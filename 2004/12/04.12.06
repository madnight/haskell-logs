00:00:01 <cm> actually.. :)
00:00:06 * cm slaps his lazy end
01:14:55 <segphault> good evening
01:22:33 * dblhelix is away: brb
02:03:14 <musasabi> morning
02:04:28 <Itkovian> hi
02:05:34 <Itkovian> Can anybody point me to some docs regarding records and their use, i.e. Data T = Tumdiedum { x :: int, y ::int } or am I completely off track here?
02:06:29 <musasabi> haskell.org/tutorial.
02:06:50 <musasabi> no that looks fine, except Int.
02:07:09 <musasabi> (It is a type and you should not forget such things)
02:14:00 <Itkovian> yeah, blame my keyb ;-)
02:14:50 <Itkovian> When I have a function F :: T -> Int, can I just say F t = t.x ?
02:19:11 * dblhelix is back (gone 00:56:38)
02:19:28 <dblhelix> Itkovian: try  f t = x t
02:21:00 <dblhelix> Itkovian: for data T = C {x :: u} you get x :: T -> u for a suitable type expression u
02:22:29 <musasabi> data type declarations declare a constructor function, accessors, the datatype and a deconstructor.
02:24:12 <Itkovian> ok, any place I can find documentation regarding this? On the haskell website?
02:24:51 <dblhelix> Itkovian: http://haskell.org/learning and http://haskell.org/definition
02:25:55 <dblhelix> Itkovian: err, the first url should be http://haskell.org/learning.html
02:26:20 <Itkovian> ok.
02:26:22 <Itkovian> thx.
02:27:00 * dblhelix is away: groceries
02:44:13 * dblhelix is back (gone 00:17:13)
02:49:00 <Itkovian> (fast shopping imho)
02:49:28 <dblhelix> super market just around the corner ;)
02:54:20 <Itkovian> with fast cahiers obviously
02:54:25 <Itkovian> *cashiers
02:54:39 <Itkovian> or is that an incorrect word?
02:56:11 <dblhelix> Itkovian: it's a correct word, but I think it's reserved for people in certain position at a bank or other financial institution
02:57:50 <Itkovian> ah, ok.
02:58:17 <dblhelix> but I'm not that sure (I'm anything but a native speaker)
04:26:15 <joke> hi all. Someone knows the meaning of the symbol $ in haskell. The emacs mode gives me type $::(a->b) -> a -> b
04:26:49 <ibid> everybody knows it
04:26:55 <ibid> ($) f x = f x
04:27:09 <joke> ibid: but me :)
04:27:11 <ibid> but the juice is in that it has very low precedence
04:27:29 <ibid> hence, f $ g x means the same as f (g x)
04:28:15 <joke> ibid: thanks :)
04:28:22 <ibid> np
04:39:13 <joke> ibid: do you know where I can read something about $?
04:40:03 <ibid> what do you want to read about it?
04:41:37 <joke> ibid: i would like to understand better how it works and put it in context. I never found it before
04:42:17 <ibid> what else do you need of it than its definition?
04:42:23 <ibid> which is f $ x = f x
04:43:11 <ibid> (oh yes, also the precedence declaration, infixr 0  $)
04:48:34 <vegai> joke: you use it if you don't like parentheses
04:49:40 <ibid> not that much a joke :)
04:50:03 <ibid> i mean, the main reason i use it is that it helps reduce the parenthesis clutter
04:50:17 <vegai> I wasn't joking =)
04:51:20 <ibid> ohh
04:51:21 <ibid> :)
04:51:25 <ibid> heh
04:51:33 <ibid> i didn't notice joke's nick :)
04:52:07 * vegai smirks
04:53:27 <joke> ibid: :)
04:53:59 <vegai> you could, for instance replace (*) 2 ((/) 4 2) with (*) 2 $ (/) 4 2
04:55:10 <joke> vegai: ok, this gives me more hints about it. Thanks
04:55:53 <ibid> vegai: did batalyx instill lispism into you?
04:56:12 <vegai> I've been studying some scheme lately
04:56:52 <vegai> no, not batalyx
04:57:04 <ibid> :)
04:57:10 <ibid> scheme rocks
04:57:22 <ibid> of course, batalyx is pure commonlisper
04:58:24 <vegai> yep. I hate it when so many non-orthogonal things rock :/
05:00:11 <ibid> heh
05:00:30 <Amadan> joke: you can also write silly crap like this: zipWith3 ($) [(+), (*), (/)] [4, 5, 6] [1, 2, 3]
05:04:05 <joke> Amadan: urgh! And what id does_
05:04:07 <joke> ?
05:04:28 <vegai> not much :)
05:04:36 <Amadan> not much :)
05:04:49 <Amadan> [4+1, 5*2, 6/3]
05:05:13 <Amadan> but there's gotta be a more useful example :)
05:05:32 <vegai> oh, I thought he asked about id :P
05:05:36 <ibid> perhaps we should have a competition, who writes the most convoluted idiomatic haskell to calculate 1+1 :)
05:06:10 <vegai> pure lambda?
05:06:18 <Maddas> ibid: You might like http://www.willamette.edu/~fruehr/haskell/evolution.html (uses Fibonacci, though)
05:06:21 <Maddas> Er, no, factorial
05:06:23 <ibid> vegai: hmm?
05:06:29 <earthy> vegai: worse: pure lambda at the type level
05:06:41 <earthy> and then with barendregt numerals instead of church numerals
05:06:56 <vegai> ibid: Church... 
05:06:57 <Oejet> print (f (3 + 4)) == print $ f (3 + 4)
05:07:01 <ibid> the requirement for idiomatic haskell means that an entry should not contain anything that a real haskell program wouldn't
05:07:05 <ibid> vegai: :)
05:07:26 <ibid> == print $ f $ 3 + 4
05:07:35 <ibid> Maddas: i've seen it
05:08:52 <ibid> how many of you get the references in "Continuation-passing Haskell programmer
05:08:55 <ibid> (raised RABBITS in early years, then moved to New Jersey)"?
05:10:04 <Maddas> I think I get it
05:11:24 <ibid> the best of them is, of course,
05:11:25 <ibid> Tenured professor
05:11:25 <ibid> (teaching Haskell to freshmen)
05:11:25 <ibid> fac n = product [1..n]
05:11:29 <ibid> :)
05:12:10 <earthy> ibid: well, SML-NJ is fully based on CPS
05:12:34 <ibid> anyway, the references question can be rephrased as "what's RABBIT, what do they do at NJ, and what they both have to do with CPS" :)
05:12:43 <ibid> earthy: how about RABBIT?
05:12:58 <earthy> that's the puzzler :)
05:13:09 <ibid> anybody know? :=
05:13:11 <Maddas> The Scheme compiler, I presume
05:13:14 <ibid> yeah
05:13:16 <earthy> google knows :)
05:13:19 <Maddas> yay :-)
05:13:26 <Maddas> (Not that I ever used it)
05:13:39 <ibid> steele invented CPS in compilers and implemented the first CPS compiler; it became RABBIT
05:13:40 <earthy> yep, it is.
05:13:57 <earthy> steele did not invent CPS, afaik
05:14:10 <ibid> not the style in itself
05:14:17 <ibid> but its use in compilers, afaik
05:14:20 <earthy> but the use for compileation, that may well be
05:14:25 <earthy> -e
05:14:28 <ibid> CPS was already known in formal semantics
05:14:34 <joke> thnaks for the clarification. later :)
05:34:49 <boegel> hey everyone
05:38:53 <boegel> hey kosmikus 
05:47:27 <boegel> hey arauko bringert andersca shammah 
05:47:51 <Muad_Dibber> netsplit :P
05:48:36 <boegel> Muad_Dibber, I know what happens when a netsplit occures, but what _is_ it ?
05:48:40 <boegel> why does it happen?
05:50:55 <Muad_Dibber> boegel: well
05:51:08 <Muad_Dibber> you know that a network exists from different servers, right?
05:51:16 <boegel> yes :D
05:51:25 <Muad_Dibber> so they get disconnected for some reason
05:51:40 <Muad_Dibber> either because an ISP has some trouble
05:51:45 <Muad_Dibber> the router behind a server breaks down
05:51:52 <Muad_Dibber> or a temporary bandwith overflow :)
05:52:13 <Muad_Dibber> so thats when the connection between some servers break, and we experience a netsplit ;)
05:52:14 <boegel> oh, so if I would keep flooding, that would cause a netsplit ? :p
05:52:36 <Muad_Dibber> well, it is very doubtfull wehter ur bandwith would be sufficient
05:52:40 <Muad_Dibber> but in essence, yeah :P
05:53:20 <boegel> arauko, did you get wxHaskell working ?
05:55:17 <arauko> boegel, Hello dude
05:55:38 <arauko> boegel, I just received an email from Daan Leijen 
05:56:14 <boegel> arauko, who's that ? :D
05:56:17 <arauko> Im trying something right now
05:56:19 <Muad_Dibber> and what did he say?
05:56:46 <arauko> You can probably fix it by editing the makefile. Add at after the
05:56:46 <arauko> include statements (line 56?) the line:
05:56:47 <arauko> HCFLAGS += $(HCFLAGS) -package parsec 
05:56:57 <delft> can someone plz help me with this im stuck
05:57:09 <boegel> delft, with what ?
05:57:11 <arauko> Im trying that right now.
05:57:17 <arauko> I hope it works.
05:57:46 <Muad_Dibber> delft: do they use haskell on TU delft or only you? :P
05:57:51 <delft> i have a list ["year,project,hour","year,project,hour""year,project,hour"]    year is int project is a string and hour is a int  
05:58:17 <delft> lol they do 
05:58:24 <Muad_Dibber> coolio
05:58:28 <Muad_Dibber> continu ur problem :P
05:58:44 <delft> and i want to sum the hours of a year of the same project
05:58:55 <delft> becouse i have many kind of projects
05:59:36 <Muad_Dibber> is the list of type [String]?
05:59:47 <boegel> delft, same question :)
05:59:56 <arauko> boegel, =
05:59:58 <arauko> Daan Leijen
05:59:58 <arauko>     The main developer and designer of wxHaskell 
06:00:02 <delft> a possible list is :   ["2001,math,6","2001,math,4","2001, blah,4"
06:00:14 <Muad_Dibber> so yeah, the list is of type string :P
06:00:38 <boegel> that's not that easy... you have to work with substrings and stuff...
06:00:39 <delft> and i have methods to get the hours the project and the year
06:00:47 <boegel> ow, you have those ?
06:00:51 <delft> yes 
06:01:01 <delft> i just need a same year methode
06:01:05 <boegel> that makes it a lot easier, doesn't it ?
06:01:08 <delft> to sum the hours of a project
06:01:23 <boegel> sameYear :: String -> String -> Bool
06:01:28 <boegel> something like that ?
06:01:45 <boegel> woehoew, Belgium is world-champion in Maths :)
06:01:52 <Muad_Dibber> blah @ belgium
06:01:54 <boegel> at least, the news says so ;)
06:02:27 <boegel> Muad_Dibber, blah ? why blah ?
06:02:43 <Muad_Dibber> lol nothing, just want to irritate you a bit ;)
06:02:44 <delft> anyone?
06:03:00 <Muad_Dibber> delft, yeah
06:03:04 <boegel> sameYear :: String -> String -> Bool
06:03:06 <boegel> something like that ?
06:03:07 <Muad_Dibber> it shouldnt be that hard
06:03:43 <Muad_Dibber> first you maken a function sortProjects -> [String] -> [[String]]
06:03:44 <boegel> delft, I don't see the problem with it either
06:03:56 <Muad_Dibber> so that each list of [[String]] contains only 1 project
06:04:04 <Muad_Dibber> then you just can calculate it all
06:04:11 <Muad_Dibber> at least, that would one way of approaching it
06:04:15 <Muad_Dibber> there are numerous others i think
06:04:37 <delft> how will sortproject will look like?
06:05:07 <boegel> delft, are you familiar with quicksort, mergesort, and such ?
06:05:17 <delft> no boagel
06:05:25 <delft> boegel*
06:05:28 <boegel> delft, you should google for it
06:05:36 <boegel> those are quite easy in Haskell
06:05:49 <boegel> I believe mergesort can be written in 2 lines or so, am I right ?
06:06:33 <Darius> Given a merge function...
06:06:54 <boegel> Darius, how about ++ >
06:06:57 <Darius> The merge function takes 3ish lines.
06:07:03 <boegel> s/>/?
06:07:08 <delft> im using qsort  
06:07:14 <delft> qsort []     = []
06:07:14 <delft> qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
06:07:14 <delft>                  where
06:07:14 <delft>                    elts_lt_x   = [y | y <- xs, y < x]
06:07:14 <delft>                    elts_greq_x = [y | y <- xs, y >= x]
06:07:25 <delft> it sort the years
06:07:27 <Darius> boegel: That's not the kind of merging necessary.
06:07:37 <delft> but it cant sum the same project hours
06:07:48 <boegel> delft, you should sort and project first, then years
06:08:01 <Darius> As a note, that qsort implementation is inefficient.
06:08:05 <boegel> Darius, i'm a bit rusty on sort algorithms, that's probably it :p
06:08:06 <Darius> asymptotically
06:09:14 <arauko> boegel, Working! Working!
06:09:24 <boegel> arauko, yaay
06:09:31 <arauko> boegel, But i also had to do other thing, i had to remove a $(HCFLAGS) reference. 
06:09:56 <boegel> arauko, what was your problem again ?
06:10:09 <arauko> makefile:482: *** Recursive variable `HCFLAGS' references itself (eventually).  Stop.
06:10:18 <arauko> Uh, stopped again, i need to remove other one.
06:10:34 <Muad_Dibber> delft, i wanted to make a remark early
06:10:44 <Amadan> delft: sortBy, groupBy, map sum?
06:10:48 <Muad_Dibber> if i were you, i would change the program a bit
06:11:16 <Muad_Dibber> so that your list would be like a list of [(int,String,int)]
06:11:17 <arauko> boegel, shoot me please :-(
06:11:29 <arauko> It throws the same error.
06:12:10 <delft> so from ["2001,math,6","2001,math,4","2001,haskell,4","2002,math,2","2002,math,6"]  i need to sort the years and then the project ?
06:12:17 * boegel takes out his gun, and pulls the trigger: BANG !
06:12:43 <boegel> delft, what do you want ? sum of hours for every year of each project ?
06:12:56 <delft> yes
06:12:59 <boegel> or sum of hours for every project of each year?
06:13:32 <delft> some of the total project hours from every year   and sorted by year
06:14:04 <boegel> then you should sort on project first...
06:14:21 <boegel> and then sort every list of strings for the same project on year
06:14:23 <boegel> then sum
06:14:29 <delft> so i should get from the example     "2001,math,10","2001,haskel,4"
06:14:32 <delft> ets..
06:15:24 <boegel> delft: sortOnProject :: [String] -> [[String]]
06:15:43 <boegel> this takes your list, and produces sublists of strings with the same project
06:15:57 <boegel> sortOnYear :: [String] -> [[String]]
06:16:12 <boegel> this takes 1 sublist from sortOnProject, and sorts the entry's on year
06:16:33 <boegel> sumStrings :: [String] -> String
06:16:44 <boegel> this sums the entry for the same year and project
06:16:51 <arauko> nothing... doesn't work.
06:17:09 <boegel> arauko, what's the problem now ?
06:17:22 <arauko> boegel, same problem.
06:17:41 <arauko> : undefined reference to `TextziParserCombinatorsziParsecziPrim_parse_closure'
06:17:41 <arauko> out/wxdirect/Classes.o(.text+0x5c51): In function `r2lZ_entry':
06:17:41 <arauko> : undefined reference to `TextziParserCombinatorsziParsecziPrim_parse_closure'
06:17:43 <arauko> collect2: ld returned 1 exit status
06:17:47 <arauko> make: *** [out/wxdirect/wxdirect] Error 1
06:17:58 <arauko> Sorry for pasteing, i didn't think it was so much.
06:18:10 <boegel> arauko, have you googles for that error ?
06:18:19 <boegel> s/googles/googled
06:18:36 <arauko> No (weirdly) i didn't
06:18:47 <arauko> That is a good next step.
06:18:58 <delft> there isnt so much references and example for haskell on the web
06:19:37 <delft> boegel whats the point of sorting it twice?
06:19:46 <arauko> delft, i got nopthing to lose ... i got this problem since yesterday.
06:19:47 <boegel> arauko, no results :s
06:19:54 <boegel> delft, because you need entry's with the same project AND the same year
06:19:56 <arauko> I think i'll re-send the email to him again.
06:20:11 <arauko> :-(
06:20:17 <Amadan> actually you can sort by year-and-project
06:20:24 <delft> yes but boegel if you start sorting of project name then all the same project name will be together  
06:20:30 <delft> and then u gonna sort by years
06:20:36 <delft> so you gonna change it 
06:20:41 <boegel> delft, no
06:20:44 <delft> so there is no need to sort twice
06:21:03 <boegel> the first sort subdivides the list into sublists, with same project-names
06:21:13 <delft> like  sort from  1,2,3  to  3,2,1  and then go back to  1,2,3  ?
06:21:22 <boegel> no
06:21:35 <delft> ohh you take the project name out of the second sort
06:21:50 <dx> hi. is there a way to install wxhaskell for ghc 6.2.1 on ghc 6.3.2? it builds fine but it doesn't seem to want to register with ghc (Reading package info from "config/wxcore.pkg" / Fail: Line 1: Invalid syntax (no colon after field name) / gmake: *** [wxcore-register] Error 1) ?
06:22:04 <boegel> sortOnProject  ["2001,math,6","2001,math,4","2001,haskell,4","2002,math,2","2002,math,6"]  = [["2001,math,6","2001,math,4","2002,math,2","2002,math,6"],["2001,haskell,4"]]
06:22:18 <boegel> on then
06:22:23 <boegel> s/on/and
06:22:36 <delft> s/om/and ?
06:22:52 <boegel> sortOnYear ["2001,math,6","2001,math,4","2002,math,2","2002,math,6"] = [["2001,math,6","2001,math,4"],["2002,math,2","2002,math,6"]]
06:22:54 <boegel> and then
06:23:32 <boegel> sumStrings ["2001,math,6","2001,math,4"] = "2001,math,10"
06:23:35 <CosmicRay> @seen shapr
06:23:36 <lambdabot> I saw shapr leaving #darcs 1 day 15 hours 13 minutes 27 seconds ago.
06:23:37 <boegel> you see ?
06:23:57 <delft> yes boegel  
06:24:05 <delft> thanks im gonna try that
06:24:16 <boegel> no doubt there is a better solution, but it will work...
06:24:34 <Muad_Dibber> boegel: isnt it like integers?
06:24:36 <Darius> You really should do what Muad_Dibber suggested and convert to a tuple first.
06:24:50 <Muad_Dibber> there is always a better solution? :P
06:24:51 <delft> how do u do that
06:25:03 <boegel> Darius, you're right, converting to tuples will make it a lot easier
06:25:11 <Amadan> yeah, but he can do it with sortOnProjectAndYear ["2001,math,6","2001,math,4","2001,haskell,4","2002,math,2","2002,math,6"] = [["2001,math,6","2001,math,4"],["2001,haskell,4"],["2002,math,6"]], i don't think he needs the second nesting level
06:25:13 <boegel> Muad_Dibber, how like integers ?
06:25:20 <Darius> boegel: And more efficient to boot.
06:25:49 <Amadan> just group by anything that is not the hour.
06:25:50 <Muad_Dibber> boegel: infinite number of integers, i++ :P
06:26:01 <Darius> delft: You said you were provided with extraction functions, simply do (extractYear x,extractName x,extractHours x)
06:26:04 <boegel> Amadan, that function will be more complicated than the two other ones... 
06:26:10 <Amadan> no...
06:26:19 <delft> yes Darius i made thos already
06:26:35 <delft> its just  a mather of sort 
06:26:44 <boegel> delft, Darius means you should convert your [String] to [(Int,String,Int)]
06:26:49 <boegel> that will make things easier
06:26:58 <delft> i already have that boegel
06:27:12 <boegel> ow, okay then :)
06:27:26 <Darius> "oh"
06:27:27 * boegel crawls back in his corner
06:27:58 <delft> lol but i still dont know how 
06:28:21 <delft> Amadan  how can you do that?  sortOnProjectAndYear
06:28:44 <goron> I want to have a constructor operator. TypeA TypeB :>: TypeC TypeD. It seems it only works with two operands. 
06:29:37 <Amadan> boegel: compareProjectAndYear a b = let projCmp = compare (proj a) (proj b) in if projsCmp==Eq then compare (year a) (year b) else projCmp
06:29:42 <Amadan> off the top of my head
06:33:24 <Amadan> then something like: sortOnProjectAndYear = (groupBy (\a \b -> (compareProjectAndYear a b) == Eq) . (sortBy compareProjectAndYear)
06:36:02 <Amadan> sorry, typos:
06:36:09 <Amadan> compareProjectAndYear a b = let projCmp = compare (proj a) (proj b) in if projsCmp==EQ then compare (year a) (year b) else projCmp
06:36:23 <Amadan> sortOnProjectAndYear = (groupBy (\a b -> (compareProjectAndYear a b) == EQ) . (sortBy compareProjectAndYear)
06:39:21 <delft> year a  is getyear a  ?
06:39:30 <Amadan> yeah...
06:43:16 <Amadan> would be even easier if you made a datatype, and implemented Ord class with the above compare function, then you just say:  group . sort
06:43:40 <delft> i have data types Amandan
06:43:51 <delft> and i have the getmethodes of it
06:44:18 <Amadan> then just make instance Ord with compare = compareProjectAndYear
06:45:04 <Amadan> gotta go. good luck
06:45:33 <delft> thx 
06:51:38 <CosmicRay> some MegaMonad quotes here: http://www.haskell.org//pipermail/haskell-cafe/2004-December/007880.html
06:51:42 <delft> i gtg ill be back at home :) bye now
06:57:57 <Darius> Yay!  Good choices for sample downloads for "The Empire Strikes First"
06:58:30 <bringert> MegaMonad: wassup?
06:58:36 <MegaMonad> bringert: Y0 nuts, wassup?
06:58:55 <bringert> MegaMonad: how about them monads?
06:59:01 <MegaMonad> bringert: For example, backtracking monads (call/cc could be as easy to make a difference.
06:59:23 <CosmicRay> MegaMonad: what do you think of bringert?
06:59:28 <bringert> MegaMonad: are monads just for side effects?
06:59:28 <vegai> what the ... "Vegai starts a summerjob as a directed graph."
06:59:29 <MegaMonad> CosmicRay: If you get what they do to me i think of bringert?
06:59:41 <MegaMonad> bringert: Ah, but the side effects on the side.
06:59:53 <vegai> MegaMonad: I'm not a graph, I'm a free man!
06:59:56 <CosmicRay> vegai: someone said "megamonad: vegai?", and that's what it thought of :-)
06:59:59 <MegaMonad> vegai: And its a very bad place to a repository, it takes a stdgen which is frankly not good for the graph in the place where semantic can index them, it probably writes a man to be free.
07:00:02 <CosmicRay> I think it was you :-)
07:00:09 <vegai> ah, privately
07:00:13 <vegai> yes
07:00:40 <CosmicRay> ah.  my conversation logs don't note original nicks, but also don't note whether it was in the channel or a msg
07:00:49 <CosmicRay> I tried to make sure to not reveal any personal information
07:00:51 <kpreid> clear
07:00:53 <CosmicRay> sorry if I goofed there
07:00:54 <kpreid> oops
07:00:56 <vegai> yeah, I don't care =)
07:01:22 <CosmicRay> I also liked his quote about Jakarta :-)
07:01:29 <CosmicRay> MegaMonad: do you still think Jakarta is evil?
07:01:35 <MegaMonad> CosmicRay: The jakarta project suffices for me to some of the evil that is included in any language you can't construct proof terms for a -> _|_ or b.
07:02:09 <vegai> there might be a problem with MegaMonad 
07:02:13 <bringert> MegaMonad: does shapr boing?
07:02:21 <CosmicRay> vegai: oh?
07:02:32 <MegaMonad> bringert: Boing is the way to only one file.
07:02:42 <vegai> newcomers to the channel may confuse his talking with conversations that Haskell experts are having...
07:02:51 <bringert> MegaMonad: you don't say
07:02:57 <MegaMonad> bringert: Probably saner to just ask about the general case is at edinburgh, and he's heavily involved in ilt.
07:03:09 <arauko> boegel, seems working now
07:03:15 * earthy grins
07:03:15 <Darius> Yes, I'm sure the indepth conversations on category theory sound very incoherent.
07:03:17 <boegel> arauko, yaay again
07:03:27 <CosmicRay> vegai: yeah, that is a concern.  to try to be safe on that, I made sure that megamonad never responds in public unless directly spoken to first
07:03:32 <bringert> MegaMonad: interactive language technology? but that project is nearly over.
07:03:39 <MegaMonad> bringert: Data point a = pt a a", a point created is not general enough to remember what it is, and there is a language to a subtype. You know what technology i want, just i can project back to outputting.
07:03:46 <earthy> megamonad could be better though ;)
07:03:49 <vegai> MegaMonad: do you feel threatened by Haskell experts?
07:03:58 <MegaMonad> vegai: Newtype may cause me to get haskell to the experts.
07:04:18 <bringert> MegaMonad: tell me about hylomorphisms
07:04:24 <MegaMonad> bringert: And people think of mutable state you where to download http, especially if you use debian, ipv6 is slower, but it is a language of hylomorphisms (which is what you mean.
07:04:25 <CosmicRay> vegai: really I think it would be cool to find a trainable AI that's smarter than megahal that could actually provide real answers in some cases
07:04:45 <earthy> that'd be quite cool indeed
07:04:51 <Darius> MegaMonad: What are zygomorphisms?
07:04:51 <bringert> MegaHal: @type map
07:04:53 <earthy> problem is, how to do that?
07:04:57 <CosmicRay> vegai: otoh, if there's some way I can message the irclogs to better fit megahal's training model
07:04:57 <MegaMonad> Darius: Um. :) In .nl it was still some rivalry there.
07:05:30 <CosmicRay> earthy: there are some quite good chatterbots out there, such as jabberwacky or prelude@#.  But they are all either 1) web-only, or 2) closed-source or Windows-only
07:05:32 <vegai> CosmicRay: perhaps Alice?
07:05:32 <CosmicRay> so I can't use them
07:05:35 <bringert> wouldn't MegaMonad learn lambdabot's answers after a while
07:05:47 <CosmicRay> vegai: from what I understand, alice does not learn, but I confess I haven't investigated it closely
07:05:53 <bringert> and be able to answer @type-questions
07:06:10 <CosmicRay> bringert: megamonad specifically ignores lambdabot to avoid any potential feedback loop issues
07:07:21 <Darius> MegaMonad: Apomorphisms?
07:07:27 <MegaMonad> Darius: Non, pas beaucoup en ce moment, hélas.
07:07:51 <Darius> *blink* *blink*
07:07:54 <CosmicRay> hah
07:08:13 <Darius> Yes, I guess using a non-English language would get high coherence.
07:09:39 <vegai> "no, not much at the moment, alas"
07:10:06 <Darius> I know little about Markov models, but likely the reason MegaMonad is so incoherent is the size and relative uniformity of the vocabulary.
07:11:20 <vegai> funny how it relates "Bush or Kerry" to "emacs or xemacs" :)
07:12:52 <CosmicRay> hehe
07:13:09 <Darius> MegaMonad: Sprechen Sie Deutsch?
07:13:15 <MegaMonad> Darius: Shapr, ich auch verstehe deutsch.
07:13:22 <CosmicRay> bwahahaha
07:13:27 <vegai> huh, why shapr :P
07:13:35 <vegai> then again, shapr speaks anything
07:13:35 <Darius> Well... I'm not shapr, but impressive!
07:13:59 <CosmicRay> speak and understand german, wow :-)
07:15:45 <earthy> MegaMonad: waarom werk je maar op zo'n beperkte subset van taalconstructen?
07:15:52 <MegaMonad> earthy: Xerox: yes, there are a subset if it looks counts a bit about that, france (and now germany it seems) have been trying to maintain wash and gf at the top of an op.
07:16:18 <Darius> MegaMonad: Nihongo hanashimasu ka
07:16:24 <MegaMonad> Darius: Feh, you know what ka means.
07:16:29 <CosmicRay> haha
07:16:43 <CosmicRay> nice cop-out
07:16:45 <arauko> It Worked!
07:16:55 <arauko> boegel, i just run my HelloWorld sample :-)
07:17:04 <arauko> I had to install libgmp though 
07:17:11 <Darius> MegaMonad: wxHaskell
07:17:17 <MegaMonad> Darius: Igloo: in wxhaskell, is the fear of getting the compilation itself then it appears twice.
07:18:02 <Darius> Sinister Rouge ho!
07:18:14 <_Codex> megamonad: Teach us some category theory? Maybe equalizers or something.
07:18:21 <MegaMonad> _Codex: In theory, this is a category, then i probably ought to do things like powers, pullbacks, equalizers.
07:18:38 <bourbi> hiho
07:18:52 <CosmicRay> good morning bourbi
07:19:09 <boegel> bourbi = bourbaki ?
07:19:25 <bringert> MegaHal: do you have any ideas for sharing strings?
07:19:34 <bringert> MegaMonad: do you have any ideas for sharing strings?A
07:19:38 <bringert> I mean
07:19:40 <MegaMonad> bringert: School-lab, prefer not to tell me i have been bad at remembering intersting ideas of the code sharing.
07:20:04 <bringert> MegaMonad: you're not answering the question
07:20:10 <MegaMonad> bringert: I'm pretty sure that i'm the same question you were answering my questions that have cwd=~ and then kills any that aren't types then.
07:20:11 <Darius> MegaMonad: Bad Religion
07:20:17 <MegaMonad> Darius: Unfortunately, i know is that darcs has a *weird* religion.
07:20:32 <bourbi> bourbi ?s bourbaki yes :)
07:20:45 <Philippa> give or take a grammatical correction that's quotable
07:20:54 <CosmicRay> hehe
07:22:40 <boegel> bourbi, what happened with bourbaki ?
07:22:46 <bringert> MegaMonad: how big is your monad?
07:22:53 <MegaMonad> bringert: Both my best place to get my code needs to be some revival once the list monad is riastradh?
07:23:10 <boegel> he's not making _any_ sense :)
07:23:32 <bourbi> nothing im in the lab and dont want others to see my password :)
07:23:36 <vegai> MegaMonad: could you explain to a newbie what monads and arrows are?
07:23:38 <boegel> what a weird dude, but a fast typer dough :p
07:23:44 <MegaMonad> vegai: Riastradh: you explain monads to the newbie, that the concept of semantics? "The meaning of () in this example : http://cs-www.cs.yale.edu/arrows.
07:23:55 <boegel> he answered ! 
07:23:59 <boegel> :D
07:24:07 <vegai> he seems to be fixed on Riastradh now
07:24:16 <boegel> heh ;)
07:24:17 <vegai> MegaMonad: do you have a crush on Riastradh?
07:24:27 <Darius> CosmicRay: Maybe you should just make a MegaMonad wiki page.
07:24:28 <MegaMonad> vegai: I agree with riastradh in the io() is coming from the mailing lists showed how to crush.
07:24:46 <bringert> MegaMonad: when will ghc 6.4 be out?
07:24:48 <Darius> MegaMonad: What are some useful HaWiki pages?
07:24:52 <MegaMonad> bringert: Pop :: stack a -> (a,a)  it's in ghc4 i think. Even if that gult bug is located on a mission to get the hightest node number of lines of code it in the length of the 6.4 will be wxhaskell.
07:24:58 <MegaMonad> Darius: -- File into a .so file at the pages in the hawiki.
07:25:08 <CosmicRay> Darius: probably a good idea
07:27:26 <Maddas> MegaMonad: Why do you like Haskell?
07:27:32 <MegaMonad> Maddas: And dislike the version number separated by a number of haskell i find the average function that calculates how many bit a while for the winter. I'd be completely seperated, but that requires constraints as parameters to foo above gets transformed by the cs field is that + division.
07:27:43 * Maddas laughs
07:28:02 <boegel> MegaMonad, who is writing a raytracer ?
07:28:09 <MegaMonad> boegel: S'okay, i couldn't figure out what a composition of a raytracer.
07:28:15 <bringert> MegaMonad: life, the universe and everything?
07:28:19 <boegel> MegaMonad, boegel raytracer
07:28:21 <MegaMonad> bringert: If it's in the universe.
07:28:22 <earthy> 42
07:28:27 <boegel> lolz
07:28:27 <MegaMonad> boegel: Have a good change. There's only so far) was a raytracer. I think it won't while i'm doing this raytracer... So i exploit that in imperative languages :p.
07:32:09 <Darius> MegaMonad: ML syntax
07:32:16 <MegaMonad> Darius: Syntax isn't the right-hand-side of the syntax highlighting differ from subversion in that syntax currently, though.
07:38:53 <bourbi> bogel any progression yet on your raytracer?
07:43:28 <bourbi> am i still in here?
07:43:50 <arjanb> ?
07:44:11 <Itkovian> yes you are.
07:44:15 <bourbi> heh just because i didnt get an answer :)
07:44:28 <bourbi> sometimes the connection seems to time out
07:44:34 <Itkovian> a minor case of existential doubt
07:44:40 <bourbi> :)
07:44:52 <Itkovian> you type, thus you are
07:46:06 <CosmicRay> heh
07:46:39 <bourbi> but sometimes you type in a channel and dont get a response
07:48:07 <Darius> Itkovian: Pssh.  Me, I'm sure about.  It's the rest of you that're questionable.
07:49:38 <boegel> bourbi, I'm still working on the transparency stuff... not much, but now and then
07:49:55 <Darius> Any radiosity?
07:50:00 <boegel> bourbi, http://studwww.ugent.be/~kehoste/thesisPublic/website/transp/
07:50:04 <boegel> Darius, no :)
07:50:17 <boegel> transparency is the last thing I'll get working, for now at least
07:52:37 <Darius> Are you optimizing hit-testing in anyway or just using the naive algorithm?
08:02:45 <Oejet> MegaMonad: Test.
08:02:51 <MegaMonad> Oejet: Yeah i use to test with.
08:03:24 <CosmicRay> heh
08:03:57 <CosmicRay> MegaMonad: oejet left quickly.
08:04:03 <MegaMonad> CosmicRay: What, just refuse to be left or left to do it, but it shows ip or hostname, not always including the detail and build up quickly.
08:04:25 <tumm_>  is there someone who is familiar with haskelldb awake?
08:04:46 <boegel> Darius, I'm using the native algorithm... no bounding boxes or other nifty stuff...
08:06:02 <WobL> shplonk
08:06:31 <Philippa> 'lo
08:06:51 <Philippa> hrmm, shapr's not in here atm, if you're unlucky I might be the one on tutorial duty for a while :-)
08:07:07 <Spark> heh
08:07:16 <CosmicRay> Philippa: better you than MegaMonad :-)
08:07:19 <Darius> MegaMonad: @seen shapr
08:07:28 <MegaMonad> Darius: Http://shapr.homelinux.net:9673/shae_stuff/xmlrpc/" "add2num.py" 4 2.
08:07:39 <vegai> 4 2!
08:07:49 <CosmicRay> @seen shapr
08:07:49 <lambdabot> I saw shapr leaving #darcs 1 day 16 hours 57 minutes 41 seconds ago.
08:07:54 <CosmicRay> that's unusual for shapr
08:07:57 <CosmicRay> hope he's ok 
08:08:55 <Philippa> you never know, he might've developed the horrible condition known as "a life"
08:09:07 <CosmicRay> surely not shapr!
08:11:27 <tintin> maybe he is out on his monocycle 
08:11:37 <tintin> biking in the mountains :)
08:11:53 <Spark> maybe he's in a crack house
08:12:05 <Spark> talking to people about monads, completely off his tits
08:12:39 <CosmicRay> heh
08:13:50 <tumm_> :)
08:14:01 <CosmicRay> MegaMonad: is shapr on crack?
08:14:13 <MegaMonad> CosmicRay: Urchin.earth.li/~ian/haskell-policy/ might be interesting to actually run many things that would be nice if emacs was as a parser in haskell (i think one is on crack.
08:15:26 <Philippa> MegaMonad: shapr has multiple personalities?
08:15:32 <MegaMonad> Philippa: Smerdyakov, but not a multiple of that could be effected by judicious use of other keys is easy to store it as the sorts of personalities.
08:16:00 <vegai> shapr is Smerdy?!
08:17:57 <tumm_> anyway, i'm doing an insert in haskelldb, pretty basic stuff,  insert db W.wiki_pages (W.page << const key), but it cant match Database.HaskellDB.HDBRec.RecNil against ...RecCons
08:30:40 * Igloo wonders if CosmicRay realises "Simon^2 expands to simon simon" is pretty much an exact quote of a real person
08:31:17 <bringert> MegaMonad: anyway, i'm doing an insert in haskelldb, pretty basic stuff,  insert db W.wiki_pages (W.page << const key), but it cant match Database.HaskellDB.HDBRec.RecNil against ...RecCons
08:31:23 <MegaMonad> bringert: Haskelldb to the test program for making everyone learn all the db and the key to me.
08:31:39 <Spark> Darius: can you point me in the direction of some decidable intersection type systems, and especially any that have actually been used in languages (other than forsythe)
08:31:47 <bringert> hmm, only slightly better than what I told tumm_
08:31:49 <Spark> or anyone else for that matter :)
08:32:42 <Philippa> MegaMonad: what is the answer?
08:32:48 <MegaMonad> Philippa: But the longer answer is to work with a trout.
08:32:54 <bringert> haha
08:32:59 <bringert> MegaMonad: why a trout?
08:33:06 <MegaMonad> bringert: Ebml is xml, but with work coming closer and closer, i'm not convinced that the a should be bound to find the efficient sets with a trout.
08:33:06 <Darius> Google Polar Type inference 
08:33:45 <bringert> MegaMonad: sure, but why a trout? wouldn't a cod do?
08:33:50 <Darius> Spark: Intersection type inference is decidable for any finite rank restriction.
08:33:52 <MegaMonad> bringert: Wouldn't you have problems with a trout.
08:34:03 <bringert> MegaMonad: my point exactly
08:34:09 <MegaMonad> bringert: Musasabi: my point is that they have static properties, and rewriting it with unsafeinterleaveio i guess, java is not exactly your problem exactly?
08:34:21 <Spark> Darius: i havent looked at the rank restrictions, wheres a good place to start?
08:34:50 <Spark> everytime i try and read a paper it assumes some knowledge i dont have and i end up DFSing into a sea of papers and totally losing track of what i wanted to find out
08:34:57 <bringert> MegaMonad: unsafeInterleaveIO a trout? very interesting. have you tried that yourself?
08:35:03 <MegaMonad> bringert: Interesting. Do you also hang out with a trout.
08:35:19 <Philippa> Spark: save the papers on your HD, come back to them
08:35:26 <Spark> i print them off :)
08:35:27 <Philippa> categorise them as you DL, recategorise where useful
08:35:31 <Spark> then you get *piles* of papers
08:35:33 <Darius> http://types.bu.edu/reports/Carlier:ITRS-2002.html
08:35:44 <Darius> Spark: Yes, DFSing is the way it works.  
08:35:51 <Darius> I wouldn't recommend printing though...
08:36:08 <Darius> Spark: And the Church Project in general: http://types.bu.edu/reports/
08:36:35 * Darius has over 1400 research papers
08:37:32 <Spark> heh
08:37:44 <bringert> MegaMonad: when did you meet this trout?
08:37:51 <MegaMonad> bringert: I want me to tell me you must undertake a big trout.
08:38:30 <bringert> MegaMonad: wouldn't it be better to tell me that?
08:38:36 <MegaMonad> bringert: Syntaxninja: wouldn't you be at you if you hear about type theory from what i am going to be symmetrical, one should thus use them right now.
08:39:43 <Darius> Spark: Sometimes just trying to find a paper in my collection makes me lose track of what I was doing.  The chunk of papers I have on full-text indexing is in part inspired by heap.
08:40:03 <Spark> heh
08:40:09 <Spark> you need a minigoogle
08:40:15 <Spark> or, maybe grep
08:40:18 <Spark> :)
08:40:58 <Darius> PS and PDF files aren't nicely greppable and I'd rather not keep generated text-files around just to search them.
08:41:25 <Spark> mm
08:41:37 <Darius> (Though if I hadn't used stopwords I could do a good job of recreating text files for all my papers from the postings file)
08:44:30 <tautologico> MegaMonad, good afternoon
08:44:36 <MegaMonad> tautologico: And wants to own a copy but its sort of time will make people understanding well what they mean with "force dependency to libstdc++ from hs-fltk.
08:46:34 <musasabi> MegaMonad: hs-fltk does not currently depend on libstdc++ (killed that because it was causing all kinds of evil linker nastiness), but it depends on libfltk, which in turn depends on libstdc++.
08:46:40 <MegaMonad> musasabi: Causing all the times i thought it was because it has killed a few getopts in haskell.
08:47:10 <musasabi> hmm?
08:47:19 <tautologico> lol
08:47:32 <tautologico> MegaMonad, what do you think of musasabi ?
08:47:37 <MegaMonad> tautologico: Esap: it sometimes happened to me and i to think of musasabi ?
08:48:22 <tautologico> MegaMonad, what about unicycles ?
08:48:28 <MegaMonad> tautologico: So, so f1 unicycles would have used x and y is from my compiler, ghci.
08:50:35 <musasabi> ohh. now I understand :-)
08:50:54 <tautologico> :)
08:51:04 * musasabi is a little bit tired about party lasting to 6am and the train trip back.
08:51:22 <tautologico> musasabi: the last bit on the topic was by MegaMonad
08:52:17 <SyntaxNinja> it's like I never left...
08:52:32 <tautologico> :)
08:53:36 <SyntaxNinja> MegaMonad: have these guys been talking to you all night? is anyone getting any work done?
08:53:42 <MegaMonad> SyntaxNinja: Anyone talking to the work.
08:53:57 <tautologico> not me, I just got here and said hi to him :)
08:54:41 <SyntaxNinja> :)
08:54:44 <xerox> @get-definition zip
08:54:45 <lambdabot> zip = zipWith Pair
08:54:55 <xerox> @get-definition zipWith
08:54:55 <lambdabot> zipWith = \f l r.if null l || null r then [] else f (head l) (head r) :
08:54:55 <lambdabot> zipWith f (tail l) (tail r)
08:58:39 <Spark> can someone give an example of what typings have to be explicit, i.e. cant be inferred through the type system
09:01:16 <Igloo> In theory none in H98
09:01:33 <Darius> Igloo: Ambiguity with type classes and polymorphic recursion.
09:01:36 <TheHunter> (modulo monomorphism restriction)
09:01:39 <Lor> Monomorphism restriction notw... echo.
09:03:02 <Igloo> Good point - I clearly haven't had enough chocolate yet today  :-)
09:03:47 <Darius> Hindley-Milner type inference requires no explicit type signatures.
09:04:11 <Spark> how does it differ to damas milner?
09:04:23 <SyntaxNinja> Spark: but also you might want to give a  less general type than the inferred type.
09:04:25 <Spark> im trying to relate to a statement in the first few paragraphs of that paper
09:04:38 <tautologico> Spark: it's hindley-milner-damas
09:04:48 <Igloo> ISTR it's identical, but the people you name depend on whether you are an ML person or a Haskell person
09:05:03 <Spark> heh
09:06:08 <Spark> Darius: but section 1.1 in http://types.bu.edu/reports/Carlier:ITRS-2002.html
09:11:59 <tautologico> is anyone aware of recent work with linear types ?
09:12:21 <Darius> tautologico: Google
09:12:36 <Spark> ah, you have to explicitly type self application with hm
09:13:16 <Darius> @type id id
09:13:18 <lambdabot> id id :: forall a. a -> a
09:13:18 <tautologico> Darius: yes, I know google :) maybe someone here would have a lead
09:13:44 <Spark> @type \x.x x
09:13:45 <lambdabot> bzzt
09:13:52 <Spark> syntax error? :)
09:14:11 <Spark> @type \x x x
09:14:12 <lambdabot> bzzt
09:14:17 <Darius> @type \x -> x x
09:14:18 <lambdabot> bzzt
09:14:47 <Spark> @type (\x -> x x) id
09:14:49 <lambdabot> bzzt
09:14:55 <Spark> @type (\x -> x) id
09:14:56 <Darius> tautologico: What aspect linear types are you interested in?
09:14:57 <lambdabot> (\x -> x) id :: forall a. a -> a
09:15:03 <Spark> so thats the answer hten
09:15:07 <Igloo> Hmm, it should really differentiate between type and syntax errors
09:15:25 <Spark> saying something other than 'bzzt' might be helpful :)
09:15:28 <Darius> Spark: When you show that you can give a type for \x -> x x at all in HM.
09:15:32 <Spark> reminds me of the bbc micro and "Mistake."
09:16:14 <Spark> is this paper just wrong then
09:16:29 <Spark> is he confusing 'requires type annotation' with 'cannot be expressed in the type system'
09:17:16 <Darius> No.  There are systems that require type annotations to type some terms, e.g. HM extended with polymorphic recursion.
09:17:26 <tautologico> Darius: for now I'm just surveying applications of linear logic... I was browsing through citeseer and it seems that linear types aren't receiving much attention nowadays... I wonder why
09:17:33 <Philippa> and then there're a lot of people who refused to create such a system
09:19:20 <Spark> what is polymorphic recursion?  it sounds like the sort of thing you can do in plain ML
09:19:35 <Spark> or is that mycroft's type system
09:20:10 <Lor> Polymorphic recursion happens when a polymorphic function calls itself recursively with a _different_ type argument.
09:20:45 <Darius> Spark: ML doesn't have polymorphic recursion (unless that's changed since last I checked) Haskell does.
09:21:08 <musasabi> Lor: is (==) on lists thus polymorphically recursive?
09:21:30 <tautologico> no polymorphic recursion in ML
09:23:15 <Lor> musa, (==) just takes a dictionary and retrieves an instance from it.
09:23:16 <Spark> hm can you give me an example of a function that does that?
09:26:52 <Spark> Darius: is it generally the undecidability of the inference algorithm that makes type annotations necessary?
09:31:04 <Darius> Spark: That's at least one situation.  Infererring polymorphic recursive types is undecidable.
09:31:55 <Darius> Spark: I'm trying to recall an algorithm I had that called itself on the list tupled up with itself.  I think bitreversal permutation can be expressed that way with polymorphic recursion.
09:32:16 <Spark> mm
09:32:34 <CosmicRay> Is there a place where I can see the equivolent of http://www.haskell.org/ghc/docs/latest/html/libraries/index.html, but for the CVS version of ghc/fptools?
09:33:02 <bringert> MegaMonad: what can you tell me about alex and string sharing?
09:33:02 <Darius> Also, on that Church reports page there is a paper: Programming Examples of Polymorphic Recursion.
09:33:08 <MegaMonad> bringert: M-p-h: list of string are you sharing.
09:33:24 <bringert> MegaMonad: I prefer a HashTable
09:33:30 <MegaMonad> bringert: You got a hashtable to implement something similar by using sharing; there's also a hashtable again.
09:33:31 <Spark> k
09:33:32 <Spark> ok
09:36:01 <SyntaxNinja> we need a wiki page for megamonad quotes
09:36:15 <tautologico> yep
09:38:54 <tautologico> MegaMonad, do you like linear logic ?
09:39:00 <MegaMonad> tautologico: Linear in the logic be in the i combinator do again ?
09:43:32 <Darius> Spark: bitreverse [x] = [x]; bitreverse xs = uncurry (++) $ unzip $ bitreverse $ pairUp xs where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs
09:44:14 <Spark> blimey
09:50:31 <Darius> @define bitreverse \l.if null l then [] else if null (tail l) then l else uncurry (\x y.x++y) (unzip (bitreverse (pairUp xs)))
09:50:31 <lambdabot> bitreverse defined
09:50:44 <Darius> @eval bitreverse $ fromTo 0 15
09:50:44 <lambdabot> unbound variable: xs
09:50:56 <Darius> @define bitreverse \l.if null l then [] else if null (tail l) then l else uncurry (\x y.x++y) (unzip (bitreverse (pairUp l)))
09:50:57 <lambdabot> bitreverse defined
09:50:57 <Darius> @eval bitreverse $ fromTo 0 15
09:50:59 <lambdabot> [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]
09:52:06 <Janni> Is readFile slow on big files in general?
09:52:27 <Darius> It depends on what you are doing.
09:53:02 <Darius> Though lazy lists do have a good chunk of overhead.
09:53:02 <Janni> I guess due to lazy evaluation it can happen that there will be _very_ many read operations that only read a small amout of bytes?
09:54:05 <Darius> Janni: I don't see how that could happen, unless you mean seeking.
09:54:09 <Philippa> Janni: it /can/ happen, though IIRC GHC at least does block IO
09:54:20 <Philippa> Darius: handle set to work byte-at-a-time
09:55:25 <Darius> Philippa: I was thinking of extra reads, but yes, buffering should be the same as whatever you set it to.
09:56:37 <Janni> OK. AFAISee, my performance problem isn't because of IO...
09:56:37 <bringert> anyone know what a stg_ap_1_upd_info is?
09:56:48 <bringert> I've got tons of them in my heap
10:01:01 <Igloo> I'd guess an application, but I don't know
10:02:47 <Darius> A lazy application presumably from the' upd'
10:04:24 <marcot> Hello, I'm having a problem in making an instance of a class. I want to do an instance for types that are in the class Num, and the for Bool. So I've done:
10:04:31 <marcot> instance Num a => Zeros a where
10:04:36 <marcot>     zero = 0
10:04:42 <marcot> instance Zeros Bool where
10:04:59 <marcot>     zero = False
10:05:08 <Igloo> The problem is someone might later make an instance Num Bool
10:05:22 <Igloo> You need to enable overlapping-instances if you want to do that
10:05:26 <marcot> Igloo: hum... I understand.
10:05:49 <marcot> Igloo: is doing this an elegant solution?
10:06:00 <marcot> Igloo: I mean, overlapping-instances enabled?
10:06:09 <Igloo> Well, you wouldn't catch me doing it  :-)
10:06:40 <marcot> So, how could I solve this problem better?
10:06:49 <marcot> doing: instance Num Int where zero = 0
10:06:55 * musasabi just used overlapping instances.
10:07:02 <marcot> instance Num Integer where zero = 0
10:07:39 <Igloo> You could enumerate them all like that. You could make an instance Num Bool yourself
10:07:46 <marcot> When I use overlapping instances, which one is used? The last declared?
10:08:00 <Igloo> The most specific
10:08:00 <musasabi> the most specific one.
10:08:18 <marcot> Igloo: I think that doing an instance of bool is a good solution.
10:08:40 <Igloo> It's not entirely pleasant either, but is at least H98
10:09:08 <marcot> The code I'm doing is for a Thesis. It should be the most elegant as possible.
10:09:28 <marcot> How can I solve it then? Enumerating instances is the better solution?
10:12:09 <Igloo> Is enumerating instances feasible? If so I'd probably do that
10:13:50 <marcot> Igloo: ok, I'll do this way then. For now is just Int from Num, but it can get bigger.... no problem then, thanks all.
10:14:07 <Darius> Another possibility is to explicitly wrap Num types, and have instance Num a => Zeros (NumType a).
10:14:49 <Darius> With constant overloading it wouldn't hurt readability.
10:15:01 <marcot> Darius: I thought about it too, but it's not a very beautiful solution either.
10:15:22 <marcot> Darius: It's not about readability, it's about elegance.
10:16:05 <Muad_Dibber> arent these 2 related?
10:17:15 <marcot> Muad_Dibber: yes, they are, but in this case I think that overlapping-instances is readable but not elegant, mainly because it's not in H98.
10:17:17 <Spark> i dont think the lambda calculus is very readable :)
10:18:03 <Muad_Dibber> well
10:18:12 <Darius> Spark:  It is pretty damned good for a minimalistic foundational calculi.  I could leave you with a Turing machine...
10:18:14 <Muad_Dibber> whether something is readable is quite commonly accepted
10:18:22 <Muad_Dibber> although elegancy really is a matter of taste i think?
10:18:59 <marcot> Muad_Dibber: you have a point.
10:20:15 <Darius> Well between NumType and listing the instances they are about the same.
10:21:19 <Philippa> Spark: \calc with use of equations (think let) and arbitrary whitespace can be reasonably readable
10:21:24 <Darius> The end user will have to add a redundant instance of Zeros for types in Num with the latter or simply give the type NumType TheirType in the former.
10:23:26 <Darius> Spark: About the only ugly part is dealing with matching multiple arguments.  Case analysis can be encoded in a fairly pretty form, but unfolding pattern matching into cases is quite complicated for some things.
10:23:50 <Spark> Darius: i suppose it is better than the turing machine, yes
10:24:26 <Spark> i think the problem is that you dont perceive much of the structure of the term from its concrete syntax
10:25:26 <Spark> that might just be my lack of experience though...
10:25:32 <Darius> Um, assuming one allows naming of lambda terms, the code looks -just- like fp code.
10:25:51 <Spark> ah i wasnt allowing that
10:26:24 <Spark> hm, lc with naming of terms, thats the polymorphic lambda calculus isnt it
10:26:37 <Darius> Well, you don't really need to, you can encode it by abstracting every free function.
10:27:20 <Darius> Spark: I just mean being able to write, id = \x.x.  Recursive uses wouldn't be allowed.
10:27:32 <Spark> yeah
10:27:41 <Spark> if you have recursion, does it become a term rewriting system?
10:27:50 <Spark> or does it become a term rewriting system if you have names on the right hand side too
10:28:05 <Spark> hang on, without names on the right and without abstraction is a combinator system
10:28:14 <Darius> The names simply get macro expanded out before any reduction.
10:28:36 <Darius> They are just names for terms and have no semantic significance.
10:28:40 <Spark> right
10:29:14 <Spark> but thats not the syntax of the lc though, and if you introduce let, then you lose some of the elegance, right?
10:29:32 <Darius> If recursive uses of names were allowed, it'd simply expand into a usage of a fixed point combinator.
10:29:52 <Spark> yeah sure
10:30:04 <Darius> Spark: 1) It's meta syntax, 2) it can actually be done easily inside the lambda calculus as well.
10:30:45 <Spark> inside the lambda calculus being (\x.x blah x blah x) (definition of x)?
10:30:54 <Darius> Yes.
10:30:59 <tautologico> let is just a lambda
10:31:08 <Spark> nah the syntax of let is the other way round
10:31:14 <Darius> (or a bit more complicated for mutually recursive bindings)
10:31:28 <Spark> ooh how do you do those
10:31:34 <Spark> two arguments?
10:32:23 <Darius> Well, first you make a fixpoint combinator for recursive bindings, then mutually recursive bindings become a fixpoint of a function of tuples and you project each element to the functions.
10:32:37 <Spark> ahh
10:33:33 <Darius> @eval take 10 $ fst $ fix (pair (\a b.Pair (1:b) (2:a)))
10:33:56 <lambdabot> out of fuel - use @resume to continue
10:34:32 <Darius> @eval take 10 $ fst $ fix (\p.Pair (1:snd p) (2:fst p))
10:34:33 <lambdabot> [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
10:34:46 * Philippa decides that deriving Read is an extremely lazy but nice way to generate a config file format for a quickie script
10:35:21 <Lor> Isn't that the point of it?
10:35:25 * Darius therefore demonstrates the difference between f (x,y) = (1:y,2:x) and f ~(x,y) = (1:y,2:x)
10:36:30 <Darius> The translation of the above fix (or rather untranslation) could be let a = 1:b;b = 1:a in a
10:36:46 <Darius> (change the second 1 to a 2)
10:38:56 <Igloo> Does anyone happen to know if Conniver would be described as a functional programming language?
10:39:56 <Darius> I don't know, but I'd lean toward it being likely.
10:42:14 <CosmicRay> MegaMonad: is Conniver a functional programming language?
10:42:20 <MegaMonad> CosmicRay: A language for the same key. Ok. Let me know if conniver would be functional.
10:43:03 <Darius> Igloo: Are any papers or manuals for Conniver lying around somewhere?
10:43:25 <musasabi> what kind of thing is conniver? (text console)
10:43:54 <Darius> Presumably he means the language between PLANNER and SCHEME(R)
10:45:45 <Igloo> Darius: Not that I can easily find. I've just gone with "Conniver and LISP" to cover myself  :-)
10:47:00 <Darius> Well the CONNIVER manual is seemingly an MIT AI memo, but I'm not sure if MIT has kept -all- of them (in a publically accessible location) and don't care enough to look myself.
10:47:50 <Igloo> Sure, I was just wondering if anyone happened to know
10:50:27 <Darius> Igloo: Can I ask what this is for?
10:50:30 <Spark> does mu sometimes mean fix?
10:50:38 <Darius> Spark: Essentially, yes.
10:50:59 <Spark> okey dokey
10:51:14 <Spark> im finding that paper on polymorphic recursion examples very accessable :)
10:53:28 <CosmicRay> <MegaMonad> Dustin`: that's what i think igloo's answer is hard in a week of school.
10:54:38 <delft> i have a program when i enter main it read from a file and put something else in another file     i want to check (debug) the uitput of some function the program used  how do i do that?
10:55:28 <Muad_Dibber> uitput == output
10:55:39 <Igloo> Darius: Just giving a quick history of quasiquotation
10:55:48 <Muad_Dibber> delft: use ghci?
10:56:01 <delft> im using hugs
10:56:18 <Muad_Dibber> well
10:56:19 <delft> what do you mean uitput == output ?
10:56:25 <Muad_Dibber> lol
10:56:33 <Muad_Dibber> uitput is not really english, more like dutch :)
10:56:35 <delft> lol yea 
10:56:38 <xkb> lol
10:56:39 <delft> haha sorry
10:56:49 <delft> yes output == uitput :D
10:56:55 <xkb> well your name kinda gives it away :D
10:57:22 <Muad_Dibber> xkb, so does his (and your and mine) whois ;)
10:57:29 <xkb> :P
10:57:32 <delft> :)
10:58:20 <delft> so how can i check the output of the function i want in the programm 
10:58:30 <Muad_Dibber> just call the function?
10:58:32 <delft> its not like java give a println 
10:58:35 <Muad_Dibber> like manually?
10:58:48 <delft> but im reading from a .txt file
10:59:05 <CosmicRay> delft: what is the function returning?
10:59:17 <CosmicRay> delft: if it's an IO (something), then you can just use putStrLn
10:59:27 <CosmicRay> delft: otherwise, the output will always be the same for a given input.
10:59:39 <CosmicRay> delft: therefore your problem becomes one of isolating the inputs
10:59:48 <CosmicRay> delft: once you have done that, it's trivial to test it in hugs or ghci
11:00:09 <Muad_Dibber> CosmicRay, right, and thats exactly the point of a functional language :)
11:01:03 <delft> CosmicRay: my function returns a type i made
11:01:34 <delft> CosmicRay: putStrLn(my_function s)  ? 
11:01:50 <CosmicRay> delft: you could probably say print (my_function s)
11:02:05 <CosmicRay> delft: you will have to make your type an instance of Show for that to work, though
11:02:18 <CosmicRay> delft: if it's a datatype, usually you can do that by just adding "deriving (Show)" at the end
11:02:40 <CosmicRay> you could also say putStrLn (show (my_function s))
11:02:44 <delft> its a type
11:02:49 <CosmicRay> or alternatively putStrLn $ show $ my_function s
11:02:55 <xkb> deriving is so neat :D
11:03:05 <CosmicRay> if it's declared with "type", then you're safe (as long as it doesn't reference anything else that's not an instance of Show)
11:03:20 <delft> yes its "type"
11:03:33 <delft> thanks CosmicRay im gonna give it a try
11:03:38 <Darius> CosmicRay: print = putStrLn . show
11:03:58 <CosmicRay> right
11:04:33 <Darius> Why would someone want to say putStrLn $ show foo when they can just do print foo?
11:05:00 <CosmicRay> Darius: I was just illustrating what print foo is doing
11:05:07 <Darius> Okay
11:05:39 <xerox> CosmicRay, how putStrLn $ show $ my_function s is different from putStrLn . show . my_function s ?
11:06:23 <xerox> i mean putStrLn . show . my_function $ s
11:06:45 <delft> where do you put print (my_function s)   ?  
11:06:53 <delft> under my function?
11:07:02 <Igloo> xerox: It isn't
11:07:21 <CosmicRay> xerox: those are the same
11:07:35 <CosmicRay> delft: you would have to do that where you call the function
11:07:42 <delft> becouse its saying (unexpected symbol "s"
11:07:44 <xerox> Ah, ok.
11:08:36 <delft> thats the function i want to print
11:08:37 <delft> firststep :: [Char] -> [Projec]
11:08:38 <delft> firststep s = (qsort   ( map (makeProject) (lines s))   ) 
11:08:40 <xerox> i just know that $ is needed in composition, but why? (referring to the second expression)
11:08:56 <delft> where must print (firststep s) come ?
11:09:01 <CosmicRay> xerox: because "my_function s" is not a function
11:09:13 <delft> damn out of cigarets  :(
11:09:15 <CosmicRay> xerox: that is, the expression (my_function s) is a string, or whatever
11:09:21 <CosmicRay> xerox: and (.) only applies to functions
11:09:38 <CosmicRay> delft: wherever you call (firststep s)
11:09:40 <CosmicRay> delft: is your code huge?
11:09:55 <CosmicRay> delft: if not, you could maybe just post it on the wiki paste page and I could lookat it for you
11:10:18 <delft> where is wiki paste page 
11:11:06 <CosmicRay> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:11:29 <Spark> can i ask a big favour from someone: i'd like a latex file for a paper on type theory, because i think that would be the quickest way to learn how to express the things i need to express in my own document :)
11:11:52 <xerox> CosmicRay, ah! got it.
11:13:18 <Igloo> Spark: Look for the inference latex package
11:13:34 <Igloo> Err, maybe not
11:13:39 <Spark> :o
11:13:58 <Igloo> Ah, infernce. Might be part of semantic.
11:14:12 <Spark> i may already have it
11:15:48 <Spark> i shouldnt think it would need a new class though
11:15:59 <pesco> Moin
11:16:10 * pesco smashes his keys
11:16:45 <delft> CosmicRay  my code is in dutch lol
11:17:20 <Igloo> Neither of those are classes
11:18:21 <marcot> I have a doubt about composition. If I have a function f :: a -> b -> c, a g :: c -> d, can I make h :: a -> b -> d; h = g . f ?
11:18:54 <Darius> @type (.) . (.)
11:18:55 <lambdabot> (.) . (.) :: forall a b c a1.
11:18:55 <lambdabot> 	     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:19:07 <marcot> It's not working here, how can I solve this composition problem with 2 parameters in the f function?
11:19:26 <CosmicRay> where in setup.description can I tell cabal to pass -O to ghc?
11:19:30 <marcot> Darius: hum...
11:19:42 <CosmicRay> doo I have to use options-ghc?
11:19:45 <Darius> @type curry (g . uncurry f)
11:19:46 <lambdabot> bzzt
11:20:13 <Darius> @type \f g -> curry (g . uncurry f)
11:20:15 <lambdabot> \f g -> curry (g . uncurry f) :: forall c c1 a b.
11:20:15 <lambdabot> 				 (a -> b -> c1) -> (c1 -> c) -> a -> b -> c
11:22:54 <marcot> Darius: thanks.
11:23:24 <arjanb> marcot: or use  (g .) . f
11:23:57 <Darius> Or of course, you could simply define compose2 g f a b = g (f a b) or simply eta expand.
11:28:45 <pesco> Can someone tell me why my code is working? http://www.scannedinavian.org/~pesco/code/Regex/Pesco/Regex.lhs subsection "Substitution"
11:30:09 <pesco> There, class Subst has an instance with the method undefined. That instance is required, if not present, GHC complains it cannot find a suitable instance for the usage of subst somewhere else in the code.
11:31:09 <pesco> Still, appearently, when the method is actually called, the more specific instance is called, which is what I want.
11:31:54 <pesco> So why does the typechecker need the more general instance which I cannot define while that is not even the instance being called in the end?
11:32:42 <Darius> What use does it complain about when you omit the instance declaration?
11:34:59 <pesco> test = ...,  see http://www.haskell.org/hawiki/HaskellIrcPastePage
11:36:34 <pesco> Erm wait. Are you getting the error?
11:37:24 <wagle> looks like his last instance is overlapping the 2nd and 3rd
11:38:10 <pesco> Right, but that's not the problem, but wait. I can't reproduce the error now!
11:38:14 <pesco> I'm utterly confused.
11:38:58 <wagle> it needs to know which of the overlapping instances to use, and i dont know how it decides when it can decide and when it cant
11:40:26 <pesco> Ok, I don't know what I did, but it works now.
11:40:36 <pesco> I can remove the general instance.
11:40:37 <Igloo> If I want to break meta-programming down into "template meta-programming" and "foo", can anyone think of a good word for foo?
11:41:03 <Philippa> what's covered by "template meta-programming"?
11:41:25 <Philippa> generative code-type stuff where there's no preprocessor?
11:41:27 <Lor> How about "generative meta-programming"?
11:41:28 <Igloo> Constructing programs by having templates filled in
11:41:58 <Igloo> As opposed to looking at the program as code and fiddling with it. Hmm, maybe reflective metaprogramming or something is what I want
11:42:10 <Philippa> perhaps
11:42:20 <Lor> TH is not purely template stuff, as it provides a full reification of haskell code.
11:42:21 <Philippa> TH is reflective metaprogramming though?
11:42:25 <wagle> i have noticed that the overlapping support does react differently on how you actually define (or not) the instance functions
11:42:28 <Igloo> Yeah
11:42:40 <Igloo> Well, TH is both
11:43:26 <wagle> i'd like to reserve "reflection" as something like operates on running programs
11:43:43 <Philippa> yeah, though programs that analyse (non-running) programs are also useful
11:43:48 <Igloo> Hmm
11:44:14 <Igloo> Maybe introspective MP, then
11:44:27 * Igloo makes a note of these to mull over later - thanks guys!
11:44:34 <wagle> reflection is something that happens at runtime..  of course, you could run the compiler at run-time..  
11:44:34 <marcot> When I have a declaration like:  instance (Zeros a, Funct f) => Zeros (f a) where
11:44:56 <marcot> and instance Zeros [a] where
11:45:09 <marcot> and instance Funct [] where
11:45:32 <marcot> Isn't it the same problem of overlapping?
11:47:00 <Darius> That'd be completely ambiguous I'd say.
11:48:34 <marcot> What's going to be used, the instance from Zeros (f a) or the one from Zeros [a] ?
11:49:14 <Darius> I'd imagine neither, it'll complain about an ambiguity.  There's no way for it to decide.
11:49:57 <marcot> Yes, it's doing this...
11:50:04 <wagle> does TH do stuff at run-time?
11:50:13 <Igloo> no
11:50:36 <wagle> so it only runs stuff at compile time
11:50:48 <Igloo> Yes
11:51:02 <CosmicRay> why is it restricted to ghc then?
11:51:12 <CosmicRay> couldn't we have a generic TH filter that could generate plain .hs files for, say, hugs?
11:51:30 <Darius> TH uses compiler information.
11:51:40 <Igloo> It should be fairly easy to tweak GHC into being that filter
11:51:41 <Darius> That filter would have to be most of the frontend of a compiler...
11:52:07 <marcot> Is overlapping going to be accepted someday in haskell?
11:52:16 <marcot> Something like Multiparameter classes?
11:52:48 <Darius> I can't tell now.  I personally have never really used it.
11:53:15 <Darius> Though in the above case, the overlapping instances or no, there is no way for the compiler to decide without making an arbitrary decision.
11:56:27 <marcot> Darius: wouldn't it use the most specif one, in this case, Zeros [a]?
11:59:17 <Darius> Maybe, but both instances are completely legitimate.  I can easily see cases where I want the functor instance instead and there would be no way for me to tell it so.
12:00:57 <marcot> Darius: yes, this is a problem... in that old case of instace Num a => Zeros a and instance Zeros Bool, I think that it's really more interesting than the instance Zeros Int stuff.
12:01:39 <marcot> Using Int, Integer, I lose a lot from the generalization.
12:06:03 <Darius> marcot:  Maybe Chameleon my be more suitable
12:07:59 <marcot> Darius: sorry? What's Chameleon?
12:08:47 <Darius> http://www.comp.nus.edu.sg/~sulzmann/chameleon/
12:47:24 <delft> what do you need to import to use sort
12:48:29 <Igloo> (Data.)List
12:51:48 <xerox> @index sort
12:51:49 <lambdabot> Data.List,List
12:51:56 <delft> thx
12:56:41 <Darius> @prelude concat
12:56:42 <lambdabot> ERROR: connect: does not exist (Connection refused)
12:57:46 <boegel> eh ?
12:57:57 <boegel> @get_definition concat
12:57:57 <lambdabot> Sorry, I don't know the command "get_definition", try "lambdabot: @listcommands
12:58:04 <boegel> @listcommands
12:58:04 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
12:58:04 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
12:58:04 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
12:58:04 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
12:58:04 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
12:58:05 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
12:58:07 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
12:58:09 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
12:58:11 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
12:58:12 <boegel> @get-definition concat
12:58:13 <lambdabot> concat = foldr (\x y.x++y) []
12:58:22 <boegel> Darius, is that what you wanted ?
13:00:23 <xerox> http://haskell.org/hawiki/HaskellIrcPastePage  <- the last entry, can someone help me?
13:00:51 <Darius> No.  @prelude was a dict command that connected to a dict-server, that was run by Tom Moertel I think, which had the Haskell Prelude in dict format.
13:01:43 <Darius>  @get-definition returns the definition of functions defined for @eval in it's slightly extended lambda calculus.
13:01:56 <xerox> 1) is the first code correct? 2) what about the second exercise?
13:02:04 <delft> finaly i got it working  thx
13:02:17 <delft> CosmicRay thx for the help
13:03:16 <Darius> xerox: The first code doesn't even use all the parts mentioned in the exercise.
13:03:26 <xerox> uh.
13:03:43 <boegel> xerox, what happens if I give (Two 1 2) to the tuple4 function ... ? --> error
13:03:50 <xerox> exactly
13:04:03 <Darius> What happens if I give (Three 1 2 3) to the tuple2 function
13:04:12 <xerox> ok ok i got it 
13:04:27 <monochrom> I think xerox is reading exercise 4.6 wrong.
13:04:59 <boegel> monochrom, how ? I think it's right
13:05:10 <xerox> do you think elements of the tuple should be of same or different types?
13:05:17 <Darius> I believe there is a way to avoid the repetitive cases, but I'll mention it later perhaps.
13:05:23 <monochrom> data Tuple = ... is correct.  The question is asking for something else when it comes to tuple1 to tuple4.
13:05:35 <monochrom> different types
13:06:14 <monochrom> Ah, my bad.  boegel has it right.
13:06:40 <bringert> @eval "MegaMonad: hi MegaMonad"
13:06:41 <lambdabot> MegaMonad: hi MegaMonad
13:06:42 <xerox> i need some check in every function?
13:07:06 <xerox> like tuple1 (One a) = a; tuple1 _ = Nothing ?
13:07:09 <bringert> MegaMonad: what do you think about lambdabot?
13:07:17 <MegaMonad> bringert: I'm trying to point me to the discussion stepcut and i to think that often it is a lambdabot.
13:07:18 <xerox> but book hasn't told me of _ yet
13:07:18 <monochrom> For exercise 4.7, since there are four cases, you will need three Either's.
13:07:46 <xerox> or it has, let me search..
13:08:00 <boegel> xerox, just do tuple1 (One a) = a; tuple t = Nothing
13:08:04 <boegel> you don't need the _
13:08:21 <monochrom> tuple1 (One a) = Just a
13:08:41 <monochrom> tuple1 (Two a b) = Just a
13:08:54 <monochrom> makes sense?
13:09:28 <monochrom> tuple4 (Two a b) = Nothing  -- this is an example given by the question
13:09:29 * boegel isn't familiar with Just
13:09:42 <monochrom> Whenever you have Nothing you have Just.
13:09:48 <xerox> Just
13:10:02 <xerox> data Maybe a = Nothing
13:10:10 <xerox>             | Just a
13:11:10 <xerox> i think i got it
13:11:34 <xerox> tuple1 :: (Tuple a b c d) -> Maybe a
13:11:34 <xerox> ?
13:11:56 <boegel> xerox, tuple1 should always return a, right ?
13:12:01 <boegel> tuple1 (One a) = a
13:12:03 <boegel> but also
13:12:04 <xerox> you think?
13:12:11 <boegel> tuple1 (Four a b c d) = a
13:12:26 <boegel> I believe tuple1 means give me the first element of the tuple
13:12:32 <boegel> and that works for any tuple
13:12:53 <goron> In what language? 
13:12:56 <boegel> tuple2 gives you problems for (One a), tuple 3 for (Two a b) _and_ (One a), and so on
13:13:20 <xerox> uuh.
13:13:56 <boegel> that what I think, but don't ask me how to solve it then :p
13:14:02 <xerox> argh:)
13:14:44 <boegel> or maybe we just want to make it too hard :)
13:18:37 <xerox> i'm lost
13:19:43 <xerox> tuple1 :: (Tuple a b c d) -> a
13:19:43 <xerox> tuple1 (One a) = a
13:19:43 <xerox> tuple1 (Two a b) = a
13:19:43 <xerox> tuple1 (Three a b c) = a
13:19:43 <xerox> tuple1 (Four a b c d) = a
13:19:50 <xerox> any way to abbreviate this?
13:20:17 <goron> Uhmmmm... you want the first of a Tuple....
13:20:24 <goron> Not of a constructor...
13:20:41 <Igloo> data Tuple a b c d = ... | Two { tuple1 :: a, tuple2 :: b } | ...
13:20:43 <xerox> but tuple1 (Tuple ..) raises error
13:21:59 <goron> Ah, I didn't read the final sentence. You have done something else, than is required. And that's probably the problem :)
13:22:20 <xerox> ok! that's something
13:22:25 <xerox> ""why?""
13:22:27 <xerox> (:
13:23:39 <goron> tuple4 (Two a b) = Nothing
13:23:48 <goron> How's that?
13:24:05 <xerox> i think i understand it
13:24:17 <boegel> because Two has only 2 'elements', and tuple4 is a function which wants to give the fourth element...
13:24:27 <boegel> atleast, that's how I see it :)
13:24:55 <goron> I thought you were a Haskell expert (but I think time spent on IRC is not a good measure ;) ) 
13:25:21 <xerox> me?! :)
13:25:22 <Darius> How time is spent on IRC may be a better one...
13:28:19 <xerox> http://haskell.org/hawiki/HaskellIrcPastePage
13:28:21 <xerox> is it ok?
13:28:28 <Heffalump> are there any debs of HaXML around?
13:29:11 <boegel> xerox, I think you can do it a lot shorter... but I'm not sure how
13:29:47 <boegel> how about if you use tuple1 :: a in your data constructor, and add tuple t = Nothing
13:29:57 <boegel> or will that cause even more problems ?
13:30:05 * boegel isn't used to working with monads
13:30:43 <xerox> are those monads ?!
13:32:24 <boegel> Nothing and Just are, or am I mistaking ?
13:32:40 * boegel is confused
13:32:45 <ibid> Maybe is
13:32:46 <xerox> *Ex4_6> :t Nothing
13:32:46 <xerox> Nothing :: forall a. Maybe a
13:32:50 <Heffalump> they are, but that's not relevant here, is it?
13:32:53 <Heffalump> Maybe is a monad, that is.
13:32:57 <xerox> ah oki
13:32:58 <ibid> Nothing and Just are not monads
13:33:05 <ibid> they are data constructors of a monad :)
13:34:07 <xerox> meh.
13:34:53 <xerox> <boegel> how about if you use tuple1 :: a in your data constructor, and add
13:34:53 <xerox>     tuple t = Nothing 
13:34:57 <xerox> what does it mean?
13:35:45 <boegel> I meant tuple1 t = Nothing
13:36:49 <xerox> mmh
13:36:53 <esap> Any ideas how to model data storage in category theory? [I have some ideas, but want to test them :-) ]
13:37:02 <xerox> can you show me the complete example you're thinking about?
13:38:07 <boegel> data Tuple a b c d = One {tuple1 :: a} | Two {tuple1 :: a, tuple2 :: b} | ...
13:38:21 <boegel> and then adding tuple2 t = Nothing
13:38:46 <boegel> because naming the 'elements' of One, Two, ... is the same as providing functions for it...
13:38:59 <xerox> ah
13:39:03 <xerox> mmmh
13:39:04 <Darius> esap: You mean as in giving semantics to "machine" level layout or what?
13:39:09 <boegel> but I'm not sure that will work
13:39:10 * musasabi starts listening after hearing the cue word "category theory"
13:40:23 <esap> darius: I mean understanding the semantics at all.
13:41:09 <Darius> esap: Can you give a more elaborate definition of "data storage"?
13:41:22 <musasabi> Is data storage different from memory in this context?
13:42:16 <esap> darius: A data storage is a storage device that can hold (lots of) data for some (finite) time.
13:43:01 <esap> darius: I think memory is one such device, disk is another. You need to be able to store and retrieve data from it.
13:43:38 <esap> darius: and it shouldn't lose the data meanwhile :-)
13:43:44 <Heffalump> grr. Installing HaXML without making a mess over /usr/lib is non-trivial
13:44:12 <Darius> esap: Yes, already you can think somewhat algebraically.  Imagine a store operation and a retrieve operation and add some rules store x;retrieve = id store x;store y = store y.
13:45:37 <esap> darius: Right, that's a good point.
13:46:38 <xerox> btw, if you give that 4.6 is correct, what about 4.7?
13:46:39 <esap> darius: ok, let me describe my current thinking. I'm thinking data storage is definitely related to coproducts.
13:48:19 <esap> darius: Because a coproduct can be thought as describing information about events (that occur at some point of time), and data store is intended to maintain the data such that when you handle one event, you can store data, and maintain it until the next event, where you read it. So Data store is somehow a relationship between the branches of a coproduct.
13:49:04 <Darius> Hmm, my above playing is making me think of limits in a funtor category with the source being the Addresses and the target being Values.
13:49:35 <Darius> (or rather a particular limit of the diagram that represents the rules store and retrieve (natural transformations) should hold)
13:49:43 <boegel> I'm out
13:49:45 <boegel> bye everyone
13:49:49 <xerox> bye
13:49:52 <xerox> thanks for helping
13:51:25 <esap> darius: yea, functors are definitely also related, since another thought is that a data store is the domain of a functor to the category that contains the user of the data storage.
13:52:01 <Darius> esap: Describe the injections for the coproduct view.
13:53:06 <jadrian> esap: do you know "hidden algebra"?
13:53:13 <esap> jadrian: no.
13:53:23 <jadrian> it's used in some specification languages like CafeOBJ
13:54:01 <jadrian> it's uses special sorts to simplify state handling
13:54:09 <jadrian> maybe it's worth checking it out
13:54:13 <esap> darius: the injections are just normal injections. I mean something like: storage :: Either a (a -> b) -> Maybe b
13:56:30 <Darius> How do you make a b ever with that?  You either have an A or have a A -> B but you never have both unless storage closed over some A or A->B
13:57:13 <esap> darius: yea, when you invoke this function with an 'a', it stores it. When you invoke it with a function, it invokes the function with the stored value and returns the 'b' there.
13:57:47 <esap> darius: and it should return 'Nothing' for the store and if no value is stored.
13:58:27 <esap> darius: But perhaps it's more like: storage :: (StorageMonad m) => Either a (a -> m b) -> m b
13:58:40 <esap> darius: Something along those lines.
13:59:13 <Darius> Yes, you are putting the actually storing of things into the objects with that approach rather than explicating that actual storage.
13:59:38 <Darius> The storage arrow "magically" can store and retrieve things, but you don't know how it does it.
14:00:32 <Darius> One interesting thing about the functor category approach is if the Address category is discrete, then objects in the functor category essentially reduce to tuples, store simply changes the value of one of the components of the tuple (creating/leading to a new store).
14:00:37 <esap> darius: right. Perhaps I need some IORef stuff there to indicate the location where to store. storage :: IORef a -> Either a (a -> IO b) -> IO (Maybe b)
14:01:06 <jadrian> yesp
14:01:09 <jadrian> yeap
14:02:38 <Darius> I'm not sure what arrows in the Address category would mean.  Perhaps aliasing or containment.
14:04:37 <esap> darius: maybe associations?
14:05:41 <esap> darius: with the address (objects) describing the roles?
14:05:59 * esap overloads the word 'object' :-)
14:06:45 <Darius> Meh, "object" can simply be upcast to it's most general definition, "thing".  
14:06:59 <wolfman8k> "upcast"?
14:07:03 <esap> darius: No, I mean objects of the category.
14:07:41 <Darius> wolfman8k: The coercion of a subtype into its supertype.
14:08:01 <wolfman8k> hm... like in OOP?
14:08:11 <esap> darius: So, objects of the category are roles (or types of addresses/references).
14:08:18 <Darius> wolfman8k: Yes, or just subtyping in general.
14:08:24 <esap> darius: And arrows of the category are associations between the roles
14:10:42 <Darius> Well, the objects of the Address category really don't need any structure (in a discrete category they'd have none) they are simply keys to a finite map.
14:10:42 <esap> darius: Once you map use the functor from this category to category of values and functions, you get for each address, a value and for each association a function.
14:11:29 <wolfman8k> what's a functor?
14:11:46 <Darius> A category homomorphism.
14:11:57 <wolfman8k> eek
14:12:01 <wolfman8k> "homo" hehe
14:12:56 <Lor> Uh, you are going to have a very difficult time with formal sciences if you have an aversion to the prefix "homo". :)
14:13:24 <jadrian> lol
14:13:44 <wolfman8k> homo...
14:13:46 <wolfman8k> sapien
14:13:48 <wolfman8k> hahahahahahahaha
14:14:41 <wolfman8k> i guess i better leave before i get kicked :/
14:15:15 <Darius> esap: The category with roles and associations sounds like a schema.
14:15:43 <esap> darius: like in databases, yes, that's where the idea comes from.
14:15:59 <Darius> Yeah, I was figuring.
14:16:39 <Darius> I'm thinking the arrows are references.
14:17:04 <esap> darius: but then what are objects?
14:17:06 <Darius> For every value at one store location, there'd be an arrow from that value to another value at another store location.
14:17:12 <Darius> The objects are addresses.
14:17:19 <Darius> Just meaningless keys.
14:18:14 <Darius> However, this view which is part of what got me thinking about arrows more again, hides all the layout information (if you care about that).
14:18:35 <Darius> Or perhaps all of it will have to be demonstrated by arrows...
14:19:36 <Darius> The arrows in the Address category are meaningless too, it's the functor into the value category that will give meaning.  The Address category just describes the "shape" of the store.
14:20:04 <Darius> However, this makes me think it may not be dynamic enough.
14:20:24 <esap> darius: I think the arrows are meaningful, in that they describe the external behaviour of the data store.
14:21:50 <esap> darius: you can follow the arrows from one part of the store to other parts, and via those links, you can form transactions to update the storage.
14:22:47 <esap> darius: So I would define a database transaction as a collection of associations that are updated simultaneously.
14:23:02 <esap> darius: And this definition would use the address category.
14:24:04 <esap> darius: which would amount to a hom-set in the category of addresses and associations.
14:24:19 <esap> darius: roles and associations I mean.
14:25:12 <esap> darius: Or maybe a subset of a hom-set
14:25:26 <Darius> Yes, the Address category is like syntax, but the link is the image of an Address arrow in the Value category.
14:27:23 <esap> darius: ok, I suppose I'm thinking about the *types* of addresses as objects, I think you're thinking about addresses as objects.
14:27:38 <Darius> I specifically am.
14:28:33 <esap> darius: can there be more than one arrow from one address to another address?
14:29:47 <Darius> Technically yes.  In one perspective, the machine level one (that I'm interested in for language design purposes) that wouldn't make sense, but another perspective is structures containing pointers to other structures in which case it would be fine.
14:30:57 <Darius> The latter view could be mapped to the former view by having strongly connected components connected along the pointers in the higher level view.
14:31:03 <esap> darius: right, then objects are the structures (or the OO-style objects/things).
14:32:18 <esap> darius: But I'm thinking there is a big difference between one address and a collection of addresses in a structure.
14:33:46 <Darius> There obviously is.  My second comment was on a bit of a different topic.  The mapping is possible but not what you should do in all situations.
14:34:23 <Darius> You'd do that mapping if you wanted to give the layout of the structures in memory.  Most of the time one doesn't care.
14:34:47 <Darius> The thing that changes is the target (Value) category and the functors.
14:36:51 <esap> darius: Yes, that's why you'd normally work in the category of roles and associations; you don't care about the structure in memory.
14:37:01 <Darius> esap: To give you an idea of where I'm coming from on that side of the issue: I'm interested in a categorical approach to memory layout for certifying compilers.
14:37:53 <Darius> Oh, who was asking about linear logic earlier?
14:38:47 <bringert> MegaMonad: who was asking about linear logic earlier?
14:38:52 <MegaMonad> bringert: Linear logic i don't hate ite, and you're asking /us/ if cabal 0.1 is not linear.
14:39:10 <Darius> bringert: It was tautologico and he's stepped out.
14:40:21 <Darius> Heya Pseudonym.
14:40:35 <Pseudonym> G'day.
14:40:46 * Pseudonym read some papers on cache oblivious algorithms
14:40:51 <Pseudonym> I'm not convinced yet.
14:40:57 <Pseudonym> I think there's some work before they're practical.
14:41:13 <Pseudonym> Two issues: 1) They're optimised for REALLY LARGE problems.
14:41:27 <Pseudonym> 2) They use more memory than the equivalent cache-aware algorithm at the moment.
14:41:45 <Pseudonym> So I think there's more work to be done.
14:42:06 <Igloo> Can you easily sum up the basic idea, or si it the sort of thing one has to read a few papers about?
14:42:25 * esap listens as well.
14:42:59 <Pseudonym> Basically, a cache-oblivious algorithm is not only designed to minimise algorithmic complexity, but also cache misses.
14:43:12 <Pseudonym> However, a cache-oblivious algorithm is not parameterised by cache size.
14:43:36 <Pseudonym> So, if you like, it's an algorithm which degrades gracefully as the "working set" increases relative to cache size.
14:43:44 <Pseudonym> Or as the cache size shrinks./
14:44:54 <Pseudonym> A cache-aware algorithm, on the other hand, tunes itself to the cache size.
14:45:05 <Pseudonym> Which it could be input as a parameter, or it could tune itself.
14:45:28 <Pseudonym> Say, by spending a minute finding out what the cache size is by timing itself.
14:45:59 <Igloo> I meant is there some basic trick they use to achieve it?
14:46:14 <Pseudonym> Well, different algorithms require different things.
14:46:15 <Darius> One of the issues I was thinking of is the added constant factors/low level terms would still make them impractical for external memory problems, the picture might be better for less dramatic changes in access time where the time might be made up with better usage of faster cache.
14:46:48 <Pseudonym> But the basic idea is that data is buffered at intermediate levels, and the internal buffer sizes are determined mathematically.
14:46:57 <Pseudonym> So they increase as the level number increases.
14:47:12 <Lor> Is there a standard example of a c-o algorithm?
14:47:14 <Pseudonym> So if you have to go to a lower level, you do a lot of work while you're there.
14:47:43 <Pseudonym> Lor: Yes.  Merging (i.e. the interesting bit of merge sort) is apparently standard.
14:47:55 <Lor> Ah. Thought as much.
14:48:27 <Pseudonym> A lot of algorithms (sort, priority queues etc) can be based on that.
14:48:29 <esap> Maybe you can organize the data already in a way that accesses will occur in reasonable groups
14:48:31 <Darius> Well, scanning, sorting, and (I think) permutation are usually the three "primitive" operations that algorithms are built out of.
14:48:42 <Darius> van Emde Boas trees.
14:49:19 <Pseudonym> They're an interesting idea, but I see them in a similar light to fine-grained parallel algorithms.
14:49:28 <esap> But I suppose it means you must convert data often to different format.
14:49:40 <Pseudonym> Not terrible practical yet.
14:50:04 <Pseudonym> The thing is, they are competing with cache-aware algorithms, which _are_ practical.
14:50:12 <Pseudonym> So there's some work to be done.
14:50:17 * esap points out that OO programming actually does convert data to localized objects, but they're not organized according to the algorithms.
14:50:26 <Pseudonym> It's all good research.
14:52:00 <esap> hmm... does it help with cache, if you always copy things into the stack? Wouldn't then all accesses be close from the same page in the cache?
14:52:38 <Darius> esap: But copying things into the stack (or whatever) would not be cache coherent.  You need to make those cache friendly too.
14:52:58 <esap> ah right.
14:53:20 <esap> maybe just ensure that those copies are not made too often
14:53:54 <esap> or always copy from stack :-)
14:56:23 * esap is thinking of something where all the data is in the stack. might still need to minimize the amount of copying [only copy farthest things?]
14:56:28 <Darius> esap: Everything simply won't fit into the cache.  No matter what you do you are going to have a cache miss some times; the idea is to minimize those.
14:58:04 <Pseudonym> esap: A good example to consider is quicksort.
14:58:25 <Pseudonym> With quicksort, the "working sets" get smaller as the algorithm proceeds.
14:58:36 <Pseudonym> So as the partitions get small, the algorithm gets more cache friendly.
14:58:51 <Pseudonym> It's locality of reference which is important, not size.
14:59:20 <Darius> It also gets more cache friendly for each level of cache.
14:59:24 <Pseudonym> Right.
14:59:34 <esap> yes, you need to group things that have lots of data dependencies
14:59:42 <Pseudonym> I find this interesting because I've just spent a year working on the problem of how to sort when it's expensive to access a key.
15:00:04 <esap> because algorithms are likely to access the data via those dependencies
15:00:14 <Darius> Pseudonym: Just to toss something out, any opinions on String B trees?
15:00:38 <Pseudonym> Errr... and the difference between these and normal B-trees is...?
15:01:05 <Darius> The keys are large.
15:01:21 <Darius> It's kind of like a B-tree of Patricia Trees.
15:01:25 <Pseudonym> Oh, interesting.
15:01:37 <Pseudonym> Have you ever seen burst tries?
15:01:45 <ibid> oo is. i believe, considered generally cache-unfriendly, as it disperses data all over memory
15:02:03 <Darius> http://citeseer.ist.psu.edu/ferragina98string.html
15:02:06 <esap> ibid: yes, that's because the algorithms and the objects are orthogonal
15:02:11 <Darius> Pseudonym: Yes, they are cool.
15:02:12 <ibid> depth-first copying garbage collection tends to improve locality, on the other hand
15:02:30 <Darius> (And the author also has a nice hash table impl)
15:02:47 <Pseudonym> Darius: Can you compare and contrast busrt tries with string B-trees?
15:03:03 <Pseudonym> Actually, OO is orthogonal to cache-friendliness.
15:03:04 <ibid> esap: no, because the data is dispersed all over the memory :) (due to "do one thing well" philosophy, which leads to a mess of cooperating objects)
15:03:08 <Pseudonym> OO is an abstraction mechanism.
15:03:22 <Pseudonym> What lies under the abstraction is whatever the implementor wants.
15:03:29 <esap> ibid: that's what I mean with orthogonal.
15:03:31 <Pseudonym> Having said that, OO works better at the "higher" levels.
15:03:46 <Pseudonym> cf. ML modules.
15:03:47 <esap> ibid: each algorithm uses methods from almost every object.
15:04:51 <Darius> Well, application-wise String B Trees are an external data structure (and an internal one) Burst tries seem mostly internal (but I've been wondering how they or a variation would perform externally).  String B Trees also support most string searching operations, I forget whether Burst Tries can do things like ranges well.
15:06:17 <Pseudonym> I think they do.
15:06:29 <Pseudonym> Because the higher-levels are based on ternary tries.
15:06:40 <Pseudonym> In addition, burst tries do approximate matching.
15:06:54 <Pseudonym> Find all keys within an edit distance of d in O(d log n) time.
15:14:48 <Darius> If you've read the abstract of the paper I mentioned above, another difference is that String B Trees deal with very large keys while Burst Tries deal with large amount of reasonably sized keys.
15:15:07 <Pseudonym> Right.
15:15:31 <Pseudonym> Do string B-trees store suffixes of keys if the prefixes are identical?
15:18:25 <Darius> If the prefixes are identical but the strings different it should end up with two leaves storing indexes into the string set.
15:24:24 <Lemmih> @seen shapr
15:24:24 <lambdabot> I saw shapr leaving #darcs 2 days 14 minutes 16 seconds ago.
15:24:39 <Lemmih> Who killed shapr?!
15:25:37 <Darius> MegaMonad: Who killed shapr?
15:25:43 <MegaMonad> Darius: Shapr: shapr is on msdn.
15:25:52 <Pseudonym> Oh, no!
15:26:00 <esap> msdn?
15:26:01 <Pseudonym> He's part of the Microsoft haskell-killing conspiracy!
15:26:10 <Darius> Microsoft Developer Network.
15:26:18 * esap knows what msdn is.
15:26:31 <SyntaxNinja> haha
15:27:31 * esap starts thinking msdn is not a real network, if you can't even irc from it :-)
15:27:54 <monochrom> hahahaha
15:33:42 <Lemmih> MegaMonad: Do you think shapr will ever return?
15:33:48 <MegaMonad> Lemmih: 9Ish mysql database servers and a return at the function 'lookup' always finds an 'int', for whatever you think shapr will ever be evaluated, and the set of all the basic syntax highlighting can be easier to me.
15:45:07 <segphault> can somebody point me in the direction of a tutorial on how to use IOExts?
15:49:06 <Darius> Tackling The Awkward Squad isn't that exactly but should be close enough if you want general information.
15:50:17 <Darius> maybe 
15:51:27 <Darius> What do you want from IOExts?
15:53:13 <Spark> a fulfilling and meaningful existence
16:02:28 <wagle> what can i get a sixth grader to give him programming experience?
16:03:26 <shrimpx> ghc
16:03:49 <wagle> i gave him the idea of learning to program, an now he wants to program something like the football ghame on his x-box
16:04:09 <emu> hehe
16:04:13 <segphault> could somebody provide me with a good example of how to use unsafePerformIO?
16:04:17 <emu> buy him SICP for his birthday
16:04:21 * emu grins evilly
16:04:24 <wagle> "can you teach me"?
16:04:45 <wagle> heh
16:05:21 <segphault> Darius: I need to be able to increment a counter from a lower scope in which i'm iterating over a tree
16:06:22 <wagle> i dont understand what you mean by "lower scope"?
16:06:37 <shrimpx> inner
16:06:40 <segphault> right
16:07:06 <wagle> i dont understand what you mean by "inner scope"?
16:07:11 * wagle drools stupidly
16:07:21 <shrimpx> seems like it'd be easier to thread the counter or use a state monad
16:07:46 <wagle> i imagine whatever that means keeps you from just writing a standard monadic traverser that increments the counter
16:08:07 <Darius> segphault: Why do you want to use unsafePerformIO (and presumably IORefs) to do this?
16:09:19 <segphault> Darius: it looks like the best solution. Do you know of a better way to do it?
16:09:53 <wagle> segphault: whats wrong with a state monad tree traverser?
16:09:55 <segphault> I realize that it would break referential transparency, but thats really not a big concern in this context
16:10:04 <segphault> how does that work?
16:10:14 <Darius> What is the context? what is the counter? what is the code?
16:11:04 <segphault> http://rafb.net/paste/results/7WXpvq43.html
16:11:48 <segphault> thats a copy of the message I posted to c.l.f
16:14:00 <Darius> segphault: Monads are definitely applicable there (though there are other possibilities).  Even at the very worse, you could put the funtion in the IO monad and use IORefs safely.
16:14:42 <segphault> what I really need are some examples that I can understand
16:15:00 <segphault> how do you think I should do it?
16:15:04 <Darius> @wiki MonadState
16:15:04 <lambdabot> http://www.haskell.org/hawiki/MonadState
16:15:07 <Darius> has some examples
16:15:39 <segphault> I was looking at that yesterday
16:24:00 <segphault> Darius: thx. it looks like I have a lot to learn about monads
16:24:17 <Darius> @wiki HaskellIrcPastePage
16:24:18 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:24:27 <stepcut> monads -- not just for side-effects!
16:25:10 <Darius> I converted your code to use a state monad, running it with import Control.Monad and import Control.Monad.State may work though I'm iffy about that foldM.
16:25:14 <wagle> segphault: its easier if you wrok through simpler uses of the monads than to go straight for a complex example (like your compiler)
16:25:51 <Darius> By the way, I recommend using pattern matching syntax as opposed to 'case'.
16:26:45 <Darius> And you can have more complex patterns (with case or pattern matching).  I'm going to make another version using that style.
16:26:54 <segphault> Darius: I really appreciate this
16:27:25 <segphault> Darius: wouldnt it be more verbose in this context to use regular pattern matching syntax?
16:29:29 <wagle> hmm..  i should setup a "monad tetsuji and kata" interactive webpage or something..  just so _I_ can keep my brain wrapped around the things
16:29:44 <Darius> The only "bad" part about normal pattern matching syntax is that you repeat the function name.
16:29:56 <Darius> The page is updated.
16:30:37 <segphault> oooh neat. (Arg (Sym e)) ... nested matches. thats really cool.
16:30:55 <wagle> segphault seems sold
16:31:23 <Darius> segphault: You can do that with case expressions as well.
16:31:29 <wagle> i'd assumed nested pattern matches would work for case too..  why not?
16:31:39 <segphault> thats good
16:31:45 <wagle> ahh
16:31:55 <Darius> The only thing that's mildly awkward with cases that pattern matching makes easier is when you are pattern matching multiple arguments at once.
16:32:57 <segphault> the more I learn about haskell, the more I like it
16:32:57 <Darius> Even that can be done by matching a tuple which should be optimized away by the compiler
16:34:11 <Darius> The foldM is likely inefficient.  It'd probably be better to cons to the front of the list then reverse when you are done.
16:34:24 <np_hard> are GHC's PackedStrings not particularly fast?
16:34:48 <Darius> I'd think they'd be fast, but I hear that Darcs FastPackedStrings or something like that are faster.
16:34:52 <wagle> ugh..  i hate "reverse the list at the end" algorithms
16:35:12 <Darius> wagle: The alternative in this case is an accumulator.
16:35:45 <np_hard> I guess it's more the reading of them that I am worried about
16:35:53 <Darius> np_hard: They should still kill Strings in many cases.
16:36:04 <wagle> yeah, i know the need, just dont like it
16:36:14 <np_hard> profiling an operation, it seemed like a lot of CPU was in the read function
16:36:22 <np_hard> yeah, definitely better than strings
16:36:31 <np_hard> I was taking aim at Python though :)
16:38:49 <Darius> segphault: A nice thing about monads is that now if you want to add say an environment for resolving variables for example, very little will need to change.
16:40:48 <segphault> what module do I have to import for liftM?
16:41:09 <Darius> It should be in Control.Monad
16:41:13 <Darius> @index liftM
16:41:14 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
16:41:14 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
16:41:14 <lambdabot> State,Control.Monad.Writer,Monad
16:41:26 <segphault> thx
16:43:36 * Janni is back
16:43:39 <Lemmih> Welcome back jadrian 
16:43:42 <Janni> re
16:43:45 <Lemmih> *Janni
16:47:33 <jadrian> hello Lemmih 
16:47:49 <jadrian> oh you meant Janni   
16:48:01 <jadrian> lol I was wondering how did you guess I was about to show up
16:48:13 <jadrian> and checking if I had written anything already
16:48:39 <Lemmih> heh
17:30:10 <CosmicRay> MegaMonad: it is way too quiet in here.
17:30:15 <MegaMonad> CosmicRay: Shapr: pretend to be quiet then.
17:30:24 <CosmicRay> MegaMonad: nono, DON'T be quiet.
17:30:32 <MegaMonad> CosmicRay: It's quiet in here in the uk? Like judge judy? No, we just keep quiet at the category of types as plurals !
17:30:54 <CosmicRay> MegaMonad: I've always thought Judge Judy was more of a () myself.
17:31:00 <MegaMonad> CosmicRay: Gintas: so, add yourself to be converted automatically, but i think that a be the judge.
17:31:25 <CosmicRay> MegaMonad: I just tried out hackage.  Looks pretty cool.
17:31:30 <MegaMonad> CosmicRay: The common stuff people bitch about how the implementation of ann in haskell if i can tell you that this is cool: http://www.haskell.org/hackage ?
17:32:13 <CosmicRay> MegaMonad: there's some nifty-looking debugging stuff in hackage.
17:32:18 <MegaMonad> CosmicRay: I find debugging haskell is pretty common now days.. If they are very quiet anyway so they can host hackage on haskell.org, so i don't want to. Not because of that nifty is a real opportunity to try and see.
17:32:38 <CosmicRay> MegaMonad: what debuggers are people using?
17:32:44 <MegaMonad> CosmicRay: The only people in general, though there many people who are into producing software for themselves, but wiser people so that you should be made for "natural" languages like c debuggers, anyhow.
17:33:05 <CosmicRay> MegaMonad: I don't think C debuggers would be of much help.
17:33:11 <MegaMonad> CosmicRay: Help as in c have a strong dislike of debuggers.
17:33:49 <CosmicRay> MegaMonad: I saw gcc use 250MB of RAM compiling a haskell program today.  It was compiling a C program more than 100,000 lines long.  I don't think I can use gdb to debug that.
17:33:55 <MegaMonad> CosmicRay: I will think up the mitre speech recognition program want to compare it with gdb.
17:34:13 <CosmicRay> MegaMonad: I don't really need speech recognition in a debugger.  A standard terminal interface wil be fine.
17:34:19 <MegaMonad> CosmicRay: Well, there's lots of recognition in a terminal.
17:34:32 <CosmicRay> MegaMonad: True, it does have a nice pattern matching feature.
17:34:38 <MegaMonad> CosmicRay: The truth is, most of the pattern for a feature.
17:34:57 <CosmicRay> MegaMonad: It would be interesting to see a haskell patterns book.
17:35:03 <MegaMonad> CosmicRay: Or a it is the return function (note: function, not keyword) comes into the patterns, it was an interesting book.
17:35:17 <CosmicRay> MegaMonad: which book?
17:35:20 <whyrph> MegaMonad: how do you pronounce 'haskell'?
17:35:23 <MegaMonad> CosmicRay: That's a pretty reasonable book.
17:35:26 <wagle> MegaMonad: can you imagine an imaginary man imagining an imaginary imagination?
17:35:29 <MegaMonad> whyrph: Shapr: you might be me, but you can't pronounce all the haskell i would work better?
17:35:35 <MegaMonad> wagle: I have a man to be in the logs, it's not imaginary.
17:35:41 <CosmicRay> MegaMonad: which one?
17:35:46 <MegaMonad> CosmicRay: Shapr: i'm unhappy with having something involving unsafeevil.
17:35:59 <dons> fair enough
17:35:59 <CosmicRay> MegaMonad: aren't we all.
17:36:00 <whyrph> hmm ..how IS haskell pronounced?
17:36:10 <MegaMonad> CosmicRay: Heffalump: nope i just described it as bloody stinking hot ourselves.
17:36:21 <CosmicRay> whyrph: there was a faq somewhere on that.  Roughly rhymes with "rascal".
17:36:27 <wagle> aitch ey ...
17:36:38 <CosmicRay> heh
17:37:09 <wagle> MegaMonad: what do you think of MegaMonad?
17:37:15 <MegaMonad> wagle: Its born out of me i think of megamonad?
17:37:20 <CosmicRay> whyrph: http://www.mail-archive.com/haskell-cafe%40haskell.org/msg03602.html
17:37:29 <CosmicRay> @seen shapr
17:37:29 <lambdabot> I saw shapr leaving #darcs 2 days 2 hours 27 minutes 21 seconds ago.
17:37:53 <CosmicRay> MegaMonad: how about wagle?
17:37:58 <MegaMonad> CosmicRay: Wagle googles and finds.
17:38:01 <CosmicRay> heh
17:38:02 <wagle> hattle?
17:38:27 <CosmicRay> MegaMonad: did you give anyone the tutorial today
17:38:28 <Lemmih> CosmicRay: I would appreciate some feedback on Hackage.
17:38:33 <MegaMonad> CosmicRay: Anyone know the tutorial i just about where haskell regexes would be me.
17:38:50 <CosmicRay> Lemmih: I like it.  I just checked out the website and it looks nice.  I haven't looked under the hood but what's there is good
17:39:04 <CosmicRay> I was half tempted to upload a bunch of Setup.descriptions :-)
17:39:28 <CosmicRay> but then I realized that I didn't know how to set the homepage in them, so it would be sorta pointless
18:15:57 <CosmicRay> MegaMonad: Ahh, I percieve your schwartz is as big as mine.
18:16:03 <MegaMonad> CosmicRay: Ahh, i percieve your schwartz is as i saw yours.
18:16:14 <CosmicRay> MegaMonad: that's definately not the right quote from Spaceballs!
18:16:21 <MegaMonad> CosmicRay: Well, spaceballs is a really great quote to the result of this definately needs to be initialized if it is right.
18:19:05 <CosmicRay> I see this channel is as active as I was when I left :-)
18:43:43 <Spark> MegaMonad: i hate myself and i want to die
18:43:49 <MegaMonad> Spark: Make: *** no rule to enforce behavioural properties. Epigram can hold out for yourself if you wanted to code up true love for postmaster to work out how new they -have- all of the die.
18:45:13 <marcot> Is there a function to divide an Integer in prime factors, something like fact :: Int -> [Int] ?
18:46:03 <np_hard> naturally there is one'
18:46:12 <np_hard> implementation is left as an exercise
18:46:13 <np_hard> :)
18:46:20 <marcot> (=
18:46:31 <marcot> Ok, but isn't there one already implemented?
18:49:42 <np_hard> i am sure there is one somewhere but not distributed with Haskell
18:50:12 <np_hard> a naive implementation is not very difficult
18:50:43 <marcot> np_hard: ok, thanks.
18:56:56 <Lemmih> MegaMonad: Why do you think shapr is on msdn?
18:57:02 <MegaMonad> Lemmih: Shapr you think is that changing your data as tuples and all is on msdn.
18:57:07 <jadrian> Maddas: there used to be one distributed with hugs
18:57:22 <jadrian> Maddas: quite inneficient, but interesting example 
18:58:03 * jadrian learned quite a lot by studying functions distributed with hugs
18:58:16 <jadrian> prelude, libs and others
18:59:33 <np_hard> MegaMonad: we can a priori and prior to all given objects have a knowledge of those conditions on which alone experience of them is possible, but never of the laws to which things may in themselves be subject, without reference to possible experience.
18:59:39 <MegaMonad> np_hard: Subject with a reference does not want to experience the best part is all day to day operations and think it's where i needed to be about lisp macros (and extensibility)?
19:00:32 <np_hard> MegaMonad: The result, therefore, is that the human being (the laborer) does not feel himself to be free except in his animal functions: eating, drinking, and reproducing, at his best in his dwelling or in his clothing, etc., and in his human functions he is no more than an animal. The animal becomes human and the human becomes animal.
19:00:38 <MegaMonad> np_hard: Except i would like functions very much time, or if it's free?
19:02:03 <np_hard> MegaMonad: All I am saying is that analytic philosophy has become, whether it likes it or not, the same sort of discipline as we find in the other "humanities" departments--departments where pretensions to "rigor" and to "scientific" status are less evident. The normal form of life in the humanities is the same as that in the arts and in belles-lettres; a genius does something new and interesting and persuasive, and his or her a
19:02:03 <np_hard> dmirers begin to form a school or movement.
19:02:09 <MegaMonad> np_hard: Master of fine arts in the humanities is the normal data types.
19:02:10 <np_hard> ok, that's enough of that :)
19:06:42 <Spark> MegaMonad: cunt
19:06:48 <MegaMonad> Spark: For example, if the conditions for an i18n-sprint, or a few good pages with varing rates of image compression, etc to balance load.
19:07:18 <Spark> MegaMonad: blade grates against bone, severring the withered bronchaic muscle that joins the face to the tonsils
19:07:24 <MegaMonad> Spark: Bone is the muscle in vertebrates that connects to the tonsils.
19:07:31 <Spark> result
19:07:53 <Spark> MegaMonad: und die welt ziehlt laut bis zehn
19:08:00 <MegaMonad> Spark: Die arcane ghc build system, die.
19:08:06 <Spark> lol
19:08:26 <Lemmih> haha
19:09:32 <np_hard> heheh
19:09:39 <Lemmih> Bah. He quoted ozone.
19:09:52 <np_hard> that's german for "the arcane ghc build system, the"
19:10:02 <np_hard> "No one who speaks German could be evil."
19:10:45 <Lemmih> MegaMonad: What else should die?
19:10:51 <MegaMonad> Lemmih: Shapr: he found it didn't suck, you die.
19:12:10 <Spark> MegaMonad: you die
19:12:17 <MegaMonad> Spark: So if i can write an os that will let you, then you might use a variable and value should i make some behavior an inherent part of me to log off and die.
19:12:18 <Lemmih> MegaMonad: You talk an awful lot about shapr.
19:12:24 <MegaMonad> Lemmih: Shapr i would talk about, it would be awful.
19:12:34 <Spark> heh
19:12:39 <Spark> MegaMonad: sounds awful
19:12:46 <MegaMonad> Spark: That would be awful.
19:12:57 <Spark> MegaMonad: cucumber
19:13:03 <MegaMonad> Spark: Earthy: mijnheer is the expression was regular". Perhaps that is accesible from a dutch friend: "the curse is broken.
19:13:40 <Spark> MegaMonad: labia
19:13:46 <MegaMonad> Spark: Pesco imagines enraged programmers swinging wooden lambdas at the hugs prelude.
19:16:46 <Lemmih> MegaMonad: quit.
19:16:52 <MegaMonad> Lemmih: [23:39] * Cale has quit irc ("leaving.
19:16:57 <CosmicRay> haha
19:17:16 <Lemmih> MegaMonad: @quit.
19:17:22 <MegaMonad> Lemmih: ,"Moo","more","msg","musasabi","part","prelude","quit","reconnect","resume","seen","set-fuel","shapr","state.
19:17:26 <CosmicRay> haha
19:17:34 <CosmicRay> Lemmih: he doesn't take commands
19:17:50 <CosmicRay> I think it's amusing that nicks got listed in that list of lambdabot commands
19:18:27 <Lemmih> @musasabi
19:18:28 <lambdabot> Sorry, I don't know the command "musasabi", try "lambdabot: @listcommands
19:18:39 <Lemmih> @Moo
19:18:40 <lambdabot> Sorry, I don't know the command "Moo", try "lambdabot: @listcommands"
19:18:41 <CosmicRay> ha!  lambabot has mismatched quotes!
19:18:51 <CosmicRay> @more
19:18:51 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
19:18:54 <CosmicRay> hm.
19:19:02 <CosmicRay> wonder where those are from then.
19:19:06 <CosmicRay> some irc client maybe
19:19:10 <Lemmih> Who crippled lambdabot?
19:19:15 <CosmicRay> @listcommands
19:19:15 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
19:19:15 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
19:19:15 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
19:19:15 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
19:19:15 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
19:19:16 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
19:19:18 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
19:19:20 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
19:19:22 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
19:19:31 <CosmicRay> huh, moo is listed.
19:19:33 <CosmicRay> strange.
19:19:37 <CosmicRay> lambdabot: moo
19:19:37 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:19:49 <Lemmih> @moo
19:19:49 <lambdabot>          (__)
19:19:49 <lambdabot>          (oo)
19:19:49 <lambdabot>    /------\/
19:19:49 <lambdabot>   / |    ||
19:19:49 <lambdabot>  *  /\---/\
19:19:50 <lambdabot>     ~~   ~~
19:19:52 <lambdabot> ...."Have you mooed today?"...
19:19:58 <CosmicRay> case sensitive?
19:20:53 <Lemmih> I think the commands are kept in a finite map.
19:21:11 <CosmicRay> ah.
19:21:23 <jadrian> I got a list of lists of pairs
19:21:23 <CosmicRay> map toLower on the keys being looked up could solve that
19:21:31 <CosmicRay> megamonad: moo
19:21:36 <Darius> There used to be a @more.
19:21:41 <MegaMonad> CosmicRay: It's important to note is that the following commands: ["dummy","wiki","learn","moo","det.
19:21:42 <jadrian> and I need to map the 2nd component
19:21:57 <jadrian> the best way I can think about it is
19:22:04 <jadrian> maping with unzip
19:22:14 <jadrian> then unziping
19:22:22 <jadrian> then mapping the 1st component
19:22:30 <jadrian> then (uncurry) zip it
19:22:36 <jadrian> and then map uncurry zip it
19:22:49 <jadrian> ... but this sucks so much :-|
19:23:06 <Darius> map (map (\(x,y) -> (x,f y)))
19:23:12 <CosmicRay> MegaMonad: I think jadrian should stop unzipping.
19:23:14 <Darius> @type \f -> map (map (\(x,y) -> (x,f y)))
19:23:15 <lambdabot> \f -> map (map (\(x,y) -> (x,f y))) :: forall t t1 t2.
19:23:15 <lambdabot> 				       (t -> t2) -> [[(t1, t)]] -> [[(t1, t2)]]
19:23:18 <MegaMonad> CosmicRay: Jadrian how to allocate a new object. I guess i should stop unzipping.
19:23:49 <jadrian> Darius: sorry it's a mapAccumL
19:24:02 <jadrian> I omitted the accumulator to make it simpler...
19:24:16 <jadrian> but it's important
19:24:24 <Darius> Use a State monad instead.
19:24:54 <jadrian> yeah, that crossed my mind...
19:26:14 <CosmicRay> MegaMonad: what are your true feelings about Java?
19:26:20 <MegaMonad> CosmicRay: Hmmm heatsink ok, well that's just my learning haskell or java all that other gtk apps have similar feelings.
19:26:25 <CosmicRay> heh
19:27:20 <Spark> we cant beat the school kids anymore so we invented java instead
19:27:31 <Darius> @type \f -> [(x,f y) | xs <- xss, (x,y) <- xs]
19:27:32 <lambdabot> bzzt
19:27:39 <Darius> @type \f xss -> [(x,f y) | xs <- xss, (x,y) <- xs]
19:27:40 <lambdabot> \f xss -> [(x,f y) | xs <- xss, (x,y) <- xs] :: forall t t1 t2.
19:27:40 <lambdabot> 						(t -> t2) -> [[(t1, t)]] -> [(t1, t2)]
19:29:35 <jadrian> Darius: list comp. wouldn't work in this case
19:30:17 <jadrian> Darius: because of the acummulating parameter, and in that case you're also destroying the structure (you end up with just one list)
19:30:35 <jadrian> Darius: guess State monad is the easiest way...
19:36:03 <np_hard> well, Guy Steele is a Java language honcho.
19:36:12 <CosmicRay> what?
19:36:14 <CosmicRay> he is?
19:36:17 <CosmicRay> gls?
19:36:18 <np_hard> We probably have him to thank for anonymous inner classes and whatnot
19:36:45 <CosmicRay> The Great Quux is a JAVA guy?
19:36:49 <np_hard> http://java.sun.com/features/2003/05/steele_qa.html
19:37:18 <CosmicRay> damn.
19:37:22 * CosmicRay is shocked, shocked I say.
19:37:26 <np_hard> yeah, I was humbled by that too
19:37:27 <np_hard> :)
19:37:57 <CosmicRay> I named quux.org in his honor!
19:38:23 <CosmicRay> I guess I'll just have to load it up with as much haskell code as I can find now.
19:38:56 <np_hard> sounds like a plan
19:39:15 <CosmicRay> wasn't guy an old-time lisper too?
19:39:24 <CosmicRay> like, before I was born sort of old-time? :-)
19:39:53 <np_hard> yes
19:39:53 <Philippa_> like, the man behind scheme old-time
19:41:00 <np_hard> 'ell, this part is embarrassing. When I first joined Sun Labs in 1994, I surveyed the existing projects to see what was going on. One of the projects involved a variant of C they called "Oak," and it seemed to be focused on a narrow application area, set-top cable boxes. "Interesting, I guess, but not earth-shaking," I said to myself as I tossed the overview on my pile of project documents. "Next!"'
19:41:06 <np_hard> har har
22:01:38 <SyntaxNinja> are there nightly build logs for the libraries directory under fptools?
22:13:13 <Helic> ghc is failing without telling me why
22:13:16 <Helic> any ideas ?
22:14:04 <whyrph> how is it "failing"?  what command are you running?
22:14:42 <Helic> I am trying to bootstrap it. This is "ghc-inplace" to be exact. It returns non-zero, produces no output files, produces no messages.
22:20:26 <Helic> <<ghc: 1041052 bytes, 2 GCs, 31000/31000 avg/max bytes residency (1 samples), 5M in use, 0.01 INIT (0.00 elapsed), 0.00 MUT (0.02 elapsed), 0.01 GC (0.01 elapsed) :ghc>>
22:20:38 <Helic> it produces only this message
22:23:26 <SyntaxNinja> are you sure you need to bootstrap it?
22:23:35 * SyntaxNinja has never bootstrapped ghc
22:23:57 <SyntaxNinja> so my strategy to help people who are trying to do so is to try to talk them out of it ;)
22:31:57 <Helic> SyntaxNinja: Good advice. I am a masochist who is trying build a native cygwin build
22:36:17 <SyntaxNinja> Helic: there aren't pre-built binaries you can start from?
22:39:18 <Helic> no. There is the mingw build, which cannot be used since it doesnt provide Posix, which the ghc sources use.
22:44:10 <Helic> God, Lara Croft the Movie has zero respect for physics...
23:00:26 <SyntaxNinja> heh
23:14:28 <Helic> MegaMonad: Am I going to succeed at building ghc ?
23:14:34 <MegaMonad> Helic: It's a little help with gluing it all reduces to inf/1 and hence did not succeed... Sorry...) (to understand, check my website, the shadow problem is ghc trying to get you in the building i have a map from one experience with chalmers so far i have.
23:16:13 <Lemmih> MegaMonad: Have you taken the role of the magic 8-ball?
23:16:19 <MegaMonad> Lemmih: Magic is a ball you have i can rotate.
23:18:31 <Lemmih> MegaMonad: When will I be able to pay my rent?
23:18:37 <MegaMonad> Lemmih: And to create a notebook, adding tabs and the induction step (non-empty list whose value - once the function if you look at your type declarations to give a sensible/interesting meaning to "this --> <-- space for rent.
23:22:16 <Helic> It seems to pick apart a sentence that carries the word "rent" from the logs and stick a few other random bits to it
23:23:03 <Helic> I wonder what it will say if I use words it hasnt seen before...
23:23:26 <Helic> MegaMonad: Juxtaposition Cubism Dali ?
23:23:32 <MegaMonad> Helic: B.  {Juxtaposition} associates to the local post office, and no amount of indentation.
23:23:50 <Helic> wow
23:24:24 <Helic> Somebody has actually used juxtaposition before
23:29:51 <SyntaxNinja> Helic: this is #haskell. we specialize in diversity 
23:34:12 <Helic> I can't figure out why gmake is doing what it's doing
23:34:28 <Helic> even with the debug flags
23:35:58 <SyntaxNinja> do you have a "show" target? those are handy
23:37:58 <Helic> nah
23:38:01 <SyntaxNinja> something like show: \n\t echo $($(VALUE))
23:41:28 <Lemmih> I so love the internet. Two minutes on google and I found a paper which addresses my needs exactly.
23:42:28 <Helic> MegaMonad: Where are the papers that address my needs ?
23:42:34 <MegaMonad> Helic: Fier: your on the commercial needs of the same person as the address in the input to a foreign call.
23:44:26 <Lemmih> I think MegaMonad is religious.
23:47:45 <SyntaxNinja> MegaMonad: are you part of the cabal?
23:47:51 <MegaMonad> SyntaxNinja: I think having cabal and send me more than me.
23:48:20 <SyntaxNinja> MegaMonad: you mean darcs send?
23:48:26 <MegaMonad> SyntaxNinja: Send me the user to enter large mutually recursive modules allow you to darcs send?
23:50:04 <Helic> MegaMonad: What do you think of Haskell and dynamic linking ?
23:50:10 <MegaMonad> Helic: I'm sometimes shocked by how fast haskell could be dynamic, so happy sounds great in that linking.
23:50:18 <Helic> lol
23:50:43 <Helic> I bet 'happy' is the parser
23:57:55 <Helic> I think I figured the problem out. It appears that the ghc-inplace's dependency generator section is b0rked.
