01:36:30 <xerox> 'morning
01:42:13 <musasabi> morning
01:42:17 <wli> moin
01:43:56 <vegai> MegaMonad: You would be fools to ignore the boolean anti-binary least-square approach.
01:44:00 <ac_mac> @arr
01:44:01 <lambdabot> Yeh scurvy dog...
01:44:02 <MegaMonad> vegai: (Ignore the first approach is a square, that is my function: http://rafb.net/paste/results/wt5u4l84.html.
02:22:07 <kosmikus> wli: the one given on the lhs2tex web site would do, or the second one in the manual, or the second one in the release announcement ...
02:22:17 <wli> okay
02:23:54 <wli> Andres Löh?
02:28:34 <kosmikus> wli: the roman fonts should be simple; \let\Varid\mathrm\let\Conid\mathrm
02:30:01 <kosmikus> wli: the typesetting of ^ is difficult to get correct in general; this is because lhs2TeX doesn't know about operator precedence (and it shouldn't, imo), therefore it cannot know how far the right argument of ^ extends 
02:30:14 <wli> ouch
02:30:23 <kosmikus> wli: I'd recommend a function pow = (^) as an alternative
02:30:52 <kosmikus> wli: then you could say %format (pow (a) (b)) = a "^{" b "}" or something similar
02:31:04 <kosmikus> probably no parens around the a
02:48:45 <xerox> > :t hSetBuffering
02:48:45 <xerox> Variable not in scope: `hSetBuffering'
02:48:47 <xerox> Why?
03:04:04 <musasabi> xerox: import System.IO 
03:04:18 <wli> igloo: boo
03:04:22 <wli> igloo: I have a strong lead
03:04:48 <xerox> Thank you
03:05:02 <wli> igloo: a strong lead that may need very very little work to resolve
03:19:00 <wli> Igloo: were the SPARC ghc6 packages compiled on native 32-bit SPARC or 32-bit emulation on sun4u?
03:21:45 <xerox> *Main> main    Loading package haskell98 ... linking ... done.    I'm thinking of a number between 1 and 100    Enter your guess: 50    You Win!
03:21:46 <xerox>  
03:21:49 <xerox> yeah! ;-)
03:33:31 <wli> so, does ghc hardcode the pagesize anywhere?
03:34:09 <wli> actually ghci
03:35:21 <musasabi> iirc ghc uses getpagesize
03:37:08 <wli> musasabi: well, one of the major differences between native 32-bit SPARC and emulated 32-bit SPARC on 64-bit SPARC is the page size
03:37:21 <wli> musasabi: so if anything is using a hardcoded pagesize...
03:37:25 <wli> musasabi: it will explode
03:37:32 <wli> musasabi: and it is exploding
03:38:05 <wli> ghc/includes/DerivedConstants.h:18:#define BLOCK_SIZE   4096
03:40:46 <wli> I'm trying to figure out what BLOCK_SIZE is used for
03:40:53 <wli> 4096 matches getpagesize() where it works
03:40:58 <wli> and mismatches it where it fails
03:46:29 <wli> loading package base... linking... done
03:46:33 <wli> core
03:46:44 <wli> it's not tripping assertions
03:46:50 <wli> but it is corrupting something
03:50:30 <wli> or misplacing it
03:52:40 <musasabi> Should I write a short piece on managing fptools source code in darcs to the darcs or haskell wiki?
03:53:11 <wli> yes please
03:53:42 <musasabi> (which one)
04:09:19 <arauko> Morning.
04:29:40 <musasabi> http://haskell.org/hawiki/FptoolsWithDarcs
05:01:24 <musasabi> Safe serialization seems quite easy to implement but doing deserialization seems very hard.
05:05:11 <Philippa> well, ultimately deserialisation isn't safe, there's a cast in there
05:06:34 <samc_> musasabi, as in writing out and reading in files?
05:07:36 <musasabi> yes.
05:08:19 <musasabi> would e.g. just using raw constructor indexes be too cruel?
05:09:02 <samc_> I came across a functional pearl about that recently, entitled 'pickler combinators' (I think) I set it aside for a more proper reading later
05:09:29 <musasabi> hmm have to google that up.
05:09:31 <Philippa> musasabi: raw constructor indexes? As in, assign an int[eger] to each constructor?
05:10:41 <musasabi> Philippa: I was thinking of using a modified version of the parallel haskell serializer. so it just takes the guts of the closures..
05:10:58 <Philippa> eww
05:11:08 <Philippa> not portable across haskell implementations
05:11:25 <musasabi> Philippa: I don't think one can write that in a good portable way.
05:11:28 <Philippa> I mean okay, if you want to serialise functions you're prolly stuck with that
05:11:39 <musasabi> Philippa: cyclic structures...
05:12:44 <musasabi> using stablenames for e.g. each char of a string is kind of wastefull.
05:13:27 <Philippa> which would be okay if there were a reasonable check for cyclicity or the absence thereof
05:13:56 <musasabi> but there is none.
05:14:06 <Philippa> quite. Suckage ahoy
05:17:59 <tintin> helo all 
05:18:10 <tintin> *hello
05:19:02 <ralf> anyone awake? 
05:21:38 <ralf> guess not. 
05:23:25 <musasabi> yes..
05:37:20 <xerox> Where can I read about things like "Ord", I mean, where can I lookup definitions and so?
05:38:36 <TheHunter> cd /usr/lib/hugs; vi Hugs/Prelude.hs
05:38:42 <TheHunter> that's what I do.
05:39:54 <samc_> www.haskell.org/onlinereport/
05:40:13 <wolfman8k> what's the best way to work with mathematical sets in haskell?
05:40:26 <xerox> Thanks both.
05:40:29 <wolfman8k> is there a standard Set type?
05:40:40 <TheHunter> either Data.Set or (a -> Bool)
05:41:22 <musasabi> does not really help :-(that paper fo
05:41:43 * musasabi sighs at the lag
05:41:59 <musasabi> that paper (the functional pearl ) does not really help.
05:42:15 <wolfman8k> TheHunter: if i use (a -> Bool) then how can i intersect two sets?
05:42:35 <TheHunter> liftM2 (&&)
05:42:44 <TheHunter> (if you import Control.Monad.Reader)
05:42:48 <xerox> I'm stunned by the clarity of the definitions.. like Ord.
05:43:17 <TheHunter> or, intersect f g x = f x && g x
05:43:49 <TheHunter> wolfman8k, the only thing you can't do is get all the elements out of the set.
05:44:10 <wolfman8k> hm.... yeah
05:47:08 <wolfman8k> why does the Data.Set type require the elements to be Ord type?
05:47:22 <TheHunter> for efficiency reasons
05:47:27 <samc_> I came across a set module yesterday, here: www.cse.unsw.edu.au/~chak/software.html ,I don't know anything about it
05:48:29 <wolfman8k> couldn't they make 2 versions, one that uses Ord and one that doesn't?
05:48:44 <wolfman8k> and then the correct implementation would be used automatically
05:48:55 <TheHunter> there is also edison (http://www.haskell.org/ghc/docs/edison/)
05:49:05 <TheHunter> wolfman8k, that's impossible, i think.
05:49:51 <TheHunter> Data.List has more or less an implementation of sets (as lists) which requires only Eq
05:50:17 <wolfman8k> ok thanks
05:50:27 <samc_> I forgot about edison
06:05:01 <vincenz> re
06:05:13 <vincenz> samc_: could you send me that book now?
06:06:17 <samc_> http://www.cs.man.ac.uk/~david/categories/book/book.pdf working now
06:10:02 <vincenz> thx
06:53:48 <termol> @index toIn
06:53:49 <lambdabot> bzzt
06:53:50 <termol> @index toInt
06:53:50 <lambdabot> bzzt
06:54:28 <termol> hi! what can i do about this error in hugs: ERROR "C:\Program\Hugs98/libraries/Graphics/win32\GraphicsTypes.hs":45 - Undefin
06:54:42 <termol> sorry
06:54:53 <termol> Undefined variable "toInt"
06:55:05 <termol> is the whole message
07:01:38 <xerox> Hm, what's the preferred indenting style in Haskell? 2 spaces? 4? TABs?
07:02:02 <Igloo> Not tabs
07:02:12 <dustin`> I have a big long string, that I wish to split into a list of substrings, the presence of two newlines in a row marking a new string.  I'm using groupBy and giving it a (\ x y -> (x/='\n') || (y /= '\n')), but this is also splitting the string in cases where a regular letter is followed by a newline.
07:02:17 <xerox> Hm, OK..
07:02:18 <dustin`> Am I crazy?
07:02:28 <xerox> Igloo, do you know Emacs's HaskellMode?
07:03:23 <termol> how can i make the toInt function available to my programs?
07:04:18 <Igloo> No
07:04:27 <Calister> heya
07:05:06 <xerox> :-\
07:05:31 <xerox> Anyone uses that? How can I setup it to do "correct"/"preferred" indentation?
07:09:26 <dustin`> Oh, I looked at the implementation of groupBy, I'm an idiot, nevermind.
07:32:42 <matteo> Hola
07:32:54 <Calister> heya
07:54:03 <vincenz> what does it mean when it says that it is a "_free_ algebra"?
08:17:53 <marcot> Hello, I'm having a doubt reading a program. The program imports qualified Prelude and some things normal, like:
08:18:03 <marcot> import qualified Prelude
08:18:10 <marcot> import Prelude (Int, Float, Bool, Char, error)
08:18:21 <marcot> and it exports:
08:18:33 <marcot> module Language.Haskell230
08:18:38 <marcot>             (Int, Float, Bool (True, False), Char,
08:19:06 <samc_> vincenz, I don't know, I dled another book to learn these things www.thoralf.uwaterloo.ca/htdocs/ualg.html I'm not up to free algebras yet, and its tough going (for me). I hope when I get there they're the same 'free algebras' ;)
08:19:13 <marcot> How can it exports Bool (True, False) if it only imports Bool.
08:19:54 <Igloo> It doesn't define its own datatype with True and False?
08:20:05 <marcot> Igloo: no..
08:20:24 <marcot> Igloo: in hugs, it gives me this messsage.
08:20:59 <marcot> Language.Haskell230> True
08:21:07 <marcot> ERROR - Undefined constructor function "True"
08:22:22 <Igloo> Smells like a bug to me, but I'm surprised both ghc and hugs exhibit it if that's the case
08:23:40 <marcot> Igloo: I haven't tested it in ghc yet.
08:26:29 <Calister> ghc is compared to hugs a bitch
08:26:44 <Calister> if it works in hugs it doesnt mean its working in ghc too
08:27:02 <marcot> Igloo: in hugs, I've even made a test with a file importing this module.
08:27:34 <marcot> It works in hugs.
08:27:38 <marcot> i mean, ghc.
08:27:43 <marcot> it works in ghc too.
08:28:41 <wli> Igloo: boo
08:28:53 <wli> Igloo: native 32-bit SPARC has a 4K page size and it works there
08:28:54 <xerox> Hm, how to use isDoesNotExistError ??
08:29:07 <wli> Igloo: emulated 32-bit SPARC has an 8K page size and it breaks there
08:29:25 <xerox> I can't use it on the handle, mmh .. ?
08:29:26 <marcot> Any idea?
08:29:31 <wli> Igloo: this broke sbcl, in the other direction (worked on emulated 32-bit, broke on native)
08:29:39 <wli> Igloo: any ideas where it might break ghc?
08:30:34 <Igloo> Hmm, is loading object files affected by pagesize?
08:30:37 <wli> Igloo: yes
08:31:03 <wli> Igloo: if they're linked to 4K boundaries they're unusable with an 8K page size
08:31:57 <Igloo> ghc/rts/Linker.c looks to be using getpagesize();
08:32:16 <wli> Igloo: it generally has to be hunted down
08:32:30 <wli> (i.e. it's not obvious where the last hardcoded one is left)
08:32:59 <wli> or otherwise where the dependency is
08:35:28 <wli> I can't get a decent strace
08:38:37 <xerox>   bracket (try (openFile filename ReadMode)) hClose
08:38:37 <xerox>           (\h -> if isDoesNotExistError h ...)
08:38:43 <xerox> Why isn't it right? :\
08:40:15 <wli> I don't see anything useful/interesting in strace
08:40:36 <wli> no error returns from mmap()
08:41:01 <wli> no EINVAL returns from any syscall
08:41:27 <wli> address space layout
08:41:31 <wli> and particularly absolute code
08:41:35 <wli> those will hurt
08:41:55 <wli> I'm completely oblivious to whatever kind of address space layout considerations may be going on
08:42:09 <xerox> How to get a thing out of an Either?
08:42:25 <Calister> oh god, im something between a genius and an idiot.. but deffo closer to idiot. But at least i get my code working in end - mostly.
08:42:49 <Calister> you all just code in haskell to have this very nice HAH! feeling in the end, dont you?
08:43:10 <xerox> I miss my HAH! today :)
08:43:28 <Calister> i just had a HAH!
08:43:38 <wli> I just lied to it using LD_PRELOAD
08:43:48 <xerox> Do you know about IO errors?
08:44:28 <Calister> i didnt meet em in haskell yet.. but i fear i will some day >_<
08:44:42 <wli> that didn't fix it
08:44:43 <wli> so that's not it
08:44:48 <wli> probably
08:44:53 <wli> there aer signs
08:45:02 <wli> that seem to indicate it circumvented my library
08:46:40 <wli> (gdb) bt
08:46:40 <wli> #0  0x70ce874c in ?? ()
08:46:40 <wli> #1  0x00b2ef6c in stg_ap_stk_p ()
08:46:40 <wli> #2  0x00b2ef6c in stg_ap_stk_p ()
08:46:40 <wli> Previous frame identical to this frame (corrupt stack?)
08:48:25 <wli> Program received signal SIGSEGV, Segmentation fault.
08:48:25 <wli> 0x70ce874c in ?? ()
08:48:34 <wli> 70b00000-71272000 rw-p 70b00000 00:00 0 
08:48:41 <wli> it's trying to execute off the stack?
08:50:12 <wli> okay, now I need an LD_PRELOAD that can override mmap()
08:50:16 <wli> and | in some flags
08:50:53 <wli> this may be related to enforcement of executable bit protections
08:51:45 <xerox> Hm, I can't understand Either, and how to get a thing out of it.
08:52:21 <xerox> hm i found something.
08:52:25 <wli> okay, who knows how to make a 6-argument syscall on sparc?
08:54:58 <wli> hmm, stack trampolines will kill it, too
08:56:01 <wli> does anyone know if ghc is executing off the stack?
08:56:59 <xerox> Couldn't match `IOError' against `Either IOError Handle'
08:57:05 <xerox> aaaaaaaa.. I'm going nuts.
08:57:30 <Igloo> It doesn't use the C stack
08:59:31 <wli> Igloo: well, that means it needs PROT_EXEC for *everything* it's trying to execute...
09:00:11 <jadrian> xerox: not sure what you are trying to do but
09:00:18 <wli> (gdb) bt
09:00:18 <wli> #0  0x70ce874c in ?? ()
09:00:18 <wli> #1  0x00b2ef6c in stg_ap_stk_p ()
09:00:18 <wli> #2  0x00b2ef6c in stg_ap_stk_p ()
09:00:25 <jadrian> xerox: (Either b) is an instance of monad error
09:01:17 <jadrian> xerox: so you can do things like     some_either >>= \x -> some_other_either
09:01:26 <xerox> jadrian, I'm trying to catch errors opening a file in read mode
09:01:29 <xerox> using bracket
09:01:30 <wli> what's stg_ap_stk_p() do?
09:01:49 <xerox> jadrian, uh, I don't know >>= :-\
09:02:11 <xerox>   bracket (try (openFile filename ReadMode))
09:02:11 <xerox>           (\h -> if isDoesNotExistError ...
09:02:17 <xerox> Is it the correct approach?
09:02:59 <jadrian> xerox: I would have just done (openFile filename ReadMode) `catch` ...
09:03:28 <jadrian> xerox: or use catchJust THE_KIND_OF_ERROR_YOU_WANNA_CATCH
09:03:29 <xerox> jadrian, what does it `s mean?
09:04:40 <jadrian> just a sec
09:05:07 <xerox> Thanks
09:06:19 <jadrian> xerox: catch :: IO a -> (Exception -> IO a) -> IO a
09:06:29 <xerox> Hm
09:06:39 <jadrian> xerox: so if your operation returns an error
09:07:16 <jadrian> xerox: you catch it and do somehing else instead
09:07:33 <jadrian> xerox: you can ignore the kind of error you get
09:07:38 <jadrian> just do something like
09:07:40 <xerox> catch instead_action h ?
09:07:59 <jadrian> no
09:08:05 <jadrian> the other way around
09:08:26 <jadrian> catch your_function  (\ _ -> something_instead)
09:08:29 <jadrian> or
09:08:39 <jadrian> your_function  `catch` (\ _ -> something_instead)
09:08:55 <jadrian> the \_ -> ...  means I'm ignoring the error itself 
09:09:02 <jadrian> and I just do something
09:09:41 <jadrian> notice that the type of that function is  (Exception -> IO a)
09:10:03 <jadrian> so your alternative action may depend on the type of error
09:10:22 <jadrian> of course you might just ignore that argument and do something else instead
09:10:30 <xerox> hmm
09:10:39 <jadrian> I think that's the easiest way to do what you want
09:10:57 <xerox> try and catch are kind of complementary
09:11:07 <xerox> I just don't see how
09:11:21 <xerox> What's the first argument of catch?
09:11:31 <xerox> the resutl of try?
09:12:39 <jadrian> the 1st argument in your case should be (openFile filename ReadMode)
09:14:15 <jadrian> here is a simple example
09:14:22 <jadrian> catch (readLn :: IO(Int))  (\_ -> return 0)
09:14:31 <jadrian> it tries to read an Int
09:14:43 <jadrian> if it fails it just returns a 0
09:14:48 <jadrian> try that in ghci
09:15:00 <jadrian> you could also do
09:15:16 <jadrian> catch (readLn :: IO(Int))  (\_ -> print "opss! defaulting to 0" >> return 0)
09:15:35 <jadrian> and it will also print that message when there is an input error
09:15:43 <xerox> uh
09:15:54 <xerox> can you show me an example using bracket?
09:16:07 <xerox> or explain to me why isn't the right thing to use, if so ?
09:16:16 <jadrian> I never used bracket, let me see its signature :)
09:17:01 <xerox> :D thank you so much,
09:18:30 <jadrian> ok
09:18:34 <jadrian> read it ;)
09:18:42 <xerox> ^_^
09:21:39 <jadrian> if you are just trying to catch the fact that the file may not exist, then catch seems enough
09:21:45 <jadrian> the bracket would be in case
09:22:02 <jadrian> you also want to catch errors when you're using that handle 
09:22:08 <jadrian> and make sure it gets closed
09:22:20 <jadrian> (you can do all that with cases I guess)
09:22:26 <jadrian> the ideia is
09:22:32 <xerox> the second argument in bracket is called in case of error or at the end
09:22:37 <xerox> if I understood correctly
09:22:44 <jadrian> yeap
09:23:18 <jadrian> so you'd need another argument with the computation that you want to perform with that handle
09:23:35 <xerox> the third arg of bracket, right?
09:23:41 <jadrian> yeap
09:23:57 <xerox> perfect.. so WHAT i'm doing wrong? :D
09:24:26 <jadrian> <xerox>   bracket (try (openFile filename ReadMode))
09:24:26 <jadrian> <xerox>           (\h -> if isDoesNotExistError ...
09:24:27 <xerox>   bracket (try (openFile filename ReadMode))
09:24:27 <xerox>           (\h -> catch h (\_ -> return ()))
09:24:27 <xerox>           (\h -> do contents <- hGetContents h
09:24:27 <xerox>                     putStrLn contents)
09:24:54 <jadrian> why the try?
09:25:03 <jadrian> remove it
09:25:19 <jadrian> and the catch too
09:25:20 <xerox>     Couldn't match `IO a' against `Handle'
09:25:22 <xerox> removing it
09:25:23 <xerox> ah.
09:26:08 <xerox> Enter a file name to read: c:/asdh.asd
09:26:09 <xerox> *** Exception: c:/asdh.asd: openFile: does not exist (No such file or directory)
09:26:14 <xerox> hm!
09:26:34 <xerox> That's good.. how to effectively catch it?
09:26:56 <xerox> Without breaking the program.. :)
09:27:23 <jadrian> the bracket just makes sure you perform an action in case there is an exception
09:27:41 <jadrian> but it still raises an exception
09:27:41 <xerox> hm
09:27:52 <jadrian> to catch it you need atch
09:27:53 <jadrian> catch
09:28:11 <xerox> in the second arg of bracket, i suppose?
09:28:19 <jadrian> no
09:28:23 <xerox> in the first one!
09:28:29 <jadrian> in none of them
09:28:35 <jadrian> it's 2 different things
09:28:40 * xerox lost again
09:28:43 <jadrian> braket is not supposed to catch anything
09:29:03 <jadrian> imagine you're performing some computation that uses lots of resources
09:29:12 <jadrian> and it raises an exception somewhere
09:29:21 <jadrian> you might just wanna catch it at top level
09:29:36 <jadrian> but still
09:30:21 <jadrian> you might wanna perform some actions in lower level procedures to make sure you release your resources
09:30:57 <xerox> ok
09:31:33 <jadrian> in your case, I think catch is all what you want
09:31:43 <jadrian> s/all what/all
09:32:24 <xerox> If I put catch in the first argument it brokes because the result of catch is passed to the third, when computing..
09:32:54 <jadrian> no it wouldn't break...
09:33:05 <jadrian> if you put the catch in the 1st argument
09:33:19 <jadrian> then that computation never returns an exception
09:33:27 <jadrian> so the bracket is useless
09:33:37 <xerox> hm..
09:33:39 <jadrian> hmm well
09:34:11 <jadrian> not it would still perform the pre and post computations
09:34:21 <jadrian> but you wouldn't have to put them in a bracket
09:34:26 <jadrian> you could just do 
09:35:00 <jadrian> do  pre-comp; what you have in last argument ; post-comp
09:35:43 <jadrian> the idea of braket is precisely to perform the post computation *without* stoping the propagation of the exception
09:35:56 <jadrian> it would be equivalent to catch the error
09:36:03 <jadrian> perform the post computation
09:36:12 <jadrian> then throw the error again
09:36:44 <jadrian> brb
09:36:51 <xerox> ok (-:
09:43:17 <samc> who was the original perpetrator of allegory theory?
09:46:28 <samc> nm
09:59:52 <SyntaxNinja> darcs 1.0.1 is now in Debian unstable :)
10:33:13 <hellow> hi, anyone here on a mac?
10:34:44 <Calister> not me
10:34:53 * Calister waves bye to all
10:35:26 <bourbaki> moin
10:36:22 <hellow> moinmoin
10:36:26 <SyntaxNinja> hellow: people might be able to help, even if they don't have macintosh machines.
10:37:04 <hellow> well, i got a problem with the installation of greencard (required for Hopengl)
10:39:00 <hellow> but its better not to post the errorlog here. thought, that someone may have experienced the same problem
10:42:02 <Lemmih> hellow: HOpenGL is a part of GHC.
10:43:13 <hellow> oh ty, and GLUT?
10:44:21 <Lemmih> GLUT is also distributed with GHC.
11:11:00 <CosmicRay> MegaMonad: hello
11:11:05 <MegaMonad> CosmicRay: Hello andersca :) how was the idea?
11:11:16 <CosmicRay> MegaMonad: it sucked, and I'm not andersca.
11:11:24 <MegaMonad> CosmicRay: Hm, you're the first time i'll ask andersca how to search emails i indexed attachments, which sucked.
12:03:42 <wagle> @seen ski
12:03:43 <lambdabot> I saw ski leaving #haskell.se 1 day 17 hours 33 minutes ago.
12:03:58 <wagle> interesting
12:13:27 * wli tries to figure out how one may programmatically deduce that things like "F.O.O." and "foo" are the "same word", or "are" and "were" likewise.
12:17:40 <zamez> why isn't main something like [String] -> String, ie. a function from the arguments to the output?
12:20:56 <Nioate> writing to stdout is only one way for the program to affect its environment
12:21:04 <Nioate> there are others
12:21:15 <ibid> zamez: it used to be something similar, but that's very hard to program correctly
12:21:48 <zamez> might be nice if there was more than one acceptable type
12:21:58 <ibid> @type interaction
12:22:00 <lambdabot> bzzt
12:22:03 <zamez> I just don't like this IO stuff ;)
12:22:05 <ibid> @index interaction
12:22:06 <lambdabot> bzzt
12:22:10 <ibid> what was the name?
12:22:12 <ibid> @index interact
12:22:12 <lambdabot> Prelude,System.IO,IO
12:22:12 <Nioate> can't main be any IO action?
12:22:15 <ibid> @type interact
12:22:17 <lambdabot> interact :: (String -> String) -> IO ()
12:22:23 <ibid> Nioate: it can
12:22:30 <Nioate> that's what I thought
12:22:52 <ibid> zamez: you can use interact to emulate what you want to do
12:23:03 <ibid> zamez: myMain = ... ; main = interact myMain
12:23:14 <zamez> I'll try that, thanks
12:23:39 <ibid> the parameter is the input, not command-line args
12:23:44 <ibid> though
12:23:47 <zamez> yep
12:23:52 <zamez> so something like this:
12:23:55 <zamez> main = do
12:24:03 <zamez>     args <- getArgs
12:24:12 <zamez>     interact (run args)
12:24:16 <zamez> I'll try it
12:24:16 <ibid> yeah
12:59:09 <shapr> yow!
13:06:13 <SyntaxNinja> y0 shapr
13:07:56 <shapr> y0 y0
13:07:57 <shapr> wassup?
13:11:07 <SyntaxNinja> nomuch, you?
13:11:35 <shapr> Just filled out a questionarre on Design Patterns for a graduate student doing research.
13:11:41 <shapr> @seen wagle 
13:11:41 <lambdabot> wagle is in #haskell.se and #haskell.
13:12:54 <arauko> Hello.
13:13:37 <shapr> Â¿hola, como est as?
13:13:51 <shapr> SyntaxNinja: written any neat code lately?
13:15:57 <arauko> shapr, bien y tu? :-)
13:16:31 * arauko cracking his head learning Haskell
13:18:05 <shapr> hiya Coz
13:18:26 <shapr> Lemmih: where's Hemplate?
13:18:28 <MegaMonad> Howdy to you, i'd like to drop down a full appointment will be in finland right now...
13:18:30 <CosmicRay> hi shapr
13:18:47 <SyntaxNinja> hi CosmicRay
13:19:53 <CosmicRay> hi SyntaxNinja 
13:20:05 * CosmicRay finally read HHGTG
13:20:08 <CosmicRay> good book.
13:20:24 <Lemmih> shapr: Currectly only in Hackage.
13:20:51 <Lemmih> shapr: I can take it out and cabalize it if you wanna host the darcs repo.
13:21:06 <CosmicRay> MegaMonad: hhgtg
13:21:13 <MegaMonad> CosmicRay: I do, but you can't load plugins compiled with the crafting of haskell xmlrpc (http://www.haskell.org/ghc/docs/latest/html/libraries.
13:21:23 <CosmicRay> MegaMonad: douglas adams?
13:21:29 <MegaMonad> CosmicRay: Jadrian assumes there is definately unlike douglas adams.
13:25:11 <shapr> Lemmih: lemme try it out first.
13:26:31 <shapr> Lemmih: does your nick come from Lemmih purts?
13:27:02 <Lemmih> purts?
13:27:24 <shapr> yeah, like "purts lemmih"
13:27:40 <Lemmih> Ah, yes (-:
13:28:03 <shapr> ok, I was just wondering.
13:32:07 <Lemmih> Has HaskellDB been cabalized?
13:32:20 <ac_mac> hej shae
13:35:37 <shapr> Lemmih: What's this mean? - <Lemmih> GHC only supports Cabal packages now? 
13:35:46 <shapr> hiya mrsolo 
13:36:55 <SyntaxNinja> GHC won't compile code unless it's been cabal-ized... it's part of a new initiative ;)
13:37:06 <shapr> whoa nifty =)
13:37:54 <SyntaxNinja> it's all like "Have you cabalized your code? [yes]" 
13:38:10 <Lemmih> heh
13:41:48 <Lemmih> It's kinda annoying.
13:42:37 <shapr> What is?
13:42:39 <Lemmih> I've ready had to cabalize HaXml and now it seems HSQL and HaskellDB are next.
13:43:11 <zamez> is there an equivalent to 'show' which outputs data structures nicely indented?
13:44:07 <shapr> Yup, PrettyPrint
13:44:17 <SyntaxNinja> I should release a cabal with the interface changes...
13:44:20 <SyntaxNinja> it's in constant flux, though
13:44:21 <shapr> SyntaxNinja: yes!
13:44:28 <shapr> well, flux out the latest
13:44:37 <shapr> release early, release often
13:44:40 <shapr> especially with Cabal
13:44:42 <SyntaxNinja> yeah... soon.
13:44:45 <shapr> it's generating lots of interest and excitement.
13:44:52 <SyntaxNinja> once I have some evidence that the hooks interface is going to work.
13:45:05 * shapr organizes a hooks posse
13:45:05 <SyntaxNinja> also, ross is hacking on Hugs support, which is great.
13:45:40 <shapr> Oh hey! I could Cabalize curryspondence to make it easier to install and upgrade on client machines.
13:45:58 <SyntaxNinja> the big thing that needs to happen now is with HugsSetup
13:46:17 <SyntaxNinja> HugsSetup is a cabal interface, based on Distribution.Simple, for hugs packages in fptools.
13:46:35 <SyntaxNinja> my goal is to get everything moved out of there, so that HugsSetup can be trivial.
13:46:41 <SyntaxNinja> (Ross wrote it)
13:48:26 <zamez> can't find it, shapr 
13:48:28 <SyntaxNinja> btw, the hooks interface is going to rule
13:48:45 <shapr> Any plans for an archive format for cabal? What's left before single-file source-only archives can be automagically installed?
13:48:45 <zamez> I mean instances of the structures
13:49:12 <zamez> not the   data X = ...  source
13:49:20 <shapr> zamez: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.PrettyPrint.html
13:49:58 <shapr> I don't know if there's a derive PrettyPrint already.
13:50:24 <SyntaxNinja> shapr: I don't understand.
13:50:46 <SyntaxNinja> I did cabal hacking at the airport and on the airplane yesterday :)
13:52:24 <zamez> it doesn't seem to do what I want, shapr
13:55:16 <xerox> Is it possible to convert this in point-free? foo f l = l ++ map f l  I really can't find how to do this, I tried foo _ l = (++) l map  .. but I think I'm missing something.
14:01:50 <Cale> (++) :: [a] -> [a] -> [a], so it can't take map as an argument
14:02:18 <xerox> Ah
14:02:22 <xerox> So there is no way?
14:03:06 <Cale> there might be some trickery with the composition operator
14:03:33 <xerox> Maybe I solved.
14:04:08 <xerox> No (-:
14:04:59 <SyntaxNinja> since you need 'l' twice, I don't see how it can be made points-free, but I might be wrong.
14:06:27 <xerox> What about foo _ l = ... ? Would it be points-free?
14:06:49 <arjanb> no
14:06:58 <xerox> Ah!.
14:08:15 <Cale> well, with the right combinators you can certainly do it
14:09:22 <SyntaxNinja> Cale: heh... i don't think it counts if you have to invent a non-points-free combinator ;)
14:10:56 <Cale> how about expressing that combinator in terms of S and K? :)
14:11:00 <zamez> foo = copy_and_map_with_f
14:11:07 <xerox> @get-definition S
14:11:08 <lambdabot> S = \f g x.f x (g x)
14:11:12 <xerox> @get-definition K
14:11:12 <lambdabot> K = \x y.x
14:11:55 <Cale> You just need some C x y z w = x w (y z w)
14:12:03 <xerox> Cale, can I directly use "S" and "K" in Haskell programs?
14:12:23 <Cale> xerox: sure, just define them like shown there
14:12:29 <SyntaxNinja> SyntaxNinja's guide to writing points-free code: Write normal code, then remove the readable stuff.
14:12:42 <xerox> Ah!
14:12:43 <Cale> SyntaxNinja: heheh
14:13:13 <xerox> downcase, right?
14:13:19 <Cale> yeah
14:13:21 <xerox> Lowrcase I mean.
14:13:25 <xerox> err, Lowercase.
14:14:57 <xerox> Cale, can you rewrite C args in a more "expressive" way? (-:
14:15:38 <Cale> C (++) map z w = (++) w (map z w)
14:16:37 <xerox> And then write a wrapper?
14:17:44 <Cale> well, if C is expressible as a confection of Ss and Ks, then you can write foo = C (++) map
14:17:46 <xerox> func3 f l = l ++ map f l
14:17:46 <xerox> func3pf' x y z w = x w (y z w)
14:17:46 <xerox> func3pf = func3pf' (++) (map)
14:18:03 <Cale> sure
14:18:05 <xerox> Who knows if its really points-free programming (_:
14:23:46 <xerox> Thanks for the help, nice way to build functions.
14:29:20 <TheHunter> xerox, how bout foo = (. repeat) . ((concat . take 2) .) . zipWith map . (`iterate` id) . (.) ?
14:33:33 <zamez> mad
14:33:37 <heatsink> evil
14:34:01 <xerox> O_O
14:34:21 <xerox> (\z -> z `elem` [1..10])
14:34:33 <xerox> pf-ize that is possible only with a combinator, right?
14:34:59 <TheHunter> it'd count (`elem` [1..10]) as pointfree
14:35:12 <TheHunter> otherwise it's flip elem [1..10]
14:35:20 <xerox> flip!
14:35:26 <xerox> right! Great.
14:35:39 <xerox> Can you explain to me you foo, btw? (-:
14:35:54 <TheHunter> the original is:
14:36:01 <TheHunter> foo f = concat . take 2 . zipWith map (iterate (f.) id) . repeat
14:36:41 <TheHunter> where iterate (f.) id yields [id, f, f . f, ...]
14:37:44 <TheHunter> ok, foo f l = concat . take 2 . zipWith map (iterate (f.) id) (repeat l)
14:38:07 <TheHunter> hmm, foo f l = concat . take 2 $ zipWith map (iterate (f.) id) (repeat l)
14:38:07 <xerox> hm..
14:38:26 <xerox> I still confuse . and $ :-\
14:38:56 <TheHunter> f . g . h $ x === f $ g $ h $ x
14:39:52 <xerox> Why the $ is needed in the left part?
14:40:29 <TheHunter> zipWith map (iterate (f.) id) (repeat l) returns a list.
14:41:05 <TheHunter> and anything . list is a type error.
14:41:28 <xerox> Ok
14:42:16 <ne1> $ is there for precedences
14:43:02 <TheHunter> the rest of the translation is mechanical.
14:43:12 <ne1> (a . b) c is the same as a . b $ c   you can choose the one you like.
14:43:12 <TheHunter> because every argument on the rhs appears exactly once.
14:44:40 <xerox> rhs?
14:44:50 <TheHunter> right hand side.
14:45:17 <heatsink> Why not rs?
14:46:07 <ne1> somehow rhs sticks
14:47:34 <xerox> func4 l = map (\y -> y+2)
14:47:35 <xerox>               (filter (\z -> z `elem` [1..10])
14:47:35 <xerox>                       (5:l))
14:47:35 <xerox> func4pf = map (+2) . filter (`elem` [1..10]) . (5:)
14:47:36 <esap> Is it possible to implement 'Data' instances for types whose constructors are not accessible? (say, Text.PrettyPrint.Doc)?
14:47:39 <xerox> the last one..
15:06:12 <xerox> Can you explain me this one? I read: "As soon as Graham stated the problem in terms of: "create a function that has internal, updatable state" he had stepped out of the object oriented model of Python (and out of the model of pure functional programming as well)"
15:07:06 <heatsink> It's impure but I don't see how it's unpythonic
15:07:07 <zamez> how do I make an Int into a Float?
15:07:17 <jadrian> zamez: fromIntegral
15:07:23 <zamez> thanks
15:07:46 <xerox> heatsink, do "that has an internal, updatable state" mean monads?
15:09:34 <heatsink> It sounds more like what C calls static variables to me
15:11:01 <ne1> out of pure functional programming, I understand.  out of oop? just because "function that has state" not "object that has state"? Who writes that?
15:11:35 <xerox> ne1, let me search
15:12:12 <shapr> is set! function-local?
15:12:13 <xerox> http://www.prescod.net/python/IsPythonLisp.html
15:14:13 <ne1> I think this person is fanatic.
15:16:18 <shapr> xerox: a monad is required for mutable state.
15:17:03 <xerox> shapr, what does "motable state" means?
15:17:57 <vincenz> mutable
15:18:25 <SyntaxNinja> any country with a river around it
15:18:41 <xerox> *mutable, sorry.
15:18:51 <ne1> hahaha
15:18:56 <zamez> :)
15:19:00 <xerox> SyntaxNinja! eheh.
15:19:52 <ne1> Like in C, int f() { static int state = 0; ++state; return state; }
15:20:01 <shapr> You can think of a variable as a location in memory where there's a value that can be changed/updated.
15:20:09 <ne1> The nth time you call f(), you get n.
15:20:37 <shapr> Haskell doesn't have variables. It has single-assignment constants.
15:21:11 <xerox> Right.
15:21:56 <shapr> You can shadow existing names to fake it, but you're not overwriting the previous assignment, in many cases it's still being used.
15:22:07 <xerox> I saw this example, printAString :: RealWorld -> String -> RealWorld, readAString :: RealWorld -> (RealWorld -> String), in this case monads are not needed, am I right?
15:22:32 <shapr> that is a monad.
15:22:39 <shapr> hiya pesco 
15:22:42 <pesco> MOO!
15:22:46 <xerox> Why is it a monad?
15:22:54 <pesco> shapr: Hi shapr!
15:23:10 <xerox> In the example I see: (rW', name) = ReadLine hW
15:23:18 <xerox> There's an = not a <-
15:23:21 <shapr> xerox: A monad is just a container type, and two functions. One function puts other values into the container, the other function puts together two containers and returns a new container.
15:23:34 <shapr> @type return
15:23:35 <lambdabot> return :: forall m a. (Monad m) => a -> m a
15:23:40 <shapr> @type (>>=)
15:23:41 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
15:24:02 <ne1> The point of int f() { static int state = 0; ++state; return state; }  is that there is no explicit mention of the global state.
15:24:37 <ne1> If you have to write RealWorld -> String -> RealWorld, you are making the global state explicit.  The mental model is somehow different.
15:24:45 <musasabi> A
15:24:48 <shapr> B
15:25:27 <musasabi> and night
15:25:28 <xerox> Hm..
15:25:30 <shapr> The monadic io model really is explicit state passing.
15:25:35 <shapr> g'night musasabi 
15:25:38 <ibid> omega
15:25:43 <ne1> If you package it up in a state monad, then you successfully avoid mentioning the state, at least for most of the code.
15:25:52 <xerox> Can you show me an example of using >>= ?
15:26:07 <shapr> @type putStr
15:26:08 <lambdabot> putStr :: String -> IO ()
15:26:18 <shapr> IO sort of means RealWorld
15:26:51 <ibid> for some rather strange values of "sort of"
15:26:56 <shapr> heh
15:27:05 <xerox> Where's ">>=" there? Sorry I didn't understand
15:27:09 <SyntaxNinja> getArgs >>= print
15:27:14 <shapr> oh, good point
15:27:14 <SyntaxNinja> main = getArgs >>= print
15:27:20 <SyntaxNinja> that'll print out the arguments as a list of strings
15:27:24 * shapr likes SyntaxNinja's example
15:27:38 <xerox> @type getArgs
15:27:39 <ne1> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm  elaborates what I just said.
15:27:40 <lambdabot> bzzt
15:27:47 <SyntaxNinja> you need to import System
15:27:54 <xerox> @type System.getArgs
15:27:55 <SyntaxNinja> @type System.getArgs
15:27:56 <lambdabot> System.getArgs :: IO [String]
15:27:57 <lambdabot> System.getArgs :: IO [String]
15:28:01 <SyntaxNinja> @type print
15:28:02 <lambdabot> print :: forall a. (Show a) => a -> IO ()
15:28:10 <SyntaxNinja> @type (>>=)
15:28:12 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
15:28:27 <SyntaxNinja> so it takes the output of "getArgs" and plugs it as the input of "print" basically
15:29:17 <shapr> @type (System.getArgs >>=)
15:29:18 <lambdabot> (System.getArgs >>=) :: forall b. ([String] -> IO b) -> IO b
15:30:00 <xerox> HMMM..
15:30:13 <shapr> @type (>>= print)
15:30:14 <lambdabot> (>>= print) :: forall a. (Show a) => IO a -> IO ()
15:30:52 <xerox> What does it mean "returning IO ()" ?
15:31:21 <shapr> @type ()
15:31:22 <lambdabot> () :: ()
15:31:44 <vincenz> @type shapr
15:31:46 <lambdabot> bzzt
15:32:01 <shapr> I'm atype-ical
15:32:04 <vincenz> hehe
15:32:19 <xerox> Sigh.
15:32:29 <shapr> @type return ()
15:32:30 <lambdabot> return () :: forall m. (Monad m) => m ()
15:32:50 <xerox> @tupe return IO ()
15:32:50 <lambdabot> Sorry, I don't know the command "tupe", try "lambdabot: @listcommands"
15:32:58 <xerox> @type return IO ()
15:33:00 <lambdabot> bzzt
15:33:09 <shapr> xerox: the () is called the unit type, I think. It means you got a result but it didn't evaluate to anything useful other than its side-effect.
15:33:16 <shapr> hiya vincenz 
15:33:20 <vincenz> hi!
15:33:24 <shapr> how's code?
15:33:43 <pesco> xerox: () Is the type with only a single value, also called ().
15:33:43 <ne1> you can think of () as void.
15:33:44 <vincenz> categorical
15:34:01 <pesco> xerox: It's used to mean "returns no information".
15:34:04 <xerox> Let me re-read all this stuff, I'm a little lost, sorry.
15:34:08 <shapr> pesco: oh what about value types that encode a value in a type?
15:34:42 <pesco> shapr: What do you mean?
15:35:18 <shapr> HaskellDB encodes types like VARCHAR(42)
15:35:22 <vincenz> @type IO()
15:35:24 <lambdabot> bzzt
15:35:27 <vincenz> hmm
15:35:40 <pesco> vincenz: That's not an expression!
15:35:48 <vincenz> oh
15:35:49 <vincenz> hnn
15:35:52 <shapr> So you need to be able to typecheck the maximum length of a list, and that requires that you can encode a value as a type, right?
15:36:02 <ne1> My own IO tutorial is at http://www.cs.toronto.edu/~trebla/fp/lecture-11.pdf  it is short.
15:36:02 <vincenz> @type (>>= print)
15:36:04 <lambdabot> (>>= print) :: forall a. (Show a) => IO a -> IO ()
15:36:13 <pesco> shapr: Right.
15:36:17 <vincenz> @type (>>= print) (Show 1)
15:36:19 <lambdabot> bzzt
15:36:25 <pesco> shapr: But what's the connection to ()V
15:36:31 <pesco> s/V/?/
15:36:43 <vincenz> () is a unit, the empty type
15:36:45 <shapr> I was just wondering if there are other good ways to make types that have only one value.
15:36:47 <pesco> Hah! advogato has 4482 users.
15:36:54 <xerox> I think I more or less got it..
15:36:58 <pesco> vincenz: No, not empty.
15:36:59 <shapr> like, how to make a type that has the value of 4?
15:37:06 <vincenz> pesco: unit type
15:37:13 <shapr> xerox: have you read the nomaware monads tutorial?
15:37:17 <xerox> ne1, thanks
15:37:19 <xerox> shapr, no
15:37:33 <shapr> It's the best monads tutorial I've seen.
15:37:43 <ne1> It's the longest I've seen.
15:37:45 <SyntaxNinja> shapr: data TypeWithFour = Four
15:38:03 <SyntaxNinja> shapr: link?
15:38:06 <xerox> shapr, I have the link, but I'm still reading "Yet Another Haskell Tutorial"
15:38:11 <shapr> SyntaxNinja: now how do you use that to typecheck the maximum length of something?
15:38:16 <shapr> xerox: ok, no hurry.
15:38:21 <ne1> I'm also not sure about 1. whether it need to be that long, 2. the validity of the analogies at the end
15:39:09 <shapr> They worked well for me. I read Steve Atkin's monads tutorial, then the The nomaware tutorial and finally Cale's monads as containers tutorial, and then I got the big lightning bolt of understanding.
15:39:21 <shapr> SyntaxNinja: link to nomaware?
15:39:25 <SyntaxNinja> ja
15:39:33 <shapr> http://www.nomaware.com/monads/html/
15:39:48 <vincenz> nomadic monads?
15:40:00 <xerox> shapr, I think i nearly got it, in Haskell there are no variables, so we use the IO monad to put (in the getArgs >>= print case) the String into "memory" and then pass that thing to a function that extrapolates the value contained into it and returns another monad
15:40:12 <shapr> Tribes of monadic grad students wanders the grounds in search of a return to the RealWorld
15:40:55 <xerox> with the result of the computation IO () in case of print, because all it matters are side effects
15:41:04 <shapr> xerox: that sounds right, but it depends on what you mean by extrapolate and returning a monad.
15:41:24 <shapr> A monad is just an interface, like an API.
15:41:30 <xerox> If I want to do a function that sums two numbers AND prints it I can't define it as a function
15:41:31 <xerox> Right?
15:41:47 <shapr> That's true, print requires IO
15:43:07 <xerox> Can you show me such a "function" ?
15:43:11 <vincenz> shapr: euhm.. the monads return Nothing....the students lost between lazy computations
15:44:35 <shapr> @type \x y -> print (x + y)
15:44:36 <lambdabot> \x y -> print (x + y) :: forall a. (Num a) => a -> a -> IO ()
15:45:07 <xerox> Hm, sorry, I meant "and returning the sum"
15:46:03 <shapr> IO can't 'come back'
15:46:11 <shapr> It's a one-way trip.
15:46:38 <xerox> Is it possible to do "return 3" ?
15:47:29 <xerox> What about:
15:47:34 <xerox> foo a b = do print (a + b)
15:47:35 <xerox>              return (a + b)
15:47:35 <xerox> ?
15:47:37 <ne1> boo x y = do { let z = x+y; print z; return z }
15:47:43 <ne1> which is the same as your foo
15:47:45 <xerox> yes
15:48:03 <ne1> I did a manual common subexpression elimination.
15:48:17 <xerox> Yes, something I know, this time (-:
15:48:21 <shapr> But the only way you can work with the returned value is to wind forward in the IO monad again.
15:48:56 <shapr> It's like burning your bridges behind you or something.
15:49:06 <ne1> yes
15:49:10 <xerox> Hm
15:49:18 <xerox> sum <- foo 2 3
15:49:40 <xerox> hm.. sum is an IO monad now?
15:49:46 <ne1> No.
15:49:56 <ne1> foo is.  or rather, foo 2 3 is.
15:49:56 <Gahhh> I think the best way to learn monads is not to study IO monads, but State and others. I find them simpler.
15:50:31 <ne1> You can write: main = do { sum <- foo 2 3; print (sum*sum) }
15:50:51 <ne1> sum is an ordinary number. not monadic, not IOish.
15:51:09 <xerox> so is it possible to do things like bar = sum * 2 ?
15:51:10 <ne1> It is foo 2 3 and the whole main that's monadic IOish.
15:51:46 <wli> (Monad m, Num m t) => m t
15:51:55 <wli> feh
15:51:58 <xerox> I'll better read the tutorial.. (-:
15:52:00 <wli> (Monad m, Num (m t)) => m t
15:53:09 <zamez> new version of http://cvs.strcprstskrzkrk.co.uk/factorcss/ for anyone interested
15:54:08 <jadrian> Gahhh: actually I think a better approach may be starting with very simple monads like Maybe
15:54:34 <jadrian> I whish someone had suggested me that some years ago
15:55:00 <jadrian> Maybe monad is so simple to understand
15:55:09 <zamez> didn't know Maybe was a monad
15:55:16 <jadrian> but it is
15:56:07 <xerox> Maybe is a monad???
15:56:10 <jadrian> yeap
15:56:14 <jadrian> and a very simple one
15:56:27 <xerox> Can you elaborate on that? :D
15:56:58 <jadrian> think about a monad as something that wraps computations
15:57:17 <jadrian> Maybe a   <-- wraps a computation that returns something of type a
15:57:38 <jadrian> you may think of it as a computation that might fail
15:58:02 <zamez> do you think that having lots of monads in a program means it would be better written in a imperative language?
15:58:09 <Gahhh> zamez, no
15:58:25 <xerox> jadrian, OK
15:58:30 <ne1> On the Maybe monad the no-whatever-aware tutorial is superb.  (I can never remember the name.)
15:58:40 <shapr> do you think lots of objects means a program should be written in FP? =)
15:58:45 <wagle> would more people on the planet understand it if it were written imperatively?
15:59:12 <jadrian> xerox:  now try   Just  4 >= \x -> Just (x + 2 )
15:59:13 <Gahhh> wagle, yes, since more people are familiar withthe  imperative style
15:59:25 <shapr> wagle: probably, but the imperative version could take more time to extend and maintain
15:59:31 <xerox> @type >=
15:59:32 <lambdabot> bzzt
15:59:43 <wagle> i'm personally with shapr
15:59:47 <jadrian> xerox:  it passes the 4 onto the second function and returns Just 6
15:59:48 <ne1> try (>=) or (>>=)
15:59:55 <jadrian> opss
16:00:00 <jadrian> I meant >>=
16:00:05 <jadrian> I always do that :-|
16:00:20 <wagle> i just wonder sometimes about the cultural utility of writing programs that so few would understand
16:00:24 <xerox> It retuns Just 6, yep!
16:00:36 <jadrian> xerox: then try   Nothing >>= \x -> Just (x + 2 )  
16:00:44 <jadrian> xerox: you get Nothing
16:00:50 <ne1> There is great cultural utility of writing something that few would understand.
16:00:58 <xerox> jadrian, Yep!
16:01:02 <jadrian> xerox: in the Maybe monad,  fail = Nothing, and return = Just
16:01:48 <jadrian> xerox: then try things like:  sequence [Just 1, Just 2, Just 3]
16:01:57 <xerox> Why "Nothing + 2" doesn't work?
16:01:59 <jadrian> xerox: you get   Just [1,2,3]
16:02:09 <ne1> For example look at music.  A century ago Schoenberg wrote something few understood.  Now all scholar musicians write only things that Schoenberg would approve.
16:02:31 <xerox> Main> [Just 1, Just 2, Just 3]
16:02:31 <xerox> [Just 1,Just 2,Just 3]
16:02:37 <ne1> So I predict that a century from now everyone will write in terms of maps and folds.
16:02:41 <jadrian> xerox:  sequence [Just 1, Just 2, Just 3]
16:03:14 <xerox> jadrian, sorry, missed that, works like you said
16:03:25 <jadrian> xerox:  now  [Just 1, Nothing,  Just 3]
16:03:40 <wagle> i've heard people dis schoenberg
16:03:47 <xerox> Nothing!
16:03:58 <ne1> Yes, but now they are the marginalized minority.
16:04:01 <xerox> impressive..
16:04:14 <wagle> PhD in music?
16:04:22 <jadrian> xerox: you cannot do Nothing + 2 because Maybe isn't even a number
16:04:27 <ne1> It is their turn to be understood by few. :)
16:04:55 <xerox> jadrian, what does the last two sequences mean?
16:05:18 <jadrian> xerox: you can think of it like this
16:05:38 <jadrian> xerox: you got a list of computations
16:05:52 <xerox> ok.
16:06:05 <jadrian> xerox: sequencing those computations gives you one computation with a list as a result
16:06:18 <jadrian> xerox: if one of the computations of the list failed, they all fail
16:07:04 <jadrian> xerox: if I were you, I'd check out all the Monad functions using Maybe
16:07:07 <shapr> In my opinion, the FP versions of most algorithms are easier to understand.
16:07:07 <shapr> wagle: I dunno if that counts or not.
16:07:25 <jadrian> xerox: then check out MonadPlus using Maybe too
16:08:14 <jadrian> xerox: then probably understand how (Either b) can be a monad or maybe try to understand lists as Monads
16:08:15 <wagle> hmm..  didnt schoenberg claim something like that brahms was the last (real?) musician?
16:08:29 <jadrian> xerox: and only then State monads and such
16:08:33 * jadrian is away
16:08:58 <xerox> hm hm 
16:09:00 <xerox> thanks jadrian
16:09:07 <shapr> Have you read Rabhi and Lapalme's FP Algorithms book?
16:11:19 <xerox> Nope
16:11:32 <wagle> i own it, keep wanting to read it, but other things always have higher priority
16:11:39 <wagle> 8(
16:15:59 <ne1> I didn't find interesting things in that book.
16:16:34 <jadrian> I got that book too, but I haven't read much of it
16:16:46 <jadrian> and I just bought "the fun of programming" :))
16:17:59 <ne1> I have no money to buy The Fun of Programming in North America.  Is some of you coming to Toronto any time soon?  You can smuggle a copy for me...
16:18:42 <ne1> On the bright side, no one wants functional programming in North America, so effective I own the library copy :)
16:18:51 <ne1> s/effective/effectively/
16:18:59 <SyntaxNinja> ne1: ahh, you must be the guy who has North America's copy of that book...
16:19:11 <pesco> hehe
16:19:14 <jadrian> lol
16:19:26 <SyntaxNinja> I tried to acquire it to no avail
16:19:33 <Lunar^> pesco: How was your talk at CCC ?
16:19:35 <SyntaxNinja> I should have picked it up while overseas, as someone had advised me to
16:20:10 <pesco> Lunar^: It went quite well, except that the 'net wasn't up for the workshop part. Oh well.
16:20:15 <ne1> Yeah, our library's loan policy is very generous to us grad students.  Basically I can keep it for months by a large number of renewals.  Renewals on the web, too.
16:20:49 <Lunar^> pesco: cool
16:21:36 <ne1> Yes, it's hard or expensive to get in North America.  The problem, I believe, is that the publisher is rather uncommon.  (You would have no problem with Springer or even CUP.)
16:23:31 <ne1> Why the bloody hell was the book not published through CUP?  That would make everyone's life easier, plus CUP is a good publisher in this field too (cf Okassaki's book and Andrew Gordon's thesis).
16:25:47 <pesco> Lunar^: If you're interested, the paper/slides are at http://www.scannedinavian.org/~pesco/
16:26:37 * SyntaxNinja notes that shapr's server is very promiscuous 
16:26:47 <pesco> Is it? :-)
16:27:46 <Lunar^> pesco: I've read it already :)
16:28:10 <pesco> Lunar^: Oh, cool. Did you find it from the Congress site? How'd you find it?
16:29:18 <ne1> there is some weird problem with that url.  I use IE.  The browser does not show the page; instead I am offered to save a file.  Then the save fails because something was not found.
16:29:41 <pesco> ne1: There is some weird solution to that problem.  Don't use IE.
16:29:45 <pesco> ;-P
16:30:15 <pesco> The site is in written in XHTML, and the mime-type reflects that.
16:31:35 <vincenz> firefox
16:31:42 <ne1> I see. No problem.
16:32:13 <pesco> ne1: IE is appearently uncapable of dealing with such a situation. *giggle*.
16:32:43 <vincenz> F-ree-1: You could try opera
16:33:18 <ne1> I guess I will eventually install firefox.
16:33:44 <Cale> It's pretty easy to install.
16:34:23 <vincenz> urpmi firefox
16:34:28 <Cale> and very much worth it -- you'll also get fairly good protection against a lot of spyware
16:34:35 <vincenz> firefox does have some isseus
16:34:40 <vincenz> notably on kisheido site
16:35:09 <Cale> kiseido?
16:35:23 <Cale> I didn't have any problems with it.
16:36:06 <vincenz> well if you look at pags
16:36:18 <vincenz> some part of the right column is covered by the left column
16:38:37 <pesco> vincenz: You sure, that's a firefox problem? Sounds like a CSS issue. And then, I thought mozilla's engine was pretty much the most accurate one.
16:39:22 * vincenz shrugs
16:39:33 <vincenz> then they misdesigned it with ie quirks in mind
16:39:45 <pesco> who knows
16:39:48 * pesco shrugs
16:40:06 <vincenz> bye
16:41:01 <pesco> bye
16:42:30 <vincenz> it's rather late...and tomorrow is new year... so ...you know ..
16:50:34 <jadrian> so you should stay up late today as a preparation for tomorrow :)
17:40:00 <xerox> thanks for all, goodnight falks.
17:40:02 <xerox> *folks
17:41:23 <Lemmih> How do you cabalize a project which depends on a preprocessor?
17:42:08 <Calister> ni ni xerox
18:15:40 <ne1> Haha, I have installed firefox (windows), and can view pesco's page.
18:17:08 <ne1> there are reports that the acrobat reader plugin works not very well with firefox. we'll see.
18:39:53 <jadrian> how should I name a class of things one can apply susbtitutions too?
18:40:03 <jadrian> "Substitutable"? :)
18:41:17 <dons> Subable?
18:42:09 <jadrian> does that word exist?
18:42:56 <Cale> what kind of substitutions?
18:43:08 <jadrian> variable substitutions
18:43:10 <Cale> perhaps indeterminates?
18:43:39 <dons> class Substitute a where
18:43:40 <jadrian> variables in the context of first order logic
18:44:17 <jadrian> dons: hmm yeah, that's probably better than "Substitutable"
18:46:21 <dons> e.g. we have class Functor , not Fmappable ;)
18:47:05 <dons> class Monad, versus Sequenceable/Monadable :)
18:47:30 <Cale> Fmapple, the next big fruit drink?
18:47:36 <dons> yeah!
18:48:18 * shapr swears at darcs
18:48:20 <dons> we have Typeable, but not Datable
18:48:23 <shapr> it killed my repo :-(
18:49:11 <dons> Monoidable might be fun
18:50:31 <aj> shapr: ??
18:50:32 <shapr> A transistor is just an AND gate, right?
18:50:44 <shapr> aj: I got the weirdest error I have ever seen.
18:50:59 <shapr> several thousand lines of error in fact.
18:51:01 <Lemmih> Any Cabal guru's in here?
18:51:32 <shapr> Any photorefractive crystal gurus in here? 
18:52:19 <dons> :p
18:52:43 * shapr has a crazy idea about using consumer quality photorefractive crystals as FPGAs.
18:52:53 <dons> wrong channel, shapr. you need #photorefractivecrystalgurus
18:53:12 <shapr> I bet there's no one there :-P
18:53:55 <shapr> dons: do you know anything about photorefractivity?
18:54:49 <dons> nope :)
18:55:41 <shapr> I really need to pick up a laser, some photorefractive crystals, and some sort of equipment that measures changes in photorefractive index.
18:55:48 * shapr asks google
19:03:45 <shapr> Physics is so screwy. According to some sources you could propagate entangled photon information at six times the speed of light.
19:03:57 <shapr> dons: how's code?
19:04:03 * Lemmih thinks shapr should be less distracted.
19:04:45 <shapr> Lemmih: It depends on the goal. Is my goal to contribute positively to the human society? Or is my goal to complete whatever tasks I have?
19:06:03 <shapr> This crazy photorefractive idea might allow you to buy CPUs by the pound.
19:06:22 <shapr> er, kilo
19:06:24 <shapr> whatever
19:10:06 <shapr> Lemmih: on the other hand, if I never complete anything, I don't contribute positively to anyone.
19:13:46 <dons> code is coming along. really attacking syn hl now. I think I've got the types about right, for standard syn hl. need to finalise the interface, and modify the ghc parser to work with the api
19:14:19 <shapr> spiffy!
19:14:29 <dons> seafood just got ghc loading Core plugins :)
19:14:42 <dons> whoohoo
19:15:48 <shapr> whoa nifty, runtime reloadable optimizations?
19:16:00 <dons> yep
19:16:16 <dons> and user-defineable optimisations
19:16:42 <shapr> That's awesome. That could do many nifty things.
19:17:42 <shapr> If there were a simplistic supercombinator implementation of GHC, you could bootstrap from almost nothing.
19:18:20 <shapr> Is he adding a QuickCheck wrapper to test plugins for safety once they're loaded?
19:18:21 <dons> that's an interesting idea
19:18:38 <dons> hmm. good idea!
19:19:02 <shapr> A quickcheck/hunit wrapper would let you try out totally crazy sounding optimizations and see if there's a failing case.
19:35:09 <CosmicRay> that guy should be kickbanned.
19:35:18 <CosmicRay> he just msg--spammed me
19:36:22 <Cale> He should be banned from the network.
19:36:29 <CosmicRay> I agree.
19:36:38 <Cale> though it looks like he just killed himself :)
19:42:08 <Lemmih> YDVSZYTS: Go away!
19:49:22 <dons> grr
19:58:52 <ne1> It must have been a robot.  By the second law it is bound to obey your command.
20:20:00 <Lemmih> dons: You parse the text and then do syn hling according to the parsed structure?
20:36:12 <dons> Lemmih: yep
20:52:08 <Lemmih> dons: And will it be possible to perform edit operations on the parsed data?
20:55:34 <dons> that is the plan, yes. the abstract syntax will be available, so we should be able to inspect and edit it 
20:56:01 <dons> at first, I just want it for syn hl. but then more interesting things can be done
20:57:03 <dons> I've been looking a lot at an ML editor along these lines: ftp://ftp.inria.fr/INRIA/publication/publi-pdf/RR/part3/RR-3139.pdf
20:58:56 <dons> I don't necessarily want to use that design exactly, but the features it provides are some of what I'd like
21:04:54 * Lemmih is overwhelmed by a desire to contribute.
21:06:03 <dons> yay!
21:06:54 <dons> once I've got the basic syn hl stuff in place, there should be a lot more scope for contributions. atm, it is really editor bindings that could be further worked on
21:07:53 <dons> if there is something you were thinking about, let me know :)
21:09:20 <dons> and shapr needs to get hacking on that emacs binding. (including the tutorial)
23:15:47 <whip> sup yall
23:20:29 <whip> has anybody used haskells foreign function interface ?
23:21:10 <sjanssen> nope
23:21:15 <sjanssen> will you be the first?
23:21:24 <whip> if necessary.
23:21:29 <whip> ive used java's jni
23:21:48 * ibid has used it
23:21:51 <whip> but there is greater distance between common haskell and c data types
23:22:02 <whip> ibid... my dear friend
23:22:06 <ibid> heh
23:22:12 <whip> im looking at using green card
23:22:14 <whip> to make things easier
23:22:22 <whip> what have you used
23:22:32 <ibid> i used to use green card years ago
23:22:47 <ibid> lately i've used the standard ffi directly
23:23:00 <ibid> for a large library, i'd probably investigate c->haskell
23:23:12 <ibid> or whatever it's called
23:23:30 <whip> why is that
23:24:00 <ibid> it seems the most appropriate
23:24:14 <whip> ... ok
23:25:13 <whip> i just dont really feel like learning the gory details of the ffi when i just have a couple fairly simple functions to call
23:25:40 <ibid> standard ffi is not that goreful
23:25:48 <ibid> in fact, it's quite pleasant
23:25:57 <ibid> as long as the functions are straightforward
23:26:40 <whip> really
23:27:03 <ibid> basically, you just declare the function in your haskell module (with a special syntax) and call it as usual
23:27:24 <ibid> as long as you are not trying to move complex data structures back and forth
23:28:15 <whip> ok maybe ill check it out then
23:28:31 <whip> i do have one tricky conversion to make
23:28:47 <whip> from a variable length list to a bitmask
23:29:03 <whip> but thanks
23:29:42 <ibid> np
23:30:22 <whip> green card seems to make simple conversions easy
23:30:45 <whip> because it provides a bunch of predefined functions for ints,floats,strings, etc.
23:32:25 <whip> but ill probably have to figure out how to do the tricky stuff myself anyway
23:33:46 <ibid> you don't need any predefined functions for ints etc with standard ffi
23:33:56 <ibid> it's done for you by the compiler
23:34:08 <ibid> it's only pointers and such stuff that require trickery
23:40:08 <whip> oh i have got to go to the source now
23:40:14 <whip> "tools"..  pfff
23:44:01 <ibid> read the ffi spec
23:49:34 <whip> yup
