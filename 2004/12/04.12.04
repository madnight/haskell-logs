01:07:37 <bourbaki> moin
01:14:39 <tintin> hello all 
01:14:53 <tintin> is yi the emacs being written in haskell ?
01:15:02 <lament> o___________________________________O
01:25:06 <blackdog> tintin: yi is an editor being written in haskell. It has emacs keybindings, or did reasonably recently. It's meant to be extensible like emacs.
01:38:37 <tintin> em as opposed to a clone of emacs ... its a new editor ? 
01:48:34 <Nioate> that's my understanding
01:51:44 <musasabi> morninh
01:51:55 <musasabi> blackdog: yi has nano and vi bindings too.
01:53:03 * dblhelix is away: I'm busy
02:25:51 * vegai had a crazy idea of using darcs for roaming profiles
02:25:59 <vegai> somebody shoot me :P
02:26:54 <tintin> yi can multitask unlike emacs ? 
02:46:36 <blackdog> vegai: I've been thinking of doing the same thing.
02:46:55 <blackdog> people use cvs for it already...
02:47:46 <vegai> yi is already an OS? =)
03:01:34 * dblhelix is back (gone 01:08:30)
03:06:13 <Janni> Hi.
03:13:36 <rene[G]ade> hi 2 all
03:14:48 <musasabi> hello
03:16:16 <vegai> blackdog: had any extra ideas, or just darcs push at every logout and darcs pull at every login?
03:16:34 <vegai> or per reboot?
03:16:55 <vegai> manually, perhaps?
03:17:54 <blackdog> that's more or less the shape of it. probably manual for me - I can't always rely on internet access
04:53:31 <Darius> @seen Pseudonym
04:53:31 <lambdabot> I saw Pseudonym leaving #haskell 1 day 4 hours 55 minutes 47 seconds ago
05:28:15 <pesco> Moin Moin!
05:31:29 <Jan_w> g'mornin
06:12:13 <shapr> y0
06:12:27 <xerox> yo!
06:13:11 <pesco> Yo.
06:14:10 <pesco> I made a convenience wrapper around Text.Regex yesterday. Care to have a look?
06:15:56 <pesco> *shrug*
06:21:16 <Janni> re
06:22:56 <pesco> Hello, Janni.
06:24:04 <pesco> Where are you from? I'm from Hamburg.
06:32:28 <pesco> Ah, that's better.
06:44:40 <Symmetry-> can I use haskell to create Windows executables?
06:46:45 <Symmetry-> or is this an RTFM issue?
06:46:57 <pesco> It's a RTFGHCM issue. ;-)
06:47:28 <pesco> That's to say, yes, GHC runs on Windows, too and creates Windows executables there.
06:47:31 <vegai> JFDI-issue =)
06:47:36 <vegai> (Just Do It)
06:47:57 <Symmetry-> i'm pulling GHC now thanks =)
06:48:08 <pesco> Does Hugs run on 'dows?
06:48:09 <Symmetry-> so, um, there are ways to call C libraries from inside Haskell?
06:48:15 <Symmetry-> yes pesco
06:48:20 <pesco> Ah yes! The FFI!
06:48:41 <pesco> Check the website, the foreign function interface is an addendum to the Haskell report.
06:48:53 <Symmetry-> great
06:49:12 <Symmetry-> i thought that was Failure to Follow Instructions
06:49:26 <pesco> Hah! You might also want to check out handy tools like c2hs from Manual Chakravarty or greencard.
06:49:54 <pesco> Those help mapping C interfaces into Haskell.
06:50:01 <pesco> They use the FFI.
06:50:04 <Symmetry-> neato
06:50:28 <pesco> s/Manual/Manuel/ of course. Damn fingers.
06:50:50 <Symmetry-> i found c2hs, many thanks
06:51:05 <pesco> Ok. c2hs is very useful. I've used it myself.
06:51:34 <Symmetry-> so you've actualy written GUI programs with Haskell?
06:51:45 <pesco> Well, in a sense.
06:51:48 <Symmetry-> are they shorter, etc.?
06:52:07 <Janni> pesco: Sorry was away. I'm from Karlsruhe
06:52:59 <pesco> Janni: Ah, hm. I tried to read it from the traceroute but sf-sb4.F.DE.net.DTAG.DE sounded like Frankfurt. It didn't get further. :(
06:53:13 <pesco> Symmetry-: I'd guess so.
06:53:59 <Janni> Symmetry: I'm writing a GUI program with Haskell (using wxWindows). They are shorter indeed.
06:54:35 <Janni> It runs on Windows as well as UNIX. It uses OpenGL.
06:54:50 <Symmetry-> sweet. I can't wait to get my hands on it
06:54:53 * Janni has the feeling there is somebody to convince, you can actually DO stuff with haskell.
06:55:30 <pesco> We'll just keep throwing buzzwords at him. ;)
06:57:17 <Symmetry-> heh
06:58:07 <Symmetry-> they usually silence me on #C++ with "sequence points"
06:58:31 <Remco> hi all :-)
06:59:01 <pesco> What are sequence points?!
07:00:18 <Symmetry-> see?
07:00:33 <pesco> Grmbl. I thought they would have told you.
07:00:44 <Symmetry-> they're somewhere in chapter 72, subsection A.98.a.1 of the Standard
07:01:16 <Symmetry-> well... technicall they're ; } and a few other things, "separators" so to speak
07:01:28 <Symmetry-> beyond which operators like ++ don't interfere with each other
07:01:57 <pesco> Oh, great.
07:03:06 <Darius> sequence points: things Haskell doesn't care about
07:05:40 <Symmetry-> you have "monadic covariance"
07:05:53 <pesco> What's that!
07:05:53 * Symmetry- checks the spelling
07:08:58 <pesco> Covariance, E(X^2-Y^2) - EX^2 - EY^2 ?
07:09:17 <pesco> Er (X-Y)^2 I meant
07:09:55 <pesco> I don't know. I'm just randomly poking around memory blocks long since flagged for reuse.
07:10:41 <Symmetry-> i don't know, i was just reading the IRC "quotes" page and it keeps popping up
07:11:34 <pesco> I don't think it has anything to do with statistics, though.
07:13:14 <Symmetry-> i don't know, i heard about Haskell 2 months ago
07:15:57 <pesco> Oh, just ignore my appearently senseless ramblings. I'm trying to make a fool of myself. ;)
07:22:59 <Spark> need to add #haskell to autojoin really :)
07:25:53 <Oejet__> Igloo, just found out that someone also called Igloo won the ICFP programming contest.  Congratulations if it's you.  I participated myself. :-)
07:29:24 <Igloo> It is - thanks  :-)
07:29:35 <Igloo> And kosmikus and Heffalump sometimes on this channel
07:29:57 <Oejet__> I remember to have seen kosmikus.
07:30:51 <Oejet__> It was a really nice problem, I think.
07:35:20 <Oejet__> Igloo, may I ask how you organized your team, how fast you did the different programs, and any great programming troubles you had.
07:37:58 <shapr> Symmetry-: Which irc quotes page? The one one the Haskell Wiki?
07:38:13 <shapr> pesco: oh, can I see your convenience wrapper?
07:38:52 <pesco> shapr: Yes of course. ;) http://www.scannedinavian.org/~pesco/code/Regex/Pesco/Regex.lhs
07:39:03 <shapr> tintin: yes, Yi is multithreaded, unlike emacs.
07:39:17 <tintin> ah excellent shapr
07:39:39 <tintin> and it can handle the elisp part ? (in the works maybe )
07:39:43 <pesco> It's unfinished and unpolished, but the code works and is 1.0-feature-complete, I think.
07:39:46 <tintin> elisp being emacs lisp 
07:39:49 <shapr> pesco: the docs for your code are often more entertaining than the code itself. I still chuckle when I read TypeModule
07:39:58 <shapr> tintin: nope, Yi uses Haskell for its scripting.
07:40:01 <Igloo> Oejet__: Yeah, we really like the problem too
07:40:17 <pesco> shapr: Hehe, let me read that again myself!
07:40:24 <tintin> shapr: but a compatablity layer forr emacs lisp maybe ? 
07:40:29 <shapr> pesco: do you write fiction as well?
07:40:36 <tintin> there are so many goodies out there :)
07:40:46 <shapr> tintin: you'll have to write it yourself I think.
07:40:54 <pesco> shapr: No, but maybe that wouldn't be such a bad idea...
07:41:18 <Igloo> We didn't really have any great troubles, which is I think why we won. I think we had the ant essentially done 1/2 the way through. The visualiser, simulator and meta language were probably ready before the end of day 1. Can't really remember now...
07:41:38 <shapr> tintin: it would be easier than you might think... Ashley Yakeley's HScheme and Mattias (Mr Preprocessor) Neubauer's elisp to scheme converter should get you 95% of the way there.
07:42:13 <shapr> pesco: At a minimum you should write essays, blog entries, something.
07:42:25 * Darius hugs Firefox's tabs.
07:42:29 <Riastradh> Matthias Neubauer is also known as Mr Preprocessor?  Odd.
07:42:37 * Riastradh wonders how many of them there are.
07:42:41 <shapr> Did I get the last name wrong? 
07:42:50 <shapr> The guy who hangs out with Peter Thiemann?
07:43:03 <shapr> doh!
07:43:06 <shapr> Michael Sperber
07:43:10 * shapr is embarassed
07:43:18 <shapr> Riastradh: thanks for pointing that out.
07:43:25 <Darius> Gah, TinyOS is a 146 MB download.
07:43:41 <pesco> shapr: I'll remember that.
07:43:50 <tintin> is that linux Darius ?
07:43:55 <shapr> I wonder why I confused Mattias Neubauer with Michael Sperber?
07:44:05 <Darius> tintin: No.
07:44:19 <Symmetry-> what's TinyOS?
07:44:27 <Darius> tinyos.net
07:45:02 <tintin> TinyOS is an open-source operating system designed for wireless embedded sensor networks. It features a component-based architecture which enables rapid innovation and implementation while minimizing code size as required by the severe memory constraints inherent in sensor networks.
07:45:32 <tintin> which is outside my realim of immediate interest 
07:46:20 <Darius> tintin: Give it 10 years.
07:46:31 <Symmetry-> I would have googled but by bandwidth is taken with the GHC download ;)
07:49:12 <shapr> oh my! Gödel attacks already exist in some form.
07:49:16 <shapr> They're called basilisks.
07:49:54 <shapr> hiya vinodh2
07:50:05 <vinodh2> hey, how's it going?
07:50:20 <shapr> I'm finding new ideas, how's it going with you?
07:50:40 <Darius> shapr: What the heck are you talking about?
07:50:55 <vinodh2> Uggh, you know - to be honest - I've been having trouble learning new stuff.
07:51:22 <vinodh2> Although interesting, it just slides across my brain without gaining purchase.
07:51:44 <shapr> Darius: Have you read Gödel, Escher, Bach? You remember the record that breaks the record player?
07:52:05 <Darius> Yah
07:52:18 <shapr> http://www.nature.com/cgi-taf/DynaPage.taf?file=/nature/journal/v402/n6761/full/402465a0_fs.html
07:52:38 <shapr> I've been looking for deterministic ways to calculate Gödel attacks for any system.
07:53:20 <shapr> I've also been trying to see if there's some way to overlap systems to beat Gödel attacks, but I think that's totally lost cause. Any two systems are just a single larger system.
07:54:04 <shapr> amusing, comp.basilisk
07:54:15 <xerox> what's that?
07:54:21 * shapr chortles
07:56:43 <shapr> vinodh2: so, are you learning Haskell that way?
07:56:49 <Darius> shapr: I very much doubt that one could deterministically create Goedel attacks.  While it may be possible in theory (which I'm not sure about), it should lead to ever more and more complex systems eventually exploding your brain.
07:57:34 <shapr> hej bringert 
07:57:40 <bringert> hej
07:57:51 <andersca> hej bringert 
07:58:10 <bringert> hej andersca
07:58:16 <bringert> how did last night end?
07:58:16 <vinodh2> shapr: Oh no, not now.  (I'm just been perusing the channel links.  That's real impressive the top 4 places for ICPF are occupied by Haskell).
07:59:16 <shapr> Yes, Haskell is way spiffy.
07:59:29 <andersca> bringert: interesting...
08:02:23 <pesco> I'm currently reading Asimov's Foundation trilogy and Haskell strangely reminds me of the Foundation. I'm just wondering how "avoid success at all costs" fits into the picture.
08:02:37 <shapr> speed of change
08:02:48 <pesco> Exactly!
08:02:50 <shapr> Not sure if that fits into the Foundation trilogy though.
08:03:26 <pesco> Of course! They don't thrive to expand and conquer rapidly.
08:03:37 <pesco> They just follow the plan.
08:03:40 <shapr> ?
08:03:49 <shapr> Which, the foundation?
08:03:52 <pesco> Yes.
08:04:11 * shapr tries to remember all the details of Hari Seldon's plan.
08:04:49 <pesco> Remember the crisis when the old Imperium attacks?
08:05:19 <Igloo> And every year the image of SPJ appears at HW to impart new knowledge upon us...
08:05:36 <Igloo> And it looks so real!
08:05:56 <musasabi> Getting a new standard out is much more important than making haskell more popular..
08:05:58 <wli> HW?
08:06:04 <Igloo> Haskell Workshop
08:06:08 <musasabi> Cabal is also a good addition..
08:06:28 <Igloo> Getting a new standard out is is /part of/ making Haskell more popular, I'd say
08:06:52 <musasabi> But the more popular it is the harder it is to make changes.
08:07:14 <vegai> libraries libraries libraries. That's what we need
08:07:16 <shapr> Igloo: bwahaha
08:07:24 <Remco> hmm, a short question, when I make a function that outputs it given arguments, how do I call it once I load this function ? Somehow it doesn't seem to work. I tried main 1 3 for example.
08:07:31 <shapr> Igloo: that's totally quotable =)
08:07:38 <pesco> musasabi: So we must make changes slowly and thoughtfully.
08:07:38 <Remco> and for the ones who wonder which function i wrote:
08:07:39 <Remco> main = do x <- getArgs
08:07:39 <Remco> 	 print x
08:07:41 <wli> I'd say memory footprint.
08:08:01 <musasabi> wli: that is mostly about String...
08:08:13 <wli> might as well give up on the variables and do main = getArgs >>= print
08:08:20 <wli> musasabi: hm?
08:08:24 <Remco> yes okay, but how do i call it ?
08:08:33 <Igloo> Remco: Tabs are generally considered inadvisable
08:08:44 <Remco> hmm
08:08:45 <musasabi> wli: many simple haskell memory problems originate from strings.
08:09:02 <musasabi> they are just too expensive.
08:09:34 <Remco> well ok, but the question remains :) how do I call it ?
08:09:36 <wli> musasabi: I guess linked lists are kind of bloated for 1B elements
08:09:43 <shapr> Ya know, any joke that requires knowledge of Haskell and a specific science-fiction series probably qualifies as stratospheric.
08:09:52 <tuomov> except they're not 1byte
08:10:00 <tuomov> strings are supposed to be unicode
08:10:04 <shapr> pesco: was that thrive? or try?
08:10:15 <musasabi> I have noticed that either 1) my program does not use strings much and does not care how they are represented 2) my program uses lots of strings, and I cannot use String because of the memory footprint.
08:10:31 <pesco> Er, it was thrive but is that word wrong?
08:10:54 <Remco> ie i want to call "Main 1 2 3" which should output ["1","2","3"]
08:10:56 <musasabi> tuomov: but you *can* use utf-8 strings they are not just used by default.
08:11:03 <wli> I wouldn't mind something like -ffunction-sections being usable so the binaries were a bit smaller.
08:11:10 <pesco> shapr: Ah, i meant strive. :-)
08:11:14 <musasabi> tuomov: see e.g. how ghc stores string constants holding non-ascii values.
08:11:15 <shapr> ah
08:11:20 <pesco> Strange mix-up
08:11:23 <wli> I think I mostly don't care about strings.
08:11:51 <tuomov> the way strings appear to the programmer is very convenient, and I wouldn't want to change that
08:12:02 <tuomov> we just need optimisations under the hood
08:12:02 <Darius> Igloo: Tabs are generally considered evil.
08:12:02 <Darius> wli: Well, technically they are Unicode so more like 4b and I believe all implementations use words for Chars.
08:12:36 <wli> Darius: that will be large
08:12:46 <Remco> well I had to put some spaces between it because else it would give me the nice " Last generator in do {...} must be an expression " error
08:12:57 <Igloo> Only a factor of 4 - less once you have the overhead of the lists, boxing etc
08:13:00 <Remco> so I thought, why not tabs
08:13:01 <Remco> :)
08:13:25 <pesco> Remco: Because nobody knows how wide they should be.
08:13:40 * Remco votes for 4 spaces
08:13:49 <xerox> so put 4 spaces (;
08:13:52 <Remco> let's make tabs universal
08:13:57 <Riastradh> Tabs are evil!  Down with tabs!
08:14:00 <Igloo> If they're four spaces your code above would be invalid
08:14:03 <shapr> universally excommunicated?
08:14:08 <tuomov> tabs are too much trouble
08:14:12 * Riastradh prances about the room waving a 'DOWN WITH TABS' sign.
08:14:23 <Remco> yea ok so I don't use them anymore, but anyway, how would I call my Main function ?
08:14:24 <pesco> Excommunicate tabs! Is there a pope in here?!
08:14:30 * xerox shoots at the sign, for fun
08:14:30 <shapr> There's nothing quite so painful as using tab containing code where you really have no idea what tab size they were using.
08:14:45 <pesco> Remco: compile, run.
08:14:46 <shapr> Oh, I found out that excommunicate in swedish is considered a very strong swearword.
08:14:49 * Riastradh beats xerox down with the sign and continues.
08:14:50 <shapr> Crazy, eh?
08:14:51 <Remco> hmm
08:14:52 <wli> I just use 8-column interpretations of '\t' and say anything that nests deeply enough for that to be a problem is FITH.
08:15:00 * xerox respawns and rais Riastradh
08:15:03 <xerox> *rails
08:15:10 <shapr> what's FITH?
08:15:12 <Riastradh> ...'rails?'
08:15:18 <shapr> oh, In The Head?
08:15:25 <xerox> quake3-ish *g*
08:15:34 <Remco> pesco: thats the thing... it would just call main then which returns me an empty list
08:15:37 <wli> shapr: yes
08:15:43 <Remco> I want to give it arguments :P
08:15:49 <xerox> from "rail-gun"
08:15:51 <shapr> I'll give you an argument!
08:15:59 * Remco holds his hands up
08:16:01 <vinodh2> Well, if each of your forms was surrounded by a pair of parenthesis, then the editor would be able to automatically format your code. (The tabs would be superfluous).
08:16:05 <vinodh2> Just an idea.
08:16:21 <shapr> vinodh2: that sounds like .... lisp or something.
08:16:28 <Remco> anyway, brb gotta eat..
08:17:14 <vinodh2> Yeah, you know what they say ..... about other languages slowly reinventing lisp....
08:17:28 <shapr> If I really liked extremely regular syntax and autoformatting of code, I'd go for a postfix concatenative language. Those are even less trouble than lisp.
08:17:41 <shapr> Yah, but all those parentheses are a waste of typing.
08:17:54 <Riastradh> Whitespace is a waste of typing.
08:18:00 <shapr> I type whitespace.
08:18:04 <shapr> er "I don't type whitespace"
08:18:05 <vinodh2> (1 2 3 +)
08:18:11 <vinodh2> oops I meant    
08:18:14 <vinodh2> 1 2 3 +
08:18:17 <shapr> vinodh2: with 1 2 3 + + you don't need parens
08:18:29 <pesco> Remco: Then you ran it without arguments. I'm suspecting you ran the program by double-clicking the executable in one of those "Windows"?
08:18:34 <Riastradh> Or: Saying that it's a 'waste of whitespace' is fairly ridiculous.  Noone notices that he's typing whitespace; no Lisper notices that he's typing parentheses.
08:18:37 <Riastradh> Er.
08:18:39 <Riastradh> Waste of typing, even!
08:19:00 * xerox agrees with Riastradh
08:19:21 <shapr> But with postfix concatenative languages, you don't have to type whitespace or parens, it's already known.
08:19:30 <vinodh2> shapr: Sorry, but is that two pluses  1 2 3 + +  ?
08:20:21 <shapr> Yes, because the addition stack operator takes two args off the top of the stack and puts back one arg.
08:20:58 <vinodh2> Okay, I see now.  Yes - that would work too.
08:21:33 <shapr> Of course, I still prefer Haskell over Lisp and/or Joy. (Joy is one of the postfix concatenative languages)
08:22:43 <ddarius> My main problem with Joy was partial application/"closures" was awkward.  At least the ways I could see.
08:23:03 <CosmicRay> shapr: you better be careful.  igloo's collection of obscure Haskell code is starting to rival yours :-)
08:23:05 <Riastradh> Gack.  How many Dariuses are there?  ('Darii?')
08:23:12 <shapr> My main problem with Joy is that I can't put most of the operators on the stack.
08:23:13 <Philippa_> my main problem is I like variables. If I'm having problems refactoring because of those, I can write a tool...
08:23:30 <ddarius> Riastradh: I got dropped.  But at least two.
08:23:39 <Riastradh> Oh.  You're the same as Darius?
08:23:40 <shapr> I want real first class manipulation. I can't push the succ operator and then dup it. Otherwise metaprogramming in Joy would be way powerful.
08:23:56 <ddarius> Riastradh: Yes.
08:23:57 <vinodh2> For me, anything functional is good.  But I use Common Lisp because there is support from commercial vendors (high quality boutique systems) and I like macros.  
08:24:12 <Philippa_> shapr: haskell on top of whichever funky semantics you like. Have fun :-)
08:24:22 <ddarius> shapr: Mess with Postscript
08:24:22 <shapr> Also, eager evaluation as you push onto the stack is handy, and I think it would be easier to automatically parallelize concatenative languages.
08:24:38 <shapr> I can push and manipulate ops as data with Postscript?
08:24:47 <ddarius> Though you can push [succ] and make a two element list from that then i it.
08:24:59 <shapr> yah, but that's sort of cheesy :-/
08:25:04 <Philippa_> heh
08:25:12 <ddarius> Yes (re PS)
08:25:35 <shapr> Joy just doesn't feel smooth without more first class manipulation.
08:25:36 <ddarius> It also has very late binding and very dynamic scope (as if it were a continuum).
08:25:50 <shapr> Ok, you've persuaded me to try PostScript.
08:26:03 * shapr wonders if the nearby printer supports PS
08:26:20 <ddarius> shapr: Well in PS, you can push names.  It also has executable arrays which are like Joy quotations.
08:26:26 <pesco> "the nearby printer"
08:26:30 * pesco giggles
08:26:31 <Riastradh> Every reasonable printer supports PostScript.
08:27:03 <pesco> shapr: sounds like a nethack adventure. "There's a printer nearby. You wonder whether it supports Postscript."
08:27:11 * shapr grins
08:27:22 <CosmicRay> heh
08:27:46 <pesco> Ah. I'm still waiting for the day I write my own MUD.
08:27:50 <CosmicRay> do you dare send it packets?  perhaps you'll be beaten by the evil PCL6 wizard!
08:28:34 <wli> hmm, I did darcs get --partial and seem to not be able to do much
08:28:54 <shapr> because you didn't get the history
08:28:57 <wli> any way to recover from that without starting over?
08:29:36 <shapr> I don't know. I've never tried to go from a --partial get to one with the real history.
08:29:40 <shapr> Good question though.
08:30:10 <vinodh2> So what was your favorite language before you discovered Haskell?
08:30:13 <wli> screw this, I'm dead in the water
08:30:28 * shapr asks on #darcs
08:31:03 <wli> *** #darcs : You can't join that many channels
08:31:19 * wli ftso IRC "admins"
08:32:08 <Igloo> vinodh2: Is this like tallest mountains? It was Haskell before anyone discovered it?
08:33:18 <pesco> Why can't I seem to come up with a combinator to make polyvariadic functions? poly :: (Poly p a b) => ([a] -> b) -> p  where p is something like (a -> ... -> a -> b)
08:34:29 <shapr> wnoise: hey, haven't I seen you on Gale?
08:34:46 <TheHunter> looks impossible to me.
08:35:26 <pesco> TheHunter: The problem is the result type.
08:35:31 <pesco> (obviously, duh)
08:35:34 <TheHunter> you'd need the size of the [a]'s at compile time
08:35:56 <shapr> Can you use the xml-rpc variable number of args trick?
08:36:25 <pesco> shapr: Which one is that? I know the one that Oleg demonstrated.
08:36:42 <shapr> You know the trick Lennart Augustsson used in his recent Printf?
08:36:48 <pesco> Heh, no?
08:36:52 <shapr> um
08:36:53 <CosmicRay> shapr: he used that one too?
08:37:06 <pesco> shapr: Look at Regex.lhs, class Subst.
08:37:10 <pesco> That's what I do now.
08:37:16 <shapr> CosmicRay: yah, part of that whole thread about printf
08:37:17 <wli> I suspect if I did something less stressful than kernel hacking for a living I'd have more patience somehow. e.g. things less stressful than ppl's data getting corrupted, boxen spontaneously rebooting during database queries, and fighting off Microsoft conversions in far-flung timezones.
08:37:19 <TheHunter> maybe ([a] -> b) -> (forall p. Poly a b => p)
08:37:24 <CosmicRay> shapr: that was me
08:37:29 <shapr> CosmicRay: yah, I know :-)
08:38:07 <CosmicRay> huh.  guess I'l have to go check it out
08:38:26 <CosmicRay> I am looking for feedback on the interface documented here.  http://www.complete.org/~jgoerzen/MissingH.FileArchive.GZip.html
08:38:33 <shapr> Lennart Augustsson is *good*
08:38:35 <TheHunter> oops, pesco, that's a special case of what you wrote.
08:38:35 <CosmicRay> specifically, the error checking is rather clumsy and inconvenient, I think
08:39:00 <CosmicRay> it's a little tricky because of laziness; certain errors can't be detected until the whole file is read
08:39:02 <Igloo> CosmicRay: You shouldn't put stuff under MissingH.*, just have a MissingH package
08:39:12 <CosmicRay> so I'm wondering if I should just use exceptions...
08:39:17 <CosmicRay> Igloo: Hugs doesn'thave packages, AFAICT
08:40:06 <TheHunter> pesco, i guess you need a phantom varible that encodes a Natural at the type level.
08:40:14 <Igloo> Ah, OK, it might be necessary in the short-term then
08:40:42 <Igloo> You should definitely have functions that work lazily
08:40:58 <CosmicRay> Igloo: I do use packages with ghc, though.  though a collision is still possible if two packages are used in one program
08:41:00 <TheHunter> pesco, just ignore me, prolly all of what i wrote is wrong.
08:41:04 <CosmicRay> Igloo: I do, or at least I think I do.
08:41:25 <CosmicRay> Igloo: but that's why I can't just have decompress return Either GZipError String.
08:41:29 <Igloo> You would return (String, Maybe Error) so people can force the error sacrificing laziness should they want
08:41:53 <musasabi> CosmicRay: s/String/FilePath/ 
08:42:00 <Igloo> Huh? decompress can't be lazy as-is surely
08:42:18 <CosmicRay> Igloo: the GZipError would only occur when parsing the header
08:42:28 <Igloo> Ah, sorry, I misunderstood
08:42:29 <CosmicRay> Igloo: any other problem would be reflected in that bool
08:42:43 <musasabi> and then supporting handles would be nice for all the cases when one uses stdin/out or sockets.
08:43:05 <Igloo> So it's only CRC checks that can fail later on?
08:43:08 <CosmicRay> musasabi: right, I'll add those.  I want to get this bit done first.
08:43:12 <CosmicRay> Igloo: correct
08:43:21 <CosmicRay> Igloo: the CRC cannot be checked until the entire file is decompressed
08:43:39 <CosmicRay> Igloo: also, there could be exceptions raised during the inflation, but I'm pretending those don't exist for now.
08:44:12 <musasabi> but in general the whole concept is problematic, as Strings grow too large.
08:44:29 <CosmicRay> musasabi: couldn't they be used lazily, just as with hGetContents?
08:44:42 <Igloo> Ah, right
08:44:59 <CosmicRay> I could imagine do {x <- hGetContents stdin; putStr $ decompress x} or something
08:46:03 <CosmicRay> Igloo: That (String, Maybe Error) thing would work for decompress for sure.  That makes a lot more sense than what I have now.  I suppose it could be used other places, too
08:46:12 <musasabi> CosmicRay: in our dreams that works.
08:46:18 <CosmicRay> musasabi: oh?
08:46:30 <Igloo> Well, you probably want the header errors to be separate as you have them now anyway
08:46:37 <CosmicRay> or even main = interact decompress
08:46:42 <musasabi> most of the time when doing serious IO using Strings is just too slow.
08:46:55 <Igloo> It'll be slow, but it won't use loads of memory
08:47:06 <CosmicRay> musasabi: yeah I know but I'm not worried about optimization at this stage
08:47:21 <CosmicRay> musasabi: I'm worried more about a convenient interface and not crashing due to overflowing the stack or heap
08:47:32 <musasabi> true.
08:47:46 <CosmicRay> besides, Igloo is using a list of Bools to represent the bits in the file, and that's not too slow :-)
08:48:41 <musasabi> This depends on the definition of too slow ;)
08:48:52 <wli> Just need to get some Cray-style machines with very fast RAM instead of caches.
08:49:11 <musasabi> When trying to process 20mb files one starts noticing why String is not nice..
08:49:34 <Igloo> Speaking of overflowing the stack, are you maintaining the crc32 strictly?
08:49:54 <CosmicRay> hmm.
08:49:57 <CosmicRay> no I'm not.
08:50:07 <Igloo> I suspect it'll explode on large files then
08:50:15 <CosmicRay> good point.
08:50:26 <CosmicRay> foo.
08:50:51 <CosmicRay> btw I am seeing some very large memory usage from inflate
08:51:02 <jadrian> another haskell related artcle in slashdot
08:51:05 <CosmicRay> about 208MB to inflate my 10Mb \0 test file
08:51:06 <TheHunter> pesco, i've got it:
08:51:06 <wli> and no TLB's (well, I'd personally recommend batch address translation)
08:51:16 <Igloo> Are you keeping the result in memory?
08:51:17 <TheHunter> @wiki HaskellIrcPastePage
08:51:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:51:18 <jadrian> someones trying hard to promote the language :)
08:51:20 <CosmicRay> Igloo: no
08:51:34 <Igloo> Oh. Does memory increase over time or just jump to 208M immediately?
08:51:47 <Igloo> And are you compiling with -O?
08:51:54 <CosmicRay> actually, never mind, I think the person who told me that just calling "length" on the result is bad, was right.
08:52:14 <CosmicRay> no, no -O args
08:52:32 <Igloo> length should be fine I think. Try with -O
08:52:41 <CosmicRay> took only 2M this time, with (\x -> (replicate 10485760 '\0') == inflate_string x)
08:53:14 <Igloo> Oh, OK
08:53:14 <xerox> 2Mzillions years?
08:53:17 <xerox> *g*
08:53:24 <wli> jadrian: which one?
08:53:35 <CosmicRay> xerox: 40 seconds :-)
08:53:44 <jadrian> wli: http://developers.slashdot.org/developers/04/12/04/0116231.shtml?tid=159&tid=156
08:54:05 <jadrian> wli: sometime ago there was one about darcs
08:54:33 <shapr> That guy who designed the puzzle showed up here a few times.
08:55:01 <shapr> He was really thrilled about Haskell.
08:55:40 <shapr> He got me started thinking about other strange uses of Haskell.
08:55:41 <CosmicRay> ghc is lots slower at compiling with -O.
08:55:48 <Darius> Yes.
08:55:56 <pesco> TheHunter: Wait, I'll find something wrong with it...
08:56:04 <Darius> Though in its defense a good chunk is gcc.
08:56:18 <shapr> I still want to try to pervert Hudak's Dance language into a martial arts design language.
08:56:28 <TheHunter> pesco, I just put an example there.
08:56:33 <Darius> shapr: *shudder*
08:56:40 <musasabi> Sometimes I start thinking ghc is slow. Then I look at g++ and ghc seems nice and fast again.
08:56:42 <shapr> Why yes, this push kick was designed with STATIC TYPE CHECKING!
08:56:43 <CosmicRay> Igloo: the memory requirements for the length test actually increased when I used -O
08:56:53 <CosmicRay> 125,647,420 bytes maximum residency (9 sample(s))
08:56:57 <CosmicRay>         242 Mb total memory in use
08:57:00 <shapr> Darius: don't like martial arts? :-)
08:57:09 <wli> jadrian: same one as yesterday
08:57:10 <Igloo> CosmicRay: What are you using to measure OOI?
08:57:14 <Darius> shapr: I do. -That's- the problem.
08:57:25 * Igloo can't think why length would need to keep hold of stuff
08:57:29 <CosmicRay> This comes from +RTS -sfoo, but I don't know what OOI is
08:57:37 <Igloo> Is length returning an Int or Integer?
08:57:45 <CosmicRay> should be an Int
08:57:51 <shapr> On the other hand, I could use such a modification of Dance to test my theory that martial arts and massage are duals of each other.
08:57:52 <Igloo> Out Of Interest
08:57:54 <CosmicRay> I think genericLength returns the Integer
08:57:54 <Darius> @type genericLength
08:57:55 <lambdabot> bzzt
08:58:00 <Igloo> Oh, duh, silly me
08:58:03 <CosmicRay> @type Data.List.genericLength
08:58:04 <lambdabot> Data.List.genericLength :: forall i b. (Num i) => [b] -> i
08:58:15 <CosmicRay> @type Data.List.length
08:58:16 <lambdabot> Data.List.length :: forall a. [a] -> Int
08:58:32 * Igloo can't think what the problem is then
08:58:56 <Igloo> Oh, maybe it's updates to the history
08:59:00 <CosmicRay> someone (Darius?) was telling me last night that since I'm never evaluating any of the objects, they...
08:59:02 <shapr> Darius: you think using a typesystem to design a martial art would mean it's no longer an art?
08:59:03 <CosmicRay> yeah, something like that.
08:59:06 <CosmicRay> I didn't quite follow it.
08:59:15 <CosmicRay> anyway, if I actually compare the result, it works fine.
08:59:15 <Darius> CosmicRay, it was me.
08:59:33 <Igloo> Well the output String will just be being thrown away as length walks down it
08:59:42 <CosmicRay> that's what I would have thought.
09:00:18 <Igloo> Can you try with history :: !(Array Word32 Word32) please?
09:00:43 <CosmicRay> ok, give me a sec.
09:01:32 <CosmicRay> oh btw, I hacked your inflate slightly:
09:01:38 <CosmicRay> inflate is = extract_InfM $ do set_bits $ concatMap int_to_bits is
09:01:38 <CosmicRay>                                x <- inflate_blocks False
09:01:38 <CosmicRay>                                align_8_bits
09:01:38 <CosmicRay>                                return x
09:01:42 <shapr> I think lambdabot needs a wtf plugin that includes oxfordisms.
09:01:48 <CosmicRay> without the align_8_bits, it was returning a few extra bits
09:02:09 <CosmicRay> which confused the code that looks at the gzip footer that follows the deflated data
09:02:31 <Darius> shapr: the thing that probably most was/is an issue, is 'martial arts -design- language'.  As a 'descriptive' language it would be (more) okay.
09:02:40 <xerox> erlang?
09:02:59 <chucky> I appear to have a problem. Shouldn't the following code return a list of every directory in "/"?
09:03:01 <chucky> getDirectoryContents "/" >>= filterM doesDirectoryExist
09:03:01 <xerox> oh, it's 'declarative' i think
09:03:09 <Igloo> Ah, OK
09:03:25 <CosmicRay> chucky: I suspect that getDirectoryContents is returning relative paths, not absolute ones
09:03:33 <pesco> TheHunter: Okay, thanks. One thing I can't get to work thoug, is psum = poly sum for any Num type.
09:03:37 <CosmicRay> chucky: so doesDirectoryExist will be looking for those names in your current directory
09:03:49 <Darius> shapr: What would the language be used for?
09:03:50 <chucky> ooooh.
09:03:57 <chucky> CosmicRay: Smart thinking. :)
09:04:02 <CosmicRay> danke :-)
09:04:15 <Darius> shapr: About the only reasonable use is I can think of is describing kata.
09:05:06 <TheHunter> pesco, that's the price you pay for -fallow-undecidable-instnaces.
09:05:15 <shapr> Darius: Personally, I'd use it to study the process that people like Bruce Tegner and Bruce Lee used to design their own systems, by comparing descriptions of their systems to descriptions of their 'input systems' Then I'd try to see if weak/strong points of the various systems can be spotted with such a tool.
09:05:35 <pesco> TheHunter: Is it?
09:06:10 <TheHunter> i believe so.
09:06:13 <chucky> cosmicray: Thanks, it works as expected now
09:06:18 <wli> I'm not even sure how you model stuff like that.
09:06:25 <pesco> Ah of course! Thanks. :)
09:06:33 <wli> OTOH I've never odne much AI.
09:06:34 <pesco> But isn't there a way to  direct it to pick the first instance for anything but function types?
09:06:38 <Darius> shapr: Hmm, it would depend on the level of description and how much can be assumed of the user.
09:06:43 <CosmicRay> chucky: no prob
09:06:50 <shapr> For example, ninjitsu focusses on close-in fighting and keeping visibility of the opponent. Could I quantify that by head position while fighting/moving and the average distance of various moves?
09:07:05 <Darius> shapr: It's fairly easy to say, "punch this direction at such and such a height" but describing what "punch" means is more tricky.
09:07:17 <shapr> The little I've read about hapkido implies that it's more about using the momentum of the opponent against them.
09:07:37 <shapr> Well, sure, you can only really describe and study such a system in the presence of an opponent.
09:07:49 <Darius> shapr: Yes, softer more circular styles would seem to need a rather precise treatment of motion.
09:08:02 <shapr> One thing about Dance, it only describes one person's movements at its most basic level. I want to describe the interactions between two people.
09:09:25 <wli> I'm rather stumped by all this. Can we start by how the bodies are modelled?
09:09:47 <shapr> Sure, lemme get the url to Hudak's Dance papers.
09:10:06 <Darius> shapr: The thing with dance is that you cannot "raise your arm to head height" wrongly.
09:10:18 <shapr> Darius: interesting point
09:10:23 <Darius> (or at least there's a much greater leeway)
09:10:25 <TheHunter> pesco, awesome! phantom params can do miracles. Check out:
09:10:36 <Darius> Whereas you can easily "punch" incorrectly.
09:10:46 <Darius> (e.g. locking your elbow)
09:10:51 <monochrom> phantom type params are neat.
09:10:52 <shapr> I would very much like to spned a few hours chatting with Hudak.
09:11:07 <TheHunter> psum :: Num a => a -> a -> a -> a
09:11:08 <TheHunter> psum (x::a) = poly (sum :: [a] -> a)
09:11:08 <monochrom> phantom type params are neat.
09:11:41 <shapr> wli: here's the paper I can find off the top of my head: http://haskell.cs.yale.edu/yale/papers/dance-30-tr/ but I think there's more than one.
09:11:48 <Darius> Phantom types are a clear argument to -added- functionality of a static type system v. a dynamic type system.
09:12:41 <TheHunter> and I guess with SPJ's scoping proposal, many phantoms would be made superfluous.
09:13:26 <pesco> TheHunter: Whats' the infered type of psum? I can't use ghci...
09:13:49 <TheHunter> psum :: forall p a. (Num a, Poly p a a) => a -> p
09:13:59 <pesco> Hah!
09:14:13 <shapr> I've been studying my own sense of balance in much greater detail since I started unicycling, I've noticed that left or right side dominance is much stronger than I thought. I wonder if Dance could be extended to model what training an athlete needs to improve their strength and coordination balance.
09:14:19 <TheHunter> but that breaks psum 1 2 3 :(
09:14:21 <pesco> Now, why is this working, suddenly?
09:14:24 <pesco> Huh?
09:15:39 <pesco> Ah, damn, you have to give explicit type signatures for the args.
09:16:10 <shapr> I wish I had pressure and movement recorders in my shoes, waist, and shoulders. I think I could dramatically improve my skills if I could figure out exactly what I'm doing wrong for tricks like idling, one-footing, etc.
09:16:29 <shapr> and I could do it with Haskell at the same time =)
09:17:20 <Remco> 17:18:18 (pesco) Remco: Then you ran it without arguments. I'm suspecting you ran the program by double-clicking the executable in one of those "Windows"? << what i did is: :load myprogram.hs, then i typed: Main 1 2 3, when I only type Main, i get an empty list returned (which is logical ofcourse)
09:17:27 <Spark> shapr: youre such a geek :)
09:17:42 <CosmicRay> igloo:
09:17:47 <CosmicRay>  9487 jgoerzen  18   0 1758m 764m 2932 T  0.0 86.4   0:31.50 runtests
09:17:53 <Darius> shapr: Paintables in your shoes.
09:17:53 <shapr> Spark: I'll take that as a compliment :-)
09:17:57 <TheHunter> pesco, i have an idea...
09:18:02 <CosmicRay> Igloo: making the history strict did not help :-)
09:18:20 <shapr> Spark: c'mon, you're studying intersection types for your PhD, right? And you call me a geek? ;-)
09:18:27 <pesco> Remco: Oh, in an interpreter, you have to tell it explicitly the command line arguments to use, try :set args
09:18:28 <Darius> (okay so that'd be overkill, but in all your clothing doing other things as well, how 'bout that)
09:18:33 <Philippa_> that reminds me: Spark, where've you got?
09:18:44 <Igloo> Heh, OK  :-)
09:18:45 <Philippa_> only I'm thinking I can make marginal use of intersection types in Tyop if I have the time
09:18:48 <TheHunter> pesco, no, fundeps didn't work :(
09:19:03 <shapr> Darius: works for me... I'll take whatever I can get. I know I could do nifty things with computers and sensors in my clothing.
09:19:16 <Spark> shapr: geekdom is a fine place to be :)
09:19:25 <TheHunter> at least we can get p b -> a if we change the first instance declaration.
09:19:26 <Philippa_> I dunno, geeksub can be fun too
09:19:26 <shapr> Other than just keeping from paying the parking meter as long as possible =)
09:19:55 <Spark> Philippa_: ive got as far as making a new .latex file and starting to put comments in it
09:20:00 <Philippa_> heh
09:20:08 <wli> pay a flunky to wipe the chalk off your tires
09:20:39 <shapr> On my paydays, I'd take $20 in quarters and run around about a block in front of the parking meter people and put money in the meters that had run out.
09:21:19 <TheHunter> pesco, ok, i got rid of the phantom param, but we still need an explicit type signature. I'll put it on the paste page in a minute.
09:21:20 <Darius> Doing it only a meter in front would be more entertaining.
09:21:41 <shapr> Darius: I tried that first, I discovered that being out of arms reach is a lot safer.
09:22:15 <Philippa_> heh
09:22:19 <Philippa_> they shouldn't /care/
09:22:23 <Philippa_> I mean, you're paying for the parking time
09:22:34 <shapr> The city gets $75 or so from each parking ticket.
09:22:52 <Philippa_> oh, I know
09:22:55 <Philippa_> but that's their problem
09:23:00 <Philippa_> they shouldn't be able to do anything about it
09:23:24 <wli> they rely on a nonzero noncompliance rate
09:23:31 <Philippa_> oh, I know
09:23:32 <wli> otherwise it loses money
09:23:32 <shapr> right, which is pretty silly.
09:23:34 <Philippa_> that's their problem :-)
09:23:56 <shapr> It's like the whole system encourages people to break the rules because it's profitable for the rulemakers.
09:23:59 <wli> paying the parking meters loses them money
09:24:25 <Philippa_> sure, but that's like saying "people need to commit more crime so we can fine them"
09:24:40 <wli> that's exactly what it is
09:25:08 <Philippa_> no, they're going further: "you can't prevent people from committing crime, that costs us!"
09:25:15 <shapr> A 100% solutions to any problem is rarely just prevention. 
09:26:11 <wli> look at it from a game theoretic point of view
09:26:16 * Darius wonders if shapr is aiding and abetting traffic violators.
09:26:20 <TheHunter> pesco, and it got rid of -fundecidable-instances!
09:26:25 <pesco> Wah!
09:26:31 <pesco> You're utterly amazing me.
09:26:53 <shapr> Darius: that would be very scary, some sort of law that said only the person themself could put money in the parking meter.
09:26:53 <Philippa_> wli: Their. Damn. Problem.
09:26:57 <pesco> Ah, and you switched to passing a continuation function . ;)
09:27:26 <wli> Philippa: AFAICT that's a normative notion.
09:27:37 <CosmicRay> can someone tell me what the purpose of Prelude.undefined is?
09:27:47 <shapr> CosmicRay: it's quite useful actually.
09:27:57 <Darius> shapr took the words out of my mouth.
09:27:59 <shapr> @type undefine :: Int
09:28:00 <lambdabot> bzzt
09:28:02 <pesco> TheHunter: Oh, no you didn't ;)
09:28:03 <shapr> doh
09:28:07 <shapr> @type undefined :: Int
09:28:08 <lambdabot> undefined :: Int :: Int
09:28:20 <shapr> hej psi
09:28:27 <psi> hey
09:28:29 <shapr> psi: how was the Go contest?
09:28:29 <CosmicRay> shapr: but when might I actually use it?
09:28:32 <Igloo> It's for when you should say error "Foo" but can't be bothered to think of a Foo
09:28:37 <CosmicRay> ah.
09:28:39 <CosmicRay> ok.
09:28:40 <psi> shapr: great
09:28:45 <psi> shapr: much better than i expected
09:28:52 <psi> i won 3 out 5 games :)
09:28:52 <TheHunter> pesco, i'm still not satisfied. everything should be point-free.
09:28:58 <shapr> undefined is also good for faking a type when you don't want to specify a value.
09:29:04 <psi> out of*
09:29:11 <shapr> Sometimes the type itself is the value you want.
09:29:33 <TheHunter> it's a shame undefined is such a pain to type.
09:29:41 <shapr> That's something I want to put into my "Cool Typesystem Tricks" chapter.
09:29:52 <shapr> und = undefined ?
09:30:14 <shapr> or maybe U.u
09:30:15 <TheHunter> i'm using bt = error "foo".
09:30:17 <Darius> CosmicRay: It's also 0 the morphism in a(n imprecise) categorical semantics of Haskell
09:30:22 <wli> Moving on, maximize the payoff for a player whose strategies consist of choosing behaviors of an opponent and amounts of money the opponent has to pay when one of those things is tripped over.
09:30:42 <psi> shapr: also, the swedish champion was there, and he held a great seminar
09:30:48 <shapr> wow neat!
09:30:53 <shapr> Now I'm sorry I missed it!
09:31:10 <shapr> Of course, I'd probably have to ask for a translation afterwards, but it sure sounds like fun.
09:31:16 <wli> There is a very simple optimum there, which is complete coverage of all behaviors.
09:31:19 <psi> it was in english :)
09:31:37 <TheHunter> actually the semantics of error is a pain, even destroying referential transperancy in the absense of seq.
09:31:44 <wli> The question is more of how to prevent the "opponent" from collapsing instantaneously.
09:31:49 <Darius> See shapr, you made a good choice being born in America.
09:32:01 <psi> there were people there from finland that didn't speak swedish
09:32:07 <shapr> I spent the sunny part of today doing real mountain unicycling in ankle deep just-fallen snow. I thought my legs were gonna fall off after five kilometers.
09:32:18 <TheHunter> undefined =/= \x -> undefined x
09:32:26 <shapr> wli: so you're saying that government is a parasite that uses the public as its host?
09:32:29 <wli> i.e. the above player only refrains from taking everything they've got in order to keep them paying money longer.
09:33:01 <Igloo> TheHunter: How is it observably different without seq in a lazy language?
09:33:06 <shapr> That's a standard poker strategy as well.
09:33:14 <wli> shapr: I'm not particularly convinced that implication is the important one.
09:33:17 <shapr> Namely, don't raise too high too early when you've got a good hand.
09:33:31 <shapr> wli: s'okay, I was just being a smartass anyway :-)
09:33:41 <TheHunter> Igloo, you're right, you need seq to distinguish it, but it's not seq's fault but the fault of undefined.
09:34:22 <Philippa_> wli: the government should be of at least equal value to the public to what the public put in to keep it going
09:34:26 <CosmicRay> is there a good place I could read about seq, $!, strict constructors, etc?
09:34:31 <Philippa_> it should be a symbiote, not a parasite
09:34:43 <shapr> Yah, I much prefer government as symbiote rather than parasite.
09:34:43 <Darius> @wiki EagerEvaluation
09:34:44 <lambdabot> http://www.haskell.org/hawiki/EagerEvaluation
09:34:45 <Darius> (?)
09:34:50 <wli> Philippa: again, that's normative
09:34:54 <Darius> @wiki ForcingEagerEvaluation
09:34:54 <lambdabot> http://www.haskell.org/hawiki/ForcingEagerEvaluation
09:35:16 <Philippa_> the alternative is that the rest of us don't give a fuck about the government anyway
09:35:16 <shapr> Though in my experience if you're having trouble dealing with laziness in your program, Darius can help ;-)
09:35:25 <CosmicRay> thank you
09:35:37 <TheHunter> @wiki ControlOperation
09:35:37 <lambdabot> http://www.haskell.org/hawiki/ControlOperation
09:35:46 <CosmicRay> shapr: I may well ask him at some point; I just want to properly make the crc32 calculation lazy in my gzip
09:35:58 <CosmicRay> shapr: I'd rather try it myself first :-)
09:36:11 <shapr> CosmicRay: yes! that's the Haskell and especially the #haskell way to do it.
09:36:14 <TheHunter> nope that's something different.
09:36:42 <shapr> I try not to ask a question here unless I've really exhausted all the possibilities I can find by myself.
09:37:01 <Darius> TheHunter:  In the absence of non-termination, wouldn't seq essentially be meaningless (as far as theory is concerned).
09:37:35 <TheHunter> Darius, i think so.
09:37:39 <Darius> In a sense, the meaning of seq -is- the fact that it distinguishes undefined and \x.undefined.
09:37:40 <Igloo> Not if you have exceptions like division by zero
09:37:57 <Darius> Igloo: I was counting them as 'non-termination'
09:38:10 <Igloo> Fair enough
09:39:10 <TheHunter> i still don't understand why the semantic of undefined :: a -> b shouldn't be the same as \x -> undefined :: a -> b.
09:41:24 <wli> undefined is \bot
09:42:53 <TheHunter> pesco, so that's the real definition of poly: poly = (poly .) . (. (:)) . (.)
09:43:42 <monochrom> Eww!
09:43:42 <Darius> @type let poly = (poly .) . (. (:)) . (.) in poly
09:43:43 <lambdabot> bzzt
09:44:15 <wli> yeah, I get infinite type badness with that too
09:44:26 <TheHunter> poly is defined in a type class
09:44:42 <TheHunter> *Main> :t poly
09:44:42 <TheHunter> poly :: forall p b a. (Poly p a b) => ([a] -> b) -> p
09:47:50 <Darius> TheHunter:  Having _|_ :: a -> b be identical to \x._|_ with (presumably) _|_ :: a /= \x._|_ would break the naturality of seq I'd imagine.
09:49:38 <pesco> TheHunter: Wow. But what's the type of psum now?
09:50:31 <TheHunter> psum :: Num a => a -> a -> a -> a; psum = poly sum. But you can only use it if the number of a's is fixed.
09:51:16 <pesco> I can declare psum = poly sum without a signature and the call it as (psum (1::Int) (2::Int) :: Int)
09:51:47 <TheHunter> psum :: forall p a. (Num a, Poly p a a) => p
09:52:27 <pesco> If I explicitly state that, I get "Could not deduce (Poly p a1 a1) from the context (Num a, Poly p a a)
09:52:27 <TheHunter> yep, that works, too.
09:53:12 <TheHunter> pesco, same here.
09:53:30 <pesco> Do you know why that happens?!
09:53:32 <bringert> shapr: when you take notes in swedish class, is that just new words, or other stuff too?
09:53:39 <monochrom> @info Poly
09:53:53 <bringert> if iy's just new words, is there a problem using flip's own word-adding feature?
09:54:10 <TheHunter> pesco, it might be a weird ghc thingy.
09:54:23 <pesco> Hm. *shrug*
09:54:42 <TheHunter> oh, sorry it's obvious that it does that.
09:55:16 <TheHunter> it doesn't know what a is.
09:57:42 <TheHunter> i have no idea how to give it an explicit type signature without having to use a phantom.
09:58:22 <Darius> @wiki HaskellIrcPastePage
09:58:22 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:58:36 <shapr> bringert: mostly new words, notable differences are particles verbs and idioms
09:59:29 <pesco> How do you make it work with a phantom?
10:00:23 <shapr> bringert: I tend to get a bunch of new words at the same time, so I'd like to be able to enter them all without requiring interaction other than keyboard (I have a Palm keyboard)
10:00:34 <bringert> ah, ok
10:02:16 <TheHunter> psum' :: (Num a, Poly p a a) => a -> p
10:02:16 <TheHunter> psum' (_::a) = poly (sum :: [a] -> a)
10:03:23 * Darius can't get rid of the sensation that he types some words by essentially smashing the keyboard since switching to dvorak.
10:03:54 <shapr> Darius: oh really? What do you mean?
10:04:21 <jadrian> One thing I wonder about Dvorak
10:04:34 <jadrian> would it usefulness depend on your language?
10:04:34 <pesco> Darius: Yeah, that wows me, too. startx takes two smashes, for example.
10:04:50 <Darius> When I type 'darcs' for example, I almost press all the characters at once.  I'm amazed that words like that come out more often then not rather than falling pray to race conditions.
10:05:19 <Darius> [pray/prey]
10:05:29 <Darius> er, vice versa.
10:05:55 <Darius> Though I actually saw one paper that used, [term/var].
10:06:36 <Darius> jadrian: Of course it would.  Probably doesn't help Japanese typers a bit ;)
10:06:44 <wli> I heard some bullcrap like the layout of various keyboards were devised to slow down typists when typewriters/etc. couldn't handle the speed with which ppl could type.
10:07:11 <jadrian> Darius: :)
10:07:19 <pesco> wli: That's not really bullcrap. It's just pathos.
10:07:20 <TheHunter> aren't {[]} a pain to use on a dvorak keyboard?
10:07:22 <jadrian> Darius: yes but other languages that use isolatin chars...
10:07:50 <jadrian> TheHunter: well they are a pain to use in any PT keyboard
10:08:11 <jadrian> TheHunter: for '[' it's AltGr + 8
10:08:28 <Darius> jadrian:  It'd have to be adjusted to be "optimal", though in general optimality would be a person-by-person thing.
10:08:31 <TheHunter> jadrian, german keyboard, too, that's basically the reason that I use a us layout.
10:08:39 <tautologico> pt = portugal ?
10:08:45 <jadrian> tautologico: sim ;)
10:08:59 <tautologico> jadrian: ah, brasil aqui :)
10:09:11 <pesco> {} just are because you have to press shift. On my Kinesis they get placed at opposite ends of the keyboard, so I need to switch shift keys.
10:09:19 <jadrian> tautologico: sim, com esse nome tinha de ser brasileiro ou português 
10:09:20 <jadrian> :)
10:09:35 <tautologico> é verdade, esqueço do nick as vezes :) mas de repente podia ser espanhol
10:09:44 <jadrian> sim bem visto...
10:10:26 <tautologico> I once had to use a pt keyboard and the delimiters are in odd places... a bit awkward to program :)
10:11:00 <jadrian> yeap, I'm used to it of course, but it's not that great
10:11:21 <jadrian> the only good thing about them is that they are all close together
10:11:30 <jadrian> () are in 8 and 9 
10:11:35 <jadrian> [] are in 8 and 9 too
10:11:45 <tautologico> I don't like the pt-br layout either... I always configure to us international
10:11:48 <jadrian> and {} in 7 and 0
10:11:58 <TheHunter> jadrian, pt and de seem to be very similar...
10:12:58 <jadrian> TheHunter: yeap, I've been told that before
10:12:59 <shapr> pesco: ah, you're using dvorak original then
10:13:12 <shapr> I'm started with dvorak-microsoft
10:13:13 <jadrian> TheHunter: I had a friend working there for some time
10:13:18 <shapr> which has {} next to each other.
10:13:33 <jadrian> brb
10:13:50 <pesco> shapr: Ah. I don't mind the two keys being where they ar.
10:14:09 <pesco> It was confusing at first because } is left and { right but I hardly notice anymore.
10:14:19 <shapr> I do very much prefer dvorak.
10:14:33 <shapr> Have you tried dvorak-right-hand on one of those flat keyboards?
10:14:33 <musasabi> fi has {} = 70, ()=89, []=89 which is annoying.
10:14:51 <pesco> shapr: I've tried dvorak-left-hand. It's cool.
10:14:58 <shapr> Darius: have you tried a Kinesis contoured?
10:15:05 <musasabi> Thus I am using plain english keyboard with all the finnish keys behind alt-gr
10:15:31 <shapr> I still think keyboards suck. If you use them a lot, they damage you.
10:15:36 <shapr> There must be a better alternative.
10:15:39 <Darius> shapr: No.  'don't really see it happening anytime soon.
10:16:06 <pesco> shapr: Jack on!
10:16:10 <shapr> I wish.
10:16:30 <pesco> ;)
10:16:37 <shapr> I've been thinking about designing binary-based spoken and written systems lately.
10:16:55 <shapr> I have a neat spiral-based writing system that produces a nifty binary-based orthography.
10:17:02 <tautologico> voice interfaces for programming would be a nuisance
10:17:06 <pesco> hihihi. Maybe train yourself to speak like a 900 baud modem.
10:17:14 <tautologico> module Bla
10:17:20 <Darius> If they taught kids binary, they'd be able to count up to 1023 on their fingers.
10:17:26 <pesco> lol
10:17:33 <tautologico> a space colon-colon space Integer
10:17:56 <shapr> Darius: have you seen the on-the-fingers vedic-maths-style calculation system?
10:18:03 <tautologico> computer "do you want a space or the letter 'a' followed by a space?"
10:18:09 <Darius> tautologico: As would most "direct manipulation" interfaces, and I'm really unsure how one would make a tangible interface to language abstractions.
10:18:18 <Darius> shapr: no
10:18:46 <shapr> I forget the details, but there are certain 'moves' you make to do division/multiplication, etc. It's actually quite elegant.
10:18:55 <TheHunter> ok, i'm givin' it a shot!
10:19:13 <tautologico> Darius: yes, I always thought so, and I don't see anything better than a keyboard, for now
10:20:00 <TheHunter> wah, it took me forever to write that sentence.
10:20:04 <shapr> Haskell isn't much higher-level lambda calculus, as I've learned from @eval. I wonder if a spoken programming language would be best started with lambda cal.
10:20:10 <monochrom> Wouldn't you be saying "a has type integer" instead?
10:20:57 <Darius> What if you have a function 'a' and values 'has', 'type', 'integer' !  !!  !!!!!
10:21:13 <monochrom> that's pathalogical
10:21:22 <Darius> Ack! Infinite metavoice input recursion.
10:21:28 <shapr> Maybe you'd end up with a spoken version of APL? 
10:21:44 <pesco> Of course most of language recognition hast to deal with context.
10:21:49 <Darius> Perhaps concatenative languages would be best then...
10:21:57 <shapr> yes, I've thought of that.
10:22:07 <shapr> would be weird to think about though.
10:22:44 <pesco> Maybe we should rather try to replace the keyboard with a digitizer pad.
10:22:52 <shapr> I'd much prefer a spellcasting paradigm where I could see sources and sinks, and spoken words would turn into program chunks that I could apply like point-free functions.
10:22:58 <Darius> shapr: Has anyone mentioned the (seeming) idealness of concatenative languages for being input vocally on the concatenative mailinglist
10:23:08 <shapr> Darius: don't think so
10:23:38 * arauko just bought Richard Bird: Introduction to Functional Programming using Haskell, 2nd edition 
10:23:48 <shapr> arauko: good book!
10:23:54 <arauko> Good!
10:23:57 <Darius> Hmm... Killer App: Programming PDAs
10:24:01 <TheHunter> darius, shapr, do you lose the ability to write on qwerty keyboards if you switch to dvorak?
10:24:06 <shapr> Darius: I bet you're right!
10:24:10 <shapr> TheHunter: I never had that ability =)
10:24:12 * shapr laughs
10:24:12 <tautologico> Darius: exactly... I always thought about that
10:24:16 <arauko> shapr, thanks god, i didn't waste my money ;_)
10:24:21 <pesco> TheHunter: Not necessarily.
10:24:41 <shapr> hei Lor 
10:24:50 <Darius> TheHunter: Not completely for me and I'm not trying to use QWERTY at all.  However, it only took me a week to be comfortable with dvorak.  I could relearn QWERTY in less time.
10:25:01 <Lor> Iltaa.
10:25:26 <Lor> A week?
10:25:32 <pesco> TheHunter: I lost it after relearning on dvorak and have been regaining the capability through sometimes forced use of querty.
10:25:43 <tautologico> syntax of PLs is rather predictable, with a good systems you would need to type only the identifiers
10:25:46 <Lor> Lord almighty, it took me three or four monts of continuous typoing before I got the gist of dvorak.
10:25:51 <shapr> qwerty typists look to me like they're taking the long way around to type every word.
10:25:51 <arauko> shapr, actually, i was looking for something else, and it surprised they had this book about haskell.
10:26:06 <TheHunter> ok, thanks, i think i'm gonna try switching.
10:26:09 <Darius> Lor: The first few days were horrible, painful.  But after that it wasn't too bad.
10:26:16 <xerox> shapr: what layout do you use?
10:26:20 <pesco> Lor: Wow. I learned for like three days. After a few weeks, I didn't feel a difference.
10:26:27 <shapr> xerox: heavily modified dvorak
10:26:29 * Darius thoroughly recommends it.
10:26:40 <tautologico> but 
10:26:45 <tautologico> } left and { right is weird :)
10:26:46 <xerox> hardware mods?
10:26:50 <Darius> I always thought it was better, but never "took the plunge" 'til I did.  
10:26:51 <shapr> It took me about a week to type better with dvorak than with qwerty, but then I never tried systematically learn qwerty.
10:27:24 <shapr> xerox: um, sort of... I use a Kinesis contoured keyboard, I've moved quite a few keys around, and several of the keys are bound to emacs functions
10:27:24 <Darius> (btw, the painful above was psychological not physical)
10:27:31 <xerox> pics pls!
10:27:35 <pesco> tautologico: That's just my keyboard. On a standard keyboard, they're as you'd expect.
10:27:50 <shapr> xerox: I'm a fan of Jeff Raskin's Humane Interface ideas, so I've applied them myself.
10:27:58 <tautologico> pesco: good to know... I've been thinking about trying dvorak
10:28:15 <shapr> I call my current layout "Not a Koala"
10:28:20 <tautologico> don't know how it would be for portuguese though
10:28:32 <xerox> any pic of that keyboard?
10:28:34 <pesco> tautologico: Just make sure you can take off three days or so where you don't _have to_ type.
10:28:37 <Darius> Lor: Did you try to learn without "cheating", i.e. looking at the keyboard if you moved the keys (or looking at a PDF on the screen as I did).
10:28:44 <shapr> xerox: it just looks like a standard kinesis contoured, I'll get a pic....
10:28:53 <xerox> thanks! (:
10:29:08 <pesco> tautologico: Use those three keys exclusively to make the switch, otherwise you might get stuck in an ugly half-learned state.
10:29:13 <shapr> xerox: http://www.kinesis-ergo.com/images/132.jpg
10:29:15 <Lor> Yeah. There wouldn't have been much point in looking at the keyboard and seeing the qwerty keycaps. :)
10:29:20 <pesco> thre days I mean.
10:29:27 <Lor> Well allright, maybe it wasn't three months. But too long, anyway.
10:29:32 <shapr> xerox: The new black models look much cooler - http://www.kinesis-ergo.com/images/500-blk.jpg
10:29:38 <xerox> antifuchs one!
10:29:45 <shapr> He has a black model?
10:29:56 <xerox> i want one.
10:30:05 <shapr> I have two. they're MINE!!
10:30:08 * shapr cackles evilly
10:30:12 <pesco> I have a black one, but they don't (or didn't) have them with dvorak keycaps.
10:30:24 <shapr> pesco: oooh, coool!
10:30:28 <tuomov> hmm.. is there any standard fi-dvorak layout?
10:30:35 <Darius> Lor: Assuming one can already touch-type, I'd suggest "cheating" (via the PDF or some such if moving the keys isn't viable) method when learning dvorak.
10:30:37 <tuomov> there's airas, of course, but it isn't exactly dvorak
10:30:39 <vegai> tuomov: svorak is pretty close
10:30:42 <shapr> tuomov: sort of, I've heard it called svorak
10:30:45 <vegai> tuomov: http://www.aoeu.info
10:30:52 <pesco> Which is a feature. Why would I want to look at dvorak keycaps anyway? Whats' the point of blind typing?! ;-)
10:30:59 <Lor> No, I couldn't touch-type before that.
10:31:00 <tuomov> well, swedish qwerty=finnish qwerty
10:31:02 <vegai> oops, what am I saying ;)
10:31:15 <Darius> Lor: I don't know what to say in that case.
10:31:27 <shapr> I have qwerty keycaps, which is handy for configuring my BIOS and stuff like that.
10:31:28 <vegai> tuomov: anyway, there are keymaps for practically everything svorak on that site
10:31:37 <Darius> Of course, then it would be pretty hard to type if the keys are all wrong and you can't "feel" the keyboard.
10:31:51 <Lor> tuomov, mine is 123456890+´ åöäpyfgcrl<¨ aoeuidhtns-' .,qjkxbmwvz
10:32:14 * Darius has QWERTY keycaps as other people use the computer and it makes no difference to him.
10:32:21 <tuomov> svorak seems decent. but of course I'll still make my <>| = altgr mapping
10:32:22 <Darius> (except for typing one handed)
10:32:46 <Darius> At which dvorak thoroughly sucks at in my opinion (which I view as indicating it's balancedness).
10:32:52 * shapr agrees
10:32:57 <vegai> <>|= are the same with svorak and fi-qwerty
10:33:15 <shapr> I want a USB kinesis model so I can have my dvorak-right-hand IBM clicky plugged in at the same time
10:33:19 <Lor> That's why there are special one-handed dvorak keymaps.
10:33:27 <tuomov> on my setup <>|=altgr, and altgr-SDF=<|>, altgr-IOHJKL = []{}()
10:33:43 <vegai> oh, right
10:33:53 <tuomov> the finnish/swedish kb layout with awful altgr+number combos sucks for programming
10:34:14 * Lor is pretty conservative and just uses the left windows key as a second altgr.
10:34:15 <Spark> â¬
10:34:25 <vegai> well, only if you use such a poor language that you need { and } :)
10:34:25 <pesco> $
10:34:40 <Lor> The worst problem with altgr is that you have to hit altgr and the other key with the same hand.
10:34:52 <wli> I'm a sun type 5 person
10:34:57 <shapr> can't you do sticky keys?
10:34:59 <vegai> but seriously, I agree
10:35:12 <tuomov> dead keys are evil
10:35:12 <Lor> Sticky keys are for handicapped people.
10:35:18 <Spark> i quite like {} syntax
10:35:29 <shapr> I do wish I had more modifiers keys on this kinesis.
10:35:32 * Darius is with spark.
10:35:44 <tuomov> hmm.. maybe I should switch to svorak..
10:35:45 <pesco> That's the great thing about the kinesis, it has enough keys under the thumbs for Ctrl, Alt, Meta, and Super for _both_ hands.
10:35:52 * wli is the linux sparc32 architecture port maintainer =(
10:36:01 <shapr> pesco: yes! Are you using that too?
10:36:13 <shapr> Best keyboard design I've seen yet: http://www.benjaminrossen.com/KBD/subframeset_keyboard.htm
10:36:22 <vegai> isn't the Kinesis really really expensive?
10:36:40 <pesco> shapr: Yes, since maybe two months or so, after I got off my butt to look at XKB again.
10:36:41 <shapr> nah, it's about 300 euro
10:36:49 <tuomov> although, re-learning all program bindings will be difficult
10:36:57 <jadrian> !
10:36:58 <tuomov> learning to type on a different layout not so much
10:37:01 <pesco> tuomov: surprisingly, not so much!
10:37:05 <vegai> shapr: well, I guess that's ok if it's the last keyboard one buys..
10:37:05 <jadrian> who packaged ghc and alex for SUSE 9.2?
10:37:13 <pesco> tuomov: I got the hang of vi and emacs again pretty quickly.
10:37:14 <shapr> really expensive is the datahand, which is a thousand euro per hand.
10:37:21 <jadrian> hmm Herbert Graeber
10:37:30 <pesco> And it's funny directing someone sitting at your dvorak to make a quick change with vi.
10:37:31 <jadrian> if you're around thanks!
10:37:33 <jadrian> :)
10:37:45 <pesco> Well, now you press J. Ok. then K.
10:38:01 <shapr> I was tempted to try datahand, until I saw the price.
10:38:51 <shapr> sexy keyboard, the flinder - http://www.benjaminrossen.com/KBD/images/assembly_32.jpg
10:39:10 <shapr> If they ever start mass producing the flinder, I'll buy one.
10:39:15 <Lor> I'd like a graphical browser that supported keyboard-only use as well as lynx does.
10:39:30 <shapr> galeon is pretty good for keyboard use.
10:39:36 <tuomov> imho firefox supports kb better than lynx..
10:39:44 <tuomov> typeahead rules!
10:40:12 <Lor> Does it support choosing a link with a number?
10:40:20 <jadrian> and haddock and happy!
10:40:23 <tuomov> no I don't think so
10:40:36 <shapr> m-number is for tabs
10:40:59 <Lor> That's the neat thing about lynx. It just shows a number next to each link, and all you need to do is type in a link number and hit enter.
10:44:34 <eixei|away> well, hi and bye more or less :-)
10:47:29 <tuomov> hmm... the lack of those small bulges on the index finger keys is annoying..
10:47:41 <tuomov> after having modded keys on the kb to svorak layout
10:49:06 <Darius> Yes, bulges are fairly critical.
10:49:41 <Darius> shapr: Besides me mentioning it above, you've heard of Tangible Interfaces?
10:50:58 <shapr> no?
10:51:12 * shapr googles
10:53:09 <shapr> oh, nifty!
10:53:17 * shapr likes Tangible Interfaces
11:00:04 <tuomov> I can't remember when I've last typed this slow
11:05:57 <Darius> Yeah, it -really- sucks at first.
11:06:06 <shapr> But it gets a lot better.
11:06:08 <CosmicRay> I tried it once.
11:06:12 <CosmicRay> I couldn't stand it.
11:06:14 <CosmicRay> it was way too frustrating.
11:09:30 <Darius> How long did you try before you gave up?
11:10:54 <CosmicRay> a couple of days, I think.
11:11:16 <CosmicRay> it was excruciating.  I'm used to being able to type at a certain speed
11:11:30 <jadrian> are there several Dvorak layouts? like Qwerty ones?
11:11:43 <shapr> Tangible Interfaces fit with my wish to bind emacs functions to the input and force-feedback features of my joystick.
11:12:14 <shapr> jadrian: there are three original layouts, and the microsoft, swedish, etc varieties.
11:12:21 <Darius> CosmicRay: It took me about 3ish days before I could type at a reasonable enough rate.
11:12:44 <shapr> August Dvorak made the two-hand, left-hand, and right-hand layouts for the US Navy. The one hand layouts were for veteran who had lost a limb.
11:12:46 <Darius> About a week before I was typing at about my old rate.
11:13:27 <shapr> Interestingly, the 'real' two hand layout has the two havles of the numbers swapped, because 9,0, and 1 occur much more often than the other numbers.
11:14:22 <shapr> This has made me facetiously wonder whether we should just cut it down to three numbers only, 0, 1, and infinity.
11:14:58 <Darius> shapr: Tangible Interfaces also incorporate using non-haptic objects that represent other, less manipulable objects, e.g. http://citeseer.ist.psu.edu/underkoffler98illuminating.html
11:15:09 <Lunar^> shapr: Did I tell you I have switched since EuroHaskell ?
11:15:21 <shapr> Lunar^: you switched to dvorak too?
11:15:44 <Lunar^> shapr: sure :)
11:15:48 <shapr> neat!
11:15:53 <shapr> What do you think?
11:15:58 <Darius> Lunar^: How was the transition for you?
11:15:59 <Lunar^> shapr: about 3 months ago... 
11:16:14 <Lunar^> shapr: I was helped a lot by using Mac OS X and Keyboard viewer
11:16:21 <CosmicRay> OK, I'm back to ask for help on strict evaluation :-)
11:16:25 <Lunar^> (that was for Darius)
11:16:31 <CosmicRay> I have successfully trimmed my memory usage for 350MB to 35MB
11:16:42 <CosmicRay> however that is still about 30MB higher than Igloo's code for the same thing
11:16:46 <shapr> I printed out the dvorak layout and taped it to the bottom of my monitor, that's how I learned.
11:16:50 <Lunar^> shapr: I'm not typing faster, but I feel less pain after long typing session
11:16:53 <CosmicRay> I'd expect a much smaller overhead
11:16:58 <Darius> Lunar^: I agree assuming Keyboard viewer does what I think it does.
11:16:58 <jadrian> CosmicRay: :)
11:17:17 <shapr> Lunar^: that's good to hear.
11:17:36 <Lunar^> Darius: It was called KeyCaps in the old days. What's useful is that it also modifies the layout when you press a modifier
11:17:43 <Lunar^> Darius: KTouch helped a lot also
11:17:57 <Lunar^> Darius: The dvorak training program is a bit short, though
11:18:42 <Darius> Lunar^: Just get on IRC.  You'll learn a new keyboard layout quick enough if you have enough discipline ;)
11:19:08 * shapr grins
11:19:59 <Lunar^> Darius: sure, but you don't learn how to type well
11:20:16 <Lunar^> shapr: I've also noticed that I was typing in a very unorthodox way
11:20:33 <shapr> how so?
11:21:07 <jadrian> is there supposed to be a "standard" for argument order in Haskell Libs?
11:21:17 <Darius> Lunar^: If you mean learning to touch-type the first time, I don't and wouldn't know.  But I don't see it making a difference for someone who can already touch type.
11:21:20 <jadrian> addToFM takes the FM first and the elems later
11:21:29 <jadrian> insert takes the elem then the list
11:21:46 <CosmicRay> elemFM also is the elem then the map
11:21:50 <CosmicRay> it's annoying.
11:22:14 <Lunar^> Darius: I was not typing like tutor recommands before
11:22:38 <jadrian> yeap
11:23:04 <Darius> Lunar^: Neither was I.  I'm pretty sure.  I think my typing might actually have gotten better after learning dvorak.
11:23:09 <Lunar^> Darius: I was typing the middle  columns with my both hands, and never using my little fingers
11:23:43 <Darius> Though right now I have one foot on the desk, so I can't say my typing posture is all that improved ;)
11:24:03 <Lunar^> Darius: :)
11:26:56 <shapr> I usually sit on my couch indian-style, or in the lotus position with my keyboard on my lap.
11:27:16 <Spark> dali-shapr
11:27:24 <Spark> dalih?
11:27:29 <Spark> actually thats tibet isnt it
11:27:39 <Spark> for your own comfort and convenience, please type /clear
11:27:50 * shapr snickers
11:28:53 <tuomov> I always have one foot on desk or something
11:29:28 <jadrian> I spent over ¤600 in this chair
11:29:30 <jadrian> http://www.haworth.de/en/group/comforto/set_all.htm?content/02/020_01_EN.shtml&navi/navi_02.htm
11:29:42 <jadrian> but my back never hurt again
11:29:46 <jadrian> so it was well spent money
11:31:13 <jadrian> now I just need to take care of my wrists, my right wrist hurst a bit
11:31:22 <jadrian> I know you recommend dvorak :)
11:31:34 <pesco> jadrian: looks cool (the chair)
11:31:40 <jadrian> but I don't know... I was thinking about trying a split keyboard 1st
11:32:07 <jadrian> pesco: yeap I like it a lot
11:32:39 <jadrian> pesco: but you got to adjust it to yourself and try it to see how good it feels
11:37:18 <pesco> Oh, that's a german place. Where did you buy yoursV
11:42:55 <Igloo> CosmicRay: What is it I have lower memory usage for?
11:43:09 <jadrian> pesco: I bought it here in portugal, in a company that works with them
11:43:40 <CosmicRay> Igloo: my gzip processing appears to use about 30MB more RAM than the inflate alogrithm on the compressed portion only
11:43:45 <pesco> jadrian: Oh, I see.
11:43:59 <CosmicRay> Igloo: I suspect it is related to CRC or error checking, but can't reall prove it
11:44:16 <Igloo> If you haven't made the CRC strictly maintained it's probably that
11:45:50 * Igloo wishes for whole-program unused function checking
11:45:59 <CosmicRay> actually I think I have
11:46:02 <tuomov> this in painful
11:46:05 <CosmicRay> I used 250MB before
11:46:08 <CosmicRay> err 350MB
11:46:24 <CosmicRay> 90% reduction by adding "seq" one place :-)
11:46:24 <Igloo> Nothing else obvious comes to mind
11:46:36 <CosmicRay> yeah I suspect it's a strictness problem somewhere
11:46:39 <CosmicRay> I don't really know where
11:47:01 <Igloo> You don't hold on to the input as well as sticking it into inflate, I assume?
11:47:22 <CosmicRay> no
11:47:30 <CosmicRay> all I care about it what is left over after running inflate
11:47:39 <CosmicRay> my input it only a few tens of K anyway
11:49:23 * SyntaxNinja hasn't got his laptop back yet
11:49:31 <SyntaxNinja> Igloo: I tried to resurrect my sparc, but I think the hard drive is dying
11:49:42 <Igloo> :-( ^ 2
11:50:08 <SyntaxNinja> it mounts it readonly; I can boot it if I say init=/bin/sh and then remount the drive, then continue running init
11:50:36 <SyntaxNinja> somehow I can't get it to boot from a rescue disk, and it's not running fsck before mounting, I don't understand why
11:50:56 <SyntaxNinja> and I can't log into cvs.haskell.org without my key, but I think I can get it from the sparc
11:51:11 <tuomov> hmmm.... I wonder if the author of slrn uses dvorak the letters slrn being arranged into a square inthis layout
11:54:35 <tuomov> one rather annoying and potentially harmful thing is that what used to be ^C is now ^J and is understood as enter by bash
11:55:55 <Darius> Another one is, Ctrl-T (make a new tab in firefox) is right above Ctrl-W (close current tabe).
11:56:43 <vegai> tuomov: yes, that's caused a couple of dangerous bloopers on my part
11:58:29 <tuomov> that should be coneigrable away though as the true enter is ^M
11:58:53 <tuomov> *configurable
12:03:13 <tuomov> .inputrc: "\C-j":
12:08:23 <TheHunter> huh?
12:08:30 <TheHunter>     My brain just exploded.
12:08:30 <TheHunter>     I can't handle pattern bindings for existentially-quantified constructors.
12:08:44 <stepcut> hehe
12:11:22 <TheHunter> i always thought i had understood existentials...
12:14:25 <Lor> ghc cannot skolemize?
12:34:36 <SyntaxNinja> meh
12:34:41 <shapr> wha?
12:34:45 <SyntaxNinja> ghc is not installed on cvs.haskell.org?
12:34:59 <Igloo> heh
12:35:01 * SyntaxNinja is utterly frustrated by attempts to get any hacking done
12:35:06 <Igloo> Bet it's got perl, though  :-)
12:35:11 <shapr> ouch
12:35:20 <SyntaxNinja> I had to grep through my mail directory for these darcs patches
12:35:22 <shapr> that's worth putting into AntiQuotes
12:36:09 <Igloo> BTW, do the darcs debs fall back to sensible-editor rather than vi?
12:36:40 <SyntaxNinja> I've never messed with the editor stuff in darcs debian packages
12:36:57 <wli> Igloo: vi is good, if you're going to do sensible-editor please consult $EDITOR beforehand
12:37:07 <Igloo> wli: It already does
12:37:32 <Igloo> And sensible-editor is better than vi on Debian
12:38:31 <SyntaxNinja> darcs just consults $EDITOR, right?
12:39:06 <Igloo> Wrong
12:39:09 <Igloo> DarcsArguments.lhs:             getEnv "EDITOR" `catchall` return "vi"
12:39:11 <wli> good thing you reminded me
12:39:20 <wli> Using `/usr/bin/nvi' to provide `editor'.
12:39:28 <wli> so that explains why pico was getting invoked
12:39:41 <Igloo> It does?
12:39:43 <SyntaxNinja> Igloo: that looks like it's consulting EDITOR to me ;)
12:40:04 <Igloo> It's not /just/ consulting $EDITOR
12:40:10 <SyntaxNinja> so how 'bout if it checked EDITOR, then checked to see if sensible-editor exists, then returned vi?
12:40:17 <wli> I would so much rather have nuked pico but one of the idiot users wants pine
12:40:42 <Igloo> I'd just make s/vi/sensible-editor/ in the Debian package if I were you
12:40:43 <Darius> If people want a sensible-editor, set $EDITOR !
12:41:00 <Darius> But vi is the standard editor!
12:41:06 <SyntaxNinja> Igloo: seems like something that can go upstream
12:41:11 <Igloo> Darius: The advantage of sensible-editor is that it will be an editor that is installed without you having to do anything
12:41:45 * TheHunter is away: I'm busy
12:41:48 <Igloo> If you say so. I probably wouldn't accept it if I were upstream  :-)
12:42:07 <Darius> I'm either confused or don't like what that's saying.
12:42:24 <SyntaxNinja> why not? if there's no such thing as sensible-editor, then it falls back to vi
12:42:41 <stepcut> export EDITOR=yi
12:42:51 * jadrian doesn't even know what "sensible-editor" is...
12:43:35 <jadrian> ok
12:43:39 <jadrian> now I know...
12:43:58 <Riastradh> The only sensible & universal editor is ed!
12:44:04 * Igloo looks confused. I thought it was handled using alternatives, but it seems not to be
12:44:07 <jadrian> ed is sensible?
12:44:20 <musasabi> Riastradh speaks the true words.
12:44:32 <musasabi> ed is the *standard* editor
12:44:52 <jadrian> yeap
12:45:01 <jadrian> to bad nobody uses it :)
12:45:40 <musasabi> well sometimes one has to use it..
12:45:44 <stepcut> jadrian: maybe we just need an ed mode for yi
12:45:55 <jadrian> stepcut: lol
12:45:59 <musasabi> (install disc with no other working editor - that was very painfull)
12:46:25 <jadrian> ouch...
12:47:03 <SyntaxNinja> Igloo, shapr are you using darcs1.0.0.final-4?
12:47:07 <SyntaxNinja> any troubles with darcs send?
12:47:19 <shapr> um
12:47:25 * Igloo is using darcs unstable when I remember
12:47:35 <shapr> yes, SASL sucks
12:47:45 <shapr> (has nothing to do with darcs though)
12:47:57 <Igloo> I have 1.0.0.final-4 installed and hav definitely successfully sent a few times, though
12:48:00 <tuomov> default EDITOR=ed, VISUAL=vi
12:48:28 <Igloo> Why, what's the problem?
12:48:45 <SyntaxNinja> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=283229
12:49:46 <SyntaxNinja> I guess it must be one of the auto-builders
12:49:56 <SyntaxNinja> i don't see what platform he's on
12:50:16 <Igloo> Ah, maybe
12:50:21 <SyntaxNinja> hmm. should it build-depend on a provides: sendmail?
12:50:32 <SyntaxNinja> this is a little sticky
12:50:52 <Igloo> exim | message-transport-agent
12:51:06 <Igloo> You should depend, or at least recommend, on it too
12:51:25 <SyntaxNinja> yeah
12:51:41 <SyntaxNinja> not depends, I think, since it doesn't really _need_ it, and some won't want it.
12:52:07 <SyntaxNinja> also anyone using darcs server? can we verify that it depends on xsltproc 
12:52:42 * shapr raises his hand
12:52:49 * Igloo doesn't have that installed
12:54:57 <musasabi> SyntaxNinja: I use darcs on a machine without MTA, but that is nondebian.
12:56:14 <SyntaxNinja> yeah; I'm sure others do to
12:56:21 <SyntaxNinja> like, um. ME!
12:56:40 <shapr> btw, why isn't there a darcs.cgi that takes http POST'd patches?
12:56:54 <shapr> then you don't need an MTA on the server
12:57:00 <shapr> you could still check the GPG sig
12:57:22 <SyntaxNinja> Igloo: what's that bug # (or link) for the mipsel problem?
12:57:23 <Igloo> musasabi: What OS?
12:58:19 <Igloo> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=274942
12:59:09 <musasabi> Igloo: stripped down NetBSD
13:01:58 <SyntaxNinja> Igloo: thanks.
13:13:13 <Alabaster> aaaaah
13:13:23 <Alabaster> i cant make GHC compile anything to an exe
13:13:28 <Alabaster> even Hello World
13:14:04 <Alabaster> C:\>more Main.hs
13:14:04 <Alabaster> module HelloWorld (main) where
13:14:04 <Alabaster> main = putStr "Hello World\n"
13:14:04 <Alabaster> C:\>ghc Main.hs
13:14:07 <Alabaster> c:/ghc/libHSrts.a(Main.o)(.text+0x87):Main.c: undefined reference to `__stginit_
13:14:09 <Alabaster> ZCMain'
13:14:10 <Alabaster> c:/ghc/libHSrts.a(Main.o)(.text+0xa1):Main.c: undefined reference to `ZCMain_mai
13:14:13 <Alabaster> n_closure'
13:14:33 <musasabi> Alabaster: you need to have main in a module called Main (or without a module declaration)
13:14:54 <Alabaster> allllllllright...
13:15:00 <Alabaster> so take that line out?
13:15:11 <Alabaster> or what?
13:15:13 <Alabaster> im so lost..
13:15:39 <musasabi> that would work.
13:15:47 <Alabaster> i can barely figure out this functional programming stuff.. ive been used to imperative languages for the past.. 12 years?
13:15:57 <Nioate> module HelloWorld should be module Main, or else you can omit the line
13:16:35 <Alabaster> w00t
13:16:39 <Alabaster> it works if i take it out
13:16:47 <Alabaster> if i put module Main, i get an error
13:16:57 <Alabaster> C:\>ghc Main.hs
13:16:58 <Alabaster> Main.hs:3: parse error on input `main'
13:17:28 <Nioate> you still have the "where" there?
13:17:35 <Alabaster> no
13:17:41 <Nioate> well you need to
13:18:00 <Alabaster> aah..
13:18:08 <Alabaster> so i always need a module called Main
13:19:21 <musasabi> Alabaster: well if you are compiling multiple modules it *is* kind of helpfull to know which is the main module.
13:19:43 <Alabaster> mm yes
13:22:42 <SyntaxNinja> there's also the -main-is flag (in newish ghc versions) so you can say "ghc -main-is HelloWorld.main HelloWorld.hs"
13:22:45 <SyntaxNinja> this is very nice :)
13:29:06 <Alabaster> dont i wish there was a tutorial for us imperative coders... that isnt in postscript..
13:29:18 <Alabaster> >_< *sigh*
13:30:08 <Lemmih> Alabaster: http://www.haskell.org/complex/
13:30:56 <Riastradh> What's wrong with PostScript?
13:31:51 <mflux> I wish there was a postscript viewer which would understand what is the region the text is on
13:32:11 <mflux> often postscripts have ridiculous margins
13:32:30 <mflux> maybe nice on paper, but useless on screen..
13:33:04 <stepcut> mflux: can't you just zoom in ?
13:33:16 <mflux> yes, but when I press space the white region scrolls back in
13:33:29 <mflux> and in the worst case it also scrolls horizontally to ensure I see all the white area
13:33:39 <mflux> well, with gv atleast
13:33:48 <stepcut> mflux: what OS ?
13:33:52 <mflux> mostly a problem with smaller screens though
13:33:52 <mflux> linux
13:33:55 <mflux> (debian)
13:34:07 <stepcut> kghostview has a better interfacee
13:34:38 <mflux> I'll try that, thanks
13:35:35 <stepcut> of course, if you are not running kde, it will likely want to pull in an ungodly amount of deps
13:35:49 <mflux> I already have the deps (even though I don't use it)
13:37:29 <SyntaxNinja> musasabi: I just pushed your patch, finally.
13:37:45 <mflux> that's relatively slick (kghostview)
13:37:51 <SyntaxNinja> I'm still pending on simon's big patch since it doesn't really build now.
13:40:04 <Alabaster> danke schon Lemmih
13:41:59 <Lemmih> Nicht zu danke.
13:42:18 <arauko> Hello.
13:42:25 <Lemmih> Hello arauko.
13:42:39 <arauko> Is there a way to program GUI on Haskell? GNU/Linux i686
13:42:50 <arauko> Lemmih, hello
13:43:10 <SyntaxNinja> arauko: sure! wxhaskell :)
13:43:11 <Lemmih> arauko: Yes. There are many such libraries in fact.
13:43:29 <arauko> Good.
13:43:32 <arauko> Any link?
13:44:12 <Lemmih> wxhaskell.sf.net
13:44:20 <arauko> Thanks.
13:45:39 <Lemmih> I think there's a GTK2 binding out there somewhere. And musasabi is/was working on a fltk binding.
13:46:09 <vegai> some people seem to like fltk over wx
13:47:14 <Darius> However, wxHaskell for the most part is the "standard GUI" to the extent that there is one.
13:47:42 <musasabi> SyntaxNinja: thanks :-)
13:48:26 <SyntaxNinja> musasabi: thank YOU!
13:48:35 <musasabi> there is a fltk binding too...
13:49:29 <arauko> so.. wxHaskell is like the more "mature" ?
13:49:41 <musasabi> very much more mature.
13:50:32 <arauko> Ok, that could be useful for a beginner, like me
13:52:48 * SyntaxNinja has found wxhaskell to be quite nice.
14:04:09 <Darius> What gives you a DC is wxHaskell?
14:05:46 <Darius> I guess withPaint/ClientDC is the way to go.
14:33:13 <TheHunter> wft? Ambiguous occurrence `union' It could refer to either `Data.List.union' or `Data.Set.union'
14:34:07 * SyntaxNinja believes in enumerating all imports
14:34:25 <SyntaxNinja> so rather than "import Data.List" you "import Data.List(length)" it makes the code much more readable and avoids problems like that
14:35:34 <TheHunter> still, it's braindead. Some of the Data.Set function have Set in their name (like emptySet) and others (like union) don't.
14:35:43 <SyntaxNinja> of course, you can "import Data.List hiding (union)"
14:35:55 <TheHunter> yep, that's what i'm doing
14:36:40 <SyntaxNinja> I would prefer that set get cleaned so that there are actually MORE overlapping names :)
14:36:52 <SyntaxNinja> now that we have the hierarchical modules, we might as well use them.
14:36:58 <TheHunter> right.
14:39:20 <musasabi> having identical interfaces for different collections is nice.
14:39:52 <SyntaxNinja> yeah
14:58:48 <jadrian> well I agree with that
14:58:53 * shapr throws lambdas
14:59:05 <jadrian> but I'd probably start importing all modules as "shorter name"
14:59:33 <jadrian> Data.Set.union is a bit to long
14:59:45 * shapr notices a whole bunch of Yi patches from tuomov.
15:00:23 <jadrian> the other thing I don't really like about using namespaces is that the distinction between Upper and Lower case identifiers is harder
15:03:06 <Lor> It's kindasorta bad idea that . is both a name component and an operator symbol.
15:04:42 <tuomov> unicode ring should be used for composition
15:06:38 <Lor> ? would berhaps be a bit easier.
15:06:49 <Lor> Or °, but that's perverse.
15:07:00 <wagle> that came out as ? and a space 
15:07:09 <Lor> Well, they were latin-1.
15:07:14 <wagle> which indicate the problem
15:07:44 <jadrian> hmmm
15:07:53 <Lor> Â· Â°
15:07:56 <Lor> Was that better?
15:07:56 <wagle> sigh..  there were special keyboards for apl in the early seventies
15:08:15 <wagle> 15:07 < Lor> Â· Â°
15:08:16 <jadrian> yeah multiple meanings for . is not that great either
15:08:45 <jadrian> I wonder what happens if I actually declare  constructors names Data and List
15:08:48 <Lor> wagle, just pasting the bytes back to me doesn't tell me what you _saw_ on the screen.
15:08:51 <jadrian> and type Data.List
15:08:51 <wagle> the token "." vs a token with '.' internalls
15:09:22 <tuomov> \ciri
15:09:26 <tuomov> \circ
15:09:29 <wagle> Lor: i know..  was curious whether it can being converted and where
15:09:36 <wagle> 15:06 < Lor> ? would berhaps be a bit easier.
15:09:45 <wagle> 15:06 < Lor> Or ï¿½, but that's perverse.
15:09:56 <Lor> Sheesh.
15:09:59 <wagle> did either of those come back correct?
15:10:08 <Lor> I saw a question mark on the first line.
15:10:11 <jadrian> Lor: here I saw a question mark on the 1st
15:10:26 <jadrian> Lor: and your second was a little circle
15:10:29 <Lor> In the second line there were an i with diaeresis, an inverted question mark, and a one-half sign.
15:10:45 <jadrian> I'm using iso8859-15
15:10:58 <jadrian> I know freenode standard is unicode...
15:11:52 <tuomov> I communicate in utf8 but my term is latin1
15:11:56 <Lor> Ah. Xchat does something really weird.
15:12:08 <Lor> I use compose and I _try_ to output a middle dot sign.
15:12:24 <Lor> ·
15:12:26 <Lor> That one.
15:12:39 <Lor> But instead I got, uh, \u02d9.
15:12:52 <tuomov> Â·
15:13:13 <tuomov> but that one is ugly
15:14:19 <tuomov> hmmm.... there's Â¤ in latin1
15:15:14 <wagle> Â¶
15:15:25 <wagle> Latin-1 Supplement?
15:15:49 <wagle> is "Basic Latin" Latin-1?
15:16:09 <tuomov> 8859-1
15:16:18 <wagle> Æ¢
15:17:04 <wagle> odd..  i can display these odd chars, but if you do it, it gets mangled
15:17:37 <tuomov> I send utf8
15:17:38 <wagle> Æ¢ <- what does that look like?
15:17:42 <tuomov> ?
15:17:54 <tuomov> q mark
15:18:33 <wagle> apparently its 02248
15:18:41 <Lor> AE-ligature and cent symbol.
15:19:03 <wli> Now we need a Euro symbol
15:19:15 <jadrian> ¤
15:19:19 <tuomov> useless
15:19:27 <wagle> big O, with right side flattened, and a straight up and down line to the right
15:19:53 <wagle> wli needs it for refering to his money... 8)
15:19:57 <tuomov> that is the imtl. currency symbol Â¤
15:20:35 <tuomov> i just use 'e'
15:21:01 <tuomov> no need for another symbol
15:21:12 <jadrian> eh, so why not use  S for dollars?
15:21:26 <wagle> hmm..  i can do traditional chinese: ä¸¦
15:23:43 <wagle> wli: you moving to ukraine now?  8)
15:24:31 <tuomov> D would be bettep for dollar
15:24:56 <Riastradh> ...which is indeed what some people used, just with a prefix of 'US.'
15:30:24 <jadrian> i can't find a description of the icfp04 contest anywhere in the page...
15:30:36 <jadrian> oh and congrats Igloo!
15:32:10 <Igloo> http://www.cis.upenn.edu/proj/plclub/contest/task.php ?
15:32:13 <Igloo> And thanks  :-)
15:32:13 <Riastradh> jadrian, look at <http://www.ant-wars.com/>, and think of a somewhat less-developed version of it.
15:33:07 <jadrian> Riastradh: thanks
15:55:10 <atwood> 
16:12:46 <Remco> goodnight :)
17:08:48 <CosmicRay> lambdabot, @commands
17:09:04 <Riastradh> @listcommands
17:09:04 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
17:09:04 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
17:09:04 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
17:09:04 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
17:09:04 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
17:09:05 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
17:09:07 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
17:09:09 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
17:09:11 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
17:13:08 <Lor> @hitchcock
17:13:31 <Lor> And suddenly... nothing happens!
17:15:18 <CosmicRay> heh
17:19:15 <Riastradh> Creepy!
17:34:07 <CosmicRay> @yow
17:34:08 <lambdabot> Used staples are good with SOY SAUCE!
17:34:31 <CosmicRay> @learn
17:34:31 <lambdabot> http://www.haskell.org/learning.html
17:54:59 <CosmicRay> @fortune
17:55:00 <lambdabot> "Pull the trigger and you're garbage."
17:55:00 <lambdabot> -- Lady Blue
17:55:09 <CosmicRay> @karma
17:55:09 <lambdabot> I can't find the karma of nobody.
17:55:16 <CosmicRay> @karma shapr
17:55:16 <lambdabot> shapr has a karma of 0
17:55:22 <CosmicRay> @karma+
17:55:22 <lambdabot> I can't find the karma of nobody.
17:55:31 <CosmicRay> @karma lambdabot
17:55:31 <lambdabot> lambdabot has a karma of 0
17:55:37 <CosmicRay> @karma+ shapr
17:55:37 <lambdabot> shapr's karma has been incremented.
17:56:39 <CosmicRay> it's quiet in here when it's just me and the bot talking....
17:56:40 <ibid> hmm
17:56:44 <ibid> @karm ibid
17:56:44 <lambdabot> Sorry, I don't know the command "karm", try "lambdabot: @listcommands"
17:56:47 <ibid> @karma ibid
17:56:47 <lambdabot> You have a karma of 0
17:56:53 <ibid> unsurprising :)
17:56:55 <CosmicRay> @karma- ibid
17:56:55 <lambdabot> ibid's karma has been decremented.
17:56:57 <CosmicRay> hah
17:57:00 <ibid> heh
17:57:21 <CosmicRay> @karma ibid
17:57:21 <lambdabot> ibid has a karma of -1
17:57:48 <ibid> instant karma's gonna get you
17:58:00 <CosmicRay> heh
17:58:09 <CosmicRay> @karma+ ibid 5
17:58:09 <lambdabot> ibid's karma has been incremented.
17:58:12 <CosmicRay> @karma ibid
17:58:12 <lambdabot> ibid has a karma of 0
17:58:17 <CosmicRay> @karma+ 5 ibid
17:58:17 <lambdabot> 5's karma has been incremented.
17:58:21 <CosmicRay> doh
17:58:24 <CosmicRay> @karma ibid
17:58:24 <ibid> heh
17:58:24 <lambdabot> ibid has a karma of 0
17:58:26 <CosmicRay> @karma 5
17:58:27 <lambdabot> 5 has a karma of 1
17:58:35 <CosmicRay> look at that.  5 has higher karma than you.
17:58:47 <ibid> @karma- CosmicRay 
17:58:47 <lambdabot> CosmicRay's karma has been decremented.
17:58:52 <ibid> for playing with it:
17:58:52 <ibid> )
17:59:08 <ibid> @karma CosmicRay 
17:59:08 <lambdabot> CosmicRay has a karma of -1
17:59:33 <CosmicRay> heh
17:59:55 <CosmicRay> @jargon karma
17:59:59 <lambdabot> No match for "karma".
18:00:03 <CosmicRay> @jargon mel
18:00:04 <lambdabot> No match for "mel".
18:00:09 <CosmicRay> @jargon legend of mel
18:00:12 <lambdabot> No match for "legend".
18:00:12 <lambdabot> No match for "of".
18:00:12 <lambdabot> No match for "mel".
18:00:25 <CosmicRay> @jargon real programmer
18:00:27 <lambdabot> *** "real" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:00:27 <lambdabot> real adj. Not simulated. Often used as a specific antonym to {virtual}
18:00:27 <lambdabot>    in any of its jargon senses.
18:00:27 <ibid> From WordNet (r) 2.0 (August 2003) [wn]:
18:00:27 <ibid>   karma
18:00:27 <ibid>       n : (Hinduism and Buddhism) the effects of a person's actions
18:00:27 <ibid>           that determine his destiny in his next incarnation
18:00:30 <lambdabot> No match for "programmer".
18:00:43 <ibid> @jargon "real programmer"
18:00:44 <lambdabot> *** "Real Programmer" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:00:44 <lambdabot> Real Programmer n. [indirectly, from the book "Real Men Don't Eat
18:00:44 <lambdabot>    Quiche"] A particular sub-variety of hacker: one possessed of a flippant
18:00:44 <lambdabot>    attitude toward complexity that is arrogant even when justified by
18:00:45 <lambdabot>    experience. The archetypal `Real Programmer' likes to program on the
18:00:47 <lambdabot>    {bare metal} and is very good at same, remembers the binary opcodes for
18:00:49 <lambdabot>    every machine he has ever programmed, thinks that HLLs are sissy, and
18:00:51 <lambdabot>    uses a debugger to edit his code because full-screen editors are for
18:00:53 <lambdabot> [24 @more lines]
18:00:56 <CosmicRay> heh
18:01:03 <CosmicRay> what the hey, I'm bored
18:01:04 <CosmicRay> @more
18:01:04 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
18:01:07 <CosmicRay> bah
18:01:11 <CosmicRay> @more lines
18:01:11 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
18:01:13 <ibid> @jargon "real programmer" @more
18:01:15 <lambdabot> *** "Real Programmer" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:01:15 <lambdabot> Real Programmer n. [indirectly, from the book "Real Men Don't Eat
18:01:15 <lambdabot>    Quiche"] A particular sub-variety of hacker: one possessed of a flippant
18:01:15 <lambdabot>    attitude toward complexity that is arrogant even when justified by
18:01:16 <lambdabot>    experience. The archetypal `Real Programmer' likes to program on the
18:01:18 <lambdabot>    {bare metal} and is very good at same, remembers the binary opcodes for
18:01:19 <ibid> (just a guess)
18:01:20 <lambdabot>    every machine he has ever programmed, thinks that HLLs are sissy, and
18:01:22 <lambdabot>    uses a debugger to edit his code because full-screen editors are for
18:01:24 <lambdabot> [25 @more lines]
18:01:26 <ibid> nope
18:01:30 <CosmicRay> heh
18:01:45 <CosmicRay> it's more fun than just reading the lambdabot source
18:01:52 <ibid> never done that
18:02:08 <CosmicRay> me neither
18:02:12 <ibid> in fact, it's been a while since i last worked on anything haskellish
18:02:16 <CosmicRay> we are all lazy, after all
18:02:19 <ibid> heh
18:02:30 <CosmicRay> in fact, I didn't know you were interested in haskell, ibid
18:02:45 <ibid> CosmicRay: i think i was one of the earliest debianites in haskell :)
18:03:42 <ibid> i adopted hugs from gorgo back when there were no nhc or ghc packages
18:03:53 <ibid> back when hugs was still in non-free
18:04:15 <ibid> (in fact, i believe i had something to do with why it's no longer there:)
18:04:18 <CosmicRay> that does sound... awhile ago :-)
18:04:24 * CosmicRay doesn't remember that
18:04:33 <CosmicRay> otoh I didn't follow haskell until about... las tmonth... :-)
18:04:43 <ibid> i also created haskell-doc and packaged green-card
18:04:52 <ibid> and something else i've forgotten
18:04:54 <ibid> CosmicRay: 1999 or so :)
18:05:14 <ibid> i am fairly certain i'm the reason why the not so intro has a free license
18:05:45 <ibid> and i'm listed in the report acknowledgements (no reason cited, but my license-related licenses are probable causes:)
18:06:17 <ibid> not so intro = gentle intro
18:06:22 <CosmicRay> ahhh
18:06:25 <ibid> (mixed with latex)
18:06:43 <ibid> license-related *mails*
18:06:59 <ibid> you'd think i'm staying up late from these mistakes
18:07:06 <ibid> no, wait, i *am* staying up late!
18:07:10 <Igloo> "He made a lot of noise - best put him in or he'll spend the next 5 years whinging about it"  :-)
18:07:16 <CosmicRay> haha
18:07:19 <ibid> heh
18:09:08 <ibid> i'm sorry about all that boasting ... wait, actually, i'm not ;)
18:09:56 <ibid> @karma- ibid
18:09:57 <lambdabot> You can't change your own karma, silly.
18:10:03 <ibid> not even decrease it?
18:10:06 <ibid> silly bot
18:10:30 <Riastradh> @karma- ibid
18:10:30 <lambdabot> ibid's karma has been decremented.
18:10:31 <Riastradh> @karma- ibid
18:10:31 <lambdabot> ibid's karma has been decremented.
18:10:41 <Riastradh> @karma ibid
18:10:41 <lambdabot> ibid has a karma of -2
18:10:49 <ibid> thanks :)
18:12:17 <Alabaster> Hrm.. i have questions for people
18:12:31 <Riastradh> Ask them.
18:13:16 <ibid> getting back to my less-haskellness: my current three pet projects are: a) the ibicc compiler, b) the celery language and c) my dissertation (typical me, each would alone be enough for most people:)
18:13:29 <ibid> (none of them are publically available)
18:13:34 <ibid> (at this time)
18:14:10 <CosmicRay> tell us about the first 2
18:14:21 <ibid> :)
18:14:37 <Alabaster> Well ok.. I come from an imperative/object oriented background, and I'm trying to learn some haskell, i've done a (very small) bit in scheme, but in general i think in OO terms. It's been bothering me that while it seems all fine and elegant, im not sure how well it models real world situations that i'd be coding for.. Seems to me at the core of everything, that multiply sign is still an action, not a value.. And I'm just wondering if it's wort
18:14:37 <Alabaster> h it for me.
18:14:42 <ibid> ibicc is a C99 compiler (or rather, currently only a preprocessor works)
18:15:06 <ibid> celery is a persistent programming language
18:15:30 <np_hard> Alabaster: if you take anything away from functional programming, take away higher order functions
18:15:39 <np_hard> map, fold, filter
18:15:44 <Riastradh> Alabaster, it is a value that _represents_ an action.
18:15:54 <CosmicRay> ibid: what is a persistent programming language?  
18:16:08 <np_hard> in many "OO" languages functions are first-class values
18:16:09 <ibid> CosmicRay: a programming language that implements orthogonal persistence :)
18:16:14 <np_hard> we call them enlightened languages :)
18:16:18 <np_hard> python, lisp, etc.
18:16:24 <np_hard> smalltalk
18:16:24 <Alabaster> yeah i like HOF a lot
18:16:30 <np_hard> not java or C++ though
18:16:31 <Alabaster> since i code in python freuqnetly
18:16:46 <Riastradh> Alabaster, so what's wrong with having operators be first-class functions?
18:16:46 <ibid> np_hard: both can fake it, c++ better than java
18:16:57 <np_hard> right but that's faking it
18:17:02 <np_hard> you can fake it in ASM if you want
18:17:16 <ibid> CosmicRay: basically, persistence in this context is the ability of data structures to outlive a program activation
18:17:17 <Alabaster> Riastradh: im not trying to say its bad.. im just saying i feel like im missing something
18:17:23 <Alabaster> im confused, if you will
18:17:30 <Riastradh> Alabaster, missing what?
18:17:37 <CosmicRay> ibid: hmm.  to survive after its process dies, you mean?
18:17:51 <ibid> CosmicRay: orthogonal persistence means that persistence of data is orthogonal to other features like typing
18:17:55 <CosmicRay> ibid: I know python has pickle, but...  is that the distinguishing....
18:17:56 <ibid> CosmicRay: yes
18:18:14 <ibid> CosmicRay: i believe zope has true persistence
18:18:18 <CosmicRay> so java isn't persistent because to be Serializable, you must implement it manually
18:18:19 <CosmicRay> ah
18:18:21 <ibid> CosmicRay: pickle is just the lowest layer
18:18:53 <ibid> CosmicRay: to be truly persistent, a language must make persistent data look like ordinary data even though it's backed by long-term storage
18:19:05 <Alabaster> Riastradh: Well, I'm just confused because it seems to me in the long run, theres going to end up being a distinction. Some action (math: operation) is going to be performed at some point.
18:19:32 <ibid> analoguous to how virtual memory makes a part of a disk seem a part of memory
18:19:34 <CosmicRay> ibid: so python's dbm interfaces would be a primitive form of that?
18:19:58 <ibid> CosmicRay: i'm not familiar with them
18:20:05 <ibid> CosmicRay: but i'd guess it's not enough
18:20:27 <CosmicRay> basically you can access an on-disk dbm file as a dict
18:20:32 <Alabaster> Riastradh: and not like im trying to bash functional programming.. i've made similar arguments about OO languages like smalltalk.
18:20:33 <ibid> like virtual memory, once some data is marked persistent, the I/O must happen behind the scene
18:20:41 <CosmicRay> ic
18:21:16 <CosmicRay> ibid: my gut says that would be difficult in haskell, since we're always cloning objects to modify them
18:21:17 <CosmicRay> true?
18:21:29 <ibid> CosmicRay: and to make it useful, the persistency backend must implement ACID
18:22:01 <ibid> CosmicRay: i haven't really thought about what a nondestructive persistent language would look like :)
18:22:18 <Riastradh> Alabaster, I'm not quite sure I understand your confusion.
18:22:41 <ibid> CosmicRay: yes, what you said about dbm makes it look like a form of persistency
18:22:51 <ibid> CosmicRay: although not orthogonal persistency :)
18:22:55 <Alabaster> Riastradh: well i keep heaqring how everything is a value.. but im evil and I like to poke at the underlying theory. It seems to me that everything doesnt end up being a value in the end run
18:23:02 <Alabaster> *hearing
18:24:05 <Riastradh> Alabaster, is a lack of distinction between code & data really that hard to accept?
18:24:20 <np_hard> hmm
18:24:24 <np_hard> he's right though
18:24:26 <Riastradh> Code is just data that is interpreted by a machine to perform computation itself.
18:24:31 <np_hard> typeclasses aren't first-class in Haskell
18:24:32 <np_hard> :)
18:24:55 <Alabaster> Riastradh: I come from a very low level background (asm anyone?) so i tend to keep track of everything.. like i have trouble trying *not* to manage memory by hand.
18:24:59 <CosmicRay> Alabaster: what specifically is giving you trouble
18:25:19 <ibid> CosmicRay: one consequence of orthogonal persistency i had some difficulty of accepting at first was that such a language should not be implemented as a traditional ahead-of-time compiler
18:25:29 <Alabaster> CosmicRay: theory.. syntax is all fine and wonderful
18:25:30 <ibid> CosmicRay: instead, you'd have to use the java approach
18:25:35 <Riastradh> Alabaster, then you know that code is represented as sequences of bytes (that form instructions) in memory just like all other data, right?
18:25:48 <Alabaster> Riastradh: In some architectures, yes
18:26:12 <Riastradh> Alabaster, why a dichotomy between the two, then?
18:26:36 <Riastradh> The only difference is that machine code is interpreted by the machine itself, rather than a human or some other program.
18:26:43 <Alabaster> Riastradh: Alright, I get the idea. Just a tad difficult to wrap my head around everything at once, you understand.
18:27:05 <Alabaster> 12 years dont die quietly.
18:27:07 <CosmicRay> Alabaster: have you used any other language with automatic memory management, such as python?
18:27:15 <Alabaster> CosmicRay: yeah i use python all the time
18:27:25 <Riastradh> All data, however, are interpreted, or they would be fairly useless.
18:27:26 <Alabaster> CosmicRay: but i tend to pick the language to fit the task rather than the other way aroiund
18:27:39 <CosmicRay> Alabaster: python can be used functionally
18:27:49 <CosmicRay> you can declare functions via lambda and pass them around, just as with haskell
18:28:01 <CosmicRay> though the standard library is not really designed to be used in that manner
18:28:05 <Alabaster> CosmicRay: I tend to use a mix of OO and a bit of HOF, like for my plugin architecture
18:30:24 <CosmicRay> so it's not the functional part of haskell that's bothering you, but the "we only have expressions" part?
18:33:10 <Alabaster> CosmicRay: yeah
18:33:21 <Alabaster> lol as I said, old habits die hard
18:33:28 <jadrian> back
18:33:32 <jadrian> question
18:33:42 <jadrian> I have something like
18:33:56 <jadrian> data D1 = A | B
18:34:02 <jadrian> data D2 = C | D
18:34:35 <CosmicRay> Alabaster: well, here's the thing.  haskell has rules for evaluating expressions
18:34:48 <CosmicRay> Alabaster: just like there are rules for the order of evaluating 5 * 3 + 2
18:34:54 <jadrian> there is a certain function that I'd like it to work with both D1 and D2
18:35:04 <jadrian> since there is no subtyping in haskell
18:35:06 <CosmicRay> you can take that snippet of C and fairly directly translate it to asm
18:35:11 <jadrian> I thought I'd use typeclasses
18:35:11 <ibid> CosmicRay: i believe a persistent haskell would have to have a versioning database backend to implement the persistency
18:35:19 <ibid> so that persistent data structures are also persistent :)
18:35:23 <jadrian> class D where
18:35:26 <ibid> (two meanings of persistence there)
18:35:33 <jadrian> instance D D1 where
18:35:34 <jadrian> instance D D2 where
18:36:39 <jadrian> now is there some way to define a function that takes either a D2 or a D1, pattern matches, and gives the result?
18:36:51 <jadrian> (I think I cannot do such a thing)
18:37:08 <CosmicRay> Alabaster: I/O is the main thing where you have to force a certain order
18:37:19 <ibid> jadrian: either it's trivial or i don't understand the question
18:37:27 <CosmicRay> Alabaster: Haskell has actions (in the form of the IO monad) to do that
18:37:42 <jadrian> ibid: I hope it's the 2nd one :)
18:37:56 <CosmicRay> Alabaster: the idea is that if you can assert that a given function always returns the same value when given the same arguments...
18:38:08 <jadrian> ibid: I'd like to be able to do samething like 
18:38:13 <Alabaster> CosmicRay: ah okay
18:38:13 <CosmicRay> Alabaster: then you care a lot less about when/if/how it gets called
18:38:15 <jadrian> foo :: <I have no idea>
18:38:18 <jadrian> f A = ...
18:38:19 <Alabaster> CosmicRay: much clearer
18:38:21 <jadrian> f B = ...
18:38:25 <jadrian> f C = ...
18:38:32 <jadrian> f D = ...
18:38:32 <ibid> i mean, what's wrong with instance D D1 where f A = ... instance D D2 where f B = ...
18:38:37 <jadrian> (yes f should be foo)
18:38:56 <jadrian> ibid: nothing, that is ok
18:38:59 <ibid> sorry, instance D D2 where f C = ...
18:39:12 <ibid> jadrian: ok, that was the trivial solution i mentioned
18:39:17 <jadrian> ibid: but it doesn't allow me to define a function like the one above
18:39:24 <CosmicRay> Alabaster: I found this informative: http://www.isi.edu/~hdaume/htut/
18:39:25 <jadrian> ibid: ah
18:39:26 <ibid> jadrian: how so?
18:39:38 <ibid> jadrian: i don't see why not
18:39:40 <jadrian> ibid: define the function as a method?
18:39:45 <ibid> of course
18:40:23 <jadrian> let me see my code again
18:41:26 <CosmicRay> Alabaster: on a slightly different note, you can think of the laziness in Haskell as saying "computer, should you need to figure out the value of x at some point, here's how you do it" rather than "computer, run this code and store its result in the location pointed to by x"
18:41:46 <CosmicRay> Alabaster: that extends to, say, the 5th item in a list or whatever
18:42:21 <Alabaster> CosmicRay: alrighty, ill take the laziness paradigm
18:42:29 <Alabaster> that makes my head stop spinning
18:42:35 <jadrian> ibid: yeap you'r eright that it would work, I didn't think of it because it just doesn't fit my code...
18:42:38 <CosmicRay> that's good :-)
18:42:44 <CosmicRay> it takes some getting used to, but I like it
18:43:03 <jadrian> ibid: the problem is that I have two kinds of symbols
18:43:04 * ibid clearly remembers how he, after reading that kind of descriptions of laziness, thought laziness would for example make the compiler omit asking for inputs it doesn't nreed ;)
18:43:28 <CosmicRay> for instance, I found a bug in my FTP client one time.  It was never reading the result code from the server because the program never used that code in a computation.  (you have to read that code to ensure proper synchronization.)
18:43:50 <jadrian> ibid: and it would be handy to have functions all over the place should be able to take either kind of symbol 
18:43:56 <CosmicRay> there are ways around that, but that's just an example.  it can be a clever way of implementing "only ask the user if you can't ifgure it out"
18:44:14 <jadrian> ibid: but putting all those functions under am instance declaration would make no sense
18:44:42 <ibid> i note that lazy IO is generally a kluge, based on unsafeInterleaveIO
18:44:59 <jadrian> I thought about declaring those symbols as the same type
18:45:26 <jadrian> but I wanted static check in some places where only one kind of symbol make sense
18:45:31 <CosmicRay> ibid: not necessarily, if you discard the action without ever evaluating its result, it is never run
18:45:36 <CosmicRay> that's what happened ot me
18:45:45 <ibid> CosmicRay: uh?
18:45:58 <Alabaster> CosmicRay: yup.. and hey.. even if I end up not using it so much, it's good for the learning. I love learning new languages because that way, there's always a best tool for the job.
18:46:12 <ibid> CosmicRay: unless you discard the action, bot just its evaluation resut, you can't really do that
18:46:16 <ibid> without uIIO
18:46:25 <CosmicRay> well if you return an IO Int, say, but the caller never uses it
18:46:39 <ibid> that's discarding the action itself :)
18:46:43 <CosmicRay> right
18:46:47 <CosmicRay> that's what I said
18:46:49 <jadrian> I think there was some trick with quantifiers
18:46:53 <CosmicRay> "if you discard the action".... :-)
18:46:56 <ibid> you said you discarded its returned value :)
18:47:14 <CosmicRay> <CosmicRay> ibid: not necessarily, if you discard the action without ever evaluating its result, it is never run
18:47:19 <ibid> yes
18:47:22 <ibid> that's how i read it :)
18:47:31 <CosmicRay> oh, ok.  that's not what I meant :-)
18:47:37 <Alabaster> im thinking that haskell would be a wondeful language to do genetic algorithms/CA in..
18:47:40 <ibid> obviously :)
18:47:57 <CosmicRay> Alabaster: I learned Haskell for the same reason, in fact.
18:48:08 <Alabaster> CosmicRay: Cool :) thats one of my favorite areas
18:48:11 <CosmicRay> Alabaster: you may be interested in OCaml also.  It is similar to Haskell, though it is not pure and it is not lazy
18:48:25 <CosmicRay> Alabaster: I meant the "to learn new things" rather than the GA thing, sorry :-)
18:48:31 <Alabaster> CosmicRay: I looked at OCaml and it looked ugly to me.. 
18:48:33 <CosmicRay> you just typed a little too fast
18:48:37 <Alabaster> CosmicRay: Hell either way its cool
18:48:45 <Alabaster> Haskell looks pretty.. lol
18:48:55 <CosmicRay> Alabaster: the ocaml syntax is, uhm, oldish-feeling, yes.
18:49:23 <CosmicRay> Alabaster: OCaml also can be blindingly fast, often outperforming g++ and occasionally even gcc
18:50:03 <Helic> Has anyone tried F# ? Microsoft's .NET ocaml ?
18:50:15 <CosmicRay> Helic: its license stopped me
18:50:18 <Alabaster> CosmicRay: When I need to worry about performance that much, i tend to drop into ASM
18:50:36 <CosmicRay> Alabaster: Haskell has a fairly nice interface to C, wihch you could probably exploit readily enough as well
18:50:46 <ibid> hmm, perhaps i should model ibicc after fp compilers :)
18:50:49 <Alabaster> for the most part, i honestly dont care terribly since if you code nicely, performance wont be terrible anyways
18:50:50 * Helic is trying to build ghc for target cygwin. Any help is appreciated.
18:50:52 <Riastradh> Alabaster, why, when there are higher-level tools with the same performance available?
18:51:20 * CosmicRay offers Helic prayers, chants, rain dances, and coffee.
18:51:22 <ibid> turn c source into sugared lambda terms and transform that over and over, and only then generate three-address code...
18:51:41 <Alabaster> Riastradh: Theres only so much you can do. I also write shellcode so .. yeah. You understand.
18:51:41 <Alabaster> Sometimes you actually need to mess with parts of the machine not normally accessible
18:51:42 <ibid> might make c code match ocaml :)
18:51:49 <Riastradh> ibid, are you familiar with Kelsey's Pre-Scheme compiler?
18:51:54 <CosmicRay> ibid: you could always write your compiler in camlp4, and just transform the C code into an ocaml AST :-)
18:52:04 <ibid> Riastradh: i recently read a paper that referenced it
18:52:09 <CosmicRay> ibid: you would then be able to compile it using ocamlc, or dump it as scheme :-)
18:52:30 <ibid> Riastradh: (the retrospective on a scheme compiler paper, i forget which)
18:52:33 <Alabaster> But in general, im not too worried. It rarely comes up as an issue
18:52:34 <ibid> CosmicRay: boring :)
18:52:43 <Riastradh> ibid, or, more generally, his work on transformational compilation with a call-by-value lambda calculus intermdiate language?
18:52:50 <ibid> Riastradh: vaguely
18:53:02 <ibid> Riastradh: heard of it, that is
18:53:11 <CosmicRay> ibid: do you know how template haskell compares to camlp4?
18:53:15 <ibid> CosmicRay: no
18:53:18 <CosmicRay> rats.
18:53:24 <ibid> CosmicRay: haven't looked into either
18:53:27 <Riastradh> I suggest that you look into it further.  It sounds like you're interested in something similar.
18:53:27 <CosmicRay> I haven't yet found anyone familiar enough with both to answer.
18:53:34 <ibid> Riastradh: probably :)
18:53:44 <CosmicRay> ibid: well you've at least *heard* of them both, which is something :-)
18:54:04 <ibid> Riastradh: and i suppose i would have ended up reading on it eventually anyway :)
18:54:25 <ibid> CosmicRay: not really even heard of the latter
18:54:31 <bringert> alcohol is a messed up drug
18:54:36 <Riastradh> Template Haskell & camlp4 are both grotesque.  Camlp4 can extend OCaml's syntax, whereas Template Haskell can't extend Haskell's.  That's about the extent of what I know about them (beyond the obvious basics of what they are).
18:54:54 <ibid> Riastradh: do you have a good opening reference?
18:55:00 <CosmicRay> camlp4 can actually completely replace ocaml's syntax
18:55:05 <CosmicRay> there are, for instance, scheme parsers that use camlp4
18:55:15 <CosmicRay> as long as you generate an ocaml ast, you're ok
18:55:43 <Riastradh> ibid, there's Kelsey's PhD dissertation and the conference-length version of it, but the former is very long & requires that you throw gobs of dough to someone, and the latter is ridden with errors & bad typesetting.
18:56:04 * ibid fires up scholar.google :)
18:56:44 <Alabaster> ibid: how good is that? I've peeked at it before, but never bought anything from it.
18:56:46 <ibid> ah yes, the paper whose retrospective i read was Orbit: An optimizing compiler for Scheme
18:57:20 <ibid> Alabaster: somewhere between ho-hum and really great :)
18:57:25 <ibid> Alabaster: haven't decided yet
18:57:32 <Riastradh> I also have a copy of his original compiler, TC, with the ideas researched in his PhD work.
18:57:52 <ibid> they mentioned the transformational compiler work in the retrospective
18:58:02 <Igloo> Riastradh: ICBW, but I think you'd agree only the use of TH to look at the constructors is hideous
18:58:27 <Riastradh> ICBW?
18:58:36 <Igloo> I really like the template construction side
18:58:38 <Igloo> I could be wrong
18:59:42 <Igloo> And if you don't agree I'll show you SHA1 with (a) cpp and hand-unrolled Haskell (b) TH  :-)
19:00:44 <Riastradh> cpp is hardly a useful point of comparison.
19:01:20 <Igloo> Well, I have 2 fast implementations in Haskell, and those are they
19:45:14 * stepcut wants an ebook reader that supports ps/pdf
19:49:38 <Helic> how about a tablet pc ?
19:51:45 <stepcut> one of those *also*
19:52:13 <CosmicRay> stepcut: try a sharp zaurus
19:52:18 <CosmicRay> stepcut: I have a c760, linux OS
19:52:23 <CosmicRay> stepcut: there is a port of xpdf to it
19:52:32 <CosmicRay> works well considering the size of the screen
19:52:35 <CosmicRay> 3" 640x480
19:52:41 <stepcut> CosmicRay: right, that is the problem.... 3"
19:52:46 <CosmicRay> ah
19:53:06 <CosmicRay> much larger and the bulge in your pocket is highly conspicuous :-)
19:54:02 <stepcut> a good ebook reader is better for reading ebooks than either a handle held or tablet 
19:54:22 <CosmicRay> don't they tend to  be tied to a particular format, though?
19:54:39 <stepcut> yes, rtf, txt, and doc often
19:56:31 <stepcut> a large screen pda might do the trick
19:56:44 <stepcut> but they don't really make those that I have seen
20:06:38 <stepcut> so much for that...
20:11:09 <CosmicRay> @commands
20:11:09 <lambdabot> Sorry, I don't know the command "commands", try "lambdabot: @listcommands
20:11:20 <CosmicRay> @listcommnads
20:11:20 <lambdabot> Sorry, I don't know the command "listcommnads", try "lambdabot: @listcommands
20:11:23 <CosmicRay> @listcommands
20:11:23 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
20:11:23 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
20:11:23 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
20:11:23 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
20:11:23 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
20:11:24 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
20:11:26 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
20:11:28 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
20:11:30 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
20:13:22 <stepcut> @fortune
20:13:22 <lambdabot> The myth of romantic love holds that once you've fallen in love with the
20:13:22 <lambdabot> perfect partner, you're home free.  Unfortunately, falling out of love
20:13:22 <lambdabot> seems to be just as involuntary as falling into it.
20:17:39 <stepcut> ugh, I wonder if I show write a simple parser on top of this lexer :-/
20:20:36 <stepcut> oh look, someone already did =)
20:23:16 <Helic> is it me or is the configure/Makefile system truly antiquated
20:26:35 <stepcut> yes
20:28:11 <CosmicRay> auto* SUCK
20:28:24 <CosmicRay> of course the problem they are trying to solve sucks too
20:28:25 <CosmicRay> but still
20:28:46 <Helic> yeah. it really hurts if you're not well versed in shell scripting.
20:29:05 <heatsink> and m4
20:29:21 <Helic> and there is always a perl script scattered somewhere
20:30:10 * Helic does HAVE_UNISTD_H and is proud of it.
20:45:02 <stepcut> hrm...
21:44:30 <shaleh> so, any progress on wxhaskell debian packages?
23:18:19 <dons> yeah. we have a yi gui thanks to wolfgang!
23:19:30 <stepcut> in darcs ?
23:20:25 <dons> not yet. screenshot: http://www.cse.unsw.edu.au/~dons/Yi.jpg
23:20:55 <stepcut> heh, OS X even
23:21:05 <dons> yep. wxHaskell / OS X
23:21:18 <stepcut> neat
23:21:36 <dons> wolfgang thaller wins "yi hacker of the week" award
23:23:19 <stepcut> hehe
