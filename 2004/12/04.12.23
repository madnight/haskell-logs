00:00:04 * arauko is enlightened now 
00:00:26 <Gahhh> KrispyKringle, I recommend nomaware monads tutorial.
00:00:27 <ibid> segphault: which means that i just as well could have done it imperatively in the first place
00:00:51 <eivuokko> ibid, I assumed you meant Annex A of the C++ standard, which is not be taken definitive in things like this - whetever all qualifiers can go after name of the variable/function.
00:01:31 <KrispyKringle> I was trying one of the excercizes int he haskell tutorial i was reading, writing a function to traverse a binary tree bottom-up from the left and generate a list of nodes, but I couldn't quite figure out how to cons it all together. elements (Leaf a) = a would presumably be the base-case, but in the other case, if I recursively do something like: elements (left x right) = (elements left) : x : (elements right), I can't really do t
00:01:38 <KrispyKringle> Whew! (did that make sense?)
00:01:50 <ibid> eivuokko: i said "section 7" of the standard. where did you geet annex A from?
00:02:06 <wli> tell 
00:02:08 <arauko> KrispyKringle, it makes more sense that the wli answer
00:02:13 <wli> the Writer monad
00:02:15 <KrispyKringle> let me paste something. 
00:02:23 <wli> CPS style of IO is passing the continuation in
00:02:25 <Gahhh> KrispyKringle, use the past page on the wiki
00:02:26 <ibid> eivuokko: i'm reading also ISO/IEC 9899:1999 (E), it too seems to allow that
00:02:31 <Gahhh> err paste
00:02:40 <wli> so the impure functions get continuations etc.
00:02:44 <wli> now
00:02:50 <wli> this normally has typing issues
00:02:53 <ibid> eivuokko: (that's C99)
00:02:56 <KrispyKringle> http://rafb.net/paste/results/oNDFPR49.html
00:02:57 <Gahhh> wli, I doubt they know what a continuation is.
00:02:59 <wli> higher-order types can type it
00:03:05 <KrispyKringle> Gahhh: ^^^
00:03:12 <wli> a continuation is just a function representing what you want to do next
00:03:17 <wli> "how to continue"
00:03:21 <arauko> Ah good.
00:03:23 <KrispyKringle> Gahhh: being that that's clearly broken. 
00:03:25 <eivuokko> ibid, I was reading iso 14882:2003 C++ standard....
00:03:39 <KrispyKringle> so if i'm a right leaf, i want to return [a] instead, i should think.
00:03:40 <ibid> eivuokko: what's that? 1998+TC1?
00:03:42 <wli> the user of a continuation knows to how to continue: it calls the function you passed in for the continuation
00:03:56 <wli> etc.
00:04:08 <eivuokko> ibid, 1998 and solved issues, nothind really added.
00:04:19 <ibid> eivuokko: my copy of the wiley book is at work, i'm reading the 1998 PDF
00:04:28 <ibid> eivuokko: ie. 1998+TC1
00:05:05 <arauko> wli, and the function what does it does?
00:05:13 <ibid> eivuokko: i mean:
00:05:22 <wli> arauko: the rest of the program after that IO operation
00:05:23 <ibid> simple-declaration:
00:05:23 <ibid>            decl-specifier-seqopt init-declarator-listopt ;
00:05:35 <eivuokko> ibid, I have no idea what TC1 is.
00:05:38 <wli> arauko: the IO operation chops the program into 2 pieces
00:05:45 <Gahhh> KrispyKringle, what do you expect the return type of "elements" to be ?
00:05:46 <wli> arauko: what's done before the IO operation and what's done after it
00:06:01 <wli> arauko: you make what's done after it into a function and pass it as an argument to it
00:06:04 <arauko> Aah... 
00:06:08 <ibid> eivuokko: you should, if you are into standards :)
00:06:11 <wli> arauko: no mysteries
00:06:15 <ibid> eivuokko: TC1 is Technical Corrigendum 1
00:06:37 <eivuokko> ibid, I dont remember eanyone calling it that, but sure, ok.
00:06:43 <ibid> eivuokko: and then in 7.1:1, we have a definition of decl-specifier-seq and decl-specifier, which include both extern and type names
00:06:51 <arauko> wli, so that is the continuation?
00:06:54 <ibid> eivuokko: it's standard terminology on ISO standards
00:07:00 <wli> arauko: yes
00:07:11 <ibid> eivuokko: are you using the wiley book?
00:07:15 <eivuokko> ibid, That is no proof....  those pieces of grammar are not definitive of all restrictions.
00:07:24 <arauko> wli, and all that process is the monadic concept?
00:07:27 <eivuokko> ibid, No, I find pdf much lighter.
00:07:40 <ibid> eivuokko: as i said, i don't see any constraints that forbid it
00:07:43 <wli> arauko: the monadic concept is a special way to arrange this process
00:07:49 <wli> arauko: in terms of types and so on
00:07:50 <ibid> eivuokko: but i'm not going to read the whole standard to find it
00:07:58 <arauko> Ah.
00:07:59 <ibid> eivuokko: do *you* find one?
00:08:01 <KrispyKringle>  Gahhh a list. so you can see the error here. 
00:08:15 <eivuokko> ibid, I didn't expect you to, I'll check it....
00:08:21 <ibid> eivuokko: TCs are essentially diffs
00:08:22 <Gahhh> KrispyKringle, your base case doesnt return a list.
00:08:30 <arauko> That DOES sound complex
00:08:38 <ibid> eivuokko: what you have seems to incorporate TC1 in the text
00:08:52 <KrispyKringle> Gahhh: right. but if it did, i'd be consing a list onto a list, which, as far as i can telll, is illegal (isn't it?). 
00:08:53 <eivuokko> ibid, Yes.  I do understand what it is from the words....
00:09:09 <KrispyKringle> Gahhh: if i could cons a list to a list, i could just return [a] in my base case and everything'd be peachy. 
00:09:32 <ibid> eivuokko: i have C99's both TC's as PDF :)
00:09:32 <Gahhh> KrispyKringle, you want to concatenate the left and right lists. remember the quicksort example.
00:09:44 <wli> arauko: the continuation is "backwards"; you have to put what comes after before. The monad makes it look "forward" again, because it uses a generic function (>>=) to do the operations in order.
00:10:49 <KrispyKringle> Gahhh: actually, i don't, but i'll go look :)
00:11:16 <Gahhh> KrispyKringle, oh. Just use the "++" operator. Look that operator up in the Prelude. Or...
00:11:22 <KrispyKringle> Ah. that makes it easier
00:11:24 <KrispyKringle> i remember now
00:11:25 <Gahhh> lambdabot: @info (++)
00:11:27 <lambdabot> -- ++ is a variable
00:11:27 <lambdabot> infixr 5 ++
00:11:27 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
00:11:34 <Gahhh> gee thanks
00:12:33 <Gahhh> I should mention another C++ tidbit to get ibid and eivuokko going again...
00:12:43 <arauko> wli, aaah...
00:12:53 <KrispyKringle> thanks, Gahhh 
00:12:56 <wli> do comonads have any programming language -level significance?
00:13:11 <Gahhh> KrispyKringle, np
00:13:33 <Gahhh> wli, do you know category theory ?
00:13:49 <wli> a tiny bit
00:14:02 <Gahhh> I have no idea what a comonad is.
00:14:11 <ibid> Gahhh: :)
00:14:22 <wli> reverse all the arrows in the diagrams a monad makes commute
00:14:26 <wli> done
00:15:49 <Gahhh> I never saw any arrows/diagrams in the monad tutorials I read.
00:16:18 <wli> Gahhh: I'm still not sure how the heck a Haskell monad corresponds to a category theory monad
00:17:01 <Gahhh> I haven't seen the category theory definition of a monad.
00:18:04 <Gahhh> Ugh, the wikipedia page for it is cryptic.
00:18:13 <wli> Gahhh: category theory is cryptic
00:19:10 <Gahhh> wli, I think it can be easier to figure out if a Haskell functor is anything like a CT functor.
00:19:52 <wli> No idea yet.
00:20:39 <eivuokko> ibid, Um, well, actually, my reading of the C++ std annex A (grammar summary) gives that decl-specifier contains, among other things, storage-class-specifier, where extern is.  And init-declarator contains "actualy" type and cv and pointers etc.  But that's pretty lousy given it's not definitive.  But I need to hurry work anyway...
00:20:43 <ibid> when i asked my math prof about category theory he just told me a story whose moral was "don't touch it, it's useless" :)
00:21:15 <Gahhh> wli, you may wanna read Phil Wadler's early papers on monads.
00:21:17 <ibid> eivuokko: the same grammar is in the actual text, just broken up into fragments
00:21:17 <wli> not for programming languages
00:21:20 <wli> not for algebra either
00:21:32 <Gahhh> All science is useless.
00:21:39 <wli> Gahhh: I have. Unfortunately I didn't get much out of them.
00:22:02 <eivuokko> ibid, Yes, but I cannot find the sentece or paragraph containing that restriction.
00:22:08 <ibid> :)
00:22:51 <eivuokko> The skill to read standards seems to fade rather fast....it's not that long ago I read it more.
00:22:54 <ibid> eivuokko: int and friends are part of decl-specifier
00:23:08 <ibid> eivuokko: through type-specifier
00:24:03 <ibid> eivuokko: the declarator part contains the variable name, the pointer asterisks, the array []s and so on
00:24:09 <Gahhh> wli, for some reason, his paper "Monads for functional programming" explained monads to me better than dedicated lighter tutorials.
00:25:26 <eivuokko> ibid, yes, I read wrong.  init-declarator just has it all expressed...
00:25:46 <eivuokko> Duh, now really off.
00:26:42 <Gahhh> ibid, can you tell me the difference between reinterpret_cast and static_cast on a pointer of a derived class ? ;)
00:28:17 <ibid> Gahhh: static_cast performs any type conversion that can be statically be shown to not cause undefined behaviour
00:28:22 <ibid> (more or less)
00:28:51 <ibid> Gahhh: reinterpret_cast is iirc completely implementation-defined, the idea being that it just takes the bits and reinterprets them according to the new type
00:30:20 <ibid> 5.2.10:3: "The mapping performed by reinterpret_cast is implementation-defined. [Note: it might, or might
00:30:24 <ibid> not, produce a representation different from the original value. ]
00:30:27 <ibid> "
00:30:58 <ibid> and :7
00:31:00 <ibid> >> A pointer to an object can be explicitly converted to a pointer to an object of different type.65) Except that converting an rvalue of type "pointer to T1" to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.
00:32:39 <Gahhh> Hmm
00:32:44 <ibid> on static-cast:
00:32:46 <ibid> >> An expression e can be explicitly converted to a type T using a static_cast of the form static_cast<T>(e) if the declaration "T t(e);" is well-formed, for some invented temporary vari- able t.
00:32:57 <ibid> (5.2.9:2)
00:33:55 <Gahhh> Well, from that I conclude that, depending on the platform/implementation, there may not be a difference.
00:34:12 <ibid> yes, but don't count on that
00:34:34 <Gahhh> I won't. You gotta know what you are doing to do reinterpret_cast
00:34:41 <ibid> in fact, there is generally little reason to use reinterpret_cast in most progrms
00:36:33 <ibid> sorry for temporarily making this channel #c++ :)
00:37:02 <arauko> Ohh... i was about to leave this channel
00:37:13 <arauko> that wasn't haskell after all
00:37:16 <arauko> :-)
00:38:28 <ibid> hmm :)
00:39:14 <Gahhh> ok, haskell question
00:39:23 <wli> me too
00:39:27 <wli> So I want a function
00:39:37 <Gahhh> yesterday, arauko showed that ghci accepts "sqrt 9". 9 is not a float, is it ?
00:39:40 <wli> labelTree :: Tree t -> Tree (Integer, t)
00:39:51 <wli> Gahhh: do :type 9 in ghci
00:39:59 <Gahhh> wli, it says Num
00:40:08 <wli> Gahh: float is a num, right?
00:40:12 <Gahhh> lambdabot: @type 9
00:40:13 <lambdabot> 9 :: forall t. (Num t) => t
00:40:44 <Gahhh> wli, I thought Float was a subtype of Num
00:40:51 <ibid> Gahhh: there is no subtyping in haskell
00:40:58 <ibid> Gahhh: and the type is not Num
00:41:55 <wli> 9 :: Num t => t
00:42:13 <wli> well, you can define something of a partial ordering
00:42:21 <wli> maybe even a meet semilattice
00:42:43 <wli> no, not a meet semilattice
00:42:50 <wli> just partial order
00:43:14 <ibid> wli: it's partial order of classes, not types
00:43:34 <Gahhh> I dont know what "Num t => t" means. It is like the context specifier, but t is unknown ?
00:43:46 <wli> ibid: qualifier-free types have a meet if they unify
00:44:14 <wli> so there is a partial ordering on types
00:44:21 <wli> and you can extend it to qualified types
00:44:33 <wli> but those properties aren't used by the type inferencer etc.
00:44:41 <ibid> wli: heh, but that's different :)
00:44:59 <wli> also
00:45:09 <ibid> Gahhh: it means "any type t that is in the type class Num"
00:45:24 <wli> the same expression involving type variables with 2 different sets of qualifiers has a meet
00:45:30 <wli> take the union of the set of qualifiers
00:49:07 <Gahhh> ibid, then, does haskell coerce 9 into being an Int or Float as the usage requires ?
00:51:49 <ibid> Gahhh: there is no coercion required
00:52:09 <segphault> sometimes I scare myself. I just wrote a function to generate church numerals in python
00:52:13 <segphault> church = lambda n: n == 1 and (lambda f,x: f(x)) or (lambda f,x: church(n-1)(f, f(x)))
00:52:38 * Gahhh donates to segphault's sanity fund
00:52:49 <ibid> Gahhh: but the type will be specialized in context to Float or Double or Int or whatever
00:53:05 <Gahhh> ibid, I see.
00:53:14 <ibid> Gahhh: there is no coercion involved, since the result is that the 9 was "always" of that type
00:53:44 <Gahhh> i.e., 9 was "9::Int" and "9::Double" at the same time
00:54:02 <ibid> Gahhh: in a manner of speaking, but technically no
00:54:51 <ibid> the 9 without a context is essentially a set of nines in all the Num types; the type specialization will rule out all but one of them
00:55:22 <Gahhh> ok
00:55:33 <ibid> Gahhh: are you familiar with quantum mechanics and superposition?
00:55:40 <Gahhh> ibid, yes.
00:55:48 <ibid> Gahhh: the situation is similar here :)
00:55:49 <Gahhh> but I find Haskell easier to understand :)
00:56:04 <ibid> me too :)
00:56:39 <Gahhh> I don't even claim to understand anything about Theory of Relativity. 
00:57:53 <ibid> Gahhh: the mechanism is the same that allows you to use length on all kinds of lists
00:58:09 <ibid> Gahhh: well, almost :)
00:58:56 <Gahhh> ibid, I haven't analyzed lists as monads yet.
00:59:36 <ibid> Gahhh: there are no monads involved
00:59:54 <ibid> (though lists are monads, you can ignore that most of the time)
01:00:25 <wli> Relativity is just writing up the Hamilton-Jacobi equations as a geodesic problem for the case where the metric is not positive definite.
01:00:42 <Gahhh> wli, is that sarcasm ?
01:00:53 <wli> No.
01:01:24 <Gahhh> Then you have too much faith in me.
01:01:35 <wli> Not that either, no.
01:02:30 <wli> The point was that variational shenanigans in GR are a different branch of math.
01:57:41 <wli> what are QVars and MVars?
01:57:57 <wli> and Chan's
02:00:06 <wli> Chan's look like a typed pipe
02:00:12 <wli> QSem's look like semaphores
02:00:17 <wli> MVars look like mutexes
02:00:28 <wli> or something
02:00:41 <wli> hmm, no
02:01:03 <wli> MVar's have to be something else
02:01:12 <wli> like a variable protected by mutual exclusion
02:03:25 <wli> if that's so what's the difference between that and a SampleVar?
02:06:30 <wli> okay, SampleVar is the same as MVar but blocks on an empty box
02:07:44 <wli> well, that's easy enough
02:10:56 <wli> so a request comes in, I assign it a tag, I spawn a thread to service it, the thread sends the result back in on a chan
02:11:10 <wli> hmm
02:11:15 <wli> how do I do epoll in Haskell
02:11:52 <wli> well, hmm, maybe I don't do it that way
02:12:19 <wli> maybe the thread receiving from the chan is dedicated
02:13:16 <wli> hmm, there's no priority queue data structure
02:32:33 <wli> okay, there's a queue
02:32:47 <wli> data Queue t
02:32:47 <wli>     = QBranch t (Integer, Queue t) (Integer, Queue t) | QLeaf
02:32:47 <wli> drawQueue :: forall t. (Ord t, Show t) => Queue t -> String
02:32:47 <wli> enqueue :: forall t. (Ord t) => Queue t -> t -> Queue t
02:32:47 <wli> dequeue :: forall t. (Ord t) => Queue t -> Maybe (Queue t, t)
02:35:46 <wli> there should be some way to nuke things by "pointers"
02:35:54 <wli> deleting something etc.
02:37:25 <wli> hmm
02:37:30 <wli> deletion is too naive
02:49:49 <wli> fixed
02:51:40 <wli> not a terribly efficient queue
02:54:33 * arauko wonders who is talking to wli
02:55:49 <vegai> a monologue?
02:57:59 <arauko> when i got sopmething like: Num a => a -> a -> a
02:59:03 <arauko> it means that i got a function that takes a value of type _a_ and returns other fuction that takes a value of type _a_ that returns _a_ 
02:59:03 <arauko> ?
02:59:36 <arauko> a value which is an instance of class type Num also.
03:31:13 <balkan> are these equivalent: map (1+) [1,2,3]   and map (+1) [1,2,3] ?
03:32:25 <balkan> (+1) 3
03:32:35 <pesco> At least they're equal.
03:32:56 <balkan> yes i wonder if there is some subtle difference there...
03:33:11 <pesco> No, (+) is commutative, you know.
03:33:27 <pesco> So, the functions (+1) and (1+) are equal.
03:34:28 <balkan> what is the type of the function (+1) ?
03:34:52 <pesco> In case you're working with floating point numbers, maybe you could spend some thought on rounding errors, but, you know...
03:35:02 <pesco> @type (+1)
03:35:04 <lambdabot> (+1) :: forall a. (Num a) => a -> a
03:35:14 * pesco pats lambdabot.
03:35:26 <balkan> @type (1+)
03:35:28 <lambdabot> (1+) :: forall a. (Num a) => a -> a
03:35:56 <balkan> in hugs these are not the same type
03:36:05 <pesco> I don't believe you.
03:36:15 <balkan> you better
03:36:35 <balkan> :t (+1) in hugs will give
03:36:49 <balkan> flip (+) 1 :: Num a => a -> a
03:37:19 <pesco> The type is the part after the ::
03:37:21 <balkan> whilst :t (1+) gives (1 +) :: Num a => a -> a
03:37:30 <pesco> Which is the same for both.
03:37:32 <balkan> ok
03:37:58 <balkan> what's with the flip part?
03:38:04 <pesco> Read "::" as "has type". The left side is the expression.
03:38:16 <pesco> flip is a function that flips the argument order of a two-arg function.
03:38:40 <pesco> @type map
03:38:42 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
03:38:42 <pesco> @type flip map
03:38:44 <lambdabot> flip map :: forall a b. [a] -> (a -> b) -> [b]
03:38:46 <balkan> is (+1) somehow transformed into flip?
03:38:54 <pesco> Appearently.
03:39:16 <balkan> ok, i wonder if that applies to all functions...
03:39:41 <pesco> See, (1+) is short for "partially apply 1 as the 'left', i.e. first, argument of (+)".
03:39:53 <pesco> That's written as "(+) 1".
03:40:20 <balkan> ok, that i understand.
03:40:37 <pesco> Whereas (+1) has to bind the _second_ arg of (+), so one way to transform it into more basic syntax is to read it as "flip (+) 1".
03:41:07 <balkan> can you do this for all infix functions?
03:41:14 <pesco> Yes, of course.
03:41:17 <ibid> or you can read (1+) as \x -> 1 + x and (+1) as \x -> x + 1
03:43:17 <ibid> @type intersperse
03:43:18 <lambdabot> bzzt
03:43:27 <ibid> heh
03:43:31 <pesco> @type List.intersperse
03:43:33 <lambdabot> List.intersperse :: forall a. a -> [a] -> [a]
03:43:54 <pesco> intersperse is one of my favourite functions.
03:44:14 <ibid> actually, i was hoping that @type would've told me in which module it was :)
03:44:23 <pesco> @index intersperse
03:44:24 <lambdabot> Data.List,List
03:44:29 <ibid> ok, nice
03:47:52 <balkan> @index sort
03:47:53 <lambdabot> Data.List,List
03:48:08 <balkan> @index sortby
03:48:09 <lambdabot> bzzt
03:48:12 <balkan> @index sortBy
03:48:12 <lambdabot> Data.List,List
03:48:22 <balkan> @index map
03:48:22 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
03:48:39 <balkan> is there another way to do this that to send it to this place?
03:48:57 <pesco> You can /msg lambdabot.
03:49:10 <pesco> Or look at the index at http://www.haskell.org/ghc/docs/6.2.2/html/libraries/index.html
03:49:22 <balkan> what if i don't have and internet connection?
03:49:33 <pesco> Download the GHC docs.
03:49:41 <balkan> can it be downloaded?
03:49:48 <pesco> Yes.
03:50:17 <pesco> http://www.haskell.org/ghc/docs/6.2.2/libraries.html.tar.gz
03:50:31 <pesco> For the libs. The same directory holds everything else as well.
03:50:46 <balkan> thx
03:50:53 <pesco> You're welcome.
03:53:43 <balkan> i've browsed it a bit. is there an index function?
03:54:41 <aFlag> hi
03:55:03 <aFlag> does anyone know where can i find some information about typing theory
03:55:04 <aFlag> ?
03:55:46 <pesco> "Types and Programming Languages" by Pierce is a standard book, I'm told.
03:55:59 <pesco> I've read it in part. It is good.
03:56:05 <aFlag> ok, thanks
03:58:03 <aFlag> i'll get it today at the library
03:59:28 <aFlag> i hope no one gets it until this afternoon, but that seems unlikely hehe
04:06:58 <pesco> aFlag: Standing alone, that makes a cool quote. "I hope no one gets it until this afternoon..." ;-P
04:07:37 <yasam> i don't get it
04:07:51 <pesco> That's good.
04:08:06 <pesco> I hope, I don't either. :-PP
04:08:33 <aFlag> hehe i'll get it if no one else does :(
04:13:13 <pesco> What is topological sort?
04:19:14 <yasam> I've met that sort before, snobs if you ask me ;)
04:21:36 <Cale> pesco: taking a set with a partial order on it, and inducing a total order compliant with that partial order
04:22:31 <aFlag> man, cale simple knows everything
04:22:32 <Cale> i.e. If the set is {a,b,c} and you know a < b and a < c, then a < b < c and a < c < b are valid topological sorts of that set.
04:22:43 <arauko> Hello.
04:22:47 <Cale> hello
04:24:28 <yasam> has anyone here got wxhaskell and ghc on Mac OS X?
04:26:11 <Cale> yasam: I've seen that work
04:26:54 <yasam> I'm having problems getting the interactive bit to work
04:28:17 <yasam> Wolfgang Thaller wrote a module to circumvent the restrictions of OS X, but I'm having trouble getting it to link
05:01:27 <yasam> nevermind, I think I understand
05:05:20 <arauko> why 'in' isn't required in a 'do' block?
05:07:05 <sh10151> why would it be?
05:07:44 <yasam> what is readline for?
05:08:21 <arauko> sh10151, you asking to me?
05:08:26 <psi> if you want to show "hello, world" in haskell, can you regard 'putStrLn "Hello, World!"' as a complete program?
05:08:42 <arauko> yes.. 
05:08:44 <arauko> i think...
05:08:46 <arauko> :-)
05:09:09 <psi> i thought maybe main = putStrLn... would be better
05:09:18 <yasam> nevermind
05:09:22 <psi> ghc will compile that, at least
05:10:05 <arauko> you gotta have main to run it standalone
05:10:12 <arauko> if it is what you mean
05:13:14 <yasam> If in ghci I 'set -package wx' I get '... can't load .so/.DLL for: readline (dlcompat: file "libreadline.dylib" not found)' how do I tell it where it is, and why doesn't ghc have the same problem?
05:14:44 <psi> arauko: i guess i'm asking if you can call it a program, even though ghc won't accept it as it is
05:15:23 <psi> or just a function
05:16:51 <psi> is the main function defined as the entry point in the haskell definition, or has ghc decided on this?
05:18:11 <ibid> it's standard
05:18:19 * yasam is rtfm
05:19:07 <ibid> in chapter 5, second paragraph of the revised report:
05:19:14 <ibid> >> A Haskell program is a collection of modules, one of which, by convention, must be called Main and must export the value main. The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t (see Chapter 7). When the program is executed, the computation main is performed, and its result (of type t) is discarded.
05:19:42 <psi> thanks!
05:22:07 <arauko> http://paste.lisp.org/display/4539 <-- why i don't use "let s <- readFile .." ?
05:24:11 <Philippa> arauko: because that wouldn't translate to anything involving >>=, so you'd never actually explicitly sequence the monadic ops
05:24:34 <Philippa> it actually translates to readFile foo >>= (\s -> ...)
05:28:11 <arauko> eeh.. 
05:28:29 <arauko> that means it is a bad thing that shouldn't be done right?
05:29:33 <yasam> I still can't figure it
05:32:11 <pesco> Cale: Thanks.
05:34:42 <Philippa> arauko: it means it won't do what you want it to
05:35:23 * boegel says hello to everyone
05:35:38 <pesco> Hello boegel.
05:36:56 <arauko> Philippa, Ok.
05:38:58 <Philippa> oh, also because the <- bit is strictly part of the do notation
05:39:09 <Philippa> 'lo boegel
05:39:42 <arauko> Ah...
05:47:34 <wolfman8k> boegel: hi
05:47:54 <boegel> hey wolfman8k 
05:48:02 <boegel> created any crazy renders lately ?
05:49:20 <wolfman8k> yeah
05:50:17 <wolfman8k> i've been experimenting with a bunch of shaders
05:50:24 <wolfman8k> here's a gradient shader: http://img133.exs.cx/img133/5049/haskellraytrace106ce.png
05:50:40 <wolfman8k> here's something weird: http://img63.exs.cx/img63/562/haskellraytrace117rb.png
05:51:01 <wolfman8k> here's random stripes: http://img137.exs.cx/img137/2624/haskellraytrace120xd.png
05:51:20 <wolfman8k> here's another weird one: http://img147.exs.cx/img147/5681/haskellraytrace134tc.png
05:51:38 <wolfman8k> here's 3d noise: http://img133.exs.cx/img133/1562/haskellraytrace140mp.png
05:51:53 <wolfman8k> and here is an example of shader composition: http://img157.exs.cx/img157/8803/haskellraytrace162ub.png
05:52:34 <wolfman8k> and i put some info about the raytracer on my website, http://benny.kramekweb.com/hrayt
05:52:52 <boegel> wolfman8k: nice
05:53:11 <boegel> I'm currently not working on mine anymore, I have to do some theoretic stuff on it now
05:54:47 <boegel> but I have lost lots of time when trying to get refraction to work properly
05:55:44 <wolfman8k> i think i'm gonna try getting volumetric lights working
05:56:55 <yasam> a while ago I was reading about an elegant raytracer implementation using geometric algebra and thoguth I might look into a haskell implementation 
05:58:09 <yasam> someone must have some idea on my problem!
05:58:50 <wolfman8k> i think all raytracers use geometric algebra
05:59:01 <Philippa> not always intentionally
05:59:17 * Philippa tries to remember what little of it she knew once...
05:59:29 <Philippa> can just about remember what bivectors, trivectors etc describe, that's about it :-(
05:59:42 <yasam> blades? ;)
06:00:04 <arauko> mm.. i see that Integer == Int in haskell right?
06:00:25 <yasam> geometric algebra exactly equals clifford algebra?
06:01:52 <Philippa> arauko: no
06:02:14 <Philippa> Integer stores integers of arbitrary size, Int is probably whatever your C compiler thinks an int is
06:02:42 <Philippa> yasam: 'mnot quite sure of the details, I think geometric algebra's essentially clifford + near relatives
06:05:08 <yasam> is 'near relatives' a technical term?
06:08:03 <arauko> Thanks Philippa
06:08:13 <arauko> it makes it clearer
06:10:39 <balkan> what if i have a function f x y z and i want to bind the third argument to a value?
06:11:03 <Philippa> yasam: it could be if you believe in memetics
06:11:23 <Philippa> er, you probably don't have a function f x y z?
06:11:34 <Philippa> unless you mean that evaluating f x y z yields a function
06:12:23 <Philippa> but try: (\f z x y -> f x y z) f value
06:14:13 <balkan> i mean lets say that f is a function taking three arguments. i want to curry this to a new function f2 that has the third argument bound to lets say 5.
06:15:09 <aj> f2 x y = f x y 5 # ?
06:15:25 <aj> or (\x y -> f x y 5) ?
06:16:29 <balkan> ok thx. that was easy enough
06:16:58 <yasam> I have found an answer of a sort, mathematicians need to learn Haskell to get a taste for precision 
06:17:25 * aj wonders how someone imprecise could possibly call themselves a mathematician
06:17:34 <Philippa> aj: you ever seen their notation?
06:18:06 <yasam> it's not as bad as physicists atleast
06:18:07 <aj> computer scientists (and maybe physicists) do imprecise mathematical notation...
06:18:07 <Philippa> it leads to things like the guy who runs the FoP group at my uni inventing an entire calculus of quantifiers because he's fed up with inconsistant notation
06:18:29 <aj> oh, inconsistency's another matter
06:19:03 <Philippa> yeah, but inconsistancy can be a form of imprecision when it leads to ambiguity
06:20:14 <Philippa> the infamous ... in sequences is a good example
06:24:05 <balkan> let's say i have a function smaller x y = if x<y then x else y. then i can do map (smaller 3) [1,2,3]. x in smaller will be bound to 3. what if i want to bind to y instead?
06:24:43 <ibid> aj: mathematicians are much more imprecise than most track b theoretical computer scientists
06:25:04 <MegaMonad> Greetings andre_ and patanisca, looking for haskell lists for something else, and whether programs that write python code when you're coding things in hugs or other narcotic when that was executed to give me polite feedback.
06:25:11 <ibid> aj: they do it because they only need to convince other mathematicians, not computers
06:27:21 <Philippa> balkan: you write a quickie function that does things the other way round
06:27:25 <Philippa> it's all just substitution
06:27:36 * shapr yawns
06:27:38 <aj> balkan: (\f x y -> f y x) smaller     gives you the function you want
06:27:58 <aj> balkan: there's a standard name for the (\f x y -> f y x) function, but i don't know what it is :)
06:28:06 <Philippa> swap?
06:28:10 <aj> probably :)
06:28:12 <balkan> that's a bit of a shame right there....when it's the first argument then it's much shorter to write...
06:28:18 <yasam> transpose?
06:28:25 <balkan> flip?
06:28:26 <shapr> Philippa: sure, I'll swap with you...
06:28:47 <aj> flip sounds right
06:29:28 <aj> map (flip smaller 3) [ 1, 2, 3 ]
06:30:03 <balkan> yes that works for functions with two arguments. 
06:33:55 <yasam> This may have been the paper I was thinking of regarding raytracers http://www.science.uva.nl/ga/files/fontijne_dorst_2003.pdf
06:34:21 * shapr yawns more
06:35:00 <yasam> shapr finds raytracing boring?
06:35:05 <Philippa> balkan: er, it's more subtle than that, you can use a chain of swaps and whatever the \f x -> f x func is...
06:35:08 <shapr> no, I just woke up.
06:35:22 <shapr> raytracers are really cool.
06:35:58 <Philippa> have to admit I mostly find raytracers boring, but I have the excuse of having played with graphics a lot prior to shaders taking off in consumer hardware
06:35:59 <balkan> i think i prefered not to swap and just use:  map (\x->smaller 3 x) [4,4,4]
06:36:18 <Philippa> it's often the easiest, yeah
06:36:20 <balkan> kind of a stupid example actually
06:36:22 <shapr> andersca: new mac?
06:36:26 <andersca> yes!
06:36:37 <shapr> andersca: named luminoth?
06:36:44 <andersca> yes
06:36:52 <andersca> it's a race in metroid prime 2
06:36:58 <andersca> they are very wise
06:37:23 * shapr googles
06:37:44 <Philippa> andersca: cool, my b/f just bought it. Unfortunately he's in Harpenden and I'm not atm, but hey
06:38:17 <Philippa> I should finish the first one though. Didn't spend enough time learning the controls
06:38:32 <andersca> I've finished both :)
06:38:36 * andersca is kind of a metroid freak
06:38:50 <andersca> s/kind of//
06:39:16 <Philippa> I liked the 2d games, Prime I kept finding awkward because of the amount of PC FPS I've played
06:39:26 <Philippa> it's not so much learning the controls as unlearning everything else
06:39:28 <andersca> shapr: http://media.nintendo.com/mediaFiles/47df746b-327c-49e2-b0c6-9b9d64d915f7.jpg 
06:39:35 <andersca> I learned them pretty quickly
06:39:47 <Philippa> I can move, I just can't dance
06:40:01 <Philippa> for somebody who used to be pretty good at UT that still feels like being crippled though
06:43:50 <arauko> http://paste.lisp.org/display/4541 <-- what is wrong with this?
06:44:28 * basti_ .o° ( ? )
06:45:02 <basti_> arauko: what is the desired return type of your function?
06:47:03 <yasam> andersca: this is a (very) long shot but you don't perchance have ghc and wxhaskell running on an OS X box?
06:47:18 <basti_> andersca dropped dead.
06:47:29 <yasam> oops :)
06:49:37 <arauko> basti_, a positive number or a negative one as you can see
06:50:05 <basti_> arauko: "some number" or an integer or a float or
06:50:47 <basti_> and, what is the error that happens?
06:51:09 <arauko> basti_, an integer
06:51:37 <basti_> would it neccisairly be the same type as the "input" argument?
06:51:56 <arauko> basti_, http://paste.lisp.org/display/4542
06:52:04 <arauko> that is the errror i get when i load the module.
06:52:16 <basti_> what does this tell you?
06:52:27 <arauko> check it there.
06:52:33 <basti_> no i mean
06:52:42 <basti_> what does your analysis of the error give you
06:52:52 <basti_> what is the information that you gathered from that blurb
06:53:29 <arauko> says something about adding (Ord a)
06:53:56 <basti_> why could you need that?
06:54:03 <basti_> what would (Ord a) be?
06:54:14 <arauko> i don't know, it is the error message.
06:54:36 <basti_> you should try to dig at that spot
06:54:43 <basti_> (Ord a) would be a type restriction
06:55:06 <basti_> saying that the type represented by "a" would be a type of things that can be "ordered"
06:56:00 <arauko> aha
06:57:15 <arauko> yes, but when i use Ord instead of Num , it says that it needs Num instead :-P
06:57:40 <yasam> SUCCESS! After only two days I have managed to et ghci working with wxhaskell on Mac OS X, woot!
06:58:28 <boegel> arauko: you should search for more info on Ord
06:59:02 <arauko> boegel, there isn't something like the HyperSpec for CL similar in Haskell?
06:59:18 <boegel> arauko: I have no idea, sorry :)
06:59:22 <balkan> how can i generate  [(x,y,z) |....] where x,y,z are independent
06:59:28 <arauko> Ok,
06:59:41 <boegel> balkan: how do you mean, independent ?
07:00:08 <balkan> boegel: well it's not like (x,x-1,x*2) if you know what i mean.
07:00:16 <xerox> @get-definition Y
07:00:16 <lambdabot> Y = \f.U(\g.f(U g))
07:00:28 <boegel> balkan: [(x,y,z) | x <- [1.5], y<-[6..10], z<-[11;15] ]
07:00:41 <boegel> typo's, but you get the idea
07:00:52 <boegel> it should be [1..5] and [11..15]
07:01:07 <boegel> balkan: you mean something like this ?
07:01:11 <balkan> boegel: will this give me the cubic product space?
07:01:23 <boegel> balkan: no idea :)
07:01:30 <boegel> what kind of list do you want ?
07:01:35 <yasam> atleast I think it's working correctly
07:01:36 <boegel> what should be in it ?
07:01:37 <arauko> basti_, without a type signature it works fine though.
07:01:54 <balkan> lets say i want (x,y,z) to be random numbers.
07:02:02 <boegel> this will give you [(1,6,11), (1,6,12), ... (5,10,15)]
07:02:11 <boegel> random is quite tricky :)
07:02:20 <balkan> pity
07:02:36 <basti_>  
07:02:39 <xerox> @get-definition U
07:02:40 <lambdabot> U = \f. f f
07:02:56 <balkan> boegel: your expression gave me a giant list
07:03:36 <boegel> balkan: true
07:03:42 <balkan> boegel: i would like (1,6,11),(2,7,12),(3,8,13)...
07:03:50 <boegel> 5*5*5 = 125 itmes
07:03:59 <basti_> arauko: hmm yes now have a guess why ;)
07:04:40 <Darius> Damn I hate Java.
07:05:00 <balkan> Darius: don't we all...
07:05:08 <boegel> balkan: [(\x -> (1+x,6+x,11+x)) x | x <- [0..5]]
07:05:16 <boegel> I'm not sure about this, but it seems ok to me
07:05:22 <boegel> Darius: why ?
07:05:25 <balkan> boegel: this is what i mean with independant...
07:05:46 <boegel> balkan: I see
07:05:54 <balkan> boegel: well i guess i can use zip
07:05:54 <boegel> but I'm afraidI don't know how then
07:06:01 <boegel> true
07:06:06 <Darius> boegel: I'm sure you can provide a laundry list of reasons yourself.
07:06:27 <boegel> Darius: eh, no, not reallt
07:06:37 <boegel> I hate C(++) more than I hate Java
07:06:51 <boegel> s/reallt/really
07:06:55 <balkan> java 5 is quite ok actually..
07:07:06 <basti_> arauko: try a :t my_signum
07:07:09 <Darius> boegel: You couldn't at least provide lack of higher order functions and (until very recently) lack of parametric polymorphism.
07:08:00 <arauko> my_signum :: forall a1 a. (Num a1, Num a, Ord a) => a -> a1
07:08:08 <arauko> thats what i get without type signature.
07:08:27 <basti_> this looks somewhat stricter than yours doesnt it?
07:08:56 <Darius> boegel: One more thing to add to the list for me is that, unlike C++, you must name parameters even if they are unreferenced (at least in Java 1.3).
07:08:58 <arauko> hah... yes.. this is type inference?
07:09:09 * Darius now imagines a bunch of "this variable is not used" warnings.
07:09:22 <boegel> Darius: true
07:09:41 <boegel> Darius: but I guess you can come up with stuff like this for every comp.lang.
07:09:42 <basti_> arauko: yes.
07:10:17 <Darius> boegel: Java has by far the most pedantic and annoying compilers of any language I have ever seen.
07:11:03 <boegel> Darius: pendantic ? I don't know that word... (sorry)
07:11:15 <Darius> boegel:  Further, it's not so much that Java has these problems as that it has -so many- of these problems (and others, and no excuse).
07:11:16 <sh10151> PL/SQL
07:11:18 <Darius> @wn pedantic
07:11:25 <lambdabot> *** "pedantic" wn "WordNet (r) 2.0"
07:11:25 <lambdabot> pedantic
07:11:25 <lambdabot>      adj : marked by a narrow focus on or display of learning
07:11:25 <lambdabot>            especially its trivial aspects [syn: {academic}, {donnish}]
07:11:25 <arauko> basti_, i see where yopu are getting at... but, i don't see how those two extra parameters found their ways into the type signature.
07:11:32 <arauko> basti_, Ord mainly
07:11:48 <basti_> arauko: well Ord would be "orderable" "comparable numbers"
07:11:49 <basti_> or
07:12:07 <yasam> it aint
07:12:13 <basti_> not?
07:12:18 <basti_> ordinal=?
07:12:40 <Darius> boegel: I rather prefer C++ to Java.  About the only thing Java has that I often want in C++ (though not always) is GC.
07:12:56 <Darius> And even that's attainable.
07:13:01 <boegel> Darius: no GC in C++ is a real pain in the ass
07:13:14 <boegel> especially when you're used to coding in Java (like I am)
07:14:17 <basti_> arauko: yes it is "orderable numbers"... Ord types are forced to supply at least a function "<=".
07:14:43 <balkan> how can i subtract 1 from every element i the list [1,2,3]
07:15:13 <jadrian> map the list with a function that subtracts one from an element
07:15:21 <basti_> map (1-) [1,2,3]
07:15:21 <shapr> @yow !
07:15:22 <lambdabot> Not enough people play SKEE-BALL..  They're always thinking about
07:15:22 <lambdabot>  COCAINE or and ALIEN BEINGS!!
07:15:31 <basti_> uhm sorry no
07:15:41 <basti_> map (+(-1)) [1,2,3]
07:15:42 <balkan> not quiet no...
07:15:54 <basti_> for example. 
07:15:57 <balkan> basti_: i have to use +?
07:15:58 <shapr> actually map (1-) should work
07:15:59 <basti_> i didnt say it is optimal
07:16:08 <basti_> no that does 1-x
07:16:30 <shapr> oh right
07:16:32 <Darius> map pred
07:16:40 <basti_> map (\x->x-1) [1,2,3]
07:16:45 <basti_> would be synonymous
07:17:00 <basti_> yup
07:17:04 <basti_> balkan: 
07:17:08 <Darius> @eval map pred [1,2,3]
07:17:09 <lambdabot> unbound variable: pred
07:17:10 <basti_> uhm s/://
07:17:13 <balkan> ok, there is no way to bind to the second argument of - ?
07:17:18 <Darius> @define pred \x.x-1
07:17:18 <lambdabot> pred defined
07:17:21 <Darius> @eval map pred [1,2,3]
07:17:22 <lambdabot> [0, 1, 2]
07:17:35 <basti_> hmm well you could... like... uhm... maybe define some special function which flips parameters
07:17:42 <balkan> what is pred?
07:17:44 <Darius> balkan: Yes, that is one of the few syntactic snafus of Haskell.
07:17:49 <Darius> @type pred
07:17:51 <lambdabot> pred :: forall a. (Enum a) => a -> a
07:18:07 <basti_> i think you can use (-) to access the prefix operator
07:18:41 <Darius> basti_: Yeah, but the problem is only when binding the second argument, so you'd need to do flip (-) x.
07:18:54 <basti_> map (flip (-) 1) [1,2,3]
07:19:14 <basti_> would make the 1 go where the second argument belongs
07:19:30 <basti_> balkan: i hope you learn a lot through that ;)
07:19:40 <basti_> @eval map (flip (-) 1) [1,2,3]
07:19:41 <lambdabot> (line 1, column 12):
07:19:41 <lambdabot> unexpected "-"
07:19:41 <lambdabot> expecting simple term
07:19:51 <basti_> lambdabot: poor dumb little bot.
07:19:52 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:20:03 <balkan> yes, i see. but still it would have been nice if you could bind to any argument...
07:20:10 <basti_> hmm
07:20:10 <Darius> basti_: Quick, patch it to expand (-) into (\x y -> x - y)
07:20:16 <basti_> well you can...
07:20:25 <basti_> Darius: would i need to dig in parser intestines then?
07:20:37 <basti_> balkan: you can ad hoc with lambda
07:21:03 <Darius> basti_: It's actually not too bad... hmm, wait let me check...
07:21:12 <basti_> map ((\x y z->(x z y)) (-) 1) [1,2,3]
07:21:15 <balkan> yes lambda is a good way to go...but there is an assymetri in that you can only bind to the arguments in order...
07:21:17 <basti_> actually thats what flip does
07:21:50 <basti_> hmm what you mean "in order"?
07:23:44 <balkan> you can curry a function very simply by supply the arguments in order. in f x y z you have to bind first x then x and y and so on. if i wanted to bind z i would have to create a lambda.
07:24:17 <balkan> it's not a biggie. lambdas are short to write...
07:24:22 <basti_> yes.
07:24:23 <basti_> =)
07:24:31 <basti_> i think this wont work another way.
07:24:32 <Darius> bastic_: I think adding an alternative in 'application' along the lines of parens operator would be about it.
07:24:46 <basti_> Darius: yes something like that.
07:24:55 <basti_> maybe you could build that around the Stuff/Costuff scheme ;)
07:25:02 <basti_> or the Premise/Result scheme
07:25:07 <basti_> =)
07:25:08 <basti_> oh wow
07:25:29 <Darius> balkan: With binary operators you can section either argument, you just can't with (-) because it conflicts with negation.
07:25:46 <basti_> infix operators are tricky
07:25:52 <basti_> but haskell has a pretty good solution i think
07:26:09 <balkan> Darius: are you sure. doesn't associativity come into play as well?
07:26:27 <basti_> i think darius is right
07:26:36 <basti_> i remember both +5 and 5+ working
07:26:51 <Darius> balkan: No because you (unfortunately) are not allowed to do (+3-2) or such.
07:27:22 <Darius> Actually, the only case I find that unfortunate is ('a':'b':'c':)
07:27:29 <balkan> Darius: i'm gonna try this with division...
07:27:55 <basti_> works like expected.
07:28:13 <balkan> yes. it seems to be a special case with -
07:29:49 <basti_> my BahnCard is still valid =)
07:30:56 <wolfman8k> man... c++ blows chunks :\
07:31:15 <basti_> c++ is to c like lung cancer to lung.
07:31:16 <basti_> ;)
07:32:02 <wolfman8k> i've done c++ coding for years and started getting really good at it and finally really understanding what they call OOP
07:32:15 <wolfman8k> and very recently i've done only a very little bit of haskell programming
07:32:31 <wolfman8k> but now that i try to code some c++ again it sucks... i wish i were using haskell
07:32:35 <basti_> yes.
07:32:40 <basti_> thats what everyone experiences
07:32:51 <basti_> suddenly all that seemed natural feels artificial and awkward ;)
07:32:57 <wolfman8k> yes!
07:33:08 <basti_> because its just playing with cups and peas...
07:33:24 <basti_> do you know these "shuffle" players?
07:33:37 <wolfman8k> yes
07:33:42 <basti_> thats what C does
07:33:44 <basti_> in a sort.
07:34:25 <basti_> ill now journey to my parents for christmas.
07:34:28 <basti_> no haskell there.
07:34:44 <basti_> bye
07:34:46 <basti_> =)
07:35:00 <wolfman8k> i'm trying to code something short and simple... but when i try to do it in c++ short and simple it feels like it's hacky and not very clean... and if i were to try to do it in a clean way then i would have to do this monster OOP framework that would be bloated :\
07:35:41 <sh10151> you should use the STL
07:35:45 <wolfman8k> i am
07:35:50 <sh10151> and the boost libraries
07:35:58 <wolfman8k> i am
07:36:06 <sh10151> oh, ok then :)
07:36:39 <wolfman8k> thing is, i should be ok if i sit down and really design the architecture of the program
07:37:00 <wolfman8k> but i feel that if i were using haskell i wouldn't need to be able to do that since with haskell you can write small components that are extremely modular
07:37:08 <wolfman8k> but c++ just doesn't give you that kind of flexibility
07:37:21 <Darius> Wow, how's this for an error message: "IntegerOp is not abstract and does not override abstract method binOp(int,int) in IntegerOp"
07:37:30 <sh10151> tool support might help, but you are right
07:38:36 <Darius> Ah I see what it's trying to say
07:39:50 <balkan> is there a difference between 'instance' and 'deriving'?
07:40:37 <Darius> Yes, one does the other automatically but only for a few special cases.
07:40:42 <sh10151> Darius: but... but... http://c2.com/cgi/wiki?WhyJavaIsGreat
07:43:07 <srid> is there a equivalent of lisp spel (macros) in haskell?
07:44:21 <Darius> srid: Not in standard Haskell, Template Haskell is along those lines but is not standard.
07:44:39 <srid> hmm
07:44:49 <Darius> sh10151: Wow, some of the things that (according to that page) make Java great are some of the problems I (and others) find with Java.
07:45:04 <wolfman8k> yeah
07:45:17 <Darius> sh10151: Others are simply false, but a few are actually okay but don't make Java -great-.
07:45:18 <wolfman8k> interface vs. class <- sucks
07:45:26 <sh10151> oh, so you think it's a problem that Java isn't BANCStar? 
07:45:28 <wolfman8k>  single class inheritance <- sucks
07:45:35 <wolfman8k>  no operator overloading <- sucks
07:45:47 <sh10151> gotta love the answer to that... "Why is Java great?" "It isn't BANCStar."
07:46:02 <wolfman8k>  Code is fairly transparent... <- sucks
07:46:36 <Darius> wolfman8k:  That's more of just an outright false statement.
07:47:21 <Darius> sh10151: The page would've been better titled "WhyJavaIsGreatProvidedAllYouKnowIsC"
07:50:06 <sh10151> yeah, for sure
07:57:32 <yasam> how convenient is interpretation in developing a non-small project?
07:57:54 <sh10151> by interpretation you mean a DSL?
07:58:04 <sh10151> or programming in a REPL?
07:58:30 <yasam> i mean like ghci vs ghc
07:58:51 <yasam> iteractive dev
08:00:32 <Darius> yasam: It's not a binary decision, you can mix and match, use one or the other as appropriate.
08:00:42 <jadrian> and I don't see the point
08:00:53 <jadrian> why would it stop being useful in a big project
08:00:56 <jadrian> ?
08:03:24 <yasam> I realise you can mix and match, I just wanted to know how useful you considered the facility, neither was I suggesting it would become less useful
08:04:25 <yasam> i.e. if I give up on ghci what am I missing out on?
08:04:53 <jadrian> the same you'd be missing out in small projects I guess... 
08:05:05 <wolfman8k> that's it! i'm converting my project to haskell!!!!!
08:05:12 <Darius> Well, jadrian just took the words out of my mouth.
08:05:40 <sh10151> wolfman8k: make sure to clear it with your boss first
08:05:41 <sh10151> :)
08:05:50 * wolfman8k is his own boss
08:06:03 <Darius> well then clear it with yourself first
08:06:12 * wolfman8k attempts to clear it with himself
08:06:29 <srid> I wonder how lispers handle the global variables problem
08:06:40 <yasam> so not much then
08:06:49 <wolfman8k> only problem is that some of this c++ code i wrote a long time ago and i don't understand how it works
08:07:17 <Darius> wolfman8k: Then use the FFI until you figure it out and can replace it, or just replace it.
08:07:31 <wolfman8k> no, i'll just have to replace it
08:07:48 <jadrian> srid: I don't know about others, but it always seemed to me like parameterized modules would solve most of the problems for me...
08:07:53 <wolfman8k> the only problem is that i'm still very new to haskell
08:08:06 <Darius> srid: What do you mean by the "global variable problem"?
08:08:08 <srid> jadrian: you talking about lisp?
08:08:13 <jadrian> srid: no haskell
08:08:22 <srid> Darius: global variables lead to bugs in general in any language
08:08:43 <jadrian> oh!
08:08:45 <srid> i have just started learning lisp (pcl) .. will learn haskell next ...
08:08:53 <sh10151> common lisp code has plenty of special variables
08:08:55 <Darius> srid: Okay, in that case they do it as most other languages do, by not using them as much.
08:08:55 <srid> but who knows, i may suspend lisp and come to haskell at any stage
08:09:16 <sh10151> CL vs. Haskell is the big choice, isn't it ... :)
08:09:17 <yasam> I had assumed that it would be much more useful for large projects?
08:10:30 <Darius> yasam: I'd say it depends more on what the project is than the size.
08:11:42 <MegaMonad> The hi-boot.
08:12:01 <jadrian> MegaMonad: greetings
08:12:06 <MegaMonad> jadrian: Greetings barrett, what's up?
08:14:59 <sh10151> megamonad: Common Lisp or Haskell?
08:15:05 <MegaMonad> sh10151: Spark: and ruby is more pure than lisp" .. I guess it is haskell written in haskell to understand the difficult language in haskell, so i think c atexit gets called with nil... How can you sort by the lack of ph.d.
08:15:44 <vegai> amazing.
08:25:14 <sh10151> oh geez
08:25:39 <sh10151> http://www-106.ibm.com/developerworks/library/j-pg12144.html
08:25:59 <sh10151> "Much like some of its well known predecessors, Groovy supports the notion of nameless functions or closures. You may be familiar with closures if you've done any coding in Python or Jython, where a closure is introduced using the lambda keyword. "
08:27:44 * yasam doesn't know what a closure is, but I do know what a lambda expression is ;)
08:28:18 <wli> Didn't developerworks do an article directly on Haskell at some point?
08:30:29 <wli> there it is
08:30:31 <wli> http://www-106.ibm.com/developerworks/edu/os-dw-linuxhask-i.html
08:31:39 <sh10151> where do they get the people who write these columns?
08:31:47 <sh10151> an anonymous function is not a closure!
08:32:01 <sh10151> python lambdas don't create a closure!
08:32:41 <wli> what do they do instead?
08:33:33 <yasam> I really should learn about closures, the little I have read hasn't suggested to me they are a very natural, essential concept, wrong?
08:34:54 <Darius> closures are an implementation technique for lexically nested lambda expressions.
08:34:56 <ibid> yasam: they are a very natural, essential implementation concept
08:35:06 <sh10151> python lambdas are not true lambdas
08:35:15 <yasam> ok, will add to stack of things to learn
08:35:20 <ibid> sh10151: isn't that obsolete info?
08:35:28 <sh10151> they only return expressions, and a lot of what python does is not in expressions
08:35:33 <tic> sh10151, corret, only expressions.
08:35:38 * tic learns how to spell
08:36:09 <CosmicRay_> python does support closures, though
08:36:14 <CosmicRay_> just not in lambda definitions
08:36:14 <wli> how so?
08:36:20 <CosmicRay_> you can define a function with def and return it
08:36:25 <Darius> yasam: It's not really pressing to learn what closures are in very much detail if you understand lambda expressions.
08:36:36 <wli> and this is lexical scope?
08:36:51 <CosmicRay> there is a PEP on this
08:36:53 <Darius> yasam: Anyways, closures should be one of the most obvious ways of implementing lambda expressions.
08:36:56 <sh10151> I am just irked that this guy goes on with the trendy Java nonsense and can't get really basic facts straight
08:37:00 <CosmicRay> you used to have to do from __future__ import nested_scopes
08:37:08 <yasam> ok, make that a heap of things to learn so I can change their priority ;)
08:37:14 <wli> what's a PEP?
08:37:24 <CosmicRay> wli: python enhancement proposal
08:37:25 <sh10151> python enhancement proposal
08:37:28 <sh10151> wrong channel :)
08:37:35 <CosmicRay> wli: it's the mechanism for deciding on improvements to python
08:41:36 <yasam> gotta run, thanks to all who gave me info
08:54:10 <kosmikus> hi swiert, how's life?
08:54:44 <swiert> kosmikus: all right - wrapping up my thesis work and considering what to do next.
08:55:44 <kosmikus> do you have a date for your final presentation already?
08:56:49 <swiert> I spoke to Doaitse and Atze last Friday. We decided to spend Christmas on looking at new ideas, then start writing, and graduate in March.
08:56:59 <swiert> but no date set yet.
08:57:03 <kosmikus> ah, ok
08:57:50 <kosmikus> good luck with the new ideas, then ;)
08:58:20 <swiert> Thanks.
08:58:40 <swiert> I'm also looking at places to do a phd.
08:58:44 <swiert> any advice?
08:59:09 <cp__> mit
08:59:59 <swiert> ah - perhaps I should be more specific - involving functional programming/type systems in Europe.
09:00:52 <cp__> what about inria in france ?  they develop ocaml
09:02:19 <swiert> inria, utrecht, gotheborg, nottingham, cambridge, oxford are all good candidates.
09:03:22 <Riastradh> Chalmers?
09:04:08 <swiert> that would be Gothenburg (or whatever the proper english translation is)
09:04:24 <Riastradh> ...oh.
09:05:05 <Igloo> York?
09:05:23 <Riastradh> U of Glasgow?
09:08:05 * CosmicRay wonders: are there any "distant learning" universities in Europe like there are here in the USA?
09:08:09 <swiert> The problem is probably too many suitable candidates. I should probably narrow down further.
09:08:19 <CosmicRay> where you turn in work, communicate mostly over the internet
09:10:07 <Igloo> There's the Open University in the UK, aimed at people who couldn't make normal uni hours I think
09:10:21 <swiert> same in the Netherlands.
09:10:45 <Igloo> I imagine other unis would be flexible on an individual basis, but I don't know of others advertising themselvesas distance learning
09:10:45 <CosmicRay> hmm, that's not the same idea (by "couldn't make normal uni hours", you mean didn't have classwork scores good enough for admission to most universities?)
09:11:01 <Igloo> No, I mean have a day job or something
09:11:05 <CosmicRay> ah.
09:11:13 <CosmicRay> ok, then that is the same idea
09:11:17 <CosmicRay> maybe.
09:11:21 <CosmicRay> that is pretty common here.
09:11:30 <CosmicRay> many universities have night, evening, weekend classes
09:11:48 <CosmicRay> and a good chunk of them offer distant classes, where you need not be physically present.
09:11:54 <shapr> CosmicRay: y0
09:12:12 <CosmicRay> shapr: red pill :-)
09:12:37 <shapr> just had a crazy shower idea... I was thinking that the social organization on #haskell reminds me of a dojo I once attended, and I was wondering a dojo-like structure would be useful for teaching programming
09:12:48 <CosmicRay> what's a dojo?
09:13:16 <shapr> literally it's a building where people teach and learn martial arts.
09:13:17 * CosmicRay can't remember now whether it was the red or the blue pill that signified further study of the matrix
09:13:27 <CosmicRay> ah
09:13:28 <Darius> shapr: Once the Nokia Developer's Suite thrashes its way to starting then the Series 40 emulator thrashes -its- way to starting I'll be testing my Joy interpreter.
09:13:48 <psi> CosmicRay: red
09:13:54 <shapr> figuratively it's more a social organization with the goal being studying of martial arts
09:14:03 <shapr> Darius: cool!
09:14:06 <Darius> shapr: I imagine different dojos are organized in different ways.
09:14:22 <psi> "why of why didn't i take the blue pill"
09:14:36 <CosmicRay> heh
09:14:53 <CosmicRay> these days, isn't the blue pill viagra or something?  /me vaguely remembers "blue pill" commercials on tv
09:15:00 <shapr> Darius: yeah, I agree, I was just wondering how to increase the efficiency of knowledge transfer here on #haskell
09:15:23 <shapr> On the other hand, I suspect the supply is sufficient, it's probably demand that's the limit here.
09:15:25 <CosmicRay> shapr: you could get internet access for your laptop
09:15:32 <shapr> huh?
09:15:34 <shapr> how would that help?
09:15:42 <CosmicRay> shapr: you could transfer knowledge why unicycling
09:15:47 <Darius> shapr: Well if you mean Haskell-related knowledge transfer we could start by talking about Haskell every now and then ;)
09:16:02 * CosmicRay grins
09:16:26 <shapr> good point
09:16:28 <CosmicRay> seriously though, I think the wiki is under-used, and perhaps under-organized, as tends to happen to wikis.
09:16:42 <shapr> the wiki wasn't used at all when I got it :-)
09:16:51 <shapr> like one update a week maybe
09:17:16 <shapr> An explicit wiki-global license would encourage me to put more docs and code on the wiki
09:17:31 <shapr> I can't assure people that they can use anything they see right now.
09:18:56 <shapr> I think demo code would really help.
09:19:34 <shapr> musasabi was talking about a collection of demonstration code. I think it would really help to have a chunk of code for each module at least.
09:20:18 <shapr> And it would be nice to have it on the wiki so anyone can update it, like Lemmih revamped the HaskellDB tutorial I wrote.
09:20:50 <shapr> Anyway, I'm going back to clean the apartment, was just trying to think about the good and bad sides of an online programming dojo.
09:21:20 <shapr> I was thinking five bucks a month for shell, web hosting, lessons, etc
09:21:35 * shapr grabs a sponge and disappears
09:22:46 <tintin> .
09:29:25 <Leimy> howdy!
09:29:38 <Lemmih> G'day Leimy.
09:29:48 <reffie> hello.
09:46:05 <psi> CosmicRay: you're question about the colour of the pill just came on jeopardy :)
09:46:30 <psi> your*
09:47:17 <CosmicRay> psi: heh
09:47:58 <shapr> greetz marksto1 
09:48:37 <shapr> Wow, nifty paper xmas hearts with spiffy mathematical designs on andrew cooke's mailing list.
09:49:57 <shapr> CosmicRay: you think people would cough up five bucks a month to join a small quality community to learn from and teach others?
09:50:08 <shapr> something with a non-profit goal of course
09:50:51 <shapr> CosmicRay: any organization tips for the wiki?
09:51:21 <CosmicRay> shapr: hmm.  I think it would be nice to have such a thing.  But people are used to finding info for free.  It could be a hard sell.
09:51:37 <CosmicRay> shapr: Hierarchical categorization often seems most easy to navigate for me
09:52:58 <shapr> That's true, info usually is free. So what's the benefit of a five dollar a month community? I'm not sure if web/shell/etc is enough.
09:53:29 <shapr> A real dojo teaches regular classes.
09:54:01 <shapr> Maybe the paying members can ask questions during lectures/classes, and the non-paying viewers can't?
09:54:18 * shapr wonders if this idea is worthwhile.
09:54:27 <shapr> Basically, Where's the Beef?
09:54:41 * shapr goes shopping to consider.
09:54:45 <CosmicRay> heh
09:55:13 <shapr> I'll also consider hierarchical organization of the wiki.
10:20:30 <marksto1> really basic question: How can check the length of an array? 
10:23:35 <resiak> marksto1: length   :)
10:25:36 <marksto1> I get 'parse error' when I try this:     when (length opts > 0) $
10:25:36 <marksto1>    
10:25:53 <marksto1> Maybe 'opts' isn't what I think it is?
10:27:02 <ibid> marksto1: that fragment has no problems, the problem is probably caused by the context that you are not showing
10:29:08 <marksto1> Thanks ibid: I'm a perl programmer trying to learn a little Haskell to hack on Darcs. I found a point in DiffCommands.lhs around like 140 that I want to make conditional. We only need to call 'read_repo' if there are options in 'opts'. I'll see if I can get a link with more context. 
10:31:31 <ibid> @wiki PastePage
10:31:32 <lambdabot> http://www.haskell.org/hawiki/PastePage
10:31:37 <ibid> :)
10:32:08 <ibid> hmmhhmmh
10:32:15 <marksto1> Here's a link the code (before I tried to modify it!). If you search near the bottom for 'morepatches',  those are the two lines that only need to be called if there are any opts: http://abridgegame.org/cgi-bin/darcs.cgi/darcs/DiffCommand.lhs?c=annotate
10:32:18 <ibid> i obviously meant
10:32:29 <ibid> @wiki HaskellIrcPastePage
10:32:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:33:04 <Lemmih> marksto1: Is it diff_cmd you're trying to change?
10:33:39 <marksto1> Yes it is. 
10:34:08 <Lemmih> marksto1: If so, a simple 'diff_cmd [] _ = return ()' should suffice.
10:34:13 <ibid> well yeah, just adding "when (length opts > 0) $" somewhere there as a line of its own is going to be a problem
10:35:04 <marksto1> I see. I probably need to bury my head in documentation for a while...
10:35:21 <ibid> marksto1: what Lemmih said might help you
10:35:54 <marksto1> Lemmih: I'll try something based on your syntax suggestion. Thanks!
10:36:31 <ibid> marksto1: the critical thing is to know where to add it...
10:37:15 <ibid> i'd say immediately before diff_cmd opts args = do
10:37:36 <ibid> of course, the question is whether it does what you want :)
10:38:38 <marksto1> Thanks ibid: I still want to run some other parts of the current diff_cmd, but I think perhaps I'll work it out if I play some more. 
10:40:24 <ibid> marksto1: something that you can do, if you just want to ignore a couple of lines, is
10:40:43 <ibid>   when (length opts > 0) $ do line 1
10:40:45 <ibid>   line 2
10:40:55 <ibid> where line 2 is aligned with line1
10:41:16 <ibid> and if there are more lines, just align them with line1 :)
10:41:33 <ibid> when you return to the original indentation, the condition block ends
10:41:34 <marksto1> And the main difference with that and what I had is that 'line 1' starts on the same line as 'when'? 
10:41:45 <ibid> and you had no do
10:41:51 <marksto1> Right. 
10:42:13 <ibid> you can also put line 1 on its own line, just make sure to indent it more than the when
10:49:42 <marksto1> I think I need to go 'back to the basics': I'm still not getting this right: http://www.haskell.org/hawiki/HaskellIrcPastePage
11:05:41 <jadrian> marksto1: well you go to return something
11:05:51 <jadrian> marksto1: you are not returning any value
11:07:17 <marksto1> Thanks for the tip jadrian. I'll look into that. 
11:07:35 <jadrian> marksto1: why are you binding 'morepatches' to that expression if you're not using it
11:10:20 <marksto1> I do want to use morepatches if there are any 'opts'.
11:12:09 <Darius> shapr: Well, I need to add persistency and rewrite/finish the parser but it seems to do what it's supposed to after inextensive testing.
11:12:36 <marksto1> thanks for your help everyone. 
12:05:35 <Darius> @definitions joy
12:05:36 <lambdabot> ["joy","joyBinOp","joyDefs","joyEval","joyExpr","joyIFTE","joyParse"]
12:05:51 <Darius> @get-definition joyDefs
12:05:52 <lambdabot> joyDefs = [Pair "+" (joyBinOp (\x y.x+y)),Pair "-" (joyBinOp (\x y.x-y)
12:05:52 <lambdabot> ,Pair "/" (joyBinOp (\x y.x/y)),Pair "*" (joyBinOp (\x y.x*y)),Pair "="
12:05:52 <lambdabot> (joyBinOp (\x y.x==y)),Pair "dup" \s.first s : s,Pair "i" \s.joyEval (first
12:05:52 <lambdabot> s) (tail s),Pair "true" \s.True:s,Pair "false" \s.False:s,Pair "ifte" joyIFTE
12:05:52 <lambdabot> Pair "x" \s.joyEval (first s) s,Pair "pop" tail,Pair "dip" \s.second s:joyEval
12:05:52 <lambdabot> (first s) (tail (tail s))]
12:06:43 <shapr> Darius: yay
12:07:07 * shapr returns from shopping
12:07:28 <shapr> I bought watch batteries for our five cats for christmas. Now their favorite laser pointer has returned.
12:07:59 <Darius> shapr: Can you/How easy is it to make [ ] on a cell phone?
12:08:35 <shapr> there's one button for a special chars, it's under there.
12:08:39 <shapr> along with twenty others.
12:08:50 <shapr> it's easy to make .
12:10:44 <shapr> In general, it's hard to make characters on phones.
12:10:56 <Darius> Hmm, I guess . and , would work; 'guess I could make that configurable too.
12:13:08 <Darius> Now I need a good machine readable format for Joy code.
12:13:20 <shapr> I've been thinking about new orthographies, the various points I see are ease of human writing and ease of both human and computer reading.
12:13:51 <shapr> I have a really cute spiral orthography, but I suspect it's difficult to differentiate the chars.
12:14:25 <shapr> It's easy enough to find a cute binary number of human voice sounds that stand out, but how to do that with written shapes?
12:15:53 <shapr> If you're talking about somewhat 'compiled' Joy code, I think eager evaluation on input would allow easy representation as constants and stackscramblers.
12:16:45 <shapr> essentially compile to point-free :-)
12:16:55 * shapr wonders if that idea has any gotchas
12:18:14 <shapr> I guess you could think of executables on the command line as point-free functions.
12:18:16 <shapr> whoa, cosmic.
12:18:23 * shapr tokes on a lambda
12:19:05 <Darius> @get-definition joy
12:19:06 <lambdabot> joy = either id (flip joyEval [] . fst) . joyParse
12:19:14 <Darius> @get-definition joyEval
12:19:14 <lambdabot> joyEval = \l.foldr (flip B) id (map (lookupDef joyDefs) l)
12:19:22 <Darius> @get-definition joyParse
12:19:23 <lambdabot> joyParse = runMonad MonadParser joyExpr
12:19:32 <Darius> @get-definition joyExpr
12:19:33 <lambdabot> joyExpr = many $ choice [bind (squares joyExpr) (return . Left),bind identifier
12:19:33 <lambdabot> (return . Right),bind_ (sat (\c.c=='\'')) $ bind next $ \c.bind_ spaces
12:19:33 <lambdabot> $ return (Left c),bind parseNum $ \n.bind_ spaces $ return (Left n)]
12:20:36 <Darius> Looking at that definition in an almost pure lambda calculus and comparing it to my current Java code is depressing (depending on where you stand).
12:21:45 <shapr> Maybe it's simpler to implement a lambda cal interpreter in Java?
12:22:12 <shapr> Or maybe one of Brent Kerby's sets of elegant bases for Joy?
12:22:22 <Darius> I was thinking about saying screw Java and compiling some language to Java.
12:23:08 <shapr> that's probably sensible
12:23:11 <Darius> Though one issue is that I'd want to minimize file size.
12:23:52 <shapr> of the compiled language?
12:24:00 <shapr> or the intermediate format? or what?
12:24:31 <shapr> Theory of Concatenative Combinators - http://tunes.org/~iepos/joy.html
12:24:42 <Darius> Of the "executable".
12:24:43 <shapr> Reminds me of SPJs work on supercombinators.
12:24:46 <shapr> oh
12:33:30 <Leimy> ultramonad
12:33:30 <shapr> I need another unicycle.
12:33:48 <Lemmih> shapr: How so?
12:34:26 <shapr> Lemmih: they don't make ice tires in either 20" or 24" so I want a 700c/29" since they make both 65mm rims and metal studded tires in that size.
12:34:35 <Leimy> ice tires for a unicycle?
12:34:49 <Leimy> that sounds hazardous :)
12:34:55 <shapr> I haven't ridden in neary a week now, and it's making me stir crazy.
12:35:09 <Leimy> yeah... I need to get my bass out and start playing again
12:35:16 <Leimy> but the holidays keep me too busy
12:37:23 <shapr> crap, the 65mm rim is 26" rather than 700c
12:38:15 * shapr sends email to Kris Holm
12:48:12 * Darius needs to add a Cancel to Define.
13:05:46 <Darius> oi
13:10:42 <Aglarion> Does someone have the time and patience to answer a newbee question?
13:10:59 <Riastradh> Only if you ask it.
13:13:14 <Aglarion> The problem is, I try to print a string, read on in and then print the read one back to screen. The thing is, haskell keeps first reading the string, then printing the question and then the answer.
13:13:45 <Aglarion> I tried to use
13:13:46 <Aglarion> do
13:13:52 <Aglarion> putStr "Question: "
13:13:59 <Aglarion> x <- getLine
13:14:02 <Aglarion> putStr x
13:14:07 <SyntaxNinja> you have to flush the buffer somehow, either with a newline or a flush command
13:14:19 <Aglarion> ah...
13:15:07 <Aglarion> That sounds logically. I was used to having flushed the output buffer automatically when reading input...
13:15:17 <Aglarion> Thanks a lot
13:15:20 <SyntaxNinja> http://www.haskell.org/hawiki/UsingIo
13:15:32 <SyntaxNinja> look about half-way down for the explanation, "My program is supposed to prompt the user for input, but it reads the input before showing the prompt. Why?"
13:17:22 <Aglarion> Thank very much! I googled about this topic, guess I used the wrong keywords.
13:17:39 <SyntaxNinja> np
13:30:40 <Aglarion> Okay, I added "hFlush stdout" right after the putStr line, it compiles, but effect is the same. Do I use hFlush wrong?
13:30:43 * Igloo decides, based on a couple of nights hacking, that XSLT is not a rival for Haskell in the programmer-friendliness department
13:31:15 <Philippa> could've told you that for free, I already had a wiki clone that was essentially XSLT + a database
13:31:25 <Igloo> That sounds right. Are you sure it's before the getline line, that you saved it and that you are running the right binary?
13:31:58 <Lemmih> Aglarion: Posting the code might help us debug it.
13:32:06 <Aglarion> I am sure about it. "import IO (hFlush, stdout)" is also correct?
13:32:39 <Aglarion> Oh... dammit.
13:32:42 <Aglarion> Sorry
13:32:53 * Aglarion feels VERY VERY stupid
13:32:55 <Igloo> Well, I wasn't really expecting it to be  :-)   Although I'm a bit disappointed in just how bad it is. It looks like 2.0 will fix at least some of my issues, though
13:33:35 <Igloo> What had you done?
13:33:36 <Aglarion> (forgot to add output filename in ghc call... correct binary was therefore a.out)
13:33:46 <Igloo> Ah  :-)
13:33:50 <Aglarion> So, I was sure... but wrong anyway
13:34:03 <Igloo> heh
13:34:24 <Aglarion> (It's just like when I began Linux programming... called the program "test")....
13:35:04 <Aglarion> And then wondered why the program did not do anything
13:35:29 <maeglin> Aglarion, lol, i encountered the same problem
13:36:19 <Aglarion> It's good to know I am not the only one making that stupid mistakes
13:37:06 <maeglin> i don't think this is not *that* stupid
13:37:13 <Aglarion> maeglin: Does your name come from tolkien books?
13:37:29 <maeglin> Aglarion, yes! no one noticed so far
13:37:42 <maeglin> Maeglin is the son of E?l
13:37:52 <Aglarion> I know
13:38:05 <Aglarion> I read the Fall of Gondolin...
13:38:35 <maeglin> yeah, he betrayed gondolin to morgoth
13:39:48 <SyntaxNinja> "test" is a classic problem
13:39:49 <Aglarion> My name is a self-assembled Quenya word, meaning (hopefully) something like "The shiny one" (I did not really think about it too long..)
13:39:59 <SyntaxNinja> it's so awesome that it just does nothing too
13:40:25 <maeglin> Aglarion, i see, i tried to learn sindarin once but gave up
13:40:52 <Aglarion> I found sindarin too hard, because of all the mutation rules. Quenya is much easier
13:40:55 <Igloo> Oh, I thought it was a refernce to make test doing nothing, which seemed odd for a beginner
13:41:02 <SyntaxNinja> we used to joke that we were going to write a "make go" target for graduate student help requests which would 1) check to see if their program actually compiles 2) check to see if it has execute permissions...
13:41:25 <SyntaxNinja> 3) check to see if it's called "test" 4) check to see if they used "./progName" to execute it 5) if all else fails, delete it.
13:41:41 <maeglin> lol
13:41:53 <wli> I love /bin/[
13:42:19 <wli> might be /usr/bin/\[ on your box
13:42:53 <tuomov> shell built-in
13:43:03 <wli> not for all shells
13:43:08 <wli> ls -ld /usr/bin/\[
13:43:13 <tuomov> I prefer typing 'test foo' than [ foo ], though
13:43:17 <wli> or ls -ld /bin/\[
13:43:27 <Aglarion> "/bin/MaTA"
13:43:33 <Aglarion> it's an insider joke
13:44:27 <Aglarion> "bin" is the german word for "I am" and MaTA is the abbreviation for my profession
13:45:23 <Aglarion> and since a MaTA does often have to work with Unix-System someone came up with this joke...
13:46:23 <maeglin> Aglarion, do you have to study at  a university inorder to be educated as MaTa ?
13:47:09 <Aglarion> no, why?
13:47:18 <Aglarion> wasprofession the wron word?
13:47:24 <Igloo> Do people say bin nt preceeded by "ich", then?
13:47:41 <maeglin> no, i just thought MaTas would study at univeristy
13:47:59 <Aglarion> Igloo: they do, but i thought noone would understand a simple "am"
13:48:20 <tuomov> mathematics teaching assistant? no?
13:48:30 <Aglarion> and people do often leave the "Ich" away
13:48:46 <Aglarion> almost... mathematics technician assistant
13:49:08 <Aglarion> (don't know if technician is the right wor, or even IF it is a word)
13:49:26 <Aglarion> "Mathematisch-Technischer Assistent"
13:51:23 <tuomov> sysadmin for a math. dept?
13:54:02 <Aglarion> The job is about numerical computation, at my school with focus on unix environments
13:56:10 <Aglarion> Well... numericalcomputations are only the thing that gave it the name "MaTA". In fact, it's also about system-programming, digital electronics, databases etc
13:56:17 * boegel says "hi"
13:56:23 <Darius> shapr: Quick, what's a definition of ifte in terms of other Joy primitives!
13:57:07 <shapr> um um
13:58:01 <shapr> something using == and two quoted chunks of code?
13:58:42 <shapr> er, three
13:58:52 * shapr thinks
13:59:03 * boegel cheers for shapr 
13:59:11 <shapr> hoi boegel, wassup?
13:59:18 <boegel> shapr: kinda tired
13:59:28 <Aglarion> But for some weird reason, we were tought programming C++, which is a pretty bad choice for numerics. Guess Haskell would've been a better choice.
13:59:30 <boegel> I had a party last night, and it was 5am when I got to bed :p
13:59:34 <shapr> nice
14:00:02 <Aglarion> afk
14:00:48 <boegel> and I should really start to do some heavy studying/working tomorrow, but my girlfriend asked if I'd go shopping with her
14:01:04 <shapr> I went shopping with my girl today, it was fun.
14:01:05 <Darius> shapr: I'm thinking something along the lines of [[stack [i] dip cons unstack] dip] dip choice i or something.
14:01:52 * shapr doesn't remember stack
14:01:54 * Darius still needs to get something he's been meaning to get
14:02:00 <Aglarion> shopping is fine... as long as she does not decide to enter a shoe store
14:02:04 <Darius> shapr: It pushes the stack on the top of the stack.
14:02:17 <shapr> oh
14:02:22 <shapr> that makes everything easy
14:02:30 <Aglarion> i noticed women start running in pretty irregular patterns,once they are there
14:03:32 <shapr> that's usually because they only try on one shoe at a time.
14:03:41 <shapr> it's hard to run in a regular pattern with unequal shoes.
14:03:47 <Aglarion> lol
14:03:59 <Aglarion> i meant before trying on any shoe
14:04:03 <shapr> oh
14:04:15 <arauko> Hello.
14:04:26 <arauko> my_signum :: (Num a1, Num a, Ord a) => a -> a1
14:04:26 <arauko> my_signum a =
14:04:26 <arauko>     if a > 0
14:04:26 <arauko>        then 1
14:04:26 <arauko>     else if a < 0
14:04:26 <arauko> 	 then -1
14:04:29 <arauko> 	 else 0
14:04:31 <Aglarion> just the act of selecting the right shoes to try
14:04:40 <arauko> why does it give error with a negative argument?
14:04:42 <shapr> hey, three lines is max paste size without special permission.
14:04:52 <arauko> shapr, oh, sorry about that
14:04:53 <boegel> aruako, try (-1)
14:05:00 <shapr> no worries, just don't do it again :-)
14:05:04 <arauko> :-)
14:05:06 <shapr> that's why we have a paste page
14:05:09 <boegel> or shapr will kick your ass :p
14:05:13 <shapr> I will?
14:05:18 <arauko> shapr, what is it?
14:05:18 <shapr> I thought you were the channel enforcer?
14:05:25 <shapr> @wiki HaskellIrcPastePage
14:05:26 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:05:26 <shapr> I think
14:05:32 <arauko> Cool, thanks
14:05:44 <arauko> boegel, oh, thanks 
14:05:45 <shapr> Darius: what prims do I get to use?
14:05:55 * Darius thinks his unstack is not popping the top of the stack when it unstacks.
14:05:57 <shapr> any particular set?
14:06:00 <boegel> shapr: me ? enforcer ?
14:06:46 <boegel> arauko: you should use pattern matching
14:07:07 <arauko> boegel, ?
14:07:15 <arauko> <--- a few days with haskell
14:07:24 <boegel> my_signum 0 = 0
14:07:33 <Darius> The prims I have are: most literals, dup pop swap stack unstack or xor and not first rest cons null i x choice name intern body + - * / rem <= dip
14:07:44 <boegel> that clips down to two more possibilities (>0 and <0)
14:07:45 * Aglarion <--- ,too
14:07:55 <boegel> so then you'll have this :
14:08:08 <boegel> my_signum :: (Num b, Num a, Ord a) => a -> b
14:08:16 <boegel> my_signum 0 =0
14:08:33 <boegel> my_signum x = if (x>0) then 1 else (-1)
14:08:51 <boegel> and you could do the last one without 'if .. else' I think
14:08:56 <boegel> s/if/if then
14:08:58 <Darius> shapr: After fiddling with my unstack if that definition of ifte works and therefore factorial works you want the jar and/or the ugly ugly source?
14:09:07 <arauko> boegel, aaah.. beautiful
14:09:13 <arauko> Thanks boegel
14:09:23 <boegel> arauko: do you understand how it works ?
14:09:28 <shapr> Darius: yes, e) all of the above
14:09:37 <shapr> not sure how I can get it into my phone, but I'll figure it out.
14:09:39 <arauko> yes, when it receives 0, the function just returns 0
14:09:55 <boegel> arauko: ok then :)
14:09:59 <arauko> otherwise, runs the if..then clauses
14:10:04 <arauko> :-)
14:10:46 <arauko> boegel, what i don't understand a little, it is the type signature.... why if im receiving only one number as argument, i need to specify three.?
14:11:03 <shapr> Darius: yah, I think your ifte is much like what I just figured out, thread the i down to the [B], then smack the result with i
14:11:25 <boegel> arauko: you only specify one type (a) and one type of result (b)
14:11:30 <Aglarion> if I am right, you just specified the types of the parameter and result
14:11:39 <boegel> the first bit of your type, are constraints on the types you are using
14:11:41 <Aglarion> so a is in classes num and ord and b is in num
14:11:51 <boegel> type a should be numeric, as should type b
14:11:53 <shapr> Joy is so cool, but I gotta try PostScript. It really irritates me that I can push succ onto the stack.
14:11:57 <shapr> g'day Pseudonym 
14:11:58 <boegel> and type a should be sortable
14:11:59 <Pseudonym> G'day.
14:12:13 <boegel> Aglarion: right
14:12:23 <Aglarion> I was _RIGHT_???
14:12:30 <Aglarion> "Oh happy day..."
14:12:56 <Aglarion> that does not happen very often in haskell questions
14:13:16 <boegel> Aglarion: you'll learn, just as I am learning
14:13:24 <boegel> I'm quite newbie too
14:13:28 <Aglarion> ok
14:13:30 <shapr> oh oh me too!
14:13:54 <arauko> so, i think i got sort of a confusion here.. type signature has nothing to do with arguments?, i mean, they don't specify arguments, but the values types the function (in general) will use?
14:13:59 <Pseudonym> We'd all better be learning.
14:14:03 <Pseudonym> The alternative is being stupid.
14:14:38 * boegel is thinking about doing a Phd on stuff with functional proof tools and such
14:14:59 <Aglarion> i thought the basic way of thinking functional was the hardest part... but when i switched from scheme to haskell... everything got pretty confusing
14:15:01 <Pseudonym> Interestingly, modern functional programming started with proof tools.
14:15:09 <Pseudonym> ML was the Macro Language for a theorem prover.
14:15:25 <shapr> Backus
14:15:26 <shapr> right?
14:15:29 * Aglarion is going to study next winter
14:15:35 <Pseudonym> Can't remember which one it was.
14:15:42 <arauko> anyone?
14:15:43 <shapr> Aglarion: how are you going to study next winter before you get there?
14:16:03 <shapr> arauko: how else can you specify arguments?
14:16:04 <SyntaxNinja> arauko: I don't understand your question
14:16:05 <Pseudonym> Sorry, Meta Language.
14:16:08 <Pseudonym> Not Macro Language.
14:16:08 <Riastradh> Backus invented FP.  Milner did ML, which I thought expanded to Meta Language.
14:16:19 <SyntaxNinja> arauko: indeed, they do say what the type of the functions arguments are.
14:16:27 <Pseudonym> I _think_ it was LCF.
14:16:32 <Riastradh> If I'm not mistaken, FP was from the '60s & ML was from the late '70s.
14:16:34 <Pseudonym> The theorem prover.
14:16:37 <Riastradh> I could be totally wrong, though.
14:16:41 * Aglarion is going to begin studying computer science in winter 2005
14:16:48 <Aglarion> winter 2005/2006
14:16:48 <boegel> arauko: type signature specify's the types of the arguments and of the result of the function
14:17:30 <arauko> SyntaxNinja, shapr, well, my question can be summed up on Why do i need to specify three (Num a, Num b, Ord a) types if im only get one?
14:17:51 <arauko> i only pass one value i mean
14:18:02 <SyntaxNinja> you mean that b is the return value?
14:18:05 <Aglarion> because "a" has actually two classes,so you specified only two. the second is the return type
14:18:16 <shapr> oh, because return types are part of the type sig too
14:18:35 <SyntaxNinja> "Num and Ord" are describing the type of the input parameter.
14:18:35 <Pseudonym> FP was interesting, but I'm not convinced that it was that much of an improvement over Lisp-esque languages.
14:18:37 <Darius> I think 'safe = stack rest swap dip unstack' is the combinator I need to get my ifte working.
14:18:42 <Pseudonym> It had a more modern syntax, admittedly.
14:18:52 <Aglarion> signum :: (Num parameter1, Num return_type, Ord paramter1)
14:18:53 <arauko> Ah... but it isn't the return type this : (Num a, Num b, Ord a) -> b 
14:18:55 <arauko> ?
14:18:58 <arauko> the last b
14:19:03 <SyntaxNinja> something's wrong there
14:19:15 <arauko> Sorry
14:19:17 <SyntaxNinja> did you post a code example that I'm missing?
14:19:21 <arauko> Ah... but it isn't the return type this : (Num a, Num b, Ord a) => a -> b 
14:19:32 <SyntaxNinja> so "a" is the input param, and "b" is the return type.
14:19:38 <arauko> SyntaxNinja, let me paste it in the wiki
14:20:04 <Pseudonym> The more important thing about FP was the insight.
14:20:06 <SyntaxNinja> and Num and Ord describe some restrictions on "a" and "b"
14:20:35 <Pseudonym> The language itself was kinda useless, IMO.
14:20:44 <Aglarion> a and b are types, not variables
14:21:16 <SyntaxNinja> yeah, I should have said "a" is the input param's type and "b" is the return type
14:21:56 <Aglarion> SyntaxNinja, I did not mean to criticize you, just wanted to explain it to arauko
14:22:18 <SyntaxNinja> Aglarion: np
14:23:11 <arauko> Here is the code http://paste.lisp.org/display/4546 
14:23:48 <arauko> yes, b is the returned value, but i though that was specified by => a -> b and not by (Num a, Num b, Ord a)
14:24:05 <SyntaxNinja> "a" is the type of the input param, and it has to be a "Num".
14:24:19 <arauko> ok, i get that part.
14:24:25 <arauko> what about Ord?
14:24:35 <arauko> And Nm b?
14:24:55 <SyntaxNinja> b is the output type
14:24:58 <SyntaxNinja> it also must be a number
14:25:05 <Aglarion> => a -> b specifies what is the name of input- and what is outputtypes. (Num a, Num b, Ord a) actually specifies, what these types are
14:25:08 <SyntaxNinja> and I am not sure, but you may not need ord, because ai think all numbers are ord
14:25:29 <arauko> SyntaxNinja, when i remove the Ord a , it doesn't work.
14:25:35 <Aglarion> bad syntax in above statement...
14:25:35 <arauko> it says it needs to be added.
14:27:03 <SyntaxNinja> OK fine :)
14:27:58 <SyntaxNinja> arauko: so "f :: a -> b" says that a and b can be any type whatsoever.
14:28:23 <SyntaxNinja> but "f :: (Num a) => a -> b" means that "a can be any type, as long as it implements the 'Num' interface, and b can be any type whatsoever."
14:28:52 <SyntaxNinja> but "f :: A -> B" means that A and B are specific types, since they're capitalized.
14:30:21 * arauko scratches his head
14:31:15 <SyntaxNinja> you're not going to completely get it until you read about type classes.
14:31:51 <boegel> arauko: a and b are placeholders for any type (variables for a certain type)
14:32:12 <arauko> i mean, i get that part, what i don't understand it is the syntax of the signature type... i mean, Num a meas a value which is of type Num, similar to Ord, they are sort of a restriction?
14:32:17 <boegel> when you capitalize them, they are considered as actual type, so Haskell will search for a type with name A and B
14:32:29 <arauko> Ah.. 
14:32:37 <arauko> Similar to, Int -> Int
14:32:42 <boegel> arauko: yes, kindof restrictions on the type you can fill in for a
14:32:45 <boegel> arauko: right
14:32:52 <arauko> Ah...
14:33:58 <arauko> so, (Num a, Num b, Ord a) means that the function takes any value 'a' which is an instance of type class Num and Ord and returns a value 'b' which is an instance of Num also ?
14:34:33 <arauko> (Num a, Num b, Ord a) => a -> b 
14:35:53 <boegel> arauko: you got it :)
14:36:14 <arauko> \o/ 
14:36:23 <boegel> \\o
14:36:26 <boegel> \o/
14:36:26 <arauko> Thanks all
14:36:28 <boegel> o//
14:36:29 <arauko> :-)
14:36:34 <arauko> hah
14:36:52 <Pseudonym> Now do the YMCA thing in ASCII.
14:37:02 <SyntaxNinja> no... please.......
14:37:09 * Darius wonders how many other people thought that...
14:37:22 <Pseudonym> Yeah, but I managed to type it fastest.
14:37:25 <SyntaxNinja> what is that supposed to be anyway? it looks like a plate with chopsticks to me
14:37:34 <Darius> Pseudonym: I just decided not to say it.
14:37:41 <Pseudonym> Darius: Good call.
14:37:56 * Pseudonym is tired, under-caffeinated and it's Christmas eve.
14:38:14 <monochrom> Y
14:38:15 <monochrom> M
14:38:17 <monochrom> C
14:38:18 <monochrom> A
14:38:25 <monochrom> (YMCA thing in ASCII)
14:38:26 * Darius has a whole 6 and a half hours before Christmas Eve.
14:39:01 <arauko> haha
14:39:26 <boegel> SyntaxNinja: it a guy with his arms open
14:39:33 <boegel> \\o -> arms to the left
14:39:39 <boegel> o// -> arms to the right
14:39:46 <Pseudonym> boegel: If you have to explain it, it's no longer funny.
14:40:00 <boegel> Pseudonym: true, but he asked for it :p
14:40:47 <Aglarion> Ok... with my newly obtained knowledge on flushing IO streams, i will now try my first program that actually does something: XXO without AI...
14:41:23 <Pseudonym> Aglarion: Have you seen my tic-tac-toe program?
14:41:32 <Aglarion> no I haven't
14:41:37 * Darius is going to vacuum and think of how to implement ifte or why his implementation doesn't work.  Probably something to do with mutating list structure.
14:42:04 <Pseudonym> http://www.scannedinavian.org/iohcc/zeroth-2003/winners.html
14:42:16 <Aglarion> one question: does haskell use tail recursion? if yes, how do i get it working?
14:42:28 <Pseudonym> Hey!
14:42:36 <Pseudonym> Oh, it's my client.  Sorry.
14:42:52 <Aglarion> iohcc? clean haskell is already obfuscated enough for me...
14:43:11 <Leimy> haskell is obfuscated?
14:43:21 <Aglarion> Leimy: for a beginner...
14:43:30 <Leimy> there are worse things out there :)
14:43:34 <Pseudonym> Unfortunately, the formatting has been lost on the version on shapr's page.
14:43:38 <Lemmih> Aglarion: -O
14:43:51 <Leimy> Lemmih: is that you punching Aglarion ?
14:44:20 <arauko> that's true, there are worse things out there, i think it depends on your experience with other languages. haskell code seems pretty clean, (though i still study basic stuff)
14:44:21 <Pseudonym> You need to put a space at the start of the line on line 22 if you want to run it.
14:44:35 <monochrom> haskell is not intended to be obfuscated. but every Church-complete language can be abused for obfuscation.
14:45:03 <Aglarion> It was a joke... (just if you did not notice)
14:45:09 <arauko> :-)
14:45:31 <arauko> No, but you are right also, for a beginner might be a nightmare
14:45:46 <wli> Church-complete?
14:46:06 * arauko notices wli coming out from the darkness
14:46:12 <monochrom> On an imperative programming channel I would say Turing-complete.
14:46:39 <monochrom> And on a math channel, Kleene-complete. :D
14:46:53 <SyntaxNinja> haskell is beautiful!!
14:47:27 <wli> but
14:47:42 <wli> Turing AFAIK is the primary one responsible.
14:47:47 <Aglarion> SyntaxNinja: Maybe it becomes beautiful,one I have mastered the requirements to more than the simplest programs
14:48:27 <monochrom> I'll think about that.
14:49:45 <Pseudonym> Turing and Church were doing their stuff around the same time.
14:49:55 <Pseudonym> Turing is usually credited because his model is closer to a "real" machine.
14:50:10 <Leimy> I've been trying to find something to do with Haskell that makes sense... I was thinking of designing a small language to describe "build rules" then I realized I could probably implement an entire "ports system" in haskell
14:50:27 <Pseudonym> It was easier to believe that Turing machines do whatever a machine can.  It was harder to believe that about lambda calculus until their equivalence was proven.
14:51:58 <earthy> wasn't he earlier as well? with the entscheidungsproblem paper?
14:52:56 <arauko> Leimy, ports system?
14:53:09 <Pseudonym> Yeah. :-)
14:53:14 <Pseudonym> Whoops.
14:53:34 <arauko> Pseudonym, that is because lambda calculus is more abstract?
14:53:40 <Leimy> arauko: like FreeBSD ports... "dependencies, fetch, patch, build, install" stages of software
14:53:45 <Aglarion> it's funny, to see how german words are used in english speech. now i know how you would feel if you read german texts with anglicism in it
14:53:47 <Leimy> or "darwinports"
14:53:49 <arauko> Leimy, aah cool... 
14:53:51 <Leimy> which is in TCL
14:54:00 <arauko> Leimy, are you working on that?
14:54:07 <Pseudonym> Yes.  It was ahrder to visualise lambda calculus as representing "anything a machine can do".
14:54:08 <Leimy> arauko: mostly just daydreaming :)
14:54:10 <arauko> Leimy, seems an interesting project
14:54:11 <Leimy> no real plans yet
14:54:14 <Leimy> but I think it'd be fun
14:54:20 <Leimy> and complimentary to Yi and darcs
14:54:20 <arauko> yeah, it'd be fun
14:54:30 <Pseudonym> Ah, OK.
14:54:39 <arauko> Pseudonym, *nods*
14:54:42 <Leimy> I have not the skills to do it yet
14:54:48 <arauko> Leimy, hahah me ither
14:54:49 <Pseudonym> According to Wikipedia, Church was the first person who proved that there was an undecidable problem.
14:54:51 <arauko> either...
14:55:09 <arauko> Leimy, so we will have to talk about this within..mm.. 6 months?
14:55:10 <arauko> :-)
14:55:11 <Pseudonym> He later proved that lambda calculus and Turing machines had equivalent power.
14:55:11 <Leimy> but since Haskell is great for even prototyping other languages I think that it'd be really good for creating a "port" description language
14:55:31 <arauko> yeah.
14:55:34 <Leimy> arauko: well... It's going to take me a while to get the time and expertise in Haskell to do anything like that
14:55:40 <arauko> i actually thought about that idea with CL.
14:55:50 <arauko> though i never did anything.
14:55:50 <Leimy> CL is a really good choice for this too I think
14:56:02 <Leimy> since, in some ways, Haskell is still more "static" than Lisp
14:56:09 <Leimy> except that Yi gets around that
14:56:22 <Leimy> not sure I understand exactly how yet though :)
14:56:33 <arauko> Yi?
14:56:36 <SyntaxNinja> "static"?
14:56:40 <monochrom> It is easier to visualize and believe all those things about TM, but that's only because a large dose of handwaving and make-believing is allowed in visualization and believing.  A rigorous, formal proof is another story.  The situation with LC is reversed: it is more abstract, so it is harder to make-believe, but it is also easier to formally prove.
14:56:44 <Leimy> SyntaxNinja: less dynamic :)
14:56:54 <SyntaxNinja> as in the typing?
14:57:00 <sh10151> haskell has no setf
14:57:38 <Leimy> arauko: Yi is an editor system in haskell, it emulates vi and pico right now... people are working on Emacs.  All in Haskell
14:57:53 <Leimy> and the syntax description files can be "compiled in" "statically"
14:57:57 <shapr> Hear Yi, Hear Yi...
14:57:58 <Leimy> or can be loaded 
14:58:05 <Leimy> in a more dynamic way
14:58:15 <Leimy> SyntaxNinja: which is what I meant by "static" :)
14:58:29 <Leimy> shapr: aren't you working on Yi-Emacs mode? :)
14:58:34 <shapr> yes!
14:58:37 <Leimy> cool :)
14:58:44 <Leimy> I played with Yi about a month back
14:58:44 <shapr> But it's slow going because I am continually distracted.
14:58:48 <Leimy> shapr: likewise
14:58:52 <Leimy> I need to help with the Mac OS X port :)
14:58:59 <shapr> I started writing a keymap tutorial on my way towards a full emacs mode.
14:59:07 <Leimy> it didn't quite work last time I was on it.... had a few issues with the dynamic Haskell code compiler thingy
14:59:20 <Leimy> the fact that it can load haskell "source" and compile during loading is really nice IMO
14:59:33 <sh10151> i assume by emacs you just mean emacs keybindings?
14:59:40 <Leimy> sh10151: yeah 
14:59:42 <shapr> That's a requirement for elisp-quality dynamicism.
14:59:43 <Leimy> and behavior
14:59:49 * shapr wonders if dynamicism is a real word.
14:59:55 <Leimy> shapr: good enough for me :)
15:00:01 <sh10151> how is syntax highlighting done?
15:00:14 <Leimy> shapr: but that's what I like about Yi... it seems to stretch out what Haskell can do
15:00:18 <shapr> not at all right now, but several systems have been considered.
15:00:21 <sh10151> emacs regexp model is a little rough :)
15:00:28 <Leimy> sh10151: oh god yeah... 
15:00:36 <Leimy> it's downright ugly
15:00:48 <Leimy> but Yi works really well in vi mode IMO
15:00:53 <shapr> One of my goals for Yi is to have every mode be fully parser based.
15:00:55 <Leimy> and Pico mode works as well as I can remember to use Pico
15:00:59 <shapr> Then you can do parse tree macros
15:01:12 <sh10151> shapr: i was just thinking that. it does increase the barrier to entry though
15:01:20 <shapr> The downside of full parser based modes is that syntax highlighting can act strangely as you modify other parts of the code.
15:01:21 <sh10151> it's a lot easier to tweak emacs syntax handling
15:01:24 <Leimy> well I think doing it right is worth doing
15:01:24 <shapr> sh10151: I have a plan =)
15:01:29 <sh10151> just hard to avoid certain classes of bugs
15:01:29 <Leimy> Haskell is already a small community :)
15:01:39 <shapr> have you used visual-re-builder or just re-builder in emacs?
15:02:13 <Leimy> But i think a full packaging/porting system for other operating systems in Haskell is certainly doable.
15:02:34 <sh10151> i have used re-builder
15:02:40 <Leimy> I've just not decided how to go about it design-wise.
15:02:46 <shapr> In any case, re-builder gives you two buffers, a three lines tall buffer for the regex, and everything else for the 'interactive output buffer'
15:03:04 <shapr> As you change the regex, the matching groups are highlighted in the other buffer.
15:03:09 * boegel is going to bed, 'night everyone !
15:03:41 <shapr> I think that's the right way to do parser based modes. As you change the parser, it should show parsing results in another buffer.
15:03:54 <Leimy> night boegel 
15:04:00 <shapr> g'night boegel 
15:04:12 <shapr> word up Agent Ray
15:04:26 <shapr> btw, anyone know what "word up" actually means?
15:04:34 <CosmicRay> y0 shaprcycle
15:04:41 <shapr> I know that homeboy actually means "person from my home" or "neighbor"
15:04:42 <Leimy> that one band did that song "Word Up"
15:04:56 * wli looks at epoll
15:04:58 <Leimy> "what's going on"
15:04:59 * wli looks at ffi
15:05:01 <Leimy> tell me what's the word
15:05:03 <shapr> so "y0 homeboy" is actually ebonics for Ned's "Hidely Ho Neighbor!"
15:05:03 * wli boggles
15:05:04 <Leimy> "Word Up"
15:05:11 <CosmicRay> shapr: I don't know, it's from that mysterious thing called "pop culture" :-)
15:05:24 <Leimy> Microsoft Word to your mother!
15:05:27 * shapr laughs
15:05:28 <CosmicRay> haha
15:05:30 <shapr> Leimy: that's cruel
15:05:39 <Leimy> ice-ice Leimy
15:05:58 <MegaMonad> Shapr: right, but it will be garbage colleted. It's usually essential that you could make the .hs -> .hi tool a separate recursive function so i can't fix 'em.
15:05:59 <CosmicRay> shapr: I think I could understand 1890s London slang better than I could modern street slang.
15:06:19 <shapr> MegaMonad: great, now you tell me.
15:06:25 <MegaMonad> shapr: Musasabi: so *very* deep recursion is equivelant to applying arrays as functions of control.exception stuff and reduced prices on cokers.
15:06:42 <CosmicRay> MegaMonad: "reduced prices on cokers?"!!
15:06:42 <shapr> wow, da bot talks of unicycles.
15:06:42 <Igloo_> CosmicRay: I might have a vaguely working deflate if I can get the patch applied
15:06:47 <MegaMonad> CosmicRay: What would be able to get the variables that the prices would be useful to have good prices.
15:06:51 <CosmicRay> Igloo_: sweet
15:06:54 <shapr> A coker is a 36" wheeled unicycle.
15:06:58 <CosmicRay> ah.
15:07:07 <wli> Can I get a turkey walk through ffi'ing epoll?
15:07:07 <Leimy> shapr: whoah
15:07:13 <CosmicRay> see, there me sense of slang is awry again, I thought it sounded like drug stuff
15:07:20 <Leimy> shapr: the wheel is 36"?
15:07:23 <shapr> Leimy: http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
15:07:27 <Leimy> is that diameter or circumfrence
15:07:40 <shapr> At least it's not radius.
15:08:26 <Leimy> shapr: that would be huge!
15:08:33 <shapr> I don't really need a coker at the moment.
15:08:48 <shapr> It is very tall, yes. It's also very fast, and very smooth to ride.
15:09:08 <Igloo_> Ah, got it. Try pulling now?
15:09:20 <CosmicRay> Igloo: are you speaking to me?
15:09:24 <Igloo> Yup
15:09:28 <shapr> wli: foreign import ccall etc?
15:09:31 <CosmicRay> where should I be pulling from?
15:09:46 <Igloo> It's not deflating quite as I expected, but it managed to give a valid answer for about 10 0s
15:10:01 <CosmicRay> heh
15:10:03 <Igloo> http://urchin.earth.li/darcs/ian/inflate
15:10:27 <shapr> 404
15:10:30 <CosmicRay> jgoerzen@katherina:~/tree$ darcs get http://urchin.earth.li/darcs/ian/inflate
15:10:31 <CosmicRay> Copying patches...
15:10:31 <CosmicRay> .
15:10:31 <CosmicRay> darcs failed:  Failed to download URL http://urchin.earth.li/darcs/ian/inflate/_darcs/patches/20041223230329-3fd76-dda604f74afcbc7b98063c61c07eac97582ca977.gz
15:10:31 <CosmicRay> libcurl: HTTP error (404?)
15:10:51 <Igloo> Oh, I wonder if it screwed the permissions up
15:10:54 <CosmicRay> Igloo: you kick ass.  I didn't think you would actually do this. :-)
15:11:09 <shapr> Truly, Igloo kicks ass.
15:11:17 <CosmicRay> shapr: psst, I think igloo is a little insane to write a deflate in haskell... :-)
15:11:27 <Igloo> *sigh*m looks like mutt is a pain about such things too
15:11:37 <shapr> CosmicRay: many people might be insane to do that, but not Igloo.
15:11:45 <Igloo> :-)  I always intended to when I wrote inflate, just never got round to it
15:11:49 <CosmicRay> true enough
15:12:16 <Igloo> It feels very slow too. I think I need to look at my monad definition some time
15:12:26 <CosmicRay> Igloo: are you using lists of bools again?
15:12:31 <Igloo> Yes
15:12:39 <CosmicRay> Igloo: do you think that could be why? :-)
15:12:40 <shapr> I was on the same team with Igloo for ICFP two or three years back. I realized that I have a very long way to go to reach his level of skill.
15:12:54 * CosmicRay realizes that over irc :-)
15:12:54 <SyntaxNinja> 1337
15:13:11 <Igloo> I think something else is wrong too
15:13:26 <CosmicRay> hi SyntaxNinja 
15:13:43 <shapr> That's one reason I love this community, there are so many people that I can learn from.
15:14:03 * Darius tries purely functional implementations of the prims...
15:14:16 <Igloo> Hmm, my gf and I bought 16 ultra-cheap CDs yesterday, I think, and I've already run out
15:14:28 <Igloo> (hurrah for clearence sales!)
15:14:41 <shapr> Run out of what? Music to listen to?
15:14:49 <Igloo> Yeah
15:15:01 <Igloo> Oh, 18 CDs in 16 boxes
15:15:06 <Pseudonym> shapr: The Bolivian Navy has rules against the wearing of toupees while in the Southern Hemisphere.
15:15:11 <Pseudonym> See what you learn on #haskell?
15:15:19 <shapr> Do you know about the flac'd concerts on archive.org? or the full label releases on legaltorrents.com ?
15:15:23 <SyntaxNinja> hi CosmicRay
15:15:50 * CosmicRay benchmarks his ftp server
15:16:04 <shapr> Also, the mp3s on magnatune.com are free, only the CD-quality files cost money.
15:16:45 <shapr> gnomoradio, irate, and another client whose name I forget are good tools for finding quality legal free music.
15:17:30 <shapr> I can make a bunch of legal free music recommendations if you want pointers to stuff I enjoy.
15:18:09 <CosmicRay> 6MB/s
15:19:20 <shapr> Hey, have you seen Richard Braakman online lately?
15:19:36 * Igloo hasn't found a free track worth keeping online yet, so doesn't tend to look much
15:19:47 <Igloo> The problem is it's hard to search for what I want
15:19:51 <Igloo> s/want/like/
15:20:32 * Igloo ponders learning about DTDs and/or XML Schema
15:20:52 <shapr> what do you like?
15:21:41 * Igloo will answer that in a few days for complicated reasons  :-)
15:22:37 <Leimy> garrrr
15:22:45 <Leimy> I have to go to yon grocery store
15:22:55 <Leimy> Christmas food consumption is high!
15:23:02 <Leimy> bbl
15:28:31 <shapr> hiya monk0
15:30:00 * CosmicRay hates System.Time
15:30:13 <CosmicRay> too many different types and crap
15:30:39 <shapr> yeah, totally
15:30:42 <shapr> I want to switch to libtai
15:30:48 <Lemmih> CosmicRay: You can finish Marlow's proposal.
15:31:07 * shapr elects CosmicRay "guy most likely to finish things"
15:31:24 <CosmicRay> heh
15:31:33 * shapr elects himself "guy most likely to start things and then get distracted"
15:31:47 <CosmicRay> shapr: are you sure I'm not "guy most likely to finish things the wrong way"? :-)
15:31:48 * Pseudonym elects himself... oh, look, something shiny!
15:31:53 <CosmicRay> heh
15:31:55 * shapr snickers
15:32:00 <CosmicRay> Pseudonym: guy most likely to have adhd
15:32:03 <shapr> CosmicRay: running code is good code.
15:32:33 <shapr> I had ADHD once, but I forgot where I put it.
15:32:35 <Pseudonym> OK.  Here's what you doo.
15:32:45 <Pseudonym> I made a directory /home/groups/a/aq/aqsis/tmp
15:32:52 <Pseudonym> mv the file to that directory.
15:32:55 <Lemmih> CosmicRay: What have you finished so far?
15:33:03 <Pseudonym> You still can't delete it, but at least it's out of the htdocs tree.
15:33:06 <shapr> hej r3tex 
15:33:06 <CosmicRay> Lemmih: http://quux.org/devel/missingh
15:33:06 <Pseudonym> Whoops.
15:33:17 <sh10151> Igloo: learn about RELAX NG instead of schema or DTD :)
15:33:35 <r3tex> shapr: yo homey =)
15:33:53 <Igloo> Oh, OK, I'll take a look
15:34:03 * Igloo puts the XML Schema spec down  :-)
15:34:03 <CosmicRay> Lemmih: also I will be releasing, tomorrow, a virtual I/O infrastructure, modular FTP server, and TCP/IP server infrastructure
15:34:13 <shapr> r3tex: tja gubbe
15:34:18 * shapr wonders if that's close to y0 homey
15:34:27 <CosmicRay> Igloo: best to just rm it now, so you never accidentally pick it up again!
15:34:28 <CosmicRay> :-)
15:34:37 <r3tex> shapr: windows sucks =(( den skrev over min boot-sektor... doh
15:34:43 <shapr> yuck
15:35:01 <shapr> jag har en lÃ¶sning... anvÃ¤nder inte windows.
15:35:50 <CosmicRay> MegaMonad: could you translate that?
15:35:55 <MegaMonad> CosmicRay: I had to translate it to me, and i may not have a warning during package install time.
15:36:10 <Lemmih> "I have a solution... don't use Windows"
15:36:20 <CosmicRay> that's always worked well for me.
15:36:55 * wli ponders something less crappy than the WAM for LP semantics.
15:37:09 <shapr> wli: wha?
15:37:26 <Darius> wli: BAM
15:37:57 <wli> Darius: Haven't heard of the BAM. I want PTTP-like breadth-first semantics anyway so I'll have to chuck the normal stuff anyway.
15:38:02 <shapr> Lemmih: you read swedish well =)
15:38:32 <CosmicRay> @type mapM
15:38:33 <CosmicRay> @type mapM)
15:38:34 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
15:38:35 <CosmicRay> @type mapM_
15:38:35 <lambdabot> bzzt
15:38:36 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
15:39:34 * Igloo reads down the relax ng validator list and mutters at the language choices
15:39:35 <Lemmih> shapr: It's not very different from danish. "jeg har en loesning... anvaend ikke windows"
15:39:51 <Darius> wli: The BAM was described in Peter Van Roy's Master or PhD thesis.  You may also want to look at techniques for implementing Curry though they probably aren't less crappy depending on the metric.
15:39:57 <CosmicRay> GRRRFUME.  there is now a *fourth* time type, EpochTmie
15:40:10 <CosmicRay> that module *must* have come from Java.
15:40:27 <shapr> I think EpochTime has only a single value, right?
15:40:39 <shapr> What irritates me is that all the converters have IO return types.
15:40:44 <CosmicRay> that too
15:40:53 <shapr> That's why I'd rather use a libtai based time type.
15:40:55 <CosmicRay> no, it's the type of stuff on the FileStat structure in System.Posix.Types
15:40:59 <Maddas> shapr: Powerisers look fun too
15:41:01 <Lemmih> shapr: I think I almost got one-footing with my left foot.
15:41:02 <wli> Darius: well, it just makes sense for a particular command language
15:41:05 <Leimy> mapM_ is for when you don't need the result right?  And just want to do the transform.  Useful for IO?
15:41:19 <Maddas> If I'd listen to the recommendation, I'd have to get the "Kids Model", though ;-)
15:41:29 <shapr> how so? you don't weigh much?
15:41:32 <Maddas> Yup
15:41:40 <Maddas> (I'm small)
15:41:52 <shapr> I'd have to be careful of my weight just to use the largest model.
15:41:59 <Maddas> Heh :-)
15:42:57 <shapr> They max out at 100 kilos. I'm 93 right now, and was 107 not long ago.
15:44:25 <sh10151> Igloo: the java, c#, and C++ folk need the most handholding with this stuff :)
15:44:29 <shapr> Powerskips an Powerisers tempt me to find a gym with a trampoline so I can practice enhanced forward flips while I save up for the power stilts.
15:44:36 <Maddas> Did you find any further information comparing Powerskips with Powerisers?
15:44:36 <wli> well, the List monad handles depth-first-search semantics
15:44:38 <Igloo> heh
15:44:40 <sh10151> for validation I just use xmllint that comes with the gnome library
15:44:46 <Darius> Pure FP has saved my program!
15:44:48 <wli> so I need an analogue of the List monad that implements a queue
15:44:54 <wli> instead of a stack
15:44:57 <Igloo> I'd missed libxml2, which should be fine
15:44:59 <wli> or some such crap
15:45:02 <sh10151> wli: okasaki has it
15:45:18 <shapr> Maddas: nope, but I haven't looked very hard. Powerisers are half the price of Powerskips, even though powerskips appear to be superior.
15:45:35 <Maddas> Hm, right. The price is quite an issue there :-)
15:45:36 <Darius> wli:  That is pretty trivial, just write the same code as the List monad using a queue instead of a stack.
15:45:40 <Igloo> Ah, in libxml2-utils. Nifty, thanks!
15:47:00 <shapr> Maddas: plus, the details that make a difference to me are unlikely to be online. I really want CAD models of both, and spring ratings for both so I can figure out which is most powerful and most efficient.
15:47:03 <wli> Darius: possible though uniqueness is wanted
15:47:21 <shapr> All of these powerstilts are based on the kangaroo's powersaving cruise mode.
15:47:30 <Maddas> heh, yeah, spring ratings would be nifty :-)
15:47:40 <Maddas> eh
15:48:03 <wli> Darius: and sublinear-time insertion...
15:49:05 <shapr> Kangaroos are very efficient long distance travelers. They have a head down tail up posture that allows their legs to absorb, store, and rerelease nearly all the downard energy.
15:49:22 <Maddas> Cool.
15:49:28 <Pseudonym> That's true.
15:49:32 <wli> Darius: any thoughts on that?
15:49:40 <Pseudonym> There was an old SIGGRAPH paper on precisely that topic.
15:49:50 <Maddas> sublinear-time insertion or Kangaroos?
15:49:52 <Darius> The latter can be done. Do most logic languages do the former in general?
15:49:57 <Pseudonym> www.cs.princeton.edu/courses/ archive/spring01/cs598b/papers/raibert91.pdf
15:50:06 <wli> Darius: depth-first-search? yes
15:50:13 <Maddas> (I guess that was a silly question, sorry)
15:50:23 * shapr is wondering the same thing
15:50:30 <Pseudonym> Kangaroos.
15:50:33 <Maddas> Oh, cool :-)
15:50:36 <Darius> wli: Not searching duplicate branches.
15:50:49 <wli> Darius: No, most don't try to prune that way.
15:51:04 <Pseudonym> BTW, all the data is in the paper.
15:51:12 <Pseudonym> Why not simulate a kangaroo in Haskell?
15:51:43 <Maddas> Whoa, that's definitely one paper to keep :-)
15:51:58 <Pseudonym> Yeah, it's a very cool paper.
15:52:22 <Pseudonym> A particularly interesting bit is that their models actually seem to model the real kangaroo extremely well.
15:52:28 <Maddas> Heh, is there any research hat /isn't/ "supported by contracts from DARPA [...]"? :-)
15:52:32 <Maddas> That, even.
15:52:44 <Pseudonym> Maddas: Yess, some is supported by the Department of Energy.
15:52:52 <shapr> Truly, DARPA is a good thing.
15:52:53 <sh10151> sociological research I would imagine
15:53:00 <Maddas> Heh :-)
15:53:10 <shapr> DARPA gave us the space shuttle among many nifty results.
15:53:34 <wli> The US Navy funded a bunch of crap on direct numerical methods for the calculus of variations.
15:53:50 <shapr> Did it help?
15:54:03 <Pseudonym> Do you guys know the story about zero-knowledge proofs?
15:54:11 <wli> shapr: there were post-Hestenes numerical methods that came out IIRC.
15:55:03 <wli> None of them is anywhere near as influential or commonly-used as Hestenes' methods (which says something given that they're 50+ years old)
15:55:13 <Pseudonym> Adi Shamir (the "S" of RSA) invented a technique for zero-knowledge proofs.
15:55:30 <Pseudonym> The idea is that I know the proof of some theorem, and I want to convince you that I know it, but I don't want to tell you the actual proof.
15:55:49 <shapr> I read about a neat zero knowledge proof that uses color patterns.
15:55:53 <Pseudonym> He worked out a way to do it cryptographically.
15:56:11 <Pseudonym> And, of course, if you put it on a smart card, you have an uncopyable identity card.
15:56:15 <shapr> Isn't the Windows NT CHAP a zero knowledge proof?
15:56:17 <wli> graph isomorphism?
15:56:39 <Pseudonym> The US Army decided they liked that idea, so they ordered that all copies of Shamir's paper be turned over.
15:56:54 <Pseudonym> Needless to say, the scientific community was not happy.
15:57:01 <wli> of course, Shamir wasn't a US citizen, so he merely published elsewhere, no?
15:57:01 <CosmicRay> bwahahaha
15:57:01 <shapr> CHAP - challenge handshake authentication protocol
15:57:02 <CosmicRay> it works.
15:57:04 <Pseudonym> Right.
15:57:10 <Pseudonym> Shamir was an Israeli citizen.
15:57:13 <Pseudonym> So they backed down.
15:57:25 <Pseudonym> But it's still a bit scary.
15:57:36 * Darius had a paper from a bit back about how to hide information from an oracle.
15:57:38 <wli> IIRC they didn't back down until later
15:57:42 <shapr> Merkle's puzzles allow for a probabilistic secure channel over insecure
15:57:57 <wli> and threatened Shamir with various things after he published it in some other country...
15:58:09 <wli> (probably .il)
15:58:29 <Pseudonym> Yeah, something like that.
15:58:33 <Pseudonym> It's a bizarre story, anyway.
15:58:45 <shapr> The US has some great stuff like DARPA and the DoE, but equally stupid stuff like the DMCA.
15:58:45 <wli> Pseudonym: not terribly uncommon
15:59:14 <shapr> I am a US Citizen, and I love my country. It still isn't 100% perfect though.
15:59:25 <Pseudonym> The trouble with getting your funding from DARPA is that they can do that.
15:59:34 <Pseudonym> If you don't turn over your research, you lose funding.
15:59:36 <wli> Pseudonym: word is Amerikkka uses terror tactics on various citizens who try to renounce their citizenship.
15:59:50 * Pseudonym is aware of that second-hand
15:59:53 <wli> Pseudonym: not physical violence but legal/financial/etc.
15:59:56 <Pseudonym> I know someone who tried it.
16:00:01 <Pseudonym> And they ask all sorts of questions.
16:00:14 <shapr> I wish all tax funded research were made public.
16:00:29 <shapr> In every country.
16:00:32 <CosmicRay> how's this for a full FTP server....
16:00:39 <CosmicRay> main = do
16:00:46 <CosmicRay>        let opts = (simpleTCPOptions 12345) {reuse = True}
16:00:46 <CosmicRay>        serveTCPforever opts $
16:00:46 <CosmicRay>             threadedHandler $
16:00:46 <CosmicRay>             loggingHandler "" INFO $
16:00:46 <CosmicRay>             handleHandler $
16:00:47 <CosmicRay>             anonFtpHandler (HVFSReadOnly SystemFS)
16:01:00 <Pseudonym> All you need to do, though, is serve in a foreign millitary or stand for public office in a foreign country.
16:01:08 <Pseudonym> You do that, you implicitly renounce your citizenship.
16:01:16 <wli> Pseudonym: only a few hundred ppl each year successfully get rid of their Amerikkkan tax burdens, most of whom are foreign citizens returning to their home countries.
16:01:40 <wli> 90% of which or some such
16:01:58 <Pseudonym> If you want to be no longer a US citizen, the best thing you can do is act like it and keep your head low.
16:02:11 <wli> yes
16:02:32 <shapr> I don't have to pay taxes in the US.
16:02:41 <wli> yes
16:02:46 <wli> it's income over some limit
16:02:53 <shapr> oh
16:02:59 <shapr> Not a problem :-)
16:03:05 <wli> that will be doubletaxed
16:03:19 <Pseudonym> You know the most bizarre thing.
16:03:21 <CosmicRay> obviously too much code :-)
16:03:27 <shapr> CosmicRay: looks nice to mee
16:03:31 <Pseudonym> Income tax is only about 15% of the US government money intake.
16:03:37 <wli> there are other doubletaxation situations most of which are temporary anyway
16:03:39 <Pseudonym> And about 100% of that goes to servicing the debt.
16:03:51 <CosmicRay> thanks shapr
16:03:59 <arauko> what's wrong with this = my_square a = (\x -> x * x) a ?
16:04:00 <Pseudonym> So it's not even like your (federal) taxes are doing anything productive.
16:04:12 <Darius> CosmicRay: If you make a function ftpServer that equals main, then you can shorten that to main = ftpServer.
16:04:17 <shapr> US national debt is a bizarre thing, it seems to me like it's designed to put free money in someone's pocket.
16:04:20 <wli> Pseudonym: They're killing innocent ppl.
16:04:32 <Pseudonym> wli: No, money for that comes from elsewhere.
16:04:34 <Darius> arauko: What -is- wrong with it?
16:04:35 <wli> shapr: it's being embezzled en masse
16:04:43 <Pseudonym> Tariffs, patent fees, charges etc.
16:04:46 <arauko> Darius, can i run that on ghci ?
16:04:47 <CosmicRay> Darius: there are some variables there, such as: 1) what port to listen on, 2) what exactly are you serving, 3) how to log
16:04:48 <Pseudonym> Corporate tax, I think.
16:04:50 <shapr> wli: it does appear that way from the stuff I've read.
16:05:19 <Darius> arauko: You can try and find out.
16:05:26 <Pseudonym> Income tax goes to paying interest on the national debt.
16:05:26 <CosmicRay> Darius: these threadedHandler stuff are SocketServer combinators, basically
16:05:35 <arauko> Darius, it gives this : <interactive>:1: parse error on input `='?
16:05:37 <Darius> Except GHCi only handle expressions not declarations.
16:05:41 <arauko> without ?
16:05:56 <arauko> Ah.
16:05:57 * CosmicRay will brb
16:06:26 <Darius> arauko: Since GHCi interprets the top-level as if it were in a big do statement, you can do let my_square a = ...
16:06:33 <Pseudonym> BTW, if any US government officials are reading the logs of this channel, I'd like to send them a big "hello", and would like to point out that I do not wish the US government, public officials or citizenry any ill-will whatsoever.
16:06:52 <Pseudonym> I hope they all live long, happy and fruitful lives.
16:07:06 <Darius> Would that they would.
16:07:15 <wli> Unclear by whom or if there's any kind of coordinated action, who's doing it, or how many ppl are doing it.
16:07:27 <Riastradh> Pseudonym, don't forget a theistic reference!
16:07:36 <Pseudonym> Yes.  God bless America!
16:08:02 <arauko> Darius, ah, thanks
16:08:05 <Pseudonym> (Except that I believe the ACLU recently got an injunction against God.  I'm not sure he's allowed to bless America until the Supreme Court case is decided.)
16:08:06 <shapr> I'm sure the NSA is already reading this.
16:08:35 <SyntaxNinja> is God what they call a non-state actor?
16:08:37 <shapr> And thinking "these guys are about as dangerous as a taco stand at the north pole"
16:08:40 <Pseudonym> Could be.
16:08:53 <Pseudonym> shapr: Precisely.
16:09:20 <Pseudonym> But just in case the Federal Police come knocking at my door, I'd like the disclaimer in the official record.
16:09:33 <Pseudonym> It only takes one humourless loony to report you.
16:10:01 <shapr> It would take a lot of humourless loonies to decide that any of our discussions are dangerous in any way.
16:10:28 <Pseudonym> Death to all Visual Basic programmers!
16:10:33 <Riastradh> I'm going to report you guys for insulting me and saying I lack humour and that I'm a loony!
16:10:38 <shapr> C'mon, we can't even revolt against the bunch of clueless managers who decide to use Java and C++
16:10:47 <wli> So, any idea on getting epoll stuff via the FFI?
16:10:53 <shapr> What's epoll?
16:10:58 * shapr asks apt-cache
16:11:03 <Pseudonym> wli: That sounds like an on-topic discussion.
16:11:23 <wli> shapr: Linux system call
16:12:09 <shapr> I guess at worst you could write a C lib that calls it, and wrap that via the FFI
16:12:24 <shapr> I dunno if there's a more direct way, I don't know much about the FFI.
16:12:30 <arauko> im tryng to understand this code: let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l , something i don't grasp at is, the lambda function shouldn't take two arguments? x and c, i only see passing one argument.
16:12:56 <wli> shapr: that's pretty much the idea
16:14:25 <sh10151> i don't care so much about managers picking java or c++ or whatever
16:14:34 <sh10151> I care more about managers not managing
16:14:51 <sh10151> you know, talking to customers, ensuring that requirements are documented and met
16:15:09 <shapr> arauko: if you have a function that takes two args and evaluates to one result, you can generalize that across a list by making something that takes a given first arg and the first item from the list, and then uses the result of that with the second item of the list, etc
16:15:32 <sh10151> seems to me being a good manager means being able to delegate responsibility while absorbing credit
16:15:38 <shapr> arauko: for example, foldr (+) 0 [1,1,1]
16:15:50 <shapr> arauko: plus takes two args, gives one result.
16:16:10 <Darius> arauko: The arguments that are passed to the lambda abstraction are passed to it inside the foldr, perhaps viewing it this way may help 'count p l = (foldr (\x c -> if p x then c+1 else c)) 0 l'
16:16:28 <shapr> I think a good manager is the ultimate waterboy, they run interference for the guys who get the actual work done.
16:16:54 <wli> shapr: tricky part is translating the syscall ABI to Haskell, as it involves data structures
16:17:36 <shapr> greencard has some neat tricks for that, or you could use some of the Ptr/ForeignPtr stuff in the FFI.
16:17:44 <shapr> that's the limit of my knowledge.
16:19:22 <arauko> Darius, shapr, i stll don't see the correspondence of x and c , which value is x?, the list? and c?
16:19:34 <Darius> @type foldr
16:19:36 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
16:20:58 <Darius> Okay shapr.  What's a good email address to send this Joy stuff?
16:21:13 <arauko> Darius, well, according to that, x would be 0 and c would be the list?
16:22:10 <Darius> @type \p l -> foldr (\x c -> if p x then c+1 else c) (0 :: Int) l
16:22:12 <lambdabot> \p l -> foldr (\x c -> if p x then c+1 else c) (0 :: Int) l :: forall a
16:22:12 <lambdabot> 							       (a -> Bool) -> [a] -> Int
16:22:41 <monochrom> the function you give to foldr is supposed to take two arguments.  "binary operator"
16:23:18 <arauko> monochrom, exactly...
16:23:24 <Darius> arauko: foldr plays with it's parameters more than that.
16:23:25 <monochrom> x will be an item in the list.  c will be a number.
16:23:39 <arauko> monochrom, swhich numbers?
16:23:43 <arauko> number*
16:23:58 <monochrom> it may be 0. it may be c. it may be c+1
16:24:36 <arauko> c+1 wouldn't be an error?
16:24:44 <arauko> i mean, c doesn't have value
16:25:10 <arauko> haha, i just don't see where c gets a numerci value to sum
16:25:17 <monochrom> I wish to confuse you with a simpler example of using foldr.  foldr (\x c -> c+1) 0 "abcdefg"  -- this will give you 7, the length of "abcdefg".
16:26:16 <monochrom> My example cares about just the length, so I don't care about the items themselves, so in (\x c -> c+1) I don't use x.
16:26:32 * Darius pokes shapr.
16:26:58 <monochrom> I can trace my example if you want.
16:27:24 <shapr> oh, shae@scannedinavian.com
16:27:27 <arauko> Please.
16:27:33 <monochrom> I will trace foldr (\x c -> c+1) 0 "ab" instead because that is less work.
16:27:34 <arauko> i'd appreciate it
16:27:39 <arauko> ok
16:27:40 <shapr> and if you tell me your address of origin, I'll whitelist you so you don't see the TMDA bounce
16:28:15 <Darius> shapr: ddarius@hotpop.com
16:28:31 <monochrom> (\x c -> c+1) 'a' (foldr (\x c -> c+1) 0 "b")
16:28:47 <monochrom> (foldr (\x c -> c+1) 0 "b") + 1
16:28:58 <shapr> Darius: ok
16:29:18 <monochrom> ((\x c -> c+1) 'b' (foldr (\x c -> c+1) 0 "")) + 1
16:29:36 <monochrom> ((foldr (\x c -> c+1) 0 "") + 1) + 1
16:29:50 <monochrom> (0 + 1) + 1
16:29:53 <monochrom> 2
16:30:37 <monochrom> I have some places where I need more parentheses.  But I hope you get the idea.
16:31:00 <monochrom> Oh haha I don't need more parentheses. It's all correct.
16:31:44 <Darius> shapr: It's sent.  To run it you should only need the jar and jad file.  I've only tested on Nokia Series 40 emulator.
16:31:51 <shapr> cute title
16:31:52 * shapr snickers
16:31:58 <monochrom> You can think of c as a counter, 0 as its initial value.
16:32:23 <arauko> yeah, im grasping at it 
16:32:46 <Darius> shapr: On a real phone it's probably a nightmare to use, and I haven't changed it to use . and , or be configurable so...
16:33:29 <Darius> shapr: No standard library or persistency yet either.  And no combinators that would make it really interesting.
16:34:14 <Pseudonym> http://thankpoland.info/
16:34:29 <Darius> arauko: Well foldr is called foldr because it "folds" an operator Right associatively into a list, so e.g. foldr (+) 0 [1,2,3,4] => 1+(2+(3+(4+0)))
16:35:34 <monochrom> I have to go, so I will answer a question you will ask in the near future.
16:35:45 <arauko> monochrom, Thanks indeed.
16:35:52 <SyntaxNinja> what's this inflate and deflate business, anyway, Igloo?
16:35:54 <Darius> shapr: Oh and if I haven't mentioned it before, the parser for the code is steaming garbage as far as efficiency is concerned.
16:36:06 <arauko> i will re-read this log
16:36:48 <monochrom> You look at my trace and see (0+1)+1 and you may ask "why is it not 1+(1+0) as Darius says?"  The reason is in (\x c -> c+1) and it reverses the order.  If you have (\x c -> 1+c) instead, it will match Darius's predication perfectly.
16:37:32 <Darius> shapr: If you can't get it onto a phone somehow you could get a phone emulator (i.e. the Series 40 SDK at forums.nokia.com or maybe forum; requires (free) registration though)
16:38:15 <arauko> Darius, monochrom Aaaahh
16:38:20 <arauko> Darius, monochrom haha, get it
16:38:29 <arauko> Thanks guys
16:39:03 <Igloo> SyntaxNinja: It's what gzip, amongst other things, uses
16:39:05 * arauko still thinks too procedural
16:39:13 <Darius> arauko: Another way to understand foldr that generalizes quite a bit is that foldr cons nil replaces (:) with cons and [] with nil (a list [1,2,3] is 1:2:3:[])
16:39:41 * Philippa likes that explanation
16:39:44 <arauko> yeah, i understood it that way, but i don't why, your previous explanation made it clearer to me.
16:40:41 <Darius> arauko: Following this you get folds for, for example, trees, data Tree a = Leaf a | Branch (Tree a) (Tree a)  foldTree leaf branch (Leaf a) = leaf a;foldTree leaf branch (Branch l r) = Branch (foldTree leaf branch l) (foldTree leaf branch r)
16:41:36 * arauko scrtaches his head.
16:41:38 <Darius> Lining that up will ake it easier to read.  If you look at the definition of foldr it can be written just like that.
16:53:02 <Darius> shapr: If you do get it working on a real phone I'd be interested to know.
16:53:29 <shapr> I'm not sure my 6310i is Series 40, but I'll see what I can do.
16:54:30 <monk0> [(1,2),(2,3)] => [1,2,2,3] , how ?
16:57:03 <Darius> \[(1,2),(2,3)] -> [1,2,2,3]
16:59:02 <Darius> shapr: I think pretty much all Nokia phones are Series 40, and I'm pretty certain I didn't use anything Nokia specific so it should work on anything supporting at worst MIDP 2.0 and CLDC 1.1 and probably doesn't even require that.
17:20:52 <Pseudonym> @wiki ConcreteView
17:20:53 <lambdabot> http://www.haskell.org/hawiki/ConcreteView
17:22:27 <CosmicRay> MegaMonad: y0 dude!  what's happening?
17:22:33 <MegaMonad> CosmicRay: Dude i don't like getting 0 for the color/contrast stuff, it just isn't happening.
17:22:38 <CosmicRay> hah
17:22:45 <CosmicRay> MegaMonad: have you ever seen Office Space?
17:22:51 <MegaMonad> CosmicRay: I to do that for me to be a space in the office.
17:23:06 <CosmicRay> MegaMonad: It's a movie.
17:23:08 <thebug> MegaMonad: Have you ever enjoyed a nice, heaping plate of 'taters and pie?
17:23:11 <MegaMonad> CosmicRay: Its in a movie, maybe i need that for a movie-science master's.
17:23:17 <MegaMonad> thebug: Bit i is the license plate of the a in it?
17:23:24 <CosmicRay> heh
17:23:30 <CosmicRay> MegaMonad: apple pie is the best.
17:23:37 <MegaMonad> CosmicRay: Apple pie is the common people.
17:23:39 <psi> MegaMonad: i need those tps reports!
17:23:43 <thebug> that was a bit less coherent than its anwsers to you ;)
17:23:44 <MegaMonad> psi: Did you post timings with and got about that when it fails to get the type you think it can be instantiated for both "list"s and "binary tree"s, and the bug reports.
17:23:57 <thebug> MegaMonad: perhaps you missed the memo?
17:24:02 <MegaMonad> thebug: One doing nothing anyway.  What am i reading that and prove me wrong with it, and apparently missed a better way to get the memo.
17:24:04 <CosmicRay> thebug: it's probably never heard of pie before tonight...
17:24:07 <CosmicRay> heh
17:24:15 <CosmicRay> thebug: did you GET that memo?
17:24:23 <CosmicRay> err
17:24:27 <CosmicRay> MegaMonad: did you GET that memo?
17:24:34 <MegaMonad> CosmicRay: Nah, it's that i want memo in package wxhaskell-ghc6 are really two paths to mysql.hsc and ui.hs for the hls (which would duplicate it) or the one i'm referring to me like it's just me.
17:24:43 <CosmicRay> MegaMonad: I think I'm going to have to, yeah, go ahead and have you come in, yeah, tomorrow.
17:24:48 <thebug> nope, it was a POST memo
17:24:48 <MegaMonad> CosmicRay: Yeah if you plan ahead.
17:24:54 <CosmicRay> heh
17:25:19 <thebug> MegaMonad: cookies are also tasty to eat with pie
17:25:25 <MegaMonad> thebug: Also if you eat out of the clean uniqueness type corpses are tasty.
17:25:27 * Pseudonym would appreciate a proofread of that wiki page
17:25:31 <thebug> ! !
17:25:38 <CosmicRay> MegaMonad: but the best option, of course, is ice cream.
17:25:43 <MegaMonad> CosmicRay: The recent announcement of the course of the code looks like an ice cream.
17:25:49 <CosmicRay> heh
17:25:55 <thebug> do I sense a theme? ;)
17:26:05 <CosmicRay> heh
17:26:12 <CosmicRay> MegaMonad: is there a theme?
17:26:18 <MegaMonad> CosmicRay: If that's possible make a region at the same theme.
17:26:20 <Philippa> MegaMonad: is there an IceCream monad?
17:26:27 <MegaMonad> Philippa: A monad is a monad. The monad is a command...
17:26:52 * Philippa laughs
17:27:02 <Philippa> it's probably /me/ it took the pattern for that from...
17:27:24 <Pseudonym> Disturbingly, I misread that as "The monad is a comonad..."
17:27:25 <CosmicRay> hah
17:27:45 <Pseudonym> I thought MegaMonad has discovered a contradiction in category theory for a moment there.
17:28:08 <Darius> Pseudonym: Promulgating superfluous parens
17:28:10 <wagle> iscream >>= uscream >>= weallscream == iscream
17:28:39 <wagle> monad thaws?
17:28:44 <CosmicRay> heh
17:31:28 <Darius> @wn converse
17:31:34 <lambdabot> *** "converse" wn "WordNet (r) 2.0"
17:31:34 <lambdabot> converse
17:31:34 <lambdabot>      adj 1: of words so related that one reverses the relation denoted
17:31:34 <lambdabot>             by the other; "`parental' and `filial' are converse
17:31:34 <lambdabot>             terms"
17:31:36 <lambdabot>      2: turned about in order or relation; "transposed letters"
17:31:38 <lambdabot>         [syn: {reversed}, {transposed}]
17:31:40 <lambdabot>      n : a proposition obtained by conversion
17:34:37 <ibid> CosmicRay: how much memory is MegaMonad using?
17:34:53 <CosmicRay>   PID USER      PR  NI  VIRT  RES  SHR S PU %MEM    TIME+  COMMAND
17:34:53 <CosmicRay>  4021 jgoerzen  25   0  573m 572m 1516 S  0.0 64.7  39:40.62 megahal
17:34:59 <ibid> ugh
17:35:02 <CosmicRay> yeah
17:35:07 <ibid> mine is below 200 megs virtual
17:35:16 <Pseudonym> OK, this paper is cool.
17:35:30 <ibid> MegaMonad: how do you feel about being such a memory hog?
17:35:32 <CosmicRay> -rw-r--r--  1 jgoerzen jgoerzen 164M Dec 23 19:29 megahal.brn
17:35:36 <MegaMonad> ibid: Well, memory could be a hog, but it's hideous for int.
17:35:41 <CosmicRay> heh
17:36:09 <Darius> Pseudonym: This paper?  The Ralf Hinze paper?
17:36:12 <Pseudonym> http://www.informatik.uni-bonn.de/~ralf/publications.html#work
17:36:17 <Pseudonym> Typed Quote/AntiQuote
17:36:24 <Pseudonym> It's a different paper.
17:43:10 <shapr> hysterically funny email .sig --> 99th Explosive Ordnance Disposal Flight Nellis AFB, NV -  "If you see me running, try to catch up" 
17:43:35 <ibid> MegaMonad: who is shapr?
17:43:41 <MegaMonad> ibid: Shapr stabs zope.
17:43:47 <ibid> :)
17:43:53 * shapr laughs
17:45:44 <shapr> ok, this is really funny - http://www.geocities.com/combatunicycle/index.html
17:48:49 <shapr> salut paf 
17:49:23 <Darius> The Psychology section is the best.
17:49:34 <CosmicRay> haha
17:49:37 <CosmicRay> I like the parachute drop
17:51:11 <arauko> When i make usage of 'data', like: data List a b c = List a b c , List becomes in a data type exactly like Integer?
17:51:23 <paf> shapr: salut
17:52:04 <Darius> arauko: More like List or Maybe (type constructors) but basically yes for a very loose definition of 'exactly'
17:52:14 <Philippa> arauko: pretty much - you might like to think of Integer as data Integer = 0 | 1 | ...
17:52:26 <arauko> Thanks Darius & Philippa
17:52:46 <thebug> MegaMonad: what do you think of Smalltalk and like languages, such as Objective C ?
17:52:51 <MegaMonad> thebug: Because objective c would be a little smalltalk.
17:53:15 <sh10151> haha
17:53:22 <Darius> Smalltalk and Objective C are alike?
17:53:28 <arauko> thebug, obj-c is nice (better imh than C++) , but it lacks a good stdlib
17:53:30 <sh10151> who knew?
17:53:37 <arauko> Darius, yes
17:53:50 <sh10151> arauko: depends, if you take Apple as the stdlib provider, it has a pretty comprehensive one :)
17:54:03 <sh10151> if you shun NS* classes, you are out of luck :)
17:54:12 <arauko> sh10151, yes, sorry, i wanted to mean that it doesn't have anything good for free software
17:54:22 <Leimy> libFoundation is a project being worked on at opendarwin.org
17:54:31 <Leimy> to provide a better cross platform Objective-C runtime
17:54:35 <sh10151> is gnustep still stagnant?
17:54:41 <Leimy> but I don't know how far Landon has gotten
17:54:42 <sh10151> i tried it about 3 years ago
17:54:47 <Leimy> GNUStep is still interesting
17:54:49 <Leimy> but GPL :)
17:54:51 <CosmicRay> sh10151: I don't think it's been stagnant for ages
17:55:01 <stepcut> vroom!
17:55:14 <Leimy> GNUStep just had some new updates like last month
17:55:26 <Leimy> I don't think it's fair to call it stagnant :)
17:55:27 <sh10151> I am totally conflicted about general client side technologies
17:55:42 <sh10151> since anything I do there would be on a hobbyist basis
17:55:52 <sh10151> right now my main machine is an OS X laptop
17:55:59 <sh10151> I used to run FreeBSD as a primary OS
17:56:07 <CosmicRay> I am not conflicted.
17:56:08 <CosmicRay> they all suck
17:56:12 <CosmicRay> so I choose the OS I like.
17:56:21 <CosmicRay> out of the festering heap of sucky OSs that we have today.
17:56:29 <sh10151> CosmicRay: I know THAT, but given that they all suck, what to do?
17:56:32 <CosmicRay> heh
17:56:37 <CosmicRay> hold your nose and use Linux? :-)
17:56:42 <sh10151> write web apps, since I am getting good at them from work?
17:56:46 <CosmicRay> heh
17:56:52 <CosmicRay> actually, I use KDE.
17:57:03 <CosmicRay> It is the best integrated environment available for linux
17:57:13 <sh10151> write things using Qt, Tk, or some other random crossplatform toolkit that isn't great in OS X?
17:57:15 <CosmicRay> MacOS X is nice but has numerous annoying flaws that prevent me from really using it
17:57:22 <CosmicRay> sh10151: what about Wxwidgets?
17:57:28 <sh10151> write Cocoa because Objective-C is pretty nice and I like Macs?
17:57:44 <Riastradh> CosmicRay, such as?
17:57:55 <sh10151> I can't even decide on a LANGUAGE let alone a GUI toolkit
17:58:09 <sh10151> haskell, common lisp, objective-c, java
17:58:17 <sh10151> python
17:58:23 <sh10151> those are the big 5 for me right now
17:58:30 <Riastradh> sh10151, there's any question there?
17:58:37 <sh10151> python and java could cross over at work, the rest can'[t
17:58:40 <shapr> obviously Haskell
17:58:44 * shapr grins
17:58:47 <CosmicRay> Riastradh: the spinning disc of death; the lack of customizability of the user interface; the general sluggish performance of the system; the strange filesystem semantics; the lack of source code to the entire system; the lack of support for openoffice; etc.
17:58:48 <sh10151> obviously :)
17:59:01 <shapr> Well, it is the #haskell channel...
17:59:06 <CosmicRay> sh10151: python is decently supported on the mac, by default even.
17:59:12 <sh10151> unfortunately I am not running Debian Linux which seems to be the preferred haskell environmenty
17:59:20 <CosmicRay> Riastradh: the lack of decent terminal emulation by default; the presence of vi in the defaul install...
17:59:20 <Leimy> I don't want to customize the UI
17:59:32 <Leimy> OpenOffice sucks
17:59:32 <sh10151> CosmicRay: I have no doubt that I could use python or jython for just about everything
17:59:38 <shapr> I don't think there really is a preferred environment.
17:59:44 <CosmicRay> I am completely sick of white, red, green, gray, and blue.
17:59:45 <shapr> Wolfgang Thaller uses OSX
17:59:50 <Leimy> there is enough source to do interesting things :)
17:59:50 <sh10151> but I am envious of SLIME for CL and Eclipse for Java
18:00:09 * Darius imagines CosmicRay's desktop yellow on black.
18:00:09 <Leimy> I don't understand what you mean by strange filesystem semantics
18:00:10 <sh10151> I would like SPYME or something
18:00:15 <Leimy> or sluggish performance :)
18:00:18 <CosmicRay> heh
18:00:18 <Riastradh> CosmicRay, the spinning beach ball of death has been gone since years ago; it is better to be consistent than everything to be flexible in very different ways; I haven't found the system to be sluggish at all; I'm not sure what strange filesystem semantics you're referring to; if the source code were available, Apple couldn't have made any profit; that's not the fault of OS X but the OpenOffice developers.
18:00:20 <shapr> I think there's a lot of Debian users on #haskell, that's all.
18:00:28 <sh10151> or SHAME
18:00:39 <sh10151> Superior HAskell Mode for Emacs
18:00:41 <CosmicRay> the spinning bal of death is less present but it is still there.
18:00:47 <Leimy> sh10151: does that exist?
18:00:52 <CosmicRay> KDE is consistent and flexible at the same time.
18:00:55 <sh10151> no, it should
18:01:02 <Leimy> KDE is a nightmare :)
18:01:04 <sh10151> but people are wasting time on projects like Yi ;)
18:01:05 <Riastradh> I just use rxvt; and both Emacs and vi are present in the default install.
18:01:06 <CosmicRay> compared to linux on the same powerpc hardware, os x is noticably more sluggish
18:01:13 <Leimy> it has more dependencies than GNOME :)
18:01:14 <CosmicRay> Riastradh: I know, the vi thing was a joke :-)
18:01:17 <sh10151> I did a quick hack for haskell-mode
18:01:21 <CosmicRay> Leimy: feh, apt-get handles it all :-)
18:01:26 <Leimy> CosmicRay: true
18:01:31 <Riastradh> Show me Expose in KDE, CosmicRay, and show that it's not sluggish.
18:01:39 <Leimy> Linux on the same powerPC hardware is unstable and crap
18:01:40 <Leimy> at best :)
18:01:43 <sh10151> that uses ghci to determine the type of an expression, even when not declared in the source file
18:01:47 <sh10151> but it is a quick hack
18:01:52 <Riastradh> Ah, supper just arrived.
18:01:52 <CosmicRay> Riastradh: KDE doesn't have it, but then I don't care.  I do my file management in bash, not some gui.
18:02:02 <CosmicRay> I am far faster with bash than I am with any gui file manager.
18:02:02 <sh10151> I would like a nice interface to ghci in Emacs
18:02:10 <Leimy> sh10151: it works... I use Haskell mode and it does a nice job finding types of expressions IMO
18:02:12 <sh10151> but that entails programming elisp!
18:02:23 <sh10151> and both Yi and Eclipse dishearten me for that project
18:02:29 * Leimy likes QuickSilver :)
18:02:30 <CosmicRay> oh alos, here's a nit.  Why does Apple Mail, which is without a doubt the best GUI mail reader I've ever seen, make it so damn hard to use gpg in a decent fashion?!!
18:02:45 <sh10151> Leimy: for things you have already declared, or Prelude functions, sure :)
18:02:45 <Leimy> CosmicRay: doesn't PGP work? :)
18:02:59 <shapr> sh10151: so, jump in and work on one of them.
18:03:00 <sh10151> it would also be nice to see haddock in emacs
18:03:01 <Leimy> sh10151: oh that's true... I usually declare everything :)
18:03:05 <CosmicRay> Leimy: all I've ever seen are hackish extensions that break every time apple makes a security release
18:03:09 <thebug> wow, I harass a bot, look away for a few minutes, and come back only to learn that I've spawned an interesting discussion ... ;)
18:03:10 <shapr> yes, haskell-mode could benefit from haddock
18:03:15 <CosmicRay> heh
18:03:28 <CosmicRay> shapr: so are there options better than haskell-mode?  because it ticks me off
18:03:29 <sh10151> shapr: yi or eclipse? but they are not yet sufficiently like Emacs!
18:03:38 <sh10151> Emacs is my biggest productivity tool at work
18:03:50 <Leimy> yi is pretty neat
18:03:58 <sh10151> M-|, sql-mode, cperl-perldoc, jdee, all of these wonderful things at my fingertips
18:04:02 <CosmicRay> haskell-mode can't seem to understand how to indent (\_ -> do blah)
18:04:05 <Leimy> I should hopefully have more time for that this weekend and see if it works on OS X ok :)
18:04:17 <sh10151> so then it's settled
18:04:17 <thebug> I really like ObjC, it always seemed like it did OO the right way, as opposed to the C++ way of 'OO'
18:04:26 <CosmicRay> also it gets confused when  matching parens on \(foo, bar) -> blah
18:04:30 <sh10151> I will learn elisp enough to add haddock to haskell-mode
18:04:44 <shapr> sh10151: Choose one, make it more like you want. If you get frustrated, switch to another one.
18:04:47 <Leimy> OO was a term coined by the guy who made smalltalk
18:04:55 <shapr> Also, try to work in releasable increments.
18:05:00 <CosmicRay> thebug: have you ever used python?
18:05:16 <thebug> actually no, though I've heard many, many good things about it
18:05:22 <sh10151> I used Haskell at work for a little bit
18:05:27 <sh10151> the IO was very slow :-/
18:05:31 <CosmicRay> thebug: I consider it the pinnacle of a pervasive OO language
18:05:33 <shapr> sh10151: my problem with emacs was that I used it too much. I do email, news, irc, shell, code, etc in emacs.
18:05:42 <CosmicRay> thebug: it is OO without being in your face about it
18:05:51 <CosmicRay> thebug: and has a large standard library
18:05:57 <sh10151> shapr : if I could do email and scheduling at work in emacs, I would
18:05:58 <thebug> generally I stick with Perl and C for my own mischief, and C++ for coursework (gak, though it's what is always required for classes in our CS department)
18:06:00 <CosmicRay> thebug: and a rather nice syntax.
18:06:04 <sh10151> unfortunately we use Notes
18:06:22 <thebug> I've been messing with Haskell of late due to my interest in FP
18:06:28 <Darius> shapr: "was"?
18:06:29 <CosmicRay> thebug: the downside is that it supports some very slick object manipulations, which can lead to surprises when things deviate significantly from standard behavior
18:06:33 <shapr> I ran into emacs problems with any blocking operation, and the lack of popular parser based modes. I now require multithreading and parse tree macros for my next editor.
18:06:35 <sh10151> I don't use emacs quite so much at home, as you can tell from me using Snak instead of erc
18:06:39 <CosmicRay> thebug: I view Haskell as the language Python should have been.
18:06:56 <thebug> as I view ObjC as the language C++ should have been ;)
18:06:57 <shapr> Darius: yes, Yi exists and I'm getting closer to moving in.
18:06:59 <Leimy> shapr: will Yi do multithreaded parsing and evaluation for you?
18:07:09 <CosmicRay> thebug: funny, that's what Java folks think of their language :-)
18:07:14 <Darius> Leimy: It will if he programs it to.
18:07:14 <Leimy> I'm thinking of signing onto Yi as well :)
18:07:15 <sh10151> CosmicRay: I don't think you're allowed to do that until Haskell's library gets bigger :)
18:07:16 <CosmicRay> which I have an *extremely* dim view of.
18:07:17 <thebug> haha
18:07:30 <sh10151> python's big win is the batteries that are included, just like for perl and for java
18:07:34 <thebug> CosmicRay: I agree whole-heartedly with you on that one
18:07:49 <CosmicRay> sh10151: jgoerzen@katherina:~/tree/projects/missingh/libsrc$ cat `find . -name "*.hs" ` | wc -l
18:07:49 <CosmicRay> 14676
18:07:54 <shapr> Python's big win used to be ease of learning and ease of reading.
18:08:00 <CosmicRay> sh10151: how much bigger does it need to be? :-)
18:08:02 <Leimy> sh10151: and that python runs on your Nokia phones now ain't too shabby :)
18:08:04 <ibid> shapr: used to be?
18:08:10 <CosmicRay> yes, Python's library still is a lot larger than Haskell's.
18:08:18 <CosmicRay> OTOH, it's a lot easier to extend Haskell's.
18:08:20 <ibid> MegaMonad: is python good?
18:08:26 <CosmicRay> and we have people like Igloo writing a native Deflate :-)
18:08:40 <sh10151> shapr: maybe, but so many people nowadays are brainwashed into Java, C++, or VB that it doesn't matter
18:08:49 <thebug> here comes the wisdom of megamonad on programming languages
18:08:58 <Leimy> or brainwashed into whatever language
18:09:00 <shapr> ibid: what does this do? def foo(a):  bar(*(a)) 
18:09:05 <Leimy> don't just pick the one's you dislike
18:09:15 * Leimy believes "small languages" can have their place
18:09:23 <Leimy> and I think Haskell is the way to implement some of them :)
18:09:27 <CosmicRay> heh
18:09:40 <ibid> CosmicRay: is MegaMonad saving or why is it not answering?
18:09:43 <Leimy> but I've seen some really neat stuff done in C++ when it comes to making parsers
18:09:46 <thebug> Leimy: what, like Lua?
18:09:49 <Leimy> EBNF form template evaluators
18:09:52 <CosmicRay> ibid: I think it is behind on processing the conversation
18:09:53 <arauko> I think Java is crap.
18:09:55 <MegaMonad> ibid: So all i don't like this "expected"/"inferred" terminology. Depending on from python.
18:09:57 <ibid> CosmicRay: ok
18:10:00 <CosmicRay> ibid: I tweaked it to allow up to 6 seconds per item
18:10:05 <ibid> CosmicRay: how?
18:10:08 <CosmicRay> ibid: so it has been sitting at 97% cpu for awhile
18:10:13 <Leimy> thebug: I've not messed with Lua
18:10:17 <Leimy> but I've looked at LPS
18:10:19 <thebug> me either
18:10:27 <Leimy> Language Prototyping System
18:10:28 <CosmicRay> ibid: hrm.  I don't exactly remember.
18:10:33 <Leimy> it's a haskell project
18:10:33 <CosmicRay> ibid: I hacked the megahal source somwehere.
18:10:40 <shapr> ibid: or, what do you think of the decorator syntax in Python?
18:10:45 <Leimy> uses literate haskell though... which I don't grok quite yet
18:10:57 <ibid> shapr: haven't looked at python that much lately
18:10:59 <thebug> CosmicRay: that's what I've been playing with  a bit too, it's fun
18:11:03 <ibid> shapr: i haven't written it since 1.*
18:11:11 <sh10151> arauko: what are the top 3 things wrong with java?
18:11:27 <shapr> ibid: I've had to search the manual thoroughly to read recent code I've been using.
18:11:33 <ibid> MegaMonad: what's wrong with java?
18:11:43 <sh10151> shapr: i don't even use generators yet, don't ask me about decorators!
18:11:44 <CosmicRay> ibid: see some of the quotes at @wiki MegaMonad
18:11:50 <ibid> CosmicRay: i've read them
18:11:50 <CosmicRay> ibid: there are some great ones :-)
18:12:02 <shapr> Python 1.5 was *easy* to teach to anyone. I could guarantee they could read any source code they would fine after an hour of syntax tutorial.
18:12:03 <CosmicRay> my favorite megamonad quote still is "to me, java is a monomorphic type"
18:12:07 <ibid> CosmicRay: you pointed me there the other day :)
18:12:13 <shapr> find*
18:12:23 <CosmicRay> ibid: I have trouble remembering whom I've pointed where.
18:12:27 <ibid> :)
18:12:30 <CosmicRay> guess that's why I don't use much C anymore...
18:12:36 <ibid> heh
18:12:55 * ibid is writing a bootstrap compiler for ketchup in haskell
18:12:55 <sh10151> shapr: really? i much prefer Python list comprehensions to map/filter/apply
18:13:13 <MegaMonad> ibid: The only criteria that i like in c would be really painful in java...
18:13:15 <CosmicRay> sh10151: though haskell has those too...
18:13:19 <ibid> sh10151: "python" list comprehensions?
18:13:21 <Leimy> Haskell's are nice too :)
18:13:23 <Leimy> yeah
18:13:27 <sh10151> i use python list comprehensions all the time
18:13:27 <Leimy> python has list comprehensions
18:13:28 <CosmicRay> sh10151: I originally thought that,m too, but map is far nicer.
18:13:30 <ibid> CosmicRay: haskell had them first :)
18:13:40 <sh10151> CosmicRay: but haskell doesn't have jaskell
18:13:42 <sh10151> :)
18:13:44 <shapr> sh10151: I don't, because map/filter/apply are easier to read.
18:13:44 <ibid> well, not first as in first ever
18:13:50 <Leimy> sh10151: yet!
18:13:54 <CosmicRay> heh
18:14:13 <Leimy> the fold functions are nice for some things too
18:14:14 <sh10151> shapr: why do you say that?
18:14:27 <Leimy> I can see them being done in a parallel data distrubution on a cluster 
18:14:31 <Leimy> as a sort of MPI_Reduce
18:14:32 <shapr> Because every bit of extra syntax adds learning time.
18:14:36 <sh10151> list comprehensions came very naturally to me in haskell and in python
18:14:36 <Philippa> shapr: some list comprehensions're OK if you've been subjected to set comprehensions elsewhere
18:14:46 <sh10151> see, I don't see it as extra
18:15:00 <sh10151> I see it as "finally, someone respects mathematical convention!"
18:15:01 <Leimy> never seen set comprehensions
18:15:03 <Philippa> it is though, it's syntactic sugar pure and simple
18:15:22 <sh10151> yes, but all languages are syntactic sugar
18:15:27 <Philippa> there's a reason mathematical convention and engineering convention differs
18:15:29 <shapr> I sold a bunch of my coworkers on Python 1.* because it really was that easy to learn and immediately use. But that's not true anymore.
18:15:38 <Philippa> sh10151: youwhat?
18:15:40 <sh10151> list comprehensions are very convenient for me
18:15:46 <Pseudonym> Woah.
18:15:52 * Pseudonym just had an insight
18:15:57 <Pseudonym> Thinking about ConcreteView.
18:16:00 <sh10151> Pseudonym: write it down
18:16:05 <Pseudonym> Yeah, I will do that.
18:16:13 <Philippa> sh10151: him telling us about it would be writing it down
18:16:18 <Philippa> at least, assuming he logs :-)
18:16:22 <Philippa> so yeah, tell us
18:16:31 <shapr> At this point, if I want to spend a bunch of time teaching someone a 'real programming language' I might as well teach them a heavy duty power tool like Haskell.
18:16:31 <Pseudonym> Well, who read ConcreteView?
18:16:33 <CosmicRay> shapr: It's still true in that 1.5 syntax can still work in 2.x
18:16:35 <shapr> I read it!
18:16:36 <Philippa> I did
18:16:38 <Pseudonym> Cool.
18:16:44 <CosmicRay> shapr: however it's not so true in that reading 2.x code is not always that easy
18:16:54 <CosmicRay> shapr: nonetheless, things like nested scopes are very useful
18:16:58 <shapr> right, and I can't read it, I can't keep learning at the same speed
18:17:17 <CosmicRay> though the whole generator/iterator thing was a really half-assed way to try to be like FP languages
18:17:23 <shapr> yup
18:17:27 <Pseudonym> A view is like a section in category theory.
18:17:33 <shapr> Might as well get both buns and a real FP lang.
18:17:52 <Pseudonym> Because it's reversible using a retraction.
18:17:52 <Leimy> well python is becoming a melting pot
18:17:54 <Leimy> like Ruby
18:18:18 <Darius> ski thought about something along those lines about a year ago Pseudonym.
18:18:21 <Leimy> Perl is a hodgepodge :)
18:18:27 <Leimy> Python is a melting pot
18:18:32 <Pseudonym> No, ski was looking at retract types.
18:18:44 <Pseudonym> The interesting insight is what if the view is forgetful.
18:19:11 <sh10151> Unix shell is an eminently practical language to learn :)
18:19:14 <Pseudonym> Suppose, for example, that both the Object and the View are members of FUnctor.
18:19:14 <shapr> Python used to be a conceptually pure language in terms of syntax. Python was good for teaching programming to anybody, and the student could immediately be useful too. Now it's too big.
18:19:47 <Leimy> yes
18:19:53 <Leimy> that's basically how I feel about it
18:19:54 <Pseudonym> Then it's a section-like natural transformation.
18:19:59 * Pseudonym needs to think about this some more
18:20:03 <Pseudonym> I'm not making sense.
18:20:58 <Darius> Pseudonym: A section in a functor category?
18:21:08 <Pseudonym> I guess so.
18:21:15 <CosmicRay> hmm.
18:21:16 <CosmicRay> http://haskell.org/mailman/listinfo/test2
18:21:19 <CosmicRay> http://haskell.org/mailman/listinfo/test1
18:21:21 <Pseudonym> I'm just wondering it this turns up more often.
18:24:30 <shapr> I want a planet.haskell.org
18:24:38 * shapr hops impatiently
18:24:42 <shapr> now!
18:24:47 <CosmicRay> heh
18:24:51 <shapr> ok, who here has a blog?
18:24:57 <CosmicRay> changelog.complete.org
18:25:11 <ibid> antti-juhani.kaijanaho.info/blog
18:25:24 * CosmicRay notes that his is easier to spell :-)
18:25:38 <ibid> add /en/ to that if you want to exclude finnish stuff
18:26:10 <sh10151> has anyone #here done work with Erlang?
18:26:16 * ibid notes that it cannot possibly be a _complete_ changelog  :)
18:26:40 <ibid> of org, at least
18:26:47 <shapr> I wonder if the Simons have blogs.
18:26:54 <ibid> MegaMonad: is it a complete changelog of org?
18:26:57 <CosmicRay> hehe
18:27:00 <MegaMonad> ibid: Bring: you've started a week trying to hack on haskell.org, but i want to do is an abstract language that gives me a complete computation of all the math function as the changelog.
18:27:24 <ibid> that's ambitious :)
18:28:44 <shapr> I like this http://www.haskell.org/~simonmar/time/NewTime.html
18:28:57 <CosmicRay> ibid: I like your blog.
18:29:30 <CosmicRay> get rid of one of calendartime or clocktime and make the remaining one a num representing seconds since 1/1/1970 UTC, and I'll be happy :-)
18:29:52 <shapr> clocktime is TAI since the epoch
18:29:58 <CosmicRay> TAI?
18:30:04 <ibid> CosmicRay: why? :)
18:30:40 <shapr> clocktime is picoseconds since the epoch of 1 January 1970 00:10 TAI
18:30:49 <CosmicRay> ibid: your ID6 post in particular was thought-provoking
18:30:51 <CosmicRay> what's TAI
18:31:02 <ibid> ahh, i actually meant the times but thanks
18:31:11 <shapr> greetz SyntaxNinja, any suggestions for planet.haskell.org? I've got you, CosmicRay, ibid, and me.
18:31:15 <ibid> thought you wanted me to change times in my blog :)
18:31:22 <CosmicRay> shapr: drupal would be excellent for it.
18:31:35 <CosmicRay> ibid: heh, sorry, I was talking to you and shapr at once :-)
18:31:39 <ibid> heh
18:32:06 <CosmicRay> obviously I had a little context leakage there...
18:32:13 <thebug> I had really good luck setting up and getting a group running with Drupal recently
18:32:17 <ibid> Host planet.haskell.org not found: 3(NXDOMAIN)
18:32:18 <ibid> :)
18:32:20 <ibid> where is it?
18:32:29 <CosmicRay> I used to run drupal for my blog
18:32:38 <CosmicRay> but it was too heavyweight for one person's blog
18:32:43 <CosmicRay> but it would be ideal for this
18:32:50 <CosmicRay> IIRC that's what planet.debian.org uses
18:32:51 <shapr> it doesn't exist, but I figure enough interest and it would.
18:32:58 <CosmicRay> I bet we could get a more geeky name
18:33:00 <ibid> CosmicRay: planets use planetplanet
18:33:00 <shapr> SyntaxNinja suggested it!
18:33:06 <CosmicRay> hehe
18:33:15 <shapr> redex.haskell.org ?
18:33:34 <Leimy> fedex?
18:33:36 <CosmicRay> heh
18:33:43 <CosmicRay> dailymonad.haskell.org
18:33:57 <CosmicRay> functor.haskell.org
18:34:25 <CosmicRay> forall.haskell.org
18:34:27 <shapr> TAI is Temps Atomique National
18:34:39 <shapr> hiya bpalmer
18:34:40 <CosmicRay> shapr: that didn't help much :-)
18:34:45 <ibid> i like forall
18:35:06 <CosmicRay> backslashunderscore.haskell.org :-)
18:35:16 <Pseudonym> The Forgetful Functor
18:35:20 <CosmicRay> shapr: some sort of standards body?
18:35:21 <CosmicRay> hahaha
18:35:33 <thebug> doublegreaterthanequals.haskell.org
18:35:34 <shapr> http://cr.yp.to/libtai.html
18:35:49 <Leimy> cplusplus.haskell.org ?
18:35:57 <shapr> "TAI, Temps Atomique International, is the international atomic time scale based on a continuous counting of the SI second."
18:36:11 <CosmicRay> ah.
18:36:13 <CosmicRay> thank you
18:36:23 * CosmicRay thwaps leimy
18:36:31 <CosmicRay> incr.haskell.org
18:36:37 <CosmicRay> return.haskell.org
18:36:41 <Darius> Well continuing on the monad front you'd have join.haskell.org, but noone ever uses join.
18:36:46 <CosmicRay> ah
18:36:52 <CosmicRay> excellent, darius
18:36:53 * Leimy feels slightly thwapped
18:36:59 <CosmicRay> sequence-noobs.haskell.org
18:37:05 <CosmicRay> map.haskell.org
18:37:08 <CosmicRay> uhm...
18:37:12 <Darius> not-a-monomorphic-type.haskell.org
18:37:15 <CosmicRay> nub.haskell.org
18:37:15 <CosmicRay> haha
18:37:34 <CosmicRay> handle.haskell.org
18:37:48 <monochrom> haskell.haskell.org
18:37:52 <shapr> bpalmer: learning Haskell?
18:38:00 <Darius> curry.b.haskell.org
18:38:01 <thebug> shapr: did you ever get "shapr's noob column" off the ground?
18:38:06 <CosmicRay> heh
18:38:13 <Pseudonym> Concurrent.Chan.haskell.org
18:38:26 <Darius> System.Unsafe.haskell.org
18:38:30 <CosmicRay> hah
18:38:32 <shapr> thebug: nah, I said I wouldn't start the Haskell periodical unless I had at least three other authors willing to commit to monthly entries.
18:38:42 * CosmicRay volunteers.
18:38:42 <shapr> I got one.
18:38:45 <thebug> ah, I missed that part apparently
18:38:47 <Leimy> org.haskell.poopy-pants
18:38:56 <Pseudonym> I can volunteer as half an author.
18:38:56 <CosmicRay> now you need only 1 :-)
18:39:06 <Pseudonym> I'll commit to every two months.
18:39:29 <monochrom> Text.ParserCombinators.Parsec.Language.haskell.org
18:39:32 <CosmicRay> I volunteer for the "what happens when you don't heed Simon's advice" column :-)
18:39:38 * shapr grins
18:40:09 <Pseudonym> I want to call my column "Functional Granite".
18:40:20 <Pseudonym> It won't be as pretty as Functional Pearls.
18:40:24 <Pseudonym> Or "Functional Swine".
18:40:29 <shapr> There were a bunch of good ideas for columns and articles for a Haskell webzine, but not enough author interest.
18:40:30 <monochrom> and mine Static Dynamite
18:40:31 <CosmicRay> Pseudonym: lambdadump has a ring to it
18:40:41 <thebug> shapr: how were you going to set up subscription to this periodical?
18:40:46 <CosmicRay> shapr: I bet you could corral syntaxninja into it
18:40:52 <shapr> I was aiming for a free wiki-based webzine
18:41:04 <thebug> ah, makes sense
18:41:06 <CosmicRay> shapr: or a planet-based one?
18:41:14 <shapr> CosmicRay: what's that?
18:41:22 <CosmicRay> shapr: post the articles on planet.haskell.org
18:41:34 <shapr> CosmicRay: I doubt SyntaxNinja has time at the moment.
18:41:44 <CosmicRay> oh, bummer.
18:42:09 <CosmicRay> shapr: there are articles on planet.debian.org regularly
18:42:38 <CosmicRay> shapr: if you're selective about what goes on the front page, it'd work nicely
18:42:45 <shapr> I'll try again for a Haskell periodical webzine when I have firm server hosting. Right now things are looking shaky.
18:42:53 <shapr> bpalmer`: hiya
18:43:00 <ibid> hmm, i'd better go to bed
18:43:03 <bpalmer`> yo
18:43:07 <CosmicRay> shapr: that's a bummer
18:43:23 <CosmicRay> shapr: you have some nice deal somewhere, right?
18:43:39 <Pseudonym> haskell.pla.net
18:43:40 <shapr> At the moment my nice deal is becoming less nice.
18:43:47 <SyntaxNinja> what are you corraling me into?
18:44:00 <CosmicRay> heh
18:44:04 <CosmicRay> oh nothing, nothing at all....
18:44:34 <CosmicRay> shapr: do you require a dedicated machine or would a usermodelinux box suffice?
18:44:36 <shapr> SyntaxNinja: a column in the Haskell webzine
18:45:12 <SyntaxNinja> heh. like dwn?
18:45:44 <shapr> It's my personal/business server, so I really want physical access to it. I dunno about UML, might work.
18:45:57 <CosmicRay> shapr: do you think a simon would volunteer?
18:46:06 <CosmicRay> shapr: I have been extremely happy with both the service and price at memset.com
18:46:15 <shapr> volunteer for an interview maybe? I doubt for a column.
18:46:27 <CosmicRay> shapr: they have some nice deals for annual contracts that they don't mention on the site
18:46:44 <CosmicRay> shapr: it's been very reliable for me
18:46:55 <shapr> huh, they do look nice.
18:47:04 <CosmicRay> they're a debian shop, too.  :-)
18:47:11 <shapr> do they allow me to run debian/unstable and have root on my UML?
18:47:18 <CosmicRay> yes
18:47:20 <CosmicRay> that's what I do
18:47:32 <CosmicRay> IIRC they'll even preinstall testing for you
18:48:46 <CosmicRay> they also have a web tool that you can use to see your uml box's console log or reboot your uml box
18:48:50 * ibid likes bytemark, now that we are talking about uml hosting :)
18:49:16 <shapr> I'll think about it.
18:49:27 * CosmicRay should get a commission :-)
18:49:30 <shapr> I'm still leaning towards buying a static ip and running the whole thing here.
18:49:31 <CosmicRay> ibid: url?
18:49:40 <Pseudonym> Must away.
18:49:40 <CosmicRay> I did that for awhile
18:49:40 <Leimy> Earl?
18:49:47 <ibid> CosmicRay: bytemark.co.uk
18:49:54 <CosmicRay> got annoying having to be responsible for it during power outages, etc
18:49:55 <shapr> CosmicRay: what do you think?
18:50:00 <thebug> Tea. Earl Gray. Hot.
18:50:03 <shapr> UPS isn't a problem.
18:50:06 <Pseudonym> Merry Christmas, Happy Channukah, Happy Solstice or whatever.
18:50:11 <shapr> cya Pseudonym
18:50:19 <Pseudonym> See you in a little over a week.
18:50:21 <Leimy> thebug: just once I'd love to see Jean Luc Picard say "Wings, hot"
18:50:23 <Pseudonym> Assuming any of you are here then.
18:50:31 <CosmicRay> shapr: also here in the USA a cable modem or dsl is just not reliable enough for a server
18:50:33 <thebug> Wings. Spicy. Hot
18:50:33 * Philippa delivers thebug a cup of something almost but not entirely unlike tea
18:50:35 <Pseudonym> Not that I'm expecting...
18:50:37 <Pseudonym> Uhm...
18:50:38 <Leimy> and then have people come into his ready room with lots of sauce all over his face
18:50:39 <Pseudonym> Never mind.
18:50:41 <Pseudonym> Fare well!
18:50:42 <CosmicRay> shapr: OTOH, it's a lot cheaper if you need lots of disk space
18:50:48 <CosmicRay> shapr: especially if you'd have the service anyway
18:50:59 <thebug> why thank you, Philippa ;)
18:51:55 <CosmicRay> ibid: looks nicer, but a lot more expensive than memset given that they don't sell in dollars
18:52:08 <CosmicRay> er s/nicer/nice/
18:52:18 <ibid> CosmicRay: for me, being in eu is a strong point
18:52:56 <CosmicRay> ibid: memset is in london and has machines there and in canada iirc
18:53:02 <ibid> url?
18:53:23 <ibid> but i'm not switching without a very good reason?
18:53:27 <CosmicRay> memset.co.uk
18:53:37 <ibid> (such as bytemark-level service in finland, which i haven't found yet)
18:53:49 <CosmicRay> the miniserver is their uml deal
18:54:20 <Darius> Variable Length Records are annoying.
18:54:29 <ibid> bytemark is actually cheaper for me
18:54:30 <CosmicRay> I have the miniserver 6000, but get a hefty discount since I pay annually
18:54:44 <CosmicRay> I wonder if they do that too
18:55:00 * Darius calls it a day.
18:55:04 <CosmicRay> cya darius
18:55:07 <ibid> bytemark has a free softwaree developer discount :)
18:55:13 <CosmicRay> :-)
18:55:22 <CosmicRay> I used to use johncompanies.com, which had that too :-)
18:55:39 <CosmicRay> but it was actually less of a discount than memset's 20% off for annual contract deal
18:55:57 <ibid> i believe bytemark has an annual deal
18:56:39 <ibid> yeah, you get two months for free
18:59:04 <ibid> it's 5am and i need to get some sleep
18:59:16 <ibid> shops close at 1pm and open again on monday
19:00:38 * CosmicRay releases missingh 0.8.0
19:02:18 <Leimy> my keyboard is o so clicky
19:09:29 <shapr> dang, SyntaxNinja left..
19:09:41 <shapr> I found an irritating bug in haskell-mode 2.0
19:10:18 <shapr> comment-region and C-u comment-region are not inverses.
19:11:33 <bpalmer`> what do they do, instead?
19:12:53 <shapr> leaves a space in front of the uncommented line, that's a serious bug since Haskell is layout significant.
19:13:03 <shapr> Why, are you the maintainer? :-)
19:13:21 <bpalmer`> nono, just curious :-)
19:13:53 <shapr> Are you learning Haskell?
19:14:02 <CosmicRay> http://www.thinkgeek.com/cubegoodies/toys/5b5f/
19:14:28 <bpalmer`> yep
19:14:41 <shapr> any questions?
19:15:08 <bpalmer`> nope. I'll have to actually start programming in it before I get any questions :-)
19:15:30 <shapr> You want the channel tour and short Haskell intro?
19:16:07 <Leimy> shapr rides unicycles
19:16:11 <Leimy> that's all you need to know :)
19:16:13 <bpalmer`> going through the docs on haskell.org now (the ones I haven't gone through before, at any rate :-)
19:16:42 <shapr> Ok, if you get the urge for extra input, feel free to ask.
19:16:57 <bpalmer`> cool. thanks :-)
19:20:35 * Leimy notes this is one of the most helpful channels for beginners in a language he's been in
19:22:34 <shapr> Alternatively, you could call us rabid proselytizers.
19:23:01 <bpalmer`> I would never do that! 
19:23:02 <bpalmer`> (Too hard to say)
19:26:53 * shapr grins
19:27:07 <shapr> Yay! I have finally relearned HaskellDB.
19:28:05 <Lemmih> Eh?
19:29:51 <shapr> Lemmih: I'm partway into updating curryspondence.
19:30:15 <Lemmih> Did HaskellDB change its interface?
19:30:32 <shapr> I think several things have changed.
19:34:23 <shapr> Lemmih: but the primary problem was that I couldn't remember how it all worked...
19:34:38 <Philippa> change is between keyboard and chair?
19:35:15 <shapr> seems likely
19:45:05 <shapr> Huh, what happened to the "download entire mailman archive as an mbox?" link in mailman?
19:48:32 <Lemmih> Good night, #haskell.
19:48:41 <shapr> g'night
19:49:40 * shapr discovers an apt cache on haskell.org
19:52:07 <shapr> hej r3tex
19:52:18 <r3tex> shapr: e du vaken nu ;)
19:53:35 <shapr> Jag fÃ¶rsÃ¶kte att sova en gÃ¥ng, det var inte kul.
19:53:42 <r3tex> =P
19:53:48 <r3tex> jag har lagt in win-cacca på min laptop nu
19:53:55 <r3tex> bredvid gentoo
19:54:12 <r3tex> måste ha det för Cubase skull =/
19:54:32 <shapr> man, you need to switch to utf-8
19:54:35 <shapr> it's so much tastier.
19:54:40 <shapr> extra flavor!
19:54:52 <r3tex> hmm =/
19:54:53 <r3tex> =P
19:54:55 <r3tex> tycker du?
19:54:57 <r3tex> hehe
19:55:12 <shapr> I sure like it.
19:55:21 <shapr> utf-8 now?
19:56:04 <r3tex> sÃ¥
19:56:34 <r3tex> eller =
19:56:35 <r3tex> =)
19:56:39 <r3tex> du ser la mina Ã¥Ã¶Ã¤
19:56:59 <shapr> jo, det Ã¤r bra :-)
19:57:05 <r3tex> ok
19:57:11 <shapr> anyway, have you tried the many open source audio apps?
19:57:11 <shapr> I dunno how they compare to cubase, but I sure have seen a lot of cool apps.
19:57:18 <r3tex> ska fixa firefox sÃ¥ den lÃ¤ser kinesiska (flickvÃ¤nnen =)
19:57:26 <shapr> neat
19:57:49 <r3tex> yea, problem nr.1 with OpenSource audio apps is lack of VST plugins
19:58:05 <r3tex> problem nr2 is... still quite buggy =/
19:58:40 <shapr> well, it's open source.... you can fix both of those :-)
19:59:05 <r3tex> heh, im not "that" good. requires a lot of math/time/knowhow =((
19:59:05 <r3tex> crappo
19:59:07 <r3tex> i have none
19:59:19 <shapr> finding bugs and reporting them is an important part.
19:59:22 <r3tex> yea
19:59:29 <r3tex> my bugreporting consists of
19:59:34 <r3tex> crap! it crashed again!
19:59:35 <r3tex> shit
19:59:38 <r3tex> i lost my file!
19:59:43 <shapr> that does suck
19:59:49 <r3tex> yea i'll admit
19:59:50 <r3tex> =)
20:00:03 <shapr> which apps have you tried?
20:01:02 <shapr> I don't know enough to crash anything so far.
20:01:20 <shapr> I recently tried to warp and stretch some audio, but couldn't really figure out a good way to do it.
20:01:26 <r3tex> =) um my favorite app for multitrack mixing is ardour
20:01:36 <r3tex> rosegarden is so confusing =/
20:01:51 <r3tex> oooh stretching audio is veery beta in linux =/
20:01:58 <r3tex> the plugins are still quite immature
20:02:07 <r3tex> too bad
20:02:31 <r3tex> especially since the hardware and Jack, both work so well
20:03:00 <shapr> yeah, I really like Jack
20:03:22 <r3tex> =)
20:03:27 <r3tex> more apps should support it
20:03:33 <r3tex> it's really l33t
20:04:03 <shapr> How does one create a VST plugin for Linux?
20:04:17 <shapr> Do you just set the attack, decay, etc for a new instrument? or is there more to it?
20:05:55 * shapr explodes his code repeatedly
20:06:42 <r3tex> shapr: heh, let me see, just a sec
20:07:24 <r3tex> http://audacityteam.org/vst/
20:07:25 <r3tex> there
20:07:33 <r3tex> there is something in that direction
20:07:35 <r3tex> before
20:07:51 <r3tex> the only way of getting VST to work is a superugly wrapper and Wine
20:08:15 <shapr> oh, so... what's the real solution? just use jack plugins?
20:08:41 <shapr> VSTs are just bits of code that imitate musical instruments, right?
20:10:03 <r3tex> shapr: VSTs are plugins that most often have a UI to the plugin that works through a certain audio layer like Jack, or the Windows audio layer
20:10:12 <r3tex> linux's equivalent is LADSPA
20:10:21 <r3tex> wich is a good effort
20:10:29 <r3tex> but not enough pros/manpower
20:10:40 <r3tex> er
20:10:44 <r3tex> corporate backing
20:10:46 <r3tex> mainly
20:10:48 <r3tex> =(
20:10:59 <ralf> can someone give me an exercise to understand monads?  Point me to a tutorial?  Right now I am reading a tutorial at nomaware.com/monads and some academic paper.  (my background is math, so the academic paper is pretty comfortable.)
20:11:05 <shapr> it seems unlikely to me that any Linux effort will have corporate backing.
20:11:31 <shapr> ralf: Other than nomaware, you might like http://www.cs.fit.edu/~satkin/monads.html
20:11:52 <shapr> r3tex: so, how hard is it to write LADSPA plugins? do they require C or can I use Haskell?
20:11:55 * shapr asks google
20:12:18 <r3tex> =))
20:12:46 <r3tex> shapr: you interested in music too?
20:13:13 <shapr> Should a LADSPA plugin be really fast? Is it a realtime transform, or is it applied to a sample?
20:13:16 <r3tex> it's better to work on a VST4linux thÃ¤ng =)
20:13:25 <r3tex> shapr: it depends
20:13:44 <r3tex> but when talking about audio, low latency is most often quite critical
20:13:47 <r3tex> =/
20:14:10 <shapr> I don't want to port windows software to linux unless it's totally necessary. I'd rather try the Linux native solution first.
20:14:29 <shapr> Also, I bet VST is tuned for Win32, not Linux.
20:14:50 * shapr reads http://gdam.ffem.org/ladspa-doc/ladspa.html
20:15:01 <shapr> I'm interested in nearly everything, but I have very little skill with music.
20:15:26 <shapr> oh, that's an old version, 2000
20:17:16 <r3tex> yeah VST is very tuned for Win32
20:17:30 <r3tex> but if you can port VST to Linux that is everyones dream come true
20:17:34 <r3tex> you would be a god
20:17:35 <r3tex> =P
20:18:11 <shapr> I'd rather write LADSPA plugins.
20:18:39 <shapr> this is neat - http://www.linuxdevcenter.com/pub/a/linux/2001/02/02/ladspa.html?page=1
20:19:01 <shapr> Tutorial on writing your own plugins.
20:20:07 <r3tex> yeah =)
20:20:24 <r3tex> shapr: ladspa needs a time stretch plugin
20:20:29 <r3tex> i think there is one being worked on
20:20:34 <r3tex> but it's still very beta
20:20:40 <r3tex> a lot of math required =/
20:21:38 <shapr> not really, if it sounds right it is right.
20:22:02 <r3tex> well =/
20:22:20 <r3tex> that's like saying all guitar distortions are the same ;P
20:22:38 <ralf> shapr: it's funny that you recommend that tutorial because it is based on a paper by Philip Wadler.  The academic paper that I mentioned above is also by Philip Wadler. 
20:22:52 <shapr> One solution is to write a plugin combinator language that spits out plugins.
20:23:22 <ralf> shapr: How does the import statement work?  Because Mine isn't. It only works when I put the full path in quotes and that is not always convenient.  (And it's not portable.)
20:23:24 <shapr> Wadler got everybody using monads in Haskell. Moggio got computer science people to try monads.
20:23:37 <shapr> @wiki HaskellDemo
20:23:37 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
20:24:24 <ralf> I learned about Wadler last night.  I read his web page and I am reading his "Comprehending Monads."  I love it.  He seems cool.  But who is Moggio? 
20:24:34 <shapr> ask the google
20:27:05 <shapr> ralf: sorry, moggi and monads
20:36:07 * shapr notes that WASH's MailParser has really crappy date parsing.
20:38:58 <shapr> Whoa, TaPL (aka The Brick Book) has a sequel planned for 2005!
20:40:46 * shapr remembers BjÃ¶rn Bringert solved this problem already - http://www.dtek.chalmers.se/~d00bring/misc/ParseDate.hs
20:51:27 <desrt> merry Î»mas, all :D
20:52:42 <Leimy> Âµerry Ã§hristÂµÃâ
20:54:55 <shapr> ï¿½erry ï¿½hristmas
20:55:09 * desrt gives shapr the gift of utf8
20:55:41 <Leimy> ÃÃÃÃÃÃ
20:55:41 * shapr is happy.
20:55:55 <Leimy> utf8 is the bestest evar!
20:56:10 * Leimy hugs his plan 9 box
20:56:10 <desrt> it's hard to disagree
20:56:27 <desrt> there's no good reason to run plan9.
20:56:37 <Leimy> nope
20:56:41 <Leimy> just fun ones
20:57:06 <Leimy> and plan9 has a port of Hugs :)
20:57:16 <Leimy> so at least haskell code has a chance :)
20:57:23 <Leimy> and python now that I think of it
20:57:36 <desrt> is there a c++ compiler?
20:57:39 <Leimy> nope
20:57:42 <desrt> !
20:57:42 <shapr> yay, ParseDate is soooo much better than WASHMail's date parsing.
20:57:46 * desrt switches now
20:57:48 <Leimy> I think the thought iof such a thing would piss people off :)
20:57:58 <Leimy> their C isn't ANSI though
20:58:02 <Leimy> it's a little weird
20:58:06 <desrt> the platform that supports haskell but not C++ is ideal
20:58:26 <Leimy> having email as a filesystem is a neat thing too
20:58:36 <desrt> pfft
20:58:38 <jdrake> Does anyone know if adding a line of text to a locally hosted haskell report indicating where it is hosted and link back to the main index without any other changes would constitute a modified version?
20:58:40 <Leimy> I tried to make it go with gmail
20:58:40 <desrt> i get that now
20:58:44 <Leimy> it wasn't happy :)
20:59:06 <ralf> shapr: I picked the least intimidating sounding title in moggi's list of publications from his website and it is pretty difficult reading. 
20:59:12 <ralf> Not to say incomprehensible. 
20:59:28 <ralf> Can anyone explain to me how the import line works in hugs or ghc? 
20:59:47 <desrt> ralf; did the title start out like "a gentle introduction to..."?
20:59:53 <shapr> did you look at HaskellDemo?
20:59:56 <desrt> because if it did, they're lying
21:00:39 <ralf> I guess you have to change a line in your .bashrc file.  But what are the defaults.  Maybe it would be better to transfer the relevant files to their proper place than to fix the problem by editing .bashrc
21:00:55 <ralf> desrt: No, but I've read that one.  Yeah.  It's not _too_ gentle. 
21:01:14 <ralf> The paper is called "Notions of computation and monads"\
21:01:17 <ralf> by moggi.
21:03:48 * desrt watches the temperature drop
21:04:03 <desrt> it's freaky out
21:05:25 <Riastradh> It is freakily hot where I am.
21:07:02 <shapr> it's surprisingly well lit where I am.
21:07:42 <Leimy> 34 degrees here
21:09:18 <shapr> Minor blizzard here.
21:10:52 * Riastradh envies shapr.
21:11:18 <Riastradh> All we got was a bunch of rain...in almost the northernmost region of the US...in the middle of December...
21:12:45 <shapr> The snow is more than ankle deep right now, and appears to be falling faster.
21:13:10 <jdrake> any ideas where I can find further information on 'where' in the report? SOE says to see the report for further info about its use only at top level where visibility rules are different
21:13:21 <jdrake> I look in the report turns up empty
21:15:06 * shapr cheers for happy date parsing!
21:19:56 * shapr curses the mailman authors.
21:20:33 <shapr> Monthly archives have different date formats from the entire archive? No way!
21:21:57 <Leimy> way!
21:22:24 <shapr> sh10151: what's your nickname mean?
21:22:42 <jdrake> it is the bot number
21:23:03 <jdrake> can't you tell an 0wn3d machine when you see one?
21:25:12 <Leimy> pwned
21:25:30 <Leimy> ÃwÃ±ââ
21:26:49 <shapr> how
21:26:51 <shapr> yow!
21:27:07 * shapr grumbles at mailman
21:27:21 <shapr> st00p1d thing has different formats for half the dates in the archive.
21:28:02 <jdrake> AppleÂ® will hopefully release TigerÂ® shortly
21:29:18 * Leimy is trying to envision a usage for foldM
21:30:14 <arauko> This is dissapointing, opendarwin doesn't have support for my hardware yet.. 
21:30:20 <arauko> apprently
21:30:23 <Leimy> jdrake: I think not until next 2Q 2005
21:30:35 <Leimy> arauko: opendarwin isn't worth trying to run IMO
21:30:45 <arauko> Leimy, why?
21:31:10 <Leimy> I've run it
21:31:15 <Leimy> and had tons of problems with it
21:31:26 <Leimy> no one is even really taking it very seriously at 
21:31:29 <Leimy> #opendarwin
21:31:34 <arauko> oh.. 
21:31:35 <Leimy> and it's horribly outdated
21:31:39 <arauko> sad to hear that
21:31:42 * Leimy is an opendarwin developer
21:31:47 <arauko> :-P
21:31:50 <Leimy> Rob Braun is building a new Darwin snapshot
21:31:56 <Leimy> but it may not be the official OpenDarwin
21:32:09 <Riastradh> Leimy, do you suppose you could remind me what the point of OpenDarwin is?
21:32:15 <Leimy> you are WAY better off running any of the BSDs or linux if you expect to get any work done
21:32:16 <arauko> Why the development is so .. slow?
21:32:19 <Leimy> Riastradh: no idea.
21:32:21 <Riastradh> I think I was told once, but I forgot.
21:32:55 <jdrake> Leimy, is OpenDarwin the project that has that annoying GNU nazi?
21:33:00 <arauko> I wanted to give a try.. it seems interesting to me.
21:33:09 <Riastradh> jdrake, no, that's GNU Darwin.
21:33:20 <jdrake> heh
21:33:30 <Leimy> OpenDarwin might one day be a useful OS
21:33:34 <arauko> But that has annoyed more to OpenDarwin developers than to GNU actually.
21:33:45 <Leimy> we still have to use binary-only drivers
21:33:55 <Leimy> from apple to get most stuff to boot
21:34:11 <arauko> yes, i downloaded the iso image, it doesn't boot.
21:34:25 <Leimy> I think the overall design of the Darwin OS is pretty attrocious
21:34:41 <Leimy> anyone using Mach on purpose today should probably be shot.
21:34:46 <Leimy> or at least called names
21:34:47 <arauko> haha
21:34:59 <arauko> But seems like Apple is doing well wiyth it.
21:35:04 <Leimy> cuz they are trapped
21:35:09 <Leimy> it would cost a lot to dump Mach
21:35:18 <Leimy> and if the OS runs slowly people will upgrade their hardware
21:35:29 <Leimy> probably sells more G5s
21:35:30 <jdrake> i would be more concerned about whether or not hardware works than whether you use binary drivers
21:35:44 <arauko> Oh.
21:35:52 <Leimy> OD works best on my PC
21:35:55 <Leimy> not on my apples
21:36:07 <arauko> hah
21:36:21 <jdrake> Leimy, what about your PearÂ®
21:36:34 <Leimy> The only projects that even seem to exist in any real form on opendarwin.org are darwinports, libFoundation and xar
21:36:50 <Leimy> the opendarwin OS itself doesn't seem to matter very much to anyone
21:37:09 <Leimy> but then again... the whole thing makes me bitter :)
21:37:24 <arauko> Leimy, but, the OD developers also hack into the kernel?
21:37:31 <Leimy> some do
21:37:49 <Leimy> I think someone hacked SACK into darwin
21:37:50 <sh10151> what's wrong with Mach?
21:37:55 <jdrake> why would SOE present a method for calculating the area of a triangle that involves far more calculations than a simpler method that looks to be applicable to the same situation
21:37:57 <Leimy> TCP selective Acknowledgement
21:38:06 <arauko> sh10151, it is really slow.
21:38:37 <sh10151> how is it really slow?
21:38:37 <Leimy> the question is "what's right with mach?"
21:38:59 * sh10151 was under the impression that mach benchmarks used an obsolete version of mach
21:38:59 <arauko> sh10151, test it out and you'll see.
21:39:06 <sh10151> one that is not used in OS X
21:39:12 <Leimy> run LMBench on a G4 system on OS X
21:39:15 <Leimy> then run it with NetBSD
21:39:20 <Leimy> and then run with Linux
21:39:27 <Leimy> and you'll see why Mach is horrid
21:39:43 <Leimy> system call overhead is nightmarih
21:39:47 <Leimy> nightmarish
21:39:59 <jdrake> why would they use it then
21:40:22 <Leimy> because apple bought NeXT
21:40:24 <arauko> Well, i ve not used OD, ive only used GNUmach, and it is slow, i thought Apple project had tuned that kernel better, that's why i wanted to give a try.
21:40:46 <jdrake> Leimy, I thought NeXT bought Apple, but made Apple pay them
21:40:46 <Leimy> and NeXT was Mach 2.5 + BSD based
21:41:03 <Riastradh> ...er, no, Apple bought NeXT.
21:41:04 <Leimy> jdrake: you could look at it that way... :)
21:41:14 <Leimy> it's sort of like being consumed by a virus :)
21:41:14 <jdrake> Riastradh, you don't get the joke then
21:41:33 <Riastradh> Apparently.
21:41:40 <Leimy> XNU is basically NeXT's kernel + IOKit and an updated Mach
21:41:54 * Riastradh just saw this conversation in passing.
21:42:00 * Riastradh wanders back to what he was absent-mindedly doing.
21:42:57 <jdrake> Riastradh, Apple is basically NeXT because they contain basically the people at NeXT in managements and such - thus run by NeXT. So they were bought by NeXT, but Apple paid for them to do it :p
21:44:27 * Leimy found his foldM example in that nomaware.com monad tutorial
21:44:30 <Leimy> that's pretty awesome
21:47:55 <Leimy> I was at the grocery store today
21:48:10 <Leimy> and I bought some Land O Lakes butter
21:48:21 <Leimy> and it rang up on the sign as "LOL BUTTER'... 
21:48:25 <Leimy> I've been ircing too much
21:48:29 <Leimy> I thought that was funny :)
21:49:37 <shapr> sick man...
21:49:53 <jdrake> Land O Lakes?
21:49:57 <jdrake> Neverheard of it
21:50:20 <shapr> When I was first learning monads I dreamed that I had restructured my brain using the monadic interface, and I was unsafePerformIO to see five seconds into the future.
21:50:52 <jdrake> shapr, does insanity result in the understanding moadic life?
21:51:25 <shapr> eh?
21:51:57 <shapr> too many typos on your part, or not enough brain on my part, not sure which...
21:52:02 <shapr> more likely not enough brain, it's almost 7am
21:52:31 <shapr> is there a foldMaybe?
21:53:16 <jdrake> 7am? it be 0:51 by my clock here, perhaps I be soon best bed going 
21:53:47 <shapr> Man this blizzard is really cranking up.
21:53:55 <shapr> hiya Shrdlu
21:54:00 <jdrake> Shrdlu, To Channel you Welcoming
21:54:22 <shapr> jdrake: I suspect you're east coast USA?
21:54:44 <jdrake> I kindfully ask you not to insult me
21:54:52 <Shrdlu> jadrian,shapr: thanks. I'm already here
21:54:54 <jdrake> I am in Ontario
21:54:56 * Shrdlu glares at Nioate 
21:55:07 <shapr> Anyway, I'm in Sweden, somewhere close to UTC.
21:55:30 * shapr yawns
21:55:42 <jdrake> shapr, Swede! How is life there
21:55:57 <shapr> Actually, I'm a US Citizen, only been living here a few years.
21:56:08 <shapr> But at the moment, this place is extremely snowy.
21:56:23 <jdrake> We had quite the blizzard here today
21:56:29 <shapr> I'm hoping for kneedeep snow by noon.
21:56:34 <jdrake> I was lucky to get off the street and to work
21:56:44 <jdrake> We had it just above the ankles
21:56:56 <jdrake> But it is enough to screw our incompetent city services
21:57:20 <shapr> It's definitely more than ankle deep snow in the last few hours.
21:57:47 <jdrake> When Wellington Road is covered in snow, you know you had a blizzard
21:58:18 <shapr> Haven't been to Ontario, don't know what that means.
22:00:45 <jdrake> By 'that' do you refer to Ontario? It doesn't actually mean anything really except for a political boundry
22:01:04 <shapr> Nah, I mean about wellington road.
22:01:44 <jdrake> Wellington Road just is the main artery in the city
22:01:52 <jdrake> At least in the southern part
22:04:12 <arauko> Why this doesn't not work? http://paste.lisp.org/display/4550
22:04:18 <arauko> s/not//
22:04:57 <Riastradh> You have to indent the clauses of the conditional more than the 'if' itself.
22:05:11 <Riastradh> The most common way to write it would be:
22:05:13 <Riastradh>   if p x
22:05:16 <Riastradh>     then Just x
22:05:21 <Riastradh>     else findElement p xs
22:05:33 <Riastradh> You also misspelled findElement.
22:05:38 <Riastradh> ...twice.
22:05:51 <arauko> oh, found it... dam
22:05:52 <arauko> thanks
22:06:35 <jdrake> what is 'Just x', I know it is a data constructor, but its purpose I don't see
22:06:54 <Leimy> it creates an instance of the Maybe class containing "x"
22:07:13 <Leimy> Maybe classes having two data constructors "Just " and "Nothing"
22:07:14 <arauko> yes.
22:07:28 <Leimy> and Maybe's purpose is to deal with functions that can "fail"
22:07:31 <Leimy> but in a defined way
22:07:31 <arauko> i still grasp at the idea actually, but there we go :-)
22:07:54 <Leimy> arauko: think of a function that divides 2 Integers
22:08:07 <Leimy> divider = Integer -> Integer -> Maybe Integer
22:08:13 <Leimy> if the second number is a 0
22:08:20 <Leimy> you have the option to return Nothing
22:08:33 <Leimy> rather than just failing the whole program outright when you try to divide by 0
22:08:41 <Leimy> oops
22:08:44 <Leimy> my syntax is bad :)
22:08:53 <Leimy> divider : Integer -> Integer -> Maybe Integer
22:09:01 <Leimy> dividier _ 0 = Nothing
22:09:01 <arauko> you bring an interesting doubt i have, data types (those constructed with data) are equal to functions?
22:09:15 <arauko> Oh, get it
22:09:26 <Leimy> divider x y = x / y
22:09:34 <jdrake> divider x 0 = Nothing
22:09:34 <jdrake> divider x y = Just (x / y)
22:09:37 <Leimy> oops :)
22:09:37 <Leimy> yes
22:09:38 <Leimy>  :)
22:09:50 <Leimy> see I'm just getting into this myself for the first time in a few weeks
22:09:51 <arauko> Get it.
22:09:53 <Leimy> and I'm already rusty
22:09:55 <jdrake> _ would be better I guess
22:10:33 <arauko> Could i also use? divider _ _ = Nothing  ?
22:10:38 <Leimy> nope
22:10:43 <Leimy> _ _ matches everything :)
22:10:46 <jdrake> arauko, those constructed data types are available for patterns, I don't believe functions are
22:10:47 <Leimy> you wouldn't want to do that
22:10:53 <arauko> Oh, hah true.
22:11:08 <arauko> jdrake, aaah ok... they are like templates?
22:11:21 <jdrake> what do you refer to as templates
22:11:28 <arauko> C++ templates alike?
22:11:32 <jdrake> oh god
22:11:36 <arauko> Sorry
22:11:38 <Leimy> well ... it matches "things"
22:11:38 <arauko> hah
22:11:51 <Leimy> so in the respect that the template engine in C++ can "match" it's pretty close
22:11:54 <jdrake> that question I am afraid i shall not dignify by attempting to answer
22:12:01 <Leimy> but I would try never to think of C++ when learning Haskell
22:12:14 <arauko> im not a person who uses to bring insane programming languages talks up, but this could make it clearer to me :-)
22:12:19 <Leimy> it's really a different kind of thing altogether.
22:12:22 <jdrake> C++ Templates by mere mention can soil you. You must then wash and be unclean until the end of the day
22:12:36 <arauko> Ok.
22:13:23 <jdrake> My cousin had an example once that allowed you to do a call like cos(5) and it would actually generate that at runtime
22:13:46 <jdrake> template metaprogramming...
22:13:53 <shapr> like Template Haskell
22:14:52 <Leimy> jdrake: I've got c++ template factorial and then combinations built from that :)
22:14:57 <jdrake> arauko, how are you learning SOE
22:15:08 <arauko> SOE?
22:15:12 <jdrake> sorry, how are you learning haskell
22:15:19 <jdrake> SOE is how I am learning
22:15:31 <jdrake> http://haskell.org/soe/
22:15:58 <arauko> im reading Yet-Another Haskell Tutorial and the book, Introduction to Fuctional Programming using Haskell 2d Edition.
22:16:40 <jdrake> I just finished a section that had you write a function to find the area of a triangle
22:16:59 <jdrake> Yet the method they gave you looked very inefficient compared to another way I found online
22:18:24 <jdrake> Man! It figures my code wouldn't load right off the bat
22:19:19 <jdrake> ah, easy fix
22:22:26 <jdrake> my beloved triArea function doesn't seem to work..
22:24:19 <arauko> Something i don't understand is why a type signature such firstElement :: [a] -> Maybe a , works, and when i try to do something like, returnElement :: [a] -> Integer 
22:24:22 <arauko> doesn't work.
22:25:02 <jdrake> you shouldn't have a problem with that unless there is something in code
22:25:05 <arauko> Of course, i modify the function for it to return an integer... isn't that possible?
22:25:07 <jdrake> do you have an example you can paste
22:25:12 <arauko> Ok.. wait
22:25:41 <arauko> a dump example, just to test
22:25:43 <arauko> my_square :: [a] -> Integer
22:25:43 <arauko> my_square (x:xs) = x
22:25:58 <jdrake> that is [a] -> a
22:26:48 <arauko> Oh.. yes
22:28:02 <jdrake> perhaps you should next time try it without the type definition and just let it infer
22:28:34 <arauko> what abut this little one:
22:28:36 <arauko> my_square :: a -> a
22:28:36 <arauko> my_square a = a * a
22:29:59 <arauko> or should it be instead, my_square :: a -> b ....
22:30:38 <jdrake> nope that is a -> a
22:30:42 <jdrake> because they are same type
22:30:51 <arauko> but.. doesn't work.
22:30:53 <jdrake> But it must be a Num
22:30:58 <jdrake> what do you use
22:31:11 <arauko> i mean,it doesn't load it.
22:31:15 <arauko> GHCi
22:31:23 <jdrake> let square a = a * a
22:31:26 <jdrake> :t square
22:31:49 <arauko> that way works. 
22:32:05 <jdrake> let it try to infer it more 
22:32:17 <arauko> but i don't know if it doesn't work with square :: a -> a 
22:32:21 <arauko> isn't it the same?
22:32:35 <jdrake> one sec
22:32:39 <arauko> Ok.
22:32:53 <Leimy> sayHello = do putStrLn "Hello World"
22:32:59 <Leimy> possibly incorrect indentation???
22:33:12 <Riastradh> Leimy, that 'do' is redundant.
22:33:13 <Leimy> do I need parenthesis?
22:33:19 <Leimy> Riastradh: I thought so too :)
22:33:25 <Leimy> but I stuck it in there just in case :)
22:33:43 <Leimy> still won't compile :)
22:33:59 <Riastradh> What is the main error?
22:34:34 <arauko> Prelude> let sayHello = putStrLn "Hello" works here Leimy
22:35:03 <Leimy> Compiling Main             ( actions.hs, actions.o )
22:35:03 <Leimy> actions.hs:9: parse error (possibly incorrect indentation)
22:35:08 <jdrake> square :: (Num a) => a -> a
22:35:08 <jdrake> square x = x * x
22:35:15 <Leimy> sayHello : IO ()
22:35:15 <Leimy> sayHello = putStrLn "Hello World"
22:35:23 <arauko> with do also works, though it is indeed redundant.
22:35:28 <Leimy> probably something stupid :)
22:35:47 <arauko> jdrake, yes, it works that way, but why it doesn't the other way around?
22:35:51 <Riastradh> Leimy, : constructs a list.
22:35:57 <jdrake> because * is only for numbers
22:36:01 <Riastradh> :: is the syntax for type annotations.
22:36:10 <arauko> jdrake, aaaaah 
22:36:18 <arauko> Shit, im always falling in the same mistake.
22:36:22 <arauko> thanks jdrake
22:36:56 <Leimy> Riastradh: see
22:36:58 <arauko> jdrake, similar when i use for instance, boolean operators, i need to specify Ord right?
22:37:01 <Leimy> told you I was rusty :)
22:37:16 <jdrake> arauko, I am not that far along
22:37:26 <Leimy> strangely enough I didn't do that for main :)
22:37:29 <jdrake> arauko, what do you think of the module I am working through http://shack.divinecode.org/examples/Shape.hs
22:42:00 <arauko> jdrake, hah, you asking to me? :-)
22:42:06 <arauko> let me see...
22:42:49 <jdrake> you are a fellow learner, so why not ask
22:43:03 <jdrake> triArea seems to be giving me some problems :-)
22:43:12 <jdrake> the /4 should be /2 though
22:43:38 <jdrake> The test I devised is probably incorrect
22:44:54 <jdrake> triArea (1.5,3) (3,0) (0,0)
22:44:54 <jdrake> 4.5
22:45:04 <jdrake> by my calculations it should be half that
22:45:37 <arauko> look, this is what i told you about Ord:
22:45:39 <arauko> http://paste.lisp.org/display/4551
22:46:30 <jdrake> arauko, that function looks nasty
22:46:37 <jdrake> mind if I give you a possible better version/
22:47:04 <arauko> hahah, all i show i guess will look nasty
22:47:25 <arauko> at the moment im just worry that things "get" working, but of course, show me what you got
22:47:43 <jdrake> *Shape> :t my_signum
22:47:43 <jdrake> my_signum :: forall a1 a. (Num a1, Num a, Ord a) => a -> a1
22:48:06 <arauko> *nods* ghci also infers that.
22:48:07 <jdrake> So your type definition should be my_signum :: (Num a1, Num a, Ord a) => a -> a1
22:48:32 <arauko> jdrake, any technical difference in comparison with mine?
22:49:41 <jdrake> the only thing I can think of is that you are allowing a return value that is not within the domain of Ord, thus the a1 type can only be Num
22:50:52 <jdrake> my_signum a | a > 0 = 1
22:50:52 <jdrake>             | a < 0 = -1
22:50:52 <jdrake>             | otherwise = 0
22:52:02 <arauko> what is the | used for?
22:52:26 <jdrake> it is part of the pattern matching
22:52:45 <jdrake> it does the same thing as your if statements were doing
22:52:48 <jdrake> just cleaner
22:52:50 <arauko> Ah get...
22:55:49 <jdrake> I think I might have an explanation for the Ord for a but not for a1. The Report says "The Ord class is used for totally ordered datatypes.", which although it doesn't give an exact thing, the derived reasoning I conclude is that -1 is not ordered in the sense of 0,1,2,3,4,etc.
22:56:23 <jdrake> I am not sure why it uses a1 though
22:56:30 <arauko> mm...
22:56:43 <arauko> and it works in the other way also without complains.
22:56:54 <jdrake> one of the other guys would have to answer this question
22:57:25 <jdrake> i am going to go to sleep now
22:57:32 <arauko> nite jdrake
22:57:40 <arauko> thanks for the help
22:57:44 <jdrake> no problem
22:57:48 <jdrake> lets talk more haskell :-)
22:57:53 <arauko> :-)
22:58:00 <jdrake> do you use aim?
22:58:07 <arauko> No, only this.
22:58:14 <jdrake> ah
23:01:18 * arauko continue reading
23:06:31 <wli> sued on all sides, eh?
23:09:35 <monk0> any ideas how to make an "all_combinations (x:xs) n" function that returns all possible combinations of n elements from list (x:xs) ?
23:10:29 <Leimy> what's the opposite of "words" in Haskell Prelude?
23:10:41 <wli> unwords, likely
23:10:52 <wli> Prelude> :type unwords
23:10:52 <wli> unwords :: [String] -> String
23:10:57 <Leimy> heh
23:10:59 <wli> Not a local thing.
23:11:05 <wli> stock Prelude
23:15:06 <arauko> What is the operator to test if something is true or false?
23:21:13 <Leimy> if ? :)
23:23:06 <arauko> i mean.. let me re-elaborate... in haskell the only false value is False ?
23:23:45 <arauko> i mean, a function to test if some variable is true or not. 
23:41:40 <sjanssen> what exactly are you trying to do?
23:42:09 <arauko> This doesn't work = (8::Int + 9::Int) ?
23:42:25 <arauko> sjanssen, something like, if a then True else False 
23:42:37 <arauko> if a has a true value
23:42:47 <monk0> arauko : check a = a
23:42:55 <sjanssen> you just use 'a' then
23:45:15 <sjanssen> arauko: that has to do with the precedence of :: , (8 + 9 :: Int) should work
23:45:23 <wli> parse error
23:47:18 <arauko> it doesn't work checking, a = a , or 'a'
23:47:40 <arauko> i want to dosomethin like, Func a = if a then True else False
23:49:01 <sjanssen> arauko: do you see that your function is just an identity function?
23:49:20 <sjanssen> (f True) ==> True
23:49:27 <sjanssen> (f False) ==> False
23:50:32 <arauko> mmm....
23:51:23 <Leimy> what's "not equal" in Haskell?
23:51:25 <Leimy> ~=?
23:51:33 <Leimy>  /=?
23:51:34 <Leimy> ?
23:51:36 <sjanssen> therefore (f a) is the same thing as a, which means that f is just an unnecessary middleman
23:51:44 <sjanssen>  /= is the right one
23:51:48 <Leimy> yeah
23:51:51 <Leimy> I had a brainfart
23:54:33 * Leimy is finding selectionSort to be tricky to implement in haskell
23:54:53 <Leimy> I need a good function to remove the nth element of a list :)
23:55:00 <Leimy> I just used filter
23:55:05 <wli> don't do it quite that way
23:55:07 <Leimy> filter (\= x) xs
23:55:10 <wli> rearrange the list
23:55:13 <Leimy> and hello sorted becomes
23:55:15 <Leimy> helo :)
23:55:17 <Leimy> er
23:55:22 <Leimy> Hello becomes Helo
23:56:47 <wli> select x (y:ys) zs = if y < x then select y ys (x:zs) else select x ys (y:zs)
23:56:58 <wli> feh
23:57:13 <Leimy> selectionSort :: Ord a => [a] -> [a]
23:57:13 <Leimy> selectionSort [] = []
23:57:13 <Leimy> selectionSort ns = m : selectionSort (remove m ns)
23:57:14 <Leimy>     where m = minimum ns
23:57:24 <Leimy> remove :: Eq a =>  a -> [a] -> [a]
23:57:25 <Leimy> remove x xs = filter (/= x) xs  
23:57:35 <wli> select x [] zs = (x,zs)
23:57:36 <Leimy> remove is wrong
23:57:45 <wli> Leimy: yes, duplicates are handled wrongly
23:57:51 <Leimy> wli: right :)
23:58:56 <monk00> can you explain this line -> selectionSort :: Ord a => [a] -> [a]
23:59:00 <monk00> what do u declare here ?
23:59:16 <wli> Prelude> let { select x (y:ys) zs = if y < x then select y ys (x:zs) else select x ys (y:zs) ; select x [] zs = (x,zs) ; selectSort [] = [] ; selectSort (x:xs) = let (y,ys) = select x xs [] in y : selectSort ys } in selectSort [5,1,4,2,3]
23:59:16 <wli> [1,2,3,4,5]
23:59:18 <Leimy> monk00: I'm saying that all the "a's" on that line of of the class Ord
23:59:27 <Leimy> which means they can be compared for < > etc
23:59:45 <Leimy> so my function takes a list of elements that are of Ord
23:59:52 <Leimy> and outputs a list of elements that are also of Ord
