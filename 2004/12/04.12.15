00:00:04 <musasabi> OOHaskell
00:00:55 <wli> the wrappers can't be called
00:00:59 <wli> the constraint will show in their types
00:01:11 <wli> they can only be used in "cleanup passes" outside the monad methods
00:01:25 <wli> which I guess is the hack to which I'll have to resort
00:02:25 <wagle> the idea is to use the class/instrance system to automatically generate the cleanup passes
00:02:34 * shapr yawns
00:02:36 <wli> well, we're in trouble
00:02:41 <wli> this doesn't look doable
00:03:01 <shapr> Itkovian: sleep is for weenies!
00:03:47 <wli> I just made a Set class
00:03:54 <wli> and tried to make Data.Set an instance of it
00:04:08 <wli> and then instance Set c => Monad c 
00:04:11 <wli> this pukes
00:04:24 <wli> I'm out of steam, folks.
00:04:56 <Itkovian> shapr: well, I did have a fairly good rest for about 5.5 hours ...
00:06:24 <Itkovian> euh: http://www.bmezine.com/news/pubring/20041214.html
00:07:02 <musasabi> wli: there is no good solution.
00:07:25 <wli> this sounds like a language implementor thing
00:08:00 <wli> i.e. throw the entire problem area over the wall at language implementorsr
00:08:23 <Itkovian> wli: how's the distribution thing coming along?
00:08:31 <wli> lousy
00:09:44 <wli> no leads on the shape of the distribution
00:11:29 <wli> another possibility is to accumulate a list of operations you can't carry out directly
00:11:55 <wli> then do them all in some other function
00:12:54 <Itkovian> hmm
00:13:20 <shapr> Itkovian: interesting, but I'll pass on piercings
00:13:31 <shapr> I like the glasses I have right now with no earpieces.
00:14:29 <Itkovian> I dislike piercings as well ...
00:14:58 <Itkovian> it seems fairly dangerous as well, when something grabs your galsses ...
00:15:00 <wli> data Set t = Set (SetPending t) (Data.Set t) deriving (...) instance Eq t => Eq (Set t) where { ... }
00:15:20 <wli> why not just get it over with and get laser eye surgery?
00:15:27 <Itkovian> ew
00:15:45 <Itkovian> I'm totlaly scared when it comes to my eyes. Nothing or nobody touches 'em!
00:15:56 <wli> ergh
00:16:08 <shapr> Itkovian: http://www.staffanpreutz.com/USA/Preutzproducts.htm
00:16:15 <wli> data Set t = Set [SetPending t] (Data.Set t) deriving (...) instance Eq t => Eq (Set t) where { ... }
00:16:20 <shapr> Those are great glasses.
00:16:37 <Itkovian> wli: hmm, those pending actions ... isn;t that what laziness is for?
00:16:44 <wli> data SetPending t = AddToSet t | DelFromSet t | UnionWith (Data.Set t) | ...
00:16:46 <shapr> time for class.
00:16:49 <wli> Itkovian: well
00:17:05 <wli> Itkovian: there are problems where you can't call anything with a constraint from a monad method
00:18:19 <Itkovian> shapr: they look cool indeed ... but I like my regular ones just fine
00:18:37 <wli> Itkovian: so the pending operations let you build up a set structure by logging operations, which don't need any constraints
00:18:55 <wli> Itkovian: then whenever you look at them directly, you force the operations to go through
00:19:05 <wli> but this is too disgusting to seriously contemplate
00:22:06 <wli> i.e. hacking around the type system by means of methods with actual operational impacts
00:23:03 <Itkovian> hmm
00:26:32 <hammy> moin
00:29:20 <xkb> hi
00:29:53 <Lemmih> Yo
00:31:41 <xkb> Do you know any "pretty printer" for Clean in Latex?
00:31:51 <xkb> like listings or lhs2tex
00:32:01 <wli> well, I think subkinding does it
00:32:03 <wli> for instance
00:32:20 <wli> you have qualifiers like Eq, Ord, etc.
00:32:40 <wli> (Eq, Ord *) -> (Eq, Ord *) is a subkind of * -> *
00:32:46 <wli> constraint-free is "top"
00:32:55 <bourbaki> is it possible to build a simple recursion just useing the usual arrow operarions?
00:33:12 <xkb> pfft you dont want to know what google return on "latex clean"
00:33:29 <bourbaki> operarations
00:33:45 <Maddas> Heh, vedic math.
00:33:48 <wli> the meet of (C1, C2, ..., Ck *) and (K1, K2, ..., Kn *) would basically be the union of the C's and K's as qualifiers on *
00:34:05 <wli> the join would be the intersection
00:34:41 <wli> given labellings to distinguish different instances of *, you can always move those to the front
00:36:09 <wli> e.g. say (C1, ..., Cm s <= *, K1, ..., Kn t <= *) qualifies s -> t
00:36:48 <wli> where s and t are basically just different instances of * labelled so that different sets of qualifiers can be used on them
00:37:47 <musasabi> bourbaki: there is ArrowLoop but using it seems very complex.
00:38:09 <wli> Monad and Functor are qualifiers on * -> * and so should work similarly
00:38:43 <bourbaki> musasabi i know its the reason why i havent slept for like 3 days :)
00:39:00 <musasabi> wli: yes, that is more of less in lines what I was talking a month ago...
00:39:17 <bourbaki> and its not representable as a graph i think i can crunsh it into the loop once i have a graph for it
00:39:19 <musasabi> bourbaki: please tell me if you find a solution.
00:39:28 <bourbaki> musasabi i have an idea
00:39:52 <bourbaki> there is a function tau which is a test if the element comeing in is the terminal element
00:40:22 <musasabi> if I remember initialisation was a larger problem for me.
00:40:30 <musasabi> as I didn't need to terminate ;)
00:40:34 <bourbaki> if its not you branch in one direction if yes into another of these two functions you build the sum of this node you loop back to the initial test node
00:40:56 <bourbaki> initialization of what?
00:41:26 <wli> I think the only effect this has is saying that since (C1, ..., Cm s <= *, K1, ..., Kn t <= *) are both "less general than" *, they're admissible to instantiate in * -> * and merely result in requiring qualifiers on the types accepted by the constructor of kind * -> *
00:41:45 <wli> musasabi: Is this the subkinding you mentioned?
00:42:38 <wli> now the burning question is, how do I hack this into ghc? =)
00:43:36 <wli> if I'm complaining about this, should it go to haskell-cafe or somewhere else?
00:51:20 <musasabi> wli: that could be hacked into ghc, and not even be overly complex.
00:51:29 <wli> musasabi: I'm interested
00:51:43 <musasabi> wli: your real problem should be to write a paper to accompany things.
00:52:10 <musasabi> e.g. that that is really formally safe/sound in addition to just working.
00:53:00 <musasabi> but have to run =>
00:53:38 <wli> I'm a kernel hacker, it probably wouldn't be appreciated (not that it would be particularly looked down on) if I did so.
00:53:56 <wli> I can codemonkey out the wazoo though.
00:55:07 <wli> actually, the methods for proving additions to type systems as complex as Haskell's are sound are a bit beyond my ken.
00:56:09 <TheHunter> good morning, everybody
00:58:49 <bourbaki> moin TheHunter
00:59:22 <bourbaki> TheHunter do you happen to have an idea how to construct a simple recursion with just useing arrows?
00:59:56 <bourbaki> and what was the diagram again for categorical sum? this triangle thing
01:00:51 <TheHunter> for recursion you might consider ArrowLoop
01:01:22 <bourbaki> hm first i think that loop is rather uninteresting since it hides all the features of a recursion
01:01:33 <bourbaki> id like to build it in a graph like structure
01:02:54 <TheHunter> http://en.wikipedia.org/wiki/Coproduct
01:03:11 <bourbaki> hm
01:03:25 <bourbaki> i mean that triangle thingy like the product ...
01:04:19 <bourbaki> a: S->A b: S->B , [a,b]: S->AxB, p1 : AxB -> A, p2 : AxB -> B
01:04:32 <bourbaki> where was something like that for sums as well i just cant think anymore
01:05:04 <shapr> well crap, I have swedish class tomorrow :-(
01:05:29 <TheHunter> given two morphisms f : a -> c and g: b -> c, there is a unique morphism h : a + b -> c satisfying h . i = f and h . j = g.
01:05:42 <bourbaki> and what was that called again?
01:06:21 <TheHunter> universal property?
01:06:36 <bourbaki> hm
01:06:45 <bourbaki> and the thing i pointed out?
01:06:58 <bourbaki> have you used arrow loop to do recursions?
01:07:04 <TheHunter> nope.
01:07:39 <TheHunter> all those things are called universal properties (of products, coproducts, limits etc.).
01:08:00 <wli> are ends and coends universal?
01:08:10 <wli> or cones/cocones?
01:08:13 * shapr wonders if his head is his coend.
01:08:20 <bourbaki> the thing is a recursion can put out two different functions codomains thingies
01:08:33 <wli> I think ends/coends are category-theoretic analogues of integrals
01:08:35 <bourbaki> and i want to join these outputs again in one thing
01:09:01 <TheHunter> wli: ends = limits?
01:09:21 <wli> but I have to say they are so far beyond the category theory I actually understand the only salient comment I can make is that the symbol resembles an integral sign
01:11:02 <TheHunter> wli: yeah, i've seen integral-like thingies, too, but i don't have the slightest idea what they do.
01:11:12 <bourbaki> so my idea is kind of this
01:11:45 <bourbaki> trace (test >>> (branch1 <+> branch2))
01:12:08 <bourbaki> where test says if its the terminal element or not
01:13:42 <TheHunter> what's <+>
01:13:50 <bourbaki> sec
01:13:58 <bourbaki> bbs
01:15:41 <aruser02_> bk its me boubaki
01:15:47 <aruser02_> bourbaki
01:16:11 <aruser02_> im not entirely sure but i think that its the direct sum of two functions
01:16:47 <aruser02_> dang no angle brackets here
01:17:12 <aruser02_> either a b -anglebracket either c d
01:17:31 <aruser02_> so the test returns left or right depending if its the terminal element or not
01:18:00 <aruser02_> then plugged into the other thing i get either the end part or the left recursion part of the recursion
01:18:14 <aruser02_> looping over that should do the job i guess
01:19:11 <aruser02_> and if you draw it as a diagram youd end up with a y where the two ends are the top connected via the sum where the sum loops to the bottom of the y
01:19:32 * wli has now complained to haskell-cafe
01:21:22 <aruser02_> TheHunter, does that sound reasonable?
01:22:13 <TheHunter> aruser02_: i don't really get what you mean. Your recursion can probably only be implemented with ArrowLoop.
01:22:45 <aruser02_> trace is the same ill do some diagrams and such when i got home if youre still on then im in the robot lab atm
01:22:48 <TheHunter> What troubles me is the fact that the only candidates for a terminal element in your category are () and the empty type.
01:23:22 <aruser02_> thats the terminateing branch in any recursion isnt it?
01:23:23 <TheHunter> (assuming you want to use Control.Arrow arrows)
01:23:59 <aruser02_> TheHunter, i think ill be able soon to build progams with my stuff
01:24:09 <aruser02_> ill do it in a petri net like way
01:24:26 <aruser02_> just the arrow stuff to collapse the things needs to be worked on
01:24:48 <aruser02_> and especially cycles in the graphs are though i think
02:00:56 <TheHunter> wow, i didn't know "verboten" can be used in English.
02:01:13 <TheHunter> (And I don't like it considering that it indicates what kind of image Germans have in other countries.)
02:05:13 <TheHunter> @seen MegaMonad
02:05:13 <lambdabot> I haven't seen MegaMonad
02:05:46 <wli> TheHunter: hmm?
02:06:11 <wli> TheHunter: What do you mean? I thought it was just a common borrowing for "forbidden".
02:06:37 <TheHunter> yeah, it probably is.
02:07:43 <TheHunter> i just meant to say, i don't like the fact that this word is borrowed.
02:08:16 <wli> TheHunter: Okay, why not?
02:09:04 <TheHunter> wli: you might be interested in http://www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps .
02:11:57 <TheHunter> because the reason a word (that already exists in a language) is being borrowed, can be that the word is somehow considered typical for the people speaking the language it is borrowed from.
02:12:08 <TheHunter> But maybe, i'm just interpreting too much into it.
02:12:57 * TheHunter needs an English ethymological dictionary.
02:13:48 <wli> TheHunter: well, it is somewhat typical, e.g. on the equivalents of "No Smoking" signs.
02:16:19 <TheHunter> There are no signs saying "verboten". Anyway, i don't like it that Germany is apperantly viewed as a restrictive country.
02:17:39 <Itkovian> so then we can't import the F-word into other languages, cos that would make the english speaking people look like sex maniacs?
02:17:51 <Itkovian> TheHunter: it's just a word ...
02:18:28 <TheHunter> Itkovian: i know it's no big deal, and i'm not critizising the fact that it is being used.
02:18:32 <wli> TheHunter: I'm not sure why that's an implication of the borrowing. I wouldn't bother reading so much into it. It's pretty well-understood that Amerikkka is on par with Singapore et al wrt. restricting personal freedoms etc.
02:18:45 <TheHunter> I just find the implications of it quite interesting.
02:19:04 <Itkovian> Maybe they just finds it sounds 'cool' in some way
02:19:14 <wli> c'est moi
02:19:23 <Itkovian> eh?
02:19:39 <wli> I used it in a haskell-cafe post
02:19:45 <Itkovian> ah
02:20:37 <wli> I've been yelled at in Turkish, Greek, Italian, and German in conference calls recently, so there's plenty of polyglot hell going around.
02:20:52 <wli> and French too actually
02:23:26 <Itkovian> hehe
02:23:37 * Itkovian has subscribed himself to the haskell-cafe mailing list
02:23:40 <wli> Itkovian: so, given that you do prob/stat, given some observed phenomenon, how would you go about figuring out what the probability distribution is?
02:23:43 <Itkovian> another piece of worthless information
02:25:04 <Itkovian> well ...
02:25:37 <Itkovian> First, you'd have to know more or less what you're measuring ...
02:25:58 <wli> Itkovian: what does that entail?
02:26:49 <wli> i.e. what needs to be known in advance
02:27:05 <Itkovian> As I'm not a general statistics expert (I only learn and know what I need for my own stuff), I find it hard to give a general strategy
02:27:31 <Itkovian> let's try and tackle your yesterday's problem then
02:27:51 <wli> sure
02:28:24 <wli> I hit some other library/type system oddity
02:28:25 <Itkovian> given that, iirc, you observe the number of hits before hits to n different positions
02:28:50 <wli> hits before hits?
02:29:18 <wli> oh, how many samples I have to take before I have hits to n different positions
02:30:37 <TheHunter> @type Data.Complex.magnitude
02:30:39 <lambdabot> Data.Complex.magnitude :: forall a.
02:30:39 <lambdabot> 			  (RealFloat a) =>
02:30:39 <lambdabot> 			  Data.Complex.Complex a -> a
02:31:18 <wli> well, the Norm suggestion seems to work; it might be handy to have it in a lib
02:31:37 <TheHunter> you're right, that sucks.
02:32:45 <wli> well, I like getting stuff done
02:32:49 <wli> and I don't like it when things are in my way
02:32:58 <wli> so when I trip over something that sucks... I complain
02:33:34 <TheHunter> or even class Norm a b 
02:33:39 <TheHunter> | a -> b
02:34:20 <TheHunter> ok, i'm off to lunch.
02:51:20 * wli finds dup f x = f x x immensely useful
02:51:59 <wli> e.g. palindrome = dup $ (==) . reverse
03:17:56 <juhp> hmmm, haddock doesn't seem to build with ghc-6.2.2...
03:18:20 <juhp> HaddockUtil.hs:191: lexical error in string/character literal
03:19:06 * juhp wonders if there is a patch somewhere
03:31:57 <kosmikus> juhp: that's a gcc problem
03:32:05 <juhp> ah
03:33:01 <kosmikus> juhp: the CVS version of haddock probably builds fine
03:35:18 <juhp> kosmikus: is gcc-3.3 ok?
03:35:49 <kosmikus> gcc-3.3 should also work
03:35:57 <juhp> ok, thanks
04:01:44 <bourbaki> moin
04:02:00 <Lemmih> G'day.
04:04:04 <Lemmih> themaximus: Learning Haskell?
04:09:42 <Itkovian> @seen boegel
04:09:42 <lambdabot> I haven't seen boegel
04:10:05 <Itkovian> @type ($)
04:10:06 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
04:10:44 <bourbaki> has anyone of you ever used the arrow loop?
04:11:34 <Itkovian> the what?
04:11:51 <bourbaki> the loop that comes with arrows
04:32:32 <Muad_Dibber> good morning all
04:39:53 <bourbaki> can you construct a recursive function from other frunctions?
04:40:21 <kosmikus> bourbaki: ?
04:40:26 <bourbaki> i mean on the fly
04:40:40 <bourbaki> i have the idea of constuction a recursion with arrows
04:40:44 <bourbaki> from a diagram
04:41:11 <bourbaki> and then you get something like this roughly more or less pseudo code like
04:42:16 <bourbaki> f = test >>> (branch1 <+> (((pure head) &&& ((pure tail) >>> f)) >>> (pure +))
04:43:31 <bourbaki> so if i have some structure of a recursion and want to define the function f in terms of itself i cant do that from scratch at runtime can i?
04:46:37 <bourbaki> kosmikus did you ever use loop from arrows?
04:48:00 <kosmikus> bourbaki: I've barely used arrows; I've only done toy examples so far -- when I did, I also used loop, yes
04:48:20 <bourbaki> kosmikus what did you use loop for?
04:48:21 <kosmikus> but I guess I still don't understand what you're trying to do
04:48:35 <bourbaki> i want to do simple recursion with loop
04:48:39 <kosmikus> bourbaki: some exercise, nothing more, don't remember anything concrete now
04:49:09 <bourbaki> and the structure of the recursion should be mappable to a graph
04:50:07 <bourbaki> ive just tried to do length with loop and my implementation was really trivial not useing the loop properties really
04:52:30 <bourbaki> wb
04:58:38 <musasabi> home..
05:01:53 <Muad_Dibber> :)
05:42:20 <Itkovian> Ok, I have a question for you creative lot.
05:43:10 <Itkovian> We can get four students for one semester (10-12 weeks) to do something groovy. The idea is that they learn something and ideally we would be able to use the fruits of their labour.
05:43:25 <Itkovian> Anything you wanted done, but never had the time to do it?
05:43:29 <Itkovian> :-)
05:44:17 <Itkovian> We have some ideas lying around, concerning traces, simulators, x86 (yuk :-) and some such ...
05:45:57 <Lemmih> TH based library for automatic generation of Haskell binding code to C++ libraries.
05:46:28 <Lemmih> Efficient in-memory backend for HaskellDB.
05:46:34 <tuomov> Vis :)
05:46:43 <tuomov> (but it's too big a project)
05:47:15 <vegai> a haskell implementation with the feature-set of ghc and the performance of O'caml :-D
05:48:47 <musasabi> I think the in-memory database would be quite good (with optional on-disk serialization)
05:51:02 <Lemmih> High level abstractions for all wxWidgets' classes.
05:52:19 <Lemmih> Completion of Cabal and Cabalization of all haskell packages.
05:52:33 <wli> ARGH
05:52:41 <wli> please no more "serialization" abuse
05:53:18 <wli> as someone who has to do what serialization really is on a second-to-second basis I beg of you
05:54:01 * wli ponders flashing Algebra.hs in the direction of the numeric ppl.
05:54:39 <musasabi> I think I will be taking a compiler course which will allow me to legally spend some time hacking a suitable compiler.. Would erlang style binary matching make sense?
05:57:12 <wli> hmm, but it's clunky
05:57:48 <wli> it infers GHC.Num.Num t => t as the type of an integer literal
06:00:30 <Lemmih> And so it should.
06:02:44 <Lemmih> Itkovian: I think shapr has a lot of ideas for improving Haskell.
06:03:10 <wli> nah, it should use whatever fromInteger or fromIntegral is in scope, or some such nonsense.
06:04:54 <Lemmih> wli: I don't follow.
06:06:06 <wli> syntactically expand integer literals to (fromIntegral <hard integer in program text>); then whatever fromIntegral is in scope works.
06:07:27 <wli> *really* easy
06:07:52 <Lemmih> What should that accomplish?
06:08:10 <wli> allowing the use of alternative numeric hierarchies
06:08:32 <wli> well, I'll just have to hack it into ghc
06:08:45 <wli> probably a 1-liner
06:08:56 <Lemmih> I still don't follow.
06:09:01 <Lemmih> @type 10
06:09:02 <lambdabot> 10 :: forall t. (Num t) => t
06:09:05 <Lemmih> @type 10 :: Int
06:09:06 <lambdabot> 10 :: Int :: Int
06:09:10 <Lemmih> @type 10 :: Integer
06:09:11 <lambdabot> 10 :: Integer :: Integer
06:09:28 <Itkovian> anybody knows of any 'simulators' written in Haskell or another FP? I have simple scalar in mind ...
06:09:35 <Lemmih> @type fromIntegral 10
06:09:36 <lambdabot> fromIntegral 10 :: forall b. (Num b) => b
06:09:41 <Lemmih> @type fromIntegral 10 :: Int
06:09:42 <lambdabot> fromIntegral 10 :: Int :: Int
06:09:48 <Lemmih> @type fromIntegral 10 :: Integer
06:09:49 <lambdabot> fromIntegral 10 :: Integer :: Integer
06:10:13 <wli> well, step 1 is import qualified Prelude as P and do the usual abstract algebra-ish treatments of numeric hierarchies. You get GHC.Num.Num t => t despite redefining fromIntegral, fromInteger, and everything else in the universe.
06:11:10 <wli> e.g. you've blown the "native" fromIntegral out of scope with the qualified Prelude
06:11:37 <wli> then you cook up something like fromIntegral :: (MultiplicativeMonoid t, Module Z t, P.Integral t) => Z -> t
06:11:57 <Lemmih> wli: 'fromIntegral' and 'fromInteger' are methods in Integral and Num.
06:12:14 <wli> Lemmih: they've just been blown away by import qualified Prelude
06:12:41 <wli> well, this is at best counterproductive; ghc source digging time
06:13:15 <Itkovian> man this paper is getting crappier with the hour
06:13:35 <vegai> you should read it very very early, then
06:13:50 <wli> I woke up before midnight.
06:14:00 <shapr> I woke up before the midmorning.
06:14:12 <shapr> Itkovian: man, don't you ever sleep?
06:14:13 <Lemmih> shapr: Greetings.
06:14:26 <shapr> Lemmih: gratings and slices!
06:14:56 <Itkovian> shapr: sure I do, it's only 15.18 ... 
06:15:04 <Itkovian> I can hardly sleep at work, can I?
06:15:12 <Itkovian> Unless I take a nap at the loo
06:18:04 <Lemmih> shapr: I'm still having problems with HaskellDB. Feeling like helping a fellow Haskeller?
06:20:08 <shapr> Itkovian: haha!
06:20:11 <shapr> Lemmih: what can I do for you?
06:20:16 <shapr> I still can't build HaskellDB :-(
06:20:32 <shapr> maybe I should rip out CosmicRay's deb
06:20:49 <shapr> but I don't think it's the deb
06:21:41 <Lemmih> shapr: I'm getting Thu Jan 1 01:00:00 CET 1970 from all my timestamp fields.
06:21:47 <wli> hunting for where integer literal processing happens
06:23:40 <wli> Looks like mkIntegerExpr
06:24:37 <Lemmih> shapr: So you aren't able to confirm the possible bug?
06:24:54 <shapr> not until I build HDB
06:25:19 <Lemmih> HaskellDB doesn't build with >= GHC 6.03, btw.
06:26:12 <Lemmih> (Data.Typeable changed its interface)
06:29:14 <wli> found it
06:30:34 <wli> it's explicitly generating varQual pREL_NUM FSLIT(...) garbage
06:31:02 <wli> and what actually shows up is an expression involving plusInteger etc. etc.
06:31:47 <wli> the top-level driver of integer literal expression generation is mkIntegerExpr
06:32:23 <wli> so wrapping that so it generates an unadorned call (i.e. to whichever is in scope) to fromInteger and/or fromIntegral should work there
06:32:35 <wli> so far so good?
06:33:09 <wli> it's in DsUtils.lhs
06:34:09 <wli> no comments?
06:34:37 <wli> well, given how long it takes to build ghc
06:34:42 <Lemmih> wli: Are you aware that fromInteger a method in the Num typeclass and you can achieve a lot by making your own data types instances of Num?
06:35:11 <Lemmih> s/fromInteger a/fromInteger is a/
06:35:27 * boegel greets #haskell
06:35:36 * Lemmih greets boegel
06:35:56 <wli> Lemmih: yes, and I'm also rather painfully aware that the organization of that typeclass doesn't fit a lot of mathematical structures that "normally" use the operators it claims for itself
06:37:00 <wli> okay, let's figure out how I generate a call to fromIntegral
06:37:18 <wli> instead of naked GHC.Num.Num t (which I can see is done with varQual pREL_NUM)
06:37:40 <shapr> hoi boegel 
06:37:50 <shapr> Lemmih: hey, tried it with other backends?
06:38:17 <Lemmih> shapr: No. Good idea, I will try that.
06:39:13 <boegel> hey shapr Lemmih 
06:39:52 <Lemmih> Am I the only one seriously can't understand what wli is trying to achieve?
06:40:59 <wli> Lemmih: Getting integers to show up properly when you write your own numeric hierarchies, i.e. throw away the stock Num, Integral, Floating, etc. classes
06:41:50 <wli> Lemmih: they show up as a type qualified with a typeclass you've gone through extreme pains to circumvent
06:42:02 <Lemmih> What's a numeric hierarchy?
06:42:27 <wli> Lemmih: a system of typeclasses like Num, Integral, Floating, etc. that are used to represent the basic operations on numbers
06:42:43 <wli> last #haskell 99
06:43:58 <balkan> i found "two dozen short lessons in haskell" on the net. it's a lot of pages. almost 300. is it worth the printout?
06:43:59 <shapr> first #haskell 42
06:44:09 <shapr> balkan: some people really like it.
06:44:24 <wli> looks like dsLExpr fun `thenDs` \core_fun -> dsLExpr arg `thenDs` \core_arg returnDs (core_fun `App` core_arg)
06:44:25 <balkan> shapr: it looks very basic.
06:44:29 <tintin> whats is #haskell 42 ?
06:44:35 <Itkovian> balkan: I have a printout next to me ...
06:44:47 <Lemmih> wli: And you can't solve your problem by defining you own datatype?
06:44:52 <balkan> Itkovian: do you regret printing it?
06:44:55 <Itkovian> but it's only 150 pages ...
06:45:00 <TheHunter> wli: would it really be a problem to use the class Num a only as "integer literals can be converted to a" and ignoring (+) etc or setting them to undefined?
06:45:03 <wli> the /last #haskell bit was a typo trying to get the last several lines of output from #haskell on my screen in place of the 50 lines from #debian-devel, #debian-kernel, etc.
06:45:08 <Itkovian> heh, I 'inherited' it from my predecessor
06:45:25 <wli> TheHunter: yes, b/c it clobbers the infix ops these things want to use
06:45:31 <balkan> Itkovian: the question part is 158 pages. the answers are 132 pages.
06:46:17 <tintin> balkan: i am using the yet another haskell tutorial and that seems like a nice book too :)
06:46:33 <balkan> tintin: i don't like that one so much
06:46:36 <Itkovian> ah then the answers are missing :-)
06:46:57 <balkan> Itkovian: you don't have the answers? you need answers.
06:47:07 <tintin> balkan: is it cos its too down to earth ?
06:47:09 <Itkovian> I've never actually read it, I dug it up yesterday in a feeble attempt to clean my surroundings :-)
06:47:12 <wli> hmm, OTOH
06:47:49 <wli> dsExpr (HsLit lit) = dsLit lit <-- with some hacking around that could probably inject a desugared call in there
06:48:06 <wli> provided that desugaring doesn't qualify the name with its module
06:48:27 <wli> (does anyone know offhand?)
06:48:34 <balkan> tintin: no, it's not that. i couldn't learn haskell very good from that book.
06:49:07 <balkan> Itkovian: i don't want to waste good forest printing unncessary stuff.
06:49:55 <Itkovian> then I'd read it on the screen
06:50:19 <balkan> Itkovian: ok
06:51:01 <tintin> craft of functional programming is the dead-tree version i have 
06:52:17 <balkan> i just ordered hudak, haskell school of expression...
06:54:43 <tintin> must be a nice book 
06:54:48 <wli> Hm, I'm stumped
06:55:48 * shapr braches out
06:57:19 <wli> maybe HsOverLit is more relevant
06:59:16 <balkan> wli: could you give the complete title of that book?
06:59:20 <Lemmih> shapr: I'm getting the same result with MySql )-:
06:59:33 <balkan> wli: sorry
06:59:34 <shapr> can you hack up some unit tests?
06:59:41 <balkan> wli: wrong person
07:00:04 <shapr> for example, cast a date into the HaskellDB type and read it directly back out?
07:00:15 <Lemmih> Sure.
07:04:15 <Lemmih> shapr: I've made a small self-contained "select now()".
07:04:42 <Muad_Dibber> kosmikus?
07:04:53 <kosmikus> Muad_Dibber: yes
07:05:03 <wli> okay, looks like it's doing it so late that it generates the name fromInteger qualified with the typeclass for an overloaded literal
07:05:16 <wli> ../prelude/PrelNames.lhs:533:fromIntegerName   = methName numClassName FSLIT("fromInteger") fromIntegerClassOpKey
07:05:29 <shapr> Lemmih: can you dump the query with showQuery? does it appear sane?
07:05:33 <wli> newOverloadedLit orig lit@(HsIntegral i fi) expected_ty
07:05:33 <wli>   | fi /= fromIntegerName       -- Do not generate a LitInst for rebindable synt
07:05:33 <wli> ax.
07:05:35 <Lemmih> shapr: You have successfully used CalendarTimeT fields before, right?
07:05:42 <Lemmih> shapr: Yes.
07:05:49 <shapr> I've had problems with time fields
07:05:55 <shapr> I don't remember the details though.
07:05:58 <Muad_Dibber> i was wondering what a  Hindley-Milner type was?
07:06:05 <wli> notice the numClassName dependency
07:06:15 <shapr> Muad_Dibber: HM is the type system that Haskell uses.
07:06:23 <Muad_Dibber> ah okay
07:06:24 <wli> i.e. it's calling the wrong fromInteger
07:06:34 <shapr> Muad_Dibber: in essence, type systems are simplified automated proof systems.
07:06:35 <Muad_Dibber> and i was interested in how much the talk for tomorrow was related to Generic Haskell
07:06:39 <shapr> y0 CosmicRay 
07:06:44 <CosmicRay> morning shapr
07:06:48 <wli> so it's generating fromInteger already, it's just doing it so late it's required to qualify it
07:06:55 <shapr> evening here, but I hope your morning is good :-)
07:07:22 <MegaMonad> Greetings mr. Goerzen.
07:07:35 <wli> so hoisting this is going to be hairier than I expected
07:07:54 <CosmicRay> haha
07:08:52 <wli> so to circumvent actually doing real work I can hack the generation of the call to the parser
07:08:59 <shapr> CosmicRay: MegaMonad likes you.
07:09:24 <CosmicRay> awww, that's so sweet.
07:09:32 <wli> (i.e. after the brutal hack, HsOverLit never actually happens anymore)
07:09:36 <CosmicRay> MegaMonad: greetings, mr. monad.
07:09:43 <MegaMonad> CosmicRay: Monad, monad on the monad.
07:10:13 <shapr> sounds like the beginning of a poem.
07:10:20 <CosmicRay> heh
07:10:21 <kosmikus> Muad_Dibber: not that much, but it'll be an interesting talk
07:10:35 <Muad_Dibber> kosmikus: figured so
07:10:54 <tintin> .
07:11:04 <shapr> ,
07:11:07 <shapr> really big semicolons!
07:11:08 <kosmikus> Muad_Dibber: I'll be there and ask questions ;)
07:11:20 <Muad_Dibber> kosmikus: i'll be there and just listen :)
07:11:45 <tintin> shapr: :)
07:11:58 <Muad_Dibber> brb
07:12:46 <wli> So I need to build up an expression like HsApp noFsckingClueButSaysFromInteger somethingWithTheIntegerValue
07:13:00 <tintin> map Char.isLower "Hello Haskell" should produce ello askell in the hugs prelude ? 
07:13:47 <arjanb> tintin: if you replace map with filter
07:14:32 <tintin> filter Char.isLower "Hello Haskell"
07:14:33 <tintin> ERROR - Undefined qualified variable "Char.isLower"
07:14:50 <CosmicRay> tintin: import Char, then filter isLower "Hello Haskell"
07:14:55 <CosmicRay> or import qualified Char
07:14:58 <CosmicRay> then your command will work
07:16:25 <shapr> man, I cannot focus :-(
07:16:40 <tintin> i get the same error for import qualified Char ...
07:16:54 <shapr> fookit, I'll try the latest ion3 not-even-yet-experimental debs
07:17:20 <tintin> shapr: you are looking for a wm ? use xwem :) 
07:17:35 <shapr> I *like* ion
07:17:39 <shapr> I already use it.
07:17:57 <shapr> I just want all the extra goodies like the dock and stuff that hasn't yet made its way into the debs.
07:18:05 <tintin> shapr: xwem is emacs lisp :) and lovely www.xwem.org 
07:18:14 <shapr> oy, I strongly dislike elisp
07:18:27 <shapr> admittedly, I've written bunches of it.
07:18:37 <shapr> but I'd rather write Haskell
07:18:41 <shapr> I want Yi!
07:18:45 <shapr> Yi Yi Yi!
07:18:46 <tintin> .
07:18:48 <shapr> ,
07:18:56 <shapr> Yi!
07:19:04 * shapr /= focussed
07:19:24 <shapr> MegaMonad: randomness and chipmunks side by side in a glassy pond.
07:19:30 <MegaMonad> shapr: Side of a in the building across the pond.
07:19:49 <shapr> MegaMonad: the naif jolie femme en puhu svenska
07:19:56 <MegaMonad> shapr: En has a fix for the svenska specific content.
07:20:00 <tintin> import Char        should work with hugs ? 
07:20:54 <tintin> unexpected keyword import ... :( 
07:20:54 <shapr> I think I just had a flat brain. Sort of like having a flat tire, but it's even more messy and I don't have a spare.
07:21:01 <shapr> try import Data.Char
07:21:08 <shapr> and try it in a file, not the prompt
07:21:37 <tintin> hmmz ok 
07:22:23 <Lemmih> tintin: Or :l Char from the prompt.
07:23:38 <CosmicRay> I think that has to be :m for ghci
07:24:14 <wli> LHsExpr id is Located (HsExpr id) so far so good
07:24:25 <wli> RdrName I want Unqual
07:24:51 <tintin> CosmicRay: i am in Hugs98
07:25:04 <tintin> should i be using ghci to learn ? 
07:25:09 <CosmicRay> hugs will be fine
07:25:13 <wli> OccName I've got NFI about
07:26:20 <wli> Okay, OccName VarName EncodedFS and EncodedFS is a FastString
07:27:22 <wli> mkFastString :: String -> FastString will do
07:27:53 <wli> and I've lost the train of thought connecting this to whatever I was trying to do
07:28:13 <Muad_Dibber> back
07:36:07 <babybo0m> hi :)
07:36:16 <Boegel> hey
07:36:44 <babybo0m> if I have eg. a type declared Order = (String, String, Int, String) , how can I get the Int out of that? can i use some sort of index?
07:39:05 <TheHunter> pattern matching: getIntOutOfOrder (_, _, i, _) = i
07:41:07 <babybo0m> hmm....and if i declare to be Order = (Ordername, Itemname, Ordernr, Orderdate)   with Ordername = String  etc can i do it in another way? 
07:42:16 <TheHunter> an algebraic datatype is probably better suited: data Order = Order { odername :: String, itemname :: String, ... }.
07:42:42 <TheHunter> then you get Order :: String -> String -> int -> String -> Order, ordername :: Order -> String, etc.
07:43:09 <babybo0m> ok,thanks :)
07:43:30 <tintin> import Data.Char
07:43:30 <tintin> map Char.toUpper "Hello Haskell"
07:43:45 <tintin> i still get an unexpected symbol "Char.toUpper ...
07:44:05 <tintin> its in a file map.hs and i load it into hugs with :load map.hs ...
07:45:11 <TheHunter> i think both map Data.Char.toUpper ... and map toUpper ... would work.
07:46:03 <tintin> everything seems to be a syntax error here ...
07:47:22 <TheHunter> maybe there's an error in a line above.
07:48:03 <TheHunter> hugs doesn't give you very good error messages, in my experience.
07:48:20 <tintin> those are the only two line i have in the file 
07:48:29 <tintin> import Data.Char 
07:48:45 <tintin> map Char.toUpper "Hello Haskell"
07:49:03 <TheHunter> tintin: you have to define a function:
07:49:09 <TheHunter> test = map Char.toUpper "Hello Haskell"
07:49:19 <TheHunter> and then type `test' at the hugs prompt
07:58:05 <wli> well, if anyone's up for dumb ghc questions, I've got one
07:58:25 <Itkovian> gotta go
07:58:33 * Itkovian escaped wli's questions just in time
07:59:50 <Boegel> wli: shoot
08:00:29 <wli> Boegel: in aexp2 in Parser.y.pp I've got L1 (HsOverLit $! mkHsIntegral (getINTEGER $1)) ... now, I want to turn this into an HsApp of fromIntegral to the integer constant, so how do I "prep" the args of HsApp?
08:01:19 <wli> likewise for the HsOverLit in the RATIONAL case
08:02:13 <Boegel> wli: this is too much for me, sry :p
08:02:24 <wli> Boegel: okay
08:02:25 <arjanb> i guess only the Simon's can answer these questions
08:03:14 <wli> arjanb: hmm, that can't be true, the HsSyn stuff has been fiddled with by others
08:04:42 <wli> in fact
08:04:45 <wli> it has to have been
08:04:50 <wli> because it's been made into a library
08:05:01 <wli> because it's been made into a library
08:06:18 <wli> (in fact, I've fiddled with HsSyn myself before, but I only used a small subset of it)
08:07:20 <wli> (one of the stock parsers in the libraries emitted HsSyn for parse trees and I used it for some calculator-like thingie that had some microscopic subset of Haskell syntax)
08:23:27 <Lemmih> I so hate when they change the interface for parts of the hierarchical libraries.
08:26:13 <Igloo> Only use stable libraries then  :-)
08:28:30 <Lemmih> Igloo: The updated libraries breaks HSQL and it's used by several other projects.
08:30:06 <Lemmih> I would like to see more use of the WARNING pragma.
08:30:58 <Igloo> Lemmih: If they wreen't declared as stable then you don't have a right to complain. Perhaps ghc should emit a warning if non-stable libraries are used, though
08:34:08 <CosmicRay> Igloo: that would make -Werror useless
08:34:22 <CosmicRay> Igloo: it seems like that majority of libraries aren't declared stable
08:35:23 <Igloo> You could hack around that with another flag. In fact, an entire set of such flags might be worthwhile
08:35:48 <Igloo> -fno-Werror-* or something
08:37:21 <Lemmih> Igloo: Yeah, I know I can't complain but wasting some hours trying to figure it out left my a little cranky. (-:
08:37:40 <CosmicRay> Igloo: any news from ftpmasters on the mips issue?  iirc, that one thing is keeping haskell-cabal and everything that depends on it from testing
08:37:57 <CosmicRay> Igloo: "everything that depends on it" being a fair bit of stuff by now
08:38:06 <Igloo> I know the feeling - TH has been a bit of a moving target for me  :-)
08:38:26 <Igloo> CosmicRay: I believe the hat/nhc situation also needs to be sorted out
08:39:15 <CosmicRay> according to http://packages.qa.debian.org/g/ghc6.html, it's the mips problem only
08:39:27 <CosmicRay> ah foo.
08:39:38 <Igloo> That's because the scripts don't look at "makes foo uninstallable" if the package isn't a candidate
08:40:31 <CosmicRay> bah, that's annoying.
08:40:48 <CosmicRay> is the hat issue #282873?
08:41:15 <Igloo> Yes
08:41:36 <wli> still looking for someone who knows HsSyn
08:41:49 <musasabi> from ghc sources?
08:42:02 <wli> musasabi: yes
08:42:18 <CosmicRay> Igloo: could the binary deb for nhc98 be skipped on sparc?
08:42:20 <Igloo> I don't /think/ nhc98 failing to build on m68k is related to the hat problem, and it also shouldn't be relevant for the sarge migration
08:43:04 <Igloo> It could
08:43:05 <wli> musasabi: I'm trying to blow away the HsOverLit stuff in favor of generating fromIntegral (literal) 
08:43:19 <CosmicRay> Igloo: is that viable?  it sounds like nhc98 is hosed on sparc anyway
08:43:42 <wli> musasabi: except I'm failing miserably at determining how to build up the expression
08:43:46 <Igloo> Ohh, it doesn't look like nhc98 was in woody at all
08:43:51 <Igloo> s/hh/dd/
08:44:06 <CosmicRay> Igloo: correct
08:44:12 <musasabi> wli: I know it in a very superficial way..
08:45:29 * Igloo will contemplate a bit more and probably file a bug for removal on sparc
08:45:35 <wli> musasabi: well, the "transformation" is basically changing something that builds up HsOverLit "0" to something that builds up HsApp "fromIntegral" (HsLit "0") or similar (thing is, I don't know wtf the arg position for HsApp needs to be
08:46:11 <CosmicRay> Igloo: you should then make a new upload that excludes sparc nhc98 in the hat build
08:46:13 <musasabi> have you looked at hsSyn/HsExpr.lhs ?
08:46:19 <musasabi> That defines those iirc
08:46:32 <wli> musasabi: and similarly I'm not sure what on earth is expected of a function expression either
08:47:13 <wli> musasabi: oh, it's more a semantic thing, i.e. which things make sense to the rest of ghc; cramming in something plausible that typechecks I can probably do on my own without spending a lot of time on it.
08:48:05 <wli> musasabi: actually HsExpr.lhs didn't help very much b/c it was mostly monadic transformers etc.; the parser stuff told me more of how to construct things
08:49:14 <wli> I've yet to decipher the ppr stuff
08:49:23 <musasabi> ppr is easy.
08:49:52 <musasabi> I have changes to add a simple new syntax till the hsexpr point if you are interested.
08:50:08 <wli> musasabi: that would probably help
08:50:58 * musasabi generates a diff
08:51:06 <wli> musasabi: what I'm trying to do is several orders of magnitude simpler, so ...
08:51:26 <wli> I wonder what SDoc is
08:52:34 <wli> hmm, seems to have something to do with printing stuff, though what I have no idea
08:53:42 <wli> maybe literate programming -related (SDoc == 'S' (?) "Documentation" ??)
08:54:47 <wli> musasabi: if you've got anything that would give me hints on how to bang out a subkinding patch, I'd be very interested
08:55:10 <wli> (while you're offering hints wrt. ghc internals...)
08:55:51 * musasabi is waiting for darcs to churn out a diff
08:56:57 <wli> darcs repo of ghc? probably almost as bad as the kernel
08:58:17 <wli> well, ghc is a lot smaller than the kernel actually
08:59:40 <paf> wli: have you ever used HaskellDSP?
08:59:54 <musasabi> wli: http://www.cs.helsinki.fi/u/ekarttun/haskell/d.diff
09:00:07 <wli> paf: nope, never even heard of it
09:00:42 <musasabi> darcs works quite nicely with ghc.
09:00:58 <paf> wli: http://haskelldsp.sourceforge.net/doc/index.html
09:01:14 <paf> it's a librairy
09:01:41 <paf> it looks noce but i can't figure out how to install it (I have GHC)
09:01:45 <paf> *nice
09:02:27 <wli> paf: I'm probably the last person to ask for help figuring out how to get things with compiler/etc. version skew to build; I can't get past any of that stuff for my own purposes
09:04:28 <CosmicRay> is an IORef lazy?
09:04:40 <CosmicRay> that is, can I put something into it without forcing its evaluation immediately?
09:06:55 <CosmicRay> same question goes for an MVar.
09:08:38 <musasabi> CosmicRay: no.
09:08:45 <CosmicRay> neither one is lazy?
09:08:48 <musasabi> the evaluation is not forced.
09:08:55 <CosmicRay> oh, they both are lazy then?
09:09:00 <musasabi> yes.
09:09:06 <CosmicRay> Is an IORef thread-safe?
09:09:13 <musasabi> Try writeIORef ref undefined ;)
09:10:06 <paf> do someone knows how to compile and add a librairy to GHC?
09:10:22 <Lemmih> paf: Checkout ghc-pkg.
09:10:39 <Lemmih> Or wait for Cabal. (-:
09:10:39 <musasabi> paf: see Cabal.
09:10:50 <musasabi> Cabal is quite usable at the moment.
09:11:05 <musasabi> (but do get it from darcs the tarbal is iirc quite old)
09:11:25 <Lemmih> musasabi: I'm quite sure that HaskellDSP isn't cabalized.
09:12:55 <Lemmih> paf: You can do a good deed and cabalize it.
09:13:11 <paf> Lemmih: never read something saying it is 
09:14:57 <wli> is there a cabal deb?
09:15:14 <paf> Lemmih: how would you use ghc-pkg to install haskelldsp?
09:16:18 <Lemmih> paf: Create a package file and do: ghc-pkg -a -i PKG-FILE
09:16:49 <CosmicRay> wli: yes
09:16:52 <CosmicRay> wli: libghc6-cabal-dev
09:17:20 <wli> thanks
09:18:38 <wli> So if I bang out a bunch of "special functions" (I need them for generalized farting around anyway) I presume I should backpropagate those.
09:19:19 <Lemmih> paf: http://haskell.org/ghc/docs/latest/html/users_guide/packages.html#PACKAGE-MANAGEMENT
09:21:22 <musasabi> What would be good syntax for binary matching? Erlang uses syntax like <<_:8, Foo:16, Bar:32/binary>>...
09:21:39 <paf> Lemmih: Thanks, I was on http://www.cs.mu.oz.au/fpu/ghc-guides/set/packages.html
09:26:08 <musasabi> Using "<<" pattern {',' pattern} ">>" might be too close to the monadic notation.
09:28:38 <musasabi> [# #] perhaps..
10:32:51 <CosmicRay> Question: what is a good datatype to use for a variable-size in-memory mutable buffer?
10:33:06 <CosmicRay> I'm looking at Data.Array.MArray but it seems to be fixed-size
10:33:26 <CosmicRay> oh, I need fast random access to indexed elements, so a list is not the best choice
10:34:23 <Lemmih> Hash table?
10:34:38 <CosmicRay> and use an Int or something as the key?
10:35:01 <Lemmih> Yes.
10:35:29 <CosmicRay> I suppose that could work.  Seems like truncation would take longer, but that's not as big a deal.
10:35:59 <CosmicRay> incidentally, why does FiniteMap not take a custom hashing function?
10:37:14 <Heffalump> FiniteMap doesn't hash, does it?
10:37:20 <Heffalump> it makes a binary tree
10:37:25 <CosmicRay> ah.
10:37:44 <CosmicRay> that would explain why it's still faster than association lists.
10:39:09 <Heffalump> should be log n for most stuff
10:39:24 <Heffalump> but it requires an Ord instance, whereas association lists just require Eq
10:39:37 <CosmicRay> a hashtable seems a large overhead for simply storing a string though.  hm.
10:39:45 <CosmicRay> true
10:39:52 <Heffalump> I'm missing context here.
10:40:05 <CosmicRay> I just need an in-memory string buffer than can shrink and expand.
10:40:37 <CosmicRay> I need quick indexing but I don't need intermediate insertion
10:40:47 <CosmicRay> I also need the ability to modify any character
10:41:05 <CosmicRay> this is all happening in the IO monad.
10:41:48 <musasabi> CosmicRay: you probably want a rope.
10:41:54 <CosmicRay> so the lazy (effort-wise) way woudl be to use an IORef String.  But indexing will suck and modifications will be bad too.
10:41:55 <CosmicRay> musasabi: heh
10:42:18 <Heffalump> how about some kind of counted binary tree?
10:42:25 <musasabi> So it will either work, or you can hang either yourself or me.
10:42:58 <Heffalump> or a balanced binary tree with single characters at the leaves
10:43:08 <musasabi> no..
10:43:31 <tintin> do hugs and ghc preludes behave differently ?
10:43:38 <musasabi> A tree of IOUArray Int Char ;)
10:43:42 <CosmicRay> Heffalump: well yeah, I could do that.  I guess my question was: does Haskell already have a data type that does this for me, and the answer seems to be no.  So I'll devise one
10:43:45 <CosmicRay> musasabi: evil :-)
10:43:51 <CosmicRay> tintin: they shouldn't
10:44:01 <CosmicRay> tintin: if they diverge, it's probably a bug in one of them
10:44:04 <Heffalump> a finitemap from positions to characters wouldn't be a horrendously inefficient representation
10:44:09 <musasabi> but note that Char is 32bits still..
10:44:31 <CosmicRay> good point, and that is as it should be since I may be storing Unicode
10:44:31 <tintin> CosmicRay: ghc just seems to know howto handle filter Char.isUpper "Haskell Hello " ... 
10:44:42 <Heffalump> you could either use IORef (FiniteMap Int Char) or IORef (FiniteMap Int (IORef Char)) depending on precisely what you want
10:44:58 <CosmicRay> tintin: what do you mean, "just know"
10:45:04 <tintin> maybe i got a crappy hugs installation here 
10:45:15 <CosmicRay> tintin: did you import Char?
10:45:24 <tintin> CosmicRay: no 
10:45:28 <tintin> it dosnt work 
10:45:29 <CosmicRay> tintin: that's your problem.
10:45:38 <CosmicRay> what do you mean?
10:45:53 <tintin> i tried that too same error but ghci works 
10:45:53 <CosmicRay> tintin: it would make it far easier for people to help you if you included actual error messages
10:46:00 <CosmicRay> what error?
10:46:25 <CosmicRay> and are you putting this into a file, or typing it interactively?
10:46:32 <tintin> undefined qualifeid variable Char.isUpper 
10:46:44 <musasabi> tintin: import Char
10:46:47 <tintin> yes i tried both 
10:46:49 <CosmicRay> import qualified Char
10:46:54 <CosmicRay> if he wants to refer to it that way.
10:46:58 <musasabi> true.
10:47:03 <vegai> "Designer style Sunglasses for haskelldoc@haskell.org" -- these guys know where to find really cool people
10:47:14 <Lemmih> tintin: GHC and Hugs are different. GHC allows you to use functions from a module without importing if you qualify its name, Hugs doesn't.
10:47:21 <CosmicRay> tintin: you must either use "import qualified Char" or use "import Char" and drop the "Char." before isUpper
10:47:40 <CosmicRay> Lemmih: GHC the compiler doesn't, afaik
10:47:50 <CosmicRay> Lemmih: in fact, I don't think ghci does either.  could be mistaken....
10:48:02 <CosmicRay> or maybe it has something to do with packages.
10:48:32 <Lemmih> CosmicRay: GHCi does, GHC doesn't.
10:48:39 <CosmicRay> ah.
10:48:42 <CosmicRay> that could be it.
10:49:06 <tintin> import wont work interactively ?
10:49:20 <CosmicRay> tintin: no, you must use :l as someone told you a couple of hours ago
10:49:23 <Lemmih> tintin: 'import' is not an expression.
10:49:31 <musasabi> :mod +Char
10:49:38 <CosmicRay> (didn't we have this discussion earlier?)
10:50:12 <tintin> CosmicRay: i tried putting it into a file and posted the error messages ....
10:50:30 <CosmicRay> and you got the error message when loading the file?
10:50:57 <tintin> ERROR "filter.hs":2 - Undefined qualified variable "Char.toUpper"
10:51:08 <tintin> and i have Import Char as the first line 
10:51:33 <CosmicRay> tintin: like I said, you must make that import qualified Char if you are going to refer to Char in that manner.
10:52:55 <tintin> prelude changes the Main> 
10:53:13 <tintin> when i put in import qualified Ghar
10:53:23 <tintin>  /s /the /to
10:53:27 <Lemmih> tintin: That's good.
10:54:01 * tintin just stared with haskell a few hours ago 
10:54:28 <tintin> so where will the output go ?
10:54:40 <CosmicRay> you can call it itneractively
10:55:23 <CosmicRay> $ cat > foo.hs
10:55:23 <CosmicRay> import Char
10:55:23 <CosmicRay> temp = filter isUpper
10:55:34 <CosmicRay> $ hugs foo.hs
10:55:39 <CosmicRay> Type :? for help
10:55:40 <CosmicRay> Main> temp "Haskell Hello "
10:55:40 <CosmicRay> "HH"
10:56:10 <tintin> ah tnx that worked finally 
10:56:31 <tintin> tnx a lot CosmicRay, Lemmih , musasabi :)
10:56:50 <CosmicRay> glad to help
11:35:49 <CosmicRay> @index truncate
11:35:51 <lambdabot> GHC.Real,Prelude
11:35:56 <CosmicRay> @index fTruncate
11:35:57 <lambdabot> bzzt
11:36:01 <CosmicRay> @idnex truncateFile
11:36:01 <lambdabot> Sorry, I don't know the command "idnex", try "lambdabot: @listcommands"
11:36:05 <CosmicRay> @index truncateFile
11:36:06 <lambdabot> bzzt
12:00:32 <Darius> Well we all knew that. (regarding LtU's top entry)
12:00:48 <Heffalump> about Olivier?
12:03:10 <Darius> Yes
12:21:33 <retardo> I had never heard of him.
12:22:10 <Heffalump> careless of you :-)
12:22:49 <retardo> Yes, I agree.  You would think I would have run across him since I do read a lot of papers in his research area.
12:24:32 <Darius> retardo: He's a veritable gold mine.  One can just simply follow him around for cool things to read.
12:25:12 * Darius knows most of the names for the top 10 individuals, but not a few.
12:25:23 <Heffalump> I'd only heard of Goldberg vaguely.
12:25:28 <retardo> Where's the top 10 list?  I have only seen an article in Nature that mentions Danvy.
12:25:31 <Heffalump> It's interesting that they're mostly programming languages people.
12:25:58 <Darius> retardo: Check the LtU comments
12:26:33 <Darius> Heffalump: He's one I don't know.  I wouldn't have known Frank Pfennig if this had been done a month or two ago.
12:26:42 <retardo> It just now dawned on my what LtU stands for.
12:26:56 <Heffalump> who is Tom Mitchell?
12:27:04 <Darius> That's another.
12:27:08 <Heffalump> oh, I mean Goldreich, sorry.
12:27:21 <Heffalump> I think he might have co-authored the paper on the impossibility of obfuscation, BICBW
12:27:49 <Darius> The only Mitchell I can think of is Mitchell Wand.
12:28:01 <Heffalump> ah, yes, he did.
12:28:19 <Heffalump> I couldn't easily place what Moshe Vardi does, though the name rings bells.
12:28:38 <Heffalump> I've never heard of Avi Wigderson
12:28:46 <Heffalump> or Noga Alon
12:29:08 <Heffalump> but Pierce downwards is outside the top 10
12:43:03 * basti_ curries himself
12:43:48 <retardo> Vardi rings a bell for me, but I know I'm thinking of Ilan Vardi.
12:52:09 * basti_ burns some expressions
12:53:01 * basti_ meditates over the haskell curry isomorphism
12:57:40 * basti_ waits for enlightenment
12:58:23 * Riastradh hands basti_ a beer to test out a theory he heard that, if you attain total enlightenment while drinking beer, beer will shoot out your nose.
12:59:10 <Maddas> Haha
13:14:17 <kosmikus> the haskell curry isomorphism?
13:14:39 <basti_> yes
13:14:47 <basti_> this is that any program is a proof too.
13:14:50 <basti_> and vice versa
13:15:03 <basti_> a proof without "tertium non datur" though
13:15:05 <Heffalump> curry-howard isomorphism..
13:15:48 <basti_> uhm
13:15:58 <basti_> sorry
13:16:05 * basti_ is a litte uhm
13:16:12 <Riastradh> Drunk?
13:16:37 <basti_> hmmm
13:16:42 <basti_> how do you say
13:16:55 <basti_> if you, hypothetically, basically, smoked weed?
13:17:02 <Riastradh> Stoned.
13:17:08 <basti_> yes.
13:17:13 <basti_> that sounds a litte blunt though
13:17:45 <basti_> i was meaning curry howard isomorphism
13:17:56 <basti_> some people didnt believe me
13:17:56 <kosmikus> ah, ok
13:18:04 <basti_> that was a very bizarre experience
13:18:16 <basti_> "what? i thought i need a program and the proof that it works"
13:18:24 <basti_> "uhm well its... uhm builtin correctness?"
13:18:26 <Riastradh> Pondering the Curry-Howard isomorphism while stoned is a very bizarre experience?
13:18:31 <basti_> "april fools day huh?"
13:18:54 <basti_> that too.
13:19:03 <basti_> np: Garbage - As Heaven Is Wide
13:19:10 <basti_> helps though
13:19:24 * Riastradh wonders what his code would look like if he were stoned while writing it...
13:19:42 <basti_> i make music while stoned now and then
13:19:51 <Spark> i wrote some sml while stoned once
13:19:56 <Spark> got 99% for it :)
13:20:14 <basti_> =)
13:21:02 <monochrom> some people are very dumb
13:21:13 <basti_> most people are pretty dumb.
13:21:38 <monochrom> alright, not a fair statement.
13:21:38 <Maddas> Everybody is a little bit dumb.
13:22:28 <monochrom> some people are very stubborn, that's the real problem.  I am dumb too, but I have patience to listen out on you before I ridicule you.
13:59:49 * retardo is away: home
14:08:47 <Philippa> ohboy
14:08:58 <Philippa> you get some really, really screwy errors if you fuck up a type in a .hi-boot
14:12:59 <Pseudonym> I can imagine.
14:13:06 <Pseudonym> Did you get a type error or a crash?
14:16:24 <Philippa> type error
14:16:27 <Philippa> really confusing though
14:17:02 <Philippa> I was exporting a Maybe String, which I'd still got typed as a String in the .hi-boot. Was using it as a scrutinee in a case expression
14:24:11 <Philippa> anyway, Flippi now has the one explicit Config module, though there's still need to rewrite PageTemplates and/or DeWikify for the relevant bits atm
14:59:51 <Philippa> argh
14:59:53 <Philippa> fucking GHCi
14:59:55 <Philippa> GHC, even
15:00:12 <Philippa> doesn't fucking check the contents of the .hi-boot match the inferred type when it actually builds the damn module
15:00:16 <Philippa> so much for type-checking
15:03:41 <Heffalump> .hi-boot isn't part of the language, though :-)
15:04:03 <Philippa> sure, that's no excuse for sloppy semantics for Haskell 98 + .hi-boot though
15:04:14 <Philippa> it causes invalid programs to compile
15:04:27 <Heffalump> ah, ok.
15:05:09 <Philippa> for now I've slapped an explicit type signiature on the stuff mentioned in the .hi-boot so it gets caught during module compilation, but I shouldn't have to
15:05:18 <Philippa> it's a config module, type annotations're just confusion for end-users
15:07:12 <Heffalump> how about putting the .hi-boot on the other module?
15:07:31 <Philippa> very, very painful
15:07:38 <Philippa> the config module only needs to .hi-boot one value
15:07:58 <Philippa> the other module needs to .hi-boot a large number of values which is regularly added to atm
15:08:06 <Pseudonym> .hi-boot is sloppy semantics by definition, surely?
15:08:31 <Philippa> I dunno, forward declarations're reasonably well-recognised
15:08:39 <Pseudonym> Oh, now here's an idea.
15:08:40 <Philippa> but yeah, not having to write one at all would be good
15:08:45 <Pseudonym> .hi-boot auto-generator
15:08:51 <Philippa> :-)
15:08:55 <Pseudonym> :-)
15:09:00 <Philippa> write it and I'll use it...
15:09:47 <Pseudonym> You build a toilet seat out of solid gold and _I'll_ use it.
15:10:04 <Philippa> though I'd need it to handle implicitly typed stuff that doesn't refer to the modules in the import cycle either
15:10:59 <Darius> There's a toilet in China, I believe, that is solid gold or something like that.
15:11:30 <Pseudonym> There you go.
15:11:38 <Pseudonym> Next time I'm in China...
15:11:49 <babybo0m> hrm... i need to make dataflow diagrams for school.. can anybody tell me what they are and how i can make them? (pref. which software, like rose)
15:12:41 <Pseudonym> There are lots of different standards for dataflow diagrams.
15:12:43 <Pseudonym> Any hints?
15:13:21 <babybo0m> i need to show the relation between the functions and their inputs outputs i think
15:13:26 <Pseudonym> This is the one I was taught:
15:13:27 <Pseudonym> http://www.smartdraw.com/tutorials/software-dfd/dfd.htm
15:14:09 <Pseudonym> Does that look familiar?
15:14:12 <babybo0m> hmm they look kinda familiar yeah
15:14:28 <Pseudonym> Some Rational product or other probably does it.
15:14:42 <Pseudonym> I think they've officially subsumed the last independent design methodology.
15:14:59 <babybo0m> ok, thanks
15:15:50 <Pseudonym> Ah, yes.
15:15:53 <Pseudonym> http://www.xpexaggerated.com/
15:20:23 <wilx`> Hmm.
15:20:31 <wilx`> What is the name of the Haskell editor?
15:20:37 <wilx`> Something starting with Y.
15:20:37 <Heffalump> HaRe? yi?
15:20:46 <wilx`> Yi.
15:26:03 <wilx`> Hmmm, no binaries :/
15:26:24 <Pseudonym> Nope.
15:26:35 <Heffalump> Philippa was having trouble building it a few days ago, IIRC.
15:27:05 <Philippa> yep, though largely through carelessness
15:30:17 <Pseudonym> Even so.
15:30:21 <Darius> Philippa: Did you fiddle with hs-plugins or compile statically?
15:30:30 <Pseudonym> Some things are harder than they need to be to build.
15:30:36 * Pseudonym coughs... GHC... cough cough...
15:33:45 <Philippa> Darius: both. I got it working in the end
15:34:00 <Philippa> 'course, there's not a lot I can do for win32 yet, I'd have to find an appropriate curses port
15:34:15 <Philippa> (I was building on my somewhat borked Debian install)
15:34:43 <Darius> ah
15:36:20 * esap just wrote an article to wikipedia about object identity http://en.wikipedia.org/wiki/Identity_%28object-oriented_programming%29
16:26:45 <Itkovian> night :-)
16:26:59 <Itkovian> @seen wli
16:26:59 <lambdabot> wli is in #darcs and #haskell.
16:27:08 <Itkovian> yeah but is he active ...
16:27:09 <Itkovian> :-)
16:39:36 <Janni> G'evening
17:39:20 <wagle_gone> how do you create a Set such that the elements of type t MUST have the Eq t property?
17:41:05 <np_hard> wrap the Library set?
17:41:57 <dons> don't sets already have an Eq constraint, (implied by the Ord constraint)?
17:42:40 <wagle> where are they?
17:43:08 <dons> just looking through the libraries page for Set, I see: Eq a => Eq (Set a)  
17:43:41 <np_hard> heh, you're right
17:45:14 <dons> wagle: you got the library docs? 
17:45:33 <wagle> trying to find them now
17:45:38 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
17:46:31 <wagle> the first problem is trying to define "instance Functor Set"
17:46:56 <np_hard> is something wrong with the library Sets?
17:47:25 <dons> well, Sets are in terms of FiniteMaps, and FMs have:
17:47:25 <dons> instance Functor (FiniteMap k) where
17:47:26 <wagle> naively trying to define set Monads
17:47:26 <dons>   fmap f = mapFM (const f)
17:48:23 <dons> so you could use mapSet (maybe ?)
17:48:25 <wagle> .. which falls down because the type of f in fmap f can be of any type a -> b
17:49:52 <wagle> and you cant remove duplicate elements if you dont know that Eq b
17:50:56 <wagle> so, half of this exercise is just figuring out if there is a way to do this, or at least completely understanding why not
17:52:28 <Lunar^> dons: Hey, you! :)
17:52:35 <dons> hey you!
17:52:45 <Lunar^> dons: Have you take a look at the undo library posted on MLs recently ?
17:53:18 <dons> yep. I wrote Arjan an email about it. He seemed interested in the reversability property of the yi implementation
17:54:38 <dons> his design doesn't use invertable actions, which seemed a bit strange
17:54:40 <Lunar^> dons: Is it suitable for Yi?
17:55:04 <dons> I don't think so (it's boxed and too inefficient) -- anyway, we have our own library now
17:55:05 <Lunar^> dons: What? There is already undo support in Yi?!
17:55:09 <dons> yeah!
17:55:14 <Lunar^> damn :)
17:55:21 <Lunar^> That is going way to fast.. :)
17:55:24 <dons> based on a paper from 1994
17:55:33 <Lunar^> You damnly should work on hOp :)))
17:56:06 <dons> there's way too much going on for me to work on it atm, but one day...
17:56:10 <Philippa> oh damn, I just missed a load of context, didn't I?
17:56:21 <wagle> if emacs is an os, yi has to be, too?
17:56:30 <dons> ah, true.
17:56:41 <dons> maybe we should just *merge* hOp and Yi ...
17:56:44 <wagle> Philippa: more fun that way
17:56:57 <dons> hehehaha. evil laugh
17:58:05 <wagle> where do you find the implementations of the .hi files?
17:58:13 <wagle> .. source..
17:58:22 <dons> of which source files?
17:58:37 <dons> yi?/
17:59:07 <wagle> /usr/local/lib/ghc-6.2.1/hslibs-imports/data/Set.p_hi
17:59:25 <wagle> aigh, i'm obsooolete!
17:59:38 <dons> not too obsolete. it probably hasn't changed
17:59:48 <Lunar^> dons: :)))
18:00:11 <wagle> i know, just that someone was recommending 6.2.3 for something else i felt interested in yesterday
18:00:26 <dons> there isn't any 6.2.3 :)
18:00:36 <wagle> and that 6.2.1 wouldnt work..  
18:00:45 <dons> we have 6.2.2 and 6.3 ;)
18:00:50 * wagle send SIGMEMFAULT
18:01:47 * wagle wears his trousers rolled
18:02:28 <wagle> see?  toldya
18:03:00 <wagle> anywho, wheres the source?
18:03:21 <dons> for Data.Set.hs?
18:03:59 * wagle wonders where he was being ambiguous, wanting to correct that
18:04:26 <wagle> ie, yes..  
18:04:28 <dons> oh, sorry, I keep getting confused, because I'm thinking about yi source :}
18:05:16 <Darius> wagle: source for Data.Set is essentially type Set a = FiniteMap a () if I remember correctly and it hasn't changed since then.
18:05:55 <dons> yep! newtype Set a = MkSet (FiniteMap a ())
18:06:43 <wagle> whered you find that?
18:07:13 <dons> in $fptools/libraries/base/Data/Set.hs
18:07:35 <Darius> You can get the source code for the heirarchical libraries at the cvs repo with GHC.
18:07:36 <dons> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/Set.hs
18:07:50 <Darius> That one.
18:08:10 * wagle shoots the macosx locate command
18:08:21 <wagle> /Users/wagle/Desktop/Downloads/_OLD_uncategorized/ghc-6.2.1/libraries/base/Data/Set.hs
18:08:32 <wagle> bwhaha
18:09:21 <wagle> i'd _tried_ to locate it
18:09:49 <wagle> i coulda sworn i'd seen the sorce on my machine
18:11:17 <dons> hmm. there's some new Data/* libraries appearing. Data.Version, for example
18:21:29 <Pseudonym> http://poserpros.com/forums/files/8317_1103123404.jpg
18:21:38 <Pseudonym> I'm sure there's a joke in there somewhere, but damned if I can find it.
19:13:59 <marcot> Hello, is there a function in Haskell that returns the factors of an Integer?
19:14:09 <jdrake> wagle, I am afraid that source is property of 
19:14:17 <jdrake> SCO, you will be billed for a license fee
19:14:55 <Darius> marcot: Not in the standard libraries.
19:16:33 <np_hard> hmm
19:16:39 <np_hard> maybe we should add one
19:16:45 <np_hard> to make instructors be more creative
19:23:29 <Pseudonym> marcot: Here's a hint.  List comprehensions.
19:23:42 <Pseudonym> It's a one-liner, and not a complex one at that.
19:24:02 <Pseudonym> For small Integers, anyway.  For large Integers, if you can find an efficient one-liner, please apply for your PhD.
19:24:37 <marcot> Pseudonym: I want something like factor from unix's coreutils
19:25:01 <marcot> marcot@tonhao:~/desenvolvimento/java/algebra$ factor 413290419284712
19:25:01 <marcot> 413290419284712: 2 2 2 3 17220434136863
19:25:17 <marcot> This kind of stuff..
19:25:35 <marcot> How can i use this factor program in a haskell program?
19:27:48 <Pseudonym> @eval filter (\f -> 413290419284712 `mod` f == 0) primes
19:28:07 <lambdabot> out of fuel - use @resume to continue
19:28:09 <Pseudonym> @resume
19:28:27 <lambdabot> out of fuel - use @resume to continue
19:28:28 <Pseudonym> Taking its time.
19:28:30 <Pseudonym> @resume
19:28:37 <Pseudonym> Ah!
19:28:40 <blackdog> That's not going to get it anyway...
19:28:44 <np_hard> yeah
19:28:47 <Pseudonym> Does it handle takeWhile?
19:28:50 <lambdabot> out of fuel - use @resume to continue
19:28:53 <np_hard> need a complete factorization
19:29:05 <np_hard> you are just filtering, not powering
19:29:08 <Pseudonym> @eval filter (\f -> 413290419284712 `mod` f == 0) (takewhile (<= sqrt 413290419284712) primes
19:29:08 <lambdabot> (line 1, column 57):
19:29:08 <lambdabot> unexpected "<"
19:29:08 <lambdabot> expecting simple term
19:29:10 <Pseudonym> True.
19:29:20 <Pseudonym> @eval filter (\f -> 413290419284712 `mod` f == 0) (takewhile (\x -> x <= sqrt 413290419284712) primes
19:29:20 <lambdabot> (line 1, column 96):
19:29:20 <lambdabot> unexpected end of input
19:29:20 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:29:20 <lambdabot>  "(", operator, simple term or ")"
19:29:25 <Pseudonym> Dan.
19:29:27 <Pseudonym> Damn.
19:29:27 <np_hard> need to divide 41329... by the found factor
19:29:28 <Pseudonym> Anyway.
19:29:30 <Pseudonym> Right.
19:30:30 <Pseudonym> I wonder how factor does it.
19:30:51 <np_hard> iteratively, I am sure
19:30:57 <np_hard> ba dum bum
19:31:36 <blackdog> well, there's a oneliner for eratosthenes. a simple recursive function over that should do it, so maybe a three liner if you're feeling lazy. :)
19:39:08 <dons> blackdog is famously fond of eratosthenes :)
19:40:10 <yrlnry> There's a paper by wadler or peyton jones or someone like that that has an example of an array monad with update---actually two array monads, one of which supports update and one of which is read only.  Does this ring a bell for anyone?
19:40:26 <marcot> Isn't there a way of interfacing an program with haskell?
19:40:40 <marcot> Like using factor to solve this problem?
19:41:03 <marcot> Something like a function that receives a shell command e return the output of the command.
19:41:28 <dons> system(), but that is ugly. you could write a nice pure function to solve it, I reckon
19:41:32 <np_hard> sure but then you have to parse it and what not
19:42:00 <wagle> find source for factor, rewrite into haskell..  maybe you need yi to do the transform?
19:42:02 <wli> the elliptic curve method is relatively easy
19:42:11 <yrlnry> Never mind; it's "Monads for Functional Programming" by Wadler.
19:42:22 <wli> maybe I should post an implementation
19:42:35 <dons> wagle: yes, yi would be very appropriate! you could add plugins too :P
19:42:57 <wagle> yi yi yi!
19:43:13 <wli> so I never did get anywhere in any of the monad stuff
19:43:50 <wagle> you find the Data.Set implementation or FiniteMap?
19:44:10 <wli> I knew about them before they were mentioned on the channel
19:44:24 <Pseudonym> factor doesn't work on numbers over 2^128
19:44:28 <Pseudonym> Is that important?
19:44:29 <wli> making a monad out of the damned things is the issue
19:44:43 <wagle> why do you need Set monad?
19:44:56 <wagle> (other than aesthetics)
19:45:10 <wli> obviously nondeterminism with uniqueness
19:45:31 <wli> but it's significantly worse than that
19:45:47 <wli> if you can't do a set monad you can't do a breadth-first search nondeterminism monad
19:46:35 <wagle> was thinking that maybe the Set data structure could carry its own equality predicate, but then that doesnt let f map the old to the new predicate
19:46:44 <marcot> dons: but how can I get the output from factor with system() ?
19:46:52 <wagle> sigh
19:47:28 <wli> well, musasabi has some subkinding idea but I can't even figure out how to wrap integer literals with fromIntegral in ghc, much less fiddle with kinding
19:48:00 <dons> marcot: oh, sorry. you need popen(), not system().
19:48:10 <dons> System.Process, would also work
19:49:07 <wagle> i remember someone trying to dop sets a couple years ago, and ending up with less than was hoped for..
19:49:14 <wagle> s/dop/do/
19:49:15 <wli> "dop"?
19:49:49 <wli> well, there's one obvious way to do it type-wise
19:50:01 <wli> I just don't know how to shoehorn it into ghc
19:50:09 <wagle> how?
19:50:17 <marcot> dons: where can I get doc about these?
19:50:33 <wli> wagle: subkinding
19:50:55 <wagle> hmm superkinding...
19:51:06 <wli> well, that's not used
19:51:15 <wli> it's dumb
19:51:27 <wagle> (just that "supertypes" are a hot new thing here)
19:51:52 <dons> marcot: popen is in hslibs: http://www.haskell.org/ghc/docs/latest/html/hslibs/popen.html
19:52:03 <wli> if a type constraint arises in a class then any instantiation has to be on types satisfying hte constraints
19:52:14 <wagle> i havent had a chance to poke at it today yet
19:52:58 <wli> wagle: well, "subtyping" and "subkinding" refer to general partial lattice -like structure on types, which is easy to arrange with qualified types etc.
19:53:23 <wli> wagle: so the "superkinds" and "supertypes" are already there AFAIK
19:53:55 <wagle> just trying the square peg in round hole...
19:54:16 <dons> marcot: System.Process is in ghc 6.3: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/libraries/base/System/Process.hs
19:55:05 <wagle> to see what happens
19:55:33 * wagle gaffiates
19:55:57 <wli> well, I'm just stumped as to what they're on about since supertype stuff is already in the subtyping stuff.
19:56:59 <wagle> i think its which direction you are going when you create new stuff from old
20:27:57 <marcot> dons: which module should I import to use this popen?
20:31:33 <SyntaxNinja> popen isn't a standard function
20:31:48 <dons> import POpen, and I think you need -package posix. You should consider the portability issues here
20:32:00 <marcot> dons: ok! Thanks.
20:32:09 <dons> the alternative is to use the standard System.Process, which requires ghc 6.3 >=
20:34:50 <Pseudonym> @wiki HaskellIrcPastePage
20:34:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:35:18 <Pseudonym> It's a bit slower than the factor program, but it doesn't have the arbitrary limit at 2^128
20:36:48 <Pseudonym> And it even uses Eratosthenes to generate the wheels. :-)
20:37:19 <dons> lovely!
20:38:46 <Pseudonym> It only uses pseudo-primes for the main sieve, though.
20:38:48 <dons> now, I wonder if there is similar stuff in the hs-crypto lib?
20:39:00 <Pseudonym> hs-crypto probably uses the Fermat algorithm.
20:39:12 <Pseudonym> With small primes for speed.
20:39:19 <Pseudonym> But you could use wheel generation with Fermat.
20:40:11 <Pseudonym> It'd mean you probably don't have to do the small prime test.
20:40:20 <Pseudonym> Though you might as well.
20:41:14 <dons> thre's a factor function in there, but it doesn't say which one
20:42:03 <dons> factor :: Integer -> [Int]
20:42:12 <Pseudonym> Hmmm.
20:42:16 <Pseudonym> Looks like a hard limit there.
20:42:31 <dons> yeah
20:42:47 <Pseudonym> Actually, there's one other potential optimisation you could do to this.
20:43:13 <Pseudonym> If it looks like you've skipped a lot (say, 1000) of pseudo-prime factors, you could try a full primality test.
20:43:24 <Pseudonym> It could potentially save a lot of computation.
20:48:27 <Pseudonym> OTOH it could also potentially waste a lot.
20:55:25 <mrsolo> is it easy to do gui with haskell?
20:55:30 <mrsolo> labgtk?
20:57:48 <dons> http://www.haskell.org/libraries/index.html#guigs
20:59:47 <mrsolo> ah thanks
21:31:58 <cm> tired. hi
21:46:56 <svend> does anyone know if ghc builds under netbsd-alpha?
21:47:52 <desrt> if not, you can probably port it easily
21:48:09 <desrt> actually, it's not really porting... it's more like bootstraping
21:51:03 <svend> I am suprised.  The lang/ghc in FreeBSD only builds for i386.  I would have thought that if it was easy, they would have done it already.
21:51:36 <Pseudonym> D'oh!
21:51:40 <Pseudonym> Forgot a critical optimisation.
21:51:50 <desrt> svend; it's an issue of bootstrapping
21:51:58 <desrt> in order to build ghc, you need to have ghc already
21:52:03 <desrt> and ghc doesn't cross-compile
21:52:20 <desrt> so freebsd probably has a ghc-bin package for i386 only
21:52:29 <svend> desrt: do you know if hc files for netbsd-alpha are available, or do I have to do the full cross build.
21:53:01 <desrt> svend; if someone made the .hc files available they'd probably go the one step more and provide the full unregisterised binary distribution
21:53:04 <Pseudonym> @wiki HaskellIrcPastePage
21:53:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
21:53:07 <Pseudonym> Better factorisation now.
21:53:40 <desrt> svend; btw: if you do this, please email one of the lists with your binary package
21:55:22 <svend> I tried to build the hc files myself, but ran into problems.  My setup is:  copied config.h from netbsd-alpha machine to linux-i386 machine.  Will a linux-386 work for building the hc files?
21:55:41 <desrt> it should
21:55:51 <desrt> all of the platform-specific stuff in the RTS will fail miserably
21:55:55 <desrt> but you don't need that
21:56:18 <svend> desrt: I'll give it another go.  Will you be available to answer q's?
21:56:28 <desrt> i'm technically studying for an exam :)
21:56:37 <desrt> so i'd like to say 'no', but who knows :)
21:56:45 <desrt> do you have the bootstrapping guide?
21:58:28 <svend> I followed the online copy: http://www.haskell.org/ghc/docs/6.2.2/html/building/sec-porting-ghc.html
21:58:41 <desrt> ya.  this is the one.
21:59:30 <desrt> all the stuff about registerised builds you don't need to worry about
22:00:01 <desrt> ie: you don't need to port the rts
22:00:36 <desrt> (nor the mangler, the NCG, ghci or the object splitter)
22:00:48 <thebug> unregisterized should work, but it'll be s l o w ;)
22:00:58 <desrt> thebug; it's not that bad :)
22:01:15 <desrt> i use unregisterised ghc on a daily basis
22:01:19 <thebug> desrt: depending on the arch, it may well be very bad
22:01:47 <desrt> (that being said, i've never seen these machines run regiserised so i might be missing out)
22:03:04 <thebug> unregisterized on mips isn't fun
22:03:09 <svend> thebug: does that mean programs I build will run slow, or the ghc compiler will be slow?
22:03:10 <desrt> ppc64 here
22:03:17 <desrt> svend; both.
22:03:27 <thebug> svend: option c: all of the above
22:03:46 <desrt> (by virtue of the fact that ghc itself is a haskell program built using ghc)
22:03:57 <thebug> it's because it won't use the registers of the processor optimally, hence the term 'unregistereized'
22:04:04 <dons> the alpha runs registerised
22:04:12 <thebug> cool
22:04:13 <dons> it's just a matter of following the bootstrap procedure
22:04:40 <desrt> dons; is alpha abi stable from OS to OS?
22:05:09 <dons> I think it must be. we have linux/alpha and osf/alpha, with no special code
22:05:25 <dons> i haven't had a go at openbsd/alpha yet
22:05:25 <desrt> i wonder who copied who :)
22:05:28 <thebug> ah, but what about OpenVMS/Alpha hehe
22:05:30 <dons> osf came first
22:05:35 <desrt> dons; joke :)
22:05:43 <dons> oh, sorry :P
22:05:57 <jdrake> it is ok, you are forgiven
22:06:42 <dons> svend: send your progress to glasgow-haskell-users, and you'll get lots of help
22:06:56 <svend> dons: will do
22:07:58 <dons> it will be easier if you use a netbsd-i386 machine (but it is not too serious if you use linux)
22:08:34 <thebug> in a slightly more semi-serious question though, has it ever been run on VMS?
22:09:01 <dons> svend: and you may also want to check the glasgow-haskell-users archives -- there has been some long threads on porting last year.
22:09:11 <dons> thebug: hmm. maybe 10 years ago. let me see...
22:09:35 <dons> thebug: also, I got contacted by a guy who wants to write a native codegen for mips64/ghc, which you may be pleased to know
22:10:11 <thebug> cool cool
22:10:42 <jdrake> The government can make things difficult sometimes, I need to get a new birth certificate because I lost my initial one. The form has a section for guarantor, which is rather narrowly focused as to who can be one.
22:11:45 <thebug> perhaps when I have some free time later this month I'll give building ghc under VMS a whirl, just for sadistic fun
22:12:13 <jdrake> how about ghc microcontroller programming
22:12:41 <dons> nope, don't think we ever had an openvms port
22:13:20 <thebug> well, it's got far more posix bits than it would have had 10 years ago, so that's one thing going in ghc's favor
22:13:50 <thebug> and we know ghc does work on alpha under other OSes
22:13:55 <dons> yeah. that's good. and we don't use that much posix.
22:14:58 <dons> enough that it works on irix and osf. and aix!
22:15:00 <jdrake> can you guys try and do cos (acos (-1)/2)   and tell me if you ever get anything like say '0'? (instead of a number close to zero)
22:15:42 <thebug> dunno how well it'd deal with DEC C, but I do know that GCC with a VMS target exists
22:16:34 <dons> jdrake: hugs, ghci, hbi and plugs all give the same answer: 6.123031769111886e-17
22:17:13 <jdrake> are you on a 7447?
22:17:22 <dons> thebug: hmm. yeah. the headers could be problematic. you defn. need gcc
22:17:29 <dons> what's a 7447?
22:17:38 <jdrake> A processor
22:17:50 <dons> duh.
22:18:16 <dons> if you want better feedback, you need to supply more info.
22:18:29 <dons> same result on ia64/ghci
22:18:35 <jdrake> Its a Motorolla Powerpc 
22:18:43 <dons> oh. ok. don't have one.
22:19:03 <thebug> 7447 is otherwise known as a G4
22:19:11 <jdrake> Apple's moniker for it sure
22:19:24 <thebug> well, one of the G4 family
22:19:25 <dons> right. do you actually get 0?
22:19:31 <jdrake> no
22:19:37 <jdrake> I get the same answer as you
22:19:48 <jdrake> sorry, not the same, but similar
22:19:59 <jdrake> 6.123233995736766e-17
22:19:59 <svend> dons: what sort of issues may I expect when building on a linux-i386 vs netbsd-i386?
22:20:11 <jdrake> Is there any way of getting a correct answer out of this?
22:20:49 <dons> svend: some of the headers will be different -- so you'll get more complaints when building the  .hc on linux
22:21:07 <dons> but I don't think it'll be too scary. I've cross-ported linux->openbsd a few times
22:21:12 <thebug> svend: iirc, linux and *bsd have a different system call interface ... something about int80
22:21:22 <dons> the wordsize will be more of an issue
22:23:34 <svend> will any of the complaints require me to do any modifications?
22:24:24 <dons> not sure... unfortunately I can't do the cross-port in my head ;)
22:25:12 <svend> ok.  I'm just wondering what to expect, and if it's worth installing netbsd-i386 to do this.
22:25:23 <dons> no. try with linux. 
22:25:56 <dons> even openbsd -> irix-64 worked. so this should be alright.
22:26:02 <jdrake> is there any chart showing a class hierarchy
22:26:27 <dons> and I see that debian/alpha is still building, so the code musn't be too bitrotted
22:26:58 <dons> jdrake: in the h98 report
22:30:12 <jdrake> I am having trouble determining the difference exactly between a type and a class. When I 'detype' my function haskell infers this: polarToVertex :: forall a. (Floating a) => a -> a -> (a, a)   When I try using Floating as a type alias it says trying to use a class as a type
22:31:30 <dons> you can't use Floating (a typeclass) as a type alias
22:32:41 <jdrake> What is the difference between a typeclass and a type
22:32:44 <Riastradh> jdrake, type classes are somewhat like Objective-C protocols.  You can't use them in the place of types, just as you can't use Objective-C protocols in the place of C types.
22:32:45 <dons> the paper "Type classes in Haskell" Hall, 1994 has a good introduction
22:33:59 <monochrom> Pick a different name.
22:34:39 <Riastradh> A Haskell type class represents a set of operations that may be defined on certain types.  Likewise, an Objective-C protocol represents a set of selectors that may be implemented by Objective-C classes.
22:35:39 <monochrom> My own explanation is at http://www.cs.utoronto.ca/~trebla/fp/lecture-06.pdf
22:38:17 <dons> yeah, that's a good summary.
22:39:26 * desrt pokes cale
22:39:35 <Cale> hey
22:39:48 <desrt> i just finally figured out the y combinator :P
22:39:58 <Cale> cool
22:40:14 * desrt never uses recursion again! ha ha
22:40:30 <desrt> how is school?
22:40:47 <Cale> It's alright. Just finished my last exam for the term today.
22:41:03 <desrt> lucky.
22:41:35 <jdrake> dons, where is the good introduction in that paper? The 'introduction' section certainly doesn't have it. It is difficult for me to navigate in the pdf document because it is a glorified image in a pdf
22:41:48 <desrt> i have dr. kahl's exam tomorrow.  fear :)
22:42:02 <Cale> :)
22:43:36 <Cale> I had functional analysis followed two days later by algebraic curves, followed by a 50%-of-final-grade assignment for algebraic combinatorics (which I stayed up 26 hours doing), then 18-20 hours of sleep, and then Galois theory today.
22:43:53 <desrt> boring math
22:43:58 <dons> jdrake: pg 3-4 are relevant. the refs at the back are also useful
22:44:17 <desrt> where's the category theory?
22:44:38 <dons> jdrake: also _lots_ of stuff in s4 of the h98 report
22:45:22 <dons> huh. () is a valid context. () => a -> a
22:45:32 <dons> i love haskell
22:46:06 <jdrake> So a type is an instance of the class
22:47:14 <dons> hmm. I wouldn't say that.
22:47:42 <jdrake> "A class declaration (Section 4.3.1) introduces a new type class and the overloaded operations that must be supported by any type that is an instance of that class. An instance declaration (Section 4.3.2) declares that a type is an instance of a class and includes the definitions of the overloaded operations---called class methods---instantiated on the named type.'
22:47:49 <Cale> desrt: there was some category theory in my algebraic curves course
22:47:50 <jdrake> That is what makes me think that
22:48:34 <dons> but a type is not in general just "an instance of a class"
22:48:34 <Cale> but not a heck of a lot, just a few interesting functors
22:48:56 <dons> and I think 'instance' is overloaded here, too
22:49:41 <jdrake> My book here looks like it explains typeclasses later on so I can ignore this for now
22:49:41 <dons> but you do write instances of classes, for particular types
22:52:35 <jdrake> how long does it take somebody to actually 'know' haskell
22:53:45 <Heffalump> how would you define 'know'?
22:54:10 <Heffalump> I find things that surprise me occasionally after more than 7 years using it. It's hard to know any language _perfectly_.
22:54:27 <jdrake> Perhaps ability to write most common things without having to look everything up
22:54:58 <Heffalump> writing common things is generally a matter of knowing the libraries well
22:54:59 <jdrake> 'know' I guess isn't the best word
22:55:13 <jdrake> But 'learn' isn't much better of a word
22:55:44 <Heffalump> I don't think it's a question that can easily be answered anyway. Different people learn things at different rates, and getting familiar with a new language is likely to be a very variable thing.
22:55:59 <Heffalump> What languages would you say you 'know' already, and how long did it take you?
22:56:08 <jdrake> haskell is far different from anything i am actually used to
22:56:20 <jdrake> I have used ocaml and sml in the past though
22:57:03 <desrt> Cale; i don't even know what it is.  i just hear people talk about it like it's the holy grail or something :)
22:58:07 <Heffalump> it's not that different to OCaml and SML
22:58:17 <Heffalump> laziness, type classes and monads are the new things
22:58:31 <Heffalump> and a nice bonus is not having to declare things in dependency order and use letrec
22:59:30 <jdrake> letrec is only ocaml
23:03:59 <Heffalump> well, SML has the equivalent since you have to use let ... and ... and ...
23:04:19 <jdrake> haskell is nice and pretty
23:04:31 <Heffalump> yeah
23:05:03 <mrsolo> where is haskell going?
23:05:21 <jdrake> It must stagnate to let others catch up
23:06:23 <Heffalump> mrsolo: it seems unclear
23:06:26 <mrsolo> yea right
23:06:28 <Riastradh> Thataway.
23:06:32 * Riastradh points over there.
23:06:34 <Heffalump> the most ambiguity is in where the type class system is headed, I think
23:07:00 <Riastradh> Notice how all of the main stream languages are trembling in their boots when you look over in that direction.
23:07:25 <dons> certainly, type hackery is getting a lot of attention
23:07:56 <jdrake> what would be the best way of making sure a parameter is not too high in a recursive function?
23:08:08 <Riastradh> I want to know when Haskell will get a Turing-complete type system that needs a kind system as expressive as the current type system.
23:08:10 <mrsolo> ideas get borrowed into another 'main stream' languages eventually, good one that is
23:09:56 <Heffalump> jdrake: "too high"?
23:10:05 <Heffalump> you're trying to guard against uncontrolled recursion?
23:10:17 <jdrake> yes
23:10:29 <jdrake> back in school they called it a sentinel 
23:11:31 <jdrake> looks like if will work
23:11:33 <svend> dons: I am getting the following error when running make in H/libraries: cc1: invalid option `ieee'
23:11:36 <Heffalump> do you just want to add an explicit check for a particular parameter, or are you looking for general techniques to avoid parameters growing out of control without adding explicit code?
23:12:35 <jdrake> well the best way would be a good start, so I shall explain. I have n sides, I have a counter cn. cn increases each iteration, I must guard against cn >= n
23:13:02 <jdrake> the way I would normally do this would be to have an if expression, would that be proper here?
23:13:29 <musasabi> You want a proof that your function is primitively recursive?
23:13:58 <mrsolo> you want to stop if cn >= n?
23:13:59 <Heffalump> I'm still not sure if you want to do this by adding an explicit check for cn>=n, or having some way to guarantee that implicitly.
23:14:05 <jdrake> musasabi, I do not know what proof or primitively recursive even is
23:14:44 <jdrake> Well an explicit check would be what I would normally do, but is there any easy way of guaranteeing it implicitly?
23:14:54 <Heffalump> what do you normally do?
23:15:03 <Heffalump> perhaps if you explain in some other language, we can help
23:15:15 <Heffalump> I doubt the techniques will be any different from OCaml or SML, though the syntax may vary.
23:15:17 <dons> svend: I can't remember the soln, but someone posted on this when porting to alpha on glasgow-haskell-users, a year or two ago
23:15:33 <jdrake> I usually would have used a condition in an if statement or while statement
23:15:52 <Heffalump> ok.
23:15:57 <jdrake> I can paste my function here in a sec once the general out of control case is ready
23:16:01 <Heffalump> so use an if statement in Haskell
23:16:11 <svend> dons: I saw that.  I'm trying to find a solution on the list now.
23:16:32 <Heffalump> countto n = if n>=5 then "" else show n ++ "," ++ countto (n+1)
23:16:47 <jdrake> regularPolygon n s = Polygon vertices 0
23:16:47 <jdrake>     where
23:16:47 <jdrake>         vertices xs cn = vertices ((polarToVertex ((2*pi / n) * cn) s) : xs) (cn + 1)
23:17:09 <jdrake> ok, i will do that
23:19:24 <dons> svend: oh, I see I posted about ieee :}
23:19:25 <svend> dons: http://www.haskell.org//pipermail/glasgow-haskell-users/2003-September/005650.html "You might be able to hack around
23:19:28 <svend> it with lots of 'make -k' on the host machine."
23:19:45 <dons> ah, yep. that was it
23:20:09 <svend> so should I just run `make -k' anytime a make fails with that error?
23:20:42 <dons> when on the host machine, yep. you don't care about the rts/ files, for example, so it doesn't matter if they get built or not
23:21:15 <jdrake> Couldn't match `Angle' against `Int'   In the expression: ((2 * pi) / n) * cn       Angle is just a Float, I am not sure what this would have trouble. pi is a Floating, so I think it should infer something like Float
23:21:33 <dons> @type (/)
23:21:36 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
23:22:41 <Heffalump> what's n?
23:22:51 <Heffalump> try changing n to fromIntegral n
23:22:56 <Heffalump> yo! SyntaxDude!
23:24:47 <jdrake> no change
23:24:53 <Heffalump> try changing cn that way too
23:24:54 <svend> should a .hc be build for each .hs and .lhs?
23:25:01 <Heffalump> the basic issue is that there are no implicit coercions
23:25:58 <jdrake> now it compiles
23:26:10 <dons> svend: yep. in libraries/  hslibs/ and ghc/compiler/
23:26:41 <SyntaxNinja> hi Heffalump
23:26:56 <svend> because after running `make -k' in libraries, I have two .hc files compared to 22 .lhc files
23:27:19 <svend> this was the same problem I ran into last time I attempted this
23:27:44 <jdrake> is there a way to do :t on a function in a where clause inside a function?
23:28:46 <dons> svend: after the 2-stage build on the host, you end up with 268 .hc files in libraries/
23:29:01 <dons> and 255 in ghc/
23:29:13 <Heffalump> jdrake: not that I know of :-(
23:29:22 <dons> this will vary slightly from ghc version to version
23:30:51 <dons> svend: I did manage to generate .hc for osf/alpha with 6.2.1, and igloo does it all the time for debian
23:31:00 <svend> dons: are you talking about the cd H/ghc; make boot stage=2 && make stage=2 step?
23:32:19 <dons> that'll build .hc in ghc/
23:33:20 <dons> if the .hc aren't being generated, recheck that you have the right flags
23:34:08 <svend> after the cd H/libraries; make boot && make -k step: find libraries -name '*.hc' | wc -l: 2
23:34:37 <svend> somethings wrong.  what flags are you refering to?
23:36:05 <jdrake> what do you guys think of the regularPolygon function here: http://paste.lisp.org/display/4387 (at the bottom). It doesn't actually produce what it should, but its a start, I would like to know how good it is style wise and if there are any recommendations
23:37:00 <Heffalump> looks fine to me
23:37:17 <Heffalump> if you want to avoid the if then else there's alternate syntax
23:37:33 <Heffalump> and I'd avoid the long line, but that's a very personal and language-non-specific matter
23:37:46 <Heffalump> vertices xs cn | cn >= n = xs
23:37:48 <jdrake> I don't like long lines either
23:37:53 <dons> svend: ok. you may have to start over. i;m referring to the flags in mk/build.mk
23:37:56 <Heffalump> vertices xs cn = vertices ...
23:38:11 <jdrake> what is the | syntax there
23:38:16 <Heffalump> it's "guard" syntax
23:38:31 <jdrake> that was what i was wondering about before
23:38:32 <Heffalump> the clause only applies if the guard is true
23:38:43 <dons> svend: you using ghc <= 6.2.2 ?
23:38:47 <jdrake> makes it a little easier
23:38:50 <Heffalump> they get tried top-to-bottom, like with pattern matching
23:39:04 <Heffalump> you can use | otherwise on the second clause if you want to make it absolutely clear
23:39:12 <Heffalump> the other nice thing about them is that they mix with pattern matching
23:39:43 <svend> dons: The linux-i386 system I am building on has the 6.2.2 RPMS installed.
23:39:47 <jdrake> I have to do this thing a little bit better because in the case of a square it makes a diamond shape where the actual side lengths are longer
23:39:54 <Heffalump> you can also do it like:
23:40:03 <Heffalump> vertices xs cn | cn >= n = xs
23:40:12 <Heffalump>                | otherwise = vertices ...
23:40:48 <Heffalump> oh, also, some of your brackets are redundant
23:40:49 <svend> I pasted the contents of mk/build.mk as the appeared in the docs.
23:40:55 <Heffalump> but you may prefer them for comprehensibility
23:41:12 <jdrake> with haskell I am not sure which is which so I have this tendancy to bracket far too much
23:41:18 <jdrake> I used lisp for a few days too
23:41:39 <Heffalump> vertices (polarToVertex (2*pi / fromIntegral n * fromIntegral cn) sideLength : xs) (cn + 1)
23:41:44 <Heffalump> is minimally bracketed, I think
23:42:08 <jdrake> which binds tigher - function application or infix operations
23:42:15 <Heffalump> function application
23:42:21 <Heffalump> key rule to remember - that binds tighter than anything else
23:42:25 <Heffalump> and associates to the left
23:42:29 <WobL> yeah
23:42:58 <Heffalump> actually, style-wise, here's another way to write your entire function:
23:43:18 <Heffalump> regularPolygon n s = map vertex [0..n-1]
23:43:22 <Heffalump>   where sideLength = s/2
23:43:49 <dons> svend: what source version of ghc are you building in?
23:43:57 <Heffalump>        vertex n = polarToVertex (2*pi / fromIntegral n * fromIntegral cn) sideLength
23:44:01 <jdrake> hmm, i think I like that idea
23:44:06 <Heffalump> sorry, vertex n should be indented as much as sideLength
23:44:16 <Heffalump> and I may have got the list backwards, if so make it [n-1..0]
23:44:34 <Heffalump> yes, I have got it backwards, so if the order matters you want [n-1..0]
23:44:39 <svend> dons: 6.2.2
23:44:47 <dons> ok. that's all good.
23:44:58 <jdrake> now the problem coming up here is that I have to write this function properly :-)
23:45:00 <Heffalump> it's really a matter of style; there are a lot of combinators to do recursion for you, like map, foldr, filter etc.
23:45:10 <Heffalump> But you may feel that making the recursion explicit is clearer.
23:45:41 <svend> I have some errors that may be relevant.  can I paste 6 lines to the channel?
23:45:45 <Heffalump> yes
23:45:47 <jdrake> so I have to find the first position, and then a run around like in a circle for how ever many sides there are
23:46:00 <jdrake> perhaps a pastebot might be better
23:46:12 <svend> I'm not sure what that is.
23:46:22 <jdrake> I shall direct you...
23:46:30 <jdrake> http://paste.lisp.org/
23:46:44 <Heffalump> jdrake: btw the way I would have checked on the precedence rules for * and / if I hadn't known them was to do :i * and :i /
23:46:56 <Heffalump> which would have told me infixl 7 * and infixl 7 /
23:47:10 <Heffalump> which means that they are equal precedence and associate to the left
23:47:22 <Heffalump> but in the case of arithmetic operators the rules are what you'd expect, so it's easy
23:48:11 <Heffalump> http://www.haskell.org/hawiki/HaskellIrcPastePage is the standard place for #haskell, but a proper paste bot may be nicer to use
23:48:13 <jdrake> I haven't exactly got it automatically understood what associativity and direction actually mean
23:48:29 <jdrake> Heffalump, I can ask chandler to get lisp paste made for us here
23:48:42 <Heffalump> the nice thing about the paste page is that it syntax highlights
23:48:51 <svend> I can't find #haskell on paste.lisp.org
23:48:55 <Heffalump> but it does have concurrency issues
23:49:00 <jdrake> svend, paste to no channel
23:49:11 <jdrake> and then grab the url from the resulting page and manually paste it
23:49:14 <Heffalump> associating to the left means that a * b * c is parsed as (a * b) * c
23:49:34 <Heffalump> and since * and / are equal precedence that also applies to them - a * b / c is (a * b) / c
23:50:28 <svend> http://paste.lisp.org/display/4388
23:50:55 <svend> there are lots of errors like that one
23:51:12 <desrt> svend; how's it going?
23:51:37 <svend> still struggling with netbsd-alpha
23:52:12 <dons> that seems to be because the Prelude hasn't yet been compiled?
23:52:19 <Gahhh> Has anyone written a P2P application in fewer than 9 Haskell lines yet ?
23:52:37 <jdrake> this there any block comment format?
23:52:43 <dons> {- -}
23:52:59 <svend> I'm confused.  Is this error related to the missing .hc files?
23:53:07 <Gahhh> svend: which error
23:53:08 <jdrake> you guys are awesome, thank you for all the help
23:53:11 <WobL> Gahhh: i love that sort of question :) only in haskell!
23:53:13 <dons> svend: no, missing .hi files
23:53:45 <Gahhh> WobL, some professor wrote one in 15 Python lines. It's over at slashdot.
23:53:45 <dons> it looks like it hasn't compiled the libraries/ files that Ix.hs depends on
23:53:47 <musasabi> svend: isn't ghc available via pkgsrc?
23:53:54 <dons> so they must all be failing for some reason?
23:54:02 <dons> musasabi: not for netbsd-alpha :)
23:54:06 <svend> musasabi: yes, but only for i386 I believe
23:54:26 <musasabi> but pkgsrc is to build from source - no?
23:54:28 <Gahhh> svend, I've been trying to port it to cygwin. Maybe I can help.
23:54:31 <jdrake> everyone must see this: http://homepage.mac.com/drewthaler/newbie-advice/iMovieTheater8.html
23:54:46 <svend> Would the full log of make -k in /libraries be helpful?
23:54:55 <dons> musasabi: yes. there are 2 issues. Free,NetBSD bootstrap from a binary ghc version
23:55:02 <Gahhh> svend, tell me first how you are bootstrapping it.
23:55:03 <musasabi> true.
23:55:05 <dons> and secondly, you still need to get .hc for the new platform
23:55:14 <musasabi> svend: are you using gmake?
23:55:33 <dons> openbsd bootstraps directly from .hc, so no binary is needed, but you still need to bootstrap it once to get the .hc
23:55:54 <svend> musasabi: the host system is i386-linux with gmake as make.
23:56:17 <Gahhh> svend, how are you bootstrapping ? did you edit build.mk ?
23:57:09 <svend> Gahhh: I pasted the build.mk contents from http://www.haskell.org/ghc/docs/6.2.2/html/building/sec-porting-ghc.html
23:57:57 <dons> yep. that's all good. but since .hi files are missing, we need to see the errors that occur when it first tries to compile in the libraries/
23:58:56 <Gahhh> svend, that is fine. But I doubt you will get any hc files for the libraries, since the makefile is br0ken.
23:59:12 <dons> ?
23:59:21 <dons> why?
23:59:28 <dons> which Makefile?
23:59:48 <Gahhh> The makefile under libraries does not use GhcStageEtcFlags, so you dont get -fvia-C, -keep-hc-files while building them.
