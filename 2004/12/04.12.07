00:04:31 <SyntaxNinja> happy is the parser.  alex is the lexer, but if simonMar had his way, he was going to call it Lexstatic.  he should have just renamed it when he sucked it into the cvs tree :)
00:11:59 <Helic> it's 3am in boston
00:12:24 <wolfman8k> hehe, this is great, read the user comment at the bottom of the page: http://freshmeat.net/projects/python
00:14:01 <Helic> haha
00:14:59 <Helic>  ./configure --paranoid=yes
00:17:42 <Lemmih> @seen shapr
00:17:42 <lambdabot> I saw shapr leaving #darcs 2 days 9 hours 7 minutes 34 seconds ago.
00:18:09 <Helic> good night all
01:31:44 <vegai> how about a time tracking utility
02:10:53 <reffie> is there a function that "flattens" a list?
02:11:13 <reffie> like from [[1],[2],[3,4]] to [1,2,3,4]?
02:11:43 <reffie> well
02:11:51 <earthy> yup
02:11:59 <earthy> @type flatten
02:12:00 <lambdabot> bzzt
02:12:12 <Lunar^> @type concat 
02:12:13 <lambdabot> concat :: forall a. [[a]] -> [a]
02:12:42 <reffie> thanks.
02:12:50 <xerox> reffie! :)
02:13:01 <reffie> ciao
02:13:05 <earthy> hm. where the hmph did I remember flatten from?
02:13:17 <reffie> probably some other language
02:13:28 <reffie> cause it's what i remembered too
02:13:39 <xerox> @get-definition concat
02:13:39 <lambdabot> concat = foldr (\x y.x++y) []
02:13:45 <xerox> nice.
02:14:19 <xerox> mmh
02:14:21 <vegai> the mecca of oneliners :)
02:15:35 <earthy> now if only there were ghci -e
02:15:41 <xerox> why not
02:15:51 <xerox> concat = foldr (++) []
02:15:52 <xerox> ?
02:16:07 <earthy> dunno
02:20:19 <xerox> @get-definition ++
02:20:20 <lambdabot> ++ not defined
02:20:50 <vegai> why indeed...
02:21:36 <Amadan> @get-definition (++)
02:21:36 <lambdabot> (++) not defined
02:27:14 <Amadan> can someone help me with parsec and monads, please?
02:28:05 <Lemmih> Sure.
02:29:17 <Amadan> i got a parser p that returns [AbsType (a, b, c)]. I would like to extend it to [AbsType (a, b, c, Int)], where the last one would be the index. now that needs the parser to keep count of AbsTypes found.
02:29:36 <Amadan> there's a similar example @ parsec page, but i couldn't make it work
02:30:30 <Amadan> i still don't really get monads, unfortunately
02:30:30 <tromp> what do you mean by index?
02:30:43 <tromp> index in the list?
02:31:10 <Amadan> [AbsType _ _ _ 0), (AbsType _ _ _ 1), ...]
02:31:14 <Amadan> yeah
02:31:26 <tromp> that is easily added with a map
02:31:47 <kosmikus> are you sure you want to do this during parsing?
02:32:19 <Amadan> it's definitely easier to do it with a map... but i'm trying to learn new stuff. :)
02:32:51 <tromp> as in "why do it the easy way if there's a hard way?"
02:33:00 <tromp> :-P
02:33:04 <Amadan> exactly :)
02:33:35 <tromp> i've never used parsec:(
02:34:49 <Amadan> and it looks kind of inelegant with map: i'd need to construct AbsTypes with dummy fields, then construct new AbsTypes with real ones during map... however, i'm really not intuitive in haskell profiling :)
02:35:22 <Amadan> anyway, as you said, it's really not important
02:35:33 <Amadan> except as another piece of the monad puzzle.
02:36:09 <Amadan> MegaMonad: what's the best way to solve the monad puzzle?
02:36:15 <MegaMonad> Amadan: Swisscheese: that is why they don't seem to be of the cygwin bash. But ghci causes those dos windows again i am trying to puzzle over the head of premise organization, and head of the monad puzzle?
02:40:51 <Itkovian> MegaMonad: can you make sense?
02:40:58 <MegaMonad> Itkovian: Or maybe it would be a net if it couldn't possibly be the same with searchnodot.
02:41:06 <Itkovian> i thought so ;-)
02:41:30 <xerox> If I define a type MyList to be:
02:41:30 <xerox> data MyList a = Nil
02:41:30 <xerox>               | Cons a (MyList a)
02:41:39 <Itkovian> eek, I feel depressed talking to a bot
02:41:40 <xerox> How's defined listTail ?
02:42:01 <Amadan> Itkovian: well, for me, no-one else does, why should MegaMonad? :)
02:42:18 <Itkovian> True
02:44:20 <xerox> listHead :: (Num a) => MyList a -> a
02:44:20 <xerox> listHead Nil = 0
02:44:20 <xerox> listHead (Cons x xs) = x
02:44:37 <Lemmih> Amadan: Are you familiar with {get|set}State from Parsec?
02:44:49 <xerox> i suppose it can be considered more or less correct, but i can't figure out the listTail
02:45:26 <Amadan> i've seen them in parsec docs, but i can't make heads or tails of it. :)
02:45:37 <Lemmih> listTail (Cons _ t) = t?
02:46:20 <xerox> seems to not work
02:47:02 <Lemmih> xerox: Why type do you think it has?
02:47:19 <xerox> listTail :: MyList a -> MyList a
02:47:33 <Lemmih> And why isn't it working?
02:48:11 <xerox> listTail (Cons 1 Nil) => No instance for (Show (MyList a))
02:48:25 <xerox> listTail (Cons 1 (Cons 2 Nil)) => No instance for (Show (MyList a))
02:48:43 <Amadan> (probably because heads and tails belong to a different monad :))
02:48:50 <Lemmih> Indeed. You have to tell Haskell how to show the data type.
02:48:59 <xerox> mh
02:49:09 <xerox> how?
02:49:27 <Itkovian> use add 'deriving (Show)' in the datatype def
02:49:45 <Lemmih> Amadan: They are quite simple to use.
02:49:46 <Itkovian> like: data MyList a = Nil | Cons a (MyList a) deriving (Show)
02:50:13 <Itkovian> I do wonder why a should be a Num instance in the listHead definition
02:50:13 <xerox> *Ex4_8> listTail (Cons 1 (Cons 2 Nil))
02:50:13 <xerox> Cons 2 Nil
02:50:29 <Lemmih> Amadan: Except that you can't use the predefined Parser type.
02:50:39 <xerox> Itkovian, i didn't understand that too
02:50:49 <Itkovian> well, imho you can just drop that.
02:50:59 <Itkovian> listHead is quite general, and you want to keep it that way
02:51:09 <Lemmih> Remember to drop the 'listHead Nil = 0' too (-:
02:51:18 <Itkovian> True
02:51:21 <xerox> oh, that is.
02:51:31 <Lemmih> @type error
02:51:33 <lambdabot> error :: forall a. [Char] -> a
02:51:36 <Lemmih> @type undefined
02:51:37 <lambdabot> undefined :: forall a. a
02:52:19 <xerox> *Ex4_8> listHead Nil
02:52:19 <xerox> *** Exception: c:/ex4_8.hs:13: Non-exhaustive patterns in function listHead
02:52:36 <xerox> btw it's ok
02:53:28 <Lemmih> fail "Ex4_8.listHead: empty list" might be appropriate, tho.
02:53:30 <xerox> exercise's text says to not worry about exceptional conditions for that two
02:54:12 <xerox> *Ex4_8> listHead Nil
02:54:12 <xerox> *** Exception: Empty list
02:54:14 <xerox> yes, nice
02:54:32 <Amadan> lemmih: that means that i can't use the Parser functions either, right? so scratch parseFromFile, i'd need to hGetContents then runParser?
02:54:53 <Lemmih> Amadan: Yes.
02:56:08 <Amadan> lemmih: that might be why i couldn't make it work... thanks, it's a bit clearer now. effectively, i'd need type CharParser Int (AbsType a b c Int) instead of Parser, right?
02:57:43 <Lemmih> Yes.
02:58:48 <Lemmih> That can be generalized to 'type YourParser a = CharParser Int a'.
03:00:13 <Amadan> yeah, but it's clearer for me to talk specifically when i'm trying to understand something. :) thanks, lemmih!
03:07:24 <xerox> whoa i got listFoldr at the first try!
03:07:31 <xerox> ^_^
03:07:33 <Lemmih> Yay.
03:20:33 <Itkovian> Nice.
03:43:35 <xerox> *Ex4_8> listFoldr (-) 1 (Cons 4 (Cons 8 (Cons 5 Nil)))
03:43:35 <xerox> 0
03:43:35 <xerox> *Ex4_8> listFoldl (-) 1 (Cons 4 (Cons 8 (Cons 5 Nil)))
03:43:35 <xerox> -16
03:43:41 <xerox> *puff pant*
05:12:40 <reffie> is there a function that generates all the possible pairs of elements of two lists?
05:13:11 <tromp> cartesian product?
05:13:11 <reffie> like f [1,2] [3,4] = [(1,3), (1,4), (2,3), (2,4)]
05:13:12 <xerox> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html ?
05:13:31 <tromp> use list comprehension
05:13:52 <tromp> [(x,y)|x<-xs,y<-ys]
05:14:49 <reffie> thanks
05:14:56 <xerox> nice.
05:15:44 <xerox> Prelude> [(x,y)|x<-[1,2],y<-[3,4]]
05:15:44 <xerox> [(1,3),(1,4),(2,3),(2,4)]
06:13:52 <xerox> mmh
06:13:57 <xerox> what do you think of that:
06:14:03 <xerox> data BinaryTree a = Leaf a
06:14:03 <xerox>                   | Branch (BinaryTree a) a (BinaryTree a)
06:14:11 <xerox> foldBL f v (Leaf x) = f v x
06:14:11 <xerox> foldBL f v (Branch left x right) = foldBL f (f (foldBL f v left) x) right
06:14:11 <xerox> foldBR f v (Leaf x) = f x v
06:14:11 <xerox> foldBR f v (Branch left x right) = foldBR f (f x (foldBR f v right)) left
06:14:24 <xerox> as folding function for a binary tree
06:14:40 <musasabi> xerox: you don't need v.
06:14:58 <musasabi> no.
06:15:01 <musasabi> you need it.
06:15:12 <kosmikus> looks strange
06:15:37 <kosmikus> what are the types of foldBL and foldBR, or does it typecheck at all?
06:16:02 <xerox> foldBL :: forall t a. (t -> a -> t) -> t -> BinaryTree a -> t
06:16:08 <xerox> foldBR :: forall t a. (a -> t -> t) -> t -> BinaryTree a -> t
06:16:18 <xerox> compared to:
06:16:20 <xerox> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
06:16:25 <xerox> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
06:16:32 <xerox> seems """correct""" ?
06:17:06 <kosmikus> ah, so you're trying to implement a fold on a binary tree by flattening it to a list and then using the list fold
06:18:36 <xerox> no!
06:18:47 <kosmikus> but that's what you seem to be doing
06:19:04 <xerox> the exercise just says
06:19:05 <xerox> Exercise 4.10 Write a fold function for BinaryTrees
06:19:08 <kosmikus> I mean, you're fusing the two steps, but that doesn't change the idea
06:19:40 <kosmikus> did you learn about the concept of a "fold" in the book/lecture/whatever you're following?
06:20:50 <xerox> i have a "substituting cons with the provided function"-like definition of fold
06:20:58 <xerox> (in some list)
06:21:38 <kosmikus> is it a course, or a book?
06:21:59 <xerox> Yet Another Haskell Tutorial
06:23:49 <jadrian> hello
06:24:53 <kosmikus> xerox: and it doesn't explain somewhere how to define folds for different datatypes, yet gives it as an exercise?
06:25:11 <xerox> it says that about fold
06:25:14 <xerox> The function foldr takes a little more getting used to. foldr takes three arguments:
06:25:14 <xerox> a function, an initial value and a list. The best way to think about foldr is
06:25:14 <xerox> that it replaces occurences of the list cons operator (:) with the function parameter and
06:25:14 <xerox> replaces the empty list constructor ([]) with the initial value. Thus, if we have a list:
06:25:14 <xerox> 3 : 8 : 12 : 5 : []
06:25:15 <xerox> and we apply foldr (+) 0 to it, we get:
06:25:17 <xerox> 3 + 8 + 12 + 5 + 0
06:25:19 <xerox> which sums the list.
06:26:00 <jadrian> does it make sense calling it a fold*r* on trees?
06:26:10 <kosmikus> jadrian: no
06:26:22 <kosmikus> jadrian: well, it does, the way xerox implemented it
06:26:36 <xerox> ouch :-)
06:26:48 <jadrian> kosmikus: how was that? he associated elements in pre-order or something like that?
06:27:02 <xerox> the only fold-related exercise is:
06:27:04 <xerox> Exercise 4.8 Write functions listHead, listTail, listFoldl and listFoldr
06:27:04 <xerox> which are equivalent to their Prelude twins, but function on our List datatype.
06:27:21 <xerox> based upon:
06:27:33 <xerox> data List a = Nil | Cons a (List a)
06:28:02 <kosmikus> jadrian: inorder, I think
06:28:50 <kosmikus> xerox: yes, that one is okay
06:29:04 <xerox> so, how should i read "Write a fold function for BinaryTrees" ?
06:29:21 <xerox> if you want to see, i did this for ex4.8:
06:29:28 <xerox> listFoldl :: (a -> b -> a) -> a -> MyList b -> a
06:29:28 <xerox> listFoldl _ v Nil = v
06:29:28 <xerox> listFoldl f v l = listFoldl f (f v (listHead l)) (listTail l)
06:29:28 <xerox>  
06:29:28 <xerox> listFoldr :: (a -> b -> b) -> b -> MyList a -> b
06:29:28 <xerox> listFoldr _ v Nil = v
06:29:30 <xerox> listFoldr f v l = f (listHead l) (listFoldr f v (listTail l))
06:29:35 <kosmikus> please stop pasting here
06:29:50 <xerox> yes sure
06:31:27 <jadrian> sometime ago I needed "generic" functions on some non-parameterized simply-recursive data types I have
06:31:44 <jadrian> I think I might have even talked to you about it kosmikus 
06:32:17 <xerox> kosmikus, can you explain to me the meaning of "fold" in the exercise about binary trees?
06:32:21 <jadrian> but since I don't know much about generic programing, and don't have much time, I ended up defining a classe of simply-recursive data
06:32:52 <kosmikus> I just downloaded the tutorial
06:32:56 <kosmikus> I don't think it explains it well
06:32:57 <kosmikus> ok
06:33:01 <xerox> thank you
06:33:16 <kosmikus> the concept to generalize is that of replacing constructor by functions
06:33:17 <jadrian> the only methods are: subData::a->[a], updSubData :: a->[a]->a 
06:33:25 <kosmikus> take foldr, ignore foldl for now
06:33:42 <kosmikus> foldr takes two argument, one corresponds to the (:) constructor, and one to the [] constructor
06:33:47 <jadrian> it doesn't allow me to implement *folds*
06:33:58 <jadrian> but I can implement something more generic
06:34:05 <xerox> wops, erc-smiley covered the constructor
06:34:06 <jadrian> like paramorphisms
06:34:15 <jadrian> (if I understood them right)
06:34:56 <kosmikus> xerox: foldr's type is (a -> b -> b) -> b -> [a] -> b
06:35:25 <jadrian> the thing about my functions is that the functions they take as arguments don't act on each of the datatype components
06:35:28 <xerox> <kosmikus> foldr takes two argument, one corresponds to the *here i saw two smileys sorry* contructor, ...
06:35:35 <jadrian> but on the whole datatype
06:35:50 <kosmikus> xerox: that's (:), the : in parentheses
06:36:00 <xerox> ok, i disabled it (:
06:36:04 <jadrian> I don't know wether that was an elegant way out, or a messy implementation :-|
06:36:29 <kosmikus> jadrian: sorry, I cannot explain to xerox and listen to you at the same time ;)
06:36:40 <jadrian> kosmikus: k you're right sorry :) go on
06:37:28 <kosmikus> look at the type of (:) -- it is  a -> [a] -> [a]
06:37:43 <kosmikus> the type of foldr's first argument is  a -> b -> b
06:38:08 <kosmikus> that's the same, only that every occurrence of the datatype in question ([a]) has been replaced with a fresh type variable
06:38:36 <xerox> mh
06:38:59 <Amadan> @index fromMaybe
06:38:59 <lambdabot> Data.Maybe,Maybe
06:39:07 <kosmikus> xerox: mh as in "ok" or as in "wtf??"
06:39:24 <xerox> as in "damn phone" -- sorry
06:39:58 <xerox> back
06:40:06 <jadrian> @HaskellIrcPastePage
06:40:06 <lambdabot> Sorry, I don't know the command "HaskellIrcPastePage", try "lambdabot: 
06:40:06 <lambdabot> listcommands"
06:40:30 <Amadan> @wiki HaskellIrcPastePage
06:40:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:40:37 <xerox> kosmikus, "ok" .
06:40:38 <jadrian> Amadan: thanks
06:40:43 * Lemmih ponders how handle C++ exceptions in Haskell.
06:40:57 <Amadan> jadrian: no prob.
06:41:10 <kosmikus> xerox: similarly, we have [] :: [a]
06:41:21 <kosmikus> xerox: and the second argument of foldr has type  b
06:41:29 <xerox> yes
06:41:40 <xerox> b = [a]
06:41:46 <kosmikus> again, you get from one to the other by just replacing all occurrences of [a] by the fresh type variable
06:41:56 <kosmikus> the same principle applies for all datatypes
06:42:15 <jadrian> Amadan: are we supposed to edit that page at will?
06:42:16 <kosmikus> if you want to get the type of the fold on binary trees, look at the types of the constructors for binary trees
06:42:30 <kosmikus> what's the type of Leaf?
06:42:39 <xerox> a -> BinaryTree a
06:42:47 <Amadan> jadrian: afaik, yeah.
06:42:51 <jadrian> Amadan: nice
06:42:52 <kosmikus> right, so what'd be the type of the first argument of foldBT
06:43:03 <Amadan> jadrian: 's what it's for, to avoid channel clutter.
06:43:17 <xerox> BinaryTree a
06:43:40 <kosmikus> xerox: no; why do you think so?
06:43:47 <xerox> wops
06:43:55 <xerox> the first argument is the function
06:44:26 <xerox> let me think
06:45:05 <kosmikus> it should correspond to the type of "Leaf" in the same way as the type of foldr's first argument corresponds to the type of the (:) constructor
06:45:57 <xerox> (a -> Leaf a -> Leaf a) ?
06:46:45 <kosmikus> ah, but Leaf a is not a type ...
06:46:52 <xerox> right.
06:47:04 <xerox> (a -> BinaryTree a -> BinaryThree a)
06:47:18 <xerox> -h
06:47:36 <kosmikus> not really either
06:47:59 <kosmikus> you're not really comfortable yet with types and higher-order functions, are you?
06:48:14 <xerox> expecially with types
06:48:36 <kosmikus> xerox: ok, let's try to approach it from the code side then
06:49:12 <kosmikus> xerox: try to write the recursive, specialized identity function for lists
06:49:35 <kosmikus> identity is easy, right? you could just write "idList = id"
06:49:44 <kosmikus> but let's do it in a more explicit way
06:49:51 <xerox> mmh ok
06:49:55 <kosmikus> what's "idList []" ?
06:50:01 <xerox> []
06:50:04 <kosmikus> correct
06:50:10 <kosmikus> so we have "idList [] = []"
06:50:15 <xerox> sure
06:50:25 <kosmikus> how can we compute "idList (x:xs)" ?
06:50:43 <xerox> x:xs ?
06:50:57 <kosmikus> sure, but now we want to apply our "idList" function recursively ...
06:50:58 <xerox> i mean, i know what x:xs means
06:51:13 <kosmikus> so, let's do "x : idList xs"
06:51:16 <kosmikus> ok?
06:51:23 <xerox> idList (x:xs) = x : idList xs
06:51:27 <xerox> yep
06:51:27 <kosmikus> bingo
06:51:33 <earthy> that seems pointless
06:51:48 <kosmikus> ok, now we're going to abstract from the symbols/constructors/functions [] and (:)
06:51:53 * earthy watches amusedly where this will lead ;)
06:51:56 <kosmikus> that's a simple program transformation
06:52:28 <kosmikus> instead of using [] or (:) on the right hand side, you introduce two new arguments, say "nil" and "cons".
06:52:47 <xerox> idList [] = Nil
06:52:48 <xerox> idList (x:xs) = Cons x idList xs
06:52:49 <xerox> ?
06:52:52 <xerox> wops
06:52:55 <Amadan> earthy: i believe he's driving him not to use default constructors... and then simply switch to tree semantics... not so pointless.
06:53:07 <xerox> parens around idList xs
06:53:18 <kosmikus> xerox: almost
06:53:22 <kosmikus> Amadan: exactly ;)
06:53:44 <kosmikus> xerox: I meant: idList cons nil [] = nil
06:54:00 <kosmikus> i.e., you're really introducing two additional arguments, and then perform the replacement on the rhs
06:54:33 <xerox> idList Cons _ Nil = Nil ?
06:54:40 <kosmikus> ??
06:54:42 <xerox> mmh..
06:55:18 <kosmikus> let's go back once more to the idList in its original form
06:55:21 <kosmikus> idList [] = []
06:55:27 <kosmikus> idList (x:xs) = x : idList xs
06:55:27 <xerox> yes
06:55:39 <kosmikus> you can see this as deconstructing the list and then re-building it
06:55:45 <Si\> is there any way of directing a Handle into some sort of Buffer, so that I can read the contents as a String later (without using files)?
06:55:47 <xerox> yes
06:56:29 <kosmikus> xerox: ok, we now also want to deconstruct the list, but then not re-build it in exactly the same way, but rather parametrize over it
06:56:46 <Amadan> si\: hGetContents? but watch for lazyness...
06:56:51 <kosmikus> so, we're going to leave the patterns on the left-hand side, [] and (x:xs), unchanged
06:57:00 <xerox> ok
06:57:22 <Si\> hGetContents reads the contents of a handle to an object
06:57:35 <kosmikus> but on the right-hand side, let's not use the same [] and (:) constructors to re-build the same list, but some new functions "nil" and "cons" which we are going to introduce as additional parameters
06:57:39 <kosmikus> so, in a first step, we get
06:57:42 <kosmikus> idList [] = nil
06:57:50 <kosmikus> idList (x:xs) = cons x (idList xs)
06:57:55 <Si\> I want to create a handle to an object which I can write characters to
06:58:06 <kosmikus> this is not correct, because it refers to names which aren't in scope, but do you get the idea?
06:58:14 <Si\> what I'm trying to do is redirect stdio into a String
06:58:22 <xerox> kosmikus, yes
06:58:25 <Amadan> ah. sorry... :)
06:58:26 <Si\> stdinput specifically
06:58:39 <Si\> no, stdouput rather
06:58:46 <kosmikus> xerox: ok, so now we're simply introducing "cons" and "nil" as additional parameters to the "idList" function
06:58:50 <kosmikus> this results in
06:58:54 <kosmikus> idList cons nil [] = nil
06:59:04 <kosmikus> idList cons nil (x:xs) = cons x (idList cons nil xs)
06:59:19 <kosmikus> note that I have to pass cons and nil to the recursive call of idList as well
06:59:36 <kosmikus> xerox: understand?
06:59:39 <xerox> yep!
06:59:49 <xerox> yes
06:59:53 <kosmikus> xerox: ok, so now compare the code for "idList" to the code for "foldr"
07:00:24 <CosmicRay> @seen shapr
07:00:24 <lambdabot> I saw shapr leaving #darcs 2 days 15 hours 50 minutes 16 seconds ago.
07:00:32 <CosmicRay> good morning, MegaMonad.
07:00:35 <xerox> kosmikus, as foldr, idList gets a function a value and a list
07:00:45 <xerox> i think they're kind of the same.
07:00:53 <kosmikus> xerox: !
07:00:57 <kosmikus> they are indeed
07:01:08 <kosmikus> they only use different names
07:01:14 <xerox> yes
07:01:29 <kosmikus> that's because I've shown you how to "construct" the fold function for the [] datatype
07:01:50 <xerox> mmh yes
07:01:50 <kosmikus> you can apply the same principle to another datatype now, say "BinTree" ;)
07:01:56 <xerox> uhu
07:02:04 <CosmicRay> MegaMonad: good morning.
07:02:13 <MegaMonad> CosmicRay: Original articles in sciam called it in.
07:02:13 <kosmikus> start out by writing the specialized recursive identity function for binary trees
07:03:22 <jadrian> xerox, kosmikus:  I learned about foldr (just lists) with this Graham Hutton paper:  "A Tutorial on the Universality and Expressiveness of Fold" http://citeseer.ist.psu.edu/hutton93tutorial.html
07:03:57 <jadrian> I think it's very well written
07:04:38 <kosmikus> jadrian: seems to be, but it doesn't talk about other datatypes, does it?
07:04:47 <xerox> idBT (Leaf x) = (Leaf x)
07:04:47 <xerox> idBT (Branch r x l) = Branch (idBT r) x (idBT l)
07:05:12 <kosmikus> correct so far, only that I'd flip 'r' and 'l'
07:05:22 <xerox> ouch, eh eh :-)
07:05:38 <earthy> wel... not if you're looking from inside the screen :P
07:05:44 <jadrian> kosmikus: nope, I just thought I'd mention it, maybe it's easier to understand other folds after really understanding foldr...
07:05:58 <kosmikus> jadrian: that might indeed be true
07:06:35 <kosmikus> xerox: now try to introduce new functions "leaf" and "branch", and replace all right-hand side occurrences of "Leaf" and "Branch" with calls to the functions
07:08:12 <xerox> idBT leaf (Leaf x) = leaf x
07:08:12 <xerox> idBT branch (Branch l x r) branch (idBT branch l) x (idBT branch r)
07:08:24 <xerox> i missed the =
07:08:37 <xerox> idBT branch (Branch l x r) = branch (idBT branch l) x (idBT branch r)
07:08:45 <kosmikus> hm, but you need both arguments "leaf" and "branch" in both cases
07:09:08 <kosmikus> the same way you need to pass "cons" to the "idList" function even in the first case
07:09:22 <kosmikus> and "nil" also in the second case
07:09:28 <xerox> idBT branch leaf (Leaf x) = leaf x
07:09:28 <xerox> idBT branch leaf (Branch l x r) = branch (idBT branch leaf l) x (idBT branch leaf r)
07:09:32 <xerox> yes i understand
07:09:38 <kosmikus> that's it
07:09:50 <earthy> now, for extra credit, write a compiler that will generate these functions automatically for arbitrary datatypes, check their typesignatures, and partially specialize them where needed. :)
07:09:53 <kosmikus> you can rename that one to "foldBT" and check what type it has
07:10:08 <jadrian> earthy: :)
07:10:14 <xerox> (t -> a -> t -> t) -> (a -> t) -> BinaryTree a -> t
07:10:21 <Amadan> earthy: rofl!
07:10:37 <kosmikus> earthy just want to see me unemployed ;)
07:10:40 <Amadan> MegaMonad: folding compilers are FUN!
07:10:50 <MegaMonad> Amadan: And it could be fun to use their settings with all haskell compilers fun.
07:10:59 <earthy> naw, you already did that, so it's left as an exercise in an advanced functional programming class
07:11:08 <earthy> nothing special anymore :P
07:11:12 <xerox> kosmikus, seems correct
07:11:14 <CosmicRay> MegaMonad: are you special?
07:11:16 <xerox> interesting.
07:11:26 <MegaMonad> CosmicRay: Hehe to me seem like special 'multiplicity constraints' [if you know if it will be me not use it purely in haskell, but i think this paper they write the smallest number out of 80 students a year.
07:12:24 <kosmikus> xerox: do you see how the types of the first two arguments correspond to the types of "Branch" and "Leaf", the same way there's a correspondence between foldr's type and the types of "[]" and "(:)"? That's what I originally wanted to start with, but now we've written the function without looking at the types at all, which is fine as well.
07:13:23 <xerox> yes i see it, it's really nice.
07:14:06 <xerox> when i implemented my foldB* functions i tought about how would they operate, what i want them to do
07:14:40 <CosmicRay> MegaMonad: I think you should go xerox some paperwork right now.
07:14:45 <MegaMonad> CosmicRay: Xerox wants to highlight right on the appropriate paperwork.
07:15:06 <kosmikus> xerox: you didn't really do it "wrong", you just took the operation of the list fold and transferred it to the BT type
07:15:32 <jadrian> and I think those operations are usefull too
07:15:36 <kosmikus> xerox: but "folding" is a more general concept and can be instantiated for both "list"s and "binary tree"s, and the tutorial doesn't explain that properly
07:15:50 <xerox> now i'm interested of trying this "proper fold"
07:16:21 <earthy> friggin python regex engine
07:16:27 <kosmikus> jadrian: yes, they're called reductions or crushes in the literature
07:16:29 <xerox> in fact i can't foldBT (+)
07:17:14 <xerox> i need something that operates on Leafs
07:19:00 <jadrian> you need both the (+) for the branches and something for the leafs
07:19:13 <jadrian> xerox: think about the case where your tree is just one leaf
07:19:15 <kosmikus> xerox: if you want the sum of all elements in a BT, that'd be "foldBT (\l x r -> l + x + r) id"
07:20:17 <jadrian> oh, he has elements in each branch too...
07:20:45 <xerox> yes
07:20:58 <xerox> book gives that definition
07:21:03 <xerox> is it correct for a binary tree?
07:21:06 <jadrian> yes
07:21:44 <xerox> i finally understood it i think
07:21:52 <xerox> that's really interesting
07:22:10 <xerox> (\l x r -> l + x + r) is the "recostruncting" procedure
07:22:27 <kosmikus> sort of, yes
07:22:40 <xerox> why sort of?
07:23:16 <kosmikus> because it's spelt reconstructing ;)
07:23:25 <xerox> haha, umpf.
07:23:38 <xerox> thanks much
07:24:13 <kosmikus> you're welcome
07:24:37 <Si\> can anyone think of a way of directing an output handle into some sort of memory buffer rather than into a file?
07:28:25 <CosmicRay> there is no easy way to do that
07:28:32 <CosmicRay> you could use a pipe to a separate thread or process
07:28:43 <CosmicRay> but usually you should be able to just grab a string or something instead
07:28:59 <jadrian> kosmikus: could you just take a quick look at my simply-recursive data class (pasted it on HaskellIrcPastePage) and tell me your opinion? I'd just like to know what you think of my approach...
07:28:59 <Amadan> does it have to be a handle?
07:29:26 <Si\> my problem is this, I'm trying to get the error message produced by hs-plugins if it doesn't type-check correctly
07:29:42 <Si\> this message is only relayed to stdout, but I want it as a String
07:30:20 <jadrian> kosmikus: no need to read the whole thing, I'd just like someones opinion on it the general idea (I know it's not the best approach, but I don't want to get into generic programming now)
07:30:53 <kosmikus> jadrian: why aren't you using Data.Generics ?
07:31:32 <kosmikus> ah, you don't want to, but in fact, the main functions of the classes involved there are much the same thing
07:31:39 <Si\> I can make redirect stdout to any other handle I like
07:31:41 <jadrian> kosmikus: well, the main reason is that I have no experinence with it and I got very little time left...
07:31:56 <kosmikus> jadrian: time left until what?
07:32:04 <jadrian> kosmikus: MSc Thesis 
07:32:12 <jadrian> kosmikus: deadline approaching
07:32:18 <kosmikus> jadrian: topic?
07:32:27 <jadrian> kosmikus: automated theorem proving
07:32:56 <jadrian> kosmikus: I used this for defining functions on terms, formulas and such
07:33:22 <jadrian> kosmikus: and I got a similar one for mutually recursive data structures
07:33:55 <kosmikus> jadrian: looks relatively simple and self-contained
07:34:10 <kosmikus> I assume you have a fixed set of instances for the RecData class
07:34:20 <jadrian> kosmikus: yeap
07:34:35 <kosmikus> then it's fine as long as it works
07:34:53 <jadrian> kosmikus: I think it is not very elegant in the sense that, to define a fold, I define functions on the whole data, not its components
07:36:41 <CosmicRay> is there any function out there like this:
07:36:46 <CosmicRay> mktup :: a -> b -> (a, b)
07:36:47 <CosmicRay> mktup a b = (a, b)
07:36:50 <CosmicRay> in the prelude or anything
07:36:54 <CosmicRay> I can't find one
07:37:04 <jadrian> (,)
07:37:05 <kosmikus> jadrian: yes, but it seems like a necessary evil if you don't want to use language extensions or severe type system hacks
07:37:15 <CosmicRay> huh!
07:37:23 <CosmicRay> I had no idea I could do that with the comma.
07:37:23 <CosmicRay> thanks.
07:37:36 <CosmicRay> I thought the comma was caught by the lexer.
07:37:59 <kosmikus> CosmicRay: every datatype has a prefix notation
07:38:16 <kosmikus> you can write (->) Int Int instead of Int -> Int, and you can write [] Int instead of [Int]
07:38:35 <kosmikus> ah sorry, different topic
07:39:06 <kosmikus> you were asking about the value constructor, not the type constructor
07:40:41 <jadrian> kosmikus: by the way, that paraData function is a paramorphism right?
07:41:40 <jadrian> paraData f d = f d (map (paraData f) (subData d))    <- it recurses to the subdata, then operates it with the whole term 
07:43:49 <kosmikus> seems like one, yes
07:44:23 <jadrian> nice thanks! it makes no difference for my work, but I need names for these functions :)
07:45:31 <jadrian> I actually liked the way it turned out for mutually recursuve data structures
07:45:52 <jadrian> I defined a multi param-class: class MRecData a b | a->b where
07:46:26 <jadrian> I have for instance,  subMRData    :: a->[b]
07:46:49 <jadrian> so this just means that 'a' as 'b' as subdata, nothing more
07:47:04 <jadrian> then to define operations on mutually recursive data I have:
07:47:11 <jadrian> paraMRData :: (MRecData a b, MRecData b a) => (a->[d]->c)->(b->[c]->d)->a->c
07:47:57 <jadrian> the definition of that function would be
07:48:02 <jadrian> paraMRData f g d = f d (map (paraMRData g f) (subMRData d))
07:49:15 <jadrian> that was pretty cool because even with mutually recursive data structures with quite a few components each, I could get a fold by just defining 2 functions
07:53:19 <kosmikus> hmm, that's only for two datatypes that are mutually recursive, though? what if you have three or more?
07:54:50 <jadrian> kosmikus: yeap just for two, that what I needed
08:02:45 <jadrian> kosmikus: would it be possible at all to generalize it for an arbitrary number of mutually recursive datatypes at all?
08:03:22 <kosmikus> not using this approach, I think
08:04:08 <jadrian> I would expect it not to be possible with any approach even...
08:04:46 <jadrian> because such a function would take as argument an arbitrary number of functions (one for each datatype)
08:09:14 <basti_> hi!
08:11:40 <kosmikus> jadrian: well, I guess if you have a language in which you can describe to which functor you want to apply the fold, it might work, but it certainly doesn't in Generic Haskell
08:12:46 <kosmikus> jadrian: GH does allow generic functions that do not have a functor/algebra argument for mutually recursive datatypes, though, in a relatively straightforward way
08:14:21 <jadrian> kosmikus: right
08:14:31 <basti_> can anyone explain the relation between a funktor and a monad?
08:16:19 <jadrian> I guess the short answer is, Monads are Functors, and fmap = liftM
08:16:33 <basti_> mhk.
08:16:37 * basti_ ponders a little.
08:17:03 <basti_> and fmap[LIST] = map for example?
08:17:12 <musasabi> A better question might be "what is a functor" 
08:17:57 <basti_> as i understand, a funky definition of coalgebra.
08:18:08 <basti_> isnt it?
08:34:00 <basti_> hi derelm 
08:34:31 <derelm> hi
08:35:59 <derelm> (fxv) + (rechne func (x+step) step end op) <- how would i need to transform this, to disable to avoid unneeded lazyness? (this is inside function rechne)
08:37:01 <derelm> hmm, i probably know what i mean...
08:37:04 <derelm> grr
08:37:05 <derelm> you
08:37:07 <derelm> argh
08:37:17 <derelm> ;)
08:37:28 <basti_> no.
08:37:34 <basti_> =)
08:37:43 <derelm> really?
08:38:02 <basti_> why is laziness "unneeded" at all?
08:38:10 <dude1> jesus this is better than efnet
08:38:36 <derelm> well it might lead to much more memory consumption
08:38:48 <musasabi> derelm: profile first optimize then.
08:38:49 <basti_> mmh okay.
08:38:58 <musasabi> derelm: and seq is your friend.
08:38:59 <jadrian> derelm: well you want to force the evaluation on those 2 (+) right?
08:39:10 <musasabi> of course changing lets to cases can help too.
08:39:32 <jadrian> I usually put the acummulators as the last parameter
08:39:36 <jadrian> so I can do 
08:39:39 <derelm> jadrian: yes the right one calls itself again, so i'd like to evaluate this first, as it might call itself about 10000 times
08:39:41 <basti_> i think you would have to "move inside" the (fxv) + wouldnt you?
08:39:50 <jadrian> foo arg1 arg2 $! acc
08:40:19 <basti_> i guess we mean the same jadrian we just put it different ways.
08:40:33 <jadrian> if the accumulator is one of the middle arguments you have to use extra parenthesis
08:40:43 <derelm> hmmpf
08:40:56 <jadrian> (fxv) + ((rechne func $! (x+step)) step end op)
08:41:11 <basti_> o.0
08:41:11 <jadrian> that would force the evaluation of the 2nd plus
08:41:31 <basti_> ihr habt doch gelitten =)
08:41:36 <derelm> hmm, well maybe it's not exactly what i had in mind ... 
08:41:56 <basti_> derelm: i think he is right.
08:42:02 <basti_> in some way.
08:42:03 <basti_> =)
08:42:17 <basti_> i dont know if we mean the same thing
08:42:21 <derelm> ok i'll see if it makes any difference :)
08:42:31 <basti_> my idea was that the "rechne" call should be done first
08:42:48 <Cale> you should generally order arguments such that the ones which are expected to change most are placed last
08:42:51 <basti_> tail recursion is that i believe.
08:42:58 <basti_> yep.
08:43:07 <dude1> how do u clear the screen in haskell?
08:43:14 <derelm> ctrl -l ?
08:43:20 <CosmicRay> dude1: that's an operating system function
08:43:24 <jadrian> dude1: lots of putStrLn "" :)
08:43:25 <CosmicRay> dude1: what operating system are you using?
08:43:29 <dude1> xp
08:43:33 <dude1> :P
08:43:40 <derelm> dude1: ah you didn't mean clearing the interpreters window ;)
08:43:43 <CosmicRay> I don't know how one does that in a terminal on xp.
08:43:54 <CosmicRay> presumably ^L won't work
08:43:56 <dude1> aye. its for coursework; i want to make it look nice :)
08:44:01 <CosmicRay> maybe it would in cygwin?
08:44:34 <jadrian> dude1: just print empty lines... it looks the same...
08:44:44 <dude1> lol okay
08:44:45 <jadrian> dude1: and it's portable
08:45:02 <CosmicRay> jadrian: unless you're running an 80x200 xterm on a 21" monitor or something :-)
08:45:06 <dude1> ahaha
08:45:40 <jadrian> CosmicRay: :)
08:48:24 <derelm> hmm, does anyone have a decent implementation of integral calculations? or maybe something like a lower/upper sum function handy? mine seems not to be really optimized and i'd love some inspiration
08:48:35 <basti_> thats numerics
08:48:52 <basti_> "quadrature algorithm" is the keyword for that
08:49:16 <basti_> most are pretty easy to inplement and converge sufficiently quick
08:49:24 <basti_> in fact they're reconstructable very easy...
08:49:30 <Cale> derelm: I have a Simpson's 1/3 3/8 rule evaluator
08:49:57 <derelm> Cale: err ... i don't have a clue what that is ;)
08:50:05 <basti_> take for example a polynomal approximation of the function (steps, splines of various orders) and integrate this symbolically
08:50:24 <basti_> then shrink the step size until youre happy which would be soon.
08:50:52 <Cale> http://mathworld.wolfram.com/SimpsonsRule.html
08:51:12 <basti_> thats one of them yep
09:16:55 <dude1> I've need some help. I've got an IO() function, called "DisplayMenu". I want to run a function called "makeIndex" that has String as input and returns [([Int], Word)] but I'm getting a "type error in generator error" ;/ any insight? 
09:17:27 <dude1> makeIndex works perfectly on its own.
09:20:09 <samason> dude1: a bit more context would help. . .
09:20:34 <samason> dude1: how is everything bundled together at the moment?
09:23:01 <dude1> Well, I plan to write a menu function that prompts for a file, the contents of the file gets written to a string then makeIndex runs several functions. I've tried to run one function, splitUp from the menu and I get the same error.
09:24:50 <dude1> ERROR "c:/haskell/textProc2.hs":21 - Type error in generator
09:24:50 <dude1> *** Term           : splitUp doc
09:24:50 <dude1> *** Type           : [Line]
09:24:50 <dude1> *** Does not match : IO a     
09:25:08 <samason> dude1: don't you need to do something with the return of "makeIndex" first, instead of just returning it from the function?
09:25:42 <dude1> ooo
09:25:48 <samason> dude1: (I may be coming in the middle of this, so sorry if you've gone over this before!)
09:27:02 <dude1> Well, one of the functions in makeIndex actually writes it to a file, but I understand what your hinting at. I'l give it a go.
09:28:25 <musasabi> Can anyone build cabal from darcs? It dies complaining "Can't find module `Distribution.Simple.LocalBuildInfo'"
09:28:30 <samason> dude1: if it's doing everything already, just a "return ()" at the end of the function should make the types match up -- don't know if this is right though!
09:32:45 <samason> dude1: eek, just realised the time. . .   back in a couple of hours if you respond
09:33:21 <dude1> okay man I'll try it, thanks for ur help.
09:37:54 <derelm> i am still looking for an efficient version of upper/lower sum ... my version can be found at http://paste.uni.cc/6365 (though badly word wrapped). can somone please have a look at it and give me some ideas on how to optimize?
09:41:10 <dude1> holly shit
09:41:12 <dude1> its works
09:41:20 <dude1> thanks samason
09:47:59 <samason> dude1: good to hear -- I'm really off now!
09:48:26 <dude1> ;]
09:54:31 <TheHunter> wtf? newtype CPError a = CPError (Either Error a) deriving(Monad,MonadError) is valid? This would've been very useful to me quite some time!
09:57:51 <reffie> \o/
09:57:56 <reffie> i'm done with my project!
09:58:10 <reffie> implementing a toy version of AES in haskell! \o/
09:58:18 <reffie> http://segfaulted.com/stuff/proj.pdf
09:59:53 <dude1> i've just done my project too
09:59:56 <dude1> woo
10:00:30 <dude1> lol yours is more hardcord than mine ;P
10:00:38 <TheHunter>     Can't make a derived instance of `Monad (ContState r)'
10:00:38 <TheHunter>     (even with cunning newtype deriving:
10:00:38 <TheHunter>      the newtype is recursive
10:00:38 <TheHunter>      the eta-reduction property does not hold)
10:00:38 * CosmicRay isn't done with his project yet
10:00:42 <TheHunter> :(
10:00:44 <CosmicRay> (implementing a ZIP reader <g>)
10:00:56 <CosmicRay> you guys that are done could help me :-)
10:01:09 <kosmikus> derelm: I have a nicer solution, or so I think, but I won't be able to discuss it until tomorrow
10:01:13 * CosmicRay notes this is not a school project
10:01:34 <derelm> kosmikus: ? why that
10:02:08 <kosmikus> derelm: have to leave right now, i.e. 5 minutes ago
10:02:14 <reffie> dude1 :P
10:02:31 <derelm> kosmikus: would have been nicer if you hadn't told me ... ;)
10:03:24 <CosmicRay> MegaMonad: how are your projects going?
10:03:30 <MegaMonad> CosmicRay: My client thinks it lost all my projects, both personal and economical reasons, i might be my taste though  :-)    it's possible it would be the issues involved.
10:03:44 <CosmicRay> so reffie, dude1, do you think you'll continue using Haskell after your class is over?
10:03:59 <CosmicRay> MegaMonad: you lost all your projects?
10:04:05 <MegaMonad> CosmicRay: I used to that; your doing me a whole lot of projects would be lost.
10:05:03 <musasabi> derelm: http://youzen.b2.fi/~musasabi/calc.hs - try it out whether it is slower / faster (and tell me too ;)
10:05:05 <TheHunter> MegaMonad, what do you think of lambdabot?
10:05:15 <MegaMonad> TheHunter: When you are me and i to think of lambdabot?
10:06:19 <derelm> musasabi: i'll have a look at it
10:06:30 <CosmicRay> MegaMonad: what of TheHunter?
10:06:36 <MegaMonad> CosmicRay: Thehunter: me too, but i forget exactly.
10:06:46 <CosmicRay> MegaMonad: memory problems, eh?
10:06:47 <musasabi> sauna is calling, have to go..
10:06:52 <MegaMonad> CosmicRay: Can you put in the .o files in a global variable.  It is counterintuitive (but when you have problems figuring out zip_with in terms of problems to the guy (name... ?). Pretty cool eh?
10:07:46 <CosmicRay> megamonad, you use up a lot of memory.
10:07:52 <MegaMonad> CosmicRay: Sorry, memory is a lot you can use seq, right?
10:07:59 <CosmicRay>   PID USER      PR  NI  VIRT  RES  SHR S PU %MEM    TIME+  COMMAND
10:07:59 <CosmicRay>  7068 jgoerzen  25   0  550m 549m 1516 S  0.0 62.1 286:53.50 megahal
10:08:37 <vegai> MegaMonad: that's it! You're on a diet!
10:08:42 <MegaMonad> vegai: I'm using a _very_concrete_ example, awk, which so far as i'm on a diet.
10:08:52 <CosmicRay> heh
10:09:45 <vegai> hmm
10:09:49 <vegai> @seen shapr
10:09:49 <lambdabot> I saw shapr leaving #darcs 2 days 18 hours 59 minutes 41 seconds ago.
10:09:56 <CosmicRay> I've been wondering about that too
10:10:05 <CosmicRay> I haven't known him to go 2 days without IRCing before :-)
10:10:08 <CosmicRay> hope he's OK
10:10:11 <stepcut> MegaMonad: @seen shapr
10:10:12 <vegai> a girl? :P
10:10:20 <CosmicRay> vegai: for 2 days? :-)
10:10:24 <MegaMonad> stepcut: Shapr: think the relationship between hinze's nondet monad (a -> b -> b) -> b -> [a] -> [b.
10:10:48 <jadrian> MegaMonad has a syntax error there...
10:10:53 <CosmicRay> MegaMonad: when was shapr last seen?
10:10:53 <CosmicRay> heh
10:11:00 <MegaMonad> CosmicRay: Shapr fakes out the gentle introduction is not too sure about what dependent types yet.
10:11:16 <CosmicRay> ahh, he fakes the tutorial.  now we know.
10:11:55 <chucky> megamonad: Do you know where shapr is?
10:11:56 <derelm> musasabi: it gives a totally different value ?!
10:12:00 <MegaMonad> chucky: Shapr: but i do something like (.).(.) or so, i just noticed i've gained quite transparent to me.
10:13:01 <CosmicRay> MegaMonad: do you like tom lord?
10:13:07 <MegaMonad> CosmicRay: Tom lord is my personal dns name and wanted to see me code.
10:13:13 <CosmicRay> haha
10:14:24 <CosmicRay> <MegaMonad> Eek: obraun@ has been really different and quite frankly, haskell isn't like a bike in my thesis.
10:15:11 <CosmicRay> MegaMonad: quux
10:15:17 <MegaMonad> CosmicRay: I wish i could use org.quux.missingh.foo or jsut missingh.foo.
10:15:33 <CosmicRay> oh no, java tendencies again!
10:15:36 <chucky> megamonad: Who's the coolest Haskell dude?
10:15:45 <MegaMonad> chucky: Dude, haskell is so convenient for a functional depencency or some other dude.
10:16:12 <chucky> hmm I wouldn't call functional dependencies a dude, but oh well. :)
10:19:30 <CosmicRay> heh
10:19:49 <chucky> megamonad: In your opinion, what is the best feature of Haskell?
10:19:53 <CosmicRay> <musasabi> Can anyone build cabal from darcs? It dies complaining "Can't find module `Distribution.Simple.LocalBuildInfo'"
10:19:55 <MegaMonad> chucky: And my haskell for a nice feature is that haskell?
10:20:46 <SyntaxNinja> er, I'll fix that now.
10:20:49 <SyntaxNinja> blame simon marlow...
10:22:38 <SyntaxNinja> OK fixed.  thanks CosmicRay musasabi
10:22:54 <chucky> megamonad: Do you think Simon Marlow is really the one to blame?
10:23:00 <MegaMonad> chucky: Blame me for the first one is just.
10:23:16 <stepcut> grr, itskaratekidthemusical.com's nameserver seems to be down :(
10:23:39 * chucky ought to do something more useful than chatting to MegaMonad, but it's rather fun. :)
10:24:05 <SyntaxNinja> heh
10:24:09 <CosmicRay> chucky: did you see the quotes I posed to -cafe?  megamonad was on a roll the other day :-)
10:24:45 <chucky> cosmicray: Yeah I saw it. :)
10:24:53 <SyntaxNinja> CosmicRay: which post?
10:24:59 <CosmicRay> SyntaxNinja: http://www.haskell.org//pipermail/haskell-cafe/2004-December/007880.html
10:25:10 <chucky> megamonad: Do you read haskell-cafe?
10:25:16 <MegaMonad> chucky: (That would be read in the haskell i don't really know where it might point you referenced above on the cafe list.
10:29:09 <SyntaxNinja> haha
10:29:20 <SyntaxNinja> has someone started a wiki page yet?
10:29:23 <CosmicRay> not yet
10:29:25 <CosmicRay> I really should
10:29:44 <CosmicRay> what's your favorite, SyntaxNinja?  I'm partial to "To me java is a monomorphic type" myself :-)
10:29:51 <chucky> megamonad: Why would anyone want GADTs?
10:30:09 <MegaMonad> chucky: Gadts will be used by anyone on a metaprogramming language for some haskell before any other implications of gadts for the first phrasing can be difficult to learn?
10:30:22 <SyntaxNinja> I like the kerry or bush one, since he seems to equate it with the emacs vs xemacs argument, which is rather a good point actually.
10:30:27 <CosmicRay> hehe
10:30:55 <CosmicRay> I also liked the one where a user asked if he's evil, and he said he gets eveil when working with jakarta :-)
10:31:52 <CosmicRay> what's a good wiki name... just MegaMonad?
10:34:56 <chucky> cosmicray: Wrong way to ask it. :)
10:35:03 <chucky> megamonad: what's a good wiki name... just MegaMonad?
10:35:05 <CosmicRay> heh
10:35:09 <MegaMonad> chucky: I think i'll stick to a wiki be a lot of syntax we want multiple versions in the name of a megamonad.
10:35:13 <CosmicRay> I meant to ask igloo :-)
10:35:24 <CosmicRay> hehe
10:35:43 <Igloo> Ask me what?
10:35:46 <chucky> yeah I know. But I think megamonad should have some input in this debate. :)
10:35:52 <CosmicRay> Igloo: what I should name a page of quotes
10:35:59 * Igloo has nothing to do with the wiki
10:36:03 <CosmicRay> chucky: of course :-)
10:36:03 <CosmicRay> oh.
10:36:10 <CosmicRay> @wiki MegaMonad
10:36:10 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
10:41:48 <Igloo> SyntaxNinja: when (not e) == unless e, BTW
10:42:46 <SyntaxNinja> oh yeah
10:43:26 <monochrom> MegaMonad: what is a monad?
10:43:32 <MegaMonad> monochrom: Y, i still don't see why that is understanding the functional way to combine wx stuff and i will also bring the benefit of making []'s a monad monad.
10:44:05 <monochrom> megamonad is very confused.
10:45:40 <chucky> megamonad: when should I use a monad?
10:45:46 <MegaMonad> chucky: Yeah ! And only thanks to you by the army of 120,000 with this monad a and y are diagrams.
10:46:33 <chucky> megamonad: What do you mean by that? I need some kind of army to use monads?
10:46:34 <monochrom> army of 120,000.  Good lord.
10:46:38 <MegaMonad> chucky: Hmm... First, what kind of army to use the monads do.
10:47:52 <chucky> megamonad: I'm not quite sure I follow you
10:47:58 <MegaMonad> chucky: Is it me or what.  I'm sure i follow you.
10:54:08 <SyntaxNinja> haha
10:54:23 <chucky> I think megamonad just 0wn3d me
10:54:58 <Spark> are computational effects just a posh word for side effects?
10:55:08 <Spark> s/word/term/
10:55:40 <Darius> There similar, though perhaps some computational effects wouldn't be considered side effects.
10:56:11 <monochrom> "side effect" is vague, "computational effect" is abstract.
10:56:23 <Darius> Side effect is also usually more strongly associated with either mutable state or IO.
10:57:04 <Spark> ok ive googled and found computation effects being used to represent assignments, and exceptions, i think
10:57:09 <Spark> but im still not sure what they are in general
10:57:15 <Spark> is there a convenient definition? :)
11:01:36 <Darius> Spark:  Well, "something that breaks purity" would be a fairly reasonable, though not exactly right and somewhat vague.
11:03:55 <Spark> purity...? :)
11:04:01 <Spark> referential transparency?
11:05:01 <lament> Virgin Mary is computational effect-free.
11:05:48 <basti_> Spark: i think "things that happen outside the lambda-calculus environment"
11:06:02 <Spark> hm but that includes let polymorphism
11:06:28 <basti_> they do?
11:06:45 <basti_> i think this is HM-type system?
11:06:47 <Spark> hm that can be represented 'semantically' but it cant be typed
11:06:59 <basti_> hmm
11:07:22 <Darius> Spark: referential transparency is related yes.
11:07:53 <Spark> is it a sort of catch-all term for a class of things that have been identified?
11:08:39 <Darius> If you want a formal definition of computational effect, there's Moggi's paper.  But the emphasis is on -a-, and it isn't necessarily completely aligned to the intuitive idea.
11:09:19 <Darius> Purity is not formally defined (at least not in any widely accepted way), but there's usually a strong intuitive idea.
11:09:42 <Spark> right
11:12:46 <_Codex> I thought it'd mean that "f 10" always returns the same thing.
11:13:14 <basti_> purity requires this, but not the other way round
11:13:51 <basti_> for example output is an example for side effects
11:15:21 <Spark> so is it something you ultimately have to think about when designing a pragmatic language
11:15:32 <Spark> ive been reading about value restriction in ml
11:15:36 <basti_> yep
11:16:04 <basti_> eagerness is a solution, as is monads or this thing that clean has
11:16:18 <basti_> well a way to make it treatable in a sane way ;)
11:17:21 <Muad_Dibber> evening all
11:17:47 <Darius> Amr Sabry has a paper call "What is a Purely Functional Language?" that shows some issues with most of the typical ways of defining "pure" and proposes another definition that covers all the cases mentioned.
11:18:29 <Darius> However, I don't believe it talks about the sequentially realizable functions and I don't believe that they would be considered pure under Sabry's definition.
11:19:57 <wagle> whats a SRF?
11:20:35 <Darius> A "pure" function that can't be implemented via other pure (not sequentially realizable) functions.
11:20:38 <musasabi> SyntaxNinja: ping
11:20:44 <SyntaxNinja> hi musasabi
11:20:53 <wagle> example?
11:20:57 <musasabi> Building cabal dies complaining "Can't find module `Distribution.Simple.LocalBuildInfo'"
11:21:28 <SyntaxNinja> darcs pull
11:21:59 <Darius> The function that of type ((A -> B) -> C) -> Bool that returns True if it's argument uses it's argument and False otherwise.
11:22:11 <musasabi> thanks, that was a very quickly fixed thing ^_^
11:22:50 <SyntaxNinja> I fixed it earlier :)
11:22:54 <SyntaxNinja> blame simonMar
11:23:21 <stepcut> scary! --> http://www.itskaratekidthemusical.com/
11:24:06 <wagle> Darius: whats the defn of such a function?
11:27:59 <Darius> Well mathematically, (let's call it F) F f = True, if f applies it's argument False otherwise.  However, the whole point is that it has no implementation in a pure language.  However, one simple possibility is to use exceptions F f = (f (\_ -> throw ());False) `catch` \_ -> True
11:28:23 <musasabi> now 
11:28:31 <musasabi> (sorry irssi history)
11:29:09 <jadrian> is there a short way of transforming 
11:29:13 <jadrian> (a, m b)
11:29:14 <jadrian> into
11:29:19 <jadrian> m (a, b) ?
11:29:24 <wagle> I think Meyer Goldberg had "decompilation combinators" in the pure lambda calculus a decade ago
11:29:26 <jadrian> or even better 
11:29:29 <esap> darius: What if 'f' itself raises exceptions?
11:29:41 <jadrian> is there a short way to do 
11:29:51 <esap> darius: choose B = IO () and you can.
11:30:05 <esap> darius: and C = IO ()
11:30:16 <jadrian> (a,b) -> (b->m c) -> m (a,c)
11:30:27 <Darius> esap: The language is supposed to be pure.  And A,B,C are arbitrary.
11:30:36 <jadrian> that m is a monad
11:31:00 <esap> darius: you mean it's not possible to apply the tester with a function that raises exceptions?
11:31:13 <jadrian> I couldn't think of anything better than the obvious do notation solution
11:31:39 <esap> darius: F (const (throw ()))
11:31:54 <Darius> esap: Yes.  The idea is that the language is pure, however this a function that is also pure but can't be implemented via pure functions.
11:33:32 <Darius> @type ap
11:33:33 <lambdabot> bzzt
11:33:39 <Darius> @type Control.Monad.ap
11:33:40 <lambdabot> Control.Monad.ap :: forall b m a.
11:33:40 <lambdabot> 		    (Monad m) =>
11:33:40 <lambdabot> 		    m (a -> b) -> m a -> m b
11:33:46 <esap> darius: ah ok, so you'd currently need to use unsafePerformIO to actually implement it?
11:34:05 <Darius> esap: In Haskell, yes.
11:35:02 <esap> darius: Or maybe it means exceptions are pure? :-)
11:35:04 <wagle> http://www.brics.dk/~danvy/scheme.html
11:36:29 <esap> darius: I seem to recall I have actually read the paper, but I can remember almost nothing of it...
11:36:55 <Darius> A paper about sequentially realizable functions or "What is a Purely Functional Language?"
11:43:04 <wagle> http://www.cs.bgu.ac.il/~gmayer/research/index.html
11:43:50 <CosmicRay> @wiki MegaMonad
11:43:51 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
11:43:56 <CosmicRay> OK, there's the new MegaMonad quotes page.
11:44:17 <esap> maybe the idea that you treat imperative effects as values also works other way around, e.g. you should treat lazy functions as values in the imperative world?
11:45:39 <Darius> Lazy functions are values.
11:45:50 <CosmicRay> MegaHAL: Scientists love failure; engineers love it in channel
11:45:59 <esap> darius: heh right
11:46:39 <basti_> i still can't believe there are actually places in the (virtual) world where people have such conversations
11:47:20 <esap> darius: I mean, making things act like constants is a powerful mechanism to separate layers of abstraction, such that first layer is separate from second.
11:47:36 <esap> darius: And I think you should be able to do that both ways.
11:48:49 <Darius> Making things act like constants (which I assume you mean values) is done by 'delay', and indeed it is a powerful mechanism to separate layers of abstraction, hence Haskell.
11:48:58 <wagle> whats it mean for a function to "use" its argument?
11:49:20 <Darius> wagle:  In the above case, it means apply.  I should have said apply to begin with.
11:49:38 <Darius> esap:  Have you looked at call-by-push-value?
11:49:50 <esap> darius: no, what is that?
11:49:56 <basti_> call/cc?
11:50:05 <Darius> esap: Ask Google.
11:50:08 <CosmicRay> @wiki
11:50:08 <lambdabot> http://www.haskell.org/hawiki/
11:50:18 <wagle> goldberg's thesis work seems to do something clever with that sort of thing
11:50:22 <Darius> basti: No, as in call-by-name call-by-value etc.
11:50:34 <basti_> hmm i see
11:52:31 <Darius> wagle: Is there a link to a good paper.  The publications page is some javascript thing that says it's underconstruction.
11:52:40 * basti_ .o ( wow. Wired compiles again )
11:53:12 <wagle> looking
11:53:15 <CosmicRay> MegaHAL: Eek: obraun@ has been really different and quite frankly, haskell isn't like a bike in my thesis.
11:53:24 <wagle> , already looking..
11:53:43 <wagle> i'm going on conversations with him in the early to mid 1990's
11:53:58 <Darius> I was going to get a paper called "Goedelisation in the Lambda Calculus" or something like that a while back, but I don't think I could find it.
11:54:19 <basti_> omfg.
11:54:20 <basti_> this is like basic on acid?
11:54:20 <esap> darius: hmm.. ok it tries to explain the semantics in terms of a stack? I don't think that's in general possible [but I need to read the paper]
11:54:37 * basti_ runs away and yelps
11:54:46 <Darius> stack == context
11:56:04 <esap> darius: in simple cases, stack is the context.
11:56:30 <esap> darius: but maybe the paper really talks about contexts, not stack.
12:01:15 <shapr> hej hej
12:01:17 <shapr> wassup?
12:01:50 <chucky> wow! Where have you been?
12:02:01 <wagle> man..  ogi lost its site license to acm?
12:02:20 <shapr> I've been trying to fix my xemacs mostly, but I finally gave up and switched to gnu emacs :-(
12:02:54 <CosmicRay> shapr!
12:03:01 <CosmicRay> we've been worried about you
12:03:05 <shapr> y0 CosmicRay, wassup?
12:03:17 <CosmicRay> shapr: you are apparently the AI bot's best friend
12:03:19 <_Codex> shapr: I never managed to switch to xemacs. Tried it few times, it always failed because of odd behaviour of xemacs.
12:03:22 <CosmicRay> @wiki MegaMonad
12:03:22 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
12:03:26 <CosmicRay> shapr: read that :-)
12:03:37 <xkb> MegaMonad?
12:03:37 <shapr> I had a big swedish test on Monday, so I studied on the weekend.
12:03:43 * xkb reads
12:03:44 <CosmicRay> xkb: that url explains all
12:04:20 <shapr> sequence a bunch of noobs, heh!
12:04:29 <CosmicRay> <g>
12:04:52 <xkb> lol
12:05:23 <shapr> man this is great!
12:05:35 <LittleDan> Is there a way to explicitly pass around the world, as in Clean, for purposes of I/O, instead of using the IO monad in Haskell? I don't care if it's non-standard or evil.
12:05:36 <CosmicRay> I thought you'd enjoy it :-)
12:05:54 <CosmicRay> LittleDan: no, though you can pass around IO actions
12:06:06 <LittleDan> that's really not what I want to do at all
12:06:10 <LittleDan> but thanks
12:06:14 <xkb> doesnt the IO monad implicitly pass the world?
12:06:42 <LittleDan> yes, but I need to not be in a monad
12:06:50 <LittleDan> or maybe I can be in a monad, it'd just be much less convienent
12:07:08 <xkb> LittleDan: what are you trying to do?
12:08:30 <CosmicRay> User:    Who killed shapr?
12:08:30 <CosmicRay> MegaHAL: shapr is on msdn.
12:09:04 * shapr laughs!
12:09:21 <CosmicRay> User:    do you like tom lord?
12:09:21 <CosmicRay> MegaHAL: Tom lord is my personal dns name and wanted to see me code.
12:09:33 <LittleDan> xkb: I'm making the runtime (and partly also the compiletime) for a language in Haskell. It's implemented with a datastack and a return stack, and I'm doing those with HLists. I want the language to have whatever arbitrary side effects, but I want to make sure they're in order
12:09:49 <LittleDan> I guess I could do it in the IO monad, but then I'd have to use a bunch of monad tranformers
12:09:49 <CosmicRay> But my favorite is still this:
12:09:53 <CosmicRay> MegaHAL: To me java is a monomorphic type.
12:10:00 <LittleDan> because for another part, I'm using the State monad
12:10:07 <xkb> LittleDan: sounds like fun :D
12:10:29 <chucky> megamonad: Why haven't you said hi to shapr yet? He's back now!
12:10:35 <MegaMonad> chucky: Because i'm using runwithhook to get shapr to be me not mentioned in the hi file.
12:10:58 <shapr> MegaMonad: hello there bubby
12:11:04 <MegaMonad> shapr: Boegel: hello dere bubby... Wazzup?
12:11:09 <xkb> MegaMonad: what do you think of Clean?
12:11:14 <MegaMonad> xkb: That's me and i to think of clean?
12:11:38 * xkb looks puzzled
12:11:43 <shapr> MegaMonad: Do you like programming?
12:11:48 <CosmicRay> xkb: it helps if you imagine him with a strong accent :-)
12:11:49 <MegaMonad> shapr: Don't get me a lot of changes that are mutually beneficial and they kinda dislike alignment changes... It could be great if it made the silly prompt to get programming in a coalgebra example in the i and the do notation only does category theory than monads are just glued at the moment, and also no dvd rom, although i've been using haskell?
12:12:17 <CosmicRay> shapr: for some reason, whenever you are involved, megamonad gets really long-winded :-)
12:12:17 <shapr> wow, that bot is bizarre and nifty.
12:12:20 <CosmicRay> hehe
12:12:41 <Calister> does anybody have to much free time on their hands and wants to help a haskell-complete-not-understanding person a lil bit?
12:12:45 <shapr> I wonder if there's a correlation between shapr and long-winded. Does the MegaHalgorithm use hidden markov models?
12:12:52 * Calister cant say she is used to functonal programming yet
12:12:57 <Cale> Calister: sure
12:12:58 <shapr> Calister: how may we assist you?
12:13:07 <CosmicRay> shapr: yes, see megahal.alioth.debian.org
12:13:07 <jadrian> shapr: yeah, just like most of us #haskell regulars I guess
12:13:22 <CosmicRay> shapr: I haven't noticed one, but megamonad seems to have :-)
12:13:30 <jadrian> shapr: (referring to the bizarre and nifty comment) :)
12:13:35 <shapr> jadrian: haha!
12:13:37 <CosmicRay> hehe
12:13:53 <Cale> MegaMonad: What do you think of monoidal categories?
12:13:55 <Calister> Cale, shapr: i try to find out how i can find the right signature (or however this top part after the :: is called) to my simple function
12:13:58 <LittleDan> if I do unsafePerformIO (print "hello") `seq` unsafePerformIO (print "world"), will hello be guaranteed to come before world?
12:14:03 <MegaMonad> Cale: Can anybody tell me the meaning of the categories are just in different categories.
12:14:04 <Calister> but im simply too dim to see how to get it
12:14:05 <Calister> :s
12:14:26 <CosmicRay> Calister: one thing you can do is load it up in hugs and say :t funcname
12:14:32 <CosmicRay> Calister: what does your function do?
12:15:15 <CosmicRay> LittleDan: all I have to say to you about that is: eek. :-)
12:15:31 <CosmicRay> Calister: BTW, http://www.isi.edu/~hdaume/htut/ may be helpful for you
12:15:34 <Cale> Calister: That's known as the function's type -- Haskell can infer it, as CosmicRay pointed out.
12:15:46 <Calister> thanks :)
12:15:54 <CosmicRay> Calister: there is also a good functional tutorial at http://www.merjis.com/developers/ocaml_tutorial/, though it's for OCaml
12:16:06 <CosmicRay> calister: lets say I have a function that takes an int and returns a string.
12:16:08 <CosmicRay> I would say:
12:16:12 <CosmicRay> myfunc :: Int -> String
12:16:13 <Darius> LittleDan: unsafePerformIO is not standard and gives no guarantees.
12:16:20 <CosmicRay> myfunc x = show x
12:16:27 <CosmicRay> or something along those lines.
12:16:30 <Darius> LittleDan:  However, in practice probably.
12:16:41 <Calister> okay, with hugs i know now how to get it ^_^
12:16:44 <CosmicRay> calister, basically, you list all the arguments, and then the return value, separated by ->
12:16:50 <CosmicRay> Calister: great
12:17:02 <Calister> CosmicRay, can i pm ya?
12:17:04 <shapr> MegaMonad: What did Darius say?
12:17:11 <CosmicRay> Calister: you can also refer to the haskell library docs at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html for some examples
12:17:14 <MegaMonad> shapr: Darius came up with will be difficult in haskell, maybe || ? Maybe or.
12:17:20 <CosmicRay> Calister: sure
12:17:24 <shapr> cute bot
12:17:44 <CosmicRay> shapr: do a pull in haskell-v8, btw, syntaxninja committed about 9 patches (I've got them in my repo)
12:18:04 <shapr> will do
12:18:31 <shapr> yeagh, gnumacs is so not like xemacs.
12:18:43 <CosmicRay> more... spartan?
12:18:46 <CosmicRay> ...working?
12:18:56 <CosmicRay> less... evil? :-)
12:19:18 <shapr> less working
12:19:38 <shapr> xemacs does a lot of stuff gnumacs doesn't do, but in any case, I just want Yi!
12:19:50 <shapr> anyone here used Sdf2Haskell?
12:20:28 <xkb> sdf? as in syntax description framework?
12:20:50 <shapr> I think it's syntax definition format or something.
12:21:07 <xkb> aha.. did not even know there was a sdf2haskell
12:21:08 <shapr> SDF is part of the MetaEnvironment tools from CWI
12:21:18 <xkb> yeah.. I know those
12:29:13 <Darius> Wow.  Compiling with my C++ code optimizations made a massive improvement.  I won't need to get rid of my O(N^2) monstrosity!
12:29:42 <CosmicRay> heh
12:29:43 <shapr> xkb: would you happen to know where I can get the latest (2.0.1) version of SDF2Haskell?
12:29:53 <Darius> Er, move with after "my C++ code"
12:30:18 <xkb> shapr: not by heart
12:30:37 <esap> darius: you're not planning to use the code with large inputs? :-)
12:31:03 <shapr> xkb: the link is broken, and I want to try SDF2Haskell for syntax highlighting in Yi
12:31:21 * shapr looks for JoostVisser's email
12:31:24 <Darius> As it is now, the size is hard coded.  But,  I'm not expecting to use much more than I have now (2000).
12:35:31 <wagle> wow..  i'm STILL trying to find a copy of goldberg's stuff
12:35:50 <wagle> elsevier considered harmful
12:36:25 <jadrian> huh?
12:36:31 <shapr> oy, DrIFT is barfing on autoreconf
12:36:36 <jadrian> what ?
12:36:42 <jadrian> wagle: elsevier?
12:36:48 <Darius> wagle:  There's practically nothing online (except via the ACM) except for two BRICS papers. (Or at least one of them).
12:37:17 <wagle> publish via elsevier, no-one can see you
12:37:51 <jadrian> which gooldberg are you takeing about? the "david goldberg"?
12:38:01 <jadrian> the genetic algorithms guy?
12:38:21 <wagle> i managed to get the springer-verlag paper via a subscription, but the elsevier pub is not online as far as i can tell so far
12:38:35 <wagle> jadrian likes jumping into the middle
12:38:42 <wagle> jadrian: mayer goldberg
12:38:46 <jadrian> wagle: ok ok sorry :)
12:39:16 <wagle> unfortunately, i cant disseminate the springer-verlag paper
12:39:36 <jadrian> just asked because I should have some stuff from him arround and that could be what you wanted...
12:42:23 <wagle> jadrian: i was just teasing
12:46:17 <wagle> FINALLY i get to read the "A Symmetric Approach to Compilation and Decompilation" paper
12:46:23 <shapr> yay
12:46:30 <wagle> whats it been?  an hour?
12:46:34 <wagle> yeesh
12:46:48 <wagle> lunch time
12:47:02 <shapr> It's often worse if you have zero academic ties :-)
12:47:18 <Darius> wagle: Yeah, that's the only one I have.
12:47:25 <wagle> i used my ogi tie to get the paper
12:47:35 <Darius> It's available at BRICS I believe.
12:47:48 <wagle> haha
12:48:08 <wagle> i was mostly trying to get the dissertation
12:48:24 <wagle> really surprising that its not a tech report at indiana university
12:49:06 <Darius> I want the Goedelisation in the \lambda calculus paper.
13:00:38 * CosmicRay afks
13:03:07 <shapr> hiya Heffalump 
13:03:09 <Heffalump> hi there
13:03:20 * Heffalump is just building debs of HaXml with cabal.
13:03:20 <shapr> How's code?
13:03:25 <shapr> yay!
13:03:40 <Heffalump> I need some help with the recommended way to specify what files go in what package.
13:03:50 <Heffalump> (with debs in general)
13:04:22 * Calister is a lil smarter now
13:05:05 * basti_ is not
13:05:45 <Calister> which DOESNT mean tho that i am smarter than you now ;p
13:05:55 * Heffalump doesn't know enough about the ARM architecture.
13:06:34 <Spark> its got an elbow, a wrist and a shoulder
13:06:35 <Spark> ehehheheheheh
13:06:59 <Heffalump> mostly a Wrist and a Thumb.
13:08:07 <wagle> whats the wrist?
13:08:16 <wagle> (I know the thumb)
13:08:40 <Heffalump> I think that might have been a joke, actually.
13:08:48 <Heffalump> but I remember seeing it somewhere.
13:09:22 <basti_> wrist is the hand joint
13:09:27 <basti_> the one that tilts the hand
13:10:35 <basti_> =)
13:11:07 <Spark> the one that *breaks*
13:11:10 <Spark> well, they all break
13:11:22 <Spark> but the statement still holds
13:12:01 <wagle> warning: wrists brake for anything
13:12:13 <basti_> wrake brist?
13:12:25 <basti_> i know chin brake
13:12:43 <basti_> thats a maneuver my brother did once on his BMX
13:14:17 * stepcut did the chain-break superman once
13:21:26 <CosmicRay> Heffalump: you can use missingh as an example
13:21:30 <CosmicRay> Heffalump: ar eyou going to upload to sid?
13:21:43 <CosmicRay> Heffalump: fwiw I was about to ITP haxml and xml-rpc so thank you for doing the work instead :-)
13:22:13 <Calister> wb
13:22:17 <Heffalump> CosmicRay: I used it as an example, but I'm not sure of the correct way to specify that certain things should go in certain packages
13:22:34 <Heffalump> and I'm not a Debian Developer, but I'd be happy to give you what I do if you want to fix it up properly and upload it.
13:23:15 <Heffalump> I'm a bit confused by the fact that dh_haskell does all the building in the install phase
13:23:21 <CosmicRay> Heffalump: what do you mean by "certain packages"
13:23:26 <CosmicRay> Heffalump: yeah, that is nonstandard
13:23:33 <Heffalump> why is it necessary?
13:23:48 <CosmicRay> Heffalump: it should get it all correct if you have specified things using standard names in control
13:23:51 <Heffalump> haxml consists of two binary packages, the library and one called haxml which has some tools in it
13:23:54 <CosmicRay> Heffalump: it's not, it was just easier
13:23:55 <CosmicRay> ah.
13:23:57 <Heffalump> I want to partition the files into the appropriate bits
13:24:12 <Heffalump> the tools are build by executable specifications in the cabal file
13:24:20 <CosmicRay> Heffalump: dh_haskell will install the bits that cabal installs
13:24:38 <Heffalump> right, and it puts them all in libghc6-haxml-dev, which isn't what I want
13:24:38 <CosmicRay> Heffalump: then you can use dh_move (or dh_movefiles?)
13:24:42 <Heffalump> ah, ok.
13:25:07 * Heffalump notes that the man page recommends use of dh_install instead
13:25:19 <Igloo> Why is it easier to do everything in install? cabal is broken up in the same way isn't it?
13:26:03 <CosmicRay> Igloo: it is, and it's possible, I was just in a hurry and having to deal with Perl.
13:26:13 <Igloo> :-)
13:26:13 <CosmicRay> Igloo: changing that is on my todo list
13:26:21 <Igloo> OK, cool
13:26:31 <CosmicRay> Igloo: I also accept patches :-)
13:26:43 * CosmicRay is happy to get out of doing perl work
13:27:20 <Igloo> Gee, I'd love to, but someone asked me to write deflate...  :-
13:27:27 <CosmicRay> haha
13:28:09 <CosmicRay> I think we need to seq igloo, he's too lazy...
13:28:31 <CosmicRay> deepseq even :-)
13:28:38 * shapr fires a heat-seq'ing missile at Igloo 
13:29:02 <CosmicRay> shapr: good job giving megamonad a violent streak :-)
13:29:08 * shapr snickers
13:29:20 <shapr> Poor bot talks about unicycling, violence, and shapr.
13:29:23 <CosmicRay> megamonad does continue to learn from everything said in the channel, except lambdabot
13:29:24 <CosmicRay> hehe
13:29:28 <CosmicRay> also Smerdy.
13:29:30 <shapr> He's warped for life, I tell you!
13:29:31 <shapr> oyy
13:29:34 <CosmicRay> nobody can figure out why that is :-)
13:30:02 <stepcut> but lambdabot is the most sensible person on the channel :(
13:30:04 <stepcut> @yow
13:30:05 <lambdabot> Yow!  Are you the self-frying president?
13:30:17 <CosmicRay> stepcut: yes but botloops can be ugly
13:30:31 <stepcut> hehe
13:30:36 <shapr> the irc standard says that bots should only use Notice
13:30:41 <shapr> so that loops will never happen.
13:32:50 <Heffalump> can cabal be told to put executables somewhere else?
13:40:52 * Darius may need to get the new BR CD earlier than he intended.
13:48:41 <musasabi> Heffalump: --prefix
13:51:20 <bringert> shapr: did you see this gem?
13:51:22 <bringert> <Philippa> MegaMonad: shapr has multiple personalities? 
13:51:22 <bringert> <MegaMonad> Philippa: Smerdyakov, but not a multiple of that could be effected by judicious use of other keys is easy to store it as the sorts of personalities.
13:51:22 <bringert> <vegai> shapr is Smerdy?!
13:59:37 <chucky> megamonad: Should go to bed soon?
13:59:42 <MegaMonad> chucky: It's soon to be back soon.
14:00:05 <chucky> Megamonad: Sorry, let me rephrase that. Should I go to bed soon?
14:00:11 <MegaMonad> chucky: In fact, good point.  Bed would be pretty soon if i want to rephrase that.
14:00:44 <Darius> Actually, that kind of makes sense.
14:01:38 <chucky> it does. :)
14:02:50 <goron> MegaMonad: Oh.. bottie, bottie, bottiethingie...
14:02:56 <MegaMonad> goron: Oh, and a user perspective, twiki feels too restrictive to me, peace and prosperity.
14:03:00 <yonkeltron> hi. i need some help here. i have been looking for a good haskell tutorial. a hello world and some basic arithmetic etc. i am a python programmer with severely limited experience with php, lisp and c.....i just want a decent tutorial to get me started before i start reading a huge language overview.
14:03:24 <bringert> man, that really makes sense
14:03:24 <goron> yonkeltron: Reed Hal Daums III stuff. 
14:03:35 * bringert is starting to be afraid of MegaMonad
14:03:50 <goron> MegaMonad: What about this?
14:03:56 <MegaMonad> goron: Eral `-', make it the whole thing to (\x.x) to extract the contents of x years of writing a plotting function.
14:04:15 <bringert> MegaMonad: do you want to go to bed with chucky?
14:04:17 <goron> MegaMonad: What about this?
14:04:21 <MegaMonad> bringert: Chucky: i know python enought to me.
14:04:27 <MegaMonad> goron: But they're damn great.
14:04:28 * stepcut plays Hal Daums III on his clarinet
14:04:32 <Darius> bringert:  That looks like it was a near quote.
14:04:40 <yonkeltron> goron: where would i find that?
14:04:53 <goron> haskell.org/learning, I thought.
14:05:01 <chucky> megamonad: Hey, I never said that about Python!
14:05:04 <goron> haskell.org click something
14:05:05 <bringert> 10:15:45 <xerox> ok i know python enought to understand translations
14:05:07 <MegaMonad> chucky: You might have a dog and doing alpha renaming and the program installed, "lsof -i" will show you the problem with python that would directly contribute to the same amount of information also could/would be different because i looked at php sources is great hey.
14:05:16 <bringert> from 2004-11-20
14:05:21 <goron> MegaMonad: What's Haskell?
14:05:31 <MegaMonad> goron: Haven't written any haskell?
14:05:45 <bringert> that's probably true
14:05:46 <goron> MegaMonad: What IS Haskell?
14:05:57 <MegaMonad> goron: Well, come by #haskell and meet really unintuitive?
14:06:06 <bringert> MegaMonad: I need a haskell tutorial
14:06:11 <MegaMonad> bringert: The tutorial a good way to do haskell.
14:06:15 <goron> MegaMonad: I am already there :)
14:06:22 <bringert> MegaMonad: who are you calling unintuitive?
14:06:22 <MegaMonad> goron: You reduce when you have a ps2, but only to tell which variants are available at http://www.mail-archive.com/haskell-cafe                  0x1.4fda800000097p-895skell.org/msg14555.html.
14:06:28 <MegaMonad> bringert: I teach the graph once and i want to remind me like it just looks ugly and unintuitive.
14:06:30 <goron> bringert: I will fetch the address for ya.
14:06:55 <bringert> MegaMonad: goron misunderstodd
14:07:00 <MegaMonad> bringert: Goron: darcs pull -a.
14:07:09 <goron> http://www.isi.edu/~hdaume/htut/
14:07:42 <bringert> goron: yonkeltron was the one looking for a tutorial
14:07:49 <bringert> I was just bugging MegaMonad
14:08:08 <bringert> hmm, I think the MegaMonad stuff is increasing the s/n ratio here
14:08:11 <goron> My store in memory procedure is buggy ;)
14:08:25 <goron> bringert: Decreasing.
14:08:50 <bringert> you think so?
14:08:56 <goron> bringert: Well, depends on definition ;)
14:09:16 <goron> MegaMonad: Who are you, anyway?
14:09:23 <MegaMonad> goron: Hoi dr_fripp.
14:09:43 <Heffalump> musabi: I don't want it to put the library elsewhere, just the executables
14:10:08 <goron> MegaMonad: Where do you live?
14:10:15 <MegaMonad> goron: Well i takes a list of live references from the software i write code that you've defined one of those people are convinced they're that more people don't say that, i that paper.
14:10:55 * goron should write a program to ask all this questions and fetch the answers, and compare them automatically, sorted by intelligence. 
14:11:03 <goron> this->these
14:12:54 <goron> MegaMonad: Perl. 
14:13:00 <MegaMonad> goron: And1 takes two arguments to (/) must have the dynamic-type (perl, python) bigots in mind.  I assume this means that it's written in haskell, the more packages than most (all?) others.
14:16:21 <CosmicRay> MegaMonad: can you sort by intelligence?
14:16:27 <MegaMonad> CosmicRay: I want me to some constraints i get :)  shouldn't be too hard about an unlambda interpreter, and bits of intelligence put into the specification i'd give.
14:17:50 <CosmicRay> MegaMonad: what are your constraints?
14:17:56 <MegaMonad> CosmicRay: With my generation of native ip students go into a few seconds ago, not a compiler, my haskell just using my window with that one, modulo space constraints.
14:18:00 <Calister> can anybody tell me what haskell tries to tell me if it throws  "unification would give infinite type" as error msg?
14:18:38 <bringert> you've done something like applying a function to itself
14:19:21 <Calister> hmmm
14:20:45 <bringert> if you are using hugs, testing in ghci might give you a more informative error message
14:21:04 <Calister> im indeed using hugs
14:21:09 <bringert> if you haven't given the function an explicit signature, adding one could also help give you a better message
14:22:34 <Calister> oi :x im quite good in breaking stuff
14:23:14 <basti_> re derelm 
14:23:14 <basti_> ls
14:23:18 <derelm> re
14:23:24 <derelm> grr, client crashed
14:23:30 <basti_> =)
14:26:16 <Calister> omigod
14:26:21 <Calister> i cant believe it
14:26:35 <Calister> i understood what haskell wanted from me
14:26:42 <Calister> and now the prog works
14:26:47 <chucky> calister: Congratulations. :)
14:26:47 * Calister faints
14:26:50 <Calister> thx
14:26:51 <Calister> ^_^
14:27:31 <Calister> i feel so proud of myself *lol* n i managed to do it all alone without cheating
14:38:21 <CosmicRay> is there a way to do a multi-line string literal in haskell?
14:38:32 <Heffalump> no
14:38:32 <CosmicRay> without hugs non-standard here doc suppotr?
14:38:34 <CosmicRay> rats.
14:39:55 <Igloo> There are string gaps, but you still have to put the \ns in yourself
14:40:01 <Igloo> foo = "bar\n\
14:40:05 <Igloo> \baz\n\
14:40:08 <Igloo> \quux"
14:40:20 <CosmicRay> hmm, I tried the \ at the end of the line and it didn't seem to like it, though maybe I misinterpreted the error mesag
14:40:28 <Igloo> Are you using cpp?
14:40:31 <CosmicRay> no
14:48:06 <monochrom> desrt: yes it's me there on efnet
14:48:25 <desrt> :)
14:48:30 <desrt> you're a functional whore!
14:48:42 <desrt> you're all like haskell lisp schemeing it all over the place
14:49:52 <monochrom> No, just haskell and scheme and ocaml
14:54:39 <CosmicRay> MegaMonad: ever been to efnet?
14:54:45 <MegaMonad> CosmicRay: But, you sure be aware that efnet was still banned on v4, he banned me from #twisted for arguing about the naturals having no upper bound...
14:59:41 <bringert> MegaMonad: tell me more about the naturals
14:59:46 <MegaMonad> bringert: And you only use windows unless paid to write a function of type a -> b, and you have to change the syntax for naturals?  Now if you change them to make fail ...
15:00:21 <bringert> MegaMonad: how much would you pay for a function a -> b?
15:00:26 <MegaMonad> bringert: Si\: still don't have to pay al lot of function might be me, but a number.
15:05:36 * shapr laughs as MegaMonad 
15:05:42 <shapr> bringert: truly that is a gem.
15:06:29 <shapr> er "laughs at" I have enough personalities already.
15:24:52 <jadrian> *** Exception: Prelude.(!!): index too large
15:24:53 <jadrian> :(
15:24:58 <jadrian> I hate when this happens
15:25:36 <jadrian> I've reduced "unsafe" uses of functions to avoid this sort of stuff
15:25:42 <jadrian> so I think I now where it comes from
15:25:48 <monochrom> You have a list of unprecedent length?
15:26:09 <jadrian> I know what that means ;)
15:27:08 <bringert> does "+RTS -xc" help in such cases?
15:27:13 * bringert is to lazy to test
15:27:16 <jadrian> I was just thinking about a discussion in Haskell Cafe about stacking error messages
15:27:22 <bringert> and goes to sleep
15:27:24 <wagle> []     !! _       = error "Prelude.!!: index too large"
15:27:25 <jadrian> ?
15:27:29 <Calister> ok, i know that []:xs = xs is wrong.. but can someone tell me the reason? ppl always seem to tell me different reasons
15:27:37 <jadrian> wagle: exactly
15:27:58 <jadrian> because of that I even defined my  !!? operator
15:28:07 <jadrian> that returns Maybe a
15:28:08 <wagle> (i'd been wondering why it wouldnt tell you what index was too large
15:28:29 <monochrom> I don't understand what "[]:xs = xs" means.  Perhaps that's what's wrong with it.
15:28:58 <jadrian> wagle: eh wouldn't help much
15:29:12 <Calister> well.. the xs is from the (x:xs) i suppose
15:29:18 <Calister> like the rest of a list
15:29:21 <Heffalump> calister: first of all work out what type xs should have in that 'equation'
15:29:33 <jadrian> what I would like was some easy way to find out what called that !!
15:29:48 <jadrian> even though I don't think it will be necessary ow
15:29:49 <jadrian> now
15:29:54 <jadrian> brb
15:30:18 <Calister> Heffalump.. it can be everything.. ints, chars, lists
15:30:26 <Heffalump> no.
15:30:37 <Janni> G'evening.
15:30:47 <Heffalump> (the standard way to say what you just did is to say it has type 'a' for some type variable a)
15:30:53 <monochrom> "what's wrong with ___" questions are very hard to answer.
15:31:02 <Calister> lol
15:31:05 <Calister> ya
15:31:07 <Calister> hi Janni
15:31:22 <monochrom> "what's right with ____" I can answer.  I can furnish a proof of why ___ is right.
15:31:40 <Calister> i just dislike to know that something is wrong but i cant point out why its wrong. its what profs like to ask in exams
15:32:12 <Heffalump> monochrom: what's right with []:xs = xs ?
15:32:29 <Calister> lol
15:32:32 <monochrom> It can't be right.  There is no proof.
15:33:17 <monochrom> Ok, first, what is "=" there supposed to mean?  Is it the Haskell "="?  Is it the human "="?
15:33:33 <blackdog> monochrom:you need a bit more than that, or Goedel will smack. :)
15:33:46 <Calister> i think a human "="
15:34:25 <monochrom> Ok.  I assume []:xs type-checks.  (Even that is a big question.)
15:34:27 <Heffalump> monochrom: but you just said you could furnish a proof.
15:34:37 <Heffalump> And if you can't, then can you prove that there is no proof?
15:34:58 <monochrom> The length of []:xs is one more than the length of xs.  So []:xs cannot equal xs.  Leibniz rule.
15:35:15 <Heffalump> what is Leibniz rule and why does it apply?
15:35:44 <monochrom> Leibniz rule may be more common known among you as "referential transparency".  x=y implies fx=fy.
15:35:50 * Heffalump notes that xs := repeat [] is a solution of the equation
15:36:19 <wagle> suppose xs is the infinite list of empty lists
15:36:19 <Heffalump> so I'm not very impressed by your proof
15:36:22 <blackdog> you're a cunning bastard, heffalump
15:36:34 <monochrom> Aha! I forgot the infinite case.  You are right.  Not much wrong with []:xs equals xs barring typing.
15:36:47 * wagle 8-p's Heffalump 
15:36:47 <Heffalump> :-)
15:36:54 * xerox is lost.
15:37:04 <Heffalump> blackdog: I blame the Aussie influence.
15:37:26 <monochrom> Nothing wrong with the existence of xs such that []:xs equals xs.  That's the conclusion.
15:37:33 <wagle> xs = [] : xs
15:38:18 <wagle> though i still cant type that in in haskell
15:38:26 <Heffalump> xs :: [a]
15:38:28 <Heffalump> for any a
15:38:36 <monochrom> xs :: [[a]]
15:38:45 <Heffalump> oh, sorry.
15:38:48 <Heffalump> what he said.
15:38:49 <wagle> gotta know what a is
15:38:59 <Heffalump> oh, right.
15:39:07 <monochrom> @type []
15:39:08 <Heffalump> give it an explicit type signature
15:39:08 <lambdabot> [] :: forall a. [a]
15:39:24 <monochrom> xs :: forall a. [[a]]
15:39:27 <wagle> oops "still cant type that in at _top-level_ in haskell
15:39:31 <Heffalump> in ghci?
15:39:37 <Heffalump> how are you trying to type it in?
15:39:44 <monochrom> oh of course there is monomorphingy
15:39:47 <Heffalump> yes
15:39:53 <Heffalump> but it works for me in ghci
15:40:02 <wagle> xs = [] : xs :: [Int]
15:40:04 <Heffalump> (I think that doesn't care about the monomorphism restriction)
15:40:08 <monochrom> @type [[],[],[]]
15:40:09 <lambdabot> [[],[],[]] :: forall a. [[a]]
15:40:13 <monochrom> There.
15:40:23 <Heffalump> wagle: you're trying to write it in a .hs / .lhs file?
15:40:30 <Heffalump> if so, give it an explicit type signature
15:40:47 <monochrom> @type let xs = []:xs in xs
15:40:48 <lambdabot> let xs = []:xs in xs :: forall a. [[a]]
15:40:54 <wagle> thats what i was implying
15:40:56 <Darius> The influence of Haskell on a C++ programmer: const char * const name() const { return m_Name; }
15:40:59 <wagle> see above
15:41:33 <Heffalump> module Main where
15:41:33 <Heffalump> xs :: [[a]]
15:41:33 <Heffalump> xs = []:xs
15:41:35 <Heffalump> works for me
15:41:40 <blackdog> Darius: I never thought referential transparency could look so goddamn ugly
15:41:59 <Darius> blackdog: Immutable values should be the default.
15:42:16 <blackdog> Darius: absolutely
15:42:27 <Heffalump> what does the third const mean?
15:42:30 <wagle> in C++?  get serious
15:42:50 * Calister scratches her head.. now im all confused again
15:43:06 <Heffalump> calister: sorry :-)
15:43:18 <Heffalump> []:xs = xs does have a solution, as we just discussed.
15:43:33 <Heffalump> If the question is "does []:xs = xs for all xs", then you can easily exhibit a counter-example.
15:43:37 <wagle> _in what context_?
15:43:53 <monochrom> Don't guess what the question is supposed to be.
15:44:01 <Heffalump> wagle: what are you asking about?
15:44:07 <monochrom> We trust the students always ask the questions the way it is intended.
15:44:24 <Calister> its rather a "is there any possible xs for which []:xs = xs correct? and if there is one, what is it?"
15:44:40 <monochrom> Then we have solved it.  See line 928347114 above.
15:44:46 <Calister> lol
15:44:55 <wagle> where is the hole in which we are dropping "[]:xs=xs" into?
15:45:26 <Calister> monochrom, you would love the homework of my prof... its buggy.. sooooooooooooo many bugs in it + the questions can be understood different ways
15:45:50 <monochrom> wagle I think the question is "find a context to make []:xs equal xs"
15:45:57 <Darius> Heffalump: The third const is a const qualifier for the class.
15:46:27 <wagle> [] : xs == xs
15:46:42 <shapr> Calister: who's your prof?
15:46:54 <wagle> [] : [] : xs == xs
15:47:01 <wagle> [] : [] : [] : xs == xs
15:47:09 <desrt> no.
15:47:13 <Heffalump> darius: ah, ok. Didn't realise it was a member function.
15:47:26 <desrt> [] : xs = [] : xs
15:47:33 <desrt> where xs :: [[a]]
15:47:40 <Calister> a very nice guy called Prof. Schweppe. he is really nice. but his questions.. confusing
15:47:46 <desrt> ie: if xs is [[3]]
15:47:52 <monochrom> That's the name of a soft drink.
15:47:52 <desrt> then []:xs is [[],[3]]
15:48:11 <_Codex> If two things are equal, you can substitute.
15:48:41 <Calister> shapr.. why are you asking?
15:48:42 <wagle> Calister: some of the fun is investigating all the possible interesting interpretations of the confusing question
15:49:01 <Calister> wagle.. wont be funny in exam ;o
15:49:22 <shapr> Calister: just curious, some profs have bad reputations, I was wondering if it's someone I know.
15:49:36 <Calister> shapr.. and do you know him? ^_^
15:49:45 <wagle> "i interpret this question to mean ____, and the answer is ___"
15:49:52 <shapr> Calister: nope, don't know Prof. Schweppe
15:50:07 <wagle> the danger is coming up with a boring interpretation of the question
15:50:28 <shapr> or an exciting interpretation that irritates all your classmates?
15:50:39 <Calister> wagle... lol ^_^ sounds actually like a good idea. i suppose his helpers should get money for the km's they gotta walk during the exam from one student to the next to explain the questions
15:51:18 <Calister> hmmm
15:51:42 <shapr> good idea, sort of like paying mileage to employees who use their own cars.
15:51:55 <Calister> uh huh ^_^
15:52:21 <Calister> i got the solution for a lil proggy... actually i got two.. they are both kinna alike. i made my own proggy and it looks completely different o.o
15:52:42 <Calister> why do my progs always look different? >_>
15:53:25 <Lemmih> shapr: You're back!
16:12:22 * Calister yawns
16:13:07 <Heffalump> UK tax rules are bizarre. You can pay employees 40p/mile mileage, but non-employees can only get 20p/mile.
16:14:24 <Calister> should i trust my teampartner and simply take his answers to the questions? then i could lay down and sleeeeeeeeep
16:16:02 <shapr> Lemmih: was I really gone that long?
16:16:46 * Calister flips a coin
16:16:55 <shapr> Life has been somewhat distracting lately. I'm pining for the solstice.
16:18:22 <Calister> solstice? when is it?
16:19:19 <CrewdenX> the 21st,  or so, isn't it?
16:21:31 <shapr> Memories or descriptions of the long winter nights near the Arctic Circle don't have the same heavy depressing pressure as actually being there and feeling the energy leech out into the lightless cold. When the sun is only a sliver on the horizon at noon, I feel like clockwork that desperately needs winding.
16:22:35 <Calister> shapr, where do you live?
16:22:46 <shapr> About 90 km south of the Arctic Circle.
16:23:03 <Darius> Crap.  My program runs differently under gdb and doesn't crash, but doesn't work.
16:23:04 <shapr> I live in Boden, Sweden, just outside of Lule, Sweden.
16:23:10 <Heffalump> you should move to the Antarctic for winter
16:23:13 <Heffalump> (NH winter that is)
16:23:21 <shapr> Heffalump: that's a brilliant idea, I'd love that.
16:23:23 <Calister> i got friends in sweden and finland
16:23:49 <Calister> long depressing winters you get there up in the north
16:23:53 <Calister> >_<
16:24:12 <shapr> This is the best time of the year to fly back to the states and visit. Weirdest thing is that most of the natives take their long vacations in other countries in the summer!
16:24:44 <shapr> The summer here is wonderful! You can read a book at 3am, jog around the lake, whatever.
16:24:52 <Calister> maybe it would be too frustrating to return into the coldness?
16:25:00 <Calister> lol
16:25:17 <Calister> i was in sweden in august
16:25:32 <shapr> Visiting friends? Which part of Sweden?
16:26:18 * jadrian feels like he's in sweeden
16:26:22 <jadrian> It's cold
16:26:25 <Calister> i visited a friend in Linkping and did some sightseeing in stockholm
16:26:47 <jadrian> I go to bed late and get up in the afternoon so I only get to see a few hours of light
16:27:46 <jadrian> unfortunately no hot blondes around :(
16:27:58 <Calister> lol
16:28:34 * jadrian works...
16:28:53 <Calister> its funny how most guys react on blonde hair
16:30:33 <shapr> I'm an equal opportunity admirer. I'm ready to appreciate any flavor of God's most beautiful creations.
16:31:45 * Calister had pink hair for a while.. not really a creation of god, but still nice ^_^
16:31:50 * shapr grins
16:32:25 <Calister> it looked really quite kewl ;)
16:32:41 <Calister> eventho my dad nearly got a heartattack
16:32:52 <Calister> and couldnt wait till it was gone again
16:33:24 <shapr> I think the exotic and the unusual receives the most appreciation. Many of the women in this area prefer a very particular dark red color, even though their natural color is blonde.
16:34:18 <shapr> I tried to bleach my hair blonde once, but several repeated bleachings only got me to strawberry blonde. My hair wasn't soft either, I didn't like that.
16:34:21 * Darius prefers black hair.
16:35:02 <shapr> see shapr --> http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
16:36:01 <Calister> ya, dark hair is hard to bleach.. esp if there is a lil reddish in it
16:37:00 <Darius> shapr: Oh yeah, I got my hair cut.  It is now under half a foot.
16:37:16 <shapr> Darius: pix?
16:37:34 <shapr> oh, have you seen pix of my new mad unicycle skillz? --> http://www.scannedinavian.com/images/uni-hop.jpg
16:37:41 <Darius> Unfortunately no.  In fact, I don't think there are any pictures whatsoever of me with long hair.
16:37:53 <shapr> any pix of you with short hair?
16:38:45 <Darius> Not digital.  Or at least not digital that I have.
16:38:56 <Darius> Cool picture though.
16:39:07 <Darius> I think that's the first time I've seen your unicycle.
16:39:22 <xerox> http://www.scannedinavian.com/images/deathbymath.jpg
16:39:27 <xerox> ^- ah ah ah
16:40:15 <Darius> I've never seen integral signs so slanted.
16:40:25 <shapr> xerox: those are pix from my 'blog at http://www.scannedinavian.com/ I find them all over the 'net
16:40:59 <Darius> That reminds me of some geometric calculus calculating I did.
16:41:21 <shapr> Darius: oh, that's my second unicycle. my first one was a 20" training uni, this new one is a 24" mountain unicycle.
16:42:31 <Darius> I should learn to unicycle.  No particular reason why; I should just do it.
16:42:39 <shapr> this is a partial pic of my first uni - http://www.scannedinavian.org/~shae/foto/shaecycle.jpg
16:42:56 <shapr> Unicycling is really good meditation of some flavor.
16:44:48 <shapr> You can't think very hard about anything except unicycling if you don't want to fall off.
16:44:51 <Igloo> unicycling is somewhere below learn the piano on my list, so not likely to happen any time soon  :-)
16:45:14 <shapr> It's like anti-programming. It's very good for relaxing my brain when I can't stop thinking about a problem.
16:45:44 <Calister> trampolin
16:45:49 <Calister> try trampoline
16:47:18 <shapr> I haven't tried a trampoline in many years. That would be fun.
16:47:38 <shapr> I'd like to try snowboarding soon. I wonder if my past life as a skateboarder would help there.
16:48:19 <Calister> hmm
16:48:27 <Calister> i never tried snowboarding
16:48:45 <Calister> skiing was all i done... and ski-falling ;o
16:49:11 * Darius would more like to jump out of planes.
16:49:17 <shapr> Oh, I want to try skiing, it sounds like fun.
16:49:30 <shapr> Unicycling in deep snow is GREAT!
16:49:54 <Calister> skydiving
16:49:56 <Calister> hmm
16:50:00 <Calister> i wanna try that one day
16:50:18 <Calister> esp since normal diving last time didnt go that well :s
16:50:29 * Calister wonders if she will dare it next year again
16:51:03 <shapr> I was snowjumping day before yesterday. There's a nearby parking lot with a dropoff where the pavement ends and there's a half a meter drop into snow.
16:51:26 <Calister> you got snow already? :o
16:51:52 <shapr> We have *lots* of snow.
16:52:30 <Calister> we just got rain here :s
16:52:36 <Calister> *LOTS*
16:55:09 <Darius> Calister: Where do you live roughly?
16:55:36 <Calister> Germany
16:55:48 <Calister> or to be more exactly:
16:55:50 <Calister> Berlin
16:56:25 * Darius goes to some online map site to compare latitudes.
16:56:55 <Calister> where do you live? ;o
16:57:08 <shapr> I've never been to Berlin. I've been to Munich and Nuremberg(sp?)
16:57:37 <Calister> Nrnberg (Nuernberg) (i think)
16:57:53 <Darius> Calister: Virginia, USA
16:57:54 <shapr> They had a really cool castle.
16:58:39 <Calister> oh
16:59:35 <Calister> there is a nice palace here in Berlin too :)
16:59:58 <shapr> Not so many palaces in the USA. None in the southeast that I can think of.
17:08:21 <Janni> Are there palaces in the USA at all? Who built them?
17:10:05 <wagle> there a replica of stonehenge
17:10:13 <wagle> there's a replica of stonehenge
17:10:20 <xerox> goodnight!
17:10:38 <Igloo> What's the definition? Surely some mad popstar or someone has built one?
17:11:03 <shapr> I think the Vanderbilts had an oversized house.
17:11:23 * Darius doesn't know whether take the fact that most of his coding errors are simple stupid mistakes to be a good thing or a bad thing.
17:11:25 <Riastradh> There's at least one genuine castle (well, technically: it was disassembled in Europe and reassembled in the US, if I remember correctly).
17:11:27 <Igloo> Ah, you need to be some sort of great official to have a non-loosely-defined palace
17:11:50 <wagle> isnt london bridge somewhere in the usa now?
17:12:11 <Calister> o.o
17:12:18 * Darius is surprised that he is the only one even remotely topical.
17:12:35 <shapr> Oh, I want sdf2haskell discussion.
17:12:40 <shapr> Darius: have you tried Yi?
17:12:51 <shapr> I'm trying to figure out a good way to do syntax highlighting.
17:13:25 <Darius> I would.  But it seems the only way to get it is darcs.  I don't feel like building darcs but the site that allegedly has a win32 binary is(was) down.
17:13:32 <shapr> hm
17:13:35 <Janni> Could anyone please release the yi sources in a tar.gz? It would make it easier for me to write a FreeBSD port for it.
17:13:43 <shapr> um, sure
17:14:07 <shapr> I'm running the euro mirror of the darcs repo (and the DarcsWiki too) so I can probably mirror both of those.
17:14:44 <Janni> That would be nice.
17:15:22 <shapr> I have a nightly pull script, I can build a .tgz file with that too.
17:15:39 <shapr> I wish the darcs.cgi automatically did that.
17:17:45 <shapr> up to the minute sources -> http://www.scannedinavian.org/~shae/yi.tgz
17:18:22 <shapr> that's the whole darcs repo, in case it helps
17:18:27 <stepcut> Janni: isn't darcs in the freebsd ports ?
17:20:31 <Janni> stepcut: Yes it is, but a dependency from yi to darcs isn't really necessary
17:22:50 <Darius> shapr: It seems the glozer.net is up now, so as long as it remains that way for a few more minutes I should have a darcs.
17:22:58 <shapr> spiffy
17:31:15 <dons> I might run a nightly .tar.gz build script like I do for hs-plugins
17:31:28 <dons> seems there is a bit of a demand. this issue has come up a few times
17:32:08 <dons> Janni: you'll be happy to know that I now test on FreeBSD too, so it should be no problem -- though I'm not sure if it is ready for the ports tree yet..
17:32:11 <shapr> g'day dons!
17:32:15 <dons> hey shapr!!
17:32:56 <dons> how's the northern hemisphere?
17:33:07 <shapr> cold, dark, depressing... :-)
17:33:18 <Janni> dons: I thought so too, I just wanted to write the port for myself, for testing.
17:33:24 <Calister> HE GOT SNOW!
17:33:35 <Janni> dons: Of course I would submit it, if it's ready...
17:33:53 <dons> Janni: cool. feeback it welcome on the build system etc. I'd like to make it easy to package up
17:34:26 <dons> shapr: hot and sunny down here :p
17:34:32 <shapr> lucky you
17:34:43 <dons> too hot sometimes. 41.8C a few days ago .. blargh
17:34:44 <shapr> ship me a sunwarmed rock ;-)
17:34:48 <shapr> oh man, I'd love that.
17:35:01 <shapr> we had 25 ... minus
17:35:08 <dons> scary
17:35:16 <shapr> I don't think it's gone below 30 yet.
17:37:07 <shapr> I like life hot and sunny, I really will come visit you guys. Hopefully before you've all left UNSW =)
17:37:29 * Igloo prefers cold to hot
17:37:43 <Igloo> But those are both a bit extreme for my taste  :-)
17:37:58 <dons> too much for me too
17:37:58 <shapr> How cold/hot does it get where you live?
17:38:25 <dons> shapr, well we've got another 2 - 3 years, I'd say..
17:38:35 <shapr> I think I can make it in that timeframe.
17:39:00 <Igloo> I think it would be unusual for it to go outside of -5..30, but I'm not sure
17:39:23 <shapr> it gets up to 40 here for about a week each year.
17:39:29 <shapr> that's my favorite part of the year.
17:39:40 <shapr> of course, it gets cold really faster after that :-(
17:41:50 <Lemmih> Is something like this possible: test :: TypeQ -> Q [Dec]; test t = [d| func :: t; func = undefined |]
17:42:48 <Igloo> You'll have to build it with the smart constructors
17:43:32 <Igloo> do d1 <- sigD (mkName "func") t; d2 <- [d| func = undefined |]; return [d1, d2] or somesuch
17:44:24 <Igloo> Posting to the list saying you want to be able to splice types will probably make it happen sooner
17:46:12 <Lemmih> Thanks.
17:48:00 <dons> shapr: did you see wolfgang thaller's yi+wxhaskell screenshot: www.cse.unsw.edu.au/~dons/Yi.jpg
17:48:30 <dons> we're just coming up with a ui abstraction layer atm.
17:48:33 <shapr> oh man!
17:48:35 <shapr> that's way sexy!
17:49:33 <Darius> Aqua is so pretty.
17:51:51 <blackdog> dons: are you at uni? rhialto's off the net and would appreciate being buttoned good and hard...
17:52:29 <dons> not at uni... nico might be or roshan
17:52:46 <blackdog> cheers
17:53:03 <symmetry-> Darius: Aqua on Mac?
17:54:01 <Darius> Yes.
17:59:00 <yonkeltron> in haskell....the parentheses after a funtion are optional right....and if so, should you use them for the sake of clarity or is it just "not done"
17:59:00 <yonkeltron> ?
17:59:22 <Cale> yonkeltron: parentheses are used only for grouping
17:59:22 <shapr> what do you mean after a function?
17:59:25 <shapr> you mean like in C?
17:59:46 <np_hard> has anyone worked significantly with HaXML?
17:59:52 <blackdog> it'll work for single-arg functions, I guess. Don't do it, though, it bad for you kiddy!
18:00:04 <yonkeltron> shapr: 'sqrt 16' vs 'sqrt(16)'
18:00:08 <shapr> I worked with HaXML some, but I've used HXml Toolbox more.
18:00:12 <Cale> yonkeltron: f x + y = (f x) + y, which is not f (x + y)
18:00:31 <np_hard> what's the difference?
18:00:43 <yonkeltron> ok so i'll stick with traditional function notation then
18:01:01 <dons> nobody uses sqrt(16) form. it's weird, and doesn't scale to multiple arguments
18:01:04 <Darius> yonkeltron: f x y is different from f(x,y)
18:01:21 <Calister> is it?
18:01:23 <shapr> HaXML generates 'significant' algebraic datatypes, one for each tag name. You can only build a HaXML structure 'safely' like a syntax-directed editor.
18:01:32 <Darius> @type \x y -> (x,y)
18:01:33 <lambdabot> \x y -> (x,y) :: forall t t1. t -> t1 -> (t, t1)
18:01:38 <Darius> @type \(x,y) -> (x,y)
18:01:40 <lambdabot> \(x,y) -> (x,y) :: forall t t1. (t, t1) -> (t, t1)
18:01:54 <shapr> HXmlToolbox uses a generic tree structure, validation, stylesheets, etc, are separate steps.
18:02:00 <dons> f x y == uncurry f (x,y)
18:02:03 <yonkeltron> woah woah woah...so it's a matter of personal taste then?
18:02:20 <Riastradh> Curried functions are the norm in Haskell.
18:02:23 <np_hard> hm
18:02:26 <Darius> The notation isn't.  Whether you use curried or uncurried is.
18:02:35 <yonkeltron> darius: explain?
18:02:40 <np_hard> I guess I will have to play with the XML libraries then
18:02:57 <np_hard> a coworker is essentially writing SVG and Javascript macros in Perl.
18:03:05 <np_hard> it hurts me deep inside
18:03:06 <shapr> np_hard: ouch!
18:03:08 <Darius> yonkeltron: If the function is curried you have to use f x y syntax, if it's uncurried you have to use f (x,y) syntax.
18:03:10 <shapr> yes, I understand.
18:03:28 <yonkeltron> darius: gotcha...i get it now thanx!
18:03:35 <Darius> yonkeltron:  Of course, whether the function is curried or not is up to the creator of the function.
18:03:41 <np_hard> I am thinking if I can show a clear win for haskell over that, I might have a shot at spreading the word
18:03:54 <np_hard> also gets me a chance to use haskell on something else real at work
18:04:01 <shapr> I got paid for three days of HXmlToolbox coding that did what a month (and huge amounts) of Java did not accomplish.
18:04:52 <np_hard> too bad you couldn't get paid for a month
18:04:55 <np_hard> :-D
18:05:01 <Calister> java :s
18:05:08 <Darius> structure transformations in Java *shakes his head*
18:05:12 <np_hard> of course, you got to work on something else
18:05:16 <shapr> My task was to turn 42mb of ms.doc files into a custom XML flavor, so 2.5 days of HXmlToolbox coding did 95% of the work, and a few hours of hand editing did the rest.
18:05:16 <yonkeltron> i am amazed! some of haskell looks pythonic...and some of it looks downright lispy!
18:05:27 <shapr> yonkeltron: yes it is very wonderful!
18:05:31 <np_hard> yeah, well right now my coworker isn't doing much structure transformation
18:05:39 <np_hard> he is going to want to though
18:05:40 <Darius> javash: program("ls").withArgument("-a").withArgument("-l").execute()
18:05:40 <shapr> yonkeltron: http://www.haskell.org/hawiki/HaskellDemo
18:06:05 <yonkeltron> shapr: well i am a python guy...who likes to pretend he knows more about lisp than he has had time to learn..although someday i'll get there
18:06:17 <shapr> I was a Python guy.
18:06:25 <np_hard> If we can skip the XSLT phase and move to Haskell I will be ecstatic
18:06:54 <shapr> XSLT sucks rocks. It's like trying to dig a ditch with a spoon.
18:07:02 <Calister> hmmm
18:07:14 <Calister> i _THINK_ i should try to get some sleep
18:07:23 <shapr> g'night Calister
18:07:27 <shapr> come back soon :-)
18:07:36 * Calister needs to get up at 6:30 >_<
18:07:37 <Darius> And for the webdesigners, xmlsh: <program><name>ls</name><argument>-a</argument><argument>-l</argument></program>
18:07:46 <Calister> for sure will do ;)
18:07:53 <np_hard> he is taking a CSV dependency list and generating a visual representation of the hardware elements involved
18:07:58 <np_hard> all in perl.
18:08:07 <Calister> i will have an exam next week... mainly bout haskell
18:08:11 <Calister> ;d
18:08:20 <Calister> lots to learn before that
18:08:28 <shapr> Haskell is a great language!
18:08:28 * shapr cheers
18:08:36 <Calister> since when? ;p
18:08:49 <shapr> Um, the last seven years or so
18:08:54 <shapr> at least since they added monad support.
18:08:58 <yonkeltron> shapr: wow.. there is a lot here. i need to learn more before i can really parse all that
18:09:11 <yonkeltron> shapr: monad?
18:09:12 <Calister> i must be lagging more than 7 years then
18:09:15 <Calister> ;)
18:09:39 <shapr> yonkeltron: HaskellDemo is designed to be parsed by any programmer, but especially a Python programmer. If something about it doesn't parse, tell me, cuz I wrote it.
18:09:42 * Calister is struggling to survive it
18:10:07 <shapr> Haskell really is an amazingly elegant programming language. There are powerful patterns in this language.
18:10:28 <yonkeltron> shapr: want it in here or in a pm?
18:10:32 <Calister> its kinna funny alnguage
18:10:33 <shapr> It's not perfect for every task, and I'm sure something better will come along in the next few years, but for now, it's great!
18:10:35 <shapr> yonkeltron: here
18:10:43 <Calister> language*
18:10:47 <yonkeltron> well for starters...the type def: add1 :: Int -> Int
18:10:50 <yonkeltron> i don't get it
18:11:12 <dons> int add1(int);
18:11:20 <shapr> yonkeltron: how do you expect "add1 x = x + 1" to work?
18:11:26 <dons> think like maths
18:11:38 <shapr> like Calister said, this language is a bit funny.
18:11:44 <shapr> Because, Haskell works like an equation.
18:12:03 <yonkeltron> shapr: so the first Int is what it returns?
18:12:04 <shapr> Java, Perl, Python, etc are a series of steps to complete.
18:12:10 <Calister> it reminds me a wee bit to humm
18:12:14 <Calister> oi
18:12:19 <Calister> bummer how is it called?
18:12:24 <shapr> Haskell is more like a bunch of equations to simplify.
18:12:33 <Calister> programming languages like prolog?
18:12:46 <Janni> imperative
18:12:47 <tautologico> Int -> Int means a function from Ints to Ints
18:12:48 <shapr> Prolog is a logic or constraint language, that's the third flavor.
18:12:52 <np_hard> yonkeltron: have you taken discrete math? Have you seen notation like abs : I -> N
18:12:56 <Calister> ah yes, logic
18:13:02 <yonkeltron> np_hard: no
18:13:03 <Calister> logic programming
18:13:09 <dons> yokeltron: f :: Int -> Char ==  char f(int);
18:13:13 <tautologico> constraint programming
18:13:17 <shapr> yonkeltron: def add1(x): x + 1
18:13:23 <Calister> some patterns are similar to it
18:13:26 <shapr> doh, I left out return
18:13:37 <yonkeltron> shapr: OH!
18:13:40 <shapr> yonkeltron: anyway, what type does that Python add1 take in, and what type does it return?
18:13:57 <yonkeltron> gets and int and gives and int!
18:14:00 <yonkeltron> i get it!
18:14:00 <yonkeltron> haha
18:14:02 <yonkeltron> ok next....
18:14:04 * shapr cheers
18:14:34 * Calister had the first time the feeling today to play with haskell.. and even understand it partly :D
18:14:35 <yonkeltron> oh man
18:14:45 <Calister> like a mind game
18:14:47 <shapr> Calister: the major difference between logic and functional (I think) is that logic is 'two way simplification' and functional is one way.
18:14:59 <yonkeltron> it all makes sense...the type defs for functions........omg it's GORGEOUS!
18:15:13 * shapr plugs his computer into the lightning bolt that just hit yonkeltron 
18:15:20 <Calister> lol
18:15:23 <shapr> mmm, power for a week!
18:15:30 <yonkeltron> ok...now i need to keep reading
18:15:48 <shapr> Calister: you've only got three hours of sleep before you need to get up...
18:15:49 <Janni> MISSION ACCOMPLISHED
18:16:03 <Calister> yep :s
18:16:05 <np_hard> heh
18:16:11 <Calister> but its hard to go to bed
18:16:13 <Calister> i mean
18:16:26 <shapr> yonkeltron: what do you think of those datatypes? specifically, Season and Temp
18:16:33 <Calister> its the first time i got the feeling i did some serious thinking for a haskell prog today
18:16:37 <Calister> and i did it all myself
18:16:40 <Calister> and its working!
18:16:44 <np_hard> wait til yonkeltron sees the "terribly inefficient but so cool-looking" definitions of primes and quicksort
18:16:44 <shapr> yay!
18:16:45 <np_hard> :-D
18:16:59 <Calister> eventho it looks completely different from all other solutions i saw :s
18:17:05 <shapr> yah, the elegance of expression you get from Haskell is sooo pleasing.
18:17:12 <yonkeltron> shapr: season and temp...haven't gotten there yet...one thing at a time
18:17:19 <shapr> ok
18:17:24 <shapr> I gotta go to sleep myself.
18:17:31 <Calister> ni ni
18:17:32 <tautologico> functional reactive programming
18:17:33 <Calister> ^_^
18:17:45 <Calister> O.o
18:17:46 <shapr> Calister: ikki ikki ptang zoop zrow sassafras!
18:18:13 * Calister blinks.. wha? O.O
18:18:24 <shapr> We are no longer the knights who say Ni!
18:18:36 <Calister> ^_^
18:18:41 <yonkeltron> shapr: i know my roots zude....
18:18:49 * shapr grins
18:19:25 <Calister> oh god, my classes tomorrow will seem so extra boring
18:19:34 <shapr> because you'll be asleep?
18:19:39 <Calister> yep
18:19:40 <Calister> lol
18:19:48 <shapr> That does affect the interest level.
18:19:49 <Calister> i'll take my laptop w/ me
18:19:58 <shapr> I have work tomorrow, and study.
18:19:59 <Calister> open it.. and sleep behind it
18:20:22 <Calister> except in first lesson
18:20:30 <Calister> cuz a) we always get coffee during it
18:20:47 <shapr> Smart teacher.
18:20:47 <Calister> and b) ima have a test in comp structures on friday
18:20:56 <shapr> I myself must sleep now.
18:20:58 <Calister> sleepy teacher ;)
18:21:01 <Calister> me too
18:21:07 <shapr> g'night!
18:21:13 <Calister> gnite :)
18:21:16 * shapr wanders off to bed
18:21:35 * Calister waves and creeps off
18:24:14 <Darius> Debugging memory errors is like riding a bike.
18:24:43 <Darius> MegaMonad: How's the C today?
18:24:48 <Lemmih> How so?
18:24:49 <MegaMonad> Darius: Igloo: i mean, stuff that c and c++ are pretty practially negligently slower then in haskell, but it's not possible to define c to haskell so dont ask how.
18:25:21 <tautologico> MegaMonad, how ?
18:25:25 <Darius> Lemmih: In the standard way.
18:25:27 <MegaMonad> tautologico: Chane de markov.
18:26:02 <tautologico> MegaMonad: parlez-vous franais ?
18:26:07 <MegaMonad> tautologico: :-) It was in fran?
18:37:13 <dons> Janni: nightly tar balls of yi are happening now. check the yi page for the link
18:37:25 <Janni> Thx.
19:13:45 <miniwheats> 12,1[15,1 Hellooo people! I am in tha house! 12,1] [15,1 Zero-Force Script12,1]
19:14:26 <Lemmih> Eeeek.
19:36:24 <jadrian> in Data.FiniteMap isn't there any function available to map just one element with a certain key???
19:36:26 <jadrian> :(
19:36:34 <jadrian> I should have used DData...
19:40:45 <Darius> You could construct one easily.
19:41:01 <Darius> @type Data.FiniteMap.mapFM
19:41:03 <lambdabot> Data.FiniteMap.mapFM :: forall elt2 key elt1.
19:41:03 <lambdabot> 			(key -> elt1 -> elt2)
19:41:03 <lambdabot> 			-> Data.FiniteMap.FiniteMap key elt1
19:41:03 <lambdabot> 			   -> Data.FiniteMap.FiniteMap key elt2
19:41:49 <Darius> mapFM (\k e -> if k == theKey then f e else e)
19:46:54 <blackdog> You're still doing O(n) work there
19:46:59 <Darius> Yes.
19:47:41 <Darius> Anyways, I'm leaving.
19:54:55 <waltz> What is the difference between an 'Int' type and an 'Integer' type in Haskell?
19:56:34 <dons> Integer  is arbitrary precision. Int is fixed precision
19:57:12 <waltz> So is '3' an Int?
19:57:20 <dons> @type 3
19:57:22 <lambdabot> 3 :: forall t. (Num t) => t
19:57:35 <dons> @type 3 :: Int
19:57:36 <lambdabot> 3 :: Int :: Int
19:57:46 <waltz> I see
19:58:13 <dons> the type of a numeric literal depends on its context
19:58:37 <dons> @type 3 :: Integer
19:58:38 <lambdabot> 3 :: Integer :: Integer
20:20:26 <jadrian> mapFM (\k e -> if k == theKey then f e else e)
20:20:45 <jadrian> this would wonder around the whole sequent
20:20:56 <jadrian> the whole finiteMap
20:21:02 <jadrian> :-|
20:40:19 <blackdog> jadrian: you could rewrite it using lookupFM and addToFM - that'd be asymptotically ok
20:52:14 <blackdog> ok, straw poll: i'm writing a global optimiser for haskell, and I'm doing the first chapter of the thesis now. Do I need to roll out the "Haskell's really nice, here's why it's worth doing all this work to make it run faster"?
20:52:55 <blackdog> or is it just too obvious to bother with? I don't want to rewrite Why FP matters...
20:53:24 <Riastradh> You should give a brief overview in a couple paragraphs or a short section.  In that section, you should also refer to that paper.
20:55:36 <blackdog> fair enough. I've got a lamentable tendency to turn into Advocacy Guy, so I just wanted to check that it's not unreasonable to say a few kind words. :)
20:56:04 <lament> your tendencies are indeed lamentable
20:56:56 <blackdog> Hello there. Apologies for taking your name in vain.
20:57:22 <lament> :P
22:57:35 <jadrian> :-|
23:12:37 <jadrian> blackdog: I used another workaround
23:12:46 <jadrian> blackdog: my FiniteMap contains lists
23:13:06 <jadrian> blackdog: and I wanted to add an element to the list
23:13:41 <jadrian> blackdog: so I just used  addToFM_C  (++) [my_elem]
23:13:57 <jadrian> blackdog: still it would be a nice operation to have
23:14:18 * jadrian hasn't slep yet... 7am here and working since 6pm the day before :(
23:14:27 <jadrian> s/slep/slept
23:47:13 <Defty> what does  front _ [] = [] mean ? front :: Int [a] -> [a]
23:48:34 <Defty> is _ somehow the parameter and [] 'what is matched'? i don't really know haskell at all, just trying to understand a text that uses it as an example
23:48:38 <basti_> that front of "anything" and [] is []
23:48:52 <basti_> _ is "don't care about that and match all the rest"
23:49:14 <Defty> ok :)
23:49:26 <basti_> never done prolog huh? ;)
23:49:50 <Defty> that neither :) it comes later in the book i'm reading, but also as an example..
23:56:44 <Defty> thanks btw. i'm off to read the book ..
