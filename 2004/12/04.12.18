01:56:32 <musasabi> How would I add a primop that involves inline assembler on some architectures to ghc?
01:56:48 <musasabi> (and is that even possible with the cmm things)
01:57:11 <boegel> good morning #haskell
02:01:13 <esap> good morning
02:09:26 <Itkovian> meuning boegel
02:35:02 <musasabi> How is the performance of pinned vs normal allocation in the GHC rts?
03:42:44 <derelm> hi, i do have a [[char]] list and want it to become a [string] list, what's the easiest way to do that?
03:42:55 <derelm> btw, i thought [[char]] was [string] ?
03:42:58 <kristnjov> [[Char]] == [String]
03:43:17 <kristnjov> [Char] == String, therefore [[Char]] == [String]
03:43:32 <derelm> hmm... then i understood the error wrong...
03:43:36 <kristnjov> probably
03:44:07 <derelm>     Couldn't match `[Char]' against `Char' \n Expected type: [[Char]] \n Inferred type: String
03:44:45 <TheHunter> derelm, you're using a String where a [String
03:44:51 <TheHunter> ] would be appropriate.
03:45:05 <kristnjov> yep
03:45:06 <derelm> ok, so simply [] around it
03:45:25 <kristnjov> pretty much, you might wonder why the function takes [String] in the first place
03:46:25 <kristnjov> seems unnecessary to take [String] if there's only one element in the list
03:46:26 <derelm> actually i am trying to pass a getDirectoryContents list to a funktion filtering a certain suffix of that list
03:47:30 <musasabi> do xs <- getDirectoryContents foo; return $ filter bar xs
03:48:01 <musasabi> or even getDirectoryContents foo >>= return. (filter bar)
03:48:54 <derelm> doesn't getDirectoryContents return a list of strings (^= filenames) ?
03:50:29 <Lemmih> @type System.Directory.getDirectoryContents
03:50:31 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
03:51:19 <Lemmih> derelm: 'getDirectoryContents path' is an IO action.
03:51:26 <derelm> musasabi: that do xs <- stuff doesn't work
03:51:52 <kristnjov> what's "bar"?
03:51:52 <derelm> Lemmih: yes, these io actions do drive me crazy :(
03:52:12 <derelm> read from io
03:52:17 <kristnjov> do <- drive me crazy
03:52:35 <Lemmih> kristnjov: How so?
03:52:50 <kristnjov> Lemmih, "filter bar xs", what does that filter?
03:53:11 <kristnjov> and do doesn't drive me crazy, that was a slow pun :P
03:53:23 <Lemmih> kristnjov: 'bar' is a function of type (FilePath -> Bool).
03:53:32 <kristnjov> @type bar
03:53:33 <lambdabot> bzzt
03:53:45 <Oejet> Hello, Lemmih.
03:53:45 <Lemmih> kristnjov: It should be user defined.
03:54:05 <kristnjov> what should the function do then?
03:54:11 <Lemmih> Greetings Oejet.
03:54:11 <derelm> onlyWith muster liste = filter (isSuffixOf muster) liste <- thats my function to filterout the elements not matching the suffix
03:54:37 <Lemmih> kristnjov: It should evaluate to False for the FilePaths you wanna filter out.
03:58:07 <derelm> argh, now how do i print a list with IO [[Char]]
03:59:22 <Lemmih> derelm: ioaction >>= print
03:59:50 <derelm> No instance for (Show (IO [[Char]]))
04:00:19 <Lemmih> Indeed.
04:01:45 <kristnjov> i'm thinking about going back to playing xbox
04:01:48 <derelm> what i am basically trying to do is, read a path from stdin, see if that path is correct, if correct read a extension, now filter everything from the directory contents out that doesn't match the extension and print the resulting list to the screen
04:01:57 <kristnjov> these IO functions are twisting my mind
04:02:57 <derelm> but after having applied my function to filter, i cannot print the resulting list anymore :(
04:03:08 <Lemmih> derelm: ioaction >>= print
04:03:20 <TheHunter> @wiki HaskellIrcPastePage
04:03:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:03:47 <TheHunter> derelm, you might wanna put your code there.
04:07:41 <derelm> ok, i pasted mine to that site, second "paragraph"
04:09:55 <TheHunter> derelm, the fix is actually quite simple, just replace $ in the last line with =<<
04:10:27 <derelm> i did not use that, since i don't understand what that does
04:10:52 <TheHunter> derelm, main = do 
04:11:00 <TheHunter>   output <- promptDir "Enter a path: "
04:11:05 <TheHunter>   print output
04:11:34 <derelm> thats what =<< does?
04:11:52 <TheHunter> f =<< x is the same as x >>= f.
04:12:07 <TheHunter> You could also write promptDir "Enter a path: " >>= print
04:12:44 <derelm> TheHunter: no i get an exception: prelude.read: no parse
04:12:47 <derelm> now
04:12:54 <TheHunter> yep, i get that one, too
04:13:06 <derelm> so probably the filtering didn't work?
04:14:21 <Lemmih> derelm: Why are you calling 'read' in 'prompt'?
04:14:52 <derelm> hmm, it didn't work otherwise ... i think
04:15:09 <TheHunter> read reads Strings which are in the form "fdsaf\nfdsafads"
04:16:17 <TheHunter> derelm, you see how to fix that?
04:16:41 <musasabi> How should this be written?
04:16:42 <derelm> ok, now when i remove that read and simply return what i read in, i can print a list, but it's always empty :(
04:16:42 <musasabi> size :: Storable e => BinT m e -> Int
04:16:42 <musasabi> size b = bsize b `div` sizeOf (undefined :: e)
04:17:07 <musasabi> This fails because e is not qualified in the function body.
04:17:11 <TheHunter> derelm, you've filtered a singleton list.
04:17:27 <TheHunter> you want files instead of [eingabe]
04:18:14 <derelm> TheHunter: ARGH
04:18:18 <derelm> :)
04:18:51 <TheHunter> @type mapM_
04:18:52 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
04:19:04 <TheHunter> derelm, any idea what mapM_ might do?
04:19:33 <derelm> not.... not really
04:20:19 <wli> mapM_ print :: Show t => [t] -> IO ()
04:20:19 <TheHunter> it takes a function with side effects (such as print) and a list, and applies the function to each element of the list and combines the side effects.
04:21:17 <TheHunter> so if you make you `main' line main = mapM_ print (promptDir "Enter a path: "), the results are printed in a nicer way.
04:21:41 <TheHunter> oh, sorry
04:21:52 <derelm> but right now it doesn't work since char doesn't match filepath :(
04:21:57 <TheHunter> main = do
04:21:59 <musasabi> hmm found it ^_^
04:22:04 <TheHunter>   output <- promptDir ...
04:22:13 <TheHunter>   mapM_ print output
04:23:00 <derelm> TheHunter: no, it complains about char ^= filepath in onlyWith ...
04:23:36 <TheHunter> hmm, return (onlyWith extension files) works fine here.
04:24:26 <derelm> TheHunter: i am sorry, io burnt my brain
04:25:02 <derelm> i still had [ ] around files, but it's no longer a singleton ...
04:26:02 <derelm> TheHunter: thanks a lot....
04:26:49 <TheHunter> derelm, one last thing. For the sake of documentation and easier understanding of the types involved, it might be helpful to explicitely write down the type signatures.
04:26:59 <TheHunter> prompt :: String -> IO String
04:27:05 <TheHunter> promptDir :: String -> IO [[Char]]
04:27:09 <TheHunter> and so on
04:27:28 <derelm> TheHunter: ok, i'll try to do that!
04:28:24 <TheHunter> your interpreter already has all the information you need if the program compiled, so you can ask it: :t prompt
04:29:16 <derelm> what i learned today, io is not really fun
04:30:55 <TheHunter> derelm, it takes some getting used to, but once you've got it, it's quite nice.
04:31:44 <derelm> that's what i hope :)
04:48:51 <shapr> good afternoon #haskell!
04:55:07 <Lemmih> Greetings shapr.
04:56:42 <Lemmih> How's code?
05:02:21 <musasabi> Where is sizeofMutableByteArray# defined? grepping does not seem to help...
05:05:47 <jadrian> jadrian@linux:~/Install/Haskell/ghc-6.2.1> grep -R   sizeofMutableByteArray  *
05:05:50 <jadrian> hslibs/lang/MutableArray.lhs:    sizeofMutableByteArray, -- :: Ix ix => MutableByteArray s ix -> Int
05:06:01 <jadrian> I think that's it
05:06:09 <jadrian> hslibs/lang/MutableArray.lhs
05:06:47 <jadrian> oh wait
05:06:50 <jadrian> you want the #
05:07:59 <jadrian> musasabi: I think this is it: 
05:08:02 <jadrian> primop  SizeofByteArrayOp "sizeofByteArray#" GenPrimOp
05:08:02 <jadrian>    ByteArr# -> Int#
05:08:14 <jadrian> it's in ghc/compiler/prelude/primops.txt.pp
05:08:17 <musasabi> jadrian: yes. I found that.
05:08:21 <jadrian> k
05:08:37 <musasabi> jadrian: but what code does it generate and how is the layout at rts level?
05:08:46 <musasabi> that is what I cannot find.
05:09:18 <musasabi> array implementations seem to cache the size, and I am curious why.
05:09:22 <jadrian> right, no idea, I never messed with lower level ghc stuff
05:16:45 <musasabi> hmm seems it is just a normal closure so it is an indirect call.
06:09:44 <musasabi> why isn't . proper syntax?
06:09:48 <musasabi> that is:
06:10:13 <musasabi> foo = A.b and foo a = A (b a) are not equal.
06:10:55 <tuomov> because it is qualified module member reference?
06:11:30 <tuomov> there's a bit too much overloading in parts of haskell..
06:12:16 <tuomov> hmm.. but that A is big..
06:12:47 <tuomov> in that case the latter doesn't make much sense
06:13:17 <musasabi> no the kind error problem.
06:13:58 <tuomov> A is a constructor?
06:14:00 <musasabi> aw_read  a b = I# (indexIntArray# a b) <- no '.' for me :-(
06:17:00 <shapr> Lemmih: code isn't
06:17:12 <shapr> I'm hibernating until after the solstice.
06:20:49 <Oejet> Greetings all, I have implemented a new and improved and lightning fast implementation of a counting semaphore as a replacement for Control.Concurrent.QSem.  Only the problem is it's so much slower that I think, I give the wrong compiler flags.
06:22:29 <Lemmih> Oejet: Is it availiable on the web?
06:23:12 <Lemmih> *available
06:23:18 <Oejet> No, it's secret.
06:24:12 <Lemmih> Oh.
06:24:27 <Lemmih> For real?
06:24:49 <Oejet> Let me just put it up...
06:25:43 <Oejet> http://www.student.dtu.dk/~s022018/QSem.hs
06:27:32 <Oejet> My test program is http://www.student.dtu.dk/~s022018/test.hs
06:28:31 <Oejet> The implementations should be comparable by replacing "import QSem" by "import Control.Concurrent.QSem".
06:31:07 <Lemmih> Maybe you should look at the GHC implementation.
06:31:15 <Oejet> I have tried with "~] ghc -O2 -C QSem.hs"
06:31:40 <Oejet> Lemmih: Maybe that is the one, I used as a template. :-P
06:33:11 <Oejet> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Control/Concurrent/QSem.hs?rev=1.7
06:39:34 <Lemmih> You're using a lot of time in pSIGNAL and inc according to profiling.
06:40:03 <Oejet> Oh, I didn't think of profiling.  Just a moment.
06:43:01 <Oejet> Lemmih: What options did you compile and run with to get the profiling that detailed?
06:44:26 <Lemmih> ghc -prof -auto-all
06:44:40 <Lemmih> ./Test +RTS -p
06:45:39 <Oejet> I forgot -auto-all :-)
06:46:50 <Oejet> ghc -prof -auto-all -O2 -C QSem.hs
06:48:37 <Oejet> No, better with: ghc -prof -auto-all -O2 --make test.hs -o test
06:48:43 <Oejet> Thanks, Lemmih.
06:49:43 <shapr> hej Marvin-- !
06:49:45 <shapr> ltns!
06:49:49 <Marvin--> hello hello
06:49:58 <shapr> wassup? how's the job?
06:50:00 <Marvin--> yeah, I keep forgetting to drop by :)
06:50:05 <Marvin--> job's good
06:50:13 <shapr> You writing Haskell code at the job?
06:50:41 <Marvin--> no, unfortunately I'm not working on any of the haskell parts
06:51:20 <shapr> maybe you'll get promoted =)
06:52:26 <Marvin--> eh, the organization is more flat than hierarchical, it's more a question of who's working on what
06:53:11 <shapr> guess not
06:53:31 <shapr> Of course it pays money and you get to write code.
06:53:36 <shapr> Sounds good.
06:53:51 <shapr> Have you rebalanced your exercise and energy output?
06:54:21 <shapr> written any fun code lately?
06:54:31 <shapr> Oh, I think SyntaxNinja was looking for your for Cabal questions.
06:56:39 <Marvin--> no, my balance is still out of whack, unfortunately, gotta do something about that One Of These Days
06:56:49 <Marvin--> my questions?
06:56:55 <Marvin--> what questions?
06:57:04 <shapr> um
06:57:07 <shapr> "for you"
06:57:12 <Marvin--> oh
06:57:24 <shapr> Jag tror han har flera frågor från din Cabal kod?
07:16:46 <srid> any haskell book torrent link?
07:18:37 <jadrian> not that I know of...
07:19:00 * jadrian just ordered "The Fun of Programming"
07:24:00 <tintin> jadrian: is that a haskell book ?
07:24:44 <srid> tintin: oh, you are in #haskell too!
07:27:00 <tintin> yeah 
07:27:13 <tintin> what are you doing here ?
07:27:53 <musasabi> hmm how to handle a binary comprehension.. Haskell syntax is just too liberal..
07:28:02 * TheHunter is away: I'm busy
07:28:05 <wli> what's a binary comprehension?
07:28:27 <musasabi> < a : 48, b/binary > is just not going to work.
07:28:44 <musasabi> wli: pattern matching binary data, quite nice in e.g. erlang.
07:28:51 <srid> tintin: going to learn haskell :)
07:29:21 <srid> btw, which haskell book do you recomment for am imperative programmer?
07:29:29 <jadrian> tintin: yeap it is
07:30:29 <jadrian> tintin: http://www.palgrave.com/products/catalogue.aspx?is=0333992857
07:30:36 <tintin> srid: i am the worst guy to ask 
07:30:47 <tintin> but Craft of Haskell programming seems ok
07:31:14 <srid> tintin: actually there is rarelly a haskell book in chennai .. ebook would be better
07:31:28 <tintin> srid: try the tutorials 
07:31:50 <tintin> www.haskell.org/learning.html
07:31:52 <srid> wondering whether i must go with YAHT
07:32:11 <tintin> YAHT ?
07:32:27 <srid> Yet Another Haskell Tutorial
07:32:56 <tintin> yes thats a good one too 
07:32:59 <tintin> but i dont think there is any scope for haskell in India 
07:33:03 <tintin> i have never heard of it being used anywhere
07:33:40 <tintin> but you should learn haskell :) 
07:34:05 <wli> if you have a use for it do so
07:34:29 <wli> valid uses include curiosity and entertainment
07:35:10 <wli> they are of course not limited to such
07:35:12 <tintin> anyways he has too much time of his hands so why bother :)
07:35:17 <tintin> go ahead and learn 
07:35:18 * shapr hops
07:35:33 <tintin> hello shapr
07:35:42 <tintin> how has you day been so far ?
07:35:52 <tintin> any unicycling today ?
07:35:54 <shapr> Very dark. How is your day?
07:36:10 <shapr> No, I'm low energy until after the solstice.
07:36:22 <shapr> That was my only hop today.
07:36:57 <tintin> hmmz hope it brightens up :) 
07:37:05 <tintin> sooner the better 
07:38:57 <tintin> fun of programming looks like a good book 
07:38:58 <tintin> i think i might buy it :)
07:39:13 <tintin> tnx jadrian 
07:39:44 <jadrian> I hope it's nice since already paied for it :) np ;)
07:40:10 <tintin> yeah but i have been disappointed before ... 
07:40:49 <tintin> the reviews seem good but the books sometimes fail to meet expectations 
08:40:03 <bourbaki> moin
09:06:27 <shapr> wheeee!
09:06:31 <shapr> the hills are alive!
09:08:51 <tintin> with the sound of music ...
09:24:05 <bourbaki> how can i make a HList a parameter of a function?
09:52:01 <wli> how many lines of crap in ghci before you should really dump it to a file?
09:52:24 <wli> List Prelude> do { fc <- readFile "/proc/meminfo" ; fs <- return $ map ((\[x,y] -> (reverse . tail . reverse $ x, read y :: Integer)) . take 2 . words) $ lines fc ; width <- return $ foldr max 0 $ map (length . fst) fs ; mapM_ putStrLn ((\xs -> let ns = foldr (zipWith max) (repeat 0) (map ((++ repeat 0) . map length) xs) in map (concat . intersperse " " . zipWith (\n v -> v ++ replicate ((ns!!0) - length v) ' ') ns) xs) . map (map snd) . groupBy (\(x,_) (y,_) -> x
09:52:33 <wli> well, there's more 
09:53:35 <wli> should be n instead of (ns!!0)
09:53:37 <wli> but nm that
09:55:15 <shapr> seems to me that test driven development is a modified version of the cycle of interactive testing and then recording code
09:55:43 <wli> yeah
09:55:50 <wli> but I don't want to do the above by hand anyway
09:56:21 <wli> I probably want to have some silly micro-language for grabbing fields out of files in /proc/ etc.
09:56:44 <wli> and do it like an interpreter
09:59:09 <wli> they're pretty much all line-oriented or field-oriented
09:59:51 <Riastradh> wli, have you ever used scsh's AWK macro facility?  It is precisely designed for this sort of thing.
10:00:01 <wli> well
10:00:15 <wli> it's not for extraction per se
10:00:19 <wli> rather charting
10:00:24 <wli> in realtime, even
10:00:51 <wli> so it's unclear how much things that don't plug into a renderer will help
10:07:38 <shapr> a dsl for field grabbing does sound nice
10:09:47 * Riastradh points at scsh's facilities for that sort of thing.
10:11:51 <bourbaki> how do you use a HList in a type?
10:42:53 <Lemmih> bourbaki: :: l
10:43:08 <shapr> Lemmih:: Coder
10:43:10 * shapr snickers
10:43:20 <shapr> Lemmih:: Hacker =)
10:44:55 <Lemmih> Uh. I'm a data constructor?
10:45:13 <shapr> :-P
10:45:15 <Lemmih> (o:
10:45:56 * shapr HOPS!
10:46:06 <shapr> wow, I have enough energy for TWO hops today!
10:46:12 <shapr> Must be the liter of coffee I just imbibed.
10:46:28 <shapr> anyway...
10:46:52 <Lemmih> No unicycling today?
10:47:04 <shapr> nor yesterday... 
10:47:08 <shapr> nor the day before I think.
10:47:27 <shapr> the ice is extremely slippery
10:47:33 <Lemmih> I expect you to do backwards driving, one-foot and wheelwalk at the next euroHaskell!
10:47:38 <shapr> I will!
10:47:49 <shapr> backwards and one-foot I've almost got already.
10:48:00 <shapr> and wheelwalk should be achievable from one-foot.
10:48:12 <shapr> Oh I can almost do idling too. The online tutorial videos helped me a lot.
10:48:45 <Lemmih> I've undertrained my left foot )-:
10:48:56 <shapr> I have the same problem with my right foot.
10:49:06 <shapr> I can only freemount with my left foot.
10:49:19 <shapr> but at least I can freemount 99.9% first try
10:51:12 <shapr> My stillstand is getting better also. I can stop and pick up my right foot, and readjust it to a better pedal placement.
10:51:20 <shapr> That looks cool =)
10:51:44 * shapr gets a weird emacs error: "peculiar error: [67108925 backspace]"
10:53:00 <Riastradh> It even acknowledges that it is peculiar.
10:54:14 <Lemmih> I'm making no progress at all with my wheelwalking.
10:55:37 <Lemmih> It's a little annoying because it's the only trick where my brother is still better than me.
10:57:58 <shapr> I didn't even know you had a brother.
10:58:17 <Lor> What's wheelwalking?
11:01:15 <Lemmih> Lor: It's where you walk on the wheel. *doh* (-:
11:10:43 <shapr> Lemmih: I want to glide, that must be so much more like flying.
11:11:03 <shapr> I also suspect it will require more concentration than any other trick.
11:25:02 <tintin> shapr: has some misplaced genes ... he is hell-bent on breaking his bones ...
11:25:37 <tintin> maybe he is a mutant, kill him before he infects all our children!!!
11:27:14 * Lemmih has never broken any bones in all his many years of wild unicycling and roller-skating.
11:27:51 <tintin> loook he is infected too !!! lets get the shotguns out 
11:28:06 * tintin aims his shotgun at Lemmih and shapr 
11:28:55 <Lemmih> tintin: We are immutable!
11:29:33 <shapr> I'm actually a clay skolem.
11:29:57 <Lemmih> skolem?
11:30:06 <shapr> ya know, skolemization
11:30:35 <Lemmih> eh?
11:30:40 * jadrian broke a few bones already. Once went for 5 months with a fractured Fifth Metatarsal without knowing :-/
11:31:25 <shapr> I've never broken any bones that I noticed.
11:31:48 <shapr> though I suspect I broke my wrist once, and my hand another time. They sure hurt a whole bunch for weeks.
11:36:12 <tintin> hmmm 
11:37:21 <tintin> unicycling is evil the lord jesus christ dosnt want you to do it ... if he wanted you to do it why didnt he create a unicycle on the eight day 
11:37:27 <tintin> haha thats funny 
11:37:56 <shapr> Right, if God had wanted us to be naked, we'd have been born that way.
11:38:45 <shapr> Sonarman: hiya, how's code?
11:38:56 <tintin> maybe i should stop here before some fanatic turns up in here and decides to put a bullet hole through my head ...
11:38:57 <Sonarman> hi shapr
11:39:46 * Lemmih suddenly recalls that time he parachuted.
11:40:35 <Guest78747> for best search ==>  http://infinitybook.net/ebook/googleDeskbar.exe
11:40:37 <shapr> tintin: I'm a Baptist with a nice collection of firearms.
11:40:52 <shapr> I betcha that's infected
11:40:55 <Sonarman> AWESOME HEY LET'S DOWNLOAD THAT EXE
11:42:09 <kristnjov> cool that an actual guest of the network pasted the link too
11:42:39 <shapr> ?
11:42:47 <kristnjov> what?
11:44:15 <tintin> whats an exe ? is it an alien from Krypton ? is it evil ? find out in the next episode of Bill and His Friends ...
11:45:48 <kristnjov> word on the street is that it's an executable file.
11:46:08 <tintin> i wish there was something similar to google desktop search for linux it does a good job indexing the text files 
11:46:16 <shapr> tintin: write it!
11:46:18 <shapr> wouldn't be hard
11:47:33 <shapr> there's already "remembrance agent" that does work like it.
11:48:00 <bourbaki> how can i return a HList?
11:48:16 * shapr doesn't know
11:52:37 <Lemmih> bourbaki: RecNil
11:52:49 <Lemmih> bourbaki: for example.
11:53:47 <shapr> matt_: greetings! want to learn Haskell? =)
11:54:01 <matt_> shapr, no thansk
11:54:02 <bourbaki> Lemmih: ?
11:54:04 <shapr> ok
11:54:21 * shapr clicks his heels together three times and thinks "There's no place like ::1"
11:54:34 <matt_> kristnjov, does it have +x ?
11:54:56 <kristnjov> matt_, depends on the file i suppose
11:55:30 <matt_> kristnjov, joke !
11:55:39 <kristnjov> yeah i know
11:55:48 <shapr> Oh, I made a joke once. But no one laughed.
11:56:13 <kristnjov> people usually look at me as if i'm insane when i make jokes
11:56:30 <kristnjov> but that's just because my laughter sounds retarded.. like "hur hur hur"
11:57:38 <shapr> kristnjov: You're lucky, people only look at you like that when you make jokes.
11:57:53 <kristnjov> heh
11:57:58 <Lemmih> bourbaki: Yes?
11:58:08 <shapr> I (completely seriously) suggested pizza for christmas dinner when recently asked...
11:58:22 <kristnjov> shapr, of course man!
11:58:45 <shapr> It seems that many people have a rather traditionalist slant towards choice of food for Christmas dinner.
11:58:59 <Lor> Well, christmas is all about tradition.
11:59:10 <Lor> If you take out the tradition, what's the point of the whole thing?
11:59:31 <Oejet> Lor: Remembering the birth of Jesus?
11:59:38 <Lemmih> Lor: Good food and jolly people?
12:00:01 <Lor> Oejet, that isn't tradition?
12:00:10 <Lor> Lemmih, so it'd be just another party?
12:01:20 <shapr> I thought christmas was about taking time to appreciate your friends and family.
12:01:31 <shapr> As well as remembering the birth of Jesus.
12:01:54 <tintin> Hail shapr
12:02:23 <Oejet> And having Saint Nikolaus visiting. :-P
12:02:43 <shapr> I already got my Christmas present. One mountain unicycle, to go! =)
12:02:46 <tintin> yeah the bugger was premature by 5 days 
12:02:59 <tintin> lol shapr
12:03:03 * Lemmih wonders if shapr is a christian.
12:03:10 <tintin> you want a ton of them ?
12:03:14 <shapr> Lemmih: Yes in fact I am.
12:03:45 <Oejet> Me too. :-D
12:03:55 <Lemmih> Eek.
12:05:09 <tintin> Scentiology will cure all of you people ....
12:05:19 <shapr> tintin: I would be favorably disposed to one ton of mountain unicycles.
12:05:21 <Lemmih> Double Eek.
12:06:07 <Oejet> Lemmih: Is it really that odd?
12:06:31 <shapr> The way I see it, everyone should find what works for them.
12:07:09 <tintin> shapr: what will you do with all those unicycles ?
12:07:16 <Lemmih> Oejet: I'm having problems understanding how God can coexist with logic.
12:07:35 <shapr> tintin: Convert the unbelievers!
12:07:50 <shapr> um, I mean..
12:07:52 * shapr snickers
12:08:10 <shapr> All fanatics must die!
12:08:35 <tintin> Lemmih: its simple ... where did this universe come from ?
12:08:43 <tintin> bigbang ?
12:08:53 <shapr> and then you think, where did the bigbang come from?
12:08:57 <shapr> and then...
12:08:59 <tintin> how did big bang start ? 
12:09:03 <tintin> hehe 
12:09:26 <tintin> and finally there must be some idiot who did that by accident or by design ...
12:09:28 * Oejet wants a bigger brain.
12:09:29 <Lemmih> But where did God come from?
12:09:32 <tintin> that person is proved 
12:09:47 <shapr> There's a lot of information available, you get to choose how you interpret it.
12:10:07 <tintin> Lemmih: ofcourse human beings created him in the first place :)
12:10:26 <tintin> u have to be a god to understand where he came from :)
12:10:26 <shapr> I chose my way, but I won't say that it's right way for others.
12:11:02 <shapr> The complexity and operation of the human brain is a point of evidence for me.
12:11:08 <Lemmih> tintin: There's only one God according to christianity.
12:11:22 <shapr> But like I said, you choose for yourself.
12:11:23 <tintin> right but the best part about it is you will never ever find direct evidence to support his existance 
12:11:40 * Oejet wonders what God looks like.
12:11:44 <tintin> if you do find it its fake ...
12:12:47 <tintin> Lemmih: so lets figure out where we came from and then we can find out where god came from :)
12:13:22 <bourbaki> Lemmih: do you happen to know how to return a HList from a function or make it part of another type?
12:13:27 <Lemmih> tintin: We are a product of natural evolution.
12:13:29 <tintin> Oejet: your guess is as good as mine :)
12:13:45 <Lemmih> bourbaki: Yes.
12:14:00 <tintin> Lemmih: and where does it all begin ? we are back where we started ... 
12:14:04 <bourbaki> Lemmih: and how do you do that :)?
12:14:29 <shapr> From my viewpoint, evolution is a religion not so different from christianity.
12:15:19 <tintin> God is part of us and we are part of the whole and the whole in itself ... 
12:15:54 <shapr> Have you actually experimented enough to prove the theory of evolution to yourself? Have you calculated whether the constants in a physics book match with the reality around you? Or do you have faith that they are correct?
12:16:10 <Lemmih> tintin: I don't know yet. But saying that some divine creature created this planet and us humans in his image is too self deluding for me (no offence).
12:16:37 <Lemmih> bourbaki: What are you trying to do?
12:16:55 <bourbaki> Lemmih: i try to guild a HGraph the layout is rougly this
12:17:10 <bourbaki> Lemmih: type ([edges], [nodes]
12:17:23 <tintin> Lemmih: i dont think so either ... but i do believe he exists ... (the extent of his involvement in daily affairs is not known ) 
12:17:27 <Oejet> Evolution is not a religion.  It's just hard to explain and think about without confusing the concepts.
12:17:42 <bourbaki> now i need to store the edges and nodes as hlist since their type isnt the same necessaryly
12:18:42 <tintin> shapr: Its all part of living ... we believe in ideals truth honesty ... but they are moving goalposts never the same ... its perception and the reality (or lack of it) keeps changeing 
12:19:13 <shapr> Yup, but most people don't realize that their perception is not reality.
12:19:34 <Lemmih> bourbaki: I would suggest that you read "Strongly Typed Heterogeneous Collections".
12:19:38 <shapr> "We see through a glass, darkly"
12:20:35 <bourbaki> Lemmih: i did that but i wasnt able to figure out how to use these things as values that can be returned then
12:20:46 <bourbaki> is it (HCons a b) that i have to return?
12:21:11 <bourbaki> i mean i havent found anything like type blubb = (HCons a b) | HNil
12:21:41 <bourbaki> atm i just have HNil in the Graph as placeholders
12:21:55 <Lemmih> Take a look at how HCons is defined.
12:22:14 <Lemmih> data HCons e l = HCons e l
12:22:51 <Lemmih> Now you can return stuff like: HCons True (HCons 10 (HCons 'c' HNil))
12:23:12 <bourbaki> but i cant return HNil
12:23:25 <Lemmih> bourbaki: Why not?
12:23:37 <bourbaki> sec what you want to do is this
12:24:05 <bourbaki> foobar :: Graph -> HCons e l for example?
12:24:42 <Lemmih> No. foobar :: (HList l) => Graph -> l
12:25:08 <shapr> Oh, the theoretically most powerful pure nitrogen explosive has been created in a lab recently. It's a nitrogen diamond.
12:25:57 <Lemmih> shapr: eh.. Okay.
12:25:58 * TheHunter is back (gone 04:57:55)
12:25:59 <bourbaki> aha ok and the HNil does surfice to do the type thingy yes?
12:26:14 <shapr> Lemmih: I'm just a neophile, addicted to new information.
12:26:30 <Lemmih> bourbaki: HNil is an instance of HList, yes.
12:27:14 <bourbaki> so my graph is like this then
12:27:27 <bourbaki> type Graph = (HList, HList) ?
12:27:53 <bourbaki> or type (HList a, HList b) => Graph = (a ,b) ?
12:27:55 <Lemmih> shapr: That's one of the reasons I find you interesting (-: I'm not much of a smalltalker myself and I have a way too narrow field of interest.
12:29:47 <shapr> I don't do social smalltalk either, but I know a little about everything so I can usually intelligently discuss whatever the person next to me is really interested in thinking about.
12:30:06 <TheHunter> hey, bourbaki, you can kinda do that using existential types such as in data Graph = forall a b. (HList a, HList b) => Graph a b.
12:30:12 <Lemmih> bourbaki: The latter. Although I'm not sure you wanna use existential types.
12:30:44 <shapr> Though my focus is on the sciences. I'm real crap when it comes to spectator sports (which I think TV fits into)
12:30:45 <bourbaki> hm why not? the thing is that i need these lists in that type what other way is there to go?
12:31:03 <bourbaki> TheHunter: hidiho :) when i solved that list prob im on my way to write the interpreter :)
12:31:17 <TheHunter> but that is pretty much equivalent to type Graph = ([Anything], [Anything]) where data Anything = forall a. Anything a.
12:31:46 <bourbaki> well the thing is i need to be able to store nodes with different types in the graph
12:31:58 <bourbaki> since the nodes ( the functions domains) can differ
12:32:07 <TheHunter> to get anything out of that however, you'll have to use Typeable: data Anything = forall a. Typable a => Anything a
12:32:10 <Lemmih> bourbaki: Is there a specific reason you're not just using existential types?
12:32:31 <TheHunter> bourbaki, HList is not a type, it's a type class.
12:32:31 <bourbaki> and also it needs to be flexible in the sence that i have to be able to build the pushout and such so i need to be able to do products of types of nodes
12:33:07 <bourbaki> id be glad if you can think of another solution
12:33:22 <bourbaki> what i need is a graph that can hold different types of nodes
12:33:34 <bourbaki> that is the associated data needs to be flexible
12:33:58 <TheHunter> All I can think of is i) existentials and ii) some ST monad magic.
12:34:00 <bourbaki> and its needs to map to the input of the arrows
12:34:18 <bourbaki> that is something like this
12:34:34 <bourbaki> combine :: Node a -> Node b -> Node (a,b)
12:34:54 <bourbaki> so i can feed these new types to the arrows i build up for the network
12:36:46 <TheHunter> hmm, doesn't that mean your graph has an infinite number of nodes?
12:37:10 <bourbaki> well that is what i meant some time ago witht hat these graphs are topos
12:37:15 <shapr> boop boop be doop!
12:37:31 <bourbaki> i can build always the product of two nodes 
12:37:38 <bourbaki> cartesian closed
12:39:46 <bourbaki> i need to have these nodes since i want to update the network each iteration like a petrinet
12:40:02 <bourbaki> so the data tokens hop through the function into the codoman
12:40:19 <Lemmih> shapr: Can you help me with some xterm stuff?
12:40:25 <bourbaki> and when i use the arrow operation i can "compile" the graph to a single function
12:42:31 <bourbaki> TheHunter: any idea?
12:42:55 <Lemmih> bourbaki: Wouldn't a user specified data type be enough?
12:43:20 <bourbaki> Lemmih: for the starting network you already need more data types in the network
12:43:36 <bourbaki> that is you can have domains that are not the same across the network
12:43:57 <bourbaki> and since i want to use the arrow operations to compile these networks i need them to be flexible also
12:44:21 <bourbaki> i can post the code i have so far which does not use any types yet for the nodes
12:44:23 <bourbaki> and edges
12:44:30 <Lemmih> No 'data MyData = TypeOne | TypeTwo' ?
12:44:32 <bourbaki> but you can see the idea i think
12:44:38 <bourbaki> i had taht as well
12:44:49 <bourbaki> but with that i cant construct new types
12:45:15 <bourbaki> also it would force me to write all edges in the graph as functions of that type
12:45:28 <bourbaki> wich would result in a lot of rewriteing
12:45:50 <bourbaki> i thought about a pure alalog for nodes
12:46:15 <bourbaki> something like (pure id) so to say
12:46:58 <bourbaki> that way i would be able to combine nodes in the same way i combine the functions with the arrows
12:47:39 <TheHunter> bourbaki, i still think existentials (+Typeable) and the ST monad are you options. The first one has some problems wrt to type safety while the latter is probably very difficult.
12:47:49 <bourbaki> ((pure fn1) +++ (pure fn2)) ((nodepure data1) +++ (nodepure data2))
12:49:17 <TheHunter> or iii) abandon Control.Arrow altogether and replace it with a similar interface in which products and sums are build differently, but i'm not sure if you can pursue that idea far enough in haskell.
12:49:43 <bourbaki> i have written my own arrow stuff already
12:50:40 <bourbaki> the thing is that arrows just work for single functions ... i mean how would one otherwise write a graph that has heterogenous typeing?
12:51:02 <shapr> Lemmih: what sort of xterm stuff?
12:51:05 <shapr> hej magnus-- 
12:51:08 <bourbaki> and the ability to build new types on the fly that match to the input and output of the combined arrows?
12:51:17 <shapr> magnus--: you're not Magnus Uggla, are you?
12:52:02 <Lemmih> shapr: Never mind. I can live with it.
12:52:31 <shapr> Now I'm really curious!
12:56:10 <Lemmih> shapr: I'm trying to get the bash prompt to show the current directory.
12:57:21 <psi> \w in $PS1 gives the currect directory 
12:59:07 <Lemmih> psi: What about PROMPT_COMMAND?
13:00:09 <psi> Lemmih: is that a environment variable? i haven't seen it before
13:01:29 <Oejet> Lemmih: echo $PS1
13:02:11 <Lemmih> psi: Thanks. PS1 did the trick.
13:02:16 <bourbaki> data GraphType = (HList a, HList b) => Graph (a, b) doesnt work :(
13:03:15 <TheHunter> bourbaki, you need to do data GraphType = forall a b. (HList a, HList b) => Graph (a, b)
13:03:21 <TheHunter> @wiki ExistentialTypes
13:03:22 <lambdabot> http://www.haskell.org/hawiki/ExistentialTypes
13:06:23 <TheHunter> But that doesn't really work anyway. You'll never get elements out of this you can do anything with.
13:06:26 <bourbaki> then he tells me that forall was no constructor
13:06:38 <bourbaki> hm wargh!
13:06:49 <TheHunter> using -fglasgow-exts ?
13:06:59 <bourbaki> ghci
13:07:31 <TheHunter> existentials are not haskell 98, therefore they most be enabled using the flag -fglasgow-exts
13:08:49 <bourbaki> but why wont that solve my prob?
13:09:50 <TheHunter> because you can get the 4th element of your list, but you won't be able to do anything with it since you don't know the type.
13:10:24 <bourbaki> well the type the exaclty the type at the edge
13:10:35 <bourbaki> its the same type the function at that point requires
13:11:54 * Lemmih goes unicycling.
13:12:09 <bourbaki> so i just get all the successors of the node and apply the value of that node to these functions
13:12:29 <bourbaki> the result is then written into the nodes adjacent to these edges
13:15:37 <TheHunter> bourbaki, have a look at Data.Typeable.
13:17:08 <bourbaki> TheHunter: is there an introduction somehwere on the net?
13:18:45 <TheHunter> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Typeable.html
13:19:08 <bourbaki> thx
13:20:35 <TheHunter> maybe the scrap your boilerplate papers contain some information.
13:22:09 <bourbaki> TheHunter: boiler plate papers?:)
13:22:32 <bourbaki> in which package is ps2pdf?
13:24:51 <TheHunter> dpkg -S `which ps2pdf`
13:24:51 <TheHunter> gs-common: /usr/bin/ps2pdf
13:25:26 <TheHunter> http://research.microsoft.com/Users/simonpj/papers/hmap/hmap.htm
13:35:42 <bourbaki> hm this gets really complicated :)
13:35:52 <bourbaki> though the actual thing is quite easy
13:36:23 <TheHunter> you don't need Data.Generic, just the (paragraph?) about Typeable.
13:36:54 <TheHunter> The actual thing is quite complicated, too, in a typed setting.
13:37:25 <bourbaki> yep
13:37:55 <bourbaki> if id go ahead and formulate something for the graph thingy in mathematical terms
13:38:09 <bourbaki> would you help me a bit to construct this graph type?
13:41:58 <TheHunter> bourbaki, i guess i could do that. Don't have much time the next few days, though.
13:43:06 <bourbaki> np id need to write down my stuff anyway
13:43:26 <bourbaki> id be really glad though since i know what i need but i cant to it really in haskell its so mindboggleing
13:44:15 <bourbaki> these graph/program transformations should be arrows as well such i can do fancy things with the interpreter as well
13:44:30 <bourbaki> so the interpreter is written in principle as such a network itself
13:46:09 <TheHunter> bourbaki, this might be of interest, too (an ST approach): http://www.cse.ogi.edu/~magnus/Adaptive/
13:47:27 <dblhelix> any thoughts on how i can achieve the following: I want a program :: IO () to run for n seconds maximum and to be aborted if it exceeds n seconds of running time ... any elegant approaches?
13:50:06 <bourbaki> TheHunter: are you familiar with differential geometry?
13:51:18 <TheHunter> nope.
13:51:28 <bourbaki> too bad
13:52:35 <kristnjov> familiate him
13:53:16 * dblhelix is curious too :)
13:55:42 <bourbaki> about what?
13:55:47 <shapr> dblhelix: start another thread with a timeout?
13:56:23 <bourbaki> i just need to find a way to determin the trace of a particle in a vector field
13:56:24 <dblhelix> shapr: I guess so
13:56:45 <dblhelix> bourbaki: about differential geometry
13:56:50 <bourbaki> that ie to be precise i have a repeller and an attractor and i search the trace that leads from the one to the other
13:57:24 <bourbaki> without of course calculateing all traces
13:58:12 <shapr> dblhelix: would be nice to have threads with built-in timeouts
14:00:44 <dblhelix> shapr: indeed ... but to be honest, i always try to stay away from threads and other distribution issues ... somehow they cannot interest me that much
14:02:16 <dblhelix> mmm ... maybe I should try to get over that ... chances are that I will be working in industry in a couple of months from now ... and you cannot always pick out the interesting things then, I guess :(
14:02:56 <shapr> It would be good to know at least the basics of a bunch of different stuff.
14:05:17 <dblhelix> it sure is ... but, not to brag, I think I do have a fair amount of basic knowledge ... I'm a couple of weeks from my master's now ... and i did work for three years at a middle-large software company ... it's just that i know enough to eliminate certain areas as being interesting to me ... ;)
14:05:41 <shapr> heh
14:05:59 <dblhelix> but, of course, there's still enough to learn
14:06:27 <shapr> I'm sure I'm missing a lot of the basics. My formal education was in art, radiation safety, literature, and other non-math non-programming fields.
14:07:11 <dblhelix> at least that gives you a very broad view on things, which is of course an advantage too
14:07:45 <shapr> Knowledge of proton decay doesn't help so much in programming =)
14:08:30 <dblhelix> for me, the advantage of having worked for a software company for a couple of years is that i now know i don't want to work for a company after finishing my education :)
14:08:56 <dblhelix> well, knowledge of proton decay amounts to your ability to abstract, I guess
14:08:58 <shapr> Not having a CS degree does mean I *know* I don't know everything. I'm more than willing to try what another person suggests and I'm more than willing to flagrantly wave my ignorance in hopes of repairing it.
14:10:23 <shapr> I'm also aware than Haskell is just one tool in a good toolbox, not the perfect tool for every task. Even a Leatherman tool has limitations!
14:10:27 <dblhelix> having a cs degree makes that you find it frustrating that after five years of studying you still don't know as much as you want to know
14:10:49 <shapr> I'll never know as much as I want to know. But I sure enjoy the journey.
14:11:10 <shapr> I do enjoy working in a software company, probably because I own half the company and write all the software.
14:11:38 <shapr> I am my own boss! (but also my own employee :-)
14:11:44 <dblhelix> well it's the kind of frustration i like to live with :)
14:12:39 <dblhelix> i'm the owner of half a company (albeit a very small one) for another 13 days
14:12:58 <shapr> What happens in 13 days?
14:13:39 <dblhelix> then, on January 1st, my partner w the sole owner and I st
14:13:45 <dblhelix> ouch
14:13:59 <dblhelix> I will step back and my partner will be the sole owener
14:14:07 <dblhelix> slip of the keyboard :S
14:14:51 <dblhelix> we ran it for three years together (both for 20-30 hours a week) and it was fun ...
14:15:08 <dblhelix> but not the thing i want to do for the next 40 years
14:15:19 <Riastradh> What did the company do?
14:16:46 <dblhelix> mainly web applications ... but our highlight was the development of an electronic learning environment for an institution for ???-ary education (the kind you take between age 12 and 17)
14:17:38 <dblhelix> last months we spend on the prototype for a new distribution system for digital music
14:18:16 <dblhelix> the work was great ... it's just to bad we had to deal with clients ... those were really driving me nuts
14:18:33 <dblhelix> i'm not much of a pr guy, you know
14:19:11 <dblhelix> so now I'd really fancy a position at a r&d department somewhere
14:19:21 <dblhelix> or, even better, a phd position at a uni
14:19:36 <dblhelix> still hoping for the latter
14:19:54 <dblhelix> but enough about me; how are you guys doing? :)
14:20:22 <shapr> We do webapps too. It's surprising how many are needed.
14:20:27 <shapr> And they can be really valuable to the clients.
14:20:31 <shapr> But I agree, clients suck.
14:20:53 <KrisKringle> on the other hand, clients are where the money is ;)
14:20:55 <shapr> Right now one of our largest and most regular clients just hasn't paid us for almost two months.
14:21:01 <shapr> KrisKringle: oh yeah?
14:21:02 * shapr grins
14:21:09 <KrisKringle> shapr: oops :P
14:21:35 <shapr> It's not like we'll starve, but it sure is irritating.
14:21:56 <dblhelix> the problem is that when you run a company with only two persons, a lot of your time has to be spend on administrative stuff, dealing with clients etc.
14:22:07 * TheHunter is away: I'm busy
14:23:00 <KrisKringle> dunno, shapr. i did a bit of freelance work for someone a few months back. got the up front payment, which was plenty for the entire job, but the client never paid him so he never paid me for the rest. i was sfucking pissed. 
14:23:14 <dblhelix> and things are even worse if you both don't work fulltime: for me it was just to earn me some money for paying for my education
14:23:21 <KrisKringle> it was like, %70 up front or so. 
14:24:28 <dblhelix> shapr: since when do you run your own company?
14:26:25 <shapr> y0 SyntaxNinja!
14:26:39 <shapr> dblhelix: um, three years I've been a partner, five years I've been working for the company.
14:27:46 <dblhelix> shapr: and do you see yourself doing this for, well, let's say the next fiveteen years?
14:27:50 <shapr> It pisses me off that I nearly need to build backdoors into my software to keep people paying.
14:28:07 <shapr> dblhelix: nah, I plan on becoming independently wealthy so I can do it for free.
14:28:30 <dblhelix> shapr: that's the right kind of ambition
14:28:50 <musasabi> What is the sources.list line for the debian haskell repository?
14:29:03 <musasabi> (and does that contain things for woody/sarge too?)
14:29:20 <shapr> I'm actually somewhat serious about that. I have a bunch of crazy ideas that might be cool enough to make a bunch of money. I would very much like to take a bunch of money and put it into paying for open source development.
14:29:25 <SyntaxNinja> hihi shapr
14:29:25 <dblhelix> problem for me is that i'm too ambitious to work on a production department of a larger company: software is too much about compromises
14:30:26 <shapr> Programming is the Magic Executable Fridge Poetry, it is machines made of ideas, fueled by thought.
14:30:34 <dblhelix> shapr: my partner had a lot of ideas too; problem was that all of them required three years of money to put into development
14:30:41 <shapr> Admittedly, sex is better than programming.
14:30:57 <dblhelix> no doubts about that
14:30:58 <shapr> But not food or sleep.
14:31:14 <dblhelix> agreed
14:31:29 <shapr> I don't think software is about compromises.
14:31:42 <shapr> Have you read the introduction to "Software Patterns"?
14:32:10 <dblhelix> I did, but cannot remember any highlights right now 
14:33:13 <shapr> Christopher Alexander says that his architectural students set their standards too low, they should aim for Chartres.
14:33:27 <shapr> Whoever that is :-)
14:33:49 <dblhelix> I worked for a middle-large company with people that were in the business for about fiveteen years ... they were just doing the same trick day in, day out ... no ambition to improve skills, methods or processes ... for me, it was a nightmare
14:34:17 <shapr> I think my software should fit into the same class with emacs, unix, the linux kernel, and tools with the same level of respect.
14:34:44 <dblhelix> in a way, I'm always aiming for Chartres ... but often you're not alone ... you're in a team
14:34:53 <lament> sex is better than programming?
14:34:59 <shapr> lament: yes.
14:35:01 <dblhelix> lament: it is
14:35:07 <lament> oh
14:35:07 <np_hard> iirc chris alexander has some criticisms of his own work in patterns
14:35:50 <dblhelix> shapr: do you prefer working in a small team on a small project ... or in a large team on a more ambitious project?
14:36:23 <shapr> small team, ambitious project
14:36:25 <np_hard> small teams can accomplish ambitious projects
14:36:36 <dblhelix> shapr: same for me :)
14:36:42 <lament> shapr, dblhelix: how do you know? :P
14:36:54 <np_hard> "productivity" varies among programmers so very much
14:37:26 <shapr> np_hard: right, so find the one that don't suck, figure out how you can get closer to them
14:37:39 <dblhelix> lament: well, admittedly, it's 11:35 pm on a saturday night here right now, and i *am* talking to you guys
14:37:59 <np_hard> hahah
14:38:04 <np_hard> I am just waiting for dinner
14:38:11 <np_hard> roommate is making stew
14:38:16 <dblhelix> shapr: there aren't much companies to choose from around here :(
14:38:19 <shapr> For example, I realized recently that one reason one of my finnish coworkers at my last job was so productive was that he was willing to dive into anything and at least try for an hour to fix it.
14:38:50 <dblhelix> lament: in my defence: gf is sitting next to me :)
14:38:58 <shapr> I realized that I often assume I don't know enough to fix something I've never seen before.
14:39:09 <np_hard> yeah
14:39:17 <np_hard> there are three of us here
14:39:24 <np_hard> two girls and I
14:39:31 <np_hard> all sitting with our respective laptops
14:39:42 <np_hard> this is truly paradise in earthly form :-P
14:39:46 <shapr> np_hard: unless you're also female, that's depressing :-P
14:39:54 * shapr grins
14:40:03 <shapr> What lessons have you guys learned from good programmers?
14:40:11 <lament> being a female is depressing
14:40:25 <shapr> it is?
14:40:36 <lament> you told me that!
14:40:39 <shapr> I'd like to try it sometime, temporarily.
14:40:41 <lament> i assume you're a good programmer
14:41:16 <shapr> Nah, I said that three people in the same room all using their laptops need to get a social life =)
14:41:28 <dblhelix> shapr: lessons? mmm ... hard to say ... to step away from the theory every now and then
14:41:46 <shapr> step away from the theory and come out with your hands up!
14:41:49 <np_hard> we have a month before the public smoking ban goes into effect
14:41:53 <dblhelix> in haskell: "let types guide your programming"
14:42:00 <shapr> that is a good lesson
14:42:13 <np_hard> nightclubs, bars, restaurants, other "social" venues are just not very comfortable right now
14:42:25 <lament> ouch
14:42:27 <lament> all bars?
14:42:51 <Riastradh> np_hard, whoa, where are you?
14:43:00 <np_hard> Riastradh: columbus, ohio
14:43:15 <lament> that's pretty horrible
14:43:52 <dblhelix> in haskell, it's really striking to see how hard it is to introduce bugs if you have written down the types signatures before the function definitions
14:44:23 <shapr> you're assuming that someone has thought out the program enough to do that
14:44:34 <shapr> On the other hand, a type sig is often a good summary.
14:44:46 <shapr> I'd like to have a collection of "type tricks"
14:44:54 <shapr> Like, how to easily make a value type
14:45:02 <dblhelix> shapr: well, it's a incremental process ... I don't think about writing down all signatures in advance
14:46:20 * shapr googles for haskell type tricks
14:46:41 <shapr> Any suggestions for sources of type tricks?
14:46:43 * shapr thinks
14:46:53 <shapr> SPJ did the Enron thing with the type system?
14:47:02 * dblhelix has safari still pointed to an introductory text on differential geometry
14:47:19 <dblhelix> (is introductory the right adjective?)
14:47:20 <Lor> Practically all haskell programming is "type tricks", imho. :)
14:47:51 <shapr> hm
14:48:11 <shapr> Lor: any suggestions for totally basic type tricks?
14:48:29 <shapr> TheHunter: oh hey
14:48:48 <shapr> TheHunter: do you remember once asking me how a type signature you came up with was different from the actual monadic type sig?
14:48:50 <dblhelix> generic programming is all about type tricks
14:49:07 <dblhelix> well, actually I like to think of it as fighting the type system
14:50:03 <shapr> Yeah, I was thinking about how to make a DSL for Martin Fowler's Analysis Patterns recently. I realized I need a bunch of product/enumerate/etc combinators.
14:50:04 <Darius> @wiki CommonHaskellIdioms
14:50:04 <lambdabot> http://www.haskell.org/hawiki/CommonHaskellIdioms
14:50:09 <shapr> Not sure if that's the right way to do that though.
14:50:17 <shapr> Darius: oh good choice
14:52:03 <dblhelix> shapr: have you ever considered @google functionality for lambdabot (not sure if i asked you before)
14:52:17 <shapr> dblhelix: sure, write it!
14:52:35 <Darius> shapr: Wasn't there something like that a long time ago?
14:53:03 <shapr> Simon Foster wrote something that used his own SOAP code
14:53:07 <dblhelix> shapr: :) too many projects already right now ... most notably a master's thesis
14:53:08 <Darius> shapr: Have you also thought about replacing @wiki with @eval wikify "blah"
14:53:13 <shapr> and needed the HAIFA framework, I think
14:53:22 <shapr> Darius: would be sensible
14:53:30 <shapr> would probably be even more sensible to have an irc DSL
14:53:32 <Darius> @define wikify \x -> "http://www.haskell.org/hawiki/"
14:53:32 <lambdabot> wikify defined
14:53:41 <Darius> @eval wikify CommonHaskellIdioms
14:53:41 <lambdabot> http://www.haskell.org/hawiki/
14:53:46 <Darius> @define wikify \x -> "http://www.haskell.org/hawiki/"++x
14:53:47 <lambdabot> wikify defined
14:53:47 <Darius> @eval wikify CommonHaskellIdioms
14:53:48 <lambdabot> unbound variable: CommonHaskellIdioms
14:53:53 <shapr> the long gone @fact command might be handy too
14:53:55 <Darius> @eval wikify "CommonHaskellIdioms"
14:53:56 <lambdabot> http://www.haskell.org/hawiki/CommonHaskellIdioms
14:54:08 <Darius> Only problem is that it's less convienient.
14:54:21 <Darius> shapr: That was the one I was thinking of yesterday.
14:54:27 <shapr> unless lambdabot's default commands fall through to eval
14:54:32 <shapr> then you do have an irc dsl
14:54:34 <shapr> sort of
14:54:49 <dblhelix> what did the @fact command do?
14:55:01 <TheHunter> shapr, hmm, i don't remember.
14:55:03 <shapr> read/write a postgresql database
14:55:03 <Darius> shapr: That might be interesting to do.  If we did do that though, @eval's code would not be appropriate.
14:55:10 <shapr> Darius: how so?
14:55:49 * dblhelix yawns (not because of what has been discussed and is being discussed though)
14:56:02 <Darius> shapr: I wrote it mostly to be simple and to play with monad transformers.
14:56:19 <dblhelix> think i'm going to call it a day
14:56:22 <shapr> yeah, I've pointed a bunch of people to Eval for that reason.
14:56:31 <TheHunter> shapr, btw, i think lambdabot forgot about @more.
14:56:38 <dblhelix> cu guys tomorrow
14:56:42 <shapr> cya dblhelix 
14:56:47 <shapr> TheHunter: yeah, I need to fix that...
14:57:05 <shapr> I had two major changes in mind for lambdabot that haven't happened...
14:57:14 <shapr> first, switch to hs-plugins from the custom framework
14:57:51 <shapr> second, I was hoping that I would uncover a real OTP-style distributed framework for running Haskell apps so that lambdabot could be distributed on multiple machines and I could distribute the admin that way.
14:58:00 <Darius> That would be sensible.
14:58:21 <Darius> That would also allow a very efficient eval (though with horrible latency).
14:58:33 <shapr> the distributed part?
14:58:42 <Darius> The first part.
14:58:45 <shapr> ah
14:59:26 <shapr> I think scannedinavian is going to unexpectedly disappear for possibly weeks at some unspecified point in the future.
14:59:35 <shapr> So I'm trying to get everything mirrored.
14:59:58 <Riastradh> It's not going to be very unexpected now, is it?
15:00:12 <shapr> depneds on whether it actually happens or not.
15:07:18 <jesse98> hmm, I'm getting odd behavior with Parsec, I have a production like "try (many element)" that acts as if it's consuming input even though element should fail
15:08:02 <shapr> what about many1 element ?
15:08:45 <jesse98> same thing
15:09:17 <shapr> Have you tried to unit test it?
15:09:45 <jesse98> well I have a unit test for my grammar...
15:09:53 <shapr> I wrote a test_run for my parsec stuff
15:09:59 * shapr looks
15:10:37 <shapr> test_run = (flip parse) ""
15:11:10 <shapr> and I wrote run :: Show a => Parser a -> String -> IO ()
15:11:20 <shapr> which is handy for interactive testing of parsec bitz
15:13:06 <Darius> jesse98: What then is it returning?
15:13:30 <jesse98> it's returning an error message within element
15:13:56 <jesse98> but I thought the try should suppress that and back the parser up
15:15:29 <Darius> What's the alternative to that production?
15:16:01 <jesse98> there is no alternative, it should succeed and eat tokens, or fail and consume nothing
15:16:42 <shapr> can you show your code for element? is it short?
15:17:20 <jesse98> it's 6 or so lines
15:18:44 <shapr> @eval wikify HaskellIrcPastePage
15:18:44 <lambdabot> unbound variable: HaskellIrcPastePage
15:18:59 <Riastradh> @eval wikify "HaskellIrcPastePage"
15:18:59 <shapr> @eval wikify "HaskellIrcPastePage"
15:18:59 <Darius> @wiki HaskellIrcPastePage is still more convenient.
15:19:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:19:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:19:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage is still more convenient
15:19:07 <shapr> truly
15:19:17 <shapr> @dump
15:19:17 <lambdabot> dumped
15:19:41 <shapr> Where do you think the idea of an interpreted irc scripting lang would go?
15:20:47 <musasabi> shapr: into building a small working eval for haskell hopefully ;)
15:20:49 <Darius> For lambdabot?  Into making most of the plugins.
15:21:18 <jesse98> i think the docs are just misleading try only seems to work in conjuction with alternation
15:21:39 <shapr> what about using option instead?
15:21:45 <Darius> jesse98: Yes, the point of try is that Parsec doesn't maintain the information for backtrack by default.
15:31:39 <Darius> So shapr... you're hacking away at an IRC scripting language for lambdabot as we speak, right?
15:31:53 <shapr> no, actually not
15:38:34 <shapr> I'm playing with keymaps in Yi
15:38:36 <shapr> hej svend 
15:39:16 * musasabi is trying to install woody/sid/sarge under qemu to create packages and test them
15:39:40 <svend> hi shapr 
15:40:49 <shapr> Darius: what are you working on?
15:41:28 <Darius> Right now, I'm mostly reading mail and a bit earlier I was adjusting my firewall.
15:47:17 <shapr> Darius: any suggestions for programming music?
15:47:33 <Darius> shapr: Programming music in what way?
15:48:10 <Darius> shapr: Haskore-like, sound synthesis, sound manipulation, simply playing music?
15:50:50 <shapr> music to listen to
15:52:18 <Darius> Ah
15:52:35 * Darius was totally off course.
15:53:51 <Darius> As much as I like Bad Religion it can be pretty distracting, but if you do want very driving socio-political music, try the freely available songs from their new album.
15:53:56 <shapr> english is so ambiguous.
15:55:09 <Darius> Though sometimes I do find myself hours later realizing I've just sung through several CDs worth of Bad Religion while I've been doing something else.
15:55:21 <shapr> yeah, my favorite music does that to me too
15:55:39 <shapr> downside is that I have both neighbors and a strong singing voice
15:56:24 <Darius> This is a link if you are interested: http://www.epitaph.com/bands/index.php?id=369
15:57:20 <shapr> I just grabbed "Let Them Eat War" "Sinister Rouge" and "Sorrow"
15:58:01 <Darius> shapr: Segovia is rather pleasant and, if you are into guitar, amazing, and with no words it's more limited in its potential to distract.
15:58:25 <Darius> shapr: Without "Overture", "Sinister Rouge" is -very- hard hitting.
16:00:34 <shapr> Truly the guitar is excellent.
16:01:46 <Darius> shapr: Well, Bad Religion focuses mostly on vocals.  I'm pretty certain they have some of the best choruses in the punk rock genre.
16:03:01 <Darius> As "Sorrow" will demonstrate, there are quite a few less driving songs.
16:04:22 <shapr> I like driving songs, in both senses.
16:04:47 <Darius> shapr: I do too, but sometimes it's not what I want.
16:06:31 <shapr> The Crystal Method is some of the best programming music for me.
16:07:29 <svend> the ghc compiler I ported to netbsd-alpha freezes when I run it.  what is the best way to debug it?
16:08:22 <kristnjov> pink floyd - dark side of the moon is the programming music of all time... i'd bet they had functional programming in mind while recording that album
16:08:41 <shapr> svend: I've heard gdb
16:08:44 <musasabi> svend: maybe gdb
16:09:07 <Darius> Some other bands I listen to (in no particular order) are: Alkaline Trio, Jimmy Eat World, Sublime, Red Hot Chili Peppers, Nanase Aikawa and occasionally Offspring and No Doubt; not sure which of those would be best programming music, though I've certainly listened to them all while programming.
16:10:32 <shapr> I bought a Jimmy Eat World album, it didn't do much for me. I sure do love that one track though.
16:10:42 <shapr> RHCP is great.
16:10:55 <shapr> I don't know Alkaline Trio, Sublime, or Nanase Aikawa
16:11:01 <svend> I'll give gdb a try.  I'm not sure if it got built with debugging turned off or not.
16:11:25 <kristnjov> rhcp WERE great...
16:11:30 <kristnjov> alkaline trio are great
16:11:46 <kristnjov> the other bands ... s*ck in my opinion, but who am i to judge :P
16:12:38 <kristnjov> can't say i've heard nanase aikawa though :)
16:12:54 <wli> Godflesh, Samhain, Siouxsie and the Banshees, Fear Factory, Brujeria, Luxt, etc.
16:13:24 <kristnjov> cannibal corpse, stabwound, defleshed, cock and ball torture, anal cunt, behexen...
16:13:33 <kristnjov> namedropping is my favourite hobby
16:14:02 <wli> heh, a band named after a G. G. Allin song
16:14:08 <kristnjov> which one?
16:14:21 <wli> point
16:14:24 <kristnjov> haven't really tried to listen to gg allin seriously, i see him mostly as a joke.'
16:14:31 <wli> he is
16:14:41 <kristnjov> well he was, i heard he died
16:14:58 <wli> 10 years ago
16:15:01 <kristnjov> rumour is he used to fling his own faeces into the audience...
16:15:10 <wli> that's no rumor
16:15:14 <wli> that's on videotape
16:15:17 <kristnjov> lol
16:15:41 <kristnjov> okay, well a RUMOUR is that he didn't bathe for like a whole year and then wrote his name into the shit on his chest
16:15:53 <Darius> shapr: You don't know Sublime?(!)
16:15:59 <kristnjov> in the same way that you write "wash me" on dirty cars
16:16:05 <kristnjov> Darius, they're not too famous in sweden
16:16:30 <Darius> kristnjov: Yeah, but shapr's not Swedish.
16:16:35 <kristnjov> he lives in sweden though
16:17:16 <shapr> Famous doesn't have much use with me, I don't really watch tv, read newspapers or that sort of stuff.
16:17:37 <kristnjov> although in some way you recognize the hives, isn't that odd
16:17:50 <kristnjov> my point is that you don't have to stay updated to know what bands are "in"
16:19:20 <Darius> Well, Sublime's not "in" any more, the lead singer died quite a while back and Sublime died with him.
16:19:57 <shapr> I know The Hives becuase a coworker of mine got me to listen to them.
16:20:28 <kristnjov> when was that, 95-96?
16:22:11 <Darius> kristnjov: '96 
16:22:25 <kristnjov> not _that_ long ago
16:23:16 <Darius> kristnjov: About Nanase, I'd be surprised if you knew her unless you were into J-pop
16:23:37 <wli> I probably do more anime soundtracks than jpop proper
16:23:51 <kristnjov> i'm not into j-pop more than mini moni
16:24:22 * Darius isn't into J-pop but Nanase is actually pretty good, and the guitarist is great!
16:25:28 <Darius> Cage by Dir En Grey is also a great song, but I haven't listened to many others, and I doubt I'd like the most of them.
16:25:53 * Darius isn't really into Goth let alone Japanese Goth.
16:26:31 <wli> "visual kei"
16:26:40 * Darius only knows about these bands because he has a friend with too much free time on his hands (apparently).
16:29:17 <Darius> Anyways, I'm going shopping.
16:33:56 <musasabi> visual kei fans tend to be quite annoying.
16:34:11 <musasabi> but then again I know too many teens..
16:36:40 <wli> there's always the "guess what the actual sex of the Mana clone is" game that's good for a few laughs. So many manage to rather precisely reproduce the album cover photographs it's meaningless.
16:38:52 <musasabi> I was more disturbed by their thinking that visual kei / egl is much more deep, real and less commercially inspired than the western counterparts.
16:39:16 <wli> oh, bizarre
16:50:03 <shapr> hiya no98no
16:50:11 <no98no> where can i download a free haskell compiler ?
16:50:25 <shapr> from http://www.haskell.org/ghc/
16:50:46 <no98no> thanx shapr
16:51:05 <shapr> I was in Athens once a coupla years back, it's a nice city.
16:51:16 <Lemmih> Are there non-free Haskell implementations?
16:51:33 <no98no> shapr : it is :) , next time try the islands
16:51:34 <shapr> Lemmih: um, sort of?
16:51:46 <shapr> no98no: oh, I went to the islands too. We spent a week on Hydra.
16:51:54 <shapr> It's *beautiful*
16:51:57 <Lemmih> shapr: Sort of?
16:52:02 <svend> what does ghc's -B<dir> option do?  I couldn't find it in the flag reference.
16:52:16 <no98no> yep, its nice there, no cars
16:52:37 <shapr> Lemmih: GHC is BSD, I think both BlueSpec and Cryptol are derived from GHC.
16:53:54 <shapr> I think there are some other modified GHC derivative products
16:53:57 <no98no>  shapr : is there any smaller free compiler?
16:54:09 <shapr> Yes, but you'll probably end up wanting to use GHC.
16:54:18 <shapr> NHC is smaller, and produces smaller binaries.
16:54:43 <shapr> I actually don't remember where to get NHC, because I always use the debian packages.
16:54:52 <Lemmih> no98no: Interpreters are great for learning.
16:54:53 <shapr> aha
16:54:59 <shapr> no98no: http://www.haskell.org/nhc98/
16:55:23 <Lemmih> no98no: Hugs is a small and fast Haskell interpreter.
16:55:30 <shapr> no98no: Are you learning Haskell for business or pleasure?
16:55:58 <no98no> pleasure and for university
16:56:07 <reffie> there are people who learn haskell for business?
16:57:07 <shapr> me me!
16:57:11 <shapr> well, sort of...
16:57:35 <shapr> Actually, there have been a few people who showed up here to learn Haskell for job interviews.
16:57:58 <reffie> cool
16:58:00 <shapr> no98no: Do you have any questions? Anything I can do to help you?
16:58:40 <no98no> no :) , at first it was difficult to understand but now i am ok
16:59:00 <no98no> it's a very different language
16:59:02 <shapr> ok, feel free to ask any questions that you find.
16:59:06 <shapr> Yes, it is. I really like it.
17:00:53 <shapr> I find that Haskell is amazingly expressive. I can do a lot of work with a little bit of code.
17:01:53 <no98no> fow what kind of problems u usually use haskell ?
17:02:16 * esap uses haskell for writing compilers.
17:02:31 <wli> I use Haskell where others would largely use perl.
17:02:55 <no98no> yep, perl is my language :)
17:02:59 <shapr> I use Haskell for testing my Zope work, sometimes shell script stuff, xml transforms, pretty much anything.
17:04:22 <no98no> i see
17:05:51 <shapr> Would you to see some code? Or maybe try out some applications?
17:06:42 <no98no> no prob
17:06:52 <no98no> that woulb be good
17:07:37 <shapr> this is a simple taste of the syntax and very basic usage - http://www.haskell.org/hawiki/HaskellDemo
17:07:56 <shapr> Here's a wiki written in Haskell - http://www.scannedinavian.org/cgi-bin/flippi/flippi
17:08:32 <shapr> There's the beginnings of a vim/emacs clone with elisp-quality interactivity here - http://www.cse.unsw.edu.au/~dons/yi.html
17:08:42 <shapr> lambdabot is written in Haskell
17:08:43 <shapr> @yow
17:08:44 <lambdabot> I predict that by 1993 everyone will live in and around LAS VEGAS and
17:08:44 <lambdabot>  wear BEATLE HAIRCUTS!
17:08:55 * shapr tries to think of other interesting applications
17:08:58 <shapr> oh darcs is nifty
17:09:08 <shapr> darcs - http://darcs.net/
17:09:39 <shapr> Are you interested in anything in particular?
17:10:50 <musasabi> Is there a good tutorial to creating debian packages of cabalized haskell libraries?
17:10:51 <no98no> i ll look the links you gave, thanx :)
17:11:14 <shapr> ok
17:23:38 <desrt> is there a name for a function that can be defined solely by its own type signature?
17:27:22 <musasabi> libghc6-cabal-dev talks about doing it, but I cannot find an actual way to do it...
18:28:06 <bourbaki> you know what i wonder about really?
18:28:20 <bourbaki> i have checked out this haskell merchandiseing site
18:28:30 <Riastradh> http://www.cafepress.com/skicalc
18:28:43 <bourbaki> and there are HOT strings tangas :) since then i wonder if they sell them alot
18:28:46 <Riastradh> (see the back)
18:31:07 <bourbaki> heh whats that about?
18:31:24 <Riastradh> It's about the Hindley-Milner principal type inference algorithm, _duh_!
18:31:40 <bourbaki> type inference?
18:32:20 <arjanb> heh
18:35:19 <dons> hehe. that's nice
18:35:34 * Riastradh bows.
18:36:34 <dons> that's one of the best haskell-ish ones I've seen, in fact.
18:53:56 <bourbaki> .
18:55:40 <dons> g.f
19:05:07 <shapr> ... --- ...
19:05:12 * shapr grins
19:07:14 <dons> (.) . (.) $ (.) . (.)
19:08:53 <arjanb> @type (.) . (.) $ (.) . (.)
19:08:55 <lambdabot> (.) . (.) $ (.) . (.) :: forall a a1 a2 b c a3.
19:08:55 <lambdabot> 			 (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> a3 -> b) -> a2 -> a3 -> c
19:09:47 <dons> @type .
19:09:49 <lambdabot> bzzt
19:09:50 <dons> @type (.)
19:09:52 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
19:10:03 <dons> @type (.) id id
19:10:04 <lambdabot> (.) id id :: forall a. a -> a
19:10:10 <dons> @type id . id
19:10:11 <lambdabot> id . id :: forall a. a -> a
19:10:18 <dons> now, where is infix . defined?
19:11:17 <dons> found it
19:43:06 <jadrian> what is the relation between Strafunski and "Scrap your boilerplate" ?
19:43:26 <jadrian> could google for it, but to lazy now :P
19:43:50 <shapr> strafunski did the first "deriving" I think
19:44:12 <shapr> I also think it has some basic 'generic haskell' functionality, which is the whole point of "boilerplate"
19:44:37 <shapr> I think strafunski does even more than that, since it includes a bunch of strategies I've never really played with.
19:44:58 <jadrian> yeap
19:45:10 <jadrian> I think Drift does the deriving, no?
19:45:12 <shapr> I vaguely recally reading in the docs that it can do some code-based generation of product types, etc
19:45:35 <jadrian> hmm I thought that was drift...
19:45:44 <shapr> As for more relation, Data.Generics comes with GHC, and building Strafunski is a pain in the butt.
19:45:53 <jadrian> :)
19:45:54 <shapr> I spent a coupla hours without success last week.
19:46:13 <jadrian> I thought you could just download and import strafunski...
19:47:17 <jadrian> "How does the boilerplate approach relate to Strafunski?"
19:47:23 <jadrian> "How does the boilerplate approach relate to Generic Haskell?"
19:47:25 <jadrian> lol
19:47:30 <jadrian> it's in the homepage :)
19:48:48 * jadrian is going to get some sleep
19:48:54 <jadrian> bye shapr! 
19:49:01 <jadrian> bye all
19:52:27 <dons> argh. 39.1C
20:15:38 <svend> hey dons
20:23:54 <dons> hey svend: how goes the alpha?
20:24:15 <dons> still looping?
20:25:45 <dons> looking back over my notes from the osf/alpha port I see that I couldn't get it passed the stage1 compiler, which looped when it was invoked. 
20:25:49 <dons> didn't figure it out. 
20:26:05 <dons> but at  the same time igloo got the linux/alpha port working fine.
20:35:05 <svend> dons: yep, the stage1 compiler loops.  I used gdb, and it broke out of the loop at 0x1211220a0 in StgRun ()
20:39:09 <jdrake> hmm, vertices x:xs cn | cn >= n   = x : xs   gets me a parse error in pattern, not sure why
20:40:29 <cm> sup
20:40:53 <jdrake> parse error in pattern is what is up ;-(
20:43:13 <jdrake> http://paste.lisp.org/display/4441#1   has the code in question. I wish it would give a better description
20:55:42 <dons> svend: I think you need to build a debug version of the compiler, which will give you actual line numbers in gdb
20:56:06 <dons> you could ask on the mailing list for the best way to debug this problem -- simonm will have good ideas
20:57:38 <dons> ghc should always port, so the fact that we couldn't build it on two different alphas is interesting, and needs to be tracked down. and i wonder why the linux port worked?
20:57:53 <wli> is there an unfoldM?
20:58:22 <dons> don't think so.
20:58:25 <desrt> wli; what would that do?
20:59:20 <wli> I envisioned something like:
20:59:21 <wli> unfoldM f x = do
20:59:21 <wli>                 y <- f x
20:59:21 <wli>                 case y of
20:59:21 <wli>                         Nothing -> return ()
20:59:21 <wli>                         Just z  -> unfoldM f z
20:59:46 <wli> or some such
20:59:59 <dons> unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]
20:59:59 <dons> unfoldr f b  =
20:59:59 <dons>   case f b of
20:59:59 <dons>    Just (a,new_b) -> a : unfoldr f new_b
21:00:00 <dons>    Nothing        -> []
21:00:07 <wli> it
21:00:14 <wli> it's not a perfect analogue
21:00:31 <wli> I vaguely wonder if the case is even necessary
21:00:59 <desrt> uhm
21:01:05 <desrt> where does it ever give you something other than ()?
21:01:09 <wli> or if I could just do unfoldM f x = f x >>= unfoldM f or some such
21:01:14 <wli> the result is obviously unimportant
21:01:30 <dons> the above is sequence_
21:01:47 <wli> sequence_ of some list I suppose
21:02:01 <dons> oh, sorry. yes.
21:02:14 <dons> I'm thinking of: 
21:02:14 <dons> repeatM_ :: Monad m => m a -> m ()
21:02:14 <dons> repeatM_ a = a >> repeatM_ a
21:02:26 <wli> I think the termination and space bits differ
21:08:21 <dons> you can probably do something nice with the Maybe monad
21:08:51 <dons> or maybe just fmap
21:09:52 <wli> well
21:10:19 <wli> it's basically \f x -> sequence (iterateM f x) except with a workaround or two for termination and space
21:10:23 <wli> feh
21:10:32 <wli> \f x -> sequence_ (iterateM f x) 
21:11:34 <wli> feh
21:11:40 <wli> where the heck did iterateM go?
21:13:13 <wli> no idea
21:14:45 <wli> *Main> let iterateM f x = do { xs <- iterateM f (f x) ; return $ x:xs }         cmTypeOfName: iterateM
21:14:45 <wli> iterateM :: forall m a. (Monad m) => (a -> a) -> a -> m [a]
21:16:03 <dons> @type Control.Monad.liftM2 iterate
21:16:05 <lambdabot> Control.Monad.liftM2 iterate :: forall a2 m.
21:16:05 <lambdabot> 				(Monad m) =>
21:16:05 <lambdabot> 				m (a2 -> a2) -> m a2 -> m [a2]
21:16:19 <wli> I guess that's why iterateM is unnecessary.
21:16:26 <wli> or maybe not...
21:16:33 <dons> not quite the same.
21:17:07 <wli> anyway, I fiddled with iterateM
21:18:11 <wli> and the space behavior wasn't the same as unfoldM
21:19:05 <wli> I originally called it loopM or fixM or something
21:20:05 <svend> dons:  does the ghc build system use CFLAGS?
21:20:22 <wli> mfix is really the closest thing
21:21:18 <dons> or Control.Monad.Fix.fix (\loop -> putChar 'x' >> loop)
21:21:43 <dons> svend: I don't think so. C compiler flags have a special var
21:21:54 <dons> SRC_CC_OPTS, for one
21:22:20 <dons> GhcRtsCcOpts
21:22:36 <wli> dons: well, the idea is a repl that keeps some state going but supports a "quit" command
21:23:21 <dons> can you just write a recursive function?
21:23:40 <wli> yes
21:23:50 <svend> dons: what is the correct way of compiling with debugging turned on?
21:24:19 <wli> kind of a waste though
21:24:27 <dons> svend: you'll have to check the docs. -DDEBUG gives you .hs debug code. and I think -g is enough for the rts
21:24:31 <wli> the pattern should be doable with HOF in the libs
21:25:38 <dons> svend: maybe just 'way=debug'
21:25:58 <dons> look in mk/config.mk.in for "debug"
21:29:30 <svend> config.mk.in mentions -DDEBUG, but I didn't think it applied when you are bootstrapping ghc from the hc files, because you are using gcc to compile.
21:29:39 <wli> probably something to do with monad transformers
21:30:58 <dons> svend: maybe CC_OPTS works?/
21:31:16 <dons> HC_BOOT_CC_OPTS
21:31:41 <dons> EXTRA_CC_OPTS etc etc
21:33:10 <svend> I'll see which one works.
21:33:19 <dons> just grep around mk/target.mk
21:33:22 <dons> for CC
21:33:46 <dons> I think this is actually defined somewhere. maybe the building guide?
21:55:54 <mar3> I'm trying to implement a counter without creating a recursive function to intialise and increment it...here is what I have
21:57:43 <mar3> map ( \(ParamSQL nomSQL modeSQL typeSQL ) -> Case n+1 [Return ("get"++(toUpperFirst nomSQL)++"()")])  ps       what I would like to do is to have a counter for Case that starts at 0 and is incremented for each element of ps...is it even possible to do it without an extra function ?
21:58:18 <dons> length ps ?
22:01:00 <mar3> length ps only gives me the the total length of my list :(
22:02:11 <dons> mapAccumL ?
22:05:50 <wli> hmm, data IOResult t = IOResult (IO (Maybe t))
22:05:55 <wli> this is not easy to make a monad
22:10:59 <mar3> mapAccumuL doesn't do the trick either :(
22:13:45 <mar3> by the way does anyone know if there is an efficient way to determine the type of a function (On a piece of paper and not using :type) ? 
22:19:51 <wli> oh, yeah
22:19:54 <wli> unfoldM (\s -> if s == "quit" then return Nothing else putStr "> " >> hFlush stdout >> getLine >>= return . Just) ""
22:22:55 <srid> YAHT looks boring
22:25:56 <np_hard> foldl' (+) 0 [1::Int ..100000]
22:25:57 <np_hard> 705082704
22:25:57 <np_hard> (0.03 secs, 5001988 bytes)
22:26:06 <np_hard> why so much memory consumption?
22:27:03 <wli> spiffier
22:27:08 <wli> unfoldM (\(n,s) -> if s == "quit" then return Nothing else putStr (show n ++ "> ") >> hFlush stdout >> getLine >>= return . Just . (,) (n+1)) (1,"")
22:27:22 <Nioate> np_hard: laziness?
22:27:25 <Nioate> maybe
22:27:45 <np_hard> foldl' is strict
22:28:13 <Nioate> okay
22:28:15 <np_hard> i guess laziness means you store the calculation though
22:28:29 <Nioate> hos is foldl' defined?
22:28:40 <np_hard> it's Data.List.foldl'
22:29:09 <Nioate> I see
22:29:16 <Nioate> I have no idea
22:29:57 <np_hard> i guess it must be [1..100000]
22:29:59 <np_hard> it is lazy
22:30:33 <Nioate> I don't know that it matters, but don't trust me
22:31:23 <mar3> thanks anyway bye
22:39:27 <cm> "I believe in God because there is no other explanation for Apple\u2019s continued existence."
22:41:07 <wli> monad transformers hmm
22:41:48 <wli> cm: =(
22:44:23 * cm updates his servers to PHP 4.3.10.. fucking security issues with 4.3.9
