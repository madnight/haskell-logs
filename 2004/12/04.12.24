00:00:21 <Leimy> wli: what about with dups? :)
00:00:45 <wli> Prelude> let { select x (y:ys) zs = if y < x then select y ys (x:zs) else select x ys (y:zs) ; select x [] zs = (x,zs) ; selectSort [] = [] ; selectSort (x:xs) = let (y,ys) = select x xs [] in y : selectSort ys } in selectSort [5,1,5,2,5,3,5,4,5]
00:00:45 <wli> [1,2,3,4,5,5,5,5,5]
00:00:51 <Leimy> nice
00:01:05 <Leimy> what I really need is a "swap" :)
00:01:10 <Leimy> not a remove
00:01:23 <Leimy> and I can do an "unstable" selection sort
00:01:32 <Leimy> by not caring which of the duplicates I swap
00:02:38 <Leimy> but haskell "swap" seems hard :)
00:03:18 <wli> if you want it stable then do this
00:03:33 <wli> oh forget it
00:03:36 <Leimy> heh
00:03:51 <wli> you have to basically do findIndex on the minimum
00:04:31 <wli> zip [0..] xs and then find the minimum with like foldr of a min that ignores the first of the pair
00:05:14 <wli> then partition (>=idx)
00:05:34 <wli> well
00:05:39 <wli> then partition ((>=idx) . snd)
00:05:46 <wli> then peel the min off the true half
00:05:57 <Leimy> at which point quicksort is cheaper
00:05:57 <wli> then ++ of the remainders
00:06:01 <wli> by a longshot
00:06:28 <wli> stable selection sort isn't really doable without being imperative I think
00:10:08 <wli> worse than bubblesort where I put it
00:10:13 <wli> heck
00:10:21 <wli> it's not particularly cheap as I wrote it above
00:14:15 <monk00> any ideas how to make an "all_combinations (x:xs) n" function that returns all possible combinations of n elements from list (x:xs) ?
00:14:20 <Leimy> just seems like the constant overhead present in quicksort might warrant a faster n^2 algorithm for short string sorts
00:14:24 <wli> "combinations"?
00:14:32 <Leimy> wli:  reading the backlog?
00:15:23 <monk00> yes, combinations
00:15:37 <wli> monk00: ah, choose (length (x:xs)) n
00:15:52 <wli> monk00: well, first use nub
00:16:11 <wli> monk00: then make all possible decisions...
00:16:17 <monk00> num ?
00:16:20 <wli> nub
00:16:23 <monk00> nub?
00:16:26 <wli> yes
00:16:46 <monk00> never heard that in my 5 days of haskell life
00:18:25 <wli> Prelude> let xs = ([1..5] ++ reverse [1..5]) in (xs, List.nub xs)
00:18:25 <wli> ([1,2,3,4,5,5,4,3,2,1],[1,2,3,4,5])
00:20:26 <monk00> what List.nub does ?
00:20:48 <wli> removes duplicates
00:20:57 <wli> the result is the input with duplicates removed
00:21:11 <monk00> i see
00:21:38 <wli> Prelude> let { selectN n xs [] zs = (reverse xs, zs) ; selectN n (x:xs) (y:ys) zs = if y < x then selectN n (take n $ List.sortBy (flip compare) (y:xs)) ys (x:zs) else selectN n (x:xs) ys (y:zs) } in selectN 2 [7,6] (reverse [1..5]) []
00:21:38 <wli> ([1,2],[3,4,5,6,7])
00:21:43 <wli> that looks good
00:22:06 <wli> probably < vs. <= braindamage
00:22:23 <wli> no, < is good
00:22:27 <wli> it's the largest
00:22:36 <wli> and it's primed with n
00:23:35 <wli> \n xs -> let (xs, ys) = splitAt n xs in selectN n xs ys []
00:23:40 <wli> that's probably more "customary"
00:24:16 <Leimy> just found this one :)
00:24:17 <Leimy> import List (insert)
00:24:17 <Leimy> insertionSort :: Ord a => [a] -> [a]
00:24:17 <Leimy> insertionSort = foldl (\ a b -> insert b a) []
00:26:16 <Leimy> since "insert" already does the right thing for a list "sorting wise" :)
00:29:05 <Leimy> insert e [] = [e]
00:29:14 <Leimy> insert e lst@(x:xs) 
00:29:23 <Leimy>     |  e < x = e : lst
00:29:37 <Leimy>     | otherwise = x : (insert e xs)
00:30:10 <Leimy> the algorithmic "insertion" is just easier to express than trying to find an item and swap it from selection sort
00:30:15 <Leimy> in Haskell anyway
00:30:43 <Leimy> my understanding is that selection sort is generally one of the better performing O(n^2) sorts though
00:34:56 <wli> it won't be as I wrote it
00:35:02 <Leimy> yeah
00:35:02 <wli> it modifies stuff as I wrote it
00:35:20 <wli> dirty cachelines etc.
00:38:10 <Leimy> @ foldl (\a b -> List.insert b a) [] 
00:38:11 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
00:38:21 <Leimy> @ foldl (\a b -> List.insert b a) [] "badjakdlfjalE"
00:38:22 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
00:38:24 <Leimy> hmmm
00:38:30 <Leimy> @foldl (\a b -> List.insert b a) [] "badjakdlfjalE"
00:38:31 <lambdabot> Sorry, I don't know the command "foldl", try "lambdabot: @listcommands"
00:38:43 <Leimy> lambdabot: @listcommands
00:38:44 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
00:38:44 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
00:38:44 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
00:38:44 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
00:38:44 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
00:38:44 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
00:38:47 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
00:38:49 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
00:38:50 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
00:38:56 <Leimy> hmm should have messaged it eh?
00:39:47 <Leimy> @eval foldl (\a b -> List.insert b a) [] "dfjkldasjfkaleajlk"
00:39:48 <lambdabot> <<EM Dynamic -> EM Dynamic>>
00:39:52 <Leimy> oh well
00:39:55 <Leimy> I give up :)
04:06:50 <maeglin> as haskell newbie i have a question concerning your favorite text editor: lisp programmers tend to use emacs; c programmers use both.. how about the haskell community ?
04:07:04 <maeglin> s/both/vim or emacs
04:07:50 <cptchaos> maeglin: I use vim ...
04:08:15 <TheHunter> maeglin, me too, but I think we're a minority here.
04:09:20 <maeglin> ok, personally i prefer vim too
04:09:32 <cptchaos> I thing you should use the Editor, that you like most
04:11:07 <wli> nvi forever
04:11:35 * TheHunter does `darcs pull http://www.cse.unsw.edu.au/~dons/yi'
04:14:16 <TheHunter> yi is an editor written in haskell and will be superior to both vim and emacs.
04:28:51 <wolfman8k> problem with vim is that it doesn't indent haskell
04:35:21 <TheHunter> anyone got an idea how to implement "call-by-need"-lists?
04:35:44 <TheHunter> so that middle :: [a] -> a
04:35:44 <TheHunter> middle xs = walk xs xs where
04:35:44 <TheHunter>   walk (_:_:ys) (_:zs) = walk ys zs
04:35:44 <TheHunter>   walk _ (x:_)         = x
04:35:44 <TheHunter>   walk _ _             = error "Impossible"
04:35:50 <TheHunter> won't leak space.
05:13:12 <cptchaos> before I forget it, I wish you all a merry Christmas ...  
05:58:32 <wli> let's see what I can do
06:15:30 <shapr> whee!
06:19:33 <shapr> hiya srid 
06:21:41 <wli> hmm, Skolem functions
06:24:09 * shapr casts a clay skolem spell
06:25:35 <wli> I need a logic programming -based command interpreter.
06:26:17 <srid> hi shapr 
06:31:14 <srid> shapr: i am deferring the haskell thing ... first learning common lisp (pcl) .. then will learn haskel
06:32:28 <wli> well, hmm, Term :- [Term] is a bit weak
06:33:05 <shapr> srid: ok
06:38:35 <CosmicRay> merry christmas, everyone!
06:41:18 <maeglin> i think xmas is tomorrow
06:41:35 <CosmicRay> yeah... let's chalk it up to rounding error :-)
06:41:43 <maeglin> lol ok
06:47:03 <MegaMonad> G'day saz, ltns.
06:47:33 <TheHunter> Ah, crap, even newtype CList a = CL { runCL :: forall r. r -> (a -> CList a -> r) -> r} causes sharing.
06:47:46 <TheHunter> MegaMonad, Merry Christmas
06:47:52 <MegaMonad> TheHunter: Is it christmas in croatian. I can probably find it much easier to write it for christmas.
06:48:06 <CosmicRay> MegaMonad: you should be more festive!
06:48:11 <MegaMonad> CosmicRay: Me is going to prod don and i are from miranda. So seems almost as festive as a general numeric type.
06:53:19 <CosmicRay> MegaMonad: well.  that was characteristically understandable of you.
06:53:25 <MegaMonad> CosmicRay: Public in what i did, it would be understandable if you want me to make.
08:25:41 <goron> Does anyone knows a BSD irc channel? 
08:26:06 <goron> knows->know
08:27:56 <TheHunter> ////////////////////////////
08:28:01 <TheHunter> \\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:28:18 <TheHunter> sorry
08:28:36 <maeglin> #freebsd ?
08:30:00 <goron> yes. I searched for bsd irc on Google, but that didn't help. Thanks. 
08:30:42 <Riastradh> goron, try using /LIST or ChanServ's LIST command.
08:31:06 <Riastradh> Quite a lot of them.
08:37:27 * shapr sings christmas songs
08:38:39 * Riastradh sings Tom Lehrer's Christmas carol.
08:41:40 * xerox claps
09:02:16 * sam_ took both pills
09:07:27 <shapr> I'm color-blind, I took the yellow pill.
09:11:44 <tintin> shapr: yellow pill puts you back into the matrix right ?
09:43:29 <sam_> I just clicked on my first ad on google, and you thought web advertisements were useless!
09:57:05 <sam_> I don't get it: "A complete lattice is a poset (L,<) in which every subset of L has both an infimum and a supremum", sounds to me if thought of as a graph possibly with autoloops, and what about the empty set?
09:57:41 <sam_> menat to be ...if thought of as a graph, as a chain...
09:58:06 * ibid got some 15 clicks on his election textad on google in october
09:58:12 <sam_> meant :)
09:58:18 <ibid> (it ran for two weeks)
09:59:30 <sam_> election?
09:59:51 <ibid> general municipal elections
09:59:57 <ibid> in finland
10:00:09 <ibid> i ran in my home town for a seat in the city council
10:01:07 <sam_> and ...
10:01:35 <sam_> won/lost?
10:01:39 <ibid> i was the first candidate in my list that didn't get even a deputy seat
10:02:24 <sam_> :) whats the population of your hometown 15 clicks doen't sound too bad
10:02:37 <ibid> 80000
10:02:49 <ibid> rounded down to tens of thousands :)
10:04:14 <ibid> (if even one of the councillors or deputy councillors of my party resigns during the term, i'll be promoted to vice councillor)
10:04:26 <ibid> (due to my position as the first loser:)
10:06:30 <ibid> sam__: hmm?
10:06:46 <sam__> "the application has unexpectedly quit", it gives itself too much credit it wasn't so unexpected
10:06:53 <ibid> heh
10:07:05 <ibid> do i need to repaste?
10:07:15 <sam__> i saw 80000
10:07:38 <ibid> 20:01  <ibid> rounded down to tens of thousands :)
10:07:38 <ibid> 20:02  <ibid> (if even one of the councillors or deputy councillors of my party resigns during the term, i'll be
10:07:42 <ibid>               promoted to vice councillor)
10:07:44 <ibid> 20:02  <ibid> (due to my position as the first loser:)
10:16:04 <shapr> man, "Love Actually" is such a great christmas movie.
10:16:10 <shapr> y0 SyntaxNinja 
10:23:52 <SyntaxNinja> y0
10:24:11 <maeglin> yo guys
10:25:17 <cptchaos> @yow
10:25:18 <lambdabot> Dehydrated EGGS are STREWN across ROULETTE TABLES..
10:25:31 <maeglin> haskell is indeed very nice.. what a pity that i haven't learned it earlier
10:25:43 <TheHunter> MegaMonad, yo
10:25:49 <MegaMonad> TheHunter: Or an expression to evaluate, then expand that first yo?
10:27:00 <sam__> The source for MegaMonad is this channel?
10:27:21 <TheHunter> yep
10:27:28 <sam__> cool
10:29:26 <TheHunter> sam__, if you're still wondering, the inf and sup of the empty set are the greatest and the least elements, respectively.
10:30:35 <sam__> huh? what elements?
10:30:49 <sam__> oh I get it
10:30:54 <sam__> thanks
10:31:27 <sam__> wait no I don't
10:33:14 <ibid> MegaMonad: what is a complete lattice?
10:33:20 <MegaMonad> ibid: Because it's a lattice that you have a complete lattice.
10:33:57 <ibid> MegaMonad: gee, thanks :)
10:34:03 <MegaMonad> ibid: `Gee, i'd better stay ahead of time.
10:38:53 <sam__> MegaMonad: what is the absorption law?
10:38:59 <MegaMonad> sam__: The law is the absorption law?
10:39:35 <ibid> MegaMonad: are you an expert in functional programming?
10:39:42 <MegaMonad> ibid: The only way currently to make me choose a different view of programming it in haskell is functional.
10:40:20 <sam__> almost a joke
10:41:08 <Riastradh> That made so much sense I thought it was someone really speaking, until I saw the nick.
10:42:20 <ibid> MegaMonad: you are killing me :(
10:42:25 <MegaMonad> ibid: You are killing me for a file out at me.
10:44:56 <sam__> MegaMonad: should I buy 'the algebra of programming' it isn't in the library?
10:45:01 <MegaMonad> sam__: Haskell programming is an ultraproduct of a library to be an algebra.
10:47:23 <ibid> MegaMonad: could you please come and finish this module for me? i'm getting tired of it...
10:47:28 <MegaMonad> ibid: To finish, this really looks a bit tired at the same module was just me.
10:47:42 <TheHunter> MegaMonad, should I run 2.6.7-pax or 2.6.9 vanilla?
10:47:47 <MegaMonad> TheHunter: And 6 is the list of arrows, 2. It is 9 lines !
10:48:50 <sam__> MegaMonad: could you give me an example of a lattice?
10:48:55 <MegaMonad> sam__: For example, a speed of tan is going to get you the whole lattice.
10:50:04 <ibid> MegaMonad: are you a reincarnation of the oracle at delphi?  you sure sound like it.
10:50:09 <MegaMonad> ibid: Spark_: are you a reincarnation of the oracle in the stanza that has a lot on fp within embedded system is sound?
10:50:30 <ibid> i'll take that as a definite maybe
10:50:33 <ibid> as is fitting
10:51:50 <sam__> MegaMonad: are you being sarcastic?
10:51:56 <MegaMonad> sam__: Shapr: i know, it's me who wrote the emacs rolodex, it's got code to try to stop me from having a hard time choosing which. They are match after appearance in a sarcastic sense.
10:55:14 <maeglin> i just installed haskell-mode but i don't want my source code indented 8 whitespaces when pressing tab, 2 or 4 would be ok..
10:55:32 <Philippa> you don't really want to use tab at all IMO
10:56:12 <ibid> MegaMonad: it is my experience that haskell-mode generally honors whatever indents i use
10:56:15 <ibid> blah
10:56:16 <Philippa> however, IIRC 8 spaces is the standard-defined meaning of tab in Haskell (think about it, it matters)
10:56:17 <MegaMonad> ibid: Generally the way he does it say haskell do the honors?
10:56:19 <ibid> maeglin: it is my experience that haskell-mode generally honors whatever indents i use
10:56:36 <ibid> maeglin: you may have to press tab more than once
10:57:24 <maeglin> ibid, oh yes, you're right.. but can i configure haskell-mode so that it will indent my code 4 spaces when i press tab just once ?
10:57:45 <ibid> maeglin: why would you want to?
10:58:05 <maeglin> ibid, because pressing tab once is faster than pressing it twice
10:58:06 <ibid> maeglin: generally the amount of indentation is determined by what is on the previous line
10:58:29 <ibid> maeglin: yes, but indenting 4 spaces unconditionally is often the wrong thing to do
10:58:34 <ibid> in terms of syntax
10:58:42 <maeglin> oh ok
10:59:26 <ibid> maeglin: most of the time, haskell-mode settles to the correct indentation as specified in the previous line with just one tab press
10:59:36 <ibid> but there are situations when you need to press it more than once
10:59:42 <ibid> and once in a while it gets it wrong
10:59:57 <maeglin> oh, ok.. so indentation amtters *so* much in haskell ?
11:00:09 <tuomov> no
11:00:33 <tuomov> it just looks crappy if you indent n spaces always
11:00:53 <tuomov> although for the compiler just a chance in indentation level suffices
11:00:57 <maeglin> i just noticed that haskell-mode does not automatically indent code (unless i press tab of course) .. is this "correct behavior" ?
11:00:59 <ibid> yeah, you *can* write your code so that all indents are multiples of 4 for example
11:01:11 <ibid> but that's usually more trouble than it's worth
11:01:16 <sam__> ooh an indentation discussion
11:01:19 <ibid> maeglin: that's what all emacs modes do
11:01:28 <ibid> maeglin: by default, at least
11:01:34 <maeglin> ibid, no. slime doesn't, erlang-mode doesn't either
11:01:38 <ibid> well, not counting python-mode, i guess
11:01:42 <ibid> maeglin: slime?
11:01:52 <ibid> maeglin: c-mode and derivatives do
11:01:54 <tuomov> jed haskell mode is quite primitive so I just manually indent all the time
11:01:59 <tuomov> ... waiting for yi ...
11:02:18 <maeglin> ibid, superior lisp interaction mode for emacs
11:02:31 <ibid> maeglin: heh
11:02:39 <sam__> MegaMonad: what is the proper way to indent code?
11:02:44 <maeglin> ibid, well, slime is just yet another lisp-mode
11:02:44 <MegaMonad> sam__: And so that's code you want to do  data object = sphere of radius * material' do ? I don't know what your latest cabal mail where you can patch the proper way to indent this for me to get the same code.
11:02:45 <ibid> maeglin: the only slime i was aware of  was an abandoned mua
11:02:50 <maeglin> :)
11:03:33 <ibid> (the stupid little mailer by liw)
11:03:52 <maeglin> so what's haskell-mode's indentation function called so i can call it whenever i hit <return>
11:04:13 <ibid> tried describe-key?
11:04:37 <maeglin> thanks :D
11:05:17 <tuomov> modes rebind tab? ugly.
11:05:34 <ibid> i have no idea
11:53:35 <maeglin> my inferior haskell mode (ghci) won't start, turn-on-haskell-ghci doesn't return an error though
12:00:02 <maeglin> sry, works.. just forgot the c-c c-s lol
12:16:50 <Spark> there were 10 in a bed and the little one said "roll over, roll over"
12:17:00 <Spark> so they all rolled over and one fell out...
12:19:44 <Spark> can anyone unravel the mystery of expansions / liftings in intersection types
12:21:58 <Spark> come on, its christmas
12:29:56 <monochrom> come on, it's christmas, all of us are stuck in traffic
12:41:53 <Spark> gawd
12:54:33 <dblhelix> Spark: i'm no expert, but Pierce's PhD thesis is known to be a very accessible introdution to the subject
12:55:09 <dblhelix> merry xmas
12:56:33 <ibid> MegaMonad: have you read pierce's phd dissertation?
12:56:39 <MegaMonad> ibid: Should i be writing a dissertation on the server for a phd.
12:56:53 <ibid> MegaMonad: i don't know. should you?
12:56:59 <MegaMonad> ibid: Reverse                 :: [a] -> [a.
12:57:12 <ibid> MegaMonad: don't change the subject!
12:57:17 <MegaMonad> ibid: Shapr wonders if -threaded would make it law for some reason, whenever you make it clear that you're the subject questions the way to get a 404 again soon, though. Once my new version of russell's paradox correctly at a time.
12:57:36 <ibid> :)
12:57:59 <Spark> mm ive got that here actually
12:58:21 <Spark> i know the general gist of it but i havent read more than about 10 pages of the introduction
12:58:40 <Spark> let me stare blankly at it once again...
12:58:53 <ibid> :)
12:59:11 <ibid> MegaMonad: what is more important, programming or writing a dissertation?
12:59:17 <MegaMonad> ibid: And then thread the state changes) and then writing it with my dissertation on the programming basics.
12:59:34 <ibid> MegaMonad: i wish i could write a dissertation on programming basics
12:59:38 <monochrom> MegaMonad: which part should one read first, the introduction or the third chapter?
12:59:40 <MegaMonad> ibid: Programming in my dissertation supervisor (graham hutton) wrote for the basics.
12:59:45 <MegaMonad> monochrom: First of it is the chapter in the same person either read a pretty good introduction, i can only see.. Monochrom!
13:00:00 <ibid> MegaMonad: you studied under graham hutton?
13:00:05 <MegaMonad> ibid: That's amazingly close to me, why not graham hutton.
13:00:13 <ibid> MegaMonad: good for you
13:00:19 <MegaMonad> ibid: Syntaxninja: data gvmt = anarchy | despotism | monarchy | republicanism | democratic deriving (eq, ord, read, show) (see 6.1.8) <-- ahh ok.
13:01:04 <monochrom> wow MegaMonad can write code!
13:02:12 <ibid> MegaMonad: write some more, complete this module from hell...
13:02:18 <MegaMonad> ibid: Hell i am stuck on a module to be complete anyway.
13:02:25 <Spark> MegaMonad: fix
13:02:31 <MegaMonad> Spark: Ozone: i had it with solution rootpuz, which would need to find out more of maybe or something, must fix that.
13:02:49 <Cale> MegaMonad: y f
13:02:54 <MegaMonad> Cale: Fold f is, f is f the same as union?
13:02:56 <Spark> MegaMonad: (\x.xx)(\x.xx)
13:03:01 <MegaMonad> Spark: Let f x = f xx.
13:03:05 <Spark> cool
13:03:12 <Cale> hehe
13:03:20 <Spark> not quite the same
13:03:25 <Spark> thats 3 lots of it isnt it?
13:03:56 <Spark> (\x.xxx)(\x.xxx)
13:04:16 <ibid> MegaMonad: ($)
13:04:21 <MegaMonad> ibid: My mostly automatically generated paterror being created wrongly, but haven't read that as "tee minus n applied to the troops. Male ego stopped anyone claiming that a little svn->tla script at aetion.
13:04:37 <Spark> MegaMonad: sylvia plath
13:04:42 <MegaMonad> Spark: S/manager/mangers.
13:04:51 <Aglarion> Merry christmas everywhere
13:05:09 <Spark> where about in his phd thesis should i be looking then :)
13:05:46 <Aglarion> Happy day for me... I just wrote my first actually working, not-so-trivial haskell program
13:06:07 <maeglin> yo Aglarion 
13:06:07 <ibid> Aglarion: conga rats
13:06:57 <Aglarion> This is a big step for me, since previously my longest programs where about 2-3 lines with very simple recursion (that is factorials, fibanocci numbers and stuff)
13:08:36 <Cale> so what sort of program did you write?
13:11:19 <Aglarion> I don't know the correct english word for it... "interval nesting" or so... a program that takes a function, a left and a right border and precision value and searches for places where the function returns values with abs(y)<precision.
13:11:49 <Cale> ah, nice.
13:13:32 <maeglin> Aglarion, this reminds me of some kind of square root generation
13:14:36 <Cale> maeglin: it's root-finding for general functions
13:14:37 <Aglarion> you could use it for this purpose...
13:14:59 <maeglin> cool
13:15:11 <maeglin> oh yes, you have to pass it a function as argument .. :)
13:15:22 <Cale> i.e. find x such that x^2 - a = 0, and you have sqrt(a)
13:15:28 <Aglarion> just use \x -> x*x-root as function argument
13:15:40 <maeglin> yep, nice :)
13:16:45 <Aglarion> It was the first algorithm we discussed in school. (You remember the MaTA thing?)
13:17:00 <Aglarion> In most cases it's very in-efficient
13:17:12 <Spark> ok im having difficulty finding reference to expansions / liftings in pierce's phd thesis
13:17:17 <Spark> and theres no index :)
13:17:21 <Spark> and i have no digital copy...
13:17:31 <Aglarion> Spark: good luck then :-)
13:17:43 <Aglarion> or try OCR with even more luck
13:17:49 <maeglin> Aglarion, yes, i have read something about MaTa - education yesterday..  very interesting indeed
13:17:54 <Spark> fuck scanning it all :)
13:19:02 <Aglarion> not quite as interesting as it might sound. where did you read it, besides on this channel?
13:21:42 <monk00> any ideas on how to make a "all_combs n (x:xs)" function that returns all possible combinations of n elements from list (x:xs) ? is it possible ?
13:21:59 <Aglarion> it is possible.
13:22:35 <Spark> sounds like a homework assignment to me :)
13:22:47 <Spark> i seem to recall doing something similar once, it was just a little recursive function
13:24:17 <monk00> little ?
13:24:50 <Aglarion> argh...
13:25:05 <Aglarion> I have language problems describing s way to do this...
13:25:13 <Aglarion> s/s/a
13:25:31 <Philippa> monk00: yep. Think about it a moment
13:26:30 <Philippa> the possible combinations of a:as are all the combinations of as without an a, and all the combinations of as with a added
13:26:56 <Philippa> if you're bored, you can just generate that then take all the results of length n...
13:27:15 <Philippa> there /will/ be a better way to do it, but hey
13:28:15 <Aglarion> create a function that goes throu the list
13:28:32 <Philippa> Aglarion: my definition does that for you :-)
13:28:46 <Philippa> okay, you need a base case, but hey
13:29:03 <Aglarion> for each element: remove it, call function with remaining list and append removed element afterwards
13:29:08 <maeglin> Aglarion, i googled a bit for it.. and found some web site..
13:30:30 <Aglarion> in english? I had problems finding a german web site about it
13:30:46 <monk00> let me google it too
13:31:37 <Aglarion> http://de.wikipedia.org/wiki/Mathematisch-Technischer_Assistent is a german text about it... maybe google or the like can translate it for you...
13:32:51 <Aglarion> monkOO probably meant something completely different...
13:33:09 <Aglarion> this page is actually not solving any of your problems monkOO
13:35:39 * CosmicRay bounces
13:35:47 <Cale> monk00: here's how to think about it: How would you construct all_combs (x:xs) if you already had all_combs xs done for you?
13:35:50 <CosmicRay> my wife got me Haskell: The Craft of Functional Programming for Christmas! :-)
13:36:37 <Cale> In general, a good way to think about functions on recursive data.
13:37:48 <Aglarion> x can not only appear as head of one combination 
13:38:03 <Aglarion> it can appear in any place in the list of length n
13:39:08 <Cale> hm?
13:39:17 <Cale> That would be all permutations of all combinations
13:39:26 <Aglarion> or is it about unordered combinations?
13:39:36 <Cale> combinations are generally unordered subcollections
13:39:38 <monk00> Cale : the problem is that i have also a "n" parameter , for the lenght of combinations
13:40:01 <Aglarion> you just pass n - 1 to the recursive call and stop is n = 0
13:40:11 <Aglarion> like all_coms 0 _ = []
13:40:16 <Cale> right
13:41:09 <Aglarion> Cale: sorry about me misunderstanding the term "combination". must have confused it with permutations
13:41:41 <maeglin> Aglarion, no, it was in german
13:41:58 <maeglin> Aglarion, since i am a native german speaker (like you) it was no problem for me to understand :)
13:42:05 <Cale> Aglarion: that's fine - it's easy enough to do even if they are ordered -- you just have to pull out a single element in each possible way
13:42:59 <Aglarion> maeglin: oh...
13:43:04 <Aglarion> "gut zu wissen"
13:44:01 <Aglarion> Cale: that's what I tried to express with my humble english
13:45:24 <Aglarion> but I think I will do the same exercise, just to see if i can do it in haskell
13:45:49 <Aglarion> the recursive algorithm itself should be no problem... my problem is writing it down in haskell
13:46:54 <Aglarion> maeglin: what city do you live in?
13:49:33 <maeglin> Aglarion, Kiel.. and you ?
13:50:03 <Aglarion> Kassel, but I am going to move to Bremen next fall
13:50:42 <maeglin> i see.. do you want to study computer science after you have become a MaTa
13:51:04 <maeglin> i have read that some university accept MaTa status as "Vordiplom"
13:52:21 <Aglarion> yes, that's why i go to bremen. did'nt know about this fact... i actually chose Bremen, because it's the only university in germany where my girl-friend and I can study together
13:53:02 <Aglarion> it is actually the only university that teaches psychology and computer science
13:53:10 <shapr> d00d
13:53:52 * ibid notes that my university teaches cs and psych (not in germany though:)
13:53:58 <Aglarion> (and i read that RoboCup 2006 will be in bremen...)
13:54:03 <maeglin> Aglarion, i have heard that bremen is considered the best university for cs in germany
13:54:27 <Aglarion> really? i actually never heard that before... but makes things even better :-)
13:54:37 <maeglin> so did you first get your "abitur" and then started the MaTA thing ?
13:54:44 <Aglarion> yes
13:54:45 <sond> merry xmas
13:54:59 <Aglarion> (it's funny mixing german words into english sentences)
13:55:10 <maeglin> Aglarion, yes, a relative of ours studied cs there in the 1970s..
13:55:28 <maeglin> Aglarion, yes, but i doubt there is an english word for abitur
13:55:29 <Aglarion> thats a long time ago...
13:55:45 <maeglin> yeah, bremen was even the first university where you could study cs
13:55:58 <Aglarion> maeglin: thats not right...
13:56:02 <Aglarion> wait a moment...
13:56:14 <maeglin> no?
13:56:20 <maeglin> one of the first then :)
13:56:33 <Aglarion> ok, i think i can accept that...
13:57:13 <Aglarion> somewhere on informatik.uni-bremen.de, they write they are not  the first...
13:57:42 <maeglin> i'll try to study cs in kiel after my abitur
13:57:54 <maeglin> you don't need any NC in bremen, do you ?
13:57:58 <Aglarion> no
13:58:05 <maeglin> but for psychology ?
13:58:08 <Aglarion> yes
13:58:13 <maeglin> i bet 1.x
13:58:32 <Aglarion> the problem is, psychology goes throu the "ZVS"
13:58:45 <maeglin> ohh
13:59:00 <Aglarion> and she will most probably not get the 1.x nc. so she's likely to wait a few semesters
13:59:23 <maeglin> i prolly get a 3.0 nc
13:59:27 <Aglarion> i had 2.2
13:59:35 <maeglin> not bad
13:59:58 <Aglarion> but not very good... a few friends of mine had 1.3 or 1.2
14:00:45 <Aglarion> the problem where classes like history or politics or german... i just hate those
14:01:06 <maeglin> me too. i really suck at german especially
14:01:21 <Aglarion> if i had not been able to choose computerscience and maths as my "Leistungskurse" i'd had 3.x, too
14:01:45 <Aglarion> got 15 points in "informatik-abiturprüfung" :-)
14:01:48 <maeglin> i couldn't... i had computer science in grade 11  with 15 pts  but it wasn't offered as LK
14:02:01 <maeglin> so i had to take maths and physics as LKs
14:02:24 <maeglin> got currently 11 points in maths and 9 in physics.. 
14:02:46 <Aglarion> had 12 in maths... but 8 in history (P3) and 8 in english (P4)
14:03:09 <maeglin> i hope i get 12 in maths in the final exams too
14:03:35 <Aglarion> do have 4 or 5 final exam courses?
14:03:50 <maeglin> 4
14:04:09 <maeglin> 3 written, 1 oral
14:04:39 <Aglarion> In Hessen, my age-group was the last to do 4. All followers had to do a 5th exam: a presentation
14:05:09 <Aglarion> i'm very happy I didn't have to do this
14:05:45 <maeglin> i can imagine.. i guess students who were using powerpoint were rated better than students with ooffice
14:06:17 <Aglarion> I actually don't know anything about their results... 
14:07:17 <Aglarion> but it's nice to know, there are other Tolkien-readers out there, who are also interested in computer science. I almost began thinking i was the only one...
14:07:59 <maeglin> i think i have only met very few of them
14:08:50 <Aglarion> you're probably the first one i ever met
14:10:03 <Aglarion> (well... germany counts only 80 million people... how there be more than 2?)
14:10:18 <maeglin> probably there are :)
14:10:26 <Aglarion> s/how /how could
14:10:37 <Aglarion> probably :)
14:11:27 <Aglarion> i'm working on a little encyclopedia-website for tolkien related things, but writing the actual articles for it is a hell...
14:11:52 <maeglin> cool, is it already up ?
14:12:24 <Aglarion> no, it's far far FAR from complete. i have my good old LotR books glued with little post-its with important information on it
14:13:17 <Aglarion> and about 50% of this is already typed into my notebook, but it's neither formulated nor well organized
14:13:25 <Aglarion> it's just too much information
14:14:00 <maeglin> in english ?
14:14:01 <Aglarion> on nearly every page, you find information that might be of interest, descriptions of places, persons, ...
14:14:04 <Aglarion> german
14:14:36 <maeglin> btw, have you read the books series "history of middle earth" ?
14:14:52 <Aglarion> i don't have a single english tolkien book. but when i order history of middle earth 3-12, i need to use english, since they are not available in german
14:15:13 <Aglarion> i have "Lost tales 1+2", the only ones translated into german
14:16:44 <Aglarion> i actually don't want to buy a new book, before i have not excerpted all information from a) LotR, b) The Hobbit c) Silmarillion d) Lost Tales e) "Nachrichten aus Mittelerde" and f) LotR appendencies
14:17:13 <Aglarion> have to go sorry... back soon
14:18:16 <maeglin> me too :)
14:18:36 <maeglin> maybe we should continue in a query, since we are "a bit" off topic
14:18:36 <maeglin> brb
14:33:59 <maeglin> Aglarion, back
15:21:49 <Darius> for a wiki wiki name, Underestimated or UnderEstimated?
15:26:53 <Aglarion> back... i hate siblings
15:27:16 <jdrake> Darius, one word - the former, two words the latter
15:27:45 <ski> hm, for what i know, you have to have at least two parts (but not fully sure. some wikis might possibly allow it anyway ..)
15:28:03 <Darius> ski: It'll have more parts, but I'm wondering which looks better.
15:28:07 <Aglarion> maeglin, where did we stop?
15:28:52 <Darius> I'd say the first one is more "correct" but the second more pleasing.
15:33:46 <maeglin> Aglarion, we were just talking about "history of middle earth" and i was suggesting if we sould continue in a query
15:33:53 <maeglin> s/sould/should
15:37:07 <Aglarion> monkO have you solved your problem?
16:00:04 <ski> MegaMonad: Merry Christmas!
16:00:09 <MegaMonad> ski: Dblhelix: how do you want it for christmas.
16:00:59 <ski> MegaMonad: Well, i like having a nice meal
16:01:04 <MegaMonad> ski: Philippa wonders idly if anybody can help you with the a, but i think i don't know the english word for meal.
16:01:38 <ski> MegaMonad: The English word for 'meal' is, unsurprisingly, 'meal'
16:01:43 <MegaMonad> ski: Unsurprisingly, i'm more of a meal that a really, really evil question to ask whether there's a word.
16:02:04 <ski> MegaMonad: I lost it nw.
16:02:10 <MegaMonad> ski: You can think of values still need at least of it you i think i've lost it nw.
16:02:36 <ski> MegaMonad: What values do you like?
16:02:42 <MegaMonad> ski: (Me is not safe, for all values of forever that i dislike about haskell.
16:03:01 <ski> MegaMonad: Do you like haskell then?
16:03:07 <MegaMonad> ski: Jaffacake: do you dislike? Specifically? Not just the haskell i can think of me?
16:05:05 <ibid> MegaMonad: what is it about haskell that you like?
16:05:10 <MegaMonad> ibid: This is interesting, because it makes it haskell/fpish is that i dislike about the fact that you have me there.
16:06:01 <ibid> MegaMonad: i have you where?
16:06:06 <MegaMonad> ibid: C is my other test code as a nun's knickers to me...
16:06:45 <ibid> MegaMonad: so, you like C?
16:06:50 <MegaMonad> ibid: Even perl does not dislike clean itself. It's actually doing r&d into the result of the first c of c and i?
16:07:38 <ibid> MegaMonad: perl is developing something?  am i to understand that this 'something' is a counter to clean?
16:07:45 <MegaMonad> ibid: Oh, clean is a category with the counter.
16:08:00 <ibid> he's being unusually lucid :)
16:11:15 <ibid> MegaMonad: who is your favourite person?
16:11:21 <MegaMonad> ibid: It's my favourite things about my pipes stuff in my .hs file.
16:40:35 <Cale> MegaMonad: Hello
16:40:40 <MegaMonad> Cale: To make a language other than hello world.
16:40:52 <Cale> MegaMonad: Cale: To make a language other than hello world.
16:40:58 <MegaMonad> Cale: It's hello in a world of stuff has been joking about the 'successful' part :-9.
16:41:14 <Cale> MegaMonad: Cale: It's hello in a world of stuff has been joking about the 'successful' part :-9.
16:41:20 <MegaMonad> Cale: Hello to you under the impression that a must be joking.
16:41:47 <Philippa> 'sfunny, you only really appreciate the significance of Hello World when you do FP or something of that ilk IMO
16:55:23 <bourb> moin
17:00:07 <Darius> Philippa: No, not at all.  Hello world is trivial in most FP languages too, even Haskell.  No, you only truly appreciate the significance of "Hello World" when you implement the necessary IO libraries at the bare metal level.
17:00:13 <Darius> Damn.
17:02:42 <Darius> Philippa: Did you get the last thing I said immediately before you were disconnected?
17:10:38 <Philippa> nope
17:10:54 <Philippa> I assume my own comment made it through?
17:14:33 <Darius> <Darius> Philippa: No, not at all.  Hello world is trivial in most FP languages too, even Haskell.  No, you only truly appreciate the significance of "Hello World" when you implement the necessary IO libraries at the bare metal level.
17:21:23 <Philippa> Darius: heh. I guess what I was referring to is the significance of "World" in Hello World
17:21:41 <Philippa> the rest's just "damn, that was hard work"
17:40:56 <Darius> What do people think of the page here, http://haskell.org/hawiki/WikiSandBox and any additions (I'm sure there are some, I haven't gone through everything I have and this is a preliminary version).
17:43:15 <Philippa> at first glance, I'm inclined to say that some of the analogies you dismiss only apply when you use the extensions (though fair enough at that point)
17:44:47 <Darius> Philippa: Which?  I can think of examples that make each incomparable to the other.
17:44:53 <Darius> (without extensions)
17:45:14 <Darius> (though with Java 1.5 I'd have to check some things)
17:46:37 <Philippa> 'k. What's the example for java interfaces?
17:47:20 <Darius> Constructor classes in general (at least pre Java 1.5)
17:47:54 <Darius> Mostly because Java didn't have type constructors.
17:47:54 <Philippa> that's just a "Java lacks this outright" though, in that there aren't type constructors either
17:47:59 <Philippa> right
17:55:24 <ultramagnus> um
17:55:52 <ultramagnus> what are the features that would make haskell better/nicer than Lisp?
17:56:59 <Riastradh> Better in what way?
17:57:27 <ultramagnus> well.. don't they attract the same type of crowds?
17:57:36 * Darius laughs.
17:57:39 <Riastradh> That's a rather general question.
17:57:59 <ultramagnus> yeah
17:58:34 <ultramagnus> well, I just would like to know why people would choose to use Haskell instead of Lisp
17:58:52 <Riastradh> That depends on what they're using it for.
17:58:55 <Darius> ultramagnus: Nowadays it probably seems like that because most people who "find" either are the kinds of people who look at non-mainstream languages and look around.
17:59:13 <Darius> ultramagnus: How similar the crowd is beyond that is debatable.
17:59:58 <ultramagnus> hmm.. but some universities seem to use Haskell as a Lisp substitute
18:00:08 <Riastradh> A Lisp 'substitute?'
18:00:14 <ultramagnus> instead of Lisp
18:00:23 <ultramagnus> in programming courses
18:00:51 <Riastradh> Rather than making questions that are prompted by thin curiosity and not much background knowledge, why don't you learn both Haskell and Scheme or some other Lisp?
18:02:41 <ultramagnus> yeah I guesss
18:02:49 <ultramagnus> are there any nice Haskell windows IDEs?
18:02:59 <Riastradh> Emacs
18:03:37 <Darius> ultramagnus: There's also an Eclipse plugin.  There was HIDE, but I think it was mostly stillborn (or I could be totally wrong).
18:04:06 <ultramagnus> ok
18:04:19 <Philippa> or a syntax highlighting file for your favourite text editor'll do nicely
18:04:20 <Darius> ultramagnus: Or because Riastradh saying Emacs and me being a vimmer requires it, vim.
18:04:21 <Philippa> I'm using TextPad
18:05:27 <Philippa> btw, the uni "lisp substitute" thing is really because unis were using lisp as a haskell substitute in FP courses
18:05:33 <ultramagnus> but I'm an IDE guy.. and I don't really call Emacs an IDE :)
18:05:37 <Philippa> usually the lisp in question being Scheme
18:05:48 <Philippa> there aren't any good debuggers, so an IDE makes far less sense
18:06:04 <Philippa> me, I call Emacs a weird OS with a bundled text editor...
18:06:09 <ultramagnus> Philippa: but Lisp is older
18:06:11 <Darius> ultramagnus: People call Emacs an Operating System, how could it be less than most IDEs?
18:06:15 <Riastradh> There is no Haskell environment of the calibre of a good Lisp environment.
18:06:24 <monochrom> OS is not IDE.
18:06:33 <Philippa> ultramagnus: right. Folks used scheme 'til haskell was good enough
18:06:38 <monochrom> (Would you call Linux an IDE? :D)
18:06:39 <Philippa> and older lisps before scheme
18:07:03 <Philippa> no, but emacs has a text editor intimately linked to it which gets a bit closer
18:07:06 <Darius> monochrom: If it were also called a text editor, possibly.
18:07:32 <ultramagnus> Darius: you seen the class designer of VS2005?
18:07:36 <ultramagnus> that's what I call an IDE =)
18:07:44 <ultramagnus> very neat stuff
18:07:52 <Philippa> you don't /need/ the class designer crap with haskell
18:08:18 <Philippa> now, the as-you-type typechecking would be cool
18:08:50 <ultramagnus> yeah, are there any intellisense-like Emacs scripts for haskell?
18:09:12 <ultramagnus> hmm, is Haskell infix?
18:09:14 <Philippa> er, not that I know of, which is a shame. OTOH, you'll be doing a lot less typing elsewhere
18:09:25 <Philippa> it could be - `Haskell`
18:09:30 <Riastradh> There exist infix operators in Haskell.
18:09:30 <monochrom> haskell is more than infix.
18:09:44 <Philippa> monochrom: you've found a way to do distfix? :-)
18:09:47 <Riastradh> It is rather meaningless to call a language infix, however.
18:11:20 <monochrom> Suppose you have a function named "mod" (actually it is already in the standard library).  You can write 5 `mod` 3 if you wish.  You can also give it a precedence if you don't like the default precedence.
18:11:58 <ultramagnus> oh.. coolt
18:11:59 <monochrom> Suppose you have an operator named "+" (actually it is already in the standard library).  You can write (+) 2 3 if you wish.  Also (+ 2) and (2 +).
18:12:03 <ultramagnus> -t
18:12:15 <ultramagnus> ah, very dynamic
18:12:30 <monochrom> This is what I mean by "more than infix".
18:13:13 <monochrom> You probably come from the 20th century so you find it cool.
18:13:35 <monochrom> I come from the 22th century and I think it's the minimum requirement.
18:14:18 <Philippa> well, *I* come from the 23rd century and think the entire concept of fixity is ludicrous... :-)
18:14:24 <Riastradh> I think it's a superfluity of syntax that distracts from semantics.
18:15:06 <ultramagnus> :)
18:15:44 <Darius> monochrom: You may want to look at OBJ3 on that aspect.
18:16:01 <monochrom> Yeah Philippa, my son keeps telling me "who in his right mind would specify computer behaviour by text?" :D
18:17:12 <ultramagnus> monochrom: and what does he suggest instead? :)
18:17:24 <Riastradh> monochrom, yes, that's why Lisp's syntax is defined in terms of Lisp objects and why good Lisp environments since 1974 have offered structure editors, not just text editors.
18:17:46 <monochrom> He suggested something that I don't understand.
18:18:09 <shapr> text is a pretty silly way to specify behaviour
18:18:45 <ultramagnus> Riastradh: and VS2005 has a class designer
18:18:48 <shapr> I'm glad text is getting closer to a plugin.
18:18:56 <Darius> ultramagnus: Regarding the IDE issue, most people here would probably identify themselves with "language mavens" as used in http://lambda-the-ultimate.org/node/view/395 and the referenced blog post.
18:18:58 <shapr> Anywaye, time to go be social.
18:19:38 <Darius> ultramagnus: Having a constant flexible environment is more valuable than a bunch of language specific IDEs.
18:20:14 <Darius> (to them)
18:20:19 <ultramagnus> ok
18:20:29 <shapr> oh, neat LtU node. I like the claim that people go from tool to language mavens, but never the other way.
18:20:57 <Riastradh> I disagree with that classification.  It is silly to consider either less important than the other.
18:21:55 <Darius> Riastradh: The classification makes them about equal, not one better than the other.
18:22:30 <Darius> Riastradh: Just that to some extent most people lean significantly more towards one than the other.
18:23:15 <ultramagnus> Darius: guess I'm a tool maven then.. I like to get things done quickly in a neat and coherent way
18:23:36 <Darius> ultramagnus: So do I, that's why I'm a language maven.
18:23:51 <monochrom> I'm a language maven. I like to get things done quickly in a neat and coherent way.
18:23:58 <ultramagnus> :)
18:24:01 <monochrom> (way = language)
18:25:14 <ultramagnus> but in my experience.. very few problems lend themselves to RAD development in more simple environments like Emacs and the like
18:25:36 <ultramagnus> or very few projects rather
18:25:51 <ultramagnus> the way I see it... Emacs is a great snippet editor, but a lousy IDE
18:25:59 <Darius> In my experience, very few problems lend themselves to RAD development in more common languages like Java and C++.
18:26:02 <ultramagnus> guess that's just me
18:26:20 <Riastradh> Emacs, for a Lisp environment, is quite terrible compared with Interlisp-D or Genera.  It is, unfortunately, the only one that is still in wide use.
18:26:41 <Philippa> ultramagnus: the way I see it, RAD tends to get in the way when I try to design UIs - it's crap at dealing with dynamic stuff
18:27:08 <Philippa> and if you're not dealing with UIs at all, all this wizardry is just covering up the fact the language sucks
18:27:21 <Philippa> (OK, language and/or libs - MFC anyone? *vomits*)
18:28:45 <Philippa> now, refactoring tools can be good...
18:29:22 <ultramagnus> yeah, I love refactoring in VS2005
18:29:27 <ultramagnus> and Eclipse
18:29:38 <Darius> On that topic, Hare a refactoring tool for Haskell, works with vim and emacs.
18:29:52 <Riastradh> Philippa, one could equally well argue that wizardry of language syntax complication to make it somewhat more efficient to type is just covering up the lack of any decent development environment.
18:30:20 <Riastradh> (E.g., all the operator, indentation, &c. crud in Haskell.
18:30:20 <Philippa> Riastradh: if we're only talking syntax, sure. Usually the tools cover up semantic issues with either the language or the associated libraries
18:30:21 <Riastradh> )
18:30:44 <Riastradh> One should starve oneself of neither a good language nor a good IDE.
18:30:46 <Philippa> I'm inclined to say that crud's about as good as it gets if you want a textual representation at all
18:31:18 <Philippa> yeah, my value of "good IDE" appears to differ from ultramagnus' though
18:31:43 <monochrom> I find these values in an IDE: organizing my projects and files; push-button dependency resolution and build; testing and tracing; syntax aid; showing various summaries of programs; refactoring.
18:32:24 <ultramagnus> monochrom: not completion?
18:32:28 <Philippa> monochrom: I haven't had sufficient access to refactoring, I get most of the rest for Haskell with a half-decent text editor and GHC(i)
18:32:32 <ultramagnus> and type recognition
18:32:41 <Riastradh> ultramagnus, 'completion' falls under syntax aid.
18:32:42 <monochrom> those are under my "syntax aid".
18:32:44 <ultramagnus> I also value pre-compilation warnings/errors
18:32:56 <ultramagnus> ok
18:33:02 <Philippa> yes, those're a nice aspect of VS.net
18:33:10 <monochrom> yes, I forgot "bringing you to parse error points".
18:33:26 <Philippa> and I wouldn't mind having them - but they wouldn't be enough to cause me to move to C#, say, because I get to bang :r often enough anyway
18:33:45 <sam_> what does afp stand for
18:33:53 <Philippa> depends
18:34:01 <ultramagnus> Philippa: you know, C# is getting closures now in 2.0 ;)
18:34:06 <Philippa> if you're flicking through logs and you've caught me talking about an "afp", odds are it's alt.fan.pratchett
18:34:13 <Philippa> good, now when's it getting type inference?
18:34:16 <monochrom> I carefully exclude these from the values in an IDE: design, for-loop code templates.  If you need those, it means the language underneath is inadequate.
18:34:20 <Darius> monochrom: vim will take you to compile errors
18:34:22 <Philippa> or multiparm typeclasses with fundeps?
18:34:35 <Philippa> monochrom: bingo
18:34:37 <sam_> Philippa: It's one of your interests
18:34:48 <ultramagnus> Philippa: your speech is garbled, please revies your encoding ;)
18:34:49 <Philippa> ah, you're flicking through my LJ then...
18:35:04 <ultramagnus> +spelling
18:35:20 <Philippa> ultramagnus: you may not have heard of these features, I have
18:36:21 <Philippa> suffice to say that it'll take more than closures to sell me on C#
18:37:05 <ultramagnus> Philippa: hmm, you're a female and this fanatic about coding?
18:37:57 <Philippa> yes. If that bothers you, wait 'til you hear me talking about sex...
18:38:03 <ultramagnus> I'm just surprised
18:39:13 <ultramagnus> never met any language fangirls :)
18:39:14 <sam_> yea, I saw friend Ahruman (who I've talked to on a different channel) and saw he listed afp as an interest too, so what is it?
18:39:24 <Philippa> that surprise (and the frequently subsequent drooling) is one reason you don't hear so much about us
18:39:34 <monochrom> The values I have identified are universal to all executable languages; no matter how good a language is, you still need those aids (e.g., because it is executable you want tracing and testing; because it is intended for large projects you need aid in organization).  But only poorly thought-out languages need for-loop templates, and only poorly thought out OOP languages need a class design tool (an architecture-level design tool is necessary 
18:39:35 <monochrom> but please, if you need a tool at the class level, there is obviously a problem).
18:39:44 <Philippa> I'm not really a Haskell fangirl, just a fangirl of many of the features I find in it that I don't see elsewhere
18:40:10 <Philippa> monochrom: I'm tempted to say Haskell has little use for an architecture design tool - just mock it up in actual haskell code
18:40:52 <Darius> Philippa: But that's true of everything, I'm not really a Bad Religion fanboy, just a fan of their lyrics and harmonies.  If I consistently find better ones somewhere else then that band will become my favorite.
18:40:58 <Philippa> sam: it's a newsgroup for fans of terry pratchett. Oh, and a large community of geeks and perverts (er, the last part is just empirical tendency, honest...)
18:41:33 <Philippa> Darius: some people are fanboys/girls to that extent though, especially if the new thing's significantly different
18:43:29 <ultramagnus> heh heh
18:44:35 <Darius> Philippa: I doubt few people like anything as complicated as a language atomically.
18:45:05 <Philippa> no, but you see a lot who can't handle anything that looks too much unlike C, say
18:45:25 <Darius> Philippa: So?  Then they like C-style syntax.
18:46:29 <Darius> Philippa: And presumably there is some (possibly misgrounded) reason why the like C and dislike the languages that are different from it, not just because "it's not C".
18:46:57 <ultramagnus> I also value verbose languages and libs.. using lots of natural language for everything
18:46:59 <monochrom> I think it is beyond "like" if it is "can't handle others"
18:48:23 <ultramagnus> Lisp fanatics seem to be completely ignorant to the fact that natural language code is more readable
18:48:44 <ultramagnus> (caaar (cons (...)))
18:48:50 <Darius> ultramagnus: Lisp fanatics would say the exact same thing with s-expression replacing natural language.
18:49:00 <monochrom> you mean like "multiply x by 5 to y"?
18:49:17 <Darius> ultramagnus: Also no language has syntax anything like natural language.
18:49:34 <sam_> thank god
18:50:11 <ultramagnus> Darius: what's an s-expression?
18:50:31 <Darius> ultramagnus: Roughly, those things with all the parens in Lispy languages.
18:50:47 <monochrom> "multiply x by 5 to y" is a cobol example.  the closest to natural languages in programming history.  the laughstock of all programmers ever since.  sorry but any natural language attempt is going to be a joke, and it is not just a few lisp fanatics.
18:51:17 <Philippa> code is maths, deal
18:51:31 <ultramagnus> maybe it's not about natural language but rather about proper naming.. I dunno
18:51:37 <Riastradh> ultramagnus, what is more readable to you is merely due to familiarity.
18:51:41 <monochrom> Yes, proper naming is good.
18:51:46 <Philippa> what code /can/ do is make an effort to be easy for the human brain to break into chunks appropriately
18:51:52 <Darius> ultramagnus: You can properly name things in Lisp just fine.
18:51:56 <Riastradh> First of all, CONS, CAR, & CDR, are very special, fundamental cases.
18:52:05 <Riastradh> (Likewise with LAMBDA.)
18:52:05 <Philippa> and renamable
18:52:38 <Philippa> and excuse me if I find \s readable in the context of a language built on functions
18:52:54 * sam_ thinks Philippa sounds like a EWD Disciple :)
18:53:11 <ultramagnus> it would be nice to see some real readability research
18:53:47 <monochrom> Naw, a true EWD disciple would say "you should choose meaningless names"
18:53:53 <ultramagnus> have a couple of hundred people write equivalent programs in different languages, and then have them look at them 5 years later
18:54:40 <Darius> ultramagnus: I think some research has been done that supported (the fairly intuitively true) statement, that languages that are more difficult for a computer to parse are more difficult for a human to parse.
18:55:02 <Darius> ultramagnus: On that scale, Lisp and concatenative languages are the simplest languages to parse.
18:55:13 <Riastradh> ultramagnus, I can understand Maclisp code written during the '70s, even though I've never written any myself or even used Common Lisp much.
18:55:26 <Riastradh> (OK, not Greenblatt's code, but that's a rather extreme case.)
18:55:55 <ultramagnus> Darius: yeah that could be true
18:56:00 <Philippa> sam_: EWD?
18:56:19 <sam_> Edsger Wybe Dijkstra
18:56:27 <ski> Edsger W Dijkstra
18:56:46 <Philippa> ah. I'm more dyke than Dijkstra.
18:57:35 <sam_> hehe, if you don't know of the EWD archive it sounds like you would be interested 
18:57:50 * Philippa likes \ because the "meaningful" alternatives take up too much space and thus mental bandwidth when reading
18:58:49 * Darius would prefer Haskell using '.' instead of '->' in lambda, though now it would be a parse clash.
18:58:57 <monochrom> If I write a non-toy program, I probably have some trouble re-constructing its purpose five years later.  If I also write down its purpose, I will have no problem with that five years later, but then I may have problem re-constructing why it works.  If I also write down why it works, I have a perfectly readable program.  It thus seems to me you need a specification and reasoning language to augment your programming language.
19:00:28 <sam_> maths!
19:00:38 <Darius> monochrom: In many cases, you'd likely need something to remind you of how your "specification" meets the specification.
19:01:00 <Darius> monochrom: One could view programming languages as specification languages (they are in a sense), so it's the same problem.
19:01:36 <monochrom> a programming language is necessarily a proper sublanguage of a specification language.
19:01:48 <sam_> yea read E C R Hehner's book it's online now
19:02:04 <Darius> sam_: What's it about?
19:02:20 <monochrom> a programming language is an executable fragment of a good specification language.  A good specification language should let you write down unexecutable things, just to be complete.
19:02:28 <sam_> formal derivation of imperative programs
19:02:59 <monochrom> My supervisor has more fans than I know.
19:03:57 <sam_> Carroll Morgan's book is online too
19:04:19 <Darius> monochrom: If the specification language isn't machine-checkable then it's little better than comments, if it is then it's either static typing (actually that's a rather weak "either") or you'll likely need something to tell you why your proofs work.
19:04:25 <sam_> monochrom, your supervisor is?
19:04:43 <Darius> sam_: I'm sure I could just google for these, but links?
19:04:46 <Philippa> IOW, either it's a programming language or it's a programming language with comments
19:04:48 <monochrom> My supervisor is Hehner.
19:04:54 <sam_> cool\
19:05:33 <sam_> Hehner's http://www.cs.toronto.edu/~hehner/aPToP
19:05:48 <monochrom> Darius: Yes. In "why the program works" I include enough sketch for a proof checker.
19:06:14 <sam_> Morgan's : http://web.comlab.ox.ac.uk/oucl/publications/books/PfS/
19:06:14 <Philippa> = programming language + commented assumptions again, surely?
19:06:37 <Darius> monochrom: I covered that case and the result is what me and Philippa are saying.
19:07:49 <Darius> So while having a machine checkable proof of correctness would be very nice, it doesn't solve the understanding problem.
19:08:19 * Philippa wonders if this'd be a good time to remind everybody just why she likes monads, arrows et al so much?
19:08:32 <Philippa> (you get to build the proof-checking semantics in when you need 'em)
19:08:45 <monochrom> Orthogonally, a programming language is probably deterministic or very close to deterministic, whereas a specification language must allow arbitrary non-determinism.  For example it is impossible to express "find an occurence of x in array A and I don't care which" in C, but you need to express that in a specification language.
19:09:21 <Darius> monochrom: That = very high level language.
19:09:49 <Philippa> monochrom: create equivalents of forall and exists that happen to have the value of arbitrary specified underneath for the case where you execute them
19:10:07 <Darius> monochrom: Essentially, what you are asking for is a programming language so you can always understand the source.
19:10:18 <Darius> s/so/so nice/
19:10:22 <ultramagnus> how well can data structures be implemented in declarative languages?
19:10:24 * sam_ says just read the book man
19:10:56 <monochrom> Yes Darius, we started with "readable" didn't we?
19:11:01 <Philippa> ultramagnus: there're one or two (those that really /require/ arrays) that're a bit iffy to implement without invoking an array-like facility somehow, otherwise all is easy
19:11:37 <Philippa> which is why you want a really damn /good/ programming language. Welcome to #haskell :-)
19:11:37 <Darius> monochrom: My point is that your specification language is just a very nice programming language.
19:11:45 <Philippa> (Haskell's not there yet, but hey)
19:12:43 <Darius> monochrom: Also, that that would be a very difficult task to make a language nice enough that would be understood from source with no comments.
19:12:56 <Philippa> daft point - really you want code that works under two different sets of semantics, the 'executable' and 'checkable' semantics - is anybody else thinking of monads/arrows/related beasts where two or more conform to the same interface?
19:13:50 <Philippa> with 'just pick one' being implemented as appropriate for each
19:14:04 <ultramagnus> are there any commercial software projects using Haskell?
19:14:18 <Darius> www.galiosconnections.com
19:14:24 * sam_ says READ THE BOOK
19:14:31 <sam_> ;)
19:14:48 <ultramagnus> hm :)
19:14:55 <Philippa> I think you missed a "fucking" out there
19:15:05 <sam_> oh yeah, oops
19:15:19 <Darius> www.aetion.com
19:15:36 <monochrom> Philippa: See Hoare & He, Unifying Theories of Programming, in which they say a programming language ought to come with an operational semantics, a denotational semantics, and an axiomatic (design-oriented) semantics.  Of course they also say you need a specification language as a proper superlanguage too.
19:16:29 <ultramagnus> are declarative languages specification languages?
19:16:34 <sam_> so that you can derive an implementable and then more efficient program by calculation
19:17:17 <Philippa> monochrom: do they succeed in motivating the point of a proper superlanguage that isn't just "add comments in whatever lang helps"?
19:17:36 <Darius> ultramagnus: If you've followed the conversation you'd note, -all- programming languages are specification languages.
19:17:44 <Philippa> ultramagnus: all programming languages're specification languages for suitably twisted values of specification that often over-specify
19:17:58 <sam_> I don't think 'specification language' has a definition some languages are just more suitable for specifying with than others
19:18:08 <monochrom> I don't know your metric of "success".  I am convinced by them; I have no way to tell whether you will be.
19:18:49 <ultramagnus> oh
19:18:53 <Philippa> though usually it refers to languages created specifically for the purpose, as it were. They tend to include specific mechanisms for not specifying things - eg you can say "pick one" without saying how
19:19:33 <ultramagnus> hmm but..
19:19:45 <ultramagnus> declarative languages rather describe the problem
19:19:56 <ultramagnus> doesn't sound very specifying to me
19:20:11 <Philippa> you've not played with many of them for long, have you?
19:20:12 <sam_> sounds exactly specifying to me
19:20:29 <Philippa> depends what it is you want to specify
19:20:30 <ultramagnus> sam_: as in solution specifying
19:20:42 <ultramagnus> hmm
19:20:55 <Philippa> ah. See, when coupled with operational semantics a declarative language corresponds just as well to "do it this way" as anything else
19:21:58 <ultramagnus> hmm :)
19:22:02 <Philippa> it's perfectly possible to declare that the solution must do x before y, say
19:22:03 <ultramagnus> heh, this channel is funny
19:22:04 <sam_> I'm not sure what you mean
19:22:37 <Philippa> you don't say "x then y", you just create a situation with no other possible solutions
19:22:52 <ultramagnus> hmm.. yeah that's true I guess
19:23:13 <Philippa> given a suitably stupid IO monad I can "declare" asm code :-)
19:23:20 <ultramagnus> I've yet to visit a more C-Sci-ish channel :)
19:24:06 <ultramagnus> what's a monad?
19:24:13 <Philippa> actually, it'd want to be an arrow, on account of not being a member of ArrowApply unless you're feeling masochistic and're coding on an architecture where you can get away with it
19:24:29 <Philippa> er. Normally I'd give an answer and it might even be a good one. Today I'm feeling braindead - anybody else want to explain?
19:24:37 <ski> Philippa : don't scare him away :)
19:24:50 <Philippa> oh, if I wanted to do that I'd be talking about whips and strap-ons
19:24:54 <sam_> here's a spec: determine the number x such that x*x = y for given y
19:25:16 <monochrom> I am not sure that the "comment vs specification" point worths contention.  Probably what I call a specification you call a comment.  There are of course the questions of "should it be human-readable" and also "should it be machine-readable", but I think we can all settle to a suitable compromise.
19:25:18 <sam_> is that what you mean by solution specification?
19:25:40 <Philippa> sam_: to me that fails to specify a solution
19:25:51 <ultramagnus> sam_: to me that's a problem spec
19:26:02 <sam_> ok
19:26:25 <Philippa> monochrom: I have no objection to the comments being highly mathematical and looking like the executable code + a few extra constructs
19:26:40 <sam_> ok when I say specification I mean, in your terms, problem specification
19:27:17 <sam_> Philippa, huh?
19:27:21 <Philippa> sam_: sooner or later you say "solve the problem of executing this sequence of instructions", that's all the "it's all code" argument comes down to
19:27:40 <monochrom> Yeah, read the book, sam_. :D
19:28:07 <Philippa> monochrom: I do feel that there's often little need for tool support at that point, as what tools you can add become part of the stuff you can still express in code
19:28:21 <Philippa> (which means the best tool is a good library)
19:28:52 <sam_> later you'll say that you get there by calculation
19:29:23 <Darius> monochrom: The real issue is that any specification would either have to be taken on faith or would have to be taken on faith.
19:29:28 <Philippa> sam_: well yeah, cf comment about many programming languages leading to overspecification
19:30:00 <Philippa> it comes down to "pick a solution, any solution, I've stopped caring" - the existential case, as it were
19:30:47 <sam_> as long as any will do
19:30:57 <monochrom> Darius: I don't understand.
19:31:01 <Philippa> if not, you better specify which ones will
19:31:10 <sam_> I agree
19:31:18 <sam_> what's your point again/
19:31:36 <Philippa> oh, we've been pretty much agreeing the whole time
19:31:42 <sam_> oh good
19:32:04 <Philippa> it's just I've had to do some minor translation for ultramagnus' benefit which may've caused confusion for everybody else :-)
19:32:18 <ultramagnus> I ceased understanding the discussion as monads came into the picture :)
19:33:27 <Philippa> ultramagnus: monads are roughly what you get when you take another language, embed haskell into that language, and then embed the language back into haskell. Or at least, if you do it the sane way.
19:33:31 <ski> one couls perhaps say that monads is a kind of structuring pattern
19:33:36 <Darius> Either the specification is machine checkable in which case it is likely too complicated to actually trust implicitly to specify the intended specification or it's not and you can't trust that the code actually follows the specification.
19:33:58 <ultramagnus> hmmm
19:34:07 <ski> one use for monads in haskell is to do IO
19:34:28 <Philippa> ski: IO is always a really, really bad example of a monad, on account of it being one that can't actually be fully expressed in Haskell
19:35:09 <ski> Philippa : yes
19:35:19 <Darius> monochrom: Essentially, most programming is just too complicated to be able to come back to and easily understand.
19:35:33 <Philippa> aaanyway, you have this type, OurMonad a, which is the type of computations in the language OurMonad that have a result of type a
19:35:38 <monochrom> If I have a very good prover, I can state my specification in the terms at the level I and my colleagues like to use, and the prover will figure out its connection with the program.
19:35:54 <Philippa> and you have a function return foo, which turns a haskell function of type a into an OurMonad program of type OurMonad a
19:36:02 <sam__> damn internet connection
19:36:06 <monochrom> But then I'm being hypothetical.
19:36:07 <ski> 'OurMonad a' represents something that when run can produce values of type 'a'
19:36:09 <Darius> monochrom: Yes, and if you have a very good programming language you can just state the program at the level you like to use.
19:36:14 <ultramagnus> Master-B: hi
19:36:23 <Master-B> ultramagnus: hello
19:36:35 <Darius> monochrom: That's the issue; I'm saying it's unlikely that there will ever be a programming/specification language "nice enough"
19:36:36 <Philippa> and you have another function >>= which you use to connect OurMonad programs to each other so that the one on the right sees the result of the one on the left
19:37:13 <ultramagnus> hah
19:37:18 <Philippa> Darius: depends on what you're looking to do - if you can find ways to avoid having to solve the full halting problem, for example, things get easier
19:37:26 <ultramagnus> this Monad thing seems quite the evil
19:37:42 <ultramagnus> also I fail to understand the purpose
19:37:45 <ski> Philippa : i think we need some more explicit example(s)
19:37:51 <Philippa> ultramagnus: that's it. Really. Well, OK, there're usually other values of type OurMonad a that do other things - in the case of the IO monad, they're things like reading from files or writing to them
19:38:12 <ski> getChar has type 'IO Char'
19:38:20 <ski> @type getChar
19:38:23 <Philippa> ultramagnus: the language OurMonad represents can be really quite different. Working with the List monad can feel rather like Prolog, for example
19:38:28 <Cale> ultramagnus: monads are actually a pretty simple thing to understand. Have you read MonadsAsContainers? That article describes my way to think about them.
19:38:35 <ski> (bah. lambdabot isn't here)
19:38:50 <Philippa> in the case of IO, it's hooked into a bunch of stuff for doing IO in a way that doesn't fundamentally break Haskell
19:39:03 <ultramagnus> Cale: no, I don't even know Haskell basics
19:39:12 <Philippa> so you have a mixture of "do this bit of IO" and "evaluate this bit of haskell" programs
19:39:23 <ski> http://www.haskell.org/hawiki/MonadsAsContainers  (also http://www.haskell.org/hawiki/UsingMonads)
19:39:27 <Philippa> ultramagnus: you may wish to RTFM, or at least a tutorial
19:39:38 <Philippa> if you're used to C# et al, this may be a bit of a departure for you
19:39:57 <ultramagnus> Philippa: yeah yeah.. I just joined this channel to get a feeling for what Haskell really is :)
19:40:04 <ski> hehe
19:40:12 <Cale> ultramagnus: oh, well, monads are just an abstraction of containers if you look at them one way. From another perspective, they're an abstraction of computation, but I find that a bit trickier to think about.
19:40:12 <ultramagnus> then you start this insane discussion about spec languages and monads :D
19:40:13 <Philippa> however, my personal favourite use of monads is a parsing library based on one where you write code that looks suspiciously like annotated BNF. That code's a parser there and then, completely legit haskell
19:40:18 <Darius> Philippa: Obviously, if the program is "easy to understand" it will be easy to understand.
19:40:40 <Philippa> Darius: and if it's inherantly not easy to understand, that's hardly the language's fault
19:40:51 <ultramagnus> Cale: ok
19:40:59 <Philippa> I think one of us is arguing "you can't get it all" while the other's arguing "you can probably get most of it" though
19:41:17 <monochrom> Darius's concern is real, and I know how to answer that in principle --- in a few centuries --- but at present we are still working on it and we have no large-scale example to demonstrate.
19:41:47 <Philippa> monochrom: I have a good idea of how to answer it in principle, and it's how I intend to get most of it in practice too
19:41:54 <monochrom> It is also a mixture of many different concerns and problems.
19:42:27 <Philippa> true, at best all I really have an idea of is the framework
19:42:30 <Cale> ultramagnus: so you might have containers where pulling values out causes side effects to occur -- like boxes which do some computation in order to return a value
19:42:53 <Darius> Philippa: Yes, it basically does come down to that, I sort of lean towards "you can probably get most of it", but it isn't the case currently and the propects do look somewhat dim.
19:42:55 <Philippa> Cale: I'll give you this much, I /do/ like the "lots of black boxes" explanation when you start talking about arrows
19:43:06 <Darius> But the field of programming is young.
19:43:36 <Philippa> Darius: one of my "for the future" projects (which may prove difficult) is to keep track in the type system of which expressions involve fix somewhere
19:43:51 <ultramagnus> Cale: oh, so it's like a reverse class? :)
19:44:05 <Philippa> ultramagnus: in many ways, yes. Ever thought of class design as language design?
19:44:16 <Darius> Philippa: Yes, there are and were quite a few discussions about treating non-termination as an effect and having a NonTermination monad.
19:44:16 <ultramagnus> data modifications causes code to be run, instead of code run making modifications
19:44:33 <ultramagnus> Philippa: no
19:44:43 <Philippa> Darius: I figure the fun comes when it's not just a monad but a monad transformer
19:45:00 <Darius> Philippa: That's what I implicitly meant.
19:45:13 <Philippa> well yeah
19:45:40 <Darius> The real issue is whether it's overly distracting.
19:45:46 <ultramagnus> hm
19:45:53 <Darius> or limiting.
19:46:02 <ultramagnus> this kinda feels like STL streams :)
19:46:11 <monochrom> I am writing a simple BibTeX parser using Haskell and Parsec.
19:46:12 <ultramagnus> insertion and extraction operators
19:46:14 <Philippa> ultramagnus: STL streams are a special case
19:46:26 <Philippa> monochrom: parsec's sweet, isn't it?
19:46:30 <monochrom> YES!
19:46:32 <ultramagnus> cin >> a;
19:46:52 * sam__ has an embarassing admission, I don't know what cf means
19:46:58 <Darius> Well, Parsec is often a pretty good advertisement for Haskell.
19:47:08 <monochrom> (How would I specify the parser so that I can prove my code against the specification?  I don't dare... :D)
19:47:11 <Philippa> sam: I never remember the expansion, but effectively "compare and contrast with"
19:47:21 <sam__> ah thanks
19:47:29 <Philippa> monochrom: I suspect your spec will be the grammar
19:47:46 <Darius> monochrom: You could have a grammar and check that the parsec combinator implement it, but it'd be easier to specify the grammar with the parsec combinators ;)
19:47:47 <Philippa> which works if you're comparing against a few other parsers for the same grammar
19:48:11 <monochrom> A disciple of EWD would [pretend to] know what cf means, since EWD says "(cf stuff)" all the time. :D
19:48:21 <sam__> shame
19:48:34 * Philippa is suddenly left thinking that Flippi's new pluggable parsing setup would be an interesting one to verify
19:49:07 <ski> sam__ : i *think* cf. is latin abbreviation for "confere" which means "compare (to)"
19:49:36 <Philippa> I keep a map of parsers in Parsec's state, essentially a list of productions that're valid at this stage. Parsers that know about each other can remove each other, so eg the parser for bold can say "anything valid at this stage but another bold bit"
19:49:51 <sam__> cheers ski
19:51:03 <monochrom> You are very evil.
19:51:17 <Philippa> monochrom: me?
19:51:20 <monochrom> Yes.
19:51:36 <Philippa> Usually the word people use is "sick", though maybe that's an afp thing
19:51:40 <monochrom> Ah, damn sam_'s flaky internet connection.
19:51:52 <sam__> there I go
19:51:56 <Philippa> but yeah, I figured it was a suitable solution to a nasty problem
19:52:08 <Philippa> and I like the idea of making flippi customisable as all hell
19:52:40 <monochrom> evil is good
19:52:50 <Philippa> that's what I tell my bottoms :-)
19:52:50 <monochrom> freedom is slavery
19:53:05 <monochrom> programming is proving
19:54:30 * Darius isn't sure he wants to ask but...
19:54:33 <Darius> Bottoms?
19:56:17 <Darius> Philippa: And you are providing a Turing-complete extension language to Flippi then?
19:56:38 <sam__> monochrom, what's the difference between a lattice and a total order, only perhaps a<a?
19:56:46 <sam__> brb
19:57:13 <monochrom> in a lattice you need not have (forall a,b. a<=b or a>=b)
19:58:14 <ultramagnus> is monad an actual english word?
19:58:36 <monochrom> The powerset of {1,2} is a lattice, using subset for partial order.  This is not a total order.  not({1}<={2}), not({2}<={1}).
19:58:50 <Darius> Yes
19:59:05 <Philippa> Darius: Bottoms ~= subs
19:59:11 <Philippa> and the extension language is, er, Haskell
19:59:11 <Darius> It has a philosophical meaning and at least one mathematical meaning.
19:59:14 <Darius> @Wn monad
19:59:38 <Philippa> one of the mathematical meanings being pretty much exactly what the haskell meaning is as well, assuming you know enough to understand how they relate
19:59:41 <ultramagnus> um
19:59:49 <Darius> Philippa: The isomorphism hasn't really helped me, and dynamically?
20:00:11 * Darius cries for lambdabot
20:00:16 <ski> functional programmers have borrowed the word 'monad' from Category Theory (a kind of math). the programming monads are a kind of Cat. Theory monads.  Cat. Theorists pilfered the work monad from philosophy (Liebniz), in which it means a completely different thing
20:00:19 <sam__> so whats the infima of {{1},{2}}
20:00:25 <Philippa> it's a CGI, feel free to execute via runhugs/runghc, a mod_haskell or a web server based around hs_plugins
20:00:47 <monochrom> inf {{1},{2}} = {}
20:01:02 <monochrom> sup is {1,2}
20:01:05 <Philippa> ski: in particular, the programming ones are a kind that follows on clearly from the restrictions "it's a monad" and "it's expressible in a programming language"
20:01:43 <ski> yes, possibly
20:02:14 <Darius> Depending on which ones you consider "the programming ones" not really.
20:02:27 <Darius> Close though.
20:03:23 <sam__> damn, dogs in, out, in, out... whats the suprema then?
20:03:54 <sam__> oh you answered that
20:04:07 <Philippa> Darius: the idea of Flippi's plugin system is to make it such that you can alter the hell out of it without frigging with anything 'core', and so that you can bundle up bunches of changes into a single value so that a non-coder admin can just dump "import Foo" and "foo," into appropriate places in a config file
20:04:14 <sam__> but {1,2} isn't in {{1},{2}}
20:04:50 <monochrom> {1,2} is in { {}, {1}, {2}, {1,2} } = powerset of {1,2}.
20:05:04 <monochrom> {} isn't in {{1},{2}} either.
20:05:10 <sam__> but doesn't every subset need a sup and inf?
20:05:17 <monochrom> That's the joy of non-total lattices.
20:05:53 <monochrom> Every finite subset needs a sup and an inf.  sup {{1},{2}} = {1,2}.  inf {{1},{2}} = {}.  All is well.
20:07:21 <sam__> ok "a complete lattice is a poset (L,<=) in which every subset of L has an inf and sup" "every finite lattice is complete"?
20:07:45 <sam__> and shouldn't that be 'non-empty subset'?
20:08:02 <monochrom> Draw a large diamond shape on paper.  (A square, oriented so that vertices are on left, right, top, bottom.)  Mark {} at the bottom vertice, {1} left, {2} right, {1,2} top.  All questions of this lattice can now be answered.
20:08:18 <monochrom> inf {} = top, sup {} = bot
20:08:39 <monochrom> every finite lattice is complete.
20:08:47 <ultramagnus> need.. sleep.. c-sci theory.. making.. head.. explode
20:10:12 * ski showed some small concrete examples of list,io,parsing- monads for ultramagnus and tried to explain roughly what "pumping" a monadic value means in each case
20:10:47 <monochrom> Don't be too hard on an IDE freak, err, I mean a real-world programmer. :D
20:10:50 <Philippa> did you get anywhere, or did you just break his brain? I'm not sure he knows any FP
20:11:31 <ski> he did come up with some (imo) weird analogies for trying to understand
20:11:47 <ski> such as object-stream  (pumping out objects in list monad)
20:12:30 <ski> anyways, he said that he mayhaps should try to study some haskell ;)
20:13:13 <ski> Philippa : so, i hope he'll come back
20:14:01 <ski> monochrom : :-P
20:14:35 <sam__> oh I get it now, thanks for the help
20:14:56 <sam__> there's an earlier mistake in this text confusing me
20:15:12 <monochrom> O_o
20:15:22 <sam__> exactly
20:16:06 <monochrom> haha ok
20:16:25 <sam__> monochrom, what's your (working) thesis, anything interesting ;) 
20:17:59 <monochrom> I am just a bit surprised that a text has a mistake.  I suppose it is no big deal.
20:18:19 <sam__> lots of texts have mistakes
20:19:05 <sam__> hence all those errata files
20:19:23 <sam__> ?
20:20:22 <monochrom> Yes. I am familiar with the case that lots of calculus texts and even more C books have blatant mistakes.  I am not familiar with the case that a lattice theory book has a mistake; then again I can't assume you are reading a lattice theory book; it may as well be a 9th-rank discrete math book.
20:21:31 <sam__> it is in fact more coursenotes form local uni in cheapass textbook form :)
20:22:23 <monochrom> Ah!  All local uni book-wannabe's are all wrong.
20:22:38 <sam__> indeed :)
20:22:59 <sam__> I suppose I should have learn't by now
20:23:05 <sam__> learnt
20:25:05 <sam__> I'll take the answer to the thesis question as a no then ;)
20:30:31 <sam__> "never cut open the body of appendicitis patients because it would be tough to doctors" I like it very Dijkstraesque
20:30:43 <toomasr> i have problem, tmp <- getLine, let tmpNum = read tmp, i get an error "Ambiguous type variable `a' in the top-level contraint: `Read a' arsigin from  use of `read' at filename:line
20:30:55 <toomasr> *a problem
20:31:05 <toomasr> i can't figure out from the error msg what i'm doing wrong
20:31:14 <toomasr> maybe somebody can shed some light
20:33:57 <Darius> read is often ambiguous.  The problem is that it can't figure out what type to read since numbers are overloaded.
20:34:15 <Darius> toomasr: You can add a type annotation such as, read tmp :: Int, to handle it.
20:34:31 <ski> you could use "let tmpNum = read tmp :: Int" if you e.g. want to read an Int
20:34:51 <monochrom> Damn, I've also got a fan now.
20:34:51 <toomasr> yeah, i wanted to read int, thx
20:35:14 <toomasr> but what does "numbers are overloaded" mean?
20:35:31 <toomasr> that if it is a number it can't figure out if i want an int or a float?
20:35:35 <ski> monochrom : huh ?
20:35:44 <ski> right
20:36:02 <monochrom> sam__ quoted a sentence from my slashdot journal
20:36:04 <sam__> monochrom, can I have your autograph?
20:36:10 <monochrom> Hahah
20:36:13 <ski> so you could either constrain it by e.g. using a function that only works on, say, Int
20:36:27 <Darius> toomasr: It is unlikely that you use a function that requires specifically one of those types at any point.
20:36:36 * Philippa is inclined to say that one should annotate all instances of read
20:36:42 <sam__> It's too damn hot to do real work here
20:36:42 <ski> toomasr : or you could explicitely say  "theNumber :: Int" somewhere
20:36:51 * Darius is more or less with Philippa.
20:37:07 <toomasr> very weird, i'm doing exercises from a haskell tutorial, and in one example the let foo = read bar just worked, and then it wanted an int too, i'll probably just have to keep reading :)
20:37:14 <Darius> sam_: Where's "here" btw?
20:37:24 <sam__> New Zealand
20:37:29 <Philippa> it's too damn /late/ to do real work here, but hey
20:37:46 <Philippa> I should go to sleep soon, or I'll be too dopey for dinner tomorrow
20:38:10 <monochrom> New Zealand is very cool.  Err, hot.
20:38:16 <Darius> sam__: Ah.  This is a weird question and unlikely (for good reasons) to get an objective answer, but how do you like New Zealand?
20:38:58 <ski> toomasr : probably either something else in that example constrained foo to some specific number type, or it defaulted to one
20:39:28 <toomasr> yeah
20:39:58 <sam__> hard to say, some aspects I like, some aspects not so much, overall I'd say I like it pretty much
20:39:58 <Philippa> defaulting being a really damn good reason you should always specify - you're bothered about just what you think you're parsing too
20:41:11 <sam__> then I look at the U.S. as portrayed on tv and think hey nz aint bad ;)
20:42:04 <sam__> no different than most places I guess
20:42:20 <sam__> well rich western ones
20:46:07 <toomasr> i've been getting "the last statement in a 'do' construct must be an expression", my last statement is return 4, so this is not an expression?
20:46:30 <Darius> toomasr: That most likely means a layout error.
20:46:39 <monochrom> I suspect it is an effect of some other problem.  Yeah, for example layout.
20:46:39 <toomasr> oh, okay
20:47:17 <Darius> toomasr: Do you use tabs?
20:48:39 <toomasr> nope, i expand them to spaces
20:48:52 <Darius> Good, a right thinking programmer.
20:49:30 <toomasr> i'm for tabs! :)
20:49:48 <toomasr> when i have to haskell a bit, i don't like that i have to expand them
20:50:42 <monochrom> An ideal editor for haskell would nullify the difference between tab and space.
20:51:08 <Darius> Well, if you interpret tabs as 8 spaces, you don't have to expand them, if you don't then you are part of why tabs are evil.
20:51:33 <Darius> toomasr: Alternatively, you could just not use layout, it's not required in Haskell as it is in Python (unless they've changed that).
20:51:53 <monochrom> It would be like particle-wave duality.  If you're looking for tab-like behaviour, you'll find it.  If you're looking for space-like behaviour, you'll find it.
20:52:12 <toomasr> naah, i'll just learn the damn layout, i don't want my haskell to have braces laying around
20:52:27 <Darius> monochrom: Most editors worth using should be configurable to get that behaviour.
20:54:28 <Darius> monochrom: Well, um, similar less psychic behavior.
20:55:36 <monochrom> Don't tell me small particles are psychic and they behave according to your wish of seeing them as particles or waves!
20:56:25 <Darius> No but a program knowing whether you are "looking for tab-like behaviour" would require some psychic ability.
20:57:24 <monochrom> You may be right.  Let me think how we can work around that...
20:57:33 <Darius> headjacks.
20:58:20 <ski> maybe small particles are somehow similar to "additive conjunction" in linear logic ?                  :)
20:58:34 <monochrom> The program may learn.  In the first few minutes of use, of course it has no idea.  But after watching the programmer for a while, it may be able to deduce the programmer's fetish.
20:59:06 <Darius> ski: Linear logic has been applied to quantum programming languages.
20:59:08 <sam__> yuk
20:59:15 <ski> Darius : nice
20:59:37 <Darius> monochrom: And how will it learn exceptions?
20:59:40 <monochrom> Linear Logic Can Change The World!
21:00:10 <sam__> wadler right?
21:00:19 <monochrom> I'll think about it.  But I'm also just wildly fantasizing.
21:00:23 <monochrom> Yes sam__
21:00:24 <Darius> monochrom: Also, I think it's not uncommon for programmers to not like DWIM systems.
21:00:31 * sam__ wins
21:00:43 <monochrom> DWIM = do what I mean ?
21:00:45 <Darius> sam__: Actually, if you had to ask...
21:00:53 <Philippa> if it's DWIM it'd better tell me the language it assumes you're telling it what you mean in
21:01:07 <Darius> monochrom: Do What I Mean, which in practice means Do What I Think You Mean.
21:01:59 <Darius> Philippa: I wonder if some kid whose name I can't remember paper on language bootstrapping might actually have applications there.
21:02:44 <monochrom> Hahahaha, that opens a flood of ideas.  Perhaps when you start a new programming project you need not say what language you're using (not even by filename).  You just type away, and the editor takes a few moments to guess what language it is, and then switches to the suitable syntax aid mode.
21:04:00 <Darius> monochrom: To an extent some editors do something along those lines.
21:05:02 <Darius> monochrom: And of course editors for specific languages always do exactly that.
21:05:09 <monochrom> After half an hour, it may even guess that you're writing a web service in J2EE EJB.  Then a paperclip pops up and says, "you seem to be coding a web service; don't you think Haskell is a better choice?"
21:05:51 <monochrom> and "click here to convert your code to Haskell"
21:06:37 <Darius> monochrom: A slight variation of that is fairly easy to do.  Just have a paper clip pop up after a bit and say "Don't you think Haskell is a better choice?".  The 3.2 version will actually have a Haskell parser that makes sure you aren't actually coding in Haskell first.
21:07:22 <monochrom> We have great ideas for the most annoying editor since Word.
21:08:11 <Darius> monochrom: But it actually gives good advice (?)
21:08:40 <Darius> monochrom: Anything I'm not sure we can beat all the programmers behind the DEBWIM interface of Word.
21:08:57 <monochrom> annoyance is not always bad.  most people find most good advices annoying.
21:09:32 <Darius> "Anything"... how the heck did I write that?
21:09:35 <jesse> or even easier, just  have an editor that makes you do all of the guessing, while it leads on to nothing in the way of what language it wants you to code in, or the tabulation rules, or the caesarian cipher used to scramble what you type into gibberish
21:10:07 <monochrom> I knew what you meant and I replaced that with Anyway.  I have an error correcting modem.
21:10:08 <Darius> jesse: Or even easier, just have an editor that opens Word!
21:11:21 <monochrom> Heh. I do sometimes say "Outlook Express" when someone asks "what's a good newbie editor for haskell/ocaml".  "You can even email your code to yourself so that you can save a copy!"
21:12:55 <Darius> monochrom: But now with darcs you could do that.
21:14:01 <monochrom> Yuck.  All my worst nightmares always come true.
21:18:33 <toomasr> i've lost a link and i'm not able to refind it, i'm sure one of you guys knows it, you could browse different haskell functions on that page, and it showed examples of using the funcions, when checking a funcion it suggested other functions that were similar and so on, like an API reference, it had blueish background and the the texts yellow ones :)
21:19:13 <Darius> ZVON ?
21:20:25 <toomasr> wow, google zvon haskell produced the right one :), thanks a lot
21:20:26 <Darius> http://zvon.org/other/haskell/Outputglobal/index.html
21:21:03 <Darius> toomasr: Or alternatively you could go to haskell.org, click Book and Tutorial, Reference papers, and check the five or so links there.
21:21:46 <toomasr> damn, i checked the docs section of the wiki but thought i was at haskell.org
21:29:56 <toomasr> the docs din't help me much, i'm still having a problem, i have a function, that returns a list of user inputted numbers, getNum, then i'm doing putStrLn ("..."++show((foldr (+) 0 list))), list is list = getNum
21:30:22 <toomasr> but i get an error, couldn't match `[b]' against  'IO [Int]'
21:30:33 <Darius> @wiki UsingIO
21:30:40 <Darius> Damn!
21:30:48 <toomasr> bot is dead!
21:30:58 <toomasr> list = getNum::[Int] doesn't help
21:31:13 <toomasr> then it can't match [Int] to IO [Int]
21:31:36 <Darius> http://www.haskell.org/hawiki/UsingIo,http://www.haskell.org/hawiki/ThatAnnoyingIoType,http://www.haskell.org/hawiki/UsingMonads
21:31:41 <toomasr> but then again, why the hell does it think i have IO [Int] if i use read on userinput:
21:32:11 <toomasr> allright i'll read, althgough the tutorial says we won't discuss monads untill chapter 9 :)
21:32:20 <Darius> What is the context of the code?
21:32:50 <toomasr> what do you mean by context of the code?
21:33:22 <toomasr> http://toomas.dev.struktuur.ee/img/Exercise1.hs
21:35:23 <Darius> getNum is an IO [Int], the ThatAnnoyingIOType (or the Gentle Introduction to Haskell) explain what to do with them.
22:48:31 <Darius> hmm, prolific CS research paper writers should provide RSS feeds.
22:48:48 <shapr> ie. Hudak
22:49:38 <Darius> i.e. Danvy, Okasaki, Simon PJ
22:49:53 <Darius> Hinze, Laemmel, and on and on.
22:50:58 <Darius> Yay!  I was just about to bother you about that.
22:51:17 <Darius> Though now that I think of it, I guess instead of bothering you I could just fire up a lambdabot.
22:51:29 <Darius> It's funny that that has never occurred to me before.
22:52:05 <shapr> I would like to find a way to distribute lambdabot admin
22:54:32 <Darius> You mean have multiple instances of lambdabots running on different machines behaving as one lambdabot?
22:55:06 <shapr> or maybe multiple users on scannedinavian can sudo to the lambdabot account
22:55:14 <shapr> or maybe just fix the stack overflow and it won't crash =)
22:55:24 <Darius> shapr: Ah, those'd work too.
22:55:26 <shapr> or possible an auto-restart of some flavor
22:55:53 <shapr> zope has a separate management process that restart the main process if it crashes
22:56:10 <shapr> lambdabot as a unix service would mean it would automatically restart if the box crashes
22:56:26 <Darius> shapr: Does lambdabot just overflow stack seemingly for no reason or only immediately after someone has sent a command to it?
22:57:05 <Darius> shapr: Also, would you be interested in my list of paper titles?
22:57:58 <shapr> sure
22:59:29 <Darius> Any that sound interesting, which should be damn near all of them, you'll have to google to find, but they should be findable online.
22:59:46 <Darius> Also it's CS and Math and just whatever else I've found interesting.
23:03:53 <shapr> Sounds tasty.
23:05:20 <shapr> That gives me the urge to hack on FLM again, would be nice if the paper list included all your annotations and urls to download the paper with a single click.
23:05:23 <Darius> Jesus, 86 kilo bytes, and it only has the titles and filenames.
23:05:41 <Darius> Well it should be sent.
23:05:53 <Darius> As I say in the email it's a bit out-of-date.
23:06:26 <Darius> Also some of the "titles" are not the titles of a paper because the file doesn't correspond to a paper and there was no real good name.
23:06:52 <Darius> The format is line-based with each line of the form filename.ext#The Title
23:07:11 <Darius> So, just deleting everything upto and including # on each line should give you a list of titles.
23:07:27 <Darius> Merry Christmas ;)
23:07:50 <Darius> shapr: Oh, and if for some reason you want to give it to someone else feel free.
23:09:40 <shapr> thanks :-)
23:10:27 <shapr> oh, I didn't know ungar did GC research.
23:10:40 <shapr> oh, I've been meaning to read the SSA paper.
23:10:59 <Darius> He's fairly well known for it.  What do you know him for mostly? Self?
23:11:03 <shapr> yup
23:11:24 <shapr> When I was learning about Self, I skipped the details on PIC and other cool bits in the Self VM
23:11:31 <Darius> I actually couldn't get some of his GC papers.
23:12:46 <Darius> So, shapr, now you have to write a program that will go through the list find and download the paper and perhaps extract author and abstract information (probably easiest to scrape citeseer when it's there).
23:15:34 <shapr> I'll just finish FLM, that'll suffice.
23:18:02 <shapr> FLM is in essence just a wiki macro like [:WebDoc|url=http://www.scannedinavian.org/~shae/thesis.ps.gz|Generalization of Arrows to Spears:]
23:20:39 <Darius> Hmm, you know, maybe I'll write something that will get, say the first few google hits, and extend the list with URIs.
23:28:08 <Darius> shapr: If there is a paper without a real title or that you can't find tell me if I'm here and I should be able to provide more information, find a link, or simply send you the file.
