00:30:08 <boegel> goodmeurning #haskell
01:14:43 <Itkovian> hello boegel
01:17:31 <musasabi> morning
02:38:48 <derelm> hi, i am currently learning to use list comprehensions. is it possible to combine these expressions, meaning to have a list comprehension inside another?
02:40:11 <xerox> I think so
02:41:02 <xerox> Prelude> [y|y<-[x|x<-[1,2,3]]]
02:41:02 <xerox> [1,2,3]
02:41:16 <xerox> Generators must be lists.
02:41:21 <derelm> hmm
02:41:39 <derelm> ok, i have on generator that spits out factors of a given number
02:41:53 <xerox> Nice one!
02:42:50 <derelm> now i want to write another generator around it, that spits out a list of numbers, where the sum of the factors is the same as the number
02:42:52 <derelm> argh
02:42:57 <derelm> 1+2+3 == 3
02:43:02 <derelm> would be one match
02:43:10 <derelm> grr
02:43:11 <derelm> 6 ;)
02:43:21 <derelm> it's pretty early here in germany *g*
02:43:23 <xerox> yay! :-)
02:44:09 <Lemmih> @seen bringert
02:44:09 <lambdabot> I saw bringert leaving #haskell.se 18 hours 13 minutes 25 seconds ago.
02:44:18 <derelm> but can i use a var from the outer generator in the inner? that would be important as i see it
02:46:18 <xerox> Mmh, what does the outer generator should return exactly?
02:46:57 <derelm> the outer is to return "perfect numbers", numbers whose sum of factors is the same as the number itself (6 as an example)
02:48:13 <derelm> as i already have an generator that creates a list of factors for a given number, that one needs to be the inner generator, while the outer only checks if sum inner == number
02:48:53 <derelm> but i can't see how to translate that in correct haskell syntax :(
02:49:21 <xerox> But what you call the outer generator is just a function that takes a List and a Num and return Num if the sum == the number, isnt it?
02:50:03 <derelm> hmm, i am to return a infinite list of these so called "perfect numbers"
02:50:16 <derelm> so i need a list comprehension / generator for that
02:52:38 <xerox> Can I see the inner one?
02:52:54 <derelm> [y | x <- [n] , y <- [1..x], x `mod` y == 0 ]
02:56:39 <derelm> xerox: hm... it should better be [y | x <- [n] , y <- [1..x-1], x `mod` y == 0 ]
02:58:06 <xerox> mmh.
02:58:26 <xerox> *Foo> perfN 6
02:58:26 <xerox> [1,2,3]
02:58:29 <xerox> is it correct?
02:58:55 <derelm> only that the resulting list is only its factors, not the perfect numbers yet ;)
02:59:04 <derelm> so yes
02:59:20 <xerox> what should perfN 1 return?
02:59:23 <ex_nor> ...
02:59:45 <derelm> hmm ... well nothing i guess
02:59:52 <kristnjov> [1]?
02:59:53 <ex_nor> [y | y <- [1..], sum (factors y) == y]
03:00:00 <ex_nor> shouldn't something like that work...?
03:00:04 <ex_nor> or even
03:00:18 <ex_nor> filter (\x -> x == factors x) [1..]
03:00:29 <derelm> is factors a function defined in the prelude?
03:00:35 <ex_nor> doubt it
03:00:48 <ex_nor> I was just guessing the function name of your function
03:00:52 <derelm> ;)
03:01:08 <derelm> i don't have no function, i am to do this only using list comprehensions
03:01:17 <xerox> [y | y <- [1..], sum [y | x <- [1..] , y <- [1..x-1], x `mod` y == 0 ] == y]
03:01:18 <xerox> ?
03:01:40 <derelm> hmm, doesn't work
03:01:42 <ex_nor> dear lord that's ugly then
03:01:44 <ex_nor> but okay.
03:01:45 <derelm> ;)
03:01:48 <xerox> Yep :|
03:03:19 <derelm> xerox: the inner generator needs to accept a value of the outer ... the inside x<-[1..] is supposed to be the number the outer y<-[1..] creates
03:03:27 <xerox> yep
03:04:14 * boegel is back from squash, where he lost the game from his girlfriend :(
03:04:19 <xerox> [y | y <- [1..], sum [y | x <- [n], y <- [1..x-1], x `mod` y == 0] == n] ?
03:04:31 <xerox> wops!
03:05:03 <ex_nor> ... "x <- [n]" ?
03:05:10 <ex_nor> why not just use n instead of x then =\
03:05:30 <xerox> Wops
03:05:35 <xerox> perfN = [n | n <- [1..], sum [y | x <- [n], y <- [1..x-1], x `mod` y == 0] == n]
03:05:35 <xerox>  
03:06:00 <derelm> xerox: that one works!
03:06:03 <xerox> !!!
03:06:05 <xerox> :-)
03:06:06 <derelm> ;)
03:06:34 <derelm> now i'll take a look at it to see what i did wrong
03:06:39 <derelm> thanks!!
03:07:07 <xerox> Np. Thank ex_nor :-)
03:08:02 <ex_nor> [n | n <- [1..], sum [y |  y <- [1..n-1], n `mod` y == 0] == n] <-- so that also works
03:08:48 <derelm> nice, thanks ex_nor
03:10:12 <xerox> Btw. It's so slow. :-)
03:10:47 <derelm> well, there are only very few of these numbers ;)
03:10:54 <tromp> [bit (p-1) * (bit p)-1 | p <- primes] also works:)
03:11:03 <xerox> [6,28,496,8128, zzzz...
03:11:04 <Itkovian> yeah, there's no reason to have x <- [n] in there ...
03:11:05 <ex_nor> xerox: it's Haskell... as if want for speed =\
03:11:30 <tromp> assuming no odd perfects numbers
03:11:38 <ex_nor> tromp: woah?
03:11:45 <ex_nor> that looks like fun ;)
03:11:46 <derelm> tromp: ?
03:12:00 <xerox> @info bit
03:12:02 <Itkovian> tromp: what's 'bit' supposed to do?
03:12:06 <ex_nor> depending on what "bit" does =P
03:12:12 <tromp> same as 2**i
03:12:17 <xerox> @get-definition bit
03:12:17 <lambdabot> bit not defined
03:12:18 <Itkovian> cool
03:12:18 <boegel> hey wolfman8k 
03:12:38 <tromp> import Data.Bits
03:12:52 <xerox> @index bit
03:12:52 <lambdabot> Data.Bits,Foreign,Bits
03:12:58 <xerox> :-)
03:13:01 <tromp> bit :: Int -> a
03:13:01 <tromp> bit i is a value with the ith bit set
03:13:26 <Itkovian> nice
03:13:49 <tromp> [2^(p-1)*(2^p-1) | p <- primes]
03:13:58 <ex_nor> so it's  (1 << i)
03:14:16 <tromp> it's 1 `shiftL` i
03:14:23 <ex_nor> rightio ;)
03:14:50 <xerox> @index primes
03:14:50 <lambdabot> bzzt
03:14:59 <tromp> primes u need to define yourself:)
03:15:04 <derelm> hehe
03:15:05 <xerox> :-)
03:15:19 <ex_nor> tromp: isn't that only true is 2^p is also prime?
03:15:24 <ex_nor> errr, 2^p - 1
03:15:35 <xerox> Marsenne primes?
03:15:39 <ex_nor> indeed
03:15:48 <tromp> primes = sieve [2.. ] where
03:15:48 <tromp>          sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ]
03:15:53 <xerox> 2^9^9-1 ! :-)
03:15:54 <ex_nor> I'm almost certain =\
03:16:12 <tromp> oops, right, ex_nor
03:16:19 * ex_nor nods
03:16:27 * exnor grumbles
03:16:32 <exnor> this is the nick I'd rather
03:16:39 <exnor> some bastard beat me too it =P
03:16:50 <tromp> at least you get a speed up filtering from that list:)
03:17:36 <exnor> wow, that's reasonably fast =P
03:17:54 <tromp> [2^(p-1)*(2^p-1) | p <- primes, isPrime (2^p) ]
03:18:06 <exnor> 2^p - 1 ;)
03:18:14 <tromp> argh! right:)
03:18:14 <exnor> 2^p is barely ever prime... =)
03:18:27 <exnor> p = 1 is the only case I know of...
03:18:36 <exnor> and 1 isn't prime, so...
03:18:58 <tromp> [2^(p-1)*(2^p-1) | p <- primes, isPrime (2^p-1)]
03:19:25 <tromp> of course the latter test shld be replaced by a faster one
03:19:29 <tromp> like Lucas-Lehmer
03:19:41 <Oejet> Wow, what are you talking about? It looks like some encryption thing.
03:19:56 <tromp> we're having a perfect discussion
03:20:00 <derelm> hehe
03:20:13 <exnor> dear lord
03:20:19 <exnor> tromp: you should now die.
03:20:21 <exnor> miserably
03:20:41 <Janni> Hello.
03:20:48 <boegel> hey Janni 
03:21:31 <exnor> [x | x <- [1..], (sum [f | f <- [1..x-1], x `mod` f == 0]) == x - 1] <-- best way to generate the powers of 2 ever
03:22:11 <derelm> [ x^y | x <- [2], y <- [0..] ] ?
03:22:24 <exnor> nah, mine is WAY better
03:22:53 <derelm> ;-)
03:22:59 <derelm> it's nice to read
03:23:00 <xerox> Why is your better?
03:23:10 <exnor> wow cool, these guys look like they're even less frewuant than perfects ;)
03:23:10 <derelm> it's faster *g*
03:23:10 <exnor> Prelude> [x | x <- [1..], (sum [f | f <- [1..x-1], x `mod` f == 0]) == 2 * x]
03:23:11 <exnor> [120,672
03:23:23 <exnor> no surprises there I suppsoe
03:24:06 <exnor> derelm: you can't say anything about the speed! They both tkae an infinite amount of time to terminate
03:24:21 <tromp> here's something MUCH less frequent:
03:24:27 <tromp> main=mapM_(print.g 2)[0..]where
03:24:27 <tromp> g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
03:24:32 <xerox> O_O
03:24:43 <derelm> exnor: ok, thats right, but if i check a number with elem against that generator mine might terminate earlier, right?
03:24:45 <exnor> yeah, most readable code ever
03:25:01 <exnor> derelm: yes, maybe ;)
03:25:02 <tromp> optimized for fitting on 80char line:(
03:25:07 <exnor> if it's in there
03:25:19 <derelm> exnor: well, yes ;)
03:25:35 <exnor> yay for lazyness
03:27:37 <derelm> i have another problem. the creation of a infinite list of tuples where a is uneven and b is even. this might actually be [(a,b) | a <- [1..], b <- [1..], not(even a), even b]
03:28:36 <derelm> but if i check (3,2) `elem` that generator, it will never terminate
03:28:48 <tromp> of course not
03:28:50 <exnor> correct
03:28:55 <derelm> so how can i rewrite it so that it will terminate for that check as well
03:28:58 <tromp> it occurs after infinitely many others
03:29:14 <tromp> re-order by sum
03:29:31 <derelm> re-order by sum?
03:29:32 <exnor> ummm, I don't think that's entirely feasible using only list comprehensions...
03:29:42 <aj> ghci
03:29:44 <aj> bah
03:29:55 <exnor> yes, order the list so they are in order of (a + b)
03:30:06 <tromp> | sum <-[0..],a<-[1,3..],b<-[0,2..],a+b=sum]
03:30:09 <derelm> exnor: it's one thing on my problem sheet with a fat "use list comprehensions" above
03:30:24 <exnor> tromp: nice ;)
03:30:25 <tromp> oops
03:30:54 <tromp> b<-[sum-a] :)
03:31:05 <tromp> otherwise still takes forever:)
03:31:48 <xerox> Nice one!
03:32:01 <xerox> Bye now, lunchtime :-)
03:32:51 <derelm> tromp: i am not sure i understood how it's supposed to work
03:33:45 <exnor> tromp: that won't work
03:34:00 <exnor> but something similar should
03:35:39 <tromp> [(a,b)|sum<-[0..],a<-[1,3..sum],b<-[0,2..sum],a+b=sum]
03:35:48 <aj> | s <- [1,3..], b <- [2,4,..(s-1)]
03:35:56 <exnor> tromp: that's more like it
03:37:41 <aj> is there ever a point having two infinite lists in an expression like that?
03:39:56 <exnor> except you really want a == not an =
03:40:11 <exnor> but that's pretty obvious =P
03:41:07 <exnor> oohhh, you could speed it up, because the sum is always odd
03:42:18 <exnor> [(a,b) | sum <-[3,5..], a <- [1,3..sum], b <- [2,4..sum], a+b == sum] <-- WAY faster
03:42:38 <tromp> i went for clarity instead:)
03:42:43 <exnor> as if
03:42:49 <exnor> double speed = pwnage
03:43:03 <derelm> [(a,b) | a <- [1,3..], b <- [0,2..x], b < a] ?
03:43:17 <exnor> I'm sure you can put tighter bounds on the lengths of a and b too
03:43:20 <tromp> if you want speed, you'll have (a,sum-a)...
03:43:38 <exnor> hmmm
03:43:53 <exnor> good point
03:44:53 <tromp> then again, if you want speed...
03:45:04 <exnor> haha oh dear
03:45:14 <tromp> you'd never wanna construct a list of odd-even pairs in the first place
03:45:25 <derelm> well, it's not actually about speed, it's about, will it ever terminate ;)
03:47:41 <joao> Hello
03:47:51 <wolfman8k> wa sup ma people
03:48:22 <joao> Does anyone here has examples using State with Error and IO? :-)
03:49:25 <exnor> Prelude> elem (1237,100) [(a,sum-a) | sum <-[3,5..], a<-[1,3..sum],sum > a]
03:49:26 <exnor> True
03:49:28 <exnor> =P
03:49:33 <exnor> so it MUST work
03:50:07 <tromp> leave out the sum>a
03:50:14 <exnor> yeah, I just saw that
03:50:18 <exnor> wondering why I put it in
03:50:29 <derelm> so what should it look like in the end?
03:50:41 <derelm> a, just saw it
03:50:41 <tromp> and start sum from 1
03:50:50 <exnor> ... no
03:50:54 <exnor> a should go to sum-1
03:51:01 <tromp> no
03:51:14 <exnor> ... okay then
03:51:28 * xerox joins rapidly the 'no' party
03:51:37 * exnor hides
03:51:45 * xerox goes back to his meal
03:52:37 <exnor> ... what elemants am I missing by doing that?
03:53:25 <exnor> [(a,sum-a) | sum<-[3,5..], a<-[1,3..sum-2]]
03:53:38 * exnor scratches head
03:54:10 <exnor> if you let it go all the way to sum, you get 0 elements
03:54:21 <exnor> which is different to the first function
03:54:51 <derelm> btw: are you battleing in terms of speedoptimization ...?
03:57:33 <exnor> haha, not really
03:58:08 <exnor> all micro optimisations
04:20:05 <shapr> d00d
04:21:39 <tromp> hi shae
04:22:15 <shapr> Hiya John
04:22:18 <resiak> sw33t!
04:22:21 <tromp> dood== dead in dutch
04:22:46 <shapr> similar to svenska, where död is spoken nearly like dood
04:23:07 <shapr> d00d man walking!
04:23:17 <tromp> that's close to the german töt
04:24:21 <tromp> or do they just sayt tot?
04:24:28 <tromp> my german is rusty...
04:24:39 <shapr> I never had much german to begin with.
04:25:35 <tuomov> tot according to a dictionary
04:25:52 <derelm> tot is right
04:31:14 <Itkovian> isn't it 'Tot' ?
04:31:27 <Itkovian> if it's a noun
04:31:33 <derelm> Tod is the noun
04:31:48 <derelm> tot is the adjective
04:32:28 <shapr> I've never built any real simulations before, and I'm looking into making a unicycle simulator in Haskell. Any suggestions where I could start with such a thing?
04:34:08 <Itkovian> imho german is difficult :-)
04:59:39 <Victor> hi
04:59:47 <arjanb> hallo
04:59:54 <Victor> i'm having a problem with read
05:00:10 <Victor> transform :: String -> String
05:00:10 <Victor> transform s = (process x z (y !! 0) (y !! 1) (read (y !! 2) : Int)) where
05:00:10 <Victor> 	x = (processWords (lines s))
05:00:10 <Victor> 	y = (x !! 0)
05:00:10 <Victor> 	z = drop 1 x
05:00:24 <Victor> Undefined constructor function "Int" 
05:00:35 <Victor> missing an import or what?
05:00:50 <tromp> you mean ::
05:00:51 <arjanb> use :: instead of :
05:01:03 <Victor> oh, lol
05:01:05 <Victor> thanks
05:03:05 * wli wishes yi wouldn't use so many weird extensions
05:03:24 <irce> why does 'show 1' work but 'show (head [1,2])' gives Type           : Point -> String ->  
05:03:27 <irce> Does not match : a -> b -> c -> d
05:03:33 <irce> error
05:03:58 <irce> Type           : Point -> String -> Draw()
05:04:00 <irce> Does not match : a -> b -> c -> d
05:04:00 <Itkovian> Prelude> show (head [1,2])
05:04:00 <Itkovian> "1"
05:04:02 <irce> that is
05:04:06 <Itkovian> ?
05:04:19 <irce> jep should be 
05:04:22 <Itkovian> in ghci ...
05:04:48 <irce> its in a graphics draw function
05:05:01 <Itkovian> maybe the show there expects something else?
05:05:52 <exnor> Itkovian: but you'd expect (head [1,2]) to return 1 to show anyway... =\
05:05:54 <tromp>  (head [1,2]) and 1 shld be completely interchangable
05:05:57 <irce> Int it should be. works fine with other stuff but not when I try to get stuff out of a list
05:06:55 <irce> There's only a problem when I get the Int from a list
05:07:01 <tromp> what code gives the error?
05:07:01 <irce> weird
05:07:15 <irce> text (10,100) show (head sstart)
05:07:33 <irce> sstart = [1,2]
05:07:45 <tromp> what's text?
05:08:06 <irce> part of some graphics functions 
05:08:21 <exnor> errr, maybe it's a precidence issue?
05:08:27 <exnor> hmmm, shouldn't be
05:08:33 <exnor> if text is properly typed
05:08:50 <exnor> text (10,100) (show (head sstart))
05:09:07 <exnor> way more sexier... like a bitch
05:11:28 <irce> yees, thanks
05:16:25 <exnor> ... that fixed it?
05:19:18 <irce> jep. or I can use the $ sign apparently 
05:20:48 <Victor> what do i have to import for fromInt to work?
05:21:30 <Victor>  Instance of Num [Char] required for definition 
05:21:57 <Victor> iirc there's some nifty trigger here...
05:22:25 <exnor> wow, that really shouldn't have worked
05:23:22 <shapr> Victor: use fromIntegral
05:23:27 <shapr> fromInt is 0ldsk00l
05:23:57 <Victor> ok
05:24:03 <Victor> but apparently i still need...
05:24:06 <Victor>  Instance of Num [Char] required for definition
05:24:13 <Victor> @index fromIntegral
05:24:13 <lambdabot> GHC.Real,Prelude
05:24:22 <shapr> that means you're trying to do a numeric operation like multiplication on a String
05:24:35 <Victor> i see...
05:24:42 <shapr> that's generally considered counterintuitive.
05:25:01 <Victor> lol
05:25:11 <Victor> well, what i'm doing is [y,n,(fromIntegral h)] : r
05:25:15 <tromp> not in Ruby
05:25:22 <exnor> yeah, I wouldn't expect strings to be in the num class =P
05:25:22 <Victor> y and n are Strings
05:25:30 <tromp> "hi"*3 == "hihihi" in ruby...
05:25:33 <shapr> tromp: it works in Python too, but...
05:25:58 <exnor> what's h?
05:26:02 <Victor> an Int
05:26:29 <exnor> hmmm, could you just show it? ;)
05:26:53 <Victor> dunno, i'm a newbie
05:27:12 <exnor> [y,n,show h]:r
05:27:14 <exnor> that should work
05:27:18 <Victor> hm that makes sense
05:27:27 <shapr> I guess I can't say I'm a newbie anymore.
05:27:36 <Victor> it works, thx
05:29:28 <musasabi> times str n = concat $ replicate n str
05:29:47 <musasabi> "foo" `times` 3
05:33:58 <exnor> as if you'd do that
05:34:01 <exnor> when you could do...
05:34:11 <exnor> times = (concat) . (flip replicate)
05:34:18 <exnor> ... or something along those lines =P
05:34:51 <Itkovian> exnor: why shouldn't those extra brackets have changed anything? After all, isn't f g h == f ( g (h)) ?
05:34:51 <exnor> hmmm, not seeming to work
05:35:04 <Itkovian> erm \
05:35:11 <Itkovian> i meant (f g) h
05:35:19 <exnor> ... I suppose
05:35:40 <exnor> but if you know the type of "text" then can't you work out that show is going to return what you want...
05:35:44 <exnor> so... yeah
05:35:53 <exnor> give it it's arguments and then you're happy
05:36:02 <Itkovian> then text (10,100) show (...) == (((text (10,100)) show ) (...))
05:36:13 <Itkovian> no?
05:36:17 <Lemmih> @seen bringert
05:36:17 <lambdabot> I saw bringert leaving #haskell.se 21 hours 5 minutes 33 seconds ago.
05:36:24 <exnor> ?
05:36:27 <Itkovian> hmm maybe that should give the same result ...
05:36:27 <exnor> why?
05:36:34 <exnor> okay.
05:37:08 <Itkovian> if ((text (10,100)) show ) evaluates to a decent function ...
05:37:14 <Itkovian> but if it doesn't ...
05:37:27 <Itkovian> I'm just wildly guessing
05:37:54 <exnor> very well
05:40:07 <Itkovian> @index text
05:40:07 <lambdabot> Text.Html,Text.PrettyPrint,Text.PrettyPrint.HughesPJ
05:43:14 <Victor> how do i :unload again? :P
05:43:48 <Victor> nevermind
06:00:36 <Itkovian> wb
06:02:12 <basti_> boink
06:11:42 <yrlnry> It seems that a lot of the benefit of monadic style of programming is lost if the host language doesn't provide lazy evaluation.
06:12:45 <boegel> I cleaned up my raytracer code a bit, and I now have only 285 lines of code :)
06:13:06 <yrlnry> For example, if you implement exceptions using monads, then the expression  raise "exception" >> calculate()   will call calculate() anyway. In a lazy language, the definition of >> will suppress evaluation of calculate().
06:13:15 <boegel> and my Perlin module is way too complicated now, so it'll be less then 250 when I get that done
06:14:00 <wilx`> :)
06:14:03 <wilx`> Interesting.
06:14:08 <wilx`> Render some real scene :)
06:14:21 <boegel> wilx`: my spheres are real :p
06:14:26 <wilx`> Heh.
06:14:44 <boegel> I'm just saying it would be hard to accomplish the same result with an esuivalent amount of C or Java code
06:14:56 <wilx`> Well, something like the famous tea pot scene.
06:15:03 <boegel> s/esuivalent/equivalent
06:15:04 <wilx`> I know.
06:15:23 <boegel> wilx`: I have other stuff do to with the code than just writing it
06:15:41 <boegel> s/do to/to do
06:15:52 <Lemmih> yrlnry: Not exactly.
06:16:50 <Lemmih> yrlnry: 'x >> f' is 'x >>= \_ -> f' so f wouldn't be evaluated.
06:18:41 <Victor> when i'm having a function that evaluates to a string with "\n"'s in it, Hugs doesn't convert them to newlines but just prints "asdfa\nblabla".. is this normal?
06:18:57 <Lemmih> Victor: Yes.
06:18:57 <ibid> depends on how you print it
06:19:03 <ibid> but probably yes :)
06:19:23 <Victor> but i want them converted to newlines
06:19:24 <Victor> :P
06:19:34 <Lemmih> Victor: Then use putStrLn.
06:19:38 <Lemmih> @type putStrLn
06:19:41 <lambdabot> putStrLn :: String -> IO ()
06:19:56 <Victor> ok cool, thx
06:20:58 * Lemmih throws a shuriken at HaskellDB's optimizer.
06:21:03 <irce> so I got my list, finelist = [1,2] , now I need to change it .. error multiple define ..  
06:21:13 <yrlnry> Lemmih: Right.  I have been screwing around with an implementation that does it differently.
06:21:29 <Lemmih> irce: You can't change it.
06:22:18 <yrlnry> Lemmih: I was hoping to get rid of the binding semantics.  But you really need some way to delay the computation of the RHS of >> and >>= until the LHS has been evaluated.
06:23:38 <irce> damnit 
06:24:26 <Lemmih> yrlnry: Yes, and that is done with curried functions.
06:24:39 <Victor> thanks for the help guys, cya
06:24:46 <Lemmih> irce: Welcome to the world of functional programming (-:
06:26:11 <irce> the graphics part is not so functional .. not fun to combine functional and non functional
06:27:16 <Lemmih> irce: The graphics part?
06:27:44 <yrlnry> My real problem here is that Perl has such a crappy syntax for anonymous functions.
06:28:37 <Lemmih> yrlnry: Solution: Use Haskell instead.
06:29:10 <yrlnry> Since the problem is "Find a palatable way to demonstrate monadic programming style in Perl", that is not an acceptable solution.
06:29:11 <irce> Lemmih: graphics library
06:29:39 <yrlnry> The syntax in haskell would not be so nice either, if there were not the special case syntactic sugar for it.
06:30:38 <yrlnry> So the best answer for Perl may be some sort of preprocessor to pour on the sugar.
06:31:14 <Lemmih> Why do you wanna use Perl?
06:31:38 <yrlnry> Because I might learn something.
06:31:53 <yrlnry> Something that other people don't know, that is.
06:32:06 <Lemmih> irce: wxHaskell and hopengl are both very pleasant, IMHO.
06:44:12 <np_hard> perl has crappy syntax for anonymous functions?
06:44:19 <np_hard> sub { ... } ?
06:44:50 <np_hard> there are many more disgusting things about perl to complain about
06:46:12 <Janni> Limmih: That's right.
06:46:26 <bisby> anyone that is impressed by the elegance of scheme?
06:47:55 <TheHunter> to me, the statement "only perl can parse perl" says enough.
06:48:05 <yrlnry> np_hard: It's not the sub { ... } part that's a big problem.  It's the fact that you have to follow it with my $arg = shift;
06:48:35 <sorje> yrlnry, well, you don't _have_ to, do you?
06:48:54 <yrlnry> A cleaner binding syntax would tidy up a lot of functional-style Perl code.  As it is, you have to bend over backwards to get functional code to be at all readable.
06:48:58 <yrlnry> sorje: What do you mean?
06:49:42 <np_hard> $_[0],
06:49:45 <np_hard> $_[1],
06:49:48 <yrlnry> No, that doesn't work.
06:49:49 <np_hard> no need to name that crap
06:50:03 <yrlnry> Consider  sub { my $a = shift; return sub { my $b = shift ; ... }  }
06:50:19 <sorje> ah closure stuff
06:50:36 <TheHunter> and the perl documentation seems to consist entirely of library documentation...
06:50:52 <yrlnry> TheHunter: That is definitely not true at all.
06:51:12 <sorje> TheHunter, perl comes with the best docs I've ever seen. ;-)
06:51:19 <yrlnry> TheHunter: If anything, I would give the opposite criticism: The documentation for the Perl core language is much too big.
06:51:44 <np_hard> (lambda (a) (lambda (b) ( ... ))) i suppose you have a point
06:51:52 <TheHunter> then i guess i'm just to stupid to find it.
06:52:04 <sorje> TheHunter, perldoc perl ;-)
06:52:04 <yrlnry> TheHunter: Try www.perldoc.com.
06:52:04 <np_hard> but perl has never been known for things like that
06:52:24 <TheHunter> ah, i found something that is called "perl syntax"
06:52:44 <yrlnry> TheHunter: If you would like, I can mail the language documentation to you.
06:53:06 <sorje> It is on perldoc.com, too ;-)
06:53:41 <np_hard> although you probably don't want to mask $a and $b, yrlnry.
06:53:45 <yrlnry> Anyway, I hoped to get around some of the syntactic ugliness by uncurrying the >> operator.  But that has big semantic problems.
06:53:52 <np_hard> those are handy for HOFs in perl
06:54:29 <yrlnry> np_hard: Not particularly.  The only thing different about $a and $b is that they are exempt from "use strict 'vars'" failures.  
06:55:02 <yrlnry> But you can use any global variables in the same way if you either disable strict vars or declare the globals.
06:55:19 <yrlnry> Anyway, it's nap time. Thanks for discussing this with me.
06:56:22 <Lemmih> Yay. I fixed HaskellDB once again.
07:15:51 <goron> Where's the asymptote in the "asymptotic behaviour of an algoritm"? If I take this definition for an asymptote (I would like to have the most general definition of an asymptote): http://mathworld.wolfram.com/Asymptote.html  
07:16:07 <goron> algoritm->algorithm
07:17:25 <tromp> that's not an appropriate def of asymptotic
07:18:10 <wilx`> Huh.
07:18:21 <tromp> google for big-oh notation
07:19:18 <goron> tromp: I know they mean "when n goes to infinity"... but I want a more formal notation which fits in the asymptote for curves... or as said one that unifies both definitions. 
07:20:13 <goron> tromp: Mathworld has a site on big-oh notation. 
07:21:16 <goron> tromp: But it doesn't relate to curves, so it seems. 
07:24:10 <tromp> their need not be an asymptote in big-Oh notation
07:24:20 <tromp> for instance if running time is Theta(n)
07:24:33 <tromp> it can keep swinging between 1*n and 2*n
07:25:17 <tromp> only if running time is f=o(g) (little-o) you gave a 0 asymptote for f/g
07:25:26 <tromp> gave->have
07:26:23 <tromp> ppl say "asymptotic behaviour" just to refer to behaviour in the limit as n->infinity
07:26:36 <tromp> there is no suggestion of convergence
07:27:54 <goron> tromp: Indeed, and this seems a misuse of the word asymptote. It's only applicable in the o(g(n)) case.
07:28:56 <goron> tromp: Well, there are ofcourse algoritms with other asymptotes...
07:29:08 <goron> tromp: But not in the general case.
07:30:03 <np_hard> is it true that all algorithms are defined over some algebra, as Stepanov says in the STLport interview?
07:31:10 <wolfman8k> STLport? isn't that a c++ library?
07:36:07 <goron> np_hard: In Haskell, you claim that there exists a type FooAlbragra a = (TypeArg1->TypeArg2->a (for dataconstructor1) , TypeArg1->a (for datacons. 2)) etc. defined on an datatype, such that with a fold every algoritm can be defined. I think this is true. 
07:37:34 <goron> an->a
07:39:56 <goron> FooAlbragra->FooAlgebra :(
07:45:43 <np_hard> http://www.stlport.org/resources/StepanovUSA.html
07:46:21 <np_hard> "In other words, I realized that a parallel reduction algorithm is associated with a semigroup structure type. That is the fundamental point: algorithms are defined on algebraic structures. It took me another couple of years to realize that you have to extend the notion of structure by adding complexity requirements to regular axioms."
07:57:36 <wli> np_hard: what is a complexity requirement?
08:10:02 <np_hard> e.g. taking the head of a queue is guaranteed O(1) by an implementation
08:22:30 <joao> Does anyone here has examples using State with Error and IO? :-)
08:24:04 <Igloo> Does LambdaBot do that?
08:24:58 <musasabi> joao: I have some sources doing that.
08:25:10 <musasabi> joao: Do you want monad error or exceptions?
08:32:38 <musasabi> When should one use typeclasses and when is a structure of functions better? e.g.:
08:32:48 <musasabi> class PCC t addr | t -> addr where sendPC :: t -> addr -> addr -> Data -> IO (MVar Status) ; recvPC :: t -> IO (Data,addr,addr)
08:32:51 <musasabi> data PC a = PC { sendP :: a -> a -> Data -> IO (MVar Status), recvP :: IO (Data,a,a) }
08:37:00 <joao> musasabi, I have: type STM a = StateT InstanceVars (ErrorT MyError IO) a
08:37:14 <joao> And I'm having problems mixing the error monad in my do constructions
08:37:15 <joao> :\
08:37:35 <joao> I can work on the state, perform IO, but I'm having problems with Error
08:38:02 <Igloo> Is it necessary to have the state above the error?
08:38:16 <Darius> Igloo: It depends on what you want.
08:39:21 <joao> I'm confused with order, too :|
08:40:20 <Igloo> I think you'll find it easier to write code if the error is on the top, but like Darius said that depends on what semantics you need
08:40:49 <joao> Can you explain me the difference, please?
08:43:40 * Igloo can't right now
09:05:00 * Janni is back
09:13:39 <musasabi> joao: http://www.cs.helsinki.fi/u/ekarttun/haskell/dns/ should contain some example code.
09:26:18 <joao> Thank you
09:56:57 * TheHunter swears at Reynold's book
10:28:01 <CosmicRay> MegaMonad: good morning
10:28:07 <MegaMonad> CosmicRay: Though not the slighest idea.
10:28:20 <Heffalump> 'lo
10:28:44 <pflanze> A naive fibonacci implementation is taking 12 times as long in haskell when compiled with ghc -O than the same algorithm in GambitC scheme. Am I doing something wrong?(tm)
10:29:02 <Heffalump> using Haskell? ;-)
10:29:21 <Philippa_> and probably not squashing laziness
10:29:34 <Heffalump> what's the space usage like?
10:29:43 <pflanze> moment..
10:29:51 <CosmicRay> pflanze: where's your code?
10:30:53 <pflanze> CosmicRay: http://pflanze.mine.nu/~chris/scratch/hs/fib.hs
10:31:36 <CosmicRay> pflanze: how are you able to accurately benchmark this running only up to 35?
10:31:54 <pflanze> it's taking 2 seconds
10:31:55 <Heffalump> that's a lot of recursive calls
10:31:57 <CosmicRay> if you're just running the resulting executable several times, perhaps ghc programs just have a higher startup cost
10:31:59 <CosmicRay> hmm
10:32:01 <Heffalump> 2^35 or so..
10:32:39 <pflanze> CosmicRay: nah, linux 'time' is accurate enough
10:32:40 * CosmicRay tests
10:34:35 <Darius> Is the Gambit Scheme version using arbitrary precision integers?
10:34:46 <CosmicRay> Darius: excellent question
10:34:55 <pflanze> Darius: no, it's optimizing to using native integers.
10:35:05 <Darius> Add, fib :: Int -> Int, then try.
10:35:16 <CosmicRay> Darius: I just did that.  Went from 2s to 0.238s on my machine.
10:35:27 <Heffalump> how big is fib 35?
10:35:34 <CosmicRay> 9227465
10:35:35 <Heffalump> it might overflow the Haskell standard Int (if not the GHC one)
10:35:46 <Heffalump> is that all?
10:35:51 <pflanze> ok, cool, thx Darius :)
10:35:54 <CosmicRay> that's what the proggy says
10:35:58 <Heffalump> fairy nuff
10:36:30 <CosmicRay> pflanze: if you don't define it as int, it's going to build it as:
10:36:32 <pflanze> (9227465 is correct, getting the same from other implementations)
10:36:36 <CosmicRay> fib :: (Num a, Num b) => b -> a
10:36:54 <pflanze> CosmicRay: yeah, I see, makes sense.
10:36:56 <CosmicRay> that is, an implemention generic enough that it could take an int and return a double
10:37:24 <Darius> CosmicRay: That implementation is generic enough that it could take practically anything and return practically anything.
10:37:30 <CosmicRay> true
10:38:10 <CosmicRay> pflanze: does this meet or exceed your scheme implementation now?
10:39:06 <pflanze> CosmicRay: GambitC is at 0.180s, ghc at 0.230s, so it's still taking 30% longer, but that's fine.
10:39:36 <Heffalump> you need bigger benchmarks to really be sure of the difference
10:39:49 <pflanze> I'm wondering how one would make a caching version of the fibonacci example in haskell.
10:40:06 <Darius> It depends on how you want to cache.
10:40:15 <CosmicRay> Heffalump: quite right
10:40:30 <pflanze> fib n should remember previously calculated results for n
10:40:35 <Darius> pflanze:  There's also -O2.  I'm not sure what other optimizations that might enable.
10:40:45 <Oejet> planze: I'm curious about benchmarks with different inputs.
10:40:49 <pflanze> Darius: I've already tried -O5 to no avail.
10:41:23 <Heffalump> pflanze: remembering previously calculated results in general leads to huge space leaks
10:41:23 <pflanze> Oejet: you mean with results bigger than 2^31 ?
10:41:24 <Darius> There is no -O5 (or wasn't last time I checked).
10:41:55 <pflanze> Heffalump: but not if only 35 of them are needed :)
10:42:56 <Heffalump> how is the compiler supposed to know that?
10:42:57 <pflanze> honestly I'm a little bit surprised ghc didn't compile my naive fib in a caching way :)
10:43:47 <TheHunter> pflanze, well the canonical implementation is fib n = fibs !! n where fibs = 0:1:zipWith fibs (tail fibs)
10:43:49 <pflanze> But I'm not that smart in lazy thinking yet so don't know how that would help.
10:43:57 <thebug> I missed something ... what was this megamonad bot doing earlier?
10:44:22 <Maddas> MegaMonad: What were you doing earlier?
10:44:27 <MegaMonad> Maddas: That's how haskell is much more fun then bicycling?
10:44:30 <Maddas> Hi, pflanze :-)
10:44:34 <pflanze> hi Maddas
10:45:27 <thebug> megamonad's specialty : markov chains
10:49:02 <CosmicRay> TheHunter: I'm having trouble figuring out how that works
10:49:18 <TheHunter> oops, somebody stole (+).
10:49:20 <CosmicRay> TheHunter: I don't see a + anywere, for instance
10:49:23 <TheHunter> pflanze, well the canonical implementation is fib n = fibs !! n where fibs = 0:1:zipWith (+) fibs (tail fibs)
10:49:34 <CosmicRay> ah.
10:50:51 <Heffalump> heh
10:51:15 <Heffalump> for extra points, derive that implementation from the naive one
10:54:00 <thebug> MegaMonad: a pumpkin pie and whipped cream
10:54:06 <MegaMonad> thebug: Well, if you really need a working example. It has behaviours for characters that shows cream pie is or is it if you give it an annoyance to apply this theory to be whipped.
10:55:58 <tuomov> MegaMonad: What is a monad?
10:56:04 <MegaMonad> tuomov: I was able to use dfoo in some places you need a monad monad.
10:56:45 <tuomov> MegaMonad: I mean, really, what is it?
10:56:51 <MegaMonad> tuomov: (To use a monad. I can't say what case would have something like janw_stub.c:9: error: parse error on pstack.
10:57:07 <tuomov> MegaMonad: n00b!
10:57:13 <MegaMonad> tuomov: He might just as well as the b in the first element of the way down to 4.00.
10:58:04 <tuomov> bah. can't answer a faq item :)
10:58:39 <CosmicRay> fib :: Int -> Int
10:58:39 <CosmicRay> fib n =
10:58:39 <CosmicRay>     let fibs :: Int -> Int -> [Int]
10:58:39 <CosmicRay>         fibs x y = let next = x + y in next : fibs y next
10:58:39 <CosmicRay>         in
10:58:40 <CosmicRay>         (0 : 1 : fibs 0 1) !! n
10:58:47 <CosmicRay> try that one pflanze
10:58:57 <CosmicRay> it's the same idea as the zipwith one
10:59:09 <CosmicRay> runs in 0.001s over here
11:00:48 <Heffalump> fastfib :: Int -> (Int, Int)
11:00:55 <Heffalump> fastfib 0 = (0,1)
11:01:08 <Heffalump> fastfib (n+1) = let (a,b) = fastfib n in (b,a+b)
11:01:14 <Heffalump> fib n = fst (fastfib n)
11:01:18 <Heffalump> how fast does that run?
11:02:08 <CosmicRay> 0.001s also
11:02:13 <CosmicRay> iow, less than the margin of error
11:02:20 <CosmicRay> between that and mine
11:02:22 <pflanze> thanks CosmicRay, without the Int declarations, it calculates fib 1000 in 0.000s for me
11:02:32 <pflanze> 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
11:02:39 <CosmicRay> bwahahaha
11:02:40 <pflanze> ;)
11:05:19 <pflanze> (fib 100000 is taking 4.460s)
11:05:34 <CosmicRay> geez, how pathetic :-)
11:06:01 <pflanze> (fib 1mio is overflowing the default heap size.)
11:07:12 <resiak> fib 100000 results in "ERROR - Garbage collection fails to reclaim sufficient space" here ;). *switches to ghc*
11:09:08 <pflanze> How interesting: google doesn't know a single website with the fib 1000 result.
11:10:19 <Heffalump> maybe cos noone cares? :-)
11:13:40 <pflanze> Heh, google found a page with fib 100, and that page also contains the fib 1000 value: http://gnosis.cx/fib.txt
11:13:53 <pflanze> Looks like google doesn't remember such long 'words'.
11:17:43 <Victorious> hm, having a (newbie) problem with IO...
11:17:53 <Victorious> main = do
11:17:53 <Victorious> 	fromHandle <- (openFile "in.txt" ReadMode)
11:17:53 <Victorious> 	toHandle <- (openFile "out.txt" WriteMode)
11:17:53 <Victorious> 	contents <- getContents fromHandle
11:17:53 <Victorious> 	hPutStr toHandle (transform (return contents))
11:18:07 <CosmicRay> you want hGetContents fromHandle
11:18:10 <Victorious> transform's String -> String, so how do i make it String -> IO String?
11:18:15 <Victorious> oh ok
11:18:42 <CosmicRay> also you should probably be saying: hPutStr toHandle (transform contents)
11:18:47 <CosmicRay> contents will be type String
11:19:11 <CosmicRay> return will make it type IO String, which would mean transform would have to be IO String -> String, which makes no sense
11:19:27 <Victorious> oh right, ok thanks
11:19:32 <CosmicRay> the "<-" basically takes the "IO" off the front of the type
11:19:39 <CosmicRay> return adds it back on
11:19:43 <Victorious> so now it's not erroring anymore, but it's not creating the output file either
11:19:53 <Victorious> or do i have to create it first and only then it writes to it?
11:20:02 <CosmicRay> try hClose toHandle at the end
11:20:21 <CosmicRay> or perhaps your transform is buggy
11:20:28 <Victorious> wow it works, cool
11:20:30 <Victorious> thanks
11:20:34 <CosmicRay> no prob
11:20:58 <CosmicRay> Victorious: btw, I suggest this: http://www.isi.edu/~hdaume/htut/
11:21:05 <CosmicRay> also the wiki has some good stuff
11:21:07 <CosmicRay> @wiki
11:21:07 <Darius> Heffalump: Using the property that zipWith (+) as bs = cs => cs!!n = as!!n + bs!!n, the fact that N->X is isomorphic to a stream of Xs, and the definition of !! it can be derived quite easily.
11:21:07 <lambdabot> http://www.haskell.org/hawiki/
11:21:34 <Victorious> thx
11:21:38 <TheHunter> also, readFile and writeFile might provide a shortcut.
11:21:52 <CosmicRay> good advice.
11:22:04 <CosmicRay> Victorious: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html
11:22:11 <Victorious> so what i'm having now is this main = ... thing, shouldn't that be evaluated automatically when loading the file?
11:22:12 <CosmicRay> that's the reference to most I/O in Haskell
11:22:18 <Victorious> cuz right now i have to type "main"
11:22:27 <CosmicRay> Victorious: you're using hugs?
11:22:34 <Victorious> yea
11:22:36 <Heffalump> it would be evaluated automatically if you compiled your program and ran the compiled program
11:22:42 <Heffalump> or used 'runhugs'
11:22:46 <CosmicRay> Victorious: hugs will not evaluate it automatically
11:22:46 <Victorious> oh i see
11:22:50 <CosmicRay> Victorious: but if you compile it, it would
11:23:01 <Heffalump> hugs and ghci are providing you with an interactive REPL
11:23:07 <Heffalump> (read-eval-print-loop)
11:23:08 <CosmicRay> Victorious: or, you can make it run like a script by doing "runhugs foo.hs"
11:23:18 <Heffalump> which is generally helpful for debugging code and trying things out
11:23:23 <CosmicRay> Victorious: try ghc --make -o foo foo.hs
11:23:27 <CosmicRay> then ./foo
11:23:59 <Victorious> yeah i'll check it out
11:25:41 <musasabi> What would be the best way to represent MAC addresses in Haskell? 
11:26:04 <Heffalump> depends what you want to do with them
11:26:26 <musasabi> Heffalump: put them efficiently to memory (via Ptr)
11:26:47 <musasabi> and do comparisons with them (just simple equality)
11:26:50 <Heffalump> is there an Int64 type in GHC?
11:26:58 <musasabi> yes.
11:27:14 <Heffalump> use that then, I would expect
11:27:33 <musasabi> but how would I put a 8 byte int64 as a 6 byte mac address to the buffer?
11:29:03 <mrsolo> e
11:31:27 <Heffalump> ah.
11:31:42 <Heffalump> dunno :-)
11:31:50 <Heffalump> are you desperate to save that extra 2 bytes?
11:32:17 <Heffalump> if you're operating on an architecture that prefers 4 or 8 byte aligned operations, you might find it hurts performance
11:33:38 <musasabi> well I wouldn't care about that but other things care about it.
11:33:46 <musasabi> That is I cannot change the format..
11:34:10 <musasabi> 0: mac, 6: mac, 12: rest
11:36:03 <Heffalump> tuple of Int32 and Int16 then, I guess.
11:36:22 <musasabi> that should work..
11:38:17 <Darius> I'd probably use a Word64 and convert to a Word32/16 when needed depending on the usage pattern.
11:44:24 <Heffalump> that's true, you can just convert it to write it out
11:44:24 <pflanze> (Calculating fib(1000000) took 31m21.650s)
11:48:07 <Darius> Adding the type declaration Integer -> Integer may or may not make a differenc.
11:48:53 <bourbaki> moin
11:50:48 <bourbaki> how can i make my own = for my own data type?
11:51:19 <Heffalump> why would you want to?
11:51:21 <Heffalump> (you can't)
11:51:26 <Heffalump> oh, do you mean == ?
11:51:41 <bourbaki> Heffalump:  theres a new puh movie coming up with Heffalumps :)
11:51:47 <bourbaki> i think == yes
11:51:55 <Heffalump> make an instance of class Eq
11:51:58 <Heffalump> instance Eq Foo where
11:51:59 <bourbaki> i am writeing a graph CT implementation
11:52:04 <Heffalump>   Foo a == Foo b = a == b
11:52:08 <Heffalump>   Bar a == Bar b = a == b
11:52:14 <bourbaki> ah ok thanks
11:52:15 <Heffalump>   _ == _ = False
11:52:17 <Heffalump> or similar
11:59:40 <bourbaki> hm
11:59:59 <bourbaki> my type is type Edge = (Int, Int, String)
12:00:39 <bourbaki> instance Eq Edge where (s1,t1,n1) == (s2,t2,n2) = .... gives me an error
12:00:44 <Heffalump> ah, you can't do it for type synonyms
12:00:51 <Heffalump> you'll have to change your declaration to
12:01:00 <Heffalump> newtype Edge = Edge (Int, Int, String)
12:01:02 <Heffalump> (or similar)
12:01:18 <Heffalump> and then go through the hassle of sorting out the rest of your program
12:01:19 <bourbaki> ah ok
12:01:30 <bourbaki> what was that called again?
12:01:35 <bourbaki> phantom type?
12:01:38 <Heffalump> no, newtype
12:01:46 <Heffalump> it's a fairly standard part of the language
12:01:57 <bourbaki> no i mean its like a data with just one thingy right?
12:02:04 <Heffalump> yes, it is
12:02:09 <Heffalump> but it's got slightly different semantics
12:02:17 <Heffalump> and will have no overhead
12:02:29 <bourbaki> and what are the semantical differences?
12:02:49 <Darius> @wiki NewtypeVsStrictData
12:02:49 <lambdabot> http://www.haskell.org/hawiki/NewtypeVsStrictData
12:04:04 <Darius> Hmm.  That page (NewtypeVersusStrictData) needs to be cleaned up some.
12:04:52 <exnor> Darius: guess who can do that? ;)
12:07:36 <TheHunter> so, is there a semantic difference between data Foo a = Foo !a and newtype Foo a = Foo a?
12:08:22 <Heffalump> there is, yes
12:08:34 <Heffalump> but Igloo keeps having to remind of what it is.
12:08:53 * Heffalump remembers I made a note the last time he did
12:09:00 <Heffalump> data ! and newtype both have a single _|_, the difference is you can match it against Foo _ with newtype but not data !
12:09:45 <bourbaki> what does the ! do?
12:09:58 <TheHunter> ok, thanks.
12:12:25 <Darius> bourbaki: Makes the component strict.
12:13:00 <Darius> i.e. Foo (error "foo") will give error "foo".
12:14:35 <bourbaki> what is strict?
12:15:39 <monochrom> data Weird = Weird Int; w = Weird (0/0); f (Weird _) = 1; main = print (f w)  --- will work
12:16:03 <monochrom> If you add ! it will abort.
12:16:34 <exnor> wow, strangest way of explaining strict ever
12:16:50 <yrlnry> I thought that seemed like a really straightforward way to explain it.
12:16:59 <exnor> rightio
12:17:16 <exnor> "I'll explain this concept by giving one example of it"
12:17:31 <yrlnry> An ounce of example is worth a pound of specification.
12:17:34 <Darius> strict == eager (in practice).  I'll assume you know what eager is since you are using Haskell, a lazy language which is one of it's more notable feature.
12:17:39 <exnor> which is great if you already knew it by a different name or something...
12:18:00 <bourbaki> i dont know what eager is either sorry
12:18:07 <monochrom> I like using 0/0 to illustrate non-strictness.
12:18:19 <bourbaki> and sry to say so but the example does not help me really :)
12:18:35 <Darius> You know Haskell being a lazy language implies, no?
12:18:48 <Darius> "know what Haskell"
12:19:03 <bourbaki> you mean because 0/0 is not evaluated yet at that point it aborts?
12:19:14 <exnor> bourbaki: Haskell is lazy, which means that it doesn't evaluate anything until it needs to.
12:19:21 <exnor> strict is the opposite of lazy
12:19:33 <exnor> so things get evaluated as soon as they are encountered
12:19:36 <yrlnry> bourbaki: arguments to functions are not normally evaluated right away.  The evaluation is delayed until the time the value is needed---*unless* the argument has a strictness flag on it.
12:19:45 <exnor> instead of as soon as they are needed
12:20:10 <bourbaki> so strict stuff gets evaled right at the time i use it?
12:20:32 <exnor> ... right at the time Haskell sees it
12:21:10 <bourbaki> ok and why did that do an abrotion in the example?
12:21:42 <exnor> because the strictness of the Weird component caused 0/0 to be evaluated
12:21:44 <monochrom> Somehow I find that this operational explanation (in terms of evaluation) is quite hard to grasp.
12:22:21 <Darius> monochrom: The denotational one is a strict function takes _|_ to _|_, a non-strict one might not.
12:22:35 <monochrom> I prefer the denotational explanation f _|_ = _|_ for strict, f _|_ not necessarily = _|_ for non-strict.
12:23:12 <monochrom> And my favourite _|_ is 0/0.
12:23:22 <Darius> I'd be more inclined to used 1/0.
12:23:48 <monochrom> 1/0 is better.
12:23:48 <xerox> Can I ask you what is _|_ ?
12:23:54 <monochrom> 1/0
12:23:56 <monochrom>  :)
12:24:15 <bourbaki> false isnt it?
12:24:33 <monochrom> most people use the English words "undefined", "bottom", "can't be done", "infinite loop", ...
12:24:46 <Darius> Though typically, I use undefined if I assume the person knows what it is.
12:24:53 <Darius> @get-definition undefined
12:24:53 <lambdabot> undefined = undefined
12:26:00 <Darius> _|_ (read "bottom") is (in programming, typically) the non-terminating (or also the "stuck") computation.
12:26:07 <bourbaki> and what is the semantical difference of newtype and data then ?
12:26:16 <Darius> xerox: undefined is _|_ in Haskell.
12:26:20 <bourbaki> like NIL in lisp?
12:26:32 <xerox> Darius, uh, WHY? :-)
12:26:34 <bourbaki> or false in logics
12:27:06 <Darius> xerox: Why what?
12:28:13 <Darius> bourbaki: not really, no.  Like, undefined = undefined or 1/0.
12:28:34 <Darius> Though it has some relation to falsehood.
12:28:40 <monochrom> Many different kinds of bad things may happen in a program.
12:29:03 <xerox> Darius, is there any explanation about why underscore-pipe-underscore was choosen?
12:29:06 <monochrom> Most denotational semantics lump all those bad things into one and call it _|_
12:30:19 <Darius> xerox: It isn't, that's just the ascii-fication of it.  The thing looks like an upside down T and it was chosen because it represents the bottom of a CPO.
12:30:24 <monochrom> But there is no problem if you prefer to keep them separate, e.g., you want an infinite loop to be named differently from 1/0.  It is just that most denotational semantics don't care about the different and put all of them under one roof _|_
12:30:59 <xerox> Darius, ah!
12:31:00 <Darius> xerox: The opposite, top, looks like a sans-serif T.
12:31:10 <xerox> Nice one.
12:33:00 <emu> "under one floor" seems more appropriate ;)
12:33:17 <Darius> @wiki HaskellIrcPastePage
12:33:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:35:53 <bourbaki> can someone help me on this here? http://paste.phpfi.com/40661
12:36:22 <bourbaki> why do i get an indetion error on 23?
12:37:19 <psi> unmatching paranthesis?
12:37:44 <monochrom> yeah, on 22
12:38:10 <bourbaki> hm emacs haskell mode wont show me these parenthes anymore ... thanks
12:39:02 <Darius> bourbaki: Why all the intermediate variables?  The definition of (==) would look much nicer with none.
12:39:41 <bourbaki> Darius: with all the tests in  place?
12:40:34 <Darius> Edge (s1,t1,n1) == Edge (s2,t2,n2) = s1 == s2 && t1 == t2 && n1 == n2;  looks a lot clearer to me and is a lot shorter
12:40:51 <Darius> If nothing else, let test4 = ... in test4 is completely superfluous.
12:41:08 <bourbaki> ok i can change that but i got some more errors on the topSum fn sec
12:41:28 <bourbaki> http://paste.phpfi.com/40662
12:42:14 <Darius> @wiki HaskellIrcPastePage
12:42:15 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:42:23 <Darius> (I forgot to save)
12:44:32 <Darius> bourbaki: As a further note, you don't need an Eq instances and a newtype.  The standard one on triples is the same as the one you've defined (though you may want to keep the newtype (or better use data) for other classes).
12:45:20 <bourbaki> Darius: ? and how would i use nub then?
12:45:37 <Darius> You'd just use it.
12:45:54 <bourbaki> oh so i wont need the Eq at all?
12:46:21 <Darius> You do if you use a newtype, but with a type synonym (a,b,c) already has an Eq instance.
12:46:35 <jadrian> hmmm weird
12:46:47 <jadrian> type Bar1 a = Foo a
12:46:48 <Darius> In fact, even for your current definition, you could just do, Edge x == Edge y = x == y.
12:46:51 <jadrian> type Bar2 = Foo
12:47:02 <jadrian> aren't Bar1 and Bar2 supposed to be exactly the same?
12:47:04 <bourbaki> hm ok :)
12:47:12 <Darius> jadrian: No.
12:47:23 <jadrian> Darius: what is the difference?
12:47:30 <Darius> You can use Bar2 in a class head, but not Bar1.
12:47:40 <Darius> Meaning-wise, they are the same.
12:47:47 <jadrian> Darius: yes that's how I found out they were not the same :)
12:47:59 <jadrian> Darius: so that is the only difference?
12:48:19 <Darius> jadrian: (Well you can with glasgow-exts at least (re using in a class head))
12:48:33 <jadrian> Darius: I'm using glasgow-exts...
12:48:41 <Darius> jadrian: And things along those lines, yes, I believe.
12:48:41 <jadrian> Darius: and it says I can't
12:49:12 <jadrian> Darius: I was wondering if it was possible to define a Functor instance for (a,a)
12:49:24 <jadrian> Darius: my guess is "no"
12:50:17 <jadrian> that's why I tried:
12:50:19 <jadrian> type Pair a = (a,a)
12:50:40 <jadrian> and then
12:50:44 <jadrian> instance Functor Pair where
12:50:52 <jadrian> but doesn't work..
12:51:07 <Darius> jadrian: It worked for me (re instance Monad Bar2, instance Monad Bar1 gives an error)
12:51:26 <jadrian> Darius: oh, yes Bar2 works 
12:51:38 <jadrian> Darius: I thought you meant Bar1 would work with glasgow-exts
12:51:40 <Darius> jadrian: No you can't.  You can use a newtype instead, but that's the closest you can get.
12:52:29 <jadrian> Darius: is there any "easy to understand" motivation for this limitation?
12:53:14 <Darius> jadrian: You'd need to partially apply type synonyms to do it.  Allowing that allows something akin to a type-level lambda.  Allowing -that- makes type-inference/checking more... interesting...
12:53:18 <bourbaki> and whats wrong now with my line 24? do i need an Edge somewhere or so?
12:53:19 <bourbaki> http://paste.phpfi.com/40665
12:53:44 <jadrian> Darius: yeap, I always wondered I there was no type level lambda... :-/
12:54:41 <jadrian> Darius: for instance I can have  Monad (Either a)
12:54:58 <jadrian> Darius: but what if I wanted  Monad (\a->Either a b)
12:55:01 <Darius> jadrian: Well, here's a simple reason, type S f g x = f x (g x); type K a b = a.
12:55:10 <yrlnry> Hee hee.
12:55:21 <Darius> Though kinding might help somewhat.
12:56:31 <jadrian> right
12:58:34 <jadrian> Darius: what if it sticked to partial application?
12:59:17 <bourbaki> oh man finally :)
12:59:18 <Darius> jadrian: All you can do with combinators is (partially) apply them.
13:00:04 <jadrian> I mean just allow partial application of type constructors
13:00:08 <jadrian> like 
13:00:13 <jadrian> (Either _ b)
13:01:26 <jadrian> (if that's what you meant too, then I think I'm lost... and I'll think about it later)
13:03:02 <jadrian> nevermind
13:03:03 <Darius> I'm not sure what the ramifications of that would be.
13:03:08 <jadrian> that is already possible
13:03:22 <jadrian> with glasgow-exts and type synonyms we can do that
13:03:27 <Darius> Yes, you're right.
13:03:55 <jadrian> I wish we had simplified syntax for partial application
13:03:59 <bourbaki> is there a thing like map that tests all elements in a list with a certain function and if it passes adds it to the list otherwise kicks it out?
13:04:09 <Darius> filter
13:04:24 <Darius> or you can use a list comprehension (or do notation).
13:04:34 <TheHunter> jadrian, what's already possible?
13:04:46 <bourbaki> ah right ... 
13:04:57 <jadrian> TheHunter: define partial application of type constructors
13:05:12 <jadrian> TheHunter: e.g.
13:05:21 <jadrian> type Bar a = (,) a
13:05:26 <TheHunter> ok, thanks (i thought instance Monad (Either _ b))
13:05:44 <jadrian> yes you can do that to
13:05:57 <Darius> jadrian: You don't need a type synonym for ((,) a).
13:06:42 <jadrian> Darius: how would you write
13:06:44 <jadrian> instance Functor (Bar a) where
13:07:01 <jadrian> (with type Bar a = (,) a
13:07:04 <bourbaki> Darius: and how would i do it with list comprehensions?
13:07:04 <Darius> instance Functor ((,) a)
13:07:10 <jadrian> right
13:07:12 <jadrian> lol
13:07:26 <Darius> [x | x <- xs, predicate x]
13:07:29 <jadrian> ah
13:07:56 <jadrian> Darius: so I'm wrong...
13:07:59 <bourbaki> and only if predicate is true the x will be enlisted?
13:08:02 <TheHunter> type is just a macro like thingy, isn't it?
13:08:12 <Darius> TheHunter: Yes.
13:08:18 <jadrian> Darius: we don't have "arbitrary" partial application already
13:08:40 <Darius> jadrian: Yes, or at least I don't see it yet.
13:08:47 <jadrian> Darius: that is, I cannot have   Bar a = (,a)
13:09:36 <jadrian> seems like an harmless feature...
13:09:48 <jadrian> but admitedly I haven't given it much thought
13:10:08 <TheHunter> type Bar b a = (a,b) ?
13:10:21 <Darius> TheHunter: You can't partially apply type synonym.
13:10:23 <Darius> s.
13:15:03 <jadrian> by the way, did you see my email to haskell-cafe about Class synonyms?
13:15:12 <Darius> Yes.
13:15:17 <jadrian> Stefan solution does work
13:15:27 <jadrian> but seems overkill 
13:15:46 <jadrian> that is, what I'm doing is actually defining a new class
13:16:29 <jadrian> when all I wanted was harmless synonym for being an instance of a bunch of classes...
13:16:46 <jadrian> I don't feel that confortable using -fallow-undecidable-instances just to achieve that
15:03:19 <Philippa> any of the yi crew about? I'm having trouble building it
15:03:31 <Heffalump> the what?
15:03:43 <Philippa> those involved in developing yi
15:04:02 <Heffalump> I meant 'what's yi?'
15:04:19 <Philippa> ah
15:04:20 <Heffalump> ah, text editor thing.
15:04:24 <Philippa> yeah
15:04:35 <Philippa> I figured I'd give it a go as I was bored enough to boot into Debian
15:05:55 * Philippa blinks
15:06:02 <Philippa> OK, I know why (and that was daft of me, too)
15:08:05 <SamB> "bored enough to boot into Debian"?
15:08:13 <SamB> what do you mean by that?
15:08:42 <SamB> there are a lot of ways to interpret that, you know ;-)
15:08:50 <Philippa> I'm usually a windows user, and normally there's no good reason for me to boot Debian
15:08:58 <Philippa> playing with Ion and Yi are the only real excuses I have, tbh
15:09:41 <SamB> oh, okay, yeah. Personally I would use the term frustrated, except that I have seperate debian and windows boxes, and so really all I've got to do is switch my KVM switch.
15:10:01 <SamB> oh, and I wouldn't say I'm normally a windows user either.
15:10:22 <Philippa> I don't particularly like windows, but I like the apps I have there
15:10:39 <Philippa> (I don't think I use a single MS app regularly atm, with the possible exception of notepad as cat-inna-window)
15:10:46 <SamB> I like a few of them too, but thats not really why I have it...
15:10:56 <Philippa> the fact I'm a gamer does kinda tip the balance further
15:12:28 <SamB> My windows box is the only windows-running computer I actually own... well, except for an old 486 I got off of someone I know who didn't want it anymore.
15:12:49 <Philippa> currently this is the only PC I own
15:12:55 <Philippa> well, only functioning one
15:13:04 <SamB> wait, thats two 486s and two people I know if you count windows 3.1
15:13:40 <SamB> although I did kind of take the 3.1 box apart, didn't I?
15:13:53 <SamB> I wish I could remember why.
15:15:02 <SamB> anyway, those 486s got about as much use as the coco2 I used to have, which is to say, not much. Although at least they had nonvolatile storage devices.
15:18:23 <SamB> I've only had one other serious computer of my own before these two, and it ran RedHat.
15:19:41 <SamB> I would probably only have one computer and know a lot less if I had gotten windows originally
15:20:30 <Philippa> guess so - I started out on DOS rather than windows, at least
15:21:20 <SamB> although actually the whole point of getting a computer of my own was so that I could run linux -- the family computer had some funky wrapper around the whole drive so that nothing but DOS (95, actually) could boot on it
15:22:14 <SamB> or read it
15:22:21 <Philippa> nasty
15:22:27 <basti_> i wont say what my first computer was like.
15:22:31 * jadrian showed his familly who's in charge and moved'em all to linux :P
15:23:06 <SamB> jadrian: well it so happens that I am not in charge
15:24:02 <SamB> and my Dad needs windows for work, too. Especially now that he's moving off mainframe programming.
15:24:44 <SamB> the company is trying to get all its stuff off the mainframe.
15:26:56 <SamB> I can't help but wonder if the TCO of windows will negate any cost savings they might hope to get, but I don't know how much mainframes cost to timeshare on either...
15:32:38 <SamB> first they charge you left and right for the OS and the software you need to get stuff done, and then the all of that needs you to help it limp along before it will actually work together properly, and then it still has a bunch of problems...
15:32:56 <Philippa> ah well
15:33:04 * Philippa boots back into windows to continue hacking on Flippi instead
15:33:56 <SamB> that is a new one
15:34:02 <SamB> Lost terminal, huh.
15:34:50 <SamB> I wouldn't expect a rudely interrupted IRC client to be so informative
15:35:03 <Heffalump> it's not particularly new, TTBOMK
15:35:13 <SamB> Heffalump: well, I meant new to me
15:35:18 <Heffalump> it probably got a HUP
15:35:47 <psi> TTBOMK? that's new to ME :)
15:35:56 <Heffalump> To The Best Of My Knowledge
15:35:59 <psi> ah
15:36:41 <Heffalump> hmm
15:37:47 <Heffalump> oh well.
15:37:54 * Heffalump fails to reproduce the lost terminal
15:39:19 <SamB> how were you trying?
15:40:59 <TheHunter> hmm
15:58:10 <Itkovian> @seen shapr
15:58:10 <lambdabot> I saw shapr leaving #darcs 9 hours 37 minutes 58 seconds ago.
16:00:19 <Oejet> Hello, does anyone know of a program using extensivly the Control.Concurrent.QSem functions?
16:05:57 <Oejet> Hm, maybe I'll just implement one myself. :-)
16:29:20 <musasabi> Sometimes I looked at the modules and saw that they just used MVars and lived happily with MVars ever after.
16:30:13 <Oejet> Yeah, they just use MVars.
16:33:00 <Oejet> I want to benchmark the MVars/QSem implementation.  I was thinking about writing some barrier for a couple of thousand threads.
16:39:21 <Igloo> Hmm, should a StateT transformed Identity monad have different strictness to the State monad?
16:40:14 <Lor> Ah.
16:40:21 <Lor> There are uses for both strict and lazy transformers.
16:40:57 <Lor> Once I got bitten by the strictness of the standard StateT so I had to modify it to get a lazy version. Just adding tildes to the patterns.
16:41:12 <Lor> Actually, it was RWST.
16:41:17 <ibid> what's the fancy word for allowing ones opponent to win by withdrawing?
16:41:25 <Lor> Yield?
16:41:27 <Heffalump> isn't State defined in the same place as StateT, with the same strictness?
16:41:31 <Heffalump> concede?
16:41:34 <psi> resign
16:41:36 <Heffalump> resign?
16:41:52 <Igloo> StateT uses (x, s') <- runStateT m s of the parent monad
16:41:53 <ibid> Lor: yield, resign and concede are not the words i'm looking for :(
16:41:54 <Igloo> State uses let
16:42:07 <ibid> i know there is a certain word but i can't remember or find it myself...
16:42:20 <Heffalump> I think I know the one you mean, but I can't remember the word itself.
16:42:26 <Heffalump> </helpful>
16:42:28 <ibid> :)
16:42:49 <Heffalump> it's what people do in elections.
16:43:04 <Igloo> But Identity looks lazy to me
16:44:07 <Igloo> surrender?
16:44:41 <Lor> surrender, give up, give in, knuckle under, submit, cede, cry quits, throw in the towel, capitulate, succumb, raise the white flag; give up, surrender, give over, hand in, abandon, relinquish, renounce, cede
16:44:49 * Lor reads the thesaurus.
16:44:58 * ibid has already browsed a thesaurus :)
16:45:42 <Heffalump> capitulate sounds good.
16:45:52 <Heffalump> as does renounce
16:45:53 <ibid> yeah
16:45:59 <ibid> but not *the* word
16:46:15 <ibid> i'll use capitulate if i can't find *the* word
16:46:18 <Lor> forgo?
16:47:44 <ibid> no
16:48:19 <Lor> Can you give some specific context that you associate the word with?
16:48:39 <ibid> i believe Heffalump got it right: 02:42  <Heffalump> it's what people do in elections.
16:49:52 <Lor> waive?
16:50:20 <Heffalump> I take it you don't mean boycott, btw.
16:50:52 <ibid> yeah
16:51:22 <ibid> yield, concede and capitulate have the general meaning right
16:51:43 <ibid> there's just a certain word that *sounds* right for what i want to do
16:51:50 <Lor> acquiesce?
16:51:58 <ibid> but i've moved on and used capitulate, thanks all :)
16:52:01 <ibid> Lor: no
16:53:26 <Lor> "accede" and "defer" haven't been mentioned yet, but they're in the thesaurus too.
16:53:38 <dons> wli: you wish yi wouldn't use weird extensions? Cit doesn't even use -fglasgow-exts by default?
17:16:44 <dons> ok. time for some yi hacking
17:39:54 <bourbaki> moin
18:08:55 <bourbak1> can someone help me on instance (Show s, Show t, Show n) => Show (Edge (s,t,n)) where ... whats wrong with that? he tells me that the Edge was applied to too many arguments its newtype Edge = Edge (Node,Node,String)
18:09:45 <Igloo> It should be instance Show Edge where ...
18:10:31 <bourbak1> hm and why is that?
18:10:32 <Igloo> What you've written is closer to what would be needed for newtype Edge s t n = Edge (s, t, n)
18:10:42 <bourbak1> ah ok
18:12:12 <bourbak1> thanks :)
18:20:29 <bourbak1> hm and how do i get a sting from that?
18:21:11 <bourbak1> i try something like "start: " ++ s ++ ... ++ n ++ ... where s is an Int and n a String
18:22:38 <SyntaxNinja> @type show
18:22:39 <lambdabot> show :: forall a. (Show a) => a -> String
18:23:22 <bourbak1> and how can i get an Int to a String then?
18:24:10 <SyntaxNinja> use the show function.
18:25:22 <SyntaxNinja> if it doesn't work right away, try using more parens
18:25:23 <bourbak1> ah heh sounds reasonable
18:38:34 <bourbak1> http://paste.phpfi.com/40710
18:43:15 <bourbak1> any idea how i could make the list that gets printed haveing no leaks in the number sequence?
18:48:46 <heatsink> bourbak1: what is this supposed to do?
18:49:44 <bourbak1> i want to merge graphs with the topological sum
18:50:04 <bourbak1> and then build the quotient space of them to get a new interconnected graph
18:50:24 <heatsink> hmm, i don't know that much ablout graphs
18:50:26 <bourbak1> i just want to name the nodes in order that is atm i get something like
18:50:46 <bourbak1> 0 1 3 instead of 0 1 2 for the integer numbers of the nodes
18:54:15 <heatsink> It looks to me like you name the nodes with constants, in the source code.  But I might be missing something.
18:54:26 <heatsink> Have you tried making the example smaller?
18:55:14 <bourbak1> its just two graphs consisting of one edge each
18:55:51 <bourbak1> the string labels dont matter really what matters is the Int number in the Node thats the unique identifier
18:57:04 <Lemmih> @seen bringert
18:57:05 <lambdabot> I saw bringert leaving #haskell.se 1 day 10 hours 26 minutes 20 seconds
18:57:05 <lambdabot> ago.
18:57:56 <Lemmih> @seen shapr
18:57:56 <lambdabot> I saw shapr leaving #darcs 12 hours 37 minutes 44 seconds ago.
19:11:10 <Gahhh> MegaMonad: Good evening
19:11:16 <MegaMonad> Gahhh: Good evening #haskell!
19:11:22 <Gahhh> yay
19:12:42 <Lemmih> heh.
19:26:28 <Oejet> Hello, Lemmih.  Ain't you up a bit over your bed time?
19:27:03 <Lemmih> Oejet: I just woke up 20mins ago.
19:27:21 <Oejet> Oh, I'd better get to bed. :-/
20:13:19 <CosmicRay> hell pewk
20:22:50 <CosmicRay> err s/hell/hello/
20:22:52 <CosmicRay> sorry :-)
20:23:40 <SyntaxNinja> y0 CosmicRay
20:23:47 <CosmicRay> hi syntaxninja
20:24:14 <Lemmih> How's code?
20:24:25 <CosmicRay> trying to decide what to do next.
20:24:43 <CosmicRay> I'm thinking of a zip implementation, gopher client, or some utilities for writing daemons
20:25:21 <Lemmih> CosmicRay: What about an in-memory database backend for HaskellDB?
20:25:39 <CosmicRay> Lemmih: no interest for me, sorry :-)
20:25:48 <CosmicRay> though a gdbm interface would be good
20:26:03 <Lemmih> CosmicRay: Doesn't greencard come with such a thing?
20:26:07 <CosmicRay> hmm
20:26:34 <CosmicRay> I'll have to look into that
20:27:26 <SyntaxNinja> seen on planet debian:  A girl offered me root on a sun box today if I would dance.  It was the most amazing thing ever.
20:27:26 <SyntaxNinja> ps. drunk
20:27:46 <CosmicRay> SyntaxNinja: you or the article author?
20:29:51 <SyntaxNinja> heh him. not me.
20:30:12 <SyntaxNinja> although from the sounds coming from outside, I'm in the vicinity of drunk people.
20:30:26 <CosmicRay> heh
20:32:16 <SyntaxNinja> MegaMonad: are you in the vicinity of drunk people?
20:32:22 <MegaMonad> SyntaxNinja: What i want people to work drunk.
20:32:39 <SyntaxNinja> MegaMonad: are you drunk?
20:32:45 <MegaMonad> SyntaxNinja: I want someone to say "when you're drunk you just told me that the morphism part of writing the compiler says it sometimes impossible for me in the c64 ..
20:35:36 <CosmicRay> SyntaxNinja: I'd say yes :-)
20:35:56 <SyntaxNinja> heh. "you, or the robot"? ;)
20:38:59 <CosmicRay> <grin>
20:46:02 <jdrake> man these 'ghasts' keep getting me with their 'blind iv'
20:51:25 * CosmicRay didn't understand that sentence
21:28:59 <yrlnry> megamonad, what is the ultimate nature of truth?
21:29:05 <MegaMonad> yrlnry: Heatsink: the program could possibly give you the truth, i don't know anything about the nature of truth?
21:30:06 <SyntaxNinja> MegaMonad: yes, but what program?!
21:30:12 <MegaMonad> SyntaxNinja: Cabal isn't building there because the program read the 2nd argument of a, then i can 'give' happy a syntax demo if you're looking into caml about the program.
21:30:56 <heatsink> You do know the nature of truth, you just don't know that you know.
21:31:26 <SyntaxNinja> MegaMonad: I can never decide whether to capitalize Cabal.  What do you think?
21:31:32 <MegaMonad> SyntaxNinja: Cabal needs to think whether we get nailed for years.
21:31:40 <Lemmih> SyntaxNinja: Where did you put the Hackage page?
21:32:15 <SyntaxNinja> Lemmih: I haven't yet.
21:47:25 <SyntaxNinja> Lemmih: http://www.haskell.org/cabal/hackage/
22:34:10 <jesse98> grr, hugs seems to do a lame job handling tabs
22:34:32 <jdrake> hey jesse, do you know much about hugs?
22:34:41 <jesse98> i wouldnt say that
22:35:02 <jdrake> I have the school of expression book, but I need to get the graphics library compiled and working
22:48:23 <irce> jesse98: yes it sucks
22:49:22 * Lemmih didn't find any tabs last time he used Hugs.
22:50:06 <jesse98> you may find them in your source files Lemmih
22:50:17 <jesse98> i find them in mine -)
22:51:15 <Lemmih> Ah those tabs...
23:03:09 <irce> well maybe I just can't .. 
23:25:40 <jesse98> can anyone help me with a type error? code is at http://paste.lisp.org/display/4306 with the error message at the bottom
23:28:21 <ne1> which line is 48?
23:28:42 <jesse98> oh sorry, i'm used to another paste site and didnt notice the lack of line numbers
23:28:56 <jesse98> it's the grand_parents definition
23:29:17 <ne1> Ah, there is a checkbox to add line numbers I can use.
23:32:20 <ne1> maybeToMonad (mother s) >>= parent  -- this has type Maybe Sheep
23:32:41 <jesse98> yeah, I finally found it
23:32:55 <jesse98> should be using the more general parents function
23:32:55 <ne1> you were probably thinking of maybeToMonad (mother s >>= parent)
23:33:11 <jesse98> instead of parent which returns Maybe
23:33:35 <jesse98> these damned errors are still kicking my ass...
23:34:11 <ne1> I am not sure why you want to generalize grand_parents etc. but keep parent,mother,father special to Maybe.
23:34:28 <jesse98> well, it isnt production code ne1 :-)
23:34:34 <ne1> I would normally think one would either make them all general or make them all special.
23:35:05 <jesse98> it's from a monads tutorial where the code is progressively rewritten
23:35:21 <ne1> aha
