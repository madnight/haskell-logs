01:17:42 <boegel> hey #haskell
01:29:34 <wli> I need to figure out the GUI crud
01:32:59 <musasabi> hmm?
01:33:41 <wli> musasabi: trying to plot some statistics reported by the kernel in realtime (not hard RT or anything, just updated periodically)
01:36:29 <wli> okay, I can't run the examples =(
01:36:36 <wli> Loading package GLUT ... can't load .so/.DLL for: glut (/usr/lib/libglut.so: undefined symbol: glXBindChannelToWindowSGIX)
01:38:08 * wli prays upgrading glut libs doesn't break anything
01:38:52 <musasabi> glut sounds hard..
01:39:09 <wli> okay, it magically works now
01:39:18 <wli> maybe not 
01:39:26 <wli> okay, I think it's working
01:40:13 <wli> what I want to do is infinitely stupider than the Cube thing
01:40:21 <magnus--> How hard is it to serialize and unserialize haskell data?
01:40:33 <magnus--> or how easy? :)
01:40:56 <wli> magnus: data ... = ... deriving (Eq, Ord, Read, Show)
01:41:16 <wli> magnus: or if you're using the word "serialize" correctly, c.f. MVar in the library documentation.
01:42:00 <magnus--> wli: I just mean saving and loading data without writing special code
01:42:08 <wli> magnus: marshalling
01:42:16 <wli> magnus: c.f. Read and Show
01:42:27 <magnus--> Aha
01:42:30 <magnus--> thanks
01:42:40 <wli> magnus: it's trivial and quite often defined for data structures without any explicit programming
01:42:57 <magnus--> that's good
01:43:11 <wli> magnus: check on derived instances
01:43:49 <magnus--> I'm checking Read and Show first
01:44:21 <musasabi> (actually marshalling is not trivial)
01:44:31 <wli> perhaps not
01:44:38 <musasabi> but certainly doable.
01:44:47 <wli> but a fair number of instances are taken care of for the programmer
01:45:24 <wli> I see the Cube example
01:45:29 <wli> but I'm completely baffled by it
01:48:58 <musasabi> hmm?
01:49:15 <wli> there's an example of a rotating cube
01:49:19 <wli> thus far
01:49:27 <wli> I'm completely blown away by it
01:49:33 <wli> Not a single clue what any of it is doing.
01:50:08 <Lemmih> Maybe it would be simpler to use wxHaskell.
01:50:27 <wli> all I need is some spline stuff
01:50:52 <wli> "here are some points, display"
01:54:15 <bourbaki> moin moin
01:56:41 <boegel> hey bourbaki 
01:57:19 <bourbaki> sup boegel
02:02:59 <musasabi> hmm building debian packages seems harder each passing day.
02:03:08 <wli> you're telling me
02:03:42 <musasabi> libghc6-cabal-dev is too old to build hs-fltk properly => install new cabal => haskell-devscripts don't work with it => frustration
02:04:13 <musasabi> --install-prefix deprecation is biting me mostly.
02:15:42 <boegel> bourbaki: sup ?
02:18:39 <bourbaki> whatsup :)
02:18:41 <srid> hello all
02:18:49 <boegel> bourbaki: oooooooooooh :p
02:18:58 <srid> What book/tutor/ebook you all used for learning haskell? 
02:19:07 <boegel> bourbaki: a few days ago we were exchanging pictures
02:19:12 <boegel> do you have a pic of yourself ?
02:20:23 <boegel> srid: Haskell School of Expression
02:20:52 <bourbaki> yep on my website
02:21:34 <boegel> bourbaki: show us !
02:22:06 <bourbaki> http://codemages.sourceforge.net/main.html
02:23:50 <boegel> bourbaki: there's only one pic there :p
02:24:10 <bourbaki> yes
02:25:22 <bourbaki> http://codemages.sourceforge.net/snaps/ there are some more ;) even slightly more up to date
02:26:15 <boegel> bourbaki: idd your long hair is gone ! ;)
02:27:02 <bourbaki> heh yeah
02:28:06 <wli> looks like I can tell the thing to sample some reported kernel value by giving a (filename, fieldname) pair
02:28:40 <wli> how how the heck do I get a spline...
02:29:37 <wli> well, might as well teach it about things
02:31:20 <wli> I guess I want the user to define vars like
02:31:45 <wli> foo := someFile someField someColumn
02:31:54 <wli> bar := otherFile otherField otherColumn
02:32:14 <wli> plot sampleInterval foo bar
02:32:32 <wli> and foo and bar get some spline curve updated every sample interval
02:32:51 <wli> except I don't know how to draw yet
02:33:17 <bourbaki> this is cool http://www.perwass.de/CLU/CLUCalcDoc/index.html
02:33:27 <bourbaki> why doesnt anyone do something like that in haskell?
02:36:55 <boegel> bourbaki: who says nobody _is_ doing stuff like that in Haskell ?
02:37:13 <bourbaki> boegel: have you seen this? http://www.haskell.org/hawiki/ExistentialTypes
02:37:35 <bourbaki> well there is still the slim chance that someone does yes but i havent seen him yet :)
02:37:38 <bourbaki> orher
02:37:44 <bourbaki> or it
02:39:35 <boegel> bourbaki: I have now, but what's the difference with type classes ?
02:39:47 <boegel> data Object = Sphere | Plane
02:39:56 <boegel> and then provide type classes for each type of object
02:40:58 <bourbaki> you can build heterogenous lists with it
02:41:48 <Lemmih> And you can generate segmentation faults (-:
02:41:55 <boegel> so can I, with using [Object]
02:44:57 <tintin> i i have access to some commercial c libraries can i make haskell use those ? 
02:45:01 <tintin> *if
02:45:20 <Cale> tintin: yes, of course - use the ffi
02:45:47 <tintin> tnx Cale let me go look it up
02:47:14 <musasabi> Haskell ffi is very nice as compared to many other languages.
02:49:04 <bourbaki> ive seen some example package of haskell once which included lattices and a simple prolog interpreter
02:49:19 <bourbaki> does any one know what package that could have been?
02:50:35 <Lemmih> bourbaki: Hugs?
02:51:06 <bourbaki> yeah i guess :)
02:51:43 <Lemmih> Hugs ships with an example Prolog interpreter, iirc.
02:51:52 <bourbaki> yep
02:52:20 * wli boggles confusedly at the hOpenGL docs.
02:53:32 <mflux_> wli, do you have an url to the cube-example? (no, I know nothing about hopengl, but some c-opengl and interested in seeing the mapping)
02:54:47 <wli> it's /usr/share/doc/ghc6-hopengl/examples/Cube.hs.gz
02:54:54 <wli> in the debian pkg
02:55:07 <mflux_> ok
02:55:08 <wli> I'm rather stumped as to how to draw a spline
02:55:24 <wli> the drawing stuff seems to involve 3D objects
02:55:46 <mflux_> I think opengl provides 2d-versions of most if not every drawing operation
02:55:58 <Lemmih> wli: Maybe you should read Sven Penne's tutorial if you have no experience with OpenGL.
02:56:19 <wli> I have no experience with graphics of any kind
02:56:27 <mflux_> but it may be so that opengl-examples rarely deal with 2d
02:57:43 <wli> I've never written anything in X either
02:57:49 <wli> hmm
02:58:27 <wli> except one thing that drew a polar coordinate butterfly of higher quality (i.e. more like a real butterfly) than most of the trig poly butterflies.
02:58:27 <mflux_> well, the example doesn't seem that difficult, atleast once you've grasped opengl
02:58:28 <Lemmih> wli: Many of the RedBook examples are 2D.
02:59:25 <wli> I almost assuredly don't grasp opengl
03:00:30 <wli> I may be better off convincing a graphics-type person to do it in C then porting it
03:07:17 <magnus--> wli: for 2d, coordinates are normally from -1 to 1 in both x and y axis. then just
03:08:39 <wli> polynomial interpolate and hand it Bernstein poly coefs?
03:08:42 <magnus--> call glBegin(GL_LINE_STRIP); and for each vertex call glVertex2d(x, y); and then end with a call to glEnd();
03:09:01 <magnus--> that's for lines. I don't know if there is spline support
03:09:30 <wli> I'm confused by that answer.
03:09:39 <magnus--> where does the confusion start?
03:10:03 <wli> what you have in mind for vertices
03:10:16 <wli> Sven Panne's page says it wants control points
03:11:47 <magnus--> I didn't find his page
03:12:54 <magnus--> I don't know how his haskell binding works, but the basic idea in opengl is that for each graphics primitive, the procedure for drawing it is as follows:
03:12:58 <wli> some redbook thing
03:14:29 <magnus--> in C-like pseudocode: glBegin(THE_GRAPHICS_PRIMITIVE_YOU_WANT); for each point (x,y) { glVertex2d(x,y); } glEnd();
03:15:41 <magnus--> if you want to draw a GL_TRIANGLE then you'd call glVertex once for each corner
03:16:58 <magnus--> if you want to draw a GL_LINE_STRIP then you'd call glVertex2d once for each point in the line strip
03:17:22 <wli> and I just redraw from scratch for screen updates?
03:17:38 <magnus--> yes
03:18:29 <magnus--> but start with glClear(GL_COLOR_BUFFER_BIT);
03:18:54 <magnus--> this clears the color buffer
03:19:37 <magnus--> otherwise you keep drawing on the old contents
03:20:33 <magnus--> the clear color can be changed with glClearColor
03:21:37 <wli> I'm going to have to get decent data streams 
03:22:42 <magnus--> gl is very much like a state machine which you send commands to
03:23:25 <wli> how would I, say, have a window refreshing while a command-line interpreter is still accepting input?
03:24:10 <magnus--> I'm not sure, it sounds like that'd require threads but i have never done this so i wouldn't know for sure
03:27:48 <musasabi> I think I finally got the debs working ^_^
03:34:00 <wli> oh yeah
03:34:03 <wli> I need deltas
03:34:12 <wli> difference operators on streams or whatever
03:46:05 <wli> hm, string literals in parsec are hard
03:54:07 <wli> maybe not
03:54:08 <wli> strlit = do                                        
03:54:08 <wli>                 s <- many $ oneOf [c | c <- [minBound..maxBound], c /= '\"']
03:54:08 <wli>                 read $ "\"" ++ s ++ "\""      
03:57:56 <bourbaki> boegel: http://www.science.uva.nl/~leo/clifford/CGA3.pdf
03:59:01 <xerox> hi.
04:00:23 <Lemmih> Hey
04:01:21 <Lemmih> wli: A combinatin of getInput, setInput and reads might be prettier.
04:03:28 <Lemmih> do { tok <- getInput; case reads tok of [(val,tok')] -> setInput tok' >>= return val; _ -> fail "no parse" }
04:12:42 <boegel> bourbaki: thanks !
04:13:23 <bourbaki> np
04:30:02 * Lemmih wonders if profiling is possible with TH.
04:39:27 <musasabi> Anyone wanting to test hs-fltk debs at http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/ ?
04:44:16 <Heffalump> what stuff are you doing that needs the recent Cabal, btw?
04:46:00 <wli> *Main> parseLine 1 "x <- d(\"/proc/vmstat\", \"pgfault\")"
04:46:00 <wli> Right (Bind "x" "d" "/proc/vmstat" "pgfault" Nothing)
04:46:06 <wli> looks like it's going somewhere
04:48:16 <musasabi> Heffalump: c-sources in subdirectories and extra-lib-dirs
04:49:16 <musasabi> and living without extra-lib-dirs is not possible on platforms where libfltk is not in the default library path (e.g. gentoo)
04:50:34 <Heffalump> ah
04:51:00 <musasabi> The cabal parser sadly dies instead of emitting a warning if it encounters an unknown fieldname.
05:39:38 <wli> okay, looks like things are going
05:40:15 <wli> 1> x <- d("/proc/vmstat", "pgmajfault")
05:40:15 <wli> 2> y <- d("/proc/vmstat", "pgfault")
05:40:31 <wli> (... slow interpretation)
05:40:47 <wli> 3> plot 10 x y
05:40:47 <wli> 277641  1059397897
05:40:47 <wli> 277641  1059399239
05:40:49 <wli> ...
05:41:29 <wli> I need to interpret the leading "d" as differencing and so on.
05:44:47 <wli> or maybe I should use a number
06:01:50 <wli> polytwine :: [[t]] -> [t]
06:01:56 <wli> polytwine [] = []
06:02:35 <wli> polytwine (h:t) = case h of { [] -> polytwine t ; (x:xs) -> x : polytwine (t ++ [xs]) }
06:04:17 <wli> the burning question is actually what happens when I get thunked reads
06:04:56 <wli> diff' ns = zipWith diff'' (tail ns) ns where diff'' m m' = do { k <- m ; k' <- m' ; return $ k - k' }
06:05:06 <wli> diff k ns = (iterate diff' ns) !! k
06:05:40 <wli> I don't want to sequence_ the things
06:05:42 <wli> but rather
06:05:55 <wli> start emitting differences lazily ASAP
06:06:15 <wli> I highly suspect that k-th difference bit breaks in that respect
06:09:42 <TheHunter> wli, you're duplicating side effects with that definition.
06:10:02 <wli> that's largely what I was going on about
06:10:27 <TheHunter> is that supposed to be an IO monad?
06:10:35 <wli> yeah, it's an io monad
06:10:44 <wli> it's reading from a file
06:10:53 <TheHunter> maybe unsafeInterleaveIO is an option.
06:11:06 <wli> sounds unlikely
06:11:53 <wli> there's a way to lazily do k-th differences
06:13:25 <wli> I can think of one that leaks space
06:16:53 <TheHunter> how about type MyList a = (a, IO a), zipWith' :: (a -> b -> c) -> MyList a -> MyList b -> MyList c?
06:17:45 <TheHunter> err, ... -> IO (MyList c)
06:19:53 <wli> map (\m -> do { (xs, _) <- m ; return $ reduceDiff xs }) $ iterateM step (replicate k 0, repeat m) where { step (xs, (m:ms)) = do { y <- m ; return (take k (y:xs), ms) } ; reduceDiff [x] = x ; reduceDiff xs@(_:_:_) = zipWith (-) (tail xs) xs }
06:20:11 <wli> still not 100% sure on that
06:21:19 <wli> feh
06:21:34 <wli> reduceDiff xs@(_:_:_) = reduceDiff $ zipWith (-) (tail xs) xs
06:23:03 <wli> liftM (reduceDiff . fst)
06:26:06 <wli> blah k ns = map (liftM $ reduceDiff . fst) $ iterateM (\(xs, (m:ms)) -> do { x <- m ; return (x : init xs, ms) }) (replicate k 0, ns)
06:41:48 <wli> hmm, looks like it's sharing *too much* now
06:46:20 <TheHunter> unsafeSequence :: [IO a] -> IO [a]
06:46:21 <TheHunter> unsafeSequence []     = return []
06:46:21 <TheHunter> unsafeSequence (x:xs) = liftM2 (:) x (unsafeInterleaveIO $ unsafeSequence xs)
06:46:42 <wli> why do you think this will do any good?
06:46:58 <wli> if anything, I need more safety, not less
06:47:28 <TheHunter> you are processing a list of IO actions, right?
06:47:39 <wli> yes
06:47:51 <TheHunter> the thing is, readFile is a lazy read and already uses unsafeInterleaveIO under the hood.
06:48:09 <TheHunter> so a bit more forced lazyness probably doesn't really do much harm.
06:49:41 <wli> I don't know, I steer clear of unsafe*IO
06:50:14 <Heffalump> so you don't use readFile?
06:50:18 <TheHunter> it's unsafeInterleaveIO, not unsafePerformIO.
06:50:31 <wli> there was a *
06:50:45 <wli> Heffalump: that's in the libs
06:50:56 <Heffalump> right, but it uses unsafeInterleaveIO under the hood
06:51:11 <Heffalump> (unless I'm thinking of hGetContents)
06:51:25 <TheHunter> the alternative involves a lot of bookkeeping to keep track of what actions are already performed and possibly redefining some list functions.
06:51:59 <wli> I'll stick to that even if it's the hard way.
06:53:39 <Heffalump> unsafeInterleaveIO is fine if you are happy with IO actions happening out-of-order
06:57:43 <wli> list manipulations are off
07:01:33 <TheHunter> anyhow, it's remarkable how often you need monadic lists to be MList m a = m (1 + a * MList m a) instead of m [a].
07:04:13 <wli> well, this thing is repetitively doing readFile
07:07:59 <basti_> hi
07:08:12 <Lemmih> Hey basti_
07:08:38 <wli> thus far I have:
07:08:40 <wli> let { reduceDiff [x] = x ; reduceDiff xs@(_:_:_) = reduceDiff $ zipWith (-) (tail xs) xs ; iterateM f x = iterate (\x -> do { y <- x ; f y }) (return x) ; blah k ns = map (liftM $ (\(x,_) -> (x,reduceDiff x))) $ iterateM (\(xs, (m:ms)) -> do { x <- m ; return (tail xs ++ [x], ms) }) (replicate (k+1) 0, ns) } in foldM_ (\m' m -> do { _ <- m'; n <- m ; return $ print n}) (return ()) . blah 1 $ repeat (do { usleep (100*1000) ; s <- readFile "/proc/vmstat" ; return . 
07:08:51 <wli> . filter (\ws -> length ws >= 2 && head ws == "pgfault") . map words . lines $ s })
07:16:51 <wli> well, what I end up taking the differences of are:
07:17:03 <wli> ([0,0],0)
07:17:03 <wli> ([0,1061712695],1061712695)
07:17:03 <wli> ([1061713020,1061713020],0)
07:17:03 <wli> ([1061713020,1061713020],0)
07:17:03 <wli> ([1061713020,1061713020],0)
07:17:03 <wli> ([1061713341,1061713341],0)
07:18:05 <tuomov> anyone know of a tool that would try to dig out title/author info from ps/pdf?
07:19:14 <wli> it's reading too fast
07:19:18 <wli> usleep is returning early
07:19:58 <wli>  worse
07:20:19 <wli> if I print it immediately after I read it the behavior changes
07:20:31 <wli> i.e. it starts working
07:22:05 * wli drops in a \x -> writeFile "/dev/null" (show x) >> return x
07:23:34 <wli> "fixed" so to speak
07:25:50 <Heffalump> wli: you should stop using readFile, then.
07:25:57 <Heffalump> You're actually being bitten by the laziness of the read.
07:26:04 <Heffalump> what are you readFileing?
07:28:08 <wli> Heffalump: why's that?
07:28:30 <wli> Heffalump: /proc/vmstat
07:29:07 <Heffalump> cos readFile indirectly uses unsafeInterleaveIO (I believe)
07:29:14 <Heffalump> so the read only happens when the data is wanted
07:29:21 <Heffalump> which sounds dangerous with something from /proc
07:30:15 <wli> I found a place to put $!
07:30:30 <wli> *Main> let { reduceDiff [x] = x ; reduceDiff xs@(_:_:_) = reduceDiff $ zipWith (-) (tail xs) xs ; iterateM f x = iterate (\x -> do { y <- x ; f y }) (return x) ; blah k ns = map (liftM $ (\(x,_) -> (x,reduceDiff x))) $ iterateM (\(xs, (m:ms)) -> m >>= (\x -> return (tail xs ++ [x], ms))) (replicate (k+1) 0, ns) } in foldM_ (\_ m -> m >>= print) () . blah 1 $ repeat (sleep 1 >> readFile "/proc/vmstat" >>= (\s -> return . read . head . map (!!1) . filter (\ws -> len
07:30:39 <wli> = "pgfault") . map words . lines $! s))
07:31:56 <TheHunter> id $! [1, error "foo"] ==> [1, error "foo"]
07:32:15 <TheHunter> it's better to use "last s `seq` ...".
07:32:34 <wli> well, it does work
07:32:58 <TheHunter> because the file is short enough that a read of the first byte gives you the whole file, i suppose.
07:33:14 <Heffalump> oh, ick, that is very dangerous
07:33:25 <Heffalump> you should really do last s `seq` if you don't want odd behaviour :-)
07:34:13 * TheHunter is away: I'm busy
07:36:09 <wli> better yet
07:37:08 <wli> import Prelude hiding (readFile).... readFile f = let s = Prelude.readFile f in last s `seq` s or some such
07:40:37 <Heffalump> sounds good
07:40:58 <Heffalump> though I expect there is a way of reading from a file that is actually strict that you should use instead
07:41:04 <wli> I'll have to fiddle a bit with things
07:41:12 <Heffalump> rather than using the one that jumps through hoops to make it lazy and then more hoops to make it strict again :-)
07:41:41 <wli> readFile is actually not far from what should happen
07:41:58 <wli> but I've not done the rest of what I need to do yet (of course)
07:42:15 <wli> which is avoiding rereading files once per field extracted from them
07:44:27 <wli> I should really only need to force evaluation of the fields extracted from them.
07:45:31 <wli> hm, maybe not
07:45:42 <wli> the kernel regenerates the whole thing in-core for each distinct read op
07:46:03 <wli> one quick strict read is best
07:46:03 * TheHunter is back (gone 00:11:50)
07:52:15 <wli> well, after I finish up the differencing stuff in the interpreter I'll have to do the plotting parts
08:35:25 <MegaMonad> Hello. Simon marlow?
08:35:36 <Heffalump> hi CosmicRay
08:35:39 <CosmicRay> MegaMonad: I don't think Siman IRCs.
08:35:43 <CosmicRay> good morning, heffalump.
08:35:44 <Heffalump> he did briefly
08:35:48 <MegaMonad> CosmicRay: What happened to you. I don't think siman ircs.
08:35:49 <Heffalump> dpkg-gencontrol: warning: unknown substitution variable ${haskell:Depends}
08:35:58 <Heffalump> should that happen for architecture independent packages?
08:36:01 <CosmicRay> wow, megamonad knows something I don't.  that's scary.
08:36:13 <CosmicRay> Heffalump: do you have a hugs package?
08:36:24 <Heffalump> I'm trying to build one, yes
08:36:46 <CosmicRay> hmm.  
08:36:48 * CosmicRay checks
08:36:59 <Heffalump> I'm just building MissingH to see if that does it too, but it's quite big
08:37:09 <wli> what would be a super-strict alternative to readFile?
08:37:42 <bourbaki> Heffalump: theres a new puh film in the cinema with Heffalumps :)
08:37:49 <CosmicRay> wli: binary block i/o
08:38:00 <wli> that's a bit cumbersome =(
08:38:06 <CosmicRay> Heffalump: if you name the package libhugs-foo, it should be ok
08:38:29 <CosmicRay> wli: there are two libraries to make it less so.
08:38:33 <CosmicRay> wli: Peter's BlockIO
08:38:37 <CosmicRay> wli: and my MissingH.IO.Binary
08:38:37 <Heffalump> hmm, ok, maybe I'd called it libhugs-foo-dev at the time.
08:38:46 <Heffalump> (I just realised it wasn't supposed to be that and changed it)
08:38:47 <CosmicRay> Heffalump: ahh, libhugs-foo-dev should be ok too
08:38:49 <wli> well, ultimately I just want strictReadFile
08:38:55 <CosmicRay> Heffalump: since there seemed to be both
08:38:58 <Heffalump> oh, well it wasn't :-)
08:39:03 <CosmicRay> wli: you want something to load an entire file into memory?
08:39:05 <Heffalump> what's the logic for not having the -dev?
08:39:15 <wli> CosmicRay: they're small files
08:39:19 <CosmicRay> Heffalump: because the package would be required to run any hugs program that uses it
08:39:25 <CosmicRay> wli: what's the problem with reading them lazily?
08:39:34 <wli> CosmicRay: the results are gibberish
08:39:52 <CosmicRay> Heffalump: for instance, if I install libghc6-missingh-dev, I can build binaries using it, and the resulting binaries don't require missingh to be installed
08:39:55 <CosmicRay> Heffalump: that's not the case with hugs
08:40:02 <Heffalump> right, ok
08:40:07 <CosmicRay> wli: gibberish?  you're dealing with plain files, right?
08:40:22 <Heffalump> no, he's reading /proc/vmstat
08:40:30 <wli> CosmicRay: it's polling the things periodically; if evaluation isn't forced for prior results it all goes to hell
08:40:35 <CosmicRay> ah.
08:40:38 <wli> well, those are plainer than many files
08:40:38 <CosmicRay> right.
08:40:45 <wli> but they change often
08:40:49 <wli> and so on
08:40:59 <CosmicRay> wli: I'd say this recipe may do it:
08:41:02 <CosmicRay> do x <- readFile "foo"
08:41:14 <wli> last x `seq` x?
08:41:16 <CosmicRay>    return $ x `seq` x
08:41:25 <Heffalump> x `seq` x isn't good enough
08:41:42 <Heffalump> but anyway, the idea is to find a read that isn't lazy in the first place
08:41:48 <bourbaki> is there something for haskell that solves systems and where you can derive functions and such?
08:41:49 <Heffalump> IO actions are strict by default, being IO actions
08:42:17 <musasabi> Heffalump: what about using System.Posix.IO ?
08:42:35 <wli> I'm doing last x `seq` x in my actual program, that turned out not to be quite good enough, so then I also dropped in a writeFile "/dev/null" x
08:42:45 <wli> something above isn't quite doing it
08:43:02 <musasabi> s/HeffaLump/wli
08:43:12 <wli> musasabi: no idea
08:43:33 <Heffalump> last x `seq` x wasn't good enough?
08:43:48 <Heffalump> that's worrying
08:43:48 <wli> something above is being lazy
08:43:57 <musasabi> they are quite easy to use and they are iirc not lazy.
08:43:58 <wli> so I have to sprinkle more strictness annotations around
08:44:06 <Heffalump> was the thing that consumed last x `seq` x doing the right thing?
08:44:13 <Heffalump> as in was it consuming x?
08:44:30 <wli> Heffalump: I'm not sure, but my current hypothesis is that it was not
08:44:59 <wli> or otherwise, that it was being lazier than it should have been
08:45:24 <Heffalump> CosmicRay: hmm, not only is it complaining about haskell:Depends, it's not actually including any files in my deb :-)
08:45:46 * Heffalump changes the architecture back to any from all to see if that's what causes it to break
08:45:58 <CosmicRay> Heffalump: can you put your source packages up somewhere?
08:46:17 <Heffalump> yeah, hangon (is a darcs repo ok?)
08:46:21 <CosmicRay> yes
08:48:19 <wli> speaking of darcs repo
08:48:25 <musasabi> readFile' f = bracket (openFd f ReadOnly Nothing defaultFileFlags) closeFd (\fd -> fdRead fd 0xFFFFFFF >>= return.fst)
08:48:33 <wli> guess which darcs repo is corrupt
08:48:56 <Heffalump> your kernel one.
08:49:06 <wli> not mine
08:49:54 <musasabi> someone complained about the same thing a few weeks ago.. (the darcs kernel repo)
08:55:19 <Heffalump> CosmicRay: ok, the problem definitely doesn't happen for architecture: any. I'll push a patch and give you a URL, hangon
08:55:38 <musasabi> Anyone know what "Software Transactional Memory" is (that is supposed to be included in GHC6.4).
08:55:51 <CosmicRay> Heffalump: ok, thanks
08:56:33 <Heffalump> darcs get http://urchin.earth.li/darcs/haskell-http/
08:57:29 <CosmicRay> Heffalump: you've never called dh_haskell -i in debian/rules
08:57:56 <Heffalump> oh. duh. Sorry :-)
08:58:01 <CosmicRay> Heffalump: for devhelper scripts, -a build only arch: any (or present arch) packages
08:58:09 <Philippa> hell, anybody know when GHC6.4 might actually be released?
08:58:10 <CosmicRay> heh, no prob :-)
08:58:11 <Heffalump> yeah.
08:58:26 <Heffalump> I copied binary-arch into binary-indep  and changed all the -a to -i
08:58:31 <Heffalump> but I forgot there was a -a outside it
08:58:31 <CosmicRay> MegaMonad: when will ghc 6.4 be released?
08:58:45 <MegaMonad> CosmicRay: Phubuh adds 5 to 6, but i got up at 4 in the released version.
08:58:48 <musasabi> http://haskell.org/hawiki/GhcRelease6
08:59:55 <musasabi> CosmicRay: btw did you get the debian-haskell post?
09:00:07 <CosmicRay> musasabi: yes, I replied
09:00:21 <Philippa> musasabi: thanks
09:01:22 <musasabi> CosmicRay: yes, the mail is partially to Isaac too because I think he is on the list too..
09:01:48 <musasabi> (found the reply in list archives - has not yet arrived in my mailbox)
09:02:18 <CosmicRay> musasabi: I'll make dh_haskell work with whatever version of cabal is in debian
09:02:48 <CosmicRay> musasabi: but I can't make it work with every arbitrary darcs version
09:02:57 <CosmicRay> musasabi: that's a recipe for spaghetti code, imho :-)
09:03:02 <CosmicRay> it's evolving to fast
09:03:14 <CosmicRay> musasabi: I don't know if syntaxninja is on the list, but I think he is
09:03:42 <Heffalump> he just replied :-)
09:07:44 <Heffalump> philippa: is the correctness checking of .hi-boot at your request? :-)
09:08:50 * musasabi waits to get syntaxninja's post to get correct threading for the reply
09:17:20 <Heffalump> hmm, Cabal should be given a doc target
09:18:27 <Philippa> Heffalump: er, I didn't explicitly file a request, though I did bitch rather loudly in here
09:18:40 <Heffalump> well, it's on the list for 6.4 :-)
09:18:45 <Philippa> yeah, I saw
09:18:56 <Philippa> just don't know who added it
10:27:56 <musasabi> Did the behaviour of ghc-pkg change recently in cvs?
10:29:46 <musasabi> I get errors like "Could not import `FLTK.Widget': it is hidden (in package FLTK-0.2.5)" with a recent CVS snapshot. The module imports FLTK which is an exposed module that imports FLTK.Widget.
11:00:33 <musasabi> What should be the behavior of:
11:00:35 <musasabi> module Exposed where (module Private)
11:00:35 <musasabi> import Private
11:00:46 <musasabi> ?
11:04:07 <ibid> musasabi: syntax error, perhaps?
11:04:38 <ibid> but assuming we move the "where" after the parenthesized module Private...
11:04:57 <musasabi> yes.. just the normal typo-ratio
11:05:38 <ibid> then Exposed would export whatever Private exports, i'd say
11:07:17 <musasabi> The problem is that this seems to be illegal with ghc-pkg if Exposed is an exposed module and Private is a private module.
11:08:57 <ibid> there i can't sat
11:08:59 <ibid> say
11:36:16 <zamez> alex has strange behaviour in its character ranges
11:37:31 <zamez> @string1	= \"([\050-\176])*\"
11:37:36 <zamez> I'm using this
11:37:50 <zamez> and it's not matching "0" or "1", but is all other digits
11:38:06 <zamez> it's matching letters OK too
11:39:02 <Heffalump> Char> ord '0'
11:39:02 <Heffalump> 48
11:39:02 <Heffalump> Char> ord '1'
11:39:02 <Heffalump> 49
11:39:25 <zamez> I thought it was octal
11:39:29 <zamez> thanks
11:39:48 <Heffalump> if it was, wouldn't 176 need to start with a 0?
11:40:47 <kristnjov> i've never seen the octal system being used
11:40:48 <zamez> maybe
11:40:50 <kristnjov> people seem to settle with hexadecimal, binary and decimal
11:41:57 <zamez> I blame gucharmap
11:41:59 <Heffalump> unix file permissions :-)
11:42:02 <zamez> or something :>
11:42:58 <zamez> flex uses octal, and I was copying a flex grammar
11:43:02 <zamez> that's why :)
12:05:58 <reffie> hm
12:08:03 <reffie> i'm having problems with parsec :(
12:08:51 <jesse98> such as?
12:09:08 <reffie> updateState doesn't seem to work "soon enough"
12:09:48 <reffie> http://rafb.net/paste/results/6MaXG213.html
12:09:50 <reffie> ^- my code
12:11:12 <reffie> the updateState in colonWord only seems to update the state once it's too late
12:12:16 <jesse98> hmm, well I just started using parsec myself...
12:12:20 <reffie> :)
12:13:31 <heatsink> reffie: Do you have a small example of what you're parsing?
12:13:52 <reffie> ": a\n5 ; a"
12:13:56 <reffie> err
12:14:00 <reffie> ": a\n5 ;\n a"
12:14:45 <heatsink> That should set a to five and then get a?
12:14:53 <reffie> right
12:15:06 <reffie> ": a\n5 ;" is supposed to add "a" to the the fWords FM
12:15:41 <reffie> which it does
12:15:58 <reffie> but when i get a, fWords is empty
12:16:28 <heatsink> is that in dictWord?
12:16:34 <reffie> yeah
12:17:47 <Nioate> is many1 fWord supposed to be before updateState (in colonWord definition)?
12:18:14 <reffie> ah!
12:18:19 <reffie> i see what you're saying
12:19:12 <reffie> [here's how i run it: run wordList ": a\n5 ;\na"
12:19:13 <reffie> ]
12:20:02 <reffie> i guess it's because many1 is lazy, or something
12:20:14 <Nioate> ?
12:20:31 <Nioate> I don't think it is
12:20:38 <reffie> hm
12:22:16 <heatsink> Ok, I think I see what Nioate is saying
12:22:17 <reffie> when i do: run wordList ": a\n 5;\n5\n", colonWord seems to be executed before dictWord 
12:22:48 <heatsink> yes, but does it finish before dictWord starts?
12:23:05 <reffie> how would i make sure of that?
12:23:29 <MrZylinder> use the trace function
12:23:44 <reffie> MrZylinder which trace function?
12:23:47 <Nioate> colonWord parses many1 fWord before updating the state. fWord parses a coreWord or a DictWord
12:24:11 <reffie> Nioate right
12:25:30 <reffie> MrZylinder Hat?
12:25:48 <Nioate> so when colonWord is run, a coreWord or a dictWord is parsed before the state is updated
12:25:48 <MrZylinder> yep
12:26:47 <reffie> Nioate so is there a way to make sure that the state is updated before the dictWords is parsed?
12:26:54 <reffie> -s
12:26:55 <Philippa> 'lo shapr
12:27:03 <shapr> y0 Philippa 
12:27:21 <Nioate> reffie: I can think of a real easy way...
12:27:45 <reffie> please tell me :)
12:27:46 * heatsink is away: I'm busy
12:28:01 <MrZylinder> is there a link to reffie's code ?
12:28:13 <Nioate> update it before you try to parse an fWord?
12:28:22 <reffie> http://rafb.net/paste/results/6MaXG213.html
12:28:36 <Nioate> MrZylinder: http://rafb.net/paste/results/6MaXG213.html
12:28:52 <reffie> Nioate yes!
12:28:57 <reffie> thanks :)
12:29:06 <shapr> markstos: Hiya! Are you learning Haskell?
12:29:14 <reffie> anyway, there is something wrong
12:29:23 <reffie> i shouldn't be using many1 fWord there
12:29:37 <shapr> I use the fword all the time when programming.
12:29:59 <Philippa> cf the example code I sent you ;-)
12:30:02 <reffie> i should probably use manyTill
12:30:17 <Lemmih> shapr: haha.
12:30:22 <reffie> heh shapr 
12:30:23 <shapr> anyway, time to play with Yi
12:30:34 <reffie> as it has to stop when it it finds a semiColonWord
12:31:34 <reffie> yeah, using manyTill fixes it even better :P
12:31:58 <reffie> thanks for your help :)
12:34:27 <Lemmih> shapr: Did you unicycle today?
12:34:36 <shapr> nope, too icy
12:34:47 <shapr> I had trouble walking anywhere even.
12:36:00 <Lemmih> I've made it my goal to learn wheelwalking within the next seven days.
12:36:49 <shapr> Lemmih: I'm saving up for a digital video cam :-)
12:38:34 <stepcut> shapr: the canon xl2 ?
12:38:47 <shapr> I have no plans for a model yet
12:40:07 <stepcut> the xl2 is nice but is about $5k US ;)
12:40:20 <shapr> eek
12:40:42 * Lemmih recalls his financial situation and gets depressed.
12:43:18 <stepcut> I wonder how much I can sell my d100 for :-/
12:53:40 <KrisKringle> Lemmih: you're a unicycler?
12:53:44 <KrisKringle> you, too, shapr ?
12:54:12 <shapr> yeah, I am. http://www.scannedinavian.com/images/uni-hop.jpg
12:54:24 <shapr> Amadan owns a unicycle, though I don't know if he's ridden it :-)
12:54:40 <KrisKringle> i know some guys who unicycle, but i've been too chicken to try. 
12:54:45 <KrisKringle> do you juggle, too?
12:55:02 <shapr> Not as much as I unicycle.
12:55:09 <KrisKringle> ah, shame
12:55:48 <shapr> Juggling is a fun challenge, but it's not the rush that is unicycling. I discovered "downhill" recently.
13:10:20 <shapr> hiya aiden 
13:10:25 * shapr throws lambdas
13:10:27 <aiden> hi
13:11:38 <shapr> aiden: learning Haskell?
13:11:56 <aiden> just begining
13:12:04 <shapr> Any questions?
13:12:33 <aiden> Nope, I'm just going to lurk and see how much I understand!
13:12:48 <shapr> ok, feel free to ask any questions you come up with.
13:12:57 <aiden> Thanks
13:15:28 * heatsink is back (gone 00:47:42)
13:15:57 * shapr is forward (back 92ms)
13:20:05 <Lemmih> shapr: I got some funny TH code for you if you're bored. (-:
13:20:19 <basti_> whats TH?
13:20:31 <Lemmih> Template Haskell. www.haskell.org/th/
13:20:40 <basti_> uh
13:21:22 <Philippa> Lemmih: how funny?
13:22:29 <Lemmih> Philippa: It's actually more spiffy than funny.
13:23:06 <Philippa> what does it do?
13:23:25 <Philippa> I've still got to hack up a quickie demonstration using TH + monad transformers for a cheap compiler
13:23:37 <Lemmih> KrisKringle: Yes, I'm a unicyclist and I'm fond of juggling too.
13:24:50 <Lemmih> Philippa: It's a set of marshaling combinators.
13:25:04 <zamez> is there a standard function that joins a list of strings with a string between each? can't find it in the Prelude
13:25:24 <basti_> you can build with fold
13:25:27 <Philippa> intersperse
13:25:29 <Philippa> it's in List
13:25:49 <zamez> thanks
13:25:50 <Philippa> eg intersperse , (map show [1,2,3])
13:27:41 <basti_> uhm
13:28:12 <Lemmih> KrisKringle: Juggling while unicycling is really stretching my multitasking capabilities.
13:30:29 <jesse98> is there any built-in way to get the nth item from a tuple?
13:30:42 <Lemmih> jesse98: No.
13:30:52 <jesse98> ugh
13:31:43 <Lemmih> jesse98: What should the type of such function look like?
13:32:32 <jesse98> well there could be first, second, thord, fourth, etc
13:32:35 <Philippa> I keep trying to figure out a good way to express that type given a few extra things but /not/ dependant types...
13:32:37 <jesse98> or index0, index1, etc
13:32:50 <Philippa> only per tuple size
13:33:11 <Lemmih> jesse98: I'm interested in the type signature, not the name of the function.
13:33:31 <jesse98> hm,, i guess you cant overload them
13:33:43 <Philippa> if you had appropriate subtyping and the likes you could express (a,b) as TCons a (TCons b TNil) or something
13:33:47 <shapr> Lemmih: I'm always looking for entertaining code.
13:33:54 <shapr> hej jansborg
13:34:02 <Gahhh> dons, are you around ?
13:34:12 <Philippa> in which case you would type second as TCons a (TCons b c) -> b
13:34:51 <shapr> jansborg: learning Haskell? Lär du dig Haskell?
13:35:04 <Lemmih> shapr: Then take a look at the DIS code from hacanon (you're hosting the darcs repo).
13:35:50 <jansborg> shapr: I know some haskell already
13:35:59 <shapr> jansborg: spiffy, have any questions?
13:36:12 <jansborg> not at the moment
13:36:38 <shapr> Lemmih: I think your patches are still bouncing sometimes, did you sign the most recent send?
13:37:24 <shapr> jansborg: ok then, greetings and welcome to #haskell
13:37:33 * shapr plays The Twilight Zone theme music
13:37:50 <jansborg> shapr: thanks
13:37:54 <shapr> You've entered a world of space leaks and value based identity...
13:38:10 * shapr forgets the rest of the Twilight Zone intro
13:38:12 <musasabi> How does one use Control.Concurrent.STM ? 
13:38:13 <Lemmih> shapr: D'oh. I keep forgetting that.
13:38:14 <jansborg> oh, I've been there for some time...
13:38:40 <shapr> jansborg: oh you too? Do you have prior experience with funktionella språk?
13:39:28 <shapr> btw, there's #haskell.se for exclusively swedish discussions (not that my swedish is that great)
13:41:43 <shapr> Lemmih: maybe you can set --sign in your darcs defaults?
13:42:06 <jesse98> hmm, maybe I can use an algebraic type intead of a tuple
13:42:17 * shapr wants a geometric type
13:42:34 <Lemmih> shapr: And how do I do that?
13:42:36 * basti_ wants an NP Complete Type
13:42:59 <tic> Hehe.
13:43:25 <shapr> Lemmih: there's a user prefs file, maybe ~/.darcs ? I forget exactly.
13:43:31 <shapr> I know there's a per-repo prefs though.
13:43:35 <shapr> Guten Abend maeglin 
13:46:38 <maeglin> hallo shapr, was f?r eine nette begr??ung :)
13:47:14 <maeglin> well, i got a serious problem, i am new to haskell and just wondering how i can define a function in hugs toplevel environment
13:47:24 <shapr> you can't do it with hugs
13:48:01 <shapr> You can: * define it in a file and load it into hugs, or * use GHCi and "let add1 x = x + 1"
13:48:10 <maeglin> hm, ok. then i need a haskell implementation which lets me do things interactively just like most lisp or sml implementations
13:48:28 <Gahhh> I am comfortable with GHCi in that regard.
13:49:02 <shapr> the downside of lots of interactive definitions is that you can't save them out from the repl
13:49:20 <maeglin> is that part of the "normal" ghc distribution ?
13:49:27 <Gahhh> maeglin, yes
13:49:32 <Gahhh> depends on your platform
13:49:35 <shapr> I mostly use emacs and haskell-mode, where I can just hit C-c C-l on a buffer to load that buffer into ghci
13:49:52 <maeglin> Gahhh, freebsd
13:49:59 <Gahhh> maeglin, I bet it is supported
13:50:31 <shapr> coi Darius 
13:50:35 <shapr> ma nuzba
13:51:25 <Darius> uh, heya shapr
13:52:01 <shapr> pfloff: pfiffische!
13:52:13 <Darius> First snow here today.
13:52:14 <shapr> Darius: xu do tavla mi
13:52:41 <Darius> shapr: I'm not sure what you said, but I'll presume it's a question and the answer is 'no'.
13:52:45 * shapr grins
13:53:02 <maeglin> shapr, how many different languages do you speak :) ?
13:53:29 <shapr> oh, about 1.75 languages if you add up all the tiny bits.
13:53:59 * Darius might have a whole 1.5 or 1.75 all together.
13:54:15 <Gahhh> I speak 2.5
13:54:30 <tuomov> I might have 2.0 if you add up the pieces
13:54:54 <Gahhh> one day, haskell will become the universal language mwahaha
13:55:09 <heatsink> Does domain-specific technical jargon count as a fraction of a language?
13:55:19 <Gahhh> heatsink, no
13:56:10 <Gahhh> You must speak the necessary parts needed to pick up chicks, or equivalents...
13:56:20 <tuomov> heh. At my old job the bosses were constantly baffled by my language
13:56:20 <shapr> right, exactly
13:56:40 <shapr> Y0 babe, lemme put a custom ringtone on your phone!
13:56:45 <Gahhh> heheh
13:56:47 <maeglin> lol
13:56:48 <shapr> why doesn't that ever work?
13:56:55 <Gahhh> that might work surprisingly well in japan actually
13:58:25 <shapr> hiya OzoneXP
13:58:29 <heatsink> Well, in that case I know zero languages.
13:58:35 <shapr> Do you use eXtreme Programming?
13:59:23 <Gahhh> WoW,  the existence of this concert mp3 of Europe singing Cherokee means some people actually WENT to that concert. Gulp!
13:59:39 <basti_> hrhr
13:59:42 <shapr> maeglin: The Alabama dialect of Redneck is my native language, but I also speak some English and some Swedish. Oh, and some French.
14:00:16 <maeglin> shapr, cool.. and you speak some german :)
14:00:28 <shapr> Ich habe keine ahnung!
14:00:41 <shapr> Always useful to say to german speakers.
14:00:57 <maeglin> lol yeah :)
14:01:23 <maeglin> umm, ghc still compiling
14:01:29 <shapr> It may take some time.
14:01:36 <shapr> Takes a few hours on my dual 1.5GHz 
14:01:48 * shapr hugs Debian's binary packages.
14:01:53 <Gahhh> in my case, it takes forever
14:02:07 <Heffalump> I swear Debian packaging exists to piss me off.
14:02:16 <shapr> I thought that was my job?
14:02:20 <Gahhh> all linux packaging exists for that purpose
14:02:29 * shapr sprays his new cologne "Irritation" at Heffalump 
14:02:43 * Darius downloads Cygwin IRC clients to better live in Ion. (http://iki.fi/tuomov/ion/ before anyone asks)
14:02:44 <Heffalump> rpm was nice.
14:03:00 <shapr> Darius: can you dual-boot or switch to Linux?
14:03:23 <heatsink> I like packages. They make it possible to uninstall things without ruining your system.
14:03:25 <maeglin> package management is a religous topic
14:03:32 <Darius> shapr: I do dual-boot Linux.  But I can't use my modem or (current) ISP with it so that doesn't help.
14:03:37 <shapr> oh right
14:03:37 <tuomov> don't know about the contents, but apt-get is a bliss
14:03:49 <Darius> shapr: I do (now) have Ion installed in Linux 
14:03:51 <Gahhh> is there a #ghc-devs channel of some sort ?
14:04:26 <Darius> shapr: If I make a Cygwin Mozilla I'd have almost no need to leave Ion in Windows.
14:04:47 * Oejet likes the files system as package management idea.
14:04:49 <Darius> I'm not sure if I'm that gung-ho though.
14:04:59 <Gahhh> Darius: Can you port ghc to cygwin for me plz ?
14:05:15 <tuomov> darius: have you managed to disable some annoying windows keybindings in cygwin?
14:05:22 <tuomov> I never managed to do that
14:05:28 <Darius> Gahhh: It works with MinGW, why would you want a cygwin version?
14:06:01 <Gahhh> Darius: I use it in emacs and mingw version pops up cmd prompts, plus you get the posix stuff.
14:06:06 <Heffalump> packages are great. Debian packaging is annoying.
14:06:13 <Heffalump> as in the making of Debian packages
14:06:14 <shapr> What's annoying about debs?
14:06:26 <shapr> I've never gotten around to trying to do one from scratch.
14:06:29 <Darius> tuomov: I haven't even noticed windows keybindings for some things others (like Ion) I've set the keybindings as I like.
14:06:48 <Heffalump> the whole original upstream tarball thing is a pain, particularly when the project in question doesn't fit nicely into Debian's scheme
14:07:14 <shapr> There's no support for upstream cvs/darcs/etc ?
14:07:19 <tuomov> e.g. alt-tab is used both by ion and windows, and you can't simply use the windows keys as modifiers under windows
14:08:09 <tuomov> Also I think there was some other conflict
14:08:16 <tuomov> but it's been a while since I've had to use cygwin
14:08:19 <Darius> tuomov: I use Alt-d and Alt-n (dvorak) for the Alt-tab equivalent (or does that change workspaces?)
14:08:56 <tuomov> alt-tab = go to frame right of current (wrapping)
14:09:03 <tuomov> alt-n = some but below
14:09:06 <tuomov> in the defaults
14:09:18 <tuomov> s/so/sa/
14:10:15 <shapr> Anyone here experienced with colocation? I'm looking for a good commercial colo where I can optionally purchase a rackmount from them and get them to install debian on it.
14:10:19 <Darius> tuomov: I've vimified the frame/workspace switching bindings and the menu navigation ones.
14:10:30 <tuomov> IIRC cygwin claimed to have some options to let it receive all keys, but it didn't work when I tried
14:11:50 <shapr> Are there any decent european colo companies?
14:12:08 <shapr> Lunar^: salut, dormir tu?
14:12:18 <shapr> ack, that was swedish conjugation
14:12:41 <musasabi> Well it depends on the definition of decent. Most of things I have a part in are with connections to the companies.
14:12:50 <Darius> shapr: There's http://darcs.net/aboutaktiom.html
14:13:02 <Heffalump> shapr: I use http://www.blackcatnetworks.co.uk/
14:13:23 <Heffalump> I'm not sure if they do preinstalled servers at the moment.
14:13:36 <shapr> I could always buy one and send it to them.
14:13:47 <Darius> tuomov:  Mostly the way I've used Cygwin until now is through bash.
14:14:06 <Heffalump> ah, no, they are doing them
14:14:19 <Heffalump> I don't see much benefit in hosting in the UK if you're not UK-based, though.
14:14:34 <shapr> My clients are EU projects
14:14:58 <shapr> So Den Haag might be best, but I don't know anything about colo in the area.
14:15:15 <shapr> Doesn't earthy live there?
14:15:26 <Heffalump> I think he lives in Nijmegen
14:15:45 <Heffalump> why would Den Haag be any better than anywhere else in the EU?
14:16:12 <Heffalump> I have a friend who hosts stuff in the Netherlands somewhere for a business, but I think he thinks the provider are muppets
14:16:19 <shapr> Because most of the EU project auditing, committees, etc happens in the Hague
14:17:03 <Heffalump> ah
14:17:18 <shapr> I have trouble finding non-muppet providers.
14:17:56 <shapr> I swear Kermit the Frog would do a better job of keeping a network up than most of the ISPs I've seen. And think of hard that would be with hand made out of felt!
14:17:57 <Heffalump> well, I'm sure Black Cat are non-muppet
14:18:12 <Heffalump> though they do sometimes have a bit of downtime
14:18:13 <shapr> Do they say how much they oversell their bandwidth?
14:18:34 <Heffalump> but they're always honest about what caused it (e.g. when one of them accidentally knocked out a power cable..)
14:18:38 <shapr> In the US most colos would say just so you'd know how much saturation to expect on rough days.
14:18:50 <Heffalump> I haven't ever heard them mention it.
14:20:10 <shapr> Wow, I like these guys.
14:20:43 <shapr> Do you get a bonus for referrals? =)
14:20:56 <shapr> Geez, native IPv6.
14:21:04 <shapr> g'day Pseudonym 
14:21:08 <Pseudonym> G'day.
14:21:31 <shapr> Heffalump: I am impressed. They're more expensive than many I've seen, but obviously non-muppet.
14:22:39 <Heffalump> shapr: no :-) (re referrals :-)
14:22:51 <Heffalump> they are friends of mine, btw
14:24:08 <shapr> Do you think they'd also let me send them money to purchase a 1U according to my specs and install debian/unstable? I'd rather not ship hardware if I can escape it.
14:24:32 <Heffalump> you don't want the dedicated servers listed on their page?
14:25:31 <shapr> Nah, I dislike Via/Intel, I need a lot more ram and drive space, and I want to own the hardware.
14:25:47 <musasabi> ghc inside qemu is a tad slow.
14:26:08 <Heffalump> email them and ask
14:26:16 <shapr> I think I qualify as a complete control freak for boxen I admin.
14:26:30 <shapr> ok, thanks.
14:26:31 <boegel> @seen mitchkov
14:26:32 <lambdabot> I haven't seen mitchkov
14:27:10 <Heffalump> I would have thought it wouldn't be a major problem for them. I guess they might charge you a bit to do the install.
14:27:30 <shapr> that's expected.
14:27:53 <Heffalump> what would you do if something broke requiring physical access to fix?
14:28:36 <shapr> good question.
14:29:31 <shapr> I can get a 1megabit public ip here at home, but if I run client sites on it, I can't take vacations.
14:30:05 <shapr> I can't find any decent colos in northern sweden, and I don't know if physical access to southern sweden is significantly different from physical access to the UK.
14:30:05 <Heffalump> in case it breaks?
14:30:10 <shapr> right
14:30:17 <Heffalump> how do you get to southern sweden, then?
14:30:30 <Gahhh> bobsleigh ?
14:30:54 <shapr> If a colo box broke in southern sweden, I'd either have it mailed to me, or I guess take a plane south.
14:30:55 <Pseudonym> You could roll your own colo.
14:30:55 <kristnjov> wolves dragging his sleigh
14:31:02 <Pseudonym> That's what I did.
14:31:05 <shapr> how so?
14:31:09 <Pseudonym> My box is in someone's place.
14:31:19 <Pseudonym> A bunch of us pay for a business-class SDSL line for him.
14:31:30 <Heffalump> can he take vacations?
14:31:30 <Pseudonym> He gets SDSL at home, we get colo'd boxen.
14:31:40 <Pseudonym> It's a group house, and everyone there is a geek.
14:31:40 <bourbaki> moin
14:31:53 <Pseudonym> Occasionally you get a weekend where nobody is there.  You cross your fingers then.
14:32:21 <shapr> That's not good enough for a server that runs all the websites our clients ask us to build and host :-/
14:32:28 <Pseudonym> It's a stochastic availability guarantee, but that's true of commercial colos, too.
14:32:34 <Pseudonym> shapr: So put it in YOUR place.
14:33:01 <Heffalump> then he can't take a vacation..
14:33:16 * Pseudonym shrugs
14:33:21 <Pseudonym> Maybe my clients are more forgiving.
14:33:25 * Pseudonym doesn't do it for a living
14:34:14 <shapr> I think you're right, the only way I can depend on instant access is to have it in my own place, and I guess I'll just have backup hardware for vacations.
14:34:17 <Heffalump> shapr: how much is a plane south compared to a plane to the UK?
14:34:26 <shapr> nearly the same
14:34:56 <Pseudonym> As the old saying goes...
14:34:56 <Heffalump> well, host with Black Cat, then if it breaks you get the bonus of a holiday in London :-)
14:35:07 <Pseudonym> "How do you deliberately crash a server?"  "Take two weeks' holiday."
14:35:11 <shapr> Flying from Stockholm or Gothenburg to London or Paris is cheap. Flying from 800 plus km south to Stockholm is the expensive part.
14:35:33 <Heffalump> ah, you have to change? Lots more time, then..
14:35:49 <Heffalump> (how expensive?)
14:36:45 <shapr> iirc, it's something like 500 to 700 euro to fly down. Total price to the USA is only 800e if you shop carefully.
14:37:01 <Heffalump> how did you get to ICFP 2003?
14:37:19 <Heffalump> (why do you live in Northern Sweden, anyway?)
14:37:33 <kristnjov> he's a unicycling programmer, what could you expect? :)
14:37:41 <shapr> I took the ~13 hour night train, but man did it suck.
14:37:56 <musasabi> long train journeys are nice.
14:38:47 <Maddas> I sense a contradiction!
14:39:02 <shapr> Heffalump: no real reason ... my fiancee wants to live here, and I don't realy care where as long as I have decent internet.
14:39:08 <Pseudonym> No, you sense a quantum observation.
14:39:39 <Heffalump> I like trains.
14:39:42 <Heffalump> 13 hours might be excessive.
14:39:44 <Pseudonym> shapr's observation collapsed the train journey into the "sucks" eigenfunction.
14:40:18 <Pseudonym> Train journeys are actually a superposition of "nice" and "sucks".  Observing the journey forces it to be one or the other.
14:40:30 <Maddas> Pseudonym: Aha! Aha!
14:40:32 <musasabi> Well one can sleep/read/plan things on a train quite well.
14:40:40 <musasabi> and there is little stress.
14:40:40 * Maddas walks around gesturing
14:40:57 <tuomov> train journeys before a holiday are always observed as "sucks"
14:41:46 <Maddas> Heh. I find that I can't plan well in train journeys :-)
14:43:38 <zamez> yay, I've finished the tokenising & parsing
14:43:43 <zamez> now I can do the fun part
14:43:50 <Maddas> What are you writing?
14:44:17 * boegel needs to use the train up and down 1.5 hours when he has class
14:44:21 <zamez> a CSS optimiser, at least that's the aim
14:45:06 <heatsink> What is optimal CSS like?
14:45:30 <boegel> heatsink: short ?
14:46:00 <zamez> yes, short
14:46:10 <heatsink> to reduce bandwidth drain?
14:46:11 <zamez> I don't know how well it will work in practice
14:46:28 <zamez> no, more to make the CSS easier to maintain and understand
14:46:36 <zamez> so common stuff should appear in one place
14:46:50 <Heffalump> how do you figure out if something is common?
14:47:08 <zamez> basically, it's the same
14:47:12 <heatsink> isn't that Pseudonym's job?
14:47:16 <boegel> heatsink, I don't think bandwidth is an issue with CSS, or am I mistaking N
14:47:18 <heatsink> IIRC
14:47:25 <Pseudonym> ?
14:48:00 <heatsink> Someone here said they spent a year writing code to find similarities between different versions of documents.  I thought it was you.
14:48:13 <Pseudonym> Nope.
14:48:18 * Pseudonym spent a year sorting
14:48:43 <heatsink> you put sort keys in the filesystem, right?
14:48:49 <zamez> there are complications like specificity of selectors, but I'm going to ignore that for now
14:49:00 <Pseudonym> Errr... no.
14:49:11 <Pseudonym> It'd take too long to explain. :-)
14:49:22 <heatsink> ok :)
14:50:06 * Heffalump wonders why Debian rules files generally split the binary-arch and binary-indep targets
14:55:07 <Lunar^> shapr: non
14:55:14 <Lunar^> shapr: I'm in Dijon, right now :)
14:57:16 * Darius goes to make a Joy that will run on a phone and build irssi.
15:17:20 <mistay> hi there
15:17:29 <Heffalump> hi
15:17:32 <mistay> hey
15:17:37 <mistay> i'm going to write an exam
15:17:47 <mistay> in about 18hours
15:18:00 <mistay> could you help me in understanding some haskell code?
15:18:15 <heatsink> sure
15:18:49 <heatsink> I like how TFT monitors are supposed to be "radiation-free"
15:19:31 <heatsink> I always thought that the 400-700nm radiation was distracting anyway
15:19:54 <mistay> http://bugs.langhofer.at/viewtopic.php?p=63#63
15:20:04 <mistay> right here you can see the code i have to understand
15:20:21 <mistay> maybe you could explain me some things ...
15:20:56 <mistay> fix f = repeat_until pred f
15:21:02 <mistay> this line for example ...
15:21:02 <heatsink> hmm... they redefine fix. They should have called it something else.
15:21:22 <mistay> oh, "fix" already exists in haskell?
15:21:58 <heatsink> Yes, it's part of one of the standard libraries. It doesn't do what this function does.
15:22:07 <mistay> ic
15:22:14 <mistay> fix f = repeat_until pred f 
15:22:18 <mistay> could you explain me this line?
15:22:36 <mistay> in java ... would it be like: return repeat_until(pred,f);
15:22:43 <heatsink> yes
15:23:00 <boegel> mistay: f is performed until 'pred' is true
15:23:08 <boegel> so it repeats f until pred is true
15:23:15 <mistay> alrite, but ....
15:23:21 <heatsink> boegel: don't give it away, it's mistay's job to figure that out
15:23:27 <boegel> heatsink: sorry :s
15:23:29 <mistay> repeat_until needs three arguments: (a->Bool)->(a->a)->a
15:23:32 <mistay> right?
15:23:36 <boegel> mistay: no
15:23:38 <heatsink> yes
15:23:42 <boegel> heatsink: I'll do my best
15:23:49 <heatsink> mistay: have you heard of currying?
15:23:55 <mistay> nope
15:24:02 * boegel pays attention
15:24:05 <mistay> sec ... i gonna translate it into german ...
15:24:21 <boegel> mistay: don't bother :)
15:24:25 <heatsink> "curry" is named after a person, so it should be spelled nearly the same.
15:24:33 <mistay> currying =  	"striegelnd" nope, never heard
15:24:59 <boegel> heatsink: I don't see what currying has to do with this, but hey :p
15:25:02 <mistay> k, so does currying have anything to do with this?
15:25:48 <mistay> why does: "fix f = repeat_until pred f"  call  repeat_until with 2 instead of 3 arguments ... i dont get it
15:26:03 <heatsink> There should be something about currying in a haskell tutorial
15:26:14 <np_hard> um
15:26:21 <np_hard> how about schnfinkeling?
15:26:23 <boegel> mistay: what's the type of 'repeat_until' ?
15:26:31 <np_hard> since Curry attributes it to schnfinkel
15:26:32 <bourbaki> boegel: did you check the paper on geometric algebra and raytracers?
15:26:36 <mistay> repeat_until::(a->Bool)->(a->a)->a->a 
15:26:43 <heatsink> interesting.
15:26:48 <Pseudonym> Mmmm... geometric algebra...
15:26:56 <Pseudonym> Great stuff.
15:27:02 <heatsink> boegel: good idea.
15:27:06 <jadrian> Pseudonym: I'd like to know more about it...
15:27:16 <jadrian> Pseudonym: That and topology
15:27:27 <Pseudonym> I'd like to know more about topology, too.
15:27:34 <Pseudonym> Then I'd understand more category theory texts.
15:27:42 <bourbaki> i just had a quick thought on iplementing some visualization thing in haskell again
15:27:48 <boegel> bourbaki: a bit
15:28:04 <bourbaki> Pseudonym: hm well at a lot of points they differ alot though imho
15:28:16 <boegel> mistay: and what's the type of 'fix' ?
15:28:24 <bourbaki> ive bought a really good and small book from springer on topology
15:28:28 <mistay> fix::(Float->Float)->Float->Float 
15:28:29 <boegel> your fix, not the one in the Prelude
15:28:42 <boegel> mistay: that's the one in the Prelude
15:28:43 <Pseudonym> Category theory was first invented by a guy trying to understand topology.
15:28:56 <mistay> hmm, dont know what you mean
15:28:56 <heatsink> no, that's mistay's fix
15:29:03 <mistay> check http://bugs.langhofer.at/viewtopic.php?p=63#63
15:29:04 <Heffalump> I thought it was invented by a mathmematician who wanted to pretend to be a computer scientist
15:29:12 <jadrian> ;)
15:29:19 <Pseudonym> LOL
15:29:26 <boegel> mistay: ok, my fault, that's your 'fix'
15:29:35 <Pseudonym> Saunders Mac Lane also wrote an influential textbook on abstract algebra.
15:29:48 <Pseudonym> So it was possibly a topologist pretending to be an algebraist.
15:29:50 <arjanb> bourbaki: do you have a link to that paper?
15:29:53 <mistay> alrite, hmmm ... has anyone a clue what the code does?
15:30:02 <boegel> so, now you have a function whit type (a->Bool)->(a->a)->a->a , and a function with type (Float->Float)->Float->Float, right ?
15:30:03 <bourbaki> im just reading a lot of stuff on the net
15:30:11 <bourbaki> planet math and mathworld ie
15:30:18 <boegel> mistay, what the type of 'return_until pred'
15:30:19 <bourbaki> arjanb: which paper?
15:30:34 <mistay> <boegel>: right
15:31:00 <boegel> mistay, what is the type of 'return_until pred' ?
15:31:12 <mistay> do you mean: repeat_until?
15:31:18 <boegel> mistay: no :)
15:31:18 <bourbaki> http://staff.science.uva.nl/~leo/clifford/
15:31:34 <bourbaki> thats the page 3 papers on clifford algebra
15:31:38 <mistay> do i have a return_until right there?
15:31:45 <arjanb> thx
15:31:45 <bourbaki> the last one is on rendering and CA
15:31:48 <boegel> you should look at 'fix f = repeat_until pred f' as a variable getting a value
15:32:04 <boegel> but rather as using 'fix f' instead of 'repeat_until pred f'
15:32:04 <bourbaki> i also thought about implementing CA in haskell
15:32:22 <boegel> mistay: sorry again :p
15:32:31 <boegel> mistay: I mean 'repeat_until pred' :)
15:32:35 <mistay> hmm
15:32:36 <mistay> i c
15:32:41 <Pseudonym> bourbaki: Actually, it's on ray tracing and CA.
15:32:42 <boegel> mistay, what is the type of 'repeat_until pred' ?
15:33:03 <mistay> hmm how can i figure out?
15:33:10 <mistay> i can tell you the type of repeat_until
15:33:11 <bourbaki> Pseudonym: :) sry i tend to be not too precise at some moments
15:33:13 <Pseudonym> Scanline rendering isn't helped much by CA, although the Exluna sampler might be interesting.
15:33:25 <boegel> mistay, ok, you know the type of repeat_until
15:33:41 <boegel> what if you 'give' repeat_until 1 argument
15:33:51 <boegel> then you get another function, with a 'partial' type
15:34:19 <mistay> hmm, is this possible?
15:34:23 <boegel> mistay: yes
15:34:29 <mistay> doesnt need repeat_until 3 arguments?
15:34:43 <boegel> the get a resulting value, yes
15:34:48 <boegel> s/the/to
15:35:00 <heatsink> it doesn't need all three arguments at once
15:35:03 <mistay> repeat_until::(a->Bool)->(a->a)->a->a 
15:35:08 <boegel> mistay: but if you give just 1 argument, you'll get a new function
15:35:20 <mistay> there must be 3 arguments, right?
15:35:24 <mistay> hmm
15:35:29 <heatsink> http://en.wikipedia.org/wiki/Currying
15:35:32 <mistay> but how is this "new function" executed
15:35:33 <boegel> mistay: repeat_until pred :: (a->a)->a->a
15:35:35 <boegel> you see ?
15:36:03 <boegel> mistay: you should really stop thinking in java-like terms
15:36:40 <boegel> heatsink: damn, this is hard to explain :D
15:36:59 <mistay> hehe
15:37:09 <mistay> argl, i'm a procedural coder, not a functional
15:37:16 <mistay> it's not that easy to get it
15:37:21 <heatsink> argv, it takes time
15:37:22 <mistay> but i'm workin on it ..
15:37:28 <boegel> mistay: suppose we have a function 'sum', which is of type Double -> Double -> Double
15:37:30 <boegel> ok ?
15:37:34 <mistay> ok
15:37:49 <boegel> then 'sum' needs 2 arguments to return a result, right ?
15:37:59 <mistay> yepp
15:38:04 <boegel> so sum 1 2 = 3
15:38:11 <mistay> alrite
15:38:24 <boegel> now, if I give sum 1 argument, I'll get a new function, a function of type 'Double -> Double'
15:38:33 <boegel> 'sum 1' is such a function
15:38:39 <mistay> alrite, but you have to declare this function?
15:38:50 <mistay> it's another function, isn't it?
15:38:56 <boegel> it's a function that takes an argument, an returns the sum of that argument with 1
15:39:12 <boegel> mistay: you don't have to declare it
15:39:23 <ne1> it is another function, but you don't have to declare it
15:39:26 <boegel> mistay: check this: sumWith1 = sum 1
15:39:35 <boegel> you see ?
15:39:35 <mistay> hmmm ...
15:39:39 <ne1> you can if you like.
15:39:44 <boegel> and then sumWith1 :: Double -> Double
15:39:45 <mistay> so "sum 1" would be okay?
15:39:50 <boegel> yes
15:39:52 <ne1> yes!
15:39:52 <boegel> no errors there
15:40:07 <mistay> what would the result look like?
15:40:07 <boegel> but you won't get a result until you provide it another argument off course
15:40:13 <mistay> oh, i c
15:40:26 <boegel> so if you do 'sumWith1 = sum 1'
15:40:37 <boegel> and then you do 'sumWith1 4' you'll get 5
15:41:05 <boegel> because Haskell will replace the sumWith1 with it's definition, so 'sumWith1 4' becomes 'sum 1 4', returning 5
15:41:25 <mistay> hmm
15:41:31 <mistay> i checked that out, right now
15:41:35 <mistay> sum::Float->Float->Float
15:41:35 <mistay> sum a b = a+b
15:41:37 <boegel> so, 'fix f = repeat_until pred f' works the same way
15:41:43 <mistay> Main> sum 4
15:41:43 <mistay> ERROR - Cannot find "show" function for:
15:41:43 <mistay> *** Expression : sum 4
15:41:43 <mistay> *** Of type    : Float -> Float
15:41:43 <mistay> M
15:41:50 <mistay> dosn't work for me
15:41:54 <heatsink> mistay: it works
15:42:02 <ne1> that is normal
15:42:07 <mistay> am i doing anything wrong?
15:42:07 <boegel> mistay: we said: you can't print out the result of 'sum 4'
15:42:20 <mistay> ok
15:42:30 <boegel> mistay, try ':type sum' and ':type sum 4'
15:42:34 <boegel> @type sum
15:42:36 <lambdabot> sum :: forall a. (Num a) => [a] -> a
15:42:40 <boegel> @type sum 4
15:42:42 <lambdabot> sum 4 :: forall a. (Num a, Num [a]) => a
15:42:56 <i_of_k5> wrong sum, boegel
15:43:02 <boegel> it's a bit different here, but that's just because lambdabot is so nifty
15:43:04 <boegel> i_of_k5:  ?
15:43:12 <boegel> oh, right
15:43:15 <boegel> @index sum
15:43:17 <lambdabot> Data.List,Prelude,List
15:43:22 <i_of_k5> it's the sum from the prelude
15:43:26 <boegel> @type Prelude.sum
15:43:28 <lambdabot> Prelude.sum :: forall a. (Num a) => [a] -> a
15:43:38 <boegel> @type List.sum
15:43:40 <lambdabot> List.sum :: forall a. (Num a) => [a] -> a
15:43:42 <boegel> eh ?
15:43:44 <i_of_k5> @type \ x y -> x + y
15:43:46 <lambdabot> \ x y -> x + y :: forall a. (Num a) => a -> a -> a
15:44:13 <boegel> of, off course, sum of 2 arguments is + :p
15:44:16 <boegel> stupid me :D
15:44:23 <boegel> mistay: do you get the picture ?
15:44:27 <mistay> nope
15:44:27 <boegel> ask away if you don't
15:44:31 <mistay> i'm trying to understand
15:44:40 <mistay> how the function can get me a result
15:44:47 <mistay> if you dont provide all arguments ...
15:44:53 <i_of_k5> mistay, remember that -> is right-associative
15:45:12 <i_of_k5> so Double->Double->Double is really Double -> (Double->Double)
15:45:49 <boegel> mistay: the function _won't_ provide a result without having all it's arguments
15:46:07 <kristnjov> therefore if you want (Double->Double)->Double you do Double<-Double->Double
15:46:18 <kristnjov> btw, i'm a compulsive liar! hi.
15:46:18 <Lemmih> boegel: That depends on what you consider a result.
15:46:19 <heatsink> kristnjov: what?
15:46:36 <boegel> Lemmih: true :) a function is a result too, but I mean a printable result
15:46:52 <mistay> alrite, so tell me what "sum 1" would result in?
15:47:10 <boegel> mistay: a function of type 'Double -> Double'
15:47:16 <boegel> or Float -> Float, whatever :p
15:47:30 <kristnjov> \a -> a*a :(
15:47:35 <mistay> jepp, i dont care the actual type (float,double,..)
15:47:38 <kristnjov> haskell is so neat, i want to have sex with it
15:48:02 <Lemmih> ^_^
15:48:04 <kristnjov> women, beer and functional programming
15:48:08 * boegel hands kristnjov a condom, because having sex with Haskell isn't safe
15:48:13 <kristnjov> boegel :)
15:48:20 <mistay> alrite, so if i call "sum1" it will result in a function ... but what the heck do i need this for? what can i do with this function?
15:48:20 <Pseudonym> Actually, it's very safe.
15:48:22 <Pseudonym> Haskell is pure.
15:48:27 <ne1> I heard Haskell was pure and safe
15:48:28 <Pseudonym> Just don't touch unsafePerformIO.
15:48:32 <kristnjov> yeah, haskell is safe...
15:48:38 <kristnjov> but having sex with it... darn.
15:48:41 <kristnjov> it's like a japanese girl.
15:48:42 <boegel> the same thing is happening in your code
15:48:45 <ne1> ghc has dirty parts, that I know
15:48:52 <kristnjov> it's small, tight and makes lots of noises.
15:48:54 <boegel> repeat_until gets only 2 arguments
15:49:01 <boegel> so the result is a function
15:49:09 <mistay> jepp, alrite
15:49:12 <boegel> and you use that function to define another function
15:49:32 <heatsink> haskell isn't all that safe.  The C preprocessor -- now, that's safe.
15:49:38 <boegel> fix needs 2 arguments too, but you provide an alias for 'fix f', being 'repeat_until pred f'
15:50:01 <Pseudonym> The C preprocessor isn't nearly as sexy, though.
15:50:11 <boegel> so if you call 'fix f x', Haskell will change it to 'repeat_until pred f x'
15:50:34 <boegel> and get the result of that expression, and returns it as result of 'fix f x'
15:50:44 <Heffalump> has anyone used HaXml with hugs? If so, do you know how to sort out the CPP issues?
15:51:03 <Heffalump> (I tried -Fcpp and it failed to read the prelude for some reason)
15:51:14 <boegel> kristnjov: the thing about the japanese girl is really sick :p
15:51:35 <heatsink> boegel: what, are you racist or something?
15:51:43 <heatsink> ;)
15:52:04 <boegel> heatsink: eh ? :p
15:52:17 <mistay> boegel: just gimme a sec, i'm trying to understand what you wrote ...
15:52:18 <ne1> I have a list of numbers, say [4,7,9,3]. I want to add 1 to every item in the list, e.g. get [5,8,10,4].  I can use: map (sum 1) [4,7,9,3].  I can pass (sum 1) to map because map wants a certain type of function and (sum 1) has the matching type.
15:52:36 <boegel> ne1: nice example
15:53:13 <boegel> mistay: okay, take your time
15:53:43 <Nioate> sequence list_of_io_actions does each io action in order and returns the results right
15:53:46 <boegel> heatsink: why would I be a racist ? because I think kristnjov is sick ? :p
15:53:48 <shapr> paf: salut!
15:54:04 <boegel> shapr: ?
15:54:11 <shapr> boegel: hoi!
15:54:26 <boegel> shapr: hey !!1!1!!1
15:54:28 <shapr> paf: dorme tu?
15:54:38 <paf> shapr: no, i'm here
15:54:46 <boegel> pief, poef, ...
15:54:54 <mistay> boegel: hmm i still dont get it ... is there a possibility to so kind of trace?
15:55:07 <mistay> or some debug?
15:55:10 <paf> shapr: you got my mail?
15:55:15 <mistay> can i output some variables
15:55:18 <shapr> oui, maintenant
15:55:21 <boegel> mistay: tell me what you don't understand
15:55:36 <shapr> paf: tell me about your installations problems.
15:55:41 * shapr grabs the latest HaskellDSP
15:55:41 <mistay> alrite, let's do it step by step, okay?
15:55:54 <mistay> first of all, i do a 'fix square 0.01'
15:56:02 <boegel> uhu
15:56:16 <mistay> so, i would say it falls the "fix" function with parameter square and another parameter 0.01
15:56:17 <paf> shapr: here?
15:56:32 <boegel> mistay: okay
15:56:33 <shapr> yes, sure
15:56:36 <mistay> in java-terminology fix(square,0.01);
15:56:59 <mistay> alrite, so we jump into fix, but only have 2 arguments, instead of three
15:57:07 <shapr> paf: first, are you using the haskelldsp-snapshot.tar.gz from haskelldsp.sourceforge.net ?
15:57:12 <mistay> what happens now?
15:57:26 <bourbaki> is there a generic that lib for haskell?
15:57:31 <mistay> whoops, sorry
15:57:36 <shapr> bourbaki: that what?
15:57:38 <mistay> fix only has 2 arguments
15:57:58 <bourbaki> a collection of liear solvers eigenvectors and such
15:58:02 <bourbaki> vectors
15:58:03 <mistay> i'm sorry, alrite, we jump into fix with the first argument being a function and the second being a float
15:58:06 <bourbaki> rootfinding ets
15:58:08 <bourbaki> etx
15:58:10 <bourbaki> dang
15:58:16 <boegel> mistay: Haskell will use the 'fix f' definition to determine the result
15:58:31 <mistay> okay: here's a question
15:58:35 <paf> I downloaded the latest haskelldsp on sourceforge
15:58:42 <shapr> bourbaki: HaskellDSP Haddocks - http://haskelldsp.sourceforge.net/doc/index.html
15:58:42 <boegel> it will say, hmm, I know what 'fix f' stands for, so let's use that
15:58:45 <paf> I had to modify a few things in the Makefile
15:58:52 <shapr> paf: like what?
15:58:53 <mistay> fix f .... what does this f become ... will it 'f' be 'square 0.01' ?
15:58:59 <boegel> no
15:59:08 <boegel> f will become just square
15:59:14 <mistay> what about 0.01?
15:59:15 <boegel> 0.01 is the third argument
15:59:25 <paf> shapr: like changing green-card for greencard
15:59:30 <boegel> when you call fix, you need to provide 2 arguments
15:59:30 <paf> shapr: the INSTALLDIR
15:59:31 <shapr> oh, good change
15:59:40 <mistay> 0.01 is the second argument, isn't it?
15:59:44 <mistay> fix square 0.01 
16:00:05 <bourbaki> shapr: but thats a dsp lib
16:00:08 <paf> (INSTALLDIR was in matthew userdir :-P)
16:00:08 <boegel> one of type (Float->Float), which is a function (square), and one of type Float (0.01)
16:00:17 <boegel> mistay: yes, second, sorry :D
16:00:21 <mistay> k
16:00:31 <mistay> so what happens to the second argument (0.01) ?
16:00:41 <mistay> fix f = .... 
16:00:48 <mistay> there's only the first specified
16:00:56 <shapr> bourbaki: I don't know if a lib for eigenvectors etc exists, but I would suggest asking Pseudonym 
16:00:57 <mistay> i dont get what about the 0.01 is?
16:01:03 <paf> shapr: then make tells me: greencard -t ffi -i /usr/local/lib/greencard  Numeric/Special/Airy.gc
16:01:03 <paf> > Warning: unable to find StdDIS along the import path
16:01:13 <boegel> mistay: there's only one specified, but that's no problem
16:01:15 * shapr tries it
16:01:24 <mistay> alrite, so 0.01 get's lost?
16:01:27 <bourbaki> Pseudonym: ?
16:01:31 <mistay> we only take square
16:01:35 <boegel> Haskell will change 'fix square 0.01' into 'repeat_until pred square 0.01'
16:01:37 <boegel> you see ?
16:02:02 <mistay> aaah
16:02:08 <mistay> so f becomes "square 0.01"
16:02:19 <boegel> mistay: no :)
16:02:23 <mistay> argl.
16:02:33 <Pseudonym> Not as far as I know.
16:02:33 <mistay> but you substituted f with "square 0.01"
16:02:33 <paf> shapr: What version of haskelldsp did you use?
16:02:38 <ne1> x becomes 0.01, is that what you mean?
16:02:42 <shapr> paf: I get the same error, but I've located the lib in the win32 part of hslibs
16:02:44 <boegel> mistay: it looks that way
16:02:50 <Pseudonym> It's actually tricky to get right, according to Numerical Recipes.
16:02:54 <boegel> mistay: wait :)
16:03:16 <boegel> let's say we have a function switchDivide
16:03:19 <boegel> okay ?
16:03:32 <mistay> okay
16:03:36 <shapr> paf: I'm using the haskelldsp-snapshot.tar.gz from sourceforge.
16:04:02 <paf> shapr: you mean, you're trying to install the snapshot?
16:04:07 <shapr> yes, right now.
16:04:13 <paf> shapr: have you use it before?
16:04:54 <shapr> I think I have played with it, in the past. I recently moved to a new harddrive though.
16:05:17 <shapr> All of my Haskell packages tend to become uninstalled quickly unless they have debian packages.
16:05:50 <paf> shapr: do you have greencard?
16:05:52 <shapr> Igloo makes new GHC packages whenever there's a new version, and I get bored and start using some other Haskell packages every few weeks.
16:05:59 <shapr> Yes, I have greencard 3.01 installed.
16:06:29 <shapr> paf: it looks like StdDIS has something to do with garbage collection maybe, and it looks like it's win32-only. I suspect changing something in the Makefile will fix this problem.
16:06:32 <boegel> mistay: and it's defined as 'swithDivide x y = y / x'
16:06:51 <mistay> alrite
16:06:55 <boegel> if I call switchDivide 1 2 it will bind x to 1 and y to 2
16:07:05 <mistay> jepp
16:07:06 <boegel> thus returning 2 / 1 = 2
16:07:10 <boegel> okay?
16:07:11 <mistay> jepp
16:07:22 <boegel> now, another example
16:07:23 <boegel> um...
16:07:24 <mistay> it's clear
16:07:43 <boegel> oh, so you get it ?
16:08:01 <boegel> fix has 2 arguments, but you have an alias for fix with 1 argument
16:08:23 <boegel> so Haskell uses that alias to determine the result of 'fix f x'
16:08:37 <paf> shapr: oh. Tell me what to change if you find it.
16:08:55 <shapr> I'm looking for it now.
16:09:06 <mistay> so haskell subsitutes 'f' with 'square 0.01' ?
16:09:14 <boegel> mistay: ARG :) no
16:09:21 <mistay> damn
16:09:23 <boegel> haskell substitues f with square
16:09:30 <mistay> okay
16:09:30 <xerox> 'night!
16:09:35 <mistay> and what about 0.01?
16:09:36 <boegel> in 'fix f = repeat_until pred f'
16:09:53 <shapr> paf: aha, http://www.haskell.org/greencard/ mentions - The StdDIS module has been renamed Foreign.GreenCard
16:09:54 <boegel> so that yields 'fix square = repeat_until pred square'
16:10:04 <monochrom> I guess if fix is defined "fix f x = repeat_until pred f x" you can say x becomes 0.01
16:10:07 <boegel> and then you 'paste' the 0.01 behind it
16:10:11 <shapr> paf: HaskellDSP needs to be updated from greencard 2 to greencard 3
16:10:17 <boegel> monochrom: right :D thanks ;)
16:10:22 * shapr tries to fix
16:10:43 <mistay> hmm, so can you say that every "unsued" parameter gets "pasted" behind?
16:10:44 * boegel understand mistay, because he had lot's of problems with it too
16:10:53 <boegel> mistay: sort of
16:10:58 <mistay> aah, alrite
16:11:00 <paf> shapr: good
16:11:06 <mistay> so in this case the 0.01 gets pasted
16:11:22 <paf> shapr: have you used greencard for other stuff before?
16:11:26 <mistay> so repeat_until with 2 arguments becomes repeat_until with 3 arguments?
16:11:44 <boegel> mistay: yes !
16:11:47 <mistay> aaaah
16:11:52 <mistay> *aha-effect*
16:12:03 <boegel> so that yields a result, and thus you have a result for fix with 2 arguments
16:12:07 <mistay> now, haskell can use the repeat_until function
16:12:27 <mistay> cause it get's 3 arguments
16:13:12 <shapr> paf: no, I haven't. 
16:13:25 <boegel> mistay: idd
16:13:29 <mistay> boegel: alrite
16:13:32 <mistay> i think i got that
16:13:34 <boegel> mistay: ijhaa :)
16:13:43 <mistay> but there's still a question left
16:13:52 <mistay> where pred x = (abs(f x -x) <= 0.01) 
16:13:56 <mistay> in this case ....
16:14:02 <mistay> pred x
16:14:14 <boegel> mistay: pred is a function
16:14:15 <mistay> am i right if i say that 'x' becomes to 'f' ?
16:14:45 <mistay> jepp, it's clear that pred is a function with one argument (x)
16:14:55 <mistay> pred is boolean
16:14:55 <boegel> mistay: no
16:15:11 <boegel> pred is a function, that takes one argument, to return a boolean
16:15:28 <mistay> jepp, that's what i meant
16:15:38 <boegel> the definition of repeat_until uses pred internally to determine it's own result
16:16:04 <mistay> and this specific argument (x) .... is becomes f .. right?
16:16:12 <boegel> mistay: no :)
16:16:26 <mistay> remember your example with swithDivide ...
16:16:27 <boegel> you don't know what it becomes
16:16:36 <mistay> x got bound to 1 and y got bound to 2
16:16:42 <boegel> yep
16:16:51 <mistay> this is the same here, isn't it?
16:17:00 <mistay> you call: pred(f)
16:17:05 <mistay> argl
16:17:06 <mistay> no
16:17:11 <mistay> i think i got it
16:17:16 <mistay> it's not pred(f)
16:17:26 <mistay> it's repeat_until(pred,f,0.01)
16:17:28 <boegel> idd, it's not pred(f)
16:17:32 <boegel> mistay: right :)
16:17:32 <mistay> jepp
16:17:36 <mistay> *brainlag*
16:17:54 <boegel> a where clause is used to define stuff you only need within that particular function
16:17:57 <boegel> such as pred
16:18:10 <boegel> you could define pred seperatly, without any problems
16:18:10 <mistay> but pred needs an argument
16:18:14 <boegel> idd
16:18:24 <mistay> argl
16:18:26 <mistay> pred x
16:18:27 <boegel> and that will be provided INSIDE repeat_until
16:18:32 <boegel> in it's definition
16:18:37 <mistay> jepp
16:18:39 <mistay> but ...
16:18:42 <mistay> pred x ...
16:18:44 <boegel> you can't see that
16:18:56 <paf> shapr: should we change the HC= ghc-5.04.3 for ghc-6.0 too?
16:19:02 <mistay> pred x ... the function is called pred with one parameter (x) ?
16:19:11 <shapr> paf: I changed mine to ghc6
16:19:45 <boegel> mistay: yes
16:19:49 <mistay> hmm
16:20:05 <boegel> mistay: pred x = ... if just used to define the 'meaning' of pred
16:20:18 <boegel> what should it do with the arguments it recieves
16:21:28 <mistay> i dunno
16:21:44 <mistay> it's a question from the exam last year
16:22:24 <boegel> what is ?
16:23:34 <mistay> hmm ... i think i misunderstand you
16:23:43 <boegel> mistay: I think so too :)
16:25:15 <boegel> mistay: any more questions ?
16:25:34 <boegel> and I think everyone ran as fast as they could, apparently :p
16:26:08 <mistay> aahhh
16:26:09 <mistay> damn
16:26:16 <mistay> i think i fully got it now
16:26:26 <boegel> jihaa :D
16:26:29 <mistay> thanx boegel
16:26:40 <boegel> no problem at all dude
16:27:03 <mistay> it's logical
16:27:05 <mistay> ;)
16:27:30 <boegel> mistay: that's the whole idea ;)
16:27:37 <mistay> yepp
16:27:48 <mistay> what are you guy's using this stuff?
16:28:02 <shapr> paf: Strange, it seems that (double x) is not part of %call -> http://www.haskell.org/greencard/downloads/greencard-latest/type-sig.html#SEC-CALL
16:28:26 <heatsink> mistay: yes.
16:29:10 <paf> someone is expert with greencard here?
16:29:19 <boegel> mistay: of course we use it ;)
16:29:37 <shapr> I wonder if you can declare custom %call marshallers
16:29:40 <boegel> you would be surprised what Haskell is capable of
16:29:45 <shapr> or if it's just from greencard 2
16:30:10 <mistay> boegel: what was your way to find haskell? are you personally interested in? is it your job?
16:30:36 <boegel> mistay: I had a class in non-procedural prog.lang. which teached me Haskell
16:30:53 <boegel> then I had another class in functional languages
16:31:05 <mistay> so you're a kind of a teacher?
16:31:20 <boegel> and now I'm doing a thesis with Haskell and a functional system to model my program in
16:31:39 <shapr> I'm a self-employed user of Haskell. I own my own business, and Haskell lets me write programs in less time so it costs my clients less money.
16:31:41 <mistay> hmm sounds teriffic
16:31:51 <boegel> mistay: want to see some results ?
16:31:56 <mistay> of course
16:32:03 <mistay> link me some results
16:32:11 <shapr> One of my clients is paying me to setup a mailing list search webapp I wrote in Haskell too.
16:32:15 <boegel> http://studwww.ugent.be/~kehoste/
16:32:18 <shapr> set it up for them.
16:32:37 <boegel> there's a link to my results, and also one of my friends
16:32:55 <boegel> mistay: http://www.haskell.org/practice.html
16:33:18 <mistay> i already found this page
16:33:29 <boegel> oh okay
16:33:42 <mistay> and i wondered that you can do so much with haskell
16:34:08 <shapr> paf: aha, double must be a DIS that's defined elsewhere... If that's true, probably just need to find it and include it...
16:34:35 <shapr> mistay: Haskell is a great language for concentrating on the solution.
16:34:38 <boegel> mistay: where are you from ? why do you need haskell ?
16:34:51 <paf> shapr: what's a DIS?
16:34:53 <mistay> i'm from austria
16:35:03 <shapr> paf: seems like a marshaller for a certain type
16:35:04 <mistay> have you ever heard of austria?
16:35:06 <shapr> paf: http://www.haskell.org/greencard/downloads/greencard-latest/dis-std.html
16:35:19 <boegel> mistay: and you have a class there at uni or so ?
16:35:21 <shapr> mistay: Don't they have Kangaroos in Leiderhosen? :-)
16:35:24 * shapr is joking!
16:35:30 <mistay> exactly
16:35:31 <boegel> mistay: I'm from Belgium, so yes I have
16:35:42 <shapr> I have some clients in Bavaria.
16:35:43 <mistay> hehe jepp: we dont have kangaroos
16:35:55 <mistay> we have a small university here in salzburg
16:36:00 <mistay> salzburg is a part of austria
16:36:08 <boegel> mistay: city ?
16:36:14 <mistay> jepp
16:36:20 <mistay> salzburg is a city
16:36:22 <mistay> where mozart is from
16:36:25 <boegel> mistay: how old are you ?
16:36:28 <mistay> have you heard from mozart?
16:36:36 <mistay> 23
16:36:53 <shapr> mistay: have you heard of Bach? :-P
16:37:10 <boegel> mistay: off course we have :D
16:37:10 * Pseudonym has heard of Goedel and Escher...
16:37:24 <mistay> hehe :)
16:37:31 <Heffalump> but not Bach? :-)
16:37:36 <mistay> mozart was livin' not far from my home
16:38:02 <shapr> Nifty. Is his house still up? Any of his stuff still around?
16:38:03 <mistay> http://langhofer.net/fotos/20041203_armin_geb23/tn/IMG_7728.JPG.html ... thats me
16:38:10 <mistay> yepp
16:38:12 <mistay> they keep it
16:38:21 <shapr> nice haircut
16:38:23 <mistay> and show it to all japanese women and men
16:38:45 <shapr> Here's my lovely haircut - http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
16:38:46 <boegel> mistay: nice tits :p
16:38:49 <mistay> http://langhofer.net/fotos/20041203_armin_geb23/tn/IMG_7770.JPG.html ...
16:38:55 <mistay> haircut :)
16:39:24 <boegel> mistay: oh, I thought you were the girl on the right :p
16:39:28 <mistay> the tits are from my sister ;)
16:39:34 <boegel> woops :p
16:39:41 * shapr oopses
16:39:49 <mistay> doesn't matter :9
16:40:02 <shapr> boegel: bad time to say that ;-)
16:40:09 <mistay> hehe jepp
16:40:15 <boegel> shapr: why?
16:40:28 <shapr> because it was his sister!
16:40:31 <mistay> so, its 01:38am here in austria
16:40:35 <boegel> shapr: so ? :p
16:40:41 <boegel> mistay: same here
16:40:43 <shapr> It's 1:38am here at the Arctic Circle.
16:40:49 <mistay> i'm goin to bed
16:40:52 <mistay> gn8
16:40:59 <mistay> thanx alot for your help
16:40:59 <shapr> g'nite, come back soon!
16:41:04 <shapr> I just got started coding!
16:41:07 <boegel> mistay: see you next time
16:41:12 <Pseudonym> Night.
16:41:16 <tuomov> 2:38
16:41:24 <shapr> And now I'm being distracted learning about greencard. Greencard is quite nifty.
16:41:33 <shapr> But it also seems like it should be working just fine.
16:41:36 <boegel> it's really hard to explain such basic stuff
16:41:46 <boegel> or was I just doing it completly wrong ?
16:42:54 * shapr wasn't watching, no idea
16:44:40 <reffie> yay, my forth compiler in haskell is starting to produce useful code :P
16:44:56 <reffie> http://rafb.net/paste/results/RuXUsC74.html
16:45:09 <Heffalump> reffie: have you read Chris Okasaki's paper?
16:45:09 <shapr> paf: I'm making some progress.
16:45:16 <reffie> ^- example compilation
16:45:17 <reffie> Heffalump no
16:45:20 <reffie> http://rafb.net/paste/results/9KOEJd22.html
16:45:21 <shapr> paf: still one set of errors I haven't figured out yet.
16:45:26 <reffie> ^- the ugly source code.
16:45:32 <Heffalump> ooh, ARM assembler? :-)
16:45:37 <reffie> Heffalump yeah :)
16:45:52 <boegel> I'm going to bed
16:45:57 <paf> shapr: what have you done so far?
16:46:06 <boegel> g'night everyone !
16:46:07 <reffie> Heffalump what is his paper about?
16:46:46 <Heffalump> http://journals.cambridge.org/bin/bladerunner?30REQEVENT=&REQAUTH=0&500000REQSUB=&REQSTR1=S0956796802004483
16:47:11 <reffie> ok, thanks
16:47:11 <shapr> g'nite boegel 
16:47:36 <reffie> oh you have to pay :(
16:47:47 <shapr> not if you get them from his homepage
16:49:06 <Heffalump> "Techniques for Embedding Postfix Languages in Haskell" on http://www.eecs.usma.edu/Personnel/okasaki/pubs.html is the same thing
16:49:12 <Heffalump> well, the conference version
16:49:16 <Heffalump> and that has a .ps file available
16:49:16 <shapr> paf: if you look at the examples in greencard Gdbm.gc has "%dis gdbmfile f = addr ({GDBM_FILE} f)" and then later %call (gdbmfile f) is used
16:50:37 <shapr> paf: you may not be interested in learning greencard, you may only want to use these DSP libs
16:51:55 <paf> shapr: indeed
16:53:15 <paf> shapr: I still have a lot to learn about Haskell..
16:53:49 <paf> so maybe learning greencard should not be my priority now
16:53:51 <Heffalump> reffie: in that compiled code, where does r10 get set up in the first place?
16:54:01 <reffie> Heffalump it doesn't :P
16:54:09 <Heffalump> so how does it work?
16:54:14 <reffie> it doesn't
16:54:16 <Heffalump> ah :-)
16:54:18 <reffie> i haven't done the stack initialization yet
16:54:37 <shapr> paf: well, I'll see if I can fix this quickly
16:54:40 <reffie> (r10 is the stack pointer)
16:54:46 <Heffalump> why not use r14 for the stack pointer like everyone else?
16:54:59 <reffie> Heffalump that's not a bad idea :)
16:55:56 <reffie> Heffalump i thought r13 was the stack pointer
16:56:25 <reffie> r14 is the address of the return address
16:56:28 <reffie> err
16:56:32 <reffie> r14 is the return address
16:56:43 <reffie> [from what i've seen]
16:56:56 <Heffalump> err, sorry
16:57:17 <Heffalump> my knowledge of these things is a bit flakey, still.
16:57:24 <reffie> i simply did s/r10/sp/
16:57:49 <reffie> gas recognizes 'sp', so it sohuld be good enough
16:58:19 <Heffalump> I was counting down from 15, and I forgot PC :-)
16:58:30 <Heffalump> so I thought the LR was 15, and the SP 14.
16:58:35 <reffie> :)
16:59:07 <Heffalump> [I work at ARM, on the compiler, so that's really a bit embarrassing. In my defence I only started 7 weeks ago..]
16:59:18 <reffie> cool!
17:00:34 <reffie> i'm doing this to learn how to write compilers..
17:01:19 <reffie> i think i've implemented the hard forth words, so the rest should be easy
17:01:30 <Heffalump> what architecture are you targeting?
17:01:35 <reffie> arm
17:01:50 <reffie> [so that i can run the stuff on the GBA]
17:02:15 <Heffalump> I mean what version.
17:02:23 <reffie> arm7
17:13:46 <shapr> Anyone here used greencard?
17:13:52 <shapr> I'm convinced it should be working...
17:14:02 <heatsink> reffie: How do you get the program into the GBA?
17:14:22 <reffie> heatsink i have a flash cartridge
17:14:26 <reffie> where i can upload code
17:14:27 <heatsink> ah.
17:14:49 <reffie> of course, when developping, it's easier to use an emulator
17:15:05 <heatsink> that works too.
17:26:40 <shapr> huh, I think I may have found the problem with greencard, but I dunno why it's doing this.
17:29:12 <shapr> Why wouldn't it be able to find the interface for Foreign.Greencard in Foreign/Greencard.hi ?
17:29:28 <shapr> The file is there, -v says it looked at that file, but doesn't like it?
17:30:09 <shapr> why?
17:31:13 <dons> you could dump the .hi file with --show-iface ?
17:31:24 <shapr> The files really in at least two of these places - http://www.scannedinavian.org/~shae/green-card-errors
17:31:35 <Pseudonym> Lunch.
17:31:37 <shapr> how do I call show-iface?
17:31:40 * shapr tries
17:31:44 <dons> ghcc --show-iface Foo.hi
17:31:56 <shapr> seem to work
17:32:26 <shapr> the .hi file shows the right dumped info
17:33:01 <shapr> but still, it won't find the interface in that file
17:33:05 <dons> those paths are potential paths searched. where is the actual Foreign/Greencard.hi file?/
17:33:17 <shapr> it's in two of those paths
17:33:52 <shapr> it started here /usr/local/lib/greencard-3.01/imports/Foreign/Greencard.hi and I symlinked it into ./Foreign/Greencard.hi as well
17:34:05 <dons> it says "Checking old interface for Numeric.Special.Airy" -- maybe sometihng changed?
17:34:14 <shapr> hm, could be
17:34:26 <shapr> but I think it's another symptom of the original problem
17:34:34 <shapr> I can't import Foreign.Greencard at all
17:34:53 <shapr> I had to manually cut'n'paste "%dis float x            = %%Float  ({HsFloat}  x)" into the Airy.gc soure
17:34:54 <shapr> source
17:35:06 <dons> is greencard a -package that  needs to be registered?
17:35:39 <shapr> yes, and it is built, installed, and registered
17:36:05 <dons> are the paths mentioned in the package.conf file correct?
17:36:25 <dons> (I think -v9 or so will dump package.conf contents)
17:37:17 <shapr> seems to be the right info
17:37:39 <shapr> library_dirs and import_dirs is right
17:38:53 <dons> does adding explicit -idir help?
17:39:04 <shapr> um
17:40:18 <shapr> these don't help --> -i/usr/local/lib/greencard-3.01 -i/usr/local/lib/greencard-3.01/imports
17:40:37 <shapr> -idir /usr/local/lib/greencard-3.01 doesn't help
17:41:26 <dons> i don't literally mean 'dir' -- it's a variable ;)
17:41:38 <shapr> ok then :-)
17:42:03 <shapr> why wouldn't explicit -i$DIR work? the .hi files are correct
17:42:29 <shapr> they're 6022 .hi files as well, though I would normally expect ghc to mention if they were 6.2.1 or so
17:42:44 <dons> yes. you get a 'magic' error from the .hi file
17:42:54 <dons> the first byte of the .hi file is the vers number
17:43:10 <shapr> I rebuilt, reinstalled, and reregistered greencard just to be sure. Still no joy.
17:43:57 <shapr> uhh
17:44:33 <shapr> oh nooo
17:44:51 <shapr> it's Foreign.GreenCard not Foreign.Greencard
17:44:52 * shapr cries
17:45:46 <monochrom> http://www.haskell.org//pipermail/haskell-cafe/2004-December/008148.html
17:47:28 <dons> hahehe
17:47:39 <dons> of course it is. there was a whole thread about the name change
17:50:24 * Darius is downloading 230MB of Java crap.
17:50:27 * Darius cries.
17:50:34 <shapr> Darius: ouch, why?
17:50:53 <Darius> Nokia cell phones use J2ME.
17:51:03 <shapr> oh, true
17:51:06 <shapr> I used to do that.
17:51:16 <shapr> Sure does suck :-)
17:51:47 <Spark> is that the 'development kit' then?
17:52:09 <Darius> Well with a 56k line, I'm wondering if it might not be quicker to get the KVM spec and implement a nicer language that compiles to java bytecodes.
17:52:16 <Darius> Spark: Yes.
17:52:24 <shapr> heh
17:52:30 <Darius> Spark: Then I'll need to find other packages to get things to work.
17:52:35 <Spark> doh
17:53:06 <shapr> My Nokia phone runs j2me apps. Funny thing is that my phone crashes more often than my desktop.
17:56:32 <shapr> how do I turn .a files into .o files again?
17:58:24 <wagle> what are you trying to do?
17:58:54 <shapr> I think I need to turn libHSgreencard.a into libHSgreencard.o
17:58:56 <wagle> library files are created with the "ar" command
18:01:10 <dons> HSgreencard.o, you mean shapr.
18:01:17 <shapr> ah, ok
18:01:41 <dons> one way is to run ghc-pkg on it
18:01:43 <ral1> shapr, do you remember me?  I asked you some questions here about a month ago.  You gave me "the tour"
18:02:32 <shapr> Yes, I remember. How ar ya ralf?
18:03:18 <dons> $(GHCI_LIBRARY) : $(LIBOBJS)
18:03:18 <dons>     $(LD) -r $(LD_X) -o $@ $(STUBOBJS) $(LIBOBJS)
18:03:38 <dons> the rule's in yi/mk/rules.mk
18:03:45 <ral1> shapr, I'm a little beat up.  I didn't get that job that I was talking about.  Ouch.  It was really a dream job, I guess. 
18:03:52 <ral1> And I would have been haskell coding all day. 
18:03:53 <wagle> the ar command, tickled with the right options, will list the .o files that it is composed of
18:04:20 <ral1> I still want to learn haskell.  But it's harder to be motivated since there is no clear job prospects.  
18:04:24 <shapr> ral1: Jack Black says "You only get one out of twenty auditions."
18:04:24 <wagle> http://www.grimmy.com/editorials.php
18:04:35 <ral1> shapr: Thanks. 
18:04:43 <ral1> I wish I had 20 auditions. 
18:04:51 <shapr> Go out and find 'em
18:04:56 <ral1> You're right though.  It was my first real job interview 
18:04:58 <ral1> after college
18:05:11 <ral1> Just gotta get back on that hourse
18:05:14 <ral1> horse. 
18:05:14 <shapr> Yup
18:05:24 <ral1> So I'm trying to learn haskell right now. 
18:05:25 <shapr> I had a bunch of job interviews before I got a job.
18:05:33 <ral1> Just going through some examples I downloaded
18:05:37 <ral1> are you happy with your job now? 
18:05:42 <ral1> Do you have a really cool one? 
18:05:48 <shapr> Sort of...
18:05:53 <shapr> I wish I had more paying haskell work.
18:06:10 <shapr> dons: thanks
18:06:11 <ral1> Yeah...  Did you go to grad school? 
18:06:43 <shapr> No, I didn't finish any degree, though I do have at least six years of college.
18:07:15 <Gahhh> hey dons
18:07:21 <shapr> I chose classes that interested me rather that aiming for a degree.
18:08:43 <shapr> I've had jobs doing illustration, sales, programming, making subway sandwiches, landscaping, hardware repair, installing and maintaining networks, sysadmin, web designer, and lots more.
18:08:43 <Gahhh> I am trying to build hc files on linux for cygwin, and not getting far. hsc2hs wants to include "winsock.h" etc.
18:09:06 <shapr> Yet again, I chose subjects that interested me rather than going for big money :-)
18:09:25 <shapr> I had great fun working in a comic book shop for some time.
18:10:32 <ral1> shapr: You know, I did about the same thing, taking classes according to my interest, but I ended up with a math degree after five years anyway through the miraculous grace of G-d. 
18:10:43 <shapr> Amazing.
18:11:36 <shapr> I narrowly missed finishing a two year degree in health physics (radiation safety). I also narrowly missed finish a two year degree in computer art.
18:11:40 <Philippa> I didn't know Gid helped so many people
18:11:43 <ral1> G-d, and also a math advisor named Judy who spends much of her time grabbing scruffy kids like me off of the streets of campus and graduating them. 
18:11:44 <Philippa> heh
18:12:08 <ral1> Were it not for Judy, I would still be in College today. 
18:12:32 * Philippa nods - were it not for my tutors I wouldn't. And I wouldn't have graduated either
18:12:52 <shapr> I enjoyed college, I learned a lot though I have no degree. I think this rather the opposite of what most of the attendees ended up with.
18:15:32 <arjanb> what is G-d?
18:15:48 <Philippa> I imagine the missing letter's an o
18:16:01 <Philippa> shapr: heh
18:16:06 <arjanb> doh
18:16:44 * Philippa wishes the XP nut on cgdpm would stop trying to put words into her mouth or tell other people what she meant
18:17:14 <Gahhh> People, what Philippa means by this is....
18:18:01 <shapr> eXtreme Programming!
18:18:10 <Gahhh> AMD XP processors !
18:18:11 <shapr> paf: I think I finally fixed it.
18:18:38 <shapr> yay! it's building!
18:18:47 <shapr> w00! it finished!
18:19:17 <heatsink> It's surprising how many people think computer architects take drafting classes.
18:19:34 <Gahhh> computer architects grow on trees, imo
18:20:35 * Darius sure hopes all this cell phone stuff will work with Java 1.5...
18:22:07 <ral1> shapr: that sounds like a fair diagnosis. 
18:23:10 <paf> shapr: really? wow
18:23:32 <heatsink> Gahhh: are you calling us fruits?
18:24:31 <monochrom> no, leaves
18:25:23 * heatsink isn't leaving
18:26:04 <heatsink> oh, leaves
18:26:13 <shapr> paf: change green-card to greencard "HC= ghc" replace "import StdDIS" in all files with "import Foreign.GreenCard" make sure you have libblas and atlas3 installed
18:26:15 <shapr> I think that's everything.
18:26:16 <Gahhh> Are you a computer architect ?
18:26:29 * shapr quickly drafts a computer.
18:26:31 <heatsink> yea
18:26:44 <Gahhh> nice meeting you. Can I have this laptop autographed ?
18:28:03 <paf> shapr: I have atlas3
18:28:04 <heatsink> I wouldn't want people to think you stole it from me.
18:28:13 <paf> shapr: I'll try that
18:31:26 <shapr> paf: if you want I can send you a tarball of source that should work
18:35:13 <paf> shapr: yes, please, that would same me some time
18:35:15 <paf> thanks
18:44:26 <shapr> paf: http://www.scannedinavian.org/~shae/dsp-fixed.tar.gz
18:52:10 <shapr> paf: Do you think these DSP libraries would be useful for simple voice recognition? I was thinking of a speech recognition system where the speech is designed to be easily recognizable, not english or any other natural language.
18:54:23 <paf> shapr: of course it could help to build a speech recognition system
18:54:36 <Philippa> in case anybody cares: http://www.scannedinavian.org/~flippa/Flippi for a darcs repo
18:55:00 <paf> shapr: what do you mean by "speech designed to be easily recognizable"
18:55:43 <paf> shapr: make still tells me:
18:55:44 <paf>  http://www.scannedinavian.org/~shae/dsp-fixed.tar.gz
18:55:47 <paf> argh
18:55:55 <paf> user error ("Numeric/Special/Airy.gc", proc. spec "airy_Ai", line 41:
18:55:55 <paf>       marshall: Don't know how to marshall (double x)
18:56:51 <shapr> I want a spoken programming language, but I don't think my first few attempts will be elegant. I also want a very fast bootstrap, because my wrists have some RSI already. So I need a spoken assembly language.
18:57:38 <shapr> So I thought I would record myself talking, and find a nice binary number of easily recognizable speech features and use those to create spoken assembly language.
18:57:42 <paf> shapr: Have you think about a Music to assembly language compiler? (why not :)
18:57:54 <paf> you could sing your program
18:58:06 <shapr> I thought about that, but I wasn't sure how to approach it.
18:58:21 <paf> vowels can be easy to differentiate
18:58:24 <wli> whoa
18:58:27 <shapr> But, it's more important that I have something that just sort of works, so I don't have to use my wrists so much.
18:58:30 <wli> paf: where are you getting Airy functions?
18:58:45 <paf> you can add pitch detection to control other variables
18:59:12 <paf> wli: when I try to make haskelldsp
18:59:13 <shapr> strange, it builds here just fine
18:59:27 <paf> shapr: what could it be?
19:00:55 <shapr> Probably an error on my part because it's 4am here.
19:01:00 <shapr> lemme try it again.
19:01:08 <paf> ok
19:01:32 <shapr> Yes, I think it was my error. I'll create a new tarball.
19:01:33 <wli> paf: hmm, lots of neat functions
19:01:46 <paf> wli: indeed
19:02:19 <paf> wli: If I'm not mistaken, you were trying to program a SVD decomposition the other day.
19:02:33 <shapr> I do think that singing etc would be good areas to explore for more voice 'bandwidth' without adding much complexity to the input system.
19:02:44 <paf> wli: what happened to it?
19:03:12 <paf> wli: I mean, have you made one finally?
19:03:30 <wli> paf: I ended up just using R
19:03:54 <Philippa> <paf> vowels can be easy to differentiate <- Old MacShapr had a monad, e-i-e-i-o...
19:03:55 <paf> shapr: your syntax has to be simple
19:04:15 <paf> :)
19:05:03 <Darius> shapr: I already suggested a concatenative language would be good for that.
19:05:25 <shapr> dang, I wanted to ask more questions about that.
19:05:59 <wli> holophrastic
19:06:00 <paf> shapr: the thing is, speech to text system are complex and prone to errors, but if you could only use tones (frequencies) and different timbres (vowels) to write code it could be easy to do.
19:06:09 <shapr> paf: http://www.scannedinavian.org/~shae/dsp-fixed2.tar.gz
19:06:31 <tuomov> morse!
19:06:36 <shapr> I don't really care about exact text, I just want executable input of some type.
19:06:50 <paf> what was that concatenative language Darius was talking about?
19:06:57 <shapr> Joy
19:07:03 <shapr> At least, that's my favorite concatenative language.
19:07:08 <Philippa> write a [(tone,timbre)] -> BrainFuck converter
19:07:21 <paf> you don't care about exact text?
19:07:34 <paf> what do you mean?
19:07:46 <shapr> text is not code
19:08:26 <paf> you mean assembly code?
19:09:07 <shapr> I just mean that speech to execution is what I want, text is not a necessary midpoint.
19:09:23 <Philippa> you want to have to listen to code to grok it? eww
19:09:38 <Philippa> I sure as hell never read code linearly to understand it
19:09:41 <shapr> I'm sure there are unambiguous spoken inputs that are difficult to represent as text, but that's fine with me.
19:10:07 <paf> shapr: same thing (Don't know how to marshall (double x))
19:10:11 <shapr> I was actually thinking of a nice OpenGL description
19:10:24 <shapr> paf: where's your GreenCard.gc file?
19:10:48 <paf> /home/me/ghc-6.2.2/libraries/greencard-3.01/lib/Foreign/
19:10:58 <shapr> ah, ok
19:11:05 <paf> an OpenGl description?
19:11:08 <paf> mmm
19:11:29 <shapr> I've always thought a spellcasting paradigm is a good programming interface.
19:11:30 <paf> and then you would like to convert it to code?
19:11:37 <shapr> what do you mean?
19:11:54 <paf> compile it
19:12:01 <shapr> oh, sure
19:12:12 <shapr> I was thinking of starting with an interpreter first
19:12:27 <paf> isn't the graphical representation ambiguous?
19:12:30 <shapr> something where I can see how my inputs are executed
19:12:56 <shapr> ambiguity depends on semantics
19:13:11 <paf> have you ever played with speech processing?
19:13:18 <shapr> nope
19:13:34 <paf> I'd like to help you for that project.
19:13:44 <paf> It could be fun
19:14:04 <shapr> paf: change GC_PATH= to the right place
19:14:22 * shapr is confused
19:14:38 <shapr> my GC_PATH is wrong, but the build works.
19:14:42 <shapr> too weird
19:16:23 <shapr> paf: does ghc-pkg show greencard?
19:16:37 <shapr> paf: yah, I think it could be lots of fun
19:17:17 <shapr> I'm trying to build a spiral-based writing system that uses the same ideas, tune the writing to ease of recognition rather than legacy understadning.
19:17:47 <shapr> I'd like to have a written system that has some sort of shorthand or other compression built in...
19:17:50 <paf> how do you know ghc-pkg shows greencard?
19:18:07 <shapr> I've been wondering how to do sliding window compression with handwriting.
19:18:18 <shapr> you run ghc-pkg -l
19:18:51 <shapr> Spoken languages already use pronouns as compression, I'm just not sure yet how to extend that idea.
19:19:05 <paf> oh, non, I can't see greencard
19:19:48 <shapr> if you change GC_PATH= to point to the same dir with Foreign/GreenCard.gc it may still work
19:19:52 <paf> but greencard AND green-card are installed on my computer
19:20:01 <shapr> otherwise you may need to build and install greencard into your GHC installation.
19:20:06 <shapr> that's strange
19:20:48 <shapr> oh did you do make install-pkg after make install?
19:21:01 <paf> mmm, not sure
19:21:12 <shapr> Prounouns only have sentence scope.
19:21:35 <shapr> I wonder if scaling up to page scope would make a difference.
19:21:42 <Spark> http://www.syslog.com/~jwilson/pics-i-like/ponyboy.jpg
19:21:43 <Spark> be inspired
19:21:45 <shapr> lojban has 'numbered pronouns'
19:21:59 <shapr> iirc, there are five or so
19:23:33 <paf> I remember now, it doesn't work when I try to install-pkg greencard
19:23:35 <shapr> American Sign Language has positional pronouns. A given angle from the body is assigned to be that person or object, and you point to it when you want to refer to it. 
19:23:40 <shapr> what's the error?
19:23:54 <paf> ghc-6.2.2: unrecognised flags: -fno-prune-tydecls
19:23:58 <shapr> oh right
19:24:03 <shapr> I just removed that 
19:24:11 <shapr> you have to remove it from two Makefiles though
19:24:19 <shapr> top-level and in lib/ I think
19:24:27 <paf> what would be the use of 'numbered pronouns' in a spoken programming language?
19:24:41 <paf> which Makefiles?
19:24:50 <shapr> What's the use of named values in a programming language?
19:25:11 <paf> mm
19:25:17 <shapr> it's the difference between having to use anonymous lambdas for everything or being able to name a bit of code.
19:25:26 <paf> I see
19:25:26 <shapr> the Makefiles in greencard
19:26:47 <shapr> dang, I don't know darius' new email address.
19:27:02 <paf> ok, only the lib/Makefile
19:27:08 <paf> greencard is in ghc now
19:27:19 <shapr> ok, try it again
19:28:27 <paf> same error. What should GC_PATH be?
19:28:39 <paf> I tried the Foreign dir
19:29:24 <paf> I tried /usr/local/lib/green-card also
19:30:14 <shapr> you're using greencard-3.01 ?
19:30:22 <shapr> yes, you are
19:30:23 <paf> yes
19:30:45 * shapr is confused
19:30:47 <paf> Why function names should be 'numbered pronouns' and not verbs or adjectives?
19:31:02 <shapr> prounouns should be able to refer to anything
19:31:09 <shapr> they're just like variable names
19:31:17 <shapr> any first class citizen can be named
19:32:07 <shapr> Are you sure you unpacked the tar.gz I gave you? Are you using the old sources?
19:32:35 <paf> yesd, sp-fixed2.tar.gz
19:32:55 <shapr> If you look at the Airy.gc file, does it have "import Foreign.GreenCard --StdDIS" near the top?
19:32:56 <paf> I just did it again
19:33:39 <paf> yes import Foreign.GreenCard -- StdDIS
19:34:16 <heatsink> shapr: So you can't give slaves or foreign nationals names?
19:34:34 <shapr> heatsink: guess not
19:35:24 <shapr> paf: what is the failing make command?
19:35:31 <heatsink> Only if they get reified. But here you have to be at least 35 for that to happen. I don't know what the law is elsewhere.
19:36:17 * shapr is getting sleepy
19:36:24 <paf> greencard -t ffi -i /usr/local/lib/green-card  Numeric/Special/Airy.gc
19:36:46 <paf> reified?
19:38:31 <heatsink> made king
19:38:58 <shapr> paf: where's your GreenCard.gc file?
19:39:00 <heatsink> paf: http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=reify
19:40:35 <paf> /home/me/ghc-6.2.2/libraries/greencard-3.01/lib/Foreign/
19:41:15 <shapr> maybe --> greencard -t ffi -i /home/me/ghc-6.2.2/libraries/greencard-3.01/lib Numeric/Special/Airy.gc
19:41:25 <paf> heatsink: oh.
19:41:55 <heatsink> Just making pun.
19:43:26 <paf> :)
19:43:43 <paf> shapr: seems to work
19:44:09 <paf> I have this message at the end:
19:44:11 <paf> make: warning:  Clock skew detected.  Your build may be incomplete.
19:44:33 <paf> Is it because you live in the future (I'm in US today)
19:44:37 <paf> ?
19:45:06 <shapr> haha, I think so.
19:45:17 <shapr> I've come back in time to save your program!
19:45:17 * shapr snickers
19:45:33 <paf> funny...
19:45:57 <paf> do I need to do a install-pkg now?
19:49:48 <shapr> I don't think so
19:49:54 <shapr> just go into the demo subdire
19:50:08 <shapr> then ghc --make Article -i..
19:52:25 <shapr> does it work?
19:54:09 <paf> what sould I put after -i?
19:54:49 <paf> Article.hs:
19:54:49 <paf>     Can't find module `Numeric.Transform.Fourier.FFTUtils'
19:58:48 <shapr> it should be -i..
19:59:04 <shapr> the root of the DSP sources directory is the directory above demo
19:59:19 <paf> ok
19:59:21 <paf> :)
19:59:30 <paf> I though you mean ...
19:59:54 <shapr> heh, no
19:59:58 <shapr> sensible interpretation though
20:00:07 <shapr> I'm about to got to sleep...
20:00:32 <paf> real    0m1.071s
20:00:32 <paf> user    0m1.000s
20:00:32 <paf> sys     0m0.010s
20:00:34 <paf> thanks
20:02:37 <shapr> yay!
20:02:53 <shapr> if you have more questions, I'll be here tomorrow.
20:02:58 <paf> ok
20:03:06 * shapr falls over asleep
20:37:52 <wli> well I mostly have the differencing stuff done
21:08:21 <paf> wli: you said you ended up using R?
21:08:30 <wli> paf: yes
21:08:36 <paf> oh, you mean the language?
21:09:58 <paf> I never used R, is it nice? how does it compare to matlab (or Octave)?
21:10:43 <wli> no idea; I used some boilerplate command Itkovian showed me
21:11:17 <paf> ok
21:30:14 <blackdog> anyone ever tried configuring Asterisk, the open source PABX? Those guys _seriously_ need a language designer.
21:55:06 <aj> phwoar
21:55:14 <aj> happy looks awesome
21:55:22 <aj> (that remark censored for your enjoyment :)
22:08:16 <Itkovian> heh
22:08:31 <Itkovian> wli: u can use ?<command> at the R prompt or help(<command>)
22:08:36 <Itkovian> now I'm off to work
23:42:29 <aj> okay, happy sucks, but parsec looks awesome! :)
23:48:31 <aj> oh, hrm, except thousands of lines per second isn't really that fast is it
23:52:20 <ibid> why does happy suck?
23:57:08 <Itkovian> meuning
23:57:16 <ibid> morning
23:59:02 <dons> happy's pretty good -- ghc uses it, after all
23:59:50 <ibid> heh
