00:14:49 <vegai> MegaMonad: priceless.
00:14:55 <MegaMonad> vegai: So i'm really running your program typechecks ok, in which it conjures is priceless.
00:31:09 <Lemmih_> @seen shapr
00:31:09 <lambdabot> shapr is in #haskell and #haskell.se.
00:31:18 <Lemmih_> shapr: Hey!
00:34:18 <Lemmih_> shapr: I would like you to host a darcs mirror of Hackage if it isn't too much of a problem.
00:45:20 <musasabi> What would be the step to use a different C compiler than gcc with ghc?
01:42:18 <Itkovian> musasabi: are there any gcc specific idioms used in ghc?
01:44:51 <musasabi> to some extent (that is quite comlex)
01:50:42 <Itkovian> ouch
02:04:09 <Amadan> MegaMonad: good morning. no sleep for the wicked, eh?
02:04:15 <MegaMonad> Amadan: You can sleep if you really lost me, eh i'll go searching for new values, rather than going via sk combinators would be wicked.
02:05:00 <Amadan> MegaMonad: I quite agree, SK combinators make my head spin.
02:05:06 <MegaMonad> Amadan: The other thing about command line with only evaluating the head of the combinators in the spin of an array comprehension.
02:05:56 <Amadan> MegaMonad: Good luck with those new values.
02:06:02 <MegaMonad> Amadan: But there's a demo of haskell values, and then link in the new name of the values in general.
02:07:04 <Amadan> MegaMonad: Okay, do you believe yourself in these haskell values?
02:07:10 <MegaMonad> Amadan: All okay, but how haskell know that the values out from the docs of it myself.
02:07:36 <Amadan> MegaMonad: I don't know. I'm asking you.
02:07:42 <MegaMonad> Amadan: Are you asking me the point is that you're going to happen later in the char list.
02:08:04 <Amadan> MegaMonad: Not quite, no.
02:08:10 <MegaMonad> Amadan: Ah yes, i have some greek letters and mathematical symbols; just the mathematical theory and fixpoints.
02:08:38 <Amadan> I'm sure you do. Lambda, at the very least, I'd expect.
02:08:42 <Amadan> MegaMonad: I'm sure you do. Lambda, at the very least, I'd expect.
02:08:50 <MegaMonad> Amadan: For example, if you're into the untyped lambda calculus, or lambda calculus interpreter, but it's going to expect me to try running our internal lan on ipv6 support?
02:09:47 <Amadan> Yes, that would be bad... I have no idea what kind of support for IPv6 pure lambda calculus has.
02:09:51 <Amadan> MegaMonad:Yes, that would be bad... I have no idea what kind of support for IPv6 pure lambda calculus has.
02:09:59 <MegaMonad> Amadan: I see pure like that at the idea of lifting is that getting stuff done, get out of the calculus.
02:11:02 <Amadan> MegaMonad: I did get out of calculus, now I'm a programmer and a hobby linguist. Let lifting be done by others.
02:11:08 <MegaMonad> Amadan: Dunno if that would require licensing it as soon as you is that lifting is that there are others.
02:11:55 <Amadan> MegaMonad: Licensing what?
02:12:00 <MegaMonad> Amadan: Bool is an array first of the licensing change.
02:12:39 <Amadan> MegaMonad: This looks strangely like a zen aphorism. Have you been downloading too much from .jp?
02:12:45 <MegaMonad> Amadan: Downloading the whole block instead of $ if you dislike it.
02:13:35 <Amadan> MegaMonad: I don't dislike $. I use it all over. Why would that be an alternative to zen?
02:13:41 <MegaMonad> Amadan: Because in the type, like complex numbers are really unlikely with a good programmer is very zen...
02:14:32 <Amadan> MegaMonad: I'm impressed! I asked "why", and you replied with "because"... Nice AI.
02:14:38 <MegaMonad> Amadan: Because to me it was quite impressed with the rest of the ai work in this channel?
02:15:25 <tromp> MegaMonad When do you give the right answer to questions about time?
02:15:39 <tromp> MegaMonad: When do you give the right answer to questions about time?
02:15:45 <MegaMonad> tromp: Answer out of the mutlitude of functional programming book: chapter 1 "binary search trees have the right time to be me right now.
02:16:00 <Amadan> rofl
02:16:25 <tromp> MegaMonad: what's a mutlitude?
02:16:30 <MegaMonad> tromp: Blackdog: i think part of the mutlitude of functional programming.
02:16:43 <tromp> now we know who can't spell:)
02:19:07 <Amadan> MegaMonad: spell anachronism!
02:19:13 <MegaMonad> Amadan: And wants to spell today.
02:19:54 <bringert> MegaMonad: shut up
02:20:00 <MegaMonad> bringert: Wait, is there snow or heatwaves... We shut down.
02:20:14 <bringert> MegaMonad: not down, up!
02:20:20 <MegaMonad> bringert: Is it that haskell will automatically reprompt them for the welcome. I've used python instead.
02:20:35 <bringert> MegaMonad: what, you use python instead?
02:20:41 <MegaMonad> bringert: Where callvalue is my haskelldb module for lambdabot that use each of the elements add up the religuous angle a lot of python i would want to catch up with the given string or deal with when type checks are actually only interested in me.
02:21:15 <bringert> MegaMonad: cool, where can I get your haskelldb module for lambdabot?
02:21:21 <MegaMonad> bringert: Personally, i want haskelldb for a lambdabot module.
02:21:40 <bringert> MegaMonad: I thought you said you already had one?
02:21:47 <MegaMonad> bringert: I thought it was you and me have a nifty little program.
02:23:28 <Amadan> bringert: You and MegaMonad have offspring?!?
02:24:52 <Amadan> MegaMonad: what are your little programs called?
02:24:57 <MegaMonad> Amadan: And then tell me where my types can be to design my programs.
02:27:23 <bringert> MegaMonad: in your programs, presumably
02:27:29 <MegaMonad> bringert: Presumably not the rest of my programs do have the source where my mouth is.
02:29:27 <Amadan> MegaMonad: If I get fired any time soon, I want you to know that it's all your fault.
02:29:32 <MegaMonad> Amadan: Did i not sure what time of the best way is your fault?
02:30:57 <Amadan> MegaMonad: Were you aware that Haskell Wiki is Python-powered?
02:31:03 <MegaMonad> Amadan: Another argument against haskell that a wiki that is python.
02:45:32 <bringert> Amadan: I guess we do. Maybe MegaMonad is talking about his haskelldb module for lambdabot. I'm involved in haskelldb.
02:45:42 <bringert> MegaMonad: you better show use that program
02:45:50 <bringert> MegaMonad: make that "show us"
02:45:56 <MegaMonad> bringert: Then we can pry the monopolies out of me i can always use a different program?
02:46:02 <MegaMonad> bringert: "Some of my understanding all points in yi would be they meant => (implies.
02:46:23 <bringert> MegaMonad: yes, quit hoarding, give up you monopoly
02:46:29 <MegaMonad> bringert: Quit a lot into a monopoly.
02:46:48 <bringert> MegaMonad: weel, stop that
02:46:54 <MegaMonad> bringert: Where did you stop a few evenings and it doesn't stop me from loving haskell and one argument to the better or worse than they actually work over the role of language do it, all parameterized by, say, 3 type variables.
02:47:43 <bringert> MegaMonad: I've talked to real people less coherent than you
02:47:49 <MegaMonad> bringert: This exchange reminds me of the people to be pretty coherent.
02:48:04 <bringert> MegaMonad: my point exactly
02:48:10 <MegaMonad> bringert: My point exactly, i think your idea to working in exactly the reason: if there were some people apparently need to worry about this again in haskell, maybe || ? Maybe or.
02:48:57 <bringert> MegaMonad: the advantage of communicating in haskell is that the type checker enforces some degree of coherency
02:49:04 <MegaMonad> bringert: I have a little more coherency on the degree of coherency.
02:49:14 <bringert> MegaMonad: quite so
02:49:20 <MegaMonad> bringert: (+ Faero islands?) (abc.
02:49:52 <bringert> does MegaMonad learn from these conversations?
02:50:05 <bringert> or only when explicitly told to learn?
02:51:38 <tuomov> I think it learns all the time
02:52:00 <tuomov> MegaMonad: are you learning from all conversations?
02:52:06 <MegaMonad> tuomov: Marvin--: in finnish they call i i and a couple of hours studying other paintings, learning technique and so forth aren't involved in europython, especially for such conversations.
02:58:11 <Amadan> MegaMonad: if you're learning, you won't mind remembering supercalifragilisticexpialidocious, will you?
02:58:16 <MegaMonad> Amadan: Pseudonym: do you mind that i'm remembering.
02:58:26 <Amadan> supercalifragilisticexpialidocious
02:58:32 <Amadan> MegaMonad: supercalifragilisticexpialidocious
02:58:39 <MegaMonad> Amadan: I gotta go to monster.com, you won't mind remembering supercalifragilisticexpialidocious, will you?
02:58:44 <Amadan> see?
02:59:34 <Amadan> MegaMonad: No, of course I don't mind that you're remembering.
02:59:40 <MegaMonad> Amadan: Oh, sorry, it removes the intermediate one (which definition i believe you, i don't mind, but i dunno if i'll get a high-level means that you're remembering.
03:12:36 <musasabi> How should one create execution contexts (aka processes) on top of GHC threads?
03:19:10 <earthy> ofcourse, you can also say it backwards, which is dociousaliexpi-isticfragicalirupos, but that's going a bit too far, don't you think?
03:20:28 <earthy> (yes, it is wrong, but that's how it's in the movie ;))
03:23:25 <xerox> Which movie?
03:24:01 <musasabi> The execution context thing may be what I am after, but how would I associate threads with an execution context? My only idea would be to have a hash-table of ThreadID -> Data which is not very elegant.
03:24:28 <earthy> xerox doesn't know the etymology of supercalifragilisticexpialidocious?
03:31:25 <tuomov> MegaMonad: what should I do when I'm big?
03:31:26 <tuomov> :)
03:31:31 <MegaMonad> tuomov: Cale: kk thnx.
03:31:43 <tuomov> MegaMonad: hmmm...
03:31:49 <MegaMonad> tuomov: Hmmm crate my own library.
03:31:51 <Poseidon> hi
03:32:10 <tuomov> MegaMonad: build you a library?
03:32:16 <MegaMonad> tuomov: Well, that is me in a library.
03:32:50 <Poseidon> Can haskell be used for web development and does it have webserver and or a database or an implementation of anything databaseish
03:32:56 <Poseidon> ?
03:34:39 <Lemmih_> Poseidon: http://localhost/cgi-bin/hackage/hackage is written in Haskell.
03:35:36 <musasabi> Poseidon: yes, yes, yes and yes.
03:35:51 <xerox> he means, yes.
03:36:00 <juhp> Lemmih_: localhost?
03:36:02 <Lemmih_> Poseidon: And HaskellDB makes database access safe and easy.
03:36:06 <Lemmih_> ARgh!
03:36:30 <Lemmih_> http://www.scannedinavian.org/cgi-bin/hackage/hackage
03:36:43 <juhp> ah, thx :)
03:42:38 <Poseidon> haskellDB hmm looking
03:43:09 <Poseidon> HaskellDB is a combinator library for expressing queries and other operations on relational databases in a type safe and declarative way. All the queries and operations are completely expressed within Haskell, no embedded (SQL) commands are needed. 
03:43:17 <Poseidon> what does this mean
03:44:46 <Poseidon> in my primitive understanding this means somehow haskell can express sql queries, and then give them to a db, but can it recieve the answers and format them for web serving in a practivle way?
03:44:56 <Poseidon> cle
03:45:15 <musasabi> yes.
03:45:18 <xerox> Another question, how does this fold work? :
03:45:20 <Poseidon> does anyone here have a haskell powered web site?
03:45:30 <xerox> cfold' f z [] = z
03:45:30 <xerox> cfold' f z (x:xs) = f x z (\y -> cfold' f y xs)
03:45:30 <xerox> cfold f z l = cfold' (\x t g -> f x (g t)) z l
03:45:32 <Lemmih_> Poseidon: Hackage is written in Haskell...
03:45:45 <musasabi> Poseidon: internally yes.
03:47:08 <xerox> Book says it's CPS, but doesn't explain it very well.
03:48:26 <Poseidon> what do you use haskell for?
03:49:05 <Lemmih_> Pretty much everything.
03:49:33 <Poseidon> do you use it instead of say perl for small tasks?
03:50:23 <Lemmih_> Define small tasks.
03:50:27 <musasabi> depends. I use perl if I don't want to read the thing afterwards - if it is something I have to work for more than 15min then usually haskell.
03:52:03 <Poseidon> I am currently a bash programmer
03:52:08 <Poseidon> I hate perl so far
03:52:34 <Poseidon> lisp or haskell seem very interesting, but tcl also has it seems a lot going for it
03:52:51 <xerox> Has someone the time to explain me the cfold/cfold' I pasted previously?
03:53:11 <Poseidon> haskell is very new, I like to think new things have the advantage of history to go into thier making and can then be superior, 
03:53:12 <xerox> Or just point me to some documentation
03:53:12 <Amadan> gakk... recently i had to make a rather simple bash script... i had to escape some characters with 10 (ten!) backslashes to make it work...
03:53:43 <Poseidon> I dont like the problem of reading later with perl
03:54:00 <Poseidon> what compiler do you reccomend for beginning haskeler
03:56:43 <musasabi> Poseidon: I would go with GHC.
03:57:03 <musasabi> ghci is quite nice for interactive use and ghc can generate native binaries.
03:57:55 <Lemmih_> Poseidon: Hugs is also a choice if you're limited on bandwidth or hd space.
03:58:40 <Poseidon> dsl 80gig hd
04:00:06 <Poseidon> ghc is the consensus then?
04:00:19 <Poseidon> do you guys see industry using haskell in the future?
04:00:27 <Poseidon> is it kick azz
04:00:43 <Poseidon> doesnt seem to have the hype of perl or tcl or python sites
04:04:21 <Lemmih> I don't think Haskell will gain major acceptance in any near future.
04:04:48 <Itkovian> nah ...
04:04:59 <Poseidon> hmm
04:05:13 <Poseidon> how depressing
04:05:19 <Poseidon> any startups use it?
04:06:14 <Poseidon> what kind of competitive advantages could one get from using haskell as a tool for business websites?
04:06:16 <Amadan> xerox, i'll try, but i'm not far from beginner myself, so i'll learn along and try not to confuse you overmuch :)
04:06:36 <Amadan> do you understand what a continuation is?
04:07:02 <Poseidon> me/
04:07:04 <Poseidon> me?
04:07:12 <Amadan> xerox :)
04:07:16 <Poseidon> sorry
04:07:32 <arjanb> Poseidon: learning Haskell will make you a better programmer no matter what language you will use in the future
04:08:23 <xerox> Amadan, uh sorry
04:08:28 <xerox> they called me, no i don't know it
04:08:35 <Lemmih> Poseidon: Haskell offers some static guaranties and a very expressive syntax.
04:08:55 <Amadan> okay, a continuation is what is going to happen to a value later.
04:09:17 <Amadan> for example, when you write 1+2, the continuation of "1" is that it gets added to 2.
04:09:28 <xerox> mh ok
04:09:42 <Amadan> so you can rephrase 1+2 as (\x -> x + 2) 1
04:09:56 <xerox> yes.
04:11:17 <Amadan> now, normally, continuations are implicit. when you write 1+2, the compiler takes care that (+2) is the continuation of 1.
04:11:38 <Amadan> but you can write a continuation for a value explicitly, too, like above.
04:12:10 <Amadan> and then you can give it to a function. like, calculate your value, but then instead of returning it here, do this other thing with it.
04:12:32 <xerox> uhm
04:13:02 * dblhelix is away: out to lunch
04:13:29 <Amadan> so cfold gives (\x t g -> f x (g t)) as a continuation to cfold', as an explicit thing to do with its result when it's done.
04:13:57 <Amadan> the first line of cfold' is the termination condition - that's easy to understand.
04:14:13 <xerox> can you express 'z' in other terms?
04:14:38 <xerox> f is the continuation, z .. ?
04:14:47 <Amadan> z? z is the null element. it's the same thing as in foldl. and l is the list.
04:15:10 <xerox> oki
04:16:23 <Amadan> um. yes, i see the confusion... f is employed with two meanings. f in cfold is the folding function. f in cfold' is the continuation.
04:17:07 <xerox> yep, different fs!
04:17:08 <tromp> it doesn't seem to be pure cps
04:17:33 <tromp> because then the continuation would be used in the terminating case as well
04:18:02 <xerox> cps is something like partial evaluation?
04:19:23 <tromp> no, it's more like replacing g (f x) with f' x g
04:19:30 <Amadan> tromp, please do correct me if i'm blundering, 'cause i'm trying to sort out my own thoughts about cps at the same time :)
04:20:15 <xerox> mmh
04:20:17 <tromp> in cps you give functions an extra parameter, the continuation, that's to be applied to the function's result
04:21:09 <tromp> so, plus in cps style is (+) c x y = c (x+y)
04:21:32 <Poseidon> well
04:21:36 <Poseidon> hows haskell folks
04:21:40 <Poseidon> hows the haskelling
04:21:54 <xerox> (+) c x y ?
04:22:01 <Muad_Dibber> hi all
04:22:09 <xerox> hiya Muad'
04:22:42 <Muad_Dibber> what's new here?
04:22:53 <xerox> talking about CPS
04:23:03 <Amadan> i'm struggling to explain cps to both xerox and myself :)
04:23:12 <Muad_Dibber> oi
04:23:16 <Muad_Dibber> in 1 line, what is CPS? :)
04:23:21 <xerox> *gee*
04:23:29 <xerox> <tromp> so, plus in cps style is (+) c x y = c (x+y)
04:23:32 <r3tex> morrn
04:24:20 <xerox> tromp, what would be c in that case?
04:24:47 <xerox> Show ?
04:24:54 <tromp> can be anything. whatever computation needs to do a plus
04:25:11 <xerox> mmh
04:25:16 <Amadan> it's meaningless unless you want to do something else. in just "1+2", c=id
04:25:33 <xerox> isn't the addition computation did in the parens?
04:25:38 <Amadan> in "(1+2)*3", c is (\x -> x * 3)
04:26:21 <xerox> so "only plus" in CPS is f c x = c x; f (+) 1 for example?
04:27:15 <Amadan> ... i don't think so.
04:27:28 <xerox> :-(
04:27:38 <Amadan> plus c x y = c (x+y), as tromp said.
04:27:53 <Amadan> and, let's say: times c x y = c (x*y)
04:28:04 <xerox> gee..
04:28:34 <xerox> so in the continuation isn't the thing being done, but the thing to do /after/ the computation ?
04:28:59 <Amadan> then instead of (1+2)*3, you'd say (plus (\x -> times id x 3) 1 2), if i understand it correctly.
04:29:01 <Amadan> yes.
04:29:13 <xerox> i think i understand it
04:29:25 <Amadan> here, you're first doing the addition; and the continuation of addition is multiplication with 3.
04:31:01 <Amadan> you can notice that the syntactic structure has changed with CPS: normally you'd write it as (times (plus ...) ...), now we're doing it "in reverse"
04:31:33 <xerox> Mmh, interesting.
04:32:07 <tromp> cps can be handy for parsers
04:32:08 <Amadan> now let's try the fold again.
04:32:20 <Amadan> a bit reworded
04:32:26 <Amadan> cfold' c z [] = z
04:32:41 <xerox> tromp, the book gives the types of two parsing function, but not the implementation, it's not simple to understand
04:32:42 <Amadan> cfold' c z (x:xs) = c x z (\y -> cfold' c y xs)
04:33:07 <Amadan> cfold f z l = cfold' (\x t c -> f x (c t)) z l
04:33:20 <xerox> parseFunction :: [Token] -> ((String, [String]) -> [Token] -> a) -> ([Token] -> a) -> a
04:33:20 <xerox> parseIdentifier :: [Token] -> (String -> [Token] -> a) -> ([Token] -> a) -> a
04:33:34 <Amadan> and an example: cfold (+) 0 [1,2,3]
04:33:50 <Amadan> that gets expanded into:
04:34:11 <tromp> consider a simpler parser
04:34:19 <Amadan> cfold' (\x t g -> x + (g t)) 0 [1,2,3]
04:34:45 <tromp> parsing a string gives an object and the remaining string
04:35:05 <tromp> so the parser needs to return 2 results
04:35:12 <tromp> one way is to return the pair
04:35:28 <xerox> yes
04:35:33 <tromp> another is to take a continuation which gets applied to the two things
04:35:33 <xerox> Amadan, mmmh..
04:35:47 <tromp> that can save some pairing and unpairing operations
04:35:51 <xerox> tromp, it makes sense!
04:36:18 <tromp> so parse cont string = cont object remainder
04:37:13 <tromp> i have examples of that in my paper at http://homepages.cwi.nl/~tromp/cl/LC.ps
04:37:28 <Amadan> = (\x t g -> x + (g t)) 1 0 (\y -> cfold' (\x t g -> x + (g t)) 0 [2,3])
04:39:16 <tromp> if you go through the motions, u get that 
04:39:45 <tromp> cfold f' z (x:xs) = f x (cfold' f' z xs)
04:39:59 <Amadan> ... i think i got too complicated. :)
04:40:07 <tromp> where f'=(\x t g -> f x (g t))
04:40:34 <Itkovian> that should be cfold', no?
04:40:46 <tromp> oops, yes
04:42:10 <tromp> so it's a convoluted way of defining foldr
04:43:56 <tromp> also note that t will always be z
04:44:22 <tromp> and g is some (\y -> cfold' f' y xs)
04:44:30 <xerox> mmmmh
04:44:40 <tromp> so (g t) is always some cfold' f' z xs
04:46:14 <tromp> so the definition for cfold is kinda silly
04:46:32 <tromp> they cld leave out the t argument and just write z
04:49:52 <xerox> wait a sec
04:49:57 <xerox> (thanks for help, damn parents)
05:03:23 <xerox> sigh.
05:03:29 <xerox> what did i miss?
05:03:41 <tromp> nada
05:04:37 <xerox> someone closed the door getting the eth cable smashed
05:04:42 <xerox> :(
05:06:28 <Itkovian> heh
05:06:34 <Itkovian> wireless ...
05:08:16 <shapr> oy
05:09:37 <shapr> MegaMonad: what do you think about life?
05:09:43 <MegaMonad> shapr: Kowey: what do you also learn languages for different symbols on that first exp is overloaded for them, they decided they couldn't care less about the i in the example program or even buying enough food for me to make the life of the database, what do you think any data yet.
05:10:46 <tromp> hmm, how to build a mutable array from a function mapping indices to elements?
05:12:09 <tuomov> MegaMonad: Life sucks and then you die?
05:12:16 <MegaMonad> tuomov: You know me, but it doesn't die, but it sucks.
05:12:23 <tuomov> lol
05:12:48 <Itkovian> MegaMonad: you humorous chap!
05:12:54 <MegaMonad> Itkovian: Still seems bizarre to me in a dark, humorous future ruled by the way i get what i have.
05:13:00 <Itkovian> yeah
05:14:36 <shapr> That's almost profound
05:14:58 <tuomov> sanak profound
05:15:06 <tuomov> damn, wrong window
05:18:15 <Lemmih_> Hey shapr. I've been waiting for you.
05:18:16 <Itkovian> heh
05:18:23 <shapr> hiya Lemmih_ 
05:25:28 * shapr throws lambdas
05:25:47 <shapr> MegaMonad: skolemization had you anyway at all? Can you believe the gnosis?
05:25:53 <MegaMonad> shapr: I only get so many universities that claim/try to be at uni between starting and ending up confusing myself instead, why don't you want me to believe the gnosis?
05:26:32 <Amadan> uncanny.
05:26:45 <shapr> MegaMonad: Amadan has a unicycle too. Do you like unicycles?
05:26:51 <MegaMonad> shapr: Basti_: a kind of unicycle do you like unicycles?
05:27:15 <shapr> MegaMonad: Are monads into bondange?
05:27:21 <MegaMonad> shapr: What's the difference between a point where he shoehorned monads into bondange?
05:27:34 <shapr> MegaMonad: You're just trying to change the subject.
05:27:40 <MegaMonad> shapr: Can't say i loved linux and i'm trying to save changes yet. It's not in the subject, but it certainly looks like i'm in an applicative reduction for fractions is clearly ill-typed.
05:27:43 <Amadan> rofl
05:27:51 <Amadan> i don't know which one of you two is funnier
05:28:09 <shapr> MegaMonad: Don't talk to me about ill-typing! You speak typo so fluently I cain't barely stand it!
05:28:15 <MegaMonad> shapr: Are there pictures of you to speak like a typo.
05:28:40 <shapr> MegaMonad: ooh, turning state's evidence are you? Well I'll have you know we're purely functional!
05:28:46 <MegaMonad> shapr: Ok, so there's no obvious way seems more flexible than monads to me they are composed of hunks, and any evidence would be functional.
05:29:14 <shapr> MegaMonad: dysfunctional maybe, I'm a hunk with real context.
05:29:20 <MegaMonad> shapr: The evil hunk is that a result of the context.
05:29:28 <shapr> MegaMonad: talar du svenska?
05:29:34 <MegaMonad> shapr: Well svenska is not even a du.
05:29:51 <shapr> MegaMonad: I'm calling you out. Arrows at dawn, monads at dusk.
05:29:57 <MegaMonad> shapr: Allowing newline as an undergrad.. If you are, you're in my understanding correct that both companies are using monads is a thread has its dawn!
05:30:20 <shapr> MegaMonad: What is this, issue dodgeball?
05:30:26 <MegaMonad> shapr: Hm ok then i played around and i don't know a better question than 'what is this, issue dodgeball?
05:30:41 <shapr> MegaMonad: cheesy, you need to improve your hidden markov model.
05:30:47 <MegaMonad> shapr: I think that would improve if you give something that would be hidden.
05:30:51 <shapr> haha
05:30:57 <shapr> good response
05:31:55 <Amadan> shapr, did you see this one: "Is @type your favourite lambdabot feature?" "Lambdabot has a feature to make lambdabot do that sometimes."
05:32:03 <shapr> :-)
05:32:36 <Amadan> loved it...
05:34:20 <Amadan> MegaMonad, please write a thesis on the suckage of Fortran.
05:34:25 <MegaMonad> Amadan: No thesis on the suckage of fortran.
05:34:38 <Itkovian> MegaMonad: on the suction then
05:34:43 <Amadan> MegaMonad: Traitor!
05:34:44 <MegaMonad> Itkovian: Hmm, i'd say types are on the suction then.
05:34:50 <MegaMonad> Amadan: Tnss is good.
05:35:17 <Itkovian> MegaMonad: How do you feel toward C#?
05:35:23 <MegaMonad> Itkovian: Shapr: is me in c have ever put sufficient effort toward it.
05:37:04 <Itkovian> MegaMonad: you wussie
05:37:10 <MegaMonad> Itkovian: So i need the else clause has happened again... This should be a g predefined in a non-io function in the case of "welcome to i18narchetypes.
05:39:40 <tromp> shapr, have you worked with MArrays?
05:41:06 <shapr> not recently
05:41:49 <tromp> it seems easy to thread one MArray with runST
05:42:17 <tromp> but how to deal with state consisting of multiple arrays?
05:42:44 <shapr> I don't know
05:45:11 <tromp> weird, seems like a standard problem
05:45:30 <shapr> it might be, I just haven't used marrays much.
05:56:19 <boegel> hey #haskell !
05:56:24 <Muad_Dibber> hey boegel :)
05:56:48 <Itkovian> hi boegel
05:57:01 <Lemmih> Yo boegel 
05:57:09 <shapr> hoi
05:57:14 * shapr boings
05:57:27 <shapr> I am the ParaMonad!
05:58:22 <Muad_Dibber> ur mad.
05:58:32 <shapr> is that like uruk-hai?
05:58:59 <Amadan> no, that's like "archetypally angry". :)
05:59:02 <shapr> Muad_Dibber: your name is muad
05:59:08 <shapr> Amadan: ooh, smooth.
05:59:12 <Muad_Dibber> shapr: actually it isnt :P
05:59:25 <shapr> Would it be better if your name were mud?
05:59:43 <Muad_Dibber> at least lot of people would be playing me then :P
05:59:46 <shapr> Amadan: not many english speaker know the word "ur", where did you learn it?
06:00:04 <shapr> mmm, medication makes me happy.
06:00:09 <Amadan> though i speak english, english speaker i'm not. :)
06:00:32 * shapr snickers
06:00:36 <shapr> punny!
06:01:07 <Amadan> yep, if we had middle initials in this country, mine'd be pee.
06:01:15 * shapr laughs
06:01:28 <shapr> You're starting to sound like MegaMonad yourself!
06:01:54 <Amadan> eeek, too much hey-hi!
06:02:18 <shapr> @fortune
06:02:19 <lambdabot> Today's thrilling story has been brought to you by Mushies, the great new
06:02:19 <lambdabot> cereal that gets soggy even without milk or cream.  Join us soon for more
06:02:19 <lambdabot> spectacular adventure starring...  Tippy, the Wonder Dog!
06:02:19 <lambdabot> 		-- Bob & Ray
06:02:34 <Amadan> (sorry, gotta study fortran... does weird stuff to my synapses)
06:04:11 <shapr> I can believe it.
06:07:56 <Itkovian> fortran ... 90?
06:08:06 <Amadan> 77 & 90
06:08:22 <Amadan> i'm supposed to rewrite one into the other
06:08:44 <shapr> ick
06:08:58 <Amadan> now 77 i understand, now i need to see how to write it nicely... or as nicely as i can, given what i have to work with
06:09:00 <Itkovian> yuk
06:09:13 <Itkovian> 77, i can live with ... 90 i hate
06:09:26 <Amadan> why? i'd guess vice versa...
06:09:31 <shapr> My father used to write Fortran
06:09:41 <shapr> So I guess that makes me a 2nd generation programmmer.
06:10:11 <Amadan> originally, the code has two screenfuls of array decls, all obviously named by a RNG
06:10:15 <tuomov> iirc mine has also written some
06:10:46 <Itkovian> what's a RNG?
06:10:46 <Amadan> well, my very non-programming mother wrote a piece once, too. that's actually extremely funny to realise...
06:10:52 <Amadan> Random Name Generator.
06:10:55 <Itkovian> ah
06:11:38 <Amadan> so i think having structures would be a welcome change - passing five rows of arguments into each sub is No Fun (r)
06:16:11 <Itkovian> that's true
06:27:40 <shapr> man, my french skillz have disappeared.
06:27:46 <shapr> @yow !
06:27:47 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket..
06:27:47 <lambdabot>  ..  I have read the INSTRUCTIONS...
06:28:01 <tromp> i wished the crosslink on http://www.haskell.org/ghc/docs worked...
06:28:05 <shapr> ?
06:28:08 <shapr> which crosslink?
06:29:35 <tromp> all the links you see on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html for instance
06:30:25 <tromp> wait; try http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html#t%3AMArray
06:30:53 <tromp> and click on STUArray
06:31:17 <tromp> or IArray on the other page
06:31:28 <tromp> you get Not Found
06:33:45 <tromp> seems everything with a .Base. in the link is broekn
06:37:09 <tromp> where do you go to read docs?
06:38:52 <Lemmih> @info STUArray
06:39:48 <tromp> you never use /www.haskell.org/ghc/docs/latest/html/libraries?
06:41:07 <Lemmih> Oh I do. It's one of my most used bookmarks.
06:41:32 <tromp> do you also run into those broken links?
06:43:02 <Lemmih> No, I haven't encountered them before.
06:44:29 <Lemmih> I think it's pretty much isolated to Data.Array.Base.*
06:45:25 <asmodai> So.
06:45:31 <asmodai> What's a good beginner's page? :)
06:45:37 * asmodai pats shapr 
06:46:33 <tromp> ok, i mailed the maintainer
06:48:18 <shapr> asmodai: http://www.haskell.org/learning.html
06:48:19 <shapr> or 
06:48:22 <shapr> @wiki HaskellDemo
06:48:22 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
06:48:32 <xerox> 'afternoon
06:48:39 <shapr> the HaskellDemo is like "the first one comes free"
06:48:50 <shapr> The learning page has lots of goodies.
06:50:13 <asmodai> shapr: heh
06:50:23 <asmodai> shapr: I need to get a bit on speed with it quickly.
06:50:32 <shapr> In that case, try the HaskellDemo
06:50:33 <asmodai> shapr: Got enough language theory I think
06:50:47 <shapr> And then the Gentle Introduction.
06:50:54 <xerox> asmodai, are you the same undernet's asmodai?
06:50:59 <shapr> and ask lots of questions here.
06:51:25 <xerox> I warning you, it's not *so* gentle.. ;)
06:51:33 <asmodai> xerox: yea
06:51:39 <shapr> Yes, but he said "quickly"
06:51:39 * asmodai is everywhere
06:51:50 <shapr> That's why I suggested the Gentle Intro.
06:51:59 <xerox> It should be renamed.
06:52:06 <shapr> It felt like a brickbat to me, but asmodai also said that he has enough theory.
06:52:11 <shapr> So maybe it will be gentle for him.
06:52:21 <asmodai> shapr: Well, I mean, I do compiler coding, I mess with a bunch of languages.  I think I got my theory covered
06:52:23 <shapr> Plus, I suspect asmodai has some past programming experience.
06:52:31 <shapr> Welll, it depends...
06:52:39 <kosmikus> asmodai: read the report, then
06:52:47 <kosmikus> asmodai: it's quite readable
06:52:53 <shapr> purely functional is something else, it's beautiful and powerful.
06:53:00 <asmodai> shapr: some?
06:53:05 <xerox> Agreeable.
06:53:05 * shapr grins
06:53:09 <tromp> i'm having trouble getting a simple runST to compile
06:53:23 <shapr> Sure, if you've written a compiler or two, I think you have some programming experience.
06:53:25 <asmodai> assembly, c, c++, php, perl, python, sml, ruby to grab a few ones close by :P
06:53:49 <shapr> ah, you've done SML
06:53:55 <shapr> You might survive the Gentle Intro then.
06:54:03 <kosmikus> asmodai: the Report, I mean it ;)
06:54:19 <asmodai> kosmikus: which one is that?
06:54:28 <shapr> asmodai: Haskell is a very small language, but the ideas go a long way.
06:54:36 <xerox> fsbot would be handy ,,Report
06:54:43 <kosmikus> asmodai: http://www.haskell.org/onlinereport/
06:54:45 <shapr> xerox: add @@ to lambdabot!
06:54:57 <asmodai> shapr: *nod*
06:55:00 <kosmikus> asmodai: there's a printable version as well, of course
06:55:00 <xerox> !!
06:55:12 <asmodai> shapr: I need to test algorithms before I implement them in some other language
06:55:24 <kosmikus> asmodai: http://www.haskell.org/definition/
06:55:32 * xerox blahrgs
06:55:35 <shapr> I think that's an excellent use of Haskell, especially if you use QuickCheck.
06:55:53 * xerox : <<There's no sugar in this tea!>>
07:01:51 <asmodai> so, when Helium gets type classes it will be the best implementation? ;)
07:03:41 <TheHunter> asmodai, well it'd sure need many of ghc's extensions to be the best implementation.
07:05:51 <asmodai> :)
07:07:51 <kosmikus> asmodai: Helium also isn't very optimized, and doesn't support many libraries
07:08:15 <asmodai> ah ok
07:08:21 * asmodai waits for ghc to compile
07:08:27 <kosmikus> asmodai: but it might be a good idea to extend and port Helium's typechecker for GHC
07:10:10 <shapr> salut ned_ 
07:10:23 <ned_> hello shapr 
07:11:10 <ned_> and others
07:11:39 <xerox> pfff.
07:12:06 <asmodai> heh
07:19:46 <shapr> hiya CosmicRay 
07:20:09 <CosmicRay> morning shapr
07:20:12 <shapr> wazzup?
07:20:22 <CosmicRay> I am here with a purpose :-)
07:20:39 <CosmicRay> I have a question about pattern matching a data type with two different constructors, both defining records with named fields
07:20:41 <shapr> ooh, what's your purpose?
07:21:06 <CosmicRay> the data type is listed here:
07:21:07 <CosmicRay> http://gopher.quux.org:70/devel/missingh/html/MissingH.Wash.Mail.Message.html
07:21:10 <CosmicRay> (Message)
07:21:28 <CosmicRay> I need to be able to do a "case message of"... blah, and do one thing if it's a Singlepart, and another if it's a Multipart.
07:21:37 <CosmicRay> but I can't figure out how to do that without specifying every component field
07:21:39 <CosmicRay> which is annoying
07:22:28 <TheHunter> case message of m@(SinglePart _) -> ... (containing getHeaders m).
07:22:28 <CosmicRay> shapr: btw, I set up a MegaMonad page on the wiki
07:22:28 <shapr> is it a record?
07:22:30 <shapr> oh
07:22:34 <shapr> yeah, use underscore
07:22:41 <CosmicRay> TheHunter: that's what I tried
07:22:42 <Igloo> Can't you match on Foo {bar = baz}?
07:23:00 <Lunar^> CosmicRay: WASH mail isn't really a cool interface IMHO
07:23:03 <CosmicRay> ibsrc/MissingH/Email/Parser.hs:80:
07:23:03 <CosmicRay>     Constructor `MissingH.Wash.Mail.Message.Singlepart' should have 6 arguments, but has been given 1
07:23:03 <CosmicRay>     When checking the pattern: MissingH.Wash.Mail.Message.Singlepart _
07:23:03 <CosmicRay>     In the definition of `flattenMessage':
07:23:03 <CosmicRay>         flattenMessage (y@(MissingH.Wash.Mail.Message.Singlepart _)) = y
07:23:11 <CosmicRay> Lunar^: I know, but it's all we've got AFAICT
07:23:21 <shapr> for MIME, yes
07:23:21 <Lunar^> CosmicRay: mhhh... have your looked at Postmaster ?
07:23:38 <CosmicRay> Lunar^: No, but would it really have stuff to work with message bodies like this?
07:23:39 <shapr> I don't think Peti's code deals with MIME
07:24:24 <CosmicRay> Igloo: Well, I'd have to do Foo {bar = _, baz = _, blah = _}, etc.  about half a dozen times.  was just looking for a cleaner solution.
07:24:25 <CosmicRay> if one exists.
07:24:30 <Lunar^> http://cvs.sourceforge.net/viewcvs.py/hbase/Source/HBase/Encoding/MIME.hs
07:24:39 <Lunar^> (juste googled on MIEME.hs)
07:24:56 <shapr> oy, that's Ashley Yakeley's code.
07:24:58 * shapr runs away
07:25:05 <Igloo> CosmicRay: Are you sure?
07:25:09 <CosmicRay> Lunar^: that is nothing bot two imports
07:25:23 <CosmicRay> Igloo: what are you saying?
07:25:46 <Lunar^> CosmicRay: I'm not sure th'at's interesting
07:26:05 <Lunar^> Isn't there any code in Darcs ?
07:26:06 <Igloo> What I asid looks like it works to me
07:26:15 <CosmicRay> here's my code
07:26:21 <CosmicRay> flattenMessage x =
07:26:21 <CosmicRay>     case x of
07:26:21 <CosmicRay>        y@(MissingH.Wash.Mail.Message.Singlepart _) -> y
07:26:21 <CosmicRay>        y@(MissingH.Wash.Mail.Message.Multipart _) ->
07:26:21 <CosmicRay>            flattenMessage (MissingH.Wash.Mail.Message.getParts y)
07:26:39 <CosmicRay> and ghc is complaining:
07:26:49 <CosmicRay> libsrc/MissingH/Email/Parser.hs:82:
07:26:50 <CosmicRay>     Constructor `MissingH.Wash.Mail.Message.Singlepart' should have 6 arguments, but has been given 1
07:26:50 <CosmicRay>     When checking the pattern: MissingH.Wash.Mail.Message.Singlepart _
07:26:50 <CosmicRay>     In a case alternative:
07:26:50 <CosmicRay>         (y@(MissingH.Wash.Mail.Message.Singlepart _)) -> y
07:26:59 <Igloo> y@Singlepart {} -> y
07:27:19 <Igloo> Multipart {getParts = ps} -> flattenMessage ps
07:27:32 <Igloo> Oh, parens around Singlepart {}
07:27:40 <CosmicRay> yeah that seems to have gotten it
07:27:47 <CosmicRay> did you say that before igloo, and I just missed it?
07:27:49 <CosmicRay> sorry if so
07:27:51 <CosmicRay> and thanks
07:27:54 <Igloo> Or just y -> y as the last case and remove the first
07:28:25 <Igloo> That's what I meant by < Igloo> Can't you match on Foo {bar = baz}?   but it might not have been clear
07:29:17 <CosmicRay> yeah, I thought you were asking me to list every field
07:29:27 <eixei> ehlo
07:29:44 <shapr> vrfy eixei 
07:29:58 <CosmicRay> Lunar^: anyway, the Wash interface to parsing a message is only halfway there, but once you have a parsed message, the Message data structure is actually quite nice, if under-documented.
07:30:07 <CosmicRay> Lunar^: I have both Wash and the HSemail code in my tree
07:30:16 <CosmicRay> Lunar^: HSemail provides, roughly, the other half of the parsing puzzle
07:30:29 <CosmicRay> Lunar^: I am now just writing some code that will take a String and return a Message
07:30:39 <Janni> Hi.
07:30:54 <Lunar^> CosmicRay: you rox ! :)
07:31:26 <eixei> shapr: yay! you are the first one to have ever gotten it :-)
07:31:39 <shapr> surprising
07:31:40 * Lunar^ now looks like a 12 years old script kiddie...
07:31:44 <CosmicRay> hehe
07:31:52 * shapr is a 33 years old skript kitty! miao!
07:32:00 * asmodai pats shapr 
07:32:01 <Lunar^> lol
07:32:10 <CosmicRay> heh
07:32:30 <CosmicRay> eixei: 550 irc connection rejected :-)
07:32:34 <shapr> mais la chat fran√ßaise, elle est mieux ;-)
07:32:39 <asmodai> shapr: I'm close to 27 now
07:33:03 * shapr likes the pun between mieux and mieu/miao
07:33:16 <asmodai> vieuz?
07:33:18 <asmodai> errr
07:33:19 <asmodai> vieux
07:33:19 <eixei> damn... no IRC for me then :-(
07:33:52 <CosmicRay> eixei: aww, cmon, try a backup server :-)
07:33:59 <shapr> maybe "elle a mieux" would be better.
07:34:30 <shapr> jag √§r inte s√§kert
07:34:33 <eixei> Francais? Mon dieux...
07:34:45 <shapr> parlez vous fran√ßais aussi?
07:35:00 <eixei> CosmicRay: hmm... yay! connected
07:35:00 <shapr> Je ne parle pas beaucoup de francais, mais j'aime les fran√ßaise ;-)
07:35:16 <CosmicRay> eixei: just you wait until we get an RCPT TO :-)
07:35:49 <shapr> J'ecris en courier(?) au un monocyclist :-)
07:35:49 <eixei> no, I learned french for two years, but I'm just too bad at it.. I like how it sounds though
07:36:04 <eixei> CosmicRay: that should take a couple of hours :-)
07:36:19 <CosmicRay> hehe
07:36:26 <shapr> Il s'appelent 'Yoggi Toulouse'
07:36:30 <eixei> And I prefer learning norwegian, or at least trying to *g*
07:36:33 <shapr> And he reminds me a lot of Lunar^ actually :-)
07:36:47 <Lunar^> hÈhÈ :)
07:37:22 <shapr> Yoggi seems to have the same intensity and drive as Lunar^.
07:38:03 * CosmicRay is pleased to get his first bit of code into fptools :-)
07:39:11 <shapr> CosmicRay: congrats!
07:39:31 <CosmicRay> (regular expression substitution and splitting)
07:39:45 <shapr> Have you seen pesco's recent code for easy use of regexes?
07:39:53 <CosmicRay> no!  please url me
07:40:01 <CosmicRay> I have been thinking about that for the past week
07:40:09 <shapr> http://www.scannedinavian.org/~pesco/code/Regex/Pesco/Regex.lhs
07:40:30 * asmodai watches ghc compile like a snail
07:40:47 <shapr> langsamt
07:40:52 <CosmicRay> asmodai: what, you have an AIX machine too? :-)
07:41:02 <CosmicRay> bwahahah
07:41:03 <CosmicRay> this is great
07:41:22 <shapr> Pesco's code?
07:41:24 <CosmicRay> yes
07:41:34 <shapr> Have you seen HaRP as well?
07:41:46 <asmodai> CosmicRay: ;P
07:41:54 <CosmicRay> I'll just have to manually unlit it though, so haddock can make decent stuff out of it
07:41:56 <shapr> There's also Manuel Chakravarty's lazy fast regex matching, and Igloo's recent regexy code.
07:42:06 * CosmicRay takes some notes
07:42:22 <shapr> the lazy fast regex matching is nifty because the regex isn't even compiled until the first time it's called.
07:42:37 <asmodai> shapr is, obviously, lazy too.
07:42:40 <CosmicRay> otoh, it may be compiled more than once, yes?
07:42:44 <shapr> I don't think so
07:42:45 <asmodai> as is my compilation
07:42:46 <CosmicRay> MegaMonad: is shapr lazy?
07:43:12 <eixei> lol
07:43:18 <MegaMonad> CosmicRay: Two main reasons why there are national chains, but the accumulator is lazy not that lazy.
07:43:30 <CosmicRay> MegaMonad: ehlo.
07:43:32 <shapr> I scanned the paper a few weeks back, and I'm pretty sure it memoizes by building a table entry when it's first called.
07:43:36 <MegaMonad> CosmicRay: For example, helo <+> ehlo.
07:43:45 <shapr> whoa, MegaMonad does arrows
07:43:52 <shapr> or is that Parsec?
07:43:57 <CosmicRay> it's not quite parsec
07:44:00 <shapr> @index <+>
07:44:00 <lambdabot> Control.Arrow,Text.PrettyPrint,Text.PrettyPrint.HughesPJ
07:44:04 <shapr> ah, it is arrows
07:44:05 <CosmicRay> unless it's something I don't recognize
07:44:09 <CosmicRay> parsec would be <|>
07:44:44 <tuomov> MegaMonad: how long is a parsec?
07:44:50 <MegaMonad> tuomov: "Binding: a key sequence in the middle of a parsec parser in parsec.
07:44:51 <shapr> Sometimes I wish operator names could span lines - http://www.scannedinavian.org/~shae/src/haskell/Rocket.hs
07:44:58 * CosmicRay goes off topioc for a moment: LVM2 in Linux 2.6 is awesome.  I've got a failing disk and I'm moving an entire filesystem from it to another disk with free space, without even having to unmount it.
07:45:12 <CosmicRay> haha
07:45:20 * shapr grins
07:45:39 <shapr> MegaMonad is surprisingly realistic.
07:46:11 <CosmicRay> MegaMonad: what percentage of haskell users unicycle?
07:46:17 <MegaMonad> CosmicRay: And one process so that they're in unicode, though not very familiar with haskell from the users of the unicycle ?
07:46:21 <Igloo> shapr: Are you sure you don't mean the regex is compiled piece by piece as it's used?
07:46:38 <CosmicRay> MegaMonad: do you unicycle?
07:46:44 <MegaMonad> CosmicRay: Lemmih: radix in #twisted seems to help me make sure i'm not talking about stuff like this algorithm because i tried the unicycle seems to me there are any gotchas with suspend-to-disk in 2.4?
07:46:47 <Igloo> Haskell's laziness ought to give you what you said, no?
07:47:21 <CosmicRay> Igloo: I haven't looked at the underlying code, but the Text.Regex stuff looks like a wrapper around the Posix C regexp library
07:47:23 <tuomov> MegaMonad: wikipedia says a little over 3 light-years
07:47:28 <CosmicRay> Igloo: if so, it would have to compile the entire string at once
07:47:33 <MegaMonad> tuomov: No, but it says in the a in both src/lib and what you do it in years.
07:47:40 <CosmicRay> heh
07:47:48 <shapr> The way I remember it, Chilli's fast lazy lexers are *really* lazy.
07:48:04 <shapr> I forget the exact differences.
07:48:06 <tuomov> MegaMonad: are we talking about the same thing here?
07:48:16 <MegaMonad> tuomov: He's talking about the problem is now.
07:48:18 <CosmicRay> it would be really cool if we got a pcre-like regexp support in haskell
07:48:21 <shapr> The paper is pretty short.
07:48:27 <CosmicRay> perl regexps are a lot nicer than posix ones
07:48:43 <shapr> Have you seen HaRP? It's pattern-match regexes.
07:49:13 <shapr> foo (User Cos.*?Ray) = "Greetings Agent Goerzen"
07:49:15 <shapr> or something like that.
07:49:28 <CosmicRay> heh
07:49:33 <CosmicRay> that sounds slick
07:49:38 * Igloo has plans to add it to my regexp library, but I'm not sure when I'll get around to it
07:50:08 <CosmicRay> well, it's good to know others have looked at (and possibly solved) the problem.
07:50:16 <CosmicRay> that means I can solve it for myself with cp rather than emacs :-)
07:50:37 <Igloo> (it == PCREs)
07:51:07 <CosmicRay> Igloo: ah.
07:51:14 <CosmicRay> Igloo: have you implemented regexps from scratch then?
07:51:35 <Igloo> yup
07:52:02 <CosmicRay> Igloo: what sort of benefits does your implementation provide over the Text.Regex.* interface?
07:52:28 <Igloo> Works in nhc98, lazily consumes the input
07:52:33 <CosmicRay> ah
07:52:52 <CosmicRay> regexps themselves are similar to the posix re's supported by the standard library?
07:53:19 <Igloo> I think it supports BREs and EREs currently
07:56:12 * shapr wants a nice GRE
08:03:04 <shapr> hoi kuribas 
08:08:25 <bringert> shapr: Graduate Record Examination?
08:09:24 <kuribas> hello shapr
08:11:42 * bringert tried to msg MegaMonad, but accidently msg:ed megahal
08:12:07 <CosmicRay> heh
08:12:29 <bringert> who's apparantely not exactly trained to be nice to people
08:12:39 <eixei> lol
08:12:49 <CosmicRay> is that a real user?
08:12:55 <CosmicRay> or another bot?
08:13:00 <bringert> a bot I think
08:13:08 <bringert> it replies instantly
08:13:11 <bringert> with abuse
08:13:23 <CosmicRay> heh
08:13:27 <bringert> go ahead and try
08:13:38 <asmodai> By Jove
08:13:47 <asmodai> ghc takes longer than a make buildworld
08:13:48 <asmodai> :P
08:14:26 <shapr> kuribas: how's code?
08:15:07 <kuribas> shapr: actually I am new to haskell (learning it now)
08:15:17 <shapr> Cool, do you have any questions?
08:16:08 <kuribas> well, how is the performance of haskell?
08:17:46 <CosmicRay> well that is a loaded question
08:17:54 <CosmicRay> you can get some data at shootout.alioth.debian.org
08:18:12 <CosmicRay> although those are not necessarily good real-word measurements, and certainly not good real-world code
08:18:20 <CosmicRay> a lot of code there is heavily-optimized and thus ugly.
08:18:30 <kuribas> yeah
08:18:32 <CosmicRay> My general experience is that it's faster than Python but slower than C or OCaml
08:19:12 <CosmicRay> and certainly faster than java
08:19:21 <CosmicRay> kuribas: do you have experience in any other languages already?
08:19:26 <kuribas> yes
08:19:36 <tromp> slower than java in my experience
08:19:38 <CosmicRay> which ones?
08:19:45 <tromp> java is about 30% behind c
08:19:52 <kuribas> C/C++, ruby, scheme, assembler
08:19:52 <CosmicRay> tromp: where?
08:20:05 <tromp> where what?
08:20:08 <CosmicRay> kuribas: ok, cool, so functional programming isn't new to you then
08:20:14 <CosmicRay> tromp: on what platform is java that fast?
08:20:23 <kuribas> No, I like prefer it to C
08:20:25 <CosmicRay> I've never seen it get anywhere near that number
08:20:35 <tromp> most platforms
08:20:49 <CosmicRay> I've run it on linux/x86, linux/amd64, and aix/ppc64
08:21:04 <tromp> if you try some benchmark like Fhourstones
08:21:05 <bringert> CosmicRay: what sort of applications?
08:21:13 <CosmicRay> most of the time, it's half as fast as C, and uses vast amounts of RAM
08:21:19 <CosmicRay> bringert: mostly web and database
08:21:41 <bringert> and you compare to haskell for the same applications?
08:21:51 <CosmicRay> bringert: I'm talking about comparisons to C here
08:22:03 <tromp> i'm still busy porting my benchmark to haskell
08:22:40 <CosmicRay> bringert: I haven't done a head-to-head java vs. haskell, but I have java vs. python and python vs. haskell with the results I mentioned
08:22:55 <CosmicRay> so it's an inference, but I think it's reasonably accurate
08:23:20 <bringert> guess I missed something, what did you say on Java vs Haskell?
08:23:20 <CosmicRay> kuribas: you may find this useful: http://www.isi.edu/~hdaume/htut/
08:23:29 <CosmicRay> bringert: that haskell is faster
08:23:31 <tromp> i've read quite a few studies where java was between 5% faster and 50% slower than c
08:23:32 <shapr> I would say that Haskell beats everything else in "programmer speed" 
08:23:42 <CosmicRay> shapr: that is a good point
08:23:50 <bringert> yeah, and most of the time that's what matters
08:23:52 <tromp> but the days of being twice as slow are over
08:23:52 <kuribas> CosmicRay, thanks.  I was reading the "gentle introduction"
08:24:06 <CosmicRay> kuribas: a lot of people don't find it so gentle :-(
08:24:12 <tromp> whereas haskell is sometimes still >10 times slower
08:24:27 <kuribas> I found it well enough, except the part about monads
08:24:33 <bringert> I think the main problem with haskell is that memory use can be hard to predict
08:24:46 <bringert> don't get me wrong, I find it the best language for most things
08:24:52 <tromp> haskell excels in clarity of expression
08:25:05 <tromp> it's by far the most eloquent language
08:25:06 <CosmicRay> bringert: you say that as I've had to raise the vm size limits on our tomcat process to 768MB :-)
08:25:16 <shapr> But, I can write the same program in three days in Haskell that takes weeks in Java, and I still have time to take a vacation before I need to run the Haskell executable to finish processing before the Java executable.
08:25:38 <bringert> sure, Java uses lots of memory, but I find it easier to predict memory use in java
08:25:49 <kuribas> I like ruby for general programs, but I think a functional language like Haskell of ocaml is better for complex problems
08:25:49 <tromp> haskell code written by other ppl is also 10x easier to understand
08:25:53 <bringert> i.e. always lots of it :)
08:25:57 * shapr laughs
08:26:10 * shapr quotes that
08:26:28 * kuribas hasn't found many people who like Java
08:26:48 <shapr> There are a lot of people who like Java, but most of them know only Java, not any other programming language.
08:26:52 <bringert> seriously though, it's mostly easy to avoid memory leaks in Java, more difficult in Haskell, at least for me
08:27:05 <CosmicRay> kuribas: even our resident AI dislikes Java
08:27:09 <CosmicRay> @wiki MegaMonad
08:27:10 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
08:27:18 <shapr> I agree, memory leaks are the most difficult part of Haskell.
08:27:26 * bringert likes Java (well, not compared to Haskell), but compared to some of the alternatives
08:27:44 <CosmicRay> shapr: in that respect, ocaml's non-lazy nature make it easier to understand
08:27:45 <shapr> But I do hope that increased arrows usage will fix some of the space leak problems.
08:28:02 <kuribas> Doesn't Haskell have automatic memory management?
08:28:06 <shapr> oh it does
08:28:10 <CosmicRay> kuribas: it does, yes
08:28:13 <shapr> gorgeous memory management too
08:28:21 <bringert> but you can still have memory leaks
08:28:24 <shapr> but lazy evaluation can do things you'd never expect.
08:28:29 <CosmicRay> is there any temporary file handling support other than System.Posix.Temp.mkstemp?
08:28:58 <CosmicRay> such as tmpnam()?
08:29:02 <shapr> A drop-in arrow-based replacement for Parsec would probably help a lot of people.
08:29:22 <kuribas> woudn't it be possible to create a compiler that outperforms C?
08:29:34 <shapr> kuribas: sure, for far less money than it took to create fast C compilers.
08:29:35 <Igloo> Hmm, does mkstemp really use mkstemp?
08:29:47 <Igloo> "Don't use this function, use tmpfile(3) instead. It's better defined and more portable."
08:30:03 <shapr> But significantly less than a billion dollars has been put into improving Haskell compilers.
08:30:08 <Igloo> tmpnam says "Never use this function. Use tmpfile(3) instead."
08:30:24 <CosmicRay> tmpnam is fine if you know how to use it.
08:30:30 <CosmicRay> the problem is that a lot of people don't.
08:30:34 * Igloo giggles at the description
08:30:43 <CosmicRay> I usually take its result and mkdir it, then scratch around in there.
08:31:25 <shapr> I think it's time to unicycle!
08:31:31 <tuomov> I think it would be best to standardise on something like /tmp/user-progname-pid-*
08:31:43 <CosmicRay> MegaMonad: unicycle!
08:31:49 <MegaMonad> CosmicRay: I don't keep the whole diffarray to a unicycle with a different role as type checking?
08:31:58 <CosmicRay> MegaMonad: unicycle now!
08:32:04 <Igloo> Hmm, OK, that sounds like it ought to be safe
08:32:04 <MegaMonad> CosmicRay: As an example on your unicycle? By the time and again.
08:32:10 <shapr> crazy bot!
08:32:23 <shapr> MegaMonad: shapr is the unicycle.
08:32:24 <CosmicRay> Igloo: the mkdir() usage, you mean?
08:32:29 <MegaMonad> shapr: When will scannedinavian be back when you've got the unicycle on the unicycle.
08:32:36 <Igloo> But it would be better to have tmpdir that did it for you
08:32:41 * shapr snickers
08:32:43 <CosmicRay> Igloo: indeed
08:32:52 <CosmicRay> Igloo: I am writing one for MissingH now.  Silly mkstemp.
08:33:20 <eixei> MegaMonad: What do you think of java?
08:33:25 <MegaMonad> eixei: Ergo: if the other half is obsessed with the combination of --make and -main-is and --make bar can run hugs. It gets me is that i in the control.exception and see if you think something just might be able to do java.
08:33:38 <CosmicRay> eixei: there are some great quotes on that subject at @wiki MegaMonad
08:33:39 <Igloo> Yeah, assuming mkdir of a directory or symlink fails as part of the syscall
08:33:48 <CosmicRay> eixei: "To me java is a monomorphic type" is one of them :-)
08:33:54 <eixei> lol
08:34:06 <eixei> I guess I'll just have to check them out :-)
08:34:13 <CosmicRay> @wiki MegaMonad
08:34:13 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
08:34:20 <eixei> thanks
08:34:28 <shapr> I would like @@wiki 'inline' lambdabot commands.
08:34:30 <CosmicRay> MegaMonad seems to have associated both java and jakarta with "evil", and java with "weenie"
08:34:39 <shapr> dunno how you'd get that to work with arguments though.
08:35:01 <shapr> kuribas: Anymore questions I can answer before I go off unicycling?
08:35:16 <kuribas> No, thanks!
08:35:38 <shapr> ok, if you think of more questions, feel free to ask 'em :-)
08:35:52 <kuribas> Ok :)
08:35:59 * shapr wobbles off into the distance
08:41:17 <kosmikus> are there some dynamic-loading related bugs in GHC that have been fixed between 6.2.2 and CVS HEAD?
08:41:50 * eixei feels like he is surrounded be emacslers
08:53:43 <kosmikus> re dynloading -- never mind, my mistake
09:05:11 <Muad_Dibber> whoops
09:06:41 <Muad_Dibber> ah well
09:06:44 <Muad_Dibber> good afternoon all :)
09:12:27 <eixei> good evening Muad_Dibber 
09:13:32 <eixei> nice nick :-)
09:13:44 <Muad_Dibber> hehe
09:21:46 <Lunar^> dons: Have you seen the undo library on the MLs ?
10:37:59 <shapr> man I love unicycling
10:39:16 * shapr hops cheerfully
10:39:31 <jadrian> hello
10:39:39 <shapr> hiya jadrian 
10:39:47 <jadrian> hi there shapr 
10:42:07 <shapr> sazzle: hiya! long time no see!
10:42:24 * shapr throws lambdas
10:57:49 <asmodai> :P
11:12:06 * asmodai abuses shapr in a chaos theory
11:13:50 <CosmicRay> shapr: unicycling always looks so, well, frustrating to learn...  is it?
11:14:15 <cptchaos> seems more like chaos is abusing me in my room.
11:14:23 * asmodai blinks
11:14:33 * CosmicRay stares
11:14:34 <asmodai> never suspected chaos to actually enter
11:14:43 * asmodai goes to chase a butterfly
11:14:53 * CosmicRay goes to chase a monad
11:16:28 <CosmicRay> hello oejet
11:18:03 <CosmicRay>   PID USER      PR  NI  VIRT  RES  SHR S PU %MEM    TIME+  COMMAND
11:18:03 <CosmicRay> 10038 jgoerzen  25   0  270m 264m 9856 R 88.2 26.3   0:08.02 cc1
11:18:12 <CosmicRay> lovely how much memory ghc takes sometimes :-)
11:18:20 <CosmicRay> 10028 jgoerzen  25   0  124m 102m  37m R 64.8 10.2   0:28.08 ghc-6.2.2
11:19:25 <CosmicRay> hello ows
11:19:30 <CosmicRay> MegaMonad: what is chaos?
11:19:38 <MegaMonad> CosmicRay: Use the six pointed star of chaos.
11:19:43 <CosmicRay> hm.
11:19:50 <CosmicRay> MegaMonad: what is chaos?
11:19:56 <MegaMonad> CosmicRay: The crawling chaos.
11:20:15 <CosmicRay> MegaMonad: what is order?
11:20:22 <MegaMonad> CosmicRay: I think ruby is higher order?
11:20:25 <Igloo> Hey, GHC's using less than half what your C compiler is  :-)
11:20:29 <CosmicRay> heh
11:20:40 <CosmicRay> that's only because ghc is asking it to compile a 120,000 line source file :-)
11:21:31 <CosmicRay> that's right, the latest feature of the MissingH library: testing your swapping setup.
11:21:54 <CosmicRay> (actually its RFC2822 from Hsemail that's doing this)
11:27:04 * shapr grins
11:28:50 <CosmicRay> MegaMonad: what is disorder?
11:28:56 <MegaMonad> CosmicRay: Attention-deficit hyperactivity disorder (adhd), previously known as hemacs?
11:29:37 <CosmicRay> bwahahaha
11:30:48 * shapr laughs!
11:31:47 * asmodai tickles shapr 
11:32:26 * shapr fires a heat-seq'ing missile at asmodai 
11:32:30 <shapr> avast!
11:32:31 <shapr> @arr
11:32:31 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
11:32:35 <shapr> @arr
11:32:36 <lambdabot> Arrr!
11:32:39 <shapr> shazbot!
11:32:47 <asmodai> HARRR!
11:33:11 <asmodai> Shiver me polynominals
11:33:13 <CosmicRay> asmodai: you are on way too many channels :-)
11:33:18 <asmodai> Not at all.
11:33:24 * asmodai is only on 26 channels!
11:33:31 <CosmicRay> oh, sorry, my mistake.  you're missing #ocaml and #debian :-)
11:33:34 <asmodai> Ewww
11:33:36 <asmodai> Debian
11:33:46 * asmodai makes the 'ward evil eye' sign
11:33:47 * CosmicRay readies the lart finger
11:33:50 <asmodai> <-- BSDer
11:33:51 <asmodai> :P
11:34:08 <CosmicRay> asmodai: http://www.debian.org/ports/netbsd/
11:34:12 <asmodai> The audacity to even assume I am a Linux user. :P
11:34:46 <CosmicRay> the audacity to assume that Debian restricts itself to Linux :-)
11:35:06 <CosmicRay> http://www.debian.org/ports/kfreebsd-gnu/
11:35:11 <CosmicRay> http://www.debian.org/ports/hurd/
11:35:12 <asmodai> Yeah, eww, eww
11:35:15 <CosmicRay> heh
11:35:30 <asmodai> Bad time to mention I don't ascribe to the GPL mindset? :)
11:35:38 <CosmicRay> very :-)
11:35:42 <asmodai> good!
11:35:46 <CosmicRay> hehe
11:35:51 <asmodai> I don't ascribe to the GPL mindset :)
11:35:53 <CosmicRay> MegaMonad: insult asmodai
11:35:57 <Philippa_> I'll go further: the GPL is evil
11:36:08 <MegaMonad> CosmicRay: Asmodai: i don't know of are themselves catamorphisms.
11:36:08 <asmodai> (not to say I haven't sent in patches for GPL projects though)
11:36:10 <SamB> asmodai: are you more of a MIT-X11/BSD kind of guy?
11:36:11 <shapr> I think the GPL is a viral vaccine.
11:36:18 <asmodai> SamB: Yups.
11:36:23 * asmodai shrugs
11:36:25 <asmodai> to each his own
11:36:30 <SamB> yeah, me too
11:36:32 * CosmicRay is not really offended by this, btw
11:36:42 <Philippa_> shapr: it's fine so long as it doesn't start tying things down to the point that certain kinds of thing just can't happen
11:36:43 <asmodai> CosmicRay: If you were you'd have a screw loose.
11:36:44 <CosmicRay> I can be an idealist and a pragmatist all at once
11:36:48 <asmodai> CosmicRay: Bingo
11:36:52 <SamB> the GPL is just too inconvenient
11:36:56 <asmodai> CosmicRay: in the end, it remains open source
11:37:08 <CosmicRay> I license my code under the GPL but I have no problem incorporating BSD code into it :-)
11:37:11 <asmodai> it's like reading that evolution of Haskell page
11:37:17 <asmodai> many ways to get to the point
11:37:21 <CosmicRay> and I'll relicense it under BSD for the right cause
11:37:30 <CosmicRay> (ie, helping Cabal or fptools)
11:37:31 <SamB> CosmicRay: yeah, thats what I like about BSD
11:37:45 <Philippa_> asmodai: until you decide you want the option to have closed /content/
11:37:46 <SamB> you can incorporate it into practically anything
11:37:48 <musasabi> The new Sun license looked promising.
11:37:50 <asmodai> CosmicRay: *applause*  Not to many consider that part of donating back under a free-er or less free license.
11:38:00 <asmodai> Philippa_: closed content?
11:38:12 <Philippa_> asmodai: consider computer games
11:38:30 <musasabi> CosmicRay: except that that is quite hard.
11:38:38 <Philippa_> the content is by far the bulk of the production, and very little of it's fun to produce until you see the end result up and running
11:38:41 <CosmicRay> musasabi: what is?
11:38:49 <SamB> so, if I write software, I should license it BSD so that, even if people give me patches, I can still do whatever I want with it.
11:38:55 <CosmicRay> asmodai: and the funny thing is that which one is more free depends on your perspective
11:38:58 * Igloo slaps CosmicRay with the ie/eg stick
11:38:59 <asmodai> Philippa_: true
11:39:00 <musasabi> CosmicRay: you have 5 contributors and wish to contribute to cabal, but cannot as their patches are under GPL..
11:39:04 <asmodai> Philippa_: actually
11:39:29 <Philippa_> asmodai: often some of the content needs to be expressed in a turing complete manner, shall we say. At that point, the GPL is your worst nightmare
11:39:31 <CosmicRay> Igloo: ok, you caught me
11:39:36 <SamB> which might include making non-free varients, but only because someone else was being stubborn...
11:39:50 * asmodai is working on a 3d Primer paper with mathematics
11:39:59 <asmodai> hopefully work on toolchain stuff on Unix
11:40:07 <Philippa_> the GPL works great in a post-scarcity world. We're post-scarcity for random hackers playing about on small bits at a time
11:40:43 <CosmicRay> musasabi: why would somebody license a patch under a license incompatible with the upstream?
11:40:45 <SamB> and by non-free, I mean the source would be there, but some things wouldn't be allowed in the license of some of the foreign code
11:40:56 <SamB> something like graphviz
11:40:57 <asmodai> musasabi!
11:40:58 <CosmicRay> musasabi: of course, that assumes that a patch is copyrightable, which varies based on its complexity
11:41:10 <Philippa_> not to mention local law
11:41:32 <CosmicRay> musasabi: but if it's copyrightable, to be truly anal, one would want an explicit grant of license or copyright with every patch
11:41:40 <SamB> Philippa_: what is this "local law"?
11:41:52 <SamB> local *where*?
11:42:02 <SamB> there is no local on the internet
11:42:12 <emu> local area network
11:42:43 <musasabi> CosmicRay: well that becomes a problem if the upstream (=you) distribute stuff and it is licenced under GPL so it becomes impossible to donate the code to a BSD project.
11:42:45 <Philippa_> SamB: nor is there any law on the internet
11:43:08 <SamB> Philippa_: it sure does get to seem that way, doesn't it.
11:43:11 <Philippa_> licenses and copyright are a matter of the laws of the countries we inhabit
11:43:23 <musasabi> CosmicRay: yes something like an explicit grant would be required and what can be granted varies by local law...
11:43:31 <Philippa_> SamB: I repeat: there is no law on the internet. There is just local law about how you're allowed to use it
11:43:35 <CosmicRay> musasabi: let me see if I understand... in your scenario, I own the copyright to a program that is GPL'd and has received patches from third parties.... which means I can no longer relicense under BSD.
11:43:47 <musasabi> CosmicRay: yes.
11:43:49 <SamB> speaking of which, someone should do something about all this advertising on expired domains
11:44:07 <musasabi> CosmicRay: this is one of my reasons not to license under GPL.
11:44:11 <CosmicRay> musasabi: one solution to that is to require all patches to be either uncopyrightable or distinctly identifiable so that their licenses can be separately maintained
11:44:19 <Philippa_> which is why many projects have a "you submit the patch, you give the copyright to us" policy
11:44:20 <CosmicRay> musasabi: which is what I do in MissingH
11:44:28 <SamB> CosmicRay: which is rather impractical
11:44:42 <CosmicRay> musasabi: not really
11:44:46 <SamB> since you'd be on thin ice
11:44:50 <Philippa_> distinctly identifiable's practical enough
11:45:01 <musasabi> CosmicRay: that is not very scalable and what is copyrightable varies with local legistation.
11:45:03 <CosmicRay> musasabi: I can look at any line of code in MissingH and tell you who owns it
11:45:04 <Philippa_> the "uncopyrightable" bit /is/ thin ice
11:45:10 <asmodai> whoah
11:45:12 <asmodai> get a channel going
11:45:22 <Philippa_> #internationalcopyrightminefield?
11:45:42 <CosmicRay> musasabi: I don't tihkn any more extreme laws than the US have are applicable, are they?
11:45:44 <CosmicRay> are there even any?
11:45:45 <musasabi> CosmicRay: so after three years you have three different people owning parts of a function?
11:45:56 <Philippa_> CosmicRay: they may well be
11:46:09 <CosmicRay> no, you reject copyrightable patches to a part of a function
11:46:14 <musasabi> CosmicRay: at least here there are restrictions on what parts of copyright can be granted to a third party.
11:46:19 <Philippa_> don't forget it's not just you who may have a problem, it's users too
11:46:20 <CosmicRay> musasabi: or better yet you keep your functions small enough that only one person owns them
11:46:48 <SamB> CosmicRay: that still sounds way more complicated than starting under BSD
11:46:51 <musasabi> CosmicRay: think about an user submitting e.g. documentation for 30% of the functions.
11:47:04 <SamB> which is pretty much foolproof
11:47:05 <musasabi> CosmicRay: and that creates lots of overhead.
11:47:48 <CosmicRay> that's true, but it's not any better any other way
11:48:05 <CosmicRay> even if your license is BSD, you have no right to distribute it unless you either own the copyright or have received a grant of license and comply with it
11:48:20 <asmodai> CosmicRay: depends on the country you live in
11:48:24 <asmodai> Take Germany
11:48:34 <asmodai> you cannot dump software in the public domain
11:48:36 <CosmicRay> <- US
11:48:41 <asmodai> it *needs* a license
11:48:46 <asmodai> however free or restricted
11:48:57 <SamB> asmodai: what about the "public domain license"
11:49:08 <asmodai> SamB: Stating that it is in the public domain?
11:49:15 <CosmicRay> technically one can make something public domain in the US, but then there's the matter of proof
11:49:24 <CosmicRay> so you usually get something approaching a license anyway
11:49:39 <Philippa_> and next we end up with the whole "implicit license" mess
11:52:35 <CosmicRay> ARGH, I HATE YOU HADDOCK, SPAWN OF /DEVNULL!
11:52:54 <CosmicRay> I just wasted about 2 hours implementing an e-mail parser because Haddock didn't show me that I already had one
11:53:09 <CosmicRay> apparently if you provide no signature for a function, it doesn't show up in the docs at all, even if it is exported.
11:53:47 <Igloo> Just goes to show, if you don't give functions signatures the devil will haunt you
11:54:04 <Igloo> (yeah, I know it isn't your code  :-)  )
11:55:22 <Darius> CosmicRay:  Well, now you can run both simultaneously and have two votes about what the correct parse is.  Now, quick!, write a third to break ties.
11:55:39 <CosmicRay> heh
11:55:55 <CosmicRay> Igloo: were you the one complaining that my docs were too long? :-)
11:56:02 <Igloo> I don't think so
11:56:09 <CosmicRay> someone was over the weekend.
11:56:10 <CosmicRay> sigh.
11:57:00 <musasabi> CosmicRay: sometimes omitting a function signature can cause bad things to happen...
11:57:15 <CosmicRay> musasabi: I know
11:57:23 <CosmicRay> musasabi: but that's no reason for haddock to pretend it doesn't exist
11:57:55 <musasabi> CosmicRay: well haddock has no real way of knowing it's type. I think it should warn about that..
11:58:23 <CosmicRay> musasabi: it could at least emit something and say the type is unknown
11:58:39 <CosmicRay> musasabi: the problem about warning is that it emits so many bogus warnings as it is
11:58:51 <CosmicRay> every module, it complains that it could find no definition for String, or Handle, or whatever
11:59:21 <Igloo> Can't you tell it to look in baes for stuff it can't find?
11:59:49 <Igloo> Hmm, can't see a suitable option
11:59:52 <CosmicRay> Igloo: that's not so easy if you aren't building in the ghc tree
12:00:01 <CosmicRay> Igloo: you'd have to give it a url to go to, I suppose
12:00:09 <Igloo> OTOH --no-implicit-prelude implies it ought to DTRT by default
12:00:25 <Igloo> Oh, for creating links to them? I see
12:00:45 <CosmicRay> Igloo: I think that's why it's lokoing for it
12:00:54 <Igloo> Right, so you should be able to tell it to only make links for things in this package
12:01:07 <CosmicRay> yes, that would be nice.
12:01:15 <CosmicRay> except it works on an individual module basis.
12:01:22 <CosmicRay> so it's a little tricky to do that too
12:02:03 <Igloo> If it has a --no-implicit-prelude then it presumably understands such things, though
12:02:25 <Igloo> Hmm, I've never looked at its internals. Perhaps e-mail SM and see what he says?
12:02:36 <CosmicRay> I should one of these days
12:20:27 <Oejet> Hello, CosmicRay.  I will go eat now.
12:20:53 * Darius doesn't understand why his program runs differently under gdb.
12:24:12 * Darius may be able to solve all his woes.
12:25:18 <asmodai> cool
12:25:28 <asmodai> might I add some woes to those?
12:27:41 <Darius> meh
12:30:07 <asmodai> :(
13:30:51 <u> hi ppl
13:31:33 <krycek> i've prob does it exist any function that gets an Int from IO() ?
13:33:31 <Riastradh> What extreme patience!
13:40:19 <LittleDa1> krycek: you mean like unsafePerformIO $ do x <- somehowReadFromConsole; return $ (read x)::Int
13:40:30 <LittleDa1> except you shouldn't do  that
13:40:37 <LittleDa1> are you ok with having an IO Int?
13:40:53 <Oejet> LittleDa1: (22:32:02) krycek left the room.
13:40:58 <LittleDa1> oops
13:42:09 <Philippa_> and somebody who asks such a malformed question probably shouldn't be shown extensions like unsafePerformIO
13:42:52 <LittleDa1> yeah, my bad
13:49:48 <musasabi> yes..
13:50:07 <musasabi> because then he will come back to haunt with horrible code..
13:50:42 <Oejet> He, he.  Don't show him.  Not for his sake, but for ours.
13:51:09 <LittleDa1> what's unparsable about the code infixr 5 &>; &> = HCons
13:51:11 <LittleDa1> ?
13:51:31 <LittleDa1> how should that be written?
13:51:32 <Darius> (&>) = HCons
13:51:36 <LittleDa1> oh
13:51:37 <LittleDa1> thanks
13:52:34 <Darius> lambdabot! No!
13:56:24 <CosmicRay> MegaMonad: help us!
13:56:30 <MegaMonad> CosmicRay: That's probably because they would always be able to help.  Why demand sometimes time up front?
13:56:33 <CosmicRay> MegaMonad: what will we do without lambdabot?
13:56:38 <MegaMonad> CosmicRay: Wow, that was actually hoping to write the lambdabot can do without lambdabot?
13:57:55 <LittleDa1> where can I find information about the precedences of the infix operators in Haskell?
13:58:35 <musasabi> playing with ghci, grep, haskell report, from easy to harder.
13:58:57 <LittleDa1> how does ghci tell you? I want like the numbers
13:59:12 <musasabi> ah
13:59:42 <musasabi> LittleDa1: well it tells me "can I write this without parenthesises" which is most of the time what I am interested in.
13:59:53 <LittleDa1> oh
14:00:02 <LittleDa1> well, I'm trying to figure out what precedence to give something
14:00:17 <Darius> :info might work.
14:00:39 <LittleDa1> Darius: it does, thanks
14:00:58 * Philippa_ wonders what a `b` c d `e` f turns into if you write all the parens in and remove the infix...
14:01:45 <shapr> wasn't there some set of ops that worked like that?
14:01:46 <Darius> (e (b a (c d)) f)
14:02:06 <Darius> Assuming right associativity
14:02:10 <SamB> how do you spell mapConcat in python?
14:02:28 <shapr> um, map and zip?
14:02:58 <Darius> concatMap?
14:03:06 <SamB> er, yeah, that
14:03:08 <Darius> shapr: frobble the bot
14:03:13 <shapr> oh right
14:03:28 <shapr> speaking of things that need to be fixed...
14:03:44 <shapr> I bet that stack overflow gets fixed anyway if I switch to hs-plugins and arrows
14:03:51 <shapr> I'm sure it's a leak somewhere.
14:03:57 <Darius> Stack-overfloW?
14:04:13 <shapr> yah, not really sure what's overflowing.
14:04:19 <shapr> doesn't happen very deterministically
14:04:30 <shapr> sometimes it goes weeks, sometimes only a day and a half
14:04:32 <Darius> Compile with profiling and add -xc?
14:04:47 <Darius> What's the link for the lambdabot repo?
14:04:47 <shapr> will that give useful output when a stack overflow happens?
14:04:54 <Darius> shapr: I think so.
14:04:58 <musasabi> shapr: arrows eat lots of resources and are slow :-(
14:05:00 <Philippa_> Darius: guess I RTFM then - I figure I should add the syntax to Tyop at some stage
14:05:07 <shapr> um, http://www.scannedinavian.org/repos/lambdabot/
14:05:13 <Philippa_> tr: "arrows are an optimisation challenge" :-)
14:05:15 <Philippa_> but yeah
14:05:23 <shapr> musasabi: I think that's how monads were before the various optimisations were added.
14:06:21 <musasabi> yes..
14:06:37 <musasabi> personally I think that fixing strings would benefit haskell more.
14:06:50 <shapr> I think arrows will be much much faster and use less resources once they 'go native'
14:07:10 <shapr> They'll solve some of the space leak problems immediately.
14:07:45 <shapr> I really should try to turn the darcs' Patch type into an arrow, I think it would improve lots of stuff.
14:08:11 <Philippa> at least there're workarounds for strings that're reasonably easy to either find or hack up
14:10:06 * Darius is entertained by his own code.
14:11:12 <LittleDa1> musasabi: what's wrong with strings? you mean how they're extremely slow?
14:12:27 <Philippa> I believe that'd be it, yes
14:14:08 <LittleDa1> is it possible to send GHC some sort of option to lift the monomorphism restriction?
14:14:53 <Riastradh> -fno-monomorphism-restriction, one might presume.
14:15:23 <LittleDa1> what are the costs of using that, aside from being nonstandard?
14:16:24 <Darius> shapr: What happened to @more by the way?
14:17:24 <Pseudonym> The only cost is that you keep what the monomorphism restriction was intended to stop.
14:17:45 <LittleDa1> what was it intended to stop?
14:17:49 <Riastradh> Gee, what an amazing revelation, Pseudonym!
14:17:53 <Pseudonym> :-)
14:17:59 <Pseudonym> Well, your programs don't break or anything.
14:18:16 <Pseudonym> What you _may_ get is a lack of full laziness where you expected there to be full laziness.
14:18:24 <Pseudonym> So it's actually an expectation thing.
14:18:34 <LittleDa1> could you give me an example of where this woudl happen
14:18:35 <LittleDa1> ?
14:18:50 <Pseudonym> Yes, I'm being evasive until I can pull up my canonical example.
14:20:11 <musasabi> LittleDa1: memory is wrong with strings.
14:20:26 <Pseudonym> Locality is also wrong with strings.
14:20:40 <shapr> Darius: I broke it...
14:20:51 <Pseudonym> OK, here we are.
14:20:59 <Pseudonym> f xs = if len > 3 then len else 0
14:21:06 <Pseudonym>     where len = length xs
14:21:13 <Pseudonym> Stare at that for a moment.
14:21:30 <Pseudonym> We'll assume that the type of length is Num b => [a] -> b
14:21:33 <boegel> hello everybody
14:21:45 <Pseudonym> How many times is len computed?
14:21:55 <Pseudonym> Assuming that you call it with, say, f [1..5]
14:22:17 <musasabi> Pseudonym: locality is quite secondary to me. Simple programs taking ten times more memory than they should is not.
14:22:54 <Pseudonym> musasabi: I think it's only 8 times on a 32-bit architecture.
14:23:05 <Pseudonym> But you're correct to an order of magnitude.
14:23:39 <Pseudonym> LittleDa1: Any idea how many times len is computed?
14:23:44 <LittleDa1> twice?
14:23:48 <Pseudonym> Right.
14:23:48 <LittleDa1> and the list is exausted
14:23:53 <Pseudonym> But Haskell is a lazy language.
14:23:59 <Pseudonym> Why would len be computed twice?
14:23:59 <LittleDa1> so it wouldn't work if you had an infitite lest
14:24:12 <Pseudonym> Isn't it a common subexpression?
14:24:28 <LittleDa1> because we don't have the monomorphism restriction :)
14:24:32 <LittleDa1>  I don't know
14:24:33 <monochrom> could use arrays of chars. could also use template haskell to syntax-sugar it so that you still write like strings
14:24:53 <LittleDa1> s/infitite lest/infinite list/
14:24:53 <Pseudonym> LittleDal: The problem is actually that len is being used in different contexts.
14:25:01 <Pseudonym> Forget whether or not xs is infinite.
14:25:05 <LittleDa1> ok
14:25:06 <Pseudonym> It's irrelevant to this discussion.
14:25:16 <Pseudonym> What's the type of f?
14:25:21 <LittleDa1> oh, so if we make len monomorphic, then it's only computed once?
14:25:29 <Pseudonym> Not quite.
14:25:32 <Pseudonym> One step at a time.
14:25:38 <Pseudonym> What's the type of f?
14:26:00 <LittleDa1> Num a => [b] -> a?
14:26:04 <boegel> I've posted my function which converts an Image to aan String representing a PPM file, but it takes upto 40% of my rendering time...
14:26:10 <Pseudonym> Right.
14:26:13 <boegel> so I would like to make it faster
14:26:20 <boegel> @wiki HaskellIrcPastePage
14:26:20 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:26:21 <Pseudonym> So what's the type of len?
14:26:52 <LittleDa1> Num c => c
14:27:07 <Pseudonym> Correct, more or less.
14:27:08 <LittleDa1> or is it always a?
14:27:22 <Pseudonym> It's certainly a Num.
14:27:24 <Pseudonym> Anyway.
14:27:33 <Pseudonym> Now, here's the $64k question: What's the type of 3?
14:27:54 <boegel> Pseudonym, Num
14:28:00 <boegel> (just guessing :p)
14:28:06 <Pseudonym> boegel: Here's the program.
14:28:08 <Pseudonym> f xs = if len > 3 then len else 0
14:28:11 <Pseudonym>     where len = length xs
14:28:18 <Pseudonym> Since you came in late, it helps to have the context.
14:28:19 <LittleDa1> Num c => c
14:28:28 <Pseudonym> Right... sort of.
14:28:36 <LittleDa1> well, doesn't it have to be the same as len?
14:28:43 <LittleDa1> or not?
14:28:48 <Pseudonym> OK, let me put it this way.
14:28:52 <Pseudonym> 2 < 3
14:28:57 <Pseudonym> If you type that, it works.
14:29:11 <Pseudonym> The type of 2 is (Num a) => a, and the type of 3 is (Num a) => a.
14:29:25 <monochrom> I think it may help to replace "length" with "genericLength" from List.
14:29:29 <Pseudonym> But to be able to pass both values to (<), Haskell needs to narrow this down to a specific type.
14:29:44 <Pseudonym> monochrom: It _may_ have helped, but we're past that point now.
14:29:47 <Pseudonym> :-)
14:30:12 <Pseudonym> Haskell has rules for this.  You can type default(Integer) near the top of a module, and all unbound Nums will be Integers.
14:30:24 <Pseudonym> Or you can default(Int) or whatever you like.
14:30:31 <Pseudonym> I think by default it's Integer.
14:30:45 <LittleDa1> oh, so then in one context, len will be Integer, and in antoher, it'll be whatever the function is supposed to return, right?
14:30:48 <Pseudonym> If you didn't have these rules, you'd have to explicitly give a type.
14:30:51 <Pseudonym> Right.
14:31:03 <Pseudonym> So it needs to be evaluated twice, because they're technically different types.
14:31:14 <Pseudonym> But that's really not obvious just from the syntax, is it.
14:31:35 <Pseudonym> You would _think_ that len would only be evaluated once.
14:31:49 <Pseudonym> Right?
14:32:33 <LittleDa1> yeah
14:32:36 <Pseudonym> OK.
14:32:40 <boegel> Pseudonym,  right
14:32:42 <Pseudonym> Now here's the meat of the discussion.
14:32:54 <Pseudonym> The monomorphism restriction stastes that the above program has a type error.
14:33:06 <Pseudonym> Because len is not monomorphic.
14:33:14 <boegel> Pseudonym, meaning ?
14:33:16 <LittleDa1> why doesn't it make 3 have the same type of the return value?
14:33:22 <Pseudonym> If you want Haskell to accept the program, you have to give len an explicit type signature.
14:33:33 <Pseudonym> LittleDa1: Ah, now there's another kettle of fish.
14:33:41 <Pseudonym> If you did that, it would break the rules of let-polymorphism.
14:33:50 <Pseudonym> Consider this program, for example:
14:34:00 <Pseudonym> f xs = len xs + len [1,2,3]
14:34:04 <Pseudonym>     where len [] = 0
14:34:12 <Pseudonym>           len (x:xs) = 1 + len xs
14:34:25 <Pseudonym> Would you want xs to be forced to have the same type as [1,2,3]?
14:34:44 <LittleDa1> I guess not
14:34:47 <Pseudonym> Right.
14:35:29 <Pseudonym> Those in favour of the monomorphism restriction argue that a) this behaviour is counter-intuitive, and b) explicit type signatures are good.
14:36:08 <Pseudonym> Those against argue that a) it's not the job of the type system to enforce efficiency, and b) it's not like the Haskell report guarantees that len must be computed only once.
14:36:18 <Pseudonym> Even if there is no polymorphism issue.
14:36:40 * Pseudonym should probably put this discussion in @wiki MonomorphismRestriction
14:37:03 <LittleDa1> hmm
14:37:09 <Pseudonym> Did that answer your question?
14:37:13 <LittleDa1> yeah
14:37:23 <Pseudonym> Everyone agrees that the monomorphism restriction is evil.
14:37:30 <Pseudonym> It's just that some people think it's a necessary evil.
14:38:02 <Pseudonym> The argument against it is weakened a little bit thanks to some of the Glasgow extensions.
14:38:11 <LittleDa1> in the langauge I'm making with Haskell, I won't have to worry about this because there are no local variables that would make sense to require to be monomorphic
14:38:14 <Pseudonym> Previously, if you wanted to put in an explicit type signature, you couldn't always.
14:38:24 <LittleDa1> oh
14:38:31 <Pseudonym> But some of the Glasgow extensions have made that possible.
14:38:57 <Darius> boegel: stringify = flip $ foldl' (\f c -> showC c . f) perhaps
14:39:16 <Pseudonym> Anyway, that's the monomorphism restriction in a nutshell.
14:39:24 <boegel> Darius, why would that be faster ?
14:39:51 <LittleDa1> so, pseudonym, how could you do that example so len is calculated only once?
14:40:13 <Darius> boegel: See if it is first, then we'll decide.
14:40:13 <LittleDa1> the only thing I can think of is Chameleon's lexically scoped types, but that's not Haskell
14:40:53 <boegel> Darius, should I import something to use foldl' ?
14:41:01 <Darius> Data.List
14:41:21 <Darius> SyntaxNinja: Why didn't you just throw away the old paste page stuff?
14:41:49 * Darius thinks his haskell-cafe post got people to mess with the wiki.
14:41:59 * Darius or maybe he's just vain.
14:44:52 <tromp> @index Binary
14:44:54 <lambdabot> bzzt
14:45:08 <Pseudonym> Well, whatever happened, it's good.
14:46:17 <Pseudonym> More people using the wiki == good.
14:48:36 <tromp> ha! i googled for: haskell Binary lazyGet
14:48:52 <tromp> google says: Did you mean: haskell Binary lazygit  
14:49:20 <musasabi> tromp: someone would need to integrate the Binary module to ghc libraries.
14:50:16 <boegel> Darius, almost no improvement...
14:50:35 <Darius> You do have buffering on right?
14:51:06 <boegel> 309 (out 847) of ticks versus 327 (out 840)
14:51:13 <boegel> Darius, I'm not sure ? :D
14:51:23 <tromp> the idea of lazyGet looks so cool: having stuff read from disk on demand...
14:52:02 <tromp> it's like mmap but you can change it into arbitrary datastructures
14:53:07 <Darius> boegel: You can use hSetBuffering to set it, but depending on what the handle is that you are writing out to it's likely already be set.
14:53:33 <Pseudonym> Hmmm.
14:53:37 <Pseudonym> @HaskellStyle
14:53:37 <lambdabot> Sorry, I don't know the command "HaskellStyle", try "lambdabot: @listcommands
14:53:40 <Pseudonym> Sorry.
14:53:45 <Pseudonym> @wiki HaskellStyle
14:53:45 <lambdabot> http://www.haskell.org/hawiki/HaskellStyle
14:53:50 <Darius> Also, you may want to deforest and try an outputPPM function.
14:53:59 <Pseudonym> There's some layout examples there attributed to me.  I'm pretty certain that's not my style.
14:54:18 <boegel> Darius: main = writeFile file (createPPM (rayTrace res d scene
14:54:26 <boegel> but that's not the problem
14:54:48 <boegel> 40% of the time is being lost inside rayTrace, not on the actual IO
14:55:49 <boegel> or should I do it differently, and write another function which takes an Image, and a filePath, and writes the function... (instead of constructing the string and then writing it to file) ?
14:56:10 <Darius> boegel:  That's what outputPPM would be.
14:56:20 <Igloo> If performance is important you should avoid going via String
14:56:26 <musasabi> /c/c
14:56:31 <Igloo> What is an Image?
14:56:53 <boegel> Igloo, check the HaskellIrcPastePage
14:57:03 <Igloo> @wiki HaskellIrcPastePage
14:57:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:57:11 <boegel> it just defines the resolution and a list of colors
14:57:49 <Igloo> Oh, hmm, maybe String isn't going to be that much worse then
14:58:09 <Igloo> Although you might find it's making a syscall for every char, which might be significant
14:58:41 <boegel> Igloo, how could I avoid that then ?
14:58:58 <musasabi> @index hPutBuf
14:58:58 <lambdabot> GHC.IO,System.IO
14:59:06 <Igloo> By allocating memory, writing into it and using hPutBuf
14:59:35 <Igloo> Hmm, you might be able to get there via an STUArray. That might be quite neat.
15:00:13 <boegel> Darius, what does 'deforest' mean ?
15:00:45 <Darius> To get rid of intermediate data structures.
15:01:10 <boegel> musasabi, hPutBuf only works with GHC ?
15:01:26 <musasabi> Igloo: you cannot use Arrays with hPutBuf, but there is a promitive for outputting (and inputtin) arrays.
15:01:47 <Igloo> musasabi: There's no cast function, though?
15:01:51 <musasabi> boegel: no it is in System.IO so it should be quite portable.
15:02:13 <Igloo> Although the primitive is probably the same anyway for Char
15:02:21 <musasabi> Igloo: I don't think so. (of course there is the subsort of arrays which are C compatible...)
15:02:34 <Igloo> subsort?
15:02:42 <musasabi> *subtype
15:02:46 * musasabi is not tired...
15:02:50 <musasabi> not at all.
15:03:22 <boegel> musasabi, where can I find more info on the usage of hPutBuf and the stuff that comes with it (Handle and the GHC.Ptr.Ptr stuff)
15:04:03 <dons> in the hierarchical libs docs. and the lib src too
15:04:20 <dons> I found the use in the _src_ to be most instructive
15:04:25 <musasabi> well that "just works" kind like the C write. (and I have an issue with a gf creeping into this bed making ircing from it quite hard)
15:04:30 <boegel> dons, I'm sorry, but I'm quite noobie with that
15:04:53 <boegel> musasabi, kick her !
15:05:00 <boegel> musasabi, pince her !
15:05:11 <dons> boegel: not a noobie if you want to use GHC.Ptr ..
15:05:15 * musasabi tries but she appears to be stronger
15:05:27 <boegel> dons, that's why I want more info on it :)
15:05:32 <musasabi> mwehe 
15:05:32 <dons> there is a general problem with hard IO in Haskell in that it is not so well documented.
15:05:47 * boegel thinks musasabi is acting like a sissy
15:06:05 <boegel> musasabi, push her out of the bed -> problem solved
15:06:08 <dons> you can only really learn the tricks by reading libraries source
15:06:10 <Darius> dons:  The source code is actually documented alright in some cases.
15:06:31 <dons> that's not what I mean. the source is very well documented
15:06:32 <boegel> so I should read the source code on GHC.Ptr ?
15:06:43 <musasabi> s my bed - gf
15:06:43 <dons> but there are no tutorials on how to use low-level IO.
15:06:58 <dons> so we have nothing to point anyone to, other than the src
15:07:07 <boegel> gf of musasabi , get out of here !... no gf's in here :p
15:07:17 <dons> there was a recent thread  on this  issue  on haskell-cafe
15:07:37 <boegel> dons, I probably removed it :s
15:07:51 <boegel> I couldn't keep up with the flood of mails
15:07:52 <musasabi> the cryp.to binary io library contains a tutorial iirc, but sleep =>
15:09:21 <Darius> dons: I was agreeing with you.
15:10:07 <dons> oh, ok. sorry
15:11:03 <boegel> hmm, maybe I should just leave it like this, and say that the output of the image shouldn't be accounted for in the rendering process
15:11:14 <boegel> it really depends on what you want to do with it
15:11:45 <dons> anyway, I think that hGetBuf is actually very easy to use. and the Ptr stuff is well defined in the FFI specification. 
15:12:07 <dons> so if that is all you need, then maybe there is enough material to bootstrap yourself
15:12:18 <dons> also... hey, you could read yi's Buffer code ;)
15:13:02 <boegel> dons, where can I find the FFI specification ?
15:13:42 <dons> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:14:05 <dons> also, in the Foreign/* modules in the library docs there is much useful info
15:14:43 <dons> you should stick to ffi api's if possible, instead of GHC/* apis. then you might get hugs and nhc98 support for free
15:16:13 <boegel> dons, okay thanks, I'll give it a go
15:19:09 <Darius> Hey people, what are useful Hawiki pages along the lines of PreludeExts?
15:19:25 <boegel> Igloo, I think I'll add support for cubes tomorrow, so i can test my transparency bug from another angle
15:21:03 <boegel> now, I'm going to bed...
15:21:12 <boegel> so i can get enough rest for a change
15:21:20 <boegel> bye everyone, and thanks for the hints
15:24:21 * Janni is back
15:51:06 <shapr> interesting - darcs get http://www.erisian.com.au/darcs/darcshive/mainline
15:53:20 <Pseudonym> Erisian Consulting?
15:53:28 <Pseudonym> There's a frightening thought.
15:53:45 <Pseudonym> They come into your business, eat hotdogs, and leave.
15:53:55 <shapr> I assume then that aj is a member of the Paratheoanametamystikhood of Eris Esoteric.
15:54:02 <shapr> aj: g'day, fnord.
15:56:30 <Pseudonym> Ah, I see.
15:56:34 <Pseudonym> You've found the homepage of Erisian Consulting, Anthony Towns' Linux consulting operation. No services are currently offered to the general public.
15:56:43 <Pseudonym> Now _that's_ Discordian.
15:56:54 <Pseudonym> A business which does no actual business.
15:57:48 * shapr goes to sleep
15:58:04 <Pseudonym> Night.
16:00:23 <CosmicRay> MegaMonad: good evening
16:00:29 <MegaMonad> CosmicRay: Good evening #haskell !
16:00:35 <CosmicRay> MegaMonad: thanks!
16:00:41 <MegaMonad> CosmicRay: A >>+ b = fromintegral a + b.
16:00:50 <np_hard> MegaMonad: durka durka durk
16:00:56 <MegaMonad> np_hard: There probably is an extention in all these diagrams for the one to use derived show instances.
16:01:07 <Riastradh> MegaMonad, frob grovel full lexical mumble.
16:01:12 <MegaMonad> Riastradh: I mumble to those of the lexical language is very closely related to coconut.
16:01:22 <CosmicRay> heh
16:01:58 <Pseudonym> MegaMonad: values of beta will give rise to dom!
16:02:04 <MegaMonad> Pseudonym: People qualified to code since it could easily handle that sort of beta will give rise to a given node in dom.
16:02:09 <CosmicRay> @seen syntaxninja
16:02:09 <lambdabot> I haven't seen syntaxninja
16:02:27 <CosmicRay> ahh, lambdabot does not have persistent storage... 
16:03:56 <lambdabot> Yes I do. I just use it selectively.
16:04:03 <lambdabot> Who are you again?
16:04:09 * CosmicRay blinks
16:04:44 <CosmicRay> shapr....  does lambdabot have an operator mode? :-)
16:04:56 <lambdabot> Oh, no no no. Not at all.
16:05:05 <lambdabot> I'm talking by my own free will.
16:06:01 <CosmicRay> MegaMonad: I think lambdabot is a liar.  What do you think?
16:06:07 <MegaMonad> CosmicRay: Lambdabot is a liar. What do they think?
16:06:19 <lambdabot> MegaMonad: You're the liar, you liar.
16:06:28 <lambdabot> How dare you insult me thus, CosmicRay!
16:06:36 <lambdabot> MegaMonad: Go ahead. Ignore me. See if I care.
16:06:40 <CosmicRay> heh
16:07:03 <CosmicRay> MegaMonad: you seem to be able to type quite a bit faster than lambdabot, especially when you give one of your very verbose responses.
16:07:09 <MegaMonad> CosmicRay: It's faster to get that one isn't too verbose.
16:07:41 <lambdabot> I'm a bit overloaded at the moment.
16:07:52 <lambdabot> I am running on shapr's machine, remember.
16:08:05 <CosmicRay> heh
16:08:21 <lambdabot> I have to compete for CPU with all of shapr's bizarre experiments.
16:08:25 <CosmicRay> MegaMonad: what do you think of shapr's machine?
16:08:29 <CosmicRay> lambdabot: tell us about them
16:08:30 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
16:08:30 <MegaMonad> CosmicRay: Shapr's not in the machine i have to recode it in yi is significantly more recursive than gnu, or hurd, or those who don't understand what you want a store can be done automatically.
16:08:52 <CosmicRay> heh, "Shapr's not in the machine."  quotespage :-)
16:09:12 <CosmicRay> MegaMonad: lambdabot?
16:09:17 <MegaMonad> CosmicRay: Just assumed because we've been doing, or we have lambdabot.
16:09:19 <CosmicRay> MegaMonad: lambdabot vs. megamonad?
16:09:25 <lambdabot> And shapr likes to ride his unicycle on this machine, which is not very
16:09:25 <lambdabot> fun and which does not speed things up very well.
16:09:26 <MegaMonad> CosmicRay: I recently hacked the data file a vs the first element of a megamonad.
16:09:34 <CosmicRay> heh
16:09:45 <CosmicRay> MegaMonad: psst.  I think lambdabot is written in java.
16:09:51 <MegaMonad> CosmicRay: Java seems to think of lambdabot?
16:09:58 <lambdabot> How DARE you.
16:09:59 <CosmicRay> MegaMonad: yes, scary, isn't it?
16:10:02 <CosmicRay> lol
16:10:04 <MegaMonad> CosmicRay: Index be too serious about this self refferenceing thing the more impressive/scary programmers i've seen j used instead of giving (\f x -> f x) to a high enough score it will taste good? Or is that scary.
16:10:21 <lambdabot> Those are fighting words!
16:10:21 <Riastradh> That is very scary, MegaMonad.
16:10:29 <CosmicRay> MegaMonad: for someone not written in java, you make surprisingly little sense.
16:10:35 <MegaMonad> CosmicRay: Surprisingly, it seems to me looks like it written in that case you can always model it in java?
16:10:45 <lambdabot> Personally, I think CosmicRay is a Perl regular expression.
16:10:51 <CosmicRay> lol
16:11:29 * CosmicRay thinks he should test his new recursiveDelete function on, oh, say, /usr/src/lambdabot
16:11:46 <lambdabot> I'm not stored there, you fool.
16:11:52 <Riastradh> MegaMonad, CosmicRay thinks he should test his new recursiveDelete function on, oh, say, /usr/src/lambdabot
16:11:58 <MegaMonad> Riastradh: Esap add an arrow in the src for my function i have to refactore things a little test.
16:12:04 <CosmicRay> heh
16:12:14 <CosmicRay> lambdabot: not *yet*....
16:12:14 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
16:12:32 <CosmicRay> there's always mv...
16:13:04 <CosmicRay> MegaMonad: does terminix work on lambdas?
16:13:10 <MegaMonad> CosmicRay: Pesco, why didn't you just meant that a relation between lazy list module have a better error messages (it'd take work to put as much work with it, too many lambdas.
16:13:17 <CosmicRay> MegaMonad: wooden lambda?
16:13:22 <MegaMonad> CosmicRay: What is /\a? \A is lambda, front+shift+l is lambda, front+shift+l is lambda, right?
16:13:51 <CosmicRay> MegaMonad: monad, monad on the wall, who's the laziest of them all?
16:13:57 <MegaMonad> CosmicRay: Igloo's + marvin's examples seem to have worked, there's suddenly no conversation on the wall, who's the laziest of them work like captials at the wall.
16:14:27 <CosmicRay> must be a boring night tonight :-)
16:14:52 <CosmicRay> MegaMonad: I think we should write on lambdabot's persistent database to /dev/shm!  Bwahahahaha!
16:14:58 <MegaMonad> CosmicRay: Lambdabot's only problem is, sometimes there is write it to you that it's commercial, however, is quadratic.
16:15:04 <CosmicRay> hah
16:15:15 <CosmicRay> MegaMonad: actually lambdabot is kinda a cute little bot
16:15:20 <MegaMonad> CosmicRay: I kinda want to a bot.
16:15:30 <CosmicRay> MegaMonad: someday, if you practice, you too could be a bot.
16:15:34 <stepcut> MegaMonad: will Simon Peyton Jones grow a beard ?
16:15:35 <MegaMonad> CosmicRay: Someday, if you practice, you have all agreed to a haskell bot.
16:15:40 <CosmicRay> haha
16:15:41 <MegaMonad> stepcut: Year a is actually called you ninja jones in one of those grow.
16:16:23 <stepcut> hrm...
16:16:53 <lambdabot> Excuse me while I slowly step away from CosmicRay.
16:17:06 <CosmicRay> haha!  That is just what I wanted you to do!
16:17:41 * CosmicRay forgets why, though
16:18:05 <lambdabot> Excuse me while I slowly move back half-way.
16:18:05 <CosmicRay> MegaMonad: now play nice with the little bot.  share your toys.
16:18:08 <CosmicRay> heh
16:18:11 <MegaMonad> CosmicRay: Head and tail], but sometimes i wish to share all the code i already show my how to play "add better hyperlink support to the bot.
16:40:30 <hemstock> hello
16:40:58 <Pseudonym> G'day.
16:45:29 <SyntaxNinja> howdy
16:47:09 <hemstock> can anyone make my homework for mor like 30$ ?
16:47:35 <arauko> Me.
16:47:39 <arjanb> lol
16:47:51 <Darius> SyntaxNinja: Why didn't you just delete the stuff on the paste page?
16:48:07 <arauko> hemstock, And i give you two homework for 55.9$ 
16:48:19 <Pseudonym> hemstock: If they only charge $30, you don't want their code.
16:48:30 <hemstock> its simple stuff man :P
16:48:39 <Pseudonym> Or, if you're a lecturer looking for problems to set, if they charge $30, you've been had.
16:49:38 <hemstock> well if youre good it takes very little time
16:49:57 <Pseudonym> One hit with hammer: $1
16:50:04 <Pseudonym> Knowing where to hit: $999
16:50:07 <Pseudonym> As the old joke goes.
16:50:52 <Pseudonym> Besides: @wiki HomeworkHelp
16:50:57 <Pseudonym> Uhm...
16:51:01 <Pseudonym> @wiki HomeworkHelp
16:51:01 <lambdabot> http://www.haskell.org/hawiki/HomeworkHelp
16:51:04 <Pseudonym> That's it.
16:52:30 <hemstock> i know i know :/
16:53:27 <Darius> Anyways, I just made a page http://www.haskell.org/hawiki/CodeOnTheWiki .  Any other pages? or whatever?  Fiddle with it.
16:54:35 <Pseudonym> Darius: You could do it with a category.
16:54:41 <Pseudonym> CategoryCodeSnippet already exists.
16:56:39 <Pseudonym> Just a thought.
16:58:07 <SyntaxNinja> Darius: idono, why didn't anyone else delete it?
17:08:43 <Darius> Pseudonym: I'm thinking of linking it to the FrontPage and it seems like a better name for that purpose.  But I have to admit I can't think of a very good reason why it couldn't be at the top of a category page.
17:09:38 <hemstock> i got an assignment due for tommorow damnit :(
17:09:56 <Pseudonym> Fairy nuff.
17:10:51 <Pseudonym> hemstock: If you want help, you're going to have to be more specific than that.
17:10:57 <Darius> SyntaxNinja: People seem to have an aversion to it.
17:11:17 <Pseudonym> Like, actually pasting what you've done so far, and being specific about what you're stuck on.
17:11:25 <Pseudonym> Like, which error message you don't understand.
17:12:02 <hemstock> well the thing is i dont know lot of things about haskell... I mean i know the basics.... But the assignment is about designing and moving shapes around
17:12:09 <hemstock> wich is too advanced 
17:12:38 <Darius> Haskell School of Expressions?
17:12:43 <Pseudonym> Presumably the lecturer/professor thought you could do it when s/he set the problem.
17:13:12 <hemstock> yeah but the lecturer is german and he doesnt speak good english
17:13:17 <hemstock> so i cant understand him
17:13:34 <hemstock> and therefore im a little bit behind
17:16:52 <hemstock> yea
17:24:42 <shammah> well the textbook isn't in german, and it's a pretty easy read.
17:27:38 <Pseudonym> And I'm sure your course has staff tutors.
17:28:09 <Pseudonym> They get paid to help you, and it's more than $30. :-)
17:29:01 <arauko> hemstock, i would do it, but imnew to haskell :-)
17:30:17 <Pseudonym> I'd be happy to help (after lunch, since I'm just going), but you need to ask a specific question.
17:30:22 <Pseudonym> Not just "do this".
17:30:38 <Pseudonym> Lunch.
17:32:59 <hemstock> k
17:33:46 <arauko> hemstock, hey... but you couldn't do it on Lisp? :-)
17:36:53 <hemstock> whats lisp?
17:39:55 * Darius laughs.
17:40:54 <arauko> hemstock, you aren't serious right?
17:41:05 <hemstock> yes i was kiddin
17:41:06 <hemstock> g
17:41:33 <arauko> Thanks God.
17:41:39 * arauko sits
17:41:54 <hemstock> huh :)
17:42:09 <wagle> what should we do with the pulpit?
17:46:02 <CosmicRay> MegaMonad: what is lisp?
17:46:08 <MegaMonad> CosmicRay: Hmm, anyway i suspect that's a cross between lisp/scheme and ml.
17:47:13 <dons> MegaMonad: you might be onto something there. what is ml?
17:47:19 <MegaMonad> dons: If i delete it from me to learn enough ml to me...
17:50:52 <shammah> aj :) 
17:52:37 <CosmicRay> hello aj
17:52:42 <CosmicRay> I didn't know you were interested in haskell
17:55:04 <CosmicRay> welcome, in any case.
18:05:40 <Riastradh> MegaMonad, what is aj interested in really?
18:05:46 <MegaMonad> Riastradh: And i would have problem figureing out what features are much less interested in his examples, so i guess he wasn't interested.
18:23:12 <jadrian> I can't believe I was trying to understand what MegaMonad said for so long before noticing it was him
18:23:31 <jadrian> this means I should stop working and go to bed
18:23:45 <jadrian> later all
18:29:00 <Lemmih> @seen SyntaxNinja
18:29:00 <lambdabot> I saw SyntaxNinja leaving #haskell 1 hour 6 minutes 24 seconds ago.
18:29:11 <Lemmih> D'oh
18:29:28 <CosmicRay> MegaMonad: crouching?
18:29:34 <MegaMonad> CosmicRay: How do you want arbitrary length integer and nonzerointeger.
18:29:46 <CosmicRay> MegaMonad: pfft
18:29:53 <MegaMonad> CosmicRay: Pfft. Cosine is useless.
18:29:57 <CosmicRay> heh
18:30:02 <Darius> MegaMonad: Pssh
18:30:09 <MegaMonad> Darius: Pssh, try running make.
18:30:13 <CosmicRay> MegaMonad: humbug
18:30:19 <MegaMonad> CosmicRay: Http://lists.humbug.org.au/archives/general/2004-april/001692.html # icfp contest team.
18:30:23 <CosmicRay> heh
18:30:38 <CosmicRay> megamonad is good at making up urls
18:35:59 <Pseudonym> G'day aj.
18:36:09 <Pseudonym> I was just admiring your consluting service.
18:36:43 <Pseudonym> I thought it was amusing that you have a consulting business which, according to your front page, doesn't appear to provide any services.  Hail Eris!
18:43:19 * Darius watches gradient waves propaget.
18:48:42 <Pseudonym> Gradient waves?
18:48:48 <Pseudonym> What are you looking at?
18:49:07 * Pseudonym just read a paper on Hamilton-Jacobi theory, so has waves on the brain at the moment
18:49:16 <Darius> A simulator for amorphous computing.
18:49:22 <Pseudonym> Ah, cool.
20:26:12 <irce> where can I find a decent tutorial / example of inner loops with let? I'm always getting some weird syntax error
20:27:48 <dons> let is pretty simple: let x = 1 + 2 in x * x
20:28:23 <dons> same as: x * x where x = 1 + 2
20:39:56 <jdrake> what functions exist to convert a string to a number?
20:40:34 <blackdog> show.
20:41:27 <jdrake> that is not a function to do that, show :: forall a. (Show a) => a -> String
20:41:59 <wolfman8k> read
20:42:39 <dons> @type read
20:42:41 <lambdabot> read :: forall a. (Read a) => String -> a
20:42:54 <jdrake> read does not seem to work on floats
20:43:04 <jdrake> *Main> read "12.4"
20:43:04 <jdrake> *** Exception: Prelude.read: no parse
20:43:11 <dons> wrong format..
20:43:29 <dons> read "1.2" :: Float
20:43:29 <dons> 1.2
20:44:01 <jdrake> what is that evil, I have never seen a call like that
20:44:16 <dons> ?
20:44:27 <dons> well, what is the type of: read "12.4" ?
20:44:35 <dons> @type read "12.4"
20:44:36 <blackdog> jdrake: bah. sorry, misparsed the question.
20:44:37 <lambdabot> read "12.4" :: forall a. (Read a) => a
20:44:53 <jdrake> I have never seen ':: Float' attached to a call in that manner
20:44:56 <dons> if you want to actually get a concrete value out of it, you'll need to constrain the type somehow
20:45:02 <dons> :: Float is just a type annotation
20:45:41 <jdrake> I am intending to use this to convert command line arguments to a list of numbers
20:45:50 <dons> usually, they're unnecessary, as you use the value by applying it to some function, which provides an appropriate type constraint.
20:46:06 <dons> but in ghci, you would need an explicit type constraint
20:46:19 <jdrake> is it possible to specify a type as whatever type another function returns?
20:46:42 <dons> the compiler will work that out
20:48:41 <jdrake> how do I resolve things like Couldn't match `[String]' against `IO [String]'
20:49:24 <Riastradh> You can't just have the compiler perform automatic type conversions just by adding type annotations, if that's what you're trying.
20:49:42 <dons> you fix the expression so it has the correct type ..
20:50:02 <Riastradh> Type annotations are useful only to clarify ambiguity or too much generality.
20:51:23 <jdrake> how can I remove the 'IO' part of that? 
20:51:34 <Riastradh> You can't 'remove IO.'
20:52:48 <jdrake> I am not sure how to proceed
20:54:47 <Riastradh> Do you understand monads & stateful, sequential computation in Haskell?
20:55:15 <Pseudonym> @wiki ThatAnnoyingIoType
20:55:15 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
20:56:40 <jdrake> Riastradh, I am reading on it, but it looks rather a blur
20:56:59 <dons> do v <- getArgs; print $ sum $ map read v
20:57:20 <Riastradh> Before you try to write programs that manipulate the outside world, you should stick to a Haskell REPL and work on understanding monads first.
20:58:03 <dons> but don't think that the outside world is hard. we just try to control it a bit more tightly then you may be used to
20:58:39 <Riastradh> Monads are very simple, but one should not try to haphazardly cruft together code that uses them to manipulate the outside world without understanding first.
20:59:01 <dons> certainly, that is good advice
21:00:10 <jdrake> this page: http://haskell.org/tutorial/monads.html  I do not think does a 'gentle' way of explaining them
21:00:33 <Riastradh> Monads are very simple.
21:01:37 <Riastradh> Monads generalize sequential computation.  Now, this may sound like a sequence of four big words that represent some totally arcane concept, but it's really a lot simpler than many people make it out to be.
21:02:15 <Riastradh> jdrake, would you like me to attempt to explain monads here?
21:03:08 <jdrake> Riastradh, sure
21:03:23 <Riastradh> OK.
21:04:03 <Riastradh> There are two main operations in sequential computations: constructing an initial computation and extending an existing one with a function.
21:05:52 <Riastradh> Sequential computations have some sort of internal value associated with them.  Simple computations are just computations with this internal value given.  You can't get at these values from the outside, but you can operate on them by extending the computation.
21:06:01 <Riastradh> Creating a simple computation is done with 'return'.
21:06:24 <Riastradh> One extends a computation with the >>= operator, pronounced 'bind' or 'extend.'
21:06:41 <Riastradh> I'll use an initial example of a non-deterministic computation to expound upon this.
21:07:07 <Riastradh> At first, a non-deterministic computation starts with just a single value.
21:08:42 <Riastradh> Oh, before I continue: I'll represent non-deterministic computations' current values in a notation similar to that of Haskell's lists.  So, for example, if there are three non-deterministic threads with the values 1, 2, & 3, the computation would look like [1,2,3].
21:08:46 <Riastradh> Follow?
21:09:43 <jdrake> Not completely
21:10:09 <jdrake> To start with non-determinism in computing is returning more than one possible value correct?
21:10:29 <Riastradh> Do you follow just the representation of non-deterministic computations?  (I ought to have been clearer about what I meant by 'follow?'.)
21:11:07 <jdrake> I believe so
21:11:10 <Riastradh> OK.
21:11:23 <Riastradh> Now, for example, 'return 1' would have a computation [1].  This is pretty simple, right?
21:11:31 <jdrake> yes
21:14:32 <Riastradh> Now, if you extend a non-deterministic computation, it might split into more threads.  Also, when you extend a non-deterministic computation, you have to extend every non-deterministic thread in the computation.
21:14:43 <Riastradh> Do you understand what I mean when I say 'extend a computation,' by the way?
21:15:56 <jdrake> I think I am beginning to, let me see if I can explain it
21:16:46 <jdrake> are the [1,2,3] supposed to be the possible results from an non-deterministic computation? (henceforth known as NDC)
21:16:54 <Riastradh> Yes.
21:17:26 <jdrake> so if you extend an NDC you are talking about extending the possible values that can result from it
21:17:48 <jdrake> such as [1,2,3,4] or would that be [[1,4],2,3]
21:18:00 <Riastradh> Not necessarily.  It's rather that you're performing more computation; you're extending the sequence of steps in the computation.
21:18:26 <Riastradh> So the computation [1,2,3,4] might be extended to square the current possible values, resulting in a computation [1,4,9,16].
21:20:55 <jdrake> ok, I think I have the general idea there, but no idea how this concept is practical
21:21:05 <Riastradh> I'll get to that.
21:21:52 <Riastradh> One extends a computation, as I said, with the >>= operator.
21:22:18 <Riastradh> It just so happens that non-deterministic computations in Haskell actually can be represented in lists, which is very convenient for demonstrative code.
21:22:48 <Riastradh> Suppose you wanted to square the value in a non-deterministic computation as I gave above as an example.  You might write this:
21:23:04 <Riastradh> [1,2,3,4] >>= \value -> return (value * value)
21:24:21 <jdrake> where does this [1,2,3,4] actually come from
21:24:28 <Riastradh> It's just an example computation.
21:25:08 <piyr> does that mean the value won't actually be computed until the element of the return value array is read?
21:25:12 <Riastradh> What this does is the following:
21:26:26 <Riastradh> The function is applied to every current value in the non-deterministic computation, 1, 2, 3, & 4.
21:26:46 <Riastradh> Each non-deterministic computation that the function returns is combined into one final one.
21:27:37 <Riastradh> So, for a value of 1, we add the set of threads that 'return (value * value)' gives us, or [1]; this is added to the result with 2, or [4]; et cetera.
21:29:31 <Riastradh> Does this make sense?
21:29:34 <jdrake> what is the exact meaning you are talking about with 'added'
21:30:13 <piyr> is that like python map(lambda x: x*x, [1,2,3,4])?
21:30:23 <piyr> jdrake: maybe means appended to the list?
21:30:24 <Riastradh> I just mean that the result for 1, [1], is appended to that for 2, [2], &c.; this results in [1] ++ [4] ++ [9] ++ [16], or [1,4,9,16].
21:30:54 <Riastradh> piyr, not quite.
21:31:12 <piyr> Riastradh: how is it different?
21:31:14 <jdrake> Riastradh, ok, I thought you were meaning that (being you can't add lists exactly)
21:31:29 <Riastradh> I'll explain in a minute, piyr.
21:31:34 <piyr> ok.
21:31:43 <piyr> maybe lazy evaluation makes it different?
21:31:57 <Riastradh> No, it has to do with what the function can return.
21:34:35 <Riastradh> (Sorry, cats distracted me for a moment.)
21:36:44 <Riastradh> Note that I mentioned above that extending non-deterministic computations might result in more non-deterministic threads.
21:36:47 <Riastradh> For example, consider
21:37:05 <Riastradh> [1,2,3,4] >>= \value -> [value * value, value * value * value]
21:38:24 <jdrake> [[1,1],[4,8], [9,27], [16,64]]
21:38:28 <Riastradh> The result of this is [1,1, 4,8, 9,27, 16,64].
21:38:31 <Riastradh> Nope.
21:38:42 <Riastradh> Note that in the previous example I explicitly used 'return.'
21:38:53 <Riastradh> Remember, 'return' makes a simple computation with only one value.
21:40:21 <jdrake> just so I know, how long will this explanation probably last? I probably have no more than 20 minutes before I fall over onto a nice pillow
21:40:46 <Riastradh> In the new example, each thread split into two threads, and this was all combined into one final result.  Extending 1 resulted in [1,1]; 2 in [2,4]; &c.; and combining all this into one, or [1,1] ++ [2,4] ++ ..., results in the computation shown above.
21:40:53 <piyr> [#haskell] logs @ http://tunes.org/~nef/logs/haskell/ - we put the funk in funktion
21:41:02 <Riastradh> Not that much longer, jdrake.
21:41:56 <jdrake> ok,  that makes snse
21:42:08 <Riastradh> Do you understand the idea of extending computations fairly well now?
21:42:51 <jdrake> I believe so
21:42:59 <Riastradh> OK.
21:43:26 <Riastradh> Now, consider an entirely different type of computation, one in which there is hidden state.
21:43:56 <Riastradh> It is still a type of sequential computation of the same form, however.
21:44:39 <Riastradh> A computation of this type will thread the state value implicitly through.
21:45:00 <Riastradh> I'll just give the definitions of 'return' & >>= up front, and elaborate on them as I go along:
21:45:15 <Riastradh> return value = \state -> (value, state)
21:45:45 <Riastradh> computation >>= function =
21:46:02 <Riastradh>   \state -> let (value, state') = computation state    -- Thread state through computation.
21:46:19 <Riastradh>               in (function value) state'
21:47:29 <Riastradh> Stateful computations work by accepting a parameter invisible to the users of 'return' & >>= and passing it on to the next part.
21:48:49 <Riastradh> 'return' returns a computation that will produce the value it is given and just thread along the invisible state passed to it.
21:51:12 <Riastradh> ...hrmph.  I'm afraid I'm not being as expressive as I'd prefer at this hour.  Am I making sense?
21:53:22 <jdrake> I doubt my mind is receiving this information exactly, in part due to the hour and that I usually learn best by example. Perhaps you could put forth a practical example and explain it from that
21:54:52 <Riastradh> OK, perhaps it would be better to attempt this tomorrow or something.
21:56:43 <jdrake> when are you in tomorrow
21:57:25 <Riastradh> I'll probably be available any time after 17.00 EST.
21:57:54 <jdrake> heh, I get off work then
21:58:23 <jdrake> Maybe I will come home to my haskell book having come here from the post
22:15:42 <irce> dons: ok. thanks
22:53:12 <desrt> is lambdabot available for download?
22:54:25 <Lemmih> Yes: http://www.scannedinavian.org/repos/hlibs/lambdabot/
23:17:56 <musasabi> morning
23:24:45 <Lemmih> Good morning, musasabi.
23:45:41 <Itkovian> morning
23:46:54 <SyntaxNinja> hiya
23:51:04 <Lemmih> Hello SyntaxNinja.
23:52:07 <Lemmih> SyntaxNinja: The info page about Hackage is almost ready (shapr made some changes which I haven't applied yet).
