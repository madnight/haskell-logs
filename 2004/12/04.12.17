02:15:56 <xkb> Hi
02:16:04 <xkb> in bibtex, how would you denote nonpublished lecture notes
02:16:05 <Lemmih> Hey
02:16:24 <xkb> as in real lecture notes, a reader
03:13:17 <musasabi> Where can I find the Binary module for GHC?
03:14:10 <musasabi> http://www.informatik.uni-muenchen.de/~Sven.Panne/haskell_libs/Binary.html does not work.
03:27:19 <urtie> good question
03:27:23 <urtie> dunno
03:28:48 <wli> looks like Europe arrived
03:30:01 <wli> someone has to have some kind of idea of how to coerce ghc to build, otherwise it would never get ported
03:31:46 * urtie has some idea
03:31:53 * urtie has done it a number of times
03:32:33 <urtie> however, getting it to build from scratch on a system that does not have the appropriate intermediates is kinda tough
03:32:35 <wli> I'm thinking I may be best off starting from hc stuff
03:32:40 * urtie nods
03:32:49 <urtie> you'd have to get the right hc stuff first though
03:32:53 <wli> urtie: linux/x86-64
03:32:56 <urtie> (and that can be somewhat tricky)
03:33:03 <wli> well, it should be easy
03:33:10 <wli> since it works everywhere but SuSE
03:33:12 <urtie> `should' and `is' are not equal ;)
03:33:21 <urtie> it should also be easy for Solaris 8
03:33:26 <wli> yeah, nobody's going to send me jack
03:33:41 <urtie> anyway, have you read the building guide?
03:33:47 <wli> yes
03:33:51 <wli> hc files unobtainable
03:33:58 <urtie> really?
03:34:16 <wli> they aren't googlable and no one is willing/able to generate them for me
03:34:22 <urtie> um.
03:34:23 <wli> (that I've run into yet)
03:34:30 <urtie> you haven't read the entire building guide then?
03:34:42 <wli> it said they were platform-dependent
03:34:55 <urtie> they are
03:35:14 <urtie> read section 10.2.1 for info on how to generate your own .hc files
03:35:40 <urtie> (I'm assuming you have another machine handy ;))
03:35:47 <wli> I don't
03:35:55 <urtie> `ah'
03:36:05 <urtie> and you don't have any ghc handy either, I presume
03:36:06 <wli> and 10.* failed miserably in various respects
03:36:18 <urtie> 10.* sucks *extremely* yeah
03:36:36 <wli> I have a 32-bit ghc that's broken in numerous extremely irritating ways.
03:36:44 <urtie> I'm still getting my 10.2.1 process working
03:37:06 <urtie> that counts as not having a ghc handy
03:37:14 <wli> I obtained it by taking the straight i386 ghc and screwing with things in userspace (gcc, ld, as) to fool the ghc driver.
03:37:33 <urtie> will it generate working programs?
03:37:38 <wli> 32-bit ones
03:37:49 <wli> it eventually puked in a way I couldn't work around
03:37:55 <wli> so
03:37:57 <musasabi> wli: have you tried posting to ghc-users?
03:38:11 <urtie> hm.
03:38:12 <urtie> right.
03:38:13 <wli> someone will probably have to generate hc files for me
03:38:38 * musasabi does not have amd64, so I cannot really help
03:38:50 <urtie> let's see, can you do the target machine things and send me the config.mk and ghc/includes/config.h ?
03:39:10 <urtie> I can then run the host stuff for you and send you a set of .hc files, I think
03:39:21 <urtie> that'd get you to unregisterised
03:39:27 <wli> I got through make boot and it puked somewhere after stage2
03:39:44 <urtie> from unregisterised you should then be able to bootstrap
03:39:55 <urtie> (follow 10.2.1)
03:40:12 <wli> I screwed with both config.mk and ghc/includes/config.h to try to force it to go through
03:40:22 <urtie> doesn't work
03:40:23 <wli> so they're "corrupt"
03:40:30 * urtie nods
03:40:39 <urtie> start from scratch, following 10.2.1
03:41:07 <urtie> then give me the TARGET flags in you config.mk and you T/ghc/includes/config.h
03:41:13 <urtie> +r
03:41:27 <wli> make boot doesn't work
03:41:30 <urtie> I'll send you a set of hc.tar.gz files
03:41:32 <wli> not even close
03:41:42 <urtie> ./configure --enable-hc-boot --enable-hc-boot-unregisterised    should work
03:41:49 <urtie> as should    cd T/ghc/includes
03:41:49 <urtie> $ make config.h
03:42:05 <urtie> where T is the dir where you have your fptools stuff
03:42:19 <wli> I don't remember if I had to hack to get that to go through
03:42:22 * musasabi plots using nonstandard models of number theory to encode things in the type system.
03:42:26 <wli> I'm about to find out.
03:42:30 <urtie> :)
03:45:29 <svend> urtie: can you take a look at: http://pleiades.physics.wsu.edu/ghc/config.mk.diff and tell me if I am setting the host config.mk correctly?
03:46:07 <wli> I'm also dealing with a 2nd portability issue, which is on linux/sparc, but that one is probably glibc related (AFAICT it builds okay, albeit very slowly due to lack of -j).
03:47:57 <wli> re-downloaded
03:49:33 <wli> urtie: this is the top-level fptools thing, right?
03:49:46 <wli> config.mk and config.h
03:50:19 <wli> or the ghc/mk/config.mk
03:50:26 <wli> b/c the ghc config.mk dies
03:50:38 <wli> er, configure under fptools/ghc/ dies
03:50:45 <wli> and I forgot how I hacked around it
03:50:47 <urtie> hm
03:51:47 <wli> somewhere in rts/gmp/
03:52:07 <wli> maybe not
03:52:12 <wli> that's during make boot
03:52:18 <wli> okay, punting your way
03:54:29 <wli> urtie: incoming dcc
03:56:23 <wli> there is some residue from the hacks to get it to build
03:56:34 <wli> checking for ld... /home/wli/bin/ld
03:56:49 <wli> I think the configure can be done without that hack
03:56:49 <urtie> no probs
03:57:15 <wli> no need to re-generate it?
03:57:28 <urtie> still checking, on the phone
03:59:36 <urtie> err... I'll need ghcconfig.h as well
03:59:48 <urtie> (is this a CVS version?)
03:59:59 <wli> yes
04:00:04 <wli> checking for ld... /home/wli/bin/ld
04:00:05 <wli> feh
04:00:15 <wli> cvs -z9 co fptools
04:00:22 <wli> from glass.cse.ogi.edu
04:00:30 <urtie> ah, right ;)
04:00:34 <wli> should I be using something else?
04:01:04 <urtie> nah, I'm just off to check my own buildtree
04:01:18 <urtie> (you might actually have pointed out the error I've been running into ;))
04:02:12 <Janni> Hi
04:02:13 <urtie> (ah, no.)
04:02:48 <urtie> wli: but, yeah, downloading the official 6.2.2  sourcetree would be nice, as I can then make my buildenvironment match your tree
04:03:10 <urtie> (as I already have a 6.2.2 buildenvironment ;))
04:03:44 <wli> I can do that relatively swiftly.
04:04:23 <wli> doing it now
04:05:44 <wli> fetched at 4.672 Mb/s
04:07:00 <wli> (0.584MB/s)
04:07:24 <wli> seems to be going
04:07:47 <wli> (the configure step, that is)
04:08:05 <wli> urtie: okay, ghc/includes/config.h, mk/config.mk, and what else?
04:08:41 <wli> ghcconfig.h
04:09:16 <wli> ghcconfig.h was not created 
04:10:50 <wli> neither was ghc/includes/config.h
04:11:36 <wli> make: *** No rule to make target `config.h'.  Stop.
04:14:45 <urtie> ugh. !sigh
04:14:57 <urtie> lemme check on this side
04:15:35 <wli> maybe I need the rest of the fptools stuff for 6.2.2
04:18:17 <xkb> ah.. it was @unpublished
04:26:55 <svend> I'm working on a netbsd-alpha port.  Can someone check http://pleiades.physics.wsu.edu/ghc/config.mk.diff to make sure I am setting the target vars. correctly on the host system's config.mk file?
05:06:44 <musasabi> Defining equality for peano numbers is nice..
05:06:54 <musasabi> instance Eq Zero  where _ == _ = True
05:06:54 <musasabi> instance Eq (S a) where _ == _ = True
05:09:58 <boegel> good afternoon #haskell
05:10:24 <boegel> I have a question for the people who use linux... what do you use do produce LaTeX documents ?
05:10:56 <TheHunter> boegel: texmacs
05:10:59 * TheHunter hides
05:11:22 <boegel> TheHunter: hiding ? why ?
05:11:22 * musasabi uses emacs+tetex
05:11:31 <musasabi> and sometimes vim.
05:11:58 <boegel> I have texmacs installed, but can you make a document from code too, or is it always wysiwyg ?
05:11:59 <kosmikus> TheHunter: texmacs has nothing to do with LaTeX ...
05:12:17 <TheHunter> kosmikus: it has latex export...
05:12:29 <kosmikus> that defeats the whole purpose, though
05:12:44 <kosmikus> sorry, don't have time for this today, I have to leave
05:13:01 <kosmikus> I wonder, however, why one needs to use something special to produce LaTeX documents
05:13:03 <boegel> hmm, nobody else uses LaTeX ?
05:13:05 <kosmikus> any editor will do
05:13:08 <kosmikus> bye
05:13:10 <boegel> that's hard to believe...
05:13:25 <boegel> bye kosmikus 
05:13:28 <TheHunter> boegel: see why i've been hiding?
05:13:31 <TheHunter> bye kosmikus 
05:13:43 <boegel> TheHunter: hehe :)
05:14:15 <boegel> musasabi: I want one client to produce LaTeX documents, not 3 seperate programs
05:14:21 <boegel> if that's possible :)
05:14:22 <TheHunter> but the texmacs interface is much nicer for writing formula, and the export is quite clean.
05:15:39 <tuomov> boegel: tetex=the usual *nix latex distribution
05:17:04 <boegel> oh okay
05:17:10 <boegel> thx tuomov 
05:17:36 <tuomov> texmacs is rather nice, but I don't the fact that you must press enter instead of space after a command name..
05:18:07 <tuomov> also _ and ^ should finish entering a command
05:18:41 <tuomov> +like
05:21:13 <boegel> tuomov: does texmacs use tetex behind the scenes ?
05:21:18 <tuomov> no
05:22:04 <tuomov> texmacs is just a word processor with latex-quality output and supports entering commands while writing instead of having to use zillions of weird keycombos or *yuck* the mouse
05:22:46 <tuomov> and many of the commands are the same as in latex
05:24:26 <tuomov> the major flaw is, of course, that it is a special-purpose editor and not your favourite text editor
05:24:53 <musasabi> What was the way to make peano numbers with a binary representation?
05:25:16 <wli> oh
05:25:21 <wli> I remember that.
05:26:23 <musasabi> Calculating the int value with instance PtoInt a => PtoInt (S a) where toInt _ = 1 + toInt (undefined :: a) is not very efficient.
05:26:26 <wli> musasabi: basically you need 2 injections, 1 for 2*n and 1 for 2*n+1
05:26:58 <wli> I've actually written this
05:26:59 <xkb> im still looking for a package that lets me pretty print BNF like grammers in latex 
05:27:07 <musasabi> wli: can you send a link?
05:27:18 <wli> no, because I have no idea what I did with it
05:27:25 <wli> but I can reconstitute it from scratch
05:27:28 <wli> hang on
05:27:39 <musasabi> thanks
05:30:52 <urtie> xkb: something like http://www.ctan.org/tex-archive/macros/latex/contrib/syntax/?preferredCTAN=ftp.uni-stuttgart.de&action=/tex-archive/macros/latex/contrib/   ?
05:31:19 <wli> musasabi: what arithmetic operations do you need?
05:32:25 <urtie> or maybe mark wooding's syntax package?
05:32:27 <xkb> urtie: that looks good :D
05:32:56 <urtie> which is in tetex anyway... :)
05:33:14 <urtie> and comes with a grammar environment especially designed for BNF? :)
05:34:48 <wli> musasabi: do you want to have something like data Zero = Zero; data Even t = Even t; data Odd t = Odd t; class Nat t where { n :: t -> Integer } ?
05:35:11 <wli> hmm, it should probably start with One, but never mind that
05:35:39 <wli> I guess the even instance doing 2*n+2 instead of 2*n "fixes" it
05:41:59 <wli> well, my first thought is something like:
05:42:00 <wli> data Zero = Zero deriving (Eq, Ord, Read, Show)
05:42:00 <wli> data Even t = Even t deriving (Eq, Ord, Read, Show)
05:42:00 <wli> data Odd t = Odd t deriving (Eq, Ord, Read, Show)
05:42:00 <wli> class Nat t where
05:42:00 <wli>         natToInteger :: t -> Integer
05:42:01 <wli> instance Nat Zero where
05:42:03 <wli>         natToInteger = const 0
05:42:05 <wli> instance Nat t => Nat (Even t) where
05:42:07 <wli>         natToInteger (Even x) = 2 * (natToInteger x) + 2
05:42:09 <wli> instance Nat t => Nat (Odd t) where
05:42:11 <wli>         natToInteger (Odd x) = 2 * (natToInteger x) + 1
05:45:34 <boegel> tuomov, if I have tetex installed i can just generate latex documents with 'latex doc.tex' ?
05:45:43 <wli> musasabi: is that anything like what you were looking for?
05:45:54 <wli> musasabi: or do I need to hoist it further up?
05:46:11 <wli> (i.e. zero, even, and odd being classes)
05:46:23 <musasabi> hmm that looks nice.
05:46:30 <musasabi> I was using:
05:46:32 <musasabi> data Zero
05:46:36 <musasabi> data S a
05:46:52 <wli> successor okay
05:47:04 <musasabi> but that looks good too..
05:47:11 <wli> I'm trying to remember how to do addition etc.
05:47:39 <musasabi> class PAdd a b c | a b -> c
05:47:47 <musasabi> instance               PAdd Zero  b  b
05:48:56 <shapr> @yow !
05:48:56 <lambdabot> YOW!  I can see 1987!!  PRESIDENT FORD is doing the REMAKE of "PAGAN
05:48:56 <lambdabot>  LOVE SONG"...he's playing ESTHER WILLIAMS!!
05:50:41 <shapr> d00d
05:51:08 <musasabi> instance (Even a, Even b) => PAdd a b (Even ??)
05:53:44 <wli> yeah, I'm puzzling that out
05:54:04 <wli> (2*n+2) + (2*k+2) = 2*(n+k)+4
05:54:41 <CosmicRay> good morning everyone
05:55:08 <musasabi> wli: why is the +2 needed for even?
05:55:27 <musasabi> (of course that results in two encodings for zero)
05:55:28 <wli> musasabi: otherwise you get a nasty Even Zero = Zero 
05:56:17 <wli> 2*(n+k) + 4 = 2*(n+k+2)
05:56:27 <wli> feh
05:56:32 <wli> 2*(n+k+1) + 2
05:57:32 <wli> (PAdd n k m, m (Odd Zero) p) => Padd (Even n) (Even k) (Even p)
06:00:04 <wli> (2*n+1) + (2*k+1) = 2*(n+k)+2, so that's easier
06:00:14 <musasabi> true.
06:00:37 <shapr> y0 CosmicRay 
06:00:43 <CosmicRay> morning shapr
06:00:45 <wli> (PAdd n k m) => PAdd (Odd n) (Odd k) (Even m)
06:01:35 <wli> (2*n+1) + (2*k+2) = 2*(n+k+1) + 1
06:01:58 <musasabi> thanks ^_^
06:02:07 <wli> (PAdd n k m, Padd m (Odd Zero) p) => PAdd (Odd n) (Even k) (Odd p)
06:03:21 <wli> making webabble
06:03:40 <wli> http://holomorphy.com/~wli/Nat.hs
06:03:54 <shapr> CosmicRay: wassup?
06:04:38 <wli> Probably easier to define a successor thing
06:04:44 <wli> which comes in handy for multiplication as well
06:04:47 <CosmicRay> shapr: definately not the temperature :-)
06:04:59 <shapr> It's shockingly warm here, two degrees above freezing.
06:05:02 <CosmicRay> shapr: low of -2C tonight, and that will be tomorrow's high.
06:05:30 <CosmicRay> MegaMonad: can you convert fahrenheit to celsius?
06:05:35 <MegaMonad> CosmicRay: (Me is not always the same, then the size of list comprehensions ?"  how do you convert fahrenheit to celsius?
06:06:05 <CosmicRay> MegaMonad: try the formula: C = (F-32) * 5 / 9
06:06:11 <MegaMonad> CosmicRay: (Not bad as they appear because im visiting 5 more than 9 if you know that c is more then one function for turning non-deterministic computation? (Henceforth known as an actual formula search angine..
06:06:50 <svend>  /join #netbsd
06:07:10 <CosmicRay> svend: no thanks, I tried that last year :-)
06:07:19 <CosmicRay> shapr: how 'bout you?
06:07:30 <CosmicRay> shapr: warm enough for unicycling? :-)
06:07:50 <wli> doing multiplication
06:08:03 <svend> whitespace is significant :)
06:08:12 <CosmicRay> <grin>
06:08:38 * Lemmih_ is wondering if he should work, play or unicycle.
06:08:46 * CosmicRay used to enjoy bicycling, but now would have to load up his bicycle in a car and take it to some place where he could ride safely.
06:09:26 <CosmicRay> Lemmih: My opinion, being only a few thousand miles away from you and having met you only via IRC, is that you should play. :-)
06:09:57 <Matt-W> People should always play
06:10:01 <Matt-W> Except when they're unicycling
06:10:09 <Matt-W> At which time they should juggle
06:11:42 <CosmicRay> heh
06:11:57 <CosmicRay> MegaMonad: should Lemmih work, play, or unicycle?
06:12:03 <MegaMonad> CosmicRay: My unicycle is great, i can't seem to be a work of the play.
06:12:09 <CosmicRay> hmm.
06:12:15 <CosmicRay> well he did get all three keywords in there.
06:12:29 <Matt-W> could be worse
06:13:22 <shapr> CosmicRay: have you read Martin Fowler's "Analysis Patterns"?
06:15:02 <CosmicRay> nope
06:15:06 <CosmicRay> is that a book or a paper?
06:15:26 <wli> btw
06:15:34 <wli> I never figured out how you actually use these things
06:15:43 <xerox> hi
06:16:08 <boegel> haai
06:16:21 <shapr> wli: which things?
06:16:44 <musasabi> wli: I am using them as a base for encoding a nonstandard model of number theory..
06:16:52 <shapr> wow, nifty 'Why Cooperation With RMS Is Impossible, Death Metal Remix' - http://jwz.livejournal.com/247973.html
06:17:00 <musasabi> but then again that might be too complex.
06:17:18 * CosmicRay isn't surprised hearing that from jwz
06:17:29 <CosmicRay> shapr: I think he's the one that originally forked emacs, fwiw
06:17:47 <shapr> sort of, yes
06:18:11 <shapr> In fact, JWZ worked for Lucid, and the whole company really wanted to get their patches into the emacs mainline.
06:18:16 <CosmicRay> right
06:18:38 <shapr> And RMS put 'em off till the patches were stupendously large, and then he decided against going through a huge amount of patches and applying them himself.
06:18:45 <wli> musasabi: refresh
06:18:48 <shapr> so they forked
06:18:49 <CosmicRay> otoh, there is some truth in the idea that collaboration with rms is difficult
06:19:06 <shapr> yes, I agree. I've been cc'ed on an email from RMS.
06:19:07 <wli> musasabi: multiplication done
06:20:32 <shapr> cheesy? - http://www.scannedinavian.org/~shae/ProtoPlanning.hs
06:20:47 * shapr wishes Darius were around.
06:22:38 <musasabi> wli: thanks, that looks very nice.
06:22:44 <shapr> konichiwa ikegami--san
06:23:02 <Matt-W> shapr: I had a look, but I got frightened off by all the Maybes
06:23:23 <Matt-W> Not that there's a better way to do it that I'm aware of
06:23:43 <shapr> that's really my question.
06:23:48 <wli> musasabi: exponentiation done
06:24:18 <Matt-W> hmm
06:24:21 <Matt-W> well I wouldn't call it cheesy
06:24:22 <wli> musasabi: I've done division and gcd before but it was really painful
06:24:27 <Matt-W> but I might want to experiment with record syntax
06:24:41 <shapr> I'm not sure that I've done a good job of porting these OOP patterns to FP.
06:25:14 <musasabi> I don't think I will need those.
06:25:21 <wli> musasabi: burning question
06:25:36 <wli> musasabi: how do I actually "call" the multiplication methods?
06:26:53 <musasabi> pmul :: MulNat a b c => a -> b -> c
06:26:54 <wli> *Nat> natToInteger (undefined :: ExpNat (Odd (Odd Zero)) (Even Zero) t => t)
06:26:54 <wli> 0
06:26:57 <wli> looks ilke a bug
06:27:00 <musasabi> pmul _ _ = undefined
06:27:09 <tuomov> that dm remix is hilarious
06:27:51 <musasabi> then e.g. define some base numbers and you can do stuff like pmul two ten 
06:29:07 <wli> Okay, there's work to do.
06:29:24 <wli> I can't have the tycons in the instance decls.
06:37:18 <wli> I get nontermination in trivial testcases.
06:51:56 <wli> hmm, getting termination out of this is hard
06:55:45 <bringert> CosmicRay: I'm looking at your GZip module
06:56:02 <CosmicRay> bringert: excellent
06:56:09 <wli> instance AddNat t Zero t
06:56:09 <wli> instance (AddNat (Odd Zero) n p, AddNat k k q, AddNat p q r) 
06:56:09 <wli>                 => AddNat n (Odd k) r
06:56:09 <wli> instance (AddNat (Even Zero) n p, AddNat k k q, AddNat p q r)
06:56:09 <wli>                 => AddNat n (Even k) r
06:56:11 <wli> this pukes
06:56:34 <wli> *Nat> :type (undefined :: AddNat Zero Zero t => t)
06:56:34 <wli> Cannot unify the type-signature variable `t' with the type `Zero'
06:56:42 <CosmicRay> bringert: it's rather slow right now.  I think that's due to the inflate that's used
06:56:52 <CosmicRay> bringert: but I do know that it at least works.
06:57:07 <bringert> CosmicRay: it seem to me that decompress :: String -> (String, Maybe GZipError) might be better off as decompress :: FilePath -> Either String GZipError
06:57:39 <bringert> am I missing somrthing?
06:57:49 <CosmicRay> can't do that...  the problem is, we can't determine certain errors until the entire file has been read
06:57:52 * Igloo suggests putting the answer in a comment/haddock doc  :-)
06:57:53 <CosmicRay> crc-32 errors, specifically.
06:57:59 <CosmicRay> Igloo: yes, I should.
06:58:22 <CosmicRay> bringert: so retirning Either String GZipError would force reading and buffering the entire decompressed stream in memory
06:58:49 <bringert> hmm, nasty
06:59:18 <bringert> but you say in the docs to look at the Maybe GZipError before doing anything
06:59:23 <bringert> won't that also force reading?
07:00:02 * CosmicRay checks
07:01:27 <CosmicRay> bringert: I'm not finding that...  I found where I said that one should process the entire stream from decompress first....
07:01:48 <CosmicRay> (and it needs to be updated to refer to the GZipError instead of bool...)
07:02:04 <bringert> "If you get anything other than Nothing, the String returned should be discarded. "
07:02:16 <bringert> that's from the haddock at http://gopher.quux.org:70/devel/missingh/html/MissingH.FileArchive.GZip.html
07:03:04 <bringert> ah, ok, I see the comment at the top of the page now
07:04:52 <bringert> there's gotta be a prettier way to do that
07:05:01 <bringert> not that I can think of one right now
07:05:09 <CosmicRay> bringert: I had the exact same thought.
07:06:44 <wli> well, I can' tquite pull it off
07:07:24 <CosmicRay> bringert: it would also be interesting to have an ffi binding to zlib
07:07:25 <wli> class NatEq t t' | t -> t'
07:07:25 <wli> instance NatEq Zero Zero
07:07:25 <wli> instance (NatEq t t') => NatEq (Even t) (Even t')
07:07:25 <wli> instance (NatEq t t') => NatEq (Odd t) (Odd t')
07:07:42 <wli> *Nat> :type undefined :: NatEq Zero t => t
07:07:42 <wli> Cannot unify the type-signature variable `t' with the type `Zero'
07:08:41 <bringert> CosmicRay: there is one in darcs, right?
07:09:46 <CosmicRay> bringert: hmm.  I do recall hearing of that.
07:11:27 <wli> something odd is going on
07:11:35 <shapr> it's me!
07:11:40 <CosmicRay> ah ha.
07:11:47 <bringert> I would like a haskell version to embed in a tool, don't want to require any C libs
07:11:47 <CosmicRay> we always knew shapr wasn't even.
07:11:52 * shapr grins
07:11:56 <shapr> CosmicRay: beat me to the joke :-)
07:12:14 <shapr> bringert: .hc dumping?
07:12:32 <bringert> shapr: ?
07:12:37 <wli> if anyone's got x86-64 hc files they'd be much appreciated
07:12:51 <shapr> hiya tintin 
07:12:57 <tintin> hello shapr
07:12:59 <shapr> bringert: dons suggested that for darcs.
07:13:14 <CosmicRay> wli: I could get you those.
07:13:16 <bringert> for doing what?
07:13:20 <wli> thanks
07:13:22 <tintin> ok i have some trouble with a very very simple haskell program 
07:13:23 * bringert feels slow today?
07:13:30 <shapr> dons said you could dump the .hc files for darcs and then it would only require gcc to build darcs.
07:13:42 <bringert> ah, my problem was the opposite
07:13:44 <shapr> right now, .hc files are only used for porting, but they could do more.
07:13:45 <tintin> is there a pastebin for haskell ?
07:13:50 <CosmicRay> shapr: I don't think it's that easy.
07:13:51 <shapr> @wiki HaskellIrcPastePage
07:13:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:13:54 <bringert> I want to require only ghc, no C libraries
07:13:59 <shapr> ohh
07:14:03 <tintin> ah tnx 
07:14:09 <CosmicRay> shapr: I think those could reasonably differ on different platforms
07:14:25 <shapr> CosmicRay: oh sure, but I was talking about just some way to not require GHC
07:14:47 <CosmicRay> wli: would it be useful if I built you a statically-linked ghc?
07:15:05 <wli> CosmicRay: dear gawd yes
07:15:12 <wli> CosmicRay: preferably tarball/rpm
07:15:14 <CosmicRay> let's see if I can figure out how to do that then.
07:15:46 <shapr> bringert: even with 6.4 and the C-- backend, won't you require a C-- compiler?
07:16:50 <bringert> oh, I'm not that picky, all I mean is that the user should only need to have ghc and its dependencies, not extra stuff should be neccessary to compile GF
07:17:10 <CosmicRay> wli: ok, well let me first see if I can get you the .hc files, then I'll try to do that 
07:17:46 <Igloo> GF?
07:18:00 <shapr> GirlFriend!
07:18:05 <CosmicRay> Igloo: oh, glad to see ya.  if I dpkg-buildpackage ghc6, it should leave around the .hc files, right?
07:18:17 <shapr> GirlFriend is the Haskell accessory that every geek requires!
07:18:22 <bringert> yeah, girlfriends sure shouldn't require zlib
07:18:29 * shapr snickers
07:18:30 <Igloo> Err, I don't think so
07:18:38 <CosmicRay> bringert: unzlib maybe... :-)
07:18:42 <wli> Igloo: boo
07:18:43 * shapr laughs
07:19:09 <wli> Igloo: sparc64 issues...
07:19:34 <wli> Igloo: you did the debian stuff right?
07:19:38 <Igloo> GhcLibHcOpts = -O -H32m -keep-hc-files
07:19:40 <Igloo> GhcStage2HcOpts = -O -fvia-C -keep-hc-files
07:19:48 <Igloo> in mk/build.mk look relevant
07:19:50 <Igloo> Right
07:20:01 <bringert> Igloo: GF = Grammatical Framework http://www.cs.chalmers.se/~aarne/GF/
07:20:08 <wli> Igloo: obviously all of this is failing horrendously or I'd have long-since done it.
07:20:16 <Igloo> I'm not sure what "./configure --enable-hc-boot --enable-hc-boot-unregisterised" does, but you might need that too
07:20:27 <CosmicRay> Igloo: wli is trying to port ghc to amd64 suse
07:20:37 <Igloo> In fact, I think this might be described on the porting page
07:20:39 <CosmicRay> Igloo: ghc is working great on amd64 debian
07:20:40 <wli> well, not "port" so much as get something I can run
07:21:00 <CosmicRay> Igloo: yes, it is.  I've done that for aix, even.  I thought I could perhaps get something real quick otherwise.
07:21:07 <CosmicRay> no such luck I guess.
07:21:13 <CosmicRay> no prob, though.
07:21:35 <Igloo> I don't mean the different arch porting page
07:22:27 <urtie> it is described on the porting page
07:22:40 <Igloo> Ah, no, it doesn't tell you how to make the HC files
07:22:45 <urtie> yes, it does
07:22:52 <urtie> you need a running ghc to do so however
07:22:59 <urtie> (see 10.2.1)
07:23:18 <Igloo> Well, only going via unregisterised. Well, I guess it only work unregisterised anyway, actually
07:23:32 <wli> I've already gone through quite a bit of trouble trying various things. I think it's down to either doing some kind of major porting effort, relying on someone else to get enough to run with, or waiting for months/years for someone to get around to shipping an rpm.
07:23:38 <CosmicRay> right, according to my read of debian/rules, it's only registerized in i386 and sparc
07:24:08 <CosmicRay> wli: or you could just install a debian chroot... :-)
07:24:19 <wli> CosmicRay: -ENOSPC
07:24:25 <CosmicRay> really?
07:24:25 <wli> Igloo: speaking of sparc
07:24:32 <CosmicRay> wli: it should use <200MB
07:24:35 <wli> Igloo: why is ghci coring on sparc64?
07:25:00 <Igloo> It doesn't look like you'll be able to take any shortcuts from the cross-arch porting even though there is already an amd64 binary if that binary doesn't already work for you
07:25:05 <Igloo> No idea
07:25:20 <Igloo> Wasn't it amd64 the bug report was about?
07:25:20 <wli> Igloo: want to take a closer look?
07:25:24 <Igloo> OAIC?
07:25:25 <CosmicRay> Igloo: apparently wli is having some library versioning trouble with the debian binary
07:25:28 <wli> Igloo: no
07:25:37 <wli> Igloo: there are multiple things happening at once
07:25:38 <CosmicRay> Igloo: no, amd64 is fine (except for ghci, but anyway.)
07:25:43 * Igloo doesn't have time to look this side of xmas, sorry
07:25:49 <wli> figures
07:26:19 <tintin> shapr: does the haskell mode in emacs take care of the whitespaces that are essential in Haskell ?
07:26:28 <wli> Igloo: have you ever heard a success report with the sparc64 ghci?
07:26:31 <bringert> speaking of christmas, is ghc 6.4 coming soon?
07:26:43 <CosmicRay> wli:
07:26:52 <CosmicRay> $ ldd /usr/lib/ghc-6.2.2/ghc-6.2.2
07:26:53 <CosmicRay>         libreadline.so.4 => /lib/libreadline.so.4 (0x0000002a9566c000)
07:26:53 <CosmicRay>         libncurses.so.5 => /root32/usr/lib/libncurses.so.5 (0x0000002a957a5000)
07:26:53 <CosmicRay>         libdl.so.2 => /lib/libdl.so.2 (0x0000002a958fd000)
07:26:53 <CosmicRay>         libm.so.6 => /lib/libm.so.6 (0x0000002a95a00000)
07:26:53 <CosmicRay>         libgmp.so.3 => /usr/lib/libgmp.so.3 (0x0000002a95b87000)
07:26:55 <CosmicRay>         libc.so.6 => /lib/libc.so.6 (0x0000002a95cbc000)
07:26:57 <CosmicRay>         /lib64/ld-linux-x86-64.so.2 => /lib64/ld-linux-x86-64.so.2 (0x0000002a95556000)
07:26:57 <Igloo> Hang on, there isn't a sparc64 ghci in Debian is there?
07:26:59 <CosmicRay> (sorry for the flood)
07:27:07 <Igloo> Aren't you talking about a sparc ghci on a sparc64?
07:27:08 <wli> Igloo: it's 32-bit
07:27:24 <wli> Igloo: 99.9999% of sparc64 userspace is 32-bit
07:27:28 <Igloo> Unless vore is sparc64 I haven't, anyway
07:27:39 <Igloo> And I'm not 100% sure even then, but I can check
07:27:47 <wli> Igloo: can you get at sparc64 boxen?
07:27:58 <Igloo> Only if vore is one
07:28:00 <urtie> um
07:28:06 * urtie coughs
07:28:10 <shapr> tintin: mostly, yeah
07:28:12 <urtie> that solaris machine was sparc64
07:28:23 <wli> vore% uname -a 
07:28:23 <wli> Linux vore 2.4.26 #1 SMP Tue Apr 20 14:16:21 EDT 2004 sparc64 unknown unknown GNU/Linux
07:28:53 <CosmicRay> wli: how do you have an account on a debian boxen?
07:29:10 <wli> how do you think I got one? dd as usual
07:29:15 <wli> I'm even an ex-hugs-maintainer
07:29:17 * CosmicRay suddenly realizes who wli is irl
07:29:22 <Igloo> igloo@vore:~$ ghci
07:29:23 <Igloo> [...]
07:29:26 <Igloo> Loading package base ... linking ... done.
07:29:27 <Igloo> Prelude> 
07:29:46 <wli> Igloo: looks like it runs on woody, explodes on sid
07:30:00 <CosmicRay> wli: did I meet you at a LinuxExpo once?
07:30:00 <Igloo> This is in the unstable dchroot, although it's not the latest version
07:30:09 <wli> CosmicRay: never been to a linuxexpo
07:30:30 <wli> Igloo: if you want to log into a box where it fails, that can be arranged
07:30:49 <Igloo> It was just starting it that segfaulted, right?
07:30:53 <wli> Igloo: yes
07:31:22 <wli> Igloo: well, if I set up the acct I know you can see it, then you can go about doing whatever you're going to do at your leisure
07:31:42 <wli> Igloo: and besides, the box is s**tloads faster than vore
07:31:48 <Igloo> :-)
07:32:00 <wli> ncpus active    : 6
07:32:00 <wli> Cpu6Bogo        : 667.64
07:32:02 <CosmicRay> wli: stop it, you're taking igloo away from writing deflate :-)
07:32:04 <Igloo> I'm sure it isn't normally quite as slow as it is now
07:32:35 <Igloo> Ah, but writing deflate is something it might be feasible for me to look at over xmas  :-)
07:32:40 <wli> Igloo: send login/pw info to wli@holomorphy.com and it'll be there for as long as you want it to be, I'll reply with details (box behind NAT)
07:32:42 <Igloo> Depending on how much free time I get
07:32:47 <CosmicRay> <grin>
07:33:20 <wli> Igloo: I should be in the debian keyring but if not finger wli@holomorphy.com will fetch the gpg key (please encrypt the login/pw stuff)
07:34:21 <wli> CosmicRay: I go to OLS every year
07:34:27 <wli> CosmicRay: (and KS)
07:34:45 <urtie> OLS... that's a little something that was on my list once but that I never made
07:34:45 <wli> CosmicRay: might have seen me at USENIX in '00 or some other random places
07:34:51 <CosmicRay> wli: were you at ALS ever?
07:34:56 <wli> CosmicRay: no
07:34:59 <CosmicRay> hmmph.
07:35:04 <wli> CosmicRay: I've been to SCALE once
07:35:04 <CosmicRay> guess I've never met you then
07:35:10 <Igloo> wli: KeyID?
07:35:12 * CosmicRay doesn't get to many conferences
07:35:13 <tintin> whats the basic idea behind whitespaces having meaning in Haskell ?
07:35:43 <tintin> dosnt that lead to errors at times ?
07:35:54 <tuomov> not if you don't you use tabs
07:35:58 <CosmicRay> tintin: it can, but they're usually easy to spot
07:36:05 <CosmicRay> tintin: python uses the same approach to great success
07:36:10 <CosmicRay> tintin: also, not that it's optional
07:36:18 <CosmicRay> tintin: you can instead use braces and semicolons as you woul din c
07:36:26 <tintin> really ? 
07:36:32 <wli> Igloo: no time limits, it'll be there after xmas
07:36:38 <CosmicRay> yes, but it's uglier
07:37:00 <tintin> so i just put up semicolon at the end of the lines and functions ?
07:37:11 <tintin> curly braces ?
07:38:20 <CosmicRay> tintin: one of the haskell tutorials has some examples, but I forget which
07:38:28 <CosmicRay> tintin: try a few of the links from haskell.org
07:38:39 <svend> I'm near the end of a ghc port, gcc is building the compiler (stage1/ghc-6.2.2) and I am getting a Signals.o(.text+0xb4c): undefined reference to `ieee_set_fp_control' error.
07:38:55 <tintin> i was untill i got derailed by one of those whitespace mistakes :(
07:39:43 <tintin> what am i supposed to use in the emacs haskell mode instead of tabs ? just a single space ?
07:39:48 * Igloo wonders what "No (valid) certificate found for wli@holomorphy.com" means
07:40:05 <wli> no idea
07:40:10 <wli> I've been signed by a few ppl
07:40:18 <tuomov> configure emacs to indent with spaces instead of tabs
07:40:21 <tuomov> tabs are evil
07:40:39 <wli> e.g. Russell King, Matthew Wilcox, Vojtech Pavlik, etc.
07:41:05 <Igloo> I've made you ultimately trusted and it still says it
07:41:10 <tintin> wli:running open ssl ?
07:41:23 <wli> tintin: eh?
07:41:42 <wli> well, I have openssl
07:42:02 <tintin> webpages with openssl throw that error to users iirc ...
07:42:08 <tintin> or warning 
07:42:41 <wli> tintin: nope, I pretty much avoid fancy webstuff like the plague in favor of static content and minimal infrastructure
07:43:57 <Igloo> Oh, I think I've asked it to do S/MIME instead of PGP
07:45:20 <Igloo> Right, there we go
07:45:35 <boegel> does anyone know how I can change the style in which enumerate prints the numbers of a list in LaTeX ?
07:45:49 <tintin> do module names need to being with capital letters ?
07:45:50 <boegel> it's hard to find this stuff in manuals, because they're quite basic most of the time
07:46:10 <Igloo> You have ot change labelnumi or similar, IIRC
07:46:23 <boegel> Igloo ?
07:46:32 <Igloo> Try a google.groups search of comp.text.tex
07:46:42 <Igloo> tintin: Yes
07:48:24 <wli> igloo: okay, it's behind a NAT, so step 1 ssh holomorphy.com, step 2 ssh analyticity
07:48:54 <wli> (it will likely become analyticity.holomorphy.com in the near future)
07:49:00 <wli> (as visible to the open net that is)
08:22:11 <Lemmih_> Time to unicycle!
08:22:17 <shapr> yay!
08:25:08 * tuomov is trying to do some Ion coding after a long pause and immediately starts missing a proper type system
08:25:48 * Lemmih_ converted from Gnome to Ion yesterday and is pretty happy so far.
08:31:18 <CosmicRay> @index setNonBlockingFD
08:31:19 <lambdabot> bzzt
08:42:15 <CosmicRay> @index MutableByteArray
08:42:16 <lambdabot> bzzt
08:42:27 <CosmicRay> @index MutableByteArray#
08:42:28 <lambdabot> bzzt
08:42:34 <CosmicRay> does "#" have any significance to haskell?
08:43:38 <Igloo> It conventionally means unboxed in GHC's names
08:48:36 <Igloo> (in Haskell 98 the above would be parsed as the two lexemes MutableByteArray, a constructor, and #, an operator)
08:49:29 <CosmicRay> hm.
08:50:57 <CosmicRay> wli: I have some .hc files for you.
08:51:06 <CosmicRay> wli: would you like the .hc files only, or the entire built tree?
08:52:00 <wli> CosmicRay: might as well do the whole tree
08:52:07 <CosmicRay> ok.  let me tar it up.
08:52:32 <CosmicRay> this is 6.2.2
08:56:16 <CosmicRay> this will take some time to upload.
08:56:34 <CosmicRay> it unpacks to 1.4GB
08:56:54 <wli> whoa
08:57:03 <CosmicRay> hmm.  I could trim that to 0.9GB if I exclude the installed binaries in debian/
08:57:39 * CosmicRay does that
09:01:54 <CosmicRay> -rw-r--r--  1 jgoerzen jgoerzen 126M Dec 17 10:59 ghc-amd64.tar.bz2
09:03:11 <CosmicRay> this will take some time to upload.
09:03:30 <CosmicRay> probably 1-2 hours.
09:04:48 <CosmicRay> foo, and my server is having connectivity issues at the moment too.
09:06:07 <CosmicRay> wli: I will give you a URL once I've got it uploaded
09:06:46 <CosmicRay> eta 1h30m
09:20:04 <wli> 12 hrs for a ghc pkg build on my e3k
09:20:52 <CosmicRay> heh
09:25:17 <svend> Does DsMeta.hc get compiled when you are build the hc files on the host?
09:37:54 <CosmicRay> dammit.  5 hours before the weekend starts.
09:38:06 <CosmicRay> you europeans always get your weekend started sooner :-)
09:41:52 <Muad_Dibber> well
09:41:55 <Muad_Dibber> we are also earlier back to work again :'(
09:42:27 * Igloo would be quite glad of an extra 5 hours right now
09:48:22 <CosmicRay> heh
09:49:21 * Darius wishes Control.Concurrent exported a CAS function.
09:49:59 <Darius> Though what would that use? IORefs? Ptrs?
09:50:48 <CosmicRay> MegaMonad: bzzt
09:50:53 <MegaMonad> CosmicRay: The short answer is, read the gentle intro is short for "bzzt, thank you all once one returns.
09:51:01 <CosmicRay> heh
09:51:36 <CosmicRay> MegaMonad: I'm bored.
09:51:42 <MegaMonad> CosmicRay: Ah, but you're probably all bored and playing with dependent types, you can't dictate what licences other people tell you what you're working on?
09:51:54 <CosmicRay> heh
09:52:12 <CosmicRay> MegaMonad: I think you should port SimCity to Haskell.
09:52:18 <MegaMonad> CosmicRay: Bit i is a port of the obligation to remember that it's not playing simcity.
10:43:19 <wli> CosmicRay: any news?
10:44:49 <wli> CosmicRay: any news?
10:44:55 <wli> woops
11:10:53 <vincenz> "evaluation commutes with erasure"
11:10:55 <vincenz> kewl
11:11:08 <basti_> whats erasure?
11:11:42 <vincenz> removing the type of a term
11:11:59 <basti_> how would i imagine that?
11:12:04 <vincenz> ..
11:12:09 <basti_> i mean...
11:12:19 <basti_> lets say we do (bla a b c)
11:12:41 <basti_> and the type of bla is A->A->A->[A]
11:12:56 <basti_> how can I "remove" that type? or that of any subterm?
11:12:57 <vincenz> nono
11:13:01 <vincenz> the term is
11:13:22 <vincenz> nm
11:13:26 <vincenz> it's not something related to haskell
11:13:31 <basti_> oh okay.
11:13:42 <vincenz> BEsides
11:13:45 * vincenz doesn't know haskell
11:13:48 <vincenz> though I should prolly learn it
11:13:53 <basti_> oh i see.
11:13:54 <vincenz> as I'm making my own functional language
11:13:54 <shapr> vincenz: yes!
11:13:56 <vincenz> pure
11:14:00 <basti_> pure?
11:14:05 <basti_> how do you do i o?
11:14:08 <vincenz> like haskelll..
11:14:15 <shapr> I like haskell.
11:14:26 <vincenz> basti_: haskell is a pure functional language
11:14:29 <vincenz> I'm going to make another one
11:14:39 <basti_> hmm okay.
11:14:43 <basti_> why?
11:14:49 <vincenz> for my own purposes
11:14:55 <basti_> like?
11:14:58 * basti_ got curious now
11:14:59 <vincenz> my research
11:15:03 <wli> the amount of theory that's gonen into haskell's type system is a bit more than I can handle
11:15:15 <vincenz> wli: I already have the typing rules for my language
11:15:16 <basti_> what is your research?
11:15:19 <vincenz> ...
11:15:32 <arjanb> why making a new functional language while not knowing the existing ones?
11:15:33 <basti_> so how does it type?
11:15:40 <vincenz> arjanb: because I have certain requirements
11:15:45 <vincenz> arjanb: and I know ocaml
11:15:50 <wli> hmm
11:15:56 <vincenz> but I need to map certain idioms ot a language
11:16:00 <vincenz> which I would like to optimize
11:16:03 <vincenz> and if it interests you
11:16:07 <vincenz> it'll be built on top of c++ templates
11:16:12 <vincenz> so
11:16:18 * CosmicRay returns
11:16:24 <CosmicRay> wli: your upload is done.
11:16:32 <CosmicRay> wli: http://www.complete.org/~jgoerzen/t/ghc-amd64.tar.bz2
11:16:32 <basti_> i see
11:16:35 <vincenz> I'm considering making it pure as I assume that pure functional languages are easier to optimize
11:16:40 <CosmicRay> wli: please notify me when you have pulled it down
11:17:09 <vincenz> and my function types only allow
11:17:10 <shapr> probably pure eager languages.
11:17:12 <vincenz> I->T
11:17:18 <vincenz> where I is of type integral
11:17:21 <vincenz> and T is any allowed type
11:17:34 <basti_> integral as in number?
11:17:41 <vincenz> integral as in whole number
11:17:48 <basti_> i see
11:18:01 <Darius> shapr: Pure eager languages are asymptotically slower than pure lazy (call-by-need) languages given a few restrictions.
11:18:01 <vincenz> except that I'm stuck with a problem
11:18:06 <basti_> some sort of forced primitive/recursive?
11:18:33 <basti_> and what do you do with your T's when your function only understand I's?
11:18:41 <vincenz> I didn't say that
11:18:48 <basti_> i thought you did
11:18:49 <vincenz> I'm saying functions only accept I's
11:18:57 <vincenz> but internally it can use more types
11:19:05 <basti_> hmm
11:19:28 <basti_> whats your plan?
11:19:35 <basti_> i mean, what are you about to understand/research?
11:19:55 <vincenz> ..
11:19:58 <vincenz> Anyways
11:20:03 <vincenz> want to know something annoying?
11:20:17 <basti_> tell me =)
11:20:17 <vincenz> the c++ standard defines typing ambiguities
11:20:31 <basti_> if it would be only that.
11:20:34 <vincenz> meaning that no compiler will ever be able to fully typecheck a program at compile time
11:21:02 <shapr> Darius: yah, I agree, but as for easy of optimization...
11:21:02 <vincenz> basti_: ?
11:21:15 <basti_> C and C++ are pretty flawed i think
11:21:26 <vincenz> depends on your needs
11:21:26 <shapr> vincenz: so, why not use a better typesystem?
11:21:29 <basti_> there are some points where you just think "this CAN'T be the way of choice"
11:21:30 <vincenz> every language is a tool
11:21:34 <basti_> of course
11:21:41 <vincenz> shapr: I need to be compatible with c++ (within certain restrictions)
11:21:44 <basti_> C is suited best for LowLevel Programming... as in driver.
11:21:46 <shapr> why?
11:22:06 <vincenz> because I basically transform c++ code to my language which I then embed in the C++ with the help of templates
11:22:07 <basti_> but for general application development its a pain in the butt
11:22:13 <vincenz> so I don't want to alter the behaviour by changing the typing
11:22:17 <basti_> hmm
11:22:23 <vincenz> templates are great
11:22:29 <basti_> yes of course
11:22:31 <basti_> dependant types
11:22:33 * vincenz build a functor-curryer with templates
11:22:42 <vincenz> s/build/built
11:22:56 <basti_> >.<
11:23:07 <vincenz> curried<AnyFunctor> -> curried functor
11:23:24 <vincenz> well
11:23:32 <vincenz> curried<AnyFunctor>(x /* of type AnyFunctor */) -> curried functor
11:23:41 <wli> I'd be interested in trying to add more static typing to an imperative C-like language (no GC, first-order functions only) via type theory shenanigans but I'm not good enough at type theory to do anything useful to that effect.
11:23:53 <vincenz> what is shenanigans?
11:24:05 <basti_> yes that would be fun i think.
11:24:20 <shapr> wli: Types and Programming Languages is a great book.
11:24:23 <shapr> "The Brick Book"
11:24:25 * vincenz is reading it right now
11:24:28 <vincenz> :)
11:24:36 <wli> basti: well, I don't think it's fun so much as "desperately needed"
11:24:48 <vincenz> wli: c-like?
11:24:49 <basti_> ;)
11:25:29 <ibid> wli: have you looked at cyclone?
11:25:53 <ibid> it doesn't fulfill your criteria but it could probably be stripped down to what you want
11:25:53 <vincenz> plus c is not completely first-order
11:26:16 <vincenz> (int (*)(int)) x(int)
11:26:19 <wli> ibid: yes, Cyclone seems to be a superset in some respects
11:26:42 <vincenz> and if you just stick to c++ and throw out a few possibilities, you'd get thee
11:26:45 <vincenz> ..there.
11:26:49 <wli> nope
11:26:52 <vincenz> (basically restrict certain stuff)
11:27:07 <wli> most of the "trouble" is trying to get the code analyzable
11:27:13 <vincenz> heh
11:27:19 <vincenz> you;re telling me
11:27:21 <wli> which is where the type system shenanigans come in
11:27:25 * vincenz has to parse c++ and transform it :/
11:27:28 <vincenz> what are shenanigans?
11:27:35 <shapr> vincenz: why do you have to do that?
11:27:39 <vincenz> for my research
11:27:40 <shapr> @wn shenanigan
11:27:48 <Darius> vincenz: Have you seen Fog then?
11:27:50 <lambdabot> *** "shenanigan" wn "WordNet (r) 2.0"
11:27:50 <lambdabot> shenanigan
11:27:50 <lambdabot>      n 1: reckless or malicious behavior that causes discomfort or
11:27:50 <lambdabot>           annoyance in others [syn: {mischief}, {mischief-making},
11:27:50 <lambdabot>            {mischievousness}, {deviltry}, {devilry}, {devilment},
11:27:51 <vincenz> source-to-source transfos
11:27:52 <lambdabot>           {rascality}, {roguery}, {roguishness}]
11:27:54 <lambdabot>      2: the use of tricks to deceive someone (usually to extract
11:27:56 <lambdabot>         money from them) [syn: {trickery}, {chicanery}, {chicane},
11:28:01 <shapr> I like Knit.
11:28:03 <wli> vincenz: sense 2
11:28:16 <vincenz> Darius: I have not, I'm looking at codeboost and am actually going there to talk about possible changes
11:29:09 <vincenz> (due to some of the problems I brought up they've decided to change their system, which serves me well :) )
11:29:17 <CosmicRay> wli: dod you see that url
11:29:22 <CosmicRay> wli: for your hc files
11:29:24 <wli> CosmicRay: No
11:29:36 <CosmicRay> <CosmicRay> wli: your upload is done.
11:29:36 <CosmicRay> <CosmicRay> wli: http://www.complete.org/~jgoerzen/t/ghc-amd64.tar.bz2
11:29:39 <CosmicRay> <CosmicRay> wli: please notify me when you have pulled it down
11:29:46 <wli> okay
11:29:57 <CosmicRay> enjoy :-)
11:31:03 <Darius> vincenz:  Why do you need to parse C++ if codeboost (presumably) already does?
11:31:23 <vincenz> well *cough*
11:31:59 <vincenz> a: codeboost still has some holes, b: they're going to have to rewrite their parser, c: that'll give me an AST which I'll have to work on, ok maybe parse was the wrong word
11:33:25 <vincenz> anyways codeboost doesn't do the actual parsing
11:33:37 <vincenz> it does some semanalysis and changes the parse-tree it gets from openc++ to an AST
11:33:56 <CosmicRay> also, wli, I have your statically-linked ghc.
11:33:56 <vincenz> but they're rethinking their AST and might move to another parser (hopefully transformers from epita which is really celan)
11:34:00 <vincenz> clean
11:34:28 <wli> the notion I've got is not to extend anything but to restrict things more so concurrency/etc. can be automatically analyzed for correctness with more ease. A lot of that is ripping things out. I'm not actually sure how much a type system helps.
11:34:48 <wli> some of the macro crap makes things difficult/impossible
11:35:26 <vincenz> I know
11:35:29 <vincenz> I didn't say extend
11:35:31 <vincenz> I said restrict
11:35:34 <CosmicRay> wli: are you still interested in the statically-linked ghc?
11:35:43 <wli> CosmicRay: I'm in the middle of downloading it
11:35:52 <wli> CosmicRay: ETA is something like 19 minutes
11:35:53 <CosmicRay> wli: no, you're downloading the .hc files
11:36:01 <CosmicRay> wli: I built you a statically-linked binary separately
11:36:09 <wli> CosmicRay: yes, I'm interested in the statically-linked ghc also
11:36:15 <CosmicRay> ok, let me upload it
11:36:31 <CosmicRay> you can un-bzip2 it and then place it in ghc/compiler/stage2
11:36:40 <CosmicRay> then adjust the path in ghc/compiler/stage2/ghc-inplace
11:36:54 <CosmicRay> and then ghc-inplace should be a working option for you to bootstrap ghc on your own
11:37:08 <wli> CosmicRay: sounds great
11:37:37 <CosmicRay> eta on upload is 5 mins
11:38:37 <vincenz> Anyways, back to the issue with c++
11:39:05 <vincenz> all binary operators apply "usual arithmetic promotions" which if you look at it has one rule that is data-dependent
11:39:35 <vincenz> If one param is long int and the other is unsigned int then the result type is long int unless it wont fit in which case it becomes unsigned long int
11:40:00 <vincenz> some people..
11:40:14 <shapr> Youth! It's wasted on the young.
11:40:26 <CosmicRay> heh
11:41:06 <CosmicRay> wli: http://www.complete.org/~jgoerzen/t/ghc-6.2.2.bz2
11:43:40 <wli> CosmicRay: also in progress
11:43:57 <CosmicRay> wli: I'm curious how you fare with all this
11:44:01 <wli> me too
11:44:04 <CosmicRay> wli: so keep us updated :-)
11:45:10 <vincenz> shapr: you read TAPL completly?
11:45:25 <shapr> Not yet.
11:45:30 <vincenz> well notation wise
11:45:41 <vincenz> how do you say variables of type X are either of type a, b, c?
11:45:47 <vincenz> X = a|b|c?
11:46:02 <basti_> <X> = A+B+C i would say
11:46:05 <vincenz> hmm
11:46:08 <basti_> + being the disjunct union for some people
11:46:16 <vincenz> euhm..
11:46:24 <vincenz> basically
11:46:26 <basti_> as opposed to <X> = AxBxC which would be product
11:46:43 <vincenz> what's the < > ?
11:46:53 <basti_> like "the type of ..."
11:46:58 <vincenz> euhm no
11:47:02 <vincenz> basically
11:47:14 <vincenz> a %b is valid for a being short int, int, unsigned int, etc..
11:47:16 <vincenz> so can I say
11:47:24 <vincenz> I = short int | int | unsigned int
11:47:25 <vincenz> and then
11:47:32 <vincenz> a : I  b: I
11:47:34 <vincenz> ----------
11:47:36 <vincenz> a%b : I
11:47:46 <basti_> hm
11:48:00 <vincenz> basically my question is what the notation is for I
11:48:17 <basti_> lol when both are I?
11:48:18 <vincenz> (I in this case being "integral type"
11:49:08 <vincenz> basti_: well it's more complex
11:49:16 <vincenz> they get promoted to the minimal type that's  >= both
11:49:26 <vincenz> I guess I'll have to write it out fullhand
11:49:27 <vincenz> yick
11:49:33 <vincenz> just wished that lyx works on my pc
11:49:37 <basti_> aww.
11:49:44 <basti_> ever tried emacs +xsymbol?
11:49:56 <vincenz> let's rephrase your question
11:50:01 <vincenz> "ever tried emacs?" -> once
11:50:08 * vincenz waves his vim-flag
11:50:20 <CosmicRay> heh
11:50:21 * basti_ grins
11:50:25 <vincenz> either way
11:50:31 <CosmicRay> vincenz doesn't know what he's missing! :-)
11:50:33 <vincenz> I will have to define the integral type
11:50:38 <vincenz> for the good reason
11:50:40 <shapr> vincenz: try Yi!
11:50:50 <vincenz> that some operators are unary
11:50:52 <vincenz> so
11:50:55 <vincenz> I can't just do
11:50:59 <vincenz> a: T 
11:50:59 <vincenz> ---------
11:51:02 <vincenz> op a :T
11:51:07 <vincenz> cause it's only valid for integral types
11:51:12 <vincenz> unless you know some notation for that
11:51:16 <basti_> hum.
11:51:25 <vincenz> basically input and output are same
11:51:33 <vincenz> but only valid for certian types
11:51:48 <basti_> well then thats a restriction on the op
11:51:54 <vincenz> right
11:51:55 <basti_> it should go in the premise
11:52:00 <vincenz> which I'm writing in the typing system
11:52:06 <vincenz> a : T
11:52:08 <vincenz> -----
11:52:09 <vincenz> op a : T
11:52:17 <vincenz> when T elementof {....} 
11:52:17 <vincenz> ?
11:52:26 <vincenz> there's no shorthand?
11:52:47 <basti_> i'd write:   T <= [typeX], a: T  
11:52:48 <basti_> ----
11:52:52 <basti_> op a : T
11:52:59 <vincenz> have not seen that notation yet
11:53:03 * vincenz keeps reading Pierce
11:53:46 <wli> Pierce wasn't as informative as Mitchell for me, though it did cover some odds and ends Mitchell didn't.
11:53:56 <wli> OTOH Mitchell's a far larger text
11:54:03 * vincenz has pierce so..
11:57:19 <vincenz> hmm
11:57:51 <wli> CosmicRay: md5sums
11:58:11 <vincenz> I could force an order on the types
11:58:16 <vincenz> or at least partial order
11:58:16 <wli> 906c67cd7ef3cdfecbac60bc97c1ef65  ghc-6.2.2.bz2
11:58:23 <wli> 42ff9f83d2355a039c12848b11c72016  ghc-amd64.tar.bz2
11:58:33 <wli> CosmicRay: do those match?
11:58:40 <vincenz> wli: not smart
11:58:48 <vincenz> wli: you shoul've asked him to tell them to you
11:58:53 <vincenz> now he can just fake it and say yes
11:59:06 <wli> vincenz: assumption is good faith
11:59:12 <vincenz> :D
12:00:27 * CosmicRay checks
12:00:42 <CosmicRay> 42ff9f83d2355a039c12848b11c72016  ghc-amd64.tar.bz2
12:00:50 <CosmicRay> 906c67cd7ef3cdfecbac60bc97c1ef65  /tmp/ghc-6.2.2.bz2
12:00:52 <CosmicRay> yup, looks good.
12:00:56 <wli> spiffy
12:01:07 <wli> thanks
12:01:13 <CosmicRay> glad to help
12:03:45 * vincenz uses where clauses
12:03:47 <vincenz> f it
12:05:07 <wli> I guess another thing that would be useful (to me) would be a stack machine <-> assembly translator that uses the native stack for its stack
12:06:46 <vincenz> wli: what's so hard about that?
12:07:32 <wli> targeting multiple machines and emitting high-quality code for each, plus interoperability with programming languages that want to make use of the native processor stack (particularly in being called from them).
12:07:58 <wli> they're all back-end and runtime issues, not really language-level
12:09:28 <vincenz> it's just a matter of simple translation and knowing which register is the stack pointer and using the other registeres as much as possible
12:11:25 <evil_bunny> What docs do you recommand for a newbie on http://www.haskell.org/learning.html ?
12:11:53 <CosmicRay> evil_bunny: Yet Another Haskell Tutorial
12:11:57 <wli> vincenz: It appeared to involve ugly complications surrounding either saving/restoring the stack on entry and exit (assuming it's driven from above) and largely easy when not driven from above. And the rest is code quality.
12:12:14 <CosmicRay> evil_bunny: see also http://www.haskell.org/bookshelf/#tutorials
12:12:38 <vincenz> wli: oh you'll still have functions?
12:12:44 <vincenz> wli: just make a second stack with your data
12:12:54 <vincenz> instead of 'ab'using the system stack
12:13:15 <wli> vincenz: that's what the entire thign is trying to avoid, because the system stack is "magical" wrt. caching
12:13:27 <vincenz> no it's not
12:13:27 <wli> on certain cpus that is
12:13:32 <wli> (x86en)
12:13:33 <vincenz> like which ones?
12:13:37 <vincenz> o.O
12:13:41 <vincenz> I'd be surprised
12:13:46 <vincenz> stack is just like any other address
12:13:58 <vincenz> it's usually cached cause it's accessed often
12:14:12 <Darius> wli: Papers on Forth go the stack machine -> C (or directly to assembly) way and will maintain the stack in registers if certain constructs are avoided.
12:14:25 * vincenz would go to c as well
12:14:43 <Darius> (or on the stack)
12:14:45 <vincenz> then you can do what'sit'called'malloc
12:14:50 <vincenz> stackmalloc
12:14:56 <vincenz> that's not the name
12:15:01 <vincenz> but you get the idea
12:15:09 <vincenz> plus you'll have a wider platform support thnx to gcc
12:15:25 <wli> vincenz: there's some hardwiring of the stack to the cache on x86en, which is the whole rationale for the effort
12:15:47 <vincenz> what is x86 EN?
12:15:57 <vincenz> specifically the "en"
12:15:59 <CosmicRay> vincenz: I suspect short for "intel boxen"
12:16:04 <wli> vincenz: A faux German plural of "x86".
12:16:13 <vincenz> I was not aware of thate
12:16:17 <vincenz> ...that.
12:16:31 <vincenz> goes to show...
12:16:41 <vincenz> they always throw a shitload of crap into their procs
12:16:50 <vincenz> (I mean... p4 : 40 pipeline stages o.O 
12:17:01 <wli> "Box" is also a German word, the plural of the German "Box" is "Boxen", so things are pluralized in faux German with the suffix "-en".
12:17:09 <vincenz> in dutch too
12:17:28 <vincenz> well the "en" part
12:17:31 <CosmicRay> @jargon blinkenlights
12:17:33 <lambdabot> *** "blinkenlights" jargon "Jargon File (4.3.0, 30 APR 2001)"
12:17:33 <lambdabot> blinkenlights /blink'*n-li:tz/ n. [common] Front-panel diagnostic
12:17:33 <lambdabot>    lights on a computer, esp. a {dinosaur}. Now that dinosaurs are rare
12:17:34 <lambdabot>    this term usually refers to status lights on a modem, network hub, or
12:17:36 <lambdabot>    the like.
12:17:40 <lambdabot>    This term derives from the last word of the famous blackletter-Gothic
12:17:42 <lambdabot> [90 @more lines]
12:17:46 <CosmicRay> pfft
12:17:49 <CosmicRay> show us the 90 lines
12:17:55 <CosmicRay> http://gopher.quux.org:70/pygfarm/dict.pyg|/jargon/DEFINITION/blinkenlights
12:18:04 <vincenz> @eval (x.x x) (x.x x)
12:18:05 <lambdabot> unbound variable: x
12:18:05 <CosmicRay> try that out for some faux german.
12:18:11 <vincenz> @eval (l x.x x) (l x.x x)
12:18:12 <lambdabot> unbound variable: l
12:18:15 <vincenz> what is the symbol for lambda?
12:18:26 <vincenz> @eval (lambda x.x x) (lambda x.x x)
12:18:27 <lambdabot> unbound variable: lambda
12:18:55 <vincenz> @eval (L x.x x) (L x.x x)
12:18:55 <lambdabot> unbound variable: L
12:19:00 <vincenz> cwap
12:19:14 <CosmicRay> megamonad: blinkenlights?
12:19:19 <CosmicRay> oh crap.
12:20:30 <MegaMonad> G'day shapr. Yeah, i've looked through that...
12:20:33 <vincenz> well
12:20:36 <vincenz> 21:18
12:20:40 <vincenz> time to get the bus home from work
12:20:43 <TheHunter> @more
12:20:43 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
12:20:51 <vincenz> @shoot
12:20:51 <lambdabot> Sorry, I don't know the command "shoot", try "lambdabot: @listcommands"
12:20:54 <vincenz> @listcommands
12:20:55 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
12:20:55 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
12:20:55 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
12:20:55 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
12:20:55 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
12:20:55 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
12:20:57 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
12:20:59 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
12:21:00 * vincenz coughs
12:21:01 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
12:21:05 <vincenz> lambdabot: privmsg me this
12:21:10 <Darius> wli: You may want to look at the "Translating Forth to Efficient C" on this page http://www.complang.tuwien.ac.at/projects/rafts.html
12:21:21 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:21:22 <wli> @eval let cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs) in take 10 . filter (\(x,y)-> x `gcd` y == 1) $ cantor [[(i,j) | j <- [2..]]| i <- [2..]]
12:21:23 <lambdabot> (line 1, column 12):
12:21:25 <lambdabot> unexpected "="
12:21:27 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
12:21:29 <lambdabot>  "(", operator, simple term or end of input
12:21:45 <Darius> @definitions f
12:21:45 <lambdabot> ["fac","fact","factors","factorsOLD","failed","fibs","filter","first","fix
12:21:45 <lambdabot> ,"flip","foldTerm","foldl","foldl1","foldr","foldr1","followLinks","free
12:21:45 <lambdabot> ,"freevars","from","fromList","fromThen","fromThenTo","fromTo","fst"]
12:21:53 <Darius> @get-definition foldr
12:21:53 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
12:22:16 <Darius> @get-definition followLinks
12:22:17 <lambdabot> followLinks = foldTerm (\v.readLPRef v `bind` maybe (return (Var v)) followLinks
12:22:17 <lambdabot>  (\a ts.sequence ts `bind` \ts'.return (Term a ts'))
12:22:24 <Darius> ah yes
12:22:37 <Darius> @eval product (fromTo 1 10)
12:22:37 <lambdabot> 3628800
12:23:00 <vincenz> aha!
12:23:08 <wli> Darius: well, the entire idea is to exploit the stackhardwiring on Intel cpus, so generating C is pretty much useless
12:23:10 <vincenz> @eval (\x.x x) (\x.x x)
12:23:26 <vincenz> wli: not really, you can alloc on the stack
12:23:35 <lambdabot> out of fuel - use @resume to continue
12:23:49 <vincenz> with c
12:24:01 <vincenz> and you're sure it won't interfere with other crap on the stack
12:24:02 <Darius> wli: The C code utilizes the hardware stack, surely it's optimized for handling frames of data, not pushes and pops.
12:24:55 <vincenz> "alloca"
12:25:31 <wli> this of course completely defeats parsers' stack machines, which effectively want nothing more than pushing and popping
12:26:16 <wli> but yes, I'm aware of alloca
12:26:45 <vincenz> anyways
12:26:47 <vincenz> gotta run
12:26:55 <vincenz> want to catch the bus of 21:30 home
12:26:58 <vincenz> later!
12:29:00 <evil_bunny> 10x
12:30:02 * Darius shakes his fist at Nokia.
12:44:55 * CosmicRay shakes his fist at Java.
12:49:12 * Riastradh shakes his fist at the computing industry.
12:51:35 <CosmicRay> MegaMonad: shake your fist!
12:51:41 <MegaMonad> CosmicRay: Esap is referring to my windows to resize the damn printer should be the person here on my to do it a lot, so i have a fist to shake.
12:51:56 <CosmicRay> MegaMonad: you are quite verbose.
12:52:02 <MegaMonad> CosmicRay: Is a way to simulate the #haskell channel logs in http://citeseer.ist.psu.edu/ at least exists for extensial types ... But manage to change the way you can plumb state from me if i'm a bit verbose for doing this, or am i thinking of going to ask is "how do you want me to a specific version of the diff... In terms of darcs though.
12:53:46 <CosmicRay> MegaMonad: what language is most evil?
12:53:52 <MegaMonad> CosmicRay: Syntaxlaptop: i know he is evil evil evil.
12:54:07 <CosmicRay> megamonad, why do you say "evil evil evil" so much?
12:54:13 <MegaMonad> CosmicRay: Shapr: because of the -ddebug so there's no function to a third of their 'productive' time improving their skills. Because codemonkeys just aren't being explored because there's only one element of the evil that is me in the i ching.
12:54:31 <CosmicRay> MegaMonad: "me in the i ching"?
12:54:37 <MegaMonad> CosmicRay: You mean with java properly in the i ching, or on the difference is that you have a function is the region you want something like "before".
12:54:42 * CosmicRay wonders what a ching is
12:54:56 <CosmicRay> MegaMonad: I knew java would figure into this somehow.
12:55:02 <MegaMonad> CosmicRay: Jesse99, but not to be fully informed. My opinion is that somehow to the wrong channel to ask you, so i figure i have some c/perl/java/etc exp... Just recently discovered by um, a friend is called timber now.
12:55:22 <Asta> CosmicRay: http://en.wikipedia.org/wiki/Ching
12:55:34 <Asta> "Chings are small bowl-shaped finger cymbals of thick and heavy bronze, with a broad rim commonly used in in Cambodia and Thailand."
12:55:47 <CosmicRay> thanks, asta.
12:56:05 <Asta> np I was curious myself ;)
12:56:10 <CosmicRay> hehe
12:56:45 <tuomov> Also http://en.wikipedia.org/wiki/I_Ching
12:57:15 <Asta> MegaMonad: Should I use a State Monad Transformer in the IO Monad, or just IORefs as implicit parameters to simulate global variables?
12:57:20 <MegaMonad> Asta: The iorefs are the parameters on the monad.
13:00:03 <Asta> it would be nice if we had a MegaArrow to
13:00:19 <CosmicRay> heh
13:00:26 <Asta> then we could have both, MegaMonad and MegaArrow chatting
13:01:27 <musasabi> But MegaArrow needs to be mightier.
13:01:28 <Riastradh> Maybe we could also throw MegaCategory, MegaMorphism, and MegaFunctor, into the fun as well.
13:01:54 <Darius> You forgot the most important one, MegaNaturalTransformation.
13:02:21 <Riastradh> I didn't want to put it at the level of those other, lesser ones by adding it into the same list.
13:03:29 <Asta> by the way
13:03:31 <Asta> question
13:03:53 <Asta> when I studied categories, arrows and morphisms were the same thing
13:04:20 <Riastradh> That's not a question.
13:04:51 <Asta> now I was wondering when did this new "arrow"  notion first appeared
13:05:00 <Asta> and where can I know more about it
13:05:08 <Asta> do you recommend any papers on it?
13:05:16 <Darius> www.haskell.org/arrows
13:05:20 <Asta> thanks
13:05:26 <Darius> (Assuming you mean Arrows in Haskell)
13:05:42 <Asta> actually I was looking for something theoretical
13:06:10 <Asta> I thought they were an already studied categorical entity, like monads
13:06:12 <Asta> am I worng?
13:06:15 <Asta> wrong
13:06:31 <Asta> I tried to search for category theory and arrows
13:06:34 <tuomov> haskell's arrows are just more generic functors than monads
13:06:38 <Asta> but I just get "morphisms"
13:06:46 <basti_> uhm yes
13:06:47 <Darius> No, arrows are morphisms and are the things from Category theory.
13:06:56 <basti_> morphisms are called arrows sometimes
13:06:58 <wli> what do we need to use the Arrows libs/etc.?
13:07:06 <Darius> However, the Arrows library are arrows of a certian class of categories.
13:07:07 <basti_> no relation to arrow as monad
13:07:10 <Asta> import Control.Arrow
13:07:53 * Asta is somewhat confused
13:08:31 <Asta> I know what Functors and Monads are in Haskell
13:09:00 <Asta> instances of Functors and Monads should obey certain laws
13:09:17 <basti_> i dont understand these "haskell" arrows, but they are similar to Monads but more general (as i understood it)
13:09:18 <Asta> all this matches the Functor and Monads concepts from category theory
13:09:35 <basti_> its certainly not identical to the arrows in category theory
13:09:41 <Asta> now Haskell's Arrows, did they first came up in haskell?
13:09:53 <basti_> because in c.t. an "arrow" is another word for a "morphism"
13:09:54 <tuomov> instances of Monad and Arrow are cat. theoretical functors align with the function lifting map
13:10:09 <Asta> basti_: yes I know they are not the same as Category Theory morphisms, also called arrows
13:10:10 <tuomov> s/align/align/
13:10:34 <basti_> Asta: yes but now you know why your google search turns up "morphism" when you research arrow dont you? ;)
13:10:48 <Darius> http://www.haskell.org/arrows/biblio.html#categories gives an idea of what kind of categories Arrows are arrows in.
13:10:49 <Asta> basti_: I knew that before searching already
13:10:52 <wli> if I'm confused about monads I'm even more confused about how to take on arrows
13:10:56 <basti_> oh ok.
13:11:12 <basti_> i think arrows confuse everybody.
13:11:21 <Riastradh> Arrows are easy.
13:11:22 <Asta> basti_: but I was hoping to find more about Haskells Arrows in a categorical setting, I just don't know if that even exists
13:11:25 <Riastradh> Monads generalize sequential computation.
13:11:28 <tuomov> arrows are simpler, the kleisli categ. stuff confuses monads
13:11:28 <Riastradh> Arrows generalize pointless functions.
13:11:30 <basti_> very likely that does.
13:11:43 <tuomov> if you try to relate haskell monads to the way monads are usually presented in CT
13:11:50 <wli> I'm confused as heck on both really
13:11:51 <Asta> basti_: and I wonder why such a name was chosen since it already as a pre-defined meaning in category theory
13:12:04 <basti_> Asta: welcome to the real world ;)
13:12:10 <Asta> :)
13:12:34 * basti_ is curious for tuomov's explanation but will be right back so he does a line mark here
13:12:37 <Darius> Asta: Arrows are morphisms of a Freyd-category.
13:12:40 <Darius> (apparently)
13:12:58 <Asta> Darius: ah thanks, guess I'll start there then
13:13:25 <wli> well, for starters, I already have severe issues making effective use of monads
13:13:26 <Darius> tuomov: The "Kliesli category stuff confuses monads" ? 
13:13:46 <Darius> wli: In what way?
13:14:21 <wli> Darius: Basically, there are various problems for which I should be able to wing monad-based solutions I can think of, but that I can't actually devise monad-based solutions on-demand for.
13:15:03 <Asta> I've been using monads more and more
13:15:08 <Asta> not an expert by any chance
13:15:16 <tuomov> in CT a monad is a functor along with two natural transformations, 'return', and 'join', but these are not the ops normally used in haskell
13:15:17 <Asta> but I'm starting to like them quite a lot
13:15:23 <TheHunter> Asta, don't start with the categorical stuff, i guess it is more complicated than for monads. The papers by Hughes and Paterson are actually a very good introduction.
13:15:27 <wli> e.g. use monads to label a tree with the numbering of the elements in an in-order traversal.
13:15:37 <tuomov> what >>= operates on are more related to the kleisli category of the monad
13:15:49 <Asta> tuomov: join is not that used, but return is!
13:15:53 <CosmicRay> @index getProtocolNumber
13:15:53 <lambdabot> Network.BSD
13:15:56 <wli> or use monads to implement the state operations for depth-first search or breadth-first search of a graph.
13:16:13 <Darius> tuomov: Yes I know, but how does that "confuse" monads.
13:16:30 <Asta> TheHunter: I'm not going to start there, but I'd like to read it too
13:16:36 <tuomov> it makes them confusing if you try to relate it the CT concept without reading further than the definition
13:16:43 <tuomov> +to
13:16:59 <tuomov> "where the fsck does this >>= come from?"
13:17:36 <Asta> I haven't touched the categorical stuff in a while
13:17:53 <Asta> but the >>= was pretty  close to the  * if I recall correctly
13:17:55 <Darius> tuomov: Why would someone want to relate it to the categorical concept without having even heard of Kleisli categories?
13:18:03 <tuomov> I always also forget the details after figuring things out not needing it anywhere
13:18:16 <Asta> actually I always orefered the categorical sytax as it was easier to compose functions
13:18:25 <Darius> Also earlier papers were fairly clear about this.
13:18:26 <TheHunter> Asta, all i remember is that products and sums in Arrow categories act somehow like tensor products.
13:18:27 <CosmicRay> what is the best way to "loop forever" insdie the IO monad?
13:18:40 <CosmicRay> ie, keep calling a function over and over, doing stuff, discarding the result
13:18:50 <CosmicRay> would this call for unsafeInterleaveIO?
13:18:59 <Darius> sequence_ $ cycle comp
13:19:08 <CosmicRay> @type cycle
13:19:09 <lambdabot> cycle :: forall a. [a] -> [a]
13:19:18 <CosmicRay> Darius: sweet.
13:19:35 <CosmicRay> thanks.
13:19:49 * TheHunter thinks it is was a wrong decision to base monads on >>= instead of =<<.
13:20:01 <Asta> I don't like either
13:20:02 <Darius> wli: What about using monads do you find difficult?  I find it as straight-forward to use monads as using most effects in most languages.
13:20:25 <Asta> that is, if we use regular composition for pure functions I would expect the same for monads
13:20:32 <TheHunter> Asta, the symbol is quite weird, but powerful.
13:20:37 <Asta> it's just a matter of consistency
13:20:46 <TheHunter> f . g ==> (=<<) f . g,  f x ==> f =<< x
13:21:01 <Darius> CosmicRay: er repeat is what I wanted.
13:21:29 <wli> Darius: I'm not sure. What I end up usually doing instead is explicit state-passing.
13:21:35 <CosmicRay> Darius: ahh, right.
13:21:35 <CosmicRay> danke.
13:22:56 <wli> and I can't even grasp the concept of a monadic interpreter
13:23:36 <Darius> Asta: While I don't know how the particular symbol >>= came up, the idea is that it is like 'let'.
13:23:41 <wli> I guess I end up using Haskell like Standard ML with a weaker module system and schnazzier type system.
13:23:52 <Asta> I didn't explain myself correctly
13:23:55 <Asta> I like >>=
13:24:04 <Asta> I just think it's inconsistent
13:24:19 <Darius> Asta: Inconsistent with?
13:24:30 <Asta> because we use one style with pure functions and another with monadic ones
13:24:38 <Asta> the queivalent of  (.) would be
13:24:44 <Asta> f # g = \x -> f x >>= g
13:24:57 <wli> for arrows, what on earth does arr :: (b -> c) -> a b c represent?
13:24:58 <Asta> in a pure setting we write
13:25:05 <Asta> (f .g . h) x
13:25:29 <Asta> in a monadic setting that would be
13:25:30 <Darius> wli: It's kind of like the 'return' for arrows.  It just lifts a function into a "trivial" arrow that performs the function.
13:25:37 <Asta> (f # g # h) x
13:25:41 <wli> or, for that matter, first :: a b c -> a (b,d) (c,d)
13:25:46 <Asta> the usual syntax is
13:25:47 <TheHunter> Asta, ((=<<) f . (=<<) g . h) =<< x is pretty close to the style you usually find in papers.
13:25:49 <tuomov> 'arr' =~ 'pure' =~ 'fmap' =~ ...
13:26:09 <Asta> TheHunter: you think so?
13:26:10 <tuomov> it's just the morphism part of the functor that the data type presents
13:26:16 <wli> or, second :: a b c -> a (d,b) (d,c)
13:26:38 <Darius> Asta: But part of the idea of monads is to make explicit intermediate steps, hence the association with 'let'.
13:26:44 <Asta> TheHunter: f # g = \x -> f x >>= g   <-- this is the equiavalent of  (.), and there is not even a std definiton for it in the libs
13:26:50 <TheHunter> Asta, you usually denote (=<<) by a postfixed or subscripted * there
13:27:11 <Asta> TheHunter: yeap, I've seen it in theoretical category stuff
13:27:29 <Asta> Darius: not in the beginning it wasn't 
13:27:38 <tuomov> # would be compose in the kleisli category of the monad
13:27:41 <Darius> wli: The types pretty much explain 'first' and 'second'?
13:27:41 <Asta> the syntax was something like
13:27:48 <TheHunter> but your point remains: >>= encouriges opposite-order-programming.
13:28:11 <Asta> f x  >>= \x -> g x >>= \x >>= h x
13:28:13 <Darius> Asta: The relationship with 'let' was there in the beginning as far as monads applied to functional programming.
13:28:49 <Darius> Also the relationship with continuation passing style.
13:28:52 <Asta> Darius: oh, right sorry, I misuderstood you at first
13:29:32 <Asta> but I do understand >>= and why it is good, still all those arguments are also valid in a pure setting
13:30:00 <Asta> my point was just, we ended up with diferent standard styles for both settings
13:30:23 <TheHunter> the biggest design error imho is, that we don't have class Functor a => Monad a where ...
13:30:23 <Darius> Asta: Not really, point-free style isn't "standard" Haskell style.
13:31:07 <TheHunter> Darius, it's still backwards: f x ==> x >>= f
13:31:19 <Asta> Darius: never said it was
13:32:01 <Asta> Darius: but (.) is standard with pure functions and (>>=) with monadic ones, and you can define equivalent operators for both cases
13:32:23 <Asta> for instance     map (f . g)
13:32:32 <Asta> now type that monadic style
13:32:37 <Asta> mapM ...
13:33:58 <TheHunter> no big deal, mapM ((=<<) f . g)
13:33:58 <Darius> TheHunter: Unfortunately, getting reasonable syntax without extending the language is tricky.  It's supposed to be like let x <- m in f, but there's no pretty way to do that with combinators so it's like bind m to x in f
13:34:19 <TheHunter> Darius, i think the equivalent of let for monads is do.
13:34:25 <Asta> TheHunter: yeap, now I think that proves my point, but you don't seem agree :)
13:34:37 <Darius> Yes, but that's was an extension to the language.
13:34:37 <TheHunter> and by the way, i think let is backwards, too.
13:35:01 <Darius> TheHunter: Well if you think let is backwards then you should find (>>=) forwards.
13:35:57 <TheHunter> Darius, why? >>= in >>= \x -> \n - style is pretty much the same as let.
13:36:23 <Darius> Asta: let x = 3 in (f x,g x) now do that with only (#) (or only (.)) 
13:37:11 <Darius> TheHunter: In what way do you think let is backwards?  Backwards as compared to where or backwards in the bindings?
13:37:47 <TheHunter> Darius, right, backwards isn't the right term.
13:37:58 <Darius> TheHunter: As for the Functor constraint, whether to include or not is arguable, but not including it is only a minor issue.
13:38:00 <TheHunter> I meant something like "against the Haskell philosophy"
13:38:36 <Darius> TheHunter: In what way? (Except that I prefer 'where')
13:38:41 <TheHunter> Darius, the Functor constraint has pissed me off too many times to be a minor issue.
13:39:18 <wli> well, there's the whole constrained argument type problem
13:41:10 <TheHunter> Darius, well perhaps it's not the "Haskell philosophy" (if there even is such a thing) but rather my philosophy that a declarative description of something starts with the more general parts and then moves to the implementation of the details.
13:42:32 <TheHunter> anyone got an idea why the Functor constraint was removed?
13:42:55 <Darius> TheHunter: So you find 'where' more towards your philosophy?
13:43:17 <TheHunter> exactly.
13:44:31 <Darius> Well, I agree with that (though I also just find 'where' better looking)
13:45:02 <Darius> TheHunter: Though the argument doesn't apply to the various notations for monads (I'm not saying you were attempting to apply it to it).
13:46:21 <TheHunter> Darius, i was applying it to everything monadic except the do-notation.
13:46:52 * TheHunter is away: brb
13:47:37 * TheHunter is back (gone 00:00:44)
13:47:43 <Asta> back
13:47:45 <Asta> <Darius> Asta: let x = 3 in (f x,g x) now do that with only (#) (or only (.)) 
13:47:56 <Asta> Darius: I can't... 
13:48:11 <Asta> Darius: but what is your idea...?
13:49:29 <Asta> I wasn't saying (#) and (.) are all we need or anything like that...
13:50:52 <Darius> My point is that in most cases the order of the operations is important and (named) intermediate values are more prevalent due to the need to pipe them around.
13:52:27 <Darius> The preference for (>>=) reflects that.  The lack of a standard definition for (#) is likely because that operation occurs much less often for monadic code (or perhaps agreeing on what to name it was taking too long...)
13:52:52 <Asta> yes I agree, but again that reasoning also works for pure functions...
13:53:24 <KrispyKringle> hey folks
13:53:36 <Asta> Darius: "The lack of a standard definition for (#) is likely because that operation occurs much less often for monadic code"
13:53:41 <Asta> Darius: that I don't agree with
13:53:55 <Darius> I find (.) indispensable for pure functions.  I have rarely defined the monadic equivalent or used it much.
13:55:18 <Asta> Darius: honestly I don't see that much of a difference, I think it's more the fact that the operators shape our style
13:56:22 <Darius> In my experience there are many cases of manipulating the results of (multiple) sequenced actions in some way, but the actions don't depend on the results of previous actions.
13:56:38 <Darius> Witnessing this for me is that I also find liftM2 quite useful.
13:57:14 <CosmicRay> hot damn, haskell is awesome.
13:57:56 * CosmicRay has rigged up a way to turn any String -> String function into a multithreaded TCP server, with logging, in about 6 lines of code.
13:58:59 <Asta> Darius: well personally I had to convert pure code to monadic code may times, and there is barely no difference in the code
13:59:38 <Asta> s/may/many
14:00:09 <Asta> Darius: when I do that, I always miss consistent primitives to maintain my style
14:02:30 <Asta> Darius: even if you're right, I don't see why not have a monadic (.) a pure (>>=), etc
14:02:35 <Asta> brb
14:03:56 <TheHunter> Asta, yep, the list of operations that have been ported to monadic style is quite arbitrary.
14:04:25 <TheHunter> For example, the previously mentioned repeatM isn't there, but replicateM is.
14:04:29 <Darius> Asta: We do have a pure (>>=), it's called ($).  While there isn't much of a good reason for not including a monadic (.) hence my joke before.
14:05:05 <TheHunter> Darius, ($) is (=<<), (>>=) has no pure equivalent.
14:05:26 <Darius> okay, flip ($).
14:05:57 <Darius> or let
14:07:13 <Darius> including replicateM (though it's not in Monad only Control.Monad) is arbitrary, not including repeatM is arbitrary, but including them both would still be arbitrary.
14:07:37 <Darius> After the basic orthogonal primitives, the rest is added by things that are commonly used.
14:08:53 <TheHunter> Darius, i think pretty much everything should be included because it doesn't do much harm and the naming is pretty clear.
14:09:50 <Darius> TheHunter, Asta: regarding ($) though, there's is little reason to have a pure version of it, the only reason would be if you had a sectioned use of (>>=) and even that could be replaced by a sectioned use of ($).
14:10:09 <Darius> (or you were using it as a higher order function)
14:10:31 <Darius> "argument to" -^
14:12:40 <TheHunter> in the presence of the do-notation, it is my opionion that it makes just as little sense to have (>>=) as to have flip id.
14:14:21 <Darius> TheHunter: It's occasionally nice, but it's what do notation most readily translates to, so (for efficiency reasons) it makes most sense to explicitly define it.
14:14:51 <Darius> TheHunter: One way or the other you've gotta have something to get a hand on for defining purposes, do-notation doesn't provide it.
14:15:25 <TheHunter> well, the same is true for flip ($).
14:15:53 <Darius> TheHunter: Not at all, there is only one definition for ($). 
14:16:35 <Darius> And, except for higher order cases, there's no reason to use flip ($) directly.
14:17:15 <TheHunter> but there's no such difference between (=<<) and flip (=<<) either
14:18:47 <TheHunter> to be honest, it's no real problem to define (>>=) and use (=<<), so my point is quite weak...
14:22:44 <TheHunter> I think Asta's point makes sense, if you're requiring programmers to explicitely transform code to monadic style, you should make this transition as straightforward as possible, and that probably means there should be an equivalent of (.), repeat and so on.
14:24:54 <Darius> No one is requiring programmers to explicitly tranform code to monadic style and the list of such functions to add is endless, what's needed is a good way to transform pure functions into (the proper) monadic ones, admitedly a monadic version of (.) is one such thing.
14:28:28 <TheHunter> i think purity requires that you have to transform a function to monadic style every once in a while.
14:29:29 <Darius> Not if you write in monadic style in the first places in those cases.  (Now if I could just find my crystal ball... )
14:30:09 <Darius> At any rate, mass transforms of pure code to monadic code are (hopefully) not the typical case.
14:31:12 <TheHunter> ok, granted, it's not the typical case.
14:34:12 <Asta> back...
14:34:58 * TheHunter finds that deep nesting of monadic style often happens with the list monad.
14:35:00 <Darius> What might be useful though in that case (along the lines I was following before) is a class Distributive.  For example, the way to implement repeatM is sequence . repeat, sure enough this a distributive law
14:38:27 <TheHunter> Darius, i don't follow.
14:38:37 <Asta> Darius: hmm so which methods would be in that class?
14:40:31 <Darius> TheHunter: It seems distributing things through pure functions is a common pattern for turning pure code into "structural" monadic code.
14:40:59 <Darius> Asta: I'm not even sure if a class would be appropriate, though a multiparameter class Distributive f g may be somewhat useful.
14:41:06 <Darius> @type sequence
14:41:08 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
14:41:54 <Asta> not sure, you're right for repeatM, and also for mapM
14:41:58 <Asta> but not for foldM
14:42:00 <Asta> and others
14:42:35 <TheHunter> hmm, doesn't this only work for "first-order" functions.
14:43:39 <Asta> and about the monadic composition, I mentioned converting pure code to monadic one, but I don't even think that is needed as an argument.
14:44:23 <Asta> monadic composition might be quite useful whenever you want to use monadic higher order functions
14:47:07 <Darius> TheHunter: Ish.  That's part of the reason I'm not especially certain about a class, and certainly not expecting it to capture everything.  However, the idea of distribution seems to be a reasonable guiding principle for useful library constructs.
14:47:29 * boegel yawns
14:48:43 <Darius> At least library constructs with the aim of lifting pure code.
14:50:09 * boegel greets the world
14:50:21 <dblhelix> bye boegel
14:50:52 * TheHunter yawns, too.
14:50:56 <boegel> dblhelix: does greeting mean that I'm leaving ?
14:51:29 <dblhelix> dblhelix: oops, I'm sorry
14:51:50 * dblhelix greets boegel, yawning though
14:52:45 * Darius is going to restart to see if Nokia/Zero G's installer will be happier with a MS JVM.
15:19:10 <TheHunter> good night, everyone!
15:21:56 <boegel> boegel goes to sleep aswell
15:22:00 <boegel> damn
15:22:02 <boegel> again
15:22:09 * boegel goes to sleep aswell
15:22:14 <dblhelix> are you sure?;)
15:22:16 <boegel> it's clear I need to :p
15:22:18 <boegel> bye ;)
15:22:23 <dblhelix> bye
15:22:27 <boegel> dblhelix: i am sure ;)
16:30:07 <Leimy> who can I pay to inject the understanding of Monads into my skull?
16:30:12 <Leimy> and how much is it?
16:31:04 <wli> let me know when you find out
16:31:09 <Leimy> heh
16:31:34 <wagle> category theory is like dreams
16:32:01 <Leimy> for some reason I've had the impression I'd not need to understand category theory in depth to know Haskell monads :)
16:32:04 <Riastradh> Monads generalize sequential computation.
16:32:13 <Leimy> yeah I get the overview :)
16:32:19 <Leimy> it's the implementation :)
16:32:24 <wli> well
16:32:29 <Riastradh> You can create a simple computation with a single value, or you can extend a computation by a function that maps the current value to the new computation.
16:32:30 <wli> my standard is using them effectively
16:32:30 <Leimy> and how to use
16:33:35 <Leimy> Riastradh: that's how "do" works right?
16:35:16 <wagle> i think do is confusing unless you can freely (in your head) convert to and from >>=
16:35:35 <Riastradh> Leimy, yes, do performs a sequence of computation extensions.
16:36:03 <arjanb> Leimy: have you tried the nomaware tutorial?
16:36:12 <wli> what's nomaware?
16:36:18 <Leimy> arjanb: no... but that sounds good :)
16:36:20 <arjanb> http://www.nomaware.com/monads/html/
16:37:09 <Leimy> well it at least looks like it tries to be more comprehensive
16:37:11 <wagle> kata: do 10 monads every morning
16:37:20 <Leimy> most books and things spend surprisingly little time on the subject
16:37:23 <Leimy> or so it seems
16:37:47 <shapr> probably because monads are *really* simple structures
16:37:59 <shapr> and once they click in your head, their uses are relatively obvious
16:38:05 <shapr> of course... that first click can take some work
16:38:10 <Leimy> shapr: that's what I've been told
16:38:13 <shapr> sure took a lot of work for me
16:38:23 <shapr> but once I got it, it was a much better lightning bolt than OOP
16:38:27 <Leimy> but I have this uncanny ability to bang into every sharp corner to round off the edges of anything first
16:38:50 <shapr> The nomaware tutorial is the best I've seen.
16:38:57 <Leimy> OOP is more attractive until you realize what it is and the limitations  :)
16:39:16 <wagle> what is it?
16:39:25 <Leimy> OOP?
16:39:29 <wagle> yea
16:39:30 <Leimy> you'll get conflicting defintions
16:39:35 <Leimy> it's mostly marketing :).
16:39:41 <wagle> hahaha
16:39:43 <Leimy> It's just a way to think of code reuse
16:39:55 <Leimy> and "extending" existing code
16:40:06 <shapr> I think OOP doesn't scale well.
16:40:10 <Leimy> no it doesn't
16:40:15 <Leimy> its too transative
16:40:18 <Leimy> er transitive
16:40:19 <Leimy> :)
16:40:27 <Leimy> some "kinds" of oop work better than others
16:40:28 <wagle> i've seen people explain that, but then propose a fix
16:40:36 <Leimy> like objective C protocols and stuff
16:40:44 <Leimy> AOP is the fix 
16:40:45 <Leimy> supposedly
16:40:49 <wagle> ugh..
16:40:50 <Leimy> Aspect Oriented Programming.
16:41:05 <Leimy> or something lisp had 25 years ago or more or something :)
16:41:22 <wagle> hmm..  sorry, my ugh might be misinterpreted
16:41:30 <Leimy> it's pretty ugh :)
16:41:41 <Leimy> usually requires language extensions to make it work :)
16:41:48 <Leimy> and special tools
16:42:04 <sond> you should look at the more recent developements of OOP before dismissing it.. 
16:42:11 <shapr> aop is pretty much monads
16:42:13 <wagle> i want to apply aop to the interpreter of the program, not the program
16:42:15 <shapr> sond: oh tell me!
16:42:30 <Leimy> Heron seems to cover the bases pretty well
16:42:30 <Leimy> http://www.heron-language.com/
16:42:34 <sond> shapr, an example is the Scala language
16:42:34 <Leimy> for OOP/AOP and others
16:42:47 <wagle> yeah..  i said aspects were monads yeeeers ago
16:43:22 <shapr> Yeah, AOP and Monads are an easy connection if you've used elisp and hoks
16:43:22 <shapr> hooks
16:43:27 <shapr> sond: what's so special about Scala?
16:43:35 <wagle> the ugh was more that aspects cant do what some people want them to do
16:43:36 <shapr> does it change the definition of OOP?
16:43:51 <shapr> monads do what aspects do, and more
16:44:02 <wli> My usual tactic is to ignore the OO weenies.
16:44:10 <shapr> aspects have a larger granularity 
16:44:19 <Leimy> aspects are about separating concerns
16:44:20 <wagle> aspects change source.  monads are an organization of the source
16:44:23 <wagle> not the same
16:44:40 <goron> Attribute Grammars are also AOP. They don't need to have to do anything with monads.
16:44:52 <shapr> sond: I've heard good things about Scala, but I don't see how it makes OOP spiffier than before. What does it add or improve?
16:45:25 <sond> shapr, well.. it seems to make the composition of code easier than in traditional statically typed OOP languages
16:45:38 <shapr> can you quantify how it does that?
16:45:47 <shapr> Can you compare its composition to that of monads?
16:45:58 <sond> shapr, you better read the introduction articles instead of listening to me :)
16:46:15 <shapr> can you compare Scala to other OOP languages?
16:46:17 <arjanb> afaik Scala is an attempt to merge OO and functional starting from OOP side
16:46:30 <shapr> I've read the intro articles, but I didn't see what was so great about it.
16:46:38 <shapr> It just appears to be a more FP approach to OOP.
16:46:43 <shapr> as arjanb just said.
16:47:00 <Itkovian> Is there a way to import qualified certain stuff and import other stuff unqualified? Can I just use both statements and indicate which functions and dataypes in each of them?
16:47:07 <shapr> Itkovian: yeah sure
16:47:18 <Riastradh> On AOP:  'I am reminded of Gregor Kiczales at ILC 2003 displaying some AspectJ to a silent crowd, pausing, and then plaintively adding "When I show that to Java programmers, they stand up and cheer."'
16:47:25 <shapr> heh
16:47:47 <Leimy> yeah that's about how excited I was about it
16:47:58 <Leimy> I was like... HOly make a spaghetti mess of things already poorly organized :)
16:48:12 <Itkovian> and what if I only need the datatype from that module unqualified and the rest qualified? Can I add a general qualified import, i.e. without specifying specific funtions? Will that override my previous unqualified import
16:48:14 <Itkovian> e.g.
16:48:15 <Leimy> there is also AspectC/C++ now
16:48:20 <Itkovian> import qualified Plate (Plate)
16:48:25 <shapr> I was like ... and how is AOP better than elisp hooks?
16:48:25 <Itkovian> erm
16:48:28 <Itkovian> forget that
16:48:30 <Itkovian> import Plate
16:48:34 <Leimy> shapr: likewise :)
16:48:35 <sond> shapr, i've only got a really fuzzy feeling of Scala being better than most OOP languages :) 
16:48:39 <Riastradh> Anyone whom AOP excites needs to step back and look at Lisp for the past thirty years.
16:48:42 <Leimy> I'm like so Xerox patented this eh? :)
16:48:46 <Itkovian> eek.
16:48:47 <shapr> sond: can you show me the fuzz? :-)
16:48:50 <Itkovian> nevermind
16:48:52 <wagle> my claim is that every program has hidden source that AOP (currently) has no access to: the source of the interpreter of the language that the program is written in
16:48:54 <Itkovian> I'm screweing up
16:49:00 <Itkovian> even my typing ...
16:49:05 <sond> shapr, no.. i haven't even programmed in it
16:49:34 <sond> but it's type system seems to permit a more flexible way of structuring things.. 
16:49:35 <shapr> Itkovian: import qualified Plate as P ; import Plate (fork, knife, spoon) ; main = P.placeSetting
16:49:42 <Itkovian> yeah ok.
16:49:46 <Itkovian> getting there :-)
16:49:47 <wli> Riastradh: nah, just punting them back to 1958 will blow their minds enough as it is.
16:50:01 <Leimy> heh
16:50:01 <Itkovian> actually a Plate is not for eating but hey ...
16:50:15 <Leimy> Alan Kay had a really great article in ACM queue on some of this sort of stuff
16:50:33 <shapr> sond: if you end up with some comparisons, I'd be interested in hearing about it.
16:51:07 <Leimy> I was glad to see that in one "language shootout" weighting the # of lines of code made Haskell come out on top :)
16:51:44 * Riastradh refrains from commenting on the language shootout.
16:51:56 <Leimy> and that O'CaML did well for compiled code speed
16:51:58 <Leimy> :)
16:52:01 <Itkovian> thx
16:52:04 <Itkovian> gdnight
16:52:27 <Leimy> Riastradh: language shootouts aren't good metrics in general..
16:52:28 <Riastradh> Yuck.  Noone capitalizes it thus, Leimy.  It's either 'OCaml' or 'O'Caml.'
16:52:37 <Leimy> forgive my tired fingers
16:52:41 <shapr> ocAml!
16:52:43 * shapr cackles evilly
16:52:45 <Leimy> COakleam :)
16:52:59 <Leimy> CamLo!?
16:53:11 <shapr> JoCamelot!
16:53:11 <Leimy> berShizzle
16:53:34 <Leimy> OCaul
16:54:07 <wagle> ooocaml
16:54:32 <wagle> o_Ocaml?
16:54:47 <shapr> OokCaml!
17:02:36 * shapr wibbles
17:03:09 <wli> monadology
17:03:20 <Leimy> Leibniz? 
17:05:52 <jadrian> off-topic (LaTeX): anyone knows how set the wraping of a figure in LaTeX?
17:06:14 <jadrian> I wanted text on the side(s), and not only above and below...
17:07:51 <jadrian> hmm I might have found it...
17:08:22 <Leimy> return exist to put a value into a monad?
17:08:36 <Leimy> s/exist/exists/ ?
17:10:24 <Leimy> that would explain why "main = return ()" should be legal.
17:10:25 <Riastradh> 'return' creates a simple computation with a single value.
17:33:15 <wli> okay, the nomaware.com thing didn't help
17:36:43 <wli> I think it would be more illustrative to show some well-known algorithms that are usually done imperatively implemented in a 1:1 fashion via monads.
17:37:21 <wli> decorating a tree etc.
17:37:50 <Leimy> you read the whole nomaware thing already ? :)
17:39:07 <wli> Leimy: yes
17:39:16 <wli> it was put up a while ago
17:42:21 <wli> IO-heavy code too, like network daemons, would also be good.
17:42:25 <arjanb> the problem with monads is everyone seems to need a different way of explaination to get it..
17:42:39 <Leimy> that's what I read yeah
17:44:10 <heatsink> decorateTree = stringLights >> hangOrnaments >> putStarOnTop
17:44:11 <Leimy> so a monad can be thought of as an encapsulated block of computation... possibly made of other blocks
17:45:21 <Leimy> so the monad is responsible for defining how the chaining of Monads interacts
17:46:31 <Leimy> So ... IO's definition of >>= takes the result of the first computation and applies it to the next
17:46:40 <Leimy> but not all Monads have to define >>= that way?
17:47:30 <Leimy> That makes Monads sound more like the "algorithm" part of STL but in a WAY more generic sense.
17:48:44 <Leimy> is any of what I said accurate?
17:49:48 <shrimpx> explaining what a monad in haskell is is a bit like explaining what a category is in category theory. sure, it's a box with stuff in it, or a block of computation, or whatever, but that says absolutely nothing useful to a programmer
17:50:35 <shrimpx> if you go use the state monad to encode problems that might be inherently imperative, you'll get it right away
17:50:46 <wli> inOrderNumber :: Tree a -> Tree (Integer, a)
17:51:20 <Leimy> well I guess my point is that things like the State Monad are 1 way of combining the values that might be used in State transition... the Monad captures that combination strategy.
17:51:29 <Leimy> but the rest is up to you
17:51:39 <Leimy> like what data.... or what transition.
17:52:15 <Leimy> I tried to implement my own state monad once
17:52:19 <Leimy> it didn't go well :)
17:52:21 <wli> well, the "obvious" way I can think of to do it (which is not how an imperative person would do it is do something like...
18:00:05 <wli> *InOrder> inOrderLabel $ Branch 'a' (Branch 'b' Leaf Leaf) (Branch 'c' Leaf (Branch 'd' Leaf Leaf))
18:00:05 <wli> Branch (1,'a') (Branch (0,'b') Leaf Leaf) (Branch (2,'c') Leaf (Branch (3,'d') Leaf Leaf))
18:00:10 <wli> so I have that
18:00:15 <wli> but I've done it purely functionally =(
18:00:58 <wli> zipTree :: Tree t -> Tree t' -> Tree (t, t')
18:01:05 <wli> sizeTree :: Tree t -> Integer
18:01:21 <wli> inOrderLabel' :: Integer -> Tree t -> Tree Integer
18:01:48 <wli> inOrderLabel :: Tree t -> Tree (Integer, t)
18:01:48 <wli> inOrderLabel t = zipTree (inOrderLabel' 0 t) t  
18:04:37 <wli> I have a vague notion the parameter to inOrderLabel' is a sign of what might need to be part of the state.
18:05:18 <wli> I think breaking the tree up somehow may be needed
18:05:24 <wli> like left and right pieces
19:16:14 <shapr> wli: Cale wrote http://www.haskell.org/hawiki/MonadsAsContainers, it's a nice view.
19:24:25 <dons> morning shapr!
19:24:47 <dons> oh, it's afternoon already
19:38:06 <wli> hmm, okay, I have a practical problem
19:38:20 <wli> I want to do realtime GUI display of stats from the kernel
19:55:07 <wli> ari: yes
19:56:28 <wli> well, you can think of it as a fixed-size collection of registers that all you can do with is "insert one", and when you insert one, the cpu casts one out (you may be able to remove one or required to etc.)
20:03:12 <wli> Igloo: I've got a lead from one of the mlton hackers
20:03:26 <wli> Igloo: do you know if the sparc port screws with %g7?
20:07:40 <dons> sparc port of ghc?
20:07:45 <wli> dons: yes
20:08:01 <dons> looking now ...
20:08:41 <wli> some mlton guy found that their use of %g7 broke them on more recent glibc's
20:09:02 <wli> modifying the debian package to go unregisterized may help me
20:13:12 <dons> tentatively, I don't think it is used. it says, for the NCG: -- %g7 is reserved (ABI)
20:13:54 <dons> nothing above g2 is used in the C backend, by the looks of it
20:14:32 <dons> is this a sparc64 problem?
20:14:51 <wli> yes, ghci dereferences NULL
20:14:55 <dons> was it that ghci doesn't run on the sparc64-running-32-bit mode?
20:15:04 <wli> sparc64 hardware, 32-bit code
20:15:09 <dons> yeah, so it should work. ghci does work on a normal sparc.
20:15:19 <wli> dons: ghc/ghci are only ported to 32-bit (ultra)sparc
20:15:25 <dons> yep.
20:15:43 <dons> I've tested it on a solaris ultrasparc running in 32bit mode
20:15:49 <wli> dons: the difference between 32-bit UltraSPARC and elder SPARC are some extensions having to do with hardware multiplication.
20:16:10 <wli> dons: Linux is crapping out and I suspect glibc problems
20:16:20 <dons> at what point does it die?
20:16:24 <wli> dons: loading base
20:16:38 <wli> here, I'll paste...
20:16:40 <dons> hmm. maybe the dynamic linker is screwed
20:16:52 <dons> we implement our own dynamic linker, in Linker.c
20:16:54 <wli> Loading package base ... linking ... done.
20:16:54 <wli> zsh: 2776 segmentation fault  ghci
20:17:11 <wli> dons: I've not tracked down where in ghci it's dying
20:17:27 <wli> e.g. I don't know how to do the --debug thing ppl are talking about
20:17:36 <dons> oh, but it says 'done', so the symbols have actually been resolved. 
20:17:59 <dons> you can build ghc with debug flags, and get nice symbols when you dump core
20:18:20 <wli> yes, that's the part I don't know how to do
20:18:27 <wli> the build system is complex
20:18:30 <dons> very
20:18:49 <dons> but there's 500,000 lines of code, in 3-4 languages, so not too surprising
20:19:10 <wli> yes, if you know how to do a debug build I'm all ears
20:19:13 <wli> building works successfully
20:19:17 <wli> only ghci dies
20:19:22 <wli> noninteractive stuff works
20:19:23 <dons> in mk/build.mk.sample is example debug flag settings
20:19:33 <dons> oh. hmm. sounds like dynamic linking to me
20:20:00 <wli> I thought glibc version fsckage
20:20:10 <wli> we have an example of a box where it works (vore.debian.org)
20:20:26 <wli> 2.4.x kernel, vastly different glibc version
20:20:35 <dons> I guess it could be. hard to tell. just suspicious that ghc works, yet ghci doesn't
20:20:49 <dons> oh. really? you do have it working on a sparc64?
20:21:02 <wli> dons: well, glibc vs. non-glibc dynamic linker is scary stuff
20:21:24 <wli> dons: we have one example of a Linux/sparc64 installation where it works and 2 examples where it does not
20:21:33 <wli> actually 3
20:21:53 <wli> dons: the difference between the one that works and the 2 I have that don't is the glibc they're running
20:21:53 <dons> ok. maybe it is libraries.
20:22:17 <wli> well, I wouldn't be surprised at all if glibc/gcc TLS-related changes broke ghci's dynamic linker.
20:22:33 <dons> I wouldn't be surprised either
20:23:05 <dons> anyway, you can build with debug flags by using the "devel" settings summarised in mk/build.mk.sample
20:23:18 <wli> I was about to ask, thanks.
20:23:52 <wli> GhcRtsCcOpts?
20:24:17 <shapr> g'day dons
20:24:18 <wli> or just pepper everything that looks like a C compiler flag with -g?
20:24:28 <shapr> it's getting late here
20:25:55 <wli> oh
20:26:02 <dons> -DDEBUG, GhcRtsCcOpts -g
20:26:09 <wli> the other thing is that if it tries to use threads and it's not setting up %g7 it will die
20:26:36 <dons> won't the threadd library deal with this?
20:26:44 <wli> nope
20:26:54 <wli> thread library assumes it created all the threads etc.
20:27:15 <wli> it may be called for that regardless
20:27:18 <wli> but even so
20:27:32 <dons> anyway, you aren't running it -threaded
20:27:36 <wli> IIRC there is some new relocation or some such
20:28:10 <wli> for TLS
20:31:13 <wli> it makes no syscalls between printing "done\n" and faulting
20:38:16 <shapr> dons: Vim.lex_count is what handles numeric for '7dd' right? is that a good way to start nested keys like C-x C-c ?
20:39:10 <dons> lex_count accumulates prefix digits, right
20:39:13 <shapr> ok
20:39:28 <dons> now, what do you mean by 'nested keys'?
20:40:05 <dons> do you understand cmd_op ?
20:40:21 <dons> that is a command, followed by an optional postfix movement char
20:40:30 <shapr> oh
20:40:30 <dons> dj or d4j or 4d4j 
20:40:56 <shapr> neato
20:41:02 <shapr> -- Lazy lexers - you know we're right (tm).
20:41:05 * shapr snickers
20:41:12 <dons> hehe
20:41:51 <shapr> so, same idea can be applied to multiple commands under C-x like C-x C-c and C-x o ?
20:41:58 <wli> hm
20:42:00 <dons> yeah, I think so.
20:42:05 <shapr> ok, thanks
20:42:29 <dons> lex ^X, then run another lexer to get the postfix argument
20:42:33 <wli> gtk+hs may be the way to go
20:42:42 <wli> though I'm a bit unsteady on my feet in/around gtk
20:43:10 <dons> shapr: depends on what you're trying to do. you could just: (char '\^X' +> any)
20:43:30 <shapr> will that be easy to change at runtime?
20:43:51 * shapr shrugs
20:43:59 <shapr> hack or sleep...
20:44:07 <wli> hm, drawing curves on the fly may get tricky
20:44:16 <shapr> the sun's not coming back till january anyway....
20:44:47 <dons> nope. for that you need to pass around the lexer you're using as an argument, and run that with `meta`
20:44:56 <dons> lots of examples in Nano.hs
20:45:07 <cm> hello everyone
20:45:10 <wli> I basically just want to plot curves
20:45:15 <shapr> ah, I see
20:45:26 <shapr> cmdCharFM is an excellent example.
20:45:32 <shapr> coolio
20:45:39 <dons> in Nano?
20:45:51 <shapr> yeah
20:46:14 <shapr> hiya cm
20:46:18 <dons> yeah. probably closer to emacs. esp, as it switches to submodes with new keybindings, like askYN
20:46:24 <shapr> right
20:46:51 <shapr> absolutely, that's perfect
20:46:54 * shapr hops
20:47:17 <tintin> shapr: get back into emacs :)
20:47:20 <cm> hey shapr
20:47:29 <cm> you hopper, you
20:47:39 <dons> you see how switch2WriteMode prints a prompt, then uses metaM to pass control to askYN ?
20:47:40 <shapr> tintin: dude, I'm in Yi!
20:47:55 <tintin> :(
20:48:06 <dons> yi yi!
20:48:08 <shapr> tintin: for my purposes, Yi is significantly better.
20:48:10 <tintin> hmmz run Yi inside emacs and we are even :)
20:48:16 <shapr> no way man
20:48:16 <dons> bah!
20:48:33 <wli> are there yi debs yet?
20:48:37 <tintin> shapr: is Yi better at editing Haskell code ?
20:48:39 <shapr> c'mon, Yi has multithreading. If I want to read my email while chatting on irc with Yi, it actually works.
20:48:46 <dons> wli: nah. way too beta
20:49:09 <tintin> shapr: but it wont help with tonnes of stuff that emacs alread has ... 
20:49:18 <dons> tintin: not yet. but soon. design should provide significantly nicer haskell modes
20:49:19 <tintin> thats the basic problem with Yi ...
20:49:21 <shapr> Both gnus and erc both block if connections get weird, making it impossible to paying work at the same time. That is intolerable.
20:49:28 <cm> is Yi going to provide CUA bindings? :)
20:49:44 <cm> ("go ahead, cm!")
20:49:48 <shapr> Legacy code is not a good reason to stick with something.
20:49:53 <dons> yah
20:49:55 * shapr mutters something about lemmings.
20:50:06 <Leimy> then lets all flock to plan 9!
20:50:17 <cm> plan 9 is ugly!
20:50:33 <shapr> I think it's best to just find what works for you and use it.
20:50:40 <dons> shapr: search_km is another submode with new bindings
20:51:08 <tintin> or get emacs working under Yi :)
20:51:16 <dons> but I guess you're just working on parsing multi-char cmds, atm?
20:51:16 <shapr> emacs keybindings
20:51:19 <shapr> yup
20:51:46 <cm> so... yi. will it be possible to actually work on a syntax tree, or does the "lexer" part mean that it's just chained text blocks?
20:51:56 <shapr> cmdCharFM and askYN are good examples there.
20:52:11 <dons> the lexer is referring to how arbitrary keymaps are programmed
20:52:14 <shapr> cm: the lexer being discussed right now is the lazy keymap lexer
20:52:25 <dons> yi will work on syntax trees, after xmas sometime
20:52:44 <cm> so after xmas it's going to be a really interesting project :)
20:52:45 <dons> I'm reading up about the Centaur system from INRIA, very interesting ML system
20:52:57 <shapr> dons: btw, what do you think for that? I've been trying to get sdf2haskell built, but it has a *lot* of dependencies.
20:53:04 <dons> cm: well, the lexer keymap thing is pretty interesting already, I think.
20:53:10 <Lunar^> Waow, people still alive
20:53:17 <Lunar^> The net never stop
20:53:18 <shapr> salut Lunar^, ca va?
20:53:34 <cm> dons: :w works just fine for me ;) (pardon my ignorance)
20:53:38 <Lunar^> shapr: Je viens de passer 8 heures  faire TODO--
20:53:43 <shapr> j'ai parle un peu avec la jolie geeke :-)
20:53:55 <shapr> aujourd'ui
20:54:10 <dons> hey Lunar^
20:54:12 <cm> comment est-ce qu'elle s'appelle?
20:54:19 <cm> Eliza?
20:55:27 <shapr> Lunar^: veux tu apprendre monocycle? =)
20:55:34 <dons> shapr: re syntax trees, I don't want to tie users to writing in a particular parser language, so the api will be quite general. what I'm more concentrating on is how to efficiently map a syn tree to a coloured buffer
20:56:03 <dons> a simple traversal, with correct position information is the idea atm. 
20:56:17 <dons> with comments stored somehow, and multiple entry points for efficient reparsing
20:56:43 <dons> I'd hate to lose all the lovely performance we have atm
20:56:45 <cm> is it necessary to reparse?
20:56:54 <dons> when you edit ;)
20:56:56 <shapr> I wonder if having standard parse tree types and standard parser languages would be better for code reuse.
20:56:58 <cm> can't you edit the AST directly?
20:57:05 <cm> the text buffer merely being a view?
20:57:07 <dons> shapr: that's what I want
20:57:22 <shapr> ok
20:57:32 <dons> cm: well, there's 10 years of structured editor papers on this debate
20:57:32 <cm> (IP-style)
20:57:44 <shapr> dons: and you're getting college credit for all this too? ;-)
20:58:01 <cm> dons: right, so..? :-)
20:58:24 <shapr> do you have the structured editor bibliography online?
20:58:30 <dons> shapr: yes. hopefully full time next year
20:58:43 <dons> shapr: not yet, but the Centaur ref is in the TODO file
20:58:46 <shapr> full time credit for Yi??
20:59:02 <shapr> that would be awesome!
20:59:15 <dons> hopefully. writing a proposal.. emphasis on the plugin/type checked dyn loading aspects, though
21:00:29 <wli> shapr: ever fiddled around with GUI stuff in haskell?
21:00:34 <shapr> yeah, some
21:00:52 <wli> shapr: suppose I wanted to plot some curves in realtime
21:01:02 <shapr> HOpenGL?
21:01:02 <wli> shapr: e.g. I'm looking at /proc/meminfo or similar
21:01:21 <wli> shapr: and want to draw the history of some field for the past 10s updated every 1s
21:01:30 <wli> shapr: hOpenGL for that?
21:02:07 <shapr> why not?
21:02:36 <shapr> are you thinking something like a Haskell GKrellM?
21:02:40 <wli> shapr: no idea up-front, I just thought it was more for 3D-type stuff
21:02:49 <wli> shapr: I don't know what grellm is
21:02:53 <wli> gkrellm
21:03:06 <shapr> http://web.wt.net/~billw/gkrellm/gkrellm.html
21:03:24 <cm> opengl is fine for 2d stuff, as well.
21:03:43 <Leimy> *nod*
21:03:54 <cm> and GLUT would provide you with a good starting point
21:03:56 <Leimy> actually it's not too shabby with 2d stuff
21:04:21 <cm> (for the "updated every 1s" part + for getting started with the "drawing" part)
21:04:25 <shapr> OpenGL is more 'standard' and cross-platform than most anything else.
21:04:37 * cm fears glBegin
21:04:43 <Leimy> only thing I can think of that comes close is SDL
21:04:55 <Leimy> and it's not got any drawing primitives
21:04:55 <wli> shapr: it does something vaguely like what I have in mind but I was interested in a lot more detail
21:05:22 <wli> shapr: something tuned for boxen that have >= 10 disks and so on
21:06:40 <shapr> sounds cool
21:07:07 <shapr> my major complaint with gkrellm is that it can only be vertical, there's no horizontal mode.
21:07:40 <wli> shapr basically, something that looks more like xload with color-coded per-device/etc. curves, that's set up for more detail.
21:07:48 <cm> is the author of darcs a regular in this channel?
21:07:57 <shapr> nope, though he has been here a few times
21:08:01 <wli> shapr: and a broader variety of statistics
21:08:15 <wli> shapr: so there's not a lot of overlap with gkrellm...
21:08:36 <shapr> sounds cool to me
21:09:30 <cm> nice, yi works.
21:09:50 <wli> well I just want a picture of what's happening
21:09:57 <wli> trouble is that I'm clueless on the GUI front
21:10:06 <cm> it doesn't properly restore the console when you :q
21:10:27 <cm> but i guess you already know of the more obvious problems, so I'll shut up and play :)
21:10:46 <shapr> OpenGL is generally more mathy about drawing (imho), I think you'll like it.
21:12:44 <cm> in your case you'll probably want to use linestrips as primitives
21:14:24 <shapr> plus OpenGL knowledge transfers to nearly any language.
21:15:34 <Leimy> well it's pretty independent :)
21:15:41 <Leimy> and designed to stream information to the GPU
21:15:56 <cm> actually it needs extensions to do that reasonably ;)
21:16:07 <Leimy> so you have a lot of data setups like Begin... do some crap End
21:16:24 <Leimy> cm: well depends on the hardware acceleration involved
21:16:39 <dons> cm: it doesn't restore the console? it should. what OS?
21:16:49 <cm> dons: linux, gentoo, 2.6 kernel, Eterm
21:17:00 <cm> Leimy: you mean performance is shit with mesa, anyway? ;)
21:17:01 <dons> did you get yi from the darcs repo?
21:17:04 <cm> dons: yes
21:17:18 <dons> in what way 'doesn't it restore'? is it scrambled?
21:17:24 <Leimy> if you mean that crap that comes with X11 then yes... 
21:17:27 <cm> dons: the position is the same, but the lines above are empty/black instead of containing content
21:17:34 <cm> Leimy: yeah.. the software renderer
21:17:42 <cm> Leimy: err, rasterizer
21:17:44 <Leimy> yes... that will tend to suck :)
21:17:56 <dons> ok. yeah, I think  I've seen that on linux. doesn't occur on *BSD. I'll investigate.
21:17:59 <Leimy> but it at least lets you use it I guess
21:18:08 <dons> something different about linux ncurses, I guess
21:18:45 <cm> Leimy: what i meant is that glBegin()/glEnd() isn't the way to go if you need "real" performance. and IIRC vertex buffers and the like were extensions, no?
21:19:04 <cm> (ARB_gl_vertex_array or something like that?)
21:19:07 <wli> well, what I'm actually trying to do is incredibly crude
21:19:17 <wli> opengl sounds like overkill really
21:19:27 <Leimy> my point is that you need to do something on the order of getting what you want to send off to the coprocessors of any kind together to get any sort of streaming parallelism :)
21:19:31 <wli> I could in principle popen to gnuplot to get what I want
21:19:31 <cm> wli: and yeah, those speed comments are not relevant for spitting out graphs ;)
21:19:51 <wli> i.e. literally just dump some logged data to a file
21:20:00 <wli> then spray a command to gnuplot to plot that file
21:20:07 <wli> every second or so
21:20:40 <wli> basically the only reason not to do that is that talking over a pipe like that really sucks
21:21:37 <cm> shapr: btw, flying home to good old Europe for vacations (on sunday) :o)
21:22:02 <shapr> cool, too bad you'll be distantly south of me
21:22:18 <cm> (yay at New Year's Eve with my old mates)
21:22:29 <cm> :-)
21:22:45 <cm> what kinda temperature do you have in shapr-land, at the moment?
21:23:01 <shapr> we're having a heatwave, it's 2 degrees above freezing.
21:23:30 <cm> :) damn cold wind when I went home from work before
21:23:33 <shapr> means that our mounds of snow are alternately treacherous slush or worse glassy ice.
21:23:45 <shapr> makes it difficult to unicycle :-(
21:23:55 <cm> :\
21:23:58 <shapr> what's it like in your part of north america?
21:24:12 <cm> -16 at the moment, I think (Montreal)
21:24:21 <shapr> is that C?
21:24:24 <cm> pretty windy day as well :\
21:24:25 <cm> yep
21:24:28 <shapr> yow
21:24:44 <cm> I can't think Fahrenheit, Inch, or that kind of thing ;)
21:24:48 <shapr> heh
21:25:05 <Leimy> google makes it so easy though
21:25:06 <shapr> I wish there were a metric time unit.
21:25:20 <Leimy> http://www.google.com/search?ie=utf8&oe=utf8&q=1234+gallons+in+teaspoons
21:25:40 <shapr> A hydrid base 24 and base 60 system is nuts.
21:25:48 <Leimy> be about 13C tommorrow
21:25:57 <Leimy> 55 degrees F
21:26:25 <cm> shapr: yeh :)
21:27:06 <shapr> Programming is about making it easy to mentally process problems. I'm cool with base 10 and base 2, but not hours and minutes and weird numbers of days in a month.
21:27:07 <cm> let's ask EU for some funding for sponsoring it ;) they are even funding PyPy (pretty cool IMO).
21:27:26 <shapr> Yeah, I met the PyPy guys at EP2004. Holger Krekel is *cool*
21:27:52 <cm> how confident are you about their success?
21:28:16 <cm> the financial founding + the fact that people are gonna work full-time on it (or so I heard) is kinda nice
21:28:20 <cm> funding
21:28:21 <Leimy> what's PyPy?
21:28:32 <Leimy> Python in Python?
21:28:37 <cm> Leimy: yes
21:28:39 <shapr> I don't think it matters whether they succeed or not, they're already making positive progress that contributes positively to Python.
21:28:57 <shapr> They tried to get me interested, but I've already got one :-)
21:29:17 * shapr hugs Haskell
21:29:22 <cm> it would be awesome to have speed which is up to par with CL
21:29:48 <shapr> I want expressiveness over speed.
21:30:21 <shapr> dons: is there some cheesy way I can do buffer-local keymaps?
21:30:21 <cm> I need fast enough and accessible enough, as well :\
21:30:37 <shapr> fast enough you can get by changing abstractions and algorithms
21:30:56 <shapr> imho, expressive enough is significantly more challenging.
21:30:59 <cm> no. in some applications the constant-factor matters.
21:31:22 <dons> shapr: cheesy?? sure. when a user hits the next/prev window key, use metaM to pass a new keymap to use
21:31:41 <Leimy> show me HPC Haskell :)
21:31:45 <cm> and it's unfortunate that I'm working/very interested in such stuff, as well :-)
21:31:56 <aj> (if you had "deconds" be 0.864 of a second, 1000 deconds is about a quarter hour, and 100000 deconds is a day; that could work and not be too terribly confusing. a "dinute" would be 100 deconds, or about a minute and a half)
21:32:13 <Leimy> dinute!
21:32:20 <dons> shapr: don't actually need metaM, just `meta` probably
21:32:26 <cm> that's dinuts. :)
21:32:34 <aj> donuts?
21:32:37 <Leimy> donut!
21:32:44 <shapr> cm: tried psyco or pyrex?
21:32:49 <dons> shapr: but don't write too much code for this, as we'll have a system eventually
21:33:07 <shapr> ok
21:33:11 <cm> psyco yes
21:33:19 <shapr> I just want to hack the keymap in one window and try it in another
21:33:31 <cm> (but I was more talking about Haskell, sry)
21:34:04 <dons> shapr: in that case, use `meta` to set the new keymap on window switching
21:34:09 <shapr> aj: any ideas for a base 2 or 10 year?
21:34:19 <shapr> dons: ok, thanks
21:34:42 <shapr> cm: what constant-factor ?
21:34:47 <aj> shapr: nah, too astrological
21:35:03 <shapr> I just want some easy way to be able to calculate dates.
21:35:24 <aj> shapr: just use days from jan 1st?
21:35:37 <shapr> my favorite example is the plane I nearly missed because we were so close to a timeline in the USA
21:35:59 <shapr> and I had calculated times according to the originating timezone, not the landing timezone.
21:36:00 <cm> shapr: I mean the difference in speed you have for the same algorithm
21:36:18 <aj> oh, timezones suck
21:36:44 <shapr> So, I don't mind having a local time, but I sure don't want airport times using that.
21:37:04 <shapr> cm: huh?
21:37:20 <cm> shapr: ..between two different languages
21:38:48 * shapr finally gets sleepy
21:39:02 <cm> that's what you get from cheating with time zones ;)
21:49:11 <cm> dons: end = Curses.endWin >> Curses.refresh
21:51:01 <cm> dons: fixes the problem (it kinda.. flickers before it restores the old console, but it does that without the refresh as well)
21:51:09 <dons> ok
21:51:37 <dons> thanks.
21:53:16 <dons> argh. way to many flickers on openbsd
21:53:51 <cm> why does the flicker happen at all (the one without my change)?
21:54:42 <dons> doesn't happen for me. linux is weird. I'll go and read the docs
21:55:54 * cm checks darcs' configuration possibilities
22:00:12 <Leimy> mebbe it's eterm :)
22:00:14 <Leimy> try xterm :)
22:01:57 <cm> what is the "test" option about? what kind of test suite is it referring to?
22:03:00 <cm> ..just a consistency test or something?
22:13:01 <dons> ah ha! looks like endwin was called twice. and linux/ncurses doesn't like that
22:21:57 <cm> :)
22:22:07 <cm> explains the flickering
22:31:04 <cm> haddock parse errors on import Prelude hiding (Prelude.catch), duh :(
22:32:33 <dons> in yi?
22:32:51 <cm> no
22:32:57 <cm> personal stuff
22:33:08 <dons> ok. good :)
22:34:36 <cm> (parse error at the opening parens -- maybe it's expecting it to be like (..) only if it's a tuple of symbols? /me tries to change)
22:35:32 <cm> (no :/)
22:40:22 <dons> cm: can you pull the latest yi patch and try it for me? you need to run autoreconf ; ./configure ; make , and then see if it restores properly after quitting
22:41:58 <cm> sure
22:45:53 <cm> hum, haddock doesn't know "hiding"?! :o
22:46:30 * cm fixes the parser and hopes everything goes well
22:47:24 <cm> (yi just gave me a linker error.. re-get-ting)
22:47:29 <cm> (while make-ing)
22:47:50 <dons> hmm. maybe you need to make clean 
22:48:02 <dons> useful error msg?
22:50:21 <cm> compilation IS NOT required
22:50:21 <cm> ghc -o yi-static   -package-conf yi.conf -package yi Main.o Yi.o
22:50:21 <cm> Yi.o(.text+0x9a): In function `__stginit_Yi_':
22:50:21 <cm> : undefined reference to `__stginit_YiziCursesziUI_'
22:50:21 <cm> /home/cm/projects/3rdparty/yi/libHSyi.a(Core.o)(.text+0x2c): In function `__stginit_YiziCore_':
22:50:24 <cm> etc etc
22:51:00 <dons> no idea. make distclean ; autoreconf ; ./configure
22:51:16 <dons> doesn't occur for me on linux, freebsd or openbsd, so it is probably just old .o files lying around
22:51:21 <cm> naw, pulled a fresh yi.. make'ing..
22:55:43 <cm> dons: awesome.
22:55:54 <dons> cool :)
22:56:16 <cm> what's the difference between inplace and static?
22:57:05 <cm> (static launches as fast as vi, inplace takes 0.5sec to startup)
22:57:35 <dons> inplace is an in-tree version of normal yi, which uses hs-plugins to dynamically load both the yi library, and user config files from ~/.yi. yi-static is a statically linked version, with no configurability
22:57:53 <dons> cm: try yi vs vi on, say, a 10M file
22:57:59 <dons> vi is damn slow
22:58:46 <dons> on 64M yi takes around 4s vs vim 7s, emacs 8s and vi 23s. which is fun.
22:58:58 <dons> but I'm not sure if there are any awards for starting up fast ;)
23:00:05 <cm> i can give you a hug if you manage to make inplace start up faster :D
23:00:05 <dons> so yi-inplace has a bit of a cost a startup due to HSyi.o being dynloaded
23:00:43 <dons> yeah. need to improve the performance of ghc's dyn linker. it is the same cost that ghci pays
23:02:53 <cm> btw.. what happens if you load a plugin, create some "instance" of some type from that plugin, use it, and reload the module? I assume/hope the old value will still continue to exist?
23:03:13 <tintin> dons do you develop Yi by anychance ?
23:03:27 <cm> (i'm dreaming of that server that has "never" to be restarted :-)
23:04:03 <dons> cm: when reload, you get the new version of the module. the values created by code from the old module still exist though -- you just can't call old versions of functions
23:04:26 <dons> so it is _very_ suitable for hotpluggable haskell modules
23:04:44 <dons> i.e. yi itself has a :reboot function, that reloads yi without having to quit
23:04:56 <cm> but if you hold an old function as a value, you can still call it?
23:05:16 <dons> the code is gone, so you'll break things if you have a reference to the old code
23:05:25 <cm> k
23:05:36 <dons> tintin: I wrote yi, yes.
23:05:42 <dons> s/wrote/am writing/
23:06:17 <cm> hooray. haddock doesn't like the "Bar." part of "import Foo hiding (Bar.baz)"
23:06:32 <cm> "import Bar hiding baz; import Foo" works fine
23:06:36 <cm> hiding (baz)*
23:06:50 <dons> huh. I get most bugged by the cyclical imports issue.
23:07:26 <dons> you have to totally hack around if you want docs generated for recursive modules
23:07:37 <cm> and I get annoyed by apache forbidding me to access a html file which has "CGI" in its name, hah :)
23:07:41 <cm> (HTTP.CGI.html)
23:07:59 <cm> dons: haven't had that problem yet
23:08:09 <cm> does it happen with yi?
23:08:46 <dons> yeah, there's a recursive import with Undo.hs, so to get docs for that, you have to generate it separately, and then patch the index
23:09:26 <dons> you really treat the recursive modules as a different library, unfortunately
23:11:13 <cm> it doesn't like Generics, neither =(
23:11:24 <tintin> ah cool were you an emacs fan earlier dons ?
23:11:39 <dons> cm: haddock? why?
23:12:04 <dons> tintin: no, I'm actually a vim user - and vimScript sucks. but emacs also sucks too ;)
23:12:17 <cm> dons: parse error in deepSeq {|Unit|} a y = a `seq` y
23:12:39 * tintin runs away from yi ...
23:12:54 <dons> oh, {| |} . yeah. Language.Haskell.THH won't like that
23:13:24 <cm> les aventures de tintin :x
23:13:32 <dons> tintin: yi is designed to subsume good parts of emacs and vim, that's why it already has keybindings for 3-4 editors
23:13:54 <tintin> emacs isnt keybindings alone ... 
23:13:58 <tintin> unlike vi ...
23:14:06 <cm> dons: a) any plans for CUA keybindings (Ctrl-S, Ctrl-Left, etc.)? b) is there a more modern way for generics?
23:14:33 <dons> tintin: of course. hence the whole Haskell scriptable thing. keymaps is just what we're concentrating on atm.
23:15:03 <dons> cm: a) you could write one in 50 lines or less. b) don't know, but maybe.
23:16:02 <dons> the keymaps are defined via lexer combinators, so rather clean and simple in haskell
23:16:28 <dons> you just have to work out the grammar for your favourite editor
23:16:41 <cm> k
23:17:17 <cm> about the structure editing.. is it no goal at all for yi, goal for the distant future, ..?
23:17:24 <dons> oh, very much a goal. 
23:17:58 <dons> once we've got the full haskell abstract syntax, firstly for decent syntax hl, we can then use it for all sorts of structured editing tricks
23:18:27 <dons> grammar-sensitive keyword completion would be one
23:18:35 <Cale> I haven't really looked at the yi code -- how nicely will it abstract to other user interfaces?
23:19:32 <dons> wolfgang thaller has proposed a generic ui type classs to abstract over ncurses and wxhaskell, if that's what you mean by other user interfaces (?)
23:19:39 <dons> and I plan to integrate that soon
23:20:01 <dons> I think by structured editing we'ree referring to editing of the abstract syntax tree, rather than a raw buffer
23:20:07 <Cale> ah
23:20:17 <cm> yeh.
23:20:47 <cm> the abtract syntax tree of a generic text file would be more or less the current representation, I guess
23:21:30 <dons> yeah. or the abs syn could be just Nothing for text.
23:21:59 <Cale> nothing like a little rehubbing to break up a conversation real nicely :)
23:22:04 <dons> hehe
23:25:35 <cm> damnit, how to I fix that apache problem :)
23:27:42 <cm> RemoveHandler .cgi, voila :o)
23:30:47 <cm> dons: Yet Another Haddock newbie problem: "Warning: Main: imported module not found: Prelude"
23:30:50 <cm> any idea?
23:31:58 <dons> haven't seen that one.
23:32:34 <dons> are you using -n or --no-implicit-prelude ?
23:32:59 <cm> hrm no
23:33:18 <cm> find | grep \\.hs | xargs haddock -o path -h -t Name -v
23:33:23 <dons> because the Prelude should be imported automagically
23:33:33 <cm> yeh :\
23:33:40 <dons> maybe  all the hidden/name space tricks are messing it up?
23:34:03 <dons> you could maybe use -d for more verbose output
23:34:53 <cm> same.. bizarre
23:35:05 <cm> (happens for *all* import'ed modules)
23:35:18 <dons> ah. then something is broken :}
23:36:19 <cm> :)
23:41:21 <cm> freaky, freaky
23:42:17 <cm> module Test where main = print "foo"
23:42:27 <cm> haddock says "Module not found: Prelude"
23:42:31 <cm> daddy, did I mess something up?
23:42:43 <cm> anyhoo, good night ;)
