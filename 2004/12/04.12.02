00:37:25 <shapr> Good morning #haskell!
00:38:26 * shapr unlurks and stares at blackdog 
00:44:02 <wolfman8k> hm.. i still need to go to sleep
00:44:12 <wolfman8k> fudgets are really cool
00:52:27 * earthy blinks
00:54:35 * wli_ hrms
00:54:46 <shapr> wolfman8k: yes they are!
00:55:01 <shapr> Have you seen the InternetLib fudgets library?
00:55:39 <shapr> I'd like to see fudgets recast using arrows, but then I'm an arrows jag lately.
00:55:53 <shapr> When all you want to think about are arrows, all the world looks like a target.
01:00:21 <Maddas> haha
01:06:40 <tuomov> OOP is dusty! Arrow-oriented programming is the next big thing!
01:06:50 <shapr> w00!
01:06:59 * shapr shoots a few arrows at some nearby targets.
01:10:22 <flodin> sorry, the AOP acronym is already taken
01:10:26 <earthy> shapr: actually, having arrow syntax for fudgets seems neat
01:10:33 <earthy> yeah, them nasty aspect guys
01:12:17 <earthy> but what I'd *really* like is an arrowized fudgets implemented on top of wxHaskell
01:12:29 <Matt-W> pffft
01:12:30 <shapr> that would be spiffy.
01:12:39 <Matt-W> I'd rather have it on top of gtk2hs
01:12:45 <Matt-W> less overall glue
01:12:53 <Matt-W> although pretty useless outside UNIX
01:12:57 <Matt-W> let's do both!
01:12:57 <earthy> exactly
01:12:59 <earthy> ;)
01:13:06 <shapr> flodin: have you seen the paper discussing monads as the theoretical basis for aspect oriented programming?
01:13:31 <flodin> shapr: nope! They seem very unrelated to me
01:13:31 * Matt-W reminds himself again to write something that uses arrows
01:14:37 <earthy> flodin: they are not though
01:14:44 <shapr> time for swedish class...
01:14:46 * shapr disappears
01:14:56 <earthy> monads are really nice encapsulations of computational behaviour
01:15:03 <flodin> then again, i couldn't say i know much about monads (actually, i don't understand what's so hard about them so I figure i must be missing something, since everybody says they're very daunting and difficult)
01:15:22 <earthy> well, they're daunting allrgiht
01:15:25 <earthy> not difficult though
01:15:58 <flodin> isn't it just an object storing the current state, passed into a function and then returned containing the new state when the function completes
01:16:45 <earthy> ah, no.
01:17:03 <earthy> it can be as simple as Maybe
01:17:13 <earthy> and as complex as a continuation
01:17:18 <earthy> including call/cc
01:17:43 <flodin> hum okay
01:19:47 <earthy> as I said, daunting. :)
01:20:40 <flodin> well, i'll have to get to the bottom of that
01:55:05 <flodin> can all regular expressions be represented as unambiguous non-left-recursive context-free grammars?
02:02:33 <Matt-W> Umm
02:02:36 <Matt-W> Don't quote me on this
02:02:39 <Matt-W> but it sounds plausible
02:07:38 <flodin> i agree ;)
02:07:57 <flodin> i guess i'll just put that in my report hehe
02:08:32 <Iter> As far as I understand, monads are an abstraction of the concept of ordering or sequence.  In the IO() monad what you are sequencing is 'computations'.  State fits this, so does the List monad, but I don't know how to fit Maybe into this model, so I'm probably missing something.
02:08:43 <Iter> flodin: yes.
02:08:56 <flodin> Iter: ah goodie :)
02:09:16 <Iter> context-free grammars are a superset of finite automata.
02:09:38 <Iter> (or more precisely, languages defined by finite automata)
02:09:56 <Iter> 1 state machine => finite automata
02:10:15 <Iter> 1 state machine + 1 stack => context-free grammar
02:10:25 <flodin> yeah, that i know, but i was adding additional constraints. But I know left recursive grammars can be rewritten into non-left-recursive without changing syntax so i guess that constraint has no effect
02:10:34 <Iter> 1 state machine + 2 stacks => turing complete.
02:10:42 <flodin> ambiguity makes me less certain though
02:10:53 <flodin> a*a* would be ambiguous
02:11:39 <flodin> though in the great scheme of things it doesn't matter, except my code has to be able to handle that kind of ambiguity by selecting one interpretation
02:12:14 <Iter> are you allowed to transform it to aa*? :)
02:12:44 <flodin> yeah they're only used for lexical matching so as long as both grammars match the same thing without changing semantics it's okay
02:13:55 <flodin> er wait, it wouldn't be the same in this case
02:14:05 <flodin> but a* would
02:14:20 <Iter> opps, you're right :/
02:15:20 <Iter> that was careless.
02:15:22 <flodin> seems grep has no problems dealing with stuff like "a+a+"
02:17:33 <Iter> the problem would only arise if you care to distinguish between _a*, a*_, and a*a*
02:18:56 <Iter> but the key is to remember that all regular expressions can be expressed as a DFA and therefore by definition LL1
02:24:24 <flodin> hmm, what do you mean by '_'?
02:25:58 <Iter> I was just trying to represent the one term failing to match
02:43:52 <dblhelix> kosmikus: can a directive in lhs2Tex spread over multiple lines?
02:44:10 <dblhelix> /s/spread/be spread
03:46:59 <Janni> Morning.
04:03:22 * dblhelix is away: out to lunch
04:05:03 <Iter> Does the osx 10.3 build of ghc work under 10.2?
04:08:53 <boegel> hello #haskell
04:09:13 <xerox> hello!
04:11:12 <xerox> kudos KiMoS (:
04:11:24 <KiMoS> hi xerox  wassup  ? :)
04:12:07 <xerox> too much yawns at school..
04:12:19 <KiMoS> what do u study
04:12:48 <xerox> high school
04:14:22 <KiMoS> Lei Ë italiano? 
04:14:26 <xerox> si :)
04:14:27 <boegel> xerox: too easy for you ?
04:14:39 <KiMoS> piacevole 
04:14:48 <xerox> borism, i hate biology
04:14:58 <xerox> or maybe it's just the professor..
04:15:30 <KiMoS> i think the professor
04:15:41 <KiMoS> usualy ppl like biology 
04:16:21 <xerox> and geology, umpf.
04:17:10 <KiMoS> anyways im off to study for my math quiz tommorow bye :)
04:17:16 <xerox> enjoy :D
04:17:42 <KiMoS> ringraziarla
04:17:46 <boegel> KiMoS: I hate biology :)
04:17:50 <KiMoS> i hope i spelled good lol
04:18:00 <xerox> pi√π o meno :)
04:18:21 <xerox> "ti ringrazio" would be better
04:18:46 <KiMoS> that mean i thank you right?
04:18:52 <xerox> yes
04:19:03 <KiMoS> why dont u have thanks you at once ?  :)
04:19:09 <KiMoS> tank you*
04:19:14 <KiMoS> thank**
04:19:20 <KiMoS> instead of i thank you
04:19:38 * KiMoS new to italian
04:19:46 <xerox> hehe the suffix "la" stays for "a te", "to you"
04:19:59 <KiMoS> ohh
04:20:39 <KiMoS> anyways ciao   :)
04:20:47 <xerox> ciao :)
04:20:58 <xerox> btw it's difficult to explain the real difference
04:22:06 <KiMoS> maybe you cant expain it good?  :
04:22:42 <xerox> yeah, it's just because of my poor english (;
04:22:56 <KiMoS> :)
04:29:04 <vdrab> Hi all. sorry to barge in in the middle of this fine conversation
04:29:35 <vdrab> a quick question : how can you refer to field names in data records
04:30:35 <vdrab> for instance, i have a data type "data Mydata = Data { field1 :: Int, field2 :: Bool }
04:31:37 <vdrab> suppose i want to write a function that returns, say, which fields in that type are Boolean. meaning, i have to be able to return a list of field labels? what objects are field labels in haskell? functions?
04:34:18 <xerox> dunno, sorry
04:35:03 <vdrab> no probs, just thought some or other haskell wizard on here would know
04:35:17 <tromp> field labels are function names
04:35:20 <Iter> heh, I'm not much of a haskell expert.  It's just that this channel has the most interesting dicussions on freenode :)
04:35:29 <vdrab> anyone be interested to know if/when i do find out?
04:35:41 <tromp> which are not first class
04:35:45 <vdrab> tromp: function names?
04:35:49 <vdrab> i see
04:36:03 <vdrab> hmm.
04:36:50 <tromp> ask hugs for the type of field1
04:37:08 <tromp> it's simply Mydata -> Int
04:38:04 <vdrab> but i cannot represent the function name or pass it to other functions, is that it?
04:38:15 <tromp> you might want to look at THIH
04:38:22 <tromp> and template haskell
04:38:34 <vdrab> what's THIH?
04:38:41 <tromp> Typing Haskell in Haskell
04:38:51 <tromp> see haskell.org or google
04:38:56 <vdrab> cool
04:39:17 <tromp> you can do what you want with the quotation monad
04:39:20 <vdrab> thanks a lot, i'll do some more sniffing around before trying a different approach
04:39:26 <vdrab> quotation monad?
04:39:46 <tromp> that's part of  template haskell
04:40:12 <vdrab> right
04:40:28 <tromp> basically represent haskell source as data
04:40:29 <vdrab> that should get me started
04:41:04 <tromp> happy reading
04:41:40 <vdrab> thanks ;-)
05:14:26 * dblhelix is back (gone 01:11:04)
05:28:39 <kosmikus> dblhelix: no
05:28:54 <dblhelix> kosmikus: ok, thanks
05:35:02 <boegel> hey kosmikus
05:51:52 <boegel> hey yaarg
05:52:58 <bourbaki> moin
05:53:03 <boegel> hey bourbaki
05:53:43 <bourbaki> boegel: any progression with your refraction?
05:54:18 <boegel> bourbaki: not really...
05:55:33 <boegel> I haven't worked on it since the last time we met... I think that bit is the hardest bit of raytracing... you have to take several things into account (light behind object, inside object, normals pointing in the opposite direction, ...) which you don't have to worry about with non-transparent objects
05:57:29 <boegel> bourbaki: and I can't get my raytracer to reproduce the image that wolfman8k made... at least not exactly the same...my objects appaer closer together somehow
05:58:24 <boegel> bourbaki: this is the closest I get... http://studwww.ugent.be/~kehoste/thesisPublic/psychedelic.png
06:01:01 <Muad_Dibber> aloha
06:01:59 <boegel> hello Muad_Dibber
06:02:06 <Muad_Dibber> :)
06:17:55 <boegel> heya Cleo
06:20:24 <Cleo> boegel: hi :)
06:26:42 <shapr> d00d, wazzup?
06:27:27 <shapr> hej r3tex 
06:27:28 <boegel> shapr: who are you talking to ?
06:27:35 <shapr> boegel: um, me!
06:27:46 <boegel> shapr: okay d00d
06:27:56 <shapr> 1'm  4 c00l dud3
06:28:00 <r3tex> shapr: hey =)
06:28:02 <r3tex> l‰get?
06:28:41 <boegel> b03g31 h4t35 c001 dud35
06:28:43 <shapr> kind of flat actually, how's it lying with you? ;-)
06:29:14 <shapr> I have this nice futon with a very thin mattress, nice for the back.
06:29:53 <shapr> I got some unicycle thermal trousers and leg armor today. The thermal trousers are possibly the least manly garment I have ever owned.
06:30:17 <shapr> As for code, I'm still trying to find a sane darcs integratio.
06:30:55 <shapr> boegel: love that psychedelic pic
06:30:56 <earthy> kosmikus! any idea when you'll be back
06:31:07 <boegel> shapr: :) wolfman8k's is way cooler
06:32:11 <shapr> yours is much cooler than my complete lack of raytracer =)
06:32:26 <earthy> ?
06:32:29 * shapr boings
06:32:39 <shapr> I've never written a raytracer at all.
06:32:52 * earthy wrote a raycaster once
06:32:54 <earthy> that was fun
06:33:00 <earthy> lost the code though
06:33:06 <wli> I wonder what a raytracer would look like in Haskell
06:33:15 <boegel> earthy: you can see results of my raycaster at the bottom of my webiste :)
06:33:23 <boegel> wli: I'm writing one...
06:33:42 <wli> I'm actually trying to figure out how to do some surface modelling.
06:33:42 <earthy> boegel: I've seen some of your results. :)
06:34:02 <boegel> wli: as in with NURBS and stuff ?
06:34:26 <wli> boegel: I could use that, I guess. I'm generally enough of a math geek to wing methods of doing so.
06:34:33 <boegel> earthy: which objects did you support back then ?
06:34:41 <wli> kernel performance data
06:34:57 <earthy> boegel: cubes and balls
06:35:07 <earthy> (I know, not interesting at all :))
06:35:13 <earthy> it was fun though :)
06:35:43 <boegel> earthy: I should implement support for cubes too.. now I just have spheres and (infinite) planes
06:37:26 <wli> I was going to try to do implicit piecewise C^1 cubic interpolants with some vague minimality property.
06:43:36 <wli> 20 degrees of freedom per triangular patch it appears, minus 3 interpolation constraints and 9 continuity constraints, 8 left over for minimizing whatever integral (surface area, curvature, whatever)
06:45:26 <wli> L^2 norm of Gaussian curvature looks promising
06:55:48 <Janni> I already asked that question, but got no answer. Maybe today someone is here who knows an answer. I have a graphical program. How can I prevent the command line to be viewed under Windows?
07:02:30 * earthy doesn't know
07:04:10 <dblhelix> janni: I believe that if you compile with ghc, there is a compiler switch that prevents the command box to appear
07:09:36 <shapr> y0 CosmicRay!
07:09:40 <shapr> dude, that doc kicks ass
07:09:58 <shapr> Janni: I *think* I've seen that question on ghc-users, but I don't remember the answer.
07:10:09 <CosmicRay> shapr: really?  I was going to apologize for all the innacuracies that are still in it :-)
07:10:30 <CosmicRay> shapr: well I'll get a darcs.complete.org set up later today and you can have at it
07:10:36 <CosmicRay> shapr: you familiar with docbook sgml?
07:10:42 <shapr> Most of your explanations are nearly the same as the way I explain things here on #haskell
07:10:49 <shapr> nope, no clue about docbook, but I'm not afraid to learn.
07:11:25 <shapr> Janni: have you searched the ghc-users mailing list?
07:11:39 <CosmicRay> shapr: apt-get install docbook-defguide scons gtk-doc-tools sgml2x docbook-utils jade
07:11:49 <shapr> ok
07:12:01 <CosmicRay> shapr: it's very easy to pick up once you have code in front of you
07:12:23 <CosmicRay> shapr: once you have that installed, a good reference guide will be at file:/usr/share/doc/docbook-defguide/html/docbook.html
07:12:24 <musasabi> docbook is not a nice solution, but there are no good alternatives.
07:12:29 <shapr> The output looks nice. I assume it does postscript output as well?
07:12:44 <CosmicRay> shapr: yes, plus HTML, and in a much nicer way than LaTeX2html
07:13:00 <shapr> does it allow easy inclusion of programmatic output?
07:13:12 <CosmicRay> yes
07:13:31 <CosmicRay> in fact, it also supports splitting a doc into arbitrary files, in a manner similar to an #include in C
07:13:53 <shapr> What do you think about a chapter on type system tricks?
07:14:00 <CosmicRay> so I have my Haskell source code in separate files, and they're just included in the doc
07:14:54 <CosmicRay> shapr: yep, that's good.  Basics first, more advanced stuff later.  It's perfectly reasonable to expect two chapters on the type system in a book like this.  One to introduce the basic concepts and one to talk about the stuff that you can only really grasp after you've been using Haskell for a bit
07:15:12 <shapr> I've been joking about writing a nutshell guide called something like "Encoding useful information in entertaining ways with the HM typesystem"
07:15:24 <CosmicRay> anyway, by splitting out the examples, that means that I can compile/test them like usual, and any changes are reflected in the doc.  No making changes twice
07:15:28 <CosmicRay> <grin>
07:15:47 <CosmicRay> another cool thing about docbook sgml is that you can pretty easily embed one document in another
07:16:04 <shapr> Also means you can unit test all your code by having 'Visible' output be actual output.
07:16:12 <CosmicRay> so for my tla-buildpackage system, I wrote the manpages in docbook sgml.  I also include each one as an appendix in the user's guide.
07:16:28 <shapr> nice
07:17:28 <CosmicRay> shapr: for darcs pull, all you need is http, right?  it doesn't need ssh or dav or anything, does it?
07:17:34 <shapr> only http
07:17:39 <CosmicRay> excellent.
07:18:24 <shapr> That means that you and I can update from each other without any need for picky setup. I know you already have a webserver. =)
07:18:40 <CosmicRay> will be up in 5 mins
07:18:45 <shapr> spiffy!
07:19:54 <shapr> Oh, I have to share this terribly amusing pic I found recently: http://www.scannedinavian.com/images/balanced.breakfast.jpg
07:20:18 <CosmicRay> that is cool
07:20:24 <CosmicRay> I'll have to go to a meeting in about 5 mins
07:20:30 <shapr> have fun
07:20:33 <CosmicRay> once you have that pulled, you can use:
07:20:38 <CosmicRay> scons pdf (make a pdf)
07:20:41 <CosmicRay> scons ps (make a ps)
07:20:43 <CosmicRay> scons html (make html)
07:20:51 <CosmicRay> scons -c (clean, though it's not very thorough yet)
07:21:00 <shapr> I've got it, I'll send you some patches after I've checked these six translations I've just been handed.
07:21:03 <CosmicRay> scons -c ps, etc. may be more thorough
07:21:06 <CosmicRay> heh
07:21:46 <shapr> I'm glad I can contribute positively to my fiancee's half of our business. I still find the occasional bug in her English.
07:21:47 <CosmicRay> feel free to give yourself credit wherever appropriate :-)
07:21:53 <shapr> heh, ok
07:22:36 <CosmicRay> shapr: also I will probably split out each chapter into a separate sgml file eventually.  it gets difficult to work with sometimes
07:22:48 <CosmicRay> with one huge file, that is
07:23:01 <CosmicRay> oh, apt-get install psgml if you're an emacs user.
07:23:09 <CosmicRay> it's one of emacs' most powerful modes
07:23:26 <CosmicRay> it can catch a number of sgml errors as you type
07:24:51 <CosmicRay> ok, must run.  cya in about an hour...
07:25:25 <Janni> Hm. What C compiler does GHC use in windows?
07:26:46 <Janni> Ah, in its bin-directory is a file "gcc.exe"...
07:36:24 <shapr> hej bringert 
07:51:03 * dblhelix is away: brb
07:51:25 * shapr is aweigh: avast ye landlubbers!
07:53:28 <bringert> hej shapr
08:02:26 <shapr> Greeting Mr. Drake.
08:04:37 <shapr> hej ski
08:04:54 <ski> hej pÂ dig, shapr
08:17:56 <shapr> yeesh, xemacs just freaked out
08:22:44 <Janni> OK. I got some help from #gcc. To prevent a GUI program from showing the Windows command line you have to run ghc with -optl-mwindows.
08:34:48 * esap ponders about the global variable discussion (again).
08:40:24 <ski> esap : mhm ?
08:43:46 <esap> ski: About how to implement extensible global state with the proposed explicit global state passing mechanism.
08:46:03 <esap2> what the hell?
08:46:33 * esap2 got my irc client to do some very weird stuff.
08:50:00 <ski> you flooded excessively ??
08:50:04 <esap2> I did?
08:50:27 <esap2> because I got a lots of scroll, then had to kill the client.
08:51:20 <esap2> Maybe I accidentally hit the middle mouse button :-( to paste lots of stuff. Sorry
08:51:26 <ski> it said so on quit (but i didn't notice any flood here at least)
08:51:47 <ski> mm, extensible, how ?
08:53:49 <esap2> I mean, If you have a global variable, it's usually so that you can change its value and via that configure how the system works.
08:54:49 <ski> yea ?
08:56:48 <esap> ski: and there is a proposal that you would actually pass all that global state via state monad in a separate data type intended to carry all global data. But then how do you exactly extend it.
08:57:34 <esap> ski: It's at least a problem if you're writing a library.
08:58:20 <esap> ski: You've read http://haskell.org/hawiki/GlobalMutableState ?
08:59:27 <ski> hm, yes
09:00:12 * shapr sighs
09:00:18 <shapr> xemacs has so lost it.
09:00:31 <esap> ski: The only good approach I know is using existentially quantified predefined 'places' for the state, but then the interface to that state is completely fixed, which doesn't sound like a good idea.
09:00:39 * shapr sees the writing in the sky... time to switch to Yi!
09:00:59 * esap prefers ordinary emacs anyway.
09:01:26 <musasabi> esap: there is the functional pearl on passing configuration data as typeclass instances.
09:02:42 * esap needs to read it.
09:03:27 <wli> wow, "special position" happens a lot with various integer coordinates and general cubic curves
09:03:40 <wli> er, cubic surfaces
09:04:23 <shapr> Crap, I can't read my email. Gnus suddenly can't handle anything other than ASCII in the From: field.
09:04:27 * shapr has a small temper tantrum.
09:04:32 <wli> I'm thinking vaguely seriously about doing various kinds of integer arithmetic shenanigans to make things come out comprehensible because most of this stuff will actually be integers.
09:05:17 * shapr pulls the latest Yi
09:05:47 <wli> remind me of raytracing/etc. algorithms once I actually get somewhere wrt. constructing interpolants
09:07:13 <shapr> There's the exact real code that Pseudonym constructed from some papers.
09:07:28 <shapr> That might make your integer arithmetic shenanigans easier.
09:08:31 <wli> shapr: Actually it's unlikely it will. Most of what I'm going on about involves doing gcd things from abstract algebra (more typically used for Smith normal forms) during row reduction.
09:08:59 <wli> basically to avoid fractions.
09:09:03 <shapr> ah
09:10:59 <shapr> dons: I like the new undo support. way spiffy!
09:11:52 <tuomov> undo should have some timing based grouping to be usable..
09:12:11 <bringert> nice when you can reduce memory use by 40% by just using different flags to happy and alex
09:13:08 <tuomov> actually, joe and jed seem to do undo on per-line basis
09:13:48 <tuomov> all consecutive changes on a single line are grouped into single undo
09:14:01 <tuomov> of course, we should do this on parse tree basis :)
09:27:50 <wolfman8k> Janni: np
09:29:27 <ski> (esap : hmm, (reading on Atom), could possibly be related to my recent thought on quotients ..)
09:31:18 <esap> ski: quotients? hmm.. how?
09:31:30 <ski> half-baked thoughts ..
09:31:47 <bringert> in a heap profile, does "[]" mean empty list or cons cell?
09:34:22 <ski> esap : we could imagine changing the internal representant of an equivalence class, if we ensure we stay in the same class
09:34:51 <esap> ski: right, of course, you're right.
09:35:10 <ski> esap : was thinking earlier on splay data structures ..
09:35:28 * CosmicRay returns
09:35:42 <bringert> ah, ok, seemed to be both
09:35:57 * aleator comes to conclusion that c++ is evil.
09:36:06 <wli> novel
09:36:11 <ski> (esap : also, there was an interesting idea (how useful ?) i got, reading a paper on ST-monad)
09:36:16 <wli> innovative
09:36:32 <wli> earth-shattering shockingly unexpected
09:36:52 <wli> Not one soul on this earth saw that one coming.
09:37:08 <ski> esap : but my bro' tells me to stop chatting and help him coding on his school C project :(
09:37:17 <esap> ski: hehe :-)
09:37:51 <esap> ski: just confuse him with some category theory, he'll never ask again :-)
09:38:40 * esap actually should get something to eat as well...
09:38:56 * ski 's brother bashes esap's head
09:39:14 * ski groans
10:06:27 <wli> esap: nah, just befuddle him with a kernel written from scratch
10:40:50 * CosmicRay returns again
10:42:28 <xerox> yo!
10:42:34 <xerox> pizza-time, yea, /me goes
10:43:07 <CosmicRay> everyone always leaves when I show up.  hmmm....
10:43:08 <CosmicRay> :-)
10:43:22 * shapr swears at emacs
10:45:01 * stepcut swears at YI
10:47:11 <vegai> smart of you to do it after he's gone :P
10:48:39 <wolfman8k> anyone have a working link for the fudget papers?
10:49:32 <stepcut> ;)
10:49:55 <wolfman8k> ?
10:50:32 <stepcut> http://portal.acm.org/citation.cfm?id=165228&dl=ACM&coll=portal
10:50:33 <stepcut> ?
10:51:35 <wolfman8k> thanks dude!
10:51:47 <stepcut> thank you scholar.google.com
10:52:30 <wolfman8k> what's that?
10:52:41 <vegai> a wet dream, apparently
10:52:42 <CosmicRay> http://scholar.google.com/scholar/about.html#about
10:52:47 <CosmicRay> very interesting
10:52:54 <vegai> oh, not at all
10:53:01 * vegai was trying scholar.google.fi =)
10:53:09 <vegai> coolness extreme.
10:53:25 * CosmicRay learned at least one thing today, then :-)
10:54:22 <irce> expression (unexpected `;', possibly due to bad layout) 
10:54:28 <irce> whatta heck ?
10:54:37 <Igloo> Your indentation is wrong
10:55:36 <stepcut> I got that error last night! But that was while parsing an XML document that contained an &...
10:57:19 <raboof> scholar.google.com - some kind of citeseer i guess?
10:57:32 <stepcut> yeah
10:57:59 <stepcut> one nice feature is it groups all occurances of a pdf under one link, so you can try them all til you find a working link
10:58:21 <irce> Igloo: how do I know what it should be ?
10:58:49 <wolfman8k> will the fudgets library work on a modern gnu-linux distro?
10:59:42 * Igloo doesn't have a better reference than the Haskell 98 Report. Sane layout generally works, though.
11:00:27 <marcot> Hello, what does the ! symbol in data declaration do?
11:00:50 <wolfman8k> what are oracles?
11:01:42 <irce> think I need to change editor
11:04:12 <Cale> irce: which compiler are you using?
11:04:47 <irce> hugs98
11:05:38 <Cale> I find that ghc tends to give more useful errors -- you might just try loading your program in ghci and seeing if it gives a more comprehensible error message as to what is wrong.
11:06:14 <Cale> the basic idea about layout is that things which are inside other things need to be indented more than them
11:06:15 <ski> marcot : makes constructor argument strict
11:07:12 <marcot> ski: ok, but what is this strict thing?
11:07:52 <Cale> irce: if you want, you can post the code somewhere, and we can probably find the problem
11:11:48 <marcot> What's the use of using the data D = Cons { field1 :: Int, field2 :: String} instead of data D = Cons Int String
11:13:37 <stepcut> macrot: well, if you have a lot of fields, getting data out via labels can be nice
11:14:02 <Matt-W> marcot: it can also make adding new fields easier, as it is likely to require less modification of existing code
11:14:23 <stepcut> macrot: especially if you add and remove fields on occasion -- a postition based extraction might type check corrected after a deletion even though it really ought to fail
11:14:26 <mflux> marcot, you can also name the fields more imaginatively?-)
11:14:38 <mflux> it's maybe not that much better than field1, 2, 3, .. ;)
11:15:08 <marcot> So it's just a documentation thing?
11:15:14 <Matt-W> no
11:15:20 <Matt-W> it's a maintainability thing
11:15:49 <marcot> Ok, thank you all.
11:15:52 <mflux> but, it's a lesson that can be learned. I did. not in haskell though.
11:15:53 <Matt-W> I was actually thinking today I wish I'd used them to model state in my dissertation project, because I could have added an extra field without modifying any of the existing state extraction and update functions
11:17:47 <irce> Cale: thanks, I'll post in a while. 
11:24:42 * CosmicRay curses at hugs
11:27:37 <Cale> Hugs seems mostly best for when you really want an interpreter which starts rather quickly (ghci can have quite a bit of a delay). GHCi is a whole lot nicer to use for debugging, I find.
11:28:28 <CosmicRay> I agree
11:28:38 <CosmicRay> unforuntately as a library author, I don't have the luxury of ignoring it :-)
11:28:51 <CosmicRay> hugs doesn't like this:
11:28:52 <CosmicRay> type CPResult a = MonadError CPError m => m a
11:29:01 <CosmicRay> and manually expanding it every time it's used is going to really stink.
11:29:35 <Cale> hmm
11:30:26 <CosmicRay> ghc has no problem with it.
11:30:42 <CosmicRay> I've tried all the different permutations I, or several others, can think of, and hugs just doesn't want to take it.
11:30:55 <CosmicRay> you get credit in the changelog if you solve it :-)
11:31:32 <stepcut> anyone know if HSQL / haskelldb has been cabalized ?
11:32:50 <CosmicRay> stepcut: I have done that.
11:32:52 <CosmicRay> for hsql.
11:33:10 <stepcut> CosmicRay: is it online anywhere?
11:33:20 <CosmicRay> yes, let me make sure the latest version....
11:33:25 <stepcut> CosmicRay: or perhaps in debian  =)
11:33:31 <CosmicRay> stepcut: it's in incoming
11:33:43 <stepcut> nice
11:34:07 <CosmicRay> stepcut: you can fetch it from my debian repo with arch
11:34:51 <stepcut> whats the url for your archive ?
11:34:57 <CosmicRay> file jgoerzen@complete.org--debian/haskell-hsql--debian--1.0 from http://arch.debian.org/arch/private/jgoerzen/debian
11:35:04 <CosmicRay> stepcut: are you familiar with arch?
11:35:17 <CosmicRay> s/file/category/
11:36:16 <stepcut> CosmicRay: very!
11:36:27 <CosmicRay> ok cool, then that should do ya
11:36:33 <stepcut> tla categories | wc
11:36:33 <stepcut>     600     600    7386
11:36:35 <stepcut> :)
11:36:40 <CosmicRay> I'm doing a push-mirror now to make sure the latest version is up
11:36:41 <CosmicRay> heh
11:37:26 <CosmicRay> only 28 here
11:37:45 <CosmicRay> more at home but still probably not more than 100 :-)
11:39:33 <stepcut> archive already registered: jgoerzen@complete.org--debian
11:39:34 <stepcut> hehe
11:41:05 <CosmicRay> <g>
11:41:37 <CosmicRay> you know you're famous when people on irc forget they ever saw your code :-)
11:41:51 <CosmicRay> or infamous....
11:42:38 <CosmicRay> that parody of shapr was a riot the other day
11:44:22 <CosmicRay> btw, speaking of cabalizations, has anybody done hsshellscript?
11:45:13 <stepcut> CosmicRay: no idea, any idea if someone has cabalized haskelldb ?
11:45:15 <CosmicRay> stepcut: are you planning to package up haskelldb?
11:45:17 <CosmicRay> heh
11:45:22 <CosmicRay> afaik no
11:45:38 <stepcut> CosmicRay: then, yes, I guess I am planning to :)
11:45:42 <CosmicRay> excellent
11:45:52 <CosmicRay> feel free to use that hsql package in your build-dep
11:46:01 <stepcut> cool
11:46:05 <CosmicRay> though I am not sure I have the library dependency logic exactly right
11:46:34 <CosmicRay> the way hsql is written, every program built with -package hsql will link in the libraries for postgres, mysql, odbc, and sqlite
11:46:42 <CosmicRay> which stinks, but I don't know how to solve it
11:47:19 <CosmicRay> at least cabal's generated ghc pkg file doesn't set auto=true like upstream does.
11:48:21 <stepcut> heh
11:48:56 <CosmicRay> yeah.  delete mysql off your system and suddenly your lambdabot doesn't start anymore because libmysqlclient is gone.
11:49:03 <stepcut> heh
11:49:23 <Cale> CosmicRay: yeah, that syntax is definitely an extension which hugs doesn't seem to support
11:49:50 <CosmicRay> cale: rats, but thanks for the answer.  from reading the docs it looked like it would, but I was never quite sure
11:49:58 <CosmicRay> Cale: so my only option is to manually expand it?
11:50:38 <Cale> I'm not sure -- there might be some hackery you could do for hugs.
11:51:23 <stepcut> CosmicRay: can you have multiple enrtries in the packages file? -package hsql-mysql, -package hysql-postgresql ?
11:51:30 <CosmicRay> hmm.
11:51:45 <CosmicRay> those are defined as separate modules in hsql.
11:51:47 <CosmicRay> that just might work.
11:52:18 <CosmicRay> as long as cabal lets me specify different link options for different packages.
11:55:38 <Cale> I wonder whether requesting that as a feature in hugs would be worthwhile. Apparently, GHC type synonyms are more flexible in that type validity is checked only after expanding all type synonyms.
11:56:23 <CosmicRay> Cale: I'd like to, but I am not well versed enough in the lingo of haskell typing to be specific enough about what I want
11:56:35 <CosmicRay> I could say, "hey, make this work" but I don't think that'd quite cut it :-)
11:57:37 <Cale> If I'm not mistaken, you'd want to point them at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#TYPE-SYNONYMS
11:58:20 <CosmicRay> that does look right.
12:00:06 * CosmicRay submits.
12:00:07 <CosmicRay> thanks.
12:07:02 <jadrian> hello
12:07:09 <CosmicRay> hi jadrian
12:07:14 <jadrian> hi CosmicRay 
12:08:20 <jadrian> is there something like catMaybe but for generic MonadPlus types?
12:08:30 <jadrian> that is, similar to mplus
12:08:38 <jadrian> but that returns a list of elements 
12:08:45 <jadrian> instead of just the 1st
12:09:27 <jadrian> s/mplus/msum
12:09:35 <ibid> what would it do?
12:09:57 <shapr> CosmicRay: is there a tag for 'author notes' ?
12:10:03 <CosmicRay> DAMN YOU HUGS PIECE OF SHIT
12:10:06 <shapr> oy
12:10:19 <shapr> CosmicRay: having a bad hugs day?
12:10:28 <ibid> do you hate hugs? :)
12:10:36 * vegai hugs CosmicRay 
12:10:39 <CosmicRay> yes.  apparently it also does not accept => during the definition of the type of a named field in a data structure
12:10:40 * shapr hugs CosmicRay 
12:10:52 <CosmicRay> <grin>
12:10:52 <jadrian> ibid: foo[Just 1, Nothing, Just 2 ] = [Just 1, Just 2]
12:10:57 <CosmicRay> data ConfigParser = ConfigParser 
12:11:00 <CosmicRay>       defaulthandler :: MonadError CPError m =>
12:11:01 <CosmicRay>                         (ConfigParser -> SectionSpec -> OptionSpec -> m String),
12:11:04 <CosmicRay> does not work.
12:11:21 <CosmicRay> again ghc works fine
12:11:25 <jadrian> ibid: msum returns the 1st non-Nothing
12:11:39 <ibid> yeah, i knew that
12:11:50 <jadrian> ibid: msum [Just 1, Nothing, Just 2 ]
12:11:53 <jadrian> Just 1
12:11:53 <CosmicRay> err I ommitted a { from the paste but you get the idea
12:11:54 <ibid> just could not figure out how it generalizes to returning a list :)
12:11:56 <jadrian> I wanted them all
12:12:02 <CosmicRay> shapr: what do you mean by author notes?  comments that don't print?
12:12:12 <CosmicRay> or footnotes?
12:12:14 <jadrian> ibid: well just return all the non-Nothings
12:12:17 <shapr> comments that don't print
12:12:28 <ibid> jadrian: yeah, your first reply told me that :)
12:12:50 <jadrian> I'd use catMaybe
12:12:54 <shapr> for example, I wondered whether it would better to say that functions in Haskell work like functions in math, a single repeatable output for the same input.
12:13:12 <jadrian> but I just changed to a (Either Err) a Monad
12:13:23 <jadrian> Left Err for errors
12:13:37 <jadrian> and Right a for successful computations
12:13:42 <CosmicRay> shapr: <!-- foo bar -->, same as html
12:13:45 <shapr> ok
12:13:46 <ibid> jadrian: how do you, in general, detect a failed computation? i don't see how one could implement such a function
12:13:58 <ibid> (special cases of course can be implemented)
12:14:12 <jadrian> ibid: well how does msum work?
12:14:21 <CosmicRay> shapr: I usually put FIXME or some other searchable pattern around stuff like that
12:14:33 <ibid> jadrian: recurses using mplus?
12:14:34 <CosmicRay> shapr: fwiw, I prefer to pull patches rather than have them sent via darcs send
12:14:43 <Cale> msum "combines" two monadic values in some way for which "mzero" is the identity
12:15:00 <ibid> Cale: you are talking about mplus, i gather :)
12:15:01 <shapr> CosmicRay: I'm using "shae:" and pulling is cool. I prefer that too.
12:15:05 <jadrian> ibid: hmm right...
12:15:06 <Cale> mplus
12:15:07 <Cale> yeah
12:15:15 <Cale> msum is just folded mplus
12:15:17 <CosmicRay> shapr: excellent.
12:15:17 <jadrian> ibid: let me try and implement it myself and then I'll come back to you :)
12:15:23 <ibid> :)
12:15:27 <jadrian> ibid: seemed to make sense just a while ago...
12:15:49 <Cale> You might be able to do something by assuming that the type is in Eq as well
12:15:50 * ibid goes to bed, bbl
12:16:15 <Cale> i.e. filter (/= mzero)
12:16:35 <ibid> Cale: are all failed computations guaranteed to equal mzero?
12:16:39 <jadrian> nope
12:16:40 <Cale> no
12:16:48 <ibid> then that's not useful
12:17:01 <Cale> That's the closest thing I can come up with using MonadPlus
12:17:08 <ibid> (i asked in the context of MonadPlus, of course)
12:18:07 <ibid> but i'm off, really
12:18:47 <Cale> well, it does generalise catMaybes at least
12:18:50 <irce> how do I make a string from an integer? just need to print an integer 
12:19:01 <Cale> show 15 = "15"
12:19:31 <Cale> print n will show n and then putStrLn the result
12:20:11 <irce> ok thanks
12:20:34 <jadrian> ibid: nevermind... :-/
12:20:40 <jadrian> Am I missing some useful monad?
12:21:07 <Cale> What sort of effect are you going for?
12:21:34 <jadrian> something like the catMaybe, I want to ignore failed computations
12:21:54 <jadrian> thar would be Nothing (Maybe), Lefts (Either a), [] (List)
12:21:55 <Cale> And you want it to work for any monad?
12:22:13 <Cale> Well, there's no universal way to represent failure.
12:22:31 <jadrian> not for any monad, I'm wondering if there is any monad that supports something like this
12:22:32 <Cale> (there's calling fail, but in some monads, that just crashes)
12:22:47 <jadrian> that Class of monads
12:22:54 <jadrian> at first it seemed MonadPlus
12:22:58 <Cale> Well, you could make one
12:23:17 <jadrian> with MonadPlus I can get the 1st non failed computation with msum
12:23:55 <jadrian> Cale: yeap, I could, one way seems to be just adding a method   success :: m a -> Bool
12:24:06 <Cale> It just happens to be, due to the way that mplus is defined on those monads.
12:24:37 <jadrian> yes the thing is, it is "natural" to use it that way, or at least you can take advantage of it that way
12:25:26 <Cale> generally, mplus/mzero is going to be defined reasonably sensibly. But if there are multiple things in your monad which could count as "zero", then you'll have problems.
12:26:07 <jadrian> exactly
12:26:24 <jadrian> maybe I should be using MonadError...
12:28:11 <jadrian> eh... oh well, I'll think about it later
12:28:26 <jadrian> for now I'll just filter out all Lefts...
12:30:00 <ski> jadrian : you want something like  (MonadPlus m,MonadPlus n) => m (n a) -> m a  ??
12:32:08 <Cale> ski: he wants something which simply filters out those elements of an [m a] which are considered "failed" computations.
12:32:46 <CosmicRay> and a failed computation is a Left something?
12:32:49 <ski> hm
12:33:01 <ski> and return [m a], then ?
12:33:31 <Cale> yeah
12:34:38 * CosmicRay releases MissingH 0.7.0 with ConfigParser
12:35:28 <jadrian> hmm
12:36:06 <jadrian> ski: I can see something with that signature working for me too, depending on what it does
12:36:11 <Lunar^> CosmicRay: You are the author of OfflineIMAP ?
12:36:20 <CosmicRay> Lunar^: yup
12:36:34 <Lunar^> CosmicRay: I've never made the link since your recent post on haskell ML
12:37:00 <CosmicRay> I hope it is good that I'm the author of OfflineIMAP :-)
12:37:01 <jadrian> ski: in my case m would be list, n would be Either Err
12:37:08 <Lunar^> CosmicRay: Are you only interested in working on the client side ? 
12:37:28 <CosmicRay> Lunar^: for IMAP, yes.  I do network server work for other things.  not much that's publically-available though
12:37:47 <CosmicRay> Lunar^: except for PyGopherd, which is a gopher/http/wap server
12:37:53 <Lunar^> CosmicRay: I'm dreaming of an integrated virtual mail server with SMTP, POP3, IMAP and Webmail
12:37:54 <jadrian> ski: and it would return a list with the  just the 'as' in  Right a 
12:38:12 <Lunar^> CosmicRay: Peter Simons' postmaster is already a first step
12:38:13 <ski> jadrian : i was thinking of some kind of lifting from n to m, above ..
12:38:17 <CosmicRay> Lunar^: if memory serves, that is what the cyrus people are building
12:38:45 <CosmicRay> Lunar^: I run exim4, courier, and imp right now.  pretty pleased with them
12:38:49 <CosmicRay> especially exim4
12:39:01 <Lunar^> CosmicRay: sure, but it's 4 software, with different configs et al
12:39:02 <ski> jadrian : e.g. map (_ :: Maybe a -> [a])  and then join the resulting [[a]]
12:39:19 <CosmicRay> Lunar^: true, but the only config of much difficulty or consequence is for the smtp server
12:39:35 <CosmicRay> I guess imp requires a database, but it wouldn't have to be so
12:39:36 <Lunar^> CosmicRay: anyway, I would be glad if you write Maildir modules, anyway
12:39:42 <CosmicRay> I probably will
12:39:55 <jadrian> ski: yeah right
12:40:02 <CosmicRay> maildir is a lot easier to get right than mbox
12:40:12 <Lunar^> CosmicRay: I think so
12:40:20 <jadrian> ski: I just can't see how to define that map mapping in the general case
12:40:37 <CosmicRay> Lunar^: that's why I don't do mbox in offlineimap.  some have asked, but I don't care to write it and nobody else has sent patches either, so there it sits.
12:40:54 <CosmicRay> shapr: http://gopher.quux.org:70/devel/missingh/html/MissingH.ConfigParser.html
12:41:26 <jadrian> or maybe I can
12:41:53 <jadrian> or maybe I can't...
12:42:03 <jadrian> ski: well the problem seems the same
12:42:04 <ski> Monads are Functors
12:42:35 <ski> the prob would be if n isn't a "submonad" of m in uneful cases, i think
12:42:43 <jadrian> ski: yes... we can fmap them...
12:43:02 <musasabi> CosmicRay: about the interface.
12:43:07 <ski> or mmap or whatever it's called
12:43:17 <CosmicRay> musasabi: sure, go ahead
12:43:18 <jadrian> ski: I don't think that would be a problem...
12:44:16 <musasabi> CosmicRay: readConfig :: ConfigSource a => a -> IO (m ConfigParser)
12:44:29 * shapr is getting sleepy
12:44:41 <musasabi> or if you want to be really evil (not haskell98 though)
12:44:49 <CosmicRay> musasabi: parsing a string doesn't need to be in the IO monad though
12:44:59 <musasabi> readConfig :: ConfigSource a b => a -> b
12:45:00 <CosmicRay> musasabi: so that really just leaves a Handle or a FilePath
12:45:11 <CosmicRay> heh
12:45:19 <musasabi> class ConfigSource a b | a -> b ;)
12:45:25 <musasabi> but that is kind of evil.
12:45:38 <CosmicRay> yes, and also I don't understand it :-)
12:45:44 <CosmicRay> the "| a->b" bit
12:45:52 <musasabi> That is a functional dependency.
12:45:55 <CosmicRay> MonadError has that too and I've never figured out what it means
12:46:51 <CosmicRay> musasabi: what does that mean thuogh?
12:47:04 <CosmicRay> that there's a function somewhere that takes an a and returns a b?
12:47:31 <ski> the type a uniquely determines the type b
12:47:49 <ski> so one can't have both  instance A B0   and instance A B1
12:47:50 <CosmicRay> hmm.  interesting.
12:48:21 <musasabi> CosmicRay: that is very nice for creating functions like that.
12:48:42 <CosmicRay> musasabi: any other comments on the interface?  (The usage of the Error monad stuff particularly?)
12:49:10 <ski> this means that if the type system knows that  (SomeClass A b) => ..b.. then it can subst the correct B for the var b (instead of give an ambiguity error)
12:49:12 <musasabi> CosmicRay: personally I would just use Control.Exception, but I know many people who prefer the current scheme.
12:50:09 <musasabi> most haskell libraries use functionNames but that is a minor syntactic issue.
12:50:12 <Lunar^> CosmicRay: Why do you still use gopher, btw ?
12:50:33 <CosmicRay> Lunar^: fun, mostly
12:50:45 <Lunar^> CosmicRay: ok
12:51:11 <CosmicRay> Lunar^: there's a bit of an explanation in http://gopher.quux.org:70/About%20This%20Server.txt
12:51:22 <musasabi> get could also be made more evil and polymorphic, but it is debatable whether that would make things clearer.
12:51:31 <CosmicRay> Lunar^: some others have written about it http://gopher.quux.org:70/Software/Gopher/whygopher
12:51:48 <CosmicRay> Lunar^: also, it's really very easy to write a gopher server or client
12:52:08 <CosmicRay> Lunar^: so if you like to tinker with networking, it's an easily-debugged way to do it
12:52:14 <musasabi> class Get_C a where get :: MonadError CPError m => ConfigParser -> SectionSpec -> OptionSpec -> m a ; instance Get_C Bool where get = ...
12:52:26 <musasabi> but I am not sure whether that is worth it.
12:52:32 <CosmicRay> musasabi: hmm, good point.
12:52:56 <musasabi> that would work like read..
12:53:08 <CosmicRay> musasabi: yeah, for just bool vs. string, maybe not.  I do have a getnum in there.  I suppose it could be generalized to read.
12:53:37 <CosmicRay> but then, of course, people could just do a read :-)
12:56:12 <musasabi> but people want to use more liberal syntax
12:56:31 <musasabi> e.g. "1" "0" "true" "false" "TRUE" ...
12:57:03 <musasabi> at least if I remember python.
12:57:31 <musasabi> CosmicRay: but that looks quite nice - please drop a line when you are getting forward with it..
12:57:40 <CosmicRay> musasabi: it's done
12:57:48 <musasabi> (I could use a better config file parser in a few places)
12:57:57 <CosmicRay> right, that is why there is a dedicated getbool
12:58:23 <CosmicRay> http://gopher.quux.org:70/devel/missingh/html/MissingH.ConfigParser.html#v%3Agetbool
12:58:42 <musasabi> I think I will use a typeclass wrapper for get so I can write special parsers for my own newtypes.
12:58:58 <CosmicRay> that sounds interesting
12:59:03 <musasabi> (dns server code and want to parse stuff not generally usefull for many people)
12:59:12 <CosmicRay> musasabi: thanks for the feedback.  I appreciate it, and take patches :-)
12:59:20 <musasabi> CosmicRay: is that in darcs or should I just download it?
12:59:31 <CosmicRay> musasabi: it's in arch, but the tarball is current
12:59:49 <CosmicRay> so either one works
12:59:54 <musasabi> ok, I'll just fetch that instead.
13:04:44 <Lor> Hm, could someone suggest some compiler references about compiling with continuations?
13:04:52 <Lor> _Besides_ the Appel book, that is.
13:06:36 <Lor> Continuations seem like a natural way of representing the flow of control: a continuation call is just compiled to a jump (or to nothing, if the code you'd jump to happens to be right after where you are now).
13:07:17 <Lor> But I'd like some reference to techniques about how to naturally detect which continuations (and other lambdas) are allocatable on the stack.
13:08:23 <wagle> i think amir sabry's thesis work was in part to show the equivalence between cps and anf
13:08:53 <wagle> (anf == a normal form from moggi's papers)
13:09:06 <Lor> It would be nice to have some general technique that would compile CPS code to "normal" stack-allocating machine code, and would also support things like inner functions (which extend the environment, but only temporarily so they can use stack too)
13:09:15 <Lor> Yeah, I know anf.
13:09:54 <esap> lor: I have been beginning to think stack is orthogonal to (at least some variations of) continuations.
13:10:32 <esap> lor: So my answer would be that you are not likely to find it.
13:10:36 <wagle> i dunno..  i think of a continuation as sortof an encoding of the stack into a procedure
13:10:40 <Lor> When you do a non-tail function call, what do you push in the stack? A return code pointer and an environment. What is in a closure? A code pointer and an environment.
13:11:26 <Lor> I'd like to have more insight into this.
13:12:03 <esap> lor: think coroutines, and contrast them with function calls. Then map coroutines and continuations.
13:12:12 <Lor> The only way in which a "continuation" pushed into the stack is special is that a part of its environment is in the stack.
13:12:35 <wagle> two different environments
13:13:04 <wagle> the stack environment is the args..  the closure environment is the free references
13:13:43 <Lor> Yeah, but you lose that distinction after CPS conversion.
13:14:11 <wagle> not in my compiler..  hmm
13:14:55 <esap> lor: One big difference between stack and continuations is that when you use stack, you know the structure of the stack already at compile time [at least usually :-)]. With continuations, the structure may change at run-time.
13:15:10 <wagle> the lambda expressions my cps created were treated either as let-expressions or full-fledged closures
13:15:12 <Lor> {x}(lambda (y) (+ (* x x) (* y y))) --> {x}(lambda (y k) (* x x {y}(lambda (xx) (* y y {xx}(lambda (yy) (+ xx yy k))))))
13:15:39 <Lor> See? The parameter y became a free variable in the continuation closure.
13:15:56 <Lor> esap, yeah, that's what you need flow analysis for.
13:16:11 * Lor 's been reading Shivers' 0-CFA paper...
13:16:33 <wagle> the environment in a closure is a environment to be extended by application
13:16:40 <esap> lor: ah, but my point is that if you distinguish compile-time from run-time, then you must distinguish stack and continuations :-)
13:17:54 <wagle> really?  one implementation of continuations is to wrap the stack into a (procedural) value
13:18:19 <wagle> s/stack/current stack/
13:23:17 <esap> wagle: ok I see what you mean. Stack is anyway a run-time data structure. But I'm really thinking about the lexical dependency structure that produces the stack. Each function application creates a link into the structure, and the whole thing [when you trace from main] is the structure of the stack.
13:24:50 <esap> wagle: There are some situations, such as passing functions as first-class values that require a run-time stack structure.
13:25:23 <esap> wagle: But OTOH, first-class functions are not that different from continuations anyway :-)
13:28:29 <esap> wagle: Think about the 'import' dependency structure and its relationship to function application.
13:31:56 <ski> hm
13:33:27 <ski> esap : lexical dependency structure ~= static link ?
13:33:57 <esap> ski: yea something like that. I mean the dependencies created by 'import' (and function application).
13:34:54 <ski> hm, don't see how module importion comes into the picture ..
13:35:42 <esap> ski: think of two modules, module A that defines function f and module B that imports A and uses function f via function application. You must have that import in order to use the function from the other module.
13:36:09 <ski> mhm ?
13:37:41 <ski> how would that be related to cont. or stack ?
13:38:42 <esap> ski: well function application adds things to stack, to preserve current context until you return from the function. So whenever you use the function application, you are defining the structure of the stack.
13:39:45 <ski> yea
13:39:47 <esap> ski: you might say the structure is determined by the interaction of two features, "name lookup" (which looks up the names from the scope) and "function application" (which binds that to the structure of the stack)
13:40:34 <ski> hmm
13:41:01 <ski> 'that' being ?
13:41:55 <esap> ski: 'the dependency created by name lookup'.
13:42:46 <ski> esap : and what is that dependency ?
13:43:04 <ski> esap : compile-time ? run-time ?
13:43:06 <esap> ski: compile-time.
13:43:35 * ski 's brain works a bit slow atm
13:44:19 <ski> (been awake 20.5 hours)
13:44:26 <wagle> esap: i've been thinking that the static call graph is different from the dynamic call graph
13:44:28 <esap> ski: the easiest way to understand the dependency is to see how two modules connect to each other, e.g. how you can find names from other modules.
13:45:40 <esap> wagle: yes, exactly.
13:47:13 <wagle> i was wanting to visualize both (for C, about a year ago)
13:47:55 <wagle> i'm also slow today (and busy  8/ )
13:48:31 <esap> There is interesting thing that you can divide the dynamic call graph into sections based on the "levels" defined by the static call graph.
13:48:32 <wagle> i'm sure you arent talking about inlining, but i'm not producing why not
13:49:02 <wagle> what about indirect calls?
13:49:18 <wagle> function pointers inside of data structures
13:50:33 <wagle> and if the function pointers point to closures, its going to be a different memory object each time, though you might be able to abstract all the ones for the same code/body together
13:50:34 <esap> wagle: I think they are (abstract) links between parts of the data structure.
13:52:16 <ski> esap : foo x = (bar,baz) where bar y = x + y; baz z = x * z
13:52:39 <wagle> i've spent more time thinking about this for C than a reasonable and pleasant language, but pointers are (traditionally?) hard to predict the values of
13:52:44 <ski> esap : would bar and baz "be called statically" from foo, here ?
13:52:45 <esap> ski: that's first-class functions.
13:53:15 <esap> ski: bar and baz are not called in that code.
13:53:40 <ski> hm, right
13:54:25 <esap> wagle: Pointers are pretty hard. In Haskell, I might model pointers with existential types, which are full of small tricky things.
13:54:26 <ski> too much C, that must be the answer ..
13:55:51 <ski> (.. to why i can't think properly, i.e.)
13:58:47 <esap> wagle: about the inlining, inlining is related to the compile-time structure, because inlining must have access to the code at compile time.
14:00:24 <esap> wagle: So inlining is actually using the static dependency structure.
14:02:23 * ski decides to bike home to bed
14:05:02 <irce> anybody got time to help a bit ?
14:07:13 <CosmicRay> depends on what you need help with
14:08:05 <wagle> ask the question.  if someone has the time and knows the answer, then they might be able to help.  why demand sometimes time up front?
14:10:28 <wagle> gotta love that unbounded time
14:10:51 <SyntaxNinja> wagle: it's often sorta polite when first appearing in a channel to at least try to figure out if questions are welcome.
14:11:29 <CosmicRay> SyntaxNinja: fwiw, by coincidence, it would appear that the ConfigParser I just released is capable of parsing Setup.description files out of the box
14:11:37 <wagle> well, more specificity would help that approach
14:11:41 <CosmicRay> SyntaxNinja: I have no idea if that interests you, but if so, there it is
14:12:58 <irce> http://otto-1.hopto.org/h.hs
14:13:12 <irce> need some noob help with that
14:13:53 <musasabi> CosmicRay: thanks for the tip, now it looks even more fun..
14:14:18 <irce> apparently I can't make a list even. stuck in imperative thinking I think 
14:14:37 <musasabi> irce: I think you have problems with indentation.
14:15:42 <musasabi> getInt could just getInt :: IO Int  getInt = getLine >>= readIO
14:16:16 <CosmicRay> musasabi: <grin>
14:18:17 <monochrom> There is no politeness in "can I ask a question?"  Some people claim there is, and they actually believe they are polite; but that is an illusion.  The real issue, subconsciously, is the fear of getting no response or getting ignored.
14:19:45 <CosmicRay> irce: I'll look at it in a sec
14:20:07 <CosmicRay> monochrom: Generally, if I'm visiting a channel for the first time and don't really know what's considered on-topic 
14:20:21 <CosmicRay> , then I think it polite to ask if it's kosher to ask a question on a particular topic
14:20:35 <CosmicRay> though if I've lurked somewhere before and have an idea what's going on, I'd agree with you
14:21:32 <monochrom> Generally, if I'm visiting a channel for the first time, I listen in quietly for a day to learn what's on-topic.  For newsgroups the netiquette prescribes several weeks.
14:21:39 <monochrom> Now *that* politeness.
14:21:53 <CosmicRay> yeah but netiquette and usenet seem polar opposites
14:22:07 <CosmicRay> after all, how bad can an off-topic question be among penis spam?
14:25:02 <CosmicRay> irce: I concur
14:25:09 <CosmicRay> irce: you need one more space before your "return"
14:26:03 <monochrom> In real life, real people do this.  Suppose a real person goes to a party late.  He doesn't start immediately by announcing "can I tell you a joke?" or "can I talk about my weekend?".  He doesn't even say anything (other than "what's going on?").  He just listens in to some existing conversation for a few minutes until it is the right opportunity for him to speak the right thing.
14:26:22 <monochrom> Now I don't see why it needs to be any different on IRC.
14:26:48 <CosmicRay> sometimes you can listen for a few minutes on IRC and see nothing at all even though there are 80 people in a channel
14:28:06 <monochrom> If no one says anything for a long time, anything you say cannot be too off-topic.
14:28:25 <monochrom> If your personal goal however is to be polite, lurking is the only polite thing to do.
14:29:33 <monochrom> Perhaps I'm arguing over something unimportant.  I'll stop.
14:31:12 <Muad_Dibber> yeah
14:31:16 <Muad_Dibber> better stop :P
14:32:28 <irce> CosmicRay: yes got it to work after many tries. I must be doing this the wrong way
14:33:06 <CosmicRay> irce: if I might offer a small bit of advice...
14:33:15 <CosmicRay> irce: 1) GUI programs are not the easiest way to learn Haskell
14:33:40 <CosmicRay> irce: 2) there's a pretty decent tutorial here http://www.isi.edu/~hdaume/htut/
14:33:41 <Muad_Dibber> arent there better languages to do guis in? :P
14:33:50 <CosmicRay> Muad_Dibber: nah, they all suck :-)
14:34:02 <Muad_Dibber> CosmicRay: php :P
14:34:13 * CosmicRay thwacks muad_dibber with an uninitialized variable
14:34:45 * Muad_Dibber ducks behind a lazy list
14:35:10 * CosmicRay wiels his strict list!  bwahahahah!
14:35:17 <CosmicRay> dammit, I misspelled wields.
14:36:14 * Muad_Dibber hands CosmicRay OpenOffice spellchecker
14:36:28 <irce> monochrom: I asked the question because at first I hesitated to paste that shitty source link in here
14:36:36 <CosmicRay> oh no!  red squigglies!  the horror!
14:36:52 <monochrom> I have pasted more shitty source links.
14:36:59 <irce> :)
14:37:15 <monochrom> A single link can't hurt.  It is not like you paste 50 lines of shitty code directly here.
14:38:19 <monochrom> I think most askers worry too much about how well their questions will be received.
14:44:36 <SyntaxNinja> CosmicRay: what does config parser do?
14:44:53 <SyntaxNinja> is it just a parser that handles foo: bar type files?
14:45:30 <aleator> I'm having a sleepless night and hacked a bit towards a drawing library. Anyone wish to see the test pic with three circles and splotch? ;/
14:45:40 <SyntaxNinja> aleator: yes.
14:45:50 <SyntaxNinja> as long as it's not a trojen jpeg or anything
14:46:39 <SyntaxNinja> Muad_Dibber: I just read Dune and the next two books, and I named my new computer Chani. In case I didn't mention that last time I saw you.
14:46:40 <aleator> No, it's safe. (Or I'm really suprised.) http://www.cc.jyu.fi/~aleator/test2.png
14:46:49 <Muad_Dibber> SyntaxNinja, hey
14:46:52 <SyntaxNinja> 0xc00l
14:46:53 <Muad_Dibber> thats 'not possible
14:46:59 <Muad_Dibber> the computer i'm currently at is Chani :P
14:47:04 <SyntaxNinja> really? whoa.
14:47:20 <SyntaxNinja> me too
14:47:29 <Muad_Dibber> and shaihulud, shieldwall, caladan and giediprime are all already taken :P
14:47:31 <SyntaxNinja> you must be on a different in-ter-web than me
14:47:46 <SyntaxNinja> I named one of our conference rooms "Arrakis" 
14:47:57 <SyntaxNinja> but I only really liked the first book.
14:48:00 <Muad_Dibber> yeah
14:48:02 <Muad_Dibber> same here
14:48:07 <Muad_Dibber> but i liked the first book real good :)
14:48:14 * xerox agrees
14:48:18 <SyntaxNinja> I wish I had never seen the movie, the mini-series, or read the 2nd two bookx.
14:48:23 <SyntaxNinja> I wish I could erase them from my memory.
14:48:45 * xerox hands SyntaxNinja a shiny knife
14:48:55 <SyntaxNinja> is it a crysknife?!
14:49:23 <Muad_Dibber> lol
14:49:25 <SyntaxNinja> Muad_Dibber: is chani a debian laptop?
14:49:29 <xerox> hehe!
14:49:37 <CosmicRay> SyntaxNinja: ConfigParser handles structured config files, but can handle non-structured ones too.  specs here: http://gopher.quux.org:70/devel/missingh/html/MissingH.ConfigParser.html
14:49:40 <Muad_Dibber> SyntaxNinja, no, chani is a gentoo-amd64 box :P
14:49:47 <wagle> in high school, friends strongly and successfully discouraged me from reading past the first book.  a year or two ago, i actually read them..  but got bored halfway through the last of the pure frank herbert series
14:49:49 <SyntaxNinja> meh
14:50:04 <wagle> i thought the political thought was kinda interesting
14:50:44 <SyntaxNinja> damn skippy, when did you get time to hack that together, CosmicRay
14:50:48 <wagle> as part of the dune fest, i also watched the movies and the two tv series..  8)
14:51:16 <SyntaxNinja> that's quite possibly the most well-documented module I've ever seen ;)
14:51:17 <CosmicRay> SyntaxNinja: past week or so.  I'd already written it once for OCaml so it didn't take too long to do it again.  shapr provided MonadError enlightenment :-)
14:51:20 <xerox> i didn't see the tv series :(
14:51:28 <CosmicRay> <grin>
14:51:43 <SyntaxNinja> xerox: I recently rented it from blockbuster video store.
14:52:45 <SyntaxNinja> CosmicRay: what's the license?  did you cabal-ize it yet?
14:53:07 <CosmicRay> SyntaxNinja: GPL, but I am willing to relicense parts of it for a good cause (inclusion in cabal, fptools, etc.)
14:53:09 <SyntaxNinja> CosmicRay: btw, have you been following the discussion on libraries@? there may be some interface changes that'll cause your debian scripts to break.
14:53:13 <CosmicRay> SyntaxNinja: it was cabalized out of the box
14:53:18 <SyntaxNinja> :)
14:53:23 <CosmicRay> SyntaxNinja: no, but I do have a libraries folder.  I'll take a look
14:53:50 <CosmicRay> SyntaxNinja: it's in sid (well this latest version probably hasn't propogated to the mirrors yet, but it will in 24h)
14:53:52 <SyntaxNinja> CosmicRay: there's no action-items yet, I'll try to let you know when changes happen.
14:54:00 <CosmicRay> SyntaxNinja: there are debs and debian sources at http://quux.org/devel/missingh
14:54:02 <CosmicRay> SyntaxNinja: thanks
14:54:38 <CosmicRay> I think this module is well-documented too <grin> http://gopher.quux.org:70/devel/missingh/html/MissingH.Network.FTP.Client.html
14:55:02 <SyntaxNinja> CosmicRay: well, I was thinking that if this library is pretty cool, we could maybe have cabal depend on it, but that would require licensing it as BSD and including it w/ the compilers.
14:55:34 <SyntaxNinja> that's not real necessary, but it might be a better basis to build the compiler from than the readP stuff we're using now.
14:55:42 <CosmicRay> SyntaxNinja: I include some third-party code that is LGPL'd in MissingH, but it is not in the critical path for anything you'd need for cabal or including with the compilers
14:55:44 <SyntaxNinja> btw, what do you use underneith? parsec? readp?
14:55:48 <CosmicRay> parsec
14:56:01 <CosmicRay> but as I said, the GPL is more a default
14:56:10 <SyntaxNinja> well, I'm not saying that we'd want to import all of missingH
14:56:17 <CosmicRay> if you need something under BSD for Cabal, drop me an e-mail, and I'll add a BSD license.
14:56:26 <CosmicRay> for the bits that yuo need
14:56:35 <SyntaxNinja> well, here's the thing
14:56:53 <SyntaxNinja> basically, re ross patterson's questions on the list, it would be nice to have some more generic parsing abilities
14:57:04 <SyntaxNinja> I don't want to do what he's suggesting, which is to cpp the description file (ick)
14:57:27 <SyntaxNinja> but instead to mayb ecpp or autoconf some other file that Setup could optionally read.
14:57:33 <CosmicRay> ick indeed.
14:58:10 <SyntaxNinja> so it was JUST on my mind when you posted that link.  the idea would be to provide all of ConfigParser as just a standard Haskell library...
14:58:22 <SyntaxNinja> change cabal to use that, but also allow people to use it in their Setup.description files.
14:58:26 <CosmicRay> SyntaxNinja: I would be happy to do that
14:58:30 <SyntaxNinja> anyway, I'll let you know once I get a chance to do more hacking.
14:58:41 <SyntaxNinja> my laptop is broken, but should  get it back within a few days.
14:58:53 <CosmicRay> SyntaxNinja: I've made a blanket offer to relicense anything in MissingH under the fptools license to get it included as a default part of the compilers
14:58:58 <SyntaxNinja> oh, one change to cabal is that now the description files MIGHT be named something.hsproj
14:59:08 <SyntaxNinja> CosmicRay: excellent.
14:59:09 <CosmicRay> SyntaxNinja: no prob
14:59:40 <SyntaxNinja> whew, so exciting
14:59:55 <SyntaxNinja> we're going to change the face of Arrakis!! er, I mean the Haskell libraries.
15:00:01 <CosmicRay> I want to make it easy to use Haskell as a hacker's language
15:00:14 <SyntaxNinja> yeah. me too. 
15:00:19 <CosmicRay> so, help fptools, help cabal, port the Python standard library.  world domination is next. :-)
15:01:15 <wolfman8k> this fudget stuff is cool
15:01:27 <stepcut> mmm, fudgets
15:01:29 <CosmicRay> I wouldn't put my code under BSD for just anyone, but fptools and cabal seem fitting exceptions
15:01:47 * stepcut would put his code under BSD for anyone
15:02:21 <wolfman8k> what's an Oracle?
15:02:47 <stepcut> wolfman8k: a mechanism for introducing non-determinism ?
15:02:47 <CosmicRay> well, time for me to run
15:02:49 <CosmicRay> cyall later
15:02:57 <wolfman8k> stepcut: hm....
15:29:17 <shammah> mmmm how can I install ghc on an OSX 10.2 box?
15:30:22 <stepcut> http://www.haskell.org/ghc/download_ghc_622.html#macosx
15:30:23 <stepcut> ?
15:36:12 <np_hard> fink install ghc
15:36:38 <wolfman8k> if i want to try to understand monads, is there some sort of math that i need to learn first?
15:36:42 <np_hard> no
15:36:57 <np_hard> for some notion of "understand"
15:37:21 <np_hard> naturally if you want to understand their theoretical underpinnings, you will need to know math, but that is the same as for-loops and while-loops
15:37:32 <wolfman8k> hm...
15:37:44 <wolfman8k> what math?
15:37:54 <wolfman8k> category theory?
15:37:56 <wolfman8k> lambda calculus?
15:38:00 <wolfman8k> church numerals?
15:38:06 <wolfman8k> addition?
15:38:13 <Lor> Algebra.
15:38:20 <np_hard> yes, algebra
15:38:31 <Lor> Well, category theory is just algebra on steroids. :)
15:38:33 <np_hard> but you need algebra to understand anything in computers
15:38:48 <monochrom> the "monads as containers" page is all you need.  of course some basic lambda calculus helps --- just the very basic, like you can read "lambda x. x+1"
15:38:52 <np_hard> there are algebraic representations of typical imperative languages
15:39:00 <np_hard> algebraic representations of logic programming
15:39:25 <Lor> SK is all you ever need. :)
15:39:34 <wolfman8k> SK?
15:39:46 <monochrom> To understand while loops you have to know at least lattice theory and fixpoints.
15:39:51 <Lor> Combinatory logic. Arguably the simplest turing-complete programming language in existence.
15:40:09 <Lor> Well, except maybe for http://ling.ucsd.edu/~barker/Iota/
15:40:12 <np_hard> but none of this has to do with programming with Haskell monads.
15:40:29 <Lor> Right. Never mind my rambles if you want to learn something useful.
15:40:53 <np_hard> the key thing it took me forever to get with programming in Haskell was the translation of do-notation to >>, >>=, etc.
15:41:10 <np_hard> once I got that I started to figure things out
15:41:11 <Lor> It's just cps.
15:41:51 <wolfman8k> the thing i don't get about monads is that... there are different kinds of them? IO is only one type of monad?
15:41:54 <xerox> arrows!
15:42:07 <np_hard> i still don't ever program things correctly the first time, the syntactic sugar and order of operations haven't been internalized
15:42:39 <Lor> wolfman8k, there are other monads, yes, but IO is the only one you need to understand at first.
15:42:51 <Lor> Actually, you don't need to understand monads at all, at first. Just grok IO.
15:42:53 <SyntaxNinja> and you barely "need" to understand it for a while
15:43:13 <wolfman8k> Lor: but i wanna get to the more advanced stuff... like automatic parallel execution
15:45:25 <np_hard> now here's something I noticed ... getContents and even hGetPS seem to be way slow
15:45:39 <Nioate> wolfman8k: the nomaware tutorial is very good
15:45:56 <np_hard> I was trying to do some things at work in Haskell instead of Python
15:46:01 <Muad_Dibber> g'night all
15:46:12 <np_hard> it was pretty good except for the I/O being so slow and processor intensive
15:46:19 <monochrom> There are as many kinds of monads as there are kinds of Num.
15:49:33 <shammah> stepcut: I believe that version only supports 10.3 ?
15:56:04 <stepcut> shammah: the .dmg probably only supports 10.3, but the section below indicated that their might be a way for 10.2?? Dunno, I have linux :)
15:57:41 <shammah> well I haven't been able to work out how to install darwin ports (the way mentioned).  I've tried compiling from source, but ./configure keeps complaining that I don't have ghc installed! :(
16:03:49 <np_hard> bootstrapping problem
16:04:30 <np_hard> do you need ghc? will hugs do?
16:06:07 <shammah> np_hard: I think I do.  I want to have a play with Yampa and wxFruit.
16:06:54 <np_hard> :-/
16:07:04 <np_hard> I have 10.3 and it installed from fink
16:07:10 <np_hard> wish I could be more help
16:08:41 <shammah> even fink is a pita to install on 10.2 these days.  It seems most people have abandoned it, and it's only one point release behind :(
16:12:42 <np_hard> that is an unfortunate result of Apple's preservation of "10"
16:12:58 <np_hard> those point releases are actually major revisions, which is why they cost $$$
16:17:34 <wagle> fink destroyed my /etc/X11, /usr/bin/X11, etc, then self destructed
16:18:11 <wagle> fink is a.. umm..  fink!
16:18:44 <SyntaxNinja> heh
16:19:31 <monochrom> That makes fink a sabotageur
16:19:44 <SyntaxNinja> fink: #!/bin/sh head /dev/random > /usr/bin/X11; rm /usr/bin/fink; apt-get install debian
16:19:49 <monochrom> a suicidal terrorist? :)
16:20:04 <wagle> i'm currently building up the courage to delete fink and the native X11, then reinstall
16:20:51 <wagle> if i botch it, i prolly have to reinstall everything
16:21:57 <wagle> a setback was the powerbook not recognizing my full backup on a firewire drive as a boot device
16:22:03 <SyntaxNinja> so I have a question for you guys... I work in the same building as Linus T. (different company) and was thinking of randomly emailing him and asking if I can buy him a cup of coffee downstairs.
16:22:18 <SyntaxNinja> does anyone know anything about whether he would be annoyed at this?
16:22:20 <np_hard>  transmeta is in ohio?
16:22:31 <wagle> you in portland eh?
16:22:41 <SyntaxNinja> np_hard: 1) he doesn't work at transmeta, 2) I'm not in ohio anymore :)
16:22:46 <np_hard> aaaaah
16:22:47 <SyntaxNinja> wagle: yeah
16:22:49 <np_hard> wow
16:22:53 <SyntaxNinja> he works at OSDL, I work at Galois Connections
16:22:53 <np_hard> I can be wrong sometimes
16:23:08 <np_hard> and sometimes I manage to be very very wrong
16:23:09 <np_hard> :)
16:23:16 <SyntaxNinja> np_hard: not wrong, just out of date ;)
16:23:31 <SyntaxNinja> I think I saw him today in the lobby actually.
16:23:42 <SyntaxNinja> I gave him a very serious "nod" and he gave me a look like "Does he know me?"
16:24:05 <SyntaxNinja> also, if anyone here is in portland and wants to get togehter, let me know :)
16:24:08 <np_hard> that is way cool
16:24:18 * np_hard is in ohio :-/
16:24:37 <Riastradh> SyntaxNinja, it is customary to introduce oneself before making signs of familiar greeting, you know.
16:25:08 <SyntaxNinja> Riastradh: I didn't think I should stop him and say, "hi, I'm isaac" and then give him a "nod" :)
16:25:49 <SyntaxNinja> np_hard: hm. do I know you IRL? I have lost track of who you are.
16:26:11 <np_hard> hehehe, I came in for about 3 interviews at Aetion
16:26:17 <np_hard> I think you were there once
16:26:33 <monochrom> SyntaxNinja: "hi, I'm issac" is still greeting before introducing.  You shuould use "I'm issac, hi". :)
16:26:34 <np_hard> I barely knew any Haskell then though
16:26:41 <SyntaxNinja> monochrom: heh
16:26:51 <SyntaxNinja> well, I'll send him a mail and what the hell.
16:26:57 <np_hard> which is nearly the state of things now. I think in HOFs now, which is a plus
16:27:07 <SyntaxNinja> np_hard: what's your name?
16:27:12 <wagle> HOF?
16:27:21 <Riastradh> np_hard, duh, SyntaxNinja!
16:27:23 <wagle> higher order fun?
16:27:24 <np_hard> higher order functions :-P
16:27:40 <wagle> beat ya!  8-p~~~~~
16:28:02 <monochrom> hall of fame
16:28:09 <SyntaxNinja> np_hard: I left Aetion a bit over a month ago. 
16:30:05 <stepcut> SyntaxNinja: maybe you can turn him on to hOp
16:30:27 <np_hard> moving on to bigger things?
16:32:10 <wolfman8k> are there hOp people here?
16:32:34 <wagle> i have it runnin in virtualpc
16:32:38 <xerox> goodnight
16:36:22 <wolfman8k> someone should make a haskell os in the style of squeak
16:37:19 <wagle> whats that style?
16:38:07 <wagle> learning squeak hasnt gotten to the top of my tasklist
16:38:24 <wolfman8k> not a self contained OS, but a regular application that runs on an existing os
16:38:35 <wolfman8k> squeak runs on solaris, gnu-linux and windows
16:38:49 <wagle> so does haskell
16:40:49 <wagle> squeak seems to have its own (apparently clumsy) gui, which ignores the native gui
16:41:19 <wagle> but i havent managed to spend enough time to get over that initial hurdle
16:42:16 <Riastradh> Squeak's GUI isn't exactly 'clumsy.'  It is a lot more flexible than most others, but that is because Squeak runs in its own environment, not integrated into the underlying OS.
16:43:00 <wagle> so i was wondering why some people liked it..  (i know one person who switched advisors to stop getting tormented by squeak)
16:43:48 <wolfman8k> that's the whole point of squeak, it's a completely isolated environment
16:44:00 <wolfman8k> it's just like an os, but only from the users perspectiv
16:44:09 <wagle> ie, i was looking for people to say good things about it..  to motivate me to get around to learning it
16:44:32 <wolfman8k> i was planning on getting into squeak before i started doing haskell :)
16:44:36 <wagle> ohh..  like emacs..  8)
16:44:45 <wolfman8k> exactly
16:44:55 <Riastradh> Only even more extensive.
16:45:04 <wolfman8k> but squeak actually has the features for building good applications
16:45:06 <shammah> well if you're wanting encouragement... it's probably better than java :)
16:45:12 <wolfman8k> with things like multimedia and opengl and stuff
16:45:32 <wagle> your original statement made it sound like you were wanting something that wasnt self contained os
16:45:54 <Riastradh> Squeak is self-contained, but not a complete OS.
16:46:13 <wolfman8k> i didn't express myself correctly :|
16:46:30 <Riastradh> hOp runs on bare hardware; Squeak runs within an existing OS.
16:46:52 <vincenz> Hi
16:47:02 <wolfman8k> Riastradh: yeah. i want something like squeak :)
16:47:20 <wagle> i want more access to the metal
16:47:22 <vincenz> squeak is nice, it'd be nicer if it was fast tho
16:47:29 <wolfman8k> Riastradh: i'm interested in what a complete user interface environment would look like if it were inspired by functional programming
16:47:39 <vincenz> wolfman8k: callbacks :)
16:48:38 <vincenz> simple question: hugs or ghc?
16:48:49 <wagle> vincenz: yes
16:48:59 <vincenz> s/or/xor
16:49:03 <SyntaxNinja> np_hard: yeah :)
16:49:11 <wagle> vincenz: mu
16:49:14 <np_hard> SyntaxNinja: glad to hear it :)
16:49:25 <vincenz> ...
16:49:33 <wagle> vincenz: apples or oranges?
16:49:53 <vincenz> wagle: they're really that equivalent?
16:50:02 <vincenz> then why do they both exist?
16:50:22 <wagle> i'm more used to hugs, and it starts up faster, but ghci is less buggy flakey, and has a serious compiler
16:50:30 <Riastradh> vincenz, you might give more information about what you intend to accomplish.
16:50:34 <wagle> i have both
16:50:36 <vincenz> Riastradh: learn haskell
16:51:03 <Riastradh> It probably doesn't matter, then.
16:51:07 <wagle> dunno how the error message compare
16:51:47 * vincenz 's distro offers 20021120-3 as package for hugs
16:53:12 <SyntaxNinja> vincenz: sounds like debian :)
16:53:18 <vincenz> mandrake
16:53:23 <SyntaxNinja> oh :(
16:53:37 <vincenz> just curious how uptodate it is
16:53:39 * SyntaxNinja is the hugs debian maintainer; Igloo is the debian ghc maintainer
16:53:44 <wagle> ha!  another reason to call fink a fink!  i cant upgrade the fink version of hugs
16:54:24 <vincenz> someone should make squeak packages
16:54:28 <SyntaxNinja> wagle: there's a debian source package for it; I bet if you grab it, a simple "debuild" will do it, not that I know anything about fink
16:55:10 <wagle> the fink deps are all f'cked up, and i cant rebuild much of anything
16:55:21 <SyntaxNinja> ah well
16:55:38 <wagle> i can build stuff outside of fink (like ghc, etc)
16:55:51 <SyntaxNinja> apt-get build-dep hugs98 doesn't work?
16:56:00 <wagle> i finally got backups to work last week
16:57:56 <wagle> so after the next backup (onto a firewire disk i can actually boot off of), i will try to uninstall fink,  reinstall macosx's X11, and see if i can get fink to stop being a sleazebag and not install over /etc/X11 and /usr/bin/X11, etc
16:58:39 <wagle> itch scratched, i can hopefully submit that back to fink
16:58:43 <SyntaxNinja> vincenz: GHC is a compiler rather than an interpreter.  it also has an interpreter component
16:58:45 <np_hard> wagle: there is a package for apple's X11 as I recall
16:58:50 <np_hard> a placeholder
16:58:51 <SyntaxNinja> hugs is a bit easier to install sometimes, a bit more lightweight.
16:58:51 <vincenz> SyntaxNinja: *nods*
16:59:03 <vincenz> what about the compiled code?
16:59:05 <wagle> i have the macos install media
16:59:06 * np_hard should really try to learn more about fink, as he trusts it to do a lot of crap
16:59:15 <SyntaxNinja> vincenz: what compiled code?
16:59:21 <SyntaxNinja> vincenz: nhc is also a compiler, btw.
16:59:21 <vincenz> well....how does it perform?
16:59:33 <SyntaxNinja> vincenz: GHC will probably give you the best performance.
16:59:40 <wagle> fink would be just fine it is actually was meticulous about staying inside /sw
16:59:41 <vincenz> whole-code optimization?
17:00:00 <SyntaxNinja> vincenz: it's pretty sophisticated, but I don't know the details offhand.
17:00:06 * vincenz nods
17:00:15 * SyntaxNinja doesn't do much performance work.
17:00:36 * vincenz thinks functional languages should make an extra effort for whole-code optimization, givne the tendency to write small highly reusalbe higher-order funcs
17:00:43 * vincenz gets himself a new typist
17:01:00 * vincenz launches hugs
17:02:27 <vincenz> Prelude> inc n = n+1
17:02:27 <vincenz> ERROR - Syntax error in input (unexpected `=')
17:03:11 <SyntaxNinja> vincenz: you can't define things in the top-level
17:03:16 <vincenz> oh
17:03:23 <SyntaxNinja> in ghci you can
17:03:30 <vincenz> so what do I do to learn and mess around?
17:03:37 <SyntaxNinja> but it's a bit different, "let n = n + 1"
17:03:40 <SyntaxNinja> er
17:03:45 <SyntaxNinja> "let inc n = n + 1"
17:03:48 <vincenz> SyntaxNinja: that didn't work
17:03:54 <SyntaxNinja> in ghci it will
17:03:59 <vincenz> hmm
17:04:01 <vincenz> cwap
17:04:10 <SyntaxNinja> but what you should do is write it to a file and use :load
17:04:16 <vincenz> :/
17:04:19 <SyntaxNinja> or emacs and use C-c C-l
17:04:24 * vincenz is a vim user
17:04:49 <wagle> vim is not a REAL operating system.  use emacs.  8) 8)
17:04:52 <SyntaxNinja> vincenz: well, haskell expressions are sorta not meant to have side-effects, for the most part
17:05:03 <vincenz> SyntaxNinja: I know
17:05:09 <SyntaxNinja> so typing something in the interactive environment that has a side effect, like defining something, is a little odd
17:05:11 * vincenz knows ocaml
17:05:14 <SyntaxNinja> which is sorta why hugs doesn't do it
17:05:18 <vincenz> well
17:05:21 <vincenz> it's an interpreter
17:05:27 <vincenz> can't it ocnsider it as small files and :load em?
17:05:34 <SyntaxNinja> but GHCi does do it, but then you're using a slightly different syntax than you would IRL
17:05:44 <wagle> a pure haskell wouldnt have :l
17:05:50 <vincenz> hmm
17:05:59 <vincenz> all functions are automatically recursive
17:06:00 <vincenz> ?
17:06:32 <wagle> only if they call themselves
17:06:34 <SyntaxNinja> you don't need a "rec" thing like you do in ML if that's what you mean
17:06:42 * vincenz nods
17:06:52 <vincenz> so
17:06:57 <vincenz> how would I make a simple sum-type?
17:07:04 <wagle> oh..  you mean "all definitions are recursive"
17:07:37 <SyntaxNinja> vincenz: data Tree a = Leaf a | Branch (Tree a) (Tree a)
17:07:39 <wagle> data Sum = One Int | Two Char
17:07:54 <vincenz> kewl
17:08:21 <wagle> might want to add a "deriving Show" at the end:
17:08:28 <wagle> data Sum = One Int | Two Char deriving Show
17:08:40 <vincenz> yick
17:08:46 <vincenz> *** Term           : mylength
17:08:46 <vincenz> *** Type           : [a] -> Int
17:08:46 <vincenz> *** Does not match : [a] -> Integer
17:09:00 <vincenz> I was following a simple example
17:09:11 <vincenz> length                  :: [a] -> Integer
17:09:14 <wagle> hahaha..  Int!  haskells evil skeleton in the closet
17:09:53 <irce> http://otto-1.hopto.org/main.hs  does anyone know why that c <- getInt hangs to program ?
17:09:54 <vincenz> what's the func to get the head of a list?
17:10:05 <SyntaxNinja> head
17:10:06 <irce> head
17:10:08 <SyntaxNinja> @type head
17:10:08 <wagle> you are using something that takes or returns Int
17:10:09 <lambdabot> head :: forall a. [a] -> a
17:10:10 <SyntaxNinja> @type length
17:10:12 <lambdabot> length :: forall a. [a] -> Int
17:10:30 <vincenz> so what's an Integer then?
17:10:59 <monochrom> integers of unlimited size
17:11:03 <vincenz> oh!
17:11:06 <wagle> aigh!  Int is the unsafe version of Integer
17:11:16 <np_hard> what about the IOUSeS?
17:11:17 <vincenz> so why doesn't length return Integers?
17:11:29 <np_hard> Integers of unlimited size? I don't think they exist.
17:11:37 <monochrom> Int is more or less machine-word size. (actually usually one bit fewer than machine-word)
17:11:41 <vincenz> Main> 5 :: Integer
17:11:41 <vincenz> 5
17:11:49 <Nioate> in a non-strict language, they probably could
17:11:54 <np_hard> nope
17:12:07 <monochrom> @info genericLength
17:12:10 <wagle> Integers can be unpleasant about space usage
17:12:13 <np_hard> my mathematical philosophy is intuitionist
17:12:14 <np_hard> :)
17:12:37 <monochrom> Hrm why is lambdabot not responding?
17:12:39 <vincenz> odd
17:12:40 <vincenz> very odd
17:12:45 <vincenz>  5 :: Integetr
17:12:46 <vincenz> 5
17:12:56 <vincenz> Main> (length [1,2]) ::Integer
17:12:56 <vincenz> ERROR - Type error in type annotation
17:12:59 <irce> my getChar work perfectly but not getInt ? should be about the same 
17:13:02 <vincenz> (Int & Integer)
17:13:21 <wagle> lambdabot: are you busy computing bottom?
17:13:21 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:13:45 <wagle> @info genericLength
17:14:05 <wagle> lambdabot: info genericLength
17:14:06 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:14:09 <monochrom> @info List.genericLength
17:14:10 <lambdabot> -- Data.List.genericLength is a variable
17:14:10 <lambdabot> Data.List.genericLength :: forall b i. (Num i) => [b] -> i
17:14:15 <wagle> bah
17:14:39 <wagle> should at least blow you raspberries on a noMatch
17:14:39 <vincenz> nice
17:14:48 <vincenz> let f = \x->x+1 in let xs = [1,2,3] in [f x | x <- xs]
17:14:55 <monochrom> Well I would appreciate if lambdabot told me "not found" rather than just being quiescent.  Halting problem and byzantine agreement and all.
17:16:20 <SyntaxNinja> vince: map (+1) [1..3]
17:16:39 <vincenz> SyntaxNinja: I know, just testing stuff
17:16:40 <SyntaxNinja> [x + 1 | x <- [1..3]]
17:16:48 <SyntaxNinja> vincenz: I thought you might think it was cool ;)
17:17:07 <vincenz> hehe
17:17:11 <vincenz> maps are...simple
17:17:26 <vincenz> list comprehension is nifty tho, but I made a camlp4 thingy to get me list comprehension in ocaml ;)
17:17:38 <SyntaxNinja> [[(x,y) | x <- [1..5], y <- [6..10]]
17:17:48 <vincenz> I assume that's a typo
17:17:58 <SyntaxNinja> vincenz: I was more showing off the currying of the + op
17:18:05 <irce> (define start '((1 3) (2 3) (3 3) (4 3))) how do I do that in Haskell ?
17:18:11 <vincenz> SyntaxNinja: + can be curried in ocaml
17:18:25 <SyntaxNinja> oh.
17:18:42 <wagle> start = [[1,3],[2,3], etc
17:18:52 <vincenz> ((+) 1)
17:18:59 <irce> ok thanks
17:19:03 <SyntaxNinja> but look at all those parens!!
17:19:09 <SyntaxNinja> ;)
17:19:13 <vincenz> meh
17:19:25 <vincenz> lambda notation is nifty too
17:19:33 <vincenz> but again, syntactic sugar
17:19:42 <irce> I rather take the parents than the indet shit
17:19:45 <SyntaxNinja> [(x,y) | x <- [1..5], y <- [6..10], x < 3]
17:19:48 <irce> indent
17:19:51 <vincenz> irce: indent?
17:19:59 <vincenz> SyntaxNinja: I made a campl4 thingy for that
17:20:00 <vincenz> wait a sec
17:20:20 <vincenz> let l = [[x*2 for x in [1; 2; 3; 4; 5; 6;] when x mod 2 = 0]]
17:20:29 <vincenz> of course the for, in, when could be changed
17:20:33 <vincenz> that's just a syntax I chose
17:20:46 <SyntaxNinja> is that the fancy preprocessor syntax changer thingy?
17:20:49 <vincenz> yeah
17:20:50 <irce> had a bugg, a space was missing. took 3 hours to find ... 
17:20:56 <SyntaxNinja> that looks really 1337
17:21:26 <SyntaxNinja> I want someone to explain to me what can and can't be done w/ template haskell verses ocamlelp4
17:21:30 <wagle> that looks more "echo 1337 | md5sum" to me
17:21:37 <Riastradh> Template Haskell cannot extend Haskell's syntax.
17:21:42 <vincenz> camlp4 could theoretically be used to make a completely new syntax
17:21:44 <vincenz> from scratch
17:21:53 * SyntaxNinja nods
17:22:01 <vincenz> but I use it here to extend the syntax
17:22:06 <vincenz> of course there are some limitations
17:22:08 <vincenz> note the double [[
17:22:11 <SyntaxNinja> irce: why are you using loops? :)
17:22:12 <vincenz> cause otherwise I'd get errors
17:22:55 <SyntaxNinja> irce: your main "loop" loop is infinite, isn't it?
17:23:00 <irce> SyntaxNinja: jep
17:23:56 <SyntaxNinja> so getInt isn't returning either?
17:24:35 <irce> something hangs yes 
17:24:46 <wagle> whats the url?
17:25:19 <irce> http://otto-1.hopto.org/main.hs 
17:25:54 <SyntaxNinja> irce: works for me
17:25:57 <wagle> still have the odd indentation?
17:26:07 <SyntaxNinja> if I load getInt into ghci and run it, it works.
17:26:39 <SyntaxNinja> irce: why not put in a terminating loop and see if it terminates then :)
17:27:32 <wagle> mu:
17:27:32 <wagle>     Can't find module `GraphicsUtils'
17:28:44 <irce> SyntaxNinja: tried it outside the loop an it still hanged. :/
17:28:46 <wagle> SOE?
17:29:03 <irce> wagle: graphiclibs for hugs 
17:29:23 <SyntaxNinja> irce: you input a line and hit enter?
17:29:24 <SyntaxNinja> hmm
17:29:58 <wagle> oh well..  really need that round tuit
17:30:41 <SyntaxNinja> vincenz: you're not just here to learn Haskell's cool ideas and steal them for O'Caml, are you? ;)
17:30:48 <irce> SyntaxNinja: it just hangs. doen't take any input. 
17:30:58 <vincenz> SyntaxNinja: damn, you got me
17:31:00 <SyntaxNinja> irce: it's waiting for input, right?
17:31:27 <irce> well it doesn't take any no matter how I give 
17:31:45 <SyntaxNinja> so you type 123 and hit enter and it does, what?
17:31:53 <wagle> is that bizarre indentation correct?
17:32:27 <SyntaxNinja> wagle: not sure, he's using tabs
17:32:35 <Riastradh> Tabs are evil.
17:34:22 <irce> SyntaxNinja: does nothing. it stops at that getInt. loops there forever 
17:34:39 <irce> I have no idea about the identation
17:35:09 <SyntaxNinja> irce: it loops dumping output to the screen?
17:35:21 <SyntaxNinja> irce: does it echo the 123 and the ENTER and do nothing?
17:35:32 <SyntaxNinja> (when you call it by itself)
17:35:41 <irce> it dumps nothing to screen 
17:36:09 <SyntaxNinja> how do you know it's stopping at the getInt?
17:36:26 <wagle> fork the source, and convert the $'s to parentheses until you are sure you understand whats beeing applied to what
17:36:53 <wagle> , my suggestion is
17:37:19 <jadrian> DData seems much more complete than FiniteMap
17:37:26 <jadrian> any reason why it is not default?
17:37:54 <jadrian> that is, why isn't DData in GHC instead...
17:38:53 <SyntaxNinja>  DData is currently under review for inclusion in the standard hierarchical module name space, and you are invited to join the discussion on the Haskell libraries mailing list. The current proposal is maintained by J.P.¬†Bernardy and can be found at: http://users.skynet.be/jyp/DData/doc and http://users.skynet.be/jyp/DData/ddata.tar.gz
17:39:09 <SyntaxNinja> http://www.haskell.org/communities/11-2004/html/report.html
17:39:47 <jadrian> ah nice!
17:40:28 <irce> weird. I did the getInt first, then it worked.
17:40:53 <SyntaxNinja> there is much ddata discussion here: http://www.haskell.org//pipermail/libraries/2004-May/thread.html
17:41:25 * SyntaxNinja goes to eat...
17:41:36 <SyntaxNinja> see everyone tomorrow.
17:41:48 <SyntaxNinja> or maybe in a few hours, depending...
17:42:17 <wagle> from my perspective, your indentation indicates that the setGraphic expression is an argument to getInt (in the old code)
17:43:45 <wagle> irce: get rid of all tab chars, and then make sure everything lines up with spaces
17:44:10 <irce> need to use another editor 
18:12:15 <irce> 50 - Last generator in do {...} must be an expression getting that shit again
18:14:03 <wolfman8k> what is the CCall module?
18:14:23 <wolfman8k> @info CCall
18:14:36 <irce> 66
18:14:42 <irce> hups
18:15:01 <irce> --> sleep
18:41:56 <Darius> Hey Pseudonym are you there?
18:55:08 <jadrian> isn't there anything like a priority queue in GHC libs??
18:55:39 <monochrom> Yes.
18:56:27 <jadrian> what would it be then... FM?
18:56:53 <monochrom> Yuck, I can't find it!
18:57:19 <jadrian> that makes 2 of us :)
18:59:57 <monochrom> I admit failure.
19:00:06 <jadrian> :(
19:00:16 <jadrian> I'd really like to be wrong...
19:01:11 <jadrian> Finite Map  is not that good as a priority Queue
19:01:27 <jadrian> it's akward to decrease the costs, which would be the keys
19:04:07 <monochrom> Right.
19:07:18 <Darius> The sample chapter of "The Fun of Programming" has an extremely simple pure priority queue implementation.
19:07:29 <Darius> http://www.palgrave.com/catalogue/catalogue.asp?Title_Id=0333992857
19:11:07 <monochrom> On the bright side, I started to write a Haskell graph-theoretic module a long time ago.  I didn't do much beyond writing down a few type signatures.  I am happy to find that now we have Data.Graph and I can pretty much forget my own attempt. :)
19:15:58 <jadrian> Darius: yeap, but I could use a big library with lots of functions, and that takes some time (which I don't have now) to implement
19:16:16 <jadrian> anyway since I'll use a finite and small number of costs for now
19:16:32 <jadrian> maybe it's not such a bad idea to implement it as an Array?
19:16:41 <jadrian> array of lists
19:17:03 <jadrian> one position for each cost
19:17:33 <jadrian> I've had bad experiences with arrays before, I hope this doesn't end up being another one
19:19:29 <monochrom> Data.Graph doesn't do everything I want.
19:20:40 <jadrian> I know it is not the same thing
19:20:58 <jadrian> but I whish ghci -Wall didn't complain about things like 
19:21:00 <jadrian> cost = 10 :: Int
19:21:05 <jadrian> missing a signature
19:21:15 <monochrom> Haha
19:21:18 <Darius> jadrian: If you are going to implement queues anyways then what is wrong with Okasaki's?
19:22:22 <jadrian> Darius: they're not packaged with ghc are they?
19:23:13 <Darius> I would imagine a priority queue is in Edison, but apparently not in the heirarchical libs.
19:23:25 <Darius> Though, DData may also be worth looking at.
19:23:47 <Darius> But the entire implementation of Okasaki's queues is about 10 lines.
19:24:07 <jadrian> hmmm how about functions on them?
19:24:11 <jadrian> aren't there any?
19:25:50 <Darius> Except for the basic ones defining a priority queue (minElem, insert, etc. plus merge) you'd have to define them.  But implementing most of the (appropriate) functions from e.g. FiniteMap would probably take less than two pages of straight forward code.
19:26:26 <Igloo> jadrian: Giving type sigs like that isn't the same as giving them as separate declarations
19:26:39 <Igloo> e.g try "cost = 10 :: Num a => a" in a file and then :t cost in hugs/ghci
19:29:50 <jadrian> Darius: maybe I'll end up doing it... still I think FiniteMap is missing a lot of useful stuff 
19:30:01 <Darius> It seems to be.
19:30:01 <jadrian> Igloo: hmmm
19:30:18 <jadrian> Igloo: monomorphism restriction right?
19:30:25 <Igloo> Right
19:30:39 <jadrian> well
19:31:23 <jadrian> wouldn't make sense to put it like:
19:32:29 <jadrian> "I'd really like if   foo = ... :: Signature" worked as a signature and not just a type anotation
19:32:37 <jadrian> would it?
19:32:57 <jadrian> admitedly I haven't give it much thought
19:33:02 <jadrian> and I'm sleepy
19:33:24 <jadrian> and I've always got along with the monomorphism restriction
19:33:25 <jadrian> but
19:33:49 <jadrian> having   cost = 10 :: Num a => a    as an Int
19:34:08 <jadrian> just seems weird
19:34:39 <Igloo> I've almost never got along with the MR  :-)
19:34:44 <jadrian> :)
19:35:51 * jadrian is off to bed
19:35:54 <jadrian> way to sleepy
19:36:04 <jadrian> can't work anymore...
19:36:05 <jadrian> bye
21:58:05 <Helic> has anyone managed to build ghc for cygwin ? (no mingw)
22:16:07 <musasabi> ,prmomg
22:39:44 <heatsink> ,prmomg. ,isasano
22:51:00 <musasabi> hmm the more I see types in standard libraries the more I hate them.
22:51:10 <musasabi> Why couldn't they just use newtypes :-(
22:52:19 * musasabi wanted to have instance LoadFoo_C FilePath and String...
22:57:07 <monochrom> newtype may cause the program to be faster, but I don't see how it eases your programming.
22:58:26 <monochrom> I now think I see what you mean.  You are referring to type vs. newtype.  You are right.
23:02:52 <monochrom> ghc allows what you want. a type synonym can become an instance of a type class.
23:07:01 <musasabi> yes, but that is note very portable.
23:07:12 <musasabi> and wouldn't help with string literials.
23:07:43 <musasabi> loadFoo "/etc/myfile" - do we mean a filepath or a string - we cannot know so we need separate functions.
23:14:25 <yaarg> grrr
23:15:06 <yaarg> given intervals on the [a1,b1] and [a2,b2] they intersect if a1 <= a2 <= b2 <= b1 right?
23:17:30 <Helic> a1 a2 b1 b2 provided that a1 < a2 ?
23:17:44 <yaarg> yep
23:18:03 <yaarg> oh opps sorry
23:18:04 <yaarg> nope
23:18:17 <yaarg> but yeah vice versa is causing confusion
23:18:25 <yaarg> a1 < b1 and a2 < b2
23:19:30 <heatsink> yaarg: what about [2,3] and [1,2]?
23:21:01 <yaarg> :/
23:21:20 <yaarg> i've confused myself
23:21:31 <heatsink> yay
23:22:23 <yaarg> but those intervals don't overlap
23:22:49 <coryb> sure they do
23:22:52 <coryb> they both include 2
23:22:56 <coryb> um
23:23:04 * coryb is thinking math, not haskell, though...
23:23:17 <coryb> i.e. [1,2) and [2,3] would not overlap
23:23:24 <yaarg> gar okay
23:23:24 <coryb> since [1,2) doesn't have 2, but [2,3] does
23:23:28 <yaarg> what is the condition then? :/
23:23:44 <yaarg> if i want to check if two intervals intersect
23:24:00 <yaarg> [a1,b1] and [a2,b2]? :/
23:24:05 <heatsink> yaarg: try fixing the first interval at [0,1] and then figuring out where the second interval could be.
23:24:07 <Helic> as I said above
23:24:08 <yaarg> and one may intersect either way
23:24:10 <coryb> if a1 < b2 or b1 > a2
23:24:23 <coryb> hmmm
23:24:23 <coryb> no
23:24:37 <heatsink> coryb: that's right
23:24:47 <coryb> I don't think it is
23:25:10 <coryb> you could have [0,1] [2,3] and it would be wrong
23:25:13 <heatsink> hmm.
23:25:51 <coryb> assume [x,y] has x <= y always
23:26:09 <yaarg> yes that is the case
23:26:10 <coryb> then if b1 is between a2 and b2
23:26:29 <coryb> or if a2 is between a1 and b1
23:26:29 <heatsink> IOW b1 > a2
23:26:42 <heatsink> IOW a2 < b1
23:26:43 <coryb> not necessarily
23:27:16 <coryb> need more than either of those conditions
23:27:21 <yaarg> (a1 <= a2 and b1>=a2) || (a2 <= a1 and b2 >= a1)
23:27:22 <heatsink> yes
23:28:02 <yaarg> maybe..? :/
23:28:05 <heatsink> yaarg: what if region 1 is entirely inside region 2?
23:28:17 <coryb> yaarg: maybe need to adjust the <=, >= for your application
23:29:03 <yaarg> if you have an interal a <= b ie a <= x <=b and i want to know if two intervals [a1,b1] and [a2,b2]
23:29:27 <yaarg> just in math not necessarily in haskell  :)
23:29:39 <yaarg> +intersect
23:30:37 <coryb> hm
23:30:39 <coryb> how about this
23:30:56 <coryb> if a1 or b1 is between a2 and b2
23:30:57 <coryb> or
23:31:07 <coryb> if a2 or b2 is between a1 and b2
23:31:10 <coryb> that should cover it
23:31:22 <heatsink> yaarg: draw a number line
23:31:24 <coryb> oop
23:31:27 <coryb> last b2 is b1
23:31:34 <yaarg> heatsink: i've tried but i just confused myself! :)
23:31:48 <coryb> is [0,1] defined as intersecting [1,2]?
23:32:00 <heatsink> yaarg: then draw the first interval, then draw all cases where second interval overlaps first. There will be exactly four different cases.
23:32:50 <yaarg> coryb: yep
23:32:57 <coryb> ok
23:33:02 <heatsink> yaarg: There will be exactly two cases in which the intervals do not overlap. Figure out those two cases, and you're set.
23:33:25 <coryb> I need to sleep
23:33:36 <yaarg> heatsink: a1 <= a2 <= b1 and a2 <= a1 <= b2?
23:34:05 <coryb> hm
23:34:09 <coryb> I think you could cover it with this
23:35:06 <coryb> if ((a1 <= a2 or a2 <= b1) or (a1 <= b2 or b2 <= b1))
23:35:22 <coryb> first case covers a2 between in the interval from a1 to b1
23:35:29 <coryb> second case covers b2 between the interval from a1 to b1
23:35:41 <coryb> if either end of your second interval is in your first interval... you have an intersection
23:35:46 <heatsink> coryb: you need an and somewhere
23:36:03 <heatsink> and, you can do the entire test with only two comparisons
23:36:12 <coryb> which are?
23:36:20 <yaarg> really? :/
23:36:51 <heatsink> yes. Did you draw a number line, and one interval on it?
23:37:02 <yaarg> heatsink: yes
23:37:19 <yaarg> i don't believe you can do it with two
23:37:32 <heatsink> There are six ways that you can place the second interval, relative to the first.  Can you itemize all six?
23:38:11 <yaarg> it's the covering if it's the other way about that's i'm having trouble with
23:38:21 <heatsink> if what's the other way about?
23:38:32 <yaarg> if the second interval intersects the first
23:38:43 <yaarg> or the first interval intersects the second
23:38:50 <yaarg> i need to cover both
23:39:09 <coryb> uh
23:39:23 <coryb> if the second interval intersects the first, that means the first interval intersects the second
23:39:30 <heatsink> Is she married to him, or is he married to her? hmm!
23:39:31 <coryb> intersection is a reflexive property
23:39:40 <yaarg> lol
23:39:46 <coryb> wait
23:39:49 <coryb> not just reflexive
23:39:57 <yaarg> well doesn't work for me
23:39:58 <yaarg> !
23:40:00 <coryb> not transitive
23:40:07 <coryb> but symmetric. that's it.
23:40:56 <yaarg> a1 <= a2 <= b1 and a2 <= a1 <= b2
23:41:01 <yaarg> why doesn't that work?
23:41:03 <coryb> I don't need an and, btw, I could change any ands I might need into nots and ors :)
23:41:22 <coryb> yaarg: try a1 <= b2 <= b1 or a1 <= a2 <= b1
23:41:54 <coryb> that says "if any end (i.e. a2 or b2) of the second interval is found within the first interval, we have an intersection"
23:42:11 <coryb> *any* end... 1 or both
23:42:15 <heatsink> If you have first interval entirely inside second interval, you will get the wrong answer
23:42:31 <yaarg> heatsink: for my expression?
23:42:40 <heatsink> for coryb's
23:42:44 <coryb> [0,3] and [1,2] don't intersect?
23:42:58 <yaarg> heatsink: my expression works?
23:43:10 <heatsink> coryb: those intersect, but [1,2] and [0,3] don't intersect
23:43:25 <heatsink> yaarg: you have the opposite problem. For you, [0,3] and [1,2] don't intersect.
23:43:30 <yaarg> rofl
23:43:31 <yaarg> !
23:43:32 <coryb> ah, crap
23:43:45 <coryb> so you have to do mine again with intervals reversed :)
23:44:03 <coryb> that does 8 comparisons
23:44:05 <yaarg> heatsink: what's the two comparsion one?
23:44:26 <heatsink> Check for the cases when the intervals don't overlap
23:44:34 <heatsink> Then invert the result
23:44:56 <yaarg> :/
23:45:45 <heatsink> yaarg: six ways you can place interval 2 on the number line relative to interval 1.  Four overlap, two do not.  Can you figure out how to draw them?
23:46:01 <yaarg> (a1 <= a2 and b1>=a2) || (a2 <= a1 and b2 >= a1)
23:46:38 <coryb> so if !((b1 < a2) or (b2 < a1)
23:46:41 <coryb> )
23:46:44 <coryb> maybe that works
23:46:46 <coryb> maybe I'm tired
23:46:47 <coryb> bed
23:47:01 <yaarg> nn
23:47:13 <heatsink> goodnight coryb
23:47:17 <heatsink> antic?
23:47:21 <yaarg> heatsink: i can only see three intervals
23:47:41 <yaarg> that overlap
23:48:25 <yaarg> oh
23:48:28 <yaarg> i can see four
23:48:32 <heatsink> good!
23:49:06 <yaarg> right
23:49:46 <yaarg> so ym condition is the ones that do not overlapp
23:49:55 <heatsink> yes
23:50:03 <heatsink> You've drawn those?
23:50:13 <yaarg> yep
23:50:45 <heatsink> great. So tell me what the condition is.
23:50:54 <yaarg> two secs
23:51:27 <heatsink> This isn't geometry. No secants.
23:51:58 <yaarg> b2 < a1 
23:52:07 <yaarg> and b1 < a2?
23:52:08 <yaarg> :/
23:52:33 <heatsink> almost
23:53:11 <heatsink> b2 < a1 is part of the expression
23:53:42 <yaarg> b2 < a1 < b1
23:53:46 <yaarg> wait
23:53:49 <yaarg> grr
23:55:02 <yaarg> hmm
23:55:35 <yaarg> a2 > b1 :)
23:56:14 <yaarg> ?
23:56:42 <heatsink> a2 > b1 is the same thing as b1 < a2
23:56:56 <yaarg> doh i can't see the second bit
23:57:09 <heatsink> a2 < b1
23:57:10 <yaarg> the second case is when the second interval is after the first
23:57:15 <heatsink> right
23:57:16 <yaarg> and that's when b1  < a2
23:57:36 <heatsink> when b1 < a2, the second interval starts before the first one ends
23:58:19 <yaarg> ?
23:58:29 <yaarg> teh first interval is from a1 to b1
23:58:35 <yaarg> then seocnd interval is from a2 to b2
23:58:40 <heatsink> oh
23:58:53 <heatsink> I thought it was a1 to a2, b1 to b2
23:58:55 <heatsink> hmm
23:59:02 <yaarg> ohh
23:59:17 <yaarg> nope [a1,b1] and [a2,b2]
23:59:55 <yaarg> so still b2 < a1
