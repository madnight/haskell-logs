00:04:05 <arauko> 'T':'h':e':' ':'v':'a':'l':'u':'e':' ':'i':'s':' ':[] ++ show (sqrt 9)
00:04:14 <arauko> what is the problem with that line?
00:12:48 <SyntaxNinja> y0
00:12:55 <SyntaxNinja> new haskell-mode in haskell-unsafe debian archive
00:12:59 <SyntaxNinja> haskell-mode 2.0!
00:16:08 <wli> heh
00:17:09 <Gahhh> lambdabot: @info sqr
00:17:13 <Gahhh> lambdabot: @info sqrt
00:17:16 <lambdabot> -- sqrt is a method in class Floating
00:17:16 <lambdabot> sqrt :: forall a. (Floating a) => a -> a
00:17:16 <Gahhh> argh
00:17:37 <Gahhh> arauko, in "sqrt 9", 9 is not a float, afaik.
00:18:59 <arauko> it doesn't need to be float.
00:20:46 <SyntaxNinja> MegaMonad: how did you develop such a terrifically subtle sense of humor?
00:20:52 <MegaMonad> SyntaxNinja: Subtle stuff is a hack, of course, happy is the subset of the humor of being the lambdabot plugins include @index @type and @info commands.
00:21:17 <Gahhh> arauko, then there is no problem with that line
00:22:36 <arauko> Gahhh, it doesn work here
00:22:50 <arauko> Prelude> 'T':'h':e':' ':'v':'a':'l':'u':'e':' ':'i':'s':' ':[] ++ show (sqrt 9)
00:22:50 <arauko> <interactive>:1: Variable not in scope: `e''
00:23:05 <Gahhh> arauko, you forgot a "'" before the first 'e'
00:23:21 <arauko> hah
00:23:28 <Gahhh> MegaMonad, why do I not want to go to sleep ?
00:23:33 <MegaMonad> Gahhh: Sleep is for notes you make a wrapper around sleep though.
00:23:46 <Gahhh> hmm, wrapper around sleep
00:24:29 <arauko> MegaMonad, eh?
00:24:34 <MegaMonad> arauko: And the masters of the caterogy sum is really interesting : http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg?
00:24:35 <Gahhh> you betcha
00:25:02 <Gahhh> 'caterogy' is supposed to be 'category' ?
00:33:56 <arauko> nice output, [1 .. 9000]
00:36:27 * wli ponders logic language interpretation
00:37:08 <wli> specifically breadth-first-search -like semantics
00:37:24 <dblhelix> MegaMonad: I try do decide on a suitable title for my thesis; do you have any suggestions?
00:37:29 <shapr> greetz lypanov 
00:37:29 <MegaMonad> dblhelix: So, any other suggestions would be suitable for my thesis.
00:37:35 <lypanov> hey shapr
00:37:39 <Gahhh> dblhelix, what is it on ?
00:37:47 <dblhelix> MegaMonad: it's about generic views
00:37:53 <MegaMonad> dblhelix: Adding views to generic haskell is that views can register interest in scala is http://www.cse.unsw.edu.au/~dons/yi.
00:38:04 <dblhelix> Gahhh: eh, about generic views on data types
00:38:42 <Gahhh> what is a 'view' ?
00:39:10 <dblhelix> a certain representation of something
00:39:22 <dblhelix> are you familiar with generic haskell
00:39:28 <Gahhh> No
00:41:11 <dblhelix> well. a small example of views then ...
00:41:44 <dblhelix> looking at the def. of lists in haskell: data [] a = [] | a : [a]
00:42:06 <dblhelix> or, nicer, data List a = Nil | Cons a (List a)
00:42:32 <dblhelix> you immediately see that this def. is biased to the front of the list
00:43:25 <Gahhh> Uh, ok
00:43:41 <dblhelix> so, not surprisingly, it's quite easy to define the head function
00:43:49 <lypanov> hows yi doing now?
00:44:03 <dblhelix> pattern matching does the work for you, then: head (a : as) = a
00:44:15 <dblhelix> or head (Cons a as) = a, if you want
00:44:23 <Gahhh> ok
00:44:23 <shapr> lypanov: quite well, dons has done a lot.
00:45:50 <dblhelix> admittedly, the example is way too contrived, but you can imagine that operations that target the end of a list a more involved
00:45:58 <Gahhh> yes
00:47:13 <dblhelix> if you have a lot of those operations, it would be nice to have a representation like: data List' a = Lin | Snoc (List' a) a
00:47:46 <dblhelix> where the second component of the second constructor is the *last* element of the list
00:48:03 <Gahhh> Ok
00:48:43 <dblhelix> but wouldn't it be even nicer to switch between these representations at will?
00:49:10 <Gahhh> Well, in my uneducated opinion, doesn't that depend on what the compiler does with the data layout ?
00:49:40 <dblhelix> could you elaborate on that?
00:50:06 <Gahhh> well, I know nothing about how the compiler has the list stored in memory. (list = the original definition)
00:50:38 <dblhelix> wadler's proposal lets the compiler insert conversion functions when needed
00:50:48 * shapr plays with haskell-mode 2.0
00:50:58 <arauko> Hola shapr
00:51:05 <dblhelix> so whenever i decide to pattern match on Snocl, the compiler converts from List to List'
00:51:24 <dblhelix> all I have to do is give the conversion functions in advance -- only once, of course
00:51:30 <Gahhh> dblhelix, is this a trivial conversion or does stuff get moved around ?
00:52:26 <dblhelix> in this example the conversion is trivial, but in general there are of course caveats: what if the conversion runs is exponential time, for instance?
00:52:39 <dblhelix> /s/is/in
00:52:44 <Gahhh> even linear time is ugly imho
00:53:14 <Gahhh> is the goal to simplify the code ?
00:54:09 <dblhelix> yes, it is
00:54:11 * shapr boings cheerfully
00:54:32 <dblhelix> in generic haskell we have taken the concept even a step further
00:55:21 <dblhelix> there, every type is 'viewed' (converted to a representation) in terms of the same small set of type constructors 
00:56:21 <dblhelix> f.i., data List a = Nil | Cons a (List a) is viewed as type ListS a = Sum Unit (Prod a (List a))
00:57:54 <dblhelix> the idea is that every type can be viewed in terms of Unit, Sum and Prod
00:58:33 <shapr> Lemmih: got time for some HaskellDB questions?
00:58:56 <dblhelix> now, (simplified) if i write a function that matches on Unit, Sum and Prod, this function can be applied to all data types and so we achieve generics
00:59:24 <Gahhh> I see
00:59:28 <dblhelix> admittedly, this is a very lame explanation, but I hope you got the idea
00:59:34 <shapr> Guten Morgen Thomas
00:59:51 <Gahhh> dblhelix, thanks.
01:00:03 <TheHunter> Good morning, Shae.
01:00:06 <dblhelix> however, the choice for Unit, Prod and Sum and the used encoding is somewhat arbitrarely and that's where multiple views come in
01:00:18 <dblhelix> Gahhh: you're welcome
01:00:45 <dblhelix> but now I still need a catchy title and MegaMonad isn't of much use today :)
01:01:10 <dblhelix> a friend of mine suggested "a view more", which is perhaps kinda corny
01:02:18 <shapr> oh, I found the problem with HaskellDB. it's just missing -package hsql
01:02:40 <shapr> strange, it only seems to need that in one place.
01:02:55 * TheHunter yaaawwwnnnnns
01:03:22 <TheHunter> if I were in charge, there'd be no courses at 8 o'clock.
01:04:33 <dblhelix> TheHunter: 8 o'clock!? in which prison do you study?
01:04:36 <shapr> If I were in charge, courses wouldn't have a set time. You'd just have three set goals for passing the course.
01:06:37 <TheHunter> dblhelix, it's pretty common here (.de).
01:07:11 <dblhelix> TheHunter: no courses here before 9 o'clock (.nl) :)
01:07:21 <TheHunter> and what really pisses me off, is that you can more or less throw away the rest of the day if you had to get up at 7:30.
01:07:44 <TheHunter> the last term was way better: I only went to courses after noon.
01:08:15 <dblhelix> TheHunter: you can switch from sleeping mode to learning mode in only 30 mins?
01:08:55 <TheHunter> yep, a cold shower can do miracles.
01:09:06 <shapr> hej bringert 
01:09:14 <bringert> hej
01:09:26 <dblhelix> TheHunter: you've just earned my deepest respect :)
01:10:25 <TheHunter> dblhelix, the problem is, learning mode usually doesn't last very long.
01:10:56 <arauko> if im gonna compile a program, and i need to use module Main , do i also need to rename the file to main?
01:11:39 <TheHunter> so now i'm in a surf-the-internet mode which is closer to sleeping than to being awake.
01:12:33 <TheHunter> arauko, no, ghc --make MainModule.hs will take care of everything.
01:13:24 <arauko> main = 
01:13:28 <arauko>     x = 3
01:13:28 <arauko>     y = foldr (*) 1 [2 .. 9]
01:13:28 <arauko>     putStrLn (show (x + y))
01:13:37 <arauko> what's wrong with that?
01:13:37 <dblhelix> but will try to locate additional modules in files X.hs or X.lhs for modules X
01:14:05 <dblhelix> missing do and a couple of lets
01:14:06 <TheHunter> arauko, you probably mean
01:14:10 <TheHunter> main = do
01:14:14 <TheHunter>   let x = 3
01:14:19 <TheHunter>       y = ...
01:14:25 <TheHunter>   putStrLn ...
01:15:04 <arauko> mm... 
01:15:51 <TheHunter> arauko, you could also make x and y top-level bindings.
01:15:53 <TheHunter> x = 3
01:15:54 <TheHunter> y = ...
01:16:00 <TheHunter> main = putStrLn ...
01:16:25 * dblhelix will be away for a while
01:16:31 <eivuokko> You don't need "in" with let in do?
01:16:57 <TheHunter> eivuokko, no let in do-blocks is special.
01:17:25 <eivuokko> Duh.  Magic I didn't know about.  Thanks. :)
01:18:00 <TheHunter> If you'd use let ... in, you'd have to introduce another do block if you want more than one action to follow.
01:18:48 <eivuokko> I know, my fix would've been main = let .. in [do] putStrLn ..
01:19:40 <eivuokko> But that's of course matter of taste and what you're actually doing.
01:27:08 <arauko> how to unload a module with GHCi?
01:31:19 <arauko> Compiling Main             ( Print.hs, Print.o )
01:31:19 <arauko> Print.hs:7: parse error (possibly incorrect indentation)
01:33:55 <arauko> http://paste.lisp.org/display/4510
01:34:00 <arauko> that is the code.
01:35:24 * arauko puts his hands on the head 
01:35:34 <arauko> 5:30 am
01:35:51 <arauko> i thought it was 2 am at most.
01:35:53 <TheHunter> arauko, the putStrLn is an action, so it must be indented like the first statement in the do block.
01:36:45 <arauko> yes, makes sense
01:36:50 <arauko> thanks TheHunter
02:00:11 * TheHunter is away: lunch
04:42:06 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","Due to shortages, there will be no lambdas this Xmas","We put the Funk in Funktion","The people here like donuts"]'
04:42:06 --- topic: set by Pseudonym on [Tue Dec 14 15:09:24 2004]
04:42:06 --- names: list (clog jao arjanb LrdMtrod dustin` Si\ aFlag rhw srid cptchaos bringert TheHunter shapr borism_ martink xerox arauko SamB reltuk gnufan Nomius Joachim_ kig MegaMonad eivuokko Lemmih irce_ icb waltz kristnjov jadrian zamez wolfman8k Jan_w KrispyKringle ibid kolmodin gabor mrsolo_ vegai ex_nor isomer vincenz sjanssen Itkovian andersca tinus themaximus lament shawn jgrreex Cale lambdabot Gahhh Riastradh flodin psi borism mflux emu wilx tintin)
04:42:06 --- names: list (ozone Nioate coven johs aj kpk Lor norpan polli gdsx keverets Matt-W wli Perite desrt esap dryan blackdog Defty wagle cmeme Taaus tic Igloo dons ned sorje reffie thebug Lunar^ skylan earthy musasabi det resiak CLxyz djw asmodai flori Maddas shammah rossberg kosmikus Spark tumm tuomov)
04:42:31 <wli> if the thing applies to the top anyway, why do you care about commuting it at all?
04:42:32 <earthy> oh well, time to get lunch and fuck around with the state monad some more
04:42:35 <shapr> aren't source repos sometimes b0rken because of --no-apply --no-conflict or whatever the email based repo thingy is?
04:42:59 <shapr> because apply necessarily means that you have to check to see if it conflicts. if it conflicts, try to commute it
04:43:15 <tuomov> but the chain of patches should be ok
04:43:22 <musasabi> think about "darcs rename a b" "cp a b" "darcs add a" now patches seem to apply to a fine but they should be applied to b.
04:43:23 <wli> okay, then what does the "does it apply?" check entail?
04:43:29 <tuomov> conflicts don't mean a borken repo
04:43:51 <wli> okay, so file identity is in question
04:44:01 <tuomov> a borken repo would be something where the order of things in _darcs/inventory has been messed up
04:44:04 <wli> let me guess
04:44:30 <wli> files don't have any stable identifier so exhaustive search over the history is required to make sure all the patches are being applied to the correct files
04:44:32 <tuomov> or the pathches have been corrupt
04:45:01 <wli> but that can't be
04:45:43 <shapr> Patch arrows would mean that each patch exports its properties in whatever detail the arrow specifies. Each set of composed patches would have composed properties. That way, you could check for any problems when composing patches, and the properties would only need to be calculated once for a patch.
04:45:44 <wli> because with the rename/cp/add sequence you need some way to distinguish between patches to the moved file after the move and so on
04:46:21 <musasabi> wli: and it does. that is why patches are tied to their ancestry.
04:46:21 <shapr> You'd still have to break a collection of patches once you have a conflict, but you would no longer have to recursively walk everything
04:46:37 <wli> okay that's bust
04:46:44 <wli> get files unique identifiers...
04:46:50 <eivuokko> shapr, Is there an implementation of that?
04:46:50 <musasabi> wli: how?\
04:47:02 <shapr> eivuokko: no, that's just something I thought up myself.
04:47:05 <musasabi> the arch solutions are clunky and complex.
04:47:15 <shapr> I sent email to David describing it, but I didn't get a reply.
04:47:31 <wli> musasabi: n-th file added to the repo gets ID n
04:47:36 <shapr> Maybe I should send it again with more detail.
04:47:40 <musasabi> David is on holiday I think.
04:47:41 <wli> pick something
04:47:50 <shapr> musasabi: I sent email months ago :-)
04:47:53 <wli> it doesn't sound hard
04:47:53 <eivuokko> And he seems to be pretty busy guy anyway.
04:47:55 <musasabi> wli: but then two files have identifier n. Remember distribution.
04:47:57 <shapr> cc'd to mark stosberg too
04:48:04 <wli> musasabi: how?
04:48:27 <shapr> because I add one to my repo, and you add one to your repo?
04:48:39 <eivuokko> wli, Well, how do you get the unique identifiers?   Mmmh...hash of the patch that adds it...ehh..leads recursion?
04:48:47 <musasabi> wli: developer A: darcs get foobar; darcs add myfile; darcs record; (myfile = N)
04:49:02 <musasabi> wli: developer B: darcs get foobar; darcs add otherfile; darcs record; (otherfile = N)
04:49:12 <musasabi> wli: now both of them push to the same repo.
04:49:20 <wli> musasabi: obviously alpha equivalence games have to be played in the event of a conflict
04:49:51 <wli> but it never enters a state where 2 things have ID n simultaneously in a repo
04:50:51 <wli> you can trivially add username + location + timestamp to the sequence number (where the sequence number designates the n-th file created in some simultaneous operation)
04:50:52 <musasabi> wli: so what id should myfile and otherfile have when pushed to the masterrepo. What happens when both A and B pull from there after both have pushed their changes?
04:51:21 <musasabi> wli: that screams out abusing it.
04:51:49 <wli> musasabi: the rare event of such a nameclash causes the worst-case whole-repo search for a free name to do alpha equivalance crud on
04:52:11 <wli> musasabi: or you can just use an number larger than any in the repo (not hard to track)
04:52:49 <wli> I guess you then have to check for consistency of file ID dictionaries or some such crap
04:53:10 <wli> but that should be much smaller than the files themselves
04:54:10 <wli> you'll get nameclashes theoretically possible no matter what
04:54:15 <musasabi> yes.
04:54:29 <wli> the state can be condensed into a much smaller form
04:55:28 <musasabi> true.
04:55:50 <wli> and nameclashes can be made very very rare
04:56:47 <wli> host + username + absolute path + timestamp + sequence number for files rapidly added to the same repo after renames
04:58:01 <wli> you're already into the "We need a temporary placeholder scheme or artifically-constructed repo just to test the nameclash resolution code" territory after that.
04:58:42 <musasabi> wli: I am not worried about inadvert name clashes, just trying to make it sure there are no potential holes in them.
04:59:54 <wli> okay, let's see, how do you resolve nameclashes? smells vaguely like graph isomorphism or some such
05:00:08 <wli> nah, unification
05:00:09 <musasabi> something that would allow harmless looking patches to affect the wrong files.. But I think it is safe after all.
05:00:31 <wli> when unification fails there's a nameclash
05:03:02 <shapr> swiert: hey, do you have pix of your new glasses?
05:03:22 <swiert> shapr: no not yet.
05:03:39 <shapr> ok, just curious
05:03:57 <swiert> I was wearing lenses in the last pictures I had made 
05:04:25 <swiert> I was away when you asked me the other day.
05:06:29 <earthy> why the frigging hell does Control.Monad.State.put return m ()
05:06:40 <earthy> that's just annoying!
05:07:27 <shapr> swiert: s'okay, I regard irc as an inherently asynchronous medium with occasional fast responses.
05:08:11 <Cale> shapr: I agree with this view. In addition, occasionally no responses :)
05:08:27 <Cale> earthy: what should it return?
05:08:48 <earthy> cale: I know it cannot return anything else
05:22:22 <yasam> probably dumb wx, Mac OS X question: ghc -package wx -o EnableGUI EnableGUI.hs
05:22:22 <yasam> EnableGUI.hs:8: parse error on input `import'
05:22:22 <yasam>  why?
05:31:37 <wli> earthy: what are you expecting instead?
05:34:28 <wli> hmm
05:34:33 <wli> if you are lazy
05:34:54 <wli> then some state you rely on is something like a continuation
05:39:20 <wli> srid: you rang?
05:39:35 <srid> yes (testing xchat)
06:00:45 <shapr> yasam: module Foo where
06:01:34 <shapr> yasam: sounds like you forgot part of that line
06:04:30 <cp_> hey
06:05:27 <yasam> the module is Wolfgang Thaller's, it's on wxHaskell site, I assume it compiled for him
06:07:51 <shapr> what's the url to the module?
06:08:09 <yasam> http://wxhaskell.sourceforge.net/download/EnableGUI.hs
06:09:42 <shapr> yasam: what command and implementation are you using to build?
06:09:52 <bourbaki> moin
06:10:01 <shapr> flippi
06:10:04 <TheHunter> moin bourbaki 
06:11:07 <bourbaki> TheHunter: do you happen to know how to get the line between two points on an arbitrary differential manifold?
06:11:49 <bourbaki> Lemmih: you theer?
06:11:55 <tuomov> "line"?
06:12:18 <bourbaki> well a line is defined as the shortest path between two points
06:12:27 <yasam> command: ghc -package wx -o EnableGUI EnableGUI.hs what do you mean by implementation? ghc-6.2.1 ?
06:12:35 <tuomov> the term usually used is geodesic
06:12:41 <bourbaki> thats is where there integral over its curve under the metric of the tangentspace is 1
06:14:01 <bourbaki> Integral g( curve(t), curve(t) ) dt = 1 at least from what i know
06:14:33 <TheHunter> bourbaki, I don't know anything about differential geometry
06:15:08 <bourbaki> dang anyway i need someone who has written a wrapper class for HOpenGL
06:15:31 <TheHunter> I have a certain aversion against anything that is finer than homeomorphism.
06:15:33 <bourbaki> something like Show for GL
06:15:49 <bourbaki> TheHunter: heh why is that :)?
06:16:21 <bourbaki> basically differential geometry is just school math
06:16:57 <bourbaki> you just need some abstractions you had in LAI that is the metric for the tangent space thats all
06:16:58 <TheHunter> because i have the feeling that this part of mathematics is explored so much because of physics.
06:17:09 <bourbaki> oh heh
06:17:11 <tuomov> after you get past the physicist-inherited notation :)
06:17:21 <TheHunter> and I couldn't care less about physics.
06:17:32 <bourbaki> well i like computer graphics
06:17:40 <aFlag> physics rule :)
06:17:40 <Lemmih> bourbaki: Yes.
06:17:46 <bourbaki> and i just see that this is a great tool for it
06:18:01 <bourbaki> Lemmih: have you got wrapper class for your GL stuff?
06:18:13 <Lemmih> eh?
06:18:29 <bourbaki> TheHunter: ie you can get the normals for lighting and such that way etc
06:18:40 <Lemmih> wrapper class?
06:18:41 <bourbaki> Lemmih: something like Show for GL
06:19:02 <TheHunter> bourbaki, well, i'm not very intersted in computer graphics either.
06:19:08 <bourbaki> class GLRender a where render a ...
06:19:14 <TheHunter> as long as my fonts are anti-aliased...
06:19:21 <bourbaki> TheHunter:  heheh :)
06:20:01 <bourbaki> i hate analysis as well but its fun to be able to see what you do actually :)
06:20:03 <Lemmih> bourbaki: No.
06:20:29 <bourbaki> Lemmih: would you be able to help me on my mini game? its nearly done i just need to render it
06:20:40 <Lemmih> bourbaki: Sure.
06:20:52 <bourbaki> Lemmih: ill post the code
06:21:04 * Lemmih is no expert. He has just made some small toy OpenGL programs.
06:21:18 * TheHunter is away: brb
06:21:31 <bourbaki> Lemmih: np its not that hard i think
06:21:47 <Lemmih> shapr: Feeling like hosting my ported NeHe code?
06:21:52 <bourbaki> Lemmih: maybe we both could do something like that render class to get rid of this ugly version stuff of HOpenGL
06:22:47 <bourbaki> Lemmih: http://paste.phpfi.com/42774
06:23:23 <bourbaki> imho all that needs to be done is adding keys and rendering
06:23:42 <bourbaki> then you can drive a ball over that surface for starters ;)
06:24:53 <wli> geodesics?
06:25:25 <bourbaki> wli: yes but i need the line between two precise points
06:25:48 <wli> different from the geodesic?
06:26:30 <bourbaki> wli: no of course not but exploreing all the path that lead away from the point a is very tough :)
06:26:46 <shapr> Lemmih: yeah sure
06:26:56 <wli> bourbaki: why would you do that?
06:27:01 <bourbaki> wli:  i had the idea to ie shoot two rays over the manifold and then have a look where they intersect
06:27:28 <Lemmih> bourbaki: Isn't 'renderPrimitive' all you need?
06:27:29 <shapr> yasam: oh, you need to add -fffi
06:27:56 <wli> bourbaki: well, this is generally a variational problem, and e.g. polygon methods etc. are available.
06:27:59 <bourbaki> Lemmih: yes though the surface is a patch to render
06:28:46 <wli> bourbaki: I think the biggest problem is representing paths over the surface.
06:28:52 <bourbaki> wli: i know and thats not too hard imho :)
06:29:16 <wli> interesting, how do you represent paths over the surface then?
06:29:24 <bourbaki> wli: sec
06:30:09 <bourbaki> wli: http://research.microsoft.com/~hoppe/
06:30:49 <bourbaki> wli: Fast exact and approximate geodesic paths on meshes.
06:30:59 <Lemmih> shapr: Repo at: http://212.242.49.100/repo/haskell/nehe/
06:31:44 <shapr> Lemmih: you just want nehe as the repo name?
06:32:00 <yasam> thanks that got me some better errors :)
06:32:08 <shapr> yasam: what now?
06:32:10 <yasam> the thanks wasnt ironic btw
06:32:24 <shapr> I don't assume irony :-)
06:32:26 <yasam> illegal reference to symbol: _CPSEnableForegroundOperation defined in indirectly referenced dynamic library /System/Library/Frameworks/ApplicationServices.framework/Versions/A/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphics
06:32:29 <wli> bourbaki: 403
06:32:44 <shapr> yasam: sounds like you need to include something for linking maybe?
06:33:39 <bourbaki> wli: strange i can look at the page
06:33:46 <wli> I see a webpage
06:33:52 <wli> the technical report gets a 403
06:33:55 <bourbaki> and im just dling the paper
06:34:06 <bourbaki> hm strange sry
06:34:22 <Lemmih> shapr: I don't really care. Feel free to name it after your convenience.
06:34:30 <wli> looks like the browser's FITH
06:34:35 <wli> wget(1) works
06:35:34 <shapr> Lemmih: significant name.. haskellnehe?
06:35:51 <Lemmih> Sure. That's fine.
06:35:57 <shapr> ok
06:38:06 * shapr considers symlinking all the various allowed_keys keyrings in the scannedinavian darcs repos to a single file
06:39:53 <shapr> hiya balkan 
06:40:14 <balkan> hi shapr
06:40:18 <shapr> how's code?
06:41:07 <shapr> Lemmih: ok, repo setup, keys added, quotes also added so it'll work with postfix
06:41:23 <balkan> shapr: code is growing...how is it that foldr can work on infinite lists but foldl cannot?
06:41:44 <shapr> @type foldr
06:41:49 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
06:41:55 <shapr> @type foldl
06:41:56 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
06:42:28 <balkan> it's not such a big difference to me...
06:42:49 <balkan> but i guess it's in the details.
06:42:58 <shapr> balkan: it's the difference between foldr1 (+) [1,2,3] and foldl1 (+) [1,2,3]. One way you get (1 + (2 + 3)) the other gets you ((1 + 2) + 3)
06:43:27 <tuomov> of course, foldr1 (+) [1..] doesn't work
06:43:43 <balkan> why the '1'?
06:43:43 <tuomov> but if it e.g. produced a list, it could work
06:43:51 <tuomov> no need to give initial parameter
06:45:07 <balkan> shapr: so how does your little example expand to infinite lists?
06:45:26 * TheHunter is back (gone 00:24:08)
06:47:11 <shapr> um, I had an example in mind..
06:47:31 <shapr> aha
06:48:03 <shapr> what's the difference between foldl1 (-) [1,-2,-9] and foldr1 (-) [1,-2,-9] ?
06:48:17 <CosmicRay> Good morning, everyone!
06:48:21 <shapr> Good Morning Agent Goerzen.
06:49:12 <shapr> balkan: if you try out those two chunks of code in a hugs or ghci, do you get the same results?
06:49:26 <balkan> shapr: well the first returns 12 and the other -6
06:49:44 <shapr> so, obviously there must be some difference, right?
06:50:00 <balkan> shapr: yes. 
06:50:51 <shapr> Can you figure out the difference?
06:50:51 <balkan> shapr: but foldl cannot work on infinite lists, whereas foldr can.
06:51:18 <balkan> shapr: well it's with the parentheses you showed earlier.
06:51:23 <shapr> The difference in result between those two chunks of code I pasted are the reason that only one can work on infinite lists.
06:53:13 <shapr> balkan: Do you see the answer?
06:53:33 <balkan> shapr: not yet.
06:53:55 <TheHunter> MegaMonad
06:54:16 <TheHunter> MegaMonad, ?
06:54:21 <MegaMonad> TheHunter: Ie, let the compiler that decided it was pretty good explanation (and it's suggested that the data up and put into compilers when they're horny :p.
06:54:34 * shapr laughs
06:55:45 <shapr> balkan: which two items are folded first in foldr? Let's say you have a list of three items, which two are used first?
06:56:06 <balkan> shapr: foldr start at the right end
06:56:20 <shapr> nah, foldr folds to the right
06:57:01 <shapr> so, which two are used first in foldl?
06:57:55 <CosmicRay> heh
06:58:04 <CosmicRay> shapr: http://www.haskell.org/hawiki/MegaMonad_2fPassingTuringTest
06:58:09 <shapr> balkan: foldr uses the first two items
06:59:00 <shapr> So today's Zen FP question is, how do I use the last two items of an infinite list?
06:59:06 <CosmicRay> haha
06:59:24 <CosmicRay> shapr: splitAt 2 . reverse? :-)
06:59:29 * shapr grins
06:59:46 <CosmicRay> or take2
06:59:52 <shapr> Many times I have tried to use the last two items in an infinite list, but it has not yet succeeded for me.
06:59:57 <CosmicRay> shapr: you really need to read that wiki page :-)
07:00:07 <CosmicRay> shapr: ahh, but if you had infinite ram and cpu cycles, it would work! :-)
07:00:13 <balkan> shapr: could you write what the foldr1 (-) [1,-2,-9] expression look like with parentheses?
07:00:44 <bourbaki> Lemmih: are you working on that render thingy?
07:00:54 <shapr> CosmicRay: I am very amused =) that's really funny
07:01:21 <shapr> balkan: sure, I can, but it's far more instructive if you do it, and check yourself against the results you got from hugs or ghci
07:01:32 <shapr> it's only three items, not much work :-)
07:01:45 <CosmicRay> shapr: I'm going to tell the megahal list about it
07:02:27 <shapr> it's true, MegaMonad is always just on the edge of understandable.
07:02:31 <balkan> shapr: ok so it's 1-(-2-(-9) = -6
07:02:42 <shapr> Usually on the far edge, but occasionally on the near edge.
07:02:48 <wli> heh
07:02:54 <balkan> sorry 1-(-2-(-9)) = -6
07:04:00 <shapr> balkan: which one is that? left or right? 
07:04:14 <Lemmih> bourbaki: Is there something to work on?
07:04:33 <balkan> shapr: well i would start with the (-2(-9)) part.
07:05:00 <balkan> shapr: that was foldr by the way
07:05:02 <bourbaki> Lemmih: yes it would be really cool to have a file i could import witha  class Renderable or such
07:05:49 <CosmicRay> shapr: also my modular FTP sever in Haskell is almost complete.  My virtual IO code is complete, as is my virtual filesystem code.  All three are sorta modeled after parsec, and there are some combinators I've written...  
07:05:55 <balkan> shapr: but i guess that the 1 at the beginning need to get pushed on the stack first. is that what you mean?
07:06:18 <CosmicRay> shapr: so I'm extra psyched about haskell now.
07:06:51 <Lemmih> bourbaki: 'class GLRender a where render :: a -> IO ()' and then define instances for your own data types. Is there more to it?
07:07:46 <CosmicRay> ngopher: hmm, does your name derive from the protocol?
07:08:45 <bourbaki> Lemmih: that and the setup of the renderer and the like it also would be helpfull to get some abstraction of HOpenGL so i can get around the windoze linux version problem of it
07:10:08 <Lemmih> bourbaki: But you don't use platform specific code to initialize HOpenGL...
07:10:20 <balkan> i don't get it, why would foldl need to start with the last elements of the list. iit could start at the beginning if it wanted.
07:10:53 <CosmicRay>  foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
07:11:36 <CosmicRay> hmm.  yes it could.
07:11:45 <shapr> ?
07:11:57 <bourbaki> Lemmih: id like to have some interface where i just can put in a number of points and then the underlying renderer class will render it be it a raytracer or ogl
07:12:02 <shapr> I'm confused now, foldl does fold from the right to the left, yes?
07:12:10 <srid> how do you guys learned haskell? explain, so that it could help me
07:12:19 <CosmicRay> shapr: I would assume that would be foldr
07:12:26 <CosmicRay> srid: http://www.isi.edu/~hdaume/htut/
07:12:33 <wolfman8k> srid: i read a shit load of tutorials and stuff about haskell
07:12:40 <wolfman8k> srid: but that didn't help me
07:12:44 <CosmicRay> srid: also this tutorial on the similar language ocaml may be useful: http://www.merjis.com/developers/ocaml_tutorial/
07:12:55 <Lemmih> bourbaki: So you wanna overload the entire HOpenGL interface?
07:12:56 <CosmicRay> wolfman8k: did you read the tutorial from that page?
07:12:58 <wolfman8k> srid: i one day decided to just code something in haskell, and once i started coding i started learning real fast :)
07:13:03 <wolfman8k> CosmicRay: yeah
07:13:06 <CosmicRay> srid: also, lots of questions here and in haskell-cafe
07:13:20 <CosmicRay> wolfman8k: very true.  you never really udnerstand until you have to solve the problems for yourself.
07:13:35 <wolfman8k> CosmicRay: yep... i coded this for my first haskell program: http://benny.kramekweb.com/hrayt/
07:13:37 <bourbaki>  Lemmih no just the render part for the meshes so i can plug in just a number of points and am done
07:13:47 <srid> what's haskell-cafe
07:13:51 <CosmicRay> wolfman8k: I've seen it, it's cool
07:13:54 <CosmicRay> srid: one of the mailing lists
07:13:57 <Lemmih> bourbaki: Then just overload 'renderPrimitive'.
07:13:58 <CosmicRay> srid: see www.haskell.org
07:14:09 <srid> CosmicRay: will YAHT suffice for imperative programmers with FP exposure?
07:14:44 <CosmicRay> srid: yes, you will probably be a good fit for it.
07:15:01 <CosmicRay> srid: the first half is pretty good, the second half is not the most accessible, but you'll get going with the basics anyway
07:15:07 <Lemmih> bourbaki: Also, I don't understand why you want me to do it.
07:15:38 <bourbaki> Lemmih: heh i just asked if you wanted it to do :) because you did some things with it already
07:15:42 <CosmicRay> shapr: ahh, btw, in ocaml one is always encouraged to use foldl instead of foldr because foldr is not tail-recursive
07:19:42 <shapr> balkan: so, um, where'd you hear which fold works on an infinite list?
07:19:53 <shapr> I'm obviously confused about something.
07:20:04 <balkan> shapr: i read it in YAHT.
07:20:53 <balkan> shapr: page 20 in the note.
07:21:12 <srid> in http://www.isi.edu/~hdaume/htut/, I read: Temporary versions of the tutorial are downloadable here .... does that mean this tutor is not yet finished?
07:21:26 <Igloo> foldr works on infinite lists
07:21:39 <Igloo> And is generally preferable to foldl in Haskell
07:21:53 <balkan> shapr: the example given is foldr (:) [1,2,3,4,5]
07:22:10 <balkan> shapr: which would not work with foldl
07:22:15 <wli> but will foldr on an infinite list ever converge?
07:22:27 <wli> I guess yes
07:22:34 <wli> if it produces some incrementally-built-up structure
07:23:13 <wli> foldr (:) [] [1..]
07:23:15 <Igloo> foldr (\x _ -> x) 0 [1..] == 1
07:24:58 <wli> foldr const 
07:25:31 <balkan> wli: it's obvous that foldr starts at the left end
07:25:40 <wli> foldr const x [] == x ; foldr const _ (y:_) == y
07:26:31 <balkan> wli: but has that got anything to do with why foldr1 (+) [1,2,3] and foldl1 (+) [1,2,3] produce different results?
07:26:47 <balkan> wli: sorry. they don't
07:26:56 <shapr> the difference is in order
07:27:09 <balkan> wli: i meant foldl1 (-) [1,-2,-9] and foldr1 (-) [1,-2,-9]
07:27:43 <shapr> it's just order.
07:28:14 <balkan> shapr: let's say i start a the left here. 1-(2) is -1. 
07:28:31 <balkan> shapr: wrong
07:28:46 <wli> balkan: hm? okay, counterexample? when is foldr const x [] /= x and/or foldr const _ (y:_) /= y ?
07:28:50 * wolfman8k attempts to add perlin noise to haskell raytracer
07:28:58 <balkan> shapr: again 1 - (-2) = 3
07:29:00 <shapr> If you have a computation that uses the first two items to return a result, and can incrementally return results, then it will work on infinite lists. If it requires the last two items to start returning a result, then it won't work with infinite lists.
07:29:21 <shapr> because, infinite lists don't have last items.
07:29:32 <shapr> Not that I've ever found :-)
07:29:56 <wli> well, that's the definition of infinite list
07:29:57 <balkan> shapr: and 3 -(-9) = 12
07:30:08 <Igloo> 'course they do. The last 2 elements of let xs = 1:xs in xs are both 1!
07:30:17 <shapr> Igloo: oooh, clever!
07:30:33 <CosmicRay> how is it possible for foldr to work on an infinite list?
07:30:38 <shapr> I don't think it can.
07:30:48 <wli> I don't believe that works, because assuming there were a last element, it would have a successor, which is a contradiction
07:30:51 <shapr> foldr wants to return a single result from all the items in a list.
07:30:51 <CosmicRay> since it would have to evaluate every element before producing a result
07:30:55 <balkan> shapr: ok. i buy that. but i cannot see it coming from your example with the foldl1 (-) [1,-2,-9] and foldr1 (-) [1,-2,-9].
07:31:02 <Igloo> Cos: foldr (\x _ -> x) 0 [1..] == 1
07:31:27 <shapr> balkan: can't see what?
07:31:53 <balkan> shapr: that foldr would work on infinite lists and foldl not.
07:32:35 <Igloo> If you follow what the functions do, foldl doesn't actually return anything until the [] case
07:32:50 <wli> hm, foldl would need to be nonstrict in its first arg
07:32:51 <Igloo> foldr immediately gives you f x (foldr f e xs)
07:32:55 <wli> so fold (flip const)
07:33:04 <Igloo> Which can give you some result if f is lazy in its second argument
07:33:23 <wli> which diverges I guess
07:34:01 <wli> foldl (flip const) 0 [1..] diverges
07:34:27 <shapr> balkan: I didn't actually say that, you did... I thought you were asking a question from a book or something :-)
07:34:29 <wli> woops
07:34:32 <wli> duality went wrong
07:34:37 <wli> foldl const it must be
07:34:39 <jadrian> "slightly off topic"
07:34:44 <CosmicRay> Igloo: ah.
07:34:50 <jadrian> anyone familiar with unification theory?
07:35:14 <wli> fold const x ys == x when ys is finite, _|_ otherwise it appears
07:35:15 <balkan> shapr: so we should just say that foldr starts from the beginning of the list and be happy with that?
07:35:19 * jadrian thinks there is a mistake on the Handbook of Automated Reasoning...
07:35:54 <balkan> shapr: but Igloo wrote something interesting...
07:36:11 <Igloo> I write so much it has to happen occasionally
07:36:16 <balkan> shapr: foldr immediately gives you f x (foldr f e xs)
07:36:35 <wli> what's foldl const x (y:ys) give?
07:37:48 <Igloo> foldl const (const x y) ys
07:38:15 <wli> so you just walk the list indefinitely instead of converging
07:39:30 <wli> because it recurses directly and not via the argument of the operation argument
07:40:13 <shapr> balkan: so there's some truth to both answers :-)
07:40:25 <Igloo> Also note that foldl (as opposedto foldl') doesn't actually compute the result as it goes along, so you end up building a huge closure that still needs to be evaluated
07:40:43 <balkan> shapr: apparently...what's const btw?
07:40:59 <Igloo> And if output can be produced lazily then they're space inefficient compared to foldr too
07:41:16 * jadrian finds it easier to just draw it using infix operators
07:41:22 <balkan> Igloo: i have to disagree there. foldl apparently is more efficient. according to Hal Daume atleast.
07:41:35 <Igloo> For what?
07:41:43 <jadrian> balkan: it depends on what you're doing
07:42:10 <balkan> Igloo: don't know. he doesn't mention.
07:42:22 <shapr> foldl is more efficient for monadic ops
07:42:34 <balkan> Igloo: actually he does. but i haven't read that part yet.
07:42:44 <jadrian> shapr: hmm depending on what you mean by that, it may not be...
07:43:09 <jadrian> shapr: one example would be comandic composition 
07:43:42 <jadrian> shapr: composeM [f0,...,fn] x = f0 x >>= f1 >>= ... >>= fn
07:44:07 <jadrian> shapr: you want it to be right associative
07:45:05 <jadrian> but not sure if that is included in what you mean by monadic ops...
07:45:41 <wli> foldr (=<<)?
07:45:46 <jadrian> s/comandic/monadic
07:46:01 <jadrian> wli: errr no
07:46:10 <jadrian> wli: that would apply fn first
07:46:15 <wli> not sure what comonads look like in "Real Life"
07:46:48 <jadrian> I meant monads
07:46:52 <jadrian> that was a typo :)
07:47:05 <jadrian> it's monadic composition
07:47:05 <wli> but there are such things, no?
07:47:16 <jadrian> yes but I don't know about them either :)
07:47:45 <jadrian> that composeM could be defined as
07:47:46 <jadrian> compRM = foldr (\f g-> (\x ->f x >>= g)) return 
07:47:52 <jadrian> which is more efficient than
07:47:56 <jadrian> compLM mfs a  = foldl (>>=) (return a) mfs
07:48:29 <jadrian> because like in the const case, the foldl version always trasverse the whole list
07:48:43 <jadrian> and the foldr version might not
07:49:08 <wli> a monad T = <T, eta, mu> in a category X consists of a functor T: X -> X and two natural transformations eta : I_X -> T and mu : T^2 -> T which make the following diagrams commute... (diagram mess)
07:49:26 <jadrian> brb
07:49:31 <balkan> Igloo: you know how  foldr (:) [] [1..]  starts producing output immediately?
07:50:12 <Igloo> yes
07:51:15 <balkan> Igloo: wouldn't that be something like 1:2:3:4 ..... : [] ?
07:51:38 <Igloo> I don't understand what you're asking
07:52:00 <wli> Dually, a comonad in a category consists of a functor L: A -> A and natural transformations epsilon : L -> I, delta : L -> L^2 which make some more diagrams commute (basically the first one with arrows reversed)
07:52:04 <balkan> Igloo: it seems to me that you need to get to the end of the list before you can produce a list?
07:52:17 <wli> each adjunction defines a comonad
07:52:54 <jadrian> balkan: use parenthesis
07:53:12 <jadrian>  1:(2:(3:(4 ..... : [])))
07:54:47 <jadrian> foldr (:) [] [1,2,3,4...] -> 1 : (foldr (:) [] [2,3,4...]) -> 1 : (2 : (foldr (:) [] [,3,4...])) -> ... -> 1:(2:(3:(4 ..... : [])))
07:55:10 <jadrian> so after the 1st step you already gave  1  available
07:55:18 <jadrian> after the second step you have 1 and 2 
07:55:19 <jadrian> etc
07:55:34 <balkan> jadrian: so i would need no evaluate the innermost parentheses first or?
07:55:46 <jadrian> no
07:55:59 <jadrian> if you do  head (foldr (:) [] [1,2,3,4...])
07:56:03 <wolfman8k> should i keep using vim to edit haskell programs, or should i switch to emacs?
07:56:06 <jadrian> is just reduces to
07:56:15 <jadrian> head (1 : (foldr (:) [] [2,3,4...]))
07:56:19 <jadrian> which is 1
07:57:03 <balkan> jadrian: ok, i think i understand. this has to do with lazyness?
07:57:13 <jadrian> wolfman8k: you should switch to emacs and then tell me wether I should keep using emacs or switch to vim :D
07:57:17 <jadrian> balkan: yeap
07:57:31 <wolfman8k> ok, but why doesn't emacs enable syntax highliting by default and how do i turn it on?
07:57:57 <balkan> wolfman8k: don't go to the dark side...
07:58:04 <jadrian> wolfman8k: err I wasn't telling you to sweitch, never used vim for haskell, was just kidding ;) as for the emacs mode
07:58:22 <shapr> you could use Yi, it's an editor written in Haskell
07:58:46 <wolfman8k> problem is vim doesn't seem to work well with haskell
07:58:53 <shapr> it doesn't do any syntax highlighting yet though.
07:58:54 <wolfman8k> i'd like the editor to help me out with the layout
07:59:21 <jadrian> there is a new mode
07:59:26 <wolfman8k> i switched to vim from emacs years ago since it dealt better with c/c++ out of the box
07:59:42 <wolfman8k> i don't like configuring my editor
07:59:45 <wolfman8k> i just want something that works
07:59:53 <wolfman8k> and vim doesn't work very well with haskell(at least out of the box)
07:59:59 <wolfman8k> and i heard that all the haskell programmers use emacs
08:00:06 <wolfman8k> so i am hoping that emacs does haskell well out of the box
08:00:18 <jadrian> wolfman8k: http://www-perso.iro.umontreal.ca/~monnier/elisp/
08:00:22 <balkan> jadrian: why wouldn't foldl (:) [] [1..]  work?
08:00:40 <jadrian> wolfman8k: xemacs comes with an haskell mode, but this one is more recent
08:00:54 <balkan> jadrian: can it be seen by the use of parentheses?
08:01:27 <jadrian> balkan: because you'd be doing  (([]:1):2)... which is wrong ;)
08:01:29 <wolfman8k> thanks, but if i'm gonna be installing editor plugins and stuff then i might as well do it with vim :/
08:01:39 <jadrian> k :)
08:02:06 <jadrian> brb
08:02:17 <balkan> jadrian: if we have our analogue 1:2:3:4....:[]
08:02:24 <wolfman8k> what's the command for auto indenting code in emacs?
08:02:36 <balkan> jadrian: how would that be written with parentheses?
08:05:00 <balkan> jadrian: i guess it wouldn't at all be written that way...judging by what you said earlier.
08:07:53 <wolfman8k> btw, are there any haskell IDEs or anything?
08:08:59 <earthy> http://eclipsefp.sf.net/
08:09:51 <earthy> http://www.cs.kent.ac.uk/projects/vital/
08:11:39 <Cale> MegaMonad: What do you think of Haskell IDE's?
08:11:45 <MegaMonad> Cale: Write me a bunch of haskell ide's?
08:11:50 <earthy> ;)
08:11:53 <Cale> heh
08:12:13 <Cale> nie
08:12:14 <Cale> nice*
08:12:35 <wolfman8k> Cale: hi!
08:12:37 <Cale> hi
08:12:44 <wolfman8k> your internet is working again?
08:12:52 <Cale> It's been working for a while
08:13:00 <wolfman8k> nice
08:13:08 <wolfman8k> i'm gonna add a perlin noise shader to the raytracer
08:15:02 <Cale> cool
08:15:30 <bourbaki> hehe
08:15:35 <bourbaki> another raytracer ?
08:15:36 <wolfman8k> and then i have this really sweet idea for a shader
08:15:46 <wolfman8k> bourbaki: it's not "another", it's *the* raytracer!
08:15:52 <jadrian> wolfman8k: you should only have to turn on haskell-indent-mode
08:15:53 <bourbaki> oh i see ;)
08:16:05 <jadrian> wolfman8k: which should be on by default
08:16:07 <wolfman8k> jadrian: how do i do that?
08:16:17 <wolfman8k> jadrian: i'm in Fundamental mode
08:16:32 <jadrian> wolfman8k: emacs or xemacs?
08:16:38 <wolfman8k> emacs
08:16:43 <wolfman8k> the gtk version
08:16:49 <jadrian> wolfman8k: if you have the needed files it should just be
08:16:59 <wolfman8k> i guess i don't have the needed files
08:17:12 <jadrian> wolfman8k: M-x haskell-indent-mode
08:17:19 <jadrian> where M-x should be Alt-x
08:17:25 <jadrian> wolfman8k: yes you proabbly don't...
08:17:34 <wolfman8k> don't have that
08:17:45 <jadrian> xemacs comes with the previous version of haskell mode
08:17:49 <jadrian> I don't think emacs does
08:17:54 <jadrian> but you can get them here:
08:18:01 <jadrian> http://www-perso.iro.umontreal.ca/~monnier/elisp/
08:18:21 <jadrian> balkan: 1:(2:(3:(4....:([])
08:18:46 <jadrian> balkan: notice that  (2:[]) makes sense ([]:2) doesn't 
08:18:48 * jadrian is away
08:20:00 <yasam> has anyone written a Clifford algebra module? 
08:20:07 <balkan> jadrian: i don't see ([]:2) in your expression.
08:21:06 <balkan> jadrian: in fact it looks exactly like foldr!
08:23:58 <Igloo> Any suggestions for a fast list-a-like where I want fast cons, fast init and to beable to look through from the head to tail quickly?
08:29:29 <shapr> haskell-mode 2.0 has some definite improvements
08:29:33 * shapr bounces cheerfully
08:29:50 <wolfman8k> shapr: i just installed it... it seems to work
08:29:55 <wolfman8k> shapr: how do i indent my code?
08:30:26 <shapr> hit tab
08:31:32 <wolfman8k> cool, seems to work, but it doesn't like code like this
08:31:42 <wolfman8k> a = 1
08:31:43 <wolfman8k> b = 2
08:31:44 <jadrian> Igloo: hmmm which of those requirements does "list" fails at?
08:31:54 <wolfman8k> it indents the second line... i need to have blank line in between them bot
08:32:15 <jadrian> balkan: ([]:1) appears in your expression, the foldl one
08:32:38 <Igloo> Fast init
08:32:59 <jadrian> what's init, I thougth you meant "[]"
08:33:20 <Igloo> Like tail, but all but the last element, not first
08:33:27 <jadrian> oh!
08:33:31 <jadrian> that init
08:34:07 <balkan> jadrian: foldl should be ((((1:2):3):4)....):[]
08:34:39 <jadrian> balkan: it would also be wrong because 1:2 makes no sense (2 is not a list)
08:34:43 <jadrian> balkan: but no
08:35:05 <jadrian> balkan:  foldl would be  (((([]:1):2):3):4)....)
08:35:13 <jadrian> balkan: which is also wrong
08:35:47 <wli> foldl (flip (:))
08:36:27 <balkan> jadrian: ok. i was confused. foldl actually starts with the initial value and the front of the list. is that correct?
08:36:37 <jadrian> balkan: yeap
08:36:56 <jadrian> brb
08:36:56 <balkan> jadrian: and foldr starts with the initial value and the end of the list?
08:42:04 <maeglin> i am currently using hugs and it doesn't seem to have Char.isLower
08:42:12 <maeglin> how can i "include" it ?
08:43:52 <shapr> maeglin: either import Data.Char in your program, or :m + Data.Char interactively
08:44:27 <shapr> balkan: ah, so the original question was why does "foldr (:) [] [1..9]" but not with foldl ?
08:45:10 <balkan> shapr: i forgot the original question. but it's been a good trip...
08:45:27 <shapr> that's good enough :-)
08:45:33 <shapr> The journey is as much fun as the goal.
08:45:55 <balkan> shapr: i don't think i'll ever reach the goal...
08:46:08 <shapr> That depends on your goal of course.
08:46:11 <shapr> I want to know everything.
08:46:26 <balkan> shapr: that's a plausible goal.
08:46:36 <maeglin> thx shapr 
08:46:48 <shapr> My short term goal is to know everything about programming.
08:46:51 * shapr snickers
08:47:20 <balkan> shapr: i want to create programs that are easy to read. not write.
08:47:38 <shapr> That's easier than most people think.
08:48:01 <maeglin> hugs says "ERROR - Cannot find module "Data.Char"
08:48:15 <shapr> If you use Test Driven Development with merciless refactoring, your programs will always be easy to read.
08:48:43 <balkan> shapr: i don't know...
08:49:10 <shapr> maeglin: If you're using a very old Hugs, it won't understand hierarchical modules.
08:49:46 <maeglin> Version: November 2003
08:49:50 <maeglin> it's the one that comes with gentoo
08:50:34 <wolfman8k> can someone please help me... what's the best way to layout this code? http://rafb.net/paste/results/WKa9bB11.html
08:50:39 <wolfman8k> it's one function
08:50:40 <shapr> I don't what version first understood hierarchical modules.
08:51:30 <shapr> wolfman8k: I'd probably put the let stuff into a where clause so I could use guards.
08:51:41 <wolfman8k> shapr: hm...
08:51:45 <shapr> well, maybe
08:51:49 * shapr tries it
08:51:55 <wolfman8k> what's the difference between let and where anyway?
08:53:13 <shapr> nothing really, just depends on how you want to explain yourself.
08:53:36 <wolfman8k> is the way i indented everything good?
08:53:37 <shapr> Some functions don't make sense unless you know the detail ahead of time, some don't make sense if you do.
08:53:45 <shapr> looks good to me.
08:54:04 <wolfman8k> the weird thing is
08:54:10 <wolfman8k> if i try to put that last Nothing on a new line
08:54:23 <wolfman8k> emacs indents it in line with the "else"
08:54:37 <shapr> yah, emacs has flaky indentation like that sometimes
08:54:57 <maeglin> shapr: i just found out that all functions from the Char module lie in my "main" namespace: i can call isLower from top level
08:55:12 <maeglin> so does this mean my hugs version is kinda out dated ?
08:55:40 <shapr> I dunno if it's outdated, but I don't think you're using the latest version.
08:55:58 <maeglin> um, probably..
08:56:20 <maeglin> don't want to compile ghc here
08:58:03 <wolfman8k> shapr: what do you think of this? http://rafb.net/paste/results/bb841K61.html
08:58:20 <wolfman8k> the way i did the if/else in the last 4 lines
08:58:39 <wolfman8k> actually, i don't like it
08:58:43 <shapr> I try not to use if/else
08:58:47 <wolfman8k> :O
08:58:50 <wolfman8k> what do you use then?
08:59:00 <shapr> guards, pattern matching, stuff like that.
08:59:37 <wolfman8k> can i do something like, case d > 0.0; true -> ... ; false -> ... ?
08:59:39 <shapr> I'm not saying this is not nice layout, just that if/else feels more procedural to me, I try to emphasize the evaluation aspect of Haskell with the layout of my code.
09:00:09 <shapr> Yes, you can do that.
09:00:18 <shapr> if/then is shorthand for that.
09:00:18 <wolfman8k> and that is better then if/else?
09:00:46 <shapr> hmm, not hugely better, no.
09:01:02 <wolfman8k> i think it's uglier even
09:01:29 <shapr> You should ask philippa, who is not here right now...
09:01:50 <shapr> philippa has an excellent grasp of good code layout, far better than mine.
09:01:50 <wolfman8k> hm...
09:01:55 <wolfman8k> ok thanks for the tip
09:02:17 <shapr> in fact, you may want to look at the Flippi sources to see why I think that.
09:02:23 <shapr> It may give you some tips on good style too.
09:02:54 <wli> #1 style tip: don't do what I do in ghci in your code
09:04:51 <wolfman8k> man... too bad haskell isn't like python where your layout is forced :/
09:05:40 <ralf> speaking of ghci, Has anyone seen this error in ghci:
09:05:42 <ralf> Loading package base ... /usr/lib/ghc-6.2/HSbase.o: unknown architecture
09:05:43 <ralf> ghc-6.2: panic! (the `impossible' happened, GHC version 6.2):
09:05:43 <ralf> 	loadObj: failed
09:05:45 <ralf> ?
09:06:11 <ralf> Does ghci not work for ibooks?  I did have the problem before that mit-scheme did not work for this architecture. 
09:08:33 <bourbaki> will something like    if foo then bar else let ... lead to complications?
09:08:39 <shapr> I'm pretty sure there is a GHC version for Mac OS X
09:09:18 <yasam> yes there is
09:10:10 <wolfman8k> shapr: what do you think of this?
09:10:11 <wolfman8k> http://rafb.net/paste/results/2XtQJN87.html
09:10:49 <shapr> looks better to me.
09:15:58 <bourbak1> can someone tell my why this wont work? http://paste.phpfi.com/42791
09:16:19 <wolfman8k> shapr: what do you think of this? http://rafb.net/paste/results/qyCR2X35.html
09:19:29 <wolfman8k> damn emacs sucks eggs... it won't let me keep a consistent indentation style
09:20:02 <wolfman8k> i don't get it... how do people code haskell if there is no editor support for it?
09:20:10 <wolfman8k> what does everyone use? notepad? :)
09:20:16 <Marvin--> vim?
09:20:23 <sh10151> emacs haskell-mode works for me
09:20:28 <sh10151> what are you trying to do?
09:20:29 <wolfman8k> vim is even worse
09:20:43 <wolfman8k> sh10151: i just want it to help me a little with the indentation
09:20:54 <wolfman8k> sh10151: it sort of works, but not consistently
09:20:55 <sh10151> it does
09:20:59 <wli> I do the hairy-chested nvi and sometimes ex/ed thing
09:21:06 <Marvin--> "a little" or "DWIM"?
09:21:11 <sh10151> you have haskell-mode installed, right?
09:21:18 <wolfman8k> sh10151: yeah
09:21:22 <bourbak1> can someone have a look at this linePList function? and tell me if that if then else construct is ok?
09:21:46 <wolfman8k> maybe i should be using xemacs?
09:21:48 <sh10151> the style I get out of emacs is pretty consistent, with the exception of continuing long lines
09:21:53 <sh10151> no, it will work the same in both
09:21:59 <sh10151> what are you looking for that is not htere?
09:22:32 <wolfman8k> what's the best way to indent:
09:22:36 <wolfman8k> let x = 1
09:22:41 <wolfman8k>     y = 2
09:22:45 <wolfman8k>     z = 3 in
09:22:51 <wolfman8k> foo x y z
09:22:54 <wolfman8k> ?
09:23:03 <wolfman8k> like that?
09:23:19 <Marvin--> I usually put the 'in' on the same line as 'foo'
09:23:27 <wolfman8k> hm... i'll try that
09:23:37 <Marvin--> but I'm not an emacs user
09:23:57 <sh10151> no
09:24:06 <sh10151> the foo should be indented under the other variables
09:24:22 <sh10151> think of scheme's let
09:24:47 <wolfman8k> the f should be directly under the z?
09:24:49 <sh10151> this is also what haskell-mode does first :)
09:25:05 <sh10151> yes, otherwise your indentation isn't communicating scope
09:25:38 <wolfman8k> what about
09:25:46 <wolfman8k> case x of
09:25:56 <wolfman8k>     1 -> 2
09:26:00 <wolfman8k>     2 -> 3
09:26:23 <wolfman8k> emacs seems to want to indent the second line so that the 1 is under the o
09:26:36 <wolfman8k> which sucks when x is a very long string
09:27:36 <sh10151> you do know that haskell-mode cycles through alternatives when you hit tab again, right?
09:27:56 <wolfman8k> yes, it's either that though, or having the 1 under the c
09:28:08 <wolfman8k> i guess i'll go for the 1 under the c then
09:28:24 <wolfman8k> the other option is to have "of" be on a line of it's own
09:28:31 <sh10151> or use patterns
09:28:32 <wolfman8k> then i can have the 1 indented a nice amount
09:28:36 <sh10151> don't work against the language
09:28:36 <wolfman8k> what's that?
09:29:04 <sh10151> f 1 = 2
09:29:06 <sh10151> f 2 = 3
09:29:09 <sh10151> eyv
09:29:11 <sh10151> er, etc
09:29:37 <wolfman8k> well, this is my function: http://rafb.net/paste/results/7A3YdQ82.html
09:34:19 <yasam> what does fffi stand for?
09:35:56 <sh10151> wolfman8k: first I would make the behavior under Just its own function
09:36:17 <wolfman8k> which Just?
09:36:23 <sh10151> topmost
09:36:30 <wolfman8k> ok
09:37:21 <sh10151> actually I think I would approach this completely differently, myself.
09:37:25 <wolfman8k> it's been quite a while... i forgot what this funtion even does :D
09:37:32 <sh10151> you should be able to use some higher order functions
09:37:42 <wolfman8k> hm..
09:38:06 <sh10151> it looks like a fold to me
09:38:15 <Lemmih> yasam: f Foreign Function Interface.
09:38:39 <Lemmih> yasam: -f<something> enables <something> in GHC.
09:38:48 <wolfman8k> sh10151: it's basicly performing intersectRaySphere on all the elements of the list and then processing the result that has the lowest value
09:39:39 <ralf> shapr: I'm logging off soon.  Re: an earlier comment.  Note that ghc does work on my ibook.  It is ghci which does not work.  Also note that I am running debian, not OS X on said ibook.  
09:40:08 <yasam> ahh now I get the extra f
09:40:31 <wolfman8k> sh10151: aside from all this though, do you think that i indented everything properly?
09:42:16 <sh10151> that looks readable to me
09:42:30 <sh10151> as readable as non-haskellish Haskell can be
09:42:36 <wolfman8k> ok, thanks!
09:42:49 <wolfman8k> i gotta go eat now... maybe when i come back you can help me make it more haskellish ;)
09:42:59 <wolfman8k> i'll think about fold while i eat :D
09:52:19 <monk00> hey, i am new to haskell and i have a problem
09:53:35 <sh10151> that's ok, we all have problems regardless of haskell knowledge
09:53:54 <wolfman8k> ok i'm back
09:53:56 <monk00> i am trying to make a "isprime x y" function.. i.e. "isprime 11 5" will check from 5 downto 2 if someone divides 11
09:54:07 <monk00> isprime x y | ((x `mod` y) /= 0)&&(y>1)&&(isprime x (y-1)) = True
09:54:07 <monk00>             | ((x `mod` y) == 0)&&(y>1)                    = False
09:54:07 <monk00>             | (y==1)                                       = True
09:54:33 <monk00> the problem is that sometimes i get an error "Main> isprime 10 6
09:54:33 <monk00> Program error: pattern match failure: isprime instIntegral_v36 10 6 
09:54:44 <monk00> whats wrong ?
09:55:11 <Marvin--> monk00: you probably shouldn't use guards so much :)
09:55:58 <Marvin--> monk00: you know that you can write a function definition using several LHSes right?
09:56:16 <monk00> LHS = ?
09:56:23 <Marvin--> left hand side
09:56:28 <monk00> yes
09:56:38 <wolfman8k> is emacs haskell indentation supposed to understand do syntax?
09:56:43 <monk00> oo , i see
09:56:57 <monk00> you mean like declare this : isprime x 1 = True
09:57:05 <Marvin--> monk00: so for starters, you could have one lhs for  isprime x 1  and then another for .... yes, exactly :)
09:57:17 * Marvin-- is too lazy to delete what he already typed
09:57:53 <Marvin--> hey Syntax, ltns!
09:58:54 <SyntaxNinja> y0y0
09:59:01 <SyntaxNinja> how's it going Marvin--? long time no see.
10:00:26 <sh10151> monk00: here's a freebie for you
10:00:40 <Marvin--> SyntaxNinja: just fine, being connection-less for a while has just made me forget to start xchat :)
10:00:42 <sh10151> isPrime x = foldl1 (&&) [x `mod` y /= 0 | y <- [x-1, x-2..2]]
10:00:51 <sh10151> don't say I never gave you an incomplete answer
10:01:24 <monk00> sh10151 : thanx :) but whats  wrong with my code ?
10:01:25 <Marvin--> sh10151: now now, don't scare the newbie :-P
10:01:37 <SyntaxNinja> Marvin--: any advice for monk00?
10:01:43 <SyntaxNinja> er
10:01:49 <SyntaxNinja> I meant to ask MegaMonad
10:01:54 <SyntaxNinja> MegaMonad: any advice for monk00?
10:02:01 <MegaMonad> SyntaxNinja: Http://monk.
10:03:43 <Marvin--> monk00: well, I'm of the opinion that if your right-hand-sides contain just True or False, then you have too complex left-hand-sides, try moving some of the logic from the guards into expressions in the right hand side
10:04:09 <sh10151> wolfman8k: haskell-mode understands do syntax
10:04:48 <wolfman8k> sh10151: it doesn't seem to like two let lines, it tries to indent the second
10:05:30 <monk00> so you cant see any errors in my code?
10:05:40 <wolfman8k> hm... actually the problem is that it doesn't seem to like blank lines
10:05:51 <wolfman8k> in general is it bad to have blank lines in haskell code?
10:06:41 <Marvin--> monk00: I think it's too hard to read to begin with :P but yes I have a few ideas about what's wrong but I'm trying to "help you to help yourself"
10:08:03 <Marvin--> monk00: you do know how guards work, right?
10:08:59 <bourbak1> how can you make [[a]] -> [a] ? just add all the lists up to a single one
10:09:55 <Marvin--> bourbak1: huh? concat?
10:10:23 <bourbak1> Marvin--: thx
10:10:57 <sh10151> wolfman8k: that would do it, haskell-mode only looks one line up for indentation hints
10:11:07 <SyntaxNinja> speaking of haskell mode, Marvin-- did you check out haskell-mode 2.0 from haskell-unsafe?
10:11:12 <sh10151> wolfman8k bad, good, emacs is the guy with the gun
10:11:33 <SyntaxNinja> and some general advice: don't take haskell-mode's idea of your coding style to heart. it's rather flaky. 
10:11:37 <Marvin--> SyntaxNinja: *lalalala*
10:11:40 <yasam> typing a / or ~ works too
10:11:43 <Marvin--> SyntaxNinja: I'm a vim user :)
10:11:46 <sh10151> a pox on thee heathen
10:11:51 <SyntaxNinja> Marvin--: bah
10:12:04 <sh10151> from the word of God to man, mediated by the Holy Emacs
10:12:09 <sh10151> such is the way of Code
10:12:24 <yasam> ignore what i said
10:13:25 <wolfman8k> what gun?
10:13:33 <monk0> back
10:13:38 <sh10151> you know, the boomstick
10:13:38 <Lemmih> Welcome back monk0 
10:13:48 <sh10151> that emacs shows all of the primitive screwheads
10:16:04 <Marvin--> monk0: connectivity problems?
10:16:38 <Marvin--> monk0: to repeat myself, do you know how guards work, more precisely?
10:17:06 * Marvin-- ponders applying for that PhD student position in Utrecht
10:18:01 <wolfman8k> what's that ghc switch for linking with a package?
10:18:16 <monk0> by saying guards you mean "|" ?
10:18:21 <Lemmih> wolfman8k: -package ?
10:18:50 <Lemmih> wolfman8k: Or: -optl -l
10:19:25 <Marvin--> monk0: yes
10:19:36 <monk0> yes, its like if's
10:19:48 <wolfman8k> Lemmih: thanks, that's it
10:19:50 <monk0> starts checking from top to bottom until it find a match
10:20:19 <Marvin--> monk0: right, but the reason you get an error is that there's a case that none of your guards match
10:20:29 <monk0> oo, i see
10:20:34 <Marvin--> monk0: the guards are basically translated into    if g1 then e1 else if g2 then g2 else error
10:20:44 <monk0> yes, i got it
10:20:59 <monk0> i thought i included all cases
10:21:09 <monk0> give me a min to search :) thanx
10:21:18 <Marvin--> well, thing is, since you put all the logic in the guards, it's hard to see
10:22:38 <Marvin--> if you remove the  (y > 1)  part (since you have a separate pattern for that now), can't you move some of the logic over to the right hand side too?
10:23:06 <monk0> till now , my function looks like this :
10:23:07 <monk0> isprime x 1 = True
10:23:08 <monk0> isprime x y | (((x `mod` y) /= 0)&&(isprime x (y-1))) = True
10:23:08 <monk0>             | ((x `mod` y) == 0)                      = False
10:24:05 <Marvin--> consider this, what happens if you move the recursive call over to the right hand side? what changes do you have to do?
10:25:26 <monk0> i got it :)
10:25:36 <monk0> isprime x 1 = True
10:25:36 <monk0> isprime x y | ((x `mod` y) /= 0) = isprime x (y-1)
10:25:36 <monk0>             | ((x `mod` y) == 0) = False
10:25:59 <kosmikus> Marvin--: which position?
10:26:18 <Marvin--> kosmikus: http://www.cs.uu.nl/vacatures/62411.html
10:26:50 <Marvin--> monk0: right, and notice now that the second guard is the negation of the first one
10:26:51 <kosmikus> ok, that one
10:27:17 <monk0> you mean replace it with "otherwise".. right
10:27:37 <monk0> i think i make my life harder :)
10:27:43 <monk0> thanx Marvin--
10:29:05 <Marvin--> monk0: sure, but now you have something on the form    if a then b else False,  and this is equivalent to   a && b   so you could put that in the right hand side instead and drop the guards altogether
10:29:08 <kosmikus> monk0: ... | cond1 = cond2 | otherwise = False   ==>   ... = cond1 && cond2
10:29:31 * Marvin-- has been implementing and debugging simplification rules all day ;)
10:33:41 <marcot> Hello, I'm developing a p2p Chess game in Haskell. It's hosted in savannah, at: http://savannah.nongnu.org/projects/xadrez-haskell/
10:33:42 <wolfman8k> what's the best way to "branch" if my 3 cases are, x < a, x >=a && x <= b, x > b ?
10:33:58 <monk0> you mean like this : isprime x y = ((x `mod` y) /= 0) && (isprime x (y-1)) 
10:33:58 <monk0> ?
10:34:17 <Marvin--> monk0: exactly
10:34:24 <Marvin--> but you don't need that many parentheses
10:34:48 <monk0> which one can i omit ? the outer ?
10:34:55 <Marvin--> isprime x y = (x `mod` y) /= 0 && isprime x (y-1)
10:35:11 <monk0> i see
10:35:17 <monk0> thanx for the help Marvin--
10:36:01 <sh10151> from a definitional perspective
10:36:07 <sh10151> isPrime should take one argument :)
10:36:52 <sh10151> wolfman8k: you could use a guard, might want an 'otherwise' in case
10:37:13 <wolfman8k> sh10151: hm... what's a guard again? =]
10:37:25 <sh10151> easier to read case statements
10:37:27 <Marvin--> wolfman8k: the pipes :)
10:37:31 <monk0> sh10151 : but then how will i keep track where am i ?
10:37:55 <wolfman8k> right... thanks
10:37:59 <wolfman8k> shit gotta go brb
10:38:01 <sh10151> monk0: computers are very good at keeping track of such bookkeeping things
10:40:54 <ihb> hi. i have a general question about recursive algorithms. i hope it's OK to ask it here. are there any algorithms that 1) can't be written without having several functions interacting like "foo = ... bar ...; bar = ... foo ...;", or 2) are there algorithms where this is beneficial?
10:41:41 <musasabi> ihb: several algorithms use mutual recursion..
10:41:53 <musasabi> ihb: but depends on your definition of "one function".
10:41:54 <ihb> musasabi: can they be written without?
10:42:07 <musasabi> ihb: what is one function?
10:44:31 <ihb> musasabi: let's consider the case with no closures. does that narrow it down?
10:44:42 * musasabi was thinking math
10:44:58 * ihb was thinking programming
10:45:23 <vincenz> ihb: I think not
10:45:32 <vincenz> ihb: I think you can have algorithms that use only one recursive function
10:45:42 <vincenz> ihb: it's easy to show
10:46:01 <vincenz> let's assume both foo and bar take one parameter
10:46:05 <ihb> how do you define a function, and can you point me to an algorithm that uses mutual recursion?
10:46:12 <vincenz> wait
10:46:17 <vincenz> add an extra parameter
10:46:19 <vincenz> and then make it
10:46:23 <vincenz> new 1 = foo
10:46:25 <vincenz> new 2 = bar
10:46:27 <vincenz> and then
10:46:39 <vincenz> let new x param = if x = 1 then foo code else bar code
10:46:50 <vincenz> (ml syntax but)
10:47:56 <vincenz> so mutual recursion is not needed
10:47:58 <vincenz> you can work it away
10:49:28 <ihb> vincenz: what if foo and bar has a different arity?
10:49:45 <monk00> back again
10:49:57 <vincenz> ihb: easy
10:49:59 <vincenz> let's say 
10:50:01 <vincenz> foo a b
10:50:03 <vincenz> bar c d
10:50:04 <vincenz> make
10:50:07 <vincenz> new x a b c d
10:50:11 <vincenz> and pass dummy params where not needed
10:50:19 <basti_> oof
10:50:26 <vincenz> yes it's ugly
10:50:28 <ihb> vincenz: which is just silly, but i'm with you.
10:50:33 <vincenz> yes, silly
10:50:34 <musasabi> ihb: but consider f and g are two mutually recursive functions. Function f' contains them both...
10:50:40 <vincenz> but mutual recursion is syntactic sugar
10:50:44 <musasabi> f a = ...
10:50:47 <musasabi> g a = ...
10:50:51 <vincenz> all you need is recursion
10:51:07 <ihb> vincenz: ok, good. i just wanted someone to agree with me. :-)
10:51:20 <musasabi> f' a = f a \n where f a = ... \n \t g a = ...
10:51:41 <ihb> so to next question, which algorithms benefit from mutual recursion? any (good or real world) example?
10:51:45 <vincenz> no idea
10:51:54 * vincenz doesn't have a computer science background
10:52:29 <basti_> hmm
10:52:46 <basti_> ihb: there is an algorithm for finding the median of a set that does some sort of "mutual recursion"
10:53:21 <vincenz> musasabi: internally you still have mutually recursive functions..
10:53:35 <vincenz> ihb: what's the big issue with removing mutual recursion?
10:53:58 <vincenz> besides any recursive function is mutually recursive with itself :
10:53:59 <vincenz> :P
10:54:35 <musasabi> vincenz: that is just an implementation detail then ;)
10:54:40 <ihb> vincenz: yeah. well, it's a pretty specific programming problem (and not really a problem either :-)), so it's not of great interest to anyone else.
10:55:01 <vincenz> now my sheep...now that I'v convinced you
10:55:04 <vincenz> follow me to #ocaml!
10:55:12 <vincenz> :D
10:55:47 <ihb> i can't remember which type of paradigm ocaml uses.
10:55:53 <vincenz> three
10:55:59 <vincenz> functional, imperative and oo
10:56:04 <vincenz> though predominantly functional
10:56:15 <SyntaxNinja> Say No to OCaml
10:56:21 * vincenz slaps SyntaxNinja accross the face
10:56:27 <Lemmih> ocaml: No!
10:56:35 <musasabi> Haskell feels much nicer than Ocaml.
10:57:08 <vincenz> no it doesn't
10:57:14 <vincenz> except if you like bondage
10:57:27 <vincenz> about the only thing that I know in haskell that could be added to ocaml is typeclasses
10:57:48 <CosmicRay> actually, Haskell *does* feel much nicer than ocaml.
10:57:56 <CosmicRay> mostly, that is beacuse of the syntax
10:58:02 <CosmicRay> ocaml feels like a functional fortran sometimes.
10:58:12 <basti_> indeed.
10:58:19 <vincenz> I disagree
10:58:23 <basti_> ;)
10:58:28 <CosmicRay> its syntax with if/then, and match, is often misleading and it often doesn't do what one expects 
10:58:31 <wolfman8k> sweet, my "gradient" shader works!
10:58:41 <basti_> i dislike "seperator" languages btw.
10:58:49 <vincenz> separators?
10:59:02 <basti_> as in "do a;b;c"
10:59:04 <vincenz> oh
10:59:12 <basti_> opposed to "do a;b;c;"
10:59:12 <vincenz> well that's cause haskell doesn't allow side-effects
10:59:20 <SyntaxNinja> vincenz: no slapping
10:59:20 <basti_> i just mean syntactically
10:59:25 <CosmicRay> vincenz: it would be well for ocaml to mimic that
10:59:29 <musasabi> vincenz: yes, and that is very good.
10:59:29 <wolfman8k> high order functions rock. also lambda functions
10:59:33 * vincenz slaps SyntaxNinja again with the tail of a recursive function
10:59:37 <CosmicRay> there aren't all that many true functional ocaml programs
10:59:38 <musasabi> that produces readable code.
10:59:55 <SyntaxNinja> vincenz: I'm being lazy now, but when I need to, I'll evaluate some retaliation.
11:00:04 <Lemmih> haha
11:00:05 <musasabi> lazy, pure and powerfull static typing <3
11:00:05 <vincenz> lazy evaluation...
11:00:08 <CosmicRay> otoh, it is nice to sometimes be able to prerr "I'm in the loop" for debugging
11:00:14 <vincenz> musasabi: ocaml has static typing as well
11:00:16 <CosmicRay> and the fact that one can't get stack traces out of haskell is damn annoying
11:00:26 <jadrian> you kind of can...
11:00:30 <musasabi> vincenz: yes, so does C++ (ok this is mean)
11:00:39 <CosmicRay> vincenz: but really, the only real thing ocaml has over haskell is speed in certain situations
11:00:44 <wolfman8k> http://img133.exs.cx/img133/5049/haskellraytrace106ce.png
11:00:45 <SyntaxNinja> word
11:00:55 <jadrian> with  Debug.Trace.trace
11:01:04 <jadrian> @Debug.Trace.trace
11:01:04 <lambdabot> Sorry, I don't know the command "Debug.Trace.trace", try "lambdabot: @listcomman
11:01:04 <lambdabot> s"
11:01:05 <vincenz> musasabi: ocaml requires less typing info than haskell
11:01:11 <vincenz> musasabi: it has hindley milner
11:01:17 <CosmicRay> vincenz: Sometimes I am tempted to say that Haskell's pervasive laziness is a liability, when one has to use seq..
11:01:18 <vincenz> and it's strongly typed
11:01:20 <CosmicRay> vincenz: that's wrong.
11:01:27 <jadrian> lambdabot:  what do you mean you don't know?
11:01:27 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
11:01:29 <CosmicRay> vincenz: haskell and ocaml's type systems are very similar
11:01:40 <SyntaxNinja> @type Debug.Trace.trace
11:01:41 <CosmicRay> vincenz: haskell's being somewhat more powerful thanks to typeclasses, imho
11:01:42 <vincenz> CosmicRay: tell that to musasabi, not me
11:01:44 <jadrian> damn... that was good...
11:01:44 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
11:01:55 <jadrian> ah!
11:01:57 <CosmicRay> vincenz: well you're the one saying that ocaml requires less info
11:01:59 <vincenz> CosmicRay: yes I've said before that typeclasses are one of the things I miss
11:02:00 <jadrian> SyntaxNinja: thanks :)
11:02:08 <vincenz> CosmicRay: From what I've seen from examples..
11:02:12 <vincenz> Same info then
11:02:14 * vincenz shrugs
11:02:25 <vincenz> Anyways, musasabi was comparing it to c++
11:02:27 <SyntaxNinja> we should launch a raid against OCaml... if only we weren't so lazy.
11:02:30 <CosmicRay> vincenz: 90% of those times where one puts in the type of a function, it's for readability, not for the compiler.
11:02:34 <SyntaxNinja> we need to get some EagerHaskell folks here.
11:02:35 <musasabi> vincenz: does ocaml have things like ST ?
11:02:39 <CosmicRay> vincenz: just as when people are putting things in a .mli file.
11:02:41 <vincenz> musasabi: if you tell me what ST is
11:02:43 <vincenz> ..
11:02:50 <vincenz> CosmicRay: which is optional
11:02:55 <CosmicRay> my #1 gripe about ocaml is that its lists aren't lazy.
11:03:03 <vincenz> CosmicRay: streams
11:03:07 <CosmicRay> we have to have lists and streams, while haskell has justs lists.
11:03:12 <vincenz> hmm
11:03:16 <CosmicRay> yeah,  I know, and have you seen the size of the standard stream library?
11:03:23 <CosmicRay> about 1 function to do stuff with them.
11:03:25 <monk00> --  how can i trace an expression in hugs ?
11:03:27 <vincenz> well ocaml and haskell are pretty much the same sort of language-area, it's just a matter of preference
11:03:31 <CosmicRay> (aside from creating them, which takes 5 or 6 different options)
11:03:37 <CosmicRay> vincenz: yes, I agree
11:03:38 <vincenz> imho ocaml has better module system, haskell has typeclasses
11:03:49 <CosmicRay> vincenz: ocaml's module system also ticks me off
11:03:54 <CosmicRay> going and making me create .mli files
11:04:03 <CosmicRay> and having not even one single decent building system
11:04:05 <musasabi> vincenz: arbitary rank polymorphism. (but that is an extension)
11:04:05 <SyntaxNinja> typeclasses sorta obviates the need for OCaml's module system, and our module system is getting better all the time :)
11:04:11 <CosmicRay> I maintain about 10 ocaml packages in debian
11:04:18 <CosmicRay> let me say that cabal is already far nicer than anything in ocaml
11:04:23 <SyntaxNinja> :) :)
11:04:27 <vincenz> musasabi: I'm not a computer scientist, use laymen terms
11:04:31 <CosmicRay> SyntaxNinja: ocaml's module system is a lot more intelligable though
11:04:44 <SyntaxNinja> than typeclasses you mean? yeah
11:04:45 <vincenz> what is cabal?
11:04:52 <CosmicRay> vincenz: www.haskell.org/cabal
11:04:52 <SyntaxNinja> http://www.haskell.org/cabal
11:05:16 <vincenz> oh
11:05:19 <CosmicRay> vincenz: ghc --make does approximately what ocaml's findlib, ocamake, and ocamlmake do, all put together.
11:05:22 <vincenz> humps?
11:05:29 <CosmicRay> ./setup build goes farther yet.
11:05:36 <vincenz> CosmicRay: yes but there coming out with something new
11:05:40 <CosmicRay> vincenz: non existant for haskell yet, but being worked on
11:05:41 <vincenz> CosmicRay: a guy made it and it might become standard
11:05:48 <vincenz> s/there/they're
11:05:50 <CosmicRay> vincenz: they always are.  last time it was autoconf crap.
11:05:52 <vincenz> nono
11:05:55 <musasabi> vincenz: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#UNIVERSAL-QUANTIFICATION
11:05:58 <CosmicRay> vincenz: I've griped about that on the lists from time to time
11:05:59 <vincenz> this time it installs packages from net when needed, 
11:06:03 <vincenz> etc..etc..
11:06:12 <CosmicRay> vincenz: ah, sounds like cabal :-)
11:06:13 <vincenz> intelligent findlib that is used during make
11:06:16 <vincenz> etc..etc.
11:06:20 <musasabi> Cabal is quite nice.
11:06:20 <vincenz> but it's not std yet
11:06:23 <CosmicRay> vincenz: actually, that would make ocaml stuff much nicer to build.
11:06:27 <CosmicRay> vincenz: neither is cabal...
11:06:30 <vincenz> One thing I miss is...
11:06:32 <vincenz> jocaml :/
11:06:38 <vincenz> I saw it and noone is maintaining it
11:06:45 <CosmicRay> vincenz: java stuff?
11:06:51 <vincenz> not at all
11:06:55 <vincenz> join calculus
11:07:08 <vincenz> (distributed computing)
11:07:14 <vincenz> it's really cool
11:07:19 <vincenz> distribute programs that are 4 liners
11:07:22 <vincenz> location here {
11:07:25 <CosmicRay> oh, the other thing that really, really, REALLY TICKS ME OFF about ocaml is I/O.  They have a separate type for input than for output.  The standard ocaml library can not open up a file read-write!
11:07:26 <vincenz>   Server.register(here)
11:07:26 <vincenz> }
11:07:42 <SyntaxNinja> 1musthanks :)
11:07:44 <vincenz> distribute a lot of those
11:07:57 <vincenz> and then whenever you have a lot of computation (think SETI)
11:08:02 <SyntaxNinja> er
11:08:04 <vincenz> you have your main program offload computation to the registered locations
11:08:10 <SyntaxNinja> musasabi: thanks
11:08:28 <vincenz> it's really impressive
11:08:35 <vincenz> CosmicRay: Look at the Unix module
11:08:40 <CosmicRay> that does sound interesting vincenz
11:08:44 <CosmicRay> vincenz: I know, that's what I've had to do
11:08:46 <shapr> cabal is standard isn't it?
11:08:50 <CosmicRay> vincenz: but of course, that is a *third* type
11:08:51 <shapr> What's non-standard about Cabal?
11:08:55 <SyntaxNinja> shapr: it's getting there
11:08:56 <vincenz> CosmicRay: problem is that requires changes in the runtime systenm
11:09:08 <vincenz> CosmicRay: and it was done with ocaml 1.08, noone maintained it
11:09:11 <vincenz> :/
11:09:25 <CosmicRay> vincenz: so all the code that uses Pervasives is mutually incompatible
11:09:33 <CosmicRay> vincenz: and about 90% of the code out there does use Pervasives
11:09:39 <vincenz> incompatible?!?
11:09:56 <CosmicRay> I can't pass a file_descr to a function expecting an out_chan
11:10:10 <vincenz> in_channel_of_descr
11:10:12 <CosmicRay> or, worse, an output_chan to a function expecting a file_descr, and have a reliable result either way
11:10:13 <vincenz> just place there
11:10:33 <CosmicRay> right, but in the second case, it's worse, since you don't know if it was really opened read/write to start with (probably not)
11:10:34 <musasabi> SyntaxNinja: btw what would you think about using cabal to build .hc sources and a shell script to gcc+link those on the target system?
11:10:50 <vincenz> CosmicRay: you'd have the same problem if you passed file_descr...
11:10:54 <CosmicRay> and in either case, the semantics are annoying.
11:10:57 <vincenz> now you're mixing language issues with design issues
11:11:00 <SyntaxNinja> musasabi: rather than using ghc to compile & link them, you mena?
11:11:08 <CosmicRay> for instance, what happens if you close the channel made with channel_of_descr but not the descr?
11:11:10 <musasabi> yes.
11:11:16 <CosmicRay> vincenz: it is part of the whole.
11:11:31 <CosmicRay> vincenz: if I am to use a language, and take advantage of the lbiraries already written for it, I am stuck with those libraries.
11:11:36 <musasabi> Would be nice for an automatic way of distributing things for platforms without working ghc.
11:11:42 <vincenz> CosmicRay: what happens if you close the channel that you made available?
11:11:45 <CosmicRay> vincenz: otherwise, I waste so much time rewriting them that there is no point in using anything but Python.
11:11:46 <vincenz> CosmicRay: I really think you're fishing
11:12:01 <CosmicRay> vincenz: I don't know.  It's not documented.
11:12:08 <CosmicRay> vincenz: these are real issues I've encountered in real programs.
11:12:23 <vincenz> and how does haskell solve this?
11:12:23 <SyntaxNinja> musasabi: sounds reasonable... is .hc the output of "-via-c" or is it an ffi thing?
11:12:39 <CosmicRay> vincenz: a haskel Handle can be opened read-write.
11:12:42 <musasabi> SyntaxNinja: -keep-hc-files
11:12:45 <Spark> rah
11:12:49 <shapr> rah
11:12:53 <vincenz> CosmicRay: what happens if you close this file somewhere?
11:12:57 <Spark> im on the web :s
11:12:59 <CosmicRay> then it's closed.
11:13:03 <Spark> http://www.turbulentsoundscape.com/Rex/SC_17_12_04_3rdtry/photos/photo_78.html
11:13:04 <musasabi> the harder part is generating a shell script to do something sensible with them.
11:13:04 <vincenz> and it's still used somewhere?
11:13:05 <SyntaxNinja> musasabi: is that for compiling via c?
11:13:05 <Spark> thats me on the right
11:13:08 <vincenz> same thing with filedescr
11:13:08 <Spark> looking like a spastic imp
11:13:14 <CosmicRay> vincenz: then you get an error
11:13:17 <vincenz> right
11:13:17 <Igloo> .hc files aren't portable
11:13:21 <vincenz> same thing with filedescr I assume
11:13:30 <CosmicRay> vincenz: right, with a file_Descr.  But what about an in_channel created with in_channel_of_Descr?
11:13:31 <musasabi> SyntaxNinja: that makes ghc not delete any hc (c-source) files that it generates from haskell sources.
11:13:36 <CosmicRay> does it close just the channel or the descr too?
11:13:39 <vincenz> CosmicRay: I assume it's the ame issue
11:13:43 <shapr> Spark: are you the one in the middle?
11:13:46 <SyntaxNinja> musasabi: can you bring this up on libraries@? I can't talk here for long.
11:13:47 <Spark> nope
11:13:50 <shapr> dang
11:13:51 <CosmicRay> vincenz: but you have two different entitites.  the behavior is not documented.
11:13:57 * shapr teases Spark 
11:14:02 <shapr> hiya Darius 
11:14:05 <vincenz> no it's not
11:14:08 <Darius> heya
11:14:11 <shapr> Spark: lemme guess, you're random goth number one?
11:14:11 <CosmicRay> vincenz: anyway, you may be interested in: http://gopher.quux.org:70/devel/missinglib/html/Streamutil.html
11:14:12 <Spark> i nead hair like that
11:14:15 <Spark> yeah
11:14:16 <vincenz> I assume they'll merge that at some point
11:14:30 <CosmicRay> vincenz: I rewrote some of the standard list-manipulation code ni ocaml to work with streams
11:14:35 <shapr> vincenz: c'mon, learn Haskell... isn't that why you're on the #haskell channel?
11:14:37 <vincenz> what is this?
11:14:44 <vincenz> shapr: no it's to say 'hi' to you
11:14:44 <CosmicRay> vincenz: and you'll see somehaskell stuff ported over there too :-)
11:14:48 <shapr> oh, hi!
11:14:51 <vincenz> :)
11:14:57 <CosmicRay> vincenz: it's my ocaml utility library
11:15:09 <CosmicRay> val of_channel_lines : Pervasives.in_channel -> string Stream.t
11:15:15 <CosmicRay> that was one of my favorite functions.
11:15:21 <vincenz> euhm
11:15:25 <vincenz> that exists
11:15:26 <musasabi> SyntaxNinja: ok, I'll post there after christmas. (need to do work today and tomorrow morning we go to visit my gf's folks...)
11:15:29 <CosmicRay> does basically the same thing as hGetContents >>= lines in haskell.
11:15:38 <CosmicRay> vincenz: where?
11:15:43 <vincenz> CosmicRay: oh string Stream.t
11:15:44 <vincenz> hmm
11:15:49 <vincenz> what do you cut on?
11:15:57 <CosmicRay> vincenz: \n iirc
11:15:58 <vincenz> 'd be nice if you could specify a separator
11:16:19 <CosmicRay> vincenz: send me a patch :-)
11:16:25 <vincenz> hehe
11:16:27 <vincenz> anyways
11:16:32 <musasabi> CosmicRay: btw would it be possible for you to host things on an another port, opera does not like to open http+port 70 for some reason.
11:16:38 <vincenz> I'm working on my own pure-strict-func-lang
11:16:39 <CosmicRay> vincenz: it just uses input_line
11:16:45 <musasabi> (of course that is more of an opera issue)
11:16:50 <vincenz> musasabi: get firefox
11:16:58 <CosmicRay> musasabi: unfortunately not with my present setup
11:17:08 <CosmicRay> musasabi: try gopher://quux.org
11:17:10 <musasabi> vincenz: it eats my memory.. 
11:17:20 <CosmicRay> I have no idea if opera groks gopher though
11:17:40 <CosmicRay> vincenz: couldn't you just use haskell and "seq" :-)
11:17:47 <musasabi> it says "this address type needs a proxy server" so I don't think so.
11:17:53 <CosmicRay> foo.
11:17:54 <vincenz> vincenz: euhm?
11:17:56 <vincenz> ack
11:18:00 <vincenz> CosmicRay: euhm?
11:18:15 <CosmicRay> vincenz: seq is the haskell thing to make stuff strict
11:18:25 <vincenz> oh
11:18:27 <vincenz> well no
11:18:29 <musasabi> (I am using firefox to view missingh things - but starting it up for that is not my favorite thing)
11:18:31 <vincenz> can't do
11:18:33 <vincenz> need my own lang
11:18:49 <CosmicRay> musasabi: it sounds like opera is broken
11:18:54 <musasabi> why would you make it strict if it is pure?
11:18:59 <musasabi> yes.
11:19:00 <monk00> --  how can i trace an expression in hugs ?
11:19:00 <CosmicRay> that's a good question.
11:19:03 <SyntaxNinja> musasabi: thanks.
11:19:29 <SyntaxNinja> monk00: for debugging? it's not trivial. you might look at the "hat" debugger, but that stops working if you use a lot of extensions.
11:19:35 <SyntaxNinja> should be good for pure haskell 98 though
11:19:50 <vincenz> musasabi: because I don't want memory usage?
11:19:51 <SyntaxNinja> monk00: there's also Debug.Trace, as someone poitned out.
11:19:54 <CosmicRay> monk00: Someone just told me of Debug.Trace....
11:19:57 <CosmicRay> looks useful.
11:20:12 <monk00> ok thanx
11:20:26 <vincenz> Besides
11:20:31 <vincenz> I'm gonna build it on top of templates
11:20:34 <vincenz> (C++)
11:21:02 <CosmicRay> oh geez.
11:21:08 <CosmicRay> why do we even bother with you. :-)
11:21:17 <Maddas> Augh. :-)
11:21:18 <musasabi> vincenz: that is purely the fault of a non-optimizing compiler nothing inherent.
11:22:17 <vincenz> well I'm going to be the one optimizing the expression
11:22:53 <CosmicRay> MegaMonad: vincenz sucks because he uses the crap language C++
11:22:59 <vincenz> lol
11:23:01 <Maddas> haha
11:23:04 <vincenz> CosmicRay: not by choice
11:23:09 <musasabi> so you are saying "strict is better because I am too lazy to write a good compiler" ;)
11:23:13 <vincenz> no
11:23:18 <vincenz> I'm not saying strict is better
11:23:30 <vincenz> I'm saying strict suits my model best
11:23:55 <vincenz> and strict or non strict...
11:24:01 <vincenz> it's actually quite arbitrary in my system
11:24:09 <vincenz> the implementation will be strict
11:24:37 <vincenz> (though I might add some memoization here and there in the future)
11:24:42 <MegaMonad> CosmicRay: Which sucks.  It's been more of the crap out of he as a schema.
11:24:51 <CosmicRay> haha
11:25:15 <vincenz> ?
11:25:16 <sh10151> ok, why doesn't this version of monk's problem act as lazily as I want it to?
11:25:32 <vincenz> CosmicRay: c++ is not my choice, it's a prereq
11:26:14 <vincenz> whois CosmicRay 
11:26:34 <CosmicRay> uh oh
11:26:36 <CosmicRay> he's on to me now
11:26:42 <vincenz> Just curious where you're from
11:27:06 <CosmicRay> did the answer help? :-)
11:27:17 <CosmicRay> --- [CosmicRay] (~jgoerzen@2002:4463:7269:1:20e:a6ff:fe66:c5a3) : John Goerzen
11:29:03 <vincenz> CosmicRay: anyways, my reasons ... I'm replacing dynamic data by functors in c++, hence why I'm working on top of c++
11:29:31 <CosmicRay> that's ok, I completely understand being forced into a language by external forces
11:29:58 <vincenz> I do reserach in optimization, most mainstream multimedia software that will run on embedded systems is c (and moving to c++)
11:31:05 <vincenz> as for the language, it's basically expressions
11:31:15 <vincenz> so strict vs nonstrict doesn't make much diff
11:31:31 <vincenz> (it has a concept of lambda as well...)
11:32:17 <sh10151> isPrime x = foldl1 (&&) [x `mod` y /= 0 | y <- [2..(ceiling . sqrt . fromIntegral) x]]
11:32:38 <sh10151> i would expect that to complete very quickly on any number ending in 2, regardless of how large
11:33:18 <sh10151> but this is not the case, so I must still not understand laziness
11:36:22 <Darius> sh10151: try flip (&&)
11:36:26 * Darius wants to see something.
11:38:25 <vincenz> what is flip?
11:38:34 <Nioate> doesn't work
11:38:38 <Darius> @get-definition flip
11:38:39 <lambdabot> flip = \f x y.f y x
11:38:54 <vincenz> @get-definition Darius
11:38:55 <lambdabot> Darius not defined
11:39:11 <vincenz> CosmicRay: ping
11:39:16 <CosmicRay> I'm here
11:39:26 <vincenz> Did I already annoy you with what I achieved with c++ templates?
11:39:32 <CosmicRay> no :-)
11:39:37 <vincenz> currying of functors
11:39:42 <CosmicRay> I'm not annoyed or anything, I was just giving your trouble :-)
11:39:49 <vincenz> I know, it was a joke ;)
11:40:12 <CosmicRay> frankly I wasn't going to go there because that tought made my head spin :-)
11:40:14 <sh10151> Darius: no effect
11:40:31 * esap has done currying of natural transformations :-)
11:40:37 <Darius> sh10151: Okay,  foldr1 should work.
11:40:40 <vincenz> esap: ?
11:41:00 <esap> vincenz: Not with C++ though...
11:41:02 <vincenz> basically curried<resulttype, paramlist>(functor) creates a new functor that can be called in a curried fashion :)
11:41:04 <Darius> esap: curry does that.
11:41:22 <esap> darius: well almost.
11:41:26 * vincenz flaunts some code
11:41:31 <sh10151> foldr1 gives an incorrect answer
11:41:59 <vincenz> http://www.rafb.net/paste/results/qiflfL97.html
11:42:11 <vincenz> creator is basically a functor that acts like a factor
11:42:14 <vincenz> ...y
11:42:17 <sh10151> oops, nm bad test data :)
11:42:33 <vincenz> chainer<func1, func2> -> called and gives func1(func2(params))
11:42:45 <esap> darius: curryF :: NatTrans (P f g) h -> NatTrans f (Trans g h), where newtype NatTrans f g = NatTrans { unTrans :: forall a. f a -> g a }
11:42:45 <sh10151> I still just cannot figure out when to foldl and when to foldr
11:42:49 <vincenz> I especially like
11:42:51 <vincenz> typedef Chainer<Saver, Maker> Spawner
11:42:55 <esap> darius: P f g is product of two functors.
11:43:15 <vincenz> esap: like Chainer
11:43:23 <esap> vincenz: Chainer?
11:43:26 <vincenz> check the link
11:43:30 <Nioate> sh10151: foldr is lazy and foldl is not
11:43:32 <vincenz> my functor lib in c++
11:43:45 <vincenz> CosmicRay: whatcha think?
11:44:20 <CosmicRay> vincenz: on the phone, hang on...
11:44:29 <vincenz> np
11:44:30 <arauko> That is why foldr can be used in infinite lists.
11:44:40 <arauko> Because of its laziness.
11:45:50 <esap> darius: The problematic part is defining the product of two functors.
11:45:59 <vincenz> esap: not really
11:46:35 <esap> vincenz: hmm.. why?
11:46:36 <Darius> arauko, Nioate, sh10151: The real deciding factor (when one has a choice) is whether the folded function is lazy or not.  If it's lazy then foldr is tail-recursive and can handle infinite lists, otherwise foldl/foldl' is tail-recursive.
11:47:05 <vincenz> esap: return a new trans that when called(?) calls both given trans
11:47:48 <esap> vincenz: The problem is it's not clear whether P f g a should have two copies of 'a' or not.
11:48:15 <vincenz> o.O
11:48:15 <vincenz> ?
11:48:27 <vincenz> I have no idea what you're talking about
11:48:44 <esap> vincenz: data P f g a = P { unP :: (f a, g a) } or something that doesn't mention 'a' twice.
11:48:54 <vincenz> oh duh
11:48:55 <vincenz> product
11:48:57 <vincenz> I was thinking
11:49:00 <vincenz> F o G
11:49:09 <esap> vincenz: F o G is easy.
11:49:12 <vincenz> right
11:49:18 <vincenz> but product of functions ...
11:49:23 <vincenz> one thinks of F o G
11:49:23 <Darius> esap: And what would something that doesn't mention 'a' twice look like?
11:49:59 <vincenz> I don't get tho............
11:50:08 <esap> darius: I'm not sure. Something along the lines of: data P f g a = P { unP :: (a -> f a, a -> g a, a) } But details are not clear to me.
11:50:19 <vincenz> _P_ f g a = _P_ (unP :: (f a, g a)}
11:50:22 <vincenz> you're applying P twice
11:50:32 <vincenz> or are these rewrite rules?
11:50:50 <esap> darius: The correct categorical notion would be pullback.
11:50:55 <vincenz> and what is unP:: ?
11:51:08 <Darius> esap: Well since the unit of products is a -> (a,a), I'd imagine duplication of the value is fairly fundamental to it.
11:51:33 <vincenz> what syntax/lang is this?
11:51:50 <esap> darius: Yes, true. But the question is whether to duplicate both the abstract and the concrete part of the type, or just the concrete part.
11:51:56 <Darius> pair unit <=> dup terminal object unit <=> kill
11:52:09 * vincenz shrugs
11:52:23 <sh10151> Darius: thanks, I think that helps a lot
11:52:29 <esap> darius: in 'forall a. f a -> g a', 'a' is the abstract part.
11:52:29 <sh10151> we'll see, the next time it comes up
11:54:06 <vincenz> What are natural transformations?
11:54:16 <esap> darius: I think you can do the sharing, assuming you can figure out some method of distinguishing the abstract part from the concrete, then copying the concrete part need not copy the abstract part.
11:54:40 <esap> darius: Instead, it's a common shared part.
11:55:25 <vincenz> esap, Darius ?
11:56:21 <esap> vincenz: my code, newtype NatTrans f g = NatTrans (forall a. f a -> g a) + a rule for connecting the versions with different choices of 'a' will give you a natural transformation.
11:56:52 <Darius> vincenz: One way of thinking of them is that they are what you get when you think of polymorphic functions in a category.
11:57:03 <esap> vincenz: basically, a natural transformation alfa : F -> G takes a type A and produces alfa_A : f a -> g a.
11:58:07 <esap> vincenz: Such that alfa_a . fmap f == fmap f . alfa_b
11:59:35 <esap> vincenz: Basically, a function whose input and output both have transparent fields that the function doesn't change and passes it through.
12:01:46 <esap> vincenz: For formal details, see http://en.wikipedia.org/wiki/Natural_transformation
12:03:18 <vincenz> oh
12:03:21 * vincenz was afk
12:03:24 <Darius> esap: For a category in general, it can fiddle with it all it wants, just not in any "unnatural" way or not in any way that shows.
12:04:28 <esap> darius: hmm.. I thought applying one of the functors would do the changing of the transparent field; the component of the natural transformation wouldn't do that.
12:05:25 <vincenz> ohoh
12:05:33 <Darius> esap: The objects in the target category may be equipped with structure that lets you manipulate them, it also may not have enough arrows to distinguish some changes.
12:05:51 * vincenz will have to read the book he read "Basic Category Theory for Computer Scientists" by Benjamin C. Pierce, it appears to contain it
12:06:23 <Darius> vincenz: Any book on Category Theory that didn't talk about natural transformations would be trash.
12:06:30 <esap> darius: ok, I guess type classes can be used to specify that structure. newtype NatTrans f g = NatTrans (forall a. (Num a) => f a -> g a) would be an example.
12:06:40 <vincenz> Darius: I never read any such books
12:07:24 <Darius> esap: Yes, the (semi-)example I was thinking of was a category of ordered sets which would be like having an Ord qualifier.
12:07:52 <vincenz> what is a category?
12:08:08 <vincenz> I mean what is a category that a set is not?
12:08:40 <esap> vincenz: Read 'categorical primer'. In short, category can have arrows between the objects (~sets).
12:08:57 <vincenz> oki
12:09:25 <esap> vincenz: primer is at http://citeseer.ist.psu.edu/487012.html
12:09:34 <vincenz> thank you
12:10:07 <vincenz> hmm
12:10:10 <vincenz> to be very crude
12:10:13 <vincenz> sets of tuples
12:10:30 <vincenz> (any relationship can be seen as a set of tuples)
12:10:59 <esap> vincenz: There are categories where that is a valid approach, but not all of them can do that.
12:11:09 * vincenz is turning into a nerd "Imagine reading this in your free time even though you don't quite need it "
12:11:25 <vincenz> esap: but it's an evolution on top of set-logic?
12:11:38 <vincenz> just like domains are built on top of sets (And you know that they are constructive, unlike all sets)
12:11:54 <esap> vincenz: No, set theory can be described in category theory, and it's somewhat simpler than traditional approaches.
12:12:06 <vincenz> oh
12:15:32 <esap> vincenz: My favourite is the axiom of choice, which can be described as just "every epimorphism has a section", which is fairly good.
12:16:21 <vincenz> ?
12:16:38 * vincenz is not a CS person
12:16:41 <vincenz> I need to learn all of this
12:16:52 <vincenz> well ... need...
12:16:54 * vincenz coughs
12:18:45 <ihb> vincenz: so, there's no type classes in ocaml?
12:19:12 <vincenz> no
12:19:56 <ihb> vincenz: as a functional language, which do you prefer?
12:22:00 <monk0000> what this error means :
12:22:01 <monk0000> ERROR - Unresolved overloading
12:22:02 <monk0000> *** Type       : (Integral a, Fractional a) => (a,a)
12:22:02 <monk0000> *** Expression : goldbach 8 
12:22:18 <Marvin--> monk0000: maybe you should start using binary numbers instead of unary in your nicks ;)
12:22:37 <wolfman8k> is there like a modulu function for Double values?
12:22:49 <monk0000> Marvin-- :)
12:23:11 <Marvin--> monk0000: you need to be more specific about what type of numbers you use
12:23:31 <shapr> d00d, that's so c00l
12:23:36 <monk0000> only integers
12:23:46 <Marvin--> monk0000: are you using / ?
12:24:08 <monk0000> yes, i thought / is integer division
12:24:09 <Marvin--> shapr: d00d
12:24:17 <Marvin--> monk0000: nope, use `div` instead
12:24:36 <monk0000> i see, i ll try it
12:24:42 <shapr> h3j, v"d h"nd3r?
12:24:43 <Marvin--> / is in the Fractional type class
12:25:32 <Marvin--> shapr: I'm contemplating applying for a PhD student position in Utrecht
12:25:58 <monk0000> ok, that was the error
12:26:11 <shapr> Marvin--: cool, go for it.
12:26:38 <monk0000> i have a book written by my uni professor full of mistakes...
12:26:48 <wolfman8k> 7.5 `f` 2 = 1.5
12:26:54 <wolfman8k> which function can do that operation?
12:27:05 <Marvin--> wolfman8k: f 7.5 2 = 1.5 ?
12:27:17 <wolfman8k> Marvin--: yeah, does haskell have a builtin function for doing that?
12:27:19 <Marvin--> ask a silly question...
12:27:51 <Marvin--> wolfman8k: I really have no idea what it is you want
12:28:11 <wolfman8k> f!
12:28:13 <vincenz> ihb: I do not know haskell
12:28:36 <monk0000> wolfman8k : thats the remainder of the division
12:28:40 <wolfman8k> monk0000: yeah
12:29:02 <wolfman8k> monk0000: which haskell function does this?
12:29:21 <Marvin--> rem, but it's only defined for integral types
12:29:27 <monk0000> i used `mod` for integers , dont know if it works for floats
12:30:01 <wolfman8k> hm.. what's the difference between rem and mod?
12:30:22 <monk0000> think its the same
12:30:33 <wolfman8k> ok... but is there a function that works with Double?
12:30:39 <Darius> rem is faster but less correct (it's the same difference between quot and div)
12:32:04 <jadrian> are you sure?
12:32:17 <jadrian> I think the difference between both is the way they work for negative numbers
12:33:16 <Darius> jadrian: Yes.  quot/rem/quotRem don't do the "right" thing with them but are faster because of it.
12:33:49 <jadrian> Darius: is there such a thing as a right thing?
12:34:06 <jadrian> Darius: I think it just depends on your definitions
12:34:43 <wolfman8k> so there's no function that works with Double values?
12:35:21 <jadrian> Darius: in fact the speed should be the same, one of them just performs one more iteration
12:35:26 <musasabi> wolfman8k: mod is only defined for integers normally in math too.
12:35:47 <jadrian> wolfman8k: how should it be defined for Doubles?
12:35:51 <wolfman8k> hm.... mod is implemented as a loop?
12:36:05 <wolfman8k> why not use the cpu instruction?
12:36:29 <jadrian> I have no idea how ghc implements it
12:36:37 <jadrian> I was talking about specification
12:36:39 <Darius> wolfman8k: It presumably does (when possible), but divMod needs to do a sign check first to get the right answer.
12:37:32 <wolfman8k> ok i will implement the function myself thansk guys
12:37:46 <jadrian> wolfman8k: could you give a specification of the function?
12:37:50 <wolfman8k> i shall
12:37:52 <wolfman8k> ...
12:38:35 <jadrian> I still didn't understand what you want exactly...
12:38:42 <wolfman8k> f x y = x - ((x / y) * (floor (x / y)))
12:38:49 <wolfman8k> i think that's it
12:39:14 <wolfman8k> wait no
12:39:22 <jadrian> thought not :)
12:39:34 <wolfman8k> f x y = x - (x * (floor (x / y)))
12:39:43 <wolfman8k> wait
12:40:08 <wolfman8k> f x y = x - (y * (floor (x / y)))
12:40:17 <wolfman8k> ok i think that's it
12:44:57 <Darius> A discussion of different divs and mods is here: http://www.cs.uu.nl/~daan/download/papers/divmodnote.pdf
12:56:01 <wolfman8k> does floor not work with Double values?
12:58:55 <Darius> @type floor
12:58:57 <lambdabot> floor :: forall a b. (RealFrac a, Integral b) => a -> b
12:59:17 <Darius> @type floor (1.5 :: Double)
12:59:19 <lambdabot> floor (1.5 :: Double) :: forall b. (Integral b) => b
12:59:48 <wolfman8k> aha! how to convert from something to Double?
13:00:31 <Darius> what's "something"?
13:01:25 <wolfman8k> whatever floor returns :)
13:03:01 * CosmicRay hates reading ancient RFCs
13:03:26 <CosmicRay> especially the ftp rfc, since it deals a lot with OSs that have a record filesystem, which are pretty much obsolete today
13:03:59 <wolfman8k> CosmicRay: in that case check this out: http://muflon.linux.pl/~falcon/falcon_project.pdf
13:04:04 <musasabi> and no-one implements the RFC ;)
13:04:12 <CosmicRay> right
13:04:16 <CosmicRay> or at least not all of it
13:04:25 <CosmicRay> it's not even possible to implement all of it on modern systems
13:04:35 <CosmicRay> (or at least, not useful)
13:04:56 <CosmicRay> plus there are about half a dozen rfcs that update it, not all of which are properly indexed that way.
13:05:03 <CosmicRay> plus standard, but non-RFC, extensions.
13:05:15 <musasabi> e.g. having a data connection between two hosts and a different host for control is frowned upon.
13:05:24 <CosmicRay> right
13:05:32 <CosmicRay> though I did recently have to make use of the ebcdic options.
13:05:38 <CosmicRay> for getting data from an as/400.
13:06:04 <CosmicRay> wolfman8k: hahaha
13:06:13 <CosmicRay> I have seen this before, but it's great :-)
13:06:18 <Darius> wolfman8k: fromIntegral
13:06:26 <wolfman8k> Darius: thanks will try
13:06:37 <wolfman8k> CosmicRay: you've seen it before???? it's some dudes english project that he just wrote
13:06:54 <wolfman8k> CosmicRay: the teacher said that it had to be a paper dealing with computer science :D
13:07:08 <CosmicRay> wolfman8k: dude, it's RFC2549!\
13:07:13 <CosmicRay> or RFC1149
13:07:39 <wolfman8k> CosmicRay: hm.... you are sure there is no date somewhere?
13:07:47 <CosmicRay> his is yet another informal expansion :-)
13:07:54 <CosmicRay> April 1, 1990 and April 1, 1999
13:08:09 <CosmicRay> but I do like the maps in this one
13:08:09 <wolfman8k> he plagarized it for his homework assignment?!?? :O
13:08:15 <CosmicRay> that adds an extra dmiension
13:08:24 <CosmicRay> wolfman8k: well, let's say he embraced and extended :-)
13:08:40 <wolfman8k> let's just hope that teacher doesn't find out :\
13:12:37 <CosmicRay> I think he can get away with it because he cites his sources
13:12:55 <CosmicRay> he's saying that he saw it in the RFCs so it's probably kosher
13:13:07 <CosmicRay> so no, I hadn't seen this particular paper before, but I had seen the RFCs :-)
13:19:16 <shapr> I like haskell-mode 2.0
13:19:21 <shapr> it's not yi, but it's better than haskell-mode 1.x
13:19:35 <andersca> what is yi?
13:20:11 <musasabi> 2.0 seems to lack C-c-C-w (inserting where)
13:20:44 <pesco> 'lo.
13:21:33 <shapr> hiya pesco 
13:21:41 <pesco> Hey shapr.
13:21:45 <shapr> musasabi: works for me
13:21:52 <shapr> andersca: yi is an editor written in Haskell
13:21:53 <Marvin--> meh, I should be using a FOL prover or SAT solver to do this, not quickcheck
13:21:56 * Marvin-- grumbles
13:22:08 <shapr> Marvin--: heeyyy have you seen QC 2?
13:22:32 <shapr> I really want a copy of QC2, I wanna see if Koen picked up my test-first code or not.
13:22:55 <Marvin--> no, I haven't seen Koen for some time now
13:23:03 <pesco> shapr, would you like to certify me on advogato?
13:23:19 <Marvin--> well, actually that's a lie since I saw him at a presentation a few weeks ago, but I didn't have time to talk to him
13:23:27 <shapr> pesco: if I can remember my password, sure... haven't logged in since...  um ... when did advogato startup?
13:23:44 <pesco> start up? I don't know. I just recently registered.
13:24:19 <pesco> I'd noticed some cool people are on it, found the certification thing cool, and wanted to pick my name.
13:25:05 <vincenz> what is advogato?
13:25:07 <vincenz> CosmicRay: checked the link yet?
13:25:10 <pesco> Unfortunately I promptly forgot my password. Forunately I also forgot to log out. The cookie expires in a year. :-o
13:25:44 <shapr> hah
13:25:52 * jadrian is progarmming a FOL prover
13:26:09 <wolfman8k> shapr: i think i finally figured out how to properly indent using emacs
13:26:11 <pesco> vincenz: It's a software developers' community site where everyone can certify others on a kind of socio-technological ranking.
13:26:15 <vincenz> kewl
13:26:41 <shapr> wolfman8k: spiffy
13:26:46 <wolfman8k> indeed
13:27:10 <wolfman8k> shapr: and i got a gradient shader working!
13:27:11 <wolfman8k> modd :: Double -> Double -> Double
13:27:12 <wolfman8k> modd m n = m - (n * (fromIntegral (floor (m / n))))
13:27:12 <wolfman8k>    
13:27:15 <wolfman8k> oops
13:27:24 <pesco> vincenz: The system runs a network flow algo on the resulting certification graph and assigns you a trust level.
13:27:49 <pesco> Or "trusted level", more accurately.
13:28:20 <wolfman8k> here we go: http://img133.exs.cx/img133/5049/haskellraytrace106ce.png
13:28:54 <shapr> wow, nice
13:29:03 <vincenz> fuzzy
13:29:05 <vincenz> :)
13:29:12 <shapr> pesco: is there somewhere you can look at your own weighted value?
13:29:23 <vincenz> can someone rate me?
13:29:25 <vincenz> anyways
13:29:27 <vincenz> I gotta go
13:29:36 <vincenz> or I'll miss my bus home
13:29:40 <vincenz> later!
13:30:13 <pesco> shapr: Well, it shows your level at the top of your personal page. Sadly, you don't get to look at the details, i.e. how much trust "current" is currently "flowing" through you etc.
13:30:38 <pesco> And your distance to the nearest seed node would be interesting, too.
13:30:59 <shapr> too bad
13:31:30 <pesco> The seeds are raph and some others, in case you don't know. The whole thing basically says "Raph and friends believe you to be at soandso level".
13:31:45 <shapr> would be more fun if you could choose your own seed
13:31:47 <basti_> they put the plug on my OJ tetrapak the wrong way around
13:31:51 <pesco> shapr: Exactly.
13:32:06 <pesco> basti: You mean inside-out?! *g*
13:32:13 <basti_> no like, backwards
13:32:22 <basti_> like it would pour to the center of the pack
13:32:26 <basti_> and not to the edge
13:32:42 <pesco> haha.
13:32:56 <basti_> ?
13:32:58 <basti_> :)
13:33:20 * basti_ arghs tetra pak manufacturers
13:33:45 * pesco stares at wolfman8k's raytrace image.
13:34:00 * pesco stares harder.
13:34:02 <basti_> its nice, really.
13:34:07 <pesco> It's moving!!
13:34:10 <wolfman8k> whoah, this new shader totally rocks! ...
13:34:26 <basti_> very natural
13:34:28 <basti_> (fuzzy ;)
13:34:55 <wolfman8k> http://img63.exs.cx/img63/562/haskellraytrace117rb.png
13:35:04 <pesco> Coo!
13:35:31 <basti_> hmmmh ;)
13:35:34 <basti_> that rocks? ;)
13:35:44 <basti_> i would prefer something realistic :P
13:36:05 <wolfman8k> basti_: did you see the images on my site? http://benny.kramekweb.com/hrayt
13:36:06 <pesco> http://www.haquebright.de/Lucifer/screens/2002-08-27_Shell_perturbed.png
13:36:18 <wolfman8k> pesco: cool! what's that?
13:36:31 <basti_> mhhh hallucinogenic :)
13:36:37 <basti_> the sierpinksy rocks.
13:36:52 <wolfman8k> i'm gonna try to do perlin noise now
13:37:10 <basti_> is the sierpinksy algorithmic or an imported image?
13:37:29 <pesco> wolfman8k: It's a light volume in the shape of a thin sphere, it's surface perturbed be some sin/cos function of the coordinates.
13:37:44 <wolfman8k> hm...
13:37:54 <wolfman8k> what do you mean by "thin sphere"?
13:38:17 <pesco> The light volume has zero density except on the unit sphere.
13:38:32 <pesco> And a thin area around it where it falls off.
13:39:05 <pesco> The program traces a ray through the volume, summing the sampled the density values.
13:39:20 <wolfman8k> is this program written in haskell? :)
13:39:24 <pesco> Yes.
13:39:27 <wolfman8k> cool =D
13:39:32 <basti_> youre mad. all of you.
13:39:35 <pesco> Yes. :-P
13:39:35 <basti_> but mad in a good way.
13:40:13 <wolfman8k> i wanna do bump mapping but i can't figure out how
13:40:26 <basti_> you would transform the ray reflected
13:40:38 <basti_> its direction
13:40:45 <pesco> wolfman8k: There must be tons of docs on it.
13:40:56 <basti_> according to the gradient in the bumpmap
13:41:05 <wolfman8k> there are, but they all deal with textures, not procedurally generated height values
13:41:07 <shapr> hei Defty 
13:41:18 <pesco> wolfman8k: Bah. ;)
13:41:20 <shapr> hoi goron
13:41:35 <basti_> how you generate the height values is not important i'd say
13:41:41 <shapr> man, I've totally forgotten how to use HaskellDB. This sucks.
13:41:59 <basti_> you could generate the angles themselves by procedures
13:42:10 <basti_> you could make fresnel lenses easily this way :P
13:42:21 <shapr> Lemmih: you around?
13:43:47 <wolfman8k> if have (sqrt 2) in my program, will ghc be smart enough to evaluate it at compile time?
13:44:45 <pesco> shapr: Thanks for the cert.
13:44:50 <Darius> Probably not, it's usually not good for the compiler to mess with floating point.
13:45:29 <shapr> pesco: sure
13:46:52 * jadrian is so confused :-|
13:46:57 <jadrian> any logicians in here?
13:48:21 <SyntaxNinja> MegaMonad plays one on TV... isn't that right?
13:48:33 <SyntaxNinja> hmm
13:48:40 <Lemmih> shapr: Yes.
13:49:16 <jadrian> MegaMonad: do you know the G deduction system?
13:49:21 <MegaMonad> jadrian: Nope, but it just me, but the c code? Or do you pass in the computer system will be badly beaten by something that's gpl, than the logic from constructive logic with natural deduction.
13:50:01 <aFlag> hi, where can i find more information about typeclasses defined such as class Fst a b | a->b where fst :: a -> b;
13:50:11 <jadrian> ghc user guide
13:50:19 <aFlag> ok, thanks
13:50:40 <jadrian> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#FUNCTIONAL-DEPENDENCIES
13:51:47 <musasabi> fundeps are very nice.
13:52:42 <pesco> woohoo fundeps
13:52:51 <pesco> "Fundeps ROCK!"
13:52:56 <pesco> I'm sorry, I'm in craze mode.
13:52:58 <aFlag> There should be more documentation, but there isn't (yet). Yell if you need it.
13:52:59 <aFlag> hehe
13:53:32 <musasabi> "class Foo a b | a -> b where foo :: a -> b" means that the type a determines a single b.
13:53:41 <jadrian> btw, by that I think he means something like asking on the mailing
13:53:54 <jadrian> just yelling in front of your computer will not acomplish much
13:53:56 <jadrian> I think
13:54:11 <Cale> You never know
13:54:13 <Cale> :)
13:54:30 <musasabi> aFlag: here is a concrete example from my code:
13:54:36 <jadrian> well if SPJ is his neighbour it might work ...
13:54:41 <jadrian> :)
13:54:50 <musasabi> class Value a b where value :: a -> IO b
13:54:56 <wolfman8k> does haskell have bit operations?
13:55:11 <pesco> wolfman8k: Yes. import Data.Bits.
13:55:14 <musasabi> instance Value MyObj Int where value = someFun
13:55:15 <wolfman8k> pesco: cool thanks
13:55:20 <wolfman8k> @info Data.Bits
13:55:24 <wolfman8k> @type Data.Bits
13:55:25 <lambdabot> bzzt
13:55:38 <musasabi> instance Value OtherObj Float where value = otherFun
13:56:17 <aFlag> hum... that i know the  | a -> b is what i don't know about
13:56:41 <Cale> aFlag: it's a hint to the type inference process
13:56:42 <goron> shapr: Oh.. hi :)
13:57:11 <aFlag> yeah, i've read it's supposed to resolve some ambiguity
13:57:21 <aFlag> but i wish i could see actuall code implementing it
13:57:30 <Cale> aFlag: it means that if it comes across something of type Foo a b, and it knows what a is, then there's only one possible b, so it just has to find one
13:58:21 <pesco> I'm off. Byebye!
13:58:39 <musasabi> aFlag: that means that the compiler can infer the type of b from the type of a.
13:59:10 <Cale> For instance, you might have
13:59:20 <aFlag> but you have to define how it does it, don't you?
13:59:27 <Cale> class VectorSpace f v | v -> f
13:59:53 <Cale> where if you know the type of the vectors, then you know the type of the corresponding scalars
14:00:56 <Cale> (to give a very math-oriented example)
14:01:22 <goron> Cale: Math spam ;)
14:01:49 <Cale> So for instance that class might declare a function  scalarMultiply :: f -> v -> v
14:02:11 <Cale> and you wouldn't have to worry about ambiguities in using this
14:02:43 <aFlag> why so?
14:03:01 <aFlag> how would it be abiguous
14:03:50 <musasabi> aFlag: some real code using it (not math) - http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/src/FLTK/Widget.hs
14:04:58 <musasabi> (say if it didn
14:05:06 <musasabi> (say if it didn't work I am on a text terminal)
14:05:14 <musasabi> so nothing really works.
14:06:52 <aFlag> there's class Value_FC c v | c -> v where value :: Attr c v but it doesn't seem to be used anywhere in the code
14:09:08 <wolfman8k> sweet, a 1D noise shader!
14:09:09 <wolfman8k> http://img140.exs.cx/img140/8339/haskellraytrace129gc.png
14:11:09 <wolfman8k> oh shit, that has negative color... now wonder it looks weird
14:11:35 <Lemmih> shapr: ping.
14:13:08 <jadrian> hello Pseudonym 
14:13:24 <wolfman8k> here we go, http://img137.exs.cx/img137/2624/haskellraytrace120xd.png
14:15:50 <Pseudonym> G"day.
14:16:32 <Pseudonym> Interesting.
14:16:54 <wolfman8k> Pseudonym: check this one out, http://img63.exs.cx/img63/562/haskellraytrace117rb.png
14:17:22 <musasabi> aFlag: that defines a an attribute named value.
14:18:06 <jadrian> yeap pretty cool
14:18:12 <musasabi> aFlag: now different inputs might define e.g. instance Value_FC FloatInput Float where value = Attr foo bar
14:18:21 <Pseudonym> Ooh, nice/.
14:18:50 <musasabi> aFlag: now if you have code using FloatInputs they can use the value accessor and the type system infers that it has the type Float.
14:19:09 <musasabi> aFlag: without functional dependency it couldn't infer that.
14:19:11 <psi> wolfman8k: it looks like the red one is moving :)
14:20:53 <wolfman8k> check this one out...
14:21:49 <wolfman8k> http://img147.exs.cx/img147/5681/haskellraytrace134tc.png
14:23:36 <CosmicRay> WOOHOO!
14:23:47 * CosmicRay has successfully downloaded a file from his Haskell FTP server.
14:24:25 <musasabi> CosmicRay: congrats.
14:24:34 <CosmicRay> thanks :-)
14:25:04 <Pseudonym> http://andrew.bromage.org/screen.png
14:25:09 <Pseudonym> Had to upload it.
14:25:40 <Pseudonym> Oh, hang on.  Web server broken.
14:26:35 <Pseudonym> Nope, it was my client that was the problem.
14:27:02 <wolfman8k> CosmicRay: mazel tov
14:27:07 <wolfman8k> Pseudonym: nice... but what is it?
14:27:16 <CosmicRay> wolfman8k: ?
14:27:29 <wolfman8k> ftp server
14:27:36 <Pseudonym> It's a teapot.
14:27:40 <wolfman8k> and..... yes! 3d noise works: http://img157.exs.cx/img157/6520/haskellraytrace145cf.png
14:27:49 <Pseudonym> It just reminded me of your red screen thing.
14:28:29 <wolfman8k> is that teapot image created from a haskell program? :)
14:28:38 <Pseudonym> No, but I did write the renderer.
14:28:50 <wolfman8k> what language?
14:28:53 <Pseudonym> C++
14:29:38 <wolfman8k> nice
14:29:45 <wolfman8k> hm... my 3d noise function is actually not random enough
14:31:15 <arjanb> why do you use only one frequence for the noise?
14:33:16 <wolfman8k> here we go: http://img133.exs.cx/img133/1562/haskellraytrace140mp.png
14:34:29 <shapr> Lemmih: hiya
14:34:57 <Lemmih> shapr: Yo.
14:35:42 <shapr> what's wrong with this --> "restrict (t!author `like` constJust "%ozone%")"
14:36:13 <shapr> if I change constJust to constant, it complains it wants a Maybe type, but then it complains it doesn't want a Maybe type
14:36:16 <shapr> any clues?
14:36:42 <Riastradh> Tell it to be more decisive.  'Maybe' is not good enough.
14:37:10 <Lemmih> shapr: What's the type of 'author'?
14:38:16 <shapr> Expr (Maybe String)
14:38:31 <shapr> author :: Attr Author (Maybe String)
14:40:50 <Lemmih> Weird.
14:41:10 <shapr> am I doing something obviously weird?
14:41:21 <wolfman8k> here's a crude attempt at shader composition: http://img66.exs.cx/img66/3298/haskellraytrace153qb.png
14:41:34 <SyntaxNinja> shapr: need you ask? ;)
14:41:52 <Lemmih> shapr: I've never use nullable fields before..
14:42:14 <shapr> oh
14:42:21 <shapr> y0 SyntaxNinja 
14:42:21 <Lemmih> shapr: Oh. 'like' doesn't support those.
14:43:17 <shapr> doesn't support those what?
14:43:20 <shapr> nullables?
14:43:31 <Lemmih> shapr: Yes.
14:43:37 <shapr> um, that sucks.
14:43:54 <Lemmih> You can use 'fromNull' perhaps.
14:44:09 <SyntaxNinja> shapr: how's hack?
14:44:13 <shapr> slow
14:44:17 <shapr> how's code for you?
14:44:43 <SyntaxNinja> not bad. a little chaotic
14:45:52 * musasabi goes to bed slowly. Merry christmas to those who feel like celebrating it. Back on 26-27.12.
14:46:01 <shapr> merrry xmas musasabi 
14:46:05 <Lemmih> Bye musasabi.
14:47:07 * Lemmih is off to get a christmas beer.
14:47:22 <wolfman8k> and remember, no gifts this year! it's the popes order!
14:48:18 <Darius> meh
14:48:29 * Darius lives in America where Christmas is the celebration of Capitalism.
14:48:46 * shapr grumbles and adds NOT NULL to every field
14:48:47 <wolfman8k> yeah... i was there in november... you guys are fucked up
14:48:56 <wolfman8k> in a good way though :)
14:51:41 <SyntaxNinja> wolfman8k: that's what my life-skills teacher would have called a "Hasty Generalization"
14:52:08 <Darius> SyntaxNinja: Just because it's hasty doesn't mean it's wrong.
14:52:36 <SyntaxNinja> generalizations are usually wrong :)
14:52:42 * shapr snickers
14:53:21 * Riastradh feels obliged to play Tom Lehrer's Christmas carol at this moment.
14:53:30 <Leimy> hmmm darcs linux mirror == good times :)
14:54:11 * Leimy is compelled to sing the Chimney Sweep song thing from Merry Poppins
14:55:19 <shapr> A sweep is as lucky as lucky can be...
14:55:20 * Pseudonym laughs
14:55:35 <shapr> chim chiminy chim chiminy chim chim cheroo...
14:55:46 <Pseudonym> I also am reminded of the Stan Freberg sketch.
14:56:11 <Pseudonym> o/~ Deck the halls with advertising / fa la la la la... la la la la... / 'Tis the time for merchandising... o/~
14:56:49 <wolfman8k> alright.. here's the correct way for shader composition: http://img157.exs.cx/img157/8803/haskellraytrace162ub.png
14:57:19 <Pseudonym> Can I ask what the discontinuity is?
14:57:28 <Pseudonym> The "circle" discontinuity.
14:57:30 <Pseudonym> Is that deliberate?
14:58:28 <wolfman8k> well, it's a grid of cubes
14:58:46 <Pseudonym> Ah, it's a 3D texture.
14:58:48 <Pseudonym> That makes sense.
14:58:49 <wolfman8k> so the "rings" are where the gridplane intersects with the sphere
14:59:02 <Pseudonym> I was thinking it was a 2D texture.
15:00:37 <wolfman8k> it would be really sweet if i could make some sort of editor that would let you code shaders and compose shaders and view the result in realtime
15:01:03 <Darius> hs-plugins and call it a day
15:03:57 <wolfman8k> ok i just thought of a really sweet shader but i don't know how to implement it
15:04:23 <wolfman8k> there's the 3d volume...
15:04:37 <wolfman8k> and you basicly fill it up with a shitload of spheres, each sphere has a color
15:04:54 <wolfman8k> the spheres are placed in random locations with random radiuses
15:05:25 <wolfman8k> then to evaluate the color of x,y,z you go through the list of all of the spheres, and the first sphere that contains that point within it's volume is the result
15:05:32 <wolfman8k> that is, the result is the color of that sphere
15:06:16 <wolfman8k> does this make any sense?
15:06:56 <Darius> Presumably it's what you'd get if you carved the shape out of a pile of spheres.
15:07:15 <Pseudonym> I implemented one similar to that for RenderMan some time ago.
15:07:28 <Pseudonym> You have a bunch of vectors, and see which one the normal is closest to.
15:07:48 <wolfman8k> well, i think that if you apply this shader to a sphere then you will end up having it look like it has a bunch of circular stickers glued onto it
15:09:07 <Calister> good evening
15:09:11 <basti_> Calister!
15:09:23 <wolfman8k> what i'd *really* like to get working though is volumetric lighting, but i have no idea how
15:09:40 * Calister waves at basti_
15:09:43 <jadrian> MegaMonad: I'm feeling more confused than you usually appear to be...
15:09:43 <Calister> i swear
15:09:48 <Calister> this exam SUCKED
15:09:48 <MegaMonad> jadrian: I appear to use names defined in go, they are confused.
15:10:13 <wolfman8k> sucked eggs, or sucked the saussage?
15:10:14 <Calister> quite many ppl got from 100 possible points: 0!
15:10:26 <basti_> wow
15:10:42 <Calister> even many who had that class before
15:10:45 <basti_> and you?
15:10:51 <Calister> i got 48.5
15:10:59 <Calister> which is astonishing
15:11:08 <basti_> so you passed?
15:11:18 <Calister> since i just did questions worth 50/55 points
15:11:18 <basti_> or did they do the 50% nazi thing
15:11:32 <Calister> welp.. if i get 51.5 points in next exam: yes
15:11:39 <Calister> ^_^
15:11:40 <basti_> oh.
15:11:41 <basti_> ;)
15:11:47 <Calister> they take both exams together
15:11:49 <Calister> so phew
15:11:57 <Maddas> In that case, quite a few people will need a good score next time :-)
15:12:00 <Calister> i bet the class will be hella empty now
15:12:01 <Calister> ;x
15:12:05 <Calister> lol
15:12:06 <Calister> indeed
15:12:38 <Calister> there are for sure some ppl who wanna play punch-the-prof
15:13:04 <basti_> put his image on some figure in a 3d shooter
15:13:15 <Calister> lol
15:13:23 <Pseudonym> I have my copy of "Realistic Image Systhesis Using Photon Mapping" here.  Pity I can't fax it to you.
15:13:24 <Maddas> Shouldn't the class be very full now that many people need very good scores?
15:13:28 <basti_> gestalt therapy
15:13:30 <Pseudonym> All about volumetric lighting.
15:13:31 <Calister> then i know which game would be running on all the comps
15:13:40 <Calister> Maddas: most will give up
15:13:49 <Calister> you havent seen his exam
15:13:52 <Maddas> I guess I can understand that. Sucks, though :-(
15:13:57 <Calister> its impossible to score 100
15:14:01 <jadrian> Calister: well non-realistic tasks is something everyone experiences in college...
15:14:12 * Calister nods
15:14:15 <jadrian> Calister: I could tell many stories...
15:14:17 <Calister> its quite sad tho
15:14:21 <jadrian> way to many lol
15:14:29 <Calister> you still studying or done?
15:14:37 <jadrian> kind of done
15:14:42 <jadrian> graduated
15:14:48 <jadrian> finishing MSc
15:15:09 <Calister> MSc?
15:15:13 <jadrian> Master
15:15:16 <Calister> oha
15:15:18 <Calister> nice
15:15:19 <Calister> ^_^
15:15:43 <Calister> im going for diploma... so those shortnings are greek to me
15:15:51 <Calister> sure
15:15:57 <Calister> thats a timing
15:16:06 <Calister> i say greek and someone from greece shows up
15:16:09 <Calister> ;p
15:16:10 <monk0> :)
15:16:13 <basti_> :)
15:16:13 <Calister> heya
15:16:18 <basti_>  <
15:16:19 <basti_> :)
15:16:20 <monk0> hello
15:16:39 <Calister> humm
15:16:53 <Calister> too bad i dun have a lambda on keyboard
15:16:55 <Calister> ^_^
15:17:18 <basti_> we could to the haskell lambda \
15:17:24 <Calister> indeed
15:17:58 <Calister> ^_^
15:18:00 <Calister> awful
15:18:15 <Calister> its christmas break and i am talking bout haskell
15:18:30 <wolfman8k> speaking of haskell
15:18:38 <wolfman8k> nm
15:18:52 <arauko> my christmas present was a Haskell book.
15:18:59 <wolfman8k> which one?
15:19:26 <arauko> Introduction to Fuctional Programming with Haskell - Pretince Hall 2 edition
15:19:30 <Calister> lol
15:20:13 <Calister> i hope ima get the "programming challenges" book.. no haskell tho, i believe.. java, C and humm something else. cant recall
15:21:23 <Darius> ack, what are the challenges? "Write anything at all using these languages: Java, C"
15:22:19 <SyntaxNinja> arauko: that might not have been the best haskell book to choose... I thought that book was pre-98 standard
15:22:51 <jadrian> SyntaxNinja: is it? I got it here and never noticed any difference
15:22:52 <Calister> they got different progs to do.. and you send them your solution.. can run it on their servers.. something like that
15:23:05 <monk0> can some1 explain how to trace an expression with Debug.Trace ? new to haskell
15:23:13 * SyntaxNinja is not old enough to know the differences between 1.3 and 98
15:23:25 <jadrian> SyntaxNinja: you might be right it says 1997
15:23:39 <Darius> @type Debug.Trace.trace
15:23:40 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
15:23:41 <jadrian> still it's a very good book
15:24:06 <jadrian> quite some theory, which might be good or bad, depending on ones taste
15:24:11 <Darius> trace "foo" (some expression)
15:51:22 <shapr> why is epochTime :: IO EpochTime ?
15:52:18 <xerox> 'night!
15:52:26 <Calister> ni ni
15:53:03 <shapr> hiya Calister
15:53:14 <Leimy> Wed Dec 22 23:51:34 GMT 2004
15:54:21 <Calister> heya shapr :)
15:54:23 <Calister> hows you?
15:54:32 <shapr> happy that I survived the solstice
15:54:42 <shapr> wassup on your end of the wire?
15:56:11 <Calister> christmas stress.. n the stress of an upcoming test in first week after break
15:56:21 <Calister> and last minute prezzie fixing
16:02:22 <shapr> that does sound lovely
16:02:37 <Calister> ye, doesnt it?
16:02:56 <Calister> oh god.. marvin.. that nick always makes me think of a depressive robot
16:03:52 <SyntaxNinja> that's what he's named after
16:04:36 <Calister> lol
16:04:38 <Calister> ^_^
16:04:43 <wolfman8k> i'm interested in writing a gui library in haskell
16:05:14 <SyntaxNinja> wolfman8k: why not help maintain one of the existing ones instead?
16:05:41 <wolfman8k> they all seem to be 10 years old and based on dead technology and ui paradigms
16:05:55 <wolfman8k> and i just want to do something for fun to learn and expiriment
16:07:03 <SyntaxNinja> http://gtk2hs.sourceforge.net/
16:07:13 <SyntaxNinja> http://wxhaskell.sourceforge.net/
16:07:36 <SyntaxNinja> you can learn a lot by hacking on an existing codebase developed by such programmers
16:07:39 <Darius> SyntaxNinja: Or just http://www.haskell.org/hawiki/LibrariesAndTools#head-75ebc687f6257857cd417c34b00fa35ec1f0c809
16:07:51 <Darius> Though that doesn't seem to list everything.
16:07:56 <wolfman8k> SyntaxNinja: those are nice, but i want something with a functional design
16:08:18 <wolfman8k> something like fudgets
16:08:37 <SyntaxNinja> you might start w/ the work done at yale, wxarrows or something
16:08:54 <wolfman8k> hm...
16:09:53 <Darius> SyntaxNinja: There is Fruit, I haven't heard of anything like wxarrows.
16:09:54 <SyntaxNinja> http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
16:09:59 <SyntaxNinja> wxfruit :)
16:10:08 * jao wants cocoa bindings for haskell
16:11:14 <wolfman8k> i have some ideas inspired from some articles written by ion window manager author and also from fenfire http://www.nongnu.org/fenfire/
16:12:38 <SyntaxNinja> I guess GUIs in haskell are just a pet peeve of mine... there's a lot of people working in different directions on them, and no clear winner
16:12:53 <SyntaxNinja> the same goes for "functional style" guis, and I think a large part of the problem is just not enough manpower.
16:12:59 <basti_> we should make a swig thing for haskell.
16:13:20 * basti_ .o ( oof. )
16:13:41 <Leimy> isn't that greencard?
16:13:56 * Calister rather wants a muzzle for haskell
16:14:02 <Leimy> muzzle?
16:14:11 <Darius> SyntaxNinja: wxHaskell seems to be the "official" winner for the "just get a damn GUI up" group.
16:14:18 <SyntaxNinja> yeah
16:14:25 <Leimy> what about the GUI used in House?
16:15:14 <wolfman8k> what do you guys think of static verification of programs?
16:15:21 <wolfman8k> one thing that bugs me about fudgets
16:15:26 <wolfman8k> is they have a layout system
16:15:27 <basti_> a lot.
16:15:30 <wolfman8k> where you give each widget an id
16:15:49 <wolfman8k> and then you give a seperate tree that describes the layout that indexes the widgets based on their id
16:16:11 <wolfman8k> but the problem is that their is no compile time verification that all of the widget ids are used in the tree, or that an id is not used twice
16:18:01 <wolfman8k> so if you add a widget to the logical part of the code, but forget to place it in the layout, then your program won't work, but you don't get any compiler warnings or anything :(
16:19:05 <wolfman8k> maybe something like template haskell can add support for compile time verification for this type of specialized system
16:23:11 <basti_> maybe someone could think up a real way to specify ui's
16:25:13 <Calister> maybe someone could think of a way to install a haskell compiler or interpreter on my brain
16:25:21 <wolfman8k> o_O
16:25:27 <basti_> better not.
16:25:40 <Pseudonym> Is that going to be a registered build?
16:25:59 <Pseudonym> Actually, give me a brain and I can try to port it.
16:26:03 <Calister> for the next exam i surely do need one
16:26:05 <Calister> lol
16:26:13 * shapr steals a brain for Pseudonym's experiments
16:26:20 <Pseudonym> Abby... Normal
16:26:28 <basti_> there was this movie
16:26:37 <basti_> about some dr.hrrfrurh and his brain or something
16:26:43 <basti_> what was the name
16:26:48 <Pseudonym> The Main With Two Brains
16:26:51 <Pseudonym> Steve Martin
16:26:51 <basti_> yup
16:26:54 <basti_> yup
16:26:57 * Pseudonym was thinking of Young Frankenstein
16:27:06 <shapr> wolfman8k: check out wxFruit and its latest incarnation that's close to Yampa
16:27:13 * Pseudonym converts Calister's cranium to weak head normal form
16:27:16 <wolfman8k> shapr: i'm reading the wxFruit paper
16:27:19 <shapr> wolfman8k: that's very sexy pure FP gui
16:27:24 <Darius> wolfman8k: You may want to look at FunctionalForms which mitigates that somewhat. http://www.cs.ru.nl/~sandr/FunctionalForms/
16:27:31 <Calister> ;o~
16:27:42 <shapr> wolfman8k: ah, cool... Anthony Courtney's thesis as well?
16:28:02 <wolfman8k> shapr: no
16:29:55 <Darius> Wow! He didn't call his thesis, "thesis".
16:30:21 * shapr snickers
16:30:30 <wolfman8k> where can i find this pseudo thesis?
16:31:10 <shapr> locate thesis.ps|wc -l
16:34:17 <shapr> wolfman8k: http://www.galois.com/~antony/
16:34:36 <wolfman8k> thanks
16:41:42 <Darius> "first class signal function continuations" that's new.
16:42:29 <shapr> that's the arrow collections?
16:42:32 <Darius> shapr: What do you think of Halipeto and have you frobbled it to work with a real database?
16:42:51 <Darius> shapr: It's related (apparently) to the Dynamic collections in Yampa
16:43:08 <shapr> I'm using it for scannedinavian.org and no, but Lemmih has.
16:44:40 <shapr> I got Yampa Invaders to create 2000 aliens on startup instead of 2 just to test the speed of the arrow collections. It was really slow, but that may have been limitations of the HSX11 drawing speed.
16:44:40 <shapr> I was hoping for a coroutines replacement with somewhat serializable first class continuations.
16:44:48 <shapr> I really like Halipeto, though it's not at all like WASH. Halipeto is a templating system, WASH is a tag generation and CGI mix.
16:45:19 <Darius> WASH seems like it's more for forms while Halipeto is overall layout.
16:46:00 <shapr> Upsides of Halipeto are:  Anyone can use it, scripting code is in special attributes for tags that can be ignored by editors that don't understand. It's based on Zope Page Templates so I already have lots of experience with the same idea.
16:46:30 <shapr> WASH is very form-centric. The more I use it, the more it irks me.
16:47:27 <shapr> I wish WASH did not require javascript, did not have problems with Persistent and derivatives, did not have the BigWig caching system in the base libs, and caught type errors in a readable manner.
16:47:33 <vincenz> re
16:48:04 <shapr> With all the extensions to WASH, you can compile binaries that give strange errors at runtime, the HTML monad just doesn't check that much.
16:48:20 <shapr> Halipeto doesn't check anything really, it just lets you generate whatever you want.
16:48:58 <shapr> I do think it could check if you pass the legal DTD into any call and check the results. Andrew thinks that would require Template Haskell, but I'm not convinced.
16:49:12 * Darius doesn't feel like writing a parser in Java without StringTokenizer even for something as simple as Joy.
16:49:25 <shapr> Why are you parsing Joy with Java?
16:49:34 <Darius> So I can have Joy on a phone.
16:49:51 <shapr> oh
16:49:56 <shapr> that makes sense
16:50:10 * Darius isn't sure having StringTokenizer would help that much though...
16:50:40 <shapr> I think slava implemented Factor in Java, you could probably steal a bunch of his code.
16:51:09 <Darius> shapr: If one of these industry standard thingies or Nokia itself exports access to the microphone I could work on talking Joy too.
16:51:25 <shapr> that would be awesome
16:51:48 <shapr> several of the nokia models allow voice recording, but I don't know if the J2ME allows access.
16:52:10 <shapr> I have some friends who work with J2ME, I'll ask 'em
16:52:44 <Darius> I can check the docs, I just haven't yet because I haven't got to that part yet.
16:53:17 <Darius> Once I write a parser and then a relatively simple UI I should have a reasonable first cut Joy.
16:54:02 <Darius> After that I'd probably either enhance the GUI or fiddle with talking.
16:54:33 <shapr> I have a J2ME phone, when you have something working... :-)
16:55:19 <Darius> Well if I just suck it up, close my eyes, and pretend that it's not Java, then I could have something working tomorrow.
16:55:31 * shapr grins
16:56:07 * Darius wishes Java had TCO. *sigh*
16:56:39 <Pseudonym> Total Cost of Ownership?
16:56:48 <Darius> Tail Call Optimization
16:56:51 <Pseudonym> Ah.
16:59:38 <wolfman8k> i'm going to slep... night
16:59:45 <Pseudonym> Night.
17:02:00 <shapr> g'night wolfman8k 
17:02:04 <shapr> y0 Coz
17:02:06 * shapr boings
17:02:20 <Calister> ;o
17:02:27 <Calister> you are wide awake, eh?
17:02:36 <wolfman8k> crap, i was falling asleep at the keyboard, but now when i lie down i'm not tired anymore :(
17:02:58 <Calister> take yer keyboard with ya to bed?
17:03:00 <wolfman8k> and it's already past 3 am :'(
17:03:37 <Calister> make a printout of the prelude
17:03:40 <Calister> and read it
17:03:51 <Calister> should make ya fall asleep again
17:04:05 <shapr> but that always gets me excited and I can't sleep.
17:04:18 * shapr grins
17:04:31 <Calister> lol
17:04:36 * jadrian can't sleep because is confused :(
17:04:46 <Calister> for that you get a gf then or playboy
17:04:55 <Calister> humm actually
17:05:10 <Calister> considering in what channel i am.. prelude could be kinna playboy
17:05:17 <Calister> confused bout what?
17:05:27 <jadrian> first order logic
17:05:39 <andersca> you could always print out a picture of john hughes riding the unicycle
17:05:40 <Pseudonym> Actually, the prelude is like playboy... but only the articles.
17:06:11 <jadrian>  |- Exists x . P(x)     <- this sequent should be trivialy falsifiable, right?
17:06:12 <Calister> i better dont try to understand what first oder logic means.. or i will be even more confused than normally
17:06:35 <Calister> lol
17:06:47 <Darius> jadrian: Wouldn't it depend on what P is.
17:06:59 <Calister> Pseudonym: a quite interesting idea ^_^
17:07:01 <andersca> jadrian: just construct the model { 0, 1} with P = { }
17:07:43 <jadrian> andersca: I think that's what I'm thinking but I don't understand the way your wrote it...
17:07:53 <Cale> ah, so that's what falsifiable means :)
17:07:58 <jadrian> andersca: I was thinking about evaluating P to the function that always returns false
17:08:07 <jadrian> Darius: well not really...
17:08:27 <andersca> jadrian: yeah, I see the logical function P as a set where the elements in the set are the ones that P return true for
17:08:37 <jadrian> andersca: ok that's what I thought
17:08:41 <CosmicRay> hi shapr
17:08:53 <CosmicRay> shapr: my ftp server is now working.
17:09:06 <CosmicRay> shapr: all I have to do is implement NLST and LIST and it will be basically done
17:09:13 <Pseudonym> It seems to me that all of the distinctly sexy parts of Haskell are outside the presude.
17:09:17 <jadrian> andersca: ok but now my problem is that I can't get anywhere if I try to show it's falsifiable using a standard deduction gentzen system
17:09:18 <monk0> how can a get the elements of a list like this [(1,2),(1,4),(4,7)] in a list like this [1,2,1,4,4,7] ?
17:09:37 <CosmicRay> monk0: concatMap should be of use to you.
17:09:41 <Calister> Pseudonym: which sexy parts?
17:09:55 <jadrian> andersca: because the rule for "Exists" on right side always duplicates that formula
17:10:15 <jadrian> andersca: so how can I get "stuck" in a branch of the deduction tree
17:10:15 <Pseudonym> Calister: All the stuff that's interesting for writing complicated programs.
17:10:17 <Darius> monk0: You can do it with a simple foldr.
17:10:23 <CosmicRay> Pseudonym: what sort of "stuff"
17:10:33 <andersca> jadrian: hmm, I don't know the gentzen system :/
17:10:39 <jadrian> :-/
17:10:42 <Pseudonym> Monad transformers, interesting data structures and algorithms, templates...
17:10:49 <shapr> CosmicRay: you're too young to know that, sorry.
17:10:52 <Pseudonym> That sort of thing.
17:10:59 * CosmicRay bops shapr
17:11:02 * shapr snickers
17:11:40 <CosmicRay> shapr: I've fscked many filesystems; I don't need the "meaning of computing" talk :-)
17:11:54 * shapr laughs
17:12:15 <Calister> Pseudonym: if you said that to a "normal" (non comp sci) person... 
17:12:29 <CosmicRay> this is going to confuse megamonad, isn't it.
17:12:31 <CosmicRay> MegaMonad: fsck?
17:12:40 <MegaMonad> CosmicRay: I basically know fsck-all about emacs, but i don't think i got it.
17:12:45 <Pseudonym> I guess I should have said "writing complicated programs in Haskell".
17:12:53 <Calister> lol
17:13:03 <jadrian> MegaMonad: do you know Gentzen systems? 
17:13:08 <MegaMonad> jadrian: Am i using the gentzen rules of the systems has an alpha release coming up with me.
17:13:16 <CosmicRay> MegaMonad: so basically, you've never fscked?
17:13:21 <MegaMonad> CosmicRay: I've just added the dynamic loader is fscked.
17:13:27 <CosmicRay> heh
17:13:40 <CosmicRay> MegaMonad: what else is fscked?
17:13:46 <MegaMonad> CosmicRay: I've fscked many filesystems; i don't think gcc is the same edge and the paper, btw, if you're actually making points instead of i.
17:13:49 <Pseudonym> Time to go.  Office christmas party.
17:14:02 <CosmicRay> shapr: told you! :-)
17:14:04 <Calister> cya Pseudonym
17:14:06 <Calister> have fun
17:14:07 <jadrian> bye
17:14:13 <Pseudonym> Farewell all!  And Merry Christmas, Happy Channukah, Merry Pagan Tree Festival or whatever.
17:14:32 <Calister> he better not telling em bout the pics in playboy ;o
17:14:40 <CosmicRay> heh
17:14:41 <jadrian> do you guys know of any mailing list to discuss logic, theorem proving, formal methods and that kind of stuff?
17:14:46 <jadrian> ir an irc channel?
17:14:49 <CosmicRay> heh
17:14:51 * jadrian feels alone
17:14:56 <CosmicRay> those aren't exactly typical irc topics
17:15:05 <Darius> Hmm, if I implement the parser as just returning a lazy stream extending List it might actually not be too ugly...
17:15:12 <CosmicRay> typical irc topics would be things like "txt msg w/o v0w3lz"
17:15:20 <Calister> i used to know a nice mathematics forum.. but its in german anyways
17:15:25 <jadrian> CosmicRay: why is haskell more of a topic than that :P
17:15:51 <CosmicRay> jadrian: ahh, we have two bots to keep us from sinking to that level :-)
17:15:53 <jadrian> there is a math channel in here, but most people that hang there are not into that kind of stuff
17:16:02 <jadrian> CosmicRay: lol
17:16:05 <CosmicRay> jadrian: they're probably all looking for homework answers...
17:16:09 <CosmicRay> jadrian: oh wait, that's familiar too....
17:16:14 <jadrian> lol
17:16:51 <CosmicRay> hmm.
17:16:57 <CosmicRay> that was, erm, interesting timing :-)
17:18:53 <CosmicRay> jadrian: in seriousness, I find that channels with smart, funny people like #haskell are few and far between
17:19:08 <andersca> CosmicRay: that's true
17:19:30 <jadrian> CosmicRay: yeap
17:20:09 <jadrian> and if I recall correctly it did grow quite a bit in the last couple of years
17:20:13 <jadrian> 100 people here now
17:20:46 <Darius> The most I've seen is 122, when I first joined about a year ago the highest was like 50 or 60-some.
17:20:55 <jadrian> yeap
17:21:00 <Darius> Maybe not even that.
17:21:34 <CosmicRay> MegaMonad: how many where there when you first joined?
17:21:40 <MegaMonad> CosmicRay: To me they are joined to the eq instance code, replace the datatype of hand representing the first time i boot 2.6, but sound does not run out of them.
17:23:10 <CosmicRay> ANTIOXIDANT: WOW YOU MIGHT TRY TURNING OFF CAPSLOCK AT SOME POINT :-)
17:23:42 <Riastradh> MY TERMINAL WON'T TYPE LOWERCASE...
17:23:48 <CosmicRay> really?
17:23:51 <Riastradh> NO.
17:24:00 <CosmicRay> what sort of terminal is this?
17:24:16 <CosmicRay> pfft mirc
17:24:27 <Riastradh> AN IMAGINARY ONE.  I'M REALLY JUST USING RXVT IN X11 ON A MAC.
17:24:31 <Calister> mirc can do lower case
17:24:37 <Calister> lol
17:24:39 <CosmicRay> heh
17:24:41 <Calister> mac >_<
17:24:56 <CosmicRay> Riastradh: that's better than AS/400
17:25:00 <Calister> macs are haters... at least they been hating me
17:25:06 <CosmicRay> I'd have to beat him if he was using something based on EBCDIC
17:25:16 <CosmicRay> January 3 is our no more ebcdic day at work!
17:25:24 <CosmicRay> we'll be 99% ASCII from then on!
17:25:38 <Darius> CosmicRay: And the 1%?
17:25:51 <Calister> o.o
17:25:52 <CosmicRay> still a few programs that haven't been ported from the as/400 yet.
17:25:52 <Calister> hope
17:25:52 <CosmicRay> sigh
17:26:15 <CosmicRay> in time, they too will join the, erm, late 20th century.
17:26:27 <ANTIOXIDANT> Hello
17:26:32 <Calister> sounds like ya gonna have lotsa fun
17:26:33 <CosmicRay> hi antioxidant
17:26:58 <CosmicRay> yeah and not lotsa sleep. (I work for a manufacturing company, and our main ERP system is being migrated from as/400 to aix)
17:27:31 * Calister hands CosmicRay coffee... LOTSA coffee
17:28:17 <CosmicRay> thanks.  I'll probably need it.
17:28:32 <ANTIOXIDANT> No op's?
17:28:39 <CosmicRay> don't need 'em
17:28:46 <CosmicRay> chanserv can op people if necessary
17:29:15 <Calister> hidden ops
17:29:18 <Calister> ollalla
17:29:27 <CosmicRay> I don't even know who could be op'd here
17:29:32 <CosmicRay> I've never seen anyone need to be
17:29:47 <CosmicRay> why, are you planning to cause trouble, antioxidant? :-)
17:30:09 <ANTIOXIDANT> No i doubt i could, i can hardly make a haskell function work
17:30:22 <CosmicRay> well, what can we do to help?
17:30:31 <CosmicRay> shapr, you around for a tour?
17:30:57 <Calister> ANTIOXIDANT.. i know how you feel
17:30:58 <Calister> :x
17:34:00 <ANTIOXIDANT> im trying to make a function wich do this, max [7,9] output (9,7) order dont matter, So basically it should return from a list of int's the max of that list as a pair
17:34:44 <CosmicRay> so you might have [1, 3, 9, 8, 2] and would want (9, 8)?
17:35:05 <ANTIOXIDANT> yes, but i only manage to get 9,9 :=)
17:35:14 <Calister> (lol i was about to ask the same)
17:35:39 <CosmicRay> ANTIOXIDANT: is this for a homework assignment for some class?
17:35:53 <ANTIOXIDANT> no its from a exam i did today
17:35:59 <CosmicRay> ah :-)
17:36:18 <CosmicRay> what do you have so far?
17:36:20 <Lemmih> \x -> let s = reverse (sort x ) in (s!!0,s!!1) ?
17:36:46 <andersca> Lemmih: I'd just take 2 $ (reverse . sort)
17:36:48 <andersca> if that worked
17:36:49 <andersca> ;)
17:37:09 <Lemmih> andersca: That wouldn't be a tuple.
17:37:14 <andersca> oh, sorry
17:37:51 <Darius> bye.
17:37:57 <ANTIOXIDANT> well i got a help function, that returns a max from a list, then i try to use that help function head tail
17:38:22 <ANTIOXIDANT> max_list (x:xs) = foldr(\y z -> if y > z then y else z) x xs
17:39:13 <CosmicRay> that looks like it should work.
17:39:37 <ANTIOXIDANT> it works fine for lists with more than 2 int's, but when for ex [7,9] it does (9,9) :=)
17:40:07 <CosmicRay> urm, that function should return a single int, no?
17:40:15 <CosmicRay> @type  max_list (x:xs) = foldr(\y z -> if y > z then y else z) x xs
17:40:16 <lambdabot> bzzt
17:40:21 <bluey> Hello. :) Where can I get help building hugs98?
17:40:24 <CosmicRay> pfft to you, lambdabot.
17:40:31 <Calister> lol
17:40:38 <CosmicRay> bluey: you might try the haskell-cafe mailing list
17:40:45 <CosmicRay> bluey: or here, maybe :-)
17:40:46 <Lemmih> bluey: #haskell is also good.
17:41:08 <CosmicRay> bluey: I don't know that a lot of people here have built hugs, but you can try anyway
17:41:58 <CosmicRay> ANTIOXIDANT: your problem is that you're not making sure you've taking the highest item out of the list before calling max_list again
17:42:19 <CosmicRay> ANTIOXIDANT: I suspect you will get the desired result if the highest item occurs first in the list
17:42:31 <bluey> :)
17:42:54 <CosmicRay> you are stripping off the first element when you call max_list t, but that element may not be the largest, so your max result will be identical
17:43:03 <CosmicRay> Lemmih's version will work
17:44:02 <Lemmih> You should ignore my reply. Posting answers is not helping newbies.
17:45:04 <CosmicRay> yes, I was about to chastize you about that, but otoh, perhaps it would provide insight if antioxidant explores why it works or what it does, and we can help with that
17:45:19 <Calister> i hate you.. you made me get my laptop and start hugs cuz this error in prog is bugging me
17:45:26 <Calister> thats not normal for me
17:45:27 <Calister> >_<
17:45:41 <bluey> Well, I've trying to build the latest snapshot in a Mandrake 10.1 system, and I'm getting errors which prevent the build. It fails during the checks on Bits.hs a lot of times, complaining about syntax problems, and then fails on Storage... Can I paste the errors to someone which could give me some tips on what could be the problem? Maybe a missing library, or something?
17:46:21 <CosmicRay> @wiki HaskellIrcPastePage
17:46:22 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:46:30 <CosmicRay> bluey: I think that is the correct url for pasting stuff like that
17:50:19 <bluey> Ok. Thx ;)
17:51:14 <jadrian> what is the usuall approach for dealing with DAGs in haskell?
17:51:54 <jadrian> it would be cool if there was some way to use the implicit sharing of terms in memory
17:52:22 <jadrian> but even if it worked for building DAGs doesn't seem useful to manipulate them
17:53:35 <CosmicRay> bluey: tell us when you have it pasted.
18:00:27 <bluey> I'll ;) Thank you!
18:05:26 <bluey> Well, it is there... the layout got over the limit of the page... I'll delete that after, since it falls out of the scope of the wiki. ;)
18:06:04 * CosmicRay looks
18:06:07 <bluey> I can put my config.log there too, if it helps...
18:06:29 <CosmicRay> ouch.
18:06:38 <CosmicRay> I don't think I'm going to be able to help you with this.
18:06:48 <CosmicRay> where did you download this source?
18:07:23 <bluey> http://cvs.haskell.org/Hugs/downloads/snapshots/
18:07:33 <CosmicRay> bluey: does an actual release work for you?
18:07:38 <CosmicRay> (a non-snapshot)
18:08:05 <bluey> I'll try the latest stable release. I tried two of the snapshots
18:08:12 <bluey> and both ended that way
18:08:22 <bluey> so it must be something with my system
18:08:22 <CosmicRay> yes, always try the latest stable release first
18:08:28 <CosmicRay> or the snapshot.
18:09:14 <bluey> I'll try to build the stable then. ;)
18:15:27 <bluey> Now it's List.hs which gives that syntax error... :(
18:15:49 <CosmicRay> I'd say you better post on the mailing list
18:15:52 <bluey> I must be missing something needed to build hugs...
18:16:04 <bluey> Is there a list of needed libs?
18:16:34 <CosmicRay> I don't know
18:16:40 <CosmicRay> check www.haskell.org/hugs for hints
18:16:45 <CosmicRay> I've never built hugs
18:19:08 <bluey> Ok, I'll try it tomorrow again. Thank you! I'll clean the wiki. Good night and Happy Xmas ;)
18:19:24 <CosmicRay> good luck!
18:48:00 <arauko> This doesn't work: read (x <- getLine) 
18:48:00 <arauko> ?
18:54:32 <CosmicRay> do x <- getLine
18:54:35 <CosmicRay>    read x
18:54:37 <CosmicRay> will.
19:42:02 <Calister> ni ni all
20:00:21 <redlion> so, there are thousands of wedding photographers, but I could totally dominate the *wedding night* photography business, hardly anyone does that! 
20:27:27 <wagle> like g'kar?
20:27:37 <stepcut> ?
20:27:54 <wagle> ever see babylon 5?
20:27:58 <stepcut> no
20:28:31 <wagle> go watch all 110 episodes about 3 times, then you will understand..
20:28:47 <Lemmih> Was he a widding night photographer?
20:29:09 <wagle> (5 seasons, written mostly by one people, as a sort of novel)
20:29:13 <wagle> Lemmih: sort of
20:29:46 <wagle> he had a prothetic eye that still operated when removed
20:29:54 <Lemmih> Oh.
20:30:15 <wagle> which he used once in this fashion
20:30:50 <wagle> really interesting tv show
20:31:12 <wagle> (that was a throw-away scene)
20:34:58 * Lemmih has been without a TV since the late 2001.
20:35:15 <stepcut> I have not had one since 98 or so
20:36:24 <wagle> i got a tv to watch bab5 in 1997..  then got rid of it last year
20:36:43 <wagle> can still watch the good stuff on dvd
20:37:43 <wagle> TiVo's are both cool and evil
20:40:47 * Riastradh has never owned a TV and is glad of the fact.
20:41:00 <wagle> haha
20:41:28 <wagle> didnt have one for half my life, anyway
20:42:48 <icb> once i weared though the first 5 weeks of nonstop tivo watching, life calms down
20:43:26 <icb> now your friend doesn't have execuse like "i gotta get home to watch startrek"
20:46:14 <wagle> even 9 hours of stored shows was too much
20:46:45 <wagle> "must...  clean... plate!"
20:48:41 * wagle goes home
21:01:51 <SyntaxNinja> anyone try out the new haskell mode debian package?
22:32:52 <Gahhh> Has anyone read "Concepts, Techniques, and Models of Computer Programming" by Van Roy, Haridi ?
23:03:35 <arauko> I
23:03:40 <arauko> have not
23:41:33 <wli> everyone home for the holidays or something?
23:42:29 <ibid> no
23:42:51 <ibid> where's megamaid? :)
23:44:04 * arauko waves
23:45:44 <wli> all we need are a few good monads
23:46:54 <segphault> real programmers can code with only three combinators. ;-D
23:47:04 <wli> heh
23:47:27 <arauko> you look like bored*
23:47:44 <ibid> give me a tall monad and an arrow to steer by
23:48:45 <arauko> let's throw a question, somethng im trying to grasp at the moment.
23:48:47 <arauko> fst :: forall a b. (a, b) -> a
23:48:54 <arauko> snd :: forall b a. (a, b) -> b
23:49:00 <wli> ask away
23:49:18 <arauko> Why the difference between forall a b and forall b a?
23:49:22 <wli> a dup combinator would be handy
23:49:23 * ibid polishes the guns of answer
23:49:31 <ibid> arauko: nothing
23:49:37 <wli> there's no difference
23:49:51 <wli> adjacent universal quantifiers commute
23:49:59 <arauko> Ah ok, so, it could also be well written the same for both cases?
23:50:05 <wli> try it
23:50:24 <ibid> arauko: well, the return type should stay different :)
23:51:18 <arauko> mm.. well, i think it will dump the same...
23:51:23 <Gahhh> arauko, in C++, "extern int a" is also equal to "int extern a".
23:51:43 <arauko> oh no, C++
23:51:45 <arauko> :-)
23:51:47 <Gahhh> heh
23:52:03 <wli> C++ ew
23:52:07 <Gahhh> Well, I had to brush up on my C++ today. 
23:52:10 * segphault cowers in fear of the hideous language
23:52:11 * ibid gets out the c++ standard and removes the dust cover...
23:52:25 <Gahhh> I have to write some COM apps at work. :(
23:52:33 <KrispyKringle> so i'm simultaneously (re)learning OCaml and learning Haskell, and I have to ask, what practical advantages have monads themselves?
23:52:38 <eivuokko> Hmh.  Only cv-qualifiers const and volatile can do that, iirc
23:52:45 <eivuokko> (about the c++)
23:52:58 <KrispyKringle> I suppose I'm finding monads to be the trickiest part of haskell, so you'll forgive me for wondering why they are the way they are, perhaps. 
23:53:05 <segphault> KrispyKringle: I was formerly an ocaml programmer. Monads let you use functional syntax to do stateful things
23:53:47 <Gahhh> Not just state.
23:53:57 <Gahhh> But I am no monad expert anyway.
23:53:57 <KrispyKringle> segphault: formerly an ocaml programmer? hmm. What led you to haskell, out of curiosity?
23:54:22 <KrispyKringle> Right, but if i'm not mistaken, monads are only *necessary* because of lazy execution, no?
23:54:28 <KrispyKringle> that and to preserve the definnition of a function?
23:54:29 * arauko sees KrispyKringle just asked what he was about to ask as second question 
23:54:32 <segphault> KrispyKringle: haskell is WAY more expressive. Haskell gives me a lot more flexibility, and its a lot more concise.
23:54:54 <ibid> eivuokko: apparently, all specifiers can
23:54:57 <Gahhh> KrispyKringle, lazyness doesnt have anything to do with it. Pureness does for IO concerns.
23:54:58 <segphault> KrispyKringle: I've since developed a profound appreciation for delayed evaluation.
23:55:13 <KrispyKringle> ok. i don't know either enough to really compare, i'd dsay. the reason i never used ocaml all that much was the syntax, to be honest, but its all coming back pretty easily, so im liking it. 
23:55:17 <segphault> monads let you preserve referential transparency
23:55:20 <KrispyKringle> Gahhh: oh?
23:55:37 <Gahhh> KrispyKringle, I didnt like OCaml syntax either. Heh.
23:55:41 <eivuokko> ibid, Can you give the place where you checked that?  (page or section)
23:55:47 <KrispyKringle> segphault: what's the advantage? performance-wise, there doesn't seem to be any (or at least, other design choices of haskell counterbalance any gains). 
23:55:50 <KrispyKringle> Gahhh: nobody likes it :P
23:56:05 <segphault> KrispyKringle: much much much cleaner syntax
23:56:18 <KrispyKringle> delayed execution? 
23:56:41 <KrispyKringle> monads themselves seem to impose a significant syntactic burden, at least, for my comprehension. but then, until i fully underestand them, i should probably keep my mouth shut :P
23:56:51 <segphault> KrispyKringle: I thought that way too at first
23:56:57 <KrispyKringle> ocaml is friendlier in that it does imperative programming, as well. 
23:56:59 <ibid> eivuokko: ISO 14882:1998 (E), the formal grammar in section 7
23:57:01 <Gahhh> KrispyKringle, you are no exception. Monads are unusual for most people with imperative background.
23:57:12 <KrispyKringle> Gahhh: so i've heard others say.
23:57:16 <KrispyKringle> which encourages me. 
23:57:17 <ibid> eivuokko: i don't see any constraints that forbid it, and the formal grammar seems to allow it
23:57:31 <segphault> KrispyKringle: what you will realize when you work with haskell long enough is that you really dont need imperative syntax, and your programs are a hell of a lot cleaner without it
23:57:49 <Gahhh> KrispyKringle, there are many good monad tutorials out there. And most people here would not hesitate to give you 15 min on-the-fly tutorials as well. 
23:57:56 <ibid> segphault: or you don't, depending on the problem
23:58:06 <eivuokko> ibid, Iirc that section is doesn't contain everything neccesary.  It's not part of the definition.  But I'll check.
23:58:12 <KrispyKringle> Gahhh: yeah, i've been reading them. i was trying to stick with the Yet Another Haskell Tutorial, but i went on a tangent on monads. 
23:58:13 <arauko> <segphault> monads let you preserve referential transparency <-- even on IO?
23:58:23 <wli> especially on IO
23:58:26 <KrispyKringle> segphault: i guess ill just have to see. 
23:58:29 <Gahhh> eivuokko, I was told about that by Dan Saks at a seminar. I tried it myself, IIRC.
23:58:35 <Gahhh> arauko, yes.
23:58:39 <ibid> segphault: too often, i start out with pure code and then i end up refactoring it to support monads
23:58:43 <arauko> wli, how? (if it is explained easily)
23:58:56 <ibid> eivuokko: you're not making sense. what's not part of the definition of what?
23:59:03 * arauko doubts it though
23:59:19 <KrispyKringle> Oh, I had a silly question, while I'm here...
23:59:20 <wli> it's the CPS style of IO redone with higher-order types
23:59:33 <Gahhh> wli, nice answer lol
23:59:57 <ibid> eivuokko: as i said, i don't immediately see any constraints that forbid it. i'm not certainly going to read the whole standard to find any
