00:05:14 <Nioate> w00t
00:05:44 <aj> i might not /understand/ them, but hey...
00:44:53 <magicuser> haskell is good for what kind of programming projects?
00:46:29 <dons> all kinds
00:53:42 <bourbaki> moin
00:55:31 <TheHunter> moin bourbaki 
01:33:41 <mitchkov> hi, i've a problem that is well known i suppos, but i can't find the solution on the net, ... i've set the heapsize too high, and now winhugs doesn't run anymore, anyone here that can help me out ? 
03:44:05 <musasabi> morning
04:06:24 * dblhelix is away: I'm busy
04:19:25 <jadrian> hello
04:32:17 <bringert> anyone know the status of ghc 6.4 (apart from "we plan to release 6.4 around October/Novermber")?
04:32:47 <bringert> I think November is over even on Samoa
04:33:29 <bringert> not complaining mind you, I just like fresh ghc versions to play with
04:45:55 <musasabi> bringert: I think that is more due to people wanting to squeze features into 6.4 than due to lazyness.
04:46:04 <musasabi> I think it will be this year.
05:01:46 <Lemmih> Good morning, #haskell.
05:07:25 <tromp> good afternoon
05:11:29 <Maddas> Good evening
05:16:43 <jadrian> back
06:03:38 <edi> yawn.
06:41:56 <wli> hmm, how do I do mmap() in the Haskell libs?
06:43:25 <wli> I don't see obvious analogues
06:43:25 <jadrian> mmap() ?
06:43:31 <wli> jadrian: yeah
06:43:38 <jadrian> what's mmap?
06:43:42 <wli> jadrian: like the UNIX system call
06:43:48 * jadrian mans
06:43:53 <wli> jadrian: man 2 mmap
06:44:10 <tuomov> foreign import ...
06:45:34 <wli> tuomov: that leaves the question standing of how to represent its effect and get it to interoperate with the RTS
06:49:15 <wli> neither of which questions I can answer effectively
06:51:18 <Lunar^> wli: Maybe that's a question for glasgow-haskell-users
06:51:44 <wli> Lunar^: good idea
07:03:37 <shapr> @yow ! GOOD MORNING!
07:03:38 <lambdabot> PIZZA!!
07:04:27 <bringert> morning shapr
07:04:38 <shapr> hej bringert!
07:04:38 * bringert is profiling GF
07:04:54 <shapr> TheHunter: that's an interesting quit message.
07:05:14 <TheHunter> shapr, should have been query lambdabot...
07:05:29 <bringert> aarne wrote a french verb grammar that takes forever (for all values of forever that I have tried) to load
07:05:43 <shapr> bringert: so, about five and a half feet tall, like to eat foreign foods, enjoys culture?
07:06:07 <shapr> ok, I admit that joke is getting old.
07:06:21 <shapr> TheHunter: heh, that sort of thing happens to me too :-)
07:07:42 * shapr tries to remember what he read about GF grammar structure.
07:07:54 <shapr> It uses dependent types or something?
07:07:54 <wli> Greibach form?
07:08:13 <shapr> Grammatical Framework by Aarne Ranta and Markus Forsberg.
07:08:38 <shapr> Quite nifty, I hacked up a few simple webapps to help me learn Swedish.
07:09:05 <shapr> bringert is the lucky guy who gets paid to hack on a language framework written in Haskell.
07:10:32 <shapr> bringert: you've already sped up GF dramatically, are you running up against the speed of the type system now?
07:10:43 <shapr> That would be my first guess at least.
07:12:05 <tromp> @index group
07:12:06 <lambdabot> Data.List,List
07:12:17 <tromp> @info List.group
07:12:19 <lambdabot> -- Data.List.group is a variable
07:12:19 <lambdabot> Data.List.group :: forall a. (Eq a) => [a] -> [[a]]
07:13:29 <edi> Eq means "same type", am i right?
07:13:47 <wli> equality comparison type
07:14:00 <edi> okie.
07:14:42 * TheHunter is away: brb
07:15:16 <bringert> shapr: it doesn't use dependent types afaik
07:15:27 <bringert> I think there are still bottlenecks in the code
07:16:00 <bringert> but the grammar is so large I don't have the patience to wait for it to load so I can get a time/allocation profile
07:16:18 <bringert> is there a way to get a time/allocation profile without letting the program finish?
07:16:48 <edi> looking in the crystal sphere
07:16:52 <bringert> you get heap profiling and GC stats when interrupting the program, but not a time/allocation profile
07:17:06 <shapr> I don't think so. 
07:17:16 <shapr> would be nice, especially for programs that crash
07:17:23 <bringert> is there a technical reason why that couldn't be done?
07:17:40 <shapr> I doubt it.
07:18:02 <shapr> it's much more likely that no one ever did it.
07:18:20 <edi> mmh, why (\x -> x x) is an error?
07:18:35 <kristnjov> that would make an infinite something, no?
07:18:46 <edi> yes sure
07:18:55 <bringert> edi: what type would it have?
07:19:19 <bringert> maybe I'll just make a smaller grammar, large enough to be annoying and worth profiling, but small enough to load before next week
07:19:22 <wli> suppose x is of type t, then it must be of type t -> t'
07:19:25 <edi> it takes some function and applies it to itself
07:19:50 <edi> what exactly is t' ?
07:20:23 <wli> some other type
07:21:00 <bringert> (\x -> x x) :: (forall a. a -> a) (forall a. a -> a)
07:21:11 <bringert> sorry, (\x -> x x) :: (forall a . a -> a) -> (forall a . a -> a)
07:21:28 <kristnjov> wouldn't that be like t -> (t -> (t -> (t -> .....
07:21:33 <edi> (t -> t') -> t' ?
07:22:03 <bringert> but that is a higher rank type, which can't be inferred. it works with glasgow-exts though if you give the explicit type
07:24:40 <shapr> wow, does it really take that long to load even without profiling?
07:24:47 <bringert> yeah
07:24:54 <shapr> amazing
07:24:58 <bringert> the gfc-file is over 20MB
07:25:06 <wli> you can infer recursive types
07:25:12 <wli> but most of them aren't meaningful
07:25:27 <bringert> edi: almost, (\x -> x x) :: (forall t . t -> t') -> t'
07:25:34 <wli> generally you need to recurse through a record or sum
07:25:56 <edi> what does it mean the '.' ?
07:26:02 * dblhelix is back (gone 03:19:38)
07:26:17 <wli> edi: composition
07:26:22 <edi> oh sure.
07:26:31 <dblhelix> falling in the middle of something here? rank-n types? gotta love 'em
07:26:55 <edi> btw ghci -fglasgow-ext doesn't give :t (\x -> x x) either
07:27:06 <wli> edi: (1+) . (2*) == \x -> 2*x+1
07:27:06 <bringert> no, you have to give it explicitly
07:27:10 <edi> exts
07:27:26 <bringert> :t (\x -> x x) :: (forall t . t -> t') -> t'
07:27:29 <dblhelix> edi: no because the types cannot be inferred
07:27:51 <bringert> edi: this is known as a rank-2 type
07:28:11 <edi> i see
07:28:15 <dblhelix> in general, for rank-n polymorphism (n >= 2), type inference is undecidable
07:28:28 <edi> that's interesting
07:28:30 <jadrian> by the way
07:28:43 <jadrian> why is it ok:  bar :: (forall a. a)-> b 
07:28:44 <jadrian> but not
07:28:49 <jadrian> bar' :: (forall a . Foo a => a)-> b
07:28:52 <bringert> edi: for info on rank-n stuff in ghc, see: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#UNIVERSAL-QUANTIFICATION
07:29:31 <kosmikus> dblhelix: not sure, I think it might be decidable for rank 2, actually, but it certainly isn't for rank > 2
07:29:57 <wli> dblhelix: yes, undecidability is considered nasty]
07:29:58 * dblhelix tries to remember ...
07:30:08 <bringert> isn't the problem for n = 2 that you lose some other nice properties?
07:31:17 <jadrian> bar' :: (forall a . Foo a => a)-> b  -   Ambiguous type variable `a' in the top-level constraint: `Foo a' arising from a function with an overloaded argument type
07:32:08 <bringert> what does the body look like?
07:32:16 <wli> I'm trying to remember what n=2 loses
07:32:21 <wli> I think it may lose principality
07:32:59 <dblhelix> doesn't rank-2 already give typing problems wrt polymorphic recursion and stuff?
07:33:18 <wli> name a reference
07:33:21 <jadrian> bringert: the body off bar'? it's undefined :)
07:33:24 <wli> I may be able to look it up
07:48:56 <dblhelix> bringert: (jadrian seems gone) ... changing the body from undefined to \f -> undefined makes it type check again
07:49:02 <dblhelix> bringert: but why?
07:52:09 <dblhelix> (forall c . c) cannot be instantiated with a rank-2 type (?) 
07:53:19 <jadrian> back sorry
07:53:22 <dblhelix> at least, when type classes play a role in the rank-2 type
07:53:49 <dblhelix> jadrian: can't explain why, but it works when your body reads \f -> undefined
07:53:50 <jadrian> dblhelix: just seen the logs
07:53:58 <jadrian> dblhelix: yeap, seems weird
07:53:58 <dblhelix> ah, okay
07:54:46 <dblhelix> seems like a question for the implementors :)
07:54:55 <jadrian> yeap guess so...
07:56:35 <dblhelix> it seems rather arbitrary to me, anyway
08:02:15 <bringert> shapr: I just realised that the UI for the flashcard app is undocumented
08:03:12 <bringert> you use the up/down buttons to flip the word, and the TODO button to mark the word as known
08:09:08 <dblhelix> kosmikus: is it okay to mention typos in any of the figures of your thesis? (it's not that *useful* to mention them, anyway)
08:12:25 * dblhelix is away: brb
08:28:42 * dblhelix is back (gone 00:16:16)
08:28:58 * TheHunter is back (gone 01:14:16)
08:46:58 <jadrian> can you use a shortcut for "otherwise" in the new haskell mode?
08:47:20 <jadrian> I've looked into the haskell-indent mode file and its supposed to be \C-c \C-o
08:47:23 <jadrian> like I expected
08:47:35 <jadrian> but instead it seems to turn on and off haskell-doc-mode
08:48:08 <jadrian> exactly... 
08:48:12 <jadrian>   (local-set-key "\C-c\C-o" 'haskell-doc-mode)
08:48:23 <jadrian> eh
08:48:30 <Philippa> *sniggers*
08:48:40 <Philippa> I just confused my Tyop interpreter with the GHCi instance it was running in
08:48:42 <Philippa> d'oh
08:54:18 <tromp> otherwise should be equal to True
08:55:03 <tromp> yep, it's defined that way in Prelude
08:59:56 <jadrian> how good is GHC performing deforestation?
09:00:59 <jadrian> I can flatten (doing a preorder traversal) some datatypes I have and then apply lists functions
09:01:17 <jadrian> (foldr, foldM, zipWith, zipWithM)
09:01:27 <jadrian> or re-define those functions for my types
09:01:44 <jadrian> I'm stiking with flattening first for now
09:02:00 <jadrian> I wonder if it is worth the bother to try and optimize that
09:02:27 <monochrom> You can probably ask on the ghc mailing list.
09:03:04 <wli_> monochrom: say, any chance you could plop a pointer in this direction in the EfNet #haskell topic (you seem to be maintaining it)
09:03:04 <jadrian> yeap guess I'll do that 
09:03:32 <jadrian> or maybe I'll just try and see how it goes if I have time
09:04:25 * jadrian feels like he is reinventing generic programming :-/
09:04:31 <jadrian> I should know more about it
09:04:44 <jadrian> instead I'm defining classes of simply recursive structures
09:04:52 <jadrian> and classes of mutually recursive structures
09:04:52 <monochrom> wli_: Yes. But I don't understand what topic you want to set.
09:05:10 <jadrian> and defining my own traversals
09:05:18 <jadrian> this doesn't feel right...
09:05:22 <monochrom> Ah, you mean pointing to this channel?
09:05:31 <wli_> monochrom: just mentioning irc.freenode.net #haskell in the topic will do
09:06:18 <monochrom> done
09:06:27 <wli_> spiffy, thakns
09:06:42 <wli_> the students will swing by here now and we won't have to field all that alone
09:07:02 <monochrom> The students!  The horror!
09:07:08 * shapr gasps
09:07:29 <monochrom> Students on #efnet are different.  They are exceedingly dense.
09:08:08 <kosmikus> dblhelix: you mean, you want to mention them in your thesis?
09:09:00 <dblhelix> kosmikus: no, I do not mean that
09:09:20 <dblhelix> just ran in a very strange one
09:09:32 <dblhelix> /s/in/into
09:10:48 <dblhelix> kosmikus: p. 164, fig. 10.5, ep-constr-1: it's not that shocking though
09:12:13 <dblhelix> kosmikus: guessed that it should've been [| epsilon |]^ep, shouldn't it?
09:13:26 <dblhelix> kosmikus: just wanted to make sure, I wasn't missing any details here, and that it is indeed a typo
09:22:30 <kosmikus> dblhelix: right, thanks
09:23:49 <kosmikus> dblhelix: the arrow doesn't make sense there, either
09:24:34 <dblhelix> kosmikus: okay
09:26:18 <shapr> hiya vivien, how's the job?
09:26:57 <vivien> not bad not bad..
09:27:01 <vivien> having exams actually..
09:27:09 <shapr> Oh, did you study?
09:27:13 <vivien> how are things going with you shapr?
09:27:35 <shapr> I'm having success with my fun code, and successfully ignoring my work code for the moment.
09:28:30 <shapr> I do wish that HUnit had support for test fixtures, even though I know it was never designed to test IO code.
09:28:54 <shapr> Who's maintaining HUnit these days? Should I just send patches to the libraries list?
09:29:45 <bourbaki> mon
09:29:48 <bourbaki> moin
09:29:50 <shapr> y0 bourbaki
09:30:02 <shapr> moin mon, how de dub gwan?
09:30:23 * shapr tries rasta-speak
09:31:25 <bourbaki> :)
09:31:40 * shapr throws monads
09:31:41 <bourbaki> god mon ;)
09:31:57 <shapr> dat's duppy!
09:32:25 <bourbaki> heh
09:33:13 <shapr> me an de bwoyz gwan down trenchtown, you wan go too?
09:33:38 <bourbaki> trenchtown :)?
09:34:11 <shapr> the capital of jamaica, kingston is called trenchtown in rasta-speak
09:34:36 <shapr> dub-speak can be nearly impenetrable.
09:34:55 <bourbaki> hehe is there a dict for it?
09:35:13 <shapr> Probably so. There's lots of good pages online too.
09:35:38 <bourbaki> got one handy?:)
10:11:30 <jadrian> since there is Error e => Either e  is a monad it would be nice to have functions like the ones in Data.Maybe
10:12:32 <jadrian> converting monadic code using Maybe to Either e, to handle multiple kinds of error would be trivial then...
10:32:46 <Igloo> OK, I knew I was messing around with unsafe stuff, but I didn't expect to get /cpp/ to segfault
10:34:31 <SyntaxNinja> haha
10:35:36 * aleator would like to interface some c++ code with ghc. Any hints?
10:40:07 <musasabi> aleator: extern "C"
10:40:27 <aleator> And the linking?
10:40:29 <musasabi> aleator: I have some code doing that with manual bindings if you are interested.
10:40:46 <aleator> musasabi: That would be nice, yes.
10:41:07 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk-0.2.3.tar.gz
10:41:33 <aleator> musasabi: Thank you!
11:06:50 <jdrake> Are there any practical tutorials online about learning haskell and actually building something useful at the same time? For example, doing an 'ls' replacement or some such
11:08:15 <wli_> I'm pondering taking on one of those totally-monadic interpreter -type tasks at some point
11:08:30 <wli_> and hitting up this channel for walking me through the parts I don't understand
11:08:37 <jadrian> jadrian: it's not really a tutorial, but you might wanna check http://www.volker-wysk.de/hsshellscript/
11:13:29 <shapr> Whee, just unicycled around the lake here. That's quite some distance.
11:13:43 <shapr> I wonder how I could write a unicycle simulator with Yampa... hmm
11:14:45 <wolfman8k> where can i read how to make programs out of multiple "translation units" and then link them together?
11:15:01 <wolfman8k> does haskell use standard linkers?
11:16:08 <shapr> what do you mean? lazy pipelines? dynamic libraries?
11:16:26 * SyntaxNinja knows that lake! it's big!
11:16:31 <shapr> wli_: the monadic interpreters papers cover it pretty well.
11:16:40 <shapr> heya SyntaxNinja! wassup? Did you walk around the lake when you were here?
11:18:36 <shapr> wli_: especially the one about "building modular interpreters with monad transformers" 
11:19:06 <musasabi> jdrake: ls? 
11:19:25 <shapr> jdrake: I think Igloo did an ls replacement in Haskell.
11:19:34 <wolfman8k> jdrake: my first haskell program(and only so far) was a raytracer. i think it was a good choice
11:19:38 <jdrake> how do you use a unicycle? It seems a large conceptual leap from a duocycle
11:19:48 <musasabi> jdrake: http://youzen.b2.fi/~musasabi/ls.hs
11:20:02 <SyntaxNinja> shapr: yeah
11:20:03 <shapr> jdrake: I found inner balance on top of a unicycle.
11:20:05 <jdrake> wolfman8k, I don't even know how a raytracer actually works (beyond the thing of using 'ray'
11:20:24 <wolfman8k> jdrake: you basicly shoot a ray out for every pixel
11:20:35 <wolfman8k> that's all you need to know really
11:20:56 <jdrake> hmm
11:20:57 <Nioate> also, a little vector math
11:21:00 <wolfman8k> and it helps to know the equations for some simple lighting models
11:21:06 <Nioate> but you can easily find that with google
11:21:08 <shapr> I wrote a mandelbrot fractal grapher that put out an asterisk or a space for each spot in the grid.
11:21:15 <wolfman8k> yeah, and the equations for intersecting rays with spheres :)
11:21:16 <jdrake> I think I need something a little more basic that covers some syntax too
11:21:23 <shapr> @wiki HaskellDemo
11:21:24 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
11:22:16 <wolfman8k> my first run was ascii art too :) check it out:
11:22:17 <wolfman8k> http://rafb.net/paste/results/L2ZBBN74.html
11:22:37 <tuomov> I also did mandelbrot as one my first toy programs
11:22:41 <shapr> wolfman8k: nifty!
11:23:05 <wolfman8k> that was only like 20 lines of haskell
11:23:08 <shapr> here's mine - http://www.scannedinavian.org/~shae/src/haskell/Mandelbrot-0.2.hs
11:23:22 <wolfman8k> nice!
11:23:32 <shapr> I got help from dennisb, wli_, and Heffalump
11:24:07 <wolfman8k> i got help from a bunch of dudes including you i think :D
11:24:16 <wolfman8k> hm.... i smell popcorn
11:24:32 <shapr> I smell 1.5 hours of exercise... I need a shower =)
11:25:48 <tuomov> slightly shorter: iki.fi/tuomov/mdb.hs 
11:26:15 <shapr> oh just slightly
11:26:16 * shapr snickers
11:26:58 <jdrake> unfortunately none of this helps any but haskelldemo, it all is lacking adequate explanation
11:27:08 <shapr> really?
11:28:10 <jadrian> jadrian: trye the "Haskell School of Expression" by Paul Hudak
11:28:18 <jadrian> ops
11:28:24 <jadrian> jdrake: try the "Haskell School of Expression" by Paul Hudak
11:28:47 <jadrian> jadrian: http://www.haskell.org/soe/
11:29:00 <jadrian> The Haskell School of Expression: Learning Functional Programming through Multimedia
11:29:11 <jdrake> I am afraid money does not exist right now
11:29:49 <jadrian> jdrake: well there are some lecture slides on the side, and some demos available
11:29:49 <Philippa> jdrake: you're in a good place to ask for adequate explanations
11:29:56 <shapr> I wonder if some of those other small programs could be later parts in a series after HaskellDemo
11:29:59 <jadrian> jdrake: maybe you can use them
11:30:01 <shapr> hiya atwood 
11:30:10 <atwood> hi
11:30:23 <wolfman8k> i beat around the bush for about a year reading loads of haskell tutorials and documents and stuff. but i only started learning it once i just jumped in and started coding
11:30:28 <wolfman8k> you will be surprised how easy it is
11:30:50 <tuomov> yeah, the best way to learn programming is to program
11:31:01 <tuomov> I've never read many programming books
11:31:06 <jadrian> I never say that to newbies :)
11:31:09 <wolfman8k> while i was reading, i was like "yeah this stuff is nice, but how do you actually code an actual program that does something?" but once i started coding i immediately started to understand things :)
11:31:12 <jadrian> I mean yeah some things are really easy
11:31:20 <jadrian> but some stuff is not going to be easy
11:31:31 <jadrian> it may be fun and challeging :)
11:31:34 <jadrian> but not easy
11:31:57 <wolfman8k> if you've coded in another language before, then starting to code simple haskell programs should be easy
11:32:12 <jadrian> yes, and the keyword there is simple ;)
11:32:14 <jdrake> ok, if I were to start with a thing to do, say something to count the characters in a file. That in itself should be pretty easy because I already know the thing to get the length of a list
11:32:15 <jadrian> and even then
11:32:34 <Philippa> yeah, the IO monad is a lot easier once you know "use return on pure values, use the do notation and treat it as per imperative"
11:32:54 <wolfman8k> i chose to do a raytracer since there is no IO involved in it
11:33:04 <wolfman8k> i would try thinking of another type of program that doesn't do any IO
11:33:16 <wolfman8k> that way you will really learn functional programming. i think
11:33:23 <tuomov> it's best to start with a program where main = putStr something
11:33:29 <jdrake> I have used ocaml and sml in limited ways
11:33:30 <jadrian> yeap
11:33:36 <tuomov> or maybe interact if you're adventurous
11:33:58 <jdrake> I could just put said string inside the source file
11:38:44 <jdrake> well I have my first program,  main = putStr demotext
11:38:59 <jdrake> demotext = "In a rabbit hut there was a dog, cat and rabbit sitting down to have roast tofu"
11:45:11 <aleator> Is greencard still "in" or is there more recommendable preprocessor/ffi-builder?
11:48:38 <kristnjov> what is tofu?
11:48:56 <shapr> it's food made from beans
11:49:00 <shapr> I forget what sort of beans
11:49:07 <stepcut> soy beans
11:49:07 <shapr> peas...
11:49:08 <shapr> um
11:49:10 <shapr> right!
11:49:29 <stepcut> and soy cheese is a type of plastic made from soy beans
11:49:32 <shapr> Tofu is sort of like edible air.
11:49:36 <shapr> haha!
11:49:44 <shapr> Surprisingly tofu can be extremely tasty.
11:50:10 <shapr> I know someone who makes excellent tofu recipes.
11:50:16 <shapr> And he's on this channel right now!
11:50:43 <jdrake> Tofu can absorb almost any taste
11:50:49 <ikegami--> :)
11:51:32 <SyntaxNinja> shapr: hmm. I don't think I managed to make tofu for you, did I?
11:51:39 <SyntaxNinja> Sweden doesn't seem to have it
11:52:17 <shapr> No, you didn't manage to make it for me. But I heard rumors you're going to cook tofu at the next ICFP in Estonia?
11:53:22 <ikegami--> dried tohu (we call it "koya-tofu") is also good
11:54:36 <jdrake> I am having difficulty with this: main = putStr showInt strlen demotext   I have tried various combinations thus and can't exactly understand everything I am given back
11:54:57 <jdrake> such as: *** Term           : putStr    *** Type           : String -> IO ()              *** Does not match : a -> b -> c -> d
11:55:15 <SyntaxNinja> estonia, huh?
11:55:24 * shapr grins
11:55:32 <jadrian> jdrake: maybe   putStr (showInt strlen demotext)
11:55:50 <jadrian> jdrake: but it's probably
11:55:54 <jadrian> jdrake: maybe   putStr (showInt (strlen demotext))
11:55:57 <jadrian> opss
11:55:59 <shapr> yah, I like that one
11:56:02 <jadrian> jdrake: putStr (showInt (strlen demotext))
11:56:12 <SyntaxNinja> shapr: I wonder if they have tofu
11:56:20 <shapr> We can import some.
11:56:40 * jadrian tried raw tofu the other day...
11:56:44 <jadrian> it's not that good
11:56:49 <jdrake> *** Term           : showInt (strlen demotext)      *** Type           : [Char] -> [Char]    *** Does not match : [Char]
11:57:46 <jdrake> showInt        :: Integral a => a -> ShowS             type ShowS = String -> String
11:58:04 <jdrake> so would that be that showInt returns a function String -> String?
11:58:15 <jadrian> jadrian: what is showInt?
11:58:26 <jdrake> from Numeric
11:58:41 <SyntaxNinja> I could get to use my russian maybe. hmm
11:58:42 <musasabi> jdrake: just use "show"
11:59:18 <jadrian> yeap
11:59:19 <jdrake> ok, it works now
11:59:42 <jdrake> now if I wanted to get this thing to count something else, such as words what would be a hint of what I would have to do
11:59:58 <jadrian> by the way where did you get that strlen?
12:00:09 <jadrian> I supposed that is the same as "length"
12:00:16 <jadrian> suppose*
12:00:21 <jdrake> jadrian, I made it and yes it is the same as length
12:00:25 <jadrian> k
12:04:11 <shapr> hi Dan
12:04:17 <JustPlainDan> hi
12:04:33 <JustPlainDan> how is polymorphic recursion together with type classes implemented?
12:05:06 <shapr> usually the Class a => part gets filled in
12:05:16 <shapr> do you know about the monomorphism restriction?
12:05:26 <shapr> have you read about Num defaulting in GHCi ?
12:05:39 <JustPlainDan> no
12:05:52 <JustPlainDan> there's a monomorphism restriction?
12:05:55 <shapr> yup
12:06:01 <shapr> that's part of why your question is very sensible.
12:06:11 <shapr> google has a lot to say about it.
12:06:12 <JustPlainDan> I've heard of Num defaulting, but I haven't read much about it
12:06:24 <shapr> when you type 1 + 1 in GHCi, what's the type of 1?
12:06:33 <JustPlainDan> Integer by default, I think?
12:06:40 <edi> forall a. Num a
12:06:43 <JustPlainDan> but really Num a => a
12:06:49 <edi> wops.
12:07:05 <edi> forall a. Num a => a i meant
12:07:24 <JustPlainDan> isn't it needed in all of haskell, not just GHCi?
12:07:55 <shapr> Usually it's easy to infer in the rest of Haskell. At some point you use an operator or function that specifies it.
12:08:19 <JustPlainDan> and if you don't?
12:08:48 <shapr> I'm not sure.
12:08:55 <shapr> I think originally it complained and made you choose something.
12:09:16 <JustPlainDan> you mean like choose it at the console you compile it at?
12:09:33 <Philippa> there's a default setting, and a means of changing it at the top level
12:09:55 <JustPlainDan> but that's GHCi, isn't it?
12:09:57 <Philippa> don't know about 'originally', I first wrote Haskell code in 2001
12:10:03 <Philippa> no, that's Haskell 98
12:10:24 <JustPlainDan> so there's a default setting for each typeclass?
12:10:30 <JustPlainDan> or just Num?
12:10:35 <Philippa> just the numerics
12:10:57 <Philippa> you only really need it for those, on the grounds that there the constructors're overloaded
12:11:08 <Philippa> you'd need it if you made String a type class, say
12:11:53 <edi> why?
12:12:16 <Philippa> because then "foo" would be ambiguous (OK, OK, you can just default to [Char] and leave it at that...)
12:12:43 <JustPlainDan> I can think of a lot of cases where you might need it. Say you do show . somePolymorphicProcessing . read?
12:13:05 <Philippa> read is just generally bad
12:13:17 <JustPlainDan> well, aside from that...
12:13:29 <Philippa> any other cases that don't suffer the same flaw as read?
12:13:37 <JustPlainDan> hmm
12:13:40 <Philippa> (where you can just do (read foo)::bar)
12:15:00 <Philippa> I'm tempted to say that in the Read case, not defaulting is good - defaulting will cause much unexpected behaviour
12:15:14 <Philippa> and you can use a type annotation to say what you mean anyway
12:15:34 <JustPlainDan> yeah, I guess
12:16:02 <JustPlainDan> so do you think read probably shouldn't be generic?
12:16:14 <Philippa> it's tempting, isn't it?
12:16:27 <Philippa> but I'll allow it on the basis that there're times when the annotation can be inferred
12:17:08 <Philippa> most notably a fair chunk of the use sites for read (show foo) and variants 
12:17:30 <JustPlainDan> I think it makes less sense for read to be generic than for map (which isn't, unless they just changed something)
12:17:33 <JustPlainDan> why would they do that?
12:18:34 <Philippa> what do you mean "generic"?
12:18:46 <Philippa> "has a parametric type"?
12:19:09 <Philippa> read's overloaded, map is parametric but really really doesn't care what's in the list so long as the types match
12:19:44 <JustPlainDan> I meant overloaded
12:19:47 <JustPlainDan> sorry
12:20:42 <Philippa> the extent to which there's call for map to be overloaded is met by fmap/Functor...
12:20:58 <JustPlainDan> yeah, but why not just overload map always?
12:21:20 <JustPlainDan> why does "foldl (+) 0" cause a type error? (it's something about monomorphism, but I can't tell what)
12:21:26 <Philippa> overloaded read is pretty much a convenience at first, but because of the deriving clause it's sorta worth leaving there - you can have the dual of show calculated for you
12:21:52 <Philippa> as for not just always overloading map, that boils down to history and potential confusion
12:22:16 <Philippa> the type errors make more sense for map than they would for fmap on list
12:23:08 <aleator> Whee. My soon to be drawing library for haskell just produced it's first blank png.
12:23:37 <Philippa> foldl (+) 0 is probably causing an error complaining about Show instances, because the result is a function (pass it a list!)
12:24:00 <JustPlainDan> no, foldl (+) 0 as a definition of sum
12:24:04 <JustPlainDan> without an explicit type annotation
12:24:44 <musasabi> aleator: please tell me when that will be available.
12:24:51 <Philippa> works here
12:25:32 <JustPlainDan> a gentle introduction to haskell said it had an error
12:25:56 <aleator> musasabi: I will. If I ever find time to make it usable.
12:26:49 <musasabi> foldl (+) 0 :: forall b. (Num b) => [b] -> b
12:26:59 <Philippa> which, shock horror, is the right type
12:28:59 <Philippa> does -fglasgow-exts lift the monomorphism restriction by default? (would scare me if it did)
12:29:11 <JustPlainDan> why would it?
12:29:29 <JustPlainDan> are there any downsides besides inefficiency to lifting it?
12:29:40 <JustPlainDan> (and I'm not even sure it's inefficient)
12:29:52 <Philippa> I believe it does interesting things to what else can and can't be inferred
12:29:57 <Philippa> for "may you live in" values of interesting
12:30:15 <JustPlainDan> what would it mean can't be inferred?
12:31:05 <jadrian> Philippa: nope it doesn't
12:31:25 <jadrian> Philippa: (doesn't lift the monomorphism restriction by defaul, that is)
12:32:58 <Philippa> is there a good way to check if GHCi's in Haskell 98 mode?
12:33:08 <Philippa> (of course, the implementation could be broken, it's just the tutorial could too)
12:33:16 <edi> try :t (\(x::Int)->x*x)
12:33:46 <Philippa> yields Int->Int, (surprise surprise)
12:34:00 <edi> so glasgow extension are loaded
12:34:14 <jadrian> I think  :set  also works
12:34:19 <edi> <interactive>:1:
12:34:19 <edi>     Illegal signature in pattern: Int
12:34:19 <edi> 	Use -fglasgow-exts to permit it
12:34:20 <JustPlainDan> what? isn't that monomorphic?
12:34:33 <derelm> i wonder if it is possible to declare a new type in haskell like data Xy = Xy Int Int  and now let the first int only be < 12 and the latter < 300 e.g
12:34:43 <jadrian> but yes :t (\(x::Int)->x*x)  is way cooler :)
12:34:49 <edi> ^_^
12:34:58 <edi> hello Lemmih !
12:35:08 <Lemmih> Yo.
12:35:19 <JustPlainDan> derelm: CL has something like that
12:35:24 <Darius> derelm: smart constructors, if you want dynamic checks (which seems the reasonable way to go
12:35:31 <JustPlainDan> derelm: but it's dynamically typed, so...
12:35:53 <derelm> so basically it's not a thing beginners do, right? :)
12:36:17 <JustPlainDan> no, a smart constructor, if I understand darius right, could just be a function.
12:36:44 <Darius> smart constructors are straight forward, don't export the Xy constructor, instead define xy x y | x < 12 && y < 300 = Xy x y
12:36:54 <Darius> (and export that)
12:36:58 <jadrian> Darius: I used to do that...
12:37:18 <JustPlainDan> but did you want to do some sort of static check, derelm?
12:37:21 <jadrian> Darius: but now I really like to export constructors
12:37:46 <derelm> JustPlainDan: well i want an error raised if your input exceeds the limit of the datatype
12:37:46 <JustPlainDan> jadrian: why?
12:38:01 <jadrian> it has been discussed in the mailing list
12:38:02 <JustPlainDan> derelm: at compiletime or runtime?
12:38:17 <jadrian> it's just easier to avoid mistakes and get good error messages
12:38:27 <derelm> JustPlainDan: hmm, well at runtime
12:38:45 <JustPlainDan> then what's wrong with darius's solution?
12:38:52 <jadrian> nothing
12:38:59 <jadrian> it's the way to go really
12:39:03 <Philippa> except it can't be caught outside the IO monad
12:39:04 <derelm> that was, just use a function and a guard?
12:39:15 <Philippa> but yeah
12:39:34 <derelm> ok, i'll use that, thanks!
12:40:13 <Philippa> 'twould be nice to be able to type for use of subsets of the IO monad as it were, but hey
12:40:22 <derelm> btw: thanks to everyone on #haskell, you guys help a lot! i'd be lost otherwise ...
12:40:40 <JustPlainDan> what happens if none of the guards are met?
12:40:54 <Darius> Effectively pattern match failure.
12:41:20 <Philippa> remind me, is that an exception in the IO monad, or just "code go splat"?
12:41:28 <Darius> splat
12:41:36 <Philippa> erk, not good
12:41:38 <Darius> (at least sticking to Haskell 98(
12:41:42 <Philippa> predictable, admittedly
12:41:47 <Philippa> heh, point
12:42:16 <musasabi> hmm ghc is not the only evil compiler - http://www.cs.helsinki.fi/u/ekarttun/sc/Misc/sc-top-g++.png (this is on 2ghz machine)
12:42:20 <Philippa> oh well. non-dependantly-typed language in partial function shocker
12:43:22 <Lor> musa, your username is "e"? :)
12:44:16 <musasabi> Lor: yes.
12:44:31 <musasabi> on a lot of machines ;)
12:45:21 <Lor> A bit short, it doesn't look like a real username.
12:45:26 <JustPlainDan> so to be catchable, maybe the code should be  xy x y | x < 12 && y < 300 = Xy x y; | otherwise = unsafePerformIO throwAnErrorSomehow
12:45:28 * Lor prefers two-letter usernames. :)
12:45:45 <Philippa> JustPlainDan: or use the Maybe type
12:45:55 <CosmicRay> I have no idea what you're talking about, dan, but that looks incredibly evil
12:45:57 <JustPlainDan> yeah, or that
12:46:01 <CosmicRay> there's a reason it has "unsafe" in its name :-)
12:46:05 <JustPlainDan> CosmicRay: it is :)
12:46:14 <JustPlainDan> I like being evil
12:46:30 <CosmicRay> why do you need to use unsafePerformIO to throw an error anyway?
12:46:40 <JustPlainDan> because it has a side effect
12:46:45 <JustPlainDan> unless, of course, you go with Maybe
12:46:49 <JustPlainDan> which would probably be better
12:46:51 <Philippa> actually, throwing one doesn't
12:46:53 <CosmicRay> I don't follow
12:46:58 <musasabi> you can throw errors without IO
12:46:59 <CosmicRay> you can just use error, can't you?
12:47:01 <Philippa> it just ends evaluation in the same way that the pattern-match failure doesn't
12:47:04 <Darius> Haskell 98 only catches IOErrors which can only be thrown from IO.
12:47:06 <CosmicRay> or one of the throws
12:47:26 <Philippa> Darius: sure
12:47:42 <Darius> I actually wonder what would happen in say Hugs with the unsafePerformIO version...
12:47:46 <CosmicRay> Darius: are there really any haskell implementations in common use today that are restricted to that?
12:47:52 <Philippa> JustPlainDan: it's installing an exception handler that's a side-effect
12:48:09 <Philippa> CosmicRay: occasionally caring about Haskell98 is worthwhile
12:48:39 <CosmicRay> Philippa: true, but afaict even ghc or hugs in 98 mode will be able to do more with exceptions than just throw them in the io module
12:49:02 <CosmicRay> it doesn't require -fglasgow-exts or -98 or anything
12:49:18 <Philippa> no, just a library that can't be implemented in H98
12:49:46 <CosmicRay> we really need an h04 or something; it seems the de-facto standard these days is more aligned with fptools
12:50:23 <Darius> CosmicRay: Haskell II has been aching to be born for years.
12:50:29 <Lor> In features, ghc leads and others follow, yeah.
12:50:34 <Lor> It wasn't always like this.
12:50:47 <Darius> Lor: NHC doesn't really follow...
12:50:52 * Lor remembers installing hbc because at the time it was the only haskell implementation that supported existentials.
12:50:58 <CosmicRay> Lor: don't hugs and nhc just use fptools as-is?
12:51:59 <Darius> Lor: Who needs existentials?  Just give me arbitrary rank polymorphism.
12:52:26 <Lor> Yeah, then you can church-encode existentials.
12:52:45 <Lor> Hm, wonder if that's a proper name for it.
12:52:48 <Darius> I'm not sure if I'd consider it a Church encoding.
12:53:03 <Darius> It's more a Curry-Howard "isomorphism" thing.
12:54:38 <Lor> Ex.t(x) ~ Au(Ax.t(x)->u)->u
12:55:53 <Darius> Or more compactly, Ex.P(x) <=> not Ax.not P(x)
12:57:26 <Lor> Yeah, when you instantiate u with falsum.
12:57:51 <Darius> I was wondering recently about getting rid of universals with existentials (which would be a bit like encoding FP in OO), but the 0 morphism is naturally forall a._|_ -> a
12:58:04 <Lor> Ah, that's an exercise in TAPL. :)
12:58:31 <Lor> I think it's possible, but you have to CPS-convert the entire program.
12:58:43 <Lor> program, proof, whatever...
13:00:55 <Darius> Yep, logicians got to CPS transform before us. Take a wild guess what goes into the omitted equation array environment for Fact 1.8.7 http://www.cs.man.ac.uk/~pt/Practical_Foundations/html/s18.html
13:01:56 <Darius> However, coding existentials with universals should not actually look too much like CPS form
13:02:19 <Darius> At least that's my impression about thinking about playing with open and pack.
13:02:37 <Lor> I've never been able to get my font settings right to read Practical Foundations.
13:02:55 <Darius> The CPS transform should occur mostly when you repack and opened existential.
13:03:19 <Darius> Lor: I converted the webpages to a PDF, but the lack of diagrams and whatnot is -very- depressing.
13:03:30 <Darius> I might just have to go out and buy the book.
13:03:47 <Lor> That's probably the purpose of the crippled web version. :)
13:04:18 <Lor> Hm, when will attapl be out?
13:07:29 * Lor just got an evil idea: write a (very partial) scheme compiler thingy in Haskell, and then translate the compiler from Haskell to Scheme (so it can be used without extraneous dependencies).
13:08:04 <Lor> With TH compiling haskell to scheme should be pretty feasible, I think.
13:08:57 <Philippa> heh
13:09:03 <Philippa> I suspect TH is great for writing compilers
13:09:08 <wolfman8k> what is TH?
13:09:13 <Philippa> doing the reverse - translate an ADT into Haskell expressions
13:09:18 <Philippa> er, AST even
13:09:34 <Philippa> the way I see it, you can prolly do the monad transformer/modular semantics thing and everything
13:11:09 <Darius> Lor: I'm missing the goal... ?
13:11:24 <Philippa> wolfman8k: "Template Haskell" - you get to pass bits Haskell code to functions which can spit out new code
13:11:24 <Lor> The goal is to make a scheme thingy.
13:11:36 <Philippa> and be clever about it, no doubt
13:11:54 <Lor> When I'm designing it, I find that I'd really appreciate types and currying.
13:12:04 <Lor> So it would be more sensible to write in Haskell.
13:12:11 <Lor> But it needs to be usable from scheme.
13:12:17 <Darius> Ah
13:12:27 <wolfman8k> Philippa: hm... how is that better then high order functions?
13:12:47 * Darius feels like making a language of hylomorphisms (which is probably what HYLO was (is?))
13:13:04 <Philippa> wolfman8k: it happens at compile-time, and it can include things like new types
13:13:23 <wolfman8k> hm.... sounds good i guess
13:13:25 <Philippa> and it can introspect the code passed in
13:13:38 <Philippa> basically it gets the AST of the code you pass it
13:13:46 <Philippa> and spits out a new AST which is spliced into the program
13:13:51 <wolfman8k> so it's like macros?
13:13:56 <Philippa> yup
13:13:59 <Lor> Yeah, macros for Haskell.
13:14:08 <Philippa> only the macros are written in full Haskell
13:14:21 <Lor> No different from lisp or scheme.
13:14:21 <Philippa> including, and this is evil, access to the IO monad
13:14:26 <wolfman8k> cool. nemerle is a functional language with a sweet macro system
13:14:39 * Philippa laughed like crazy when she saw that bit
13:15:05 <wolfman8k> yeah, lisp is funny :P
13:15:13 <Darius> Hey, can anybody think of a language less (statically) compilable than postscript?
13:15:17 <Lor> What was the idea with IO?
13:15:22 <Lor> darius, sh?
13:15:36 <Philippa> Lor: you can do things like load files for extra info - I can think of a few places where that has applications
13:15:54 <Philippa> were this a decade back, compiled sprites might be one
13:15:59 <Lor> There should at least be a compiler option for disabling IO during compilation.
13:16:01 <Darius> What would be difficult to compile about sh?
13:16:04 <Philippa> yes, there should
13:16:40 <Lor> Darius, expansion is done at every conceivable stage.
13:18:05 <Darius> I'll have to think about it; it might tie.
13:18:41 <Lor> I suspect that the problems are pretty much the same as with postscript.
13:18:50 <Darius> (and tack on "reasonably efficiently" for a very vague definition of reasonable... and efficiently to my original question)
13:19:00 <Darius> Lor: Me too, which is why I say tie.
13:20:09 <Darius> Except that the "standard" primitives are a bit low-level (nothing a little library coding couldn't fix), postscript seems to be a reasonably nice language.
13:36:49 <Darius> Off to linux world
13:39:58 <Lor> Hm, it would be convenient to be able to name auxiliary types within a type definition...
13:40:56 <Lor> data Foo a b c = Foo a | Bar b c x | Baz [x] where type x = Either b (a,c)
13:41:00 <Lor> Or something like that.
13:52:38 <dblhelix> Lor: well, it would perhaps indeed be a nice syntactic feature, but of course nothing more than that; I'd much rather welcome local type definitions
13:55:38 <Lor> A real module system would of course be the answer to both problems.
13:56:20 <dblhelix> have you read oleg's post on emulating first-class modules in Haskell?
13:56:58 <Lor> Only very quickly. I should probably have another look at it.
13:57:01 <Lor> Thanks for reminding.
14:25:53 <CosmicRay> Is it true that there is no way to say type CPResult a = MonadError CPError m => m a in hugs, save having to duplicate MonadError CPError m in the type declaration of every single function that returns a CPResult?
14:26:01 <CosmicRay> (that is valid in ghc, btw)
14:26:14 <CosmicRay> I can't figure out how to make hugs like it
14:27:17 <Riastradh> Try this:
14:27:28 <Riastradh> type CPResult a = forall m. MonadError CPError m => m a
14:27:42 <Riastradh> I don't know if Haskell supports rank-2 polymorphism, however.
14:27:47 <Riastradh> ...er, Hugs, even.
14:28:06 <CosmicRay> hmm.
14:28:08 <CosmicRay> that continues to work in ghc
14:28:14 <CosmicRay> but with hugs: Syntax error in type expression (unexpected keyword "forall")
14:29:00 <CosmicRay> according to http://cvs.haskell.org/Hugs/pages/users_guide/quantified-types.html, that *should* work
14:29:04 <CosmicRay> I can't figure out why it doesn't
14:30:32 <CosmicRay> and I am running hugs with -98
14:45:42 * shapr boings
14:45:57 <shapr> Darius: er, is that really you?
14:46:03 <shapr> wow!
14:46:07 <shapr> Darius: hiiiii!
14:46:22 * Darius quickly checks...
14:46:26 <Darius> Yes! I'm me!
14:46:40 <shapr> Darius: hey, I heard rumors that you won a prize in computing :-)
14:47:15 <shapr> Darius: It's nice to see you again! What's going on?
14:48:32 <Darius> Not much.  With any luck I will disappear again fairly soon, then reappear more permanently in hopefully not too long a while.
14:48:56 <Darius> As for winning an prize in computing, it depends on when... but I'm thinking you have someone else.
14:48:58 <shapr> That's good to hear, I wondered what happened to you. I sent an email or two your way.
14:49:24 <shapr> Did you win a prize in computer science in high school?
14:49:24 <Darius> I imagine.
14:49:54 <Darius> I haven't had Internet access (or a land line) since I disappeared.
14:50:11 <shapr> Well, I hope you had enough research papers to keep you from being bored.
14:51:01 <Darius> I went to the library and got books and laboriously downloaded research papers a floppy (or rathr 8) at a time.
14:51:36 <shapr> Truly, I look forward to your permanent reappearance.
14:51:46 <shapr> Man, that must have been rough.
14:51:53 <Darius> I also finally organized my papers.  I got a bit into DBs and full text indexing and made a little full text index of the papers I had.
14:51:56 <shapr> Speaking of which, do you write notes in the margins of your research papers?
14:52:20 <shapr> I've been hacking up a neat app that lets you share your margin notes with others, "Fermat's Last Margin"
14:52:21 <Darius> Which last time I looked was 1200+ and has probably added another hundred ish this week.
14:52:33 <shapr> Yow, that's a lot.
14:52:49 <thebug> @yow
14:52:49 <lambdabot> Is this where people are HOT and NICE and they give you TOAST for
14:52:49 <lambdabot>  FREE??
14:53:17 <shapr> lambdabot: probably not.
14:53:17 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
14:53:30 <Darius> Most of my research papers (and in fact virtually everything I have related to programming) is in digital form only.
14:53:38 <thebug> lambdabot strikes again!
14:53:52 <shapr> Mine too, that's why I thought of FLM. Because I can't make decent margin notes on digital papers.
14:53:57 <Darius> I own all of two hard copy computer books.
14:54:19 <shapr> Here's the napkin mockup - http://www.scannedinavian.org/RandomWiki/AnnotationMockup
14:54:28 <Darius> Yeah, you were talking about that for quite some time, and it did and does sound like a pretty cool idea.
14:54:39 <shapr> I'm using Flippi and darcs to make it happen. It's nearly done even.
14:54:49 <Darius> Oh, and yes I won a prize and a half in high school.
14:55:13 <shapr> Nice, what did you submit to get 1.5 prizes?
14:55:16 <Darius> I should probably get darcs now.  I imagine the win32 version is load-and-goable now.
14:55:36 <Darius> I got 1st place in one case and honorable mention in the other.
14:55:37 <shapr> All except for flaky MAPI support, it is.
14:56:12 <Darius> Hey, shapr, what's the current highwater mark for #haskell occupancy nowadays?
14:56:22 <shapr> Best I've seen in the last few days is 108.
14:56:39 <shapr> oh, hey. it was 116 a minute ago.
14:56:40 <shapr> wow
14:57:12 <shapr> That's definitely the all-time highwater mark so far.
14:57:50 * shapr hops cheerfully
14:58:22 <shapr> Does this mean you can index ps and pdf files somehow?
14:58:29 <shapr> I would very much like to do that.
14:59:21 <shapr> Several other people have asked me for the same sort of software, but I don't know of any.
14:59:22 <Darius> Unfortunately no.  I used pstotext and pdftotext to do it.  Taking head -n 1 of pdftotext go me ~200 out of 500 titles, but I just enter titles in manually now.
14:59:31 <Darius> I want to know what citeseer does.
14:59:43 <shapr> Yah, that would be nice.
14:59:52 <shapr> I wonder if they publish their data in a usable format?
15:00:12 <Darius> With some HTML scraping one should be able to get bibtex
15:00:43 <shapr> Seen scholar.google.com ?
15:01:04 <Darius> Unfortunately, the problem is that you start with ps/pdfs and don't know (programmatically) what they are.
15:01:08 <Darius> shapr: not yet
15:01:52 <derelm> hmmpf, i have a list [-15,15] and a resolution 0.00002. now i want to create a list containing all the elements between the values of the first list with the given resolution. i tried [(head list),((head list)+resolution)..(tail list)] but that doesn't really work
15:03:09 <shapr> derelm: the stepwise stuff works for Integers that I'm sure of, you could use an integer step and just divide by the power of ten to get what you want.
15:03:45 <derelm> typeing it with absolute values in the interpreter works
15:04:07 <Darius> You could use takeWhile and iterate.
15:04:21 <shapr> that would be easier.
15:04:31 <derelm> ah
15:04:36 <Darius> But yes, [ .. ] uses Enum instances and they don't do the intuitive thing with fractional values.
15:04:49 <atwood> re: citeseer, looks like they do publish their metadata: http://citeseer.ist.psu.edu/oai.html
15:05:15 <shapr> atwood: mmm, thanks!
15:05:27 <shapr> This could be reallly useful for FLM.
15:06:03 <shapr> Darius: written any nifty code during your sabbatical?
15:06:49 <shapr> yow, I wonder how large oai_citeseer.tar.gz is...
15:07:00 <Darius> Besides the full text indexer thing, which is rather standard.  I got pretty far in a program that could analyze waveform data (WAV/MP3/OGG) and produce midi.
15:07:15 <shapr> That is nifty.
15:07:30 <shapr> Does it also produce midi instruments to fit the events its found?
15:07:31 <Darius> It actually worked almost perfectly for one file, but for most it was less than useable.  I'm thinking about going at it again with wavelets.
15:08:13 <Darius> shapr: No, I just wanted something that could tab music.  I wasn't too concerned about exact reproduction of the sound.  cp achieves that better.
15:08:25 * shapr snickers
15:08:46 <shapr> So, your music career is also continuing?
15:09:00 <Darius> Any way, as a hobby guitarist and after hearing some MIDI "bend" effects.  I'd be scared to try.
15:09:19 <basti_> midi bend is non-standardized.
15:09:21 <Darius> To the extent that it ever was.  I don't expect to ever cease playing guitar.
15:09:29 <Darius> basti_: And ugly to boot.
15:09:42 <basti_> it plainly sucks.
15:09:57 <Darius> Though I'd be mildly interested in getting my guitar to sound like a slide whistle.
15:10:05 <basti_> im trying to get "wired" to work (freeware linux sound editing project)
15:10:09 <shapr> I bought a Shure 55SH Series II microphone for my woman for her birthday. I think I have to learn either the harmonica or the drums so I can do backup.
15:10:17 <basti_> try a "bottleneck"
15:10:21 <derelm> takeWhile (<= 15) (iterate (\x -> x+0.2) (-15))
15:10:21 <derelm> [-15.0,-14.8,-14.600000000000001,...
15:10:25 * Darius played with Audacity a fairly long time ago.
15:10:49 <shapr> Oh, haskore has support for infinite compositions now. And the music datatype has gotten spiffier, though more complicated.
15:11:18 <basti_> wired looks like it could replace cooledit or even buzz some day.
15:11:19 <Darius> I have some slides, but I'd have to play with them again to see how close to slide whistle they sound.
15:12:33 <shapr> too bad midi doesn't support infinite compositions, I still can't listen to a lorenz fractal.
15:12:43 <Darius> And I'd like to be able to do it without slides; as with most things I'm a bit luddite/first-principles kind of person.  When I can tremolo (finger)pick I would almost be able to throw a pick away.
15:12:51 <basti_> plus, if it would work, it would be a favourite dsp playground for me
15:13:23 <Darius> takeWhile (<= 15) $ iterate (+0.2) -15
15:14:02 <monochrom> derelm: 0.2 is inexact in the usual floating point representation.
15:14:14 <shapr> derelm: of course, if you use the integer math and then divide by the power of ten, you don't have those floating point problems.
15:14:24 <Darius> ack, I guess (-15) is necessary.  One of the few syntactic warts of Haskell.
15:14:33 <derelm> ah, thats what you ment in the first place
15:14:59 <shapr> Neat, I just got "We'll keep your resume on file" from galois.com
15:15:13 <Darius> shapr: Cool
15:15:27 <Darius> Response to your Haskell(-Cafe) post recently?
15:15:32 <shapr> Yah, maybe I'll get lucky and they'll have some contract work.
15:15:51 <Darius> shapr: Also, anything new and interesting with lambdabot in the past long time?
15:16:08 <shapr> Nah, I sent my resume to all the Haskell companies. I figured if I hadn't done that yet, I wasn't even trying to get out of Python coding.
15:16:42 <shapr> Of course, I specified telecommuting from Sweden, and working through my existing company.
15:17:01 <wolfman8k> so what's the deal with lisp?
15:17:07 <shapr> What about it?
15:17:13 <wolfman8k> is it good or evil?
15:17:27 <shapr> It's neat, but Common Lisp users leave a bad taste in my mouth so far.
15:17:32 <Lemmih_> Darius: Well I've hacked a Hackage module but it's not really new anymore and it's not really interesting until Cabal and Hackage becomes a big part of the Haskell community.
15:17:53 <basti_> emacs is good.
15:18:12 <shapr> wolfman8k: lisp has lots of things that make it cool, truly. It's worth knowing.
15:18:13 <wolfman8k> someone should make a haskell based emacs clone
15:18:17 <shapr> hmmm
15:18:22 <basti_> lisp has macros.
15:18:28 <shapr> http://www.cse.unsw.edu.au/~dons/yi.html
15:18:32 <shapr> wolfman8k: see that url? =)
15:18:37 <basti_> thats like #define for intelligent people
15:18:55 <shapr> Darius: I can't actually remember what new stuff has happened with lambdabot
15:19:02 <Darius> Yeah, back when I was checking newsgroups, sometimes I was having a hard time not unsubscribing from c.l.l.
15:19:10 <shapr> Darius: oh oh, EvalModule breaks with 6.3 and I don't remember the details of why.
15:19:29 <wolfman8k> shapr: cool... but no screenshots :)
15:19:42 <shapr> hmm, I should make some screenshots.
15:20:04 <shapr> Using the Darius captioning technique of course.
15:21:05 <shapr> Darius: dons is the author of hs-plugins, which is the successor to ozone's RuntimeLoader and Hampus Ram's SmartLoader. hs-plugins is now very cool.
15:21:21 <shapr> hs-plugins is used in Yi, and I am relatively sure that Yi is now more dynamic than emacs.
15:21:50 <Darius> What you mean it has dynamic scoping?! Yarghh!
15:21:58 * shapr snickers
15:22:10 <wolfman8k> someone should make a haskell operating system or something with a haskell shell :) programs will be haskell functions
15:22:15 <Riastradh> What do you mean by 'more dynamic,' shapr?
15:22:16 <Darius> hOp
15:22:37 <shapr> http://www.cse.ogi.edu/~hallgren/House/
15:22:46 <blackdog> can you give ghci or hugs a program on the command line?
15:22:58 <shapr> there's ghc -e
15:23:03 <Darius> And Clean has a pretty cool shell thingy as a demo for it's dynamics support.  I'm not sure how fleshed out if at all it is though.
15:23:38 <shapr> House is a derivative of hOp, with the downside that Gadgets (the gui bits) is only for academic use :-(
15:23:59 <shapr> blackdog: ghc -e lets you execute a string of Haskell source
15:24:42 <blackdog> yep, just checking it... works like a dream. thanks.
15:24:47 <Riastradh> shapr, what do you mean when you say 'Yi is more dynamic than Emacs?'
15:25:03 <blackdog> always nice to be able to dump a line of haskell in a shell script, just to confuse your fellow employees. :)
15:25:16 <wolfman8k> hm... House has some sweet screenshots
15:25:22 <monochrom> heh heh heh heh heh
15:26:07 <shapr> Riastradh: emacs core requires gcc usage to rebuild and manual shutting down and restarting to get back to where you were, assuming you're already using desktop.
15:26:18 <shapr> Yi has :reboot for when you're editing Yi core with Yi itself.
15:27:06 <shapr> Riastradh: does that sound more dynamic to you?
15:28:00 <Riastradh> Not quite, unless you mean something other than what I think you mean by 'core.'
15:28:51 <Riastradh> Emacs's core is an entire Lisp implementation; Yi's is only an editor basis.  If you edit the Haskell implementation underlying Yi, would you have to rebuild stuff and manually restart?
15:29:35 <shapr> Only if you're editing the GHC runtime system.
15:30:13 <Riastradh> What about the compiler?
15:30:41 <shapr> But you could easily write a new UI binding, maybe OpenGL, and do :reboot to start using it immediately.
15:30:58 * shapr thinks about that.
15:31:55 <shapr> It depends, if your GHC edits sufficiently change the structure of .hi or .o files, then you'd have to completely shutdown and rebuild Yi.
15:32:35 <shapr> If you don't affect the .hi or .o file format, I don't think you'd need to edit hs-plugins either.
15:33:40 <shapr> but, if it's a 'pure' change, it shouldn't matter.
15:34:26 <shapr> Riastradh: what do you think? more or less dynamic?
15:35:29 <basti_> ihr habt doch alle gelitten ;)
15:35:42 <shapr> waruum?
15:35:47 <shapr> ich habe keine ahnung!
15:36:00 <basti_> :P
15:36:03 <Riastradh> I dunno; I haven't looked into Yi enough to tell.
15:38:22 <shapr> I think elisp would need a real FFI to be as dynamic as Yi. Part of the problem is that elisp bindings happen in C.
15:38:55 <shapr> Otherwise xemacs-gtk and emacs-gtk wouldn't have been so difficult.
15:39:41 <shapr> Of course, if the elisp implementation were cleaned up enough that people could add an FFI, a lot of the warts of emacs would be gone already.
15:39:55 <shapr> anyway...
15:40:19 <WilX> Maybe that's why there is Scheme :)
15:40:25 <WilX> (I don't use either.)
15:40:28 <WilX> (Well, not much.)
15:45:30 <shapr> hoi jyp
15:45:37 <jyp> hoi
15:45:37 <shapr> er, salut jyp :-)
15:46:13 <jyp> Just lurking a bit ;)
15:46:32 * shapr tries to lurk too
15:47:13 * Darius finally remembers question to ask Pseudonym... of course he isn't here right now.
15:47:20 <shapr> you could use memoserv
15:47:25 <shapr> or send him an email.
15:47:58 <Darius> It's more of a discussion thing than a question.  I mostly just want to know what he thinks about something.
17:00:42 <blackdog> shapr: you couldn't lurk on the lurkingest day of your life with an electrified lurking machine.
17:02:25 <Lemmih_> ^_^
17:10:05 <stepcut> my coworker was disappointed I did not get his joke about aleph one :(
17:10:51 <heatsink> what was the joke?
17:11:41 <stepcut> heatsink: Did you see that Brian just uploaded aleph_one? I don't think we have room for it in the warehouse... (aleph_one is a 3d game...)
17:11:56 <heatsink> oh, heh
17:12:45 <stepcut> He made me read some tutorial on infinity :(
17:14:04 <heatsink> I might have missed that too. But it's just a risk one has to take when tellng a joke.
17:15:23 <heatsink> Is the joke funny yet?
17:15:25 <heatsink> No?
17:15:36 <heatsink> Read some more.
17:15:52 <monochrom> heheheh
17:15:53 <stepcut> Well, I understand it now, but that does not make it any funnier :)
17:16:16 <heatsink> yea, you have to read it before you hear the joke.
17:16:30 <monochrom> The warehouse has cardinality c, which is at least as large as alphe_one, no?
17:17:16 <stepcut> it was extra confusing, because there is another guy with the same name as me, whose job involves fixing the warehouse when some uploads something that is too big, so I thought it was just a misdirected IM :)
17:17:45 <monochrom> I would worry about the next major version, aleph_two.
18:36:03 <CosmicRay> shapr: y0
18:40:46 <CosmicRay> lambdabot: moo
18:40:47 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:40:55 <CosmicRay> lambdabot: @listcommands
18:40:55 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
18:40:55 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
18:40:55 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
18:40:55 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
18:40:55 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
18:40:56 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
18:40:58 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
18:41:00 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
18:41:02 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
18:41:06 <CosmicRay> lambdabot: seen shapr
18:41:07 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:41:15 <CosmicRay> lambdabot: @seen shapr
18:41:16 <lambdabot> shapr is in #haskell.se, #darcs and #haskell.
18:41:24 <CosmicRay> hmmphh..
18:41:36 <Darius> lambdabot: @seen lambdabot
18:41:36 <lambdabot> Yes, I'm here
18:41:51 <Darius> Dammit, I wanted to know where else you were.
18:41:59 <CosmicRay> @listchans
18:42:00 <lambdabot> I am on these channels: ["#Haskell","#darcs","#haskell","#haskell.se"]
18:42:05 <Darius> Ah
18:42:15 <CosmicRay> @fortune
18:42:16 <lambdabot> Menu, n.:
18:42:16 <lambdabot> 	A list of dishes which the restaurant has just run out of.
18:42:28 <CosmicRay> @yow
18:42:29 <lambdabot> This is my WILLIAM BENDIX memorial CORNER where I worship William
18:42:29 <lambdabot>  Bendix like a GOD!!
18:43:26 * Darius ponders about registering a LtU account.
18:44:20 <stepcut> is it cheating to use -fallow-undecidable-instances ??
18:44:24 * stepcut feels dirty
18:44:56 <Darius> It depends on what you are doing.  Though some people consider an undecidable "type system" not a type system.
18:48:45 <ozone> stepcut: -fallow-undecidable-instances is part of my everyday breakfast
18:50:42 * stepcut enables the option... for now
18:50:59 <Darius> Okay, are you sure you need it?
18:51:12 <stepcut> well, it won't compile without it :)
18:52:15 <Darius> And this is inherent to the problem?
18:52:48 * stepcut ponders
18:54:27 <stepcut> I believe that is my problem ... I don't know if I really need -fallow-undecidable-instances to solve the problem, I just know my current solution requires it to compile
18:59:18 <jadrian> question...
18:59:28 <jadrian> Just xid <- getLineEdited "var    > "
18:59:43 <jadrian> if null xid then return emptyFM
19:00:03 <jadrian>                else do ...
19:00:28 <jadrian> it never goes to the else...
19:00:38 <jadrian> any idea why?
19:00:55 <Darius> Sure, xid is always null.
19:00:55 <stepcut> xid is always null ?
19:01:25 <Darius> Oo,oo, or it doesn't terminate!
19:01:37 <jadrian> sorry, it never goes to the then...
19:01:51 <jadrian> exactly
19:01:54 <jadrian> doesn't terminate
19:02:10 <jadrian> because in the else I have a recursive call...
19:02:28 <Darius> Actually, depending on the monad it could terminate and still not reach either branch of the if.
19:04:06 <jadrian> err, never mind, it's working
19:04:10 <jadrian> weird
19:04:15 <jadrian> I just rewrote it
19:04:21 <jadrian> maybe I'm getting too sleepy
19:10:31 <Darius> "My proposal here could be seen as another way to reconcile the two (if you allow me to reconcile two parties by eliminating one);" A time honored solution if there ever was one.
19:14:57 <tautologico> reconcile who ?
19:20:20 <Darius> More of a what that a who in this case.
19:20:34 <Darius> True, that does go against the usual theme.
19:21:17 <tautologico> I imagined
19:21:27 <tautologico> nonetheless...
19:21:46 <Darius> Pattern matching and abstract data types
19:21:52 <tautologico> hm
19:21:54 <tautologico> paper ?
19:22:21 <Darius> First Class Patterns, Mark Tullsen
19:22:36 <tautologico> cool, I'll check
19:23:57 * Darius grumbles at the fact that there appears to be no way to get rid of a LtU account.
19:25:05 <tautologico> why do you want to get rid of it ?
19:25:11 <tautologico> if I may ask
19:25:32 <wagle> LtU?
19:25:37 <Darius> I don't necessarily, but I -do- want the option.
19:25:40 <tautologico> Lambda the Ultimate
19:25:42 <Darius> lambda-the-ultimate.org
19:25:45 <tautologico> oh, I see
20:10:00 <wagle> for shame!  ERROR message.hs:3 - Maximum token length (4000) exceeded
20:19:39 <monochrom> Hhahahahah
20:20:22 <blackdog> are you talking entish?
20:20:34 <blackdog> or just slurred hawaiian?
20:21:11 <wolfman8k> hehe
20:24:19 <wagle> really long string constant
20:32:25 <Darius> Hugs?
20:36:04 <wagle> ya
20:36:10 <wagle> ghci was happy
21:32:46 <blackdog> asd
21:32:53 <blackdog> bah. sorry.
21:38:03 <kristnjov> no harm done
21:46:19 <blackdog> @seen shapr
21:46:19 <lambdabot> shapr is in #haskell.se, #darcs and #haskell.
21:46:38 <blackdog> shapr: any idea how to kill a floating window in ion?
21:49:01 <wolfman8k> http://homepages.tscnet.com/wmunger/stickman37.jpg is controversial ;-)
