01:09:57 <vegai> is the ghc ebuild developer here?
01:19:40 <vegai> what do you make of this (trying to compile "Hello World" in ghc)
01:19:43 <vegai> /opt/ghc/lib/ghc-6.2/libHSrts.a(Main.o)(.text+0x28): In function `main':
01:19:43 <vegai> : undefined reference to `ZCMain_main_closure'
01:28:38 <Cale> and you have something like  main = putStrLn "Hello World"
01:28:46 <Cale> presumably?
01:29:45 <vegai> yes
01:30:13 <vegai> oh!
01:30:23 <Cale> hm?
01:30:36 <vegai> it didn't like my module-line
01:31:19 <Cale> ah
01:31:30 <vegai> shouldn't it?
01:32:02 <Cale> well, what does your module line look like?
01:32:29 <vegai> oh, it should be module Main.
01:32:36 <Cale> yeah
01:32:36 * vegai has been too long without writing Haskell.
01:37:00 <Cale> that error message isn't so great though
01:51:11 <bring> hi JaffaCake
01:54:04 <Cale> Simon Marlow?
02:00:52 <skew> vegai: It would be nice to understand the mangling
02:01:24 <skew> somebody who does should write a tool like c++filt
02:10:10 <hashwolf> where can i find some good docs/examples on haskell records?
02:11:55 <skew> hashwolf: it doesn't take a lot of docs.
02:12:09 <skew> the section of the report is probably sufficient
02:12:24 <skew> report/gentle introduction
02:13:02 <skew> it's just that you can name the arguments to a constructor, and then those names can be used as selector fucntions
02:13:39 <skew> also, you can create and update values using the record syntax
02:20:03 <hashwolf> hmm, i'll try that
02:22:10 <hashwolf> i haven't yet understoond what exactly a haskell record is though... for example is 'data Person = Person String String Int' a haskell record?
02:23:42 <bring> hashwolf: data Person {first_name::String,last_name::String,age::Int} is a record
02:23:53 <skew> they are almost the same thing
02:24:15 <bring> it's basically the same thing, but it also adds some syntactic sugar for creation, update and access
02:24:23 <hashwolf> skew: that's what got me confused
02:24:29 <skew> you can say Person "hashwolf" "the-lastnameless" 12 with the bring's definition, for example
02:25:11 <skew> you could also write Person {age=1, last_name="young", first_name="tim"}
02:25:17 <bring> but also Person{first_name="hashwolf",last_name="the-lastnameless",age=163}
02:25:24 <bring> :)
02:25:49 <hashwolf> 10x! :)
02:25:59 <skew> also, the record definition makes functions "age :: Person -> Int", and "last_name", "first_name" of type Person->String
02:26:05 <skew> which extract the corresponding field
02:26:36 <skew> also, person { age = 12 } will return a new Person like the old one, except 12
02:26:51 <skew> that's a new kind of expression
02:28:45 <hashwolf> "like the old one"? I haven't quite got that
02:29:22 <Cale> i.e. if person :: Person
02:29:37 <skew> it makes a new value where all the other fields are the same as in "person", but age is instead set to 12
02:29:44 <Cale> let tim = Person {age=1, last_name="young", first_name="tim"}
02:29:56 <Cale> tim {age=12} = Person {first_name = "tim", last_name = "young", age = 12}
02:30:26 <skew> and that concludes the record system
02:30:27 <hashwolf> ok got that too 10x
02:31:21 <skew> which is really just a bunch of syntactic sugar over the normal data types
02:31:43 <hashwolf> in 5 minutes in here i concluded more than in 1/2 hour of haskell lectures
02:34:54 <Cale> also, the derived instances for Show and Read will produce and consume record-style strings.
02:36:33 <Cale> "If the constructor is defined using record syntax, the derived Read will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration."
02:36:46 <Cale> something to watch out for
02:36:57 <skew> sounds like they didn't use a permutation parser
02:38:39 <skew> JaffaCake: do you know anything about ForeignPtr? Some code I've written with it is giving me segfaults
02:39:16 * skew checks if Simon was actually the one who implemented them
02:43:51 <JaffaCake> hi skew
02:44:03 <JaffaCake> yes I know stuff about ForeignPtr :-)
02:47:18 <skew> my code completes the finalizer, then segfaults
02:47:49 <skew> the finalizer also reports it was called on NULL
02:48:25 <skew> hmm. Is bad to make a ForeignPtr to null?
02:49:34 <JaffaCake> hmm, it shouldn't matter what the value of the pointer is, NULL should be fine
02:49:49 <JaffaCake> there were some bugs in the ForeignPtr implementation... which version of GHC are you using?
02:49:57 <skew> 6.2.1
02:50:07 <JaffaCake> that should be fine
02:50:49 <JaffaCake> can you compile the program with -debug, then run it with +RTS -Ds
02:53:32 <shapr> hi Simon!
02:53:39 <JaffaCake> hiya :)
02:54:04 <shapr> are you coming to EuroHaskell?
02:54:28 <JaffaCake> I'd love to, but with 6 month old baby it's kind of hard to travel these days
02:54:39 <shapr> oh, I understand that
02:54:53 <JaffaCake> hope you guys have a great time though
02:55:15 <shapr> yes, I think it will be lots of fun.
02:55:38 <JaffaCake> Isaac Jones was here last week... we did lots of stuff on the library infrastructure
02:55:46 <shapr> did you guys make progress on LIP?
02:55:53 <bring> shapr: maybe we should have a #eurohaskell where people who can't travel here can still join the fun
02:56:02 <JaffaCake> yup, got most of the design nailed down now
02:56:04 <shapr> I didn't heas anything from Isaac before he went camping
02:56:19 <shapr> cool! is the new design online somewhere?
02:56:26 <JaffaCake> he left Cambridge on sunday
02:56:33 <JaffaCake> I'll put it up - that's a good idea
02:56:46 <bring> would that mean that there might be some tasks that we could work on during EuroHaskell?
02:56:53 <shapr> bring: yes!
02:56:55 <JaffaCake> quite probably, yes
02:57:02 <bring> excellent
02:57:11 <shapr> yes, a sprint channel is a good idea
02:57:34 <bring> I'd love to get LIP usable
02:57:38 <shapr> me too
02:57:48 <bring> I'm tired of autoconf and make hacks
02:58:00 <shapr> then we could debianize znd winstall a lot of the time consuming stuff
02:58:04 <JaffaCake> won't be too far away, we planned to have something working  by the end of last week but didn't quite manage it
02:58:26 <shapr> I'd like to have debs of HaXml for example
02:58:30 <JaffaCake> 1st cut will use ghc --make for building
02:58:42 <JaffaCake> then we'll incorporate hmake into the build syste
02:58:51 <shapr> that's good to hear
02:59:39 <JaffaCake> I wrote a runghc, does anyone want to try it out?
02:59:50 <shapr> oh, I'd like to hear the details about dynamic linking
02:59:54 <shapr> I want to!
02:59:56 <bring> I'd like to
03:00:21 <bring> too
03:00:29 <JaffaCake> http://www.haskel.org/~simonmar/runghc.hs
03:00:51 <shapr> http://www.haskell.org/~simonmar/runghc.hs 
03:00:57 <shapr> missed an l
03:01:00 <bring> is anyone working on LIP for Hugs?
03:01:06 <JaffaCake> oops, thanks ;)
03:01:30 <JaffaCake> yes, we're targetting Hugs too
03:01:52 <JaffaCake> just the first prototype will use ghc, compiler independent after that
03:02:23 <shapr> oh, I have a question about dynamic loading, lambdabot had some problems passing values between the dynamic and static code
03:02:39 <JaffaCake> fire away
03:02:43 <shapr> I heard that's because of separate type tables
03:02:54 <JaffaCake> are you using Dynamic?
03:03:18 <shapr> do you think Template Haskell could solve that by running the program at the compile time?
03:03:30 <shapr> yes, Dynamic among other thing
03:03:49 <skew> JaffaCake: I've built a standalone example. I'll try -debug now
03:04:09 <JaffaCake> Dynamic uses a static hash table internally
03:04:20 <JaffaCake> if you dynamically load the base package, it will have a separate hash table
03:04:48 <JaffaCake> a Dynamic 'Int' from the dynamically loaded base package will not be visible as an 'Int' in the static code
03:04:49 <shapr> oh, is there a good way around that?
03:05:06 <JaffaCake> yes, we should fix the library ;)
03:05:28 <skew> "static" as in not exposed to the linker?
03:05:32 <JaffaCake> workaround: make sure you're only using the dynamically loaded code, or the static code
03:05:54 <shapr> we're using a finitemap of Typeable to save the state of the various lambdabot plugins
03:05:56 <JaffaCake> skew: yes
03:06:06 <JaffaCake> right
03:06:31 <skew> Oh. Real support for global mutable variables would help with this sort of thing
03:07:28 <JaffaCake> ah, there's one other thing you can do: link an HSbase.o with --export-dynamic, and link the program against that, then you don't need to dynamically link base
03:08:18 <shapr> so, it sounds like dynloading is perfectly typesafe then
03:08:38 <JaffaCake> well, maybe
03:09:16 <shapr> I think I read that GHCi loaded modules had separate type tables or something
03:09:20 <JaffaCake> I thiink it's a bit of a hack at the moment
03:09:58 <JaffaCake> shapr: no I don't think so
03:10:02 <shapr> one way to fix it might be to run a program at compile time with Template Haskell
03:10:04 <shapr> oh, ok
03:10:34 <shapr> ok then, I really could write an emacs clone in Haskell
03:11:06 <JaffaCake> not easy... you'd need access to GHCi from your program
03:11:27 <JaffaCake> we're planning to put an API on the front of GHCi so you could do this
03:11:40 <skew> great! I was just about to ask about that
03:11:59 <JaffaCake> I need it for Visual Studio, and several other folks want it too
03:12:06 <JaffaCake> we just need to design the API
03:12:18 <shapr> well, ozone wrote the Runtime Loader out of GHCi, and Hampus Ram extended that a bit to the Dynamic Loader that includes a Smart Loader that resolves deps
03:12:36 <skew> what about adding typeclass support to Dynamic?
03:12:37 <shapr> lambdabot is still using ozone's code with manual deps
03:13:08 <JaffaCake> right, if you don't need to actually interpret code at runtime, then you can use dynamic linking
03:13:40 <shapr> yah, we just run make and then @dyn-reload module
03:14:22 <JaffaCake> do the HSbase.o trick I mentioned to get the Typeables to work
03:14:50 <shapr> thanks, I'll try that after work
03:15:03 <JaffaCake> skew: what do you mean about typeclass support in Dynamic?
03:15:07 <skew> I know that would be rather non-trivial.
03:15:10 <shapr> oh, did you post the .so linking details somewhere?
03:15:28 <JaffaCake> I have some notes... I'll dig them out, hang on
03:15:38 <bring> how come ghc -e does not automatically load the all required source files (like ghci does)?
03:15:48 <skew> well, polymorphic values in general
03:15:51 <bring> or am I doing something stupid?
03:16:12 <JaffaCake> bring: ghc -e has a bug I discovered last week
03:16:25 <bring> ah
03:16:29 <JaffaCake> sorry :(
03:16:31 <skew> including the ability to dynApply a class member, and possibly extract an existentially typed package
03:16:39 <shapr> have you thought of using QuickCheckM for GHC testing?
03:16:45 <bring> it makes runghc somewhat less nice
03:17:08 <JaffaCake> shared library notes: http://www.haskell.org/~simonmar/shared-libs
03:17:15 <JaffaCake> bring: yes I know
03:17:28 <bring> :)
03:17:39 <bring> runghc is a great idea though
03:17:59 <shapr> yes
03:18:05 <JaffaCake> skew: I see, like Clean's dynamic types?
03:18:21 <skew> from what little I've read of Clean's dynamics, yes
03:18:43 <JaffaCake> I haven't thought about what would be required to made that work
03:18:57 <JaffaCake> s/made/make
03:19:35 <JaffaCake> shapr: re QuickCheckM, no
03:19:40 <skew> while you're around, what are all the -u GHCziRandonName options ghc uses in linking, and is there a better way to link Haskell code into a .so than grabbing the whole list from ghc -v?
03:19:57 <skew> that is, what is ghc using them for.
03:20:07 <JaffaCake> the -u options are forward references from the RTS to the base package
03:20:14 <skew> Ah.
03:20:25 <JaffaCake> needed because ordering is important in static linking
03:20:36 <skew> I played around with the order a bit and never quite got it fixed.
03:20:46 <skew> IIRC there were less unresolved symbols with RTS after base
03:20:55 <JaffaCake> yup
03:21:11 <skew> I'm playing around with compiling Haskell code into a .so the Python interpreter can load
03:21:26 <JaffaCake> that might be possible
03:21:41 <skew> it already works :)
03:21:48 <JaffaCake> hehe :)
03:22:06 <skew> at the moment I'm making .o files with ghc -c, then linking them with ld and linker options copied verbatim from ghc -b
03:22:08 <skew> er, ghc -v
03:22:23 <JaffaCake> yes, right
03:22:40 <JaffaCake> someone did a Python<->Haskell gateway a while back
03:22:46 <skew> I was wondering if I could persuade ghc to do the link for me, so I wouldn't need to mess around with the options (and change them with each GHC version)
03:22:56 <skew> really? other than me?
03:23:04 <JaffaCake> you tried -pgml? or -optl?
03:23:31 <JaffaCake> yeah, I believe Marcin Kowalzyk (sp?) was working on one
03:25:41 <JaffaCake> Gotta go do some work, nice talking to you guys
03:25:45 <skew> "Kowalczyk" apparently
03:25:56 <JaffaCake> yup, that's it
03:26:02 <skew> not seeing much on google
03:26:20 <JaffaCake> maybe he never released the code
03:26:22 <skew> I'll check out those linker flags, thanks
03:26:24 <JaffaCake> try emailing him
03:27:29 <skew> JaffaCake: how do I interpret -Ds output?
03:28:12 <skew> the code runs for a while, with lots of _ccall_gc but no finalizer output
03:29:27 <skew> until thread1 (ThreadRunGHC) gets a HeapOverflow, then there's something about creating a thread 2, and the first _ccall_gc there results in a finalizer call followed by a segfault
03:31:14 <JaffaCake> hmm, sounds like the -Ds output isn't really telling us much
03:31:39 <skew> I wonder why presumably dead ForeignPtrs survive so many gc calls, if that's what _ccall_gc is
03:31:59 <JaffaCake> no, _ccall_gc is a 'foreign import safe'
03:32:17 <JaffaCake> Do +RTS -Sstderr if you want to see GCs too
03:32:24 <skew> that explains why the are so frequent.
03:32:52 <skew> okay, the problem shows up at the first garbage collection
03:33:18 <JaffaCake> can you run it under gdb?
03:33:25 <skew> can I?
03:33:35 <JaffaCake> try it
03:34:04 <skew> apparently I don't have gdb installed (yet)
03:34:11 <JaffaCake> ah ok
03:34:18 <skew> I had assumed it wouldn't be too useful for Haskell code
03:34:29 <shapr> iirc, the zi -> . rewriting does limit module names slightly
03:34:29 <shapr> I think you can't dynload modules named with an initial Z or something
03:34:29 <shapr> Hampus mentioned that
03:34:29 <shapr> what sort of future plans do you have for GHC? how's the Cmm backend?
03:34:30 * shapr bounces
03:34:34 <JaffaCake> it'll tell us whether it is the GC or the Haskell code crashing
03:34:34 <shapr> I think the core rewrites . to zi
03:34:38 <shapr> if you dump Core on a hierarchic call you should see that
03:34:44 * shapr checks that
03:34:54 <shapr> man, I want a zsh completer for ghc
03:35:00 * shapr lags horribly
03:35:23 <JaffaCake> shapr: C-- backend is in progress (slow progress)
03:37:26 <shapr> any thoughts on a shared heap so GHC could use SMP?
03:44:01 <skew> hmm, now my sefault seems to be in the finalizer, before the "I'm done" printf
03:44:35 <skew> probably my bug then.
03:44:42 <skew> what should a traceback look like in gdb?
03:45:36 <skew> I've got PyDecRef (the finalizer), r3m1_info, then stuff GDB doesn't like, mostly nulls
03:47:41 <JaffaCake> skew: if the segfault is in the finalizer, you should be able to debug it by compiling the finalizer code with -g and using gdb
03:48:07 <JaffaCake> oh, unless it's Python I suppose
03:49:05 <skew> I should be able to work on it, now that it doesn't seem to be in such a mysterious place
04:02:55 * shapr boings
04:02:59 <shapr> oh, I'm also curious whether you plan on updating Speculative/Optimistic for ghc 6.x
04:03:22 <Lukhas> hello
04:03:57 <skew> -optl -shared is much nicer!
04:04:20 <skew> the command looks reasonable again!
04:06:28 <Lukhas> is there a place where i can find the recommended Haskell books for a real beginner ?
04:07:28 <skew> Lukhas: I've never read any Haskell books. I started with the Gentle Introduction and the Report
04:08:00 <Lukhas> i really need a paper book for some things, programming languages is one of them :)
04:08:11 <Lukhas> something to read far from your computer
04:08:21 <skew> There was one bit that I took a while to get, but I forget which
04:08:51 <skew> Well, I read the formal definition of the layout rule three times before I had it all
04:09:01 <Lukhas> hehe
04:09:44 <skew> maybe the bit on monads, but I'm thinking there was something to do with types that didn't make sense right off
04:10:09 <skew> \me really like this -optl -shared!
04:10:13 <skew> er..
04:10:24 <Lukhas> lol
04:10:32 <Lukhas> you windows user
04:11:33 <shapr> hey Lukhas 
04:11:33 <skew> any idea why building a program from some .o files would work fine, but turning some of them into an archive and linking against that would fail?
04:11:40 <Lukhas> hey shapr
04:11:54 <skew> Lukhas: windows user? trying to get ghc to pass -shared to ld?
04:11:55 <shapr> have you seen the stuff on thelearning page?
04:12:02 <shapr> @learn
04:12:02 <lambdabot> http://www.haskell.org/learning.html
04:12:03 <Lukhas> delYsid told me that you read some haskell books
04:12:05 <skew> shapr knows some books
04:12:45 <Lukhas> i found those, but i have to make a choice
04:12:59 <skew> My current computer has never been touched by windows. Even my "window" manager (ion) doesn't use windows :)
04:13:04 <Lukhas> hehe
04:13:21 <shapr> yes, I have both Thompson's "Haskell : The Craft Of Functional Programming" and Hudak's "The Haskell School Of Expression"
04:13:50 <shapr> Lukhas: imho, SOE requires a bit more math, and Craft doesn't
04:14:05 <shapr> I think SOE is generally more fun though
04:14:23 <Lukhas> define fun, for you :)
04:14:39 <skew> comonads and endofunctors, yum yum
04:14:48 <Lukhas> endo what ?
04:15:02 <shapr> thompson's book does stuff like max of three numbers, standard CS fare
04:15:11 <skew> I think SOE is more about pretty pictures, actuallty
04:15:22 <shapr> hudak's book does music, graphics, etc
04:16:11 <shapr> music and pictures is more fun for me
04:16:33 <skew> any idea why ld <somefiles> <libfiles> <morestuff> will work, when
04:16:40 <shapr> Lukhas: and there's lambdabot for fun code
04:16:44 <shapr> @yow
04:16:45 <lambdabot> My CODE of ETHICS is vacationing at famed SCHROON LAKE
04:16:45 <lambdabot>  in upstate New York!!
04:16:53 <Lukhas> shapr: let's learn the language before
04:17:04 <Cale> http://planetmath.org/encyclopedia/Endofunctor.html
04:17:11 <shapr> I tend to jump in with everything at once
04:17:53 <Lukhas> The thompson is avaible in 24h, Hudak's one in 1 or 2 weeks
04:17:55 <Cale> Of course, to actually understand that definition, you might have to explore the links a bit :)
04:17:58 <skew> ld <somefiles> <result of ar crs lib.a libfiles> <morestuff> fails
04:18:28 <shapr> Lukhas: and you can ask questions here too!
04:18:40 <skew> that is, gives like errors like "warning: type and size of dynamic symbol `__stginit_Modules_' are not defined"
04:18:44 <Lukhas> shapr: thanks :)
04:19:31 <Lukhas> the endofunctor definition is quite scary
04:19:55 <skew> it's just a functor from a category into itself
04:20:10 <skew> "functor" and "category" are the scary bits
04:20:14 <Lukhas> yeah
04:20:22 <Lukhas> i shouldn't have clicked on those links
04:20:33 <Lukhas> i still see some math symbols in my eyes
04:20:38 <skew> actually, "functor" is just a map of categories that respects the structure of a category
04:21:00 <shapr> so, you get out what you put in?
04:21:04 <skew> and "category" has a pretty simple definition, so it's not scary at all...
04:21:21 <skew> it's the set of examples that gets scary!
04:21:35 <shapr> so length isn't a functor unless it only works on length 1 lists?
04:22:00 <Lukhas> i have difficulties with the English math vocabulary
04:22:02 <skew> shapr: length isn't a functor at all
04:22:33 <skew> in Haskell you need a map on types and values to count
04:22:47 <shapr> Lukhas: pas de problem, nous avons un peu fran√ßais ici aussi
04:22:58 <skew> the "map into" meant "map onto a subcategory of"
04:23:11 <shapr> ocks√•, vi talar mycket svenska
04:23:21 <shapr> yay, lunch!
04:24:09 <Lukhas> shapr: bon appÈtit
04:31:02 <Lukhas> Thompson ordered
04:33:51 <Lukhas> thanks for your help :)
05:16:55 <shapr> :-)
05:22:47 <skew> any idea about the linker issues?
05:23:07 <skew> it turns out the static library works fine
05:25:08 <skew> I take a bunch of objects, link with ld -shared, then ghc with a -l option gives wierd linker errors about a few symbols from that library
05:26:15 <skew> hi shapr. I should think about breakfast soon...
05:26:26 <shapr> http://www.haskell.org/~simonmar/shared-libs
05:26:32 <shapr> did you already read that?
05:26:47 <skew> I did, but didn't think about it or apply it
05:27:20 <skew> I think that's exactly what I'm doing, except with ld -shared instead of gcc -shared
05:28:46 <skew> nope, using gcc instaed of ld (and the argument order there, rather then -o first) makes no difference
05:28:55 <skew> "warning: type and size of dynamic symbol `Objects_zdfPyValIO_closure' are not defined", etc.
05:29:14 <skew> I get a .so file that does work
05:29:36 <skew> er
05:30:12 <skew> up to putting the library .so file on the system include path
05:30:27 <skew> (so the python interpreter can find it when it loads the extension .so)
05:37:00 <hashwolf> say i have a haskell record like 'Myrec {set1::[Int],set2::[Int]}' is there a way to have set2 only have elements that are in set1 ?
05:37:53 <skew> that's orthogonal to the data type
05:38:20 <skew> but Data.List.intersect will take the intersection of two lists
05:38:50 <hashwolf> hmm, i'll have a look at that
05:39:10 <skew> you can't expose your type and prevent people from building their own, though
05:39:26 <skew> you can make the type abstract and ensure all access functions preserve the invarient, if you want to
05:39:51 <skew> there is no way to override the behaviour of the field accessors and record update syntax, if that's what you are asking
05:47:48 <shapr> I've never seen a mud in Haskell
05:52:11 <skew> I remember somebody talking about making Haskell bindings for an oddly-implemented mud
05:53:04 <skew> all the objects and other things were a bunch of files and directories, and the code was a bunch of little commands execed by the server
05:53:11 <skew> I don't remember the name
06:59:30 <shapr> hi gintas 
07:00:31 <l^rchkrn> shapr: Whats the URL of your Haskell CGI? I got to go yesterday and it vanished from my Firefox's history :-\
07:01:10 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
07:01:24 <l^rchkrn> shapr: Thanks.
07:01:36 <gintas> shapr: hi
07:01:37 <shapr> sure
07:01:55 <shapr> it's about 200 lines of code, took four evenings or so
07:01:58 <gintas> shapr: I just found out that there's such a thing as eurohaskell
07:02:23 <shapr> first thing I've done with either of HaskellDB or WASH, so it could probably be better
07:02:55 <l^rchkrn> shapr: Cool.
07:04:17 <shapr> gintas: are you in Europe?
07:04:45 <gintas> shapr: yeah
07:04:51 <shapr> whereat?
07:05:09 <gintas> shapr: Lithuania
07:05:21 <shapr> oh, nifty!
07:05:28 <gintas> shapr: I'll be in Europython2004
07:05:33 <shapr> oh cool!
07:05:40 <shapr> then you can just show up!
07:06:03 <gintas> well, I could
07:06:12 <gintas> but I don't think that would be of much use
07:06:17 <gintas> I just started looking at Haskell
07:06:28 <gintas> wrote some very simple stuff and that's it
07:06:48 <shapr> well, if you want to learn more
07:07:05 <gintas> I sure do
07:07:07 <shapr> then EuroHaskell would be great for you
07:07:22 <l^rchkrn> Why does the haskell site say "Haskell purely functional" when its not?
07:07:46 <shapr> it is
07:08:17 <l^rchkrn> A purely functional language would do nothing. Or at least wont be able to show what it done...
07:08:26 <gintas> shapr: I'm not sure I will have the time
07:08:35 <Lunar^> l^rchkrn: Is this a troll ?
07:08:41 <shapr> well, you can come for part of it
07:08:49 <gintas> shapr: yeah, it's worth a try
07:09:01 <shapr> l^rchkrn: really, it is, I promise.
07:09:48 <l^rchkrn> Lunar^, shapr: ?
07:10:13 <shapr> gintas: so, add yourself to the wiki page, with notes on when you can show up, yah?
07:10:23 <l^rchkrn> shapr: Okay I believe you.
07:10:58 <shapr> l^rchkrn: the difference is that the state is explicitly passed
07:11:07 <shapr> in C, it's not
07:11:26 <shapr> there are no globals in Haskell, not ever
07:11:29 <l^rchkrn> shapr: So i can differentiate purely functional sections from dirty ones?
07:11:47 <skew> l^rchkrn: all Haskell is referentially transparent
07:12:01 <l^rchkrn> skew: Monads are not, or are they?
07:12:21 <skew> that's the whole point of introducting them!
07:12:51 <l^rchkrn> Monads are referentially transparent?
07:12:52 <shapr> sounds like magic doesn't it?
07:13:10 <shapr> how can you be bure and have side effects too?
07:13:40 <shapr> you can just trust us, and use it
07:13:52 <shapr> but it's more fun to understand monads
07:13:57 <skew> (and don't use unsafePerformIO)
07:14:01 <shapr> so that you really see
07:14:15 <l^rchkrn> :-)
07:14:32 <shapr> I'd recommend getting familar with the pure parts of Haskell first
07:14:43 <l^rchkrn> so a do input <- readStrLn is referentially transparent?
07:14:48 <shapr> once you've got that, grab the nomaware tutorial
07:14:59 <l^rchkrn> shapr: Nomaware?
07:15:09 <shapr> I'll get the url...
07:15:13 <l^rchkrn> !type readStrLn
07:15:31 <skew> @type getLine
07:15:32 <lambdabot> getLine :: IO String
07:15:37 <skew> @type readLine
07:15:41 <l^rchkrn> :-)
07:15:53 <skew> @type readLn
07:15:53 <lambdabot> readLn :: Read a => IO a
07:17:33 <shapr> dang, looks like someone stole the nomaware DNS name
07:17:40 <shapr> I think I dl-ed a copy
07:19:11 <l^rchkrn> shapr: Well, I am currently digesting YAHT, so maybe monads are far away anyways. But thanks.
07:20:10 <shapr> sure, I'll find it and get back to you when I have a copy
07:20:17 <shapr> hiya tooki 
07:20:39 <l^rchkrn> shapr: Ok cool.
07:22:37 <tooki> howy ho
07:23:30 <shapr> I have too much random Haskell crap downloaded :-/
07:24:21 <shapr> I must organize
07:29:05 <tooki> has anyone made experiences with the 'clean' prog.lang.
07:45:31 <camio> Yeah, what is going on with Clean?  It claims to be really fast (unlike ghc and the likes) yet at the same time lazy.
08:05:50 <hashwolf> what is the ` used for in haskell?
08:06:27 <jesse> infix functions
08:07:36 <hashwolf> so if i declare somethih like add' :: Int -> Int i could use it like 1 add 2 ?
08:07:53 <jesse> you said `
08:08:05 <hashwolf> oh ok add`
08:08:10 <jesse> no
08:08:31 <l^rchkrn> hashwolf: like 1+2, but (+) 1 2
08:08:33 <ski> if you have a function  f :: A -> B -> C  for some types A,B,C
08:08:35 <jesse> but if you declare add normally, you can use it like 1 `add` 2
08:08:37 <ski> then you can say
08:08:45 <ski> foo `f` bar
08:08:55 <hashwolf> oh, 10x
08:09:10 <ski> (given foo :: A  and bar :: B.  then foo `f` bar :: C)
08:09:27 <hashwolf> (htis is my second day of haskell, i'm still VERY green)
08:09:37 <ski> ok :)
08:11:48 <hashwolf> i was aware haskell existed before these two days but two days ago I managed to understand that haskell can be used to code useful stuff - not just a glorified calculator :)
08:12:21 * ski smiles
08:17:38 * Smerdyakov can see it now: Haskell introduced in a paper with the title "Haskell: A new domain-specific language for glorified calculators"
08:18:49 <ski> haha
08:20:55 <eivuokko> Heh.
08:49:19 <shapr> @yow !
08:49:19 <lambdabot> I've got to get these SNACK CAKES to NEWARK by DAWN!!
08:49:56 <shapr> lambdabot is written in Haskell
08:50:02 <shapr> and it does cool stuff
08:50:11 <shapr> @seen SyntaxLaptop
08:50:12 <lambdabot> I saw SyntaxLaptop leaving #haskell 3 days 21 hours 2 minutes 40 seconds
08:50:12 <lambdabot> ago.
08:50:19 <shapr> @seen SyntaxNinja
08:50:20 <lambdabot> I saw SyntaxNinja leaving #haskell 4 days 16 hours 53 minutes 52 seconds
08:50:20 <lambdabot> ago.
08:50:33 <l^rchkrn> @seen SemanticsSamurai
08:50:34 <lambdabot> I haven't seen SemanticsSamurai
08:50:36 <shapr> hm, I need to turn down the autowrap
08:50:50 <shapr> that's his brother
08:52:11 <kosmikus|away> does this really work?
08:52:16 <kosmikus|away> @seen kosmikus
08:52:16 <lambdabot> kosmikus has changed nick to kosmikus|away.
08:52:16 <lambdabot> kosmikus|away is in #haskell.
08:52:32 <kosmikus|away> yay
08:52:44 <shapr> @seen shapr
08:52:45 <lambdabot> shapr is in #webwitches, #haskell.se, #haskell, #haskelldb and #joy.
08:52:53 <l^rchkrn> @seen me
08:52:53 <lambdabot> I haven't seen me
08:52:57 <shapr> whoa, I'm being spied upon!
08:52:58 <l^rchkrn> :-)
08:53:05 <l^rchkrn> @seen l^rchkrn
08:53:05 <lambdabot> l^rchkrn is in #haskell.
08:53:05 <shapr> @seen lambdabot 
08:53:05 <lambdabot> Yes, I'm here
08:53:08 <kosmikus|away> hmm, why does lambdabot list all these channels for you?
08:53:10 <shapr> haha
08:53:21 <shapr> kosmikus|away: I am in many places
08:53:32 <shapr> actuaaly, more than that even
08:53:45 <shapr> but lambdabot is only in that many
08:53:49 <kosmikus|away> @seen kosmikus|away
08:53:50 <lambdabot> kosmikus|away is in #haskell.
08:53:50 <shapr> @listchans
08:53:51 <lambdabot> I am on these channels: ["#Haskell","#haSKELLDB","#haskell","#haskell.se
08:53:51 <lambdabot> ,"#haskelldb","#joy","#webwitches"]
08:53:57 <shapr> huh
08:54:04 <shapr> interesting case there
08:54:11 <kosmikus|away> ah, okay, only channels lambdabot knows of ...
08:54:18 <l^rchkrn> 16:54 -!-  channels : #animescene #debian #haskell +#freenode 
08:54:49 <Smerdyakov> animescene?!
08:54:55 <Smerdyakov> Someone call the exterminators.
08:54:58 <l^rchkrn> Smerdyakov: #demoscene
08:54:59 <Smerdyakov> We have a fanboy infestation.
08:55:06 <shapr> hashwolf: one fun learning Haskell option is to write a lambdabot plugin
08:55:18 <shapr> I'm a fanboy.
08:55:36 <Smerdyakov> shapr, it takes a brave man....
08:55:47 <shapr> to...
08:55:47 <SamB> Smerdyakov: you do not like anime?
08:55:51 <shapr> run away?
08:56:05 <shapr> Akira! Tetsuo! Kanada!
08:56:16 <l^rchkrn> !dict fanboy
08:56:18 <l^rchkrn> @dict fanboy
08:56:19 <lambdabot> Supported dictionary-lookup commands:
08:56:19 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon
08:56:19 <lambdabot> @lojban @prelude @vera @web1913 @wn @world02
08:56:19 <lambdabot> Use "@dict-help [cmd...]" for more.
08:56:28 <l^rchkrn> @all-dicts fanboy
08:56:31 <shapr> probly jargon
08:56:34 <lambdabot> No match for "fanboy".
08:56:37 <shapr> huh
08:56:41 <shapr> surprising
08:56:41 <l^rchkrn> ?
08:56:54 <shapr> we need a local dict I guess
08:57:05 <shapr> I really want a wiki search plugin
08:58:24 <bring> shapr: at this rate will be 40 people at EuroHaskell
08:58:29 <shapr> whoa
08:58:50 <bring> I saw you recruited another one :)
08:58:51 <shapr> 20 listed
08:58:59 <shapr> yes!
08:59:14 <bring> we will get UNIX-accounts and network access for everyone
08:59:16 <Lemmih> What's EuroHaskell?
08:59:22 <shapr> and there's the possibility of Hughes, Claessen, Rante
08:59:29 <bring> @wiki EuroHaskell
08:59:30 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
08:59:42 <shapr> bah, you type faster than I do :-P
08:59:46 <bring> Lemmih: haskell hackfest i Gothenburg, June 10-12
09:00:03 <bring> shapr: aren't you using just one hand?
09:00:07 <shapr> yes
09:00:21 <bring> Lemmih: denmark?
09:00:26 <Lemmih> Yep.
09:00:30 <bring> just hop across the water
09:00:33 <shapr> but I'm up to touchtyping now
09:00:46 <bring> Lemmih: where in denmark are you?
09:00:46 <shapr> yah! come on over!
09:00:54 <Lemmih> bring: Copenhagen.
09:01:09 <bring> you'll be here in what, 3 hours on the train?
09:01:16 <bring> 4 maybe
09:01:27 <shapr> entrance fee is small
09:01:32 <Lemmih> I don't think I would fit in (-:
09:01:35 <bring> or 30 min on a plane
09:01:39 <bring> why not?
09:01:53 <bring> you don't like haskell or beer?
09:02:04 <jadrian> hello
09:02:04 <shapr> yah, we have old, young, experienced and not
09:02:10 <jadrian> hi shapr
09:02:11 <Lemmih> I love both (-: But I'm only 17 /-:
09:02:14 <bring> hi jadrian
09:02:15 <shapr> y0 jadrian 
09:02:19 <jadrian> hello bring!
09:02:26 <shapr> Lemmih: phubuh is younger :-P
09:02:33 <bring> Lemmih: I think we have a 15 year old signed up
09:02:38 <shapr> right
09:02:40 <Lemmih> Whoa.
09:02:47 * JaffaCake is fed up fixing GHC bugs
09:02:49 <jadrian> looking for a ghc extension I spoted a long time ago
09:02:57 <shapr> hi JaffaCake!
09:03:02 <shapr> jadrian: which one?
09:03:03 <JaffaCake> lo :)
09:03:07 <jadrian> on guards
09:03:13 <bring> JaffaCake: fix anything nice?
09:03:15 <jadrian> but all I can find is:
09:03:20 <shapr> yah, good fixes?
09:03:23 <jadrian> 7.3.2. Pattern guards
09:03:25 <jadrian> :-/
09:03:30 <jadrian> this was not the one
09:03:32 <bring> those are sweet
09:03:35 <JaffaCake> just boring stuff mostly, see msgs on the mailing lists
09:03:38 <jadrian> here is what I wanted to do 
09:03:42 <JaffaCake> also hacking on the back end
09:03:45 <shapr> what sort of extension was it?
09:04:03 <jadrian> f (x,y) | x == y  Nothing
09:04:08 <bring> Lemmih: if you want to come, sign up on the wiki page
09:04:09 <shapr> JaffaCake: you think QCm tests would be useful?
09:04:21 <jadrian>       |otherwise <now I want to use guards and pattern matching>
09:04:31 <JaffaCake> maybe
09:04:34 <bring> jadrian is that missing a =?
09:04:43 <jadrian> bring: yeap
09:04:47 <jadrian> f (x,y) | x == y  = Nothing
09:04:51 <shapr> nested guards?
09:05:07 <bring> can you give an example of what you would like to write on the second line?
09:05:16 <shapr> JaffaCake: any suggestions for community involvement?
09:05:18 <jadrian> shapr: exactly! I missed that word
09:05:33 <JaffaCake> in general, you mean?
09:05:38 <shapr> yup
09:05:47 <bring> jadrian, something like:
09:05:51 <shapr> or for GHC or whatever
09:05:52 <jadrian> bring: well I don't know the syntax for it... I wanted to do pattern matching on y for instance
09:05:58 <bring> f (x,y) | x == y = Nothing
09:06:00 <SamB> do you guys have any suggestions for what I should get with a $30 barnes & noble gift card?
09:06:24 <shapr> SamB: pragmatic programmer
09:06:27 <bring> f (x,(_:xs)) | length xs > 56 = Just "Foo"
09:06:33 <Smerdyakov> SamB, I would suggest not using it. Buying books when you have a convenient library is a horrific waste.
09:07:39 <bring> jadrian: if the first guard isn't true, it just goes to the next pattern
09:07:42 <jadrian> bring: yeap for that example that would be enough...
09:07:45 <shapr> hej forester 
09:07:59 <forester> shapr: hej
09:08:02 <jadrian> bring: let me try to think of a better one... :-/
09:09:11 <shapr> jadrian: could you use a worker wrapper in most nested guard cases?
09:10:01 <shapr> SamB: flatland; Godel, Escher Bach; Jonathan Livingston Seagull, Zen and the art of motorcycle maitenance?
09:10:35 <shapr> SamB: "Just For Fun" by Linus Torvalds and someone else?
09:11:10 <JaffaCake> re community involvement in GHC... we have a task list on sourceforge, but it's not that great
09:11:25 <JaffaCake> I need to come up with some more ideas for it
09:11:35 <JaffaCake> there's the feature request list too
09:11:53 <shapr> JaffaCake: oh hey, have you seen my mailing searcher? it's not very efficient or I'd suggest it for haskell.org
09:12:14 <JaffaCake> mailing searcher? no
09:12:24 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
09:12:44 <Smerdyakov> shapr, have you tried to reinvent text indexing without looking at the standard techniques? :D
09:12:50 <shapr> sadly, it's not very fast on a dual athlon
09:12:54 <JaffaCake> I have a bug report for you :-P
09:13:06 <JaffaCake> I hit return and it said "unspecified action"
09:13:17 <jadrian> shapr, bring: I was thinking about needing to do patter matching depending on propreties of arguments.
09:13:24 <shapr> yes, I really do need to fix that :-)
09:13:46 <jadrian> shapr, bring: but the ghc extension to guards I just found out also acomplishes that
09:14:04 <shapr> it's the same for unselecting all lists, it breaks
09:14:07 <bring> shapr: hmm, just noticed that if you leave the textfield empty, you get a "500 Infernal Server Error"
09:14:20 <shapr> yup, it has bugs
09:14:37 <shapr> lemme see if they're all in the TODO
09:15:01 <jadrian> shapr, bring: not trying to solve a particular problem though, just trying to recall extensions I once saw to use them when appropriate
09:15:03 <JaffaCake> we're going to need a centralised package repository for the LIP, there's a good project for someone
09:15:22 <bring> jadrian: so if the list has length > 42, pattern match out the first 2 or something like that?
09:15:58 <shapr> that would combine well with a freshmeat clone
09:16:11 <JaffaCake> yes, definitely
09:16:17 <bring> I'll add LIP stuff to the EuroHaskell wiki
09:16:25 <jadrian> bring: I was thinking something like, if length(x) > 42 then do some pattern matching on y, but I guess it's almost the same 
09:17:46 <shapr> that would go well at EuroHaskell
09:17:50 <shapr> for a sprint
09:18:30 <shapr> I can be coach for that one, unless someone with more WASH or HaskellDB experience wants to volunteer
09:20:08 <shapr> do we run sprints in paralell or serial?
09:21:46 <bring> jadrian: if I understand you correctly, pattern guards can do what you want:
09:21:53 <bring> f x | length x > 43, (y:ys) <- x = y
09:22:16 <jadrian> bring: yeap
09:22:36 <jadrian> bring: I didn't know this extension, just checked and it's enough
09:22:36 <bring> shapr: paralell, IMO
09:22:48 <shapr> ok
09:22:50 * JaffaCake likes pattern guards
09:23:07 <bring> we're so many people that serial would probably not work
09:23:22 <shapr> think we'll need separate rooms for each?
09:23:23 <bring> of course we could have a few in paralell and a few serial
09:23:56 <bring> I've been thinking about the room issue, I guess it'd be nice to be able to separate
09:23:59 <shapr> man it's hard to choose the freshcurry sprint over the hOp sprint
09:24:32 <JaffaCake> what's the plan for hOp?
09:24:36 <bring> but that there should be some central location where we can hang out and have nice noisy social coding sessions
09:25:03 <shapr> JaffaCake: wiki says get GHCi to work if possible
09:25:17 <bring> Lunar^ suggested that that should be the next thing
09:25:27 <shapr> Lunar^ is the man behind much of hOp
09:25:30 <JaffaCake> including readline? :)
09:25:31 <bring> + networking
09:25:45 <bring> I think they are working on something readline-like
09:25:49 <shapr> he has a minimal readline working that malcolm wallace wrote
09:25:58 <JaffaCake> right
09:26:35 <shapr> the NE2000 driver would be cool
09:26:52 <bring> chucky, forester or someone at chalmers, what are the group rooms on the 6:th floor like?
09:26:56 <shapr> writing a tcp/ip stack in Haskell would be a blast
09:26:56 <bring> can't remember
09:27:31 <shapr> JaffaCake: screenshot of the hOp readline here: http://etudiants.insia.org/~jbobbio/hOp/
09:27:44 <shapr> c'est tres chouette :-)
09:27:48 <forester> bring: there are like 6 computer on each row
09:27:52 <JaffaCake> nice, thanks
09:27:56 <forester> and about 4 or 5 rows
09:28:11 <forester> with one computer at the front, connected to the projector
09:28:15 <bring> that's ES6[1-3], right?
09:28:28 <bring> I meant the group rooms, along the corridor
09:28:32 <forester> if I remember correctly
09:28:36 <forester> ohh
09:28:53 <forester> that's another story
09:29:20 <bring> do bochs or qemu or anything that hOp runs under work on FreeBSD?
09:29:29 * shapr dunno
09:29:42 <bring> just thinking which machines to use for hOp hacking
09:30:02 <shapr> yes, qemu
09:30:24 <bring> we can just run it on one of the big linux servers and X-forward it if that's a problem
09:30:27 <shapr> yes, bochs
09:30:49 <shapr> both work on FreeBSD
09:31:08 <Lunar^> shapr, bring: I feel bad at the idea of having EuroHaskell sprint on my shoulders
09:31:15 <bring> we should make a list of things that need to be installed on the system
09:31:18 <Lunar^> I'm not really in stable mind these days
09:31:32 <shapr> Lunar^: no worries, we're adaptable
09:31:40 <Lunar^> k
09:31:44 <forester> don't the machines on floor 6 run sunOS?
09:31:54 <bring> forester: eh, maybe?
09:32:09 <bring> Lunar^: yeah, no pressure
09:33:39 <forester> at least those in the group rooms
09:33:57 <bring> the OS doesn't matter, as long as we can install all the stuff we want on one of the linux servers
09:34:10 <bring> eh, and hope it doesn't go down :)
09:34:12 <shapr> Lunar^: the primary goal is to show and have fun
09:34:25 <bring> exactly
09:34:27 <forester> bring: that's true
09:34:33 <bring> it's above all a social thing
09:34:37 <shapr> right
09:34:41 <bring> hacking can be done at home
09:34:48 <bring> but it's more fun together
09:34:52 <shapr> yes!
09:35:14 <bring> like most things in life
09:36:42 <shapr> there are antisocial programmers in the world, but I don't expect them to show up here
09:37:13 <bring> we can have a room where all the antisocial progrmmers can sit together
09:37:20 <bring> no, wait
09:38:09 <shapr> haha
09:42:32 <bring> Lunar^: does it matter which of bochs and qemu we get?
09:47:59 <shapr> I think this calls for unicycling!
09:48:04 * shapr disappears
09:48:13 <hashwolf> what is => in haskell called?
09:51:15 <Lunar^> bring: actually it works only with bochs
09:51:20 <bring> ok
09:51:38 <bring> exactly the kind of answer I was looking for
09:51:50 <bring> we'll try to install that then
09:52:17 <bring> I added a section for software requests to the wiki page
09:53:14 <bring> btw, I just assumed noone wants a Windows machine
09:54:31 <bring> that is, noone who doesn't bring their own
09:55:56 <bluejay> I am very confused by STArrays. "stStuff = runST (do s1 <- newSTRef 0; s <- readSTRef s1; return s)" works, but "stStuff = runST (do s1 <- newSTRef 0; s <- readSTRef s1; a1 <- newArray (0,4) 0; return s)" tells me that it can't "deduce (MArray a e (ST s)) from the context". I'm using ghc 6.2. What am I doing wrong?
09:56:32 <bluejay> (The only difference is the addition of "a1 <- newArray (0,4) 0;")
09:58:01 <bluejay> I'm using the strict STs because I saw something about STArrays not working with the lazy STs.
10:05:27 <bluejay> According to Data.Array.MArray's documentation, MArray (STArray s) e (ST s) is an instance, and it seems pretty obvious that's what it should be using...
10:12:33 <bluejay> I added an explicit type to it "(newArray (0,4) 0 :: ST s (STArray s Int Int))", and it worked... What's going on?
10:57:03 <shapr> w00, I amost freemounted
10:57:13 * shapr boings happily
10:57:31 <bring> what's that?
10:57:52 <shapr> getting on without holding onto a wall, pole, or other assistance
10:58:35 <shapr> I can get up, and make a revolution forward, but I didn't really get moving
10:58:49 <bring> sweet. are you bringing the unicycle to gbg?
10:58:58 <shapr> yes!
10:59:07 <shapr> you wanna learn? :-)
10:59:29 <shapr> well, I hope I can get it on the airplane...
10:59:45 <shapr> oh, I bet I can disassemble it and pack it
11:00:53 <shapr> once we have rooms worked out, we could add directions too
11:08:59 <bring> we know what building we're going to be in, and which part of the building, still not sure about which floor
11:11:39 <shapr> ok
11:15:13 <bluejay> I have to go... Did I ask wrong, or do you guys not know or not care?
11:15:38 <shapr> what?
11:15:40 <shapr> huh?
11:16:04 <shapr> bluejay: oh sorry, I was unicycling
11:16:42 <shapr> bluejay: could it be the monomorphism restriction?
11:18:06 <bluejay> I'm not very clear on what the monomorphism restriction does.. I set the type of 0::Integer because that's not in the list of instances of MArray STUArray..., but it didn't help.
11:18:53 <shapr> you said it worked hen you gave it the explicit type, right?
11:18:57 <shapr> "when"
11:19:00 <bluejay> yeah
11:19:48 <shapr> that implies that (MArray a e (ST s)) is the most specific type it could infer
11:20:16 <bluejay> When e is set to Integer, though, it ought to be able to infer farther.
11:20:19 <shapr> which part is the a there?
11:20:34 <bluejay> Should be (STArray s)
11:21:40 <shapr> how does setting 0 to Integer give enough type info to show that a is STArray s?
11:21:50 <bluejay> I'm looking at the list of instances at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html. The only one that matches "MArray a Integer (ST s)" is "MArray (STArray s) e (ST s)".
11:21:56 <shapr> can you paste the code into the paste page?
11:22:19 <bluejay> Where's the paste page?
11:22:54 <bring> @wiki HaskellIrcPastePage
11:22:54 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:22:57 <shapr> @wiki HaskellIrcPastePage
11:22:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:22:58 <bring> or something like that
11:23:09 * shapr grins
11:23:21 <bring> shapr: beat you to the @wiki again :)
11:23:23 <shapr> bring: so, you wanna try my muni? ;-)
11:23:34 <bring> munin?
11:23:39 <bring> Odin's raven?
11:23:48 <shapr> MUni - Mountain Unicycle
11:23:55 <bring> ah
11:24:01 <shapr> I have a nifty m√∂nster d√§ck
11:24:03 <bluejay> *pasting*
11:24:12 <bring> that'd be fun
11:24:16 <bring> I'll kill myself
11:24:51 <shapr> m√∂nster d√§ck --> http://www.scannedinavian.org/~shae/foto/shaecycle.jpg
11:25:09 <bring> funky
11:25:22 <shapr> munin is an excellent name for my next uni
11:26:29 <shapr> bring: it's not so hard if you hang onto a wall the first few times
11:27:12 <bluejay> ok, it's there.
11:27:37 <shapr> I see
11:28:10 <bring> shapr: that's what people say about perl too
11:28:19 <bring> ok, sorry, that was bad
11:28:35 <shapr> haha
11:29:02 <shapr> are you saying unicycling isn't typesafe? ;-)
11:31:16 <shapr> bluejay: what's getElems ?
11:32:15 <bluejay> It converts the MArray to a list so I can see that it's actually working. It's probably extraneous.
11:32:26 <shapr> ohh
11:35:29 <shapr> bluejay: have you tried it with :t in GHCi ?
11:40:44 <bluejay> hm, I don't know how to constrain it to be in the ST monad when calling :t
11:40:55 <maihem> hm, $ ghc-6.3.20040504 -o hgl hgl.hs      hgl.o(.text+0x25): In function `__stginit_Main_':     : undefined reference to `__stginit_GraphicsziHGL_'    etc
11:41:21 <shapr> maihem: you need to link with the HOpenGL lib
11:41:31 <maihem> how?
11:41:52 <shapr> if you know where it is, add it to the path with either -I or -i
11:42:09 <maihem> hm, this is the binary distribution
11:42:19 <shapr> of 6.3 ??
11:43:02 <maihem> yeah, you unpack, ./configure --prefix=<wherever> && make install
11:43:05 <shapr> bluejay: it's saying that getElems is causing the extra constraint, but I keep getting lost trying to puzzle through all the types
11:44:11 <maihem> for some reason, `which ghc` says my new /usr/local/bin/ghc, but `ghc --version` says the normal ghc debian package
11:45:02 <shapr> check your path, maybe symlinks are the problem?
11:45:38 <shapr> bluejay: I don't know :-/
11:45:41 <bluejay> (newArray (0,4) (0 :: Integer)) >>= \x -> (return::a->ST s a) x :: forall a, i, s. (MArray a Integer (ST s), Ix i, Num i) => ST s (a i Integer)
11:45:51 <bluejay> Is what ghc gives me
11:46:13 <shapr> GHCi also does Num defaulting
11:46:17 <shapr> y0 Marvin-- 
11:46:26 <shapr> so maybe that could help you?
11:46:45 <bluejay> ok, I'll just explicitly give it a type whenever I call newArray.
11:47:16 <Marvin--> evening
11:48:56 <shapr> Marvin--: hey, did you talk to Koen about EuroHaskell?
11:49:05 <Marvin--> no, haven't seen him for a while
11:49:06 <bluejay> thanks for trying
11:49:25 <shapr> bluejay: sure, have any easier questions? :)
11:49:57 <shapr> Marvin--: what's goin on?
11:50:19 <Marvin--> shapr: he's been ill
11:50:20 <Marvin--> and away
11:50:27 <Marvin--> meeting with him on Friday
11:50:30 <shapr> oh, rough
11:50:50 <Marvin--> what should I ask him? Just generally prod him about making an appearance?
11:51:03 <shapr> yes
11:51:31 <shapr> if he's interested he could show up and code with us of course
11:53:01 <bluejay> shapr: well... this probably isn't any easier: I'm using ErrorT, ReaderT, WriterT, and ST. What order should I nest them and how do I call the resulting object with runXxx? If there's an error, I don't care about getting any output.
11:53:34 * shapr screams and runs away
11:53:43 <bluejay> lol. Sry
11:53:56 <shapr> bluejay: you're right, I'm not much good with monad transformers
11:54:23 <bluejay> I'm strongly considering giving up on purity and just doing the whole thing in IO. (It's an interpreter)
11:54:39 <shapr> oh, you should check out @eval
11:55:01 <shapr> it uses monad transformers to get an extensible interpreter
11:55:10 <bluejay> where's it live?
11:55:27 <shapr> I saw a discussion about transformer order recently on haskell@haskell.org
11:55:50 <shapr> @eval (\x -> x + 1) [1,2,3]
11:55:51 <lambdabot> type error
11:55:55 <shapr> whoops
11:56:02 <shapr> @eval map (\x -> x + 1) [1,2,3]
11:56:03 <lambdabot> [2, 3, 4]
11:56:11 <Marvin--> bluejay: if you've got AT (BT (CT ...))   you need runC (runB (runA m)) ...  obviously
11:56:25 <shapr> yay, someone with clue
11:56:27 <Marvin--> just think of it as peeling them off one at the time
11:57:15 <shapr> anyway, lambdabot is on http://sf.net/projects/haskell-libs
11:57:27 <shapr> the 2.0 release benng the latest
11:58:18 <shapr> gutenabend pesco 
11:58:21 * Marvin-- has a WriterT on top of a StateT on top of a ListT on top of a StateT in his code
11:58:32 <Marvin--> there used to be a Reader there too, but I changed that to using implicit parameters
11:58:32 <pesco> N'Abend shapr.
12:00:43 <bluejay> how . . . fun
12:01:49 <shapr> pesco: wassup?
12:02:09 <bluejay> one last (for now) question: Is there any easy way to get something like a STRef in the StateT monad rather than ST?
12:02:15 <pesco> shapr: I got the last memleak out of my particle system.
12:02:29 <pesco> shapr: But I still don't grok how exactly it was holding on to memory.
12:02:41 <pesco> Maybe someone could help me clear that up?
12:02:59 <shapr> what's the diff?
12:03:17 <pesco> I added seq/deepSeq in various places.
12:03:52 <pesco> But all those values must have been evaluated eventually in any case. I think.
12:04:13 <pesco> Is it possible that the GC would miss them if the functions are not strict?
12:05:13 <Marvin--> bluejay: the right number of applications of lift :)
12:07:07 <bluejay> hehe, that's what I was trying to avoid. :-P
12:07:21 <bluejay> thanks for the help. :) I'll go stare at this stuff some more now.
12:09:11 <Marvin--> I guess you could define some sort of MonadST class to mirror the MonadIO class
12:09:22 <Marvin--> and have just liftST
12:15:09 <bring> @eurohaskell
12:15:09 <lambdabot> less talks, more code!
12:15:09 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
12:15:09 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
12:15:26 <bring> @karma shapr +5
12:15:27 <lambdabot> shapr has a karma of 0
12:15:36 * shapr grins
12:18:05 * Marvin-- is curious about how much the syntaxninja has been terrorising the Peyton Joneses with Go
12:19:17 <chucky> @karma- bring
12:19:17 <lambdabot> bring's karma has been decremented.
12:19:20 <SamB> shapr: thanks. My parents already had Zen and the Art Of Motorcycle maintenance, and I used a borders gift card to get Godel, Escher, Bach ;-)
12:19:45 <bring> @karma+ chucky
12:19:45 <lambdabot> chucky's karma has been incremented.
12:19:53 * bring turns the other cheek
12:20:06 <andersca> butt cheek?
12:21:12 <SamB> oh, and flatland. I'm almost positive I've read that; the only reason I'm not is this strange paranoia thing I have
12:21:37 <Marvin--> GEB rocks!
12:22:22 <SamB> so I'll look at pragmatic programmer, Jonathan Livingston Seagull, "Just For Fun" by Linus Torvalds
12:23:23 <ibid> i never finished geb
12:23:33 <ibid> lots of nice ideas but sloppy execution
12:24:05 <bring> the library wants my GEB back
12:24:11 * bring suspects hram
12:24:44 <maihem> fingers crossed: $ ghc -o hgl hgl.o /usr/local/lib/ghc-6.3.20040504/*.o /usr/local/lib/ghc-6.3.20040504/*.a /usr/local/lib/ghc-6.3.20040504/*.o /usr/local/lib/ghc-6.3.20040504/*.a
12:25:24 <SamB> oh, and Smerdyakov: if I don't use the gift card soon, they will start to take money out of the account
12:34:01 <shapr> SamB: yay!
12:34:23 <shapr> ibid: he cleans up stuff in the sequels
12:35:10 <shapr> SamB: those were just the first I could think of, I can come up with more if you want
12:35:45 <shapr> Marvin--: look at the new quote on QuotesPage for the answer
12:36:03 <Marvin--> shapr: that's what I was thinking of
12:36:08 <shapr> ah :-)
12:36:10 <Marvin--> shapr: but I wonder what the connection to FP is
12:36:47 <SamB> shapr: hmm, if you want me to take forever to pick, go ahead and give me more suggestions ;-)
12:36:56 * shapr grins
12:37:37 <shapr> pragprog is about craft, just for fun is about inspiration
12:39:59 <SamB> hmm, accents are a pain. apparantly you are supposed to spell it Goedel or G√∂del, not Godel...
12:40:25 <shapr> yup
12:41:50 <shapr> I want session support back in galeon :-(
12:42:59 <esap> back? did it have one?
12:43:10 <shapr> yes
12:43:14 <shapr> was great too
12:43:31 * esap has been using galeon for a long time and I never noticed.
12:44:18 <maihem> ha ha ha: ghc-6.3.20040504 -package HGL -o hgl hgl.hs
12:44:32 <ibid> shapr: sequels?
12:46:27 <shapr> yah, there are several I think
12:46:41 <shapr> GEB is from the 70s I think
12:47:29 <ibid> yes it is
12:47:36 <ibid> i wasn't aware of any sequels
12:48:56 <shapr> http://en.wikipedia.org/wiki/Douglas_Hofstadter
12:54:20 <shapr> oh, I wondered recently if Wolfram's universe as automata ideas are just a remake of Leibniz's monads
12:54:24 <vegai> I have Metamagical Themas, and it seems to be more like an independent work
12:55:26 <shapr> anyone have thoughts on leiniz' monads as cellular automata?
13:02:53 <esap> Have you all seen the criticism of Wolfram's book, which refutes many of his ideas about physics.
13:03:13 <shapr> pesco: hey, any advice on adding hierarchical support to @type ?
13:03:27 <shapr> esap: no, tell me more!
13:03:47 <esap> shapr: http://en.wikipedia.org/wiki/A_New_Kind_of_Science has some links.
13:08:40 <shapr> how does Hugs do hierarchical modules?
13:10:20 <shapr> hi FlamingRain
13:12:00 <FlamingRain> hello shapr
13:13:14 <Philippa> shapr: A.B.C gets looked for in A/B/C.hs IIRC
13:13:46 <shapr> how do I ask for a hierarchical type?
13:14:00 <l^rchkrn> Just like Python, they copied it from Haskell.
13:14:00 <andersca> la la la
13:14:08 <l^rchkrn> Module.Type
13:14:12 <shapr> :t Control.Monad.foldM -- works in GHC
13:14:12 <l^rchkrn> Nope?
13:14:24 <shapr> but not in Hugs, it seems
13:14:28 <SamB> hmm, maybe I need more suggestions. or maybe I should just use some of my own money and buy all three of those...
13:14:31 <Philippa> got it in pure 98 mode by mistake?
13:14:53 <shapr> neither of -98 nor +98 seems to do it
13:16:08 <SamB> hugs is a bit painful, I think
13:17:13 <Philippa> have to admit I stopped using it as soon as I realised GHCi existed
13:17:13 <Marvin--> some versions of hugs need +N to use the hierarchical libs I think
13:17:22 <shapr> oh
13:17:54 <Marvin--> but I think that's orthogonal to whether :t Control.Monad.foldM works
13:18:08 <Marvin--> you still need to add Control.Monad to the list of loaded modules, I think
13:18:10 <shapr> doesn't seem to help
13:18:45 <Marvin--> hugs +N Control.Monad  works anyway
13:19:29 <Marvin--> I have to admit that I mainly use ghci too :)
13:21:24 <shapr> so you think I have to start Hugs in the root of its libs to get hierarchical module support?
13:21:34 <Marvin--> no?
13:21:57 <Marvin--> hugs +N Control.Monad  looks in the directory list
13:22:15 <shapr> I mean :m with hierarchical
13:22:23 <Marvin--> hmm, I don't know what :m does in hugs
14:12:11 <jadrian> hmm weird, anyone using Xemacs with haskell?
14:12:22 <shapr> I have been in the past
14:12:51 <shapr> what's up?
14:13:16 <jadrian> sometimes the line number disapears...
14:13:37 <saz> the line number down the bottom?
14:13:40 <jadrian> yeap
14:14:02 <shapr> never seen that
14:14:03 <saz> you can bring it back by going to display->line no
14:14:11 <jadrian> it's on
14:14:13 <saz> but i've never seen it spontaniously disappear
14:14:26 <jadrian> guess I'll just restart Xemacs
14:14:27 <jadrian> eh
14:18:27 <jadrian> did you ever used Strategies?
14:19:34 <saz> what's that?
14:20:32 <jadrian> just a sec
14:22:13 <shapr> DrIFT?
14:22:40 <jadrian> http://users.aber.ac.uk/afc/stricthaskell.html#seq
14:22:44 <jadrian> there it is
14:24:08 <jadrian> shapr: I've read about DrIFT and Strfunski (sp?), but this is supposed to be a module included in GHC
14:24:27 <shapr> oh, maybe Data.Generics?
14:24:53 <maihem> The one truly great thing about haskell is that it doesn't miss a trick, the worst thing about haskell is that it doesn't miss a trick :)
14:25:22 <jadrian> shapr: not sure if it is the same...
14:26:10 <jadrian> shapr: I think some meta programming could be in order
14:26:39 <jadrian> shapr: not sure what could be more useful though, Strafunski, Generics, Template Haskell or this one...
14:26:56 <maihem> Using HGL (Haskell Graphics Library) to open a window and wait for a key event or a mouse button event, the terminal sends a return character to the shell before the key is released, and the window manager gives the focus to the new window, so the release of the return key is captured by my program and it terminates straight away
14:26:58 <shapr> for what?
14:28:03 <jadrian> shapr: I working with logics stuff, one way to implement my algorithms is to make the Connectives, Quantifiers and all Value Constructors 
14:28:33 <jadrian> shapr: but then again, many algorithms don't really depend on the constructor you have...
14:28:48 <shapr> oh, I don't know
14:29:50 <jadrian> shapr: I thought I'd check out this strategies modules but I cannot import it
14:30:38 <shapr> which module?
14:30:42 <jadrian> Strategies
14:31:24 <jadrian>  /usr/lib/ghc-6.2.1/hslibs-imports/concurrent/Strategies.hi
14:31:30 <jadrian> so should probably be
14:31:56 <jadrian> :module +Control.Concurrent.Strategies
14:31:56 <shapr> -package concurrent ?
14:32:22 <jadrian> hmm +Control.Concurrent works without that
14:32:25 <jadrian> but let me try
14:33:08 <jadrian> nah
14:33:29 <jadrian> didn't work
14:34:28 <jadrian> this seems to have some nice evaluation strategies that could be handy
14:35:01 <jadrian> anyway DeepSeq is enough for now
14:46:32 <wagle> shapr: is the programatica cvs still broken?
14:47:15 <shapr> I dunno, I sure can't get to it
14:47:21 <shapr> would like to though
14:48:04 <shapr> @type Control.Monad.foldM
14:48:05 <lambdabot> type: 
14:48:05 <lambdabot> foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
14:48:20 <shapr> andersca: jag fixar :-)
14:48:43 <andersca> jaa!
14:49:28 <shapr> wagle: you're in that area aren't you? think you can get me a copy?
14:50:23 <shapr> wagle: I assume it happened when cvs.haskell.org was cracked
15:00:01 <wagle> shapr: i cant get in either.  i fired off a note to facilities
15:00:15 <shapr> thanks
15:29:31 <yich> HSQL has a function "retrieveRecords", with a line: query c "select..." >>= collectRows getRows. I'm trying to figure out how to use HSQL... The function "collectRows" has type: "collectRows :: (Statement -> IO a) -> Statement -> IO [a]" and getRow has "getRow :: Statement -> IO (Int,String)"... if >>= has type signature Monad a => a b -> (b -> a c) -> a c, how is collectRow's type signature matching? 
15:30:36 <shapr> HaskellDB is saner, imho
15:30:55 <shapr> I used to use HSQL
15:30:59 * shapr thinks
15:32:19 <shapr> oh, type sig Q
15:32:39 <yich> thanks, I'll take a look.... in hsql. getRow's type signature almost matches >>=...
15:33:21 <shapr> most monadic types unwrap the monad in the privacy of their own home
15:33:25 <apoplex> hi
15:33:31 <shapr> hiya apoplex 
15:34:00 <shapr> yich: look at Maybe monad instance for a good example
15:34:49 <apoplex> question: i have a list with elemetns [1,2,3,..] and a funktion f.i need the code that do a f(x) with the 1st element, a f(f(x)) with the second etc...can anybody help ?
15:35:29 <shapr> scanr
15:35:35 <shapr> @type scanr
15:35:36 <lambdabot> type: 
15:35:36 <lambdabot> scanr :: (a -> b -> b) -> b -> [a] -> [b]
15:35:51 <shapr> @type scanr1
15:35:52 <lambdabot> type: 
15:35:52 <lambdabot> scanr1 :: (a -> a -> a) -> [a] -> [a]
15:36:17 <shapr> er, maybe that's not right
15:36:27 <shapr> @type iterate
15:36:28 <lambdabot> type: 
15:36:28 <lambdabot> iterate :: (a -> a) -> a -> [a]
15:36:52 * shapr is confusing himself
15:37:36 <shapr> you could combine zipWith and iterate (. f)
15:37:51 <apoplex> hm
15:39:54 <shapr> @type replicate
15:39:55 <lambdabot> type: 
15:39:55 <lambdabot> replicate :: Int -> a -> [a]
15:43:07 <skew> how about zipWith ($) (iterate (f.) id) elements
15:43:22 <skew> that does identity on the 0th element, f(x) on the first, etc.
15:43:23 <shapr> beat me to it
15:43:39 <apoplex> skew i do not understand, how to use it ?
15:44:03 <skew> do you know what zipWith and iterate do?
15:44:25 <skew> iterate (f.) id makes the list [id, f.id, f.f.id, f.f.f.id ...]
15:44:45 <apoplex> but iterate uses the last calculation
15:44:55 <skew> zipWith ($) [f0,f1,...] [x0,x1,..] gives [f0 $ x0, f1 $ x1, ...]
15:45:10 <apoplex> i have a list with indepentend itmes
15:45:16 <skew> sure. The first result of iterate (f.) id is the identity function
15:45:25 <skew> the next result is f composed with the identity, or just f
15:45:27 <skew> and so on.
15:45:31 <apoplex> [1,2,5] --> f(1) f(f(2))  f(f(f(5)))
15:45:37 <skew> I'm building up a list of functions f^0, f^1, f^2
15:45:43 <skew> then applying them with the zipWith ($)
15:46:25 <shapr> man, Haskell is much sexier than Python
15:46:29 <apoplex> hm could you give me the exact code ?
15:46:34 * shapr sighs happily
15:46:42 <shapr> apoplex: that is exact
15:46:50 <shapr> I just tried it
15:46:54 <skew> combining the whole thing, the result of zipWith ($) (iterate (f.) id) [x0,x1,...] is [id $ x0, f.id $ x1, f.f.id $ x2, ...]
15:47:28 <skew> the ciritcal thing here is that I'm defining a list of functions, then applying them, rather than trying to make the results in one go
15:47:36 <shapr> apoplex: are you learning Haskell for school, work, or fun?
15:47:43 <apoplex> school
15:47:46 <shapr> oh
15:48:05 <shapr> well, we can't give the answers to homework
15:48:15 <shapr> but we can help a little bit
15:48:32 <apoplex> i have one correct algorithm
15:48:42 <skew> of course, if you argument list is build by iterating some function you might be able to do getter. like [1,3,5,..] is built from iterating (\x -> x+2) on 1 (or just (+2) with slice notation)
15:48:42 <apoplex> but my code isnt very nice
15:48:53 <skew> do better, even
15:49:23 <skew> then the results you want are x0,f(g(x0)),f(f(g(g(x0))), ... for some f and g
15:49:43 <skew> and if those functions are sufficiently nice that might simplifyt
15:49:53 <skew> the simplest case being if f and g are inverses.
15:50:00 <monotonom> Haha
15:50:10 * shapr grins
15:50:32 <monotonom> If f and g commute, it can be very nice too.
15:50:40 <apoplex> the list contains random items
15:50:45 <shapr> I wonder if GHC does inverse detection
15:51:19 <skew> I doubt it, but you might be able to write a simplification rule.
15:51:30 <skew> I know there are some RULES f . finverse = id
15:51:31 <shapr> that could be part of any partial evaluation system, I guess
15:51:38 <shapr> ah, good point
15:52:18 <skew> if f and g commute then the result is just iterate (f . g) x0
15:52:42 <apoplex> is it posibble to use a counter ?
15:52:49 <shapr> nooo
15:52:52 <shapr> evil!
15:52:54 <apoplex> ;)
15:52:57 * shapr grins
15:53:00 <skew> it's possible, but not a good idea
15:53:06 <apoplex> i thought that
15:53:19 <shapr> that's procedural thinking
15:53:40 <skew> it's much simpler to concatenate another copy of f into the current function than to increment a counter, and conver the counter to a function
15:54:11 <skew> it's like \ftothek -> f . ftothek compared to
15:54:33 <skew> \k -> (k+1, mconcat (replicate (k+1) f))
15:54:42 <shapr> ick
15:54:53 <shapr> I like the shorter one more
15:55:05 <skew> and you only get it that nice if you remember that Data.Monoid has an instance for functions
15:55:12 <shapr> mmm, Haskell is so elegant
15:55:31 <apoplex> i do nut understand \ftothek ?
15:55:41 * shapr names his dog Mon Oid
15:55:49 <shapr> "hey mon, wassup?"
15:55:54 <skew> that's a lambda taking he current function to be applied
15:56:04 <skew> like, if you are at the third element of the list it would be f.f.f
15:56:13 <apoplex> thats whta i need
15:56:17 <skew> and it's supposed to return the function to be applied at the next
15:56:40 <apoplex> i do not find a command ftothek
15:57:04 <monotonom> \ftothek is not a LaTeX command.
15:57:09 <apoplex> hm im new on haskell and everything sounds strange
15:57:36 <shapr> do you have a good tutorial to read?
15:57:51 <shapr> there are some nice ones online
15:58:00 <apoplex> no i do not have
15:58:07 <shapr> @learn
15:58:07 <lambdabot> http://www.haskell.org/learning.html
15:58:23 <skew> ftothek is just the name of the argument of the lambda
15:58:28 <shapr> there are several mentioned there, I like YAHT
15:58:39 <skew> watch out, a number lof those links are dead
15:58:57 <shapr> really?
15:59:12 <l^rchkrn> (A lambda is an anonymous function?)
15:59:19 <monotonom> yes
15:59:20 <shapr> I gotta notify the peoples then
15:59:41 <shapr> gotta get the web posse movin
15:59:52 <skew> oh, learning haskell. I'll check these out. Bookshelf has some dead links
16:00:48 <shapr> la: la la ?
16:00:49 <skew> never mind, these are fine
16:01:00 <l^rchkrn> apoplex: If you download YAHT, get the PS version, my GV had problems with the PDF one...
16:01:51 <apoplex> i have the PS
16:02:02 <shapr> l^rchkrn: hey did you check out curryspondence?
16:02:19 <skew> It's just Jan Skibinski's "Haskell Companion" that's dead
16:02:34 <shapr> yes
16:02:41 <monotonom> 1 is a number.
16:02:52 <shapr> that's been dead awhile
16:03:12 <shapr> needs automation!
16:03:18 <l^rchkrn> curryspondence?
16:03:22 <l^rchkrn> 8-?
16:03:32 <shapr> l^rchkrn: the mailing list search
16:04:11 <l^rchkrn> shapr: Yes. Works great :-) The sources are SearchML.hs?
16:04:25 <shapr> I'm a great fan of wikis, cuz I can fix 'em myself
16:04:39 <shapr> there's a darcs repo for curryspondence
16:04:45 <l^rchkrn> :-)
16:04:50 * l^rchkrn is stuck with tla
16:05:07 <l^rchkrn> Is darcs production ready?
16:05:08 <skew> shapr: what was the urll for the live copy?
16:05:24 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
16:05:49 <shapr> I haven't come up with a cron job or something to update it though
16:06:27 <shapr> l^rchkrn: I think so, it still has some missing features, but it works well
16:06:40 <l^rchkrn> shapr: Whats missing?
16:06:46 <skew> I think darcs is probably ready for use in small projects, anyway
16:07:08 <shapr> I really want a patch browser
16:07:18 <l^rchkrn> (I only have a SF account, they only have CVS :-(
16:07:35 <skew> I don't know about convincing managers and such that it's a good idea
16:07:45 <yich> So far, looking at instance Monad Maybe, hasn't made me less confused. when I see:  query c "select..." >>= collectRows getRow, shouldn't collectRows have type signature like:   collectRows :: a -> IO b (but with an appropriate type for a, e.g. collectRows :: Statement -> IO String)? Instead it's type signature is:    collectRows :: (Statement -> IO a) -> Statement -> IO [a]. Why doesn't haskell complain?
16:07:45 <skew> l^rchkrn: it's really lightweight to get yourself
16:07:46 <shapr> and I want to be able to see a patch before I apply it
16:08:20 <l^rchkrn> http://abridgegame.org/cgi-bin/darcs?darcs*
16:08:21 <l^rchkrn> ?
16:08:37 <shapr> l^rchkrn: that's the darcs repo of darcs
16:08:38 <skew> yich: collectRows is already applied to getRow, so it needs to take two arguments before returning an IOaction
16:08:58 <skew> apparently the first argument is supposed to have type (Statement -> IO a)
16:09:00 <shapr> you probably want source or binary at first
16:09:54 <shapr> I think getRow is of type (Statement -> IO a)
16:10:20 <shapr> so collectRows getRow becomes ::  Statement -> IO [a]
16:10:53 <skew> and then bind works to combine an IO Statement and a (Statement -> IO [a]) to give a single IO [a]
16:12:05 <shapr> @type map
16:12:06 <lambdabot> type: 
16:12:06 <lambdabot> map :: (a -> b) -> [a] -> [b]
16:12:13 <shapr> @type map (+)
16:12:14 <lambdabot> type: 
16:12:14 <lambdabot> map (+) :: Num a => [a] -> [a -> a]
16:12:32 <shapr> see how the type sig gets simpler when a function is filled in?
16:12:52 <shapr> @type map (+ 1)
16:12:52 <lambdabot> type: 
16:12:53 <lambdabot> map (flip (+) 1) :: Num a => [a] -> [a]
16:13:07 <l^rchkrn> -}
16:13:28 <jadrian> can we define datatypes in the interpreter?
16:13:36 <shapr> -- you can't hear me in a comment! nyah nyah!
16:13:44 <jadrian> lol
16:14:06 * shapr grins
16:14:49 <shapr> yich: do you see what I'm saying?
16:15:13 <yich> I'm still confused. why does getRow get applied? I thought the parsing goes left to right, e.g. this is wrong: reverse (++"xx") "yy", this is right: reverse ((++"xx") "yy").
16:15:52 <shapr> yich: the type of (+) is Int -> (Int -> Int)
16:16:09 <shapr> the -> op is right associative
16:16:30 <shapr> since (a -> b) is the type of a function
16:16:55 <shapr> that means that + takes *one* Int, and returns a new function
16:17:07 <shapr> @type (+)
16:17:07 <lambdabot> type: 
16:17:07 <lambdabot> (+) :: Num a => a -> a -> a
16:17:13 <shapr> @type (1 +)
16:17:14 <lambdabot> type: 
16:17:14 <lambdabot> (1 +) :: Num a => a -> a
16:17:47 <shapr> so, you can use a function as a value just fine
16:18:08 <shapr> @type map
16:18:09 <lambdabot> type: 
16:18:09 <lambdabot> map :: (a -> b) -> [a] -> [b]
16:18:29 <shapr> see, map is asking for a function
16:18:49 <shapr> yich: clearer?
16:19:32 <yich> .. I'm trying to digest that.. hold on heh
16:19:49 <shapr> map will execute that function on each item of a list, and return the result
16:20:10 <shapr> @eval (\x -> x + 1) 1
16:20:11 <lambdabot> 2
16:20:44 <shapr> that applies an no-name function that adds one to 1, giving 2
16:20:58 <shapr> @eval map (\x -> x + 1) [1,2,3]
16:20:59 <lambdabot> [2, 3, 4]
16:21:18 <shapr> yich: clearer?
16:21:47 <shapr> you can use the function like a hammer, banging a row of nails
16:21:48 <jadrian> ---> is this safe? @eval map (\x -> x + 1) [1,2..]
16:21:50 <jadrian> lol
16:21:57 <shapr> jadrian: try it
16:22:04 <jadrian> @eval map (\x -> x + 1) [1,2..]
16:22:04 <lambdabot> (line 1, column 24):
16:22:04 <lambdabot> unexpected "."
16:22:04 <lambdabot> expecting simple term
16:22:16 <jadrian> @eval map (\x -> x + 1) [1,2 ..]
16:22:16 <lambdabot> (line 1, column 25):
16:22:16 <lambdabot> unexpected "."
16:22:16 <lambdabot> expecting simple term
16:22:21 <jadrian> hmmm
16:22:29 <skew> @eval [1..]
16:22:30 <lambdabot> (line 1, column 4):
16:22:30 <lambdabot> unexpected "."
16:22:30 <lambdabot> expecting simple term
16:22:37 <skew> @eval let x = 1 in x
16:22:38 <lambdabot> (line 1, column 7):
16:22:38 <lambdabot> unexpected "="
16:22:38 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
16:22:38 <lambdabot>  "(", operator, simple term or end of input
16:22:49 <shapr> @eval (\x -> x x)(\x -> x x)
16:22:58 <jadrian> @type repeat
16:23:04 <esap> @eval let x = (1 : map (+1) x) in x
16:23:09 <jadrian> @type repeat x
16:23:11 <jadrian> @type repeat 1
16:23:20 <lambdabot> out of fuel - use @resume to continue
16:23:20 <lambdabot> type: 
16:23:20 <lambdabot> repeat :: a -> [a]
16:23:20 <lambdabot> (line 1, column 7):
16:23:20 <lambdabot> unexpected "="
16:23:20 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
16:23:21 <skew> lambdabot doesn't seem to evaluate Haskell...
16:23:22 <lambdabot>  "(", operator, simple term or end of input
16:23:24 <lambdabot> type: 
16:23:26 <lambdabot> type: 
16:23:28 <lambdabot> repeat 1 :: Num a => [a]
16:23:45 <jadrian> @eval repeat 1
16:23:50 <shapr> eval is a lambda cal interpreter
16:23:55 <jadrian> oh
16:24:00 <shapr> type calls hugs
16:24:24 <jadrian> @eval (\x -> repeat x) 1
16:24:29 <lambdabot> out of fuel - use @resume to continue
16:24:35 <jadrian> ah :)
16:25:12 <lambdabot> out of fuel - use @resume to continue
16:25:14 <shapr> @definition repeat
16:25:14 <lambdabot> Sorry, I don't know the command "definition", try "lambdabot: @listcommands
16:25:23 <shapr> @listcommands eval
16:25:24 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition
16:25:24 <lambdabot> ,"definitions","del-definition","dump","set-fuel","resume"]
16:25:34 <shapr> @get-definition repeat
16:25:34 <lambdabot> repeat = iterate id
16:25:45 <shapr> @get-definition iterate
16:25:45 <lambdabot> iterate = \\f x.x:iterate f (f x)
16:25:51 <shapr> @get-definition id
16:25:51 <lambdabot> id = \\x.x
16:26:00 <shapr> eval is quite nifty
16:26:21 <monotonom> What is set-fuel?
16:26:43 <shapr> max number of iterations before it runs out
16:26:45 <SamB> hmm, the poeple in #java may be worse off than the people in #c++...
16:26:57 <shapr> how so?
16:27:08 <monotonom> worse in what?
16:27:59 <SamB> hmm, I'm not sure I can explain at the moment.
16:28:26 <jadrian> hmmmm
16:28:40 <jadrian> ghci assumes IO monad?
16:28:46 <shapr> yup
16:28:51 <jadrian> :-/
16:28:52 <jadrian> eh
16:28:54 <skew> jadrian: sort of. It executes IO actions, tries to show anything else
16:28:55 <shapr> means you can do let x = 1
16:29:12 <shapr> and foo <- getContents ".bashrc"
16:29:16 <skew> oh, yeah , it accepts any statement as input
16:29:18 <shapr> and they both work
16:29:22 * jadrian is playing around with QuickCheck...
16:29:30 <shapr> QC rocks
16:29:55 <jadrian> was trying to get some generated values with  a <- arbitrary :: Gen something 
16:30:00 <jadrian> yeap it's pretty cool
16:30:07 <SamB> yes, it does.
16:31:36 <yich> shapr: ok, I get it. it's because of the infix >>=... thanks
16:32:08 <shapr> ok
16:36:20 <shapr> @fortune
16:36:21 <lambdabot>       _
16:36:21 <lambdabot>   _  / \\			   o
16:36:21 <lambdabot>  / \\ | |		       o	   o		 o
16:36:21 <lambdabot>  | | | |   _			o    o		       o       o
16:36:21 <lambdabot>  | \\_| |  / \\		      o			    o	 o
16:36:21 <lambdabot>   \\__  |  | |		  o			      o
16:36:23 <lambdabot>      | |  | |		 ______	  ~~~~		    _____
16:36:25 <shapr> oy
16:36:25 <lambdabot>      | |__/ |	       / ___--\\\\ ~~~		 __/_____\\__
16:36:27 <lambdabot>      |	___/	      / \\--\\\\  \\\\   \\ ___	<__  x x  __\\
16:36:29 <lambdabot> [14 @more lines]
16:36:45 <shapr> no thank you Mr lambdabot!
16:39:35 <jadrian> nice :)
16:40:20 <shapr> g'day Pseudonym 
16:40:31 <Pseudonym> G'day.
16:40:41 <Pseudonym> I feel the need to write.
16:40:46 <shapr> ok!
16:40:55 <Pseudonym> Curry-Howard Correspondence for Dummies.
16:41:01 <shapr> yes!
16:41:23 <Pseudonym> I'm a dummy and I only just got it.
16:41:39 <monotonom> Yes please share.
16:41:41 <Pseudonym> So I think I need to write it down before I lose it.
16:41:46 <shapr> if you write about it, others will get it too!
16:41:47 <Pseudonym> Oh, I'll put it on the wiki.
16:41:58 <Pseudonym> People who know about it: Please check my reasoning.
16:41:59 <shapr> yay!
16:42:05 <Pseudonym> OK.  Here's the idea.
16:42:15 <Pseudonym> Think of any theorem.
16:42:23 <Pseudonym> Let's say, Pythagoras' Theorem.
16:42:37 * shapr runs to bed before his head explodes
16:42:47 <Pseudonym> It is of the form: "If you have a right-angled triangle, then blah blah blah."
16:42:50 <Pseudonym> Night, shapr.
16:42:51 <monotonom> yucky, your head will explode in bed.
16:43:09 <Pseudonym> At least it won't explode all over #haskell.
16:43:23 <monotonom> I have a firewall, I don't mind.
16:43:45 <Pseudonym> OK, back to Pythagoras' Theorem.
16:43:50 <Pseudonym> Or, indeed, any theorem.
16:44:13 <Pseudonym> They're all of this form: If you have P, then Q is true.
16:44:32 <Pseudonym> Or more commonly: If you have X, Y and Z, then P is true.
16:44:40 <Pseudonym> X, Y and Z are the _assumptions_.
16:44:45 <Pseudonym> P is the _conclusion_.
16:44:48 <tautologico> hypotheses
16:44:48 <Pseudonym> With me so far?
16:44:52 <tautologico> thesis
16:45:01 <tautologico> ok
16:45:25 <Pseudonym> tautologico: I'm using the word "assumption" because I'm using sequent calculus. :-)
16:45:38 <Pseudonym> But we'll get there.
16:45:38 <tautologico> ok, go ahead :)
16:45:38 <monotonom> words
16:45:41 <Pseudonym> Yes.
16:45:51 <Pseudonym> Anyway.  You can think of it as a statement:
16:45:55 <Pseudonym> X, Y, Z |- P
16:45:56 <tautologico> I'm just saying synonyms out loud to acknowledge
16:45:59 <Pseudonym> Or perhaps:
16:46:04 <Pseudonym> X and Y and Z -> P
16:46:09 <Pseudonym> where -> is logical implication
16:46:18 <tautologico> which is equivalent
16:46:18 <Pseudonym> Or, indeed:
16:46:23 <Pseudonym> X -> (Y -> (Z -> P))
16:46:29 <Pseudonym> Which is also equivalent.
16:46:35 <Pseudonym> Is this looking familiar to anyone?
16:46:37 <tautologico> yes
16:46:47 <Pseudonym> Any, say, Haskell programmers, perhaps?
16:47:04 <monotonom> We're all haskell programmers of sorts, aren't we?
16:47:13 <Pseudonym> Yes.
16:47:20 <Pseudonym> But doesn't it remind you of currying?
16:47:25 <Pseudonym> f :: (X,Y,Z) -> P
16:47:26 <monotonom> It does.
16:47:30 <Pseudonym> g :: X -> Y -> Z -> P
16:47:33 <Pseudonym> Right.
16:47:37 <tautologico> of course
16:47:38 <Pseudonym> Now here's the cute part:
16:47:44 <skew> It reminds me of the appropriate theorem of logic as well...
16:47:44 <Pseudonym> You can also think of this theorem as a function.
16:47:49 <monotonom> And going backwards is howarding, I presume? <grin>
16:47:55 <tautologico> lol
16:47:58 <jadrian> lol
16:48:08 <Pseudonym> If you supply proofs of X, Y and Z, you give that to the theorem, and it supplies a proof of P.
16:48:12 <skew> change the prelude!
16:48:41 <Pseudonym> That's step 1: Every theorem is a function.
16:49:14 <skew> we need a few good unsophisticated things to confuse newbies, like wierd named (caadar), before they hit the sophisticated defenses like monads and laziness ;)
16:49:37 <Pseudonym> skew: More than one person has noted that we don't use nearly enough Greek letters.
16:50:05 <skew> Pseudonym: you are done with the isomorphism, right?
16:50:11 <monotonom> Not everyone loads the Greek font into their irc clients.
16:50:12 * jadrian wishes there was something like ProofGeneral for Haskell 
16:50:20 <skew> we need support for unicode source files
16:50:29 <Pseudonym> skew: No, not quite yet.
16:50:33 <Pseudonym> There's one more step.
16:50:48 <jadrian> skew: or something similar to ProofGeneral
16:50:52 <Pseudonym> Which would take too much notation to show on #haskell, so I'll do this on the wiki.
16:50:56 <jadrian> skew: ever tried it?
16:51:31 <Pseudonym> The next step is to show that every logical formula is equivalent to a type.
16:52:07 <Pseudonym> See, we're only actually dealing with the types of f and g earlier.
16:52:41 <jadrian> skew: here is a nice screenshot, it shows some greek letters http://proofgeneral.inf.ed.ac.uk/images/pg-isa-screenshot.png
16:52:59 <Pseudonym> And you get nice results like: A formula is provable in a system if the corresponding type is inhabited.
16:53:28 <Pseudonym> The other direction is that type systems can be checked by theorem provers.
16:53:47 <Pseudonym> So basically, the Curry-Howard correspondence says: Proof are types and types are proofs.
16:54:01 <Pseudonym> If anyone knows what I'm talking about, am I on the right track here?
16:54:21 <jadrian> Pseudonym: just curious, what is the definition of "inhabited type"?
16:54:52 <tautologico> I can't say if you got anything wrong... write it up in the wiki and see if anyone complains :)
16:55:29 <Pseudonym> An inhabited type, as I understand it, is a type which has a value.
16:55:40 <Pseudonym> Or, if you like, it's a set which obeys the axiom of choice.
16:55:45 <tautologico> that's what I thought
16:55:51 <Pseudonym> Kind of thing.
16:56:01 <jadrian> right
16:56:08 <jadrian> kind of...
16:56:15 <Pseudonym> One of the interesting things about Haskell is that every type is inhabited.
16:56:24 <skew> Haskells type system gives a degenerate logic for example, becasue of undefined
16:56:25 <Pseudonym> Because they all contain bottom.
16:56:29 <jadrian> because of bottom?
16:56:37 <jadrian> k
16:57:09 <jadrian> what is the english word for the opposite of inhabited btw?
16:57:18 <monotonom> uninhabited; empty
16:57:22 <jadrian> oh
16:58:13 <skew> somebody observed that the most commonly (and cleverly) proved therorem in Haskell is IO ()
16:58:44 <jadrian> can we really say a set "obeys" the axiom of choice?
16:59:19 <Pseudonym> Not if it's an axiom, obviously.
16:59:19 <monotonom> If "axiom of choice" simply means "the set/type is non-empty".
16:59:49 <Pseudonym> Basically, I mean by it that you can choose a value of that type.
17:00:16 <jadrian> well if I'm not mistaken the axiom of choice states that for every *non-empty* set
17:00:29 <skew> Pseudonym: that's a rather roundabout way of saying "nonempty"
17:00:30 <jadrian> (say A)
17:00:45 <Pseudonym> Well, that's using the interpretation that a type is a set.
17:00:51 <jadrian> you can define a function, f, etc etc
17:01:18 <Pseudonym> If you think of the type as a proof, then my intuition is that the set is the undelying set is the of all possible worlds where that statement is true.
17:01:51 <Pseudonym> So saying "the type is inhabited" is like saying "there's a universe where the conclusion is true".
17:01:57 <monotonom> the type X is the collection of all the proofs of statement X.
17:02:26 <monotonom> (the type is not necessarily "a" proof)
17:02:39 <Pseudonym> Good point.
17:02:49 <Pseudonym> See, this goes back to category theory.
17:02:59 <Pseudonym> Oh, hang on.
17:03:03 <Pseudonym> Hmmm.
17:03:07 <monotonom> IANAL, but you can usually s/collection/set/
17:03:16 <Pseudonym> Wait.  If you consider the proof system as a category, then it _is_ a proof.
17:03:22 <Pseudonym> Up to isomorphism.
17:03:25 <Pseudonym> :-)
17:03:55 * jadrian needs to sleep
17:04:11 <Pseudonym> Anyway, I'll write this up and then get people to shoot holes in it.
17:04:28 * jadrian asks to be told if you ever decide to talk about proof systems!
17:04:31 <Pseudonym> I haven't had any caffeine today yet, so I'm not making a huge amount of sense to myself.
17:04:38 * jadrian is interested on the subject
17:04:48 <Pseudonym> Then you probably know more than I do about it.
17:04:58 <Pseudonym> I only know enough to implement logic programming languages.,
17:05:02 <jadrian> I don't know that much about lambda calculus :(
17:05:07 <Pseudonym> Which is quite a bit, when you consider optimisation.
17:05:08 <jadrian> should know more about it...
17:05:39 <jadrian> now bed!
17:05:40 <jadrian> see you all
17:05:43 <Pseudonym> Night.
18:41:32 <yich> haskeldb wants me to install hsql into the ghc library tree. Do think that is $BLAH/lib/ghc-2.6.1/imports?
18:45:08 <skew> ghc library tree starts at $PREFIX/lib/ghc-6.2.1 (for 6.2.1)
18:45:20 <skew> hsql should have a makefile that will build and install correctly
18:45:24 <skew> I am off to dinner!
18:45:35 <Pseudonym> Mmmm... food...
19:20:56 <skew> yay, I fixed the decref bug!
19:21:25 <skew> foreign import "PyDecRef" pyDecRefPtr :: FunPtr (RawPyObject -> IO ()) is VERY VERY different from
19:21:43 <skew> foreign import "& PyDecRef" pyDecRefPtr ....
19:22:17 <heatsink> You can program python in haskell?
19:22:17 <skew> look here-------^
19:22:28 <skew> I'm workin on it.
19:22:38 <skew> I caught the error thanks to the typechecker
19:22:45 <skew> C's typechecker :)
19:22:54 <heatsink> :) good workin'
19:22:56 <skew> really proves the value of a well throught out type system ;)
19:23:18 <skew> yep, adding -O (implying -fvia-C) made it _easier_ to find the error...
19:23:40 <skew> see, the first import says that PyDecRef is a pure function of no arguments returning a function pointer!
19:24:01 <skew> the second imports the address of PyDecRef as a pointer to a function of one pointer argument, much more correct.
19:24:16 <heatsink> oh, okay
19:24:30 <skew> so watch out for that in your code...
19:25:04 <skew> but now it works! I run my demo and see finalizers being called, instead of crashing at the first GC. Yay!
19:27:57 <Spark> the british train network is a fucking joke
19:29:18 <Spark> a joke sicker than any abortion comedy and less humorous than what is provided on the back of penguin wrappers
19:30:17 <skew> I'm going to make the fix a single character patch in darcs, named "ampersand of doom!"
19:30:31 <skew> then it's time to support exceptions.
19:31:13 <bring> yich: did you get haskelldb + hsql working?
19:43:10 <chappy> hi
19:43:33 <chappy> is there a site where i can find out the pro's and con's of haskell?
19:44:21 <skew> what sorts of things are you interested in?
19:44:34 <skew> I don't know of anything particularly comprehensive
19:45:21 <chappy> umm...
19:45:37 <chappy> i guess different aspects of any language
19:46:04 <chappy> the typing system, readability, abstraction
19:46:13 <skew> all superb
19:46:17 <chappy> lol
19:46:37 <chappy> ok so what is bad about it?
19:46:49 <skew> there are some performance issues with strings
19:47:15 <skew> sometimes with laziness your code takes more space than you think it should
19:47:29 <skew> fixing that actually requires understanding your code
19:47:57 <skew> the abstractions might go over your head sometimes...
19:48:03 <chappy> i dont understand
19:48:20 <chappy> you mean problems with string manipulation functions?
19:48:22 <skew> well, fixing space leaks requires understanding how the program will be evaluated
19:48:30 <skew> so they are a bit of a pain
19:48:35 <chappy> oh
19:48:48 <skew> no, I mean the (default) string implementation is space inefficient and somewhat slow
19:48:54 <skew> linked list of characters, more or less
19:49:04 <chappy> oh
19:49:04 <chappy> ok
19:49:11 <heatsink> Does GHC improve on that?
19:49:19 <skew> there are more efficient and cumbersome representations available
19:49:23 <chappy> what about designing large software systems?
19:49:26 <heatsink> What about heavily side-effect computations like image processing?
19:49:38 <skew> heatsink: that's not much of an issue
19:50:01 <skew> I think even imperative code is cleaner with referential transparency and first class actions
19:50:26 <chappy> brb
19:50:39 <skew> chappy: I don't know much about design, but I know people have written some big things in Haskell
19:50:50 <heatsink> Modifying an array is not O(n) time though...
19:51:00 <heatsink> oops
19:51:05 <heatsink> I mean not O(1) time
19:51:18 <skew> heatsink: do blocks as expressions, and blocks as first class values are both poweful
19:51:32 <skew> heatsink: arrays are only slow like that if you use the simplest kind
19:51:40 <skew> even using DiffArray should give you O(1) update
19:52:01 <skew> so long as you only use one version of the array at a time
19:52:08 <heatsink> skew: My understanding was that arrays are implemented as trees, and changing an element changes (log n) nodes
19:52:21 <heatsink> skew: ... in order to maintain laziness
19:52:25 <skew> Array probably is, maybe it's even O(n) time
19:52:35 <skew> using a tree has nothing to do with laziness
19:52:41 <skew> tuples are lazy, for example
19:52:56 <skew> it
19:53:07 <skew> it's to preserve referential transparency that you would use a tree
19:53:18 <heatsink> Yes
19:53:28 <heatsink> That's what i was thinking about
19:53:36 <skew> if you use any of the arrays hosted in a mond, like say MutableByteArray# it can be implemented with mutation
19:53:42 <skew> and be fast
19:53:48 <heatsink> ok
19:53:51 <skew> also, DiffArray uses an interesting trick
19:54:08 <skew> the interface is functional, but internally a DiffArray value is a mutable cell
19:54:32 <skew> which can be either a raw array (of pointers to values, to allow laziness)
19:54:40 <skew> er, can be a raw array
19:55:09 <skew> then if you do an operation that "modifies" the array (returns a new slightly different one)
19:56:00 <skew> it actually modifies the bits in place (O(1) time), makes a new value around that, and modifies the argument array to contain instead a pointer to the modified array plus a record of the cell you changed
19:56:35 <heatsink> A history list?
19:56:39 <skew> yeah
19:56:53 <skew> that only gets used if you take an old version of the array and do something to it
19:57:04 <SamB> this HFL duel quote is funny
19:57:07 <heatsink> Okay
19:57:16 <skew> which scans throught the history until it finds the current version, copies it, and unwinds all the changes
19:57:26 <skew> then that starts a new "thread"
19:58:28 <skew> so basically you have constant time mutation and O(n) (amoritized) copying
19:58:57 <heatsink> Interesting
19:59:05 <skew> in a nice functional package
19:59:29 <skew> there's also stuff like IOUArray which is pretty much exactly an array as in C, except with bounds checks
19:59:58 <skew> actually, I think GHC probably manages more optimization on imperative code than functional code
20:00:28 <skew> because it's pretty easy to see that everything is going to be strict, and inline things, and compile mutation into single machine instructions and so on
20:00:48 <skew> do you know that the HOpenGL version of glxgears runs just as fast as the C?
20:00:54 <heatsink> No
20:01:11 <SamB> skew: only just as fast?
20:01:26 <SamB> I guess because HOpenGL is only bindings ;-)
20:01:29 <skew> SamB: approximately as fast.
20:01:48 <skew> On a poweful machine it ran exactly as fast
20:01:58 <SamB> or doesn't everyone know that C is slow?
20:02:00 <skew> somebody reported it ran faster on a somewhat memory starved machine
20:02:36 <SamB> well, unless you have a good C JIT
20:02:45 <SamB> but even so.
20:02:57 <skew> heatsink: anyway, like the docs say, "you can always recover arbitrary amounts of "vs. C" speed by taking advantage of GHC extensions"
20:03:11 <heatsink> which docs?
20:03:19 <skew> the users guide
20:03:23 <skew> the GHC user's guide
20:03:49 <heatsink> where do i get that?
20:03:56 <skew> check out the Data.Array hierarchy for arrays in particualar
20:04:09 <skew> heatsink: http://www.haskell.org/ghc
20:04:12 <skew> is the ghc home page
20:04:17 <heatsink> oh, I found it
20:05:38 <skew> SamB: slow compared to JIT, or slow for a statically compiled language?
20:05:53 <skew> that is, statically compiled without loads of specialization
20:05:58 <SamB> skew: compared to JIT of course ;-)
20:06:09 <heatsink> Where can I find info on how haskell is compiled?
20:06:13 <skew> well, Haskell already does stuff just in time ;)
20:06:32 <skew> heatsink: there are some things man is not meant to know
20:06:37 <SamB> haskell is not lazy enough until it does lazy compilation ;-)
20:07:26 <skew> heatsingk: http://www.haskell.org/ghc/documentation.html Read "The Spineless Tagless G-Machine"
20:07:33 <heatsink> That STG paper?
20:07:42 <heatsink> I thought that was how it was interpreted
20:07:58 <skew> no, that's about how you compile it
20:08:04 <SamB> they have improved the machine since then, I think?
20:08:07 <skew> things on the heap that you jump into to evaluate them
20:08:21 <SamB> unified stacks or something?
20:08:21 <skew> the notes say it is a bit out of date, but that's the basic idea
20:08:31 <skew> yeah, that was one thing
20:08:34 <SamB> is there a paper about that bit?
20:08:58 <skew> there it "Run-time System document"
20:11:07 <seafood> I'm about to reveal my ignorance.
20:11:24 <seafood> .hi files in GHC. They're mainly used for GHCi right?
20:11:37 <heatsink> They're haskell include files... right?
20:11:40 <SamB> now you can get rid of your ignorance
20:11:54 <SamB> they are interface files, and contain all sorts of juicy stuff.
20:11:59 <seafood> Are they necessary for compilation?
20:12:03 <heatsink> yes
20:12:08 <SamB> they are roughly analogous to C header files
20:12:11 <seafood> Are you sure?
20:12:21 <SamB> but they aren't exactly included
20:12:21 <heatsink> If you're compiling multiple files
20:12:32 <SamB> and they are autogenerated
20:13:52 <skew> I'm off for a while. Give chappy my regards and explain how cool Haskell is if he comes back (mention the downsides of you think of any ;-)
20:18:23 <seafood> I got a good answer.
20:18:52 <SamB> seafood: where did you get it?
20:18:56 <seafood> In other, less rich languages they wouldn't be needed.  But you need to know the precedence and fixity of functions just to do parsing correctly.
20:19:07 <seafood> From someone nearby.  
20:19:17 <seafood> (i.e. I just talked to them in person.)
20:19:22 <SamB> ah
20:19:32 <SamB> I had forgotten about that particular bit.
20:19:47 <SamB> in other, less rich languages, some of this stuff would need to be done by hand ;-)
20:19:50 <seafood> And, they are used in desugaring.
20:20:05 <seafood> e.g. list comprehensions.
20:20:13 <SamB> such as type signatures
20:20:31 <SamB> aka prototypes
20:20:33 <seafood> You need to know the type of expressions in a list comprehension to know whether to filter or not.
20:21:17 <SamB> seafood: hmm. that sounds a bit unsanitary
20:22:47 <seafood> samB: Woops. Looks like Pat (they guy I talked to) has retracted that comment.
20:23:01 <seafood> SamB: You can do it syntactically.
20:24:03 <SamB> oh good ;-). I was pretty sure haskell didn't have anything where you would HAVE to do that.
20:26:19 <skew> seafood: it's mostly about declaring data types, describing functions, and some code packed along for inlining
20:26:58 <skew> I'm apparently not being gone yet
20:33:58 <camio> Hrm, I've got a few negatives on haskell.
20:34:30 <skew> camio: libs? performance?
20:34:48 <skew> it's not Java?
20:34:49 <camio> People qualified to code haskell and maintain haskell code are rare.
20:35:14 <SamB> skew: that last is hardly a negative.
20:35:30 <camio> In the unlikely event you find someone who actually can program in haskell, he is probably going to be more expensive than you expected.
20:35:36 <skew> SamB: who knows what some people think?
20:36:01 <SamB> skew: true.
20:36:03 <skew> camio: that's not really an argument against using it for your own stuff
20:36:29 <camio> skew: True, but if you want your code to have other developers it becomes a real issue.
20:36:55 <camio> skew: And usually, in my experience, people see that as a dream of sorts for their pet projects.
20:37:03 <SamB> camio: he probably will have given up all hope of getting paid to do haskell, I think
20:37:31 <skew> low supply + low demand
20:37:58 <skew> except if you've got legacy Haskell lying around...
20:38:10 <camio> Heh, I would love to kill my current team and get in all Haskell programs to do the work.  But that just isn't feasable.
20:38:24 <skew> replacing your teammates with Haskell programs?
20:38:32 <Pseudonym> Aren't there a lot of recent graduates who know Haskell?
20:38:35 <Pseudonym> They're pretty cheap.
20:38:43 <Pseudonym> All you need is an expensive manager.
20:38:45 <camio> And it certainly isn't an option to train people.
20:39:00 <Pseudonym> camio: For anything nontrivial, you need to train people.
20:39:09 <Pseudonym> Even if only by doing it.
20:39:19 <camio> Pseudonym: Don't graduate students want to do something more reasearchy than program?
20:39:29 <SamB> camio: I'm afraid you cannot replace people who are worth anything with haskell programs ;-)
20:39:32 <Pseudonym> You get a lawyer from Belgium and put them in Britain, see how long they last without learning a thing or two.
20:39:43 <Pseudonym> camio: I'm not talking about graduate students.
20:39:46 <camio> Pseudonym: Absolutely, but even training someone in graphics and OpenGL pales in comparison to Haskell.
20:39:48 <Pseudonym> Lots of undergrads learn Haskell.
20:39:51 <skew> SamB: just give us a few years to improve the language...
20:40:22 <SamB> skew: also you would need to do AI research
20:40:28 <camio> Pseudonym: Not in US in my experience.
20:40:39 <skew> SamB: or have pretty poor teammates...
20:40:44 <skew> camio: I'm an undergrad.
20:40:50 <SamB> I'm assuming you only consider intelligent people to be worth anything
20:40:56 <camio> skew: Want a job?
20:40:57 <camio> :)
20:41:02 <skew> already got one, thanks.
20:41:10 <camio> SamB: Yeah, extremely intelligent people.
20:41:41 <Spark> whats the argument here?
20:41:57 <SamB> camio: certainly you will not be able to replace intelligent people with haskell programs anytime soon ;-)
20:42:03 <skew> something about finding people who can code Haskell and how expensive they are
20:42:24 <camio> skew: Rare+Expensive.
20:42:40 <Pseudonym> Actually, that's not entirely true.
20:42:42 <skew> I think any Math+CS double major could learn Haskell pretty quick.
20:42:43 <camio> skew: Rare probably being the more important factor.
20:42:44 <Spark> heh
20:42:51 <Spark> does it matter?
20:42:53 <Pseudonym> Intelligent people are willing to earn less if they get to do intelligent things for a living.
20:42:55 <Pseudonym> THAT'S rare.
20:43:35 <skew> I don't think other people should have that much trouble...
20:43:41 <Pseudonym> I've looked around.  Jobs where you get to use your intelligence are very, very rare.
20:43:48 <camio> skew: quick? not for me or the other Math/CS people I know.
20:43:54 <camio> Math definately helps.
20:44:12 <Pseudonym> I'm not getting paid anywhere near what I'm worth, but I'm doing really interesting things.
20:44:19 <Spark> the fewer people who place constraints on fringe languages like python and haskell, the quicker they will evolve as a proof of concept of advanced ideas
20:44:22 <skew> I'm teaching Haskell to about 4 other undergrads at the moment, a little "pick a language to learn" class
20:44:32 <skew> camio: well, depends what you mean by quick
20:44:49 <skew> being able to write basic code shouldn't take too long
20:44:58 <SamB> there is python quick and there is haskell quick, I guess
20:45:14 <camio> skew: I want them to know the language as well as they know their primary language (be it java or c++ or whatever).
20:45:20 <Pseudonym> Python is quick because you just glue existing libraries together.
20:45:24 <SamB> and java is always boring
20:45:49 <SamB> its that long-winded syntax that does it
20:45:55 <Spark> and the UML
20:45:58 <Pseudonym> Well, that's what good editors are for.
20:46:12 <Pseudonym> Thankfully, most smart Java programmers avoid UML if they can.
20:46:19 <skew> what takes a while is getting instincts for laziness and categoric abstractions.
20:46:29 <SamB> Spark: the UML certainly doesn't help matters. but it is not integral to the language ;-)
20:46:40 <Pseudonym> The language is crap without UML.
20:46:50 <heatsink> what is uml?
20:47:00 <heatsink> markup language?
20:47:04 <Spark> a crappy standard for drawing dilbert esque cartoons
20:47:11 <Pseudonym> Something Modelling Language
20:47:11 <skew> Pseudonym: how does that fit with smart programers avoiding it? They just avoid Java altogether?
20:47:14 <SamB> its this crazy diagramy stuff with about sixteen bagillion different kinds of diagrams
20:47:16 <Spark> unified
20:47:16 <camio> A language for diagraming aspects of a program.
20:47:22 <camio> Kinda like flow charts.
20:47:34 <heatsink> hm.
20:47:40 <skew> I don't think many people know C or Java all that completely
20:47:42 <Spark> but being a natural language, it does not much good to make it formal
20:47:44 <Pseudonym> skew: It's possible that you could a) get paid a lot of money for it, in which case they're willing to sell their souls, or b) they're doing smart things, but in Java for externally imposed reasons.
20:47:47 <Spark> you just end up with terribly vague definitions
20:47:47 <skew> er, C++ or java
20:47:52 <Spark> and its totally subjective anyway
20:48:07 <SamB> skew: I was going to say, there aren't all that many dark corners in C
20:48:18 <Pseudonym> Yes, the thing that gets me about UML is that it doesn't clarify your thinking in any reasonable way.
20:48:19 <skew> yeah, C is nice and clean.
20:48:25 <Pseudonym> It might be useful for requirements analysis, I suppose.
20:48:32 <Pseudonym> But not for actually designing your software.
20:48:37 <skew> but C++ has things like a turing complete type system, with those templates
20:48:50 <Spark> C is perfect, until you want to write something other than Hello world
20:48:55 <Pseudonym> skew: So does Haskell.
20:48:56 <SamB> one odd point being a[b] == b[a] == *(a + b)
20:49:02 <Pseudonym> Someone has implemented Turing machines in typeclasses.
20:49:19 <camio> skew: That use of templates is rare.
20:49:19 <skew> at least GHC won't go into an infinite loop...
20:49:32 <Pseudonym> Most C++ compilers won't either.
20:49:46 <SamB> camio: I think it is only for silly that it is actually done ;-)
20:50:06 <skew> camio: well, what do you mean by "knowing the language"?
20:50:08 <Pseudonym> At least not the good ones.
20:50:26 <skew> like, being able to understand the implementations of the standard libraries?
20:50:44 <skew> let all the "interesting" template stuff in STL?
20:50:55 <Pseudonym> skew: Do you understand the implementation of GHC's big integers?
20:51:11 <SamB> Pseudonym: hmm, that sounds kind of fun.
20:51:16 <skew> they use GMP
20:51:23 <camio> skew: I guess I mean needs-no-reference normally, fluently read all well-written code, the mind-to-code is not a bottleneck.
20:51:26 <SamB> skew: they do?
20:51:35 <Pseudonym> Do you understand the implementation of GMP?
20:51:42 <Pseudonym> In fact, how much of the RTS do you understand?
20:51:44 <SamB> camio: hehe, nobody never needs a reference ;-)
20:51:46 <skew> SamB: I think so. At least, GHC links with GMP...
20:53:06 <camio> skew: I think Python is a more viable language for new projects than Haskell.  I wish it weren't the case, but I think it is.
20:53:19 <skew> Oh, I don't know all of that (I've read the RTS papers, and a bit of GMP)
20:53:41 <skew> knowing the internals there isn't necessary to understand the language semantics, though.
20:54:33 <Pseudonym> Actually, I find the STL very easy to understand, but it took the right person to explain it to me.
20:54:38 <Pseudonym> Most of the explanations out there are crap.
20:54:54 <camio> skew: Learning python equates through a weekend of tuturial and a week of experience.  Learning Haskell equates to several weekends of learning and several weeks of experience.
20:54:58 <skew> I was specifically talking about the trait class stuff they do to pick optimized implementations
20:55:16 <Pseudonym> That's what I meant.
20:55:29 <Pseudonym> The most important part of the STL is the iterator categories.
20:55:33 <Pseudonym> Everything else follows from that.
20:55:35 <Pseudonym> But I'm off-topic.
20:55:54 <SamB> camio: there are lots of worse languages than python, anyway.
20:56:14 <camio> SamB: Indeed.
20:56:23 <SamB> and if they are used to at least minimal goodness, maybe they will be able to learn haskell easier ;-)
20:57:40 <Pseudonym> I think the best thing anyone can learn is a wide variety of languages.
20:58:06 <camio> Pseudonym: A wide variety of good languages?
20:58:15 <Pseudonym> No, a wide variety of languages, period.
20:58:24 <Pseudonym> Including representative good ones and representative bad ones.
20:58:32 <SamB> camio: the bad ones won't damage you too badly if you don't get stucl on them
20:58:45 <Pseudonym> The bad ones teach you good programming practices too.
20:59:21 <camio> Please, don't make me learn COBOL :-P
20:59:28 <Pseudonym> I find myself using functional, object-oriented, imperative, logic etc techniques no matter what language I'm using at the time.
20:59:33 <SamB> there is one language which it is more fun to write a compiler for than to actually write code in
20:59:42 <Pseudonym> SamB: Forth?
20:59:49 <skew> SamB: there are a few of those
20:59:57 <SamB> ok, maybe more than one.
21:00:03 <SamB> I wasn't talking about forth, though.
21:00:04 <skew> Java ;-)
21:00:09 <SamB> I've only done bf...
21:00:11 <Pseudonym> No, writing a Java compiler is no fun.
21:00:12 <camio> SamB: Scheme?
21:00:35 <Pseudonym> Bourne shell!
21:01:51 <heatsink> SamB: unlambda
21:02:16 <SamB> I've done some optimizations for bf (well, probably two), including one originally intended to avoid wasting half-cycles on a PII
21:02:48 <SamB> I have a third one I want to do, but I want to think about it some more first ;-)
21:03:11 <camio> hehe
21:03:39 <camio> It's almost like how I'd imagine a turing machine.
21:04:04 <SamB> camio: well, its not quite as flexible in some ways, but more in others
21:04:27 <SamB> and it never has an infinite tape
21:05:13 <camio> SamB: Interesting property that any program in (<>+-.,][)* is a vlaid one.
21:05:37 <camio> s/vlaid/valid/
21:05:40 <SamB> camio: actually, you need balenced brackets
21:06:04 <SamB> and any other chars are allowed as comments
21:06:07 <camio> SamB: Ahh, nm then.  I thought it meant jump to the next ] in memory.
21:10:14 <SamB> hmm, does haskell.org incorrectly think that .gz conveys a MIME type?
21:13:05 <SamB> ah, yes, it does.
21:13:20 <SamB> it oughtn't to do that.
21:13:41 <SamB> it ought to give the mime-type of the file inside the gzip
21:13:58 <SamB> it confuses mozilla this way
21:19:05 <camio> Cool, I didn't know that GIMP's script-fu was for embedded scheme plugins.
21:20:06 <Pseudonym> http://lambda.weblogs.com/discuss/msgReader$12171
21:20:24 <Pseudonym> Someone may get a kick out of the anecdote at the bottom.
21:21:59 <camio> What is mercury?
21:22:11 <Pseudonym> Mercury is like Prolog, only pure.
21:22:16 <Pseudonym> And type-safe.
21:22:29 <Pseudonym> OK, Mercury is to Prolog as Haskell is to Lisp.
21:22:37 <camio> :)
21:23:17 <Pseudonym> Except that Lisp is a practical programming language.
21:23:49 <camio> What are logical languages good for?
21:24:20 <Pseudonym> That's like asking what functional languages are good for.
21:24:22 <SamB> mozilla embeds prolog for dealing with RDF inference, I believe
21:24:26 <Pseudonym> In theory, everything.
21:24:37 <camio> In practice?
21:25:18 <Pseudonym> In practice, it's declarative programming just like Haskell.
21:25:26 <Pseudonym> So it's well-suited for structure-based hacking.
21:25:37 <Pseudonym> Logic languages are favourites of people who do AI-type stuff.,
21:25:47 <Pseudonym> Theorem proving, searching etc.
21:26:07 <camio> Oh, okay.  So not usefull for anythign normal.
21:26:09 <Pseudonym> But Mercury, at least, is a general-purpose declarative language.
21:26:22 <Pseudonym> camio: You could possibly say the same about Haskell.
21:27:15 <camio> Pseudonym: :) Oh yeah.
21:27:23 <SamB> I think haskell is easier than lisp -- lisp hasn't got a hierarchical library
21:27:36 <Pseudonym> Oh, I think so too.
21:27:45 <Pseudonym> Similarly, Mercury is easier than Prolog.
21:28:29 <camio> Haskell, Mercury and the like remind me of esperanto.
21:28:42 <SamB> camio: heh.
21:28:55 <SamB> esparanto was just an artificial natural language, wasn't it?
21:29:05 <Pseudonym> You mean quirky, little-used and having a lot in common with Polish?
21:29:31 <camio> lol, I guess clean elegant and little-used.
21:29:43 <camio> Oh and efficient.
21:29:46 <Pseudonym> There's a lot that's inelegant about Esperanto.
21:30:03 <SamB> cleanness is not something that is much looked for in natural language
21:30:18 <camio> Pseudonym: I just read the ads, didn't learn the language.
21:30:19 <Pseudonym> There's a reason why natural languages lose regularity over time.
21:30:38 <camio> Pseudonym: Interesting.  Why?
21:31:00 <Pseudonym> Because the regular ways of doing things are harder.
21:31:10 <Pseudonym> Harder to pronounce, usually.
21:31:30 <Pseudonym> In English, for example, it would be easier to always use "a" as the indefinite article/determiner.
21:31:46 <Pseudonym> But we use "an" before vowels because it's easier to pronounce.
21:31:49 <camio> Pseudonym: I wonder if these arguments could be made for "natural" languages like C++ versus regular languages like Haskell.
21:31:51 <Pseudonym> That's an irregularity.
21:32:06 <Pseudonym> camio: That's precisely the argument used in favour of Perl.
21:32:20 <camio> Awesome!
21:32:41 <Pseudonym> http://world.std.com/~swmcd/steven/perl/linguistics.html
21:32:53 <SamB> camio: c++ isn't natural, it is an octopus made from a horse and four pieces of wood!
21:33:07 <Pseudonym> It's a creole of C.
21:33:10 <anyone> Perl would be a "natural" language.
21:33:39 <SamB> except it is a programming language ;-)
21:33:40 <camio> Well, they patched on OO.  Who knows, they may patch on FC++.
21:34:26 <anyone> C/C++ have irregularities, yes, but they are only because back in the 70s the irregularities were seemingly easier to parse and implement.
21:34:30 <heatsink> By this paradigm, perl is designed with more emphasis on writeability and less on readability
21:35:08 <SamB> anyone: C, irrugular?
21:36:13 <Pseudonym> SamB: void (*f)(int) = something();
21:36:15 <Pseudonym> f(3);
21:36:20 <Pseudonym> That's irregular.
21:36:30 <anyone> One example: "int a[1] = { 3 };" is allowed, but "int a[1]; a = { 3 };" is not.
21:36:31 <Pseudonym> If C were regular, you would have to write (*f)(3);
21:36:58 <camio> Efforts to maintain the "purity" of a language (whether natural or artificial) only succeed in establishing an elite class of people who know the shibboleths. <- does that describe #haskell?  :)
21:37:32 <anyone> What is shibboleth?
21:37:45 <camio> an arbitrary word it seems.
21:37:48 <Pseudonym> @wn shibboleth
21:37:50 <lambdabot> *** "shibboleth" wn "WordNet (r) 2.0"
21:37:50 <lambdabot> shibboleth
21:37:50 <lambdabot>      n 1: a favorite saying of a sect or political group [syn: {motto},
21:37:50 <lambdabot>            {slogan}, {catchword}]
21:37:51 <lambdabot>      2: a manner of speaking that is distinctive of a particular
21:37:52 <anyone> (Is that a word known only to an elite class of people?)
21:37:53 <lambdabot>         group of people
21:38:34 <Pseudonym> camio: No, it doesn't describe #haskell.  It does describe LtU, though.
21:38:57 <camio> Pseudonym: LtU?
21:39:05 <Pseudonym> lambda.weblogs.com
21:39:23 <camio> Man, I hope Larry Wall isn't right on with this doc.  I really abhore the idea of learning PERL really well.
21:41:42 <camio> Well, I guess what he says can be applied to subdomain languages which haskell aparrently is good at.
21:43:37 <camio> Have any of you tried Clean?
21:44:35 <SamB> lambda the ultimate has special words?
21:45:10 <camio> I'd like to know why Clean is reportedly so much faster than Haskell compilers.
21:45:27 <SamB> camio: I would like to know why the tree is such a mess
21:45:38 <Pseudonym> camio: Because Clean uses lazy evaluation selectively.
21:45:49 <Pseudonym> Rahter than all the time unless you jump through hoops to avoid it.
21:45:52 <Pseudonym> That's the main reason.
21:46:36 <camio> Hrm
21:46:56 <camio> So, is that compiler techolology (along the lines of eager-haskell) or part of the language?
21:47:14 <l^rchkrn> http://www.cs.kun.nl/~clean/archives/clean-list/0251.html
21:47:25 <l^rchkrn> ^^^ Fist Google hit for:
21:47:29 <anyone> Seeing how each and every worthwhile pursuit such as theology, philosophy, physics, chemistry, biology, sociology, mathematics, computer science, and what-not, has developed its own shibboleth, it is pretty clear that Larry Wall's point is 1. correct, and 2. irrelevant.
21:47:31 <l^rchkrn> Clean Haskell Benchmark
21:47:44 <l^rchkrn> (Shows that Haskell is faster)
21:48:16 <camio> l^rchkrn: Cool
21:48:34 <l^rchkrn> camio: Dunno I never seen Clean.
21:48:44 <l^rchkrn> And just learning Haskell...
21:48:49 <l^rchkrn> :-)
21:49:27 <camio> anyone: Isn't he arguing that the shibboleth will always exist, but it should be a requirement to know of the shibboleth first?
21:49:40 <camio> s/should/should not/
21:50:50 <camio> Another problem with Larry Wall's argument is that bugs in speech are not a big deal, but in code they are usually a really big deal.
21:50:53 <anyone> When I was born I knew not of the shibboleth of mathematics. Now I have a BSc in mathematics. Look, I have a brain.
21:51:00 <l^rchkrn> It says "Clean produces code faster, while Haskell (GHC) produces faster code" LOL
21:51:15 <l^rchkrn> Theese Clean guys smoke crack.
21:51:35 <anyone> Yes, in all worthwhile pursuit, you ultimately need a precise and concise language one way or another.
21:52:50 <anyone> Merriam-Webster entry for "intelligence" number 5: the ability to perform computer functions.  Tell that to Larry Wall.  So much for making languages (or anything at all) "natural" or "intuitive" or all that crap.
21:53:22 <anyone> (You can find that entry on for example www.m-w.com)
21:54:15 <camio> l^rchkrn: I'd venture to guess that those benchmarks (1997) are no longer valid.
21:54:43 <l^rchkrn> camio: Well, try benchmarking yourself, Its easy.
21:55:07 <camio> l^rchkrn: Downloading clean is a pain.
21:55:26 <l^rchkrn> Downloading? Why? Is it heavyweight?
21:55:44 <l^rchkrn> Wait...
21:55:55 <camio> l^rchkrn: It isn't exactly free?
21:56:44 <l^rchkrn> camio: I dunno...?
21:56:54 <l^rchkrn> camio: Isnt it?
21:57:06 <l^rchkrn> camio: Then it sucks even if its faster!
21:57:09 <camio> l^rchkrn: It kind of is and kind of isn't.
21:57:27 <l^rchkrn> camio: What license?
21:57:38 <SamB> it is supposedly free, I think... however it doesn't build like it is free
21:57:53 <camio> http://www.cs.kun.nl/~clean/
21:58:16 <l^rchkrn> SamB: "Doesnt build like its free"?
21:58:57 <l^rchkrn> :-?
21:59:00 <SamB> l^rchkrn: that is, I couldn't figure out how to build it. kinda like blender early on, I guess
21:59:11 <l^rchkrn> :-)
21:59:48 <l^rchkrn> camio: Is Clean off-side rule?
22:00:03 <camio> dunno
22:00:07 <camio> gtg, bye all
22:00:15 <anduril1> I don't like the looks of Clean's website . . . why do they use "state of the art" so often?
22:00:17 <l^rchkrn> :-)
22:00:22 <anduril1> I feel like they're selling something
22:00:31 <jesse> they are
22:00:37 <l^rchkrn> :-)
22:00:53 <jesse> comercial rights to the library, otherwise, your clean programs are lgpl'ed by default
22:01:11 <SamB> jesse: fantastic
22:01:18 <anduril1> ah
22:01:21 <ozone> Pseudonym: do you know how does Clean use lazy evaluation selectively?
22:01:23 <l^rchkrn> Ugh. This design is icky.
22:01:41 <SamB> would be more fantastic if it had a decent source tree, though
22:01:43 <anduril1> I love the color selection on some of these diagrams
22:01:43 <ozone> i mean, is that just a result of uniqueness typing, or are there other lazy/strictness application policies involved
22:01:56 <l^rchkrn> And they run Solaris 8! Too bad!
22:02:22 <anduril1> what is this 'uniqueness typing' they speak of
22:02:24 <Pseudonym> ozone: I think it's to do with the graph rewriting semantics.
22:02:54 <ozone> oh, so they still use a graph rewriter
22:03:46 <anyone> uniqueness typing is one way to turn a pure functional language into an imperative language.
22:04:09 <ozone> i should read up on how their stricness annotations on functions work.  my brain is twisting itself in knots about what happens if you have strict function with lazy where clauses and manipulating a lazy data structure
22:09:07 <jesse> i kindof like uniqueness typing, it makes allot of sense, though cleans implementation of it really complicates its type system
22:09:56 <anduril1> where can I find documents/examples for uniqueness typing?
22:10:06 <anduril1> I'm having a hard time finding anything
22:10:13 <Pseudonym> Do a search for "linear types can change the world".
22:10:17 <Pseudonym> The phrase.
22:10:34 <ozone> by phil wadler, eh
22:10:42 <Pseudonym> Right.
22:10:47 <ozone> oh, of course.  now the title makes sense :-)
22:10:52 <Pseudonym> Right!
22:10:59 <ozone> damn wadler and his sensible yet suave titles
22:11:20 <anyone> Yes
22:12:06 <SamB> heh, that is a good joke
22:12:24 * anyone writes an article "Wadler is a fun guy!"
22:23:34 <Lor> Wadler's "a taste of linear types" is utterly hilarious.
22:24:28 <anduril1> a vast majority of this paper is above my head, but Wadler's 'let!' seems very similar to >>=
22:24:43 <Lor> It must be nice to be such a guru that one can be silly and still be taken seriously.
22:25:35 <SamB> Lor: you mean they won't take any old silly name as long as it also makes sense?
22:26:00 <Lor> Wadler and Shivers performed a small play during his presentation at ICFP.
22:33:13 <anduril1> identity crisis?
22:34:48 <l^rchkrn> Oh no...
22:35:01 <l^rchkrn> It was "lame nick wars" in #debian... Sorry...
22:35:22 <anduril1> ha
22:35:34 <anduril1> I don't mind at all
23:08:57 <l^rchkrn>  _
23:08:57 <l^rchkrn> / \ 
23:08:57 <l^rchkrn> \_/
23:32:23 <vegai> HOpenGL seems to change names quite often... I wonder if there's a handy changelog available...
23:44:54 <vegai> what is '$='?
23:54:23 <Pseudonym> @type ($=)
23:54:24 <lambdabot> type: 
23:54:33 <Pseudonym> @type $=
23:54:34 <lambdabot> type: 
23:54:40 <Pseudonym> @type id
23:54:40 <lambdabot> type: 
23:54:41 <lambdabot> id :: a -> a
23:54:44 <Pseudonym> I don't know.
23:59:54 <vegai> oh, it's an operator of some ugly library then, I guess
