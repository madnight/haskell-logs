00:00:05 <desrt> i mean
00:00:13 <desrt> i don't want to go redefining >>= and so on
00:00:23 <desrt> i want them to have the normal meaning
00:00:27 <desrt> i just want to define my own state
00:00:39 <Pseudonym> Why don't you build it on top of MonadState?
00:00:40 <desrt> (in the push/pop example, my state is a list)
00:00:50 <desrt> perhaps that's what i want to do
00:07:52 <shapr> hei ksandstr 
00:07:53 <desrt> no.  not quite what i want either :(
00:08:13 <shapr> what didn't work with that?
00:08:17 <shapr> that's what I would have done
00:08:25 <desrt> with get/put?
00:10:34 <shapr> if pop is effectively '(x:xs) <- gets ; puts xs' and push is 'xs <- gets ; puts x:xs' then, yes, something like that
00:11:08 <desrt> nod.
00:12:36 <desrt> ERROR "stack.hs":3 - Undefined type constructor "State"
00:12:39 <desrt> oh screa it
00:12:42 <desrt> *screw
00:12:44 * desrt goes to bed already
00:17:30 <shapr> gutenmorgen Joachim 
00:56:44 <Pseudonym> When is ICFP?
00:57:48 <shapr> the contest is just before europython/eurohaskell I think
00:58:28 <andersca> hey shapr
00:58:39 <shapr> hej andersca
01:09:45 <Pseudonym> Must away.  Nytol!
01:12:23 <shrimpx> any of you guys doing the contest?
01:13:05 <shapr> w00, Satnam Singh says a totally free release of Lava is a coulpa months out.
01:13:20 <shapr> yay! I can shop for Xilinx PCI boards now.
01:13:27 <shapr> wagle: y0, did you get that?
01:15:17 <andersca> wow, cool!
01:16:09 <shapr> that'll be the ultimate coprocessor
01:16:42 <andersca> running hOp on a haskell processor
01:16:52 <shapr> whoa, I hadn't thought of that...
01:16:54 <shapr> !
01:35:46 <shapr> hi tot
01:35:53 <tot> hello
01:35:58 <shapr> what can we do for you?
01:36:06 <tot> well, i've got a question ;)
01:36:14 <shapr> ok, what is it?
01:36:36 <shapr> andersca: what's your website?
01:37:24 <tot> i'm learning haskell for fun (and i know prolog already), and now i'm writing recursive function my_map
01:37:30 <andersca> shapr: http://ridley.csbnet.se/
01:38:08 <tot> the question is: what is the reason of using () in following: my_map z (x:xs) = ?
01:38:54 <tot> in prolog you write my_map(z, [x|xs]):- and so on
01:39:27 <kosmikus> the parentheses are only for grouping
01:39:30 <tot> why should i use () in (x:xs), what is the meaning of () in this case?
01:39:51 <tot> kosmikus: but i MUST use it, right?
01:40:14 <kosmikus> yes, but only to tell the parser how the arguments are separated
01:40:31 <kosmikus> to match on the first two element on a list, you could write
01:40:34 <tot> kosmikus: what if i write my_map z x:xs - what would it mean?
01:40:38 <kosmikus> my_fun (x:y:ys) = ...
01:40:47 <andersca> tot: it would be a syntax error
01:40:55 <tot> kosmikus: i understand
01:41:07 <tot> andersca: i know, but why? ;)
01:44:20 <kosmikus> in Haskell, function application is denoted by a space and binds stronger than everything else, therefore everyone used to Haskell would read above definition as (my_map z x):xs = ..., which does not make sense. Although in this particular situation the only sensible interpretation is my_map z (x:xs) = ..., the Haskell compiler forces you to write the parentheses
01:45:22 <earthy> why would (my_map z x):xs not make any sense?
01:45:46 <tot> kosmikus: well, know i understand ;)
01:46:05 <earthy> (given e.g. my_map :: (a -> b) -> a -> b
01:46:06 <earthy> )
01:46:09 <tot> kosmikus: thanks
01:46:53 <tot> that's exactly what i wanted to know ;)
01:47:44 <kosmikus> earthy: it wouldn't make sense on a left hand side
01:48:03 <tot> thanks once more ;)
02:32:41 <tot> i've just wrote function to calculate fibonacci number's, but due to it's recursive nature it works extremely slow
02:33:49 <tot> now i'm trying to write the same function using lists, but looks like i'm missing something important
02:33:49 <tot> here is my function
02:33:49 <tot> fib2 1 = [1]
02:33:49 <tot> fib2 2 = [1,1]
02:33:49 <tot> fib2 n = let tmp = fib2 (n-1)
02:33:51 <tot>          [head(tmp) + head(tail(tmp))] ++ tmp
02:33:58 <tot> problem is in last line
02:34:04 <Lor> "written", "numbers", "its", and, while I'm being anal, "slowly"
02:35:10 <Lor> That's an interesting approach.
02:35:33 <andersca> fib = 1:1:zipWith (+) fib (tail fib)
02:35:46 <Lor> andersca, 0:1:...
02:35:51 <andersca> ah, sorry
02:36:08 <Lor> Whenever you can start counting something from zero, do so. :)
02:36:45 <Lor> tot, it doesn't look horribly slow.
02:37:29 <Hyp3rion> tot there are faster ones
02:37:37 <Hyp3rion> can i paste to this channel?
02:37:51 <Lor> If it's more than a couple of lines, use the paste page.
02:38:06 <Hyp3rion> oh. okay...
02:38:45 <Lor> tot, you only calculate each number in the list once, so it's approximately as fast as andersca's version.
02:39:04 <Hyp3rion> no need to paste
02:39:05 <Lor> Of course the problem is that you only get a partial reversed list of fibonacci numbers, not _all_ of them.
02:39:13 <Hyp3rion> i found the original URL:
02:39:16 <Hyp3rion> tot, http://cubbi.org/serious/fibonacci/haskell.html#f3b
02:39:41 <Hyp3rion> and check out hhttp://cubbi.org/serious/fibonacci.html too
02:40:25 <tot> ok
02:40:26 <Hyp3rion> "algorithm 3b" is the fastest imho, because binets formula uses floating point numbers, and matrix equations too :-(
02:41:05 <andersca> tot: also, you don't have to use ++
02:41:21 <tot> : ?
02:41:34 <andersca> tot: you can just do ((head tmp) + (head (tail tmp)):tmp
02:41:36 <andersca> yeah
02:44:20 <Lor> And you can do let tmp@(a:b:_) = fib2 (n-1) in (a+b):tmp
02:44:26 <Hyp3rion> Lor, F(0) = 1 - Mathematical Handbook 2nd ed., G. Korn, T. Korn, 1968. paragraph 8.7-2
02:44:34 <Lor> Bah.
02:44:37 <Hyp3rion> Lor, or am i wrong?
02:44:41 <Lor> It's so much neater when it starts with 0.
02:44:49 <Hyp3rion> :-/
02:44:50 <Lor> It's just a matter of convention.
02:44:53 <Hyp3rion> i dunno
02:45:14 <Hyp3rion> wait i test with mathbot ;-)
02:45:42 <Hyp3rion> LOL
02:45:47 <Hyp3rion> <Hyp3rion> Fibonacci[0]
02:45:48 <Hyp3rion> <mathbot>  0
02:46:08 <Hyp3rion> mathbot is using Mathematica, so sorry Lor :-?
02:46:52 <Lor> http://www.research.att.com/projects/OEIS?Anum=A000045
02:46:55 <Lor> Begins with 0.
02:47:05 <Hyp3rion> well its a matter
02:47:22 <Hyp3rion> of whether the first element of a list is #1 or #0
02:47:55 <Hyp3rion> 0 is Haskell
02:48:08 <Lor> Huh?
02:48:16 <Hyp3rion> Prelude> [1,2,3] !! 0
02:48:16 <Hyp3rion> 1
02:48:24 <Lor> I don't think that's relevant here.
02:48:41 <Lor> We're discussing what is the first fibonacci number, not what its index in a list is.
02:49:02 <Hyp3rion> Lor, think of andresca's version
02:49:10 <Hyp3rion> fib = 1:1:zipWith (+) fib (tail fib)
02:49:13 <Hyp3rion> ^^^ its a list
02:49:20 <Hyp3rion> you query it with !! n
02:49:27 <Lor> Yeah, but how is that relevant?
02:49:31 <Hyp3rion> to get the Nth fibonacci number
02:49:39 <Hyp3rion> in Haskell
02:49:46 <Hyp3rion> you need !! 0 to get the first
02:50:14 <Lor> My question is not what is fib(0) or fib(1) or whatever, but what is the _first_ fibonacci number, no matter how it is indexed.
02:50:14 <Hyp3rion> which is 1
02:50:35 <Hyp3rion> "_first_" "no matter how it is indexed"?
02:51:09 <tot> looks like Fibonacci is really popular here ;))
02:51:16 <Hyp3rion> yay
02:51:25 <Hyp3rion> Lor, i guess both of us are right
02:51:27 <shrimpx> Hyp3rion: ya, there's nothing confusing about lor's question
02:51:43 <Hyp3rion> debian, heh
02:51:48 <shrimpx> he's wondering if the fib numbers are 0,1,1,2,3,... or 1,1,2,3,...
02:52:04 <Hyp3rion> shrimpx, all a matter of indexing!
02:52:07 <Hyp3rion> yay
02:52:15 <Hyp3rion> its a question like
02:52:24 <debian> :)
02:52:24 <Hyp3rion> 0 e N or not...
02:53:07 <Lor> Actually, I have a hard time coming up with a more pointless argument than this one. :)
02:53:20 <shrimpx> it's not how you index. it's what the value of (head fibs) is
02:53:24 <Hyp3rion> Lor, agreed!
02:53:30 * shrimpx is all about pointless arguments
02:53:36 <Hyp3rion> shrimpx, wait
02:53:40 <Hyp3rion> 0,1,1,2,3,...
02:53:50 <Hyp3rion> what is the index of "0" in your list?
02:53:56 <Hyp3rion> 0 in Haskell
02:53:59 <Hyp3rion> 1 in Mathematics
02:54:14 <Hyp3rion> but its really pointless
02:54:38 <shrimpx> indeed
02:54:48 <Hyp3rion> http://en.wikipedia.org/wiki/Fibonacci_number
02:54:54 <debian> indeed
02:55:08 <Hyp3rion> http://cubbi.org/serious/fibonacci.html
02:55:18 <Hyp3rion> they contradict
02:55:22 <Hyp3rion> :-D
02:56:40 * debian thinks: geekiness has no boundary
02:57:41 <tot> anyway, tell me, where' the error in this line: ((head tmp) + (head (tail tmp)):tmp
02:57:52 <Hyp3rion> heh
02:57:58 <Hyp3rion> tot, you need a final :[]
02:58:19 <Hyp3rion> tot, dont aky me why!
02:58:30 <shrimpx> tot: you need to index starting at 0
02:59:10 <Hyp3rion> 1:2:3 is not a list
02:59:10 <tot> Hyp3rion: no, i don't ;) 1:2 works perfect without :[] ;)
02:59:18 <Hyp3rion> 1:2:3:[] IS!
02:59:31 <Hyp3rion> tot, what?
02:59:39 <tot> ok
02:59:39 <tot> you right ;)
02:59:39 <Hyp3rion> Prelude> 1:2:3
02:59:39 <Hyp3rion> <interactive>:1:
02:59:39 <Hyp3rion>     No instance for (Num [a])
02:59:42 <Hyp3rion> ...
02:59:47 <tot> but anyway
02:59:48 <Hyp3rion> Prelude> 1:2:3:[]
02:59:48 <Hyp3rion> [1,2,3]
02:59:54 <tot> ((head tmp) + (head (tail tmp)):tmp:[] - doesn't work either
03:00:07 <Hyp3rion> shrimpx, is right too!
03:00:12 <shrimpx> since tmp is a list, he doesn't need []
03:00:22 <Hyp3rion> yay
03:00:44 * Hyp3rion <== wrong
03:01:12 <tot> ok, guys, all of you right, and i'm only left ;) i just want to know why ((head tmp) + (head (tail tmp)):tmp:[] doesnt work ;)
03:01:20 <Hyp3rion> tot, use this one http://cubbi.org/serious/fibonacci/haskell.html#f3b   your gonna me dead slow
03:01:46 <shrimpx> tot: tmp is a list and [] is a list (:) is not defined on two lists
03:01:47 <Lor> tot, because tmp is a list already.
03:02:03 <tot> ok
03:02:06 <Lor> shrimpx, yes it is, _provided_ that the right-side operand is a list of lists. :)
03:02:19 <shrimpx> heh :)
03:02:51 <shrimpx> k two lists of equal depth
03:02:57 <tot> well... it tmp is a list, then i don't need :[] at the edn
03:03:15 <shrimpx> Prelude> let t = [1,2,3] in (head t + head (tail t)):t
03:03:15 <shrimpx> [3,1,2,3]
03:03:27 <tot> 1:[2,3] => [1,2,3]
03:47:53 <tot> fib3 n = ((head tmp) + head(tail tmp)):tmp
03:47:53 <tot>          where tmp = fib3 (n-1)
03:47:53 <tot>  - this one works, at last! ;)
03:48:52 <tot> Lor but your let tmp@(a:b:_) = fib2 (n-1) in (a+b):tmp i like much better ;)
03:53:15 <shapr> g'day clausen 
03:53:21 <clausen> gday shapr
04:05:30 <shapr> Heffalump: hey, you think you'll be at EuroHaskell?
04:06:51 <shapr> hi Iter 
04:10:36 <Iter> hey shapr :)
04:13:22 <Iter> oh wow, 16 degrees... it must be winter ;)
04:14:09 <shapr> 16c?
04:14:20 <shapr> 16° alcohol? :-)
04:15:59 <bringert> wow, 16 degrees, you must have been at the university forever
04:17:25 <Iter> shapr: yeah, 16c.  btw.  Does anyone know what the correct citation for Earley's original paper is?  I'm finding conflicting citations.
04:17:58 <vegai> wow, 13 degrees. Time to wear shorts
04:18:08 <Iter> That would be "An Efficient Context-Free Parsing Algorithm"
05:34:51 <maym> lo
05:35:05 <shapr> bonjour
05:35:22 <shapr> les suedoise sont tres jolie
05:35:35 <maym> huum yeah
05:35:35 <maym> ,-
05:36:54 <shapr> les française sont aussi tres jolie. et les allegmagne aussi (how do I make that feminine?)
05:37:10 <shapr> ma fiancée est française et allegmagne
05:38:49 <shapr> so, maym, you coming to EuroHaskell?
05:46:59 <rubix_> les allemandes, shapr
05:47:09 <shapr> merci :-)
05:47:21 <rubix_> de rien :)
05:48:53 <shapr> salut rubix_, escris tu plus avec GoOnCube?
05:49:13 <rubix_> what is GoOnCube ?
05:49:55 <shapr> weren't you writing the HOpenGL go game?
05:49:58 * shapr is confused
05:50:12 <shapr> ack
05:50:15 <shapr> sorry, I was wrong
05:50:41 <rubix_> well, this was just an idea I had one day, but I have 0 lines of code :)
05:50:59 <rubix_> I have no time for this right now
05:51:02 <shapr> ok
06:17:15 <SamB> shapr: oh. for some reason I had assumed there was a reason for them all being together ;-)
06:17:37 <shapr> SamB: I hadn't used cvs much when I started haskell-libs, that's the only reason
06:17:45 <shapr> I now wish I had been thinking ahead when I did that
06:18:06 <shapr> it's been on my TODO list for months to break haskell-libs apart into separate projects
06:19:10 <SamB> shapr: what does this have to do with http://www.scannedinavian.org/repos/hlibs/ ?
06:19:28 <shapr> they're technically the same thing
06:19:31 <shapr> one in cvs, one in darcs
06:20:12 <shapr> I grabbed the cvs repo and stuffed it into darcs as an early test of darcs
06:20:37 <andersca> http://www.cairographics.org/hscairo
06:20:37 <andersca> yay
06:20:54 <SamB> with cvs, it isn't really a problem, afaict, because you can grab subtrees...
06:21:23 <SamB> or even a real annoyance
06:21:54 <desrt> gwar
06:21:58 <desrt> *angry sounds*
06:22:16 <shapr> gwar is a great band
06:22:22 <shapr> hiya gintas 
06:22:27 <desrt> i don't get the state monad :(
06:22:52 <shapr> have you read the nomaware tutorial?
06:23:15 <desrt> ya
06:23:28 <shapr> didn't help?
06:23:33 <desrt> i'm trying a demo progrma and i can't get it to print stuff
06:23:52 <desrt> push :: a -> State [a] ()
06:23:57 <desrt> pop :: State [a] a
06:24:01 <desrt> these are right, right?
06:24:10 <shapr> looks right to me
06:24:21 <desrt> i imagine my implimentation is right too, then
06:24:24 <desrt> but i say:
06:24:31 <desrt> five = (push 5 >> push 10 >> pop >> pop)
06:24:34 <desrt> and don't get 5
06:24:46 <desrt> i imagine because i'm returning some state along with it...
06:25:01 <desrt> and ghci doesn't know how to Show the state
06:25:07 <shapr> what about using >>= instead?
06:25:24 <shapr> makes any difference?
06:25:30 <desrt> i doubt it
06:25:40 <shapr> do you have the sources online?
06:25:43 <desrt> actually, ya
06:25:46 <desrt> now it doesn't build :)
06:26:04 <desrt> needs to be >> so that pop/push don't take each others return values as their arguments
06:26:24 <shapr> oh, right
06:26:27 <desrt> http://www.desrt.ca/state.hs
06:29:05 <ozone> shapr: are you familiar with arrows?
06:29:30 <shapr> for a very small definition of familiar, sure.
06:30:31 <desrt> hehehe
06:30:35 <desrt> cale just came in and fixed my problem in about 10 seconds
06:30:39 <shapr> yay!
06:30:40 <shapr> what was it?
06:30:45 <desrt> i can't just say five
06:30:49 <desrt> i need to say runState five []
06:30:58 <shapr> ohh
06:31:05 <desrt> in all fairness cale put 'runState five' and i told him he needed the [] :)
06:31:09 <shapr> I knew you needed to apply it to an initial state somehow
06:31:17 <desrt> i had tried five []
06:31:25 <desrt> and five = (push >> etc >> pop) []
06:31:28 <shapr> yah, that's what I was just doing
06:31:40 <shapr> hammers don't fix type systems.
06:31:51 <shapr> ozone: what's your question?
06:32:18 <shapr> ozone: deep understanding I can't claim, only lots of reading and ability to parrot most of what I've read
06:32:34 <ozone> shapr: i'm wondering how different they are to monads
06:32:48 <ozone> i think a diagram for monads (similar to the one on the arrows webpgae) would be helpful
06:33:04 <ozone> i understand they're more general than monads, but don't specifically know how.
06:33:19 <shapr> hey, did you guys have jokey smurf on tv there in .au?
06:33:34 <ozone> jokey smurf?
06:33:36 <shapr> or maybe you have those party poppers where you pull the string and paper ribbons fly out?
06:33:44 <ozone> yeah, we have those
06:33:58 <shapr> ok, the only way to know anything about what's inside those is to pull the string
06:34:02 <shapr> monads are the same
06:34:22 <shapr> with arrows, the popper has a nice clear outside, so you don't have to pull the string to see what you might get :-)
06:34:39 * shapr gives himself a gold star for bizarre analogy of the day
06:34:54 * ozone awards shapr another gold star, and goes to read Paterson's paper :)
06:35:01 <shapr> monads don't have any static properties you can check
06:35:03 <shapr> you have to call them
06:35:19 <shapr> the motivating example Hughes gives is a space leaks in a parse
06:35:21 <shapr> parser
06:35:59 <shapr> you know that sometimes you have to recurse zillions of calls down into a bunch of parser monads, and even so, you have to carry the whole string with you because something just might fail
06:35:59 <ozone> okie
06:36:11 <ozone> do you recommend reading the hughes paper, or paterson's one?
06:36:19 <ozone> yes
06:36:27 <andersca> http://www.haskell.org/arrows/ is a good page 
06:36:41 <ozone> yeah, had a look at that.  i'm still not very enlightened
06:36:50 <shapr> with arrows, you save a whole bunch trouble because an arrow parser combinator can statically tell you a lot about what it can accept
06:37:06 <shapr> monadic parsers + static properties = lots of space saving
06:37:15 <ozone> hmm, ok
06:37:18 <ozone> i'll keep that in mind
06:37:22 <SyntaxNinja> shapr: there's a guy on a unicycle on the front page of the student newspaper today
06:37:44 <shapr> you can even float all those static properties up to the top level of the combined arrow if you want, and save lots of trouble
06:38:15 <ozone> hey isaac
06:38:27 <shapr> SyntaxNinja: does the paper have a website?
06:38:28 <ozone> shapr: right
06:38:36 <ozone> i'll have a looksie now then
06:38:41 <ozone> thanks for the tips
06:39:00 <ozone> hmm, "hyperfunctions" eh :)
06:39:06 <shapr> er, yeah!
06:39:11 <shapr> they are!
06:39:18 <shapr> did you just think of that?
06:39:32 <SyntaxNinja> shapr: thelantern.com
06:39:59 <shapr> nifty :-)
06:40:46 <shapr> looks like a 24" wheel and a nice frame that I can't see enough of to tell you the manufacturer
06:43:31 <earthy> I'd go with the patterson paper as the road to arrows, myself
06:44:13 <shapr> ozone: in any case, if you get a good handle on them, please explain them to me ;-)
06:45:12 <ozone> shapr: will do, sir!
06:46:18 <shapr> yay!
06:56:32 <ozone> damn that category theory
06:57:08 <ozone> in 30 years, when the earth has run out of oil, we'll probably find the answer to our energy crisis and discover that category theory had it about 200 years ago
07:01:36 <earthy> ;)
07:01:50 <earthy> but for the fact that category theory hasn't been around quite that long
07:04:38 <kosmikus> :)
07:15:16 * shapr yowdels
07:15:19 <shapr> @yow del!
07:15:20 <lambdabot> .. If I cover this entire WALL with MAZOLA, wdo I have to give my
07:15:20 <lambdabot>  AGENT ten per cent??
07:19:15 <ozone> right, my brain's starting to hurt as of about page 23
07:19:29 <shapr> what do you understand so far?
07:20:24 <ozone> not freaking much :)
07:20:35 <ozone> i'm going to need a few ... uhh, years, to soak all this in
07:20:53 <ozone> (i don't really think i'm quite up to speed with monads either)
07:28:52 <shapr> ozone: well, can you explain what parts you do understand?
07:32:17 <ozone> umm
07:32:24 <ozone> tell you what, i'll go read the paterson paper now
07:32:27 <ozone> and see what i can grok from that
07:32:31 <shapr> heh, ok
07:32:40 <ozone> i have a cloud forming in my head which tells me what their idea is
07:33:43 <ozone> it seems like they're monads, but instead of computations directly returning a value, you can define a function which takes the result of a monadic computation and returns a value
07:33:52 <ozone> so the result of the computation can be of type a
07:34:00 <ozone> but the end-result is actually of type b
07:34:10 <ozone> and you can go from type a to type b by passing the monadic thingy a function
07:34:21 <ozone> but anyhoo, i'll go read this and see if i get a better freaking idea
07:34:39 <ozone> if i'm not back in about 16 hours, you can assume my brain has actually exploded, please send ambulance, jaja
07:35:01 <shapr> heh
07:35:14 <shapr> I think hyperfunctions was a great description
07:35:26 <shapr> or metafunctions maybe
07:47:23 <shapr> konichiwa juhp-san
07:47:31 <shapr> ohio gozymas
07:47:36 <juhp> evening :)
07:47:44 <shapr> oh
07:47:46 <shapr> whoops
07:47:58 <juhp> how's it going?
07:48:08 <shapr> slowly
07:48:11 <shapr> how's it going with you?
07:48:39 <juhp> tired ;)
07:49:08 <shapr> written any Haskell lately?
07:49:13 <juhp> been juggling machine around
07:49:31 <juhp> not really
07:50:22 <juhp> looking forward to reading the Haskell C&A report though
07:50:32 <juhp> machines even
07:50:36 <ozone> shapr: my eyes started glazing over after seeing the first paragraph of hyperfunctions
07:51:31 <shapr> ozone: you know you can stick a function into a variable... let x = (\x -> x + 1) and you can manipulate that somewhat with flip and a few other tricks
07:51:46 <shapr> it seems to me that arrows are the next step along that path
07:52:24 <shapr> arr x -- turn our add one function into an arrow
07:52:33 <ozone> yeah, i understand that much
07:52:41 * shapr tries to think of something interesting to actually do to an add one function
07:52:45 <ozone> (the -> function application type can be made into an arrow)
07:52:55 <ozone> i still don't quite get what arrows are, though
07:53:12 <Rotty_> Q: how can i convert a string (charlist) to an integer?
07:53:27 <shapr> Char.ord
07:53:48 <Rotty_> isn't this just char -> integer?
07:53:59 <shapr> yup
07:54:02 <ozone> Rotty_: charsToInts list = map Char.ord list
07:54:36 <Rotty_> ozone: i want (strToInt "123") yield 123
07:54:42 <ozone> oh.
07:54:54 <ozone> i'm guessing this is for an assignment?
07:55:01 <Rotty_> do i really have to code that by hand?
07:55:14 <ozone> Rotty_: no, not at all.
07:55:25 <Rotty_> i thought there must be an standard function
07:55:26 <ozone> is this part of a larger problem, or is this a homework question?
07:55:32 <Rotty_> both
07:55:42 <ozone> hmm
07:55:47 <ozone> ok, you want 'read'
07:55:49 <Rotty_> so, it's part of a homework problem
07:55:59 <ozone> (read "123" :: Int) == 123
07:56:08 <shapr> ozone: what sort of answer are you looking for to "what's an arrow" ? do you have an answer to "what's a monad" ?
07:56:29 <ozone> you need to put the :: Int after "read x", because you could read it as lots of things (int, char, arbitrary data type)
07:56:46 <ozone> shapr: i have a firmer grip on what a monad is for, yeah
07:56:49 <ozone> arrows, i don't
07:57:02 <Rotty_> ozone: thanks a lot!
07:57:12 <shapr> can you give the answer for monads?
07:57:21 <ozone> i mean, you could say that a monad is anything which satisfies the three monad laws, but that's not particularly useful
07:57:56 <ozone> so i think of monads as a means of representing computations, where you can plumb state from one computation to the next
07:58:10 <ozone> this seems to be the general consensus as to what monads are for
07:59:17 <ozone> from what little i've read about arrows so far, it seems that they're monads, but instead of plumbing state from one computation to the next, a computation can return something of another type which the next computation can use to determine what to do
07:59:36 <ozone> but i'm betting that my thinking is too specific, or just plain wrong :)
07:59:59 <shapr> they're first class transformations maybe?
08:00:07 <shapr> much like functions?
08:01:11 <ozone> maaaaayyyyyyybe?
08:04:32 <ozone> so, if you have a monadic function, then you could write something like
08:04:34 <ozone> a >>= \aR -> b aR >>= \bR -> c bR >>= ...
08:04:46 <ozone> (capital R is an abbreviation for "result")
08:04:58 <ozone> i think with arrows, you can do something like:
08:04:59 <ozone> a >>= \aR -> (?? produces aR') -> b aR' >>= \bR -> (?? produces bR') >>= c bR'
08:05:11 <ozone> i'm not entirely sure though.
08:09:23 <shapr> hej ski
08:09:33 <andersca> hey ski
08:09:44 <ski> hejhej
08:09:57 <shapr> ozone: a b c is an arrow a that takes a b and turns it into a c
08:10:37 * ski usually writes such as "ar a b"
08:10:46 <shapr> yah, easier to read
08:11:03 <shapr> ar a b >>> ar b c = ar a c
08:11:11 <ozone> so the aR/bR/cR thingys in that arrow example i wrote above are of type b, and aR'/bR'/cR' are of type c?
08:11:44 <andersca> arr
08:11:46 <andersca> @arr
08:11:46 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
08:12:45 <shapr> a >>> ar aR aR' >>> ar bR bR' >>> c
08:12:46 <shapr> ?
08:13:36 <ski> shapr : (_ :: ar a b) >>> (_ :: ar b c) :: ar a c
08:15:04 <ozone> the thing i don't get is:
08:15:09 <ozone> monads can have state
08:15:39 <shapr> that's because they've got their input
08:15:47 <ozone> why can't you replace the "a -> b" function in an arrow "ar a b" with a state?
08:16:12 <shapr> ?
08:16:23 <ozone> i mean, execute a different computation based on the output of the last computation based on the current state
08:16:28 <ozone> i'm definitely not getting something
08:16:39 <shapr> oh, that's already done with Yampa
08:16:51 <shapr> yampa has switchy arrows
08:17:46 <ski> ar a c -> ar b c -> ar (Either a b) c  ?
08:17:49 * ozone scratches head
08:18:07 <shapr> http://www.haskell.org/yampa/
08:18:14 <shapr> that's heavy duty nifty stuff
08:18:49 <shapr> those guys realized you can't easily use Haskell to do real-time processing like robotics, because you always end up with space leaks somewhere
08:19:01 <shapr> they had that problem with every monadic framework they tride
08:19:02 <shapr> tried
08:19:39 <shapr> so they switched to using an arrow-based framework where the signals are not directly manipulated, you just get to use signal transformers
08:19:42 <shapr> and it works!
08:19:56 <ski> yay
08:19:57 <shapr> there's a neat robot soccer demo for Yampa
08:20:37 <shapr> from everything I've read about the advantages of arrows and Yampa, I think it'd be perfect for a real-time strategy game like warcraft
08:21:00 <shapr> bonjour mij, comment ça va?
08:21:06 <shapr> mij: looking for Haskell info?
08:22:13 <shapr> I was very happy to meet Henrik Nilsson at ICFP03
08:28:48 <ozone> ok
08:28:55 <ozone> off to bed then, nite!  thanks for the help shapr
08:31:55 <Etaoin> how is an arrow different from a function?
08:32:34 <ski> a function is an arrow, but an arrow is not necessarily a function
08:32:43 <bringert> only one exam left!
08:32:43 <Etaoin> why not
08:32:49 <bringert> (and a thesis)
08:35:21 <ski> Etaoin : e.g. hmm, maybe ..  data Foo a b = F (a -> b) (b -> a)
08:37:57 <ski> Etaoin : i think the concept is related to morphisms in category theory
08:38:21 <Philippa_> you mean the things otherwise known as "arrows" in it? :-)
08:38:30 <ski> yes ;)
08:38:44 <Philippa_> which reminds me, I need to learn more of it
08:39:04 <ski> you do that. it's fun !
08:39:05 * Philippa_ has some notes gmh gave her from a course he did for the midland graduate school...
08:39:32 * ski hasn't seen any formal definition of Hughes-arrows
08:39:50 <ski> gmh ?
08:39:52 <Philippa_> isn't there something mentioned on the arrows site as being the equivalent?
08:39:56 <Philippa_> Graham Hutton
08:40:01 <ski> mhm
08:40:17 <ski> sorry ? (".. as being the equivalent?")
08:41:26 <Philippa_> well, the same as. Second paper under "Related theoretical work" on www.haskell.org/arrows/biblio.html
08:42:05 <Philippa_> "Freyd-categories"
08:42:08 <ski> "Here is an incomplete list of theoretical papers dealing with structures *similar* to arrows."
08:42:12 <Philippa_> 'lo shapr
08:42:15 <ski> wb shapr
08:42:20 <Philippa_> I keep meaning to have another chat with Henrik
08:42:35 <Philippa_> I mean, he's working just up the road atm
08:42:42 <Philippa_> ski: read on further
08:43:58 <Philippa_> <shapr> from everything I've read about the advantages of arrows and Yampa, I think it'd be perfect for a real-time strategy game like warcraft <- why RTS specifically?
08:44:46 <earthy> okay, the way I currently think about arrows is as follows: whereas with monads you only have sequential composition of monadic computations, with arrows you can have any composition of arrowized computation that you'd like
08:45:19 <earthy> so, if wanted, you could take two arrowized computations and build a new arrowized that does the two computations in parallel
08:45:25 <Philippa_> yeah
08:45:32 <earthy> +computation somewhere
08:45:32 <Philippa_> hence the infamous "static info" case
08:45:37 * earthy nods
08:45:49 <ski> earthy : can't you have that with special cases of monads, too ?
08:46:06 <earthy> ski: in monads you *only* have sequential composition
08:46:07 <Philippa_> yeah, but the special case is considerably more special
08:46:23 <earthy> in arrows you have injection into a product
08:46:25 <earthy> as well
08:46:35 <ski> earthy : in general monads you can't "escape"  (you can in some particular ones)
08:46:54 <earthy> well, you can't escape arrows either, in general
08:47:04 <ski> right
08:47:05 <earthy> but you have a finer structure
08:47:27 <earthy> so, with a monad   M a   you have a computation returning a
08:47:46 <earthy> with an arrao  A a b   you have a computation *from* a to b
08:47:52 <earthy> arrow, even
08:47:54 <ski> but can't we have some kind of class Monad m => MonadPar m where parM :: m a -> m b -> m (a,b) .. ?
08:48:05 <earthy> ski: that'd be *extremely* difficult, yes
08:48:23 <earthy> as the `bind` operator (or (>>) ) is sequential
08:49:07 <ski> just don't use it, then
08:49:21 <earthy> but then you lose all the nice monadic stuff ;)
08:49:24 <Philippa_> that's one hell of a degenerate monad you got
08:49:58 <earthy> anyway, I've had one beer too many
08:50:03 <earthy> time to go get home :)
08:50:05 <Philippa_> and two too few?
08:50:11 * earthy nods
08:50:12 <ski> of course you also need (>>=) at places, some there's still some logical sequencing
08:50:23 <earthy> but I still have to give a dance workshop this evening
08:50:28 <Philippa_> oops
08:51:47 <ski> earthy : (hmm, did you mean (>>=) when you said (>>) before ?)
08:52:38 <earthy> ummm.. yeah. :) sorry. :)
08:52:46 <earthy> `bind`. ;)
08:53:44 <earthy> but I'm off.
08:53:52 <ski> ok
08:55:37 <ski> in some paper they wanted ap :: Monad m => m (a -> b) -> m a -> m b to be in class Monad, because they wanted to overload the standard definition with a more non-sequential one
08:59:29 <shapr> Philippa_: warcraft because each unit needs its own 'thread' and a whole bunch of arrows would be very efficient for that
08:59:45 <shapr> never have to call empty functions that check for damage, etc
09:00:27 <shapr> Philippa_: ok, honestly it's because warcraft III pissed me off to no end because it scales so badly with number of units
09:00:50 <Philippa_> heh
09:01:19 <shapr> we were playing on a pair of 800MHz machines, and they would crash with more than 6 players.
09:01:45 <shapr> everytime you got more than N units on-screen at the same time, you suddenly got 1 frame every five seconds
09:02:18 <shapr> and I realized... whatever algorithm they use scales badly
09:04:04 <shapr> so now I want to start a game company and use Haskell, QuickCheck, and XP to write decent games :-P
09:04:11 <Philippa_> ah. That'll be at least partly the networking - RTS networking's generally synced-sim p2p
09:04:54 <Philippa_> and that in turn means it has to prioritise the sim over rendering
09:06:17 <Hyp3rion> sorry to interrupt... shapr, XP? 8-o
09:06:25 <shapr> eXtreme Programming
09:06:51 <Hyp3rion> :-D
09:07:02 <Philippa_> do lemme know any time you're hiring btw ;-)
09:07:12 <shapr> can you write Haskell ;-)
09:07:32 <Philippa_> Haskell
09:07:34 <Philippa_> yeah, guess I can
09:07:41 <shapr> oy!
09:07:54 <Hyp3rion> wow! RTS games (for Linux?) in Haskell! that'd addictive.
09:08:10 <shapr> could be nifty, I agree
09:08:26 <shapr> in fact, we set up an email list as part of the haskell-libs project
09:09:04 <shapr> but then one of my former business partners decided to do a crash and burn to her life and I got distracted.
09:09:25 * Philippa_ nods
09:09:28 <Philippa_> happens
09:09:56 <Philippa_> am narrowly avoiding the burn part myself right now, don't know where I'll be living in a couple of months
09:10:30 <Smerdyakov> Are you a student [almost] done with a degree?
09:10:40 <Philippa_> almost
09:10:47 <Philippa_> unfortunately I'll be back to finish it off in January
09:11:00 <Smerdyakov> For another year?
09:11:02 <Philippa_> need to stay in Nottingham 'til then, too
09:11:09 <Philippa_> for one more semester
09:12:05 <Smerdyakov> Undergrad?
09:12:35 <Philippa_> yeah
09:12:42 <Smerdyakov> Undergard sucks because they don't pay you.
09:12:57 <Philippa_> yeah, and I don't get any more student loan 'til september
09:13:10 <Philippa_> though as it happens I'm just about OK there. The bigger problem's my boyfriend, who doesn't have any other income
09:13:29 <Smerdyakov> How about taking a job and splitting your requirements among two semesters?
09:13:45 <Philippa_> I can't split between semesters
09:13:50 <Philippa_> and I'm in no state to work at the moment
09:14:11 <Philippa_> really though, the biggest problem's housing
09:14:17 <Philippa_> can just about scrape by 'til september on credit
09:15:06 <Philippa_> I already know what my options are, it's just a matter of getting the hell on with it
09:16:03 <Smerdyakov> Maybe you should seek professional help for whatever it is that prevents you from working.
09:16:28 <Philippa_> maybe I'm doing all of that already?
09:17:05 <Smerdyakov> Maybe. I don't know!
09:17:58 <shapr> so part of my very long list is to sit down and try to figure out how to make an RTS arrow, or whether I can just hack the Yampa arrows into something I can directly use.
09:19:55 <Philippa_> yeah, one of the things that came up for me straight away looking at The Yampa Arcade was that half the paper was reinventing OO badly. Obviously that's the "getting things done" part rather than the interesting part...
09:21:37 <Philippa_> I have to admit I'm looking forward to seeing what Tim Sweeney's produced for the next UnrealScript
09:22:47 <shapr> yah, he's into Haskell, maybe we'll see something cool.
09:22:50 <Philippa_> the current one's a curious mix of elegance and "not-quite-there"
09:23:00 <Philippa_> um. My insiders say we /will/ see something cool :-)
09:23:06 <shapr> ah, that's good to hear
09:23:14 <shapr> any hints?
09:23:52 <Philippa_> a strong Haskell influence, and a type system fairly directly based on sets is all I can really remember
09:24:18 <shapr> hm, interesting
09:24:22 <Philippa_> oh, and that it's a significant improvement on the current UScript plus a few nice/obvious extras (parametric types etc)
09:24:43 <Philippa_> which says something given that in many ways UScript just needs a little polish to be really damn good already
09:25:01 <det> shapr: I didnt like WCIII becuase I could never manage to control all my units efficiently enough to not get my ass kicked!
09:25:18 <det> shapr: too much micromanagement, cast this spell use this item, blah blah
09:25:20 <Philippa_> that happens with most RTSes
09:25:29 <Philippa_> though the *craft series is particularly bad for it
09:25:30 <shapr> det: I designed ways to do things efficiently
09:25:48 <Philippa_> even without the spells you need a lot of maneauver
09:25:50 <shapr> my favorite combo so far is humans with healers, spellbreakers, and siege engines
09:26:18 <shapr> spellbreakers do way too much for their cost, and siege engines are good at antiair 
09:26:19 <det> I would like to make a RTS that was *really high level*
09:26:27 <det> mostly just direct the AI :)
09:26:32 <shapr> me too
09:26:45 <Philippa_> you mean one with actual S in it? :-)
09:26:50 <shapr> all those cyberpunk novels I read as a kid, where you preprogrammed the icebreakers
09:26:59 <det> Philippa_: EXACTLY
09:27:04 <Philippa_> I'd like to do RTT openly, myself
09:27:14 <Philippa_> where T=Tactics
09:27:15 <det> what is the second T?
09:27:21 <det> ahh, yes
09:27:23 <det> sounds fun
09:27:26 <Philippa_> ditch all the pseudo-operational crap
09:27:42 <shapr> so my idea was to write a strategy combinator library
09:27:59 <det> shapr: you crazy haskellers, a special tool for every program!
09:28:11 <shapr> nah, a way to program your units
09:28:16 <det> shapr: Function Ractive Arrows with Monadic covariance, HOW CAN MY RTS FAIL!
09:28:24 <det> :)
09:28:27 * shapr quotes that
09:28:42 <det> exacpt I can't type :(
09:28:44 <det> shamed forever
09:28:58 <det> "Functional Reactive Arrows"
09:29:22 <det> shapr: explain your ideas for a functional strategy combinators library
09:29:59 <Philippa_> and would it be strategy or tactics?
09:30:16 <shapr> if done right, both
09:30:17 <ski> det : why covariance ?
09:30:32 <det> ski: I spout non-sense
09:30:38 <det> ski: YOU ARE MY FIRST VICTIM
09:30:54 <ski> oh
09:31:00 <Philippa_> shapr: much harder to do due to the concerns involved. Especially if your strategy includes any degree of diplomacy or politics
09:31:33 * ski turns pale
09:31:44 * shapr turns red
09:31:59 * det charged shapr
09:32:09 * ski turns a handle
09:32:15 <shapr> Philippa_: I haven't come with a decent design yet, combinator libraries are *hard* :-/
09:32:33 <shapr> or maybe I'm just too little, I don't know yet.
09:32:37 <ski> little languages and so on ..
09:32:43 <det> Philippa_: I see diplomacy and politics as concerns for the humans involved
09:33:30 <Philippa_> det: give or take, yeah. It's surprising how much negotiation can occur during the subtleties of conflict, and you at least need ways to pass on rough desires
09:33:47 <det> Philippa_: that's true
09:33:59 * Philippa_ wonders if anybody's found a design for a multiplayer Go that works
09:34:08 <det> Philippa_: "Dont enter my enemies territory unless at war"
09:34:21 <Philippa_> um, it's more than that
09:34:30 <shapr> I was thinking about writing flocking algorithms
09:34:50 <shapr> "don't attack that guy unless the total forces around you are likely to beat the forces around him"
09:35:07 <Philippa_> that'll cover some of the basics
09:35:23 <Philippa_> works well for squad-level stuff give-or-take - I used to play Counterstrike on a similar kind of basis
09:35:28 <det> shapr: and you complained about WCIII running too slowly :)
09:35:29 <shapr> anyway, read the second Yampa paper
09:35:43 <Philippa_> det: reactive agents are fast
09:35:45 <shapr> they talk about self-modifying arrows
09:36:07 <det> shapr: Philippa_ I cant say I know what those are
09:36:15 <det> erm
09:36:19 <det> s/shapr: //
09:36:51 <Philippa_> det: ones who work on a "you see it, you shoot it" basis rather than thinking too hard, IYSWIM
09:36:56 <det> Philippa_: can you really implement something like "don't attack that guy unless the total forces around you are likely to beat the forces around him" with them?
09:37:27 <det> Philippa_: oh, yes, but that is really simple
09:37:32 <Philippa_> if you've got an influence map, yeah. You can also do it via an "I'm considering this/I'm willing to join/are there enough of us?" protocol with them pretty easily
09:37:41 <bringert> my httpd log: "Fail: HTMLBase.hs:84: Non-exhaustive patterns in record update"
09:37:44 <bringert> dammit
09:38:14 <Philippa_> talked about it briefly at a talk at the first GDC Europe by the guys who wrote State of Emergency
09:38:19 <shapr> det: anyway, you don't distribute the game with that sort of logic, you distribute the game with stupid simple but working strategy
09:38:25 <shapr> it's real-time corewars
09:39:12 <shapr> if you explicitly treat it as a sort of robot wars, you could add vampiric units that would steal parts of the other team's 'orders'
09:39:26 <shapr> so you would have a motivation to play more skilled players to steal some of their code
09:40:41 * Philippa_ has sudden visions of integrating this with a Black&White-style training setup
09:40:48 <shapr> what's that?
09:41:23 <Philippa_> in B&W you can slowly train your god's creature to do things. Mostly just a primitive reward/punishment setup
09:41:39 <Philippa_> but you can eg teach it to throw shit at enemy cities, or help your villagers with their work
09:43:34 <Philippa_> now, imagine that with formations...
09:44:00 <shapr> I'd rather write the code explicitly
09:44:12 <shapr> or maybe add genetic variations
09:44:41 * Philippa_ nods
09:44:57 <Philippa_> could be interesting over the course of a campaign though
09:45:02 <shapr> yah, it could
09:45:13 <Philippa_> they'd learn from real experience too, of course
09:45:30 <shapr> would be a fun game to write, wouldn't it?
09:45:46 <Philippa_> yeah, 'cept I don't know anywhere near enough about learning algos :-)
09:46:00 <Philippa_> and I doubt the guy I know at Lionhead's gonna tell me how the creature AI works
09:46:03 <bringert> doesn't everything you print to stderr in CGI programs go to error_log?
09:46:05 <Philippa_> except possibly "it's a huge kludge"
09:46:26 <Philippa_> bringert: surely that's dependant on the web server?
09:47:08 <bringert> sorry, it was just me being stupid, recompiled the wrong thing
09:47:29 <bringert> Philippa_: you're probably right. in apache it seems to be that way anyway
09:47:45 <Philippa_> yeah, was nudging you in the direction of the relevant docs, 'sall
09:48:02 <Philippa_> if you think for a moment, it has to be - the web server sets up the context the CGI runs in
09:49:36 <bringert> well, the web server could of course decide to just have stderr go to /dev/null
09:49:47 <bringert> pretty stupid, but still
10:12:26 <shapr> heya stepcut, wossup?
10:21:10 <stepcut> not much 
10:21:24 <stepcut> plotting out how to add better hyperlinks to wash/cgi still
10:21:40 <stepcut> I am currently trying to figure out what the goals are :)
10:22:56 <shapr> goals for what?
10:23:06 <shapr> oh, for your web publishing code?
10:23:12 <stepcut> what I hope to achive, of course!
10:23:23 <shapr> right!
10:24:09 <stepcut> well, how I would like hyperlinks to behave in something like wash
10:38:21 <wagle> shapr: busy_wait ("ordered your xilinx yet?");
10:38:33 <shapr> heh
10:39:03 <shapr> the top of the line PCI card with 6million elements and 128mb of ram and lots of other goodies is only six thousand dollars!
10:42:25 <shapr> Compiling Kernel.Driver.Keyboard ( ./Kernel/Driver/Keyboard.hs, ./Kernel/Driver/Keyboard.o )
10:42:29 * shapr cackles happily
10:42:53 <shapr> mmmm, Haskell Operating System! yay!
10:43:01 <shapr> hm, same error again
10:49:50 <earthy> `only'
10:50:44 <andersca> yay, my expat bug fix was committed
10:52:23 * Philippa_ has finally grokked monads in terms of category theory. Took long enough...
10:52:48 * ski hasn't done that yet
10:53:01 * earthy either
10:53:07 <earthy> _n
10:53:10 <bringert> shapr: I've figured ouy why the dates in curryspondence were all funky
10:53:13 <Philippa_> it came pretty quickly having finally got functors and natural transformations courtesy of gmh's notes
10:53:17 <shapr> bringert: oh oh why?
10:53:31 <shapr> bringert: I'm sure it's my hackish conversion code...
10:53:38 <shapr> that I wrote in thirty seconds
10:53:42 <Philippa_> thankfully my intuition of "what they do" in an FP context still holds
10:53:43 <ski> (the first two, i've got)
10:54:04 <shapr> bringert: is that it?
10:54:14 <bringert> shapr: nope, nothing to do with date parsing or conversion
10:54:20 <shapr> oh
10:54:21 <shapr> what is it?
10:54:29 <bringert> it's something very silly
10:54:39 <shapr> ??????
10:54:46 <bringert> %M means minute, not month
10:54:49 * shapr can't stand the suspense
10:54:52 <shapr> uh oh
10:54:56 <andersca> heh
10:55:12 <shapr> well crap
10:55:16 <bringert> hence "2003-33-05" and such
10:55:22 <shapr> ok now...
10:55:28 <shapr> that was easy to fix :-)
10:55:31 <Philippa_> ski: you seen the categorical definition of a monad? If so, just remember a functor can be the composition of two functors - you can duck in and out of a second category, if that makes sense
10:55:32 <shapr> really hard to figure out though
10:57:08 <shapr> hej Marvin-- 
10:57:10 <shapr> wassup?
10:57:13 <ski> Philippa_ : i grokked natural transformations quite recently, so it could be that i just haven't looked at the definition of monads, since
10:57:18 <Philippa_> fair enough
10:58:45 * Philippa_ blinks
10:58:51 <shapr> yay, hOp is cooool
10:59:01 <shapr> Compiling Kernel.Driver.PS2 ( ./Kernel/Driver/PS2.hs, ./Kernel/Driver/PS2.o )
10:59:01 <Philippa_> I need to get my PS2 talking to a USB NIC at some point
10:59:12 <Philippa_> free up the box we're currently using from router duty
11:06:15 <Marvin--> hey
11:07:23 <shapr> Marvin--: how's code?
11:07:28 <Marvin--> shapr: what's up is that I'm trying to solve the problem set that's due next week in the randomized algorithms course
11:07:42 <Marvin--> haven't touched any code since Sunday, really
11:10:06 <shapr> oh
11:11:14 <Marvin--> right now it's pen & paper markov chains rather than haskell markov chains :)
11:11:34 <stepcut> :p
11:12:31 <Marvin--> ooh, our binary search simulated annealing algorithm for graph coloring turned out quite well
11:17:12 * Marvin-- grumbles and goes back to his pen and papers
11:20:35 <bringert> Marvin--: aarne ranta suggested that a hidden markov model library in haskell could be a useful eurohaskell sprint
11:20:48 <shapr> would be handy for speech recog as well
11:21:35 <Marvin--> hidden markov model?
11:21:53 <shapr> yup
11:31:18 <ski> 'lo esap
11:31:23 <esap> Hi!
11:31:38 <esap> What's up?
11:32:09 <ski> explaining FP (= evangelizing :) on another channel ;)
11:32:38 <shapr> oh, which channel?
11:32:57 <ski> shapr : #algos
11:33:27 <shapr> ah
11:50:30 <shapr> hoi arjanb 
11:51:31 * shapr throws dutch words around the channel
11:51:41 <arjanb> hallo
11:51:45 <shapr> `Verandering van spijs doet eten.'
11:51:52 * shapr is quoting earthy 
11:57:23 <shapr> arjanb: I think I've seen you here before, are you an experienced Haskell user?
11:57:42 <shapr> oh, I think I've seen you with dr_fripp et al
12:02:01 <arjanb> i haven't been here before and i'm not a haskell user (yet)
12:03:23 <shapr> arjanb: oh, my mistake
12:03:30 <shapr> arjanb: greetings! welcome to the world of pure code!
12:03:45 <shapr> are you learning Haskell for business or pleasure?
12:04:38 <Lukhas> hehe, shapr
12:05:00 <shapr> would you like the standard intro?
12:06:01 <arjanb> for study and pleasure
12:06:14 <shapr> oh, excellent
12:07:30 <shapr> if you have prior functional programming experience in lisp, erlang, ocaml, etc
12:07:40 <shapr> then the gentle intro will most likely work for you
12:07:48 <shapr> if not, the Yet Another Haskell Tutorial may be easier
12:07:51 <shapr> @learn
12:07:51 <lambdabot> http://www.haskell.org/learning.html
12:08:10 <shapr> those and other tourist attractions can be found at the url above
12:08:58 <shapr> do you have any immediate questions?
12:10:59 * Marvin-- smiles at shapr's pounce-fu
12:11:07 <shapr> jiihaa
12:11:10 * shapr pounces on Marvin-- 
12:11:14 <Marvin--> oof
12:11:21 * shapr is victorious!
12:11:24 <shapr> w00!
12:11:32 <shapr> it's been a long day :-)
12:11:52 <ski> lol
12:13:49 <Marvin--> this Knutby trial is plain weird
12:14:09 <bringert> sure is
12:14:27 <bringert> I don't understand a word of the newspaper articles about it
12:14:36 <shapr> ?
12:14:39 <bringert> who is the "Bride of Christ"?
12:14:56 <shapr> in catholicism?
12:14:59 * andersca knows that bringert buys and reads aftonbladet every day
12:15:06 * ski thinks the new testament talk about the concept
12:15:07 <bringert> shapr: no, in knutby
12:15:34 <shapr> the church is the bride of christ in the bible
12:16:13 <bringert> but in this weird knutby sect, the bride of christ was apparantely someone who was fscking the priest
12:16:15 <shapr> oboy, this chick flipped out
12:16:49 <bringert> you'd think christ would get pissed off
12:16:56 <ski> bringert : pastor, i think
12:17:29 <shapr> yah, christ is totally not about killing people.
12:18:27 <Marvin--> http://www.dn.se/DNet/jsp/polopoly.jsp?d=147&a=265356
12:18:57 <SyntaxNinja> Oo
12:19:04 <Marvin--> this story is full of nut cases
12:19:08 <shapr> so the woman who runs this sect is nicknamed the "bride of christ"
12:19:29 <Marvin--> I think so
12:19:36 <shapr> and the woman who killed the other woman, and tried to kill the neighbor thought she was doing the right thing.
12:20:18 <Marvin--> she appears to have been brainwashed by the priest, who was brainwashed by the "bride of christ"
12:20:52 <shapr> oookay
12:21:03 <Marvin--> or he claims to have been brainwashed anyway
12:21:31 <bringert> shapr: you've probably noticed that the tabloids have been all over this case for months
12:22:00 <shapr> no, I have the amazing ability to see everything around me except for tabloids
12:22:08 <cbus> ignore those tabloids
12:22:19 <cbus> thats the only way to remain sane ;)
12:22:21 <shapr> well, tabloids and skin magazines
12:22:41 * shapr tries to think of what else he ignores on a regular basis
12:22:48 <Marvin--> I would say that *all* media has been all over the case for months
12:22:51 <shapr> oh, ung vÃ¤nster
12:22:52 <bringert> just walking to class, I see the tabloid posters 5-10 times
12:22:58 <andersca> haha
12:23:09 <Marvin--> just look at the insane number of articles at dn.se
12:23:10 <shapr> one of the local heads of the ung vÃ¤nster live in the same apartment building as me
12:23:32 <shapr> he has a massive rastafarian cat in the hat style hat, and dreadlocks down to his butt
12:23:53 <shapr> I think it irritates him to live in the same building with an american.
12:24:01 <bringert> haha
12:24:06 <SyntaxNinja> eww TH tuple types are painful to traverse
12:24:06 <shapr> er "us citizen"
12:24:10 <SyntaxNinja> (not to change the subject)
12:24:14 <shapr> hehe!
12:24:46 <bringert> SyntaxNinja: any LIP stuff for EuroHaskell?
12:24:50 <bringert> we want work
12:25:15 <shapr> yah, give us some juicy bits
12:25:22 <shapr> is the next release out?
12:26:21 <SyntaxNinja> bringert: I'd accept travel to EuroHaskell to give a talk on LIP :)
12:26:28 <SyntaxNinja> (iknowiknow)
12:26:35 <SyntaxNinja> where's that T-shirt again?
12:26:47 <SyntaxNinja> the next release is Almost Out... we got darcs on cvs.haskell.org today :)
12:26:55 <shapr> http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg ?
12:27:07 <shapr> whoa cool!
12:27:13 <shapr> darcs on haskell.org! w00!
12:27:28 <SyntaxNinja> shapr: thanks... wanted to show that to mark.
12:27:40 <shapr> oh, is he standing next to you?
12:27:47 <shapr> Hello Mr Carrol Sir!
12:27:50 <SyntaxNinja> shapr: no, I mailed it to him. he's across the room
12:27:55 <shapr> oh, dang
12:28:22 <SyntaxNinja> there will be an announcement of the new proposed standard within days
12:28:27 <SyntaxNinja> (well, maybe early next week)
12:28:45 <shapr> is there new source up?
12:28:49 <SyntaxNinja> and a new prototype Real Soon Now. I'll have to get that darcs2cvs gateway going soon.
12:29:08 <SyntaxNinja> the source is cvs.haskell.org:~ijones/library-infrastructure (a darcs repo)
12:29:21 <SyntaxNinja> but maybe we'll put it someplace better soon... 
12:30:08 <SyntaxNinja> is there going to be anyone at EuroHaskell who uses nhc on a regular basis? :)
12:30:11 <SyntaxNinja> we could give them some work.
12:30:38 <shapr> it's not there
12:30:49 <shapr> oh, colon
12:31:39 <det> people still use nhc?
12:31:51 <shapr> it's handy for PalmOS I hear
12:32:04 * SyntaxNinja can't wait for lip-on-palm
12:32:10 <SyntaxNinja> btw, I'm thinking of changing the name of hte project :(
12:32:18 <shapr> to?
12:32:18 <SyntaxNinja> because it's Not Just Libraries Anymore
12:32:24 <shapr> oh
12:32:26 <SyntaxNinja> Maybe "Haskell Source Infrastructure"
12:32:30 <Marvin--> what, someone's been giving you lip over it? :-)
12:32:30 <shapr> HIP?
12:32:31 <shapr> oh
12:33:50 <SyntaxNinja> anyone have any ideas?
12:34:03 <SyntaxNinja> I wish I were in a community who fought like hell over names of stuff instead of shrugging ;)
12:34:04 <shapr> what else does it cover?
12:34:15 <shapr> Haskell Infrastructure Project? HIP?
12:34:38 <shapr> Haskell Infrastructure Project Extended?
12:34:56 <SyntaxNinja> libraries and tools, ya know? like you can use it to distribute exeuctable programs too
12:35:04 <shapr> hapt-get ?
12:35:08 <andersca> haha
12:35:22 <SamB> I like it ;-)
12:35:22 <Marvin--> sort of like distutils?
12:35:36 <SyntaxNinja> Marvin--: I was sorta calling it distutils for a while
12:35:42 <SyntaxNinja> but that name's taken
12:35:49 <Marvin--> there is that :)
12:35:52 <ski> Haskell Infrastructure Project Emanicipated ?
12:36:13 <shapr> Haskell Multicaster?
12:36:21 <vegai> Haskell Ynfrastructure Project Extended
12:36:22 <SamB> although hapt would be the *name*, and hapt-get would be a command
12:36:25 <vegai> don't believe it
12:36:37 <shapr> vegai: oh, that's nice
12:36:42 <SyntaxNinja> Haskell Source Dist (with a silent "H", pronounced "Sadist")
12:36:45 <Riastradh> Programs of Haskell Bundler: PHB.
12:36:52 <Marvin--> SyntaxNinja: me like!
12:37:08 <shapr> Haskell Active Program Tool - HAPT (for hapt-get)
12:37:28 <Riastradh> Programs of Haskell Packager: PHP.
12:37:31 <det> Source Unified eXchange! Haskell SUX!
12:38:04 * ski lols
12:38:04 <SyntaxNinja> "Thanks for coming, we'll let you know..."
12:38:11 <Riastradh> Oh, I have an idea: UHPDMSIP
12:38:23 <Marvin--> ..
12:38:25 <Riastradh> Er, UHPPBDMSIP.
12:38:29 <SyntaxNinja> Maybe we can call it Clonie. I like that word
12:38:30 <Marvin--> rolls right off your tongue, eh
12:38:40 <Riastradh> Unified Haskell Program Package Bundling & Distribution Management System Infrastructure Project
12:38:45 <SyntaxNinja> heh
12:38:56 <det> Riastradh: you are crazy
12:39:06 <Riastradh> 'uhhh-pptt-dumsip'
12:39:21 <ski> POTRZEBIE ?
12:40:03 <shapr> Light Active Monadic Distributer & Builder Activity?
12:40:12 <Riastradh> Thta's lamdba, shapr.
12:40:14 <vegai> Yet Another Distutils
12:40:15 <Marvin--> lamdba?!
12:40:19 <det> shapr: YOU ARE DYSLEXIC, SIR
12:40:28 <Riastradh> Hrmmmm.
12:40:34 <SyntaxNinja> s/Activity/Architecture
12:40:40 <shapr> it sure would be easy to find on google, right? :-)
12:40:42 <Riastradh> I regret having typed that so quickly.
12:40:51 <SamB> Builder & Distributer?
12:40:56 <bringert> & -> And: LAMBADA
12:41:03 <Marvin--> heh
12:41:21 <bringert> eh, switch Builder and Distributor around too
12:41:38 <Riastradh> How about a non-acronym, like the Curry Rack?
12:41:49 <det> Thta's lamdaba, bringert 
12:41:50 <Riastradh> A Haskell package would be a curry ingredient...
12:41:56 <SyntaxNinja> Library and Application (m) Building and Distribution Architecture
12:41:56 <bringert> det: dammit
12:42:03 <vegai> Haskell Distribute (and a caveman for the logo)
12:42:21 <shapr> SyntaxNinja: though google searches might find other hits for lambda
12:42:26 <SyntaxNinja> shapr maybe
12:42:34 <SamB> hmm, I still like hapt
12:42:39 <SyntaxNinja> it would be funny to call it lamdba
12:42:40 <Riastradh> Acronyms are, like, soooooo late '90s.
12:42:45 <SyntaxNinja> (like my cat)
12:43:04 <SyntaxNinja> Or since we have nothign for the "M" we could call it labda
12:43:15 <vegai> hftm
12:43:19 <SyntaxNinja> what does hapt stand for again?  "Haskell Application ..."
12:43:21 <vegai> Haskell For The Masses
12:43:39 <Riastradh> SyntaxNinja, what do you think of having something involving curry?
12:43:40 <det> Riastradh: yes, GNU HURD, is leading the way into the 21st century with it's double recursive acronyms and amazing technology!
12:43:45 <SyntaxNinja> Riastradh: I like curry
12:43:48 <shapr> we could call it Haskeleton
12:43:54 <shapr> since everything else is built on it ;-)
12:44:05 <SyntaxNinja> (I am writing all this down...)
12:44:16 <Riastradh> It could be like the Caml Hump, but with a better idea than the very dull 'hump.'
12:44:27 <Marvin--> yay, let's DoS SyntaxNinja's notes
12:44:31 <shapr> Curried Combinators?
12:44:39 <vegai> Haskell Chili
12:44:40 <Taaus> Curried acronyms? :)
12:44:58 <det> Taaus: dont tempt the haskellers!
12:44:59 <shapr> maybe this framework is the original Partial Application.
12:45:11 <shapr> since it's just for installing other applications
12:45:47 <ski> heh
12:45:54 <SyntaxNinja> I'm leaning toward labda="Library and Application Building and Distribution Architecture" since it's almost lambda and since it actually describes the system...
12:46:14 <shapr> lambda with a cold
12:46:26 <Marvin--> having a typoed lambda would be pretty fun, actually :)
12:46:37 * shapr checks google
12:46:46 <shapr> eek
12:46:50 <bringert> simply typoed lambda calculus?
12:46:52 <shapr> 30k results
12:47:00 <Marvin--> LOL, the first hit is way funny
12:47:06 <Marvin--> "Leeds and Bradford Dyslexia Association - Web Site"
12:47:08 <Riastradh> Hahaha: http://www.labda.org.uk/
12:47:20 <Marvin--> this is just too good
12:47:21 <vegai> ;)
12:47:25 <ski> lol
12:47:26 <shapr> it seems that labda is a common word in hungarian also
12:47:39 <shapr> oh, it means "ball" in hungarian.
12:48:09 * Marvin-- can't stop laughing at the dyslexia association
12:48:15 <bringert> haddock gets 478k hits in google, but it still works as a name
12:48:22 <shapr> that's true
12:48:52 <SyntaxNinja> Maybe "Labdah" (for Haskell at the end)
12:48:59 <Marvin--> the irony of sharing the acronym with a dyslexia association is too great to pass up on!
12:49:19 <Riastradh> Haskell LABs, Haskell Library & Application Buildings.
12:49:42 <Riastradh> s/[Bg]s//1
12:50:11 <Riastradh> Or perhaps the Curry LAB.
12:50:45 <shapr> scafFold
12:51:00 <shapr> The Appomorphism
12:51:11 <SamB> hehe
12:51:22 <det> Haskell Application and Library Transmittor - HALT
12:51:29 <bringert> ok, who'll write the program that takes a bunch of keywords, creates all sensible permutations and checks the resulting acronym against a dictionary?
12:51:47 <SyntaxNinja> I think that's in the standard library somewhere...
12:51:53 <SamB> bringert: -v or not -v?
12:51:59 <Marvin--> det: that'd be fun, then we could talk about the HALTing problem
12:52:04 <SyntaxNinja> heh
12:52:05 <shapr> oy
12:52:23 <det> Marvin--: :)
12:52:33 <SyntaxNinja> does anyone have preference for "labda" over "labdah"?
12:52:47 <SyntaxNinja> I guess they'd be pronunced the same
12:52:48 <det> SyntaxNinja: I think you can do better
12:53:02 <SamB> I don't know if I can stomache lambda without the m
12:53:08 <Marvin--> where the "h" is "for Haskell" or what?
12:53:13 <SyntaxNinja> Marvin--: yeah
12:53:17 <shapr> lahbda ?
12:53:17 <Riastradh> I can't say it without sounding like I have a cold.
12:53:39 <shapr> that's the southern accent
12:53:52 <shapr> kin you luk at my lahbda?
12:53:54 <bringert> Hippopotomonstrosesquippedaliophobia
12:54:16 <Marvin--> but think of the possibilities, we can do geeky rebuses
12:54:21 <Marvin--> \-m
12:54:30 <bringert> it starts with an h at least
12:54:31 <SyntaxNinja> OK, so the important words are [Haskell, Library, Either Application Tool] ++ [Distribute, Build]
12:54:44 <shapr> HEAL
12:54:54 <shapr> Haskell Either Application or Library 
12:55:19 <andersca> Either Application Library
12:55:28 <det> I like Riastradh's LAB
12:55:56 <shapr> eleat ?
12:56:06 <Marvin--> Haskell (Either Application Library)
12:56:11 <bringert> http://snrs.unl.edu/wedin/nefieldsites/Haskell/haskell_lab.htm
12:56:18 <ski> (HEAL = HEal ALl (spell from old game Bard's Tale))
12:56:26 <shapr> Distribute Either Application or Tool for Haskell
12:56:39 <Marvin--> slightly too morbid, I think :)
12:56:43 <Riastradh> bringert, that's the Haskell _Ag_ Lab, not the Haskell (or Curry) LAB.
12:56:52 <SyntaxNinja> OK, so you were supposed to parse that Either as "Either of these words"
12:56:54 <shapr> BEATL
12:57:05 <SyntaxNinja> but in your sense, Either Application Library makes sense.
12:57:10 <SyntaxNinja> tool and application are synonyms in my book
12:57:14 <shapr> yah, that's one's cool
12:57:26 <det> ohh, Tool, "Haskell Application and Library Tool"
12:58:09 <SyntaxNinja> "Haskell Architecture for Libraries and Tools"
12:58:09 <shapr> I like Either Application Library
12:58:17 <SamB> SyntaxNinja: well, a tool wouldn't have to fit the application mold
12:58:48 <shapr> The Skolem Golem ?
12:58:53 <SyntaxNinja> SamB: huh?
12:59:57 <SyntaxNinja> HILT "Haskell Infrastructure for Libraries and Tools"
13:00:09 <shapr> very sensible
13:00:17 * Marvin-- gives up on markov chains for today
13:00:53 <Riastradh> I like the Curry LAB.
13:01:27 <SyntaxNinja> LAB= Library and Application Building?
13:02:07 <Riastradh> Or Builder.
13:02:09 <SyntaxNinja> yeah
13:02:17 <SyntaxNinja> that could be the name of just the builder part...
13:02:22 <SyntaxNinja> (which is what we're working on now)
13:02:33 <SyntaxNinja> then the whole thing w/ distribution mechanism can be called something else.
13:02:47 <SyntaxNinja> And "Curry" is just for Curry, right?
13:03:13 <det> CABAL, C????? Architecture for Building Applications and Libraries
13:03:14 <Riastradh> Yup.
13:03:36 <Philippa_> Complete?
13:03:39 <SyntaxNinja> Curry
13:03:54 <SyntaxNinja> Curried
13:03:55 <SyntaxNinja> ;)
13:04:11 <det> Cliched :)
13:05:19 <SamB> Connected
13:05:50 <det> COOL!1
13:06:06 <SamB> or the C could be for CABAL
13:06:11 <SyntaxNinja> you guys are good at this
13:06:15 <SyntaxNinja> I take back what I said before
13:06:52 <det> Combinator
13:07:08 <det> now you must write in using only Combinators!
13:07:19 <SyntaxNinja> Here's my favorites so far. does anyone else have top picks that I missed:
13:07:20 <SyntaxNinja> ** halt = "Haskell Architecture for Libraries and Tools"
13:07:20 <SyntaxNinja> ** hilt = "Haskell Infrastructure for Libraries and Tools"
13:07:20 <SyntaxNinja> ** labda= "Library and Application Building and Distribution Architecture" {for haskell}
13:07:20 <SyntaxNinja> ** Curry LAB = Curry Library and Application Builder
13:07:20 <SyntaxNinja> ** CABAL =, {Curry,Curried,Connected,Complete,Cabal} Architecture for Building Applications and Libraries
13:07:25 <SyntaxNinja> (in no particular order)
13:08:12 <SyntaxNinja> we can have two, like the ones that  just mention building can be fore the building part only
13:08:17 <SamB> SyntaxNinja: you forgot Cool as one of the choices for C in CABAL
13:08:32 <ski> http://www.hilt.nl/  (related to Clean)
13:08:33 <SyntaxNinja> so CABAL would be a part of HALT, for instance.
13:08:36 <SamB> or maybe you didn't like that one?
13:08:41 * esap wishes I could figure out great names like that for my compiler :-)
13:08:55 <SyntaxNinja> SamB: didn't like cool too much.
13:09:16 <Philippa_> SamB: may as well have Crap
13:09:49 <det> :-)
13:10:30 <SyntaxNinja> so no favorites that I missed?
13:10:51 <SyntaxNinja> don't be afraid to email me if someone comes up with something clever
13:11:03 <SyntaxNinja> it doesn't actually have to be an acronym in fact, just FYI
13:11:44 <SamB> well, I still like "hapt", although I'm not sure about the expansion
13:12:24 <SyntaxNinja> yes... I kinda like hapt too... i'm a bit involved in APT development though so that could get confusihng
13:12:25 <det> Haskell Application Package Tool
13:13:06 <SyntaxNinja> Haskell Architecture for Packaging Tools
13:13:18 <shapr> Haskeleton is cheesy but cute
13:13:28 <SyntaxNinja> It is
13:13:30 <SyntaxNinja> I'll add it
13:13:42 <det> I like haskeleton
13:13:46 * SyntaxNinja too
13:15:07 <det> considering MLton, I imagine Haskeleton to be a compiler, however :)
13:15:23 <SamB> hmm. haskeleton could use some explanation ;-)
13:15:45 <det> SamB: its an acronym, isn't it obvious ?
13:16:24 <SyntaxNinja> I wrote HaSkeleton (upon which things are built)
13:16:29 <shapr> The Haskell Skeleton, everything else is built on top of it
13:16:30 <SyntaxNinja> It could have that subtitle
13:16:35 <shapr> yah
13:16:38 <SamB> det: I can't tell what tone of voice you are using
13:16:51 * shapr listens to det very carefully
13:16:51 <det> SamB: normal voice!
13:17:00 <det> SamB: but I am wearing my sarcastic hat
13:17:06 <det> SamB: + !
13:17:13 <SamB> hmm
13:17:31 <SamB> where is the part where you know what it is for?
13:17:39 <det> What. *you* dont have different hats to depict your mood and tone?
13:18:11 <det> Is the second e necessary ?
13:18:44 <det> doesn't the "ton" suffix by itself mean all that?
13:18:52 <SamB> rather, where others know that haskeleton has something to do with packaging?
13:19:19 <det> SamB: it's hard to tell that purely by ANY name
13:19:28 <det> SamB: unless it is boring
13:19:35 <det> SamB: like, "distutils" :)
13:19:52 <SamB> det: I meant of the subtitle, actually
13:20:03 <det> oh.
13:20:12 * esap prefers names that are plain, simple and boring.
13:20:25 <SamB> distutils is allowed to be boring
13:20:28 <det> esap: you would say that, "esap"!
13:21:03 <SamB> although it could do with a little more staying-out-of-the-way, probably
13:21:05 <TheSoundOfFire> *I* am creative
13:21:50 <SamB> anyway, I do not in any way disapprove of the name haskeleton.
13:21:53 <SyntaxNinja> It's OK to have not particularly descriptive names. I just don't like names that expand to inaccurate acronyms 
13:22:21 <det> SyntaxNinja: Haskeleton is my favorite
13:22:29 <SamB> I just think the subtitle should provide a better hint as to what it is for
13:22:33 <SyntaxNinja> yeah hmm
13:22:46 <SyntaxNinja> but it sould also evoke what the name means
13:23:01 <SamB> yes
13:23:39 <SamB> it should tie the name to the point
13:24:01 <SyntaxNinja> "A Framework for Packages"?
13:24:06 <det> SamB: I dont imagine you would approve of "Haskeleton, It's what's for dinner."
13:24:24 <det> SyntaxNinja: not bad
13:24:34 <det> A skeleton for packages
13:25:20 <SamB> yeah. thats okay, and it isn't exactly set in stone
13:25:24 <det>  Skeleton \Skel"e*ton\, a.
13:25:24 <det>      Consisting of, or resembling, a skeleton; consisting merely
13:25:24 <det>      of the framework or outlines; having only certain leading
13:25:24 <det>      features of anything; as, a skeleton sermon; a skeleton
13:25:24 <det>      crystal.
13:26:09 <det> Haskeleton, A Skeleton for Packages.
13:26:12 <det> I like it
13:27:08 <SyntaxNinja> i'll add that
13:27:39 * det runs off to work
13:27:48 <det> g'day
13:27:51 <SamB> where did everyone go?
13:28:16 <SamB> same to you
13:28:21 <SyntaxNinja> l8r det
13:38:33 <stepcut> ugh
13:40:45 <stepcut> so Lets say I have class:
13:40:46 <Riastradh> Curry-a-LAB: Curry Architecture for Library & Application Builder
13:40:46 <stepcut> class MyClass a where
13:40:48 <stepcut>     thing :: i -> o -> a i o
13:41:08 <stepcut> and a data-type:
13:41:08 <stepcut> data (Read i, Read o) => Test i o = Test i o
13:41:16 <ski> hello cmoline
13:41:36 <stepcut> It appears that I can not do: instance MyClass Test where
13:41:50 <stepcut> because:     Could not deduce (Read o, Read i) from the context (MyClass Test)
13:42:24 <stepcut> :(
13:42:32 <ski> stepcut :  that's because the (Read i, Read o) context isn't "attached" to the type constructor, just the data constructors
13:44:10 <stepcut> ski: is there someway I can get this to work without change the type signatures for the class, MyClass
13:44:44 <ski> stepcut : not that i know of, unfortunately :(
13:44:50 <stepcut> bummer
13:46:24 <stepcut> I had this idea for using arrow notation combining unix processes together with pipes. But I can't figure out to write a version of 'arr' that works for all datatypes. I need to restrict it to read/show types...
13:46:51 <ski> stepcut : Hughes had similar problems in his arrow paper
13:47:16 * ski thinks having arr in Arrow is evil
13:48:44 <Marvin--> arr matey
13:48:55 <stepcut> i implemented the stuff in hughes paper, (aka the fudget style streams), but that is not very practical, because it moves all the multitasking and pipe functionality out of unix and into haskell, so you incur a huge overhead
13:49:14 <stepcut> I wanted to do something different where you had phantom typed file descriptors
13:49:39 <stepcut> and then the arrow syntax would just be used to wire file descriptors together
13:50:36 <stepcut> so haskell would just spawn all the processes, and wire up the file descriptors, and let the OS handle the rest
13:51:50 <stepcut> but, using file descriptors implies that I can some how convert all haskell data types into something than can be sent 'via file descriptors'
13:51:59 <stepcut> hence the restriction to Read/Show
13:53:15 <ski> somewhat similar to hughes's cgi problem, then
13:53:39 <stepcut> maybe, I would have to review his cgi stuff again
13:55:34 <stepcut> well, I think I am still going to do something with statically-typed pipes, but I guess I won't be able to reuse arrows
13:59:09 <shapr> I would like to know about sending haskell types by unix pipe
13:59:18 <stepcut> hrm, yes it appears to be the exact same problem that hughes had with the cgi stuff
13:59:42 <Lunar^> stepcut: Waow, that seems interesting for hOp
13:59:55 <stepcut> shapr: well, I was going to define a new type: data TypedFd t = TypedFd Fd
14:00:52 <stepcut> Then I was going to use the Arrow notation to hook processes together, using the TypedFds
14:02:09 <stepcut> BUT, it turns out that I can not come up with a instance of arr in the Arrow class, because I need to able to read/show the data-types to send them through a pipe
14:02:18 * SyntaxNinja home &
14:02:19 <SyntaxNinja> peace all
14:02:55 <stepcut> and it is not possible to restrict arr to instances of (Read b, Show c), unless I reimplement the whole arrow library :(
14:03:24 <stepcut> but the concept seems really colo
14:03:26 <stepcut> cool
14:03:58 <shapr> yah, it sounds nifty
14:04:13 <stepcut> in unix, things like grep are essentially -> program :: [String] -> [String]
14:05:02 <stepcut> but, if programs could have more varied type interfaces, that could make shell scripting easier and safer
14:05:49 <Lunar^> stepcut: Did you read Arjen van Weelden paper about Esther ?
14:05:52 <stepcut> mapM_ touch (ls "*.hs")
14:05:59 <stepcut> or something
14:06:17 <Lunar^> stepcut: Sure, Esther is exactly that
14:06:21 <Riastradh> stepcut, have you looked at scsh?
14:07:04 <stepcut> a bit, I am going to look into it more, scsh is a good example of what I want
14:07:36 <stepcut> but, last time I looked, the syntax of scsh seemed a bit clunk
14:07:39 <stepcut> clunky
14:07:59 <stepcut> mabye I will think differently this time :)
14:08:00 <Riastradh> You should read Shivers' papers on the design of scsh, too.
14:08:29 <stepcut> ok
14:08:40 <stepcut> I will read both papers
14:09:39 * stepcut goes to lunch
14:09:42 <Riastradh> (for-each touch-file (glob "*.hs")), given a TOUCH-FILE -- which is defined trivially --, is neither particularly clunky (if you consider the Haskell snippet to not be clunky) nor much longer than the Haskell snippet.
14:10:27 <Riastradh> (And it would require no process forking, output parsing, et cetera...)
14:11:02 <stepcut> for i in *.hs { ls -l $i }
14:11:06 <stepcut> eshell :p
14:11:57 <Riastradh> (for-each (lambda (file) (run (ls -l ,file))) (glob "*.hs")) -- a bit longer, but not much.
15:25:52 <ski> hello gini
16:25:15 * desrt steals all of shae's monads
16:26:17 <shapr> as if!
16:28:28 <desrt> i'm doing ok with this monad stuff now
16:28:30 <desrt> state is ok
16:28:37 <desrt> it's not great, but i don't hate it
17:04:30 <desrt> hey cale
17:04:41 <desrt> you actually home?
17:08:01 <desrt> ok.  i need a sensible way to return errors
17:08:09 <Riastradh> return Nothing
17:08:20 <desrt> heh
17:08:22 <desrt> that's my problem
17:08:25 <desrt> i'm using fromJust
17:08:42 <desrt> and the only type of error i'll ever have is when i fromJust a Nothing :)
17:08:55 <Riastradh> So don't use fromJust.
17:08:56 <Riastradh> Use maybe.
17:09:17 <desrt> but i want to return an error text
17:09:22 <Riastradh> OK.
17:09:26 <Riastradh> error "Foo bar baz quux zot."
17:09:37 <desrt> is error a maybe type?
17:09:43 <Riastradh> No.
17:09:58 <Cale> error :: String -> a, iirc.
17:10:09 <Cale> @type error
17:10:13 <lambdabot> error :: forall a. [Char] -> a
17:10:19 <desrt> uh
17:10:32 <desrt> cale; btw, it works perfectly
17:10:35 <Cale> cool
17:10:41 <desrt> i cheat just a little bit
17:11:00 <desrt> instead of passing [] to runState i say [("result", 0)]
17:11:26 <desrt> ie: last line of your program must be "result = op( some, source, args )"
17:15:20 * desrt rewrites listalloc as a oneliner
17:15:54 * shapr rewrites himself as a oneline pointless function
17:16:13 * Cale rewrites the process of rewriting.
17:16:29 <shapr> Meta HasCale!
17:17:46 <Cale> heh
17:18:40 <Cale> HaWiki looks different
17:18:52 * shapr hides the evidence
17:27:00 <shapr> hi cedricshock 
17:27:04 <shapr> g'day Pseudonym 
17:27:13 <Pseudonym> G'day.,
17:27:21 <shapr> cedricshock: is your last name really shock?
17:27:25 <cedricshock> Yep
17:27:58 <shapr> nifty
17:28:37 <shapr> cedricshock: learning Haskell?
17:28:41 <cedricshock> Maybe
17:28:51 <cedricshock> I hear haskell is the least broken programming language
17:28:53 <Cale> Maybe a?
17:29:06 <shapr> cedricshock: I agree with that assessment
17:29:14 <Cale> hehe
17:29:19 <cedricshock> shapr: Been playing with erlang, it's fairly not broken
17:29:24 <shapr> yah, erlang is nice
17:29:44 <shapr> it's particularly unbroken for network apps
17:29:51 <shapr> erlang has a rare set of features
17:29:58 <shapr> many of which I would like to have in Haskell
17:30:04 <cedricshock> shapr: does haskell have a similar process / message passing model
17:30:18 <cedricshock> shapr: not necessarily over network, just between processes?
17:30:55 <shapr> closest thing is Concurrent, which green threads that can talk to each other
17:31:03 <Pseudonym> IMO there are a number of axes by which you can judge a programming language.
17:31:15 <Pseudonym> Any language on the convex hull is "interesting".
17:31:16 * shapr grinds another axe
17:31:41 <Cale> Pseudonym: on the boundary of the convex hull?
17:31:44 <Pseudonym> Because there is no language which is "less broken" than that language, using those criteria.
17:31:53 <Pseudonym> Cale: Languages are discrete points.
17:32:11 <Pseudonym> If you take the convex hull of those points, some languages lie on the surface and some are in the interior.
17:32:16 <shapr> referential transparency is a real turn on for me :-)
17:32:19 <Pseudonym> Haskell is on the surface, and therefore interesting.
17:32:34 <Cale> Pseudonym: right, that's what I was getting at
17:32:39 <cedricshock> He's saying any language in the interior is in some absolute way inferior to some other language.
17:32:39 <Pseudonym> Right.
17:32:44 <Pseudonym> Correct.
17:32:57 <Pseudonym> For example, csh is absolutely inferior to tcsh.
17:32:59 <shapr> man, I want a language that's so far under the the hull it comes on the nice wooden deck on top of the boat
17:33:12 <Cale> For example, the empty language is pretty much inferior to everything.
17:33:12 <Pseudonym> shapr: You want the null programming language.
17:33:23 <Pseudonym> Zero expressivity, zero performance, zero flexibility.
17:33:26 <shapr> S K I ?
17:33:28 <Pseudonym> Zero valid programs, too.
17:33:32 <cedricshock> Zero errors.
17:33:38 <Cale> cedricshock: good point
17:33:45 <Pseudonym> Indeed.
17:34:04 <Pseudonym> As another example, Miranda is absolutely inferior to Haskell.
17:34:17 <Pseudonym> Emacs Lisp is absolutely inferior to Scheme.
17:34:18 <Pseudonym> And so on.
17:34:28 <Cale> Also, every program written in the empty language runs in constant space and time, and is provably correct.
17:34:33 <Pseudonym> True.
17:34:55 <shapr> Joy is inferior to PostScript
17:35:35 <cedricshock> One of the biggest problems every programming language I've used runs into is interacting with the outside world.
17:35:43 <Pseudonym> C is _almost_ absolutely inferior to C++.
17:35:53 <Pseudonym> Almost.
17:36:12 <cedricshock> Such as user-interface, network stuff, etc.
17:36:19 <Pseudonym> Yes.
17:36:24 <Pseudonym> There are two problems there.
17:36:30 <Pseudonym> 1. Lack of libraries.
17:36:41 <Pseudonym> 2. Lack of agreement on what the right programming language metaphors are.
17:36:46 <cedricshock> C is a subset of C++. Thatdoesn't necessarily make it inferior.
17:36:53 <cedricshock> Yep those are the two problems
17:37:06 <shapr> C-- is a neat subset
17:37:08 <Pseudonym> cedricshock: There is one situation where C is superior to C++, and that's when memory is REALLY tight.
17:37:09 <cedricshock> Erlang's problem is #1
17:37:24 <Pseudonym> We're talking 4kb embedded processors.
17:37:26 <SamB> cedricshock: umm... you need to read up on C++.
17:37:54 <Pseudonym> If memory is that tight, then EH and RTTI are too expensive for the platform.
17:38:11 <cedricshock> On the c < c++ argument: imagine adding destructive variable assignment to a functional language. Your functional language will be a subset of the result, but it will not be better
17:38:33 <Pseudonym> cedricshock: You still need to read up on C++.
17:38:42 <Pseudonym> I used to make the same arguments against C++.
17:38:47 <desrt> how do i put  multiple constraints on a type in a :: ?
17:38:54 <Pseudonym> Until I actually wrote something nontrivial in C++, the C++-esque way.
17:39:21 <shapr> desrt: typeclass constraints? or what?
17:39:27 <cedricshock> pseudonym: what specifically should I know about c++? I prefer it to c for almost everything.
17:39:33 <desrt> shapr; correct
17:39:34 <jameson> desrt: IIRC, it's something like (Foo a, Bar a) => a -> a
17:39:38 <desrt> hmm
17:39:43 <Pseudonym> cedricshock: OK, then. :-)
17:39:44 <desrt> i hate types :P
17:39:46 <shapr> (Show a, Read a) =>
17:39:58 <SamB> cedricshock: that it isn't a superset like objc is!
17:40:00 <shapr> yah, what jameson said
17:40:09 <shapr> hi jameson, how's code?
17:40:17 <desrt> how do i do an integer?
17:40:19 <Pseudonym> Sorry, you said "C is a subset of C++. Thatdoesn't necessarily make it inferior." and I assumed you meant "C can be superior in many ways".
17:40:25 <Pseudonym> My apologies.
17:40:26 <shapr> desrt: oh, that's disgustion :-P
17:40:40 <desrt> can i just say (Num a, Enum a)
17:40:41 <shapr> wait, what do you mean by "do an Integer?"
17:40:50 <desrt> i want like (Int a) => ...
17:40:54 <cedricshock> samb: ok. What is in c but is not in c++?
17:40:55 <desrt> but it says that Int is a type constructor
17:41:03 <shapr> why not just use Int?
17:41:11 <shapr> foo :: Int -> Int -> Int
17:41:26 <ski> desrt : maybe you want Num or Integral ?
17:41:26 <desrt> listalloc :: (Eq a, Int b) => State [(a,b)] b
17:41:39 <shapr> Int isn't a typeclass
17:41:41 <SamB> cedricshock: well, there are some programs written in C which won't compile in C++.
17:41:41 <desrt> ahh
17:41:43 <desrt> Integral is the one
17:41:51 <desrt> i want to do [0..]
17:41:55 <desrt> and Num isn't Enum
17:41:55 <shapr> @info Integral
17:41:57 <lambdabot> -- Integral is a class
17:41:57 <lambdabot> class (Real a, Enum a) => Integral a where {
17:41:57 <lambdabot>     rem :: a -> a -> a {- has default method -};
17:41:57 <lambdabot>     div :: a -> a -> a {- has default method -};
17:41:57 <lambdabot>     mod :: a -> a -> a {- has default method -};
17:41:58 <lambdabot>     quot :: a -> a -> a {- has default method -};
17:42:00 <lambdabot>     divMod :: a -> a -> (a, a) {- has default method -};
17:42:01 <shapr> eek
17:42:01 <desrt> so i need something more specific.  Integral works
17:42:02 <lambdabot>     quotRem :: a -> a -> (a, a);
17:42:03 <shapr> type spam!
17:42:04 <lambdabot>     toInteger :: a -> Integer;
17:42:21 <shapr> enum is the [0..5] thingy
17:42:26 <shapr> short for enumerate
17:42:34 <desrt> listalloc :: (Eq a, Integral b) => State [(a,b)] b
17:42:34 <desrt> listalloc = do
17:42:34 <desrt>     list <- get
17:42:34 <desrt>     let notinlist = not . (\x -> elem x (map snd list))
17:42:34 <desrt>     return $ head $ filter notinlist [0..]
17:42:37 <desrt> ^^ this works :)
17:42:50 <desrt> basically i want the first number not in my list
17:42:52 <shapr> cedricshock: so, ready to dive into the world of pure code?
17:42:58 <cedricshock> Anyone here use debian? Which of these haskell packages should I choose if I'm getting started? Are there any packages that will provide UI functionality?
17:43:04 <shapr> ghc6
17:43:08 <shapr> wxHaskell
17:43:28 <shapr> if you're talking about debs
17:43:33 <Pseudonym> Which debian?
17:43:37 <Pseudonym> woody, sarge?
17:43:58 <shapr> non-debs includes gtk+hs, gtk2hs, a Tk interface, etc
17:44:18 <Igloo> By UI, do you mean a UI for doing stuff with Haskell or libraries for writing UIs in Haskell?
17:44:19 <cedricshock> Sarge I think. Whatever unstable/testing is.
17:44:31 <Pseudonym> Right, in that case, ghc6.
17:44:36 <cedricshock> Writing UIs in haskell
17:44:49 <shapr> wxHaskell
17:44:55 <Pseudonym> Fudgets
17:45:00 <Pseudonym> Arrows rule.
17:45:01 <Igloo> OK, then what shapr said
17:45:21 <Igloo> There's little in the way of libraries in Debian currently, unfortunately, but hopefully this will change soonish
17:45:57 <shapr> HSQL and HaskellDB debs would be spiffy
17:46:04 <cedricshock> Ok, the big programming language questions:
17:46:20 <cedricshock> Can I carry around a piece of data of unknown type?
17:46:25 <shapr> Dynamics?
17:46:34 <shapr> or what?
17:46:36 <Pseudonym> Dynamics, yes.
17:46:37 <desrt> heh.  listalloc just became so trivial that it had to be removed :)
17:46:49 <shapr> desrt: that's *real* programming :-)
17:46:54 <Pseudonym> @info Data.Typeable
17:47:02 <cedricshock> Can I read / write it to a file, or in some way serialize it and have it resurrected as the same type?
17:47:05 * shapr kicks lambdabot 
17:47:18 <shapr> @index Typeable
17:47:18 <lambdabot> Data.Dynamic,Data.Generics,Data.Generics.Basics,Data.Typeable
17:47:31 <Pseudonym> @info Data.Dynamic
17:47:32 <ski> often, parametric polymorphism is sufficient for what one uses (void *) for
17:47:40 <Pseudonym> Oh...
17:47:43 <shapr> @info Data.Dynamic.Typeable
17:47:43 <Pseudonym> @info Data.Typeable.Typeable
17:47:45 <lambdabot> -- Data.Typeable.Typeable is a class
17:47:45 <lambdabot> class Data.Typeable.Typeable a where {
17:47:45 <lambdabot>     Data.Typeable.typeOf :: a -> Data.Typeable.TypeRep; }
17:47:45 <lambdabot> -- Data.Typeable.Typeable is a class
17:47:45 <lambdabot> class Data.Typeable.Typeable a where {
17:47:46 <lambdabot>     Data.Typeable.typeOf :: a -> Data.Typeable.TypeRep; }
17:47:46 <shapr> oops
17:47:50 <Pseudonym> Yay.
17:47:55 <shapr> in stereo!
17:48:02 <Pseudonym> @info Data.Typeable.cast
17:48:05 <lambdabot> -- Data.Typeable.cast is a variable
17:48:05 <lambdabot> Data.Typeable.cast :: forall a b. (Data.Typeable.Typeable a, Data.Typeable
17:48:05 <lambdabot> Typeable b) =>
17:48:05 <lambdabot> 		      a -> Maybe b
17:48:17 <Pseudonym> That's how you do it.
17:48:47 <Pseudonym> @info Data.Dynamic.fromDyn
17:48:48 <lambdabot> -- Data.Dynamic.fromDyn is a variable
17:48:48 <lambdabot> Data.Dynamic.fromDyn :: forall a. (Data.Typeable.Typeable a) =>
17:48:48 <lambdabot> 			Data.Dynamic.Dynamic -> a -> a
17:48:53 <Pseudonym> @info Data.Dynamic.toDyn
17:48:54 <lambdabot> -- Data.Dynamic.toDyn is a variable
17:48:54 <lambdabot> Data.Dynamic.toDyn :: forall a. (Data.Typeable.Typeable a) =>
17:48:54 <lambdabot> 		      a -> Data.Dynamic.Dynamic
17:49:05 <cedricshock> Ok. I'll take all of that as a yes for now.
17:49:11 <Pseudonym> :-)
17:49:26 <Pseudonym> However, you should ask if you really need to do that or not.
17:49:38 <Pseudonym> A typeclass with an existential type may be superior.
17:49:50 <shapr> fight the class boundaries!
17:49:53 <cedricshock> What is a typeclass?
17:49:56 <shapr> libre logiciel!
17:50:00 <cedricshock> What is an existential type?
17:50:02 <Pseudonym> But if you're learning, of course, you should use what works.
17:50:13 <SamB> Pseudonym: you mean a more specific typeclass with an existential type
17:50:30 <Pseudonym> Right.
17:50:33 <shapr> cedricshock: typeclass is like a Java interface, but not painful :-)
17:50:55 <shapr> Eq defines equality on types
17:50:57 <shapr> @info Eq
17:50:58 <Pseudonym> Imagine a Java interface, but one you can attach to a type _after_ you define the type.
17:50:59 <cedricshock> My eternal project is writing spreadsheet / databaseesque programs in very many dimensions.
17:50:59 <lambdabot> -- Eq is a class
17:50:59 <lambdabot> class Eq a where {
17:50:59 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
17:50:59 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
17:50:59 <lambdabot>     }
17:51:13 <Pseudonym> Ah, cool.
17:51:22 <Pseudonym> I'm working on similar problems.
17:51:24 <cedricshock> Someone else gets to pick the data types after the program.
17:51:24 <shapr> lambdabot should really clean up whitespace in outputs
17:51:42 <SamB> cedricshock: typeclasses also give nice short infix ops a chance
17:52:00 <Pseudonym> cedricshock: Right, but with typeclasses, you can attach interfaces after the type.
17:52:08 <Pseudonym> It's kinda hard to explain.
17:52:09 <shapr> creating types typeclasses, and connecting them are all done separately
17:52:20 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
17:52:30 * shapr waves working around sources 
17:52:43 <Pseudonym> But if you've ever programmed in an OO language like Java, and you've ever wished that a built-in class supports some interface, but you know you can't do it without redefining the built-in type, then Haskell is for you.
17:53:07 <Pseudonym> http://www.theregister.co.uk/2004/05/27/danish_free_porn/ <- I work in the wrong business.
17:53:26 <shapr> um
17:54:10 <shapr> I love that last sentence
17:54:14 <Pseudonym> Yes. :-)
17:54:28 <cedricshock> So the next question: Will haskell interperet haskell code at runtime, like from a string?
17:54:31 <Pseudonym> Actually, I'm okay.  So long as my workplace has a site licence for the ACM Digital Library, I'm a happy camper.
17:54:37 <Pseudonym> cedricshock: No.
17:54:50 <Pseudonym> Most strongly-, statically-typed languages don't.
17:54:57 <shapr> Pseudonym: seen dons' hs-plugins framework?
17:55:07 <Pseudonym> I have, yes.  Briefly.
17:55:21 <shapr> he just added a .hi parser for type checking
17:55:25 <Pseudonym> But it's quite heavyweight.
17:55:35 <cedricshock> pseudonym: So no writing a spreadsheet in 53 lines of code then :(
17:55:48 <Pseudonym> cedricshock: Seems unlikely.
17:56:26 <Pseudonym> But I'm not sure that the ability to implement a spreadsheet in 53 lines of code is necessarily a feather in the cap of a language.
17:56:36 <cedricshock> I'd like a strongly types language with a JIT for interprting stuff
17:56:42 <SamB> what would microsoft do if you could do that?
17:56:55 <Pseudonym> cedricshock: Actually, you can get pretty close to JIT in Haskell.
17:57:16 <SamB> I mean, write a 53 line spreadsheet
17:57:21 <Pseudonym> Because Haskell is functional, you can manipulate functions.
17:57:34 <Pseudonym> So you can compile a scripting language to Haskell functions at run-time.
17:57:34 <cedricshock> It's the shortest one I've written, in Erlang. No data I/O or UI, but 53 lines of code for the whole engine.
17:57:56 <cedricshock> pseudonym: tell me more
17:58:23 <Pseudonym> @wiki RunTimeCompilation
17:58:24 <lambdabot> http://www.haskell.org/hawiki/RunTimeCompilation
17:58:29 <Pseudonym> See for yourself.
17:58:29 <SamB> I wish I was better at learning erlang
17:58:50 <Riastradh> SamB, keep learning Erlang over and over again until you get good at it, then.
17:59:04 <SamB> although I suppose the skill would be fairly useless once I learned it, though.
17:59:18 <cedricshock> samb: I started by reading the book "Concurrent programming in erlang". You can find it on the site somewhere.
17:59:24 <SamB> hmm. there were two thoughs in that sentence
17:59:31 <shapr> SamB: you could move to sweden
17:59:39 <shapr> worked for me.
17:59:54 <Pseudonym> cedricshock: http://citeseer.ist.psu.edu/dehoon95implementing.html
17:59:58 <Pseudonym> You might find that interesting.
18:02:09 <SamB> shapr: is erlang used extensively there?
18:02:16 <cedricshock> pseudonym: thanks. I find it very interesting.
18:02:19 <Riastradh> SamB, it's where Ericsson is headquartered...
18:02:24 <SamB> oh.
18:02:34 <Igloo> Didn't they drop Erlang recently?
18:02:43 <Pseudonym> I heard rumours that Erlang isn't being used on new products.
18:03:09 <SamB> well, surely there must be others using it in the area, no?
18:03:30 <Pseudonym> I'm pretty sure Erlang is used for internal applications, though.
18:03:34 <Pseudonym> So it's not exactly "dropped".
18:03:41 <cedricshock> I'm sitting on the erlang mailinglist and activity seems to be increasing, not decreasing.
18:03:56 <cedricshock> Ericsson has dropped their consulting and certification programs though.
18:06:30 <shapr> bluetail is still around
18:06:52 <desrt> dear lord
18:07:04 <desrt> looking at my 12" ibook after staring at this 23" powermac for a while is *weird*
18:07:29 <cedricshock> Let's pretend I want to take a piece of data of unknown type A, and text that forms a function deffinition, T, compile it to an anonymous function F, and apply it to A could I do that? I'm not really following the wiki page you pointed me to.
18:08:18 <Pseudonym> What you see on the wiki page isn't quite about that.
18:08:29 <cedricshock> And could a dynamically typed piece of data itself be a function?
18:08:30 <desrt> in the interest of not reimplimenting prelude
18:08:37 <shapr> desrt: but it's fun!
18:08:47 <shapr> and very educational
18:08:58 <desrt> i need a function :: (a -> Bool) -> [a] -> [[a]]
18:09:06 <Pseudonym> cedricshock: I think that you might be going about the problem the wrong way.
18:09:14 <desrt> such that [a] is broken into multiple lists along the boundry that satisfies the first argument
18:09:35 <shapr> @type break
18:09:36 <Pseudonym> What do you REALLY want to do?
18:09:37 <lambdabot> break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
18:09:40 <cedricshock> pseudonym: then what would you suggest?
18:09:50 <desrt> ie: split (','==) "foo,bar,baz"
18:09:55 <ski> cedricshock : this might be interesting http://lambda.weblogs.com/discuss/msgReader$9066
18:09:58 <shapr> desrt: use breakOnGlue from @wiki PreudeExts
18:09:59 <desrt> gives ["foo","bar","baz"]
18:10:18 <shapr> @wiki PreludeExts
18:10:20 <lambdabot> http://www.haskell.org/hawiki/PreludeExts
18:10:24 <desrt> thanks
18:10:51 <ozone> morning
18:11:09 <Pseudonym> G'day.
18:11:22 <shapr> ozone: did you dream about arrows?
18:11:26 <cedricshock> ski: spreadsheets are languages. I'm trying to write a spreadsheet / database like language. That's why I'm looking at programming languages. The language that is already most like a spreadsheet should win, right?
18:11:58 <ozone> shapr: i think i dreamt about hot chicks, but arrows sounds like they would have been fun too
18:12:03 <Pseudonym> A spreadsheet "engine" is a dataflow evaluation system.
18:12:06 <cedricshock> ski: Well in that case I should just right the language in Improv, but improv works on fewer and fewer systems now
18:12:22 <cedricshock> pseudonym: thats right
18:12:27 <Pseudonym> cedricshock: You might want to look at arrows when you're ready.
18:12:35 <Pseudonym> And Fudgets in particular.
18:12:36 <shapr> arrows r0xx
18:12:55 <ozone> noo, the A word
18:12:57 <Pseudonym> Basically, arrows are a formalism which support constructs precisely like this.
18:13:12 <shapr> ozone: oh
18:13:33 <shapr> is there some easy way for me to get my email via ssh from another box?
18:14:05 <Lukhas> shapr: uucpssh.org ?
18:14:12 <Pseudonym> cedricshock: http://www.cs.chalmers.se/~hallgren/Thesis/
18:14:34 <shapr> Lukhas: wow
18:14:46 <Lukhas> next question ! :)
18:15:41 <Igloo> Does P = NP?
18:15:58 <shapr> can you explain skolemization?
18:16:00 <Igloo> Sorry, I'll get my coat...
18:16:04 * shapr grins
18:16:06 <shapr> hi Igloo!
18:16:14 <Pseudonym> Igloo: I know the answer, but unfortunately the proof has exponential complexity.
18:16:14 <shapr> Igloo: hyromorphisms?
18:16:22 <ozone> Lukhas: crazy stuff
18:16:33 <Cale> I might be able to explain Skolemisation, given a little while to brush up on it.
18:16:38 <Igloo> Evning shapr
18:16:52 <shapr> Cale: I'm just being difficult, I actually understand skolemization
18:16:59 <Pseudonym> @foldoc skolemisation
18:17:01 <lambdabot> *** "skolemisation" foldoc "The Free On-line Dictionary of Computing (27
18:17:01 <lambdabot> SEP 03)"
18:17:01 <lambdabot> skolemisation
18:17:01 <lambdabot>      
18:17:02 <lambdabot>         A means of removing {quantifier}s from {first order logic}
18:17:03 <desrt> skolemisation!
18:17:04 <lambdabot>         formulas.
18:17:05 <lambdabot>      
18:17:08 <Pseudonym> There you go.
18:17:08 <lambdabot>         [Details?]
18:17:09 * Igloo fails to understand the hyromorphisms line
18:17:10 <lambdabot> [2 @more lines]
18:17:17 <Cale> That was detailed. :)
18:17:18 <shapr> hierglyphs :-)
18:17:20 <Pseudonym> Lambdabot knows everything except the Details.
18:17:26 <shapr> ack, hieroglyphs
18:17:27 <Igloo> Ah  :-)
18:17:36 <cedricshock> Pseudonym: If P=NP and the proof is NP and can't be done in P, then we have a contradiction so P!=NP.
18:18:16 <Riastradh> cedricshock, no, you just contradicted yourself; if you prove in NP that P=NP, then you just proved you can prove in P that P=NP.
18:19:05 <Pseudonym> Actually, you probably thought I was kidding about that.
18:19:10 <Pseudonym> But believe it or not, it's true.
18:19:12 <cedricshock> Riastradh: I am taking pseudonym as saying P=NP and proof is NP and proof != P
18:19:12 <Pseudonym> http://eprint.iacr.org/2003/187/
18:19:51 <Smerdyakov> cedricshock, what do you mean for a _proof_ to be in P or NP?
18:19:55 <desrt> is show the right function to use to convert ints to strings?
18:20:10 <Riastradh> cedricshock, I am not paying attention.  Therefore I did not see Pseudonym's original...er, what?
18:20:11 <Pseudonym> Smerdyakov: Let me quote from the abstract.
18:20:17 <cedricshock> SO we have a contradiction, so something must be wrong, the possibilities are pseudonym is wrong about proof = NP and or != P, or P = NP is wrong
18:20:32 <Pseudonym> "This paper shows that the proof complexity (minimum computational complexity of proving formally or asymptotically) of P \not= NP is super-polynomial-time with respect to a theory T [...]"
18:20:36 <Riastradh> desrt, yes.
18:20:43 <shapr> another possibility is that we're all short on sleep
18:20:50 <shapr> and then anything looks both sensible and nutty
18:20:57 <Pseudonym> Where T has some constraints on it, such as being an extension of Peano Arithmetic, and being PTM-omega consistent.
18:20:59 <cedricshock> "does P=NP" ... "I know the answer, but unfortunately the proof has exponential complexity."
18:21:54 <cedricshock> Then it's a proof that P!=NP. I get the prize money.
18:22:01 <Pseudonym> Damn.
18:22:07 <Igloo> What's it super-polynomial-time in?
18:22:19 <Pseudonym> In the size of the theory.
18:22:24 <Igloo> Ah, I see
18:22:25 <shapr> oy
18:22:30 * shapr grins
18:22:41 <ski> cedricshock : http://www.cs.kent.ac.uk/projects/vital/ and http://www.mrtc.mdh.se/php/publ_show.php3?id=0435
18:22:42 <Pseudonym> It's a really amusing result.
18:22:47 <desrt> argghhh
18:22:48 <shapr> Pseudonym: you gotta drop by teh old country and hang out with us sometime
18:22:58 <desrt> preludeexts is evil
18:23:02 <Pseudonym> shapr: Yes, I have to, but it ain't gonna happen any time soon.
18:23:04 <shapr> desrt: why do you say that?
18:23:18 <desrt> if i want 'split' i have to import several other functions too
18:23:23 <shapr> Pseudonym: that's good, because I can't afford to politely visit you back anytime soon.
18:23:26 <Pseudonym> It's the price I pay for living in the "arse end of the world", as one former Prime Minister put it.
18:23:41 <Cale> desrt: It's a bunch of people's random generic functions.
18:24:12 <cedricshock> Argh! I looked at it. It's the opposite proof from the one that would give an answer by contradiction
18:25:58 <Pseudonym> So there you go.  While P ?= NP hasn't been settled, it has been settled that it probably won't be settled.
18:26:45 * shapr throws lambdas
18:26:53 * Pseudonym throws metas
18:26:58 <cedricshock> We know know that (P != NP) != P
18:27:43 <Pseudonym> The thing is, we know that P <= NP <= PSPACE <= NPSPACE <= EXPTIME
18:27:49 <Pseudonym> And we know that P < EXPTIME
18:27:56 <desrt> *Main> build [ "sin = assign", "cos = shift sin", "other = blah sin, cos", "that = blah sin, cos", "this = some that, other", "result = func this, that, other" ]
18:28:00 <desrt> ["assign v0","shift v1, v0","blah v2, v0, v1","blah v1, v0, v1","some v0, v1, v2","func v0, v0, v1, v2"]
18:28:00 <cedricshock> pseudonym: as far as I can tell an arrow is a function. What's the difference?
18:28:03 <desrt> i think i can go home :)
18:28:15 <Pseudonym> cedricshock: No, an arrow is an abstraction.
18:28:16 <shapr> don't do it!
18:28:24 <Pseudonym> Functions are one model of arrows.
18:28:34 <desrt> people around this place are arrow-obsessed
18:28:36 <Cale> desrt: oh, you're still there :)
18:28:43 <cedricshock> pseudonym: yes, an abstraction of a function. But function is already an abstraction of a function.
18:28:45 <shapr> huh, so that's what the secret backtick moin 1.2 feature does
18:28:50 <desrt> cale; i am
18:28:55 <Pseudonym> Some category theory would help here, I think.
18:29:01 <desrt> i can now use my code =)
18:29:03 <Pseudonym> Arrows are functions in one category.
18:29:07 <desrt> i'm going to add support for constants to it
18:29:09 <desrt> or try to, anyway
18:29:15 <Pseudonym> But arrows are other things in other categories.
18:29:21 <Pseudonym> Grrr... this is too hard to explain.
18:29:24 <Cale> desrt: except that there are two kinds of arrows that get discussed around here, and they're similar on the surface, but very different
18:29:33 <Pseudonym> OK.  Learn monads first. :-)
18:29:45 <desrt> Cale; i switched over from radiant to gala to check out some old code i'd written
18:29:48 <desrt> my eyes went all weird :)
18:29:53 <cedricshock> pseudonym: what are monads?
18:30:35 <Riastradh> Generalizations of computation.
18:30:40 <Cale> cedricshock: They're data structures together with some idea of sequential computation.
18:31:06 <Pseudonym> Arrows are generalisations of this to non-sequential computation.
18:31:14 <Pseudonym> e.g. such as you find in dataflow graphs
18:31:22 <Cale> desrt: you getting all this? :)
18:31:28 <Pseudonym> Where's the monad tutorial?
18:31:33 <shapr> I think desrt went home.
18:31:35 <Cale> nomaware.com
18:31:46 <desrt> Cale; i definitely don't care right now :)
18:31:51 <desrt> shae; still here :)
18:32:09 <Cale> http://www.nomaware.com/monads/html/index.html
18:32:30 <shapr> desrt: whoops, I won't say anything more then ;-)
18:32:30 <Cale> http://www.nomaware.com/monads/html/analogy.html -- I found this useful when starting out.
18:32:32 <desrt> what sucks: i have to go to the bathroom
18:32:42 <Pseudonym> http://www.cs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
18:32:44 <Cale> desrt: haha - you don't have a key
18:32:46 <Pseudonym> That one's not too bad.
18:32:52 <desrt> Cale; you see my delemia
18:32:54 <Pseudonym> But there's a really huge tutorial somewhere.
18:33:08 <Pseudonym> Ahg, yes, that's it.
18:33:11 <Pseudonym> http://www.nomaware.com/monads/html/index.html
18:33:32 <Cale> The nomaware tutorial is pretty close to optimal :)
18:34:02 * desrt leaves this place
18:34:16 <desrt> bbiab
18:34:18 <cedricshock> So a monad is a computation that takes computations and combines them. A function is a function that takes functions and combines them.
18:34:20 <Cale> later
18:34:34 <cedricshock> I fail to see the difference in abstraction.
18:34:44 <Cale> cedricshock: no, not really
18:34:51 <cedricshock> No I do see the difference
18:35:05 <Pseudonym> A function, as we understand it, is only one abstraction which works for abstracting computation.
18:35:20 <desrt> errr
18:35:21 <desrt> problem
18:35:24 <cedricshock> We usually (and naivly) resolve the inputs of functions before sending them to the function
18:35:30 <desrt> there's gotta be some way of turning this monitor off without sleepign the computer
18:35:48 <Cale> desrt: not turning it off might work
18:35:54 <cedricshock> A monad is the same thing where we let the monad decide what to do with its input monads?
18:35:55 <desrt> ya.  i think you're right
18:36:01 <desrt> it'll sleep in 5 minutes according to energy saver
18:36:12 <Cale> desrt: run.
18:36:22 <Pseudonym> cedricshock: Not quite.
18:36:26 <desrt> run?
18:36:46 <Cale> If you need to access the machine from home or something :)
18:36:52 <desrt> noooo
18:36:55 <desrt> the screen will sleep in 5
18:36:56 <Pseudonym> OK.  In a functional language, many computations are effectively sequential.
18:36:58 <Cale> ah
18:36:59 <desrt> the computer never sleeps now :)
18:37:02 <Cale> okay
18:37:03 <desrt> anyway.  ta.
18:37:03 <Pseudonym> You do A, then B, then C.
18:37:15 <Pseudonym> You can imagine this as a pipeline of functions.
18:37:22 <Pseudonym> c (b (a x))
18:37:28 <Pseudonym> Right?
18:38:16 <Pseudonym> So in this sense, you're right.  Functions abstract sequential computation.
18:38:44 <Pseudonym> You with me, cedricshock?
18:38:51 <cedricshock> yeah
18:38:55 <Pseudonym> OK.
18:39:09 <Pseudonym> But in imperative languages, we know that this isn't the whole story.
18:39:23 <Pseudonym> b may not, for example, need to deal with everything that a returns.
18:39:42 <cedricshock> very true
18:39:45 <Pseudonym> And good programming practice demands that it not have access to that which it doesn't need.
18:40:18 <Pseudonym> One example is, for example, "output", for lack of a better word.
18:40:30 <Pseudonym> Say, trace infomation or printf-style debugging information.
18:40:53 <Pseudonym> Another is exceptions.  If a encounters an exceptional condition, b shouldn't get run.
18:41:00 <Pseudonym> Right?
18:41:36 <cedricshock> yep
18:41:47 <Pseudonym> Similarly, it might be more convenient to implement some of the data passed from b to a as something resembling "global state".
18:42:02 <Pseudonym> An example might be statistcs gathering.
18:42:20 <Pseudonym> It's not _really_ part of the return value from a, but it still needs to be passed.
18:42:34 <Pseudonym> And passing it explicitly is inconvenient, or obscures the interface to both a and b.
18:42:45 <cedricshock> unhunh
18:43:03 <Pseudonym> Right.  Well, for those situations, you don't really want pure functions, but you want something close.
18:43:06 <cedricshock> Like getting return values of {Ok, Data}, makes you add steps to the program to rip out the oks
18:43:11 <Pseudonym> Functions + a little bit extra, which is abstracted away.
18:43:14 <Pseudonym> Right.
18:43:24 <Pseudonym> Well, monads encapsulate and abstract this.
18:44:03 <Pseudonym> It's how, for example, Haskell implements I/O.
18:44:28 <Pseudonym> You can do it with just passing stuff around between functions, but it's a hell of a lot more convenient to abstract it.
18:45:32 <Pseudonym> I'm avoiding details here, I'm just trying to get across the difference.
18:45:52 <cedricshock> So a monad is a function with multiple independent return values that decides the fate of its own inputs, and a function is a broken function.
18:46:02 <Pseudonym> Uhm...
18:46:06 <Pseudonym> Not quite.
18:46:10 <Pseudonym> A monad is an abstraction.
18:46:17 <Pseudonym> Which supports certain operations.
18:46:33 <Pseudonym> A function is one possible implementation of a monad.
18:46:40 <cedricshock> A function is also an abstraction
18:46:44 <Pseudonym> Right.
18:46:54 <Pseudonym> Though not so much in Haskell.
18:47:01 <Pseudonym> In Haskell, functions are fundamental.
18:47:16 <cedricshock> A monad is one possible implementation of a function.
18:47:26 <Pseudonym> Hmmm.
18:47:41 <Pseudonym> No.  A monad is an abstraction.
18:47:49 <Pseudonym> Functions are fundamental.
18:47:51 <Riastradh> A function is one possible implementation of a monad.
18:47:53 <Pseudonym> That's how Haskell works.
18:48:08 <Cale> here's an example of a monad: Lists used to represent the return values of nondeterministic functions
18:48:19 <Pseudonym> OK, that's a good example.
18:48:24 <cedricshock> Fine. I'll agree, but in my head I still have an isomorphism between them
18:48:57 <Pseudonym> cedricshock, have you seen list comprehensions yet?
18:49:16 <cedricshock> I've seen them in erlang. Not in haskell though.
18:49:34 <Pseudonym> Right.  That's cool, at least we're in the same ballpark.
18:49:43 <Pseudonym> In Haskell, for example, you might write this:
18:49:51 <Pseudonym> [ (x,y) | x <- xs, y <- ys ]
18:49:58 <Pseudonym> To form the Cartesian product of two lists.
18:50:17 <cedricshock> Which means the list of all tuples where x is taken from xs and y from ys
18:50:17 <Pseudonym> OK?
18:50:21 <Pseudonym> Right.
18:50:28 <cedricshock> Almost exactly the same syntax.
18:50:33 <Pseudonym> Now you can think of xs not as a list, but as a single nondeterministic value.
18:50:40 <Pseudonym> Similarly for ys.
18:50:54 <cedricshock> ok
18:51:07 <Pseudonym> And what you're returning is returning a nondeterministic pair.
18:51:32 <cedricshock> Won't we have a never ending list of nendeterministic pairs?
18:51:46 <Pseudonym> If the values are never ending, sure.
18:52:08 <Pseudonym> Nondeterministic doesn't necessarily imply nonterminating, though.
18:52:19 <Pseudonym> Though having programmed in Prolog, I do wonder sometimes. :-)
18:52:36 <cedricshock> Prolog is nonterminating
18:52:44 <Cale> cartesian xs ys = do
18:52:44 <Cale>     x <- xs
18:52:44 <Cale>     y <- ys
18:52:44 <Cale>     return (x,y)
18:53:03 <Cale> there's an equivalent implementation using do-notation
18:53:06 <Pseudonym> Huh?  Plenty of Prolog programs terminate.
18:53:42 <cedricshock> Sure, but not in my lifetime ...
18:54:40 <ski> Cale: :t cartesian
18:55:04 <Pseudonym> Anyway.
18:55:08 <Cale> ski: good point :)
18:55:17 <Pseudonym> Haskell doesn't support nondeterministic functions directly.
18:55:25 <Cale> cartesian :: (Monad m) => m t -> m s -> m (t, s)
18:55:33 <Pseudonym> But monads (whether you use list comprehensions or do notation) model them.
18:55:47 <Pseudonym> List comprehensions are actually a kind of monad notation.
18:56:12 <Cale> It's too bad that they aren't monad comprehensions.
18:56:38 <Riastradh> Cale, you already have do; why do you need anything else?
18:56:51 <cedricshock> So is the hypothetical function comprehend(format, lists, tests)
18:57:03 <Cale> well, it would be nice that list functions would sometimes get more general types
18:57:23 <Riastradh> The relevant ones usually do, such as fmap.
18:57:26 <Pseudonym> cedricshock: No.
18:57:31 <Pseudonym> Let me give you another example.
18:57:46 <cedricshock> Ok
18:57:52 <Pseudonym> [ z | x <- xs, y <- f x, z <- g y ]
18:57:58 <Pseudonym> Where f and g are functions.
18:58:02 <Cale> and I think that sometimes the alternate notation would be nicer
18:58:11 <Pseudonym> You can kind of think of that as: g (f xs)
18:58:17 <Riastradh> Cale, what's wrong with do?
18:58:25 <Pseudonym> Except using nondeterministic values.
18:59:05 <cedricshock> ok
18:59:07 <Cale> nothing, but sometimes the comprehension format gets things across a little nicer.
18:59:15 <Cale> (not always)
18:59:36 <Cale> what's wrong with just using the do notation for lists?
18:59:39 <Cale> :)
18:59:42 <Riastradh> Nothing!
18:59:47 <Riastradh> Down with list comprehensions!
18:59:50 <Riastradh> Up with do!
18:59:59 <Cale> Sometimes the list comprehension syntax is just a little tighter.
19:00:10 <Cale> and gets things across a little better.
19:00:23 <Pseudonym> Anyway, cedricshock, are you getting the idea, at least for nondeterminism?
19:00:29 <Riastradh> do x <- xs; y <- f x; z <- g y; return z
19:00:39 <Riastradh> ...is only _slightly_ longer than the list comprehension equivalent.
19:00:43 <Pseudonym> If you use Riastradh's version, which he just wrote.
19:00:59 <Cale> Riastradh: but it reads differently
19:01:04 <Pseudonym> Then that code works whether you're just using functions or you're using nondeterministic functions via lists.
19:01:22 <Pseudonym> The monadic notation has abstracted away the difference.
19:04:00 <cedricshock> So has my brain. It's abstracted away the difference between functions and monads. It's even abstracted away the difference between imperative and functional programming. I should stop studying pure mathematics, I guess.
19:04:34 <Riastradh> A monad is a computation; it doesn't take input: it just computes some output.
19:04:34 <Pseudonym> :-)
19:04:37 <Pseudonym> No, you shouldn't.
19:04:39 <Riastradh> Therefore monads are not functions.
19:04:41 <Cale> cedricshock: perhaps a more formal definition of monad would set things straight :)
19:04:44 <Pseudonym> You should learn category theory.
19:04:52 <Pseudonym> It will help a lot.
19:05:15 <Riastradh> Or at the very least it will arm you with lots of obscure terms that no one outside of category theorists understands for the duels we occasionally have here in #haskell.
19:05:20 <Cale> http://planetmath.org/encyclopedia/Monad.html
19:05:27 <Pseudonym> Or duals, as the case may be.
19:05:46 * Pseudonym hits himself, hoping to start a coduel
19:05:55 <Riastradh> I was about to suggest that, Pseudonym.  May a pseudomorphism be a upon your house for saying it before I did!@
19:06:02 <Riastradh> Humph.  My @ key is excited.
19:07:01 <cedricshock> Ok. How about this compramise: A monad is different from a formal function.
19:07:14 <Pseudonym> True enough.
19:07:23 <Pseudonym> And a fish is different from a bicycle.
19:07:26 <cedricshock> The functions we talk about in programming are not formal functions. See above where someone said "nondeterministic function"
19:07:38 <Pseudonym> Hmmm.
19:07:51 <Pseudonym> The functions we talk about in Haskell are morphisms in a category.
19:07:59 <Pseudonym> This is why category theory helps.
19:08:05 <cedricshock> In my mind a programming function is way closer to this monad thing than to a formal function
19:08:22 <Cale> cedricshock: We only discuss pure functions in #haskell.
19:08:26 <Pseudonym> In imperative programming, that's very true.
19:08:42 <Pseudonym> For example, "functions" in C may have side-effects.
19:08:49 <Cale> or at least, that's the only thing we tend to use the word "function" for.
19:08:49 <Pseudonym> That's closer to a monad than a mathematical function.
19:09:19 <Riastradh> Actually, isn't a non-category-theoretical monad a one-element set?
19:09:29 <cedricshock> but its not a monad. As far as I can tell a monad can't have side effects.
19:09:42 <Pseudonym> cedricshock: A monad is an abstraction.
19:09:43 <Cale> cedricshock: oh, but it can. :)
19:09:56 <Pseudonym> Monads are good ways to model side-effects purely.
19:09:59 <Riastradh> It can have results that you just don't notice, which are thereby equivalent to side effects.
19:10:09 <Riastradh> It can also have inputs that you don't notice.
19:10:25 <Pseudonym> If it helps, monads can model C-style functions using only mathematical functions.
19:10:32 <Riastradh> The inputs & outputs are just the state that was side-effected.
19:10:39 <Riastradh> s/The/Those/1
19:10:48 <cedricshock> "functions" in c are almost always pure functions. They take an input state and return an output state. Frequently the output state involves a whole bunch of data somewhere you didn't expect
19:11:24 <ski> c_function : Memory -> Memory
19:11:33 <cedricshock> Exactly
19:11:37 <Pseudonym> Kind of.
19:11:42 <Pseudonym> Not quite.
19:11:52 <Pseudonym> There is one important respect where this is NOT true.
19:11:56 <ski> but that's bad for abstraction and encapsulation and modularity
19:12:04 <Pseudonym> c:function : Memory x Memory -> Memory
19:12:11 <Pseudonym> See where I'm getting?
19:12:17 <Pseudonym> Eeek.
19:12:21 <Pseudonym> See what I'm getting at?
19:12:40 <cedricshock> Nope
19:12:55 <Pseudonym> In C, memory is not splittable.
19:13:12 <Pseudonym> You can't, for example, execute a C function on memory that has been destructively updated.
19:13:23 <Pseudonym> Memory is a _linear_ type.
19:13:37 <Pseudonym> A given Memory state can be produced only once and consumed only once.
19:13:58 <Pseudonym> Though you can project it multiple times.
19:14:09 <cedricshock> So a monad is a formal abstraction for hiding a bunch of stuff in input and return values that.
19:14:27 <Pseudonym> Right, but like C functions, it can also do things like enforce linearity.
19:14:27 <Riastradh> No.  It _can_ be used for that, but that is not its sole purpose.
19:14:36 <Pseudonym> True.
19:14:52 <Pseudonym> Monads can abstract that, and that is one of the things they're commonly used for.
19:14:59 <Pseudonym> Possibly the most common.
19:15:05 <Riastradh> Monads are generalized computations.  That's the most specific thing you can say about every monad truthfully.
19:15:07 <ski> Pseudonym : why the 'x' in the type ?
19:15:18 <Pseudonym> ski: Cartesian product.
19:15:33 <ski> Pseudonym : i know. but why ?
19:15:35 <Pseudonym> I guess fork : Memory -> Memory x Memory
19:17:04 <Pseudonym> ski: Let me put it this way.
19:17:13 <Pseudonym> All of the following functions are C functions.
19:17:23 <Pseudonym> f :: Memory x Memory -> Memory
19:17:29 <Pseudonym> g :: Memory -> Memory
19:17:33 <Pseudonym> h :: Memory -> Memory
19:17:42 <Pseudonym> main :: Memory -> Memory
19:17:50 <Pseudonym> main mem = f (g mem) (h mem)
19:17:54 <Pseudonym> I defy you to write that in C.
19:17:58 <Pseudonym> For all f, g and h.
19:18:00 <ski> that's nonlinear
19:18:04 <Pseudonym> Right.
19:18:25 <Pseudonym> So what I'm getting at is that f can't be written in C.
19:18:28 <ski> so how could you write such an f in C ?
19:18:37 <ski> oh
19:18:40 * ski gets it
19:18:46 <Pseudonym> Bingo.
19:18:50 <Riastradh> Kersploink.
19:19:15 * ski thought Riastradh said he could write such an f ..
19:20:14 <Pseudonym> No, he said "Kersploink".
19:20:20 <Pseudonym> Hope this helps!
19:20:34 <cedricshock> Ok. So these arrow things. What do I do with them?
19:21:11 <Riastradh> ski, in what language does 'kersploink' mean 'I can write such an f that Pseudonym defied ski to?'
19:21:26 <Pseudonym> OK, monads abstract this kind of sequential computation.
19:21:43 <Pseudonym> Arrows abstract non-sequential computation.
19:21:47 <Cale> Riastradh: hahah
19:21:49 <Pseudonym> They're a generalisation of monads.
19:22:00 <cedricshock> So monads abstract arrows, or arrows monads?
19:22:13 <ski> Riastradh : no, earlier, i thought he was saying/implying some C functions have that type
19:22:22 <Pseudonym> Riastradh: The unit language, which is the terminal object in the category of languages.
19:22:32 <Cale> Hughes Arrows abstract monads
19:22:51 <Pseudonym> "Kersploink" and "I can write such an f
19:23:30 <Pseudonym> that Pseudonym defied ski to" map to the same object in the unit langage.
19:23:31 <Pseudonym> Arrows are a generalisation of monads.
19:23:31 <Pseudonym> Every monad is an arrow.
19:23:46 <cedricshock> ok
19:24:11 <Pseudonym> If you understand monads as linear flow, such as you have in the list comprehension...
19:24:23 <Pseudonym> Then arrows can model nonlinear flow, such as you might find in a spreadsheet.
19:24:44 <Pseudonym> You modify some value here, then computations fly around an arbitrary graph, rather than along a conveyor belt.
19:25:03 <cedricshock> yes. exactly.
19:25:27 <Pseudonym> Right, well that's what arrows are.
19:25:45 <Pseudonym> Which, getting back to the original topic, is why I think you should learn about them.
19:25:46 <ski> Pseudonym : does the backwards-state monad have linear flow ?
19:26:06 <Pseudonym> ski: Sure.
19:26:09 <cedricshock> Here's what I see about arrows: - Each function may be treated as a computation.
19:26:18 <cedricshock> Computations may be composed, by connecting the output of the first to the input of the second.
19:26:20 <Pseudonym> By "linear flow" Im' not talking about the evaluation rule.
19:26:27 <cedricshock> A computation may be applied to part of the input, with the rest copied through to the output.
19:27:00 <Pseudonym> cedricshock: This is right, but a "computation" here is a _generalised_ function.
19:27:04 <ski> Pseudonym : (oh. logical sequencing by (>>=) and (>>), then, i guess)
19:27:05 <cedricshock> Not very much there - it seems like a very simple and general abstraction
19:27:10 <Pseudonym> It might, for example, be nondeterministic, or have side-effects.
19:28:19 <cedricshock> How can it have side effects? There's nowhere in that model for them to happen. Unless the arrow modifies itself...
19:28:39 <Pseudonym> cedricshock: In the same way a monad can.
19:29:58 <cedricshock> I give it input, it gives me output. The output can't be a sifde effect, so the side effect must either be in altering the input or in altering itself.
19:30:24 <SamB> cedricshock: what about the IO arrow?
19:31:25 <cedricshock> Ok, so we are going to let this arrow do whatever it wants? Like kill other processes?
19:31:43 <ski> depends on what arrow we're in
19:31:58 <Pseudonym> cedricshock, now might be an excellent time to read the Fudgets thesis.
19:32:02 <Pseudonym> http://www.cs.chalmers.se/~hallgren/Thesis/
19:32:04 <ski> (s/arrow/arrow type (constructor)/)
19:32:41 <Pseudonym> It shows how they're useful in terms of GUIs.
19:32:48 <Pseudonym> Which is an application close to your heart.
19:33:14 <Pseudonym> Rather than thinking about them abstractly (which is useful), looking at some concrete examples will help, I think.
19:34:02 * desrt pumps in the sonic youth
19:35:37 <cedricshock> I like this: nother programming method might become more attractive, namely programming by copy and paste. This will soon result in programs which are complex to understand and maintain, but unfortunately, it is a too widely practised method.
19:35:52 <Pseudonym> :-)
19:36:59 <dons> desrt: I'm off to see SY in 18 days. yay!
19:37:09 <desrt> dons; :)
19:37:18 <desrt> lucky you.  where are they playing?
19:37:33 <dons> Sydney. First gig of the sonic nurse your
19:37:36 <dons> s/your/tour
19:37:40 <SamB> well, I think programming by delete is under-practiced
19:38:08 * SamB misread gig as gigabyte
19:38:16 <dons> hehe
19:38:56 <SamB> oh boy! my lag has gone down!
19:41:03 <Pseudonym> Lunch.  BBIAB
19:42:05 <Riastradh> Crazy Aussies.
19:42:25 * desrt plays some wild flower soul for Riastradh
19:43:27 <cedricshock> Ok, In haskell sum of a list can perform in constant space if the list arrives one element at a time?
19:44:42 <Riastradh> It can perform in constant space with no constraints, unless it overflows to bignums.
19:44:56 <ski> if there's no space leak
19:45:10 <Riastradh> ?
19:45:54 <ski> if the list is retained for some reason ..
19:46:14 <Riastradh> That has nothing to do with the space complexity of the summing function.
19:46:59 <ski> hmm, maybe not ..
21:04:45 <aFlag> hi
21:05:06 <aFlag> i'm starting to learn haskell, which ocmpiler/interpreter do you guys suggest?
21:05:26 <Riastradh> GHC
21:06:27 <aFlag> alright, i'll get it, i'm also installing hugs for that interactive interpreter feature, is it any good?
21:07:12 <Riastradh> It's a bit more bothersome than GHC, because you can't incrementally define functions & variables in Hugs' REPL, whereas you can in GHCi.
21:07:57 <aFlag> what do you mean by incrementally define functions?
21:08:07 <SamB> and lots of other little annoyances
21:08:09 <Riastradh> In Hugs, you have to write out the function definitions to a file and then load that file into Hugs.
21:08:50 <aFlag> and how would you do it in ghc?
21:09:32 <Riastradh> You do it as if the GHCi input were one big do; that is, you just use let -- for instance, you might send this to the REPL: let x = 5
21:10:41 <aFlag> hum... i think i'll just get ghc :P
21:11:04 <aFlag> i'm new to this functional programing world
21:11:21 <aFlag> i hope my brain doesn't blow :P
21:11:47 <SamB> hugs does one or two things in a way that can be nicer than the way GHC does them
21:12:27 <SamB> but if you aren't running debian, you may not wish to bother installing it ;-)
21:12:50 <aFlag> i'm on slackware actually :(
21:13:51 * SamB just figured out why aFlags name was showing some odd pixels: there was an Xv window there, and the colorkey was matching with some of the antialiased pixels
21:14:27 <aFlag> heh
21:15:13 <SamB> I was afraid something was wrong with xchat/gtk2/xft
21:15:39 <monotonom> hugs is easy to install on redhat
21:15:52 <SamB> the really odd part is the Xv window was minimized
21:16:01 <monotonom> I think it is easy to install everywhere.
21:17:57 <SamB> monotonom: yes, but it requires more work than apt-get install hugs, doesn't it?
21:18:11 <monotonom> You are so spoiled.
21:18:30 <SamB> hehe ;-)
21:18:57 <monotonom> There are actually people out there who 1. claim they are naive users, 2. build ghc from source.
21:19:22 <dons> hehe
21:19:35 <dons> it's easy right? just type "make"
21:20:07 <SamB> monotonom: maybe they are naive.
21:21:09 <SamB> although they would obviously have to be non-naive enough to realize that they needed binaries first
21:21:22 <monotonom> I commend their courage but I have low opinion on their intelligence. Especially when they then say "make gives me a lot of these technical messages 'leaving directory etc' but doesn't tell me success or failure, could you people make it more user-friendly?"
21:21:23 <SamB> unless, of course, they were gentoo users, which doesn't count
21:22:04 <dons> make && echo $?
21:22:07 <SamB> hehe. that is bad ;-)
21:22:18 <SamB> especially since it does make noise about failure
21:22:33 <dons> make ; echo $? might be better
21:22:49 <monotonom> Yeah. The naive user made that request on the haskell list. So last night I wrote my objection.
21:23:14 <monotonom> err on the ghc list
21:23:56 <SamB> and, of course, make is nothing to do with haskell in particular
21:24:09 <Riastradh> Which is precisely why you should complain about it on the GHC list!
21:25:12 <monotonom> Hrm my response doesn't show up. It needs manual approval because my ISP changed its hostname slightly (from @vex.net to @shell.vex.net) and so the computers did not recognize it as a subscriber's address.
21:25:12 <SamB> and no more to do with ghc
22:14:14 <aFlag> checkinstall had trouble making a ghc package, but althought it got installed anyway :(
22:18:16 <aFlag> is there a emacs module or something for highligthing haskell syntax?
22:19:15 <polli> aFlag: yes
22:19:41 <aFlag> where do i get it?
22:19:47 <polli> http://www.haskell.org/libraries/#editormodes
22:42:11 <yc> could someone tell me what this means: Ambiguous type variable `player' in the top-level constraint:
22:42:11 <yc>   `CluedoPlayer player'
22:42:11 <yc>     arising from use of `newPlayer' at <interactive>:1
