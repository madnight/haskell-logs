01:10:20 <shapr> @yow !
01:10:21 <lambdabot> I decided to be JOHN TRAVOLTA instead!!
01:10:35 <shapr> good morning #haskell!
01:11:10 <andersca> hey hey
01:13:02 <shapr> wassup?
01:14:14 <Lor> vappu.
01:19:45 <shapr> yah, there is that
01:31:17 <phubuh> hi
01:45:52 <shapr> hi phubuh 
01:54:48 <shapr> so, anyone writing cool code?
02:03:05 * esap is writing a compiler. Is that cool?
02:03:16 <shapr> that is cool
02:04:11 <esap> the problem is, you shouldn't hold your breath on the premise that it will be ready within the next 10 years or so :-)
02:04:39 * Lor would write a compiler if he had the language to write it for.
02:05:04 * esap is designing the language as I go [yes, I know it's not the recommended way]
02:05:53 * Lor always has motivation problems when trying to implement existing languages, because sooner or later one gets the feeling "augh, this is stupid, why am I wasting my time on such a stupid language?"...
02:06:04 <esap> hehe
02:06:13 <esap> my experience as well.
02:06:14 <shapr> I'd enjoy writing a Joy compiler
02:06:33 <Lor> Or forth, maybe.
02:06:41 <shapr> but there are so many other things to do too
02:06:56 <Lor> scheme would be so pretty if it weren't so ugly.
02:12:40 * ibid has an incomplete c compiler /me wrote somewhere
02:14:32 <Cale> heh, scheme without parens, and only the offside rule for grouping would be funny
02:16:25 * ibid threw it out in disgust when i realized how tangled preprocessing and parsin are
02:16:27 <Lor> There's an srfi for that.
02:17:50 <Lor> http://srfi.schemers.org/srfi-49/srfi-49.txt
02:53:02 <shapr> @yow !
02:53:03 <lambdabot> Hold the MAYO & pass the COSMIC AWARENESS...
04:00:25 * shapr boings happily
04:00:33 <shapr> wassup folks?
04:19:13 * bring is trying to focus
04:19:44 * bring is just not quite sure what to focus on
04:20:01 <shapr> code!
04:20:03 <andersca> <andersca> Burrito, focus
04:20:03 <andersca> <Burrito> FOCUS you BABOON!
04:20:26 <bring> andersca: ?
04:20:37 <shapr> FOCUS!
04:21:09 <shapr> I got new focus drugs, I'm so happy
04:21:25 <shapr> Concerta intsead of Ritaline
04:21:37 <bring> is it better?
04:21:40 * shapr swears at Zope
04:21:58 <shapr> I dunno yet, still on my fist dose
04:22:45 <bring> so cool that Lunar^ is coming to EuroHaskell, hope we can get a lot of hOp hacking going
04:22:49 <shapr> yes!
04:23:02 <shapr> I'm very much looking forward to EuroHaskell
04:23:24 <shapr> hey, I think we need sprint leaders if we end up with enough separate sprinters
04:23:48 <shapr> well, coach is the XP term
04:24:13 * shapr wants to check the HaWiki
04:24:53 <bring> there were 18 people signed up wil reasonable likelihoods of attendeance last time I saw it
04:25:00 <bring> s/wil/with/
04:25:04 <shapr> hey, did I already mention that darcs could allow for backup wikis so that if one goes down the changes can still be committed?
04:25:11 <shapr> ah, nifty
04:25:54 <shapr> I haven't heard from anyone else via email
04:26:02 <bring> josef svenningson, Lunar^ and ludde were the latest additions
04:26:04 <shapr> oh, who's Ulf Nordstrom?
04:26:15 <bring> no idea
04:26:21 <bring> you mean Ulf Norell?
04:26:29 <shapr> josefs has been here a few times
04:26:31 <shapr> maybe
04:27:11 <shapr> ahi, yes
04:27:33 <bring> phd student at CS at Chalmers
04:27:38 <shapr> ok
04:29:42 <bring> czar of the multi group
05:03:14 <Lurc> Haskell Curry.
05:06:30 <shapr> Lurc: he's the man!
05:06:43 <shapr> g'day clausen
05:06:53 <clausen> gday shapr
05:07:06 <clausen> shapr: how do you know sacha?
05:07:11 <clausen> (did I already ask?)
05:13:33 <shapr> clausen: sacha who?
05:13:43 <clausen> sandra chua
05:14:03 <clausen> on orkut, you are listed as friends (?)
05:14:38 <shapr> you mean Sacha Chua?
05:14:48 <shapr> aka sachac on #emacs?
05:15:27 <shapr> I know her, she's very nifty.
05:16:58 * liiwi tackles shapr
05:17:11 <shapr> hei liiwi 
05:17:20 * shapr vaistaa
05:17:33 <liiwi> hej hej
05:17:40 <clausen> her name is actually sandra
05:17:49 <clausen> but, everyone calls her sacha :)
05:17:58 <shapr> ok
05:20:00 <shapr> clausen: I met her on #emacs, I like emacs.
05:20:10 <clausen> thanks, makes sense
05:20:24 <clausen> #emacs is prolly a good place to meet diverse nerds
05:20:52 <shapr> yup
05:20:58 <liiwi> yess
05:21:55 <shapr> has anyone tried to wrap crystalspace for Haskell?
05:23:47 <shapr> hi aLpersen 
05:23:55 <aLpersen>   LAST MINUTE!! TERROR IN AMERICA AGAIN! 15 MINUTE AGO A BIG EXPLOSION WAS HEARD ! FOR MORE INFORMATION ABOUT THAT BOMB TERROR CLICK THAT NEWS PORTAL =====> WWW.DALNETBULTENI.COM <=====
05:24:04 <shapr> oh spammer
05:24:05 <aLpersen>   LAST MINUTE!! TERROR IN AMERICA AGAIN! 15 MINUTE AGO A BIG EXPLOSION WAS HEARD ! FOR MORE INFORMATION ABOUT THAT BOMB TERROR CLICK THAT NEWS PORTAL =====> WWW.DALNETBULTENI.COM <=====
05:24:06 <aLpersen>   LAST MINUTE!! TERROR IN AMERICA AGAIN! 15 MINUTE AGO A BIG EXPLOSION WAS HEARD ! FOR MORE INFORMATION ABOUT THAT BOMB TERROR CLICK THAT NEWS PORTAL =====> WWW.DALNETBULTENI.COM <=====
05:24:19 --- mode: ChanServ set +o shapr
05:24:33 --- kick: aLpersen was kicked by shapr (Kicked by shapr)
05:24:56 --- kick: aLpersen was kicked by shapr (Kicked by shapr)
05:25:10 --- kick: aLpersen was kicked by shapr (Kicked by shapr)
05:25:12 <shapr> this is fun
05:25:58 --- mode: shapr set +b *!*@*.mweb.co.za
05:26:01 --- kick: aLpersen was kicked by shapr (Kicked by shapr)
05:26:31 <liiwi> heh, did not have much use for /kb alias, eh :P
05:26:44 <shapr> don't even have one
05:26:55 <shapr> seems I need one
05:29:10 <saz> hmf
05:29:19 <shapr> hi saz
05:29:22 <shapr> wassup?
05:29:30 <saz> not much
05:29:34 <saz> should do some work!
05:29:43 <saz> i'm too good at wasting time I think
05:29:51 <shapr> me too
06:15:45 <shapr> hi kr_angelov 
06:15:51 <shapr> how's HToolkit?
07:15:28 <shapr> dang, I got distracted by unicycling
07:16:19 <liiwi> heh
07:17:23 <shapr> I can almost turn left now
07:19:47 <liiwi> took me couple years to go right like in a curve with ice skates
07:20:00 <liiwi> something to do with right leg being stronger
07:35:08 <Spark> mm ice skating
07:35:17 <Spark> i used to do that when i was really young
07:50:03 * bring wants haskell.org
07:52:04 <bring> back up that is
11:04:47 <Hetrish> HELLO
11:04:49 <Hetrish> ops
11:04:50 <Hetrish> hello
11:04:51 <Hetrish> :)
11:05:08 <Hetrish> I just noticed I'm having some trouble with some apparently simple stuff...
11:05:50 <Hetrish> I was just going to define an average function to compute some stuff... I didn't even bother to make it efficient
11:06:18 <Hetrish> so I just defined it like sum over length
11:06:33 <Hetrish> but I want to use it with both integers and floats
11:06:36 <Hetrish> well
11:06:51 <Hetrish> to use it with integers I need to map the elements with fromIntegral
11:07:09 <Hetrish> to use it with floats I cannot map it with from Integral
11:07:29 <Hetrish> so how do you define it to work with class Num?
11:07:36 <cm> why do you need fromIntegral
11:07:56 <Hetrish> cm: because I'm going to use "/" to divide...
11:07:56 <cm> ah, in order to be able to divide?
11:07:59 <Hetrish> yeap
11:08:19 <SyntaxLaptop> Hetrish: what do you want the return type to be?
11:08:27 <Hetrish> SyntaxLaptop: Fractional
11:08:34 <Hetrish> any Fractional
11:09:06 <Hetrish> average :: (Num a, Fractional b) => [a] -> b
11:09:36 <SyntaxLaptop> and what's your definition
11:09:52 <Hetrish> average xs = sum (map fromSomething xs) / fromIntegral (length xs)
11:09:55 <Hetrish> :)
11:10:01 <Hetrish> (forget about efficiency)
11:10:27 <Hetrish> I know I should use a foldl to process the list once
11:10:35 <Hetrish> and even use strictness
11:10:52 <Hetrish> (which I always have to think how to use when I dealing with pairs of numbers)
11:10:57 <Hetrish> anyway
11:11:08 <Hetrish> now I'm just thinking about the types
11:11:12 <Hetrish> should be easy
11:11:29 <Smerdyakov> What's fromSomething?
11:11:40 <Hetrish> Smerdyakov: that's my problem! ;)
11:11:57 <Smerdyakov> Hetrish, you shouldn't need to do _any_ mapping over xs.
11:12:16 <Hetrish> Smerdyakov: that way it doesn't work for Integrals!
11:12:22 <Hetrish> Smerdyakov: Ints or Integers
11:12:30 <Hetrish> Smerdyakov: because I need to divide
11:12:44 <eivuokko> 20:34 < bring> $(field "xid" "id" "Id" True "Int")
11:12:45 <eivuokko> 20:34 < bring> will give you:
11:12:45 <eivuokko> 20:34 < bring> data Id = Id
11:12:45 <eivuokko> 20:34 < bring> instance FieldTag Id
11:12:45 <eivuokko> 20:34 < bring> where fieldName _ = "id"
11:12:47 <eivuokko> 20:34 < bring> xid :: Attr Id (Maybe Int)
11:12:50 <eivuokko> 20:34 < bring> xid = mkAttr Id
11:12:52 <eivuokko> Oops, sorry.
11:13:00 <Hetrish> Smerdyakov: right?
11:13:04 <Smerdyakov> Hetrish, I'm not entirely familiar with the type class function here, but the most you should need is a toFractional (or whatever the name of it is), not a mapping of a fromAnything.
11:13:13 <Hetrish> Smerdyakov: oh
11:13:24 <Hetrish> Smerdyakov: I didn't know about toSomething...
11:13:31 <Smerdyakov> Hetrish, you probably don't need that, either.
11:13:33 <Hetrish> weird... I should know those things...
11:13:39 <Hetrish> Smerdyakov: of course I need...
11:13:41 <Smerdyakov> Hetrish, just remove the first map and it should work.
11:13:49 <Hetrish> Smerdyakov: no it doesn't ;)
11:14:01 <bring> Hetrish: also, you can do it on the sum, instead of mapping it over the list
11:14:19 <Smerdyakov> OK. So change the type class of a from Num to Fractional.
11:14:24 <Hetrish> bring: I know, that is a terrible definition
11:14:30 <Smerdyakov> Then I think all your troubles will be solved.
11:14:30 <Hetrish> bring: :)
11:14:50 <Hetrish> bring: But I want it to be num! to be able to do use integers
11:14:51 <Smerdyakov> (Including not needing the first map or any equivalent of it)
11:14:56 <Hetrish> bring: But I want it to be num! and ints
11:14:59 <Hetrish> opss
11:15:07 <Hetrish> Smerdyakov: but I want Num there
11:15:34 <Hetrish> Smerdyakov: I want to use it with Int and Integers not just Fractionals, but yeah, toFractional is the way to go
11:15:35 <Smerdyakov> I was thinking integers would be converted automatically, but I guess that isn't true.
11:15:40 <Hetrish> nope it isn't 
11:15:42 <Hetrish> ;)
11:15:52 <Hetrish> hmmmmmmm
11:15:57 <Hetrish> Variable not in scope: `toFractional'
11:16:04 <Smerdyakov> I told you that wasn't the real name of a function.
11:16:07 <Hetrish> in which module is this
11:16:10 <Hetrish> oh
11:16:12 <Hetrish> eh
11:16:21 <Hetrish> I thought I would have heard of it :)
11:16:31 <Hetrish> damn
11:16:39 <Smerdyakov> Clearly there will be a way to convert integers to rationals.
11:16:46 <Hetrish> yes
11:16:46 <Smerdyakov> You just need to find the name of that function.
11:16:49 <Hetrish> fromIntegral
11:16:57 <Hetrish> fromIntegral works!
11:17:15 <Hetrish> but then I can't use it for non-Integrals, i.e. Fractionals
11:17:27 <Hetrish> because the fromIntegral expects an Integral ;)
11:17:29 <Hetrish> argh!
11:17:59 <Hetrish> I know I can define my own, toFractional
11:18:24 <Hetrish> but this seems so weird, it *must* be easy, I *must* be missing something
11:18:31 <Hetrish> I hope
11:18:36 <anyone> I think you are missing something.
11:18:45 <Hetrish> anyone: good! what? :)
11:18:58 <Hetrish> anyone: I think I am missing something to but that is not enough
11:19:07 <Hetrish> anyone: any hint ;)
11:19:12 <anyone> I can't get to the docs at www.haskell.org; otherwise I would rub it into your face.
11:19:37 <Hetrish> it would be my pleasure
11:19:39 <Hetrish> ;)
11:20:03 <Hetrish> wait
11:20:25 <Hetrish> I might have found it
11:21:15 <SyntaxLaptop> Hetrish: http://haskell.cs.yale.edu/ghc/docs/latest/html/libraries/index.html
11:21:17 <anyone> It would be nice if lambdabot had reverse type lookup, i.e., if I input "Float -> Int" it outputs all library functions that are at least as general as that type.
11:21:46 <SyntaxLaptop> hm. links aren't working
11:21:56 <SyntaxLaptop> Hetrish: are you unable to reach the API?
11:22:01 <bring> haskell.org's been down all day
11:22:05 <SyntaxLaptop> oh :(
11:22:11 <Hetrish> yeap :-/
11:22:13 <SyntaxLaptop> Hetrish: are you using Debian, by chance?
11:22:28 <Hetrish> hmm no but yeah maybe I have the docs installed
11:22:33 <Hetrish> I usually just got to haskell.org
11:22:42 <Hetrish> so I didn't eve think about it
11:22:49 <SyntaxLaptop> http://packages.debian.org/unstable/doc/ghc6-doc
11:22:59 <SyntaxLaptop> you can download a source package of the docs from Debian at that site.
11:24:04 <Hetrish> wait I got them!
11:24:05 <Hetrish> nice
11:30:01 <pesco> Hey Ho.
11:30:46 <pesco> Fix haskell.org! :-P
11:31:25 <Hetrish> SyntaxLaptop: can't find anything usefull tough...
11:31:42 <Hetrish> SyntaxLaptop: the only thing with a toSomething is Rational
11:32:01 <Hetrish> SyntaxLaptop: so in theory I think I could do a fromRation.toRational
11:32:17 * bring shudders
11:32:24 <Hetrish> but that's horrible :D
11:32:26 <pesco> Has anyone here got an idea about whether there is development going on on Yampa?
11:32:46 <Hetrish> now really I find this weird, but have no idea how to do it
11:32:56 <bring> you could do it with a type class
11:33:07 <bring> but that really shouldn't be neccessary
11:33:19 <pesco> Hetrish: What's the problem?
11:34:14 <Hetrish> pesco: simple, define an average function with type:
11:34:21 <Hetrish> average :: (Num a, Fractional b) => [a] -> b
11:34:32 <SyntaxLaptop> Hetrish: you're not the only one who can't figure it out at least ;)
11:34:35 <Hetrish> (no need for efficient stuff)
11:34:47 <Hetrish> SyntaxLaptop: on one hand that makes me feel better
11:35:05 <bring> do you need it to be accurate?
11:35:08 <Hetrish> SyntaxLaptop: on the other hand I'd like to know a solution :)
11:35:20 <Hetrish> bring: define accurate
11:35:24 <Hetrish> bring: :)
11:35:31 <SyntaxLaptop> what we need is f :: (Num a, Fractional b) => a -> b
11:36:14 <Hetrish> using google cache I found:
11:36:18 <Hetrish> 12.  Typing Pitfalls
11:36:26 <Hetrish> but then their example uses
11:36:31 <pesco> avg xs = sum xs / fromIntegral (length xs)
11:36:32 <Hetrish> average                 :: (Fractional a) => [a] -> a
11:36:33 <Hetrish>  average xs              =  sum xs / fromIntegral (length xs)
11:36:46 <pesco> Oh, :(
11:36:54 <Hetrish> nope!
11:36:56 <Hetrish> ;)
11:36:59 <pesco> I see now.
11:37:30 <bring> if you convert the sum to an Integer and use div, it wouldn't always be very accurate
11:37:52 <Hetrish> yeap
11:38:19 <bring> you could also use some show and read weirdness for the conversion
11:38:29 <Hetrish> it wouldn't work that well with say, numbers in [0, 0.01] ;)
11:38:37 <pesco> bring: Wahahaaa!
11:38:38 <bring> yes
11:39:08 <Hetrish> show and read?
11:39:13 <Hetrish> come on! :)
11:39:13 <bring> I have seen code that basically uses read.show as a hacky coercison function
11:39:24 <bring> slow and nasty
11:39:32 <Hetrish> I'm talking about an "average" function!!!
11:39:33 <Hetrish> :)
11:40:19 <pesco> So what, it's funny to read at least!
11:40:37 * bring is trying to come up with even more arcane ways of doing it
11:40:51 <Hetrish> I'd guess this could be a 1st semester in haskell question... 
11:41:27 <Hetrish> argh
11:41:35 <Smerdyakov> Classes that use Haskell to teach programming concepts in the 1st semester generally won't go into type class details, I think.
11:41:45 <Hetrish> no?
11:41:54 * Hetrish never had haskell classes...
11:42:34 <bring> I think the problem  with this example is that there isn't very much in the Num class
11:42:34 <Hetrish> anyway... I'd expect this not to be that complicated
11:42:58 <SyntaxLaptop> it's kinda funny that none of us has ever run into this problem :)
11:43:13 <Hetrish> I haven't run into it either
11:43:16 <Hetrish> I just made it up
11:43:17 <Hetrish> :)
11:43:22 <bring> thus there is no general way to make anything that is an instance of Num into something Fractional
11:43:54 <bring> yeah, you'd think you'd run into this every day
11:44:44 <Smerdyakov> bring, which is sensible, since you can't treat complex numbers as Fractionals.
11:44:55 <bring> exactly
11:47:28 <SyntaxLaptop> OK gottago
11:47:33 <Hetrish> ok
11:50:04 <pesco> Ah, of course, this makes sense.
11:55:14 <bring> is settling for Real instead of Num, and going through Rational our best bet so far?
11:56:02 <Hetrish> I guess so
11:56:37 <Hetrish> "is settling for Real", I was thinking settling for Rational...
11:56:41 <Hetrish> why Real?
11:57:07 <Hetrish> opss
11:57:11 <Hetrish> Fractional I mean
11:57:21 <Hetrish> (/) :: forall a. (Fractional a) => a -> a -> a
11:57:56 <bring> Integer and Int are Instances of Real
11:58:14 <Hetrish> oh
11:58:44 <Hetrish> hmmm
11:59:16 <bring> so I meant to replace Num (which seems to general) with Real in the constraints of avg
12:00:04 <bring> which should be ok if you don't care about complex numbers
12:00:44 <Hetrish> yeap that would be fine...
12:01:04 <Hetrish> average xs = sum (map toRational xs) / fromIntegral (length xs)  ??
12:01:45 <Hetrish> but then I get Rationals...
12:01:51 <Hetrish> I don't want to use Rationals...
12:02:10 <bring> use fromRational on the result
12:02:28 <Hetrish> argh
12:02:35 <Hetrish> yes, I've mentioned that
12:02:40 <Hetrish> but it's awfull :
12:02:42 <Hetrish> :)
12:02:45 <bring> avg xs = fromRational (toRational (sum xs) / fromIntegral (length xs))
12:02:55 <bring> or something hideous like that
12:03:14 <Hetrish> yeah I've mentioned that too, but I rather not consider that as an option! lol
12:05:50 <bring> avg xs = ((read.show) (sum xs)::Double) / fromIntegral (length xs)
12:06:50 <Hetrish> bring: if you keep doing that I'm quiting haskell and back to C!
12:06:55 <Hetrish> ;)
12:07:08 <bring> avg xs = ((read.show) (sum xs)) / fromIntegral (length xs)
12:07:10 <bring> is better
12:07:17 <bring> dunno why I put DOuble in there
12:07:25 * bring likes hacks
12:07:51 <skew> what's the problem here?
12:07:59 <Hetrish> I skew
12:08:12 <skew> it looks like you all are making something way more complicated than it needs to be.
12:08:25 <bring> hopefully, yes
12:08:39 <skew> but the conversation has been going on so long I can't read back and see what!
12:09:05 <cm> skew: polymorphic average function, or something
12:09:12 <Hetrish> I guess the problem is defining an average function that works for lists of Floats and Ints using type classes...
12:09:14 <skew> what type do you want?
12:09:21 <Hetrish> (it's underspecified I know)
12:09:23 <Hetrish> so 
12:09:37 <Hetrish> the original problem was
12:09:46 <Hetrish> defining am average function with type:
12:09:51 <Hetrish> average :: (Num a, Fractional b) => [a] -> b
12:10:03 <bring> Hetrish: if it's just Float and Int, just make a type class with two instances :)
12:10:10 <Hetrish> after talking with everybody here, maybe I meant:
12:10:48 <Hetrish> average :: (Real a, Real b) => [a] -> b
12:10:52 <Hetrish> but not sure...
12:11:25 <Hetrish> skew: anyway you get the picture, I want an average function I can use with Doubles but also with Ints...
12:11:31 <Hetrish> bring: eh :P
12:11:59 <bring> I think it should be Fractional b, since / is in Fractional
12:12:04 <skew> well, Real is the most specific numeric class including both of those
12:12:11 <Hetrish> skew: sum xs / fromInteger (length xs) 
12:12:24 <skew> the bottom can be genericLength
12:12:31 <Hetrish> opss wait
12:12:36 <Hetrish> skew: sum xs / fromIntegral (length xs) 
12:12:51 <Hetrish> this doesn't work for xs:: [Int]
12:13:02 <bring> but how do you make the sum a Fractional
12:13:05 <Hetrish> skew: sum (map fromIntegral xs) / fromIntegral (length xs) 
12:13:09 <bring> without resorting to Rational
12:13:24 <Hetrish> but this doesn't work for lists of Integrals
12:13:33 <Hetrish> and that's tghe problem!
12:14:18 <skew> the only solution that handles Double and Int will go through toRational
12:14:29 <Hetrish> skew: exactly!
12:14:36 <Hetrish> skew: but that's terrible isn't it?
12:14:42 <skew> which is not necessarily as bad as it sounds
12:14:46 <Hetrish> skew: no?
12:15:00 <bring> or a writing an overloaded function
12:15:21 <Hetrish> skew: can you have ad-hoc overloading in haskell???
12:15:22 <skew> bring: but that's the only remotely useful operation the standard typeclasses give you
12:15:37 <skew> Hetrish: that's one of the things type classes let you do
12:15:59 <Lor> Well, it's not _that_ ad-hoc.
12:16:02 <skew> better than C++ and the like actually, because you can also overload on return type
12:16:13 <Hetrish> skew: ? you lost me...
12:16:25 <Hetrish> skew: that kind of overloading is what I'm trying to do here...
12:16:35 <Hetrish> skew: (which is not ad-hoc)
12:17:01 <Hetrish> skew: and using type classes, like you said, I must resort to toRational and fromRational
12:17:06 <skew> you can make a class like class Averagable a where avg :: (Fractional b) => [a] -> b
12:17:16 <skew> no, I mean without defining your own
12:17:20 <Hetrish> oh
12:17:36 <Hetrish> yeah that I know
12:17:39 <skew> anyway, toRational and fromRational might not be that bad, like I said
12:17:46 <Hetrish> yes on to that then
12:18:11 <skew> the thing is that at least with GHC you can provide specialized versions of a polymorphic function for particular types
12:18:26 <Hetrish> hmmm...
12:18:54 <Hetrish> you can produce them yourself or tell the compiler to produce them?
12:18:57 <skew> ^ is specialized for most cases where the arguments are Int or Integer, for example
12:19:26 <Hetrish> you can tell the compiler to specialize it right?
12:19:35 <skew> you write your own, and tell it to use this version if they call the generic function at a particular type
12:19:48 <skew> you are responsible for ensuring both compute the same thing, of course
12:19:53 <Hetrish> oh
12:19:58 <skew> I don't know if GHC does much specialization
12:20:07 <Hetrish> I didn't know that
12:20:12 <skew> It
12:20:21 <skew> It's not something you usually need to worry about it
12:20:30 <skew> but the libraries do it in a few places to improve performance
12:20:40 <skew> improve performance in common cases, that it
12:21:07 <Hetrish> yes but coming up with hacks just to solve this sort of issues seems really bad...
12:21:29 <skew> I expect that there exists a toFractional :: (Real a, Fractional b) => a -> b
12:21:46 <Hetrish> so I'd end up with orverloaded version which I don't really want to use and making my own specializations
12:21:59 <skew> Hetrish: no, I'm thinking that we can write something clear but inefficient-seeming and lots of coolness and lots of hacks behind the scense will make it run fase
12:22:17 <Hetrish> skew: toFractional would solve the problem
12:22:23 <Hetrish> skew: but there isn't one
12:22:26 <skew> no?
12:22:32 <Hetrish> nope
12:22:33 <skew> just a minute, I'm off to look
12:22:50 <Hetrish> skew: if there was I'd just type
12:23:11 <Hetrish> skew: sum (map toFractional xs) / fromIntegral (length xs) 
12:23:23 <Hetrish> and seems to me like that would be the way to go
12:23:49 <skew> I think toFractional (sum xs) would involve less conversions
12:23:57 <skew> and probably do the sum in a faster numeric type
12:24:11 <Hetrish> skew: yes of course
12:24:12 <Hetrish> :)
12:24:15 <skew> also, genericLength (Data.List) is more or less fromIntegral . length
12:24:56 <Hetrish> oh I thought genericLength returned an Integer
12:25:01 <Hetrish> not an Integral
12:25:05 <Hetrish> yes nice touch
12:25:49 <skew> genericLength actually returns anything in Num
12:25:53 <Hetrish> nice
12:25:56 <Hetrish> never used it...
12:26:34 <Marvin--> skew: I wouldn't say that it's more or less fromIntegral . length
12:26:38 <Hetrish> btw I know the definition is terrible, should use a foldl move once on the list, and proably seq to make it strict, but that is not important now
12:26:53 <Hetrish> I just wanted to deal with the types now
12:26:57 <skew> Hetrish: I don't think strictness is much of an issue
12:27:06 <Hetrish> skew: yeap it is...
12:27:11 <skew> sum is already doing a foldl or a strict foldl or whatever
12:27:20 <skew> at least, it should be
12:27:31 <Hetrish> but if you use a foldl like I said it is an issue
12:27:51 <Hetrish> and not even a simple strict foldl will work because then your dealing with pairs
12:27:52 <skew> all the numeric functions are strict so the strictness analyzer should be able to tell the whole thing is strict
12:28:20 <Hetrish> skew: yeap but to avoid going through the list twice you'll have to use fold
12:28:44 <Hetrish> skew: and you'll be dealing with pairs (sum, length)
12:28:57 <skew> I suppose so
12:29:02 <Hetrish> skew: so you have to be really careful about strictness
12:29:06 <skew> what are you writing that averaging a list is taking most of your runtime?
12:29:21 <Hetrish> skew: I'm not writing anything (yet anyway)
12:29:36 <Hetrish> skew: I just came up with this problem
12:29:49 <Hetrish> skew: but I had to deal with the folds over pairs before...
12:30:15 <Hetrish> skew: maybe when I implemented some neural networks, not sure
12:30:53 <Hetrish> anyway it was pretty bad because I was also using a sum, and when I wanted to compute pairs the damn thing was not strict anymore
12:31:18 <Hetrish> skew: so any luck with toFractional or something like that?
12:31:21 * Hetrish had no luck
12:31:23 <Hetrish> opssss brb
12:31:28 <Hetrish> phone
12:34:18 <skew> a toFractional :: Real -> Fractional in the library is definitely the right way to do this
12:35:00 <Smerdyakov> Well, an actual real number can't be converted in that way. :P
12:36:05 <skew> right, the carrier really should be a lazy infinite precision real
12:36:52 <skew> in your own code, maybe a typeclass would work better
12:37:26 <skew> unfortunately instance (Integral a) => MyClass a and instance (Fractional a) => MyClass a don't get along
12:44:54 <skew> hey, how about readToFrac?
12:45:05 <skew> er, realToFrac
12:52:27 <skew> in the Prelude even
12:55:49 <skew> oh, GHC does have a pragma for telling it to specialize a function at a particular type
12:56:21 <skew> realToFrac is blessed with rules implement identiy conversions on Float and Double with just id
12:58:44 <skew> I'm tracing through definitions and pragmas around toRational, but it looks like that might mostly optimize away for integers
13:59:36 <skew> Hetrish: are you still around?
14:02:48 <skew> dictlist.sort(lambda d1 d2:d1[sortfield] < d2[sortfield])
14:17:19 <Hetrish> back
14:17:26 <Hetrish> hi again skew
14:17:39 <Hetrish> hmm realToFrac
14:17:48 <Hetrish> I've seen toFractional
14:17:58 <skew> how about realToFrac?
14:18:13 <Hetrish> skew: let me serach the specification of that one...
14:18:25 <Hetrish> skew: how is it different from toFractional?
14:18:39 <skew> it's in the Prelude
14:18:45 <Hetrish> let me check
14:18:54 <skew> and has some fancy specialization rules and rewrites and things in GHC
14:19:44 <skew> actually, it's fairly irrelevant
14:20:04 <skew> avg xs = realToFrac (sum xs) / genericLength xs
14:20:26 <skew> with only one conversion it should be plenty fast if you are taking averages of lists long enough that it matters
14:21:32 <Hetrish> hmmmmright...
14:21:51 <Hetrish> skew: realToFrac was the function I was looking for! :)
14:22:01 <Hetrish> skew: but I searched for toFractional
14:22:20 <Hetrish> skew: I do understand why it is named differently though
14:22:25 <Hetrish> skew: thanks!
14:22:30 <Hetrish> skew: that is it :)
14:22:41 <skew> sometimes you need to check a few names
14:22:54 <skew> why didn't you like fromRational . toRational?
14:22:57 <Hetrish> skew: damn I don't know the Prelude half as well as I thought I did :)
14:23:15 <skew> I found that function browsing the source of GHC.Real, actually
14:23:39 <Hetrish> skew: well if you're using doubles for instance, makes no sense to convert to Rationals and back to Doubles...
14:23:44 <skew> trying to find an efficient Int -> Float function that you could use if you were writing your own toRational
14:24:15 <skew> Hetrish: no, but if you make a conversion function none of the rest of the code needs to care how it works
14:24:37 <skew> most of the time it makes no sense to allocate integers on the heap, boxed
14:24:47 <skew> but that happens a fair bit too
14:25:12 <Hetrish> skew: hmmm I didn't get the first part...
14:25:18 <Hetrish> <skew> Hetrish: no, but if you make a conversion function none of the rest of the code needs to care how it works
14:25:42 <skew> if you have a coversion function, you can just call it in the rest of your code
14:25:49 <Hetrish> yes...
14:25:54 <skew> you don't need to keep in mind the details of the implementation
14:26:03 <Hetrish> yes...
14:26:15 <Hetrish> but I don't understand why you're saying that... 
14:26:31 <skew> well, realToFrac = fromRational . toRational :)
14:26:40 <Hetrish> oh
14:26:41 <Hetrish> it is?
14:27:03 <Hetrish> hmmm
14:27:23 <skew> well, more or less
14:27:24 <Hetrish> wait but like you said, it is optimized 
14:27:25 <Hetrish> right?
14:27:58 <Hetrish> so realToFrac = fromRational . toRational  in practice is just a general specification
14:27:58 <skew> I was confused because you didn't like fromRational . toRational, but immediately accepted realToFrac, rather than asking about its performance
14:28:11 <skew> they don't do anything you couldn't do
14:28:36 <skew> but it is specialized for coversions between floating point types
14:29:07 <Hetrish> well I didn't wonder about performence because I expected it to be a polymorphic with instances for each Real instance
14:29:38 <skew> to get that it would need to be in the typeclass
14:29:47 <skew> or in some typeclass
14:30:16 <skew> I'm staring at the core output of optimizing realToFrac at assorted Integral -> Floating types
14:30:20 <Hetrish> oh yeah, right, and it would even have to be multi parameter type class
14:31:31 <Hetrish> yes you are right...
14:31:51 <Hetrish> I shouldn't have accepted it without giving it some more thought :)
14:32:05 <skew> as usual for the libraries there is a bit of magic
14:32:17 <skew> are you actually worried about performance?
14:32:20 <Hetrish> but if it is specialized for the "usual" types it is enough for me
14:32:43 <Hetrish> skew: kind of, I'm interested in learning how to do it the "right" way
14:32:53 <skew> It's not specialized for converting Int or Integer
14:33:01 <Hetrish> argh
14:33:09 <Hetrish> hmm
14:33:20 <Hetrish> but that shouldn't be that bad right?
14:33:25 <skew> not too bad
14:33:49 <skew> It pretty much inlines to (fromIntegral num) / fromIntegral 1
14:33:56 <Hetrish> yeah
14:35:11 <Hetrish> more than anything, I wanted an elegant solution, and having to define my own conversion functions for something like this seemed suspicious
14:35:40 <skew> anyway, avg xs = realToFrac (sum xs) / genericLength xs
14:35:47 <Hetrish> yeap
14:36:04 <skew> don't bother with the hand written foldl' unless it's actually an issue
14:36:13 <skew> foldl' includes some strictness
14:36:31 <skew> but I don't remember where it is defined, or even if it is exported
14:36:38 <Hetrish> skew: but it won't work on pairs
14:36:39 <skew> sum is defined with it though, IIRC
14:36:42 <skew> pairs?
14:37:00 <Hetrish> why did you mentioned foldl? 
14:37:20 <skew> you were talking earlier about combining the summing and the length calculation
14:37:26 <Hetrish> yes 
14:37:40 <Hetrish> so that means using pairs (sum, length)
14:37:46 <skew> I think that is not often worth it
14:37:57 <skew> at least, not for performance reasonas
14:38:01 <skew> it does kill laziness
14:38:15 <Hetrish> I've been through that before and by that time it seemed worth it
14:38:23 <skew> why?
14:38:27 <Hetrish> I may have the files with my experiences around...
14:38:37 <skew> large data sets?
14:38:39 <Hetrish> you can even make simple examples with sums only
14:38:51 <Hetrish> large lists
14:39:17 <Hetrish> it doesn't handle lists that big if you don't use strictness
14:39:18 <skew> yeah, the advantage of a single traversal is that the list can be garbage collected as it is consumed
14:39:31 <skew> oh, strictness is a different issue
14:39:54 <Hetrish> as an example just try fold (+) 0 instead of sum 
14:40:06 <skew> yeah, otherwise the foldl builds up a huge thunk
14:40:10 <Hetrish> yeap
14:40:17 <skew> foldr works better there
14:40:23 <skew> er, maybe nopt
14:40:27 <Hetrish> nope
14:41:05 <Hetrish> so the usual  way to go  is use foldl'
14:41:16 <skew> I don't know where that is defined
14:41:24 <skew> usual way is to use sum and prod and such that already do it
14:41:38 <skew> I don't know for custom stuff
14:42:36 <Hetrish> somthing like:
14:42:50 <Hetrish> foldl' f e [] = e
14:42:50 <Hetrish> > > foldl' f e (x:xs) = (sfoldl' f $! (f e x)) xs
14:42:59 <Hetrish> err
14:43:04 <Hetrish> foldl' f e [] = e
14:43:07 <Hetrish> foldl' f e (x:xs) = (sfoldl' f $! (f e x)) xs
14:43:11 <Hetrish> eh
14:43:15 <Hetrish> damn copy paste 
14:43:21 <Hetrish> you get the picture
14:43:35 <skew> yeah, it's like that
14:43:42 <Hetrish> it uses a $! on the accumulator
14:43:58 <Hetrish> so first it reduces it to head normal forme
14:43:59 <Hetrish> form
14:44:08 <skew> which is all the way for numbers
14:44:24 <Hetrish> problem is, if the accumulator is something like a pair it doesn't work...
14:44:40 <Hetrish> it works fine for numbers and structures with strictness anotations
14:45:02 <Hetrish> when reducing to head normal form is actually computing what you need
14:45:18 <Hetrish> thus avoinding big thunk
14:45:19 <skew> you could explicitly write a recursive function with several accumulators
14:45:19 <Hetrish> s
14:45:32 <Hetrish> yes...
14:46:04 <skew> or you could use some sort of deep sequencing operation
14:46:07 <Hetrish> another option I think is using  $! on the appropriate places in the definition of the function you pass to foldl
14:46:36 <Hetrish> or like you said define a new foldl using deep seq 
14:46:53 <Hetrish> IMO this last one is the way to go
14:47:04 <skew> what are these pairs you are working on?
14:47:24 <Hetrish> in this example they'd be the sum and the length of the list...
14:47:29 <Hetrish> is that what you're asking?
14:47:40 <skew> oh, this is still the fold with length
14:47:57 <Hetrish> yes in this example, but I've used it for other stuff before...
14:48:07 <Hetrish> not sure why but I know I did it... :)
14:48:26 <skew> for that specific case you could write a fold with length
14:48:30 <Hetrish> In fact I used to have a deep seq definition handy
14:48:41 <skew> somebody wrote a module and typeclass
14:48:52 <Hetrish> I've seen more than one definition
14:48:57 <Hetrish> I used Hal Daume's
14:49:12 <Hetrish> later I've seen one using generic haskell which seemed cool
14:49:29 <Hetrish> but I usually stick with hals
14:50:46 <skew> I think fromIntegral is probably efficient for Int -> Float/Double and Integer -> Float/Double
14:50:52 <Hetrish> I haven't been using haskell much lately so I got to get my stuff together again
14:51:08 <Hetrish> skew: yeap I expect it to be...
14:51:35 <skew> I only expect it to be efficient for Int because I think the fromInteger . toInteger
14:51:44 <skew> will see some inlining and simplification
14:51:48 <skew> I suppose I should check that
14:52:27 <Hetrish> oh right!
14:52:46 <Hetrish> again, by that time I didn't even gave it to much thought and didn't check the definition
14:53:01 <Hetrish> I simple "assumed" it should be efficient because it seemed to make sense
14:53:04 <skew> fromInteger should be pretty efficient
14:53:10 <Hetrish> (I know I shouldn't do that)
14:54:12 <skew> don't worry until you profile, but it sounds like you once did that
14:54:58 <Hetrish> I profiled a little bit because of some memory leaks
14:55:24 <Hetrish> in fact I still have a memory leak in one of the newral networks I once defined
14:55:29 <Hetrish> (neural)
14:55:35 <Hetrish> but I never got back to that
14:57:07 <skew> yep, fromInteger (S# i#) = case (int2Double# i#) of { d# -> D# d# }
14:57:14 <skew> plus an inine pragma
14:57:31 <skew> and I bet int2Iteger (I# i) = S# i
14:57:54 <skew> yep, I even guessed the name.
14:57:56 <Hetrish> that I don't know much about
14:58:02 <Hetrish> # means unboxed right?
14:58:19 <skew> on constructors themselves it doesn't really mean anything
14:58:31 <skew> just a convention saying that this constructor holds unboxed data, I think
14:58:59 <Hetrish> yeap
14:59:04 <Hetrish> that's what I thought
14:59:33 <Hetrish> (S# i#)
14:59:35 <Hetrish> ?
14:59:53 <Hetrish> that I don't know if I understand...
15:00:04 <Hetrish> ignoring the #
15:00:19 <Hetrish> I'd think about a value constructor S 
15:00:23 <Hetrish> applyed to i
15:00:28 <skew> the S# is the constructor of Integer used for small numbers
15:00:38 <skew> there is also J#, which holds a GMP bigint
15:00:42 <Hetrish> oh
15:01:03 <skew> I'm just saying inlining should sort it out
15:01:39 <Hetrish> so if I'm using type Integer with small numebers it's just a constructor with an Int?
15:01:50 <skew> yeah
15:01:57 <skew> well, a constructor with an Int#
15:01:59 <skew> unboxed
15:02:14 <Hetrish> nice I didn't know that
15:02:45 <Hetrish> I (again :)) simply assumed it used a fixed representation for all numbers
15:02:55 <skew> yep, compilining fromIntegral :: Int -> Float and fromIntegral :: Int -> Double gave me int2Float and int2Double, respectively
15:03:05 <skew> All this magic happens only with -O
15:03:10 <skew> so don't forget that!
15:03:21 <skew> another annoyance is that GHC doesn't record compilation options
15:03:21 <Hetrish> yeap!
15:03:35 <skew> so it will say "no compilation needed" if you try to recompile with -O
15:03:43 <Hetrish> oh
15:03:54 <Hetrish> I must have heard that before yes
15:04:22 <Hetrish> by the way let me get rid of this weird nick
15:04:42 <jadrian> this is my usual nick
15:09:22 <jadrian> I just found an example where I had problems with pairs and strict folds
15:09:31 <jadrian> a classic
15:09:35 <jadrian> fibonnaci
15:10:01 <jadrian> how do you define: fib n
15:10:10 <jadrian> without using a list
15:11:22 <jadrian> fibac                     :: IntPos -> (IntPos,IntPos) -> (IntPos,IntPos)
15:11:22 <jadrian> fibac n (a,b) | n == 0    = (a,b)
15:11:22 <jadrian>               | otherwise = fibac (n-1) (b,a+b)
15:11:36 <jadrian> this is pretty bad...
15:12:10 <jadrian> and so is this:
15:12:12 <jadrian> fibac2                     :: IntPos -> IntPos -> IntPos -> IntPos
15:12:12 <jadrian> fibac2 n a b | n == 0    = a 
15:12:12 <jadrian>              | otherwise = fibac2 (n-1) b (a+b)
15:12:14 <skew> no worse than using a list
15:12:22 <jadrian> yes
15:12:30 <jadrian> what I meant was, forget the list...
15:12:59 <skew> actually, is that a problem is optimization?
15:13:05 <jadrian> the question was, how to implement an efficient fib function without lists
15:13:25 <skew> change the one line to fiabac2 n a b | n == 0 = b `seq` a
15:13:52 <jadrian> yeap
15:13:55 <skew> and that might be enough to sort it out
15:15:10 <skew> I'll see
15:22:18 <jadrian> I did something like that
15:22:18 <jadrian> I was using $! though 
15:22:18 <jadrian> I also remeber I had some problems (it was a long time ago)
15:22:20 <jadrian> my 4th definition is
15:22:22 <jadrian> sfibac2                     :: IntPos -> IntPos -> IntPos -> IntPos
15:22:24 <jadrian> sfibac2 n a b | n == 0    = a 
15:22:26 <jadrian>               | otherwise = sfibac2 (n-1) b $! (a+b)
15:22:30 <jadrian> and if I recall correctly it worked fine
15:22:36 <skew> yeah
15:22:36 <jadrian> if you're using pairs it is a mess though...
15:22:40 <jadrian> (unless you use $!! <-> dep seq)
15:22:42 <jadrian> s/dep/deep
15:23:02 <jadrian> opss got to go! see you skew and thanks for the tips ;)
15:23:03 <skew> I havent tested it yet, but I'm guessing that without some stricness the complier makes code lazy in b
15:23:07 <skew> bye
15:23:28 <jadrian> yeap I think so! bye!
23:25:17 <eXcalibur> anyone about that would be willing to lend an ear to a question?
23:27:28 <Smerdyakov> Just Ask. The prime maxim of IRC.
23:27:46 <eXcalibur> is it ok to post some small code here?
23:28:08 <Smerdyakov> Better to post it on the web and give a link
23:28:21 <Smerdyakov> Unless it's one or two (reasonably sized) lines
23:28:27 <eXcalibur> to elucidate the matter?
23:28:56 <eXcalibur> well.. i don't have access to web content so quickly
23:29:29 <eXcalibur> unless you will come with me to #dump
23:30:09 <eXcalibur> #dump is no good
23:30:10 <eXcalibur> LOL
23:30:13 <eXcalibur> #flood
23:30:45 <eXcalibur> will you look at it for me?
23:31:28 <eXcalibur> it is really simple, i fear... i am just missing something that would otherwise be obvious
23:32:04 <Lurc> Fucking functionwhores
23:32:22 <eXcalibur> hmm...
23:33:10 <eXcalibur> Smerdyakov: i take that as a no?
23:33:14 <Lurc> I like Fucking functionwhores.
23:33:43 <eXcalibur> i guess i'll just bring it hree
23:33:44 <eXcalibur> here
23:33:58 <eXcalibur> i have a data type "List"... here
23:34:09 <eXcalibur> data List a = Nil |
23:34:10 <eXcalibur>               Cons a ( List a )
23:34:10 <eXcalibur>               deriving ( Show )
23:34:23 <eXcalibur> then i have a listHead function
23:34:34 <Lurc> Why are there so few functionwhores?
23:34:34 <eXcalibur> listHead :: List a -> a
23:34:34 <eXcalibur> listHead ( Cons x xs ) = x
23:34:44 <eXcalibur> and a listTail
23:34:52 <eXcalibur> listTail :: List a -> List a
23:34:52 <eXcalibur> listTail Nil = Nil
23:34:52 <eXcalibur> listTail ( Cons x xs ) = Cons ( listHead ( xs ) ) ( listTail ( xs ) )
23:34:59 <eXcalibur> but...
23:35:05 <Smerdyakov> There should be a link to a paste site in every programming channel topic.
23:35:14 <Smerdyakov> Since people always come in not knowing about them.
23:35:18 <eXcalibur> listHead is not exhaustive... without the Nil
23:35:51 <eXcalibur> so listTail failes
23:36:38 <Smerdyakov> eXcalibur, what is the purpose of this: Cons ( listHead ( xs ) ) ( listTail ( xs ) )
23:37:05 <eXcalibur> to create the tail
23:37:16 <Smerdyakov> But that's always equal to xs.
23:37:46 <eXcalibur> yes... but Cons xs Nil is not corrent
23:37:49 <eXcalibur> correct
23:37:55 <eXcalibur> nor is Cons Nil xs
23:38:06 <Smerdyakov> Right.
23:38:10 <Smerdyakov> xs by itself is correct.
23:38:18 <eXcalibur> LMAO
23:38:24 <eXcalibur> HAHAHAA
23:38:32 <eXcalibur> i'm so freaking dumb
23:38:41 <eXcalibur> thank you
23:39:03 <eXcalibur> that was like a brain orgasm
23:39:34 <eXcalibur> i was forgetting that xs was of List a type
23:40:04 <eXcalibur> i guess the context lead me in another plain of thought
23:40:33 <eXcalibur> led*
23:40:47 <Lurc> eXcalibur: how ribaldrous
23:41:06 <eXcalibur> what is so lude?
23:42:46 <Lurc> 01:38 < eXcalibur> that was like a brain orgasm
23:42:55 <eXcalibur> well.. it was
23:43:28 <eXcalibur> anyway.. say that listTail was called with Nil... how can i handle that?
23:43:44 <eXcalibur> listHead.. not listTail.. sorry
23:43:46 <eXcalibur> it's late
23:48:41 <Smerdyakov> How can we answer that question without knowing how you mean to use these functions?
23:49:51 <eXcalibur> well... i know that it is meaningless... but let us just say that my first definition is to be used
23:50:43 <eXcalibur> in this case, because listHead is not exhaustive without matching for listHead Nil, then it will fail
23:51:10 <eXcalibur> is it just the case that there is no way?
23:52:09 <eXcalibur> i guess i could just change listHead to return List a.. the compose List a with Cons x Nil for listHead Nil
23:54:41 <eXcalibur> that would be listHead ( Cons x xs ) = Cons x Nil and listHead Nil = Nil
23:54:58 <eXcalibur> not exactly what i first said
23:57:02 <eXcalibur> nevermind
23:57:07 <eXcalibur> that wouldn't work either
23:57:26 <eXcalibur> as Cons expects a for its first argument
23:57:57 <eXcalibur> anyway
23:58:03 <eXcalibur> thanks for your input
23:58:18 <eXcalibur> Haskell is a great language... so far ;-)
