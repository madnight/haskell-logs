01:39:04 <andersca> hmm, parsec is in ghc, right?
01:44:00 * earthy nods
02:05:22 <shapr> yow!
02:05:34 <andersca> hey shapr
02:05:39 <andersca> I saw the eurohaskell t-shirt yesterday
02:05:42 <shapr> g'mornin
02:05:47 <shapr> wha?
02:05:55 <shapr> where? I want one!
02:05:57 <andersca> bring made one
02:06:00 <andersca> one ex only
02:06:51 <shapr> that's nifty
02:15:15 <shapr> andersca: is the design the tshirt plus the slogan?
02:15:34 <andersca> it's the eurohaskell logo on the front
02:15:40 <andersca> and beer ... profit on the back
02:15:42 <andersca> really neat
02:16:13 <shapr> oh, I want one! I gotta get the design from bring so I can print my own
02:16:32 <shapr> bonjour Lunar^
02:16:42 <shapr> comment ca va?
02:16:47 <Lunar^> Bonjour :)
02:16:53 <Lunar^> I just made something really important
02:17:00 <shapr> whad's that?
02:17:36 <Lunar^> I've just migrate my IRC screen to its new place
02:18:02 <Lunar^> I will be finally able to switch the PC at my parents off :)
02:18:16 * shapr grins
02:49:33 <shapr> hej Marvin--
02:49:36 <shapr> wassup?
02:49:42 <Marvin--> nothing much
06:22:17 <earthy> whee, the HC&AR is coming together nicely
06:27:12 <shapr> hey, can I make a type where addition is not commutative, and express that in the Num instance somehow?
06:27:22 <shapr> Cale: awake?
06:27:49 <shapr> hi Udo, how's life?
06:29:38 <ustenzel> I'm fine, thanks.
06:30:11 <Igloo> Implementations won't assume it's commutative I'm sure, although I don't know if the report says it is
06:30:11 * shapr tries to think of expressing non-commutative addition in Haskell
06:30:36 <Igloo> Or do you mean you want to change the type too?
06:31:09 <shapr> no, just trying to figure out how I can give different implementations of p + q and q + p
06:31:21 <ustenzel> A non-commutative addition would be kind of surprising.
06:31:41 <ustenzel> If not the compiler, programmers will be surprised.
06:31:48 <shapr> I've read about some such systems that do exist 
06:32:26 <Igloo> I'm not sure I understand the question; (Foo x) + (Foo y) = 2*x + y is a non-commutative addition definition for newtype Foo = Foo Int
06:32:57 <shapr> good point
06:33:07 <ustenzel> I'd make such a thing a monoid operation, but not an addition.
06:33:38 <shapr> hm, thanks for the advice
06:37:29 <shapr> anyway, I'm just trying to come up with an interesting response to a GenericrVsOO page on WardsWiki
06:49:11 <andersca> shapr: whya ren't you in #haskell.se?
06:49:17 <shapr> is there a tutorial on Data.Generics? and a comparison versus kosmikus' Generic Haskell?
06:49:38 <shapr> andersca: tryin to work, but I just got slightly distracted right now
06:49:50 <andersca> shapr: ah, ok
06:49:53 <andersca> I'm going to write a parser in parsec
06:49:56 <andersca> but I need a lexer first
06:50:17 <shapr> also, is my info correct here? http://c2.com/cgi-bin/wiki?GenericVsObjectOrientedProgramming
06:50:23 <shapr> you do?
06:50:47 <shapr> I've never written a separate lexer
06:50:49 <shapr> hi prozz 
06:50:51 <andersca> although I've read that there is a lexer included
06:51:03 <prozz> any1 can help, im newbie with haskell ;]
06:51:13 <prozz> ?
06:51:32 <shapr> do you want urls to tutorials?
06:52:00 <prozz> no, i read a few
06:52:22 <prozz> i need to declare recursive structure but i dont know how to do this
06:52:32 <prozz> pseudocode is something like this"
06:52:33 <prozz> :
06:52:45 <shapr> are you learning haskell for school? for work? for fun?
06:53:07 <prozz> list that contains [Char, String, X] where X is the same list type
06:53:16 <prozz> for school, but its fun sometimes ;]
06:53:31 <shapr> do you have a textbook?
06:53:49 <prozz> no
06:54:05 <shapr> that's unusual
06:54:25 <shapr> you should check out the YAHT tutorial, it's good
06:54:43 <shapr> what have you tried so far?
06:55:11 <prozz> data Mylist = [Char, String, [Mylist]] <- what's wrong?
06:55:28 <prozz> no, start to read
06:55:51 <shapr> you need a constructor
06:56:14 <prozz> data Mylist = [Char, String, Cons [Mylist]] ?
06:56:30 <shapr> no, I mean one for Mylist
06:56:42 <prozz> hmm...
06:57:32 <prozz> please type it if you know how, i know perl, c, java, but its really hard to be functional programmer
06:58:08 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
06:58:19 <shapr> read that first, see if it helps
06:58:24 <prozz> ok
06:59:21 <shapr> oh, I see one problem
06:59:29 <shapr> you need homogenous lists
06:59:44 <shapr> this works: data Mylist = MylistConstructor Char String [Mylist]
06:59:46 <prozz> are tuples a clue?
06:59:55 <shapr> not really
07:00:02 <shapr> they could be
07:00:16 <shapr> haskell wants each item in a list to be the same type
07:00:44 <shapr> this works: data Mylist = MylistConstructor [(Char String [Mylist])]
07:00:47 <shapr> that works too
07:01:04 <prozz> and that is what i want, very very thanks, uff ;]
07:01:17 <shapr> er, data Mylist = MylistConstructor [(Char, String, [Mylist])]
07:01:26 <prozz> yes
07:01:48 <shapr> so, do you know how to make a parameterized type?
07:01:49 <ustenzel> or probably data Mylist = Mylist Char String [MyList]
07:02:23 <ustenzel> prozz: you want a record containing a char, a string and a list of these records, right?
07:02:57 <prozz> i want to make something like dictionary or tabcompletion
07:02:59 <shapr> yes, but it can be confusing to newbies that a type and constructor can have the same name, but be different things
07:03:42 <ustenzel> shapr: but it's quite idiomatic, better to get used to it early ;)
07:04:11 <shapr> true, but it's important to know the difference first (imho)
07:04:34 <ustenzel> whatever, the things after the constructor seem more important atm.
07:05:07 <ustenzel> prozz: given a char you want to look up a string.  and another list of mappings?
07:06:06 <prozz> it should be something like B-trees where 'char' is key
07:06:55 <prozz> after each char given, program goes down a tree and when enter is hit it prints String
07:07:17 <ustenzel> ah, a trie (aka digital search tree).
07:07:57 <prozz> but with unknow number of branches in each node
07:08:11 <ustenzel> of course.
07:08:23 <ustenzel> the branches are keyed by a char.
07:08:31 <prozz> yes
07:09:17 <ustenzel> you have to implement the mapping from char to branch somehow, possibly as a list.  this may be slow, though.
07:09:22 <ustenzel> in this case:
07:09:51 <ustenzel> data Trie = TrieCons String [(Char,Trie)]
07:11:42 <prozz> its hard for beginners, well, ill go and read something, but the most important piece ive got ;]
07:12:48 <ustenzel> prozz: just remember, what you know as records maps to a constructor and its parameters; a union maps to a sum data type
07:13:44 <ustenzel> prozz: you may want to replace the list by something else, maybe Data.FiniteMap.
07:14:15 <prozz> is there something like hashmaps in perl?
07:14:53 <ustenzel> FiniteMap is somthing similar, implemented as balanced binary search tree.
07:15:41 <ustenzel> hashmaps are somewhat ugly in a purely functional setting (though possible).
07:15:41 <prozz> but i think our teacher wants something that is very low level
07:16:17 <ustenzel> prozz: like implement the search tree yourself?
07:18:13 <prozz> unfortunatly yes
07:18:17 <kosmikus|away> shapr: I don't think that there's a good comparison between Data.Generics and Generic Haskell anywhere
07:18:49 <ustenzel> prozz: okay, a binary search tree mapping chat to string looks like this
07:19:20 <ustenzel> prozz: data BinTree = Node BinTree Char String BinTree | Leaf
07:19:44 <ustenzel> prozz: implement this first, then implement the trie on top of that, starting with
07:20:05 <ustenzel> prozz: data Trie = TrieCons String BinTree
07:20:12 <ustenzel> good luck.
07:20:36 <prozz> thanks for help, it will be ugly night ;]
07:21:48 <ustenzel> prozz: no, a long night maybe.  the same in c would be an ugly night.
07:21:56 <prozz> ;]
07:22:29 <prozz> but its very hard to start thinkin in recursive way
07:22:47 <earthy> yes. it is one of the Great Steps in understanding programming
07:23:23 <ustenzel> i find the recursive implementation comes completely naturally once the data structure is nailed down.
07:30:54 <shapr> I'm trying to get Data.Generics working atm
07:31:42 <shapr> seems some names have changed
07:36:15 <kosmikus|away> shapr: one of the problems comparing Data.Generics with GH is that both are changing ...
07:38:11 <shapr> well, I'd like to use each of them a bit
07:38:16 <shapr> then I'd know more
07:39:15 <kosmikus|away> Data.Generics is probably more usable right now
07:39:36 <kosmikus|away> I'm trying to write a good thesis, which doesn't help the implementation along
07:39:42 <shapr> :-)
08:03:53 * Marvin-- loves Data.Generics
08:07:19 <shapr> got any working demos?
08:08:56 <Marvin--> what do you want to see?
08:09:25 <shapr> xml?
08:09:32 <shapr> anything is fine though
08:10:24 <Marvin--> bottom of the paste page
08:10:36 <Marvin--> one of the transformations in my h2fol program
08:10:43 <shapr> yow
08:11:00 <Marvin--> it uses everywhereM with a writer monad to collect declarations in let expressions and where clauses
08:11:27 <Marvin--> pretty neat :)
08:11:45 <shapr> yah, interesting
08:12:06 <Marvin--> the changeNames function is written with generics too, but it's much more complicated, and I'm not sure I'm doing it the best way
08:13:28 <shapr> how could I use that to turn Haskell values into XML?
08:13:49 <Marvin--> no idea
08:14:26 <Marvin--> doesn't that sound more like a problem best solved with type classes though?
08:15:40 <shapr> maybe
08:16:00 <shapr> I'm just trying to find a good generics demo
08:16:55 <Marvin--> but I have very limited knowledge of the generics
08:17:04 <Marvin--> I basically just use the everywhere/everything combinators
08:24:11 <desrt> wow.  people talking.
08:25:38 <Marvin--> sorry, I'll go back to drinking my coffee quietly ;)
08:26:43 <bring> shapr: so you want a eurohaskell t-shirt?
08:27:01 <Marvin--> oh god, what is this monster we've created?
08:27:03 <shapr> yes!
08:27:11 <shapr> how much?
08:27:13 * Marvin-- wants one too!
08:27:38 <bring> they're very rare
08:27:38 <shapr> desrt: hiya!
08:27:52 <shapr> oh, it's gonna cost extra?
08:27:55 <bring> there's only one in the whole world
08:27:57 <shapr> wow
08:28:08 <bring> and it's sitting in my living room
08:28:24 <shapr> do you have pix?
08:28:44 <bring> nope, and my digital camera is in Malawi, and broken
08:28:56 <bring> hmm, maybe the DV-cam?
08:29:00 <shapr> where's malawi?
08:29:07 <bring> southern africa
08:29:11 <shapr> oh
08:29:12 <shapr> wow
08:29:16 <Marvin--> what's it doing there?
08:29:29 <bring> not much, since it's broken
08:29:30 <shapr> heh
08:29:32 <Marvin--> ooh
08:29:41 <shapr> desrt: learning haskell?
08:29:51 <desrt> shapr; correct.
08:29:58 <Marvin--> yay!
08:30:00 <desrt> shapr; attempting to wrap my brain around IO with monads right now
08:30:21 <shapr> spiffy
08:30:21 <Smerdyakov> desrt, it's really not complicated enough to require wrapping.
08:30:22 <desrt> i had some fun last night writing a function to generate an infinite list of fibonacci numbers
08:30:30 <shapr> yah, that's cool
08:30:46 <desrt> shapr; do i know you from elsewhere?
08:30:50 <shapr> have you seen the nomaware tutorial for monads?
08:30:55 <shapr> desrt: maybe
08:30:59 <desrt> hm.
08:30:59 <shapr> why?
08:31:09 <desrt> you just seemed excited to see me :)
08:31:21 <Marvin--> we're always excited to see new people
08:31:24 <Marvin--> shapr in particular ;)
08:31:29 <desrt> ah.  cool.
08:31:29 * shapr grins
08:31:40 <shapr> it's true, I like most people
08:31:41 <desrt> i'm working at my university this summer
08:31:48 <shapr> cool, what are you doing?
08:31:51 <desrt> and there is this haskell obsession going on
08:32:01 <shapr> oh, I have one of those too
08:32:02 <desrt> hm.  i'm not sure.
08:32:05 <desrt> :)
08:32:13 <desrt> there's a bit of confusion as to what my project ought to be
08:32:22 <desrt> they hired me without a project, just to get me into the department and doing things
08:32:26 <shapr> is your uni in europe?
08:32:29 <desrt> but we're building a supercomputer
08:32:30 <desrt> canada
08:32:41 <desrt> and we're going to teach the supercomputer how to do haskell
08:32:51 <shapr> you need phil trinder
08:32:58 <shapr> or Hal daume
08:33:00 <Marvin--> so first you have to teach yourself how to do haskell? :)
08:33:04 <desrt> right now i'm doing some of the lower level stuff for IO between the nodes of the computer
08:33:10 <desrt> but i want to be able to program the thing :P
08:33:15 <desrt> therefore => learn haskell
08:33:21 <shapr> trinder does Gph, GdH, and GUM. Hal does hMPI
08:33:48 <shapr> also, you may want to check out manuel chakravarty's parr lib
08:33:54 <desrt> AND: i might also be working on a project to help people visualise procedural programming languages better.  it's been recommended that i use haskell to this (as a learning experience)
08:34:00 <shapr> it's about flattening array ops into paralell ops
08:34:11 <desrt> AND: i have a course next year that uses haskell so my prof for that course is getting me started early
08:34:15 <shapr> oh, look at Vital for that
08:34:41 <desrt> vital for visualisation?
08:34:44 <shapr> yup
08:34:50 <desrt> what does it do for you?
08:35:03 <Marvin--> not coffee, unfortunately
08:35:21 <shapr> http://www.cs.kent.ac.uk/projects/vital/overview/
08:35:41 <desrt> no....
08:35:46 <desrt> procedural languages
08:35:48 <desrt> like C, java...
08:35:54 <shapr> yes, I heard you
08:36:08 <shapr> well, read you
08:36:16 <shapr> you know what I mean
08:37:25 <shapr> basically, you might be able to hack vital to show a simple procedural interpreter writen in Haskell
08:37:36 <shapr> that might be a shortcut
08:37:56 <desrt> well... it's sort of bad
08:38:02 <desrt> but i am trying to become uninvolved in that project
08:38:06 <desrt> but i think i might be commited
08:38:14 <desrt> i have to talk to my supervisor on monday (i think)
08:38:48 <shapr> you may also want to check out wouter van oortmerssen's pages
08:38:59 <shapr> he does some related stuff
08:39:04 <desrt> you have lots of names :)
08:39:27 <shapr> er, only two, and one of those has fallen into disuse
08:39:48 <Marvin--> I don't think he's referring to *your* name shapr ;)
08:40:04 * shapr :: Smartass
08:40:12 <desrt> has type.
08:40:16 <shapr> :-)
08:40:33 <desrt> ugh
08:40:33 <Marvin--> I thought Smartass was my job around here :(
08:40:39 <desrt> so i just got out of bed
08:40:50 <desrt> and by "got out of bed" i really mean dragged my laptop over to my bed without leaving it
08:40:52 <shapr> yes, but I've been practicing some
08:40:56 <desrt> and now the cat is harassing me to feed it
08:41:03 <shapr> wow, life is tough
08:41:10 <desrt> ya.  it sucks, man
08:41:11 <desrt> let me tell you
08:41:27 <desrt> sleeping into 11:30 isn't something that comes easy.  you have to try at it.
08:41:29 * Marvin-- wishes he didn't have all these damn allergies, so he could have a cat
08:41:50 <shapr> oh, I'll bring you some cat hair
08:41:59 * desrt gets up.  brb.
08:41:59 <Marvin--> that's the part I'm allergic to
08:42:06 <shapr> excellent
08:42:25 <shapr> anyway, I should be working
08:43:26 * shapr cranks up chemical brothers
08:44:11 <desrt> hm.
08:44:24 * desrt has a bunch of cds to listen to
08:44:29 <shapr> desrt: dude, the first lambda is free
08:44:39 * shapr tokes on a lambda
08:44:45 <Marvin--> speaking of lambdas
08:44:46 <shapr> dang, this one is partially applied
08:44:49 <desrt> ya.  what's with this haskell lambda business?
08:45:00 <shapr> well, it's like this...
08:45:11 <shapr> wait, do you want a serious answer?
08:45:18 <desrt> whatever :)
08:45:21 <shapr> or more random humor?
08:45:38 <desrt> random humour is fine, actually
08:45:45 <Marvin--> I read about the Knights of the Lambda Calculus the other day
08:46:04 <shapr> anyway, these lambdas kick ass
08:46:20 <shapr> hey desrt, you code in other languages?
08:46:21 <Lor> There are no knights of the lambda calculus.
08:46:29 <Marvin--> Lor: that's what I gathered
08:46:33 <desrt> shapr; many
08:46:48 <shapr> you do any lisp,scheme,ocaml ?
08:46:52 <desrt> no =)
08:47:00 <desrt> very little lisp long time ago
08:47:06 <Marvin--> TINC
08:47:06 <shapr> prolog, mercury?
08:47:08 <desrt> but only normal languages so far
08:47:19 <shapr> dude, Haskell is totally normal
08:47:20 <desrt> c, c++, java, c#, perl, php, shell, basic even...
08:47:25 <desrt> haskell is totally whacked :)
08:47:37 <shapr> nah, it's that othere stuff that's weird
08:47:46 <desrt> you know
08:47:47 <Marvin--> "Illuminati of the Grand Recursive Order of the Knights of the Lambda Calculus"
08:47:56 <shapr> they even have recursion limits!
08:47:58 <desrt> i almost get the impression that if i toke a lambda i might be able to understand haskell a bit better :)
08:48:45 <desrt> Marvin--; templars?
08:48:56 <shapr> actually, the only drugs I do is methylphenidate HCl
08:49:28 <desrt> i took a couple tylenol the other day
08:49:29 <desrt> but it was called for
08:49:37 <desrt> i was doing sound for "hamilton idol"
08:49:38 <shapr> is that hydrochlorate or hydrochloride?
08:49:51 <desrt> which is a bunch of highschool students (most of whom can't sing) thinking that they're on american idol
08:50:03 <desrt> shapr; chloride
08:50:12 <desrt> chlorate would need to have oxygen
08:50:18 <shapr> ah, thanks
08:50:54 <shapr> anyway, there was this guy named Alonzo Church
08:51:00 <desrt> oh here we go
08:51:17 <shapr> and he had this cool idea for something called lambda calculus
08:51:27 <shapr> stop me if you've heard this one already
08:51:36 <desrt> i thought it was going to be a joke, actually
08:51:51 <shapr> I'mstill not sure yet if it will be or not
08:52:19 <shapr> the lambdas are not what they seem, monad walk with me, etc
08:52:23 <desrt> for someone obsessed with functional programming your behaviour is quite undeterministic
08:53:16 <shapr> yah well, gotta do something with all these unused side-effects
08:53:39 * desrt googles methylphenidate for sideffects
08:53:50 <Lor> Nondeterminism is ok if you're confluent.
08:53:52 <shapr> anyway, have you tried Hal Daume's YAHT tutorial?
08:54:02 <desrt> maybe
08:54:10 <desrt> is that the first one on the page on the topic?
08:54:18 <shapr> Lor: I never could speak the language at DragonCon
08:54:19 <desrt> oh.  i downloaded it but forgot to read it
08:54:24 * desrt remembers now
08:54:30 <shapr> it's spiffy
08:54:34 <shapr> worth reading
08:54:38 <desrt> right now i need to learn: types
08:54:48 <shapr> what about 'em?
08:54:59 <Marvin--> what do you mean learn about types?
08:55:05 <desrt> all this wanker :: IO -> whack (q, w, e, r, t, y) <== blar :: huh business is confusing me
08:55:27 <Marvin--> have you seriously used all those other languages without thinking about types?
08:55:38 <desrt> oh.  i know all about types
08:55:43 <desrt> just not the haskell syntax for them
08:55:45 <eivuokko> Heh
08:55:47 <shapr> oh, monads are an abstraction like objects, you use them to hide some of the complexity
08:55:49 <Marvin--> careful with the "all" there ;)
08:55:59 <desrt> i can understand like... Int -> Int -> Int
08:56:07 <desrt> but the IO stuff gets a bit fancy for me
08:56:08 <Marvin--> I'm having a hard time with higher order existential types, myself
08:56:10 <Lor> I don't think any other practical programming language requires as much thinking about types as Haskell does.
08:56:12 <desrt> so i need to do more reading before i can grok it
08:56:22 <shapr> you know it's really Int -> (Int -> Int) ?
08:56:27 <desrt> yes. of course
08:56:35 <desrt> the first int curries it to get the int->int function
08:56:37 <shapr> ok, just checking
08:56:42 <desrt> i was proud when i figured that out :)
08:56:48 <shapr> yah, it's spiffy
08:56:58 <Marvin--> well, it's quite natural if you know some lambda calculus :)
08:57:05 <shapr> map (+1) [1,2,3] is cool
08:57:09 <Lor> Function types are often pretty-printed just Wrong.
08:57:31 <desrt> shapr; [2, 3, 4]?
08:57:35 <shapr> yup
08:57:38 <desrt> heh
08:58:04 <shapr> @eval map (\x -> x + 1) [1,2,3]
08:58:05 <lambdabot> [2, 3, 4]
08:58:21 <desrt> the \ business confuses me too
08:58:27 <desrt> just because i haven't read it yet
08:58:34 <shapr> it just means an anon function
08:58:53 <desrt> do you think:
08:59:02 <desrt> (a) haskell takes more intelligence to figure out
08:59:03 <desrt> or
08:59:13 <desrt> (b) my mind is just polluted by procedural programming
08:59:16 <shapr> b
08:59:24 <desrt> i knew you'd say that.  i still think a :)
09:00:01 <shapr> it's just a slightly different way of looking at the world
09:00:05 <desrt> (a) i didn't need lambda calc for C
09:00:14 <desrt> (b) this new CD is really good.  but again, i suspected it would be
09:00:20 <shapr> which CD?
09:00:28 <desrt> melissa mcclelland - stranded in suburbia
09:00:31 <shapr> magnatune has lotsa good stuff
09:00:44 <shapr> magnatune.com that is
09:00:55 <shapr> oh, I bet I found my bug
09:00:59 * shapr hops
09:01:28 <shapr> wrong search params to the catalog I bet
09:01:29 <desrt> heh
09:01:50 <desrt> i like their manifesto
09:01:56 <shapr> yes, they are cool
09:02:16 <shapr> lambdabot is written in haskell
09:02:23 <shapr> and has a plugin system
09:02:24 <desrt> lambdabot; botsnack
09:02:35 <shapr> makes for a nifty code toy
09:02:48 <desrt> boring bot :P
09:02:49 <shapr> lambdabot: bark!
09:02:49 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
09:03:01 <desrt> lambdabot; perhaps later.
09:03:37 <shapr> @type Data.Generics.dataTypeOf
09:03:40 <lambdabot> Data.Generics.dataTypeOf :: forall a.
09:03:40 <lambdabot> 			    (Data.Generics.Basics.Data a) =>
09:03:40 <lambdabot> 			    a -> Data.Generics.Basics.DataType
09:03:51 <shapr> @info Data.Generics.Data
09:03:53 <desrt> my irc client doesn't like tabs
09:03:53 <lambdabot> -- Data.Generics.Basics.Data is a class
09:03:53 <lambdabot> class (Data.Typeable.Typeable a) => Data.Generics.Basics.Data a where {
09:03:53 <lambdabot>     Data.Generics.Basics.gfoldl ::
09:03:53 <lambdabot> 	forall c :: (* -> *).
09:03:53 <lambdabot> 	(forall a b. (Data.Generics.Basics.Data a) =>
09:03:54 <lambdabot> 	 c (a -> b) -> a -> c b)
09:03:56 <lambdabot> 	-> (forall g. g -> c g) -> a -> c a
09:03:58 <lambdabot> 	{- has default method -};
09:03:59 <shapr> aiee
09:04:00 <lambdabot>     Data.Generics.Basics.toConstr :: a -> Data.Generics.Basics.Constr;
09:04:02 <lambdabot> [36 @more lines]
09:04:14 <Marvin--> shapr: dummy :P
09:04:24 <shapr> I wasn't tinking
09:04:31 <shapr> or thinking either
09:04:48 <shapr> yah, I need to clean those tabs out
09:05:08 <desrt> i need to clean my room out
09:05:20 <desrt> it's been one hell of a week (even yesterday i was at school)
09:05:25 <desrt> but i have no excuse to not do it today
09:05:50 <shapr> best monad tutorial --> http://www.lifl.fr/~boulet/formation/CALP/man/monads/html/
09:06:06 <shapr> I want to go to school
09:06:17 <desrt> i get that feeling sometimes
09:06:21 <shapr> maybe one day when I'm older
09:06:27 <desrt> how old?
09:06:35 <shapr> 34 probably
09:06:41 <desrt> explains a bit.
09:06:50 <shapr> I'm 2^5 right now
09:07:12 <desrt> that's quite old
09:07:20 <shapr> it is?
09:07:45 <shapr> how old are you?
09:07:55 <desrt> i'd tell you how old i am but i can't find my calculator and i'm no good at directly evaluating base-2 logs
09:08:07 <shapr> anyway, I love my unicycle
09:08:29 <shapr> no one thinks I'm old when they see me riding my uni
09:08:34 <desrt> 2^4.3
09:08:51 <shapr> mostly cuz they're too busy diving out of the way
09:09:04 * desrt appears annoyed
09:09:13 <desrt> i broke 2 frickin guitar picks yesterday
09:09:38 <shapr> you just plect um too hard
09:09:59 * Marvin-- sighs as he gets mails from "himself"
09:09:59 <desrt> it was the style of the music
09:10:09 * shapr gives up on plectrum jokes
09:11:19 <shapr> anyway, you should read that monad tutorial, it's good
09:11:39 <desrt> i will
09:11:46 <desrt> i'm not learning until later, though
09:12:12 <shapr> I gotta do some work and then ride my muni
09:16:59 <shapr> yes, bug fixed!
09:17:02 * shapr boings
09:18:29 <bring> shapr: crappy dv picture quality, but you get the general idea: http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg
09:19:27 <Lunar^> bring: neat !
09:20:09 <desrt> hah
09:20:16 <shapr> wow, nifty!
09:20:23 <desrt> i know this notation from my logic course :)
09:20:31 <shapr> is that also you wearing the tshirt?
09:20:47 <bring> nope, that's my inflatable love doll
09:20:57 <shapr> that's an awesome tshirt, I want one!
09:21:18 <bring> before anyone gets any strange ideas, yes, it's me
09:21:24 * shapr grins
09:21:28 <Lunar^> bring: so do I :)
09:22:20 <desrt> i think i'm going to write a function to do a FFT
09:22:21 <Marvin--> I want one too!
09:22:24 <Marvin--> t-shirt that is
09:23:25 <bring> I've got the design cut out in plastic (overhead transparancy) and I've got more of the white paint (ink? color? dye? whatever)
09:23:41 <desrt> holy crap 200 page tutorial?!
09:23:47 <shapr> for what?
09:23:53 <desrt> yaht
09:23:53 <bring> if you bring some t-shirts, you can make your own
09:24:06 <shapr> spiffy
09:24:16 <bring> I could make some and sell them, but this is an open source t-shirt
09:24:21 <shapr> desrt: you could read mine: http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:24:28 <shapr> it's slightly shorter
09:24:32 <desrt> short is nice
09:24:45 <shapr> doesn't mention monads though
09:24:56 <bring> hmm, it being open source doesn't stop me or anyone else from selling them though
09:24:57 <desrt> does it cover types well?
09:25:04 <shapr> no, not really
09:25:05 <desrt> oh wiki.  *changes*
09:25:31 <shapr> the Haskell wiki is elsewhere
09:25:34 <desrt> oh.  interesting
09:25:46 <shapr> http://www.haskell.org/hawiki/RecentChanges
09:25:48 <desrt> so (\x -> x * x)
09:25:54 <desrt> i now have a square operatoer
09:26:00 <shapr> yup
09:26:04 <desrt> and can use that with foldr and stuff
09:26:16 <shapr> yup
09:26:17 <desrt> ok.  i get.
09:26:39 <desrt> i find the syntax a bit unclean in places...
09:26:44 <shapr> where?
09:26:47 <desrt> like ->
09:26:55 <desrt> used in anonymous functions and function types
09:27:01 <desrt> similar but not really the same thing
09:27:18 <shapr> that's part of the point, I think
09:27:29 <Marvin--> it's used for case expressions too
09:27:34 <shapr> because it's eval, not exec
09:27:46 <Marvin--> in the same form as for lambda functions
09:27:49 <shapr> if is a function
09:27:53 <Marvin--> you have pattern -> expression
09:28:09 <desrt> deriving Show
09:28:17 <desrt> i see no show.
09:28:23 <shapr> it's a typeclass
09:28:52 <desrt> data Tree a = Nil | Node (Tree a) a (Tree a) deriving Show
09:28:55 <shapr> you know Java interfaces?
09:29:00 <desrt> can either be nil
09:29:06 <desrt> or has a left/value/right datatype
09:29:07 <desrt> ya
09:29:31 <desrt> a list of functions that a subclass must impliment if it wants to declare itself as inmplimenting an interface
09:29:33 <shapr> the Show typeclass defines an interface for turning a value into a string
09:29:39 <desrt> gotcha.
09:29:50 <desrt> so like c#'s ToString()
09:30:01 <Lunar^> bring: I'll bring a black t-shirt
09:30:13 <shapr> Eq is equality, Ord is ordered, Num is numeric, etc
09:30:14 <desrt> (which is a base property of the Object class that everything is derived from)
09:30:14 <Lunar^> bring: DYI T-shirt are always cool
09:30:19 <Lunar^> bring: read DIY
09:30:20 <desrt> i read about Eq
09:30:37 <desrt> any class that supports the == operator impliments Eq
09:30:57 <shapr> what's more interesting about typeclasses is that they are defined and instantiated separately from the type
09:31:18 <shapr> so they don't need to be part of the object
09:31:24 <bring> yeah, black t-shirt is a good idea, I only have white paint
09:31:58 <desrt> oh.  interesting
09:31:59 <shapr> you get to make instances of whatever for the standard types if you want
09:32:01 <desrt> data Tree a
09:32:05 <desrt> where a is Int, Char, whatever...
09:32:15 <desrt> and then it fills in the a on the other side of the ::
09:32:23 <shapr> yup
09:33:08 <desrt> is the node word required?
09:33:10 <desrt> or could you just say
09:33:16 <desrt> Nil | (Tree a) a (Tree a)
09:33:29 <shapr> yes, because it's the constructor
09:33:37 <desrt> i noticed that later on, which is why i asked
09:33:50 <shapr> alternatively, load this file into GHCi and try it
09:34:02 <desrt> ghci is like hugs for ghc?
09:34:56 <desrt> mylength (x:xs) = 1 + mylength xs
09:34:59 <desrt> sameas:
09:35:07 <desrt> mylength(xs) = 1 + mylength (tail xs)
09:35:09 <desrt> right?
09:35:38 <Marvin--> desrt: not quite
09:35:38 <desrt> or i suppose i should say 'mylength xs = ...'
09:36:11 <desrt> Marvin; because the first one will only match a list with at least one element?
09:36:18 <Marvin--> desrt: exactly
09:36:29 <desrt> but i should have mentioned
09:36:30 <desrt> mylength []     = 0
09:36:31 <Marvin--> desrt: you'll need a base case in any case (mylength [] = 0)
09:36:33 <desrt> declared above it
09:36:49 <Marvin--> as long as it's declared above, they're equivalent
09:36:54 <desrt> awesome
09:40:35 <shapr> so, now you know haskell
09:40:41 <desrt> not really
09:40:53 <shapr> ok, there are a few more details, I admit
09:41:39 * desrt hits shapr with a monad
09:41:46 * desrt notes that he has no idea what he has just done
09:42:05 <shapr> so, you into bindage?
09:42:16 <desrt> ...
09:42:16 * shapr makes obscure monad jokes
09:42:20 <desrt> here's what i don't get
09:42:25 <desrt> getChar                 ::   IO Char
09:42:30 <shapr> right
09:42:32 <desrt> how can it just return IO?
09:42:38 <desrt> doesn't it need to take IO as an input too?
09:42:42 <shapr> no
09:42:50 <desrt> this makes absolutely no sense to me
09:43:07 <shapr> well, you're right, sort of
09:43:10 <Marvin--> it doesn't return IO
09:43:22 <shapr> read the monad tutorial
09:43:31 <Marvin--> getChar is an "IO action" that - when run - results in a Char
09:43:35 <desrt> i'm reading 'A gentle introduction to Haskell IO'
09:45:27 <shapr> it might make your life easier if you understand monads first
09:45:33 <shapr> but maybe not, I dunno
09:45:35 <desrt> well
09:45:49 <desrt> i read this one thing that didn't make sense to me becuase i didn't understand types and anonymous functions
09:45:53 <desrt> perhaps i should reread it now that i do
09:46:13 <shapr> like the rest of haskell, monads are simple, but you have to 'get it'
09:46:41 <shapr> like OOP, it doesn't make any sense at first glance
09:48:30 <shapr> bring: can I link this on the EuroHaskell wiki sidan?
09:48:33 <shapr> er, page
09:48:48 <shapr> my brain is leaking swedish
09:49:07 <bring> the t-shirt?
09:49:20 <shapr> yah, the pic
09:49:32 <bring> sure, if you want
09:49:54 <bring> hopefully not as an inline pic 
09:49:57 <shapr> with instructions to optionally bring a black tshirt
09:49:58 <shapr> ok
09:50:10 <bring> don't want a picture of me scaring people away
09:50:14 <shapr> haha
09:50:29 <shapr> you have a much better haircut than I do
09:50:52 <bring> I need to take a better picture, maybe viblo can take one some day
09:51:35 <forester> optionally _bring_
09:51:37 * forester laughs
09:51:41 <bring> man, there is a lot of people signed up
09:52:01 <bring> oh, yeah, and bring bring a beer
09:52:14 <shapr> :-)
09:52:28 * bring is starting to realize that his choice of irc nick is suboptimal
09:52:39 <shapr> 21 ppl signed up
09:52:52 <shapr> if Heffalump shows
09:52:53 <bring> the word comes up every know and then, which makes xchat beep
09:53:07 <shapr> yup
09:53:15 <shapr> you could be bringert
09:53:22 <shapr> that's much less common
09:53:42 <bring> I'll get my laundry, then change it
09:53:48 * bring likes to make plans
09:53:52 <shapr> or pick a fanciful name if you like
09:54:02 <forester> bjorne perhaps
09:54:38 <shapr> or LambdaCowkulus
09:54:42 <bring> :)
09:54:43 <forester> hah
09:54:44 <forester> a
09:54:44 * shapr is joking
09:54:59 <bring> LambdaStarter
09:55:06 <bring> twisted LambdaStarter
09:55:20 <bring> who came up with that?
09:55:31 <shapr> with what?
09:55:56 <bring> "I'm the lambda starter, twisted lambda starter", I think someone said that last night
09:56:27 <forester> on irc?
09:56:32 <bring> dunno
09:56:41 <bring> forester: maybe at your place
09:56:42 <shapr> DNA kit?
09:56:49 <forester> might have been conny
09:56:51 * forester is still andersca
09:57:14 <bring> forester: have you checked forester for ticks yet?
09:57:26 <forester> he checked himself
09:57:31 * shapr is afraid to ask
09:57:32 <desrt> gnome andersca?
09:57:33 <bring> that'd be a sight for sore eyes
09:57:37 <forester> found fourteen or fifteen
09:57:39 <forester> desrt: none other
09:57:45 <desrt> fascinating.
09:57:49 <bring> after coming home?
09:58:02 <forester> three after coming home
09:58:02 <bring> I didn't find any
09:58:06 <shapr> andersca: you're famous!
09:59:33 <forester> shapr: apparently, yeah :)
09:59:59 * bring is trying not to have a beer
10:00:09 * shapr is trying to work
10:00:25 <desrt> i seriously fear monads
10:00:25 <forester> bring: just let conny store your beer for you
10:00:36 <shapr> I'd rather be writing Haskell!
10:00:43 <Leimy> there's a good bumper sticker
10:00:44 <Leimy> :)
10:00:45 <bring> forester: eh, somehow I don't think that'd be safe
10:00:48 <shapr> desrt: they're not scary, really
10:01:10 <shapr> desrt: just a way to do abstraction, like OOP
10:01:20 <forester> continuation monads scare me
10:01:26 <shapr> you use them to hide some of the complexity
10:01:26 <bring> seeing how everytime I see you guys, I lose a whole crate of beer
10:01:27 <forester> although in a good way
10:01:32 <Leimy> they encapsulate "stateful pollution" :)
10:01:34 <Smerdyakov> Monads are very simple.
10:01:58 <shapr> nearly everything is simple once you understand it :-)
10:02:09 <shapr> except for Zope
10:02:12 <desrt> so..
10:02:13 <Leimy> which explains why women are complex
10:02:15 * shapr stabs zope
10:02:17 <desrt> if i say IO Int
10:02:28 <desrt> that's really sort of similar to IoState -> (IoState, Int)
10:02:35 <bring> Leimy: because they're writting in python?
10:02:40 <Leimy> heh
10:02:40 <bring> written
10:02:41 <desrt> where IoState is the sort of .. state of the IO monad (or something?)
10:02:41 <forester> bring: we could go to denmark before EH and get lots of beer
10:02:43 <shapr> first class action
10:02:51 <bring> forester: that's a good idea
10:02:54 * desrt needs another tutorial :P
10:03:08 <bring> in fact, we should just book the car for all of EuroHaskell
10:03:10 <Marvin--> desrt: yes, sort of
10:03:15 <shapr> the car?
10:03:25 <Marvin--> desrt: RealWorld -> (RealWorld, Int)
10:03:27 <shapr> whoa, I haven't driven in years
10:03:31 * Leimy is still trying to write a string -> justified string function :)
10:03:44 <desrt> Marvin; you take the old realworld and convert it to the new realworld
10:03:44 <Leimy> one of the exercises in Haskell The Craft
10:03:53 <forester> bring: yeah, it's not that expensive is it
10:03:54 <desrt> and return a value in the process
10:03:57 <Marvin--> exactly
10:03:59 <bring> the CS&CE section of the student's union has a minivan
10:04:04 <desrt> but really your function might actually look like
10:04:06 <Marvin--> but the IO monad does that for you and hides the dirty details
10:04:09 <bring> forester: SEK 50 / day
10:04:16 <desrt> some -> other -> args -> (Realworld -> (Realworld, Int))
10:04:18 <bring> + SEK 2,50 / km
10:04:26 <desrt> it's just the curried form that has the rw -> (rw,int) type
10:05:04 <bring> it has "Hacke kör fortare" (=Woody drives faster) written on the side
10:05:11 <shapr> no trips to St. Petersburg
10:05:28 <bring> Woody Woodpecker (= Hacke Hackspett in swedish) is our mascot
10:05:33 <shapr> we're going to add an E right?
10:05:38 <shapr> um, R
10:05:39 <shapr> shhez
10:06:10 <forester> bring: gonna need sponsors soon ;)
10:06:17 <shapr> oh, that's a nice mascot
10:06:47 <desrt> oo.  i like this new tutorial.  it doesn't try to explain all the theory.  it just shows me how to use it :P
10:06:49 <forester> we have mega man
10:07:05 <shapr> he's a sponsor?
10:07:32 * shapr continues being a smartass
10:07:36 <Marvin--> we do?
10:07:37 <bring> forester: if we add a few SEK to each can of beer, we should be able to pay for renting the car
10:07:54 <forester> Marvin--: that's the plan
10:08:05 <forester> bring: yeah
10:08:09 <bring> we also have Christer Carlsson
10:08:28 <bring> the CS department is sponsoring us with rooms and net access
10:08:56 <bring> and computer accounts
10:08:59 <forester> I heard bring was going to do the keynote
10:09:00 <forester> @arr
10:09:00 <lambdabot> Smartly me lass
10:09:05 <bring> bah
10:09:12 * Marvin-- makes a mental note to figure out where he put his wlan card
10:09:16 <bring> @eurohaskell
10:09:16 <lambdabot> less talks, more code!
10:09:16 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
10:09:16 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
10:09:24 <bring> see, "less talks"
10:09:27 <Maddas> cool
10:09:46 <desrt> hmm.
10:10:04 <bring> we will get NOMAD accounts for everyone, which works with the ethernet jacks and the wlan
10:10:22 <bring> however, the wlan reception is very poor on th 6th floor
10:10:33 <Marvin--> yeah I've noticed :(
10:10:34 <forester> can't you bring your ap and use it as a bridge or something?
10:10:50 <bring> not sure what medic would think about that
10:11:04 <bring> we could ask them nicely to install an ap up there
10:11:11 <bring> there really ought to be one
10:11:22 <shapr> if John Hughes wants to talk (especially about arrows), I want to listen
10:11:43 <shapr> hey Marvin--, did you talk to Koen?
10:12:05 <bring> John said he would really like to come, but that he would probably not be able to
10:12:10 <shapr> aww
10:12:16 <shapr> tyvärr
10:12:22 <Marvin--> shapr: yeah, he's going to be travelling a bit during June but he doesn't know when
10:12:26 <shapr> ok
10:12:39 <shapr> that's a good solid maybe
10:12:45 <Marvin--> shapr: but he said he'd drop by if he's able to
10:12:49 <shapr> spiffy
10:14:01 <bring> we can try to convinve John to come and try out the Arrows talk that he's going to give at the FP summer school in Tartu
10:14:13 <bring> convince
10:14:20 <Marvin--> that'd be awesome
10:14:37 <desrt> ï¿½
10:14:40 <shapr> yes!
10:14:43 <shapr> yes yes!
10:14:45 <desrt> evil non-utf8 users
10:15:20 <shapr> desrt: Ã¤r det bÃ¤ttre?
10:15:38 <desrt> shapr; maybe
10:15:45 <Marvin--> shapr: be nice :P
10:15:48 <shapr> hey, did I already ask you which uni?
10:15:53 <desrt> no
10:15:59 <shapr> ok, which uni?
10:16:08 <desrt> mcmaster
10:16:55 <shapr> .ca ?
10:17:55 <shapr> I was born a poor white chile in Alabama
10:18:42 <Marvin--> couldn't even afford a "d"
10:19:00 * shapr laughs
10:19:11 <shapr> is sjÃ¶gren a common last name?
10:19:22 <shapr> I saw a David SjÃ¶gren recently
10:19:24 <Marvin--> yeah
10:19:26 <Marvin--> pretty common
10:19:34 <shapr> ok
10:20:11 <Marvin--> there's a whole slew of common names formed by taking two random words from mother nature and putting them together
10:24:20 <Marvin--> man I want to see this Scrubs episode again, it's so damn good
10:25:08 <andersca> which one is it?
10:25:59 <Marvin--> the one with the funeral
10:26:30 <Marvin--> incredibly well made episode
10:26:34 <desrt> shapr; yes.  .ca
10:29:30 <shapr> hi jmob 
10:29:38 <jmob> hola
10:30:14 <shapr> welcome to the collective
10:30:27 * shapr orders lambdabot to assimilate jmob 
10:30:42 <Leimy> a corrective collective?
10:31:15 <Marvin--> shapr: how many times do I have to tell you, *first* assimilate, *then* welcome
10:31:20 <shapr> oh, right!
10:31:48 <jmob> Smells like a cult to me.
10:31:59 <Marvin--> see what you've done now, shapr
10:32:05 <shapr> whoops
10:32:31 <shapr> dang, next time I'll use a monad to get the sequencing right
10:32:58 <shapr> jmob: any questions?
10:33:24 <Marvin--> "#haskell - bringing bad programming humor to a high level"
10:33:31 * shapr grins
10:33:49 <jmob> shapr, what's a monad?
10:33:54 <bring> hehe
10:34:10 <bluejay> jmob: http://www.lifl.fr/~boulet/formation/CALP/man/monads/html/index.html
10:34:18 <shapr> yah
10:34:24 <shapr> hi bluejay 
10:34:29 <bluejay> shapr: hi
10:34:33 <shapr> wassup?
10:35:05 <bluejay> The interpreter got finished. :) After 2 days of solid programming with about 3.5 hr of sleep.
10:35:11 <shapr> jmob: monads allow side-effects and referential transparency to live together happily
10:35:17 <shapr> yay!
10:35:32 <shapr> can we see it?
10:35:36 <bluejay> Cyclic data structures are cool, until they "Fail: <<loop>>".
10:35:50 <shapr> does it use monad transformers after all?
10:36:03 * Marvin-- ponders getting some dinner
10:36:16 <bring> mmm, food
10:36:24 <bluejay> arch://jyasskin@mail.utexas.edu--2003/tiger--main--0 (archive at http://bluejay.dyndns.org/archives/2003/)
10:37:52 <bluejay> shapr: yeah, ReaderT(WriterT(ErrorT(ContT(ST)))) (It's not very polished, as it was a semester project)
10:41:06 * shapr tries to remember how to get stuff with arch
10:41:17 <shapr> do you have a tarball? :-)
10:42:20 <shapr> jmob: did that answer actually help?
10:42:22 <bluejay> shapr: http://wiki.gnuarch.org/moin.cgi/Quick_20Introduction#head-b8402b7d51ec42b9fd607a2ff6fe1a2775016618 (no tarball yet. I can make one if you can't figure out arch)
10:42:50 <Riastradh> Most Darcs users have probably tried to figure out arch and decided that it's not worth it.
10:44:15 <jmob> shapr, your answer helps me understand what they accomplish.
10:44:22 <shapr> I've actually used arch several times
10:44:55 <Riastradh> jmob, monads are generalizations of computation.
10:45:13 <shapr> I think it's too much trouble to use, compared to darcs.
10:45:29 <Riastradh> A monad is just a computation with a set of certain generalized operations on it.
10:45:32 <Lor> "generalization of computation" really doesn't tell anything.
10:45:32 <shapr> but, rather than get into a holy was about source control systems...
10:45:42 <Lor> I think a good description ought to have something about sequencing in it.
10:45:44 <bluejay> shapr: http://bluejay.dyndns.org/~jyasskin/tmp/tiger.tar.bz2
10:45:52 <shapr> bluejay: thanks!
10:46:00 <Riastradh> Lor, except it's not _about_ sequencing.
10:46:14 <Riastradh> Really, generalization of computation is the most specific name that can be applied to all monads.
10:46:28 <shapr> what about arrows?
10:46:37 <Riastradh> Arrows are generalizations of functions.
10:46:46 <shapr> I'd say monads are about hiding the plumbing
10:47:04 <Lor> And arrows are about hiding what goes inside the plumbs?
10:47:16 <shapr> hm, maybe so
10:47:19 <shapr> hi anyone 
10:47:30 <Riastradh> It's not about hiding anything; that is a result of the abstraction bundled with monadic computation.
10:47:32 <jmob> Do arrows relate to curries in scheme?
10:47:48 <Riastradh> 'Curries?'
10:48:08 <anyone> arrows help you do plumbing, and so do monads.
10:48:17 <jmob> curried functions
10:48:29 <anyone> But of course there are other applications than plumbing.
10:48:30 <Riastradh> anyone, they can (and are often used to) _assist_ in doing so.
10:48:46 <Lor> We don't need monads for anything, really. ArrowApply works just as well.
10:48:48 <Riastradh> But that's not the point of monads.  Monads are merely generalizations of computation.
10:49:09 <anyone> Thank you Riastradh for repeating after me.
10:49:26 <Riastradh> anyone, I started writing my response before I saw yours.
10:49:49 <anyone> I mean the _assist_ part.
10:50:02 <bluejay> lol, of course the haskell people have their own RCS. ;)
10:50:06 <Riastradh> I meant to have underlined 'can.'
10:50:14 <bluejay> (not a bad thing, of course)
10:51:47 <shapr> boy, I hope we break 90 on #haskell today
10:52:06 <shapr> or maybe tomorrow
10:52:16 <maayhem> whats the high score 
10:52:18 <Riastradh> There are too many idlers here.
10:52:27 <shapr> 88 I think
10:52:46 <shapr> hi maayhem, wassup?
10:54:30 <shapr> Riastradh: at least there's regular discussion
10:55:36 <ne1> I am indeed disappointed that most people equate monads with state-threading.
10:55:50 <shapr> Maybe
10:56:09 <shapr> List monad is also nifty
10:57:28 <ne1> But in reality, most CS students encounter set comprehension { x+y | x in N, y in Q } very early on via discrete math courses, and that ought to be the first monad they encounter.
10:59:07 <Cale> Or in any math course they take
11:01:02 <shapr> maayhem: haskell is lazy, ocaml is trict
11:01:15 <shapr> haskell has typeclasses
11:01:18 <maayhem> in term of evaluation you mean ?
11:01:24 <shapr> yup
11:01:36 <shapr> it can make a big difference
11:01:45 <SamB> hmm, where is a good example of how to make your own monad? I'm thinking something in the heirarchical library, but a webpage would be fine too ;-)
11:01:45 <Marvin--> hmm, the DMCRA looks interesting
11:01:47 <maayhem> k, so all type checking is done at compile time in caml, whereas it is done in runtime for haskell if I understand well
11:02:02 <maayhem> it is indeed a big difference 
11:02:05 <shapr> for one, strict eval usually gives more speed
11:02:05 <SamB> maayhem: hehe
11:02:10 <ne1> No. compile time in haskell too.
11:02:18 <shapr> but I like lazy eval for the expressiveness
11:02:43 <shapr> lazy lists are great fun
11:02:52 <maayhem> ne1: ah k, but isnt lazy evaluation a constraint for static type checking ?
11:03:27 <ne1> I like lazy evaluation because I am too lazy. Serious. I am too lazy to tell the computer when to fetch new data.
11:03:54 <maayhem> what about metaprogramming, it needs lazy type checking right 
11:04:03 <maayhem> I guess haskell support it very well ?
11:04:14 <shapr> type checking still works fine
11:04:15 <ne1> How is lazy evaluation a constraint for static type checking?
11:04:46 <maayhem> ne1: in the sense that if you want to generate code and evaluate it lazyly, you are forced to do lazy type checking 
11:05:01 <ne1> (I suppose Haskell demonstrates that it is not a constraint.)
11:05:42 <ne1> No, I am not forced to.
11:06:15 <jvee> ne1: I dont know, I'm just asking, I never really used hasjell except reading some docs 
11:06:19 <shapr> the lazy calls can still be checked just fine
11:06:19 <jvee> haskell
11:06:43 <shapr> fib = 1 : 1 : zipWith (+) fib (tail fib)
11:06:46 <jvee> shapr: ok, but what if you want to generate a function, and then execute it in runtime
11:06:54 <mattam> for metaprogramming, i suppose splicing is deeply strict, thats all
11:07:20 <shapr> you can use Template Haskell
11:07:30 <shapr> or you could use the GHCi stuff too
11:07:38 <shapr> lambdabot does dynamic loading
11:07:47 <shapr> @dynamic-reload type
11:07:48 <lambdabot> module reloaded
11:07:48 <Leimy> hmmm zipWIth... that takes (x,y) into [x,y] ???
11:08:09 <Leimy> or is that unzip
11:08:11 <jvee> shapr: hum, its a haskell bot ? ;)
11:08:11 <Leimy> DOH!
11:08:15 <shapr> yes!
11:08:20 <jvee> heheh
11:08:39 <shapr> fun too
11:08:42 <shapr> @seen jmob
11:08:43 <lambdabot> jmob is in #haskell and #think.
11:08:51 <Leimy> so zip takes [x,y] into (x,y) and applies + to x and y?
11:08:56 <Leimy> well in that case :)
11:10:07 <Marvin--> @type zip
11:10:07 <shapr> @listmodules
11:10:08 <lambdabot> zip :: forall b a. [a] -> [b] -> [(a, b)]
11:10:08 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic
11:10:08 <lambdabot> ,"eval","hello","karma","quote","seen","state","system","topic","type"]
11:10:12 <desrt> wow.
11:10:20 <desrt> http://www.zvon.org/other/haskell/Outputprelude/
11:10:22 <Leimy> Marvin--: thanks
11:10:24 <desrt> useful for rapid learning
11:10:27 <desrt> very nice examples
11:10:28 <shapr> @listcommands type
11:10:29 <lambdabot> Module type provides the following commands: ["type","info"]
11:11:18 <shapr> desrt: the xslt info on that site is good if you ever need to learn xslt
11:11:52 <vegai> whose is the bot? how much resources does it use?
11:12:21 <Leimy> so for that fib expression you'd want to "take" since it's an infinite series
11:12:45 <desrt> wow
11:12:46 <shapr> vegai: I'm hosting it, source is online, and not much
11:12:47 <desrt> everyone does fib :)
11:12:59 <vegai> I guess I'll find out faster by trying
11:13:22 <Leimy> yeah... there are a lot of ways to do fib :)
11:13:22 <shapr> sf.net/projects/haskell-libs
11:13:30 <shapr> lambdabot 2.0 is there
11:13:40 <desrt> my first fib sucked :)
11:13:44 <Leimy> mine too :)
11:13:46 <Leimy> quite naive
11:13:50 <desrt> ya
11:13:54 <Leimy> but it was recursive :)
11:13:55 <desrt> we probably had the same algo
11:13:59 <shapr> many different #haskell people have written code for lambdabot 
11:14:10 <desrt> fib 0 = 1
11:14:11 <desrt> fib 1 = 1
11:14:17 * Leimy would love to see a Haskell version of "lisppaste"
11:14:17 <desrt> fib x = fib (x-1) + fib (x-2)
11:14:20 <bluejay> ones=1:ones is cool too ;)
11:14:32 <shapr> Leimy: write it!
11:14:33 <desrt> then liblist = fibfrom 0
11:14:43 <desrt>   where fibfrom x = fib x : fibfrom (x+1)
11:14:47 <Leimy> shapr: I might... once I understand Monads :)
11:14:54 <shapr> the lambdabot plugin system is nice
11:15:01 <desrt> fun stuff.  calculates the first couple dozen values or so then grinds to a halt :)
11:15:04 <Leimy> perhaps I can learn from lambdabot :)
11:15:28 <shapr> polli rewrote the plugin code
11:15:42 <Lor> Is it typesafe now?
11:15:46 <Lor> Ha, I kill myself.
11:15:52 <jmob> toodles.
11:16:02 <shapr> Simon Marlow said it always has been
11:16:25 <Lunar^> shapr: I need you deep knowledge of the Haskell community
11:16:38 <desrt> ahh
11:16:44 <Lunar^> shapr: I've stumbled against a hasdl-0.1pre7.tar.gz somewhere
11:16:45 <desrt> head/tail, last/init
11:17:18 <Leimy> before I tackle things like "haskellpaste" I'd better learn to do string manipulation :)
11:17:55 <Lunar^> shapr: It seems to be Richard Braakman's work. But on haskell-cafe, Adrien Hey said he was working on a SDL binding
11:18:38 <Lunar^> shapr: I took all keyboard datatypes from hasdl for hOp, who should I contact for permission ?
11:19:13 <Leimy> so I have fibList = 1 : 1 : zipWith (+) fibList (tail fibList)
11:19:35 <Leimy> and fib x = head (dropy (x-1) (take x fibList))
11:20:31 <Lor> This sure as hell ain't type-safe: http://www.ScannedInAvian.org/repos/hlibs/lambdabot/RuntimeLoader.hs
11:20:33 <shapr> Lunar^: haSDL is GPL
11:20:49 <Leimy> not LGPL?
11:20:55 <Leimy> :P
11:21:02 <shapr> Richard Braakman (dark) wrote it
11:21:23 <Lunar^> shapr: *sigh* that's annoying
11:21:36 <shapr> Adrien Hey and Nicholas Oury(?) have also worked on bindings
11:21:45 <Lor> That's pretty much the point of GPL.
11:21:59 <shapr> maybe it's lGPL
11:22:03 <Lunar^> We need to choose a license for hOp
11:22:07 <shapr> the archive should say
11:22:17 <desrt> huh.  well that sucks
11:22:22 <desrt> Prelude> sin pi
11:22:23 <desrt> 1.22464679914735e-16
11:22:45 <Lunar^> shapr: The Haskell binding is *not* under GPL or LGPL :) 
11:22:56 <shapr> oh, I can ask him
11:23:07 <Marvin--> desrt: not really Haskell's fault though
11:23:22 <Lunar^> shapr: There's GPL and LGPL license in the package because of SDL includes and 'plg'
11:23:33 <Lunar^> shapr: But the Haskell seems under a BSD like
11:23:35 <Lunar^> cool :)
11:23:55 <Lunar^> shapr: Maybe I should send him a mail
11:24:08 <shapr> yes, maybe he'll show up more then :-)
11:24:45 <shapr> I shouldn't have introduced him to "A Tale in the Desert"
11:24:51 <desrt> 1.224647e-16
11:24:53 <desrt> funny
11:24:57 <desrt> C gets the exact same answer
11:25:08 <Lor> It's not funny at all.
11:25:27 <Marvin--> there's nothing funny whatsoever about floating point numbers :P
11:25:39 <shapr> Lor: ask him tomorrow, he should be back then
11:26:02 <desrt> float sucks
11:26:09 <shapr> sinking is worse
11:26:15 <Lunar^> shapr: What's that ?
11:26:35 <desrt> i'd have thought that haskell would come up with a way to obtain infinite precission
11:27:07 <Lor> IIRC there is some package that uses continuous fractions to get infinite-precision arithmetic.
11:27:27 <Lor> It's certainly an attractive concept.
11:27:48 <desrt> quick!  what's the squareroot of 2?
11:27:53 <desrt> too late.  /me goes to get some tea
11:28:24 <bring> desrt: I could tell you, but it's going to take a while
11:28:38 <Leimy> tea is good
11:28:43 * Leimy shold have some
11:28:47 <shapr> Lunar^: addictive game, don't try it
11:28:49 <Leimy> :lch7
11:28:51 <Leimy> WOO!
11:28:58 <shapr> :rsh6
11:29:09 * Leimy needs focus-follows-eye
11:29:25 * bring built a device for that once
11:29:25 <Marvin--> or focus-follows-brain
11:29:29 <Marvin--> that'd rock
11:29:32 <Leimy> yeah
11:29:39 <Leimy> but then I'd get nothing but porn sites
11:29:46 <Marvin--> there is that
11:29:50 <Leimy> hmmm bash.org
11:29:55 <shapr> Leimy: that's not your brain
11:30:17 <shapr> that's focus follows... never mind
11:30:18 <Marvin--> Leimy: heh
11:30:48 <Leimy> I am trying to write a function that takes a list of strings
11:30:48 <Lunar^> shapr: lol
11:30:50 <SamB> desrt: you can have infinite precision, but it takes forever to print!
11:30:58 <Leimy> and then spaces them into a list of strings that is lineLen long
11:31:11 <Leimy> filling in spaces to justify it
11:31:11 <SamB> and you can't compare, either
11:31:13 <desrt> SamB; there's some stuff going on about this at my school right now, actually
11:31:32 <desrt> SamB; we're adding stuff to haskell to make it so you specify the precision of the final result
11:31:50 <desrt> and it makes sure that all of the intermediate results have enough precision so that there is never rounding errors
11:32:03 <desrt> it's like faking infinite precision
11:32:32 <SamB> hmm.
11:32:38 <desrt> barely knowing any haskell at all i have no idea how it works
11:32:55 <SamB> does it work with Num?
11:33:00 <desrt> ??
11:33:50 <SamB> I mean, does it instantiate the Prelude typeclasses?
11:33:51 <desrt> when i emerged ghc it pulled in gmp.  i found that interesting.
11:34:06 <desrt> i have no idea.  i seriously just started learning haskell last night
11:34:25 <desrt> and the last i talked to someone who knew anything about it was yesterday afternoon :)
11:35:37 <shapr> lazy evaluation in action!
11:36:33 <desrt> you're lucky you can't redefine in haskell
11:36:54 <desrt> else i'd take 2000 your dna and reassign it back to your dna
11:40:14 * shapr whews
11:40:54 <desrt> hm
11:41:21 <desrt> fst/snd only work on pairs
11:41:41 <shapr> yup
11:41:53 <desrt> is there a way to get the nth value of a tuple?
11:42:08 <SamB> ah. this sounds like what I need: "Monads for the Dazed and Confused. ... This is a guide for creating monads in Haskell and SML NJ."
11:42:26 <desrt> samb; monad woes for you too, eh?
11:42:32 <SamB> am dazed and confused... check. am using haskell... check.
11:42:34 <shapr> you can use template haskell to generate them, but tuples aren't sequences, they're types
11:42:48 <desrt> SamB; those 2 conditions are really one in the same, no? :)
11:43:10 <desrt> or certainly, one implies the other
11:43:11 <SamB> desrt: not exactly, but they do tend to coincide a lot.
11:43:32 <desrt> for example, maybe you're not a haskell user but you've just had a lot to drink
11:43:42 <SamB> oh. want to make my own monad... check.
11:44:05 <desrt> shapr; i think samb is into bindage
11:44:14 <shapr> >>= !
11:44:52 <Leimy> anyone got an idea to solve this one
11:45:03 <SamB> that is where I became aware of my confusion ;-)
11:45:15 <SamB> >>=
11:45:25 <desrt> avoid >>=
11:45:26 <desrt> use do
11:45:32 <shapr> @info (>>=)
11:45:34 <lambdabot> -- >>= is a method in class Monad
11:45:34 <lambdabot> infixl 1 >>=
11:45:34 <lambdabot> (>>=) :: forall m :: (* -> *). (Monad m) =>
11:45:34 <lambdabot> 	 forall a b. m a -> (a -> m b) -> m b
11:45:36 <desrt> this is the only thing i've really learned about monads so far
11:45:54 <Leimy>  a function that takes a list of strings and produces a string that is spaced such that the line is justified to fit in lineLength spaces
11:45:59 <Leimy> so if lineLength is 80 
11:46:00 <shapr> but, you gotta understand >>= first, I think
11:46:00 <SamB> desrt: well, you see, if I make my own monad, I have to figure out how >>= will be implemented!
11:46:04 <Leimy> and the list has two words...
11:46:33 <Leimy> you'd subtract the length of the second word from lineLength - length of the current word to get the spaces
11:46:34 <bluejay> >>= is nice if you already have a function that does what you want. Then you need less tokens than do syntax
11:46:44 <desrt> Leimy; are the elements of the list the different lines or do you have to break the lines yourself?
11:46:58 <Leimy> well I just want a single line right now :)
11:47:08 <Leimy> the elements of the list are strings
11:47:17 <desrt> but for a single string...
11:47:34 <Leimy> right... I am taking a list of strings and making it into one string of lineLength
11:47:37 <Leimy> but justified
11:47:45 <desrt> oh.
11:47:48 <desrt> so each string is a word?
11:47:54 <Leimy> yes
11:48:00 <desrt> oh.  that's quite a lot nicer
11:48:04 <Leimy> yeah... 
11:48:11 <Leimy> but it's still difficult for me :)
11:48:18 <Leimy> I have some really funky definition that doesn't work :)
11:48:19 <desrt> i'm gonna try and solve that one for fun :)
11:48:22 <desrt> it's good practice
11:48:24 <Leimy> that's what I am doing :)
11:48:29 <desrt> ok
11:48:29 <Leimy> and I think I am stumped
11:48:32 <desrt> don't tell me your answer :)
11:48:39 <Leimy> I don't have a good answer yet
11:48:47 <desrt> excellent!
11:48:51 <Leimy> but basically
11:48:54 <desrt> shhh
11:49:01 <desrt> :)
11:49:10 <Leimy> justifyJoin :: [String] -> String
11:49:13 <Leimy> that's the type :)
11:49:21 <desrt> fair enough
11:49:32 <Leimy> and you can define lineLength anywhere
11:49:57 <desrt> er
11:50:05 <desrt> oh
11:50:07 <desrt> it's constant?
11:50:30 <desrt> ok.. i think you can get the length of all the words with something like....
11:50:38 <desrt> sum map length list
11:52:53 * desrt makes a dumb version first
11:54:02 <shapr> dang, it's too late to unicycle :-(
11:56:01 <Leimy> desrt: its a constant :)
11:56:03 <Leimy> sort of :)
11:56:04 <Leimy> if 
11:56:08 <Leimy> lineLength = 80 
11:56:12 <Leimy> makes a constant :)
11:56:21 <Leimy> I just define whatever I want lineLength to be :)
11:57:48 <desrt> i have a function that works
11:57:49 <desrt> sort of
11:58:04 <desrt> it doesn't support putting different numbers of spaces between words
11:58:12 <desrt> so it doesn't always reach exactly linelength
11:58:19 <Leimy> hmmm
11:58:42 <desrt> Main> justify ["this","is","my","test","data"]
11:58:42 <desrt> "this      is      my      test      data"
11:58:45 <Leimy> so you do sum map length list
11:58:52 <Leimy> to get the length of all words
11:58:52 <desrt> well
11:58:55 <desrt> sum (map length list)
11:58:58 <Leimy> right
11:59:00 <Leimy> :)
11:59:01 <desrt> want to see my code?
11:59:03 <Leimy> sure
11:59:22 <desrt> http://www.desrt.ca/justify.hs
12:01:23 <desrt> distribute tokens buckets = replicate buckets (div tokens buckets)
12:01:28 <desrt> this is the part that needs to be made more intelligent
12:01:32 <Leimy> right
12:02:07 <Leimy> the trick is to make it figure out what to do with "spaces `mod` (length wordList)"
12:02:09 <Leimy> or something
12:02:25 <desrt> maybe it could be implimented as a recursive algorithm
12:02:32 <desrt> that passes down the number of tokens left to the next bucket
12:02:44 <desrt> which then takes how many it thinks that it should
12:02:46 <desrt> and passes again
12:02:50 <desrt> yes.  i like that
12:03:06 <Leimy> hmmm
12:03:16 <Leimy> what's the heuristic for "how many I should take" ?
12:03:28 <desrt> div tokens buckets
12:03:39 <desrt> which means that extra spaces will tend to go towards the end of the line...
12:03:46 <Leimy> yeah
12:03:48 <desrt> it could always be division with roundup...
12:04:00 <Leimy> a floor function?
12:04:18 <Leimy> er ceil
12:04:21 <desrt> div automatically floors
12:04:28 <desrt> ya.  that's what i mean
12:05:55 <desrt> Main> justify ["this", "is", "my", "second", "test"]
12:05:55 <desrt> "this     is     my      second      test"
12:05:55 <desrt> Main> justify ["this", "is", "my", "second", "testx"]
12:05:55 <desrt> "this     is     my     second      testx"
12:05:58 <desrt> looks good.
12:06:06 <Leimy> might I see the code for that?
12:06:15 <desrt> same place as last time
12:06:21 <Leimy> got it thz
12:06:24 <Leimy> er thx
12:07:24 <desrt> feel free to replace iwant with something more intelligent
12:07:34 <desrt> but it works within your specification as is :)
12:07:41 <Leimy> yeah :)
12:07:43 <Leimy> hehe
12:08:41 <desrt> hmm
12:08:55 <desrt> i wonder how badly it will puke if i pass it words that are too long or just 1 word :)
12:09:00 <desrt> (or no words...)
12:09:59 <Leimy> probably dry heave on a []
12:10:06 <desrt> Main> justify ["this", "is", "the", "string", "that", "never", "ends", "it", "just", "goes", "on", "and", "on"]
12:10:10 <desrt> "thisisthestringthatneverendsitjustgoesonandon"
12:10:13 <desrt> huh.
12:10:15 <Leimy> heh :)
12:10:26 <desrt> it actually behaves reasonably well in all situations
12:10:27 <Leimy> that's where a line break is useful :)
12:10:44 <desrt> ya...
12:10:48 <desrt> how are you breaking your lines?
12:11:27 <Leimy> well I have a function "splitLines"
12:11:33 <Leimy> before I cared about justifying
12:11:37 <desrt> ah
12:11:53 <Leimy> and I think it just took a list of Strings into a list of Lines
12:12:33 <desrt> i wonder if it might be more efficient to work that into the justifier
12:12:39 <desrt> becuase it's doing the length map anyway
12:12:48 <Leimy> but I have another function joinLines which joins lists of lines into one string with '\n'
12:13:04 <desrt> ya.  that's a nice easy one :)
12:13:05 <Leimy> I've got all the pieces scattered :)
12:13:36 <desrt> joinlines list = head joinlines ++ "\n" ++ joinlines (tail list)
12:13:49 <desrt> with an appropriate joinlines [] case
12:13:53 <desrt> actually
12:13:57 <desrt> i need to start writing like...
12:13:59 <bluejay> desrt: That's called "unlines" in the prelude
12:14:01 <Leimy> yeah
12:14:13 <Leimy> bluejay: that would have been helpful to know :)
12:14:14 <desrt> joinlines (x:xs) = x ++ "\n" ++ joinlines xs
12:14:42 <desrt> it's weird to think about pattern matching on the input values
12:14:43 <bluejay> also glance at concat, replicate, and intersperse, maybe.
12:15:14 <desrt> no intersperse
12:15:30 <bluejay> desrt: It's in the List module ("import List")
12:15:33 <desrt> ah.
12:16:04 <desrt> not what i thought it was
12:16:30 <desrt> i want one line [a] -> [a] -> [a]
12:16:32 <desrt> such that
12:16:39 <bluejay> concat $ intersperse ", " ["a","b","c"] == "a, b, c"
12:16:39 <desrt> myfunc [1,2,3] [4,5]
12:16:43 <desrt> [1,4,2,5,3]
12:17:22 <desrt> ie; different ", " for each interspersion
12:17:32 <bluejay> I was thinking to use (oneExtraSpace,rest)=splitAt numWhoNeedExtraSpace words
12:18:25 <bluejay> And then concat$intersperse spaces ((concat$intersperse (' ':spaces) oneExtraSpace):rest)
12:19:11 <desrt> uh
12:21:37 <Leimy> desrt: yeah that works well
12:21:57 <desrt> Leimy; excellent
12:22:05 <desrt> gtksourceview has no haskell syntax hilighting. hrmph.
12:22:06 <Leimy> Breaking lines might be a nice feature to add :)
12:22:13 <bluejay> alternate x:xs ys = x:alternate ys xs (with good base cases) would do what you want, desrt, and might wind up easier to read than mine.
12:22:36 <bluejay> would wind up easier to read
12:22:38 <desrt> bluejay; hmm.  good thinking.
12:23:10 <desrt> because then i can ... crap i can't
12:23:24 <desrt> replicate takes its arguments in the wrong order :P
12:23:29 <desrt> can i say like...
12:23:32 <bluejay> flip
12:23:38 <desrt> (\x -> replicate x ' ')
12:24:04 * desrt looks up flip
12:25:00 <desrt> yes.  this is exactly what i want
12:25:13 * desrt rewrites
12:25:58 <Leimy> flip flips parameters?
12:26:10 <desrt> ya.  it's cool
12:26:55 <Leimy> flip (/) 2 3
12:27:00 <Leimy> heh
12:27:21 <bluejay> @eval flip (/) 2 3
12:27:22 <lambdabot> (line 1, column 7):
12:27:22 <lambdabot> unexpected "/"
12:27:22 <lambdabot> expecting simple term
12:27:28 <bluejay> oh well
12:27:31 <Leimy> works here :)
12:27:32 <Leimy> ghci
12:27:39 <bluejay> yeah, lambdabot isn't quite cool enough
12:27:54 <bluejay> @eval 2/3
12:27:54 <Leimy> @eval replicate 200 ' '
12:27:54 <lambdabot> 0
12:27:57 <Leimy> heh
12:27:57 <lambdabot>                                                                        
12:27:57 <lambdabot>                                                                        
12:27:57 <lambdabot>                                                         
12:28:05 <desrt> woo
12:28:06 <bring> hmm, I gues you could use a multi-parameter type class to write a flip that allows all permutations of the arguments
12:28:08 <desrt> new justify version
12:28:17 <desrt> changes 'spaceify' to look like:
12:28:22 <desrt> alternate [] ys = ys
12:28:22 <desrt> alternate (x:xs) ys = x:alternate ys xs
12:28:22 <desrt> spaceify spaces list = concat (alternate list (map ((flip replicate) ' ') spaces))
12:28:22 <bring> hmm, they'd have to all have different types
12:28:25 <desrt> spiffy :)
12:28:32 <Leimy> desrt: paste it to the same place?
12:28:44 <desrt> done
12:28:48 <Leimy> thx
12:28:53 <desrt> i'm not sure which implimentation i'd say is better
12:28:58 <bluejay> bring: How would that work?
12:29:00 <desrt> the 2nd one certainly has more whiz-bang factor :)
12:29:27 <bring> dunno, maybe it doesn't, I'll try it
12:32:08 <Leimy> alternate is cool
12:32:16 <desrt> i made it cooler now :)
12:32:26 <desrt> instead of returning a list of lists it returns a list
12:32:29 <Leimy> flip flops between the heads of two lists concatenating as it goes
12:32:35 <desrt> no.
12:32:39 <desrt> oh.
12:32:47 <desrt> i thought you were talking about flip :)
12:32:50 <Leimy> nope :)
12:34:19 <desrt> haskell is like a drug :P
12:34:23 <Leimy> yeah
12:34:38 <Leimy> it's also one of the more "pretty" languages I've seen in terms of code and structure
12:34:51 <andersca> if not the most :)
12:34:55 <desrt> (map (flip replicate ' ') spaces)
12:34:59 <desrt> i love that
12:35:41 <desrt> takes a sequence of numbers and turns it into a list of strings with that many spaces :)
12:36:30 <Leimy> I was wondering where spaces came from
12:36:36 <Leimy> but it's in the where of justify
12:36:40 <Leimy> ???
12:36:51 <desrt> no
12:36:54 <desrt> spaceify gives them
12:36:58 <Leimy> oh... it's input to spaceify too :)
12:36:59 <Leimy> hehe
12:37:00 <Leimy> oops :)
12:37:05 * Leimy had a mental name clash
12:37:34 <desrt> the cool part is that you could almost one-liner this
12:37:48 <desrt> obviously not distribute and alternate
12:37:53 <desrt> becuase of their recursiveness
12:38:00 <desrt> but the rest of it could be a single line
12:39:37 <desrt> hm.  haskell's dependance on whitespace is slightly annoying
12:40:08 <Leimy> "layout"
12:40:38 <desrt> lame
12:40:55 <eivuokko> You can use {} with ; too, can't you?
12:41:02 <Leimy> there is a block mode yeah
12:41:04 <desrt> eivuokko; inside do blocks
12:41:06 <Leimy> but it's uglier IMO
12:41:22 <desrt> oh
12:41:24 <desrt> works on where too
12:41:29 <Leimy> I think it "works" :)
12:41:37 <Leimy> it's an alternative to "layout"
12:41:39 <Leimy> or something
12:41:54 <desrt> eh.  whatever
12:41:59 <Leimy> heh
12:42:36 * desrt sticks with layout
12:43:12 <Smerdyakov> Layout is compiled into {;}.
12:43:24 <eivuokko> Leimy, what would you do then?  Is there something bettern than layout or blocks?
12:43:46 <Leimy> eivuokko: ???
12:44:00 <Leimy> I am not complaining
12:44:13 <Leimy> I don't like blocks... I prefer layout
12:44:18 <Leimy> it's easier on the eyes
12:44:38 <eivuokko> Ok.
12:45:55 <shapr> @type flip
12:45:56 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
12:46:35 <desrt> hmm
12:46:41 <desrt> you can omit spaces in weird places
12:46:55 <desrt> like if you have a function that takes 2 args
12:46:57 <desrt> func (a)(b) is ok
12:47:31 * shapr boings hoppily
12:48:33 <shapr> oh, what was the multiarg flip that Cale came up with?
12:48:44 <Cale> I can't remember
12:48:47 <Cale> :)
12:48:49 <shapr> that was a neat solution
12:49:16 <bring> bluejay: a flip3 that gets you the permutation you want seems to work, but naturally it requires enough explicit type signatures to make it utterly uninteresting
12:49:18 <shapr> it was a combination of (.).(.) and flip
12:50:27 <shapr> I should really save the cool code snippets that fly past here
12:52:16 * desrt removes readability as best he can
12:52:45 <eivuokko> Is there any sensible heuristic for a lambdabot plugin?
12:53:07 <Leimy> desrt: distribute builds a list of how many spaces for each word in the list and list alternates the list of words with the list of # of spaces transformed into real spaces right?
12:53:18 <Leimy> well for each "bucket" :)
12:53:20 <desrt> Leimy; it's a little bit more generic
12:53:27 <Leimy> yeah
12:53:28 <desrt> distribute takes a number of tokens and buckets
12:53:30 <Leimy> I mean in this application
12:53:34 <desrt> and generates a list of "buckets" length
12:53:41 <desrt> with the tokens evently distributed among the buckets
12:54:08 <desrt> well.  your description isn't quite right
12:54:19 <desrt> there is 1 fewer buckets than the number of words
12:54:25 <desrt> that's the length list - 1 business
12:54:51 <Leimy> sure... the words "fencepost" the spaces :)
12:55:17 <desrt> d t b=let i=(div t b)in(if(b/=0)then(i:d(t-i)(b-1))else[]);l[][]=[];l(x:z)y=x++l(y)z;justify list = let linelength = 40 in l(list)(map(flip(replicate)' ')(d(40-sum(map length list))(length list-1)))
12:55:21 <desrt> now that's beautiful :)
12:55:27 <Leimy> OBFUSCATOR!
12:55:38 <desrt> hey
12:55:44 <desrt> i left the linelength = 40 thing in
12:55:51 <desrt> i could have taken that out to make it even more confusing :)
12:55:55 <Leimy> heh
12:56:05 <desrt> ok. gone
12:56:11 <shapr> desrt: you must enter the IOHCC
12:56:14 <Leimy> hook linelength up to input read from a camera attached to your mood ring
12:56:14 <Leimy> :)
12:56:20 <desrt> shapr; iohcc?
12:56:28 <desrt> Leimy; hah.
12:56:46 <shapr> International Obfuscated Haskell Code Contest
12:56:55 <Leimy> terror!
12:57:02 <desrt> now that's what i'm talking about :)
12:57:07 <shapr> eivuokko: what do you mean heuristic?
12:57:28 <shapr> the Succ Zero IOHCC is coming soon
12:58:04 <desrt> i think this calls for my own (recursive) replicate function with a confusing name :)
12:58:31 <shapr> the winner of the 0th IOHCC was immensely cool
12:58:41 <shapr> "remorse"
12:58:55 <Leimy> obfuscated code makes me dump core in my pants
12:59:06 <shapr> it's a programmatic obfuscator
12:59:23 <shapr> it was submitted in obfuscate form of course :-)
13:00:12 <shapr> http://iohcc.mgoetze.net/winners.html
13:00:16 <desrt> crap
13:00:19 <desrt> my code just got longer :(
13:00:30 <shapr> remorse rocks
13:00:47 <desrt> ERROR "justifyevil.hs":3 - Syntax error in input (unexpected `)')
13:00:49 <desrt> uh oh
13:00:51 <desrt> i'm *so* screwed :P
13:00:59 <shapr> eivuokko: what sort of plugin heuristic do you mean?
13:01:04 <shapr> desrt: haha!
13:01:28 <Leimy> that's bad
13:01:32 <desrt> oh.  found it
13:01:32 <eivuokko> shapr, I mean that maybe there could be a lambdabot plugin to catch snippets, but that the algorithm deciding what's code (and worth saving).
13:01:32 <Leimy> at least it's not lisp :)
13:01:43 <desrt> and now my program is shorter than it was
13:01:43 <desrt> woo
13:01:55 <desrt> w y=' ':w(y-1);d(t)b=let i=(div(t)b)in(if(b/=0)then(i:d(t-i)(b-1))else[]);l[][]=[];l(x:z)y=x++l(y)z;j q=l(q)(map(w)(d(40-sum(map(length)q))(length q-1)))
13:02:03 <shapr> eivuokko: oh, I see
13:02:05 <desrt> still the same algorithm (almost) :)
13:02:11 <Leimy> run that through remorse :)
13:02:15 <shapr> yow!
13:02:28 <desrt> ^^ justify text :)
13:03:23 <desrt> k
13:03:28 <desrt> tictac toe is the greatest :)
13:03:31 <shapr> Probably simpler to just put any goodies on PreludeExts
13:04:07 <shapr> oh, the way to play that tictactoe is to edit the source!
13:04:19 <shapr> you put an x or an o in the right place
13:04:27 <shapr> that's way cool
13:05:01 <desrt> wait a minute
13:05:13 <desrt> did it just morse-code my program?
13:05:18 <desrt> argh
13:05:24 <desrt> clever pun
13:06:15 * shapr grins
13:07:07 <desrt> er
13:07:21 <desrt> the tictactoe one prints its own code with a 'o' in the middle
13:07:22 <desrt> then quits
13:07:30 <desrt> oh my god
13:07:41 <desrt> do i modify this and run it again?
13:07:56 <shapr> put an x in the right place and run that :-)
13:08:01 <shapr> yup
13:08:01 <desrt> hahahah
13:08:05 * shapr grins
13:08:22 <desrt> sick!
13:08:26 <shapr> that was Pseudonym's entry
13:08:44 <desrt> absolutely perverse :)
13:08:51 <shapr> yah, it's brilliant
13:09:05 <shapr> anyway, the next one is coming up very soon
13:09:28 <shapr> as soon as I get some jurors together.
13:10:52 <Leimy> @eval map (flip replicate ' ') [1,2,3,1,1,4,5,1,1,2,1,3,1,15]
13:10:53 <lambdabot> [ ,   ,    ,  ,  ,     ,      ,  ,  ,   ,  ,    ,  ,                ]
13:10:57 <Leimy> awesome :)
13:11:09 <desrt> woh
13:11:12 <desrt> i like that
13:11:21 <desrt> well
13:11:23 <Leimy> desrt that's from your code man :)
13:11:26 <desrt> i don't like how it drops the ""
13:11:27 <Leimy> you BETTER like it :)
13:11:34 <Leimy> that's the bot :)
13:11:37 <desrt> i mean i like that bot
13:11:43 <Leimy> yeah the bot rocks :)
13:12:00 <desrt> @eval map (flip replicate 'x') [1, 2, 3, 4, 5, 1]
13:12:01 <lambdabot> [x, xx, xxx, xxxx, xxxxx, x]
13:12:08 <desrt> a bit better to see it....
13:12:43 <shapr> desrt: so, you still think Haskell takes more brains than proceural programming? :-)
13:12:52 <desrt> shapr; absolutely
13:13:09 <desrt> it's very amusing, though :)
13:13:09 <shapr> heh, it seems simpler to me
13:13:35 <shapr> yah, it's a blast
13:13:51 <shapr> lots more goodies you haven't seen yet too
13:13:57 <desrt> i'm going to install gtk now
13:15:00 <shapr> hOp is a neat goodie
13:15:07 <desrt> ahh
13:15:12 * desrt gets an email from anand
13:15:15 <desrt> a very happy email
13:15:26 <desrt> Begin forwarded message:
13:15:27 <desrt> >  Due to large number of participants the McMaster Optimizationn  Day
13:15:27 <desrt> >  is moved to the main lecture room ITB 137.
13:15:27 <desrt> >  We start with joint breakfast at 8.45, Monday morning.
13:15:42 <desrt> i thought it was at 7.30.  that would have sucked
13:15:48 <shapr> Optimization Day sounds cool
13:17:01 <desrt> i'm not sure how we can have a meeting in ITB137 :)
13:17:04 <Leimy> joint breakfast
13:17:14 <Leimy> breakfast at 4:20?
13:17:16 <desrt> Leimy; ya.  they're really good about feeding us
13:17:16 <Leimy> heh
13:17:48 <desrt> out of 4 days (friday, sat, sun, mon) i'm getting 4 free meals from them :)
13:17:53 <shapr> nice
13:18:16 <desrt> friday was lasagne and penne with alfrado/mushroom or red sauce (your pick), fruit, cookies, tea, etc
13:18:24 <desrt> sat was just pizza and pop
13:18:34 <desrt> for breakfast tomorrow, muffins, fruit, etc
13:18:40 <desrt> not sure about lunch tomorrow but i know we're getting it
13:22:16 <Leimy> dang
13:22:20 <Leimy> now I am hungry
13:38:44 * shapr just had pizzor
13:38:51 <andersca> more than one?
13:38:53 <desrt> i could use something like pizzor
13:38:57 <shapr> sort of
13:39:02 <desrt> i had lobster for lunch.  it wasn't enough
13:39:08 <shapr> the other fell off the bike tho ;-/
13:39:27 <desrt> andersca; i imagine you're a very good person to ask this question to:  gtk+hs or gtk2hs?
13:39:47 <andersca> desrt: gtk2hs
13:39:50 <shapr> oh, I'm hoping to get a touring unicycle for the summer!
13:40:06 <desrt> andersca; does it have the gecko bindings? :)
13:40:11 <andersca> desrt: somehow I doubt that
13:40:12 * desrt looking forward to writing a haskell webbrowser :P
13:40:15 <bring> shapr: do they have gears?
13:40:21 <desrt> andersca; gtk+hs does.
13:40:27 <shapr> juhp wrote GtkMoz embed
13:40:36 <shapr> its for gtk+hs tho
13:40:50 <shapr> bring: nah, no commercial geared unis sadly
13:41:01 <shapr> but a 36" wheel is just fine
13:41:15 <andersca> desrt: but that's gtk 1.2 though, right?
13:41:32 <desrt> andersca; i don't think so.. i'm not sure
13:41:40 * desrt checks bindings page on gtk.org
13:41:55 <desrt> both support 2.0, 2.2, 2.4
13:42:03 <desrt> gtkhs does not support 1 (but gtk+hs does)
13:42:06 <andersca> oh, neat
13:42:11 <desrt> s/^gtk/gtk2/
13:42:46 <shapr> hi asmodai 
13:42:49 * desrt pokes asmodai
13:43:02 <Leimy> asmodai: damnit man...
13:43:06 <Leimy> you are everywhere
13:43:13 <shapr> touring uni --> http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
13:43:13 <desrt> i'll say
13:43:15 <asmodai> Leimy: fear
13:43:18 <asmodai> desrt: oi :)
13:43:29 <desrt> freebsd asmodai :)
13:43:34 <desrt> gtk andersca
13:43:41 <desrt> freakish shapr
13:43:46 <asmodai> lol
13:43:48 <shapr> heh
13:43:57 <asmodai> desrt: freebsd is my old claim
13:43:59 <shapr> I'm famous!
13:44:03 <asmodai> nowadays tendra/dragonfly
13:44:06 <asmodai> shapr: I'm infamous
13:44:08 <desrt> asmodai; that's where i first met you :P
13:44:13 <desrt> tendra? :(
13:44:22 <desrt> use gcc like a good free software hacker
13:44:24 <shapr> compiler
13:44:27 <shapr> mmm
13:44:28 <Leimy> asmodai: tendra... what's new and good there?
13:44:46 <shapr> 36 inches is 90cm ?
13:44:49 <asmodai> Leimy: been working on the build system with some help from Eirik
13:44:53 <asmodai> shapr: 36 x 2.54
13:44:55 <Leimy> awesome
13:45:03 <asmodai> Leimy: finally gettnig somewhere
13:45:11 <asmodai> Leimy: and have a ton of ideas for after that
13:45:13 <shapr> right, it's 2.54 wide
13:45:32 <shapr> oh, that's the conversion, doh
13:45:44 <shapr> @eval 36 * 2.54
13:45:44 <lambdabot> type error
13:45:50 <shapr> bad bot!
13:45:52 <desrt> 36.0 :P
13:45:56 <shapr> @eval 36.0 * 2.54
13:45:56 <lambdabot> type error
13:46:00 <desrt> ...
13:46:02 <shapr> ?
13:46:08 <desrt> @eval 36.0001 * 2.54
13:46:09 <lambdabot> type error
13:46:12 <shapr> hm
13:46:13 <Igloo> @eval 36.0
13:46:13 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:46:31 <Igloo> Is it treating . as function composition?
13:46:31 <shapr> @get-definition (*)
13:46:31 <lambdabot> (*) not defined
13:46:35 <shapr> @get-definition *
13:46:36 <lambdabot> * not defined
13:46:41 * shapr shrugs
13:46:53 <Riastradh> @eval 3
13:46:53 <lambdabot> 3
13:46:56 <shapr> @eval 1.0 + 1
13:46:57 <lambdabot> type error
13:47:01 <desrt> ya
13:47:02 <Riastradh> @eval 34.0 1
13:47:02 <lambdabot> type error
13:47:03 <desrt> . is comp
13:47:04 <asmodai> lol
13:47:06 <shapr> @eval (1.0) + 1
13:47:06 <lambdabot> type error
13:47:07 <asmodai> this is fun
13:47:11 <shapr> yah, I tink so
13:47:16 <desrt> @eval 36 * 254
13:47:16 <lambdabot> 9144
13:47:21 <desrt> 91.44 :P
13:47:22 <shapr> yup
13:47:28 <shapr> too easy :-)
13:47:41 <desrt> ya
13:47:42 <desrt> easy sucks
13:47:43 <desrt> ...
13:47:57 <shapr> next to fix the interpreter
13:48:06 <desrt> hey
13:48:09 <desrt> fix this one too
13:48:16 <desrt> @eval replicate 10 ' '
13:48:16 <lambdabot>           
13:48:19 <desrt> useless :P
13:48:28 <shapr> what's wrong with that?
13:48:35 <desrt> you should add ""
13:48:35 <shapr> oh, you want quotes?
13:48:38 <shapr> ah
13:48:41 <ludde> @eval replicate 10 'a'
13:48:41 <lambdabot> aaaaaaaaaa
13:48:45 <ludde> @eval replicate 1000 'a'
13:48:50 <shapr> uhoh
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:48:58 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:49:00 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:49:01 <shapr> aieee
13:49:03 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:49:04 <lambdabot> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
13:49:06 <lambdabot> [4 @more lines]
13:49:07 <desrt> hahah.
13:49:12 <ludde> oops
13:49:18 <desrt> took it long enough :P
13:49:24 <ludde> @eval replicate 1000 '\x10'
13:49:26 <ludde> oops
13:49:27 <ludde> sorry
13:49:32 <ludde> @eval replicate 1 '\x10'
13:49:36 <lambdabot> 
13:49:36 <lambdabot> 
13:49:36 <lambdabot> 
13:49:36 <lambdabot> 
13:49:36 <lambdabot> 
13:49:37 <lambdabot> 
13:49:39 <lambdabot> 
13:49:41 <lambdabot> 
13:49:43 <lambdabot> 
13:49:43 * shapr sighs
13:49:44 <Leimy> uh
13:49:46 <lambdabot> [5 @more lines]
13:49:47 <lambdabot> 
13:49:54 <ludde> is therer some lambabot play channel?
13:49:58 <shapr> yes
13:50:00 <shapr> #joy
13:50:01 <ludde> where
13:50:20 <Marvin--> use /msg
13:51:13 <Riastradh> @eval mapM
13:51:13 <lambdabot> unbound variable: mapM
13:51:15 <Riastradh> @eval sequence
13:51:16 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:51:44 <Riastradh> @eval sequence (map (replicate 1) "\r\nPRIVMSG #haskell :Hello, world!")
13:51:44 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:51:55 <Riastradh> @get-definition sequence
13:51:55 <lambdabot> sequence = \\l.if null l then return [] else head l `bind` (\\x.sequence 
13:51:55 <lambdabot> tail l) `bind` (\\xs.return (x:xs)))
13:52:15 <Riastradh> @eval run
13:52:16 <lambdabot> unbound variable: run
13:52:34 <Riastradh> @eval map (replicate 1) "\r\nPRIVMSG #haskell :Hello, world!"
13:52:35 <lambdabot> [, 
13:52:35 <lambdabot> , P, R, I, V, M, S, G,  , #, h, a, s, k, e, l, l,  , :, H, e, l, l, o, 
13:52:35 <lambdabot> ,  , w, o, r, l, d, !]
13:52:45 <Riastradh> ...oops, that didn't work.
13:52:53 <Riastradh> Eh, this is silly.
13:58:55 <shapr> hi kosmikus 
13:59:04 <kosmikus> hi shapr
13:59:09 <shapr> what's up?
13:59:17 <shapr> thesis writing?
13:59:22 <kosmikus> still, yes ...
13:59:28 <kosmikus> boring, isn't it?
14:00:16 <shapr> I dunno, I have deadlines, client relations, hidden bugs, uncertain contracts
14:00:27 <shapr> boring might be nice for a bit
14:00:40 <kosmikus> :)
14:00:41 <desrt> i thought haskell didn't have bugs
14:00:41 <desrt> =)
14:00:54 <shapr> I don't get paid to write Haskell yet.
14:00:59 <shapr> I wish
14:01:35 <shapr> I build Zope/Plone sites for a living
14:01:44 <shapr> that's Python
14:02:05 <desrt> wow.
14:02:10 <desrt> python for a living?
14:02:13 <shapr> yup
14:02:14 <desrt> i think i might rather die
14:02:32 <shapr> doing Java was far worse
14:03:13 <shapr> Python is okay, Java hurts
14:03:30 <shapr> at least I get to use emacs and linux and sit at home
14:03:48 <desrt> wow
14:03:48 <bring> shapr: do you know the swedish expression "att må pyton"?
14:03:54 <desrt> writing python using emacs is like a bad dream for me :)
14:04:13 <shapr> bring: no, what's that?
14:04:22 <shapr> can you say it again?
14:04:29 <shapr> I switched to latin1
14:04:37 <bring> "att må pyton"
14:04:39 <desrt> heh.  irc should boot you off if you send non-utf8 text
14:04:41 <shapr> I'm fond of emacs
14:04:54 <shapr> oh, what's that?
14:05:11 <shapr> må is to grind?
14:05:12 <bring> it bascially means "to feel like crap"
14:05:14 <shapr> heh
14:05:19 <bring> no, feel
14:05:24 <shapr> oh, right
14:05:37 <shapr> "hur mår du" for example
14:05:46 <bring> exactly
14:05:49 <shapr> to feel like a python, ha
14:05:58 <bring> desrt: guess I'd better switch to utf8 then
14:06:03 <Maddas> yay
14:06:06 <desrt> bring; please do
14:06:11 <shapr> I have to try that in gothenburg
14:06:21 <bring> feeling like crap?
14:06:23 <shapr> at EuroPython
14:06:40 <shapr> nah, just saying that at EuroPython would be funny
14:06:49 <skew> desrt: what would you rather be writing than Python?
14:07:01 <skew> hi people!
14:07:05 <desrt> skew; to pick something vaguely python-like, perl
14:07:07 <shapr> y0 skew
14:07:20 <vegai> desrt: ack!
14:07:25 <skew> why perl?
14:07:45 * vegai hits himself in order to prevent a scripting language war.
14:07:50 <skew> I've never heard anything good about it except that regexes are tightly integrated into the language
14:07:51 <vegai> ah, much better
14:08:02 <skew> which is sort of neutral
14:08:45 <vegai> its runtime has a relatively small memory footprint
14:08:53 <vegai> there, I said something good about it
14:09:08 <skew> although it does remind be of the crazy regex typeclass stuff somebody (ozone?) wrote for Haskell
14:09:34 <skew> which gave appropriate results for a regex match in about 10 different contexts
14:09:36 <desrt> it's very easy to write code extremely rapidly
14:09:45 <vegai> a good language allows one to do crazy things, but does not force one
14:09:50 <skew> is it easy to produce functionality rapidly?
14:09:52 <desrt> for text processing it's absolutely blissful
14:10:03 <desrt> skew; s/code/functional code/
14:11:14 <desrt> heh.  i remember back in the day i wrote an IRC bot that was a sequence of regexps (and nothing else)
14:11:44 <skew> I'd rather not code in sed
14:12:07 <desrt> i also had one written in awk
14:12:13 <desrt> that one might still be around, actually...
14:12:27 <skew> I did write something in sed once, but I've forgotten what
14:12:31 <Maddas> Reducing Perl to regular expressions is rather silly.
14:12:43 <shapr> I wrote some stuff in sed also
14:13:02 <shapr> I tried to do binary editing in sed once but never got it working
14:13:51 <shapr> trying to remove long silences from before ripped hidden tracks
14:13:53 <desrt> Maddas; writing anything using only regexps is extremely silly
14:13:56 <desrt> that was the point :)
14:14:30 <desrt> shapr; ok... unix is cool.  it's not that cool :P
14:14:53 <shapr> well, I tried
14:14:59 <desrt> perhaps you should have cat file.wav | uuencode | sed | uudecode > newfile.wav
14:15:12 <shapr> I never did figure out a good solution
14:15:15 <skew> unix is the lesser of evils, at the moment
14:15:17 <shapr> that's a thought
14:15:30 <shapr> hOp maybe :-)
14:15:48 <skew> well, between Linux and assorted windowses
14:15:57 <shapr> http://www.macs.hw.ac.uk/~sebc/hOp/
14:16:32 <desrt> oh wow
14:16:51 <shapr> hOp roxx
14:16:53 <desrt> you people are totally whacked
14:17:00 <shapr> haha
14:17:09 <shapr> you're just jealous :-P
14:17:24 <desrt> "jealous" is a very interesting way to spell "less insane"
14:17:25 <ksandstr> that's "oh wow" as in... "how completely freaky!"
14:17:47 <shapr> I'd like to write a tcp/ip stack in Haskell
14:17:56 <shapr> would be fun
14:17:59 <desrt> ya
14:18:05 <desrt> that would actually be a good job for haskell
14:20:18 <shapr> wait till you see monadic parsers
14:20:23 <shapr> they're awesome
14:20:32 <shapr> like parsec
14:20:34 <Leimy> that's what I think a haskellpaste would need certainly
14:20:52 <Leimy> but I am hopefully going to do something with XML-RPC
14:20:59 <Leimy> so you can paste from wherever to the channel :)
14:21:25 * Leimy already has some nice emacs-lisp bindings to paste buffers to lisppaste hosted channels :)
14:21:29 <Leimy> using xml-rpc
14:21:48 <Leimy> or rather channels hosting lisppaste
14:22:12 <shapr> bring wrote a nice xmlrpc lib for Haskell
14:22:37 <shapr> http://www.dtek.chalmers.se/~d00bring/projects.html
14:23:03 <juhp> GtkMoz "works" with gtk2hs too
14:24:33 <juhp> though only thing being that the widget doesn't like to get realised somehow: I could only get it to appear after switching notebook pages, but haven't had time to look into it in detail
14:26:01 <desrt> juhp; do you use the normal IO monad to communicate with it?
14:26:14 <desrt> or does it have its own gtk monad?
14:26:29 <SamB> whats a good way to get stuff to pretty-print?
14:26:39 <juhp> desrt: the IO monad
14:26:45 <desrt> SamB; i like gedit
14:26:47 <juhp> like gtk2hs does
14:29:14 <Leimy> hmmm Haskell-XML-RPC eh/
14:29:16 <Leimy> very nice :)
14:30:23 <shapr> konichiwa juhp-san
14:30:28 <desrt> i think this whole functional thing is kinda crap
14:30:31 <desrt> it's almost meaningless
14:30:43 <shapr> I disagree
14:30:55 <desrt> any language can be function if you restrict yourself properly
14:31:00 <desrt> *functional
14:31:08 <Leimy> not sure about that
14:31:09 <desrt> the laziness is what i like
14:31:21 <SamB> desrt: but that can't be guarenteed!
14:31:31 <SamB> I mean that you will restrict yourself.
14:31:34 <juhp> 'morgen, shapr :)
14:31:44 <desrt> SamB; then you shoot yourself in the foot.  bad programmer :P
14:31:47 <shapr> thing is, purely functional means some rules can be proven
14:32:00 <desrt> shapr; ya.  from a verification standpoint i can imagine it's a dream
14:32:02 <shapr> that can't be proven in procedural langs
14:32:15 <shapr> from an optimization standpoint as well
14:32:17 <desrt> ya
14:32:23 <desrt> you can make a lot of assumptions
14:32:28 <desrt> which makes for more interesting optimisations
14:32:29 <shapr> and from a sanity standpoint when debugging
14:32:46 <SamB> desrt: the compiler can't trust code to be functional either, in a procedural language.
14:32:52 <shapr> OOP chunks the state into each instance
14:33:05 <desrt> OOP is functional
14:33:08 <shapr> pure FP puts all the state in one place
14:33:17 <SamB> and you absolutely can't expect laziness in a procedural language, anyway.
14:33:21 <desrt> assuming there is no global state
14:33:42 <desrt> actually
14:33:45 <desrt> i'm just gonna take that back
14:33:49 <desrt> because there is always global state :P
14:33:50 <shapr> but, the result of a call depends on the state of the various instances
14:34:04 <desrt> shapr; so you have an instance pointer instead of a monad
14:34:08 <desrt> same diff :P
14:34:29 <shapr> not true, a monad is a pipe I can easily change
14:34:36 <shapr> I can't instrument a poiter
14:34:39 <shapr> pointer
14:34:55 <desrt> i actually don't know what i'm talking about
14:35:04 <desrt> being that i don't even know what a monad is.  i just think i do :)
14:35:16 <shapr> well, keep it up :-)
14:35:28 <shapr> that tutorial we menioned is good
14:35:29 <desrt> i'm usually good at pretending
14:35:32 <shapr> heh
14:35:59 <shapr> we're experienced at comparing procedural to pure FP
14:36:18 <shapr> one example is unit testing
14:36:40 <desrt> uhm
14:36:46 <shapr> in a pure FP lang, I can generate a state to be passed in for testing
14:36:46 <desrt> all of this testing is crap anyway
14:36:52 <shapr> no way
14:37:02 <shapr> unit testing rocks
14:37:03 <desrt> has anyone proven that ghc always produces correct output? :)
14:37:13 <shapr> especially unit test first
14:37:19 <SamB> UnitTesting may be crap, but QuickCheck is not.
14:37:44 <desrt> 2aa4 was our software design class
14:37:45 <SamB> well, unittesting where you have to create your own test data, anyway.
14:37:46 <desrt> my lowest mark
14:37:51 <desrt> B
14:38:01 <desrt> i didn't do the assignments (worth 20%)
14:38:10 <shapr> in something like J2EE, testing is much more difficult because the result depends on the state of all the other instances in the system
14:38:20 <desrt> i scored a 95/100 on the exam.  i lost 3 of those marks to the 25-point testing question :
14:38:23 <desrt> :P
14:38:24 <desrt> (evil testing)
14:38:51 <shapr> desrt: I had an A in every CS course I've taken (all one of them ;-)
14:39:03 <desrt> i had an A in all my other software eng. courses this term
14:39:07 <desrt> my only B >:|
14:39:14 <desrt> i didn't do assignments in any of them
14:39:19 <desrt> but the bell curve brought my Bs to As
14:39:25 <desrt> in 2AA4 there was no bell curve :(
14:39:35 <shapr> unit testing plus refactoring really works wonders
14:39:47 * desrt hits shapr with a waterfall
14:39:49 <shapr> I'd be happy to show you
14:39:51 <shapr> ick
14:40:03 <desrt> know a guy named parnas?
14:40:12 <shapr> eXtreme Programming r0xx0rs
14:40:23 <shapr> don't think so, who's that?
14:40:29 <desrt> invented software engineering
14:40:43 <shapr> oh, I thought you meant on IRC :-P
14:40:43 <desrt> he has a lot to say about how useful/useless the waterfall is
14:41:03 <desrt> it's useful to document your software on paper (you pretend you followed the waterfall process)
14:41:09 <shapr> haha
14:41:09 <desrt> but it's damned useless to *actually* follow it :P
14:41:20 <shapr> XP is nice
14:41:24 <desrt> he actually wrote a paper called "how to fake it"
14:41:36 <shapr> it's hard work, but it pays big dividends
14:41:55 <shapr> XP is heavy on the discipline
14:41:58 <desrt> âA Rational Design Process and How to Fake Itâ
14:42:01 <desrt> that's the one
14:42:05 <shapr> amusing
14:42:44 <shapr> as SamB said, I think you'll like QuickCheck
14:42:54 <shapr> that's the Haskell way to test code
14:43:12 <shapr> it beats unit testing
14:43:27 <shapr> I think it can beat design by contract too
14:43:33 <desrt> i'm gonna go to school tomorrow and hit my supervisor with a haskell stick
14:43:40 * shapr laughs
14:43:50 <desrt> i think he'll fall over but in the end be happy
14:43:58 <desrt> he's the same person that taught me 2aa4 :)
14:44:09 <desrt>  he's big on verification, testing, etc
14:44:18 <shapr> he didn't teach you about QuickCheck?
14:44:24 <desrt> we don't know haskell
14:44:28 <shapr> oh
14:44:34 <desrt> he's a cool guy
14:44:35 <shapr> but now you almost do :-)
14:44:39 <desrt> but no haskell yet
14:44:55 <shapr> QuickCheck will knock your socks off
14:45:00 <desrt> (he wrote the safety shutdown system for the darlington nuclear reactor... and then spent years verifying and testing it)
14:45:05 <shapr> wow
14:45:36 <shapr> there are some interesting projects in progress to verify all of GHC
14:45:48 <shapr> and then to run it on the bare metal
14:45:48 <desrt> if that ever happened i'd be *extremely* impressed
14:45:51 <desrt> ghc is frickin huge
14:46:11 <desrt> heh.  i suppose there's no point to verifying ghc then running it on an OS that you can't trust
14:46:26 <shapr> even so, I believe the people who are doing it will  complete it.
14:46:32 <shapr> right
14:46:57 <desrt> wow
14:47:00 <shapr> I don't know if they'll ever release the verification though
14:47:16 <desrt> why is ghc so frickin big?
14:47:31 <shapr> it does a lot of stuff
14:47:32 <SamB> shapr: what are they doing it for if they won't release?
14:47:33 <Leimy> because it's awesome :)
14:47:52 <desrt> damnit
14:47:55 <desrt> all of these cds are damn good
14:48:02 <shapr> SamB: they can afford to do that for their own use
14:48:13 <Riastradh> Yes, GHC inspires awe & fear...
14:48:25 <desrt> it took about 3 days to compile
14:49:07 <shapr> SamB: that should narrow the list of candidates to a few obvious ones ;-)
14:49:53 <desrt> shapr; i made hugs segfault.  that's definitely a bug in hugs, right?
14:50:03 <shapr> I think so
14:50:07 <SamB> Microsoft? IBM?
14:50:11 <shapr> you should report it
14:50:18 <Igloo> If you made the C stack overflow then it's a known one, though
14:50:20 <desrt> i'll have to recompile it with debugging output
14:50:37 <skew> if you use FFI stuff it could be your fault
14:50:45 <desrt> ffi?
14:50:54 <skew> at least, I know you can get GHC to make code that segfaults with the FFI
14:50:57 <skew> ;)
14:51:02 <desrt> it's a 2-liner recursive algorithm to compute fibonacci's sequence backwards
14:51:06 <skew> foreign function interface
14:51:17 <desrt> oh.  none of that
14:51:21 <skew> how you call C functions and expose Haskell functions for C (or with a C calling convention)
14:52:22 <desrt> fib2 = reverse (revfib [1, 1])
14:52:22 <desrt> revfib list = head list + head (tail list) : revfib list
14:52:28 <desrt> ^^ invoking fib2 = hugs segfault
14:52:56 <desrt> ya
14:53:02 <desrt> this looks an awful lot like a stack overflow
14:53:10 <skew> reversing infinite lists doesn't work so weel
14:53:24 <desrt> i thought laziness would take care of it :)
14:53:34 <Marvin--> how would it?
14:53:44 <desrt> it was one of the first things i ever wrote in haskell.  i realise the error of my ways
14:53:44 <Marvin--> the first item in reverse xs would be the last item in xs
14:53:49 <skew> yeah, it doesn't actually try to find the last element of the list until you need the first element of the reversed list
14:53:59 <Marvin--> but if xs is infinite, it doesn't *have* a last element
14:54:01 <skew> oops, something about the naturals having no upper bound...
14:54:07 <desrt> Marvin; i know now.
14:54:10 <desrt> heh
14:54:22 <skew> oh, that revfib doesn't quite work either
14:54:23 <desrt> the gdb backtrace is at the 1300th invocation of overwrite() right now :)
14:54:31 <desrt> 1500....
14:54:31 <skew> it recurses on jsut list, the same
14:54:42 <desrt> ok
14:54:47 <desrt> i know my code is ridiculously broken :P
14:54:49 <skew> the same list, so you might as well have written repeat 2
14:54:52 <desrt> but hugs is broken too
14:54:57 <desrt> and that's the reason i kept it
14:54:59 <skew> apparently...
14:55:05 <skew> I use GHCi
14:55:17 <shapr> hm, new release of Self
14:55:18 <skew> which is nicer than hugs for interactive use
14:55:23 <desrt> my 2 dozen short lessons booklet told me to get hugs :)
14:56:24 * desrt wonders how far this backtrace goes.....
14:56:26 <Leimy> what is the preferred way to install things like HaXml into  haskell system?
14:56:28 <Leimy> or onto
14:56:44 <Leimy> download / and make install?
14:56:52 <Leimy> or is there some kind of haskell packaging system?
14:57:39 <Igloo> Not yet...
14:57:40 <skew> not just yet
14:57:49 <SamB> shapr: huh? new release of Self? who? where? which platform?
14:58:28 <desrt> ghc-6.2.1: panic! (the `impossible' happened, GHC version 6.2.1): loadObj: failed
14:58:31 * bring would like to work on some LIP stuff at EuroHaskell
14:58:42 <bring> and hOp of course
14:58:42 <desrt> so how is that ghc verification coming along, shapr? :)
14:59:02 <Leimy> desrt: hehe :)
14:59:23 <bring> Leimy: the Library Infrastructure Project is working towards that
14:59:33 <Leimy> bring: excellent
14:59:48 * Leimy is having trouble building HaXml on OS X
14:59:52 <Leimy> that's the only reason I ask :)
15:02:56 <shapr> SamB: for some definition of new, 4.2.1 is out
15:03:10 <shapr> april 16th, 2004
15:03:46 <shapr> and they have poly-inline caching working for MacOS X
15:05:07 <shapr> SamB: you use Self?
15:06:51 <desrt> hm
15:06:54 <desrt> c2hs is failing
15:06:56 <desrt> not good
15:13:12 <desrt> oh.  weird.  the build is not thread-safe
15:13:25 <shapr> ?
15:13:32 <desrt> make -j2
15:13:33 <desrt> does not work
15:13:39 <desrt> gotta do just straight up 'make'
15:14:35 <Leimy> yeah... some makefiles create directories to store objects in
15:14:48 <Leimy> and one process will be trying to put an object somewhere that doesn't exist yet
15:15:10 <Leimy> or ... they have some other similar dependency ordering that must be followed
15:15:33 <SamB> shapr: no, but I have played with it.
15:16:51 <desrt> hm.  sf.net down for anyone else?
15:18:02 <Smerdyakov> No. I was browsing the web CVS before I even read your question.
15:18:23 <Smerdyakov> Maybe other parts are down, though.
15:19:55 <shapr> SamB: any idea if I can forward an X window to another box via ssh?
15:22:31 <skew> an X window?
15:23:28 <shapr> Self lets you send an X window to another PC
15:23:42 <desrt> uh
15:23:44 <shapr> so you can collaborate
15:23:49 <desrt> you're trying too hard
15:23:50 <desrt> oh
15:23:52 <desrt> it mirrors it?
15:24:10 <shapr> not exactly, both people get to use it
15:24:11 <desrt> shapr; you want ssh -X
15:24:31 <shapr> it even shows the username next to the other persons cursor
15:24:31 <desrt> ssh -X remotehost xapp
15:24:37 <bring> shapr: sort of like vnc?
15:24:38 <desrt> will run xapp on remotehost and display it to your local display
15:24:39 <SamB> shapr: does it let you pick what display to open a new window in?
15:24:46 <shapr> yes it does
15:24:49 <SamB> or do you mean, ssh in and start self?
15:24:54 <shapr> bring: sort of, yah
15:25:00 <shapr> but better
15:25:19 <shapr> each person has their own window on the large workspace
15:25:19 <bring> and more than normal X forwarding?
15:25:26 <shapr> and you can pick up bits
15:25:43 <shapr> and they can stick to your window if you want
15:25:50 <shapr> or you can share them with others
15:26:08 * bring wants to be able to ssh to a machine and steal a window from the X server on that machine
15:26:28 <shapr> can you believe sun killed Self to do Java? :-/
15:26:37 <Leimy> suicide eh
15:26:38 <Leimy> ?
15:26:40 <SamB> shapr: I imagine you can just tell it the display of the SSH X proxy...
15:26:49 <shapr> at least stupidity imho
15:26:55 <Leimy> well they killed self
15:27:10 <bring> for example, I want to be able to ssh to my home machine and move the xchat window to whatever machine I'm at
15:27:24 <shapr> I think there is a utility to do that
15:27:31 <bring> other than vnc?
15:27:34 <shapr> yes
15:27:45 <eivuokko> That's how multisreening work, right?
15:27:45 <shapr> I saw it in debian recently
15:28:09 <SamB> shapr: evil!
15:28:59 <bring> eivuokko: what's that?
15:29:31 <eivuokko> bring, I mean the normal having multiple monitors with diffrent X on each of them, and window manager moving windows between them.
15:29:31 <shapr> bring: if you let me connect to your X server, I'll send you a Self window :-)
15:29:45 <desrt> don't do it bring :P
15:29:52 * shapr grins
15:29:52 <eivuokko> bring, I recall that being one technique it was done.
15:30:06 <desrt> give him an Xnest
15:30:09 <desrt> it's less hackable
15:30:47 <bring> hmm, guess I should upgrade the kernel 
15:31:02 <shapr> bring: would it work for you to ssh -X into my box and me forward to your $DISPLAY ?
15:31:03 <bring> stupid local priviledge escalation exploits
15:31:22 <bring> probably
15:31:44 <shapr> wanna try it? or are you busy?
15:32:06 <shapr> I wonder if I'm busy
15:32:39 <bring> I'm trying to work up the courage to go to bed, but other than that, no
15:32:43 <shapr> heh
15:33:07 <shapr> well, one quick try...
15:42:16 <shapr> should I be able to send an app to someone who's ssh -X into my box?
15:43:44 <desrt> yes
15:43:49 <desrt> you have to cheat, though
15:43:55 <desrt> you also have to be root
15:44:13 <bring> or the other guys has to give you permission
15:44:26 <desrt> well
15:44:33 <desrt> one way or another you need to get your hands on their Xauthority
15:45:11 <jadrian> hi
15:47:42 <jadrian> when you have some: "newtype New = Con Old", and want to use functions defined on old on new, what do you do? Declare new as instance of Functor and use map?
15:48:57 <Igloo> fmap, and that's one way
15:49:04 <Igloo> Having a type class for them is another
15:49:42 <jadrian> yeap, fmap of course...
15:50:09 <jadrian> Igloo: by type class you mean defining the functions over a class and make both New and Old members of that class?
15:50:31 <Igloo> Yup
15:50:42 <jadrian> ok
15:50:48 <SamB> hehe: "Note: gfoldl is more higher-order than the gmap combinators."
15:51:00 <jadrian> Igloo: that doesn't really work as I might need already defined functions
15:51:01 <SamB> more higher-order ;-)
15:51:29 <jadrian> what is gfoldl? gnu foldl? :)
15:51:29 <shapr> is xhost still the way to allow someone to connect to your X server?
15:51:35 <jadrian> hi shapr!
15:51:39 <shapr> hi jadrian
15:52:02 <Igloo> xhost never was  :-)
15:52:08 <shapr> what is?
15:52:10 <SamB> jadrian: no, it is in Data.Generics[.Basics]
15:52:12 <Igloo> You want some magic with xauth
15:52:26 <jadrian> SamB: ah generic, right! :)
15:52:31 <Igloo> (xhost will do if you're not fussed about the security implications)
15:53:32 <shapr> xhost +user@host ?
15:53:49 <jadrian> Igloo: just think it sounds weird using fmap on newtypes... :-/  "lift" sounds better, but for that I'd need a monadic structure...
15:54:15 <jadrian> but guess that's the way to go...
15:54:16 <Igloo> Dunno about user@
15:54:35 <shapr> how does the xauth work? is it easier? :-)
15:59:15 <Igloo> xhost +host should work AFAIR. xauth requires a little more magic, but you can probably find walkthroughs
15:59:18 * shapr gives up
15:59:21 <Igloo> Oh, is your X server listening on TCP?
15:59:35 <shapr> should be
15:59:57 <Igloo> OK...firewall is the only other potential issue that springs to mind
16:00:11 <shapr> just turned that off entirely
16:00:14 <shapr> didn't fix it
16:01:25 <shapr> where do I check the -tcp ?
16:02:43 <shapr> oh, xinit maybe
16:02:52 <Igloo> "netstat --inet --listen -n | grep 600" should show it listening on port 6000 I think
16:03:40 <Igloo> I have "/etc/X11/xinit/xserverrc:exec /usr/bin/X11/X -dpi 100 -nolisten tcp"
16:04:09 <shapr> I have nolisten commented out
16:04:10 <Igloo> debconf might ask, actually
16:04:18 <Igloo> Ah, OK
16:07:48 <Leimy> I am trying to write "last" using foldr
16:07:56 <Leimy> I can't figure out why this doesn't parse
16:08:09 <Leimy> foldr (/a b -> b) "Hello"
16:08:16 <Riastradh> /?
16:08:22 <Leimy> Lambda?
16:08:47 <Leimy> oops
16:08:48 <Leimy> \
16:08:49 <Leimy> ?
16:10:09 <Leimy> @eval foldr (\a b -> b) "Hello"
16:10:09 <lambdabot> <<EM Dynamic -> EM Dynamic>>
16:13:10 <Riastradh> @type foldr
16:13:12 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
16:13:28 <Riastradh> (Notice that it takes three curried parameters...)
16:13:48 <Leimy> shizzle
16:13:51 <Leimy> :)
16:14:52 <Leimy> @eval foldr (\a b -> b) 'H' "ello"
16:14:52 <lambdabot> H
16:14:55 <Leimy> hmmm
16:15:06 <Leimy> that looks like "first" to me :)
16:16:08 <Leimy> foldl works though :)
16:16:14 <Igloo> It's last
16:16:21 <Igloo> You just tell it what is last first
16:16:58 <Igloo> @eval foldr1 (\a b -> b) "Hello"
16:16:58 <lambdabot> o
16:17:16 <Leimy> neat
16:17:54 <shapr> g'day Pseudonym 
16:17:58 <Pseudonym> G'day.
16:18:21 * Igloo resists the temptation to say hello to kosmikus  :-)
16:20:09 * shapr plays with Self
16:20:17 <Pseudonym> Oooh.
16:20:20 <Leimy> masturbation
16:20:27 <Pseudonym> Obvious joke alert!
16:20:27 <shapr> :-P
16:20:36 <shapr> the language!
16:20:38 <shapr> oy
16:20:39 <Leimy> hehe
16:20:59 <Leimy> I think that language has a loaded name :)
16:21:08 <shapr> yup
16:23:15 <shapr> I still wish I knew how to forward to other local X displays
16:23:36 <Pseudonym> Sorry, you want to move a window that's already open?
16:23:56 <Pseudonym> Or you want to make an alias for a display?
16:24:54 <shapr> er, Self has something that says "forward a window to display"
16:25:06 <shapr> http://gliebe.de/self/screenshot.html
16:25:19 <shapr> g'day stigger 
16:25:27 <shapr> g'bye stigger
16:25:31 <Pseudonym> Oh, I see.
16:25:39 <Pseudonym> Have you looked at xnest?
16:25:51 <shapr> no
16:25:56 <Pseudonym> Or whatever it's called.
16:26:04 <Pseudonym> Xnest
16:26:06 <Pseudonym> That's it.
16:26:38 <Pseudonym> Comes standard with most X installations.
16:27:55 <Pseudonym> BUGS
16:27:55 <Pseudonym>        Wonât run well on servers supporting different  visual  depths.   Still
16:27:55 <Pseudonym>        crashes randomly.  Probably has some memory leaks.
16:28:03 <Pseudonym> That's from the Xnest man page.
16:29:17 <desrt> woh
16:29:20 <desrt> it's the tictactoe freak
16:29:51 <shapr> yes, Pseudonym did the tictactoe IOHCC entry
16:30:03 <desrt> cool hack :)
16:30:08 <Pseudonym> Thanks.
16:30:14 <shapr> speaking of which, I'm looking for jurors
16:30:19 <shapr> Pseudonym: interested?
16:30:24 <Pseudonym> Sure.
16:30:28 <shapr> yay
16:30:29 <desrt> i'll be one :P
16:30:59 <shapr> desrt: dude, you gotta whip up some scary haskell to be considered
16:31:07 <desrt> oh.
16:31:18 <desrt> i didn't know there was a precondition to being a juror :P
16:31:25 <desrt> when is the competition?
16:31:38 <Pseudonym> Unfortunately, I can't enter this time.
16:31:39 <shapr> whenever I get enough jurors
16:31:39 * Pseudonym sighs
16:32:09 <skew> desrt: are you sure you wouldn't think plain ordinary stuff like the continuation monad transformer was all wierd and scary?
16:32:11 <Pseudonym> BTW, kudos to the person who fixes that tic tac toe program to use decent AI/
16:32:11 <shapr> bring said he might wanit to enter, same for Igloo 
16:32:33 <desrt> skew; who the heck knows
16:33:08 <shapr> I think Marvin-- said he'd be a juror
16:33:10 <skew> I think it probably takes a bit of experience to tell ordinary Haskell wierdness from extraordinary Haskell wierdness ;)
16:33:27 <Pseudonym> This is true.
16:33:28 <shapr> Pseudonym: you think three is enough or should I hold out for five?
16:33:35 <Pseudonym> I think three is fine.
16:33:38 <shapr> ok
16:33:40 <Pseudonym> WHo's the third?
16:33:50 <shapr> Marvin-- I think
16:33:53 <Pseudonym> Cool.
16:34:09 <Pseudonym> I really hope someone tries for the "worst abuse of category theory" prize.
16:34:30 <skew>  ooh, I should read more of Pardo's papers
16:34:32 <desrt> woo
16:34:33 * shapr nominates Lor or esap
16:34:37 <desrt> gtk helloworld in haskell
16:34:41 <desrt> this totally rules
16:35:17 <Pseudonym> I think anything which uses GTK would automatically qualify as obfuscated.
16:35:18 <Leimy> the haskell OpenGL stuff is neat too :)
16:35:36 <desrt> i get a Gtk GL Drawing area too :)
16:37:50 <shapr> Pseudonym: oh, I had a cool idea, codecam
16:38:16 <Pseudonym> Codecam?
16:38:31 <Pseudonym> Ohg, you mean for Euro Haskell?
16:38:39 <Pseudonym> Like, a cam showing someone coding.
16:38:44 <Pseudonym> Now here's a thought.
16:38:50 <Pseudonym> Scalable pair programming.
16:38:59 <shapr> hook into the undo stack push for an emacs buffer, mix with htmlixe-buffer and you have a code movie
16:39:04 <Pseudonym> If people get to feed back on what the programmer is doing..
16:39:23 <Pseudonym> Oh, I see.
16:39:24 <Pseudonym> Hmmm.
16:39:31 <Pseudonym> I've done that in vim before.
16:39:38 <Pseudonym> Undo everything, then redo it.
16:39:45 <Pseudonym> Just so I can see my thought processes.
16:39:49 <shapr> yup
16:40:00 <shapr> that's the part you never get from books
16:40:45 <desrt> vim++
16:48:19 <shapr> deego just wrote the beginnings: http://gnufans.net/~deego/emacspub/lisp-mine/undo-browse/dev/undo-browse.el
17:00:15 <shapr> Pseudonym: reading any neat stuff?
17:00:26 <Pseudonym> Started on Asperti and Longo.
17:00:36 <Pseudonym> I think I might ditch this for a moment and read MacLaine instead.
17:01:24 <Pseudonym> Odd.  If you search for "MacLaine categories" on google, you get 16,000 odd links about Shirley MacLaine.
17:01:34 <Pseudonym> didn't know she was into abstract mathematics.
17:02:33 <shapr> heh
17:05:04 <shapr> bwahaha - "Richard Stallman is now less than pleased that he has to work in the Gates Building"
17:05:13 <Pseudonym> I saw that. :-)
17:05:38 <Pseudonym> Oh, I was so pleased with a joke I made on /. this weekend and nobody picked up on it.
17:05:50 <shapr> what was it?
17:05:52 <Pseudonym> Speaking of Richard Stallman.
17:06:00 <Pseudonym> It was about micro broadcasters.
17:06:03 <Pseudonym> The article.
17:06:12 <Pseudonym> And someone mentioned "pirate broadcasts".
17:06:17 <Pseudonym> My response: Don't call it "pirate" unless you believe that unauthorised use of the radio spectrum is ethically equivalent to attacking ships on the high seas, kidnaping and murdering the people on them.
17:06:33 <Riastradh> RMS has to work in that monstrosity of a building?
17:06:39 <Pseudonym> IMG
17:06:41 <Pseudonym> OMG
17:06:43 <Pseudonym> The building.
17:06:47 <Pseudonym> Oh, it could be worse.
17:07:00 <Riastradh> Pseudonym, you don't live in the vicinity; you don't see it every week.
17:07:13 <Pseudonym> I'll show you the building I have to see every day.
17:07:38 <saz> what's wrong with this building??
17:07:54 <Riastradh> saz, have you seen it?
17:08:04 <Pseudonym> http://www.labyrinth.net.au/~lerma/Storey.htm
17:08:11 <Pseudonym> The pictures aren't very good, but you get the idea.
17:08:15 <shapr> it looks like playdough
17:08:47 <shapr> I think I'd like it
17:08:59 <Pseudonym> http://archrecord.construction.com/projects/portfolio/archives/0011auditorium.asp
17:09:00 <saz> oh my
17:09:02 <Pseudonym> There's another shot of it.
17:09:06 <shapr> stata that is
17:09:06 <saz> that's a rather.. interesting building
17:09:08 <Pseudonym> Note that this is only the front.
17:09:08 <saz> where is it?
17:09:23 <Pseudonym> Storey Hall, RMIT University.
17:09:26 <Pseudonym> It's on my way to work.
17:09:33 <saz> ah
17:09:41 <saz> Pseudonym: ooh, another aussie!
17:09:46 <Pseudonym> Yes. :_)
17:09:53 <Pseudonym> There are a few of us around.
17:09:53 <Riastradh> Eh, that's just a small building that was made to be too garish.
17:09:54 <shapr> g'day saz
17:10:08 <Pseudonym> Actually, it's an historical building which was mutilated.
17:10:09 <saz> hey shapr 
17:10:26 <shapr> this just begs for a skateboard - http://www.eecs.mit.edu/images/big-stata23.jpg
17:10:52 <saz> hehehe
17:10:52 <Pseudonym> Hang on, let me find you a picture of lego land.
17:10:54 <Riastradh> shapr, no, it begs for bin Laden.
17:11:04 <shapr> :-P
17:11:07 * Riastradh gets these peculiar urges whenever he passes the building.
17:11:43 <Pseudonym> http://art.fsu.edu/keith/photos/melbourne/part5-city_shots/images/RMIT_city_building.jpg
17:11:50 <Pseudonym> That's just two doors up from Storey Hall.
17:12:00 <Pseudonym> It's referred to as "lego land" for obvious reasons.
17:12:21 <saz> hehehe
17:12:27 <Riastradh> That's definitely nowhere near as bad as the Gates monstrosity.
17:12:34 <saz> *mit people have odd tastes in architecture
17:12:39 <Pseudonym> No, but I think Storey Hall is just as bad.
17:12:47 <Pseudonym> See that historical building on the right of that photo.
17:12:56 <Pseudonym> That's what storey hall is _supposed_ to look like.
17:13:06 <Pseudonym> They added the ugly green and purple thing for... some reason.
17:13:06 <Riastradh> saz, no, some idiots who manage the campus just hired an idiot architect.
17:13:30 <Pseudonym> http://images.google.com.au/imgres?imgurl=art.fsu.edu/keith/photos/melbourne/part5-city_shots/images/RMIT_city_building.jpg&imgrefurl=http://art.fsu.edu/keith/photos/melbourne/part5-city_shots/images/&h=480&w=716&sz=159&tbnid=G31_sqCmVMgJ:&tbnh=92&tbnw=137&start=1&prev=/images%3Fq%3Drmit%2Bbuilding%2B18%26hl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26safe%3Doff%26sa%3DN
17:13:44 <Pseudonym> Sorry,
17:13:45 <saz> tinyurl it!
17:13:50 <Pseudonym> http://art.fsu.edu/keith/photos/melbourne/part5-city_shots/images/RMIT_central.jpg
17:13:52 <saz> or evilurl it :P
17:13:54 <Pseudonym> That's what I wanted to show.
17:14:00 <Pseudonym> That's a view of the whole facade, such as what it is.
17:14:08 <Pseudonym> Complete with trams.
17:14:29 <shapr> looks nifty
17:14:30 <Pseudonym> You can see just how out-of-place legoland and the green-and-purple-thing are.
17:14:51 <saz> it looks.. nutty
17:14:52 <shapr> saz: will we ever get to see the other eye?
17:14:53 <Riastradh> Yes, that's pretty ugly, but I maintain that the Gates monstrosity is worse.
17:15:08 <Pseudonym> Perhaps.
17:15:15 <saz> shapr: sure, come visit unsw
17:15:18 <shapr> ha
17:15:35 <Pseudonym> See, the thing about RMIT is that it's really jarring.
17:15:38 <shapr> probably not soon
17:15:41 <Pseudonym> Not only is it ugly, it's out of place.
17:15:44 <Riastradh> That picture shapr showed you of it is only a fraction of it...and each fraction is different.
17:17:19 <Riastradh> The Gates monstrosity is out of place at MIT, too; MIT has both classical and industrial, and the Gates monstrosity is just the hideous style of architecture.
17:17:47 <Riastradh> You could say that the building at the end of the block, with 'RMIT' in big letters on it, is out of place as well.
17:19:54 <Pseudonym> Well, true.
17:19:57 <saz> every building in that street looks odd
17:20:02 <Pseudonym> Fact is, RMIT has always been pressed for space.
17:20:19 <Pseudonym> There's not much room to expand in any direction but up.
17:21:03 <Pseudonym> http://www.cs.mu.oz.au/~alistair/buildb/dcp02822.jpg
17:21:06 <Pseudonym> That's an odd building.
17:21:08 <saz> i'd hate to study at an innercity campus like that
17:21:15 <saz> it's like UTS but worse
17:21:21 <Pseudonym> That's where the unimelb computer science department is now.
17:21:29 <Pseudonym> saz: RMIT is very similar to UTS in many ways.
17:21:38 <Pseudonym> Thankfully they pay me to turn up here.
17:21:59 <saz> hehe
17:22:30 <saz> i went to UTS at open day when i was in year 12
17:22:42 <saz> and made up my mind there and then that it wasn't going on my preferences list
17:23:00 <Pseudonym> Actually, the Gates building looks like it's in the process of falling over.
17:23:10 <Riastradh> I would that it were.
17:23:28 <saz> it looks likes it randomly assembled in an odd way
17:23:32 <saz> someones gone
17:23:38 <saz> blat. window there
17:23:54 <Pseudonym> It looks like a bad Swedish clay animation.
17:24:08 <Pseudonym> No offense to any Swedes present.
17:24:28 <Pseudonym> But Sweden's children's clay animation is crap.
17:27:50 * Riastradh wonders how much it would cost to assassinate Frank Gehry.
17:28:04 * Pseudonym wonders what good it would do now
17:28:34 <Riastradh> Well, it would stop him from further desecrating the surface of Earth.
17:28:45 <Pseudonym> Not all of his stuff is bad.
17:28:55 <Pseudonym> He designed the Hollywood Bowl, which isn't too bad.
17:29:10 <Pseudonym> It's very 70s, but still.
17:30:12 <Riastradh> I have yet to see a building of his that I don't feel like puking at the sight of.
17:33:44 <Riastradh> http://web.mit.edu/evolving/stata/photos/hires/002690.jpg <- That's the best image I can find so far of it.
17:34:11 <Pseudonym> I think most of his buildings are fairly inoffensive.
17:34:14 <skew>   wow, that building does look like it's falling down
17:34:16 <Riastradh> Now imagine that almost across the street from the little dome.
17:34:27 <Pseudonym> Not fabulous, but not offensive either.
17:34:29 <Riastradh> (well, it's a little farther than that, I guess)
17:34:45 <Riastradh> I also had to endure seeing it built.
17:34:57 <Riastradh> I'm not sure whether it was worse while being built or after being built.
17:35:09 <skew> It looks like a respectable building in the middle of a serious earthquake
17:35:22 <Riastradh> But it was a different kind of 'hideous' while being built.
17:37:45 <Pseudonym> Now here's something odd.
17:37:49 <Pseudonym> http://www.dcm-group.com/PROJECTS/7-Mel/94703/94703_02_S.jpg
17:38:04 <Pseudonym> This very, very narrowly escaped being a complete travesty.
17:38:23 <skew> that looks very odd
17:38:25 <Pseudonym> The building on the right is very ugly, though not in the same league as Strata.,
17:38:37 <Pseudonym> The thing on the left, though, is the last Victorian exhibition hall left in the world.
17:38:49 <skew> like a dragonfly regarding the old building
17:38:53 <Pseudonym> Right.
17:38:56 <shapr> yah
17:39:08 <Pseudonym> They very narrowly escaped damaging the historical landmark on the left.
17:39:20 <Pseudonym> You will note the late 90s fetish for "blades".
17:39:28 <Pseudonym> I don't know what that was about.
17:39:30 <Pseudonym> Everything was blades.
17:40:04 <shapr> too many vampire movies?
17:40:22 <Pseudonym> I only know of one vampire movie filmed in Melbourne, and it was AWFUL.
17:40:32 <Pseudonym> I dare not speak its name.
17:40:36 <shapr> speaking of which, how's Road Warrior viewed inside .au? as good film or bad?
17:40:50 <Pseudonym> First off, it was called Mad Max here.
17:41:02 <Riastradh> That's a different film.
17:41:08 <shapr> ok, the whole trilogy
17:41:21 <Pseudonym> They were called Mad Max, Mad Max 2 and Max Max 3.
17:41:28 <Riastradh> ...oh, how lame.
17:41:33 <Pseudonym> Mad Max 3, not Max Max 3
17:41:41 <Pseudonym> Anyway.
17:41:49 <Pseudonym> You have to understand Australian cinema as it was as the time.
17:41:55 <shapr> I own maybe eight films, and three of them are the mad max series
17:41:55 <Pseudonym> We were going through a bad patch.
17:42:04 <Pseudonym> It's now known as the "cultural cringe".
17:42:05 <shapr> I rather like them
17:42:25 <Pseudonym> Yes, the Mad Max films were some of the best movies we made at the time.
17:42:42 <Pseudonym> You have to understand that all of the others were truly cringeworthy, and it wasn't entirely our fault.
17:43:04 <Pseudonym> See, Australians were trying to work out who they were.
17:43:12 <Pseudonym> We weren't British any more, we knew that much.
17:43:44 <Pseudonym> And so all of these cringeworthy movies came out dealing with Australian history and Australians being very Australian.
17:44:18 <shapr> I think it's turned out quite well
17:44:30 <Pseudonym> The Mad Max movies were rare exceptions, and I think they're regarded as such today.
17:44:43 <Pseudonym> saz: Would you agree?
17:45:03 <shapr> though I'd like to visit to soak up more aussie culture
17:45:34 <Pseudonym> The Crocodile Dundee films are an example of a film about Australians being very Australian, though that's one of the better ones.
17:45:40 <Pseudonym> Well, the first one was, anyway.
17:46:36 <Pseudonym> See, the problem was that Australia was trying to find its own culture, but they were looking in the wrong place.
17:47:08 <Pseudonym> They were looking at what made Australians different, but you really can't understand Australia just by looking at that.
17:47:40 <shapr> though the wide open spaces are a defining characteristic, imho
17:48:11 <Pseudonym> Oh, definitely.
17:48:31 <Pseudonym> But you have to realise that most Australians don't live in wide open spaces by definition.
17:49:25 <shapr> right
17:49:41 <Pseudonym> It's fairly alien to most people here, except when they have to fly over it or drive through it on their way from place to place.
17:50:07 <saz> Pseudonym: sorry, afk
17:50:10 <shapr> like the USA
17:50:11 <saz> strata suck sooo much
17:50:14 <Pseudonym> And that's one of the key things to understanding Australian culture: Our cultural symbols are actually completely foreign to most people.
17:50:33 <saz> hehe
17:50:43 <Pseudonym> And we're okay with that.
17:50:47 <shapr> in the US, people take vacations to see culture
17:51:05 <Pseudonym> We're okay with someone else's flag on ours, with someone else's head of state on our currency, with a national anthem which nobody knows the words to.
17:51:25 <shapr> I'm sort of surprised .au hasn't come up with long distance WiFi
17:51:28 <saz> Pseudonym: you mean australians aren't all ostriches?
17:51:37 <saz> ;)
17:51:40 <Pseudonym> :-)
17:52:21 <Pseudonym> And despite a beach culture in many places, we're yet to see the sea "girt".
17:52:37 <saz> hehe
17:52:58 <saz> i haven't been to the beach for a long long time
17:53:04 <saz> and i'm fairly close to it
17:53:24 <Pseudonym> :-)
17:53:48 <shapr> I like sun and ocean
17:53:49 <Pseudonym> I don't really get the beach culture, but then, I'm from Melbourne.
17:55:54 <Pseudonym> shapr: Well, here's a rough guide for you.
17:56:09 <Pseudonym> Sydney is like California and south Queensland is like Florida.
17:56:18 <Pseudonym> wrt sun and ocean
17:56:30 <Pseudonym> That may or may not help you decide where you want to visit.
17:56:44 <shapr> but, unsw has Haskellers
17:56:53 <Pseudonym> So does Unimelb.
17:56:56 <shapr> hm
17:57:08 <Pseudonym> Though they have recently dumped Haskell as their first year language.
17:57:13 <Pseudonym> Thank you, Alistair Moffat.
17:57:14 <shapr> I could visit both
17:57:17 <saz> Pseudonym: oh, why??
17:57:27 <Pseudonym> No clue.
17:57:29 <shapr> anyway, I told mwotton I'd visit him
17:57:31 <saz> visit UNSW!
17:57:46 <Pseudonym> shapr: You need to try John Shepherd's home brew.
17:58:08 <Pseudonym> Or so I'm told.
17:58:12 <shapr> ok :-)
17:58:39 <Pseudonym> He's the one who introduced Haskell to Unimelb, only to leave for UNSW a couple of years later.
18:05:38 <shapr> http://pragprog.com/pragdave/Practices/Kata 
18:06:05 <shapr> seen it?
18:06:32 <Pseudonym> Unfortunately, proxy is down at the moment.  Can't web out.
18:07:16 <Pseudonym>  Bill Gates says the freakish buildings and twisted angles will be correctly aligned by the upcoming Stata Service Pack 1.
18:07:17 <shapr> it's one of the pragmatic programmers
18:07:21 <shapr> oy
18:07:25 <shapr> that war evil
18:07:57 <Leimy> I think I am having a fundamental misunderstanding of foldr1 or something here...
18:08:11 <Leimy> I am trying to write "init" with foldr and having 0 luck
18:09:58 <Pseudonym> @eval foldr1 (\a b -> b) "Hello"
18:09:59 <lambdabot> o
18:10:06 <Pseudonym> That's what Igloo wrote earlier.
18:10:15 <Leimy> that's last :)
18:10:17 <Pseudonym> It's kind of the opposite of init.
18:10:22 <Pseudonym> Yes.
18:10:28 <Pseudonym> But it's a start.
18:10:40 <Leimy> yep... I've beenthere for about 1 hour
18:10:42 <Leimy> at the start :)
18:11:04 <Leimy> no clue what the parameters to the "helper" function should be
18:18:13 <Pseudonym> Oh, that'a a good point.
18:18:32 <Pseudonym> Gehry and Tim Burton should team up on a film project.
18:21:04 <Riastradh> How bad has Tim Burton gotten in the past few years?  I've ignored him since the mid-'90s, before which his films were great.
18:21:17 <Pseudonym> Not bad, just weird.,
18:21:29 <Pseudonym> Gehry's buildings look like they're out of a Burton film.
18:21:52 <Riastradh> The only film I remember him doing in the past few years (well, for some large value of 'few') is _Mars Attacks_, which wasn't 'weird,' just bad.
18:22:10 <Pseudonym> I'm thinking more like Beetlejuice or The Nightmare Before Christmas.
18:22:29 <Riastradh> Those were what I was referring to before I stopped paying attention to him.
18:22:48 <Pseudonym> Don't you think a Gehry building would look in place in one of those films?
18:22:56 <Riastradh> Definitely not.
18:24:42 <Riastradh> Gehry buildings make it far beyond the 'crazily great' scenes of Tim Burton's films.
18:24:52 <Riastradh> ...where 'far beyond' means 'over the edge,' losing the 'great' bit.'
18:25:06 * Riastradh kicks his apostrophe key for being so close to the return key.
18:25:10 <Riastradh> '[';'
18:28:46 <Leimy> oh well still can't figure it out
18:29:39 * shapr swears at net problems
18:33:05 * Leimy swears at Haskell
18:33:19 <Riastradh> Leimy, what can't you figure out?
18:33:30 <Leimy> iter using foldr or foldr1
18:33:34 <Leimy> oops not iter
18:33:36 <Leimy> init
18:33:40 <Riastradh> @type init
18:33:41 <lambdabot> init :: forall a. [a] -> [a]
18:34:02 <Riastradh> What does init do?
18:34:11 <Leimy> init "Poop" = "Poo"
18:34:23 <Leimy> drops the last non-empty thing
18:37:07 <k> have anyone done the filterLast function?
18:37:33 <Riastradh> Leimy, what's the state you have to keep track of?
18:38:01 <Leimy> I don't understand the question as it pertains to my problem
18:38:16 <Riastradh> Leimy, when generating the resulting list, what state is there?
18:38:28 <k> i am thinking of using the last function, am i on the right track?
18:38:31 <Leimy> everything but the last item
18:38:41 <Riastradh> No, that's what the resulting list is.
18:38:47 <Riastradh> But what state do you keep track of in the iteration?
18:38:54 <Leimy> I don't keep track of any state
18:39:44 <Riastradh> No?
18:39:49 <Leimy> don't think so
18:40:02 <Leimy> foldr stops at end of list
18:40:07 <Leimy> well foldr1
18:40:30 <Leimy> and I just want a function to provide to foldr that builds the list and drops the last item from the original
18:40:33 <shapr> nifty, patrick logan mentioned HaskellDB on his blog: http://patricklogan.blogspot.com/
18:40:44 <Leimy> I have no idea why that would include any extra state to keep track of
18:40:45 <Riastradh> Leimy, first of all, how would you use foldr to copy a list?
18:41:09 <Leimy> I probably wouldn't :)
18:41:26 <Riastradh> How would you do it?
18:41:44 <Leimy> no idea... I am not "Using" haskell... I am just learning it
18:41:51 <Leimy> therefore all of my experience is 100% impractical
18:42:52 <Leimy> copy list = list
18:42:56 <Leimy> or something
18:42:58 <Riastradh> Er, no.
18:43:17 <Riastradh> OK, how would you implement map in terms of foldr?
18:44:07 <k> i think i can use init filterFirst, but how do i implement it to my function?
18:44:52 <Leimy> myCopy [] = []
18:44:53 <Leimy> myCopy (x:xs) = x : myCopy xs ???
18:45:25 <shapr> filterLast ?
18:45:26 <Riastradh> Leimy, no, you have to use foldr.
18:45:36 <Leimy> you asked how *I* would copy it :)
18:45:47 <Riastradh> ...using foldr, foo!
18:46:01 <Leimy> s/foo!/fool!/
18:46:20 <Riastradh> No, if I meant 'fool' instead of 'foo,' I'd have said 'knave' in the first place.
18:46:24 <k> shapr: yes
18:46:27 <Leimy> heh
18:46:39 <Riastradh> So, using foldr, how would you copy a list?
18:46:47 <Leimy> Riastradh: and that's my question
18:46:58 <Leimy> what are the parameters to the function foldr takes?
18:47:09 <Riastradh> @type foldr
18:47:10 <Leimy> I haven't been able to match them a single time except for stupid crap like +
18:47:10 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
18:47:17 <Leimy> yeah I've been looking at that
18:47:21 <Leimy> I even wrote foldr
18:47:21 <Riastradh> foldr f seed list
18:47:38 <Riastradh> f element currentSeed -> newSeed
18:48:37 <shapr> k: are you and Leimy doing a school assignment or something?
18:48:46 <Riastradh> foldr (+) 0 [1,2,3,4] --> 0 + (1 + (2 + (3 + 4)))
18:48:46 <Leimy> hahahahah!
18:48:47 <Leimy> as if
18:48:54 <Leimy> I am supposed to be doing this for fun :)
18:48:59 <shapr> ok
18:49:15 <Leimy> Riastradh: yeah... done that before too
18:49:16 <Riastradh> Leimy, does foldr's operation make somewhat more sense with my last three messages, using more descriptive variable names?
18:49:23 <k> honestly, yes. but got stuck on the question.
18:49:36 <shapr> I was just wondering, since you seem to have this problem in common
18:49:39 <Leimy> Riastradh: not when it comes to this particular problem
18:49:43 <Leimy> foldr doesn't "build a list"
18:49:46 <Leimy> it reduces one
18:49:56 <Leimy> and I haven't figure out how to build anything with foldr
18:49:56 <shapr> it's a cata
18:50:01 <Riastradh> Correct.  But in order to copy a list, you want to build it while reducing it.
18:50:16 <ozone> what are you trying to do?
18:50:17 <Leimy> so what are the parameters to a building function for foldr?
18:50:40 <Pseudonym> foldr (+) 0 [1,2,3,4] --> 1 + (2 + (3 + (4 + 0)))
18:50:45 <Pseudonym> The 0 is on the right.
18:50:47 <Pseudonym> That's important.
18:50:50 <Riastradh> ...er, right, sorry.
18:50:54 <Pseudonym> Another way to look at it is this:
18:51:10 <Leimy> foldr (foo) [] ?
18:51:13 <Pseudonym> foldr (+) 0 (1:(2:(3:(4:[])))) --> (1+(2+(3+(4+0))))
18:51:30 <Pseudonym> The colons get replaced by +'s and the [] gets replaced by 0.
18:52:00 <Leimy> well ... I think one of my problems was using "foldr1"
18:52:11 <Riastradh> @type foldr1
18:52:12 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
18:52:16 <Riastradh> foldr1 isn't what you want to use here.
18:52:19 <Leimy> nope
18:52:50 <shapr> hi k, are you new to Haskell?
18:53:01 <k> shapr: yes.
18:53:08 <shapr> welcome!
18:53:33 <shapr> lots of nifty tricks await you
18:53:37 <k> shapr: i am just stuck on a question. i want to pull the first element from a list, should i use foldr or init? 
18:53:49 <shapr> what about head ?
18:54:01 <k> shapr: i am using thompson's book.
18:54:04 <Riastradh> Leimy, if you want to copy a list, what do you want to use instead of + and 0?
18:54:21 <shapr> oh, you haven't reached head yet?
18:54:26 <Riastradh> (think about what Pseudonym showed above)
18:54:44 <Leimy> no idea
18:54:44 <shapr> you could do init till there's nothing left
18:54:47 <Leimy> I tried ++ and []
18:54:49 <Leimy> no avail
18:55:03 <Leimy> though : works
18:55:08 <Riastradh> Leimy, given [1,2,3], or (1:(2:(3:[]))), what would a copy of that list be?
18:55:19 <Leimy> foldr (:) [] "Pain in the ass"
18:55:22 <Leimy> heh
18:55:54 <Riastradh> Leimy, OK, good.  Now, instead of copying the _entire_ list, you want to copy all but the last element.
18:56:05 <Leimy> so : isn't useful there
18:56:09 <Riastradh> Sure it is.
18:56:17 <Leimy> in the helper function maybe
18:56:21 <Leimy> but not as is
18:56:24 <Riastradh> Right.
18:56:44 <Leimy> so does the helper function take a parameter of some kind and a list of that kind?
18:56:52 <Leimy> this is where I am mostly stuck anyway
18:57:20 <Riastradh> Suppose we have a function f and an initial seed x such that (f 1 (f 2 (f 3 x))) returns [1,2].
18:58:58 <shapr> hi jesse, looking for haskell info?
18:59:22 <Riastradh> Hmmm, I can't really think of a better question than 'what is this function and this value?'
19:02:42 <Riastradh> (Hint: something about the seed that f returns after the seed is x will remain the same until the end.)
19:04:17 <Leimy> nope still don't get it
19:04:22 <Leimy> it just returns [] for every list now :)
19:04:42 <Riastradh> Er, wait.
19:04:54 <Riastradh> (f 1 ...) doesn't return [1,2]; it returns a value that contains [1,2], rather.
19:05:04 <[dan]> Riastradh: Nice explanation, I'd been wondering about the same sort of thing reading a haskell tutorial earlier.
19:05:53 <Riastradh> Leimy, and one more hint before I have to leave: Maybe.
19:06:21 <Leimy> Maybe isn't even in this book yet so I doubt that's a prerequisite :)
19:07:05 * shapr falls over asleep
19:07:30 <Pseudonym> Night.,
19:15:52 <Leimy> nope ... still don't got it :)
19:27:34 * Leimy wonders if this has a definite solution
19:29:29 <Leimy> foldr (foo) [] "Hello"
19:29:39 <Leimy> foo x xs 
19:29:40 <Leimy>     | length xs > 1 = x : xs
19:29:40 <Leimy>     | otherwise = [x]
19:29:46 <Leimy> the otherwise is just wrong
19:37:14 <ne1> foldr (:) "" "Hello"
19:37:56 <Leimy> I want all but the last char
19:38:05 <Leimy> haven't figured out what foo has to be to do that
19:39:07 * [dan] is working on the same problem and staring blankly at it.
19:40:32 <Leimy> yeah
19:40:32 <ne1> The bottomline is: foldr satisfies these two equations: foldr foo bar [] = bar, foldr foo bar (x:xs) = foo x (foldr foo bar xs).
19:40:50 <Leimy> I understood 0 of that :)
19:41:23 <ne1> "foldr foo bar []" evaluates to bar, agree or disagree?
19:41:39 <Leimy> sure
19:41:44 <Leimy> ah... it's my stupid IRC client
19:41:46 <Leimy> it added a +
19:41:51 <Leimy> for line continuation
19:41:54 <ne1> Ok good.
19:42:35 <ne1> So whatever you want to do, you recast your job so that it looks like those two equations; then you know what foo and bar should be.
19:42:50 <Leimy> yeah
19:43:15 <Leimy> still don't know what foo is :)
19:43:38 <Leimy> or maybe I don't know what bar is
19:43:42 <Leimy> and I have foo
19:44:50 <[dan]> ne1: the problem I'm running into with dropping the last character is for the last character, foo is being called as foo c [], and I want that to be the empty string. But if foo x [] = [], then it will delete every character, not just the last one
19:45:03 <Leimy> yep
19:45:10 <Leimy> I've been doing that same thing about 50 different ways
19:45:14 <Leimy> and not found a way out of it
19:45:27 <Leimy> what seems like it should just be the innermost value is the outermost
19:45:54 <Leimy> if you look at it as  (1:(2:(3:[])))
19:45:59 * desrt attempts to clone a program made by someone at his school
19:46:35 <[dan]> What seems like it would work might be calling foldr foo bar start, where start is something other than [] that won't be found in the string, and then foo x start = []
19:47:13 <Leimy> [dan]: I think you haev your parameters backwards
19:47:30 <Leimy> its foldr func seed list
19:47:31 <[dan]> Leimy: ahh, yeah, foo start bar
19:48:12 <Leimy> [dan] problem is whatever start is has to be a list :)
19:48:23 <Leimy> since its the last parameter
19:48:50 <[dan]> Right
19:49:08 <Leimy> just like it had to be [] to make foldr do a copy
19:49:43 <Leimy> you can think of the "start" as the last parameter to be passed as the second parameter to foo
19:49:48 <Leimy> but that's not helping me either
19:50:30 <Leimy> damnit
19:50:33 <Leimy> try this
19:50:40 <Leimy> foo x "0" = []
19:50:40 <Leimy> foo x xs =  x : xs
19:50:50 <Leimy> foldr (foo) "0" "Hello"
19:50:57 <Leimy> that works but
19:51:02 <Leimy> foo x [] = []
19:51:07 <Leimy> foo x xs = x:xs
19:51:09 <Leimy> does not
19:51:19 <Leimy> and that's what I've been fighting with for the last friggin 2 hours
19:51:44 <Leimy> maybe it should be
19:51:52 <Leimy> hmmm
19:51:54 <Leimy> foo x _
19:52:28 <Leimy> npoe
19:52:29 <Leimy> er nope
19:52:33 <Leimy> that matches everything
19:54:28 <desrt> quicky
19:54:35 <desrt> how do i deference into a complex type?
19:54:39 <desrt> *dereference
19:54:47 <desrt> like... request a member, i guess is the generic term
19:59:59 <ne1> I begin to think it is not possible.
20:00:17 <Leimy> ne1: what is not possible?
20:00:42 <ne1> Using only foldr to drop the last item.
20:00:43 <desrt> oh.  odd
20:00:46 <desrt> you have to pattern-match it
20:00:51 <Leimy> well I did...
20:00:56 <Leimy> but I had to have a sentry value
20:01:37 <Leimy> primitive recursion is just more general than foldr
20:01:42 <Leimy> and I think therein lies the rub
20:01:48 <ne1> Yes.
20:02:04 <Leimy> perhaps there is errata for this book :)
20:02:32 <Riastradh> Leimy, continue with the
20:02:35 <Riastradh> foo x "0" = []
20:02:37 <Riastradh> foo x xs = x : xs
20:02:39 <Riastradh> thought.
20:02:52 <Leimy> that is an answer
20:02:56 <Leimy> but is there something more general
20:02:57 <Leimy> ?
20:03:08 <Leimy> as I said
20:03:13 <Leimy> foo x [] = []  
20:03:14 <Leimy> doesn't work
20:04:26 <Leimy> could that be a bug in ghci?
20:04:34 <Riastradh> How are you running foldr with that foo?
20:04:42 <[dan]> Nah, foo x [] = [] not working is expected :)
20:04:42 <Leimy> it's incomplete
20:04:50 <Leimy> foo x [] = []
20:04:52 <ne1> The pair head-tail and therefore the pair init-last (we are doing init) are final-coalgebra things, whereas foldr is an initial-algebra thing. It is expected that they don't match well.
20:04:56 <Leimy> foo x xs = x : xs
20:05:25 <Riastradh> ...sorry, duh.  What does foo 'o' [] give you?
20:05:47 <Leimy> doesn't that give you []
20:05:51 <Leimy> ?
20:05:58 <Riastradh> So then what does foo 'l' [] give you?
20:06:05 <Leimy> []
20:06:07 <Leimy> I see
20:06:15 <Leimy> so it's not a bug in ghci
20:06:16 <Leimy> :)
20:06:42 <Riastradh> Indeed.  I, however, am starting to get bugs in my brain if I don't go to bed soon...
20:07:08 <Smerdyakov> Your brain IS a bug! HAHA
20:07:32 <Leimy> so is there a "good" answer? :)
20:07:39 <Riastradh> I'd say something witty in response to that stupid message, but I'm too tired to think of something.
20:08:18 <Leimy> I have a crappy answer
20:10:57 * SamB finds out what forall is for
20:11:36 <desrt> it's a quantifier
20:11:52 <ne1> forall is for all of us.
20:12:41 * Riastradh wanders off to bed.
20:13:38 <ne1> Seriously, when you say init has type "[a] -> [a]", you really mean "forall a. [a] -> [a]".
20:15:05 <SamB> nel: I mean, I found out what explicit forall is for
20:15:26 <ne1> Oh haha, alright then.
20:16:24 <SamB> implicit forall is something I might like to have GHCi not display ;-)
20:28:23 <Leimy> [dan]: did you get an answer for unzip via foldr? :)
20:29:34 <[dan]> Leimy: hrm?
20:29:40 <Leimy> oh
20:29:48 <Leimy> I thought you were going through the same book :)
20:30:07 <[dan]> nope, just saw you state the problem on the channel originally, and thought it'd be a learning exercise for me as well
20:30:21 <Leimy> wll that's another one
20:30:22 <Leimy> :)
20:32:01 <[dan]> Leimy: which book are you going through, by the way?
20:32:26 <Leimy> Simon Thompson's
20:32:41 <Leimy> "Haskell The Craft of Functional Programming"
20:32:57 <[dan]> Decent book? Been looking for a haskell book myself
20:33:23 <Leimy> well except for not really explaining some things well enough for me to do the exercises it's pretty good :)
20:33:32 <Leimy> and that's not true for all exercises
20:33:36 <Leimy> they do make you think though
20:33:45 <Leimy> I'd give it a good rating
20:34:16 <[dan]> Leimy: ok
20:38:34 <SamB> parsec is cool
20:39:27 <Cale> Indeed
20:40:35 <SamB> parsec made it pretty easy to parse bf, when my brain (and probably my code) would otherwise be twisted into a pretzel trying to figure out how to do it
21:00:40 <desrt> how do i do an imperative statement for each element of a list?
21:01:06 <desrt> map isn't gonna cut it :)
21:01:30 <Leimy> ???
21:01:35 <Leimy> imperative statement?
21:01:39 <desrt> do
21:01:42 <seafood> desrt: mapM might though.
21:02:02 <Leimy> map Monad?
21:02:06 * Leimy takes a guess
21:02:15 <seafood> Leimy: Yeah.
21:02:19 <Leimy> WOOT!
21:02:20 <SamB> is there some kind of fold of seq?
21:02:42 <SamB> er, no,.
21:02:50 <SamB> fold of >>?
21:02:50 <desrt> well...
21:02:56 <desrt> mapM did *exactly* what i wanted
21:03:00 <desrt> now.. why? :)
21:03:13 <desrt> actually.. i don't even care
21:03:20 <seafood> (a -> m b) -> [a] -> m [b]
21:03:26 <seafood> mapM :: (a -> m b) -> [a] -> m [b]
21:03:49 <seafood> desrt: Of course you care.  Tell me what you wanted it to do.
21:03:52 <SamB> mapM f as       =  sequence (map f as)
21:04:02 <desrt> i'm out-nerding someone
21:04:03 <desrt> :)
21:04:18 <SamB> sequence ms = foldr k (return []) ms
21:04:19 <SamB> 	    where
21:04:19 <SamB> 	      k m m' = do { x <- m; xs <- m'; return (x:xs) }
21:04:47 <SamB> sequence       :: Monad m => [m a] -> m [a] 
21:04:53 <ne1> sequence, sequence_, foldM
21:05:13 <SamB> nel: don't forget foldM_!
21:05:23 <SamB> oh.no.
21:05:41 <SamB> I think my brain has had a cooling failure
21:06:03 <SamB> hrrm, there is at least a foldM_
21:06:46 <Leimy> foo p [] = ((fst p) : [], (snd p) :[])
21:06:47 <Leimy> foo p (x:xs) = ((fst p) : (fst x):[],(snd p) : (snd x):[])
21:07:03 <Leimy> foldr (foo) [] [(1,2),(3,4)]
21:07:09 <Leimy> trying to unzip :)
21:07:15 <Leimy> with foldr
21:08:13 <SamB> Leimy: that is... erm... interesting. I don't like playing that kind of a game... it is very twisty!
21:08:13 <Leimy> unsuccessfully
21:08:23 <Leimy> SamB: no kidding
21:08:27 <Leimy> I have my own unzip I wrote
21:08:35 <Leimy> myunzip :: [(Int,Int)] -> ([Int], [Int])
21:08:36 <Leimy> myunzip [] = ([],[])
21:08:36 <Leimy> myunzip (x:xs) = ((fst x):(fst (myunzip xs)), (snd x):(snd (myunzip xs)))
21:08:42 <Leimy> but not with foldr
21:08:53 <Leimy> and just for Int :)
21:08:59 <SamB> Leimy: does it resemple the expansion of foldr in any way, shape, or form?
21:09:20 <SamB> also, you can just scrap the typing, and it will be general
21:09:27 <Leimy> SamB: yeah I know
21:09:30 <Leimy> I was experimenting
21:09:38 <Leimy> and left it in the code
21:09:40 <SamB> hehe
21:09:46 <Leimy> D'oh
21:09:50 <Leimy> then blind cut n paste
21:10:37 <Leimy> as far as it resembling the operation of foldr... "kinda"
21:10:58 <SamB> from GHC.Base:
21:10:59 <SamB> foldr k z xs = go xs
21:10:59 <SamB> 	     where
21:10:59 <SamB> 	       go []     = z
21:10:59 <SamB> 	       go (y:ys) = y `k` go ys
21:11:00 <Leimy> My problem is figuring out how to make it work like a binary function instead of unary
21:11:35 <Leimy> yeah
21:11:38 <Leimy> pretty simple def
21:11:55 <Leimy> so k or foo in my case needs to be a binary function
21:12:29 <Leimy> which is what I was trying to achieve:
21:12:36 <Leimy> foo p [] = ((fst p) : [], (snd p) :[])
21:12:36 <Leimy> foo p (x:xs) = ((fst p) : (fst x):[],(snd p) : (snd x):[])
21:12:37 <SamB> z = ([], [])
21:12:47 <Leimy> hmmm
21:12:50 <Leimy> that's why!
21:12:51 <Leimy> doh!
21:13:08 <Leimy> pair of empty lists?
21:13:19 <SamB> I'm just starting at the simplest part ;-)
21:13:26 <Leimy> yeah
21:13:35 <Leimy> the input won't be a pair of empty lists
21:13:39 <Leimy> it will be a list of empty pairs
21:13:42 <Leimy> or an empty list
21:14:04 <Leimy> when it's zipped it it's ([],[])
21:14:18 <Leimy> er no
21:14:21 <Leimy> damned beer
21:14:25 <SamB> Leimy: the [] doesn't get zipped!
21:14:45 <Leimy> you zip 2 lists
21:14:49 <Leimy> and it produces a list of pairs
21:15:04 <Leimy> so the z should be a list of empty pairs shouldn't it?
21:15:22 <Leimy> or just an empty list?
21:15:46 <Leimy> the inputs for the helper function can't change so it has to be the same as a zipped structure
21:15:48 <SamB> Leimy: a pair of empty lists, since the output is in pairs.
21:16:03 <Leimy> so the function is not applied to z?
21:16:08 <Leimy> I don't think that's right
21:16:35 <SamB> z is used when foldr reaches the tail, as you can see.
21:16:42 <Leimy> right
21:16:55 <Leimy> and then it recurses and the function is applied with z as the 2nd argument
21:16:58 <Leimy> or parameter
21:17:00 <Leimy> or whatever :)
21:17:14 <Leimy> well the recursion unwinds
21:17:21 <Leimy> and that becomes the first step
21:17:32 <Leimy> that's why we couldn't easily do init with foldr
21:19:34 <ne1> Let a value z and a function g be given.  Consider the simultaneous equation in f:  f [] = z, f (x:xs) = g x (f xs).
21:20:16 <SamB> k = \(x, y) (xs, ys) -> (x:xs, y:ys)
21:20:18 <ne1> 1. A solution is f = foldr g z.  2. That is pretty much the unique solution up to equivalence.
21:20:47 <SamB> Leimy: I hope this wasn't homework ;-)
21:22:02 <SamB> it was actually not as bad as I would have expected
21:22:12 <Leimy> its not
21:22:23 <Leimy> SamB: did you just do unzip?
21:22:31 <Leimy> yes... 
21:22:38 <Leimy> I just looked away for a bit :)
21:22:41 <SamB> yes, I tested it too ;-)
21:24:13 <Leimy> hmmm parse error :)
21:24:25 <Leimy> I think you need ->
21:24:34 <Leimy> oh shit
21:24:35 <ne1> Yes I see ->
21:24:36 <SamB> Leimy: put parens around the lambda
21:24:36 <Leimy> I can't read :)
21:24:45 <Leimy> nope that's not the problem
21:25:09 <SamB> otherwise, it would extend all the way to the right...
21:25:45 <SamB> *Bf> foldr (\(x, y) (xs, ys) -> (x:xs, y:ys)) ([], []) [(1, 2), (3, 4)]
21:25:46 <SamB> ([1,3],[2,4])
21:27:08 <Leimy> I'm not going to pretend I understand the lambda function :)
21:27:54 <SamB> k (x, y) (xs, ys) = (x:xs, y:ys)
21:28:42 <Leimy> foo p ([],[]) = ((fst p) : [], (snd p) :[])
21:28:42 <Leimy> foo p (x:xs) = ((fst p) : (fst x):[],(snd p) : (snd x):[])
21:29:17 <Leimy> that's as far as I got before I crashed
21:29:22 <ne1> Why do ([],[]) and (x:xs) have differnt types?
21:29:43 <Leimy> I don't know why SamB's works
21:29:55 <Leimy> I was under the assumption that you needed a function with the same input types
21:30:22 <Leimy> since what I am unzipping is already zipped I'd expect to see a list of pairs come in
21:30:24 <Leimy> not a pair of lists
21:30:35 <SamB> foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b
21:30:51 <SamB> unzip    :: [(a,b)] -> ([a],[b])
21:31:01 <Leimy> so I've looked at the type of foldr for like... all evening
21:31:23 <Leimy> it doesn't mean any mor to me now than it did 2 hours before
21:31:26 <ne1> No you don't look. You instantiate with a million examples.
21:32:21 <Leimy> SamB: that's what I mean... the input is a list of pairs
21:32:27 <Leimy> the output is a pair of lists.
21:32:50 <Leimy> so the last value has to be the "pre-transformed" type of the empty form?
21:32:52 <SamB> okay. lets make this a little easier...
21:33:18 <Leimy> ne1: well fuck me for trying
21:33:40 <SamB> (foldr,unzip) :: ((a -> b -> b) -> b -> [a] -> b,[(c,d)] -> ([c],[d]))
21:33:57 <desrt> can i convert frm an int to a float (or whatever?)
21:34:03 <desrt> it doesn't appear to want to go implicitly
21:34:06 <desrt> damn typing :P
21:34:07 <ne1> No! I am suggesting you to instantiate with a million examples! I am not blaming anyone!
21:34:20 <Leimy> it reads many ways :)
21:34:21 <Leimy> hehe
21:34:35 <SamB> nel: I also read it the wrong way!
21:34:52 <SamB> okay, I will split that...
21:35:33 <Leimy> hmmm
21:35:47 <Leimy> I think my main problem is I am not learning this with any other people who are also learning
21:35:59 <Leimy> and a lot of times people throw explanations at me I am not ready to parse :)
21:36:22 <SamB> foldr :: (a -> b -> b) -> b -> ([a] -> b)
21:36:23 <SamB> unzip :: [(c,d)] -> ([c],[d])
21:36:30 <Leimy> ok
21:37:21 <SamB> that last part of foldr's type should end up as the type of unzip. solve for a?
21:37:56 <Leimy> SamB: I think I get it a little better now...
21:38:02 <ne1> In other words, the ([a] -> b) should match the [(c,d)] -> ([c],[d]) part.
21:38:05 <Leimy> the examples I had been working with before didn't make this clear
21:38:17 <Leimy> nor did the exercises I was working with
21:39:24 <Leimy> ok the (a->b->b) part is the "binary function"
21:39:29 <Leimy> forgive my terminology
21:39:49 <Leimy> b is the "seed" as others have called it
21:39:49 <SamB> Leimy: on the contrary, that is exactly what kind of a function it is.
21:39:54 <Leimy> ok :)
21:40:19 <Leimy> the last part is what the function does?
21:40:25 <Leimy> I am confused by the extra paren
21:40:36 <Leimy> I would have thought it would be just [a] -> b
21:40:51 <SamB> Leimy: the extra parens are for emphasis, and do not affect the actual meaning of the type
21:40:59 <Leimy> oh
21:41:01 <Leimy> hmmm
21:41:02 <Leimy> ok :)
21:41:11 <Leimy> the emphasis confused me :)
21:41:33 <ne1> parentheses are very cool. All the Scheme people say that.
21:41:37 <Leimy> my problem is that I was thinking stuff had to com into (a->b->b) as [a]
21:41:39 <SamB> well, it should be usefull now that you know it is merely emphasis ;-)
21:41:44 <Leimy> but that's obviously wrong
21:41:59 <Leimy> ne1: I've been looking to try to pick up some Common Lisp next
21:42:17 <Leimy> but I am having too much time sucked by Haskell at the moment :)
21:42:40 <Leimy> SamB: so basically it's saying the whole function of foldr produces the same result as the function you provide it
21:42:41 <Leimy> right?
21:42:46 <Leimy> well "result type"
21:42:56 <ne1> Yes.
21:43:10 <ne1> Err let SamB answer, actually. :)
21:43:33 <Leimy> actually the thing is the foldr type doesn't really say what the complete type of the function you provide's type is
21:43:44 <SamB> Leimy: well, yes. once you apply it to a list ;-)
21:44:00 <Leimy> oh yeah it does :)
21:44:00 <Leimy> doh
21:44:00 <Leimy> hmmm
21:44:33 <Leimy> I am not sure
21:44:33 <Leimy> (a -> b -> b) is a function that takes 2 params
21:45:09 <SamB> yes
21:45:36 <Leimy> and it yields the same type as it's 2nd param
21:45:36 <Leimy> just like the type of (+) is a->a->a
21:45:49 <ne1> yes
21:45:52 <SamB> yes
21:46:03 * Leimy had bad lag
21:46:13 <SamB> oh, hehe ;-)
21:46:15 <Leimy> I just got a bunch of stuff :)
21:46:26 <SamB> I have bad lag all the time too ;-)
21:46:30 <Leimy> I just saw like 4 lines :)
21:46:35 <SamB> (but not right now)
21:47:09 <ne1> lag is good because you have time to fore tell the responses.
21:47:30 <Leimy> so this knowledge of the return type of functions... it's something that has plagued languages like C++ and C for a long time IMO
21:47:49 <Leimy> pre 1999 C assumed everything returned an int :)
21:47:50 <SamB> nel: but sometimes it becomes difficult to tell which responses go with which questions ;-)
21:48:03 <Leimy> unless otherwise specified
21:48:13 <ne1> IRC needs line numbering.
21:48:13 <Leimy> C++ you can can overload funcitons... but not on return type
21:48:14 <Leimy> which is a royal PITA
21:48:32 <Leimy> I've had many a good idea shot down by the lack of overloading on return type
21:48:46 <Leimy> and the work required to fake it is almost never worth pursuing
21:48:53 <SamB> well, haskell doesn't bother with making you specify it, unless it is particularly complicated. you can if you want, but you generally don't have to.
21:49:02 <Leimy> yeah
21:49:16 <Leimy> I've been trying to get into the habit of specifying the types of the functions I've written thus far
21:49:18 <SamB> and overloading is not nearly as ad hoc
21:49:20 <SamB> ;-)
21:49:21 <Leimy> just so I know what I am writing :)
21:49:40 <SamB> Leimy: yes, it is usefull to have ones assumptions checked ;-)
21:50:44 <Leimy> well I am glad I come here to ask question and that you guys are so helpful :)
21:50:53 <Leimy> s/question/questions/
21:50:53 * desrt cries
21:51:16 <Leimy> it's taking a lot of "deprogramming" myself from the years of C/C++ to get the gist of this stuff
21:51:19 <Leimy> it's quite different :)
21:51:21 <SamB> thank you for being glad, it is nice to be glad ;-)
21:51:27 <desrt> "No instances for (Floating Int, RealFrac Int)"
21:51:31 <desrt> *wtf* is this supposed to mean?!
21:51:34 <Leimy> heheh :)
21:51:36 <SamB> you needn't forget your C
21:51:43 <Leimy> I am not trying to forget the C
21:51:50 <desrt> what the heck is a Floating Int?
21:51:50 <Leimy> I use it every day at work... it's like second nature
21:52:04 <Leimy> it's full of helium
21:52:14 <desrt> sigh.
21:52:17 <desrt> here's the issue
21:52:20 <SamB> desrt: it means you are attempting to do something with an Int that can only be done with a Floating
21:52:21 <desrt> when i call my function like
21:52:24 <desrt> func (300)
21:52:25 <desrt> it's okay
21:52:27 <desrt> but when i say
21:52:34 <desrt> func (min width height)
21:52:39 <desrt> it breaks with that error
21:52:39 <SamB> > :i Floating
21:52:40 <SamB> -- Floating is a class
21:52:40 <SamB> class (Fractional a) => Floating a where {
21:52:40 <SamB>     pi :: a;
21:52:40 <SamB>     log :: a -> a;
21:52:40 <SamB>     sqrt :: a -> a {- has default method -};
21:52:42 <SamB>     exp :: a -> a;
21:52:44 <SamB>     logBase :: a -> a -> a {- has default method -};
21:52:46 <SamB>     (**) :: a -> a -> a {- has default method -};
21:52:48 <SamB>     cos :: a -> a;
21:52:51 <SamB>     tan :: a -> a {- has default method -};
21:52:52 <SamB>     sin :: a -> a;
21:52:54 <SamB>     acos :: a -> a;
21:52:56 <SamB>     atan :: a -> a;
21:52:58 <SamB>     asin :: a -> a;
21:53:02 <SamB>     cosh :: a -> a;
21:53:04 <SamB>     tanh :: a -> a {- has default method -};
21:53:06 <SamB>     sinh :: a -> a;
21:53:08 <SamB>     acosh :: a -> a;
21:53:09 <desrt> ok
21:53:10 <SamB>     atanh :: a -> a;
21:53:12 <SamB>     asinh :: a -> a;
21:53:13 <desrt> how do i get it to a float, then?
21:53:14 <SamB>     }
21:53:16 <SamB> any of those needs a type which is in the Floating class
21:53:23 <desrt> it's sin/cos
21:53:27 <desrt> and floor
21:53:37 <Leimy> fromIntegral ?
21:53:44 <Leimy> where have I seen that?
21:54:23 <Leimy> hmm that makes an Integral into a Num?
21:54:37 <SamB> desrt: where did you specify Int?
21:55:00 <[dan]> SamB: What does the syntax of what you just pasted really mean? Didn't grok it when reading about classes earlier
21:55:09 <desrt> wow
21:55:14 <desrt> this typing is a bitch
21:55:22 <desrt> samb; width/height are ints
21:55:33 <ne1> That syntax declares a type class.
21:55:36 <SamB> desrt: oh. well, fromIntegral should do well enough ;-)
21:55:42 <desrt> it's working
21:55:46 <desrt> i don't think i should need it
21:55:49 <desrt> but whatever :P
21:56:09 <SamB> desrt: if it works okay, then fine.
21:56:37 <SamB> [dan]: can you ask a more specific question?
21:57:29 <[dan]> SamB: I guess I really dont understand the concept of a type class
21:57:53 <desrt> ok.. now
21:57:57 <desrt> one last thing before i can go to bed
21:58:09 * desrt makes the descent into monad hell
21:58:28 <SamB> [dan]: do you understand why it is important to have things like * work on more than one type?
21:59:15 <SamB> and why it would be a pain if there was a special mechanism that worked only for a few numeric ops and types?
22:00:15 <[dan]> SamB: yeah, but what's not obvious is if * is really working on one type or just syntactic sugar for a bunch of different operations, depending on the types passed
22:00:44 <[dan]> well, not working on one type, but being a generalization for a bunch of similar operators
22:01:18 <SamB> [dan]: it is more like a generalization for a bunch of similar operators than it is syntactical sugar.
22:01:39 <[dan]> ok, I understand that
22:01:52 <SamB> seeing as there is no other way to do that in Haskell98
22:06:17 <SamB> try this:
22:06:32 <SamB> class Foo n:
22:06:32 <SamB>     foo :: n -> n 
22:06:32 <SamB> instance Foo Int:
22:06:32 <SamB>     foo n = 2 n
22:06:35 <SamB> instance Foo Double:
22:06:37 <SamB>     foo n = n / 2
22:07:01 <SamB> hmm.
22:07:05 <SamB> I am confused.
22:07:12 <SamB> I am reverting to python mode ;-)
22:07:20 <[dan]> hehe
22:08:02 <SamB> algebra too
22:08:25 <[dan]> I'm trying to learn haskell from the perspective of years of lowlevel c/asm... there's just language constructs that I've never seen before
22:08:41 <SamB> okay. this time, for sure:
22:08:45 <SamB> class Foo n where
22:08:46 <SamB>     foo :: n -> n 
22:08:46 <SamB> instance Foo Int where 
22:08:46 <SamB>     foo n = 2 * n
22:08:47 <SamB> instance Foo Double where 
22:08:49 <SamB>     foo n = n / 2
22:09:06 <ne1> in other words, s/:/ where/
22:10:22 <SamB> at the C/ASM level, jump tables of methods are passed around.
22:10:35 <SamB> ne1: and also, add an *
22:11:01 <[dan]> ERROR "Class.hs":4 - Inferred type is not general enough
22:11:01 <[dan]> *** Expression    : foo
22:11:01 <[dan]> *** Expected type : a -> a
22:11:01 <[dan]> *** Inferred type : Double -> Double
22:11:37 <SamB> [dan]: this is because the class involved wasn't Num, which is for some odd reason specially treated.
22:12:08 <[dan]> Ok
22:12:20 <SamB> anyway, you need to give an explicit typing. like foo 1 :: Int
22:12:29 <SamB> or foo 1 :: Double
22:12:58 <[dan]> so foo 1 :: Int  will return 2, and foo 1 :: Double will return 0.5
22:13:16 <SamB> [dan]: yes.
22:13:45 <SamB> in this case, foo (1 :: Int) would have worked just as well.
22:16:43 <SamB> if you are using ghci, foo will have been passed a method table in which it will have looked up its implementation. or something similar to that, anyway.
22:17:42 <[dan]> ok
22:18:01 <Leimy> groovy
22:19:46 <Leimy> SamB: is the "b" in foo's type referring to the Double or the Int in the instance?
22:20:21 * Leimy hasn't really looked at classes yet... perhaps I should wait awhile :)
22:22:47 <ozone> classes are very nice, i wish languages besides Haskell (and Clean) implemented them
22:23:30 <ozone> although the name 'type class' has too many connotations with OO classes for my liking, but ah well
22:25:11 <Leimy> OO being one of the most bastardized terms of all of software 
22:26:28 <ne1> Object Obfuscation Pomposity.
22:26:32 <ozone> well, i disagree, but that's just me. :)
22:27:30 <Leimy> well lots of different languages claim to be OO and they support different things they label as OO
22:28:23 <Leimy> Smalltalk was the first language to be called OO and I don't think it even had inheritance :)
22:29:48 <ne1> Since it doesn't have a formal notion of class, it does not need a formal notion of inheritance.
22:30:22 <Leimy> I was not trying to say that smalltalk was incomplete :)
22:30:31 <Leimy> just that OO doesn't mean the same thing to everyone anymore
22:31:07 <ne1> Right.
22:45:09 <desrt> it's sort of interesting
22:45:11 <desrt> in messing around...
22:45:17 <desrt> if i can get it to compile it *always* works
22:45:22 <desrt> but getting it to compile is hard
22:45:29 <desrt> i guess that's what static typing is all about, tho
22:46:26 <Leimy> It's about strictness :)
22:48:39 <Leimy> well I am completely wiped out... thanks for all the help and putting up with my barrage of questions.
22:48:45 <Leimy> going to bed!
22:48:59 <ozone> night
22:55:23 <desrt> woo
22:55:27 <desrt> i am satisfied with my work
22:55:29 <desrt> gtk2hs rules
22:57:35 <desrt> all i have to do now is sell the CAS department on how cool it is :)
22:59:16 <SamB_irssi> Leimyzzzz: you are welcome.
23:02:42 <SamB_irssi> desrt: static typing isn't about pain, though it is a pain when you get incomprehensible type errors.
23:04:32 <ne1> Everything is about pain, when it comes to disciplining monkeys.
23:28:50 <desrt> SamB; incomprehensible type errors are still one better than random inexplicable segfaults
23:30:33 <SamB> of course ;-)
23:53:03 <desrt> haskell sucks!
23:53:06 * desrt trashes the channel
23:58:53 <desrt> new favourite function: id
23:59:18 <Pseudonym> Surprisingly useful, isn't it.
23:59:35 <desrt> i actually can't think of a use for it off-hand
