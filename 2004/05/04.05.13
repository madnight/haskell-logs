00:17:48 <shammah> shapr: Are you active?
00:18:33 <juhp> automake is annoying me again:
00:18:47 <juhp> % ls Makefile.am
00:18:47 <juhp> Makefile.am
00:18:58 <juhp> % automake
00:19:09 <juhp> automake: no `Makefile.am' found or specified
00:19:27 <juhp> yeah, great error message
00:19:46 <juhp> sigh
00:38:23 <tea> I want autoautomake sometime,
00:38:29 <tea> good morning room ~
00:39:55 <tea> I was python user who thinking move to haskell for lazy evaluation of list slice
00:40:31 <eivuokko> Morning :)  What are you now, then?
00:41:51 <tea> I'm umm thinking re-studing haskell tutorial, and looking for a way to do in python
00:42:10 <tea> I just wanted [1..10] ++ [20..30]
00:42:52 <tea> xrange(1,11) + xrance(20,31) ... sure not work X_X
00:42:57 <tea> <- python
00:43:22 <blackdog_> no, you'd need a lazy '+' as well
00:43:26 <tea> for this reason, I feel like haskell more than before  ^^;;
00:44:04 <tea> where '+' do i need ?
00:44:51 <blackdog_> well, isn't the problem with python that xrange(1,11) + xrange(20,31) evaluates the whole thing right away?
00:45:15 <vegai> xrange is lazy, sorta
00:45:29 <vegai> but yeah, it tries to evaluate the + right away
00:45:38 <tea> yes, but i could not xrange + xrange
00:45:47 <tea> range + range  its merge the list
00:46:36 <tea> I needed to define a generater to do it in python.
00:47:16 <shrimpx>  xrange is not really a lazy list.. it's a 'thing' that supports indexing and iteration
00:47:21 <tea> I did not have idea to make slice of list with xrange =(
00:48:53 <tea> any way, I found out the haskell's code is easy 
00:49:07 <tea> to solve it.
00:49:17 <vegai> shrimpx: it's not far from it, anyway
00:49:20 <vegai> and generators in general
00:50:37 <tea> def foo():
00:50:45 <tea>    for i in xrange(1,10): yield i
00:50:48 <shrimpx> languages without variant sums confuse me
00:50:50 <tea>  for i in xrange(20,30): yield i
00:51:25 <shammah> tea: what you need is itertools.chain(xrange(1,11), xrange(20,30))
00:51:41 <shrimpx> hah, cool
00:51:50 <tea> <- i was thnking the code, but i wished i can write it in lambda
00:52:07 <tea> 0.0 ah Is there such library !?
00:52:20 <shammah> yeah.  part of the stdlib in 2.3 :)
00:52:33 <tea> thank u, I will check it
00:52:56 <shammah> from itertools import *  # my favourite first line in any python script ;)
00:53:44 <tea> I was reading ibm dW's article that help python users to learn haskell/ functional style programing
00:55:31 <tea> :) great,, itertools.chain worked
00:57:04 <shammah> tea: good.  That's what it's there for ;)
00:57:40 <tea> did python have another library for functional programing
00:58:18 <tea> oh teh ,, but this is I missed the chance to re-study haskell ^^;
01:03:09 <tea> may i ask a qustion ?
01:04:21 <tea> which compiler is the most used in haskell
01:05:15 <vegai> ghc
01:07:17 <tea> thx, I will test with ghc,  haskell does not have compiler dependence like c compiler ?
01:07:31 <tea> that is i worryed
01:08:23 <vegai> no, it doesn't require a C compiler
01:10:45 <tea> ah , no, the case .. A compiler can compile the haskell code , but error on B compiler ?
01:11:27 <tea> for long time ago, i had compiled some haskell application. that when i did not know haskell so much
01:11:52 <tea> I gave up on that time. but now interest again. if there was such problem
01:13:43 <tea> thank u for ans, I will use ghc the popular compiler :)
01:15:30 <shrimpx> ghc did depend on the C compiler a while ago, if that's what you were asking. it still does on some platforms, afaik
01:18:13 <earthy> what tea is asking is about the portability of his code between haskell compiles
01:18:25 <earthy> as long as you stick to the Haskell 98 standard you'll be fine
01:18:56 <earthy> and several extensions are quite common
01:21:41 <tea> Yes, It was about portability. so that's good. improved it now ?!
01:22:30 <tea> I'll challenge to compile again 
02:00:02 <skew> good morning
04:24:49 <shapr> good morning!
04:25:26 <shapr> wassup peoples?
04:28:12 <Spark> i have toothache :(
04:28:39 <shapr> that sucks
04:28:51 <shapr> going to the tooth doc?
04:29:07 <Spark> its just wisdom tooth growage, so i think i'll leave it for now and see what happens
04:29:19 <Spark> or i could use this opportunity to try out some hardcore pain killers :o
04:29:32 <Spark> doctor doctor give me some VALIUM
04:29:42 <Cale> Morphine
04:29:57 <Spark> apparently there is something you can get over the counter which has morphine in it
04:29:59 <iolotusbobo> hello all
04:30:02 <Spark> probably not very much though :)
04:30:10 <shapr> oh, I'd recommend getting wisdom teeth out soonest, if you need to
04:30:18 <shapr> hi iolotusbobo 
04:30:24 <earthy> `if you need to'
04:30:27 <Spark> im not sure if i need to :)
04:30:30 <Spark> whats usually the problem
04:30:33 <iolotusbobo> hello shapr
04:30:34 <shapr> looking for haskell info?
04:30:34 <earthy> my first molars were pulled when I was younger
04:30:37 <Spark> do they grow into your brain or something :)
04:30:44 <earthy> so the wisdom teeth had some space
04:31:01 <iolotusbobo> u an op here shapr
04:31:01 <iolotusbobo> ?
04:31:16 <shapr> iolotusbobo: er, why it that important?
04:31:34 <Spark> we need to feel safe :)
04:31:37 <shapr> I'm really helpful, is that good?
04:31:45 <iolotusbobo> shapr ... because i have something that i must discuss with an op
04:32:15 <eivuokko> Library infrastructure project uses arch :\  Does anyone try these things in Windows?  Last I checked it was kinda hard.
04:32:20 <shapr> what would that be?
04:32:26 <iolotusbobo> that is good shapr ... but i am not here to learn haskell at the moment... i have another purpose...
04:32:41 <shapr> iolotusbobo: what is your other purpose?
04:33:10 <iolotusbobo> shapr... that can only be spoken to an op/with the permission of an op...'
04:33:22 <shapr> I guess we'll never know then
04:34:05 <iolotusbobo> shapr... i can /msg you if its ok with you
04:34:09 <Cale> I have come! I bring grave news from afar! Do you have ops? Heh.
04:34:31 <iolotusbobo> lol Cale ... 
04:34:33 <shapr> that does that sound suspicious 
04:34:55 <iolotusbobo> well... shapr its not... if its ok with everyone... i will speak here...
04:34:59 <eivuokko> Advertising or logging or something like that.
04:35:09 <shapr> eivuokko: anyway, it's possible that LIP will go darcs
04:35:28 <Jerub> oh god.
04:35:34 <Jerub> I just ate far too much indian food.
04:35:39 <Spark> does this involve terrorism
04:35:40 <shapr> iolotusbobo: sure as long as it's short and sweet, so far it sounds like you're trying to sell something
04:35:40 * Cale is back (gone 06:11:01)
04:36:14 <eivuokko> I seriously am feeling I'd like to do stuff to help Haskell in Windows.  But everything seems kinda hard atm.
04:36:19 <iolotusbobo> well shapr ... i am not trying to _sell_ something... i am trying to _share_ something... 
04:36:34 <shapr> what are you trying to share?
04:36:34 <Cale> why are you being so mysterious?
04:36:45 <Spark> its a teaser campaign for a new movie
04:36:51 <shapr> heh
04:36:55 <iolotusbobo> shapr... you tell me... how do you tell people about some new community on freenode...
04:37:00 <eivuokko> iolotusbobo, why don't you just say what you gonna say.  Worst thing everyone ignores you, I guess.
04:37:07 <shapr> Haskell : the Functional Dependency
04:37:43 <iolotusbobo> well... eivuokko i don't want to offend people... the Op Src Ideology is sensitive... and i am sensitive to it...
04:37:51 <shapr> iolotusbobo: you mention it on mailing lists and wikis with the same subject
04:38:17 <shapr> ok, give us one sentence advertising your new freenode community
04:38:26 <eivuokko> Indeed.
04:38:55 <Spark> thats a short sentence... oh
04:39:09 <iolotusbobo> well... we discuss algorithms and programming. our SF.net site is ... http://algosatfreenode.sf.net
04:39:21 <iolotusbobo> shapr, was that small enough
04:39:28 <shapr> yes that's fine
04:39:43 <shapr> do you have a section for functional algorithms?
04:39:55 <iolotusbobo> well... yes and no shapr
04:40:24 <Spark> surely algorithms by themselves are neither functional nor imperative, theyre way above that
04:41:06 <iolotusbobo> i agree Spark... mostly
04:41:58 <iolotusbobo> we discuss almost all kinds of algorithms... to make fast and efficient algorithms... functionality steps at implementation level...
04:42:18 <shapr> Okasaki's book showed how to make amortized algorithms that were in some cases faster than the procedural equivalent
04:42:52 <shapr> through use of lazy evaluation
04:43:12 <Spark> mm
04:44:03 <shapr> iolotusbobo: thanks for mentioning this
04:44:05 <iolotusbobo> hmm... i guess the right place to start reading would be Sussman's SICP or Cormen's Algorithms
04:44:15 <shapr> SICP is nice
04:44:20 <iolotusbobo> k shapr
04:44:47 <shapr> I like Rabhi and Lapalme's "Algorithms : A Functional Programming Approach"
04:44:49 <iolotusbobo> i hope to see you soon ... at algos... shapr
04:44:56 <shapr> I really enjoyed that book
04:45:42 <eivuokko> If I recall correctly, I felt that exercises were a bit tedious.
04:45:59 <shapr> in that book?
04:46:12 <eivuokko> Yes, in SICP.
04:46:38 <shapr> oh, I thought you meant "Algorithms : FP"
04:47:21 <Lunar^> shapr: Still no answer from dark :(
04:48:10 <shapr> even so, I'm sure he's released it under BSD
04:48:21 <shapr> he's quite picky about that
04:48:47 <shapr> oh, I should have asked him about EuroHaskell
04:49:17 <shapr> iolotusbobo: so, have you tried Haskell? it's really nice for teaching algorithms ;-)
04:49:40 <iolotusbobo> no shapr... i havent tried haskell... am from old school c !
04:49:41 <Lunar^> shapr: I'll put the blame on you if he goes mad :)
04:49:55 <shapr> Lunar^: fair enough :-)
04:50:16 <shapr> iolotusbobo: you may enjoy it, for some things it is much clearer
04:50:46 <iolotusbobo> i understand shapr... but time is a constant enemy that i must fight against ...
04:50:58 <shapr> well, me too
04:51:06 <shapr> so much to learn, so little time
04:51:44 <iolotusbobo> right now... i stick to c/c++, php etc...
04:51:57 <shapr> ok
04:52:10 <Jerub> GAH!
04:52:11 <Jerub> php!
04:52:13 <Jerub> DIE!
04:52:18 * shapr shrugs
04:52:24 <shapr> it's his choice
04:52:44 <shapr> I'm not very fond of PHP either
04:52:54 <iolotusbobo> shapr... most of my dev revolves around web based applications... so i guess you might understand _php_
04:53:36 <Lunar^> iolotusbobo: shapr is working mostly on Zope
04:53:44 <shapr> all of my dev revolves around web applications
04:54:02 <iolotusbobo> and for server side scripting ... i am yet to find something better than php...
04:54:05 <shapr> would you like to see a nice 200 line web app in Haskell?
04:54:05 <Lunar^> But anyway, Halipeto + HAIFA + HWS will rule the world someday
04:54:11 <iolotusbobo> ok... so you use zope shapr
04:54:26 <shapr> yes, most of my income is from Zope
04:54:42 <shapr> but I think Haskell is a more powerful tool in geneeral
04:54:48 <iolotusbobo> well... shapr... i might say ... "would you like to see a nice 1000 line web software in c"
04:55:09 <iolotusbobo> and i can say with much support ... that "c is a powerful tool in general"
04:55:15 <shapr> do you have one I could see?
04:55:21 <iolotusbobo> but that is not the point...
04:55:31 <iolotusbobo> the point is... languages are implementation issues... 
04:55:38 <shapr> well, we could do the shootout if you want
04:55:40 <iolotusbobo> use what you are comfortable with... simple... dot
04:55:51 <shapr> we each choose a haf hour task and swap them
04:55:54 <iolotusbobo> well... we could shapr... 
04:56:10 <shapr> but it would take time
04:56:10 <iolotusbobo> and yes ... lets do it... 
04:56:13 <shapr> ok!
04:56:20 <Cale> whee!
04:56:29 * shapr bounces happily
04:56:30 <iolotusbobo> so... throw a challenge
04:56:34 <shapr> umm
04:56:45 * shapr thinks
04:57:00 * iolotusbobo shivers
04:57:03 <shapr> heh
04:57:17 * iolotusbobo looks at shapr's shimmering sword
04:57:19 <shapr> I'm out of inspiration at the moment, do you have a suggestion?
04:57:29 <Cale> Something involving a parser
04:57:29 * shapr drinks coffee
04:57:37 <shapr> oh, that's evil
04:57:46 <shapr> C parsers are hard
04:57:54 <Cale> heheh
04:57:58 <iolotusbobo> ok... a little question shapr... is it a duel or a friendly match?
04:58:02 <Maddas> hah, a challenge!
04:58:08 <shapr> it's friendly! always!
04:58:14 <iolotusbobo> i am ok with the parser concept...
04:58:15 <Maddas> The loser shall be banished from planet earth!
04:58:16 <Maddas> Oh, bummer.
04:58:22 <shapr> I just want to learn more about why you prefer your way
04:58:25 <iolotusbobo> lol Maddas
04:58:33 <shapr> and try to show you sofe of why I like my way
04:58:39 <shapr> s/sofe/some
04:58:45 <iolotusbobo> and i want a serious motivation to start learning haskell !! shapr
04:58:50 <shapr> yay!
04:59:06 <shapr> well, parsers are motivational Haskell code
04:59:38 * earthy types out a parser in C almost as fast as he does in Haskell
04:59:46 <earthy> depending on the grammar, ofcourse. :P
04:59:50 <shapr> right
05:00:23 <shapr> ok, what about something like python's ConfigParser?
05:00:27 <Cale> Something involving a parser which must be generated on the fly at runtime from user input. :)
05:00:32 <iolotusbobo> ok shapr... i already have a couple of problems posted at our algorithms community... can we use them?
05:00:58 <shapr> aka the windows .ini file with [] section headers and name = value pairs?
05:01:10 <shapr> iolotusbobo: can I see them?
05:01:15 <earthy> shapr: that's trivial, right?
05:01:27 <iolotusbobo> yeah sure... i think i gave you the url shapr
05:01:46 <iolotusbobo> the sourceforge.net url
05:02:17 <shapr> yes, but I don't see the problems?
05:02:32 <iolotusbobo> see the 'Open Code Hacks' section
05:02:39 <iolotusbobo> shapr ^^
05:02:41 * Spark wonders
05:03:01 * iolotusbobo wonders what Spark wonders
05:03:30 <shapr> well, the expert system would take longer than half an hour to write
05:03:39 <shapr> I think
05:04:00 * shapr thinks about it
05:04:10 <iolotusbobo> well... i already have it written... so lets forget it shapr
05:04:51 <shapr> I would like to see your solution though
05:04:56 <shapr> sounds interesting
05:05:01 <Shammah> evening shapr.
05:05:10 <shapr> hi Shammah, you were looking for me earlier?
05:05:21 <shapr> hi linuxfreck 
05:05:21 <iolotusbobo> sure shapr... anytime... although most of my c code is pretty obfuscated
05:05:40 <iolotusbobo> welcome linuxfreck 
05:05:56 <linuxfreck> hi
05:06:00 <shapr> as for the fast data repository, I'd use HaskellDB and call into PostgreSQL
05:06:30 <Shammah> yeah.  I went and implemented a CPS tree-traversal in Java and C to assist your C-programmer ;)
05:06:39 <shapr> Shammah: nifty!
05:07:33 <iolotusbobo> shapr... i would use MySQL to counter that in PHP or even PostgreSQL :)
05:07:50 <iolotusbobo> but then... at algos you are not allowed to use these shapr...
05:07:51 <Shammah> Eventually I'll write up an explaination, in the interim is there somewhere convenient to post it?
05:08:08 <shapr> Shammah: sure, you can put it on the wiki
05:08:17 <shapr> or I can host it if you like
05:08:30 <Spark> shapr: do you ever say anything negative or sarcastic or unhelpful? :)
05:08:54 <shapr> Spark: yes, but then I smack myself for being an ass
05:08:57 <Spark> you remind me of that character from "scrubs" the tv comedy series
05:09:03 <Spark> haha
05:09:05 <shapr> what character?
05:09:07 <earthy> he's just such a lovejunkie :P
05:09:23 <Spark> he was another intern like the main guy
05:09:47 <Spark> but everyone looked up to him, but in the end he quit cos he couldnt handle the fact that he couldnt help this kid
05:10:09 <shapr> iolotusbobo: I would like to see your expert system code, is it available?
05:10:26 <Spark> </bad description>
05:11:05 <shapr> maybe I should try to write it myself first
05:11:21 <shapr> iolotusbobo: is it ok to use a parser generator for those problems?
05:12:04 <shapr> oh, I could use GF I bet
05:12:26 <skew> if we want more evil suggestions, how about an unlambda interpreter?
05:12:33 <iolotusbobo> shapr ... we try to _force_ people to write code from scratch
05:12:41 <skew> or at least something with continuations...
05:14:18 <shapr> iolotusbobo: I usually focus on going from an idea to working code as quickly as possible, I think that's more useful for people with programming jobs (like me :-)
05:15:34 <Cale> How about something that given a string of n consecutive u's (up, <) and d's (down, >=), returns the number of permutations on 1..n+1 which have the relationships between them as described by that string. i.e. 1 4 2 3 is described by u d u (1 up to 4 then down to 2 and up to 3)
05:15:38 <shapr> I agree that in-depth understanding of the algorithms is important, but I think once you reach a commercial setting, it's better to use libraries that have been Seriously Tuned(tm) by others
05:16:39 <Cale> Mind you, only the number of such permutations - it needn't enumerate them explicitly.
05:16:41 <shapr> so, I understand how an inverted index works, but I'd use PostgreSQL rather than write my own index
05:17:16 <skew> even understanding the algorithms are not so important if you understand the abstractions provided
05:17:40 <skew> well, understanding the Serious Tuning bit of the algorithms, at least
05:18:02 <shapr> right, that's what TaPL claims, that type systems won't be really useful until they can be used by those who don't understand them
05:18:59 <shapr> but, all else being equal, it's good to know the algorithm you're using
05:19:05 <iolotusbobo> i understand... shapr
05:20:02 <iolotusbobo> but the point of algos is _not_ to quickly produce working code... it is promote the research and development of algorithms by the Open Source Community... 
05:20:08 <shapr> ah, ok
05:20:25 <Cale> (I like the problem I just described because I know a really obscure, but fast way to solve it)
05:20:43 <iolotusbobo> so ... we talk about using Rabin Carp to locate sub strings ... rather than ... pre made linear search functions... shapr
05:21:03 <shapr> what about suffix trees?
05:21:05 <Cale> well, fast in the sense that it's polynomial time on the order of taking the determinant of a matrix :)
05:21:20 <shapr> I'm interested in n-dimensional suffix trees
05:22:20 <iolotusbobo> shapr... am currently making my ai.c (expert system) code a bit readable... its a very simple program... and i would like you to try to solve it first... 
05:22:22 <skew> that expert system problem looks like it would be pretty easy
05:22:46 <shapr> iolotusbobo: ok
05:23:06 <shapr> I think it would be fun to use GF for that
05:23:12 <skew> GF?
05:23:25 <skew> I think I heard of that before...
05:25:35 <shapr> Grammatical Framework
05:26:12 <shapr> oh cool, Jef Raskin is coming to EuroPython!
05:26:43 <shapr> I've written several bits of elisp in accordance with his ideas
05:27:08 <Shammah> shapr: http://www.haskell.org/hawiki/CpsInJava
05:27:43 <Maddas> woo!
05:28:12 <shapr> I added the java highlighting
05:28:22 <shapr> Shammah: thanks this is cool!
05:28:47 * Maddas snickers
05:31:52 * shapr hacks on a GF parser
05:33:21 <skew> iolotusbobo: is the expert system problem intended to be trivial?
05:34:23 <shapr> Shammah: very spiffy explanation, thanks. I definitely will use this in the future.
05:34:43 <Shammah> http://www.haskell.org/hawiki/CpsInCee
05:34:57 <shapr> iolotusbobo: yah, how long time should/does this take people to write?
05:35:09 <Shammah> and yes, I know it leaks memory like a sieve, with C it's hard not to when writing like this.
05:36:19 <Shammah> shapr: no problem.  I enjoy teaching, and writing pedalogical examples almost more than I enjoy actually coding for real.
05:37:11 <skew> we have proper nouns, which are members of classes, and some verbs with are binary relations on the classes
05:37:14 <skew> that is all, right?
05:37:19 <iolotusbobo> shapr... it takes sometime... but we end up learning a lot... shapr...
05:38:35 <shapr> Shammah: I added pretty colors
05:40:14 <Shammah> shapr: cool. thanks.
05:41:05 <Shammah> must admit, the CpsInCee was sufficiently hairy I was surprised when I ran it and it actually worked :)
05:41:22 <Shammah> Haskell and ML are much nicer languages for such discussions.
05:41:51 <shapr> yes, I think it's easier to teach most algos in Haskell/ML
05:41:57 <shapr> not all of course
05:47:04 * earthy thinks about Knuth's dancing links paper
05:53:50 <shapr> I like the approach of Rabhi and Lapalme, first write the painfully clear version, then show how to optimize it
05:54:58 <Shammah> shapr: I'm not sure I'm familiar with Rabhi and Lapalme.
05:56:56 <shapr> http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
05:57:45 <Shammah> ahh that one.  I've seen it on amazon.  Haven't seen it in person.  Any good?
06:05:46 <skew> get a music program that supports unicode titles?
06:05:57 <skew> ....
06:06:16 <skew> grr, talking to #python again
06:07:32 <shapr> Shammah: I like it a lot
06:07:56 <Shammah> I'll see if I can find a copy then.
06:08:12 <shapr> if you already know the algorithms backwards and forwards, it may not be so much fun for you
06:09:24 <Shammah> currently my biggest hurdle with haskell is estimating space/time complexity in the presence of lazy-evaluation.  I saw a chapter on complexity analysis, if I can find a copy at my local library it might be of help then.
06:09:42 <shapr> one neat thing it did have was my first exposure to Burstall & Darlington
06:10:07 <shapr> B&D came up with a generic 'optimization' system
06:11:04 <shapr> in the Algos book the authors show you how apply it to various algorithms, but the point is more that you learn how to apply the system to anything
06:11:18 <shapr> it works fine on Python code :-)
06:11:46 <Shammah> interesting...
06:11:56 <skew> what's this system?
06:12:15 <Shammah> especially as atm, my job is full-time optimisation of java code :)
06:12:22 <shapr> whee
06:12:40 <Shammah> yeah, something like that :)
06:12:44 <shapr> http://citeseer.ist.psu.edu/burstall77transformation.html
06:13:03 <shapr> I'm not sure if that's the most comprehensive B&D paper
06:14:49 <shapr> but the heuristic approach in this algos book is that once you know the naive versions and the transformation system, you'll be able to do whatever you need
06:14:49 * kosmikus just committed revision 200 of his thesis ...
06:15:04 <shapr> kosmikus: yay! how's your heuristic doing?
06:16:45 <Shammah> shapr: I'll definately take a look at it.  I have another order of magnitude up my sleve, and then I'm really not at all sure where to go next :).
06:16:49 <iolotusbobo> shapr?
06:16:57 * desrt yawn
06:17:23 <desrt> lambdabot; i miss you!
06:18:23 <skew> Shammah: C?
06:19:08 <skew> I've got something reasonably elegant code for the expert system thing
06:19:57 <shapr> desrt: there ya go
06:20:16 <desrt> :)
06:22:00 <shapr> skew: put it up?
06:26:20 <kosmikus> shapr: it's not helping ... (a) is the case since a few weeks already, (b) is also true, but "some content" doesn't seem to be good enough; only (c) I can really rely on ...
06:26:37 <Shammah> skew: nope java.
06:27:22 <skew> Shammah: I'm suggesting where to go after that last order of magnitude you see
06:28:15 <shapr> kosmikus: sounds nice exciting
06:28:23 <shapr> "and"
06:28:32 * shapr is semi-tasking
06:28:39 <Shammah> skew: The cost of moving to C is very high.  No gc; less safe language; recompilation required for cross-platform.
06:28:44 <Shammah> that last is a real problem.
06:29:01 <shapr> what's the cost of moving to Haskell? :-)
06:29:53 <Shammah> shapr: developer resistance; recompilation required for cross-platform; reduced interopability with existing enterprise systems.
06:29:54 <shapr> semi-tasking = doing several things at the same time, all of them badly ; ie. Windows 3.1
06:30:17 <shapr> what sort of interop do you use?
06:31:19 <Shammah> integration with J2EE sub-systems such as mbeans, and transaction-managers.
06:31:48 <Shammah> integration with existing bespoke java code.
06:32:00 <shapr> yah, there's that
06:32:59 <Spark> :)
06:33:29 <shapr> but it's java, so it should be just as easy to talk to via xmlrpc/soap/corba, right?
06:33:32 * Shammah dreams of a day when ghc cross-compiles to a jvm-target 
06:34:13 <Shammah> shapr: nah, integration is tighter than that.  
06:34:53 <Shammah> http://www.kowari.org/
06:34:56 <skew> there we go, got my code working and posted on the paste page
06:35:07 <Shammah> It sure is fun to be paid to work on oss.
06:35:32 <shapr> that is nice
06:36:06 <shapr> I'm not thrilled with J2EE
06:36:28 <shapr> that's why I switched to Zope
06:36:41 * shapr shrugs
06:36:55 <desrt> are there multiple javac's?
06:36:59 <shapr> yes
06:37:06 <shapr> jikes for example
06:37:06 <desrt> i'm using blackdown jdk right now
06:37:11 <desrt> and getting the impression it sucks
06:37:13 <shapr> is much better
06:37:28 <desrt> it breaks if i run it in a utf8 locale
06:38:13 * shapr dunno
06:38:23 <Spark> i use the sun one
06:38:31 <Spark> out of ignorance mostly :)
06:38:37 <Spark> it just about works
06:38:52 <skew> shapr: how is your work on Haskell replacements for the web stuff?
06:39:56 <Shammah> shapr: AFAIK zope dosn't really have an answer to large-scale backend integration.  Although as a content management system/web-delivery system it's pretty cool.
06:40:31 <shapr> no code progress lately, but I have realized I need to come up with a decent algebraic type publishing system
06:41:02 <shapr> that's part of why I've been playing with generics lately
06:41:30 <shapr> Shammah: what do you mean by backend?
06:42:10 <Shammah> kowari is aimed at sites wanting to manage large amounts of unstructured data, where large is 200-1000 million <subject,predicate,object> triples.
06:42:48 <shapr> like what? can you give an example of such data?
06:43:02 * shapr looks at the overview
06:43:38 <Shammah> legal citation databases.  marketing datastores.  
06:44:10 <skew> are predicates generally distinct from subjects and objects?
06:44:27 <Spark> is the predicate like metadata?
06:45:15 <Shammah> skew: not really.  you can make statements about 'subjects' that are predicates themselves in other statements.
06:45:38 <shapr> Zope has its own object database, and decent integration with a lot of other databases, commercial and not. I don't think that sort of data size would be a problem
06:46:50 <shapr> I'd rather use HaskellDB though :-)
06:47:03 <Shammah> :)
06:47:39 <shapr> my only problem with zope so far is that it's not as flexible as I'd like
06:48:33 <shapr> it's good at what it does, but when you try to rip its guts out and make it do something else, the pieces don't always fit together in the new shape
06:49:17 <shapr> zope3 looks much more flexible, but once again, I wonder if monads or arrows could do more
06:49:38 <Shammah> shapr: http://www.tucanatech.com/solutions.html  lot's of marketing speak, but carries the basic purpose of such a beast.
06:50:41 <Shammah> probably.
06:51:05 <Shammah> I haven't really played with Zope for years.  I should probably take another look.
06:51:44 <shapr> is this like 'subviews' or something that's used to treat unstructured data as a structure and then pull out significant parts?
06:52:45 <Shammah> I'm not really sure what you mean by a 'subview'; but I suspect not.
06:54:29 <Shammah> the data is stored as a massive directed-graph.  You query the graph directly through pattern matching, and basic logical predicates.
06:54:31 <shapr> I'm thinking of a system that lets you easily write a 'viewer' for a column so that you can then treat the view as another table and do queries on that
06:55:02 <shapr> sort of like an on-disk spreadsheet maybe
06:55:28 <shapr> sounds nifty
06:55:58 <shapr> hi gintas 
06:56:06 <gintas> shapr: hi
06:56:23 <shapr> Shammah: that's pretty cool
06:57:15 <shapr> can you actually write a view that treats a field as another DG?
06:57:32 <Shammah> so "select $s $p $o from 'model' where $s $p $o"  returns the entire graph.  But "select $p $o from 'model' where <person:shapr> $p $o" would return everything known about shapr ;)
06:57:50 <shapr> right, I see
06:58:28 <Shammah> and of course you can use and/or (conjunction/disjunction) to combine predicates in the where-clause.
06:58:45 <shapr> interesting
06:59:34 <Shammah> shapr: we are currently working on adding inferencing.  We already have 'views' (queries that subset the graph)
07:00:06 <Shammah> (well some of use are working on inferencing... as I said before, my job is currently just to make the queries we already support run faster)
07:00:36 <Shammah> I'm enjoying it.  Very interesting work.
07:00:45 <shapr> can you take apart a field according to certain criteria and treat it as a bunch of other fields?
07:01:41 <Shammah> fields aren't like that.
07:01:59 <Shammah> the data is stored as statements, not as tables or relations.
07:02:27 <eivuokko> Hmmm.  Sounds logicprogramming to me :)
07:02:52 <Shammah> eivuokko: Possibly, but not prolog :)
07:03:25 <Shammah> The maths behind it is actually a field called 'Discription Logics', which only overlaps Predicate Horn Logic.
07:04:32 <Shammah> still anyone who's done any prolog programming will be comfortable.
07:06:19 <Shammah> oh well, it's midnight here.  So I'll catch everyone later.
07:09:53 <skew> shapr: for monads to do much good for combining components, it seems like components would need to correspond to monad transformers
07:11:12 <skew> and a subclass of monad.
07:11:57 <skew> I think the language might need to learn about commutable monad transformers to avoid the quadradic explosion of MonadFoo instances you get with a scheme like that
07:25:03 <shapr> I think he's right
07:25:11 <shapr> I hadn't thought of that
07:25:26 <shapr> do arrows beat that?
07:25:33 * shapr isn't sure
07:36:26 <Lunar^> shapr: Can darcs send a mail  in case of repository change ?
07:39:48 <shapr> not that I can think of at the moment, but if you're using email commit, it's easy to add a target to the .forward
07:41:07 <Lunar^> shapr: We use exclusively local commit
07:41:55 <shapr> the cheesy solution is to add it to the test script
07:42:46 <Lunar^> shapr: mh?
07:43:39 <shapr> the test script is executed when you commit
07:45:09 <shapr> it's really there for running a test suite to see if you're really ready to commit, but you could also add a mailsend command if the tests succeed
07:46:48 <Lunar^> shapr: I will investigate, thanks
07:47:17 <iolotusbobo> shapr... did u check out the ai.c program?
07:49:17 <shapr> yes I did, it looks nice
07:54:41 <phubuh> hey hey
07:56:08 <ski> hi phubuh
08:11:31 <XTL> damned switch stops that port every now and then
08:13:23 <iolotusbobo> shapr, when you get the haskell code for it working... please let me know... and i would like to see it too
08:14:06 <Maddas> hey phubuh 
08:14:19 <phubuh> hi ski, hey Maddas :)
08:31:31 <ski> iolotusbobo : for what ? (expert system ?? parser ??)
08:36:55 <iolotusbobo> ski?? for expert system
08:37:08 <iolotusbobo> ski... may i /invite you?
08:38:03 <ski> where ?
08:38:33 <iolotusbobo> well... i mentioned it earlier if you remember... 
08:39:14 * ski joined this channel quite recently, and just browsed through some of the log to see what was discussed
08:42:58 <shapr> y0 phubuh 
08:43:06 <phubuh> hi hi
08:43:10 <shapr> wassup?
08:43:39 <iolotusbobo> shapr : got my msg?
08:45:04 <shapr> er, no?
08:45:19 <phubuh> writing some ugly python code to dump TV show listings as emacs diary entries :-)
08:45:50 <shapr> iolotusbobo: if you mean the link to the suffix tree paper, I got that.
08:46:05 <Maddas> phubuh: heh!
08:46:11 <Lunar^> phubuh: how geek it is :)
08:46:18 <phubuh> :P
08:46:18 <Maddas> I think that's a ten out of ten on the geek scale
08:46:20 <Maddas> haha
08:46:26 <phubuh> hee hee
08:46:48 <phubuh> i've already got it showing the current and upcoming shows in a pretty little GNOME applet :-)
08:47:25 <iolotusbobo> shapr... i mean the msg after that
08:47:56 <phubuh> shapr: would that happen to be ukkonen's paper by any chance?
08:48:05 <phubuh> i've been looking all over for that one
08:55:17 <platypus> just wondering but are there any apps that are used on linux written using any haskell based languages ?
08:55:26 <phubuh> platypus: darcs!
08:55:48 <keverets> Igloo: around?  I'm trying to use Haskell2Latex, but am mightily confused.
08:58:00 <Igloo> What's the problem?
08:58:04 <platypus> phubuh, thanks
08:58:49 <Igloo> (lhs2tex (is that the one I mean) is probably the better tool today)
08:59:59 <neologism> can you advise me some haskell IO tutorial
09:00:07 <neologism> I am a bit confused from all that monads
09:00:12 <shapr> phubuh: I'm looking for n-dimensional suffix trees
09:00:29 <shapr> neologism: http://www.haskell.org/hawiki/UsingMonads
09:01:03 <neologism> ideally with examples ;)
09:01:20 <shapr> thenomaware tutorial has excellent examples
09:01:48 <neologism> thats what I studied
09:02:04 <neologism> and I am still not able to do this "input number and print its factorial"
09:03:50 <ski> shapr : and it's up again :)
09:04:00 <shapr> can you print the factorials of a number?
09:04:20 <neologism> yes
09:06:07 <keverets> Igloo: ah, will use that instead then.  Saw Haskell2LaTeX in use for Hetris and thought I'd try that.
09:07:02 <Igloo> I'm still interested as to what the problem was if it's not hard to explain
09:07:29 <Igloo> (And H2L is fine if you're happy with the layout rules it uses, but l2tallows you to specify it I believe)
09:09:39 <keverets> Igloo: I built it as per the README, but found it difficult to figure out just what pieces were needed to actually use it.  I was putting my document in place of the Hetris one in the source, but that wasn't a good way of going.  Just was wondering if there was a Guide, HOWTO, or manual for it.
09:10:31 <stratocaster> Hi. Using the Network module (as opposed to the lower-level Network.Socket), is there a way to tell if a client on the other end of a handle returned by 'accept' has disconnected?
09:10:54 <Igloo> Hmm, AFAIR it should just be a case of running H2L on the code and then running latex in a directory with all the .sty files
09:11:09 <stratocaster> Or do I just need to try reading or writing and catch exceptions?
09:11:13 <shapr> neologism: look at the bottom of http://www.haskell.org/hawiki/HaskellIrcPastePage
09:11:42 <kosmikus> keverets: are you using windows?
09:13:58 <neologism> shapr: oh, thnx
09:14:51 <shapr> betabot: @index scanr
09:14:51 <betabot> Data.List,GHC.List,Prelude
09:15:05 <phubuh> ooh
09:15:06 <shapr> betabot: @index foldM
09:15:07 <betabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
09:15:07 <betabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
09:15:07 <betabot> State,Control.Monad.Writer
09:15:37 <shapr> that uses Haddock binary index files
09:15:39 <ski> is that all modules in which a name is defined ?
09:15:42 <shapr> yes
09:15:48 <ski> nice
09:15:58 <shapr> haddock also shows which one has the original def
09:16:21 <shapr> I guess that should show in the results somehow
09:18:07 * ski learns's the word "lazy'o-phobe"
09:19:57 <neologism> I have this code:
09:19:57 <neologism>         putStr "Input number of bracket-pairs: "
09:19:57 <neologism>         c <- readLn::IO Int
09:19:57 <neologism>         putStrLn "The pairs itself:"
09:20:12 <neologism> why am I first asked to input number and THEN the string "Input..." is printed out?
09:20:39 <phubuh> that's an annoying feature called buffering
09:20:43 <shapr> line buffering
09:20:49 <shapr> use putStrLn
09:21:18 <neologism> ah...
09:21:25 <neologism> I thought its something monad related ;)
09:21:48 <vegai> isn't there a flush of some kind?
09:21:54 <phubuh> if you don't want a newline after the question, you can flush the output buffer explicitly with hFlush
09:21:59 <ski> hFlush, IIRC
09:22:06 <vegai> aye ;P
09:22:14 <shapr> I suddenly realize that @index @info and @type would be handy additions to haskell-mode, something like an eldoc clone
09:22:16 <neologism> phubuh: yes, I see
09:22:20 <ski> hSetBuffering NoBuffering should also do it, i think
09:24:58 <neologism>         hSetBuffering stdout NoBuffering
09:24:59 <neologism>         putStr "Input number of bracket-pairs: "
09:25:05 <neologism> works like a charm - thnx!
09:26:01 <ski> (though, hFlush might maybe be nicer in this case ..)
09:26:59 <neologism> I am going to print more lines with more input interleaved
09:27:06 <keverets> kosmikus: no, Debian GNU/Linux.
09:27:35 <keverets> Igloo:
09:27:36 <keverets> $ Haskell2LaTeX Lst2Gxl.lhs 
09:27:36 <keverets> No such state at line 9, character 8
09:27:36 <keverets> No such state at line 24, character 1
09:27:43 <kosmikus> keverets: never mind; it's only that I would be especially interested to get the lhs2TeX windows installer tested
09:27:48 <keverets> (and more until)
09:27:49 <keverets> Fail: Couldn't use all parsers
09:28:01 <kosmikus> keverets: but Marvin-- made a .deb for lhs2TeX
09:28:04 <keverets> kosmikus: sorry I can't help, then.
09:28:07 <keverets> kosmikus: ooh, where?
09:28:22 <kosmikus> good question
09:28:59 <Igloo> keverets: Is the code online somewhere?
09:29:25 <neologism> does -main-is in ghc 6.2.1 work for you?
09:29:32 <kosmikus> keverets: http://www.strakt.com/~martin/lhs2tex/ seems to be it
09:30:14 <keverets> Igloo: well, in a password protected svn repo.  I could post it somewhere if you're really interested.  It seems to die first on "import Text.XML.HaXml.OneOfN", then on every function definition after a "\begin{code}"
09:30:26 <keverets> kosmikus: cheers!
09:30:34 <Igloo> Ah, yes, it's Haskell 98 only
09:39:18 <keverets> any idea where I could get polytable.sty and lazylist.sty?  They seem to be necessary to make lhs2TeX really pretty.
09:39:31 <keverets> and aren't included in the deb, though documentation for polytable is :(
10:23:51 * ski 's leaving
10:53:51 <keverets> Argh.  Now lhs2TeX is giving me hassles.
10:53:54 <keverets> ! Missing $ inserted.
10:53:54 <keverets> <inserted text> 
10:53:54 <keverets>                 $
10:53:54 <keverets> l.333 \end{pboxed}
10:53:54 <keverets>                   
10:53:58 <keverets> ?
10:54:07 <keverets> (on the generated .tex)
10:54:42 <keverets> and it dies.
10:56:16 <keverets> It works for simple .lhs files, but apparantly not for mine.
10:59:19 <keverets> seems to get confused by my inline comments "-- (somedatatype)"
11:01:04 <keverets> does anyone here have experience using lhs2TeX and multiple files in multiple directories?  Any strategies for making a document with several files to be included, but marked up?
11:05:07 <shapr> hey stepcut 
11:05:16 <stepcut> hey
11:05:31 <shapr> @index newChan
11:05:32 <lambdabot> Control.Concurrent,Control.Concurrent.Chan
11:05:37 <shapr> new toy
11:05:45 <stepcut> oh?
11:06:05 <shapr> lambdabot plugin that uses haddock indices
11:06:11 <stepcut> @index reverse
11:06:12 <lambdabot> Data.List,GHC.List,Prelude
11:06:14 <stepcut> nice
11:06:31 <stepcut> @index +
11:06:32 <lambdabot> GHC.Num,Prelude
11:06:33 <shapr> next, index by type-sig
11:06:40 <stepcut> nice
11:06:51 <shapr> and cmdline versions for haskell-mode
11:06:57 <bringert> with alpha conversion of type variables?
11:07:06 <bringert> (for type-sigs)
11:07:20 <shapr> I hope so
11:07:29 <shapr> I dunno how to do that yet
11:07:40 <bringert> maybe even generalization?
11:07:57 <shapr> yah, I was wondering about that too
11:08:07 <bringert> I ask for (Int -> Int) -> [Int] -> [Int]
11:08:11 <bringert> and lambdabot says:
11:08:26 <bringert> map :: (a -> b) -> [a] -> [b]
11:09:07 <bringert> hmm, might not be what I'm looking for though
11:09:25 <bringert> since it would always say:
11:09:29 <bringert> undefined :: a
11:10:44 * shapr dunno
11:11:11 <shapr> if you think of more good ideas along these lines, I'd like to hear 'em
11:11:23 <bringert> maybe if it gets the least type that can be instantiated to the type that you want
11:11:34 <bringert> which might not be unambigous though
11:12:00 <bringert> hmm, sounds like a cool project
11:13:30 <bringert> it could try to unify the type you want with the types of all the functions it knows about, then order the matches and return the least element(s) that matched
11:13:32 <shapr> yes it does
11:13:40 <eivuokko> If you just compare if your signature unifies with a signature of a function, and return things that have "longer" signature.
11:14:26 <bringert> by "longer" you mean a more specific type?
11:14:43 <eivuokko> Yes, but I am not sure that is unambigiously said.
11:14:49 <eivuokko> Of course it is not.
11:14:53 <eivuokko> Silly me.
11:15:38 <bringert> hmm, haskell types have a partial ordering, right?
11:16:37 <bringert> so if you just return the set of functions for which there is no less specific type in the whole set of matched functions
11:16:52 <bringert> eh
11:17:02 <bringert> more specific
11:18:20 <eivuokko> Maybe just returning a) those signatures that have same number of diffrent types b) have same number of "type expressions"?
11:20:59 <shapr> what about foldl vs foldr though?
11:21:39 <shapr> type ordering sounds hard
11:23:15 <Igloo> Did you look at the papers Simon said existed?
11:23:40 <shapr> I'm trying to find the urls for those now
11:26:32 <shapr> aha, rittri at chalmers
11:27:09 <shapr> http://www.cs.chalmers.se/~rittri/
11:28:23 <shapr> dang, the links are dead
11:33:23 <shapr> http://citeseer.ist.psu.edu/108873.html
11:37:17 <kosmikus> keverets: still there?
11:50:25 <kosmikus> shapr, bringert: now that you're all talking about it ... I have been seriously thinking about writing such a type-based query tool for Haskell quite a while now, and I still plan to do it, starting next month ... I have a couple of ideas written down about a query language. I haven't looked at the rittri papers, though. Maybe he has better solutions than I have ...
11:54:44 <shapr> I didn't understand anything in my short scan of his papers
11:54:59 <shapr> lots of type theory
11:55:42 <kosmikus> I won't look at them now.
11:56:21 <kosmikus> I just said I plan to spend time on it, and if one of you should start in the meantime, it would be nice to notify me, so that I do not duplicate any work that has already been done ;)
11:57:06 <shapr> ok by me
11:58:46 <Philippa> how to tell you've made an impression on a chan full of coders:
11:58:48 <Philippa> <Kharza-kzad> Our lady of code, wise about double enders, she's smarter than me
11:58:54 <Philippa> sweet, isn't it? :-)
12:00:14 <keverets> kosmikus: just about to run to a meeting.  Back in a bit.
12:01:07 <kosmikus> hmm, I might be away again then ...
12:01:12 <kosmikus> how long?
12:27:47 <kosmikus> keverets: as far as I can see, the TeX error stems from the fact that comments are formatted as plain text, and if you have Haskell code in comments, you should switch back to code mode
12:28:06 <kosmikus> keverets: example: data Foo = Bar -- was: |data Foo = Baz|
12:29:04 <kosmikus> keverets: if you have multiple files that are included from a central TeX file, the trick is usually to %include lhs2TeX.fmt everywhere, and %include lhs2TeX.sty in the master document only
12:29:28 <kosmikus> keverets: then process every file with lhs2TeX, and only the master document with LaTeX
12:49:05 <tyl3r> evening
12:56:23 <neologism> 3
12:57:25 <shapr> 4
12:57:32 <shapr> hi tyl3r 
13:10:10 * shapr swears at python
13:12:51 * stepcut swears at perl
13:13:30 * Riastradh swears at Haskell
13:13:32 <Riastradh> Oh, wait, wrong window.
13:13:32 * bringert swears in haskell
13:13:44 * shapr laughs
13:13:54 <shapr> unsafePerformIO!
13:13:55 <andersca> data Swear = Damn | Grr
13:14:00 <shapr> um, hi duncan_ 
13:14:01 * ibid swears with haskell
13:14:08 <duncan_> hi
13:14:12 <bringert> hi
13:14:17 <shapr> hi
13:14:26 <bringert> lo
13:14:42 <shapr> bringert: you sound bouncy
13:14:43 <SamB> ibid: what do you swear with haskell?
13:14:57 <shapr> bringert: wassup?
13:15:13 <bringert> I was going to write '@eval repeat hi'
13:15:22 <bringert> but wisely decided not to
13:15:26 <shapr> whew
13:15:28 <bringert> shapr: not too much
13:15:32 <bringert> playing with GF
13:15:35 <shapr> ohh
13:15:39 <shapr> I liiike GF
13:15:49 <bringert> and once again GF /= girlfriend
13:16:33 <ibid> SamB: Blackhole detected! :)
13:16:38 <bringert> shapr: did you use 1.2 or the GF2 beta?
13:16:42 <shapr> speaking of GF, I've plugged in phubuh's Cmafihe module
13:16:52 <shapr> @cmafihe coi rodo
13:16:52 <lambdabot> Sorry, I don't know the command "cmafihe", try "lambdabot: @listcommands
13:16:52 <betabot> coi <COI> [greetings] rodo <PA4 KOhA3> [every you] 
13:16:59 * SamB does not think that is what GF means in mnet's fec.c, either.
13:17:04 <ibid> actually, i'm swearing at c++ exceptions
13:17:10 <bringert> Cmafihe?
13:17:18 <shapr> it's lojban
13:17:26 <kosmikus> hi duncan_ 
13:17:26 <shapr> @cmafihe cmafihe
13:17:26 <lambdabot> Sorry, I don't know the command "cmafihe", try "lambdabot: @listcommands
13:17:32 <shapr> urf
13:18:28 <duncan_> I turned up then :-)
13:18:36 <shapr> anyway, lojban won't be much challenge for GF, but it'll be interesting for me.
13:19:10 <bringert> I'm having a hard time with the english resource grammar
13:19:52 <shapr> are you going through the tutorial? or what?
13:20:11 <bringert> couldn't find a tutorial that uses any of the resource grammars
13:20:17 <bringert> didn't look very hard though
13:20:22 <bringert> did you find one?
13:20:41 <shapr> oh for using? the users manual
13:21:03 <shapr> that's just what the grammar manual says, I haven't tried it myself
13:21:29 <shapr> duncan_: are you Duncan Coutts?
13:21:29 <bringert> I mean using as in writing a domain specific grammar that uses a resource grammar
13:22:12 <kosmikus> shapr: yeah, Duncan is going to take over Haskell support in Gentoo from me ;)
13:22:15 <shapr> what exactly is a resource grammar?
13:22:28 <shapr> oh that's neat
13:22:35 <duncan_> yes
13:23:17 <Igloo> kosmikus: Did we win you over to Debian then?  :-)
13:23:26 <shapr> ah, ok
13:23:43 <bringert> shapr: a general grammar for a language, that can be used when implementing domain specific ones
13:23:47 <shapr> bringert: yes, the tutorial shows you how to import
13:24:27 <bringert> I've done that, but I don't understand the representation of an english adjectival phrase for example
13:24:47 <shapr> well, there's the tut2{Symb,Eng,Fra,Deu}.gf
13:24:58 <duncan_> kosmikus: not sure about that, I'm still an aprentice!
13:25:04 <bringert> shapr: where is that?
13:25:18 <shapr> that's in the tutorial archive
13:25:39 <kosmikus> Igloo: not yet :)
13:25:44 <Igloo> Does apprentice ~= NM?
13:26:10 <Igloo> Only a matter of time, I'm sure  :-)
13:26:46 <kosmikus> might be
13:27:04 <shapr> bringert: http://www.cs.chalmers.se/~aarne/GF/Tutorial/
13:27:04 <kosmikus> but I like Gentoo, and see no point in switching right now
13:27:14 <duncan_> quoi? NM?
13:27:33 <shapr> new maintainer in debian
13:27:48 <shapr> duncan_: parlez vous français?
13:28:03 <bringert> shapr: thanks, will have a look at them
13:28:12 <kosmikus> there's no such formal status as NM in Gentoo
13:28:36 <shapr> the tutorial is actually for gf1, but works just fine
13:28:46 <duncan_> ahh I see.
13:29:19 <kosmikus> Igloo: is there a way for me as a non-debian user to find out which files a .deb installs? Something like a .deb to .tgz converter?
13:29:19 <duncan_> shapr: no :-(
13:29:35 <Igloo> alien will convert between rpm, deb and tar
13:29:49 <kosmikus> ok, thanks
13:29:51 <Igloo> But ar -x doo.deb; tar -zxvf data.tar.gz will do what you want
13:30:04 <Igloo> s/doo/foo/ # not that it really matters  :-)
13:30:10 <duncan_> emerge alien
13:30:34 <Igloo> Also, packages.debian.org allows you to search for the deb a given file is in, and I think also has filelists on the package pages
13:31:33 <shapr> kosmikus: if you're on a debian system where the deb is already installed you can use dpkg -L pkgname
13:31:34 <Igloo> Oh, do you have ghc6 with gcc 3.3 on sparc in Gentoo? And if so, have you seen any problems?
13:31:35 <kosmikus> Igloo: I'm trying to confirm keveret's statement that polytable.sty and lazylist.sty are not included in Marvin--'s .deb of lhs2TeX. That one's not yet official, I think, so packages.* wouldn't help
13:31:47 <Igloo> Ah, right
13:32:22 <kosmikus> shapr: yes, but I'm not on a debian system :)
13:33:05 <shapr> ah, ok
13:33:48 <kosmikus> Igloo: no, no ghc6 on sparc in Gentoo right now.
13:34:44 <kosmikus> Unlike Debian, Gentoo still lacks much of the infrastructure to support the non-x86 architectures. For me, having access to x86 only, it's quite difficult to test for other architectures.
13:35:06 <kosmikus> However, that's going to change really soon now, if the announcements are to be believed ...
13:35:37 <Igloo> Cool
13:36:32 <neologism> kosmikus: try netbsd
13:36:41 <neologism> great support across all platforms
13:38:42 <mattam> kosmikus: and i can always test on ppc if you want :)
13:38:45 <kosmikus> neologism: it's not that I personally need the support for other platforms ...
13:39:03 <kosmikus> mattam: yes, you're the reason that ppc support is currently better than sparc :)
13:39:17 <kosmikus> duncan_: mattam is also with Gentoo
13:39:37 <neologism> kosmikus: there is even linux emulation layer
13:39:43 <neologism> but as you want..
13:39:47 <mattam> i'm more with ocaml officially though
13:40:24 <kosmikus> mattam: you do ocaml development?
13:40:58 <mattam> i do
13:41:16 <Riastradh> Development _in_ OCaml or development _of_ OCaml?
13:41:29 <kosmikus> yes, I meant "of" ...
13:41:36 <mattam> nope, not yet ;)
13:41:56 <kosmikus> Riastradh: thanks for asking the question correctly ...
13:42:18 <Riastradh> ...er...
13:42:31 <Riastradh> (that '...er...' was directed towards mattam)
13:42:43 <mattam> my bad ?
13:42:55 <kosmikus> neologism: some day I'll look at the bsd's, I'm sure
13:42:56 <Riastradh> Which? -- in or of?
13:43:04 <Joachim_> Good evening to all of you
13:43:07 <mattam> in
13:43:08 <kosmikus> neologism: if linux has become too mainstream ;)
13:43:13 <mattam> of: not yet
13:43:26 <kosmikus> s/if/when
13:43:31 <neologism> kosmikus: it never hurts.. ;)
13:43:41 <neologism> and bsd deserves it
13:44:18 <Joachim_> Well there is also plan9, if I ever have time i will try it
13:44:34 <Riastradh> Amiga!  BeOS!
13:44:49 <mattam> The Hurd
13:45:06 <neologism> I didnt want to start flamewar
13:45:09 <mattam> (had to say it)
13:45:10 <Joachim_> I do not know plan9 is not just a reimplementation of unix
13:45:14 <Igloo> Are you serious about the mainstream thing, kos?
13:45:15 <tic> beos!!
13:45:17 <Joachim_> which afaik the hurd is or
13:46:50 <mattam> a potential improvment over unix i would say
13:47:03 <shapr> hOp!
13:47:10 <kosmikus> Igloo: why?
13:47:12 <shapr> hOp hOp hOp hOp!
13:47:22 <mattam> shapr :)
13:47:33 * Riastradh straps shapr to the ground.
13:47:36 <Riastradh> Stop hopping about!
13:47:53 <shapr> I'm thinking of starting a hOp competitor based on Hugs named bOing
13:47:56 <Igloo> It seems like a rather odd attitude to me, although surprisingly many people (claim to) have it
13:48:00 <stepcut> hOp hOp!
13:48:26 <stepcut> shapr: haha
13:48:27 * shapr bOings
13:48:33 <shapr> stepcut: :-)
13:48:57 * shapr is feeling silly
13:49:06 <shapr> hOp hOp bOing!
13:51:27 <kosmikus> Igloo: I'm not really serious, yet ...
13:51:52 <shapr> man, I'm never serious.
13:52:01 * shapr hOps
13:52:10 <kosmikus> Igloo: I'm sometimes worried that in the effort of making Linux attractive to Windows users, some Linux developers are willing to sacrifice the very advantages that Linux has all to easily
13:52:23 <Joachim_> Well as nice as this is, I really wanted to get some feedback for a small haskell programm I have written. Maybe somone will entertain me ?
13:53:06 <kosmikus> Joachim_: paste the program to the wiki paste page, and some people here might look at it
13:53:09 <shapr> Joachim_: could be
13:53:21 <Igloo> Ah, if the mainstreamness comes with lossage then I'd agree, but that's not changing because it became mainstream (unless you believe the two are necessarily linked)
13:53:26 <Joachim_> Uff where is the wiki paste page ?
13:53:48 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:53:48 <bluejay> @wiki HaskellIRCPastePage
13:53:49 <lambdabot> http://www.haskell.org/hawiki/HaskellIRCPastePage
13:53:54 <bluejay> hah!
13:54:05 <Igloo> But I think it is individual distros rather than Linux that would go that way, and I don't think Debian is likely to
13:54:06 <bluejay> except mine's wrong
13:54:07 <shapr> man we need an alias
13:54:18 <Igloo> Nor Gentoo, both being non-commercial OS OSes
13:54:35 <shapr> kosmikus: what advantages do you mean?
13:54:50 <bluejay> @pastepage ;)
13:54:50 <lambdabot> Sorry, I don't know the command "pastepage", try "lambdabot: @listcommands
13:54:57 <kosmikus> Igloo: you're probably right
13:55:24 <kosmikus> shapr: the shell :)
13:55:29 <Igloo> Also, it would probably be GNOME/KDE leading the way, which would hit all OSes equally
13:55:49 <kosmikus> shapr: well, not only. but to go into the details, I don't have enough time. I should work a bit ...
13:55:53 <shapr> ok
13:56:35 * Igloo disappears too
13:56:39 <kosmikus> Igloo: that's another point: I think GNOME/KDE are a huge part of the problem
13:57:00 * shapr tries to disappear but gets caught on a deadline
13:58:34 <shapr> Joachim_: chess?
13:59:41 <Joachim_> Hmm only the routine for updatuing and displaying a board
14:00:27 <shapr> what about it?
14:01:07 <Joachim_> well for one the parse routines for reading in the Figure structure is uses simple haskell read
14:01:25 <Joachim_> but this does not recognize for example Figure (0,0) 'K' 
14:01:37 <Joachim_> So I want to make my own read routine
14:01:47 <Joachim_> But I do not know how to best go about it
14:02:02 <Joachim_> Than the outputs routines for show board
14:02:24 <Joachim_> Is there a better way to iterate over an array than map an index list over it ?
14:03:14 <keverets> kosmikus: I removed the comments that had data types in them (I was using a rather large constructor and commented each piece).  That made the errors go away
14:04:14 * bringert needs to learn more about grammar
14:04:44 <shapr> Joachim_: off the top of my head, I don't know, I'd just look at Data.Array
14:04:59 <keverets> kosmikus: also, I decided in the end to use "%include File1.lhs" and so on, from my main.ltx file (which contained %include lhs2TeX.[fmt,sty]), then I just run lhs2TeX once on that, with the -P option to add paths, to generate the main.tex file which I run latex on.
14:05:14 <shapr> @info Read
14:05:16 <lambdabot> -- Read is a class
14:05:16 <lambdabot> class Read a where {
14:05:16 <lambdabot>     readsPrec ::
14:05:16 <lambdabot> 	Int -> String -> [(a, String)]
14:05:16 <lambdabot> 	{- has default method -};
14:05:16 <lambdabot>     readList :: String -> [([a], String)] {- has default method -};
14:05:17 <lambdabot>     GHC.Read.readPrec ::
14:05:19 <lambdabot> 	Text.ParserCombinators.ReadPrec.ReadPrec a
14:05:21 <lambdabot> 	{- has default method -};
14:05:23 <lambdabot> [4 @more lines]
14:05:26 <bringert> in "BASIC is a language from hell", what is "from hell" called?
14:05:28 <keverets> I found that I then didn't need to add %include lhs2TeX.fmt to every file.
14:06:24 <shapr> bringert: isn't that an adjectival clause?
14:06:36 <tmoertel> Joachim_: you could fmap over the array.
14:06:46 <shapr> hi tmoertel, wassup?
14:06:56 <bringert> that's what I would think too, but you can't really use it as one
14:07:03 <tmoertel> shapr: not much.  just roasting some coffee.
14:07:09 <bringert> "BASIC is a from hell language"
14:07:30 <shapr> means the same thing imho
14:07:48 <shapr> though I'd say hellish
14:08:02 <bringert> but few people consider that example to be correct english
14:08:22 <bringert> it looks like an adverbial
14:08:42 <bringert> as in "I ran here from hell"
14:09:00 <bringert> but it modifies a noun phrase
14:09:05 <kosmikus> keverets: if you have large parts of code that you want to comment, it's probably best to put them into a \begin{spec} \end{spec} block
14:09:05 <shapr> right
14:09:32 <keverets> kosmikus: how's that handled differently from {code}?
14:09:48 <kosmikus> keverets: %including all files into the the main file is also possible, yes
14:09:54 <Joachim_> huh how do I use fmap to iterate over the array
14:10:13 <kosmikus> keverets: it's treated as comment by Haskell, but formatted as code by lhs2TeX ...
14:10:22 <keverets> kosmikus: the %including meant minimal changes, which seemed reasonable at the time, though I don't know of any other implications of that.
14:10:46 <keverets> kosmikus: ah, cool.  Thanks.
14:11:29 <kosmikus> keverets: apart from the fact that you might get a huge .tex file, I don't see any real disadvantages of the approach
14:12:02 <shapr> tmoertel: written any Haskell code lately? had time to try HaskellDB?
14:12:43 <shapr> bringert: maybe adjectivals need to be after their noun in english?
14:13:04 <bringert> shapr: "I am a bad person"
14:13:09 <keverets> I think they just have to sound right.
14:13:16 <shapr> good point
14:13:39 <bringert> looking at english syntax in the resource grammar, they distinguish between simple and complex adjectival phrases
14:13:44 <shapr> maybe adjectival clauses come after?
14:13:59 <bringert> simple ones come before, complex after
14:14:06 <shapr> ah, neat
14:14:38 <bringert> what, then, is a complex adjectival phrase?
14:15:21 <shapr> maybe one that involves a preposition or other dependent clause?
14:15:41 <shapr> it looks like one word adjectivals come in front
14:15:57 <bringert> yeah, that seems true
14:18:16 <tmoertel> shapr: no I haven't actually *used* HaskellDB, although I have packaged it.  :)
14:19:20 <shapr> heh, ok
14:53:48 <bringert> > p -cat=Query "which emails are from Bjorn ?"
14:53:48 <bringert> WhichAre Email (from Bjorn)
14:53:50 <bringert> yay
15:14:23 <maihem> A couple of weeks ago, somebody posted some GHC library documentation from CVS Head that included the new HOpenGL API along with HGL. I'm on a different computer than normal, so I haven't got my bookmarks. Does anybody know the URI?
15:19:46 <spenatmannen> is there a function that removes duplicate elements from a list?
15:22:02 <kosmikus> nub
15:26:21 <Lunar^> maihem: Use shapr's search web app
15:26:38 <spenatmannen> thanks
15:27:25 <maihem> Lunar^, huh?
15:27:58 <maihem> google couldn't find it, If shapr's search web app can, I'm never using google again !
15:28:40 <Lunar^> maihem: 
15:28:48 <maihem> where is shapr's search web app?
15:29:18 <maihem> ?
15:29:20 <Lunar^> maihem: (sorry wrong paste) http://shapr.homelinux.net/cgi-bin/wash/SearchML
15:31:02 <maihem> Lunar^, thanks.
15:33:14 <maihem> Hell, 32MB Pentium MMX 150MHz. trying to run GNOME 2.6 on Linux 2.6 with an epiphany window, 2 gnome terminals and XChat. it's like using MS Windows again... chugg... chugg... chugg.
15:33:39 <maihem> GNOME uses an unnecessary amount of RAM
15:36:14 <flaw> that's nonsense, its quite necessary to manage all the leaks ;)
15:36:58 <shapr> maihem: I don't have the last coupla weeks in curryspondence
15:37:38 <shapr> I am looking for a good process to keep curryspondence up to date though
15:37:53 <maihem> It wasn't on a mailing list that I saw it, "posted" was a bad word, it was here in this channel
15:38:05 <shapr> oh!
15:38:55 <shapr> in that case, I recommend agrep and the logs
15:38:57 <Lunar^> shapr: How did you feed the initial information into the databse ?
15:39:12 <shapr> I still haven't written an irc log search
15:39:19 <maihem> shapr, any idea where I can find logs?
15:39:23 <shapr> Lunar^: MboxToDB.hs
15:39:30 <shapr> maihem: in the channel topic
15:39:43 <maihem> oh. heh :)
15:40:07 <tyl3r> maihem: whats the meaning of you handle 
15:40:51 <maihem> to infure.
15:40:53 <shapr> I think it's "May home" in swedish, so maybe it's "summer house" :-)
15:41:14 <maihem> ooops, to injure
15:41:28 <tyl3r> in which language 
15:42:53 <Lunar^> shapr: Why couldn't 
15:43:01 <Lunar^> you keep the DB up to date then ?
15:43:09 <shapr> bringert: cool, should I add irc logs to curryspondence just to make your app difficult? :-)
15:43:45 <maihem> tyl3r, English
15:44:32 <maihem> it is definately not the similar Chinese word
15:48:34 <shapr> Lunar^: just that there's not a good way to do it incrementally
15:49:10 <Lunar^> shapr: Mhhh, you are actually parsing mbox
15:49:20 <Lunar^> shapr: UID are only available in Maildirs, right ?
15:50:49 <shapr> it's not in mbox for sure
15:51:36 <shapr> also, you can't guarantee that the Message-ID: header is unique, I already made that mistake
15:53:23 <tyl3r> maihem: never heard of that word, are you english native ?
15:53:35 <shapr> so I could wait till a month is over and then grab the mbox.gz for that month, but that's sort of weenie
15:54:00 <shapr> hi tyl3r, how's code?
15:54:27 <tyl3r> shapr: in progress ;)
15:54:44 <shapr> cool, whatcha writing?
15:55:07 <tyl3r> dumb stuff, a simple logic solver 
15:55:17 <shapr> sounds like fun to me
15:55:24 <tyl3r> nothing new, just a project to learn the language 
15:55:58 <shapr> if you want a fun project, you could write a lambdabot plugin
15:56:26 <tyl3r> i'll think about it .. ;) when I'll have time for my personnal projects 
15:56:30 <shapr> ok
15:57:18 <liiwi> squish
15:57:24 <tyl3r> what the current bot actually can do ?
15:57:33 <shapr> hei liiwi, you coming to EuroPython?
15:57:54 <liiwi> shapr: unfortunately njet. bad timing.
15:57:59 <shapr> tyl3r: try "/msg lambdabot @listcommands"
15:58:04 <shapr> ah, too bad
15:58:15 <shapr> have you seen dark lately?
15:58:32 <liiwi> hmm, no, been meaning to call him.
15:58:39 <shapr> or maybe short haired Virru?
15:58:41 <maihem> tyl3r, yes, English native, the word is archaic.
15:58:45 <shapr> um, Viiru
15:59:11 <maihem> related to mayhem and maim
15:59:12 <liiwi> heh, Viiru is short haired these days :)
16:00:19 <liiwi> ..and I have hickup..
16:00:21 <shapr> I gotta drop by your place one of these days
16:00:32 <liiwi> anytime
16:01:04 <Lunar^> shapr: Maybe you could look at algorithm used be offlineimap
16:01:21 <liiwi> offlineimap rocks
16:01:25 <shapr> any hackfests planned for your area in the summer?
16:01:31 * shapr looks
16:01:50 <liiwi> shapr: only informal, as they happen ones..
16:02:35 <liiwi> shapr: mention date beforehands, and something might happen.
16:03:03 <shapr> sounds good
16:03:11 <shapr> oh, offlineimap looks nifty
16:10:11 <shapr> but it doesn't appear to deal with mbox
16:23:28 <Lunar^> shapr: But IMHO you don't need to use mbox anymore
16:24:41 <shapr> but that's the format that mailman uses for archives
16:25:06 <shapr> am I being brain fried by overexposure to Zope?
16:25:58 <Jerub> mb2md
16:26:05 <stepcut> shapr: yep
16:26:08 <Jerub> maildir is a superior format ;)
16:26:26 <shapr> stepcut: :-P
16:38:36 <keverets> mbox is good for archives, though.  Maildir is much better for "live" mail.
17:10:55 <tyl3r> whats the difference between model checking and formal proof ?
18:12:03 <shapr> g'day Pseudonym 
18:36:28 <Pseudonym> G'day.
18:37:44 <Pseudonym> Quick question.  Why do all Microsoft products have to be so damn counter-intuitive, slow and generally frustrating?
18:39:10 <Jerub> Pseudonym: evil.
18:40:23 <Riastradh> Because Microsoft is too busy stealing money from everyone to pay attention to the desires of its users.
18:41:56 <Jerub> because they use their own software?
18:49:37 <Pseudonym> I just spent half a morning trying to create a document using a custom template, and then trying to check it into VSS over an SMB share.
18:49:50 <Pseudonym> It actually worked, shockingly enough.
18:50:06 <Pseudonym> After I got about a dozen message boxes telling me that all sorts of things went wrong.
18:51:22 <Pseudonym> Did I mention that I loathe and detest Microsoft?
18:51:27 <Pseudonym> Not sure if I made that clear or not.
18:51:37 <Riastradh> Then vehemently avoid using Microsoft products.
18:52:01 <Pseudonym> In this case I don't have a choice.
18:52:20 <Riastradh> What case is this?
18:54:16 <Pseudonym> The case where I and the tax man get a not insignificant amount of money in return for filling out incident reports.
18:54:29 <Pseudonym> Oh, and actually resolving incidents, too.
18:55:42 <Riastradh> You could point out that you can't afford the exorbitant prices Microsoft applies to their products without such a non-insignificant monetary quantity, and so it's necessary not to use their products...(time being money helps that argument)
18:56:26 <Pseudonym> Unfortunately it's the person in this office who is managing he support contract who has chosen this solution.
18:56:38 <Pseudonym> I could always find something solid and hit him with it.
19:03:09 <shapr> it amazes me that managers prescribe the software programmers use, would you trust a hospital where the accountants choose your treatment without any advice from the doctors?
19:04:27 <Pseudonym> Oddly enough, the person managing the contract is a fellow programmer.
19:04:30 <Pseudonym> Younger than me, in fact.
19:05:28 <shapr> hm
19:05:53 <SamB> Pseudonym: hmm. where do they get poeple like that?
19:06:32 <Pseudonym> I think he just decided to use what we had handy.
19:06:41 <Pseudonym> Which I can't really blame him for.
19:07:02 <Pseudonym> However, it doesn't speak well for us.  We do hard text processing problems for a living.
19:07:08 <Pseudonym> And we're relying on Word?!
19:07:30 <SamB> Pseudonym: you should get microsoft Emacs.
19:07:50 <SamB> I expect there is a place on microsoft.com where you can download emacs ;-)
19:08:21 <Pseudonym> The particularly frightening thing is that these reports duplicate information stored in our own very powerful text database system.
19:09:00 <shapr> that is sad
19:09:18 <Pseudonym> We should, in theory, be able to generate them automatically from the database.
19:14:45 <shapr> aha! the new typeclass paper is up
19:15:20 <Riastradh> The new typeclass paper?
19:15:28 * shapr boings
19:15:33 <shapr> http://research.microsoft.com/Users/simonpj/papers/assoc-types/index.htm
19:15:57 <shapr> I heard about this paper when it was in-progress
19:16:48 <Pseudonym> Oooh.
19:16:54 <shapr> Chilli said it'll help his parr lib
19:17:07 <Pseudonym> The idea is that a class declaration cal also define a type?
19:17:14 <Pseudonym> As in, real OO programming?
19:17:29 <Pseudonym> Trez cool.
19:20:21 <shapr> whoa, a + op that auto coerces
19:20:41 <Riastradh> parr lib?
19:21:44 <shapr> Nepal project, flattening array ops for transparent parallelization
19:22:29 <shapr> MPMD, for Program rather than MIMD
19:23:00 <shapr> data parallelism is the generic term I think
19:23:39 <shapr> class local types are freaky
19:58:49 <shapr> in section 2.2 of this paper, is this Haskell's solution to parameterizable modules?
20:01:09 <duncan_> what do we require from parameterizable modules?
20:02:04 <duncan_> a good example perhaps, so we can think about whether it would be possible with class-local data types
20:02:42 <shapr> can't think of anything at the moment
20:02:56 <shapr> though I've seen some good examples in the past
20:03:47 <duncan_> how about some data structure that uses a finite map, and we want to be able to supply different finite map implementations
20:04:47 <duncan_> I think you can already do that with ordinary classes - bad example
20:04:56 <shapr> I think that's used later in the paper for self-optimizing libraries
20:05:24 <bluejay> Parsec's docs complain about the lack of parametrizable modules for its tokenizing module.
20:06:51 <duncan_> oh yes, Daan gets around it by making you define a record of functions that lex various common things, comments etc
20:07:23 <duncan_> it's rather a pain
20:11:24 <bluejay> Do you see a way to fix that with this paper?
20:12:08 <duncan_> not yet, still reading...
20:15:16 <shapr> "this allows us to have several distinct instances of graphs, which all have the same edge and vertex types, but differ in the representation and algorithms working on the data structure"
20:15:51 <shapr> sounds great, but how do I choose instances?
20:18:31 <SamB> what is system F?
20:19:55 <bluejay> shapr: I think you use (g::G_1) or (g::G_2)
20:20:00 <shapr> it seems you create an edge or vertex type, then make it an instance of Graph, and you get to define class-local stuff for it
20:20:07 <duncan_> SamB: I was wondering the smae thing, hadn't seen it before
20:20:15 <duncan_> shapr: exactly
20:20:33 <shapr> System F is the superclass of the HM type system
20:20:41 <duncan_> ah
20:20:51 <shapr> at least, that's what I've gathered from TaPL
20:21:22 <shapr> I haven't reached the actual definition of System F yet
20:21:40 <shapr> @foldoc "System F"
20:21:42 <lambdabot> *** "system f" foldoc "The Free On-line Dictionary of Computing (27 SEP
20:21:42 <lambdabot> 03)"
20:21:42 <lambdabot> System F
20:21:42 <lambdabot>      
20:21:42 <lambdabot>         A {type system} by J-Y. Girard.  Also known as Lambda-2 or the
20:21:44 <lambdabot>         {polymorphic lambda-calculus}.
20:21:46 <lambdabot>      
20:21:48 <lambdabot>         ["Proofs and Types", J-Y. Girard, Cambridge U Press 1989].
20:21:50 <lambdabot> [4 @more lines]
20:21:56 <shapr> neat, it's really in there
20:23:07 <duncan_> more precisely, you create a graph type and its associated edge & vertex types, then you make graph an instance of the Graph class and set Edge & Vertex to your graph's associated edge & vertex types
20:23:23 <shapr> so, one advantage of this is that you can make multiple instances of a class for Int, and they can each have an implementation tuned for different applications
20:25:05 <duncan_> not sure, you mean an Int class?
20:27:55 <duncan_> they seem also to be saying that you might be able to do some of this with multi-parameter type classes with *lots* of parameters (and perhaps using functional deps) but class-local data types allows for a neater notation, but it is strictly more expressive
20:28:46 <duncan_> eg for the graph example you might image that you could simply make edge & vertex parameters to the Graph class
20:29:18 <bluejay> And I think it says the functional deps would be undecidable in some cases
20:29:40 <duncan_> right
20:31:05 <duncan_> there's also the example of C++ template traits, instead of having loads of template parameters have some that bundle up a bunch of related type parameters
20:33:18 <SamB> does this make stroustroup mad?
20:36:18 <bluejay> SamB: why would it make stroustrup mad?
20:38:16 <SamB> bluejay: I don't know. I thought he was an unreasonable sort of person?
20:39:47 <duncan_> is he annoied that people took his perfectly simple template mechanism that he intended simply for collections and made a whole generic programming / complie-time language out of it?
20:40:19 <duncan_> "It's turing complete - quick, kill it!"
20:40:38 <bluejay> I haven't read anywhere that that annoys him, and he's heavily involved in the ISO committee that's trying to make templates more powerful.
20:41:17 <np_hard> praise be to stepanov
20:41:23 <np_hard> object orientation is a hoax
20:41:35 <duncan_> a hoax?
20:41:56 <np_hard> that is a direct quote from the author of the STL
20:42:05 <duncan_> :-)
20:42:23 <np_hard> http://www.stlport.org/resources/StepanovUSA.html
20:42:44 <duncan_> well even the oop people say inheritance is overrated
20:42:49 <np_hard> "STL is not object oriented. I think that object orientedness is almost as much of a hoax as Artificial Intelligence. I have yet to see an interesting piece of code that comes from these OO people. In a sense, I am unfair to AI: I learned a lot of stuff from the MIT AI Lab crowd, they have done some really fundamental work."
20:43:12 <np_hard> kind of defeats the point of OO programming then, no?
20:43:48 <bluejay> OO doesn't have to require inheritance. STL classes can easily be thought of as self-contained "objects", despite the fact that you can't inherit from them.
20:44:13 <duncan_> it allows them to simulate parametric polymprphism and interface programming in a non type-safe way
20:44:44 * bluejay is a C++ fan. (<- disclaimer)
20:45:02 <duncan_> only occasionally do you genuinely need oop subclassing, like exesential types in Haskell
20:45:09 <bluejay> If you avoid casts, C++ is pretty type-safe.
20:46:20 <duncan_> C++ is better than Java/C# when it comes to oop design, its got the "cloud of objects" syle rather than a singly rooted class hierarchy
20:46:42 <np_hard> well, really all you need for "OO" is a style of programming based on modeling code like physical objects 
20:47:02 <Jerub> bah, OOP is orthogonal to Typing, which is the major difference between C++/Java
20:47:03 <bluejay> oh, I see. templates aren't directly type-checked, but they compile to C++ code, which is. And you can do some neat tricks to get the compiler to give better error messages for templates.
20:47:37 <duncan_> The only oop people I hear saying not to use inheritance too much are the C++ people, in Java its subclassing all the time
20:47:57 <np_hard> implements over extends
20:48:08 <Pseudonym> Right.  There are three reasons for that.
20:48:09 <bluejay> The C++ people say to replace all of your switch/case statements with virtual functions.
20:48:15 <Jerub> delegation > inheritance
20:48:22 <Pseudonym> 1. You don't need inheritance for template arguments.
20:48:26 <Pseudonym> (You only need "concepts".)
20:48:33 <np_hard> replace them with 
20:48:44 <np_hard> (cond (( .. )))
20:48:46 <np_hard> :)
20:49:07 <Pseudonym> 2. C++ doesn't have interfaces, like Java.
20:49:18 <Pseudonym> 3. Inheritance is hard to scale.
20:49:34 <duncan_> it has multiple inheritance whcich allows interfaces
20:49:51 <Pseudonym> duncan_: It has multiple _virtual_ inheritance which allows interfaces.
20:49:57 <duncan_> yes
20:50:04 <Jerub> I like haskell's class system.
20:50:06 <Jerub> :)
20:50:14 <duncan_> me too
20:50:22 <Pseudonym> However, a C++ programmer is more likely to use a design pattern instead of using virtual inheritance.
20:50:23 <bluejay> If you don't have any data members (like an interface), virtual inheritance is equivalent to normal inheritance.
20:50:26 <Pseudonym> e.g. a proxy
20:50:29 <Jerub> Pseudonym: interfaces are a subset of multiple virtual inheritance semantics!
20:50:39 <np_hard> i really don't care much for C#, Java, C++, or Perl
20:50:44 <Pseudonym> Jerub: Yes, that's true.
20:50:58 <Jerub> Pseudonym: and also, delegation > inheritance.
20:50:59 <np_hard> would much rather C, Python, Lisp, Haskell
20:51:01 <Pseudonym> #3, however, is the real killer, I think.
20:51:12 <Jerub> I hate inheritance, I find very little use for it most times.
20:51:20 <Pseudonym> If a class is inheritable, then it effectively defines two interfaces.
20:51:26 <Pseudonym> There's the "public" interface and the "child" interface.
20:51:36 <Pseudonym> And documenting and managing that in a large project is hard.
20:51:38 <duncan_> Pseudonym: what sort of scaling problems? eg..
20:51:47 <Jerub> Pseudonym: exactly.
20:51:53 <np_hard> what I hate is casting objects from Java collections
20:52:00 <Pseudonym> It doesn't scale as well as other techniques.
20:52:03 <Jerub> np_hard: that's solved in 1.5 with generics.
20:52:13 <np_hard> and explaining map , filter, and fold in baby talk every time I loop
20:52:25 <Pseudonym> This is why C++ programmers don't like inheritance much.
20:52:36 <Pseudonym> I'm a C++ programmer, and I don't, either.
20:52:38 <Jerub> np_hard: there is also for (Foo i : c.getEnumeration()) { } I think.
20:52:46 <Jerub> don't remember the exact semantics tho.
20:53:06 <np_hard> we are still coding to 1.3.1
20:53:13 <bluejay> Java doesn't have operator overloading. :-P /me gets annoyed with Java every time I try to use it.
20:53:14 <np_hard> when we code to it at all
20:53:14 <Pseudonym> I use it for exactly two things: Either to implement an idiom which requires inheritance, or if the types are truly Liskov substitutable.
20:53:18 <Jerub> I'm a php programmer, and the one thing that has taught me is the difference between OOP and the Typing system.
20:53:21 <np_hard> my team is quite schizophrenic
20:53:46 <Jerub> (php has no typing system)
20:53:47 <Pseudonym> The other thing, of course, is that C++ isn't an object-oriented language.  It's a multi-paradigm language which supports OO constructs.
20:53:57 <Pseudonym> Haskell is also a multi-paradigm language.
20:54:05 <Pseudonym> Which is something that I like about it.
20:54:07 <np_hard> one guy wants to do everything with automagic IDE code generation in Java
20:54:16 <Pseudonym> Java is not multi-paradigm.
20:54:16 <np_hard> another writes some crazy perl
20:54:39 <np_hard> I am pushing people towards Python over Perl
20:54:39 <Jerub> np_hard: and you write haskell.
20:54:42 <np_hard> hehe
20:54:44 <np_hard> not at work!
20:54:48 <np_hard> that would not go over well
20:54:49 <np_hard> :)
20:54:58 <Jerub> np_hard: I have managed to make a workmate go to python!
20:55:05 <Jerub> without advocasy!
20:55:10 <duncan_> The only time I can think of when you want more the Haskell polymorphic types & type classes is when you want a list of things implementing an interface (eg an IO input stream) but you don't rquire the underlying implementations to all be the same, IOStream i => [i] doesn't give you that
20:55:14 <SamB> C++ allows you to shoot yourself in the foot in a variety of paradigms, you say?
20:55:21 <np_hard> of course, the shell script pipelines I end up implementing in perl & python are functional programming, of sorts
20:55:27 <bluejay> Pseudonym: Could you expand on "Haskell is multi-paradigm"?
20:55:39 <np_hard> stdin and stdout might possibly be the coolest interface abstraction ever
20:55:41 <np_hard> :)
20:55:45 <Jerub> bluejay: OOP is possible in haskell, but not necessery.
20:55:54 <Pseudonym> bluejay: Sure.  Haskell is functional, primarily.
20:55:56 <duncan_> "Haskell is the world's finest imperitive language" -- Simon PJ
20:56:00 <Pseudonym> But it also supports imperative programming.
20:56:05 <Pseudonym> Yes, like Simon PJ notes. :-)
20:56:10 <Pseudonym> It also supports OOP.
20:56:19 <bluejay> Imperative: You mean with do in IO?
20:56:19 <SamB> bluejay: it supports pure functional *and* imperative at the same time!
20:56:23 <Pseudonym> It even supports a limited form of logic programming, with the appropriate libraries.
20:56:25 <np_hard> finest language, libraries very rough
20:56:34 <duncan_> sort of OOP, via exesential types
20:56:48 <Pseudonym> But really, I mean "multi-paradigm" in the Coplien sense.
20:56:58 <Pseudonym> I'll try to explain.
20:57:00 <duncan_> mmm, libs need work
20:57:08 <SamB> np_hard: it isn't fully discovered yet ;-)
20:57:22 <SamB> and yes, it does need more libraries
20:57:30 <duncan_> I'm working on gtk2hs
20:57:31 <Pseudonym> Software design is a process of analysing the problem space and matching the bits up to the solution space (i.e. the language).
20:57:46 <Pseudonym> Coplien noted that the problem space is based around families.
20:57:59 <Pseudonym> There are families of "things" which are similar in some ways and different in others.
20:58:21 <np_hard> how is syntaxpolice's library repository project going?
20:58:38 <Pseudonym> And his thesis was that for a given set of similarities and differences, there is either a language feature or there is an idiom/
20:59:11 <Pseudonym> Each solution is a "paradigm", and languages which support more than one or two solutions is "multi-paradigm".
20:59:40 <Pseudonym> It's kind of hard to explain.
20:59:44 <duncan_> np_hard: is that the hslibs one on sourceforge?
20:59:59 <np_hard> dunno, haven't kept track of it
21:00:33 <duncan_> must sleep now...
21:00:34 <Pseudonym> www.netobjectives.com/download/CoplienThesis.pdf
21:00:38 <Pseudonym> Best just to read that, I think.
21:00:49 <bluejay> Pseudonym: That's all right, I think I understand. C++ doesn't do functional programming quite as well, and Haskell doesn't (seem to) do OOP quite as well, but they get the others about equally, I think.
21:00:59 <Pseudonym> Right.
21:01:12 <Pseudonym> C++ can simulate quite a bit of FP.
21:01:18 <Pseudonym> And Haskell can simulate quite a bit of OO.
21:02:28 <Pseudonym> bluejay: You should really read that PhD thesis, though.
21:02:32 <Pseudonym> I think you'd get a lot out of it.
21:02:41 <Pseudonym> Coplien is a C++ guy.
21:04:48 <bluejay> ouch, 276 pages
21:05:09 <Pseudonym> Yes.  If you have access to a well-stocked library, the book version might be better.
21:05:35 <bluejay> I'll try to get around to it over the summer
