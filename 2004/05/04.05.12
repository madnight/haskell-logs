00:50:12 <shapr> good morning #haskell!
00:50:23 <Jerub> good morning shapr!!!!!
00:50:36 <shapr> what's going on?
00:52:58 <andersca> hey hey
00:54:32 <shapr> hej andersca 
00:54:59 <shapr> hej Jerub 
01:10:29 * shapr bounces
01:12:42 <shapr> bonjour kowey
01:12:51 <shapr> comment Ã§a va?
01:13:38 <kowey> bonjour shapr, it goes, how are you?
01:13:40 <kowey> hi room
01:13:52 <shapr> I'm awake and coding!
01:14:12 <kowey> lordy, it must be 4h where you are
01:14:38 <shapr> actually, it's just after 10am
01:15:09 <kowey> uh... something eurohaskell related?
01:15:22 <shapr> I live just south of the arctic circle in Sweden
01:15:51 <shapr> are you coming to EuroHaskell?
01:15:58 <kowey> oh... sorry... i remembered something vaguely about Georgia (US)
01:16:25 <shapr> oh, I'm from the southeast, yes.
01:16:38 <kowey> hmm... looks not... i'll be hurrying to finish my masters thesis
01:16:48 <shapr> Alabama in fact, but I live in the far north.
01:17:50 <shapr> hopefully next time
01:18:42 <kowey> yea... sounds like fun... plus meeting real people instead of irc nicks
01:19:21 <shapr> well, I think it's easier to really cnow someone on irc, since you're not distracted by other factors.
01:20:23 <shapr> maybe that's just me though
01:20:31 * kowey ponders
01:20:58 <Jerub> I'm considering entereing in ICFP
01:21:07 <shapr> Jerub: do it!
01:21:21 <Jerub> python is allowed?
01:21:36 <Jerub> unless its a compiler, my haskell just isn't good enough
01:21:39 <shapr> any lang I think
01:21:57 <shapr> maybe it will be a compiler
01:22:07 <Jerub> if it is, then I'll be writing it in haskell
01:22:39 <shapr> anyway, I like ICFP because it stretches my skillz
01:23:19 <vegai> shapr: I think those factors are 95% what there is to a human
01:23:25 <vegai> so, in IRC, you can know that 5% of a person
01:23:47 <kowey> yeah, but shapr is right in that the 5% is actually pretty big
01:23:57 <vegai> no, I don't think so
01:23:59 <kowey> and often overlooked because people are staring at your hair
01:24:10 <vegai> yes ok, _that_ is not so important
01:24:14 <shapr> yah, really, have you seen MY hair? ;-)
01:24:34 * vegai has very little in that departement ;P
01:24:51 <kowey> but i think i agree in vegai, stuff like body language, gut feelings, etc
01:24:53 <shapr> my hair from yasterday --> http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
01:25:08 <Maddas> See, even the hair matters in IRC.
01:25:13 <shapr> "yesterday" eesh
01:25:14 <Maddas> Err, even in IRC the hair matters.
01:25:15 <Maddas> :-)
01:25:23 <Maddas> shapr: wicked!
01:25:26 <vegai> Maddas: well, splitting of it, anyway
01:25:49 <Maddas> shapr: I like that grimace, too. Can I hire you to scare small children? :-P
01:25:54 <shapr> heh!
01:27:53 <Jerub> http://thorne.id.au/
01:28:00 <shapr> anyway, I think the person behind the eyes is the most important part
01:28:58 <Jerub> I'm tempted to get a haircut.
01:28:58 <shapr> and you get to see more of that on IRC
01:29:01 <Maddas> Yes, me too, but I don't think that person is necessarily reflected very well on IRC :-)
01:29:02 <shapr> me too
01:29:03 <vegai> but you can't bring all of that to here
01:29:28 <shapr> what parts are missing?
01:29:51 <vegai> the parts you don't want to reveal =)
01:30:18 <Maddas> Or that you think you don't want to reveal, or that aren't conveyed very well through a text-based medium :-)
01:30:22 <Jerub> shapr: install shtoom!
01:30:42 <Maddas> (or at least can't express very well through a text-based medium)
01:30:57 <Jerub> sip:jerub@divmod.com
01:31:10 <shapr> I think the way a person conducts themselves shows through
01:32:12 <vegai> well, I guess it's not so serious here, since most here have relatively high literacy skills
01:32:42 <Jerub> vegai: I chat with some people with extremely low literacy skills.
01:32:51 <Maddas> Oh, I'm not saying it doesn't show through, I just think that it doesn't necessarily show through very well
01:32:55 <Jerub> its interesting, educating, and you definately still make contact with the kind of person they are.
01:33:01 <vegai> really?
01:33:11 <vegai> you've met them in person beforehand?
01:33:52 <Jerub> yes, some before I met them on irc, some aftger.
01:34:15 <vegai> hmm
01:34:28 * vegai thinks about devious plots to bring more credits to him from this.
01:34:37 <Jerub> I often don't actually get along with some of these people, but that would be the same in meatspace too I feel.
01:35:33 <vegai> it would be interesting to meet an extremely intelligent person with no literacy skills
01:35:41 <shapr> I met a bunch of #haskellers for the first time in Uppsala last year
01:35:48 <Jerub> never extremely intelligent
01:35:59 <Jerub> I've often met intelligent people who can't string sentences together tho
01:36:34 <vegai> Jerub: in today's world, such a person would have to be an aboriginal or some such
01:36:39 <Jerub> one I'm sure its actually dyslexic.
01:36:47 <Jerub> but he doesn't know it
01:37:15 <shapr> yah, oral traditions could count as educated as well
01:37:24 <kowey> on the other hand, there's a special kind of mental handicap where you have fantastic language skills
01:37:32 <Maddas> I think it's easier to get along and not get along with people in IRC, since you can more easily restrain yourself from doing silly things (and the other way around).
01:37:33 <kowey> but an iq of like 70
01:37:43 <vegai> hmm, right
01:37:47 <Jerub> Maddas: if only that were true.
01:38:01 <Maddas> I find it so.
01:38:11 <Jerub> Maddas: many people feel anonymous because they don't realise that the 8 character nick they just entered is a person, and will soon BE them.
01:38:24 <vegai> Maddas: there are those who find it much easier to insult others and generally act like an ass than in real life
01:38:25 <Maddas> Yes
01:38:40 <Maddas> I also meant to say that it is easier to insult others and generally act like an ass.
01:38:46 <Jerub> and when people feel anonymous, they're often complete and utter ... well, I won't go into that.
01:38:53 <Maddas> I also find it easier to be very tolerant of asses, though.
01:38:57 <vegai> "get along and not get along" confused me, sorry =)
01:39:01 <Maddas> :-)
01:40:28 <shapr> but that's part of how someone conducts themself, imho
01:40:45 <Maddas> Yes, that's what I mean
01:41:01 <shapr> if someone thinks they are totally anonymous in a situation, what do they do?
01:41:06 <Maddas> I find it rather hard to be more of an ass than I normally am in real life
01:41:16 <shapr> same for me
01:41:26 <Maddas> Which is why I mean that on IRC, you behave differently :-)
01:41:34 <Maddas> Not necessarily for the better or the worse
01:41:41 <Maddas> Maybe not even differently, hm.
01:41:56 <Maddas> But you don't necessarily shine through as the person you generally are in real life :-)
01:42:22 <vegai> I guess there's the possibility that who we are in IRC is closer to reality
01:42:44 <vegai> some people _are_ sociopaths, but hide it well in real life
01:42:52 <shapr> yup
01:43:44 <shapr> but, everyone has a different internal balance and you can often turn disadvantages into advantages
01:43:47 <Maddas> Maybe also the other way round :-)
01:44:36 <shapr> even sociopaths can be useful for a society when contribute
01:44:58 <shapr> er "when they contribute"
01:45:49 <Maddas> I don't think sociopaths are considered 'not useful' for society, merely having a problem communicating with it
01:45:58 <shapr> or fitting into it
01:46:02 <Maddas> indeed
01:46:26 <Maddas> Many geniuses (spelling?) didn't fit in well
01:46:43 <shapr> yup
01:47:12 <earthy> `antisocial personality disorder is also known as psychopathy or sociopathy. Individuals with this disorder have little regard for the feeling and welfare of others'
01:47:34 <shapr> earthy: but they have regard for themselves
01:47:49 <shapr> so the intelligent sociopath would learn how to emulate
01:47:52 <earthy> do they now?
01:48:05 <shapr> my opinion of course
01:48:10 <earthy> they may have, yes.
01:48:34 <shapr> have you read Heinlein's "The Laziest Man" ?
01:48:39 <earthy> nope
01:49:26 <shapr> it's about putting in work early to avoid more work later
01:50:08 <earthy> sounds like the three virtues of a programmer.
01:50:23 <earthy> laziness, impatience and hubris
01:50:32 <shapr> I think that contributing greatly to your society is one the most beneficial selfish things you can do for yourself
01:50:42 * earthy nods
01:51:12 <shapr> so, a smart selfish sociopath would do that
01:51:42 <earthy> that'd be one hell of a smart guy
01:51:45 <shapr> sadly, it seems there are too many stupid sociopaths
01:51:55 <earthy> it tends to come with the territory
01:54:19 <shapr> doesn't make much sense to me, peace and prosperity affects everyone in a society, so selfish people would promote that.
01:54:54 <earthy> ah, but the issue is that the other people tend to have negative effects on your own peace and prosperity
01:55:49 <earthy> therefore there is less use in making things better for them as well if with the same effort you can make things even better for you
01:56:07 <earthy> and the concept of `better' may well be skewed in a sociopaths mind
01:56:23 <shapr> hm
01:57:07 <shapr> the way I see it, if you can get these other people to be your friends, they'll help you out
01:57:37 <shapr> imho, altruism and selfishness are the same thing from a long term viewpoint
01:58:09 <earthy> but you're not a sociopath, obviously. ;)
01:58:34 <shapr> or maybe I'm just a really smart one ;-)
01:59:27 <earthy> take the example of a sociopath rapist. he'll reason: `having sex is good, therefore having more sex is better, so, if I were to have sex with that woman over there I'd have more sex and she'd have more sex and we both benefit'
02:00:00 <shapr> that sounds like a lack of empathy
02:00:08 <earthy> and, for the rapist, the benefit is there, and he can't see the negative effect on the rapee
02:00:26 <earthy> shapr: which is quite exactly the problem with sociopaths. total lack of empathy.
02:00:31 <shapr> aha
02:01:04 <shapr> I think I have too much most of the time
02:01:31 <earthy> that is dangerous as well ;)
02:01:36 <shapr> yup
02:04:08 <shapr> vegai: are you coming to EuroHaskell?
02:21:21 <kowey> looks like HaWiki's been spammed
02:21:23 <ishaskellgudd> hi
02:21:28 <kowey> is there a revert thingy?
02:21:32 <ishaskellgudd> anyone do a webserver in haskell yet?
02:21:40 <ishaskellgudd> i saw wash
02:21:51 <JaffaCake> ishaskellgudd: yes
02:21:52 <ishaskellgudd> I dont know if haskell is nex gr8 thing but hell
02:22:22 <shapr> kowey: yes, there's a revert, I can do it
02:22:34 <JaffaCake> ishaskellgudd: fptools/hws in CVS is the web server I wrote a while back
02:23:11 <kowey> shapr: ahh... found it... (i'm used to mediawiki)
02:23:14 <shapr> kowey: it's clean
02:23:37 <ishaskellgudd> hm?
02:23:49 <shapr> sadly, there's not a ban by IP list on the Haskell Wiki
02:24:11 <shapr> ishaskellgudd: haskell is spiffy
02:25:08 <shapr> very spiffy
02:26:15 <shapr> ishaskellgudd: you have any more questions? want the url to some tutorials?
02:28:58 <eivuokko> Ask Shapr (about Haskell) ;)
02:30:07 <shapr> I think the leet expression is "haskell r0xx0rsG
02:31:33 <shapr> ishaskellgudd: you want to see some demos?
02:37:47 <ishaskellgudd> yeah
02:37:50 <ishaskellgudd> where
02:38:20 <shapr> @laern
02:38:20 <lambdabot> Sorry, I don't know the command "laern", try "lambdabot: @listcommands"
02:38:25 <shapr> @learn
02:38:25 <lambdabot> http://www.haskell.org/learning.html
02:38:31 <shapr> that's the tutorials page
02:38:52 <shapr> here's the impatient summary : http://www.scannedinavian.org/AvianWiki/HaskellDemo
02:39:32 <shapr> here's something I wrote in three or four evenings after work: http://shapr.homelinux.net/cgi-bin/wash/SearchML
02:39:46 <shapr> it's about 200 lines of code
02:41:33 <eivuokko> Is that good to use?  I mean, I have downloaded archives and grepped them until now.  Webbiethingy would be nice :)
02:41:59 <shapr> it's decent
02:42:21 <shapr> to be good it needs a few more things
02:42:50 <shapr> like, a cron job to do regular updates
02:42:59 <Jerub> shapr: does that grep mime encoded emails as well?
02:43:03 <shapr> not yet
02:43:14 <shapr> but that would be easy to add
02:43:16 <eivuokko> Well, I meant if you mind as it takes your processor time and bandwidth.
02:43:25 <Jerub> shapr: I tried to find an email the other day that I *knew* was mime encoded, but couldn't use any rational tools to find it.
02:43:33 <shapr> oh, it's on a dual Athlon MP
02:44:04 <shapr> Jerub: I'm partway through the text demiming code
02:44:41 <shapr> it's pretty easy with WASHMail
02:44:54 <eivuokko> Cool, that thing is usefull.
02:45:12 <shapr> it also needs some CSS to get it away from butt ugly
02:48:03 <Lunar^> shapr: Talk about your butt :p
02:48:38 <Lunar^> shapr: Maybe you could take the new Haskell.org CSS as a basis ?
03:05:31 <Shammah> evening jerub.  shapr.  et al.
03:05:43 <Jerub> evening.
03:05:44 <Jerub> :)
03:07:00 <Shammah> is anyone able to give a brief description of what it means to say a diagram 'commutes' in category theory?
03:07:11 <Shammah> (or point me to a good description?)
03:07:38 <Shammah> or more to the point.  How a diagram might *not* commute.
03:11:26 <shapr> Lunar^: oh, good idea
03:11:44 <shapr> Shammah: yes
03:12:15 <shapr> Shammah: this should help - http://www.xp123.com/wwake/dissertation/model.shtml
03:12:20 <Igloo> JaffaCake: The unaligned problem disappeared when I recompiled GHC, incidentally. Possibly newer ghc or gcc fixed it.
03:12:27 <ibid> i think it means this: regard a diagram as an edge-labelled graph. then if there are two distinct paths from a vertex to another, then the corresponding terms appropriately constructed from the labels must be equal
03:12:53 <Shammah> shapr: cool, 'cause I'm currently working my way through Pierce's book, and I think I have a couple of conceptual gaps 'causing me trouble.
03:13:04 <shapr> oh, that't the commutative square thingy, right?
03:13:46 <ibid> commutative diagrams are used in many branches is mathematics, not just category theory
03:13:52 <Shammah> shapr: thanks, I'll take a look at that.
03:14:18 <Spark> why is it a "branch" of maths, but a "field" of science? :)
03:14:38 <Spark> how far does this "nature" them stretch
03:14:39 <Jerub> http://www.dangermouse.net/cgi-bin/comic.pl?comic=470 <- slightly relevent webcomic.
03:14:47 <shapr> math is one tree in the forest next to science :-P
03:14:50 <Spark> can you get a mushroom of philosophy
03:15:17 <ibid> Spark: i believe that the idea is that fields of science have branches :)
03:15:39 <Spark> thats not analogous with anything :)
03:15:49 <Shammah> ibid: ok, so is it possible for that not to hold? As I understood it, an arrow as a mapping from an C-Object A -> C-Object B.  If you have two arrows f:A->B and g:A->B aren't they the same arrow?
03:16:33 <Shammah> spark: 'cause mathmatics has traditionally been considered a field of science.
03:16:58 <Spark> ah
03:18:04 <ibid> Shammah: there is a category where the arrows are ordinary functions.  is it then necessarily true that two functions f : A -> B and g : A -> B are the same function?  (say, A = the natural numbers, B = the real number field)
03:18:54 <ibid> Shammah: it is useful sometimes to consider concrete examples when you are considering abstract definitions :)
03:19:02 <Shammah> ibid: granted :)
03:23:00 <Shammah> ibid: ah, that makes more sense now.  Thanks.
03:24:27 <Shammah> I had managed to get it into my head that the category would be natural numbers, and the arrows would be various transformations between them; which led to my difficulty.
03:25:36 <ibid> :)
03:26:16 <shapr> Jerub: man, that comic is great
03:26:22 <shapr> http://www.dangermouse.net/cgi-bin/comic.pl?comic=50
03:28:13 <ibid> i once heard a nice concept to describe similar effects: "abstraktin paikan kammo" (roughly translated "fear of abstracts", compare to "fear of heights" :)
03:28:18 <Jerub> shapr: :))
03:28:36 <Jerub> shapr: go to the root of the website, the same dude has a page on some esoteric computer languages.
03:28:57 <shapr> wow, this guy has some really evil puns
03:29:32 <shapr> whoa, he plays icehouse
03:29:43 <shapr> I have that and the blackice expansion
03:30:05 <Jerub> shapr: there are some really nasty ones.
03:30:10 <Jerub> shapr: make sure you turn on annotations.
03:32:15 * Jerub goes to dinner.
03:35:10 <juhp> shapr: http://www.dangermouse.net/irregular/cast/nigerianfinanceminister.html ;)
03:36:58 <shapr> whoa, this is great
03:37:25 <Shammah> heh.  I'll have to start following this one :)|
03:38:26 <Jerub> shapr: find the star wars bit where they go into the thermodynamics of coruscant.
03:38:30 <Jerub> ;)
03:39:49 <Shammah> http://www.dangermouse.net/cgi-bin/comic.pl?comic=24
03:41:19 <shapr> the philosophy strip had me rolling
04:02:56 <ibid> which one?
04:03:35 <Shammah> shapr: the philosophy pun strip?
04:06:15 <shapr> http://www.dangermouse.net/cgi-bin/comic.pl?comic=57
04:06:20 <shapr> yes, that one
04:24:27 <earthy> ah, the Piet programming language. :)
04:49:27 <shapr> man, bagley's shootout gets argued about every coupla months
04:49:43 <shapr> let's make a shootoutwiki
04:49:52 <earthy> it needs someone to take over the stuff and republish it.
04:49:55 <shapr> yup
04:50:04 <earthy> not me. :P
04:50:11 <shapr> I'm tempted
04:50:39 <shapr> on the other hand, it would cut down on the time I can write Haskell code
04:51:27 <earthy> ;)
04:51:44 <eivuokko> *shrugs* Constant flame generator for any emails assosiated with it.
04:51:58 <shapr> eivuokko: true
04:52:31 <vegai> I bet that shootout has been good publicity for ocaml
04:52:50 <eivuokko> Heh, yea.
04:52:50 <shapr> everytime I think about this sort of thing, I remember _joey
04:53:02 <eivuokko> Who's that?
04:53:38 <vegai> ...and therefore good publicity for FP in general
04:53:39 <shapr> was taking a Haskell class in .au, and showed up to ask questions while telling us that Haskell "was stupid"
04:53:57 <shapr> and that Java, C, etc was far superior
04:54:01 <vegai> Haskell is quite stupid ;)
04:54:12 <shapr> so I said "draw pardner"
04:54:16 <vegai> hehh
04:54:46 <shapr> we each choose a half hour code task, then we each write them in our favorite language and compare
04:55:01 <shapr> shapr's shootout
04:55:24 <vegai> you shot him in the head?
04:55:32 <shapr> nah, he wouldn't compete
04:55:55 <vegai> strategic retreat
04:56:01 <shapr> then I realized it was in fact religious fantaticism, not anything based on reality
04:56:47 <vegai> well of course
04:57:00 <shapr> so everytime I think "hey, we could all learn cool stuff from another shootout" someone with more good sense like eivuokko reminds me that this is actually a religious issue
04:57:30 <vegai> hmm
04:57:36 <vegai> a shootout is actual empiric data, is it not?
04:57:46 <shapr> it can't be
04:57:56 <shapr> choice of tests for example
04:58:06 <shapr> "modify a variable"
04:58:14 <shapr> Haskell doesn't do that
04:58:48 <shapr> or "run 200,000 processes at the same time" which is only Erlang as far as I know
04:59:06 <vegai> how should one measure languages, then? 
04:59:12 <shapr> I think Andrew Cooke's quote on the QuotesPage sums this up
05:00:02 <shapr> vegai: according to what you need right now for this task in front of you
05:00:09 <shapr> that's my opinion
05:00:17 <vegai> shapr: problem is, that there are so many choices
05:00:21 <vegai> overlapping ones
05:00:53 <shapr> most problems have enough constraints to filter out a lot of these choices
05:00:57 <shapr> imho
05:01:29 <vegai> then someone saying "I know C very well" would filter every other language based on that
05:01:41 <shapr> I think the best thing you can do is to learn a lot of different styles, languages, etc
05:01:44 <vegai> which would be sensible if the next problem has to be done in 2 hours
05:01:50 <vegai> but what about the farther future
05:01:54 <shapr> and then make your choices based on what you know
05:02:10 <liiwi> shapr: yess
05:02:35 <liiwi> shapr: incidentally, same applies to martial arts
05:02:36 <vegai> a lot of redundant work there, then ;P
05:02:44 <shapr> not really
05:03:04 <liiwi> easier to learn third if you already know two well
05:03:14 <vegai> liiwi: oh yes, that's right
05:03:17 <shapr> the stuff you've learned in Haskell and C transfers easily to Mercury
05:03:45 <shapr> maybe not always easily
05:03:49 <eivuokko> Heh.
05:04:13 <eivuokko> Mercury is kinda hard what I've seen ;)
05:04:21 <shapr> but if it dosn't change your thinking it's not worth learning
05:04:28 <vegai> what about those crazy ideas that learning a certain language ruins your brain?
05:04:35 <eivuokko> Especially I hate implicit parameters, which confused me to no end.
05:04:49 <shapr> vegai: is English your first language? :-P
05:05:01 <vegai> shapr: hmm? =P
05:05:26 <kowey> i'm brain damaged! (BASIC from 3rd to 10th grade)
05:05:37 <shapr> did learning English mean sina en puhu suomea ?
05:05:56 <vegai> shapr: I never said they were _my_ ideas =)
05:06:47 <shapr> my opinion is that programming ideas can be separate from language
05:07:18 <shapr> I think a good example of this is describing coroutines to C programmers
05:07:55 <vegai> (btw: "sinä et puhu suomea")
05:08:03 <earthy> yeah, it's hard to see how that works in C
05:08:17 <shapr> it takes awhile for theme to realize that a) a function call is not an atomic operation and b) you don't ever have to return from a call unless you really feel like it
05:09:22 <shapr> so, I think that vocabulary affects the novice's model of the world lots, but that with experience you can separate your knowledge from your vocabulary
05:09:47 <shapr> vegai: thanks for the correction btw, I need to work on my finnish :-)
05:10:50 <shapr> I think Dijkstra's comments about that is that it's hard to make the jump from a less detailed conceptual model to a deeper one
05:11:11 <vegai> what other language conjugates "no"?
05:11:12 <vegai> =)
05:11:16 <shapr> heh
05:11:36 <shapr> truly finnish is both nifty and terrifying
05:11:46 <vegai> Dijkstra was probably not all serious either
05:11:50 <shapr> seventeen cases
05:12:04 <vegai> or was exaggerating rather
05:12:15 <vegai> yes, the cases. Even we hate them
05:12:16 <earthy> Dijkstra had a habit of stating things in the extreme
05:12:23 <shapr> he was probably being frustrated because his students had to unlearn so much
05:12:55 * earthy nods
05:13:30 <shapr> I suspect that asm and lambda cal should be taught in parallel while showing the similarities and differences
05:13:54 <shapr> then you have a class where both C and Haskell make perfect sense
05:14:23 <earthy> hm.
05:15:58 <shapr> anyway, I'll stick with Andrew's quote which is sort of like "there's a lot of cool stuff to learn out there, but you can't use anything for everything"
05:17:08 <shapr> vegai: honestly, I think the best stuff happens on the borders between 'levels' of complexity
05:17:15 <shapr> Python and C for example
05:17:44 <shapr> one reason I like Haskell so much is that it's good for making levels on top of it
05:18:16 <shapr> vegai: what do you think? how do you measure a language?
05:19:48 <reffie__> but then haskell is not really between any level of complexity
05:20:21 <shapr> it has lambda cal under it
05:20:32 <shapr> and FFI gives you C/asm if you want
05:20:47 <shapr> you should look at the Core output from GHC
05:21:23 <shapr> "It's Just a Simple Functional Language" -- Simon Peyton-Jones
05:22:49 <shapr> I wonder if Haskell is at the level of C for Functional Programming? I hope I get to see much higher level stuff in my lifetime
05:25:05 <Shammah> Heh, it's not that hard to explain coroutines to a C programmer.  They tend to write alot of FSM's, and so you can explain a coroutine as unrolled FSM's.  Misses a few of the finer details, but provides an immediate motivation  (especially if they've tried doing the same thing with threads instead)
05:29:27 <shapr> ok, what about explaining continuations to a C programmer?
05:29:38 <Shammah> lol
05:29:49 <Shammah> That's more difficult.
05:30:26 <Shammah> but I start by discussing last-call-optimisation.
05:30:35 <shapr> ah, good point
05:30:45 <Shammah> then move to recusive list-walking.
05:30:45 <Igloo> Could you roughly explain it in terms of an event loop?
05:31:05 <Shammah> then move to the problem of trying to do a tail-call over a tree-walk.
05:31:10 <shapr> I have to remember the tail-call explanation trick
05:31:44 <Shammah> which leads to the concept of CPS.
05:32:24 <Shammah> (they tend to get LCO quickly, C-programmers tend to be good at picking up on optimisation tricks ;)
05:32:32 <shapr> do you have that online somewhere? it sounds good
05:33:08 <shapr> Igloo: like what?
05:33:12 <Shammah> from CPS they will either understand, and generally comment on the need to abandon the concept of a 'call-stack', and move to heap allocated frames.
05:33:39 <shapr> or their brain comes out their ears?
05:33:54 <Shammah> From there I discuss the concept of changing the 'call-stack' into a 'call-tree' (list->tree is a common datastructure pertibation)
05:34:19 <shapr> that is smooth, are you a CS teacher? :-)
05:34:26 <Shammah> then you can introduce general continuations as 'storing a pointer to the current call-frame in the call-tree'.
05:34:26 <Igloo> CPS is essentially "Create event that will determine what function is run next, then do some work, then look for the next event" isn't it? Oh, actually, that'll give you things in the wrong order
05:34:37 <Shammah> nope.  Just a humble engineer :)
05:34:50 <Shammah> but I do like teaching.  Just don't get the opportunity to do it often.
05:35:05 <Shammah> (and no, I don't have it written down anywhere, it's just all in my head :)
05:35:15 <shapr> write it on the wiki?
05:35:56 <Shammah> although I can't claim to be any more humble than an engineer can be..... as a profession, we're not particularly humble at the best of times, ;)
05:36:03 <Shammah> shapr: I might do that.
05:36:42 * earthy grinz
05:37:03 <Shammah> OTOH, it pretty much just mirrors the progress of my understanding of continuations.  Just without the false starts, red-herrings, and meanderings I required.
05:37:50 <earthy> I understood continuations after trying to grasp printing parse forests
05:38:36 <Shammah> ... all those trees make it difficult to see...
05:38:57 * earthy nods
05:39:02 <earthy> I'm weird that way
05:39:02 <shapr> can't see the coroutine for the threads?
05:39:27 <shapr> can't see the coroutine for the trees?
05:39:46 * shapr shrugs
05:39:51 <Shammah> feh... well that was one bad pun lost to literal interpretation. :(
05:40:00 * shapr grins
05:40:25 <shapr> I thought it had totally flatlined
05:41:29 <shapr> saz: your evil twin zas is here
05:41:53 <shapr> has anyone tried this Math via Haskell book?
05:42:13 <Shammah> nope, haven't had the time.
05:42:26 <Shammah> I have a reading list a mile long already... 
05:42:30 <shapr> me too
05:42:41 <shapr> but I tend to read whatever's on the end
05:42:54 <Igloo> :-)
05:43:00 <Shammah> (and that's before I start counting the 100's of papers waiting in my paper-archive :)
05:43:12 <shapr> yah, I have those too
05:43:31 <shapr> oh, I have an evil plan for that
05:43:32 * Shammah is a bit of a paper magpie... citeseer is *dangerous*... "ooohh pretty, I'll just download this one"
05:43:36 <Shammah> too.
05:43:38 <shapr> a research paper wiki
05:44:05 <Shammah> *aaaaagggggghhhhhh*
05:44:19 <shapr> where we all get to make annotations, links to related stuff
05:44:22 <shapr> etc
05:44:53 <kowey> bibtex repository?
05:45:12 <earthy> shammah: you want to stay away from portal.acm.org then :P
05:45:28 <shapr> for example, I've found a bunch of typos, fixes, etc but I have no way to distribute them
05:46:18 <shapr> and I'd like to say stuff like "this paper is a great prequel to this one over here"
05:46:26 <Shammah> shapr: Have you read Friedman's 'The role of the study of programming languages in the education of a programmer'?  One of the best paper's I've read, and the one that finally allowed me to grok CPS, and (two days later while pondering it in the shower) continuations in general.
05:46:38 <shapr> never heard of it
05:46:38 <Shammah> earthy: I don't have a subscription.
05:47:15 <saz> shapr: oh, she made an appearance did she?
05:47:57 <shapr> for example, I'd like to point reader of Hudak's Haskore paper to the Dance paper
05:48:36 <shapr> saz: yes, but she's been nice so far
05:49:03 <saz> good to hear she's behaving :)
05:49:04 <earthy> shammah: and no access to a library that does? pity.
05:49:30 <Shammah> earthy: Not online access, and if I'm there, I can photocopy most of the articles direct from the journals.
05:49:45 <Shammah> shapr: bugger.  Is citeseer down again?  I can't seem to resolve it.
05:50:03 <shapr> that's another reason I'd like a research paper wiki, it would encourage ppl to put their papers online
05:50:35 <shapr> looks like it's down
05:50:49 <shapr> ah, it's back now
05:51:42 <Shammah> mmm I still can't resolve.
05:51:48 <shapr> http://citeseer.ist.psu.edu/
05:52:12 <Shammah> shapr: yeah, my dns won't resolve it.
05:53:15 <earthy> citeseer.ist.psu.edu has address 130.203.133.2
05:53:35 <blackdog_> damn. beat me to it. :)
05:53:58 <shapr> g'day blackdog_ 
05:54:10 <blackdog_> g'day shapr. how's tricks?
05:54:21 <shapr> I can freemount!
05:54:36 <blackdog_> dear lord, tell me that's a unicycle term.
05:54:37 <shapr> what's up with you?
05:54:44 <shapr> it is :-P
05:54:48 <blackdog_> "look, ma, no hands!"
05:54:58 <shapr> oy
05:55:04 * blackdog_ slaps himself unconscious
05:55:06 * shapr grins
05:55:20 <blackdog_> i'm converting haskell code to java.
05:55:39 <shapr> ewww
05:55:43 <Igloo> Err, I think you've got something backwards mate  :-)
05:55:46 <shapr> whatever for?
05:55:53 <blackdog_> it's really painful. I want don to finish his bloody hs->java compiler.
05:56:18 <shapr> Shammah: http://www.cs.indiana.edu/~dfried/
05:56:29 * Igloo is failing to describe merging substitutions nicely
05:56:52 <blackdog_> client wants java, and no amount of wheedling or persuasion was enough to budge 'em. java means perfect compatibility with everything ever. yay java.
05:57:10 * shapr stabs java
05:57:21 <blackdog_> from hell's heart, no less.
05:58:41 <shapr> I really wish I knew what's up with that stack overflow lambdabot pulls off occasionally
06:00:17 <shapr> blackdog_: that really sucks, do you at least get to open source the Haskell code?
06:00:35 <Shammah> shapr: yeah, it's the first of the talks listed on that page.
06:00:48 <blackdog_> haven't really talked licensing terms yet. i always suck with the business stuff.
06:00:52 <Igloo> Grr, substitutions from variables to other variables are a real pain
06:02:11 <blackdog_> shapr: it's nothing groundbreaking. yet another little language +gui, but dear lord it's annoying to have to port haskell to java. makes you realise exactly how much you're missingwhen you use java...
06:02:20 <shapr> yup
06:03:30 <eivuokko> Was SF bug tracker for ghc really the right place for submitting bug report?  Or is it just custom that all bugs are unassigned?
06:04:01 <shapr> if it's a ghc bug, ghc-bugs@haskell.org is best
06:04:07 <shapr> or you could talk to JaffaCake
06:04:14 <shapr> he might have some advice
06:04:37 <JaffaCake> the bug tracker is fine
06:04:45 <eivuokko> Ok.  Thanks. :)
06:05:19 <Igloo> The e-mails is generates to the list are a real pain. The new content can be between two old bits of content
06:05:19 <JaffaCake> doesn't seem much point assigning bugs when there's only two of us who deal with most of them
06:05:51 <shapr> yah, sf.net bug followups suck
06:05:55 <JaffaCake> Igloo: I know.  Someone should fix sourceforge...
06:06:22 <eivuokko> Ok, just asking as a lot of projects think they will use bug trackers, but in reality only bugging on ml or irc makes anything happen :)
06:06:23 <shapr> there's always gforge...
06:06:27 <JaffaCake> we looked at using another bug tracker, but didn't want the hassle of setting it up & maintaining it
06:06:33 <shapr> me me!
06:06:49 <JaffaCake> hehe, we'll switch over if it's better
06:06:58 <shapr> seriously if you want web services set up, ask me
06:07:26 <shapr> gforge is more integrated in general
06:08:03 <blackdog_> it walks your dog, it mows your lawn...
06:08:17 <shapr> it's written in PHP :-P
06:08:24 <Igloo> It looks like newer ghc or gcc might have fixed the unaligned problem incidentally, JaffaCake
06:08:35 <JaffaCake> oh cool
06:08:35 <Shammah> poor sods.
06:08:57 * JaffaCake would really like a web service that mows his lawn
06:09:03 <shapr> heh
06:09:13 <shapr> I just switched to an apartment
06:09:22 <JaffaCake> that's one solution I suppose
06:09:51 <shapr> even so, loud annoying neighbors sucks
06:10:00 <blackdog_> http://www.lyricsdir.com/t/tom-waits/step-right-up.php
06:10:34 <shapr> JaffaCake: any plans for ipv6 support?
06:10:44 <JaffaCake> nope
06:11:01 <JaffaCake> but we'll incorporate patches, as usual ;)
06:11:06 <shapr> time for me to learn some GHC internals I guess
06:11:17 <JaffaCake> just the network library, I presume
06:11:21 <shapr> yup
06:11:39 <JaffaCake> It's written in portable Haskell + FFI (with a bit of hsc2hs)
06:11:58 <shapr> sounds easy enough
06:12:04 <shapr> (famous last words)
06:12:10 <JaffaCake> go for it
06:12:33 * shapr adds that to the weekend hacking list
06:13:20 <JaffaCake> In general, we really want to encourage more people to contribute to GHC... any ideas?
06:13:37 <shapr> make a list of small things that need doing
06:14:01 <shapr> and be available for some questions?
06:14:13 <JaffaCake> yeah, I've been sort of doing that, see http://sourceforge.net/pm/?group_id=8032
06:14:27 <JaffaCake> there aren't many "small" things though
06:14:31 <shapr> also, has chilli's GHC internals guide been updated?
06:14:46 <JaffaCake> it's very incomplete and probably out of date in lots of ways
06:14:55 <JaffaCake> we just don't have the time to keep it going
06:15:17 <Igloo> What sort of things would you want done?
06:16:03 <JaffaCake> well, just general quality improvements, more testing, more platforms, new features, that sort of thing
06:16:23 <shapr> you think Robert Ennals' spec_eval will be ressurected? have I already asked you this?
06:16:36 <JaffaCake> features are tricky, because we have to check for interactions with everything else, and whether the code can be maintained
06:16:47 <JaffaCake> shapr: probably not at this stage
06:17:00 <shapr> too bad, it looked nice
06:17:17 <shapr> especially for the debugger
06:17:20 <JaffaCake> in some ways yes, but the gains weren't really there, and its *very* complex
06:17:25 <shapr> oh
06:17:44 <Igloo> Well, new platforms for example, requires a significant investment in learning about both GHC and the platform, and there probably aren't that many people actually want ot use it on (and hence are motivated to put the effort in)
06:17:54 <shapr> in that case, good choice :-)
06:18:06 <JaffaCake> we want the debugger though
06:18:14 <JaffaCake> Igloo: sure
06:18:32 <Igloo> I imagine Windows,Linux,BSD and IA64,AMD64,x86,sparc covers pretty much all the use, and that's all already pretty much there
06:18:51 <Igloo> Oh, and Solaris
06:19:00 <shapr> and MacOS
06:19:05 <JaffaCake> Sparc bitrots a bit
06:19:26 <JaffaCake> we still need registerised support for amd64, but I think Don S is working on it
06:19:50 <JaffaCake> we need someone to update the native code generator for sparc in the new backend
06:19:53 <Igloo> There's also not really any research in adding support for YA platform, of course
06:19:57 * earthy is actually looking in to keeping sparc alive
06:20:01 <shapr> YA?
06:20:06 <JaffaCake> yet another
06:20:08 <shapr> oh
06:20:15 <JaffaCake> yeah, true
06:20:16 <Igloo> earthy: What OS?
06:20:20 <earthy> Solaris 8
06:20:28 <JaffaCake> earthy: cool :)
06:20:29 <Igloo> Oh, OK
06:20:34 * earthy *wants* to do it with GCC 3
06:20:48 <earthy> but I first want to really get the hang of building the damn thing. ;)
06:20:53 <JaffaCake> you need 3.3.3, or 3.4 then
06:21:02 * earthy nods
06:21:16 <JaffaCake> buidling problems I can probably help with ;)
06:21:25 <earthy> oh, I'm past most of them
06:21:43 * Igloo does my best to keep it working on the various Debian arches, but not being an expert on any given one means everything takes a little more time and effort
06:22:10 <earthy> it's just annoyances such as Solaris 8 not exporting the POSIXly correct getpwnam_r prototypes by default and ghc relying on them
06:22:23 * JaffaCake greatly appreciates Igloo's efforts :)
06:22:28 * shapr too
06:22:57 <JaffaCake> earthy: right, and if I had a sparc box here that probably wouldn't have happened
06:23:13 <JaffaCake> or if someone else could run nightly builds on Sparc and post them to the cvs-ghc list...
06:23:18 <Igloo> Didn't you used to have one, or did I imagine it?
06:23:27 <Igloo> And thanks  :-)
06:23:27 <JaffaCake> we did, it died :(
06:23:31 <shapr> maybe we could get you a sparc box?
06:23:31 <Igloo> Ah  :-(
06:23:55 <earthy> the sparc boxen I have here are not quite fast enough to do nightly builds, unfortunately
06:24:13 <Igloo> When you said "more testing" above, did you mean running the testsuite on more machines, writing new tests or something else?
06:24:16 <JaffaCake> not even a cut-down nightly build?
06:24:26 <earthy> jaffacake: mayhaps
06:24:33 <shapr> yah, what sort of testing?
06:24:41 <Igloo> A weekly build would presumably be better than nothing?
06:24:49 <shapr> I'm a firm believer in QuickCheck
06:24:50 <JaffaCake> Igloo: running nightly testsuites on other platforms would help
06:25:13 <JaffaCake> also running release candidates against all your sources and tests
06:25:54 <Igloo> I'll probably have the ghc-cvs package run the testsuite at build time when I next give it some time, but that's infrequently built
06:25:55 <JaffaCake> I know lots of folk already do... but more testing is always a good idea
06:26:17 <shapr> Igloo: is there some way to automate it?
06:26:33 <JaffaCake> the full testsuite takes a while, too
06:27:03 <Igloo> It's more an issue of not wanting to tie up Debian's resources than an implementation problem
06:27:10 <shapr> oh, make -j 3 still breaks last I checked
06:27:25 <JaffaCake> yeah, there's a good task for someone!
06:27:34 <shapr> hm, yeah
06:27:48 * shapr creates a WikiPage
06:27:51 <Igloo> Particularly the slower one - the last hat build failed on m68k as the buildd got bored after 5 hours of compiling one file and killed it  :-)
06:27:59 <Igloo> s/one/ones/
06:28:11 <shapr> heh
06:28:28 <shapr> sounds like it would be faster to build it emulated
06:29:49 * JaffaCake needs to go do some real work
06:30:03 <shapr> thanks for the suggestions
06:36:13 <shapr> @wiki GhcTodo
06:36:13 <lambdabot> http://www.haskell.org/hawiki/GhcTodo
06:36:40 <Igloo> Does make -j 2 work?
06:37:03 <shapr> er, I don't think so
06:37:26 <shapr> there's a dependcy problem in the Makefile
06:37:32 <Igloo> Ah, OK. Not that it would have been very safe if -j 3 doesn't  :-)
06:37:59 <shapr> hiya Philippa 
06:38:02 <Philippa> afternoon
06:38:14 <Philippa> I just got confirmation that uni'll let me resit the semester. Am very, very relieved
06:38:40 <Igloo> You might want to add better BTS?
06:39:38 <shapr> yes, I'll add that
06:39:43 <shapr> Philippa: what does that mean?
06:40:09 <Philippa> means a lot less stress and not doing anything at uni 'til january. Because I'm in my final year I'd also get full student support
06:40:27 <Philippa> admittedly it also means a fifth year at uni to mention on my CV, but can handle that
06:40:47 <shapr> low stress sounds nice
06:40:54 <saz> it is nice!
06:41:00 <shapr> Igloo: do you want to add that? ;-)
06:41:37 <Igloo> You may have the honour  :-)
06:41:51 * earthy has 9 years at uni between starting and his master's.
06:41:57 <earthy> 5 years is just fine.
06:42:13 <Philippa> 5 is enough to indicate something up in the UK
06:42:20 <Philippa> they're 3 year courses
06:42:29 <Philippa> and I've not been studying part-time
06:42:35 <earthy> um. :) in .nl it was officially a 4 year course. :P
06:42:49 * saz is doing 4 years in 4.5
06:42:56 <saz> and enjoying a session of part time 
06:43:02 * Philippa nods
06:43:20 <Philippa> I'll have stuff to explain to potential employers at this rate, anyway
06:43:25 <saz> i think it's the best decision I made in my uni career
06:43:34 <saz> Philippa: do they really care?
06:44:39 <shapr> yah, my employers don't care about my school, they want to see me code
06:45:11 <saz> my employer keeps on asking me when i'll be finished
06:45:36 <saz> what.. a whole year! I have to wait a whole year before you can come full time.. noooo!
06:46:47 <shapr> seems they like you
06:46:53 <earthy> hey, even *my* employer didn't mind the 5 year overshoot
06:47:02 <earthy> and I'm at a university doing a PhD!
06:49:22 <saz> shapr: scary aint it?
06:50:15 <Philippa> around here they're likely to ask what was wrong and is it still an issue?
06:50:31 <saz> Philippa: would you be able to tell them?
06:50:44 <earthy> well, me having 3 full years in industry did help, ofcourse. ;)
06:50:45 <Philippa> no to the latter, and the former's none o' your business :-)
06:50:55 <Philippa> yeah, it would. I've not worked a job in my life
06:51:08 <saz> Philippa: can you get a job around uni?
06:51:10 <earthy> yeah, then it does count, kinda.
06:51:43 <Philippa> saz: possibly during my time out, yeah. Got other things to sort out ahead of that though
06:52:08 <saz> Philippa: keep an eye out for them, ask your supervisors and stuff
06:52:15 <saz> cos uni jobs are great :)
06:53:23 <vegai> shapr: I think languages can be measured in several independent ways
06:53:54 <vegai> runtime efficiency is one (although it is more measuring the compiler, nevertheless, some languages seem to fare worse there)
06:53:56 <Philippa> "over-verbosity", "inability to express anything useful", "inability to express anything useful without having to teach it everything"...
06:54:12 <Philippa> some languages imply a runtime model that's slower
06:54:38 <Philippa> it may or may not be possible to rework it, but they all have some kind of "most obvious virtual machine"
06:55:01 <saz> how would you measure 'ability to shoot oneself in ones foot'?
06:55:55 <Philippa> a combination of 'ability to write simple expressions that break' and 'ability to build abstractions with a swiss cheese-like number of holes'
06:57:21 <Philippa> you need 'ability to avoid shooting oneself in ones foot' separately though to cover languages like C++
06:57:59 * earthy laughs
07:00:26 <saz> hehe
07:00:30 <saz> i'm learning c++ now
07:00:41 <saz> and it's just making me realise how cool haskell really is
07:00:59 <Philippa> heh
07:01:08 <Maddas> heh
07:01:15 <Philippa> C++ is pretty good for run-time efficiency, though I'd /kill/ to have tagged unions ADT-style in the type system
07:01:19 <Maddas> the more I learn about Java, the less I like it, and I never liked Java in the first place :-)
07:01:26 <Philippa> you have to work hard to handle resources cleanly though
07:01:28 <saz> i wish i could replace templates with type classes
07:01:32 <Philippa> I can't stand Java
07:01:33 * earthy actually managed to persuade a perl zealot to try out haskell yesterday evening
07:01:35 <saz> typeclasses are so much cooler
07:01:42 <vegai> saz: oh, lucky bastard!
07:01:49 <Philippa> for single-parm ones you want virtual base classes
07:01:50 <vegai> saz: you got to learn the good language first
07:02:00 <saz> vegai: indeed :-)
07:02:06 <Maddas> how is that 'lucky'?
07:02:13 <Philippa> but yeah, multiparameter ones're a nice mechanism for multiple dispatch
07:02:14 <Maddas> It only makes you feel dumber while learning the other.
07:02:20 <saz> my brain wasn't fried with c++ to begin with?
07:02:29 <Maddas> Well, yes, that's an argument :)
07:02:40 <vegai> we just discussed that brainrotting, in fact 
07:02:50 <vegai> shapr there thought that there wasn't much to ti
07:02:51 <vegai> it
07:03:02 <saz> it gradually built up resistance.. haskell, c, java, vhdl..assembly, prolog.. c++!
07:03:32 <Maddas> VHDL is domain-specific though, so I wouldn't count it with the others :-)
07:03:45 <saz> hehe
07:03:57 <saz> well, the sucky thing about vhdl was the xilinx compiler we were made to use
07:04:28 <saz> the error messages on that thing had no bearing to the actual error
07:04:37 <Maddas> heh
07:05:00 <shapr> vegai: I think it's something that can be escaped
07:05:22 <shapr> wish I'd learned Haskell first though
07:05:31 <saz> what did you learn first?
07:05:54 <shapr> basic on a sinclair something, zx I think
07:05:55 <saz> i'd played around a little with futureBASIC on a mac before getting to uni
07:06:02 * Philippa went pascal->various basics->more pascal->C->C++->Haskell with a few scripting langs on the side
07:06:05 <saz> but haskell was my first real programming experience
07:06:36 <Philippa> oh, and some x86 asm circa 486
07:06:41 <Maddas> The first programming language I really used is (apart from dabbling in Pascal and Basic) Perl
07:06:45 <Philippa> I seem to have a strangely holistic approach...
07:06:56 <shapr> I did x86 asm on my brand new 8088
07:06:58 <la> hi
07:07:00 <Philippa> heh
07:07:00 <Maddas> hi
07:07:02 <shapr> hi la
07:07:09 <la> hi Maddas, shapr
07:07:43 <la> shapr: both you and monotonom were right
07:07:46 <la> opss
07:07:48 <la> ?
07:07:51 <la> la?
07:08:08 <Maddas> I wish I had more time to keep up with learning Haskell and start with Erlang and a few other languages :-)
07:08:11 <shapr> we were? yay!
07:08:11 <la> argh brb
07:08:16 <shapr> I like being right
07:08:23 <jadrian> (2 xchats open)
07:08:26 <Maddas> heh
07:08:26 <jadrian> :)
07:08:29 <Maddas> shapr: :-)
07:08:32 <shapr> so, what did you end up with?
07:08:39 <jadrian> shapr: yeap 
07:08:52 <jadrian> shapr: is suggestion made perfect sense but I failed to see it...
07:09:04 <jadrian> s/is/his
07:09:13 <Philippa> Erlang looks funky, sadly I probably won't get 'round to it
07:09:32 <shapr> Philippa: it's worthwhile if you can
07:09:32 <Maddas> I'd really like to do some things involving concurrency in it
07:09:37 <shapr> me too
07:09:53 <jadrian> well I wrote the mailing list just in case, to get some comments on my functions and check if I was missing something
07:09:54 <shapr> or build that much concurrency into Haskell
07:09:57 <Maddas> But first, I need to learn it, second, I need to think of something involving concurrency :-P
07:10:12 <shapr> I'd like to do mnesia in Haskell
07:10:18 <jadrian> I was given  foldM (#) as an advice
07:10:30 <shapr> # ?
07:10:35 <jadrian> flip ($)
07:10:44 <jadrian> (#) = flip ($)
07:10:55 <Maddas> What is special about Mnesia (as opposed to using some SQL-based thing)? I'm pretty ignorant about it :-)
07:11:28 <shapr> oh, I see
07:11:39 <shapr> Maddas: it's a distributed database
07:11:40 <jadrian> looking at it now, it seems painfully simple
07:11:44 <Maddas> oh, cool
07:12:02 <jadrian> but it took me a while to understand why this was right associative
07:12:22 <jadrian> but I just checked the foldM definition and it was slightly diferent from what I expected
07:12:34 <shapr> it's foldl isn't it?
07:12:46 <shapr> @info Control.Monad.foldM
07:12:47 <lambdabot> -- Control.Monad.foldM is a variable
07:12:47 <lambdabot> Control.Monad.foldM :: forall a b m :: (* -> *). (Monad m) =>
07:12:47 <lambdabot> 		       (a -> b -> m a) -> a -> [b] -> m a
07:13:00 <jadrian> foldM            :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:13:00 <jadrian>  foldM f a []     =  return a
07:13:00 <jadrian>  foldM f a (x:xs) =  f a x >>= \ y -> foldM f y xs
07:13:14 <jadrian> so it processes the list from left to right
07:13:32 <shapr> ok
07:13:36 <jadrian> but it's "right associative"
07:14:03 <jadrian> quite different from my
07:14:11 <jadrian> compLM mfs a  = foldl (>>=) (return a) mfs
07:14:34 <jadrian> in fact it works like my
07:14:43 <jadrian> compRM = foldr (\f g-> (\x ->f x >>= g)) return
07:15:23 <shapr> yup, makes sense
07:15:34 <Philippa> <Maddas> But first, I need to learn it, second, I need to think of something involving concurrency :-P <- a friend of mine commented that he found himself using concurrency to express modules
07:15:40 <Philippa> or possibly the equivalent of objects
07:15:41 <jadrian> I think it's all clear now...
07:15:54 <Philippa> give or take the way that runs on consumer-level hardware atm I quite like that idea
07:15:54 <Maddas> Philippa: Cool
07:15:57 <shapr> neat, are you starting on arrows now?
07:16:03 <jadrian> hope not!!
07:16:06 <shapr> heh
07:16:06 <jadrian> lol :)
07:16:12 <Maddas> Philippa: I'd like to start thinking that way too
07:16:14 <shapr> they're easier imho
07:16:15 <jadrian> I should be concentrated in my work
07:16:21 <shapr> arrows just make sense
07:16:32 <jadrian> and I always start messing around with haskell stuff :)
07:16:48 <shapr> and since monads are a more specific case of arrows...
07:16:58 <shapr> me too
07:20:11 <Philippa> I'm still only half-getting arrows, mostly because I haven't done anything myself. I suspect I should follow through the parser example
07:32:32 <shapr> hi Jesterrr 
07:32:39 <shapr> looking for haskell info?
07:32:40 <Jesterrr> hi
07:32:44 <Jesterrr> yea, definately
07:33:12 <shapr> learning for business or pleasure?
07:33:15 <Jesterrr> i have to write a small program in haskell - i've never used it before and probably never will again and i'm struggling slightly
07:33:19 <Jesterrr> neither - education
07:33:48 <Jesterrr> i've already written this in pascal and c++, and later today i start doing it in prolog - joy!
07:34:02 <shapr> if you plan on being a programmer, Haskell's way of looking at the world is handy
07:34:12 <shapr> that sounds like fun to me actually
07:34:23 <Jesterrr> that may be true, but seeing as i am planning to get a games programmer i think C++ is the wiser choice =)
07:34:42 <Jesterrr> if that's fun, i don't want to know what your boring is! lol
07:34:54 <shapr> I strongly disagree, I've seen the source code for several games
07:35:03 <shapr> but hey, it's your choice
07:35:45 <shapr> I was recently wading through the source code of Enemy Territory
07:36:02 <shapr> Jesterrr: anyway, what's your question?
07:36:19 <Jesterrr> it's not really my choice - its my future employer's choice and they all seem to go for cpp
07:36:28 <Jesterrr> ha! i don't know where to start
07:36:43 <shapr> er, it really is your choice
07:36:53 <Jesterrr> i've been building on a sample piece of code so i have some functionality, even though i don't really understand 100% what i'm doing
07:37:14 <Jesterrr> how is that so? if all the game development companies are using C++ they're going to expect me to do the same
07:37:19 <shapr> if you can show your bosses that something can be written in less time with less bugs, I think they'd go for it
07:37:41 <Jesterrr> perhaps, once i was already a trusted member of the company, but i'd need ot get my foot in the door first
07:37:53 <shapr> especially in the game programming industry, that's fierce competition
07:38:19 <Jesterrr> i'll give it some thought, but in the meantime i slightly more concerned about fixing up this particular program
07:38:26 <shapr> fair enough
07:38:30 <Lor> A friend of mine works for a game company and afaik uses mostly ocaml and custom languages.
07:38:53 <shapr> a friend of mine uses stackless python for theMMORPG he works on
07:39:23 <Jesterrr> that doesn't surprise me, it all depends on which aspect of the game you are working on
07:39:26 <shapr> Jesterrr: what's the program going to do?
07:39:27 <Lor> Well, these were _action_ games.
07:39:30 <Philippa> <Jesterrr> that may be true, but seeing as i am planning to get a games programmer i think C++ is the wiser choice =) <- learn FP, it's going to be *massively* important in gamedev in the future
07:39:44 <Maddas> And knowing Haskell will probably improve the code you write, no matter what language you write it in
07:39:48 <Maddas> (Well, save Assembly, I guess)
07:39:52 <Jesterrr> but take it from someone who's been looking at job advertisements a LOT lately, and they all ask for C++ ok? :)
07:39:57 <Philippa> well duh
07:40:02 <shapr> yah, this whole game (eve-online) is written with stackless python
07:40:13 <Jesterrr> anyway, the program is meant to be a very VERY simple database lookup system
07:40:17 <Philippa> take it from somebody who's been hanging around the gamedev industry a long time, if all you know is C++ you're not gonna be as useful as you could be
07:40:21 <shapr> Maddas: you can generate asm with Haskell :-)
07:40:21 <Jesterrr> for a bunch of airline flight records
07:40:25 <Maddas> I think it's silly to restrict yourself to one language
07:40:28 <Maddas> shapr: Heh :-)
07:40:33 <shapr> oh that sounds like fun
07:40:41 <Jesterrr> i have to take it one step at a time Philippa.. besides, i don't intend to be a programmer for long (if at all)
07:40:50 <shapr> why not?
07:40:52 <Philippa> don't tell me, you want to direct?
07:40:55 <Philippa> sorry, "design"?
07:40:57 <Jesterrr> who mentioned restricting myself?
07:40:58 <Spark> most people with any talent, seem to think above the language anyway
07:41:07 <shapr> man, the only thing better than programming is sex!
07:41:14 <Maddas> erm
07:41:16 <Jesterrr> yes, i want to design - yes, i know everyone and their mom wants to design too - but that isn't going to stop me taking the approach i want
07:41:17 <Spark> nah programming is better than sex
07:41:19 <Philippa> I dunno, a lot of foreplay's more fun than code too :-)
07:41:26 <shapr> Spark: dude, you're sick
07:41:30 * Maddas moves his chair away from Spark and shapr 
07:41:33 <Spark> i know, its fucking wicked
07:41:36 <shapr> Philippa: :-P
07:41:54 <Philippa> Jesterrr: I used to be looking at going that route. If you want to do that, consider /what/ you're going to be coding. Doing the graphics ain't gonna get you closer to design
07:42:01 <Philippa> now, working on tools might
07:42:15 <Jesterrr> i'm not talking artwork design - i'm talking core system design
07:42:18 <Philippa> 'cos you're providing the framework the designers use to create stuff
07:42:30 <Philippa> I wasn't talking artwork either
07:42:35 <Jesterrr> ok, sounded like you were
07:42:38 <Philippa> yeah, that's one thing the toolchain deals with...
07:42:50 <Philippa> I was thinking levels, entity interaction, stuff like that
07:43:00 <Jesterrr> right now i'm not 100% sure where i'm taking this, for the meantime i'm just concerned with passing my degree
07:43:29 <Spark> i could be a textbook sociopath for all i know, but the best thing about sex is the social engineering challenge of getting the person into bed with you in the first place
07:43:31 <shapr> anyway
07:43:42 <Jesterrr> and passing my degree relies on producing this haskell program, purely for the purposes of understanding the functional paradigm
07:43:48 <Philippa> Spark: I don't see it as a /challenge/, but I can see where you're coming from
07:43:58 <shapr> Jesterrr: ok, how would you approach it?
07:44:11 <Jesterrr> approach what, exactly?
07:44:16 <Philippa> the program
07:44:33 <Philippa> assuming shapr and I're thinking along vaguely similar lines, anyway
07:44:50 <shapr> hah
07:44:57 <shapr> yes, the code
07:44:59 <Jesterrr> with 5 days on the clock i haven't had a whole lot of time to consider my approach
07:45:12 <Spark> right i think its bed time
07:45:12 <Philippa> OK, how simple /is/ the database?
07:45:13 <Jesterrr> as i said, i've been building on a sample database we were provided with
07:45:15 <shapr> well, you want to know the FP paradigm
07:45:18 <Philippa> just enter/retrieve?
07:45:25 <Jesterrr> don't even need to enter
07:45:27 <Philippa> 'night Spark
07:45:33 <Spark> night
07:45:53 <Philippa> OK, what /do/ you have to do?
07:46:22 <Jesterrr> just retrieve data from a hardcoded list of 24(or so) records containing roughly 5 fields, being able to search from 3 of those 5 fields to extract all data, including calculating a duration from the remaining two fields which are a departure and arrival time
07:46:53 <Jesterrr> as i said, i've written this twice already, in two different languages, so i know how simple it can be
07:47:07 <Jesterrr> it's just that i picked up haskell for the first time 2 days ago *shrugs*
07:47:16 <Philippa> Right. So, how would you go about creating a program that does all that?
07:47:17 <Philippa> ignore FP
07:47:20 <Philippa> ignore Haskell
07:47:23 <Philippa> what does the program *do*?
07:48:10 <Jesterrr> it takes user input, either in the form of a flight code, originating city, destination city, or both cities, and outputs all records that match the criteria provided
07:48:19 <Jesterrr> it also calculates the duration and outputs that also
07:49:14 <Jesterrr> i have all of the above done, in a rudimentary fashion i'll be the first to confess, aside from the calculation of the duration - and the output is wholly unformatted
07:49:14 <Philippa> Right. What do the innards do?
07:49:24 <Philippa> again, ignore FP for a while
07:49:54 <Jesterrr> they search through the database for matching criteria and output it.. not much else
07:50:16 <Philippa> OK. What's the database? How do you search through it?
07:51:00 <Jesterrr> i currently have it stored as an array of a type that comprises of several other types (like i record, i can't remember how that is termed in haskell)
07:51:14 <Jesterrr> as for the search... that is something i plucked from the sample program and i can't claim i understand it
07:51:21 <Jesterrr> not in its entirety
07:51:36 <Philippa> OK. Why're you using arrays for now?
07:51:44 <Jesterrr> once again, sample program
07:51:56 <Jesterrr> i took that as a guideline to what is expected in return#
07:52:19 <Philippa> yeah, if your lecturer's essentially said "do it with an array in Haskell" you're stuck with it
07:52:35 <Philippa> it won't teach you much about FP unfortunately...
07:52:52 <Jesterrr> that wasn't said, specifically
07:53:14 <Philippa> OK. Ditch arrays for now, 'cos they're actually a bugger to work with in Haskell and not for beginners
07:53:22 <Jesterrr> but i don't understand FP and i don't think this apporach is going to teach it to me either, and that's not something i have time to be upset about
07:53:23 <Philippa> read anything about how lists work?
07:53:37 <Philippa> OK, what've you been told about FP?
07:53:42 <Jesterrr> well actually i'm not sure it is an array - i'm just trying to put things into terms i understand from other languages (and yes, i have realsied that was a mistake)
07:53:48 <Philippa> yes, a big one
07:53:56 <Philippa> OK, what's the type being used?
07:54:06 <Philippa> List of <whatever the record type is>?
07:54:20 <Jesterrr> ok, i have a type called flight, which contains types origin, destination etc
07:54:20 <Philippa> or rather, [recordType]?
07:54:33 <Philippa> yep, flight's your record type
07:54:43 <Jesterrr> right
07:55:13 <Jesterrr> i'm not sure how those are grouped
07:55:30 <Philippa> hand me the declarations? Could be easier
07:55:42 <Jesterrr> once again, my lack of understanding of the language is giving me troubles
07:55:48 <Jesterrr> heck, i'll send you the whole file - it's tiny
07:55:55 <Philippa> not DCC
07:55:58 <Philippa> put it up on a web page somewhere
07:56:04 <Philippa> and don't paste it in chan :-)
07:56:28 <Jesterrr> i wasn't going to paste it, but i don't have any webspace at the moment
07:56:56 <Philippa> http://rafb.net/paste/
07:57:07 <Philippa> your friend in situations like this
07:57:42 <Jesterrr> yeah, i'd forgotten about that
07:58:06 <Jesterrr> no haskell option though.. who'da thunk it?
07:58:26 <Philippa> who cares? A raw text dump'll do
07:58:58 <Philippa> you shouldn't do more than that anyway due to layout
07:59:17 <Jesterrr> ok, done
07:59:26 <Philippa> URL?
07:59:38 <Jesterrr> http://rafb.net/paste/results/D2328393.html
08:00:04 <Philippa> ewww
08:00:13 <Jesterrr> haha, i can imagine how bad it must look
08:00:14 <Philippa> flight should *not* be a list type
08:00:23 <Philippa> OK, here goes...
08:00:31 <Jesterrr> i should still be doing "hello world!" with my level of experience, and i know it
08:00:34 <Philippa> (a,b,c,d) is a tuple type. Think struct in C, only not
08:00:41 <Jesterrr> right
08:00:41 <Philippa> [a] is a list of a
08:01:03 <Jesterrr> ok
08:01:07 <Philippa> your flight type is [(blah,blah,blah)] - a list of tuples
08:01:12 <Philippa> that's not a flight, it's flights :-)
08:01:40 <Jesterrr> yes, i know
08:02:30 <Philippa> OK, might I suggest you calculate the durations with a function of type [time] -> [time] -> [time]?
08:02:47 <Philippa> that is, that takes a list of start times and a list of end times, assumed to be of the same length, and returns a list of durations?
08:03:27 <Jesterrr> i suppose that could be useful, yea
08:04:11 <Philippa> OK, got any idea how recursion works?
08:04:22 <Philippa> though you could do this with yet another list comprehension, I guess
08:04:31 <Philippa> the comprehensions aren't teaching you a lot about FP, mind
08:04:32 <keverets> just use zipWith (-)
08:04:52 <keverets> maybe with a flip, if you have start times in the first list.
08:04:53 <Philippa> keverets: there's no (-) defined on his time. Also, zipWith's over his head atm
08:05:25 <Jesterrr> lets get this clear - i haven't any idea how any of it works, and i wondering which genius at my univeristy would consider this a good experience for learning anything aside from how to write bad programs
08:05:54 <Philippa> how much have they attempted to teach you about FP?
08:06:12 <Jesterrr> i'd probably learn more from reading material on the various paradigms, which is what i am MEANT to be learning, but i'm spending my time doing this
08:06:25 <Jesterrr> they mentioned that it existed, and suggested some places i could read about it
08:06:39 <Philippa> looked at any of those places?
08:06:47 <Jesterrr> i'm sure you can probably guess i'll be glad to leave this place :)
08:07:12 <Jesterrr> nope, been spending all my time writing the C++ and Pascal versions of this, and the trying to wrap my noggin around haskell and prolog
08:07:27 <Philippa> perhaps this'd explain why you've no clue what you're doing?
08:07:33 <Philippa> learn the paradigm and the language'll follow
08:07:37 <Jesterrr> it's genuine head against the wall time
08:07:45 <Jesterrr> if i had the time, i would - believe me
08:07:45 <Smerdyakov> Jesterrr, did you wait too long to start the assignment?
08:08:05 <Jesterrr> perhaps, but i had a LOT of other stuff to produce, and i guess i underestimated this particular one
08:08:20 <Philippa> read up on the paradigm. Do it now, do it fast
08:08:21 <Smerdyakov> OK, so don't try to blame your instructor, when texts to read have been recommended.
08:08:35 <Philippa> merely learning the language will do you no good, because you won't know how to say anything useful in it
08:08:51 <Philippa> the exercise looks well-founded so long as they pointed you at good reading material
08:09:02 <Smerdyakov> I don't agree. I include being able to produce the programs you want as part of "learning the language."
08:09:13 <Philippa> you don't know what you want to say
08:09:23 <Philippa> therefore it doesn't matter how well you know the language
08:09:28 <Philippa> now go read up on FP
08:09:34 <Jesterrr> i accept what you're telling me - and i have my excuses for why things are the way they are which i am sure you don't want to hear - but that isn't helping me here and now
08:09:34 <Smerdyakov> But you do know. You want to do this assignment. :)
08:09:56 <Philippa> Read. Do it quickly. That is the best help we're willing to give
08:10:02 <Smerdyakov> Jesterrr, do you understand that most students don't grasp FP after a full semester on that subject alone?
08:10:12 <Smerdyakov> Jesterrr, and now you want to read nothing and somehow have us infuse the knowledge into you?
08:10:16 <Maddas> Philippa: I think it's some of the best we are able to give
08:10:22 <Philippa> Smerdyakov: that's not helping him any ;-)
08:10:30 <Jesterrr> no - i'm asking you to help me write a single program, not understand the whole language
08:10:40 <Smerdyakov> Jesterrr, but that would really not be ethical.
08:10:44 <Philippa> and we're telling you there're significant chunks you need to understand to write the program
08:10:47 <Smerdyakov> Jesterrr, it would be us writing it.
08:10:49 <Philippa> OK, do you know what a function is?
08:10:56 <Jesterrr> yes, i know that much
08:11:06 <Philippa> and how that differs from the C idea of what a function is?
08:11:14 <Jesterrr> yes
08:11:19 <Philippa> OK. Know what a higher-order function is?
08:11:58 <Jesterrr> can't say i do
08:12:10 <Philippa> It's a function that operates on or returns functions
08:12:21 <Jesterrr> right, that makes perfect sense
08:12:56 <Philippa> know how to write a recursive function that operates on every element in a list?
08:14:03 <Jesterrr> no
08:14:10 <Philippa> OK, to give an example:
08:14:16 <Philippa> add [] = [0]
08:14:23 <Philippa> d'oh
08:14:26 <Philippa> add [] = 0
08:14:37 <Philippa> add (n:ns) = n + (add ns)
08:14:46 <Jesterrr> i have seen this before, yes
08:14:53 <Philippa> do you understand how it works?
08:16:22 <Jesterrr> yes
08:16:42 <Jesterrr> it goes through each element of the list, and adds it on to a runing total, once the list is empty, it adds 0 and ends
08:16:58 <Jesterrr> it acheives this by calling itself, with a new value each time
08:17:05 <Philippa> right. That's "a recursive function that operates on every element in a list"
08:17:19 <Jesterrr> until the list = []
08:17:52 <Philippa> how about the function add xs ys, where xs and ys are lists of numbers? Could you write that?
08:18:43 <Jesterrr> i think so
08:18:50 <Philippa> OK, go ahead
08:19:13 <Jesterrr> give me a minute in notepad :)
08:19:36 <Philippa> incidentally, I want the return to be a list ;-)
08:20:15 <Philippa> such that add [1,2,3] [4,5,6] = [5,7,9]
08:20:26 <Jesterrr> right, i wasn't sure
08:33:13 <jadrian> is there a standard (mathematical) notation for the monadic bind operator?
08:33:33 <jadrian> any standard math symbol for >>= ?
08:34:10 <ski> f* = (>>= f)
08:34:24 <ski> the * being raised a bit upwards
08:34:36 <ski> also   f * m = m >>= f
08:34:58 <jadrian> argh :/
08:35:04 <ski> why ?
08:35:40 <jadrian> I like to use std math notation in my (internal) documentation using literate haskell + LaTeX
08:36:20 <jadrian> but not sure if it's a good idea in this case because the arguments are switched
08:36:32 <ski> the * in "f * m" that i've seen actually had 5 corners, and not six or eight
08:36:44 <jadrian> right
08:37:01 <Philippa> Jesterrr: getting anywhere?
08:38:40 <jadrian> ski: any idea why the arguments are switched in the haskell notation?
08:40:14 <jadrian> (that is, why isn't =<< the std binding operator)
08:41:19 <ski> more natural reading/writing order in actual programs, perchance
08:41:34 <ski> e.g.   foo >>= \x -> ...
08:41:46 <ski> instead of (\x -> ...) =<< foo
08:42:24 <jadrian> we do type:
08:42:34 <jadrian> (\x -> ...) $ foo
08:43:32 <ski> or even  let x = foo in ...
08:43:54 <jadrian> yeap
08:44:12 <jadrian> Anyway, not important. Guess I'll just use >>= in my documentation, or some similar caracter
08:45:48 <ski> jadrian : see e.g. "Representing Monads", Andrzej Filinski at http://www.diku.dk/~andrzej/papers/
08:46:32 <jadrian> thanks ski
08:47:09 <ski> or "Monads and composable continuations", Philip Wadler at http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
08:47:36 <ski> (that's the first two i could find, on top of my head, that used those two notations)
08:47:49 <jadrian> ok thanks ski!
08:48:14 <jadrian> weird
08:48:29 <jadrian> literate haskell mode in xemacs is not working for LaTeX style...
08:48:43 <jadrian> isn't it just  \begin{code} \end{code} ???
08:49:09 <ski> (it's possible than Moggi, or even some earlier category theorist came up with the "star"-notation. i think the eta and mu for return and join comes from usual names for natural transformations, though)
08:49:11 <jadrian> using ">" works though :-/
08:49:28 <jadrian> I see
08:49:50 <ski> hmm, i thought, 'twas so  (but i haven't used either literate style much so what do i know)
08:50:03 <jadrian> I did study category theory but we didn't mention monads, most of what I know is from playing with haskell
08:50:27 <ski> ok. i don't know very much about monads in a cat. theory setting, either
08:51:03 <ski> only, they should be functors, and return and join are natural transformations (with some laws) ...
08:56:10 <shapr> Philippa: I guess he gave up
08:56:34 <kowey> pity... was fun watching you bust out with the pedagogical skillz
08:58:14 <shapr> I don't think he really wanted to learn
08:58:52 <shapr> but maybe I'm biased because I enjoy it so much
08:59:44 * ski grins
09:07:16 <ski> hi esap
09:07:20 <esap> hi
09:07:28 <esap> what's up?
09:07:44 <ski> dunno
09:08:05 * ski 's reading some on deductive databases
09:13:28 * earthy read destructive databases
09:13:53 * esap thinks all databases are destructive :-)
09:13:59 * ski smiles
09:14:30 <shapr> how do I see which processes are hidden from the ps command?
09:14:52 <earthy> shapr: what do you mean by `hidden from the ps command'?
09:15:08 <esap> if any, then I guess /proc/ should show it.
09:15:09 <shapr> chkrootkit says I have 9 hidden procs
09:15:17 <earthy> *ah*
09:15:23 <shapr> makes me wonder
09:15:35 <earthy> well, /proc/ *might* show them, but probably not, as that is where ps gets its info from
09:16:00 <earthy> other than that it is a matter of opening /dev/kmem and finding the process table
09:16:25 <esap> maybe the 'ps' binary is compromised and it doesn't show everything? :-) then /proc/ might still show all of it.
09:16:55 <shapr> hm
09:17:31 <earthy> esap: that is one variant. the other is a loadable kernel module that changes the behaviour of /proc/ as well
09:18:00 <esap> earthy: right ok, that's possible, I guess.
09:18:36 <earthy> (and here's me thinking that working as a security consultant hasn't poisoned my mind)
09:18:36 <shapr> scary thought
09:29:41 <shapr> does an LKM trojan also keep you from rebooting?
09:32:04 <earthy> shapr: it might
09:32:26 <earthy> but that's quite a lot harder, actually. ;)
09:32:34 <earthy> anyway, I'm off
09:37:16 <shapr> hi stepcut 
09:37:19 <stepcut> hi
09:37:46 <shapr> wassup?
09:37:52 <stepcut> hold on
09:38:05 * shapr holds
09:41:20 <shapr> weird, the hidden procs seem to be gone now
09:43:40 <stepcut> ok, I am back now :)
09:44:05 <stepcut> I was discussing the horrors of maintaining binary packages for ocaml libraries
09:45:26 <shapr> wow, fun
09:46:10 <stepcut> its a nasty little problem
09:46:55 <stepcut> anytime your change a library module interface, you have to recompile any other libraries that directly or indirectly depend on that first library
09:47:12 <shapr> why is that?
09:47:34 <Maddas> stepcut: So just make them right the first time!
09:47:37 * Maddas blinks
09:48:03 <stepcut> ocaml generates an md5sum sum of the interface, and anytime it changes for any reason, everything dependant on it must be recompiled, since the md5sum does not tell you what changed
09:48:15 <esap> stepcut: That's how dependencies work.
09:48:34 <stepcut> esap: yep. 
09:48:49 <Igloo> The same is true for ghc -O at least
09:48:59 <stepcut> Igloo: yep
09:49:10 <Maddas> shapr: yep
09:49:14 <Igloo> Well, if the actual interface changes it'll be true for ghc without optimisation too
09:49:35 <esap> Dependencies should only be used when you have a bigger thing that is built on smaller parts. If your small parts change, the whole must change as well.
09:49:54 <stepcut> It just means that our ocaml debian packages need to export more dependency information than they currently do so we can determine when we really need to rebuild and when we dont
09:50:15 <Igloo> Principal typings are an interesting idea, although possibly unwieldy when it comes to giving things type signatures, and I'm not sure how the GHC extensions etc would cope
09:50:50 * Igloo wonders if you and SyntaxPolice should be comparing notes
09:51:07 <stepcut> Igloo: I plan to some time soon
09:52:20 * shapr hopes snowbmind comes back up
09:52:26 <shapr> er "snowblind"
09:52:45 <jadrian> do you have Xemacs working with LaTeX style Literate Haskell files?
09:52:52 <shapr> yes
09:52:53 <Igloo> Your coloed machine?
09:52:57 <shapr> to both
09:53:23 <jadrian> shapr: does it requires any change to the files distributed with xemacs?
09:53:38 <shapr> no
09:53:39 <jadrian> mine only works with ">" lhs files...
09:53:43 <jadrian> :-/
09:53:43 <shapr> just works
09:53:48 <jadrian> weird
09:53:50 <shapr> oh
09:53:53 <jadrian> \begin{code}
09:53:59 <jadrian> \end{code}
09:54:01 <jadrian> right?
09:54:15 <shapr> I don't remember
09:54:21 * shapr looks for a sample
09:54:40 <Igloo> That around the Haskell, yes
09:54:54 <jadrian> it used to work...
09:55:08 <jadrian> not sure if I ever tried it since I upgraded my system thoughh
09:55:18 <shapr> to what?
09:56:09 <jadrian> to SuSE 8.2
09:56:33 <jadrian> I didn't bother to install xemacs haskell mode since it was included and apparently working fine
09:57:13 <shapr> it works fine for me
09:57:40 <jadrian> did you installed xemacs haskell mode by yourself?
09:58:02 <jadrian> or are you using the one that comes with xemacs?
09:58:42 <shapr> the one that comes with
09:59:10 <jadrian> hmmm
09:59:58 <jadrian> I did a "M-x normal-mode"
10:00:03 <jadrian> then literal haskell mode again
10:00:11 <jadrian> font-lock-fontify buffer
10:00:13 <jadrian> and it worked
10:00:43 <jadrian> it's working now...
10:00:46 <jadrian> oh well
10:01:58 <stepcut> I have a hypothesis: In the past, programmers would often shun Haskell claiming that it was "too slow", and that 'C' was the only way to go. But due to the rise of the internet, there now exists a new breed of programmers that have never written C -- they have only work with "slow" interpreted or byte-compiled languages like php, python, visual basic, etc. For the new generation of programmers, the excuse to not use Haskell wil
10:01:58 <stepcut> l be its weak support for 'internet related libraries'.
10:02:16 <jadrian> (work*ed* argh) 
10:02:44 <shapr> stepcut: yes!
10:03:01 <shapr> I've been saying we need 'net libs for years
10:03:07 <jadrian> ok, I got a workaround, but this is weird... :-/
10:03:17 <shapr> that's why I started haskell-libs.sf.net
10:03:47 <stepcut> In many ways this is a good thing, because net libs are something that can be achived by mere mortals, where-as a superfast haskell compiler is damn hard
10:04:04 <shapr> yes, I agree there also
10:04:14 <shapr> happily, we have Simon^2
10:05:03 <shapr> but, we gotta get organized and write some libs, or fall behind
10:06:09 <stepcut> I also noticed that unconsciously I switched from writing gui applications to writing net applications. When I think about a program I want, I first consider, 'Can I use a web browser for the GUI portion'
10:06:54 * Igloo has some C bindings I'll announce some time, but generally not complete bindings for a library unfortunately as I tend to write them lazily
10:07:16 <Igloo> And the one that is small enough I have completed seems to be suboptimally designed so I don't use it any more  :-)
10:07:22 <shapr> anyway, I don't think it's because they haven't been exposed to C, but instead that they realize that php, python, vb etc get the same work done in less time and less code
10:07:37 <Maddas> shapr: But those languages have loops! </troll> :-)
10:07:43 <shapr> oy
10:07:53 <Maddas> (I just couldn't resist semi-quoting Guido Van Rossum there)
10:07:55 <shapr> Guido will never live it down
10:07:59 <Maddas> haha
10:08:00 <Igloo> Unfortunately some libraries have a tendency to use C's ... type, which scupppers things rather
10:08:26 <jadrian> ghc "-i" flag does not accept "~" for home dir...
10:08:35 <jadrian> :-/
10:08:47 <shapr> jadrian: you gotta expand it yourself
10:08:50 <jadrian> yeap
10:08:51 <Igloo> Are you leaving a space after -i?
10:08:55 <jadrian> nope Igloo
10:09:12 <Igloo> It ought to work if you do, assuming GHC permits that
10:09:34 <jadrian> -i/home/jadrian/Program/Haskell/MyLibs works
10:09:39 <jadrian> -i~/Program/Haskell/MyLibs works
10:09:41 <jadrian> doesn't
10:09:46 <jadrian> opsss
10:09:51 <jadrian> the last one doesn't ;)
10:09:52 <stepcut> shapr: true, I didn't mean to imply that they would switch to C if they knew about it. I just wanted to note that they are happy with slow languages, because it's easy to get the work done
10:09:57 <Igloo> But what about "-i ~/Program/Haskell/MyLibs"?
10:11:14 <stepcut> One missing piece that seems important is the support for parsing binary files (particularily ones with bitfields). We need to finish porting the Binary.hs from nhc, and finish up that stuff deser did
10:11:14 <shapr> yes, I agree with your point
10:11:21 <jadrian> Igloo: nope...
10:11:26 <shapr> yes, that's true
10:11:40 <jadrian> I'll just exapand it...
10:11:59 <jadrian> I'm using aliases for ghc[i] anyway
10:15:24 <shapr> stepcut: I think Binary.hs has been ported, but not standardized
10:16:06 <shapr> plus, I think there are two Binary.hs, one is the equivalent of Python's pickle
10:20:31 <shapr> bah, curryspondence needs to show where the mail was sent *to* also
10:22:07 <ski> "curryspondence" ?
10:22:20 <shapr> my email search thing
10:22:26 <ski> oh
10:23:23 <shapr> also needs to auto url stuff where possible
10:23:30 <jadrian> lol nice name :)
10:24:39 <shapr> :-)
10:24:47 <shapr> stepcut: http://www.isi.edu/~hdaume/haskell/NewBinary/
10:32:12 * SamB wants types with numbers in them, and programmable type inference
10:32:43 <shapr> you can do the value as type thing
10:32:58 <eivuokko> Well, you will need basic operations on numbers, too.
10:33:05 <shapr> look at the way HaskellDB does varcharN for example
10:33:07 <stepcut> shapr: some day!
10:33:31 <shapr> stepcut: if we just use it, it'll be the standard
10:36:21 <SamB> hmm, the non-picklish one should have Struct in the name somewhere
10:38:09 <stepcut> shapr: but its not actually implemented yet
10:42:39 <shapr> Hal's code looks like it works
10:43:04 <shapr> it doesn't have the nifty erlang field thingies though
10:55:35 <stepcut> hrm
10:56:50 <stepcut> I wonder why I thought it didn't
10:57:02 <stepcut> I will have to start using it then
10:59:20 <shapr> maybe I'm wroong :-)
10:59:30 <shapr> just gotta try it I guess
11:03:10 <desrt> Cale; sucks to be you.
11:40:20 <kosmikus|away> SamB: you should have a look at dependent types, then
11:41:36 <SamB> kosmikus|away: I said I want *numbers* in types... do dependant types support that?
11:42:03 <kosmikus|away> SamB: with dependent types, you can define types that depend on values
11:42:28 <kosmikus|away> such as a datatype of lists with at most n elements, or similar things
11:42:45 <SamB> kosmikus|away: you can?
11:42:48 <kosmikus|away> yes
11:42:56 <kosmikus|away> but not in Haskell :)
11:43:20 <SamB> hmm. Well, I was thinking more along the lines of an array with a given shape... can you do that too?
11:43:49 <kosmikus|away> look at http://www.dur.ac.uk/CARG/epigram/ for a language in development that is based on dependent types
11:44:29 <kosmikus|away> yes, you should be able to do such things as well
11:44:56 <kosmikus|away> many of the things you can do can be encoded in Haskell using multiparameter typeclasses and functional dependencies
11:45:14 <kosmikus|away> but things get very ugly if you do them that way ...
11:46:26 <kosmikus|away> of course, I should also mention Cayenne: http://www.cs.chalmers.se/~augustss/cayenne/ in this context
11:47:06 <SamB> awww, but I want it in Haskell ;-). I don't care if the compiler won't really be able to understand it...
11:47:16 <SamB> hmm, Cayenne is written in some obscure dialect of Haskell...
11:48:50 <kosmikus|away> obscure dialect?
11:49:20 <ski> more like HBC, IIRC
11:50:53 <kosmikus|away> well, if you want it in Haskell, you might want to read the "Faking It (Simulating Dependent Types ...)" article, available from Conors home page http://www.dur.ac.uk/c.t.mcbride/
11:53:24 <kosmikus|away> some advanced type hackery partially related is also available from http://okmij.org/ftp/Haskell/types.html
11:54:13 <kosmikus|away> nested datatypes might also be interesting; with those, you can do far less than with dependent types, but still express some invariants that regular datatypes cannot; there are several papers on those ...
11:54:50 <kosmikus|away> ski: yes, that's what I remember, but I wouldn't call hbc a dialect, although it's maybe a bit "obscure" nowadays ...
11:55:15 <ski> kosmikus|away : right, that's what i meant
12:06:52 <jadrian> doesn't haskell support nested datatypes?
12:07:35 <ski> i think it does ..
12:07:45 <jadrian> Just tried data BT v = Con v | BT [v] 
12:07:50 <jadrian> and it is accepted...
12:08:07 <jadrian> that's a nested datatype, right?
12:08:20 <jadrian> (because of the  BT [v])
12:08:52 <ski> yes
12:09:05 <ski> actually, no
12:09:28 <ski> data BT v = Con v | Foo (BT [v])
12:09:34 <ski> is nested
12:09:40 <jadrian> opsss :)
12:09:51 <jadrian> typo
12:09:54 <jadrian> let me try again then
12:10:26 <jadrian> yeap it loads
12:10:57 <c_ray_c> hi, I want to learn haskell... is there a web page or something you could recommend for someone already familiar with functional programming?
12:11:22 <c_ray_c> I'm seeing a lot of stuff for people new to programming or new to functional programming and it's a little tedious to read
12:11:45 <ski> perhaps the "Gentle" tutorial on www.haskell.org, then ?
12:12:18 <kosmikus|away> Haskell does support nested datatypes
12:12:38 <c_ray_c> ok
12:12:39 <kosmikus|away> they are defined somewhat differently in different places
12:13:26 <jadrian> I just made a search and ended up on a paper by R. Bird about "de Bruijn notation" and nested datatypes
12:13:43 <jadrian> this might be useful to me as I'm using de Bruijn notation right now...
12:14:36 <kosmikus|away> the problem with nested datatypes is that although Haskell supports them, it does not support operations on them well
12:14:52 <jadrian> :-/
12:14:58 <jadrian> I never actually used them
12:15:20 <kosmikus|away> you cannot really use nested datatypes without having to write awfully complicated functions yourself or using generic programming ...
12:15:51 <kosmikus|away> still, they are interesting ...
12:16:02 <jadrian> by the way, are you familiar with genercics in haskell?
12:18:28 <jadrian> brb
12:38:22 <kosmikus|away> please tell jadrian when he returns that in this "generality", I can answer the question with "yes" ...
12:38:51 <kosmikus|away> however, I am leaving now ...
12:39:41 <c_ray_c> huh, strings are lists
12:39:52 <bringert> they sure are
12:40:01 <Lor> For good or ill...
12:41:26 <c_ray_c> are there vectors or arrays in haskell?
12:41:44 <ski> arrays, yes
12:43:27 <SamB> Haskell arrays are a bit more general than I feel they ought to be...
12:45:02 <Lor> You can use the low-level ghc arrays if efficiency is a concern.
12:46:46 <SamB> no, I just don't like the idea of having to pick where the indicies start from ;-)
12:46:55 <SamB> or all that typing
12:47:11 <SamB> well, its not the typing, really...
12:47:37 <ski> you mean you just want a sequence collection with array efficiency ?
12:48:36 <c_ray_c> ok.. they have this example:
12:48:38 <c_ray_c> map f  []               =  []
12:48:47 <c_ray_c> is the f significant?
12:49:02 <c_ray_c> could it be map g [] = []?
12:49:13 <ski> yes
12:49:20 <ski> or even
12:49:26 <ski> map _ [] = []
12:50:08 <SamB> note that the underscore is not a really variable name
12:50:17 <c_ray_c> ok
12:50:43 <ski> yes, i've heard about such on comp.object and on some OO sites i've gleaned at ..
12:51:17 <c_ray_c> so could I do foo f [] = []?
12:51:18 <ski> oops, forget that :)
12:52:07 <ski> if you want to name the first argument, and not use it later, yes
12:52:16 <SamB> c_ray_c: what for?
12:52:16 <c_ray_c> hmm.. it keeps saying ERROR - Syntax error in input (unexpected `=')
12:56:17 <c_ray_c> oh.. can't create difinitions at the command line
12:56:31 <c_ray_c> what's the point of using an interpreter then
12:57:33 <SamB> c_ray_c: if you use ghci, you can use let to make definitions...
12:59:16 <SamB> c_ray_c: if you've used C, I'm sure you know how annoying it is to not be able to test stuff without either making a new main or changing an existing main.
13:01:20 <c_ray_c> yeah
13:19:20 <cgibbard> The interpreter lets you test functions that you've defined in a file.
13:19:38 <cgibbard> I think of it as a debugger.
13:33:49 <stepcut> c_ray_c: I tend to use ghci as an emacs subprocess. I typically edit a file, then hit C-c C-l to load the file in ghci, and then call different functions by hand in ghci.
13:35:11 <stepcut> by editing in a separate buffer and loading it into ghci, it makes it easier to fix bugs in the function anyway
13:47:36 * Marvin-- sighs
13:47:55 <Marvin--> I so don't know what I'm doing
13:50:52 <jak_> Hi guys, I'm trying out HDaume's NewBinary (the link that shapr posted earlier) but I'm getting Prelude> :load TestBits.hs
13:50:53 <jak_> TestBits.hs:
13:50:53 <jak_>     Can't find module `IOExts'
13:50:53 <jak_>     (use -v to see a list of the files searched for)
13:50:53 <jak_>  from ghci. Any ideas?
13:51:14 <Marvin--> IOExts is a hugs thing, I think
13:52:44 <jak_> hmmm...
13:53:34 * Marvin-- swears at cooling schedules
13:54:20 <jak_> Marvin--: simulated annealing?
13:54:30 <Marvin--> jak_: yeah
13:54:57 <Marvin--> I've implemented a simulated annealing algorithm for graph colouring and I have no idea what cooling schedules to use
13:55:38 <jak_> Cool. Yeah I implemented something using simulated annealing for map label layout (somebody elses idea) 
13:55:57 <jak_> also had no idea what cooling schedule to use. Just tried and errored.
13:56:57 <jak_> you doing this in Haskell?
13:57:01 <Marvin--> yep
13:57:21 <jak_> excellent!
13:58:26 <Marvin--> I'm starting to wonder if we've made it too hard on ourselves though
13:59:20 <Marvin--> we're trying to solve the problem of minimizing the number of colours used, so we assume we have as many colours available as there are vertices, and all the states in the markov chain are valid colourings
14:00:00 <Marvin--> the problem is that means the number of state neighbours aren't constant so we have to compute them over and over (since the chain is computed on the fly)
14:00:27 <Marvin--> otoh, it makes the energy function pretty simple
14:02:04 <jak_> How many colours do you need typically?
14:02:30 <Marvin--> well, we generate our test graphs randomly, so obviously it varies :)
14:02:49 <stepcut> jak_: did you try commenting out the 'import IOExts', it might just work...
14:03:05 <Marvin--> good point, stepcut
14:03:25 <jak_> stepcut: yeah, so far so good now FastMutInt.lhs is looking for PrelIOBase
14:03:54 <stepcut> try commenting that import out too
14:04:12 <jak_> Marvin--: have you done algorithm to just colour the graph (ignoring trying to find the minimum colouring?)
14:04:32 <jak_> stepcut: ok
14:05:28 <Marvin--> jak_: no, that'd be the other thing we're considering, instead implementing an algorithm that tries to assign a fixed set of colours to the graph, it would make the transitions way simpler
14:08:37 <jak_> yeah, that's probably the easiest approach initially. 
14:09:08 <jak_> FastMutInt.lhs has horrible #include "MachDeps.h" in which ghc doesn't like...
14:09:33 <jak_> FastMutInt.lhs:15: lexical error
14:09:40 <jak_> http://www.isi.edu/~hdaume/haskell/NewBinary/FastMutInt.lhs
14:09:44 <stepcut> hrm
14:10:43 <jak_> ghc -cpp -c FastMutInt.lhs gets up to line 40
14:10:44 <stepcut> try adding -cpp to the command-line by hand maybe?
14:10:53 <jak_> FastMutInt.lhs:40: parse error on input `#'
14:11:05 <jak_> data FastMutInt = FastMutInt (MutableByteArray# RealWorld)
14:12:17 <jak_> I'm sure that I need to enable glasgow exts, but:
14:12:39 <jak_> ghc -fglasgow-exts -cpp -c FastMutInt.lhs
14:12:39 <jak_> FastMutInt.lhs:22:
14:12:39 <jak_>     Failed to load interface for `GlaExts':
14:12:39 <jak_>         Could not find interface file for `GlaExts'
14:12:39 <jak_>         (use -v to see a list of the files searched for)
14:12:49 <stepcut> hrm
14:13:10 <stepcut> add -package lang maybe?
14:13:44 <jak_> Spot on stepcut
14:13:51 <jak_> ghc -fglasgow-exts -package lang -cpp -c FastMutInt.lhs 
14:13:53 <jak_> did the job
14:14:01 <stepcut> cool
14:17:27 <jak_> NewBinary/Binary.hs:81: Module `GHC.Handle' does not export `openFileEx'
14:22:21 * shapr hops
14:23:07 <shapr> Si\: ltns, wassup?
14:23:42 <shapr> jak_: did it compile?
14:24:40 <jak_> getting there... I think it was last testing ghc 5.03
14:24:46 <shapr> oh
14:25:03 <shapr> Hal may have a later version offline
14:25:14 <shapr> I'll email him
14:25:19 <jak_> Thanks shapr
14:26:26 <stepcut> http://www.mail-archive.com/glasgow-haskell-bugs%40haskell.org/msg05667.html
14:27:42 <stepcut> you might be able to import IOExts now that you have '-package lang'
14:27:43 <shapr> @type GHC.Handle.openFileEx
14:27:44 <lambdabot> bzzt
14:28:01 <stepcut> @type IOExts.openFileEx
14:28:02 <lambdabot> bzzt
14:28:11 <stepcut> :(
14:28:19 <shapr> it doesn't run with any -lang args
14:28:23 <jak_> Looks like it's working though
14:28:26 <shapr> er -package
14:28:28 * shapr is sleepy
14:28:38 <stepcut> cool
14:29:08 <jak_> stepcut: ahh
14:30:43 <shapr> ok, sent email to hal, hopefully I'll hear back from him soon
14:30:52 <shapr> but for now, sleep
14:31:05 * jak_ is tired too
14:31:23 <stepcut> on feb 8,2004 hal indicated that was the latest version
14:31:31 <jak_> Marvin--: what about a binary search on graph colourability
14:31:43 <stepcut> but maybe he has done more since then :)
14:32:07 <jak_> It would be cool if it was a standard library
14:32:21 <Marvin--> jak_: ?
14:32:56 <stepcut> jak: agreed! 
14:32:59 <jak_> So you start with the halft the upper bound (number of nodes) and see if it can be coloured, if yes then halve again
14:33:26 <jak_> Rather than starting at 1 and working your way up.
14:35:40 <Marvin--> I don't see what that'd buy
14:36:05 <jak_> hmm.. yes maybe i'm talking rubbish :)
14:36:33 <Marvin--> we already have an algorithm implemented, the problem is figuring out some sort of decent cooling schedule
14:50:28 <jak_> Cheers guys
15:08:20 <earthy> say, marvin--
15:08:35 <earthy> have you spoken to Koen at all this week?
15:11:52 <Marvin--> damn
15:11:59 * Marvin-- runs away and hides
15:13:01 <earthy> thought so. :)
15:13:15 <earthy> now I'm going to have to use my telephone-fu tomorrow. ;)
15:14:00 <Marvin--> sorry :(
15:14:07 <earthy> no probs
15:14:19 <earthy> I also have to track down John Peterson
15:15:07 <earthy> and syntaxpolice
15:15:51 <earthy> but first, time for bed.
15:16:37 <Marvin--> good plan
15:17:11 <earthy> damn.
15:17:23 <earthy> I should've read syntaxpolice's blog earlier
15:18:05 <Marvin--> ?
15:20:02 <earthy> he's out visiting and hiking and stuff, afaict
15:20:12 <Marvin--> oh
15:20:19 <earthy> oh well. nytol.
15:38:42 <SamB> hmm, can you add apples and oranges in Haskell?
15:41:05 <Lunar^> earthy: He got closer from both Simons :)
15:43:15 <Lunar^> Cool, we'll have a release of the library infrastructure for EuroHaskell
16:59:57 <desrt> hey cale
17:00:09 <desrt> anyone know anything about ghc (or anything else) targetting embedded platforms?
17:00:23 <desrt> i think someone mentioned the other day that someone was trying to verify ghc and make it run on bare metal....
17:51:21 <np_hard> hmm
17:51:26 <np_hard> trying to build HaXML on OS X
17:51:29 <np_hard> ld: unknown flag: --whole-archive
17:51:44 <np_hard> during ar: creating archive libHSHaXml.a
17:57:00 <np_hard> hxmltoolbox dies on OS X too
17:57:09 <np_hard> In file included from /tmp/ghc802.hc:7:
17:57:23 <np_hard> readline/readline.h: No such file or directory
17:59:03 <Lunar^> np_hard: Do you have fink ?
17:59:33 <np_hard> yes
17:59:39 <np_hard> readline is installed
18:00:55 <Riastradh> Did you tell it to look in /sw for the readline junk?
18:01:15 <np_hard> hmm, I better double-check env variables
18:01:20 <np_hard> thought I had one set for that
18:06:51 <Lunar^> You need readline-dev also
18:09:38 <np_hard> don't see a package for that in fink list
18:09:53 <np_hard> i only track "stable" iirc
18:19:17 <np_hard>  Lunar: I actually don't see a readline-dev package
18:19:28 <np_hard> just got the unstable packages
18:21:38 <np_hard> not sure what in HXmlToolbox should need readline anyway :-/
18:26:55 <np_hard> hm, I will install the fink-unstable port of ghc
18:27:13 <np_hard> the install I have was the one someone put together using Apple installer
19:07:01 <SamB> hmm, Yosomono is calling Haskell names...
19:07:37 <np_hard> how does one call a language names?
19:07:50 <ozone> ghc's in fink now?
19:07:56 <np_hard> ozone: in unstable
19:08:06 <np_hard> don't know what version
19:08:20 <np_hard> fink needs some help, maybe I should try to get involved
19:08:50 <SamB> he is claiming that haskell isn't really useful for actual use
19:08:53 <np_hard> with the large userbase you'd think more people would be doing enough testing to move from unstable to stable
19:09:02 <np_hard> SamB: who is Yosomono?
19:09:02 <SamB> in #twisted
19:09:09 <np_hard> oh
19:09:23 <np_hard> well, I have written some Unix-style utilities in haskell
19:09:29 <np_hard> seems just as credible as perl
19:09:33 <np_hard> much nicer to read
19:09:41 <np_hard> sometimes even faster depending on the task
19:10:32 <SamB> I don't think "as credible as perl" qualifies as an endearing characteristic in #twisted...
19:10:41 <np_hard> :)
19:10:42 <np_hard> python, then
19:11:19 <np_hard> depends on what you need to do. the big issue with haskell is the critical mass, it's hard to justify writing something in haskell if future maintenance is important because of the lack of developers
19:11:37 <np_hard> but then, until people write in haskell, there will be few haskell developers
19:12:30 <SamB> really, Haskell is not as easy to write as it should be.
19:12:41 <Cale> I'm working on a project in Haskell to write a compiler for a new declarative language called Coconut. It will initially be used for writing real-time imaging software for MRI.
19:13:27 <np_hard> the compiler errors are certainly speaking in a different tongue than conventional compilers
19:13:39 <np_hard> but then, looking at them it's hard to figure out a better way to phrase them
19:15:27 <ozone> np_hard: there's a lot of research being done (believe it or not) solely on compiler error messages
19:15:55 <ozone> the helium guys are making some good progress in that area
19:16:36 <np_hard> ozone: I believe it! As a relative newbie it is by far my biggest roadblock and frustration
19:17:13 <np_hard> ozone: but like I said, it's rough to point out obvious flaws in them most of the time.
19:17:20 <Cale> Where I'm working it seems that people are learning Haskell really fast.
19:17:37 <np_hard> where I work, Python is considered way-out
19:17:40 <np_hard> Perl is everywher
19:17:42 <np_hard> e
19:17:45 <np_hard> what a POS language
19:17:51 <Cale> I think it helps a lot to have personal support from friends and co-workers.
19:18:22 <ozone> np_hard: now now, be nice
19:18:23 <np_hard> yeah, I think I have a potential ally for Python, at least
19:18:37 <np_hard> the issue is the sysadmins are scared to install 2.3.3
19:18:44 <np_hard> RHAS 2.1 has 1.5.2
19:18:49 <ozone> maybe i really am the only person left on earth who loves perl and haskell, hmm
19:18:56 <np_hard> maybe I can lean on them if I show them the benefits
19:19:08 <Cale> ozone: talk to desrt :)
19:19:34 <Cale> Actually, I don't mind perl for really small things.
19:21:20 <SamB> ozone: well, the perl maniacs are spoiling our perspective on perl
19:21:30 <SamB> or at least, they might be
19:21:33 * flaw likes sh :)
19:21:34 <np_hard> I think Perl 6 might be a huge flop
19:22:13 <ozone> SamB: s/perl/(insert x here)/g
19:22:19 <SamB> I hope parrot is
19:22:26 <SamB> it has waaaaaaay to many opcodes
19:22:40 <ozone> you hope parrot is a flop because it has way too many opcodes?
19:25:04 <np_hard> the perl people I know seem quite content with 5.8.x
19:25:17 <np_hard> many don't use the OO or closures at all
19:25:33 <ozone> i was quite happy with 5.004 :)
19:25:38 <np_hard> heeh
19:25:49 <ozone> np_hard: perl 6 does look quite nice
19:25:53 <ozone> they've taken some very good ideas from everywhere
19:26:06 <np_hard> IIRC so did PL/I
19:26:24 <ozone> well, remains to be seen whether people will actually use perl 6 or not
19:26:37 <ozone> but as a language, i think it'll shine
19:28:21 <np_hard> I think my preferred languages will end up being C, Python, and Haskell
19:28:29 <np_hard> depending on the situation
19:28:40 <np_hard> naturally at work I program Perl and Java
19:28:43 <np_hard> :-/
19:34:15 * Spark experiences pain
19:37:51 <Spark> where would we be without pain
19:38:48 <Spark> trying to eat doritos, while only using half your mouth is an interesting challenge
19:39:12 <SamB> hmm, I am not good at explaining monads. exarkun asked what they are ;-)
19:39:32 <Riastradh> Generalizations of computation.
20:09:52 <SamB> why can't you do $( $( [| [| 1 |] |] ) )?
20:22:08 <SamB> hmm, I'm starting to see why epigram requires xemacs, I think
20:34:54 <np_hard> where is popen2 in the ghc library?
20:36:23 <desrt> it's outside of prelude
20:41:07 <Cale> popen2?
20:41:40 <np_hard> popen, don't care which
20:41:55 <Cale> http://www.haskell.org/~petersen/haskell/popenhs/
20:43:29 <np_hard> hmm, thought it would be included with ghc by now
20:45:28 <Cale> What it does there isn't all that complicated if you stare at it a while. I'm actually kind of surprised that it comes with a configure script and everything :)
21:00:05 <flaw> dict.org has quite a def on monad
21:47:59 <desrt> hum
22:24:39 * Cale is away: Probably not here.
