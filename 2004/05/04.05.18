00:54:18 <juhp> haskell.org is still down?
00:54:24 * juhp wonders
00:56:43 <cbus> yepp :/
00:57:58 <eivuokko> Maybe we should but mirror url into topic
01:02:57 <earthy> trouble being that the mirror isn't complete
01:03:21 <eivuokko> Yea.
01:04:08 <earthy> anywho, I'd almost try to offer to host it on site here
01:04:23 <earthy> our sysadmins know how to deal with somewhat high-volume traffic. :)
01:04:47 <earthy> maybe I should suggest that.... hmmm....
01:12:51 <earthy> whehehehehhe... people still sending in stuff for the HC&AR
01:15:26 <adept> hi there!
01:16:31 <adept> Stupid question : why "(==0).(mod 5) 10" means "(==0).((mod 5) 10)" and not "((==0).(mod 5)) 10"? Why function application has greater priority than superposition?
01:17:19 <skew> function application has higher priority than everything
01:17:38 <adept> skew: i know. question: why? :)
01:17:56 <adept> skew: is it just a design decision or am I missing something obvious?
01:17:59 <skew> you don't want stuff like 1 + sum [2,3,4] to mean (1 + sum) [1,2,3], etc
01:18:53 <adept> skew: ok. Look at it from the other end: why (.) is lower that fun app?
01:19:36 <skew> again, the types rarely make sense the other way
01:19:53 <adept> skew: can you give me example please?
01:19:55 <skew> I guess they do work out better here
01:20:44 <skew> can you think of a case where you would want an operator to bind tighter than application?
01:20:49 <adept> skew: i have the same gut feeling, but was hoping to find something better than that
01:22:55 <adept> skew: operator tighter than app? here: "filter (==0.fst) pairList".
01:27:01 <earthy> so you'd want that to be parsed   filter (== (0.fst)) pairList ??
01:27:02 <skew> there isn't any deep reason
01:27:16 <skew> it's just usually more conevnient
01:29:14 <earthy> and you always have brackets for when it isn't
01:29:51 <adept> that's basically what i looked for : it there a deep reason or there is not :)
01:30:00 <adept> ^it there^is there^
01:30:36 <earthy> there's a shallow reason. `it works better'. :)
01:30:49 <Shammah> can anyone recommend a good introduction to arrows, and programming with arrows?
01:31:24 <earthy> `Arrows and computation' by Ross Patterson
01:32:10 <earthy> http://www.soi.city.ac.uk/~ross/papers/fop.html
01:33:10 <Shammah> thanks.
01:41:59 <skew> That paper is still pretty hard to understand
01:42:11 <skew> it's probably the best one out there, though
03:04:57 <Lukhas> is there a function that returns the position of an element in a given list ?
03:05:12 <Jerub> yes!
03:06:36 <Lukhas> yes ?
03:07:14 <Jerub> List.hs has 'elemIndex', which is probably what you want.
03:08:31 <Lukhas> yes, thanks
03:15:14 <Lukhas> hmm, elemIndex returns something of the form "Just x"
03:15:26 <Lukhas> how can i get just the x ?
03:16:21 <Lukhas> oh, better, i'll use elemIndices and extract the number
03:16:29 <Lukhas> that way i'll avoid things i don't know yet
03:17:39 <Jerub> you do exactly that.
03:19:32 <Jerub> f = let Just x = elemIndex 3 [2,2,2,2,3,3,3]
03:19:33 <Jerub>     in x
03:19:39 <Jerub> Main> f
03:19:39 <Jerub> 4
03:22:29 <Lukhas> hmm
03:24:59 <Lukhas> ok, i get it, i think
03:25:46 <Jerub> its pattern matching.
03:25:56 <Jerub> same deal as when you iterate through lists:
03:26:11 <Jerub> g (x:xs) = x + (g xs)
03:26:14 <Jerub> g [] = 0
03:26:18 <Jerub> you can do:
03:26:23 <Jerub> g Just x = x
03:26:28 <Jerub> g Nothing = 0
03:26:50 <Jerub> g (elemIndex 3 [2,2,2,2,3,3,3]) == 4
03:26:56 <Jerub> g (elemIndex 9 [2,2,2,2,3,3,3]) == 0
03:29:50 <Lukhas> ok
03:29:51 <Lukhas> thanks
03:31:34 <Jerub> pattern matching is wonderfully powerful, in fact: so powerful it'll work when you think it just can't.
03:32:01 <Lukhas> it seems so
04:05:04 <iolotusbobo> hello shapr
04:37:33 <skew> I just found something interesting - UUAG let's default values for USE rules contain attribute references
04:38:58 <skew> I've written a version of the repmin example with only one semantic rule, to feed the minimum back down
04:41:18 <skew> if the generalized copy rule searched the child and nodes to the right at the very last step I could do it without any explit rules at all.
04:41:44 <skew> I wonder how often the top level of a computation just feeds a value back down
04:41:50 <skew> pretty often, I'd guess
04:42:38 <kosmikus> often, yes, but for larger grammars, this procedure happens at multiple places, not only at the very top, and also for multiple values
04:42:49 <kosmikus> what exactly would you like the generalized copy rule to do?
04:44:27 <skew> after trying all the other places, feed down a synthesized attribute of the same name from the remaining children, starting from the right
04:45:12 <kosmikus> feed down synthesized -- I'm confused ...
04:45:31 <skew> DATA Child [ | chained : Type | ]
04:45:45 <skew> DATA Parent | Parent child:Child
04:46:23 <skew> the semantics that would make the toy example nice are a generated copy rule equivalent to SEM Parent | Parent child.chained = @child.chained
04:46:37 <skew> It might even be useful in practice
04:47:02 <skew> I don't think it probably happens too often with several children that you want to feed an attribute around in a loop
04:47:11 <skew> but that's the natural generalization
04:47:41 <kosmikus> I see what you mean now
04:49:23 <kosmikus> I can see that I might like that
04:49:28 <skew> If you have a tree of nodes with a chained attribute the existing copy rule will thread the attribute through internal nodes and loop it around at the leaves, but not at the root
04:51:49 <skew> I don't know if using the same name all around a loop like that is a good idea
04:52:07 <skew> I have arguments both ways
04:53:30 <kosmikus> the main argument against it is that copy rules can always be applied unintentional, and this particular one can immediately lead to looping programs, and loops in AG's aren't easy to find
04:54:13 <kosmikus> as I said, I can see that I (personally) might like it, but I don't think there's any chance convincing the other ones here to allow that behaviour
04:54:33 <kosmikus> I touched the copy rule once, at people still complain that I did, so I won't do it again :)
04:54:42 <skew> then maybe it could be a flag
04:54:51 <skew> actually, it might be nice as an annotation on the attribute
04:55:03 <kosmikus> send a patch ...
04:55:20 <skew> ATTR set [ | name CYCLE : Type | ]
04:55:33 <skew> you have worked on uuag?
04:55:41 <kosmikus> yeah, actually, that was my idea a while ago
04:55:43 <skew> what did you do to the copy rule?
04:55:51 <iolotusbobo> hello skew
04:55:53 <kosmikus> to specifiy attribute types that way
04:56:02 <skew> iolotusbobo: hi
04:56:11 <iolotusbobo> how r u skew?
04:56:11 <skew> name : Type, or the little annotations
04:56:17 <kosmikus> that you'd say ATTR Tree  min CHAINED : Type
04:56:24 <iolotusbobo> tried any of the codeS?
04:56:25 <kosmikus> instead of the very limited [ | | ] syntax
04:56:31 <iolotusbobo> skew, ^^ 
04:56:45 <kosmikus> then you could have RIGHT_CHAINED, LEFT_CHAINED, CYCLIC, or whatever other variations you like
04:56:51 <skew> iolotusbobo: what codeS?
04:56:54 <kosmikus> and there's no chance for confusion by using different flags
04:56:58 <skew> iolotusbobo: are you learning Haskell?
04:57:42 <kosmikus> skew: yes, I have worked on uuag a while ago; well, my version of the copy rule is still available as a flag, I think, using --modcopy ...
04:58:22 <skew> how is your rule different?
05:04:33 <kosmikus> in the treatment of local variabels
05:04:43 <kosmikus> /s/el/le
05:05:17 <kosmikus> in the default variant, a local variable of the same name has priority over everything else
05:05:20 <skew> I think local variables with the name of a chained attribute are completely useless at inner nodes
05:05:59 <kosmikus> yes, because of this "failure" ;)
05:07:03 <kosmikus> my rule behaves as described at http://www.cs.uu.nl/~andres/talk3.pdf, page 26 (A closer look at copy rules)
05:08:11 <kosmikus> it's just not that consequent to do the "backfeed" that you requested ...
05:10:25 <iolotusbobo> skew, no i am not learning haskell... but i plan to
05:11:11 <skew> not that consequent?
05:12:00 <skew> I thought about the local variables a while back and couldn't decide whether it would be better to have them where you put them, or only affecting the final synthesized result
05:12:37 <iolotusbobo> skew, could you point me to some good online resources for haskell
05:12:58 <skew> I guess I was thinking the rule would fall back to the old behaviour if the attribute wasn't being chaned through
05:13:25 <skew> but your way (or the implemented way) is the only one that makes sense if you want to use the same rule everywhere
05:13:38 <skew> iolotusbobo: lots of good stuff at haskell.org, which is down at the moment
05:14:29 <kosmikus> skew: well, another thing is that there's really no internal difference right now between [ x : Type | | x : Type ] and [ | x : Type | ], so it is not "known" if an attribute is explicitly chained or not
05:16:32 <JaffaCake> haskell.org news: They have been running diagnostics trying to figure out what's wrong.
05:16:32 <JaffaCake> We're hoping we don't have to replace the whole thing.  We'll try and
05:16:32 <JaffaCake> get this resolved soon.
05:16:44 <JaffaCake> (from John Peterson at Yale)
05:17:07 <shapr> yay
05:18:21 <iolotusbobo> skew haskell.org is not working currently?
05:18:26 <iolotusbobo> hello shapr
05:18:40 <shapr> hi
05:19:08 <iolotusbobo> howz everything shapr
05:19:08 <eivuokko> There is a (partial) mirror at http://www.mirror.ac.uk/sites/www.haskell.org/  Sadly f.ex. wiki is missing :\
05:19:12 <Lukhas> hi shapr
05:19:31 <JaffaCake> maybe someone should put that mirror in the channel title?
05:19:33 <shapr> bonjour Lukhas
05:19:46 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","haskelldb 0.8 released","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell", "http://www.mirror.ac.uk/sites/www.haskell.org/"]' by eivuokko
05:19:55 <iolotusbobo> eivuokko, any idea when haskell.org will be up again ?
05:20:32 <JaffaCake> 99 people :)
05:20:54 <shapr> hah
05:20:57 <JaffaCake> lol
05:21:04 <Lukhas> héhé
05:21:27 <shapr> there were 107 at some point yesterday
05:21:34 <liiwi> yo
05:21:42 <shapr> hei liiwi
05:21:51 <liiwi> hej hej
05:22:35 <shapr> anyway, we got quality more than quantity
05:23:03 <Lukhas> yeah
05:26:53 <shapr> I didn't understand the attribute grammar discussion above, means I have something nice to add to my compulsive learner's menu.
05:27:11 <skew> attribute grammars are nifty
05:28:02 <shapr> I believe you, and I once I start learning about them I'll remember to ask you and kosmikus about them.
05:28:33 <skew> I was shaking the bitrot out of the beginnings of a compiler I have lying around
05:28:49 <skew> so I was looking at the new alex and uuag
05:29:54 <shapr> I'd like to try the UHC Syntax Macros, even if they don't work on left recursive grammars yet
05:30:58 <shapr> I wonder if they could easily be used to reimplement the recent 'pattern matching extended to regexes' preprocessor 
05:31:05 <neologism> read this:
05:31:05 <neologism> http://www.osnews.com/story.php?news_id=7078
05:31:16 <neologism> quite funny statements about haskell ;)
05:32:19 <Maddas> That's probably because it doesn't have any iterative loop statement
05:32:22 * Maddas shakes his head
05:32:54 <Lukhas> "Haskell or anything looking unusual."
05:33:03 <Lukhas> well, Haskell *is* unusual :)
05:33:11 <Maddas> The whole thing looks pretty silly
05:33:27 <neologism> go on reading
05:33:41 <neologism> the article is quite accurate
05:33:43 <Maddas> "In other words, this is the core of reasons why script programming; C++ style OOP, as oppose to Objective-C style or SELF-like style; UNIX-style IO operations, as oppose to Java-style; are so popular."
05:33:46 <Maddas> Objective-C isn't popular? Interesting
05:33:47 <neologism> but the point is on the end
05:34:16 <Maddas> I find the article silly
05:34:44 <Maddas> haha
05:34:47 <neologism> I understand it as haskell (and other things described) is usefull but noone understands it
05:34:49 <flaw> hah
05:34:53 <flaw> miserable failure?
05:35:01 <Lukhas> hehe
05:35:05 <Maddas> The creators of Next thought it is insanely great but not many people, many enough for being commercially feasible, shared the view. 
05:35:10 <Maddas> Is he saying that next is not commercially feasible?
05:35:12 <flaw> ISTM that haskell is just getting started...
05:35:17 <earthy> shapr: that is one of the perfect examples of the use of the syntax macros stuff
05:35:24 <Lukhas> well, that's why i don't read OSnews articles.
05:35:54 <Maddas> I'm sure Apple will be interested to hear that Objective C isn't popular and nobody was interested in Next 
05:36:01 <skew> I read that as "people are too stupid to use anything new even if it has great advantages"
05:36:23 <shapr> on the good side, he called us all geniuses.
05:36:30 <Lukhas> yeah :)
05:37:02 <neologism> skew: I read it the same way - and I agree
05:37:56 <shapr> I think this guy is clueless and irritated at having to learn new stuff
05:38:06 <earthy> There isn't anything even remotely insightful in that article
05:38:48 <skew> it's not even remotely true
05:39:01 <skew> after all, they say that everybody uses C and stuff
05:39:07 <Maddas> I think it's hardly worth discussing
05:39:11 <skew> but what about FORTRAN, and assembly and so on?
05:39:15 <Lukhas> that's the purpose os OSnews : generate endless trolls
05:39:19 <Maddas> and "concurrency is pointless because the computer works sequentially"
05:39:21 <Lukhas> s/os/of/
05:39:26 <flaw> hehe sweet
05:39:34 <flaw> automatic troll generator..
05:39:46 <Maddas> Lukhas: I guess, I view it as something like slashdot in that regard :-
05:39:47 <Maddas> )
05:39:56 <skew> good ideas are a bit slow to make it into practice, but we all hope they get there eventually
05:39:59 <Lukhas> yeah, but without the news :)
05:40:08 <Maddas> haha
05:40:16 <Maddas> yeah, something like thot
05:40:18 <Maddas> that
05:40:52 <Maddas> I eventually decided that getting stuff done is more fun than being annoyed about trolls, so I just stopped reading either
05:41:13 <Maddas> And I didn't miss out on anything important/very interesting yet, from what I can tell
05:45:16 * shapr tries to think of a good name for a Haskell oriented slashdot
05:46:02 <Maddas> hashdot?
05:46:06 <Maddas> maybe not :-)
05:46:20 <Igloo> That's what popped into my head too  :-)
05:46:45 <Maddas> I thought the same thing like Igloo, does that mean 
05:46:46 <Igloo> And it's even got the #. thing going
05:46:47 <Maddas> that I'm smart too? :-)
05:46:54 <shapr> the combinator? the monadic tribe?
05:47:00 <Maddas> (Since great minds think alike)
05:47:00 <shapr> hmm, #.
05:47:02 <Maddas> shapr: haha
05:47:09 <Igloo> Nah, it means you're as dumb as me
05:47:15 * shapr grins
05:47:22 <neologism>  \x -> troll ?
05:47:22 <Maddas> Igloo: You have no idea how dumb that would make you :-P
05:48:10 <shapr> Haskeletons in the Closet?
05:48:23 <adept> This message is encrypted.
05:49:48 <Igloo> If you call it #. someone's going ot need to write a library in which x #. y means lookup x in category y on hashdot or something 
05:51:17 <shapr> heh
05:51:38 <shapr> that'd also give us freshhash
05:52:52 <Shammah> shapr: Well the comment section is definately a Y-Combinator ;)
05:54:31 <Shammah> after all, what better way to represent Godwin's law, than as the least-fixed-point of a topic-cascade.
06:04:02 <shapr> heh
06:06:55 <Shammah> I was starting to wonder if I'd get a response :)
06:15:39 <shapr> g'day Ninja Jones, when can we expect a blog update?
06:16:43 <SyntaxNinja> shapr: hm. probably today, late.
06:17:07 <shapr> ok
06:21:03 <SyntaxNinja> shapr: how've you been?
06:22:31 <shapr> lotsa work
06:22:37 <shapr> how're you?
06:25:57 <SyntaxNinja> not bad. getting caught up
06:26:02 <SyntaxNinja> took yesterday off since I hadn't had any sleep
06:52:37 <JaffaCake> hi SyntaxNinja :)
07:02:48 <earthy> hey, it's a syntaxninja!
07:03:51 <earthy> any chance of getting a HC&AR contribution from you before tomorrow? :P
07:04:31 <earthy> (tomorrow afternoon, 14:00 UTC)
07:06:40 <SyntaxNinja> earthy: yeah, I can probably do that.
07:06:48 <SyntaxNinja> earthy: did you get one for Aetion yet?
07:06:51 <SyntaxNinja> hi JaffaCake :)
07:07:42 <earthy> syntaxninja: yeah, Mark sent me something
07:11:07 <shapr> I'm tempted to rip off a copy of haskell.org and put it on ScannedInAvian
07:11:30 <cbus> wget -r ;)
07:11:44 <shapr> I have shell access :-P
07:11:55 <cbus> that works aswell i suppose :)
07:13:18 <shapr> oh, you think you'll be in gothenburg for EuroHaskell?
07:13:36 <cbus> might drop by
07:13:42 <shapr> nifty
07:13:45 <cbus> since i kinda live in gothenburg :)
07:14:10 <shapr> det lÃ¥ter bra
07:18:43 <earthy> how can you `kinda live' somewhere?
07:18:58 <earthy> is that like being `kinda dead'?
07:19:24 <cbus> almost
07:20:17 <earthy> <cue monty python parrot sketch>
07:20:33 <shapr> VOOM
07:20:36 * adept . o O ("while writing e-mails, i often replace "kinda regards" to "kind regards" ...)
07:22:34 <earthy> ;)
07:30:40 <earthy> um, shae, just to give you a heads up: http://www.ScannedInAvian.org/iohcc needs to be up by friday at the latest. :P
07:32:28 <shapr> right, thanks :-)
07:49:11 <adept> ppl, who know how foldr is called in xemacs? :)
07:50:00 <Lunar^> earthy: How is HC&A going ?
08:02:00 <earthy> well
08:02:09 <earthy> another day, day and a half, and it'll be done
08:02:36 <earthy> I had to cut some information from the author list, as it wouldn't fit one page any more. :)
08:03:18 <shapr> Lukhas: what's foldr in elisp?
08:03:40 <shapr> earthy: that's great!
08:03:58 <shapr> oh, where's the status page again?
08:04:35 <earthy> you mean http://www.haskell.org/communities/topics.html ?
08:04:44 * Marvin-- breathes a sigh of relief
08:04:50 <shapr> aha, yes
08:05:03 <shapr> Marvin--: CONGRATULATIONS!
08:05:15 <shapr> you survived!
08:05:51 <Marvin--> it seems like I did
08:06:45 <adept> shapr: I get it. In elist, they dont foldr. They just (while (not (null somelist)) ... (setq somelist (cdr somelist)))
08:07:04 <shapr> oh
08:07:13 <shapr> I keep meaning to learn elisp
08:07:24 <earthy> there, updated a bit. :)
08:07:44 <earthy> anyway, time to get going
08:09:02 * shapr looks for missing entries
08:10:34 * shapr chortles @ "Haskell IRC channel [if you never want to find time to work again... ;-)]"
08:11:12 <shapr> oh, I promised a QuickCheck entry
08:13:59 <Marvin--> shapr: eh? where's that from?
08:16:06 <shapr> from the HC&AR status page
08:16:14 <Marvin--> where's that?
08:16:24 <Marvin--> oh, never mind
08:17:37 <shapr> :)
08:17:57 <shapr> does vim do utf8?
08:18:03 <Marvin--> of course it does
08:20:53 <andersca> Marvin--: it was a good presentation, really interesting stuff
08:22:00 <Marvin--> thanks
08:23:11 <kosmikus> Marvin--: hey, congratulations; you survived :)
08:23:17 <Marvin--> so it seems :)
08:23:23 <kosmikus> oh, I am repeating shapr
08:23:24 <kosmikus> :)
08:23:30 <kosmikus> did not realize that
08:23:46 <Marvin--> despite the evil professors and despite the presence of the safelogic CTO ;)
08:26:35 <shapr> what's the safelogic and chalmers connection?
08:27:46 * Igloo wonders why shapr asked
08:28:07 <Marvin--> dunno
08:28:32 <shapr> I've heard some stuff that makes me wonder
08:30:01 <Igloo> Oh, why you asked about vim and utf8
08:30:22 * Igloo realises the rest of you aren't 10 mins behind the conversation  :-)
08:30:35 * Igloo heads off to a talk
08:31:53 <Marvin--> haha
08:39:17 <shapr> andersca: is there emacs to dbus integration?
08:40:03 <andersca> shapr: not that I know, why?
08:41:09 <shapr> I'm looking for a way to do distributed/virtual pair programming
08:41:49 <shapr> but I want to be able to use emacs on a file while Marvin-- uses vim, and we both see changes in nearly realtime
08:42:27 <shapr> so I thought broadcasting buffer changes via dbus might be a good solution
08:42:49 <shapr> what do you think?
08:43:24 <andersca> that might work, yeah
08:43:51 <Marvin--> but dbus is local to one computer, right?
08:43:58 <Marvin--> guess you could tunnel it over ssh or something, though
08:44:27 <andersca> hmm, what's that example you use to show why forall may be needed
08:45:17 <ozone> shapr: not that it helps you, but there's a fantastic mac os x program called subethaedit which does just that
08:45:50 <ozone> shapr: wolfgang and i ended up hacking on some haskell code together at HIM last year with that, very cool
08:45:54 <shapr> yah, I've heard of it, any idea how it deals with that issue?
08:45:58 <ozone> anyway, back to non-mac land
08:46:19 <ozone> shapr: it uses a diff algorithm to send over changes to the remote machine
08:46:32 <shapr> in near realtime?
08:46:47 <ozone> realtime enough that you call it 'realtime' :)
08:46:54 <shapr> sounds good
08:47:45 <Marvin--> andersca: what do you mean "why forall may be needed"?
08:48:28 <andersca> Marvin--: I remember a simple example that would only type-check if you used forall somewhere
09:07:38 <Marvin--> andersca: I don't think you need it unless you have rank-2 polymorphism
10:07:03 <shapr> "After a stalled effort on Monday, the European Council has approved controversial changes to a draft directive, meaning that Europe is now likely to see widespread patenting of software programs"
10:07:14 <Lunar^> shapr :(
10:07:23 * shapr swears viciously
10:07:24 <Lunar^> shapr: Should we organize a demo during EuroPython ? ;)
10:07:33 <shapr> demolition maybe
10:08:13 <shapr> http://news.zdnet.co.uk/business/legal/0,39020651,39155028,00.htm
10:08:23 <Lunar^> shapr: anarchist ! :p
10:08:36 <shapr> shh
10:08:41 <shapr> ;-)
10:08:47 <Lunar^> (who's telling that already ?)
10:09:12 <cbus> shapr: i heard something about apple trying to get a patent on transparent windows
10:09:56 <neologism> you all are europeans?
10:10:19 <shapr> I'm from Alabama, but I live in Sweden.
10:10:29 <shapr> cbus: yes, they are.
10:10:52 <Lunar^> Haskell mentioned on OSNews : http://www.osnews.com/story.php?news_id=7078
10:11:02 <vegai> I think I'll apply for the patent of recursive functions
10:11:10 <shapr> this patent thing sucks very much.
10:11:21 <vegai> then you can all bow down to me!
10:11:24 <neologism> what about patenting the idea of patents ;)
10:11:25 <shapr> it means Stallman may be right after all.
10:11:41 <vegai> that's the only reason it sucks? =)
10:11:46 <Lunar^> "Haskell, despite the affection of computer scientists, is miserable failure." mhhh
10:11:59 <neologism> Lunar^: this has been discussed here
10:11:59 <shapr> Lunar^: that guy is clueless
10:12:13 <neologism> haskell is yound
10:12:15 <neologism> young
10:12:17 <neologism> lisp is old
10:12:27 <Lunar^> neologism: Uh.. didn't follow it
10:12:38 <neologism> thats why lisp is more widespread (that and eleet feeling in using (())() ())( ))(-like code )
10:12:48 <shapr> vegai: Stallman has said for years that the big companies will screw us over if we don't zealously guard our code
10:13:18 <Lunar^> I think he's right on the background. If we were all using x86, computer science state could be really different
10:13:27 <Lunar^> read, were not
10:13:28 <vegai> personally, I wouldn't be surprised if Stallman is right in everything he says
10:13:34 <vegai> s/is/was/
10:14:39 <shapr> before the five companies sent the letter to the EU, software patents were not going to happen.
10:24:55 <ne1> The article implies that civilization must never make progress.
10:27:29 <ne1> For a response see http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1036.PDF
10:27:42 <Si\> "Haskell may improve productivity dramatically but if non-geniuses cannot use it, it will remain as a toy not a tool for real programmers."
10:27:58 <Si\> so apparently I'm not only a genius, I'm also not a real programmer
10:28:02 <Si\> hmmmm....
10:28:08 <Smerdyakov> Wow. That OSNews article is written by someone with a poor grasp of English composition.
10:28:24 <ne1> (Summary: You cannot always turn new problems into old problems.  Sometimes there is a paradigm shift and you must refrain from drawing false analogies.)
10:29:13 <cbus> nice
10:29:24 <cbus> imaginary programmers :)
10:30:48 <ne1> Geniuses are not real programmers. Geniuses have better things to do, such as being real leaders.
10:31:40 * vegai wishes for a genius leader.
10:31:57 <vegai> I might be mistaken, since I'm not a genius, but I don't think those are very common
10:32:35 <Smerdyakov> ne1, what if geniuses *like* programming?
10:33:13 <SamB> Smerdyakov: if they also have a poor grasp of reality, it doesn't really matter that much that they have a poor grasp of english composition, does it?
10:36:43 <Smerdyakov> SamB, it is too painful for me to read that article, so I can
10:36:53 <Smerdyakov> 't decide if the author has a poor grasp of reality.
10:37:43 <SamB> Smerdyakov: oh. well, it doesn't sound like it would be a good use of time
10:57:30 <kosmikus> is sven panne on irc sometimes?
10:59:02 <ne1> If a genius such as Dijkstra likes programming, he finds better ways to program.
10:59:28 <ne1> Thus he still ends up being a real leader rather than a real programmer. :D
11:00:04 <shapr> kosmikus: not that I know of
11:01:26 <kosmikus> shapr: thanks
11:35:17 * shapr boings
11:35:30 <shapr> hi gini, looking for haskell info?
11:36:30 <kosmikus> shapr: do you have a list of nicknames, so that you always know if someone has been here before?
11:37:13 <shapr> no
11:37:30 <shapr> I just remember people.
11:40:37 <shapr> I can't remember appointments at all though
11:43:31 <gini> hi, shapr ... t thought is time to move from schem :)
11:44:24 <Igloo> You're about *looks at watch* 20 years late  :-)
11:44:42 <monotonom> hehehe
11:44:47 <shapr> do you want a Haskell Tutorial?
11:45:17 <Riastradh> Why on earth would you want to move to Haskell from Scheme?
11:45:49 <monotonom> Because Haskell checks more types than Scheme does.
11:45:52 <shapr> some people prefer Haskell
11:46:46 <Riastradh> shapr, well, yeah, and those people are weirdos.  Why would you want to be one of _them_?
11:47:05 <shapr> I do prefer Haskell over Scheme.
11:47:14 <Riastradh> Weirdo!
11:47:22 <gini> one of the reason is, indeed typing
11:47:29 <shapr> well, I know what I like.
11:47:43 <monotonom> Next century I will write a program, annotate it as "it solves SAT", and expect the compiler to say "yes it does" or "no it doesn't, here is why."
11:48:03 <shapr> Scheme is nice, no arguments there, but I like Haskell more.
11:48:14 <Smerdyakov> Haskell can do that now, if your program has the wrong type. ;)
11:48:18 <monotonom> For now, I'm happy enough to have the compiler just deduce that my program returns a finite map from strings to booleans.
11:48:52 <monotonom> But if the compiler doesn't even do that, ... look, it's already the 21st century.
11:49:12 <Riastradh> Type information isn't the only useful static analysis, you know...
11:49:25 <shapr> I think intersection types will help with error finding
11:49:32 <monotonom> Bloody look at what I said at the very beginning.
11:50:00 <Riastradh> Yup!  I did.  That's why I said 'you know!'
11:50:18 * Riastradh is just being silly, in case some of you haven't noticed.
11:50:45 <shapr> I think people should try a lot of things and decide for themselves what they prefer.
11:50:47 <monotonom> More like repeating everything I say.
11:51:07 <shapr> gini: do you have any questions?
11:51:42 <Lor> Evening.
11:51:54 <shapr> hiya Lor
11:52:02 <shapr> wassup?
11:52:22 <Lor> Nothing much. Still haven't finished my thesis.
11:52:45 <monotonom> If ghc reliably analyses my program and performs all the admissible deforestation and strictening, I'm more than happy.
11:53:03 * shapr hooks a keyboard up to van de graaf generator and calls it "Static Typing"
11:53:11 <gini> well, for the moment I want to know about some IDE for haskel ..
11:53:30 <monotonom> hehehhe
11:53:51 <monotonom> Some Eclipse plugin for Haskell would be nice.
11:54:22 <monotonom> (I won't use it --- I don't use Eclipse --- but I can at least brag about it when talking to code monkeys.)
11:55:17 <shapr> gini: I use emacs and haskell-mode, some people use vim, what sort of IDE do you prefer?
11:55:34 <gini> well, something that can work with xemacs would be nice too !
11:56:01 <shapr> I use xemacs
11:57:38 <gini> me too,  even when I am under win ... I can't separate of him !
11:57:57 <shapr> there's some info about haskell-mode on the Haskell Wiki
11:58:56 <shapr> the last time I used windows, I also used xemacs
12:00:16 <monotonom> I do not install emacs to my windows partition. This is to resist the temptation to do real work on windows. :)
12:01:00 <shapr> I don't have a copy of windows installed anywhere
12:01:35 <shapr> I do have some windows 3.1 diskettes around here somewhere
12:03:29 <Maddas> monotonom: Don't worry, it's not that good :-)
12:05:29 <shapr> so, anyone written fun haskell code lately?
12:07:51 <monotonom> I need windows because I want to play games.
12:08:57 <shapr> I play games on linux
12:09:10 <Maddas> I play games on OS X
12:09:28 <monotonom> Ah well, back to the topic. No, but I am slowly reading coproducts (sums) of monads in ICFP 2002.  It is fun and mind-blowing --- "you will actually have the colimit of the whole bloody diagram?!"
12:10:50 <monotonom> (Now that I've done my ObTopic, I can digress again.)  The games I want to play are on windows.  Age of Mythology.  Command & Conquer.
12:12:13 <monotonom> I am slowly reading the technical section on how to construct the colimit, but a few days ago I read the usage part, and oh boy, is it slick to use.
12:13:32 <shapr> when I switched to linux, I got counterstrike running in wine, and I realized that I then had the fewest crashes of all the people I played with.
12:13:47 <monotonom> I don't play shooting games.
12:13:49 <Maddas> I wish they would port Zero Hour to OS X quickly
12:13:59 <Maddas> (C&C Generals is already there)
12:14:10 <monotonom> Alright I see your point, but when I play my windows games I don't get crashes.
12:14:27 <Maddas> Heh, I never got wine to run stable.
12:14:46 <monotonom> Oh C&C is available on OS X. Alright I can throw away my computer now. :D
12:14:55 <Maddas> (I never got Windows to run stable for longer periods of time either, but it was a lot more stable than wine)
12:15:01 <Maddas> monotonom: Age of Mythology too :-)
12:15:27 * monotonom borrows $5000 from the bank to buy a PowerBook.
12:15:29 <shapr> and the people I played against online said that wine allowing me to use 2 CPUs for Counterstrike was cheating
12:15:46 <monotonom> Haha
12:16:03 <Maddas> haha
12:16:22 <Maddas> shapr: You mean you could start two instances of Counter-Strike/
12:16:25 <monotonom> Fight back "I will use one CPU, but you must stepdown your single Pentium by a half!"
12:16:31 <Maddas> Oh, dual-processor
12:16:38 <shapr> right
12:16:48 <shapr> I have a dual athlon mp
12:16:57 <Maddas> Cool
12:17:06 <shapr> hot actually
12:17:16 <Maddas> Those are orthogonal :-)
12:17:24 * shapr points out the many extra case fans
12:17:35 <monotonom> I don't see why, say, two 2GHz processors is cheating while one 4GHz one isn't.  For goodness sake, the former is actually at a disadvantage.
12:17:48 <Maddas> monotonom: Latter probably has HyperThreading anyway
12:17:52 <Maddas> or something fancy like that 
12:18:43 <monotonom> May as well say "you are cheating because you are not using a crashing OS".
12:19:33 <shapr> does windows handle SMP nicely nowadays? can you now play counterstrike in win32 and use 2 cpus for it?
12:20:06 <Maddas> How are two 2ghz processors of any use for Counter-Strike, though?
12:20:07 <monotonom> you may have to pay extra money for the SMP support.
12:20:18 <Maddas> It used to run perfectly fine on my AMD XP 1800+
12:20:47 <monotonom> (Because Microsoft pays money to another company for SMPizing windows.)
12:21:08 <eivuokko> shapr, If CS is programmed to use threads, yes.
12:22:14 <shapr> I don't know if CS uses threads, wine was able to use both CPUs so that implies a yes
12:22:38 <eivuokko> I doubt it matters much for such an old game, tho.
12:25:13 <shapr> I do wish it were easier to use SMP in Haskell
13:24:31 <shapr> hi d3z 
13:25:05 <d3z> Hello.
13:25:21 <shapr> learning Haskell? longtime user?
13:26:00 <d3z> Um, a little of both.  I learned it a bit a while back, and am now back.  Much better grasp this time.
13:26:23 <shapr> got any questions about Haskell?
13:26:50 <d3z> Nothing specific.  Just thought I'd drop in and see what was being discussed.
13:27:17 <shapr> all is quiet on the eastern front... for the moment
13:27:34 <d3z> I'm focusing on stuff to get ready for ICFP '04.
13:27:47 <shapr> oh cool, have you submitted a paper there?
13:28:06 <d3z> No, but I intend to enter the programming contest.
13:28:15 <shapr> ah, I see
13:28:24 <shapr> have you tried darcs?
13:28:31 <d3z> :-)
13:28:50 <d3z> David Roundy, myself, and another individual are forming an ICFP contest team.
13:29:11 <shapr> ah, you're that David Brown
13:29:22 <shapr> I'm Shae Erisson
13:29:37 <d3z> Yes, the joys of IRC handles, and common names.
13:30:19 <Lor> Thankfully, there is also the joy of /whois
13:30:24 <shapr> I would like to enter the ICFP contest, but I think work and EuroHaskell will distract me.
13:30:53 <d3z> I'm actually going to take the Friday off, and have set aside the whole weekend.
13:31:06 <d3z> The contest will also make a good stress test for darcs.
13:31:14 <shapr> I agree
13:31:45 <shapr> though listening to #darcs I hear quite a few compliments and complaints
13:31:46 <kosmikus> sure .. who's that third individual? someone we know?
13:31:51 <d3z> I've been learning combinatorial parsers.
13:31:58 <d3z> Let me check the name...
13:32:17 <d3z> Tim Docker.
13:32:32 <kosmikus> doesn't ring a bell
13:33:09 <shapr> he's an aussie
13:33:28 <d3z> Tim?  I think he is in London.
13:33:46 <shapr> hm, maybe I have the wrong guy
13:34:51 <d3z> I also have a friend who offered to be available for any math/algorithm help needed.
13:35:06 <skew> when is the contest?
13:35:36 <shapr> weekend before europython
13:35:40 <d3z> 04 June, 1600 UTC
13:35:49 <d3z> it lasts 72 hours.
13:35:58 <andersca> @eurohaskell
13:35:59 <lambdabot> less talks, more code!
13:35:59 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
13:35:59 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
13:36:06 <skew> oh, okay. I was thinking it was much closer
13:36:14 <skew> and worrying about conflicts with current work
13:36:55 <shapr> it feels pretty close to me, I have work to get done before I go gallivanting southwards
13:37:37 <d3z> All of these are very far from me.  Although I may drive to ICFP.
13:37:59 <shapr> that's quite a drive
13:40:03 <d3z> I think it is about 12 hours from here.  I suppose I could also fly, but that is a hastle.
13:41:30 <shapr> on the subject of darcs, I think the cgi browser could do a lot more tricks
13:42:05 <d3z> Probably.  I only use it for annotate, since the cmdline annotate is unreadable.
13:42:10 <eivuokko> arete on #darcs said he was doing new one
13:42:22 <eivuokko> (iirc in perl, tho)
13:42:28 <shapr> eek
13:43:10 <shapr> like I said before, programatica and FIT could be useful
13:44:36 <shapr> hi tom, what's up?
13:45:34 <tmoertel> not much. what's up with you?
13:45:56 <shapr> mostly work
13:46:06 <tmoertel> same here
13:46:25 <shapr> I've been checking out programatica, it's nifty
13:47:16 <shapr> I want some juicy new bits of Haskell to play with
13:48:24 <ibid> if s+t denoted union of the sets s and t, what would you use for intersection?
13:48:43 <shapr> s^t ?
13:48:59 <shapr> or would that be disjoint?
13:49:12 <ibid> it would make me think of exponentation :)
13:49:21 <monotonom> s+t is bad notation, but if you want to perpetuate it consistently, try s*t for intersection.
13:49:22 <ibid> and i would start searching for what it means
13:49:32 <ibid> monotonom: s*t is cartesian product
13:49:43 <monotonom> I said it is bad notation.
13:49:55 <ibid> monotonom: of course, if i were writing a math paper, i'd use proper notation
13:50:10 <ibid> monotonom: this is for a programming language that supports set abstraction
13:50:28 <monotonom> You can always say s*t is intersection, sxt is product.
13:50:53 <ibid> sxt, with x or with the latin-1 times symbol?
13:51:05 <monotonom> Either is fine with me.
13:51:16 <ibid> x as a reserved identifier strikes me as drastic
13:51:29 <shapr> can you use unicode?
13:51:35 <ibid> i'd rather not
13:51:42 <ibid> if i did, i'd use standard notation
13:52:04 <shapr> ok, what about s&t ?
13:52:23 <monotonom> Then you will use s|t for union.
13:53:14 <monotonom> |/& is C bad notation.  +/* is mathematician algebraist bad notation.  Choose your poison.
13:53:16 <cbus> yay time to use foldl! :)
13:53:21 <cbus> i think ;)
13:53:58 <ibid> |_| would work for union...
13:55:15 <monotonom> It depresses me that it is the great 21st century and we still have to say "I am designing a [sub]language and I don't have that symbol on the keyboard."
13:55:32 <shapr> keyboards just suck
13:56:12 <monotonom> Choose a pair of Chinese characters.  Tell users to turn on Chinese IME support on Windows.  Solved.
13:56:28 <shapr> not that I can think of a way to do unicode keyboards
13:56:32 <monotonom> Err IM support.
13:56:55 <shapr> I use x-symbol in emacs, it works just fine for most things
13:57:17 <ibid> monotonom: if i go for the unicode way, i'll just use standard symbols
13:57:36 <monotonom> I think Chinese characters are more cool. :)
13:57:54 <monotonom> Err cooler.
13:58:07 <monotonom> Damn this inconsistent English language.
13:58:25 <shapr> wanna try lojban?
13:59:24 <shapr> @cmafihe xu do djica lenu tavla bau la lojban
13:59:24 <lambdabot> xu <UI6> [yes/no?] do <KOhA3> [you] djica <BRIVLA> [desire] lenu <LE NU
13:59:24 <lambdabot>  [the event of] tavla <BRIVLA> [talk] bau <BAI> [in language] la <LA> [
13:59:24 <lambdabot> ] lojban <CMENE> [] 
14:00:11 <monotonom> Seriously, you probably really want to use | & for ordinary union and intersection, so that later you can use + x for coproduct (disjoint union) and product.  Replace x by * if necessary.
14:00:40 <monotonom> | & boolean algebra.   + x category theory.
14:05:12 <earthy> btw, monotonom, an eclipse plugin for haskell is being worked on
14:05:39 <monotonom> Gooooooooooooooooooooooooood
14:06:00 * monotonom goes to slashdot and brag
14:06:25 <shapr> neat, http://www.johanmalmstrom.se/haxcel/
14:06:42 <shapr> "Haxcel - a spreadsheet interface to Haskell"
14:07:50 <Matt-W> argh!
14:08:22 <shapr> sadly, it uses Java
14:08:24 <opet> shapr: I studied that for the final year project at uni - I wrote a little spreadsheet app in haskell :)
14:08:41 <shapr> opet: you have the code around?
14:08:56 <shapr> sounds nifty
14:09:18 <opet> shapr: yes, but not internet accessible
14:09:58 <shapr> does it have a BSD/GPL/lGPL/etc sort of license?
14:10:14 <shapr> if so, I'd like to get a copy
14:10:24 <opet> I'm not sure if it has *any* sort of license
14:11:53 <shapr> opet: if you wrote it, can't you give it a license?
14:12:10 <opet> I can indeed
14:12:36 <shapr> ok, I didn't if that meant the school owned it or something
14:15:05 <Matt-W> uck, Java
14:15:08 <Matt-W> dirty word
14:15:16 <Matt-W> except when you're talking about coffee :-)
14:15:24 <shapr> opet: I would like to get a copy of your spreadsheet code
14:16:18 <Matt-W> opet: what was the agreement on our project code? Did we ever get told?
14:16:56 <opet> shapr: okay. I'm trying to work out who actually owns the code :)
14:17:32 <shapr> ok
14:17:35 <opet> Matt-W: dunno. according to Biggles, it's "joint ownership between you and the university". whatever that means
14:17:57 <Matt-W> Hmm
14:18:10 <Matt-W> sounds like they get to do what they want with it
14:18:20 <Matt-W> although I'm fairly safe
14:18:27 <Matt-W> as nobody could possibly want to do anything with my code
14:18:41 <shapr> does that mean that both parties have to approve license changes, etc?
14:22:05 <monotonom> Excel is not implemented in Excel.  Haxcel does not have to be implemented in Haskell.
14:23:14 <shapr> is C implemented in C?
14:23:27 <Smerdyakov> Is democracy implemented in democracy?
14:23:37 <shapr> no way
14:24:07 <Olathe> It usually is
14:24:18 <Jerub> shapr: normally.
14:24:21 <Olathe> If you have a working C compiler, you can easily do so
14:24:24 <Jerub> shapr: and pascal is implemented in pascal.
14:24:35 <d3z> Usually tools are implemented in their own language because the authors prefer that language.
14:24:49 <d3z> Plus, it makes bootstrapping things more challenging.
14:24:59 <Smerdyakov> Which means most authors are wrong. ;)
14:25:28 <shapr> for you maybe
14:25:43 <shapr> I think what's right for me is not always right for others
14:25:43 <Olathe> You write a compiler in another language first, then compile one in the language, then you can always compile the compiler in the language.
14:25:52 <shapr> shoe size for example
14:26:11 <Smerdyakov> Most languages are so similar that small differences have to make one better than its cousins.
14:26:37 <Jerub> ... its standard practice for compiler writers.
14:26:54 <Jerub> if a language cannot be implemented in itself, then it is obviously not practical enough to be a language.
14:27:00 <Jerub> is the usual way it goes.
14:27:21 <Marvin--> that's the usual way it goes for *general purpose* languages
14:27:50 <shapr> hej Marvin--, are you celebrating?
14:27:53 <opet> Matt-W: I've just sent dge a mail asking him about it. hopefully he'll get back to me. otherwise I'll just ask gmh
14:28:05 <Marvin--> shapr: just opened the whisky bottle a friend gave me :)
14:28:12 <shapr> cool
14:28:31 <Matt-W> opet: dge should know... gmh might though, didn't he used to run the third year projects? Or was that the group orjects?
14:30:05 <opet> Matt-W: I don't really know. I just felt like chatting to dave :)
14:32:17 <Matt-W> opet: fair enough, he's a cool kind of guy
14:32:51 <shapr> anyone here used Storable?
14:33:34 <shapr> would it be good to read in a PNG,GIF,JPG,etc?
14:35:24 <shapr> is there a better way?
14:37:46 <cgibbard> You could use my imlib2 binding to read in an image
14:38:07 <cgibbard> http://vx.hn.org/haskefl/Imlib2.hs
14:38:50 <Lor> How would Storable relate to file formats?
14:39:08 <shapr> because it looks like python's struct module to me
14:39:16 <Lor> Isn't it only about accessing some primitive binary data?
14:42:12 <cgibbard> Storable is part of the FFI, used for writing/reading values from raw memory.
14:42:57 <shapr> is there a general way to cut a binary chunk into pieces with Haskell?
14:43:47 <Lor> Use a parser?
14:44:19 <Lor> Not the most efficient solution, granted.
14:44:24 <opet> shapr: I'll find out from my ex tutor and/or supervisor and get back to you. once I know it's mine I expect I'll just slap the GPL on it and email over a tarball
14:45:32 <Lor> For a long time I've had the dream of designing a neat data format description language... something like asn.1 but simpler and prettier.
14:45:49 <Smerdyakov> 01000100101 <-- like that?
14:45:55 <Igloo> Presumably you could use stroable if you mmaped the file, but it's probably not what you want
14:45:55 <Smerdyakov> Much simpler.
14:45:58 <Lor> Because it _should_ be trivial to convert a binary file into a data structure and back.
14:46:19 <Lor> Essentially, it's just custom marshalling.
14:47:05 <shapr> phubuh mentioned that erlang does have something like that
14:47:36 <Lor> Yeah, it does.
14:47:45 <Lor> But it's a built-in special feature.
14:48:14 <Lor> Hm, template haskell should allow pretty easy marshalling.
14:48:46 <shapr> so, where's the spec for this pretty erlang thing?
14:49:03 <shapr> do you know what it's called?
14:49:58 <Lor> http://www.erlang.se/euc/00/bit_syntax.html
14:52:21 <shapr> neat stuff
14:53:43 <Lor> It could be neater.
14:54:05 <shapr> how so?
14:54:41 <Lor> It could support more complex structures.
14:55:08 <Lor> In particular, sequences whose length depends on a previously read value.
14:55:48 <Lor> I really think reading and writing a simple file format should only require a simple spec of the format, everything else should be automagic.
14:56:59 <shapr> I agree
14:57:18 <shapr> I was wondering how to use this to read an image
14:57:35 <shapr> images are not all the same size
14:57:49 <monotonom> "simple spec of the format" = grammar.  "automagic" = parser generator.
14:58:08 <monotonom> Alright I have only covered the reading side. :)
14:58:18 <Lor> Two-directional parsing is neat.
14:58:30 <Lor> I once used embedded prolog to try it out.
14:59:09 <monotonom> There is no problem for a parser generator to construct both parser and unparser at the same time.  Certainly easier than inverting a given parser.
15:01:06 <shapr> ok, I want one :-)
15:01:07 <monotonom> Same principle as: if you use the euclidean algorithm to compute gcd a b, you may as well keep track of more state and solve ax+by=gcd a b alongside.
15:02:37 <monotonom> Oh also same principle as: if you use OOP design patterns to write an editor, where each editing operation is a Command, you may as well store all Commands as they occur and support undoing.
15:03:29 * monotonom is such a great theorist. :D
15:04:16 <monotonom> Too many fun things to implement.
15:05:30 <monotonom> Oh we don't need to implement that thing!  Haskell already does it for you!  Write your grammar as a Haskell user-defined data type, then just add water, I mean deriving (Read,Show).  Tada!
15:06:11 <Lor> Or use generics to write your own.
15:06:18 * monotonom goes patent the idea.
15:06:38 <Lukhas> monotonom: too late, i have an automatic patenter based on IRC logs
15:06:40 <Lor> Except that lazy lists are probably not the most efficient marshalling format. :)
15:06:52 <monotonom> Oh wow Lukhas is clever.
15:07:53 <Lukhas> hehe
15:07:54 <monotonom> Have you patented the idea/mechanism of automatic patenting over IRC logs?
15:08:01 <Lukhas> of course
15:08:02 * monotonom goes meta
15:08:40 <monotonom> Have you patented the idea/mechansim of patenting the idea/mechanism of automatic patenting over IRC logs?
15:08:57 <Lukhas> no, i have limited the loops that my bot can handle
15:08:59 * monotonom <--- modal logic enthusiasit
15:14:36 <Smerdyakov> monotonom, do you know the BAN logic for cryptographic authentication?
15:17:07 <shapr> http://www.haskell.org//pipermail/haskell-cafe/2004-January/005782.html
15:17:20 <shapr> Lor: does that look interesting?
15:24:12 <Lor> Yeah. Pretty much what I had in mind.
15:33:37 <mattam> Smerdyakov: P believes Q believes ... :) Is it really the most well-known logic in the field ?
15:34:05 <Smerdyakov> mattam, I don't know. My crypto professor calls it "the famous BAN logic." :)
16:01:04 <shapr> now if only I could get that to compile
16:03:28 <Igloo> What's the problem?
16:04:05 <Igloo> There'll be quite a lot of translation needed I imagine, but with TH.Syntax in another window that should be straightforward
16:13:52 <shapr> I have a patch that should fix DecodeTH.hs, but doesn't. I suspect user error.
16:14:33 <Igloo> What's the compiler error?
16:18:20 <monotonom> I think I have seen some BAN.
16:20:11 <shapr> Igloo: I put it on the top of http://www.haskell.org/hawiki/HaskellIrcPastePage
16:20:27 <shapr> the error is last statement in do must be expression
16:20:46 <Igloo> The unitType line is indented too far
16:21:48 <shapr> I just added the original code below the modded code I've been trying to compile
16:23:40 <Igloo> Looks like your patch broke the indentation then. Tabs might be to blame if it looks right to you
16:23:54 <shapr> ohhh I think there's a tab in there somewhere
16:24:23 * shapr swears at tabs
16:24:50 <shapr>   now it compiles just fine
16:24:55 <shapr> thanks Igloo 
16:25:17 * Igloo realises CAT wants the same logo Isaac did for LIP
16:25:50 <shapr> CAT?
16:26:26 <shapr> oh, you've told me about this before
16:26:32 * shapr tries to remember
16:26:43 <shapr> hiya Shammah, how's code?
16:27:46 <Igloo> Campaign Against Tabs
16:27:53 <shapr> oh right
16:27:59 <shapr> yes, tabs suck
16:28:24 <shapr> I think I had a hook that cleaned out tabs before
16:30:12 <Lor> Bah. Tabs are great.
16:30:55 <Lor> Especially in C code: one indent level = 1 tab = 8 columns
16:31:08 <monotonom> No, 2 columns.
16:31:20 <shapr> no, four columns
16:31:36 <Jerub> Tabs or Spaces. Pick one.
16:31:38 <monotonom> No, I change my mind. pi^2/e^3 columns.
16:31:40 <shapr> tabs are good for flamewars
16:31:41 <Jerub> NEVER MIX THEM. That is all.
16:36:33 <monotonom> Like this? foo\tx\t=\tx\t+\t1 ?
16:36:46 <Jerub> monotonom: tee of hee.
16:37:03 <Jerub> I meant specifically for indentation and you know it :p
16:38:50 <monotonom> Yeah I confess I know it.
16:41:17 <shapr> g'day Pseudonym 
16:41:33 <Pseudonym> G'day.
16:42:41 <shapr> I don't see how to use Tomasz' code for something where the size of the later parts is specified by something that's parsed earlier.
16:42:45 * shapr reads more
16:43:12 <Shammah> shapr: code going well.  work-code managed to prove it's promise of order-magnitude improvements.
16:43:41 <Shammah> anyway.  Off to work.  bbs.
16:44:42 <Pseudonym> The paper on coproducts is really fascinating.
16:45:03 <Pseudonym> The category diagrams overflow my short-term memory, though.
16:45:10 <Pseudonym> What is it, 7 +/- 2 items?
16:45:38 <shapr> yup, that's it
16:46:02 <Pseudonym> Right, well a diagram with 15 odd items in it overflows my cognition.
16:46:56 <Spark> cognitive science is cool
17:25:47 <d3z> Speaking of Storable, it would be nice to use Data.Array.IO, and then Storable to manipulate it.
17:26:11 <d3z> I ended up using a raw Posix I/O interface in GHC to get my data.
17:28:32 <shapr> not quite as portable
17:29:11 <shapr> how did you parse it once you had it loaded?
17:29:39 <d3z> My app I didn't really want to parse it, just pass the chunks off to a sha1 hash.
17:30:12 <d3z> The stuff in Storable looks good, but clumsy to use.  I like the idea of a small language to describe the data.
17:30:25 <d3z> ASN.1 is a good concept, but _very_ poorly done.
17:30:33 * shapr agrees
17:30:57 <shapr> I had a job doing x.509 stuff for a bit
17:31:18 * d3z sympathasizes
17:31:49 <d3z> Bruce Schneier even gives condolonces to anyone who has to use x.509.
17:33:08 <Pseudonym> X.509's problem is that it's a syntax, not a standard.
17:36:00 <shapr> Pseudonym: have you seen Tomasz Zielonkas' ip header parsing code?
17:36:11 <Pseudonym> No.
17:36:34 <Pseudonym> But I'm sure you're going to tell me where I can.
17:37:58 <shapr> If you're not interested, I can drop it :-)
17:38:04 <Pseudonym> :-)
17:38:09 <Pseudonym> No, I'm very interested, actually.
17:38:12 <shapr> whew
17:38:37 <shapr> this is the original post: http://www.haskell.org//pipermail/haskell-cafe/2004-January/005782.html
17:39:12 <shapr> and here's source that works with 6.2+ http://shapr.homelinux.net/~shae/deser/src/
17:39:26 <Pseudonym> Cool.
17:39:40 <Pseudonym> I'm curious what a decent partial evaluator could do to this code.
17:39:43 <shapr> thing is, I can't tell if this only works for static stuff
17:40:13 <shapr> this only shows a static spec: http://shapr.homelinux.net/~shae/deser/src/Example.hs
17:40:14 <skew> probably, at least if it needs to generate code
17:40:45 <Pseudonym> Hmmm... OK, BRB.  Free cakes.
17:41:03 <Pseudonym> Let's see... Haskell... cakes... haskell... cakes...
17:41:06 <Pseudonym> Sorry, cakes win.
17:41:33 * Smerdyakov is not a fan of cakes.
17:41:35 <shapr> which implies I can't use this to make zip/png/etc codecs
17:41:37 <shapr> foo
17:43:49 <Igloo> Why not?
17:43:54 <Igloo> Oh, because the Huffman table varies?
17:44:09 <shapr> lots of stuff varies in those sorts of formats
17:45:05 <skew> dynamic like that is possible
17:47:41 <shapr> how so?
17:49:05 <Igloo> I haven't really understood the problem
17:49:45 <Igloo> You can write a Huffman decoder and a parser in plain old Haskell - all that TH would be buying you is efficiency or automatically generating one or the other from some sort of specification
17:49:46 <shapr> probably true of me too
17:52:22 <skew> well, you can generate marshalling code for the possible cases, or some kind of binary parser
17:52:39 <skew> I thought you were talking about deriving marshalling for new data types dynamically
17:54:34 * shapr is no longer sure what he's talkig about
18:14:02 <Pseudonym> MMm... cakes.
18:14:37 <Pseudonym> shapr: Have you read the paper "arithmetic coding revisited" by Alistair Moffat et al?
18:14:53 <Pseudonym> Very useful paper, describing how to separate models from coding algorithms.
18:28:45 * SamB wants nicer arrays
18:46:57 <Riastradh> Use APL.
18:48:01 <SamB> hmm. is it common to implement erasure codes in apl?
18:48:12 <SamB> and where do I get APL for debian?
18:48:32 <Pseudonym> Sisal also good.
20:27:13 <skew> Wow, I'm using a lot of preprocessors here
20:27:26 <skew> I've got a homegrown tool generating Alex and UUAG input
20:27:55 <skew> I'm open to suggestions of addition things to toss in :)
20:33:19 <shammah> skew: INTERCAL ;)
20:33:32 <skew> not much use for that in a compiler
20:34:23 <skew> I suppose I could turn it into an INTERCAL compiler
20:35:16 <Pseudonym> How about m4?
20:36:21 <skew> that might be an option. I've already got a little haskell program for generating my lexer and primitive parsers from a token specification
20:36:27 <skew> which is where I think m4 might come it
20:36:43 <Pseudonym> Another option would be a QLR(k) parser generator.
20:36:54 <skew> QLR?
20:37:04 <Pseudonym> Quantum LR
20:37:15 <Pseudonym> The name comes from the construction algorithm.
20:37:23 <Pseudonym> Which is based on spinor algebra.
20:37:42 <Pseudonym> I can flesh that explanation out if you want.
20:37:51 <skew> sure
20:38:11 <Pseudonym> OK.  You know that regular expressions are isomorphic with DFAs.
20:38:20 <Pseudonym> And that context-free grammars are isomorphic with PDAs.
20:38:41 <Pseudonym> Right?
20:38:44 <skew> yes
20:38:54 <Pseudonym> Cool.  Just making sure we're on the same wavelength.
20:39:35 <Pseudonym> A PDA is like a DFA only it also has two operations: push s and pop s for some stack symbol s.
20:39:46 <skew> I've got a fair bit of abstract algebra too
20:39:48 <Pseudonym> Sorry, two MORE operations.
20:40:08 <skew> so don't be afraid to be all formal
20:40:09 <Pseudonym> We will represent push s as <s| and pops as |s>
20:40:25 <Pseudonym> Dirac bracket notation.
20:40:30 <skew> right
20:40:42 <Pseudonym> They satisfy the following axioms:
20:40:54 <skew> <s|s> = 1?
20:40:56 <Pseudonym> a <s| = <s| a for all stack symbols s and terminals a
20:41:01 <Pseudonym> <s| |s> = 1
20:41:12 <Pseudonym> Where 1 is the empty string, lambda.
20:41:17 <Pseudonym> 1 E = E 1 = E
20:41:22 <Pseudonym> for all languages E
20:41:34 <Pseudonym> Similarly, <s| |t> = 0
20:41:39 <Pseudonym> Where 0 is the empty set.
20:41:43 <Pseudonym> 0 E = E 0 = 0
20:41:49 <Pseudonym> And 0 + E = E + 0 = E
20:41:57 <Pseudonym> where + is set union
20:42:05 <skew> how are terminals multiplying here?
20:42:13 <Pseudonym> Concatenation.
20:42:25 <skew> Ah, okay
20:42:30 <Pseudonym> OK.
20:42:34 <Pseudonym> So we have:
20:42:38 <Pseudonym> a <s| = <s| a
20:42:43 <Pseudonym> a |s> = |s> a
20:42:57 <Pseudonym> <s| |t> = d_{s,t}  where d is Kroenecker delta
20:43:05 <Pseudonym> And one more axiom:
20:43:22 <Pseudonym> |1> <1| + |2> <2| + ... + |n> <n| = 1
20:43:31 <Pseudonym> Think about that one for a moment.
20:43:42 <skew> sure
20:43:45 <Pseudonym> If the stack is non-empty, then that must be true, if all stack symbols are included in the union.
20:43:50 <Pseudonym> That's a spinor algebra.
20:44:05 <skew> the spinor bit being mostly the last axiom?
20:44:10 <Pseudonym> Roght.
20:44:27 <Pseudonym> The <s|t> = d_{s,t} means that the stack symbols are an orthonormal basis.
20:44:28 <skew> the bit that makes it a spinor algebra over just some orthogonal functions
20:44:32 <Pseudonym> Right.
20:44:35 * SamB accidentally started another xchat instead of xsidlplay :-(
20:44:48 <Pseudonym> So you can now put these in regular expressions.
20:45:05 <Pseudonym> For example: <0| (a <1|)* (b |1>)* |0>  is a^n b^n
20:46:07 <Pseudonym> Do you know how LR parser construction works?
20:46:31 <skew> I don't think so
20:46:34 <Pseudonym> Ah, okay.
20:46:44 <Pseudonym> Well the parser itself is a shift-reduce parser.
20:47:05 <Pseudonym> So it shifts terminals onto the stack, and a reduction of A -> w happens by popping |w| symbols and pushing A.
20:47:30 <Pseudonym> But you maintain a separate stack with the state numbers, as well.
20:47:34 <skew> interesting
20:47:38 <Pseudonym> So when you do a transition, you push the state number.
20:47:46 <Pseudonym> Then when you reduce, you "expose" a state number.
20:47:48 <skew> I think I see where the dirac brackets come in
20:47:52 <Pseudonym> And that tells you where to go next.
20:47:53 <Pseudonym> Right!
20:47:55 <skew> I know how all the shifting and stuff goes
20:48:13 <Pseudonym> QLR parsing works by first building an LR(0) machine.
20:48:14 <skew> I just never (tried to) firgured out how the parser tables are built
20:48:43 <Pseudonym> Then it finds out which state numbers are actually important, and rebuilds the machine with explicit push and pop operations as part of the transitions.
20:48:55 <Pseudonym> So you effectively turn an LR(0) machine into an explicit PDA.
20:49:03 <Pseudonym> You can then optimise the machine algebraically.
20:49:36 <Pseudonym> And you can also add lookahead by tracing arcs forward.
20:49:57 <skew> and represent the PDA as a regex over the spinor algebra?
20:50:13 <Pseudonym> No, it's best to keep the machine,.
20:50:22 <Pseudonym> Because you want to make a parser, after all.
20:50:59 <Pseudonym> The point of the regex was to show that a context free grammar is really a regular grammar with extra algebra.
20:51:29 <Pseudonym> Of course, if you introduce _two_ stacks (e.g. two types of brackets), you get Turing machines. :-)
20:51:56 <Pseudonym> Now here is where the fun REALLY starts.
20:52:02 <Pseudonym> <s|t> = d_{s,t}
20:52:02 <skew> such as, being able to push characters on the input stream
20:52:11 <Pseudonym> Suppose the amplitudes are not just 0 or 1.
20:52:20 <Pseudonym> Then what you have is a formal language description of quantum computation.
20:52:43 <Pseudonym> In a similar way that phrase structure grammars are models of Turing machine computation.
20:53:10 <Pseudonym> Pretty cool, no?
20:54:18 <Pseudonym> Anyway.
20:54:30 <Pseudonym> I actually have some simple Haskell code to build QLR parsers.
20:54:44 <Pseudonym> It's horribly inefficient, of course.
20:56:13 <shammah> Pseudonym: sounds cool, too-bad I don't know what a spinor algebra is :)
20:56:24 <Pseudonym> Well I just described it! :-)
20:56:42 <Pseudonym> It's an inner product space with an extra axiom, basically.
20:56:57 <Pseudonym> The thing about spinor algebras is that they let you separate the halves of the inner products.
20:59:04 <Pseudonym> http://mathforum.org/epigone/sci.math.research/skinglinperm
20:59:10 <skew> I don't think Java requires quantum parsing, but it's neat
20:59:13 <Pseudonym> That's a pretty good article.
20:59:36 <Pseudonym> The benefit of quantum parsing, I think, is that they allow you to build LR(k) parsers, but only as much of the LR(k) machine as you need.
20:59:42 <ozone> Pseudonym: you don't work for a government institution by any chance, do you?
20:59:51 <ozone> Pseudonym: the amount of cakes you get offered seem to indicate that
20:59:56 <Pseudonym> Moreover, you can make them nondeterministic, but keep the nondeterminism only to where it's needed.
21:00:05 <Pseudonym> ozone: No, oddly enough.
21:00:10 <Pseudonym> I technically work for a university.
21:00:15 <ozone> just checking
21:00:26 <Pseudonym> But actually we're an about-to-be-spun-off commercial venture.
21:00:40 <Pseudonym> We make a profit, which is why I think we get cakes.
21:01:27 <ozone> sweet.  (get it?  sweet?  har!)
21:01:36 <skew> how about the lookahead and parser generation stuff?
21:01:43 <skew> do you have any links on that?
21:02:50 <Pseudonym> http://compilers.iecc.com/comparch/article/94-02-127
21:02:55 <Pseudonym> That's a worked example.
21:03:13 <Pseudonym> http://compilers.iecc.com/compsearch.phtml
21:03:23 <Pseudonym> Actually, just go there and search for "quantum".
21:03:56 <skew> It wasn't obvious what you meant by "states that actually matter", and "tracing the arcs" on lookahead
21:04:01 <Pseudonym> Right.
21:04:17 <Pseudonym> The states which matter are the ones that can be "uncovered" after a reduction.
21:04:36 <skew> where do the states come from in the first place? the set of nonterminals?
21:04:48 <Pseudonym> No, they're sets of LR contexts.
21:04:53 <Pseudonym> Hmmm.
21:04:55 <Pseudonym> Hard to explain.
21:05:15 <Pseudonym> But they're sets of what are called "LR items".
21:05:26 <skew> okay, distinct states?
21:05:27 <Pseudonym> Where an item is of the form A -> w1 _._ w2
21:05:39 <Pseudonym> where A -> w1 w2 are rules in the grammar.
21:05:47 <Pseudonym> So it's a rule plus a "position".
21:06:00 <Pseudonym> Which means that you could be at this point in this rule.
21:06:20 <skew> then the contexts are sets of those?
21:06:27 <Pseudonym> Right.
21:06:28 <skew> right - positions.
21:07:12 <Pseudonym> There's a wonderful book called "LR Parsing: Theory and Practice" by Nigel Chapman which all good university libraries should have.
21:07:16 <Pseudonym> If you're curious about the topic.
21:07:23 <Pseudonym> Quantum parsing isn't covered.
21:08:57 <skew> on parsing, is there any nice way to use the utrecht combinators with tokens carrying position information?
21:10:39 <Pseudonym> Anyway, if you want code let me know, but unless you understand LR parser construction, you almost certainly won't udnerstand it.
21:10:59 <Pseudonym> It's completely undocumented, ugly and slow.
21:11:17 <skew> I
21:11:54 <skew> I understand it, I just haven't seen all of it :)
21:12:39 <Pseudonym> Just for jollies, I've also also hand-transcribed about half of the grammar for PHP into the format that my hacky application uses.
21:13:25 <Smerdyakov> Well, if it's hacky, PHP is a good match.
21:14:14 <Pseudonym> My thoughts precisley.
21:15:31 <Jerub> Pseudonym: I manged to extract the php grammar, if you want to see the full thing
21:15:52 <Pseudonym> Oh, I'm hand-translating yacc.
21:16:36 <Jerub> Pseudonym: yes, I hand translated yacc into a grammar.
21:16:43 <Jerub> Pseudonym: have you noticed that rather large warts.
21:16:51 <Jerub> none existed previously.
21:17:09 <Pseudonym> I thought you were talking about my appearance for a moment.
21:17:25 <Pseudonym> I was working from an older PHP.
21:17:49 <Jerub> http://thorne.id.au/php.tex
21:17:58 <Jerub> er s/that/the/
21:18:24 <Jerub> $foo->bar(); is a special case of $foo, instead of -> being an operator.
21:18:52 <Jerub> but they realised that that meant that $foo->bar()->baz(); didn't work, so they changed it.
21:19:08 <Jerub> now the grammar explictly handles $foo->bar()->baz(); and -> still isn't an operator.
21:19:14 <SamB> hmm, for some reason I couldn't compile sisal...
21:21:21 <Jerub> oh nevermind.
21:21:24 <Jerub> </hate>
21:22:31 <Pseudonym> Oh, PHP is a very ugly language in many ways.
21:23:34 <Jerub> Pseudonym: I'm reasonably confident I know 90% of its flaws.
21:23:40 <Jerub> Pseudonym: which is kinda comforting.
21:23:43 <Pseudonym> I believe you.
21:23:46 <Jerub> I could never do that with perl.
21:23:55 <Pseudonym> Oh, I know 90% of the flaws of Perl.
21:24:17 <Jerub> Pseudonym: I mean specific case. :)
21:24:24 <Pseudonym> Me too.
21:24:28 <Pseudonym> I know quite a bit about Perl.
21:24:43 <Jerub> okay
21:26:40 <polarType> hoi
21:42:48 <skew> Pseudonym: what do the equations in that list post mean?
21:43:07 <skew> the ones that are said to be a description of the finite state machine
21:47:24 <Pseudonym> Hang on, let me check the post.
21:47:40 <Pseudonym> Ah, I see.
21:47:49 <Pseudonym> q0 = S q1 + b q2 + a q3
21:48:01 <Pseudonym> That means that from state q0, if you see an S, goto q1.
21:48:02 <Pseudonym> etc
21:48:19 <skew> that's what I though, but how do you get that S?
21:48:33 <Pseudonym> Ah, that's part of the LR machine formulation.
21:48:54 <Pseudonym> You get it by reducing some rule S -> w, then popping |w| states and uncovering q0.
21:49:11 <skew> oh, the equations are not independant of the grammar
21:49:39 <Pseudonym> Correct.
21:49:53 <skew> you reduce when you read a dead end in the FSM?
21:49:55 <Pseudonym> The {n}'s are the reduction actions.
21:50:04 <Pseudonym> No, you reduce when you see a {n}.
21:51:48 <Pseudonym> See, parsing in this situation isn't just recognising.
21:51:54 <Pseudonym> You also want to build a parse tree.
21:56:10 <skew> does all the text on the parsing review page light up?
21:56:28 <Pseudonym> ?
21:56:34 <skew> on mouseover
21:56:40 <skew> http://www.seanerikoconnor.freeservers.com/ComputerScience/Compiler/ParserGeneratorAndParser/QuickReviewOfLRandLALRParsingTheory.html
21:56:43 <skew> this onse
21:56:50 <Pseudonym> Haven't seen that.
21:57:03 <skew> Oh, I guess that wasn't from you
21:57:16 <Pseudonym> No.
21:57:40 <Pseudonym> Do you have access to the ACM DL?
21:57:45 <skew> yes
21:57:48 <Pseudonym> Oh, damn.
21:57:50 <Pseudonym> It's not here.
21:58:02 <Pseudonym> KNUTH, D.E. On the translation of languages from left to right. Inform. and Contr. 8 (1965), 607-639.
21:58:10 <Pseudonym> That's the paper you want. :-)
21:58:46 <Pseudonym> I thought it was in the ACM DL, but it isn't.
21:58:58 <skew> was your code doing the quantum computation version of the parsing?
21:59:08 <Pseudonym> Yes.
21:59:18 <skew> any interesting grammars?
21:59:30 <Pseudonym> Only an old PHP grammar.
21:59:50 <skew> that's a classical grammar
22:00:45 <skew> wait a minute, where do the states come from if you are trying to make a model of quantum computation?
22:01:05 <skew> at least, if you are starting from something like BNF
22:01:10 <Pseudonym> Oh, that's different.
22:01:35 <Pseudonym> Kind of.
22:02:08 <Pseudonym> Because you can do transitions on the stack symbol, basically, you end up in a superposition of states.
22:02:31 <skew> yeah, I just don't see how that fits with deriving the states from the BNF, for mostly internal reasons
22:02:51 <Pseudonym> Well, the connection with quantum computing I think would be hard to extend to the automata.
22:03:11 <skew> do you know if there are any parsers that use pointer equality to handle left recursive grammars?
22:03:13 <Pseudonym> The idea is to make a _language_ model of quantum computing, not an _automata_ model.
22:03:19 <skew> parser combinators
22:03:36 <Smerdyakov> I hear language models for quantum computing aren't very nice!
22:04:00 <skew> as in, models of the languages quantum computers can recognize?
22:04:24 <skew> I don't know what you mean by language model there
22:04:44 <Pseudonym> skew: Do you understand about phrase structure grammars?
22:04:53 <skew> no, couldn't find any links
22:04:54 <Pseudonym> How general phrase structure grammars model Turing machines.
22:04:57 <Pseudonym> Ah, OK.
22:05:07 <Pseudonym> A context-free grammar is of the form:
22:05:07 <skew> well, I found some linguistics stuff
22:05:10 <Pseudonym> A -> w
22:05:24 <Pseudonym> where A is a nonterminal, and w is a string of terminals and/or nonterminals.
22:05:25 <skew> context free grammars are given
22:05:35 <Pseudonym> If instead you generalise this to: w1 -> w2
22:05:59 <Pseudonym> A parser for this family of languages must be Turing-complete.
22:06:29 <skew> doesn't the post coresspondence problem come in?
22:06:36 <Pseudonym> Yes, it does.
22:06:58 <skew> making languages of that form undecidable in general?
22:06:59 <Pseudonym> The point being that there's an isomorphism between classes of languages and classes of automata.
22:07:28 <Pseudonym> Similarly, there is an isomorphism between quantum machines and quantum languages.
22:11:29 <Pseudonym> There are some truly frightening states in the PHP parser.
22:12:04 <Pseudonym> q275 = "$" q36 + ";" q26 + "T_INLINE_HTML" q20 + "T_VARIABLE" q35 + "break" <4| q14 + "continue" <5| q15 + "declare" q25 + "do" <3| q11 + "echo" <9| q19 + "for" q12 + "foreach" <11| q24 + "global" <7| q17 + "if" q9 + "return" <6| q16 + "static" <8| q18 + "switch" q13 + "unset" q23 + "use" <10| q22 + "while" q10 + "{" <2| q8 + "}" {10} |2> |95> ([1] + [3] + [33] + [36] + [41] + [43] + [46] + [63] + [66] + [72] + [74] + [77] + [79] + [81] + [84] + [87] +
22:12:16 <Pseudonym> That should be "q7" on the end there.
22:14:18 <skew> looks like the middle of an expression
22:14:29 <Pseudonym> Most likely, yes.
22:14:36 <Pseudonym> Though there is "break", "continue" and "declare".
22:14:40 <Pseudonym> I think it's in the middle of a block.
22:15:01 <skew> does PHP use ; as a terminator or separator?
22:15:18 <Pseudonym> Dunno.
22:15:24 <Pseudonym> But ";" might be the null statement regardless.
22:15:53 <skew> I don't see any operators
22:16:06 <skew> probably a bloc then
22:16:18 <skew> how are the geberated parsers?
22:16:48 <Pseudonym> That's them.
22:17:10 <Pseudonym> I also have a Haskell function which interprets the descriptions to parse a stream of tokens.
22:17:35 <skew> whart are the advantages or this algorith over something like yacc?
22:17:43 <desrt> Cale; done my rewrite.  it *actually* produces one result in 12 clocks
22:17:53 <Pseudonym> First off, yacc is LALR(1).
22:18:07 <Pseudonym> And quantum parsing is, in theory, LR(k) for any k.
22:18:13 <desrt> i have no idea how anand is able to get a result per 2.5 clocks.  maybe it's that crazy pipelining :)
22:18:13 <Pseudonym> So more lookahead.
22:18:17 <Pseudonym> Secondly, the parsers are smaller.
22:18:58 <skew> what family does this generate? LR(k)?
22:19:08 <Pseudonym> In theory.
22:19:16 <skew> for specified k?
22:19:21 <Pseudonym> For any k.
22:19:26 <skew> or is it LR(\infty)
22:19:32 <skew> adding lookahead as needed
22:19:37 <Pseudonym> Right.
22:19:44 <Pseudonym> But if you do that, parser construction may not terminate.
22:19:49 <Pseudonym> Say, if the grammar is ambiguous.
22:20:00 <Pseudonym> But it also extends neatly to nondeterministic parsers.
22:20:05 <Pseudonym> Like byacc.
22:20:29 <Pseudonym> I haven't implemented LR(k) in my parser generator yet.
22:20:31 <Pseudonym> :q
22:20:35 <Pseudonym> Whoops.
22:21:19 <skew> one last question before I need to go for a bit - have you used the Utrecht combinators on tokens with position information?
22:21:31 <Pseudonym> No.
22:21:53 <skew> I'm using the Utrecht combinators for the reporting of multiple errors
22:23:02 <skew> but the class instances need to ignore the location field so they can't be derived
22:23:16 <Pseudonym> I have no idea, sorry.
22:23:18 <Pseudonym> Never used them.,
22:23:48 <skew> all I really care about is that they continue attempting to parse after an error
22:24:30 <skew> oh well. It's a bit premature to be worrying about user-friendliness of a compiler thet mostly doesn't exist, I suppose
22:25:33 <skew> well, I'm off until I've done some ... hmm, I don't even know what the branch of math is called!
22:25:46 <skew> proving stuff about differentiable manifolds anyway
22:26:37 <Pseudonym> Sounds interesting.
23:09:39 * SamB sees that article on OSNews, wonders what is meant by "MVC is but a natural consequence"
23:10:17 * SamB doesn't get MVC -- what is a controller?
23:14:34 <Jerub> SamB: controller is the business logic side.
23:14:43 <Jerub> its a smalltalk thing.
23:14:49 <Jerub> suitable for talking about gui development
23:14:52 <ozone> it's an OO thing, not a smalltalk thing
23:15:03 <Jerub> ozone: its something that came out of smalltalk.
23:15:15 <ozone> SamB: controller is the thing which gets the view to talk to the model
23:15:18 <Jerub> and the most recent language that it works well in is smalltalk ;)
23:15:22 <ozone> Jerub: true.  but it's still an OO thing
23:15:33 <ozone> Jerub: incorrect, works well in objective-c too
23:15:51 <ozone> (in fact, very first chapter of most objective-c books talk about MVC)
23:16:00 <Riastradh> ozone, Objective-C counts as Smalltalk.
23:16:14 <ozone> Riastradh: awww, ok then
23:16:20 <ozone> it's still an OO design pattern
23:16:36 <SamB> well, I still don't understand it.
23:16:47 <ozone> SamB: hang on a second
23:19:45 <ozone> http://developer.apple.com/documentation/Cocoa/Conceptual/AppArchitecture/Concepts/MVC.html
23:21:55 <ozone> you may also want to see http://developer.apple.com/documentation/Cocoa/Conceptual/ObjCTutorial/index.html to put it in context
23:23:28 * SamB decides to read in morning. well, err, next afternoon...
23:29:56 * SamB has nearly finished downloading aplus
23:33:01 <Hyp3rion> Morning!
23:33:30 <SamB> Hyp3rion: night! well, morning, but I haven't gone to bed yet!
23:34:13 * Riastradh ought to go to bed in about negative two or three hours.
23:34:14 <Hyp3rion> SamB, Heh
23:34:35 <SamB> Riastradh: yeah, me too
23:34:42 <Hyp3rion> Ouch, 02am
23:38:07 * Riastradh wanders off to bed.
23:38:36 <Pseudonym> Hyp3rion: Only you and me left by the look of it.
23:39:20 <Hyp3rion> Riastradh, Nite
23:39:46 <Hyp3rion> Pseudonym, ? Yea :-)
23:40:37 * SamB actually goes to bed...
23:40:43 <SamB> now!
23:40:43 <Pseudonym> Night.
23:41:10 * SamB turns off sipplay and goes again
23:42:17 * Pseudonym is finding it hard to believe that SamB is really leaving
23:50:03 * bluejay is here too
23:51:45 * adept too
23:52:24 * anduril1 isn't here
23:52:36 <Pseudonym> Looks like a quorum.
23:52:39 <Pseudonym> Let's trash the place!
