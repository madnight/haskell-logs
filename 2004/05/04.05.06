00:00:59 <vegai> indeed. Graphics.Rendering.OpenGL
00:02:49 <Cale> yeah, it's for the GL state variables
00:02:58 <Cale> ($=) :: s a -> a -> IO ()
00:03:19 <Cale> where s is an instance of HasSetter
00:07:58 <vegai> would anyone care to guess what this should look like in recent ghc?
00:08:05 <vegai> (Where' Width IsEqualTo 1600)
00:08:20 <vegai> Where' and IsEqualTo are in Graphics.UI.GLUT, but I can't seem to find Width 
00:08:22 <shapr> yow!
00:08:48 <vegai> (and it seems by comments on the source, that Width used to be called BitsPerPlane)
00:09:09 * vegai mutters about things changing names without backwards compatibility.
00:09:37 <vegai> shapr: hi'ya
00:09:51 <shapr> g'mornin!
00:10:07 <shapr> Pseudonym: hey, @type does hierarchical names now
00:10:20 <shapr> @type Control.Monad.foldM
00:10:21 <lambdabot> type: 
00:10:21 <lambdabot> foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
00:10:34 <shapr> mwotton: g'day mrak
00:10:37 <mwotton> afternoon
00:10:44 <shapr> wassup?
00:10:47 <mwotton> oops, my nom is showing
00:11:03 <mwotton> shapr: got a team together for ICFP yet?
00:11:22 <Cale> @type Graphics.Rendering.OpenGL.GL.StateVar.get
00:11:23 <lambdabot> type: 
00:12:21 <shapr> I don't think that I have HOpenGL installed there, and I don't think hugs can see it anyway
00:12:40 <shapr> mwotton: nah, not yet
00:12:50 <shapr> busy organizing EuroHaskell
00:13:22 <mwotton> EuroHaskell? Conference?
00:13:28 <shapr> sort of
00:13:33 <shapr> @eurohaskell
00:13:34 <lambdabot> less talks, more code!
00:13:34 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
00:13:34 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
00:14:17 <shapr> more like an academic lan party
00:15:08 <mwotton> Looks like fun.
00:15:28 <Pseudonym> G'day.,
00:15:36 <mwotton> heh.. you know the ACM competitions? C/C++/Java only?
00:15:51 <shapr> yah, heard of 'em
00:15:51 <mwotton> dons wrote a little tool for hiding haskell code in c.
00:15:56 <shapr> ohhh
00:15:59 <Lor> Is anyone organising joint housing at sgsveckobostader?
00:16:32 <shapr> Lor: not that I know of
00:16:41 <mwotton> http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
00:16:59 <mwotton> completely flouts the spirit. Hopefully it doesn't break the rules... i'll soon find out.
00:17:35 <shapr> I'm going to EuroPython as well, so I've organized my room sharing that way
00:18:22 <Lor> Muahah! Hope they have an IOCCC-like award for "most innovative bending of the rules". :)
00:18:47 <Lor> How early must the rooms be reserved?
00:19:30 <shapr> at some point soon any leftover EuroPy rooms will be unreserved
00:20:30 <shapr> so I think early reservation is not necessary, but I'm not 100% sure of that
00:21:38 <Lor> Hm, I'll add a section to the wikipage about who is interested in joint housing at sgs...
00:21:47 <shapr> good idea
00:28:26 <shapr> does anyone have a recent copy of programatica?
00:29:12 <shapr> source, that is
00:30:36 <shapr> hiya adept 
00:30:48 <adept> shapr: !
00:32:23 <shapr> –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ
00:32:47 <adept> shapr: whats this??
00:32:56 <Pseudonym> He's trying to hack your IRC client.
00:33:07 * shapr grins
00:33:11 <l^rchkrn> The new Haskell2004
00:33:22 <shapr> it's hello in russian in utf-8
00:33:34 <shapr> maybe I should have hried koi
00:33:38 <adept> in the lines of Stroustroup's "Whitespace overloading"?
00:34:13 <shapr> I dunno about that one
00:34:15 <adept> shapr: yep. nobody uses utf-8 for cyrillic irc. 90% is koi8-r, others use win-1251 + port-recoding irc servers
00:34:44 <shapr> –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ
00:35:01 <shapr> better?
00:35:06 <l^rchkrn> No.
00:35:10 <shapr> :-/
00:35:13 <l^rchkrn> Quite a long "hello"...
00:35:15 <shapr> irc sucks
00:35:23 <shapr> the protocol, that is
00:35:24 <adept> no. Ùhis is a correct one:
00:35:24 <adept> –“…◊≈‘!
00:35:29 <shapr> ohh
00:35:29 <l^rchkrn> Cs· csumi cs· csˆ
00:35:32 <shapr> I can see that!
00:35:49 <l^rchkrn> Van n·latok t·vcsˆ?
00:35:55 <l^rchkrn> Nincs n·latok t·vcsˆ?
00:36:08 <l^rchkrn> Csumi cs· csumi na csˆˆˆ!!!
00:36:10 <adept> l^rchkrn: what language is that?
00:36:16 <l^rchkrn> adept: Guess.
00:36:18 <shapr> hm, I dunno how to type that in emacs
00:36:25 <adept> hmmm...
00:36:28 <l^rchkrn> ¯
00:36:40 <l^rchkrn> ÊÈ·˙Û¸ÌÔˇÁ
00:36:48 <shapr> looks nifty anyway
00:37:30 <adept> shapr: (encode-coding-string (decode-coding-string "utf string" utf-8) koi8-r) ?
00:37:37 <l^rchkrn> Are theese display as two different chars for you or the same?: | ¶
00:37:46 <shapr> l^rchkrn: different
00:37:48 <adept> l^rchkrn: different
00:37:52 <l^rchkrn> Okay.
00:38:05 <l^rchkrn> Someone in #freenode told me its the same :-\
00:38:19 <adept> l^rchkrn: language was Hungarian?
00:38:26 <l^rchkrn> And IRC rulez. #animescene in Japanese UTF-8 sometimes :-)
00:38:36 <l^rchkrn> adept: Right!
00:38:40 <l^rchkrn> How did you know?
00:38:46 <shapr> http://shapr.homelinux.net/~shae/haskell-koi8.png
00:39:28 <Pseudonym> How can you read that?!
00:39:32 <adept> l^rchkrn: googled for "Nincs" :)
00:39:46 <Pseudonym> All I see is big lines.
00:39:47 <shapr> Pseudonym: you mean the cyrillic?
00:39:56 <Pseudonym> No, I mean the colour scheme and highlighting.
00:39:57 <l^rchkrn> shapr: :-) Not really the way I meant...
00:40:02 <Pseudonym> The cyrillic is easy.
00:40:09 <adept> shapr: hmm. It looks ok, excepts for the colors :)
00:40:24 <shapr> no one likes my colors but me :-P
00:40:50 <adept> shapr: "500 Internal server error" looks cool too :)
00:41:07 <shapr> what can I say, bright things grab my attention instantly, so I exploit that in my color-theme
00:41:31 <shapr> yah, that't curryspondence that needs fixing
00:41:45 <shapr> but I duuno enough about WASH yet
00:41:54 <Lor> curryspondence? :)
00:42:09 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
00:42:37 <shapr> empty search or zero lists selected gives an error
00:43:16 <shapr> I also haven't thought of a good way to do periodic updates, any suggestions?
00:49:54 <shapr> is there some way to get a list of modules via anon cvs?
00:50:01 <l^rchkrn> Took time but here's how it looks for me: http://oplb.sourceforge.net/xdump003.png
00:51:58 <shapr> nifty
00:52:59 <Cale> http://vx.hn.org/autoshare/screenshot.png
00:55:25 <l^rchkrn> Cale: XChat without nick coloring?
00:55:52 <Cale> Yep.
00:56:10 <shapr> I use emacs for irc
00:56:17 <Cale> I only highlight particular words that I'm interested in, like my name, for instance.
00:56:45 <Pseudonym> Must away.
00:56:50 <Pseudonym> Nytol!
00:57:10 <Cale> Advil!
00:57:34 * shapr grins
00:58:00 <l^rchkrn> Nytol?
00:58:06 <l^rchkrn> Advil?
00:58:18 <l^rchkrn> What language is _this_?
00:58:25 <shapr> American!
00:58:39 <l^rchkrn> Nytol = Night to all
00:58:44 <l^rchkrn> But advil?
00:59:08 <shapr> nytol is also a pill to help you sleep when you have a cold
00:59:08 <Cale> I dunno.
00:59:11 <shapr> in the US
00:59:27 <Cale> And Advil is a pain killer.
01:00:46 <l^rchkrn> :-)
01:01:35 <l^rchkrn> So everyone is using different irc clients here. There should be a Haskell one ;-)
01:02:38 <shapr> there is
01:02:45 <shapr> hircules
01:02:54 <l^rchkrn> :-)
01:03:24 <l^rchkrn> But I guess its not good if you dont use that
01:03:48 <l^rchkrn> Oh, its 0.3
01:07:46 <shapr> Programatica sure is picky
01:15:09 <shapr> good morning Simon
01:15:15 <shapr> g'day ozone 
01:15:23 <JaffaCake> mornin'
01:17:35 <shapr> ok, time to try out HaRe
01:30:23 <skew> hi
01:30:59 <skew> JaffaCake: I solved my FFI problem. omitting the & is BAD when you try to import a pointer to a function!
01:31:11 <JaffaCake> hehe, right :)
01:31:33 <skew> I tried compiling with -O, and gcc caught the type error for me...
01:31:43 <JaffaCake> yep, that's a good tip
01:32:15 <skew> That's the first time C's type system has worked better than Haskell's for me.
01:32:56 <JaffaCake> well a better FFI tool would have caught the problem - c2hs for example
01:33:19 <skew> maybe I should look at one of those
01:33:31 <skew> at the moment I'm generating marshalling code with TH
01:33:43 <JaffaCake> hmm, sounds interesting
01:33:52 <JaffaCake> the new GreenCard uses TH too
01:35:34 <skew> I want to make a raw binding, and a wrapper unwraps and wraps ForeignPtr
01:36:53 <skew> I didn't think any of the standard interface generators would do that
01:37:27 <JaffaCake> perhaps not
01:38:14 <skew> Also, I'm not sure how to represent the reference ownership
01:38:39 <JaffaCake> reference ownership?
01:38:44 <skew> some functions return an "owned" reference, where you just need to set up a decref finalizer
01:38:56 <JaffaCake> ok
01:39:10 <skew> others return a "borrowed" reference, so the marshalling needs to register another reference with an incref before setting up the finalizer
01:39:51 <skew> I think moment I just have two made up types for that, used in type splices that the TH analyses to compute the raw and wrapped type of the function, and the correct wrapping mode
01:39:57 <JaffaCake> yes, sounds like you have to program to the low level FFI
01:40:18 <JaffaCake> or write your own tool...
02:08:07 * shapr bounces
02:08:12 <shapr> moomlyn: hiya
02:09:34 <moomlyn> shapr: hi
02:10:34 <shapr> moomlyn: looking for Haskell info?
02:12:12 <moomlyn> shapr: I don't really know much about haskell, but my friend was explaining to me about haskell uses lazy evaluation to chase its own tail and create infinite lists. It sounded cool, so I thought I might just hang out here and see what I can pick up by osmosis :)
02:12:53 <skew> moomlyn: you're in luck today. JaffaCake (= Simon) wrote good bits of GHC. stand extra close to him :)
02:13:08 * moomlyn moves a little closer to JaffaCake
02:13:09 <JaffaCake> somebody mention me?
02:13:19 <skew> moomlyn: wants to learn by osmosis
02:13:34 <skew> er
02:13:41 <skew> JaffaCake: moomlyn wants to learn by osmosis
02:13:53 <skew> so I suggested standing by you :)
02:14:02 <JaffaCake> oh, i c
02:14:04 <JaffaCake> :)
02:14:41 <shapr> moomlyn: lazy lists are fun
02:14:52 <skew> lazy everything is fun
02:15:01 <shapr> ones = 1 : ones
02:15:39 <moomlyn> I never even knew what "lazy" meant (w.r.t programming languages) until yesterday!
02:15:46 <moomlyn> (I probably still don't really understand)
02:16:20 <skew> moomlyn: have you ever had to implement something like an interpreter or config file parser, where bits of the file refered to each other by name?
02:16:29 <shapr> every language must be partially lazy
02:16:47 <shapr> look at an if statement, why aren't both branches evaluated?
02:17:30 <shapr> so you could simulate laziness with an if in most langs
02:17:49 <shapr> wouldn't be elegant, but it would work
02:17:49 <moomlyn> skew: Do you mean have I hever tried to implement recursive/self-referential structure and not been able to figure out how to get the thing to pull itself up by its own bootstraps?
02:17:57 <JaffaCake> but you can only write an 'if' function in a lazy language
02:18:08 <skew> moomlyn: yep
02:18:27 <skew> generally you use mutable variables, build the thing with dummy references then go back and fix them up
02:18:39 <moomlyn> skew: I once tried to write a recursive regexpr, that was tricky :)
02:18:57 <skew> I Haskell you *can* get the thing to pull itself up by the bootstraps. It's fun!
02:19:19 <moomlyn> skew: yeah... that's what my friend showed me yesterday. It looks very cool indeed.
02:19:40 <skew> neat. What was the example? Is this anybody we know?
02:20:57 <shapr> if condition ifTrue ifFalse = case condition True -> ifTrue; False -> ifFalse
02:21:04 <shapr> ?
02:21:36 <moomlyn> skew: it was something like this: fibs = 0:1:zipWith <+> fibs (tail fibs)  (I might have gotten it wrong)
02:21:58 <skew> that's pretty close, just probably (+) instead of <+>
02:22:08 <moomlyn> skew: ya
02:22:22 <skew> the (op) notation is nice. You can turn any infix operator into a function that way.
02:22:36 <moomlyn> skew: ya
02:23:11 <moomlyn> skew: The only language I really know is python, so I tried to get python to do the same lazy thing with generators.
02:23:30 <skew> you can do that sometimes.
02:23:32 <moomlyn> skew: but in python you can't pass operators like +, - + etc... around as arguments to functions
02:23:42 <skew> you need iter.tee (from 2.4) to really get things to work out
02:23:44 <shapr> I jumped from Python to haskell
02:23:58 <skew> I jumped from Unlambda to Haskell ;)
02:24:08 <shapr> you can use operator.add
02:24:31 <moomlyn> shapr: You can?
02:24:34 * moomlyn goes and checks
02:24:56 <moomlyn> shapr: What do you mean?
02:25:15 <skew> moomlyn: the operator module contains functions that are synonyms for all the operators
02:25:26 <moomlyn> shapr: oh, I have to import first?
02:25:35 <skew> yes
02:25:37 <moomlyn> skew: I see.
02:25:56 <moomlyn> skew: I didn't know about that one, thanks.
02:26:02 <shapr> map(operator.add,[1,2,3])
02:26:22 <skew> shapr: no curry in Python!
02:26:47 <moomlyn> skew: You can write your own curry function though, if you want to.
02:27:07 <skew> yep, but shapr's code will be unhappy
02:27:08 <shapr> actually..
02:28:11 * moomlyn has forgotten quite what "currying" is, but vaguelly remembers some python-people talking about it elsewhere where she was trying to learn by osmosis.
02:28:53 <skew> currying is operator.add(1) = lambda x:1+x
02:28:58 <moomlyn> Is it something to do with binding some of the arguments to a function at one time, and some others at a later time?
02:29:18 <skew> binding them one at a time, actually
02:31:33 <moomlyn> skew: actually I have the code for a python curry class right here....
02:32:16 <moomlyn> skew: the __init__ method seems to bind a functions some args and some kwargs, and then the __call__method adds a few more args and kwargs to those bound in the __init__ method then calls the function.
02:32:24 <skew> I've seen some (I think I actually wrote one, at some point)
02:33:12 <skew> all Haskell functions get their paramaters one add a time in a similar way
02:33:47 <skew> it makes default values and keyword arguments nearly impossible, but it's usually worth it
02:34:22 <moomlyn> skew: get their parameters one at a time? Can you give me an example?
02:34:58 <moomlyn> (I suppose this is the lazy stuff again... only processing parameters at the last possible minute?)
02:35:10 <skew> map (1+) is a function that takes a list and increments each element
02:35:26 <skew> map is usually thought of as a function of two arguments
02:35:58 <skew> Types like (a,b) -> result are equivalent to types like a -> b -> c
02:36:14 <skew> currying is very handy for building arguments to higher order functions
02:36:42 <moomlyn> skew: map (1+) : List -> List  ??
02:36:43 <skew> the argument to that map, (1+) is syntactic sugar for ((+) 1), or + applied to only it's first argument
02:36:55 <skew> moomlyn: yeah, it works on lists
02:37:36 <skew> map applies it's argument to each element of a list, so it's often handy to use a function applied to all but the last argument as the thing to map
02:38:04 <skew> moomlyn: haskell is actually more specific about the list type, keeping track of what sorts of things are inside the list
02:38:30 <moomlyn> skew: Why doesn't this work: let N = 1:map (1+) N
02:38:56 * moomlyn trying to generate the natural numbers
02:38:59 <skew> this does: let n = 1:map (1+) n
02:39:22 <moomlyn> Prelude> let n = 1:map (1+) n
02:39:25 <moomlyn> ERROR - Syntax error in expression (unexpected end of input)
02:39:32 <skew> Haskell uses case to distinguish between the names of types and constants (UpperCase), and identifiers and type variables, (lower case)
02:39:36 <skew> are you using hugs?
02:39:42 <moomlyn> ya
02:39:49 <skew> in that case try let n = 1:map (1+) n in n
02:40:09 <moomlyn> coolios
02:40:31 <moomlyn> but I didn't want it to spew the result all over the screen, I wanted to do, say: take 10 n
02:40:46 <skew> then just stick that in the body of the let
02:41:13 <moomlyn> Would it be better if I put the definition in a file and then :load(ed) it?
02:41:15 <skew> the let makes a bunch of bindings, but you need to have an expression that will be evaluated with using those bindings
02:41:54 <skew> the top level of ghci treats inputs as statements, so you can use the statement form of let where the bindings are visible in the rest of the block
02:42:09 <skew> moomlyn: that's a good idea.
02:42:23 <skew> hugs doesn't let you define something and keep playing with it in sucessive statements
02:42:33 <skew> ghci does, though
02:42:52 <moomlyn> What's ghci ??
02:43:03 <skew> the interpreter that goes with GHC
02:43:26 <moomlyn> okay, it works now.
02:44:03 <moomlyn> I put it in the same file as the definition of fibs, they look kind of nice next to each other :)
02:44:46 * moomlyn wonders if she can make natural look even more like fibs...
02:45:04 <skew> moomlyn: how about iterate (1+) 0?
02:45:14 <skew> or just [0..]
02:45:34 <moomlyn> skew: I'm totally new to this
02:45:45 <skew> the last is sort of cheating, that's syntax for "enumFrom x"
02:45:52 <skew> where enumFrom x = x:enumFrom (x+1)
02:46:46 <skew> iterate f x = x:iterate f (f x)
02:47:24 <skew> Haskell has the best library for this sort of list stuff of any language I know of.
02:47:37 <skew> Python has been stealing functions bit by bit.
02:48:58 <moomlyn> I thought this might work: natural = 1:zipWith (+) natural (head natural)
02:49:00 <moomlyn> but no.
02:49:23 <skew> zipWith takes two lists. head natural is just the number 1
02:49:32 <moomlyn> skew: hmmmm...
02:50:13 <skew> you could use map (1+) natural, folding the constant into the function (this is where currying is handy)
02:50:25 <skew> or, you could make a infinite list of 1s with repeat.
02:50:53 <moomlyn> ones = 1:ones
02:50:56 <moomlyn> natural = 1:zipWith (+) natural ones
02:51:04 <skew> @type repeat
02:51:05 <lambdabot> type: 
02:51:05 <lambdabot> repeat :: a -> [a]
02:51:12 <skew> repeate 1 gives ones
02:51:34 <skew> there's also replicate, which makes a specified number of copies
02:51:51 <skew> (which can be useful with IO actions as well)
02:51:55 <moomlyn> skew: It sure is a funny language.
02:52:00 <skew> cycle repeats a list over and over again
02:52:08 <skew> some of these should sound familiar from itertools
02:54:43 <moomlyn> skew: What language is haskell written in, lisp? C?
02:54:52 <skew> GHC is written in Haskell
02:54:57 <moomlyn> heh
02:54:58 <skew> actually, Haskell with GHC extensions
02:55:14 <skew> C for the runtime and garbage collector, I think
02:55:17 <skew> Hugs is in C
02:55:25 * moomlyn tries to imagine using haskell to lazilly write itself in itself
02:55:39 <skew> that's about how it goes...
02:56:04 <skew> you try to run the program, and then the compiler kicks in and actually generates some code...
02:56:13 <skew> ;)
02:56:49 <skew> actually, I don't think GHC uses laziness too much
02:57:19 <moomlyn> But does the compiler somehow lazily compile itself?
02:57:31 <skew> it's a bootstrapping process, like with gcc
02:58:08 <skew> one mode of GHC is to compile Haskell to C and run that through gcc (still a bit better than GHC's own native code generator)
02:58:27 <skew> a fresh port usually starts with those files
03:00:04 <moomlyn> I suppose it would be asking to much to expect to be able to compile itself from scratch (not using a pre-compiled version of itself)
03:00:20 <moomlyn> to expect the compiler to be able to compile itself
03:00:51 <vegai> seems like quite a task
03:00:56 <skew> you might be able to use another Haskell compiler
03:01:19 <moomlyn> skew: but that's not really the same thing.
03:01:19 <skew> I know the build does the stage thing, where it builds a stage 1 compiler and uses that to build the stage2 compiler
03:01:29 * moomlyn is just being overly speculative
03:02:20 <skew> well, if there really is a bit written in more standard Haskell, you could bootstrap up from something written totally in C, like Hugs
03:03:06 <moomlyn> skew: maybe there is some teeny-tiny bit of core functionality of haskell which you can write in C, and execute that, and it will lazilly auto-generate the complete Haskell?
03:03:40 <skew> and you can bootstrap your C compiler from some really tiny language like forth that's easy to code up in assembly
03:03:42 <moomlyn> (only as you try to use particular pieces of haskell functionality of course)
03:04:23 <moomlyn> anyway, I'm getting ahead of myself. I only know, like, one haskell idiom :)
03:05:38 <skew> referential transparency and type classes and monads are the other big ones
03:05:51 <skew> well, referential transparency is pretty much forced by laziness
03:06:51 <moomlyn> skew: referential transparency == no side effects right?
03:07:06 <skew> pretty much
03:07:29 <skew> it means definitions are actually equal
03:07:29 <moomlyn> What are type classes and monads?
03:07:32 <ibid> moomlyn: referential transparency is the ability to replace equals with equals :)
03:08:12 <skew> like, x = printf("stuff"); return x > x is different from return printf("stuff") > printf("stuff") in most languages
03:08:50 <moomlyn> Does it kinda mean "no global variables which can be accessed by more than one function" ??
03:08:57 <skew> monads are how you intergrate referential transparency and side effects
03:09:06 <ibid> moomlyn: no
03:09:17 <moomlyn> ibid: no?
03:09:27 <ibid> moomlyn: no
03:09:46 * moomlyn doesn't understand then.
03:10:00 <ibid> moomlyn: talking about referential transparency, right?
03:10:17 <moomlyn> Does it mean if you have a function f, and you call f once, and then call f again you are guaranteed EXACTLY the same result both times?
03:10:26 <skew> moomlyn: yes
03:10:29 <ibid> moomlyn: the basic idea is that the return value of a function should only depend on the values of its explicit parameters
03:10:33 <ibid> moomlyn: yes
03:10:51 <moomlyn> ibid: right, that function shouldn't depend on some global variable somewhere whose state might change between invocations?
03:11:06 <skew> you can reconcile that with side effects by requiring that all things with side effects are explicitly ordered
03:11:27 <ibid> moomlyn: in  principle you can use global variables but only if its effect can be hidden from the caller
03:11:34 <skew> it's sort of like implicitly passing along the line number in something like C...
03:11:50 <ibid> lunch time, bbl :)
03:12:14 <shapr> hm, 83 on #haskell is nice
03:12:31 * moomlyn cannot see how it could be possible to have "referential transparancy" and global variables at the same time.
03:12:57 <shapr> pass in the globals explicitly?
03:13:18 <moomlyn> because if the function does different things depending on the state of the global variable, and the global variable changes between invocations, surely the return value of the function will be different.
03:13:25 <moomlyn> shapr: I wouldn't call that a global variable.
03:13:55 <skew> moomlyn: you say that the function is a function of the state of the program and it's explicit arguments
03:14:04 <moomlyn> shapr: global variables are, by definition, made available to a function implicitely, no?
03:14:19 <skew> moomlyn: then if you run it for different states of the global variable that counts as different inputs
03:14:31 <moomlyn> skew: but, but, but....
03:14:36 * moomlyn thinks that's somehow cheating.
03:14:40 <skew> it is
03:14:59 <skew> to get it to work out you need to explicitly specify the order of the computations
03:15:27 <skew> the goal is referential transparency, not so much to banish side effects
03:15:39 * moomlyn thinks better just not to have global variables if referential transparancy is important to you.
03:15:50 <moomlyn> pass all variables to the function explicitely, like you said.
03:15:53 <moomlyn> Its safer.
03:16:02 <skew> moomlyn: safer how?
03:16:07 <skew> more explicit, certainly
03:16:12 <moomlyn> skew: less likely to have unexpected side effects :)
03:16:38 <shapr> yup
03:16:52 <shapr> it's all about where you keep the state
03:16:52 <moomlyn> If your program is doing something funny, you can get it to print out the value of all its arguments.
03:16:58 <moomlyn> and that will give you some clue as to what's going on.
03:17:02 <shapr> in OOP it's in your instances
03:17:03 <skew> things that can have side effects in Haskell end up with special types (as a result of this threading them together), so it's easy to tell what can have side effects
03:17:07 <moomlyn> but you might "forget" to print out the contents of a global variable.
03:17:07 <skew> and to minimize them
03:17:10 <shapr> in Haskell it's all in one place
03:17:19 <shapr> makes testing easier too
03:18:24 <skew> even before you use QuickCheck.
03:18:47 <shapr> @type Debug.QuickCheck.Arbitrary
03:18:47 <lambdabot> type: 
03:18:58 <shapr> @type Debug.QuickCheck.quickcheck
03:18:59 <lambdabot> type: 
03:19:24 <shapr> @type Debug.QuickCheck.quickCheck
03:19:24 <lambdabot> type: 
03:19:24 <lambdabot> quickCheck :: Testable a => a -> IO ()
03:19:56 <shapr> anyway, @type does hierarchical names now
03:20:00 <JaffaCake> @type Control.Monad.ST.runST
03:20:00 <lambdabot> type: 
03:20:11 <shapr> but it uses Hugs :)
03:20:19 <JaffaCake> oh dear :)
03:20:21 <shapr> so whatever hugs has
03:20:51 <shapr> oh, JaffaCake, you think haddock could dump an FM of sig to func name?
03:20:55 <moomlyn> So what are "type classes and monads" ??
03:21:10 <shapr> I was thinking how to do search by sig
03:21:11 <skew> moomlyn: one more thing about the functions first.
03:21:24 <JaffaCake> hmmm
03:21:47 <moomlyn> skew: sure
03:21:47 <shapr> I wonder if I could swap @type to GHCi
03:21:55 * moomlyn absorbing much knowledge
03:21:55 <JaffaCake> in what form do you want it?  HsType isn't showable and I don't have a binary instance
03:22:47 <JaffaCake> searching by type would be really useful tho
03:23:06 <skew> moomlyn: thinking about a block of statments with side effects as a function that modifies the state of the world seems to lead to better organizes and less redundant code
03:23:18 <shapr> I haven't thought of a good way to search such an index
03:23:32 <shapr> browsing would be simple enough though
03:23:34 <moomlyn> hmmm... a function that modifies the state of the world...
03:23:38 <JaffaCake> there's lots of previous work on searching by type
03:23:47 <shapr> any pointers?
03:23:55 <JaffaCake> by folk at Chalmers if I'm not mistaken...
03:24:30 <JaffaCake> Rittri I think
03:24:39 <skew> I don't think there is anything you can do with IO actions that you can't do with plain side effecting functions of no arguments, but it's a better persepective
03:24:41 <moomlyn> skew: but if there are functions which modify the state of the world, and functions whose return values depend on the state of the world, surely we have not achieve referential transparency?
03:24:58 * moomlyn doesn't get it.
03:25:30 <skew> moomlyn: the critical piece is that the whole program must be one single chain of functions acting on that state of the world, and that none of the states of the worlds are considered identical
03:25:50 <shapr> @type Control.Monad.foldM
03:25:51 <lambdabot> type: 
03:25:51 <lambdabot> foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
03:25:51 <betabot> type: 
03:25:51 <betabot> Control.Monad.foldM :: forall a m b.
03:26:06 <skew> another way to think about it is that we use perfectly side-effect free Haskell code to generate a description of an imperative program
03:26:16 <shapr> oh, the regex is wrong now with GHCi
03:26:33 <moomlyn> skew: Then why not pass "the state of the world" into the functions explicitely?
03:26:44 <skew> moomlyn: clean does things that way
03:26:52 <skew> but it has some special type stuff.
03:27:10 <Igloo> Why's the "type:" on a separate line (actually, I'm not sure it's necessary at all)
03:27:21 <skew> It's kinda bad if you try to safe the state of the user before they give input, and resume from there if they do something stupid.
03:27:24 <shapr> JaffaCake: thanks, I'll look up Rittri later
03:27:38 <skew> well, it's a nice programming model, but a bit hard to implement
03:27:44 <moomlyn> skew: So does C have "referential transparancy" ?
03:27:47 <shapr> Igloo: just so I could see failure, it isn't necessary at all
03:27:51 <Igloo> There was something about building ghc as a package on the lists recently - would that allow you to ask it the type of something? That would avoid having to pay the startup cost of ghci each time
03:27:51 * moomlyn thinks no but cannot explain exactly why.
03:27:58 <Igloo> Ah, right
03:28:10 <skew> moomlyn: it's a question of what you consider a definition
03:28:18 <JaffaCake> Igloo: yes you could do that
03:28:26 <shapr> how so?
03:28:27 <JaffaCake> the API isn't very nice at the mo
03:28:33 <shapr> that would be spiffy
03:28:35 <skew> if you think int x = printf("stuff"); consititues a definition of x, then no
03:28:35 <moomlyn> skew: Well is there an agreed upon definition of "referential transparancy" and if not why not?
03:29:17 <moomlyn> skew: Is it possible for a program which does I/0 to have referential transparancy?
03:29:26 <moomlyn> skew: or is that, by definition, impossible.
03:29:30 * moomlyn is well and truly confused
03:29:44 <skew> it's a question of what you sorts of definitions you want to be transparent
03:30:02 <skew> in Haskell a function defintion function arg1 arg2 .. = body is always trasnparent
03:30:09 <skew> that is, you can replace the left side with the right
03:33:20 <moomlyn> skew: I don't think I really know enough haskell to understand at this point.
03:34:59 <moomlyn> skew: I have to go... stuff to do... If I stay on ICQ all day I won't get any of it done. Catch you later?
03:35:12 <skew> it doesn't really matter.
03:35:27 <skew> the important point here is that if you call some function it won't perform any side effects
03:35:52 <skew> except if you go out of your way to say "perform the side effects the result specifies"
03:36:04 <moomlyn> skew: right
03:36:16 <moomlyn> skew: So we divide all functions into two types, those with side-effects and those without.
03:36:20 <skew> so most of your code can ignore side effects.
03:36:27 <moomlyn> skew: and we have to call those with side-effects in a slightly different way to those without?
03:36:50 <skew> sort of
03:37:07 <skew> it's more like one kind of value in haskell is a package of side effects
03:37:40 <skew> so we have pure functions that take some arguments (maybe a string to print), and return a description of some stuff to do (print the string)
03:37:58 <skew> and we can compose these nicely, just like we can appens lists and such
03:39:09 <skew> It will make sense if you write some code
03:39:40 <moomlyn> skew: In functional languages, the thing to do is pass functions as arguments into other functions right? (wheras this is quite rare in both structural and OOP paradigm?)
03:39:53 <moomlyn> skew: This is what you mean by "composing" functions?
03:39:57 <skew> that happens a lot
03:40:33 <skew> composing is one particular thing, where you take two functions and combine them to get one function that has the same effect as running a value through one and then the other
03:40:45 <moomlyn> skew: right, same as mathematics then.
03:40:48 <skew> when I'm talking about compositional stuff that's a bit more general
03:41:35 <skew> like, you can take a parser than recognizes an integer, and a parser that recognizes a string, and use them directly as parts of a bigger parser that reads a number and then that many strings say.
03:41:42 <skew> if they are being compositional
03:42:00 <skew> as opposed to huge opaque state tables like bison makes, where you can't easily combine parsers
03:42:46 <moomlyn> skew: Do you pass the parser which recognizes and int, and the parser which recognizes a string into the "outer parser" as arguments?
03:43:08 <skew> you could, then you would have a paramaterizable parser
03:43:21 <moomlyn> hmmm....
03:43:24 <skew> or you could just refer directly to the inner parsers
03:44:15 <skew> the other thing I mention are type classes, which to first order are formalizing the Python sensibility of "function taking an object on which I can perform such and such an operations", and formalizing it into something machine verifiable and optimizable
03:45:00 <moomlyn> skew: python never verifies anything, right? It just raises an exception if the attribute doesn't exist or is not callable?
03:45:22 <adept> example: all types that could be read constitute type class Read
03:45:41 <skew> that's just one aspect, like handling side effects is just one aspect of monads. I'm just explaining the bits that are probably the easiest to understand and most obviously useful
03:45:54 <skew> moomlyn: yep, Python does no checking.
03:46:03 <skew> but Python programs are usually written along those lines
03:46:18 <Igloo> JaffaCake: Are you still here?
03:46:27 <JaffaCake> yup
03:46:48 <skew> moomlyn: bye!
03:47:22 <moomlyn> skew: bye!
03:47:31 <skew> happy back-to-working.
03:47:53 * moomlyn back-to-working also
03:48:04 <Igloo> re the sparc, unfortunately it's Debian's not mine so I can't give you an account. I've just tried compiling "module Test where foo _ = 5" and "module Test where foo 1 = 5" and only the latter fails. If I remember correctly one fo the octets of the number charToUtf8 fails on is a little 'p', so I suspect it's patError that is causing the problem if that is any help
03:48:55 <Igloo> (oh, and yes, only sparc seems to be affected, although it could be the other arches just got lucky with 0s being in the appropriate place))
03:49:41 <JaffaCake> thanks, that might give me enough to go on
03:50:07 <skew> ffi question. Is there any sort of definition I can write that will give me a FunPtr equivalent to a Haskell function (short of combining unsafePerformIO and a wrapper)
03:50:35 <JaffaCake> skew: foreign import "wrapper"
03:51:18 <skew> JaffaCake: I'd like to avoid rewrapping my function each time I need an argument
03:51:30 <skew> for clear code more than anything else
03:52:03 <JaffaCake> not sure what you mean
04:07:54 <JaffaCake> Igloo, you there?
04:09:36 <Igloo> Yup
04:09:45 <JaffaCake> I'm none the wiser
04:10:04 <JaffaCake> this is sparc/Linux, right?  where did you get the build from?
04:10:15 <Igloo> Yup. It's the Debian package
04:10:29 <JaffaCake> ah right
04:11:01 <Igloo> Oh, there was one small change I had to make - allowing a tab before .section for sparc in the mangler, but that shouldn't cause the problem, right?
04:11:16 <JaffaCake> no, don't think so
04:12:04 <Igloo> Hmm, anything else I can do for you?
04:12:28 <JaffaCake> well, I really need to poke around to find out what's wrong
04:13:02 <Igloo> Hmm, Isaac has a sparc, so perhaps he will be able to let you have an account in a couple of weeks when he's back home
04:13:12 <JaffaCake> yeah, sounds like a plan
04:14:48 <JaffaCake> you could insert a few traces for me if you have the GHC build there...
04:17:07 <Igloo> I don't, but if you give me a patch I can build it
04:17:44 <shapr> betabot: @type Control.Monad.ST.runST
04:17:45 <JaffaCake> nah, don't worry I'll wait till Isaac gets back
04:17:45 <betabot> Control.Monad.ST.runST :: forall a. (forall s. GHC.ST.ST s a) -> a
04:17:49 <shapr> yay
04:18:00 <Igloo> OK
04:18:06 <Igloo> Sorry I couldn't be more help
04:18:10 <JaffaCake> shapr: cool :)
04:18:15 <shapr> :)
04:18:37 <shapr> lambdabot is a fun code toy
04:19:07 <shapr> betabot: @quit
04:19:50 <shapr> @dynamic-reload type
04:19:51 <lambdabot> module reloaded
04:20:03 <shapr> @type Control.Monad.ST.runST
04:20:05 <lambdabot> Control.Monad.ST.runST :: forall a. (forall s. GHC.ST.ST s a) -> a
04:21:10 <JaffaCake> @type GHC.IOBase.IO
04:21:12 <lambdabot> GHC.IOBase.IO :: forall a.
04:21:12 <lambdabot> 		 (GHC.Prim.State# GHC.Prim.RealWorld
04:21:12 <lambdabot> 		  -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
04:21:12 <lambdabot> 		 -> IO a
04:22:50 <shapr> now a haddock index plugin would be handy
04:23:29 <JaffaCake> haddock's interface files are pretty easy to read
04:24:13 <shapr> I wonder if the binary index comes with haskell-doc
04:25:57 <Igloo> Is /usr/share/doc/ghc6-doc/html/libraries/base/base.haddock.gz what you want?
04:26:02 <shapr> I think so
04:35:59 <shapr> I think I can call Main.readIface and pass the result to full_index in ppHtmlIndex
04:48:45 <shapr> hm, readIface shouldn't be in Main, makes it harder to reuse the code
04:48:57 * shapr resists the urge to refactor Haddock
04:49:36 <Philippa> I'd just like to get a working win32 build of it
04:49:50 <shapr> what's the prob?
04:50:16 <Philippa> a bunch of configure stuff that assumes a *nix-like environment. Don't have a perl interpreter it'll work with
04:53:11 <shapr> I didn't know haddock needs perl
04:53:16 <shapr> or is that GHC?
04:54:12 <Philippa> it's haddock's configure script
04:54:57 <shapr> oh
05:00:11 <Philippa> seems to be set up to work with a mingw system, in fairness, though ICBW
05:01:07 <JaffaCake> haddock needs cygwin to build on Windows, really
05:01:18 * JaffaCake is terribly lazy
05:02:07 <JaffaCake> but if you have cygwin, then './configure; make; make install' Just Works(TM)
05:07:12 <shapr> hey ibid, are you coming to EuroHaskell?
05:07:21 <ibid> unlikely
05:07:50 <shapr> ah, too bad
05:18:47 <ibid> probably would cost too much to get there on my own account, and the lack of scientific program would most likely make it impossible for me to get university money for the trip
05:19:11 <ibid> besides, hackfests have never appealed to me
05:25:44 <shapr> ok
06:17:27 <shapr> hi gintas 
06:22:24 <gintas> shapr: hello
07:06:06 * shapr beats zope with a stick
07:34:51 <ozone> shapr: when's EuroHaskell on?
07:35:24 <l^rchkrn> @wiki euroHaskell
07:35:24 <lambdabot> http://www.haskell.org/hawiki/euroHaskell
07:37:31 <ozone> ta
08:09:36 <Arnia> shapr: Be nice to Zope and it will be nice to us
08:12:38 <earthy> oooeeeh... the GHC entry for the HC&AR is *neat*
08:41:16 <Ozkariuz> A quick question: is there any predefined function in haskell that takes a string and converts all characters to lowerCase letters?
08:41:47 <Igloo> map toLower (in Char)
08:42:13 <Ozkariuz> thanks a bunch =)
08:45:06 <neologism> is there any converter from lisp to haskell ?
08:47:52 <neologism> or vica versa
08:48:36 <Igloo> I don't know of one. For Haskell to LISP you'd have to worry about strictness causing failure/nontermination too
08:48:54 <neologism> thats solvable I suppose
08:50:53 <neologism> I prefer reading haskell sources to lisp ones
08:50:58 <neologism> so I'd appreciate it
08:52:24 <Igloo> LISP to Haskell is tricky as LISP is untyped. I doubt the resulting code would be more readable than the LISP
08:52:48 <neologism> my problem is very specific
08:52:56 <neologism> I have some examples in lisp
08:53:01 <neologism> this is not about types
08:53:07 <neologism> or anything general
08:53:20 <neologism> in fact just numbers are concerned
08:59:13 <earthy> oh goody
08:59:22 <earthy> haskell.org seems to be unreachable for me.
08:59:49 <JaffaCake> looks like it might be down
08:59:56 <earthy> looks like it
09:00:04 <JaffaCake> ... again
09:00:11 <earthy> not fun
09:09:45 <shapr> what's up with that? network? hardware?
09:09:59 <shapr> ozone: you comin to EuroHaskell?
09:11:41 <shapr> hej Ozkariuz, l√§r dig Haskell f√∂r skola?
09:13:57 <Ozkariuz> japp
09:14:19 <shapr> which school?
09:14:29 <shapr> chalmers? kth? lulea?
09:14:37 <Ozkariuz> chalmers
09:14:51 <shapr> oh, are you coming to EuroHaskell i sommar?
09:15:17 <shapr> it's happening at chalmers, should be fun
09:15:45 <shapr> lots of chalmers people on #haskell.se
09:16:13 <Ozkariuz> Yeah sure :S I am the 1337 haskeller ;P
09:16:23 <Ozkariuz> na, i dont think so =) 
09:16:43 <Ozkariuz> are you  coming+
09:16:57 <shapr> yes, flying south from Lulea
09:17:07 <shapr> I live in Boden
09:17:08 <Ozkariuz> Cool =) 
09:17:34 <shapr> EuroHaskell will be a blast
09:18:19 <shapr> I'm bringing my enhjuhling
09:18:26 <Ozkariuz> lol
09:18:38 <shapr> did I spell that right?
09:19:06 <Ozkariuz> -h ;p
09:19:13 <shapr> which one?
09:19:22 <Ozkariuz> the 2nd
09:19:27 <shapr> ah, thanks
09:19:28 <Ozkariuz> i think
09:19:34 <Ozkariuz> =)
09:19:39 <shapr> I'm still learning swedish
09:19:54 <shapr> it's funky
09:20:08 <norpan> i used to ride enhjuling when i was young
09:20:22 <norpan> i once rode it 20 km
09:20:25 <shapr> norpan: cool! you can teach me some tricks then?
09:20:39 <shapr> first trick: how to stay on
09:20:45 <norpan> shapr: i won't be at eurohaskell unfortunately
09:20:50 <shapr> aww
09:20:57 <norpan> i'm in bulgaria at the time
09:20:59 <shapr> that's right you'll be in bulgaria
09:21:13 <shapr> vacation?
09:21:17 <norpan> yes
09:21:19 <shapr> family?
09:21:20 <norpan> with my wife
09:21:22 <shapr> ah, ok
09:21:30 <stepcut> morning!
09:21:41 <norpan> cul8r
09:21:42 <shapr> glad I didn't ask if you were going to pick up chicks :-)
09:21:45 <shapr> cya
09:21:55 <shapr> greetz stepcut, wassup?
09:22:29 <stepcut> not much
09:22:38 <shapr> any new code?
09:23:08 <stepcut> a bit, I am doing the unthinkable, and writing my own accounting software =O
09:23:59 <shapr> Ozkariuz: if you decide you want to learn more Haskell, we have all levels showing up at ‚Ç¨H
09:24:11 <shapr> stepcut: nifty, in haskell?
09:24:12 <stepcut> I might make a new number type for haskell for dealing with financial numbers
09:24:27 <stepcut> yeah, its haskelldb based (of course) 
09:24:36 <shapr> have you seen Fowler's analysis patterns?
09:24:43 <stepcut> no
09:24:51 <shapr> it has some financial patterns that might be handy
09:25:10 <stepcut> interesting..
09:25:29 <shapr> I like analysis patterns
09:26:12 <shapr> one pattern they give is to keep the units as part of the value, like Pseudonym's nifty physics code
09:26:19 <shapr> and unlike the ISS
09:26:25 <stepcut> heh
09:26:42 <stepcut> have you seen frink ?
09:26:49 <shapr> nah, what's that?
09:27:15 <stepcut> its a language for doing calculations with units
09:27:19 <stepcut> http://futureboy.homeip.net/frinkdocs/
09:27:27 <stepcut> nothing fancy
09:27:32 <shapr> oh, neat
09:27:37 <stepcut> but it contains lots of constants
09:28:26 <shapr> Pseudonym's code has a few
09:28:40 <stepcut> the sample calculations are a riot: http://futureboy.homeip.net/frinkdocs/index.html#SampleCalculations
09:28:41 <shapr> and autoconverts when possible
09:29:44 <stepcut> especially, "why is superman so lazy"
09:33:29 <shapr> yes, that one's great :-)
09:33:53 <shapr> I wonder if I could hack Pseudonym's code into a units plugin for lambdabot 
09:34:33 <JaffaCake> Isaac and I came up with a great idea for a Haskell T shirt last week
09:34:56 <JaffaCake> "Ask your physician if you need Haskell.... SIde effects: none"
09:35:20 <shapr> heh!
09:35:38 <shapr> oh, did you guys get HM t-shirts?
09:35:47 <andersca> boom
09:35:56 <andersca> I want a Monad t-shirt
09:35:59 <JaffaCake> yep, got one here
09:36:12 <mattam> i want an Arrow t-shirt
09:36:32 <mattam> so it'll be cryptic even for me ;)
09:36:46 <shapr> I want a Template Haskell t-shirt, but I'd probably have to sew it myself
09:36:48 <JaffaCake> that's geeky even for a geek T shirt :)
09:36:58 <stepcut> shapr: oh?
09:37:14 * stepcut has the png handing next to his desk
09:37:30 <shapr> you, wearing the shirt at compile time and all that
09:37:50 * shapr thinks that joke stretched a bit too thin
09:38:14 <mattam> hehe
09:39:27 <shapr> hej sond 
09:39:31 <sond> tja
09:40:25 <shapr> the TH logo is spiffy, I'd like to have it on a tshirt
09:40:55 <JaffaCake> where's the TH logo? don't think I've seen that
09:41:32 <shapr> http://www.haskell.org/th/
09:41:39 <shapr> http://www.haskell.org/th/th.png
09:41:54 <JaffaCake> hehe
09:42:18 <shapr> created by Igloo 
10:39:55 <Lunar^> earthy: You'll get the hOp contribution to HC&A by tomorrow
10:40:42 <stepcut> how is hOp going?
10:41:58 <Lunar^> stepcut: not progressing that much, I'm still trapped in real life
10:42:04 <Lunar^> stepcut: and sebc by his thesis
10:42:32 <stepcut> can I boot it on a real system via grub? Or does it only work under emulators at the moment...
10:42:56 <Lunar^> I want to make a new release soon, though I'm still not sure what would be the best way
10:43:42 <Lunar^> stepcut: the first released version was able to boot directly on sebc's PC, I don't know about mine
11:46:48 <jadrian> hello
11:49:16 <maihem> hello
12:02:38 <Matt-W> hey
12:05:29 <ibid> darcs/rules
13:35:48 <hashwolf> is it possible to define a set datatype (where each item occurs only once) in haskell?
13:41:30 <ibid> yes
13:51:08 <hashwolf> 10x that's all i wanted to know
13:51:14 <hashwolf> :)
13:51:57 <wagle> shapr: when the programatica people i'm pestering about the cvs server ask me who you are, what should i say?
13:54:55 <Matt-W> If I wanted to do a PhD in something Haskelly, are there good areas to look into?
13:56:02 <wagle> all of them
13:56:26 <Matt-W> all of them?
13:56:51 <ibid> whatever strikes your fancy (and meets the approval of your prof)
13:56:53 <ibid> :)
13:56:55 <wagle> sorry, flip . answer
13:57:02 <Matt-W> I guess so
13:57:25 <Matt-W> just need to decide where to go for and when to do it and start saving up
13:57:34 <Matt-W> and then try applying of course
13:59:04 <ibid> wagle: answer :: a -> b -> ??
14:01:34 <Matt-W> ibid: where ?? = Maybe IntelligableThing
14:03:06 <ibid> :)
14:07:26 <simon-> Prelude> qsort [] = []
14:07:26 <simon-> ERROR - Syntax error in input (unexpected `=')
14:07:45 <simon-> where am I going wrong?
14:07:51 <Cale> simon-: you can't put declarations into the interpreter.
14:07:59 <Cale> put them into a file, and load it.
14:08:01 <ibid> simon-: let qsort [] = []
14:08:04 <ibid> for ghci
14:08:16 <ibid> hugs doesn't allow even that
14:08:28 <Cale> or do that, but for multiline definitions, it will be mildly painful :)
14:08:33 <ibid> :)
14:08:52 <Cale> (as you'll end up merely shadowing the previous lines)
14:09:07 <ibid> i just input them in one line
14:09:21 <Cale> yeah, you have to
14:09:31 <shapr> wagle: Shae Erisson, maintainer of The Haskell Wiki and general troublemaker
14:09:38 <Cale> In general though, it's better to put declarations into a file, and then test them with ghci
14:09:52 <ibid> true
14:10:14 <ibid> at least for definitions that are not throwaway :)
14:10:18 <Cale> you also can't declare new datatypes in the interpreter :)
14:10:42 <ibid> yeah
14:17:40 <shapr> oy
14:18:47 <shapr> @type Graphics.Rendering.OpenGL.GL.BasicTypes.GLBoolean
14:18:48 <lambdabot> bzzt
14:18:54 <shapr> :-/
14:19:01 * Igloo splutters
14:19:12 <shapr> hi Igloo 
14:19:28 <Igloo> Evening, trouble
14:19:36 <shapr> I guess I should call ghci with various -package params
14:21:35 <shapr> @type Language.Haskell.THSyntax.Q
14:21:36 <lambdabot> Language.Haskell.THSyntax.Q :: forall a.
14:21:36 <lambdabot> 			       IO a -> Language.Haskell.THSyntax.Q a
14:21:37 <Igloo> Isn't is (a) a type not a constructor and (b) spelt with a lower case b?
14:21:49 <shapr> um
14:21:51 <shapr> could be
14:22:09 <shapr> @type Graphics.Rendering.OpenGL.GL.BasicTypes.GLboolean
14:22:11 <lambdabot> bzzt
14:22:32 <shapr> @type Graphics.Rendering.OpenGL.GL.BasicTypes.Capability
14:22:34 <lambdabot> bzzt
14:22:42 <Igloo> Hmm, ghci assuming 80 columns is probably a bit silly on IRC
14:23:19 <Igloo> @type Graphics.Rendering.OpenGL.GL.BasicTypes.Enabled
14:23:20 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes.Enabled :: Graphics.Rendering.OpenGL
14:23:20 <lambdabot> GL.BasicTypes.Capability
14:23:32 <shapr> aha!
14:23:51 * Igloo would suggest removing all line endings and then s/[ \t]+/ /g
14:23:56 <shapr> now I need to add spell checking :-)
14:24:01 <Igloo> :-)
14:24:31 <shapr> yah, the ghci and hier support were a fifteen minute hack today
14:25:49 <shapr> I didn't get around to removing the \t and other stuff
14:26:06 <Igloo> Well, it's not necessarily obviously the right thing to do. At the very list I'd feel duty-bound to request s/\t/        /g in my role on the committee for the abolition of tabs, though  :-)
14:26:18 <shapr> yah, I agree
14:26:21 <shapr> tabs suck
14:26:30 <Igloo> Hmmm, CAT. Could work.
14:26:41 <shapr> ?
14:26:44 <shapr> oh!
14:26:58 <skew> CAT?
14:26:58 <Igloo> ./nick TabPolice?  :-)
14:27:04 <shapr> haha!
14:27:09 <Igloo> Committee for the Abolition of Tabs
14:29:49 <shapr> what would go onto a TH tshirt?
14:29:56 <shapr> the logo is lovely
14:30:14 <shapr> but doesn't seem enough by itself
14:33:05 <Igloo> Hmm, there are too many restrictions for obvious things like a TH program that creates itself
14:34:37 * Igloo can't think of a small canonical meta program, or a canonical potentially large Haskell program to create, OTTOMH
14:34:45 <shapr> oh, what about something cute at compile-time like download/update/build GHC?
14:34:53 <shapr> hmm
14:35:11 <Igloo> Wouldn't look very interesting
14:35:35 <shapr> what would?
14:35:40 * Igloo realises if I think of something I probably won't be able to tell you until the IOHCC anyway  :-)
14:35:46 <shapr> haha!
14:37:15 <shapr> hi CrewdenX 
14:38:45 <CrewdenX> shapr: hi
14:38:50 <shapr> what's up?
14:39:39 * shapr is taking a break from work
14:47:12 <stepcut> yeah for breaks!
14:48:30 <skew> yay for code that works. I can wrap Dynamic and pass through Python now.
14:48:42 <skew> Ooh, I should write up that thing for the HC&AR
14:49:38 <SamB> skew: what have you got there?
14:52:07 <skew> SamB: writing an interface between Python and Haskll
14:52:38 <SamB> I gathered you were doing something of that nature
14:52:53 <skew> moving along smoothly now that I added a missing ampersand that had the code segfaulting for weeks!
14:54:29 <skew> SamB: I can call back and forth (with typeclass assistance on the marshalling), and both Python and Haskell objects can be wrapped in the other environment as properly garbage collected objects
14:55:32 <SamB> skew: what happens when you have a cycle crossing the boundary?
14:55:33 <skew> well, I havent tested the Python side of the garbage collection. Just about to do that, actually
14:55:40 <skew> SamB: you die!
14:56:09 <skew> I was worrying about that for a bit, but I figure if Python got along for years without collecting cyclic garbage this can too
14:56:46 <skew> Actually, with proper support from the Haskell garbage collector I might be able to pull it off
14:57:22 <SamB> skew: I doubt it. the only problem I can anticipate is for such cycles to go uncollected...
14:57:41 <SamB> that is, I doubt that it is fatal
14:58:04 <skew> Python objects implemented in C have a traverse method the garbage collector calls, and if I could somehow hook into the Hakell garbage collector to get a list of PyObjects a given wrapped Haskell object refers to
14:58:56 <skew> If I could do that, then the Python object could detect it had cyclic garbage on it's and, and then I could implement the "break the cycle" method to free the stablePtr into Haskell-land, letting the Haskell GC take care of it's bit
15:00:10 <SamB> I know all about the python side of things ;-)
15:00:34 <SamB> well, not all about, but I have played with it ;-)
15:40:17 <shapr> hi Alcides 
15:40:57 <Alcides> Hi shapr.
15:41:06 <Alcides> Do you know ski>
15:41:09 <Alcides> ski?
15:41:15 <shapr> somewhat
15:41:17 <shapr> why?
15:41:36 <Alcides> I only heard of this language through a conversation with him/her.
15:42:18 <shapr> ski taught me a lot about haskell when I was learning
15:42:32 <Alcides> From what I have been exposed to so far, I like the structure of the language.
15:42:53 <Alcides> I think he is a great guide and very patient.
15:42:59 <shapr> yes, I agree
15:43:37 <shapr> do you have any questions?
15:44:01 <Alcides> I was reading through "YAHT" and started thinking...
15:44:27 <Alcides> Are the function names like gotos in basic?
15:44:37 <Alcides> like instead of using goto 100
15:44:43 <Alcides> We use a name instead?
15:44:53 <shapr> in what way?
15:45:08 <Alcides> For instance...
15:45:16 * jadrian wonders what would be dijkstras answer :)
15:45:37 <Alcides> functionName arg1 arg 2 =
15:45:42 <Alcides>   blah blah blah
15:45:46 <Alcides> Would be like...
15:46:02 <Alcides> 10 GOTO 100
15:46:12 <Alcides> 100 blah blah blah
15:46:43 <shapr> well, how is that different from functions in any other language?
15:46:44 <Alcides> I was thinking this because of the loop issue.
15:47:15 <Alcides> like in...
15:47:21 <Alcides> 100 blah
15:47:28 <Alcides> 110 GOTO 100
15:48:03 <Alcides> I think I am still just stumped by the simplicity of the language.
15:48:42 <shapr> you could jump in and use it :-)
15:48:50 <shapr> that worked for me
15:49:14 <jadrian> if you think imperative, GOTOs give you Conditionals, Cycles, Procedures, Functions and more (and usually that "more" is the problem)
15:49:36 <shapr> like coroutines
15:49:42 <jadrian> but in a functional setting GOTOs won't give the power of functions
15:49:58 <shapr> right, they're not first class
15:50:00 <jadrian> they are not first order citizens ;)
15:50:04 <jadrian> yeap
15:50:37 <shapr> with haskell you can treat a function as a value
15:50:52 <Alcides> Indeed.
15:51:20 <shapr> then you can transform that function, or use it like a hammer to hit a row of nails, or whatever
15:51:32 <jadrian> do you know any specification language with semantics that allow for 1st order operators/functions?
15:52:09 <Alcides> Haskell?
15:52:24 <jadrian> hmm haskell is not really a specification language...
15:52:46 <jadrian> I was thinking Maude, CafeOBJ...
15:52:56 <Alcides> Nope.
15:52:56 <jadrian> (actually I only tried OBJ dialects...)
15:53:10 <Alcides> sheme
15:53:12 <Alcides> ?
15:53:32 <jadrian> nope I'm not talking about programming languages...
15:53:41 <Alcides> Interesting.
15:53:56 <jadrian> this are languages you use to specify datatypes/programs...
15:54:02 <Alcides> I'm not familiar with the concept of specefication languages.
15:54:06 <jadrian> prove properties about them etc
15:54:45 <shapr> don't you run into the halting problem once you pauu first order logic?
15:54:53 <shapr> er "pass"
15:55:00 <jadrian> yeap
15:55:10 <jadrian> but why do you meantion that?
15:55:25 <shapr> I know marvin-- is working on encoding Haskell into FOL
15:55:26 <jadrian> because of the "prove properties"?
15:55:30 <shapr> yes
15:55:56 <shapr> Alcides: have you tried to write code yet?
15:56:08 <jadrian> well the underlying logics of those systems are not first order
15:56:22 <Alcides> No, I was just being introduced to the [1,2,3,4] thing
15:56:26 <shapr> ah yes
15:56:31 <Alcides> 1:[2,3,4]
15:56:33 <Alcides> Etc.
15:56:36 <Alcides> And Guards.
15:56:42 <jadrian> OBJ languages use equational, TRS, and hidden algebras
15:56:57 <jadrian> (I don't think the last one is decidible)
15:57:02 <shapr> @eval map (\x -> x + 1) [1,2,3]
15:57:03 <lambdabot> [2, 3, 4]
15:57:12 <jadrian> (but I don't know much about hidden algebras/behavioural reasoning)
16:01:59 <anduril1> @eval [1..]
16:01:59 <lambdabot> (line 1, column 4):
16:01:59 <lambdabot> unexpected "."
16:01:59 <lambdabot> expecting simple term
16:02:22 <shapr> @eval enumFromTo 1 5
16:02:22 <lambdabot> [1, 2, 3, 4, 5]
16:02:39 <shapr> @get-definition enumFromTo
16:02:39 <lambdabot> enumFromTo = \\l h.take (h-l+1) $ iterate (\\x.x+1) l
16:02:51 <anduril1> does lambdabot only know a subset of Haskell?
16:02:58 <skew> lambdabot's @val doesn't actually do Haskell
16:03:08 <shapr> it's actually a lambda calculus interpreter
16:03:12 <anduril1> ah
16:03:25 <shapr> but it's surprisingly useful
16:03:30 <shapr> g'mornin skew 
16:03:41 <skew> hi shapr. good afternoon
16:07:16 <skew> how is that work from earlier going?
16:07:38 <shapr> energizer bunny
16:07:55 <skew> phi is approaching usability if you need it ;)
16:08:04 <shapr> :-)
16:08:32 <shapr> would be spiffy to apply QC to Zope
16:08:39 <shapr> bet I could find some bugs
16:08:39 <skew> the only big todo at the moment is marshalling exceptions back and forth
16:11:54 <skew> it's pretty simple
16:12:07 <skew> so hopefully not too many
16:12:51 <skew> oh, the other todo is making it nicer to make extension modules
16:13:18 <shapr> I was thinking of bugs in Zope
16:13:19 <skew> at the moment you need to make a tiny C file that calls hs_init and then the module init function exported from Haskell
16:13:45 <skew> I think there's probably some linker magic that could do it, but I need to read up on it
16:13:50 <skew> some of the __wrap stuff
16:15:14 <bluejay> I'm trying to define a MonadST class analogous to MonadIO. (liftST::ST s a->m a) However, my instance for (ST s) (liftST=id) complains that the "Inferred type is less polymorphic than expected". Any ideas? (Want me to copy the file and error to the paste page?)
16:16:01 <skew> what sort of exception shows as "unknown exception"?
16:16:45 <shapr> skew: is this a Zen riddle?
16:16:59 <shapr> some sort of Haskell Koan?
16:17:23 <skew> I'm trying to figure out how to catch ^C
16:17:58 <shapr> bluejay: over my head at the moment
16:18:00 <skew> one issues at the moment is that typeing ^C in the Python interpreter gives that "main thread gc'd" message and kills the whole thing
16:18:27 <shapr> bluejay: I can guess it has to do with some monomorphism somewhere, but I'm not sure
16:18:47 <skew> bluejay: the problem is that the left side type is ST s a and the right m a, I think
16:18:48 <shapr> skew: even so, you can run programs
16:21:13 <skew> shapr: indeed, as long as no exceptions meet the langauge boundary
16:21:36 <bluejay> skew: Do you think there's any way to define MonadST then?
16:21:46 <skew> bluejay: what does the class line look like?
16:22:14 <skew> something like class (Monad (m a)) => MonadST m?
16:22:29 <skew> that state type paramater on ST is pretty important
16:23:06 <bluejay> I've copied the whole file to the paste page so there won't be any confusion. But "class Monad m => MonadST m"
16:24:55 <skew> bluejay: that liftST as written in the class definition is polymorphic in s. id with a result type ST s must have that particular s
16:25:35 <bluejay> I'm trying using MonadST m s, and the ST instance worked...
16:30:41 <shapr> motherboard :: Computer#
16:38:55 <shapr> SamBv6?
16:41:22 <Pseudonym> Greetings.
16:41:52 <Pseudonym> Anyone like to have a go at a combinatorics problem?
16:41:59 <Pseudonym> I'm 99% sure I know the answer.
17:01:19 <skew> bluejay: how is the MonadST class going?
17:02:47 <skew> that's an even better example.
17:03:36 <skew> sorry, more confusion with channels here
17:05:46 <bluejay> skew: sorry, it works. I just needed to make the class line "class Monad m => MonadST m s"
17:05:53 <bluejay> skew: Thanks for the help
17:05:58 <skew> bluejay: have you written code with that?
17:07:20 <bluejay> skew: no, I'm getting the rest of my big program to compile before I switch liftST definitions.
17:08:06 <skew> I'm a bit worried about the universal quantification on runST not likeing the class constraint.
17:08:36 <skew> I don't think the typeclass system can derive something like forall s . MonstST m s, which runST would seem to need to know
17:10:15 <bluejay> I'll tell you whether it works. Will you be around for a while?
17:10:59 <skew> I'll be around a bit.
17:11:46 <skew> I'm working on some code of my own for a while before I work
17:21:12 <SamB> why is AvianWiki not linked from http://www.scannedinavian.org/ ?
17:25:23 <bluejay> skew: After changing the class to "class Monad m => MonadST m s | m->s", my larger program compiles. I'm not calling runST yet, so I don't know if that'll break it yet.
23:38:09 <Pseudonym> @arr
23:38:09 <lambdabot> Yeh scurvy dog...
23:47:04 <andersca> indeed
