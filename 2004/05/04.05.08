00:00:04 <Gahhh> 30000 works
00:00:13 <Gahhh> and gives a bigger number than 10000 does
00:00:52 <ski__> you could try dividing (ct2 - ct1) by cpuTimePrecision to get in seconds
00:00:59 <ski__> nice
00:01:33 <Gahhh> the difference is in picosecs
00:01:38 <ski__> which fib definition ? the naive, exponential one ?  or the recursive list ? or the accumulator one ?
00:01:48 <Gahhh> the one from the tutorial
00:01:54 <Gahhh> fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
00:02:06 <ski__> ok, the recursive list one
00:02:33 <ski__> (there is also a matrix one, IIRC)
00:04:30 <Gahhh> lol
00:04:39 <Gahhh> global expressions are optimized
00:04:46 <Gahhh> you have to do it locally
00:04:54 * ski__ was thinking so
00:07:05 <Gahhh> well, if your program does any IO, I suppose you could just pass that in
00:07:17 <Gahhh> I dont think it can optimize for that 
00:07:55 <ski__> that would be hard, yes :)
00:08:20 <Gahhh> for purely FP stuff, it still gives you a figure, but only once
00:09:07 <ski__> (if you don't reload. at least in hugs)
00:09:35 <ski__> also, you can run the program several times from the command line
00:09:49 <ski__> with both hugs and ghc
00:10:02 <ski__> (compiling with ghc, runhugs with hugs)
00:10:14 <Gahhh> yeah, but that would include the loading time of the program
00:10:18 <ski__> no
00:10:35 <ski__> not if you measure the time internally, as you've done above
00:10:37 <Gahhh> oh
00:11:21 <Gahhh> yeah that should do ok
00:11:40 <Gahhh> long live referential transparency
00:11:56 <ski__> right
00:12:06 <ski__> all hail eris
00:12:12 <ski__> ermm :)
00:12:22 <Gahhh> eris ?
00:12:35 <ski__> the greek goddess of disorder
00:12:50 <Gahhh> hah
00:12:58 <ski__> the romans called her discordia
00:13:07 <ski__> see http://www.ology.org/principia/
00:13:07 <Gahhh> lol
00:13:27 <ski__> hmm, shapr is not here
02:47:18 <hashwolf> whem there is something like data T1 = T2 :+: T3 what do the colons stand for/are called?
02:49:10 <ski__> 'colon', perchance ? :)
02:49:19 <bring> :+: is a data constructor
02:49:27 <ski__> (infix constructor must start with a colon)
02:49:49 <ski__> (infix non-constructor (i.e. like +) must *not* start with a colon)
02:49:59 <bring> but I doubt that the colon has a special name when used in a data constructor
02:50:17 <ski__> (AOL!)
02:52:48 <bring> aol?
02:53:40 <hashwolf> hmm, so i could declare something like label = T2 something + T3 something ?
02:54:13 <ski__> ("AOL!" means "me too !")
02:54:50 <ski__> hashwolf : not if you are defining a type
02:56:02 <hashwolf> ah ok the words INFIX CONSTUCTOR finally made it to the the few working braincells i have
02:56:06 <hashwolf> 10x :)
02:57:03 <ski__> np
03:03:08 <l^rchkrn> Heyas!
03:04:19 <ski__> hiya l^rchkrn
03:11:17 <shapr> good morning #haskell!
03:11:30 <[dan]> morning
03:11:56 <l^rchkrn> Sorry, botabuse:
03:12:00 <shapr> hi [dan], how's your head?
03:12:02 <l^rchkrn> @type (^)
03:12:04 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
03:12:07 <ski__> good morning shapr,[dan],l^rchkrn, others
03:12:10 <l^rchkrn> @type (**)
03:12:12 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
03:12:17 <ski__> lambdabot: good morning
03:12:17 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
03:12:19 <l^rchkrn> Morning!
03:12:41 <shapr> l^rchkrn: if  you're worried about  flooding, you can also use privmsg with lambdabot 
03:12:44 <ski__> @type (^^)
03:12:45 <lambdabot> (^^) :: forall a b. (Integral b, Fractional a) => a -> b -> a
03:12:54 <shapr> @type (())
03:12:56 <lambdabot> (()) :: ()
03:13:09 <l^rchkrn> !morning $1 is <action>(N9|Heyas|Hola|Bom dias|Bona nox) $1!
03:13:11 <[dan]> shapr: definitely less than fully understanding
03:13:25 <shapr> [dan]: any questions?
03:13:39 <l^rchkrn> shapr: O I C. Okay...
03:13:39 <shapr> l^rchkrn: that would be an easy plugin to write...
03:14:25 <l^rchkrn> shapr: It works with blootbot.
03:14:28 <l^rchkrn> =>
03:14:38 <l^rchkrn> But Lambdabot is cooler.
03:14:43 <[dan]> shapr: nothing that's at question-stage yet. Mostly trying to wrap my head around the syntax and understand what things are really doing.
03:15:23 <l^rchkrn> ski__: So what is (^^)? The hyper4 operator?
03:16:02 <ski__> YA power operator, IIRC
03:16:09 * shapr has a sudden idea for extending @type
03:16:43 <ski__> @eval map (\x -> map (\y -> (x,y,x^^y)) [0..3]) [0..3]
03:16:44 <lambdabot> (line 1, column 25):
03:16:44 <lambdabot> unexpected ","
03:16:44 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character
03:16:44 <lambdabot>  "[", string, "(", operator, simple term or ")"
03:16:47 <ski__> hmm
03:16:53 * ski__ forgot that
03:17:39 <l^rchkrn> hyper4 is not power, but 
03:17:42 <ski__> Time> mapM_ print $ ....
03:17:50 <ski__> [(0.0,0,1.0),(0.0,1,0.0),(0.0,2,0.0),(0.0,3,0.0)]
03:17:50 <ski__> [(1.0,0,1.0),(1.0,1,1.0),(1.0,2,1.0),(1.0,3,1.0)]
03:17:50 <ski__> [(2.0,0,1.0),(2.0,1,2.0),(2.0,2,4.0),(2.0,3,8.0)]
03:17:50 <ski__> [(3.0,0,1.0),(3.0,1,3.0),(3.0,2,9.0),(3.0,3,27.0)]
03:17:50 <l^rchkrn> hyper4 a 1 = 1
03:18:09 <l^rchkrn> hyper4 a b = a ^ (hyper4 a (b-1))
03:18:42 <ski__> Time> mapM_ print $ map (\x -> map (\y -> (x,y,x^^y)) [2..6]) [2..6]
03:18:42 <ski__> [(2.0,2,4.0),(2.0,3,8.0),(2.0,4,16.0),(2.0,5,32.0),(2.0,6,64.0)]
03:18:42 <ski__> [(3.0,2,9.0),(3.0,3,27.0),(3.0,4,81.0),(3.0,5,243.0),(3.0,6,729.0)]
03:18:42 <ski__> [(4.0,2,16.0),(4.0,3,64.0),(4.0,4,256.0),(4.0,5,1024.0),(4.0,6,4096.0)]
03:18:42 <ski__> [(5.0,2,25.0),(5.0,3,125.0),(5.0,4,625.0),(5.0,5,3125.0),(5.0,6,15625.0)]
03:18:43 <ski__> [(6.0,2,36.0),(6.0,3,216.0),(6.0,4,1296.0),(6.0,5,7776.0),(6.0,6,46656.0)]
03:18:50 <l^rchkrn> =-?
03:19:14 * ski__ thinks it looks like power
03:20:03 <neologism> ski__: I think its a^a^a....^a b-times
03:20:20 <ski__> neologism : hyper4, you mean ?
03:20:29 <neologism> yes
03:20:38 * ski__ was talking about (^^)
03:21:08 <neologism> soryr, I am mistaken ;)
03:21:50 <l^rchkrn> =-?
03:21:58 <l^rchkrn> hyper4 is usually written as ^^
03:22:22 <l^rchkrn> so what is ^^ in Haskell then? a third variant of **?
03:22:23 <ski__> but haskell's ^^ seems not to be hyper4
03:22:34 <shapr> betabot: @info Show
03:22:35 <betabot> -- Show is a class
03:22:35 <betabot> class Show a where {
03:22:35 <betabot>     showsPrec :: Int -> a -> String -> String {- has default method -};
03:22:35 <betabot>     show :: a -> String {- has default method -};
03:22:35 <betabot>     showList :: [a] -> String -> String {- has default method -};
03:22:37 <betabot>     }
03:22:43 <ski__> seems it's yet another power operator, yes
03:22:52 <l^rchkrn> ski__: Ok.
03:22:52 <ski__> shapr : cool !
03:22:56 <l^rchkrn> %will try it.
03:23:01 <shapr> yah, it's nifty
03:23:09 <shapr> I wonder what else that could do
03:23:16 <ski__> what ?
03:23:26 <shapr> as in, what other :? commands
03:23:33 <ski__> hm
03:23:46 <shapr> :browse seems floody
03:23:53 <shapr> but handy at times
03:24:01 <ski__> perhaps allow it in privmsgs ?
03:24:14 <shapr> that would work
03:24:29 <ski__> or, reply in privmsg, when asked publicly (perhaps with a public note)
03:24:31 <shapr> would need some way to limit to privmsg though
03:25:12 <ski__> one could use some kind of @more, i guess, too
03:25:35 <ski__> (does that currently work at all ?)
03:26:41 <shapr> @more works, yes
03:26:41 <betabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
03:26:41 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
03:26:52 * ski__ smiles
03:26:54 <shapr> er, I thought it did
03:28:27 <ski__> @eval greet
03:28:27 <betabot> Sorry, I don't know the command "eval", try "lambdabot: @listcommands"
03:28:28 <lambdabot> @hello
03:28:28 <betabot> Hello world. 
03:28:48 <ski__> (they talk to eachother ! :)
03:28:59 * shapr grins
03:29:57 * l^rchkrn notes: on #debian, its possible to get apt and dpkg talking to each other, and they totally flood the channel.
03:30:18 <ski__> shapr : :find would be nice, too, but that seems hugs-only ..
03:30:29 <shapr> what does it do?
03:30:56 <shapr> oh, that's name to module lookup
03:31:04 <shapr> sure, I'm working on that one
03:31:06 <ski__> hmm
03:31:07 <ski__> sorry
03:31:11 <ski__> i meant
03:31:14 <ski__> :names [pat]        list names currently in scope
03:31:30 <ski__> :find opens the editor on the line defining something
03:34:19 * ski__ would like @prelude to work again ..
03:36:32 <ski__> (more speculative : would be cool if lambdabot would read a module from say, hawiki, and then one can query it)
03:42:58 <shapr> that sounds scary
03:43:06 <shapr> but I can fix @prelude
03:43:14 <ski__> shapr : @info doesn't work for types, it seems
03:43:26 <ski__> @info Maybe
03:43:28 <betabot> bzzt
03:43:29 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
03:44:38 <shapr> oh
03:47:54 <ski__> hmm
03:48:07 <ski__> why it says like this (GHCi does too) ?
03:48:16 <ski__> betabot: @info seq
03:48:17 <betabot> -- seq is a variable
03:48:17 <betabot> infixr 0 `seq`
03:48:17 <betabot> seq :: forall a b :: ?. a -> b -> b
03:48:26 <ski__> why the '?' ?
03:48:49 * shapr isn't sure
03:49:24 <ski__> (maybe it means it works for unboxed, too, hmm. but unboxed are always strict, i think ..)
03:49:37 <shapr> shows up in emacs and terminal ghci
03:49:44 <ski__> (s/strict/unpointed/)
03:49:48 <ski__> right
03:51:07 <shapr> betabot: @dynamic-reload type
03:51:08 <betabot> module reloaded
03:51:15 <shapr> @info Maybe
03:51:16 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
03:51:16 <betabot> -- Maybe is a type constructor
03:51:16 <betabot> data Maybe a = Nothing | Just a
03:51:20 <ski__> ah
03:52:01 <shapr> @info (>>=)
03:52:01 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
03:52:02 <betabot> -- >>= is a method in class Monad
03:52:02 <betabot> infixl 1 >>=
03:52:02 <betabot> (>>=) :: forall m :: (* -> *). (Monad m) =>
03:52:02 <betabot> 	 forall a b. m a -> (a -> m b) -> m b
03:52:29 <ski__> there it says (* -> *). no surprise
03:55:46 <Lunar^> Whose betabot is it ?
03:56:09 <Lunar^> These explicit kinds are a bit scary... IMHO
03:56:43 <ski__> it seems to be GHC(i) decision to show the explicit foralls
03:57:08 <Lunar^> @info Maybe
03:57:08 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
03:57:08 <betabot> -- Maybe is a type constructor
03:57:08 <betabot> data Maybe a = Nothing | Just a
03:57:22 <ski__> betabot: @info Int
03:57:22 <betabot> -- Int is a type constructor
03:57:22 <betabot> data Int = GHC.Base.I# GHC.Prim.Int#
03:58:55 <shapr> neat, it has its own box
04:00:15 <ski__> ?
04:01:05 <shapr> seems that I# makes a box around an unboxed Int#
04:01:40 <shapr> Lunar^: it's my betabot, I just test stuff locally first
04:01:56 <ski__> hmm, um that's true, i guess
04:07:17 <ski__> shapr : hmm, btw, how does lambdabot escape errors in @type ?
04:14:14 <shapr> oh, it uses a regex
04:14:28 <ski__> aha
05:33:25 <shapr> jiihaa
05:33:31 * shapr bounces
05:35:16 <shapr> juhp: what's up with MozEmbed?
05:37:36 <shapr> does anyone know where the nomaware tutorial went to?
05:39:06 <ski__> it seems to have disappeared, yes :(
05:52:23 <shapr> I rather like Stefan Karrmann's Tai.lhs
05:54:40 <ski__> where ?
05:56:39 <shapr> http://www.mail-archive.com/haskell@haskell.org/msg13757.html
05:57:03 <ski__> ty
05:58:14 <shapr> I can't seem to apply the patch though
06:03:43 <shapr> ski__: are you able to apply the patch from the next mail?
06:15:20 <ski__> shapr : i haven't even dowloaded it.. reading the list ...
06:16:09 <shapr> ok
06:17:07 <ski__> (can't even find the original post. where is the org Tai.lhs ?)
06:18:49 <shapr> it's attached to the url I pasted, I think
06:19:56 <ski__> hmm, sorry, somehow thought that was just a patch
06:20:14 <shapr> there's a patch in the next mail
06:20:17 <ski__> right
06:35:35 <ski__> hmm
06:35:36 <ski__> "But I don't _want_ functional programming!"
06:35:36 <ski__> -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
06:35:44 * shapr grins
06:35:48 <ski__> are they FP-like ?
06:35:59 <shapr> I guess she thinks they are
06:36:04 * ski__ has never played go
06:36:22 <shapr> it's easy to learn
06:36:33 <shapr> it has about ten rules
06:39:14 <tic> shapr, hey, 'sup? I had lunch with Gammie yesterday :)
06:41:11 <shapr> cool!
06:41:30 <shapr> he sounds like a nifty guy from the emails we've swapped
06:41:40 <tic> he sure is. :)
06:42:05 <shapr> I wonder if he's going to continue with PLog
06:42:16 <ski__> what's that ?
06:43:26 <shapr> hmm, I wonder where it went
06:44:20 <shapr> hi splinux 
06:45:23 <shapr> bye splinux
06:45:38 <shapr> ski__: it's a weblog system written in Haskell
06:45:42 <ski__> hi-bye splinux
06:45:44 <shapr> it's nifty
06:45:49 <ski__> ok
07:28:00 * ski__ updated wiki
07:48:15 * shapr boings
07:48:39 <shapr> ok, I can show HaddockTypes.Interface now
08:00:13 <ski__> bye #haskell
08:02:04 <shapr> bye
08:42:01 * shapr refactors HaddockHtml
08:42:40 <liiwi> break! coffee and ice cream for everyone
08:47:53 <shapr> liiwi: yay!
08:48:11 <bring> mmm, ice cream
08:48:45 <shapr> cool, I have FiniteMap String (FiniteMap HsQName [(t, Bool)])
08:49:25 <shapr> *Main> lookupFM findx "scanr"
08:49:25 <shapr> Just [(GHC.List.scanr,[(Data.List,True),(GHC.List,True),(Prelude,True)])]
08:50:46 <shapr> so, how should this work?
08:51:21 <shapr> return a list of module names?
08:51:52 <shapr> maybe take an offset param to show the type sig of that definition?
09:05:39 * shapr boings cheerfully
10:00:38 <shapr> hej Marvin-- 
10:01:11 <Marvin--> hejhej
10:01:45 <andersca> http://www.tradera.com/auction/aid_5999797 ojoj
10:01:46 <andersca> doh
10:01:47 <andersca> sorry :)
10:06:32 <shapr> man, lambdabot needs some spring cleaning
10:06:44 <shapr> the state accessors really suck
10:07:39 <shapr> I can authoritatively say that because I wrote them.
10:58:50 <shapr> wheee
11:03:13 <maihem> unicycling?
11:16:32 <ksandstr> hey, just a quick question -- does ghc 6.2.1 know to strength-reduce an expression like (a - x0) ** 2 to let foo = (a - x0) in foo*foo ?
11:17:06 <ksandstr> all variables are Floats. just wondering if I should trade efficiency for aesthetics :)
11:25:14 <Igloo> a-x0 will only be evaluated once if that's what you mean
11:25:32 <Igloo> And if you really use (**) I imagine it's strict in both arguments
11:27:39 <maihem> I think he means does it use (a - x0) * (a - x0) instead of (a - x0) ** 2, of course, it prolly does since it is the obvious definition of (**)
11:27:54 <maihem> I love haskell
11:28:43 <Igloo> If you want x*x then you want x^2, not x**2, but then it's not strict in the first argument as x^0 = 1
11:46:30 <shapr> oh, I like this hafnium battery idea
11:47:00 <Igloo> ?
11:47:03 <l^rchkrn> shapr: Hafnium battery?
11:47:09 <shapr> "In hafnium, however, the excited state of the neutrons is metastable -- which is just a fancy way of saying they stay excited for a long time between when they're excited and when they release photons. If a way could be developed to induce the grounding, then hafnium could be used to store large amounts of energy in the metastable state, and then induced to release it all at once, resulting in much larger discharges than ordin
11:47:09 <shapr> ary chemical reactions can store/release."
11:47:12 <l^rchkrn> Hafnium is instable nope?
11:47:22 <shapr> from slashdot no less
11:47:23 <shapr> shocking
11:48:03 <Igloo> "all at once" doesn't sound too good  :-)
11:48:11 <l^rchkrn> :-\
11:48:16 <Igloo> I guess you could have lots of cells and capacitors or something if it really does mean that
11:48:29 <l^rchkrn> And Hafnium also way too expensive :-\
11:48:32 <shapr> I've been trying to think of a step between chemical and nuclear energy storage
11:49:33 <shapr> it depends on the energy it can hold and whether you can control the release speed/amount
11:50:06 <shapr> I hadn't thought of using metastable isotopes
11:50:11 <shapr> this is nifty
11:50:53 <l^rchkrn> No sorry, Hf _is_ stable.
11:51:42 <shapr> well, whether Hf itself does this, using metastable states to store energy is a new idea
11:51:44 <l^rchkrn> Electronnegativity 1.3 :-)
11:52:04 <SamB> I wonder why GHCi is calling all the unboxed types in GHC.Base {- abstract -} -- they seem pretty concrete to me!
11:52:04 <l^rchkrn> Yes.
11:52:29 <shapr> SamB: like what?
11:53:57 <shapr> lambdabot: @dynamic-reload type
11:53:57 <lambdabot> module reloaded
11:54:05 <shapr> @info Int#
11:54:19 * shapr wonders
11:54:37 <shapr> @hello
11:54:38 <lambdabot> Hello world. 
11:54:43 <shapr> @info Int
11:54:45 <lambdabot> -- Int is a type constructor
11:54:45 <lambdabot> data Int = GHC.Base.I# GHC.Prim.Int#
11:55:06 <shapr> @info GHC.Prim.Int#
11:55:25 <shapr> I don't think he likes that hash mark
11:57:12 <SamB> @browse GHC.Base
11:57:12 <lambdabot> Sorry, I don't know the command "browse", try "lambdabot: @listcommands
11:57:44 <shapr> not yet :-)
11:57:57 <SamB> well, it would flood anyway...
11:57:58 <shapr> I'm doing the haddock index right now
11:58:25 <shapr> yah, I haven't thought of a good way to deal with a :browse flood
11:58:45 <shapr> any ideas?
11:58:59 <shapr> ski suggested make it respond privmsg only
11:59:55 <SamB> well, there is privmsg, and also you could have some kind of pattern-matching (grep?) and allow shortish sets to be sent to the channel
12:04:08 <SamB> naesten@hydrogen:~/homework/haskell% echo :browse GHC.Base | ghci | grep '{- abstract -}'|more     
12:04:08 <SamB> data Addr# {- abstract -}
12:04:08 <SamB> data Array# a {- abstract -}
12:04:08 <SamB> data ByteArray# {- abstract -}
12:04:08 <SamB> data Char# {- abstract -}
12:04:08 <SamB> data Double# {- abstract -}
12:04:10 <SamB> data Float# {- abstract -}
12:04:12 <SamB> data (->) a b {- abstract -}
12:04:14 <SamB> data Int# {- abstract -}
12:04:16 <SamB> data Int32# {- abstract -}
12:04:20 <SamB> data Int64# {- abstract -}
12:04:22 <SamB> data ForeignObj# {- abstract -}
12:04:24 <SamB> data Weak# a {- abstract -}
12:04:26 <SamB> data MutableArray# a b {- abstract -}
12:04:28 <SamB> data MutableByteArray# a {- abstract -}
12:04:30 <SamB> data MVar# a b {- abstract -}
12:04:32 <SamB> data StablePtr# a {- abstract -}
12:04:40 <SamB> data State# a {- abstract -}
12:04:42 <SamB> data StableName# a {- abstract -}
12:04:44 <SamB> data MutVar# a b {- abstract -}
12:04:46 <SamB> data Word# {- abstract -}
12:04:48 <SamB> data Word32# {- abstract -}
12:04:52 <SamB> data Word64# {- abstract -}
12:04:54 <SamB> --More--
12:05:36 <SamB> hmm, perhaps that was overkill. there are two more lines ;-)
12:12:46 <ksandstr> Igloo: thank you. just goes to show how much I need to RTFM still :)
12:21:30 <SamB> shapr: when do you sleep?
12:22:06 <Cale> where did nomaware.com/monads move to?
12:30:08 <Cale> that was my favourite monad tutorial to show people
12:30:44 <shapr> SamB: I did that last year
12:31:09 <shapr> Cale: I dunno, if someone can find a copy I'll host it
12:32:50 <SamB> Cale: well, if you can discover the IP that nomaware.com used to have, you will probably be able to find it.
12:33:05 <SamB> well, possibly, anyway.
12:38:46 <shapr> http://www.lifl.fr/~boulet/formation/CALP/man/monads/html/
12:38:49 <shapr> hiya flippo 
12:39:02 <flippo> shapr: what a surprise to see you here :)
12:39:19 * shapr is surprised too
12:39:39 <flippo> It's time to exercise a different part of my brain
12:40:13 <shapr> cool! which part?
12:40:38 <flippo> Been working on optimization of numerical code.  I don't want to use that part any more today
12:40:54 <flippo> A little expensive abstraction is in order
12:41:52 <flippo> Just realized I had forgotten about that Conceptual Mathematics book for a while.
12:41:59 <flippo> The bookmark is on page 70.
12:42:22 <SamB> expensive abstraction? like what?
12:42:24 <shapr> I got distracted into doing other stuff too
12:42:33 <shapr> I haven't finished that book
12:42:49 <flippo> Any abstraction at all will do, SamB.  I've been indexing arrays of floats all day
12:43:14 <flippo> shapr: honestly, I wasn't learning much of use
12:43:31 <SamB> what sort of arrays? boring 1d arrays?
12:43:56 <flippo> SamB: 1d and 2d.  Some of the 1d arrays were in a map.
12:44:10 <flippo> I had to replace the map by another array, to speed it up
12:44:35 <flippo> But let's not dwell on the recent past.  What's fun in the world of Haskell these days?
12:44:56 <flippo> Any improved interactive interpreters?
12:45:39 <shapr> not that I know of, GHCi is still the best
12:45:59 <flippo> so you still import often
12:46:07 <shapr> ?
12:46:28 <flippo> You write code in a file, and load it to use
12:46:48 <shapr> just now I did 'mlist <- getIfaces "base.haddock"' in ghci
12:47:11 <shapr> and then 'let findx = full_index mlist'
12:47:46 <shapr> and then ':m + Data.FiniteMap' and 'lookupFM findx "scanr"'
12:48:16 <flippo> Oh, I was using hugs.  This sounds better
12:48:32 <shapr> I still have to derive some typeable instances, but this plugin nearly works
12:49:58 <flippo> ghci is not the same as ghc5 ?
12:50:24 <flippo> (oh interactive versus compiler)
12:50:28 <shapr> oh, ghc6.2.1 is out
12:51:02 <shapr> ghci is nice
12:51:22 <SamB> yes, ghci is quite nice
12:51:27 <flippo> I've learned something useful already
12:51:43 <SamB> it's :i may leave something to be desired, though.
12:53:26 <shapr> what should it do?
12:53:40 <shapr> @info Typeable
12:53:54 <shapr> @info Data.Typeable.Typeable
12:53:56 <lambdabot> -- Data.Typeable.Typeable is a class
12:53:56 <lambdabot> class Data.Typeable.Typeable a where {
12:53:56 <lambdabot>     Data.Typeable.typeOf :: a -> Data.Typeable.TypeRep; }
12:54:23 <shapr> hi [dan] 
12:54:35 <[dan]> hi :)
12:55:34 <flippo> is ghci bundled with ghc?
12:56:22 <shapr> yup
12:57:50 <shapr> Erik Meiler is vicious to Guido van Rossum - http://blogs.gotdotnet.com/emeijer/PermaLink.aspx/eb37226d-25d9-4a3c-bfe8-f26a1137ebc6
12:57:54 * shapr laughs
12:58:57 <flippo> That's pretty embarrassing stuff.
12:59:16 <Maddas> haha
12:59:22 <shapr> yah, it is
12:59:42 <shapr> maybe it was just a brainfart day, I have those too
12:59:58 <flippo> "I have no doubt that the human brain has special reasoning abilities for loops"
13:00:09 <flippo> That was quite a fart there
13:00:09 <shapr> well
13:00:12 <shapr> yes
13:00:54 <flippo> He goes into detail on this opinion.  It wasn't just a throwaway line
13:01:46 <flippo> Funny, he says haskell list comprehensions resemble those of python.  Wonder how that happened?
13:02:14 <CrewdenX> "I'd say that a loop is a higher-level concept than recursion; recursion is more powerful, but also more low-level, like assembly language."    isn't that kind of backwards?
13:02:28 <Maddas> I was about to paste that :-)
13:02:37 <flippo> me too :)
13:03:30 <flippo> Let's see, a loop has a jump in it.
13:03:45 <shapr> I do run up against the recursion depth limit a bit too often in Python
13:03:58 <Maddas> The other turing award thing is very, uh, silly too
13:04:00 <Maddas> (At least at times)
13:04:02 <flippo> shapr: I found a nice hack to overcome that limit though :)
13:04:06 <CrewdenX> assuming there is something here i'm not understandig, he sure choose a bad metaphor.
13:04:08 <shapr> oh tell me!
13:04:19 <Maddas> shapr: I still don't understand why people would want to use a language without tail-call optimisation :-)
13:04:25 <shapr> nor do I
13:04:50 <shapr> but then, I want continuations, coroutines, and more too
13:05:01 <shapr> that's why I skipped out of Python and into Haskell
13:05:08 * Maddas nods
13:05:22 <flippo> shapr: Here you go: http://billharlan.com/pub/papers/Python_notes.html
13:05:35 <flippo> shapr: it's kinda cute
13:05:46 <shapr> the pure side effecst bother me most, [].sort() for example
13:06:33 <flippo> yes, those are exasperating.  They don't have an if expression either
13:06:34 <shapr> and I know about the xoltar toolkit, and the other workarounds, I just wish they were in standard python
13:06:45 <shapr> yes, no if expression
13:07:09 <flippo> Every language should have an if expression, even if it is called a "ternary"
13:07:43 <SamB> Maddas: it has all kinds of other nice things, and nobody wants to go and figure out how to implement it!
13:07:48 <shapr> that's a scary hack
13:08:03 <flippo> shapr: indeed.  It's very unnatural.
13:08:15 <Maddas> SamB: What has all kinds of other nice things?
13:08:26 <Maddas> Oh, ok.
13:08:43 <Maddas> I'd just think that people would be more eager to implement it, I guess 
13:08:58 <shapr> to implement what?
13:09:15 <SamB> well, maybe they would be eager before they tried to figure out how to do it ;-)
13:09:21 <Maddas> Tail-call optimisation
13:09:23 <shapr> oh
13:09:25 <Maddas> Heh.
13:09:59 <SamB> oh, and then there are the tracebacks.
13:10:26 <flippo> Early python had pretty awful scoping rules too.
13:10:44 <flippo> (Like javascript today.  Gag.)
13:12:11 <flippo> Guido has a 70's blowdry hairdo.
13:13:36 <chucky> is that a good or a bad thing concerning Python? (the hairdo i mean)
13:13:38 <chucky> :)
13:13:51 <flippo> It's impressive.  Those are high-maintenance
13:14:38 <chucky> so he has less time left for improving the language? ;)
13:14:51 <flippo> I suppose I could insinuate that.
13:15:14 <Maddas> haha
13:16:01 <SamB> what does *he* need to improve the language for?
13:16:10 <flippo> He mentions a $() construct.  I haven't seen that before
13:17:27 <chucky> flippo: It's part of Template Haskell
13:17:54 <flippo> I'm afraid to ask
13:18:04 <flippo> I hope it's not a preprocessor
13:18:30 <chucky> see http://www.haskell.org/th/
13:18:53 <chucky> I haven't had more than a cursory look at it, so I don't really know much about it
13:18:59 <vegai> I never use the "normal" loop constructs when I write python =)
13:19:24 <shapr> yay, it typechecks
13:19:27 <vegai> or if I do, I later replace them with something
13:19:37 <Maddas> Scheme's DO doesn't seem to be too popular either.
13:19:46 <flippo> Guido thinks you have an unnatural mind
13:19:52 <SamB> hmm. I wonder what guido thinks map and list comprehensions are if not looping constructs?
13:19:55 <shapr> he's probably right
13:20:02 <shapr> programming is unnatural
13:20:54 <vegai> not unlike... mathematics?
13:20:55 <flippo> abstraction seems to be unnatural for many
13:20:57 * vegai runs away.
13:21:06 <shapr> math is unnatural too
13:21:14 <shapr> we're not designed to think
13:21:30 <Maddas> Yes, stop it already!
13:21:36 <Maddas> :-)
13:21:39 * shapr grins
13:21:40 <SamB> sometimes I do want to write a loop that seems like it would be easier to write in an imperative style...
13:21:50 <shapr> SamB: like what?
13:22:00 <flippo> Here we go
13:22:22 <flippo> This discussion has been lacking representation on both sides
13:22:37 <vegai> to which imperatists say "there, I told you" and functionalists "that means you haven't thought the problem really"
13:22:38 <shapr> I'd like to do this functionally: if getattr(p,lang,None): pdict.update({lang:{lang:dictProjectLang(getattr(p,lang))}})
13:22:52 <shapr> using fromMaybe for example
13:23:17 <shapr> then I wouldn't need to run the getattr twice
13:23:17 <flippo> vegai: you've already abstracted the problem.  How unnatural
13:23:34 * shapr grins
13:23:52 <vegai> caught in the act
13:24:01 <shapr> of course, I could just stick that first getattr into a var and check that
13:24:18 <flippo> ooh, variables, how unfunctional
13:24:19 <shapr> but that feels like I have to go out of my way to do that
13:25:30 <SamB> flippo: they are called variables even in haskell, silly!
13:26:00 <flippo> guilty
13:30:12 <shapr> oy
13:30:46 <shapr> flippo: have a particular goal in mind?
13:31:59 <flippo> shapr: no, just idle curiousity
13:32:06 <Marvin--> woohoo! From Dusk till Dawn on tv
13:32:28 <shapr> swedish summer is a bad time to show that
13:32:44 <shapr> it's better during winter when it's always dark
13:33:16 <Marvin--> :)
13:33:22 <Marvin--> it's dark enough now
13:33:25 <Marvin--> down here anyway
13:33:26 <flippo> That's an entertaining piece of trash
13:33:35 <Marvin--> yes :)
13:34:42 <shapr> hm, does liftIO coerce to (Monad,MonadState IRCRWState,MonadError IRCError,MonadIO) ?
13:35:14 <shapr> oh, I should move this to after lambdabot connection maybe
13:37:22 <shapr> there's a large percentage of swedish artists on magnatune.com
13:37:31 <shapr> and they're *good* too
13:39:51 <shapr> how do I pass an IO foo into "IRC.moduleInit :: m -> IRC.LB ()" when it wants a pure foo?
13:40:28 <shapr> liftIO didn't cut it even though LB is "newtype LB a = LB { runLB :: IRCErrorT (StateT IRCRWState IO) a }"
13:40:59 <shapr> Marvin--: any advice on this one? you're Mr Transformer :-)
13:42:44 <Marvin--> shapr: you have to instantiate MonadIO in able to use liftIO
13:42:56 <Marvin--> er, modulo word order and some missing words
13:43:27 <shapr> LB derives MonadIO
13:43:34 <shapr> hm
13:43:38 * Marvin-- is tired
13:43:46 <Marvin--> I'm pretty sure it's not derivable :)
13:44:08 <shapr> seems to compile
13:44:38 * shapr shrugs
13:45:25 <Marvin--> whoa
13:45:27 <Marvin--> that's funky
13:46:07 <Marvin--> you can even derive Monad??
13:46:18 <shapr> deriving (Monad,MonadState IRCRWState,MonadError IRCError,MonadIO)
13:46:28 * Marvin-- is officially scared
13:46:35 <shapr> and IRCRWState is even user defined
13:46:47 <Marvin--> I guess that's because it's a newtype rather than a data
13:46:58 <Marvin--> cute
13:47:12 <Marvin--> very cute
13:48:09 <shapr> so, 'makeInitialState "haddock" $ liftIO (IO foo)' should work, right? even though it want a pure foo?
13:48:28 <Marvin--> IO foo??
13:48:46 <Marvin--> liftIO :: forall m a. (MonadIO m) => IO a -> m a
13:49:01 <Marvin--> for example, you can do  liftIO (putStrLn "foo")
13:49:08 <shapr> oh, type does hierlibs now
13:49:56 <shapr> @type Control.Monad.liftIO
13:49:58 <lambdabot> bzzt
13:51:06 <shapr> @type Control.Monad.Trans.liftIO
13:51:08 <lambdabot> Control.Monad.Trans.liftIO :: forall m a.
13:51:08 <lambdabot> 			      (Control.Monad.Trans.MonadIO m) =>
13:51:08 <lambdabot> 			      IO a -> m a
13:56:16 <shapr> aha
14:01:20 <Marvin--> god I love this movie
14:02:59 <chucky> he he
14:11:56 <Marvin--> splat!
14:14:04 <[dan]> what functional programming/haskell books are recommended for learning the language?
14:15:40 <shapr> there are several mentioned on the learning Haskell page
14:15:43 <shapr> @learn
14:15:44 <lambdabot> http://www.haskell.org/learning.html
14:15:58 <shapr> I think you'd like Hudak
14:16:08 <shapr> more than Thompson
14:16:21 <shapr> Hudak is more mathy, and Thompson is less so
14:16:29 <[dan]> ahh
14:17:06 <shapr> I don't own any of the others, so I have no opinion on them
14:18:47 * shapr looks for the bug
14:19:55 <[dan]> shapr: is the hudak book more examples, or more theory?
14:22:06 <shrimpx> someone needs to write a book on advanced haskell programming
14:23:18 <shrimpx> i feel that i don't know haskell very well, but that the hudak and thompson books can't teach me more than i already know
14:23:51 <shapr> shrimpx: yah, I agree with that
14:24:23 <shapr> [dan]: they both have examples, but hudak has more I think
14:24:37 <shapr> it also has some very cool examples
14:24:39 <[dan]> I think a lot of that is because the math behind functional programming is slightly more advanced than that behind assembly
14:24:49 <shapr> Haskore for example
14:27:03 <shapr> oy, stupid obvious bug
15:07:48 <shapr> hi jadrian
15:08:12 <jadrian> hi shapr!
15:10:01 <shapr> what's going on?
15:18:18 <jadrian> ah not much
15:18:43 <jadrian> searching for FOL theorem proving algorithms
15:21:18 <jadrian> d'like obtain simple and understandable proofs, so I guess the best way to work will be using tactics and tacticals
15:23:40 <Marvin--> read some of the papers written by authors of FOL prover software
15:24:04 <Marvin--> I don't understand much of it myself, I just use the programs :)
15:24:19 <jadrian> yeap, I will
15:24:34 <jadrian> HOL stuff is on my To Do list
15:25:12 <jadrian> There is also an Haskell port(?) of HOL... should check some things by them
15:25:37 <jadrian> rigth now I'm implementeng some simple theorem theorem provers
15:25:39 <Marvin--> HOL as in the Isabelle system?
15:26:47 <jadrian> I don't think Isabelle uses HOL, I know both systems have many things in common
15:27:05 <Marvin--> you see, to me HOL just stands for Higher Order Logic
15:27:12 <jadrian> oh
15:27:14 <jadrian> :)
15:27:21 <jadrian> there is a theorem prover named HOL
15:28:13 <Marvin--> I've seen both "Isabelle" and "Isabelle/HOL" in different contexts and was never clear on whether it was the same thing or different things or multiple things
15:28:53 <jadrian> I think it's just Isabelle with a Higher Order Logic module... 
15:29:00 <Marvin--> right
15:29:10 <jadrian> I don't think it's related to HOL the theorem prover but I might be wrong
15:29:34 <jadrian> let me check
15:31:03 <jadrian> Isabelle/HOL: is a version of classical higher-order logic resembling that of the HOL System. The main libraries of the HOL 4 System are now available in Isabelle. 
15:31:12 <jadrian> *resembling*
15:31:18 <Marvin--> ok :)
15:31:23 <jadrian> ;)
15:40:42 <earthy> actually, there are other logics in Isabelle
15:40:51 <earthy> HOL is just one of them
15:41:02 <Marvin--> yes, that's why it's called Isabelle/HOL, I suppose
15:41:57 <earthy> exactly
15:42:36 * Marvin-- has mostly worked with FOL provers
15:42:56 <earthy> well, there's Isabelle/FOL and Isabelle/ZF for that. ;)
15:44:01 <Marvin--> heh
15:45:20 <Lunar^> earthy: I've sent the contribution about hOp for HC&A... a bit late, sorry
15:45:29 <earthy> oh, no probs. ;)
15:45:52 <earthy> I haven't even sent the `by golly, dude, we're past the due date and I still haven't heard from ya' mails. ;)
15:46:40 <Marvin--> I forgot to prod Koen about it :(
15:50:01 * jadrian is off to bed
15:50:03 <earthy> if you can, could you try on monday?
15:50:12 <Marvin--> will do
15:54:54 <Marvin--> oh boy, there's an abundance of bad movies on TV tonight
16:00:16 <earthy> by the way, everybody in europe, sign the call for action II!
16:00:21 <earthy> at www.ffii.org
16:05:09 <shapr> yah, if this one gets passed I'm going back to soft and sane copyright laws like the DMCA
16:05:32 <shapr> as in, if this current proposal from .ie gets passed
16:06:37 <Marvin--> looks like several of the Swedish MEPs have signed it, yay!
16:06:49 <shapr> yay!
16:07:26 <Marvin--> and so have the PBF of course
16:07:33 <Marvin--> and Strakt
16:08:04 <earthy> yeah
16:08:21 <earthy> I'm going to rally the people at cs.uu.nl monday as well
16:08:44 <earthy> and getting people at cs.kun.nl to rally shouldn't be too hard either
16:08:52 <earthy> but still
16:08:56 <earthy> damn.
16:09:39 <shapr> I've tried to explain this issue to the people around here
16:10:05 <earthy> and the response?
16:10:26 <shapr> the best response I've gotten so far is "oh, Linux is free? maybe I should try it."
16:11:12 <shapr> very few people are interested in the economics af copyright
16:11:32 <clausen> shapr: rubbish
16:11:36 <earthy> very few people are interested in things that matter period
16:11:46 <earthy> *unless* you bring it home to them
16:12:04 <clausen> shapr: well, many economists + lawyers are interested in the economics of copyright
16:12:06 <earthy> and in CS deparments that should be relatively easy
16:12:19 <clausen> it is a Hot Topic in economics right now
16:12:38 <earthy> `so, do you still want to be doing your work 2 years from now?'
16:12:40 <clausen> (it's the kind of thing "rebel undergrads" try to avoid, because it's too mainstream)
16:13:31 <shapr> I don't know anyone in CS around here
16:14:11 <Marvin--> well, copyright isn't the main problem, software patents is
16:14:48 <shapr> that's true, but the issues are tightly related
16:14:53 <earthy> the big thing is `intellectual property'
16:14:56 <shapr> yes
16:14:58 <earthy> (which is a misnomer, really)
16:15:04 <clausen> shapr: the magic words are "network externality" and "public good" (i.e. non-excludable, non-rivalress)
16:15:19 <Marvin--> yes, "IP" is a bad term because it mixes several wildly different things into one pot
16:15:21 <shapr> what do those mean?
16:16:01 <shapr> surprisingly, most win32 users I've spoken to don't really get open source
16:16:30 <clausen> shapr: an externality is an effect on a third party to a transaction
16:16:32 <earthy> open source is a non-issue when it comes to these patents
16:16:56 <clausen> shapr: eg: trains might cause sparks which cause fires in farms
16:17:08 <earthy> having to pay EUR 50 more to have a particular patented new feature on your TV *is*
16:17:15 <clausen> shapr: the transaction here is between the railway and the commuter
16:17:27 <clausen> shapr: but the farmer (third party) gets affected
16:17:34 <shapr> so how do I explain that to your average win32 user?
16:17:36 <clausen> so, this effect is an externality
16:17:56 <Marvin--> avoiding writing software because you may be infringing on someone's patent without knowing it is also a big issue
16:18:11 <Marvin--> not knowing about it is not an excuse when it comes to patents
16:18:16 <Marvin--> that's what's so scary about them
16:18:26 <shapr> nearly everyone I've talked to has primarily pirated software on their PC, even businesses
16:19:04 <shapr> so it's hard to show them that patents increase software costs
16:19:05 <Marvin--> same here
16:19:33 <anyone> open source is less about money spent (although it has that side effect), but more about how much choice you have in hiring a car mechanic to fix or mod things.
16:19:46 <earthy> shapr: point out to them that software is in e.g. their MP3 player
16:19:48 <shapr> but that is about money
16:19:51 <earthy> (patents right there)
16:19:58 <shapr> earthy: ah, good point!
16:20:00 <earthy> and e.g. their TV (even more patents)
16:20:04 <shapr> frauhofer codec
16:20:06 <Marvin--> http://www.dslreports.com/shownews/43503  <- this got a few of them worried though
16:20:08 <earthy> bingo
16:20:12 <shapr> and AAC for example
16:20:41 <shapr> anyone: if only one guy can fix your car, he can charge anything he likes
16:21:05 <anyone> Well it is beyond that. If that guy dies, no amount of money will change things.
16:22:05 <shapr> yes
16:22:43 <earthy> ah, but that is not a problem with patents, as they require full disclosure
16:22:52 <shapr> I try that sometimes "no one pays ms.com, they go out of business, who fixes your pirate copies?"
16:23:12 <anyone> Of course no one expects Microsoft to suddenly die. But Microsoft and other companies have long histories of declaring "we will no longer fix bugs in Win95".
16:23:34 <Marvin--> right, and of course they don't let anyone else fix them either
16:23:40 <shapr> most of my arguments make zero impression, but there is one that really irritates people
16:23:41 <Marvin--> heaven forbid
16:24:08 <shapr> I say that I write software, and I won't steal others software because I wouldn't want my own stolen
16:24:26 <Marvin--> I very very very carefully avoid talking about "stealing" software
16:24:38 <earthy> I'm extremely careful as well
16:24:38 <Marvin--> because you can't, really
16:24:40 <Smerdyakov> I don't recognize this idea of "stealing" patterns of bits.
16:25:02 <Marvin--> theft is one thing, copyright infringement is another
16:25:21 <shapr> what about unpublished experimental data?
16:25:31 <shapr> is industrial espionage stealing?
16:25:47 <earthy> I'd always put it `I do not copy illegally, because I depend for my own livelihood on the same law I'd be breaking'
16:25:51 <Marvin--> letting people get away with calling it "theft" and comparing infringers to scurvy pirates is losing half the battle
16:26:06 <anyone> I personally think that the car-hood analogy is faithful and effective. If you encounter anyone who is not convinced by it, well remember that the definition of "average intelligence" means half the people are below average!
16:26:15 <Smerdyakov> shapr, I only have a problem with claiming credit for gathering that data.
16:26:26 <shapr> car-hood analogy?
16:26:27 <Smerdyakov> shapr, there is nothing inherently wrong with accepting it when you have an opportunity.
16:26:30 <shapr> what's that?
16:26:59 <anyone> "What if your car manufacturer refuses to let someone else open the hood of your car?"
16:27:16 <Marvin--> especially yourself
16:27:17 <earthy> that's good for open source, yes.
16:27:20 <clausen> anyone: actually, that's median :P
16:27:22 <earthy> as an analogy
16:27:22 <Smerdyakov> If you're a responsible person, then you don't have a car in the first place. :P
16:27:30 <clausen> anyone: but, I guess there's the central limit theorem :P
16:27:53 <anyone> (Even if the someone is professional.)
16:28:08 <earthy> the problem is that there's more and more people that don't care. `Oh, but the company will fix it for me, won't they, if I pay them?'
16:28:16 <shapr> right
16:28:36 <shapr> that's the scariest part
16:29:04 <anyone> Heh, it is not really that more and more people don't care, but that more below-average people have access to computers.
16:29:50 <shapr> whatever it is, it's depressing
16:29:54 <earthy> no. too many people *just*don't*care*.
16:30:13 <anyone> Well yeah, half of them.
16:30:38 <[dan]> its depressing when it comes to computers and such, it's damn frightening when its in relation to local politics
16:31:07 <[dan]> i.e. the large majority which seems to say, I dont care who's mayor/leader/runs things, they will always be looking out for me
16:31:15 <earthy> exactly
16:31:28 <Smerdyakov> [dan], the problem lies in thinking that it makes sense to have "leaders" in the first place.
16:31:44 <earthy> it does, though
16:31:45 <Smerdyakov> [dan], I think it is even sensible to not care about elections in America and other places.
16:31:50 <shapr> oh, I had a vision of the geek future of politics recently
16:31:59 <Smerdyakov> earthy, how so?
16:32:01 <[dan]> Smerdyakov: Depends on how you think about it.
16:32:08 <earthy> there's a shitload of things I personally don't want to have to spend time upon
16:32:28 <earthy> that I really want people to decide for me
16:32:30 <[dan]> Smerdyakov: it makes sense to not care about elections when there's politcians "running" for office. I don't want to put him there because he wants to be there and for no other reason
16:32:35 <Smerdyakov> earthy, that is a personal fault in you.
16:32:39 <earthy> but I want to know I can check up on them
16:32:43 <shapr> think of politicians being heavily math/economics/CS/sociology educated
16:33:02 <earthy> and I want a way to correct them when they're going wrong
16:33:04 <anyone> They are?!
16:33:12 <Smerdyakov> earthy, are you sure you are talking about "leaders" and not people implementing collective will?
16:33:20 <shapr> and election is where the public at large critiques the polticians personal models
16:33:26 <earthy> smerdyakov: yes.
16:33:30 <shapr> and the changes they propose
16:33:35 <shapr> that would be cool
16:33:50 <earthy> many people *don't* have a conscious will to do certain things
16:33:50 <Smerdyakov> earthy, you don't agree that the popular image of, for example, the US president's job is ridiculous?
16:33:57 <clausen> Smerdyakov: representative democracy is a bit like that...
16:34:03 <Cale> oh, come on Smerdyakov - everyone has details which they'd rather not care about, but which politicians take care of.
16:34:05 <clausen> (50/50 leader/implementor of public will)
16:34:06 <earthy> I do agree.
16:34:14 <[dan]> The fundamental problem is what defines collective will or agreement. How do you handle a society in which there's 30-40 percent minorities opposing most "majority" opinions quite strongly?
16:34:19 <Smerdyakov> earthy, it's that kind of image that I mean by the quoted "leader."
16:34:34 <earthy> ah, okay, I didn't quite grasp that.
16:34:42 <Smerdyakov> Cale, not wanting to do something doesn't mean that it's not the right thing to do.
16:34:44 <shapr> [dan]: yah, I agree
16:34:48 <earthy> since true leaders are necessary.
16:34:55 <anyone> I somehow have a bleak view of what shapr says. Look, in that scene, the politicians are well-education, and the electorate is illiterate.
16:35:06 <Cale> Smerdyakov: no, it just means you don't have time for it.
16:35:23 <Smerdyakov> earthy, I don't think positions that give the sole power to order others to do things should be allowed.
16:35:35 <shapr> the greek idea of thesis and antithesis had groups splitting, evolving, one dying out and the cycle would restart
16:35:36 <Smerdyakov> Cale, arguing extremes does nothing to justify today's widespread apathy.
16:35:54 <earthy> um. well. it *does* facilitate matters greatly
16:36:05 <shapr> but we can't easily change citizenship nowadays
16:36:07 <earthy> but there need to be checks and balances, or it grows out of hand
16:36:10 <Cale> Apathy?
16:36:11 <[dan]> Cale: It can be argued that looking after one's society and local issues ought to take precedence over things like a job
16:36:12 <Smerdyakov> earthy, it is useless when the people are properly educated to begin with.
16:36:15 <clausen> Smerdyakov: what brand of toothpaste should the whitehouse staff be supplied with?
16:36:23 <shapr> I don't care about apathy :-P
16:36:26 <earthy> smerdyakov: why?
16:36:29 <Smerdyakov> clausen, there shouldn't be whitehouse staff.
16:36:47 <Cale> What is this, the US we're talking about, or something?
16:36:49 <Smerdyakov> earthy, why not? Why would it be useful?
16:36:53 <earthy> to wit: germans, in the 1920's, on the large, were well educated
16:37:06 <Smerdyakov> Cale, I think it includes the US, Canada, Europe...
16:37:16 <shapr> anyone: thing is, people educate themselves
16:37:19 <earthy> yet, they still voted to put a leader in charge.
16:37:24 <shapr> you can lead a horse to water...
16:37:34 <Smerdyakov> earthy, the fact that they voted so shows that they were not well educated in the sense I mean.
16:37:43 <flippo> I find the prolatariate in the US extremely sceptical about those in power.  They mostly lack information, thanks to a carefully engineered press
16:37:43 <anyone> Alright.
16:37:43 <Cale> I don't know - people vote in Canada, and care about whatever issues affect them.
16:37:57 <shapr> anyone: just my opinion of course
16:37:58 <anyone> We do?!
16:37:59 <Smerdyakov> earthy, this education includes teaching people to think for themselves and avoid all hierarchical power structures.
16:38:07 <shapr> haha
16:38:08 * earthy grins
16:38:18 <flippo> The middle class are those that want to believe the lies.
16:38:19 <shapr> teach people to avoid hierarchicy
16:38:19 <earthy> nice pipedream smerdyakov
16:38:22 <Smerdyakov> Cale, caring (which isn't always genuine) is next to worthless.
16:38:34 <earthy> people *want* to be told what to do
16:38:36 <Smerdyakov> Cale, I'm talking about people running their own communities.
16:38:45 <earthy> they *love* it
16:38:50 <Cale> Smerdyakov: they do
16:38:54 <shapr> "I'm taking a class on rebelling against authority"
16:38:56 <Smerdyakov> Cale, I'm talking about losing the distinction whereby most people consider "the government" a separate entity from themselves.
16:39:05 <Cale> Smerdyakov: they elect someone to take care of it.
16:39:06 * earthy laughs at shapr
16:39:18 <Cale> Those people are only there because the people put them there.
16:39:37 <Smerdyakov> Cale, I am saying that electing people is not good enough. It does not count as really running your own life.
16:39:58 <Cale> Well then don't elect people - nobody's stopping you :)
16:40:00 <clausen> Smerdyakov: are you familiar with social choice theory?
16:40:05 <Cale> heh
16:40:07 <Smerdyakov> clausen, no
16:40:10 <clausen> and Arrow's impossibility theorem?
16:40:30 <Smerdyakov> Cale, but people _are_ stopping me from living where I live and not going along with the decisions of the people in the government.
16:40:31 <shapr> along these same lines, I see IPv6 letting each person connect to another, taking the ISP out of the loop
16:40:44 <shapr> down with the empiralist IPv4!
16:40:55 <clausen> http://en.wikipedia.org/wiki/Arrow's_impossibility_theorem
16:40:56 * shapr laughs
16:41:02 <Cale> Nobody's stopping you from volunteering your life into doing community service.
16:41:08 <[dan]> Smerdyakov: Agreed completely. "goverments" tend to react violently to people desiring a society outside of the current power system.
16:41:10 <Smerdyakov> clausen, hey, informative page!
16:41:19 <shapr> right, don't tell others what to do, lead by example
16:41:44 <Cale> If you don't like the way that most people do things in your country, then leave.
16:41:46 <Smerdyakov> Cale, "community service" in our societies is something that still leaves you under the control of others.
16:41:47 <shapr> yup
16:41:52 <Smerdyakov> Cale, why should I have to leave?
16:41:52 <shapr> worked for me
16:42:05 <clausen> Smerdyakov: it is actually about more than just about voting
16:42:06 <Cale> Well, if it's so unacceptable.
16:42:12 <earthy> `It's a lousy rotten world, but it's the only one we've got'
16:42:16 <shapr> yes
16:42:17 <clausen> Smerdyakov: it is about aggregating preferences
16:42:18 <Smerdyakov> clausen, you gave me a link to a blank page.
16:42:21 <clausen> Smerdyakov: in general, it is impossible
16:42:31 <clausen> Smerdyakov: works for me
16:42:33 <shapr> I'd rather not blow ub the earth, no matter how much it sucks
16:42:51 <clausen> Smerdyakov: try http://www2.sjsu.edu/faculty/watkins/arrow.htm
16:42:53 <Smerdyakov> clausen, oh, XChat apparently removed the '
16:42:56 <Marvin--> Smerdyakov: make sure you don't lose the '
16:43:00 <Marvin--> Smerdyakov: exactly
16:43:02 <Cale> Go and live on a tiny island somewhere if you want to take care of everything on your own.
16:43:12 <shapr> yes, I agree
16:43:18 <Smerdyakov> Cale, why is that a better choice than staying where I am and trying to change things?
16:43:23 <shapr> we have an existing social contract
16:43:32 <clausen> shapr: what if it's a bad contract?
16:43:40 <clausen> (and what if smerdy can convince everyone it's a bad contract?)
16:43:41 <Cale> Oh, sure, you're free to try to get elected.
16:43:49 <shapr> renegotiate
16:44:00 <clausen> that's what smerdy's after :)
16:44:05 <Cale> You have to get people to agree with you if you want to be elected though.
16:44:06 <shapr> so am I
16:44:23 <shapr> step one, kill the software patents legislation in the EU
16:44:58 <Smerdyakov> Cale, no, I don't think "getting elected" is a good way to have a lasting effect on a society.
16:45:04 <shapr> we do have an in-place system that sort of supports change
16:45:26 <Cale> So what do you propose you're going to do to change things then?
16:45:27 <shapr> Smerdyakov: yup, didn't work for Lincoln or Eisenhower for example
16:45:35 <clausen> Smerdyakov: changing the constitution?
16:45:58 <Smerdyakov> clausen, ditching the constitution.
16:46:08 <clausen> Smerdyakov: same thing
16:46:11 <Smerdyakov> People can, over time, build alternate social structures.
16:46:17 <Cale> You're not going to be able to propose changes directly without being a member of the elected government, that is, getting people to agree with your views.
16:46:24 <clausen> Smerdyakov: anyway, I strongly recommend you learn about social choice theory
16:46:25 <Smerdyakov> The only thing standing in the way of a complete transformation this way is violence by others.
16:46:30 <clausen> Smerdyakov: what you are suggesting sounds impossible to me
16:46:48 <Smerdyakov> Cale, why not? I can propose whatever I want.
16:46:48 <clausen> (the second URL I sent is much better)
16:47:00 <shapr> so, speaking of arrows
16:47:16 <shapr> anyone written any arrow-using code lately?
16:47:17 <Smerdyakov> clausen, the theorem doesn't seem too relevant to me. It has no relevance if everyone really has the same things in his best interests.
16:47:27 <Cale> Smerdyakov: You don't seem to have any concept of actual implementation of social change.
16:47:29 <clausen> Smerdyakov: agreed
16:47:53 <[dan]> Cale: There's a point at which small changes no longer suffice
16:48:01 <clausen> Smerdyakov: but, I'm not sure I accept the premise "everyone really has the same things in his best interests"
16:48:16 <Smerdyakov> Cale, how so? For instance, you can stop doing business with any entities that don't publish complete breakdowns of their use of resources and business relationships with others.
16:48:47 <Cale> Either you kill everyone and take their place by force, or you work within the system and try to enact transformations from within.
16:49:11 <Smerdyakov> Exactly. And the "from within" option does not require acknowledging the importance of or going through what the average person views as "the system."
16:49:35 <Smerdyakov> Rather, "the system" is an adversary you deal with when forced to.
16:50:10 <Cale> Well, you're going to have to actually deal with other people when getting them to change what they're doing. Those people are the system.
16:50:30 <[dan]> Cale: Not necessarily.
16:50:37 <Smerdyakov> Right, but if you convince them that the government is not the only mechanism for organizing society, then the government need not be involved.
16:51:40 <shapr> they are the government
16:51:47 <[dan]> Which is more equitable, 51% of the population enslaving the other 49% and wanting no change to this because of the direct benefit, or actual debate and consensus?
16:51:51 <shapr> government is just an idea that sticks
16:51:54 <Smerdyakov> "They are the government" is a subjective statement.
16:52:01 <shapr> like a lot of other things
16:52:04 <Smerdyakov> People will no longer "be the government" if you convince them that they aren't.
16:52:43 <shapr> what if we had a government end nobody came?
16:52:52 <shapr> s/end/and
16:53:10 <Smerdyakov> What do you mean?
16:53:25 <[dan]> shapr: from history, that usually would mean the government would use the force at its disposal to make people conform and obey, or forcibly expel them.
16:53:31 <shapr> I think the in-place structures are unlikely to change
16:53:36 <shapr> [dan]: yes, I agree
16:53:43 <Smerdyakov> shapr, it's clear from history that they _will_ change.
16:54:14 <[dan]> shapr: So you have two outcomes. Either the government has enough power, and people are enslaved to it, or the government does not, and is overthrown and replaced.
16:54:27 <[dan]> It's basically survival of the fittest applied to social systems
16:54:30 <shapr> yup
16:54:38 <Smerdyakov> The idea of "government" clearly and undeniably exists for the sole purpose of enslaving people.
16:54:51 <clausen> Smerdyakov: I deny it :)
16:55:02 <shapr> I thought it was there to keep you from getting mugged?
16:55:06 <[dan]> clausen: What other purpose does government have?
16:55:15 <clausen> [dan]: provision of public goods
16:55:29 <Smerdyakov> Different ages' ideas of "government" move slowly further and further away from the original state of conquering barbarians imposing their will on subject people, but the idea is still meaningless when viewed from first principles.
16:55:42 <shapr> right, means I don't get to beat up on you
16:56:22 <Smerdyakov> shapr, you have the wool pulled over your eyes. This is one benefit claimed for government, but other social organization principles also avoid physical harm to you.
16:56:44 <shapr> see, I think you have the wool
16:56:49 <Smerdyakov> Why?
16:56:51 <[dan]> shapr: is beating up on someone inherently wrong?
16:57:32 <Jon> ask chuck palanhuik
16:57:37 <shapr> I can't think of any cases where it's right
16:58:04 <Smerdyakov> shapr, why do you think you can't guarantee your physical safety without having people with the power to order others to do things?
16:58:18 <[dan]> shapr: but that's a result of a very particular moral system... which cannot be projected onto others forcibly
16:59:11 <[dan]> clausen: the concept of a public good is interesting... on one end you can interpret that as being why government exists, and on the other it's possible to see it as what government does with the people it has enslaved
16:59:11 <shapr> [dan]: that's true, I'm very gandhi about violence
16:59:41 <clausen> [dan]: I mean public good in the economics sense
16:59:51 <clausen> [dan]: i.e. non-excludable + non-rivalress
16:59:58 <shapr> Smerdyakov: there is no way to guarantee anyone's physical safety
17:00:07 <clausen> [dan]: private provision of public goods is Pareto inefficient
17:00:10 <shapr> but cops do help
17:00:27 <Smerdyakov> shapr, education helps more.
17:00:55 <shapr> you bring a book to a knife fight?
17:00:57 <[dan]> clausen: Think of public goods as services which are paid for by obedience. Don't pay, get thrown out and don't get them.
17:01:05 <Smerdyakov> shapr, educated people don't start knife fights
17:01:22 <shapr> right, educated people get stabbed
17:01:27 <clausen> [dan]: that is inefficient, however
17:01:31 <Smerdyakov> If everyone is educated, no one gets stabbed.
17:01:40 <clausen> [dan]: it is more efficient to tax and give to everyone
17:01:42 <shapr> if everyone is stabbed...
17:01:44 <shapr> hmm
17:02:07 <clausen> [dan]: by definition, "non-excludable" means it is expensive to deny the services
17:02:14 <clausen> (so, I'm not talking about education here)
17:02:21 <Smerdyakov> The desire to stab someone else is highly unnatural and occurs because of the deleterious influence of bad social structures.
17:02:24 <shapr> Smerdyakov: that's not true though
17:02:47 <shapr> stabbing your buddy is a great way to get his money
17:03:12 <shapr> education teaches that we compete the best we can
17:03:23 <Smerdyakov> No, not the education I'm talking about.
17:03:39 <shapr> nature shows that breaking the rules is often advantageous
17:03:42 <Smerdyakov> I will switch to calling it "rational socialization."
17:03:57 <shapr> look at the cuckoo
17:04:02 <Smerdyakov> Breaking the rules is not advantageous when the rules are set by people smarter than you are.
17:04:14 <[dan]> Smerdyakov: Untrue
17:04:21 <Smerdyakov> And "the whole of previous human history" can be thought of as a really smart person for these purposes.
17:04:39 <bring> wanting to stab someone is highly natural, education teaches us to control that impulse
17:04:47 <bring> anyway, good night
17:04:51 <Smerdyakov> bring, what evidence do you have for that?
17:04:55 <shapr> according to that logic, we have really smart rules right now, why change them?
17:05:01 <[dan]> Breaking the rules is advantageous if you do not care about society, only yourself. And it becomes more advantageous if you are the only rule-breaker in a society that follows rules.
17:05:08 <shapr> bring: I'm with you on that
17:05:18 <shapr> I have the Snoopy Rule
17:05:39 <Smerdyakov> shapr, smart people have the ability to analyze the rules in depth and propose changes.
17:06:05 <Smerdyakov> [dan], no, because the rules may be the result of much deliberation, such that you hurt yourself in a very complex way that you hadn't though of by breaking them./
17:06:36 <shapr> I read one Peanuts strip where Snoopy said "sometimes I wake up in the morning, and I really, really want to bite a cat. If I just hang on and wait, that urge passes. That's true maturity."
17:07:06 <Smerdyakov> Besides, we have evidence that people will follow the social systems they're born into.
17:07:09 <[dan]> Smerdyakov: Yes, but that's not going to stop anyone from thinking that breaking the rules is advantageous
17:07:24 <Smerdyakov> If I like the qualities if the system I propose in steady state, then it makes sense for me to try to implement it.
17:07:35 <Smerdyakov> Perhaps it will occasionally be necessary to banish, kill, whatever people who don't go along with it.
17:07:43 <shapr> but wait
17:07:51 <shapr> that means someone has the power
17:08:15 <shapr> weren't you were saying we should govern ourselves?
17:08:16 <Smerdyakov> Careful. Power itself is not necessarily hierarchical power.
17:08:28 <Smerdyakov> The people agree that such-and-such a person has to go.
17:08:34 <shapr> oh, so I get to banish you whenever I want?
17:08:39 <Smerdyakov> Yes
17:08:47 <Smerdyakov> When you have widespread support.
17:08:48 <shapr> and you get to do the same to me?
17:08:55 <Smerdyakov> This is essentially the situation we have now.
17:09:00 <Smerdyakov> I don't see any way of avoiding it.
17:09:32 <shapr> well, I want to banish software patents
17:09:44 <shapr> right now!
17:10:03 * shapr makes an official proclamation and then goes to sleep
17:10:09 <[dan]> So basically even in your better system, Smerdyakov, there's still no resolution to the problem of disagreement with the current government/power structure
17:10:29 <Smerdyakov> Well, if you disagree with a flat power structure, then you may have a problem.
17:11:23 <[dan]> A flat power structure is only theoretical. Once the first person is persuaded to "give up" the power they hold, it's no longer flat
17:11:49 <[dan]> Fast forward some duration of time, and we arrive at precisely the apathy and increasing concentration of power in current-day societies.
17:12:03 <Smerdyakov> This is not a problem if no one "gives up" power.
17:12:17 <[dan]> Agreed. But I don't think that's possible.
17:12:25 <Smerdyakov> I think it is.
17:12:56 <Smerdyakov> I think it's the natural state of humanity, and all we need to do is get rid of the influence of particular historical events and we can return to it.
17:14:13 <[dan]> Smerdyakov: I think we can agree to disagree here.. I see a fundamental lack of an ability for people to say that they have enough of something.
17:14:25 <Smerdyakov> I have enough of just about everything.
17:15:48 <[dan]> Congratulations, then. How do we go about teaching every other greedy man to be like that?
17:16:27 <Smerdyakov> I think it's just a matter of not teaching them _otherwise_.
17:17:15 <[dan]> Which presupposes the existence of a society which isn't busily trying to take away whatever they have.
17:17:44 <Smerdyakov> And we get there in stages.
17:38:22 <juhp> shapr: you tried MozEmbed? :)
18:03:44 <desrt> wow.  now this is a party place.
18:19:50 <desrt> is anyone here good with gtk?
18:20:02 <desrt> i want to know which set of the language bindings i should be looking at
18:20:25 <desrt> i should probably mention that i don't know haskell yet but i plan to very soon
18:27:25 * desrt drops a pin
18:34:39 * [dan] listens to the echoes of the dropped pin
18:35:17 <desrt> the story is: we're building a supercomputer at my university
18:35:22 <desrt> and it's going to be running haskell
18:35:42 <desrt> and i'm doing a lot of the work on getting the operating system up to scratch to handle massive amounts of network io of memory
18:35:52 <desrt> but i'd like to be able to program this thing, so..... much learn haskell
19:10:50 <Riastradh> ...fast I/O in Haskell?
19:12:30 <flippo> Grab that supercomputer by the monads
19:22:41 <desrt> not IO for haskell.  IO for distributing the processing
19:23:07 <desrt> quick question: one of the profs on the project gave me something called "2 dozen short lessons"
19:23:21 <desrt> it says i can say things like 'var = "somestring"'
19:23:27 <desrt> but when i do this hugs balks
19:23:45 <desrt> ERROR - Syntax error in input (unexpected '=')
19:28:07 <desrt> hm.  the tutorial is a little bit unclear about the fact that definitions have to be in a .hs file...
19:32:37 <desrt> ok.  this is neat stuff.
19:32:54 * desrt writes a program to calculate a list of fibbonaci numbers using the naive recursive algorithm
19:33:02 * desrt watches hugs output the list in real time
19:35:14 * desrt thinks of how he can do better
19:48:52 <skew> desrt: GHCi accepts statements, as if you were in a do block
19:49:18 <skew> so you can declare things if you say let var = binding
19:49:30 <skew> try let fibs = 1:1:zipWith (+) fibs (tail fibs)
19:50:13 <desrt> ghc is currently compiling.  it's very large
19:50:41 <desrt> btw: is there a : that adds to the end instead of the beginning?
19:50:58 <desrt> right now i have append list newelement = reverse (newelement : (reverse list))
19:51:00 <desrt> kinda hackish :)
19:51:27 <skew> how about list++[newelemnt]?
19:51:55 <skew> both are pretty inefficient through. Lists are nice for laziness, but only support head and cons efficienly
19:52:15 <desrt> i'm just trying to get a feel for the language right now
19:52:26 <desrt> started coding in it about 10 mins ago :)
19:53:33 <desrt> ok.  how about concatenating lists?
19:54:11 <desrt> without using some whacky recursive append/head thing....
19:56:07 <desrt> hm.  my implimentation ended up being lazy-unfriendly
19:56:41 <desrt> it did nothing except display "ERROR - Garbage collection fails to reclaim sufficient space"... which i assume means that i'm trying to recurse infinitely (which i am.... but i thought laziness might take care of it)
19:59:14 <desrt> oh!  of course
19:59:23 <desrt> list++[new] is just a special case of adding 2 lists :P
19:59:35 <desrt> <- dumb
20:01:14 <SamB> desrt: maybe you want to do this with the list backwards?
20:01:35 <desrt> SamB; i'm building a list of fibbonacci numbers
20:01:56 <SamB> desrt: hehe, that is not hard...
20:02:00 <desrt> i know
20:02:02 <desrt> i just got it to work
20:02:05 <desrt> it's rather fast
20:02:09 <desrt> (compared to my first one)
20:02:23 <SamB> how small is it?
20:02:25 <desrt> it fills my screen with output before i can stop it
20:02:34 <desrt> 5 lines
20:02:45 <desrt> i think i see what you mean, though....
20:02:52 <desrt> this is mind-bending
20:03:05 <desrt> i could define the program to add to the beginning of the list....
20:03:11 <desrt> and reverse the list when it's done
20:03:11 <SamB> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
20:03:15 <desrt> and never have to knwo the beginning....
20:03:47 <desrt> i don't like this algorithm because i don't understand it :)
20:03:59 <desrt> remember: only been writing haskell for 20 mins :)
20:04:06 <bluejay> desrt: http://www.cse.unsw.edu.au/~chak/haskell/gtk/ (for when you eventually know enough to use it)
20:04:17 <SamB> it is pretty simple, really.
20:04:34 <desrt> bluejay; there is another one called gtk2hs.  it claims to be an improved version of this one.  any experience?
20:04:39 <SamB> lets unroll it a bit.
20:04:48 <desrt> samb; it's a huge shift in mindset for me.  i've never programmed functional before
20:06:17 <SamB> fibs = 1 : 1 : (1 + 1) : zipWith (+) (tail fibs) (tail (tail fibs))
20:06:28 <bluejay> desrt: nope, I just got that link from ghc's web page. But I have to go :( good luck with haskell
20:06:37 <desrt> bluejay; thank you :)
20:07:11 <SamB> now of course, that isn't the way a compiler would unroll it. but I am not a compiler, so ;-)
20:07:47 <desrt> i'm trying my own insane way
20:07:56 <desrt> much smaller than my first try
20:08:03 <SamB> well, lets see your insane way ;-)
20:08:09 <desrt> i'm still working on it :)
20:08:23 <desrt> or rather, trying to understand what i just wrote...
20:08:55 <desrt> wow.
20:08:59 <desrt> it just made hugs segfault
20:09:07 <desrt> i guess that's a bug in hugs?
20:09:34 <desrt> my algorithm:
20:09:45 <desrt> fib = reverse (revfib [1,1])
20:09:57 <desrt> revfib list = head list + head (tail list) : revfib list
20:10:20 <desrt> sort of an infinite list in which the last element is defined first.....
20:10:30 <desrt> and you reverse it so the first element is defined first
20:13:24 <SamB> you know what is interesting about this? the commas make curves on your screen!
20:13:36 * desrt grins
20:13:56 <desrt> only one curve
20:14:13 <desrt> or at least only one terribly noticable one
20:15:06 <SamB> it depends on where you get up to... the further you go, the less of them and probably the more noticable they are.
20:16:04 <SamB> hrmm, no. once you go past a certain point, they become hard to see, because there is no longer at least one comma per line
20:16:23 <desrt> it's neat how well it scales
20:16:31 <desrt> it handles adding 80 digit numbers quite easily
20:17:56 <SamB> hmm, yours isn't lazy, though...
20:18:37 <SamB> well, how about a less concise lazy version, with exlicit recursion?
20:18:50 <desrt> why can't it be lazy?
20:19:41 <SamB> well, it doesn't seem to be... because when I try it, I get no output on the screen.
20:20:20 <desrt> i think haskell isn't being smart enough :)
20:20:50 <SamB> hmm. let me see...
20:22:23 <desrt> i think there's a trick that i'm missing
20:22:33 <desrt> i mean.  i think i understand my problem
20:23:07 <desrt> mathwise my statements work, but they require infinite recursion to even retreive the first element
20:23:13 <desrt> which i assumed was ok
20:23:17 <desrt> but i think is not
20:24:01 <desrt> i figured that haskell would realise that the first n elements of the return value of the function is equal to the first n elements going in....
20:24:12 <desrt> and not evaluate (and thus recurse forever)
20:24:14 <SamB> haskell is not a mathematician ;-)
20:24:30 * desrt saves some of these non-working examples to show his prof =)
20:25:08 <SamB> and actually, the one you gave me... revfib [1,1] produced [2,2..]!
20:25:29 <SamB> fibs2 = fibs' 1 1
20:25:29 <SamB>     where
20:25:29 <SamB>     fibs' a b = let x = a + b in  x : fibs' b x
20:26:43 <desrt> hm.  that's looking like my new one
20:26:49 <desrt> i didn't know you could recurse inside where
20:26:59 <desrt> can you do like.. . sub-where?
20:27:18 <desrt> x = y
20:27:21 <desrt>  where y = z
20:27:23 <desrt>   where z = ...
20:28:01 <SamB> *Main> let x = y where y = z where z = 1
20:28:01 <SamB> *Main> x
20:28:01 <SamB> 1
20:28:14 <SamB> (this is ghci)
21:34:33 <desrt> i finally got a recursive algo for fibonacci that i'm happy with
21:35:18 <desrt> and samb is now gone :(
21:39:36 <desrt> oh.  yay.
21:39:48 <desrt> samb; here's my algorithm that i'm happy with:
21:39:54 <desrt> fiblist = 1 : 1 : fibify 1 1
21:40:09 <desrt>   where fibify x y = x + y : fibify y (x + y)
21:42:06 <flippo> looks nice and lazy
21:42:30 <desrt> quite lazy :)
21:43:18 <SamB> desrt: that is essentially the same as what I told you last, actually.
21:44:06 * desrt scrolls
21:44:10 <SamB> only I uglied mine up with a let for the (x + y)s
21:44:25 <SamB> and it had different names for the variables
21:44:29 <desrt> interesting.
21:45:01 <SamB> so I guess I shouldn't have put that let in there ;-)
21:45:12 <desrt> ya.  i don't know let/in yet
21:45:19 <desrt> but from comparison i assume it's equivilent to:
21:45:24 <desrt> fibs' a b = x: fibs' b x
21:45:27 <desrt>   where x = a + b
21:45:43 <SamB> approximately.
21:45:50 <desrt> wow.  mine really *is* a blatant ripoff of yours :)
21:45:55 <SamB> I think wheres apply to whole definitions.
21:46:12 <SamB> desrt: there aren't that many different ways to do it lazily, you know.
21:46:21 <desrt> fair enough
21:47:05 <SamB> I mean, I'm sure there is an infinite number of more ugly ways...
21:47:09 <desrt> i still think my backwards-list method ought to work and am rather disappointed that it does not :P
21:47:40 <SamB> I think your backwards list version was a bit confusing...
21:48:22 <desrt> confusing enough to crash hugs :)
21:49:37 <SamB> and remember, when I did revfibs [1, 1] I got the same thing as if I had done [2,2..]
21:49:51 <desrt> ya.  i'm noticing a problem now.
21:49:59 <desrt> revfib list = anything : revfib list
21:50:03 <desrt> isn't going to do the right thing...
21:50:19 <desrt> i want to make this work because if i can it will be *very* cool
21:50:23 <desrt> i just need to rethink my logic
21:51:28 <SamB> I do not think it can.
21:51:28 <SamB> at least, not without becoming something distinctly different from what you had in mind.
21:51:49 <desrt> well...
21:51:54 <desrt> i'm going to take my working example
21:51:56 <desrt> and reverse it
21:52:02 <desrt> and see if any interesting optimisations appear
21:52:08 <desrt> i doubt they will, though
21:52:13 <desrt> i really just want to see if it will work
21:54:42 <desrt> fails to be lazy :(
21:54:44 <desrt> oh well
21:57:47 <desrt> i now have this burning desire to create a lazy program to calculate all of the digits of pi :)
21:59:31 <simon-> why not just one that calculates the nth digit?
21:59:48 <desrt> i'm fond of the idea of having lists of infinite length :)
22:00:12 <SamB> desrt: hmm, in binary?
22:00:32 <desrt> dunno.
22:00:42 <desrt> base 2 certainly seems more natural of a choice than base ten
22:01:29 <SamB> because I heard that you can calculate the nth bit of pi. so for a start, you could have:
22:01:55 <desrt> ya.  it's called the digit extraction algorithm, i think
22:02:12 <desrt> i wrote a *really* small ssh client once... and i was doing everything i could to make it smaller
22:02:29 <desrt> and it used the blowfish encryption algorithm... which uses the digits of pi as initial data for keying itself
22:02:52 <SamB> hmm, I don't know much about encryption techniques, or blowfish, or ssh...
22:02:54 <desrt> and it stores about 4k worth of pi... so i was looking for ways to get rid of that by being able to generate it on the fly
22:03:19 <SamB> so was the bit extraction algorithm smaller than 4k?
22:03:19 <desrt> but all of the algorithms were either too slow to be useful or too large to make it worth while
22:03:21 <simon-> desrt, storing is faster
22:03:39 <desrt> simon; i discovered this
22:03:58 <desrt> on the other hand, MD5 takes its initial data from sin(n) for integer values of n
22:04:05 <desrt> and that was quite easy to cook up on the fly
22:04:12 <simon-> yeah
22:04:28 <desrt> you win some you lose some
22:04:33 <simon-> what does MD5 do with pseudo-random data?
22:05:29 <simon-> or is it the same values of n all the time?
22:05:49 <SamB> hmm, I must sleep...
22:05:52 <desrt> uhm
22:05:55 <desrt> it has a table
22:06:14 <desrt> its digest function does a whole lot of weird operations on the incoming data as part of the hasing
22:06:36 <desrt> from what i remember it splits the data into 4 chunks and does a lot of weird ops like a = F(a, b, c, d, E)
22:06:42 <desrt> where F is some weird bit-mixing function that changes
22:06:47 <simon-> ah yes
22:06:48 <desrt> and E is a "random" number
22:06:59 <simon-> random?
22:07:00 <desrt> but E is really the result of sin(n) where n is the step in the process you're doing
22:07:14 <simon-> ah, okay. that makes sense
22:08:18 <desrt> heh.  i got so optimised that i actually took a lot of the common parts of the different F() functions and wrote common code for them
22:09:09 <desrt> as far as i know i have the smallest md5 implimentation in existance (although *quite* far from being the fastest by any measure)
22:10:55 <desrt> 459 bytes on x86
22:11:54 <SamB> desrt: did you code it in C?
22:12:04 <desrt> SamB; ya.  good call
22:12:09 <desrt> someone probably has one in asm that's better
22:12:36 <SamB> well, I'm sure it would be doable. maybe it has been, maybe not.
22:14:08 <desrt> heh
22:14:29 <desrt> i remember competing with a friend as to who could write the smallest rot13 implimentation that was a valid ELF executable that would run on linux
22:14:52 <desrt> we did crazy stuff like sticking code in unused portions of the executable header
22:15:03 * desrt used to live for stuff like this =)
22:15:27 <simon-> fun
22:16:06 <desrt> these ideas seem quite incompatible with programming in haskell
22:17:27 <SamB> what about invalid ELF executables that would run on linux?
22:17:45 <desrt> er.  with valid defined as "will run on linux"
22:18:38 <desrt> i think we ended up finding that the smallest rot13 algorithm we could do actually involved division
22:18:47 <desrt> soo long ago
22:19:22 * desrt reads some more tutorials
22:23:43 <desrt> omg.  ghc is done
22:26:25 <desrt> anyone know a good site for describing monoids?
22:27:20 * desrt googles and finds
22:53:34 <desrt> thanks for the help guys.  it's bed time.
