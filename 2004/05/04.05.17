00:59:11 <skew> according to the sourceforge project page it's stable
00:59:29 <skew> anybody around here use irssi?
00:59:37 <skew> I'd like to keep separate channels in separate instances
00:59:46 <skew> so stuff like the above doesn't happen
01:00:30 <ayrnieu> skew - what happened above?
01:00:48 <skew> what sourceforge project was I talking about?
01:00:49 <ganymede> skew: irssi run on windows ?
01:00:58 <skew> not in response to anything on this channel :)
01:01:09 <skew> ganymede: how does that help?
01:01:28 <ganymede> skew: i want to try it out ... on my work box if possible ... 
01:01:43 <ibid> just ECHAN and resend to the correct channel, it's not that bad :)
01:01:47 <skew> oh, I thought you said run irssi on windows...
01:01:51 <skew> what is ECHAN?
01:01:54 * ibid uses irssi
01:02:05 <ibid> skew: "sorry, wrong channel"
01:02:08 <saz> irssi is really cool
01:02:13 <skew> I just don't always check what channel I'm typing in
01:02:38 <skew> I'd prefer to let my window manager manage the windows rather than curses
01:02:51 <saz> skew: then use xchat?
01:02:57 <ibid> (curses does not manage windows)
01:03:08 <skew> well, whatever does the split window stuff
01:03:20 <bluejay> curses are what I use when my window manager does things wrong. ;)
01:03:28 <bluejay> s/use/say/
01:03:37 <ibid> to me, speaking in a wrong channel is a rare event, and when that happens, i usually notice it right away, allowing me to ECHAN and resend to the correct channel
01:03:50 <ibid> skew: irssi itself, i'd say
01:04:08 <ganymede> ah there are version for windows
01:09:23 <polli> anyone tried out generic haskell?
01:10:25 <ganymede> polli: what is generic haskell ?
01:11:24 <skew> polli: I've never tried generic haskell
01:11:35 <polli> ganymede: www.generic-haskell.org
01:12:18 <skew> I've done a tiny bit with Data.Generic, which I think is roughly similar in power
01:17:26 <kosmikus> I wrote Generic Haskell
01:18:17 <skew> excpet maybe for some of the kind indexed kind stuff, and things like that
01:19:24 <skew> polli: if you have any questions, sounds like now is the time!
01:19:38 <polli> is it possible to import "normal" .hs modules to a .ghs?
01:19:46 <polli> polli: yes, seems like it :)
01:20:15 <kosmikus> polli: that's relatively difficult, but not impossible
01:20:39 <kosmikus> do those .hs modules contain any constructs that GH does not understand?
01:20:53 <polli> kosmikus: ok, I'm trying to use generic haskell combined with the gtk package
01:23:40 <kosmikus> hmm, I never used that package, but it probably consists of a huge number of modules and functions, right?
01:24:14 <polli> yupp
01:25:21 <kosmikus> and do you want to use generic functions on datatypes defined in those modules?
01:26:46 <polli> kosmikus: no, but I want to use the package
01:27:06 <kosmikus> ah, ok
01:27:08 <andersca> hello JaffaCake
01:27:17 <JaffaCake> mornin' ;)
01:27:30 <skew> night
01:27:41 <Lukhas> morning
01:27:50 <skew> aww, I'm outvoted
01:27:55 <Lukhas> seems so
01:28:28 <kosmikus> polli: then it should be possible: the gh compiler has a -C option that causes it to continue even if unresolved names are encountered
01:28:39 <polli> kosmikus: aha :)
01:29:02 <skew> kosmikus: can the compiler operate as a preprocessor, generating haskell files?
01:29:11 <kosmikus> polli: this option is generally unsafe, but if the functions are in imported modules that gh does not know of, and if they do not "contribute" to the genericity, then it should work
01:29:20 <kosmikus> skew: that's all it does
01:29:32 <polli> kosmikus: thanks
01:29:45 <kosmikus> polli: anytime
01:31:27 <kosmikus> polli: which version are you using?
01:31:39 <polli> 1.23
01:33:58 <alanl> hi...does anyone know why the cvs web interface at haskell.org is down?
01:34:46 <JaffaCake> alanl:  cvs.haskell.org was re-installed recently
01:34:55 <JaffaCake> the cvsweb hasn't been brought up again yet
01:37:51 <alanl> fair enough....just wanted to look inside a few files
01:38:13 <JaffaCake> I don't have an ETA I'm afraid, but hopefully soon
01:39:07 <alanl> just wondering simon, would there be much interest in the haskell community if I got around to doing this?
01:39:12 <alanl> http://www.cse.unsw.edu.au/~pls/thesis-topics/sourcenav.html
01:40:19 <JaffaCake> looks pretty cool.... though you might consider doing the parsing in Haskell instead
01:40:41 <skew> say, with GHC's parser :)
01:40:50 <JaffaCake> or Haddock's
01:41:14 <skew> does that handle all the GHC extensions?
01:41:35 <skew> I remmeber some trouble in that direction, maybe with explicit kind signatures
01:41:42 <JaffaCake> Haddock's parser handles lots of extensions (a few are missing, like TH)
01:42:19 <JaffaCake> yes, explicit kind signatures are missing
01:42:35 <alanl> or would you know of some other open source IDE that I can adapt to make it work with haskell?
01:42:36 <JaffaCake> it isn't difficult to add though: just steal the code from GHC's parser
01:43:04 <skew> I would suggest making a library that parsers Haskell and analyzes the dependancies
01:43:06 <JaffaCake> kdevelop, or the IBM one that I keep forgetting the name of
01:43:12 <skew> Eclipse?
01:43:18 <JaffaCake> that's it, thanks :)
01:43:42 <JaffaCake> there are existing efforts for both of those, IIRC, but nothing complete
01:43:55 <skew> or, think about making the most of the code reusable between IDEs
01:44:15 <JaffaCake> yup
01:44:26 <JaffaCake> we're building an API onto GHC along those lines
01:44:33 <JaffaCake> for use in VIsual Studio
01:45:07 <alanl> would you care to elaborate...? 
01:45:52 <JaffaCake> well, an IDE needs to understand Haskell source - at the very least to lex it for colorisation, but maybe parse and even typecheck it too
01:46:16 <JaffaCake> we want to put an API onto GHC to let you use GHC "as a library" for doing this sort of thing
01:46:46 <skew> it would be cool if you could typecheck incomplete expressions
01:47:17 <skew> and tab complete among things with the appropriate type to continue with
01:47:46 <ayrnieu> 1 + <TAB>0<TAB>1<TAB>2<TAB>3<RET>
01:48:17 <skew> nah, let's hit the integers is ascending order
01:48:30 <skew> ;)
01:48:43 <skew> Something like that would be most useful for functions
01:48:50 <skew> excep you have to write a function before its arguments
01:49:09 <alanl> I'm also interested in getting GHC to emit more helpful error messages...would that be really painful to do or does it just need someone to do it?
01:49:36 <skew> it shouldn't be hard for small values of more
01:50:12 <alanl> I'm mostly interested in the syntaxy like errors
01:50:19 <alanl> like ones EVERYBODY makes
01:52:20 <alanl> does anyone know of some good papers/tutorials on calling C from haskell apart from the awkward squad?
01:52:47 <alanl> and other language interfacing issues in haskell?
01:54:10 <skew> Reid's guide
01:54:14 <skew> http://www.reid-consulting-uk.ltd.uk/docs/ffi.html
01:54:26 <skew> the FFI addenum to the Report
01:55:31 <skew> and a suggestion from me to be careful importing function pointers. Forgetting that "&" will try to call the function and use it's result instead
02:36:39 <skew> that is, if you want to do it the right way and robustly and all that
02:36:52 <skew> er, ECHAN
02:37:17 <Lukhas> hehe
02:43:07 <Hyp3rion> ÊúÄËøëÁâà„ÅØ„Åß„ÅÇ„Çã‰Ωï
02:43:22 <Hyp3rion> >_< Err sorry. Wrong channel :-(
02:43:42 <Iter> mmm don't think I have that charset installed :)
02:44:51 <Hyp3rion> UTF8 Japanese... Mostly Kanji tho, so you would also need Chinese i suspect...
02:45:07 <Lukhas> Iter: me neither
02:45:20 <skew> worked fine for me
02:45:24 <skew> not that I can read any of it
02:45:38 <Hyp3rion> Heh
02:45:49 <Hyp3rion> skew, Can I /VERSION You?
02:46:04 <skew> dunno, try it
02:46:13 <Hyp3rion> Wow.
02:46:21 <Hyp3rion> UTF8 in Irssi. Great
02:46:55 <skew> come to think of it, I don't know if Irssi knows anything about UTF-8
02:47:03 <Lukhas> but your console does
02:47:08 <skew> yeah
02:47:22 <Iter> correct me if I'm wrong, but it isn't so much that there's a difference between isomorphisms and homomorphisms, but that isomorphisms are a restricted subset of the homomorphisms for a category?
02:47:57 <skew> well, isomorphisms are special morphisms
02:47:58 <Maddas> I could read it fine
02:47:59 * Iter has been getting himself confused over that for the past week, unless of course I'm still confused.
02:48:01 <skew> but they are the ones with inverses
02:48:05 <Maddas> (irssi)
02:48:23 <skew> I wonder if irssi would properly wrap a long line with UTF-8 and double width characters
02:48:37 <eivuokko> I think it does not.
02:48:48 <Lukhas> isomorphism doesn't change the object at all, homomorphisms keeps the same shape, but not forcibly the same content
02:48:50 * eivuokko has had wrapping problems with irssi
02:49:07 <skew> also, it's not quite correct to talk about a subset of the morphisms unless you have a small category
02:50:11 <Iter> skew: then what's a better way to phrase it?
02:50:56 <skew> I don't know. you don't talk about collections of morphisms too much
02:51:27 <skew> subset is probably fine
02:51:37 <skew> or just talk in plural
02:51:56 <skew> an isomorphism is a morphism with an inverse
02:52:15 <skew> category theory seems to be more about the operations you can do, rather than thinking about collections of things
02:52:34 <skew> it's not really a big issue
02:53:12 <Iter> I'm still very new to category theory.
02:55:41 <shapr> good morning #haskell!
02:55:49 <Iter> evening shapr.
02:55:54 <skew> hi shapr
02:56:50 <skew> hmm, days must be shorter in Sweden.
02:57:04 <eivuokko> names
02:57:18 <eivuokko> Oops.
02:58:31 <skew> I was awake the last time you said that!
02:58:40 <shapr> skew: ok, happy noon to you :-P
02:58:58 <shapr> hi Iter 
03:03:16 <shapr> hi Verditus, looking for Haskell info?
03:03:31 <shammah> mmm that's more comfortable.
03:11:02 <Verditus> Yes, what are you sharing
03:11:13 <Verditus> Rookie
03:11:39 <Verditus> I'm Looking for music and video
03:11:55 <Verditus> Terms?
03:12:55 <eivuokko> It might be me, but I don't understand what you're after.
03:13:34 <shapr> I'll share any videos on my hard drive, but it's one lambda per MB
03:13:58 <tea> good evening room 
03:14:10 <tea> Is there Haskell's music ? (interest)
03:14:23 <shapr> I have 6gb of SICP realaudio files
03:14:29 <Verditus> I was looking for terms that Haskell ask for shearing
03:14:55 <Verditus> SHAPR, reggae music?
03:15:01 <shapr> not exactly
03:15:19 <shapr> no, this is Abelson and Sussman
03:16:06 <Verditus> What? Abelson Sussman?
03:16:25 <Verditus> SICP?
03:16:44 <Verditus> I'm a new user of xnap.
03:17:12 <skew> http://mitpress.mit.edu/sicp/
03:18:12 <shapr> ya know, I should make bittorrents of these
03:18:28 <shapr> though I wish I had the MPGs
03:18:44 <tea> share SICP.rm :)
03:20:13 <tea> can I get the realaudio from mit ? (though im not the student..
03:20:36 <shapr> they had it online for a long time
03:21:45 <tea> I have only the book and mirror of html files.
03:22:59 <shapr> I can put up bittorrents of the rm files tomorrow
03:24:50 <Lukhas> http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/ ?
03:25:00 <shapr> Verditus: this isn't a napster forum
03:25:11 <Verditus> ciao ciaO
03:25:41 <shapr> at least he was polite about
03:26:40 <shapr> Lukhas: oh nice, I thought they went offline
03:26:42 <shapr> yay
03:26:46 <tea> looking the url *
03:26:56 <Lukhas> shapr: i got that url on #emacs :)
03:27:40 <shapr> I wonder why they don't use bittorrent
03:28:23 <eivuokko> Is there an SMTP (client) library in Haskell?
03:33:18 <shapr> I think WASH has one
03:33:30 <shapr> not sure about that
03:33:58 <eivuokko> Thanks, I'll check it out.
03:36:07 <tea> thx u, url. I will watch those movies.
03:36:32 <eivuokko> It seems to me that WASH/Mail uses sendmail to send mail.
03:37:13 <eivuokko> The lack of good nullmailer in Windows makes sending mail from darcs a bit perverse in Windows. :\
03:39:01 <Lukhas> emacs has is own smtp, you could try to batch it.
03:39:07 <Lukhas> bit that's a bit overbloated :)
03:39:46 <eivuokko> Whoa!  I rather port nullmailer or ssmtp to Windows.
03:40:40 <Lukhas> hehe
03:40:43 <eivuokko> Maybe that's not really so bad idea, anyway.
03:47:53 <shapr> wagle: is the Programatica CVS back?
04:12:35 <gintas> I have a little question; I can make matching succeed all the time with lazy binding (~), right? Can I check in the function if the match has failed?
04:13:14 <gintas> e.g., I have f ~a@[x] = 11
04:13:38 <gintas> when the match fails, the value of a is _|_, right?
04:14:03 <skew> why not just use strict matching?
04:14:08 <earthy> errr. :)
04:14:23 <skew> or, just bind a variable and destructure it with a case
04:17:24 <ibid> i sometimes use a@(~(x:_)), then i can use x if i later find that a is nonempty
04:20:58 <gintas> hmm
04:21:44 <gintas> let's say I have a function f, which expects a list of N Ints (N is constant)
04:21:57 <gintas> can I find out N?
04:22:31 <gintas> perhaps by trying iteratively with a list of 1 element, 2 elements, 3 and so on until I get a match?
04:22:55 <kosmikus> if N is constant, then you should not need to determine it
04:23:07 <kosmikus> but I guess I just don't understand the problem
04:23:29 <gintas> well, it's mostly just a question out of curiosity
04:23:55 <gintas> I have written a simple function analyzer
04:24:29 <gintas> it expects functions of type [a] -> b
04:24:55 <gintas> and the functions look like this: f [x, y, z] = x * y + z
04:25:17 <gintas> right now I have to pass the function and the number of arguments to the analyzer
04:25:29 <gintas> I'm wondering if it could figure out the number of arguments on its own
04:26:35 <skew> you could pass functions like f x y z = x*y + z instead, and use a typeclass
04:27:13 <gintas> skew: could you elaborate?
04:27:15 <skew> you could catch pattern match failures, as long as the functions are always strict in the structure of the list
04:27:31 <skew> class ArgCount a where argCount :: a -> Int
04:27:39 <skew> instance ArgCount Int where argCount _ = 0
04:28:20 <skew> instance ArgCount a => ArgCount (Int -> a) where argCount _ = 1 + argCount (undefined::a)
04:29:21 <skew> everything else is probably easier with lists
04:43:47 <gintas> darn, I don't understand most of what you've written :(
04:49:05 <gintas> skew: but if I use functions like f x y z, what would the type of the analyzer function be>
04:49:32 <skew> (ArgCount a) => a -> Result
04:49:46 <skew> you would need to add a few more arguments to actually call it though
04:49:49 <skew> it might be a bit tricky
04:49:57 <skew> what sort of anaylsis are you doing?
04:50:28 <gintas> ah, just experimenting with boolean functions; e.g. comparing them (by complete search) and checking for some properties
04:50:57 <gintas> one of the simplest analyzer functions:
04:50:58 <gintas> funcInT0 :: TestFunc
04:50:58 <gintas> funcInT0 d f        = f (replicate d False) == False
04:51:06 <gintas> type TestFunc = Int -> BoolFunc -> Bool
04:51:14 <gintas> type BoolFunc = [Bool] -> Bool
04:51:50 <gintas> d is the number of arguments here, the thing I want to get rid of
04:52:20 <gintas> funcInT0 tests if a boolean function returns False when all arguments are False
04:55:42 <gintas> so you suggest I have the type BoolFunc = (ArgCount a) => Bool ?
04:56:02 <gintas> oops, (ArgCount a) => a -> Bool
04:56:10 <shammah> could someone please resolve citeseer for me?  My dns seems to have forgotten how to :(
04:56:32 <gintas> shammah: 138.15.10.13
04:57:11 <gintas> I'm completely lost :(
04:57:30 <shammah> thanks.
05:09:09 <gintas> BTW, I just found about ghc interactive mode (I've been using hugs)
05:09:46 <gintas> why would I use hugs when ghc has apparently more verbose error messages and the ability to define functions interactively?
05:10:20 <saz> i use hugs as my calculator
05:10:27 <saz> it's much easier to use than say.. bc
05:10:42 <Jerub> I dunno
05:11:11 <Jerub> I wrote some rather large programs in bc when I was in university.
05:11:45 <Jerub> didn't have matlab at home, so I improvised with bc + gnuplot
05:12:01 <Jerub> scared the heck out of my lecturer.
05:12:10 <shapr> heh
05:12:19 <shapr> do you still have some around?
05:12:30 <Jerub> might do, let me check my backup archives.
05:12:40 <shapr> I'd like to see that
05:12:52 <shapr> gintas: GHC doesn't run on the Zaurus
05:13:05 <gintas> ah
05:13:15 <shapr> and some features are much easier to add to a Haskell interpreter written in C
05:13:17 <gintas> well that only matters if one has a Zaurus :)
05:13:25 <shapr> look at Trex for example
05:13:35 <Jerub> no, doesn't look like it. I think I may have something in a tarball on a cd somewhere
05:13:58 <Jerub> shapr: bc is very C-like, but with arbitary precision.
05:14:58 <shapr> I really enjoyed writing postfix Joy code, but the number system sucks
05:15:14 <gintas> shapr: is GHC implemented in Haskell?
05:15:23 <Lunar^> gintas: sure :)
05:15:28 <shapr> yup
05:15:29 <Jerub> its annoying when a really hideous language gets let down by a merely substandard type/number system.
05:16:06 <shapr> Joy is sexy, I wish there were a serious implementation around
05:16:40 <skew> Jerub: yeah, it's a real pity about Unlambda
05:17:19 <shapr> does it have a decent number system?
05:17:32 <skew> if you write one yourself
05:17:47 <Jerub> I have hopes for forth + parrot
05:18:31 <shapr> I think Joy could be the Python of FP
05:19:36 <shapr> so, anyone has new  code?
05:19:47 * shapr wants his fix
05:20:24 * Jerub thinks
05:20:47 <Jerub> haven't done much in the last week.
05:20:58 <Jerub> mostly latex.
05:22:11 <Cale> nice, this seems to be generating good constraints
05:23:09 <Igloo> I think gstream 0.8 will be entering Debian tonight, so I might have increased workingness of old code  :-)
05:23:31 <Cale> Just finished up a function last night to generate constraints on the physical unit types for nodes in a simplified abstract syntax tree. Now I have to be able to solve them :)
05:24:18 <Jerub> shapr: I'm thinking about a programming problem at the moment.
05:24:30 <Jerub> shapr: I'm not sure how to solve it.
05:25:27 <shapr> what's the problem?
05:25:32 * Igloo also has my toy soft-type checker working now, I think
05:25:35 <shapr> Igloo: yay!
05:25:47 <Jerub> shapr: have you seen the psyco slides?
05:25:56 <shapr> no, where are they?
05:26:07 <Jerub> shapr: where a cute animation shows how psyco works on a section of code?
05:26:24 <Hyp3rion> Is there psyco for other than x86 now?
05:26:36 <shapr> sounds nice
05:26:45 <skew> it's written in pygame
05:26:50 <Jerub> http://www.pygame.org/screenshot.jpg
05:26:58 <Jerub> thats a screenshot.
05:27:29 <Jerub> http://psyco.sourceforge.net/accu2004-psyco.tgz <- requires pygame to run
05:27:51 <shapr> which probably requires OpenGL
05:27:52 <Jerub> see, thats all hardcoded.
05:27:56 <Jerub> nope.
05:28:01 <shapr> oh, cool
05:28:01 <Jerub> pygame != opengl.
05:28:08 <skew> pygame = SDL
05:28:24 <shapr> spiffy
05:28:44 <Jerub> I want to be able to take an executable code listing, and show how state changes with every statement execution.
05:29:17 <skew> what sort of language?
05:29:22 <Jerub> skew: python.
05:30:11 <skew> write a python interpreter in Haskell and instrument it!
05:30:37 <Jerub> not really interested in implementing all of python in order to write this.
05:31:05 <skew> I'm not sure if the interpreter hooks cover everything you would want for that
05:31:06 <shapr> what about PyPy?
05:31:26 <skew> I know you can register callbacks for statements ending
05:31:29 <Jerub> shapr: not done much with it before, should look into it.
05:31:46 <skew> you might need to analyze the bytecode to decide what variables you need to examine after each line
05:32:00 <skew> actually, each statement's own code can only set one variable
05:35:00 <gintas> Jerub: how do I 'run' the contents of accu2004-psyco.tgz?
05:35:19 <skew> gintas: invoke the python interpreter
05:35:59 <gintas> skew: got it. was trying to run the wrong file
05:35:59 <Jerub> gintas: python accu.py
05:36:23 <Jerub> or, python
05:36:26 <Jerub> >>> import accu
05:44:58 <shapr> hej bringert 
05:45:25 <bringert> hej
05:45:30 <bringert> eh, hi
05:47:34 <gintas> could anyone explain skew's code to me?
05:47:37 <gintas> class ArgCount a where argCount :: a -> Int
05:47:51 <gintas> instance ArgCount Int where argCount _ = 0
05:47:56 <gintas> instance ArgCount a => ArgCount (Int -> a) where argCount _ = 1 + argCount (undefined::a)
05:48:50 <bringert> I could
05:48:57 <skew> I could
05:49:04 <bringert> hehe
05:49:45 <skew> ArgCount is the class of functions where we want to know how many arguments they take
05:49:55 <skew> things of type Int are nullary functions
05:49:56 <gintas> ok
05:50:07 <gintas> i.e. they take 0 arguments?
05:50:14 <skew> things of type Int -> a take one more argument than things of type a
05:53:26 <ibid> gintas: correct
05:55:04 <gintas> I still have a very wobbly understanding about type classes :(
05:55:31 <gintas> after declaring this class, I just need to specify the time ArgCount for a function?
05:57:36 <skew> you would apply argCounts to a function to get the count of the number of arguments
05:57:55 <skew> if you just know that the type is an instances of ArgCount you can't call it
05:58:12 <skew> unless you add some methods for doing that
05:58:22 <skew> maybe call :: [Int] -> a -> Int
05:59:05 <gintas> is this valid? ::
05:59:07 <gintas> count :: (ArgCount a) => a -> Int
05:59:07 <gintas> count f = argCount f
05:59:16 <skew> with an instance ClassName Int where call [] x = x
05:59:45 <skew> instance _ a => _ (Int -> a) where call (v:vs) f = call vs (f v)
05:59:49 <skew> gintas: sure
05:59:57 <skew> no reason to do that, but sure
06:00:22 <gintas> ummm...
06:00:24 <gintas>     Illegal instance declaration for `ArgCount (Int -> a)'
06:00:24 <gintas>         (The instance type must be of form (T a b c)
06:00:24 <gintas>          where T is not a synonym, and a,b,c are distinct type variables)
06:00:24 <gintas>     In the instance declaration for `ArgCount (Int -> a)'
06:00:37 <skew> well, that does constrain the return type to Int, but otherwise count == argCount
06:01:16 <skew> add -fglasgow-exts
06:02:22 <gintas> ah, so you're using extensions...
06:02:29 <gintas> that helped to compile the thing
06:02:32 <gintas>     No instance for (ArgCount (a -> a -> a -> a))
06:02:32 <gintas>       arising from use of `count' at <interactive>:1
06:02:32 <gintas>     In the definition of `it': it = count ex
06:03:29 <gintas> I got it to work after adding an explicit type declaration
06:05:27 <gintas> skew: thanks for your help
06:12:20 <shapr> hi iolotusbobo 
06:12:25 <shapr> how's code?
06:12:45 <iolotusbobo> hello shapr
06:12:51 <iolotusbobo> what code shapr?
06:13:59 <shapr> iolotusbobo: any code you're working on
06:15:40 <shapr> gutentag Joachim
06:15:58 <iolotusbobo> ow... :) shapr ... all's fine...
06:16:22 <iolotusbobo> shapr... am currently designing a data store solution and working on another project that's in alpha state :)
06:16:44 <iolotusbobo> shapr... it would be nice to have you back at our channel too
06:19:25 <skew> what channel would that be?
06:21:26 <shapr> #algos
06:21:38 <skew> oh right.
06:21:50 <skew> I wrote the little expert system thing
06:22:07 <iolotusbobo> shapr :) (adv for me ;) )
06:22:09 <iolotusbobo> skew, ??
06:22:42 <skew> isn't this something to do with algosatfreenode?
06:22:50 <skew> there was a page of assorted problems
06:25:36 <shapr> man, I want a source copy of programatica
06:26:41 <shapr> I noticed that being petulant towards a computer isn't an effective debugging method.
06:29:34 <eivuokko> Got annoyed to a program?
06:29:54 <shapr> yup
06:30:05 <shapr> hiya eivuokko, how's code?
06:30:30 <eivuokko> Writing C++ at work....rewriting tree strcutures isn't as much as in Haskell :/  But fun enough :)
06:30:55 <eivuokko> I always get annoyed at programs.  It doesn't help any more than getting angry at anything at all  :)
06:31:09 <eivuokko> *as much fun as
06:31:31 <shapr> I agree, frustration rarely helps
06:33:21 <iolotusbobo> skew ... yes?
06:35:25 <eivuokko> What got you frustrated, shapr?  Haskell or what?
06:36:19 <shapr> nah, Zope as usual
06:38:25 <eivuokko> Ahas.
07:50:30 <cgibbard> hmmm... anyone know how to get darcs to use basic http auth?\
07:50:50 <shapr> could you use an .htaccess?
07:51:11 <shapr> or do you want to push that way?
07:51:12 <cgibbard> I have an .htaccess - but darcs doesn't appear to know what to do when I do a get
07:51:30 <ibid> cgibbard: can you not give the username and password in the url?
07:51:41 <cgibbard> hmm, perhaps :)
07:51:51 <ibid> i mean, the old-fashioned foo@example.com:bar/ or whatever
07:51:56 <shapr> it's calling libcurl, so however curl handles it
07:54:48 <eivuokko> Hmmm.  Wget could handle that, atleast.  But I think you can't skip libcurl if it's linked in.
08:00:16 <cgibbard> yep, that works, it should do
08:28:16 <lewis_m> could someone tell me why hugs says that foldr has type (a->b->b)->b->[a]->b rather than what I think it should be: (a->a->a)->a->[a]->a
08:28:42 <lewis_m> the reason I think that is that if the first argument is an operator like (+), surely in a+b=c, a b and c should all have the same type?
08:28:44 <skew> because it finds most generaly types
08:28:53 <skew> your type is overly restrictive
08:29:22 <shapr> @type foldr
08:29:23 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
08:29:32 <skew> if the first argument is something like (+) then types a and b unify, leaving the type you wrote
08:29:43 <skew> but you can also use it with other things, like (:)
08:30:29 <lewis_m> ah, okay, I follow you
08:32:39 <lewis_m> don't suppose you could give an example of foldr with (:) in it?
08:32:56 <skew> foldr (:) []
08:33:51 <cgibbard> (++) = flip (foldr (:))
08:34:21 <cgibbard> hehe
08:36:58 <shapr> lewis_m: foldr1 does behave like that
08:37:03 <shapr> @type foldr1
08:37:05 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
08:37:47 <cgibbard> The type of foldr becomes more obvious when you realise that foldr is designed to replace the cons (:) with its first argument, and [] with its second.
08:38:22 <cgibbard> cons itself does not have matching types in its two parameters
09:10:04 <atom-z> ugh, just had a computing exam
09:10:17 <atom-z> asked questions like 'explain how the invoice is calculated'
09:37:23 <cbus> chucky: vaken?
09:51:41 <Jad_> a person who thinks of multiple things at the same time
09:51:48 <Jad_> any one knows what is this case called ?
09:52:17 <sorrow> multitasking? ;-)
09:52:19 <Lukhas> Goethe-like ? :)
09:53:15 <Jad_> I need a scientific term, if any knows it..
09:53:30 <Olathe> "Unknowable"
09:53:34 <Olathe> :)
09:55:54 <Maddas> confused?
09:57:28 <ibid> Jad_: can you be more precise?
10:26:45 <gintas> I was wondering, does Haskell have integrated 'caching' of function values?
10:27:27 <gintas> since it's a pure functional language, there are no side effects, and therefore every function always returns the same result given the same arguments
10:27:42 <Lukhas> gintas: oh, btw, your romandigits doesn't work if the number contains 0s :)
10:27:56 <ibid> gintas: not automatically
10:27:56 <gintas> Lukhas: probably, didn't test it that much
10:28:23 <gintas> ibid: that's what I thought
10:28:38 <ibid> gintas: there are problems related to indiscriminate use of memoization
10:28:39 <gintas> but I still think it would be a neat idea
10:28:54 <gintas> ibid: such as?
10:29:15 <gintas> I was thinking along the lines of weak references
10:31:22 <gintas> by the way, how do I easily implement memoization manually?
10:31:27 <shapr> gintas: it's called Common Subexpression Elimination
10:32:02 <shapr> you can do it, but it's often not what you want
10:32:13 <gintas> shapr: thanks
10:32:49 <wagle> uhh... memoized objects are first class objects (uh... "values")..  expressions arent
10:33:52 * shapr wonders
10:34:04 <ibid> gintas: memoization of function values requires in general a hashing operation; if it were done for every function application, performance would suffer
10:34:48 <gintas> it appears that it has been implemented as a Haskell extension, and results were not significant
10:36:07 <gintas> ibid: well, one could to memoization selectively (where explicitly specified by the programmer)
10:36:17 <shapr> yes, I'd like that
10:36:26 <kosmikus> often, you can achieve the same goals as memoization by using sharing; there's also a generic/polytypic implementation of a memo function that makes use of sharing
10:36:42 <ibid> gintas: yes, that would be useful
10:37:13 <wagle> mouse fell off tray, xchat crashes
10:37:33 <kosmikus> gintas: selective memoization is possible using the Memo module, and the memo function
10:37:59 <gintas> kosmikus: neat, thanks
10:39:40 <shapr> wagle: talk about tightly coupled code ;-)
10:40:00 <shapr> wagle: hey, any progress on the programatica cvs?
10:40:27 <wagle> shapr: it still doesn't work?
10:40:47 <shapr> I very much want a copy of the source of the lxr-style source browser, I think it could fit well with the darcs browser.
10:41:44 <shapr> actually, I think programatica and darcs and haddock could be great friends, but I need the programatica sources to try it.
10:42:02 <wagle> when's the last time you tried the anon cvs?
10:42:07 <gintas> hmm, it appears that in Haskell "integers are generally copied a lot", and therefore the Memo module is hampered because it checks for pointer equality
10:42:15 <shapr> not in the last few days.
10:42:35 * shapr tries again
10:42:57 * wagle plays "jeopardy" music
10:43:04 <shapr> heh
10:43:16 <shapr> ahh, I've been memed
10:43:24 * shapr whistles the jeopardy music
10:43:37 <gintas> I guess I like the Python approach more (IIRC it creates a number just once and uses references to the same instance everywhere)
10:44:59 <kosmikus> I guess this happens in Haskell too, as long as you use literals. But once you compute on the integers, new integers are created.
10:45:08 <shapr> wagle: what is a working cvs repo?
10:45:38 <ibid> it might be interesting to have a memoizing Int(eger) constructor :)
10:45:53 <shapr> wagle: thanks for talking to whoever, it works!
10:46:07 <shapr> I should have used -z3
10:46:31 <gintas> ummm, a very stupid question: how do I import modules in GHC interactive shell?
10:46:42 <shapr> :m + Data.Maybe
10:46:48 <shapr> look at :?
10:46:52 <shapr> lots of goodies
10:48:17 <gintas> shapr: missed :module, as I was looking for something like 'load'...
10:48:35 <shapr> gintas: neat tricks: 'stuff <- getContents ".zshrc"' and 'let foo x = x + 1'
10:48:53 <shapr> few others, but I can't think of them at the moment.
10:49:39 <shapr> whew, programatica cvs is big
10:50:21 <shapr> what's Humake?
10:50:40 <shapr> seems to be an hmake clone
10:50:57 <Igloo> Who cloned it? And why?
10:51:21 * shapr dunno
10:51:37 <shapr> Thomas Hallgren, Programatica
10:51:41 <shapr> http://www.cse.ogi.edu/~hallgren/Programatica/tools/INSTALL.html
10:51:47 <shapr> that mentions hmake
10:51:53 <shapr> er, Humake
10:53:04 <shapr> huh, InternetLib has support for GIF and PNM
10:53:30 * Lukhas whishes he could define a function by just giving some examples...
10:53:59 <Lukhas> splitte "MCM" ==> ("M","CM") ; splitte "VII" ==> ("VII") ...
10:54:10 <eivuokko> Oooo, Programmatica features look cool.
10:54:23 <Igloo> You can, as long as your examples make it clear what should happen in each case  :-)
10:54:54 <Lukhas> yeah, but i want a general behavior
10:55:04 <shapr> eivuokko: I thinking programatica + darcs = http://fit.c2.com/ for Haskell
10:55:13 <Lukhas> i don't feel like giving all the cases to the function
10:56:15 <shapr> can you generalize?
10:58:12 <gintas> darn, how do I import the Memo module (which is in the util category)?
10:58:21 <shapr> :set -package util
10:58:42 <gintas> ah
10:59:16 <gintas> shapr: yay, thanks
10:59:30 * shapr bOings
10:59:37 <eivuokko> shapr, I am not familiar with that site, either.....it's big...
11:00:24 <shapr> eivuokko: in essence, allow your developers to put unit tests into a wiki, and turn the tests red or green according to success
11:00:44 <eivuokko> Aha!  I have heard of that idea before :)
11:01:17 <eivuokko> Thanks for quick explanation...I seem to get lost on that site.
11:01:21 <shapr> programatica already supports 'certificates' which can be HUnit, QuickCheck, Alfa proofs, etc
11:01:53 <shapr> and it has that nifty lxr-style html cross ref Haskell source browser
11:02:05 <Lukhas> i don't get a single word of what you're talking about :)
11:02:33 <eivuokko> Hmmm.  The ideas are good.  I hope this doesn't turn up as one of those buzzword tours :)
11:02:57 <gintas> shapr: what's QuickCheck?
11:03:04 <eivuokko> Hm, so Programatice cvs doesn't work?
11:03:21 <shapr> Lukhas: click on the "Run: http:run.cgi" at the bottom of http://fit.c2.com/wiki.cgi?SimpleExample
11:03:26 <shapr> eivuokko: does now
11:03:49 <shapr> thanks to wagle for talkin to the folks over there.
11:05:14 <shapr> if you have trouble with cvs, I can put up a bz2
11:05:34 <Lukhas> shapr: oh, ok, i get it
11:06:01 <Lukhas> thanks :)
11:07:18 <shapr> so, I'd like to extend that some, let anyone write unit tests into a wiki, use User Mode Linux so you don't get screwed, and see if that makes open source bug reporting easier
11:07:33 <eivuokko> Heh
11:07:45 <shapr> for example, darcs has the trackdown command
11:07:54 <eivuokko> Indeed.
11:08:47 <shapr> trackdown iterates a rollback && test cycle until the new test passes, so you can find where the ;ug crept in
11:08:53 <shapr> "bug"
11:08:58 <gintas> how do I specify in code that I want Memo in package util?
11:09:20 <shapr> hm, can you put -package in a pragma?
11:09:46 <shapr> I usually use ghc -package foo --make Foo
11:10:14 <Igloo> You shouldn't need -package util with --make
11:11:28 <Jad_> ibid: it`s called brain mutlitasking
11:11:40 <Jad_> http://www.apa.org/releases/multitasking.html
11:11:53 <Jad_> http://www.apa.org/journals/xhp/press_releases/august_2001/xhp274763.html
11:12:08 <shapr> there's also semitasking ;-)
11:12:15 <ibid> Jad_: wasn't that offered?
11:12:33 <shapr> that's where you doing several things at once, all of them badly.
11:12:39 <shapr> like windows 3.1
11:12:49 <Jad_> ibid: yep.
11:12:56 <Jad_> and that`s the scientific term for it..
11:13:07 <shapr> hej cbus, vem √§r du?
11:13:12 <ibid> okay, evvk :)
11:13:48 <cbus> shapr: nÂgon pÂ chuckys skola bara
11:14:13 <shapr> har du provat #haskell.se ?
11:14:20 <cbus> nope men fixade problemet :)
11:14:27 <shapr> okej
11:14:33 <cbus> var bara ett litet problem med read typ
11:14:46 <shapr> awright
11:14:56 <cbus> har liten deadline ikv‰ll pÂ en labb n‰mligen :)
11:15:23 <shapr> hm, utf8 makes it hard to read latin1
11:15:43 <shapr> cbus: coming to EuroHaskell?
11:15:48 <Hyp3rion> shapr, latin1 is a subset of utf8
11:15:55 <ibid> Hyp3rion: it's not
11:15:58 <cbus> shapr: EuroHaskell?
11:16:05 <ibid> Hyp3rion: latin1 is a subset of unicode but not utf8
11:16:06 <shapr> @eurohaskell
11:16:06 <lambdabot> less talks, more code!
11:16:06 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
11:16:06 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
11:16:28 * shapr pats lambdabot 
11:16:39 <Hyp3rion> ibid, Err sorry...
11:16:50 * shapr feeds lambdabot a juicy existential type as a reward.
11:17:29 <Igloo> shapr: You might be able to port http://urchin.earth.li/~ian/utf8/trans.pl to your client
11:17:32 <shapr> cbus: it'll be fun, wanna see the tshirt design?
11:17:59 <cbus> sure
11:18:39 <shapr> http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg
11:19:16 <cbus> hmm seen that dude at school :)
11:19:37 <shapr> yah, he's one of the organizers for EuroHaskell
11:20:26 <shapr> anyway, it'll be fun, code and socialness
11:20:51 <shapr> and you can hear swedish as spoken by someone from swwet home alabama
11:21:00 <cbus> haha nice :)
11:21:44 <shapr> not quite as bad as sk√•ne...
11:22:23 <cbus> hmm so is there any real project using opengl for haskell?
11:22:57 <shapr> there was that cool tank game
11:22:58 <cbus> just started to like haskell some months ago
11:23:00 <cbus> hated it before
11:23:17 <cbus> when i started to get the hang of it, it became really nice :)
11:23:26 <shapr> well, it takes some mindtwisting at first
11:23:45 <cbus> hehe yeah :)
11:24:00 <cbus> starting to think and solve problems with recursion is hard
11:24:27 <shapr> and once you 'get it', going back to loops is hard.
11:24:56 <shapr> I get paid to write python, but I tend to blow the recursion limit nowadays.
11:25:02 <eivuokko> Hm.
11:25:44 <eivuokko> I don't find that to be a problem.  But FP did require a twist at first.  Logic programming more so, tho.
11:26:08 <shapr> wow, #haskell has 101 clients, neat
11:26:10 <cbus> i usually code c++ but i like the way of doing functional programming aswell
11:28:20 <shapr> I really like building a pipeline and and letting lazy evaluation take care of keeping memory usage low.
11:33:05 <eivuokko> Hm.
11:33:15 <eivuokko> shapr, did you compile Programatice already?
11:33:34 <eivuokko> I mean, it requires Fudgets?  Do you have version that works "out-of-thex-box"?
11:33:49 <eivuokko> I don't feel like starting to fix that...
11:35:33 <eivuokko> Oh, there was another dir with more snapshots.
11:41:43 <cbus> hmm damn why do i always forget how to use ifs? ;)
11:42:01 <eivuokko> Huh?
11:42:28 <eivuokko> What do you write then?  A case?
11:42:58 <cbus> i usually dont need ifs :)
11:43:54 <eivuokko> Yes.
11:47:01 * eivuokko gives up and gets a precompiled binary
12:06:56 <Lukhas> proof is made, you can write crappy code in Haskell too, i'm the living proof :)
12:11:26 <Dark|Shadow> howto concat a list of chars with a single char?
12:13:05 <Lukhas> list ++ [char] ?
12:15:13 <Dark|Shadow> thank you
12:17:25 <Lukhas> you're welcome
12:38:39 <stepcut> ('a':"pple")
12:39:07 <stepcut> @eval ('a':"pple")
12:39:08 <lambdabot> apple
12:40:14 <Dark|Shadow> :o)
12:40:55 <Dark|Shadow> @eval ("appl"++[e])
12:40:55 <lambdabot> unbound variable: e
12:41:04 <Dark|Shadow> ;)
12:43:48 * Marvin-- is hellishly nervous
12:44:14 <stepcut> Marvin--: oh?
12:44:22 <stepcut> thesis stuff (or something?)
12:44:40 <Marvin--> yeah, presenting my "master" thesis tomorrow
12:44:51 <stepcut> @eval ("appl"++['e'])
12:44:51 <lambdabot> apple
12:45:36 <stepcut> i thought I might want to go back to school, but now I think I was wrong, I think what I really want is to become a wacky inventor
12:46:54 <opet> stepcut: do you have a suitably funny haircut?
12:47:52 <Marvin--> go mad scientists!
12:57:05 <stepcut> opet: working on it
13:01:42 <Hyp3rion> Anyone knows whaddiz "Balashwaar Baksheesh"?
13:03:14 <monotonom> http://www.google.ca/search?q=Balashwaar+Baksheesh
13:03:48 <Hyp3rion> Hehhah
13:03:57 <Hyp3rion> monotonom, Okaygonnaseewthatta
14:08:11 <eivuokko> How one is supposed to read a contents of a file strictly.  readFile and hGetContents are lazy.  Should I just seq over whole String?
14:13:07 <monotonom> Yuck. I don't know why you want to do that, but yes you can do that, seq over the string.
14:13:32 <Marvin--> hGetChar and hGetLine are strict
14:14:06 <eivuokko> Hm.  Maybe I use hGetChar then.  Thanks.
14:14:13 <Marvin--> you could also use hGetBuf
14:14:21 <Marvin--> but then you enter the realms of pointers
14:14:32 <eivuokko> And I need to read the file (not big), which is going to be deleted (temp file).
14:14:40 <eivuokko> Ah, no thanks :)
14:14:57 <Marvin--> hm, but deleting a semiclosed file shouldn't be a proble, should it?
14:15:26 <eivuokko> I am not sure, but it seems the only explanation why darcs is having problems with temporary files.
14:15:43 <eivuokko> In Windows, that is.
14:17:27 <Marvin--> oh
14:17:28 <Marvin--> Windows
14:17:30 <eivuokko> There are things like bracket mktemp removeFile foo, and in foo writeFile f, run user editor, readFile f.  What else could it be?
14:17:44 <eivuokko> I might have of course overlooked some other action...
14:20:11 <Marvin--> I have no idea what removing a semiclosed file does in windows
14:20:51 <eivuokko> Windows is somewhat more protective on files.  On normal situations it is somewhat hard to delete a file someone else uses.
14:21:01 <eivuokko> *more protective than unixes
14:21:03 <Marvin--> right
14:22:36 <Marvin--> but if the running user editor works fine, it's hard to see the problem being anything else than readFile
14:23:29 <Marvin--> but using hGetChar and then hClose should do the trick
14:23:42 <cbus> hmm damn i have a small problem
14:24:14 <Marvin--> good thing it ain't a big one :)
14:24:34 <cbus> if i try to write some show:ed tree to a specific file it complains but if i do something like writeFile "wordfile" "aoeu" it works
14:24:45 <cbus> (wordfile is the file im trying to write to)
14:25:02 <cbus> and if i try to write the same stuff that it failed to write to wordfile to another file it works
14:25:09 <cbus> any idea what may be wrong?
14:25:11 <Marvin--> well, what precisely does it say?
14:25:46 <cbus> Program error: Prelude.read: no parserunhugs: Error occurred
14:25:58 <Marvin--> *read*
14:26:11 <Marvin--> not *show*
14:26:21 <Marvin--> so it seems like the problem is elsewhere
14:26:54 <cbus> ill paste some code if its ok
14:26:54 <cbus> writeFile wordlist (show (put mytree ordNameRead (explNameRead,urlNameRead) ))
14:26:58 <cbus> that fails while this is ok
14:27:02 <cbus> writeFile "aoeu" (show (put mytree ordNameRead (explNameRead,urlNameRead) ))
14:27:04 <cbus> so :)
14:27:22 <Marvin--> and wordlist = "wordfile"?
14:27:34 <cbus> wordlist = "wordlist"
14:27:52 <cbus> (i try to read from that file earlier)
14:28:16 <Marvin--> see, what goes wrong is a call to read, not show
14:28:19 <cbus> was worrying about that it didnt close that file earlier when i read it but was told that readFile closes the file directly after it was complete
14:28:32 <Marvin--> that's only semi-true
14:28:36 <Marvin--> it semi-closes the file
14:28:49 <Marvin--> reusing file names is a tricky business
14:28:51 <cbus> but the read works perfectly if i output the tree to another file
14:29:09 <Marvin--> but do you read from that other file or do you read from wordlist?
14:29:10 <wagle> anyone have the url for hOp?  i still havent managed to bookmark it
14:29:20 <cbus> so i see it like that its having problems with filewriting rather than the parsing for read since it works if i output to a file named "aoeu"
14:29:27 <cbus> i read from that file
14:29:39 <cbus> manipulate the tree and try to update the file by rewriting it
14:29:50 <Marvin--> cbus: could you paste the whole code to the paste page?
14:29:52 <cbus> the file isnt even big
14:30:15 <Marvin--> http://haskell.org/hawiki/HaskellIrcPastePage
14:30:40 <eivuokko> wagle, http://etudiants.insia.org/~jbobbio/hOp/ is what I have in my bookmarks
14:30:50 <wagle> eivuokko: thanks
14:31:10 <cbus> Marvin--: ill paste you a link in private :)
14:31:22 <Marvin--> cbus: ok
14:32:26 <kosmikus> cbus: why private?
14:32:37 <cbus> school-lab, prefer not to spread it :)
14:33:37 <wagle> eivuokko: huh..  thats much more informative than the one i had
14:34:39 <eivuokko> wagle, I think there were two links, one to the guy who made initial version, adn the one I gave to they guy who continued.  Or something like that.
14:34:51 <wagle> ahh..  i had been looking at www.macs.hw.ac.uk/~sebc/hOp
14:55:38 <wagle> cool.  it runs on virtualPC on my powerbook
14:57:19 * Marvin-- runs around and panics some more
14:58:21 <eivuokko> Panic?
14:58:33 <Marvin--> I'm nervous
14:58:55 <eivuokko> Why's that?
14:59:02 <Marvin--> I'm presenting my master thesis tomorrow
14:59:10 <kosmikus> to whom?
14:59:16 <eivuokko> Oh.  Good luck :)
14:59:25 <Marvin--> to my supervisor and anybody else who I can't lock out :P
14:59:34 <Lukhas> :)
14:59:34 <wolfman8k> Marvin--: just remember - you are a machine
14:59:47 <shapr> so, what's the url for the webcast?
14:59:53 <Marvin--> hah
15:01:07 <kosmikus> you'll do fine
15:01:49 <eivuokko> Marvin, it was the laziness.  Thanks for help :)
15:01:58 <kosmikus> have a single malt, watch a snooker tape :)
15:02:04 <eivuokko> (the readFile vs removeFile problem, that is ;)
15:02:06 <shapr> Marvin--: yah, we're rootin for ya
15:02:16 <Marvin--> kosmikus: haha
15:02:31 <Marvin--> I don't have any whisky left
15:02:54 <Marvin--> first thing I do after the presentation is to go buy something damn expensive though :)
15:03:09 <kosmikus> is this the final thing you have to do?
15:03:35 <Marvin--> well, besides sending the report to the printing press and getting some signatures on a form, yes
15:03:52 <kosmikus> cool
15:05:53 * shapr bOings
15:05:57 <Marvin--> I just wish I could take some time off afterwards, but I have another project to hand in next Monday and then an exam :/
15:08:18 <kosmikus> delegate the exam, then :)
15:08:53 <Marvin--> oh cool, you can delegate taking exams? :)
15:09:16 <Marvin--> (I'm still taking courses)
15:10:34 <kosmikus> no, not really, but didn't you just say you were finished except for formalities after the presentation. now, I can understand having another project, but why an exam?
15:10:51 <Marvin--> oh, sorry for the confusion
15:11:04 <Marvin--> formally, the thesis is just another course you take
15:11:33 <Marvin--> I'm also taking a course on randomized algorithms, that's where I have a project and an exam
15:11:54 <kosmikus> ok
15:12:06 <Marvin--> sure, as soon as the thesis is finished, I can apply for a degree
15:12:45 <kosmikus> so, when will you be done
15:12:47 <kosmikus> ?
15:13:08 <Marvin--> completely completely done? Eh, they take forever processing the applications for the *degree*
15:13:43 <Marvin--> three, four months until the formalities are done and I have the papers in my hand, perhaps
15:13:43 <kosmikus> what do they do with them? just abstract "processing"? ;)
15:13:49 <Marvin--> I have *no* idea :)
15:14:01 <Marvin--> but it's centralized for the entire university
15:14:02 <kosmikus> how long does it usually take?
15:14:11 <Marvin--> three, four months :)
15:14:51 <kosmikus> that's extremely long
15:15:09 <Marvin--> yes indeed
15:15:19 <kosmikus> strange
15:15:28 <Marvin--> I don't pretend to understand it
15:19:45 <Marvin--> well, I should get some sleep, I guess
15:19:47 <Marvin--> wish me luck
15:20:11 <shapr> good luck!
15:20:39 <eivuokko> Good luck :)
15:21:59 <shapr> greetz SyntaxLaptop! that's a USA hostname isn't it?
15:22:24 <SyntaxLaptop> shapr: sure is :)
15:22:39 * shapr checks the SyntaxBlog
15:22:41 <Igloo> Ah, cool, you got back safely then  :-)
15:22:50 <SyntaxLaptop> Igloo: yup. thanks for hosting me :)
15:22:57 <SyntaxLaptop> not much on my blog yet. I took notes that I have to copy in.
15:23:50 <Igloo> np - thanks for the tuition  :-)
15:24:27 <shapr> ?
15:24:31 * Igloo was just reading reviews on Amazon of hyroglyph dictionaries
15:24:35 <Igloo> Guitar tuition
15:24:40 <shapr> oh
15:24:56 <shapr> have you plect um yet?
15:25:33 <Igloo> Is that meant to be a bad pun?
15:25:34 * shapr wonders if that's a recognizable pun on plectrum and plucked 'em
15:25:39 * shapr laughs
15:25:48 <Igloo> Barely  :-)
15:26:39 * Igloo thinks if I ever need new housemates I should look for musicians
15:29:05 <SyntaxLaptop> Igloo: depends on whether you can put up w/ practicing, which can be very repetative
15:29:09 <SyntaxLaptop> there's a damn car alarm going off outside :( :(
15:29:54 <Igloo> I wouldn't have thought it would be bad as long as it was music rather than the noise I generate  :-)
15:29:59 <Igloo> :-(
15:31:52 <shammah> morning shapr ;)
15:32:07 <shapr> g'mornin shammah, how's trix?
15:32:14 <shammah> going well.
15:32:44 <shammah> spent last night helping a friend with a paper on parser combinators, so my head is swimming atm :)
15:32:57 <shapr> sounds like fun
15:33:51 <kosmikus> shammah: what kind of paper?
15:35:56 <shammah> shapr: it was, but now I have to get myself back in work-mode.
15:36:18 <shammah> kosmikus: I'm not sure where he hopes to submit it.
15:37:35 <kosmikus> what's the topic? or is it still a secret?
15:41:06 <shammah> kosmikus: parser combinators to support earley's algo.
15:42:03 <shapr> that's interesting
15:42:37 <Jerub> but not as interesting as demonstrating executable code using PyPy! ;)
15:42:41 <Jerub> *cough*
15:43:00 <shapr> Jerub: you got something working?
15:43:03 <shammah> morning jerub :)
15:43:08 <Jerub> shapr: no, I went straight to bed.
15:43:12 <shapr> heh
16:01:24 <skew> isn't earley's algorithm more or less complete nodetermanism?
16:23:00 <shammah> opps wrong button.
16:23:48 <Lukhas> romanToIndian "MCDXXI" --> 1421
16:23:53 <Lukhas> woooo hoooo :)
16:24:23 <Igloo> Indian?
16:24:24 <Lukhas> god, i wonder how they managed to conquer so much countries with such a borken system :)
16:24:35 <Lukhas> arabic / indian
16:24:44 <Hyp3rion> hindi
16:24:45 <Igloo> Never heard it called Indian before
16:25:02 <Lukhas> in France it's alternatively indian or arabic
16:25:14 <Lukhas> never seen hindi before, for numbers
16:25:32 <Lukhas> looks like i'll need to find another name, any proposals ?
16:25:43 <Hyp3rion> it was just my stupid religious note...
16:25:55 <Hyp3rion> indian is fine
16:25:59 <Olathe> Should be European, probably
16:26:11 <Hyp3rion> Olathe, no
16:26:15 <Lukhas> romanToDecimal
16:26:23 <Igloo> Arabic is the one I've seen
16:26:24 <Hyp3rion> Olathe, romans were european too
16:26:26 <shammah> or romanToArabic
16:26:28 <skew> I've always heard arabic or decimal
16:26:47 <skew> TeX calls them arabic, for whatever that's worth
16:26:52 <monotonom> The Roman numeral system is not broken. It is an optimized unary system. Addition is (almost) concatenation. Beautiful algebra!
16:26:56 <skew> decimal could mean numbers with decimal points in them
16:27:11 <Lukhas> skew: right
16:27:15 <saz> decimal just means base 10
16:27:20 <saz> no?
16:27:21 <Lukhas> romanToDecimalWithoutDecimalPoints
16:27:21 <shammah> skew: I thought the number system was decimal, the glyphs were decendents of arabic numerals, and hence described as arabic.
16:27:26 <Igloo> merging, surely?
16:27:29 <saz> arabic is the actual way the numbers are
16:27:31 <Lukhas> saz: not exactly, it can have both meanings
16:27:47 <Olathe> The Arabs don't use those characters and they write the right to left, so they really write them starting with the least significant digit.
16:28:00 <Lukhas> a decimal number is a number with a decimal point
16:28:03 <saz> Olathe: in arabic numbers are written left to right
16:28:16 <saz> Olathe: but no, other than the 0 and 1 and 9, the rest look a bit different
16:28:21 <Lukhas> i learnt that years ago, the decimal base is only 2-3 years old
16:28:24 <Olathe> No, in Arabic, words and everything else are written right to left.
16:28:33 <saz> Olathe: look, i know arabic
16:28:41 <saz> numbers aren't
16:28:44 <Hyp3rion> Lukhas, 2-3 thousand?
16:29:16 <monotonom> So how is say twenty three written in arabic? Like 32?
16:29:17 <Lukhas> Hyp3rion: not in my teaching history, i'm not that old you know :)
16:29:21 <shammah> heh, the perils of disputing on the net... far too easy to run into someone who actually knows what they're talking about... :)
16:29:42 <Hyp3rion> Lukhas, :-)
16:30:06 <monotonom> Perhaps I should ask about nineteen instead.
16:30:17 <Lukhas> how about "natural numbers" ?
16:30:30 <Lukhas> romanToNonBrokenSystem
16:30:30 <saz> monotonom: no, it's written 23
16:30:34 <Hyp3rion> bleh, babelfish doesnt have arabic :-(
16:30:36 <saz> LEFT to RIGHT
16:30:37 <saz> ok?
16:30:43 <monotonom> Alright danke.
16:30:54 <mattam> but _written_ right to left maybe ?
16:30:58 <saz> no
16:31:05 <saz> the writing is left to write
16:31:09 <saz> sorry
16:31:15 <saz> the writing the right to left
16:31:21 <saz> anything with numbers left to right
16:31:28 <saz> like maths is the same as english
16:31:30 <Hyp3rion> heh
16:31:36 <Hyp3rion> i pity those arabs
16:31:38 <saz> (now you're confusing me!)
16:31:48 <saz> eh?
16:31:51 <Olathe> SamB : Ahh, you're right
16:31:56 <Olathe> saz, rather
16:31:57 <mattam> if you put numbers in a phrase,  that would seem more sensible to begin with the least significant digit
16:32:16 <saz> that's what happens
16:32:20 <saz> unlike in english
16:32:37 <Hyp3rion> you cannot write text rtl and numbers ltr... you will have to know how much space to leave...
16:32:49 <mattam> so they're _written_ right to left :)
16:33:02 <Hyp3rion> oh
16:33:04 <monotonom> So you mean it is still written right to left, but be sure to write lsb first.
16:33:04 <mattam> wrote maybe
16:33:10 <saz> well
16:33:18 <saz> when i write it, i'd write from left to right
16:33:29 <Hyp3rion> heh
16:33:30 <iehon> Who's on first?
16:33:32 <mattam> well, that's interesting
16:33:34 <monotonom> You are odd. So your hand jumps around?
16:33:34 <saz> i've never seen anyone write a number using the least sig digit first
16:33:35 <Hyp3rion> anyone knows devanagiri?
16:33:37 <shapr> of course the same thing happens in programming
16:33:37 <saz> unless it's binary
16:33:50 <monotonom> Every Arab is odd.
16:33:55 <Hyp3rion> decimal numbers actually come from devanadigiri, not arab afaik...
16:33:55 <mattam> me neither, it would just seem weird to me
16:34:03 <shapr> except those divisible by two!
16:34:42 <Lukhas> http://rafb.net/paste/results/Oj344111.html
16:34:43 <iehon> (I think it came to Europe through Arabic. I recall hearing that in Arabic, they're called "Hindi numbers" or something.)
16:34:45 <shapr> anyway, what's up with foo x = x + 1 ?
16:35:04 <saz> monotonom: it feels just fine.. i thought writing from left to right was rather odd
16:35:06 <shapr> is that right to left, or vice versa?
16:35:17 <saz> iehon: they're the hindo-arabic numbers
16:35:21 <saz> the arabs came up with 0
16:35:22 <saz> iirc
16:35:38 <saz> 1-9 is curtesy of the indians
16:35:40 <monotonom> I only know that (f.g.h.i.j) is right to left. :D
16:35:47 <Hyp3rion> Lukhas, Coolah
16:36:22 <iehon> http://www.scit.wlv.ac.uk/university/scit/modules/mm2217/han.htm
16:36:54 <Lukhas> :-)
16:37:21 <shapr> source is mostly top to bottom, english text is left to right, but x = x + 1 reads very right to left to me
16:37:34 <Lukhas> the cumule func needs to be rewritten, i think
16:37:43 <shapr> cumule?
16:37:55 <Lukhas> check the link i pasted
16:38:11 <shapr> oh
16:38:59 <Igloo> It reads l-r to me - I'm not sure you can even read it r-l as you wouldn't know what x you were talking about when you read the right hand x
16:39:34 <monotonom> It reads top down to me. = at the top, + is a child, ...
16:39:50 <shapr> hm
16:40:32 <Igloo> I think source tends to be a list of sets, so I'm not sure it really has an order
16:40:57 <Igloo> If some sets are "above" other sets then it probably means they should be in a different module
16:40:59 <monotonom> list has order :)
16:41:07 <monotonom> Ah, true.
16:41:10 <mattam> Lukhas: pourquoi tu codes en franÁais ?
16:41:13 <monotonom> Partial order
16:41:23 <Igloo> True, i should have said set of sets
16:41:23 <Lukhas> mattam: parce que je suis franÁais ? :-)
16:41:33 <mattam> trop facile
16:41:36 <Igloo> But flattened into a list for the physical representation, obviously
16:41:39 <shapr> Igloo: that's a neat point
16:41:51 <Lukhas> et comme Áa je suis sur de pas toucher ‡ une fonction prÈdÈfinie
16:42:15 <mattam> pour le coup oui
16:42:23 <shapr> so, is it time to start #haskell.fr? :-)
16:42:34 <Igloo> Hmm, perhaps it should actually be a set and each of my set of sets should be in a different module? Although that would lead to lots of modules
16:42:44 <Lukhas> don't think so, if it's like #emacsfr ... :)
16:43:05 <mattam> lol splitte 
16:43:05 <shapr> peut-etre nous avons besoin d'une #haskell.fr
16:43:12 <Lukhas> mattam: :)
16:43:19 <shapr> men kanske inte!
16:43:34 <monotonom> Everyone should write a program as a graph of modules and in each module a tree of code. All these "you must define before use" or "you must use before define" are red herrings.
16:43:38 <Igloo> Pah, just you wait until I've learnt hyroglyphics!
16:43:49 <Igloo> (are they in unicode?)
16:43:49 <Lukhas> my favourite function in that code is definetely the last one
16:43:58 <shapr> isn't it hieroglyphics?
16:44:17 <Igloo> Yes
16:44:27 <shapr> I'm pretty sure they're in unicode, though not most fonts
16:44:38 * Igloo looks at the amazon search form and finds I could spell it earlier tonight. How odd.
16:44:59 <mattam> nope, Lukhas has to abide by the law of hackers, that is code in english
16:45:06 <shapr> hyro sounds like one of those morphisms :-)
16:45:26 <shapr> hyro :: [Char] -> [Glyph]
16:45:31 <saz> hehe
16:45:42 <Lukhas> mattam: i code alternatively english or french, depending on my mood and/or the word i want to type
16:46:14 <shapr> I sometimes code in Swedish or Lojban
16:46:32 <mattam> isCroissant has a funny meaning to me :)
16:46:37 <monotonom> I code alternatively European or Asian.  European: begin F; G; H end.  Asian: h.g.f
16:46:41 <Lukhas> yeah :)
16:47:03 <Lukhas> but that was not the main goal
16:47:39 <shapr> monotonom: I don't understand
16:48:03 <Lukhas> me neither
16:48:05 <shapr> oh, is that a reference to the writing systems?
16:48:22 <monotonom> Say for example, begin x:=x+1; y:=y+1 end, (\(x,y)->(x,y+1)).(\(x,y)->(x+1,y))
16:48:59 <shapr> words are composed of letters in the west, and pictographs are not easily decomposed?
16:49:13 <saz> shapr: 'in the west'?
16:49:25 <saz> you know.. english is not the only language with an alphabet..
16:49:57 <shapr> that's true, I was showing my American cultural bias I'm sure.
16:50:04 <mattam> Lukhas: you could rewrite extraitCouple as 'fromJust . find (\(x,y) -> y == a)'
16:50:34 <mattam> hmm, some ocamlism has managed to get in there
16:50:47 <Lukhas> hehe
16:50:56 * shapr quickly exorcises the impurity ;-)
16:51:02 <mattam> oh no, -> is haskell too :)
16:51:32 <mattam> thanks for the quick work shapr 
16:51:35 <shammah> shapr: although latin has had a particularly signifigant influence on the development of written european languages :)
16:51:45 <kosmikus> ha, I now have "dangerous lambdas" in my thesis :)
16:51:45 <Lukhas> now, the trick is to understand what it does :)
16:51:59 <shapr> saz: anyway, pictographs are not obviously decomposable into an alphabet
16:52:18 <monotonom> What are dangerous lambdas?
16:52:37 <shapr> though they are composed of other simpler pictographs
16:53:01 <kosmikus> they're my own variant of "dangerous bends", as they occur in the TeXbook
16:53:04 <saz> shapr: i don't think that's always the case (the simpler pictographs), but idon't know any pictographic languages
16:53:45 <monotonom> Ha!
16:54:26 * shapr asks google and wikipedia
16:54:43 <shapr> ya know, maybe programming languages are the same
16:55:07 <shapr> I'd like to be able to ask my runtime code for its supercombinators
16:56:15 <Jerub> ;)
16:56:37 <iehon> (Technically they're usually ideographs, not pictographs, because they're not recognizable pictures anymore in most such systems, but I won't be so pedantic as to point that out.)
16:56:57 * iehon hides Wikipedia in his lap while talking to the group.
16:56:58 <shapr> I think you just did ;-)
16:58:20 <iehon> On the contrary, I specifically said that I didn't. Please pay more attention.
16:58:42 <shapr> hi iehon, are you new to Haskell or just #haskell?
16:58:49 <shapr> right, my mistake
16:58:52 <iehon> Both.
16:59:04 * shapr resolves to read more carefully in the future.
16:59:18 <shapr> got any questions?
16:59:27 <iehon> Too many, at the moment.
16:59:37 <Jerub> shapr: what is the unladen air speed of an african swallow
16:59:42 <shapr> have you already seen the Wiki, the learning page, etc?
16:59:58 <shapr> Jerub: I don't know that! ahhh!
17:00:07 <iehon> Yep. I won't claim to have understood them yet, though.
17:00:10 <Riastradh> Argh!
17:00:13 <Riastradh> You did it all wrong, shapr.
17:00:17 * shapr flies into the <<loop>>
17:00:31 <Riastradh> It was _supposed_ to be:
17:00:38 <Riastradh> Is that an African or European swallow?
17:00:43 <shapr> but
17:00:49 <shapr> he *said* african
17:00:57 <Riastradh> Yes, but he did it wrong, too.
17:01:07 <iehon> Tsk.
17:01:10 <Jerub> bah, I did it right.
17:01:15 <Jerub> I'm a good bridgekeeper.
17:01:28 <shapr> actually, if it was entertaining, it was done right
17:01:47 <shapr> iehon: any questions you feel like asking?
17:02:21 <iehon> Not right at the moment, thanks. But I'll remember the offer and spring some on you when you're least expecting it.
17:02:36 <shapr> ha! no one expects the...
17:02:49 <shapr> wait, this is #haskell, not #python
17:02:49 <Jerub> SPANISH INQUISTION!
17:03:02 <Riastradh> Our cheif weapon is fear.
17:03:07 <Riastradh> Chief, even.
17:03:15 <shapr> ph33r even
17:03:15 <Jerub> Our Primary weapon is SURPRISE! Surprise and Spiffy costumes!
17:03:33 <Riastradh> Wait, what about a fanatical devotion to...?
17:03:43 <shapr> lambda calculus?
17:03:48 <shapr> saz: http://en.wikipedia.org/wiki/Ideograph
17:04:20 <shapr> check out that third paragraph
17:04:52 <shapr> @yow
17:04:53 <lambdabot> YOW!!  I'm in a very clever and adorable INSANE ASYLUM!!
17:05:20 <monotonom> How can an asylum be clever?
17:05:38 <saz> shapr: ah!
17:05:44 <mattam> yow is generally absurd or non-sensical
17:06:01 <monotonom> Fine I won't ask next time.
17:06:33 <mattam> maybe shapr can produce a reasonable answer though :)
17:06:41 <shapr> um
17:06:44 <shapr> uh
17:07:00 <Lukhas> kablam
17:07:22 <shapr> monotonom: unclever insane asylums are where the inmates realize it is in fact an insane asylum.
17:07:51 <shapr> unlike the higher education system in the USA, for example.
17:07:51 <ayrnieu> mono - clever insane asylums refer to any exit from the asylum as 'an egress'.
17:10:08 <shapr> saz: on the other hand, that page very specifically says that pictographs aren't decomposable, so in fact "<shapr> though they are composed of other simpler pictographs" is wrong.
17:10:23 <saz> shapr: yeah, that's the impression i had
17:10:36 <saz> shapr: they may have once been, they're composite, but not decomposable
17:10:50 <ayrnieu> good, then people will stop referring to Chinese characters as 'pictographic'.
17:10:51 <shapr> so imo, my thesis is correct, but my vocabulary is wrong
17:10:53 <Jerub> bah!
17:10:57 <Jerub> but they ARE decomposable!
17:11:01 <Jerub> the very exmaple on that page is.
17:11:38 <shapr> right, but that's an ideograph, not a pictograph
17:11:53 <shapr> now that everyone is confused...
17:11:59 <monotonom> All theses are correct after correcting the vocabulary.
17:12:08 <ayrnieu> but 'ma3', the character for 'horse' in Chinese, could qualify as pictographic.
17:12:56 <ayrnieu> Just for an example -- Chinese has many (but very much the minority) pictographic characters.
17:13:01 <shapr> I'm looking forward to utf8 sources support in GHC, real lambdas!
17:14:06 <monotonom> You can always switch to Java. It already allows identifiers in all languages.
17:14:36 <wagle> try using a chinese -> english dictionary..  the characters do decompose.  more or less
17:15:10 <monotonom> You can for example write <arabic name> = <arabic name> + 1, although I am not sure if true Arabs prefer 1 + <arabic name> = <arabic name>
17:15:16 <iehon> (Real arrows, too.)
17:15:47 <Jerub> what is an arrow anyway?
17:16:20 <ayrnieu> wagle - a Chinese -> English dictionary wouldn't focus very much on characters.  Do you mean to say that Chinese words 'decompose'?
17:16:21 <shapr> it's a generalization of 'function'
17:16:44 <shapr> in essence, a monad that exposes static properties
17:16:52 <wagle> ayrnieu: the dictionary i had did
17:17:12 <shapr> the downside of monads is that you have to call them to do anything with them
17:17:21 <ayrnieu> wagle - did you have a character dictionary with English definitions or a Chinese-English dictionary?
17:17:41 <wagle> ayrnieu: dont remember..  it was 10-15 years ago
17:17:54 <ayrnieu> wagle - probably the first, then.
17:18:13 <wagle> i just remember knowing that i had to decompose, then count strokes
17:18:18 <shapr> Jerub: so, with an arrow based parser rather than a monadic parser, the arrows can expose some of their preconditions to the calling code
17:18:49 <wagle> counting strokes might be difficult for someone not familier with calligraphy, though, i guess
17:19:10 <ayrnieu> wagle - er, sure, if you wanted to look a character up by its radical -- and if you had a pictographic word (such as 'horse'), you'd have to count the strokes.
17:20:04 <shapr> I think it was swierstra and duponcheel who found out that arrows give you that 'ounce of prevention' that's lacking in monads
17:20:09 <wagle> i imagine that horse was "obviously" a single radical
17:20:34 <shapr> Jerub: does that answer your question?
17:20:37 <ayrnieu> wagle - I don't see that as 'focusing very much on characters', so much as 'needing some method of looking characters up in a dictionary' =)  IIRC some russian came up with a niftier system where you look the character up by some other quality.
17:20:57 <Jerub> shapr: its interesting, but I'd have to see usage.
17:21:05 <shapr> imho, arrows are easier to understand than monads
17:21:37 <ayrnieu> wagle - no, dictionaries don't often index by the 'horse' character -- and no character has 'horse' as its radical.
17:22:16 <Jerub> shapr: basically its a function with state?
17:22:41 <Riastradh> Arrows are generalizations of functions.
17:23:06 <Jerub> shapr: int foo () { static int i = 1; i++; return i; } <- can you do that with arrows?
17:23:41 <Igloo> You can do it with monads, and arrows are a superset of the functionality IIRC
17:24:06 <shapr> swierstra and duponcheel realized that a failing input to monadic parsers can usually be figured out just a few characters into the string, but to allow backtracking you had to keep the whole string around just in case, and that ended up being a space leak
17:24:51 <wagle> ayrnieu: the character for horse was in the dictionary..  the dictionary asked you to decompose into "radicals", ergo ... uh something
17:25:08 <wagle> shapr: which swierstra and duponcheel paper you talking about
17:25:10 <shapr> Jerub: I'm parroting the Hughes' arrows paper anyway, he describes it better.
17:25:23 * shapr digs for references
17:25:34 <wagle> you mean the one that highes cites?
17:25:42 <wagle> you mean the one that hughes cites?
17:25:51 <wagle> (shapr)
17:25:56 <shapr> right
17:26:21 <wagle> oh.. my first reading had you saying that they followed on to hughes
17:26:29 <shapr> I know that was swierstra, but it might not have been duponcheel, I haven't read that paper
17:26:44 <ayrnieu> wagle - 'horse' does not 'decompose into radicals'.  Chinese dictionaries tend to have at least three indexes: by pinyin/bopomofo, by radical, and by stroke.
17:26:45 <shapr> oh, I think they did a followup after his arrows paper.
17:27:30 <ayrnieu> wagle - and no character 'decomposes into radicals'.  The vast majority of Chinese characters has a single radical.  ... and then you have www.zhongwen.com's method, also interesting.
17:28:18 <shapr> meeting swierstra at icfp2003 was cool
17:29:26 <wagle> ayrnieu: well, i described what the dictionary had you do.  i know nothing else
17:29:55 <wagle> s/what/what i remember that/
17:29:55 <ayrnieu> wagle - very well.
17:29:56 <shapr> I hope John Hughes shows up at EuroHaskell, I'd like to hear him talk about arrows (and QuickCheck!)
17:30:59 <shapr> Jerub: section 3 of http://www.cs.chalmers.se/~rjmh/Papers/arrows.ps talks ayout swierstra and duponcheel's parsing combinators
17:32:38 <wagle> www.haskell.org/arrows 
17:33:47 <shapr> I haven't seen anything this year about arrows
17:33:55 <wagle> i dont see that hughes has written anything on arrows since 2000.. unless he uses them in his other stuff
17:34:35 <Cale> I think I should really spend some time learning what arrows are all about and where they're a useful technique.
17:34:51 <Riastradh> Does anyone actually use arrows in a practical situation except in parsing?
17:34:57 * stepcut knows some about arrows
17:35:14 <shapr> Yampa uses arrows
17:35:17 <Jerub> Riastradh: There is nothing to computing except parsing.
17:35:29 <Riastradh> Yampa?
17:35:36 <shapr> Yampa does death defying stunts with arrows
17:35:37 <Riastradh> Jerub, oh, shut up, you silly computer scientist!
17:35:39 <wagle> there is no meaning.  there is only syntax.
17:35:56 <Cale> In what facet of program structure do arrows give more control than monads?
17:35:59 <shapr> stuff that makes me want to write warcraft 4 with Yampa
17:36:01 <stepcut> I think arrows could be useful for piping unix processes together, but I have not had time to work on that recently
17:37:08 <shapr> Cale: sections 2 and 3 of hughes paper show how you can avoid space leaks by exporting static properties
17:37:20 <Cale> hmm...
17:39:41 <monotonom> There is nothing in computing except satisfiability of high-order logic formulae.
17:40:14 <monotonom> But of course you can use arrows for that too.
17:40:24 * wagle 's robot whaps monotonom with a stick
17:40:55 <shapr> like it says in that paper, "the ferst component of a parser tells us whether it matches the empty string, and which tokens it can accept first, while the second component does the actual parsing."
17:41:05 <Cale> We should all use machines optimised for evaluating Conway's game of life, and then all programs could be written as games of life. :)
17:41:30 <wagle> CAM?
17:42:55 <shapr> ?
17:43:34 <monotonom> And then we'll all write programs in Perl because there is this Aussie guy who is funded by the Perl community to help add new features to Perl and he chooses new features for writing games of life.
17:44:30 <shapr> I think the floater is not a very inspired symbol for hackers, I want something better.
17:44:53 <wagle> (C)ellular (A)utomata (M)achine..  built by Toffoli and Margolus
17:45:00 <shapr> oh
17:45:16 <wagle> "floater"?
17:45:32 <monotonom> yeah, what is floater?
17:45:41 <shapr> I think it was ESR who chose that
17:45:46 <anduril1> you mean glider?
17:45:47 * shapr digs for url
17:45:57 <anduril1> I think thats what its usually called
17:46:04 <shapr> er, is that what other people call it?
17:46:11 <monotonom> Ah the glider in Game of Life. Yeah ESR suggestes that.
17:46:28 <iehon> http://www.catb.org/~esr/hacker-emblem/
17:46:37 <monotonom> And ESR called it glider :D
17:46:47 <iehon> (Pasting does not imply endorsement.)
17:47:02 <skew> oh, it's definitely called a glider
17:47:13 <wagle> glider generator would be better.  the UTM life form would be best (?)
17:47:26 <Cale> I like the unit cell :)
17:47:27 <skew> the people who prove theoremens about the game of life and build turing machines and stuff call it a glider ;)
17:47:37 <skew> all those are a bit big
17:47:41 <skew> maybe a nice spacefiller?
17:48:18 <Cale> yes, there's a really nice spacefiller which is currently the emblem of a particular life simulator...
17:48:37 <Cale> http://www.igs.net/~tril/gtklife/
17:48:37 <wagle> original articles in sciam called it glider..  Winning Ways for Your Mathematical Games and Plays calls it glider..  ergo...
17:48:56 <shammah> my only exposure to arrows thus far has been Courtney and Elliott's application of arrows to represent frp signals in 'Genuinely Functional User Interfaces'.  As a demonstration of usage it was reasonably clear to me.
17:49:33 <Cale> http://www.ericweisstein.com/encyclopedias/life/Glider.html
17:49:41 <shapr> that's Fruit, right?
17:51:01 <shapr> yes, http://www.haskell.org/fruit/
17:53:54 <shapr> I think an axe or something would be a better hacker symbol. The word came from 'one who makes furniture with an axe' but I'd much rather have something that shows the pleasing elegance of using a system in unexpected ways.
17:54:09 <shapr> maybe #! or traceroute
17:54:16 <monotonom> Duct tape.
17:54:21 <shapr> heh!
17:54:35 <shapr> that's a good point
17:56:07 <shammah> shapr: yeah, fruit.
17:58:22 <Cale> I wonder whether it would be good to adopt arrows as the default, and build a little syntax around them to make them work like monads when that's more appropriate.
17:58:55 <shapr> I've wondered that myself
17:58:56 <Cale> although I suppose there's no real need to choose
17:59:09 <Cale> It would be interesting to see what arrow IO would look like.
17:59:18 <shapr> arrow composition is easier
17:59:37 <shapr> >>> aka flip .
17:59:58 <shapr> monad transformers are more trouble
18:00:19 <Cale> you mean, the arrow generalisation of monad transformers?
18:00:27 <shapr> right
18:00:54 <Cale> hmm - I think that the issue of monad transformers in general needs some sorting out.
18:01:24 <shapr> yup
18:01:27 <Cale> It seems like there ought to be a nicer way to think about that whole issue.
18:01:39 <wagle> Cale: i'm still at the point where i think i understand them less than everyone else..  how do you mean?
18:01:57 <shapr> along with commutative monads and commutative monad transformers
18:02:04 <wagle> .. i'm talking about stuff like liang's stuff
18:02:34 <wagle> but i still monad transformers in the standard prelude
18:02:42 <wagle> but i see monad transformers in the standard prelude
18:03:03 <Cale> wagle: hm?
18:03:23 <Cale> You mean, you predict that monad transformers will eventually be in the prelude?
18:03:38 <Pseudonym> I predict that the prelude will eventually be split.
18:03:45 <wagle> there are some in the standard prelude
18:03:48 <Pseudonym> Monad transformers will eventually be standard, though.
18:05:12 <wagle> ..  i'm thinking of lift, etc. i think
18:06:13 <Cale> wagle: Monad transformers are things like StateT
18:07:43 <wagle> Cale: yes, i know..  but I've heard people refer to lift as a monad transformer
18:08:10 <wagle> i'm not claiming to not be confused)
18:09:08 <Cale> That would probably be a different kind of transformation. liftM takes a function and makes it act on monadic values
18:09:11 * shapr claims to be confused
18:09:25 <Cale> unless you're speaking of some other lifting function
18:09:49 <Cale> Monad transformers transform the whole type, not specific values.
18:09:59 <Cale> brb
18:10:05 <wagle> Cale: the prelude i'm thinking of has other things too, but liftM, liftM2, etc where among them
18:11:20 <shapr> monad transformers let you add State Error etc together to make a monad that has all of them
18:12:20 <shapr> http://www.haskell.org/ghc/docs/latest/html/libraries/ Control.Monad.Identity is the id transformer
18:12:53 <wagle> yeah,,  i'm unconfused just enough to get about half of Liang's stuff to work (in haskell!), but its still all magick
18:12:56 <shapr> note, I'm not claiming to thoroughly understand all that
18:13:20 <shapr> in fact, lambdabot uses several monad trasformers
18:13:38 <Pseudonym> I can vouch for that. :-)
18:13:50 <shapr> because he wrote it ;-)
18:13:54 <Pseudonym> @type liftM
18:13:55 <lambdabot> bzzt
18:14:00 <Pseudonym> Hmmm.
18:14:02 <Pseudonym> @type liftM2
18:14:03 <lambdabot> bzzt
18:14:11 <shapr> @type Control.Monad.liftM
18:14:12 <lambdabot> Control.Monad.liftM :: forall r m a1.
18:14:12 <lambdabot> 		       (Monad m) =>
18:14:12 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
18:14:20 <wagle> @type _
18:14:21 <lambdabot> bzzt
18:14:36 <shapr> Pseudonym: did you see @index ?
18:14:41 <Pseudonym> Is it just me or does the type of liftM look disturbingly close to that of map?
18:14:45 <Pseudonym> fmap
18:14:51 <Pseudonym> shapr: No.
18:14:56 <shapr> @index fmap
18:14:56 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
18:14:56 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
18:14:56 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
18:15:06 <shammah> WOOT! first hard data demonstrating that I've found my order-mag performance improvement! :)
18:15:08 <Pseudonym> Nice.
18:15:15 <wagle> @type Control.Monad.liftM3
18:15:17 <lambdabot> Control.Monad.liftM3 :: forall r m a3 a2 a1.
18:15:17 <lambdabot> 			(Monad m) =>
18:15:17 <lambdabot> 			(a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
18:15:31 <Pseudonym> Aha.  OK, liftM* are actually generalisations of map.
18:15:37 <Pseudonym> Correct?
18:15:42 <shapr> slurps up the *.haddock Binary interfaces and makes an FM
18:15:45 <Pseudonym> @index lift
18:15:45 <lambdabot> Language.Haskell.THSyntax,Control.Monad.Cont,Control.Monad.Error,Control
18:15:45 <lambdabot> Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad.State,Control
18:15:45 <lambdabot> Monad.Trans,Control.Monad.Writer,Text.ParserCombinators.ReadPrec,Text.Read
18:15:53 <Cale> Pseudonym: seems plausible :)
18:15:54 <Pseudonym> @type COntrol.Monad.Trans.lift
18:15:55 <lambdabot> bzzt
18:16:10 <Pseudonym> @type COntrol.Monad.lift
18:16:10 <shapr> I need to trim it to the entries that re-export
18:16:11 <lambdabot> bzzt
18:16:15 <Pseudonym> @type Control.Monad.Trans.lift
18:16:17 <Pseudonym> Sorry.
18:16:17 <lambdabot> Control.Monad.Trans.lift :: forall t a m.
18:16:17 <lambdabot> 			    (Control.Monad.Trans.MonadTrans t, Monad m) =>
18:16:17 <lambdabot> 			    m a -> t m a
18:16:18 <wagle> how do you get the actual implementation?
18:16:27 <Cale> yes, in fact, liftM can be used directly as map
18:16:40 <shapr> wagle: from lambdabot?
18:16:47 <wagle> shapr: yeah
18:17:01 <shapr> you can't
18:17:07 <wagle> awww
18:17:11 <shapr> but you could write a plugin
18:17:23 <shapr> I wrote @info last thursday
18:17:25 <Cale> you used to be able to
18:17:40 <Pseudonym> @info last thursday
18:17:41 <lambdabot> -- last is a variable
18:17:41 <lambdabot> last :: forall a. [a] -> a
18:17:42 <shapr> oh, that was tmoertel's prelude
18:18:22 <shapr> he whacked the prelude into something that dictd can serve
18:18:56 <shapr> he sent me the data, I'll see if I can get it back online
18:19:35 <shapr> but not tonight
18:19:55 <Cale> The list monad is interesting. I don't think I use the monadic functions enough in the context of lists. You can get some pretty nice effects.
18:21:26 <Pseudonym> Cale: The original Phil Wadler paper on monads introduced them as generalisations of list comprehensions.
18:21:46 <Pseudonym> For example: do { x <- foo; y <- bar; return (x,y) }
18:21:59 <Pseudonym> is analogous to: [ (x,y) | x <- foo, y <- bar ]
18:22:21 <Pseudonym> It's kinda interesting.
18:22:41 <Pseudonym> In fact, in response to this, Gofer ditched list comprehensions and only implemented monad comprehensions.
18:22:53 <Cale> yes, I was about to suggest that
18:23:06 <Cale> does it work out very well? Are there any downsides?
18:23:22 <Pseudonym> The error messages that undergrads started to get were way too confusing.
18:23:36 <Pseudonym> Because, of course, you start them off with list comprehensions on the command line.
18:23:44 <shapr> ?
18:24:01 <Pseudonym> That's the main reason monad comprehensions were dumped.
18:24:04 <Cale> and they were getting errors referring to monadic-type stuff?
18:24:09 <Pseudonym> Right.
18:24:29 <Cale> hmm... I can't imagine that as something which is insurmountable
18:24:49 <Pseudonym> You could, I suppose have something like default().
18:25:03 <Cale> Can't the error messages in the context of particular monads be specialised?
18:26:19 <Cale> This is probably a good idea anyway
18:29:12 <wagle> keeno..  my ups "worked" but my system rebooted anyway
18:29:29 <Cale> heheh
18:31:37 <Pseudonym> Or say that if you can't work out what type a list comprehension has, it's of type list.
18:31:37 <Pseudonym> Only for list comprehensions, not for general do-notation.
18:32:52 <Cale> Do you suppose there is some way, rather than having monad transformers, to have a type constructor capable of combining two monads to produce another?
18:33:47 <Riastradh> The compose operator, duh.
18:35:43 <Cale> Riastradh: are you joking, or am I really missing something here?
18:36:05 <Cale> Or neither?
18:36:15 <Pseudonym> Ugh, lag.
18:36:37 <Cale> Ping reply from Pseudonym : 1.19 second(s)
18:36:39 <wagle> wheee
18:39:12 <Riastradh> Cale, the monadic compose operator is in one of those sets of fundamental monad operations.
18:41:25 <Cale> So if m and n are monads, how do we construct Compose m n a, such that Compose m n is a monad?
18:42:17 <ozone> speaking of, has anybody read the "Composing Monads using Coproducts" paper yet?  http://lambda.weblogs.com/discuss/msgReader$12291
18:43:32 <Cale> hmm...
18:43:53 <Cale> It would make sense that the sum of two monads would be what we're looking for :)
18:44:11 <Pseudonym> Except that the sum is disjoint, presumably.
18:44:21 <Pseudonym> You get either THIS monad or THAT monad, but not both.
18:45:53 <Cale> It would be nice to have more category-theoretical magic around. How about the pushout of a couple of monads with respect to another, and some suitable maps? I wonder how computable these things are.
18:47:00 <Cale> in that case, it would be like you "glued" two monads together, making them coincide on certain values.
18:47:09 <Cale> that could get strange :)
18:48:21 <shapr> this is interesting, might be related to David Espinoza's ideas on stratified monad transformers
18:49:02 <shapr> Cale: er, hey, isn't that the commutative square thing?
18:49:08 <Cale> yes
18:49:19 <shapr> can you use that to get commutative monad transformers?
18:49:20 <Cale> it's a commutative square of a particular sort
18:49:26 <Cale> I'm not sure
18:49:41 <shapr> would be handy
18:50:15 <Cale> I actually somehow doubt that pushouts exist in general - especially for things like IO, but perhaps.
18:51:03 <shapr> this paper ozone mentioned has some nice bits
18:53:12 <Cale> The coproduct, after all, isn't *just* disjoint union, but the "smallest" monad containing the disjoint union. You would still have to be able to bind and so on, so I think that often it would end up looking more like the product.
18:53:35 <Cale> (as is the case in the category of abelian groups)
18:53:53 <Cale> I may be completely wrong though :)
18:57:36 <Cale> wow, look at Figure 1.
18:59:03 <wagle> equation (8) is a little more fun
18:59:22 <Cale> yes
18:59:28 <Cale> Just saw that now
19:00:05 <Cale> That's got to be one of the more fun diagrams that I've seen. Wouldn't want to have to chase it though :)
19:00:49 <Cale> Occasionally there are non-planar things which come up, and so the diagrams become 3-D. :)
19:01:17 <Cale> (or the 3-d representation is just more natural for some reason)
19:01:27 <Cale> (no pun intended)
19:02:51 <shapr> truly figure 8 is impressive
19:05:48 * shapr goes to sleep
19:06:29 * wagle goes to dinner
20:09:30 <desrt> Cale; it's kevin :)
20:09:53 <desrt> and now i know who it is too.  he was at your type inference lecture
20:10:01 <Cale> desrt: cool - yeah, I couldn't remember correctly
20:10:04 <Cale> yeah
20:10:36 <desrt> cool enough guy.  was a bit harsh on marking our interim report for our final project in 2d03 :)
20:12:32 <desrt> btw; i figured out what was causing my GL screensaver to glitch
20:13:17 <desrt> it's caused not by a task running in the background but rather by a task sending a lot of data to the X server at the same time (ie: my music playing did it because it was constantly updating the terminal window... i screened it and it stop messing up)
20:17:15 <Cale> ah
20:17:33 <Cale> I have enough lag at the moment to prevent most webservers from talking to me
20:18:35 <Cale> Stupidly configured DSL modem, you see.
20:19:23 <desrt> don't be one to argue with bell
20:19:28 <desrt> cancel (and switch to cable)
20:19:52 <Cale> I think that's what we'll be doing.
20:20:19 <Cale> My dsl connection from bell in waterloo was sweet (3Mbits) - here it's just awful.
20:22:00 <desrt> hm
20:22:12 <desrt> i wonder why you can't just make a really fast sin/cosine lookup table
20:22:30 <desrt> just make your table 28 times the size of the one we have here
20:22:37 <Cale> heh
20:22:39 <desrt> i suppose it increases the working set too much
20:23:54 <desrt> he has some totally whacked out constants in this thing
20:24:05 <desrt> like the sin of 3
20:24:08 <Cale> heheh
20:24:15 <desrt> he also has the cos of 0
20:24:22 <Cale> ?
20:24:27 <desrt> as 0.999999999996880272
20:24:29 <Cale> hahaha
20:24:33 <Cale> why?
20:24:34 <desrt> like, wtf?
20:24:54 <desrt> he has it as one of those fixed-point hexidecimal constants
20:26:36 <Cale> Wouldn't you want to lock that to exactly 1?
20:26:54 <Cale> Or does 1 not have an exact rep for some esoteric reason?
20:27:34 <desrt> i'm relatively certain that you can represent integers exactly using floats
20:27:50 <desrt> just when you go below the point things get weird
20:27:50 <Cale> but it's fixed point, isn't it?
20:28:10 <desrt> fixed/float.. same idea minus the shift
20:28:22 <Cale> yeah
20:28:28 <Cale> oh
20:28:31 <Cale> I read "can't"
20:28:59 <Cale> yeah, you should be able to represent integers within a suitable range exactly, I think.
20:29:05 <desrt> ya
20:29:10 <desrt> like up to 2^63 or so
20:29:21 <desrt> maybe a bit less because you lose a few bits to represent the shift
20:29:33 <desrt> but, certainly, 1 falls well within the acceptable range :)
20:29:55 <Pseudonym> You can represent a 32-bit unsigned integer exactly within an IEEE-754 double precision floating point number.
20:29:56 <desrt> i swear every time i look at this function it gets longer
20:30:19 <Cale> heh, maybe that's his problem - cos(0) being off by just that tiny amount
20:30:19 <Pseudonym> desrt: That's your problem.  Stop looking at it.
20:30:21 <desrt> (and i feel justified in calling this procedure a function because it's pure functional) :)
20:32:11 <desrt> so here's the deal
20:32:36 <desrt> he has this function setup in such a way that he asks it for 256k (k=1024) worth of numbers at once
20:32:37 <Cale> desrt: maybe it would shrink if you bit off a piece of that other mushroom
20:32:52 <Cale> or is that you?
20:34:13 <desrt> O_o
20:34:25 <desrt> i made a mistake
20:34:32 <desrt> it passes the quartersize argument as 256k
20:34:38 <desrt> so the real size is 1meg
20:34:49 <desrt> 2^20 lookups at once
20:35:06 <desrt> is it possible for this to be practical in *any* application?
20:36:03 * desrt gets a hunch and follows it
20:40:22 <Pseudonym> What are you looking up?
20:41:16 <Pseudonym> If you can batch your requests concurrently, looking up 2^20 things can be quite practical.
20:41:19 <desrt> given an array of thetas, return an array of sines and consines
20:41:22 <Pseudonym> Because it can be made very cache efficient.
20:41:24 <Pseudonym> Ah, I see.
20:41:50 <Pseudonym> Well, I can think of quite a few applications that need 2^20 of those computed.
20:42:01 <desrt> is one of them MRI?
20:42:31 <Pseudonym> Could well be.  MRI (and other kinds of CT for that matter) does a huge Fourier transform on the input data.
20:42:41 <Pseudonym> There'd be a lot more than 2^20 samples there, I'd wager.
20:43:06 <Pseudonym> Been a while since I last used a CT machine.  (Though I have, believe it or not.)
20:45:25 <desrt> this code is officially really cool
20:45:35 <desrt> it's doing some funky shit
20:45:36 <Pseudonym> Which official has certified it?
20:45:45 <desrt> i have
20:46:01 <Pseudonym> I didn't know you were a coolness inspector.  Excellent!
20:46:08 <Pseudonym> Great job.
20:46:16 <desrt> i'm an official official of the UN commitee of reallycoolology 
20:47:18 <Pseudonym> I do have a friend who works for the Federal Department of Pop Culture.  He's told me about you guys.
20:47:45 <Pseudonym> My code used to be cool, but it was recently reclassified as passe.
20:47:47 <desrt> is this the american department or the german one?
20:47:55 <Pseudonym> I'm told that in 8 years time it's scheduled to be retro, though.
20:48:03 <desrt> ah.  american
20:48:09 <Pseudonym> No, not American.
20:48:11 <desrt> their terminology is a bit different than the UN adopted standard
20:48:36 <desrt> good, then
20:48:40 <Pseudonym> It's Australian, but we're a signatory to the South-East Asian Trend Convention.
20:48:50 <desrt> oh.  totally cool
20:48:53 <desrt> hip, even
20:48:54 <Pseudonym> So we use their definitions.
20:49:17 <desrt> when they tell you something is due to be retro you'd better keep it in good shape
20:49:38 <desrt> certified retro intangible objects go on ebay for big bucks
20:51:50 * SamB wonders if the halting problem applies to sidtunes
20:52:12 <desrt> Cale; i understand now, why 28 pieces
20:52:42 <Cale> to keep the precision of the approximation within a particular bound?
20:52:53 <desrt> no
20:53:10 <Cale> why 28 then?
20:53:14 <desrt> how many 'parts' (basically) are there to a single cycle of sin or consine?
20:53:17 <desrt> *cosine
20:53:47 <desrt> (i'm looking for '4')
20:53:47 <Cale> about 4
20:53:58 <desrt> up down down up
20:54:32 <desrt> if you have to describe one part of this curve in a vector that will hold 8 values
20:54:39 <desrt> and your first value is 0
20:54:43 <desrt> and your last value is 1
20:54:48 <Cale> but where 7?
20:54:51 <desrt> and the 6 inbetween are the inbetwen values
20:55:01 <desrt> then you've just cut 1/4 of the full cycle into 7 parts
20:55:05 <Cale> yeah
20:55:06 <desrt> 7*4 is 28
20:55:11 <Cale> I know :)
20:55:22 <Cale> but why the 7?
20:55:27 <desrt> i just told you
20:55:33 <Cale> oh
20:55:35 <Cale> right
20:55:51 <desrt> anyway.  it doesn't make sense to me
20:56:06 <desrt> why store 0 *and* 1?
20:56:11 <desrt> when the 1 corresponds to the next 0
20:56:15 <skew> Cale: 7 is used for occult significance
20:56:34 <desrt> seems like a better idea to split it into 32 pieces
20:56:42 <desrt> maybe i'm just thinking too much like a programmer, though
20:56:57 <Cale> yeah, it really does.
20:59:04 <SamB> desrt: because special cases really slow down code?
20:59:11 <skew> hmm, how long is a cache line?
20:59:21 <Pseudonym> skew: Twice the length of a piece of string.
20:59:38 * SamB runs mplayer to find out
20:59:55 <SamB> CPU: Intel Celeron Covington/Pentium II Deschutes,Tonga/Pentium II Xeon 644.9 MHz (Family: 6, Stepping: 2)
20:59:55 <SamB> Detected cache-line size is 32 bytes
21:00:14 <Pseudonym> 32 bytes is usual, yes
21:00:23 <Pseudonym> Double that on a sparc.
21:00:38 <Pseudonym> I think it's double that on an Opteron, too.
21:00:51 <SamB> Pseudonym: what is an opteron?
21:01:14 <Pseudonym> AMD-64
21:02:00 <SamB> I had forgotten momentarily whether it was that or another name for some kind of Itanic
21:02:06 <Pseudonym> No. :-)
21:02:24 <Pseudonym> Actually, oddly enough we found the Itanium 2 to be quite a nice machine.
21:02:30 <Pseudonym> Not as good as the Opterons, mind you.
21:02:39 <Pseudonym> For our application, anyway.
21:04:04 <SamB> well, the only problem with it that I remember is the way-behind rollout and lack of pupularity... not much of a problem for special-purpose applications, right?
21:04:25 <desrt> it's really confusing and inconvenient that 2^8 != 8^2
21:04:38 <SamB> desrt: hehe. 
21:05:06 <Pseudonym> SamB: There were some technical issues, too.
21:05:09 <desrt> this whole 8/16/256 thing is annoying and possibly upsetting
21:05:14 <Pseudonym> The thing wasn't very fast for wht you get.
21:05:24 <Pseudonym> Uhm...
21:05:33 <Pseudonym> Sorry, what I meant to say was: You don't get what you pay for.
21:05:50 <SamB> hehe
21:05:52 <Pseudonym> The other problem we found was the Linux OOM killer, which is a huge pain.
21:06:03 <SamB> oh?
21:06:19 <Pseudonym> Yes.  If you run out of addressspace and try to allocate memory, it fails.
21:06:29 <Pseudonym> If you run out of memory and try to allocate memory, Linux kills your process.
21:07:09 <Pseudonym> Which is a huge pain.
21:07:20 <SamB> Pseudonym: hmm. I've never played with anything that had more RAM than address space anyway.
21:07:32 <Pseudonym> Right, which is why you need a 64 bit machine.
21:07:49 <SamB> even if you only count userspace
21:08:04 <Pseudonym> Anyway, our application has steps which it can take to kill off resources it's using.
21:08:14 <Pseudonym> But Linux won't give it a chance.
21:08:35 <Cale> desrt: yeah, 2^x = x^2 has only three solutions in R, and the third one isn't 8 :)
21:08:42 <SamB> hmm. maybe the OOM killer should give an advisory signal?
21:09:01 <Pseudonym> Linux should reserve some memory for its own emergency use and just refuse the allocation request.
21:09:19 <skew> did you try changing it?
21:09:22 <desrt> perhaps i'm not being very imaginative but i can only think of 2 offhand
21:09:24 * desrt solves it properly
21:10:33 <Pseudonym> Anyway, that's the only problem we've really had with Linux since they implemented real Posix threads.
21:10:59 <desrt> well
21:11:03 <desrt> i can see how 3 solutions would exist
21:11:05 <Cale> desrt: you'll have trouble getting the third - it's negative. Very close to -23/30, but not quite.
21:11:15 <desrt> nod
21:11:19 <desrt> i knew it was negative :)
21:11:37 <desrt> i'm trying to get an explicit form for it
21:11:40 <desrt> (i'm failing)
21:11:43 <Cale> Expressing it analytically requires a special function, afaik.
21:11:48 <desrt> oh
21:11:52 <desrt> i feel less stupid now :)
21:12:19 <desrt> the special function is the inverse of f(x) = x/lnx :)
21:12:23 <Cale> you need Lambert's W function.
21:12:43 <Cale> roughly, yeah
21:13:12 <desrt> mmm.  still 3-0
21:13:18 <Cale> z = W e^W, plug in z, solve for W - that's your function :)
21:13:52 <Cale> and then you can write it as - 2 W(log(2)/2)/log(2)
21:13:53 <desrt> heh
21:14:02 <desrt> "do the impossible and then you will have the function in explicit form"
21:14:11 <desrt> "but sir.. i can't do the impossible."
21:14:13 <desrt> "precisely."
21:14:22 <Pseudonym> Are there any "nice" iterative algorithms for sin/cos which don't use sin/cos?
21:14:39 <Pseudonym> Iterative.  I mean fixpoint.
21:15:04 * Pseudonym asks mathworld
21:15:21 <Cale> Well, you could probably cheat the Taylor representation into giving you something.
21:15:43 <Pseudonym> 3314 formulas for Cosine.
21:15:55 <desrt> pfft. cosine is useless
21:16:43 <Cale> all you really need is the exponential map.
21:16:55 <Pseudonym> cos z = product [ 1 - 4*z*z / (pi*pi*(2*k-1)*(2*k-1) | k <- [1..] ]
21:16:57 <Pseudonym> That's nice.
21:17:24 * desrt yells at cale for his evil power series written in product form
21:17:31 <desrt> i'm going to have nightmares tonight :(
21:17:38 <Cale> heheh
21:18:03 <Cale> desrt is referring to the second equation here: http://vx.hn.org/wiki.pl?MathDiscussion
21:18:43 <Cale> btw - that thing does actually converge in the unit circle
21:19:22 <Cale> but on the unit circle it just fails massively
21:19:55 <Cale> I think every point on the unit circle acts like an essential singularity.
21:20:30 <Cale> anyway - you prove that identity by pushing dots around
21:20:41 <Cale> it's not all that hard, actually
21:23:58 <Cale> You chop a particular diagram of dots up into a triangle and another part, and you say something simple about the other part, and you're done.
21:26:17 * desrt kills unions
21:26:36 <desrt> why he did this is quite beyond me
21:30:05 * Cale tries to plot the imaginary part of that series.
21:30:34 <Cale> It's slow
21:31:04 * desrt blinks as the software produces entirely incorrect results
21:32:12 <Cale> Oh, this looks about right - the function is okay so long as you keep a good distance from |z| = 1
21:32:26 <Cale> or are you talking about the software you're hacking on?
21:33:31 <desrt> ya
21:33:37 <desrt> the results are wildly inaccurate
21:34:14 <desrt> like the sin of pi/6 is 0.502335
21:34:29 <Cale> wow, this is pretty - I wish I could get closer to the boundary of pain without losing all ability to compute the thing.
21:34:31 <desrt> i might be crazy but last time i checked the sin of pi/6 is 0.5 exactly
21:35:02 <Cale> It's 1/2 in fact :)
21:35:11 <desrt> oh.  get this
21:35:22 <desrt> the cosine of 0 is 1.4375 :)
21:35:28 <Cale> sweet
21:35:34 <desrt> i think this is the bug that occurs at boundry conditions that he spoke of :)
21:35:47 <Cale> I'll have to remember that when I want to compute arccos(1.4375)
21:36:04 <desrt> 1.43.. isn't that root2(ish)?
21:36:12 <desrt> hm.  not quite
21:36:12 <Cale> ish
21:36:16 <Cale> 1.414
21:36:27 <desrt> then again.. given the inaccuracy of everything else here... :)
21:36:48 <Pseudonym> @eval sqrt 2
21:36:49 <lambdabot> 1
21:36:54 <Cale> heheh
21:36:59 <Pseudonym> There you go.  Lambdabot has proven it.
21:37:04 <Cale> @eval sqrt 2.0
21:37:05 <lambdabot> <<EM Dynamic -> EM Dynamic>>
21:37:13 <Cale> okay.
21:37:14 <desrt> . is function composition :)
21:37:19 <Cale> right
21:37:30 <Cale> that shouldn't be typechecking then :)
21:37:49 <Cale> of course, the language there is quite simplified
21:38:38 <Cale> poorly behaved functions are so hard to get good pictures of.
21:39:14 <Cale> I might just go and make this a density plot.
21:39:14 <desrt> i wonder if anand is comfortable with results that are only accurate +/- a few %
21:39:29 * desrt emails
21:39:46 <Cale> I think that 1.4 being generated at all is pretty bad.
21:40:00 <desrt> that's the bug though
21:40:02 <desrt> we know about that one
21:40:10 <Cale> ah, okay
21:40:13 <desrt> i'm more concerned about 0.502335 instead of 1/2
21:41:24 <Cale> that might be okay - there are instances where we're only going to request, say, 2 decimal digits of output, and it will have to build the appriximation
21:41:40 <Cale> approximation*
21:43:01 <desrt> i think pi/6 might be a boundry
21:44:09 <desrt> no.  actually pretty sure it's not
21:44:16 <desrt> normalised, pi/6 is 1/12
21:44:34 <desrt> 12 is not a factor of 56
21:49:03 <skew> I'm having an odd problem with GHC
21:49:21 <skew> ghc -c /path/to/file.hs works fine, producing an object file in the same directory
21:49:35 <skew> but, if the file uses template haskell no output files are produced anywhere
21:51:07 <skew> building from the same directory as the file works, though
23:00:51 * SamB wonders why the ICFP website is apparantly done in PHP
23:01:53 <SamB> err, ICFP contest website
23:03:28 <ozone> the perl website's done in PHP, i think.
23:08:31 <SamB> we all knew perl was a mess anyway, didn't we?
23:09:28 <Jerub> yes
23:09:30 <Jerub> yes we did.
23:09:50 <Pseudonym> At least it's not a complete mess, like English.
23:09:57 <SamB> so, whether or not they use PHP is irrelevent
23:10:21 <SamB> Pseudonym: sensible people have stopped trying to get programming in english to work ;-)
23:10:38 <Pseudonym> ADD ONE TO ENGLISH GIVING ENGLISH
23:10:59 <SamB> Pseudonym: I said sensible people, not cobol people.
23:11:14 <Pseudonym> Are there any cobol people left?
23:11:45 <SamB> I don't know. it depends whether they have forgotten it or not.
23:12:51 <ozone> i'd like to be a cobol guy
23:13:14 <ozone> then i can make buckets of money, and spend the rest of my life inventing a language better than cobol (and also buy some fast cars)
23:15:35 <Jerub> ozone: ... 
23:16:17 <Jerub> ozone: the reason cobol people are cobol people is because the langauges better than cobol were invented and became viable, at the time cobol was being used.
23:16:28 <Jerub> oh, nevermind
23:16:35 <Jerub> its too convoluted.
23:16:42 <ozone> Jerub: you ignore the $$$ factor
23:16:45 <SamB> ozone: it is too late for that.
23:16:59 <SamB> there are already plenty of better langs!
23:17:25 <ozone> i think you missed the point of my one-liner, but anyhoo
23:17:38 <SamB> the only reason I can think of to learn cobol is for the purpose of translating so-called legacy software into something new
23:17:41 <SamB> er
23:17:52 <ozone> see above
23:17:52 <Jerub> maintenance programming is the only area cobol guys can live.
23:19:43 <SamB> ozone: no, I'm just really good at accidentally ignoring the jokeyness of jokes ;-)
