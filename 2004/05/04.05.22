01:52:46 <shapr> good morning #haskell!
01:57:06 <Jerub> morning sharp.
01:58:57 * shapr hOps hAppily
01:59:13 <Jerub> @yow
01:59:14 <lambdabot> On the other hand, life can be an endless parade of TRANSSEXUAL
01:59:14 <lambdabot>  QUILTING BEES aboard a cruise ship to DISNEYWORLD
01:59:14 <lambdabot>  if only we let it!!
02:30:27 <shapr> hi gini 
02:31:13 <shapr> so, what's going on folks?
02:31:20 <shapr> lots of code flying?
02:31:58 <shapr> everyone's getting prepared for EuroHaskell?
02:32:28 <Lunar^> :)
02:33:19 <Lunar^> Worked from 2 to 2 yesterday, didn't happen for a long time
02:35:13 <shapr> I wonder what I need to do to get prepared for EuroHaskell
02:36:44 <Lunar^> cheer ! :)
02:37:24 * shapr gets out thelambda pom-poms
02:37:32 <shapr> yay Haskell!
02:37:41 <shapr> dons: g'day!
02:37:49 <Lunar^> beta-reduce the night away :)
02:37:54 <shapr> ha!
02:38:20 <shapr> I need to eta something
02:38:26 * shapr eta-reduces a donut
02:38:31 <Lunar^> lol
02:39:04 <shapr> so many bad jokes, so little time :-)
02:39:30 <Lunar^> We are so funny, why do we have so less friends ?
02:39:56 <shapr> well, there's lots of people here on #haskell
02:40:01 <Lunar^> Can't remember the exact Dilbert quote
02:40:07 <shapr> end they haven't run away screaming
02:40:45 <shapr> yes, I understand the idea though I don't remember the quote
02:43:37 <dons> hey
02:44:51 <shapr> dons: so are you the author of creations such as hs-plugins and "sed : A Simple Functional Language" ?
02:45:10 <dons> ah, you mean, "lsd", lambda-sed :)
02:45:21 * shapr laughs
02:45:32 <dons> yep, that would be me. 
02:45:47 <dons> I'll get lsd out the door in the next few months sometime
02:46:34 <dons> and I hope everyone is playing with hs-plugins
02:50:06 <Lunar^> dons: I'd like to
02:50:32 <Lunar^> dons: hws + hs-plugins means a simple JSP-like server for free I think
02:50:44 <dons> put up a new version today to handle shared dependencies between multiple plugins
02:51:06 <dons> so you can just say, roughly, mapM load [plugin1,plugin2,..] and it will handle it all
02:51:16 <shapr> did you see Kragen Sitaker's writings on sed as a general purpose term-rewriting system?
02:51:31 <dons> ah! no.
02:51:38 <dons> sounds plausible though
02:51:41 <shapr> lambdabot has dynamic reloading of plugins
02:52:05 <dons> recompilation and reloading?
02:52:05 <shapr> using ozone's code
02:52:13 <shapr> nope, not recompilation
02:52:26 <dons> so you can call reload() and get and unload and load?
02:52:29 <shapr> it's just a use of ozone's Runtime Loater
02:52:37 <shapr> @dynamic-reload type
02:52:38 <lambdabot> module reloaded
02:52:47 <dons> yep, sure. that's what hs-plugins sits on top of
02:53:36 <shapr> I'd like to have all the dynamic properties of elisp and still be type-safe
02:53:56 <shapr> as in, able to execute/load a buffer for the current app
02:54:25 <dons> yes. so you'd want to tycheck the buffer, then compile it?
02:54:51 <shapr> it looks to me like hs-plugins is type-safe by virtue of a declared interface in the plugin
02:55:20 <shapr> so, can I declare an interface that returns new interfaces?
02:55:25 <dons> that's the idea of a shared interface. the plugin compiles against the api, and the application compiles against the api.
02:55:49 <dons> hmm.. an interface that returns new interfaces... maybe..
02:55:53 <dons> I can't see why not
02:56:33 <dons> there is a new discussion on type safety for plugins up on the hs-plugins page
02:56:44 <shapr> ah, that sounds interesting
02:56:57 <dons> mostly on why we would should use toDyn to wrap up the interface value
02:57:54 <shapr> hey, are you using Pete Gammie's PLog?
02:58:15 <dons> nope. but a few people are.
02:58:26 <shapr> have you seen Hampus Ram's extension of ozone's code?
02:58:31 <dons> yep.
02:58:33 <shapr> he added dependencies
02:58:49 <dons> doesn't the application author have to specify the dependencies in the application code?
02:59:05 <shapr> have you thought of getting type-safety by running the whole app in the compile loop of Template Haskell?
02:59:18 <shapr> yah, it needs specifying
02:59:47 <dons> hs-plugins uses .hi file information specified by the plugin to work out the dependencies.
02:59:52 <shapr> aha
02:59:57 <dons> that's why you can recompile the plugin, and still hvae stuff work.
03:00:05 <shapr> do you also pull type info from the .hi file?
03:00:08 <dons> because it is the plugin that specifies deps, not the app
03:00:17 <shapr> ah, nifty
03:00:25 <dons> actually, I dump the .hi info out of ghc and parse that
03:00:38 <dons> the actual .hi file parser is a few thousand lines of code
03:00:44 <dons> so I'll need -package ghc to use that
03:00:46 <shapr> yow
03:01:10 <dons> no type info comes from the .hi file
03:01:21 <shapr> what info is in a .hi file?
03:01:47 <shapr> I know, I could RTFM :-)
03:01:54 <dons> dependency info, info about the types of stuff in a module for cross-module inlining etc.
03:01:58 <dons> and strictness stuff
03:02:05 <shapr> neat
03:02:09 <dons> but I only want the dependency info.
03:02:14 <dons> that's what gets put in the .dep files
03:02:24 <shapr> I wonder if that would be handy to have access from haskell-mode
03:02:36 <dons> ?
03:02:44 <shapr> emacs haskell-mode
03:03:07 <dons> ah.. maybe. how else could you find the type of a prelude function?
03:03:15 <shapr> I hacked some code out of haddock to get lambdabot's index command
03:03:25 <shapr> @index foldM
03:03:27 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
03:03:27 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
03:03:27 <lambdabot> State,Control.Monad.Writer,Monad
03:03:40 <shapr> @type Control.Monad.foldM
03:03:41 <lambdabot> Control.Monad.foldM :: forall a m b.
03:03:41 <lambdabot> 		       (Monad m) =>
03:03:41 <lambdabot> 		       (a -> b -> m a) -> a -> [b] -> m a
03:03:46 <dons> where is it getting that from?
03:03:50 <dons> the src?
03:04:21 <shapr> the index command loads Haddock's Binary dumps of the module signatures
03:04:37 <dons> ah, yep, haddock has its own ".hi" files
03:04:48 <dons> hmm.. interesting
03:05:02 <shapr> if you look at the debian ghc6-doc packages, you'll see base.haddock.gz etc
03:05:09 <shapr> @type scanr
03:05:10 <lambdabot> scanr :: forall b a. (a -> b -> b) -> b -> [a] -> [b]
03:05:42 <shapr> type cheats by calling ghc and passing it ":t " ++ name and reading the result
03:05:50 <dons> it would be nicer to get that stuff straight form the .hi file 
03:05:56 <shapr> yah it would
03:05:57 <dons> we need -package ghc 
03:06:17 <shapr> would be handy
03:06:23 <dons> then we'd have a full -fglasgow-exts parser too
03:06:59 <shapr> I'd also like to have something like 'eval' where I could pass a module as a string and have that loaded
03:07:48 <shapr> that would be nice for hOp
03:07:59 <dons> hmm.. could could write that to a file and call hs-plugins' make() and load()
03:08:08 <dons> sort of like hmake
03:08:15 <shapr> ah, but hOp doesn't have a filesystem
03:08:18 <dons> no
03:08:29 <dons> need to read from a buffer
03:09:04 <dons> or compile to ghci bytecode and eval that
03:09:05 <shapr> hOp - http://www.macs.hw.ac.uk/~sebc/hOp/
03:09:34 <shapr> I gotta put the factoid plugin back into lambdabot 
03:10:15 <shapr> yes, a full -fglasgow-exts parser would be nice
03:10:36 <dons> that's the problem I mention with hsplugins' makeWith() function, and with happy too
03:10:40 <shapr> preferably something that returned a TH-compatible structure
03:11:11 <shapr> then you could load and transform arbitrary Haskell sources
03:11:17 <dons> Language.Haskell doesn't give enough extns
03:11:23 <shapr> yup
03:12:01 <shapr> that would give syntax macros too, wouldn't it?
03:12:37 <shapr> oh hey, I didn't introduce myself, I'm Shae Erisson
03:12:43 <dons> I know ;)
03:12:49 <shapr> ok :-)
03:13:19 <shapr> and of course you know blackdog_ saz and seafood
03:13:37 <dons> yep, and ozone and peteg and a few others
03:13:40 <shapr> yup
03:13:58 <shapr> I haven't seen pete in #haskell
03:14:11 <shapr> but we'll both be at EuroHaskell
03:15:04 <dons> you could say hi for me
03:15:28 <shapr> I'm very interested in type-safe dynamic loading, and the extensions like fully serializable types/values
03:15:44 <shapr> I'd like to have all the power of Erlang in Haskell
03:15:51 <shapr> yah, I'll tell him
03:16:40 <ipkiss_> hi
03:17:22 <shapr> bonjour ipkiss_ 
03:17:32 <dons> hm. I don't think I know enough about Erlang 
03:18:04 <shapr> Erlang makes it easy to migrate a running process to another RTS
03:18:21 <dons> yeah, I know that. pretty wild
03:18:44 <shapr> heavy duty runtime reloading, lots of other cool tricks
03:19:01 <shapr> but, syntax isn't as nice, abstractions aren't as nice
03:19:11 <wolfman8k> anyone know about merd?
03:19:41 <ipkiss_> hi am new to haskell, and everything is not clear in my head yet, could someone help me using the Random module?
03:20:33 <shapr> ipkiss_: I usually grab a seed from the clocktime and use that to start up the rng
03:20:36 <ipkiss_> the problem is that randomR takes a generator, and i don't know how to get one (except using getStdRandom, which gives me a IO one)
03:20:53 <shapr> @index mkStdGen
03:20:54 <lambdabot> System.Random,Random
03:21:12 <shapr> @type System.Random.mkStdGen
03:21:14 <lambdabot> System.Random.mkStdGen :: Int -> System.Random.StdGen
03:21:31 <ipkiss_> shapr: mkStdGen needs a seed too, so it's the same problem
03:21:46 <shapr> @type (System.Random.mkStdGen 1)
03:21:48 <lambdabot> (System.Random.mkStdGen 1) :: System.Random.StdGen
03:22:24 <ipkiss_> but it will be the same generator for each execution of the program?
03:22:48 <shapr> yes, unless you use an IO value to get a unique seed
03:23:10 <ipkiss_> how can i do that?
03:23:14 * dons -> gotta go
03:23:22 <shapr> dons: nice meeting you
03:24:01 <shapr> ipkiss_: write you function as a pure function that takes an Int
03:24:54 <shapr> then call that function from monadic code that gets the seed and passes it in
03:25:13 <shapr> lambdabot's quote module does that
03:26:26 <ipkiss_> does this mean that i have to use the seed as arguments of all the functions using random numbers?
03:26:41 <ipkiss_> -s
03:27:07 <shapr> if you want to write them as pure functions, yes
03:27:23 <shapr> there are ways to make that easier though
03:27:53 <ipkiss_> these interest me :)
03:28:09 <shapr> a gen returns two results in a tuple, the random number and another gen that just got that number as its seed
03:29:05 <shapr> so you can write a whole bunch of pure random using numbers that just pass their new gen to the next bit of code that needs another nuwber
03:29:40 <shapr> that means that only the first seed really has to be IO, everything else can take it from the first guy
03:30:11 <shapr> that's also really handy for testing since you get to start at the same seed every time if you want
03:31:03 <ipkiss_> ok, i understand the principle
03:31:12 <ipkiss_> i just hope i'll manage to apply it :)
03:31:23 <shapr> it's easier than it sounds
03:31:45 <shapr> and if you can't figure it out, grab the lambdabot source and look at Yow and Fortune
03:32:05 <ipkiss_> ok
03:32:09 <shapr> and QuoteModule
03:32:18 <shapr> somewhere in there
03:32:47 <ipkiss_> thanks
03:33:46 <shapr> and feel free to ask more questions here when you get them
03:57:49 <dons> Lunar^: re hws+hs-plugins. I hadn't thought of that, but that is a great idea
03:59:16 <dons> it would be easy to compile, load and run random .hs begin fed to you
04:01:28 <ipkiss_> shapr: is it possible to write a function generating random numbers that somehow "saves" the generator from call to call?
04:01:38 <shapr> sure
04:02:18 <shapr> look at the two pieces returned from a gen call
04:03:52 <shapr> ipkiss_: it's easier to pass around a lazy list of random values, there's one such in the Random module already
04:04:51 <ipkiss_> internally, will it compute all the first items of the list every time i need another random number?
04:05:00 <shapr> try it
04:05:10 <shapr> it's easy to try stuff in GHCi
04:05:38 <shapr> you can play with IO values in GHCi by using <-
04:05:47 <ipkiss_> how can i find out how it actually computes things?
04:06:08 <shapr> text <- getContents ".zshrc"
04:06:33 <shapr> if it's a lazy list, it'll only compute as much as you ask for
04:06:51 <ipkiss_> the first time, yes
04:07:35 <ipkiss_> but he next time, will it have memorized all computed values, in order not to compute them again if i ask for element (n+1)?
04:08:03 <ipkiss_> s/he/the
04:08:45 <shapr> I usually pass the 'rest' of the list
04:09:27 <ipkiss_> oh
04:09:57 <ipkiss_> i will try that :)
04:10:20 <shapr> Haskell is all about making stuff implicit
04:12:35 <ipkiss_> it's nice, but coming from the C/C++ world, it's sometimes difficult not to worry about performances issues :)
04:13:29 <shapr> you can get them in Haskell, but in general if you can make it work, it's good enough
04:17:14 * vegai coughs in surprise.
04:17:30 * vegai can
04:17:38 <vegai> ...'t compile ghc-6.2.1 with ghc-6.2.1
04:18:19 <shapr> what's the error?
04:19:10 <vegai> ah, might be a gcc-3.4.0-issue
04:19:34 <vegai> doing make in ghc/utils/ghc-pkg:
04:19:37 <vegai> Main.hs:87: lexical error in string/character literal
04:19:52 <vegai> line 87-88:
04:19:54 <vegai> version = tail "\
04:19:54 <vegai>    \ GHC_PKG_VERSION"
04:20:00 <shapr> oh yeae
04:20:03 <shapr> heard of that one
04:20:06 <dons> looks like one of the cpp changes has got you
04:20:18 <vegai> oh, and check the comment
04:20:22 <vegai> -- hackery to convice cpp to splice GHC_PKG_VERSION into a string
04:20:30 <vegai> perhaps it doesn't need hackery anymore?
04:21:50 <dons> same code is still in the head, you could report this to glasgow-haskell-bugs, perhaps
04:22:15 <vegai> fixing that might break it for earlier compilers, then?
04:22:52 <dons> possibly.
04:23:18 <dons> you could fix it for gcc-3.4 and send that patch with the bug report and simonm might be able to fix it 
04:24:04 <dons> though you may want to check the ghc archives first
04:32:09 <shapr> whee
04:33:03 <vegai> hmm
04:41:08 <dons> time to go
04:41:30 <shapr> irc is inherently async
04:41:57 <shapr> it's half email and half instant messaging system, in my opinion
04:43:16 <tic> all cooked up in a wonderful soup. :)
04:43:29 <shapr> yup
04:44:24 <vegai> I've seen people rather annoyed when I have ... deferred their messages 
04:49:53 <shapr> hi spenatmannen 
04:50:04 <spenatmannen> hi!
04:50:18 <spenatmannen> howya doing?
04:52:37 <shapr> workin, and doing haskell stuff in the parts between
04:52:44 <shapr> how are you?
04:54:55 <spenatmannen> fine... I'm still doing this cgi-lab...
04:56:25 <spenatmannen> Do you know how to fix the והצ in the variables that lookup gets from the inputform?
04:57:27 <tic> spinach-man
04:57:41 <tic> heh.  only people from Chalmers around here :)
04:57:53 <shapr> which ~ do you mean?
04:58:02 <shapr> tic: I'm from Boden!
04:58:06 <shapr> sort of
04:58:12 <tic> shapr, yeah well, I mean people asking questions.
04:59:14 <shapr> well, we get aussies from unsw
04:59:29 <shapr> and autodidacts from all over
04:59:32 <spenatmannen> shapr : have you programed cgi in haskell? 
04:59:39 <shapr> yes I have
05:00:01 <shapr> but I've used several different libraries, so I don't quite know what you mean
05:00:38 <spenatmannen> did you use a cgi-lib of some sort or did you do everything from scratsh?
05:01:02 <tic> spenatmannen, what exactly is the problem?
05:01:33 * tic unzips d1lp4_ptc.zip
05:02:22 <shapr> lately I've used WASH
05:02:28 <spenatmannen> I can't get צהו to work when I get the variables from the input-form...
05:02:43 <tic> spenatmannen, strange, worked when I did it...
05:02:48 <shapr> which library are you using?
05:02:57 <tic> some inhouse thing I think
05:03:04 <tic> spenatmannen, http://www.dtek.chalmers.se/~tic/cgi-bin/ptc-lab4/Main.cgi
05:03:51 <spenatmannen> CGI.lhs
05:04:15 <spenatmannen> it's a file that our teacher provideed us with...
05:07:13 <spenatmannen> tic : your doing the same lab i do... or have done... some year... in a galaxy far far away... I'm almost done with mine... there are just two problems that I have to solve... 
05:07:33 <tic> yes, I did it last year.
05:09:44 <spenatmannen> the והצ-thing... and my insert-script is strange... it does what it is supposed to, although the browser says that there is an internal error.. look : http://www.dtek.chalmers.se/~mikaandr/cgi-bin/insertForm.cgi
05:33:44 <shapr> spenatmannen: seems to work fine
05:33:48 <shapr> g'day saz
05:35:39 <saz> hey shapr!
06:06:08 <ipkiss_> what is the difference between fhe 'rem' and 'mod' functions in the 'Integral' class?
06:08:10 <ludde> ipkiss_: i think they have different behavior for negative numbers
06:10:06 <ipkiss_> ok
06:21:28 * shapr hacks on HaskellDB Forum
07:06:58 * shapr bounces
07:10:23 * bringert compiles wash
07:10:31 <shapr> yay
07:10:45 <shapr> it takes awhile to build
07:12:30 <bringert> whoa, WASHHTML is almost 19000 lines of code
07:13:30 <Jerub> bringert: its becuase it implements all HTML elements as haskell code.
07:13:53 <shapr> which is nifty from one viewpoint
07:13:58 <shapr> and insane from another
07:14:33 <shapr> I wish it would give html-ish type errors when tags mismatch
07:15:57 <Jerub> web sucks.
07:16:55 <shapr> you know something better?
07:17:23 <Jerub> shapr: yes, caves.
07:17:42 <shapr> hmm
07:29:43 <MakeMyDay> is there a way to insert an Element in a list during the construction of that list? 
07:30:02 <MakeMyDay> er that doesn't make much sense does it
07:30:33 <shapr> I'm not sure?
07:34:13 * bringert thinks that it would be hard not to insert elements when constructing a list
07:35:34 <keverets> myList = []
07:35:37 <vegai> it seems that a good grammar/vocabulary checker would be enough to block most spam today
07:35:41 <MakeMyDay> yeah hehe..
07:36:34 <bringert> keverets: true
07:36:44 <bringert> undefined : []
07:36:50 <desrt> keverets; you might be interested: http://www.desrt.ca/ctrace/
07:37:28 <bringert> hmm, would you consider bottom to be an element
07:38:56 <desrt> the .c's are just stupid little programs
07:39:05 <desrt> the .png's are control flow graphs
07:40:12 <desrt> you were right.  graphviz is pretty cool
07:41:59 <keverets> makes drawing graphs pretty easy.
07:42:10 <desrt> ya.  go .dot
07:42:58 <desrt> anyway.  so far that's auto-generated by a makefile, some assembly and a few perlscripts... hopefully i can make it a bit more friendly :)
07:43:01 <ipkiss_> how can i mix a 'do' construct with 'let' or 'where'?
07:44:38 <bringert> you can put 'let' without the 'in' in a 'do'
07:45:21 <ipkiss_> thanks, it works
07:46:00 <ipkiss_> why this difference with normal use of 'in'?
07:46:21 <ipkiss_> of 'let', rather
07:48:47 <np_hard> it's not, really
07:48:48 <MakeMyDay> ok I found out my problem..my data Definition has a Recursive part , and a part that isn't recursive. When I implement a function that is supposed to give out such a data type , I can't seem to figure out a way to go from the non-recursive part , to the recursive part
07:48:54 <np_hard> 'do' is the strange thing
07:49:11 <np_hard> it's a shorthand for monad operations
07:50:57 <edwinb> MakeMyDay: What do you mean by "go from"? What exactly are you trying to do?
07:51:03 * edwinb is trying to understand the question...
07:51:05 <MakeMyDay> like when I get a non-recursive data in my function , I have to stop my fuction there , because I can't implement a recursion of that function in my non-recursive data.
07:51:19 <edwinb> isn't that a good thing?
07:51:32 <MakeMyDay> Ok I have a better way of explaining this.
07:52:46 <MakeMyDay> I have a data type with 2 definitions. One that is recursive , and one that is not. Like just a string or something.
07:53:20 * edwinb imagines a list
07:53:36 <MakeMyDay> So when I cunstruct that data with a function I get to a point where I make a recursion that leads to the non-recursive part.
07:54:09 <edwinb> indeed
07:54:29 <edwinb> do you mean you're writing a function which is recursive over a list/string/whatever?
07:54:39 <MakeMyDay> yes
07:54:55 <edwinb> okay. So eventually you get to the end and have to stop...
07:55:48 <edwinb> Is the problem that you want to insert an element during the recursion?
07:56:46 <MakeMyDay> example:  Data [ Data [ Text "Hello there" ] , Data [ Text "Bye,bye" ] ] 
07:56:54 <MakeMyDay> how can I enter that text.
07:57:09 <MakeMyDay> If I go into that element I can't get out to work on the rest..
07:58:18 <edwinb> Can you paste your data declaration?
07:59:00 <MakeMyDay> > data XML                      =  Text String
07:59:00 <MakeMyDay> >                               |  Tag  Name [XML]
07:59:00 <MakeMyDay> >                                  deriving (Show, Eq, Ord)
07:59:00 <MakeMyDay> > data Token                    =  Begin Name | End Name | PCData String
07:59:00 <MakeMyDay> >                                  deriving (Show, Eq, Ord)
07:59:18 <MakeMyDay> I am making a function [Token] -> XML 
07:59:22 <edwinb> If I'm understanding correctly, the standard thing to do would be to pass an accumulator; essentially the thing to process next/the result so far.
07:59:32 <MakeMyDay> very simplified ofcourse...
07:59:40 <edwinb> ah
08:01:01 <MakeMyDay> I am trying to avoid creating a tree or something like that...
08:01:09 <MakeMyDay> :)
08:02:38 <edwinb> hmm
08:04:39 <edwinb> If you're building a parser, maybe you could also return the tokens you haven't processed yet?
08:22:23 <ipkiss_> how do you debug haskell programs?
08:25:01 <ipkiss_> and how can you force the evaluation of a particular expression?
08:25:23 <ipkiss_> (i.e. refuse laziness)
08:25:54 <Riastradh> @type seq
08:25:56 <lambdabot> seq :: forall b a. a -> b -> b
08:26:18 <Riastradh> x `seq` y    -- Forces evaluation of x and returns y.
08:26:45 <edwinb> ipkiss_: I use "trace" for debugging. Can be confusing though, due to evaluation order.
08:29:03 <ShaminoDC|FBK> how do i def an empty string ?
08:29:18 <Riastradh> 'Def an empty string?'
08:29:43 <ShaminoDC|FBK> xxx :: String -> blabla and the string is empty
08:30:54 <ShaminoDC|FBK> xxx ??? = [] ie but whats ??? ?
08:31:32 <Riastradh> I still don't understand.
08:32:13 <tautologico> do you want to match against an empty string ?
08:32:38 <ShaminoDC|FBK> how to call data String empty ? thats my question
08:33:01 <Riastradh> What do you mean 'call data String empty?'
08:34:24 <ipkiss_> ShaminoDC|FBK: a string is a list of chars, so you can match against [], i think
08:34:33 <ShaminoDC|FBK> k thx
08:52:55 <shapr> mmm, sparkly ideas
08:58:37 <MakeMyDay> I want to do "if a mod m == 0 then blah blah "  , and I want m to keep incrementing until it reaches m. how do I do that. I know there must be a simple way .
08:58:49 <MakeMyDay> until it reaches a sorry
08:58:56 <MakeMyDay> where m = ??
08:59:24 <shapr> @type Until
08:59:26 <lambdabot> bzzt
08:59:30 <shapr> @type until
08:59:32 <lambdabot> until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
08:59:47 <MakeMyDay> there is an until in Haskell
08:59:56 <MakeMyDay> :/ 
08:59:58 <MakeMyDay> I feel stupid
09:00:17 <shapr> nah, you just need to read the Prelude
09:00:18 <keverets> you just have to know where to look for these things
09:00:23 <keverets> such as the Prelude ;)
09:00:40 <shapr> and then try to use each of the functions for something
09:00:57 <MakeMyDay> :)
09:01:02 <shapr> scan weirded me out at first, I didn't see the point
09:01:07 <shapr> now I love it
09:01:55 <shapr> the Prelude is like "with this flavor of language, here's a bunch of code you'd use on a daily basis"
09:05:15 <shapr> emacs po-mode is an infuriating bit of code
09:15:39 <MakeMyDay> I must be stupid because I can't use Until
09:17:02 <shapr> http://www.scannedinavian.org/~shae/src/haskell/Mandelbrot-0.1.hs
09:17:09 <shapr> look at doPoint
09:18:22 <shapr> @type until (> 5) (\x -> x+1)
09:18:24 <lambdabot> until (> 5) (\\x -> x+1) :: forall a. (Ord a, Num a) => a -> a
09:18:42 <shapr> MakeMyDay: clearer?
09:18:57 <shapr> hiya iehon, how's code?
09:19:17 <iehon> Procrastinated is how it is. But thanks for asking.
09:19:42 <shapr> heh
09:19:51 <shapr> I know the feeling
09:22:29 <shapr> MakeMyDay: got it now?
09:22:46 <shapr> spenatmannen: did you get your code working?
09:28:10 <MakeMyDay> if ((a mod n) == 0)
09:28:14 <MakeMyDay> why doesn't this work
09:28:28 <Smerdyakov> What does "not work" mean here?
09:28:36 <MakeMyDay> I get a type error
09:29:02 <ipkiss_> it's mod a n, or a `mod` n
09:29:15 <MakeMyDay> ah
09:29:43 <MakeMyDay> er
09:30:03 * MakeMyDay is getting frustrated with everything.
09:30:33 <MakeMyDay> I just want to check is a mod n == 0 . a is an Integer.
09:30:43 <MakeMyDay> n is the part that I have to increment
09:32:15 <MakeMyDay> and I get that my a does not match " a->b->c " ???
09:33:06 <Smerdyakov> Then apparently n has that type.
09:33:42 <Smerdyakov> Unless you still haven't changed it to call mod in the proper way, as ipkiss_ said.
09:33:53 <MakeMyDay> I did ...
09:33:56 <keverets> until ((==0) . (flip mod 20)) (+1) 1
09:34:05 <keverets> until ((==0) . (flip mod n)) (+1) 1
09:34:10 <keverets> until ((==0) . (flip mod n)) (+1) a
09:34:12 * keverets sighs
09:35:14 <keverets> er, exchange a and n.
09:35:17 * keverets can't read, either.
09:36:41 <shapr> y0 jadrian, wassup?
09:36:49 <jadrian> hello shapr
09:37:23 * jadrian is just tearing apart is program 
09:37:41 <shapr> oh, fun
09:37:48 <jadrian> sometimes you caos is needed to come up with a better order ;)
09:37:59 <shapr> I'm tearing apart someone else's program
09:38:09 <jadrian> ah :)
09:38:10 <spenatmannen> shapr : almost... 
09:38:46 <MakeMyDay> > nonprimes 			:: Stream Integer
09:38:46 <MakeMyDay> > nonprimes			= check nat
09:38:46 <MakeMyDay> > check 			:: Stream Integer -> Stream Integer
09:38:46 <MakeMyDay> > check (Cons a as) 		= if ((a `mod` n) == 0) 
09:38:46 <MakeMyDay> >					then Cons a ( check as)
09:38:46 <MakeMyDay> >					else check as
09:38:48 <MakeMyDay> >				     where 
09:39:02 * MakeMyDay starts to wheep
09:39:20 <spenatmannen> there still is a small problem... 
09:39:32 <MakeMyDay> all I want to do I make n shrink from a to 2
09:40:25 <shapr> MakeMyDay: are you using church numerals?
09:41:12 <MakeMyDay> I have no idea what that is. Stream is a neverending stream of number though in the form of "Cons 0 ( Cons 1 ( Cons 2 ... etc etc
09:41:51 <MakeMyDay> So I take the natural Stream of numbers , and want to take out the primenumbers.
09:42:28 <shapr> ok
09:42:51 <MakeMyDay> in very very stupid way I admit to that..
09:43:01 <shapr> where does n come from?
09:43:20 <MakeMyDay> nowhere..
09:43:53 <shapr> so, what's the logic behind this algorithm?
09:43:55 <MakeMyDay> oh I should pass it on with the check function..
09:44:22 <shapr> can you describe the algorithm?
09:45:14 <MakeMyDay> It just checks to see if the a can be divided with a number between 2 and a-1 . If it does then it returns Cons a ( check as )  .
09:45:20 <jadrian> isn't it just good old sieve of eratosthenes?
09:45:28 <MakeMyDay> well kinda.
09:45:33 <MakeMyDay> I need the nonprimes.
09:45:45 <MakeMyDay> plus this is a neverending Stream ..
09:45:57 <jadrian> well that what the Sieve of Eratosthenes does
09:46:12 <MakeMyDay> yeah ok
09:46:38 <jadrian> I remember it beeing distributed as an example with Hugs
09:46:48 <jadrian> so if you have Hugs you can take a look at it
09:46:54 <jadrian> it has some differences
09:46:58 <jadrian> namely
09:47:01 <jadrian> It uses lists
09:47:04 <jadrian> (for the stream)
09:47:07 <MakeMyDay> yeah I know
09:47:22 <jadrian> and it doesn't take any stream as an argument
09:47:24 <MakeMyDay> I know how it works I can't implement it on lists
09:47:34 <MakeMyDay> and it is pissing me off
09:47:49 <keverets> why can't you implement it on lists?
09:48:05 <jadrian> it is not that different with your stream
09:48:33 <jadrian> all you have there is a list with another syntax
09:49:07 <jadrian> using lists just makes you're life a little easier since you can use all the predifined Prelude and List functions
09:49:13 <jadrian> but you don't even need that many...
09:49:24 <MakeMyDay> jadrian : Yes i know but I still can't get it to work :(
09:50:19 <jadrian> oh wait, it isn't Eras sieve :)
09:50:26 <jadrian> you want the *non* primes!
09:50:34 <jadrian> opsss :)
09:50:39 <MakeMyDay> it still is analog
09:50:46 <jadrian> yes
09:50:50 <jadrian> it is
09:50:51 <MakeMyDay> you just add the ones you would normally leave out.
09:50:56 <jadrian> (sort of)
09:51:04 <jadrian> yeah sort of...
10:00:39 <jadrian> what is a "splice"??
10:00:50 <jadrian> i just foound out i can type:
10:00:54 <jadrian> f$ a
10:00:57 <jadrian> but not
10:01:00 <jadrian> f$a
10:01:22 <shapr> it's template haskell
10:01:31 <jadrian> oh
10:01:34 <jadrian> :-/
10:02:03 <shapr> if you use -no-th you can still do it
10:02:24 <jadrian> oh yes I remember seeing that before
10:04:04 <jadrian> I don't get the decision of including TH in the fglasgow-exts flag... 
10:04:17 <jadrian> seems like something of a completely different nature to me
10:04:45 <jadrian> but I don't know that much of TH so I should better be quiet
10:07:15 <iolotusbobo> hello shapr
10:16:17 <Igloo> fglasgow-exts turns on all the extensions...
10:22:32 <jadrian> Igloo: yes I know, Template (and Generic) programming seems to me like something quite different from pattern guards, paralel list compreension, or even implicit parameters
10:28:45 <shapr> hi iolotusbobo 
10:28:55 * shapr bounces
10:30:16 <iolotusbobo> how r u shapr
10:32:03 <shapr> I am awake.
10:32:07 <shapr> how are you?
10:34:27 <shapr> hi cm
10:34:32 <shapr> how's code?
10:34:38 <cm> hi shapr
10:34:54 <cm> fine, thanks.. brainstorming for a new mejor version of our web framework :)
10:34:57 <cm> how are you doing?
10:35:23 <shapr> doing well, my todo list is shrinking, ergo life is good
10:46:37 <ipkiss_> i have a strange problem:
10:46:51 <shapr> me too!
10:46:59 <ipkiss_> i have an infinite loop, doing a computation and printing a debug message
10:47:38 <ipkiss_> but when i run the program, there is nothing for a while, then suddenly 57 debug messages apear (corresponding to 57 iterations), then i wait again, etc...
10:47:50 <ipkiss_> are the IO functions asynchronous?
10:48:39 <ayrnieu> please consider hSetBuffering
10:49:38 <ipkiss_> ayrnieu: where can i find help on this?
10:49:56 <ayrnieu> in the library documentation, probably.
10:50:54 <ipkiss_> ok, found it
11:07:08 <ipkiss_> how can 'trace' output to stderr without being 'IO something'?
11:10:23 <ayrnieu> ipkiss - possibly by use of functions from System.IO.Unsafe
11:11:53 <ipkiss_> ok, thanks
11:12:04 <jadrian> ipkiss_: there is a trace moudle in ghc
11:12:13 <jadrian> ipkiss_: maybe that's what you want...
11:12:55 <jadrian> ipkiss_: Debug.Trace
11:13:26 <ipkiss_> yes, that's what i was using, but i was wondering how it could work :)
11:13:28 <jadrian> ipkiss_: it just contains a "trace" function
11:13:59 <jadrian> oh
11:59:38 <ipkiss_> when does the GC collect its data?
12:00:05 <ipkiss_> i get a "Heap exhausted" error after a few computations on a big array
12:00:22 <Riastradh> Right before that.
12:00:56 <ipkiss_> ?
12:02:03 <ayrnieu> ipkiss - I think that nhc offers a number of heap-profiling options to help you with that.
12:03:48 <ipkiss_> ok...
12:04:47 <ayrnieu> ipkiss - I don't think that knowledge of the GC would help you all that much, either.  Please consider a way to modify your array in-place.
12:05:53 <Riastradh> Or at least make sure that the old arrays are no longer reachable once you've constructed the next one.
12:07:05 <ayrnieu> can GHC optimize writes to random singly-threaded data to in-place modifications, yet?
12:07:45 <ayrnieu> also, curiously.
12:09:07 <jadrian> I don't think so...
12:15:27 <ipkiss_> Riastradh: i have something like that:
12:15:33 <ipkiss_> infiniteLoop oldArray = let newArray = generate oldArray in
12:15:33 <ipkiss_>                       -- some stuff here
12:15:33 <ipkiss_>                       infiniteLoop newArray
12:15:43 <simson> na!
12:16:13 <ipkiss_> Riastradh: do you consider oldArray as still reachable?
12:16:24 <Riastradh> ipkiss_, by the way, by 'right before that,' I meant that a GC happened right before the 'heap exhausted' error.  It's because the GC couldn't free up enough space.
12:16:27 <Riastradh> No.
12:17:33 <ipkiss_> then i have no idea of why the heap gets exhausted :/
12:17:53 <Riastradh> It's likely that it happens in generate, then.
12:19:30 <ipkiss_> well, generate is called successfully 26 times before the problem happens
12:20:04 <Riastradh> Does generate allocate anything but a new array of the same size?
12:20:47 <ipkiss_> no, except the list needed for the array creation and a few (small) intermediate lists
12:21:09 <Riastradh> Do the intermediate lists persist?
12:21:20 <ipkiss_> they are not supposed to :)
12:22:32 <ipkiss_> actually, i don't see how anything could persist since when generate has returned the result nothing is reachable anymore
12:22:50 <Riastradh> (You could store it into the new array...)
12:23:47 <ipkiss_> the arrays are bidimensional arrays, containing 0 and 1 only
12:24:22 <Riastradh> You could try packing them more tightly, since they don't need to occupy much space.
12:24:43 <ayrnieu> as a single number, for instance =)
12:25:50 <ipkiss_> bah, it would allow a few more iterations, but the problem would still remain :)
14:09:28 <shapr> jiihaa
14:13:45 <Marvin--> is that so
14:15:21 <Lunar^> shapr: got more time to look at my rc ?
14:18:39 <stepcut> sharp, can you add this to lambdabot? http://www.kuro5hin.org/story/2004/5/22/161127/590
14:18:53 <cm> hah!
14:19:04 <cm> is there libcartoon? :]
14:19:16 <stepcut> hehe
14:19:26 <stepcut> yeah, but its written in perl =(
14:19:31 <stepcut> :p
14:20:01 <cm> really?
14:21:49 <shapr> Lunar^: it's fun code time
14:22:37 <Lunar^> shapr: fun code time ?
14:22:54 <shapr> yah, I've been working today
14:23:24 <Lunar^> stepcut: that would be fun to use something like that gnomz.fluctuat.net/index.html
14:23:44 <Lunar^> shapr: Good work ?
14:23:56 <shapr> plone hacking
14:24:09 <Lunar^> mhh did you fight with Archetypes also ?
14:24:14 <shapr> I don't starve and it's not Java, so...
14:24:34 <shapr> I gave up on I18NLayer and switched to I18NArchetypes
14:24:46 * Lunar^ really feels like each day with Zope is a wrestling day
14:25:05 <Lunar^> I'd like to be coding friendly :)
14:25:33 <shapr> well, it's better than Java, I promise
14:26:05 <Lunar^> shapr: hOp ! :)
14:26:13 <shapr> yes!
14:26:35 <Lunar^> sebc is hacking the build system to add ISO support right now :)
14:26:50 <ShaminoDC|FBK> functionx :: a -> Bool 
14:26:50 <ShaminoDC|FBK>  functionx "<" = True
14:27:29 <ShaminoDC|FBK> it says nit general enough why that ?
14:27:36 <ShaminoDC|FBK> not
14:27:54 <Lunar^> Because "<" is String
14:27:55 <ShaminoDC|FBK> yes i want to check if a string is existand
14:27:55 <Lunar^> whereas 'a' in the type means anything
14:27:56 <Cale> because that's clearly of type String -> Bool
14:28:19 <ShaminoDC|FBK> mhh so no chance to make "<" an a ?
14:28:32 <Cale> well, what if a is Int?
14:28:48 <Cale> "<" can't be treated as an integer
14:29:08 <Cale> or if a is a list of trees?
14:29:27 <Cale> if it says a -> Bool, it has to work on everything
14:29:41 <ShaminoDC|FBK> mhh ok thx ill use string then
14:31:09 <desrt> (\x -> True) :: a -> Bool :)
15:12:24 <dons> moin
15:12:50 <dons> shapr: after the discussion about .hi files I'm going to add the .hi file parser to hs-plugins
15:13:10 <dons> that way you can get type information from a plugin as well
15:13:22 <dons> would make it easy to implement :t plugin
15:13:38 <dons> and gets rid of the .dep file
15:16:12 <Lunar^> dons: Good news :)
15:16:18 <dons> :)
15:16:38 <dons> I think I can write a GHCi-library this way
15:16:47 <dons> for embedding interpreters
15:16:58 <shapr> yay
15:17:11 <dons> more like an embedded hmake, really.
15:17:46 <dons> time to go ghc-src diving
15:18:00 <shapr> get out the heavy duty gear!
15:18:44 <shapr> seriously though, I would like to have an online version of the GHC sources under the Programatica haskell source browser
15:20:00 <dons> that's a good idea.
15:43:55 * ayrnieu recovers some of his Haskell code from Yahoo's 'sent mail' folder.  Yay, accidental archiving.
15:44:59 <shapr> did you have a drive crash?
15:45:42 * shapr is a great fan of rsync
15:47:43 <ayrnieu> I had a few unwise OS moves.  For a while I wanted to fluctuate between Gentoo Linux (better support for CL, Java, Haskell (GHCi!), and various other programming systems) and OpenBSD (more appealing overall, with PF and systrace).  I finally *stopped* myself from continuing this silliness, but my Haskell did not survive.
15:49:38 <dons> where did you end up?
15:49:58 <ayrnieu> OpenBSD.
15:50:22 <dons> ;)
15:50:28 <ayrnieu> which means that I'll have an older GHC system, probably, and no GHCi.
15:50:35 <dons> no!
15:50:47 <dons> update to OpenBSD -current
15:50:53 <dons> 6.2.1 is in the ports tree
15:51:00 <ayrnieu> does GHCi work?
15:51:02 <dons> and then you can build ghc head, which has ghci support
15:51:11 <dons> ghci support for openbsd will be in 6.2.2
15:51:11 <ayrnieu> oh, OK.
15:51:24 <dons> paprika$ uname -msr
15:51:24 <dons> OpenBSD 3.5 i386
15:51:24 <dons> paprika$ ghci
15:51:24 <dons>    ___         ___ _
15:51:24 <dons>   / _ \ /\  /\/ __(_)
15:51:27 <dons>  / /_\// /_/ / /  | |      GHC Interactive, version 6.3, for Haskell 98.
15:51:29 <dons> /_\\/ __  / /___| |      http://www.haskell.org/ghc/
15:51:32 <dons> \____/\/ /_/\____/|_|      Type :? for help.
15:51:34 <dons> Loading package base ... linking ... done.
15:51:37 <dons> Prelude> 
15:51:42 <ayrnieu> er, OK, you didn't have to draw me a picture =)
15:51:46 <ayrnieu> but yay =)
15:51:47 <shapr> I think dons and ustenzel are the canonical BSDers in the Haskell world
15:52:09 <dons> canonical, that's nice :)
15:52:12 <ayrnieu> Somebody also got SBCL kinda working on OpenBSD, which pleases me.
15:57:36 <dons> ayrnieu: http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
15:58:09 <ayrnieu> ooh, nifty.  Thank you.
15:58:58 <shapr> mmm, crunchy music
15:59:21 <desrt> what's this ghc thing everyone keeps talking about?
15:59:51 <shapr> it's part of the Haskell Sekrit Underground
15:59:58 <shapr> which doesn't exist of course
16:00:00 <ayrnieu> desrt - http://www.haskell.org/ghc/
16:00:45 <desrt> shapr; i see.  i shouldn't go poking my nose into other people's business, then
16:01:00 <cbus> ghc is nice :)
16:01:04 <desrt> these secret undergrounders sound like they might be connected with the mob
16:01:16 <ayrnieu> desrt - er, and even if the Haskell Sekrit Underground exists (it doesn't), and if GHC had anything to do with it (it doesn't), shapr (not a member) wouldn't know -- and neither would I (even more of a non-member).
16:01:21 <cbus> you have to pay a toll to the mob to be able to use ghc ;)
16:01:37 * desrt watches ayrnieu go and ruin all the fun
16:01:56 <ayrnieu> desrt - yes, fun.  Just fun.  Please move along.
16:02:21 <desrt> huh?
16:02:28 <ayrnieu> what?
16:02:42 <Cale> Nothing to see here.
16:02:43 <shapr> who?
16:02:48 <blackdog_> who's on first.
16:02:52 <shapr> move along quietly
16:02:58 <shapr> g'day blackdog_ !
16:03:01 <desrt> cale is definitely a member of the sekrit underground
16:03:09 <blackdog_> g'day shapr.
16:03:17 <dons> blackdog_: hey ;)
16:03:47 <blackdog_> dons: hail fellow and well met. i'm in deathmarch mode now, and enjoying it, perversely enough...
16:04:04 <dons> working?
16:04:04 <shapr> whee
16:04:37 <blackdog_> yeah. chak got a bit annoyed with me for being a lazy bastard, unsurprisingly enough, and I've got the fear of god in me now.
16:04:46 <dons> yikes!
16:04:57 <shapr> oh, I had a crazy idea for inserting Haskell into the job market with a crowbar... write PHP analysis and fix tools with it!
16:05:06 <Cale> desrt: What are you talking about? Who told you that GHC stood for Great Huge Conspiracy?
16:05:28 <ayrnieu> shapr - write Haskell programs to analyze confused PHP programs?
16:05:35 <shapr> ayrnieu: yes!
16:06:35 <blackdog_> shapr: what can Haskell provide there that'll justify using it over another language?
16:06:48 <shapr> I asked around and I heard that there are one-page debug tools, but nothing that does multi-module analysis
16:07:11 <shapr> blackdog_: it'd be a lot easier to write and maintain in Haskell imho
16:07:51 <shapr> so I figure we got the power, we can contribute some of it to those in need (PHP programmers)
16:08:46 <shapr> blackdog_: whaddya think? I need more sleep?
16:08:54 <blackdog_> What sort of analysis? I was thinking just whack a type system on top of PHP; is that the goal?
16:09:29 <shapr> that's an idea
16:09:55 <blackdog_> maybe make a preprocessor to convert PHP to WASH combinators. :)
16:10:49 <shapr> actually I was thinking you could do a lot of simple checks at first, if you have the whole program tree, checking to see if a function is being used in unmatching ways should be easy
16:11:48 <dons> a lint for php?
16:11:54 <blackdog_> less interesting theoretically but probably a whole lot more useful.
16:11:58 <shapr> right
16:12:24 <shapr> Haskell seems like it would be great for lint tools
16:12:32 <dons> perfect for it. 
16:12:58 <dons> like 'cmi', the cross-module inliner for C, that is a preprocessor for gcc
16:13:07 <shapr> and Haskell is so mind-twisting we could get paid to extend that sort of tool
16:13:37 <dons> hehe. we start our own self-perpetuating industry
16:13:40 <shapr> or we'd get more Haskell programmers, either would mean I'd be more likely to get a Haskell job
16:13:44 <shapr> right on
16:13:54 <Lunar^> nice idea :)
16:14:23 <shapr> Lunar^: zope fixing gave me the idea... 
16:22:53 <desrt> mmm
16:22:56 <desrt> ut rules
16:23:28 <shapr> utah?
16:23:39 <desrt> unreal tournament
16:23:41 <desrt> wanna play?
16:23:42 <shapr> oh
16:24:04 <shapr> nvidia + linux 2.6 + smp = horrible pain
16:24:12 <desrt> hahah
16:24:15 <desrt> i know your pain!
16:24:20 <desrt> i took my nvidia card back and got an ati
16:24:28 <shapr> I wish I had
16:24:44 * desrt running dual athlon MP 1800+
16:24:47 <blackdog_> shapr: what were you thinking? I thought you were all about the free software...
16:25:16 <desrt> heh
16:26:05 <desrt> nvidia isn't the worst company when it comes to drivers
16:26:19 <desrt> (at least they bother to release a driver for linux every now and then)
16:26:24 <desrt> but they're far from the best
16:26:44 <ayrnieu> such as, perhaps according to RMS, the companies that help encourage the production of free drivers by not releasing anything.
16:26:53 <shapr> desrt: I got the same cpus
16:27:10 <desrt> shapr; you know the 2.4 amd76x_pm?
16:27:14 <desrt> is there an equivilent in 2.6 yet?
16:27:23 <shapr> blackdog_: I want ATI because it has the best 100% open source OpenGL
16:28:02 <desrt> there wasn't one in 2.6.0 which prevented me from upgrading at the time
16:28:06 <shapr> it really irks me that I cannot fix these nvidia binary drivers
16:28:07 <blackdog_> shapr: yeah, that's kinda what i meant.
16:28:18 <desrt> shapr; likewise
16:28:29 <shapr> it's like this cd-copy-protection that only works on win32
16:28:35 <desrt> shapr; does it take ~30 seconds for your X server to start up?
16:29:01 <shapr> a) I use linux b) any idiot who buys that can't use their CD in a few years
16:29:16 <shapr> c) why pay more to make my life difficult?
16:29:18 * desrt refuses to buy copyprotected cds
16:29:23 <shapr> same here
16:29:26 <desrt> which is a problem
16:29:34 <desrt> oh susanna's new cd is copy control :(
16:29:39 <desrt> i bought it at her concert and returned it to her
16:29:40 <shapr> nah, buy magnatune.com
16:29:43 <desrt> saying that i refused to buy it
16:29:55 <desrt> but....
16:29:56 <ayrnieu> desrt - directly to her?  Wee.
16:29:58 <desrt> the new cd is *so* good
16:30:06 <desrt> so i almost caved
16:30:11 <shapr> yah, I really wanted Norah Jones latest, but it's copy-protect
16:30:17 <ayrnieu> desrt - see if anyone on irc.nullus.net:6666 has gotten around the protection, since you've already paid for it.
16:30:27 <desrt> huh
16:30:32 <desrt> i ripped a norah jones cd recently
16:30:35 <desrt> i wonder if it was her new one
16:30:39 * ayrnieu mostly listens to ancient music, anyway.
16:30:47 <desrt> come away with me
16:31:07 <desrt> ^ new or old?
16:31:14 <shapr> blackdog_: so my brilliant idea to fix the nvidia/ATI problem is to start a gfx driver compiler project
16:31:30 <shapr> desrt: first album
16:31:40 <shapr> incredibly sexy
16:31:41 <desrt> shame
16:31:57 <desrt> i enjoy copying music because it's not available on non-broken cd
16:32:18 <shapr> you gotta check out the best-selling acts on magnatune
16:32:24 <shapr> they're *great*
16:32:27 <desrt> i looked at magnatune
16:32:33 <desrt> although, admittedly, didn't listen
16:32:39 <shapr> did you listen to all the top stuff?
16:32:45 <desrt> *goes now*
16:33:07 <shapr> I've purchased two albums (you choose how much you want to pay) for ten bucks each
16:33:12 <desrt> i'm not sure what genre to click on :)
16:33:17 <shapr> and I have my eye on three more
16:33:35 <shapr> start at the top: http://www.magnatune.com/info/stats/best_selling_all_time
16:33:51 <shapr> some of these I was like wtf?!
16:34:16 <desrt> argh
16:34:23 <desrt> this m3u business is more than slightly nanoying
16:34:59 <shapr> for example, the Christian Themes in Ukrainian Folk Songs from a thousand years ago...
16:35:00 * desrt pipes it into xargs wget
16:35:22 <desrt> so far i like
16:36:05 <shapr> I just purchased the Ukrainian Folk Songs album.. think I would have found that in the local record store?
16:37:01 <desrt> the cello reminds me of apocalyptica
16:37:13 <shapr> heh, apocalyptica is cool
16:39:49 <desrt> this label is cool
16:39:55 <desrt> the one thing i don't like: you can't buy a CD
16:39:59 <ayrnieu> oh, yes, apocalyptica.  Some kind of all-girl pop band (oh, "Bond") has an apocalyptica feel -- and some girl with an electrin violin does a good job of Bach's Tocatta and Fugue (popularly known from the Nintendo game Gyruss), but I can't remember her name.
16:41:45 <desrt> i like how they offer good formats
16:41:47 <desrt> like flac and ogg
16:41:49 <ayrnieu> also, 'electric violen'.
16:41:58 * ayrnieu gives up.
16:44:26 <desrt> this ehrin guy makes me want to sleep
16:49:22 <shapr> heh
16:49:38 <shapr> I think he's great
16:49:52 <desrt> i didn't say i don't like it :)
16:50:18 <shapr> it is calming, I agree
16:50:26 <desrt> my sister says it reminds her of old b&w silent films
16:58:03 <desrt> violin.  yay
21:24:51 <stepcut> ugh
21:27:46 * stepcut ponders how to fix wash/cgi to work better with links
22:28:19 <shrimpx> freenode sucks
22:31:16 <Riastradh> shrimpx, do you mean to suggest you could do it better, without designing a better protocol than IRC?
