01:00:54 * SamB wonders if microsoft research could be used to take over microsoft
01:02:01 <opet> if they research killer robots they could TAKE OVER THE WORLD
01:03:26 <SamB> opet: you know that microsoft research isn't as evil as the rest of microsoft, don't you?
01:03:36 <SamB> I mean, some of it isn't at all evil.
01:04:09 <SamB> unless, of course, Happy is an attempt to keep people from noticing Parsec
01:04:29 <opet> yes, but with killer robots anything is possible
01:04:49 <SamB> well, that wouldn't explain Simon Peyton-Jones.
01:05:45 <SamB> opet: they get smart researchers! and these smart types tend to be nice, so, I don't think they will be researching that any time soon.
01:07:55 <SamB> I hope they find us a new math framework soon ;-)
01:09:02 <Hyp3rion> Hi, er, maybe offtopic, but what does HEIFER mean?
01:11:28 <saz> cow?
01:11:46 <saz> female cow
01:11:56 <SamB> Hyp3rion: it could possibly be a kind of cow. I don't know if that is how you spell what I think it might be or not :-(.
01:12:12 <SamB> hmm, yes. a young cow.
01:12:29 <SamB> I don't remember what it means metaphorically...
01:12:47 <SamB> saz: all cows are female. the males are called bulls ;-)
01:14:03 <saz> heh, well yeah :)
01:14:54 <saz> From WordNet (r) 2.0 [wn]:
01:14:54 <saz>   heifer
01:14:54 <saz>        n : young cow
01:14:57 <saz> there ya go
01:14:59 <Hyp3rion> SamB, saz, Okis cheers... Reading about greek mythology ^_^
01:15:07 <saz> (the rest of the results from dict are pretty non-sensical)
03:50:12 <shapr> good morning #haskell!
03:50:22 <saz> goooood moooorning shaaaapr!
03:50:52 <shapr> hey saz, how's XXXX treating you?
03:51:23 <saz> heh, annoyingly
03:52:43 <shapr> not warm enough? too much work?
03:53:04 <saz> just trying to understand this problem, and would rather sleep
03:53:20 <saz> i should really compile what I've got
03:56:16 <shapr> hi jesse 
03:56:22 <shapr> saz: what's the prob?
03:56:36 <saz> just an assignment
04:04:40 <saz> woo, dinner :)
05:00:36 * shapr sings thelambda song
05:02:56 <keverets> you're going to have to put an ogg of that up somewhere
05:06:23 <iolotusbobo> hello shapr
05:50:17 * shapr boings
05:51:11 <Lukhas> hello
05:51:14 <shapr> anyone know if the haddock cvs has anything significantly different from 0.6?
05:51:30 <shapr> hi Lukhas
05:55:40 <Lukhas> on Thompson's book, an exercises tells me to define a function romanDigit :: Char -> String, that returns the roman digit associated to the digit entered.
05:55:55 <Lukhas> i have found several ways of doing it, but i'm not satisfied
05:56:34 <Lukhas> can someone here give me an elegant version ? :-)
05:57:01 <Lukhas> mine is :
05:57:02 <Lukhas> romanDigit c =
05:57:02 <Lukhas>     ["I","II","III","IV","V","VI","VII","VIII","IX"] !! (ord c - ord '0' - 1)
05:57:35 <bluejay> I like yours
05:57:48 <Lukhas> heh, thanks :)
05:57:50 <neologism> now define the rest and you're done
05:57:58 <Lukhas> rest ?
05:58:02 <Hyp3rion> The DiveIntoPython docs has whole romanNumber for example... Maybe not this elegant tho.
05:58:11 <neologism> romandDigit "X" = 10 etc.
05:58:55 <Lukhas> yeah, next step for me is to convert any number into a roman one
05:59:09 <Lukhas> but the more i think of it, the less i like that
06:00:04 <neologism> its not that hard - roman2indian
06:00:19 <neologism> reverse is a bit harder
06:00:23 <Lukhas> yup
06:05:02 <neologism> http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html
06:05:11 <neologism> interesting article ;)
06:05:53 <Lukhas> hehe
06:53:10 <Shammah> neologism: for a very perverse definition of 'interesting'.
06:53:36 <neologism> Shammah: thats why I put there that smiley ;)
06:53:50 <Shammah> neo: I was hoping that was the case :)
06:54:06 <neologism> its interesting that people still say such shit
06:54:45 <Shammah> heh.  Not anyone who's actually in the business of optimisation though.
06:56:50 <Shammah> neo: I just finished a major cascade (almost flamewar) on the same issue on our local LUG mailing list.
06:57:29 <Shammah> http://lists.humbug.org.au/archives/general/2004-April/023737.html  <= head of the thread.
07:05:48 <neologism> funny
07:06:30 <XTL> Maybe if it was less attacking, it would have a mild point. Namely that a program that runs even twice as fast as another version is somewhat more useable :)
07:57:04 * iolotusbobo is away: Got Some Work... AFK...
08:05:46 <Marvin--> more...coffee...needed
08:10:26 <Lukhas> Main> romanDigits 2581
08:10:27 <Lukhas> "MMDLXXXI"
08:10:29 <Lukhas> phew :)
08:11:01 <Hyp3rion> 8-|
08:11:04 <Hyp3rion> Cool!
08:11:27 <Hyp3rion> Lukhas, Could you please put the code under public domain?
08:11:59 <Lukhas> no way, i'll sell it to Microsoft !
08:12:07 * Lukhas runs away with his code
08:12:28 <Hyp3rion> They wont understand higher intelligence Haskell...
08:12:28 <Marvin--> heh
08:12:36 <Lukhas> code is at http://rafb.net/paste/results/Pv405781.html
08:13:10 <vegai> Hyp3rion: hmm, tell that to Simon (any one of them) ;P
08:13:15 <Lukhas> i understand why we no longer use roman numbers
08:14:06 <shapr> cuz they suck
08:14:18 <Marvin--> behold the wisdom of shapr
08:14:20 <mattam> they look nice
08:14:33 <mattam> as ordinals
08:14:40 <shapr> but they're difficult to manipulate symbolically
08:14:49 * Hyp3rion hands 500FnK to Lukhas
08:14:56 <Lukhas> FnK ?
08:15:03 <Hyp3rion> Freenode Kronen
08:15:08 <shapr> heh
08:15:12 <Lukhas> hehe, thanks
08:16:58 <Lukhas> i'm sure there's a smarter way to extract numbers from an integer
08:17:13 <Lukhas> i remember using something else on my calc...
08:17:15 <Lukhas> but that's too old
08:17:32 <keverets> Language: VB ?
08:17:45 <Lukhas> keverets: highlight strings at some keywords
08:17:51 <Lukhas> s/at/and/
08:18:14 <Lukhas> use Haskell.Net :-)
08:42:35 <atom-z> also, there are many ways of writing a number as a roman numeral
08:43:25 <Lukhas> many ? apart from the 4 that can be written IV or IIII, i don't see others
08:43:51 <Hyp3rion> 4 = IV, never seen III...
08:43:56 <Hyp3rion> Err IIII
08:44:08 <Lukhas> Hyp3rion: used in Middle Age in France
08:44:16 <Lukhas> and on my parents' clock :)
08:44:23 <Hyp3rion> Lukhas, Oh. :-)
08:44:46 <Lukhas> but that's too confusing
08:45:05 <Lukhas> when you see "many Is" -> 3, no need to count them
08:45:24 <Lukhas> whereas with 4 being written IIII, you have to count to see if it's 3 or 4
08:45:33 <Hyp3rion> Yes.
08:46:58 <atom-z> e.g. 1999 = IMM or MCMIC ?
08:47:29 <Lukhas> "MCMXCIX" :)
08:47:33 <Lukhas> good point
08:48:21 <keverets> IIII vs IV on a clock generally indicates how it will chime for that hour.
08:49:37 <Lukhas> oh, ok.
08:50:09 <Lukhas> hmm, to compare 2 roman digits, what should i use ?
08:50:32 <atom-z> an interesting programming problem would be to make it print the simplest possible roman numeral
08:50:51 <Lukhas> atom-z: yeah, but we'll have to define simplest
08:50:58 <atom-z> Lukhas: i'de convert it to an unambiguous number system first, like denary
08:51:09 <atom-z> (to compare 2 numbers)
08:51:12 <Lukhas> denary ?
08:51:24 <atom-z> base 10
08:51:30 <Lukhas> doh
08:51:37 <Lukhas> ah yeah, good idea :)
08:52:23 <atom-z> sorry, just that they make us learn all of these technical terms, which mostly irrelevant in AS computing (the exam is basically just definitions)
08:52:43 <Lukhas> "decimal" sounds good for base 10
08:53:03 <atom-z> s/mostly/are mostly/
08:53:21 <atom-z> Lukhas: i'de lose marks if i put that in an exam, apparently
08:53:34 <Lukhas> that's weird
08:53:37 <atom-z> indeed
08:56:46 <gintas> Lukhas: I think your program can be rewritten in a simpler, more "functional" way
08:57:03 <Lukhas> gintas: i'm sure it can, that's my first Haskell program.
08:57:15 <gintas> Lukhas: well then you're quite good :)
08:57:23 * Lukhas blushes :)
08:57:51 <atom-z> "DRUGS: Curcumventing life's problems since 1881" heh
08:58:06 <Lukhas> hehe
09:01:28 <Lukhas> list comprehension is really funny
09:04:16 <simon-> which software do you people use for writing book material?
09:06:54 <gintas> Lukhas: want to see the improved version?
09:07:19 <Lukhas> gintas: sure
09:12:18 <gintas> hey, that paste service is pretty cool; http://rafb.net/paste/results/qE853767.html
09:12:52 <Lukhas> aow, gotta go party :-) i'll see your code later, thanks gintas 
09:12:57 <Lukhas> and cya gentlemen
09:15:04 <Hyp3rion> CYA
09:16:50 * iolotusbobo is back (gone 01:19:44)
09:30:25 <shapr> simon-: I've heard people use latex or docbook
09:31:26 <simon-> shapr, but do they write docbook by hand?
09:31:46 <shapr> I'd use an emacs mode
09:32:19 <shapr> I like psgml for speedy sgml editing
09:38:00 <Cale_> man, we really need to change ISPs
09:38:28 <Marvin--> hmm, I need some really really bad haskell jokes
09:38:35 * Marvin-- goes digging through QuotesPage
09:43:52 <Marvin--> amazing, I couldn't find anything appropriate
09:44:39 <Marvin--> now what
09:44:41 <eivuokko> So, maybe you should make some up?
09:44:56 <eivuokko> Remember to store them in wiki for next person to find ;)
09:45:03 <Marvin--> it's probably easier to dig through #haskell.log :_)
09:45:28 * Marvin-- needs something to keep people from walking out the door during his presentation
09:46:30 <Maddas> heh.
09:46:39 <Maddas> Marvin--: A guard?
09:47:42 <Marvin--> well, that's plan B, but it's a bit too obvious :P
09:49:19 <Maddas> oh, a good way is to ask the first person that gets up why he is getting up and if this all is too esay
09:49:20 <Maddas> easy
09:49:28 <Maddas> that'll scare the others from leaving, but they probably won't come next time either :-)
09:49:57 <Marvin--> well, this is a one-shot presentation (my degree project)
09:50:22 <Maddas> Oh, I see
09:50:41 <Maddas> Oh, you are only planning in advance, not from experience ;-)
09:51:14 <Maddas> I guess promising free beer to anybody that sits it out is too obvious too :-P
09:51:31 <Marvin--> I'm planning the presentation and from what I can tell, it'll be much longer than I can hope to keep people from getting bored :)
09:51:48 <Maddas> What is it about again? (And how long will it take?)
09:52:09 <Marvin--> so I thought, "hey, if I sprinkle in some really bad jokes, at least they can sit there and groan at my bad sense of humor instead of how stupid and boring the project is!"
09:52:51 <Marvin--> it's about a FOL axiomatization of Haskell that I use to prove stuff about programs
09:52:58 <Maddas> Cool
09:53:29 <Marvin--> and I was aiming for a 45 minutes presentation + questions, but the way I'm outlining stuff now, I'm looking at probably an hour minimum, and then you multiply that by 1.5...
09:58:07 <shapr> hi wolfman8k 
09:58:20 <wolfman8k> greetings
09:58:28 <ibid> the only good thing about slides is that they allow a fairly accurate timing plan
09:58:54 <wolfman8k> i'm newbie
09:59:30 <shapr> looking for tutorials?
09:59:51 <wolfman8k> no
09:59:58 <wolfman8k> i'm just here to lurk, to get a feel for the community vibes
10:00:22 <shapr> want the quick tour of useful channel resources?
10:00:39 <wolfman8k> sure
10:01:04 <shapr> ok, lambdabot has some handy commands, @type, @info, and @index
10:01:16 <shapr> and @eval is a lambda cal interpreter
10:01:40 <shapr> the Haskell Wiki has our paste page and a lot of other useful info
10:02:12 <Marvin--> huh, @index? Is that new?
10:02:15 <shapr> the learning page and channel logs are mentioned in the channel topic
10:02:23 <shapr> Marvin--: yah, last night I think
10:02:36 <Marvin--> @index
10:02:37 <lambdabot> bzzt
10:02:40 <iolotusbobo> shapr, sorry to disturb... did u finish that code snippet?
10:02:40 <shapr> it uses all the haddock indices that come in debian
10:02:50 <Marvin--> bzzt bzzt
10:02:57 <shapr> iolotusbobo: sorry, I've been distracted by work
10:03:02 <wolfman8k> shapr: thanks
10:03:06 <shapr> @index foldr
10:03:06 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
10:03:12 <wolfman8k> what is lambda cal?
10:03:16 <iolotusbobo> shapr ... np
10:03:18 <shapr> wolfman8k: that's all I can think of at the moment
10:03:25 <shapr> lambda calculus
10:03:29 <Marvin--> oh, nifty
10:03:38 <shapr> @index GLubyte
10:03:38 <lambdabot> Graphics.UI.GLUT,Graphics.Rendering.OpenGL,Graphics.Rendering.OpenGL.GL
10:03:38 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes
10:03:42 <Marvin--> but a quite redundant list :)
10:04:15 <shapr> well, I may switch it to show only the re-exporters
10:04:21 <wolfman8k> this is a stupid question, but is haskell really as good as they say it is? :)
10:04:27 <shapr> no
10:04:29 <shapr> it's better
10:04:32 <shapr> ;-)
10:04:45 <Marvin--> who's 'tis "they"
10:04:56 * Marvin-- breaks out the thumbscrews
10:05:09 <shapr> but, what sort of claims can we discuss?
10:05:11 <wolfman8k> haskell.org
10:05:42 <shapr> oh, I that's understated
10:06:21 <shapr> you want some demos?
10:06:45 <wolfman8k> no, actually i have a question
10:06:55 <wolfman8k> but maybe i should learn a bit about haskell before asking it
10:06:56 <shapr> what would you like to see? simple source/syntax demo, useful apps and source, other?
10:06:57 <Marvin--> questions good
10:07:16 <wolfman8k> i think i just need to read some tutorials and stuff
10:07:22 <wolfman8k> i'll come here if i have any questions
10:07:23 <shapr> sure, throw us a question if you want
10:07:31 <shapr> lambdabot is written in Haskell
10:07:44 <wolfman8k> lambdabot: who's your daddy?
10:07:44 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
10:08:06 <shapr> I wrote a rudimentary web-based mail list searcher in 200 lines of Haskell
10:08:23 <shapr> I'm using a blog written in Haskell :-)
10:08:37 * gintas throws a very heavy curvy question towards shapr
10:08:54 <shapr> oh, oh, pick me!
10:09:01 <shapr> what's the question?
10:09:28 <wolfman8k> what's the best tutorial to start with?
10:09:44 <ibid> shapr: where's your blog?
10:09:45 <Cale> I like the one called "Yet Another Haskell Tutorial" by Hal Daume
10:09:53 <shapr> gentle tutorial if you have prior functional programming experience
10:10:04 <shapr> yah, YAHT is easier to get into
10:10:47 <wolfman8k> hm... is there anywhere i can view this online?
10:11:02 <shapr> ibid: http://shapr.homelinux.net/~shae/blog/
10:11:22 <wolfman8k> nm, found it
10:11:26 <shapr> dunno if it's ready for prime time yet though
10:11:53 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
10:12:00 <wolfman8k> nein! 200 pages :O
10:12:02 <Cale> if you don't care to put in your name :)
10:12:08 <Cale> It's pretty much a book :)
10:13:04 <shapr> ibid: I'm using Peter Gammie's PLog system
10:17:27 <eivuokko> Tutorial reminds me, is it good to have PLEAC haskell in "general introduction to haskell".  I find to be very unidiomatic haskell.
10:17:45 <Cale> Hm?
10:17:46 <eivuokko> I mean, it's a link at haskell.org's "Haskell bookshelf"
10:17:50 <ibid> PLEAC?
10:18:00 <eivuokko> Some perl cookbbook.
10:18:14 <shapr> ibid: I can't find a download site for PLog since Pete moved from unsw.au to chalmers, but I can pass you a copy if you want.
10:18:22 <ibid> not needed
10:18:28 <shapr> I think we should stel PLEAC and stuff it onto the wiki
10:18:33 <Cale> You find Haskell to be very unidiomatic, or you find the code in the tutorial to be unidiomatic?
10:18:35 <shapr> er "steal"
10:18:54 <shapr> I'd contribute code if it were a wiki
10:19:02 <eivuokko> Cale, the code in "tutorial".
10:20:09 <shapr> ibid: your wiki is on debianplanet
10:20:14 <shapr> er "blog"
10:21:46 <Lunar^> shapr: Did you read the announcment of hs-plugins ?
10:22:04 <shapr> yes, though I haven't used it yet
10:22:18 <shapr> is that Hemacs waiting to happen?
10:22:29 <eivuokko> Heh
10:22:45 <Lunar^> shapr: Or dynamic HSP ?
10:22:57 * shapr thinks about that
10:22:58 <Lunar^> shapr: Servlet like
10:23:23 <shapr> hm!
10:24:10 <shapr> isn't this what Simon Foster is already doing?
10:25:20 <shapr> yes, this is good for HSP/Servlets
10:25:59 <shapr> and I think this answers Lor's questions of type-safety as well
10:29:02 <shapr> first question, does this include a plugin plugin API?
10:32:20 <shapr> this appears to do autodynloading when the source has changed, is that right?
10:37:15 <shapr> I wonder if this uses the extended loader from hram
10:59:18 <wolfman8k> ugh, this is making my brain explode :(
10:59:43 <desrt> wolfman8k; haskell in general?
10:59:51 <wolfman8k> yeah
10:59:59 <desrt> for a good time, take a look at church numerals
11:01:24 <Cale> heheheh
11:02:15 <shapr> hi cholo 
11:02:34 <shapr> wolfman8k: have questions?
11:02:58 <wolfman8k> can you use SDL with haskell? :)
11:03:04 <shapr> sure
11:03:19 <Cale> You can use any C library with Haskell.
11:03:43 <wolfman8k> automatically?
11:03:44 <Cale> It will be more or less convenient depending on whether nice bindings have been written.
11:04:12 <Cale> Well, for each function you want access to, you will need to do an ffi import.
11:04:13 <shapr> there aren't any complete SDL bindings, but there's one partial and another in progress
11:04:40 <Cale> (if there are bindings, you don't need to worry about the ffi)
11:05:06 <wolfman8k> so is haskell useful for making gui applications?
11:05:18 <Cale> I find it's not too bad at it.
11:05:27 <Cale> though I haven't used it extensively for that
11:05:42 <shapr> Tk, wxWidgets, gtk, gtk2
11:05:43 <SamB> shapr: does TH support ffi?
11:06:18 <Cale> I found wxHaskell to be rather pleasant.
11:06:22 <shapr> SamB: they can be used together, and that's how some of the MacOS bindings work
11:06:22 <Marvin--> woot
11:06:35 <Marvin--> apparently the local gaming store has a copy of Ricochet Robot in store
11:06:55 <shapr> and I think the wxWidgets bindings are generated from wxEiffel bindings
11:07:08 <wolfman8k> so let's say i want to write a simple drawing program in haskell, where you can draw circles, and then select them and modify the radius/color of each one
11:07:22 <wolfman8k> there should be some user interface widget that shows you the radius of the selected circle
11:07:26 <wolfman8k> and lets you adjust it's radius
11:07:40 <Cale> Add a textbox or something :)
11:07:40 <shapr> you should get Hudak's book, I think he does that as an exrcise
11:07:53 <wolfman8k> so it seems like haskell would make it really easy to have the widget always reflect the current status of the selection
11:07:54 <SamB> shapr: what I mean is, TH supports generating ffi import declarations?
11:08:12 <wolfman8k> like, if the radius changes somehow, by using some scale tool, then the widget should automatically get updated
11:08:33 <wolfman8k> this is sort of what haskell is supposed to be good at, right?
11:08:39 <shapr> SamB: I think that's how Wolfgang Thaller does most of his binding stuff
11:09:06 <Cale> wolfman8k: depending on what level the bindings are at, yeah - there are some higher level gui libraries where this is easy to set up.
11:09:22 <Cale> Unfortunately, a lot of them suffer from bit rot it seems.
11:09:37 <wolfman8k> and since haskell uses lazy evaluation for everything, then if the "radius" widget is like hidden, then it won't be updated
11:09:46 <wolfman8k> so if you have dozens of widgets in a hidden tab
11:09:57 <wolfman8k> then haskell will automatically know which to update based on lazy evalution?
11:10:06 <Cale> It could.
11:10:20 <Cale> Depending on how the widgets work.
11:10:23 <wolfman8k> is this what haskell is designed for?
11:11:19 <shapr> for widgets?
11:11:24 <Cale> http://www.cs.chalmers.se/ComputingScience/Research/Functional/Fudgets/
11:11:44 <Cale> there's some pretty neat ideas there - I'm not sure how well the library is maintained though
11:11:55 <Cale> and it would be nice to see a gtk2 version
11:12:12 <SamB> shapr: nice ;-)
11:12:21 <shapr> wolfman8k: http://www.haskell.org/complex/why_does_haskell_matter.html
11:13:36 <SamB> haskell is good at pushing a little bit of syntax a long way
11:13:41 <shapr> yup
11:14:30 <wolfman8k> i read that a while ago
11:14:41 <shapr> wolfman8k: oh, ok
11:14:42 <wolfman8k> i guess i'll just have to dig deeper into haskell
11:14:46 <shapr> yes!
11:14:50 <shapr> write code!
11:15:00 <wolfman8k> but i have brain ache now
11:15:06 <wolfman8k> so i'm gonna go eat
11:15:07 <shapr> lambdabot always needs more plugins
11:15:15 <shapr> @listmodules
11:15:15 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
11:15:15 <lambdabot> ,"dynamic","eval","hello","karma","more","quote","seen","state","system
11:15:15 <lambdabot> ,"topic","type"]
11:15:24 <wolfman8k> lambdabot: hello
11:15:25 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
11:15:28 <wolfman8k> @hello
11:15:28 <lambdabot> Hello world. 
11:15:38 <shapr> @hello How Are You.
11:15:39 <lambdabot> Hello world. How Are You.
11:23:36 <wolf|food> anyone know of any examples of 3d graphics with haskell?
11:26:15 <Cale> Some guys coded Quake in Haskell at one point.
11:27:08 <wolf|food> hm.... what?!?
11:28:00 <Cale> i.e. they rewrote it in Haskell.
11:28:35 <Cale> I'm not sure where you could get a copy - there's a report on how the project went somewhere.
11:30:15 <Cale> http://www.tfh-berlin.de/~panitz/hopengl/examples/klassen.html -- there's a bunch of simple examples of using HOpenGL
11:31:32 <wolf|food> thanks
11:31:35 * wolf|food is away: food
11:36:34 <Cale> @yow
11:36:35 <lambdabot> With this weapon I can expose fictional characters and bring about
11:36:35 <lambdabot>  sweeping reforms!!
11:36:49 <Cale> Sweeping reforms, indeed!
11:43:14 <simon-> @commands
11:43:15 <lambdabot> Sorry, I don't know the command "commands", try "lambdabot: @listcommands
11:51:28 <Cale> @listcommands
11:51:28 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
11:51:28 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
11:51:28 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
11:51:28 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
11:51:28 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
11:51:29 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
11:51:31 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
11:51:33 <lambdabot> ,"seen","set-fuel","shapr","state","topic-cons","topic-init","topic-snoc
11:51:35 <lambdabot> ,"topic-tail","topic-tell","type","vera","web1913","wiki","wn","world02
12:10:34 <wolfman8k> so the haskell that most people use today is back from 1998? :O
12:12:17 <chucky_> wolfman8k: not really. Most people tend to use at least some of the extensions to the language. And both the FFI and the hierarchical libraries were added after 98
12:12:49 <wolfman8k> are these major improvements from the 1998 version?
12:13:29 <simon-> as far as I know, the air that we breathe is very old... it's a matter of the quality, not its age. =)
12:14:49 <chucky_> I'd reckon the hierarchical libraries are a major improvement to Haskell 98
12:15:49 <spenatmannen> how do I convert a String to a Int?
12:15:57 <spenatmannen> an In
12:15:58 <spenatmannen> t
12:16:14 <wolfman8k> read
12:16:37 <spenatmannen> Program error: Prelude.read: no parse
12:19:59 <spenatmannen> getCols :: String -> Int
12:20:00 <spenatmannen> getCols xs = (read (drop 2 xs))
12:20:24 <spenatmannen> is my error and my code
12:21:50 <Cale> spenatmannen: the string you passed in couldn't be read as an Int
12:22:24 <spenatmannen> hmm but it is an int.. 
12:22:28 <Cale> hmmm...
12:22:42 <Cale> maybe there are some extra characters getting in somehow
12:23:12 <spenatmannen> this is what I type in getCols "1234"
12:23:17 <spenatmannen> in hugs
12:24:00 <Cale> what happens if you type: read (drop 2 "1234")::Int
12:24:25 <dennisb> spenatmannen: reload the file, :r in hugs
12:24:32 <Cale> yeah, that might be it
12:25:23 <spenatmannen> Cale, yeah that works...
12:25:57 <Cale> so yeah, make sure your file is saved / reload it
12:26:00 <spenatmannen> weird :)
12:26:21 <spenatmannen> I put the function in there before I started hugs...
12:27:01 <spenatmannen> but now it works...
12:27:24 <Cale> well, that's good then :)
12:37:54 <wolfman8k> how can i install Graphics.UI.GLUT on gentoo linux?
12:39:15 <Cale> it should come as part of GHC, I think - if the right option is turned on at compile time
12:57:18 <kosmikus|away> could be that you have to emerge ghc with USE="opengl" ...
13:29:52 <SamB> is lambdaTeX new, or did I just miss it before when looking at http://www.haskell.org/libraries/?
13:30:32 <SamB> oh, maybe I just didn't like the birdfeet.
13:30:47 <SamB> I think I could stand them now ;-)
13:41:35 <wolfman8k> i installed hugs, not ghc
13:44:07 <kosmikus|away> SamB: why would you prefer lambdaTeX over lhs2TeX? ;)
13:44:15 <kosmikus|away> wolfman8k: then I don't know right now
13:44:25 <wolfman8k> is ghc better than hugs?
13:44:55 <SamB> kosmikus|away: because I am ignorant! extol the wonders of lhs2TeX if you have time ;-)
13:45:08 <SamB> wolfman8k: for most things.
13:45:21 <SamB> hugs :i is a bit more informative sometimes
13:45:37 <wolfman8k> SamB: i thought that you were a python coder? ;)
13:46:03 <SamB> wolfman8k: python and haskell have more than you would think in common
13:46:22 <wolfman8k> hm...
13:46:24 <SamB> particularly userbase-wise
13:46:53 <SamB> philosophically, too.
13:49:04 <wolfman8k> python was simple to learn while haskell is devishly mind bending :|
13:50:18 <kosmikus|away> SamB: not much time right now, sorry, but you could look at the lhs2TeX manual, available from www.cs.uu.nl/~andres/lhs2tex
13:50:25 <SamB> it is unfortunately so a lot of the time, yes.
13:52:22 <SamB> wolfman8k: which aspects are you finding the most mind-bending?
13:53:30 <wolfman8k> church numerals
13:54:00 <SamB> that is not an aspect of Haskell, per se.
13:54:26 <wolfman8k> no jk, that's not my problem :)
13:54:47 <Riastradh> SamB, userbase-wise?
13:56:05 <SamB> Riastradh: there are a surprising (to a python user not familiar with Haskell) number of people here who also like python, right?
13:56:21 <Riastradh> SamB, let's see...two, if I count correctly: you & shapr
13:56:33 <wolfman8k> and me :D
13:57:07 <SamB> Riastradh: hmm. I though there were more than that.
13:57:48 <SamB> hmm, irc clients really should implement set operations...
13:58:10 <Riastradh> Set operations?
13:58:57 <SamB> Riastradh: you know, union, intersection, difference?
13:59:31 <Riastradh> Yes, but, uh, on what sets?
14:00:24 <SamB> channels and other set expressions
14:11:57 <Philippa> as a rule most don't because their commands are pretty close to the raw protocol itself
14:12:58 <wolfman8k> irc already supports intersection of sets:
14:13:07 <wolfman8k> raise your hand if you are also in #python please
14:18:05 <chucky> I'm not in #python, but I've coded some python and I really like it.
14:20:29 <chucky> Specifically, I like using python for developing small applications, concept testers and so on. Haskell's monadic IO gets in the way when your complete program only needs to be 20-30 lines long
14:25:59 <gintas> well, I'm a half-time python coder too -- SamB's conjecture holds pretty well :)
14:31:31 <Smerdyakov> There are very few Python fans here, proportionately.
14:31:43 <Cale> chucky: how so?
14:32:02 <Smerdyakov> With a language as popular as Python, we should certainly not be surprised in the direction of thinking that there are surprisingly _many_ Python users here.
14:35:11 <chucky> cale: I actually have an excellent example. I once tried to simulate a problem involving lotto rows. The python solution turned out to be around 10 rows. The Haskell solution is 30 rows, and I still haven't gotten it to work correctly (it segfaults)
14:35:51 <Cale> interesting - what's the problem?
14:36:05 <Cale> i.e. the problem to be simulated
14:36:25 <saz> hm
14:36:28 <saz> i code python at work
14:38:12 <chucky> consider the following: When playing lotto, it has been observed that numbers often appear in sequence (ie 3 and 4). Simulate a large number of lotto rows to see which ones contain numbers that are in sequence, and which ones don't
14:38:46 <Cale> okay - what form should the output be in?
14:40:20 <chucky> any you like. A percentage or similar
14:40:39 <Cale> okay
14:40:46 <Smerdyakov> 30 rows... tehe.
14:40:54 * Smerdyakov expects a solution of about 5 lines.
14:41:50 <SamB> Smerdyakov: so many?
14:41:52 <wolfman8k> ghc is taking forever to compile :/
14:42:02 <chucky> mine is closer to 15-20 now that I look at it, but then again it makes GHC overflow the C stack
14:42:07 <SamB> wolfman8k: what distro are you on?
14:42:12 <SamB> gentoo?
14:42:12 <wolfman8k> SamB: gentoo
14:42:42 <SamB> hmm, well, you could try and just steal the GHC that is compiling your GHC
14:43:36 <SamB> assuming they don't try and bootstrap it...
14:43:41 <bluejay> wolfman8k: yeah, gentoo has a ghc-bin package
14:44:00 <wolfman8k> gcc-bin was installed as a dependency
14:44:03 <wolfman8k> i mean ghc-bin
14:44:07 <wolfman8k> now ghc is compiling
14:44:24 <chucky> hmm it seems my solution actually works on ghc 6.2.
14:44:50 <SamB> wolfman8k: I was nearly calling GCC GHC in #python earlier, when I claimed it was written in Haskell ;-)
14:44:51 <bluejay> wolfman8k: once ghc finishes compiling, you can unmerge ghc-bin, or you can probably just use ghc-bin
14:45:37 <SamB> wolfman8k: do you want to wait for it to compile or not? I have no clue how long it takes ;-)
14:45:56 <wolfman8k> i don't know... it's been going on for like 40 minutes already
14:45:59 <bluejay> IIRC, it was less than KDE
14:46:16 <wolfman8k> heh
14:46:20 <Maddas> heh, 40 minutes isn't even long!±
14:46:21 <SamB> I think I heard a report of three days somewhere, don't know what they were compiling on or anything though.
14:46:24 <bluejay> probably similar to gcc, although that's a rough guess
14:46:30 <SamB> I would just use the binaries myself ;-)
14:46:33 <wolfman8k> gcc only takes about 40 minutes
14:47:12 <SamB> oh, GHC does a good deal of optimizations, (cross module inlining, etc.) so it could take quite some time...
14:47:33 <bluejay> If you're impatient, you can always use the ghc that's on your system from ghc-bin, and it'll transparently switch over to the compiled one when ghc finishes emerging.
14:47:57 <chucky> the main problem with bootstrapping ghc is that the linking uses TONS of memory. And if you have to use swap it can take a day or two. :)
14:49:12 <bluejay> Question: If I'm thinking about grad school related to Haskell/functional programming, what universities should I be looking at?
14:49:41 <SamB> I would recommend just sticking with the prebuilt GHC, I don't expect compiling GHC with loads of machine-specific optimizations helps much anyway ;-)
14:51:05 <SamB> (after all, it isn't exactly a number-crunching program, right?)
14:59:07 <daniel_yokomiso> hi, I'm having a dumb (AFAICT) problem. I was toying with the church encoding of booleans and tried to define a equality operation based on it: "eq a b = a b (no b)" where no is "no b = b false true". But I can't figure out how to type check it (i.e. it type-checks but I'm unable to write "eq true true 1 2"). Can I type check this?
14:59:56 <Cale> chucky: okay, I have a 9 line Haskell solution
15:00:05 <chucky> nice
15:00:19 <Cale> I can probably shorten it :)
15:00:56 <Cale> 7
15:01:01 <chucky> I could shorten mine a bit too. :) Especially since I've done lots of nice splitting into functions where it wasn't needed. :)
15:01:04 <Cale> import Random
15:01:05 <Cale> ticket k n = newStdGen >>= (\g -> return $ take k $ randomRs (1::Int, n) g) 
15:01:05 <Cale> hasSequence []  = False
15:01:05 <Cale> hasSequence [x] = False
15:01:05 <Cale> hasSequence (x:y:xs) = if y == x + 1 then True else hasSequence (y:xs)
15:01:07 <Cale> main = do xs <- sequence $ replicate 10000 (ticket 6 49)
15:01:11 <Cale>           print $ fromIntegral (length (filter hasSequence xs)) / 10000
15:01:50 <chucky> nice solution
15:03:15 <chucky> but where do you ensure that the list is sorted, and that it doesn't contain duplicates?
15:03:30 <Cale> oh, you didn't say what the tickets look like :)
15:03:52 <Cale> I assumed they'd be some element of a cartesian product :)
15:04:11 <chucky> I'd like to see you fill in that lottery ticket. :)
15:04:48 <chucky> "fill in", hmm I think that's a swedish-ification.
15:07:28 <bluejay> do xs <- sequence $ repeat $ ticket 6 49; n <- length $ filter hasSequence $ take 10000 $ filter nodups $ map sort xs; print $ fromIntegral(n)/10000
15:07:37 <bluejay> sorry for the ugliness
15:09:30 <jadrian> hi
15:12:58 <jadrian> is there any simple way to define simple instance derivations at least for simple particular cases? (was that question to understand)?
15:13:28 <jadrian> (maybe template haskell... how complicated is it to use it for that purpose?)
15:15:19 <chucky> jadrian: There's a preprocessor available somewhere that you can use. Can't remember what it's called though...
15:15:41 <jadrian> chucky: you mean Drift?
15:17:03 <chucky> yes, although that's not a "simple" way. :(
15:17:26 <jadrian> and I'm not sure if it would do 
15:17:43 <jadrian> I wanted to derive instances for a class I declared
15:17:56 <jadrian> the derivation is really straighforward
15:18:18 <jadrian> it would just be nice to avoid typing the same stuff all the time
15:19:12 <jadrian> I cannot waste to much time right now, but if someone experient told me it can be easily done with Template Haskell for instance, I'd check it out
15:19:28 <Cale_> 13 lines for something that makes the tickets with no duplication and sorts them :)
15:20:24 <chucky> nice. :) I discovered my version works at home, but not on the Solaris machines at school. Interesting
15:22:09 <skew> jadrian: it can be done with Template Haskell, or DrIFT
15:23:22 <jadrian> skew: I think I'd prefer to avoid pre-processing, so I guess I'd choose TH in that case. Do you think it is a good choice?
15:23:30 <jadrian> skew: or overkill?
15:24:24 <chucky> jadrian: using TH means losing Hugs compatibility
15:24:49 <jadrian> chucky: I've lost that already :)
15:28:15 <chucky> jadrian: One usually does. :)
15:29:59 <shapr> @yow !
15:30:00 <lambdabot> YOW!!  I am having FUN!!
15:30:05 <shapr> Me Too!
15:30:10 <andersca> @arr
15:30:10 <lambdabot> Get out of me way, yeh landlubber
15:30:14 <shapr> @arr
15:30:14 <lambdabot> Yeh scurvy dog...
15:30:48 <shapr> good evening #haskell!
15:31:48 <shapr> wassup?
15:31:57 <jadrian> good evening shapr, nice bot commands :D
15:32:34 <stepcut> good evening shapr!
15:32:44 <jadrian> hmm evening? where are you shapr?
15:33:04 <shapr> it's just after midnight in sweden
15:33:11 * isomer bounces in
15:33:16 <isomer> hi ho
15:33:20 <shapr> jadrian: don't I sound swedish?
15:33:26 <shapr> hey anth, wassup?
15:33:51 <isomer> not much -- just kicking back at the end of the day. how about you, shapr?
15:34:00 <shapr> stepcut: I had something interesting to tell you, wish I could remember what it was
15:34:21 <stepcut> hah
15:34:25 <jadrian> shapr: the "evening" in your sentence made me ignore all the traces of swedish in your accent ;)
15:34:27 <shapr> oh, I joined del.icio.us and started a blog
15:34:48 <stepcut> shapr: I compiled daume's Binary.hs
15:34:53 <isomer> what's del.icio.us?
15:34:58 <shapr> jadrian: actually, I'm from southeast USA, I just happen to live in sweden
15:35:05 <shapr> stepcut: want want!
15:35:29 <shapr> isomer: it's nifty, social bookmarking
15:35:36 <shapr> http://del.icio.us/shapr
15:35:40 <jadrian> shapr: nice! I want to check that area someday (Denmark, Sweeden, etc)
15:35:55 <isomer> huh...cool
15:36:23 <shapr> and you can see what people I 'subscribe' to with http://del.icio.us/inbox/shapr
15:36:53 <shapr> and you can search by the tag other people added to their links
15:37:35 <isomer> nice hair, shae :)
15:37:37 <shapr> stepcut: do you have 6.2 compatible sources online?
15:37:39 <shapr> heh
15:37:45 <shapr> I need a haircut
15:38:12 <stepcut> shapr: in a moment
15:38:18 <shapr> stepcut: yay!
15:38:31 * shapr does the binary dance 010101
15:39:29 <skew> jadrian: the Template Haskell way is probable a bit trickier to code, but easier to use because you don't need to work a preprocessor into the makefile
15:39:51 <Spark> hmm thats my age in binary
15:40:00 <shapr> wow
15:40:33 <jadrian> skew: yeap that what I thought, got to take a look at it
15:40:33 <Spark> 01010101 is probably when i'll die :)
15:40:42 <shapr> Spark: oh, I said something less than nice earlier today. I'm practicing.
15:40:48 <Spark> wicked
15:40:53 <shapr> exactly
15:41:39 <Spark> people who are elligible for screaming at, join #c approximately once every 15 minutes
15:42:04 <shapr> jadrian: it gets too dark here in the winter, but the summers are wonderful
15:42:34 <skew> how do you know they are eligible for screaming at?
15:42:40 <shapr> it's light enough outside to read, and it's nearly 00:45
15:42:52 <Spark> their state of being is the inverse of what is acceptable
15:42:56 <Spark> it is unacceptable
15:43:08 <Spark> i think i must sleep
15:43:19 <jadrian> shapr: nice!
15:43:49 <skew> is this one of those places that has one big long day for a summer and a big long night for a winter?
15:43:56 <stepcut> http://www.n-heptane.com/nhlab/tarballs/
15:44:12 <Spark> heh
15:44:13 <isomer> shapr: sounds wonderful
15:44:15 <Spark> gotta love the poles
15:44:55 <shapr> skew: nearly
15:44:59 <jadrian> question on style, is this ugly:
15:45:02 <jadrian> class Wraper b a | b -> a where
15:45:02 <jadrian>     lift   :: (a->a)->(b->b)
15:45:13 <stepcut> shapr: I added a Makefile and dorked around with things until the test program compiled
15:45:14 <jadrian> and I'm using this on newtypes
15:45:34 <jadrian> to lift operations on the "wraped" type to the newtype...
15:45:39 <stepcut> shapr: I have no idea what the test program does, but to run it you say './speedTest n' where n is an integer
15:45:46 <shapr> winters are painful, if you miss the one hour of twilight at noon you're scrud till the next day
15:45:59 <jadrian> lol
15:46:02 <skew> wow, that's pretty extreme
15:46:08 <shapr> yah it is
15:46:08 <jadrian> :-/
15:46:25 <jadrian> by extreme you mean ugly right? :-/
15:46:25 <shapr> everyone sits inside and drinks alcohol in winter
15:46:50 <shapr> it hit -45 Centigrade nearby here last year
15:47:07 <shapr> that's waaay too cold
15:47:47 <shapr> so, when the summer hits *everybody* goes outside to be photosynthetic
15:47:51 * jadrian doesn't drink alcohol... that could be a problem
15:48:37 <shapr> several months of winter is rough
15:48:38 <isomer> shapr: i would totally hibernate for the winter. i'd be completely useless there
15:49:26 <shapr> lots of people start exercising to get in shape for summer, and live on chocolate in the winter
15:49:46 <isomer> i can so see that
15:50:21 <shapr> strange thing to me is that so many swedes take summer vacation somewhere in the south
15:51:34 <shapr> arctic summers are great, I'd prefer to take winter vacation in the Sahara for perspective
15:53:03 <shapr> stepcut: what was the next step? erlang binary pattern matchers?
15:56:12 <shapr> what numbers do you get from the test program?
15:56:58 <stepcut> ./speedTest 100
15:56:58 <stepcut> Write time: 9999000000
15:56:58 <stepcut>  Read time: 7999000000
15:57:27 <stepcut> I have not really looked at the code yet, so I don't know what the next step is
15:57:55 <stepcut> I think their are some comments in the code indicating some changes/hidden bugs that need to be done
15:57:56 <shapr> what was your original inspiration?
15:58:19 <stepcut> ??
15:59:10 <shapr> you were talking about libs that Haskell needs for increased popularity
15:59:19 <stepcut> yeah
16:00:36 <stepcut> I just noticed that python is getting really popular, and that many people who come on the channel or post on the mailling list, want to do internet apps, but we don't have the best libraries for doing that yet
16:01:19 <jadrian> by the way, slightly OT
16:01:36 <stepcut> I am interested in the NewBinary stuff, because I keep writing programs that need to read/write binary file formats with bit fields
16:01:44 <shapr> ah yes
16:01:44 <stepcut> like .swf (aka flash)
16:01:44 <jadrian> is there an imperative language with a class system similar to Haskells?
16:02:09 <shapr> and I'd like to write file format parsers with parsec
16:02:18 <jadrian> (not poo, procedural...)
16:02:26 <stepcut> i am not sure that parsec is really that great for file formats
16:02:28 <jadrian> (not OOP, procedural...)
16:02:37 <shapr> well, monadic parsers then
16:02:41 <shapr> or arrowdic
16:02:44 <stepcut> the deser stuff seemed nicer in many ways
16:02:52 <shapr> what's that?
16:03:00 <shapr> oh wait, we've discussed this
16:03:29 <stepcut> in my (limited) experience, file formats don't tend to have a lot of choice built into them, so the awesome power of parsec is largely under used
16:03:48 <shapr> hm
16:04:02 <shapr> that's surprising to me
16:04:23 <shapr> but I've never done any format parsing, so I wouldn't know
16:05:11 <stepcut> typically files, protocols, etc, have the format: header + data. And the header has a field that dictacts how many bytes of data are in the data portion.
16:05:52 <stepcut> The headers tend to be a simple 'C' struct, not much choice involved.
16:06:23 <stepcut> Often times, their might be a number of different types of headers (sometimes called tags), but you usually only need to look at the first byte to figure that out.
16:07:39 <stepcut> you don't typically need any backtracking, at worst, just 1 'symbol' look-ahead.
16:08:32 <shapr> I wonder if tar,zip,or video formats are complicated enough to make parsec interesting
16:08:55 <shapr> could be fun for ASN.1 at least
16:09:03 <stepcut> <shapr> I wonder if tar,zip,ERC> 
16:09:05 <stepcut> eek
16:09:22 <shapr> fellow erc user :-)
16:09:26 <stepcut> my keyboard got stuck :)
16:09:30 <Igloo> A lot of things fall into a hole where Haskell patterns are too klunky but parsec/happy seems overkill
16:09:50 <stepcut> for binary file formats, I think there needs to be a different kind of parser
16:10:08 <Igloo> Even things like "If it begins with foo then give me the rest" aren't pretty in Haskell
16:10:12 <stepcut> some that takes C stucts + some rules, and spits out a validating parser
16:10:22 <shapr> these regex pattern matches from today look nifty
16:10:27 <stepcut> s/stucts/structs
16:10:30 <stepcut> /
16:10:41 <Igloo> I don't think they'd help that case, though
16:10:54 <shapr> do pattern guards help?
16:11:10 <Igloo> No
16:11:40 <Igloo> The thing is you want to say    foo ("foo"++xs)   where you'd currently have to say   foo ('f':'o':'o':xs)
16:12:34 <Igloo> Bit without something repeitious like   foo ys | "foo" `isPrefixOf` ys = let xs = drop (length "foo") ys in
16:13:10 <shapr> can we get that?
16:13:31 <shapr> maybe JaffaCake has some suggestions?
16:14:04 <Marvin--> isn't that what views are meant to solve?
16:14:10 <shapr> personally, I want extra endy commas for lists, and triple quote strings from python
16:14:21 * Igloo has never looked at views, but quite possibly
16:14:36 <Igloo> Certainly if you wanted to add an extension then you'd lamost certainly want something more generic than the above
16:14:54 <Igloo> triple quote strings?
16:15:10 <shapr> """this is a bunch of stuff
16:15:29 <stepcut> sharp: sounds like a job for Syntax Macros
16:15:32 <Igloo> Extra commas anywhere in a list, tuple etc would be good in my book, and also (5,_) style tuples constructing functions
16:15:35 <shapr> where CRs are taken literally, and so is "" and '' and etc"""
16:16:13 <Igloo> I'm not convinced that's vastly better than just allowing CRs in "..." strings
16:16:27 <shapr> I just want to be able to put a comma after the last item in a list, so it's easy to comment out lines
16:16:40 * shapr quickly compiles SourceCode
16:16:45 <SourceCode> heh
16:17:15 <shapr> SourceCode: need some debugging?
16:17:17 * jadrian would like tuples with strictness anotations
16:17:21 <SourceCode> lol:)
16:17:21 <Igloo> Hmm, maybe just at the end would be best on reflection
16:17:41 <shapr> SourceCode: learning Haskell?
16:17:50 <SourceCode> shapr: no not at all lol
16:18:02 <shapr> greetings SDr, learning Haskell?
16:18:15 <shapr> SourceCode: lemme guess, long time user?
16:18:22 <SourceCode> shapr: we were discussing how hostile people in #c are in another channel and someone said people in Haskell are friendly
16:18:24 <SourceCode> so i had to join
16:18:24 <SourceCode> lol
16:18:31 <shapr> oh
16:18:33 <shapr> well
16:18:33 <SourceCode> nope never even seen haskell code, I've heard about it though
16:18:42 <shapr> what do you think so far? are we nice?
16:18:47 <SourceCode> great:)
16:18:51 <shapr> yay!
16:18:53 <stepcut> :p
16:18:54 <SourceCode> hehe
16:19:02 <shapr> stepcut is nice.
16:19:27 <stepcut> shapr: just because I feed you juicy bits of haskell code
16:19:30 <shapr> he fixed some code and gave it to me. That's really nice.
16:19:34 <shapr> yes!
16:19:42 <SourceCode> hehe
16:19:57 * shapr munches on the NewBinary sources
16:20:14 <shapr> SourceCode: would you like to learn Haskell? it's extranifty.
16:20:16 <stepcut> shapr: don't getting an bits stuck in your teeth
16:20:35 <SourceCode> SourceCode: I don't have time right now, working on other stuff, otherwise I would
16:20:35 <shapr> dang, that PRAGMA went down the wrong way
16:21:11 <shapr> mmm, cd table && make clean
16:21:34 <shapr> SourceCode: it's really worth
16:21:41 <shapr> the first lambda is free
16:21:48 * shapr tokes on a lambda
16:21:53 <Cale> heh
16:22:00 <SourceCode> hehe
16:22:06 <SourceCode> Cale is here lol
16:22:16 <Cale> Of course, I'm always here
16:22:17 <SourceCode> Cale you were right
16:22:18 <SourceCode> cool
16:22:30 <shapr> wanna see just the HaskellDemo? ;-)
16:22:40 <SourceCode> sure
16:22:54 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
16:23:36 <shapr> that's short and sweet for those who are impatient or have little free time
16:23:42 <jadrian> Using Data.Set, which is based on Data.FiniteMap. 1st I'll build the set and then just search in it. 
16:24:03 <jadrian> Probably a good idea to force the evaluation of the set, right?
16:24:21 <shapr> SourceCode: what do you think? looks tasty?
16:24:22 <jadrian> (before searching)
16:24:48 <Cale> SourceCode: one really neat thing about haskell is that it can work with infinite data structures (infinite lists, trees, etc.) as easily as finite ones
16:24:55 <shapr> that first high... er, high order function I mean
16:25:15 <Cale> haha
16:25:21 <shapr> yup, "ones = 1 : ones"
16:26:03 <shapr> @define one = 1 : ones
16:26:03 <lambdabot> (line 1, column 2):
16:26:03 <lambdabot> unexpected "="
16:26:03 <lambdabot> expecting space or simple term
16:26:06 <shapr> hmm
16:26:12 <shapr> @define one 1 : ones
16:26:12 <lambdabot> one defined
16:26:18 <shapr> take 4 ones
16:26:25 <shapr> @eval take 4 ones
16:26:25 <lambdabot> unbound variable: ones
16:26:35 <Cale> heh
16:26:35 <shapr> urf, I can't type
16:26:41 <shapr> @define ones 1 : ones
16:26:42 <lambdabot> ones defined
16:26:44 <shapr> @eval take 4 ones
16:26:45 <lambdabot> [1, 1, 1, 1]
16:26:48 <shapr> yay!
16:26:49 <SourceCode> looks pretty cool
16:27:00 <Cale> hmmm... @eval ones
16:27:16 <jadrian> Cale: I tried that :P
16:27:17 <shapr> SourceCode: so, wanna try some of the harder stuff like a whole compiler?
16:27:22 <SourceCode> hehe nah
16:27:26 <SourceCode> i really don't have time 
16:27:34 <shapr> aw, maybe next time?
16:27:37 <jadrian> Cale: doesn't work ;)
16:27:49 <SourceCode> yea
16:27:51 <SourceCode> in a few weeks
16:27:54 <SourceCode> i won't be so busy:)
16:27:57 <shapr> yay!
16:28:04 <SourceCode> like after mid-june
16:28:05 <SourceCode> hehe yea
16:28:07 <shapr> come learn to lift lambdas!
16:28:10 <SourceCode> LOL
16:28:46 <SamB> I practiced writing badly about how wonderful Haskell is today
16:28:50 <shapr> we can take that crazy C brain and teach you how to find the Zen of Head Normal Form
16:29:03 <SourceCode> haha
16:29:22 <Cale> such terrible puns :) quite good, too.
16:29:31 * shapr grins
16:30:04 <SourceCode> lol
16:30:18 <shapr> ok, I'll stop the cheesy humor for the moment
16:30:33 <shapr> SamB: what did you write?
16:31:00 <SamB> shapr: lifting lambdas is the compilers job, anyway.
16:31:26 <shapr> that's true
16:32:10 <SamB> shapr: you don't think I want to put this up where somebody who doesn't know haskell might possibly have a chance of bumping into it, do you?
16:32:34 <shapr> well, everyone starts at the beginning
16:32:40 <SamB> well, maybe with a disclaimer.
16:33:13 <shapr> if you put it up and solicit suggestions for improvement maybe?
16:42:13 <SamB> maybe.
16:46:46 <skew> SamB: are you intentionally writing badly about Haskell?
16:47:36 <SamB> skew: no, I just was unable to write goodly
16:48:20 <shapr> hi nuncanada, looking for Haskell info?
16:49:37 <nuncanada> heya, just keeping a look what ppl say in the interesting channels :)
16:50:04 <skew> < shapr> we can take that crazy C brain and teach you how to find the Zen of Head Normal Form
16:50:05 <nuncanada> have never used haskell myself. But i find functional programming very interesting... Not to say Haskell sexy :)
16:51:35 <stepcut> I wonder if I could cast my own gas power engine
16:52:02 <stepcut> that would be sweet
16:52:18 <shapr> I want a heat semiconductor
16:52:31 <jadrian> hmmm I wonder why isn't there a default Show instance for Sets...
16:52:39 <jadrian> there is a setToList function
16:53:10 <shapr> then you can create an artificial temperature gradient to get 'free' energy.
16:53:26 <jadrian> so it could be just something  like  show.("Set "++).setToList
16:53:31 <shapr> would be good for a refrigerator at least.
16:54:04 <shapr> jadrian: that's my generic show instance for FiniteMaps
16:54:18 <skew> shapr: a magic second law violation?
16:54:23 <shapr> show fm = show fmToList fm
16:54:30 <shapr> no violation
16:54:42 * jadrian is sleepy 
16:54:46 <jadrian> off to bed
16:54:47 <shapr> steam engines turn heat into mechanical energy
16:54:48 <skew> interesting. how does it work?
16:54:49 <jadrian> bye
16:55:15 <shapr> thermocouples too
16:55:41 <skew> oh, you didn't mention a power supply somewhere
16:56:22 <shapr> I just wish I could find something that would only conduct heat in one direction
16:56:50 <skew> all those heat engines need to dump heat somewhere with a lower temperature
16:57:03 <shapr> the power source would be the ambient heat, it's a heat cell, just like a solar cell
16:59:01 <shapr> if you can bias heat conduction according to direction, it'd make heat cells easier to build
16:59:38 <skew> you can't just take ambient heat and get energy out, you need a temperature gradient
16:59:54 <shapr> yup
17:00:12 <shapr> and a heat semiconductor would give you part of that
17:00:49 <shapr> think of a sphere of liquid that you shake to start the gradient
17:01:24 <skew> you can't just take something at constant heat and get a gradient either...
17:01:43 <shapr> and the heat conduction bias of a heat semiconductor could keep the gradient going (I think)
17:01:48 <skew> at least not without putting in more energy than you can extract
17:02:41 <skew> not any more than you can use an electrical diode to keep up a current loop while you tap that for power
17:03:43 <shapr> right, but this is just about turning ambient existing heat into something we can use to power a laptop
17:04:19 <shapr> no perpetual motion machines for me
17:04:28 <shapr> greetings Olathe 
17:04:37 <Olathe> Hello
17:04:46 <shapr> hunting the wiley lambda?
17:04:51 <Igloo> I was wondering earlier today iw, if you put a magnet on one shoe and a wire (coil?) on the other whether you could generate enough energy by induction to power a watch
17:05:06 <Olathe> Finding out what type of language Haskell is
17:05:16 <stepcut> Igloo: i think there are watches that are powered simply by moving your arm around
17:05:19 <skew> second law is mostly that all those little air molecules bouncing around and being hot don't just happen to line up and do something useful, unless you give them a push
17:05:30 <shapr> Olathe: would you like to see some demos?
17:05:38 <SamB> Olathe: it is many kinds of language
17:05:42 <Igloo> stepcut: Is that using induction?
17:05:50 <Olathe> shapr : OK
17:05:51 <stepcut> Igloo: beats me
17:05:57 <Igloo> OK  :-)
17:06:01 * Igloo heads bedwards, anyway
17:06:09 <shapr> there are self-winding watches, I've taken some apart
17:06:20 <shapr> they use an off-center weight on a post
17:06:28 <shapr> Olathe: http://www.scannedinavian.org/AvianWiki/HaskellDemo
17:06:42 <Olathe> Thanks
17:07:01 <shapr> Olathe: that's a short syntax demo, I can show you larger bits of code if you like
17:07:03 <Jerub> I knew a guy who had one.
17:07:21 <Jerub> he'd take it off and wave it around in meetings to wind it.
17:07:31 <Jerub> (being a programmer, he didn't move his arms enough to wind it)
17:07:42 <shapr> ha!
17:08:04 <stepcut> http://science.howstuffworks.com/question285.htm
17:08:24 <shapr> I've wondered about making generator hubs in cycle tires
17:09:14 <skew> I've seen bike lights with a little wheel you put on the tire
17:09:18 <shapr> skew: anyway, that's is all dependent on a heat semiconductor, know of any?
17:09:49 <stepcut> skew: I used to have one of those
17:10:03 <SamB> shapr: I there is something wrong with the syntax-highlighting there...
17:10:03 <stepcut> skew: we used to ride as fast as we could so the light would get really bright :)
17:10:09 <SamB> -- Typeclasses let you define the same operations on different types
17:10:09 <SamB> -- the operators equal to ( == ) and output left in -
17:10:09 <SamB> not equal to ( /= ) are in the typeclass Eq
17:10:09 <SamB> instance Eq Temp where
17:10:17 <shapr> oh
17:10:25 <shapr> that's a bug I need to fix
17:10:53 <skew> I've heard of somebody making a bike with a fancier generator thing that ran a computer, with a chord keyboard on the handles and such
17:11:32 <skew> and then just riding the country (US?) working from there
17:11:45 <shapr> that would be nifty
17:11:49 <skew> shapr: you should do that with your unicycle
17:11:53 <shapr> yes!
17:12:23 <skew> do you think you could use a normal laptop?
17:12:30 <Jerub> I find that excercise and advanced cognition are incompatible.
17:12:36 <shapr> if it's waterproof
17:12:54 <shapr> I think better while and after exercising
17:13:10 <skew> you could get a huge umbrella, and put solar cells on it
17:13:45 <shapr> oh, have you seen the solar cell cover made for some laptop models? that's a useful thing
17:13:49 <Jerub> shapr: really? I find I think better after, but I can't even think through simple problems while doing treadmill or weights.
17:13:53 <Jerub> or riding my bike.
17:14:21 <shapr> Olathe: any questions? want the general overview? have experience with other FP languages?
17:15:06 <Olathe> I'd like to look at the general overview, I guess. I don't really have experience with functional languages.
17:15:20 <shapr> @learn
17:15:20 <lambdabot> http://www.haskell.org/learning.html
17:15:21 * Jerub goes shopping + stuff.
17:15:39 <shapr> that has several tutorials you may find interesting
17:15:44 <Olathe> Thanks
17:16:26 <shapr> I'd say important points are referential transparency, immutability, recursion, and pattern matching
17:17:01 <shapr> oh, and being based lambda gives you partial application
17:17:18 <shapr> "on lambda calculus"
17:17:47 <shapr> @shapr
17:17:47 <lambdabot> needs sleep
17:18:48 <stepcut> @stepcut
17:18:48 <lambdabot> Sorry, I don't know the command "stepcut", try "lambdabot: @listcommands
17:18:50 <stepcut> !!!!
17:18:59 * shapr grins
17:19:18 <shapr> ok, what's your response?
17:19:32 <stepcut> hrm, i will have to ponder that
17:21:29 <shapr> @dynamic-reload dummy
17:21:30 <lambdabot> module reloaded
17:21:35 <shapr> @stepcut
17:21:35 <lambdabot> juicy bits of code
17:21:40 <shapr> :-P
17:22:19 <shapr> those arrows are nice
17:22:51 <stepcut> haha
17:22:56 <shapr> Olathe: any specific questions?
17:23:02 <stepcut> mmm arrows
17:23:10 <stepcut> someday I hope to get back to those
17:23:25 <stepcut> but I have (atleast) two big haskell projects to do before that
17:23:35 <shapr> oh, what are they?
17:23:48 <shapr> neat stuff? open source?
17:23:59 <stepcut> (1) A platform for secure web application development (built on top of wash/cgi)
17:24:15 <Olathe> shapr : Not yet. I'm reading through the Why Functional Programming paper
17:24:30 <shapr> Olathe: feel free to ask if you think of some
17:24:34 <Olathe> shapr : OK :)
17:24:35 <stepcut> (2) I need to do more on the scheme->swf compiler because I need to use it for a different project :)
17:25:20 <stepcut> I think I will release parts or all of both projects under something like the BSD license
17:26:08 <shapr> oh, I've been thinking about web pub with haskell, I think the best approach is to "derive WebPublish" to generate web based setters/getters for a datatype, and combine that with a templating system
17:27:06 <stepcut> interesting
17:27:30 <shapr> have you seen archetypes in Zope?
17:27:35 <stepcut> nope
17:27:38 <stepcut> never used zope
17:28:11 * shapr grabs links
17:29:39 * stepcut grabs princess zelda
17:30:04 <shapr> :-)
17:30:53 * stepcut goes to clean the bathroom, bbiab
17:31:53 <shapr> hoi earthy, you're unlocked?
18:30:48 <SamB> hmm, I wonder how much like monads Deferreds are...
18:31:25 <bluejay> What's a Deferred?
18:32:22 <SamB> bluejay: it is a thing in Twisted, a nice asynch networking framework for Python
18:32:47 <bluejay> Oh, I've heard of that. *looks it up*
18:39:06 <SamB> I'm hoping somebody will figure out the moral equivalent of a deferred in Haskell soon, and write a paper on it.
20:47:43 <bluejay> wow, people _are_ mean on #c. A guy came in with a simple pointer question and they flamed him.
20:49:01 <SamB> bluejay: wow
20:49:12 <SamB> who is this guy?
20:49:16 <flaw> hehe
20:49:23 <SamB> maybe we should take over for #c ;-)
20:49:41 <bluejay> milosn, he left
20:49:43 <saz> hehe
20:49:49 <saz> #haskell is so much nicer than #c
20:50:14 <Jerub> never spent time in #c
20:50:21 <Jerub> but I used to hang in #debian lots+lots.
20:50:23 <bluejay> He took it pretty well, but they could easily have taught him something, and instead they told him to find a book
20:50:27 <Jerub> go there recently, and its all hate.
20:50:29 <Jerub> :(
20:50:34 <saz> Jerub: isn't #debian a little infamous for its kindness?
20:50:53 <Jerub> saz: I've been flamed there on extremely little provocation.
20:52:18 <SamB> I think debian is a little infamous for its high scroll rate
20:52:24 <SamB> err, #debian
20:53:35 <Jerub> SamB: that too.
20:53:53 <blackdog_> C programmers are a little less evangelical than haskellers, i suspect. for good reason, too.
20:55:56 <SamB> blackdog_: true.
21:00:51 <desrt> C is the greatest language on earth
21:00:58 <desrt> the use of all other languages is pointless
21:01:01 <desrt> they all come from C
21:04:08 <desrt> mm.  if i was a bit more bored i'd go trolling in #debian :)
21:08:12 <Shammah> desrt: you could be a little more imaginative....
21:08:42 <desrt> quite.  i was also thinking about writing a function :: String -> String
21:08:50 <desrt> takes a C program and produces assembly output
21:08:59 <Shammah> I remember a fledgeling vi vs. emacs war on a list I frequent, completely derailed and sidetracked when one of the participants decided to champion *ed* :)
21:11:40 <Shammah> that was definately the most entertaining editor-war I've witnessed.
21:12:08 <desrt> vi vs. emacs is no war
21:12:20 <Jerub> vim vs. emacs is a real war.
21:12:36 <desrt> no
21:12:37 <Jerub> vi users are an evolutionary dead-end.
21:12:39 <desrt> vim vs. emacs is a slaughtering
21:12:40 <SamB> desrt: meaning they are for different things, or meaning emacs rules all?
21:12:40 <Shammah> ahh jerub, I thought you had left already.
21:12:50 <Jerub> Shammah: I have left in sprit.
21:12:59 <desrt> meaning vi rules all
21:13:09 <desrt> vi beats emacs
21:13:13 <desrt> vim just destroys without mercy
21:13:15 <Jerub> desrt: I stand behind my evolutionary dead-end comment.
21:13:16 <Shammah> ahhh looks like I have to fetch greg to intervene on behalf of ed again ;)
21:13:27 <Jerub> :)
21:13:32 <desrt> i'm not about to engage in a flamewar
21:13:36 <desrt> again, not that bored :P
21:13:52 <desrt> let's just say that we all know that i'm right and leave it at that
21:14:01 <desrt> *cough*
23:16:29 <anduril1> who broke haskell.org ?
23:26:25 <Riastradh> He did.
23:26:27 * Riastradh points wildly.
23:35:16 <skew> actually, there somebody in Python was directed to haskell.org
23:35:38 <skew> so of course it promptly went down :(
23:37:04 <SamB> skew: actually, it went down before I said that _the_ language was probably haskell 4
23:38:42 <skew> haskell 1.4?
23:39:26 <SamB> skew: the haskell which will come 3 haskells after this one.
23:40:21 <SamB> decades from now, I guess
23:51:52 <Cale> Is haskell.org having hardware problems or something? It seems that it goes down on a regular basis now.
