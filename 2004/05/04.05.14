00:49:26 <ganymede> isn't there a netbsd package for darcs ?
00:59:40 <juhp> anyone use automake with ghc nicely?
01:37:31 <Pseudonym> Nytol.
03:03:10 <shapr> yow!
03:10:12 <shapr> hej tumm_
04:05:08 * shapr bounces happily
04:09:56 <Philippa> you just got a pogo stick?
04:11:28 <shapr> nah, just writing a bit of fun code
04:11:41 <shapr> hi Philippa, wassup?
04:12:48 <Philippa> having trouble finding directions for where I'm supposed to be tomorrow
04:13:02 <Philippa> which is great fun as I get on a train in about three hours
04:13:55 <shapr> where are you going?
04:14:19 <Philippa> an NUS trans day that's been massively misorganised and is supposed to educate random SU bods from varying unis
04:16:00 <Philippa> all praise student politics!
04:16:02 <Philippa> *ahem*
04:27:17 <shapr> what do those stand for? national union of students / student union ?
04:28:25 <andersca> grr
04:28:27 * andersca slaps parsec
04:31:30 <JaffaCak1> andersca: perhaps you should be more Happy :)
04:33:12 <andersca> ah, found the error
04:33:16 <andersca> need to parse operators before integers
04:33:44 <Philippa> shapr: yep
04:34:07 <shapr> JaffaCake: does GHC do the class local stuff already?
04:34:19 <JaffaCake> you mean associated types?
04:35:35 <shapr> yup
04:35:42 <JaffaCake> no, not yet
04:36:00 <JaffaCake> we're not sure it's quite the right thing
04:36:05 <JaffaCake> (but Chilli might disagree)
04:36:11 <shapr> yup
04:36:43 <JaffaCake> having AT *and* functional dependencies seems overkill
04:36:47 <andersca> JaffaCake: I did find the problem
04:37:05 <andersca> JaffaCake: I couldn't parse "+" because I tried to parse it as an integer before an operator :)
04:37:34 <JaffaCake> andersca: just wanted to do a bit of Happy advocacy :)
04:37:50 <andersca> :)
04:37:52 * andersca likes happy
04:38:40 <shapr> is there a happy tutorial like Parsec's tutorial?
04:38:59 <JaffaCake> the manual has some tuturial-ish bits
04:39:21 <JaffaCake> http://www.haskell.org/happy/doc/html/happy.html
04:39:22 <andersca> I tried getting line and column numbers out of happy/alex, that was a bit tricky
04:39:41 <JaffaCake> yeah, it's not trivial by any means
04:40:05 <JaffaCake> GHC 6.4 will have absolutely accurate line/column numbers for everything, BTW
04:40:21 <andersca> wow, that's nice
04:40:36 <JaffaCake> in fact it keeps the actual source *span* for every syntactic entity
04:40:43 <andersca> cool!
04:40:54 <shapr> that's nifty
04:41:03 <JaffaCake> this is for Visual Studio: when you get a type error, it highlights the expression
04:41:13 <shapr> sounds like it could be useful fer HaRe too
04:41:18 <JaffaCake> yeah, definitely
04:41:53 <JaffaCake> was a real pain to implement, though :-/
04:42:06 <shapr> are you saving the ASTs or what?
04:42:14 * saz remembers being told that haskell will become part of VS soon way back in first year..
04:42:25 <Philippa> hah
04:42:31 <JaffaCake> shapr: not sure what you mean
04:42:38 <JaffaCake> saz: it's still coming soon ;)
04:42:54 <saz> JaffaCake: hehe :)
04:43:08 <andersca> something like ? newtype ExprSpan = ExprSpan Expr Loc Loc
04:43:15 <Philippa> I believe you mean Real Soon Now :-)
04:43:24 <JaffaCake> yup, that's the expression
04:43:46 <JaffaCake> andersca: yes, we have data Located a = Located SrcSpan a
04:44:06 <JaffaCake> and then you have Located Expr, Located Binding, etc.etc.
04:44:08 <andersca> nod
04:44:23 * andersca is writing a small functional language that's meant to compile to ILX
04:44:35 <JaffaCake> like F#
04:44:36 <JaffaCake> ?
04:44:45 <andersca> yeah
04:44:48 <andersca> although way smaller
04:44:53 <JaffaCake> right
04:45:09 <andersca> it's for a programming language course I'm taking
04:45:12 <andersca> john hughes is giving it
04:45:19 <JaffaCake> ah, i c
04:45:34 <JaffaCake> that's a fun project
04:46:35 <Andre4s> does haskell support templated?
04:46:42 <Andre4s> templates
04:46:53 <JaffaCake> yes, though probably not in the way that you think ;)
04:47:16 <Shammah> First you'll have to let us know what you think templates actually are. :)
04:47:21 <JaffaCake> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
04:49:05 <Andre4s> thanks
04:53:45 <andersca> you can also compare C++ templates/C# generics with polymorphic functions in haskell
04:56:42 <Andre4s> what is haskell used for .. now days?
04:58:23 <Cale> I'm working on a compiler for a new high-level language for optimised high-bandwidth MRI image processing, written in Haskell.
04:58:36 <andersca> Cale: cool
05:00:02 <Cale> Well, that's not the only thing the language is for, but that's our first target application.
05:00:52 <Cale> I got hired on as a summer student for the Coconut project - see http://www.cas.mcmaster.ca/~anand/
05:01:32 <Igloo> andersca: You might find the igloo example directory in the (CVS only, I think) happy source useful
05:02:53 <shapr> Cale: I think data parallelism would be very helpful for that project
05:04:58 <shapr> hi Andre4s, are you in norrbotten?
05:05:20 <Andre4s> G‰vle
05:06:00 <shapr> isn't that near Lule√•?
05:06:12 * shapr checks
05:06:18 <dr_fripp> hey shapr
05:06:21 <Andre4s> it's in middle sweden .. south from norrbotten
05:06:24 <shapr> hoi dr_fripp
05:06:30 <shapr> ah ok
05:06:36 <Andre4s> have you been there?
05:06:37 <dr_fripp> does anybody ahve any experience with converting Expr a's to Int?
05:06:55 <dr_fripp> because we can't get it done
05:07:06 <shapr> Andre4s: I live in Boden, but I'm sort of new to the country
05:07:16 <dr_fripp> when I want a string I just use show, but an int is kinda impossible
05:07:39 <andersca> Andre4s: join #haskell.se!
05:08:42 <Andre4s> andersca: another time maybe
05:08:54 <shapr> dr_fripp: you could read the string, but that's cheesy
05:09:11 <shapr> Andre4s: are you learning Haskell for business or pleasure?
05:09:55 <Andre4s> I'm not learning it, just came a cross it by mistake. Here just to check it out a bit
05:10:09 <shapr> do you have any questions?
05:10:28 <andersca> it's a great language
05:10:59 <shapr> Sweden has one of the best places for Haskell, Gothenburg has GU and Chalmers
05:11:01 <Andre4s> what make is so great?
05:11:16 <Andre4s> is = it
05:11:18 <shapr> and Boden, the worlds center for hi-tech ;-)
05:11:37 <Philippa> the level of control over how things're put together. If you can think of a system design, odds are you'll have an easy time implementing it in Haskell
05:12:04 <Philippa> and that goes for some things that're a massive pain in the arse in eg most OO languages
05:12:06 <shapr> also, it's easier to test, reuse, and modularize Haskell code
05:12:18 <Philippa> well yeah, but for the same reason :-)
05:12:27 <Philippa> no hidden connections to keep track of
05:12:43 <shapr> right, OOP holds the state inside each object
05:12:59 <Andre4s> how come " it's easier to test, reuse, and modularize Haskell code" ?
05:13:02 <shapr> that means each library has a lot of init cost
05:13:07 <Philippa> though personally I like the idea of monads as a generalisation of objects (or more accurately, classes)
05:13:31 <Philippa> Andre4s: because it's a "pure" language. Nothing goes anywhere without it being explicitly declared
05:13:34 <shapr> with Haskell, state is passed explicitly, so separation is much more natural
05:14:08 <shapr> Andre4s: have you tried to test J2EE software, or other large OOP system?
05:14:18 <Andre4s> yes
05:14:41 <shapr> manufacturing a set state, or getting the system into a known state is a lot of trouble
05:15:17 <Andre4s> heskill is a functional language right?
05:15:23 <Philippa> yeah
05:15:31 <shapr> Haskell requires everything to be explicitly passed, but makes it very little trouble to do so
05:15:32 <Philippa> specifically a pure, non-strict one
05:15:55 <Philippa> (unfortunately I gotta get ready to go out, so I won't be paying too much attention here)
05:16:09 <Andre4s> never used a functional language .. some Lisp for emacs .. if that counts =)
05:16:49 <shapr> yes, elisp is closer than C
05:16:58 <shapr> much closer
05:17:20 <shapr> another difference is that higher order functions are normal
05:17:54 <shapr> that means that a function is a value just like an int, and you can operate on it just like any other value
05:17:55 <Andre4s> paste a small hello world example just so that I can see it
05:18:00 <Andre4s> how it look
05:18:25 <shapr> here's something I wrote: http://www.scannedinavian.org/AvianWiki/HaskellDemo
05:18:37 <maihem> Hi shapr
05:18:46 <shapr> lambdabot is written in Haskell if you want to see something larger
05:18:50 <shapr> hiya maihem 
05:18:59 <maihem> Well I'm buggered if I can find those docs in the IRC logs :/
05:19:04 <shapr> Andre4s: Haskell √§r j√§ttekul
05:19:54 <Andre4s> dont make sense :)
05:20:09 <maihem> I think the most significant thing about haskell over common imperative languages like C and java is the simplicity and elegance of curried functions
05:20:29 <shapr> @eval (\x -> x + 1) 1
05:20:29 <lambdabot> 2
05:20:40 <shapr> @eval map (\x -> x + 1) [1,2,3]
05:20:40 <lambdabot> [2, 3, 4]
05:21:13 <shapr> that's an example of a higher order function, map uses the function like a hammer on a row of nails
05:21:26 <maihem> @eval ((\x y -> x + y) 1) 2
05:21:26 <lambdabot> 3
05:22:06 <maihem> curried function, (\x y -> x + y) takes a number to make another function that takes a number to make a number, it does not take two numbers
05:22:08 <shapr> Andre4s: which languages have you used before? maybe I can show some similarities?
05:22:28 <maihem> *that* is the beuty of haskell for me
05:23:24 <Andre4s> java,c,c++.perl mostly
05:23:32 <JaffaCake> @eval (\x -> x x) (\x -> x x)
05:23:47 <lambdabot> out of fuel - use @resume to continue
05:23:51 <JaffaCake> hehe
05:25:14 * shapr tries to think of a good comparison
05:26:21 <shapr> dang, where's sebastian sylvan's intro?
05:26:43 <shapr> http://www.haskell.org/complex/why_does_haskell_matter.html
05:26:44 <shapr> aha
05:27:23 <shapr> Andre4s: that url has C++ examples next to Haskell examples
05:27:43 <Andre4s> k
05:28:01 <Andre4s> does it work kind of like prolog?
05:28:20 <shapr> a little bit
05:29:14 <shapr> there are really three flavors in my opinion, procedural (C,C++,Java), Logic (Prolog,Mercury), and Functional (Haskell, Ocaml,SML)
05:29:29 <shapr> lisp is somewhere in the middle of those
05:29:59 <Andre4s> ok
05:30:46 <Philippa> when I first learnt prolog I thought of it as being like Haskell backwards
05:30:54 <shapr> Haskell lets you do function composition and partial application, which is more difficult in procedural langs
05:31:21 <shapr> for example, "add x y = x + y" is probably obvious
05:31:45 <shapr> but then later you can do "addOne = add 1"
05:31:55 <Philippa> Andre4s: if your C++ code has a high expression:statement ratio you'll like this
05:32:18 <shapr> and the addOne function acts like "add y = y + 1"
05:32:34 <Philippa> *cough*1+y*cough* :-)
05:32:36 <Marvin--> shapr: 1 + 7 ;)
05:32:39 <Philippa> not that it matters here
05:32:41 <Marvin--> er, 1+y
05:32:50 <shapr> picky people :-P
05:32:56 <Marvin--> Philippa: yay, picky people unite!
05:33:14 <Philippa> go on, explain pattern-matching next...
05:33:16 <shapr> Andre4s: forst√•r du?
05:33:26 <Andre4s> yes
05:33:45 <Maddas> Yeah, explain pattern-matching, Philippa is just waiting to find things to correct you on! :-P
05:33:54 <Philippa> heh
05:33:57 <Philippa> nah, I'm off to the pub soon
05:33:59 <shapr> oh, pattern matching is nifty
05:34:10 * Philippa nods
05:34:21 <shapr> pattern matching looks like you write a function multiple times
05:34:38 <andersca> mmm, pub
05:34:41 <Philippa> well, that part's just syntactic sugar...
05:34:50 <shapr> the different ones are tried in order till one matches, then that one gets to excute
05:34:52 <Maddas> Hah
05:34:54 <Maddas> Philippa: So I was right
05:34:58 <shapr> mylength [] = 0
05:35:14 <Philippa> I could live with all my functions being f parm = case (parm) of...
05:35:15 <shapr> mylength (x:xs) = 1 + mylength xs
05:35:26 <Philippa> Maddas: no, I just do it by instinct :-)
05:35:42 <shapr> that function says, if I get an empty list, return zero
05:36:07 <Marvin--> Philippa: if you want to be *that* way, you could say that most of haskell is just syntactic sugar for lambda calculus
05:36:09 <shapr> if I get a list with one or more items, assign the first item to x, and everything else to xs
05:36:23 <andersca> Marvin--: which is syntactic sugar for turing machines
05:36:32 <shapr> then return 1 plus the value of calling myself with xs
05:36:42 <shapr> Andre4s: ja?
05:36:43 <maihem> I'm looking for (I think - Haddock) documentation for GHC CVS Head. The heirarchical libraries docs includes the new HOpenGL API and the HGL API. I've googled, SearchML'd, and grepped the IRC logs, but alas, I can't find anything. Anybody know anything?
05:36:58 <Philippa> Marvin--: that's a bit more blatant a statement though. The function pattern-matching is directly defined as syntactic sugar for case, which is why you have to keep all the patterns for a given function together
05:37:23 <Philippa> also, knowing that case exists is useful
05:37:50 <Marvin--> Philippa: of course it's useful to know that case exists :)
05:37:50 <Philippa> anyway, I'll shut up and let the explanation continue...
05:38:08 <Marvin--> when you've seen Haskell's case expressions you will loathe the inferior switch statement forever
05:38:14 <Philippa> no shit
05:38:29 <shapr> yah, I agree
05:38:45 <Philippa> I'd love it if C++ had tagged unions...
05:38:52 <shapr> same for nested if else, once you find out that Maybe is a monad
05:39:18 <Philippa> Maybe () :-)
05:39:24 <shapr> Andre4s: √§r du forvirrad eller hur?
05:41:18 <Marvin--> japp, nu har vi skr√§mt iv√§g honom :(
05:41:26 <Andre4s> shapr: en aning, intressant l‰sning dock
05:41:46 <Marvin--> anyway, English, or #haskell.se
05:42:15 <shapr> Andre4s: by the way, you can use autoinsert or jdee to create java class info when you open a .java file in emacs
05:42:18 <shapr> right
05:42:54 <shapr> I probably can't explain fp in swedish anyway
05:43:55 <shapr> Andre4s: any questions? wanna see some working code?
05:44:30 <Andre4s> shapr: I dont have time
05:45:06 <shapr> you should come back when you do, Haskell r0xx
05:45:19 <Andre4s> got homework
05:45:21 <Andre4s> sure
05:45:35 <shapr> and there's EuroHaskell in summer in gothenburg
05:45:47 <shapr> the ultimate in academic lan parties
05:45:53 * maihem sighs
05:45:55 <Andre4s> thanks for your time shapr and others
05:45:55 <Lunar^> shapr: It's in less than one month now
05:46:04 <shapr> Lunar^: yay!
05:46:32 <shapr> Andre4s: you're welcome, come back and see us!
05:47:04 * Andre4s never fellet so welcomed on a irc channel
05:47:09 <shapr> maihem: so you'll have your passport for next hackfest, right? :-)
05:47:22 <maihem> next one ;)
05:47:32 <shapr> Andre4s: oh, I forgot to mention, really friendly user community, and that's a huge plus.
05:47:44 <maihem> I made my laptop work specially too :/
05:47:46 <Andre4s> yes it really is
05:47:58 <Marvin--> the friendly use community is all shapr, the rest of us are indifferent bastards ;)
05:48:04 <shapr> haha
05:48:11 <Andre4s> lol
05:48:37 <maihem> go ahead, laugh...
05:48:47 <Andre4s> back to the books
05:49:24 <shapr> maihem: we'll be on irc during, you can join in that way
05:49:36 <indifferent_bast> yay!
05:49:43 <indifferent_bast> bugger, too long
05:49:52 <shapr> hah
05:49:56 <Maddas> heh
05:51:32 <shapr> I learned much of what I know about Haskell on this channel, lots of helpful folks here.
05:52:01 <dr_fripp> well you sure so pass it on
05:52:06 <dr_fripp> *do
05:52:36 <dr_fripp> I think this channel is a must for anyone programming in haskell
05:53:25 <neologism> so help me - are you able to compile haskell program with ghc 6.2.1 with -main-is X ?
05:53:37 <neologism> I have had no luck so far
05:54:50 <shapr> what OS/version?
05:55:02 <neologism> fbsd 5-current
05:55:44 <shapr> do you have a short piece of test module you could put on the test page?
05:55:51 <neologism> shit... it works now!
05:55:57 <shapr> er "paste page"
05:56:02 <shapr> see, I'm good
05:56:08 <neologism> I commited whole yesterday to this and it works now ;)
05:56:12 <shapr> remote mind rays repaired your GHC
05:56:14 <neologism> you are my god now, shapr
05:56:19 <neologism> ;)
05:56:20 * shapr laughs
05:56:36 <shapr> you should make beer offerings to the GHC authors
05:56:38 <dr_fripp> join the club, neo :P
05:56:54 <dr_fripp> of shapr worshippers
05:57:00 <shapr> oy
05:57:23 <iolotusbobo> hello shapr
05:57:29 <shapr> any donations go to the channel hackfest+beer fund
05:57:39 <neologism> I have been worshiping him since yesterday (he advised me with monads)
05:57:39 <shapr> hi iolotusbobo 
05:57:47 <iolotusbobo> howdy shapr
05:58:15 <dr_fripp> I've been worshipping him for many weeks now
05:58:25 * shapr hides
05:58:57 <dr_fripp> let's organize a pilgrimage to his hometown
06:00:20 <shapr> come to EuroHaskell!
06:00:34 <shapr> it'll be more fun than Alabama :-P
06:00:40 <Marvin--> or Boden :P
06:02:10 <shapr> right, Gothenburg has a nightlife
06:12:34 <shapr> I want more libraries
06:13:16 <eivuokko> Libraries or cool libraries to play with? ;)
06:14:02 <ozone> yo
06:14:08 <ozone> i have an inquiry
06:14:27 <shapr> eivuokko: cool libs to play with
06:14:29 <ozone> can anyone think of a short haskell-ish program to solve a problem (like, something that haskell would be good for solving)
06:14:35 <ozone> about a page long or so
06:14:44 <ozone> ... which would be really nice to wrap up in a gui?
06:15:11 <Cale> you want to do the gui part?
06:15:25 <ozone> as in, something which you say "damn, this haskell program's really neat, it's heaps shorter than it would be in another language.  now if only i could wrap this up in a gui"
06:15:38 <ozone> i can do the GUI part, i'm looking for a nice example program
06:15:40 <Cale> heheh
06:16:12 <ozone> there are plenty of boring "look, write a GUI program with haskell and it has menus and graphics and stuff, hooray"
06:16:41 <ozone> but not many examples i've found which are geared to take advantage of haskell's nice features (e.g. strong list processing facilities)
06:17:09 <shapr> what about an RSS aggregator?
06:17:43 <ozone> can you write that in a line of code?
06:17:48 <ozone> err
06:17:49 <ozone> a page :)
06:18:00 <shapr> probably
06:18:21 <shapr> would require some HaXML or HXT backup
06:18:37 <ozone> hmm, needs to be something that'll work with standard GHC libraries
06:18:49 <ozone> it's OK, i'll make do with an example
06:19:01 <ozone> was just wondering if anybody could think of one off the top of their head
06:19:55 <shapr> gantt chart?
06:20:31 <ozone> what's that?
06:20:34 <shapr> easy to express with an algebraic type, but more useful with a gui display
06:20:46 <shapr> the dependency graphs in MrProject
06:21:22 <shapr> and in Ms Project
06:21:48 <shapr> http://www.ganttchart.com/
06:22:04 <ozone> cool, thanks
06:22:07 <ozone> will check it out
06:24:10 * iolotusbobo prepares to quit()
06:25:42 <shapr> hej bkhl 
06:26:00 <bkhl> I'm about to build ghc here, and I'm wondering if it does any bootstrapping, or if I should do an intermediary build.
06:26:18 <bkhl> shapr, hallÂ.
06:26:24 <shapr> the build has two stages
06:26:30 <bkhl> Ok.
06:27:07 <bkhl> I'm not about to learn Haskell (right now). I'm just building it so I can use darcs.
06:27:18 <bkhl> So I'll be on my way now...
06:33:48 <shapr> ozone: if you have a nearby copy of fowler's "Analysis Patterns" chapter 8 is helpful for building a useful gantt-style tool
06:46:16 <dr_fripp> platypus the band?
06:54:13 <ozone> shapr: thanks
06:55:33 <Lunar^> shapr: I just booked the planes
06:57:06 <earthy> sounds like mr bobbio is heading off to sweden for eurohaskell
06:59:34 <Lunar^> damn my real name :)
06:59:35 <Marvin--> what about mr van Leeuwen, then? :)
07:01:37 * earthy won't make it
07:01:51 <earthy> unfortunately
07:04:59 <Marvin--> dang
07:10:05 * earthy knows Koen is at safelogic today, so he won't ask. ;)
07:11:04 <shapr> Lunar^: yay!
07:11:12 <shapr> earthy: aww
07:12:30 <Marvin--> earthy: well, I can send him a mail...
07:17:45 <earthy> ;)
07:17:47 <earthy> might work.
07:18:20 <earthy> I'm gonna drop either him or Patrik Jansson a call if I haven't seen anything by monday
07:28:38 <Marvin--> Koen complains about not having any time over whatsoever :)
07:29:08 <earthy> he's not the only one. ;)
07:31:54 <shapr> I have lots of time, but a surprising amount gets spent on work
07:33:32 <Marvin--> earthy: you might be better off talking to Patrik, John or Marcin Benke
07:33:54 <earthy> I was planning to
07:34:02 <earthy> not today though
07:37:37 <iolotusbobo> hello shapr...
07:37:50 <shapr> grretings iolotusbobo 
07:38:13 <iolotusbobo> aloha ... shapr
08:18:01 <Marvin--> does anybody know of a program that can insert bookmarks into an existing pdf file?
08:40:41 <shapr> hey SyntaxLaptop! ltns!
08:41:05 <shapr> how's LIP? are you stiil in the UK?
08:41:12 <JaffaCake> SyntaxLaptop: nice walk? :)
08:41:27 <SyntaxLaptop> y0y0 shapr
08:41:39 <SyntaxLaptop> hi simon :) 
08:41:47 <SyntaxLaptop> yeah, went really well.
08:42:02 <SyntaxLaptop> I survived. I even was able to mostly dry out my tent, because the sun came out at one point
08:42:07 <SyntaxLaptop> well, at least once ;)
08:42:20 <JaffaCake> hey
08:42:26 <skew> sounds fun
08:42:35 <SyntaxLaptop> I have 2570 emails to download...
08:42:38 <JaffaCake> oh dear :( hope it wasn't too dreik
08:42:45 <skew> for some reason, I'm thinking you walked back from the UK
08:42:54 <SyntaxLaptop> skew: that would be a challenge ;)
08:42:58 <Igloo> lol
08:43:01 <skew> that would explain the being wet
08:43:04 <SyntaxLaptop> but yeah, still in the UK. at Igloo HQ now
08:43:50 <shapr> SyntaxLaptop: so will we see a new LIP release soon?
08:43:51 <Hyp3rion> Hola.
08:43:58 <shapr> hi Hyp3rion 
08:43:59 <skew> any suggestions for teaching parser combinators?
08:44:19 <SyntaxLaptop> I was just waiting to see what, if anything, simon & simon had done about that since I've been gone
08:44:23 <SyntaxLaptop> I'm keen to see one, yeah :)
08:44:54 <JaffaCake> SyntaxLaptop: Simon PJ has updated the doc, as you'll see
08:44:54 <JaffaCake> it's in pretty good shape, we can publish it soon and get hacking on that prototype
08:45:23 <skew> Is GHC growing the fancier package namespace/grafting stuff any time soon?
08:45:49 <JaffaCake> not grafting, no
08:45:54 <JaffaCake> we couldn't find a scheme we were completely happy with
08:46:17 <skew> what were the issues?
08:46:51 <JaffaCake> well, implementability for one I think
08:47:26 <JaffaCake> once you have package versioning, it's not clear that you need the generality of grafting too
08:47:33 <JaffaCake> and the LIP includes package versioning
08:47:52 <skew> How does the versioning work, if not through some sort of grafting?
08:48:23 <JaffaCake> the simple scheme is that you're only allowed one version of a package in any given program
08:48:30 <skew> Ah
08:48:50 <JaffaCake> you can generalise that, but it means some implementation complexity and some language changes too
08:48:57 <skew> so it's easy because you are not actually solving any versioning problems
08:49:03 <Igloo> You lose some of the benefits of abstraction, though
08:49:04 <JaffaCake> er... yes :)
08:49:13 <JaffaCake> Igloo: yes
08:49:57 <JaffaCake> the Haskell Packages specification explains all this
08:50:12 <JaffaCake> will be available RSN
08:50:20 <skew> I thought the idea with grafting was that each package would have an internal name and possibly a graft point, code would refer to the graft point, and compiled code would refer to the internal name
08:51:07 <JaffaCake> yep (though I can't remember the details exactly, there were several proposals)
08:51:37 <skew> what was the issue, other than needing to implement it?
08:51:53 <JaffaCake> well, all compilers have to implement it
08:52:57 <JaffaCake> and perhaps we'll find that we do need it at some point... but the gains don't seem to be worth the effort
08:53:20 <skew> all it really solves is letting code compiled against different versions of a library coexist
08:53:27 <skew> although I don't know what else there really is to solve
08:53:44 <JaffaCake> you can still do that without grafting
08:54:12 <JaffaCake> grafting lets you refer to different versions of a library from the same source code *module*
08:54:22 <JaffaCake> unlikely that you'd need to do that
08:54:31 <skew> does it?
08:54:46 <JaffaCake> yes, by grafting the libraries to different parts of the hierarchy
08:54:53 <Igloo> Oh, when you said "program" above I thought you meant a whole program - that's not so bad
08:54:54 <skew> I thought the idea was that you would compile a library, upgrade a dependancy, and the old code still works
08:55:22 <skew> because it refers to the package version rather than package currently living at that point in the three
08:55:25 <skew> tree
08:55:32 <JaffaCake> skew: yes
08:55:37 <tyl3r> anyone can explain me a very simple thing in lambda calculus please
08:55:40 <JaffaCake> but you don't need grafting for that
08:55:50 <tyl3r> true = Lx.Ly.x and false = Lx.Ly.y (with L = lambda, the abstraction operator). I thought I understood the stuff, but I dont catch this example
08:56:07 <JaffaCake> Igloo: I think i did mean the whole program
08:56:28 <Igloo> Oh, OK
08:56:35 <skew> no? I thought as things are now trying to build something using the library after the upgrade would pull in the new version of the dependancy, breaking stuff
08:57:09 <skew> tyl3r: read the Unlambda manual and write some programs, and you will understand this stuff quite well
08:57:17 <Igloo> tyl3r: Suppose g is either true or false. Then  g e1 e2  is equivalent to if g then e1 else e2
08:57:30 <JaffaCake> Ok, we're getting a bit mixed up here....  I'll try to clarify
08:57:57 <JaffaCake> version 1 of the LIP will not allow multiple versions of a package to coexist in a program
08:58:10 <skew> tyl3r: yeah, the idea is that true X Y = Lx.Ly.x X Y = X and false X Y = Lx.Ly.X Y = Y
08:58:24 <JaffaCake> we can remove this restriction later, but doing so adds some complexity
08:59:05 <tyl3r> skew: where is the Unlambda manual
08:59:11 <JaffaCake> when we remove the restriction, you'll be able to have package A-1.0 depending on package B-1.0, and install package B-1.1, and package A will still work
08:59:15 <skew> tyl3r: the booleans alreay encapsulate some conditional behaviour
08:59:45 <JaffaCake> (at the same time as B-1.0)
08:59:46 <skew> tyl3r: http://www.google.com/search?&q=Unlambda
08:59:58 <skew> shapr: is there a way to tell lambdabot to look something up on google?
09:00:35 <skew> tyl3r: the unlambda page also explains stuff like pairs, variants, etc
09:01:24 <skew> the basic idea for representing values in the lambda calculus is to pass around a destructuing function instead of a value, if that makes any sense
09:01:45 <skew> for example, you can thing of if as a function like
09:01:51 <tyl3r> i'm talking about pure lambda calculus, not typed one, I'm trying to learn it from a course by J.L.Krivine, its not always  clear ;)
09:01:59 <skew> if True thn els = thn
09:02:03 <skew> if False thn els = els
09:02:42 <skew> the if function is all you actually need in the way of being able to examine a boolean value
09:03:14 <shapr> skew: nope, but there's a SOAP lib in-progress
09:03:15 <skew> if you were using a language like Haskell you might pass around a concrete boolean value
09:03:26 <shapr> Simon Foster is working on it
09:03:29 <tyl3r> until now, I catched that Lx.y.x was about exchanging all 'x' by 'x' in the rest of the expression
09:03:44 <tyl3r> so when you're talking with big X and little x, it confuses me 
09:03:54 <shapr> when it's released, lambdabot will be able to search google
09:03:59 <tyl3r> all 'x' by 'y' sorry
09:04:31 <skew> I like to be able to say "bot, google for X", as a gentle hint that somebody should have asked google for a link rather than poor old me
09:04:33 <Igloo> That doesn't sound right
09:04:48 <tyl3r> Igloo: are you talking to me ?
09:04:49 <Igloo> Lx.y.x doesn't really make sense anyway - do you mean Lx.Ly.x?
09:04:51 <Igloo> Yes
09:04:58 <shapr> yes, @google would be nice
09:05:34 <shapr> so would an inline command, like "check out @@wiki RecentChanges"
09:05:38 <skew> tyl3r: as I was saying, instead of passing booleans True or False around in a program, you can get by with passing around if True and if False, functions
09:06:09 <skew> tyl3r: then if you want to do conditional behaviour you just pass the then and else case to the boolean thingy you were given
09:06:42 <skew> similary you can represen a pair of values a and b as the lambda function Lf.(f a) b
09:06:51 <shapr> so, once lambdabot can search by type, what next? any other useful tool ideas?
09:07:32 <skew> and a sum with two cases as Lf.Lg.f a for value a in the left case, or Lf.Lg.g b for value b in the right case
09:07:42 <shapr> oh, I had an idea for a fit clone for Haddock
09:07:46 <skew> to be used like sumValue thingToDoForAnInt thingToDoForAString
09:08:22 <skew> tyl3r: so, is this value representation stuff making more sense?
09:08:35 <tyl3r> skew: not really, i suck!
09:08:54 <skew> tyl3r: oops, were you making noises like you didn't understand what a lambda expression like Lx.Ly.x meant as a function
09:09:12 * shapr has an idea
09:10:08 <skew> Lx.<expression with xs> is a function of one argument
09:10:12 * shapr wonders if mcmaster.ca hires teleworkers for their Haskell jobs
09:11:16 <skew> when you apply to something it replaces all the xs in the body with that argument
09:11:39 <skew> (except if you have something like Lx.Lx.x, where the x in the body referes to the inner x)
09:12:00 <skew> tyl3r: wait a minute, what languages do you know?
09:13:36 <neologism> skew: maybe using \x -> x haskell way would be clearer
09:13:50 <tyl3r> skew: ok Igloo explained me, i got it now ;)
09:14:17 <skew> neologism: yeah, I was just about to translate to another language, but I thought I should ask what he knew
09:14:53 <neologism> skew: ok...
09:15:44 <skew> tyl3r: so, do you understand how the values work, like booleans and lists and such
09:19:25 <tyl3r> skew: yop ;)
09:20:05 <skew> tyl3r: are you going to be writing any code in the lambda calculus?
09:21:12 <tyl3r> skew: i'm studying formal reverse engineering and I want to apply the curry-howard isomorphism to reversed code 
09:21:30 <skew> you think that might help?
09:21:42 <skew> logics corresponding to programming languages tend to be inconsistent
09:22:33 <tyl3r> well, that might help for the part of the code that can be extracted and recognized as sideffect-free
09:22:50 <skew> Aha, this program proves void - now it's all clear!! (if you are looking at C code)
09:23:00 <shapr> have you seen dark's uncc?
09:23:11 <skew> er, (int,char*) -> void, I guess
09:23:13 <tyl3r> shapr: yeah, its not what I want
09:23:34 <shapr> ok
09:24:33 <skew> tyl3r: I'm interested - what do you thing viewing the code as a proof of its type will do for you?
09:24:42 <skew> or are you making some other use of the isomorphism?
09:25:02 <skew> sounds nifty, I just wonder if it will be useful
09:27:20 <tyl3r> skew: the typechecking of binary code is one thing, but if I can 'compile' typed lambda calculus from binary code, then I can also compute side-effect free binary code very easily and eventually reduce the combinatorial explosion of model checking algorithms. Honnestly, I dont know if its gonna be really good, but I'm doing it for learning mostly
09:27:57 <skew> ooh, deriving code from proofs is nice
09:28:27 <skew> not quite curry-howard, or at least not curry-howard on the standard typesystem of the language
09:28:51 <skew> but very useful. That's really the heart of the power of the typeclass system
09:32:26 <skew> tyl3r: Pierce's "Types and Programming Languages" is a good book on type systems
09:33:50 <skew> it's actually the only one I've read, but it seems to explain pretty well everything you would need to know if you wanted to design your own type system complete with a type inferencer
09:34:25 <tyl3r> thanks, I also have a big course about system E and system F, I think I'm gonna start with that
09:34:40 <skew> E?
09:34:59 <skew> I haven't heard that name before. Is that a system with existential types?
09:35:32 <neologism> tyl3r: what school do you attend?
09:35:36 <ozone> oleg AT pobox.com is completely utterly mad
09:35:38 <tyl3r> Engeler model
09:36:16 <skew> ozone: who would that be?
09:36:52 <tyl3r> the course say that it is the syntaxic version of the simpliest typed lambda calculus
09:37:03 <ozone> skew: http://okmij.org/ftp/
09:37:24 <ozone> or see http://okmij.org/ftp/Haskell/ for his haskell stuff
09:37:30 <ozone> i'm just re-reading his post from about a year ago
09:37:33 <ozone> and i finally understand it
09:37:51 <tyl3r> neologism: french school ...
09:38:14 <neologism> name/year..
09:38:28 <ozone> in particular his types work (add types.html on to last URL i pasted)
09:39:43 <skew> ozone: wait a minute, aren't you the one who does all the crazy type class hackery?
09:39:50 <tyl3r> neologism: the courses I'm talking about are from jussieu university and ecole normale superieure, but I'm a student in an CS engineering school, so its different
09:39:53 <skew> like the integer indexed type heaps and so on
09:40:04 <ozone> skew: you're brandon michael moore?
09:40:10 <skew> yeah
09:40:12 <ozone> oh!
09:40:16 <ozone> i've been wanting to meet you for yonks
09:40:20 <ozone> no, i'm andre pang
09:40:31 <ozone> the guy who attempts to do crazy type class hackery and always fails. :)
09:40:41 <skew> oh, it is oleg that does all the weird stuff
09:40:49 <ozone> and then oleg comes along and saves the day
09:41:08 <ozone> skew: well, i was just re-reading that old thread you sent out on multiple inheritance
09:41:22 <ozone> i finally bothered to read oleg's post and it just clicked
09:41:23 <skew> although usually after seeing his solution I decide that it can't be done nicely in Haskell
09:41:40 <skew> the lack of backtracking really hurts
09:41:42 <ozone> yeah, i agree
09:41:53 <skew> the type class system is a pretty wimpy theorem prover
09:42:01 <ozone> well, the thing is, his solution actually works quite well for what you want
09:42:10 <ozone> the untidiness is a matter of syntax, imho
09:42:34 <tyl3r> neologism: I disapointed you ? ;o ;)
09:42:49 <skew> I think his code wasn't enough, but I don't remember the details
09:43:02 <neologism> tyl3r: no...
09:43:28 <ozone> skew: ah, that's right ...
09:43:29 <ozone> One part of the solution that I didn't like is that the constraint on a
09:43:29 <ozone> method had to explicitly list all the classes that declared that method.
09:43:34 <tyl3r> neologism: just kidding 
09:44:00 <skew> ozone: did it?
09:44:11 <skew> what do you mean, constraint on a method?
09:44:16 <ozone> skew: actually, i think oleg's last post blew away that constraint
09:44:19 <skew> I rememeber just a HasFoo class
09:44:36 <skew> the issue I had (which isn't actually an issue with the jvm bride)
09:44:46 <skew> was that his code didn't follw the diamond rule
09:44:53 <ozone> skew: i think it did
09:44:54 <skew> but, looking back I'm pretty sure I could get that too
09:45:02 <ozone> lemme dig up the post
09:45:09 <ozone> it looked like he solved bloody everything
09:45:11 <skew> nah, his code was just a depth first search up the inheritance tree
09:45:32 <ozone> http://www.haskell.org/pipermail/haskell-cafe/2003-November/005433.html
09:45:36 <skew> but stick in one of those functional queues built with the reverse and you would have it
09:46:34 <ozone> skew: what scenario wouldn't it work in (in, say, java)
09:46:52 <skew> I think it works just fine in java
09:47:08 <skew> and I don't remember this post, so maybe it will work. I'm still reading
09:47:32 <ozone> it's possible you missed it -- i never saw a reply from you to that post
09:47:57 <ozone> glad to finally meet you, btw.  we seem to be tackling somewhat similar problems in haskell, for some odd reason
09:48:35 <skew> the problem I'm kicking around that the moment is how to to type class resolution based on the greatest fixed point of the instances.
09:48:47 <skew> or at least a computable approximation
09:48:59 <ozone> sorry, you'll have to explain it to me in more OO terms and less math terms. :)
09:49:08 <skew> no such thing in OO
09:49:52 <ozone> what do you mean by fixed point of instances?
09:49:54 <skew> basically, handle situations where the generated code involves polymorphic recursion through instances, more or less
09:50:21 <skew> so you need a potentially unbounded set of distinct instances
09:50:21 <ozone> ah
09:50:39 <ozone> yes, i see.  now i know what you're talking about, and i also know i don't know crap about polymorphic recursion
09:50:49 <skew> which you can provide by bunding up the whole type class machinery into the program, feeding it a TypeRep or something 
09:51:05 <skew> but proving that the use is actually well typed ahead of time is still a problem
09:51:47 <skew> I'm not sure what it would be actually good for, but it's an interesting problem
09:52:27 <skew> as it is I'm just trying to find something better than trying to construct an instance for figuring out if there is a regular derivation
09:52:57 <skew> but that's more or less useless, because you can just run and if an instance exists or there is a problem you will find it in finite time
09:53:09 <skew> a regular instance that is, corresponding to mutually recursive instance dictionaries
09:53:46 <ozone> skew: btw, in that oleg post, can you tell me why he chose the names mtrace_om and mtrace_ahm for those typechecking functions?  what's the om and ahm stand for?
09:56:52 <skew> the ohm and ahm are for Object Has Method and Ancestor Has Method
09:56:58 <skew> I don't know about the mtrace bit
09:57:06 <ozone> mtrace == method trace, i presume
09:57:07 <skew> method trace maybe?
09:57:09 <ozone> thanks, that makes sense
09:57:24 <skew> I originated the OHM and AHM names
09:57:55 <ozone> ah, ok
10:00:16 <skew> oh, is is doing a breadth first search
10:00:36 <skew> ah, must write lecture slides!
10:11:41 <SyntaxLaptop> later all
10:27:25 <markus> is there a function like words that will split my string at any character?
10:27:33 <markus> not just ' '
10:27:40 <skew> no, but it would be nice
10:27:50 <skew> there should be a Data.String with stuff like that, I think
10:28:09 <markus> ok... thanks. ill make one myself then... maybe
10:28:36 <skew> I like a ([a] -> ([a],[a])) -> [a] -> [[a]] combinator myself
10:29:19 <skew> ([a] -> (b,[a])) -> [a] -> [b], I suppose
10:29:28 <markus> huh, mabie :)
10:29:37 <desrt> types!
10:30:14 <desrt> markus; do you mean *any* character or any non-alpha?
10:30:26 <skew> desrt: any specified character
10:30:37 <desrt> write one :)
10:30:39 <markus> like any ascii-value
10:30:40 <skew> map (:[]) works just fine otherwise
10:30:53 <markus> i found break, maybe that will work
10:30:55 <skew> if you want to split between every pair of characters :)
10:31:03 <markus> heh, nooo
10:31:07 <desrt> i'd use takeWhile
10:31:09 <markus> the character that i specify
10:31:25 <skew> markus: yeah, the combinator I'm talking about would be for turning break into something that keeps on splitting
10:32:29 <bluejay> markus: look in the wiki's PreludeExts. It's something involving "glue"
10:33:08 <bluejay> I think
10:40:08 <Marvin--> skew: wouldn't that be sort of like unfoldr?
10:40:23 <Marvin--> Data.List.unfoldr :: forall a b. (b -> Maybe (a, b)) -> b -> [a]
10:40:30 <skew> right!
10:40:49 <skew> er, not quite
10:42:04 <skew> nevermind, it is like that
10:42:27 <skew> unfoldr . (\f x -> case x of [] -> Nothing; _ -> Just (f x))
10:52:26 <markus> thanks, but i modified "words" from the prelude, it worked
11:12:04 <shapr> skew: any suggestions for a good way to web publish algebraic types?
11:12:25 <shapr> hey Si\ wassup?
11:38:49 <shapr> gintas: hey, aren't you involved in schooltool?
11:39:20 <Si\> I am still alive shapr; I'm just recovering from a week of Java E-Commerce
11:39:46 <Marvin--> sounds painful
11:39:51 <shapr> ow, a whole week of java
11:40:11 <Maddas> haha
11:40:25 <gintas> shapr: I am
11:40:41 <gintas> shapr: why do you ask?
11:40:51 <shapr> I remember one of the worst weeks of my life, I quit smoking and started a java job at the same time
11:40:55 <Si\> I've come to the conclusion that Java is junk because it isn't Haskell, Java is junk because it's Java :D
11:41:10 <Si\> I'll say that again
11:41:22 <Si\> I've come to the conclusion that Java isn't junk because it isn't Haskell, Java is junk because it's Java :D
11:41:39 <shapr> gintas: I've been trying to remember where I saw your name before, and it finally clicked
11:41:45 <Maddas> Si\: :-)
11:41:47 <gintas> shapr: heh :)
11:42:29 <gintas> shapr: actually I didn't work all that much on schooltool, I only joined the team after they were midway
11:42:32 <shapr> gintas: have you used haskell much?
11:43:17 <gintas> shapr: nope
11:43:50 <gintas> shapr: I find it very interesting but can't find the time to learn :(
11:43:52 <shapr> I get the impression that team is a good place to work
11:44:22 <gintas> shapr: yeah, you could say that
11:44:37 <gintas> shapr: they're very smart, almost too smart for me :)
11:44:56 <shapr> well, you gotta take a day off and learn some cool stuff with us here on Channel Haskell
11:45:08 <shapr> don't turn that dial!
11:45:19 * shapr wonders if anyone says that anymore
11:45:41 <gintas> shapr: huh?
11:46:01 <shapr> I admit, it took me several weeks to understand the last deep discussion I had with SteveA
11:47:04 <shapr> just trying to pun on irc channel and TV channel
11:47:26 <gintas> shapr: ah :)
11:48:22 * shapr boings
11:50:53 <liiwi> yawn
11:55:44 * shapr hacks on Peter Gammie's PLog
12:25:01 <markus> What causes the illegal type-error?
12:27:58 <ibid> a type error that is illegal?
12:31:24 <markus> i dont like it :/
12:33:00 <markus> Illegal type "Uppslag -> TreeMap" in constructor application
12:33:08 <markus> wtf does that mean?
12:33:39 <ibid> what's the context?
12:33:58 <markus> addPut :: TreeMap -> Uppslag -> TreeMap
12:34:15 <ibid> and the constructor application?
12:34:25 <markus> dont know what that is
12:35:02 <ibid> the message gives that line?
12:35:33 <markus> hmm the error is on line 11: addPut :: TreeMap -> Uppslag -> TreeMap
12:35:45 <ibid> ok, how is addPut defined?
12:35:47 <ibid> sorry
12:35:50 <ibid> TreeMap
12:36:19 <markus> data TreeMap k d = Null | Node (TreeMap k d) (k, d) (TreeMap k d)
12:36:19 <markus> deriving (Eq,Ord,Show)
12:36:23 <ibid> ok
12:36:29 <ibid> that explains it
12:36:41 <ibid> TreeMap is a type constructor
12:36:52 <ibid> it needs actual type parameters
12:37:04 <markus> yeah, thats true!
12:37:07 <markus> hehe, i forgot
12:37:09 <ibid> :)
12:37:10 <markus> thanks!
12:37:50 <ibid> np
14:03:16 <shapr> I realized I don't want to derive XML, I want to derive WebPublish
14:03:43 <shapr> where I automatically get input/edit and view pages for a type
14:04:26 <shapr> I guess that requires a bit more infrastructure though
14:15:35 <skew> shapr: I think you want an edit widget to stick into web page template thingies
14:15:52 <skew> it sounds like a good idea
14:16:31 <skew> I have to go write stuff for a while now
14:30:38 <skew> shapr: what do you mean be web publishing an algebraic data type?
14:57:37 <Marvin--> Sphere is an interesting movie
14:57:41 * Marvin-- just saw it
14:59:03 <Riastradh> _Sphere_, if we're talking about the same movie, is just a cheesy ripoff of _Forbidden Planet_, and it doesn't even have Theramin music in it.  (Of course, _Forbidden Planet_ is kind of cheesy itself, but still.)
14:59:25 <Marvin--> heh
14:59:53 <Marvin--> it felt pretty 2001, but the whole Jerry <-> Harry thing was too easy to figure out, as was the squid
15:00:09 <skew> had you read the book?
15:00:25 <Marvin--> nope
15:00:38 <Marvin--> wtf
15:00:47 <Marvin--> why is there a group of people standing in the parking lot singing?
15:00:52 * Marvin-- boggles
15:00:55 <Riastradh> What are they singing?
15:01:50 <Marvin--> I don't know, I just cought the ending of it
15:01:55 <Marvin--> caught
15:02:05 <Marvin--> sounded religious though
15:02:25 <skew> Is it Christmas in your timezone? ;)
15:02:28 <Marvin--> no :)
15:02:45 <Marvin--> now it sounds like choir versions of folk songs though
15:03:30 <Marvin--> Kristallen den fina, to be precise
15:03:38 <stepcut>  'kill the wabbit, kill the wabbit!'
15:04:00 <Marvin--> did I mention that it's raining?
15:04:03 <Marvin--> a lot
15:04:15 <XTL> Marvin--: Maybe they did a rain dance
15:04:32 <skew> speaking of religion, we need a church of the greatest fixed point
15:04:41 <Marvin--> no, they're standing pretty still :)
15:05:09 <XTL> Marvin--: Ah, some experimental methods, then.
15:05:20 <XTL> That or maybe they just like singing in the rain.
15:05:21 <Marvin--> heh
15:05:37 <skew> experimental theology?
15:05:56 <Marvin--> it could be some sort of freaky group serenade thingy, but it's hard to know who the target it, seeing as this is a 14 story building...
15:06:18 <skew> Well, my school has a laboratory of mathematics, so I guess it's not too far out there
15:06:24 <XTL> Anyone who'll let them in perhaps.
15:06:30 <Marvin--> heh
15:06:55 * XTL really wants some more tea
15:09:53 <stepcut> mmm, tea
15:10:21 <Marvin--> well, either they've stopped or they can't make up their mind what to sing next :)
15:12:09 <XTL> I imagine that if they were here, someone would already have yelled "Soittakaa Paranoid!" out to them
15:13:38 <Marvin--> ?
15:14:10 <shapr> skew: yes, edit widget is right
15:14:44 <XTL> I'm just starting to wake up and my legs are killing me for not getting enough sleep. *sigh*
15:14:59 <shapr> your legs want sleep?
15:15:19 <shapr> I can't think straight without sleep
15:15:31 <shapr> not that it alvays works when I have sleep
15:15:32 <XTL> They're not getting enough blood or something. If I get up with too little sleep they ache for the rest of the day.
15:16:17 <shapr> interesting
15:17:22 <shapr> XTL: you write Haskell?
15:19:43 <Marvin--> what, you think that might be the cause? ;)
15:20:35 <shapr> interesting --> http://www.ii2.org/misc/channel.php?chanid=182685
15:20:43 <XTL> shapr: I occasionally try to.
15:21:06 <XTL> Lovely language.
15:21:25 <shapr> yah, I empathize with both of those
15:22:10 <XTL> http://irc-galleria.net/channel.php?channel_id=134417
15:22:46 <XTL> Lately I've been mostly writing Ruby code at work.  There's an exceedingly convenient language.
15:22:59 <shapr> I realize just how much haskell I don't write when I try to comment out code with #
15:23:19 <skew> My problems mostly go the other way
15:23:27 <XTL> Not much of that either.
15:23:29 <shapr> yah, Ruby seems more flexible than Python, I just can't bear the syntax
15:23:40 <skew> How are you supposed to program without monads?
15:23:43 <XTL> shapr: Too perly?
15:23:54 <shapr> I'm a significant whitespace addict
15:24:21 <skew> Sometimes I worry that x = x+1 is ill founded recursion
15:24:26 <shapr> ha
15:24:47 <XTL> :)
15:25:37 <shapr> I remember when I was first immersing myself in monads, I dreamed that I had restructured my brain into monadic form, and that I was using unsafePerformIO to see five seconds into the future
15:26:06 <skew> didn' 
15:26:14 <skew> didn't you make the world <<loop>> a lot?
15:26:30 <shapr> maybe that's when I woke up
15:28:09 <shapr> XTL: you have a dead link in your Perkele page
15:28:24 <XTL> shapr: Hmm..
15:30:35 <shapr> min√§ en tieda
15:30:51 <XTL> They seem to have moved to a .fi domain, I think..
15:31:41 <XTL> There.
15:31:56 <shapr> hm, none of those let you search by network
15:31:57 <XTL> Can't help but wonder how you noticed, though :)
15:32:19 <shapr> how I noticed the dead link?
15:32:50 <shapr> years of finnish classes that I've almost forgotten
15:36:04 <shapr> XTL: cool pic
15:36:43 <XTL> Where?
15:36:53 <shapr> well, all the suit pix
15:37:31 <XTL> Oh. Thank you :)
15:37:32 <shapr> heh "not my cat"
15:38:27 <shapr> I wonder why babelfish doesn't do finnish
15:38:27 <XTL> There. Tea, cookies..   Niina on the couch complaining about bad dreams.
15:39:47 <XTL> Not-my-cat, the tabby kitten? Does it have an english label somewhere?
15:39:52 <shapr> as long as she didn't dream of monads
15:40:21 <shapr> no, I had years of finnish classes
15:40:46 <XTL> No, it was something about a wasp coming in and turning into a cat and watching one of our cats eat a fly and a false awakening and telling me about some other dream (in the dream).
15:41:02 <shapr> heh, that's nifty
15:42:26 <shapr> so I can still read some finnish, but it's fading
15:42:45 <shapr> I'll get back to it after I'm done with swedish
15:43:09 <shapr> XTL: talar du svenska? :-)
15:43:12 <XTL> I vaguely remember some talk about that.
15:43:38 <XTL> I'll admit I understand swedish, mandatory subject and all  ;)
15:43:46 <XTL> Well, some.
15:44:25 <shapr> swedish is improving my understanding of german
15:44:50 <shapr> spoken languages are nifty
15:45:02 <XTL> I'd love to learn more languages (even swedish), but somehow the teachers are always so irritating :)
15:45:17 <simon-> blame the teachers!
15:45:57 <XTL> That and I'm too lazy and antisocial of course, but that's an insignificant detail :)
15:46:34 <shapr> if you move to someplace where you have to speak a certain language to buy food, it's motivating
15:47:18 <XTL> That could well be :)  I actually spoke english out loud just earlier this evening to a cleaning lady.
15:47:55 <shapr> finnish is good for swearing
15:48:08 <shapr> very snappy
15:48:14 <Jerub> I remember talking to a european who came to our LUG.
15:48:41 <Jerub> he was confused that we were using 'fsck' as a swear word, (pronounced 'fisk')
15:49:17 <shapr> I always said that as fuh-sik
15:49:34 <XTL> fsssssck
15:49:44 <shapr> I see your point
15:49:44 <Jerub> shapr: must be an austarlian thing then, because we pronounce it fisk.
15:49:53 <XTL> Kind of takes the bark out of the original
15:49:56 <XTL> :)
15:50:29 * Jerub goes to help a friend move house.
15:50:38 <XTL> Maybe it's a word that doesn't get very predictably into wide regional accents
15:52:28 <shapr> I dunno
15:52:59 <shapr> I've decided to give and make a personal website
15:53:17 <shapr> er "give in"
15:53:18 <eivuokko> I didn't know it was possible to pronounce fsck.
15:53:32 <XTL> I've never heard anyone use it. Not that I hear much talk like that spoken.  Finns mostly say something close to "f s check"
15:53:53 <XTL> Ones I've heard anyway. Maybe with a soft ch, though.
15:54:25 <shapr> I don't actually speak to people about programming much
15:54:58 <shapr> almost always it's email, irc, and web comments
15:55:22 <XTL> I'm a sysadmin for a tiny bunch, but it doesn't bring much out either
15:55:57 <shapr> I wonder if a spoken programming language would let us swap useful code tricks at lunch
15:56:12 <simon-> I think I'd say fs-check or fuck.
15:56:15 <eivuokko> Hmmm.  I talk about programming quite a bit, at work and with the technical oriented friends.
15:56:35 <shapr> eivuokko: maybe it's just Boden
15:56:36 <XTL> Would it be like spoken perl or like some extra verbose incantation?
15:56:49 <shapr> well, lojban so far
15:56:52 <simon-> or maybe "ef-es-chick" :)
15:56:58 <saz> chick?
15:57:19 <shapr> which seems to have surprising similarities to lambda cal
15:57:24 <simon-> sorry, "fis-chick" or "fesh-chick"
15:57:36 <simon-> er, I would probably not want to pronounce it simply due to these considerations!
15:57:38 <XTL> maybe ef-es-sek to rhyme with parsek or such -chick/-check
15:58:28 <XTL> Oh, but of course there's a difference in pronouncing "fsck" and "fsck!"
15:58:52 <shapr> I suspect spoken programming would increase 'concept mobility' or whatever you call it
15:59:13 <shapr> meme potential :-)
15:59:16 <XTL> I once entertained the thought about interpretive dance designing/architecture
15:59:26 <Riastradh> 'fsck' -> 'eff ess chek'; 'fsck!' -> 'f<upside-down e>sk'
15:59:29 <shapr> "man, I can't get this code out of my head!"
15:59:32 <eivuokko> shapr, You're way ahead....if only people used the same definitions for terms, that'd be a big win.
15:59:42 <XTL> I guess I got that from the Zappa, but it might almost make sense if you agreed to a set of hand gestures
15:59:56 <shapr> XTL: yah, I agree
16:00:24 <shapr> I've tried to think up ways a gestural interface could work
16:00:44 <XTL> Like Minority Report? :)
16:01:00 <shapr> nah, that was cheesy 2D
16:01:14 <shapr> 2D is so 90s
16:01:19 <shapr> :-)
16:01:32 <eivuokko> Indeed, gestures aren't that usefull unless the interface is 3D (or more).
16:01:44 <shapr> seriously, did you guys see the UT2003 hack that works with 3D goggles?
16:02:04 <shapr> I've wanted that for years too
16:02:08 <XTL> Well, how deep would the Z be? lots of overlap in objects? Movement depthwise?
16:02:24 <shapr> depends on the metaphor
16:03:01 <shapr> the best one I've thought of is spell casting and 'cells'
16:03:37 <shapr> but I'm sure there-s something better
16:03:49 * XTL has an image of someone hopping up and down and chanting 'Ja maisemat vaihtuu'
16:03:56 <eivuokko> Cells?
16:04:00 <XTL> I don't mud. It's just some friends that did...
16:04:27 <shapr> anyway, if you speak a chunk of code you have a visible 'combinator'
16:05:32 <shapr> programs could be cells, showing the code as it operates
16:05:40 <eivuokko> Hm.
16:06:29 <shapr> in essence, an object analogy. ports on the outside for connecting source and sink
16:06:46 <shapr> flip it inside out to see the internal structure
16:06:55 <shapr> and to alter it
16:07:13 <XTL> Hm. Is that a user interface or for development/debug?
16:07:19 <XTL> Of course you can have both..
16:07:24 <eivuokko> I am sure I don't want to see structure of most programs I use ;)
16:07:54 <shapr> I bet the first OpenGL debugger makes slashdot :-)
16:08:50 <shapr> anyway, that's just my vague imagining of a real 3D interface, any ideas for improving it?
16:09:00 <XTL> A debugger like that might be neat, really.
16:09:09 <shapr> or for an entirely different better interface?
16:09:19 <XTL> Less things to shuffle in your head
16:10:10 <XTL> I could still hop back to spoken code for a bit.. what would be the use? Describing/teaching algorithms? Easier to perform the next decss?
16:10:17 <eivuokko> I'd much prefer jack in my head over gestures for input.  For gestures, I think that most ideas seem to incorporate only rather large movements.  That's not good for long term use.  Only wrists and fingers should be required imho.  For representation, I might go for 2d with layers and layer changing through machine following what my eyes focus.
16:11:24 <shapr> I can speak faster than I can type
16:11:32 <XTL> I think there's been some attempts at eye focus following and they have looked not promising. But it might just be some other technological barrier
16:11:46 <shapr> blind or disabled would like speech
16:11:51 <XTL> shapr: So speech recognition? Or just composing code on the fly for someone?
16:12:14 <eivuokko> Yes, speaking is faster, listening is not faster than reading.
16:12:45 <shapr> eivuokko: yes, speech for input, graphics for display
16:13:22 <shapr> though it would be cool to hear other programmers speak code to me
16:13:36 <eivuokko> Well, I think patterns are usually used for that.
16:13:46 <shapr> like I said, I think that would improve speed of change in our industry
16:14:03 <XTL> Oral tradition. Might really help if networks start to lose freedom of expression :)
16:14:14 <shapr> yes, you have patterns because you can't speak code
16:14:20 <Riastradh> It might prove problematic for people who stutter or mumble...
16:14:40 <shapr> Riastradh: like keyboards for those who are handicapped
16:15:16 <shapr> any motor nerve disease is rough with keyboards
16:15:26 <eivuokko> Well, not many programming languages offer simple enough grammar and vocabulary for speaking and yet they'd need to be able to express rather high level concepts.
16:15:30 <XTL> Then you could walk and talk -program.
16:15:52 <shapr> or your phone could be your entire interface if  you want
16:16:01 <XTL> eivuokko: The language would probably need be a new one. I asked earlier a bit about what way it would lean.
16:16:08 <shapr> no need for graphics or buttons?
16:16:55 <XTL> Maybe face (nerve?) sensors could recognize enough without the need for wind and noise. So you could just mime talking or whisper
16:16:58 <shapr> as for gestures, there's a lot to learn from sign language as used by the deaf
16:17:28 <eivuokko> Do you find it intuitive?
16:17:49 <shapr> for example, pronouns are angles from the front center of the body
16:18:32 <shapr> if you want to talk about four people, you assign them four spots left, right, left of forward, right of forward
16:19:04 <shapr> register based? ;-)
16:19:25 <XTL> Might there be any barriers that could be removed in speech vs written text? More expression?
16:19:39 <XTL> You could compile it to text maybe.
16:19:49 <XTL> Whistle macros :)
16:19:50 <eivuokko> lol at register
16:20:09 <shapr> heh, whistle macros, yes
16:20:17 <shapr> or gesture macros
16:20:42 <XTL> That would be an even more holistic approach.
16:21:15 <XTL> Perhaps syntax vs ..  what do you call that.. tokens?
16:21:30 <shapr> ?
16:22:03 <XTL> finger-wave structure or whatnot and speak variable and function names and the like. Sort of separate that...
16:22:23 <shapr> eivuokko: sign language is about as intutive as spoken language, imho
16:22:34 <XTL> Less need to repeat the same words (what I said earlier about lengthy incantations)
16:22:34 <shapr> XTL: yes, spellcasting
16:22:41 <eivuokko> shapr, That's not intuitive in my book ;)
16:22:49 <shapr> eivuokko: yah, I agree
16:23:32 <shapr> anyway, this all vague hand waving (ha) until it can be used
16:23:38 <XTL> :)
16:23:51 <XTL> It needs some human interface work at the very least
16:24:01 <shapr> yup
16:24:25 <XTL> It might be possible to start experimenting with a sort of paper-coding by just interfacing between humans
16:24:27 <shapr> right now, I want an open source speech recog engine
16:24:43 <shapr> heh, 3D napkin prototyping
16:25:24 <XTL> You, sir, shall be my napkin. Observe!
16:25:32 * shapr laughs
16:26:33 <shapr> I've heard OpenCroquet is a bit like this
16:26:49 <shapr> haven't tried it myself though
16:27:48 * XTL googles a bit
16:28:36 <shapr> pieces missing: open source speech recog, affordable 3D position tracked headset that works with standard gfx cards, affordable tracked glove input devices
16:29:38 <shapr> headsets are getting cheaper, gloves aren't so much
16:29:39 <blackdog_> you're still trying to turn yourself into a cyborg, shapr?
16:29:52 <shapr> yah, like Sacha Chua
16:29:53 <XTL> There are headsets, aren't there. Maybe the position tracking could be bolted on.
16:30:07 <XTL> Sort of like light pens in those TV micros.
16:30:20 <shapr> but Sacha is far cuter than me
16:30:52 <blackdog_> *sound of jetplanes overhead*  who's sach chua?
16:31:55 <shapr> she's an attractive geek in the phillipines
16:33:01 <shapr> blackdog_: http://sacha.free.net.ph/notebook/pics/sacha_of_borg.png
16:34:28 <shapr> anyway, it seems silly that text is so deeply ingrained in our computer systems
16:34:45 <shapr> ha
16:36:00 <shapr> I was thinking about scheme syntax macros, and I wonder if they can be used to implment Piet - http://www.dangermouse.net/esoteric/piet.html
16:36:14 <XTL> Well, it is a convenient bridge between electrical signals (or bits) and human expression
16:37:12 <XTL> uhhuh
16:38:14 <shapr> wouter gets around text, look at his sauerkraut lang for example - http://wouter.fov120.com/proglang/index.html
16:40:09 <XTL> This is starting to look like the start of a long mad reading streak again :-/
16:41:08 <shapr> seems to me like 'domain specific languages' shouldn't stop at text
16:41:57 <shapr> XTL: hopefully you'll find stuff I've missed and point it out to me
16:42:52 <XTL> shapr: I just have this tendency to get some weird idea and go read about it and some long while later I realize I never really got back from the trip
16:44:11 <shapr> a spoken/gestural proglang could easily have anonymous values, so I'm thinking about an extended Joy as the underlying language
16:44:15 <XTL> You see, this here all probably started when I picked up an innocent looking LISP book at a library somewhere wondering what it would look like. Here I am, trying to pick up speed still
16:44:29 * shapr grins
16:44:35 <shapr> yah, me too
16:45:40 <shapr> I picked up this book "True Names" when I was eleven
16:45:42 <XTL> I mean, one moment I was at the most helping someone find out why some Basic didn't run on his Atari 800XL and wondering what people see in computer games and then whoosh
16:46:30 <XTL> Insert caption "fifteen years later" or something
16:46:43 * shapr grins
16:46:51 <XTL> Hm. Is it Vinge's?
16:46:58 <shapr> yup, that's it
16:47:17 <XTL> I was halfway through that at one point. I should find a copy and finish it sometime.
16:47:37 <XTL> I'm first part through Across Realtime, coincidentally.
16:48:28 <shapr> I don't think I've read that one
16:49:29 <shapr> amazoners like it
18:05:27 <skew> is anyone about here familiar with lhs2tex?
18:05:47 <skew> I'm combining it with prosper, and it doesn't seem to properly clean up th eline spacing after itself
19:24:29 <yc> if i had: [[[(elem)]]] and i wanted to elem:[[[(elem)]]] and that kept on adding a few elems over some period of time but then when a function is called i want to then add elems such that elem:[[],[[(oldelems)]]], the new elems are put into a seperate list from the old elems
19:24:38 <yc> thats probably some bad explaining :P
19:25:19 <saz> indeed
19:28:39 <yc> hmmm well i've got a list within a list within a list [[[(elem)]]], what i want to do is add elems at the base list, however at some later stage i want to retrieve this old list and all new elems added are put into a new list in the front, [[],[[(oldelems)]]], like when i add elems now i want them to go into that empty list not the list of oldelems
19:31:18 <Cale> well, you'll need to reach in and pull out the list you want to put elements into, and then put it back when you're done.
19:31:48 <Cale> unless you want to be more specific about what you're doing :)
19:32:54 <Cale> You can't really "add" elements to a list. Lists aren't mutable :)
19:33:17 <Cale> you can, of course, define new lists in terms of old ones in any way that you'd like
19:36:17 <yc> hehe well this to me reads logically but it's wrong, ((testelem:(getBaseHistory testmemory)):getMiddleHistory testmemory)
19:37:36 <yc> getBaseHistory = head(getMiddleHistory).......i know a touch redundant but it's not up to me
19:39:46 <Cale> hmm...
19:40:53 <yc> the output of that is [[(testelem)],[]]
19:40:56 <Cale> testelem will end up inside a list inside a list.
19:41:01 <Cale> yes
19:41:03 <yc> yeah :/
19:41:10 <Cale> and where do you want it?
19:42:20 <yc> [[(testelem)]] like that but then at some stage later i want the next elem to added such that i get [[(testelem)],[(oldelems)]]
19:42:51 <Cale> well, that will require two different functions, or the equivalent thereof, of course
19:43:19 <Cale> When do items get added?
19:43:50 <Cale> Could the entire structure conceivably be built up all at once?
19:44:01 <yc> into the base level [(elem)]
19:44:10 <Cale> no, not where, when.
19:44:44 <Cale> you're speaking of this as if it's a mutable list, which implies that it's being used for IO or something
19:45:10 <Cale> normally, you'd just define the list all at once, and not have to add elements to it after that.
19:46:33 <yc> no IO, it's just a history of actions that needs to be updated as more actions occure, it is updated when observe is called, which is given the old history and a new element as input, it needs to output the oldhistory with the new element
19:47:04 <Cale> well, that sounds quite a bit like IO to me :)
19:47:24 <Cale> not that it actually has to involve IO directly
19:47:53 <yc> hehe well i can not use anything outside the interface
19:47:56 <Cale> I just wanted to know whether you could conceivably know all the elements in the list at compile time
19:48:37 <Cale> (in which case, you would not want to construct the list by reaching back in and adding elements repetitively)
19:48:56 <Cale> but in this case, you probably have no choice
19:49:37 <yc> no, the list would be empty at compile time
19:49:56 <Cale> what causes the list to split?
19:50:29 <Cale> couldn't you represent a history as a simple pair of lists (one for forward, one for back)?
19:50:40 <yc> it is holding information like gamehistory, handhistory, roundhistory
19:51:17 <Cale> Do you get to make code design decisions?
19:51:44 <Cale> There are going to be a lot of functions which will work the same on any history list.
19:52:07 <Cale> (or pair thereof, if you need undo and redo)
19:52:11 <yc> i can do anything as long i do not change any of the given functions type signautres
19:52:35 <yc> oh and i can not add anymore functions :P
19:52:45 <Cale> that's stupid
19:53:02 <Cale> especially as this is a functional programming language
19:53:14 <Cale> anyway, it would seem to make sense to me, to store the different kinds of history as fields in a record datatype
19:53:20 <yc> heh well my module will be randomly swapped with anyone elses, they all have to be able to work with anyone elses other modules
19:53:32 <Cale> and they would all be of some common History datatype
19:53:54 <yc> hehehe however i can not add a new datatype :P
19:53:55 <Cale> well, what's the problem with adding extra functions, then?
19:54:16 <Cale> I mean, so long as they're in the same module.
19:54:58 <Cale> or datatypes for that matter, so long as you don't expose them to the air :)
19:55:31 <yc> well it seems ok, yet however they made us decide on datatypes that we will etc pre-hand
19:55:41 <yc> so i'm not sure if we are really allowed to use anything but what we decided on
19:56:12 <yc> i'd better ask to make sure :D
19:56:19 <Cale> yeah - I'd ask
19:56:24 <yc> however that would make things alot easier :)
19:56:27 <Cale> yes
19:56:59 <saz> yc: you wouldn't happen to be doing comp1711 would you?
19:56:59 * desrt sits outside
19:57:21 <desrt> my old job called me in today out of desperation 'cause they couldn't get anyone else
19:57:33 <Cale> lists of lists of lists of... gets hard to manage
19:58:29 <desrt> anyway.  dulcie showed up in my line
19:58:35 <desrt> it was really weird to see her out of context
20:00:03 <yc> saz: of course
20:00:07 <Cale> Dulcie? Is that the first name of someone I'd know? I'm poor with names.
20:00:21 <desrt> dulcie armal (or however you spell it)
20:00:30 <desrt> the really cute secretary in the CAS office (202)
20:00:53 <yc> cale: i'm trying to reason with my group to get rid of this list of list of list, none are even planning to use it :P, all anyone will use is the most recent base list
20:00:56 <desrt> she was at the meeting last friday, remember?
20:01:07 <Cale> hmm... maybe
20:02:24 <desrt> it's got me wondering now how old she is
20:03:24 <Cale> My people mapping is pretty weak, and mostly restricted to Christopher, Wolfram, Gord, Jacques, You, and Vivian.
20:03:25 <saz> yc: what's the assignment this session?
20:03:41 <desrt> btw
20:03:49 <desrt> it's viwien or something weird like that :)
20:03:57 <Cale> okay
20:03:58 <yc> saz: Blackadder and Baldric :/ CARDS!
20:04:05 <desrt> heh
20:04:16 <saz> yc: aaarh, no trains?
20:04:17 <desrt> mcmaster CIS has 2 servers called blackadder and baldric
20:04:24 <Cale> Everyone called her Vivian, so I went with that.
20:04:32 <desrt> cale; that's her name
20:04:36 <desrt> it's just spelled really strangely
20:04:38 <Cale> ah
20:05:14 <keverets> desrt: you are aware that this channel has a public web archive?
20:05:21 <yc> saz: we did trains already :P
20:05:38 <saz> yc: ah, I see :)
20:05:38 <yc> saz: num to word, trains, blackadder and baldric
20:06:05 <yc> saz: trains was awesome, this cards business isn't so much fun :D
20:06:21 <keverets> and it's dulcie amaral
20:06:22 <saz> hehe, trains are cool
20:06:27 <desrt> keverets; i am
20:06:53 <desrt> keverets; ah.  thanks.  you from mac?
20:07:35 <desrt> oh.  queens.  i see.
20:07:44 <keverets> don't believe everything you read.
20:07:52 <desrt> heh
20:08:57 <desrt> so where are you from, then?
20:09:30 <Cale> keverets: yes - perhaps we could all meet at some point if you're on campus :)
20:09:54 <desrt> i doubt i want to meet him.  queens students are almost as bad as waterloo students
20:09:58 <desrt> =)
20:10:04 <Cale> heh
20:10:30 <desrt> it's *so* nice out
20:10:30 <desrt> mmm
20:10:47 <Cale> It's *so* sweltering.
20:10:53 <desrt> not here
20:10:58 <desrt> wicked cool breeze
20:11:02 <Cale> In general
20:11:04 <desrt> ah
20:11:09 <desrt> it's gonna cool off the next couple of days
20:11:43 <Cale> My room is still 30 degrees though, even with the breeze. My machine running at 50C isn't helping.
20:11:52 <desrt> ah
20:11:58 <desrt> my computers are tucked away in the closet
20:12:18 <desrt> i couldn't stand the noise
20:12:37 <Cale> I see you're taking affirmative action on the sleeping front.
20:12:43 <desrt> :)
20:12:46 <desrt> they've been there for a while
20:12:54 <desrt> i slept good last night
20:13:05 <desrt> then failed to come in to work today
20:13:17 <desrt> i got a lot done, though
20:13:43 <desrt> we were talking about targetting haskell to the brick.  i think we're not going to do that now
20:13:54 <desrt> because even though it would be really cool, i doubt it would be particularly useful
20:15:20 <desrt> as it turns out, in the real world, control systems are more about propagation of signals within certain time contraints, etc than they are about making complicated decisions
20:15:47 <desrt> ie: very sequential
20:23:57 <Cale> did you have a look at Timber?
20:24:06 <desrt> no . what is this?
20:24:25 <Cale> http://www.tt.luth.se/staff/nordland/TimberCourse/
20:24:27 <desrt> like the /etc/ppp/peers/whatever
20:24:31 <desrt> erp.  wrong channel :)
20:24:52 <desrt> hm
20:25:43 <desrt> functional programming for realtime systems
20:25:45 <desrt> interesting
20:27:23 <Cale> here comes rain
20:27:41 <Cale> sounds like it just started to pour
20:28:04 <desrt> wow
20:28:08 <desrt> i hope we end up getting hit
20:28:40 <desrt> it'll probably take about an hour to get here tho
20:28:48 <desrt> unless it's coming in laterally
20:40:52 <yc> cale: you where right dude, i can do whatever i want, just i can only export the functions decided upon as group which is fine and dandy :) horrible shame I just got the stupid thing working ;) oh cruel world
20:43:23 <Cale> :)
20:44:58 <Cale> desrt: yeah, check out the lecture notes on Timber when you're feeling up to it, just for kicks. It's got some neat stuff in it.
21:27:10 <desrt> cale; still no rain :(
21:27:38 <desrt> lots of wind, though
21:28:19 <SamB> is there a way to search for a function by type unification yet?
21:31:22 <stepcut> hrm
21:47:43 <stepcut> it is difficult (or perhaps impossible) to justify writting your own accounting software
21:50:32 <Shammah> mmm not entirely sure I agree on that.
21:51:11 <SamB> when you are, or when you are not, an accountant?
21:52:10 <stepcut> Shammah: oh?
21:53:43 <Hyp3rion> Morning!
21:54:14 <stepcut> hey
21:54:18 <SamB> Hyp3rion: Night!
22:04:36 <Hyp3rion> Heh
22:06:59 <Hyp3rion> Err, its 07:07 now...
22:07:07 <stepcut> 10:07
22:07:32 <Hyp3rion> SamB has 01:07 :-)
22:07:53 <Hyp3rion> stepcut, You from Persia?
22:08:06 <stepcut> california
22:08:07 <SamB> hmm, maybe its only :07, and time resets every hour.
22:08:34 <Hyp3rion> ?
22:09:05 <Hyp3rion> stepcut, Oh, 10pm, i see...
22:09:10 <Hyp3rion> :-D
22:18:09 <SamB> hmm, is there a paper called "Monads can Save the World"?
22:20:37 <SamB> @google "Monads can Save the World"
22:20:37 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands
22:20:58 <SamB> lambdabot: you should ask pynfo to teach you that trick!
22:20:58 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
22:52:28 <Shammah> stepcut: there are alot of industries that are v.poorly serviced by the current SME acct-pkg providers.
22:57:00 * SamB had forgotten about n+k patterns ;-)
23:03:45 * SamB wants emacs with lazier mode loading
23:50:54 <eivuokko> What's n+k pattern?
23:53:05 <SamB> eivuokko: they are something probably best forgotten
23:54:31 <eivuokko> Aha
23:57:29 <SamB> except, perhaps, in humour, such as "the evolution of a haskell programmer"
