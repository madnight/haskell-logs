00:30:55 <earthy> good morning #haskell
00:31:06 <earthy> and I wouldn't really call Serge Mechveliani a naive user.
00:35:02 <dons> hehe
00:44:11 <andersca> @type seq
00:44:13 <lambdabot> seq :: forall b a. a -> b -> b
00:44:43 <andersca> @arr
00:44:44 <lambdabot> Ahoy mateys
00:45:47 <Pseudonym> @arr
00:45:48 <lambdabot> This is the END for you, you gutter-crawling cur!
00:57:00 <cedricshock> One of the common features of many programming languages is some sort of data structure with named fields, which allows the programmer to expand a structure from cantaining, say, a name and phone number to also containing an address. I've sometimes seen this called a structure, sometimes a record. Is there something analagous in haskell?
00:57:23 <cedricshock> @arr
00:57:24 <lambdabot> Prelude.(!!): index too large
00:57:52 <andersca> whoops
00:58:05 <andersca> cedricshock: there are data record types in haskell
01:00:03 <cedricshock> andersca: Thanks. I found them a few chapters past data types in the gentle introduction tutorial.
01:02:36 <cedricshock> "As a "side effect" of the successful match, the formal parameter is bound to the value it is being matched against. For this reason patterns in any one equation are not allowed to have more than one occurrence of the same formal parameter" 
01:04:04 <cedricshock> Does this mean that I can't write a pattern for a function that only matches if two things are equivalent, or is there some sort of gaurd expression for function definitions?
01:04:39 <kosmikus> cedricshock: yes, you can use guards for that
01:05:05 <kosmikus> f x y | x `equiv` y = ...
01:05:15 <kosmikus> where "equiv" is your equivalence relation
01:06:25 <cedricshock> Are gaurd expressions first-class, or is there a limited selection to chose from. I guess I'd better just keep reading and stop asking questions I'll probably find an answer to later.
01:07:37 <kosmikus> you can use any expression of type "Bool" in a guard
01:07:49 <earthy> errr... they're not first class in the sense that you can pass them around as arguments or somesuch
01:07:59 <kosmikus> but guards themselves are not first-class entities, i.e., you cannot assign them to variables and so forth
01:08:03 <kosmikus> ah, too slow
01:08:44 <cedricshock> thanks
01:09:32 <kosmikus> s/assign/bind/
01:31:36 <earthy> interesting to see that suddenly there are 3 new announces on haskell.org
01:31:46 <earthy> s/haskell/haskell@haskell/
03:04:50 <shapr> good morning #haskell!
03:05:10 <andersca> hey hey shae
03:05:32 <shapr> hiya andersca
03:08:29 <arjanb> i find the 'do' notation confusing when learning monads
03:11:18 <arjanb> it gives another view on monads with an non trivial transformation so trying to understand them both at the same time makes my brain overheated
03:11:59 <earthy> yup, do notation is all fine and dandy once you understand monads, but up to that point it can be confusing
03:14:30 <shapr> bondage first, nike later
03:14:38 * shapr grins
03:19:01 <Lunar^> earthy: I like Hudak's SOE view on it
03:19:33 <Lunar^> earthy: First show the do notation, saying "this is like you in all langages you already know", explaining what's behind 12 chapters after
03:20:18 <arjanb> imho starting to early with the 'do' notation is the only negative point of the "all about monads" tutorial
03:29:09 <arjanb> why is the a -> m a function called "return"?  the name looks too specific to me
03:30:23 <shapr> it's also called unit I think
03:33:03 <kosmikus> I think the name is a concession to certain widely used imperative languages
03:35:38 <earthy> lunar^: yes, that really is a good way of doing it...
03:36:03 <earthy> but, if you then start doing monads and try to understand it and only think of it in terms of the do notation it gets confusing
03:36:15 <earthy> (at one point you have to ignore it for a while)
03:37:44 <arjanb> indeed
03:41:33 <Lunar^> earthy: yes
03:58:31 * shapr hops
03:58:44 <shapr> hiya _n0cte_ 
03:59:44 <Lukhas> morning #haskell
03:59:59 <shapr> g'mornin Lukhas, written any Haskell code lately?
04:00:21 <Lukhas> some base conversion stuff
04:00:30 <Lukhas> but i'm more into exams right now :(
04:00:50 <shapr> _n0cte_: learning Haskell?
04:01:35 <_n0cte_> not really
04:02:04 <shapr> quelle dommage
04:02:11 <shapr> c'est une langue plus jolie
04:02:17 <_n0cte_> ^^
04:02:37 <shapr> haskell est une langue fonctionelle
04:02:57 <shapr> c'est plus fort och tres chouette ;-)
04:03:13 <_n0cte_> elle est proche de tel type de langage  ?
04:03:24 <shapr> um
04:03:33 <Lukhas> s/tel/quel/
04:03:39 <shapr> je ne sais pai :-)
04:03:52 <shapr> je ne comprends pas!
04:04:10 <shapr> proche?
04:04:16 <Lukhas> "close to"
04:04:17 <_n0cte_> look like ?
04:04:20 <shapr> que'est que c'est en anglais?
04:04:20 <shapr> oh
04:04:27 <Lukhas> or "looks like"
04:04:27 <shapr> hmm
04:04:43 <shapr> peut-etre ocaml/sml/ml
04:04:58 <shapr> mais Lisp, Scheme, elisp, est aussi fonctionelle
04:05:16 <shapr> mais Haskell n'as pas mutable variables
04:05:22 <_n0cte_> je connais pas trop mal le LISP...
04:05:30 <_n0cte_> k
04:05:49 <_n0cte_> quel genre de programme sont écrit en Haskell ?
04:05:57 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
04:06:15 <Lukhas> "mutable variables" ?
04:06:37 <shapr> Lukhas: you can't do x = x + 1, all 'variables' are in fact single assignment constants
04:06:50 <shapr> you can shadow an assignment from an earlier scope though
04:07:08 <Lukhas> well, i didn't feel the need for such a thing, you're right
04:07:35 <_n0cte_> quel age a ce langage ? et par qui a - t - il était concu ?
04:07:50 <shapr> man, I gotta switch back to latin-1
04:08:03 <_n0cte_> ;)
04:08:17 <shapr> quelle dommage, utf-8 är så kul
04:08:45 <Lukhas> shapr: what's wrong with utf-8 ?
04:08:48 <shapr> suivez vous en cours de programme?
04:09:07 <shapr> Lukhas: I can't see latin-1 when I use C-x C-m p utf-8 in erc process buffer
04:09:22 <Lukhas> (setq erc-default-coding-system '(iso-latin-1 . undecided))
04:09:29 * shapr tries that
04:09:34 <Lukhas> i see utf-8 & latin-1&9
04:09:43 <Lukhas> and i send latin-1
04:11:03 <shapr> uff
04:11:14 <shapr> No such coding system: iso-latin-1
04:11:22 <shapr> what's the equivalent for xemacs?
04:11:41 <shapr> _n0cte_: Haskell is fun!
04:11:47 <shapr> lambdabot is written in haskell
04:12:05 <shapr> @yow
04:12:06 <lambdabot> YOW!!  Up ahead!  It's a DONUT HUT!!
04:12:17 <_n0cte_> shapr : i'll learn haskell 
04:12:36 <shapr> haskell can help you be a better programmer in other languages too
04:12:40 <bringert> shapr: "x = x + 1" is valid haskell, and doesn't need an earlier binding of x
04:12:53 <bringert> it's just useless haskell :)
04:12:56 * shapr grins
04:13:21 <shapr> _n0cte_: talar du svenska?
04:14:15 <shapr> Lukhas: No such coding system: iso-latin-1
04:14:24 <shapr> Lukhas: what's the xemacs equivalent?
04:14:50 <andersca> 8859-1?
04:14:55 <andersca> iso-8859-1
04:14:56 <Lukhas> probably
04:14:56 <shapr> peut-etre nous avons besoin de #haskell.fr?
04:15:10 <_n0cte_> <shapr> _n0cte_: talar du svenska? => ?
04:15:11 <Lukhas> but i'd suggest to wipe XEmacs :)
04:15:27 <shapr> parlez vous suedois?
04:15:43 <shapr> I bet my spelling of swedish in french is atrocious
04:15:45 <Lukhas> krifprollf !
04:15:51 <Lukhas> shapr: not so bad
04:16:05 <bringert> vy govorite po shvedski?
04:16:11 <shapr> haha
04:16:57 <shapr> not me
04:17:18 <shapr> _n0cte_: have you used other programming languages?
04:17:23 <shapr> C, Java, Perl?
04:20:17 <_n0cte_> yes
04:20:24 <_n0cte_> LISP, Java
04:20:33 <_n0cte_> i learn C
04:20:44 <_n0cte_> and script langage (vbs, js)
04:20:45 <shapr> a l'ecole?
04:20:56 <_n0cte_> C et JAVA a l'école oui
04:20:59 <_n0cte_> LISP au travail
04:21:06 <_n0cte_> script langage seul 
04:22:00 <shapr> connais tu TTY? Ce chat code en Java... 
04:23:13 <bringert> shapr: weren't they going to teach tty haskell?
04:23:16 <shapr> C isn't a scripting language
04:23:26 <_n0cte_> non, j'apprends le java en cours, on ne la pas vu
04:23:38 <shapr> bringert: I heard they were going to teach her CAML or OCaml because it's more french
04:23:48 <bringert> makes sense
04:24:33 <shapr> _n0cte_: http://www.prologin.org/archives/affiches.php?affiche=affiche_2004_grand.jpg
04:24:37 <shapr> c'est TTY!
04:25:20 <_n0cte_> k thx
04:25:26 * shapr grins
04:26:18 * shapr tries to sort the french and swedish words into two different places
04:26:41 <shapr> bringert: russian is nifty
04:27:45 <shapr> _n0cte_: si vous voulez apprendre Haskell, peut-etre http://www.haskell.org/learning.html
04:27:56 <bringert> but it's a pain to have to transliterate to/from the latin alphabet when typing it in irc etc.
04:28:10 <_n0cte_> shapr : j'ai vu le site oui, je le lis depuis tout à l'heure ;)
04:28:14 <shapr> yah, I can dig that
04:28:23 <andersca> hey JaffaCake
04:28:30 <shapr> good morning JaffaCake 
04:28:36 <JaffaCake> hi all
04:28:38 <andersca> mmmm, cake
04:28:39 <shapr> _n0cte_: c'est bien
04:29:19 <shapr> bringert: one day we'll all switch to utf-8, though I don't know how we'll get multi-char-set keyboards.
04:29:53 <Lukhas> morning JaffaCake
04:30:02 <bringert> I have seen some cool keyboards that can switch between layouts, and that have lcds in each key
04:30:06 <Lukhas> compose key, i think
04:30:20 <shapr> ohh LCDs in each key would be COOL
04:30:33 <shapr> especially if it's part of a complete keyboard lego set
04:30:56 <shapr> where you can buy a different chassis if you want, and completely change the layout
04:31:41 <shapr> I've often wanted to have the flat top of my keyboard facing me, and the keys on mostly on the other side
04:32:01 <shapr> where I grip both edges and rest the sides of my hand on the desk to type
05:32:43 <shapr> hi gini 
05:56:40 <shapr> interesting nickname
06:03:48 <liiwi> ello
06:04:45 <shapr> hei liiwi 
06:13:14 <shapr> g'day Ninja Jones
06:22:52 <SyntaxNinja> hej shapr
06:32:46 <shapr> wazzup?
06:48:05 <shapr> bonjour mij 
07:06:07 <SyntaxNinja> shapr: how are you/
07:06:28 <shapr> I am AWAKE!
07:06:37 <shapr> and working hard!
07:06:41 <andersca> me too
07:07:08 <SyntaxNinja> I have now had some coffee
07:07:24 <SyntaxNinja> JaffaCake is lucky; they've got awesome coffee machines over there.
07:07:24 <shapr> oh, I wanted to ask you something about arrows
07:07:32 <shapr> you gotta talk to your boss
07:07:40 <shapr> tell him it's a work quality requirement
07:09:24 <shapr> you guys need both an automatic coffee machine with either a timer or RFC2324 support, and gourmet coffee to go with it
07:10:28 <shapr> Hyper Text Coffee Pot Control Protocol - ftp://ftp.isi.edu/in-notes/rfc2324.txt
07:11:21 <shapr> emacs already supports that protocol of course
07:11:58 <ibid> i've been telling the people here that  we need HTCPCP supprt ASAP :)
07:13:22 <SyntaxNinja> hehe
07:13:31 <SyntaxNinja> right now we use a french press
07:13:36 <ibid> + for years
07:15:10 <earthy> ofcourse, you'd also want the snmp objects for drip type hot beverage dispensers
07:15:25 <earthy> rfc 2323, IIRC
07:16:46 <earthy> ah, no, 2325 in fact
07:22:24 <bringert> is there a haskell library for producing RSS feeds?
07:22:47 <bringert> consuming RSS would also be nice
07:23:43 <shapr> stepcut has some RSS code
07:24:15 <shapr> and galority wrote CheckRDF that's on sf.net, though I dunno how related that is
07:25:31 <shapr> bringert: http://www.n-heptane.com/nhlab/src/RSS.hs
07:26:04 <shapr> bringert: are you checking out PLog?
07:29:35 <shapr> hiya lantis, wassup?
07:30:16 <lantis> hi :)
07:32:06 <bringert> shapr: sort of
07:32:12 <bringert> thanks for the links btw
07:33:16 <bringert> I talked to pete about adding comments and such to plog, he said he wasn't really interested in that, and that it might be better to start something new to do that
07:33:37 <bringert> but if someone wanted to add stuff to plog, go for it
07:33:50 <shapr> so, we set up a darcs repo and go for it?
07:33:59 <bringert> sure
07:34:27 <bringert> I started writing a very simple system from scratch, just to see how easy it would be with haskelldb, xmlrpc etc
07:34:42 <shapr> what do you think?
07:35:23 <andersca> you'll have to support one of the official xmlrpc blog apis then
07:35:26 <andersca> like the movabletype one
07:35:35 <bringert> I've made a simple haskelldb backend, and a very limited bloggerapi implementation
07:35:53 <bringert> don't really feel like using wash for the web frontend
07:36:21 <shapr> wash feels very procedural to me
07:36:45 <shapr> I want to derive the view
07:37:10 <bringert> is there some more light-weight and declarative library that supports forms?
07:37:28 <shapr> not that I know of
07:37:45 <shapr> but there should be
07:37:52 <shapr> something like steve van hoygen's thesis
07:39:33 <bringert> I haven't done any blogging, and I don't know if I would start either, but it feels like a nice little project involing a bunch of interesting things, like databases, rss, xml-rpc etc.
07:39:55 <bringert> could be a nice demo of the power of using libraries
07:39:57 <shapr> and a declarative form library
07:40:11 <andersca> blogging is fun
07:40:22 <andersca> shapr: did I talk to you about a planet haskell
07:40:39 <shapr> yes, that's why stepcut mentioned his RSS code
07:40:40 <bringert> andersca: I just downloaded gnome-blog to test my bloggerAPI implementation
07:40:48 <bringert> thanks for recommending it
07:40:56 <andersca> cool
07:41:01 <andersca> did you try it too?
07:41:06 <andersca> since it's a panel applet
07:42:08 <bringert> I'm going to just now
07:42:26 <bringert> just seem to have to install som python-gnome bindings
07:46:33 <andersca> yeah
07:46:37 <andersca> it's written in python
07:47:28 <bringert> hmm, still won't work
08:30:31 <shapr> seems to me like Buddha is post-mortem QuickCheck
08:31:13 <shapr> oh, buddha has debs
08:31:37 <shapr> foo, they're not in haskell-experimental
08:32:31 <shapr> hey SyntaxNinja, how hard to add new people to haskell-experimental? can I try to recruit Bernie?
08:34:26 <shapr> hoi arjanb, hoe gaat het met jou?
08:35:27 <SyntaxNinja> shapr: probably; does he have a key in the debian keyring, or can he get one signed by someone here?
08:36:29 <shapr> I dunno, I'll send him an email. He was at ICFP2003, so it seems likely.
08:42:19 <SyntaxNinja> shapr: where's he located?
08:57:33 <whiskas> Hello.
08:58:01 <SyntaxNinja> hi whiskas
08:58:28 <whiskas> I'm starting up with Haskell, got myself ghc and hugs98...
08:58:51 <andersca> good, good
08:58:59 <whiskas> But... why I can't define functions in the interpreter session?
08:59:10 <whiskas> Or, rather, how?
08:59:19 <vegai> let f x = x + 1 and so forth
08:59:24 <vegai> "let" is the magic word
08:59:34 <whiskas> Ooh... I was trying to specify the signature, as well...
08:59:43 <JaffaCake> that has to be the #1 Hugs FAQ :)
08:59:58 <vegai> there's a sensible answer to that which is related to monads
09:00:09 <vegai> but you should perhaps not stress yourself with that yet ;)
09:00:10 <Igloo> You can say let f :: Int -> Int; f x = x + 1   too, but you can't have them on separate lines
09:00:15 <Igloo> (in ghci)
09:00:25 <whiskas> Ooh, so semicolon was the magic symbol :)
09:00:49 <whiskas> Sweet :)
09:00:54 <whiskas> GHCi seems to like that.
09:01:23 <whiskas> Now, can I ask you the classic question?
09:02:05 <whiskas> Like... got any good begginers tut?
09:02:22 <whiskas> :)
09:02:37 <vegai> haskell.org has quite a few, I think
09:03:01 <vegai> though they might be too academic for your taste (they were for mine, iirc)
09:03:11 <whiskas> Okay, any other pointers, then?
09:03:32 <whiskas> Idiotic question: is it possible to write, say, an irc bot in haskell and have fun along the way? :P
09:03:36 <vegai> http://www.haskell.org/tutorial/ seemed like a good guess
09:03:55 <vegai> whiskas: we usually have a lambdabot here, who is written in Haskell, and is quite excellent
09:03:59 <vegai> shawn: ?
09:04:03 <vegai> oops
09:04:10 <vegai> oh, its owner is missing too ;)
09:04:15 <whiskas> Swell :)
09:04:46 <whiskas> I have to say, ML syntax seems prettier at a first look :P
09:05:00 <andersca> ugh
09:05:40 <whiskas> Though I though I'd give Haskell a try, as it is "pure".
09:06:09 <whiskas> *thought
09:08:14 <vegai> I think Haskell has much prettier syntax
09:08:33 <whiskas> Okay :)
09:08:40 <andersca> yeah, definitely
09:08:54 <vegai> which ML syntax did you mean there?
09:09:19 <whiskas> O'Caml, to be precise.
09:09:26 <vegai> oh, that's the worst ;)
09:09:33 <whiskas> :))
09:10:38 <whiskas> Hmm...
09:10:49 <whiskas> I'm following the tutorial on haskell.org...
09:10:56 <SyntaxNinja> @wiki LearningHaskell
09:11:10 <whiskas> But I seem not to be able to type stuff into the interpreter session...
09:11:14 <SyntaxNinja> oh, the bot is gone
09:11:15 <whiskas> Like it gives me errors.
09:11:40 <SyntaxNinja> whiskas: what errors?
09:11:42 <Igloo> Haskell is normally used by writing in a file and then compiling or loading in an interpreter
09:11:57 <whiskas> Can't I just type stuff into the interpreter?
09:11:58 <Igloo> You can generally :r(eload), and in hugs at least :e(dit)
09:12:10 <SyntaxNinja> whiskas: I agree w/ igloo there.  what platform are you using this on?  I usually tell people to use emacs and just reload from a file.
09:12:40 <whiskas> Windows...
09:12:55 <SyntaxNinja> OK well, I won't hold that against you ;)
09:13:04 <whiskas> :))
09:13:10 <SyntaxNinja> fwiw, emacs and haskell-mode (on emacs) are usable on windows too.
09:13:25 <whiskas> I simply HATE emacs (no flame war, please).
09:13:30 <whiskas> That's the thing.
09:13:40 <SyntaxNinja> anyway, you can definitely type stuff into the interpreter, but you will very quickly find yourself programming somethign too complex for that to work wel.
09:13:50 <whiskas> Aha.
09:13:52 <SyntaxNinja> plus I don't know if you can do data declarations and what-not int he interpreter
09:13:55 <vegai> don't hate your tools, they can't fight back ;P
09:14:19 <SyntaxNinja> usually, write your stuff in a file, :load (or :reload) it from the interpreter, then you can run your functions and what-have-you from the interprter
09:14:46 <whiskas> I'll try that.
09:14:52 <SyntaxNinja> whiskas: don't worry, we won't flame you.
09:15:17 <whiskas> :)
09:16:20 <whiskas> So you know of any nice, free, lightweight, programmer's editor for Windows?
09:16:27 <cbus> vim? ;)
09:16:34 <JaffaCake> notepad :)
09:16:35 <cbus> *hides*
09:17:15 <whiskas> Yeah, vim is nice, I use it all the time when I'm on *nix.
09:17:33 <whiskas> But it simply doesn't fit Windows.
09:17:35 <cbus> there is some win-port (i use it)
09:17:37 <cbus> hehe
09:17:40 <cbus> your choice :)
09:17:51 <whiskas> I know, http://www.gvim.org/
09:18:13 <cbus> www.vim.org
09:18:14 <cbus> even
09:18:26 <whiskas> I know that, either :P
09:18:40 <whiskas> s/either/too
09:18:41 <whiskas> Crap.
09:18:45 <whiskas> My English has gone mad.
09:18:47 <whiskas> :P
09:18:50 <cbus> hehe :)
09:18:52 <whiskas> Anyways...
09:19:30 <whiskas> Went I first got into FP, I was (and still am) looking for a tut or something that works with real-world examples, not how to get the roots of a quadratic equation or so...
09:19:45 <whiskas> s/works/would work/i
09:20:39 <SyntaxNinja> whiskas: what would you consider a real-world example?
09:21:00 <whiskas> Dunno... something that does something useful... I really don't have an example at hand.
09:22:00 <SyntaxNinja> well, I've never really seen a tutorial for any  language that does something truly useful.
09:22:12 <whiskas> Hmm...
09:22:21 <SyntaxNinja> here's information about lambdabot: http://www.haskell.org/hawiki/LambdaBot
09:22:40 <SyntaxNinja> the book "Haskell School of Expression" works with animation, geometry, music, etc.
09:23:58 <SyntaxNinja> here's my slashdot review of that book :) http://books.slashdot.org/books/04/03/12/221232.shtml?tid=126&tid=156&tid=188&tid=192
09:25:02 <whiskas> @listcommands
09:25:12 <whiskas> Oh wait, it's not here.
09:25:44 <whiskas> Damn, FP still feels so weird.
09:25:46 <whiskas> :(
09:26:22 <neologism> you'd better learn one language perfecly then messing with others
09:26:53 <monotonom> In a parallel universe, everyone does FP, and then someone comes along with Algol, and everyone says it's weird.
09:27:05 <whiskas> It's not about languages, it's about programming paradigm.
09:27:29 <monotonom> s/language/paradigm/ in his statement then! :)
09:27:33 <neologism> if you learn given langauge you learn the paradigm it implements along th eway
09:27:58 <whiskas> It's like, everyone graps imperative, OO is easy, meta is nice with C++, but FP... sheesh, quite a change of perspective.
09:28:00 <neologism> I dont see differecnces among C/Pascal/Java and Haskell/Lisp/FP and Goedel/Prolog for example
09:28:17 <SyntaxNinja> I think the poin tof sticking to one language is to isolate the details of learning the language itself from the details of learning the functional paradigm in general.
09:29:19 <neologism> agreed
09:30:00 <monotonom> I begin to think ML is the easier transition from imperative to functional.  No, not because of mutable variables in ML.  It is because of the eager execution.
09:30:43 <SyntaxNinja> why does that make it easier?
09:30:48 <SyntaxNinja> most of the time, you can ignore laziness
09:31:42 <neologism> you can ignore lazyness in haskell too
09:31:51 <neologism> it jsut depends on example
09:31:55 <neologism> you are trying to code
09:32:10 <SyntaxNinja> neologism: yeah, I'm talking about haskell.
09:33:24 <neologism> SyntaxNinja: I talked to monotonom 
09:33:43 <monotonom> I have the spotlight.
09:33:48 <whiskas> :))
09:34:39 <neologism> you really had ;)
09:41:29 <srle> Hi
09:43:37 <srle> Hi.
09:43:56 <srle> I have a question about Haskell.
09:45:10 <neologism> so ask...
09:45:20 <monotonom> We all have questions about Haskell.
09:45:27 <srle> How to make a list of random numbers in Haskell, but list has to have different elements each time the proggram is started.
09:45:56 <srle> I tried randomRIO but I didnt know how to use it.
09:46:46 <neologism> import Random
09:46:47 <srle> If I use randomR of randomRs, I hame manualy to set seed.
09:46:47 <neologism> ?
09:48:06 <neologism> set seed to time value or whatever
09:48:12 <neologism> automatically
09:48:28 <srle> I imported Random but can you give me a oneliner. I would like to write something like this: print sum take 5 listOfRandomNumbers.
09:48:58 <monotonom> I would relax it to two-liner.
09:49:04 <neologism> ;)
09:49:07 <srle> OK.
09:49:15 <neologism> I dont know the api of Random
09:49:46 <neologism> but something like set_sed foldr (:) getrandom [] ?
09:50:37 <srle> The problem is that randomRIO is monad or something like that and it doesnt behave like regular function. I'll try what you have told me. Thanks.
09:51:01 <neologism> srle: it being a monad means you can serialize actions
09:51:17 <monotonom> Your main program is also an IO monad.
09:51:18 <neologism> which is necessary for seed being set before geting those numbers
09:52:37 <srle> I dont understand how to make a nondeterministic function out of the deterministic functions. Seed always has to be some value like time or date which is not deterministic. Thats what confuses me.
09:53:12 <monotonom> That is a philosophical question, and I would ignore it for the next few months.
09:53:18 <neologism> lol
09:53:25 <neologism> srle: just set the seed to time
09:53:37 <neologism> and the seed will be set according to time the program is run
09:54:12 <monotonom> { x <- randomIO; print x } will get you one pseudorandom number.
09:54:57 <srle> monotonom > That is the point. How to appent value of x to some list.
09:55:06 <monotonom> Err of course that does not tell the computer what type I want.
09:55:14 <shapr> I heard that haskell is really cool.
09:55:27 <monotonom> { x <- randomIO; print (x :: Int) } is better.
09:56:09 <shapr> srle: is Haskell cool?
09:56:17 <monotonom> randomIO and randomRIO uses the global generator, which is automatically seeded irreproducibly when the program starts.
09:56:58 <srle> How to write something like this. {f = randomIO >>= \x -> x : f}
09:58:19 <monotonom> To use randoms or randomRs to get a list, you need to get hold of a generator, say the global generator (hey it is already there and seeded as you wish, so why not).  The global generator can be obtained by the IO action getStdGen :: IO StdGen
09:59:12 <monotonom> { g <- getStdGen; print (take 5 (randoms g :: [Int])) }  The promised two-liner.
09:59:22 <shapr> huh, that looks like one line to me.
10:00:07 <srle> monotonom > Thanks. I'll try it. I have to go now. Bye.
10:00:22 <neologism> shapr: everything can be written on on-line if needed.. just the line would be a bit long
10:00:35 <monotonom> Look I am not one of those Obfuscated C contestants, I don't call a hundred-line program "one line" simply because I could concatenate!
10:00:56 <shapr> what about an Obfuscated Haskell contestant?
10:01:08 <monotonom> I am against all obfuscation.
10:01:49 <neologism> monotonom: how would you do that with just randomIO ?
10:01:55 <neologism> I mean creating the list
10:02:44 <monotonom> Too much work for me, and then I am not sure if the result is memory-efficient.
10:03:13 <neologism> it doesnt matter
10:03:18 <neologism> I am interested in that construct
10:03:42 <neologism> x <- randomIO foldrm_ (:) x [] ?
10:03:58 <shapr> @index randomRs
10:04:08 <shapr> hm
10:04:33 <shapr> @index randomRs
10:04:35 <lambdabot> System.Random,Random
10:04:45 <shapr> @type Random.randomRs
10:04:46 <lambdabot> Random.randomRs :: forall a g.
10:04:46 <lambdabot> 		   (System.Random.Random a, System.Random.RandomGen g) =>
10:04:46 <lambdabot> 		   (a, a) -> g -> [a]
10:05:35 <monotonom> I don't know how to do it.
10:05:51 <neologism> would that mine solution work? at least a bit ;)
10:05:57 <shapr> try it!
10:06:15 * shapr throws code darts at the target
10:06:31 <neologism> shapr: having no haskell at hand
10:06:38 <shapr> install it!
10:06:39 <neologism> I think it could... by a chance
10:06:56 <neologism> shapr: within 10 minutes I am going off ;)
10:07:02 <neologism> I am at school
10:07:10 <neologism> and I dont want to waste my time with such things
10:07:13 <shapr> it works on windows, linux, bsd, macosX, lots more
10:07:21 <shapr> well, ok
10:07:33 <neologism> shapr: I know, but I am at school and I am willing to waste no time on this
10:07:46 <shapr> ok, if you say so.
10:07:47 <monotonom> If you use some kind of foldM, it will not stop.
10:08:22 <neologism> monotonom: its lazy
10:08:45 <monotonom> The IO monad has strictness and eagerness written all over it.  Remember you said things about serialization?
10:09:08 <monotonom> And you are foldMing over an IO monad.
10:09:25 <neologism> hm... thats true
10:10:48 <shapr> you could seed the random gen yourself, and then it could be lazy
10:11:57 <monotonom> If you know how many numbers you want, you can fold-whatever over a list of that length, so at least it will finish.
10:12:22 <neologism> of course (I could take X couldnt I?)
10:12:37 <monotonom> If you don't know, you may have to fall back to my two-liner.
10:13:24 <monotonom> @type repeat
10:13:26 <lambdabot> repeat :: forall a. a -> [a]
10:13:45 <neologism> foo x = x <- randomIO take X (foldM_ (:) x []) ?
10:13:47 <monotonom> I badly need reverse type lookup
10:13:55 <neologism> shit, cofused with parametr names ;)
10:14:16 <Smerdyakov> Coq has reverse type lookup!
10:14:22 <monotonom> I will ask the humans here.  Need a function of type a -> Int -> [a] or Int -> a -> [a]
10:14:55 <shapr> monotonom: what does it do?
10:14:57 <Smerdyakov> OK!
10:15:01 <Smerdyakov> \ _ _ -> []
10:15:07 <monotonom> @type replicate
10:15:09 <lambdabot> replicate :: forall a. Int -> a -> [a]
10:15:16 <shapr> that looks like it.
10:15:35 <shapr> monotonom: btw, several more of us want reverse type lookup as well
10:15:51 <monotonom> sequence (replicate 10000 randomIO) will get you 10000 random things in a list.
10:15:51 <shapr> we've had some interesting discussions and pointers to various papers about it.
10:16:15 <Smerdyakov> shapr, papers? Is there something complicated about it?
10:16:24 <Smerdyakov> shapr, is it because of type classes?
10:16:53 <arjanb> reverse type lookup ???
10:16:56 <shapr> well, how would you do it?
10:17:18 <shapr> arjanb: it's easy to ask GHCi for the type of a function, but there's no easy way to ask for functions that have a certain type
10:17:19 <Smerdyakov> The same way you do pattern matching of values.
10:18:01 <shapr> it may be that easy, I won't know for sure til I've tried to write it.
10:18:24 <Smerdyakov> You can look at what Coq does.
10:18:24 <shapr> there are more issues than that though
10:18:34 <shapr> @type (+)
10:18:36 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
10:18:38 <Smerdyakov> There are no type classes there, but it is still a pretty complex logic.
10:18:47 <shapr> does that match a -> a ? yes, it does.
10:19:00 <Smerdyakov> shapr, how?
10:19:09 <shapr> @type (+ 1)
10:19:11 <lambdabot> (+ 1) :: forall a. (Num a) => a -> a
10:19:17 <Smerdyakov> (+ 1) is not (+)
10:19:28 <shapr> every haskell type signature has implicit parens
10:19:40 <shapr> so (+) can take just one argument
10:19:47 <monotonom> (a -> a) -> a will match b -> a, not a -> a
10:19:48 <Smerdyakov> Again, (+ 1) is not (+).
10:19:50 <shapr> because it really has a -> (a -> a) as the type sig
10:19:59 <monotonom> Err 
10:20:07 <monotonom> a -> (a -> a) will match b -> a, not a -> a
10:20:11 <Smerdyakov> If you are really asking "find an expression with this type" instead of "find a variable of this type," then this makes sense.
10:20:20 <Smerdyakov> But I assumed you meant the simpler "find a variable."
10:20:58 <shapr> dumping out the type sigs as strings and doing alpha renaming would be the cheesy solution
10:21:41 <shapr> I'd like to have a lookup that's smart enough to handle currying
10:22:03 <bringert> and flipped arguments
10:22:08 <shapr> yup
10:22:15 <monotonom> We are grown-ups.  When I ask for a -> [a], I surely mean the two a's to be the same type; why would I not write a -> [b] otherwise?
10:22:44 <shapr> ok?
10:23:47 <monotonom> So I don't see why a->(a->a) is thought to match b->b and why it is not out of the question.
10:25:13 <shapr> if you have a transform function that works on transform functions, then a->(a->a) and b->b could actually match
10:25:50 <monotonom> Alright tell me one single instantiation of b that does what you say.
10:26:58 * shapr thinks about it
10:28:25 <shapr> let's say that b is a transform function
10:28:44 <shapr> it takes a function, and returns a function
10:29:26 <shapr> let's say you use that function on itself
10:29:30 <shapr> what is its type?
10:29:58 <monotonom> I see what you mean.  But I use the reverse lookup this way.  I write "find me something that matches b->b".
10:30:01 <shapr> if it takes a function and returns a function, then it matches b -> b, right?
10:30:33 <shapr> but, b -> b can mean a bunch of different things
10:31:28 <monotonom> That is not precise enough.  The precise statement is: b can be instantiated to one of a bunch of different things.
10:32:04 <monotonom> Even that is not enough.  Here it is: the search engine may instantiate b to one of a bunch of different things.
10:32:05 <arjanb> why would you want more specific definitions than the type you asked for?
10:32:32 <shapr> ah, monomorphism like regex backreferences, that would make it much easier to write.
10:32:52 <shapr> in fact, I think you could write it with a regex in that case.
10:33:11 <shapr> arjanb: what do you mean?
10:33:21 <monotonom> This has nothing to do with monomorphism.
10:34:12 <monotonom> It's plain basic HM typing.  If I have f::a->a  it simply cannot be specialized to f::Int->Bool.
10:34:28 <shapr> arjanb: oh, you mean, why would I want a -> (a -> a) if I asked for b -> b? because sometimes they are the same.
10:34:52 <arjanb> yes
10:34:53 <shapr> unless you've made Num and Bool instances of the same typeclass.
10:35:05 <Smerdyakov> shapr, no. You can use an expression of the first type to build an expression of the second type, but I wouldn't say that "somtimes they're the same."
10:35:41 <arjanb> i think it's up to the user to give precise enough types for the lookup
10:36:07 <shapr> anyway, it's a fun problem to consider.
10:36:13 <Smerdyakov> In case y'all don't realize it, a Prolog interpreter can do most of this reasoning for you.
10:36:31 <Smerdyakov> Since Haskell types are isomorphic with predicates in higher-order logic. (Mostly first-order, even)
10:36:37 <monotonom> Int and Bool are both instances of Eq in Haskell.  Yet in Haskell f::a->a never becomes f::Int->Bool.
10:36:43 <shapr> it'll be fun to read these papers and try to build a this sort of lookup into lambdabot 
10:37:14 <shapr> monotonom: why is that?
10:38:06 <monotonom> f::(Eq a)=>a->a never beomces f::Int->Bool either.
10:41:38 <monotonom> I'll let ghc tell you why.  (==) :: (Eq a) => a->a->Bool.  Let's see if I could use it like Int->Char->Bool, Int and Char both being instances of Eq.
10:42:11 <monotonom> (1 :: Int) == ('c') gives: Couldn't match `Int' against `Char', Expected type: Int, Inferred type: Char
10:42:22 <jameson> Hmm... is there something like 'readFile' of type 'String -> IO [Word8]' ?
10:42:27 <monotonom> And it is not even the monomorphism restriction.
10:42:34 <jameson> (i.e., that interprets a file as a binary file?)
10:43:21 <shapr> jameson: yes, NewBinary
10:43:39 <shapr> I think I have stepcut's patched version handy...
10:43:47 <arjanb> i think reverse type lookup should only show generalizations so  (a -> b) -> [a] -> [b] would give map but also fmap :: Functor a => (b -> c) -> a b -> a c 
10:44:24 <shapr> jameson: http://shapr.homelinux.net/~shae/NewBinary/
10:44:59 <shapr> it may not be exactly what you want, there may be some other better solutions around
10:45:15 <shapr> monotonom: sounds good to me
10:50:29 <shapr> greetz stepcut
10:52:03 <jameson> shapr: Thanks
10:52:03 <stepcut> greetings
10:52:16 <shapr> jameson: does it do what you need?
10:52:33 <shapr> credits to stepcut for updating NewBinary for GHC 6.2.1
10:52:48 <shapr> originally written by Hal Daumé III
10:53:02 * shapr creates ihdb.org
10:53:09 <stepcut> well, it only took 5 minutes :) I give Hal Daume III all the credit for writing it
10:53:35 <shapr> bwahahaaa --> "It doesn't matter that Britney Spears has nothing to say and is about as deep as a birdbath. It matters that she has cute tits, and that's all that matters."
10:53:51 <shapr> from http://www.pbs.org/wgbh/pages/frontline/shows/music/interviews/crosby.html
10:59:25 <jameson> shapr: Something to (lazily) search and replace in large binary files.
11:01:02 <shapr> oh
11:05:41 <vegai> I wonder if it's counter-productive that the monad section of the tutorial in haskell.org begins with "This section is perhaps less 'gentle' than the others."
11:05:47 <shapr> heh
11:06:02 <vegai> also, there are some minor grammar faults.... I wonder who made that
11:06:15 <shapr> wikize it!
11:06:23 <vegai> ah, found them
11:06:35 <vegai> hmm, it's rather large. But why not
11:08:15 <earthy> coult it be that it is `difficult for the uninitiated reader' [RR011]
11:08:19 <earthy> ?
11:09:10 <vegai> but what if it really isn't?
11:09:18 <vegai> or, only is because of saying that it might be
11:10:09 <vegai> but then again, perhaps it is ;)
11:12:24 <gintas> I also think that it's very unconstructive to say 'hold on, this is gonna be hard'
11:12:31 <shapr> I've seen a bunch of different responses here
11:12:39 <shapr> some people think the gentle intro is weenie and slow
11:12:49 <shapr> when I went through it, it felt like a brickbat
11:13:44 <shapr> I don't why some people without any prior FP experience can just read the Gentle Intro and understand it, and some people can't.
11:13:44 <gintas> shapr: yeah, the last time I tried to follow it (a year or two ago), it felt pretty much the same
11:13:57 <shapr> so I yelled loudly on the mailing lists, and Hal started YAHT
11:14:14 <shapr> and now there's #haskell, and lots of people willing to help
11:14:17 <gintas> shapr: I think it's related to maths skills
11:14:33 <shapr> I just couldn't get a conceptual handle on monads
11:14:45 <gintas> that would explain why I find it easier to follow now
11:14:48 <shapr> everything else was easy, I'd thought of much of it myself
11:15:17 <shapr> someone said to me that my Python code was beginning to look purely functional
11:15:22 <stepcut> :p
11:15:42 <shapr> but, monads don't come easy to me
11:15:53 <shapr> arrows are easier though, they just make more sense
11:15:54 <gintas> shapr: please don't do that. Python is an imperative language, period
11:16:17 <gintas> I had a shiver when you said you were having stack overflow errors in python constantly :)
11:16:23 <shapr> :-)
11:16:58 <shapr> I switched to using recursion and explicitly passed state in some of my Python code, that's when someone pointed me to Haskell.
11:17:14 <gintas> shapr: functional programming obscures Python code, which kind of defeats the purpose of using Python in the first place
11:17:38 <shapr> I think FP fits into Python just fine, for the most part.
11:17:42 <gintas> sometimes having an explicit state is a good idea
11:17:58 <gintas> but I'd rather avoid it where it isn't needed
11:18:04 <gintas> because it makes things more complex
11:18:11 <shapr> monads are explicit state
11:38:11 <vegai> shapr: http://personal.baker.edu/web2/cdavis09/roses.html
11:38:19 <earthy> frigging `intelligent' linkers
11:38:38 <vegai> shapr: you probably heard of that before. Some people get it instantly, others don't
12:06:25 <earthy> well, that was in interesting little game
12:06:45 <earthy> the link didn't work for me, so I had to hunt for a version that did
12:07:12 <earthy> and the article about Bill Gates and how hard a time he had of working it out was very entertaining ;)
12:21:57 <vegai> oh, that was a flashy version. Sorry
12:25:29 <Igloo> Got one that'll work in galeon without flash or Java?
12:25:58 <vegai> we could code one for lambdabot
12:26:13 <vegai> though it doesn't really work so well
12:27:41 <vegai> for reasons which are perhaps obvious for those who solved it
12:44:51 <lispy> hmm...seems very hard to find comparisons of languages that focus on programmer performance...
12:45:09 <vegai> hard to measure, that is
12:46:26 <lispy> the only one i've been able to find is at norvig.com, know of any others?
12:46:59 <vegai> is that the one with Erlang?
12:47:24 <lispy> i don't remember if it covered Erlang, I know it covered C, Java and Lisp
12:48:09 <vajrabum_> The history of the ICFP contest?
12:48:27 <lispy> ICFP contest?
12:49:05 <vajrabum_> http://www.google.com/search?hl=en&ie=UTF-8&q=ICFP+programming+contest&btnG=Google+Search
12:50:26 <vajrabum_> This is a yearly programming contest held in conjunction with the ICFP conference. The purpose is to provide a head to head comparison of language technologies.
12:51:51 <vajrabum_> Of course this is all confounded by the contribution of skill that the contest teams brought to the problems.
12:53:36 <lispy> right, i'm trying to find the judging criteria to make sure it compares what i'm curious about
12:54:22 <vajrabum_> The only criteria that I remember for the winners are correctness and development speed.
12:54:41 <lispy> perfect
12:54:54 <vajrabum_> They give honorable mentions based on other criteria, but the winners are only juged on those two.
12:55:13 <vajrabum_> Many, but not all of the contest entries are on line.
12:55:27 <vajrabum_> It's kind of interesting to see how different groups conceive the same problems.
12:56:53 <lispy> it's some sort of robot simulator?  or was that a one year theme?
12:58:02 <vajrabum_> Every contest has a different problem.
12:58:32 <vajrabum_> The 2000 one was to code up a ray-tracer kind of like POVray from scratch.
12:59:15 <vajrabum_> Most of them have a computer-sciency flavor to them though.
13:00:03 <lispy> a ray-tracer in 3 days would be hard...i'd have to learn all the math as i went :)
13:00:36 <vajrabum_> Some of the other problems have the same problem. Usually the winners are grad students or professor types.
13:01:07 <vajrabum_> Those folks are likely to already know the algorithms involved.
13:01:23 <lispy> that makes sense
13:01:46 <vajrabum_> None of this is really an answer to your question but it bears in the same direction.
13:03:04 <lispy> due to the lack of official studies, i think this will satisfy my curiosity
13:04:36 <vajrabum_> You might even learn something about ray-tracing. ;)
13:05:32 <lispy> hehe, the ironic part is that i've helped write a ray-trace in common lisp :)
13:05:42 <lispy> but my contributions were not great
13:06:06 <lispy> mostly i performance tuned the output, and found some bugs :)
13:07:02 <vajrabum_> Sounds cool. I've never written a lick of common lisp. I'm not sure whether that's a recommendation or not.
13:08:14 <lispy> i like lisp, but i like to learn about other languages when i have time, and lately i've found myself curious about haskell
13:09:38 <vajrabum_> Haskell is a good thing to be curious about. There are all sorts of interesting language ideas built into it. Maybe too many. Off to lunch now.
13:09:53 <lispy> thanks for the links
13:25:56 <TheHunter> Hi, I've got a question about the Haskell type system
13:26:58 <TheHunter> I was trying to implement different "recursion strategies"
13:28:06 <TheHunter> the basic version is a function that evaluates the recursion in the usual order
13:28:17 <TheHunter> basicRec :: ((k -> v) -> k -> v) -> k -> v
13:28:23 <TheHunter> basicRec rec = f where
13:28:30 <TheHunter>     f = rec f
13:29:01 <TheHunter> This works fine as long as I don't try to give a type signature in the where clause.
13:29:57 <TheHunter> If I intentionally give it a wrong signature f :: Int
13:30:22 <TheHunter> the compiler (ghc) suggestest that f should be of type f :: k -> v
13:31:01 <TheHunter> but if I give f this type, this doesn't unify with the signature of basicRec
13:31:52 <TheHunter> so that the compiler decides f that rec is not general enough to do this kind of thing
13:33:02 <TheHunter> Is there any way to tell the compiler that it should use the type names (k, v) from the basicRec type signature?
13:35:39 <Riastradh> Is there something wrong with just not specifying the type of f?
13:37:43 <TheHunter> When the where-clause becomes bigger,
13:38:23 <TheHunter> and more complicated and I make a mistake somewhere the errors will get even weirder than there usually are
13:39:59 <TheHunter> I actually was trying to implement a monadic version of this recursion thing of type
13:40:09 <TheHunter> cachedFM :: (Ord k) => ((k -> (State (FiniteMap k v) v)) -> k -> (State (FiniteMap k v) v)) -> k -> v
13:42:15 <TheHunter> I worked around this by developing it first with concrete types, but that doesn't seem to be a good solution
15:42:04 <cedric_> Is anyone here familiar with category theory?
15:51:58 <monotonom> A bit
15:53:58 <cedricshock> It seems an aweful lot like group theory. We have a class instead of a set, and a binary operator. IS the big difference in the properties of the identities?
15:56:02 <cedricshock> It's an aweful lot unlike group theory.
15:56:03 <monotonom> The binary operator has no inverse.
15:57:26 <cedricshock> Ok, if we look at morphisms with respect to composition of morphisms, and assume it is well defined.
15:57:45 <monotonom> A group has just "elements".  A category has objects and morphisms; the binary operator applies to morphisms, but don't forget that objects do something too, which is not present in group theory.
15:57:56 <cedricshock> Then we have the associative property.
15:58:24 <cedricshock> Are the morphisms a group. I don't think so because the identities don't seem right.
15:58:38 <monotonom> Namely, let A, B, C, D be distinct objects.  If you have morphism f:A->B and g:C->D, you *cannot* compose f and g with the binary operator.
15:58:55 <monotonom> Whereas in a group you compose at will.
15:59:01 <cedricshock> ahh
15:59:14 <monotonom> So in other words, a category comes with some type constraints.
16:00:40 <monotonom> Now if you say, let me fix two objects A and B, and just look at all morphisms A->B.  Now you can say they are sort of a monoid or something.
16:01:03 <cedricshock> For every object X, we have exactly one identity morphism that maps X to X.
16:01:17 <cedricshock> That's really different from an identity in a group.
16:01:32 <monotonom> That is also right.
16:02:42 <monotonom> For the morphisms A->B, id_A is an identity on one side and id_B is an identity on the other side.  You have a left identity and a right identity, and they are usually different.
16:02:58 <monotonom> So it doesn't even look too much like a monoid.
16:03:13 <cedricshock> So if the class has N objects, then the size of the set of morphisms would be N*N, because they'd be formed by the cartesian product of the class with itself?
16:03:41 <monotonom> No. Between A and B the possible number of morphisms is unrestricted.
16:03:59 <cedricshock> But between A and A there can be only one?
16:04:10 <monotonom> No, not even that.
16:05:17 <cedricshock> But A -> A is the identity for A, and its unique. Or does it also need some other condition like idA(A) = A?
16:05:36 <monotonom> The identity rule just says, among all morphisms A->A, exactly one of them has the identity property.
16:06:17 <cedricshock> The identity property being that given X, a member of the class A, id(X) = x?
16:06:31 <monotonom> No.
16:08:02 <cedricshock> Let's call it idA: A -> A where A is some class
16:08:12 <cedricshock> What gives it the identity property?
16:08:30 <jameson> Let o be an object of the category C under consideration, and Mor(C) be the class of all morphisms in that category. Then there exists precisely one morphism id(o) such that, for all m \in Mor(C, o), m * id(o) = m, and for all m in \in Mor(o, C), id(o) * m = m.
16:08:39 <jameson> (If I remember correctly.)
16:09:18 <monotonom> forall f:X->Y, f.id_A = f.  forall g:Y->X, id_A.g = g
16:09:42 <monotonom> err s/X/A/
16:10:00 <jameson> So, for each object in the category there exists some morphism which, when applied before or after ANY type-matching morphism, preserves that morphism.
16:10:54 <cedricshock> So it must map each element of the class A onto itself, and it must be the identity function in the class A?
16:11:23 <monotonom> class A? I thought A was an object.
16:11:34 <cedricshock> A is an object in the castegory.
16:11:42 <cedricshock> Doh!
16:11:53 <jameson> Category theory does not talk about the structure of objects at all.
16:12:08 <jameson> There is no notion of "elements of objects", or anything.
16:12:17 <cedricshock> I read it all wrong. I saw *a class of things called objects
16:12:34 <cedricshock> And interpereted it as meaning the objects in the category are classes.
16:13:24 <aFlag> can't i define a function on the interactive interpreter (ghci)?
16:14:06 <monotonom> let f x = x + 1
16:14:10 <jameson> aFlag: IIRC, the best you can do is to load a file with a definition or to do 'let f = ... in (here-goes-the-rest)'.
16:14:20 <ayrnieu> flag - with GHCi, yes.  jameson seems to have Hugs in mind.
16:14:39 <jameson> ayrnieu: How does that work?
16:14:41 <cedricshock> So among morphisms from A -> A, the identity one is one such that idA.f = f and f = f.idA when f is another morphism in the category?
16:14:48 <aFlag> Prelude> my_length [] = 0
16:14:48 <aFlag> <interactive>:1: parse error on input `='
16:14:58 <ayrnieu> jameson - I couldn't tell you about the implementation.
16:14:59 <aFlag> what am i doing wrong?
16:15:10 <ayrnieu> flag - please consider monotonom's example.
16:15:20 <monotonom> Good counsel always goes ignored.
16:15:45 <monotonom> Bad counsel always gets the attention because it generates endless conversations.
16:15:46 <aFlag> oh, i'm sorry, i thought ayrnieu said it was for hugs 
16:15:50 <cedricshock> So where does this equality notion come from?
16:16:11 <monotonom> equality is taken for granted.
16:16:31 <monotonom> As undefined as the composition operator.
16:17:06 <monotonom> All we know is it's reflexive, symmetric, and transitive, and also satisfies the Leibniz rule.
16:17:25 <cedricshock> Ok. It's undefined like the operator in a group.
16:18:20 <monotonom> For example from f.g=h you deduce blahblah f.g blahblah = blahblah h blahblah
16:18:39 <cedricshock> So a category really needs a class of objects, the morphisms, some notion of equality between objects (or is that required for a class, I can't remember...) and maybe a few other things that depend on its application.
16:18:44 <jameson> ayrnieu: No, I meant-- how would I define a function on-line in ghci?
16:18:50 <jameson> (syntax)
16:19:11 <monotonom> equality between morphism is also needed and is usually more used.
16:19:20 <monotonom> s/morphism/morphisms/
16:19:57 <cedricshock> From which we could define our own notion of equality between objects, based on their associated unique identity morphism.
16:20:04 <TheHunter> you actually don't need equality explicitely because you already have that for elements of classes
16:22:35 <aFlag> on the "yet another tutorial" in haskell's page there's this definition of a length function:
16:22:41 <aFlag> my_length [] = 0
16:22:55 <aFlag> my_length (x:xs) = 1 + my_length xs
16:23:05 <TheHunter> equality of objects doesn't mean much. You can often treat isomorphic objects (that is objects A,B with arrows f: A->B and g: B->A and f.g=id_B, g.f=id_a) as equal
16:23:07 <aFlag> i can't figure out how that x:xs worked
16:23:31 <aFlag> it doesn't seem to be explained on the tutorial
16:23:55 <lispy> aFlag: have you read about pattern matching yet?
16:23:59 <cedricshock> Alright. Does anyone here know how this category theory stuff relates to arrows?
16:24:11 <cedricshock> The (x:xs) is a pattern.
16:24:17 <aFlag> hum...
16:24:36 <TheHunter> "arrow" is just another name for "morphism"
16:25:31 <lispy> aFlag: it basically means, if you feed the function a list, it should separate the first element from the rest of the list, as x and xs respectively
16:26:01 <lispy> aFlag: from there it's just a simple recursion
16:26:16 <jameson> Are you referring to the category-theoretical modeling of John Hughes' Arrows?
16:26:18 <aFlag> yeah, the pattern was the only thing i didn't understand
16:26:20 <cedricshock> It "matches" when the argument to the function is a list with the first element x, and the rest of the list xs. Then it "binds" x to the first element of the list, and xs to the rest of it, making them variables containing those values.
16:26:36 <aFlag> i suppose there's more to patterns than that, right?
16:27:07 <lispy> aFlag: yes, and they can be quite handy
16:27:13 <cedricshock> actually the mylength [] = 0 also has a pattern, [], which matched the empty list.
16:29:31 <cedricshock> jameson: I don't know. I was told to look into arrows instead of evaluating code, and to look into category theory to understand arrows.
16:31:40 <TheHunter> I guess you mean John Hughes' Arrows. It's roughly as follows. In Haskell, you have the category of "types" with objects the haskell types and morphisms the functions between that types.
16:31:40 <monotonom> There is some chance they mean Hugh's arrows, in which case you have a week or two or reading before you get there.
16:31:50 <monotonom> err Hughes
16:34:32 <cedricshock> Excellent! What ould you suggest I read next?
16:36:20 <cedricshock> class Arrow a where
16:36:20 <cedricshock>   arr :: (b -> c) -> a b c
16:36:20 <cedricshock>     -- Each function may be treated as a computation.
16:36:32 <monotonom> There is some chance you want to first get to monads.
16:36:36 <cedricshock> What does this type definition mean?
16:37:28 <cedricshock> arr is a function from (functions from type b to type c) to what is the "a b c"?
16:39:03 <andersca> arr is
16:39:04 <andersca> @arr
16:39:04 <lambdabot> Yeh scurvy dog...
16:39:20 <cedricshock> That's the same advice I got last night. I've read a bunch on monads, but I'm not sure I'be totally got them.
16:39:29 <cedricshock> @arr
16:39:29 <lambdabot> Ahoy mateys
16:39:37 <monotonom> 'a' is a parametric type with two type parameters. You now use it 'a b c', i.e., the two parameters are b and c respectively.
16:40:27 <monotonom> At this point I can only be abstract because 1. I haven't learned some interesting examples of arrows, 2. it is supposed to be rather abstract. :)
16:41:25 <cedricshock> So arr takes a function from type b to type c and makes an arrow with tpye parameters b and c, or was a some other type already?
16:41:56 <cedricshock> @Arrow
16:41:56 <lambdabot> Sorry, I don't know the command "Arrow", try "lambdabot: @listcommands"
16:42:37 <jameson> cedricshock: 'a' is some sort of type constructor, from what I can see (I don't fully understand arrows yet, either). I suppose that 'a' should be thought of as being a type of some typeclass "Arrow" (similar to how Monads are handled).
16:45:36 <lispy> has anyone ever written a haskell to haskell compiler (perhaps i mean translator) ?
16:46:35 <monotonom> { f <- readFile in; writeFile out } ?
16:46:58 <lispy> monotonom: how about _non_ trivial :)
16:48:08 <lispy> my reason for asking: I wonder if certain optimizations would be easier to do if the program was interpreted on a high level
16:48:44 <lispy> it's probably a stupid question...
16:48:53 <monotonom> Yes at every level there are optimizations easy to do.
16:49:18 <monotonom> But I know of no non-trivial h2h transformer.
16:49:44 <lispy> h2h transformers, compilers in disguise :)
16:51:03 <cedricshock> Perharps you are looking for some sort of parser? In Erlang a parsed representation of code is called an abstract form, and is a basic component of the system.
16:51:30 <dons> ghc is an h2h transformer. "compilation by transformation" is its strategy.
16:51:44 <TheHunter> @cedrishock: I guess you should read a short introduction to category theory first (see http://cliki.tunes.org/Category%20Theory%20101). Then you should make sure you understand the Haskell type system and move on with the papers by hughes and patterson. I think there is no really easy introduction to the Arrow Concept.
16:51:45 <lambdabot> Sorry, I don't know the command "cedrishock:", try "lambdabot: @listcommands
16:52:42 <dons> an hs-plugins has an h2h transformer that takes in 2 .hs files and merges their syntax to produce a 3rd .hs file
16:52:47 <dons> s/an/and/
16:53:01 <dons> if you want to do this stuff, look at the Language.Haskell library
16:53:55 <lispy> dons: cool, i'm still very much new to the language, but i'll make note of that
16:55:03 <cedricshock> TheHunter: I think I've got the category theory part, at least partialy. I guess I'm on the type system now. I'll read the tutorial parts on it again.
16:58:43 <cedricshock> @Control.Arrow
16:58:44 <lambdabot> Sorry, I don't know the command "Control.Arrow", try "lambdabot: @listcommands
16:59:20 <cedricshock> If we have this declaration:
16:59:21 <cedricshock> class Arrow a where
16:59:22 <cedricshock>   arr :: (b -> c) -> a b c
16:59:22 <cedricshock>     -- Each function may be treated as a computation.
17:00:41 <cedricshock> Then it reads a type a is a member of the class Arrow if the method arr is defined for a, where arr maps (functions from type b to type c) to type a with parameter types b and c?
17:01:25 <TheHunter> Right
17:01:55 <jameson> Well, it also needs to be explicitly declared to be of that class.
17:03:08 <cedricshock> How is it not-ambiguous? arr is a function that takes a (function from type b to type c). How can it distinguish between two types x, and y, that both match the description of an arrow for types b and c?
17:04:10 <cedricshock> The next part of the arrow deffinition makes more sense:
17:04:19 <cedricshock> (>>>) :: a b c -> a c d -> a b d
17:04:19 <cedricshock>     -- Computations may be composed, by connecting the output of the first to the input of the second.
17:05:25 <cedricshock> This means >>> is a function from (functions from (arrows from b to c) to (arrows from c to d)) to arrows from b to d. 
17:05:51 <cedricshock> In other words >>> is a function that will serve to compose arrows.
17:06:01 <cedricshock> right?
17:07:23 <cedricshock> And finally we have:
17:07:25 <cedricshock> first :: a b c -> a (b,d) (c,d)
17:08:39 <cedricshock> Where first takes an arrow from b to c, and makes an arrow from (b,d) to (c,d)?
17:09:02 <stepcut> yes 
17:09:36 <cedricshock> So this whole class definition is going to let us do what? Make generic code that works with arrows, regardless of the specific type of arrow?
17:09:47 <stepcut> yes..
17:11:05 <stepcut> i don't understand your question about arr being ambiguous...
17:11:39 <cedricshock> But it won't let us put together arrows of different types? Like if x matches the class arrow, and y matches the class arrow, and we have an arrow of types x b c and another of types y c d we won't be able to compose them together? 
17:12:01 <stepcut> nope
17:12:02 <jameson> cedricshock: Yes. They have to be the same arrows.
17:12:32 <cedricshock> jameson: So type x must be the same as type y?
17:12:34 <stepcut> by nope, I mean correct :)
17:12:49 <jameson> Ah... so 'yes' and 'nope' meant the same things here. ;-)
17:12:59 <stepcut> :p
17:13:02 <jameson> cedricshock: Yes.
17:13:38 <jameson> Wrt ambiguity: Do you mean that "arr f" for some f: A -> B, doesn't tell you which arrow we're going to use?
17:13:47 <Cale> arrow composition is strictly of the form a b c -> a c d -> a b d
17:13:50 <cedricshock> So here's the ambiguity I mentioned earlier. If I do arr(f) where f is of type (b-d) ... yes
17:14:35 <Cale> cedricshock: then the result will have type forall a. a A B 
17:14:46 <jameson> The inferred type should be '(Arrow a) => a A B'
17:14:52 <Cale> er
17:14:58 <Cale> yes, (Arrow a)
17:15:31 <aFlag> how can i get the second value on a list?
17:15:44 <jameson> IIRC, just as with monads, you'll have to explicitly give the type of the arrow you want to use somewhere, or use something else that gives away the type (thought type inference.)
17:15:51 <Cale> [0,1,2,3,4] !! 1 == 1
17:16:01 <stepcut> aFlag: many ways... depends on how sure you are that there IS a second value
17:16:19 <Cale> head $ tail $ xs
17:16:25 <Cale> is another way
17:16:30 <cedricshock> jameson: so how does it infer a? If both x and y are instances of the class Arrow, and I do arr(f) where f is (b->c) how do I know if I'll get an "x b c" or a "y b c"?
17:16:50 <aFlag> i actually needed a way to get an arbritary value
17:16:59 <Cale> aFlag: then you want !!
17:17:13 <Cale> xs !! n  is the nth element of xs
17:17:33 <aFlag> oh, i didn't realise that you said that to me :P
17:17:56 <Cale> cedricshock: you'll get a more generic thing
17:18:17 <stepcut> @eval let second (_:s:_)  = s in second [1,2,3,4]
17:18:18 <lambdabot> (line 1, column 21):
17:18:18 <lambdabot> unexpected "="
17:18:18 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
17:18:18 <lambdabot>  "(", operator, simple term or end of input
17:18:19 <Cale> which will only be made concrete when it's finally used in a particular context
17:18:23 <stepcut> doh!
17:18:49 <jameson> cedricshock: Initially, the type system will leave this open. If you place further restrictions on it, it may be neccessary to fix the type of the arrow type.
17:18:59 <cedricshock> cale: will it be a thing that will work as either an x or a y when I use it, and lazy evaluation would pick the type?
17:19:11 <Cale> The type inference will pick the type
17:19:20 <Cale> the evaluation won't have anything to do with it
17:19:30 <jameson> cedricshock: Lazy evaluation does not affect type inference, except for strictness annotations (correct me if I'm wrong, please!)
17:19:32 <Cale> consider:
17:19:41 <Cale> id :: forall a. a -> a
17:19:44 <Cale> id x = x
17:19:51 <cedricshock> So i couldn't use it later as both an x and a y?
17:20:04 <jameson> cedricshock: Yes, you could-- if it's left open.
17:20:05 <Cale> You could use it later as both.
17:20:21 <Cale> This is called let polymorphism.
17:20:33 <jameson> You could, of course, explicitly provide a type annotation to override that.
17:21:07 <cedricshock> So its some sort of generic arrow, that then fixates itself once per use to match the infered type.
17:21:13 <Cale> right
17:21:37 <cedricshock> ok. I like that.
17:22:01 <cedricshock> So is there ever a reason that more than one type of arrow should exist?
17:22:03 <Cale> It's a method for constructing an arrow-value without necessarily knowing the arrow-type.
17:22:09 <Cale> cedricshock: certainly
17:22:33 <Cale> That's where all the meat of what you're actually getting done lies.
17:23:02 <Cale> That is, the whole kind of computations you're performing.
17:23:15 <cedricshock> I thought all the meat would lie in the function from b->c that we built the arrow out of.
17:23:23 <Cale> And of course, sometimes when you use arrows, they won't receive such general types.
17:23:30 <cedricshock> Oh I get it.
17:24:06 <cedricshock> Nevermind. No I don't.
17:24:08 <Cale> well, it's partly in the functions you're lifting in
17:24:21 <Cale> and partly in the definition of the arrow primitives
17:24:35 <Cale> (arr being just one of these)
17:25:00 <Cale> those primitives might do different things depending on the type of arrow you have.
17:25:05 <cedricshock> So what sort of arrow would I build, other than one that just applies functions in some long daisy chain?
17:25:31 <Cale> well, for one, every monad is also an arrow.
17:26:19 <Cale> also, you can model automata, stream transformers, and a bunch of other stuff.
17:27:14 <Cale> there's arrows for doing parsing as well
17:28:37 <Cale> arrows which model circuitry
17:28:48 <cedricshock> So I need to master monads?
17:28:58 <Cale> I think monads would be a good first step.
17:29:17 <stepcut> monads are significantly more common than arrows anyway
17:29:25 <Cale> I don't really even know how to use arrows (might have something to do with the fact that I've never used one)
17:29:45 <cedricshock> Ok. Let's look at the monad defintion:
17:29:46 <cedricshock> class Monad m where
17:29:46 <cedricshock>     (>>=)  :: m a -> (a -> m b) -> m b
17:29:46 <cedricshock>     return :: a -> m a
17:29:53 <jameson> cedricshock: Not sure. I've found monads to be more easy to understand and apply, but that might be just the tininess of my brain.
17:29:55 <Cale> yeah, that's the gist of it.
17:30:08 <cedricshock> And I'll try to explain it.
17:30:27 <Cale> cedricshock: how much math do you know?
17:30:39 <cedricshock> a type m is a monad if it has a method >>= ...
17:30:48 <cedricshock> cale: I'm a pure math major, I think.
17:30:55 <Cale> It's not really a type, but a type constructor.
17:31:17 <Cale> m is intended to be what you'd call a functor in category theory.
17:31:29 <jameson> 'm' is. 'Monad' is a typeclass of unary type constructors.
17:31:56 <Cale> m itself is not a type.
17:32:05 <Cale> 'm a' is a type
17:32:10 <cedricshock> Ok it has a method >>= (this neads an english name, what should we call it?)
17:32:14 <Cale> bind
17:32:17 <cedricshock> Is -> right associative?
17:32:26 <Cale> yes
17:33:23 <cedricshock> So bind if a function from (monads of type a) to (functions from (function from a to monads of type b) to monads of type b)?
17:33:45 <Cale> well, the monad is the whole structure
17:34:00 <Cale> so it's a bit awkward to say "from (monads of type a)
17:34:01 <Cale> "
17:34:18 <Cale> but, yeah
17:34:29 <Cale> if the monad is lists,
17:34:36 <Cale> then it would be lists of type a
17:35:08 <Riastradh> >>= is also sometimes known as extend, by the way.
17:35:10 <cedricshock> A functor is a structure preserving map between categories, how does the type fitthat role?
17:35:34 <Riastradh> (It extends a monadic computation with a function.)
17:36:40 <Cale> cedricshock: suppose that a is an object in the category of types. Then m a is another object in the category of types, and every function f: a -> a can be lifted to a function m f: m a -> m a
17:36:49 <Cale> in such a way that composition is preserved
17:37:07 <Cale> m f is not Haskell notation here :)
17:38:04 <Cale> (In the context of lists, this is "map")
17:38:15 <Cale> (the lifting bit)
17:38:29 <cedricshock> cool. I get that.
17:39:34 <aFlag> hum... i suppose i don't know enough to do what i want yet :(
17:40:10 <Cale> Now if we stare at the type of >>= ...
17:40:21 <Cale> m a -> (a -> m b) -> m b
17:40:45 <Cale> I think that an example is very instructive here - particularly the list example.
17:40:54 <Cale> Bind there has type:
17:40:54 <cedricshock> Ok
17:41:02 <Cale> [a] -> (a -> [b]) -> [b]
17:41:31 <Cale> it takes a list of a's, and a function from a's to lists of b's, and produces a new list of b's.
17:41:40 <Cale> Can you guess what it might do?
17:41:57 <cedricshock> Yeah. m is the type of monad, which then has some paramter type i was calling of type earlier. Way to confuse myself.
17:42:31 <cedricshock> Nopw
17:42:51 <cedricshock> I could guess what a function [a] -> (a -> b) -> [b] would do.
17:43:21 <Cale> For the list monad, the most natural thing is to apply the function a -> [b] to each of the elements of the list of a's, and then concatenate the lists that you get as a result.
17:43:24 <clausen> how many such functinos are there?
17:43:50 <clausen> (how many functions are there that are [a] -> (a -> b) -> [b] ?)
17:43:51 <cedricshock> I see, that gives us slightly more expressive power.
17:43:56 <Cale> this is in fact, what it is defined to do in Haskell.
17:44:00 <cedricshock> [b] could be bigger or smaller than [a]
17:44:08 <Cale> cedricshock: indeed
17:44:14 <Cale> well, the value of that type
17:44:22 <cedricshock> In mine [b] would need to be exactly the same size as [a]
17:44:27 <Cale> clausen: not a whole lot.
17:44:48 <clausen> I think there are countably many
17:45:06 <clausen> you can permute the list arbitrarily
17:45:36 <jameson> And you can choose not to terminate or cut off after an arbitrary number of returned elements.
17:45:43 <clausen> agreed
17:46:03 <clausen> perhaps a more interesting question is: how many functions are there that are a -> (a -> b) -> b
17:46:08 <Cale> cedricshock: so that's bind in just one case
17:46:14 <clausen> I think there is only one
17:46:25 <jameson> Two (nontermination)
17:46:34 <jameson> (bottom, I mean)
17:46:36 <clausen> jameson: ah, right :)
17:46:49 <Cale> Yeah, if you allow for bottom. :)
17:47:38 <Cale> cedricshock: so how about return?
17:47:55 <Cale> return :: a -> m a
17:48:40 <cedricshock> For a list I'd define:
17:48:47 <cedricshock> return a = [a]
17:48:50 <Cale> right
17:49:12 <Cale> that's the most natural thing to do
17:49:19 <cedricshock> It builds a monad, so why do we call it return?
17:49:50 <Cale> (return x) is the monadic computation which always returns x.
17:49:57 <cedricshock> And like the arrow exampole before it will pick up a specific type of monad later from inference.
17:50:46 <Cale> right, if "return" gets used without enough context to fix a particular monad, then it will be used generally.
17:51:02 <Cale> (similarly with bind)
17:52:31 <Cale> Perhaps we should tackle some other examples.
17:52:32 <cedricshock> So monads are going to pop up all over the place, such as for folding, etc?
17:53:19 <Cale> Well, folding is a different sort of generalisation, I think.
17:53:33 <Cale> but monads do pop up all over the place
17:53:45 <Cale> Saying that something is a monad doesn't say much about it.
17:53:55 <cedricshock> I have an example of a Maybe monad, but I don't understand the syntax used to describe it:
17:54:05 <cedricshock> instance Monad Maybe where
17:54:05 <cedricshock>     Nothing  >>= f = Nothing
17:54:05 <cedricshock>     (Just x) >>= f = f x
17:54:05 <cedricshock>     return         = Just
17:54:11 <Cale> okay
17:54:21 <Cale> data Maybe a = Nothing | Just a
17:54:55 <cedricshock> Yeah. What's the word data doing?
17:54:56 <Cale> that is, a value of type Maybe a, is either the value "Nothing", or "Just x" where x is of type a
17:55:41 <Cale> Maybe represents simple failure to present a value.
17:55:53 <cedricshock> Yeah
17:55:58 <Cale> A function of type a -> Maybe b, is a partial function from a's to b's.
17:56:37 <cedricshock> ok
17:57:35 <cedricshock> So how do I read the 2nd and third lines?
17:58:31 <Cale> Okay, so they tell us how to take a Maybe value, and a function from ordinary values to Maybe values, and get a new Maybe value.
17:58:36 <cedricshock> They don't seen to define >>=, but instead define Nothing and (Just x)
17:59:05 <Cale> They in fact are defining >>=  -- but you're right, they're very natural.
17:59:33 <Cale> The first line says "if we put nothing in, then we get nothing out"
17:59:49 <jameson> cedricshock: They're using infix notation for (>>=).
17:59:49 <cedricshock> How does it say that?
17:59:56 <jameson> Alternatively, you coul read it as
18:00:03 <jameson>    (>>=) Nothing f = Nothing
18:00:19 <Cale> >>= is an operator
18:00:21 <jameson>     (>>=) (Just x) f = f x
18:00:32 <jameson> s/read/write/
18:00:36 <Cale> (not in the mathematical sense, in the syntactical sense)
18:01:08 <Cale> You can also write (+) 3 5
18:01:21 <Cale> to mean 8 :)
18:01:28 <cedricshock> But >>= only take one argument, so it must reaturn some sort of function that will then act on f.
18:01:40 <Cale> >>= takes two arguments
18:01:54 <Cale> or one, and returns a function, of you like
18:01:58 <Cale> if*
18:02:15 <Cale> but it's easier to think of it as taking two arguments here
18:02:38 <cedricshock> (>>=) is a function from something of type m a to all that other garbeldy gook
18:03:05 <Cale> cedricshock: The set of functions A x B -> C is isomorphic to the set of functions A -> (B -> C)
18:04:15 <cedricshock> I write a function A -> B -> C -> D, is that the only way to write a function from A X B X C -> D?
18:04:34 <Cale> no, but it's the best one in Haskell
18:04:46 <Cale> You could also write one (A,B,C) -> D
18:05:01 <Cale> (which is equivalent to A x B x C -> D)
18:05:10 <Cale> but it's just less convenient.
18:05:14 <cedricshock> So if I'm going to write them that way I'm probably going to think about them that way.
18:05:38 <Cale> Well, sometimes that just makes things harder for no good reason.
18:05:56 <cedricshock> So we could write (>>=) :: (m a, (a -> m b)) -> m b?
18:06:14 <Cale> Talking about + without thinking about both its arguments is a bit unnatural, for instance.
18:06:23 <Cale> sure
18:06:39 <desrt> cedricshock; if you curry it...
18:06:44 <Cale> it would be merely a bit less convenient to use
18:07:22 <cedricshock> plus(3) returns a function f(x) = x + 3, and then you'd write plus 3 7 or whatever
18:07:49 <cedricshock> deasrt: what does curry mean?
18:08:13 <Cale> cedricshock: curry :: ((a,b) -> c) -> (a -> b -> c)
18:08:30 <Cale> uncurry :: (a -> b -> c) -> ((a,b) -> c)
18:08:36 <desrt> cale; http://freshmeat.net/screenshots/41350/
18:08:44 <cedricshock> Ok, so those functions are not equivalent
18:08:54 <desrt> cale; not sure if it's useful to you
18:09:16 <desrt> cale; you may want to at least steal its units database :)
18:09:45 <Cale> Hehe - well, I'm sure we could implement all those units now.
18:10:06 <Cale> My code is very general, and doesn't assume any particular set of base units.
18:10:46 <desrt> ah
18:11:21 <Cale> cedricshock: right - functions of type (a,b) -> c are not functions of type a -> b -> c, but it's easy to make the natural conversion.
18:11:59 <cedricshock> Cale: you're doing stuff with units? Ever played with something called "dimensional analysis"? It's pretty cool (and also a pretty good way to arive at answers that look right and are quite wrong)
18:12:07 <cedricshock> ok
18:12:33 <Cale> cedricshock: that's basically what I was doing, playing around with the Abelian group of units.
18:13:09 <desrt> heh
18:13:13 <desrt> units really would be a group, too
18:13:29 <desrt> with multiplication
18:13:41 <cedricshock> It's the abelian group of symbols under multiplication.
18:14:01 <desrt> well
18:14:05 <Cale> I wrote some Haskell code which takes a syntax tree and some of the information on units, and generates constraints on the units of other things in the tree and then attempts to solve that system of constraints (this is just linear algebra)
18:14:06 <desrt> symbols plus complex symbols
18:14:32 <Cale> It's Z^n for some n.
18:14:55 <Cale> or Z^infty if you want that kind of freedom.
18:15:33 <desrt> wow
18:15:41 <desrt> pine just faithfully notified me that i've received spam
18:15:44 <desrt> ... yay
18:16:05 <Cale> so cedricshock, anyway, getting back to bind on Maybe
18:16:08 <ayrnieu> it said "you have received spam" ?
18:16:17 <cedricshock> ok
18:16:30 <Cale> Nothing >>= f = Nothing
18:16:34 <desrt> ayrnieu; no.  but it took me to my spam folder, beeped, and displayed the index with the new message in it
18:17:00 <desrt> you can't do this
18:17:05 <desrt> Nothing doesn't have a monad type
18:17:12 <Cale> yes it does
18:17:16 <Cale> Maybe is a monad.
18:17:22 <desrt> you're obviously insane
18:17:27 <desrt> what?!
18:17:30 <cedricshock> Nothing is a Maybe?
18:17:37 <Cale> instance Monad Maybe where
18:17:37 <Cale>     return         = Just
18:17:37 <Cale>     fail           = Nothing
18:17:37 <Cale>     Nothing  >>= f = Nothing
18:17:37 <Cale>     (Just x) >>= f = f x
18:17:39 <desrt> Maybes are Nothings and Justs
18:17:51 <desrt> woh
18:18:09 <Cale> It describes computations which might fail to produce a value.
18:18:11 <desrt> it's like faking strict
18:18:36 <Cale> Not really, it's still lazy.
18:18:47 <Cale> It's faking partial functions.
18:18:51 <Cale> :)
18:19:04 <Cale> and composition thereof
18:19:04 <desrt> i could use this in my allocator
18:19:12 <ayrnieu> er, could I please see an example use of that monad?
18:19:18 <Cale> sure
18:19:29 <cedricshock> -- we can use monadic operations to build complicated sequences
18:19:29 <cedricshock> maternalGrandfather :: Sheep -> Maybe Sheep
18:19:29 <cedricshock> maternalGrandfather s = (return s) >>= mother >>= father
18:19:29 <cedricshock> fathersMaternalGrandmother :: Sheep -> Maybe Sheep
18:19:30 <cedricshock> fathersMaternalGrandmother s = (return s) >>= father >>= mother >>= mother 
18:19:32 <desrt> i have 2 cases that would benifit from it
18:19:45 <Cale> http://www.nomaware.com/monads/html/maybemonad.html -- there's a practical example there at the bottom
18:19:47 <desrt> (1) assigning to an unused value (remember, backwards)
18:19:51 <desrt> (2) running out of registers
18:20:15 <desrt> in the code we're writing...
18:20:21 <desrt> assigning to an unused value won't ever be done
18:20:34 <desrt> so it's probably better to produce an error that to optimise it out of existance
18:20:40 <desrt> because it's almost definitely a mistake
18:20:47 <cedricshock> So nothing bound to a function f is still nothing
18:20:51 <Cale> right
18:21:14 <Cale> and Just x bound to a function f :: a -> Maybe b, apples f to x
18:21:17 <Cale> applies*
18:21:20 <cedricshock> And Just x bound to a function is f x. Why do we want that?
18:21:40 <desrt> cedricshock; so that your function doesn't have to deal with Maybes
18:21:49 <ayrnieu> wee, thank you.
18:21:51 <Cale> well, if we pass some actual value to a partial function, the result is the result of that function
18:21:53 <desrt> ie: otherwise you'd have to fromJust your argument
18:22:13 <Cale> (i.e. failure will only happen if f fails)
18:22:37 <desrt> Cale; btw.  i picked out a stereo system for the oplab.  do i talk to anand about getting the money for that?
18:22:45 <Cale> desrt: that's too practical an explanation here :)
18:22:46 <Cale> heh
18:22:57 <Cale> desrt: nice
18:23:06 <Cale> You can talk to him.
18:23:09 <desrt> :)
18:23:22 <desrt> i want you to aprove it
18:23:23 <desrt> :)
18:23:42 <Cale> Well, we should ask the other people that work there.
18:23:58 <desrt> (sanity check: you're not being serious, right?)
18:24:04 <Cale> heh
18:24:09 <Cale> You decide.
18:24:13 <desrt> :)
18:24:29 * desrt plays the tori amos
18:24:49 <cedricshock> So monad's could be useful in building something like a symbol manipulation system?
18:25:00 <Cale> cedricshock: possibly, sure
18:25:01 <cedricshock> Sorry, monads
18:25:07 <desrt> cedricshock; monads are basically required for everything :)
18:25:47 <Cale> well, monads model computation, so you're using a monad whenever you use any programming language. It's all about whether you think about it that way.
18:25:50 <desrt> i shouldn't say required because there's always a way to rework a program to use something other than monads
18:26:12 <Cale> Haskell has some constructs to help you think about it that way.
18:26:14 <desrt> ok.  call them Monads, then :)
18:26:23 * ayrnieu decides, somewhat late, that knowing how to do IO in Haskell does not make him an expert on monads.
18:26:51 <Cale> ayrnieu: it goes a long way though
18:27:00 <desrt> ayrnieu; being a type god makes you an expert on monads :)
18:27:10 <desrt> ayrnieu :: typegod
18:28:00 * cedricshock decided (a while ago) that being the first google result on a subject doesn't make him an expert on that subject
18:28:30 * desrt googles chicken porn
18:28:50 * desrt sees cedric, but it's okay, because he's not really an expert :)
18:29:45 <cedricshock> Ok. I guess I can ask the question I tried to ask last night again.
18:30:34 <cedricshock> My eternal project is building some sort of sick hybrid between a spreadsheet and a database.
18:30:36 <Cale> Basically a monad is two things: 1) A way to structure data. 2) A way to combine computations producing structures of that sort from plain values.
18:31:13 <Cale> cedricshock: are you sure this isn't Haskell?
18:31:15 <ayrnieu> cedric - always good to have an eternal project =)
18:31:18 <Cale> hehehe
18:31:47 <cedricshock> I'm looking for the programming language that is already most like what I'm writing.
18:32:00 <Cale> :)
18:32:04 <ayrnieu> cedric - K, I suppose.
18:32:08 <Cale> Also, did you check out vital?
18:32:31 <desrt> cedricshock; we have a summer student at our school that might be doing something related to your project
18:32:34 <cedricshock> I looked at Vital. Vital is written in Java. I'm a bit cinfused there.
18:32:37 <Cale> It's a stripped down version of Haskell with a funny gui on it. :)
18:32:51 <Cale> Vital is Haskell implemented in Java.
18:33:03 <Cale> well, Haskel minus a bunch of features.
18:33:07 <Cale> Haskell*
18:33:27 <cedricshock> That's what I thought. I can't imagine wanting to implement a language in some other language, when it should be far easier to do in the language itself.
18:33:36 <Cale> :)
18:33:45 <Cale> Well, ghc is written in Haskell.
18:33:57 <Cale> hugs is written in C
18:34:02 <ayrnieu> People like to implement nifty programming languages in Java so that I can't use them.
18:34:17 <desrt> ayrnieu; what's your excuse for not using java?
18:34:23 <Cale> ayrnieu: are you on some crazy platform?
18:35:10 <cedricshock> So the question was, how can I take a runtime function definition from a user, and turn it into a function used in my happy little data program.
18:35:11 <ayrnieu> yes.  OpenBSD, 128M RAM, 300Mhz CPU.
18:35:21 <desrt> ayrnieu; gcj runs on openbsd
18:35:47 <ayrnieu> desrt - and so does Kaffe, or a Linux JVM with emulation.
18:35:59 <desrt> gcj isn't a JVM
18:36:05 <Cale> cedricshock: so have you written a compiler before?
18:36:12 <cedricshock> Nope.
18:36:14 <Cale> It's a good exercise.
18:36:41 <clausen> Cale: you know anything about crypto?
18:36:55 <Cale> Pick a very very simple language, and a very simple architecture, and write a compiler.
18:37:07 <Cale> clausen: Not a whole lot.
18:37:15 <desrt> clausen; your question?
18:37:18 <clausen> I agree... compilers are good excercise
18:37:28 <cedricshock> clausen: no more than rsa, a couple other little things
18:37:31 <clausen> my first non-trivial (>200 lines) program was a compiler :)
18:37:53 <clausen> I'm currently reading up on "secure computation"
18:38:09 <clausen> I've been thinking about the dating problem (I made this up, but has probably been studied already...)
18:38:24 <clausen> suppose you have a room full of teenagers
18:38:27 <cedricshock> So why should I write a compiler. I'm looking for a language where I won't need to do that sort of thing.
18:38:28 <Cale> Many of the people in math (and all of the people in CS) which go to Waterloo write a compiler in 2nd year.
18:38:43 <Cale> cedricshock: well, that's what you want to do in the end, right?
18:38:57 <Cale> So you might as well do a simple one.
18:39:10 <clausen> ... who all have crushes on each other.  How can they communicate their crushes, but only have the crush revealed if it is requited?  i.e. all-or-nothing
18:39:33 <clausen> cedricshock: writing a compiler helps you understand how "everything fits together"
18:39:35 <desrt> clausen; not solveable
18:39:40 <cedricshock> clausen: they can't
18:39:43 <clausen> desrt: can you prove it?
18:39:52 <desrt> clausen; i pretend to like you
18:39:57 <desrt> clausen; and i can find out if you like me
18:40:00 <cedricshock> I can always find out if Jenny has a crush on me, by saying I have a crush on Jenny
18:40:13 <clausen> desrt: but, if you pretend, you just signed a note...
18:40:16 <desrt> it's only possible if you require commiting the crush
18:40:20 <desrt> ah
18:40:22 <clausen> desrt: right
18:40:25 <Cale> clausen: are you allowed to lie?
18:40:26 <clausen> suppose you commit the crush :)
18:40:38 <clausen> Cale: you can lie, but it will cost you
18:40:46 <cedricshock> Then some sort of trap door algorithm will work
18:40:57 <clausen> (suppose you commit to paying for a holiday to a pacific island...)
18:41:12 <clausen> cedricshock: I think it STILL might be unsolvable
18:41:22 <desrt> i think i might have a solution
18:41:41 <cedricshock> Write down "Girl's Name and Guy's Name"
18:41:58 <cedricshock> hash it with a very very strong hash, so that chance of collision is low
18:42:14 <Cale> Make a machine where everyone records their crush, and it only reveals matches.
18:42:20 <desrt> Cale; lame
18:42:27 <clausen> Cale: I want this to be decentralized
18:42:29 <Cale> sure, but what do you want?
18:42:30 <desrt> the problem isn't even vaguely interesting if you have an authority
18:42:34 <Cale> heh
18:42:36 <clausen> Cale: no trusted third parties
18:43:01 <cedricshock> Never mind then, my hashs algo go to the authority. Otherwise someone would be able to probe it.
18:43:15 <desrt> you need to be able to ask people something
18:43:22 <desrt> because there has to be communication
18:43:29 <desrt> but communication doesn't have to imply crushes
18:43:34 <desrt> ie: you have to have people faking it
18:43:34 <clausen> right
18:43:43 <desrt> in order to throw off other people
18:45:25 <cedricshock> Then I think it can't be done.
18:45:33 <desrt> i think it can
18:45:46 <cedricshock> Then I think I can break it. Shoot.
18:45:53 <desrt> i didn't say i know how
18:46:40 <cedricshock> There are two messages, M and M'. How do you make it so you can only recieve the other if you (and only you) have first broadcast the first?
18:47:04 <clausen> cedricshock: I've thought about this paradox
18:47:17 <clausen> perhaps you swap one bit at a time of M
18:47:21 <clausen> and prove that each bit is correct
18:47:27 <desrt> lame
18:47:30 <clausen> as you get closer to the end
18:47:31 <desrt> then it turns into a probability game
18:47:39 <cedricshock> And how do you keep Sam from saying "I'm Bob and I have a crush on Sally"?
18:47:45 <clausen> the cost of brute-forcing goes down
18:47:58 <clausen> cedricshock: you can agree on public keys before hand
18:48:05 <clausen> desrt: why is probability lame?
18:48:14 <cedricshock> So we have a key authority?
18:48:27 <clausen> cedricshock: they could meet face-to-face
18:48:48 <desrt> it's safe to assume all communications are
18:48:53 <desrt>   (1) authenticated
18:48:54 <cedricshock> Ok. Lets make it simpler
18:48:55 <desrt>   (2) in private
18:49:02 <desrt>   (3) possible to reproduce with proof
18:49:03 <cedricshock> We have two people: Sally and Bob
18:49:21 <cedricshock> Or better, Alice and Bob
18:49:31 <desrt> why alice?
18:49:31 <desrt> :)
18:49:38 <clausen> (wouldn't it be cool to have a crypto paper where Alice has a crush on Bob!)
18:49:41 <ayrnieu> Alice, Bob, and Eve.
18:49:55 <cedricshock> How can they communicate to each other that they like each other iff they both like each other
18:50:06 <cedricshock> Because then they are A and B
18:50:16 <cedricshock> We could use Yancy and Zelda.
18:51:31 <cedricshock> It is possible, if we can force them to commmunicate simultaneously.
18:51:41 <cedricshock> Nope that doesn;t work. Never mind.
18:52:30 <desrt> wait.  i have a solution, i think
18:52:30 <cedricshock> You need some operator where 0 * 1 = 0, 0 * 0 is 0, 1 * 0 is 0, and 1 * 1 is 1
18:52:45 <cedricshock> I think it's called and
18:52:45 <Cale> this is AND
18:52:59 <Cale> or *
18:53:11 <cedricshock> So we need some communication method that is AND or multiplication
18:53:40 <ayrnieu> cedric - you also need to reformulate the problem so that it only considers assertions, such as "I like Bob".
18:54:14 <ayrnieu> "iff they both like each other" may otherwise confuse you =)
18:54:58 <clausen> http://citeseer.ist.psu.edu/feige94minimal.html
18:55:04 <ayrnieu> If Alice has 26 classmates, she can discover who likes her by asserting seperately that she likes 25 people... who then cannot reliably discover that Alice likes them.
18:55:13 <clausen> I think this paper claims the problem is unsolvable
18:55:26 <Cale> hey, couldn't you just have them communicate with an and gate and a light bulb? :)
18:55:26 <desrt> ok
18:55:28 <cedricshock> We already have established some degree of trust. All they need to do is reveal their answer at the same time in some multiplicitive system.
18:55:29 <desrt> i have a really lame solution
18:55:33 <desrt> but it's a solution
18:55:55 <desrt> alice hands bob 2 envelopes
18:56:07 <desrt> (this only works when the participants are physically close)
18:56:30 <desrt> she says to bob "open the first envelope if you have a crush on me, else the other"
18:56:34 <ayrnieu> "Do you like me?  YES NO"
18:56:37 <desrt> bob goes somewhere private
18:56:43 <desrt> like behind a screen
18:56:51 <ayrnieu> and then opens both envelopes.
18:57:06 <Cale> heh
18:57:07 <desrt> alice has the first envelope (the "i love you") set to make a loud noise when bob opens it if she loves him
18:57:19 <ayrnieu> and then laughs at Alice until she developes Social Anxiety Disorder.
18:57:21 <desrt> ie: they both know they love each other
18:57:41 <desrt> if she doesn't love bob and bob opens "i love you" nothing happens
18:57:46 <clausen> desrt: couldn't bob alarm both envelopes?
18:57:47 <ayrnieu> desrt - no, Alice knows that Bob opened the first envelope first.
18:57:47 <desrt> if she loves bob and bob opens "i don't love you" then nothing happens
18:57:56 <desrt> no.
18:58:10 <desrt> bob must come out from behind the screen with 1 envelope in hand
18:58:17 <desrt> that is prompty shredded
18:58:34 <desrt> if bob cheats then he can find out
18:58:40 <desrt> but cheating is immediately found out
18:58:48 <desrt> and bob is punished :)
18:59:12 <desrt> also: if bob opens both and alice likes bob
18:59:17 <desrt> then bob has commited to liking aliec
18:59:19 <ayrnieu> You can only have a sensical system with a third party.
18:59:23 <desrt> because he's opened the "i like you" envelope
18:59:40 <desrt> wait.
18:59:41 <cedricshock> So he oppens the I don't like you envelope first
18:59:43 <desrt> this is far too confusing
18:59:57 <desrt> alice hands bob 1 envolpe
19:00:03 <desrt> he opens it if he likes her
19:00:03 <Cale> I have a solution: Alice and Bob both get really drunk...
19:00:13 <desrt> it makes a sound when he opens it if alice likes him
19:00:14 <desrt> easy
19:00:26 <desrt> or he can choose to throw it away while behidn the screen
19:00:28 <clausen> Cale: that is the classical solution :)
19:00:34 <Cale> heh
19:00:43 <cedricshock> So it goes off only when alice and bob recipricate the liking.
19:00:51 <desrt> cedric; right
19:01:02 <desrt> if bob does not like alice, the envelope is never opened
19:01:07 <desrt> if alice does not like bob, it makes no noise
19:01:29 <cedricshock> The envelope just became the authority
19:01:40 <cedricshock> It could just as easily be a wheel: 0 0 1
19:01:47 <desrt> hmm
19:01:56 <desrt> the envelope sort of does represent an authority
19:01:59 <ayrnieu> desrt - your method would demand a third party to monitor the process, and it would also need much noise (e.g., it would have to demand that everyone in a community write up letters to everyone else -- and then a monitoring body to ensure that everyone writes consistent letters).
19:02:21 <cedricshock> Each gets to advance it one place or 0, starting at 0. You can't see the rest of the wheel. It only comes up one if they agree.
19:02:26 <desrt> ayrnieu; everyone would need to write letters to everyone else regardless
19:02:27 <ayrnieu> e.g., to avoid an Evilena asserting that she likes everyone.
19:02:54 <desrt> ayrnieu; to throw people off
19:03:09 <cedricshock> We avoided that by forcing them to buy tickets to the pacific islands if it comes up yes. We already introduced an authority to do that.
19:03:33 <Cale> ayrnieu: well, maybe Evilena does "like" everyone
19:03:53 <desrt> i assume we want a straight-up computation-and-communication system, then?
19:04:18 <ayrnieu> Cale - that she does at all disturbs this system.
19:04:22 <clausen> desrt: I think these digressions are interesting though
19:04:54 <Cale> ayrnieu: why?
19:05:34 <cedricshock> Here's another version: I am a member of a secret political society. How can I communicate to someone else that I am a member of the secret society, if and only if they are a member of the society, even if a member of the society gets abducted and tells everything?
19:06:14 <desrt> cedricshock; if a member gets abducted you'd require key redistribution
19:06:14 <cedricshock> Answer: I can't. The abducted member could always show up and do the thing. It takes an authority to get around that.
19:06:17 <desrt> cedricshock; is that ok?
19:06:39 <cedricshock> Nope. How would we know he got abducted / brainwashed / switched sides?
19:06:54 <desrt> if he switched sides you'd never know
19:07:10 <cedricshock> This problem requires a trusted third party.
19:07:14 <desrt> it's not the same as the dating problem, though
19:07:25 <cedricshock> If he switched sides he could just rat us all out ...
19:07:36 <desrt> unless you allow that doing the secret handshake is asserting your loyalty to the group
19:07:38 <monotonom> There are key sharing schemes that can stand a certain degree of betrayal.
19:07:43 <desrt> (ie: you haven't been bought)
19:07:52 <cedricshock> desrt: Which is allowing an authority
19:08:11 <desrt> cedricshock; you require some authority no matter what
19:08:23 <desrt> i mean... assume alice and bob do an exchange
19:08:29 <desrt> and they both say they like each other
19:08:31 <cedricshock> Exactly. That's because the problem requires an authority.
19:08:34 <desrt> then bob's like "sorry.. i was just lying"
19:08:39 <desrt> who's going to enforce them to date?
19:08:43 <desrt> it only works in a room full of people
19:08:52 <cedricshock> an authority
19:08:58 <Cale> hey, is it okay to reveal that you don't have a crush on someone?
19:08:59 <desrt> and the authority is public humilation in the case of the teenagers
19:09:04 <ayrnieu> secret political societies (e.g., terrorist groups) couldn't possibly survive if they relied on such a method.  Terrorist groups need terrorist cells, which structure relies on limited information.  If Adam doesn't know that Bob belongs to this organization, he has no business knowing.
19:09:48 <keverets> the authority would be the lack of dates when others learn that you lie about who you like.
19:09:52 <ayrnieu> desrt - in a room full of people with one person acting as "pseudomatchmaker".
19:10:03 <desrt> ayrnieu; too easy
19:10:05 <cedricshock> So we are trusting to public humiliation. So the answer is yes, if you allow an authority. Now how small can the authority be?
19:10:10 <keverets> just requires a "he lied" message to be sent to all of her friends.
19:10:24 <desrt> keverets; exactly
19:10:33 <desrt> humiliation
19:10:52 <desrt> or i like the idea of forcing the new couples to go on a cruise together :)
19:10:58 <keverets> humiliation isn't necessarily the right word... the liar might not be humiliated at all.
19:11:01 <desrt> (by law, or whatever)
19:11:04 <keverets> just known to be a liar.
19:11:20 <ayrnieu> just know to have lied in that context.
19:11:25 <keverets> this seems to be a poorly specified problem, regardless.
19:11:44 <ayrnieu> also, known.  Change the function to 'willing to go out on a date with' and you've more sense.
19:12:06 <desrt> keverets; what's the running time of the node placement algorithm in graphviz?
19:12:09 <desrt> (if you know)
19:12:38 <desrt> it seems to slow down quite rapidly
19:12:43 <keverets> don't know.  It's probably specified in one of their white papers.
19:13:12 <desrt> w3rd.
19:13:28 <desrt> heh.  that's ironic.
19:14:19 <desrt> <desrt> what's the complexity?
19:14:22 <desrt> *** np_hard joins
19:17:02 <np_hard> hilarious
19:17:04 <np_hard> :)
19:36:36 <desrt> Cale; remember how i was joking around about altivec's lack of an integer multiply instruction?  no joke.
19:37:00 <desrt> it can't do 32bit integer multiplications
19:37:44 <dons> the sparc specification doesn't require multiplication be done in hardware.
19:38:56 * desrt wants 32 bit integer FMA
19:39:30 <desrt> altivec comes close.  it can do (16bit*16bit) + 32bit = 32bit
19:40:01 <desrt> in one instruction
19:54:15 <cedricshock> I saw the graphviz placement algorithmic complexity somewhere in the docs the last time I used it. I'll go look for it.
20:00:35 <cedricshock> I think that the majority of the running time in dot for large graphs ends up being i/o. When I
20:01:13 <cedricshock> 've graphed the parse trees of even small functions, I've frequently gotten 10000 x 7000 pixel images, or something of the sort.
20:06:54 <cedricshock> "minimizing edge crossings in layouts of ranked graphs is NP complete", though it doesn't say what it's NP complete with respect to - I presume edges. (http://www.research.att.com/sw/tools/graphviz/TSE93.pdf) 
20:10:55 <cedricshock> Cale: So if I want to take someone's expression representing a haskell function, and turn it into a haskell function, I'd need to write my own compiler?
20:11:15 <Cale> hm?
20:11:30 <Cale> if it's already Haskell, there's no need to change it
20:11:56 <cedricshock> You suggested a few hours ago that I should write a compiler for my own personal edification.
20:12:33 <Cale> because you sounded like you wanted to design a database/functional language and write a compiler for it.
20:12:58 <cedricshock> So if I have a string like "\x = x + 3" (That's an anonymous function, right?), can I translate it into a working haskell function without writing my own compiler?
20:13:10 <Cale> sure - use ghc
20:13:12 <dons> \x -> x + 3
20:13:27 <cedricshock> Why would I want an impedence mismatch between the language of the spreadsheet, and the language the spreadsheet is implemented in?
20:13:44 <cedricshock> at run-time?
20:13:54 <desrt> i just wrote an email to chris
20:14:17 <desrt> and then i didn't send it
20:14:45 <desrt> it helped alot to think aloud, though
20:15:55 <Cale> "alot" -> "a lot"
20:16:11 <desrt> i know.  i was ashamed of myself slightly after pressing enter :(
20:16:52 <ayrnieu> I also experienced alittle annoyance.
20:17:21 <desrt> "alittle" -> "a little"
20:17:27 <desrt> cute.
20:17:41 <ayrnieu> desrt - nobody ever makes that mistake.
20:18:03 <desrt> ayrnieu; i have a counterexample in very recent history :)
20:18:13 <ayrnieu> cedric - in general, you do not use Haskell as the language of programs that you write in Haskell.
20:18:16 <ayrnieu> desrt - no, you don't =)
20:18:58 <desrt> heh
20:19:22 <desrt> you don't know that :)
20:19:55 <ayrnieu> cedric - for the same reason that you do not generally use C as the language of programs that you write in C.
20:20:03 <cedricshock> ayrnieu: yes, and in general a spreadsheet is totally useless and messy
20:20:17 <Cale> I don't understand the "alot" mistake. Nobody ever genuinely thinks "alittle" is a word.
20:20:47 <cedricshock> ayrineu: I don't use c as the language of programs I write in c because c doesn't support it, not because something else is better.
20:20:49 <desrt> Cale; it's something that self-reenforces
20:21:02 <desrt> people make the mistake a_lot because they see it a_lot
20:21:37 <Cale> cedricshock: Haskell doesn't come with a Haskell interpreter/compiler apart from the one which you would use to compile your program.
20:21:52 <Cale> You would still end up ripping code out of ghc.
20:21:56 <dons> ayrnieu: you can easily use Haskell as the scripting language of a Haskell program
20:22:02 <Cale> (or at least calling it)
20:22:05 <dons> guys, this is what hs-plugins is for.
20:22:21 <dons> you can embed a Haskell interpreter in your application
20:22:21 <ayrnieu> dons - no, you can't.
20:22:38 <dons> I've got two examples sitting on my hard drive ;)
20:22:59 <cedricshock> cale: I have never understood why anyone would want a programming language which produces programs which cannot use the programming language they were written in.
20:23:06 <dons> sure, it has been hard/impossible. but that is what hs-plugins is for.
20:23:22 <ayrnieu> dons - oh, good for hs-plugins =)
20:24:00 <Cale> cedricshock: you can do this with every programming language - it's just usually a lot of work.
20:24:29 <desrt> gcc is a rather solid example that it's possible to parse c with a c program :P
20:25:16 <cedricshock> Now the coup-de-gras, can hs-plugins or ghc, or whatever, compile a supplied tidbit of code so that it will run as fast (minus linking / whatever) as the code originaly distributed with the program?
20:25:34 <ayrnieu> desrt - also, a solid example of something besides the point.
20:26:12 <dons> hs-plugins compiles supplied haskell strings to object code, which runs exactly as fast as normal code compiled via ghc
20:26:22 <dons> it isn't interpreted, if that is what you mean
20:26:30 <cedricshock> Excellent!
20:26:33 <Cale> cedricshock: of course it can - it compiled the program in the first place
20:27:12 <desrt> hm
20:27:19 <cedricshock> Yeah, but the developer doesn't have the leagal permission to redistribute it and use it that way.
20:27:23 <desrt> if you have libraries in haskell you need to type the interface, right?
20:27:35 <cedricshock> dons, why does the page for hs-plugins have ~dons in the address?
20:27:48 <dons> cause that is me ;)
20:27:56 <Cale> cedricshock: Nobody uses non-free software, right?
20:27:59 <Cale> :)
20:28:24 * desrt tries to wrap his mind around the idea of people selling software
20:28:45 <Cale> heheh
20:29:11 <desrt> dah!  lambda calculus was way easier than this one...
20:29:18 <stepcut> desrt: for an encore, wrap your mind around people selling open source software
20:30:27 <desrt> stepcut; are you attacking my incorrect interpretation of the word "free" or questioning the business model of people who sell open source software? :)
20:30:59 * stepcut ponders what he meant
20:31:27 * desrt watches lazy evaluation in action
20:31:40 <stepcut> hehe
20:32:13 <stepcut> I believe I meant the business model of selling open source software (specifically selling open source software that other people wrote)
20:32:42 <desrt> ah.  in that case, it's because you're not selling software
20:32:53 <stepcut> :p
20:32:57 <desrt> you're selling a nice box, a shiny cd and a 1-800- number to call when it breaks
20:33:11 <ayrnieu> desrt - also, stickers.
20:33:18 <desrt> i love stickers
20:33:24 * desrt hands redhat his $$$
20:35:02 <cedricshock> How do you quit ghci?
20:35:17 <Cale> ctrl-d?
20:35:21 <stepcut> quit? why would you do that? That would be like quiting emacs...
20:35:26 <dons> :q
20:35:28 <cedricshock> Thanks
20:35:40 <cedricshock> dons: You're not in debian yet. You must not exist. Now where did that tarball end up...
20:35:57 <desrt> stepcut; i quite agree.  you'd be insane to quit emacs.
20:36:10 * stepcut looks forward to LIP (or whatever its called)
20:36:25 <cedricshock> desrt: But only because you'd be insane to start it.
20:36:28 <desrt> stepcut; i mean.. unless it was running on the computer when you sat down...
20:36:34 <desrt> cedricshock; exactly =)
20:36:39 <stepcut> i should figure try out that emacs-multi-tty thing
20:36:59 * desrt hands stepcut vi and screen
20:37:19 <stepcut> bah
20:37:32 <stepcut> what good is a text editor without an irc client ???
20:37:33 <desrt> emacs => escape meta alt control shift
20:37:40 <desrt> emacs => eighty megs and constantly swapping
20:38:35 <desrt> vi => very .... uh.....
20:39:01 <stepcut> very intuitive, of course
20:39:11 <desrt> yes.  quite :)
20:39:12 <lispy> you can't spell evil with out vi
20:39:37 <desrt> lispy; only because emacs segfaults after "evi"
20:39:42 <cedricshock> I thought vi was veritably infuriating
20:40:24 <lispy> desrt: you mean C-M-S-e C-v M-i ?
20:41:03 <desrt> lispy; i wouldn't know
20:41:19 <lispy> desrt: just making a joke about the key bindings
20:41:32 <lispy> it's like playing the piano sometimes
20:41:43 <desrt> lispy; indeed.  i never figured out how to get it to actually enter text
20:41:49 <desrt> got distracted by the irc client, i guess
20:41:52 <stepcut> besides, its quite useful to use a text editor with its own built-in shell
20:42:18 <lispy> yeah, emacs is a good os, and an okay text editor
20:42:45 <ayrnieu> color-theme-goldenrod also contributes to my personal wellbeing.
20:42:50 <bluejay> desrt: c'mon, emacs is much easier than vi if you just want to enter text. vi makes you hit "i" first.
20:43:30 <bluejay> however, doing anything with the text is another story
20:45:08 <desrt> mm.  one of my favourite things about vi is how you can have an entire session without vi actually starting
20:45:16 <desrt> not sure if emacs does that or not
20:45:35 <stepcut> desrt: sure does!
20:45:55 <cedricshock> dons: hs-plugins looks great for loading code and such. What's the simplest route from the string "\x -> x + 1" to having a usable function?
20:46:48 <desrt> cedricshock; that's easy
20:47:10 <desrt> f x | x == "\x -> x + 1" = (\x -> x + 1)
20:47:40 <Cale> desrt: haha
20:48:23 <dons> look at examples/hmake/simple. You'd have to tweak that code for your case.
20:49:04 <desrt> dons; got a url for this?
20:49:11 <dons> its in the tarball.
20:49:19 <desrt> in ghc?
20:49:19 <cedricshock> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:49:27 <desrt> that's the one :)
20:49:58 <dons> sorry, yeah. it's an external library to ghc
20:51:04 <dons> basically, you have to write "\x -> x+1" to a file, and call make() and load() on that. then you get back the Haskell value representing that code
20:52:46 <cedricshock> Did you use lower level functions somewhere that I could hijack eventually to skip the file step, like set up the compiler with the data already?
20:53:47 <dons> hmm.. look at the implementation. at some point you have to compile the code with ghc.
20:54:01 <dons> and I don't think ghc can read from stdin, say.
20:54:01 <cedricshock> oh
20:54:08 <Cale> Yeah, eventually it gets to ghc - you have the source to that.
20:54:16 <stepcut> dons: i think ghc can read from stdin these days
20:54:24 <dons> runghci ?
20:54:31 * stepcut ponders
20:54:53 <dons> perhaps ghc could read from a named pipe
20:55:02 <Cale> cale@zaphod[~]$ ghc -e "print $ map (+1) [1,2,3,4,5]"
20:55:02 <Cale> [2,3,4,5,6]
20:55:19 <dons> that's ghci you're calling
20:55:33 <dons> it is giving you a string back, not a Haskell value
20:55:39 <Cale> right
20:55:52 <stepcut> i think I was thinking of the ghci -e, actually
20:56:04 <dons> if all you want to do is eval code in the background, just system() ghci, like lambdabot does (I think)
20:57:18 <desrt> lambdabot isn't haskell
20:58:05 <Cale> lambdabot is written in haskell, but for @eval it just evaluates a simple functional language.
20:58:23 <cedricshock> So my best place to start would probably really be the source code to ghci?
20:58:28 <dons> ?
20:58:41 <Cale> (which is not Haskell)
20:58:56 <dons> I don't see why you need to look at ghci.
20:59:05 <stepcut> eval does not support 'let' !!!!
20:59:41 <stepcut> :(
21:00:43 <dons> cedricshock: why do you need to look at ghci?
21:26:54 * _SamB_ wants a type debugger
21:28:56 * _SamB_ finds the leak
21:50:41 * SamB forgets the syntax for declarations in th
22:37:08 <SamB> hmm, why do I run into trouble with:
22:37:13 <SamB> instance (GaloisField gf i) => Num gf where
22:37:48 <SamB> and
22:37:57 <SamB> class (Eq gf, Integral base, Bits base) =>
22:37:57 <SamB>        GaloisField gf base | gf -> base, base -> gf where
22:37:57 <SamB> ?
22:42:24 <Riastradh> It would help to describe the trouble into which you run.
22:46:34 <SamB> oh. well, when I turned on undecidable instances, it claimed there was an overlap...
22:47:13 <SamB>     Overlapping instance declarations:
22:47:13 <SamB>       FEC/GF.hs:44: Num gf
22:47:13 <SamB>       In module GHC.Num: Num Integer
22:49:15 * SamB gets what might be a good idea
22:50:17 * SamB doesn't think now is the time to radically change the typing of his code, though, so he saves it for after the weekend
23:57:28 <ozone> SamB: -fallow-overlapping-instances
