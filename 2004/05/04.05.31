00:36:35 <javaNewb> evnin
00:38:19 <javaNewb> is there a prelude function that given a String will return all entries without whitespaces?
00:39:59 <shrimpx> given a list of strings you mean?
00:40:34 <javaNewb> no just one long string
00:41:47 <cedricshock> Pseudonym: I found a fairly good description of monads and arrows. Hughes original paper on arrows is excellent, and quite clear.
00:41:58 <shrimpx> javaNewb: what's an "entry" then?
00:42:25 <javaNewb> a valid entry is one that is inputed without any spaces
00:43:06 <javaNewb> so "Name" is one and "A Name" is not one
00:44:03 <shrimpx> so you want something like (not . List.elem ' ')
00:44:41 <javaNewb> okay :) i'll look it up
00:46:30 <javaNewb> this is not in the prelude?
00:46:56 <shrimpx> not and elem should be...
00:48:16 <javaNewb> okay my bad found it
00:48:33 <javaNewb> List?
00:50:07 <shrimpx> heh. elem is in module List but it's also exported by the prelude...
00:52:25 <javaNewb> so not.elem ' ' lines x will return all the entries what don't contain white spaces?
00:53:46 <shrimpx> heh, so you do want to pass it a list of strings 
00:54:27 <javaNewb> oops
00:54:29 <javaNewb> sorrie
00:54:44 <javaNewb> haden't fully read the description
00:57:27 <shrimpx> so then you just need to use filter with the above function
00:58:33 <javaNewb> thought so, thanks
00:58:47 <javaNewb> :)
00:59:01 <javaNewb> i was trying takeWhile
01:00:15 <shrimpx> that will only grab stuff at the beginning of the list
01:02:11 <javaNewb> okay im trying filter (/= " ") lines x....and its the same as just doing lines x...
01:02:52 <shrimpx> that only filters out the string " "
01:03:24 <javaNewb> oh :O
01:03:43 <shrimpx> i think filter (not.elem ' ') is what you want =)
01:04:47 <javaNewb> ;) :)
01:06:55 <javaNewb> thankyou, oh i just got why not.elem works and /= " " doesn't
01:21:45 <javaNewb> why does [read x | x <- words "1,2,3"] work and [read x | x <- words " 1, 2, 3"] not work?
01:28:33 <Heffalump> wdym by "not work"?
01:29:03 <Heffalump> neither works for me in hugs
01:29:10 <Heffalump> is this part of a bigger program?
01:29:19 <Heffalump> (the only reason they fail is to do with type-checking
01:29:47 <javaNewb> yes thsi is part of a bigger program
01:30:05 <javaNewb> the read is used to parse "1" to 1
01:30:14 <Heffalump> when I give an explicit type signature I get Program error: Prelude.read: no parse
01:30:17 <Heffalump> from both
01:30:27 <javaNewb> i only get the error from the second case
01:30:32 * Heffalump tries ghci
01:30:50 <Heffalump> the answer is really that words isn't intended to separate things by commas
01:31:25 <Heffalump> you might find that read "[1, 2, 3]" does what you want
01:32:02 <Heffalump> in which case one possibility would be to use read ("["++str++"]") if str is the name of the "1, 2, 3" string
01:32:55 <javaNewb> ahh i c
01:34:09 <javaNewb> thanks, i was meant to be testing [read x | x <- words"1 2 3"] and [read x | x <- words" 1 2 3"]
01:34:23 <javaNewb> so read is like type casting in java?
01:35:19 <Heffalump> no, not really
01:35:31 <cbus> isnt that incorrect syntax?
01:35:32 <Heffalump> read :: Read a => String -> a
01:35:50 <Heffalump> read is a general purpose string reader
01:36:39 <cbus> javaNewb: should look something like read "[1,2,3]" :: [Int]
01:36:55 <Heffalump> no, what he said is fine, apart from the lack of space between words and "
01:37:53 <cbus> yeah
01:37:55 <javaNewb> oh, i getchya now ;)
01:37:57 <javaNewb> thanks again
01:38:09 <cbus> so he probobly should do a show "1 2 3" :)
01:39:13 <javaNewb> i cannot find isAlpha in any haskell directory
01:39:20 <javaNewb> is this a prelude function??
01:39:37 <Heffalump> umm, I think so
01:39:45 <Heffalump> it's in module Char
01:40:00 <Heffalump> so "import Char" at the top of your program just under the module ... line
01:40:21 * Heffalump disappears
01:40:28 <javaNewb> okay, where can i find a proper list of the haskell directories?
01:40:36 <javaNewb> i think the one i have is lacking somewhat
02:46:38 <ibid> javaNewb: "haskell directories"?  the standard modules are documented in the report, and ghc modules are documented in ghc docs
02:53:27 <javaNewb> the report....? i have whatever comes with hugs
02:55:48 <javaNewb> is there a prelude function that checks to see if any elements are repeated in a list?? i.e [1,2,1,3] = False?
02:59:10 <Hyp3rion> javaNewb - you can do that easily
02:59:23 * Hyp3rion still learning haskell so dont ask how
03:00:13 <bringert> javaNewb: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
03:00:20 <bringert> is that what you are looking for?
03:00:40 <bringert> @type nub
03:00:50 <bringert> @type List.nub
03:01:03 <Hyp3rion> heh
03:01:09 <bringert> lambdabot: wake up
03:01:57 <bringert> anyway, nub removes duplicate elements from a list, you could use that to check for repeated elements
03:03:40 <bringert> but nub is n^2 I think
03:04:09 <bringert> you might be able to get n log n by using Data.Set or something
03:04:44 <bringert> @eurohaskell
03:05:08 <bringert> shapr: lambdabot is asleep
03:07:51 <TheHunter> hasDup xs = cardinality (mkSet xs) /= length xs
03:08:09 <TheHunter> but it's far from optimal, at least n log n
03:08:38 <clausen> n log n isn't optimal?
03:09:25 <TheHunter> well it needs to copy the list...
03:09:35 <clausen> you could sort the list
03:09:41 <clausen> and then do pairwise comparisons
03:09:57 <clausen> but, sorting requires copying also
03:10:07 <javaNewb> i sorted the list
03:10:10 <clausen> TheHunter: I don't think you can avoiding copying the list
03:10:22 <javaNewb> i just did sort s
03:10:33 <TheHunter> but I think you can avoid traversing it twice
03:10:38 <bringert> clausen: what if you write it like nub?
03:10:59 <bringert> then you'll only traverse it, but not construct a new list
03:11:24 <javaNewb> thanks for the libraries bringert
03:11:38 <bringert> you're welcome
03:11:45 <clausen> bringert: if you do that, it must be n^2 I think
03:11:50 <bringert> sure
03:11:58 <bringert> but you don't copy the list :)
03:12:16 <clausen> I think nlog n + copy list is preferable
03:12:22 <bringert> I agree
03:12:25 <clausen> (well, depends on the size of the list...)
03:12:45 <bringert> javaNewb: that page is very useful, but not very easy to find unless you really know what you are looking for
03:13:02 <bringert> any www.haskell.org webmasters in here?
03:13:05 <javaNewb> oh, i found anotha one called ZVON
03:13:29 <javaNewb> together i think they have more than i need
03:13:29 <bringert> zvon is pretty good, but not very complete IIRC
03:13:37 <clausen> TheHunter: you think you can avoid 2 traversals and do better than O(n^2) ?
03:13:41 <clausen> oops
03:13:48 <clausen> stupid xchat
03:14:25 <javaNewb> once the list is sorted how can i compare each element with the one preceding it??
03:14:31 <javaNewb> is recursion needed?
03:14:56 <bringert> recursion is always needed (but you might not have to do it yourself) :)
03:14:59 <clausen> javaNewb: you could use fold
03:15:27 <bringert> or group
03:15:36 <javaNewb> foldr or foldl?
03:15:58 <clausen> foldr
03:16:07 <javaNewb> okay :) i will try
03:16:10 <bringert> Data.List.group if you want to look it up
03:16:25 <clausen> (hmmm, maybe foldl)
03:16:28 * clausen always gets confused
03:16:32 * bringert too
03:17:04 <clausen> either will work
03:17:23 <clausen> ooops, no
03:17:28 <clausen> I don't think it's possible
03:17:41 <bringert> with fold[l,r]?
03:17:50 <clausen> well, it can be done, but is ugly
03:18:05 <bringert> yeah
03:18:10 <javaNewb> so with group i just compare each list within the list right?
03:18:14 <TheHunter> clausen: You can do much better that hasDup. You could add the elements to the list pointwise and check everytime you add an element if it was already there. Unfortunatly we don't have an Either return type in any of the FiniteMap functions and no way to use the sideeffects in addToFM_C
03:18:57 <clausen> TheHunter: why is that better?
03:19:27 <bringert> javaNewb: actually looking at the length is enough
03:19:50 <javaNewb> then length?
03:19:58 <javaNewb> oh ic
03:20:00 <javaNewb> my bad
03:21:11 <TheHunter> clausen: cause it works much better on the list [1,1,2,3,4,5,6,7,8,9] and is possible in lists like 1:[1..]. Off to lunch now
03:21:25 <bringert> javaNewb: if you want, show us the code when you're done
03:22:49 <javaNewb> all (length==1) ([x | x <- (group(sort pp))]) . . . i tried that
03:22:58 <javaNewb> but i think ive misused all
03:25:00 <lambdabot> ERROR: unknown exception
03:25:01 <lambdabot> ERROR: unknown exception
03:25:02 <lambdabot> ERROR: unknown exception
03:25:02 <lambdabot> 1
03:25:02 <lambdabot> Shiver me timbers!
03:25:02 <lambdabot> juicy bits of code
03:25:05 <lambdabot> bzzt
03:25:06 <lambdabot> List.nub :: forall a. (Eq a) => [a] -> [a]
03:25:07 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
03:25:09 <lambdabot> less talks, more code!
03:25:11 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
03:25:13 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
03:25:13 <shrimpx> eh
03:25:14 <arjanb> lol
03:25:15 <shapr> whooo
03:25:19 <shapr> wtf was that
03:25:32 <shrimpx> dew on the wires
03:25:36 * shapr laughs
03:26:01 <javaNewb> ha ha ha
03:26:54 <shapr> oh, I think I might know the problem
03:27:21 <javaNewb> thanks chaps i got it working now :)
03:27:52 <shrimpx> heh chaps
03:28:08 <shapr> good morning #haskell!
03:28:25 <vegai> howdy pardners
03:28:27 <javaNewb> mornin shapr
03:28:38 <javaNewb> howdy to u too vegai
03:29:06 <shrimpx> are you guys doing the icfp contest?
03:30:53 <bringert> javaNewb: another defintion would be hasDup s = length s == length (group (sort s))
03:33:33 <javaNewb> and much easier to understand i see
03:33:56 <javaNewb> all (1==) ([length x | x <- (group(sort pp))]) <--- thats what i ended up with
03:34:46 * shapr looks for coffee
03:34:56 <javaNewb> already into the coffee?
03:35:12 <shapr> it's noon, so I'm a bit late :-)
03:35:45 <javaNewb> noon, what country is this?
03:35:50 <bringert> all ((1==) . length) . group . sort
03:35:56 <shapr> Sweden!
03:36:11 <shapr> land of sun and babes
03:36:14 <shapr> and haskell
03:36:14 * bringert likes to say the same thing in different ways
03:36:25 <andersca> sun, babes and haskell
03:36:32 <andersca> except that people are moving to freebsd
03:36:45 <shapr> in Sweden?
03:36:47 <javaNewb> sun && babes....oooooo
03:36:48 <shapr> oy
03:36:55 * shapr gets the joke
03:37:25 <javaNewb> thanks bringert
03:37:31 <javaNewb> :)
03:37:36 <andersca> hmm, what does group do
03:37:38 <andersca> @type group
03:37:39 <lambdabot> bzzt
03:37:43 <javaNewb> we youst to have sun && babes
03:37:46 <bringert> @type List.group
03:37:47 <lambdabot> List.group :: forall a. (Eq a) => [a] -> [[a]]
03:37:51 <andersca> oh
03:38:02 <andersca> makes sense
03:38:11 <shapr> @index all
03:38:11 <lambdabot> Data.List,GHC.List,Prelude,List
03:38:13 <bringert> @eval List.group "Mississippi"
03:38:14 <lambdabot> <<EM Dynamic -> EM Dynamic>>
03:38:40 <shapr> @get-definition group
03:38:40 <lambdabot> group = groupBy (\\x y.x==y)
03:38:45 <shapr> neat
03:38:59 <bringert> sweet
03:39:05 <arjanb> is that haskell?
03:39:11 <bringert> @get-definition nub
03:39:11 <lambdabot> nub = nubBy (\\x y.x==y)
03:39:17 <bringert> @get-definition nubBy
03:39:18 <shapr> nah, @eval is a lambda calculus interpreter
03:39:18 <lambdabot> nubBy = \\eq l.if null l then [] else head l : nubBy eq (filter (\\x.not 
03:39:18 <lambdabot> x `eq` head l)) (tail l))
03:39:37 <shapr> but it's amazing how easy it is to write much of the Haskell basics in a lambda cal interpreter
03:39:51 <shrimpx> well it's lc + lots of other stuff :)
03:40:00 <shrimpx> conditionals, lists, math, etc
03:41:05 <shrimpx> encoding lists in pure LC would be slightly more contrived
03:54:33 <kosmikus|away> lists are relatively easy
03:55:21 <vegai> is there any preferred way to store state into a file?
03:55:38 <vegai> such as pickle in python
03:55:42 <shapr> you could use NewBinary
03:56:31 <bringert> writeFile "file" . show
03:57:34 <shapr> bok Amadan 
03:57:40 <Amadan> bok :)
03:57:49 <shapr> looking for Haskell info?
03:58:06 <Amadan> yeah. just started learning it
03:58:13 <shapr> have any questions?
03:58:14 <vegai> bringert: heh, that's nice
03:58:44 <Amadan> actually, yes: i'm interested in parallel application of haskell
03:58:52 <vegai> bringert: reading that might be a bit tougher
03:59:02 <vegai> ...or is it?
03:59:07 <bringert> liftM read (readFile "file")
03:59:19 <shapr> Amadan: there's GpH, GdH, Eden, and Parr
03:59:23 <shapr> oh, and hMPI
03:59:55 <shapr> Glasgow Parallel Haskell, Glasgow Distributed Haskell use PVM
04:00:02 <shapr> hMPI uses MPI (surprise)
04:00:05 <Amadan> i got the ghc6 package and pvm as stated in user manual
04:00:16 <Amadan> and tried entering a sample program
04:00:22 <shapr> Parr is about nested data parallelization
04:01:02 <Amadan> and when i try to compile it "ghc -parallel Main.hs" i got
04:01:24 <Amadan> Failed to load interface for `Prelude' and Failed to load interface for `Control.Parallel'
04:01:25 <shapr> I think GdH and GpH are still at ghc 5.04.3
04:01:56 <Amadan> i understood from the docs that the parallelism was integrated into the main distribution now?
04:02:03 <shapr> really?
04:02:16 <Amadan> i don't know, the docs are in the main ghc manual
04:03:32 <Amadan> anyway, "ghc -parallel -v Main.hs" says that it searches for "/usr/lib/ghc-6.2/imports/Control/Parallel.mp_hi"
04:03:35 <shapr> this is what I've seen: http://www.macs.hw.ac.uk/~dsg/gdh/
04:03:44 <Amadan> i got Parallel.hi, but not the other one
04:04:08 <Amadan> See http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-using-concurrent.html
04:04:16 <Amadan> And http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-using-parallel.html
04:04:37 <Amadan> anyway, i might try some of the other compilers you pointed me to. thanks, people, for the ideas...
04:04:48 <Amadan> gotta go now, will return :)
04:05:39 <shapr> that's interesting
04:05:48 <shapr> I wonder if this really works
04:06:06 <javaNewb> thanks for the help all, and good night :)
04:06:12 <shapr> g'night javaNewb 
04:07:51 <shapr> Igloo: is PVM built into the standard debs?
04:08:05 <vegai> bringert: hmm ;-/
04:18:07 <vegai> bringert: cute idea, anyway. Perhaps it works with the simpler types
04:18:59 <andersca> vegai: otherwise you can just override the show and read instances
04:21:24 <vegai> which is not quite what I wanted. But perhaps it is a better idea
04:26:50 <TheHunter> @moo
04:26:51 <lambdabot>          (__)
04:26:51 <lambdabot>          (oo)
04:26:51 <lambdabot>    /------\\/
04:26:51 <lambdabot>   / |    ||
04:26:51 <lambdabot>  *  /\\---/\\
04:26:51 <lambdabot>     ~~   ~~
04:26:53 <lambdabot> ...."Have you mooed today?"...
04:27:30 <andersca> @arr
04:27:31 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
04:30:43 <Igloo> Don't think so, shapr
04:45:50 * Marvin-- grumbles noisily about Gibbs samplers
04:46:15 * Jerub attempts to write a parser.
04:50:17 <Jerub> :(
04:50:17 <Jerub> I know markov chains.
04:50:17 <Marvin--> I'm trying to wrap my brain around some notation
04:50:17 <Jerub> but not gibbs samplers.
04:50:32 <Jerub> I'm trying to find out why my parser isn't throwing errors on syntax problems.
04:51:03 <Marvin--> gibbs sampling is basically about using markov chain monte carlo and conditional probability to simulate a probability distribution that's hard to calculate directly
04:51:23 <Jerub> right
04:51:29 <Jerub> I kinda understand.
04:53:14 <Jerub> bingo, found my problem
04:53:49 <Marvin--> lucky you :/
04:53:50 <Marvin--> I'm trying to express pi(s) in terms of a conditional probability
05:33:11 <Marvin--> hm, I think I figured it out
05:58:52 * shapr sings the lambda song
05:59:15 <shapr> lift me up and let me float!
05:59:47 <Maddas> doesn't exactly sound like a chartbreaker :-)
06:00:04 * shapr agrees
06:00:16 <Marvin--> no wonder I'm such a slow thinker today
06:00:25 <Marvin--> I haven't had any coffee yet
06:00:27 <Marvin--> (!)
06:13:01 <neologism> I am studying for tommorows semestr test from programing languages theory
06:13:23 <neologism> I am wondering why everyone uses imperative languages when there is so much problems with it
06:13:26 <neologism> strange ;(
06:13:33 <shapr> I wonder that too.
06:13:46 <shapr> I think it's because everyone is used to doing it that way.
06:14:28 <neologism> might be
06:14:34 <shapr> so the answer is...
06:14:42 <Marvin--> "people suck"
06:14:48 <neologism> heh ;)
06:14:48 <shapr> if you do it differently, then it's not everyone
06:14:52 <andersca> Marvin--: or more like "people are morons"
06:14:58 <Marvin--> oh wait, that's my answer to anything
06:15:26 <andersca> to anything?
06:15:33 <neologism> but the sad thing is that when we were introduced to lisp and prolog nearly everyone said "its useless and terrible"
06:15:37 <neologism> just because they didnt know it
06:15:59 <neologism> they were offended by something "dangerously strange" ;)
06:16:06 <shapr> so you've noticed that people usually dismiss unknown technologies
06:16:07 <lispy> neologism: and because they've never seen a job posting in "the real world" for it
06:16:23 <neologism> lispy: I wouldnt say so
06:16:34 <neologism> we're students - our primary interest is alcohol and sex ;)
06:16:38 <shapr> ha
06:16:54 <neologism> we have the luxury to "do what we want"
06:16:59 <neologism> not whats demanded by industry
06:17:07 <shapr> I'm not a student, but I still believe that sex > programming
06:17:14 <andersca> shapr: depends on the language
06:17:17 <andersca> ;)
06:17:28 * shapr thinks about that
06:17:30 <lispy> at my school most CS students were interested in getting $$ when they finished school
06:17:57 <neologism> I remember when we saw stack implementation in prologi (stack(A,OSTACK,[A|OSTACK]).) nearly everyone had to see "the light"
06:18:00 <lispy> so they wanted to learn php, java, xml and database things
06:18:06 <shapr> yah, best thing we could do for CS is to dump all those who are just in it for the cash
06:18:16 <neologism> lispy: we're from different countries obviously
06:18:23 <andersca> shapr: people are usually more into IT for the cash
06:18:29 <neologism> not here
06:18:40 <shapr> what's the difference between IT and CS?
06:18:55 <neologism> in my country people tend to study CS because that allows them to play computer games and seem like "working hard"
06:19:08 <lispy> i usually think of IT as being system administration
06:19:26 <shapr> I guess I'm lucky I never studied CS.
06:19:43 <saz> hmm
06:19:45 <shapr> I still thing that sex > programming > everything else
06:19:59 <saz> shapr: you have a strange view of the world :P
06:20:01 <neologism> shapr: what about having sex while programmoing ;)
06:20:18 <shapr> it would be hard to focus on doing a good job of either in that case :-)
06:20:37 <shapr> saz: why do you think that?
06:20:44 <lispy> it's hard to make a career out of sex, the waiting list to become a porn star tends to be long for men.  and with HIV it can be a dangerous life style
06:21:10 <saz> shapr: i like programming, but there are a *lot* of things i'd rather do
06:21:15 <shapr> like what?
06:21:17 <saz> like
06:21:19 <saz> go out
06:21:37 <shapr> I do go out
06:21:57 <saz> but given the option, you'd rather program?
06:22:03 <shapr> yes, honestly
06:22:13 <saz> heh
06:22:15 <saz> ok :)
06:22:19 <shapr> though going out with programmers is spiffy
06:22:43 <saz> i don't mind going out with programmers
06:22:55 <saz> easier to talk to :P
06:23:10 <shapr> I keep thinking there's a coherent unified theory behind all of programming, or at least a set of ideas that are at the bottom of it all
06:23:10 <neologism> why going out with programmers when there is IRC?
06:23:18 <shapr> because there are female programmers ;-)
06:23:25 <neologism> shapr: have you seen any?
06:23:29 <shapr> sure, lots
06:23:36 <neologism> I have and I have to admit they look ugly ;)
06:23:39 <shapr> no way
06:23:45 <saz> *cough*
06:23:46 <shapr> lots of good looking female programmers too
06:23:49 <neologism> from my experience I have to say so
06:23:57 <shapr> neologism: you need to visit other countries
06:24:54 <neologism> hm... talking to a girl about "the beauty of polyform types" hm... ;)
06:25:03 <shapr> sure, why not?
06:25:53 <neologism> I am a bit conservative about this... I prefer to talk about non-CS-related things with such beutafull beings as girls are
06:26:04 <neologism> anyway - back to studying
06:26:09 * shapr grins
06:26:10 <neologism> thnx for a nice chat ;)
06:27:19 <shapr> the stereotypes are just that, stereotypes
06:27:32 <neologism> what?
06:27:33 * saz is pretty sure she wouldn't want to meet neologism 
06:27:36 <neologism> I dont understand
06:27:43 <neologism> saz: why? ;)
06:27:52 * shapr grins
06:27:53 <saz> cos you think i'm ugly
06:27:54 <saz> ?
06:28:04 <saz> and um, dumb or something?
06:28:28 <shapr> neologism: I have the strong suspicion that saz is a cute female programmer.
06:28:36 <neologism> saz: I said that I have seen just ugly programmer girls...
06:28:46 <neologism> nothing about you!
06:28:56 <neologism> I deeply aplogize
06:29:42 <saz> shapr: not sure about cute ;-)
06:30:15 <lispy> if you have a digital camera we could settle the issue :)
06:30:29 <saz> i'll be right :)
06:30:33 <saz> why does it matter anyway?
06:30:37 <neologism> see, she's a girl and you dont talk about CS anymore ;)
06:30:42 <shapr> oy
06:30:59 <lispy> saz: it doesn't, but i had to tease you
06:31:56 <shapr> in any case, there are several female Haskell programmers who show up here on #haskell
06:32:11 <shapr> but they have this shocking habit of discussing CS while they're here!
06:32:19 * Igloo can only think of two, and before this conversaion only one  :-)
06:32:19 <lispy> *gasp*
06:32:20 <saz> shapr: omg!
06:32:29 * ozone verifies that saz is indeed a cute female programmer
06:32:34 <Igloo> Are you doing a PhD, saz?
06:32:39 <Lunar^> Warning, sexism detected...
06:32:48 <saz> Igloo: no, just undergrad atm
06:32:50 <ozone> muahahaha
06:32:53 <ozone> my work here is done
06:33:11 * shapr grins
06:33:13 <Igloo> Aha, OK
06:33:36 <ozone> Lunar^: sexist?  me?  nawwww
06:33:48 <ozone> saz will verify that i'm no sexist pig.  (maybe a sexist dog, though)
06:33:50 <neologism> nice debate indeed ;)
06:34:23 * saz asserts ozones non-sexist-ness
06:34:25 <Lunar^> ozone: Don't launch me on this subject please.. I'm fed up with sexists behaviour in the computer field
06:35:01 <shapr> I think it's hard to tell when someone is just joking, because sexism takes different forms in different cultures.
06:35:02 <Marvin--> ozone's non-sexiness?
06:35:14 <Igloo> Waah. LaTeX hates me.
06:35:19 <saz> i didn't say that!
06:35:26 <Marvin--> Igloo: join the club
06:35:29 <lispy> Igloo: why is that?
06:36:03 <Igloo> Because it's cast from pure liquid evil, probably
06:36:12 * shapr quotes that
06:36:19 <lispy> hehe, i like latex
06:36:42 <ozone> i like latex too.  *giggle*
06:36:46 <shapr> oy
06:37:46 <Igloo> It seems to be laying things out differently depending on whether I have white space or text inside what is essentially a verbatim environment
06:38:19 <saz> i hate how latex places images
06:39:27 <Igloo> Possibly just ignoring blank lines at the start. Hmm.
06:40:20 <ozone> Igloo: i'll get back to you about the implicit parameters, sorry
06:40:27 <ozone> i have three papers due in the next 2 weeks.  hooray!
06:40:29 <lispy> saz: were you using figures?
06:40:49 <ozone> and one due in about 30 hours
06:40:58 <Igloo> ozone: Don't rush on my account, it's you who wants them  :-)
06:41:10 <saz> lispy: yeah
06:41:11 <ozone> indeed
06:41:18 * Igloo might have thought about it myself but have a similar time issue...
06:41:32 <lispy> saz: ah, yeah figures only place well if you are writing a book.
06:42:23 <saz> lispy: yeah, if you have lots of room to place them (big document), and don't really care if they're close to what refers to them, it's fine
06:43:34 <lispy> saz: you do know it's possible to just drop them in and center them without using figures right?  It can take a little tweaking, but works better for homework and the like.
06:43:49 <saz> lispy: oh? how do you do that?
06:43:57 <neologism> pls can you tell me what "stg machine" is?
06:44:05 <lispy> saz: good question, let me see if i can find an example
06:44:12 <shapr> spineless tagless g-machine
06:44:22 <neologism> shapr: and that what?
06:44:32 <shapr> it's one of the ways of implementing a functional language
06:44:46 <neologism> can you give me any ur about that topic?
06:44:49 <shapr> along with supercombinators, TIM (three instruction machine), etc
06:44:53 <shapr> ur?
06:44:55 <neologism> url
06:45:00 <andersca> I printed out the book simon peyton jones wrote
06:45:08 <andersca> about implementing functional languages
06:45:09 <shapr> yes, read the book by SPJ
06:45:12 <shapr> it's free
06:45:58 <neologism> I have to had summary information
06:46:14 <neologism> and I am willing to sacrifice about 10 minutes to it ;)
06:46:14 * bringert dislikes Makefiles
06:47:05 <Igloo> Don't get me started on Makefiles. I'm already fuming at TeX - I'd probably explode
06:47:31 * bringert also does not like autoconf
06:47:38 <bringert> but that's another story
06:47:57 <lispy> saz: first you put \usepackage[dvips]{graphicx}, then to include a .eps (or .ps) file use something like this \includegraphics[width=.5\textwidth]{5b.eps}
06:48:24 <saz> lispy: aah, thanks, I'll note that for the next assignment :)
06:48:36 <maihem> lispy: what does pdflatex do to such a file?
06:49:00 <lispy> maihem: no clue, i don't use pdflatex
06:49:06 <maihem> heh :)
06:49:16 <lispy> sorry :)
06:49:47 <neologism> wheren can I get the book by peyton you mentioned?
06:51:10 <shapr> I think it's on his homepage
06:51:11 <lispy> if you use makefiles i trust you use suffix rules....
06:51:30 <Amadan> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
06:52:18 <neologism> thnx
06:52:30 <Amadan> no prob
06:56:58 <Marvin--> http://www.theinquirer.net/?article=16247
06:58:09 <Amadan> anyway, i'm back; anyone know anything about ghc6 debian package and parallelism?
06:58:40 <shapr> Marvin--: bwahahaa!
06:58:52 <shapr> that's the biggest heatsink I've ever seen.
06:59:00 <shapr> it looks like a jet engine!
07:00:54 <shapr> Amadan: I don't know, Igloo might have some advice
07:01:03 <Marvin--> my spontaneous thought was "WTF?"
07:01:48 <shapr> with linux 2.6 which device is my first serial port?
07:01:57 <Marvin--> my second thought was "Is this for real?"
07:02:12 <shapr> when I point pilot-manager at /dev/vc/0 weird things happen
07:02:36 * shapr wonders if that's virtual console
07:02:40 <maihem> /dev/ttyS0
07:02:51 <shapr> I don't have one of those
07:02:54 <shapr> I'm using devfs
07:03:05 <shapr> (mostly because I can't figure out how to get rid of it)
07:03:10 <maihem> haha!
07:03:37 <mikef> Oops.
07:04:11 <maihem> shapr: append="nodevfs devfs=nomount"
07:04:21 <shapr> maihem: and then my system won't boot :-)
07:04:25 <maihem> umount devfs
07:04:31 <maihem> cd /dev
07:05:11 <shapr> something bad happened when I was first installing devfs, and I have zero devices in /dev when I don't boot with devfs
07:05:24 <maihem> MAKEDEV
07:05:36 <shapr> don't you need to boot the system to use makedev?
07:06:11 <shapr> oh I bet I could fix that with a knoppix CD
07:06:23 <maihem> no, boot, change lilo.conf, umount /dev && cd /dev && MAKEDEV && lilo && reboot; should probably do it
07:07:22 <shapr> g'day sabamacx 
07:07:24 <shapr> hej spenatmannen 
07:07:33 <sabamacx> Evening.
07:07:36 <shapr> maihem: I'll try that after I've done some work, thanks
07:08:23 <maihem> I suggest not actually changing the command line until after testing manually ;)
07:08:47 <shapr> I'm using grub, so I can screw around all I want with the boot line
07:08:52 * shapr hugs grub
07:09:11 <shapr> grub > lilo
07:09:29 <sabamacx> I think otherwise :P
07:09:31 <maihem> grub sucks lilo's <whistle>
07:10:17 <shapr> what's better about lilo?
07:10:36 <sabamacx> It works, no fuss, no mess, for "different" hard drive configurations :)
07:10:38 <shapr> sabamacx: are you new to Haskell?
07:10:54 <shapr> bonjour lordodo
07:10:56 <sabamacx> No; I quite enjoyed the year of it forced upon me at university :)
07:11:11 <shapr> ok, so you don't want the learning haskell tour then :-)
07:11:22 <mikef> What's the learning haskell tour?
07:11:33 <sabamacx> I'll pass, unless you have a spiffy lambda-calculus section :)
07:11:36 * mikef 's forced year was in SML.
07:11:36 * sabamacx raised on HUGS
07:11:54 <Amadan> oh, oh, i do, i do! :)
07:11:58 <shapr> @eval (\x -> x + 1) 1
07:12:04 * shapr blinks
07:12:12 <sabamacx> ++
07:12:17 <Amadan> 2
07:12:22 * shapr takes a stick to lambdabot
07:12:42 <shapr> @eval (\x -> x + 1) 1
07:12:43 <lambdabot> 2
07:12:52 * sabamacx claps
07:13:05 <shapr> @eval map (\x -> x + 1) [1,2,3]
07:13:06 <lambdabot> [2, 3, 4]
07:13:13 <shapr> @get-definition map
07:13:14 <lambdabot> map = \\f.foldr (\\x y.f x:y) []
07:13:19 <sabamacx> How do you feed it multiline statements?
07:13:20 <mikef> Ah.
07:13:37 <shapr> @get-definition foldr
07:13:38 <lambdabot> foldr = \\c n l.if null l then n else c (head l) (foldr c n (tail l))
07:14:03 <shapr> the Eval plugin has just a few built-ins, everything else is defined with lambda cal
07:14:19 <sabamacx> @eval map toLower "Test"
07:14:20 <lambdabot> unbound variable: toLower
07:14:24 <sabamacx> Darn.
07:14:35 <shapr> @get-definition to
07:14:36 <lambdabot> to not defined
07:14:39 <shapr> @get-definitions to
07:14:40 <lambdabot> Sorry, I don't know the command "get-definitions", try "lambdabot: @listcommands
07:14:44 <shapr> @listcommands eval
07:14:45 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition
07:14:45 <lambdabot> ,"definitions","del-definition","dump","set-fuel","resume"]
07:14:58 <mikef> What does the backslash indicate in (\x -> x + 1) ?
07:15:10 <shapr> it means incoming argument
07:15:16 <mikef> Thanks.
07:15:22 <sabamacx> (\ <- Kinda looks like a lambda
07:15:27 <sabamacx> If you stuck a straw in your eye
07:15:28 <mikef> heh
07:15:36 <mikef> Yes.
07:15:41 <neologism> @define ($)
07:15:41 <lambdabot> (line 1, column 1):
07:15:41 <lambdabot> unexpected end of input
07:15:41 <lambdabot> expecting white space or simple term
07:16:00 <sabamacx> shapr, so no multiline statements? :)
07:16:34 <shapr> like what?
07:16:39 <shapr> @definitions to
07:16:40 <lambdabot> ["toList"]
07:17:04 <sabamacx> Say, junk a b ; where ; a = foo b ; b = bar something
07:17:09 <neologism> can anyone give me the definition of ($) in lamdba calculi?
07:18:12 <bringert> ($) = \f . \x . f x
07:18:15 <bringert> right?
07:18:30 <sabamacx> Function ($) Arguments = Function Arguments
07:18:39 <sabamacx> If my hazy memory kicks in correctly.
07:19:56 <neologism> yes, it seems ok
07:22:37 <spenatmannen> hej shapr
07:24:20 <shapr> wassup?
07:25:09 <shapr> bringert: you still working on blog code? is that what the xhtml was about? I'd prefer xhtml fer shure.
07:25:15 <shapr> hiya opet, how's code?
07:25:52 <opet> shapr: slow! the weather's too good to spend too much time in front of a screen :)
07:26:01 <shapr> get a laptop!
07:26:13 * shapr grins evilly
07:26:18 <opet> pff
07:26:20 <bringert> shapr: I sure am
07:26:22 <opet> still a screen :)
07:26:34 <shapr> ok, I admit, I've spent some time unicycling in the bright sunlight, with no computer involved.
07:26:41 <shapr> bringert: do you have a repo up?
07:26:50 <bringert> I can put one up
07:26:54 <shapr> yay!
07:31:43 <neologism> and how does and operator look in lambda calculi?
07:32:01 <bringert> with church booleans?
07:32:06 <shapr> you just give it a name
07:32:34 <maihem> shapr: don't do the MAKEDEV thing, it's wrong, sorry. I can't remember what I did when I got rid of devfs.
07:32:56 <shapr> if you remember it, I want to hear!
07:33:09 <neologism> is it
07:33:25 <neologism> Lx.Ly.y True False
07:33:26 <neologism> ?
07:34:35 <bringert> \x . \y . x y False
07:34:38 <bringert> right?
07:35:17 <neologism> shit, you're right
07:35:49 <shapr> oh I thought you asked "how does an operator look in lambda calculi"
07:36:57 <chucky> maihem, shapr: Isn't udev supposed to replace devfs? That's what Gentoo is doing anyway
07:37:30 <shapr> yes, udev claims to be better
07:37:34 <shapr> I would like to use udev myself
07:37:50 <neologism> and or?
07:38:00 <neologism> Lx.Ly.(not y) x True ?
07:38:22 <bringert> \x . \y . x True x
07:38:25 <bringert> which is the same
07:38:29 <bringert> but does not use not
07:38:32 <neologism> so I was corect?
07:38:46 <neologism> cool! (mine firt succesfull lamdba program ;) )
07:38:50 <bringert> assuming that you have defined not already
07:38:53 <kosmikus1away> there should be some y in there, bringert ...
07:38:59 <bringert> eh
07:39:01 <bringert> right
07:39:07 <bringert> \x . \y . x True y
07:39:16 <kosmikus1away> better :)
07:39:35 <bringert> neologism: hmm, isn't your's backwards
07:39:53 <andersca> isn't it "yours"?
07:40:12 <neologism> I dont think so
07:40:51 <neologism> I'd say its in right order
07:41:02 <bringert> andersca: yes
07:41:17 * bringert is sloppy
07:42:55 <neologism> so - is mine solution correct?
07:42:59 <neologism> I'd say yes byt...
07:45:35 <bringert> neologism: your solution looks at y first
07:47:04 <neologism> so?
07:47:42 <neologism> when y is true True is returned
07:47:51 <neologism> when y is false then x is returned
07:47:57 <neologism> thats correct, isnt it?
07:49:04 <bringert> neologism: normally you'd like x to be evaluated first
07:49:14 <bringert> but that depends on you intended semantics
07:49:19 <bringert> your
07:49:31 <shapr> kosmikus: I guess it's better to talk about generics in Haskell on this channel
07:50:16 <neologism> bringert: my semantic is that there is no "short evaluation"
07:50:57 <shapr> kosmikus: there's some neat discussion about generics on Ward's Wiki, http://c2.com/cgi-bin/wiki?GenericVsObjectOrientedProgramming
07:51:03 <neologism> so I suppose its correct
07:51:33 <bringert> are you assuming call-by-name or call-by-value?
07:51:54 <shapr> though I'm beginning to think that what I wrote about generics is incorrect
07:52:39 * bringert sneaks out for a bit
07:52:45 <shapr> the differences between the implementations of generics is fascinating
07:53:02 <shapr> boilerplate uses a unitraversal and typeful dispatching
07:53:14 <shapr> hinze uses type-indexed functions and type-indexed types
07:53:56 <shapr> typeclasses are sort of generics also
07:54:18 <shapr> seems like type-indexed functions is one step past typeclasses to me
07:54:56 <kosmikus> type-indexed functions are about the same as type classes, only a different view on the same matter
07:55:05 <kosmikus> type class methods are type-indexed functions, really
07:55:18 <shapr> hmm
07:55:22 <kosmikus> if you call a function such as (==), then the compiler finds out the right instance to use
07:55:39 <shapr> yes, but typeclasses require that they all have the same kind, right?
07:55:40 <kosmikus> but you could also see it as a function having a type argument
07:55:51 <shapr> doesn't type-indexed functions let you go past that?
07:55:54 <kosmikus> (==) <Int> 2 3, or something
07:56:56 <kosmikus> not really
07:57:14 <shapr> hm
07:57:24 <kosmikus> for class instances, you can also write something like instance X a => X [a] where ...
07:57:37 <kosmikus> that is almost the same as defining an instance for the list type constructor
07:58:32 <kosmikus> the relationship between Hinze's MPC style and Dependency-style GH is almost the same
07:59:33 <kosmikus> in Hinze's approach, you define  generic_function<[]>, whereas in depstyle GH you would define  generic_function<[alpha]>, for any alpha ...
07:59:33 <shapr> I sort of understand the MPC approach, but I have no clue about the dependency-style
08:00:01 <kosmikus> shapr: well, then my thesis is exactly what you need ;)
08:00:01 <shapr> hm, I'll have to read more
08:01:22 * shapr grins
08:03:57 <kosmikus> shapr: re the discussion at Ward's Wiki, I think the problem is that it's called "Generic Vs OO". I think that Generic is not well-defined enough to support any such argument. Every language has something called "generic", everyone has a slightly different understanding of what it should mean, ...
08:04:47 <shapr> I'm beginning to realize that
08:07:55 <Philippa_> genericism = selective ignorance. Oh, wait, that's abstraction
08:10:07 <Philippa_> selective ignorance of differences, then?
08:10:14 <Philippa_> probably about as good as you're going to get
08:12:57 <neologism> how can I do recursion in lambda caculi?
08:13:53 <ibid> neologism: you can get the effect by using the y combinator
08:14:00 <Philippa> or another fixpoint operator
08:16:22 <neologism> show me an example in haskell pls
08:16:27 <neologism> I heard about y operator
08:16:36 <neologism> but dunno how to use it or what it is
08:17:24 <Philippa> Google for it? It's been a while since my exam, I've forgotten what it looks like written out
08:17:33 <ibid> are you talking about lambda calculus or haskell? it's not quite the same thing...
08:17:49 <neologism> anything
08:17:55 <neologism> ideally both
08:18:01 <ibid> though i would have to look it up as well, so i can't be bothered :)
08:18:43 <arjanb> programming in a functional language takes me much more time because i constantly find ways to make the code prettier
08:19:00 * arjanb slaps the perfectionist in himself
08:19:34 <Philippa> neologism: given a function f and a fixpoint operator y, f (y f) = y f. That, or I'm braindead and I've misremembered
08:20:04 <neologism> thats what I read
08:20:43 <neologism> I would love to see any real example...
08:20:53 <ibid> i usually start my projects in c++ and then often redo it in haskell out of frustration
08:21:09 <Philippa> well, there aren't many really-real examples because most of us code in languages that have explicit recursion
08:21:26 <Philippa> ibid: heh. I would if I could be arsed to learn how to generate bindings for C++ libs
08:21:30 * ibid mutters "wikipedia"
08:21:46 <ibid> Philippa: my projects do not usually need bindings
08:21:58 <Philippa> the ones I'm even vaguely tempted to do in C++ do
08:22:23 <ibid> i usually choose c and c++ due to their ubiquity
08:22:40 <Philippa> ah. For me it's the libs and the speed of the resulting code
08:23:06 <ibid> libs would tempt me toward python and perl :)
08:23:29 * Philippa nods
08:23:50 <Philippa> doesn't really work for a lot of what I play with. Guess I ought to look at PyGame again sometime
08:24:09 <ibid> but i have this irrational disinterest in languages with only one implementation that happens to be interpreted
08:24:17 <Philippa> heh
08:24:41 <Philippa> Python puts me off just because it feels flimsy to me
08:24:49 <ibid> flimsy?
08:24:58 <Philippa> yeah. Too easy to fuck up my abstractions, stuff like that
08:26:20 <ibid> in what way?
08:27:35 <Philippa> been a while since I looked it over and I never wrote any docs, but ISTR it only offering pseudo-protection of a class's internals, stuff like that
08:28:10 <ibid> well yeah, but it's good pseudo-protection :)
08:28:33 <ibid> in the sense that it's there is a real psychological line to be crossed
08:28:43 <Philippa> true
08:28:57 <Philippa> I think my other problem is I'm getting too used to really good type systems
08:29:01 <Philippa> pisses me off with C++, too
08:29:04 <ibid> heh
08:29:37 <sundeep> Philippa: good type systems, like what?
08:29:42 <ibid> yeah, it sort of feels like papering when code actually works when it first passes compiler's checks :)
08:29:48 <ibid> pampering
08:29:56 <Philippa> sundeep: we're sitting in #haskell, take a guess
08:30:11 <Philippa> but really, C++'s type system is like a particularly arsey asm language...
08:30:11 <sundeep> Philippa: ok
08:30:19 <Philippa> it's turing complete, but it's hell to work with
08:30:35 <Philippa> and any time you screw up the errors're hell to trace
08:30:43 <ibid> i actually like most of it, but there are certain mountain-size problems
08:30:59 <Philippa> yeah. The basic object model I don't have too big an issue with
08:31:03 <sundeep> Philippa: what do you mean by turing complete: thats a useless tautological fact for all languages
08:31:17 <Philippa> not for type systems, however
08:31:32 <ibid> like why the hell do classes get default copy constructors and default copy assignment operators
08:31:56 <sundeep> Philippa: would like to read about it then, any pointers?
08:32:26 <ibid> sundeep: not tautological, actually. a language without free recursion and while loops would not be turing complete, even though it would feel useful
08:32:46 <ibid> (primitive recursion and for loops are allowed)
08:33:01 <ibid> s/free recursion/general recursion/
08:33:04 <Philippa> what value of for loop?
08:33:04 <sundeep> ibid: when i said 'all' i meant languages that are in use
08:33:11 <ibid> Philippa: the classic kind
08:33:31 <ibid> sundeep: that kind of makes the tautology argument useless imho
08:33:54 <ibid> Philippa: ie. for i := 1 to 42 do ... done
08:34:05 <Philippa> sundeep: just look up C++'s template mechanism, including partial specialisation
08:34:17 <Philippa> it's sort of like Prolog's bastard step-child with freckles
08:34:39 <ibid> heh
08:34:55 <ibid> Philippa: i have seen C++ code that looks almost like haskell
08:34:59 <sundeep> hmmmm
08:35:16 <ibid> Philippa: of course, the huge template system required for its support was hidden :)
08:36:12 <Philippa> And the macros too, I assume?
08:36:21 <Philippa> raw template-heavy stuff has nasty syntax...
08:36:39 <ibid> no, it made ingenious use of operator overloading
08:36:45 <ibid> no macro stuff as far as i know
08:36:49 <neologism>       Y = lf.(lx.(f (x x)) lx.(f (x x)))
08:36:54 <neologism> thats the Y operator
08:37:01 <neologism> (by Church)
08:37:10 <neologism> eee, Curry ;)
08:37:24 <det> Y f = f (Y f)
08:37:47 <det> erm, I guess you want it without the self-reference
08:38:02 <neologism> I wanted to show how its used ;)
08:38:12 <Smerdyakov> It's _not_ used...
08:39:07 <Philippa> it's used to show we can use recursion in lambda calc-derived languages so we don't have to bother
08:39:21 <Philippa> much like church numerals et al show we can use built-in ints
08:39:48 <ibid> but they are neat :)
08:40:01 <neologism> Philippa: I study lambda calculi so I want to see
08:40:06 <neologism> I dont want to use it in real life
08:40:54 <Philippa> ibid: d'oh, yeah, I always forget about operator overloading 'cos I decided there weren't enough operators and I couldn't be arsed
08:41:31 <ibid> :)
08:41:40 <Philippa> neologism: once again, google and wikipedia will have examples
08:41:50 <neologism> Philippa: I have seen
08:41:52 <Philippa> if you ask me to type one out I'll get it wrong
08:42:00 <Philippa> right. What makes you think we've got any others?
08:42:06 <Philippa> we don't use the damn things
08:42:06 <neologism> but people here told me they dont know exactly
08:42:07 <ibid> neologism: it's also useful to work some examples out yourself
08:42:10 <neologism> so I put here the example
08:42:30 <neologism> I dont ask for anything!
08:42:33 <ibid> neologism: it was not an example, it was a definition, and we did know, not offhand though
08:43:02 <neologism> oh, I didnt past it ;(
08:43:14 <neologism> thought I did
08:43:25 <ibid> neologism: don't bother
08:43:28 <neologism> I found nice example - functional (the classinc one)
08:43:50 <neologism> ok, thnx for advices and patience!
08:45:47 <neologism> s/functional/factorial (I am a bit tired)
08:48:03 <jadrian> hi
08:49:37 <jadrian> noname f (x,y) = (f x, f y)?
08:49:53 <jadrian> is pairwise a good name for "noname"?
08:50:13 <jadrian> (ignore the '?' in the equation)
08:50:50 <Philippa> toEachOf?
08:50:53 <Philippa> though that's wordy
08:51:36 <jadrian> I thought about mapPair
08:51:46 <jadrian> but I wanted to avoid "map" in this context
08:52:31 <neologism> innerApply ?
08:53:05 <jadrian> maybe to general... just like lift
08:54:05 <jadrian> I got functions prodf and splitf, for the categorial  x and /\
08:55:00 <jadrian> but I don't think this has any specific name in category theory
08:55:22 <jadrian> it's just the product of a function by itself
08:55:59 <jadrian> hmm sqrf...
08:56:27 <jadrian> is f^2 used in category theory? 
08:56:42 <jadrian> f^2 = f x f
08:56:45 <jadrian> ?
09:16:04 <kosmikus> jadrian: why not map?
09:19:26 <arjanb> jadrian: for Arrows operators like &&& *** >>> are used so what about  f ^^^ (x,y) = (f x, fy)
09:21:52 <jadrian> kosmikus: I don't have a strong argument aginst it. Don't like "map"-kind of names associated with pairs, (,) isn't an instance of functor...
09:23:29 <jadrian> kosmikus: I know it's not a great argument because, data Pair a = Pair a a,  could have an instance of functor, but I'd like to stress that I'm working with general pairs of (a,b), it just happens to be (a,a) in this case
09:23:45 <jadrian> kosmikus: but I was looking for something along the lines of split and product
09:23:53 <jadrian> arjanb: hmmm I don't know arrows...
09:24:14 <jadrian> arjanb: let me google them
09:24:17 <monotonom> (a,b) could have a bifunctor.
09:24:41 <arjanb> http://www.haskell.org/arrows/
09:24:41 <jadrian> monotonom: let me google bifunctor too :)
09:24:58 <jadrian> thanks arjanb
09:35:54 <neologism> "politic is just a different form of sex" - lol ;)
09:41:44 <jadrian> so let me see if I got this right, &&& when applied to functions works like function product
09:41:52 <jadrian> f &&& g  = f x g
09:42:04 <jadrian> and >>> would be backword composition
09:42:24 <jadrian> backwards composition
09:43:02 <Riastradh> http://www.flightlab.com/~joe/hxml/arrows.html
09:43:39 <jadrian> opss sorry 
09:43:42 <jadrian> &&& - split
09:43:47 <jadrian> *** - product
09:43:58 <jadrian> >>> - backwards composition
09:44:08 <jadrian> when applied to functions
09:44:28 <jadrian> thanks Riastradh!
09:46:16 <Riastradh> When I read John Hughes' paper about the eleventh time, I think I actually understood arrows for about five minutes thereafter.  Then I found that page...
09:46:30 <jadrian> lol
09:47:03 <jadrian> right now I cannot spend to much time with it, so I don't think I have to understand it fully
09:47:23 <jadrian> I'm just interested combinators that make point free style easier
09:47:31 <Riastradh> What you want is just f >&< f.
09:48:17 <jadrian> hmmm isn't it (f &&& f) ?
09:48:29 <jadrian> (I haven't looked at >&< yet)
09:48:52 <Riastradh> No.  That would return an arrow that takes one input, applies f to it twice, and stores the output doubly in a tuple.
09:49:50 <arjanb> >&< == ***  i think
09:49:54 <jadrian> hmmm that's not what it does here...
09:49:59 <Riastradh> f >&< f returns an arrow that takes a tuple input, applies f to the left and f to the right, and returns a tuple of the two outputs.
09:50:17 <jadrian> oh wait yeah
09:50:36 <jadrian> I've read so much stuff I even forgot what I wanted... geez
09:51:06 <Riastradh> Arrows are rather annoying in that everyone has his own differing names for the operators.
09:51:15 <jadrian> ok so what I want is (f *** f)
09:51:32 <jadrian> so if >&< is the same that's what I want, but!
09:51:40 <jadrian> I don't want to type f twice
09:52:00 <Riastradh> So define a >&& or come up with some equally confusing operator name that does it for you.
09:52:58 <jadrian> I was working with split, prod, and so on, and was looking for a good name in that context
09:53:58 <jadrian> I'm not familiar with arrows so have have to give it some thought
09:55:17 <jadrian> brb sis needs computer
10:53:31 <jadrian> hi again
10:53:39 <Riastradh> Hi.
10:53:44 * Riastradh shoots an arrow at jadrian.
10:55:07 <jadrian> Riastradh: guess I'm using "both" :)
10:55:17 <jadrian> ...
10:55:18 <jadrian> (>>>) :: a b c -> a c d -> a b d
10:55:18 <jadrian> first :: a b c -> a (b, d) (c, d)
10:55:21 <jadrian> second :: a b c -> a (d, b) (d, c)
10:55:53 <jadrian> in the context of function, first applies to the 1st, second applies to the 2nd...
10:56:01 <jadrian> so I'll just use "both" :)
11:02:10 <Riastradh> Why not use *** / >&<?
11:02:21 <Riastradh> (that looked more like a curse than an arrow operator...)
11:02:35 <Marvin--> Stop swe...duh
11:02:53 <Marvin--> dammit, don't use my punchlines :)
11:03:20 * Riastradh snickers.
11:03:29 <Marvin--> oh great
11:03:43 <Marvin--> a friend of mine is supposed to present his thesis tomorrow at four
11:04:00 <jadrian> Riastradh: ? 
11:04:06 <jadrian> Riastradh: *** is diferente
11:04:09 <jadrian> different
11:04:43 <jadrian> Riastradh: I want a short for  (f *** f)
11:05:16 <Riastradh> jadrian, uh, so define fan f = f *** f
11:05:17 <Marvin--> right now he's stuck in a flight strike and will land in Gothenburg at 15.30
11:05:29 <jadrian> Riastradh: yeap, and my fan is "both"
11:05:38 <Marvin--> there you go with the swearing again
11:05:54 <Marvin--> ("fan" is a Swedish curse)
11:06:09 <jadrian> Riastradh: and I decided for both because in  class Arrow  you have "first" and "second" 
11:06:20 <jadrian> Riastradh: so both seemed appropriate... 
11:06:31 <jadrian> Riastradh: more appropriate than "fan" ;)
11:07:12 <jadrian> Riastradh: but what was your point?
11:07:27 <jadrian> not sure if I'm missing something...
11:08:02 <Riastradh> Oh, never mind.  I was missing your point.
11:08:45 <jadrian> but yes arrows are cool, and I whish I had the time to take a closer look
11:09:17 <jadrian> for now I'll just use them for point free style
11:15:41 * Marvin-- sighs
11:15:51 <Marvin--> I thought I'd have a little peace and quiet once I finished the thesis
11:15:51 <shapr> hi Kuril, wassup?
11:15:58 <Marvin--> guess I was wrong
11:16:19 <Kuril> The Hal Daume tutorial (YAHT)
11:16:50 <shapr> good choice
11:22:23 <jadrian> hi shapr
11:22:33 <shapr> hi jadrian, wassup?
11:22:49 <jadrian> Ok just for fun, can my both operator be defined with methods in class arrow only?
11:22:56 <jadrian> shapr: playing with arrows
11:23:03 <jadrian> I came up with
11:23:09 <jadrian> both :: Arrow a => a b c -> a (b, b) (c, c)
11:23:09 <jadrian> both =  (first &&& second)  >>>  uncurry (>>>)
11:23:19 <jadrian> but I have an uncurry there :-/
11:23:35 <Marvin--> so?
11:23:38 <jadrian> shapr: just a two minutes more and then back to work
11:23:52 <shapr> yay work
11:23:54 <jadrian> Marvin--: uncurry is not a method of class Arrow...
11:24:05 <jadrian> oh!
11:24:14 <jadrian> and I mean a point free style definition
11:24:27 <jadrian> otherwise this would do
11:24:33 <jadrian> both :: Arrow a => a b c -> a (b, b) (c, c)
11:24:34 <jadrian> both f = (f *** f)
11:24:40 <jadrian> but that's not fun
11:24:44 * Philippa is currently teaching herself more stuff by coding up some of the simpler stuff in the papers then making it do some of the more interesting bits on top
11:24:53 <Philippa> regarding arrows, that is
11:25:23 <jadrian> nice :)
11:27:21 <jadrian> brb
11:27:26 <Philippa> I think first up is a state transformer that tells you how often you read/write. Obviously that one's not ArrowApply or ArrowLoop as that gets pointless
11:37:24 <shapr> huh, interesting debian kernel package flap
11:43:53 <stepcut> ugh
11:44:23 <stepcut> kernel and drivers management  is a huge nightmare
11:44:37 <shapr> seems bizarre to me that someone would resign from debian because they list taiwan as a country
11:44:49 <stepcut> hehe
11:44:55 <stepcut> debian rocks like that :)
11:46:14 <shapr> lwn.net has an article about the movable type license change, and one of the comments says "now what do you have to say about debian's almost free /= free pickiness?"
11:46:56 <shapr> lwn.net also mentions the HC&AR report :-)
11:47:03 <stepcut> I am always entertained that linspire is based on debian, because the philosophies of lindows and debian are so different
11:47:25 <shapr> I have wondered about that myself.
11:47:31 <stepcut> :p
11:48:55 <stepcut> the technology unites us :)
11:50:00 * Marvin-- gets lwn to mail him a new password
11:50:07 <Marvin--> goddangit I always forget passwords
11:50:46 <shapr> if you base your password on the site name with a salt and hash of your own choosing, it's easy.
11:51:11 <stepcut> gshow 1
11:51:13 <stepcut> oops
11:59:01 <stepcut> I wonder if there is someway to 'show' a partial applied type constructor...
11:59:14 <stepcut> for example: data MyType = MyType String Int
11:59:41 <stepcut> oh wait...
12:00:21 <stepcut> show (Type2 "hi")
12:00:33 <stepcut> (Type2 "hi") :: Int -> MyType
12:00:36 <stepcut> or something...
12:06:41 <Marvin--> stepcut: basically you want a Show instance for functions?
12:07:01 <stepcut> Marvin--: well, more restricted than that...
12:09:51 <stepcut> but, I think the problem is, what I want to do, does ultimately boil down to Show instance for functions...
12:10:45 <stepcut> in the above case, could do something like this to extract the str from the partial applied constructor:
12:10:46 <stepcut> let (Type2 s _) = (Type2 "hi" 1) in s
12:11:02 <stepcut> ie, just fill in a dummy value for the int, and then pattern match
12:11:28 <stepcut> but that is not safe, for all functions of type (Int -> MyType)
12:11:58 <jadrian> is there any labeled data extension for easy application of functions to its fields? 
12:12:28 <jadrian> its easy to do:   record{field = value}
12:12:41 <jadrian> but what if the update of the field depends on the field itself...
12:14:26 <stepcut> well, I think I will just stick to serializing the serializable
12:14:26 <Marvin--> jadrian: basically you want a neater syntax for   record{field=f (field record)}?
12:14:53 <jadrian> yeap
12:15:20 <Marvin--> jadrian: that makes two of us
12:15:23 <Marvin--> :)
12:15:25 <stepcut> :p
12:17:03 <stepcut> hello shapr? Any questions about haskell we can help you with?
12:17:18 <Philippa> well, I pulled off the arrow-with-static-info trick, am finally satisfied I really *really* understand how it works
12:17:25 <stepcut> hehe
12:17:28 <stepcut> Philippa: nice!
12:17:43 * shapr grins
12:18:00 <stepcut>  I keep trying to use arrows in all my programs, but so far I have not had to write anything which could benefit from arrows :(
12:18:02 <shapr> stepcut: why yes, where can I find a job using Haskell? ;-)
12:18:03 <Philippa> shapr: the really *really* bit's important :-)
12:18:05 <Marvin--> stepcut: haha
12:18:49 <stepcut> shapr: at lindows, of course...
12:20:43 <jadrian> Marvin--: :-/
12:20:46 <stepcut> of course, you will also have to do something ocaml programming, hope that's not a problem
12:20:50 <Philippa> stepcut: am only playing about at the moment, but I've a few ideas
12:21:19 <jadrian> Marvin--: it's really tedious having to define application functions for every field of every record :(
12:21:58 <shapr> stepcut: no, I think I can live with that.
12:28:34 <Philippa> hmm, something occurs to me...
12:28:50 <Philippa> the static info trick doesn't need lazy evaluation, it only needs partial evaluation
12:30:13 <stepcut> jadrian: you might be able to use template haskell to generate the functions automatically?
12:30:36 <Philippa> stepcut: thought current implementations weren't up to that yet?
12:31:44 <stepcut> Philippa: Well, TH is definately buggy -- so it would probably be necessary to use CVS head 
12:39:07 <Philippa> oh, cool, looks like it's in fully in GHC 6.2
12:41:37 <Philippa> $([|1|]) <- overly complicated? :-)
12:43:00 <Marvin--> nahhh
12:43:01 <Marvin--> :)
12:58:32 * shapr stabs devfs
13:01:46 <jadrian> stepcut: haven't read anything about TH yet...
13:02:03 <jadrian> Philippa: what does that mean by the way?
13:06:07 <Philippa> [|1|] gives you an expression value for 1, $(...) splices an expression back in
13:06:16 <Philippa> so it's a wordy way of writing 1 :-)
13:07:02 * Philippa suspects TH and arrows would make for a wonderful combination for self-optimising code
13:08:17 <Philippa> admittedly the static info thing with arrows can be done by analysing the raw code in TH, but where's the fun/value in that?
13:11:40 <jadrian> Philippa: interesting :)
13:49:14 <stepcut> whoa, extQ is my new friend
13:49:57 <Marvin--> yep, it's neat
13:51:04 <Marvin--> the things that Data.Generics does to the type system are insane :)
13:51:32 <jadrian> what does extQ does?
13:51:46 * jadrian hasn't played with Data.Generics yet either...
13:51:47 <stepcut> I am working on a version of gshow that has a return type (String,String), so I can do stuff like: ashow (Just "hi") --> ("Just", "\"hi\")
13:51:53 <Marvin--> extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
13:52:06 <stepcut> and then use Data.List.lookup on a list of those things
13:52:36 <Marvin--> jadrian: you use extQ with mkQ and often with combinators like everything
13:52:43 <stepcut> ((\t -> "hi") `extQ` (show :: String -> String))
13:53:14 <Marvin--> jadrian: type safe casts :)
13:53:19 <jadrian> right...
13:53:36 <stepcut> that function will take a value of any type. If the type is a string, then it calls show on the string, otherwise it returns the string "hi"
14:06:32 <stepcut> is there a why to make a new class which is derivable?
14:06:39 <stepcut> s/why/way/
14:07:09 <Marvin--> no, I don't think so, but you could use TH to generate instance declarations
14:07:36 <stepcut> ok, that's what I thought
14:07:55 <Marvin--> it would be neat if those two ends could be tied together
14:08:29 <Marvin--> "Here's a class, here's some TH code for deriving instances, make the class derivable please"
14:09:46 <stepcut> I am not sure its worth it in this case
14:10:00 <stepcut> this is my class definition: class URLable a
14:10:05 <stepcut> that's it
14:10:08 <Marvin--> well, I meant in general
14:10:39 <stepcut> I just want it so I can restrict the context(?) of a function to specially marked data types
14:10:40 <stepcut> showURLable :: (Data a, URLable a) => a -> String
14:12:38 * bringert likes stepcut's rss module
14:13:02 <stepcut> heh, actually, my girlfriend wrote it (but I helped)
14:13:42 <stepcut> its pretty useful though
14:13:51 <Marvin--> then we like your girlfriend! ;)
14:13:55 <stepcut> haha
14:16:05 <stepcut> Of course, it would be better if you could define a record with optional fields
14:17:25 <stepcut> or something...
14:18:17 <stepcut> someway to check at compile time that elements only appear once 
15:23:16 * jadrian hates coding in ascii
15:24:02 * jadrian wants greek letters and higher order functions as hats and bars and stuff :-/
15:27:19 <Lor> How would you input them?
15:28:02 <Lor> But you can try the x-symbol package for emacs if you want a quick remedy.
15:37:41 <jadrian> Lor: with an Unicode editor :P
15:38:02 <jadrian> Lor: but yes somthing like x-symbol
15:38:05 <jadrian> Lor: would be nice
15:38:34 <jadrian> Lor: proof general with x-symbol looks great
15:38:43 <Lor> The point is not how it looks but how it is written.
15:39:03 <jadrian> Lor: oh, simple there are 2 ways
15:39:11 <Lor> "\" is just a single character. I can't think how any special combination for the greek lambda could be more practical.
15:40:05 <jadrian> oh it wouldn't be easier to type
15:40:10 <jadrian> just easier to read
15:40:20 <jadrian> I tend to spend more time reading my code then typing it
15:40:31 <jadrian> I've seen two ways to insert unicode symbols
15:40:47 <jadrian> one (the best) is having a meta key
15:41:14 <jadrian> press the key, your cursor changes, type the name, returnm and you have the simbol
15:41:36 <jadrian> :META: lambda :RETURN:
15:41:41 <Lor> Uh. You don't expect to use that in practical coding, do you?
15:41:44 <jadrian> and you have a lambda 
15:41:50 <jadrian> yeap I do ;)
15:42:06 <Lor> I think the x-symbol approach is much more sensible. Plain simple input, and a prettified display.
15:42:36 <jadrian> depends
15:42:51 <jadrian> I don't see much diference between what I just said and
15:42:54 <jadrian> \<lambda>
15:43:10 <jadrian> (that was Isabelle)
15:43:13 <jadrian> or \lambda
15:43:17 <jadrian> (LaTeX)
15:43:23 <Lor> No, I mean just plain \
15:43:30 <Lor> That's lambda in haskell.
15:43:49 <jadrian> oh pressing \ and getting a lambda?
15:44:04 <Lor> It can be pretty-printed that way, of course.
15:44:09 <jadrian> yes but that is just a very particular case...
15:44:30 <jadrian> what about all the other greek letters
15:44:31 <Lor> The point is that in Haskell, it is a _common_ lexical token, and therefore it should be easy to write.
15:44:47 <Lor> What do you need other greek letters for?
15:45:19 <Lor> What's wrong with just identifiers a, or alpha, and then using x-symbol if you want on-screen prettyprinting, and lhs2tex if you want on-print prettyprinting.
15:45:22 <jadrian> yes you're right, I just was not thinking about simply pretty printing '\'
15:46:07 <Lor> Coding should be _simple_. It's okay if you have, say, Super-a bound to alpha, and so on for the rest of the greek letters, but that's about it.
15:46:10 <jadrian> nothing is wrong with that, that would be the x-symbol approach
15:46:25 <jadrian> I don't like that because it is dependent on what you're working with
15:46:30 <jadrian> and you have to memorize it
15:46:32 <jadrian> for instance
15:46:35 <Lor> Once you need to do extra special key combinations in the course of ordinary coding, you're off the course.
15:46:47 <jadrian> in Isabelle I have \<lambda> for lambdas
15:47:00 <jadrian> in LaTeX to do a lambda it's \lambda
15:47:02 <Lor> For real? That's the token that's used for anonymous functions?
15:47:21 <jadrian> ?
15:47:33 <jadrian> no
15:47:46 <jadrian> do you know isabelle? the theorem prover?
15:48:04 <Lor> Not very well, Coq always looked more attractive.
15:48:19 <jadrian> there is a Proof-General mode for Isabell that can use x-symbol to pretty print stuff
15:48:36 <jadrian> and that's the token for lambdas
15:48:40 <jadrian> \<lambda>
15:49:10 <jadrian> the meta-key approach allows you to abstract from the grammar
15:49:10 <Lor> But this is just a plain identifier, not a binding construct?
15:49:20 <jadrian> no just an identifier
15:49:55 <Lor> All right. Let me say, in a functional context, using lambda as an identifier is a _tremendously_ bad idea. :)
15:50:22 <jadrian> yes I know, Isabelle is not a functional language though
15:50:39 <Lor> That must be why I don't use it. :)
15:50:43 <jadrian> lol
15:50:44 <Lor> Coq _is_ a functional language.
15:50:59 <jadrian> I don't know coq
15:52:26 <Lor> It's, well, pretty expressive.
15:53:55 <jadrian> COQ has been dissolved on 12/31/2000
15:53:59 <jadrian> It has been replaced by LOGICAL
15:54:00 <jadrian> ?
15:54:22 <jadrian> seems like coqs dead
15:54:46 <Lor> Uh, no.
15:54:56 <Lor> Coq's latest version (8) came out this year.
15:55:06 <Lor> Actually, it might still be in beta.
15:55:11 <jadrian> hmm am I looking at the wrong site?
15:55:15 <jadrian> http://www.inria.fr/recherche/equipes/coq.en.html
15:55:17 <Lor> coq.inria.fr
15:55:21 <jadrian> COQ : Formal Specifications and Program Validation (project-team) 
15:55:39 <Lor> That is just inria's internal project organization.
15:55:51 <Lor> If they have renamed a team, it doesn't mean that the software is dead.
15:56:01 <jadrian> yes you're right
15:56:17 <jadrian> they were refering to the team...
15:57:32 <jadrian> brb
17:59:59 <SyntaxLaptop> something wrong w/ cvs.haskell.org, or is it just me?
18:04:00 <Kuril> I couldn't access it earlier either.
18:05:01 * lispy wonders why haskell.org hasn't switched to darcs, since it's written is Haskell.
18:05:57 <lispy> i guess it's hard to convert between revision control systems
18:08:52 <SyntaxLaptop> lispy: it'll take a while before large projects consider moving to a new VC system
18:09:07 <SyntaxLaptop> but FWIW, last week we got darcs installed on cvs.haskell.org, and there's an "official" haskell project using darcs now.
18:09:34 <lispy> oh good, i've started using (still using cvs for somethings) and it seems nice
18:09:39 <Jerub> lots of people are moving from cvs -> svn
18:09:53 <Jerub> 3 projects I know of in the last 2 months.
18:10:29 <lispy> svn is backwards compatible with cvs though isn't it?
18:11:03 <Jerub> svn isn't named 'subversion' for nothing.
18:11:19 <Jerub> they're intentionally trying to put themselves in a position where they can take over cvs repositories.
18:11:25 <lispy> my biggest complaint with darcs is that i haven't found a way to paginate the changes
18:11:29 <Jerub> so yes, there's lots of similarity and compatibility.
18:11:40 <Jerub> lispy: what? no rss feed of changes?
18:11:41 <Jerub> ;)
18:12:23 <lispy> i don't know what rss is, but i mean on the command line when i use darcs, and it basically gives the output of diff
18:13:35 <SyntaxLaptop> we were talking about this on #darcs the other day...
18:13:48 <SyntaxLaptop> I didn't know svn was compatible w/ cvs. not sure if that's true
18:13:55 <SyntaxLaptop> but they are designed in a very similar way.
18:14:00 <SyntaxLaptop> which is a draw-back if you ask me.
18:14:04 * SyntaxLaptop is much more interested in tla and darcs
18:14:47 <lispy> tla?
18:15:31 <lispy> "TLA - The Temporal Logic of Actions" ?
18:16:43 <Smerdyakov> Total Laser Arena
18:17:50 <SyntaxLaptop> Tom Lord's Arch, I think.
18:17:54 <SyntaxLaptop> AKA "arch"
18:17:58 <SyntaxLaptop> or "Gnu Arch"
18:18:06 <lispy> oh, okay, yeah i know gnu arch
18:20:46 * SyntaxLaptop uses both darcs and tla on a regular basis, and used to use svn
18:20:51 <SyntaxLaptop> (and of course, cvs, since one cannot escape it)
18:21:05 <SyntaxLaptop> honestly, ATM I like tla best, but darcs is growing on me.
18:21:11 <lispy> SyntaxLaptop: do you see any advantages between tla vs. darcs and the other way around?
18:22:53 <lispy> i wonder how hard it would be to write a tool that converts cvs repositories into darcs or arch repositories
18:23:06 <lispy> i'm not finding one on google
18:27:05 <SyntaxLaptop> there is one, I think. they both have wikis, I'd look there
18:27:26 <ozone> Three Letter Acronym
18:27:27 <SyntaxLaptop> heffelump (not currently here) has some kind of cvs2darcs tool, but I haven't looked at iet yet.  I will, because I need it :)
18:27:37 <lispy> i just changed my search and i'm finding some things now
18:28:36 <SyntaxLaptop> tla vs darcs... I like darcs because it's easy to cherry-pick exactly which patches I want
18:29:14 <SyntaxLaptop> I like the way the repository in tla is layed out better, and over-all it is a more mature piece of software (more developers and more users) but darcs is catching up fast. 
20:02:45 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelld #darcs","http://www.haskell.org/hawiki/EuroHaskell","http://www.mirror.ac.uk/sites/www.haskell.org/","May 2004 HC&AR: http://www.haskell.org/communities/"]'
20:02:45 --- topic: set by Pseudonym on [Tue May 25 17:24:50 2004]
20:02:45 --- names: list (clog Pseudonym clausen Lukhas andersca _Codex skylan stepcut flori Joachim blackdog_ Etaoin ne_one GreyLensman shawn desrt Smerdyakov Jerub norpan bringert mattam Kuril esap Riastradh themaximus lambdabot mij SamB_on_a_trip Cale Pinnen cbus rubix gdsx ludde dennisb lispy Segora sundeep isomer tic kosmikus|away saz polli jasonw Tomas mikef smkl Spark Matt-W shrimpx neologism Lor ozone ibid Lunar^ Taaus vegai mayhem ksandstr cmeme sorrow asmodai)
20:02:45 --- names: list (Jon det jameson|afk shammah wagle keverets Hipo earthy reffie np_hard gnufan Amadan bluejay chucky Igloo edwinb [dan])
21:18:05 <lispy> wxhaskell is really hard to install it appears.
21:18:32 <tautologico> I had no troubles
21:18:32 <lispy> at least in debian, I found some "install tips" for debian on a wiki, but they seem to be out dated.
21:19:20 <tautologico> well, I didn't test with debian
21:20:11 <lispy> the version of wxwidgets that appears in apt isn't compatible with wxhaskell (apt has 2.5 instead of 2.4)
21:22:03 <lispy> it's too bad really, i would like to try out the darcs gui, and getting wxhaskell on my system is the last thing in my way
21:23:23 <lispy> i've tried building from sources (tons of compiler errors, mostly due to th difference in wxwidgets versions), and installing the rpm (sort of worked, but now i'm unable to register the packages with ghc)
21:23:48 <tautologico> well, the only problem I had was the huge binaries
21:24:09 <lispy> it generates large binaries?
21:24:48 <tautologico> ye
21:24:49 <tautologico> yes
21:25:19 <tautologico> I believe ghc links statically the libraries, so there goes the whole wxWidgets with your binary
21:25:32 <lispy> eep
21:26:04 <shrimpx> is it bad that i think unsafePerformIO is cool?
21:26:33 <desrt> shrimpx; no.  you'll pay dearly, just like everyone else
21:26:42 <shrimpx> haha
21:27:34 <lispy> tautologico: if the binary size didn't suffer so badly i'd prefer static linking anyway.
21:28:26 <tautologico> lispy: well, the upside is that is compresses very well :) and works nicely
21:29:04 <tautologico> it
21:29:10 <lispy> any idea where ${wxhlibdir} should point?
21:29:51 <tautologico> .  /usr/lib/wxwidgets ?
21:30:16 <lispy> hm...i don't have /usr/lib/wxwidgets
21:31:32 <lispy> Expanding embedded variables... Unable to expand variable "wxhlibdir"
21:31:52 <lispy> that's the error i get when i run ghc-pkg -ai wxcore.pkg
23:27:23 <yc> is there anyway to take/drop or something similar on an integer?
23:30:53 <Etaoin> depends on what you want take and drop to mean I guess
23:31:11 <earthy> happy mailman day
23:32:37 <yc> as defined in prelude
23:33:47 <Etaoin> then I guess it's already done for you
23:36:15 <yc> the functions work on lists, i'm wondering if similar functions exist for integers
23:38:17 <Etaoin> you mean one that uses Integers rather than Ints?
23:40:01 <Etaoin> it probably woudn't be too hard to write
23:41:45 <yc> no i mean like: take 5 349594 = 34959
23:42:40 <Etaoin> ah
23:43:21 <earthy> convert from int to list of digits, delete element, convert back?
23:49:10 <yc> coverting back is giving me trouble
23:50:40 <earthy> errr huh?
23:52:57 <earthy> listtoint xs = listtoint' (reverse xs)  where listtoint' [] = 0; listtoint' (x:xs) = (10 * listtoint' xs) + x
23:53:05 <earthy> (warning, untested code)
23:55:06 <yc> works
