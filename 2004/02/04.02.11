00:55:25 <kosmikus|away> just a question in between: has Helium 1.2 actually been announced somewhere? I was quite surprised to get an update request without seeing any announcement.
00:56:01 <shapr> I think Darius mentioned it to me, but I never heard an announcment.
00:56:38 <kosmikus|away> also, they don't seem to reveal that they have type classes now ...
00:56:44 <shapr> they DO?
00:56:53 <kosmikus|away> limited, but yes
00:56:57 <kosmikus|away> hidden feature
00:56:58 <shapr> wow, cool
00:57:18 <kosmikus|away> I don't have the tarball available, but there should be two preludes or something
00:57:34 <kosmikus|away> the one without typeclasses is probably default, but if you set the include path correctly ...
00:57:39 <shapr> spiffy
00:58:06 <kosmikus|away> you can't define own instances, though
00:58:14 <kosmikus|away> they just have the Prelude classes
00:58:31 <ibid> hardcoded?
00:59:09 <kosmikus|away> I don't know ...
00:59:27 <ibid> it would make sense if new ones cannot be declared
00:59:57 <kosmikus|away> basically, it's for the error messages
01:00:12 <kosmikus|away> if you say "2 + 'c'", you get something like
01:00:59 <kosmikus|away> 'c' is no Float, Int, or Double
01:01:56 <ibid> basically, they make the closed world assumption?
01:02:37 <kosmikus|away> I think so
01:05:42 <kosmikus|away> Prelude> show id
01:05:42 <kosmikus|away>  Type error in overloaded function
01:05:42 <kosmikus|away>  function         : show
01:05:42 <kosmikus|away>    type           : Show a => a        -> String
01:05:42 <kosmikus|away>    used as        :           (b -> b) -> String
01:05:44 <kosmikus|away>  problem          : b -> b is not an instance of class Show
01:05:47 <kosmikus|away>  hint             : valid instances of Show are [a], Int, Float, Bool, Char and
01:05:49 <kosmikus|away>                     tuples
01:06:06 <kosmikus|away> but I'm away, I forgot
01:06:12 <ibid> then it might be possible to allow new classes so long as all instances are declared in that same module
01:15:11 <earthy> morning, kosmikus. ;)
01:15:30 <earthy> you are failing to hand in the `woon-werkverkeer' form, if I surmise correctly.
02:13:52 <MakeMyDay> Ok I need some help with a list definition: bool (n + 1) = [b : bs | b <- [O, I], bs <- bool n ]
02:14:12 <MakeMyDay> bool 0 = [[]]
02:14:27 <MakeMyDay> bool is either O or I 
02:14:43 <MakeMyDay> ( simulated boolean)
02:15:28 <earthy> interesting thing you're building there
02:15:36 <earthy> what do you intend to build? :)
02:16:11 <earthy> (what you seem to be building is a list of lists of lists of lists of lists of lists until you end up with a list containing an empty list
02:16:14 <earthy> )
02:16:31 <MakeMyDay> It's just a function that gives out the list Bitvectors
02:16:38 <MakeMyDay> so for bool 2 it you give you
02:17:03 <MakeMyDay> [O,O] [O,I] [I,O] [I,I]
02:17:45 <MakeMyDay> only I really don't see how that works...
02:18:31 <earthy> hm. hmmmm.
02:18:42 <earthy> I seem to be misparsing
02:19:46 <MakeMyDay> what is that "b <- [O,I]" supposed to do in there?
02:20:02 <earthy> ah, right. I forgot that lists in haskell are (head:(head:(head:(head:()))))
02:20:15 <earthy> MMD: it sets b to the values O and I respectively
02:20:34 <earthy> the [b: bs | b <- [O, I], bs <- bool n]   is a list comprehension
02:20:35 <MakeMyDay> ah
02:20:56 <earthy> it iterates the bindings to the left of the <- over the values to the right
02:21:34 <MakeMyDay> ok I think i got it
02:21:49 <MakeMyDay> but how is this  a list of a list
02:22:05 <MakeMyDay> I mean [[bit]]
02:22:06 <earthy> ah,  b:bs  is itself a list
02:22:17 <earthy> due to  :  being the list constructor
02:22:21 <MakeMyDay> ow
02:22:25 <MakeMyDay> yeah I see now
02:28:18 <MakeMyDay> wouldn't he bs <- bool n create another list?
02:29:04 <MakeMyDay> arg feck I don't get it
02:29:14 <MakeMyDay> I really wish he would run it one time..
02:29:31 <earthy> yes. It does generate another list
02:30:02 <earthy> the list of bitvectors of length n
02:30:09 <earthy> bs gets iterated over that list
02:30:21 <earthy> (that's what had me thrown for a sec)
02:37:32 <MakeMyDay> ok I seriously must be missing something here
02:37:42 <MakeMyDay> perms as = [a : p | (a, bs) <- remove as, p <- perms bs ]
02:37:51 <MakeMyDay> how is that supposed to create all permutations?
02:40:08 <MakeMyDay> ow wait
02:40:15 <earthy> got it? :)
02:40:31 <MakeMyDay> nearly there..
02:42:04 <MakeMyDay> n
02:42:05 <MakeMyDay> o
02:42:13 <MakeMyDay> god damn it why is he doing lists this way
02:43:25 <MakeMyDay> I read a tutorial on Haskell and then I could write all sorts of programms ,now I read his stuff and can't even make out a damn list :/
02:45:43 <MakeMyDay> ok nm the permutations..back to the boolean
02:52:37 <MakeMyDay> omg I got the bool thing
02:52:47 <MakeMyDay> it's easy
02:52:51 <MakeMyDay> I just couoldn't see it
02:54:18 <ludde> can I write this in some simpler way
02:54:28 <ludde> which is not as long but still reasonably efficient
02:54:29 <ludde> getPow2 :: Integer -> Int
02:54:29 <ludde> getPow2 1 = 0
02:54:29 <ludde> getPow2 2 = 1
02:54:29 <ludde> getPow2 4 = 2
02:54:29 <ludde> ...
02:54:31 <ludde> getPow2 _ = -1
03:20:31 <phubuh> getPow2 n = length $ takeWhile (/= 1) $ iterate (`div` 2) n
03:20:32 <phubuh> :-)
03:37:10 <vorpal> log makes more sense than getPow :)
04:22:08 <ludde> vorpal: log is for floating point numbers though
04:23:19 <vorpal> ic.  what about the '$' in phubuhs function? is that for composition?  i thought '.' was for composition.
04:23:23 <ludde> how can I truncate a double into an integer?
04:23:42 <phubuh> vorpal: . is composition, $ is application with very low precedence
04:23:43 <ludde> "a $ b c" is the same as "a (b c)"
04:24:05 <phubuh> you could write getPow2 = length . takeWhile (/= 1) . iterate (`div` 2), too :-)
04:24:16 <ludde> phubuh: that doesn't properly return -1 for all non pow2:s though :)
04:24:18 <vorpal> got it
04:24:26 <ludde> phubuh: but i solved my problem in another way
04:24:28 <phubuh> oh, right.
04:24:40 <ludde> maybe you can help me make it shorter
04:24:54 <ludde> getPow2 :: Integer -> Integer
04:24:54 <ludde> getPow2 n = case (lookup n (tbl 1 0)) of
04:24:54 <ludde> 	Nothing -> -1
04:24:54 <ludde> 	Just x -> x
04:24:54 <ludde> 	where
04:24:55 <ludde> 		tbl _ 32 = []
04:24:57 <ludde> 		tbl a b = (a,b) : tbl (a*2) (b+1)
04:40:48 <ejt_> if it's a power of 2 there will be only 1 bit set, so you can repeatedly rshift and check the zero bit, probably faster than a list lookup
04:41:36 <ejt_> I don't think the bitops library has a find_first_set function unfortunately
05:24:22 <MakeMyArse> hmm
05:24:32 <MakeMyArse> I got a new instance of the show class
05:24:38 <MakeMyArse> with following definition :
05:24:38 <MakeMyArse> showsPrec d (Inv g)
05:24:39 <MakeMyArse> = showParen (d > 9)
05:24:39 <MakeMyArse> (showString "~" · showsPrec 9 g)
05:25:07 <MakeMyDay> what is that d > 9
05:26:05 <ejt_> true or false ?
05:26:54 <MakeMyDay> but what is d ?
05:27:08 <MakeMyDay> I guess you can't awnser that since you don't know the whole program
05:28:17 <MakeMyDay> what it must do it when I type Inv(x) it should show ~x
05:30:52 <Darius> d is the precedence
05:32:41 <MakeMyDay> ah rgr
05:32:54 <MakeMyDay> thx
05:36:01 <MakeMyDay> heh great nickname
05:42:30 <vorpal> I like the SemanticBovine
08:53:50 <Odiseo> hello, i'm trying to use function composition and it's not working, can i paste the code in here or something?(the error at least?)it's short
08:54:14 <Odiseo> the error appears complaining of the types when i try to use tuplas in order to apply the composition
08:55:00 <ibid> one or two lines can be pasted
08:55:15 <Odiseo> g::(Int->[Int])->Int
08:55:15 <Odiseo> g (1,(x:xs)) = x
08:55:15 <Odiseo> g (x,(y:ys)) = g ((x-1),ys)
08:55:34 <Odiseo> i'm from argentina, inflation made that 3 lines:)
08:57:24 <Odiseo> am i still connected?
08:58:48 <Odiseo> anybody?
09:02:05 <kowey> hi room... could someone help me with forkProcess?
09:02:37 <kowey> i've got some old code which expects forkProcess to return Maybe ProcessID,
09:02:52 <kowey> and now the new library returns just ProcessID
09:03:22 <kowey> the doc says "on success forkProcess returns the child's ProcessID to the parent's process"
09:03:31 <kowey> but how does this tell me how to figure out who's who?
09:03:54 <Igloo> The child just runs the computation you give it
09:04:06 <Igloo> It knows it's the child because otherwise it wouldn't be running that code  :-)
09:04:20 <kowey> oh...
09:04:30 * kowey takes a second look at the code... 
09:04:48 <kowey> so that means the stuff that used to be matched from Nothing...
09:04:57 <kowey> becomes an argument to forkProcess?
09:05:20 <ibid> Odiseo: Int->[Int] is a function, not a pair
09:05:20 <Igloo> That sounds right
09:05:50 <kowey> thanks! i'll wrangle out the lets/do
09:23:06 <kowey> thanks again Igloo, it compiles, but it'll be a while before i find out if it works :-)
09:25:45 <Odiseo> ibid, what do you mean?
09:26:34 <ibid> Odiseo: what i said
09:27:01 <Odiseo> i've caught an example of using composition of functions and it says that, how can i fix that otherwise then?
09:27:08 <ibid> Odiseo: your type says your function takes a function, but you define the function as if it takes a pair
09:27:45 <ibid> try g :: (Int, [Int]) -> Int
09:29:04 <Odiseo> no, that's one of the two functions i use to do the composition, would you like to see the other one?or I maybe not understanding what you've said
09:29:42 <Odiseo> ohhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh i get it
09:29:46 <Odiseo> , instead of ->
09:29:48 <Odiseo> my bad
09:29:53 <ibid> :)
09:30:35 <Odiseo> heh I apologize big time
09:30:41 <Darius> Odiseo: You don't need to provide the type.  Further you can ask an interpreter for the type.
09:31:04 <Odiseo> :t ?
09:31:10 <Darius> Yes.
09:31:18 <Darius> @type let g (1,x:xs) = x;g (x,y:ys) = g (x-1,ys) in g
09:31:18 <lambdabot> let {g $0 $0} in g :: Num a => (a,[b]) -> b
09:31:43 <Igloo> It's good practice to give the type for all top-level functions, though
09:32:33 <Darius> Igloo: It's also good practice to give top-level functions names more descriptive than "g" ;)
09:32:47 <Odiseo> kick me while i'm down
09:32:48 <Odiseo> :)
09:33:20 <Odiseo> i've used g cause in math it's easier to do fog, f and g, than myfirstfunction'o'mysecondfunction
09:34:04 <Darius> @type uncurry (!!)
09:34:04 <lambdabot> uncurry (!!) :: ([a],Int) -> a
09:34:26 <Darius> @type uncurry (flip (!!))
09:34:27 <lambdabot> uncurry (flip (!!)) :: (Int,[a]) -> a
09:35:26 <Odiseo> I still don't what what's that curry stuff, what's with all the curry, it's bad for your stomach
09:36:06 <ski> then you perhaps like uncurry better ?
09:36:53 <Odiseo> yes!
09:37:09 <ski> :)
09:38:07 <Odiseo> question, if I do composition am I obligated to only use one argument?I mean, if I use two arguments instead of a tupla then it doesn't work... ergo, that's why i'm asking
09:38:51 <ski> how do you mean ?
09:39:15 <Odiseo> like, instead of g::(Int,[Int])->Int , doing g::Int->[Int]->Int
09:39:37 <Odiseo> and after that use that in a composition
09:39:40 <ski> do you mean like trying to convert "f x y = g (h x y)" to "f = g . h" ??
09:40:24 <ski> (as opposed to converting "f (x,y) = g (h (x,y))" to "f = g . h" !)
09:40:35 <Riastradh> You'd have to do [[f x = g . h x]] or some such thing.
09:40:56 <Darius> @type \f g -> (f .) . g
09:40:57 <lambdabot> \f g -> (f .) . g :: (a -> b) -> (c -> d -> a) -> c -> d -> b
09:41:08 <ski> Odiseo : hmm ?
09:41:11 <Odiseo> no, no, just using composition fog... 
09:41:23 <ski> fog is f.g in haskell
09:41:54 <Odiseo> exactly, I though I could use two parameters but it doesn't make any sense, sorry:)
09:41:54 <Darius> But as most functions don't return tuples and it's not necessary to represent a function as a long chain of compositions it doesn't come up often.
09:42:20 <ski> Odiseo : (exactly) what were you trying to do ?
09:42:27 <Riastradh> (This works just fine in Scheme!)
09:42:32 * Riastradh ducks.
09:42:47 <Darius> With curried functions?
09:43:03 * ski slasps Raistradh with a big tuple
09:43:05 <Odiseo> it worked what I was trying to do, but I was curious to know if it was possible to use instead of a tupla two separated 'variables'
09:43:05 <Riastradh> No, because you typically don't use currying in Scheme, whereas you do in Haskell.
09:43:26 <Odiseo> like, instead of f::(Int, [Int]->Int, f::Int->[Int]->Int, but doing the same thing
09:43:47 <Odiseo> but I guess f::Int->[Int]->Int it's not allowed if i'm going to do f.g
09:43:59 <ski> doing *what* "same thing" ?
09:44:25 <Odiseo> the composition
09:44:31 * ski thinks it depends on what one's trying to do ..
09:44:42 <ski> what's the type of g ?
09:45:07 <Odiseo> f::Int->Bool and g::(Int,[Int])->Int
09:45:17 <Odiseo> that way it works f.g perfectly
09:45:25 <ski> aha
09:45:47 <ski> and you wonder if it works with g :: Int -> [Int] -> Int  ?
09:45:49 <Odiseo> but if i change g::Int->[Int]->Int, and try to do f.g doesn't work, instead f.g should be f.g::Int->[Int]->Bool
09:45:55 <Odiseo> exactly!!!
09:46:08 <Odiseo> just being curious
09:46:11 <ski> so f_g x y = f (g x y)
09:46:23 <ski> so f_g x = f . (g x)
09:46:44 <ski> which is  = (.) f (g x)
09:47:06 <ski> so  f_g = (.) f . g
09:47:07 <ski> :)
09:47:21 <Odiseo> (can I call this variables?I know functional doesn't have variables but... how do i call this then?)
09:47:43 <Odiseo> I get what you mean, if I do that I should be working with 2 variables functions, yep, sound like right
09:48:09 <ski> @type let (.:) = (.) . (.); f = (undefined :: Int->[Int]->Int); g = (undefined :: Int->[Int]->Int) in    f .: g
09:48:09 <lambdabot> let {($0 (0 ((.) . (.))) $0 .: $0) (f ($0 (0 undefined) $0) $0 (g ($0 (0 undefined) $0) $0 $0))} in f .: g :: Int -> [Int] -> [Int] -> Int
09:48:28 <ski> oh, worng
09:48:53 <ski> @type let (.:) = (.) . (.); f = (undefined :: Int->Bool); g = (undefined :: Int->[Int]->Int) in   f .: g
09:48:53 <lambdabot> let {($0 (0 ((.) . (.))) $0 .: $0) (f ($0 (0 undefined) $0) $0 (g ($0 (0 undefined) $0) $0 $0))} in f .: g :: Int -> [Int] -> Bool
09:49:14 <ski> *that* works ;)
09:50:01 <ski> Odiseo : functional does indeed have variables. it just isn't the same concept as variables in imperative programming languages
09:50:17 <ski> (functional variables is a lot more like variables in mathematics)
09:50:20 <Odiseo> awesome
09:50:29 <Odiseo> quite like prolog vars?
09:50:42 <ski> yes, they have many similarities
09:50:49 <Odiseo> excelent
09:51:02 <ski> though prolog variables can also be "unknown"
09:51:15 <Odiseo> functional ones can't?
09:51:35 <ski> neither can be "changed" to another value, once it's value is known
09:51:54 <Odiseo> If i use parentheses and use -> inside it means like a function prototype isn't?
09:52:16 <Odiseo> (i'm asking cause haskell was whining about it)
09:52:28 <ski> in functional programming languages, it is customary to introduce a value to bind to the variable, whenever a variable is introduced
09:53:43 <ski> Odiseo : the thing above I did to "remove" the variables from the code, should not be used when the code gets less easy to understand ..
09:54:34 <ski> Odiseo : sometimes this, so called "points-free" style, can be clearer, but it can easily get less clear and harder to read/understand ..
09:54:51 <ski> hmm
09:55:06 <Riastradh> Some people prefer to call it 'point-less' style.
09:55:13 <ski> "use parenthesis and use -> inside ..." ?
09:55:16 <ski> example ?
09:56:43 <Odiseo> sorry I was checking the theory... i'm back
09:56:56 <Odiseo> like, f::(a->b->b)->Int->Int
09:57:03 <Odiseo> (a->b->b) represents a function right?
09:58:50 <ski> yes
09:59:12 <ski> so the first argument of f should be a function with such a type
10:00:06 <ski> but i'd suppose that you could call the whole type in "f :: (a->b->b)->Int->Int" a "function prototype", if you like
10:00:22 <Odiseo> aha
10:01:07 <ski> it indeed is a function type
10:01:14 <ejt> Odiseo: -> is right assiciative, so  a -> b -> c is parsed as (a -> (b -> c)), ie. a function that takes an 'a' and returns a function that takes a 'b' and returns a 'c'
10:02:07 <ski> which is often shortened to "function taking 'a' to 'b' to 'c'" or just "function taking 'a' and 'b' to 'c'"
10:02:10 <Odiseo> that's weird i must say
10:02:24 <ejt> it's very beatiful
10:02:33 <Odiseo> is it?
10:02:44 <ejt> eg. add :: Int -> Int -> Int
10:02:50 <ski> ejt : (but a little unsymmetric)
10:02:53 <ejt> (add 2) :: Int -> Int
10:03:00 <ejt> (add 2 3) :: Int
10:03:51 <Odiseo> what do you call the ::, starting of proto?
10:03:59 <Odiseo> how
10:04:14 <ski> 'has type' or 'is in' or 'inhabits'  e.g.
10:04:39 <ibid> "is a" :)
10:05:25 <ski> Odiseo : the normal term for a thing like "add :: Int -> Int -> Int" in haskell is "type signature", but i think most people will understand you if you use "prototype" ..
10:05:29 <ski> ibid : yes
10:06:47 <Odiseo> I find proper talking easier to make questions cause some people may feel hurt if I destroy the language I still don't know how to use:)
10:07:35 <Odiseo> question, where can I find a list of the internal stuff haskell has, like (+) and ++, and that stuff?
10:07:44 <Odiseo> (stuff it's not the proper term but...)
10:07:59 <ibid> the report
10:08:10 <Odiseo> report?
10:08:17 <ibid> its prelude appendix
10:08:40 <ski> also, i think, if you use hugs or ghci, you can type :n to see the types of all names in scope
10:09:02 <ski> also, in hugs, you can browse through the Prelude and the other libs
10:09:53 <ibid> http://www.haskell.org/definition/
10:09:55 <ski> Odiseo : the report (definition of language) is at http://www.haskell.org/onlinereport/
10:10:17 <Odiseo> wow excelent
10:10:30 <Odiseo> and yes, i'm using hugs, excelent under linux
10:11:00 <ski> i think you can see the path to the Prelude (and other libs) when hugs loads them
10:11:46 <Odiseo> doing :n brings a lot of stuff, but can't see ++ and those
10:12:18 <ski> it should be in the Prelude
10:12:55 <Odiseo> this superior order functions seem pretty useful
10:13:01 <ski> hmm, well :n, in hugs just shows names, not types
10:13:21 <ski> you can also use browse, :b
10:14:00 <Odiseo> oops, I have a file loaded so browse shows me only that...
10:14:15 <ski> do :m Prelude to switch module focus
10:14:29 <Odiseo> I was about to ask that
10:14:55 <Odiseo> oh that's awesome!
10:15:37 <Odiseo> can I load more than one file?
10:15:48 <ski> (i hope you know that :? shows available commands)
10:15:57 <ski> load, yes
10:16:00 <Odiseo> yes, It says that at the beggining:)
10:16:14 <Odiseo> although most people don't read the beggining
10:16:42 <ski> i don't think, though, that you can have more than one module in focus  (not sure about this)
10:17:13 <Odiseo> not in focus, I meant lots of modules load and switching?
10:17:30 <ski> yes
10:18:15 <ski> you can load many modules at the same time with :l
10:18:45 <ski> and (if not changed), it recursively loads all the modules that are imported from those and so on
10:19:00 <ski> you can add modules to the already loaded with :a
10:19:03 <Odiseo> and if I don't specify argument then it gets rid of the module right?
10:19:14 <Odiseo> found that by myself:)
10:19:41 <ski> (if you do :l, it flushes out the previous ones and starts over from the ones given after the :l)
10:19:51 <ski> yes
10:20:08 <ski> :l reverts to just Prelude (which is loaded on default)
10:24:59 <Odiseo> now infinite lists:)
10:25:39 <ski> what about them :)
10:25:59 <Odiseo> trying to learn:)
10:26:14 <bring> [1..]
10:26:19 <Odiseo> that's all?
10:26:23 <Odiseo> i'm done:P
10:26:35 <bring> well, yes, if you only want a list of ones
10:26:56 <Odiseo> or 2's, [2..]
10:27:04 <Odiseo> now i'm feeling the power...
10:27:06 <ejt> list _from_ 1 up
10:27:33 <bring> oops, sorry
10:27:51 <bring> repeat 1
10:27:57 <ejt> you can do nice things like use the sieve of eratosthenes (sp?) to define a list of _all_ primes
10:27:58 <bring> will give you a list of only ones
10:28:17 <ejt> and then lookup the nth prime in this list
10:28:34 * bring is tired
10:28:42 <Odiseo> ejt, the example from where i'm trying to learn infinite lists gives the case of primes and first prime...
10:29:01 <Odiseo> prime non minor than m, that calculates
10:29:16 <ejt> y, it's a good example
10:30:21 <bring> or [1,1..]
10:30:35 * bring is flogging a dead horse
10:33:12 <Odiseo> this is a nice example, it gives 35 as a prime number, that's something new
10:33:38 <ejt> !
10:34:08 <ski> 35 might me a prime in some unusual field
10:34:20 <Maddas> haha
10:34:20 <ejt> bring: let ones = 1 : ones
10:34:26 <Odiseo> no, my bad, don't know how to read
10:34:55 * Odiseo wonders if the biggest merssene prime was found this way... anyone knows?
10:34:57 <ski> in Compex integers, 5 isn't a prime
10:35:09 <ski> 5 = (2 + i)*(2 - i)
10:35:19 <Odiseo> In riemann geometry paralel cross:)
10:35:34 <ski> what way ?
10:35:42 <ski> by reading worng ?
10:35:42 <Odiseo> focus!
10:35:56 <Odiseo> what?
10:36:20 <ski> "* Odiseo wonders if the biggest merssene prime was found this way... anyone knows?"
10:36:22 <Odiseo> never though of that in complex integers have to admit:)
10:36:31 <Odiseo> ski, no, with functional programming:)
10:36:43 <Odiseo> worng:P
10:37:11 <ski> yes "worng". what's worng with that ?
10:37:25 <Odiseo> nothing is worng, srory
10:37:38 <ski> ;)
10:38:14 <bring> ejt: filter (==1) (cycle [1..42])
10:38:35 <bring> who can come up with the worst way to create an infinte list of ones?
10:39:40 <ejt> map (const 1) [1..]
10:40:10 <bring> ejt: haha
10:40:11 <Igloo> Define <= on implementation goodness and I might give it a shot  :-)
10:40:30 <Igloo> s/implementation goodness/implementations for goodness/
10:41:17 <viblo> zipWith (-) [2..] [1..] 
10:41:18 <Odiseo> (x:xs) matchs (1:[]) right?isn't like prolog in that way isn't?
10:41:43 <Igloo> That matches, yes
10:41:49 <bring> goddness (badness rather in this case) would have to be deficed by community consensus I guess
10:41:49 <Odiseo> fascinating
10:41:55 <phubuh> map (let dup x = (x,x) in uncurry div . dup) $ repeat 150
10:41:57 <Odiseo> (i'm running out of adjetives)
10:43:03 <ski> Odiseo : it is like in Prolog, only different syntax
10:46:05 <ski> map (let foo 1 = 1; foo n = foo (if even n then n `div` 2 else 3 * n + 1) in foo) [1..]
10:46:15 <ski> :)
10:46:37 * ejt applauds
10:46:57 <ski> of course, nobody knows if that qualifies
10:46:59 <Odiseo> ski, and without backtracking
10:47:41 <ski> Odiseo : what do you mean by "without backtracking" ?
10:49:06 <ski> was the other solutions using backtracking in some stronger sense than mine ??
10:49:22 <Odiseo> no, just quoting
10:49:32 <Odiseo> I mean, does haskell has backtracking?
10:49:42 <ski> it depends on what you mean
10:50:26 <Odiseo> can i do combinational stuff with haskell?
10:50:37 <Maddas> ski: haha
10:50:44 <Maddas> ski: Nice method of getting ones :-)
10:50:46 <ski> (and perhaps this thing you are thinking about is really "(don't know) nondeterminism", of which "backtracking" is an implementation technique)
10:51:08 <ski> Odiseo : you can do some Prolog-like things, yes
10:51:58 <ski> but there really isn't any nondeterminism (effect) in the language
10:52:55 <ski> Maddas : yes, thinking so ?  :)
10:54:20 <ski> Odiseo : instead of having a backtracking predicate (or function), you have a function returning a list. but because the list is usually lazy constructed, it can sure get a "backtracking-feel" (and execution)
10:55:08 <Odiseo> but wasn't lazy meaning that the end of the list isn't used?
10:55:31 <Odiseo> I don't understand the relation between lazy list and backtracking, which would be like combinational form
10:56:12 <ski> I don't quite understand what you mean by "combinational form" :)
10:57:33 <Odiseo> like, if I have 3 clauses, color(white), color(red), color(blue), and do, whatever(functor(X,Y,Z)):-color(X), color(Y), color(Z). I get all the combinations of colors
10:58:44 <Marvin--> that's because you have clauses and relations rather than functions
10:58:51 <ski> det går att göra liknande i haskell, ja
10:58:54 <Riastradh> Go shift & reset!
10:59:15 <Marvin--> ski: wrong language ;)
10:59:34 <ski> color = [White,Red,Blue]
10:59:55 <ski> whatever = [Functor x y z | x <- color, y <- color, z <- color]
11:00:03 <ejt> there's a nice article on doing prolog like stuff in 'the fun of programming'
11:00:11 <Odiseo> url plz?
11:01:37 <ejt> the authors are Michael Spivey and Silvija Seres, 'Combinators for logic programming'
11:02:00 <ejt> it's probably a bit advanced if you're just starting out, but it shows it can be done
11:03:30 <ski> Marvin-- : "wrong language" ??
11:03:41 <Marvin--> <ski> det gÃ¥r att gÃ¶ra liknande i haskell, ja
11:04:03 <Marvin--> ski: wrong *natural* language, not wrong *programming* language :-)
11:04:39 <ski> Marvin-- : ah. forgot to swap languages again, when swapping focus channel  :)
11:04:45 <Odiseo> Ich bin deustche... nain... jokein:P
11:05:23 <ski> (for the record, "det går att göra liknande i haskell, ja" is "something similar is possible in haskell, yes")
11:06:41 <Odiseo> what language is that?
11:06:51 <Marvin--> Swedish
11:06:52 <phubuh> Swedish.
11:06:52 <ski> Odiseo : swedish
11:07:01 <Marvin--> Odiseo: there's a bunch of us here :)
11:07:07 <Odiseo> I see
11:07:27 <Odiseo> I bet i'm the only one from Argentina...
11:08:39 <Odiseo> is there some specially made tutorial describing infinite lists?cause my theory paper it's crappy, it explains just an example and it's not useful
11:09:17 <ski> Odiseo : you can also see http://www.cs.chalmers.se/~peb/papper/logvar-haskell.ps.gz "Typed Logical Variables in Haskell"
11:10:25 <ski> Odiseo : IIRC i think i've seen someone else from Argentina here, sometime. BIMBW
11:10:35 <ejt> Odiseo: it's lazy evaluation you need to understand, infinite lists are self explanitory in light of that
11:10:53 <Odiseo> it names lazy evaluation but it doesn't explain
11:11:03 <ski> ejt : well, it can of course help to look at some common idioms
11:11:38 <ejt> ski: yes of course
11:13:00 * Darius thinks eager evaluation would require more explanation than lazy evaluation to somenone new to programming.
11:13:23 <Odiseo> I don't know if it's something wrong with my fonts or what, I keep seing the .ps docs with broken fonts, I can read them but it looks ugly
11:14:07 <ejt> Odiseo: what other programming languages do you know ?
11:16:04 <Odiseo> C, C++, Perl, Php, smalltalk, prolog
11:16:20 <Odiseo> but functional I find very close to prolog, that's why I try to relate
11:16:25 <Odiseo> both declarative paradigms
11:17:36 <ski> recursion, e.g., is stressed/important in both logic and functional progamming languages
11:19:30 <Odiseo> yes, I've made the stack suffer sometimes in C:)
11:19:48 <Odiseo> C:) looks even funnier than prolog:)
11:20:10 <ski> {}:), then ?
11:20:58 <Odiseo> we're all cucu
11:20:59 <ibid> }}:)
11:23:00 <Odiseo> how the Eq a=> works?I know it does an equality that allows me to compare elements when I work with a [a] etc... but, Does it have some internal comparisson algorithm?or am I stablishing this comparisson as I do Eq a=>?
11:23:22 <esap> odisco: instance declarations.
11:24:01 <ski> ibid : there was a channel #{} that clog logged. maybe it {} a prog.lang.
11:24:18 <ibid> heh
11:24:33 <ski> s/it {}/{} was/
11:24:50 <ejt> Odiseo: Eq a means that a is a member of the class Eq (beware the Haskell concept of classes is v. different from C++ etc)
11:25:48 <ejt> it's just saying a must have an equality operator
11:26:27 <Odiseo> aha, it stablishes the relation automagically then?
11:26:34 <Odiseo> esap, odisco?
11:26:45 <ski> "stablishes the relation" ?
11:27:09 <esap> odiseo: sorry, typo :-) I'm having trouble distinguishing 'e' and 'c' in my screen.
11:27:24 <Odiseo> esap, no problem, I though it was funny
11:27:32 <Odiseo> ski, establish the relation?
11:27:40 <Jezze> Could someone tell me what the biggest difference is between haskell and other functional languages?
11:27:59 <Maddas> Odiseo: Classes are added explicitly and the comparison operator for that class is also defined.
11:28:03 <ski> Odiseo : yes. what do you mean by that ?
11:28:13 <Maddas> Odiseo: You can also add your own classes
11:28:56 <ski> Jezze : pure (well Clean is too (perhaps Hope also)). monads (are heavy in it). and laziness (which Clean also have)
11:29:10 <Jezze> ok cool
11:29:26 <Darius> typeclasses would be another major difference.
11:29:36 <ski> mm, yes
11:30:08 <Odiseo> can I take a look at those classes?in what language is haskell made?
11:30:28 <Odiseo> nevermind, have the source in C:)
11:30:40 <ski> the classes is written in haskell, of course
11:30:46 <ejt> Odiseo: some classes are declared in the prelude
11:30:53 <ejt> worth reading
11:31:06 <ski> haskell is made in (somewhat formalized) natural language (just see the report)
11:31:22 <Odiseo> I cry when people indent with 4 spaces instead of 8 spaces tab
11:31:39 * ski usually indents with 2 spaces
11:31:50 * Maddas usually indents with 4 spaces
11:31:51 <Odiseo> tell me you're joking
11:31:55 * ibid usually lets emacs indent
11:31:57 <Riastradh> I cry when people use tabs instead of spaces.
11:32:11 * ibid cries when people make such a fuss about indentation
11:32:12 * ipkiss too
11:32:14 * Odiseo recommends /usr/src/linux/Documentation/CodingStyle :)
11:32:19 <Jezze> 2 spaces for me as well  =)
11:32:20 <Odiseo> now we all cry?
11:32:26 <Riastradh> Actually, no, I just do M-< C-SPC M-> M-x indent-region.
11:32:42 <Maddas> I do gg=G :)
11:32:46 <Odiseo> 2 spaces?can't see anything with 2 spaces
11:32:47 <Riastradh> Er, s/indent-region/untabify/1.
11:33:36 * Darius uses 2 or 3 spaces for Lispy languages and 4 for everything else.
11:34:12 <ibid> it's best to be indentation agnostic, so that one can read lots of styles
11:34:20 <ejt> can we have the vi vs. emacs argument next please ;)
11:34:22 <Odiseo> the main thing is that 4 spaces usually makes that programmers use more than 3 levels of indentation, and that's no good
11:34:30 <Odiseo> sorry ejt, i've started this
11:34:32 <Darius> ibid: I have no problem reading it.
11:34:49 <Riastradh> I cry when people write code like that of Ashley Yakeley; otherwise I really don't care how people indent.
11:34:53 <Darius> ejt: In the Haskell community, vi and emacs users seem to get along well.
11:34:55 <Odiseo> but I vote for a rms vs linus discussion
11:35:50 <Marvin--> isn't it normally RMS vs ESR?
11:36:00 <ibid> rms vs linus is boring, what Marvin-- said :)
11:36:37 <Riastradh> How about a static versus dynamic typing debate?
11:36:43 <Maddas> I vote for Dschingis Khan versus Muhammed Ali
11:36:58 * ibid votes for church vs turing :)
11:37:31 <Odiseo> Marvin--, I don't like Raymond, so, I rather focus the discussion between linus and rms, heh, besides they hate each other
11:37:40 <Maddas> ibid: Haskell versus Curry!
11:37:42 * ski votes for category theory versus zermelo-fraenckel set theory
11:37:43 <Maddas> (yes, yes, I know.)
11:38:05 <Darius> Set theory is just 0-Category theory.
11:38:12 * ski also votes for a classical versus intuitionisical/constructivistical logic
11:38:28 * Odiseo votes for kings vs spurs... 
11:38:37 * Darius votes for constructivist v. constructivistical.
11:38:43 <Maddas> ski: intuitionistical? whoa, now that's one word :)
11:38:44 <ibid> ZFC versus that other theory, what's it called, von neumann & gödel & bernays?
11:38:46 <Riastradh> How about anarchism versus socialism?
11:38:55 * ski laughs
11:38:56 * esap votes for control operation vs. lambda abstraction
11:39:01 <Odiseo> or democrat vs republican
11:39:06 <Darius> Riastradh: You mean statist socialism
11:39:08 <Riastradh> Odiseo, nah, there's no difference there.
11:39:25 <ibid> frege vs russell
11:39:43 <Riastradh> S & K versus X?
11:40:08 <ibid> resolution vs tableaux?
11:40:28 <ski> Darius : authoritarian socialism
11:41:03 <esap> axiom of choice vs. continuum hypothesis
11:41:10 <ibid> heh
11:41:46 <ibid> us vs them
11:41:55 <ski> call-by-value versus call-by-name
11:42:03 <esap> duality vs. inverse
11:42:05 <Darius> pure v. impure
11:42:17 <esap> lazy vs. non-strict
11:42:18 <Maddas> Serif versus sans serif
11:42:18 <ski> monad vs. comonad
11:42:22 <ejt> perhaps we should just go over to #ocaml and pick a fight there
11:42:30 <Maddas> haha
11:42:50 <earthy> what is the difference between lazy and non-strict? are the concepts even comparable?
11:42:51 <Maddas> camels versus mathematicians?
11:42:57 <ski> haha
11:43:10 <esap> coffee vs. comathematicians?
11:43:18 <earthy> decidable logic vs undecidable logic
11:43:19 <Darius> snakes v. ladders
11:43:20 <ski> flat versus round earth ?
11:43:28 <Darius> hollow earth!
11:43:33 <earthy> science vs faith
11:43:41 <ski> Darius : heretic !
11:43:53 <Riastradh> Flat _and_ hollow earth!
11:44:06 <ski> that'd be interesting
11:44:39 <Riastradh> Klein earth.  (whatever the right spelling is)
11:44:42 <ski> trolls, elves and fairies versus aliens and UFOs
11:44:43 <Odiseo> when a a line call recursively the same function, it firsts keep going and check the next statement for the function or it starts all over?(it starts all over right?)
11:45:00 <Odiseo> still with this?I've created a monster
11:45:13 <esap> monsters vs. elves
11:45:20 <ski> helping Odiseo versus not helping Odiseo
11:45:21 <Maddas> holy war versus flamewar!
11:45:26 <ejt> Odiseo: not sure what you mean ?
11:45:28 <Maddas> to be vs not to be
11:45:29 <Odiseo> ski, like the first one
11:45:44 <Vulpyne> Odiseo: It only reaches the line after the recursive call after the recursive call returns.
11:45:45 <esap> rec X.not(X) vs. fix(id)
11:45:52 <Vulpyne> (Same as calling any other function.)
11:46:02 <ski> variables versus points-free
11:46:08 <Odiseo> ejt, like this, if I do this:contarfrase (x:y:zs) (a:b:cs) | x == a && y == b = 1+contarfrase (x:y:zs) cs (pretty horrible isn't?) and then I have another contarfrase line after that, it continues with the next or it calls the first one?
11:46:27 <Odiseo> Vulpyne, aha
11:46:32 <Odiseo> all right
11:46:49 <Odiseo> jenna jameson vs hilary clinton?
11:47:04 <Odiseo> tray bizzarre
11:47:11 <earthy> Paris Hilton vs Paris Hilton? :)
11:47:17 <ejt> Odiseo: it'll call the first one if the guard matches
11:47:29 <Marvin--> earthy: dear god, now you're scaring me
11:47:33 <ski> Shub-niggurath versus Nyarlathotep
11:47:47 <Odiseo> aha, ok
11:47:49 <ski> Bush versus Cthulhu
11:47:53 <Odiseo> keep working then
11:47:55 <Marvin--> meh, still no reply from Maarten
11:48:05 <earthy> Marvin--: seen the Saturday Night Live sketch with miss Hilton?
11:48:11 <ski> Marvin-- : Fokkinga ?
11:48:15 <earthy> de Mol
11:48:22 <earthy> he's only in 3 days a week
11:48:28 <Marvin--> oh
11:48:29 <Maddas> Echnaton versus Julius Caesar
11:48:40 * earthy grinz at Maddas
11:48:46 <earthy> Asterix vs Caesar
11:48:55 <Maddas> Asterix vs Idefix :)
11:49:10 <ski> Orthodox versus gnostical christians
11:49:22 <Maddas> versus versus vs
11:49:24 <earthy> orthodox vs roman catholics
11:49:48 <Darius> vs versus v.
11:50:02 <ejt> this lot should probably go into the quotes page
11:50:11 <Darius> That would be obscene.
11:50:17 <ski> (my Orthodox was before the catolic/orthodox split)
11:50:31 <earthy> ski: that I know :)
11:50:50 <earthy> iLink vs Firewire
11:51:03 <Maddas> Firewire vs Firewall
11:51:06 <ski> Ireneaus versus Valentinos
11:51:12 <earthy> tired vs wired
11:51:23 <Maddas> deity vs diety
11:51:34 <earthy> iran vs irak
11:51:50 <ski> floppy disks versus CD-RW
11:51:56 <Riastradh> Gnostic versus gnocci.
11:52:03 <Odiseo> oh for crying at loud
11:52:07 <earthy> USB key vs PCMCIA CF adapter
11:52:10 <Odiseo> this has gone too far
11:52:21 <Marvin--> ski: neither, there are usb memory sticks
11:52:23 <ski> 5'1/4'' versus 8''  floppies  :)
11:52:25 <Riastradh> Going on versus discussing Haskell.
11:52:36 <earthy> Odiseo: then don't start deviating from the holy standard of 8 spaces for a tab
11:52:42 <earthy> s/tab/indent
11:52:48 <earthy> tab vs spaces  to indent!
11:52:48 <ejt> and so the finest haskell minds finally melted down
11:52:51 * Maddas agrees completely with Riastradh 
11:52:56 <Odiseo> never imagined it would go that far
11:53:10 <earthy> monadic vs point-free style
11:53:42 <earthy> anyway, back to playing 'round with initrd
11:53:43 <Marvin--> now if I only knew how to get my usb stick to work nicely with the Solaris machines at the institution
11:53:51 <earthy> marvin--: just a sec
11:53:54 <Marvin--> earthy: you mean point-free vs pointless? :)
11:54:07 <earthy> marvin: :)
11:54:29 <esap> point-full?
11:54:47 <ski> Odiseo : butterfly-effect versus non-chaotic
11:54:53 <earthy> marvin--: if you're allowed to mount the usb device as pcfs
11:55:01 <earthy> and the USB key is not too far from standard
11:55:03 <earthy> that should work
11:55:22 <earthy> ofcourse, this presupposes you can moutn ;)
11:55:37 <Marvin--> I can't
11:55:38 <Darius> http://www.geocities.com/inversedearth/
11:55:56 <Marvin--> I guess I rely on the tech support people setting up some program for doing it
11:56:08 <earthy> marvin--: the automounter
11:56:16 <earthy> and nope, they probably wont
11:56:17 <Marvin--> hm
11:56:21 <ski> Darius : read "Elven star" ?
11:56:32 <earthy> or allow usermounting and useraccess to the usb device
11:56:43 <earthy> that *is* possible, but not necessarily done
11:56:48 <earthy> check /etc/fstab
11:57:02 <Marvin--> I wonder if volcheck can do it
11:57:25 <Darius> ski: No.
11:57:34 <Marvin--> I guess it could be slightly complicated by the fact that it's a Sun Ray
11:57:53 <Marvin--> and there IS no /etc/fstab
11:58:04 <earthy> err.. /etc/vfstab ;)
11:58:14 <earthy> `slightly complicated' he says
11:58:29 <ski> Darius : (2nd book in Death Gate Cycle by Margaret Weis & Trazy Hickman). The world in it is a very large hollow sphere with 4 suns in the centre
11:58:30 <Marvin--> heh
11:58:31 <earthy> do you even have any idea what a sunray is? :)
11:58:48 <earthy> it has something to do with `dumb terminal'
11:59:06 <Marvin--> yeah, we have five silent terminals in this lab
11:59:17 <Odiseo> what kind of statement it's error, cause doesn't lookup the type of the function, is it like 'universal' or something related?
11:59:41 <Marvin--> they have usb keyboards and mice so obviously it could be done
12:00:03 <earthy> no
12:00:04 <earthy> ;)
12:00:10 <ibid> Odiseo: parse error
12:00:14 <Marvin--> well, theoretically
12:00:15 <Odiseo> earthy, so what you mean is that the galaxy it's in the center?like an atom?
12:00:37 <Odiseo> ibid, oh
12:00:44 <earthy> marvin--: not even.
12:00:52 <Marvin--> shucks
12:00:56 <Odiseo> earthy, I remember men in black, the size doesn't matter, the galaxy
12:01:05 <earthy> the OS runs on the remote system.
12:01:19 <earthy> we had Sun Rays as the FHQ machines at HAL
12:01:45 <earthy> very cool, rip out the smartcard, insert it somewhere else, have your complete session back
12:01:53 <Marvin--> yeah
12:01:56 <Marvin--> ... if I had a smartcard
12:02:26 <Odiseo> earthy, who's the guy behind that theory?
12:02:32 <Odiseo> sorry, hypothesis
12:02:51 <earthy> however, this would completely *break* if the system were to have to unmount and remount as well
12:03:09 <ski> Odiseo : perhaps you mean Darius ?
12:03:13 <Marvin--> hm
12:03:20 <earthy> as it would have no way of enforcing that
12:03:25 <Odiseo> I though earthy was the one that posted
12:03:26 <Marvin--> true
12:03:26 <earthy> you put in the usb key
12:03:29 <Odiseo> sorry
12:03:31 <Odiseo> thanks ski
12:03:32 <Odiseo> Darius, ?
12:03:37 <earthy> posted what? :)
12:03:44 <Marvin--> well, I'd settle for getting it to work with the blade machines
12:04:00 <ski> earthy : the hollow earth link
12:04:07 <earthy> ah, no, not me
12:04:14 <earthy> marvin--: that is possible
12:04:18 <Odiseo> now where's the gravity then?we should drill and see then... just start bombing trough the center of earth
12:04:36 <earthy> odiseo: gravity does not preclude a hollow earth
12:04:42 <Marvin--> hollow earthy
12:05:00 <Darius> Odiseo: I don't know who first thought of it.
12:05:01 <ski> hehe
12:05:50 <ski> wasn't there some other hypothesis about hollow earth, but with us still on the outside, and holes at the poles
12:06:19 <Odiseo> earthy, what do you mean?
12:06:46 <Darius> ski: There was some crazy page that had holes in the poles when I put hollow earth into google.
12:06:56 <Marvin--> "They got a senior chairwoman to demonstrate the new system to the troops. Male ego stopped anyone claiming that Linux was difficult to use, once they'd seen that the 'weaker sex' could master it."
12:07:01 <ejt> gravity for a hollow sphere drops off at 1/r^2 same as a solid one
12:07:36 <earthy> ejt: exactly.
12:07:38 <Odiseo> Darius, that's a theory behind a testimony of a pilot that says it saw something like that, and that in the center of the poles there were holes with tropical jungles in it, altough there's a book about it too
12:07:49 <earthy> as long as the mass is equal it doesn't matter that it's hollw
12:08:06 <earthy> (the center of gravity of the total mass will be identical)
12:08:10 <earthy> (as it's a sphere)
12:08:16 <Odiseo> but we wouldn't have a core
12:08:26 <earthy> we don't need any
12:08:30 <Odiseo> and what would be in the center?antimatter?
12:08:35 <earthy> we just need an outer skin that is heavy enough
12:08:40 <earthy> odiseo: absolute vacuum
12:08:51 <earthy> or some gase
12:08:54 <earthy> or whatever
12:09:07 <Odiseo> +100 planets has been discovered last 10 years, some with oxygen (something like that), you mean that's inside not outside?
12:09:15 <ejt> now gravity _inside_ a hollow sphere is more interesting ... I seem to remember that you'd be weightless :)
12:09:19 <Odiseo> it would be an amazing change of paradigm...
12:09:34 <earthy> ejt: not quite
12:09:59 <earthy> you'd actually still be pulled to the center of gravity of the entire mass
12:10:08 <earthy> afaicr
12:10:09 <ejt> I'm sure that was the answer I got in calculus class many years ago
12:10:10 <Odiseo> but the center has to be inside
12:10:15 <earthy> odiseo: yes
12:10:28 <Odiseo> so we will be pulled trough the sun per say
12:10:38 <earthy> ?
12:10:41 <earthy> why?
12:10:42 <Odiseo> which is not nice unless you love taint
12:10:53 <ski> Odiseo : also, the "Valérian and Laureline" album "World without Stars" had a hollow planet
12:11:04 <Darius> If you dug all the way through the core in the model you'd come out on the other "side" that you'd expect with a spherical earth.
12:11:06 <Odiseo> shouldn't be the sun still the center and the earth rotating around?
12:11:23 <Odiseo> I always though that If I drill real hard I could led to china:(
12:11:29 <Darius> Odiseo: It's not the sun or the galaxy that's in the "center", it's the entire universe.
12:11:57 <ski> Darius : IIRC the idea with holes in the poles is at least some decades old. perhaps even some decenniums
12:12:09 <earthy> decades, ski
12:12:16 <Odiseo> I'm wasting time in something that it's not even close from some weird truth... i better back to work
12:12:24 <Odiseo> (that's what colon said?:P)
12:12:40 <earthy> `work'
12:12:49 <earthy> hm. yeah. finish dinner and try to get 2.6.2 to boot
12:12:53 <Darius> Odiseo: As far as general relativity is concerned, it's correct.
12:13:10 <Odiseo> you mean einstein though about that?
12:13:33 <ejt> earthy: you've been having trouble with 2.6.2 ?
12:13:36 <Darius> At some point he probably did.  He certainly thought of the properties that lead to it being correct.
12:13:43 <Odiseo> if that would be true then riemann would be wrong with his angle theory:)
12:14:02 <Odiseo> (not talking about the riemann sphere, talking about something else)
12:14:04 <Darius> The thing is that in the theory light does not travel in "straight" lines.
12:14:17 <Odiseo> and what would be outside the sphere then?outside earth?to keep the balance?
12:14:48 <Darius> There is no "outside" the sphere, as I said earlier you'd come out where you'd expect to on a spherical Earth.
12:14:51 <Odiseo> Darius, I've learned that in a photo in which einstein was playing against steffi graff in a universe a la einstein, and of course he won:)
12:15:07 <earthy> ejt: nope, but I have to build a custom initrd as I run root from lvm
12:15:23 <Odiseo> parallel question, how can I manage fractional numbers with functional?is there some kind of cast?
12:15:24 <ejt> are you using lvm2 then :)\
12:15:36 <earthy> ejt: not currently that i know of :)
12:15:56 <Odiseo> 2.6.2 is non preemptive?or optional still?
12:16:04 <ejt> LVM1 doesn't work with 2.6
12:16:18 <ski> @type toRational
12:16:19 <lambdabot> toRational :: Real a => a -> Rational
12:16:21 <ejt> Odiseo: optional, recommended for desktops
12:16:41 <earthy> ejt: I gathered something like taht
12:16:47 <ski> or (% 1)
12:16:51 <earthy> however, what do I do for LVM migration to 2.6? :)
12:17:06 <ski> @type (%1)
12:17:07 <lambdabot> flip (%) 1 :: Integral a => a -> Ratio a
12:17:14 <Odiseo> thanks ski
12:17:15 <ejt> earthy: LVM2 understands the LVM1 metadata, so just rebuild the LVM2 tools
12:17:39 <ejt> and consider upgrading to LVM2 metadata when you've got it all working
12:17:59 <ejt> make sure you select device-mapper in the kernel config
12:18:32 <ski> (is LVM = Lazy Virtual Machine ?)
12:18:40 <ejt> logical volume manager
12:18:46 <ski> aha
12:18:47 <Odiseo> ski, the thing is that i'm using Ints but I have a division and has to return Rational
12:18:47 <earthy> ejt: thanx
12:18:50 <Odiseo> that's the deal
12:20:07 <ski> Odiseo : try to say "i % 1" or "i0 % i1"  where i,i0,i1 :: Integer
12:20:49 <Odiseo> I don't understand
12:20:53 <Odiseo> i%1?
12:21:06 <ski> @type (15 :: Int) % 1
12:21:06 <lambdabot> 15 % 1 :: Ratio Int
12:21:11 <ejt> earthy: snapshots cannot be upgraded, you'll have to drop them first
12:21:26 <ski> @type ((15 :: Integer) % 1) :: Rational
12:21:26 <lambdabot> 15 % 1 :: Rational
12:21:28 <earthy> I don't do snapshots currently
12:21:29 <Odiseo> it says:ERROR "ejercicios":81 - Undefined variable "%"
12:21:48 <ejt> earthy: probably wise with LVM1
12:22:28 <ski> Odiseo : it's in module Ratio, i believe  (at least in ghc, perhaps it's still in Prelude in hugs)
12:22:39 <ejt> You'll have to pick up my -udm tree if you want to use them in 2.6
12:23:27 <Odiseo> all this mess to divide 2 Int?i only want the Int part anyway
12:23:39 <ski> why didn't you say so ?
12:23:54 <ski> use e.g. "14 `div` 7"
12:24:04 * earthy ponders
12:24:26 <ejt> Odiseo: (backticks around a function name makes it infix)
12:24:43 * ski thought Odiseo wanted rationals to compute with
12:24:56 * earthy knew upgrading to 2.6 wasn't going to be trivial
12:25:41 <ejt> which distro are you using ?
12:26:05 <earthy> debian
12:26:06 <earthy> what else ;)
12:26:26 <ejt> good, that makes it simple
12:26:30 <ejt> just apt-get the tools
12:26:59 <ejt> you could try LVM2 on 2.4 and then make the jump to 2.6 if it worries you
12:27:13 <ejt> (you are using grub as well I hope ?)
12:27:14 <earthy> I'm not even sure I'm not running LVM2 already
12:27:21 <earthy> grub? nope, LILO still
12:27:52 <ejt> I like grub because it can read the filesystem so you can hunt out those old kernel images that worked
12:27:59 <earthy> (I had this wild pipedream of even trying to boot from LVM, but neither grub nor LILO allowed me to do that)
12:28:18 <ejt> some people are running root on lvm
12:28:33 <earthy> as am I
12:28:43 <ejt> sct got it working the other day
12:29:04 <earthy> but I haven't been able to read the kernel from a partition under LVM
12:29:09 <Odiseo> still can't work this out, ejt you mean \?|?
12:29:35 <Odiseo> oh `?
12:29:54 <earthy> ` indeed
12:30:05 <Odiseo> around what function?
12:30:50 <ejt> Odiseo: (div 14 7) is the same as (14 `div` 7)
12:31:39 <ejt> earthy: http://www.saout.de/misc/
12:32:09 <ejt> earthy: not used it myself but Christophe knows what he's doing
12:37:46 <earthy> hmz.
12:38:48 <earthy> this requires more thought than  would've thought
12:41:54 <Marvin--> all because of lvm?
12:44:06 <earthy> marvin--: yes.
12:44:21 <earthy> the system I'm doing this to has to be *stable*
12:44:32 <Marvin--> gee, almost makes me happy I don't use it
12:45:07 <earthy> oh, I didn't know about LVM1 to LVM2
12:45:27 <earthy> i.e. I thought it'd be a simple matter of dropping the right modules in to my initrd and rebooting to 2.6.2
12:45:37 <earthy> but given what ejt just told me that is not possible
12:46:05 <Marvin--> but...without lvm I should just be able to apt-get kernel-image-2.6 and reboot, right?
12:46:16 <earthy> marvin--: technically... yes.
12:47:36 <ejt> tools + module into initrd, plus the bootloader needs to know where the kernel is (LILO may have the patch in already for all I know)
12:50:47 <earthy> but LILO did not have those patches when I was playing with it
12:50:55 <earthy> so I have a simple partition for kernels and initrd's
12:51:19 <ejt> oh great, I thought you had boot on lv too
12:51:42 <earthy> ejt: never got that to work
12:52:03 <ejt> probably not worth the effort
12:53:16 <ejt> check out the debian init.d script that creates the device-mapper control dev, you'll need to do this before activating root
12:58:35 * earthy has *some* linuxing experience
13:00:05 <tzu> hi
13:00:37 <tzu> ski, can i bother you again?
13:03:42 <bring> shapr: new version of Haskell XmlRpc out, with hierarchical module names and support for introspection
13:06:03 <Lemmih> Is there a function which allows you to listen to a list of Handles?
13:08:35 * ski is back
13:08:39 <ski> ski : yes
13:09:05 <tzu> great :)
13:09:23 <tzu> i've been thinking over the function and i think i know the problem, but not yet how to fix it correctly
13:09:54 <tzu> again:
13:09:54 <tzu> getPrereqs :: Int -> [(Int,Int)] -> [Int]
13:09:54 <tzu> getPrereqs pid ((parent, child):xs)
13:09:54 <tzu> 	| parent == pid = [child] ++ getPrereqs child ((parent, child):xs) ++ getPrereqs pid xs
13:09:56 <tzu> 	| otherwise = getPrereqs pid xs
13:10:23 <tzu> i think the problem is that while i'm working through the list, i'm deleting parts of the original list so i don't have access to the other relationship pairs later
13:11:14 <ski> hm
13:11:23 <tzu> so, an idea would be to hand the full list seperately as extra variable which remains untouched, but i've got the feeling this wouldn't exactly be good style
13:12:38 <ski> Lemmih : hmm, i think there were some function called hSelect in some ghc (hierarchical ??) lib
13:14:02 <ski> tzu : you can do something like that
13:14:22 <ski> or better : have the org list around as a nonlocal
13:14:36 <tzu> hmm
13:14:36 <ski> wanna see example ?
13:14:40 <tzu> please
13:14:43 <Marvin--> tzu: what are you trying to do?
13:14:45 <ski> ok :
13:15:02 <ski> foo initialArg = bar initialArg
13:15:05 <ski>   where
13:15:13 <ski>   bar [] = ...initialArg...
13:15:24 <ski>   bar (x:xs) = ...x...xs...initialArg...
13:15:32 <tzu> Marvin--, essentially i'm trying to list all childs from a given node in a tree
13:15:32 <ski> tzu : understand ?
13:16:06 <tzu> and the tree is stored as (parent, child) in a list
13:16:36 <Marvin--> so you want all the vertices of the subtree rooted at a certain vertex?
13:18:13 <tzu> ski, so i walk the list until i've found a matching pair to the initial query, then list all it's childs using the 'foo' function?
13:19:26 <ski> tzu : i meant the a trick like initialArg could provide you with the original list passed to foo, even if bar has recursed itself a lot of times¨
13:19:30 <tzu> Marvin--, an example: i've got  alist prereqs = [(2, 1), (2, 3), (4, 1), (5,4), (6, 5), (6, 2)] :: [Prerequisite]
13:19:40 <tzu> that is, 2 depends on 1 etc
13:19:46 <tzu> or rather, is a child of 1
13:20:00 <tzu> ahh
13:20:07 <tzu> i understand ski
13:20:21 <tzu> Marvin--, and 3 is a child of 3
13:20:49 <tzu> so i'd like to see all childs of 1, which are 2, 3 and 6
13:21:01 <tzu> ah, and 4
13:21:02 <tzu> and 5
13:21:04 <ski> tzu : provided, of course that bar doesn't recursively call foo
13:21:05 <tzu> hmm
13:21:09 <tzu> lots :)
13:21:33 <ski> tzu : then, of course, initialArg is the argument passed to that (latest) invocation of foo
13:21:39 <Marvin--> tzu: right, so the vertices of the subtree rooted at 3 :)
13:22:24 <Marvin--> at least if it's a tree
13:22:36 <Marvin--> if it's a graph it gets trickier
13:22:45 <ski> tzu : (not to say that this can't be useful sometimes)
13:23:20 <tzu> thanks ski, i'll try this way
13:23:29 <tzu> no it's always a tree
13:23:31 <tzu> and has no cycles
13:24:35 <ski> tzu : for some more info, see
13:24:41 <ski> @wiki AvoidingParameterPassing
13:24:41 <lambdabot> http://www.haskell.org/hawiki/AvoidingParameterPassing
13:30:26 <ski> Lemmih : seems to be in package util, package Select
13:30:53 <ski> shapr : hej
13:31:05 <shapr> hej ski
13:33:30 <shapr> tzu: kanske du vill prova #haskell.se ?
13:33:48 <shapr> uh
13:34:02 <ski> shapr : kan tzu svenska ?
13:34:11 <shapr> for some reason I thought so...
13:34:12 <tzu> i don't really speak swedish, even though i'm in växjö right now :)
13:34:22 <Marvin--> heh
13:34:34 <Marvin--> what're you doing in VÃ¤xjÃ¶?
13:34:35 <tzu> but soon i'll right over hej and hejda
13:34:46 <shapr> tzu: you just moved to sweden?
13:34:54 <tzu> well probably when i set my keyboard so i can type a proper heyda
13:34:55 <ski> or on visit
13:35:06 <tzu> neither, i'm an exchange student
13:35:17 <shapr> cool, where from?
13:35:22 <tzu> so it's sort of visit :)
13:35:23 <tzu> austria
13:35:31 <shapr> spiffy
13:35:37 <tzu> i like it here :)
13:35:41 <shapr> yah, I agree.
13:35:44 <tzu> btw where are you two from?
13:35:54 <shapr> I've been in sweden for slighly more than a year.
13:36:29 <shapr> I'm from Alabama, but I think I'll be in sweden for at least four or five more years.
13:36:46 <Odiseo> ejt, thanks, I was using / to make the division, not div
13:36:54 <tzu> if your name from the /whois is correct, you're an emigrants child?
13:37:46 <shapr> tzu: no, but that's a whole 'nother story :-)
13:37:54 <tzu> ah :)
13:38:17 <tzu> just assumed because we've been told that about 1mil swedes emigrated to the midwest
13:38:27 <ski> tzu : i'm a native swede
13:38:40 <shapr> yes, that's true, but I was born with a different name, so...
13:39:00 <Marvin--> I'm a naive Swede
13:39:06 <shapr> I'm just naive ;-)
13:39:10 <Marvin--> insert a t wherever
13:39:33 <shapr> anyways, I'm wandering off to bed
13:39:38 <Riastradh> He's {insert vague gesturing} from Evian.
13:39:45 * shapr forsvinner
13:40:00 <tzu> night
13:40:25 <Odiseo> where can I see a real life example of functional programming?like some software used for something important
13:40:41 <Riastradh> What do you deem important?
13:40:46 <tzu> i've been thold the yahoo shops are coded in lisp
13:40:52 <tzu> dunno if they still live or not
13:42:11 <ecraven> it's been recoded in c++ and is substantially brokener :)
13:42:24 <Odiseo> important like, something a company uses
13:42:33 <ecraven> autocad
13:42:46 <ecraven> lots of virtual reality and 3d graphics tools
13:42:54 <Riastradh> Ericsson uses Erlang all over the place.
13:43:04 <ecraven> yea, that's an even better example
13:43:37 <Riastradh> They use it in lots of highly concurrently distributed telecom apps.
13:44:54 <Odiseo> but I can't see that code
13:45:07 <Riastradh> There's lots of Erlang code you can see.
13:45:10 <Odiseo> I want something to see what they've done and check the code (not saying I'll understand, but...)
13:45:35 <Riastradh> Freenode may at some point in the future be rewritten with Erlang.
13:46:19 <Marvin--> Odiseo: um, no, and there's lots and lots of commercial imperative code you cannot see either
13:49:52 <Odiseo> if there's some opensource I can take a look then I would be glad:)
13:50:19 <Riastradh> Look at erlang-projects.org and.
13:50:24 <Riastradh> ...er, s/and//1.
13:52:13 <Odiseo> who was the creator of this language?was really Curry haskell or he just did the logic?
13:52:34 <Odiseo> I shouldn't be asking that in here, should be checking in the web, sorry
13:54:39 <ski> haskell was specified by a committee, i think
13:56:02 <Odiseo> is it a standard?
13:56:09 <Odiseo> like c99 or so?
13:56:14 <Odiseo> ansi haskell?
13:56:23 <ski> Haskell98
13:56:35 <Odiseo> hence hugs98, get it
13:56:41 <ski> http://www.haskell.org/definition/
13:56:42 <Odiseo> s/get/got/gic
13:57:07 <ski> i'm not sure, but i think there's no ANSI standard (yet, at least)
13:58:04 <Marvin--> heck no, very few languages have an ansi standard
14:00:37 <Odiseo> though the spurs played today, gee, not until wed18, that's a long time
14:01:01 <ski> "spurs" ?
14:02:09 <Odiseo> san antonio, nba, spurs
14:03:29 * ski doesn't even know what "nba" is :-/
14:04:32 <tzu> basketball i guess
14:06:33 <Odiseo> kidding me?
14:06:47 <Odiseo> national basketball association
14:06:50 <ski> Odiseo : me ?
14:06:53 <Odiseo> nba, not babies allowed:)
14:06:59 <Odiseo> s/not/no/
14:07:02 <Riastradh> Odiseo, you know that 'national' refers to only one nation, correct?
14:07:06 * ski doesn't know very much about sport
14:07:29 <Odiseo> Riastradh, yes, but I though everybody would know about, nba, nfl, nhl, etc...
14:08:15 <Riastradh> Odiseo, that's a wildly generalized assumption to make, especially given that they exist only in the US...
14:08:36 <Odiseo> but there are players from all around the globe playing
14:08:46 <Riastradh> So?
14:08:51 <Odiseo> anyway, don't want to start another, vs stuff or something like that heh
14:10:23 <Maddas> Odiseo: Swiss football teams also have players from all around the globe playing, yet I doubt you know the names of the league they play in :-)
14:11:07 <Odiseo> I know the names of the coach in the japanesse kung fu team
14:11:11 <Odiseo> just kidding:)
14:12:05 <Odiseo> well, got to go, thank you for everything
14:12:26 <ski> min syrra har något dyslexi-aktigt
14:12:30 <ski> oh
14:13:06 * ski is angry at ircII !
14:13:19 <ski> Odiseo : bye
14:13:21 <Riastradh> Use irssi!
14:13:40 <ski> Is it windowed ??
14:14:19 <Riastradh> ?
14:14:55 <ski> Riastradh : does it run in own windows, or in a term ?
14:15:06 <Riastradh> It's a console client.
14:15:29 <ski> ok
15:09:43 <ski> hello DanC
15:10:23 <DanC> er.. hi... I'm trying to use some code I just downloaded... trying to figure out which end of this swish thing is up. http://www.ninebynine.org/RDFNotes/Swish/Intro.html#GraphDiff
15:10:39 <DanC> I've got hugs installed.
15:11:18 <DanC> the docs say "edit the Hugs registry key to..." but I'm on debian linux.
15:11:55 <ski> use the hugs registry to *what* ?
15:12:27 <DanC> "Edit the Hugs registry key to include additional
15:12:27 <DanC>                  directories for the HaskellUtils, Parsec, HUnit, Sort
15:12:27 <DanC>                  and Dfa libraries."
15:12:41 <ski> oh, paths
15:13:02 <ski> well you can tell more search paths by the option -P
15:13:23 <DanC> trying the obvious thing ($ hugs SwishMain.hs) produced: ERROR "SwishMain.hs" - Can't find imported module "ListHelpers"
15:13:31 * ski thinks that option also can be set from within hugs by the ":s" command
15:14:47 <DanC> $ hugs -P ../HaskellUtils -P Parsec -P HUnit -P Sort -P Dfa SwishMain.hs
15:14:52 <DanC> ERROR - Can't find module "HUnit"
15:15:16 <ski> there's an environment variable HUGSFLAGS where you can set the path with -P
15:16:01 <DanC> $ hugs -P../HaskellUtils:Parsec:HUnit:Sort:Dfa SwishMain.hs
15:16:02 <ski> -P:../HaskellUtils:Parsec:HUnit:Sort:Dfa
15:16:07 <ski> or something like that
15:16:08 <DanC> ERROR "SwishMain.hs" - Can't find imported module "ListHelpers"
15:16:37 <ski> where's ListHelpers ?
15:17:12 <DanC> seems to be in ../HaskellUtils/ListHelpers.hs
15:17:19 <ski> DanC : the ':' in "-P:..." tells hugs to append the following paths to the search path
15:17:36 <ski> hmm
15:18:13 * ski is not sure if it wants absolute paths, or if relative ones work
15:18:20 <DanC> maybe a space...
15:18:35 <DanC> no...
15:19:37 <DanC> aha... progress... this: $ hugs -P:.:../HaskellUtils/:Parsec:HUnit:Sort:Dfa SwishMain.hs
15:19:44 <ski> well, relative paths seem to work here
15:19:47 <DanC> produces: ERROR "../HaskellUtils//LookupMap.hs":57 - Haskell 98 does not support dependent parameters
15:20:13 <ski> what does that line say ?
15:20:28 <DanC> the swish docs talk about required extensions...
15:20:56 <ski> sorry, the line 57 of LookupMap.hs
15:21:37 <ski> i just didn't recognise that error msg
15:21:58 <ski> anyway, to turn on extensions with hugs, give it the "-98" flag
15:22:03 <DanC>   57          newEntry    :: (k,v) -> a
15:22:13 <ski> (can't be done from within a running hugs)
15:22:26 <DanC> bingo. (-98)
15:22:37 <ski> is it in a class ?  what does it's header look like ?
15:22:39 <DanC> -98 is mentioned in the swish docs.
15:22:53 <DanC>     55  class (Eq k, Show k) => LookupEntryClass a k v | a -> k, a -> v
15:22:54 <DanC>     56      where
15:22:54 <DanC>     57          newEntry    :: (k,v) -> a
15:22:58 <ski> ok
15:23:32 <ski> i.e. it's the "| a -> k, a -> v" things it complained about, i guess
15:24:03 <ski> the name i've heard is "functional dependencies". guess i didn't connect that to "dependent parameters"
15:26:02 <DanC> I seem to need another clue... his directions say:
15:26:03 <DanC> D:\Dev\HaskellRDF>Swish -i=Data/Diff1.n3 -d=Data/Diff2.n3
15:26:08 <DanC> at http://www.ninebynine.org/RDFNotes/Swish/Intro.html#GraphDiff
15:26:28 <DanC> I'm trying to figure out what's the corresponding spell on my debian linux box
15:26:44 <DanC> should I try a compiler in stead of hugs?
15:27:02 <ski> well, is "Swish" the name of the haskell program ?
15:27:24 <ski> you could do that (e.g. ghc or nhc). you could also use runhugs
15:28:36 <DanC> hellifino if "Swish" is the name of the haskell program. ;-) I do see Swish.hs in this directory.
15:29:08 <ski> make a script with "#!/whatever/runhugs /theSources/Swish.hs !:*" (or however you pass all arguments to another program, can't remember that RN)
15:29:36 <DanC> ooh!
15:29:39 <ski> and chmod u+x it
15:29:44 <DanC> $ runhugs -98 -P:.:../HaskellUtils/:Parsec:HUnit:Sort:Dfa Swish.hs -i=Data/Diff1.n3 -d=Data/Diff2.n3
15:29:52 <DanC> I win! thanks!
15:29:59 <ski> it'll still interpret, but you can use it from the command line
16:14:14 <ski> hi cmoline
16:14:16 <cmoline> hey all
16:14:20 <cmoline> hey ski
16:14:45 <cmoline> i dont have much to say today so im just going to sit and listen :)
16:17:16 <ski> no discussion RN
16:19:45 <Darius> Yep, you missed all the craziness, cmoline.
16:20:36 <cmoline> theres logs arent there? :)
16:20:45 <cmoline> ski: RN?
16:20:56 <ski> right now
16:21:00 <cmoline> ah
16:21:05 <ski> sure there are logs
16:21:42 <cmoline> lemme guess, todays log is a big list of silence
16:21:45 <ski> we had a fun "versus" "discussion" earlier
16:21:50 <ski> nope
16:28:04 <ski> _shawnafk : how do you join, when you're away from keyboard ?
16:34:20 <cmoline> i wish i was as funny as the people on that page :)
16:34:33 * cmoline resolves to be funny
16:36:06 <Darius> "that page"?
16:36:24 <ski> @wiki QuotesPage
16:36:24 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
16:36:27 <ski> probably
16:47:36 <cmoline> yep
16:53:20 <stepcut`> hahaha: * shapr begins his own paper "Generalizing Arrows to Spears" 
17:07:55 * ski curses his mouse ...
17:09:23 <cmoline> heh.i bought this optical mouse cause it had blue leds inside it that made it look cool. but then it turned out that the leds were on *all the time*
17:09:32 <cmoline> and they were bright
17:09:46 <cmoline> i didnt need to turn the light on at night anymore :)
17:10:12 <cmoline> i ended up taking them out cause they were interfering with my sleep
17:10:20 <ski> my stoopid mouse is double-clicking almost all the time, when i just click *once* !
17:11:47 <ski> cmoline : so they didn't go out after, say, 10 seconds, if not moving the mouse ?
17:12:07 <cmoline> nope. they got brighter when you moved the mouse
17:12:32 <ski> ... but did no drop to nothing after some time ?
17:12:40 <ski> s/no/not/
17:13:20 <cmoline> nope. there were two levels of brightness, bright when its not moving and really bright when it was
17:14:11 <cmoline> liralen: s/its/it was/ ;)
17:18:04 <cmoline> triple clicking vs not triple clicking :)
17:18:28 <cmoline> i guess i shouldnt start that again :)
17:25:51 <esap> hmm, someone explain to me what 'unfold const' does? It's type seems strange :-)
17:26:10 <Riastradh> @type unfold const
17:26:15 <Riastradh> @type unfoldl const
17:26:26 <Riastradh> lambdabot?
17:26:32 <Riastradh> @type unfold
17:26:32 <esap> unfold const :: forall a b. a -> Rec ((->) b)
17:26:40 <Riastradh> ...glerk?
17:26:46 <Maddas> @moo
17:26:48 <lambdabot>          (__)
17:26:48 <lambdabot>          (oo)
17:26:48 <lambdabot>    /------\/
17:26:48 <lambdabot>   / |    ||
17:26:48 <lambdabot>  *  /\---/\
17:26:49 <lambdabot>     ~~   ~~
17:26:50 <lambdabot> ...."Have you mooed today?"...
17:26:51 <Maddas> Hm
17:26:56 <Riastradh> @type unfoldl
17:29:51 <ski> Heffalump : dropped the k ?
17:30:07 <Heffalump> yeah
17:30:11 <Heffalump> ChanServ wouldn't talk to me
17:30:22 <Heffalump> I was never planning on keeping it for long.
17:30:52 * ski wonders if it would be ok to add quote from comp.lang.scheme to hawiki/QuotesPage ...
17:32:02 <ski> esap : is it  eater = \x.eater ?
17:32:19 <esap> ski: I think yes.
17:33:12 <Heffalump> WayOT: I don't suppose anyone knows precisely why uwimapd (and possibly others) requires X-UID headers?
17:34:05 <ski> Riastradh : i think unfoldr is in List
17:34:55 <ski> Heffalump : (doesn't like more than 9 chars in nicks ?)
17:35:05 <Heffalump> no, I think it just expected me to be Heffalump
17:35:06 <ski> Heffalump : (ok)
17:35:12 <Heffalump> it doesn't actually matter now, anyway
17:35:15 <ski> no
17:36:59 <Igloo> You can generally give your registered nick as an extra argument to the identify command
17:37:29 <Riastradh> @type List.unfoldr
17:37:57 <Riastradh> @type ^W^W^W:m List
17:38:15 <Maddas> @type List.unfoldr
17:38:23 <ski> List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
17:38:38 <ski> Maddas : ha ! :)
17:39:02 <Maddas> haha :)
17:39:13 <Riastradh> @type List.unfoldr const
17:39:50 <Riastradh> Hurry up, ski!
17:40:04 <Darius> It doesn't type check.
17:40:06 <Darius> @type const
17:40:07 <lambdabot> const :: a -> b -> a
17:40:15 <Riastradh> I know.
17:40:27 <Riastradh> I'm waiting for ski to give a detailed type error.
17:40:37 <Darius> Well then, @type doesn't return anything when it fails to typecheck.
17:40:47 <Riastradh> Right, because @type is broken.
17:40:51 <Riastradh> Is ski broken, then?
17:40:56 <Darius> Apparently.
17:41:12 <ski> Esap.unfold :: Functor f => (a -> f a) -> (a -> Rec f)
17:42:09 <ski> Esap.unfold const :: a -> Rec ((->) a)
17:42:50 <ski> Couldn't match `Maybe (a, b)' against `b1 -> b'
17:42:50 <ski>     Expected type: b -> Maybe (a, b)
17:42:50 <ski>     Inferred type: b -> b1 -> b
17:42:50 <ski> In the first argument of `unfoldr', namely `const'
17:43:04 <Riastradh> OK, so ski is just horridly slow.
17:43:19 <Darius> Perhaps he has a space-leak and is thrashing.
17:45:10 <Heffalump> they're multiplying!
17:46:00 * slj thinks that ski just for a while had other higher-priority threads running (and an unfair scheduler)
17:46:20 <slj> Heffalump : haha
17:47:28 <Stefan_> Mwahahahaha !!
17:48:30 <Vulpyne> Uh oh, scary laughter.
17:48:52 <Maddas> Ack, didn't I tell you not to feed it after midnight!
17:48:59 <Maddas> s/!/?/
17:49:00 <Riastradh> Wait a moment.  They aren't multiplying.  Both two and three are prime, so they can't be products of ski.
17:49:37 <slj> 2's not prime, (1+i)*(1-i) = 2
17:50:25 <liralen> hey, wait, 3 also fails the test of primality: sqrt(3)*sqrt(3)=3 !
17:50:36 <Stefan_> but where is the (1+i)th clone of md9slj ?
17:51:03 <Riastradh> Neither sqrt(3) nor (1+i) are real integers.
17:51:14 <Cale> (1+i) is a Gaussian integer
17:51:21 <ski> 1+i is a real complex integer
17:51:24 <Cale> and sqrt(3) is an algebraic integer
17:51:36 <Darius> pi is a surreal rational
17:53:29 <Cale> it has minimal polynomial x^2 - 3, which is monic with integer coefficients.
18:00:06 <ski> Cale : monic as in monomorphism ?
18:00:23 <Cale> no, monic as in the coefficient of the leading term is 1
18:01:59 <ski> ok
18:03:26 <ski> hello pimpbot5000
18:03:34 <pimpbot5000> hey whats up
18:03:44 <ski> i dunno
18:03:54 <pimpbot5000> has anyone here gotten gtk+hs to compile under ghc 6.2
18:04:06 <pimpbot5000> im stuck at a compile error
18:04:17 <pimpbot5000> it wants 'foreignPtrToPtr'
18:04:35 <Igloo> IIRC it is fixed in gtk+hs CVS
18:04:42 <pimpbot5000> i guess it's deprecated...but i can't find out where to import it from
18:04:44 <Igloo> Or was that gtk2hs?
18:04:48 <pimpbot5000> right on
18:04:51 <pimpbot5000> gtk+
18:05:07 <pimpbot5000> i might try gtk2hs anyways
18:05:09 <Igloo> I can't remember which had it fixed though
18:05:47 <Igloo> It was renamed to unsafeForeignPtrToPtr, anyway. You might also have problems with argument orders changing and things for the foreign pointer bits
18:06:26 <pimpbot5000> ok ill try that really quick
18:07:18 <pimpbot5000> yea the arguments are messed up
18:07:30 <ski> skew : hello
18:07:36 <skew> hi
18:09:11 <ski> pimpbot5000 : you could probably make a wrapper module, if you're lazy
18:10:31 <skew> were there any good Haskell tutorials?
18:11:21 <cmoline> skis a pretty good tutorial ;)
18:11:28 <Cale> there are some good Haskell tutorials
18:11:33 <ski> skew : i dunno
18:11:41 <Cale> I like hdaume's.
18:11:44 <ski> cmoline : :)
18:11:57 <vorpal> im working my way through "gentle intro"
18:12:19 <pimpbot5000> there's a really peculiar error in CAttrs.hs
18:12:21 <skew> Sinistrad in #python was sounding a bit perplexed over the "gentle intro"
18:12:24 <Cale> http://www.isi.edu/~hdaume/htut/
18:12:33 <pimpbot5000> it's a parse error...easy to fix...but i wonder how it got in there
18:14:40 <cmoline> ski: heh. you got me :) it is a little weird to talk about your tutorial on a website somewhere :)
18:14:42 <Cale> pimpbot5000: what does it look like?
18:14:59 <pimpbot5000> there's a comma after a function
18:15:07 <Cale> hmm...
18:15:22 <ski> cmoline : "your tutorial on a website" ?
18:15:26 <pimpbot5000> line 143
18:15:59 <Darius> Is it in a record expression?
18:17:14 <pimpbot5000> leaveObjRangeC    :: AttrC -> AttrC
18:17:14 <pimpbot5000> leaveObjRangeC ac  = ac {
18:17:14 <pimpbot5000> 		       defObjsAC = fst . leaveRange . defObjsAC $ ac,
18:17:14 <pimpbot5000> 		     }
18:17:33 <pimpbot5000> the comma had to be removed
18:17:49 <Darius> Yes, GHC used to allow that, but doesn't now.
18:18:00 <pimpbot5000> right on
18:18:20 <Darius> Personally, I'd rather them have left it or better that the standard allowed it.
18:18:24 <cmoline> ok. i can see how i confused you :) i was just thinking that my sentence was ambiguos and that skis could be interpreted as a possesive
18:18:47 <ski> cmoline : oh
18:18:54 <Igloo> I'd rather the standard allowed it everywhere, but given that's not the case I'd prefer ghc, nhc98 and hugs agreed what to do
18:20:05 <cmoline> support it i say!
18:20:10 <ski> Igloo : where everywhere ?
18:20:25 <ski> in lists also ?
18:20:30 <ski> [1,2,3,]
18:20:31 <Darius> Igloo: I'm ambivalent about it. 
18:20:40 <ski> foo,bar, :: X -> Y
18:20:43 <cmoline> i think he means across multiple compilers
18:20:48 <ski> Igloo : ?
18:20:51 <Igloo> Lists and records. Probably not tuples as it has more potential for other meaning there
18:20:57 <pimpbot5000> yea it is gtk2hs that has ghc 6.2 support
18:20:58 <cmoline> ok guess not :)
18:21:23 <Igloo> It wouldn't be useful to me there, but I wouldn't oppose it being allowed
18:21:46 <ski> mm
18:22:27 <skew> It's convenient when you are building values on several lines
18:22:36 <skew> If you like to put the commas at the end
18:22:59 * ski usually puts commas at the beginning, at such cases
18:23:05 <Igloo> I'd often like to be able to say
18:23:06 <skew> lately I like putting separators at the start of the line
18:23:07 <Igloo> [
18:23:10 <Igloo>   thing1,
18:23:12 <Igloo>   thing2,
18:23:13 <Igloo> ]
18:23:15 <cmoline> and it should allow a similar thing in type definitions with | i think
18:23:25 <Igloo> and comment out any thing without having to worry about special cases
18:23:29 <skew> So I can keep my eye on all of them, and they can't get up to any mischeif
18:23:49 <skew> Allowing newline as an element separator might also do that
18:23:59 <Darius> The start has the same problem as the end.
18:24:04 <cmoline> its handy when refactoring. you can reorder the lines without having to worry about the syntax on the end
18:24:26 <skew> Darius: yeah, but to fix that you need to allow a starting comma, not a trailing comma
18:24:28 <ski> cmoline : yes i'd like "data VeryLongName = \n  | Constr0 ...\n  | Constr1 ..."
18:25:00 <ski> comline : but i suppose one could also do "data VeryLongName\n  = Constr0 ...\n  | Constr1 ..."
18:25:00 <cmoline> oh hey! i never thought of that!
18:25:02 <Darius> skew: So you should use the end, so when they fix it you just need to add a comma.
18:25:25 <skew> but then the commas are scattered at all sorts of column positions, adding visual noise
18:25:33 <cmoline> do you guys know satchel from get fuzzy? sometimes i feel im satchel
18:25:36 <Darius> ski: The latter is more common, in my experience.
18:26:10 <skew> Not that stuff like this matters all that much, but it's about the only level of the language where you don't have control
18:26:11 <Darius> skew: But they are joined to the ending expressions so they don't stick out as much.
18:27:23 <satchel> irc needs a time travel feature so i can go back and fix my sentences. i make a lot of mistakes
18:27:58 <Darius> You could have someone proofread each line before sending it.
18:28:15 * Darius wonders how much that would raise the quality of IRC or Usenet.
18:28:27 <skew> The Scheme proposal for "I-expressions" is interesting
18:28:43 <pimpbot5000> what are they?
18:28:53 <satchel> Darius: you volunteering? :)
18:29:00 <skew> They give a uniform translation from indentation to S-expressions, something like the way Haskell works
18:29:15 <satchel> what i need is vigor (is that whats its called?)
18:29:29 <pimpbot5000> yea that would be really cool
18:29:43 <Darius> satchel: It doesn't need to be one particular person that proofreads.  Just each person has someone around them check what they enter.
18:29:46 <skew> I've been thinking something like that might be a great way to mix indentation with nice macros
18:30:01 <ski> (same thing with case in SML, of's 2 chars, so i have to indent code with "  | " in the branches :( )
18:30:21 <satchel> "are you sure you want to send this message [ok] [cance]"
18:30:37 <skew> So you can add macros and use standard indentation forms with them
18:30:38 <satchel> nope, i didnt want to send that one :)
18:30:44 <pimpbot5000> skew: by that you mean parens could be eliminated in favor of indentation?
18:30:50 <satchel> add a ? and a l
18:31:01 <skew> that's the idea with the scheme stuff
18:31:01 <satchel> in the appropriate spots
18:31:29 <skew> My interest is that if it's a simple rule rather than keyword specific magic that does layout,
18:32:34 <skew> then macros are a lot easier because you can uniformly process source using things you don't understand (before expanding macros in the body), and you can use them with layout
18:32:37 <pimpbot5000> that reminds me of doug hofstadter...i asked him what language his lab uses...he said "i take issue with that question...it doesn't matter what language you use, the algorithms are what matter.  we use that language with all the parentheses..."
18:32:43 <ski> one'd perhaps want "sub-macros", also
18:33:08 <ski> (like "<-" in "do")
18:33:23 <skew> Yeah, I think those would just be nullary macros or something that the parent would look for
18:33:39 <skew> (Or, if it's raw s-expression stuff, just for those strings)
18:34:21 <ski> or perhaps macros building another compile-time-type than Expr (userdefined, of course. e.g. DoCmd)
18:34:48 <skew> I'm thinking a raw S-expression level would be nice
18:35:07 <Riastradh> Why not, uh, just S-expressions?
18:35:19 <skew> The question is what the source language looks like
18:36:17 <skew> Or, how to put some syntax on there, short of an extensible parser (and still, what do you use for datatypes)
18:36:51 <Riastradh> Syntax is a solved problem, and has been solved for decades.
18:36:56 <ski> extensible datatypes ?
18:37:18 <skew> Monads already give you the execution control, so it seems like most of what you want is control over binding
18:37:43 <skew> Riastradh: Is the solution just to eliminate it?
18:38:00 <Riastradh> To eliminate it as much as possible and use S-expressions.
18:38:21 <skew> That's a reasonable solution.
18:38:36 <skew> I dislike the redundancy of having indentation and grouping symbols
18:41:25 <ski> { ; } ?
18:41:39 <skew> I guess selling other people on S-expression might not be that hard, if somebody tried
18:41:50 <skew> like, Java, or C# level of trying
18:42:09 <Riastradh> There are much more important issues than the minor redundancy of two kinds of grouping symbols.
18:43:04 <skew> On reflection, I doubt anybody using Haskell would care too much one way or the other, excepting legacy code
18:43:18 <skew> I'm off for a while
18:44:00 <vorpal> on that note i would like to ask what major applications have been written in Haskell
18:44:10 <ski> s/skew/skew_afk/
18:45:33 <ski> ghc ;)
18:46:23 <ski> seriously, see http://www.haskell.org/practice.html
18:46:29 <ski> darcs e.g.
18:47:00 <vorpal> not to deter from the coolness of the language, but I just wanted to see examples of what real applications exist 
18:47:20 <ski> (well, dunno if it's a major app. but it's interesting, in it's own right)
18:49:17 <vorpal> at least OS bindings?  how about if ii want to be pioneer and write a haskell email client?
18:51:31 <ski> i don't know about any email client written in haskell
18:51:46 <ski> (but there's hircules, the irc client)
18:51:56 <Riastradh> Go ahead, write one.  GHC provides OS bindings.
18:52:00 <Pseudonym> Clearly, by Zawinski's rule, no Haskell program is large enough yet.
18:52:26 <ski> Pseudonym : what's "Zawinski's rule" ?
18:53:03 <ski> Pseudonym : Jamie Zawinski ?
18:53:26 <vorpal> all programs will evolve until the have email capability
18:53:35 <vorpal> they^
18:54:00 <Pseudonym> @jargon Zawinski's law
18:54:03 <lambdabot> No match for "Zawinski's".
18:54:03 <lambdabot> No match for "law".
18:54:08 <Pseudonym> @jargon "Zawinski's law"
18:54:09 <lambdabot> *** "Zawinski's Law" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:54:09 <lambdabot> Zawinski's Law "Every program attempts to expand until it can read
18:54:09 <lambdabot>    mail. Those programs which cannot so expand are replaced by ones which
18:54:09 <lambdabot>    can." Coined by Jamie Zawinski (who called it the "Law of Software
18:54:10 <lambdabot>    Envelopment") to express his belief that all truly useful programs
18:54:12 <lambdabot>    experience pressure to evolve into toolkits and application platforms
18:54:14 <lambdabot>    (the mailer thing, he says, is just a side effect of that). It is
18:54:16 <lambdabot>    commonly cited, though with widely varying degrees of accuracy.
18:54:18 <lambdabot> [2 @more lines]
18:54:45 <ski> @more
18:55:21 <ski> lambdabot: @hello
18:55:22 <lambdabot> Hello world. 
19:05:36 * ski curses his mouse, *again*
19:09:14 <Darius> ski: If you didn't use a cursed mouse, maybe you'd have better luck.
19:11:50 * liralen drops a cursed mouse of -3 dexterity.
19:12:01 * ski blesses his mouse : MON ZO BRO ROS
19:12:46 <ski> (maximum electricity helping swiftness/agility)
19:14:15 <ski> maybe i need to find a Remove Curse Scroll ...
19:15:13 <ski> (or find someone who has scribed and memorized it. helpdesk ?)
19:17:09 <skew> exorcist?
19:17:57 <ski> someone who has that arcane knowledge ..
19:18:44 <liralen> ski - just write a program to generate a random string of words with an appropriately magical sound, run it once (and compile it once), and then say those words over your mouse.  Then destroy all copies and forms of the program.
19:19:03 <skew> A simple remove curse won't work if the problem is Windows-based.
19:19:05 <liralen> ski - if you leave the program around, or find that you have to compile it more than once during development, the spell will fial.
19:20:41 <Darius> take someAmount $ sequence magicWords
19:21:54 <ski> liralen : but uttering the magic syllables requires utmost skill and knowledge of the proper mind-structures to build, and quite a bit familiarity with the occult (hidden) meaning of those syllables
19:22:42 <ski> liralen : (s/will fial/will fizzle/ ?)
19:22:44 <liralen> ski - oh, sure in *traditional* magic.
19:22:59 <skew> The behaviour of aged windows installs only makes sense once you realize Windows opens a portal to the netherworld, through which demons possess the machine.
19:23:05 <liralen> ski - fail in a way that leads to increased disruption.
19:23:10 <Pseudonym> I knew Hungarian notation had a purpose.
19:23:21 <np_hard> pszl
19:23:31 <Pseudonym> lpstrParam
19:23:44 <np_hard> m_lpsz
19:24:02 <np_hard> of all the wretched ideas
19:24:03 <ski> skew : It hasn't to do with windows. (I think. Hmm, it says "Microsoft" on the mouse..)
19:24:30 <skew> Microsoft mice and joysticks are solid products.
19:24:34 <ski> liralen : I think we have to built an appropriate denotational semantics for magic
19:25:14 <np_hard> how long has the (x:xs) notation been in vogue?
19:25:23 <Darius> Not at all like those other gaseous products.
19:25:41 <Darius> Depends on your definition of "in vogue".
19:25:47 <ski> np_hard : that exact notation ?
19:25:48 <keverets_> I prefer liquid products... a good middle ground.
19:26:02 * np_hard never really saw it before seeing some haskell\
19:26:23 <skew> Darius: Specifically, in contrast to the ephermal information-only products
19:26:38 <np_hard> though I have adapted it to a lot of python
19:26:43 <np_hard> for field in fields:
19:26:49 <np_hard> things like that
19:27:08 <ski> np_hard : ML has x::xs, Prolog has [X|Xs] (which is '.'(X,Xs) which is roughly X . Xs), Lisp has (x . xs)
19:28:00 <np_hard> no no
19:28:08 <ski> ?
19:28:10 <np_hard> I mean the "xs" for the cdr part
19:28:17 <ski> ah
19:28:19 <np_hard> not the different ways of consing
19:28:41 <ski> well, i'm not sure who started it
19:28:48 <ski> ML'ers ?
19:29:09 <np_hard> these are the important things we should all know!
19:29:24 <skew> yep, syntax and variable naming conventions
19:30:01 <ski> perhaps not, considering that "as" is a keyword (at least in recent SML)
19:30:18 <liralen> ski - I see h::t more often in O'Caml, at least.
19:30:38 <ski> perhaps, it was us haskellers
19:30:49 <ski> (or maybe it comes from Miranda ..)
19:31:09 <np_hard> it does work well for less abstract thing
19:31:09 <np_hard> s
19:31:18 <np_hard> for row in rows: etc
19:31:57 <ski> sheep:sheep ?
19:32:17 <np_hard> heh
19:33:14 <ski> prolly things like "child:children", "potato:potatoes" and "box:boxen", though
19:33:47 <np_hard> aah
19:33:55 <np_hard> the dreaded b-xen word
19:34:19 <ski> so perhaps it should be called "plural convention"
19:35:29 <ski> index:indices vertex:vertices mutex:mutices redex:redices  ?
19:35:53 <skew> moose:meece
19:36:01 * ski could probably come up with some more
19:36:04 <ski> haha
19:37:35 <ski> goose:geese  moose:meese
19:39:49 <Darius> radius:radii
19:39:55 <ski> yes
19:40:07 <ski> hm
19:40:16 <ski> virus:virii
19:40:20 <np_hard> nooo
19:40:27 <ski> Darius : perhaps radiii ?
19:41:21 <Darius> Why radiii?
19:41:29 <Darius> virus:viruses
19:42:33 <ski> hmm
19:42:47 <ski> i thought it was virii
19:43:12 <ski> e.g. http://www.perl.com/language/misc/virus.html doesn't agree
19:47:36 <Riastradh> The plural is viruses, as it was added in an already anglicized language, not Latin; in Latin, 'virus' had no plural.
19:50:01 <ski> but e.g. redex:redices, then ?
19:51:57 <ski> surely, one ought to be able to choose another form than the default, if it fits in, at least at the time of introducing the new word ?
19:55:58 <Darius> Why?
19:56:07 <ski> Y not ?
19:56:12 <Darius> redex stands for reducible expression and it's plural is redexes.
19:56:28 <Darius> ski: Because it would be an arbitrary rule for no reason.
19:56:36 <Darius> English has enough of them.
19:56:40 <ski> it wouldn't be a rule
19:56:47 <ski> it would be an option
19:56:49 <Darius> No it would be worse, a special case.
19:57:21 <ski> by "fit in", i meant that there already should be words with this pattern
19:58:15 <ski> so it wouldn't be *another* rule, disagree ?
19:58:15 <Darius> There are many more words (in English) of the pattern <word> -> <word>s, <word>es
19:58:27 <ski> so ?
19:58:28 <Darius> It's not a rule of English.
19:58:36 <Riastradh> English has no rules.
19:58:49 <ski> It is a rule of some words used in english
19:59:00 <Darius> So, if I see 'virus' and want the plural it should be the "normal" rule for plurals.
19:59:09 <Darius> ski: Because they came from Latin.
19:59:55 <ski> Darius : depends on if there were a latin plural form of this latin word ..
20:00:11 <Riastradh> There was not.
20:00:18 <ski> Darius : but i guess i agree (reluctantly) in the "virus" case
20:00:34 <ski> Riastradh : i know. now
20:00:35 <Darius> If you are inventing a word, it is not a latin word.
20:00:48 <Pseudonym> partly it depends how the word got into English.
20:00:58 <ski> yes
20:01:16 <Pseudonym> Multiple female prosecutors are "prosecutrices".
20:01:29 <Pseudonym> Because the word entered through Norman French.
20:01:54 <Riastradh> The plural of 'octopus' is 'octopodes,' too.
20:02:10 <Pseudonym> Most Greek words use Greek plurals, I think.
20:02:26 <Pseudonym> (Technically, the Greek word is "octopos".  Not sure how it became a "u".)
20:02:55 <Riastradh> Indeed.  But it is a very common misconception that the plural is 'octopi,' which is simply wrong.
20:02:57 <ski> Darius : i was thinking of defining word forms that "emulated" various rules for word groups
20:03:00 <Pseudonym> Right.
20:03:22 <Riastradh> It would be nice if we used a language that didn't suck like English so we _had_ rules about plural forms.
20:03:26 <Pseudonym> Actually, the root is *octopod, but the Greek elision rule is unvoiced dental + s = s.
20:03:38 <ski> Darius : in some "reasonable" way. (whatever that is)
20:03:40 <Riastradh> Then I guess pedants like myself would be unable to pedantricize people about those plurals.
20:04:19 <Pseudonym> Riastradh: I'm not sure that "pedantricize" is correct.  Did "pedant" join English through Norman French or not?
20:04:28 <Pseudonym> If so, it's "pedantricise".
20:04:54 <liralen> Riastradh - but English gives you all kinds of other joyful pedanticisms that another languages may have less of simply because of that language's greater regularity.
20:04:55 <Riastradh> Ah, but remember that nearly all of those '-ise' suffixes were _erroneously_ produced from French, and their originals _were_ '-ize.'
20:04:56 <Darius> ski: So why not choose the most "reasonable" way?
20:05:27 <Pseudonym> Riastradh: Doesn't matter.  If it came to English through French, we use the French spelling.
20:05:58 <Pseudonym> The original is _actually_ -izo (where the "o" is an omega, not an omicron).
20:06:01 <Riastradh> I refuse to be a French crumpet monkey!
20:06:07 <liralen> Riastradh - for instance, in Chinese I wouldn't have made that 'another languages' error because I wouldn't have written the plural in the first place (and forgotten about it in a partial rewrite).
20:06:27 <ski> Darius : i want many "reasonable" ways (english already has many. well, depends on whether you think mice and others are "reasonable" :)
20:06:52 <Darius> ski: Well, in practice, you have them.
20:07:38 * ski wants to eat cake and have it too
20:07:42 <Pseudonym> Riastradh: The original is "croissant monkey".
20:13:04 <Riastradh> It is irrelevant what the French original was.
20:13:25 <Riastradh> I was referring to being a crumpet monkey, but being constrained by French silliness.
20:14:15 <Pseudonym> Yes, back to Saxon, I say.
20:14:50 <Riastradh> And 'crumpet monkey' has a much nicer ring to it, anyways.
21:10:46 <shapr> @yow
21:10:46 <shapr> lambdabot: hello?
21:10:46 <shapr> good morning #haskell!
21:10:47 <lambdabot> Hydraulic pizza oven!!  Guided missile!  Herring sandwich!  Styrofoam!
21:10:47 <lambdabot>  Jayne Mansfield!  Aluminum siding!  Borax!  Pedal pushers!  Jukebox!
21:10:47 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
21:11:15 <ski> lambdabot: @hello
21:11:16 <lambdabot> Hello world. 
21:11:30 <ski> mornin' shapr
21:11:38 <shapr> y0 y0 ski, what's happening?
21:12:12 <ski> listening to "Red Devil - Last Ninjha 3"
21:12:23 <shapr> haven't heard of it.
21:13:32 <ski> shapr : http://remix.kwed.org/?search_id=389
21:14:33 <ski> wheee, up and down !
21:15:01 <SamB> how to ski uphill?
21:15:49 <ski> shapr : perhaps easier to look at http://www.mdstud.chalmers.se/~alg3-59/msx/RedDevil/
21:16:20 <ski> SamB : i suppose you need speed
21:23:08 <shapr> ski: that's nice music
21:23:17 <ski> yes :)
21:23:42 <shapr> and the category theory book is nice too :-)
21:23:57 <ski> author at http://clix.to/helldin/
21:24:52 <ski> (though the links there doesn't seem to work ATM, and i don't have all the tunes (which i have at home) at school :( )
21:25:30 <ski> shapr : i'm going to reloan the book
21:27:59 <shapr> the catsmoeder.ps ?
21:28:04 <ski> oh
21:28:15 <shapr> mmm, new Haskell + web design = http://acooke.org/jara/halipeto/
21:28:45 <ski> just a postscipt file on category theory i, for some reason i don't remember, put there
21:28:47 <shapr> halipeto is modeled after the Template Attribute Language in Zope Page Templates.
21:29:15 <Pseudonym> @arr
21:29:15 <lambdabot> I heard andersca is a pirate
21:29:21 <Pseudonym> Is he really?
21:29:43 <Pseudonym> Arr, shiver me timbers!  Have some MP3s!
21:29:46 <shapr> lambdabot isn't saying anything more about it.
21:30:18 <ski> shapr : nice (site)
21:30:24 <shapr> Pseudonym: http://www.jinxhackwear.com/scripts/details.asp?affid=-1&productID=205
21:30:34 <shapr> yah andrew cooke is good designer.
21:33:19 <liiwi> good morning
21:33:39 <ski> morning, liiwi
21:33:42 <shapr> hei liiwi, hyvää huomenta
21:42:01 <shapr> oh, neat: http://asia.cnet.com/newstech/applications/0%2c39001094%2c39168090%2c00.htm
21:44:11 <ski> "... some users were afraid the deployment of Linux was part of a secret plan to read everyone's e-mail, record all their keystrokes and monitor their surfing habits."
21:44:28 <ski> huh :/
21:48:32 <monotonom> And Windows isn't? :)
21:48:54 <shapr> yah, I wondered about that myself.
21:51:16 <Pseudonym> monotonom: No it isn't.  In Windows, you can't monitor _anything_.  (Unless you install a third-party tool like Back Orifice, I suppose.)
21:54:30 <monotonom> I am sure we all know that Windows monitors and reports back to Microsoft all software packages you install.
21:56:11 <shapr> my linux does that, but I had to install popularity-contest first :-)
22:03:36 <Pseudonym> Haven't you installed vrms?
22:03:44 <shapr> c:/> vrms
22:05:22 <ski> what's that ?
22:07:01 <shapr> virtual richard m stallman
22:07:07 <shapr> it checks your linux for non-gpl'd software
22:08:18 <liralen> ah.  Funny joke =)
22:08:19 <ski> cool !
22:17:32 <Pseudonym> We just managed to rescue our espresso machine from the people on the other side of the floor.
22:18:12 * Pseudonym cleaned it out last night
22:18:12 <Pseudonym> And I am now bouncing off the walls.
22:18:37 <Pseudonym> Still haven't mastered the eccentricities of the machine yet, though.
22:56:48 <shapr> yow!
23:01:17 <ski> @yow
23:01:18 <lambdabot> Why am I in this ROOM in DOWNTOWN PHILADELPHIA?
23:35:49 <Maddas> heh
