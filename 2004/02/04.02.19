00:23:01 <DeltaZer0> I think Haskell is a good starting point for taking over the world.
00:27:06 <skew> space leakage could use some work though.
00:27:24 <skew> Any idea why "main = print $ head $ drop 1000000 $ enumFrom 0"
00:27:34 <skew> should consume lots of memory?
00:27:58 <earthy> yup
00:28:31 <earthy> it'll happilly start constructing upto the max heapsize
00:28:39 <earthy> and only then the garbage collector has to kick in
00:29:03 <skew> No, it never garbage collects
00:29:09 <earthy> (you'll have lots of dirty memory that can be cleaned up by then, but it'll have been dirtied)
00:29:19 <earthy> skew: you haven't hit max heapsize yet? :)
00:29:32 <skew> At least I hope it would garbage collect before saying "stack overflow"
00:29:49 <earthy> it says `stack overflow'?
00:30:01 <skew> maybe not with that exact number
00:30:28 <skew> main = print (head (drop 1000000 (enumFrom 0)))
00:30:56 <DeltaZer0> is the stack overflow message the only reason you say it's taking lots of memory?
00:31:11 <skew> ghc -O -o memtest memtest.hs; ./memtest
00:31:17 <skew> Stack space overflow: current size 1048576 bytes.
00:31:22 <skew> No, heap profiling.
00:31:31 <skew> I got this by whittling down something else involving CAFs
00:31:57 <skew> then thought for sure that moving [1..] into main would knock it down to constant live data
00:31:58 <earthy> but, you're constructing a huge list, only to drop a huge number of cells only to get the first element
00:32:20 <earthy> yet, the cells seem to be constructed
00:32:32 <earthy> hugs doesn't die, by the way
00:32:42 <skew> I can't see anything that should hang onto the head of the list
00:32:58 <earthy> skew: there isn't...
00:33:15 <earthy> but why do the cleanup if you have a garbage collector to do that?
00:33:31 <skew> it doesn't, if it's running out of memory
00:33:44 <skew> "Stack space overflow: current size 1048576 bytes."
00:33:45 <earthy> ah, but that's a different matter entirely. :)
00:34:02 <earthy> having a gc doesn't mean it'll get run in time...
00:34:30 * earthy thinks
00:34:54 <skew> This example really should have been deforested out of existence anyway
00:34:58 <earthy> I have a distinct feeling Ralf Hinze mentioned something about this on one of the haskell or ghc lists...
00:41:32 <skew> I'm not finding much
00:41:40 <earthy> nor am I
00:45:07 <earthy> gotcha.
00:45:13 <earthy> 416117 and 416118
00:45:28 <earthy> that's the breaking point
00:45:50 <earthy> next q, why would it break exactly there
00:46:16 <skew> What?
00:46:29 <skew> You mean that's the number that makes my program hit the stack limit?
00:46:37 * earthy nods
00:46:49 <earthy> at least, in ghci
00:46:54 <skew> That's just how the space usage and the standard stack size line up
00:47:08 <skew> peak usage is rougly proportional to the number, I think
00:47:14 <skew> bump up the stack and you can go higher
00:47:41 * earthy knows
00:48:03 <earthy> just trying to find out why it would hit the stack
00:48:11 <earthy> liit
00:48:14 <earthy> limit even
00:49:16 <earthy> hm. 'kay. in ghci there apparently is a different sized stack.
03:49:49 <Lunar^> hOp works !
03:50:13 <earthy> hOp?
03:50:28 <Lunar^> GHC RTS on the metal
03:50:42 <Lunar^> (shapr's pretty neat description)
03:50:47 <Lunar^> We have a kernel in Haskell :)
03:51:01 * earthy ponders
03:51:55 <earthy> so, you have enough setup code that you could compile some haskell code to a binary, plonk that binary in a bootblock of a computer and boot that?
03:52:17 <earthy> or am I now misunderstanding?
03:55:48 <Lunar^> No, your right\
03:56:05 <earthy> cool
03:56:07 <Lunar^> Using GHC RTS as support code
03:56:30 <earthy> so, how do you deal with hardwareinteraction? :)
03:56:53 <Lunar^> That's the next step
03:57:03 <earthy> `ah'. `not yet'. :)
03:57:12 <Lunar^> At 6am CET we had a kernel booting
03:57:29 <Lunar^> Forking two threads that prints an increasing number on the screen
03:57:39 <earthy> schweet
03:57:59 <Maddas> Cool! I always wanted a kernel that does that!
03:58:00 <Maddas> :-P
03:58:32 <earthy> maddas: hey, don't knock it, linux began with alternating a's and b's. :)
03:58:42 <Lunar^> earthy: poke (nullPtr `plusPtr` (0x008B0000 :: Word32)) ...
03:59:00 <earthy> lunar^: *eeewwwwww*
03:59:04 <Lunar^> earthy: That's how we did it for the video part
03:59:18 <earthy> how BASIC. ;)
03:59:26 <earthy> how C64 and Apple II. ;)
03:59:38 <Lunar^> earthy: I think we going to use foreign and make the IRQ handler code call the respective Haskell functions
04:00:40 <Maddas> earthy: I was just being sarcastic, of course it's cool. :)
04:01:17 <Lunar^> earthy: We already have Control.Concurrent.Chan, so it will be quite easy
04:10:04 <earthy> hmyeah. definitely cool stuff, lunar
04:19:12 <Lunar^> earthy: I'm getting a screenshot
04:19:22 <Lunar^> earthy: sebc just woke up and sent me the disk image
04:31:09 <Lunar^> http://lune.talath.net/~lunar/hOp-20040219.png
04:31:16 <Lunar^> Here it is :)
04:31:26 <Lunar^> With Main.hs
04:40:16 <earthy> pokeElemOff is part of hOp?
04:40:37 <Lunar^> Nope
04:40:43 <Lunar^> Foreign.Storable
04:40:50 <earthy> ah
04:40:59 * earthy doesn't know Foreign at all ;)
04:41:09 <Lunar^> There's not any custom function in the whole Haskell file for the moment
04:45:27 <earthy> schweet
04:46:00 <earthy> (though the dynamic behaviour of the code doesn't come out too nicely in the screenshot)
04:46:09 <themaximus> Morning
05:08:36 <themaximus> bbl (breakfast + skiing)
05:19:19 <earthy> skiing?
05:19:23 <earthy> some people. ;)
05:28:55 <Lunar^> http://haskell.org/pipermail/haskell-cafe/2004-February/005839.html
05:52:47 <earthy> I saw it. ;)
08:01:21 <[3N1GM4]> HI, I have a newbie haskell question...
08:01:30 <ski> ok..
08:01:38 <[3N1GM4]> one sec, I will type...
08:05:50 <[3N1GM4]> I am trying to write a function which will take a list of Strings, where the first string in the list describes a shape, i.e. Circle or Rectangle or Triangle, with the remaining string containing string representations of info on those shapes. For example, the circle has a further 3 strings: the x and y coordinates of its centre and it's radius. I need to store this information in a record I have defined called Shape, [more to come]
08:08:19 <[3N1GM4]> sorry, Shape is a type, with three record types in it: one for each shape, i.e Circle Point Double, where Point I have defined as type Point = (Double,Double)... I need to store my shape information in one of these shape types from the list of strings I have sent to this function... I am not asking you to code for me, but I don't knwo where to start...
08:08:44 <earthy> you do know about guards?
08:08:51 <[3N1GM4]> yes, I have used them once.
08:08:53 <earthy> or even about case expressiosn?
08:09:02 <[3N1GM4]> I used them in defining Shape
08:09:10 <ski> (or pattern-matching ?)
08:09:17 <[3N1GM4]> I know of pattern matching...
08:10:03 <ski> so the function should return (just) a Shape ?
08:10:14 <earthy> foo ("Bar":xs) = 
08:11:25 <[3N1GM4]> I have the list of Strings, which may be ["Circle","3","4","2"] and I know I can use read to convert the 3,4 and 2 into double, but how do I actually get the data into a shape type?
08:11:53 <[3N1GM4]> do I recursively loop through the list and do something to each item?
08:11:57 <ski> Circle 3 4 2 :: Shape
08:12:17 <earthy> well,  Circle (3,4,2) :: Shape  probably
08:12:41 <earthy> err... Circle (3,4) 2 :: Shape   even, going from his descriptiong
08:12:45 <ski> supposedly the expected length of the list is determined by the word at the beginning of the list, e.g. "Circle", "Rectangle", etc ..
08:12:53 <[3N1GM4]> I have defined Shape as follows:
08:12:53 <[3N1GM4]> data Shape = Circle Point Double 
08:12:54 <[3N1GM4]>            | Triangle Point Point Point 
08:12:54 <[3N1GM4]>            | Rectangle Point Point
08:12:54 <[3N1GM4]>            deriving (Read,Show)
08:12:57 <ski> oh, right
08:13:04 <[3N1GM4]> yes ski
08:13:17 <[3N1GM4]> the length of the list depends on the shape being described
08:13:24 <ski> so i don't think you should recurse through the list
08:13:36 <[3N1GM4]> ok, should I write a seperate funtion for each shape?
08:13:36 <ski> just pattern-match on the correct length
08:13:39 <ski> no
08:13:41 <[3N1GM4]> ok
08:13:59 <ski> a separate definition-line for each kind of shape
08:14:08 <[3N1GM4]> so like if the length of the list (number of items in it) is 4, then it's a circle...
08:14:14 <[3N1GM4]> etc
08:14:16 <ski> do you understand what i mean ?
08:14:20 <[3N1GM4]> I think so.
08:15:08 <[3N1GM4]> so now I have a list of strings and I know what kind of shape it should be, how do I actually build the shape? Can I pattern match with elements of a list?
08:15:24 <[3N1GM4]> like Circle(x,y,z) or something?
08:15:29 <ski> no, not "the length determines the kind of shape", but "the first word determines the kind of shape, and thus, the length" !
08:15:31 <[3N1GM4]> where x,y,z are the list elements
08:15:53 <[3N1GM4]> right, ok, I have already done that then, I think, with 3 lines like:
08:16:04 <[3N1GM4]> if head(words(st)) == "Circle" then toCircle(words(st))
08:16:19 <[3N1GM4]> this is when I have one string containing all the words...
08:16:39 <[3N1GM4]> before it is sent to the function which takes a list of strings...
08:16:58 <[3N1GM4]> but that is wrong, because I dont want seperate functions for each shape?
08:17:18 <[3N1GM4]> so toCircle needs to be like toShape and then I sort it all out in there?
08:17:59 <ski> well..
08:18:01 <earthy> toShape :: [String] -> Shape
08:18:08 <[3N1GM4]> yes...
08:18:17 <ski> you could have a separate func. for each kind of shape, i guess..
08:18:28 <earthy> toShape (type:args) | type == String  = toCircle args
08:18:34 <[3N1GM4]> so then toShape will recieve a list of Strings, one for each element of the shape: name, x coord, y coord, radius?
08:18:42 <earthy>                | type == "String"   that is
08:18:44 <earthy> and so on
08:18:48 <ski> but, i think your test in "if" above could be nicer done by pattern-matching ..
08:19:25 <[3N1GM4]> ok, but how can I pattern match before I know the first word and therefore the length of the list?
08:19:36 <[3N1GM4]> *string
08:19:43 <ski> i was thinking in doing something like .. :
08:20:03 <ski> toShape ["Circle",xStr,yStr,radStr] = ...
08:20:16 <[3N1GM4]> ah, ok.
08:20:21 <ski> and 2 more lines for the other cases
08:20:24 <[3N1GM4]> riiight.
08:20:42 <ski> so you don't need the if and head stuff
08:21:21 <[3N1GM4]> so then, once I know what kind of shape I have in my list, how exactly do I make it a shape? Using my type definition of Shape above?
08:21:25 <ski> but you still have to convert the 'argument strings' to values (of correct type)
08:21:37 <[3N1GM4]> yeh, using read apparently
08:22:14 <ski> so if you have somehow computed  x,y,rad , i guess you could return  'Shape (x,y) rad', no ?
08:22:40 <[3N1GM4]> errr, Circle (x,y) rad, yeh? from my multiple type def above?
08:22:59 <[3N1GM4]> in that particular case
08:23:03 <ski> yes
08:23:06 <[3N1GM4]> ok.......
08:23:15 <ski> you could try it out..
08:23:31 <[3N1GM4]> and am I right in the fact that I can use read or something to convert those argument strings to doubles?
08:23:39 <ski> and..  you have to decide what to do if there is error in the input..
08:23:47 <ski> i think so
08:23:50 <[3N1GM4]> yeh, that's work for later!
08:23:56 <[3N1GM4]> ok, well thanks sincerely for your help.
08:24:10 <[3N1GM4]> I may be back in a few hours/days... =)
08:24:22 <ski> :)
08:24:38 <[3N1GM4]> Thanks again. Laters.
08:29:53 <ski> good afternoon, shapr
08:30:21 <shapr> greetings ski
08:30:32 <shapr> bring: hey, you have a moment for an XmlRpc question?
08:30:39 <bring> sure
08:32:12 <shapr> gee, forming the question may have answered it :-)
08:32:15 * shapr blushes
08:32:35 <earthy> the `tell your granny' method of solving problems. ;)
08:32:45 <shapr> aka Cardboard Analyst on The Wiki
08:33:19 <shapr> anyways, I'm using XmlRpc to unit test my zope code.
08:33:24 <shapr> trying to, anyway
08:34:50 <bring> hmm, wonder if you could use QuickCheck to test the Zope code over XML-RPC then
08:35:18 <shapr> probably so
08:35:40 <shapr> but since I'm more familiar with unit testing, I'm starting there.
08:36:02 <shapr> on the other hand, a QuickCheck that saved failing test cases would subsume HUnit.
08:36:22 <shapr> anyways
08:37:59 <Lunar^> shapr: saw the mail on haskell-cafe ?
08:38:04 <shapr> no?
08:38:21 <earthy> hOp booted and screenshotted.
08:38:33 <earthy> high coolness factor
08:38:42 <Lunar^> http://haskell.org/pipermail/haskell-cafe/2004-February/005839.html
08:39:05 <earthy> (and I really like the announcement... more HC&A fodder >:) )
08:39:08 <shapr> whoa, cool :-)
08:39:11 <Lunar^> shapr: btw, we'll soon need a way to host an arch repos
08:39:19 <shapr> darcs !
08:39:23 <Lunar^> earthy: HC&A ?
08:39:38 <Lunar^> shapr: GNU Arch would be better IMHO because we need to keep in sync with vendor realese of GHC
08:39:50 <Lunar^> shapr: It has realy nice feature to do that
08:40:00 <shapr> darcs has a perl script that uses cvsps :-/
08:40:15 <shapr> obviously, this must be changed.
08:40:19 <Igloo> How does arch help you keep sync?
08:40:36 <Lunar^> http://wiki.gnuarch.org/moin.cgi/Arch_20Recipes <- section 10
08:40:42 <Lunar^> http://wiki.gnuarch.org/moin.cgi/Tracking_20a_20project_20that_20doesn_27t_20use_20Arch
08:41:40 <shapr> hmm, I think I may be able to beat that with darcs
08:42:02 <Igloo> If not it's worth e-mailing DR and asking for something like it IMO  :-)
08:42:07 <shapr> truly
08:42:15 <shapr> david is *very* responsive.
08:42:43 <shapr> anyways, after I'm done with getting XmlRpc to unit test Zope...
08:42:49 <shapr> ohh
08:43:04 <Lunar^> shapr: What do you think of the screenshot ?
08:43:44 <shapr> looks sexy to me.
08:43:51 <bring> shapr: so what was the problem?
08:44:03 <shapr> I have a few 486 machines that will probably be running hOp soon :-)
08:44:09 <shapr> bring: http://shapr.homelinux.net/~shae/Test_XmlRpc.hs
08:44:35 <shapr> that gives a big long error message that suggests the monomorphism restriction
08:45:27 <shapr> should I be giving an explicit type somewhere? "No instance for (Network.XmlRpc.Client.Remote (m [Char]))" is the error
08:46:05 <shapr> calling remote with three strings works fine in ghci
08:47:23 <bring> yes, you need to force it to be IO [Char] instead of m [Char]
08:47:31 <earthy> anyway, time to go home
08:48:51 <bring> I think it works in ghci because of type defaulting
08:49:14 <shapr> which it?
08:49:22 <bring> ?
08:49:34 <shapr> er, which argument needs to have the explicit type?
08:50:14 <bring> ah, the result of the call to remote
08:50:45 <shapr> aha!
08:50:52 <shapr> yay!
08:52:55 <bring> from your sudden expression of joy I conclude that the outcome was favorable
08:53:11 <shapr> Cases: 1  Tried: 1  Errors: 0  Failures: 0
08:53:11 <shapr> Counts {cases = 1, tried = 1, errors = 0, failures = 0}
08:53:16 * shapr cheers joyfully
08:53:58 <shapr> this also means I can now write tests for XmlRpc itself.
08:54:44 <bring> that would be nice
08:58:54 <Lunar^> shapr: How is gforge doing currently ? 
08:59:53 <shapr> it's dead, Jim.
09:00:00 <Lunar^> ???
09:00:09 <shapr> Lunar^: so, when do we get hOppix?
09:00:23 <Lunar^> hihi
09:00:36 <Lunar^> We're getting this in a releasable shape
09:00:51 <Lunar^> Removing licensing issue is done now
09:00:53 <shapr> I can see compiling my program onto a bootable hOppix CD :-)
09:00:58 <Lunar^> sebc is making a nice tarball
09:01:55 <shapr> the Simons and the haskell.org maintainers didn't see how a haskell-specific gforge was better than sourceforge.
09:02:15 <shapr> and SPJ said he'd rather see LIP get more effort
09:02:27 <Lunar^> LIP = Library Infrastructure Project ?
09:02:30 <shapr> yes
09:02:37 <shapr> speaking of which, I owe SyntaxNinja some code :-)
09:03:00 <Lunar^> We'll see how the project is received on Haskell mailling-lists
09:03:14 <Lunar^> But it could be cool to make it a joint effort
09:03:29 <Lunar^> I would be quite glad when it'll run HWS-WP
09:04:19 <shapr> me too
09:15:18 <ski> hello DeltaZer0
09:16:09 <DeltaZer0> hello
09:17:10 <ski> have you wriiten any haskell ?
09:17:20 <ski> (s/wriiten/written/)
09:18:39 <ski> or got any questions ?
09:19:13 <DeltaZer0> i'm wondering what book i should get
09:19:36 <shapr> Hudak is good if you like math
09:19:41 <shapr> Thompson is good if you don't
09:19:47 <shapr> that's my opinion at least :-)
09:20:11 <shapr> you should probably start with the Gentle Introduction, some people don't need a book.
09:20:17 * shapr wasn't one of those.
09:20:37 <DeltaZer0> i have a nice, shiny bachelor's degree in math
09:20:55 <shapr> wow, do you have a pic of the shiny part?
09:21:31 <DeltaZer0> no, no pics
09:21:34 <shapr> aww
09:21:36 <DeltaZer0> but it really is shiny
09:21:39 <shapr> I wanna see!
09:21:45 <DeltaZer0> lol
09:22:11 <shapr> ok, I'll be patient.
09:22:25 <shapr> anyways, check out Hudak's book. It's spiffy.
09:22:26 <DeltaZer0> i do have a digital camera
09:22:32 <DeltaZer0> $30 for paperback
09:22:34 <DeltaZer0> not too bad
09:23:11 <ski> so ..  what do you know about haskell ?
09:24:09 <DeltaZer0> next to nothing
09:24:59 <ski> have you used any functional programming language ?  (or indeed any programming language at all ?)
09:25:33 <DeltaZer0> i also have a nice, shiny bachelor's degree in computer science
09:25:39 <DeltaZer0> but i never took any FP classes
09:25:39 <ski> ok :)
09:26:06 <DeltaZer0> why does amazon.com say this book has less than 416 pages?
09:26:37 <shapr> Hudak's book isn't particularly thick.
09:26:54 <DeltaZer0> but hudak's page says it has 416 pages
09:27:07 * shapr looks at his copy
09:28:06 <shapr> my copy has 363 pages.
09:28:14 <shapr> maybe 2nd edition is out?
09:28:18 <ski> different editions ?
09:29:08 <DeltaZer0> it seems the 2000 edition is the 4th
09:29:25 <DeltaZer0> well, it *is* the same book, in any case
09:29:37 <shapr> says 382 pages here - http://titles.cambridge.org/catalogue.asp?isbn=0521644089
09:29:42 <shapr> and that's the publisher.
09:29:55 <shapr> someone can't count, this much we know.
09:30:18 <DeltaZer0> hmm
09:30:23 <DeltaZer0> ok
09:42:36 <shapr> bring: does XmlRpc support auth?
09:43:01 <bring> normal http authentication?
09:43:10 <shapr> I guess so?
09:43:52 <shapr> that would be part of HTTP.hs then?
09:46:45 <bring> well, as far as I remember http authentication is done by simply adding an "Authorization" header field to the request
09:47:00 <shapr> that's easy enough
09:47:04 <bring> HTTP supports that, and defines HdrAuthorization
09:47:43 <bring> now, XmlRpc.Client doesn't allow the user to add extra headers, but that could be easily hacked in
09:47:49 <ham[let]> hiho
09:48:00 <ski> hi ham[let]
09:48:10 <shapr> I'd be interested in some way to do that.
09:48:13 <shapr> hi ham[let] 
09:49:28 <bring> basically the header just has to be added in the list right at the end of Client.hs, but I'll try to think of a clean way to allow the user to add arbitrary header fields
09:50:22 <bring> hmm, if we just want authentication, we could put it in the url
09:50:32 <shapr> basic http auth appears to be a standard thing to combine with xml-rpc, but I may be biased since most my xml-rpc involvement has been with Zope.
09:50:59 <shapr> oh, I've seen syntax for that
09:51:06 * shapr tries to remember
09:51:07 <bring> as in: http://username:password@hostname/
09:51:09 <bring> ?
09:51:17 <shapr> I think that's it.
09:51:34 <shapr> amusingly, that would involve parsing another colon :-)
09:52:52 <shapr> that would be another useful addition to HTTP.hs
09:53:03 <bring> yes, I'll add that
09:53:05 <shapr> speaking of which, is Warrick integrating the various changes?
09:53:26 <bring> I've tried to contact him, got no repsonse
09:53:32 <bring> then tried googling for him
09:53:43 <shapr> he's become a Perl Monk?
09:53:48 <shapr> Luddite?
09:53:52 * shapr grins
09:53:55 <bring> he seems to have disappeared some time after mid-2002
09:54:08 <shapr> sounds like we should host the canonically correct version ourselves.
09:54:35 <bring> starting to think so
09:55:10 <shapr> Peter Thiemann has some basic MIME support in WASHMail
09:55:23 <bring> from my brief amateur google detetctive work I'm afraid Warrick may have passed away
09:55:36 <shapr> we could talk to Marvin-- about SSL support, he did PyOpenSSL
09:55:40 <shapr> why do you think that?
09:55:58 <bring> phone, brb
09:56:13 * shapr googles
10:03:46 <shapr> hi cptchaos 
10:03:58 <cptchaos> hi
10:12:30 <shapr> bring: ok, I give up, I can't figure out what you found.
10:12:41 <bring> not much really, just that there's nothing on google from after june 2002, and he is the author of a site for arachoiditis sufferers
10:12:42 <shapr> but I am now terribly curious.
10:13:19 <shapr> oh
10:16:44 <bring> though the web page for HTTP.hs reports a last modfied date 02/24/2003 06:56:24 AM
10:23:43 <shapr> I wonder if I can hack in temporary user:pass parsing ...
10:25:29 <bring> oh, right, that's what we were doing
10:25:41 <bring> not tracking down missing haskell hackers
10:25:45 <shapr> :-)
10:26:23 <bring> I can do it, just want to find an RFC for it
10:26:29 * bring likes RFCs
10:26:38 <shapr> I did find out that he has an Honour's Bachelor's in CS, his thesis was on Monadic Functional Parser combinators.
10:26:44 <shapr> I like code.
10:26:52 <bring> :)
10:26:56 <shapr> I'm fond of the IETF motto, "rough consensus, running code"
10:27:18 <shapr> I think I'm not a real programmer though, since I always prefer to use or modify existing code rather than write something myself.
10:29:12 <bring> found it, RFC 1738: //<user>:<password>@<host>:<port>/<url-path>
10:29:44 <DeltaZer0> shapr, why is that a bad thing?
10:30:07 <DeltaZer0> if everyone wrote their own programs from scratch, we'd have nothing but crap
10:30:17 <shapr> I think we need both flavors.
10:31:27 <bring> RFC 296: "Some URL schemes use the format "user:password" in the userinfo
10:31:28 <bring>    field. This practice is NOT RECOMMENDED, because the passing of
10:31:28 <bring>    authentication information in clear text (such as URI) has proven to
10:31:28 <bring>    be a security risk in almost every case where it has been used."
10:31:41 <bring> stupid formatting
10:31:51 <DeltaZer0> well, duh
10:32:12 <DeltaZer0> you need https if that password matters
10:32:27 <shapr> this says otherwise --> http://support.microsoft.com/default.aspx?scid=kb;[LN];834489
10:32:42 <shapr> for example, that user/pw will still be in your history.
10:33:23 <shapr> anyways, I still want it because it's easier than setting up HTTP.hs to use the equivalent cookies.
10:33:33 <DeltaZer0> shapr, that says IE no longer supports login information in the URL
10:33:40 <shapr> right
10:33:42 <bring> yeah, I'll add it
10:33:49 <shapr> bring: many thanks :-)
10:34:09 <shapr> or do you think it could be just as easy to use auth cookies?
10:34:16 * shapr doesn't know
10:34:39 <bring> it would be more difficult with XmlRpc, as we would need to add extra headers
10:35:03 <bring> when we put it in the url, no functions need extra arguments
10:35:05 <shapr> that sounds like overly tight coupling
10:35:06 <shapr> right
10:35:46 <shapr> though if you/I pick up hosting the canonical copy of HTTP.hs, we should put the equivalent warning in the docs.
10:36:23 <bring> I'll be sure to put that in a haddock comment somewhere
10:37:19 <shapr> so, idle question, are you going to add that parsing code in the next few minutes, or should I hack in some of my own temporary code locally?
10:37:32 <bring> I'm working on it right now
10:37:37 <shapr> yay!
10:37:51 <shapr> see, I'm not a Real Programmer ;-)
10:40:34 <shapr> hello Si
10:40:41 <Si2> hello
10:40:48 <shapr> looking for Haskell info?
10:41:44 <shapr> wow, we've nearly hit 80 clients on #haskell
10:45:37 <DeltaZer0> glad i can help
10:47:04 <Riastradh> Bah!
10:59:45 <shapr> hi wglwill 
10:59:49 <shapr> looking for Haskell info?
11:00:10 <wglwill> hi
11:00:14 <wglwill> yes infact i am
11:00:22 <wglwill> i'm curious if haskell object code can be linked with c++ object code
11:00:36 <shapr> yes, in both directions.
11:00:39 <wglwill> if so is it something that would be recommended?
11:00:50 <shapr> sure, if you want to.
11:01:38 <wglwill> cool, i'm thinking about trying to write mixed programs, using haskell for all the logic and functionality code and just c++ for time critical algorithms
11:01:48 <wglwill> to cut down on bugs and such
11:01:55 <wglwill> and make it easier to write
11:02:09 <shapr> There's a useful pattern called 'Alternate Hard and Soft Layers' where you write most of your code in the most expressive language you can find, and then when you profile, you can write the speed-necessary parts in a lower level but less expressive language.
11:02:12 <shapr> I think we just said the same thing.
11:02:47 <shapr> http://c2.com/cgi-bin/wiki?AlternateHardAndSoftLayers
11:02:53 <shapr> wglwill: yes, I totally agree with you.
11:04:22 <wglwill> i've only recently been introduced to functional programming and it seems like a really great thing, surprising more programs don't use it
11:04:47 <shapr> I think it's because programmer culture changes slowly.
11:05:14 <shapr> also, Haskell doesn't have much for an advertising budget.
11:06:16 <wglwill> have you ever heard of wings3d?
11:06:19 <shapr> sure
11:06:23 <shapr> I've used it.
11:06:55 <wglwill> that's like my favorite modeller, when i realized erlang was a functional language i realized why it was significant that it was written in it
11:06:59 <shapr> it's my favorite 3D modeler (not that I've used many)
11:07:12 <wglwill> also explains why when i tried to read the source it didn't make any sense to me :)
11:07:18 <shapr> :)
11:09:01 <wglwill> have you ever used mirai? the program wings is based on
11:09:16 <shapr> There's also #wings3d and #erlang channels. You may want to try them if you haven't already.
11:09:18 <shapr> no, I haven't
11:09:35 <shapr> I'm allergic to closed source software.
11:09:36 <wglwill> ah, well it's a 3d animation program that was written totally in lisp
11:09:48 <wglwill> they pioneered the modern subdivision surface modelling methods
11:09:58 <wglwill> apps like maya and 3dsmax have been mining it for features for years
11:11:36 <bring> is there a library function  Monad m => m a -> m b -> m a ?
11:12:24 <bring> >>, but returns the first result
11:13:41 <shapr> wglwill: well, jump in, the water's fine.
11:14:26 <wglwill> well thanks for the info shapr i think this might be just the solution i need to write better programs
11:14:27 <ski> bring : hmm, like  SML's before : 'a * unit -> 'a
11:15:40 * shapr tries to figure out how to turn python xmlrpclib naming conventions into XmlRpc calls
11:15:47 <bring> easy enough to write: \a b -> a >>= \x -> b >> return x but it seems like it should be a standard function
11:16:32 <bring> shapr: what do those look like?
11:17:07 <ski> bring : i sortof thought i'd seen such a function somewhere, but i might be misremembering.. :(
11:17:33 <bring> ski: I thought I had too, but I can't find it
11:17:40 <shapr> bring: f=xmlrpclib.Server('http://localhost:8080') ; print f.objectIds()
11:18:59 <bring> shapr: does that mean: remote "http://localhost:8080" "objectIds" :: IO something
11:19:10 <shapr> doesn't seem so, since that gives an error.
11:22:53 <shapr> sebc: wow, is it really you??
11:22:59 <sebc> hi shapr
11:23:03 * shapr grins
11:23:07 <sebc> http://www.macs.hw.ac.uk/~sebc/hOp/
11:23:10 <shapr> greetings sebc 
11:23:17 <shapr> yay!
11:23:41 <shapr> how did you end up doing malloc?
11:24:09 <ski> patanisca : hi
11:24:25 <sebc> I am using Doug Lea's public domain implementation, together with a dumb implementation of sbrk;  paging is not enabled, which keeps things very simple
11:25:05 <shapr> neat
11:25:18 <ski> patanisca : got any haskell questions ?
11:25:59 * shapr looks for a blank floppy
11:26:04 <sebc> hehe
11:27:07 <shapr> hey, did you ever talk to John Launchbury?
11:27:27 <shapr> he told me he's looking for a way to get GHC RTS running on the bare metal.
11:27:46 <sebc> well, that's hOp :)
11:27:54 <shapr> yup
11:28:13 <shapr> John seemed interesting in funding such a thing.
11:28:23 <sebc> funding?  $)
11:28:26 <shapr> or at least selling it to some of his clients
11:29:07 <sebc> interesting, I'll get in touch with him
11:29:21 <sebc> all the code I wrote for hOp is in the public domain, by the way
11:29:31 <shapr> cool
11:30:21 <shapr> do you have a public source repo for hOp?
11:30:34 <sebc> Lunar is setting that up
11:30:48 <shapr> ok
11:31:01 <sebc> well, it's not public since it's on my box at the university :-(
11:31:12 <sebc> he plans on using GNU arch
11:31:37 <sebc> we will probably be looking for a server to host the repository
11:31:45 <shapr> I can host it.
11:31:59 <shapr> on ScannedInAvian.org
11:32:14 <sebc> oh, that would be great, thanks!
11:33:31 <shapr> is there a difference between GNU arch and Tom Lord's arch?
11:33:38 <sebc> I have no idea
11:33:54 * shapr doesn't either
11:34:06 <shapr> I'll talk to Lunar^ about it.
11:34:34 <shapr> any exciting news about intersection types?
11:35:07 <sebc> I'll be working on the approximate analysis now, which is the first step for practical applications
11:35:49 <shapr> I mentioned intersection types to Martin Sulzmann, he hadn't heard of them before.
11:36:09 <sebc> I am looking for some kind of incremental editor, like projects Harmonia (which looks quite proprietary) and Proxima (written in Haskell, but the author does not have time to finish it)
11:37:00 <sebc> intersection types are not very common (yet, I hope :))
11:37:39 <shapr> it's good stuff, I wish haskell-mode supported intersection types.
11:38:03 <shapr> what about Programatica? is it incremental?
11:38:22 <ski> what are they (intersection types) good for ?
11:38:27 <sebc> it would require some kind of incremental parsing like Harmonia provides, so that the incremental aspect of intersection types can be used
11:39:12 <shapr> ski: it would let me see the spots in the source where my types can match, and can't match
11:39:22 <sebc> intersection types look very promising for expressing many kinds of incremental analyses that can go to an arbitrary degree of precision
11:39:23 <shapr> I don't have the url handy for sebc's paper.
11:39:47 <shapr> oh, here: http://www.macs.hw.ac.uk/~sebc/
11:39:59 <sebc> for comparison, Hindley/Milner does some fixed amount of analysis
11:40:03 <shapr> sebc: btw, any plans for more wiwiwi dev?
11:40:30 <sebc> shapr: research leaves me too little time for that :-/
11:40:37 <shapr> that's understandable.
11:40:38 <ski> shapr : like type error slicing ??
11:40:47 <shapr> yes, I think it's related.
11:40:53 <sebc> ski: type error slicing use intersection types for analysis, yes
11:41:00 <ski> ok
11:42:10 <ski> that would indeed be nice to have in one's IDE ..
11:42:27 <shapr> yes, I usually do the same thing myself, manually.
11:42:41 <ski> what do you mean ?
11:43:08 <shapr> today I figured out how to use HUnit for testing IO code
11:43:12 <ski> trying to find out the possible places contributing to the error ?
11:43:14 <shapr> right
11:43:46 <shapr> I'd comment out half the code and see if the type checker passed it
11:43:53 <ski> heh :)
11:44:04 <sebc> shapr: I haven't looked into Programatica, I don't know if it is incremental
11:44:10 <ski> i have used that, too
11:44:31 <shapr> so, each time the type checker passed the code, I'd assign that to its own toplevel var and work with whatever was left.
11:45:04 <shapr> hi stepcut 
11:45:35 <shapr> sebc: are you anywhere close to oxford?
11:45:50 * shapr knows nothing about UK geography.
11:46:24 <sebc> shpar: I'm in France now for about a week;  I don't think Edinburgh is very near Oxford though
11:46:32 <shapr> Since I was drafted into working on the europython conference, I've been thinking about irregular EuroHaskell meetings.
11:46:49 <shapr> bring said I could sleep on his floor for a gothenburg hack-fest for example :-)
11:47:09 <shapr> c'est chouette
11:47:29 <ski> shapr : ("thinking about irregular" = "irregulary thinking about" ? :)
11:47:46 <shapr> peut-etre nous avon #haskell.fr aussi?
11:47:51 * shapr grins
11:48:19 <shapr> err "nous avon besoin de"
11:48:31 <sebc> Lunar^ is back, I need to go :)
11:48:35 <shapr> ok, cya!
11:48:42 <sebc> see you later
11:49:19 <shapr> ski: I don't know if there's enough Haskell activity for a once a year Haskell conference, but pre-arranged gatherings in .se and .uk would probably work.
11:49:30 <shapr> well, time for food, bbl
12:00:29 <stepcut> hi shapr
12:19:39 <Lunar^> shapr: I still thinking about creating a HUG in Paris
12:21:12 <Lunar^> shapr: GNU Arch is Tom Lord's
12:22:10 <Lunar^> shapr: Anyway, "GHC RTS on the metal" is a really good way to define hOp, and thanks for that expression :)
12:26:21 <Lunar^> damn.. there's so many work to do now
12:26:36 <Lunar^> We need an assembler, a truetype loader, renderer
12:26:46 <Lunar^> drivers.... Ok who wants to code some Haskell now ?!
12:26:57 <shapr> me me!
12:27:02 <Lunar^> :))
12:27:11 <shapr> but I'm going to be social with my woman instead
12:27:15 <shapr> balance is important!
12:27:21 <shapr> but first...
12:27:29 <Lunar^> lol
12:27:31 <shapr> bring: hey, how's the HTTP auth?
12:27:40 <bring> not much left
12:27:49 * shapr bounces happily
12:28:09 <shapr> bring: thank you for doing so much that has helped me towards getting paid to write Haskell :-)
12:34:56 <ski> Oh no, more Lemmi(ngs) !                                    :)
12:37:15 <bring> eureka!
12:37:29 <shapr> your bathwater is too hot? :-)
12:37:50 <ski> what did you find ?
12:38:23 <bring> well, maybe that was the wrong interjection
12:38:31 <bring> got the authentication thing working
12:38:43 <bring> shapr: you're welcome
12:38:45 <shapr> I think that's a eureka moment
12:38:54 * ski just misread 'Shape' (on usenet) as 'Shapr' :)
12:39:00 <shapr> haha!
12:39:05 <shapr> you've been memed ;-)
12:40:04 <ski> hmm, one could think of it as a word-based 'not-snuffy'
12:40:59 <shapr> not-snuffy?
12:41:15 <ski> http://www.hopkinsfan.net/ob/notsnuffy/notsnuffy1.html
12:43:51 <shapr> that's interesting
12:43:51 <ski> it's a funny term
12:43:57 <ski> yes
12:44:36 <shapr> bring: you have code online?
12:44:45 <bring> soon...
12:44:55 <shapr> ok
12:45:03 <shapr> oh, you're going to make a new release of xmlrpc?
12:45:09 <bring> yep
12:45:11 <shapr> spiffy
12:45:33 <shapr> I'll just grab it tomorrow morning, as I'm heading for sleep now.
12:45:39 * shapr disappears
12:45:52 <Lemmih> ski: I'm currently on the office and my home computer has auto join :)
12:46:28 <ski> Lemmih : it tries to join, over and over again ?
12:50:12 <bring> shapr: haskell-xml-rpc-20040219 available now
12:56:30 <ski> hi m-p-h
12:57:06 <Marvin--> whee
12:57:15 <m-p-h> hello
12:57:29 <Marvin--> Mongoose are making a new edition of PARANOIA
12:57:37 <Marvin--> "PARANOIA's second edition rules were, of course, perfect. The new PARANOIA XP expunges certain imperfections introduced by subversive elements, and will be even more perfect."
12:57:38 <ski> m-p-h : have any haskell questions ?
12:57:57 * Marvin-- bounces around in cheerful bliss
12:58:25 <ski> Marvin-- : how can something be 'more perfect' ? :)
12:59:11 <Marvin--> ski: Careful citizen, that information is not available at your security clearance. Do you doubt The Computer? Perhaps you need to visit the Bright Vision Re-Education Center.
12:59:48 <ski> Marvin-- : oh, newspeak ?
13:00:03 <Marvin--> seriously, you've never played Paranoia?
13:00:15 <Marvin--> BUY PARANOIA. IT WILL BE FUN. FUN IS MANDATORY.
13:00:34 * ski doesn't even know what it is
13:00:48 <Marvin--> it's a roleplaying game
13:00:51 <ski> ok
13:01:12 <m-p-h> as a matter of fact i do happen to have some haskell questions if you're willing to help
13:01:27 <ski> m-p-h : sure
13:01:42 <Marvin--> ski: it's sort of set in a dark, humorous future ruled by The Computer
13:03:47 <ski> Marvin-- : sounds like fun !
13:04:27 <ski> m-p-h : state your questions
13:05:08 <m-p-h> sorry, i'm trying phrase it in a readable manner
13:05:23 <ski> ok
13:06:06 * bring realizes that the Browser module already contains way more advanced authentication support than what he has hacked together
13:06:53 <m-p-h> I'm writing a function that takes a list of Int and produces a list of pairs of Int, i.e. myFunction :: [Int] -> ([Int, Int]) It should be enough just to put the numbers into pairs sequentially, e.g...
13:07:10 <TheComputer> State your reason for requesting this information.
13:07:22 <Marvin--> sorry, couldn't help it :)
13:07:30 <m-p-h> if i had the list [1,2,3,4] i'd expect to get out [(1,2) (3,4)]
13:07:33 <ski> Marvin-- : I actually haven't played any real PRG. (Just some single-player Computer ones, and thngs like Lone Wolf. Also i've read a bit in description books for e.g. Drakar och Demoner ..)
13:07:55 <Marvin--> ski: you should really give it a try :)
13:08:12 <ski> m-p-h : ah, ok
13:08:27 <Marvin--> m-p-h: list of pairs of Int would be [(Int,Int)]   not ([Int,Int])
13:08:32 <ski> that should not be so hard, methinks
13:09:30 <m-p-h> good point marvin, just a typo (fortunately)
13:09:45 <Marvin--> good :)
13:09:56 <ski> TheComputer : Oh, mighty Computer, i know i'm not worthy of thy answers, but, how can we worship thou better ?
13:10:23 <Marvin--> m-p-h: well, what do you have so far?
13:11:30 <m-p-h> not as much as i'd like :-( my function needs to be recursive, which i'm having a hard time getting my head around
13:11:31 <ski> Marvin-- : yeah, sometime ..  *really*
13:12:02 <ski> so you need a base case and a recursive case (at least)
13:12:51 <m-p-h> i was working along the lines of taking the head of the list and then taking the head of the tail
13:13:40 <Marvin--> m-p-h: and what kind of restriction does that impose on the length of the list?
13:14:01 <ski> by calling the function 'head' or by using pattern-matching ?
13:15:09 <m-p-h> i think i was trying to combine both with little success
13:16:11 <m-p-h> something like (x:xs) = (x, head xs)
13:16:20 <ski> can we see what you've written so far (so we can critizise it >:-} ) ?   or is it secret ?
13:16:40 <Marvin--> m-p-h: there's an easier way to write that, actually
13:16:52 <Marvin--> m-p-h: you can write   foo (x1:x2:xs) = (x1,x2)
13:16:53 <ski> myFunction (x:xs) = (x, head xs)   you mean ???
13:17:21 <m-p-h> ski: yeah
13:17:35 <ski> also, myFunction should return a *list* of pairs, and not just a pair, right ?
13:17:37 <m-p-h> marvin: ah, i've only ever seen x:xs done
13:18:08 <m-p-h> that's right. which is one of the problems i was having as much implementation / body doesn't match my definition
13:18:13 <ski> m-p-h : [1,2,3] = 1:[2,3] = 1:2:[3] = 1:2:3:[]
13:18:15 <Marvin--> m-p-h:  (x1:x2:xs)  is equal to  (x1:(x2:xs)),  you can nest patterns arbitrarily deep
13:19:55 <Marvin--> m-p-h: so, now we know how to turn the two first elements of a list into a pair, right? Now comes the recursion
13:19:55 <ski> m-p-h : do you know how you can return a list (of a single pair), if you have a pair  (as you have got, above) ?
13:21:07 <m-p-h> not really
13:21:16 <ski> (on second thought, this line might be scapped anyway, so it perhaps doesn't matter)
13:21:19 <ski> well
13:22:02 <ski> [(x1,x2)]  is a list containing the single pair, which consists of x1 and x2
13:22:32 <m-p-h> makes sense so far
13:22:49 <Marvin--> m-p-h: well, anyhoo, xs is a list of ints, right? And we know how to turn a list of ints into a list of pairs, we apply foo! We can use  foo xs  in the right-hand-side of the definition of foo (x1:x2:xs)
13:23:37 <ski> in any case, we could either first try some more basic easy cases, like the input has 4 or 6 elements, or we could go straight to the recursion and try to solve the general case ..
13:24:11 <ski> (the second way being what Marvin-- is doing ;)
13:24:26 <m-p-h> i like the general case :-)
13:24:35 <ski> good :)
13:25:39 <ski> to use recursion we should try to figure out : what is a 'simpler' problem 'of the same sort' which we are currenty trying to solve ?
13:26:19 <ski> e.g. to compute the length of a list, the 'simpler' problem is computing the length of the tail of that list
13:26:52 <ski> ok ?
13:27:24 <m-p-h> yep, i can see that. not sure if i can think of a simpler problem in relation to my problem though :-s
13:28:32 <ski> if we have a long list of integers (presumably an even number of them), we know how to grab initial elements off the list, right ?   see how ?
13:29:08 <ski> (hint : look a bit above)
13:29:10 <m-p-h> using that x1:x2:xs notation, right?
13:29:15 <ski> yep
13:30:01 <ski> for any *predetermined* (finite) number, we can grab that many elements off the front of the list
13:30:28 <ski> like x1:x2:x3:x4:x5:x6:xs
13:30:50 <m-p-h> okay
13:30:55 <ski> but we want our function to handle *any* length of the list (well, even length)
13:31:49 <ski> so writing like that (i.e. trying to get many pairs of ints off the list in one go) isn't buying us much
13:33:32 <ski> usually it's clearer and sufficient to convert our current problem (computing myFunction for the current input) to a smaller problem that is "one-step smaller" than the current one
13:34:05 <ski> have you seen a definition of length ?
13:34:20 <m-p-h> not that i know
13:34:32 <ski> (ok, forget about that, then)
13:35:34 <ski> the idea is : if we can convert the current problem into some work now + a smaller one, we can call the function we are trying to define on that smaller problem
13:36:13 <ski> so, that call will in turn call myFunction on yet another smaller problem, all the way down to a base case, which is solved directly
13:37:07 <ski> do you follow ?
13:37:17 <m-p-h> yeah
13:37:19 <ski> ok
13:37:29 <ski> so do you have a base case ?
13:38:24 <ski> (one sometimes has more that one base case, also sometimes more that one recursive case. it differs)
13:38:25 <m-p-h> if there's only two integers in the list a pair can be formed directly... would that count?
13:38:30 <ski> yes
13:38:35 <ski> that would work
13:38:48 <ski> can you write that ?
13:39:34 <m-p-h> with recursion probably not
13:40:01 <ski> the base case should not use recursion (of the function is belongs to), yes
13:40:22 <ski> myFunction ... = ...
13:41:13 <ski> m-p-h : (BTW, you might want to choose a proper name for your function ..)
13:41:39 <m-p-h> maybe when i've written it i will ;-)
13:41:54 <ski> ok :)
13:42:20 <Marvin--> "myFunction" is way too long, I prefer "foo" myself ;)
13:43:10 <ski> Marvin-- : i concur
13:43:40 <ski> do you need help with formulating the base case ?
13:44:54 <m-p-h> using pattern matching i guess it would like: myFunction [x,y] = [(x,y)]
13:45:05 <ski> yes
13:47:34 <ski> so ..
13:48:26 <ski> if we have an input list of, perhaps 4 or 6 or 8 elements, what would a 'smaller problem of the same kind' be ?  have any idea ?
13:49:03 <m-p-h> a pair of elements removed?
13:49:40 <ski> yes, we can try that
13:49:53 <ski> how would we begin to write that ?
13:51:00 <m-p-h> i imagine it would be something along the lines of myFunction [x1:x2:xs] = [(x1,x2)], though i suspect that's not quite right
13:52:09 <ski> [x1,x2] is shorthand for x1:x2:[] , so [x1:x2:xs] is a list containing a single element, which is a list of at least 2 elements
13:52:11 <Marvin--> that'd be  (x1:x2:xs),  not [x1:x2:xs]
13:52:17 <ski> right
13:53:15 <ski> the parenthesis is needed because otherwise haskell thinks you've written     (myFunction x1):x2:xs = ...
13:55:51 <ski> m-p-h : ok ?
13:56:04 <m-p-h> i think i just about follow that
13:56:31 <ski> ok, so now you have   myFunction (x1:x2:xs) = [(x1,x2)]
13:56:53 <ski> this is of course not quite right, yet
13:57:16 <ski> it discards xs, i.e. all but the first two elements of the input
13:57:28 <m-p-h> is this where the recursive call comes in?
13:57:31 <ski> yes
13:58:00 <ski> somewhere on the right-hand-side (of the '=') we should call myFunction (i.e. recursively)
13:58:18 <ski> what argument do you think this call to myFunction should have ?
13:58:26 <m-p-h> xs
13:58:31 <ski> (it should be the 'smaller argument')
13:58:32 <ski> yes
13:59:01 <ski> if we imagine that this call does what it is supposed to do, what would that call return, then ?
13:59:32 <m-p-h> the next pair of integers i think
14:00:09 <ski> what should the *current* call of myFunction return ?  (i.e the call with (x1:x2:xs) as argument)
14:00:35 <ski> what do we, conceptually, *want* it to return ?
14:00:57 <m-p-h> it would effectively return the answer to the entire problem
14:01:02 <ski> which is ?
14:01:04 <ski> :)
14:01:15 <m-p-h> the list of all the pairs of integers
14:01:18 <ski> yes
14:01:51 <ski> and the recursive call would effectively return the answer to the *subproblem*  (i.e. myFunction xs)
14:02:19 <ski> what, pray tell, could that returned value be ?   ;)
14:02:38 <ski> (trying to get you to think recursively)
14:02:41 <Marvin--> sheesh, Disney bought the rights to Kermit and ms Piggy
14:02:51 <Marvin--> long live "intellectual property" :/
14:02:52 <Riastradh> ...!
14:03:28 <Marvin--> for an "undisclosed" sum
14:03:38 <m-p-h> that result would be equivalent to the solution to the entire problem, minus the first pair of integers
14:03:45 <ski> m-p-h : i.e. what is the recursive call returning ?   (sorry, no, it doesn't return just the next pair :(  )
14:03:57 <ski> yes !
14:04:22 <ski> that means ...  it returns a list of pairs, but the first two elems are not included
14:04:29 <ski> ok ?
14:04:35 <m-p-h> yep
14:05:46 <ski> so, given the first two integers (i.e. x1 and x2) and given the result of this recursive call, how can we construct what we want to return from the *current* call to myFunction ?  (i.e. how to construct the list of all pairs, including the first two integers)
14:07:04 <m-p-h> the recursive call needs to be concatenated to the first pair
14:07:21 <ski> or, given 4 and 5 and [(6,7),(8,9)], how do we construct [(4,5),(6,7),(8,9)] ?
14:07:24 <ski> yes
14:07:26 <ski> right
14:07:37 <ski> do you know how one can do that ?
14:08:25 <m-p-h> that would be the same notation as x1:xs
14:08:40 <ski> go on ..          :)
14:08:56 <m-p-h> something like [(x1,x2):myFunction xs]
14:09:29 <ski> remember, [x1:xs] isn't x1 added to the front of xs !
14:09:55 <ski> (you are almost there :)
14:10:20 <m-p-h> hmmm
14:11:03 <ski> ( [...] is used when we want to write a list with *predetermined* number of elements)
14:11:25 <ski> (here we want to add a pair to the front of a list of *any* length)
14:12:24 <ski> ( [] is of length 0, [4] is of length 1, [4,5] is of length 2, [4,5,6] is of length 3, and so on ...)
14:12:54 <ski> the ":"-notation puts an element in front of a list, remember ?
14:13:10 <ski> 1:[2,3] is the same as [1,2,3]
14:13:20 <m-p-h> okay
14:13:44 <ski> you don't need to wrap a  blaha:moreBlahas  thing is [ ]
14:14:41 <ski> (above you said  [(x1,x2):myFunction xs],  so you should have said ...   what ?)
14:15:24 <ski> if you don't see it, i can tell you .. if you want
14:15:46 <m-p-h> it might be best to put me out of my misery
14:16:18 <ski> well, *ta-dam-ta-dam* :  (x1,x2):myFunction xs    !
14:16:23 <ski> :)
14:16:50 <m-p-h> oh :-)
14:17:35 <ski> so what does that make of your recursive case ?
14:18:40 <m-p-h> what do you mean?
14:19:08 <ski> what should the recursive line of myFunction look like ?
14:19:26 <ski> the base case being :
14:19:43 <ski> myFunction [x1,x2] = [(x1,x2)]
14:21:16 <m-p-h> myFunction [x1:x2:xs] = (x1,x2):myFunction xs ?
14:21:55 <ski> well, what did Marvin-- say about [x1:x2:xs] ?  :)
14:22:31 <m-p-h> use parentheses instead?
14:23:18 <ski> not, 'instead'. but : drop the [ ], and then add ( ) because of priority rules
14:23:44 <ski> so, that means, do that, yes :)
14:23:58 <m-p-h> i see, the same but different ;-)
14:24:14 <cm> heyp
14:24:50 <ski> compare with :  2 + 3 * 4  is the same as  2 + (3 * 4) , but it's not the same as  (2 + 3) * 4
14:24:56 <ski> cm : hi
14:25:44 <ski> so  myFunction x1:x2:xs  is the same as  (myFunction x1):x2:xs , but it's not the same as  myFunction (x1:x2:xs)
14:25:52 <ski> and we want the latter one
14:25:58 <ski> m-p-h : ok ?
14:26:07 <m-p-h> yeah i see it now
14:26:32 <ski> that is the only reason we need parenthesis there
14:26:55 <ski> they really has nothing to do with adding an element to the front of a list
14:27:08 <ski> (or doing the inverse of the with a pattern)
14:27:48 <ski> so, to go back to your function ..
14:28:11 <ski> myFunction [x1,x2   ] = [(x1,x2)]
14:28:24 <ski> myFunction (x1:x2:xs) = (x1,x2) : myFunction xs
14:28:41 <ski> do you see why (and how) this works ?
14:29:51 <m-p-h> yeah. it takes the first two elements in the list, then calls itself which causes it to get the next two... and so until it reaches the final two. then it all unwinds.
14:29:59 <ski> yes
14:30:05 <m-p-h> causing all the results to be returned
14:30:07 <ski> yes
14:30:49 <ski> also, what do you think should happen if myFunction gets an empty list as argument ?
14:31:16 <ski> should it be defined ?  if it should be, what should it return ?
14:31:20 <m-p-h> probably myFunction [] = []
14:31:33 <ski> that seems reasonable, i think
14:31:55 <ski> that would be another base case, then
14:32:44 <ski> (but we would only reach that for the empty list, otherwise we'd stop at two elements (base) case , and not recurse more)
14:33:26 <ski> we can write your two-element base case in a slightly different way, wanna see ?
14:33:32 <m-p-h> sure
14:33:46 <ski> myFunction (x1:x2:[]) = (x1:x2) : []
14:34:02 <ski> do you see that it's essentially the same ?
14:34:43 <m-p-h> yeah, because the empty list there is essentially redundant
14:35:13 <ski> ( [4] = 4:[]    [4,5] = 4:[5] = 4:5:[]  and so on ..)
14:35:40 <ski> how is it redundant ? :)
14:36:50 <m-p-h> it doesn't really contribute anything
14:37:20 <Igloo> myFunction (x1:x2:[]) = (x1:x2) : []   isn't well typed
14:37:35 <Igloo> Oh, you meant  myFunction (x1:x2:[]) = (x1,x2) : []    right?
14:37:36 <ski> Igloo : oh sorry :)
14:37:44 <ski> of course
14:37:50 * ski blushes
14:38:45 <m-p-h> thanks for all your help ski (and marvin)
14:38:59 <ski> m-p-h : compare that line with the recursive case
14:39:04 <ski> myFunction (x1:x2:xs) = (x1,x2) : myFunction xs
14:39:14 <ski> myFunction (x1:x2:[]) = (x1,x2) : []
14:39:19 <ski> similar, eh ?
14:39:52 <m-p-h> so it seems
14:40:17 <ski> imagine that we'd ditch the two-element base case, what would happen ?
14:40:39 <ski> the empty-list base case doesn't match a list like e.g. [4,5]
14:40:54 <ski> but the recursive case matches that list, right ?
14:41:17 <m-p-h> yeah
14:41:25 <ski> so, what happens ?
14:41:30 <ski> x1 = 4
14:41:34 <ski> x2 = 5
14:41:36 <ski> right ?
14:41:46 <m-p-h> yep
14:41:52 <ski> what will xs be ?
14:41:57 <m-p-h> []
14:41:58 <ski> yes
14:42:18 <ski> so what will  myFunction xs  be ?  (i.e.  myFunction [])
14:43:06 <m-p-h> [] ?
14:43:19 <ski> by the base case
14:43:26 <ski> myFunction [        ] = []
14:43:33 <ski> so, that's right
14:44:03 <ski> that means that we're going to return  (4,5) : []  or  [(4,5)]  anyway
14:44:17 <ski> just as the previous (two-element) base case would do
14:44:18 <ski> ok ?
14:44:24 <m-p-h> yeah
14:44:41 <m-p-h> it's subtle but it makes sense
14:44:54 <ski> so that, in turn means, that the two-element case is not needed. it is already covered by the other cases
14:44:56 <ski> right
14:45:48 <ski> often, when working with lists, it suffices to have a base case for the empty list
14:45:57 <ski> ok ?
14:46:06 <m-p-h> yep
14:46:32 <ski> that was the end-point i wanted to show here ..   :)
14:47:20 <m-p-h> well thanks again for your help. it's been invaluable.
14:47:23 <ski> (i.e. why make more complicated base cases than you have to)
14:47:27 <ski> ok
14:47:45 <ski> no problem
14:47:52 <m-p-h> i'm going to go get some sleep. cya :-)
14:48:01 <ski> good dreaming, m-p-h !
14:48:10 <ski> bye
14:52:20 <stepcut> what library might I used to do some simple string parsing, if I don't want to deal with regular expressions? Something like parsec but more regular expression oriented?
14:53:05 <Marvin--> you want to do regular expressions but without regular expressions?
14:53:07 <ski> you want regular expression oriented but yet not regular expressions ?  :)
14:53:09 <Marvin--> I'm confused
14:53:12 <Marvin--> and so is ski :)
14:54:08 <Pseudonym> Clearly, stepcut wants to work in paradoxical sets.
14:54:19 <ski> stepcut : can't you take a regular expression library and change it to not be regular expression, but yet almost ?
14:54:28 <stepcut> well
14:54:46 <ski> stepcut : or is 'almost' not quite good enough for you ?
14:55:01 <Marvin--> for simple stuff, I find that pattern matching and functions like span are good enough
14:55:15 <stepcut> I want to do things you would typically do with regular expresions, but I don't want have to write regular expressions
14:55:29 <Marvin--> things like...?
14:56:18 <stepcut> well, I have a config file, which one config option per line. I want to read the config file and parse it into a data structure.
14:56:22 <ski> stepcut : like some kind of combinator library, instead of writing !$#!%&! strings ?
14:56:53 <stepcut> ski: yeah, I thought something existed like that...
14:57:27 <stepcut> the config file is a simple format: dirname whitespace [optional protocol]location
14:57:29 <Marvin--> stepcut: maybe look at Text.ParserCombinators.ReadP?
14:57:50 <Marvin--> or use stuff like words, lines and stuff
14:57:58 <Marvin--> and stuff
14:58:35 <ski> or design your own incompatible library ! ;)
14:58:45 <Marvin--> NIH!
14:59:02 <Pseudonym> Well, it's actually pretty easy to write stuff like this in Haskell.
14:59:03 <ski> Ni ?
14:59:14 <Marvin--> Not Invented Here
14:59:49 <ski> Marvin-- : (ok, thought it might be Monty Python ..)
15:00:04 <Pseudonym> ski is the keeper of the sacred words: "Ni", "Peng" and "Neee-wom".
15:00:53 <stepcut> ah, I found the thread, it was on the clean  mailing list: 
15:00:54 <stepcut> 	do{yyyy<-r 4 d;c '-';mm<-r 2 d;c '-';dd<-r 2 d;return(yyyy,mm,dd); }
15:00:57 <Pseudonym>  Oh, what sad times are these when passing ruffians can say 'ni' at will to IRC users.
15:01:03 * ski commands thee to cut down the mightiest imperative language in business with   a   Monad !!
15:01:35 <Pseudonym> I shall do no such thing!
15:01:43 <Pseudonym> Cut down an imperative language with amonad? It can't be done.
15:02:33 <Pseudonym> Even those who arrange and design combinators are under considerable economic stress at this period in history.
15:02:42 <stepcut> darn, it seems that they were imagining a string parsing combinator library, not refering to a real one
15:02:56 <ski> nooo, you said the word that the keeper of the sacred words ("Ni","Peng","Neee-wom") can't stand to hear !
15:03:15 <Pseudonym> What, "combinator"?
15:03:23 <ski> the word "it"
15:03:26 <Marvin--> stepcut: but why not just use ReadP or Parsec or what have you?
15:03:30 <ski> noo, now i said it !
15:03:42 <ski> oops, i daid it again, aweeeh !
15:04:49 <stepcut> Marvin--: I am going to look into that now -- just wanted to make sure there was not something more appropriate
15:05:42 <stepcut> ReadP looks like its probably what I want
15:05:47 <Marvin--> ReadP is especially geared towards writing Read instances
15:06:32 <stepcut> yeah, and Parsec is geared towards parsing languages
15:11:27 <Marvin--> well, I'm off to bed
15:11:43 <Pseudonym> Night.
16:04:24 <themaximus> Back from skiing
16:04:48 <themaximus> Hey Lemmih
16:11:50 <ski> (i guess that wasn't an obscure reference to me :)
16:11:57 <ski> hello, btw
16:21:18 <themaximus> hey ski :)
16:21:19 <themaximus> lol
16:21:42 <ski> (my nick having nothing to do with snow)
16:21:46 <themaximus> lol
16:22:01 <themaximus> hm.
16:22:01 <ski> i saw you the other day, here, right ?
16:22:05 <themaximus> yeah
16:22:18 <themaximus> I am usually always here
16:22:37 <themaximus> brb (B-Room)
16:22:41 <ski> is your nick taken from King's Bounty or HoMM ?
16:27:03 <Pseudonym> I need a name for a concept.
16:27:19 <ski> which one ?
16:27:55 <Pseudonym> Well, it's an object which is associated with some system event.
16:28:02 <Pseudonym> Say, when the user hits control-C.
16:28:16 <Pseudonym> "Event" isn't the right word, though.
16:28:20 <ski> action ?
16:28:26 <Pseudonym> No, not action either.
16:28:35 <Pseudonym> "Event" and "action" are already in use.
16:28:38 <ski> some kind of info ?
16:28:58 <Pseudonym> An "event" is data from the GUI system, like a mouse click or key press.
16:29:05 <ski> yes
16:29:12 <Pseudonym> An "action" is a response to the GUI system, like repainting a window.
16:29:21 <ski> mm
16:29:30 <themaximus> back
16:29:33 <Pseudonym> I envisage this something like a monostable switch in electronics.
16:29:46 <ski> so is the object info *about* the system event ?
16:30:05 <ski> themaximus : i wondered about your nick, above ..
16:30:05 <Pseudonym> Uhm... no.  Bits of the program register with it if they want to be informed when the event happens.
16:30:14 <Pseudonym> The object then sends them all a signal.
16:30:19 <ski> aha
16:30:38 <ski> hmm, isn't there such things in smalltalk .. ?
16:30:55 <Pseudonym> It's kind of like a condition variable.
16:31:33 <ski> hmm
16:31:58 <ski> EventSignalProvider ????
16:32:07 <themaximus> ski: what?
16:32:07 <Pseudonym> Bingo!
16:32:13 <ski> oh
16:32:16 <Pseudonym> (That's buzzword bingo.)
16:32:22 <themaximus> brb
16:32:25 <Pseudonym> You should turn that into a design pattern. :-)
16:32:37 <ski> (signal could perhaps be renamed to something better)
16:32:42 <Pseudonym> Perhaps.
16:33:03 <ski> i thought i'd seen something like that in some smalltalk (squeak perhaps ?)
16:33:12 <Pseudonym> OK, I'll look at squeak.
16:33:22 <ski> i still don't remember what they called it there ..
16:33:24 <Pseudonym> I figure this is something that turns up often enough that it has a name.
16:33:25 <ski> though
16:34:34 <ski> Pseudonym : i guess you might ask on comp.object too, if you can wait for answers ..
16:34:58 <Pseudonym> #c++ might know, too, though I doubt it.
16:35:24 <ski> well, i definitely think i've seen it somewhere before, at least ..
16:35:34 <Pseudonym> Yeah, it rings a bell for me, too.
16:36:16 <ski> something about registering interest to be informed of some event
16:36:22 <ski> e.g. window resize
16:36:36 <Pseudonym> Oh, that's...
16:36:37 <mattam_> Pseudonym: would you mind repeating the description of your concept for me ?
16:36:42 <Pseudonym> OK, hang on.
16:37:29 <ski> or some input widget's control changed to new value, so we need to recompute the output (e.g. a bar graph)
16:37:29 <Pseudonym> OK, what I want is an abstraction where bits of the system can register interest in a certain system event happening.
16:37:40 <Pseudonym> ski: That's "observer".
16:37:47 <mattam> spectators or observers
16:37:59 <Pseudonym> But this is different.  "Observer" has some model which is being observer.
16:38:04 <Pseudonym> observed
16:38:15 <Pseudonym> This is just events.
16:38:26 <ski> hmm, ok. perhaps these shouldn't be confused, then
16:38:27 <Pseudonym> When the external event happens, we notify anyone who cares.  End of story.
16:39:11 <Pseudonym> I suppose it's a kind of multiplexer, except we don't analyse the system event to do our dispatching.
16:39:30 <Pseudonym> Er... demultiplexer.
16:39:50 <ski> (i just thought that one might perhaps register interest in change on some buttons or draw-sliders or whatever, and when they change, they inform us, so we can update whatever we want to update)
16:40:19 <mattam> sounds like registering a hook too
16:40:23 <Pseudonym> ski: Yes, that's "observer" or "spectator" (as mattam said).
16:40:35 <Pseudonym> There is a crucial difference here, though.
16:40:43 <Pseudonym> A draw-slider has an underlying value which is always available.
16:40:56 <Pseudonym> This thing which I'm trying to name does not.
16:40:59 <mattam> you're not watching a state but an event, basically
16:41:03 <Pseudonym> Right.
16:41:05 <ski> but an event is a one-shot thing ?
16:41:08 <Pseudonym> Yes.
16:41:11 <Pseudonym> Oh, one-shot.
16:41:13 <Pseudonym> That's a good name.
16:41:27 <mattam> callback ?
16:41:49 <Pseudonym> A call back is a more general concept.
16:41:50 <ski> but one could build events from a state :  StateChanged event
16:42:00 <Pseudonym> Sure you could.
16:42:20 <Pseudonym> The thing is, this concept must be in common use, so it must have a jargon name.
16:42:28 <mattam> when you register for a signal event in unix world, you say it's a callback, nothing less.
16:42:30 <ski> but i agree that we additionally can monitor a state whenever we want, instead of just waiting for changes ..
16:43:19 <Pseudonym> Yeah, a Unix signal is probably the closest thing to what I'm thinking of.
16:43:34 <Pseudonym> Aha!
16:43:37 <Pseudonym> @foldoc trigger
16:43:39 <lambdabot> *** "trigger" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
16:43:39 <lambdabot> trigger
16:43:39 <lambdabot>      
16:43:39 <lambdabot>         <database> An action causing the automatic invocation of a
16:43:40 <lambdabot>         procedure, for instance to preserve {referential integrity}.
16:43:42 <lambdabot>         A triggers goes into effect when a user attempts to modify
16:43:44 <lambdabot>         data with an insert, delete, or update command.  A trigger can
16:43:46 <lambdabot>         instruct the system to take any number of actions when a
16:43:48 <lambdabot> [9 @more lines]
16:43:50 <Pseudonym> @more
16:43:50 <lambdabot>         specified change is attempted.  By preventing incorrect,
16:43:52 <lambdabot>         unauthorized, or inconsistent changes to data, triggers help
16:43:54 <lambdabot>         maintain the integrity of the database.
16:43:56 <lambdabot>      
16:43:58 <lambdabot>         [Sybase SQL Server Release 10.0 Transact-SQL User's Guide].
16:44:00 <lambdabot>      
16:44:02 <lambdabot>         (1995-02-22)
16:44:04 <lambdabot>      
16:44:06 <Pseudonym> "Trigger" it is.
16:44:06 <lambdabot>      
16:44:23 <Pseudonym> That's a term in common use among database people.
16:44:27 <ski> hmm, perhaps
16:44:48 <Pseudonym> That's the term I like best so far.
16:44:55 <Pseudonym> Though I do like "one-shot".
16:45:47 <ski> hmm  MVR = Model-View-Controller   perhaps ?
16:45:59 <Pseudonym> Unfortunately, the term "interrupt" implies that existing code is interrupted somehow.
16:46:34 <mattam> it really are callbacks returning a boolean value (continue/rollback).
16:46:38 <ski> Q36 and Q48 at http://www.faqs.org/faqs/smalltalk-faq/
16:46:46 <mattam> s/it/triggers/
16:47:18 <Pseudonym> Hmmm.
16:47:26 <ski> (it could at least've been MVR i was thinking about)
16:47:29 <Pseudonym> "Trigger" seems too generic now that I read this.
16:47:33 <Pseudonym> I think I might use "one-shot".
16:47:46 <ski> discreet ?
16:48:05 <mattam> you dislike event monitor too ?
16:48:36 <Pseudonym> mattam: The problem is that I'm already using the term "event" as a GUI-specific term.
16:48:56 <ski> one-shot perhaps implies that the "callback" is only going to be called once (then automatically unregistered). what do you think ?
16:49:43 <Pseudonym> Well I don't think so, but then, I used to be really into electronics.
16:50:06 <Pseudonym> A "one-shot" switch does something specific which is fairly close to this.
16:50:36 <mattam> Unix signal callbacks are ont-shots iirc :)
16:50:42 <Pseudonym> http://www.allaboutcircuits.com/vol_4/chpt_10/8.html
16:50:57 * ski only know a little about chip level things like mux,demux,counter,alu,...
16:51:03 <Pseudonym> Sure.
16:51:16 <Pseudonym> Well, the analogy is that a one-shot circuit is like a pushbutton.
16:51:35 <Pseudonym> You push it, the contacts close for a moment, then it resets itself after a set time.
16:52:00 <Pseudonym> As opposed to a switch, which has two stable states, a pushbutton has one stable state.
16:52:46 <ski> JK-switch and so on ?
16:52:59 <Pseudonym> J/K flip flops have two stable states.
16:53:19 <Pseudonym> All latches do.
16:53:27 <ski> wasn't it JK which was edge triggered ?
16:53:40 <Pseudonym> Oh, you mean the inputs.
16:53:43 <Pseudonym> Yes, I suppose so.
16:54:20 <Pseudonym> Anyway, I think I might use "one-shot".  Thanks.
16:54:28 <Pseudonym> I will search around a bit more, though.
16:54:32 <ski> i.e. a specific discreet event does something
16:55:08 <ski> Pseudonym : what did you think about MVR ?
16:55:28 <Pseudonym> Did you mean MVC?
16:55:34 <ski> oh, right
16:55:41 <ski> :)
16:55:48 <Pseudonym> The thing about MVC is that there needs to be an "M".
16:55:57 <Pseudonym> WHich there isn't here.
16:56:20 <Pseudonym> A switch has a model.  It's like a flag.  It's either on or off at any given time.
16:56:29 <Pseudonym> A pushbutton doesn't.
16:56:35 <ski> ok. i'm not really so much into this so wasn't sure if it was appropriate
16:56:50 <ski> mm
16:56:55 <Pseudonym> That's cool.  It's actually helping to clarify my thoughts.
16:57:02 <Pseudonym> Oh, by "model" I mean "state".
16:57:12 <ski> sortof guessed so
16:57:23 <Pseudonym> That's kind of what "model" means in MVC.
16:57:45 <monotonom> You can have a state variable of type ().
16:57:53 <Pseudonym> True.
16:58:13 <ski> so the state generating events is included in MVC but excluded in your idea (though it might be present somewhere else)
16:58:47 <Pseudonym> In fact, I'm implementing it using a general message-passing system.
16:59:20 <ski> monotonom : so in MVC one can notify interested parties even if the state (the one in the model) didn't change ?
16:59:35 <Pseudonym> The thing is, "observer" uses a specific kind of message-passing/callback/whatever thing.
16:59:43 <Pseudonym> It has a name which is more specific than "callback".
16:59:49 <Pseudonym> I figured this concept would too.
17:00:01 <ski> "Q48. How do an object register interest in a ValueModel?  Ans. By sending onChangeSend: aChangeMessage to: anInterestedObject to a ValueModel. ..."
17:00:35 <ski> (this seems to imply notification only occurs on state change (but perhaps not at every change))
17:00:41 <Pseudonym> Right.
17:00:45 <monotonom> Every time you assign () to the state variable, even though the value doesn't really change, you can still notify all interested parties.
17:00:52 <ski> i guess
17:00:56 <Pseudonym> monotonom: Yes.
17:01:17 <monotonom> Furthermore in the one-shot application, there is a state change, though it happens just once in a lifetime.
17:01:19 <Pseudonym> monotonom: That's a good way to implement it, but it still, IMO, needs its own name.
17:02:00 <Pseudonym> ski: Part of the more advanced MVC model is that views can register interest in only part of a model.
17:02:05 <ski> but, perhaps one could take the view that : compare the new valuew with the old, and if same, do not notify about stateChange  (think e.g. about spread-sheet and adaptible/incremental computing/algorithms)
17:02:13 <Pseudonym> For example, a bar chart view of a spreadsheet may not care if the user changes a font.
17:02:19 <Pseudonym> But it may care if the user changes a number.
17:03:06 <monotonom> A salmon mates just once in its life, and it dies then. Still, it has a state variable with two values: "I am virgin" and "I am no longer virgin".
17:03:38 <ski> Pseudonym : yes, so a change doesn't have to imply a notification to a specific party. but if a party gets notified, one might insist on there having been some (effective) state change
17:03:48 <Pseudonym> Right.
17:03:59 <Lunar^> Ok... now I can work on hOp
17:04:12 <Pseudonym> Anyway, BBIAB.  Need to join a conference call.
17:04:14 <ski> (i.e. update to same value might not qualify as change)
17:04:14 <Pseudonym> Thanks everyone.
17:04:15 <Lunar^> but we'll see that tomorrow
17:04:24 <ski> Pseudonym : bye
17:06:44 <ski> monotonom : (i think Pseudonym was thinking about registering interest in whenever some event occurs, and not just the first time (which might be inferred from the use of the word 'one-shot'), though i'm not completely sure. if that is the case, perhaps discreet is a better word)
17:08:56 <ski> themaximus : away ?
17:09:31 <themaximus> oh, no
17:09:37 <themaximus> sorry, what was it again?
17:09:38 <themaximus> :)
17:09:45 <monotonom> I now think it is all bloat. So there is some event source S, and there is some guy G, and there are observers O, and whenever S churns out an event, then it tells G, and then G tells O?  Why not eliminate G altogether and register O directly with S and have S notify O without any middleman?
17:10:44 <ski> themaximus : i just wondered previously if your nick perchance came from the HoMM games ?
17:11:14 <themaximus> oh, no
17:11:28 <themaximus> My name is Max so I just expanded it
17:11:50 <monotonom> Now suppose you really want the middleman G for reasons of factoring, decoupling, or separation of concerns.  Then G is called a proxy or facade or decorator or something like that, a middleman, not a model or subject (in the observer pattern); S is the subject.
17:11:54 <ski> monotonom : what if S is not anything process-like that can act on it's own ?
17:12:53 <ski> monotonom : or at least, is not designed to keep track of all the different interested parties and what types of change/info they are interested about ?
17:13:52 <ski> monotonom : i sortof thought that MVC was a name for the whole relationship, not just a name for G
17:14:03 <ski> themaximus : ok
17:16:24 <ski> themaximus : (we once had a hamster named maximum :)
17:16:45 <themaximus> :)
17:17:01 <ski> (and one called minimum, of course)
17:18:44 <ski> (i suppose you've seen the dance, too)
17:23:29 <stepcut> I don't think I understand how to use ReadP 
17:26:01 <ski> no ?
17:26:47 <ski> most seems self-evident, you don't think so ?
17:27:43 <ski> what part of ReadP do you not understand ?
17:28:12 <stepcut> it seems like my parser will almost always be of type ReadP String
17:28:45 <stepcut> but aren't I supposed to be able to use it to write parser for instances of Read?
17:28:47 <ski> but ReadP is an instance of Functor and Monad (and MonadPlus)
17:29:14 <ski> i would guess so
17:29:47 * ski haven't actually used ReadP. just looking at the GHC docs
17:30:01 <monotonom> do { return 0 } :: ReadP Int. There, a parser of type other than ReadP String :)
17:30:14 <stepcut> lets say I have a data type: data MyType = MyType String String String
17:30:34 <ski> do {mapM_ char "abc"; return 42}  e.g.
17:30:37 <ski> ok
17:30:56 <stepcut> and I want to make an instance of Read so that I can do: read "val1--val2--val3" ---> (MyType "val1" "val2" "val3")
17:31:10 <ski> (s/mapM_ char/string/ which i just saw)
17:31:37 <stepcut> hrm
17:31:49 <ski> so val1 can contain single - ?
17:31:56 <ski> (and val2)
17:31:59 <stepcut> hold on
17:32:46 <stepcut> ah
17:32:49 <stepcut> I understand now
17:32:51 <themaximus> Good Night All!
17:32:57 <stepcut> thanks
17:33:05 <ski> themaximus : good night, nice dreams !
17:33:25 <themaximus> thanks
17:34:00 <ski> stepcut : could val1 and val2 contain single '-'s ?
17:34:29 <stepcut> yes
17:34:43 <ski> like "a-b-c--d-e--f" ---> MyType "a-b-c" "d-e" "f"
17:34:44 <ski> ok
17:34:51 <stepcut> yes
17:35:11 <monotonom> That should pose no difficulty.
17:35:18 <ski> no, not really
17:35:57 <stepcut> my difficulty was not realizing that I need to use do notation 
17:36:16 * ski was just thinking about something like  many (satisfy (/= '-'))   but that wouldn't work here..
17:36:28 <ski> (also i don't see many in this lib)
17:36:34 <monotonom> Heh!
17:37:12 <stepcut> maybe something with:  string "--"
17:37:53 <stepcut> hrm, maybe not
17:37:56 <ski> perhaps one could do something with look
17:38:25 <stepcut> yeah
17:38:44 <ski> failing if it begins with "--"
17:39:44 <stepcut>  i wonder what 'symmetric choice' means
17:40:20 <ski> perhaps it's the non-cutting version of 'or'
17:41:13 <stepcut> ah
17:41:17 <ski> pfail +++ p = p  and  pfail <++ p = p  of course
17:42:04 <stepcut> readP_to_S ((string "apple") +++  (string "apple1")) "apple123"
17:42:05 <stepcut> [("apple","123"),("apple1","23")]
17:42:10 <monotonom> Right. Symmetric choice spends more memory and may backtrack, so it is slower, but it is great for being too lazy to code up lookaheads.  +++ does not backtrack, so it is faster, but it also fails more easily.
17:42:15 <ski> but probably nonFailing <++ p = nonFailing  while  nonFailing +++ p /= nonFailing  (if p is nonFailing)
17:42:54 <ski> monotonom : s/+++/<++/ ?
17:43:39 <ski> (s/if p is nonFailing/if p is something that doesn't fail/)
17:45:18 <ski> (hmm, seem like  munch = many . satisfy  or something like that)
17:46:25 <monotonom> Yeah probably it is now called <++
17:46:46 <monotonom> I haven't read the ReadP doc either :)  I have only seen Parsec.
17:47:56 <ski> monotonom : in ParseLib we had mplus and +++. i think that corresponds to +++ and <++ in ReadP
17:48:17 <ski> mm
17:50:12 <monotonom> If ReadP is a MonadPlus then ++ must mean symmetric choice in order to preserve all the monadic laws.
17:50:40 <ski> ??
17:50:54 <ski> ++ is just for lists, nowadays, right ?
17:51:13 <ski> and the one in MonadPlus is mplus, no ?
17:51:20 <monotonom> Oops you are right.  Correction.  If ReadP is a MonadPlus then mplus must mean symmetric choice.
17:51:50 <ski> (as was the case in ParseLib. dunno about Parsec)
17:52:34 <monotonom> Parsec follows that seminal paper closely, and the paper uses +++ for cutting choice.  Bad notation, but it's historic.
17:52:59 <ski> ok, yes
17:53:55 <ski> thinking about it, has any Prolog had a cutting choice operator ?
18:05:44 <monotonom> I don't think so. The prolog people are obsessed with cuts.
18:06:07 <monotonom> I mean obsessed with the cut operator on its own.
18:06:23 <ski> *yuck*  tell me about it
18:07:35 <ski> (it's *evil* !  doesn't obey resolution  (somewhat alike return in C e.g.))
18:08:22 <monotonom> As Hoare puts it, "!" should be meaningless unless you use it in context like making a cutting choice, and only then you give semantics to cutting choice, not cut.  This is like you bloody never give meaning to "else"; you give meaning to the whole construct "if ... then ... else..."
18:09:07 <ski> yes
18:10:08 <ski> the problem (well one of them) is that you can't abstract out some lines of code into a new predicate (keeping track of what variables must be passed), and expect it to work.. :(
18:11:29 <ski> (just like the /cc replacement for call/cc on comp.lang.scheme recently)
18:11:55 <Riastradh> ...non-replacement...
18:14:43 <ski> Riastradh : yes !  :)
18:28:27 <ski> hello Swynndla and flippo
18:30:35 <Swynndla> hi ski :)
18:31:20 <flippo> howdy, ski
18:31:41 <ski> what country is nz ?
18:32:32 <Swynndla> well, I was learning ocaml, and someone suggested Haskell too, so I started reading "a gentle intro to haskell" and just about gave up learning haskell, as that tutorial isn't gentle, but then I found "yet another haskell tutorial" and it's great
18:32:37 <Swynndla> nz is New Zealand
18:32:50 <ski> ok
18:33:04 <ski> was that the one by hal daume iii ?
18:33:25 <flippo> I loved that ungentle introduction
18:33:26 <Swynndla> yea :)
18:33:32 <Swynndla> haha
18:33:38 <ski> :)
18:33:45 <flippo> Not this one? http://www.haskell.org/tutorial/
18:33:55 <flippo> hudak, et al?
18:34:29 <ski> flippo : isn't that the "gentle" one ?
18:34:37 <flippo> oh, yes it is
18:34:58 <flippo> That intro was the first to convince me that haskell was different in a useful way
18:36:29 <Swynndla> the "yet another haskell tut" said that the gentle one presumes prior knowledge on functional languages
18:36:42 <ski> mm
18:37:36 <flippo> that's probably a good assumption for many who are interested
18:37:49 <ski> (i learned from Thompson's book, so i suppose i don't qualify for judging how good the 'gentle' one is :)
18:38:21 <Swynndla> I was only learning Ocaml for a couple of weeks etc
18:38:30 <ski> ok
18:38:57 <Swynndla> well, 4 or 5 weeks actually :P
18:39:01 <flippo> Is a monad the same as a monoid?
18:39:31 <ski> it's a bit related i think, but not the same
18:39:45 <flippo> oh well, no shortcuts for me then
18:39:50 <ski> :)
18:39:59 <ski> learning about monads now, eh ?
18:40:08 <flippo> No, just about monoids :)
18:40:18 <ski> ok
18:40:51 <flippo> I'm ploughing through this "Conceptual Mathematics" book, looking for relevance
18:40:51 <ski> why ? math ? for use in programming ?
18:40:56 <ski> ah
18:40:58 <ski> ok
18:41:34 <ski> so are you on the StudyGroup ?
18:41:36 <flippo> I looked at category theory many years ago, before I knew what to do with it.
18:41:47 <flippo> ski: no, but I heard the recommendation here
18:42:07 <ski> borrowed the book at a library ?
18:42:12 <flippo> It's fun.  Helps me remember group theory, functional analysis, etc
18:42:19 <flippo> ski: got it really cheap online
18:42:34 * ski envies flippo
18:42:46 <flippo> twenty three dollars I think
18:43:02 <flippo> seemed cheap at the time anyway
18:43:41 * monotonom envies flippo
18:43:45 <flippo> dollar continues to crash too
18:44:00 <monotonom> American Peso :)
18:44:21 <flippo> Amazon referred me to a cheap dealer
18:47:36 <ski> flippo : "looking for relevance" for programming ?
18:48:09 <flippo> yes, I failed long ago to use it for physics, which was my original reason for looking
18:49:11 <ski> (seem to recall someone John Baez that used it (?) for physics)
18:55:26 <ski> hi pwk
18:58:09 <Odiseo> that's right baby
19:00:26 <flippo> This was my first category theory book: http://www.amazon.com/exec/obidos/tg/detail/-/0226288625/002-4854785-8632049?v=glance
19:00:52 <flippo> Mathematical Physics by Robert Geroch 
19:01:22 <Odiseo> how can you work hard and study hard?I need motivation
19:01:53 <flippo> Beer
19:02:10 <flippo> Okay, maybe that won't really help.
19:02:19 <Odiseo> beer disperse the concentration
19:06:30 <Swynndla> so it Ocaml or Haskell easier to learn? ... and which is easier to program?
19:06:40 <Swynndla> s/so it/so is/
19:07:15 <ski> well, because you ask here, what do you think the answers gonna be ?  :)
19:07:31 <Swynndla> ski, I was thinking of asking in ocaml too :)
19:07:53 <Swynndla> but quite a few program in both ...
19:08:04 <Swynndla> so I was hoping for some honest insight
19:08:09 <ski> do you mean comparing learning of the roughly equivalent features of both ?
19:08:40 <Swynndla> ski - are you saying their strengths lie is different areas?
19:09:10 <Swynndla> s/is/in/
19:09:39 <ski> if you are used to unpure, then O'Caml allows that (non-steeper learning curve, perhaps), while in Haskell one probably has to deal with it more direcly (steeper ...)
19:09:54 <Swynndla> oic
19:10:04 <ski> well, perhaps
19:10:28 <ski> O'Caml has an OO system built-in
19:10:30 <Swynndla> well, I've learned to program ocaml with no for loops etc
19:10:37 <Swynndla> oic
19:10:41 <ski> ok
19:10:52 <ski> but i/o effects ?
19:10:56 <Swynndla> I've learned how to do tail recursion
19:11:00 <ski> ok, good
19:11:13 <Swynndla> I'm not sure what you mean by i/o effects
19:11:38 <Swynndla> and when I say I've learned tail recursion etc, I only mean at a basic level
19:11:57 <Swynndla> ocaml was and still is a very steep learning curve for me
19:12:06 <ski> read input from files or standard input, write output to files or standard output, do mouse,keyboard,graphics,gui,sockets,etc ...
19:12:59 <Swynndla> ski I haven't done that with ocaml except drawing some coordinates etc to produce a picture
19:13:08 <ski> ok
19:13:34 <ski> (that would probably(/perhaps ?) require using monads in haskell)
19:14:16 <Swynndla> ski - oh so it's more difficult to deal with i/o effects in haskell?
19:14:26 <ski> (though would probably not require some deep understanding of what monads are good for, though)
19:14:30 <ski> well
19:14:39 <ski> it's a little different, at least
19:15:08 <ski> you can't have a function that reads an int and returns it (in the normal way)
19:16:00 <ski> (though, i think it's not so hard to see how some examples do it, and imitate that)
19:16:50 <Swynndla> well, in ocaml I just do this to draw a circle: fill_circle 320 240 radius
19:16:58 <ski> yes
19:17:03 <Swynndla> how could I do that in haskell?
19:17:08 <ski> in haskell you'd do the same
19:17:12 <Swynndla> oic
19:17:15 <ski> but in a different context !
19:17:21 <Swynndla> oh
19:17:42 <Swynndla> it's just that I was impressed by how easy it was to do in ocaml
19:17:42 <ski> in ocaml  fill_circle : int -> int -> int -> unit   probably
19:18:01 <Swynndla> I want to write a checkers program in ocaml ... to play checkers
19:18:11 <Swynndla> yes
19:18:21 <ski> in haskell   fillCircle :: Int -> Int -> Int -> IO ()    (where () is the same as unit in ocaml)
19:18:34 <Swynndla> oic
19:18:45 <Swynndla> that seems very similar then
19:19:05 <ski> this means (roughly) that you can only call this from a monadic context
19:19:21 <ski> (i.e. a function which itself returns  IO Something)
19:19:36 <Swynndla> I'm not up to monads yet 
19:19:56 <Swynndla> ok
19:20:23 <ski> so all functions that (might) do i/o gets 'tagged' (well their return type gets tagged) to acknowledge that it can have i/o effects
19:20:43 <ski> and a pure function can't call such a function  (type error !)
19:20:50 <ski> ok
19:20:59 <Swynndla> oh
19:21:08 <Swynndla> so how do you call it?
19:21:16 <ski> the informal thinking is mostly similar, yes
19:21:49 <ski> it's kinda like we have a thin unpure/imperative shell at the outside of the pure haskell core
19:22:19 <Swynndla> ok
19:22:35 <ski> one usually calls it from a syntactic-sugar called do-notation  (that resembles a sequence of imperative statements)
19:23:23 <ski> example :
19:23:37 <ski> main = do putStrLn "What is your name ?"
19:23:46 <ski>           name <- getLine
19:24:04 <ski>           putStrLn ("Hi " ++ name ++ " !")
19:24:16 <ski> ok ?
19:24:24 <Swynndla> ok
19:25:03 <ski> so  main :: IO ()
19:25:11 <ski> and putStrLn :: String -> IO ()
19:25:19 <ski> and getLine :: IO String
19:27:13 <Swynndla> i'm taking notes, bt I need to read more of that tutorial I think :)
19:27:23 <ski> mhmm
19:28:53 <Swynndla> in ocaml I can draw a circle using 6 lines ....
19:28:59 <Swynndla> open Graphics;;
19:28:59 <Swynndla> open_graph " 640x480";;
19:28:59 <Swynndla> let radius = 40;;
19:28:59 <Swynndla> set_color red;;
19:28:59 <Swynndla> fill_circle 320 240 radius;;
19:29:00 <Swynndla> read_line ();;
19:29:06 <Swynndla> how can I do this in haskell?
19:29:25 <ski> well, i'm not sure what's the status of graphics libraries
19:29:54 <ski> (haven't played much with that kind of thing. just pondered above how it might look like)
19:30:12 <ski> hmm
19:30:30 <ski> can open_graph handle multiple drawing areas ?
19:30:52 <ski> if so, how does set_color,fill_circle know which one to use ?
19:31:08 <ski> the latest one opened ?
19:31:11 <Swynndla> I don't know ... I just copied it from an example
19:31:14 <ski> ok
19:31:29 <Swynndla> I have to compile it using: ocamlc graphics.cma circle.ml -o circle
19:31:51 <Swynndla> if my script is called circle.ml that is
19:32:11 <ski> well, *assuming* we have similar functions in haskell, we'd write essentially the same sequence of commands into a do-block, i think
19:32:24 <Swynndla> ok
19:33:16 <Swynndla> do you call them modules?
19:33:21 <ski> yes
19:33:35 <ski> (i.e. we call the modules, modules :)
19:33:43 <Swynndla> :)
19:33:56 <keverets> Swynndla: http://anfaenger.de/cygwin/haskell/hugs/soe/graphics-2.0.4/demos/HelloWorld.hs
19:34:03 <ski> (do-blocks is a kind of expression, if that's what you were referring to)
19:34:12 <tty4> excuse me. has anyone done any work with Haskell and partial evaluators ?
19:35:13 <Swynndla> oic keverets, and I guess there are commands to draw circles too?
19:35:34 <keverets> Swynndla: yes
19:36:31 <Pseudonym> Back.
19:36:54 <Swynndla> ski how do I found out how modules are standard ... and which ones I have to import, and how do I find out which modules are available to import?
19:36:57 <ski> tty4 : (google finds http://www.math.chalmers.se/~rjmh/PECourse/Exercises/PE.html and http://citeseer.nj.nec.com/rose98typedirected.html and http://www.haskell.org/pipermail/template-haskell/2003-December/000235.html and http://portal.acm.org/citation.cfm?id=115890&dl=ACM&coll=GUIDE e.g.)
19:36:59 <Pseudonym> To answer some questions that arose while I was away, a one-shot/monostable circuit is actually triggered.
19:37:12 <Pseudonym> A real-world example is a computer's reset button.
19:37:29 <Pseudonym> The button may be hit several times while the power is on.
19:37:31 <ski> Swynndla : by looking at the haskell98 report, perhaps ?
19:37:44 <Swynndla> ski, ahhhh ok
19:37:57 <ski> (for the standard ones, i.e.)
19:38:08 <Swynndla> yup
19:38:09 <tty4> ski: thanks. my google came up with scheme PE and a search on Haskell wiki turned up nothing.
19:38:12 <Pseudonym> And the reason for wanting a middleman is not just bloat. :-)
19:38:32 <Pseudonym> Abstracting simple stuff, if the simple stuff is machine-dependent, is good for testing.
19:38:59 <Pseudonym> For example, I can run unit tests which simulate the user hitting control-C without them actually doing so.
19:39:03 <ski> Pseudonym : is your kind a 'retriggerable' one, using that circuit terminology ?
19:39:07 <Pseudonym> Yes.
19:39:41 <ski> tty4 : (though, i would perhaps like to see something like MetaHaskell :)
19:39:44 <ski> ok
19:40:09 <ski> Pseudonym : yes
19:40:38 <Swynndla> ski, thanks for being patient with me, I'll go and do some reading now ;)
19:40:52 <ski> ok, bye Swynndla
19:51:34 <ski> hello DeezNuts
19:52:26 <tty4> ski: could you please elaborate on MetaHaskell.
19:52:43 <ski> oh, i just meant something alike MetaML or MetaOCaml
19:53:01 <ski> i.e. staged (meta-)programming
19:53:16 <tty4> hmmm...i'm not familiar with MetaML.
19:53:51 <tty4> how does it relate to lambda calculi or even category theory ?
19:54:08 <ski> hmm
19:54:34 <ski> do you know quasi-quote and unquote in Lisp ?
19:54:52 <tty4> not very well.
19:55:18 <DeezNuts> hi ski
19:55:18 <tty4> most of my functional prog. knowledge is self taught. much gaps...
19:55:24 <ski> MetaML is sortof a typed version of that
19:55:56 <ski> tty4 : (most of my FPL knowledge is also self taught)
19:56:32 <ski> DeezNuts : have any haskell questions ?  looking for info ?
19:56:33 <tty4> aren't you at chalmers though ? don't they do FPL there ?
19:56:43 <ski> yes, right
19:57:14 <ski> but the only FPL i have learned by course is haskell
19:57:48 <tty4> and the only one by course is scheme. and we did not even cover half of EOPL.
19:58:03 <ski> oh ?
19:58:16 <ski> have you tried to read some of it yourself ?
19:58:45 <tty4> read it twice. mostly interested in CPS and how to convert it to iterative/procedural.
19:58:54 <ski> ok
19:59:01 <ski> well CPS is interesting
19:59:13 <DeezNuts> ski: not atm
19:59:23 <tty4> yes, there was a time when knowing CPS would have saved me lots of grief.
19:59:27 <ski> (and call/cc and nqCPS and shift/reset, and monadic refection, and so on ... :)
19:59:44 <tty4> :) you are way ahead of me...
19:59:53 <ski> what were you doing then ?
20:00:23 <Riastradh> Refection?
20:00:24 <ski> DeezNuts : ok, when(if ?) you got some, you can ask them here :)
20:00:29 <ski> sorry
20:00:35 <ski> Reflection, of course
20:00:44 <tty4> in the industry, mostly Java although i might get lucky and start something in Erlang in the near future.
20:00:49 * Riastradh has gone and forgotten what monadic reflection and reification is again.
20:01:04 <ski> (refectory being something quite else ;)
20:01:31 <Pseudonym> Monadic reflection is whan you take a monad and reverse its coordinate system.
20:01:43 <Riastradh> Great.  I totally comprehend now!
20:02:02 <tty4> like an anti-monad :)
20:02:10 <ski> Riastradh : take any monad and 'implicitify' it like state and continuations already are in Scheme and SML/NJ   (implemented by using composable continuations)
20:02:40 <Pseudonym> Reification is when you generate a quasi-Schoenfinkel pullback functor and apply it to its terminal co-equalizer.
20:02:43 <Pseudonym> Hope this helpe!
20:03:01 <ski> Pseudonym : I didn't know that explanation previously. thanks for sharing it !
20:03:07 <tty4> *ouch* way beyond my league :)
20:03:16 <Pseudonym> Way beyond my league, too.
20:03:28 <Riastradh> Pseudonym, I think you might have even out-arcanitized esap there.
20:03:36 <Pseudonym> Woohoo!
20:03:41 <Pseudonym> I out-BS'd him, too.
20:03:54 <Pseudonym> Win-win situation, I think.
20:04:07 <tty4> oh, Wadler showed that monads are a superset of CPS (or more powerful at any rate).
20:04:12 <Riastradh> ski, what's reification, then?
20:04:23 <ski> the inverse of reflection
20:04:27 <tty4> with CPS there is a CPS -> iteration conversion. is there something similiar with monads ?
20:04:28 <Pseudonym> @wn reification
20:04:29 <Riastradh> Well, duh.
20:04:29 <lambdabot> *** "reification" wn "WordNet (r) 2.0"
20:04:29 <lambdabot> reification
20:04:29 <lambdabot>      n 1: regarding something abstract as a material thing [syn: {hypostatization},
20:04:29 <lambdabot>            {hypostatisation}]
20:04:30 <lambdabot>      2: representing a human being as a physical thing deprived of
20:04:31 <ski> "thingification"
20:04:32 <lambdabot>         personal qualities or individuality; "according to Marx,
20:04:34 <lambdabot>         treating labor as a commodity exemplified the reification
20:04:36 <lambdabot>         of the individual" [syn: {depersonalization}, {depersonalisation}]
20:04:53 <Pseudonym> I think I like "hypostatization" better.
20:04:56 <Pseudonym> Much more obscure.
20:05:52 <ski> tty4 : what do you mean by "-> interation conversion" ?
20:06:47 <ski> tt4 : the sequentialization of CPS transformation ?
20:06:52 <tty4> ski: convert a CPS function to a while loop for example.
20:07:12 <tty4> ski: or use trampolining.
20:07:26 <ski> you're sure you aren't thinking of implementing tail-recursion ?
20:07:29 <tty4> ski: which i believe is about the same thing...come to think of it.
20:07:30 <Riastradh> Trampolining is a technique for implementing TCO.
20:07:45 <Riastradh> CPS is not TCO; if you create a new continuation, you're making a _non_-tail call.
20:07:54 <Riastradh> (Well, OK, that was somewhat misleading.)
20:08:03 <Riastradh> (CPS and TCO don't really have much to do with each other.)
20:08:10 <Riastradh> (So I'm kind of just spouting trout here.)
20:08:10 <tty4> i thought all CPS are tail calls ?
20:08:20 <ski> oh, that
20:08:22 <Riastradh> tty4, no.
20:08:49 <Riastradh> A CPS call with a continuation that is a LAMBDA expression is _not_ a tail call; if it is a constant, it _is_ a tail call.
20:09:09 <tty4> ah...thanks.
20:09:19 <ski> depends on how you define 'tail call', no ?
20:09:25 <Riastradh> So [[f (\x -> ...) a1 a2]] is a non-tail call; [[g k b1 b2]] is a tail call, however.
20:09:43 <ski> 'source code tail call' or 'target code tail call' ?
20:09:44 <Riastradh> ski, in the context of CPS, I just defined 'tail call.'
20:09:45 <SamB> Riastradh: isn't it a tail call as far as the compiler is concerned... not that Haskell compilers have to care or anything.
20:10:14 <Riastradh> SamB, in CPS, it is not a tail call.
20:10:37 <tty4> ok. my question then is: if I have a CPS how do transform the code so that i can implement it using a 'while' loop.
20:10:47 <Riastradh> A compiler might stupidly heap-allocate a closure for the continuation and perform a tail call for it, but that's even _worse_ than allocating a new stack frame for a non-tail call.
20:10:55 <tty4> sometimes i prototype something in schema but need to implement it in Java.
20:11:03 <SamB> Riastradh: yes, but does CPS not involve a lot of *apparant* tail calls in the code that is passing the continuations?
20:11:07 <ski> Riastradh : can't you always put those lambdas in lets, and call with a variable name instead ?  (thus tail call in your meaning above)
20:11:32 <Riastradh> ski, OK, my definition was somewhat misleading; I ought to have said: if you allocate a new continuation, it's a non-tail call.
20:11:34 <tty4> s/do/to/
20:11:58 <Riastradh> SamB, when you're talking about CPS, those regular rules about what is and isn'ta tail call don't apply.
20:12:20 <ski> 'it's a non-tail call' in the *source* code, methinks
20:13:32 <Riastradh> ski, it doesn't matter whether or not the compiler compiles it to a jump as it would compile a tail call in a direct program; you're still allocating a new continuation.
20:14:21 <ski> yes, just like allocating a new closure is allocating a new continuation
20:14:31 <Riastradh> A compiler will compile a direct non-tail call to allocate a new stack frame; a naive compiler will compile that same non-tail call in CPS to use no new _stack_ frames, but to use a new continuation nevertheless.
20:14:45 <ski> (though the compiler might, for efficieny reasons handle continuations specially)
20:14:51 <SamB> Riastradh: you are demonstrating some kind of inability to think on multiple levels, or at least on the same one I am thinking on
20:14:54 <Riastradh> s/naive//1
20:15:40 <Riastradh> SamB, does it matter whether the compiler allocates a new continuation frame in the stack or the heap?
20:16:11 <Riastradh> (this assumes that a naive compiler will compile the continuation of said CPS call into a heap-allocated closure)
20:16:57 <SamB> Riastradh: I think I am thinking of intermediate code. certainly not machine or asm...
20:17:18 <Riastradh> SamB, but the whole _point_ of TCO is that the _end_result_ does not allocate a new continuation frame.
20:17:19 <ski> Riastrach : a function closure is a kind of continuation (closure),  a -> b  =  not (a * not b)
20:17:49 <ski> tty4 : (so, do you try to code in CPS in Java, then ?)
20:18:21 <Riastradh> If you use CPS, your heap-allocated closure is a new continuation; if you use direct-style, your new stack frame is your new continuation.
20:18:52 <tty4> ski: not really. example. its easy to convert from a recursive function to one using a while loop.
20:19:12 <tty4> but starting from CPS i get stuck.
20:20:03 <ski> Riastradh : IMO if you use CPS, your heap-allocated closure is a function  (that represent a continuation in your mind). this is what saying that CPS is a style means, no ?
20:20:19 <Riastradh> ski, er, what?
20:20:33 <ski> tty4 : because it's quite cumbersome to use closures in Java
20:21:17 <tty4> ski: i know. Riastradh is where i'm looking at. i can either use the heap or a new stack frame to simulate CPS in Java.
20:21:20 <ski> Riastradh, if i code in CPS, i usually have a *function*, e.g. called k, that takes some input to a final answer/result type
20:21:21 <Riastradh> (Note that I've been talking about a naive compiler that will heap-allocate those closures.  A good compiler will produce the _same_machine_code_ for CPS & direct-style source code, because you're doing the same thing: allocating a new continuation frame.)
20:21:59 <tty4> i'm looking at using a heap. but the question remains how do i do the transformation.
20:22:22 <jemfinch|lambda> so SamB tells me that Haskell supports not only threads, but microthreads.  I'm interested in this, can someone point me to some more information?
20:22:35 <Riastradh> tty4, you're not going to get a while loop if you go from direct-style->CPS and do nothing else.
20:23:13 <ski> Riastradh, but in low-level machine code, a continuations is an address of some machine code (possibly coupled with some data, e.g. on a "stack frame")
20:23:17 <tty4> Riastradh: what would i get then ?
20:23:33 <tty4> ski: at machine code lvl you smash the heap.
20:23:34 <Riastradh> tty4, the same result; you'd end up doing nothing.
20:24:13 <tty4> ski: and put the continuing functions return code.
20:25:40 <ski> jemfinch|lambda : Concurrent Haskell ?
20:26:03 <Riastradh> In fact, even if you ended up transforming it to a while loop, you'd still be doing pretty much nothing; all you're doing is moving the accumulator around.
20:26:33 <tty4> Riastradh: unfortunately you lost me.
20:26:48 <tty4> Riastradh: can we use an example?
20:26:55 <Riastradh> tty4, with the regular recursive function, you're using the stack as your accumulator.
20:27:13 <Riastradh> With your CPS-transformed function, you're using the heap as your accumulator, or, with a smart compiler, it ends up being the stack again.
20:27:40 <Riastradh> With your while loop, you're using a local variable -- perhaps on the stack, perhaps in a register -- as your accumulator.
20:27:41 <tty4> Riastradh: ahh...true however in some cases the heap has way more memory then the stack.
20:28:10 <Riastradh> tty4, er, you're thinking about that in the wrong way.  You don't want to heap-allocate a closure for _every_ non-tail call.
20:28:31 <tty4> Riastradh: sure i do agree with your statement.
20:28:32 <ski> Riastradh : perhaps tty4 wondered how the tail-calls turn into effective jumps (at machine code level)
20:28:51 <tty4> ski: that to me would be trampolining.
20:30:39 <ski> jemfinch|lambda : perhaps http://citeseer.nj.nec.com/jones96concurrent.html then ?
20:31:29 <jemfinch|lambda> ski: thanks.
20:32:14 <SamB> maybe http://www.haskell.org/ghc/docs/6.0.1/html/base/Control.Concurrent.html would be interesting, too?
20:32:31 <ski> jemfinch|lambda : IIRC the threads were quite light-weight  (but perhaps not as much as in Erlang !?!)
20:32:42 <Riastradh> I'm going to bed now.  You can go on confusing yourselves about CPS and TCO after I leave.
20:33:27 <ski> SamB : ah, thanks, was looking for that in GHC docs ..
20:34:01 <ski> Riastradh : thanks. good dreams.
20:34:40 <tty4> Riastradh: thanks.
20:37:40 <tty4> ski: Recursive -> CPS -> while loop. my actual if-i-knew-cps-it-would-be-great-example.
20:38:10 <tty4> we had an xml tree which only the leaf were of interest. we did the usual depth-first travesal.
20:38:39 <tty4> which was recursive. however with CPS we could have avoided using the stack since really
20:39:08 <tty4> there was no need for it. each leaf did not interact with another.
20:39:09 <ski> tty4 : perhaps  Tail-recursive  --> CPS-code -> machine-code <- while-loop  is more correct ..
20:39:18 <tty4> ski: yes!!
20:39:44 <tty4> now the crux is how do i go about it?
20:39:58 <ski> go about what ?
20:40:40 <ski> and what do you mean by leafs not interaction, and that implying stack is unnecessary ?
20:42:34 <ski> (s/interaction/interacting/)
20:43:30 <ski> tty4 : hmm ?
20:43:52 <tty4> ski: go about doing the transformation from CPS-code -> 'machine code', since my machine code at this stage is really Java code.
20:44:15 <tty4> leafs not iteracting meaning i did not have to store context from one leaf to another.
20:44:55 <ski> (except how to get to the next leaf, right ?)
20:45:07 <tty4> ski: correction - not all of the stack was necessary. we still needed to know which sub-tree to visit.
20:45:14 <ski> yes
20:45:16 <tty4> yes
20:45:37 <ski> so perhaps you wanted to have an explicit path in some array/vector
20:46:04 <ski> or dabble around with poin^H^H^H^Hobject references
20:47:03 <ski> (i.e. e.g. some "pointer-reversal" techniques)
20:47:05 <tty4> hmmm....interesting because i pre-transformed the tree and collected all the leaves into a vector (linked list) manually.
20:47:28 <tty4> but really wanted to do this at runtime.
20:48:16 <tty4> or in some automated manner to ensure my transformation was correct.
20:48:27 <ski> (well, i was referring to an array/vector of "directions" to take at each fork in the tree. i.e. a path to a node. on second thought a stack data structure might be better for this :)
20:48:55 <ski> oh, so you serialized it
20:49:24 <ski> i guess you perhaps could've done an iterator..
20:50:13 <ski> ("same-fringe" problem is interesting in this context)
20:53:57 <tty4> ski: just realize i transformed the datastructure.
20:54:05 <ski> mm
20:54:09 <tty4> i understand your statement now.
20:54:14 <ski> oh
20:54:20 <ski> (which one ? :)
20:54:38 <ski> (the path one ?)
20:54:46 <tty4> yes, basically use a stack as the accumulator as Riastradh said.
20:55:14 <tty4> that was the missing link for me. thanks
20:55:53 <ski> do you mean *the* stack, or *stack* (as a random datastructure) ?
20:56:35 <ski> (sorry, s/*stack*/*a* stack/)
20:56:42 <tty4> *stack* as the directions at each fork
20:58:07 <tty4> summary: once i get to CPS. figure out what is passed as the continuation. that is the accumulator which i need to simulate in Java.
20:59:28 <ski> mm, something like that could possibly work
21:00:32 <tty4> ski: ok. how would you go about it then. (i might be missing something and want to make sure i do not :)
21:01:13 <ski> oh :)
21:01:20 <ski> well, i'm not sure
21:02:31 <ski> i assume one could do some defunctionalization after the CPS transformation
21:02:57 <tty4> ski: what is defunctionalization ?
21:03:18 <ski> @wiki DeFunctionalization
21:03:18 <lambdabot> http://www.haskell.org/hawiki/DeFunctionalization
21:04:07 <tty4> ski,lambdabot: thanks.
21:06:28 <tty4> ski: its late in this part of the world. so long and thanks for all your fish.
21:07:05 <ski> tty4 : bye
21:33:40 <Swynndla> I did: Prelude> map Char.toUpper "aBCde"    but it didn't work
21:33:51 <Swynndla> the tutorial said it should work
21:34:06 <Swynndla> but I get an error: ERROR - Undefined qualified variable "Char.toUpper"
21:34:32 <ski> using hugs or ghci ?
21:34:38 <Swynndla> hugs
21:34:48 <ski> try ":l Char"
21:35:25 <Swynndla> Prelude> map :l Char.toUpper "aBCde"
21:35:25 <Swynndla> ERROR - Undefined qualified variable "Char.toUpper"
21:37:04 <Swynndla> is that what you meant sky?
21:38:21 <ski> oh
21:38:23 <ski> hmm
21:38:24 <Etaoin> I think he meant just ":l Char" on a line
21:38:27 <ski> yes
21:38:41 <Etaoin> to load the module
21:38:42 <Etaoin> ?
21:38:43 <ski> and : in Hugs, toUpper is actually in the Prelude
21:38:49 <ski> (for some reason)
21:39:15 <ski> so just write   map toUpper "aBCde"
21:39:51 <Swynndla> Prelude> map toUpper "aBCde"
21:39:51 <Swynndla> ERROR - Undefined variable "toUpper"
21:40:18 <Swynndla> Prelude> :l char
21:40:19 <Swynndla> ERROR - Unable to open file "char"
21:40:51 <Swynndla> Prelude> :l Char
21:40:52 <Swynndla> Char>
21:41:06 <Swynndla> Char> map toUpper "aBCde"
21:41:07 <Swynndla> "ABCDE"
21:41:14 <Swynndla> ok that worked ...
21:41:44 <Swynndla> but ... I'm confused why I couldn't do it the way the tut said
21:42:15 <ski> Swynndla : what hugs version ?
21:42:33 <Swynndla> Hugs 98
21:42:41 <ski> yeah, but ?
21:42:42 <Swynndla> Version: November 2003
21:42:44 <Swynndla> sorry
21:42:47 <ski> November 2002 ?
21:42:48 <ski> ok
21:43:07 <ski> well, i suppose they have fixed toUpper not being in Char, then
21:43:30 <Swynndla> huh?
21:43:45 <Swynndla> where is it fixed? ... and how to I get the fix?
21:43:48 <ski> in November 2002 toUpper is not in module Char
21:44:05 <ski> i think you already have the fix (by having November 2003)
21:44:39 <ski> it's i that not have the fix. (because they seem to not have installed later than November 2002, here at uni)
21:45:29 <ski> Swynndla : hmm, perhaps the tut were referring to the way to do it in ghci
21:45:43 <Swynndla> ski, yea I think you are right
21:45:53 <ski> (in ghci Char is already loaded, because it's in a preloaded package)
21:46:11 <Swynndla> so which is the standard way ... is there a standard?
21:46:12 <ski> but i think that if you load Char in hugs, the original version should work
21:46:38 <Swynndla> oh
21:47:01 <ski> i don't think there is a standard (as in standard documents) way of doing a top-level read-type-eval-print-loop
21:47:14 <ski> though hugs and ghci is quite similar
21:47:27 <ski> (at least compared to hbci, i've heard)
21:47:56 <Swynndla> oic ... what about if I want to compile it ... do I need to put it in a file first?
21:48:11 <ski> in hugs ? ghci ?
21:48:33 <ski> hugs can't compile. it's an inperpreter
21:48:41 <Swynndla> oic
21:48:56 <ski> (well, it might actually do a compile-to-some-byte-code. i dunno)
21:49:02 <Swynndla> i'll give ghci a go then
21:49:28 <ski> but usually, if you want to have more definitions, you write it in a file, yes
21:49:50 <Swynndla> ok
21:49:56 <ski> there is no problem in typeing a lot of definitions into a *.hs file and loading that into hugs
21:50:16 <Swynndla> but if I did, I couldn't use the format in the tut?
21:50:18 <ski> (perhaps that was what you meant by "compiling" ?)
21:50:24 <ski> ?
21:50:29 <ski> what format ?
21:50:39 <Swynndla> Char.toUpper
21:50:47 <ski> (and what tut ?  the gentle one ?)
21:50:58 <ski> that should work in source files too
21:51:10 <Swynndla> but not for hugs?
21:51:18 <ski> for hugs, too
21:51:23 <Swynndla> remember that Char.toUpper *didn't* work for hugs
21:51:27 <Swynndla> doesn't
21:51:37 <Swynndla> not that format
21:51:42 <ski> try typing ":l" into hugs
21:51:57 <ski> it should change the prompt into "Prelude> " i think
21:52:18 <ski> oh, sorry
21:52:32 <ski> hmm
21:52:33 <Swynndla> Prelude> :l
21:52:33 <Swynndla> Prelude> map Char.toUpper "aBCde"
21:52:33 <Swynndla> ERROR - Undefined qualified variable "Char.toUpper"
21:52:33 <Swynndla> Prelude>
21:52:47 <ski> ok
21:52:55 <ski> now try typing ":l Char"
21:53:07 <ski> and then trying the same line
21:53:19 <Swynndla> Prelude> :l Char
21:53:19 <Swynndla> Char> map Char.toUpper "aBCde"
21:53:19 <Swynndla> ERROR - Undefined qualified variable "Char.toUpper"
21:53:19 <Swynndla> Char>
21:53:26 <ski> hmm
21:53:39 <Swynndla> Char> map toUpper "aBCde"
21:53:39 <Swynndla> "ABCDE"
21:53:39 <Swynndla> Char>
21:53:45 <Swynndla> that format works
21:53:57 <Swynndla> but it's a different format to the tut
21:54:17 <Swynndla> and if I was going to put it in a file, which format should I use?
21:54:42 <ski> try typing ":b"
21:55:03 <ski> is "toUpper :: Char -> String" mentioned there ?
21:55:12 <ski> "toUpper :: Char -> Char"
21:55:43 <Swynndla> nope
21:55:47 <ski> ok
21:55:59 <ski> then it seems toUpper is still in Prelude :(
21:56:09 <Swynndla> what is Prelude?
21:56:15 <ski> so you should use the "toUpper" format, then
21:56:31 <ski> Prelude is the automatically loaded module/source-file
21:56:53 <saz> um
21:56:55 <ski> it contains things like lists manipulation, +,-,*,/, etc ...
21:57:02 <saz> I thought that toUpper was changed to upper
21:57:30 <ski> saz : i dunno. you might be right
21:57:58 <Swynndla> "upper" isn't in :b either
21:58:05 <ski> saz : hmm, not in ghc docs, anyway
21:58:10 <saz> oh, hmm
21:58:17 <saz> might be confusing languages :)
21:58:28 <saz> yeah, I am
21:59:42 <ski> Swynndla : also, in an interpreter you type *expressions* to evaluate  (and commands like ":l MyFile")
21:59:56 <ski> in the source file you type *definitions*
22:00:01 <ski> e.g.
22:00:18 <ski> test1 = map toUpper "aBCde"
22:00:44 <Swynndla> oh
22:00:51 <ski> after you've (re)loaded the file/module, you can then try typing test1 in the interpreter
22:01:05 <ski> and it will answer "ABCDE"  (hopefully :)
22:01:45 <ski> but this is probably covered in the tutorial, not too far from the beginning ..
22:01:56 <ski> which tutorial are you reading, btw ?
22:02:24 <ski> the "gentle introduction" ?
22:02:24 <Swynndla> "yet another haskell tutorial"
22:02:26 <ski> ok
22:02:36 <ski> that one is good (i've heard)
22:02:36 <Swynndla> no the gentle one was too rough for me
22:02:41 <ski> yes
22:04:51 <Swynndla> but the format it uses doesn't work in hugs .. I should try ghci
22:05:15 <ski> which page are you on ?
22:05:29 <Swynndla> in ocaml, the syntax for the interpreter is exactly the same as what you put in a file ... makes it really easy
22:05:46 <Swynndla> 18
22:05:56 <Swynndla> the Char.toUpper is on page 18
22:06:13 <ski> the Char.toUpper business have nothing to do with syntax being same or not
22:06:42 <Swynndla> oh
22:06:44 <ski> (that has to do with that hugs arguably have that function in a worng module)
22:07:13 <Swynndla> oic oic
22:07:19 <ski> i think most (if not all) examples in the tut would work with both hugs and ghci
22:08:43 <Swynndla> ok
22:09:06 <Swynndla> I'll keep going then :)
22:09:47 <ski> (though some things in hugs is in Prelude while they ought to be in some other module ..)
22:10:46 <ski> hello vorpal
22:11:19 <Swynndla> well, apt-get says I can download ghc4, ghc5, or ghc6 ... I guess ghc6 is the latest
22:11:26 <ski> yes
22:11:52 <vorpal> hiya ski
22:11:56 <ski> it's bigger, of course. and ghci is a bit slower than hugs
22:12:14 <ski> but it includes a full compiler
22:13:01 <ski> (and one can type value and function definitions directly into the top-level, if one wants)
22:13:51 <Swynndla> ski, so basically what is in a file I can copy and paste it into the top-level interpreter and it would work?
22:15:19 <Swynndla> 63 megs
22:16:29 <Swynndla> ski, once again, thanks for being patient with me :)
22:16:53 <ski> mm, wait
22:17:15 <Swynndla> ok
22:17:40 <ski> you can't copy and paste things from a source file into the top-level
22:17:49 <ski> (e.g. type definitions)
22:18:00 <ski> (at least not in hugs and ghci)
22:18:19 <ski> usually the main work is done in some editor
22:18:46 <ski> and hugs/ghci is used to interactively try out the things defined in the source file
22:19:06 <Swynndla> ok
22:19:24 <ski> you might of course run an inferior hugs process in emacs, though
22:19:49 <ski> "63 megs" ?
22:19:55 <ski> (oh, ghc)
22:20:00 <Swynndla> yup :)
22:20:16 <Swynndla> I don't like inferior hugs ... just ask my wife
22:20:20 <ski> (that includes quite some libraries, i think)
22:20:27 <ski> haha
22:20:40 <Swynndla> yup ... 63 megs for the whole bundle
22:21:11 <ski> ok
22:21:24 <ski> well ..
22:21:40 <ski> i think it's time to leave, for me
22:21:51 <ski> (get some food, and sleep :)
22:22:01 <ski> got any last-minute questions ? ;)
22:22:54 <Swynndla> I've just got into the ghci ....
22:23:04 <ski> already installed it ?
22:23:05 <Swynndla> ... I'll just try out that map ...
22:23:09 <ski> ok
22:23:23 <Swynndla> it works!!
22:23:32 <Swynndla> :))
22:23:36 <ski> fine :)
22:23:48 <Swynndla> thanks ski .. you are one patient person :)
22:23:56 <ski> i guess
22:24:20 <ski> ok, bye for today
22:24:21 <ski> cya
22:24:26 <Swynndla> bye ski :)))
23:22:24 <Swynndla> I know how to compile a file using ghc, but what would I put in that file so it says "Hello world!" ?
23:30:50 <shapr> Swynndla: putStrLn "Hello world! ?"
23:31:08 <Swynndla> oh :)
23:31:33 <ibid> main = putStrLn "Hello world! ?"
23:31:35 <ibid> actually :)
23:31:41 <Swynndla> ahhh
23:32:00 <ibid> and a "module Main where" line at the beginning would be nice :)
23:32:26 <Swynndla> but not neccessary?
23:32:38 <shapr> try it
23:32:48 <ibid> i'm not sure - i think it is
23:33:12 <ibid> it certainly is required by the specs, but i'm not sure how strict ghc is in that regard
23:35:38 <Swynndla> I tried it both ways ... "module Main where" isn't neccessary
23:40:39 <Swynndla> what's wrong with this:
23:40:41 <Swynndla> main = do putStrLn "What is your name ?"
23:40:41 <Swynndla>            name <- getLine
23:40:41 <Swynndla>            putStrLn ("Hi " ++ name ++ " !")
23:41:07 <shapr> do you get an error?
23:41:18 <Swynndla> yes
23:41:33 <ibid> Swynndla: layout is wrong
23:41:44 <ibid> Swynndla: unless irc is messing with your indentation...
23:42:22 <ibid> both later lines should be aligned with the "p" of putStrLn in the first line
23:42:42 <Swynndla> oic]
23:43:29 <Swynndla> yea that was it thx ibid :)
23:52:22 * shapr yawns
23:59:55 <andersca> fosdem, here I come!
