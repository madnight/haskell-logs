02:13:12 <ham> hiho
02:13:20 <ham> hiho
02:13:48 <basti_> hiho
02:14:02 <ski> fifo
02:14:12 <ham> fofam
02:14:17 <ski> gigo
02:14:21 <basti_> foam?
02:14:25 <eivuokko> Hi all.
02:14:44 <ski> hi eivuokko
02:15:38 <ski> do you have some haskell question ?
02:15:55 <eivuokko> No.  Should I? :)
02:16:11 <ski> i dunno
02:16:27 <basti_> it would rise the entertainment factor of the chan
02:16:32 <ski> do you know anything about haskell ?  :)
02:16:45 <earthy> it's typed, right? :)
02:17:46 <ski> earthy : :-¤
02:18:26 <eivuokko> I do know haskell.  Enough to read report and help some students on ircnet...
02:18:39 <ski> fine !
02:20:55 <ski> "Like most functional programming languages, ML is lazy."
02:21:04 <ski> huh ?
02:21:10 <earthy> *wha*?
02:22:19 <ski> also "ML does not run on a PC." and "ML cannot be used to build applications with 3D buttons and context sensitive help."
02:22:47 <earthy> sounds like one awfully big troll.
02:23:06 <ski> seen on http://www.bath.ac.uk/~cs1cb/ML/index.htm 'weaknesses' section
02:23:30 <ski> some of the other info seems not so worng
02:24:38 <ski> i suspect the page is very old, and probably wasn't totally accurate/correct even then  (at least in some respects)
02:25:20 <ski> hmm
02:25:22 <earthy> well, they mention Lazy ML separately... why would that language exist as a separate branch
02:25:37 <earthy> looks like a student project to me with bad internal coordination among members of the group
02:25:47 <ski> ML 2000 is presumably from around year 2000, no ?
02:26:01 <eivuokko> Last-Modified: Wed, 14 May 2003 17:50:02 GMT
02:26:10 <ski> (so all of it can't be that old, then)
02:27:08 <ski> (also OCaml is not mentioned in 'history')
02:28:14 <earthy> student project, not very well executed
02:28:21 <earthy> I hope the teach berated them on parts. :)
02:29:01 <earthy> undergrads, even
02:30:55 * earthy nods
02:31:04 <earthy> course no. cm20168
02:31:15 <earthy> on the history of programming languages. ;)
02:32:11 <ski> (hmm, trying to find the course page ..)
02:33:37 <earthy> http://www.cs.bath.ac.uk/~jap/CM20168/
02:35:10 <ski> thanks
02:36:40 <earthy> unfortunately, while there are grades for 2001/2002 there aren't any for 2002/2003
02:37:28 <ski> (noticed that)
02:38:36 <vegai> "Although this [laziness] seems to be a sensible approach for avoiding unnecessary computation, it is not."
02:38:50 <ski> (hmm, you don't think they took the course, say 2000/2001, then ?)
02:39:55 <vegai> I wish I had the guts to state facts like that
02:40:31 <ski> (i don't see ML in group mapping at either of 02/03 and 01/02)
03:03:06 <Maddas> uh
03:03:10 <Maddas> I hate those kind of pages
03:03:11 <Maddas> :)
03:05:45 <earthy> ski: there are only mappings on that website for 01/02 and 03/04, if I see correctly
03:07:26 <ski> earthy : right, 03/04, not 02/03  (forgot what year it was ATM)
04:16:00 <earthy> Whee! Bram says: Arthur - Bedankt voor de nieuwe files.  Ik zal ze overnemen.
04:16:44 <earthy> roughly translated: `Thanks for the new files. I'll use them from now on'
04:56:52 <blackdog> should you be looking for something headsmackingly trivial, http://www.cse.unsw.edu.au/~mwotton/vixenlove.tgz may fill the empty void.
05:16:47 <shapr> yow!
05:17:33 <Lunar^> shapr: yow
05:17:43 <shapr> hey Lunar^, what's up? any progress on IRQs?
05:18:04 <Lunar^> shapr: I need to read, read, read, read
05:18:25 <blackdog> shapr: got the vixenlove bot working. such fun. :)
05:18:43 <shapr> blackdog: what's the interface?
05:19:05 <Lunar^> shapr: But I think I'm going to prototype something with an handler written in C filling a buffer that an Haskell thread would decode
05:19:37 <shapr> blackdog: ah, I see
05:19:38 <Lunar^> shapr: If the design is convincing, we surely could dynamically generate it later
05:19:49 <shapr> Lunar^: yes, I agree.
05:20:01 <Lunar^> shapr: But, the garbage-collector described in "Non-stop Haskell" seems also really promising
05:20:13 <blackdog> shapr: primitive.
05:20:34 <blackdog> just too tired for real hacking, so something completely silly seemed appropriate.
05:20:49 <Lunar^> shapr: (but I need to read the paper more deepfully), because in that case, modifying the Scheduler could make the trick
05:22:29 <shapr> hopefully I'll have time to read that paper.
05:22:36 <shapr> and write a vixenlove lambdabot plugin.
05:23:25 * blackdog rubs hands together
05:23:36 <shapr> which I could then connect to my icq/jabber/etc
05:23:48 <blackdog> ok, design question: is it worthwhile having multiple regex layers, do you think?
05:24:30 <blackdog> I was thinking you could search for "why" at one level, then search for other things within that... it might help to structure the control file.
05:25:40 * shapr tries to think of how vixenlove would respond ;-)
05:27:26 <blackdog> "isn't it obvious?", apparently.
05:27:42 <shapr> I'd have to try it, I don't know.
05:28:00 <blackdog> cheeky little bugger. she's probably going to start criticising my indentation next.
05:28:23 * shapr grins
05:29:58 <blackdog> it's quite a general framework, really... i wonder how hard it'd be to get enough marvin quotes for a plausibly depressing bot.
05:32:57 <Igloo> Hmm, GHC 6.2.1 expected around March 8th
05:34:28 <blackdog> pre-order now to avoid disappointment
05:38:39 <Lunar^> Igloo: cool
05:38:44 <Lunar^> Igloo: With the C-- backend ?
05:38:55 <Igloo> No
05:39:00 <Igloo> That's not even in the HEAD yet  :-)
05:39:20 <Lunar^> It seems a great progress anyway
05:39:35 <Lunar^> You will be able to remove Perl from the package depandancies :)
05:44:46 <edwinb> Hmm, I haven't played with C-- for a while.
06:18:25 <shapr> what's the status of utf-8 support in GHC?
06:18:58 <shapr> iirc, utf-8 data is fine to read and write, you just can't use it in .hs files, right?
06:27:05 <shapr> does GHC or other support gnu gettext or so?
06:27:17 <shapr> is there a good way to i18n a Haskell program?
06:28:03 <dennisb> shapr: I think norpan made a binding of gettext
06:28:12 <shapr> FFI binding?
06:28:21 <dennisb> yes
06:28:37 <dennisb> what else is there?
06:29:04 <shapr> the .po and .pot file structure looks very simple, so I thought it might be a pure Haskell library. 
06:29:42 <dennisb> ok, that could work also of course
06:31:06 <Igloo> I think the IO primitives use Latin-1 still, BICBW
06:59:07 <ham> bk
06:59:51 <shapr> ham: darcs!
06:59:55 * shapr cackles happily
07:00:03 <ham> heh :)
07:01:36 <Igloo> :-)
07:01:55 <Lunar^> shapr: Currently it's quite bad.. The easiest would be to use a TH Printf lib with FFI
07:18:04 <ski> hmm, values are immutable, variables are ... ?
07:18:21 <ski> ... also immutable ?
07:18:27 <ski> nonreassignable ?
07:18:37 <ski> final ?  const ?
07:18:48 <ski> constant, perhaps ?
07:19:45 <ham> ?
07:19:47 <ham> :)
07:21:30 <Lunar^> ski: unrebindable ?
07:22:21 <ski> (trying to compare/relate with single assignment and single static assignment)
07:23:35 <Lunar^> In fact, with the do-notation, you can shadow a previous definition
07:23:55 <Lunar^> do x <- return True ; x <- return False ; return x
07:23:56 <ski> mm, true
07:23:59 <Lunar^> gets translated into
07:24:24 <Lunar^> return True >>= \ x -> return False >>= \ x -> return x
07:24:29 <Lunar^> Which is correct
07:25:23 <ski> (let in ML,let* in Scheme (CL ?),# is Clean)
07:26:16 <Igloo> That's not reassigning to a variable, that's a new variable
07:26:50 <Igloo> It doesn't necessarily even have the same type
07:26:50 <ski> (just like Lunar^s monad example was, yes)
07:27:03 <ski> right
07:27:07 <Lunar^> Igloo: sure, I'm just saying it looks like
07:31:44 <Segora> re
08:06:49 <shapr> it's oh so quiet.. it's oh so still....
08:08:16 <Igloo> WAALLA WALLA LA BAMBA!
08:09:33 * shapr boings!
08:10:06 <shapr> la-la-la-la-la-la-LAMBDA!
08:10:24 * Igloo looks confused at a 'expecting letter or digit or "#"' error from a parser that should never want a #
08:10:27 <shapr> la-la-la something I forgot... o/~
08:11:11 <Lunar^> shapr: http://lambdadance.spacebar.org/
08:16:32 <earthy> *sick*. :)
08:16:35 <earthy> but fun. :)
08:16:43 <edwinb> how frightening...
08:17:10 <Igloo> Does this need animated gifs?
08:17:17 <earthy> yes. :)
08:17:51 <Lunar^> Ever heard of this Hamster dance ?
08:18:01 * Igloo smiles at it
08:18:41 <earthy> a `badger' adaptation in this style would be quite horrible.
08:19:22 <Lunar^> http://www.hampsterdance2.com/hampsterdance2.html
08:57:54 <Maddas> haha, the lambdadance
09:02:05 <Lunar^> Maddas: :)
09:35:53 <moccino> !list
11:44:27 <wglwill> hi
11:47:58 <Etaoin> hi
11:49:27 <Lemmih> hi
11:52:11 <wglwill> would you guys be willing to help me clear some things up? i'm very new to haskell, i'm currently reading up on it to gather some information for trying some actual programming
11:52:22 <wglwill> in haskell
11:52:33 <Lemmih> Sure.
11:53:50 <wglwill> ok, from what i've been reading functional programs are just like a large mathematical definiton, a really complex function. due to this things that are external to the program that are stateful (such as IO or opengl) sort of cause a problem for functional programming right?
11:54:17 <wglwill> because you don't want anything changing while the function is being evaluated
11:54:37 <wglwill> am i understanding this correctly?
11:54:45 <Lemmih> yeah.
11:54:49 <Etaoin> well you want a function to return the same value when given the same arguments
11:55:02 <Etaoin> (otherwise, it's not a mathematical function)
11:55:10 <Etaoin> and IO kind of breaks this
11:55:26 <wglwill> ok i realize there are solutions to this problem, like monads, but i had an idea and i'm wondering if it's a valid approach
11:55:37 <wglwill> first i had to confirm my undersanding of the situation before asking
11:57:07 <jlouis> A monad is a nice mathematical object with certain properties. It can capture state and I/O among other things and ''wrap'' it such that the rest of the program can be purely functional.
11:59:00 <wglwill> lets say i had an external main loop written in an imperative language which repeatedly calls a haskell program, all of the functionality of the program would be in this haskell program. the imperative main loop would basically set up an input state which can be assumed to be non varying during the execution of the haskell program, when it is called it takes this input and generates the output, like redrawing the graphical objec
11:59:00 <wglwill> ts on the scene and such, then it exits, the imperative loop updates the input states then repeats
11:59:55 <wglwill> does that make any sense?
12:00:33 <wglwill> basically design your haskell program to be run a as a function being repeatedly evaluated over the input state
12:01:08 <jlouis> yes. A monad can emulate the imperative style and read data from the stdin. The loop can be written in Haskell. There is no need for it to be imperative as far as I see
12:01:29 <wglwill> oh monads do this?
12:01:38 <wglwill> i've just started reading about them
12:02:21 <wglwill> i was thinking this would be an effective way of working with stateful systems like the standard device library
12:02:25 <jlouis> They capture certain properties of imperative style yes
12:04:45 <wglwill> Also it seemed to me that it would also allow me to keep any hints of imperative coding style out of the haskell program by being able to assume that all stateful functon calls are constant for the duration of the haskell program
12:04:58 <wglwill> but monads would be better approach than this?
12:06:26 <stepcut> wglwill: to understand monads, it is useful to understand what existed before monads
12:07:32 <wglwill> well it's not really monads i'm trying to understand right now, i'm really more concerned if this approach i've described is at all a valid approach
12:08:15 <stepcut> I think what you are describing is essentially how things work
12:08:32 <wglwill> i see
12:08:54 <stepcut> before monads, people used to pass in a variable 'world' to functions that did I/O, and doing I/O affects the state of that variable.
12:09:03 <monotonom> I think it is fine. The only inconvenience is the need of two languages. If you have monads in Haskell, you don't need a second language, that's all.
12:09:40 <stepcut> In this sense, I/O is still purely function, if 'world' is the same, then the result of the program should be the same
12:09:43 <wglwill> ok then, so monads are just a more elegant and correct approach to doing what i've described
12:11:09 <stepcut> monads just provide a convinent syntax so that you do not have to explicitly pass 'world' around. This reduces errors and makes code easier to read. Monads also increase reusability
12:11:48 <stepcut> http://www.abercrombiegroup.co.uk/~noel/research/monads.html
12:11:53 <DeezNuts> heh
12:12:05 <stepcut> this page has a section on Monadic IO which talks about the world variable
12:12:06 <DeezNuts> u wouldn't have to pass 'world' around anyway in a real langauge
12:12:48 <wglwill> ok this is making more sense, thanks for clearing that up for me
12:13:15 <wglwill> by the way how do monads compare to uniqueness typing?
12:13:44 <wglwill> is it a superior approach, or just a different approach
12:13:50 <monotonom> just different
12:14:02 <wglwill> ok
12:14:16 <wglwill> you guys have been very helpful
12:14:17 <wglwill> thanks
12:21:21 <stepcut> wglwill: uniqness typesa and monads can both be used to solve the IO 'problem'. But they both are much more general and each offer from unique benefits of their own
13:00:41 <DeezNuts> yo
13:00:53 <DeezNuts> i thought ghci is suppose to let you define functions and such
13:01:54 <keverets> Prelude> let square x = x * x
13:01:55 <keverets> Prelude> square 3
13:01:55 <keverets> 9
13:02:06 <DeezNuts> let
13:02:18 <DeezNuts> u dont have to use that in a file
13:02:26 <keverets> you're right.
13:04:01 <DeezNuts> Prelude> let f 1 = 1
13:04:01 <DeezNuts> Prelude> f 1
13:04:01 <DeezNuts> 1
13:04:01 <DeezNuts> Prelude> let f 2 = 1
13:04:01 <DeezNuts> Prelude> f 1
13:04:02 <DeezNuts> *** Exception: <interactive>:1: Non-exhaustive patterns in function f
13:04:25 <Marvin--> DeezNuts: let { f 1 = 1 ; f 2 = 1 }
13:05:08 <Marvin--> basically, what you wrote translates to   let f 1 = 1 in let f 2 = 1 in f
13:05:33 <DeezNuts> huh
13:05:43 <DeezNuts> why is it different in the interpreter?
13:06:04 <Marvin--> you can see the interaction with the interpreter as being "inside" an IO monad
13:06:20 <DeezNuts> oh great... that "different but just as easy" monad thing heh
13:06:26 * DeezNuts thinks all you haskellers are in denial
13:06:38 <Marvin--> if you write
13:06:39 <Marvin--> main = do
13:06:40 <Marvin-->  let f 1 = 1
13:06:40 <Marvin-->  let f 2 = 1
13:06:40 <Marvin-->  print (f 1)
13:06:43 <Marvin--> you'll have the same problem
13:06:57 <DeezNuts> oh
13:06:58 <DeezNuts> ok
13:07:05 <DeezNuts> but i haven't written anything like that yet
13:07:16 <Marvin--> the right way would be:
13:07:17 <Marvin--> main = do
13:07:18 <Marvin-->  let f 1 = 1
13:07:18 <Marvin-->      f 2 = 1
13:07:18 <Marvin-->  print (f 1)
13:07:35 <DeezNuts> oh is let like perl's my?
13:07:36 <Marvin--> but since the interpreter doesn't have multi-line input, you have to use explicit delimiters (the {;})
13:07:39 <DeezNuts> ie it makes f a lexical?
13:07:46 <Marvin--> I don't speak perl
13:07:52 * Lunar^ just added an entry to his dev lOg
13:07:52 <DeezNuts> or C
13:07:55 <DeezNuts> or whatever
13:08:11 <Igloo> Yes, except the LHS is in the scope of the RHS
13:08:12 <DeezNuts> it seems 'let' says 'this variable (or function or whatever) is local'
13:08:24 <Marvin--> well, sort of
13:08:55 <DeezNuts> ok
13:08:58 <Marvin--> but you can't put let at top level in a haskell module
13:09:07 <DeezNuts> why not
13:09:28 <Marvin--> because a haskell module consists of a sequence of bindings
13:09:36 <Marvin--> and a let is not a binding
13:09:52 <Marvin--> the let:s in do expressions are just syntactic sugar
13:10:01 <DeezNuts> good lord ghci is slow
13:10:29 * DeezNuts 's teeth are rotted from Perl
13:10:33 <Marvin--> do { let { f 1 = 1 ; f 2 = 1 } ; print (f 1) }  is syntactic sugar for   let { f 1 = 1 ; f 2 = 1 } in print (f 1)   which is an expression rather than a binding
13:11:08 <Maddas> DeezNuts: ghci _compiles_ slowly, but the resulting code isn't.
13:11:18 <Maddas> err, ghc.
13:11:26 <DeezNuts> okay... im talking about ghci
13:11:49 <DeezNuts> in fact
13:12:03 <DeezNuts> ghci is unacceptably slow
13:12:14 <DeezNuts> fib(100) is taking minutes...
13:12:21 <DeezNuts> if not forever
13:12:33 <Igloo> The recursive definition?
13:12:39 <DeezNuts> indeed
13:12:56 <Igloo> That's exponential in n, isn't it?
13:12:59 <DeezNuts> let { f 1 = 1; f 2 = 1; f n = f(n-1) + f(n-2); }
13:13:17 <Maddas> DeezNuts: Uh, fib(100) isn't very fast in Perl either, I'd say.
13:13:24 <DeezNuts> lol
13:13:34 <DeezNuts> im sure it would return quicker than you could say "fib(100)"
13:13:40 <Maddas> Try it.
13:13:44 <DeezNuts> i've written this many times before
13:13:47 <DeezNuts> in different languages
13:13:48 <Marvin--> um
13:13:51 <Maddas> Right.
13:15:47 <DeezNuts> my bad
13:15:52 <Igloo> fst ((iterate (\(x, y) -> (y, x+y)) (1, 1)) !! 100)   should be fast enough for you
13:15:54 <DeezNuts> maybe i was thinking of another function
13:16:25 <DeezNuts> or maybe of C
13:16:26 <DeezNuts> or some such
13:16:27 <DeezNuts> dunno
13:16:36 <Maddas> fib(100) in C won't return that quickly either :)
13:16:38 <DeezNuts> Igloo: i dont actually need a fast fib function
13:16:44 <DeezNuts> Maddas: ok well still quicker :p
13:16:48 <Igloo> Everyone needs a fast fib function
13:16:59 <Maddas> The problem isn't the programming language
13:17:01 <Maddas> (in this case)
13:17:02 <DeezNuts> Igloo: I'm sure I will in the future :)
13:17:07 <DeezNuts> Maddas: I concur
13:17:12 <Maddas> Igloo: I want it O(1)!
13:17:40 <Taaus> Maddas: Just use the closed form ;)
13:17:49 * Igloo would have to think to work it out, but intuitively it'll require something like 2^100 operations which isn't feasible
13:17:51 <Maddas> Igloo: For arbitrarily large numbers, so looking it up in a hash/db doesn't count! :-)
13:18:02 <Marvin--> Maddas: shucks :P
13:18:12 <Maddas> Marvin--: What? :)
13:18:14 <Igloo> Maddas: But you want a computer to do the calculation, right?
13:18:20 <Maddas> Yes! My laptop!
13:18:30 <Marvin--> Maddas: I was going to give you a fast program for calculating fib(100) :)
13:18:48 <Maddas> Igloo: :-)
13:19:05 <Igloo> So all I need is one with enough ROM to hold a lookup table large enough to have a lookup table large enough to cover all numbers you can represent in the RAM you have available  :-)
13:19:13 <Igloo> where RAM = all alterable store
13:19:15 <Maddas> haha
13:19:29 <Maddas> Good answer :)
13:20:05 <Marvin--> oh my god, I might actually finish this report some time this year, Koen seems to like what I've written so far
13:20:22 <DeezNuts> ok so will fib(100) ever return
13:20:47 <Marvin--> DeezNuts: try it in C or assembly or something like that first
13:20:54 <Marvin--> or perl
13:20:55 <Taaus> fib(100) does halt... Eventually...
13:21:14 <Taaus> (Given enough runtime, memory, etc.)
13:21:18 * Marvin-- won't torture his poor laptop with this kind of program
13:21:20 <Maddas> It might be faster to just google.
13:21:30 * Maddas does
13:21:38 <Maddas> actually
13:21:44 <Maddas> Time to make use of this dual G5! :-)
13:22:11 <DeezNuts> Marvin--: I did try it in perl
13:22:16 <DeezNuts> Marvin--: was waiting too long for that too
13:22:29 <ludde> fib(100) will probably not return in a reasonable amount of time in any language
13:22:44 <ludde> that's like 2^100 steps or so, right?
13:22:46 <Maddas> ludde: Is one week reasonable?
13:22:47 <DeezNuts> ludde: what about in a day or two?
13:23:11 <Maddas> Maybe we should setup a distributed network to calculate fibanocci numbers. 
13:23:12 * Maddas grins
13:23:17 <ludde> I think it would take hundreds of years
13:23:19 <ludde> but i'm not sure
13:23:35 <Marvin--> bah, 2^100 isn't that large
13:23:39 <Marvin--> oh wait, it is
13:23:43 <Igloo> lol
13:23:44 <Maddas> Just twice as large as 2^99!
13:24:27 <DeezNuts> 2^100 == 1.2676506002282294*^30
13:24:39 <DeezNuts> according to mathematica
13:24:41 <ludde> if the computer can do 2^32 steps per second
13:24:48 <ludde> then it's 2^68 seconds
13:24:49 <Igloo> 2^100 is about where 3DES gets cracked once you pull any tricks you can out of the bag isn't it?
13:24:52 <Marvin--> 1267650600228229401496703205376 according to bc
13:24:58 <Maddas> aiie
13:25:05 <Maddas> Ok, you convinced me.
13:25:15 * Maddas shuts his desktop computer down again
13:25:25 <ludde> that's like 9 millions of millions of years
13:25:27 <DeezNuts> so how many years would it take??
13:25:30 <DeezNuts> ouch
13:25:31 <DeezNuts> damnit
13:25:42 <Maddas> DeezNuts: And you blame ghci! Pff! :-)
13:25:43 <DeezNuts> so its intractible?
13:25:47 <DeezNuts> Maddas: ok ok! u got me
13:25:49 <ludde> i'm not sure if fib(100) is 2^100 steps though
13:25:55 <Marvin--> DeezNuts: hell yeah
13:25:56 <ludde> but quite close enough
13:26:04 <Igloo> Maddas: But just think how many millions of years slower ghci was making it with the interpretive overhead!
13:26:12 <DeezNuts> ludde: fib 1 = 1; fib 2 = 1; fib n = fib(n-1) + fib(n-2)
13:26:21 <Maddas> Igloo: haha
13:26:54 <Maddas> Igloo: actually, you could just hide it behind lazy evaluation, never print the value and pretend to the user that the program knows it!
13:27:02 <Maddas> (And just refuses to tell the answer)
13:27:43 <Marvin--> would that be called impolite evaluation?
13:28:02 <Maddas> Haha
13:32:29 <DeezNuts> I have a function exponent
13:32:32 <DeezNuts> that takes two arguments
13:32:44 <DeezNuts> and I want to supply the return values of two function calls
13:32:49 <DeezNuts> but I can't get the syntax right
13:36:29 <bring> assuming Moore's law holds for the next 150 years or so, we should have a computer that does 2^100 times as many operations per second as current machines around year 2150
13:36:37 <Lunar^> DeezNuts: supply?
13:37:06 <bring> so assuming Moore's holds indefinitely (not likely I guess) NP = P
13:37:06 <Lunar^> DeezNuts: f (g a) (h b)
13:37:39 <Maddas> wake me up in 146 years, then!
13:38:12 <bring> it's a lot sooner than 9 million millon anyway :)
13:38:31 <DeezNuts> Lunar^: not working
13:38:32 <monotonom> Fast computers are not an excuse for deliberately slow algorithms.
13:38:39 <DeezNuts> Lunar^: I have exponent f(32) f(32)
13:39:05 <Lunar^> DeezNuts: Sure, in Haskell, application is not written by putting arguments inside parenthesis
13:39:14 <Lunar^> DeezNuts: You just write a simple space
13:39:30 <bring> actually, using the principle of maximum slacktitude, we could wait 148 years, then start computing, and be done in a few years
13:39:31 <Lunar^> DeezNuts: In math, you write f(32), in Haskell, you just need : f 32
13:39:32 <Taaus> bring: I believe Intel is of the opinion that Moore's law won't hold beyond 2015. And other people think the good times will end considerably sooner. In 2007.
13:40:09 * bring hopes noone thinks he's being serious
13:40:13 <Etaoin> in math you can write f 32 too, sometimes
13:40:16 <Maddas> Taaus: What do you mean? I want to know fib(100)!
13:40:17 <Etaoin> like sin x
13:40:26 <Lunar^> DeezNuts: This notation seems strange at start, but when you start using partial application, it perfectly makes sense
13:40:38 <Taaus> Maddas: You wants to know, you gots to pay!
13:40:41 <bring> although people have been predicting the end of Moore's law for some time
13:40:47 <Maddas> Taaus: haha.
13:40:57 <Maddas> bring: I'm not thinking your serious!
13:41:01 <Maddas> you're.
13:41:03 <Lunar^> DeezNuts: That's why, in your case, you need to put parenthesis around exponent arguments : exponent (f 32) (f 32)
13:41:04 <Maddas> (Argh)
13:41:14 <Marvin--> Maddas: 573147844013817084101
13:41:16 <Marvin--> Maddas: happy now?
13:41:29 <bring> how about fib(fib(100))
13:41:35 <Taaus> Evil!
13:41:36 <Maddas> Marvin--: I don't trust anything I didn't verify in my head!
13:41:41 * Maddas grabs a pen and paper
13:41:47 <Marvin--> Maddas: well, I'll see you in a few years, then...
13:41:51 <Lunar^> Maddas: see you in 146 years ;)
13:42:11 <monotonom> fib 100 has fewer than 30 digits?
13:42:21 <Maddas> ...but humans are much more intelligent than computers! 
13:42:22 <Maddas> ;-)
13:42:32 <monotonom> Yeah right.
13:43:21 <DeezNuts> Lunar^: thanks
13:43:52 <Lunar^> DeezNuts: in case of doubt, you could always use let constructions
13:43:57 <bring> didn't Turing quote one definition of intelligence along the lines of "a machine is not intelligent until it can appreciate the taste of strawberries with cream"?
13:44:04 <monotonom> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=intelligence&x=22&y=13  "intelligence" defn #5: the ability to perform computer functions  (This is noted by Dijkstra.)
13:44:37 <bring> luckliy, he didn't go with that definition for the Turing test
13:44:45 <bring> would have been interesting thoguh
13:44:47 <Marvin--> mm, strawberries
13:45:10 <monotonom> I think Turing got intelligence and aesthetics mixed up.
13:45:18 <bring> s/butchered spelling/though/
13:45:52 <bring> I think he was quoting someone else, and using that as an example of a useless definition of intelligence
13:46:14 <monotonom> Ah heheh.  I still like Dijkstra's definition :)
13:46:48 <bring> "Possibly a machine might be made to enjoy this delicious dish, but any attempt to make one do so would be idiotic."
13:48:34 <Marvin--> hm, in what article was it that Dijkstra wrote that famous line about testing and showing the presence of errors?
13:49:17 <DeezNuts> How do you pronounce Dijkstra?
13:49:50 <Riastradh> With considerable difficulty.
13:49:54 <bring> :)
13:50:03 <monotonom> I approximate it as dych stra, where ch is as in chi
13:50:04 <Marvin--> oh yes
13:50:12 <bring> how about "de Bruijn"?
13:50:25 <Maddas> uh, how do you pronounce 'dych' and 'stra'?
13:50:54 <DeezNuts> dichy straw?
13:51:46 <DeezNuts> why do I get stack overflow errors from ghci??
13:51:52 <Igloo> I say it the way I'd naturally read "dike strerr"
13:52:13 <Maddas> ...maybe I'll just be happy with the fact that I never needed to pronounce Dijkstra yet, and don't have to in forseeable future.
13:52:36 <bring> DeezNuts: deep non-tail recursion 
13:53:11 <Igloo> Hmm, actually, less of an "err"
13:53:17 <cm> yo
13:53:55 <DeezNuts> why does [] == ([])?
13:54:09 <DeezNuts> or [] == ((([])))
13:54:22 <bring> because they are identical values?
13:54:26 <Marvin--> why not?
13:54:29 * Maddas nods
13:54:41 <Maddas> DeezNuts: Do you know what parentheses do?
13:54:48 <cm> it's not as if (x) was some kind of function application..
13:54:49 <monotonom> "foldl 0 (+) very_long_list" may give stack overflow because it first becomes (...((0+x)+y)+...) and then the stack is overflowed when evaluating that.
13:55:02 <DeezNuts> make ordered lists?
13:55:34 * Etaoin did not have enough memory to compute fib(fib(100)) :(
13:55:37 <Riastradh> monotonom, er, that's, uh, wrong.  Left folding is inherently tail-recursive.
13:55:59 <bring> DeezNutes: paranthesis just force precedence
13:56:00 <monotonom> You forgot laziness.
13:56:12 <Maddas> bring: parentheses ;-)
13:56:22 <bring> Maddas: thanks
13:56:31 <Maddas> Sorry then.
13:56:37 <DeezNuts> parenthesis let you make tuples
13:56:46 <DeezNuts> but is [] by itself a tupple?
13:56:59 <Lunar^> DeezNuts: [] means the empty list
13:57:03 <DeezNuts> i know
13:57:04 <bring> DeezNuts:  parentheses ;-)
13:57:11 <DeezNuts> but [] == ([])
13:57:14 <kosmikus> DeezNuts: there are no 1-tuples in Haskell
13:57:19 <Maddas> bring: haha :)
13:57:29 <bring> :)
13:57:33 <DeezNuts> .
13:57:47 <monotonom> Prelude> foldl (+) 0 [1..1000000]
13:57:47 <monotonom> *** Exception: stack overflow
13:57:52 <monotonom> That is with ghci 5.04
13:58:04 <DeezNuts> okkkkay
13:58:09 <DeezNuts> why does [] == ([])
13:58:11 <DeezNuts> anyone?
13:58:12 <jameson> DeezNuts: [] is a literal value by itself, just like 1 or 42.
13:58:15 * Riastradh mutters incomprehensibly at laziness.
13:58:25 <monotonom> Because (whatever) equals whatever
13:58:26 <Riastradh> You lazy people are causing overly heavy loads on the stack!
13:58:33 <monotonom> For example (1) equals 1.
13:58:36 <DeezNuts> obviously
13:58:38 <DeezNuts> but why
13:58:39 <DeezNuts> WHY
13:58:40 <bring> Prelude> foldr (+) 0 [1..1000000]
13:58:40 <bring> *** Exception: stack overflow
13:58:42 <kosmikus> DeezNuts: I don't see why not
13:58:43 <bring> wtf
13:58:56 <Maddas> DeezNuts: Because it is the same thing
13:58:57 <Riastradh> DeezNuts, it's because of silliness about tuples.  A single-element tuple containing X is equal to X.
13:59:00 <DeezNuts> well since () is used to make tuples
13:59:06 <jameson> DeezNuts: Parentheses don't have any semantics by themselves. They're merely a syntactic device to override operator precedence.
13:59:18 <bring> , makes a tuple
13:59:20 <monotonom> Is () really always used to make tuples?
13:59:20 <DeezNuts> jameson: how would you make tuples without them?
13:59:23 <DeezNuts> oh
13:59:24 <Riastradh> Blame Matthias Blume for spreading this silliness.  (or maybe someone else; he tries to spread it to Scheme)
13:59:38 <monotonom> I tend to think , is used to make tuples, not ()
13:59:38 <DeezNuts> hmm
13:59:52 <monotonom> 1+(2) is 3. Every 3yo knows that.
13:59:59 <DeezNuts> Riastradh: so normally in mathematics a tuple is a distinct object the same way a set is, correct?
14:00:15 <bring> for example: (,) 1 2 = (1,2)
14:00:20 <bring> s/=/==/
14:00:20 <Riastradh> DeezNuts, not quite.  Sets are unordered; tuples have specific orders.
14:00:32 <DeezNuts> Riastradh: I know they are different types of objects
14:00:34 <jameson> I think what he means is something else...
14:00:53 <DeezNuts> Riastradh: and I was asking if tuples are treated as distinct objects from its members
14:01:09 <Riastradh> Yes, except in the case of the single-element tuple.
14:01:09 <DeezNuts> Riastradh: the same way a set is treated
14:01:21 <DeezNuts> Riastradh: is that true in math too ?
14:01:32 <Riastradh> ?
14:01:33 <bring> but for one-element tuples, that's not true, right?
14:01:36 <DeezNuts> nevermind
14:01:43 <Riastradh> bring, uh, that's what I just said...
14:01:43 <jameson> DeezNuts: I've never heard of one-tuples in mathematics.
14:01:46 <monotonom> There is no "one-element tuple" in Haskell.
14:02:04 <DeezNuts> blah
14:02:06 <jameson> DeezNuts: AFAIK, the set-theoretical definition of tuples starts with two-element tuples, and reduces others to two-element ones.
14:02:27 <DeezNuts> jameson: so haskell confuses things with its syntax?
14:02:49 <bring> Riastradh: what I meant was that there are no one element tuples in math either
14:02:51 <jameson> It doesn't really make a lot of sense to distinguish one-tuples from nontuples anyway, as these things would evidently always be isomorphic.
14:02:55 <bring> as far as I understand
14:02:57 <jameson> DeezNuts: I don't follow you...
14:03:27 <monotonom> Yeah it would be nice if tuples were writte <1,2> instead of (1,2), so as to avoid multiple meanings of ().  Ooops < and > already have other meanings.  Well what do you suggest?
14:03:36 <stepcut> Deeznuts: the , is the tuple operator, the parens are 'just' for precedence
14:03:38 <Riastradh> Erlang uses { & }.
14:03:44 <stepcut> DeezNuts: (,) 1 2 --> (1,2)
14:04:04 <DeezNuts> how come you can't evaluate 1,2 by itself on the ghci interpreter line?
14:04:06 <Riastradh> Curly braces may be confused with sets, but sets are complicated beasts compared to tuples (in programming, anyways).
14:04:34 <DeezNuts> can I use set-constructor notation in haskell?
14:04:36 <DeezNuts> as in 
14:04:48 <stepcut> DeezNuts: dunno, in ocaml 1,2 does work :p
14:04:51 <monotonom> The problem is with the highly shortsighted ASCII character set.  In Unicode you would be able to choose unique symbols.
14:04:56 <DeezNuts> A = { x | x < x**2 }
14:04:59 <Marvin--> DeezNuts: because (e1,e2,e3,...,eN) is a special syntactic construct
14:05:08 <jameson> The "most correct" way to write tuples would probably be $\langle a, b \rangle$, but there are no ASCII characters for $\langle$ and $\rangle$...
14:05:14 <Marvin--> (1,2) is syntactic sugar for (,) 1 2
14:05:15 <Maddas> DeezNuts: yes, list comprehensions are like that.
14:05:27 <Riastradh> DeezNuts, er, no, you can't do that.
14:05:44 <Riastradh> Nor can you write a similar list comprehension.
14:05:49 <Maddas> (You can't do that particular example, though)
14:06:22 <DeezNuts> err i mean
14:06:31 <jameson> DeezNuts: A = [ [0..x**2] | x <- [0..] ] should work, though.
14:06:38 <DeezNuts> oh
14:06:44 <DeezNuts> when do I learn that
14:06:50 <bring> what would your keyboard look like if you hade unique symbols for everyhing?
14:06:57 <jameson> (That's lists, not sets, BTW. But it's close enough for most practical purposes.)
14:07:03 <monotonom> You learn that in calculus XXIII
14:07:12 <Riastradh> bring, it would be digital; the keys would be dynamically drawn.
14:07:16 <Maddas> monotonom: I find using unicode characters as operators messy.
14:07:51 <jameson> DeezNuts: I beleive there are tutorials on that.
14:08:01 <bring> Riastradh: sweet, but how would it know which ones to draw? an emacs mode maybe?
14:08:05 <jameson> Wadler discusses the monadic semantics in quite some detail in his paper on "Comprehending Monads".
14:08:18 <jameson> s/beleive/believe/
14:08:33 <monotonom> If I had enough unique symbols for Haskell, my keyboard would look like this: all those useless Fn and Windows keys would go away, instead I would have useful keys in their place.
14:08:49 <Maddas> bring: for a keyboard with emacs shortcuts, see http://www.fingerworks.com/emacs_mode.html :-)
14:09:17 <Maddas> monotonom: More power to you! Unfortunately, I use those "useless Fn" keys
14:09:33 <Riastradh> bring, the kernel would determine that; a syscall would modify certain keys.
14:09:58 <bring> but how would the software know what you want ot type next?
14:10:06 <Maddas> Riastradh: Hah, so when are you building that? :-)
14:10:20 <bring> s/ot/to/
14:10:20 <Riastradh> Maddas, check back in about forty years.
14:10:26 <Maddas> ok.
14:10:38 <Riastradh> ...(I'm going to regret having said that forty years from now)...
14:10:44 * Maddas nods
14:10:55 <Marvin--> yeah, by then we'll be able to calculate fib(100)
14:11:08 <Marvin--> or have we changed topic while I wasn't looking?
14:11:48 <monotonom> Hahah
14:13:16 <Riastradh> Marvin--, yeah, it's now fib(fib(100)).
14:13:48 <Marvin--> dang
14:14:21 <Riastradh> You're, like, forty seconds behind.  The train of thought left the station aeons ago!
14:14:55 <Marvin--> :(
14:15:06 <DeezNuts> Prelude> let { my_map (f) (x:xs) = (f x) : (my_map (f) (xs)) }
14:15:06 <DeezNuts> Prelude> my_map f [1,2,3,4,5,6,7,8,9]
14:15:06 <DeezNuts> [1,1,2,3,5,8,13,21,34*** Exception: <interactive>:1: Non-exhaustive patterns in function my_map
14:15:38 <Marvin--> you don't need all those parentheses!  my_map f (x:xs) = f x : my_map f xs  is quite enough
14:15:44 <DeezNuts> i know
14:15:47 <DeezNuts> i kept adding them
14:15:48 <Riastradh> DeezNuts, what happens if something tries [[my_map f []]]?
14:15:50 <DeezNuts> just to see if that was it
14:15:55 <DeezNuts> huh
14:15:55 <Marvin--> well, except that you need a base case too
14:16:16 <DeezNuts> ok
14:16:34 <monotonom> Infinity lists are rare.
14:16:51 <kosmikus> monotonom: actually, there are quite many of them ;)
14:17:06 <monotonom> Yes, but we happen to use very few of them.
14:17:35 <DeezNuts> let { my_map f [] = []; my_map f (x:xs) = f x : my_map f (xs) }
14:17:51 <DeezNuts> works
14:17:55 <monotonom> Das ist good
14:18:03 <DeezNuts> phat
14:18:22 <DeezNuts> next part is on IO heh
14:18:26 * Lunar^ is just realizing how Haskell is bad on IRC
14:18:30 <DeezNuts> but i gotta go take down a C first
14:18:31 <DeezNuts> brb
14:18:55 <monotonom> How is Haskell bad on IRC?
14:19:38 <kosmikus> probably because it is layout sensitive
14:20:54 <Lunar^> right
14:23:31 <Lunar^> Interesting : in eval/apply vs push/enter paper (SPJ-SM), they're already discussing using C--, but backend-hacking-branch just started lately
14:28:06 <Igloo> It's been vaguely planned for ages
14:30:30 * Lunar^ hits the mangler... "You're evil !"
14:32:55 <Marvin--> and it's written in perl too
16:23:22 <CyberTNT> hey what function reverses an integer?
16:23:54 <Cale> reverses?
16:24:12 <CyberTNT> yeah
16:24:15 <ozone> CyberTNT: as in, 123 -> 321?
16:24:21 <CyberTNT> yeah
16:24:50 <ozone> CyberTNT: this is a homework q, right? :)
16:24:56 <Cale> that defines a function (if you mention what it does with negatives)
16:24:59 <CyberTNT> i know it works with lists "reverse [1,2,3]" -> [3,2,1]
16:25:05 <CyberTNT> ozone no it isnt
16:25:06 <Cale> oh
16:25:09 <CyberTNT> personal pleasure
16:25:14 <Cale> hehe, this isn't #math
16:25:20 <Cale> :)
16:25:43 <Cale> you'll probably want to write something that turns an integer into a list of digits
16:25:56 <jameson> Try 'read (reverse (show 14))::Integer'
16:26:05 <jameson> And abstract out 14, of course ;-)
16:26:20 <ozone> CyberTNT: easiest (but ultra-slow) solution: "read (reverse (show 123)) :: Int"
16:26:28 <ozone> oh, yeah, what he said
16:26:34 <CyberTNT> ok thanks
16:26:58 <jameson> There are much faster ways, but this one has the advantage of still being reasonably quick to type ;-)
16:27:18 <Igloo> ultra-slow? Is it really that bad?
16:27:19 <Cale> also try read $ reverse $ show (-123)
16:27:42 <Cale> you'll find that you'll have to deal with negatives specially :)
16:28:28 <CyberTNT> i dont have negatives ;o
16:28:30 <ozone> Igloo: well, it's not the fastest :)
16:28:38 <ozone> but pre-mature optimisation blah blah blah
16:28:54 <Cale> you might also want to try writing functions that decompose an integer into its digits and build an integer from digits anyway
16:29:03 <CyberTNT> oh well seems like my program will take a while
16:29:30 <Cale> what does your program have to do?
16:29:40 <Cale> just that?
16:29:44 <CyberTNT> looking through 10^18 for palindroms dividable by prims between 10 and 30
16:29:52 <CyberTNT> ;o
16:30:02 <CyberTNT> and give the highest one out
16:30:03 <Cale> ah
16:30:27 <CyberTNT> so i am working my way from the top to bottom else it would be much more time consuming
16:30:52 <Cale> maybe only contstruct palindromes to test
16:31:28 <jlouis> I certainly hope you can skip a lot of those 10^18 and not try an exhaustive search
16:31:43 <CyberTNT> jlouis how would i skip?
16:32:39 <jlouis> CyberTNT: 1Ghz means 10^9 cycles. If you can test one case in a cycle (which you can't) you have to wait 10^9 seconds to get your answer.
16:33:07 <CyberTNT> yep
16:33:16 <CyberTNT> but i dont know how to leave some numbers out
16:33:21 <Igloo> Assuming the answer is there are none
16:33:37 <jlouis> ah yes, I forgot
16:34:49 <jlouis> 10^9 is still about 17 years
16:35:12 <jlouis> So even given you have to search only 1% of the space, you are in for something
16:35:20 <CyberTNT> lol yes
16:35:40 <jlouis> and this is still assuming that you can test things in one cycle, which you cannot
16:36:03 <jlouis> My bet: You need a better algorithm
16:36:40 <stepcut> CyberTNT: two dozen short lessons in haskell has code for reversing integers i think
16:37:06 <Igloo> You can reduce it to a touch over 10^9 cases rather than 10^18 by constructing palindromes rather than filtering all numbers for palindromes
16:37:38 <CyberTNT> stepcut and how?
16:37:55 <CyberTNT> Igloo yes the problem is read doesnt work for something as big as 10^18
16:38:27 <Cale> CyberTNT: how many of them do you need?
16:38:28 <Igloo> That's not a problem if you do the above. Anyway, read ought to work fine
16:38:49 <CyberTNT> Cale the highest
16:38:51 <Igloo> Prelude> read "1000000000000000000" :: Integer
16:38:51 <Igloo> 1000000000000000000
16:39:21 <CyberTNT> User> read "1000000000000000000"
16:39:23 <CyberTNT> ERROR - Unresolved overloading
16:39:23 <CyberTNT> *** Type       : Read a => a
16:39:23 <CyberTNT> *** Expression : read "1000000000000000000"   
16:39:38 <CyberTNT> oh ups
16:39:40 <CyberTNT> yes
16:41:05 <Cale> um. 999999999999999999
16:41:24 <CyberTNT> Cale yes but that doesnt divide by some of the primes
16:41:31 <Cale> oh, needs all
16:41:40 <CyberTNT> indeed
16:43:14 <Cale> since 2 and 5 both divide it, it ends in a 0.
16:44:49 <jlouis> 999999999999999999: 3 3 3 3 7 11 13 19 37 52579 333667
16:44:57 <jlouis>  /usr/games/factor good
16:45:14 <mgoetze> i wrote a haskell program to do that...
16:45:43 <mgoetze> in fact you should be able to get it at http://www.mgoetze.net/~mgoetze/prime.hs
16:46:16 <Igloo> For palindromes ending in 0 you need more than just show
16:46:28 <Cale> yeah
16:49:03 <jlouis> multiples num max=  [num,num+num..max], what kind of syntactic sugar gets applied here?
16:49:26 <Cale> You can just reduce your test to divisibility by 6469693230
16:49:40 <Igloo> fromThenTo num (num+num) max   IIRC
16:54:36 <ozone> enumFromThenTo, iirc
16:56:51 <Cale> oh
16:58:50 <Cale> 99999999999999999 mod 6469693230 = 2636643909. So you should start your search with 99999999999999999 - 2636643909, and drop by 6469693230 each step.
17:01:12 <Cale> hmm, how to make it faster though - this is still going to take a long time.
17:03:32 <Cale> oops bug, got: 682663980999999999999990893662860 :)
17:03:57 <Pseudonym> Cale: You're not doing division on an old Pentium, are you?
17:04:03 <Cale> hehe
17:08:58 <themaximus> good nigt
17:55:51 <DeezNuts> sup kidz
17:56:07 * DeezNuts waves his gun in the air
17:58:43 <Etaoin> your gun?
18:00:28 <DeezNuts> its a watergun
18:00:29 <DeezNuts> i hate guns
18:00:46 * DeezNuts squirts Etaoin with nuts juice
18:00:52 <DeezNuts> its just water dont worry
18:00:55 <DeezNuts> i hate nut juice
18:02:19 <DeezNuts> sorry for all the vulgar allusions
18:02:34 * DeezNuts just got done bustn' one
18:10:19 <flippo> Someone has been up too late
18:12:09 <swisscheese> Hi all. Can someone point me to a URL showing a simple hash algorithm in H?
18:14:58 <DeezNuts> heh
18:15:17 <DeezNuts> flippo: :p no way im just bustin' ill shit left and right
18:15:21 <DeezNuts> swisscheese: nope
18:15:28 <DeezNuts> swisscheese: can you show me one?
18:16:48 <flippo> DeezNuts: that was my other guess
18:18:28 <DeezNuts> lol
18:18:48 <Cale> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/haskell-md5-0.1.5/MD5.lhs
18:19:00 <DeezNuts> ahh, of course Cale comes through
18:19:12 <DeezNuts> (psst, he knows everything, and has a link to back up each thing)
18:20:04 <Cale> Actually, it's Igloo that you should thank -- seems that he wrote it
18:20:11 <swisscheese> Thanks Cale.
18:20:12 <Cale> :)
18:20:50 <DeezNuts> ahh yes Cale, there's some Maaagical Igloo that writes examples of hash algorithms in Haskell and posts them online for all to see!
18:21:22 <Cale> Yeah, it's Igloo in this channel.
18:21:40 <DeezNuts> Cale: dude its a joke from the simpsons ;-)
18:21:46 <Cale> ahh
18:21:48 <Cale> heh
18:22:03 <DeezNuts> Cale: lisa tells homer that sausages, bacon, ham, etc all come from the same animal (namely, a pig)
18:22:14 <Cale> oh, right - I remember that
18:22:29 * DeezNuts doesn't own a TV :)
18:22:33 <DeezNuts> ya that was mad old
18:22:47 <Cale> yeah, I almost never watch TV anymore
18:22:59 <DeezNuts> i wish i had a tv so I could watch terrance and phillip and CSPAN-1 and 2
18:23:01 <DeezNuts> good!
18:23:08 <DeezNuts> tv is ... lucifers anvil
18:25:35 <DeezNuts> it is
18:25:37 <DeezNuts> really
18:26:26 * DeezNuts slows sips the mocha his gf made for him mmmmm
18:26:37 <DeezNuts> *slowly
18:26:38 <DeezNuts> doh
18:26:46 <swisscheese> Hmmm - URL does not seem to answer what I need. How can I take a list of values like 2,3,6 and generate a list like [0,1,1,0,0,1].
18:27:58 <swisscheese> Seems H makes everything hard before it makes it easy ;-)
18:29:04 <Cale> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/hashtable/
18:31:17 <swisscheese> Thanks.
18:33:08 <DeezNuts> Cale: I know you would have a link for this: a reference page for the ascii equivalents for traditional math syntax
18:33:23 <Cale> ascii isn't terribly extensive
18:33:30 <DeezNuts> i know
18:33:30 <DeezNuts> but
18:33:33 <DeezNuts> we have to have some way
18:33:40 <DeezNuts> so whatever way we have agreed upon
18:36:02 * Pseudonym mmms... nut juice
18:36:10 <Pseudonym> Well, Amaretto, anyway.
18:37:03 <DeezNuts> lol
18:37:38 <DeezNuts> hehe
18:37:46 <DeezNuts> man sauce
18:37:48 <DeezNuts> hehehe
18:37:51 <DeezNuts> i said sauce
18:38:34 * DeezNuts wonders if anyone notices his subversive ploy to destroy Haskell by lowering the standard of conversation
18:39:13 --- mode: mgoetze set +q DeezNuts!*@*
18:39:17 <mgoetze> for haskell!
18:39:48 <mgoetze> ok, that was fun...
18:39:56 --- mode: mgoetze set -q DeezNuts!*@*
18:39:58 <DeezNuts> I   CAN'T    BREATH  !!!
18:40:00 <DeezNuts> ahhh
18:40:03 * DeezNuts wipes his brow
18:40:20 <DeezNuts> damn next time warn me before you near choke me to death!
18:40:36 --- mode: mgoetze set +o mgoetze
18:40:39 <mgoetze> like that? ;)
18:40:43 <DeezNuts> lol uhh
18:40:47 <mgoetze> hehe
18:40:48 <DeezNuts> close ? ;)
18:40:52 --- mode: mgoetze set -o mgoetze
18:41:00 * DeezNuts keeps his raunchy mouth shut
18:41:16 * DeezNuts goes over to the corner and pets the Haskell statue
18:41:21 <DeezNuts> niiice lambda
18:41:23 <DeezNuts> niiiice lambda
18:41:26 <mgoetze> good boy :)
18:41:30 <DeezNuts> hehe
23:45:54 <earthy> seems I'm glad DeezNuts is not active at times I am. now we can keep conversation at a reasonable level.
23:46:13 * earthy goes back to playing with CPS and monads
