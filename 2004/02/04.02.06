00:00:02 <Yosomono> phew, finally finished the gentle intro
00:00:18 * Darius should add backwards state to Scheme using the ideas from "Representing Monads".
00:00:24 <shapr> Yosomono: see, I call it the brickbat intro, but you know I couldn't tell you that beforehand ;-)
00:00:46 <Pseudonym> shapr: A table mapping word -> message id would allow for full-text searching.
00:00:47 <shapr> but seriously, what sort of practical code do you want to see?
00:01:02 <Pseudonym> The only problem is that it could easily get out of sync.
00:01:07 <Yosomono> shapr: give me some time to catch my breath here, i've just been thoroughly raped by that intro
00:01:10 <Darius> It's relatively short, yet pretty comprehensive despite that so it's somewhat compact.
00:01:16 <Pseudonym> (Which is why you need a real text index.)
00:01:23 <shapr> I know postgres allows fulltext searching with where msg_body like '%word%'
00:01:37 <Pseudonym> Yes, but it probably greps the whole table.
00:02:11 <shapr> I think explicit indexing of the msg_body column makes that much faster
00:02:24 <shapr> I wonder if that's the auxiliary table
00:03:37 <Maddas> Yosomono: haha
00:04:24 <Yosomono> Maddas: Near the end, I just went somewhere safe in my head and let it have its way with me.
00:04:30 <shapr> well, I'll try it and see how painful it is...
00:04:35 <Darius> Slide!
00:04:59 <Maddas> Yosomono: haha, I know exactly how you feel
00:05:03 <shapr> I hope I can run it on my 600MHz colo box without killing it.
00:05:11 <Maddas> Concurrency in Alice looks interesting
00:05:14 <shapr> Pseudonym: anyways, seen HaskellDB yet?
00:05:40 <Darius> So shapr, Pseudonym, what should go into the Rough Introduction to Haskell?
00:06:12 <shapr> I think the rough intro should start with the HaskellDemo file I wrote, and should be loadable into ghci
00:06:44 <Maddas> "Let us start with monads!"
00:07:00 <Maddas> ("since everything elf is self-explanatory")
00:07:02 <Maddas> else, even
00:07:03 <Darius> Maddas: Pssh, monads were covered in the Gentle one.
00:07:04 <Pseudonym> How rough should it be?
00:07:14 <Maddas> Darius: hm, dang.
00:07:29 <Pseudonym> I think we should start by lifting the user up by the collars and threatening them if they don't use Haskell.
00:07:44 <shapr> what about a tutorial that is loaded into hugs or ghci?
00:07:52 <Darius> Pseudonym: Well, if the reader is choosing to read "The Rough Introduction" ...
00:08:39 <Darius> We can break legs, but not arms.
00:09:13 <shapr> for me, I always want to play with the code interactively to see how I can change its behaviour
00:09:22 <Darius> Heck, breaking legs may even help; they'll have nothing better to do but code in that case.
00:09:27 <Yosomono> shapr: You know, I think reading the Tour of Syntax is easier to digest.
00:09:28 <shapr> hah
00:09:34 <shapr> Yosomono: where's that?
00:09:57 <Yosomono> the haskell.org learning page, reference section
00:10:07 <shapr> Yosomono: I think the gentle intro will be more valuable to you when you start to write your own Haskell programs.
00:10:56 <Yosomono> You should rename it the Gentile intro, because it is in fact akin to having your $#%& sliced up...
00:11:21 <Maddas> brain?
00:11:25 <Yosomono> But now I'm just being a smartass.
00:11:53 <shapr> I think I'll try using WASH's MIME splitter.
00:12:20 <shapr> it's funny, Oleg was saying that one downside of WASH is that it's in heavy development, that it changes too fast.
00:12:53 <shapr> and I was thinking it's one of the few haskell libs with a passable amount of development.
00:13:51 <Pseudonym> That's 'cause all the others are perfect.
00:14:01 <shapr> ah :-)
00:15:25 <Pseudonym> Gotta go home.
00:15:34 <Pseudonym> Meeting my cousin for lunch tomorrow and I have to cook.
00:15:42 <shapr> have fun
00:15:42 <Pseudonym> (It's a picnic, but have to take stuff.)
00:16:11 <Pseudonym> He's actually just got the unenviable job of producing the Australian version of "Queer Eye for the Straight Guy".
00:16:17 * Pseudonym shudders
00:16:19 <shapr> sounds cool :-)
00:16:40 <shapr> I wish mailman archives had a deterministic name for each email, either the id, or the year/month/day or something
00:17:00 <shapr> then I could just return urls to the mailman archives on haskell.org
00:17:18 <Pseudonym> Anyway, nytol.
00:17:25 <shapr> number since beginning is workable, I guess.
00:17:32 <shapr> means I have to leave the spam in though :-P
00:20:39 * Maddas starts another attempt to grok Monads
00:31:16 <shapr> Darius: what would you want in a rough tutorial?
00:34:25 <Darius> Things that are scary, but aren't completely artificial.
00:35:00 <shapr> like what?
00:36:15 <Darius> Like "The Evolution of a Haskell Programmer", but applied.
00:36:23 <shapr> I like that idea.
00:37:02 <shapr> I think it's easy to explain the concepts in Haskell, I think that's even done well. I think what's missing is "how to solve problems with haskell"
00:38:02 <shapr> for example, the functional modeling examples on WardsWiki were helpful to me.
00:42:19 <shurik> if I could only find a good source of info on Haskell types with several examples
00:42:36 <shapr> there's us, what are you looking for?
00:42:56 <shurik> what do yo mean what I'm looking for?
00:43:02 <shurik> for a file with information on types
00:43:22 <shapr> that's not specific enough for me to give you an answer.
00:43:36 <shapr> type systems like Hindely-Milner?
00:43:41 <shapr> simple typed lambda calculus?
00:43:50 <shapr> how to write type signatures?
00:43:55 <shurik> types are usied in haskell
00:44:07 <shapr> parameterized types? abstract types? rank-2 types?
00:44:17 <shurik> yhou silly
00:44:40 <shurik> do I hape to type it in French ?
00:44:44 <shapr> what do you know about Haskell so far?
00:44:48 <shapr> non merci, pas de probleme
00:44:56 <shapr> men svensa skulle bli kul
00:45:55 <shurik> types in general I've been learning Haskell for about 4 hours altogethe
00:46:05 <shapr> aha
00:46:06 <shapr> that helps
00:46:09 <shurik> where's you common snese , funny fellow
00:46:24 <shapr> have you seen http://www.scannedinavian.org/AvianWiki/HaskellDemo ?
00:46:39 <shapr> have you used statically typed languages before?
00:46:50 <Darius> shurik: "types in general" is an extremely wide domain.
00:47:26 <shapr> some people write very large books on type systems, and then complain that those books can only cover a small part of the subject.
00:47:35 <shurik> it's covered 2/3 chapters in Thompson's book, isn't it?
00:47:54 <shapr> not all of it
00:48:08 <shurik> well, C/Java/C++ faimilar with their staatic types
00:50:15 <shapr> so, do you know why people use static types? do you know how they can help you?
00:51:21 <shurik> you are defintaely a funny man:>
00:51:33 <shurik> let me find an answer for you on goofle:>
00:51:41 <shurik> google rather
00:51:59 <shapr> goof can mean a funny person in english, so it was a good joke.
00:52:33 <shurik> let's see, to spend hours of getting the tyyping right before thee program compiles?
00:52:47 <shapr> oh, that's what's you want to change
00:52:58 <shurik> here a question for do you know why Perl/Python became very popular?
00:53:03 <shapr> yes, I know why :-)
00:53:26 <Maddas> shurik: Types are your friend
00:53:33 <shapr> did you know that Python is strongly typed also?
00:54:27 <shurik> now I'm thinking someone is chatting out of his sphincter
00:54:43 <shapr> >>> 1 + ''
00:54:44 <shapr> Traceback (most recent call last):
00:54:44 <shapr>   File "<stdin>", line 1, in ?
00:54:44 <shapr> TypeError: unsupported operand type(s) for +: 'int' and 'str'
00:54:48 <Darius> shurik: It doesn't seem to be because of dynamic typing if that's what you are implying as there are more C/C++/Java/COBOL/FORTRAN etc. programmers than Python and Perl programmers.
00:54:54 <shapr> see, it says TypeError
00:55:21 <Darius> And those statically typed languages have -horrible- type systems.
00:55:31 <shurik> I didn't imply Python?perl are more popular than C/C++/Java
00:56:11 <shapr> :-(
00:56:17 <shapr> I didn't mean to drive him off
00:56:26 * shapr will try to be more tactful in the future
00:56:35 <Darius> How do you know it was you
00:56:45 <shapr> that's a good point
01:37:57 <shapr> hey, quick poll
01:38:13 <shapr> anyone has changes they want to file for lambdabot before the 2.0 release?
01:38:46 <shapr> if not, I'm going to create a tarball from the latest darcs repo and stick it online
02:00:02 <shapr> hej phubuh`
02:00:10 <liiwi> Morjens
02:01:02 <shapr> hei liiwi 
02:01:21 <phubuh`> hej hej shrimpx
02:01:24 <phubuh`> err.
02:01:32 <Maddas> heh
02:01:38 <phubuh`> hej shapr, also :-)
02:01:55 * phubuh` can't write swedish characters from PuTTY
02:04:21 <liiwi> set your locales etc
02:06:08 <shapr> ok, time for work
02:06:10 <shapr> bbl
02:47:43 <earthy> once more I learn that editing for the most part consists of deleting
03:22:46 <Darius> ee! (because d is left)
03:23:02 <Darius> (and d is e)
03:36:37 <blackdog> Pseudonym: dammit, why couldn't you have made the "Queer Eye for the Straight Guy" comment when an australian was around? You missed out on all the "Rule Three: No poofters!" jokes...
03:47:48 * clausen likes QE, and is from .au
03:52:31 <blackdog> Sure. I just like the opportunity to work on my Bruce impersonation.
03:52:56 <clausen> hehe
03:56:59 <earthy> rule six: there is *no* rule six.
04:16:21 <earthy> whee! `in order to be able to'
04:16:30 * earthy hacks 'n slashes
04:16:45 <Maddas> err...
04:16:50 * Maddas runs for cover
04:17:06 <earthy> and leaves 'to'
04:20:54 <blackdog> that's the way. strike with the scythe, clean up with the scalpel
04:21:11 <blackdog> what're you writing, earthy?
04:23:08 * earthy is editing part of the course notes for the programming and correctness course we're teaching this period
04:30:11 <Jerub> earthy: got any notes on writing good course notes?
04:30:16 <earthy> nope
04:30:18 <earthy> why? :)
04:30:33 <Jerub> earthy: I run a 4 session crash course on programming once a year (13-17 year olds).
04:30:59 <Jerub> its getting better, but I really need it reletively top notch in order to be effective.
04:31:12 <earthy> (other than: 1. be entertaining. 2. be precise. 3. be clear. 4. make sure you have a *good* course-outline)
04:31:25 <earthy> 4 sessions. damn, that's little
04:31:35 <Jerub> yeah, its on a camp.
04:32:00 <earthy> we schedule rougly 15 sessions of 2h30m to get basic programming into the brains of our 12-15 year olds
04:32:28 <earthy> ofcourse that is with one week between two sessions
04:32:33 <Jerub> My goals aren't to teach programming, they're more to give a positive taste of whats possible with programming.
04:32:43 <Jerub> ;)
04:33:51 * earthy nods
04:34:00 <earthy> you want to look into scripting ;)
04:34:55 <earthy> and you want to have the clear goal that it's no biggie if after the course the kids don't ever program anything
04:35:09 <earthy> as long as they've `seen the light' in that it is a powerful tool
04:35:43 <Jerub> oh, we do python ;)
04:35:58 <earthy> I guessed you might :)
04:36:12 <Jerub> we've been through many many languages over the years.
04:36:16 <earthy> and you do pygame-like stuff, right? :)
04:36:21 <Jerub> tcl/tk, smalltalk, pascal, C, php.
04:36:24 * earthy nods
04:36:25 <Jerub> earthy: yep!
04:36:35 <earthy> we do exactly the same ;)
04:37:03 <earthy> though I'm thinking of hooking some of the brighter kids on Haskell
04:37:08 <earthy> with HOpenGL :)
04:42:50 <earthy> then again, we don't really supply coursenotes for that `course'
04:46:34 <Jerub> ;)
04:47:03 <Jerub> if any kid seems to be getting too far ahead, I blow their mind with list comprehensions, map/filter/reduce and lambda functions.
04:47:57 <Maddas> earthy: heh, isn't Haskell a bit too hard for the kids?
04:50:34 <Darius> Why would Haskell be hard?  They wouldn't be messed up by years of imperative programming?
04:50:34 <earthy> nope. why.
04:50:57 <Maddas> Darius: I don't know, I'm asking.
04:51:00 <earthy> I learned programming with Basic, Pascal and Logo intermingled
04:51:30 <earthy> and I *still* value having learned how to do stuff well in Logo
04:51:52 * Darius wrote absolutely horrid BASIC, then moved on to C/C++ mish-mash, then some solid C++ with x86 assembly, Java, Prolog and others along the way.
04:52:12 <Maddas> Darius: I would think that Monads are a bit hard, but maybe it's just me.
04:52:26 <Darius> It's just you and a few others.
04:52:42 <Maddas> Ok
04:52:49 <earthy> monads are a bit hard
04:53:03 <Darius> Though ironically, for those experienced with imperative programming it should be more comfortable.
04:53:08 <earthy> but you don't have to deal with explaining them initially
05:15:06 <shapr> hi Arnia
05:37:17 <ham[nwn]> hiho
05:37:25 <shapr> darcs!
05:37:33 <shapr> um
05:37:36 <shapr> hiham!
05:37:50 <ham[nwn]> :)
05:38:06 <ham[nwn]> that darcs sounds as if you had torette ;)
05:38:22 <shapr> heh
05:38:26 <shapr> not that I'm aware of...
05:38:31 <ham[nwn]> :)
06:02:58 <earthy> Tourette's syndrom, not torette
06:03:15 <phubuh> syndrome, not syndrom
06:03:17 <phubuh> :-P
06:03:23 * earthy nods
06:03:41 * earthy was confused by the dutch `syndroom'
06:17:30 * shapr is just confused
06:59:19 <ski> hi frevidar
07:01:41 <ski> got any haskell questions ?
07:02:17 <frevidar> hello ski.
07:02:22 <frevidar> I have actually.
07:02:27 <frevidar> well, kind of.
07:02:34 <ski> please tell :)
07:03:43 <frevidar> you see, in haskell, I know you can make a function, say "ford", with argument "colour", which could produce a complex data structure involving a car's make, model, number of wheels, cost etc, including colour.
07:04:22 <frevidar> so you could just use "ford red" to get a red ford, with all its details.
07:04:56 <ski> yes (if the ford function contains all that other info)
07:05:01 <frevidar> and if I say, wanted a list of these cars, I could just go [ford "red", ford "green", ford "blue"]
07:05:13 <earthy> yes
07:05:28 <frevidar> and I'd have a complex data structure with a lot of repeated data.
07:05:46 <ski> mm
07:05:52 <frevidar> however, the predefinition of the repeated data using the ford function saves a lot of typing.
07:05:55 <frevidar> which is good.
07:06:10 <ski> yes
07:06:23 <ski> (it might perhaps also be a gain in abstraction)
07:06:59 <frevidar> but what I was looking at was making a program where the user inputs a data structure like the one I just mentioned, which could contain a lot of repeated data, as above.
07:07:15 <frevidar> and I was thinking about what language the user should input this in.
07:08:01 <ski> what kind of user input do you have in mind
07:08:01 <frevidar> at first I thought XML, but I'm not sure how the above could be written in XML without extra repetition, or doing some post processing on the data.
07:08:46 <frevidar> the input is actually a tree describing QOS.
07:09:08 <ski> what's QOS ?
07:09:34 <frevidar> sorry, quality of service.
07:09:41 <frevidar> bandwidth management.
07:09:51 <ski> mhm
07:10:16 <SyntaxNinja> frevidar: FYI, "map ford ["red", "green", "blue"]" does the same thing :)
07:10:22 * earthy thinks about some stuff whats-his-name of lilo-fame did
07:11:17 <frevidar> like, for my net connection, I share it with my neighbour, 50/50. Then I share my half, 50/50. Then I allocate bandwidth flows for games, acks, interactive traffic, web and the rest of traffic.
07:11:35 <frevidar> I share my half 50/50 with my sister.
07:12:17 <frevidar> of course, whenever bandwidth isn't being used, by someone it is allocated to, it goes to someone else.
07:13:01 <earthy> ah, Werner Almesberger
07:13:04 <earthy> tcng
07:13:19 <frevidar> at the moment, I've got a bash script, with for loops in evals in for loops, and its quite a mess, and took me quite a while to debug, hence I wanted to make it a little more generic.
07:13:41 <frevidar> anyway, it'll have data structures like the one I described above.
07:13:55 <earthy> frevidar, do look into tcng
07:14:57 <frevidar> what I was wondering, is there a data definiton language that can describe the data structure like the ford one without unnessacary repetition, or am I better off getting my users just to write their structures in haskell?
07:15:17 <frevidar> that would require them to be compiled and what not, which I felt was a little awkward.
07:16:13 <frevidar> earthy: I am using 'tc'. My script spits out a bunch of tc commands.]
07:16:54 <frevidar> earthy: oh, tcng is different, I see now, I'll check it out.
07:19:31 * ski doesn't really know much about xml and related
07:20:32 <ski> figure i'll have to learn it some day ..
07:21:01 <ski> (well, that can wait, for the moment)
07:27:22 <cybermanco> ski
07:27:29 <cybermanco> is normal
07:27:45 <cybermanco> a function takes more than 1 hour to calc the result?
07:27:49 <ski> cybermanco : sorry ?
07:27:58 <earthy> depends on the function
07:28:31 <ski> what is it supposed to do ?
07:28:52 <cybermanco> scale a bmp sotored in a quadtree
07:28:52 <ski> process massive amounts of data ??
07:28:57 <cybermanco> nop
07:29:13 <cybermanco> the bmp size is 196x96
07:29:19 <cybermanco> and the scale 3.5
07:29:20 <ski> have you tried with really small bmp's to begin with ?
07:29:26 <cybermanco> yes
07:29:38 <ski> 2 * 2 pixels, and such ?
07:29:51 <cybermanco> yes.. it runs slow but shows the result
07:29:57 <cybermanco> when I tryed with this
07:30:03 <ski> is that the ones that seems to be taking very long time ?
07:30:08 <cybermanco> I gived up after 1 hour..
07:36:28 <ski> hmm
07:37:00 <ski> it *could* be that your algorithm complexity is bad
07:37:12 <frevidar> cybermanco: are you using "!!"?
07:37:23 <cybermanco> frevidar: yes.. a lot
07:37:32 <ski> or it could be some error that causes it to loop sometimes
07:37:34 <frevidar> oh dear.
07:37:37 <cybermanco> and I am always changing type from float to int
07:37:46 <ski> cybermanco : like you would on an array ?
07:37:51 <frevidar> !! takes a long time.
07:38:07 <cybermanco> ski: yes
07:38:09 <frevidar> lists at not for random access.
07:38:19 <frevidar> don't use !! on them.
07:38:22 <cybermanco> hm
07:38:33 <frevidar> if you need to use !!, you need to use something other than lists.
07:38:45 <frevidar> if you know the size in advance, use an array.
07:39:03 <cybermanco> array?
07:39:11 <cybermanco> how?
07:39:15 <cybermanco> I know the size,,
07:39:26 <frevidar> yeah, you'll have to "import Array" from memory.
07:39:31 <frevidar> look at the Array module.
07:39:36 <cybermanco> ok
07:39:47 <frevidar> don't use !! though.
07:39:55 <cybermanco> hm.. how do I look at the Array module?
07:39:59 <cybermanco> where is it?
07:40:05 <frevidar> the haskell docs.
07:40:09 <frevidar> www.haskell.org
07:40:32 <frevidar> if you're just blowing a bitmap up, you shouldn't need to use !! though.
07:42:25 <shapr> frevidar: your users wouldn't necessarily have to compile their datastructures, you could cheeze by with read
07:42:35 <ski> cybermanco : were you using hugs ?
07:42:40 <cybermanco> ghc
07:42:44 <ski> ok
07:43:06 <frevidar> shapr: you can 'read' raw haskell code?
07:43:39 <shapr> sure
07:43:48 <shapr> if it's a datastructure
07:43:49 <frevidar> I thought you could only 'read' raw data, not lamdba expressions and what not.
07:43:52 <ski> i think shapr meant : reading in data structures
07:44:11 <ski> frevidar : hmm, well. what do you think ghc does ?  ;)
07:44:36 <frevidar> shapr: it will be a data structure, but it might be described in terms of function.
07:44:45 <shapr> your earlier example was [ford "red",ford "blue"]
07:45:02 <frevidar> shapr: I could 'read' that?
07:45:14 <shapr> you could read ["red","blue"] easily
07:45:30 <shapr> also, you can define your type to be an instance of the Read typeclass
07:45:36 <shapr> that would let you do all sorts of nifty tricks.
07:46:00 * earthy nods
07:46:12 <earthy> the Read and Show typeclasses are mighty cool
07:46:41 <shapr> on the downside, you wouldn't get detailed error reporting from a simple Read instance
07:47:40 <frevidar> hmmm, its quite possible though, that "ford" is a user defined function though.
07:47:57 <earthy> so?
07:48:01 <shapr> instance Read DNA where read x = DNA (map read x :: [RNA])
07:48:23 <frevidar> but this tcng that earthy refered me to seemed to of already implimented what I was thinking of doing.
07:48:29 <earthy> represent function abstraction and application in your datastructure and map an evaluator over it.
07:48:32 <earthy> frevidar: :)
07:48:32 <frevidar> in a much more detailed way.
07:48:48 <earthy> Werner's been at it a tad longer than you have :)
07:48:48 <Maddas> to of?
07:48:55 <shapr> to have
07:49:00 <Maddas> oh, ok
07:49:22 <shapr> I think that's a britishism :)
07:49:22 <earthy> (I saw the first tcng stuff appear somewhere in 2002)
07:50:20 <shapr> frevidar: anyways, if you can come up with some more detailed examples, I'm sure I can scrape up a useful Read instances for you.
07:53:28 <frevidar> shapr: I'll have more of a think about it tommorrow. After I rewrite my tc script in tcng. No more 'eval "for I in..."'.
07:53:56 <shapr> ok
07:54:40 <shapr> the difference between data and code isn't as strong in Haskell as in other languages.
07:55:14 <shapr> lessee, value -> function -> monad -> arrow
07:55:22 <frevidar> shapr: its getting blurier all the time.
07:55:32 <ski> frevidar : were you doing all that evaling to be able to insert things into the code to eval ?
07:59:35 <frevidar> ski: the evaling was in a bash script. There's a for loop in there that iterates through a list, but the name of that list depends on the name of the variable in the for loop that encloses the inner for loop.
07:59:41 <frevidar> if that made any sence at all.
07:59:46 <frevidar> its a mess, really.
07:59:59 <frevidar> even after I've tried to clean it up.
08:00:12 <frevidar> which is what I get for trying to do it in bash.
08:03:38 <ski> i was wondering if it was similar to (lambda (x) (eval `(lambda (y) (+ ,x y))))
08:04:46 <ski> (i.e. using eval when sane scoping fits better)
08:05:28 <ski> hello daf
08:07:57 <shapr> dang, looks like Zope doesn't support xml-rpc introspection
08:09:07 <frevidar> ski: I'm not sure what you mean, but I'm off to bed, but you can have a look at the script/mess at http://www.users.on.net/cmead/shape
08:09:35 <ski> ok
08:19:20 <frevidar> wow, this tcng is pretty good.
08:19:37 <frevidar> I'm actually going to bed now, good night all, and thanks for the help.
08:19:53 <ski> good sleep
08:32:26 <cybermanco> night!
08:32:37 <cybermanco> here is 4:32 pm..
08:33:12 <ski> good night, cybermanco
08:33:26 <shapr> it's 17:33 here
08:34:31 * ski is eating an avocado
08:34:38 <ski> yumm !
08:58:50 <shapr> yum!
08:59:08 <cptchaos> hi!
08:59:15 <shapr> hi cptchaos, what's up?
08:59:46 <cptchaos> had my last lectures for this semester :-)
09:00:44 <shapr> cool
09:00:48 <shapr> time for a break then?
09:00:52 <shapr> hello nerdlor 
09:00:58 <nerdlor> hey shapr
09:02:11 <cptchaos> shapr: some Time, have to do some tests, and write a lot in Haskell
09:02:27 <shapr> that sounds like fun
09:03:53 <cptchaos> Coding in Haskell is Fun, indeed, tests not really
09:14:41 <SamB> cptchaos: maybe they are tests of taste?
09:15:53 <cptchaos> SamB: not planned jet, just Quantum Mechanics and Thermodynamic
09:16:05 <cptchaos> :-)
09:16:33 <SamB> don't you need a quantum computer for quantum mechanics simulations?
09:16:53 * SyntaxNinja has been having fun with tests for the last 1.5 days
09:17:14 <shapr> I hope they use release a dual gapped ring setup for quantum computers.
09:17:20 <cptchaos> SamB: I need pen and paper
09:17:28 <shapr> it'd be Two Ring complete.
09:17:34 <Igloo> They're going to appear at the top of my TODO list before long too
09:18:00 * shapr hears the steady solid tone of a flatlined joke
09:18:05 <shapr> SyntaxNinja: so, you like QC?
09:18:41 <SyntaxNinja> shapr: yeah :)
09:18:56 <shapr> is it better for testing signal functions?
09:19:02 <SyntaxNinja> shapr: yep
09:19:07 <SyntaxNinja> i'm about to send you an email about that actually
09:19:09 <shapr> spiffy!
09:19:13 <shapr> oh, neat
09:19:18 <SyntaxNinja> well, it might wait until I have more results...
09:19:29 <shapr> I've just been swapping emails with mrak about using QC to test GHC
09:19:40 <shapr> feel free to send me incomplete results
09:19:40 <Igloo> mrak?
09:20:03 <shapr> mrak is how Mark Wotton aka blackdog, signs his emails
09:20:57 <shapr> I think QC would be good for testing hslibs et al, as soon as it implements Heffalump's idea of saving failed cases for later repeatable static unit tests
09:21:01 <SamB> did he start by accident?
09:21:47 <shapr> I think so, but I also think he explained it to me after alcohol, so I could easily be wrong.
09:22:24 * SamB has an alias 'emasc' for emacs, but he doesn't think he uses it much anymore
09:22:45 <shapr> I'm afraid to ask if that's vi humor relating to emasculation.
09:23:46 <SamB> shapr: don't be. I don't even know what emasculation is, I just used to type that when I meant emacs by mistake
09:24:08 <shapr> you don't want to know what it is.
09:24:24 <SamB> I don't even think I want to know how to use vi
09:24:47 <shapr> vi has some advantages, but I think tramp cancels out most of them.
09:25:08 * ski usually writes worng. (it should be !)
09:25:45 <shapr> I like recursive humor. "I am *not* being defensive!"
09:27:04 * ski wonders if there's any non-left mutually recursive acronyms
09:28:23 <ski> does anyone know of a non-left recursive acronym ?
09:28:43 <shapr> what would one look like?
09:29:05 <SamB> how about mutually tail recursive?
09:29:22 <ski> that would satisfy it, yes
09:29:29 <SyntaxNinja> shapr: OK, you've got mail.
09:29:33 <shapr> yay
09:29:50 <ski> most recursive acronyms seem to be head-recursive  (that is prob a better word)
09:30:01 <shapr> SyntaxNinja: if you have ideas on how to do unit-test-first with quickcheck, I'm *very* interested in such things.
09:30:11 <ski> GNU, EINE, TWEI
09:30:16 <shapr> heyyy, Heffalump's QC extension would do it!
09:30:24 <SamB> actually, wait. I don't think you can have tail recursive acronyms.
09:30:36 <SamB> not without side effects, anyway
09:30:47 <ski> what ?
09:30:58 <shapr> because if the code didn't exist, the error would save the very first instance of the generated data for future tests!
09:30:59 <shapr> AHA!
09:31:05 * shapr moshes happily
09:31:11 <ski> SamB : you talking about linguistic side effects ?
09:31:23 <shapr> I've been trying to figure this out since I first read about QC.
09:31:24 <shapr> w00
09:31:39 <SyntaxNinja> shapr: I think you're going to like the stuff in that email, btw :)
09:31:46 <SyntaxNinja> shapr: but I have to go to lunch now, ttyl.
09:31:48 <shapr> w00
09:31:50 <shapr> ttyl
09:32:56 <ski> ttyl is ?
09:33:03 <SamB> well, since acronyms don't take arguments, a tail recursive acronym would evaluate to _|_
09:33:07 <Lemmih> talk to you later.
09:33:07 <shapr> 'talk to you later'
09:33:21 <ski> got it
09:36:10 <Lemmih> What's a quantum computer?
09:37:41 <shrimpx>           <computer> A type of computer which uses the ability of
09:37:41 <shrimpx>           quantum systems, such as a collection of atoms, to be in many
09:37:42 <shrimpx>           different states at once.
09:37:44 <shapr> it's a computer that exploits some unique properties of quantum entanglement
09:37:57 * liiwi starts excercising to get his arm mobility back
09:38:26 <shapr> liiwi: you're getting mouse elbow?
09:39:31 <liiwi> shapr: didn't I tell you? broke my collar bone few weeks ago
09:39:48 <shapr> I don't think you told me.
09:39:51 <shapr> what happened?
09:40:43 <liiwi> broke it in training
09:42:08 <liiwi> hrm, my cd collection takes only 6GB
09:42:20 <shapr> I haven't done enough exercise lately to break my fingernails, much less a bone.
09:42:23 <liiwi> 838 songs, 3,4 days
09:42:30 <shapr> liiwi: switch to FLAC
09:42:42 <liiwi> ogg -6 is good enough for me
09:42:47 <shapr> I require FLAC.
09:42:53 <liiwi> cannot make any difference between it and cd
09:42:58 <shapr> I can
09:43:13 <shapr> I now also require more hard drives, unsurprisingly :-/
09:43:53 <liiwi> I can imagine it, but when we tried blind tests with friends, there were plenty of mistakes.
09:44:12 <shapr> I haven't tried blind tests, that's a good idea.
09:44:26 <shapr> did you find anyone who could reliable find the difference?
09:44:50 <liiwi> we had 4 persons, nobody could
09:45:09 <liiwi> imagination is a powerful thing
09:45:15 <shapr> yes, it is.
09:45:46 <shapr> I gotta try blind testing myself later, should be interesting.
09:48:05 <liiwi> we had extension cable and tester with headphones in other room
09:50:52 <liiwi> http://ahp.autonet.ee/pussy_licking.jpg
10:14:09 * esap just wrote a function with type: 
10:14:50 * esap just wrote a function with type: (Functor f, Functor g) => (f a -> g a -> a) -> Rec f -> Rec g -> a
10:15:07 <shapr> %-)
10:15:17 <shapr> what do you do with that function?
10:15:20 <ski> what does it do ?
10:15:41 <ski> zip ?
10:15:45 <esap> It's a version of fold for two-argument functions
10:15:49 <shapr> oh
10:15:53 <shapr> that makes sense
10:16:08 <esap> outerN f x y = fold (\a -> fold (f a) y) x
10:16:47 <esap> I call it outerN because the implementation is so close to the outer thing  :-)
10:19:09 <shapr> hej tic 
10:19:46 <shapr> hoi Vincenz 
10:19:52 <shapr> hoe gaat het met jou?
10:20:09 <liiwi> it's all dutch to me
10:21:37 <shapr> jasonw: dude, you don't have mournblade anymore.
10:22:09 <ski> shapr : drakan ?
10:22:29 <shapr> draken?
10:22:37 <ski> the game
10:22:59 <ski> (wondered about 'mournblade')
10:23:04 <shapr> mournblade is from Michael Moorcock's books.
10:23:13 <shapr> specifically, Elric of Melnibonae
10:23:29 <ski> (hmm, but now, that i think of it, it was mourn bringer)
10:23:36 <shapr> his sword was called Stormbringer, but its brother sword was called mournblade.
10:24:04 <ski> is it fantasy books ??
10:24:12 <shapr> yes
10:24:56 <ski> i've read some fantasy ..
10:25:17 <shapr> I've read many fantasy books.
10:27:01 <ski> (Tolkien,C.S.Lewis,John White,Elizabeth Moon,Katharine Kerr,David Edding,Robert Jordan,Margaret Weis & Trazy Hickman, + prob some more)
10:27:17 <ski> which've you read ?
10:27:52 <shapr> it's a big list :-) I've also read Tolkien,Lewis, Moon, Kerr, Eddings, Jordan, Weis & Hickman
10:27:53 <Vincenz> hey shapr, goed, en met u?
10:28:11 <shapr> Vincenz: sleepy but conscious. have you decided to try Haskell yet? :-)
10:28:18 <Vincenz> nop
10:28:27 <shapr> my favorite fantasy author is Terry Pratchett
10:28:27 <Vincenz> I've been studying stroustrup's bible
10:28:38 <Vincenz> I'm starting a doctorate soon and it'll be mostly written in c++
10:28:44 <ski> shapr : ok :)
10:29:04 <ski> shapr : haven't tried Pratchett yet
10:29:27 <shapr> Terry Goodkind, Guy Gavriel Kay, Andre Norton, Edgar Rice Burroughs, Richard Cook, ...
10:29:33 <shapr> I'm sure I can think of lots more.
10:29:38 <ski> LeGuin ?
10:29:41 <shapr> yes
10:29:49 <shapr> Wizard of EarthSea was nice
10:29:52 <ski> not me (yet)
10:30:52 <ski> have you looked at Gaiman's work ?
10:31:27 <shapr> yes, I've read almost everything he's written, including comics.
10:31:29 <ski> (i.e. Sandman)
10:31:39 <shapr> his books are incredible
10:31:50 <shapr> I just read one a few days ago
10:31:57 <shapr> but I can't remember the name...
10:31:59 <shapr> it's upstairs
10:32:01 * shapr goes to look
10:32:10 <ski> mm, of the books i've just read stardust
10:32:22 <shapr> yes! that's it!
10:32:43 <ski> (i.e. i've not read any of his other books)
10:33:01 <shapr> Neverwhere is wonderful
10:33:40 <ski> I'm currently rereading Kerr
10:33:49 <shapr> have you read Tad Williams?
10:33:56 <ski> no
10:34:08 <ski> can't even remember a title of him
10:34:15 <shapr> he had really nice trilogy recently...
10:34:18 <shapr> can't remember the name though.
10:36:40 <shapr> hi stepcut 
10:36:44 <stepcut> hey
10:38:16 <ski> shapr : hmm, well. i've read quite a bit of Wendy and Richard Pini's Elfquest, also ..
10:38:41 <shapr> I haven't read all of it, but the parts I have read were memorable.
10:39:03 <shapr> I remember when what's his name overpowered door to get out of the filigree eggshell thingy.
10:40:14 <ski> shapr : my bro's made a site with info + some pics he did (in DeluxePaint,Amiga) some years ago. http://www.algonet.se/~dervak/ElfQuest/ElfQuest.html
10:40:43 <ski> Rayek, probably
10:42:00 <ski> shapr : you can look at the pics, if you want ..
10:43:32 <shapr> nice pix
10:44:14 <ski> hand-pixeled
10:47:59 * ski sighs
10:48:06 <shapr> ?
10:48:26 <ski> well
10:49:26 <ski> there won't be any more pics there now .....
10:49:46 <shapr> why not?
10:55:29 <raver> y0!
10:55:48 <shapr> y0 y0
10:56:32 <raver> hi shapr
10:56:34 <raver> :)
10:57:29 <raver> do you know any good manual for programming gtk2-haskell?
10:57:52 <shapr> from what I've seen, the gtk2hs docs suggest that you read the gtk2 docs for C
10:58:06 <raver> i see
10:58:22 <raver> ok i'will try that way
10:58:25 <raver> cheers
10:58:26 <raver> ;)
10:58:44 <shapr> I know that juhp wrote some neat stuff with the gtk2hs bindings
10:59:20 <shapr> http://www.haskell.org/hircules/ 
11:00:01 <shapr> he also wrote a simpler gtk2 network widget, but I can't find it at the moment.
11:02:03 <raver> wow
11:02:17 <raver> this info will be so useful...
11:32:54 <DrNerdware> Namaste!
11:32:56 <DrNerdware> http://www.badgas.co.uk/snowman_porn.html
11:33:40 <DrNerdware> oops...wrong chatroom...sorry
11:34:23 * ski shakes his head
12:13:33 <Maddas> Ah, cool, irssix is finally stable.
13:05:38 <esap> Hmm.. Someonw explain to me what a function with the following type does: (Functor f) => (c -> a -> f a) -> (f c -> c) -> ((a -> c1) -> c1) -> c -> c1. What's your interpretation?
13:07:10 * esap just implemented that.
13:15:44 <Maddas> hm
13:15:54 <ski> the ((a -> c1) -> c1) looks like CPS to me
13:15:59 <Maddas> shapr: Is there any lambadbot bundle I can download?
13:16:09 <esap> ski: yes, double negation.
13:18:15 <ski> esap : don't tell. let me think
13:18:50 <esap> ok
13:26:00 * Maddas pokes shapr 
13:29:37 <ski> esap : just checking, the function doesn't discard any info ?
13:29:47 <esap> ski: right.
13:30:07 * ski is thinking hard
13:31:00 * ski is thinking : how can we convert an 'a' into a 'c' ?
13:31:32 <ski> hmm
13:33:12 <esap> That's actually the tricky part of the implementation.
13:33:34 <esap> but I'm more interested in what would be a good use for that function.
13:33:52 <ski> esap : hmm, is mayhaps the c argument to to function duplicated ?
13:34:27 <ski> esap : first i will infer the function. then i can think about what good it might be .. ;)
13:34:49 <esap> I'm not sure, it's not easy to see from the implementation whether it's duplicated or not.
13:35:32 <esap> I think yes, but it's not done in a simple way.
13:36:04 <esap> I think inferring the implementation from that type might be quite hard.
13:36:20 <ski> (by discarded or duplicated, i of course mean : in *this* function. not if it might be in a function passed in from the outside as argument)
13:36:38 <ski> esap : i think i might be close ..
13:41:23 <ski> yay !
13:41:42 <esap> found it?
13:41:58 <ski> see the code under the link at bottom of http://www.mdstud.chalmers.se/~md9slj/
13:42:17 <ski> it typechecks
13:43:00 <ski> esap : see it ?
13:43:06 <esap> yes
13:43:23 <ski> does the code structure look similar to yours ?
13:43:39 <esap> very close, at least.
13:44:39 <ski> a_c will always use the c that is passed to foo, should that be so ?
13:44:52 <ski> sorry, "passed to bar"
13:45:09 <ski> hmm
13:45:29 <ski> oh, wait. bar is recursive, so c will still get differnt values
13:46:42 <esap> ok, let me paste my implementation. I think it's somewhat easier to analyze.
13:47:00 <ski> hmm, so we could probably think od a_d__d as a CPS computation yielding a
13:47:12 <ski> s/od/of/
13:47:23 <esap> I was actually surprised to see the CPS thing there when I wrote that.
13:47:24 <ski> esap : paste it or a link ?
13:47:36 <esap> well it's just two lines, I guess I can paste.
13:47:41 <ski> is it serious CPS ?
13:47:53 <ski> well, stupid question
13:48:05 <ski> of course depends on whether a_d__d is serious
13:48:29 <ski> esap : yes
13:48:45 <esap> new_function dtr ctr = ctr . fmap (new_function dtr ctr) . dtr  ; cross_function dtr ctr neg = new_function (\a -> new_function (dtr a) ctr) neg
13:49:43 <ski> is it two (toplevel) functions ?
13:49:47 <esap> yes.
13:49:51 <ski> ok
13:50:04 <ski> which one have the type ?
13:50:11 <esap> cross_function one.
13:50:20 <ski> ok
13:51:39 <esap> note that I've used the same scheme for cross_function that was in the outer thing in PreludeExts. And the new_function thing looks like an implementation of 'fold', but is not quite.
13:52:07 <esap> but still I'm not sure what the thing does :-)
13:52:57 <ski> esap : sorry i haven't looked at outer in PreludeExts (yet) :(
13:53:04 <esap> oh ok.
13:53:35 <esap> it's some kind of generalization of cartesian product.
13:54:21 <ski> hmm, new_function looks like a liftet version of a_c, methinks
13:54:47 <ski> not sure about cross_function >vs< foo
13:54:55 <ski> lifted
13:55:12 <esap> yea, your version is very close to mine.
13:56:10 <ski> hmm
13:56:59 <ski> ERROR "MysteriousType.hs":32 - Illegal Haskell 98 class constraint in inferred type
13:56:59 <ski> *** Expression : cross_function
13:57:00 <ski> *** Type       : (Functor ((->) a), Functor b) => (c -> a -> b a) -> (b c -> c) -> ((a -> d) -> d) -> c -> d
13:57:07 <ski> that looks bad
13:57:22 <esap> hmm.. interesting.
13:57:30 <ski> how can you pass (dtr a) to the inner new_function, in cross_function
13:57:32 <ski> ?
13:57:32 <esap> I don't get that error
13:57:46 <ski> it expects something of same type as dtr, yes ?
13:58:05 <ski> (you aren't doing polymorphic recursion, i guess)
13:58:24 <ski> hmm
13:58:34 <esap> hmm.. actually, it's possible I have accidentally used an instance of Functor ((->) a) :-)
13:58:55 <ski> (or perhaps dtr in new_function and cross_function is not of the "same" type)
14:00:42 <esap> well I expected them to be the same type.
14:01:14 <esap> but actually, it can instantiate 'a' in the second use of new_function.
14:02:11 <ski> hmm, are those two new_function calls in cross_function monomorphized to the same type, or not ?
14:02:34 <esap> I think not.
14:03:04 <ski> then ctr's and neg's is unified, right ?
14:03:14 <ski> ctr's and neg's *type*
14:03:35 <ski> (both are passed as 2nd args to new_function)
14:04:08 <esap> hmm..
14:04:37 <ski> oh, did you say they were *not* type-compatible calls ?
14:05:16 <esap> I guess the two uses of new_function have different type.
14:05:21 <ski> i somehow thought you said they was
14:05:37 <ski> ok, then i can continue
14:06:15 <esap> ok, I think I wasn't entirely clear, sorry about that.
14:07:26 <esap> ok, I tested it, yes, I think it used an instance of Functor ((->) a).  I didn't realize it was used...
14:07:59 <esap> from Control.Monad.Reader
14:09:44 <ski> hmm, doesn't that instance mean then that one call to fmap is the same as (.) ?
14:10:30 <esap> yes
14:10:32 <ski> probably the one arising from the outer new_function call ..
14:12:20 <esap> yes
14:12:41 <esap> that's why it looks like the CPS thing.
14:20:35 <esap> here's what I tried to do with it, I'm not any more sure it was what I got :-): I tried that new_function would be such generalization of fold that would create arbitrary functions.
14:20:56 <esap> by giving a destructor and a constructor, you would be able to create a function.
14:21:59 <esap> now, the cross_function idea was that I use the same mechanism as in 'outer' from PreludeExts to generate all 'combinations', but with the mapping function used would be the 'new_function' instead of fmap.
14:22:15 <esap> I mean, generate all pairs of values.
14:22:37 <esap> And from the type, it seemed it might actually do quite a bit more than I intended.
14:22:39 * ski is looking at the function ATM, will soon listen ..
14:28:47 <ski> esap : ok
14:29:17 <ski> i think i got a (hopefully) correct derivation from your function to mine :)
14:29:29 <esap> heh ok.
14:29:44 <ski> so, i think they are equal
14:30:08 <ski> but, letme check outer on the wiki
14:30:14 <esap> ok
14:33:31 <ski> (hmm, the type of outer looks a little like composition, i think)
14:34:07 <ski> well, f . g is the functor composition of f and g, right ?
14:34:14 <ski> :)
14:34:21 <esap> ski: functor?
14:34:32 <ski> cat. theory
14:34:37 <esap> ski: oh you mean in the type of outer, yes.
14:35:06 <esap> ski: outer (+) [1,2,3] [10,20,30] == [[11,21,31],[12,22,32],[13,23,33]]
14:35:57 <ski> wonder if one could write that type nicer with some kind of natural transformation notation (which i, btw, still has no intuition for)
14:36:49 <ski> hmm, i think i've actually used the technique with nested fmap's that way
14:37:04 <esap> hmm.. I guess that might be possible
14:37:22 <esap> at least the part after the 'f' argument.
14:37:32 <esap> if you curry the function
14:37:32 <ski> it was for a couple of test cases for a couple of variants of functions
14:39:35 <ski> something like
14:39:47 <ski> pam xs f = map f xs
14:40:38 <ski> tests = listOfPairOfFunctionsAndListOfTests `pam` \(f,tsts) ->
14:40:51 <ski>         tsts `pam` \tst ->
14:40:55 <ski>         f tst
14:42:16 <ski> (but it was more complicated, 'cuz the tested functions were higher-order, so i tested each of them with each one of a list of supplied helper-functions)
14:42:38 <ski> anyway, let me get back to outer and co.
14:43:42 <ski> hmm, ok
14:43:45 <esap> yea, if you flip fmap, then outer is actually easier to understand.
14:44:10 <ski> it almost looks like manually using >>=
14:44:17 <esap> yes.
14:44:26 <ski> that was the idea
14:45:14 <ski> (i of course could've used >>= and return for lists, but then would the final list be flattened, and it would be hard to see what belonged to what ..)
14:45:45 <ski> (and different variants of the functions had different number of testcases)
14:47:19 <ski> outer_product seems to remind even more of nat. transf. notation
14:47:43 <ski> (i.e. like eta :: f -> g  instead of eta_a :: f a -> g a  IIRC)
14:48:19 <esap> yes.
14:51:00 <ski> hmm, so (cross_function,new_function,dstr,cstr,neg) corresponds to (outer,fmap,f,y,x) ?
14:51:43 <esap> yes
14:52:02 <ski> why is new_function as it is ?
14:52:05 <esap> but note that the type of new_function is quite different from type of fmap.
14:52:19 <ski> hmm
14:52:21 <esap> it's based on the implementation of fold.
14:52:43 <esap> which is: fold f = f . fmap (fold f) . unIn  , where unIn (In x) = x
14:53:08 <esap> so new_function is basically the fold but with arbitrary function in place of 'unIn'.
14:54:09 <ski> hm, is that called anything whatever-morphism ?
14:54:20 <ski> hylo ? para ? zygo ?
14:54:31 <esap> I don't know.
14:55:00 * esap has heard those terms but I can't ever remember which one stands for which concept :-)
14:55:43 <esap> the fold itself is catamorphism, I think.
14:55:43 <ski> same here (except cata and ana, of course, and the more common category ones)
14:55:47 <ski> yes
14:57:33 <ski> hmm i think dtr is converting (possibly ana) to an intermediate structure, and ctr is consuming that intermediate (after recursive change) (so it is possibly a cata), hmmm ...
14:58:17 <ski> or something
14:58:45 <ski> (talking about dtr and ctr in new_function, here)
14:59:09 <esap> yes, that's the idea. It's destructing a recursive structure and constructing another based on the data obtained.
14:59:55 <ski> so dtr is constructing one layer of the intermediate, then ?
15:00:12 <esap> no, dtr is destructing.
15:00:47 <esap> you need to read the '.' from right to left.
15:00:52 <ski> hmm, well, it really sounds like the psi argument to ana, not an ana itself (as i said before)
15:01:50 <esap> yes, the new_function is kind of both ana and cata.
15:01:54 <ski> yes, i know, dtr may possibly destruct its a-input (e.g. by cata)
15:02:15 <ski> but it still sounds like a psi argument to ana
15:02:38 <ski> ana psi = In . map (ana psi) . psi    IIRC
15:02:54 <esap> yes, but psi there is destructing the structure.
15:03:08 <ski> (hm should be an out somewhere also)
15:03:58 <ski> yes, psi is possibly destructing it's input. but it construct a new layer for fmap to work on. do you agree ?
15:04:22 <esap> well it could do that, but often it just exposes the encapsulation.
15:04:33 <ski> ok, whatever
15:04:39 <ski> :)
15:05:30 <esap> The 'a' in (a -> f a) is the type of object being destructed.
15:06:26 <ski> but if it just exposes the layer, couldn't we just had constructed the type 'a' via Rec and just passed out as psi, always ?  (i.e. we really don't use the full power of ana)
15:06:32 <esap> it's important that the return type is 'f a', so that this enforces that 'f' represents the whole "level" of the recursion hierarchy.
15:06:37 <ski> esap : i agree ?
15:06:44 <ski> s/?/!/  :)
15:06:52 * ski laughs
15:07:20 <ski> yes
15:07:34 <esap> yes, I agree.
15:07:55 <ski> but psi might just as well do *real* work and construct that layer (instead of just exposing it)
15:08:23 <esap> true.
15:08:25 <ski> the mutatis mutandis, i think is true for new_function
15:09:39 * SamB is reminded of Jigsaw
15:09:49 <esap> There is a concept called 'mono-epi factorization'. I think new_function is kind of inverse of that.
15:10:04 <ski> SamB : some puzzle/game ?
15:10:42 <SamB> ski: its an IF
15:10:46 <ski> esap : i don't know it. feel like explaining it now ?
15:11:06 <ski> SamB : and what's an IF ? :)
15:11:24 <esap> ski: basically, there is a theorem that says that every function can be factored into two parts, where first one is epimorphism and the second part is a monomorphism.
15:11:45 <ski> hmm
15:12:10 <ski> (just in Set ? or any Category ?)
15:12:11 <esap> ski: I mean morphism, not function. I think it requires something from the category (products maybe?)
15:12:19 <ski> ok
15:12:35 <SamB> ski: a work of Interactive Fiction
15:12:57 <ski> so this would give us an intermediate object
15:13:32 <SamB> ski: also known as an adventure game
15:14:27 <ski> and in e.g. Set this would be perhaps some kind of minimal internal state ??
15:14:28 <esap> ski: yes, I think the important part there is that the morphism can be divided into a mono and an epi, because then you can rely on their properties.
15:14:50 <ski> SamB : aha, thanks
15:16:24 <esap> ski: but of course, an inverse of the factorization would be just composition of a constructor and a destructor.
15:17:07 <ski> hmm, so you mean that with new_function we get a mono and an epi (so must phi and psi be that, then ?) and construct them together (recursively) into a whole function ?
15:18:30 <ski> so the 'inverse' of new_function might be a way of splitting a -> b into a *functor* f and a -> f a and f b -> b ?
15:19:03 <ski> (which satisifies the correct diagram)
15:19:47 <esap> ski: yes. That's because type of constructors (I think) can be expressed as 'f b -> b' (and similarly for destructors)
15:19:48 <ski> (that sounds interesting :)
15:21:13 <esap> of course, I think new_function assumes some structure [the recursion hierarchy] from the data structure that is used to build the function, the epi-mono-factorization doesn't really do that, but I think it's a good assumption.
15:21:32 <ski> esap : isn't that type for operation on any algebra, and not just for an initial one (i.e. case:able constructor) ?
15:21:54 <esap> yes
15:22:01 <ski> s/assumption/starting-point/ ?
15:22:11 <esap> heh right.
15:22:52 <esap> anyway, I'm looking at it to be able to understand functions.
15:23:10 <esap> and how to build a programming language with powerful functions
15:23:13 * ski thinks this sounds quite interesting, though he doesn't know what it means (is good for) :)
15:23:39 <esap> I would use this to represent functions as data.
15:23:45 <ski> y'know .., that's pretty vague :)
15:24:31 <esap> a monomorphism is a constructor, and constructors can be represented simply as (primitive) tokens. epimorphisms are harder, but they should be dual to monomorphisms.
15:24:51 <ski> hmm
15:25:04 <ski> a monomorphism is a constructor ?
15:25:09 <ski> hm
15:25:18 <esap> monomorphism is basically an injective function.
15:25:23 <ski> inclusion
15:25:26 <ski> yes
15:26:04 <ski> we could have several mono's from a to b, right ?
15:26:20 <esap> yes.
15:27:00 <ski> or m0 : a -> c, and m1 : b -> c, such that they are overlapping
15:27:28 <esap> overlapping in c?
15:27:48 <ski> so we would disallow/not-use-that if we want mono = constr. ?
15:28:20 <esap> yes, but doesn't mono do that already?
15:28:21 <ski> a and b corresponding to conjoint subsets of c
15:28:45 <ski> do what ?
15:29:19 <ski> det : hi again
15:29:44 <esap> the definition of mono is: f(a) = f(b) => a = b, if I recall correctly.
15:30:08 <ski> f.a = f.b => a = b  (but whatever)
15:30:15 <esap> ok right
15:30:57 <det> ski: ;)
15:31:23 <ski> det : verry fast reboot ?
15:31:46 <ski> esap : hm, so what were you going to say ?
15:32:10 <esap> ski: I was saying that I think that condition requires that f is like a constructor.
15:32:33 * esap at least cannot think of any counter-examples.
15:32:36 <ski> i'm not sure
15:33:00 <Cale> a monomorphism is a homomorphism which is injective (1-1)
15:33:33 * ski would think that F-(initial-)algebra operation would be needed for "constructor feel"
15:33:53 <ski> Cale : yes
15:34:37 <ski> Cale : (for obj = structured set & morph = structure-preserving func.)
15:34:55 <Cale> yeah
15:36:10 <ski> hm
15:37:09 <esap> ski: ok, perhaps you're right. But the algebra also requires that there is some functor which represents a level of the hierarchy. If you just require mono, I think that requirement is lifted, but the morphism still (to me at least) seems to act like a constructor.
15:37:14 <ski> if we can have several mono's from a to b, if we get a point of b, which of the constructors is it built upon ?
15:38:03 <esap> ski: you don't necessarily know it [I didn't say you have pattern matching :-) ]
15:38:14 <ski> heh
15:39:10 <ski> which requirement would you lift ?  initiality ?
15:39:36 <esap> no, the fact that there is the functor.
15:39:44 <ski> ok
15:40:17 <ski> but isn't there a functor in new_function ?
15:40:31 <ski> or were we now talking about it's 'inverse' ?
15:40:34 * ski forgot
15:41:09 <esap> yes, that's because I went from mono to the ordinary notion of constructors (I didn't know how to represent mono in Haskell :-)
15:41:18 <ski> :)
15:42:31 <esap> but if I could represent the relationship between the return type of the first function and the argument type of the second function reasonably without using that functor, I would expect the same thing would work. [of course, fmap would be changed to something else)
15:43:13 <ski> ok, hmm
15:44:28 <esap> of course, ordinary composition is one approach, but I think it's not quite what I want.
15:44:38 <ski> esap : i hope you've notice that you have swapped ctr and neg in cross_function with respect to x and y in outer
15:46:08 * esap is thinking.
15:46:19 <ski> (ordinary comp. of the mono and epi ?)
15:47:11 <ski> esap : i.e. no very big semantic difference, just top-level args swapped ..
15:47:19 <esap> oh right.
15:47:30 <ski> was it intended ?
15:48:05 <esap> yes, I rearranged that to make it more clear how the flow of data goes.
15:48:12 <ski> ok
15:48:17 <ski> just wondered
15:49:56 <esap> actually I'm not sure I got that correct :-)
15:50:35 <esap> it might still be somewhat odd order, I just looked from type and guessed at how it seems to be easy to understand.
15:50:48 <ski> esap : hmm, also : isn't the spelling "leftAdjoint" and "rightAdjoint"  (just picky)
15:52:25 <ski> hmmmm
15:52:53 <esap> hmm.. I think those mean different thing [e.g. in F -| G, F is leftAdjoint but the morphisms would be leftAdjunct [but I'm not expert on terminology there]
15:53:12 <ski> ok, may well be so.
15:53:53 <esap> I think the normal names for those are 'lad' and 'rad', but I thought nobody would understand those.
15:54:05 <ski> hmm, i think i still don't quite get all of the analogy with outer
15:54:19 <esap> what analogy?
15:54:26 <ski> esap : surely so :)
15:54:39 <ski> new_function as fmap
15:55:32 <esap> well try replace fmap with fold first, and you get a useful function. Then I guess it's easy step to go to new_function?
15:55:46 <ski> i just thought it seemed unsymmetrical to have f as dtr and y as ctr
15:56:12 <ski> ctr and dtr would appear to be symmetrical, yes ?
15:56:21 <ski> but f and y aren't
15:56:29 <ski> hm
15:57:21 <ski> cata phi = phi . fmap (cata phi) . out
15:57:31 <esap> about the symmetry thing, I didn't really consider it from that point of view. I chose the names because of the new_function arguments are basically constructors and destructors.
15:57:46 <ski> yes
15:58:16 <ski> but cross_functions's dtr isn't compatible with new_function's dtr
15:59:01 <esap> yes, you're right. I guess that's a good reason for not having the name like that. I actually missed the use of the ((->) a) instance there.
15:59:40 <ski> that naming, i think, was partly what was confusing me
16:00:18 * esap just changed it back to 'f', 'x' and 'y'.
16:01:31 <ski> cross_function f y x = new_function (\a -> new_function (f a) y) x
16:01:33 <ski> then ?
16:01:42 <esap> right.
16:02:40 <esap> the double-negation type thing is actually still kind of interesting.
16:02:47 <ski> yes
16:03:07 <ski> (yes, it looks more analogous to me now :)
16:04:03 <ski> hmm, so before x and y was "collections"
16:04:18 <esap> yes
16:04:37 <ski> now they are ...
16:04:39 <ski> hmm
16:04:43 <ski> ... what ?
16:05:05 <esap> well I think of x as a 'data store' :-)  and y as destructor.
16:05:14 <esap> no I mean y is constructor.
16:06:11 <ski> hmm, both y and x are sent as ctr
16:06:15 <esap> you can actually make ((a -> c) -> c) into a monad.
16:06:20 <ski> i know
16:07:08 <esap> oh hmm.. that's a good point.
16:07:34 <ski> esap : hmm, still intersting that d (your c1) is named in the type an odd number of times
16:08:40 <esap> why=
16:08:42 <ski> (but if we write ((a -> c) -> c) as CPS c a, we perhaps can get away with saying it's even :)
16:09:48 <esap> heh, I think it's the new_function that does that. Because the outer use of new_function has 'f c = (a -> c)'
16:10:00 <ski> well, hmm, if we discard an argument, then it often happens that the corresponding type variable is "odd"
16:11:17 <esap> ski: hmm.. interesting, I hadn't thought of it like that. But yes, I guess often that's the case. But new_function essentially 'encapsulates' f into the function it creates. I think that might cause a similar effect.
16:11:24 <ski> (this obviously doesn't hold for collections like list, and so on. but in type def of list, a is used multiple times)
16:11:44 <ski> yes, it might
16:11:58 <ski> some of the recursion is doing it, i think
16:12:22 <ski> (that was why i asked if some info was being discarded)
16:12:43 <esap> at least type information of 'f' is discarded :-)
16:13:13 <ski> hm
16:13:16 <esap> But I don't think at value level it translates to discarding anything
16:13:44 <ski> think of  bot = bot, it creates an odd typevariable
16:13:48 <ski> (recursion)
16:14:32 <ski> (otherwise, usually, there would be one more contravariant than covariant typevariable, for the odd one)
16:14:40 <esap> also 'fix :: (a -> a) -> a'
16:14:46 <ski> s/typevariable/typevariable occurance/
16:14:50 <ski> yes
16:14:58 <ski> good example :)
16:19:28 <ski> hmm
16:19:58 <ski> one dtr is f a, other is (\a -> new_function (f a) y)
16:21:13 <esap> right.
16:21:29 <ski> (\a -> new_function (f a) y) = (\a -> f a `new_function` y) = ((`new_function` y) . f)
16:21:57 <ski> hm
16:23:40 <ski> i think i might be happier if the two new_function calls were "aligned" at the same star^H^H^Htype, but perhaps it would be worng, then ...
16:24:36 <ski> hmm, well, the fmap's aren't, right ?
16:25:00 <esap> aren't what? aligned?
16:25:04 <ski> yes
16:25:21 <ski> inner takes an g b
16:25:28 <esap> right.
16:26:17 <ski> hm
16:26:41 <esap> Yes, I guess it might work better to flip one of the new_function calls.
16:27:14 <ski> at least look nicer/easier to read  (in this form)
16:29:37 <ski> (i.e flipping args to fmap/new_function. or were you speaking about other flip ?)
16:30:00 <esap> the inner new_function.
16:30:48 <ski> just the inner ?
16:31:35 <esap> yes.
16:32:15 <esap> But I guess I need to spend some time on thinking about this, it's not that clear to me what's correct/good idea.
16:32:22 <ski> you mean change the semantics ?
16:32:30 <esap> yes it would change the semantics.
16:32:52 <ski> (i was just talking of making fmap/new_function take its args in the other order)
16:33:02 <esap> oh
16:33:20 <esap> right.
16:33:35 <ski> or, rather, that's what i thought you were talking about
16:34:05 <esap> I think I was, but then I got a wild idea about making a minor change to the semantics :-)
16:34:58 <ski> ok :)
16:35:19 <esap> but I now not any more sure that would do any good.
16:35:37 <ski> well, i think i find it a little weird that we no longer have two different functors around
16:35:56 <ski> (one of the got instantated to (a ->))
16:36:22 <ski> can this really be "right" ?  (whatever that is :)
16:37:31 <ski> (it's possible though, that i'm thinking to close on outer)
16:37:32 <esap> which version are you talking about?
16:38:05 <ski> cross_function f y x = new_function (\a -> new_function (f a) y) x
16:38:10 <esap> ok.
16:38:19 <ski> your original (except naming)
16:39:34 <esap> yea, I think I would rather like a little more generic case there.
16:39:52 <ski> i guess i'm sorta trying to align the types of outer and flip . cross_function, to try to find how they relate
16:40:23 <ski> (possibly i should also think then how fmap and new_function relates)
16:40:49 <esap> yes. The fold step is quite interesting, I think.
16:41:22 <ski> hm, what's the type of new_function, btw ?
16:41:44 <esap> new_function :: (Functor f) => (a -> f a) -> (f c -> c) -> a -> c
16:43:27 <esap> that's btw, why I call it 'new_function' :-)
16:44:09 <cybermanco> hello
16:44:14 <ski> so, isn't new_function as much related to ana as to cata (fold) ?
16:44:19 <cybermanco> (sorry my bad english)
16:44:22 <ski> cybermanco : hi !
16:44:27 <esap> ski: yes.
16:44:48 <cybermanco> how do I know how long the function takes to cacl... in ghc
16:44:48 <ski> cybermanco : last time i checked, "hello" was correct english ;)
16:44:49 <cybermanco> ?
16:45:00 <ski> "cacl" ?
16:45:03 <cybermanco> calc
16:45:06 <ski> ok
16:45:24 <ski> you could time it, i guess
16:45:41 <ski> or, do you mean, *before* it has finished ?
16:46:27 <cybermanco> in hugs there was an option to know that
16:46:29 <cybermanco> I think
16:46:59 <esap> ski: I was about to say something about fold2 :: (Functor f, Functor g) => (f a -> g a -> a) -> Rec f -> Rec g -> a ; fold2 f x y = fold (\a -> fold (f a) y) x
16:47:00 <ski> and now you wonder in ghci ?
16:47:12 <cybermanco> yes
16:47:38 <ski> cybermanco : try ":set +s"
16:47:58 <cybermanco> yes.. thanks :)
16:48:02 <ski> ok, good
16:48:34 <ski> esap : i'm all eyes
16:49:22 <ski> cybermanco : i hope you know that you can type ":help" or ":?" in ghci
16:49:37 <esap> ski: that's in a sense an intermediate step between outer and the cross_function thing. Very close to it, but seems to do quite different operation.
16:50:15 <ski> hm\mmm...mm/mm/mm :)
16:50:41 <ski> (\ and / is sentence pronounciation frequency down and up)
16:51:09 * esap never understood english pronounciation.
16:51:25 * ski just invented that syntax
16:52:13 <ski> (and it's possible that this things means wildly different things is different languages (such as english and swedish))
16:54:32 <ski> so this fold2 is interesting, yes
16:55:09 <esap> yes, I think it is like ordinary fold but for two argument function.
16:55:30 <ski> so for this, we relate fold and fmap ...
16:56:03 <esap> right. And fold and new_function are obviously related.
16:56:32 <ski> still seems harder to do that properly for fmap (1 arg) and new_function (2 args)
16:56:39 <ski> hmm
16:56:43 <esap> actually, I just thought about: fold_func :: (Functor f) => (a -> f a) -> (f c -> f c -> c) -> a ; fold_func f g x y = new_function f (\a -> new_function f (g a) y) x
16:58:08 * esap doesn't have a good name for that yet.
16:58:26 <cybermanco> [00:49] <ski> cybermanco : i hope you know that you can type ":help" or ":?" in ghci
16:58:30 <cybermanco> I didn't know!
16:58:35 <ski> yes, (somethingA `new_function`) or (`new_function` somethingB) seems better somehow, i think
16:59:48 <ski> cybermanco : also in hugs, of course
17:00:02 <ski> what type has
17:00:03 <ski> fold_func' f g x y = (`new_function` f) (\a -> (`new_function` f) (g a) y) x
17:01:44 <esap> (Functor f) => (f (f a) -> f a) -> (a -> b -> f b) -> a -> b -> f a
17:02:36 * ski currently has some undefined's in his module
17:02:45 <ski> thanks
17:03:21 * esap looks at the clock, and it's 3am again. I think I'm going to get some sleep.
17:04:18 <ski> ERROR "MysteriousType.hs":180 - Type error in explicitly typed binding
17:04:18 <ski> *** Term           : fold_func
17:04:18 <ski> *** Type           : (a -> b a) -> (b c -> b c -> c) -> a -> a -> c
17:04:18 <ski> *** Does not match : (a -> b a) -> (b c -> b c -> c) -> a
17:04:19 <ski> *** Because        : unification would give infinite type
17:04:24 <ski> hmm
17:04:34 <ski> esap : ok
17:04:39 <esap> right, I misspelled it, fold_func :: (Functor f) => (a -> f a) -> (f c -> f c -> c) -> a -> a -> c is correct type.
17:05:36 <ski> anyway, the "guess the function" game was fun (and the after-thinking too)
17:05:57 <esap> yea, have to do that again sometimes.
17:06:17 <ski> so, good night then ?
17:06:19 * esap has lots of functions with cryptic types.
17:06:24 <ski> haha
17:06:26 <esap> good night. See you later.
17:06:32 <ski> sure
17:08:24 <ski> cryptic discussion is *over* !  start talking about normal things, *now* :
17:08:45 <Riastradh> 42
17:09:13 <ski> riemann's zeta function
17:10:14 <Riastradh> 5
17:11:07 <ski> "synergy"
17:11:17 <Riastradh> 23
17:12:17 <ski> Kant
17:13:23 <Riastradh> 0
17:14:40 <ski> Cosmic consciousness
17:14:46 <Riastradh> 2
17:15:16 <ski> Bill Crosby
17:15:29 <Riastradh> 1
17:16:03 <ski> Seafood
17:16:23 <Riastradh> 7
17:16:56 <ski> Bahai'ullah
17:17:28 <Riastradh> 59
17:17:36 <ski> Mount Pinatubo
17:17:55 <Riastradh> sqrt 5
17:17:56 <cybermanco> my ghc crashes..
17:18:29 <ski> The silver cord
17:18:35 <Riastradh> i
17:18:47 <ski> cybermanco : oh ? what did you do ?
17:18:59 <ski> Earth
17:19:16 <cybermanco> ski.. I tested my program
17:19:18 <Riastradh> sqrt (-i)
17:19:22 <cybermanco> for a big pic
17:19:25 <cybermanco> 1024x768
17:20:10 <cybermanco> ski: do you have ghc?
17:20:35 <ski> Kraken
17:20:52 <Riastradh> pi^e - e^pi
17:21:03 <cybermanco> kraken!
17:21:49 <ski> cybermanco : here, yes
17:22:04 <SamB> I wonder why there is no apparant way to make a function polymorphic over shapeness in FISh
17:23:08 <ski> the crawling chaos
17:23:36 <cybermanco> ski: can you please teste my program?
17:23:58 <ski> cybermanco : how big is it ?
17:24:06 <Riastradh> 1/0
17:24:12 <cybermanco> 1,1 MB
17:25:00 <ski> Riastradh : I give up !
17:25:09 <Riastradh>  Hah!
17:25:13 <ski> :)
17:26:01 <ski> (um, well, i've might have said Reticular Activating System)
17:26:16 <ski> (but, nevermind)
17:26:48 <ski> cybermanco : hmm, well. i guess i could perhaps try it out in /tmp
17:27:05 <Riastradh> Well, then I'd have just said 3.
17:27:09 <ski> cybermanco : (otherwise quota exceeded)
17:27:18 <cybermanco> 1.1 compressed..
17:27:36 <cybermanco> 9.16 not compressed
17:27:51 <ski> Riastradh : see !, i might just as well give up
17:27:58 <Riastradh> Indeed.
17:30:36 <ski> cybermanco : hmm, i'll give it a shot, then ..
17:30:43 <cybermanco> hm
17:30:47 <cybermanco> this is the error:
17:30:58 <cybermanco> before crash:
17:31:26 <cybermanco> internal error: RTS exhausted max heap size (268435456 bytes)
17:31:30 <ski> aha
17:31:32 <cybermanco> please report...
17:31:50 <ski> can't you increase max heap size ?
17:31:57 <cybermanco> I don't know..
17:32:01 <cybermanco> how
17:32:01 <cybermanco> '
17:32:03 <cybermanco> ?
17:32:04 <ski> (or try to optimise more)
17:32:21 <ski> have you stopped using !! ?
17:32:36 <cybermanco> in this case I don't use !!
17:32:44 <ski> (or am i confusing people ?)
17:32:48 <ski> no ?
17:32:56 <cybermanco> nop
17:33:14 <ski> so you've changed to arrays, then ?
17:33:23 <cybermanco> nop.. not yet
17:33:36 <cybermanco> but in this case.. I dont' need to use !!
17:33:51 <ski> (or tuples/separate-constructor-argumets, if they are small and size is known)
17:34:01 <ski> mhm ?
17:34:19 <cybermanco> how can I change heap size?
17:34:26 <ski> hmm, well
17:34:45 <ski> i suppose we *could* check at ghc's website ..
17:35:19 <ski> or shall we just randomly try out options ?
17:35:54 <cybermanco> I don't sse anything in options..
17:36:02 <cybermanco> I guess
17:37:10 <ski> hmm
17:38:07 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html, might be of interest
17:39:01 <ski> cybermanco : you're sure the lists or !! isn't causing your problem ?
17:40:34 <cybermanco> in this case no
17:41:18 <cybermanco> in this case is just because I suck coding in haskell :)
17:44:02 <ski> well, i guess it's hard to tell
17:44:38 <ski> "you sucking coding haskell" might make you use lists or !! in bad ways
17:47:04 <cybermanco> i used lists
17:47:07 <cybermanco> but not !!
17:47:31 <ski> well, it could perhaps be ok, and perhaps not
17:47:58 <ski> (you know !! doesn't use a predefined !!)
17:48:26 <ski> so you might still access or construct lists in bad ways :(
17:49:25 <cybermanco> hm
17:49:31 <ski> (bad means, could be done better. either with lists, or with other datastructure, like tree or array or hashtable)
17:49:38 <cybermanco> the only way I know how to construct lists is the recursive way
17:49:44 <ski> yes
17:50:18 <ski> you know that "foo ... = foo ... ++ ..." is bad, right ?
17:51:44 <ski> better to do something like "foo ... acc = foo ... (... (acc) ...)"
17:53:38 <Riastradh> Using [[x ++ [elt]]] is also a bad idea; instead, you should either build up a list in reverse and then reverse it or use the stack as your accumulator and write it in a non-tail-recursive manner.
17:54:43 <ski> cybermanco : hmm ?
17:55:21 <cybermanco> hm
17:55:48 <cybermanco> I only use ++ with strings
17:55:54 <ski> (c.l.f : "Just kill the worker and get on with it." :)
17:56:03 <ski> long strings ?
17:56:11 <cybermanco> nop
17:56:25 <ski> or just short ones for descriptions ?
17:56:59 <cybermanco> the only strings I use are the strings for show
17:57:19 <ski> should be ok, as long as they aren't long
17:58:01 <cybermanco> I am using func length
17:58:11 <cybermanco> in a list of 9 MB
17:58:21 <ski> which Prelude and List functions (working with lists) do you use ?            (is it very many ?)
17:58:31 <ski> ok, hm
18:08:15 <cybermanco> ski: you said to use array isntead of normal lists.. but for big arrays (length = 768432) its better anyway?
18:08:52 <ski> so, anyway, if you are going through (essentially) the same list over and over, just to modify it slightly, that's bad
18:09:09 <ski> what's better ?
18:09:14 <cybermanco> faster
18:10:21 <ski> better to use arrays than lists if one has 768432 or more elements, or better to use lists rather than arrays if 768432 or more elements ?
18:12:35 <cybermanco> better to use arrays than lists if they have a large number of elements
18:12:54 <ski> could well be, yes
18:14:04 <ski> (but if one is using lazy lists that are traversed once, and not actually kept in memory as a whole at any time, the lists can be preferrable, i think)
18:14:39 <cybermanco> I need to keep them in mem
18:14:45 <ski> ok
18:14:56 <cybermanco> because I am constantly checking some elems of the list
18:15:17 <ski> (example of this is like a unix filter)
18:15:29 <cybermanco> but i am still trying to understand how to use Array
18:15:38 <ski> ok
18:16:44 <ski> array :: Ix a => (a,a) -> [(a,b)] -> Array a b
18:16:54 <ski> that's one way to create an array
18:17:09 <ski> oh, hum
18:17:42 <ski> are you going to change these arrays in your program
18:18:03 <cybermanco> I will try
18:18:14 <ski> and if so, change them in small steps, incrementally, or change them much at a time
18:18:53 <ski> cybermanco : know that the arrays in module Array are immutable
18:19:17 <ski> i.e. it's costly to "change" such an array (it will probably get copied)
18:19:40 <cybermanco> hm
18:19:44 <ski> thus, don't change it often (i.e. change much in one go)
18:20:00 <cybermanco> ok
18:20:46 <ski> as an alternative, you might consider using IOArray or STArray  (this can be changed like ordinary imperative arrays, but only from within an appropriate monad (IO,ST))
18:21:27 <cybermanco> that's to much for me..
18:22:20 <ski> (ghc also provides DiffArray which feels like Array but is implemented roughly like [IO|ST]Array, provided that you use it single-theadedly. Then there's also unboxed versions of these for a couple of types. (and there's more :))
18:22:23 <ski> :)
18:22:57 <ski> i would suggest using either Array or [IO|ST]Array
18:24:51 * ski just hit an elbow-nerve
18:24:54 <ski> ouch
18:25:42 <cybermanco> the algorithm I am trying to do is this:for (i = 0; i < wf; i++)
18:25:42 <cybermanco> for (j = 0; j < hf; j++)
18:25:42 <cybermanco> buffer_final[j * wf + i] = buffer[(j / s) * w + (i / s)];
18:25:54 <cybermanco> where buffer_final is a list
18:25:59 <cybermanco> and buffer is being constructed
18:26:08 <cybermanco> hm
18:26:10 <cybermanco> nop
18:26:15 <cybermanco> buffer is a list
18:26:25 <cybermanco> and buffer_final is being cosntructed
18:27:08 <cybermanco> as you can see I am always acessing buffer
18:27:17 <ski> what's w ?
18:27:22 <cybermanco> width
18:27:28 <cybermanco> wf is widthfinal
18:27:58 <ski> so there's wf,hf *and* w ?
18:28:12 <cybermanco> yes..
18:28:23 <cybermanco> and wf = w * s
18:28:37 <ski> always ?
18:29:07 <cybermanco> yes.. wf is pre-calculated
18:29:12 <ski> hm
18:29:18 <ski> aha, ok
18:29:34 <cybermanco> this is a very simple scale function in c..
18:29:45 <cybermanco> but in haskell is a hell to do this!!!
18:29:58 <cybermanco> fast
18:30:10 <ski> why buffer_final[j * wf + i] and not buffer_final[j][i] ?
18:30:22 <ski> any reason ?
18:30:28 <cybermanco> yes..
18:30:54 <cybermanco> in c is the same thing.. I think
18:31:22 <ski> yes, probably. so why complicate the program more than necessary ?
18:31:25 <cybermanco> he needs to do this calc anyway
18:31:29 <cybermanco> nop
18:31:37 <cybermanco> because is more simples with just one pointee
18:31:41 <cybermanco> pointer
18:31:51 <ski> yes, so we might just as well let the compiler do it for us, right ?
18:32:23 <cybermanco> maybe
18:32:34 <ski> well, buffer_final doesn't have to be an array of pointers, in that case. it could be an array of arrays
18:32:57 <ski> probably same memory layout, but we don't have to have about it
18:33:09 <cybermanco> hm.. but in my haskell version
18:33:17 <cybermanco> I store it as array of array
18:33:22 <ski> ok
18:33:32 <cybermanco> getPixel (Bmp (h, w, b)) x y = (!!) ((!!) b y) x
18:33:50 <cybermanco> if it was only one array I only need one !!
18:34:23 <ski> so, for every (proper) i and j, you're initializing(?) all of buffer_final's cells, reading data from buffer
18:34:25 <ski> ?
18:34:38 <cybermanco> yes
18:34:56 <ski> hmm, there you use (!!), baaad !
18:35:13 <ski> with arrays one uses (!) instead :)
18:35:42 <cybermanco> and (!) is faster in this case?
18:35:44 <ski> (!!) :: [a] -> Int -> a
18:35:44 <ski> (!) :: Ix a => Array a b -> a -> b
18:35:48 <ski> yesss !
18:35:54 <cybermanco> hm
18:35:56 <cybermanco> ok..
18:35:57 <cybermanco> s
18:36:00 <cybermanco> so
18:36:23 <ski> (there still might be problems with updating, though)
18:37:16 <cybermanco> I think I will not need to update it
18:37:46 <cybermanco> because every time I made some change in information of the image.. i create a new one
18:38:21 <ski> cybermanco : btw, that old getPixel is better like : getPixel (Bmp (h, w, b)) x y = b !! y !! x
18:39:02 <ski> so the new is perhaps gonna be : getPixel (Bmp (h, w,
18:39:12 <ski> b)) x y = b ! y ! x
18:39:18 <ski> d'oh
18:39:28 <ski> getPixel (Bmp (h, w, b)) x y = b ! y ! x
18:40:20 <ski> perhaps you can create the new array something like :
18:41:53 <ski> array [ buffer ! (..i..j..s..w..) | i <- [0 .. wf-1] , j <- [0 .. hf-1] ]
18:42:09 <cybermanco> hm
18:43:01 <ski> well
18:43:37 <ski> array first needs the height and width of the array to create, of course
18:44:05 <ski> and getPixel could be like
18:44:13 <ski> getPixel (Bmp (h, w, b)) x y = b ! (y,x)
18:44:33 <ski> is you use twodimensional array, instead of "array of arrays"
18:44:47 <ski> ok ?
18:44:49 <cybermanco> ok
18:44:53 <cybermanco> thanks for the help
18:44:55 <ski> array :: Ix a => (a,a) -> [(a,b)] -> Array a b
18:45:00 <cybermanco> I will see if I can make it
18:45:20 <ski> if i want an one-dimesional array i can do
18:45:31 <ski> array (-10,10) [...]
18:45:50 <ski> (-10 being lower index bound, and 10 being upper)
18:45:58 <ski> if i want two-dimensional :
18:46:22 <shapr> @yow
18:46:23 <lambdabot> There's enough money here to buy 5000 cans of Noodle-Roni!
18:46:25 <ski> array ( (0,0) , (width-1,height-1) ) [...]
18:46:27 <ski> e.g.
18:46:34 <ski> cybermanco : understand ?
18:46:37 <cybermanco> yes
18:46:40 <ski> good
18:47:09 <ski> @moo
18:47:10 <lambdabot>          (__)
18:47:10 <lambdabot>          (oo)
18:47:10 <lambdabot>    /------\/
18:47:10 <lambdabot>   / |    ||
18:47:10 <lambdabot>  *  /\---/\
18:47:11 <lambdabot>     ~~   ~~
18:47:13 <lambdabot> ...."Have you mooed today?"...
18:47:46 <shapr> good morning #haskell!
18:47:50 <shapr> it's nearly 4am
18:48:32 <ski> yes :)
18:49:03 <shapr> hello lzfnk 
18:49:17 <lzfnk> shapr: hello
18:49:29 <lzfnk> shapr: I am the former _|_.
18:49:47 <lzfnk> shapr: My new irc client claims that nick is taken.
18:50:03 <shapr> it seems that nickname is in fact taken.
18:50:28 <shapr> looks like someone else registered that nickname with nickserv
18:50:59 <lzfnk> Ah.  I didn't know that was an option.
18:51:12 <Riastradh> What an audacious nerve to register such a sacred nick as that.
18:54:54 * shapr tries to clear away the fuzzyheadedness
18:55:19 <lzfnk> @yow
18:55:19 <lambdabot> I guess you guys got BIG MUSCLES from doing too much STUDYING!
18:55:23 <shapr> lzfnk: when you find another nickname that you like, try /msg nickserv help
18:55:45 <shapr> that'll show you how to register your irc nick
18:55:48 <lzfnk> shapr: Ok, thanks for the hint
18:57:26 <lzfnk> Just got KDE3.2 installed; using the builtin Kopete.  It's pretty nice.
18:57:55 <shapr> I'm tempted to try hircules
18:58:10 <lzfnk> But it still doesn't handle really long words like lambdabot tends to generate
18:58:35 <shapr> long words?
18:58:37 <shapr> or long lines?
18:58:58 <lzfnk> long words, without spaces.
18:59:03 <lzfnk> @listcommands
18:59:03 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
18:59:06 <shapr> ohh
18:59:08 <shapr> I see
18:59:12 * SamB wonders if he will see a day when circuits have to be swapped
18:59:14 <phubuh> lzfnk: If you're an Emacs fan, you might like ERC!
18:59:48 <lzfnk> phubuh: Oh, I'm a vi guy.
19:00:06 * SamB wonders if it would be doable
19:00:14 <shapr> swap circuits?
19:00:30 <phubuh> lzfnk: You probably wouldn't like it, then. :-)
19:00:50 <lzfnk> What's the best command line IRC client?
19:01:09 <shapr> emacs -nw ;-)
19:01:16 <phubuh> I think ERC in emacs -nw, most other people think irssi.
19:02:55 <lzfnk> I'll give irssi a try; thanks
19:03:01 <phubuh> :-)
19:03:43 <lzfnk> Just out of curiosity, what does -nw do to emacs?
19:04:01 <shapr> no window
19:04:05 <phubuh> Starts it in console mode even if DISPLAY is set.
19:04:28 <lzfnk> Oh, OK
19:04:32 * phubuh tries his /screenshot elisp script!
19:04:36 <phubuh> Screenshot: http://www.phubuh.org/~phubuh/screenshot-2004-Feb-07-04h-04m.png
19:04:41 <shapr> right now I'm using xemacs21-gnome, with all the pretty colors, gnome themes, etc
19:05:01 <shapr> oh, neat
19:05:49 <lzfnk> Nice!
19:05:57 <phubuh> Whoops, ignore the left half of that screenshot. :-)
19:06:41 <SamB> xemacs stole my .emacs.el, iirc
19:06:52 <shapr> SamB: but you can get it back if you want
19:07:07 <SamB> shapr: I did. but it scared me!
19:07:26 <shapr> I can understand that.e
19:08:04 <shapr> ok, time for HaskellDB
19:11:34 * phubuh drifts off to sleep.
19:11:41 <shapr> sov gott phubuh 
19:11:49 <phubuh> god natt :-)
19:12:14 <lzfnk-2> @arr
19:12:14 <lambdabot> Ahoy mateys
19:20:20 <cybermanco> i have one problem..
19:20:23 <ski> mm ?
19:20:39 <cybermanco> ambiguous occurende '!'
19:20:54 <cybermanco> I have this defined twice
19:21:14 <cybermanco> in GHC.Arr.!
19:21:17 <ski> are you doing array of arrays  or  2-dimensional array ?
19:21:18 <cybermanco> and Mpi.!
19:21:23 <ski> aha
19:21:25 <ski> sorry
19:21:35 <ski> What's Mpi.! ?
19:21:42 <cybermanco> I do I say to use the GHC.Arr
19:21:51 <ski> e.g. what type does it have ?
19:21:55 <cybermanco> Mpi is one file that I use
19:22:09 <ski> and there is a ! exported from it
19:22:26 <ski> try
19:22:33 <cybermanco> yes
19:22:33 <cybermanco> (!) :: a -> ()
19:22:33 <cybermanco> (!) = const ()
19:22:34 <ski> import Mpi hiding ( (!) )
19:22:44 <ski> or do you use it ?
19:22:50 <cybermanco> i don't use it..
19:22:56 <ski> ok
19:23:12 <ski> try adding  hiding ( (!) )  after the Mpi import, then
19:23:28 <cybermanco> it working
19:23:36 <ski> good
19:24:24 <ski> (hmm, Mpi.! sounds like category theory :)
19:24:50 <ski> what does Mpi stand for ?
19:24:57 <ski> do you know ?
19:25:09 <cybermanco> Metodos de programao 1 - programming methods 1
19:25:30 <ski> umhm
19:26:31 <cybermanco> is the name of the discipline in that we have to do this project
19:27:04 <ski> is this on a page somewhere ?
19:27:18 <cybermanco> yes.. but in portuguese
19:27:28 <ski> ok :)
19:27:57 <ski> and i suppose they have portuguese-sounding functions in Mpi ...
19:28:50 <cybermanco> hm
19:28:54 <cybermanco> the code is in english
19:30:37 <ski> ok
19:31:37 <ski> _|_-2 : hi again
19:32:19 <lzfnk-2> ski: hi
19:33:06 <ski> testing ?
19:33:20 <lzfnk-2> trying out irssi
19:33:32 <ski> mhm
19:34:29 <lzfnk-2> @listcommands
19:34:30 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
19:34:45 <ski> still cut off
19:35:01 <lzfnk-2> ski: Is there a lambdabot bug?
19:35:23 <ski> probably it tries to send all
19:35:35 <Riastradh> @listmodules
19:35:36 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
19:35:45 <ski> but client (or server ?) eats the tail
19:35:56 <lzfnk-2> that makes sense
19:37:15 <lzfnk-2> ;kjfl;kjfs;kfjs;flkjsfkjhgkgakbkufgkjfgwauyfakuerfgkuyfyfukfauygfykuwaeufgwauyfgfwaeuyfukgwaeuyffkuaygfwyufgkwafuygfywufgwkuuwgekufgkuwagwakuybukybcyucbaweykuuyfgwkufgwuyfgwkuybckybcyfgyufgkwafuyafgkbfgbfykbcybfyfgkfufgwkfgwkuyfgwfyfgwkugwkgwkuebcuybauygwuykwfgwukygewkuwgkuwfguwkfgwakuyfgwkuybacbeykuageyuagfuyfgukywkuafgakufgkbacukygceuygrbabrgwkrbgkybgkrbgkbgauckgbcrauwrbgawurbgcwkubgacwekugbcwaukbgacurbgcurbckrgbcawekubgwackbg
19:37:31 <lzfnk-2> Guess it must be the client
19:39:40 <ski> hmm, roughly 440 chars (if i counted correctly)
19:39:48 <lzfnk-2> @state
19:39:48 <lambdabot> nothing yet
19:39:59 <lzfnk-2> @listcommands state
19:39:59 <lambdabot> Module state provides the following commands: ["state"]
19:40:05 <lzfnk-2> @listcommands system
19:40:05 <lambdabot> Module system provides the following commands: ["listchans","listmodules","listcommands","join","leave","part","msg","quit","reconnect","echo"]
19:40:18 <keverets> 433 chars here ( echo "..." | wc -c )
19:40:43 <keverets> not including the "22:37 < lzfnk-2> "
19:41:12 <ski> i get + is at the start of every new line. is that just my client ?
19:41:20 <ski> (guess so)
19:41:46 <keverets> yup, just you.
19:41:49 <ski> 442 - 6 = 436
19:42:10 <keverets> mine ended on "wackbg"
19:42:18 <Riastradh> The server limits the message twice.
19:42:26 <Riastradh> Or the client limits it once and the server limits it once.
19:42:31 <Riastradh> IRC messages have a limit of 512 characters.
19:43:11 <Riastradh> The client uses up some with 'PRIVMSG #haskell :' and the server uses even more for the prefix.
19:43:15 <lzfnk-2> the message I sent ended with "waku"
19:43:38 <ski> my wc says 443
19:43:57 <cybermanco> is there any functions that flatten a list: [[1,2],[3,4]] -> [1,2,3,4] ?
19:44:04 <ski> Riastradh : yeah, i guessed so
19:44:06 <Riastradh> @type concat
19:44:07 <lambdabot> concat :: [[a]] -> [a]
19:44:42 <cybermanco> thanks
19:44:44 <ski> keverets : you talking about lzfnk-2's msg ? i was counting lambdabot's
19:45:29 <Riastradh> lambdabot messages can be longer, because lambdabot has a shorter hostname, which is included in the prefix.
19:45:58 <keverets> ah, lambdabot's gives me 444 chars
19:46:33 <keverets> sorry, 443 without the space between the name and the message.
19:46:47 <ski> ok, fine. we agree
19:47:13 <ski> (lzfnk-2's ended with wackbg here too)
19:47:36 <keverets> ski: which client are you using, though?
19:47:45 <keverets> irssi 0.8.9 here.
19:47:45 <ski> ircII
19:47:57 <Riastradh> It doesn't matter what client you're using.  The IRC protocol limits messages to 512 characters.
19:49:34 <lzfnk-2> Heh.  I saw the whole 540 chars I sent; I guess IRC doesn't echo your own msgs back to you.
19:49:51 <Riastradh> No, it doesn't.
19:49:58 <keverets> just wondering if the clients limited it further.
20:04:55 <ski> @arr
20:04:56 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
20:19:32 <cybermanco> I think I found my problem
20:19:41 <ski> ok ?
20:19:44 <cybermanco> I I don't know how to solve it
20:20:18 <cybermanco> someone here know a fast algorithm to transform a quadtree in a list?
20:20:33 <ski> why ?
20:20:49 <cybermanco> because mine is very very very sloww..
20:21:02 <ski> no. why transform to a list ?
20:21:06 <cybermanco> hm
20:21:12 <ski> as some final stage ?
20:21:13 <cybermanco> to save the waudtree to a file
20:21:16 <ski> ok
20:21:16 <cybermanco> yes
20:21:21 <ski> hmm
20:21:23 <cybermanco> to see the final result
20:21:34 <ski> how is your quadtree type defined
20:23:23 <ski> cybermanco : well ?
20:24:17 <cybermanco> w8
20:24:34 <cybermanco> type Point = (Int, Int)
20:24:34 <cybermanco> type Coords = (Point, Point)
20:24:34 <cybermanco> type Section = (Coords, Colour)
20:24:34 <cybermanco> data QTree = Empty | Leaf Section | Node Coords QTree QTree QTree QTree
20:25:21 <ski> and what is the type signature of your current conversion-to-list function ?
20:25:51 <ski> (+ how it is defined. if not too big)
20:26:05 <cybermanco> getColoursFromQTree :: QTree -> Int -> Int -> Int -> Int -> [Colour]
20:26:16 <cybermanco> getColoursFromQTree qt x y w h | (x < w)             = (getColourFromPixelFromQTree qt x y):(getColoursFromQTree qt (x + 1) y w h)
20:26:16 <cybermanco>                                | (x == w) && (y < h) = (getColoursFromQTree qt 0 (y + 1) w h)
20:26:16 <cybermanco>                                | otherwise           = []
20:26:29 <cybermanco> it will get pixel by pixel
20:26:40 <cybermanco> and the getpixel is very slow
20:26:49 <cybermanco> beacause its recursive
20:27:12 <ski> hmm
20:28:51 <ski> so you scan through it, line by line ...
20:29:10 <cybermanco> and in every line I scan all pixels
20:29:28 <cybermanco> and store all in a list
20:29:33 <ski> getColourFromPixelFromQTree is recursive in the QTree ?
20:30:08 <cybermanco> yes
20:30:13 <ski> hmm
20:31:02 <ski> i'm not really sure what to do ... hm
20:31:15 <cybermanco> so .. in a 640*480 image it will call getColourFromPixelFromQTree 307200 times
20:31:37 <cybermanco> the problem is in the algorithm
20:31:56 <ski> we could mayybe try to extract many pixels at one go, in the recursive part
20:32:07 <ski> but the problem is in the order
20:32:22 <lzfnk-2> cybermanco: do the Sections overlap, in a QTree?
20:32:41 <cybermanco> nop
20:32:46 <ski> cybermanco : i would think there would be a similar problem here in an imperative language, yes ?
20:33:18 <cybermanco> hm.. yes
20:33:34 <ski> we could perhaps make the recursive pass return a list of list of pixels instead. or something (arrays ??)
20:33:36 <lzfnk-2> cybermanco: Would a 640x480 QTree always have 4 320x240 subtrees?
20:34:11 <cybermanco> lzfnk-2: yes
20:34:59 <lzfnk-2> cybermanco: One more question: Is the purpose of getColoursFromQTree to dump all the pixels from the QTree?
20:35:15 <ski> well, i guess we could e.g. allocate a big array/bitmap, and plot the pixels into that (in the natural recursive order, not the line-by-line one). then we could easily linearize the array/bitmap
20:35:41 <ski> but perhaps we waste too much memory allocating the array/bitmap ?
20:35:53 <cybermanco> lzfnk-2: dump the colors of all pixels
20:35:57 <cybermanco> ordered
20:36:04 <ski> line-by-line
20:36:06 <cybermanco> to store in a file
20:36:35 <cybermanco> ski: we can allocate in haskell?!
20:36:38 <ski> cybermanco : what do you think ?
20:36:46 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/", "ghc 6.2 is out", "ghc rpms: http://haskell.org/~petersen/rpms/ghc/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html"]'
20:36:46 --- topic: set by shapr on [Sat Jan 24 08:38:50 2004]
20:36:52 <cybermanco> I thinks is the best way...
20:37:05 <ski> cybermanco, usually every constructor allocates :)
20:37:06 <cybermanco> because we only will go through the QTree one time
20:37:32 <ski> what is the best way ?
20:38:22 <cybermanco> [04:35] <ski> well, i guess we could e.g. allocate a big array/bitmap, and plot the pixels into that (in the natural recursive order, not the line-by-line one). then we could easily linearize the array/bitmap
20:38:23 <cybermanco> this
20:38:30 <ski> ok
20:38:32 <ski> hmm
20:38:43 <ski> well, we could use mutable arrays
20:39:04 <ski> (do you have some bitmap type ? or should we try to use arrays ?)
20:39:35 <ski> on the other hand, i think we could return a list to pass to the function 'array'
20:39:38 <cybermanco> I have on bitmap typw
20:39:45 <ski> wouldn't that be ok, also .. ?
20:39:50 <cybermanco> yes..
20:39:50 <ski> ok
20:39:56 <cybermanco> but..
20:40:09 <cybermanco> how do I allocate the list?
20:40:11 <ski> do you want to use the bitmap type ?
20:40:19 <ski> is it mutable or not ?
20:40:22 <cybermanco> the bitmap type is predefined
20:40:39 <cybermanco> I can't change it
20:40:40 <cybermanco> data BitMap = Bmp (Int, Int, [[Pixel]])
20:41:42 <ski> cybermanco : well, if we return a list to pass to 'array', then, i think, the order in the list isn't going to matter, so we could generate the list in the natural-recursive way
20:41:47 <ski> aha
20:41:58 <cybermanco> how|!?
20:42:23 <ski> well, it contains list of lists of pixel so this is probably not good for this task
20:42:44 <cybermanco> forget BitMap..
20:42:50 <cybermanco> i want it in a list only
20:43:13 <ski> (i would think that using mutable arrays would be more efficient, but i dunno if the different is small or large)
20:43:31 <ski> ok, so if we want a pure list
20:43:35 <cybermanco> what are muttable arrays?
20:43:50 <ski> then we can't use the IO monad
20:44:07 <ski> but we could still use the ST monad
20:44:26 <cybermanco> hm
20:44:37 <cybermanco> it starts to looks complicated :\
20:44:39 <ski> mutable arrays are arrays thats you can selectively update (cheaply), just as in many imperative proglangs
20:45:01 <cybermanco> ok
20:45:04 <ski> only caveat is that one must use a monad :)
20:45:30 <cybermanco> where can I get info acabout that?
20:46:15 <ski> it could well be that it is acceptable if this generateXXX is in the IO monad (because it will probable anyway be near the IO toplevel)
20:46:31 <ski> well, GHC documentation, of course
20:46:39 <ski> and here also, i suppose ;)
20:46:48 <cybermanco> what are the name of this kind of arrays?
20:46:50 <ski> possibly at other places too
20:46:57 <ski> which ?
20:47:08 <cybermanco> mutable arrays
20:47:09 <ski> Array IOArray or STArray ?    :)
20:47:12 <cybermanco> hm
20:47:22 <ski> (IIRC)
20:47:27 <cybermanco> are these two mutable?
20:47:33 <ski> lemme check GHC doc
20:49:08 <ski> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.ST.html is on STArray
20:49:23 <ski> yes, IOArray and STArray are mutable
20:49:44 <ski> but you could also try with Array
20:50:23 <ski> (i.e. returning a list of assocs, and calling 'array' on that)
20:50:47 <cybermanco> hm..
20:51:12 <cybermanco> that gived me an idea!
20:51:20 <ski> what ?
20:51:25 <lzfnk-2> cybermanco: The following (untested) might do what you want:
20:51:34 <lzfnk-2> getColoursFromQTree :: QTree -> [Colour]
20:51:34 <lzfnk-2> getColoursFromQTree = concat . getScanlinesFromQTree
20:51:34 <lzfnk-2> getScanlinesFromQTree :: QTree -> [[Colour]]
20:51:34 <lzfnk-2> getScanlinesFromQTree = foldQT empty leaf node where
20:51:34 <lzfnk-2>     empty = [[]]
20:51:37 <lzfnk-2>     leaf (((x0,y0),(x1,y1)), c) = [[c | x<-[x0..x1]] | y <- [y0..y1]]
20:51:39 <lzfnk-2>     node q1 q2 q3 q4 = (map (++) q1 q2) ++ (map (++) q3 q4)
20:51:42 <lzfnk-2> foldQT :: a -> (Section -> a) -> (a->a->a->a->a) -> QTree -> a
20:51:44 <lzfnk-2> foldQT empty leaf node = f where
20:51:47 <lzfnk-2>    f Empty = empty
20:51:49 <lzfnk-2>    f (Leaf section) = leaf section
20:51:52 <lzfnk-2>    f (Node t1 t2 t3 t4) = node (f t1) (f t2) (f t3) (f t4)
20:52:06 <cybermanco> hm
20:52:20 <cybermanco> fold.. is like the foldr?
20:52:35 <lzfnk-2> cybermanco: yes; it's a fold for your QTree type
20:52:36 <ski> cybermanco : that gave me! an idea :)  perhaps not good, but one might be able to dump the pixels in tree-order, and then permute them into line-by-line-order
20:52:49 <cybermanco> my ideas was..
20:53:01 <cybermanco> go through the QTree
20:53:07 <cybermanco> and store all in a list
20:53:11 <cybermanco> like this
20:53:25 <cybermanco> (y * w + x, colour)
20:53:26 <cybermanco> then
20:53:27 <ski> and sort it, then ??
20:53:32 <cybermanco> sort by first member
20:53:35 <cybermanco> yes
20:53:37 <ski> yay !
20:53:42 <cybermanco> :)
20:53:46 * ski guessed right !
20:53:58 <shapr> @yow
20:53:58 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me
20:53:58 <lambdabot>  to Minnesota but don't EMBARRASS me!!
20:54:07 <cybermanco> or.. sort is not a god idea?
20:54:20 <cybermanco> god - good
20:54:31 <ski> lambdabot : you're too funny sometimes. ya'know that ?
20:54:45 <ski> lambdabot: huh ?
20:54:45 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
20:56:43 <lzfnk-2> cybermanco: My code assumes the QTrees in a Node are in the order (upper-left, upper-right, lower-left, lower-right)
20:56:47 <ski> lzfnk-2 : yes, that seem like my first thought :)
20:57:24 <cybermanco> yes they are
20:58:03 <ski> i dunno how efficient that is, but probably better than your previous solution :)
20:58:23 <cybermanco> :)
20:58:37 <cybermanco> there is a problem with it
20:58:42 <ski> (because it only traverses the tree once)
20:58:43 <cybermanco>  f (Node t1 t2 t3 t4) = node (f t1) (f t2) (f t3) (f t4)
20:58:47 <cybermanco> Node takes 5 args
20:59:12 <ski> yea, which was the first arg ?
20:59:16 <lzfnk-2> cybermanco: Oh, you're right, change it to this:
20:59:28 <cybermanco> Coords
20:59:31 <ski> ok
20:59:34 <lzfnk-2>    f (Node _ t1 t2 t3 t4) = node (f t1) (f t2) (f t3) (f t4)
21:00:32 <ski> cybermanco : does coords contain info about what min- & max-  x- & y- pos this particular subtree has ?
21:00:40 <lzfnk-2> Since the sections don't overlap, and all the pixels are covered by sections, you should be able to ignore the coords on a Node
21:00:47 <ski> (for easy reference)
21:00:58 <ski> yes
21:01:11 <ski> if they are built in a sane way
21:01:19 <cybermanco> hm
21:01:50 <cybermanco> in map (++) q1 q2 map is aplied to too many args
21:02:15 <ski> (i.e. no weird tree building like in hilbert path)
21:02:17 <lzfnk-2> bleh!  I meant zip!
21:02:38 <lzfnk-2> zipWith!
21:02:56 <cybermanco> zipWith (++) q1 q2 ?
21:03:03 <lzfnk-2> ya
21:03:12 <ski> cybermanco : yes, (as i said) this may perhaps still be too unefficient   (dunno)
21:03:19 <ski> lzfnk-2 : :)
21:03:47 <lzfnk-2> q1 & q2 should contain the same # of scanlines, right?
21:03:54 <cybermanco> weird
21:04:00 <cybermanco> it crashed when I compiled it!
21:04:09 <ski> oh ?
21:04:10 <lzfnk-2> wow
21:04:14 <lzfnk-2> ghc?
21:04:16 <ski> to little mem ?
21:04:17 <cybermanco> yes
21:04:20 <ski> or what ?
21:04:31 <cybermanco> hm
21:04:36 <cybermanco> its working now..
21:04:42 <ski> strange
21:05:57 <ski> are you just trying reading in a bitmap, and dumping it out again ?
21:06:13 <cybermanco> now.. I am read a bmp
21:06:19 <cybermanco> tranform in qaudtree
21:06:27 <cybermanco> and save it again in a file
21:06:41 <ski> so you do complicated transform on these test-runs also ?
21:07:01 <cybermanco> the transformtion is fast
21:07:13 <cybermanco> I think that does't have problem
21:07:21 <ski> (hopefully the transform is not too inefficiant)
21:07:25 <ski> ok
21:07:31 <ski> fine
21:07:50 <ski> you're trying with some smaller pics to start with ?
21:08:12 <cybermanco> yes
21:08:15 <cybermanco> with 8x8 pic
21:08:32 <cybermanco> lzfnk-2: worked with the 8x8 pic
21:08:32 <ski> and it's not finished yet .. ?
21:08:38 <ski> ok
21:08:43 <lzfnk-2> cybermanco: good!
21:08:43 <cybermanco> let me test with a 640x480 pic :)
21:09:14 <ski> you could try some, perhaps, 40x40 first
21:09:19 <cybermanco> 10 secs :)
21:09:23 <ski> ok
21:09:24 <ski> fine !
21:09:35 <cybermanco> hm
21:09:35 <lzfnk-2> cybermanco: That's not too bad, eh?
21:09:38 <ski> not too bad :)
21:09:40 <cybermanco> but..
21:09:58 <cybermanco> it seems to have a problem
21:10:03 <cybermanco> in the output file
21:10:03 <ski> what ?
21:10:06 <ski> bug ?
21:10:24 <ski> worng dimensions ?
21:10:29 <ski> scrambled data ?
21:10:37 <ski> missing data ?
21:10:54 <cybermanco> missing data
21:11:08 <lzfnk-2> cybermanco: change the "empty" line to:
21:11:10 <lzfnk-2>     empty = repeat []
21:11:33 <ski> that might be the problem
21:13:20 <cybermanco> calculating..
21:14:54 <ski> it takes longer, eh ?
21:15:23 <cybermanco> hm
21:15:40 <cybermanco> it's still processing
21:16:09 <lzfnk-2> There must be a QTree with two Empty pieces at the top or bottom
21:16:22 <ski> do you actually have (generate) any Empty's is nonempty QTree's ?
21:16:46 <ski> lzfnk-2 : oops. that would make it loop :)
21:17:08 <cybermanco> hm
21:17:12 <lzfnk-2> yah.
21:17:12 <cybermanco> maybe the problem
21:17:22 <cybermanco> is in the way I generate the txt file
21:17:47 <ski> it seems to me that Empty would be unnnecessary for QTree's other than (toplevel) empty ones
21:17:48 <cybermanco> saveQTree (Node (c1, (x, y)) a b c d) file = do writeFile file (unlines ((show (y + 1)):(show (x + 1)):(cts (_getColoursFromQTree (Node (c1, (x, y)) a b c d)))))
21:17:50 <cybermanco>                                                 return ()
21:17:50 <cybermanco>   where
21:17:50 <cybermanco>   cts []     = []
21:17:50 <cybermanco>   cts ((a, b, c):xs) = (show a ++ " " ++ show b ++ " " ++ show c):(cts xs)
21:18:04 <cybermanco> I use the ++
21:18:42 <ski> hm
21:19:14 <ski> didn't you convert the tree to [Colour] and then dump that ?
21:19:23 <ski> hm
21:19:33 <ski> sorry
21:19:39 <ski> i'm reading bad
21:19:39 <cybermanco> yes
21:19:51 <ski> i see you are doing that now, yes
21:21:11 <lzfnk-2> cybermanco: I don't think your use of ++ is a problem, but you could use unwords [show a,show b,show c] instead.
21:21:39 <cybermanco> lzfnk-2: i will try that..
21:21:58 <ski> saveQTree node@(Node (_, (x, y)) _ _ _ _) = do writeFile file (unlines ((show (y + 1)):(show (x + 1)):(cts (_getColoursFromQTree node))))
21:22:05 <ski> better
21:22:33 <cybermanco> node@ !!! never saw that
21:22:48 <ski> the ++ use isn't a problem
21:23:37 <lzfnk-2> cybermanco: when generating the QTrees, would it be possible to include Coords for the Empty sections as well?
21:23:54 <ski> (i hope saveQTree can handle at least Leaf's too)
21:24:15 <cybermanco> nop
21:24:24 <ski> better would be to not have any Empty, in my mind
21:24:33 <ski> or is it required for something ?
21:24:51 <cybermanco> is required if the pic is not a power of 2
21:24:57 <cybermanco> the size
21:25:00 <ski> hmm
21:25:04 <cybermanco> I think
21:25:06 <ski> yes, of course
21:25:11 <ski> hmm
21:27:08 * lzfnk-2 needs to go to bed
21:27:35 <ski> there seems to be some fun with quadtrees at http://www.cse.ogi.edu/~jl/wg2.8/Recife.html#Okasaki
21:27:50 <lzfnk-2> Good night
21:28:02 <ski> good night, lzfnk-2
21:28:28 <ski> hmm
21:29:18 <ski> do the QTree transformations require power of 2 (fake) width & heigth ?
21:29:41 <cybermanco> yes
21:29:42 <ski> (by fake i mean that some subtrees are actually Empty)
21:30:18 <ski> so they would not word with Okasaki's Rect type, then ?
21:30:54 <ski> (which seems to be a tree encoding of rectangular matrices/2-dimensional arrays)
21:31:05 <ski> just wondering ..
21:31:41 <ski> (the Empty constructor annoys me)
21:32:31 <ski> anyway, are you satisifed with this solution of dumping ?
21:32:55 <cybermanco> yes.. it looks ok
21:33:14 <ski> not too slow on large pics ?
21:33:36 <ski> hmmmmmmmm
21:33:43 <ski> actually !
21:34:22 <ski> lzfnk-2 does have the (left-associative) ++ problem !
21:34:40 <ski> lzfnk-2's solution has it, i mean
21:34:47 <ski> do you see it ?
21:36:01 <cybermanco> I don't understant the lzfnk-2 code :)
21:36:12 <ski> though it may perhaps not be so severe, in this case   (the left-assoc depth is proportional to log of the [height|width])
21:36:14 <ski> oh
21:36:28 <ski> perhaps we should try to correct that :)
21:36:54 <ski> well ?
21:37:09 <cybermanco> hm
21:37:14 <cybermanco> how?
21:37:30 <ski> do you understand what foldQTree is good for, and what it does ?
21:38:08 <ski> getScanlinesFromQTree could be written quite easily without it, also
21:38:26 <ski> so foldQTree is not required
21:38:32 <ski> how ?
21:38:44 <ski> by explaining, perhaps ;)
21:39:48 <ski> so, what do you think about foldQTree ?
21:40:59 <cybermanco> hm
21:41:11 <ski> do you use foldr at times ?
21:41:12 <cybermanco> I think it shoul be like the foldr ou foldf
21:41:18 <cybermanco> never..
21:41:38 <ski> sorry ?
21:41:46 <cybermanco> the problem seems to still be in the func that generats the list
21:42:06 <ski> so there is still a problem ?
21:42:08 <ski> bug ?
21:42:13 <ski> or efficiency ?
21:42:18 <cybermanco> is slow
21:42:20 <ski> ok
21:42:40 <cybermanco> because if I create a list like this: [(i, i, i) | i <- [0..768200]] and save it
21:42:45 <cybermanco> it takes 16 seg
21:42:54 <ski> well, it could perhaps be the ++ problem i mentioned, after all ..
21:42:57 <cybermanco> that .. is fast
21:43:19 <ski> ok
21:44:45 <ski> so i guess you have a picture of a square, divided into four subsquares, same with these, and so on, until we come to the Leafs
21:44:50 <ski> yes ?
21:45:30 <cybermanco> yes
21:45:41 <ski> now what does getScanlinesFromQTree do ?
21:45:48 <ski> what does it return ?
21:46:51 <cybermanco> I guess it return a lists of all lines
21:46:57 <cybermanco> of the pic
21:47:39 <ski> nope :)
21:47:49 <ski> that's what getColoursFromQTree do
21:47:51 <cybermanco> hm
21:48:00 <ski> oh, pardon me again
21:48:06 <ski> you are right :)
21:48:26 * ski guesses he is a little tired
21:48:37 <cybermanco> me too
21:48:42 <shapr> me too!
21:48:51 <cybermanco> I can't get my eyes open!!
21:48:56 <ski> so, it gives us a row-order-"matrix"
21:49:09 <ski> ok
21:49:13 <ski> hm
21:49:43 <ski> so perhaps you should go off to fluffy-land ?
21:49:54 <cybermanco> fluffy-land?
21:49:59 <ski> sleep
21:50:01 <ski> :)
21:50:02 <cybermanco> ha..
21:50:02 <cybermanco> nop
21:50:05 <cybermanco> I can't!
21:50:09 <ski> oh
21:50:59 <ski> so you're one of those people who need to eat pills to sleep properly, eh ?
21:51:03 * ski is joking
21:51:12 <cybermanco> :9 nop
21:51:29 <ski> well
21:51:30 <cybermanco> sometimes I need to see some movie to sleep
21:51:36 <ski> mhm
21:51:54 <cybermanco> yesterday I started seeing a movie
21:52:02 <cybermanco> maybe I finish it today..
21:52:03 <ski> (should i continue a little about getScanlinesFromQTree ?)
21:52:05 <ski> aha
21:52:19 <ski> which one ?  (if you don't mind telling)
21:52:32 <cybermanco> thirteen..
21:52:36 <cybermanco> hm
21:52:44 <cybermanco> not a really good movie..
21:52:45 <ski> ok, never heard of. :)
21:52:58 <cybermanco> but the cover was good
21:53:00 <cybermanco> :)
21:53:27 <ski> cover = music ?
21:53:50 <cybermanco> wehttp://www.imdb.com/title/tt0328538/
21:53:57 <cybermanco> cover.. box
21:54:17 <ski> mhm
21:55:32 <ski> @eval imoen
21:55:32 <lambdabot> You're all buffle-headed !
21:56:34 <ski> cybermanco : want me to continue ?  (yes or no)
21:57:01 <cybermanco> I think you help me enough for today :)
21:57:05 <cybermanco> just one more question
21:57:09 <ski> sure
21:57:16 <cybermanco> what is the best sorting algorithm?
21:57:40 <Riastradh> There isn't one.
21:57:47 <ski> depends on whether the data is "arbitrary" or there is some structure known
21:57:49 <Riastradh> They all suck in some way or another.
21:58:00 <Riastradh> Some suck less than others for particular situations.
21:58:06 <ski> yes
21:58:20 <ski> Hear Hear !
21:58:43 <cybermanco> is there anyone already implemented in haskell libs?
21:59:28 <SamB> cybermanco: there is a sort function...
21:59:38 <ski> sort :: Ord a => [a] -> [a]
21:59:49 <Riastradh> What?  There's just a sort, no control over what algorithm?
21:59:55 <ski> haha
22:00:09 <SamB> Riastradh: another algorithm IS another sort!
22:00:23 <Riastradh> ?
22:00:28 <cybermanco> sort! I need to import something?
22:00:36 <ski> List
22:00:49 <SamB> Riastradh: that is, if you had another algorithm implemented, it would be a whole other sort function!
22:01:11 <ski> cybermanco : what do you want to sort ?
22:01:18 <Riastradh> SamB, right!  There should be different heapSort, merge, insertionSort, et cetera.
22:01:42 <cybermanco> a thing like this (x, y)
22:01:45 <SamB> Riastradh: send in patches!
22:01:46 <cybermanco> sort by x
22:02:08 <Riastradh> Eugh.  sort should also take an explicit comparison predicate, not depend on Ord.
22:02:20 <ski> Riastradh : i guess sort only makes the contract that it sorts (if the Ord instance is a total ordering), not how, and perhaps not stableness ..
22:02:22 <SamB> Riastradh: there is another version that takes one!
22:02:50 <frevidar> Riastradh: you can use "sortBy"
22:02:55 <ski> sortBy :: (a -> a -> Ordering) -> [a] -> [a]
22:03:03 <Riastradh> Oh.
22:03:32 <ski> cybermanco : but what is it ?
22:03:50 <ski> sort = sortBy compare
22:04:19 <cybermanco> ski: I will try my idea
22:04:26 <ski> ok
22:05:04 <ski> i'm not sure it will be good (or even better), but try to your hearts content :)
22:05:31 <ski> can't possibly hurt  (or what do they say ?)
22:10:44 <ski> cybermanco : did you change away from  empty = repeat []  ?
22:10:57 <cybermanco> nop
22:11:02 <ski> or does that work good ?
22:11:11 <cybermanco> I don't understand the code..
22:11:17 <cybermanco> I can't touch it
22:11:28 * shapr fights the evil that is MS Outlook
22:11:33 <frevidar> ghc seems to do a quicksort.
22:11:34 <ski> i mean, does it hang ?
22:11:41 <shapr> good morning frevidar!
22:12:08 <shapr> parsing messages produced by MS Outlook is painful.
22:12:08 <frevidar> good afternoon shapr
22:12:21 <cybermanco> it works but it's still slow
22:12:21 <shapr> are you in sydney?
22:12:37 <ski> frevidar : hugs 2002Nov seems to do insertion sort
22:12:51 <frevidar> cybermanco: it will be slow on sorted lists, because its a 'quick'sort.
22:13:06 <frevidar> cybermanco: which isn't very quick at all.
22:13:12 <ski> cybermanco : but it doesn't hang as lzfnk-2 thought it might ?
22:13:22 * shapr reads up on MIME
22:15:36 <ski> cybermanco : hmm ?
22:16:20 <shapr> anyone here used WASH's Mail parsing code?
22:17:52 <cybermanco> hm
22:18:02 <cybermanco> I give up
22:18:09 <ski> cybermanco : so, does that line say "empty = [[]]" or "empty = repeat []" ?
22:18:11 <cybermanco> I am going to bed...
22:18:21 <cybermanco> empty = repeat []
22:18:23 <ski> ok
22:18:26 <ski> thanks
22:18:44 <ski> (i'm trying to see if i can improve the ++ things)
22:19:08 <ski> well, good dreams to you, then
22:19:26 <cybermanco> thank you very much for your help
22:19:43 <cybermanco> your really helped me a lot :)
22:19:47 <shapr> aha, getParts
22:20:01 <ski> cybermanco : thanks :)
22:20:29 <ski> (now you are supposed to thanking me for thanking you for thanking me ;)
22:20:34 <cybermanco> :)
22:20:50 <ski> shapr : ?
22:21:13 <shapr> I'm trying to use WASH's MailParser to cut off any non-text MIME parts of a message before throwing the message into a database.
22:21:32 <ski> mhm, ok
22:21:47 <shapr> full text indexing on attachments isn't very helpful.
22:22:46 <ski> you can't easily see which ones are text ??
22:24:10 <shapr> a MIME email looks like this: http://shapr.homelinux.net/~shae/snippet2.txt
22:24:53 <ski> ok
22:24:57 <shapr> so I want to index text/plain
22:24:59 <shapr> but not text/html
22:25:13 <shapr> I don't know if there are more Content-Types I want to index.
22:25:23 <ski> and WASH's doesn't help you with thay ?
22:25:47 <shapr> it seems that WASH doesn't handle all the types
22:25:50 <ski> mhm
22:25:57 <shapr> *MailParser Data.Either> getParts $ digestMessage $ fRight mmsg
22:25:57 <shapr> [Singlepart {getHeaders = [], getLines = ["Content-Type: text/plain;","charset=\"iso-8859-1\"","Content-Transfer-Encoding: quoted-printable","","unsubscribe haskell@haskell.org",""], getDecoded = "Content-Type: text/plain;\ncharset=\"iso-8859-1\"\nContent-Transfer-Encoding: quoted-printable\n\nunsubscribe haskell@haskell.org\n\n", getContentType = Content-Type: text/plain ;charset="us-ascii", getContentTransferEncoding = Conten
22:25:57 <shapr> t-Transfer-Encoding: 7bit, getContentDisposition = Content-Disposition: inline},*** Exception: "body part" (line 2, column 21):
22:25:58 <shapr> unexpected "\n"
22:26:00 <shapr> expecting ":"
22:26:30 <shapr> so I'm trying to figure out if the Exception above is because I've broken something
22:26:36 <shapr> or MS Outlook has broken something
22:26:47 <shapr> or if MailParser is incompletee
22:27:08 <shapr> Haskell is fun
22:27:21 <shapr> oh, hey
22:27:32 <ski> hm, well i don't know much about WASH :(
22:27:35 <shapr> nor do I
22:27:41 <shapr> but I'm reading :-)
22:27:41 <ski> yes
22:28:03 <shapr> mrak had a good idea, he said Haskell needs a generic server
22:28:13 <ski> which is ?
22:28:26 <shapr> something where you put in your handler function, but all the infrastructure stuff is already written for you
22:28:38 <ski> handler for what ?
22:28:42 <shapr> for anything
22:28:53 <ski> oh ?
22:29:02 <ski> that sounds useful !
22:29:10 <shapr> the generic server just lisens for connections, and then calls your function when it gets input
22:29:20 <shapr> yes, I agree
22:29:40 <shapr> bring said that it'd be nice to have a standalone xml-rpc server for his XmlRpc lib
22:29:49 <ski> (but i don't know what the expected values of anything is)
22:29:56 <shapr> and I know lots of people have wanted to write other simple network servers
22:30:11 <shapr> I want to write a pop3 and smtp server
22:30:14 <shapr> bring wants xml-rpc
22:30:25 <shapr> phubuh wants DCTC
22:30:43 <ski> ok..
22:30:45 <shapr> so, how much of that code would be generic?
22:30:57 <ski> i've no idea :)
22:31:20 <shapr> at least the threading and socket opening is rewritten every time
22:31:35 * ski isn't very used to using connections
22:31:42 <ski> yes
22:31:50 <shapr> I'm not either, but I would use them more if it were easier to do it.
22:32:23 <shapr> so, I wonder how to do this
22:32:44 <ski> hmm, so it "would call something on the other side" ?
22:33:13 <shapr> a simple implementation of a generic server would let you put in your own callback function
22:33:21 <ski> how to determine/identify what ?
22:33:23 <shapr> and specify which port and protocol to listen on
22:33:28 <ski> strings ?
22:33:41 <SamB> I don't think xml-rpc supports lazyness
22:33:45 <shapr> maybe it just calls your function every time it receives a line?
22:34:00 <shapr> we could steal ideas from Twisted for this.
22:34:35 <ski> so, this would need to get registered on both sides, yes ?
22:35:03 <shapr> well, I could see writing a simple webserver function that parsers an HTTP 1.0 request, and just returns the file
22:35:38 <shapr> so the user would just write the REQUEST parsing code and then return some sgml
22:35:39 <ski> but if we want at least two different handlers ?
22:35:51 <shapr> yes, that's where it starts to get interesting :-)
22:36:05 <shapr> I think this requires a wiki page
22:36:51 <ski> i guess the thing to run, must already be in binary form, on that side .. ?
22:36:53 <shapr> if the generic server is already using Concurrent, you might as well allow the user to have multiple handlers
22:37:00 <shapr> http and ftp at the same time, for example
22:37:20 <ski> (otherwise we'd have to transmit closures and stuff)
22:38:40 <ski> shapr : DYM : multiple handlers, *at the same time* ?  (concurrently)
22:38:51 <shapr> why not?
22:38:57 <shapr> Concurrent could handle that, right?
22:39:01 <ski> i guess
22:39:19 <ski> i was just still thinking on how to install several of them
22:39:28 <ski> ready to be invoked
22:39:40 <shapr> they'd work much like inetd
22:40:02 <shapr> the GenericServer listens on a port, and when it receives a connection, it grabs input and then calls the user function
22:41:31 <ski> my bro made some simple such dispatching system (in C) for some programs
22:41:52 <ski> (well, it was not very simple to implement)
22:42:03 <shapr> right, that will probably be true of this system also.
22:42:10 <shapr> but maybe arrows would make this simpler
22:42:13 <ski> he first tried to make some netbus clone, i think
22:43:28 <ski> perhaps ..
22:44:33 <ski> would such an arrow represent a computation in this, that can communicate things over the conn ..
22:44:46 <ski> hmm
22:45:19 <shapr> that sounds good
22:45:21 <ski> we'd have to serialize the transmitted data anyway, right ?
22:46:18 <shapr> hi liralen, looking for Haskell info?
22:46:19 <ski> so, i'm not sure if arrows would buy us more that monads
22:47:00 <ski> shapr : perhaps they could make it harder(/impossible) to introduce to space leaks or something .. ?
22:47:05 <shapr> they could, yes
22:47:16 <shapr> but I think they could do more
22:47:51 <shapr> I have to think about it a bit.
22:48:02 <ski> liralen : i think i recognise your name from somewhere .. (dunno wherefrom, though. usenet perhaps)
22:48:53 <ski> liralen : have you tried haskell any ?
22:48:58 <ski> shapr : yes
22:49:26 <shapr> liralen == ayrnieu == cleverdra
22:49:33 <ski> d'oh, scared him away, eh ?
22:49:45 <ski> ok
22:50:05 <shapr> could arrows be used to make connection specfying combinators?
22:50:55 <ski> perhaps
22:52:05 <ski> specfying connections how ?
22:53:13 <ski> hm
22:53:48 <shapr> http://www.twistedmatrix.com/documents/howto/reactor-basics
22:54:07 <shapr> something like monad transformers, where you can combine ErrorT, StateT, etc
22:54:29 <shapr> but instead, sslA, udpA, tcpA
22:54:29 <ski> oh, you meant at type level ..
22:54:48 <ski> or did you ?
22:54:52 <shapr> so your callback function could be an arrow itself
22:54:59 <shapr> and you build it out of the other pieces
22:55:44 <ski> well, i guess it would be nice if the handler could also communicate using the conn
22:55:54 <shapr> ?
22:56:05 <shapr> what do you mean?
22:56:58 <ski> didn't you mean that, if it could be an arroe itself, then it too could use all the features of the arrow, inluding delegating/rpc over conn ?
22:57:20 <shapr> hm, that's a good point.
22:57:29 <shapr> sort of mindbending, but nifty
22:57:56 <ski> when you say "callback" ..
22:58:24 <shapr> I say callback because the user function isn't Main.main, it gets called by Main.main
22:58:30 <ski> .. do you mean that we, here decide what code should be run, and install it over there ?
22:58:49 <ski> or that we just select from a menu over there ?
22:58:59 <ski> hmm
22:59:14 <ski> which user function ?
23:00:10 <shapr> originally, I was just thinking of writing a Server.hs module where the user would "import qualified Server" and then "main = Server.serve myFunction"
23:00:35 <shapr> and then serve would listen on a port, and call myFunction with anything it gets.
23:00:44 <ski> ok
23:00:51 <ski> i get that
23:01:03 <shapr> but an arrow based framework would be far more useful
23:02:29 <ski> i guess i was thinking of something FFI like, perhaps, but over a conn instead of over language barrier
23:02:48 <shapr> you could do that with an arrow framework
23:03:10 <ski> (but probably implemented without making any new haskell extensions for this)
23:03:15 <shapr> right
23:03:17 <ski> perhaps
23:04:57 <shapr> if you can write an arrow to specify a callback in terms of other arrow callbacks...
23:05:01 <shapr> %-)
23:05:43 <shapr> then, as long as you could serialize data, you could call remote arrows just fine
23:05:53 <ski> yes
23:06:10 <shapr> "serialize data" is a bit harder than it sounds though.
23:06:11 <shapr> I think
23:06:38 <ski> perhaps we would need some unique ID generating and caching of arrows (for some time) on the server
23:06:59 <shapr> I think we should start by writing an arrow based server that has just one simple arrow
23:07:02 <shapr> and see what happens next.
23:07:07 <ski> serialize closures is hard
23:07:34 <shapr> yes, serialization is challenging.
23:08:41 <ski> Joachim Durchholz's Marshalling survey talks a bit about these problems
23:09:12 <shapr> I never did see the final version of that, do you have an url?
23:09:29 * shapr googles
23:09:41 <ski> i don't know if he has it on web yet (i think he said that he will)
23:10:07 <ski> also, the threads discuss this mucha
23:10:41 <ski> hmm
23:12:17 <ski> (i dunno how much decomposition of function type into top-level functions would help)
23:12:31 <shapr> I don't know either.
23:12:40 <shapr> but serialization is a separate issue from a generic server.
23:13:06 <ski> mm
23:13:27 <shapr> I'd be happy to start with udp and tcp arrows.
23:14:08 <ski> if the server's gonna be up for some time, i'll guess we'd want timeouts for registered callbacks ..
23:14:41 <shapr> right, a time arrow
23:14:44 <shapr> for scheduling
23:15:02 * ski 's little bro' knows more about udp and tcp than himself
23:16:45 <ski> mm
