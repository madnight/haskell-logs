00:10:13 <shapr> hej hej
00:10:29 <Maddas> Good morning
00:14:26 <shapr> hi!
00:58:15 * shapr cogitates on the subject of darcs repository browsers
02:03:33 <shapr> neat nickname
02:03:50 <det> I just think his 'i' key is stuck
02:25:56 <shapr> MonadPlus is cool
02:26:17 <apmuf> monads suck :)
02:26:34 <shapr> arrows rock out
02:28:11 <shapr> It might be said that Haskell with monads does not give you much that you won't find in an imperative, nondeterministic language, with extensible, strong, but generic typing, and a powerful applicative expression sublanguage. The problem is there is no such language in common use.
02:28:16 <shapr> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
02:35:02 <earthy> shapr: you might actually state `There is no such language'
02:35:32 <ibid> The problem is, the only such language is - Haskell. :)
02:35:43 <earthy> Haskell is not imperative. :)
02:36:06 <ibid> depends on your pov :)
02:36:45 <shapr> I realize that I now understand enough that I should read the haskell mailing list archives.
02:37:11 <ibid> besides, it's useless in practice to group languages into imperative, functional etc.  imperative, functional etc are programming styles, not language styles
02:37:19 <shapr> yup
02:38:00 * earthy agrees
02:38:17 <earthy> but every programming language affords a certain programming style
02:38:22 <earthy> better than others
02:38:33 <ibid> every programming language worth mentioning allows many styles
02:38:34 <earthy> and that style can then be said to apply to the programming language as well
02:38:51 <kowey> anyone use the language Oz?
02:38:56 <kowey> i hear it is very multi-style
02:39:35 <ibid> it just happens that usually communities grow around languages, and often a single style is prevalent in that community; and the style is then attributed to the language
02:39:55 <ibid> (not historically correct, but ideologically correct, that :)
02:46:02 <det> kowey: apparently the Oz people are now doing alice
02:46:24 <det> kowey: erm, mozart people
02:46:33 <det> kowey: which is oz concepts ontop standard ml
02:46:34 <kowey> alice? another language?
02:46:45 <det> yes, anotehr language
02:47:00 * kowey nods thoughtfully
02:47:01 <Maddas> yay
02:47:25 <det> http://www.ps.uni-sb.de/alice/
03:00:57 <shurik> are there any free to read books online?
03:01:02 <shurik> on haskell programming
03:02:04 <kowey> http://www.haskell.org/learning.html
03:02:20 <kowey> i'm new to haskell too; the Yet Another Haskell Tutorial is quite helpful
03:02:27 <shurik> 3 tutorials
03:02:39 <shurik> on that site which are concise
03:05:46 <Lemmih> shurik: www.haskell.org/complex helped me a lot.
03:06:33 <shurik> I went to our library today and couldn't find a book on Haskell
03:08:04 <shurik> too basic
03:08:07 <shurik> Lemmih 
03:08:44 <shurik> I'd be pleased if someone could scan a couple of chapters from Hudak's book:>
03:08:59 <Maddas> Buy it!
03:09:13 <shurik> no
03:09:23 <shurik> I don't want to own it
03:44:22 <shurik> haskell community do not make anything easy for newcomers, man many languages provide authority books for free
03:44:41 <earthy> such as?!
03:45:01 <Maddas> earthy: Perl, Objective Caml, Scheme if you count the SICP
03:45:10 <Maddas> although those aren't provided by the languages, of course
03:45:23 <earthy> okay, call me silly, but I thought the camel book was nowhere near free
03:45:35 <shurik> Java tutorial is about 3-4 books, Python, Ruby
03:45:43 <Maddas> earthy: http://caml.inria.fr/oreilly-book/
03:45:55 <shurik> someone mentioned Clean book yesterday
03:45:57 <earthy> camel, nat caml. :)
03:46:01 <earthy> camel == perl
03:46:08 <Maddas> oh, the camel.
03:46:10 <earthy> Programming Perl, to be more exact. :)
03:46:12 <Maddas> earthy: No, but Beginning Perl is free
03:46:15 <earthy> ah.
03:46:18 <Maddas> Since the publisher went out of business
03:46:27 <mattam> it benefits from O'Reilly's give-away politic for very standards or very small audience subject :)
03:46:34 <earthy> shurik: the current clean book is reasonably good
03:46:39 <earthy> and *directly* adaptable to haskell
03:46:47 <earthy> (the languages are very much alike)
03:46:48 <shurik> earthy if you read perl tutorials youd notice that Camel book 80% the same what's in those tutorials
03:47:13 <earthy> problem with the clean book is it suffers from bitrot
03:47:21 <Maddas> shurik: actually no, it's 80% of the perldocs
03:47:35 <earthy> (I saw the first drafts of it back in 1995 or somesuch... not much changed)
03:47:49 <Maddas> But I don't think one can blame anybody for not giving their book away for free
03:47:56 <shurik> tutorials in perldocs whatever you call it
03:48:50 <shurik> Maddas it's not upto the author
03:48:56 <earthy> shurik: and you may want to look into the functional programming coursenotes by Jeroen Fokker
03:48:58 <shurik> it's the publisher who decides
03:49:10 <Maddas> shurik: I never said it's up to the author
03:49:19 <shurik> and they get to keep 75% of the revenue maybe more
03:49:26 <Maddas> oh, well, maybe I implied it.
03:49:46 <Maddas> You also can't blame the publishers for not giving away their books for free, either, of course :)
03:50:14 <earthy> (truly, the stuff on http://www.haskell.org/learning.html is very good)
03:50:20 <Maddas> Is there any O'Reilly book about Haskell?
03:50:48 <Maddas> Safari doesn't have anything mentioning Haskell in the title :-(
03:50:54 <earthy> maddas: should there be?
03:51:11 <Maddas> earthy: I would like one, yes.
03:53:15 <swisscheese> Can someone tell me why this gives "Inferred type is not general enough"
03:53:15 <swisscheese> getWhile :: (a -> Bool) -> [a] -> [a]
03:53:15 <swisscheese> getWhile p [] = []
03:53:15 <swisscheese> getWhile p (x:xs) = (if p x then x else []) : getWhile p xs
03:56:01 <earthy> hm.
03:56:04 * earthy ponders
03:56:19 <earthy> no, I will not go to O'Reilly to propose a book on Haskell
03:59:39 <shurik> any good book on a subject is always welcomed
04:00:08 <shurik> and O'Reilly , usually, don't publish rubbish:>
04:02:14 <earthy> thing is, I have too many projects going on anyway
04:02:16 <Maddas> earthy: I don't say O'Reilly publishes better books, but if there wer a Haskell book by them I could read it with the safari subscription :-)
04:02:17 <Maddas> were, even.
04:02:30 <earthy> ;)
04:02:37 <earthy> good point
04:02:51 <earthy> and there *is* a noticeable gap in the books on Haskell
04:02:51 <Maddas> or if it were by one of the other publishers on that list. :0
04:02:54 <Maddas> s/0/)/
04:03:49 <earthy> (they take you up to basic proficiency but then stop when it gets to using libraries, designing libraries, setting up haskell code for distribution, integrating with C, stuff like that)
04:18:54 <shurik> Maddas how much do you pay for safari subscription?
04:19:47 <Maddas> I think it starts from $10 a month.
04:20:46 <shurik> interesting
04:20:53 <shurik> I may subscribe to it too
05:11:05 <shurik> :> Found a 2nd hand book in reasonable condt5ion for $15:>
05:11:14 <shurik> byt Simon Thompson
05:18:23 <earthy> that's a pretty reasonable book
06:35:51 <ski> hi
07:20:56 <Lemmih> Could someone guide me though a hasdl installation?
07:34:19 <ski> coee !
07:36:57 <eixei> hi
07:37:06 <ski> hi eixei
07:37:48 <ski> i saw you here before, the other day, right ?
07:37:59 <eixei> I think so :-)
07:38:32 <eixei> I've been here a couple of times
07:45:32 <eixei> Could you recommend me a channel where I could ask a question about boolean algebra? :-)
07:45:55 <andersca> is it a hard question?
07:45:57 <ski> i dunno many channels
07:46:23 <eixei> no, not very, it's just one of the "rules"(do you call them like that in english?) that I don't manage to understand
07:46:41 <ski> laws ?
07:46:54 <eixei> I'll just post it :-)
07:47:03 <ski> ok, fine with me :)
07:47:49 <ski> (if not *too* big)
07:48:00 <eixei> it was: x or (y and z) = (x or y) and z if x =< z
07:48:15 <eixei> I just don't get what they mean by x =< z :-/
07:48:35 <eixei> is true > false?
07:48:50 <eixei> Or what do they mean?!? *is completely lost*
07:48:53 <ski> i would think so
07:49:18 <Igloo> It's not x => z?
07:49:19 <ski> isn't x =< z the same as x and z = x ?
07:50:00 <eixei> no it says that x is smaller/equal z Igloo :-/
07:50:42 <Igloo> My guess would be they meant => (implies)
07:51:05 <Igloo> Especially as I'd write <= for less than or equal to
07:51:32 <eixei> Well, they did write the less than or equal sign, and several pages in the net did so too :-/
07:51:36 <ski> perhaps they wrote a one-symbol glyph ?
07:52:17 <eixei> yep, the < and equal on the same symbol (gosh, it's hard to explain *g*)
07:52:32 <ski> well, by distributivity (x or y) and z = (x and z) or (y and z)   isn't that so ?
07:52:43 <eixei> yep
07:53:16 <ski> so if we assume  x =< z  is the same as  x and z = x  (as i said above)
07:53:33 <ski> then (x or y) and z = (x and z) or (y and z) = x or (y and z)
07:53:50 <ski> i.e.  x or (y and z) = (x or y) and z
07:53:50 <Igloo> Going the other way makes more sense. x or (y and z) = (x or y) and (x or z)
07:54:16 <eixei> hmm, I see...
07:54:21 <Igloo> Then it suffices to show x or z is true whenever z is
07:54:28 <ski> Igloo : but then you have  x =< z  <==>  x or z = z   eh ?
07:54:55 <eixei> I'll do some "truth tables" (again, english problems... *argh*) to see it a bit clearer
07:55:02 <Igloo> s/whenever/exactly when/
07:55:06 <eixei> thanks a lot Igloo and ski!
07:55:17 <ski> i.e.  x =< z  <==>  x and z = x  <==>  x or z = z
07:55:47 <eixei> hi Heffalump
07:55:53 <Heffalump> 'lo
07:55:54 <Igloo> ski: If x => z then x or z = z
07:55:59 <Heffalump> and darcs experts around?
07:56:23 <Igloo> I haven't thought about other possible interpretations of =<
07:56:31 <Heffalump> s/and/any/
07:56:59 <ski> eixei : note that it isn't necessarily the case, for any boolean algebra, (for all x,y) that  x =< y  or x >= y.   they could be incomparable
07:57:38 <ski> Igloo : that '=>' is implication, right ?
07:57:42 <Igloo> Yup
07:58:32 <Darius> eixei: truth tables is exactly the English term.
07:58:35 <ski> Igloo : (it doesn't make sense if '=>' were greater or equal)
08:00:21 <cybermanco> hello
08:00:29 <cybermanco> somebody to help me?
08:00:43 <ski> sure
08:00:51 <ski> with what ?
08:00:58 <cybermanco> I have this data type:
08:00:59 <cybermanco> data QTree = Empty | Leaf Section | Node Coords QTree QTree QTree QTree
08:01:12 <cybermanco> and I want the in an out func
08:01:33 <ski> "the in an out func" ?
08:01:37 <cybermanco> but I never did for data with 3 kinds..
08:01:43 <cybermanco> hm
08:01:45 <cybermanco> wait..
08:02:24 <cybermanco> imagine this data: data LTree a = Leaf a | Split (LTree a, LTree a)
08:02:35 <ski> yes
08:02:37 <cybermanco> in and out
08:02:40 <cybermanco> is this:
08:02:40 <cybermanco> inLTree = either Leaf Split
08:02:41 <cybermanco> outLTree :: LTree a -> Either a (LTree a,LTree a)
08:02:41 <cybermanco> outLTree (Leaf a)     = i1   a
08:02:41 <cybermanco> outLTree (Split (t1,t2)) = i2    (t1,t2)
08:02:55 <ski> aha
08:03:03 <Darius> Why do you want to do that?
08:03:22 <cybermanco> Darius: because I must do for my school project :\
08:03:28 <ski> cybermanco : must you use the Either type for QTree ?
08:03:37 <eixei> oh. sorry, was just away trying it out, nice to know I got exactly the right term, and ski, thanks a lot for the infomation
08:03:51 <ski> or can you use your own, say, Either3 type ?
08:04:16 <Darius> Or you could express QTree as a fixpoint and have a generic in and out.
08:04:18 <cybermanco> either Empty (either Leaf Node)
08:04:19 <cybermanco> ?
08:05:29 * Darius has no idea why your instructor would want you to do this as it is completely unnecessary and will make the code more complicated.
08:05:41 <ski> eixei : IIRC you can think of 'and' as giving the greatest value less than the args of and (the greatest lower bound, glb), mutatis mutandis for or (the least upper bound, lub)
08:05:42 <cybermanco> Darius: i agree
08:06:38 <cybermanco> I need this funcs to create hylo and ana and cata funcs..
08:07:02 <eixei> ski: oh, I see... thanks a lot ski, never really saw it that way, it certainly makes it easier to understand
08:07:43 <ski> cybermanco : should  outQTree :: QTree -> Either () (Either Section (Coords,Qtree,QTree,QTree,QTree))  ?
08:08:24 <cybermanco> hm
08:08:44 <ski> eixei : also IIRC, the lub is often written roughly like |_|, and the glb as that turned upside-down
08:09:50 <eixei> cool, do you have any book/website you could recommend me about it ski=
08:09:52 <eixei> *?
08:10:02 <ski> eixei : (kinda like a squary-like U, remindful of the \/ symbol for or)
08:10:46 * ski doesn't know if the word 'remindful' exists
08:11:01 * ibid wears an hacker emblem t-shirt, me is 1337 :)
08:11:08 <eixei> I get what you mean ski :-)
08:11:37 <ski> ibid : the conway life thing ?
08:11:41 <ibid> yeah
08:13:04 <ski> eixei : well, hm, not sure. i guess there are info on this on the www somewhere, though i don't think i have any links handy. sorry
08:13:33 <ski> eixei : guess you could always search around a little
08:13:53 <eixei> ski: I definitely will, thanks a lot for your pointers
08:15:05 <ski> cybermanco : got it working ?
08:15:14 <cybermanco> not..
08:15:22 <cybermanco> I think I will not use this..
08:15:34 <ski> use what ?
08:15:45 <cybermanco> in out hylo etc funcs
08:16:03 <ski> weren't you required to ?
08:17:10 <cybermanco> I don't know yet... what I know is that if I use this I get a better classification in my project
08:17:26 <ski> classification ?
08:17:37 <cybermanco> hm
08:17:40 <cybermanco> note..
08:17:43 <cybermanco> hm
08:18:02 <cybermanco> leet me sse in the dictionary
08:18:14 <eixei> more points :-)
08:18:18 <cybermanco> yes
08:18:44 <eixei> "a better mark" afaik :-/
08:18:49 <cybermanco> mark
08:18:53 <cybermanco> yes
08:19:27 <cybermanco> what is afaik?
08:19:29 <ski> cybermanco : you've seen "The Evolution of a Haskell Programmer" ?
08:19:36 <cybermanco> ski: yes
08:19:47 <ski> cybermanco : AFAIK = As Far As I Can Tell
08:20:12 <Marvin--> ski: no, AFAIK = As Far As I Know
08:20:24 <Marvin--> ski: As Far As I Can Tell would be AFAICT :)
08:20:39 <ski> oops :) my brain short-circuited
08:20:43 <ski> haha
08:23:42 <eixei> lol, I still have a lot to learn, I would use the "Another junior Haskell programmer" approach *g*
08:25:05 <cybermanco> looks like I trying to use Cartesianally-inclined Haskell programmer style.. :\
08:25:27 <eixei> rotfl @ Interpetive Haskell programmer *g*
08:32:13 * Marvin-- is part of the "ban n+k patterns" movement too, but would probably use the accumulating version, or most likely the tenured professor version
08:32:50 <Marvin--> I still love the prod against pointless^H^H^H^Hfree programming :)
08:33:00 <eixei> lol
08:34:04 <eixei> hi viblo
08:34:48 <viblo> hi
08:38:38 <Jad> any one here read the book "The Haskell School of Expression" ?
08:39:50 <ski> i think some people here have it. not me though :(
08:40:04 <ski> anything you wanna comment on, in it ?
08:40:13 <ned> Jad: 2 friends recommended it to me recently
08:40:34 <cybermanco> I have Introduction to Functional Programming using haskell and other..
08:40:48 <ned> (one is functional programming teacher)
08:41:04 <Jad> okay
08:41:19 <Jad> shall i recomend it to a friend of mine ?
08:41:24 <Jad> he is new to programming
08:41:28 <ned> i think so :)
08:41:43 <ned> i dunno how hard it is
08:44:05 <ski> i have Thompson's and think it's quite good. (but then i havn't anyelse to compare with :)
09:00:00 <cybermanco> someone here knows some opensource haskell program that works with QuadTrees?
09:55:37 <phubuh_> testing
10:31:17 <ecraven> c
10:31:39 <ski> u
10:32:33 <Marvin--> c? y?
10:33:10 <ski> Marvin-- : don't ask me. ecraven started it
10:37:18 <ecraven> sorry.. should have been /c(lear)
10:38:15 <eixei> lol
10:38:22 <ski> ecraven : i imagined that you were doing a "CUl8r" thing
10:38:57 <ski> sorta, singalong
10:41:06 <Marvin--> whee, amazingly enough it seems like we'll manage to get a RPG session going tomorrow
10:41:44 <ecraven> i'd like to do that again.. can't find anyone here though..
10:41:54 <ski> Marvin-- : whee is not on this channel, that i can see
10:42:20 <ski> ecraven : huh ?
10:42:22 <Marvin--> ski: FYI I use ":" rather than "," for adressing people directly
10:43:10 <ski> some ppl use , at least at times
10:43:13 <Marvin--> ski: so spare me your wit :)
10:43:26 <ski> heh
10:44:35 * ski grins
11:06:12 <stepcut> yuck! car repairs!
11:08:33 <SyntaxNinja> stepcut: word!
11:08:48 * SyntaxNinja has been taking the bus for the last couple of days :(
11:10:34 * Marvin-- pats his bike
11:13:04 <SyntaxNinja> if they would put salt on the sidewalks and the sides of the road, I might be able to bike int he winter...
11:13:09 <SyntaxNinja> as it is, I fear for my lif
11:13:09 <SyntaxNinja> e
11:13:14 <Marvin--> ah
11:13:18 <Marvin--> that works pretty well here
11:13:58 <Marvin--> good thing, though, is that I don't have more than 30 minutes on foot to the institution so I don't *have* to take the bus when my bike's broken
11:14:40 <ski> Marvin-- : I envy you :)
11:16:07 <stepcut> I have to get a 60,000 mile tune-up (which is ~$400), but I am also having  difficulties  starting the car -- so who knows how much that will be
11:16:20 <ski> Marvin-- : I bike from Västra Frölunda (almost)
11:16:31 <stepcut> and I like in an apartment, so I can't really work on the car myself
11:16:50 <Marvin--> ski: that's quite a distance, but certainly doable
11:17:52 <ski> Marvin-- : as long as the weather and the road isn't too bad, I don't complain
11:19:10 <ski> Marvin-- : so it's a good thing that most of the snow, slush and ice have rained away by now (and the rain stopped)
11:20:19 <Marvin--> yah
11:20:23 <ski> (the gravel is still irritating though)
11:21:09 * ski hates gravel on asphalt roads
11:23:05 <Marvin--> aiiiih, what lousy timing
11:23:22 <Marvin--> Viktoria Tolstoy at Nefertiti tomorrow
11:23:30 <ski> ?
11:23:58 <Marvin--> incredible jazz singer?
11:24:12 <Igloo> I don't really understand the anti n+k brigade
11:25:02 <Heffalump> well, it is an anomaly
11:25:10 <Heffalump> we should either have proper views or not have a single hack like that
11:25:22 <ski> Marvin-- : i don't know
11:25:57 <Igloo> Oh, if it's pro something more generic then I'd understand that
11:26:00 <ski> Igloo : isn't one problem to see which symbol/identifier is being defined ?
11:26:12 <Marvin--> ski: no, the k is a number, the n is a variable ;)
11:26:17 <Marvin--> ski: wasn't that obvious? ;)
11:27:28 <ski> Marvin-- : ?
11:27:49 <Marvin--> ski: "x+3" is an n+k pattern
11:28:04 <Marvin--> ski: "x+y" isn't
11:28:05 <Heffalump> "x+k" isn't.
11:28:05 <ski> Marvin-- :  a + 2 + 3 = ...   or something ..
11:28:13 <Heffalump> it actually took me quite a while to figure this out
11:28:22 <Heffalump> that's a good point, how about (n+1)+1 ?
11:28:52 <Marvin--> you have to read the report carefully, the k is in italics and the n isn't, or the other way around, I don't remember
11:28:55 <ski> Marvin--,Heffalump : i know
11:30:08 <SamB> Heffalump: if you consider n+k deprecated, it is no problem!
11:30:10 <Marvin--> so yeah, yes to more general views, no to specific hacks that clutter the grammar in the report
11:30:29 <Heffalump> there's arguments against more features too, of course
11:31:12 * Igloo is just against complete abolition, although  don't think I've ever wanted to do anything other than n+k
11:31:28 <ski> Marvin-- : to that i can concur
11:32:25 <Marvin--> I just don't see the point to n+k, since there's no type for natural numbers, n+1 doesn't mean "non-zero" anyway
11:33:33 <ski> IMUO there should be a Nat and a Natural
11:34:46 <ski> Marvin-- : well, mustn't n be nonnegative in the n+k pattern "n+1" ?
11:35:23 <Marvin--> I sure hope not, that'd be a special case of a special case
11:35:48 <Marvin--> omg, you're right
11:35:50 <Marvin--> that's even uglier
11:35:51 <SamB> ski: then Num n wouldn't have (-) :: n -> n -> n
11:36:03 <ski> Marvin-- : see ?
11:36:38 <Marvin--> well, if there ever was a possibility of getting me out of the anti-n+k camp, it just went away
11:36:42 <Igloo> Marvin: It's nice for things like implementations of the layout rule, which is specified in the report using n+k patterns in pseudo code
11:37:42 <ski> SamB : well, then we would have the god-given numerical classes instead of this infirmity
11:38:26 <Heffalump> n+k patterns are intended for simulating the obvious algebraic definition of the natural numbers
11:38:35 <Heffalump> I think they should just apply to Int and Integer, myself
11:38:42 <ski> so we should have naturals
11:39:05 <Heffalump> algebraically defined naturals would be _slow_
11:39:09 <Heffalump> anything else would be a hack
11:39:12 <ski> why ?
11:39:23 <Heffalump> + takes linear time...
11:39:36 <ski> just optimise it
11:39:44 <Marvin--> *cough*optimizingcompiler*cough*
11:39:54 <ski> hehe
11:40:03 <Marvin--> we could use some optimization for strings too
11:40:07 <Heffalump> that wouldn't provide a guarantee of fast implementation
11:40:44 <ski> Heffalump : we could use a similar implementation as Integer probably has
11:40:54 <Heffalump> but Integer doesn't allow partial numbers
11:40:56 <ski> (i.e. for the unbounded Natural type)
11:40:58 <Heffalump> which naturals would
11:41:10 <ski> "partial numbers" ?
11:41:23 <Heffalump> data Nat = Zero | Succ Nat
11:41:27 <Marvin--> Succ _|_ and stuff
11:41:33 <Heffalump> Succ (Succ _|_) is a partial number
11:41:39 <Heffalump> we know it's at least 2, but nothing else
11:41:52 <ski> well, hmm. that could be a problem, yes
11:42:58 <ski> one could perhaps store a pair of some Integer-alike thing and a thunk
11:43:26 <ski> updating the first part whenever the thunk yields Succ's
11:44:03 <ski> hmm, is there some way of using ! or something to declare away these partial numbers from the type
11:44:42 <Igloo> ! would mean there were no partial numbers, but that would be undesirable
11:44:45 <ski> i'd perhaps figure we really didn't want them there in the first place, if this was supposed to be real naturals
11:45:10 <Heffalump> well, we don't have partial Integers either
11:45:27 <ski> Igloo : is there e.g. partial Integers or Ints (not counting full bottom) ?
11:45:41 <Heffalump> no.
11:46:10 <ski> so if we wanted a Natural that was similar in behaviour to Integer
11:46:45 <ski> and wanted facade constructors for it, then we'd probably not want all those partial numbers
11:47:50 * ski has even thought about optimising things like data X = N | A X | B X  :)
11:47:51 <Marvin--> now that'd be a use for n+k patterns :-P
11:47:58 <Marvin--> _|_+3
11:48:09 <ski> haha
11:48:32 <Marvin--> 'course, then you'd want n-k patterns too
11:48:43 <ski> but the _|_ must be nonnegative
11:49:33 <Marvin--> and what about n*k patterns? :)
11:49:36 <ski> for Integers, that would be the natural thing, yes  (and no > or < constraints on Integer)
11:49:58 <ski> k mustn't be 0
11:50:57 <ski> sometimes i've wanted a pattern like :  "whatever" ++ str
11:51:11 <Marvin--> oh yes, which is why views are interesting
11:51:11 <SamB> how about n*k+l patterns?
11:51:31 <Marvin--> yes! let's implement the division algorithm in the pattern matching engine
11:52:02 <Marvin--> heck, if we could have variables multiple times this could make gcd much easier to implement ;)
11:52:05 <ski> SamB : why not, though that wouldn't be a special case, but a composition of simpler cases
11:52:21 <SamB> ski: hmm, maybe.
11:52:37 <ski> Marvin-- : using == for equal check, then ?
11:52:46 <Marvin--> heck if I know
11:52:56 <ski> that's the problem
11:53:19 <ski> (i.e. what equality to use, not that you don't know ;)
11:54:44 <ski> the same problem also occurs when one wants to match against an (otherwise) already bound variable
11:55:02 <ski> Erlang has this, IIRC
11:56:50 <Heffalump> well, given the Eq class exists it's not unreasonable to use it
11:57:16 <ski> i guess
11:58:09 <ski> declaring a new/replacement instance over a local scope might help flexibility here ..
11:58:50 <ski> Coee !
11:59:07 <ski> wasn't there someone here that had used Mercury ?
11:59:50 <Darius> Yes.
12:00:03 * ski wonders to what extent this kind of thing might be possible there
12:00:41 <ski> well, how is the append function written ?
12:00:44 <Darius> I'm not that someone, by the way and I'm taking a generalized view of "here".
12:00:50 <ski> ok
12:01:50 <ski> anyway, i though, perhaps one can declare backward modes for append (the function)
12:02:22 <ski> and then use them in function/predicate heads
12:03:17 <ski> so one could possibly even use whatever corresponds to a "xs ++ ys" pattern (binding both xs and ys)
12:03:33 <ski> that would of course be nondeterministic
12:12:54 <cybermanco> hello
12:13:07 <ski> hi
12:13:10 <cybermanco> I have one simple question
12:13:13 <ski> mm
12:13:14 <cybermanco> I have a function
12:13:28 <cybermanco> that returns
12:13:31 <cybermanco> data Pixel = Pix Colour
12:13:33 <cybermanco> a pixel
12:13:35 <cybermanco> but
12:13:42 <cybermanco> I only need the colour part
12:13:49 <cybermanco> how do I get it?
12:13:52 <monotonom> write
12:13:54 <monotonom> the
12:13:56 <monotonom> following
12:13:59 <monotonom> function
12:14:00 <monotonom> :
12:14:10 <monotonom> colour
12:14:11 <ski> monotonom : hahaha !
12:14:14 <monotonom> (Pix
12:14:18 <monotonom> c)
12:14:21 <monotonom> =
12:14:22 <monotonom> c
12:14:32 <cybermanco> I see :)
12:14:34 <cybermanco> thanks
12:16:03 <cybermanco> how do I div an int?
12:16:12 <phubuh> @type div
12:16:13 <lambdabot> div :: Integral a => a -> a -> a
12:16:21 <cybermanco> Int
12:16:30 <monotonom> 5 `div` 3
12:16:31 <cybermanco> is Integral?
12:16:42 <monotonom> or div 5 3 will also do
12:29:19 <cybermanco> how can I get random numbers?
12:30:01 <cybermanco> @type rand
12:30:21 <ski> module Random, perhaps
12:30:39 <phubuh> randomRIO (minimum, maximum)
12:30:42 <phubuh> @type randomRIO
12:30:50 <phubuh> @type Random.randomRIO
12:30:53 <phubuh> bah.
12:31:25 <ski> randomRIO :: Random a => (a,a) -> IO a
12:38:39 <cybermanco> @type &&
12:38:49 <ski> @type (&&)
12:38:50 <lambdabot> (&&) :: Bool -> Bool -> Bool
13:37:06 * shapr waits to get flamed by the arch users on the pragprog mailing list.
13:37:19 <andersca> hi shapr
13:37:27 <shapr> I sent an email that says "darcs is preferable to arch because of simplicity and better cherry picking of patches"
13:37:39 <shapr> hi andersca 
13:37:45 <shapr> I bet I get flamed :-)
13:37:50 <shapr> anyways, movie time
13:38:10 <Riastradh> shapr, tell tomlord on this network!
13:38:39 <shapr> after the movie maybe.
13:48:07 <Marvin--> my laphroaig bottle won't last much longer now :(
13:48:34 <ski> what's that ?
13:48:39 <Marvin--> whisky
14:34:43 <earthy> laphroaig.... hmmm.
14:34:53 <earthy> that reminds me of my bowmore mariner
14:35:03 <earthy> which is calling my name *right*now*
14:41:27 <Marvin--> go!
14:42:03 <earthy> well, given that the wine that accompanied the rijsttafel is definitely making itself known I think that might not be wise
14:44:05 <Marvin--> d'oh
14:44:26 <earthy> okay, you just convinced me
14:44:48 <ski> earthy : what's rijsttafel ?
14:44:51 <earthy> now I can dedicate myself to playing around with lifting Haskell to HOL tomorrow.
14:45:01 <earthy> ski: it's a combination of indonesian dishes
14:45:20 <earthy> basically, rice and a number of meat and vegetable dishes
14:45:21 <ski> (isn't taffel or something like that a german word for meal ???)
14:46:00 <ski> (or is rijsttafel a kreole word ? pidgin ?)
14:46:11 <ski> ok
14:46:12 <ecraven> seems dutch..
14:46:15 <earthy> no, rijsttafel is dutch for rice table
14:46:25 <earthy> but that is really the only word for it, afaik
14:46:32 <ski> the 'ij' looked duthch yes
14:46:35 <ski> dutch
14:46:42 <earthy> it was developed when the dutch ruled indonesia
14:48:21 <earthy> and it's pretty easy to cook. :)
14:49:59 <earthy> anyway, time to give in to the last temptation of the night
14:50:38 <ski> mm
14:50:43 <Marvin--> ski: taffel is a perfectly valid Swedish word as well
14:50:48 <ski> good night, earthy
14:51:25 <ski> Marvin-- : i know. that's why i thought it might've come from german
14:51:46 <Marvin--> ah
14:52:45 <earthy> what's taffel mean? something from the same stem as tafl? (as in hnefatafl, the game)
14:53:47 <ski> methinks it could well come from the same root as table in english
14:53:58 * earthy nods
14:54:21 <earthy> and this still leaves me wondering what `taffel' means. :)
14:54:26 <ski> what language is tafl and hnefatafl ?  icelandish ?
14:54:42 <earthy> old norse
14:55:13 <ski> roughly the same :)
14:56:25 <earthy> oh well, almost midnight
14:56:30 <ski> 'twas a long time ago i visited iceland
14:56:34 <ski> yes
14:56:41 <earthy> I could say that I've never visited iceland
14:56:56 <earthy> (and it'd even be true ;))
14:56:58 <ski> it's an interesting land
14:57:21 <earthy> from what I hear of it I know I'll have to visit it once
14:57:33 <ski> i remember picking up sulphur from the ground
14:58:18 <earthy> I remember the sulfur harvesters in Indonesia. that was a nasty job
14:58:36 <earthy> but, night all
14:58:45 <ski> and they have active volcanoes (jöklar) and Europe's largest glacier
14:58:53 <ski> yes, night
15:00:45 <ski> (of course glaciers is "jöklar", sorry to confuse it)
15:02:38 <ski> (sometimes a volcano erupts under Vattnajökull (the big glacier) ! then there comes enormous amount of melt-water, splashing away roads :)
15:08:02 <ski> (That's called "jökellopp")
17:00:16 <stepcut> when I try to run the example on the top of this page: http://www.haskell.org/arrows/syntax.html
17:00:37 <stepcut> ghci says: parse error on input `->'
17:00:55 <Igloo> Are you using a flag that would turn arrow mode on?
17:01:14 <stepcut> -fglasgot-exts? or do I need something else?
17:01:32 <Igloo> I don't know
17:01:33 <Heffalump> -farrows I think
17:01:44 <Heffalump> though glasgow-exts might give it too, I'm not sure
17:02:20 <stepcut> apparently I also need -farrows, thank
17:02:22 <stepcut> s
17:08:57 <ham[nwn]> Heffalump is Heffalump a name from dumbo?
17:09:13 <Heffalump> no, from Winnie the Pooh
17:09:21 <ham[nwn]> ah right
17:09:27 <ham[nwn]> and what is it again?
17:09:37 <Heffalump> elephant type thing
17:09:42 <Riastradh> A heffable horralump!
17:09:54 <ski> (missing k IIRC)
17:09:55 <Heffalump> hmph.
17:10:12 <Heffalump> Riastradh is nasty. I'm not talking to him any more.
17:10:29 <ski> (or perhaps that was only the swedish translation)
17:10:55 <Igloo> Where does the k go?
17:11:14 <ski> Heffaklump, if i indeed recall correctly
17:11:22 <Heffalump> umm, I doubt it
17:11:42 <Heffalump> try googling for Heffaklump, it corrects you to Heffalump
17:11:43 <Igloo> Me too, but I've never read it
17:11:55 <ski> hmm, klump in swedish is lump in english
17:12:03 <Heffalump> ah.
17:12:15 <ski> that probably explains it
17:12:18 <Heffalump> yes, it probably was the swedish translation then :-)
17:12:45 * ski grins
17:15:18 <ski> http://www.acc.umu.se/technical/hosts/host/heffaklump.html :)
17:15:46 <ski> and google finds a lot of other heffaklumpar
17:19:08 * Darius is reminded of http://www.albinoblacksheep.com/text/victories.html
17:19:15 <ski> whereof one is about fictive names in child's literature and linguistics
17:20:47 <ski> hehe
17:33:22 <stepcut> what is the difference between: fptools/libraries/base/Control/Arrow and fptools/libraries/arrows/Control/Arrow? The latter seems to have more stuff (like Control.Arrow.Operations, which contains ArrowCircuit), but also does not appear to be built or used...
17:35:54 <stepcut> this page indicates I should be able to use ArrowCircuit in 6.2, but it does not work for me: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
17:36:22 <cybermanco> How do I transform a float in a Int?
17:36:47 <ski> which way ?
17:37:05 <ski> truncate ? round up ? round down ? round to nearest ?
17:37:31 <cybermanco> round up
17:38:05 <ski> @type ceiling
17:38:05 <lambdabot> ceiling :: (RealFrac a, Integral b) => a -> b
17:38:35 <cybermanco> thanks
17:48:51 <cybermanco> what means this error:
17:49:13 <ski> yes ?
17:49:16 <cybermanco> parse error (possibly incorrect indentation)
17:49:16 <cybermanco> ?
17:49:32 <ski> just that, i suppose
17:50:00 <cybermanco> hm
17:50:00 <ski> perhaps you can paste a few lines around the line the error occured on
17:50:26 <cybermanco> and
17:50:51 <cybermanco> no instance for (RealFrac, Int) arising from usa of ceiling
17:50:52 <cybermanco> ?
17:51:21 <ski> ErrM> ceiling (1 :: Float) :: Int
17:51:22 <ski> 1 :: Int
17:51:28 <ski> seems to work for me
17:52:02 <ski> which type are you trying to convert to which other type (using ceiling)
17:52:28 <ski> if it really tries to convert Float -> Int, then i think it should work ..
17:52:52 <ski> um
17:53:19 <cybermanco> I am doing (ceiling ((x + 1) * s))
17:53:20 <ski> well, it looks like the error says you are trying to convert an Int with ceiling
17:53:23 <cybermanco> x is Int
17:53:27 <cybermanco> and s is Float
17:53:42 <ski> that doesn't work
17:53:46 <cybermanco> why?
17:54:06 <ski> you can't multiply two values of different type
17:54:21 <cybermanco> then how do I do this?
17:54:26 <ski> (there are no implicit conversions for numeric types in haskell)
17:54:50 <ski> (ceiling (fromIntegral (x + 1) * s))
17:54:54 <ski> perhaps
17:55:09 <ski> @type fromIntegral
17:55:09 <lambdabot> fromIntegral :: (Integral a, Num b) => a -> b
17:55:19 <ski> @type fromInteger
17:55:20 <lambdabot> fromInteger :: Num a => Integer -> a
17:55:25 <ski> @type fromInt
17:55:25 <lambdabot> fromInt :: Num a => Int -> a
17:55:33 <cybermanco> nop
17:56:09 <cybermanco> it says variable not in scope fromInt
17:56:15 <ski> i seem to recall that either fromInt or toInt (or both) aren't in the haskell98 standard
17:56:21 <ski> ok
17:56:27 <ski> then use fromIntegral
17:56:38 <ski> that should work, i think
17:57:07 <cybermanco> nop
17:57:12 <ski> nope ?
17:57:24 <cybermanco> no instance for (RealFrac Int)
17:57:43 <Darius> even if fromInteger and fromInt were defined, there is no reason to use anything but fromIntegral.
17:58:08 <ski> ErrM> :t \x s -> (ceiling (fromIntegral (x + 1) * s))
17:58:08 <ski> \x s -> ceiling (fromIntegral (x + 1) * s) :: (Integral a, Integral b, RealFrac c) => a -> c -> b
17:58:19 <Heffaklump> darius: well, it might save an explicit type annotation
17:59:25 <cybermanco> so
17:59:29 <cybermanco> what is the solution?
17:59:30 <ski> cybermanco : what do you have now ?
17:59:31 <Darius> Only if for fromInt or if the default is not Integer and even then not very likely.
17:59:35 <ski> Darius : ok
17:59:37 <cybermanco> no instance for (RealFrac Int)
17:59:46 <cybermanco>   (ceiling ((fromIntegral (x + 1)) * s))
17:59:49 <cybermanco> when I do this
18:00:31 <cybermanco> s is Float
18:00:32 <ski> i think it perhaps thinks that s is an Int
18:00:45 <Darius> Considering you're first error, I'd think s isn't a Float or else you'd have gotten a conflict between x and s.
18:01:05 <ski> 'cause ceiling is prob. the one introducing the RealFrac constraint
18:01:18 <Darius> @type ceiling
18:01:18 <lambdabot> ceiling :: (RealFrac a, Integral b) => a -> b
18:01:33 <Darius> What does :type s say?
18:01:44 <ski> (i.e. the constraint that shows up in the error)
18:01:58 <cybermanco> hm
18:01:59 <cybermanco> (ceiling ((fromIntegral (x + 1)) * fromIntegral(s)))
18:02:02 <cybermanco> this works..
18:02:16 <ski> so the type of s is an instance of Integral
18:02:23 <ski> i'll bet it is an Int
18:02:39 <Darius> There's no need to bet ski, unless he changed his defaults.
18:03:11 <ski> Darius : manner of speech
18:04:27 <ski> cybermanco : so either s should really be an Int, and you just thought it should be Float. or you are somewhere (else) forcing it to be Int
18:07:20 <Darius> cybermanco: On a side note, you have all kinds of superfluous parentheses.  The above can be rewritten: ceiling (fromIntegral (x+1) * fromIntegral s)
18:08:41 <ski> cybermanco : do you have type-signatures on (most) of your functions (and other constants) ?
18:08:56 <cybermanco> it is working
18:09:01 <ski> ok
18:09:03 <ski> fine
18:09:24 <ski> were you forcing s to be Int, somewhere ?
18:10:00 <ski> or do you know now what the problem was ?
18:17:52 <cybermanco> I was forcing it
18:18:01 <ski> ok
18:22:06 <cybermanco> how do I convert float to Int to the nearest?
18:22:15 <ski> @type round
18:22:16 <lambdabot> round :: (RealFrac a, Integral b) => a -> b
18:22:32 <ski> @type floor
18:22:32 <lambdabot> floor :: (RealFrac a, Integral b) => a -> b
18:22:45 <ski> floor is for rounding downwards
18:23:13 <ski> @type truncate
18:23:13 <lambdabot> truncate :: (RealFrac a, Integral b) => a -> b
18:23:49 <ski> and that is for truncation  (rounding towards 0, if i'm not completely worng)
19:02:16 <ski> hello jiwon
19:03:08 <ski> hmm
19:03:35 <ski> good morning #haskell !
19:28:18 * Yosomono pokes shapr
19:39:39 <cybermanco> how do I debug in ghc?
19:45:27 <Darius> http://www.haskell.org/libraries/#tracing
19:48:12 <shurik> there's an example member (x:xs) y = ( x ==y) \/ member xs y, what does the operator '\/' do in this expression?
19:48:44 <Darius> It's not a standard function, so whatever it's defined to do.  Presumably it's ||.
19:49:07 <shurik> there's no defintion for it in the code
19:50:15 <shurik> came out of P wadler's paper on 'how to make ad-hoc polymorhism less ad-hoc'
19:51:09 <shurik> looks like an escape for '/' symbol
19:51:25 <Darius> It's a legal operator.
19:51:39 <Darius> @type let a \/ b = 0 in (\/)
19:51:40 <lambdabot> let {$0 \/ $0} in (\/) :: Num a => b -> c -> a
19:52:08 <Darius> That paper is really old, perhaps \/ was a standard operator in earlier versions of Haskell.
19:52:21 <Darius> As I said though, it's likely equivalent to ||.
19:52:25 <Darius> @type (||)
19:52:26 <lambdabot> (||) :: Bool -> Bool -> Bool
20:17:23 <shapr> good morning #haskell!
20:17:30 <shapr> yo yo Yosomono 
20:18:06 <det> Yosomono: hi!
20:18:18 <SamB> wha? Yoso in here?
20:18:55 <det> crazy, huh
20:19:39 <shapr> you guys surprised to see Yosomono outside of #python? :-)
20:20:41 <SamB> well, yes ;-)
20:22:26 <det> more specificly, in #haskell
20:23:31 <SamB> I wouldn't have been too surprised if he was in a #python-allied channel, that is, er, #twisted
20:23:55 <shapr> maybe it's the significant whitespace?
20:25:02 <det> I would be somewhat surprised to see him in #twisted
20:25:11 <SamB> does he actually *use* python?
20:25:18 <det> no
20:25:31 <det> it is too inherently open-source
20:26:18 <shapr> cool, there's a picture of Dennis Björklund on orkut
20:27:22 <shapr> the of blackdog, aka Mark Wotton, is great
20:27:53 <shapr> huh, Bastian Zapf is on orkut too
20:27:53 <shapr> wow
20:29:50 <shapr> so I was thinking about a naive but not stupid way to build an index of words in an email archive
20:30:11 <shapr> haskell.org has *lots* of mailing list archives
20:31:28 <shapr> so, I'd guess if you don't want to blow your ram, incrementally updatable indices are best.
20:34:00 <shapr> I'm having a snöverdose.
20:34:48 <shapr> or I could just throw it into postgresql and use HaskellDB
20:39:41 <shapr> hi darius-
20:39:43 <shapr> good morning!
20:39:47 <darius-> evening shapr
20:40:31 * darius- is wishing valgrind ran on windows right now
20:40:45 <shapr> g'day mwotton, long time no see
20:41:02 <shapr> darius-: you want valgrind on ScannedInAvian?
20:41:18 <darius-> that'd be nice, but i'd need X working here to use it for this program, i think
20:41:30 <shapr> ssh -X
20:41:40 <SamB> who knows prolog?
20:41:48 <darius-> samb - ask away
20:41:58 <shapr> too bad you can't fake an X server and then VNC to it.
20:42:19 <mwotton> g'day shapr. yeah, i've been busier than a one-legged man in a pool comp
20:42:26 <darius-> shapr - actually for this job i don't need to see the display, i just need an x server for the silly thing to connect to
20:43:13 <shapr> blackdog: I thought you were doing part of the C-- backend?
20:44:04 <SamB> what about x0rfbserver ?
20:44:06 <blackdog> yep. somehow i got dragooned :)
20:44:22 <shapr> Cmm looks like fun.
20:44:31 <SamB> oh. hmm.
20:44:36 <blackdog> i wrote a stix backend ages ago and spj asked don and me to retarget it. going to have a hack this weekend.
20:44:46 <SamB> xvfb
20:44:58 <shapr> darius-: I'll valgrind it if you'll send it to me
20:45:16 <darius-> hm, xvfb sounds nice
20:45:23 <darius-> shapr - only if you're not busy :)
20:45:30 <SamB> darius-: oh, why does help(Topic) only give one value for Topic?
20:45:57 <darius-> samb - dunno, sounds like an implementation question rather than a language question.
20:45:58 <shapr> well, I'm attempting to make a mailing list searcher for haskell.org, so only for some value of not busy.
20:46:24 <darius-> i'd presume it's deterministic like other i/o thingies like consult()
20:46:36 <SamB> darius-: well, this would be about swi-prolog
20:46:45 <shapr> blackdog: that's a pretty awesome pic on orkut
20:46:45 <darius-> shapr - i'll schlep the files over to scannedetc
20:46:59 <shapr> ScannedEtCetera, I like it.
20:47:01 <darius-> samb - sorry, don't know about that
20:47:01 <darius-> heh
20:47:38 <shapr> Sacha Chua is a very cool person.
20:52:04 <SamB> hmm, occurs to me that x0rfbserver would be pretty useless when you haven't got an X server actually running on the machine already. which would mean that you would want {,tight}vncserver, which is an X/vnc server, if you actually wanted to see the display.
20:52:44 <darius-> xvfb ought to do the trick, if i can actually get the files over there.  damn scp.
20:54:17 <SamB> darius-: try rsync?
20:54:23 * blackdog grins at shapr
20:54:36 <darius-> i'm on a bloody windows box
20:54:42 <blackdog> wish i had pre-surgery photos
20:55:16 <shapr> I heard rumor that a bunch of guys beat up on you, what happened?
20:55:32 <SamB> darius-: have cygwin?
20:56:03 <darius-> yeah.  thanks for the suggestions -- i think all this is too off-topic for this channel
20:56:15 <blackdog> I was coming home from the pub with sean, he stopped for a slash, and i waited for him. while this was happening, 7 guys walked past, called me a hero c***, and beat the shit out of me. *shrug* worse things happen at sea.
20:56:44 * darius- notes he shouldn't be suprised at needing to valgrind, with triple *** pointers in this c program :)
20:56:46 <shapr> what's a slash?
20:58:46 <blackdog> ...uh, urination.
20:58:50 <shapr> ah, ok
20:59:04 <shapr> man she's cool - http://sacha.free.net.ph/notebook/pics/sacha-014-lowres.jpg
20:59:29 <darius-> blackdog - ack, geez.
20:59:33 <Yosomono> shapr: I pray that's worksafe
20:59:55 <shapr> Yosomono: if you're a geek, it may not be ;-) but 99% of the world would consider that worksafe.
21:00:07 <Yosomono> SamB: Be more surprised if I'm in #twisted than anywhere else
21:00:12 <Yosomono> SamB: Remember, I am the anti-glyph
21:00:25 <Yosomono> shapr: d00d, sexeh!
21:00:38 <shapr> yah, and she's much better at elisp than I am.
21:00:47 <Yosomono> oh, right, the girl
21:00:49 <Yosomono> she's not bad
21:00:49 <Yosomono> :D
21:01:04 <shapr> :-P
21:01:25 <Yosomono> shapr: btw, haskell hurts my brain
21:01:30 <shapr> how so?
21:01:43 <Yosomono> shapr: I've been plodding through the Gentle Introduction
21:01:46 <Yosomono> It's not very gentle.
21:02:10 <Yosomono> It's like having Kobe Bryant as your first.
21:02:44 <shapr> well, do you have any questions?
21:02:45 <Yosomono> SamB: Also, be shocked, because I used an analogy involving a sports figure.
21:02:52 <Yosomono> shapr: How do I make the headache stop?
21:03:16 <SamB> Yosomono: it is not that bad!
21:03:18 <darius-> shapr - you didn't say she's a cyborg
21:03:31 <Yosomono> SamB: Not bad, but still painful.
21:03:37 <shapr> Yosomono: realize that functional is simpler than procedural, and give in to our way of thinking :-P
21:03:38 <blackdog> darius-: it's ok, i got some cool scars out of it. no-one cards me in bars anymore :)
21:03:45 <shapr> heh
21:03:46 <darius-> blackdog - heh
21:03:47 <Yosomono> SamB: Neurological pathways twisting and burning new ground into unused areas...
21:04:08 <Yosomono> shapr: It's not my first exposure to functional programming, I'm a CS grad remember...
21:04:30 <shapr> darius-: Sacha Of Borg - http://sacha.free.net.ph/notebook/pics/sacha_of_borg_thumb.png
21:04:31 <SamB> Yosomono: what, specifically, is making your head hurt?
21:04:56 <Yosomono> shapr: heh, very cool
21:05:17 <Yosomono> SamB: I think I explained it nicely above. Wrapping my brain in peculiar loops.
21:05:21 <darius-> cool :)  reminds me of those kids in vernor vinge's story
21:05:26 <darius-> fast times at fairmont high
21:05:45 <SamB> Yosomono: WHAT LOOPS!
21:05:55 <SamB> there are no LOOPS
21:05:55 <Yosomono> SamB: Remember, I've been in the "Real World" for 5 years now. The status quo is etched into my brain in deep, far-reaching grooves.
21:06:05 <SamB> there is only RECURSION!
21:06:15 <Yosomono> SamB: Figure of speech, ya dweeb ;)
21:06:17 <SamB> ;-)
21:06:36 <shapr> I'm hoping sacha will show up on #haskell, she's all kinds of good for community.
21:07:36 <Yosomono> must...have...monocle....
21:09:14 <SamB> Yosomono: watch out! MS research is involved in haskell. be carefull you don't get stuck with MS Visual Haskell!
21:10:18 <Yosomono> So what is more preferred, hugs or ghc?
21:10:25 <Yosomono> Or is that an incorrect question?
21:10:31 <shapr> I prefer GHC
21:11:16 <Yosomono> shapr: It's your fault I started reading this damn introduction. Your demopage didn't pique my interest much until I found something I thought was a mistake.
21:11:29 <SamB> I use both.
21:11:31 <shapr> what was the mistake?
21:11:45 <SamB> they each pretty print types differently
21:12:21 <Yosomono> Your pattern matching example with "mylength" used "length" on the right side, where I had expected to see "mylength" and I wondered if perhaps I had misunderstood what it was doing. So I figured I had to learn haskell basics.
21:12:44 <Yosomono> Been reading the not-so-gentle Gentle Introduction ever since.
21:12:58 <shapr> hm, I bet that is an error.
21:13:13 <SamB> Yosomono: the problem may be related to not-enough-interaction?
21:13:23 <Yosomono> SamB: Whaddya mean?
21:13:33 <Yosomono> SamB: Let's not-speak-in-hyphens-though...
21:13:56 <SamB> Yosomono: if you haven't installed a Haskell system... then you haven't been at the REPL
21:14:24 <SamB> by the way, ghci has a really nice repl
21:14:28 <SamB> s/has/is/
21:14:31 <Yosomono> SamB: I am so not following you.
21:14:37 <Yosomono> I have played around with hugs a bit.
21:14:39 <Darius> SamB: relatively
21:14:41 <SamB> oh, okay.
21:15:06 <Yosomono> Ah, you are expecting me to complain about lack of interactivity at the prompt because I'm a pythonista.
21:15:10 <Yosomono> Silly SamB.
21:15:14 <SamB> Yosomono: no.
21:15:15 <shapr> ah chill out
21:15:33 <Yosomono> SamB: Oh, then definitely not following you.
21:15:37 <shapr> oh, my coffee's probably ready now
21:15:50 <Yosomono> shapr: I've been having a tough time rediscovering coffee.
21:15:52 <SamB> Yosomono: I was thinking maybe you weren't playing around with hugs or ghci, and therefore not getting it!
21:16:13 <Yosomono> SamB: Ah, interaction in the broad sense rather than direct.
21:16:21 <Yosomono> SamB: I'm mostly reading for now.
21:16:41 <Yosomono> I'm not one of those "hrm, I don't know this language, but I'll try to write something in it anyway" kind of people.
21:17:03 <SamB> Yosomono: why ever not?
21:17:29 <Yosomono> SamB: Even the boldest explorer gets a rough idea of the lands he's about to travel in, before setting off.
21:18:13 <shapr> except for those who take Ritalin
21:18:17 <blackdog> you obviously haven't looked into australian explorers. :)
21:18:31 <Yosomono> shapr: You're practically a paid spokesman for that now...
21:18:36 <blackdog> half of 'em are known only by discreet plaques next to trees
21:18:39 <shapr> for Ritalin? or unplanned exploration?
21:18:45 <Yosomono> shapr: Ritalin
21:18:56 <Yosomono> I don't think we've had a conversation since I came back that didn't involve it ;)
21:18:57 <shapr> well, it's really... what were we saying? ;-)
21:19:05 <SamB> Yosomono: interaction is a great way to get a clearer idea of what is really happening
21:19:12 <blackdog> i would have thought that the ritalin'd help with planning, rather than unplanning
21:19:30 <Yosomono> SamB: So far the hardest thing for me to get used to is the direction. :)
21:19:42 <SamB> shapr: anyway, I take dextrostat, not ritalin!
21:20:09 <Yosomono> I am 100% natural freak, with no additives and only trace amounts of preservatives.
21:20:14 <shapr> ritalin does help with planning, it's just that organizational bobbles can mean you run out, and then...
21:20:25 <shapr> I took dextroamphetamines for awhile, but I got too many side effects.
21:20:46 <shapr> for example, they put me to sleep
21:21:13 <SamB> I don't know if I get any side effects
21:21:28 <SamB> but they do not put me to sleep
21:22:12 <shapr> on the good side, I got a lot of sleep with dex.
21:22:14 <Yosomono> Anyhow, it's just taking some effort to get used to a language where left and right are so important.
21:22:27 <Yosomono> As directions.
21:23:49 <shapr> I will say that being in the same room with several unmedicated ADHD folks is more fun than a rollercoaster.
21:24:58 <Yosomono> ooh, ghc has a whole bunch of junk that gets installed with it
21:25:01 <Yosomono> that implies better
21:25:02 <Yosomono> :)
21:25:27 <shapr> so, did you find the HaskellDemo useful?
21:25:45 <shapr> I've shown it to a bunch of people, but I haven't gotten much in the way of specific feedback.
21:25:57 <Yosomono> shapr: it got my interest piqued enough to read the gentle intro
21:26:02 <Yosomono> shapr: so as a hook, it works
21:26:08 <shapr> neat :-)
21:26:38 <Yosomono> The gentle intro is short on explanations. It tends to just throw stuff at you and say "this is this, that is that".
21:26:56 <Yosomono> "And clearly, this is doing that, now for the next part..."
21:27:04 <Yosomono> While you're thinking to yourself "what is doing where?"
21:28:31 <SamB> hence the exploration
21:28:52 <shapr> I prefer lots of code with little explanation
21:29:08 <SamB> I like to read GHC.*
21:29:12 <darius-> shapr - the extra spaces in the type declarations seem gratuitous
21:29:15 <shapr> then I can throw it into some sort of interactive environment and see what happens.
21:29:19 <monotonom> I prefer lots of proofs with no code. :)
21:29:23 <shapr> darius-: where?
21:29:23 <Yosomono> I imagine once I get done this intro, I'll want to see some practical examples I can pick apart.
21:29:30 <darius-> near top of haskelldemo
21:29:34 <shapr> Yosomono: oh, lambdabot is practical.
21:29:34 <SamB> monotonom: proofs *are* code!
21:29:53 <Darius> SamB: Constructive proofs.
21:30:06 <Yosomono> shapr: Is there some sort of repository of practical code?
21:30:20 <shapr> Yosomono: you could check out the hlibs repository.
21:30:33 <SamB> Darius: isn't it called the curry-howard isomorphism or something like that?
21:30:39 <shapr> what counts as practical to you?
21:30:44 <darius-> shapr - i don't see how Tree a is an abstract datatype - you mean algebraic?
21:30:55 <darius-> oh, i guess it's the parameter
21:30:58 <Yosomono> shapr: something that does something I can poke at
21:31:05 <shapr> @yow
21:31:05 <lambdabot> I feel real SOPHISTICATED being in FRANCE!
21:31:22 <Yosomono> as opposed to snippets that show something's usage
21:31:23 <Darius> The Curry-Howard isomorphism is a correspondence between intuitionist logic and the simply typed lambda calculus.
21:31:24 <shapr> Yosomono: you could write a lambdabot plugin.
21:31:37 <SamB> @ghci show "hello"
21:31:38 <lambdabot> Sorry, I don't know the command "ghci", try "lambdabot: @listcommands"
21:31:45 <shapr> darius-: yah, I think Tree a is abstract, and Tree Int is concrete.
21:31:46 <SamB> @hugs show "hello"
21:31:46 <lambdabot> Sorry, I don't know the command "hugs", try "lambdabot: @listcommands"
21:31:47 <darius-> i would you would use a typeclass to express an abstract datatype in haskell
21:31:54 * SamB awws
21:31:58 <darius-> i would call the tree a parameterized type instead
21:32:07 <shapr> you may be right
21:32:09 * shapr checks
21:32:15 <Darius> shapr: You should have @ghci based @type and @info commands.
21:32:30 <SamB> Tree a is polymorphic
21:32:32 <shapr> probably so, but no one has volunteered to write them ;-)
21:32:41 <Darius> darius-: Abstract data types are usually done through the module system.
21:32:41 * shapr volunteers Yosomono 
21:33:14 <darius-> darius - er, right, that would be better
21:33:15 <Darius> To turn @ghci into @type would only require modifying it to output the first string instead of analyzing it.
21:33:47 <darius-> shapr - i would've written Nil instead of (Nil) - maybe i should just edit this instead of minutely criticizing
21:33:50 <SamB> Darius: since when does it actually analyze it?
21:34:12 <Darius> SamB: There are other "Curry-Howard isomorphisms" for other logics and other lambda calculi.
21:34:48 <Darius> SamB: It checks it to see if the type contains IO.  At least that was my understanding of it.
21:36:57 <shapr> yes, you are correct
21:36:57 <shapr> http://www.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/modules.html#sect5.8
21:36:57 <shapr> darius-: yes, it is a wiki :-)
21:36:57 <shapr> I'm waiting for det to come up with an infinite type to feed to lambdabot 
21:37:34 * shapr goes to retrieve coffee
21:38:00 <SamB> shapr: heh. I thought haskell didn't like those.
21:38:26 <shapr> from what I've read/heard, I think it's possible with some of the GHC extensions.
21:38:46 <shapr> I'd be interested in seeing a big O complexity description of the various type extensions.
21:38:59 <Yosomono> It's kind of annoying how the gentle intro writes some sample code to explain something and then at the end says "this is ugly, let's clean it up" and does all sorts of crazy ass shit that hasn't been explained yet, and never explains it.
21:39:16 <shapr> Yosomono: happily, you have us, and we can uncrazy that shit.
21:40:04 <Yosomono> shapr: it's not incomprehensible, just crazy
21:40:06 <Darius> shapr: As far as I know the only time the typechecker can loop (assuming it's bug-free) is via undecidable-instances, and even in that case it has a limit on the depth.
21:40:27 <Yosomono> shapr: all of a sudden cleaning stuff up means turning all sorts of things into little mini functions to exploit functional composition
21:40:47 <SamB> Yosomono: yes, that is the general idea
21:40:50 <Yosomono> It takes a nice clear explanation and hacks it to bits held together with tape.
21:41:02 <SamB> Yosomono: but oh, what tape!
21:41:36 <Yosomono> Maybe my brain is just rusty from years of neglect. :(
21:42:05 <SamB> well, have you got any monkey on you that you could use to clean it up?
21:42:15 <SamB> s/monkey/monkey oil/
21:42:29 <blackdog> where's this intro of yours, shapr?
21:43:41 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
21:43:50 <shapr> though I think darius- may be editing it?
21:43:50 <Darius> Yosomono: Which section?
21:44:09 <Yosomono> darius: Which section what?
21:44:28 <Darius> Which section of the Gentle Introduction are you talking about?
21:44:41 <Yosomono> All of it. :)
21:45:02 <Yosomono> I'm currently in the section on Show and Read
21:45:19 <Yosomono> The tree example just goes apeshit at the end.
21:47:09 <shapr> g'day Jerub 
21:47:35 <Darius> Yosomono: You mean the change from ++ to .?
21:48:30 <Yosomono> darius: Well, putting aside for the moment that I don't recall "." being used before...it was more the change to functions that aggravated me.
21:48:55 <Yosomono> When you are making examples to explain a specific thing, the examples should ONLY explain that thing. Not a bunch of other things.
21:49:04 <Yosomono> It's too easy to confuse the reader.
21:50:08 <shapr> blackdog: any comments on the intro?
21:50:47 <Darius> Composition (.) is in section 3.2
21:51:20 <Yosomono> Way back there? I read that yesterday.
21:51:23 <Yosomono> No wonder I don't remember :P
21:51:24 <cleverdra> yoso - perhaps that section should have a "WARNING: Readers with strict evaluation should probably skip this section until they understand the following terms (later on in this document, hopefully): ..."
21:51:41 <shapr> I had a strict evaluation once.
21:51:43 <Yosomono> cleverdra: That was a very subtle jab. Nice.
21:52:01 <shapr> truly, that was subtle.
21:52:09 <det> cleverdra: hah
21:52:10 <Darius> cleverdra: What does strict evaluation have to do with that section?
21:52:12 <cleverdra> yoso - not a jab, just a disagreement.
21:52:13 <SamB> how will people know what it means?
21:52:30 <Yosomono> It's nice when you can apply concepts from the language to concepts in meatspace.
21:52:41 <Yosomono> cleverdra: Close enough.
21:52:43 <SamB> I don't get it.
21:53:11 <Yosomono> Darius, SamB: He's saying I'm incapable of dealing with things as they come along and getting their "values" later.
21:53:21 <Yosomono> When they are needed.
21:53:21 <SamB> Yosomono: oh.
21:53:35 <Yosomono> It was nicely done.
21:53:39 <cleverdra> yoso - no, I didn't say that -- but your complaint only happens when you strictly evaluate.
21:53:54 <cleverdra> yoso - hence the suggested warning =)
21:54:01 <Yosomono> cleverdra: You should have just taken the compliment ;)
21:54:01 <shapr> how do people usually want to search or associate emails? by keyword on subject and body, by thread, by date. Anything else I should put into the postgresql table structure?
21:54:16 <cleverdra> yoso - oh, OK.  I'd thought that I offended you.
21:54:47 <Darius> cleverdra: That'd likely be more appropriate in both respects for section 4.4.
21:54:50 <Yosomono> cleverdra: Nah, I consider myself something of a master of subtle jabs, so it was a compliment :)
21:55:13 * SamB thinks SQL is inadequate for such wingled stuff as email
21:55:37 <Darius> wingled?
21:57:51 <SamB> Darius: see jwz.org
21:58:18 <shapr> SamB: I was thinking to use HaskellDB on top, I don't want to actually write SQL myself.
21:58:48 <SamB> shapr: its the whole table thing I think likely to be inadequate, actually.
21:59:12 <shapr> do you know a better way?
21:59:40 <monotonom> I know people who hate "f = g+1 where g=..."; they can't stand forward references.  I also know people who hate "f = let g=... in g+1"; they can't stand being told the gory details before being told the big picture or ultimate goal.
21:59:44 <blackdog> shapr: for the first Eq instance, it might be nice to have something that you can't derive automatically.
22:00:05 <shapr> blackdog: like what?
22:00:33 <blackdog> i was thinking of an Ord instance for Bridge, myself, but it could get a bit messy. 
22:00:40 <blackdog> anyway, i'm off home. see you later...
22:00:44 <shapr> cya
22:00:51 <darius-> later
22:00:52 <shapr> for Bridge? the game?
22:01:01 * shapr has no clue about Bridge
22:02:01 <blackdog> shapr: neither do i, but there's all these funky rules about when jacks beat kings etc... it'd actually be pretty hard to formalise in a pedagogical way, now i think about it.
22:02:16 <shapr> could be fun
22:03:33 <cleverdra> ow, you just reminded me that I want to play some more Weiqi =)
22:03:51 <shapr> what's that?
22:03:59 <shapr> I've been playing dominions II lately, it's fun.
22:04:05 <cleverdra> Also known as 'Go'.
22:04:13 <cleverdra> (Theh Chinese call it 'Weiqi')
22:04:13 <shapr> ah
22:05:25 <Darius> monotonom: I hate let (when where will do) because it's ugly, I could care less about the details.
22:05:44 <Darius> monotonom: Um, where did that come from by the way?
22:05:59 <monotonom> A lifetime of observing people.
22:06:54 <monotonom> For example, the kind of programmers who are used to Fortran, C, ... they are educated (brainwashed?) to hate forward references.
22:07:25 <Darius> Needing to declare forward references in C/C++ is a pain in the ass.
22:07:41 <SamB> where is prettier than let is
22:07:52 <Darius> That said my question was what prompted you to write the above remark?
22:08:18 <cleverdra> mono - curiously, have you observed any other perceptual habits common to either group?
22:08:22 <monotonom> Ah. The "strict evaluation" remark of cleverdra.
22:08:30 * SamB wants his colored nicks back.
22:08:48 <cleverdra> sam - what do the colors mean to your IRC client?
22:09:06 <Darius> monotonom: ah
22:09:18 <SamB> cleverdra: nothing. but they would help me to see who is talking when at a glance
22:11:18 <shapr> which irc client do you use?
22:11:46 <shapr> SamB: unless you have a better idea for saving/search emails, I'll use postgresql
22:12:51 <monotonom> The where-lovers are mostly top-down minded. The let-lovers are mostly bottom-up minded.
22:13:11 <shapr> hi shurik 
22:13:32 <SamB> actually, I'm usually bottom up minded. I also like smaller emacs windows, though
22:14:05 <Yosomono> SamB: puny emacs user!
22:15:01 <monotonom> I mysteriously switch between the two nondeterministically as time goes forward.
22:16:52 <Darius> monotonom: What about case?
22:17:00 <Darius> Yosomono: What editor do you use?
22:18:16 <shurik> G'day shapr
22:19:24 <Yosomono> darius: There is only one true editor, and that is vi.
22:19:55 <Darius> I don't think I could use vi.
22:20:01 * Darius is a vimmer.
22:20:37 <Darius> Of course, a not too long time ago I used the MS-DOS edit.com.
22:20:48 <Yosomono> darius: They are as one. Like a Holy Trinity, for which I can't quite think of a third party.
22:20:57 <SamB> Yosomono: me neither.
22:21:06 <Yosomono> I use jvim, naturally.
22:21:24 <monotonom> ed
22:21:25 <Yosomono> Unfortunately it's a few revisions behind vim.
22:21:30 <SamB> edit.com is comparable with nano, I think
22:22:01 <SamB> much easier than vi
22:22:11 * darius- likes ed :)
22:22:56 <shapr> I like emacs, but it's a bit lightweight imho
22:22:58 <Darius> A somewhat messed up thing is that some MFC tutorial notes that you can make a more featureful editor than notepad in a single line.  The question is why then does notepad suck so much?
22:23:19 <shapr> Darius: if it didn't suck, you would be encouraged to edit stuff.
22:23:26 <Darius> Of course it's a non-issue for me as I absolutely can not stand GUI editor's for coding.
22:23:30 <shapr> windows is not *for* editing
22:23:34 <SamB> ed? I don't think even Ken uses ed anymore
22:23:36 <shapr> it is for using.
22:23:50 <monotonom> notepad is there for those of us who don't know MFC programming
22:23:52 <darius-> well, i only actually use it occasionally
22:24:44 <SamB> darius-: why did you switch just now?
22:24:47 <Yosomono> When forced to be on windows, I use Maruo editor.
22:25:17 <shurik> vim is a nice editor, emacs is usble too if you switch in vim mode:>
22:25:26 <darius-> er, i switched just now?  i don't understand
22:25:49 <monotonom> maybe he means switching from Darius to darius-
22:25:54 <darius-> ah, right
22:26:01 <Darius> Uh, /whois darius- /whois Darius
22:26:02 <SamB> monotonom: yes
22:26:28 <darius-> that Darius guy sure confuses people :)
22:26:51 <SamB> if you are different people it is awfully tricky of you to be in the same channel!
22:27:15 <Darius> Hey Darius should have been here first... uh as Darius...
22:27:41 * darius- apologizes for delinquency
22:28:08 <monotonom> Haha
22:34:31 <Darius> And on the first day the Lord sed s/there/light/
22:35:06 <Yosomono> Someone shoot him
22:35:07 <Yosomono> :)
22:38:41 * Darius wonders what Derek'd think about that.
22:38:47 <Jerub> shurik: I find emacs vim mode sorely lacking.
22:39:17 * Darius wonders what Derek'd think about a lot of things about me.
22:39:31 <SamB> Darius: you appear to have misheard that verse
22:44:44 <Darius> Wow.  The Internet is a crazy place which is apparently populated by musicians.
22:46:00 <cleverdra> darius - curiously, what languages do you natively speak?
22:46:16 <phubuh> That's wonderfully ambiguous
22:47:11 <Darius> cleverdra: American English.  (Can one -natively- speak multiple languages?  I guess.)
22:47:41 <cleverdra> Darius - of course you can.  Many 'bilingual' people exist, for instance.
22:49:30 <Darius> Yes, but that wouldn't be native.  However, if your native country had multiple languages...
22:51:22 <stepcut> is there a takeUntil function: takeUntil ((==) 4) [1,2,3,4,5,6] ---> [1,2,3,4]
22:51:44 <Darius> @type takeWhile . not
22:52:09 <Darius> @type (takeWhile . not .)
22:52:21 <cleverdra> Darius - a 'bilingual' person, by definition, knows two languages as natively as anyone can know any language.  Hence the 'native'.
22:52:23 <Darius> @type takeWhile . (not .)
22:52:23 <lambdabot> takeWhile . (not .) :: (a -> Bool) -> [a] -> [a]
22:52:48 <cleverdra> Darius - the languages of the country has little to do with that -- consider immigrant families.
22:52:55 <Yosomono> I speak Esperanto like a native!
22:52:57 * Yosomono smirks.
22:53:51 <stepcut> (takeWhile . (not .))  ((==) 4) [1,2,3,4,5] ----> [1,2,3]
22:54:01 <stepcut> I need that last element.. the 4
22:54:19 <cleverdra> perhaps you want dropWhile ?
22:54:35 <stepcut> nope, I want the head of the list, not the tail
22:54:58 <cleverdra> perhaps you want something using dropWhile ?
22:55:07 <stepcut> I can easily write a function to do what I want, I just wondered if there was an obvious solution I am missing
22:55:12 <monotonom> takeWhile (<= 4) [1,2,3,4,5,6] --> [1,2,3,4]
22:56:09 <stepcut> monotonom: I also want this property: takeUntil ((==) 4) [6,7,8,4] ---> [6,7,8,4]
22:56:23 <stepcut> basically I want all the elements in the list upto and including the 4
22:56:44 <cleverdra> dropWhile (/= 4)
22:57:03 <Darius> That will return [5,6]
22:57:04 <cleverdra> takeUntil p = dropWhile (not p)
22:57:23 <cleverdra> @eval dropWhile (/= 4) [1..10]
22:57:24 <lambdabot> (line 1, column 12):
22:57:24 <lambdabot> unexpected "/"
22:57:24 <lambdabot> expecting simple term
22:57:28 <stepcut> cleverdra: that returns the end of the list, I want the beginning
22:57:53 <Darius> @eval dropWhile (\x -> x /= 4) (fromTo 1 10)
22:57:53 <lambdabot> [4, 5, 6, 7, 8, 9, 10]
22:57:54 <cleverdra> darius - no, it will not return that.
22:58:03 <Darius> Yes it will return 4 5 6.
22:58:13 <cleverdra> Darius - you didn't say [4,5,6], you said [5,6]
22:58:17 <Darius> Unless I misimplemented dropWhile
22:58:30 <Darius> I know, I was agreeing in my latter remark, but still the point remains.
22:58:36 <Darius> @eval span
22:58:36 <lambdabot> <<EM Dynamic -> EM Dynamic>>
22:58:41 <cleverdra> stepcut - please start over -- you've expressed contradictory desires.
22:58:50 <Darius> @eval span (\x -> x == 4) (fromTo 1 10)
22:58:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
22:58:51 <cleverdra> darius - what point?
22:59:05 <Darius> That the desired answer is 1 2 3 4
22:59:21 <stepcut> takeUntil p (x:xs) | p x = [x]
22:59:22 <stepcut> 		   | otherwise = x : (takeUntil p xs)
22:59:31 <Darius> x : takeUntil p xs
22:59:35 <cleverdra> darius - you must've used your psychic powers, then.
22:59:57 <cleverdra> stepcut - curiously, what didn't you like about my takeUntil implementation?
23:00:14 <Darius> When "psychic" become a synonym for "reading"?
23:00:34 <Taaus> That it dropped instead of taking, perhaps?
23:01:16 <monotonom> Darius: Yeah, I actually considered suggesting "f [1,2,3,4,5,6] = [1,2,3,4]" :)
23:01:21 <stepcut> cleverdra: your function (as far as I can tell) returns 4 and the elements that follow it, I want the elements leading upto and including the 4
23:02:44 <norpan_> (\(x,y)->x++[head y]).span (/=4)
23:03:46 <monotonom> reverse . (dropWhile (/= 4)) . reverse  :)
23:04:19 <stepcut> monotonom: my list is infinate
23:04:51 <stepcut> monotonom: well, in the place where I actually use this, my list in infinate, and finate at the same time
23:05:09 <monotonom> norpan's will work.
23:05:23 <stepcut> norpan's does indeed work
23:06:49 <Darius> finite
23:08:42 <stepcut> man, my spelling has been really bad this week. I know how to spell finite
23:09:41 <Darius> ah, the consistency was misleading.
23:09:44 <Taaus> Hmmm... takeUntil is a bad name for the function. The correct takeUntil is the one Darius made. You're after a takeUntilAndThenOneMore... :)
23:10:31 <stepcut> Taaus: or perhaps takeUntilAndIncluding?
23:10:48 <Taaus> Yeah. :)
23:10:50 <Darius> or takeUntilInclusive or takeUntilPoliticallyCorrect
23:11:24 <stepcut> maybe just takeInclusive
23:12:00 <stepcut> takeUntill++
23:12:03 <monotonom> takeWhileForDummies
23:12:09 <Taaus> What would you call takeWhileInclusive, then?
23:12:51 <stepcut> true
23:18:35 <stepcut> well, I have caused enough trouble for one night, night
23:18:40 * stepcut goes to bed
23:35:13 <Maddas> hrm
23:35:20 <Maddas> shapr: Around?
23:39:39 <shapr> eh?
23:40:07 <Pseudonym> Oh, shapr, I have a bone to pick.
23:40:10 <Maddas> shapr: How long did compiling lambdabot take for you?
23:40:26 <Pseudonym> There is an imperative, strongly-typed nondeterministic language with functional syntax.
23:40:36 <Pseudonym> In fact, there are probably at least three.
23:40:43 <Pseudonym> Four if you count Escher.
23:40:52 <Pseudonym> Oz, Mercury and Goedel.
23:40:56 <shapr> Maddas: a minute or so?
23:40:59 <shapr> maybe less?
23:41:02 <Maddas> shapr: ok
23:41:14 <Maddas> don't ask me :-)
23:41:17 <shapr> I am compiling on a dual 1544MHz with 512mb of RAM.
23:41:27 * Maddas nods
23:41:42 <shapr> g'day Pseudonym 
23:41:48 <Pseudonym> G'day.
23:41:51 <shapr> Maddas: why do you ask?
23:41:57 <Pseudonym> My machine is finally free of script kiddiness.
23:42:06 <shapr> happiness
23:42:08 <Pseudonym> Though I now suspect my rootkitting to be the work of spammers.
23:42:20 <Pseudonym> The mail queue was full.
23:42:28 <Maddas> shapr: I got a new machine, just as a pseudo-benchmark I want to test it later
23:42:36 <shapr> tell me about it!
23:42:39 <Darius> Pseudonym: I think by strong typing it meant static typing.
23:42:45 <Maddas> Me?
23:42:47 <shapr> it's fun to bask in the reflected enthusaism of others :-)
23:42:52 <shapr> yes, I want to hear about your new machine
23:43:01 <Pseudonym> Darius: I'm pretty sure that Oz, Mercury and Goedel are all statically typed.
23:43:04 <Pseudonym> And strongly typed.
23:43:22 <Darius> Oz definitely isn't.
23:43:32 <Pseudonym> That was the one I was unsure about. :-)
23:44:07 <Darius> Do they all also have a powerful applicitive expression sublanguage?
23:44:21 <Pseudonym> It's interesting, though, that most of the push for combined functional/logic languages is coming from the logic programming community, NOT the functional programming community.
23:44:42 <Darius> Interesting maybe, surprising no, at least not to me.
23:44:42 <Pseudonym> Darius: It depends what you mean by "powerful".
23:44:51 <Pseudonym> No, it's not surprising to me either.
23:44:58 <Pseudonym> Functional programmers like their simple dataflow.
23:45:09 <Pseudonym> Can't blame 'em, either.
23:46:00 <Darius> Pseudonym: Yeah, I thought you'd respond in that way. (in reply to "powerful")
23:46:12 <Pseudonym> :-)
23:46:18 <Darius> Is Mercury imperative?
23:46:39 <Pseudonym> As much as Haskell is.
23:46:44 <Maddas> shapr: Dual G5 2.0Ghz :-)
23:46:54 <Jerub> I've yet to find a language I find as useful and fun as python.
23:47:03 <Jerub> but haskell is fun.
23:47:11 <Maddas> Not really mine, belongs to the family, but I get to use (and administrate) it.
23:47:16 <shapr> Maddas: awesome :-)
23:47:55 <Maddas> Yes!
23:48:12 <Pseudonym> Linear types/modes with DCL syntax basically gives you a syntax which is arguably as convenient as do-notation.
23:48:16 <SamB> it must be cool to be able to go with the flow AND run unix ;-)
23:48:37 <Pseudonym> IMO
23:48:40 <Maddas> SamB: I certainly am happy with it
23:48:42 <Darius> I think the remark was limiting to impure languages by imperative.
23:48:53 <Pseudonym> Ah, OK.
23:48:56 <Darius> Is Goedel impure?
23:49:00 <Pseudonym> Yes.
23:49:09 <Pseudonym> In Goedel you can backtrack over I/O.
23:49:45 <Darius> I thought so, though I have(had) virtually no basis for thinking so.
23:50:13 <Maddas> Hrm. Are those languages (Goedel, Escher, Oz, Mercury) cool?
23:50:44 <Darius> Oz is pretty cool.
23:51:00 <Darius> Though I've written almost nothing in it, but have read a chunk about it.
23:51:24 <Pseudonym> Goedel and Mercury are much less painful than Prolog.
23:51:29 <Darius> Pseudonym: Now we need a language with all those features and backward state variables and it'd be set.
23:51:32 <Pseudonym> So if you think Prolog is cool, you'll probably like them.
23:51:34 <Maddas> Are the languages similar or do I only think so because I know nothing about any of them?
23:51:38 <Maddas> Pseudonym: heh.
23:51:55 <Pseudonym> Escher, IMO, is more of a theoretical curiosity.
23:52:02 <Maddas> haha
23:52:03 <Pseudonym> Oz is interesting.
23:52:08 <Darius> PseudonyM: X is much less painful than Prolog I think is tautological.
23:52:31 <Maddas> What about Mozart?
23:52:39 <Darius> Mozart is the environment of Oz.
23:52:46 <Darius> Oz is the language.
23:52:57 <Maddas> oh. I should stop talking and start reading.
23:52:59 <Darius> A related by dramatically different language is Alice.
23:53:02 <Pseudonym> some [X] ( programming_language(X), painfulness(X) > painfulness(Prolog) )
23:53:26 <Pseudonym> I contend that JCL is more painful than Prolog.
23:53:31 <Darius> (Or I guess Alice ML in particular as there is another language named Alice)
23:54:03 <Maddas> heh.
23:54:58 <Maddas> Maybe I should play around with it :-)
23:56:22 * Darius actually did write that neural net code using a backward state monad.
23:56:54 <shapr> hey Pseudonym, you think throwing the haskell mailing list into postgresql with indices on subject, body (without mime attachments), msgid as primary key, will be okay?
23:57:04 <Darius> Though I think it would have been clearer to do the passing explicitly and I'm not sure what the best "primitives" are for it.
23:57:21 <Pseudonym> Depends what you want to search on.
23:57:35 <Darius> (hmm, those two clauses were rather unrelated)
23:57:52 <shapr> I just wanted to put this online since several people said they'd like to search the haskell mailing lists.
23:57:57 * Pseudonym nods
23:58:02 <Pseudonym> Well, go for it and see how it is.
23:58:24 <shapr> ok, just pinging you for any obvious flaws, since you know muc more about databases than I do :-)
23:59:11 <Pseudonym> If you want to do full-text searching, you might need to use some kind of auxillary table to do that.
23:59:22 <Pseudonym> BTW, I know about database internals.
23:59:26 <Pseudonym> And Z39.50.
23:59:27 <shapr> I don't
23:59:30 <shapr> or that
23:59:32 <Pseudonym> Not so much about postgresql.
23:59:50 <shapr> I have no idea what you mean by auxiliary table
