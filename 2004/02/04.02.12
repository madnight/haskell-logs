00:00:19 <det> "We put the chairwoman of our workers' council on stage in front of all the    Intel chip aims to cut
00:00:19 <det>      municipal workers, and showed her using the new system. After that, we found   optical costs
00:00:19 <det>      that no man would say that he couldn't use his PC now that everyone knew a     Notebooks make a play
00:00:23 <det>      woman could do it," revealed Brauner. 
00:00:52 <Vulpyne> Nice text mangling.
00:11:50 * det whips out his lasso and wrangles the text
00:28:32 <Vulpyne> Yeehaw.
01:02:06 <Swynndla> I've found it a bit hard to find a free on-line beginners tutorial on ocaml that goes through things step by step ... are there good resourses for haskell?
01:03:16 <Maddas> See http://www.haskell.org/learning.html for tutorials, also feel free to ask here if you have questions
01:04:01 <Swynndla> ahhhh thx :)
01:04:06 <ski> Swynndla : someone said that http://www.isi.edu/~hdaume/htut/ was quite good
01:04:20 <Maddas> morning, ski :)
01:04:20 <Swynndla> oic
01:04:35 <ski> Maddas : mornin'
01:06:40 <forcer> hi there :)
01:06:56 <Maddas> hay their :)
01:06:58 <det> hello
01:07:06 <forcer> is any darcs user here right now and would like to talk a bit about an useful emacs mode for darcs? :]
01:07:10 <ski> forcer : hi
01:07:28 <det> forcer: there apparently already exists a darcs mode
01:07:39 <det> forcer: maybe you dont find it as useful as could be ?
01:07:46 <forcer> det: do you mean vc-darcs.el?
01:07:50 <det> yeah
01:07:54 <forcer> that's written by me
01:07:54 <forcer> ;)
01:07:59 <det> oh :)
01:08:21 <forcer> what vc expects is just too different from what darcs does
01:09:10 <det> what is vc ?
01:09:24 <forcer> the default "Version Control" code in emacs
01:09:46 <forcer> it was written for RCS and SCCS, extended easily to CVS, but now just won't cut it anymore...
01:09:51 <det> do subversion/CVS modes use it ?
01:10:05 * ski pekar på haskell
01:10:09 <forcer> det: emacs comes with vc-cvs, and subversion comes with vc-svn
01:10:25 <det> forcer: is darcs much different than subversion ?
01:10:34 <forcer> det: yep
01:11:01 <det> so a full-fledged darcs mode would most liekly be a huge undertaking ?
01:11:09 <forcer> det: subversion is file-tree based. that in itself is already a bit beyond vc, but svn can be adapted. darcs is patch-based, and has no notion of "files"
01:11:18 <forcer> i hope not too huge
01:11:23 <forcer> :)
01:11:48 <det> hmm, then how does it know where to apply a patch ?
01:12:00 <forcer> det: subversion?
01:12:04 <det> darcs
01:12:09 <det> if it has no notion of a file
01:12:22 <forcer> it has notions of patches that apply to a tree
01:12:44 <forcer> subversion has notions of "versions of the tree", and can operate on single files alone, too
01:14:15 <det> forcer: shapr may be interested when he is on
01:14:32 <forcer> i always miss shapr :)
01:17:25 <earthy> he normally joins 'round noon
01:17:35 <earthy> which is in just under two hours, for me. :)
01:18:05 <ski> forcer : shapr says he has homework
01:18:11 <forcer> det: what are your typical darcs usage cycles involving the contents of one or many files? inittree+add+record, add+record, edit+record, diff, changes?
01:18:16 <forcer> ski: :)
01:18:28 <forcer> earthy: i'm going to bed soon :/
01:18:42 <ski> forcer : (he said something about "after school")
01:18:49 <forcer> ski: thanks :)
01:19:01 <det> forcer: I have never used DARCS
01:19:20 <det> ski: shapr is in school ?
01:19:29 <ski> det : i dunno
01:19:43 <forcer> heh
01:19:43 <forcer> ok :)
01:19:52 <det> forcer: but it looks interesting
01:20:08 <det> forcer: and shapr is always raving about it
01:21:43 <forcer> my configuration files are now managed by darcs, and i started a new project for which i use darcs
01:21:45 <forcer> it's fun to use :)
01:22:28 * earthy thinks of talking to andres about maintaining the HC&A in darcs
01:24:18 <forcer> sadly, i can't get GHC to compile in our CS pool, and the precompiled solaris binary links to libraries that don't exist there. :/
01:27:57 <det> I am afraid darcs doesnt exist
01:28:16 * forcer blinks.
01:28:39 <det> apt-cache says so
01:28:51 <Vulpyne> *poof*
01:28:54 <forcer> ah
01:29:01 <forcer> deb http://http.abridgegame.org/debian/ unstable/
01:29:05 <det> I really wanted to try it out, too!
01:29:06 <forcer> det: it's not in debian yet
01:29:16 <Vulpyne> It's in FreeBSD ports. :)
01:29:36 <forcer> if you add that line to your sources.list, and do an apt-get update, you can apt-get install it, too
01:30:00 <det> ahh!
01:30:06 <ski> hmm, how to throw an userError in GHC ?
01:30:15 <liralen> Gentoo has dev-util/darcs-0.9.{13,14,15}, all masked.
01:30:28 * liralen goes back to sleep.
01:31:07 <det> masked ?
01:34:57 <det> forcer: how do you keep your configuration files in darcs, something like ~/Configuration with everything in it, or can you use ~/.* directly ?
01:40:52 <forcer> det: darcs inittree sets up a _darcs directory in the current directory. it contains all the files you need.
01:41:06 <forcer> the newest darcs has some sort of config file i read, but i don't know what for :]
01:44:34 <Marvin--> anyone here familiar with GAST?
01:44:48 <forcer> det: 
01:44:52 <forcer>   * Can now put prefs that would normally go in _darcs/prefs (defaults,
01:44:52 <forcer>     binaries and boring) in ~/.darcs/ to set the prefs for all your
01:44:52 <forcer>     repositories at once.
01:45:38 <det> forcer: but, I imagine that would be undesirable if I ran that in ~
01:45:56 <det> forcer: I would just want certain files
01:46:58 <forcer> det: create a directory for your project. run darcs inittree there. then start writing your files. then darcs add file1 file2 ...
01:48:07 <det> oh, I meant, to keep my configuration files in
01:48:25 <forcer> oh, that :)
01:48:35 <forcer> i just did darcs inittree in ~/
01:48:59 <forcer> now i have a _darcs directory in my home
01:49:02 <forcer> but i can live with that
01:49:10 <forcer> darcs won't touch files you didn't add to it
01:51:07 <det> darcs doesnt seem to have a way to create an empty repository
01:51:52 <forcer> darcs inittree
01:52:12 * Marvin-- sighs and re-learns common lisp
01:52:16 <det> but, I dont want to add the entire contents of my home dir to it! :)
01:52:24 <forcer> det: you don't have to
01:52:38 <Marvin--> inittree doesn't add files, it just creates a repo
01:52:42 <forcer> i have a few dotfiles and such
01:52:54 <Marvin--> mkdir foo; cd foo; darcs inittree
01:53:30 <forcer> Marvin--: are you using darcs? are you using emacs? if so, what would you like to see in an useful emacs mode for darcs?
01:54:22 <det> oh
01:54:37 <det> I misread
01:54:40 <Marvin--> forcer: yes. no.
01:54:47 <forcer> Marvin--: damn :)
01:54:57 <Marvin--> forcer: :)
01:54:58 <forcer> det: btw, you need to remove one line from _darcs/prefs/boring
01:55:10 <forcer> det: it makes darcs ignore files starting with a dit
01:55:11 <forcer> dot
01:56:59 <det> yeah, just ran across that
01:57:56 <det> it seems silly that darcs should refuse to add a file I ask it to
01:58:10 <forcer> i guess that's for darcs add *
01:58:11 <forcer> or so
01:58:22 <det> oh
01:59:25 <det> how can I tell darcs to use a server?
02:00:20 <forcer> the way you'll find most familiar is using  darcs push --and-apply user@server:/repodir
02:00:24 <forcer> using ssh
02:00:53 <det> ahh, neat
02:00:54 <forcer> but darcs has a few ways of using it that i like a lot that don't fit with the notion of a central repository :)
02:01:44 <forcer> e.g. it's totally normal to pull patches from a number of different sources (other darcs repositories from other developers), and cherry-pick the patches they applied to their own trees
02:01:46 <Marvin--> well, that's because there IS no central repository...
02:02:11 <forcer> darcs can also push via email, which is quite nice as well
02:02:35 <shapr> argh, I'm trying to homework :-)
02:02:40 <forcer> shapr: :))
02:02:50 <shapr> I have a wikiwiki repository 
02:02:51 <det> So, if I am on a new machine and I want to grab all my config files from this machine I can do "darcs XXX chris@detriment.org:" ?
02:03:03 <shapr> "darcs get http://www.ScannedInAvian.org/repos/wikiwiki"
02:03:14 <forcer> det: actually, darcs get http://.../
02:03:30 <shapr> right, I'm using darcs to do 2-way sync from my client and dev machines
02:03:44 <shapr> sometimes I use vi to make a quick hackish change to see if it fixes something
02:04:00 <shapr> if it does, I can just pull the patch into my dev repo
02:04:16 <shapr> it's *really* nice.
02:04:27 <det> forcer: does it actually work over http ?
02:04:39 <forcer> det: it just needs access to the _darcs directory
02:04:44 <shapr> pulling works over http
02:04:50 <shapr> pushing requires ssh or email
02:04:59 <shapr> the wikiwiki repo uses email for pushing
02:05:00 <det> I can pull over ssh as well ?
02:05:05 <shapr> yes
02:05:43 <shapr> det: I'm in "Swedish for Invaders" school.
02:06:31 <forcer> shapr: have you finished your homework? :)
02:06:41 <shapr> no, not yet, I'm going back underground now :-)
02:06:44 <det> shapr: what is that ?
02:06:45 <forcer> damn :)
02:06:57 <shapr> forcer: but, why not make a darcs-vc.el mode?
02:07:04 <shapr> something that is what vc should be for darcs?
02:07:20 <forcer> shapr: that's what i'm thinking about
02:07:32 <shapr> that's what I want
02:07:33 <det> email for pushing
02:07:34 <forcer> shapr: but i need someone who uses darcs more then i do for a specification
02:07:39 <det> that is crazy :)
02:07:50 <forcer> det: not really. mono uses news. THAT is crazy.
02:07:50 <shapr> I was trying to fit my vc-cvs.el habits into darcs, but it doesn't work
02:07:53 <forcer> ;)
02:08:11 <shapr> det: it's *nice* I can give you commit privs with only your public PGP key
02:08:27 <det> agreed
02:08:39 <det> but still, over email!
02:08:49 <shapr> then 'darcs push -s' creates the patch, signs it, and send the email to hlibs@scannedinavian.org
02:08:59 <Marvin--> det: why not?
02:09:09 <shapr> det: you're used to doing it the hard way, eh?
02:09:12 <shapr> :-)
02:09:16 <forcer> :)
02:09:18 <shapr> anyways, läxa...
02:09:24 * shapr forsvinner
02:09:26 * Marvin-- lÃ¤xar upp shapr
02:09:38 <det> why not have a stand-alone darcs serevr that accepts pgp-signed darcs patches ?
02:09:52 <Marvin--> det: because it's more work?
02:11:29 <det> I guess
02:11:51 * forcer ponders adding -I _darcs to his ls alias
02:12:15 <det> shapr: how does it get patches from email ?
02:12:26 <forcer> det: procmail runs darcs
02:12:35 <det> I see
02:12:50 <ski> forcer : what's -I ?
02:12:53 <forcer> ski: ignore
02:12:55 <forcer> gnu ls
02:17:42 <Swynndla> forcer ... I did a man ls ... but it's still not clear to me what the -I option does
02:18:16 <forcer> Swynndla: it ignores files matching the parameter, like it normally ignores dot files
02:20:34 <Swynndla> forcer, can you give me an example?
02:21:10 <forcer> <0>forcer@forcix[5]:/tmp/foo$ ls
02:21:10 <forcer> bar  baz  _darcs/  foo
02:21:10 <forcer> <0>forcer@forcix[5]:/tmp/foo$ ls -I _darcs
02:21:10 <forcer> bar  baz  foo
02:21:42 <Swynndla> ahhhhhhhhhhhh
02:22:08 <ski> why isn't _darcs/ .darcs/ instead ?
02:22:45 <forcer> ski: i guess so that it's not ignored by ls
02:22:49 <forcer> :))
02:23:25 <Marvin--> heh
02:28:40 <kowey> hi room...
02:28:54 <kowey> could anyone tell me where i could find the substS function mentioned in PLEAC?
02:28:57 <ski> hi kow-ey
02:29:04 <kowey> http://pleac.sourceforge.net/pleac_haskell/strings.html
02:29:27 <ski> yes ?
02:29:36 <kowey> ski: was that the haskeller's anonymous hello? :-)
02:30:37 <ski> in http://pleac.sourceforge.net/pleac_haskell/a1102.html it says "use http://www.dcs.gla.ac.uk/~meurig/regexp/ for substS, ..."
02:31:42 <kowey> ah-hah... thanks
02:32:21 * ski kindly tells kowey to rtfs better :)
02:33:00 <kowey> nod... google builds bad habits
02:33:06 * kowey slaps own wrists
02:45:17 <kowey> trim (' ':xs) = trim xs
02:45:17 <kowey> trim xs = xs
02:45:25 <kowey> seems simpler... who needs extra libs?
02:46:16 <ski> what do you mean ?
02:46:39 <ski> trim = dropWhile (== ' ')
02:46:41 <kowey> PLEAC was telling me to use substS to implement trim, but this means downloading that RegExp lib
02:46:51 <kowey> ooh tinier!
02:47:16 <ski> and quite clear/easy to read/understand
02:47:25 <ski> (if you know dropWhile)
02:47:40 * kowey does not miss java
02:49:23 <skew> kowey: :(
02:49:27 <skew> kowey: I sympathize
02:49:51 <kowey> what, with the forehead slapping of "what was i doing all this time programming in java?"
02:49:59 <skew> ski: what if you want to lose trailing spaces?
02:50:11 <kowey> skew: how about reversing the string?
02:50:21 <ski> skew : reverse . trim . reverse
02:50:28 <skew> kowey: Well, I'm my case it was more constantly grumbling about having to use such a braindead language, but about the same idea
02:50:49 <kowey> there's not jython for haskell? jhaskell?
02:50:59 <forcer> ski: i don't know dropWhile, and I don't know much Haskell, and I found it clear to read :P
02:51:06 <skew> Hmm. I realized reverse . trim . reverse would work, just not that you would write it like that.
02:51:16 <skew> kowey: There's the JVM bridge
02:51:28 <skew> It's not as dynamic, but it works pretty well
02:51:32 <Marvin--> skew: well, you need to be sure you do it at the end of the string, so you have to traverse the string anyway
02:51:58 <kowey> i guess another issue is whether co-workers are willing to read/edit the haskell bits
02:52:57 <skew> It also doesn't have anything specifically for building Haskell native extensions for Java, so the main program is Haskell, and fairly ugly two
02:53:04 <skew> because you must use name mangling
02:53:35 <skew> trim should probably use isSpace, anyway
02:53:51 <skew> lstrip = dropWhile isSpace
02:54:03 <skew> trim = reverse . lstrip . reverse . lstrip
02:54:14 <kowey> nod... thx
02:54:27 <skew> If you must use Java, I'd use Jython
02:55:37 <Marvin--> I guess you could do something like
02:55:39 <Marvin--> rtrim [] = []
02:55:40 <Marvin--> rtrim (x:xs) = case rtrim xs of
02:55:40 <Marvin-->                  [] | isSpace x -> []
02:55:40 <Marvin-->                  ys -> x:ys
02:56:35 <skew> I don't think trying to come up with fancier functions on [Char] is worthwhile
02:56:41 <Marvin--> indeed
02:56:43 <skew> faster, that is
02:56:49 <Marvin--> just showing that it can be done without reverse
02:57:13 * ski is working on another idea to solve it ..
02:57:38 <skew> In the event you need faster strings I think the thing to do would be take PackedString or something
02:57:49 <Marvin--> definitely
02:57:56 <Marvin--> [Char] is useless for speed
02:57:57 <skew> and build a "String" typeclass for nice operators
03:08:58 <ski> hmm, my sol. is a little longer than Marvin--'s
03:09:08 <ski> but interesting IMHO
03:09:15 <ski> wanna see it ?
03:09:50 <skew> sure
03:10:06 <ski> rtrim = (`walk` id)
03:10:06 <ski>   where
03:10:06 <ski>   walk [     ] k  = k []
03:10:06 <ski>   walk (' ':s) k0 = lookout s
03:10:06 <ski>   $ k0 . (' ' :)
03:10:06 <ski>     where
03:10:08 <ski>     lookout [     ] _ = k0 []
03:10:10 <ski>     lookout (' ':s) k = lookout s
03:10:12 <ski>       $ k . (' ' :)
03:10:14 <ski>     lookout ( c :s) k = walk s
03:10:16 <ski>       $ k . (c :)
03:10:18 <ski>   walk ( c :s) k  = walk s
03:10:20 <ski>   $ k . (c :)
03:10:27 <ski> hmm, tabs didn't show well
03:10:57 <Marvin--> sheesh
03:11:01 <Marvin--> bleedin' CPS
03:11:43 <ski> Marvin-- : first i though of nqCPS, but then it seemed i didn't need it
03:11:56 * forcer doesn't understand a word :)
03:12:01 <Marvin--> my solution has the advantage of actually being readable ;)
03:12:24 <ski> Marvin-- : more readable. i'll concur to that
03:13:02 <ski> (the lines beginning with $ should be indented more)
03:13:32 <shapr> forcer: if you like elisp, you might like Haskell also.
03:14:08 <forcer> shapr: i know haskell conceptually a bit, but the syntax eludes me. and it would be cruel to compare an imperative pseudo-lisp like elisp with Haskell :)
03:14:11 <Marvin--> ski: might get more readable if you use a CPS monad
03:14:46 <ski> Marvin-- : in this particular example, perhaps
03:15:40 <forcer> shapr: are you back from homework? :P
03:16:20 <shapr> forcer: sort of...
03:16:40 <shapr> I have to go to class in ten minutes, so any homework that's not done now, won't be done before class.
03:16:46 <forcer> ;)
03:16:51 <forcer> then i'll go to bed soon
03:17:25 <shapr> anyways, my emacs + darcs habits are usually save and record, or save, record, push
03:18:03 <forcer> ok, thanks :)
03:18:14 <ejt> shapr: have you had any problems with darcs heap useage ?
03:18:28 <shapr> and I'd like to be able to add this buffer/file to darcs
03:18:41 <forcer> ok
03:18:43 <ejt> I tried to import the linux kernel and it died horribly
03:18:47 <shapr> ejt: no, but I'm working with small amounts of python sources, not big sources.
03:19:00 <shapr> ejt: the solution for that is to import it in smaller chunks
03:19:15 <shapr> david uses the linux kernel for his big tests of darcs as well
03:19:29 <ejt> ooh, it's good to know that it works for someone
03:20:14 <shapr> someone imported a very large source tree (150MB?), and said the only way they could do it was to break the add/record cycle into smaller pieces
03:20:52 <shapr> anyways, I know david is working on that, it's caused some interesting traffic on the ghc-users mailing list.
03:21:03 <shapr> I'm happy to see Haskell applied to real everyday use this way :-)
03:21:54 <shapr> for me, darcs is really useful for doing easy and intelligent two-way source synchronizing as well as source control.
03:23:19 <shapr> ejt: I think someone got a massive source tree recorded in a single step with 36 hours of running time, and once they broke it down into smaller steps it took something like one to three hours.
03:23:50 <ejt> that needs to be reduced drastically for people to take it seriously
03:23:57 <shapr> yup
03:25:07 <shapr> I know that david is working on it, I don't know if that behaviour has changed recently.
03:25:35 <Marvin--> note to self: start writing that PhD student application already
03:25:40 <skew> I should really start using revision control
03:25:50 <skew> how much does it take to set up darcs?
03:26:00 <forcer> skew: ghc ;)
03:26:16 <forcer> if you have access to binaries, not even that
03:26:30 <shapr> if you have darcs binaries, it takes about a minute to start using darcs
03:26:34 <skew> I was looking at subversion, and didn't feel like tweaking an apache and bdb
03:26:54 <forcer> darcs is really lightweight
03:26:55 <forcer> :)
03:26:58 <forcer> another pro
03:27:19 <forcer> the only problem is, if it's not there already, getting it compiled can be a pain
03:27:19 <forcer> :(
03:27:32 <forcer> (our CS campus has broken solaris machines where GHC doesn't compile)
03:27:33 <Marvin--> skew: you don't need to do any tweaking
03:27:55 <Marvin--> skew: for local use, file:// works just fine, for remote use, svn+ssh:// works just fine
03:28:19 <skew> The last time a friend got it to build with it's apache under the version of gentoo I'm running, it took a bit of work
03:28:37 <skew> Something about the apache build only seeing a version of Bdb a bit too recent
03:28:43 <forcer> skew: svn _can_ use an apache module as a server, it doesn't have to
03:29:09 <shapr> darcs requires ghc and a filesystem.
03:29:12 <shapr> skew: using debian?
03:29:18 <skew> shapre: gentoo
03:29:33 <shapr> I think there's an emerge, or whatever you call it.
03:30:39 <skew> So there is.
03:30:46 <skew> Well, darcs and subversion are building
03:30:52 * forcer grins.
03:30:58 <forcer> try arch as well to be complete ;)
03:31:35 <skew> Hmm, appareently I'm installing ruby now
03:32:21 <shapr> when you have darcs installed, do "darcs get http://www.ScannedInAvian.org/repos/wikiwiki" to grab a repo, then make changes (there's only a README atm) then "darcs record" and "darcs push" to push the changes back to the online repo.
03:33:42 <shapr> time for skolan!
03:33:45 <shapr> bbl
03:33:56 <ski> shapr : hejdå
03:34:32 <skew> How is ruby? (Now that I've got it installed)
03:35:02 <Marvin--> well, I'm off to a lecture, see you guys
03:35:20 <forcer> skew: a thing between perl and python. it has a few nice ideas, but hides them quite well beneath a huge lot of unintuitive syntax.
03:38:16 <skew> I don't know perl at all
03:41:06 <forcer> skew: that's ok, believe me.
03:41:18 <skew> That's what I've heard
03:41:21 <forcer> perl's a huge pile of DWIM-syntax with a lot of special cases
03:41:38 <skew> I think the only perl I've seen was an unlambda interpreter, and bits of cons
03:43:08 <forcer> interesting, looks like i haven't written any perl in quite some time
03:43:10 <forcer> that's good :)
03:43:55 <skew> I wonder what happend to the unlambda interpreter I made
03:44:14 <skew> I mailed it in, but I haven't heard anything
03:44:37 <forcer> put it on your website
03:44:37 <forcer> :)
05:54:53 <skew> hi shapr. darcs seems to worked
05:55:12 <skew> I added some ? to the test file
05:55:42 <harsha123> hello #haskell
06:02:33 <andersca> is there a built-in function for taking the value out of a Maybe ?
06:03:07 <skew> and assuming there always is one?
06:04:04 <andersca> yes
06:04:12 <skew> okay, fromJust
06:04:16 <andersca> thanks
06:04:19 <skew> check out Data.Maybe
06:04:29 <skew> "maybe" is good to use too
06:08:26 <shapr> skew: neato
06:20:15 <shapr> skew: did you push your changes?
06:22:00 <skew> I think so
06:22:14 <shapr> hm, I don't see them. I'll check the logs
06:23:41 <skew> I guess I didn't
06:24:12 <skew> because darcs asked me if I wanted to push the patch when I told it to push
06:24:21 <skew> See if you have it now
06:39:50 <Lunar^> shapr: sebc's in France :)
06:40:19 <Lunar^> shapr: he's staying a bit, I think we're going to make progress on hOp :)
07:14:40 <shapr> Lunar^: yay!
07:23:04 <shapr> argh
07:23:10 <shapr> I tried to write swedish...
07:23:15 <shapr> once more, in english
07:23:23 <shapr> does anyone know of an NNTP lib in Haskell?
07:24:53 <Segora> no. wanted to write one once, but got distracted by other aspects of the absurd idea that triggered the wish ;)
07:27:21 <shapr> I have a client who wants me to slurp everything from an NNTP server into an MS Access database.
07:27:51 <bring> MS Access, hihi
07:28:30 <bring> sorry, couldn't help myself
07:28:47 <shapr> it is funny, I admit :-)
07:29:14 <shapr> I think I may use postgresql and try to persuade the guy to use the pg ODBC driver to import data.
07:39:12 <earthy> op huus an
07:40:24 <shapr> Segora: did you end up with any code for the NNTP lib?
07:41:16 <bring> shapr: just use postgre, then give it to him in CSV or something :)
07:41:39 <bring> preferrably printed on used paper with a tiny font
07:41:51 <shapr> I'm not sure my client could import a CSV file into access.
07:42:10 <bring> :)
07:42:45 <bring> the customer is always right I guess
07:42:54 <shapr> yes, sadly.
07:43:18 <shapr> or at the least, he's a really nice guy who wants to do this for statistical psychological research.
07:44:15 <shapr> would be nice to get paid a second time for writing some Haskell code :-)
08:08:24 * kowey sighs
08:08:33 <kowey> anyone see anything like this:
08:08:41 <kowey> /lib/libgcc_s.so.1(*IND*+0x0): multiple definition of `__divdi3@GLIBC_2.0'
08:08:41 <kowey> /lib/libc.so.6(.text+0x380): first defined here
08:08:52 <kowey> i get this trying to compile something with wxhaskell
08:10:00 <Igloo> What version of GHC do you have?
08:10:11 <kowey> 6.2
08:10:48 <kowey> i'm trying to make sure i didn't accidentally compile wxhaskell itself with the wrong ghc (5.x on the machine), but doubtful
08:11:20 <Igloo> On x86?
08:11:34 <kowey> yes, sorry, it's Linux, Mandrake 9.0
08:11:45 <Igloo> Did you compile GHC yourself, on that machine?
08:11:59 <kowey> yes... there was a /usr/bin/ghc which i don't override
08:12:20 <Segora> shapr: no, unfortunately not (nntp code frags)
08:12:22 <kowey> instead i put my haskell in a separate place and tell everyone else (happy, wxhaskell, etc) to use that
08:12:49 <Igloo> Is wxhaskell using the full path to compile with?
08:13:00 <Igloo> make tends to prefer things in /usr/bin over things that come sooner in your path
08:13:02 <kowey> yes... although... hmm
08:13:09 <kowey> maybe ghc-pkg needs to be set
08:13:43 <Igloo> If you've got the URL handy I could see if it works for me
08:14:08 <kowey> what do you mean? http://wxhaskell.sourceforge.net
08:14:21 <kowey> don't go to any trouble though... i'm betting on my not having set hcpkg correctly
08:22:07 <Igloo> Does this find anything in your build tree? strings ghc/rts/Linker.o | grep __divdi3
08:22:49 <kowey> this is the wxhaskell tree you refer to?
08:22:55 <Igloo> No, the GHC one
08:23:09 <kowey> yep
08:23:31 <Igloo> In fact, "nm ghc6-6.2/ghc/rts/Linker.o | grep __divdi3" would be a more sensible check
08:24:18 <kowey>          U __divdi3
08:24:24 * kowey needs to learn more about libraries and unix
08:25:43 <Igloo> OK, that's the same as I have. I don't have time to try to remember/work out the problem here, but I'll let you know if it builds OK or not for me
08:27:51 <kowey> thanks :-)
08:42:49 <kowey> LD_LIBRARY_PATH would not be involved, would it? (during linking)
08:45:09 <Igloo> make looks like it finished OK
08:45:50 <kowey> well i'm going to try compiling a wx sample
08:45:55 <Igloo> Ermm, not sure. The issue as I recall is something like both /lib/libc* and /lib/libgcc* defining the symbols
08:46:12 <kowey> right
08:46:32 <kowey> i'll note that if i comment out the wx bits of my source, my code links happily
08:46:32 <Igloo> But I can't remember more than that. The archives might have clues, and possibly workarounds. 6.2 ought to have the solution too, AFAIK, though  :-/
08:46:52 <Igloo> Oh, it's actually using wxhaskell not building it?
08:46:56 <kowey> using
08:47:27 <kowey> building wxhaskell is fine (argh, sorry to make you go through that... hopefully wx will come in handy for you later)
08:48:02 <kowey> nantois wx 220 % ghc -package wx HelloWorld.hs 
08:48:02 <kowey> /lib/libgcc_s.so.1(*IND*+0x0): multiple definition of `__divdi3@GLIBC_2.0'
08:48:02 <kowey> /lib/libc.so.6(.text+0x380): first defined here
08:48:10 <kowey> ok... so it's not my code, at least
08:48:30 <kowey> /lib/libgcc_s.so.1(*IND*+0x0): multiple definition of `__umoddi3@GLIBC_2.0'
08:48:30 <kowey> /lib/libc.so.6(.text+0x480): first defined here
08:48:30 <kowey> /lib/libgcc_s.so.1(*IND*+0x0): multiple definition of `__udivdi3@GLIBC_2.0'
08:48:30 <kowey> /lib/libc.so.6(.text+0x460): first defined here
08:48:30 <kowey> /lib/libgcc_s.so.1(*IND*+0x0): multiple definition of `__moddi3@GLIBC_2.0'
08:48:32 <kowey> /lib/libc.so.6(.text+0x3f0): first defined here
08:48:35 <kowey> collect2: ld returned 1 exit status
08:48:36 <Igloo> I wonder if it could be caused by the WX libraries linking against them
08:48:38 <kowey> as well
08:49:17 <kowey> any way to find out / fix+
08:49:17 <kowey> ?
08:49:38 <Igloo> From "ldd /usr/lib/libwx_gtk-2.4.so" it looks like it links against both
08:49:55 <Igloo> Do C++ WX programs link OK?
08:50:29 <kowey> i'll check
08:51:42 <kowey> well, i can compile and run the minimal example
08:53:26 <kowey> and a fancier example
08:55:18 <Igloo> OK, I suggest either looking through list archives or mailing glasgow-haskell-bugs@ giving all the details you have then
08:55:36 <kowey> thanks again for your help
08:55:46 <Igloo> np
08:55:50 <kowey> aside from these woes, wxhaskell seems quite nice to program in :-)
08:56:08 <Igloo> :-)
08:56:27 <Igloo> Oh, mailing the WXH maintainer might be worthwhile too
08:56:51 * kowey suddenly remembers to look on the sourceforge page
08:58:34 <kowey> hmm... there was a new release for 6.2... 
08:59:15 <kowey> as of today!
09:01:54 <Igloo> :-)
09:14:06 <kowey> sigh... this neither.  think i'll contact the maintainer
09:20:57 <Igloo> Something very odd is going on here
09:22:30 <Igloo> Ah, I had a variable set wrong
09:57:48 <kowey> Igloo: just an update... i tried logging on to a different Linux machine with a newer version of Mandrake
09:58:02 <kowey> and it works (haskell, etc installed on a NFS-shared directory)
10:20:41 <andersca> hmm, what's the opposite of unless in Monad?
10:21:00 <shapr> when?
10:21:01 <ski> when
10:21:05 <Jad> hello guys
10:21:07 <shapr> hi Jad 
10:21:11 <ski> Jad : hello
10:21:33 <Jad> shapr i emailed paul hudak
10:21:43 <Jad> and he added a link to the soe library
10:21:43 <ski> oh :)
10:21:49 <shapr> ah, nice
10:22:16 <Jad> http://haskell.org/soe/graphics.htm
10:23:04 <andersca> ah, thanks
10:25:46 <kowey> bye, room
10:35:30 <Jad> bye
10:48:41 <Igloo> Fighting TODO lists is hard work
10:57:40 <Darius> Doing the things on my TODO list is on my TODO list.
10:58:38 <ski> I haven't even got a TODO list. Getting one would probably be on it.
11:49:55 <Marvin--> heh, jumptheshark.com is a fun page
12:07:40 <ski> hello, H-kan
12:08:30 <ski> H-kan : is it Håkan ??
12:22:36 * Darius is unsurprised by the top "Shark Vote Getter"
12:27:40 <Marvin--> Darius: :)
13:19:15 <SyntaxNinja> Heffalump: happy birthday :)
13:19:18 <SyntaxNinja> (belated)
13:27:09 * Igloo wonders how you knew about it
13:27:37 <SyntaxNinja> Igloo: orkut ;)
13:28:23 <Igloo> Oh dear  :-)
13:28:46 <Lemmih> What's orkut?
13:29:11 <Riastradh> A grand silliness that is spreading like the plague throughout the internet.
13:29:51 <Lemmih> url?
13:30:14 <Riastradh> orkut.com, probably.
13:31:01 <mattam> Riastradh: w2k3 sources ?
13:31:42 <Riastradh> ?
13:32:24 <SyntaxNinja> Lemmih: it's a "social networking" web site where you can easily find and correspond with people who have a shared interests.
13:32:33 <SyntaxNinja> s/a shared/shared
13:32:35 <mattam> windows 2003 sources were leaked apparently...
13:32:52 <ludde> mattam: to where?
13:33:01 <Heffalump> SyntaxNinja: ta :-)
13:33:13 <Heffalump> it is definitely very silly.
13:33:30 <mattam> well, it's on some sites right now, but i don't know where.
13:35:03 <SyntaxNinja> I think that orkut and friendster are fads, but I think that something useful and interesting will come out of them.
13:35:20 <Darius> Heffalump mentioned he had a birthday coming up about a week or so ago.
13:35:58 <Heffalump> did I? That was careless of me :-)
13:36:16 <Heffalump> I like the idea of a central point of contact for people in the future
13:36:19 <SyntaxNinja> now everyone knows.  Heffalump is going to remove me from his friends list for breaking the sacred orkut trust.
13:36:29 <Marvin--> heh
13:36:41 <Heffalump> I think my birthdate (but not age) is public, actually :-p
13:37:09 <Igloo> public in what sense?
13:37:24 <Heffalump> anyone with an orkut account can see it
13:37:49 <SyntaxNinja> I think combining orkut with debianplanet would be interesting.
13:37:53 <SyntaxNinja> and perfectly natural.
13:38:07 <Heffalump> debianplanet? That's just Yanother news site, isn't it?
13:42:29 <SyntaxNinja> it's a debian-related blog aggregater, unless I'm getting it mixed up with planetdebian :)
13:43:57 <Igloo> Has anyone got a good URL about constants and inline functions vs #defines?
13:46:32 <Marvin--> SyntaxNinja: you are. debianplanet is a news site, planetdebian is a blog thingy
13:48:31 <SyntaxNinja> sorry
13:50:06 <SyntaxNinja> however, debianplanet does seem to be mirroring some planet debian stuff for some reason.
14:21:04 * Marvin-- sighs
14:21:09 <andrewc> hello?
14:21:16 <Marvin--> hey
14:21:36 <andrewc> if anyone is out there i have an embarassingly stupid question.
14:21:43 <Marvin--> shoot
14:21:59 <andrewc> (is a Marvin that sighs a bot or for real?!)
14:22:24 <andrewc> maybe i read too much douglas adams.
14:22:39 <ski> andrewc : hard to tell ?
14:22:44 <Marvin--> heh, I'm for real, I'm sighing because I'm trying to write a letter of application for a PhD student position
14:23:04 <andrewc> ah.  clearly an intelligent answer. :o)  sorry.
14:23:16 <Marvin--> yay, I passed, take that, Turing!
14:23:41 <andrewc> what's the function that tests a list (using either equality or a
14:23:50 <andrewc> user specified fuction) to see if it contains
14:24:04 <andrewc> a particular member?  i sear i've looked in the docs!
14:24:08 <ski> @type elem
14:24:08 <lambdabot> elem :: Eq a => a -> [a] -> Bool
14:24:14 <andrewc> argh!
14:24:16 <andrewc> thanks!
14:24:36 <mattam> @type find
14:24:42 <Marvin--> @type any
14:24:42 <lambdabot> any :: (a -> Bool) -> [a] -> Bool
14:25:04 <andrewc> cheers.
14:25:10 * mattam is more an ocaml guy :)
14:25:19 <Marvin--> mattam: tsk tsk, go stand in the corner :-)
14:25:20 <andrewc> if anyone is interested there's a pre-release of some haskell
14:25:33 <andrewc> code that generates web pages from templates
14:25:43 <andrewc> at http://www.acooke.org/jara/halipeto
14:26:06 <andrewc> i'm not announcing it on the haskell list yet as i'm fixing
14:26:13 <andrewc> a few things i've just noticed.
14:26:29 <Riastradh> Like your enthusiastic return key?
14:26:34 <ski> andrewc : so you're andrew cooke ?  shapr pointed to that site earlier today
14:26:45 <andrewc> mattam - do you know of anocaml orb?  i can't find one.
14:26:49 <andrewc> yes.
14:27:01 <andrewc> should i just type long lines?  sorry - i don't know much about irc.
14:27:22 <Marvin--> irc clients word wrap just fine, so long lines are often better
14:27:27 <andrewc> is shapr shae?
14:27:31 <ski> yes
14:27:32 <Marvin--> for sure, don't line break in the middle of a sentence!
14:27:58 <andrewc> ah, ok.
14:28:29 <andrewc> where are you applying for th ephd?
14:29:03 <Marvin--> Chalmers
14:29:22 <Marvin--> trying to figure out where else to apply to too
14:29:41 <andrewc> well, i've heard of that, so it must be famous ;)  good luck.
14:29:54 <andrewc> is it haskell related?
14:30:06 <Marvin--> yeah
14:30:09 <ski> andrewc : some famous haskell people are here, yes
14:30:22 <ski> e.g. John Hughes
14:32:23 <andrewc> ah ok. (just googled for him - i'm useless with names - and it turned up loads of stuff i've read.)
14:32:44 <ski> mhmm
14:33:05 <Marvin--> heh
14:33:12 <ski> andrewc : you're on lambda the ultimate, yes ?
14:33:31 <Marvin--> which reminds me I should prod Koen and John about releasing a new version of QuickCheck
14:34:13 <andrewc> ski - well, yes, i was there at the beginning, but these days i don't post so much
14:34:21 <mattam> andrewc: i read there will be bindings for gnome's one but i'm not sure. It's overly complicated IMHO.
14:34:33 <andrewc> (although i have been the last few days as i'm on summer holiday)
14:35:12 <andrewc> yeah, i think it's complicated too.  BUT if i can find a decent language with CORBA support i can probably get to use it at work.
14:35:30 <ski> andrewc : you're on the southern hemisphere ?
14:35:33 <andrewc> so far i've found almost nothing.
14:35:51 <andrewc> yep, chile.  sitting out in my garden in the evening sun with my laptop.  life is good.
14:36:26 <ski> here it's cold weather RN :/
14:36:47 <mattam> i envy you andrewc :)
14:37:07 <andrewc> but at least you have heating.  here in winter it's not that cold (maybe 40F), but the house has NO central heating!
14:37:32 <ski> ok, hm
14:38:09 <Marvin--> 40F... that's quite chilly without heating
14:38:29 <andrewc> we have little gas heaters on wheels that we wheel around wherever we go.
14:38:46 <andrewc> but they don't work very well.
14:38:56 <andrewc> oops.  an extra return there.
14:39:54 <andrewc> lua and, i think, python have corba support.  maybe javascript too.
14:40:19 <andrewc> really i'd like something with static types though.
14:41:22 <ski> (hmm, i actually (joined and) posted on lambda, recently)
14:41:53 <andrewc> i hope i wasn't rude about your post!  (as i said, i'm terrible with names).
14:42:28 <ski> i don't think you were rude
14:42:58 <andrewc> hey, according to google you helped me out!  thanks!
14:43:20 * ski was just struck be a doh!-attack and joined lambda then
14:43:26 <ski> when ?
14:43:29 <ski> usenet ?
14:44:20 <andrewc> on lambda.  i was asking about currying complex interfaces and you posted a load of stuff on template haskell.  i didn't understand it and had to go lookig stuff up :o)
14:44:28 * ski thinks he has seen andrewc on usenet
14:44:37 <ski> ?
14:44:58 <ski> i haven't posted anything about template haskell, that i know of
14:45:10 <andrewc> maybe.  i've been around for a while.  maybe 5 years ago i posted to clf a fair bit.
14:45:15 <ski> but i was posting to currying complex interfaces
14:45:45 <andrewc> sorry, i'm mixing up two posts on the same thread.
14:45:53 <ski> andrewc : perhaps c.l.s ?  i might be confusing people, though
14:45:58 <ski> :)
14:46:40 <andrewc> hang on.  trex, not template haskell.
14:46:47 <ski> right :)
14:46:49 <andrewc> cls?
14:46:54 <andrewc> scheme?
14:46:58 <ski> comp.lanf.scheme
14:47:01 <ski> lang
14:47:03 <ski> mm
14:47:16 * ski 's not sure
14:47:44 <andrewc> more likely lisp, but years and years ago.
14:48:17 * ski started reading usenet 1999, he thinks
14:48:37 <andrewc> there's not a corba binding for scheme, either!
14:49:00 <ski> perhaps someone could make an SRFI for that
14:49:54 <andrewc> (according to google i've posted 8 times to cls!)
14:50:06 <ski> oh :)
14:50:25 <ski> then, i'm probably confusing things
14:50:36 <andrewc> i guess you need to pick a particular oo extension (is there a preferred/semi-official one?)
14:50:50 <ski> for corba ?
14:51:19 <andrewc> preferred way of adding objects to scheme.  as far as i know, corba thinks in terms of objects.
14:51:25 * ski isn't totally sure what corba is
14:51:38 <ski> somewhat similar to COM ?
14:51:42 <andrewc> ah, sorry - it's a way of inter-operating between different 
14:51:45 <andrewc> yes.  
14:52:04 <ski> i'll guess i someday have to look at that in more detail
14:52:17 <andrewc> com (or dcom?) is microsoft's corba
14:52:39 <andrewc> it's not interesting, really, it's just lots of details to make things work.  engineering.
14:52:40 <ski> Common Object Request Broker A...?
14:52:48 <Heffalump> rchitecture
14:52:50 <ski> something like that, i think
14:53:24 <ski> some people seem talk about "component-oriented-programming"
14:53:46 <ski> is that of any interest ?
14:53:52 <ski> or just a buzz word
14:53:58 <ski> or both ?
14:54:02 <Heffalump> both, I think
14:54:03 <esap> both
14:54:11 <ski> :)
14:54:41 <andrewc> i guess corba or com is middleware for that.
14:54:43 <esap> component-oriented just means that you have components and interfaces.
14:54:52 <Riastradh> andrewc, no, there is no 'semi-official' object system or anything for Scheme.
14:55:08 <andrewc> thanks.
14:55:15 <ski> but, presumably, it comes with a design/thinking style/"paradigm"
14:55:49 <esap> ski; well yes, you are supposed to have all communication with a component be performed via those interfaces.
14:56:23 <ski> hmm
14:56:44 <esap> the buzz-word thing is of course quite different :-)
14:57:11 <ski> from that descr. it sounds similar to OO. but the detail might well be quite different
14:57:18 <andrewc> rats.  sorry, i should be making dinner.
14:57:26 <andrewc> must go.  tahnks for the info.  bye
14:57:52 <esap> ski: it is very closely tied to OO paradigm
14:58:25 <ski> i'd suppose that there would be at least some big similarities
14:59:31 <ski> hmm
14:59:38 <ski> that reminds me..
14:59:47 <ski> hm
15:00:19 <ski> esap : ?
15:00:36 <esap> ski: ?
15:00:41 <ski> :)
15:00:55 <ski> well
15:00:57 <Marvin--> !
15:01:04 <esap> no, not this again :-)
15:01:14 <ski> esap : are you busy, or tired or some such ?
15:01:19 <ski> not what again ?
15:01:51 <esap> ski: not busy, but going to get some sleep in about two hours or so.
15:02:08 <ski> ok, hm
15:02:12 <esap> ski: I mean, the ? vs ! thing :-)
15:02:28 <ski> esap : I don't recall that
15:02:48 <Marvin--> sorry :)
15:02:52 <esap> oh, you weren't there when we had a long discussion with "X vs Y" thing?
15:03:12 <ski> @wiki QuotesPage
15:03:13 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
15:03:35 <ski> that one ?
15:04:46 <esap> right, the VersusQuotesPage thing.
15:04:55 <ski> I don't see any ! ? debate there
15:05:17 <esap> no, but I obviously connected the '?'/'!' thing to it.
15:05:26 <ski> ok
15:06:45 <ski> hmm, well, at least at some time, i would like to understand your paragraphs on MessageDispatching ..
15:07:32 <esap> what was the hard-to-understand part?
15:08:18 <esap> the whole thing? :-)
15:08:21 <ski> well, hm. i think i had trouble understanding some of your views there
15:08:40 <ski> not quite all of it ;)
15:09:18 <ski> (this could have to do with me not being so familiar to e.g. OOA/D or something)
15:10:03 <esap> probably. That's based on conceptual modelling that is advocated in some parts of the OO communnity (I think)
15:10:30 <ski> when i read it, i'd like to put coalgebras is "data as interface"
15:10:34 <esap> That is, the process where you identify 'concepts' from requirements, then structure your objects based on those concepts.
15:11:34 <esap> ski: well consider the operations for a coalgebra, say stream. You have head and tail. The names of the operations are important there. It doesn't matter what data is stored in the coalgebra, as long as it can support the head and tail operations.
15:11:42 <ski> there seems to be some (more or less) solid epistemology here i think
15:12:07 <ski> so it is 'data as interface' ?  no ?
15:12:41 <esap> no, it's 'data as resource'. The coalgebraic data type is a localized resource that stores data [you can access it via the 'head' and 'tail' operations.
15:13:06 <ski> the head and tail ops is an interface
15:13:09 <ski> right ?
15:13:10 <esap> yes.
15:13:41 <ski> so one could perhaps say that we really have a pointer/reference to an interface
15:13:44 <ski> no ?
15:14:20 <esap> in C++ terminology, that's how interfaces are handled. But it's a bit more complicated when you consider Haskell and referential transparency.
15:14:35 <ski> (is this reasoning somwehat similar to COM ?)
15:14:38 <esap> But the same thing.
15:14:47 <ski> mm
15:15:08 <ski> so i'd like to call coalgebra 'data as interface'
15:15:10 <esap> ski: I'm not sure which part of COM you are referring to. COM tries to be the "component oriented" thing.
15:15:29 <esap> ski: but why? What is the interface there?
15:15:57 <esap> ski: the data passed as argument to 'head', for example, is not at all important.
15:16:00 <ski> (well, i seemed to vaugely recall something about things (objects) there having multiple interfaces, and one had pointers to those)
15:16:21 <ski> the interface is the ops and their types
15:16:32 <ski> it's like a Java interface, e.g.
15:16:33 <esap> ski: Yes, COM has the "IUnknown" interface, which is a way to access different interfaces of the same object.
15:17:22 <ski> i.e. a java interface can be instantiated to many different implementations (classes)
15:17:58 <ski> so if you have an Comparable, you don't know what implementation (class) is behind that
15:17:59 <esap> ski: yes. But usually you think of it in the opposite way, e.g. an implementation _supports_ some set of interfaces.
15:18:19 <esap> ski: yes, exactly.
15:18:34 <ski> that's just similar to looking at functions/modules from the outside vs from the inside
15:18:42 <esap> yes.
15:18:51 <esap> objects are modules.
15:18:59 <ski> (more or less)
15:19:02 <esap> that provide access to some internal resources
15:19:52 <esap> usually, the resource is just memory space, but it can be something else as well, say a socket.
15:19:57 <ski> many module systems and sort of, regarding classes, ties *one* implementation to the interface
15:20:14 <ski> (though classes can be "inherited")
15:20:36 <esap> ski: true, but that's a different paradigm
15:20:50 <ski> in some one can make module-types/signatures/interfaces on their own
15:21:11 <esap> ski: that's why there is an empasis on surrounding components with interfaces in component-oriented programming.
15:21:24 <ski> what do you mean ?
15:21:32 <ski> "surrounding components" ?
15:21:51 <ski> aha
15:22:01 <ski> "surrounding components with interfaces"
15:22:03 <esap> ski: I mean, components are supposed to be independent of its environment. And interfaces can decouple the component.
15:22:10 <ski> yes
15:23:04 <esap> but it's important to note that a component can both 'provide' interfaces and 'use' interfaces. And both have to be considered and decoupled.
15:23:17 <ski> anyway, my more or less ideal intuitive pic of coalgebras correspond more to "free" interfaces than interfaces that are tied to a particular implementation (class)
15:23:40 <esap> ski: hmm.. but my understanding is that the coalgebra is the 
15:23:44 <esap> ski: hmm.. but my understanding is that the coalgebra is the resource.
15:23:54 <ski> what is the resource ?
15:23:58 <esap> ski: not the interface. the 'head' and 'tail' is the interface.
15:24:18 <esap> ski: I mean, 'data Stream a = Stream a (Stream a)' is a coalgebraic data type.
15:24:26 <ski> the interface is sortof like a type, right ?
15:24:35 <esap> ski: and values of that are more like objects (resources) storing some data.
15:24:51 <esap> ski: no, interface is not like a type
15:25:31 <ski> data Stream a = Head :: a & Tail :: Stream a
15:25:31 <esap> ski: interface is like 'class StreamI s where { head :: s a -> a, tail :: s a -> s a }'
15:25:45 <ski> isn't there an interface on the rhs of the = ?
15:26:47 <esap> ski: well I think that also includes the implementation.
15:26:53 <ski> no
15:26:56 <esap> ski: and interface doesn't include implementation.
15:27:04 <ski> i don't think so
15:27:17 <ski> an example of one possible implementation :
15:27:26 <ski> Head (repeat a) = a
15:27:34 <ski> Tail (repeat a) = repeat a
15:27:42 <ski> another implementation :
15:27:45 <esap> ski: in particular, data Stream' a = Head :: (a,Int) & Tail :: Stream a  also can implement the same interface.
15:27:47 <ski> Head (from n) = n
15:27:55 <ski> Tail (from n) = from (n + 1)
15:28:13 <ski> you don't think of these two as different implementations ?
15:28:29 <ski> (of Stream a, for some type a)
15:28:36 <esap> ski: yes, they are. But can you have both in the same program?
15:28:42 <ski> yes
15:28:45 <ski> i can
15:28:56 <esap> oh you mean 'from' and 'repeat' are the implementation.
15:29:23 <ski> from is somewhat like a From class in java implementing the interface
15:29:32 <esap> well I guess it's then the same as my use of the class, just with different syntax.
15:29:47 <ski> and repeat is like another class (not inherited) that also implements the interface
15:30:23 <ski> the actual repeat and from above work like constructors
15:30:25 <esap> actually, I would have to think 'from' and 'repeat' similar to instance declarations of that class. But the data type (implementation) is different
15:30:39 <ski> (like Java-constructors, i mean)
15:31:19 <ski> different from type classes ?
15:31:41 <esap> yes. There are three concepts: Interface, implementation, and 'relationship between interface and implementation'.
15:32:37 <ski> i'm not totally sure how these ideas relate to type classes. but i see at least an analogy between coalgebras an interfaces (in OO)
15:32:41 <esap> which are very much like 'type class', 'data type' and 'instance declaration'.
15:32:51 <ski> hmm
15:33:13 <esap> type class is the interface, data type is the implementation, and instance declaration is the relationship between the implementation and the interface.
15:33:14 <ski> what's the 'relationship' in OO ?  "implements" ?
15:33:26 <esap> yes.
15:33:59 <esap> but OO binds the relationship and the implementation together, which is bad.
15:34:04 <ski> hmm, one can emulate algebraic and coalgebraic types with type-classes, also :)
15:34:47 <ski> it's quite funny
15:35:04 <ski> esap : yes
15:35:54 <ski> i've also tried to think how these things relate to extensionability  (not inheritance)
15:36:07 <esap> what do you mean by extensionality there?
15:36:33 <esap> do you mean the rule for extensional equality?
15:37:57 <Darius> I think he means, extensibility.
15:38:04 <ski> for an algebraic datatype we have a *fixed* set of (direct) producers (namely the constructors). but we can make how many (direct) consumers we like (by pattern-matching). we can also make indirect producers, which can call indirect and direct producers. similary for indirect consumers
15:38:50 <ski> the thing that was extensible here was direct consumers
15:39:06 <ski> for the coalgebras, it's the dual picture
15:39:10 <esap> yes.
15:40:01 <ski> then i was thinking about how most OO restricts coalgebras (my just having classes). also, i still ignore inheritance
15:40:33 <ski> then in OO, we can only make *1* producer
15:40:53 <esap> coalgebras already include the important restriction there. For coalgebras, creation can fail, but destruction cannot fail. For algebras, creation cannot fail, but destruction can fail.
15:41:10 <ski> (as opposed to OO interfaces which can have mane producers/implementations)
15:41:31 <ski> fail, how ? what do you mean ?
15:41:38 <ski> pattern-match-failure ?
15:41:43 <esap> yes.
15:42:06 <Pseudonym> I'm not convinced.  Most algebraic interfaces, for example, have constraints which go beyond the algebra.
15:42:07 <ski> ok. then imagine that we are coding in a system that doesn't allow that !
15:42:10 <esap> for coalgebras, it does not make sense to return pattern match failure (or any other failure) from e.g. 'head' or 'tail' 
15:42:28 <Pseudonym> For example, binary search trees have the key ordering constraint, and possibly also a balance constraint.
15:42:59 <Pseudonym> So creation can "fail".
15:42:59 <ski> Pseudonym : what are you not convinced of ?
15:43:01 <Pseudonym> In that sense.
15:43:04 <esap> pseudonym: yes, but for coalgebras, it's the creation of the coalgebra that must satisfy that constraint. That's why the creation can fail.
15:43:24 <esap> pseudonym: oh you mean it as an algebra?
15:43:28 <Pseudonym> yES.
15:43:42 <Pseudonym> Are binary search trees actually co-algebraic?
15:44:01 <Pseudonym> Or are the constructors actually the "smart constructors" of the dictionary interface (which can't fail)?
15:44:13 <ski> Pseudonym : you are talking about archic algebras, as opposed to just anarchic (i.e. what datatype gives us in SML, e.g.)
15:44:22 * esap thinks about the key-ordeering.
15:44:30 <Pseudonym> I'm talking about Haskell's "data" keyword.
15:44:40 <Pseudonym> Is that archic or anarchic?
15:45:11 <ski> Pseudonym : sorry, that was menat to be a question
15:45:13 <esap> pseudonym: I guess if your search tree has to be balanced _before_ you create it, it's not an algebra.
15:45:33 <esap> pseudonym: in the sense that both creation and destruction can then fail.
15:45:41 <ski> Pseudonym : it's anarchic, as far as i understand
15:46:10 <esap> pseudonym: you cannot expose the constructors for such type without breaking the type.
15:46:20 <Pseudonym> esap: That's true.
15:46:33 <Pseudonym> Because the "type" is both an algebraic structure _and_ a set of constraints.
15:46:50 * ski don't think the 'failability' or not is very relevant
15:47:44 <ski> Pseudonym : i.e. in many cases a retract of an algebraic structure, i suspect
15:48:38 <ski> we can just require that one is not allowed to have missing cases in pattern-matching
15:49:42 <esap> pseudonym: hmm.. My understanding of 'algebra' is that it includes only the algebraic structure part. The set of constraints in your example is expressed via existential quantification (for the module that hides the actual constructors).
15:49:52 <Pseudonym> Yes.
15:50:37 <ski> Pseudonym : it's quite common to, either just use some canonical forms of an "internal datatype" (e.g. Rationals as pairs), or, to compute with equivalence classes of values in the "internal implementation type" ?
15:51:12 <Pseudonym> I guess my underlying point is that guaranteeing that creation can't fail or "destruction" (a term which I don't like) can't fail is useful enough on its own, but it's never the whole story.
15:51:32 <Pseudonym> ("Destruction" implies the end of something's lifetime.)
15:51:40 <ski> deconstruction ?
15:51:46 <Pseudonym> Deconstruction is good.
15:51:56 <Pseudonym> Projection isn't bad.
15:52:03 <Pseudonym> Though it implies something else.
15:52:11 <ski> selection, too, i'd imagine
15:52:24 <esap> pseudonym: right, invariants for coalgebras and the dual counterpart to that is what's important. Not 'failing' as such, but the invariant that causes the failure.
15:52:38 <Pseudonym> Speaking with my database server writer's hat on, "map" does projection, and "filter" does selection.
15:52:42 <ski> esap : hmm ?
15:52:56 <Pseudonym> Right.  OK, cool.  I get it now.
15:53:00 <Pseudonym> Thanks. :-)
15:53:07 <Pseudonym> Now back to what you were saying before I interrupted.
15:53:53 <ski> esap : "the invariant that causes the failure" ?
15:53:53 * esap can't remember what it was :-)
15:54:08 <ski> archic algebras ?
15:54:26 <ski> esap : hmm, think 'twas on failability
15:55:11 <ski> you were saying that consumers for coalgebras could fail
15:55:48 <ski> wasn't you ?
15:55:56 <esap> yes. that's true.
15:56:11 <ski> how important is that ?
15:56:24 <esap> hmm. actually no.
15:56:24 <ski> i'm not sure it's very important
15:56:43 <ski> ?
15:56:56 <esap> for coalgebras, creation can fail, not destruction. coalgebras have projection operations that do not fail.
15:57:20 <ski> how can creation fail ?
15:57:47 <ski> (i assume you are talking about *final* coalgebras here !)
15:57:57 <ski> perhaps you weren't ?
15:58:20 <esap> actually, I'm not sure I'm making distinction between final coalgebras and non-final ones.
15:58:34 <wagle> the first template example tries to import pr from Printf..  i have ghc 6.2 on my powerbook, and there's no Printf.hi.  what should i do instead?
15:59:12 <ski> isn't it such that the "operation" on coalgebras is an iso for final ones ?
16:00:50 <esap> ski: hmmm... I have to think a bit about the difference between final and non-final coalgebras. Because I'm not quite sure which way it is. It's either that only final coalgebras satisfy the invariant, or that final coalgebras _only_ satisfy the invariants specified in its interface(s).
16:01:55 <ski> i'm still not sure if you are speaking about archic or anarchic ..
16:02:04 <ski> when you say "invariants specified in its interface(s)" i think of archic
16:02:19 <ski> (which i don't know as much about)
16:02:28 * esap didn't understand what you mean by 'archic' vs. 'anarchic'.
16:03:07 <ski> group,monoid are archic (because there are laws like asscoiativity, etc)
16:03:42 <esap> ok, I think coalgebras are archic, at least.
16:03:44 <ski> anarchic just have constructors (for algebra). (dual for coalgebras)
16:04:23 <esap> and the law is that projections don't fail.
16:05:33 <ski> of course there must exist all four combinations : archic algebras (group,monoid), anarchic algebras (naturals), anarchic coalgebras (streams), archic algebras (well, i think ham[kell]'s "coalgebra" was such a one)
16:05:47 <ski> mm
16:06:19 <ski> so not all coalgebras are archic, no ?
16:08:37 <esap> the example with naturals is interesting, because I view type of naturals as a fixed point of an algebraic functor.
16:08:53 <esap> e.g. Nat = Rec Maybe
16:08:58 <ski> yes
16:09:20 <ski> least fixed point, right ?
16:09:50 <esap> And fixed point might well change the behviour of the type. I think fixed points are both algebraic and coalgebraic.
16:10:30 <ski> isn't naturals the least type satisfying the closure
16:10:37 <esap> yes.
16:10:49 <ski> so it's least fixed point
16:10:55 <esap> yes
16:11:48 <ski> and we can use greatest fixed points of functors to create (at least anarchic) coalgebras, right ?
16:12:07 <ski> \X. A*X
16:12:16 <ski> gives use A-streams
16:12:48 <esap> yes, I think that's correct.
16:13:47 <ski> i'm not sure, but perhaps one must specify, when talking about fixed points, if one wants least or greatest (or possibly some other, in between, or something)
16:14:12 <esap> true.
16:14:36 <ski> isn't finite lists + cyclic lists a fixed point of a recursive domain equation ?
16:14:56 <esap> what do you mean by '+' there?
16:15:09 <ski> and that is greater than finite lists, but not the greatest, i think
16:15:13 <ski> union
16:15:47 <ski> like lists in O'Caml (i think one can create cyclic lists by 'rec')
16:15:58 <ski> forcer : hello
16:16:05 <forcer> ski: hi there :)
16:16:26 <esap> I think yes, though I don't know that much about (general) recursive domain equations.
16:16:51 <ski> no me either :)
16:17:03 <esap> ski: I think you have to handle strictness if you consider both finite and cyclic lists.
16:17:46 <ski> what do you mean "handle strictness" "consider ..." ?
16:18:38 <esap> ski: I mean, the important difference between least and greatest fixed point is strictness.
16:18:49 <ski> forcer : you have any question ?
16:19:03 <ski> call-by-value vs call-by-name
16:19:08 <esap> ski: yes.
16:19:08 <ski> i think
16:19:18 <ski> in the *really* dual sense
16:19:22 <esap> yes.
16:20:11 <ski> i.e. not just some ordinary unsymmetric lambda-calculus that distorts the picture by it's own unsymmetricness
16:20:38 <ski> like Church-Rosser
16:21:20 <esap> hmm.. do you mean C-R is unsymmetric? [what is the dual of C-R?]
16:22:12 <ski> well, in lambda-calc : if there's a normal form, then call-by-name finds it, call-by-value doesn't nessecarily do so
16:22:42 <esap> oh ok. I thought of 'initial' vs. 'final' objects in a category.
16:22:45 <ski> or was Church-Rosser about the confluence ?
16:22:54 <esap> yes.
16:22:56 <ski> :)
16:23:36 <forcer> ski: not really, just enjoying intelligent talk as a background noise
16:23:55 * ski should remember such things. especially as i saw it briefly on lecture today (well yesterday, by now)
16:24:56 * ski wants a symmetric (self-dual) programming language !
16:25:07 * esap is designing one.
16:25:41 <ski> the problem is with the continuations. i.e. non referentially transparent
16:26:32 <ski> one could of course dispense with nonlocal conts, but to be symmetrical, one should also then dispense with nonlocal ordinary variables :(
16:27:01 <ski> the problem seems to come when one have both at the same time
16:27:08 <esap> ski: I think I've solved that problem. The dual of functions.
16:27:15 <ski> ?
16:27:23 <ski> what do you mean ?
16:27:30 <ski> coexponentials ?
16:27:34 <esap> ski: have you read "Crolard: Subtractive logic"?
16:27:38 <esap> ski: yes.
16:27:53 <ski> hmm, browsed it a bit at least, i think
16:28:33 <ski> in your system, do you have both value and continuation variables ?
16:28:59 <ski> (i.e. a kind of gentzen sequent calculus typesystem)
16:29:35 <esap> ski: Well I think the dual of variable is a constant.
16:29:41 * ski ski suspects the problem might be solved/softened by linear types
16:29:51 <ski> ?
16:30:06 <esap> ski: so I have value variables and continuation constants.
16:30:17 <esap> ski: which do similar things.
16:30:48 <ski> Gamma |- e : T , Delta   and   Gamma, c : T |- Delta   ?
16:31:08 <ski> with ordinary vars in Gamma, and the cont. sort in Delta  ?
16:31:28 <esap> yes, I think it amounts to that.
16:31:57 <ski> and do you have terms at both sides ?  or jus tone ?
16:32:50 <ski> andrewc : hi again.  more questions ? ;)
16:33:27 <andrewc> hi, no, i just remmebered a link - someone was talking about a phd application letter.
16:33:47 <ski> andrewc : think that was Marvin--
16:33:56 <esap> ski: hmm.. interesting question, I think the term at the left side is more like the structure of the context.
16:34:09 <ski> yes, of course ! :)
16:34:42 <esap> ski: so in a trivial sense, yes I do have that :-9
16:35:12 <ski> E ::= x  |  F <@ E
16:35:20 <esap> what's that?
16:35:22 <ski> C ::= y  | C @> F
16:35:40 <ski> F ::= id | F . F | \x.E | /y.C
16:35:51 <ski> from some paper
16:36:33 <ski> lemme see if i can find it
16:36:56 <esap> sounds like a subset of the thing in Wadler's duality paper.
16:38:35 <ski> Declarative Continuations and Categorical Duality (1989), Andrzej Filinski   e.g. p. 24
16:38:49 <ski> http://citeseer.nj.nec.com/filinski89declarative.html
16:39:28 <esap> Heh, Filinski's master's thesis is the thing I first read about duality.
16:39:47 <ski> :)
16:40:33 <esap> it's really the basis of what I'm doing with the language design.
16:41:46 <ski> Ichiro Ogata,  Constructive Classical Logic as CPS-calculus
16:42:06 <ski> seen it ?
16:42:33 <esap> the Crolard paper is where the handling of 'continuations' is a necessary addition to it [+ of course the Hagino thesis].
16:42:56 <ski> well, Filinski have both a syntactic class of expressions and a syntactic class of continuation-expressions
16:43:31 <ski> handling how ?
16:43:47 <esap> hold on a sec.
16:43:54 <ski> catching operators ?
16:43:56 <ski> ok
16:44:49 <esap> ski: see http://www.kotiposti.net/epulkkin/summary.dvi
16:46:24 <esap> ski: it amounts to throwing an exception and providing handler for the exception.
16:46:37 <esap> ski: but there's more to it.
16:46:52 <esap> ski: because the case construct interacts with it as well.
16:47:14 <ski> hmm
16:47:42 <ski> mu x.y ?
16:47:52 <esap> ski: the control operation.
16:48:30 <ski> hmm, you haven't any cont. syntactic class here, right ?
16:49:23 <ski> mu acts a bit like a handler ?
16:49:36 <esap> ski: well, the typing does distinguish between constants introduced via the control operation and variables introduced via lambda abstraction.
16:49:54 <ski> hmm, ok
16:50:11 <ski> (i just didn't saw any cont. terms)
16:51:02 <ski> Gamma and Delta isn't collections here, right ?
16:51:28 <ski> just a big monolithic formula ?
16:51:32 <ski> have i understood correctly ?
16:51:45 <esap> ski: think of them as objects in category theory.
16:51:49 <ski> mm
16:52:14 <esap> so they're essentially similar to types.
16:52:29 <ski> is all the /\ \/ => \\ things object-connectives, or is some of the meta ?
16:52:49 <ski> (can i think of them as type-constructors ?)
16:53:01 <esap> only |- and --------- are special.
16:53:11 <ski> ok
16:53:36 <esap> and perhaps ':' :-) I'm not yet quite sure about that.
16:53:41 <ski> is Gamma0 \\ Gamma1 wellformed ?  (just invented it)
16:54:08 <ski> or must there be like Gamma \\ var : Type  ?
16:54:14 <esap> yes, you can leave out names if not needed.
16:54:58 <ski> some of the terms look a bit strange/unusual/uncommon (to me at least)
16:55:05 <esap> which ones?
16:55:31 <esap> I think rule 5 has a typo :-)
16:55:34 <ski> well, i guess it's just that i haven't played much with those particular forms
16:55:40 <ski> well
16:55:47 <ski> x = y
16:55:54 <ski> (rule 8)
16:56:10 <esap> ok, that's the control application. Maybe my syntax for it is somewhat unusual.
16:56:12 <ski> or f(x)
16:56:37 <ski> so it seems like one can only apply when the arg is a var, right ?
16:56:39 <esap> ok, you mean my restriction that the argument to the application must be found from context?
16:57:03 <esap> I think that's essential restriction to be able to dualize correctly.
16:57:13 <ski> sortof reminds of beta-0 for some reason
16:57:36 <ski> hmm
16:57:38 <ski> why ?
16:58:59 <esap> because if you allow arbitrary expressions, then the continuation rules have to also allow that for the dual case. And I think that'll cause difficulty.
16:59:50 <ski> by reduction-ambiguity ?
16:59:52 <esap> look at rule 8 and rule 6, they're almost similar.
16:59:56 <ski> nonconfluence ?
17:00:13 <esap> similarly for rules 5 and 7
17:00:54 <esap> but if you allow rule 6 to have 'x' from upper side of the equation, then how do you rewrite rule 8?
17:01:14 <ski> oh, i thought you meant they were more or less mirror pictures of each other 
17:01:50 <esap> well there is many kinds of symmetry there.
17:02:14 <ski> well, the kind of rules that i was thinking about would be strictly mirror images (+ swap some symbols)
17:02:27 <esap> because 5,6,7 and 8 are based on the same thing.
17:02:28 <ski> esap : yes :)
17:02:50 <esap> which are axioms 5 and 6 from the first page.
17:02:56 <ski> esap : perhape it's to do with adjoints ?
17:03:05 <esap> ski: yes exactly.
17:03:35 <ski> on the first page
17:03:54 <ski> is delta (doubling) a bifunctor ?
17:04:05 <esap> Delta(A) = A,A
17:04:22 <esap> so only one argument
17:04:28 <ski> oh
17:04:31 <ski> sorry
17:04:49 <ski> i guess i mean "the other way around" .. :)
17:05:08 <esap> Delta : C -> CxC
17:05:14 <ski> is it a functor from C to CxC for any C ?
17:05:19 <ski> oh
17:05:22 <esap> yes.
17:05:24 <ski> ok
17:05:58 <ski> this reminds me one a thing is dynamical systems
17:06:33 <ski> one can multiple dynamical systems
17:06:36 <ski> multiply
17:07:16 <ski> esap : do you know what i mean by "dynamical systems" ?
17:07:26 <esap> I'm not quite sure
17:07:36 <ski> given a cat C
17:08:13 <ski> we can build a cat, whose objs are pairs of objs in C and an endo over that obj
17:08:55 <ski> and whose arrows are pairs of arrows between corresponding obj parts in C and a proof that a diagram commutes
17:09:06 <ski> i.e. if we start from set
17:10:00 <ski> we can think of the objs as sets, but with a structure like : from every point of a set there leaves an edge (which arrives at some point of the same set)
17:10:10 <ski> esap : better ?
17:11:08 <ski> (this is one of the favourite example cats in lawvere's conceptual mathematics)
17:11:32 <ski> stepcut : hi
17:11:42 <Darius> Wouldn't that essentially be Mon.
17:11:46 <esap> yes, I think I got it.
17:11:54 <ski> what ?
17:11:58 <ski> the endo ?
17:12:19 <ski> oh
17:12:57 <ski> Darius : you mean Monoid(s ?)  ?
17:13:10 <ski> Darius : not monic/mono ?
17:13:32 <Darius> I meant the category of monoids and monoid homomorphisms, but I think I misread a part.
17:14:00 <ski> Darius : yes, i realized you might have meant that
17:14:25 <ski> example is Bool + not
17:14:33 <ski> i.e. the 2-loop
17:14:47 <ski> another example is naturals + succ
17:15:00 <ski> (call that N)
17:15:51 <esap> are there initial and final objects in that category?
17:16:03 <ski> N is special, in such way that it suffices to separate arrys, by point-wise testing the input of both
17:16:09 <ski> yes :)
17:16:12 <Darius> Your description of the objects is confusing.
17:16:23 <ski> initial is the empty system
17:16:35 <mattam_> why dynamical system ?
17:16:35 <ski> i.e. empty-set + id
17:17:06 <ski> mattam_ : it "evolves" if you follow the edges
17:17:16 <ski> (though discreetely)
17:17:41 <ski> esap : terminal is the one point-set + it's identity
17:18:21 <ski> there's also sub-object classifier, omega
17:19:13 <ski> omega is like  naturals extended with aleph-zero, and predecessor (defined for 0 to be zero, in this case)
17:19:32 <ski> so omega has two fixed-points
17:19:58 <ski> a fixed-point is a map from the terminal object (the 1-loop)
17:20:09 <ski> anyway
17:20:14 * esap thinks of Hagino's thesis and its handling of naturals + aleph zero.
17:20:42 <ski> well, it's perhaps better to say, the first infinite ordinal, hmm
17:20:47 <ski> hmm
17:21:08 <Darius> ski: I think you are describing something like Barr and Well's u-structures that they used as an example, but you description of objects just doesn't make sense.
17:21:27 <ski> or perhaps the points of omega is the elements of  data CoNat = Pred :: Maybe CoNat
17:21:31 <Darius> (or rather the category of u-structures and u-structure homomorphisms)
17:22:08 <ski> Darius : well it was a little sketchy, at least
17:22:48 <ski> Darius : i can write it down in some dependent-types like system
17:23:21 * Darius wonders if the subobject classifier would return the length of the matching prefix.
17:23:38 <ski> Darius : each object of the new category consists of an object of the old one, and an endomorphism over that old object
17:23:56 <Darius> Yes, a -single- object.
17:24:17 <ski> Darius : omega tells you how many steps you have to go to come inside the sub-system
17:24:27 <ski> Darius : yes
17:24:32 <Darius> ski: Well that was my other idea.
17:25:04 * esap thinks of unfold.
17:25:13 <ski> Darius : that explains why there is a "point at infinity", it's for those that never wander into the subsystem
17:25:17 <Darius> It was either how many they coincided on or how many until they coincided.
17:25:47 <ski> Darius : therefore they don't have to be distinguished from each other
17:25:59 <Darius> ski: Anyways, yes, unless I'm utterly mistaken, those are Barr and Wells' u-structures.
17:26:03 <ski> how many until
17:26:22 <ski> "u-structures" ?
17:26:36 <ski> why 'u' ?
17:26:41 <Darius> ski: That was my first guess, but I have a bad habit of second guessing myself only to find I was right in the first place.
17:26:43 <Darius> unary.
17:27:44 <ski> well, anyway, it is easy to multiply these objects, graphically (at least if you can render them more or less on a line)
17:28:20 <ski> if you multiply N by itself you get something like
17:28:22 <ski> \\\\\
17:28:23 <ski> \\\\\
17:28:25 <ski> \\\\\
17:28:26 <ski> \\\\\
17:28:52 <ski> where all those should be imagined as pointing downwards and rightwards
17:29:12 <Darius> And what are "those"?
17:29:20 <ski> i.e. it is N + N + N + ...  (aleph-0 of them)
17:30:19 <ski> one can also have a "dynamical system" with two endomorphisms (distinguished from each other (ordered if you like))
17:31:02 <ski> Darius : that is a bad ascii repr. for the internal diagram of one object
17:31:27 <ski> in this case one node at each grid  (at natural x and y coordinates)
17:31:55 <ski> so the \ means that from (x,y) the endomap gives us (x+1,y+1)
17:32:01 <ski> better ?
17:32:06 <ski> lzfnk : hi
17:32:30 <lzfnk> ski hello
17:32:36 <Darius> The product of them in the category of models?
17:32:58 <ski> product objects within the category
17:33:23 <ski> same thing ??
17:33:33 <esap> I'm not quite sure what is the intended interpretation of the endomap.
17:33:58 <Darius> esap: There isn't any "intended" interpretation, but for N it's succ (+1).
17:34:18 <ski> for each element of the set (if we start from that cat), we get a 'next' one by following the endo
17:35:53 <esap> what happens if you use something else than N, is is still like "next one"? or is that specific to N?
17:35:58 <Darius> ski: Well I should have said models of the loop diagram.
17:36:09 <ski> it is not specific to N
17:37:48 <ski> (DynSysOf cat).Obj = {obj : cat.Obj , endo : obj cat.--> obj}
17:37:54 <ski> does that help ?
17:38:45 <esap> yes, that's what I was thinking, but I was trying to map the endo to the commuting diagrams.
17:38:56 <Darius> ski: I think the category is isomorphic to the co/algebras of the identity functor.
17:40:04 <ski> (i.e. the objects in the new "dynamical systems" category, founded upon a parametric category cat is a dependent record, where the 'obj' field has typo cat.Obj and the 'endo' field has type obj cat.--> obj, for that previous obj)
17:40:25 <esap> ski: yes, that part was clear.
17:41:06 <esap> ski: the part where each endo somehow represents commuting diagrams was not (that was what I understood you said earlier).
17:43:06 <ski> a (DynSysOf cat).--> b = {mor : a.Obj cat.--> b.Obj , law :  mor cat.o a.endo  ===  b.endo cat.o mor}
17:43:21 <ski> where cat.o is composition in cat
17:43:50 <ski> see the diagram better now ?
17:44:14 <esap> ok.
17:45:11 <ski> so if we go round on a (using it's endo), and the go to b, it's the same as going to b and then going around to b (using it's endo)
17:45:56 <esap> yes, it's clear now.
17:46:00 <Darius> (Co)Algebras and (Co)Algebra homomorphisms.
17:46:10 <ski> btw, this seem like quite an interesting way/notation of specifying categories
17:46:39 <Darius> It seems quite synactically busy.
17:47:18 <ski> the explicit proof objects for the laws ?
17:47:29 <Darius> I'd want something that would let me not have everything qualified.
17:48:04 <esap> at least it's explicit, so it's not easy to misunderstand what category is used.
17:48:06 <ski> then we must have some reconstructing algorithm, yes ?
17:48:28 <ski> esap : yes, that was my idea
17:48:54 <ski> to make it explicit so i didn't miss out things
17:49:31 <ski> i'm sure more experience people feels fine with less explicit notation
17:50:01 <esap> I was thinking you considered the endo in the sense of curry-howard isomorphism and mixed 'law' and 'endo'.
17:50:40 <ski> "endo in the sense of curry-howard isomorphism" ?
17:50:53 <esap> that is, representing a proof.
17:51:32 <ski> well the field named law contains a proof of the proposition that is it's type
17:51:55 <esap> right, I originally understood you meant endo to be that proof.
17:51:59 <ski> ok
17:52:30 <ski> we can also make a variant of this category
17:52:38 <ski> but with 2 endos
17:52:53 <ski> we could call them "mother" and "father" e.g.
17:53:11 <ski> some objects in this represents family trees
17:53:29 <Darius> I'd imagine it'd be paths in binary trees.
17:54:03 <ski> could be shared parts and cyclic parts too
17:54:32 <ski> think of every point of the form (x,y) where x and y is a natural
17:54:54 <ski> say, x axis is right, and y axis is up
17:55:31 <ski> now saw that the mother of (x,y) is (x+1,y) and the father of (x,y) is (x,y+1)
17:55:41 <ski> can you visualize that ?
17:55:56 <esap> yes
17:56:22 <esap> just an infinite 2d matrix?
17:56:35 <esap> paths in the matrix
17:56:37 <Darius> Yes, that would be paths in a binary tree, I'd think two endos would result in the equivalent of data X = Right X | Up X (to use your names).
17:56:49 <ski> now this object seems to be a "product" of N (in the earlier dynamical systems) with itself
17:57:05 <ski> of course it is not category product
17:57:17 <ski> source and target aren't in the same cat
17:58:22 <ski> but i thought that this new category might be the product of the old (dyn.sys) with itself. i.e. products in the category of categories
17:59:01 <ski> if so, this object might perhaps be considered the "pair" of N with itself
17:59:16 <ski> does this sounds crazy/worng ?
17:59:40 <Darius> I'm wondering how much they could interact, but it doesn't sound completely crazy.
18:00:27 * esap thinks of outer.
18:00:28 <Darius> It would seem that the product could only identify points, but not specify how they were arrived at.
18:00:49 <ski> in dyn.sys. the prod. of A and B has as many points as the product of the number of points in A and in B
18:02:52 <ski> here, with "pairing", we have that, for each combination of point in A and edge in B we get an edge in (A,B), and symmetrically, also for each pair of points in A and B we get a point in (A,B). and finally, for each pair of edges from A and B we get a square in (A,B)
18:04:40 <ski> (commuting square, i.e. on the endo's, i think)
18:05:05 <Darius> I'd think the product in Cat of the category of u-structures would have objects like (N,N).  This would be different then the two endo category as (1,1) could correspond to Right Left or Left Right.
18:05:13 <Darius> (Right Up or Up Right)
18:06:16 <ski> what's N and 1, there ?
18:07:53 <esap> yes, you mean you are in a sense building a certain kinds of equivalence classes of paths
18:08:33 <ski> i am ?
18:09:01 <Darius> N is the u-structure (N,succ) and succ.
18:09:27 <Darius> "and 1 is succ (i.e. 1 composition of succ).
18:10:04 <ski> "(N,succ) and succ" ?
18:10:16 <Darius> The u-structures you mentioned above.
18:10:19 <ski> why succ 2 times ?
18:10:29 <esap> the u-structure is a pair
18:10:45 <ski> not a triple
18:11:33 <ski> (N,succ) already seems enought to me
18:12:05 <Darius> Replace the end of the first sentence with the second one.
18:12:18 <ski> ok
18:12:21 <esap> oh ok.
18:12:21 <Darius> "N is the u-structure (N,succ) and 1 is succ"
18:12:45 <ski> so 1 is just an endo, then ?
18:12:54 <Darius> (1,1) is an element of the object (N,N)
18:12:56 <ski> i.e. not same type as N
18:13:02 <ski> hmm
18:16:20 * esap has to get some sleep.
18:16:36 <ski> mm
18:16:52 <ski> esap : nice dreams
18:17:00 <esap> see you later.
18:17:06 <ski> mm
18:22:26 <esap> hmm.. one thing still about that u-structure thing: for the product, doesn't the endo for one of the categories act like an identity in the other?
18:24:10 <Darius> For the product u-structure, there'd only be one endomorphism and it would roughly be <endo1,endo2>
18:25:30 <esap> consider it as a matrix, then paths to the horizonal direction have zero projection in the other dimension. Of course the endo for the whole product is different.
18:26:02 <ski> esap : the normal product, mapping to same cat ?
18:26:38 <esap> think of <endo1, id>
18:26:44 <esap> and <id, endo2>
18:27:33 <ski> (you don't mean x instead of < , > ??)
18:27:36 <Darius> Those morphisms may not exist in general.
18:27:49 <Darius> ski: Yes, I was going to change that, but what the hey)
18:28:46 <esap> ok, I guess the point was, was the product chosen so that those exist?
18:29:25 <ski> object product or category product ?
18:30:00 <esap> category I guess
18:30:42 <ski> then i guess we should have two projection functors
18:31:04 <ski> perhaps these functors can have "elements"
18:31:34 <ski> esap : were you talking about something in tht direction ?
18:32:01 <esap> yes, though I'm not sure what you mean with elements of functors
18:32:11 <ski> not me either :)
18:33:09 <ski> we could have elements of the product (which happend to be a category)
18:33:27 <ski> well, i dunno
18:35:19 <esap> ok, but now I really need to get some sleep. bbl.
18:35:27 <ski> mm, sure
20:10:27 <shapr> good morning #haskell!
20:10:43 <Pseudonym> G'day.
20:10:45 <liralen> g'morning, shapr.
20:10:50 <Pseudonym> So, who got a copy of the Win2k source? :-)
20:11:15 <forcer> 62.9%
20:11:31 <liralen> Pseudonym - Microsoft, I hope =)  and some other companies, like that one that implements Windows for Mac systems.  Why, do you need it?
20:11:46 <Pseudonym> liralen: You heard it got leaked?
20:11:53 <forcer> oh, edonkey is faster, 91.8%
20:11:57 <forcer> ;)
20:12:11 <liralen> Pseudonym - oh, no, but some random comments in other channels suddenly make more sense, now.
20:12:22 <Pseudonym> Ah, OK.
20:14:19 <liralen> mmm =)  I look forward to the public analysis.
20:14:35 <liralen> -- and particularly to people sending patches in.
20:14:44 * liralen gets lost in a happy daydream.
20:14:48 <forcer> ;)
20:14:54 <forcer> 't was funny
20:15:05 <shapr> haha
20:15:11 <forcer> i heard about the incident on IRC, and got a few urls, and started downloading
20:15:21 <forcer> then i read about it on a newspage
20:15:39 <forcer> they didn't believe it, because so far only file listings would have shown up
20:15:42 <forcer> ;)
20:15:46 <ski> shapr : mornin'
20:15:56 <forcer> funny feeling to download something you just read about that it doesn't exist
20:16:59 <forcer> shapr: hi there :)
20:17:41 <liralen> "Hi.  I've looked over the code to Win2k for a bit, and I couldn't help but notice some astonishingly horrid flaws in your FROB subsystem.  I've a fix attached, but I'll need more time to work on a proper fix.  I don't care so much for your software... but really.  Ick.  Just thank me for not GPLing this thing after you notice the performance improvements."
20:18:14 <forcer> :)
20:20:49 <shapr> forcer: hey, any updates or changes to vc-darcs.el ?
20:21:31 <forcer> shapr: i fixed one bug that caused it to be unable to add+record a file using vc-darcs.el alone
20:21:34 <forcer> else, nope
21:42:16 * shapr yawns
21:44:08 <forcer> :)
21:46:02 * shapr reads docs about MoinMoin
21:54:08 <shapr> huh, it's friday the 13th
21:54:41 <forcer> yep
21:55:13 * shapr yawns more
21:55:17 <shapr> need coffee
22:00:04 <forcer> :)
22:00:09 <forcer> shapr: any ideas for darcs.el?
22:10:06 * shapr thinks
22:12:25 <shapr> maybe darcs-apply-region
22:13:10 <forcer> hm.
22:13:11 <shapr> I'd like to be able to add multiple other sibling repos in customize and have a single keycombo to check them for pullable patches
22:13:48 <shapr> I'd like to be able to darcs add this file/buffer
22:13:59 <shapr> tag would be a nice command
22:14:02 <forcer> this buffer is difficult :)
22:14:14 <forcer> the file of this buffer works with vc-darcs.el
22:14:16 <shapr> well, I just mean the file I'm working on right now :-)
22:14:25 <shapr> ok, that's what I meant
22:15:32 <shapr> I'd like to specify some per-repo settings, for example, I'd like vc-darcs.el to run darcs check (and check for command success) before each command unless I specify otherwise.
22:16:13 <forcer> ah! :)
22:17:22 <shapr> if the repo is large, darcs check uses bunches of drivespace (as evidence by a recent darcs-users-list posting), so I'd like to be able to turn off the darcs-check-before 
22:17:49 <shapr> I'd like to be able to edit some of the _darcs/prefs/ stuff with customize
22:17:53 <shapr> same for ~/.darcs
22:18:33 <forcer> hm.
22:18:37 <forcer> ok :]
22:19:34 <shapr> it'd be nice to have a C-u darcs-push where I can specify an email to send to, for cases where I've 'anonymously' checked out the repo and would like to send some patches back to the repo author/maintainer
22:19:53 <shapr> it'd be nice to customize the 'darcs test' part of the darcs record as well
22:20:15 <shapr> these are just ideas off the top of my head, I'll think about it more.
22:21:14 * forcer noted them down.
22:21:14 <forcer> thanks :)
22:21:41 <shapr> are those the sort of suggestions you're looking for?
22:21:46 <forcer> yes
22:21:52 <shapr> ok
22:21:55 <shapr> hej jagular 
22:22:04 <forcer> i won't be implementing all of them, but it's good to have an overview of what would be useful
22:22:20 <shapr> right, just random ideas that might be useful :-)
22:22:35 <forcer> :)
22:22:51 <shapr> have you looked at all the functionality that vc-*.el offers and checked to see if the same stuff can be done with vc-darcs?
22:23:19 <forcer> vc-* has quite a few features, but they're all file-based
22:23:35 <forcer> so they're often not applicable or not useful when working with darcs
22:26:11 <shapr> hi CoolPops 
22:26:44 <CoolPops> shapr: howdy.
22:27:12 <shapr> forcer: I think the most immediatly useful thing for me would be darcs whatsnew that works on the file of this buffer
22:27:54 <CoolPops> I'm new to Functional languages in general (looking at Erlang, Ocaml and Haskell). But in a learning exercise, I am trying to build a list of random numbers and I don't understand what's wrong. Can I paste my three lines for comment?
22:28:11 <shapr> sure, three lines is fin.
22:28:14 <shapr> ack "fine"
22:28:20 <CoolPops> buildCode n = addToCode [] n
22:28:29 <CoolPops> addToCode c 0 = c
22:28:31 <CoolPops> addToCode c n = addToCode (randomRIO(0::Int,5) : c) (n-1)
22:28:57 <CoolPops> I was hoping for: let b = buildCode 4 {- b = [1,4,3,2] -}
22:29:09 <forcer> shapr: whatsnew is similar to diff, isn't it?
22:31:21 <shapr> err, I'm thinking I want a keycombo for "I've saved this file, but I don't know how it differs from what's in the repo"
22:31:29 <shapr> is that whatsnew?
22:32:06 <shapr> CoolPops: have you seen System.Random?
22:32:26 <CoolPops> shapr: no, I'll look though.
22:33:05 <shapr> I have code to generate a random list once you've given a pseudorandom number generator a seed
22:33:06 <forcer> shapr: hm :)
22:33:17 <shapr> and I have some code to generate a seed from the picoseconds of the current time
22:33:20 <forcer> shapr: you can call darcs diff on the file, and get a diff to the repo file
22:33:23 <shapr> oh
22:33:25 <shapr> spiffy
22:35:03 <CoolPops> shapr: in the Haskell 98 Report? I don't see a System.Random.
22:36:17 <CoolPops> shapr: opps. never mind, I've found it.
22:36:18 <shapr> System.Random.randoms takes a RandomGen and returns a list of anything that has Random instances
22:36:37 <shapr> Int, Char, Bool, Double, Float, Integer
22:36:59 <shapr> take 5 (randoms (mkStdGen 5) :: Double)
22:37:12 <shapr> that should work in ghci once you've done ":m + System.Random"
22:37:31 <shapr> er, once I fix the type sig :-)
22:37:38 <shapr> take 5 (randoms (mkStdGen 5) :: [Double])
22:42:10 <shapr> CoolPops: does that work for you?
22:43:29 <CoolPops> shapr: yes, I see that it works, but why it works I do not know.
22:43:52 <shapr> do you want explanation? or do you enjoy the thrill of the chase, and would prefer to ask only when stuck?
22:43:53 <CoolPops> shapr: I am going through the Yet Another Haskell Tutorial and I think I still have some to learn about reading the function signatures.
22:44:08 <CoolPops> shapr: I wouldn't mind an explanation if you don't mind.
22:44:11 <shapr> sure
22:44:44 <shapr> mkStdGen 5 gives the prng a seed to work with
22:45:25 <shapr> do you have ghci open, and with System.Random in scope?
22:45:30 <CoolPops> shapr: yes.
22:45:39 <CoolPops> mkStdGen 5 -> 6 1
22:45:45 <shapr> ok, you can check the type of mkStdGen with ":t mkStdGen"
22:46:32 <CoolPops> shapr: ok, that was an easy one to understand.
22:46:33 <shapr> do you know how pseudorandom number generators work?
22:47:01 <CoolPops> shapr: to be honest, no. I've used them but do not know how they generate random numbers.
22:47:14 <CoolPops> shapr: other than if you give them the same seed, the numbers are not random :)
22:47:45 <forcer> re
22:47:57 <shapr> well, they have a function that works like a roller coaster sort of, maybe it halves the number, swap the sign, and multiplies it by that, just something to give very different return values for a given input value
22:48:32 <shapr> it's just a function, so it will always give the same output for a given input
22:49:03 <CoolPops> shapr: ok.
22:49:14 <shapr> the usual way to work with a prng is to have it return two values, an output to be used, and another number to be the next seed to feed back into the prng function.
22:49:35 <shapr> so when you tried to print the value of "mkStdGen 5" you got to see both of those values.
22:49:56 <shapr> usually you never see the second one, it's fed back into the prng during the next call.
22:50:13 <CoolPops> shapr: ok.
22:51:35 <shapr> so you could write your own function that takes a seed, calls the prng with that, and maps the first value into a value of your chosen type, and calls itself with the second number
22:51:45 <shapr> that would give you a list of random values of your chose type
22:51:54 <shapr> that's what the function randoms does for you.
22:52:06 <CoolPops> shapr: ok.
22:52:12 <shapr> was that clear as mud? :-)
22:52:27 <CoolPops> shapr: I have a better understanding of the random number generator now.
22:52:38 <forcer> shapr: did you say anything else to be after "<shapr> spiffy"? i dropped out it seems
22:52:46 <CoolPops> shapr: but I have a question about reading function signatures.
22:53:21 <CoolPops> shapr: for instance, I want random numbers between 0 and 5, therefore I see randomRs ... but I don't understand the func signature as to what to send it.
22:53:30 <shapr> forcer: no, I didn't. Was I supposed to responde to something?
22:53:35 * shapr check his scrollback
22:53:37 <CoolPops> :t mkStdGen was easy.
22:53:53 <shapr> have you tried ":t randomR" ?
22:54:20 <CoolPops> shapr: yes, but it's function signature is very, very different.
22:54:29 <shapr> forcer: I think I'll read through the darcs manual again, hopefully that will spring more ideas.
22:54:36 <shapr> hey saz, I saw you on orkut
22:54:43 <saz> oh!
22:54:48 <forcer> shapr: :)
22:54:51 <saz> orkut is getting scary :P
22:55:01 <CoolPops> shapr: maybe I just need to spend more time in the tutorial. I thought I knew enough to make a little learning app, but I guess not.
22:55:04 <forcer> shapr: not supposed, just in case you had another idea
22:55:18 <saz> shapr: how did you come by me?
22:55:25 <shapr> CoolPops: have you reached typeclasses in the tutorial?
22:55:33 <CoolPops> shapr: no.
22:56:02 <shapr> saz: you're connected through to whole unsw crowd, and they're connected to the Haskell community, and... 
22:56:20 <saz> shapr: true
22:56:22 <saz> hehe
22:56:30 <CoolPops> shapr: I didn't think this was going to be too hard, just a random code generator [5,2,2,3]. Then have the user guess the code. Tell them how many were right, and how many exact until they get the code. a code breaking game :)
22:56:35 <shapr> CoolPops: here's my 'haskell for the impatient' http://www.scannedinavian.org/AvianWiki/HaskellDemo
22:57:19 <shapr> well, a typeclass is sort of like an interface in java, and sort of like the new interface stuff in python 
22:57:24 <CoolPops> shapr: i.e. code: 5,4,3,2 ... user guess: 1 2 3 4 ... 1 is exact (3), 1 is right (2) ...
22:57:55 <CoolPops> shapr: so by thinking about it the user can crack the code in just a few experiments.
22:57:59 <shapr> CoolPops: this should work: "randomR (1 :: Int,10) (mkStdGen 5)"
22:58:19 <shapr> oh, I see you want a mastermind game
22:58:33 * shapr thinks
22:58:46 <shapr> saz: nice eye on orkut ;-)
22:58:59 <CoolPops> shapr: it was just a little game I made for WinCE in C, and I thought it would be a good exercise to help me learn functional programming.
22:59:11 <shapr> yah, I agree, good idea, not too hard, not too simple.
22:59:23 <saz> shapr: well, eyes are meant to be good for identifying people.. so I figured...
22:59:29 <harsha123> hey shapr !
22:59:35 <shapr> hiya harsha123!
22:59:52 <shapr> CoolPops: randomR wants two numbers in a tuple, the top and the bottom number (I forget if they're inclusive)
23:00:02 <shapr> and it wants a prng
23:00:21 <shapr> in return it gives the same old tuple of (result,prng) 
23:00:36 <forcer> haskell has \ as lambda?
23:00:46 <shapr> forcer: yup, (\x -> x + 1)
23:00:46 <liralen> forcer - yes.
23:00:55 * forcer really should look more into haskell.
23:01:03 <shapr> forcer: yes yes!
23:01:03 <liralen> lambdabot: @eval (\x -> x + 1) 2
23:01:04 <lambdabot> 3
23:01:07 <shapr> come to the dark side!
23:01:17 <shapr> er, I mean.. purity! we're the light side!
23:01:30 <CoolPops> take 4 (randomRs (0::Int, 5) (mkStdGen 5))
23:02:07 <shapr> CoolPops: does that work?
23:02:14 <CoolPops> shapr: yes.
23:02:19 <shapr> excellent :-)
23:02:26 <CoolPops> shapr: thank you for your time and help.
23:02:54 <shapr> sure, I'm always willing to answer questions when I'm not busy.
23:02:56 <liralen> forcer - I don't know how much of this you will understand without knowing at least some Haskell, but you may find it helpful: http://www.willamette.edu/~fruehr/haskell/evolution.html
23:04:16 <shapr> CoolPops: hey, your wiki is giving me 403
23:05:58 <CoolPops> shapr: yes. A hacker succuessfully cracked into my web server. It's on the bench in the middle of an os reinstall and also much, much tighter security lockdown.
23:06:08 <CoolPops> shapr: btw, how did you know?
23:06:25 * liralen blames shapr!
23:06:39 <shapr> CoolPops: I just did a /whois CoolPops and looked in google.
23:06:41 <forcer> liralen: thanks :)
23:07:08 <shapr> gee, I wonder if my wiki is secure.
23:07:40 <forcer> hehe
23:08:01 <CoolPops> shapr: it wasn't the wiki they hacked into. It appears to be an apache exploint, they then did a wget in the /tmp dir for some cool crack utils and soon were using the root account for the fun of it.
23:08:03 <forcer> i just looked at that, "heh, haskell has x+y pattern matching? wow!" when i saw this remark about the disgusting part :)
23:08:21 <liralen> forcer - IMHO, that page does a very good job of underlining Haskell's expressivity =)
23:09:39 <forcer> liralen: foldl (*) 1 [1..n]  -- the parens around the * are necessary to prevent haskell from parsing this as "foldl times 1"?
23:10:35 <CoolPops> shapr: hum. there's quite a bit of stuff in there on google.com for my name. I think I need to change it.
23:10:59 <liralen> forcer - I guess that you could say that the parentheses limit *'s scope so that it, in this example, finds no arguments and so curries to itself (a function accepting two arguments).
23:11:16 <liralen> forcer - consider: map (*5) [1..n]
23:11:36 <forcer> liralen: yes, i know about the "auto-currying". thanks for the clarification of my statement :)
23:16:48 <forcer> id being the identity function?
23:16:54 <liralen> yes.
23:17:04 <liralen> @type id
23:17:05 <lambdabot> id :: a -> a
23:17:11 <liralen> @eval id 5
23:17:12 <lambdabot> 5
23:18:11 <forcer> :)
23:18:52 <forcer> fac n = foldr (\x g n -> g (x*n)) id [1..n] 1 -- so i guess that the usage of id here does the trick of "simulating foldl" using foldr, right?
23:19:45 <forcer> @eval [1..5] !! 3
23:19:45 <lambdabot> (line 1, column 4):
23:19:45 <lambdabot> unexpected "."
23:19:45 <lambdabot> expecting simple term
23:20:00 <forcer> damn :)
23:20:18 <shapr> @eval enumFromTo 1 5
23:20:18 <lambdabot> [1, 2, 3, 4, 5]
23:20:34 <forcer> hm.
23:21:18 <liralen> forcer - lambdabot does not evaluate perfectly.  [1..5]!!3 -- does what you'd expect in, say, GHCi
23:22:18 <shapr> does lambdabot's lambda interpreter do !! ?
23:22:28 <forcer> liralen: thanks :)
23:22:41 <forcer> liralen: where do you know from what I expect? :)
23:24:03 <liralen> @eval (enumFromTo 1 5)!!3
23:24:03 <lambdabot> (line 1, column 17):
23:24:03 <lambdabot> unexpected "!"
23:24:03 <lambdabot> expecting operator, simple term or end of input
23:24:14 <liralen> @eval (!!) (enumFromTo 1 5) 3
23:24:15 <lambdabot> (line 1, column 2):
23:24:15 <lambdabot> unexpected "!"
23:24:15 <lambdabot> expecting simple term
23:24:16 <shapr> @get-definition index
23:24:16 <lambdabot> index not defined
23:25:46 <shapr> @defitions i
23:25:46 <lambdabot> Sorry, I don't know the command "defitions", try "lambdabot: @listcommands"
23:25:52 <shapr> @definitions i
23:25:53 <lambdabot> ["id","identifier","init","internalListCase","interpretTerm","intersperse","isDigit","isIdentifierLetter","isPrime","isSpace","isUpper","isVar","iterate"]
23:26:03 * shapr shrugs
23:26:08 <shapr> anyways, time for me to work
23:30:05 <det> While editing a file with tramp over ssh I loaded shell and noticed the current path was "/ssh:chris@detriment.org:/home/chris", but typing any command causes emacs to hang until I ctrl-g. Can eshell work with tramp?
23:30:19 <det> eh, ignore
23:31:56 <CoolPops> det: does that really work? ssh in emacs?
23:32:21 <det> CoolPops: using tramp, yes you can edit over ssh
23:32:28 <det> but it doesnt come with emacs
23:32:40 <CoolPops> det: hum... I'll look into that. That is of intrest to me :)
23:33:11 <det> its neat, just open /ssh:user@host:/path/to/file :)
23:33:20 <det> and it will open it over ssh
23:33:28 <det> it has several backends
23:33:55 <CoolPops> det: what os are you using?
23:34:00 <det> linux
23:34:13 <shapr> det: no, eshell and tramp don't mix like that.
23:34:31 <det> shapr: hrmm, it seems to be working now :)
23:34:38 <det> shapr: just ls takes a long time
23:34:41 <shapr> ??
23:34:45 <det> shapr: is eshell doing it on it's own ?
23:34:48 <CoolPops> det: their is a mount tool that allows you to mount remote SSH, FTP, Webdav just as though they were local as well.
23:35:02 <det> CoolPops: I prefer this
23:35:05 <shapr> heck if I know, I've never gotten it to work, even though I've written my own eshell extensions.
23:35:16 <shapr> you can really ls the remote dir??
23:35:37 <det> shapr: yeah, it takes a long time for ls, but other commands are fast
23:35:57 <det> I suspect because it is using it's builting ls + some slow gathering filelist on remote host thing
23:36:25 <shapr> bizarre, I must try that.
23:36:31 <shapr> you using gnumacs or xemacs?
23:36:35 <det> gnuemacs
23:36:47 <CoolPops> det: have you used lufs before?
23:37:40 <det> shapr, in eshell try: cd /ssh:user@host:
23:37:41 <CoolPops> det: I've used it once but the primary thing I do on remote systems is edit files, so... I'm always looking for good ways.
23:37:48 <det> CoolPops: I dont know what it is
23:38:06 <shapr> det: that gives me an ftp connection
23:38:12 <shapr> linux user file system
23:38:22 <det> shapr: do you have tramp installed ?
23:38:23 <shapr> tramp has the advantage that you can multi-hop
23:38:29 <shapr> yes, with xemacs
23:38:53 <det> oh, I suspect it will try to use ange-ftp to a host names "ssh" without tramp installed
23:38:58 <shapr> yup
23:39:39 <CoolPops> det: ok. lufs allows you to: mount -t sshfs me@remotehost.com:/home ~/my_remote_dir ... Now you can cd, ls, rm, mkdir, even run shell scripts, executables, etc... as though they were local, but all over ssh.
23:40:07 <shapr> can you mount something that's only ssh'able from remotehost.com ?
23:40:36 <CoolPops> shapr: if you can access it with ssh, you can mount it.
23:40:54 <shapr> can ssh do multi-hop?
23:41:09 <CoolPops> shapr: it will also mount other protocols such as ftp and webdav.
23:41:28 <CoolPops> shapr: I don't know what you mean.
23:43:03 <det> CoolPops: what if he can only access somehost.com from remotehost.com and he is on myhost.com when he wants to mount somehost.com
23:43:32 <det> CoolPops: tramp allows you do do multihop myhost -> remotehost -> somehost
23:44:03 <CoolPops> det: ah. I see. I have done that before (getting into internal networks from external) but I have had full control on the firewall box and simply setup an iptables...
23:44:13 <CoolPops> det: how does it do that?
23:44:46 <det> by sshing to remotehost and sshing to somehost
23:44:46 <CoolPops> det: ah, nevermind, I can see how. the remotehost.com must have a user account for you, obviously, correct?
23:45:11 <det> yes
23:45:51 <CoolPops> det: ok. I do not know if lufs will do it. From the options that I have used and seen, I would guess no.
23:51:47 <CoolPops> why would you write: square = \x -> x*x instead of square x = x*x ?
23:52:37 <liralen> well, you wouldn't really want to write either.
23:53:28 <liralen> square = (*) k where f x = f x x
23:53:55 <liralen> square = k (*) where k f x = f x x
23:53:58 <liralen> sorry, terminal problems.
23:54:45 <shapr> CoolPops: if you're talking about the "add2 = \x -> x + 2" part of the HaskellDemo, there's no real reason.
23:55:24 <CoolPops> liralen: shapr: I'm in the Yet Another .t.. tutorial.
23:55:41 <CoolPops> liralen: your 2nd square does not compile.
23:55:52 <CoolPops> oops. hold on.
23:56:13 <CoolPops> liralen: sorry. my typo that I over looked 5 times.
23:56:48 <CoolPops> liralen: I won't even ask how or why that works.
23:57:14 <liralen> cool - hm?  What part don't you understand?
23:58:10 <CoolPops> liralen: um, the part I do understand is that you are assining something to square ... the rest of it is amazing to me.
23:58:38 <liralen> cool - do you understand the 'where' syntax used?
23:58:42 <CoolPops> liralen: ah, wait. I remember the (*) now. that's where the * comes in. ok.
23:59:19 <CoolPops> liralen: no, I don't understand the where part in that syntax.
23:59:32 <det> do you understand let ?
23:59:39 <CoolPops> det: yes.
23:59:47 <det> where is the opposite :)
