00:00:31 <liralen> anyway, English has many rules.  An wealth of them.
00:00:34 <Maddas> liralen: I don't understand :-)
00:00:51 <liralen> For instance, I clearly commited an error with 'an wealth'.
00:01:08 <Pseudonym> Actually, I just started reading Bill Bryson's book on troublesome parts of English.
00:01:16 <Pseudonym> Did you know that NATO is an acronym but IBM isn't?
00:01:19 <Maddas> Yes, sure, but consider the question whether something is a proper word or not.
00:01:24 <Maddas> Why is IBM not an acronym?
00:01:30 <liralen> Pseudonym - yes, because the later forms an initialism.
00:01:34 <Pseudonym> Because it's not pronounced as a word.
00:01:37 <Yosomono> As much as I hate to admit it, languages are alive, and dictionaries/grammars are descriptive not prescriptive.
00:01:41 <Maddas> Pseudonym: I believe that that is wrong.
00:01:52 <Pseudonym> Yosomono: Ah, someone studied linguistics. :-)
00:02:03 <liralen> Maddas - no, a distinction between 'acronym' and 'initialism' exists, however rarely people concern themselves with it.
00:02:04 <Yosomono> Pseudonym: Yes, sometimes to my own detriment.
00:02:06 <Yosomono> :(
00:02:24 <shapr> Yosomono: you speak one of them funny language on a daily basis, don't you?
00:02:32 <Yosomono> shapr: I try not to.
00:02:35 <Pseudonym> Maddas: As noted previously, definitions are prescribed by usage, not the other way around.
00:02:44 <Pseudonym> So it's quite possible that IBM _is_ now an acronym.
00:02:53 <Maddas> Heh
00:03:09 <Maddas> I never really felt very comfortable with that kind of 'regulation' :)
00:03:17 <liralen> Pseudonym - only by the way that people tend not to care about 'initalisms' as seperate from 'acronyms'.
00:03:19 <Yosomono> shapr: Thankfully I have a peculiar psychological problem which prevents me from ever being any good at languages in general.
00:03:45 <shapr> liiwi: I played the savage demo yesterday, but the demo desynchs pretty badly. Is the full version better?
00:03:57 <Maddas> liralen: I thought to have read something about that, but I can't find the reference anymore.
00:04:08 <liralen> yoso - no worries!  You can always say "Please forgive my English" and everyone will always immediately deal with you in a more polite manner.
00:04:24 <Pseudonym> Well, it's also an "abbreviation".
00:04:44 <Yosomono> liralen: Most people are quite forgiving, since I allow them a rarely received opportunity.
00:05:02 <Yosomono> liralen: They can get the benefit of free English demonstration without the pesky need to speak it.
00:05:13 <Yosomono> i.e. They speak their language, I speak a limited subset of mine.
00:05:22 <Maddas> Pseudonym: IBM is? I don't understand that
00:05:48 <liralen> Pseudonym - I think that fairly obvious differences exist between acronyms, initialisms, and abbreviations.
00:06:12 <liralen> And then you have whatever they call 'FORTRAN', if they've a specific name for it.
00:06:23 * liralen seems to recall that one exists.
00:06:30 <liralen> and also i18n.
00:06:43 <shapr> which I've started pronouncing "in"
00:07:18 <Pseudonym> What about l10n?
00:07:19 <Yosomono> and I've started pronouncing "lame"
00:07:28 <Pseudonym> Do you pronounce that "natural logarithm"?
00:07:51 <shapr> Pseudonym: 'lion"
00:07:51 <Maddas> I pronounce it as logarithmus naturalis
00:08:05 <Pseudonym> FORTRAN, I believe, is technically a portmanteau abbreviation.
00:08:06 <Maddas> oh, in, not ln
00:08:16 <liralen> Pseudonym - oh, thanks.  That seems familiar.
00:08:24 <shapr> pm?
00:08:27 <Yosomono> Yep.
00:08:40 <Maddas> Pseudonym: See, this is the problem when teh definition is prescribed by usage.
00:08:45 <Maddas> the, even.
00:09:01 <Yosomono> Maddas: It's gotten so that I sometimes pronounce "teh" when speaking.
00:09:03 <shapr> nearly everything in spoken languages is prescribed by usage
00:09:04 <Yosomono> I use it so often.
00:09:08 <Maddas> Yosomono: haha
00:09:35 <Maddas> shapr: I believe French has an official body that determines what is proper and what not.
00:09:35 <Pseudonym> Language is, when you get down to it, a social contract that we will understand each other.
00:09:39 <Pseudonym> Everything else is detail.
00:09:44 <shapr> Maddas: german does also
00:09:49 <Maddas> I know
00:09:50 <Pseudonym> And Japanese.
00:09:53 <Yosomono> Maddas: Which is why French people hate talking to Canadians ;)
00:09:58 <Maddas> And I find that very convenient.
00:10:05 <liralen> "So teh problem is -- oh?  'the', sorry.  Yes, I IRC more than I speak.  Anyway, those ppl over there ..."
00:10:08 <shapr> http://www.forcix.cx/computer/programs/vc-darcs.html - darcs plugin for vc-minor-mode
00:10:36 <Pseudonym> I wonder how long it would take to get ISO English standardised.
00:10:41 <Yosomono> Pseudonym: The Japanese regulatory body is fighting a terribly losing battle.
00:10:49 <Maddas> I doubt that would work.
00:10:58 <Pseudonym> Yes.
00:11:02 <liralen> Yoso - IIRC, the French amusingly dislike Canadian words for Canadian-specific flora and fauna.
00:11:09 <Pseudonym> Japan is very pop-culture-sensitive.
00:11:14 <shapr> I think an engish ISO standard would work about as well as the various HTML standards have worked.
00:11:23 <Maddas> haha, exactly, shapr 
00:11:42 <Pseudonym> Or Haskell 98?
00:11:42 * Pseudonym ducks
00:11:47 <shapr> that too
00:11:48 <Maddas> Except that you'd have multiple dialects, too
00:11:55 <Yosomono> liralen: Canadians have created a mishmash of English and French.
00:12:13 <liralen> Yosomono - wait a sec, I need to ask the ouebe about that.
00:12:44 <Yosomono> Frenchies don't like loanwords, whereas they are all over the place in Quebec french
00:12:44 <liralen> ("I have a dog named Fido.  P-H-I-D-E-U-X.")
00:12:57 * shapr laughs
00:12:57 <Maddas> haha
00:13:20 <shapr> or tibado - thibadeaux
00:13:26 <Yosomono> Pseudonym: Calling Japan "pop-culture-sensitive" is like saying Venus is a little warm this time of year......
00:14:00 * Maddas looks up the temperature on Venus
00:15:37 <liralen> (I understand that Japan has only just started to recover from their brush with the Tang Dynasty's fashions in China.)
00:15:38 <Maddas> Hm, no agreeing opinions it seems
00:16:39 <liralen> Maddas - I can safely tell you that Venus lies nearer the Sun than us and has a much thicker atmosphere than ours.
00:17:27 <Maddas> liralen: It can't be that hard to find out the surface temperature :-)
00:17:47 <Yosomono> um, google is your friend
00:17:55 <Maddas> Yes, I find conflicting entries
00:18:09 <Yosomono> A little over 700k
00:18:10 <Yosomono> er K
00:18:34 <Yosomono> Maddas: Surprise, you'll find conflicting temperature recordings at different points on the Earth too. :)
00:19:04 <Maddas> Yosomono: Hm, yes, but this seems a rather high standard deviation :-)
00:19:27 <Maddas> hm, not important anyawy. /me goes back to his cave
00:19:41 <shapr> hey skew
00:19:46 <skew> hi shapr
00:20:00 <shapr> I have a mental flag that says I should talk to you about something, any idea what that was?
00:20:12 <skew> string libraries?
00:20:18 <skew> a lexer generator?
00:20:27 <skew> making java suck less?
00:20:33 <shapr> ouch
00:20:45 <shapr> jython is the only solution for the third one
00:21:12 <skew> I've been writing a little servlet thing in java for class, after doing something similar in twisted.
00:21:38 <shapr> I've been thinking about twisted in Haskell
00:21:52 <skew> twisted would like continuations
00:22:09 <shapr> I was thinking of an arrow based framework
00:22:26 <shapr> so you could have udpA tcpA sslA
00:22:50 <shapr> so that building servers would just be concatenation of arrows
00:23:43 <shapr> of course, that might be harder than it sounds :-)
00:25:41 <Pseudonym> "main" looks really, really elegant!  Shame about the rest of the program...
00:26:45 <shapr> Pseudonym: what do you think about a generic server framework?
00:26:53 <shapr> any ideas for structuring it?
00:27:47 <Pseudonym> Ideally, I'd want something like lambdabot.  You have a Chan of requests, server threads pull them off and deal with them.
00:27:54 <Pseudonym> Trouble is, what's a "request"?
00:28:15 <Maddas> ecraven: there?
00:28:32 <Pseudonym> For some kinds of server, that makes sense.  For others, it might not.
00:28:34 <shapr> request is a combination of protocol and port, right?
00:28:48 <Pseudonym> No, "request" is an abstract concept.
00:28:57 <Pseudonym> Consider an ftp server, for example.
00:29:01 <Pseudonym> A "request" would be a command.
00:29:23 <Pseudonym> I suppose you could do it at the "connection" level.
00:29:34 <Pseudonym> It'd be easier to maintain state.
00:29:35 <shapr> so, a connection has requests?
00:29:55 <Pseudonym> Yes, something like that.
00:30:34 <Pseudonym> Hmmm.
00:30:57 <Pseudonym> Pushing connections down a Chan would be a start, I think.
00:31:16 <Pseudonym> At least for TCP servers.
00:31:32 <shapr> yah, SCTP could have multiple connections in the initial connection
00:31:45 <shapr> I wonder if multicast would have any weird effects
00:31:56 <Pseudonym> I have no idea how to program multicast.
00:32:35 <shapr> from what I've read, it looks like you subscribe to an address, then when someone sends to that address, everyone gets it.
00:32:44 <shapr> or "all subscribers"
00:32:45 <shapr> hej ski 
00:32:46 <shapr> god morgon
00:33:00 <ski> god morgon, shapr
00:33:47 <Pseudonym> Must away.  Nytol!
00:33:53 <shapr> cya
00:34:01 <andersca> coffee woudl be nice
00:36:37 <shapr> huh, Guido van Rossum has something to do with the MUSIC-SERVICE IPv6 multicast address.
00:38:32 <skew> how is that?
00:39:45 <shapr> skew: http://www.iana.org/assignments/ipv6-multicast-addresses
02:18:18 <shapr> @yow
02:18:19 <lambdabot> ..  I feel..  JUGULAR..
02:19:19 <shapr> wow, they're using a fire axe to get snow off the roof of the building across the street.
02:19:53 <shapr> what does räddningstjänsten mean?
02:20:04 <andersca> the rescue service
02:20:08 <shapr> oh, neat
02:20:09 <andersca> fire fighters for example
02:20:16 <shapr> that might explain the fire axe
02:20:23 <andersca> my father is chief of the rÃ¤ddningstjÃ¤nsten in torsby
02:20:36 <shapr> wow, cool
02:39:27 <shapr> hi Arnia 
02:39:53 <shapr> hey Arnia, I've been thinking about the generic server idea more lately
02:40:44 <Arnia> oh?
03:43:54 <Lemmih> Is there a way to listen to multiple Handles? (like select)
03:44:23 <shapr> I think there's a select binding somewhere
03:51:09 <Maddas> Riastradh: Still working on the ircd?
03:51:55 <liiwi> shapr: desynchs?
04:33:44 <shapr> liiwi: for example, when I would go up a level and get armor, sometimes the guy next to me would get the glittery explosion but I would get the armor
04:34:20 <shapr> oh, I like HsUnix - http://www.volker-wysk.de/hsunix/
04:38:48 <earthy> I find it to be lacking
04:38:58 <shapr> what does it need?
04:39:02 <earthy> >&
04:39:07 <earthy> in all it's variants
04:39:15 <shapr> could you add that?
04:39:17 <earthy> so that the plumbing is not only stdout and stderr
04:39:33 <earthy> shapr: probably, but I have to look into it a bit  deeper
04:40:23 <earthy> (having had considerable experience writing shell scripts one learns such things :))
04:41:02 <shapr> I have very little experience with shell scripting, I've always used Python instead.
04:41:10 <shapr> and recently, Haskell
04:42:44 <earthy> well, I've written a minimal streaming MIME-decoder in posix shell
04:43:01 <earthy> as the shell was the only programming language we had
04:43:08 <shapr> that sounds pretty scary
04:43:23 <earthy> yes. you learn that posix shell != posix shell
04:43:26 <shapr> I wrote a spell checking in one line of shell script, but that's not that impressive.
04:43:58 <shapr> basically just tr " " "\n" | sort | uniq | comm -1 -3 /usr/share/dict/words
04:44:03 <shapr> something to that effect
04:44:20 <earthy> but nowadays I don't shy away from doing shite like mknods and plumbing through multiple different paths
04:45:17 <earthy> but, lunchtime
04:53:25 <ecraven> Maddas: yea
04:54:15 <liiwi> shapr: haven't seen those. Is the demo upgraded to 2.x yet?
04:54:28 <shapr> I don't know, I'll check that out.
04:55:21 <liiwi> shapr: want to try playing tonight?
04:58:01 <shapr> sure
04:58:07 <shapr> the demo doesn't say what version it is
04:59:20 <liiwi> in about 4 hours from now?
04:59:44 <shapr> oh wait, I have lots of swedish homework tonite, I don't think I'll have time.
04:59:59 <liiwi> ok, some other day this week?
05:00:10 <shapr> sure
05:00:20 <liiwi> how does tomorrow look for you?
05:01:28 <shapr> it sounds good at the moment, I won't know till I get there.
05:01:50 <liiwi> ok, I'll bug you tomorrow :)
06:24:39 <unmanarc> hello, there are some method to transform Char to Int?
06:25:00 <skew> how do you want that done?
06:25:24 <unmanarc> as ascii, by example... 
06:25:33 <skew> fromEnum is what you are looking for then
06:25:40 <unmanarc> thanks
06:25:48 <earthy> doesn't fromEnum interpret stuff as Unicode?
06:26:38 <skew> ascii is a subset of Unicode
06:26:48 <unmanarc> i don't know, but i only need for simple characters
06:26:53 <earthy> ah, 'kay
06:26:58 <unmanarc> a,b,c :P
08:06:48 <cybermanco> @get-definition ceiling
08:06:48 <lambdabot> ceiling not defined
08:06:59 <earthy> @get-definition ceil
08:06:59 <lambdabot> ceil not defined
08:07:06 <earthy> @get-definition head
08:07:06 <lambdabot> head not defined
08:07:19 <earthy> @get-definition hd
08:07:20 <lambdabot> hd not defined
08:07:23 <cybermanco> @get-definition ceilling
08:07:23 <lambdabot> ceilling not defined
08:07:29 <earthy> weird. :)
08:07:42 <earthy> @type hd
08:09:05 <andersca_> hello
08:09:23 <andersca_> what's the name of the function that lets you apply a function on a monadic result directly?
08:09:37 <andersca_> so you can do foo <- something bar
08:09:57 <andersca_> instead of foo' <- bar; let foo = something foo'
08:12:21 <Lunar^> andersca_: liftM
08:12:47 <andersca_> aah, yeah
08:12:49 <andersca_> thanks a lot
08:34:27 <Darius> earthy, cybermanco: @get-definition is related to @eval which is not a Haskell evaluator.
08:34:49 <Maddas> hello, ecraven 
08:35:31 <Igloo> Is marvin a vim person or an emacs person?
08:36:35 <Darius> I -think- vim, but only from a vague feeling.
08:38:43 <ecraven> Maddas: hey :)
08:38:53 <ecraven> Maddas: i'll leave in some minutes :(
08:39:01 <Maddas> oh
08:39:06 <Maddas> did you order a keyboard?
08:39:07 <ecraven> Maddas: i'll probably get one of those keyboards around the end of february
08:39:12 <Maddas> haha, ok
08:57:50 <shapr> jiihaa
08:59:28 <andersca> hej shapr
08:59:45 <shapr> hej andersca 
09:00:16 * Igloo hands shapr http://urchin.earth.li/~ian/utf8.txt as part of his newly-active UTF8-the-world campaign  :-)
09:00:52 * shapr switches to utf-8
09:01:14 <Igloo> Hurrah!
09:02:12 <andersca> âº whee
09:02:50 * Igloo wonders how you make that character
09:02:58 <shapr> which character?
09:03:05 <Igloo> The smiley face one
09:03:29 <andersca> I just run gucharmap and copy from there
09:03:36 <shapr> I'd like to try utf-16 or utf-32
09:03:37 <Igloo> Ah
09:03:51 <andersca> shapr: sounds like a waste :)
09:04:10 <shapr> I don't actually know the difference.
09:04:56 <Igloo> UTF 32 gives you uniform length at the expense of lots of wastage then using mostly ASCII
09:05:08 <shapr> what about utf 16?
09:05:11 <Igloo> It might have a shorter maximum length than UTF8, I'm not sure
09:05:26 <Igloo> 16 is just a stupid idea AFAIAA
09:05:34 <Lunar^> ?
09:05:50 <Igloo> "?"?
09:06:03 <shapr> what's the AA part of AFAIAA?
09:06:29 <shapr> am aware?
09:07:04 <Igloo> Yup
09:07:12 <Igloo> andersca: Where abouts it the smiley?
09:07:57 <andersca> Igloo: I searched for smiley
09:08:07 <andersca> 263A
09:08:20 * Igloo fails to work out what font uxterm is using
09:13:42 <cybermanco> hello
09:13:46 <cybermanco> if I use div
09:13:53 <cybermanco> and I div by zero I get an error
09:13:57 <shapr> I use span
09:14:04 <shapr> oh, this isn't #html
09:14:12 <Lunar^> shapr: --->[]
09:14:12 <cybermanco> there is any func like this but that gives 1 when div by 0?
09:14:28 <Lunar^> cybermanco: Why would you want THAT ?
09:14:41 <cybermanco> to don't get an error..
09:15:15 <cybermanco> looks like I must do my own div
09:15:17 <Igloo> div1 x 0 = 1; div1 x y = div x y
09:15:23 <shapr> Lunar^: is that an obscure insult in Haskell? something like, "you're just an empty list." ? :-)
09:15:43 <Lunar^> shapr: That means "out" in french IRC channels ;)
09:15:52 <Lunar^> shapr: "Tu sors" exactly
09:16:04 <shapr> what's sors?
09:16:20 <Lunar^> shapr: http://62.212.109.174/pika/tu_sors.php?texte=shapr
09:16:39 <Lunar^> shapr: sortir means going out
09:17:01 <shapr> haha! that's a great url!
09:23:41 <bring> I don't understand this error message from hugs:
09:23:48 <bring> hugs -98 +o test.hs
09:23:52 <bring> class FromStr a where
09:23:54 <bring>  fromStr :: String -> a
09:23:58 <bring> typeError :: FromStr a => a -> a
09:24:01 <bring> typeError t = error "type error"
09:24:04 <bring> instance FromStr [a] where
09:24:07 <bring> fromStr _ = typeError undefined
09:24:10 <bring> instance FromStr [(String,a)] where
09:24:13 <bring>  fromStr _ = typeError undefined
09:24:18 <bring> gives me:
09:24:29 <bring> ERROR "test.hs":8 - Cannot justify constraints in instance member binding
09:24:36 <bring> *** Expression    : fromStr
09:24:41 <bring> *** Type          : FromStr [a] => String -> [a]
09:24:44 <bring> *** Given context : FromStr [a]
09:24:47 <bring> *** Constraints   : FromStr [a]
09:25:13 <bring> it seems to be saying that I need FromStr [a] and that I only have FromStr [a]
09:25:33 <bring> ghc doesn't complain
09:27:26 <shapr> Igloo: when do we hit ghc with your new campaign?
09:28:11 <Igloo> Operative Marlow is on the case, I understand
09:33:31 <malik> hm is fromInt a prelude function?
09:36:22 <Darius> malik: I don't think fromInt is a standard function at all.
09:36:41 <shapr> it was, but long aago
09:36:54 <shapr> fromIntegral is the new replacement
09:37:25 <malik> shapr: ah... thank you
09:37:47 <shapr> is your nick related to Malaclypse the Younger?
09:38:14 <malik> well yes
09:38:24 <malik> shapr: and is there no replacement for toInt?
09:38:37 <shapr> fromIntegral
09:40:05 <malik> hm i dont understand why but it works... code from somebody else... thanks
09:40:37 <shapr> are you the original Mad Malik?
09:43:16 <shapr> anyways, I'm happy that my last name is Erisson.
09:43:28 <shapr> Hail Eris!
09:43:43 <ski> bringer of disorder
09:43:48 <malik> sorry, i'm quite busy at the moment
09:43:54 <malik> yes i am _the_ malik :)
09:43:57 <malik> hail eris!
09:44:06 <shapr> All Hail Discordia!
09:44:13 <shapr> Block Disorganizer?
09:44:21 <shapr> writer for the GREATER POOP?
09:44:44 <shapr> how the heck did you fit into the post office box?
09:45:03 <ski> entropy personified
09:47:44 <shapr> I've been trying to join the Paratheoanametamystikhood of Eris Esoteric for years.
09:47:55 <shapr> but at some point, I realized I had already joined.
10:02:54 <shapr> Igloo: hey, is your zsh prompt online? ;-)
10:03:04 <shapr> I just want the pretty PS1 value...
10:03:19 * shapr is collecting flashy zsh prompts
10:04:51 <Igloo> urchin.earth.li/~ian/prompt
10:05:04 <shapr> w00
10:05:09 <Igloo> I really should fix the SSH trail
10:11:48 <shapr> that is seriously spiffy
10:12:01 <shapr> I don't understand everything it does yet, but it sure is cool.
10:13:32 <Igloo> What don't you understand?
10:13:41 <shapr> what's the XXXX for?
10:13:50 <Igloo> Unimplemented functionality
11:07:55 <ski> JGs]lE5G
11:08:03 <ski> sorry :)
11:08:26 <shapr> NsjuTb!
11:08:31 <Maddas> Sorry? You mean I don't have to try to decipher that? :)
11:10:00 <ski> done !
11:11:06 <shapr> hi Jad
11:11:17 <Jad> hello shapr :)
11:11:22 <shapr> what's up?
11:11:36 <Jad> nothing special
11:11:40 <ski> (in case anyone wondered, yes that was a passwd and, *yes* it is changed by now ;)
11:12:05 <Jad> shapr do you know wer to download the SOEGraphics lib for linux ?
11:12:13 <andersca> ski: lab account one? :)
11:12:23 <shapr> Jad: yes, let me find the url
11:12:38 <ski> andersca : mm. haven't used that one very much yet, though
11:13:35 * ski blames WindowMaker for focusing any window at all, when the pointer is in the root area ..
11:15:34 <shapr> Jad: this looks like the right place - http://www.haskell.org/soe/graphics.htm
11:16:02 <Marvin--> heh, lac found the hudak94haskell paper
11:16:47 <Jad> shapr it says soegraphics comes with hugs
11:16:49 <Jad> however it doesn`t
11:17:12 <shapr> Marvin--: eh? lac is looking at Haskell? when did that happen?
11:17:13 <Jad> shapr lambdabot isn`t on freshmeat
11:17:20 <shapr> Jad: no, it isn't
11:17:27 <shapr> I really should do that.
11:17:35 <Jad> can you gimme a link to it again please
11:17:43 <shapr> yes
11:17:48 <shapr> new 'release' today
11:17:52 <Jad> :)
11:17:52 <liralen> oh, wow, people actually look for software on freshmeat?
11:18:15 <Jad> liralen other suggestion ?
11:18:27 <Jad> shapr i want to add an Eliza module to lambdabot
11:18:33 <Jad> however the version i got home is quite old
11:18:42 <Marvin--> shapr: dunno
11:19:03 <Marvin--> shapr: she *does* have Thompson's book
11:19:09 <shapr> good point
11:19:19 <shapr> Jad: http://www.scannedinavian.org/~shae/lambdabot20040209.tar.bz2
11:19:25 <shapr> Jad: but, I haven't fixed the README yet
11:19:42 <shapr> you just need to run 'make' not anything else
11:20:22 <Jad> i will be having a connection home soon
11:20:32 <Jad> i will update you with my progress then.
11:20:50 <shapr> cool!
11:21:24 <cptchaos> is a GHC developer here?
11:26:35 <cybermanco> shapr: http://www.scannedinavian.org/~shae/lambdabot20040209.tar.bz2 this version works?
11:27:46 <shapr> cybermanco: yes, just don't do what the README says, instead run "make"
11:28:14 <Jad> argg winzip can`t extract bz2
11:28:27 <cybermanco> hm
11:28:32 <cybermanco> I'm using windfows :\
11:28:45 <shapr> ok, I'll create a zip archive
11:29:16 <Jad> am in a netcafe, and the owner is sceptical about me installing winzip
11:29:22 <shapr> :-)
11:30:03 <Jad> Hircules is based on lambdabot
11:31:13 <shapr> yup
11:31:34 <shapr> http://www.scannedinavian.org/~shae/lambdabot20040209.zip
11:31:36 <shapr> ok, try that one.
11:31:51 <shapr> parts of lambdabot may be unix specific, I don't know.
11:32:05 <shapr> if they are, please send me some bug reports and I'll work on it.
11:32:25 <shapr> ok, I'm off to do homework, I'll be back later to read the bug reports :-)
11:33:17 <cybermanco> hm
11:33:19 <cybermanco> I get an error
11:33:24 <cybermanco> extracting
11:33:39 <Jad> what i like about haskell is you don`t have to write comments
11:33:46 <Jad> the code by itself is understandable
11:33:51 <cybermanco> "would you like to replace GHCiModules.hs"
11:41:21 <Jad> ny one know a wordpad alternative ?
11:41:31 <Marvin--> vim? emacs?
11:41:41 <Lemmih> Kdevelop.
11:41:57 <Jad> i am in a netcafe, and wordpad is opening .hs files in a weird way
11:42:05 <cybermanco> editplus
11:42:07 <cybermanco> textpad
11:42:18 <Jad> tnx
11:42:19 <Jad> import Control.Monad ( when )
11:48:12 <Darius> So have you installed Hugs on that netcafe computer?
11:49:44 <Jad> nope
11:49:53 <Jad> i transfer data through a usb 
11:51:58 <Jad> it is annoying to be forced to use windows
11:52:18 <Jad> and knoppix not allowed
11:52:42 <Jad> @topic-tell
11:52:42 <lambdabot> don't know that channel
11:53:20 <Jad> @topic-tell #joy 
11:53:21 <lambdabot> don't know that channel
11:53:24 <Jad> @topic-tell joy 
11:53:25 <lambdabot> don't know that channel
11:58:00 <Jad> bye
12:45:50 <ham[home]> hiho
12:46:03 <ski> ham[home] : hi
12:46:10 <cptchaos> hi
12:47:19 <ski> cptchaos : and hi to you too :)
12:47:46 <cptchaos> ski: thanks :-)
12:51:13 <Lemmih> I'm having problems with this code: http://212.242.49.100/menu.hs <- line 23
12:51:28 <ski> mnemonics : hi !
12:52:21 <ski> Lemmih : mhm
12:52:27 <ski> what kind of problem ?
12:52:42 <Lemmih> I want to run on every item which have a callback.
12:53:05 <Lemmih> *I want to run onButtonClick
12:53:06 <ski> mnemonics : looking for haskell info/answers ??
12:53:26 <Lemmih> s/onButtonClick/onButtonPress/
12:53:50 <mnemonics> ski: nope passed the info looking stage. began the learning one now . :)
12:54:03 <ski> Lemmih : syntax error ?
12:54:08 <ski> type error ?
12:54:32 <ski> doesn't do what i want error ?
12:54:56 <Lemmih> No.
12:54:56 <Lemmih> *menu.hs:13: 
12:54:56 <Lemmih> *Couldn't match 
12:54:56 <Lemmih> *`b -> Event -> IO Bool' 
12:54:56 <Lemmih> *against 
12:54:57 <Lemmih> *`Maybe (MenuItem -> Event -> IO Bool)' 
12:54:59 <ski> mnemonics : ok. you're learning on your own ?
12:54:59 <Lemmih> *Expected type: [(b -> Event -> IO Bool, b)] 
12:55:01 <Lemmih> *Inferred type: [(Maybe (MenuItem -> Event -> IO Bool), MenuItem)] 
12:55:03 <Lemmih> *In the second argument of `mapM', namely `filtered' 
12:55:05 <Lemmih> *In a 'do' expression pattern binding: 
12:55:07 <Lemmih> *mapM (\ i -> (snd i) `onButtonPress` ((fst i) (snd i))) filtered
12:56:05 <ski> hmm
12:56:17 <Lemmih> filtered is a tuple with menuItem and a callback function.
12:57:02 <Lemmih> *filtered is a list of tuples.
12:57:09 <ski> so zipped :: [(Maybe (MenuItem -> Event -> IO Bool), MenuItem)] ?
12:57:38 <Lemmih> yeah
12:57:50 <ski> hmm, you are filtering the list
12:58:03 <ski> but you aren't stripping the Just-constructors away
12:58:19 <ski> i think you can use Maybe.catMaybes for this
12:58:31 <ski> Maybe.catMaybes :: [Maybe a] -> [a]
12:58:54 <Lemmih> ahh Thx
12:59:08 <ski> i.e. "let filtered = catMaybes zipped"
12:59:13 <ski> um
12:59:18 <Lemmih> yes i understand.
12:59:25 <ski> ok
12:59:39 <ski> you *could* write
12:59:52 <Lemmih> But that's not the problem.
13:00:03 <ski> mapM (\i -> snd i `onButtonPress` fst i (snd i)) filtered
13:00:12 <ski> bu ti dunno, if its clearer
13:00:18 <ski> Lemmih : no ?
13:00:43 <Darius> Lemmih: Parts of your code could be made simpler by using pattern matching and partial application.
13:03:41 <ski> Lemmih : hm, sorry catMaybes don't seem to fit exactly in here
13:03:43 <Lemmih> Darius: I'm very new to Haskell so I'm sure that much/most of the code could be better :)
13:04:00 <Lemmih> ski: catMaybes is perfect for the task.
13:04:17 <ski> but why are you zipping with a list containing Nothing's, just to strip them away afterwards ?
13:04:34 <ski> hm
13:04:41 <Lemmih> Because I want to add callbacks when I code them :)
13:04:52 <Lemmih> The callbacks should match the MenuItems.
13:04:58 <ski> ok, so they are stubs, then
13:05:02 <ski> ?
13:05:16 <Lemmih> stubs?
13:05:25 <ski> placeholders
13:05:30 <Lemmih> yeah
13:05:52 <cptchaos> Lemmih: could you map Just to the second list before zipping?
13:06:13 <mnemonics> is the twodzn tutorial a good start ?
13:06:56 <Lemmih> cptchaos: I don't understand.
13:07:22 <Darius> Lemmih: Well the two immediate things are, mapM (\i -> (snd i) etc.) can be mapM (\(f,x) -> x `onButtonPress` (f x)), and the (\i -> containerAdd menu i) is the same as just (containerAdd menu).
13:07:29 <ski> Lemmih : hm, catMaybes take [Maybe a], your list have a type [(Maybe ...,...)], right ?
13:08:23 <Lemmih> oh yeah
13:08:46 <ski> then i think catMaybes won't fit (at least in the code's current state)
13:09:21 <ski> what tyoe does menuItemNewWithLabel have ?
13:09:38 <ski> String -> ?what?
13:09:56 <Darius> Lemmih: You can also use pattern matching to solve your problem, i.e. mapM (\(Just f,x) -> ...)
13:10:22 <ski> Darius : will that work ?
13:10:23 <Darius> Also (importing isJust from module Maybe) you can rewrite the predicate for filter as (isJust . fst).
13:10:39 <ski> better
13:11:24 <ski> Darius : wouldn't match-failures generate an error in  mapM (\(Just f,x) -> ...) ?
13:11:51 <Lemmih> Darius: Thx. That fixed it.
13:11:58 <ski> mnemonics : sorry, i dunno much about the tutorials :(
13:12:23 <Darius> ski: Yes, but filtered should always be of the form [(Just _,_),(Just _,_), ...]
13:12:43 <ski> mnemonics : i learned the initials from a book (Thompson's)
13:13:02 <bring> isn't this constraint always unneccessary:
13:13:05 <bring> class FromStr a where
13:13:12 <ski> Darius : oh, sorry. somehow thought you were up in the filter
13:13:16 <bring> fromStr :: FromStr a => String -> a
13:13:33 <palomer> is lazy evaluation _really_ useful?
13:13:42 <bring> that is, isn't "FromStr a" always pointless here
13:13:46 <palomer> someone show me an example where its power is obvious
13:14:00 <Darius> bring: I'm not sure if that's even legal.
13:14:29 <bring> Darius: ghc and hugs accept it, and I have found a program where Hugs requires it
13:14:29 <Darius> palomer: The paper "Why functional programming matters" has examples utilizing lazy evaluation.
13:14:32 <ski> palomer : hmm, well e.g. alfa-beta-pruning
13:14:45 <ski> palomer : it can help with modularity
13:15:00 <palomer> I short example where the advantages are obvious
13:15:14 <palomer> one has to wonder if it adds more than it takes away(ie performance)
13:15:32 <bring> here's one: addIntrospection t = t' where t' = ("system.listMethods", fun (listMethods t')) : t
13:15:58 <palomer> how would you do that without lazy evalution?
13:16:27 <bring> hmm, I'd prefer not to
13:16:30 <bring> :)
13:16:53 <palomer> what does it do?
13:17:09 <Riastradh> Demonstrates laziness.
13:17:18 <palomer> apart from that
13:18:16 <bring> it takes a list of [(String,XmlRpcMethod {- just think of it as a function-} )] and adds a method listMethod to it that lists all the functions in that list, but listMethods is also able to list itself, since it is given the list t'
13:18:35 <bring> lot of 'list' in that sentence
13:18:51 <bring> don't think I understand that sentence myself
13:18:56 <palomer> ahhhh, I see
13:19:19 <Darius> bring: It doesn't appear to use it's argument.
13:19:25 <ski> palomer : they talk some on alfa-beta-pruning in the "Why functional ..." paper
13:19:27 <Darius> Oh, nevermind.
13:19:33 <Darius> I missed the second line.
13:19:36 <palomer> hrm, all in all, is it really worth it?
13:20:23 <Darius> palomer: Well, think of how you would make the above.
13:20:49 <ski> palomer : with lazyness you can separate the concerns of constructing the (very large or perhaps sometimes infinity) game space tree and of searching it
13:20:51 <palomer> to tell you the truth, I never felt the need to do the above
13:21:12 <Riastradh> palomer, how extensively have you used Haskell?
13:21:25 <palomer> none
13:21:29 <palomer> >:O
13:21:41 <Riastradh> So if you've never used it, how do you know what you feel like doing when using it?
13:21:59 <ski> palomer : without laziness, i think that one would have to intertwine these two code snippets and compicate it thusly  (i.e. to stop it from actually constructing a very large tree)
13:22:25 <CrewdenX> palomer: the lazy evaluation is probably worth it in a language like haskell.  the benefits of reengineering typical imperitive languages to use lazy evaluation maybe less so.
13:36:00 <ski> d'oh
13:36:29 <ski> ERROR "....hugs/Trex.hs" - Illegal export of a lone data constructor "EmptyRec"
13:36:42 <ski> why hugs does like this ?
13:36:59 <ski> (Hugs 2002Nov)
13:37:14 <ski> (with -98 option)
13:38:06 <bring> I though Trex was broken in hugs nov2002
13:38:12 <bring> s/though/thought/
13:38:15 <ski> hmm perhaps is
13:38:19 <bring> have you tried nov2003?
13:38:35 <ski> dunno if it's installed here ..
13:38:47 <bring> in school?
13:38:49 <bring> yes it is
13:38:49 <ski> mm
13:39:31 <bring> Darius: I looked it up, you are right, haskell 98 doesn't allow constraints in class methods on the type variable that is used in the class declaration head, but the implementations don't seem to care if the constraint is the class being declared, even in haskell98 mode
13:39:45 <bring> /usr/ed-pkg/sup.phc/b/binh/_hugs_Nov2003
13:39:52 <ski> bring : yes, works
13:40:33 <ski> seems "hugs" refer to 2002Nov one, though. for some reason ..
13:41:18 <ski> bring : hmm well i actually found /usr/ed-pkg/pkg/hugs98-Nov2003/
13:41:21 <bring> chucky told me that they only upgrade the default between the quarters
13:41:30 <ski> ok
13:41:49 <ski> he's in helpdesk or something .. ?
13:42:31 <bring> nope, but he has permission to install unsupported stuff
13:42:55 <ski> mhm
13:43:05 <bring> so don't use him as a helpdesk, he's not getting paid for it :)
13:43:19 <ski> won't do, then.
13:43:40 <bring> but he seems happy to help out if you ask nicely
13:43:47 * ski bah!'s
13:44:00 <ski> (it doesn't work)
13:44:24 <bring> what are you using Trex for?
13:44:28 <ski> Trex> :t (x = 5,a = 3|)
13:44:29 <ski> ERROR - Syntax error in expression (unexpected `)')
13:44:45 <ski> was going to test a thing
13:44:55 <ski> related to http://lambda.weblogs.com/discuss/msgReader$11048?mode=topic&y=2004&m=2&d=9
13:46:07 <ski> more specifically, i was thinking that one could perhaps use a trex-record-section to "curry" a function with named arguments (i.e. in this case, really a record argument)
13:46:36 <ski> like  f :: (a :: A,b :: B,c :: C) -> X
13:47:05 <ski> f . (c = someC,a = someA |) :: (b :: B) -> X
13:47:15 <ski> or something like that
13:47:33 <ski> but seems they haven't thought of record sections :(
13:47:39 <bring> that seems diffcult, but interesting
13:47:55 <ski> so one has to write  f . (\r -> (c = someC,a = someA |r))  :(
13:48:03 <ski> much worse
13:48:12 <bring> but that works?
13:48:16 <ski> i guess
13:48:34 <bring> I mean the whole curry thing?
13:48:49 <bring> what about records with another number of arguments
13:50:11 <ski> what ?
13:51:19 <bring> s/arguments/fields/
13:51:30 <bring> would you have to write a different f for, say, a record with four fields instead of three?
13:51:38 <ski> isn't it mutatis mutandis ?  if this works, why wouldn't other number of arguments ?
13:52:02 <ski> i don't understand your question.
13:52:17 <bring> I mean does the same function work for any number of fields, or would you have to write one for each number of fields?
13:52:51 <bring> maybe I missed the point
13:53:17 <ski> yay !
13:53:21 <ski> it typechecked
13:53:29 <ski> Trex> :t \f -> (f :: Rec (a :: Int,b :: Bool,c :: Char) -> String) . (\r -> (c = 'c',a = 42 | r))
13:53:29 <ski> \f -> f . (\r -> (a=42, c='c' | r)) :: (Rec (a :: Int, b :: Bool, c :: Char) -> String) -> Rec (b :: Bool) -> [Char]
13:54:06 <ski> i abstracted over the f, 'cuz this isn't ghci
13:54:10 <ski> well
13:54:16 <ski> the idea was this
13:54:28 <ski> suppose you have a function of several arguments
13:54:41 <ski> and you want to curry it at times
13:54:49 <ski> in several incompatible ways
13:54:56 <ski> so
13:55:03 <ski> we name the arguments
13:55:10 <ski> (putting them into a record)
13:55:46 <ski> and we want a syntax for giving just some of the arguments, such that we get back a function still wanting the remaining ones
13:55:57 <bring> ok
13:56:00 <bring> got it
13:56:13 <ski> O'Caml has labelled arguments in commuting mode
13:56:35 <ski> i was thinking of achieving a similar effect with a "record section"
13:57:02 <ski> i.e. like  "(c = 'a',a = 42 | )"
13:57:19 <ski> which would be the same as "\r -> (c = 'a',a = 42 | r )"
13:57:47 <ski> (where the | r part is the record we extend with c and a fields)
13:58:48 <ski> hmm, wonder if i should post something on this idea to lambda the ultimate ...
14:00:15 <ski> (i'll have to create a profile, then, i guess)
14:32:59 <ski> hi tzu
14:33:05 <tzu> hi
14:33:13 <ski> got haskell ?
14:33:25 <tzu> yeah, i'm just working on an assignment
14:33:30 <ski> have any questions ?
14:33:32 <ski> ok
14:33:54 <tzu> yeah, i'm stuck with a recursion which doesn't work the way it should
14:34:07 <ski> mhm
14:34:09 <tzu> was just trying to look over it again if i maybe find any faults
14:34:14 <tzu> but
14:34:20 <tzu> please have a short look at it :)(
14:34:28 <ski> ok :)
14:34:31 <tzu> getPrereqs :: Int -> [Prerequisite] -> [Int]
14:34:31 <tzu> getPrereqs id (x:xs)
14:34:31 <tzu> 	| fst x == id = [snd x] ++ getPrereqs (snd x) (x:xs) ++ getPrereqs id xs
14:34:31 <tzu> 	| otherwise = getPrereqs id xs
14:34:43 <tzu> Prerequisite is a (int,int)
14:35:06 <tzu> and it is a list of prerequisites, which form a tree
14:35:20 <tzu> that is, i esentially want to find all childs of a given node
14:35:39 <tzu> and with this one, i find all of the current childs, but no childs of the childs
14:35:40 <ski> getPrereqs id ((id',whatever):preqs)
14:36:14 <Cale> you possibly shouldn't be using id as a variable name, as it's a prelude function, though I'm not sure it matters.
14:36:18 <ski>   | id == id' = [whatever] ++ getPrereqs whatever ((id,whatever):preqs) ++ getPrereqs id
14:36:21 <tzu> hmm
14:36:30 <tzu> worked so far fine, but thanks for pointing it out
14:36:33 <ski>   | otherwise = getPrereqs id preqs
14:36:36 <Darius> Cale: Haskell doesn't care, though it could be misleading.
14:36:40 <Cale> yeah
14:37:11 <ski> tzu : that was just some pattern matching, to make the code look tidier
14:37:46 <tzu> oh, you avoided the fst stuff :)
14:37:51 <ski> yes
14:38:31 <tzu> isn't that pretty much the same as i had?
14:38:33 <Darius> ski: If you were going to bother with that, why not point out that consing an element to the front instead appending a singleton is clearer.
14:38:37 <ski> tzu : yes
14:38:45 <tzu> but it won't work :|
14:38:55 <ski> Darius : hadn't read the code then :)
14:39:03 <tzu> or did you just rewrite it to see through it?
14:39:31 <ski> well, one might imagine that
14:39:36 <ski> :)
14:41:43 <ski> hm
14:42:00 <ski> so the snd x is "child" ?
14:42:05 <tzu> ah yes
14:42:13 <tzu> (parent, child)
14:42:18 <ski> ok
14:43:55 <ski> hm
14:44:58 <ski> i guess you really would want to do "getPrereqs (snd x) xs0", where xs0 is the "toplevel" list of Prerequisite, right ?
14:45:08 <ski> (you are not doing that ATM)
14:45:14 <tzu> right.. i want the prereqs of the found prereq
14:45:50 <ski> so, say that this getPrereqs function has recursed, say, 10 elements into the toplevel list (xs0)
14:46:31 <ski> then, say, it finds a parent-child-pair, with parent equal to the current person sought after
14:46:55 <tzu> hmm
14:47:04 <tzu> argh damn
14:47:08 <tzu> i need to go :/
14:47:26 <ski> now it (getPrereqs) is going to hand this list to the recursive call "getPrereqs child (prereq:prereqs)"
14:47:34 <ski> mhm
14:47:42 <tzu> thanks a lot for taking the effort of helping, i'll try again tomorrow if i fail again i'll bother you again
14:47:45 <tzu> if it's ok
14:47:45 <ski> tzu : temporarily ?
14:47:49 <ski> ok
14:47:56 <ski> you do that
14:48:01 <tzu> but thanks for now
14:48:06 <ski> goodbye
14:57:52 <Darius> hmm, four people (well one wasn't a person) left and 77 remained...
14:58:47 <ski> what does that tell you ?
14:59:07 <Riastradh> There are too many frequenters of this channel, especially idlers.
14:59:42 <ski> i dunno, i'm not so used to irc
14:59:54 <ski> but i'll take your word for it
15:00:31 <Riastradh> Idlers prevail throughout.
15:03:17 <ski> perhaps there happens to be a lot of people with permanent connections, so that they can be here most of the 24 hours of the day ..
15:03:37 <ski> hi cmoline !
15:03:55 <cmoline> hey!
15:03:57 <ski> looking for haskell help or info ?
15:04:07 <cmoline> not really
15:04:16 <ski> just curious, then ?
15:04:17 <cmoline> more in the mood to talk about haskell stuff
15:04:20 <ski> ok
15:04:28 <ski> well
15:04:36 <cmoline> why are you being so helpful?
15:04:40 <cmoline> bored?
15:04:51 <ski> unfortunately there'sn't much of a discussion going on here ATM
15:04:56 <ski> well
15:04:56 <cybermanco> because ski is a cool guy!
15:05:14 <ski> i usually try to be helpful, if i have the time
15:05:23 <ski> and i like it
15:05:31 <cmoline> heh. in my experience theres never much discussion in the interesting channels :)
15:05:36 <ski> cybermanco : flatterer :)
15:05:36 <Marvin--> ski da man :)
15:05:42 <cmoline> yeah. i like helping people too.
15:05:49 <ski> Marvin-- : huh ?
15:06:01 <cmoline> hes saying youre cool
15:06:07 <ski> mhm
15:06:27 <ski> (thought that was some weird swedish or something)
15:06:35 <Marvin--> heh
15:06:38 <ski> (like in dialect)
15:06:46 <cmoline> heh :) no its just slang
15:07:07 <ski> mm
15:07:14 <cmoline> so how many people are in that category study group now?
15:07:24 * ski checks
15:07:30 <cmoline> actually i suppose i should just go look at the wiki page
15:07:49 <Marvin--> what wiki?
15:08:08 <ski> hawiki !
15:08:28 * Darius would @wiki StudyGroup, but, alas, the 'bot is gone.
15:08:30 <ski> 7 persons on the page
15:08:50 <cmoline> yep
15:09:05 <cmoline> im one. can you figure out which? :)
15:09:07 <ski> cmoline : so i guess you're Chris Moline, then ?
15:09:15 <ski> ha :)
15:09:54 <ski> do you own it ?
15:09:54 <cmoline> ive made it up to page 46 of that conceptual mathematics book
15:10:01 <cmoline> yes i do
15:10:06 <ski> mm, how far is that ?
15:10:11 <cmoline> im glad i decided to buy it
15:10:19 * ski hasn't got the book here at uni for the moment
15:10:29 <cmoline> the books 350 pages, so not very far
15:10:59 <ski> well, i more wondered, like, what concepts have they introduced yet ?
15:11:03 <cmoline> i have a short attention span when it comes to reading textbooks :)
15:11:12 <ski> heh
15:11:12 <cmoline> oh.
15:11:25 <ski> product informally, i know
15:11:30 <cmoline> well theve introduced categories and isomorphisms.
15:11:59 <cmoline> and the part i am in is division and isomorphisms
15:12:25 <cmoline> the diagrams in this section are kind of confusing :)
15:12:31 * ski must return the book tomorrow, but will try to borrow it again, if nobody else has reserved it ..
15:12:38 <ski> ah, ok
15:12:50 <Marvin--> ski: oh, so you're saying I shouldn't? :)
15:12:58 <cmoline> it took me several seconds to figure out that this one diagram wasnt making any sense because it was for a different example :)
15:13:09 <ski> because you're new to them ?
15:13:30 <ski> Marvin-- : Fie on you, found fiend !
15:14:00 <cmoline> no because the diagram for the first example came after it was finished on the other side of the page
15:14:10 <ski> ok, mm
15:14:32 <Darius> ski: Why do you add extra whitespace between (some) punctuation?
15:14:48 <ski> Marvin-- : I thought you said, the other day, that "category theory scares me" ?   :)
15:14:49 <cmoline> i assumed the diagram for the example would be above it and so i was reading example 2 and trying to figure out the diagram for example 1
15:15:18 <ski> Darius : Well, I think it looks more correct. (Long habit)
15:15:20 <cmoline> Darius: what kind of punctuation?
15:15:56 <Darius> cmoline:  For question marks and the colon between the addressee and the text, e.g. "Darius :"
15:16:01 <Marvin--> ski: it does, but I want to learn more about it
15:16:07 <ski> Darius : also when making "tables" in programs i most often use "blabla ,blabla" rather than "blabla, blabla"
15:16:13 <Marvin--> ski: go ahead and reloan it, I'll look for something else :)
15:17:43 <cmoline> ski im curious, why does the former seem more correct to you?
15:17:56 <ski> Darius : I guess my internal lexer thinks that symbols like ; : ! ? belongs to the preceding token if there's no whitespace in between .. (Is the case for . also, actually, but ..)
15:18:51 <cmoline> ok i see
15:18:59 <cmoline> i dont think that way :)
15:19:09 <ski> I.e. i'm not saying that it really is more correct in normal swedish or english usage. Only that it feels that way to me.
15:19:21 <cmoline> yeah i get you
15:20:28 <ski> Also, I'd rather write like "foo- and bar-quuz", than "foo- and barquux"
15:20:59 <ski> Marvin-- : thanks :)
15:22:01 <cmoline> yeah its more symetric
15:22:15 <cybermanco> finaly I finished my project...
15:22:16 <ski> and less ambigous, in some cases
15:22:23 <ski> which was ?
15:22:42 <cybermanco> some funcs qith quadtrees
15:22:49 <cybermanco> qith - with
15:22:50 <ski> oh, right
15:23:02 <ski> i hope it's not too slow
15:23:07 <cybermanco> :)
15:23:09 <cybermanco> a bit
15:23:26 <cybermanco> and it crashes with pics bigger than 512x512..
15:23:30 <ski> i think the linearization of the QTree could be done better
15:23:41 <cybermanco> next year probably
15:23:45 <cybermanco> I will be here again
15:23:48 <ski> (even while keeping the current idea of doing it)
15:23:49 <cybermanco> asking for help
15:24:09 <ski> so, are you finished with your course or something ?
15:24:31 <cybermanco> I have a discipline in wich we use haskell
15:24:39 <ski> it's a long time 'til next year ..
15:24:44 <cybermanco> but I don't know enough to pass
15:24:53 <cybermanco> I will do it again next year
15:24:55 <cybermanco> :)
15:25:01 <ski> mm, ok
15:26:19 <ski> cmoline : so, are they talking about sections and retractions, yet ?
15:26:29 <cmoline> uh, no
15:26:34 <cmoline> :)
15:26:47 <cmoline> let me look them up
15:26:54 <ski> monos and epis ?
15:27:09 <cmoline> hey thats cool i can read this while i sit here and smoke
15:27:14 <ski> their definition is not so hard to understand
15:28:14 <cmoline> oh hey sections and retractions is right after the section im reading
15:28:14 <ski> read the book ? or read this channel ?
15:28:18 <ski> ok
15:28:22 <cmoline> the book
15:28:28 <ski> mm
15:29:07 <ski> i think they describe sections and retractions as a kind of "division" problem
15:30:04 <cmoline> yep. they describe them as special cases of determination and choice problems
15:30:52 <cmoline> ok i just read the determination part so iknow thats division, but i need to refresh on choices for a sec
15:31:01 <ski> (i had some ideas about making use of retracts to define types in proglangs)
15:31:08 <cmoline> i think thats multiplication
15:31:24 <ski> well, i dunno
15:31:36 <ski> i've been "fast-reading" the book
15:31:51 <cmoline> cool. let me read this and see if i can understand what you just said
15:31:57 <ski> so i'm not sure which is which of determination and choice
15:32:39 <ski> re retracts ?
15:32:43 <cmoline> er ive made a mistake. choices is divsion too. 
15:32:56 <ski> hmm, well would think so
15:33:12 <ski> f = g . h
15:33:39 <ski> wasn't it like we have f and one of f and g, and want the other one ..
15:33:46 <ski> or something like that
15:33:58 <ski> s/one of f and g/one of g and h/
15:34:50 <cmoline> hmm. looks like i need to reread this section :)
15:35:02 <ski> the section on sections ?
15:35:11 <cmoline> no on division :)
15:35:14 * ski couldn't resist
15:35:26 <cmoline> im a little slow today :)
15:46:08 <cmoline> ski: could i ask a question about types? what exactly is a type. i have some math books here that define the word but im not sure if the math definition of type is the same as the programming language. also, i dont understand the definitions given in my math books :)
15:46:31 <ski> well, that's a big question :)
15:46:47 <ski> to a zeroeth approximation, it's just a set
15:47:12 <cmoline> ive been kind of thinking of them as sets that define acceptable values that can be passed to functions
15:47:32 <cmoline> i dont know how close that is though
15:47:32 * ski has a book @ home that nicely explains common types
15:47:40 <ski> well
15:47:50 <ski> usually not *any* set can be a type
15:47:52 <cmoline> do you know the title?
15:48:02 <ski> (trying to recall it)
15:49:55 <ski> usually in programming languages, the types can only be inhabitated by computable values (IIUC)
15:51:48 <Darius> Hmm, interesting quote: "Life is a sexually transmitted disease."
15:52:12 <ski> Darius : you haven't seen that before ?
15:52:19 <Darius> Nope.
15:54:44 <ski> hmm, perhaps could've been "
15:54:47 <ski> Principles of Programming Languages"
15:55:03 <ski> R. D. Tennent i was thinking about
15:55:24 <cmoline> that book sounds familiar. let me look it up
15:57:36 <ski> i can't seem to find a pic of it
15:58:25 <cmoline> wow at two bucks that is a cheap book
16:00:12 <ski> well, i remember that it said in the preface that it was indented as the first book in a series of three  (the other two concentrating more on actual syntax and semantic. the first being more oriented towards language-independant concepts (and principles))
16:00:15 <cmoline> weird amazon doesnt seem to have any reviews of this book
16:01:16 <cmoline> i suppose prentice hall ought to have a description of the book eh?
16:01:52 <ski> one chapter in the book was coauthored with hughes  (the one on the functional paradigm)
16:02:50 <cmoline> wow prentice hall has alot of books on subjects im interested in
16:03:03 <cmoline> ive been trying to teach myself some math
16:03:19 <cmoline> but the local bookstores dont sell much for math books 
16:03:58 <ski> IIRC, the divisions of the book were roughly :  Introduction , Part 1 (Values,Storage,Bindings,Typesystems,Sequencers), Part 2 (Imperative,Object-oriented,Functional,Logic/Declarative),Conclusions
16:04:17 <cmoline> mostly histories and recreational maths and study guides for sats and calculus class
16:04:27 <ski> :(
16:04:45 <cmoline> thank god for buying stuff online :)
16:04:57 <ski> oh
16:05:08 * ski hits self on head, hard !
16:05:31 <ski> why must i be so thick-headed sometimes
16:05:32 <ski> ?
16:05:44 * palomer is part of christian for type classes in ocaml
16:05:45 <palomer> join us!
16:05:51 <ski> I do have to book's name on my homepage !
16:05:51 <cmoline> hey im thickheaded all the time
16:05:57 <palomer> s/christian/christians
16:06:14 <ski> palomer : perhaps i'll do ;)
16:06:18 <palomer> cmoline: have any math questions?
16:06:44 <ski> palomer : what's "christian for type classes in ocaml" ?  some group/project ?
16:06:48 <cmoline> well i dont really want to bother you with such basic questions
16:07:06 <cmoline> i think if i just spend more time with these books ill make progress
16:07:17 <palomer> ski: christians for type classis in ocaml is a religious group which believes in improving ocaml by adding type classes
16:07:18 <ski> cmoline : see bottom of http://www.mdstud.chalmers.se/~md9slj/HTMLPage/principles.html for book name
16:07:35 <ski> palomer : that sound like fun ! :)
16:08:01 <palomer> want to join?
16:08:02 <Darius> What does religion have to do with adding type classes to OCaml?
16:08:14 <palomer> I'm also part of mothers for type classes in ocaml
16:08:34 <palomer> Darius: what does religion have to do with anything those groups advocate?
16:08:39 <ski> Darius : Isn't that obvious ?  Programming languages is all about religon. I though you'd noticed.
16:09:13 <ski> (well, at least some debates seem pretty religous :)
16:09:54 <ski> palomer : well, i'm not a mother, so i could probably not join that group ..
16:10:03 <palomer> oh, I'm not a mother too
16:10:13 <palomer> we have quite a bit in common
16:10:17 <palomer> are you a fireman? 
16:10:23 <cmoline> ok i found it. damn prentice hall their description doesnt say anything
16:10:23 <ski> no
16:10:31 <palomer> me neither!
16:10:33 <ski> "I want to be a fireman"   (citation)
16:10:48 <ski> (d'you know from where ?)
16:10:51 <palomer> anyways, if ocaml had type classes, it would rock.
16:10:57 <palomer> barny? 
16:10:58 <ski> well, perhaps
16:11:56 <ski> palomer : no. the game "The Secret of Monkey Island", in the SCUMM Bar, talking to the three pirate captains, all drinking grog(TM)
16:12:00 <ski> :)
16:12:51 <ski> cmoline : that page is meant to show some "principles" from that book
16:12:57 <ham[home]> me bed
16:13:13 <ski> ham[home] : good dreaming !
16:13:20 <ham[home]> thx
16:14:00 <ski> palomer : hmm, also i'm not sure if i'm a christian. so that would perhaps be another disqualification ..
16:14:43 <ski> (or perhaps, rather i'm not sure hom much of me is christian)
16:16:57 <ski> cmoline : the book contained some aha-experiences for me
16:17:41 * Heffaklump appears
16:18:03 <cmoline> it certianly sounds cool.
16:18:37 <ski> Heffalump : be welcome, oh thou big lump elephant-like thing :)
16:18:49 <ski> yes
16:19:08 <ski> i only wish they would discuss continuations some
16:19:34 * Heffaklump was just at a workshop at UKC about refactoring and HaRe
16:19:42 <ski> cool !
16:19:47 <cmoline> i know a little about continuations though i havent actually used them yet
16:19:49 <ski> was it fun ?
16:20:02 <ski> cmoline : they're interesting
16:22:46 <ski> (continuations in natural language is also interesting)
16:23:18 <Heffaklump> yes, it was good
16:24:07 <cmoline> interesting. could you give an example of how continuations would be useful in natural language?
16:24:33 <ski> well, words like all,some e.g.
16:24:46 <ski> which scope do they have
16:24:47 <ski> ?
16:25:05 <ski> Bob likes all cats.
16:25:34 <ski> forall c. Cat c /\ Likes Bob c
16:25:57 <ski> how do we discover that the forall should scope over the whole sentence
16:27:09 <ski> if we try to parse this in a normal way, the outer level could be arbitrarily long away from the level at which we discover that the 'and'-word was actually used
16:28:03 <ski> so we do something like [[ all ]] = shift k. forall x. k x
16:28:22 <ski> understood anything of that ? ;)
16:29:08 <cmoline> what do you mean by the "'and'-word"?
16:29:10 <cmoline> the all?
16:29:12 <ski> oh
16:29:14 <ski> 'all'
16:29:19 <ski> yes
16:29:39 <palomer> I have here that X \subset f^-1(V_1) U ... U f^-1(V_n) => f(X) \subset V_1 U ... U V_n <---why is that?
16:29:46 <palomer> woops, wrong channel
16:29:46 <cmoline> ok and so shift is like callcc?
16:30:00 <ski> almost, but not quite ;)
16:30:11 <cmoline> well k is the continuation right?
16:30:13 <ski> it a kind of "composable continuation"
16:30:15 <ski> yes
16:30:23 <ski> wanna an example ?
16:30:45 <ski> (of the kinds of cont.s)
16:30:53 <cmoline> sure. i dont understand much of this stuff but i sure seem to like it
16:30:59 <ski> ok
16:31:16 <ski> 1 + letcc k. k 10 = 1 + 10 = 11
16:31:35 <ski> letcc is callcc just like a let in syntax
16:31:54 <ski> (letcc k. M = callcc (\k. M))
16:32:05 <ski> get that ?
16:32:28 <cmoline> ok this is lambda calculus notation?
16:32:37 <ski> yes, more or less
16:32:48 <cmoline> were defining a function letcc
16:32:52 <ski> no
16:32:56 <ski> letcc is syntax
16:33:23 <ski> <expression> ::= "letcc" <variable> "." <expression>
16:33:30 <ski> like
16:33:34 <cmoline> well k is the continuation again right? :)
16:33:44 <ski> <expression> ::= "\" <variable> "." <expression>
16:33:47 <ski> yes
16:34:16 <ski> so in that case, k is "add 1 and return to toplevel"
16:35:02 <ski> so that example isn't very exciting, actually
16:35:21 <cmoline> ok i think im beginning to get that part.
16:35:26 <ski> letcc k.k M  ===  M   if k free in M
16:36:10 <ski> the letcc thing captures the current (implicit) continuation and calls it k
16:36:21 <cmoline> functional programs are made out of expressions right? so to bind k to the expression after the letcc is to bind the rest of the computation right?
16:36:32 <ski> yes, right
16:37:11 <ski> well, we bind it the the context (expression with hole) that is *around* the expression of form "letcc k. M"
16:37:22 <cmoline> ok now whats this M = ?
16:37:23 <ski> s/the the/to the/
16:37:43 <Darius> ski: C[letcc k.k M] === M as opposed to C[1+2] === C[3]
16:37:45 <ski> it's just any term/expression.  i.e. a meta-variable notation
16:38:19 <ski> Darius : huh ?
16:38:35 <Darius> Actually, that's wrong.
16:38:41 <ski> yes :)
16:39:23 <ski> perhaps you thought of "letcc k.M", k free in M ???
16:40:05 <Darius> ski: It would be wrong even in that case if letcc is callcc.  What I'd need is to have a more involved expression.
16:40:30 <ski> Darius : yes. (but not if it was curly-C)
16:40:50 <Darius> control
16:41:02 <ski> control-prompt ??
16:41:14 <ski> felleisen's ?
16:41:44 <ski> (think 'twas him, who invented control + prompt)
16:42:05 <Darius> Felleisen made prompt, but there are many variations
16:42:32 <ski> cmoline : did i answer your question (about M = ) good enough ?
16:42:42 <ski> Darius : yes :(
16:43:54 <cmoline> in the example you gave M would be bound to 10
16:44:09 <ski> umm, yes
16:44:19 <cmoline> im getting there but im not quite there
16:45:05 <ski> you could think of k as representing "abort (\x.1 + x)"
16:45:10 <jameson> Come to think of it... does Haskell have continuations? Sure, one could presumably implement the Continuation Monad, but are continuations built in as in SML/NJ?
16:45:17 <Darius> ski: C[letcc k.E[k x]] ->> C[x] is probably the most compact way of explaining it.  It's closer to what I was intending, though a control version is clearer (for this).
16:45:38 <cmoline> jameson: i dont think so
16:45:43 <ski> hmm, well perhaps not quite like that ..
16:45:44 <Darius> jameson: No, and it shouldn't.
16:46:19 <ski> continuations is an (side-)effect !
16:47:08 <ski> Darius : yes. agree
16:47:26 <jameson> Good point, so they should only occur in monadic contexts, then.
16:47:57 <ski> though monadic reflection is interesting ..
16:48:09 <jameson> What's that?
16:48:36 <Riastradh> ski, anything, then, is a side effect -- function calling, function returning, consing a closure, et cetera --.
16:48:59 <ski> a way of implicitifying any explicit monad so it becomes implicit effect, like state usually is in e.g. imperative languages
16:49:38 <cmoline> oh i get what you wrote now. i was parsing it all wrong
16:49:47 <ski> Riastradh : well, the (ordinary) result of an expression is not considered "side", If i have understood correctly
16:49:49 <jameson> ski: How do you maintain referential transparency, then?
16:50:16 <ski> jameson : you don't                                          :) :/
16:50:20 <cmoline> you were saying that letcc k. M was the same thing as callcc (\k. M)
16:50:27 <ski> yeah
16:50:41 <ski> that's just syntax differences
16:50:44 <Darius> cmoline: Yes, and I have no idea why he didn't just use it.
16:51:05 <ski> Darius : huh ?
16:51:08 <cmoline> jeez i was thinking you were trying to do assignment or some kind of binding with that equal sign
16:51:15 <cmoline> :)
16:51:28 <cmoline> see why i get confused by diagrams :)
16:51:30 <jameson> ski: Not quite. IIRC, "let" is polymorphic, whereas "\" isn't.
16:51:56 <ski> jameson : this is an answer to what ?
16:52:10 <Darius> ski: callcc is more familiar
16:52:38 <ski> but perhaps a bit heavier notation
16:53:02 <jameson> ski: If I'm not mistaken, 'k' in "letcc k. M" could be used with different types, whereas it could not in "callcc (\k. M)".
16:53:31 <ski> jameson : that of course depends on if the language is typed or not :)
16:53:44 <jameson> ski: True ;-)
16:54:15 <Darius> ski: Not enough to the extents you are likely to be using it.
16:54:42 <Darius> Especially, with a much more compact lambda that Scheme's.
16:55:06 <ski> Darius : sorry, i don't understand what you mean.  (must be thick-headed again :)
16:55:26 <ski> aha
16:55:27 <ski> ok
16:55:59 <ski> well, DrScheme had a letcc, and in scheme the lambda syntax is heavier
16:56:27 <ski> probably that explained why i preferred that for the moment
16:56:37 <ski> s/had/has/
16:57:40 <ski> well
16:58:04 <ski> cmoline : did you see why the expression should reduce to 11 ?
16:58:30 <cmoline> darn im out of scrollback. i gotta set that to like a thousand or something
16:58:51 <ski> 1 + letcc k. k 10  =  1 + 10  =  11
16:59:05 <ski> cmoline : i've :)
16:59:05 <cmoline> what were we talking about again? oh yeah, continuations in natural language
16:59:13 <ski> um, yes
16:59:35 <ski> and i think i was going to explain shift and reset  (roughly)
17:00:09 <ski> well
17:00:36 <ski> k (in one view) is here a function of type  Int -> Absurd
17:00:42 <Darius> ski: Being pedantic, an arrow (reduces) would be better than equality.  And on another issue, using "I've" for "I have" as an entire clause is somewhat odd.
17:00:49 <ski> where Absurd is the type which has no value
17:01:46 <ski> Darius : mm, perhaps that's better. and thanks
17:02:09 <ski> so with reduces we could instead write
17:02:21 <ski> 1 + letcc k. k 10  -->  1 + 10  -->  11
17:02:26 <cmoline> i think so. the letcc captures the expression with the hole, ie "1 +". this returns a continuation, which i guess we could say is a function of one arg. we then pass a value to this function and it "fills in the hole". and we are now in a "different place". ie that control will continue from where the continuation was applied. right? am i going where you need me to go?
17:03:01 <ski> yes
17:04:08 <ski> only, that in this view, the continuation would really be something like "\x.toplevelLoop (1 + x)" where toplevelLoop doesn't (conceptually) return (within the system)
17:04:35 <Riastradh> ski, what do you mean?  It's possible for a continuation invocation to return.
17:04:52 <Riastradh> callcc \k. ...(callcc \k'. k k')...
17:05:08 <Riastradh> ...or just [[callcc k]], even.
17:05:15 <cmoline> i think thats just jumping from place to place
17:05:19 <ski> i.e. in this way of looking at it, continuations have an "inner hole" (i.e. an argument), but doesn't have an outer border (i.e does not return anywhere (within the system))
17:06:15 <ski> Riastradh : it's the callcc invokation that return in that (first) example
17:07:25 <ski> cmoline : do you have an idea of how function calls and returns are usually implemented in machine code ?
17:07:55 <cmoline> vaguely. theyre just jumps
17:08:07 <cmoline> there and back again, right/
17:09:17 <ski> Riastradh : with a CPS transform, one usually at last applies the whole thing to (\x.x) to extract the *final* *result* of the program, but in this view, that 'return' is outside of the world model
17:09:21 <ski> yes
17:09:24 <ski> correct
17:09:55 <ski> so (rougly) how would we call a function of type  a -> b  ?
17:10:03 <ski> well
17:10:16 <ski> (for the moment you can forget about closures)
17:10:33 <ski> the function's code is stored at some machine addres
17:11:04 <ski> first we put an argument of type  a  in some well-known place  (e.g. register or stack)
17:11:08 <Riastradh> ski, er, what does that have to do with what I said?
17:11:17 <ski> and then we jump to that address
17:11:40 <ski> Riastradh : of course continuations have to do with this !  :)
17:12:03 <ski> cmoline : are you with so far ?
17:12:16 <cmoline> yep. its simple
17:12:20 <ski> ok
17:12:26 <Riastradh> ski, I never said anything about CPS transformation, about the final result, or anything like that.
17:12:33 <ski> but, wait. haven't we forgotten anything ?
17:12:57 <ski> Riastradh : you were talking about returning continuations, right ?
17:13:12 <Riastradh> I was talking about continuation invocations returning.
17:13:21 <ski> yes
17:13:32 <Riastradh> callcc \k. ...callcc k...   -- That invocation of k can return.
17:13:40 <ski> that's the same thing   (at least as i understand what you say)
17:13:57 <Riastradh> No, that has absolutely nothing to do with the final continuation.
17:14:10 <ski> what final continuation ?
17:14:19 <ski> do you mean the initial one ?
17:14:25 <Riastradh> The final continuation of any running CPS program.
17:14:37 <ski> ok
17:14:49 <ski> terminology clash, it seems
17:15:31 <ski> cmoline : anyway, when we jump to the address of the function, let's call it foo
17:16:20 <ski> we also have to remember where (what addres) we want to continue executing code, after foo's code has run to it's end
17:16:36 <ski> that is the "return address"
17:17:01 <ski> so actually we perform a jump to the address foo, with *two* arguments
17:17:27 <cmoline> the functions argument and the return address
17:17:32 <ski> yes
17:17:46 <ski> normally one thinks of an address as either being untyped
17:18:10 <ski> or belonging to some type like Addr
17:18:21 <ski> (kinda like Int)
17:18:27 <ski> but
17:18:45 <ski> we can include the arguments in this type
17:18:58 <ski> so by jump, we mean, jump with argument
17:19:06 <ski> ok ?
17:19:44 <cmoline> you mean jump with return address?
17:19:58 <ski> *and* the usual function argument
17:20:05 <cmoline> ok
17:20:08 <ski> so
17:21:03 <ski> lets denote the type of an address to a piece of code that is expecting an argument of type "a", lets denote the type of that address by "Not a" :)
17:21:35 <ski> so you understand what i mean ?
17:21:56 <ski> s/so/do/
17:22:17 <Riastradh> Is this supposed to be a basic explanation of continuations?
17:22:38 <ski> Riastradh : well, of the non-composable kind
17:23:27 <ski> cmoline : ?
17:23:58 <cmoline> right Not a denotes a pointer to a function in c terms. the Not a is kind of a pun, indicating its the opposite of data
17:24:10 <ski> yeah
17:24:19 <ski> (and in a more deep sense also)
17:24:45 <cmoline> thus distuighdfkjdk bleh it from an address containing a value of type a
17:24:46 <ski> so, the type of (address to) code expecting Int is  Not Int
17:24:54 <ski> yeah
17:25:26 <ski> so, again we have function  foo :: a -> b
17:25:35 <ski> in lower-level terms
17:25:44 <ski> it is code expecting two things
17:25:53 <cmoline> i wish this client had tab completion for some words, like distuiguishing.
17:25:54 <ski> i.e. Not (?,?)
17:25:59 <ski> mm
17:26:04 <cmoline> damn. i still dont think i got that right :)
17:26:14 <cmoline> ok
17:26:18 <ski> ok ?
17:26:42 <cmoline> i meant im back to paying attention now instead of making jokes
17:26:52 <ski> one of the things that this code needs is the value of type "a"
17:26:56 <ski> ok :)
17:27:03 <ski> i.e.  Not (a,?)
17:27:49 <ski> so, the code is expecting a pair, of which the first field is going to be the "function argument"
17:27:50 <cmoline> yeah the second question mark is the return address
17:27:54 <ski> yeah
17:28:15 <ski> but the "return address" is also (a pointer to) code, right ?
17:28:23 <cmoline> yep
17:28:32 <ski> so that gives us  Not (a,Not ?)
17:28:45 <ski> can you guess wht to fill the last ? with ?
17:28:58 <ski> (i.e. the last "?")
17:29:12 <Darius> ski: He'd be hard pressed to fail even if he completely guessed.
17:29:22 <cmoline> hold on here for a sec. i gotta do something
17:29:29 <ski> Darius : perhaps ...
17:29:59 <ski> cmoline : sure
17:33:08 <cmoline> ok. im back
17:33:11 <ski> mm
17:33:42 <ski> do you want to guess/figure it out. or should i just continue ?
17:34:19 <cmoline> i think id like a few minutes. am i slow?
17:34:30 <ski> i dunno :)
17:34:45 <ski> take the time you want
17:36:32 <cmoline> that last question mark should be a pointer to code that takes a value of the type the function is returning
17:36:34 <cmoline> right?
17:36:43 <ski> yes !
17:36:57 <ski> that makes it  Not (a,Not b)  right ?
17:37:06 <cmoline> cool. i didnt think i was going to get that one
17:37:09 <ski> np_hard : hi
17:37:32 <ski> np_hard : looking for info/help on haskell ?
17:38:05 <cmoline> holy! how many people can you help at once? im like getting a university course here :)
17:38:13 <ski> np_hard : for the record, we're not discussing haskell here right now. so don't be scared ! :)
17:38:37 <ski> cmoline : yes, at least i should try to welcome the person, yes ?
17:38:47 <cmoline> of course!
17:38:59 <np_hard> Hello!
17:39:05 <np_hard> I am just going to lurk for a bit
17:39:06 <cmoline> i have no problem with you helping others!
17:39:11 <cmoline> hey np_hard
17:39:19 <cmoline> cool
17:39:24 <np_hard> Anyone got any good ways to use Haskell in corporate IT under the radar? :)
17:39:30 <cmoline> ski is trying to explain something to me
17:39:42 <ski> np_hard : ok. do know though, that we are currently discussing some not-so-simple things :)
17:40:12 <ski> np_hard : "under radar" ?
17:40:27 <cmoline> without official approval :)
17:40:53 <ski> well, i'm not sure what he would like
17:41:01 <np_hard> well
17:41:17 <ski> (or she, which also could be, of course :)
17:41:20 <np_hard> obviously it is not going to get the signoff from the architecture steering group
17:41:30 <np_hard> but a lot of things aren't specifically in there
17:41:33 <np_hard> bash, for example
17:41:40 <np_hard> perl even
17:41:47 <ski> in where ?
17:41:55 <ski> and what's "it" ?
17:42:03 <np_hard> in the "these are the technologies approved for use" list!
17:42:13 <np_hard> there are many technologies in use not on that list
17:42:14 <ski> ah, ok
17:42:19 <np_hard> but they are things like bash and perl
17:42:20 <ski> yes
17:42:26 <Riastradh> cmoline, I hate to interrupt, but just in case this exceedingly low-level explanation isn't really making much sense to you: http://www.bloodandcoffee.net/campbell/txt/continuation-tutorial.log (yeah, it's in Scheme, but it has only minor syntactic differences for the purposes of that log)
17:42:27 <np_hard> pretty hard to avoid with Linux servers
17:42:57 <cmoline> hey i love scheme! now if only it was purely functional :)
17:43:15 <Riastradh> cmoline, you can use it purely functionally...
17:43:21 <cmoline> yeah i know
17:44:01 <ski> cmoline : well, one of the points of this, admittedly, low-level exposition was to show the non-returnness of continuations
17:44:16 <ski> you just jump away somewhere
17:44:18 <cmoline> yeah, i know continuations dont return
17:44:35 <cmoline> thats why i said we were in a "different place"
17:44:54 <cmoline> sorry for not being clear
17:45:09 <ski> and a function "a -> b" could be though of as implemented by "Not (a,Not b)", i.e. by non-returning-continuations 
17:45:19 <cmoline> yep
17:45:24 <ski> "different place" ?
17:46:19 <cmoline> well like jumping. first you are at one address and then you jump to a different one. "different place" == "different address"
17:46:27 <ski> yes, ok
17:47:19 <ski> there actually isn't very much lowlevel in the type "Not (a,Not b)", except that we are talking bare addresses here, and not closures
17:47:57 <ski> cmoline : btw, do you know some propositional or boolean logic ?
17:48:42 <cmoline> i know a little bit of logic.
17:49:21 <ski> then, perhaps you know that "not (a and not b)" is equivalent to "a implies b" ?
17:49:47 <ski> it's quite easy to see, using a truth-table
17:50:38 <ski> Riastradh : thanks for the link, anyway
17:50:47 <cmoline> yeah, my logic book had me do exercises on these things. i need a refresher but i see what youre saying
17:51:26 <ski> there is a connection between this in logic, and the types we worked out before
17:51:44 <ski> i just though i should mention it
17:52:18 <ski> ok ?
17:52:19 <Riastradh> http://www.bloodandcoffee.net/campbell/txt/shift-reset-tutorial.log may also be of interest, thoough it probably ought to be redone.
17:52:45 <ski> Riastradh : thanks
17:53:21 <cmoline> cool. ill have to read that later
17:53:22 <Riastradh> http://www.common-lisp.net/paste/display/116 has a very neat SHIFT & RESET example.
17:53:49 <cmoline> i should prolly keep a log of this conversation too so others can benefit from reading it
17:54:22 <ski> cmoline : clog logs it
17:54:28 <cmoline> ok. cool
17:54:41 <ski> (at least if it's here now. is it ?)
17:55:02 <ski> well
17:55:04 <cmoline> looks like it
17:55:32 <ski> anyway, if one really want, one could think of the type "Not a" as equivalent to "a -> Absurd"
17:55:37 <ski> i.e. a function
17:55:59 <ski> it's just that the type Absurd is defined to have *no* values
17:56:30 <cmoline> cause it models continuations which never return?
17:56:32 <ski> (i.e. it's *not* like e.g. void C or C++ or Java, which *does* have a value)
17:56:37 <ski> yes
17:57:08 <cmoline> ok. im not too sure i see what this has to do with the logic
17:57:21 <ski> because the type Absurd has no value, it wouldn't be type correct to try to return (because them we'd have to return a value of type Absurd)
17:57:35 <cmoline> ok
17:58:08 * ski thinks void in C, C++, Jave should really be called unit or something like that
17:58:30 <ski> ok
17:58:43 <cmoline> right cause its like identity? thats what unit is?
17:59:17 <ski> it's a bit like True in logic, if that's what you mean..
17:59:33 <ski> (and Absurd is False)
18:00:02 <ski> the unit type in haskell is written  "()"
18:00:14 <ski> in ML it is written "unit"
18:00:56 <cmoline> or null
18:01:25 <ski> sorry ?  what could be written "null" ?
18:01:30 <Yosomono> morning
18:01:39 <ski> Yosomono : good night
18:02:00 <Yosomono> ski: very well then, "generic non-time-referential greeting fellow terran"
18:02:15 <cmoline> sorry i think ive confused myself with c here.
18:02:40 <cmoline> i mean null in the sense of being the empty value
18:02:45 <ski> Yosomono : no, i didn't complain. you can well use the time-zone you're in, at the moment :)
18:03:24 <ski> well, i think you agree that void takes 0 bits of memory
18:03:31 <cmoline> ol
18:03:33 <Yosomono> So after two days of shapr's incessant goading, I gave in and made my first haskell program.
18:03:34 <cmoline> k
18:03:41 <Yosomono> Anyone wanna assist me in something?
18:03:50 <ski> Yosomono : what ?
18:03:55 <cmoline> cool. what was it? did you have fun writing it?
18:04:04 <Yosomono> ski: I don't appear to comprehend the scope of exceptions
18:04:19 <Yosomono> cmoline: It's a commandline google "I'm Feeling Lucky" query thing.
18:04:31 <cmoline> cool
18:04:33 <Yosomono> cmoline: You give it a keyword and it asks google for the first result it gets.
18:04:38 <ski> Yosomono : it's called "dynamic scope"
18:04:52 <cmoline> yeah i can see what it does
18:05:10 <Yosomono> ski: I'm unfortunately used to exceptions continuing "up" until they get handled
18:05:16 <Yosomono> ski: which does not seem to occur
18:05:25 <ski> in haskell, you mean ?
18:05:33 <Yosomono> Not necessarily, but in my code at least ;)
18:05:44 <Yosomono> It could be that what I'm encountering is not specifically a catchable exception.
18:05:57 <Yosomono> I've only been looking at haskell for two days...;)
18:06:33 <ski> what do you mean by "continuing "up"" ?  or not "continuing "up"" for that matter ?
18:06:56 <Yosomono> ski: Well I wrapped a function call in a catch and the failure was not "caught"
18:07:14 <ski> in the IO monad ?
18:07:31 <cmoline> ski: oh ok. so void is false. void can be represented in zero. therefore, false can be represented in zero bits. and zero bits would be represented by a function that never returns
18:07:34 <Yosomono> I'm not entirely certain where the IO ends and the rest begins, frankly :P
18:07:45 <ski> cmoline : no :)
18:07:50 <cmoline> bummer
18:08:13 <ski> cmoline : imagine that int had 8 bit. then it would have 256 values, right ?
18:08:41 <ski> Yosomono : ok
18:09:04 <Yosomono> ski: I've got the result of some IO and I throw it into a function which strips a piece out and returns that.
18:09:06 <cmoline> yeah. so zero bit would have no values. a function that never returns has no value. so a function that never returns is zero bits
18:09:18 <cmoline> closer?
18:09:30 <Yosomono> ski: the function can fail through exhausting possible pattern matches
18:09:32 <ski> cmoline : not much :)
18:09:37 <Yosomono> ski: I'm not certain how to *stop* that gracefully.
18:09:40 <ski> cmoline : you're thinking too fast
18:09:43 <cmoline> bummer again :)
18:10:42 <ski> Yosomono : well, if it can be stopped, it must be in the IO monad  (for the nondeterminism of which exception is actually thrown, if many would be possible)
18:11:15 <ski> cmoline : c'mon :)  2^8 = 256 right ?  i.e. log_2 256 = 8  yes ?
18:11:31 <cmoline> ok
18:11:34 <Yosomono> ski: Well, can you think of a more graceful way to stop a recursive breakdown pattern match?
18:11:36 <Darius> Yosomono: Standard Haskell is rather poor about exceptions.
18:11:49 <ski> cmoline : that was for 8 bits. now do the same for 0 bits :)
18:11:59 <Yosomono> ski: where if something matches, it returns a value, but if there is no match, it re-calls the function with a remainder portion of the input?
18:12:00 <Darius> Yosomono: I'm pretty sure you can't catch pattern match failures in Haskell 98.  There is a GHC extension that will let you.
18:12:04 <np_hard> exceptions are exceptional!
18:12:12 <Yosomono> Darius: Well that sucks.
18:12:33 <np_hard> hm
18:12:38 <ski> Yosomono : well, you could perhaps add a "catch-all"-case to the functions which currently can pattern-match-fail
18:12:48 <Darius> Another technique is to return Either ErrMsg Value.  Which can be extended to simulate exceptions.
18:13:00 <np_hard> couldn't you avoid that by explicitly specifying narrow types for functions that do pattern matching?
18:13:08 <ski> np_hard : yes :)
18:13:40 <Darius> Yosomono: Yes it does suck, though it likely won't survive into Haskell 2.
18:13:42 <ski> np_hard : that's not always possible
18:14:07 <Yosomono> I had tried using bot and _ but it seems in pattern matching they overlap, which doesn't help/.
18:14:16 <cmoline> shoot! i dont really know logarithms. its been years since ive been in school. so im going to guess a bit here. 2^0 is 1 so log 2 1 must be zero?
18:14:21 <ski> cmoline : shall i give it to you ?
18:14:26 <cmoline> please
18:14:27 <ski> yes
18:14:28 <cmoline> :)
18:14:47 <ski> i.e. "void" in C, C++, Java has *1* value
18:15:15 <ski> (so it is really similar to () in haskell or unit in ML)
18:15:17 <cmoline> oh ok. so thats why its unit. its the type with just one value?
18:15:23 <ski> yes
18:15:36 <np_hard> does Haskell: TNG have a set timeline for coming to fruition?
18:15:48 <Yosomono> Ah well, guess I'll have to settle for my code freaking out if it gets an invalid response.
18:15:53 <cmoline> as soon as you implement it :)
18:15:53 <ski> it's also a left and right "unit" to pair
18:16:04 <Yosomono> THankfully that should never happen, but I always like to prepare for worst-case scenarios.
18:16:09 <ski> Yosomono : you could try using Maybe or Either
18:16:26 <cmoline> yeah thats more the haskell way
18:16:34 <ski> Yosomono : aha, so if it happens, it is internal error, then ?
18:16:44 <cmoline> i dont think ive ever used exceptions in my code, though maybe i should
18:17:07 <ski> Yosomono : (or input data hasn't been checked to conform to something)
18:17:11 <Yosomono> ski: It should almost never happen, but is not impossible.
18:17:19 <Darius> np_hard: Not to my knowledge.
18:17:28 <Riastradh> Yosomono, if pattern match failure occurs, it's a bug in your program, not just an exceptional condition in your program's execution.
18:17:37 <Yosomono> ski: I'm not familiar with the use of Maybe or Either, is there a page on them?
18:17:55 <Riastradh> data Maybe a = Just a | Nothing; data Either a b = Left a | Right b
18:18:09 <Yosomono> Riastradh: I was hoping for something a bit more productive than "your code is wrong"
18:18:10 * ski looks at Darius and the others ..
18:18:33 <Yosomono> I've been reading about this for two days, it should be taken for granted that everything I write is wrong.
18:18:34 <ski> Yosomono : but perhaps it isn't wrong ..
18:18:47 * cmoline wonders why ski is looking at darius and the others
18:18:48 <Riastradh> Yosomono, that's why people write test suites.
18:19:18 <ski> cmoline : well, i haven't looked much at the haskell tutorials
18:19:58 <Yosomono> Well, I'm sure I'll figure it out then..
18:20:29 <ski> cmoline : if you like, you could try to imagine how many bit a value of the Absurd type (the type *without* values) would occupy, just for fun :)
18:21:41 <ski> cmoline : that'd be log_2 of what ?
18:21:54 <cmoline> zero
18:21:58 <ski> right ;)
18:22:07 <ski> do you know what that is ?
18:22:17 <ski> (s/is/"is"/)
18:22:20 <cmoline> isnt that undefined or infinity or something?
18:22:40 * cmoline needs to get a book on basic maths
18:22:58 <cmoline> instead of fancy category theory :)
18:23:02 <ski> if x goes towards 0
18:23:14 <ski> then log_2 x goes towards minus infinity :)
18:23:22 <cmoline> oh right its a limit 
18:23:36 <cmoline> ?
18:24:20 <ski> no wonder why it's absurd ! if we had a value of that type we could store as many other things we'd like in whatever number of bits we'd like :)
18:25:03 <cmoline> thatd be cool. no need to get a bigger hard drive
18:25:09 <ski> hehe
18:25:15 <cmoline> great for ram too :)
18:25:43 <ski> this is of course not quite firm reasoning, but quite fun to think of, anyway :)
18:25:59 <cmoline> of course :)
18:27:23 <ski> Yosomono : if you care to, i guess you could put up the code somewhere, so we can have a look at it. but perhaps not just right now ..
18:27:47 <ski> cmoline : you see ? continuations are fun to think of :)
18:28:11 <cmoline> oh hey i think i get your double periods. that last period is terminating the whole message
18:28:26 <cmoline> agreed :)
18:28:28 <ski> is it ?
18:28:38 <ski> i didn't know                                                 :)
18:30:57 <Yosomono> ski: That's quite alright, I've managed to come up with solutions to problems on my own so far, I'm sure I'll be fine.
18:30:59 <ski> i though they were, kinda, like a message : "i could perhaps continue/say more here" or a sort of textual representation of a sort of perhaps-not-quite-finished sentence
18:31:11 <ski> Yosomono : ok
18:32:08 <cmoline> it doesnt seem that way to me. periods terminate things.
18:32:17 <cmoline> perhaps an ellipsis?
18:32:21 <cmoline> ...
18:32:25 <ski> does "..." terminate things ?
18:32:35 <cmoline> or perhaps [...?]
18:32:41 <ski> a half-way ellipsis, perchance ?
18:33:15 <cmoline> or maybe even, "la, la, la. (hmm, could i say more?)"
18:33:21 <ski> yeah
18:33:44 <ski> i guess it could be interpreted in a number of ways
18:33:46 <cmoline> though i bet you want something shorter
18:33:57 <ski> perhaps
18:34:28 <Riastradh> Or perhaps you're just a grammatically terrible typist.
18:34:30 <cmoline> the period just doesnt suggest to me the idea that a message might be potentially unfinished
18:35:00 <ski> Riastradh : now *that* could be the real reason. i can see it before me :)
18:35:02 <cmoline> i used to double all my !' and ?'s
18:35:20 <ski> i do that sometimes too
18:35:21 <cmoline> i dont know why. i thought it was cool i guess. i am glad i stopped
18:35:33 <ski> or use things like "!?!" or "?!?"
18:35:54 <ski> a kind of mixture between exclamation and question
18:36:01 <cmoline> i usually use ?! for that 
18:36:07 <cmoline> or !?
18:36:42 <cmoline> yeah its an excited question
18:36:49 <ski> i think i use "?!?" and "!?!" for when one or the other is "in the majority"
18:37:21 <ski> so it expressed degrees between the border cases
18:37:39 <cmoline> that might come in handy, though i think i am satisfied with indicating that its both excited and a question
18:38:10 <cmoline> commas
18:38:18 <cmoline> i still havent got the hang of them
18:38:41 <ski> (it could be that i don't use !? or ?! so often because i have a hard time choosing which. they are not symmetric (on their own))
18:38:42 <cmoline> and capital letters. who needs them? they seem to me to serve no purpose whatsoever
18:38:51 <ski> what ?
18:39:01 <cmoline> use whatever you think works best
18:39:13 <cmoline> what what?
18:39:14 <ski> my commas ?  or just everyone's commas ?
18:39:28 <cmoline> oh no, i mean my commas
18:39:34 <ski> ah, ok
18:40:02 <ski> well, i usually try to use capitals in emails and usenet posts and such
18:40:04 <cmoline> sometimes i get the feeling theres supposed to be a comma somewhere yet i can see no logical reason for one.
18:40:12 <ski> same here
18:40:28 <cmoline> this happens alot around words like "but"
18:40:29 <ski> i'm not at all always sure where commas should be
18:40:32 <ski> mm
18:40:55 <liralen> cmoline - you can always comfort yourself with noticing "alot", though.
18:41:16 <ski> vorpal : is the name from Dungeon Master ?   :)
18:41:41 <ski> vorpal : and btw, hi !
18:41:43 <cmoline> that bugs you? i dont see what difference it makes whether you write "alot" or "a lot"
18:41:54 <liralen> cmo - do you write "alittle"?
18:41:58 <cmoline> no
18:42:06 <cmoline> but alot is pretty common
18:42:18 <cmoline> common enough to be acceptable i think
18:42:25 <ski> isn't there a verb that sounds similar ?
18:42:28 <ski> "allot" ?
18:42:30 <vorpal> hi ski
18:42:47 <cmoline> yeah. means to portion or something similar to that
18:42:56 <liralen> cmo - only in the same contexts where people find 'lol' and 'lolollololol' common enough to have acceptability.
18:42:57 <ski> vorpal : do you know where your name "vorpal" comes from ?
18:43:10 <vorpal> through the looking glass
18:43:14 <vorpal> lewis carroll
18:43:22 <cmoline> hey i like that abreviation
18:43:29 <cmoline> shit i need a spell checker
18:43:30 <ski> vorpal : aha, didn't know that
18:43:30 <liralen> cmo - but if that fairly blatant error doesn't bother you, no need to get picky about commas -- just put one wherever you'd pause in actual speech.
18:43:38 <ski> vorpal : what does it mean, there ?
18:43:45 <cmoline> er, oops. does swearing bother you folks?
18:44:16 <Riastradh> He took his vorpal sword in hand, / Long time the manxome foe he sought; / So rested he by the tum-tum tree / And stood a while in thought.
18:44:22 <ski> cmo : perhaps depends on the foul word :)
18:44:34 <Darius> cmoline: There are actually some fairly young people here.  That said, if they are like youths of America that I've seen, they already swear to no end.
18:44:42 <ski> Riastradh : is that from lewis carroll ?
18:44:46 <cmo> yep thats me
18:44:48 <Riastradh> ski, uh, yes.
18:45:00 <liralen> cmo - don't say 'fuck you' unless you intend to leave immediately in a huff, though =)
18:45:03 <cmo> though i try not to swear so much around people that dont like it
18:45:10 <Riastradh> Darius, how young?
18:45:17 <ski> cmoline : actually i almost never swear
18:45:27 <ski> Riastradh : interesting ...
18:46:02 <ski> cmo : i haven't even noticed that you have sworn ..
18:46:13 <cmo> amongst me and my friends swearing and being very frank (some would say crude) is the norm
18:46:36 <ski> ok
18:46:44 <cmo> yeah thats cause im trying to be polite :)
18:46:54 <ski> aha :)
18:47:45 <ski> well i personally usually don't care so much, but i dunno if others here might do
18:48:08 <cmo> well ill try not to swear anyways
18:48:21 <cmo> swearing doesnt really add anything to the message
18:49:04 <ski> vorpal : the reason i asked, was that in the old game "Dungeon Master", there are a kind of sword called "Vorpal Blade", It's black and "wavy", and can harm non-material beings
18:49:14 <cmo> actually you know i think i prefer my name the other way. though you can still call me cmo
18:49:35 <ski> was "line" a swear-word ?
18:49:53 <cmoline> why would line be a swear word?
18:49:58 <ski> i dunno
18:50:05 <cmoline> :)
18:50:22 <ski> why did you change nick back and forth while talking about swearing ?
18:50:24 <ski> :)
18:50:57 <ski> vorpal : i take you haven't got any haskell questions at the moment
18:50:58 <cmoline> oh cause liralen started calling me cmo and i liked the abbrev.
18:51:06 <cmoline> but then i changed my mind
18:51:09 <cmoline> sorry :)
18:51:16 <ski> aha
18:51:24 <ski> no prob
18:51:40 <vorpal> ski, i could work some up :)
18:52:00 <ski> :) ;) :-) ;-) :))
18:52:15 <ski> (just fooling around)
18:52:17 <cmoline> yeah ive come to believe that every conversation is an exercise in misunderstaning :)
18:52:41 <vorpal> are there named-parameters to functions in haskell?  if not why the hell not?
18:52:42 <Cale> @:)  <--- the superfluous-third-ear-on-the-forehead.
18:52:59 <cmoline> Cale: lol
18:53:09 <ski> vorpal : "all functions take one argument"
18:53:20 <ski> hah
18:53:22 <cmoline> vorpal: you mean like common lisp or smalltalk? if so i totally agree
18:53:42 <cmoline> i am trying to learn parsing so i can write a preprocessor that will do that
18:53:45 <ski> or O'Caml
18:54:19 <vorpal> the order of the parameters imposes a constraint on how you can curry functions
18:54:35 <cmoline> hey ski can i run an idea past you? i dont know if its bullshit or not
18:55:07 <liralen> cmo - "it's", too.
18:55:14 <ski> why not ?
18:55:14 <Cale> you can always lambda away those problems, though I'll admit it's a little inconvenient.
18:55:26 <liralen> cmo - a very very bad grammatical error =)  Much worse than commas.
18:55:44 <ski> liralen : i try to make amends for that kind of thing
18:55:45 <cmoline> yeah apotrophes suck. theyre not really needed to indicate common contractions like theyre, and dont
18:56:01 <cmoline> though i admit well can be confusing at times
18:56:06 <Cale> whyusepunctuationorspacesatall?
18:56:11 <Cale> heh
18:56:14 <ski> liralen : but i know i still err, at times
18:56:20 <Cale> whyusepunctuationorspacesatallrather
18:56:40 <liralen> Cale - for the same reason that we invented it, to make the meaning of written language easier for the reader to grasp.
18:56:49 <ski> Cale:hardertoparseand seewhereeachwordbeginsandends
18:56:50 <cmoline> coolidea.ithinkancienthebrewwaslikethat.didnthavevowels.thoughimightbemistaken :)
18:57:04 <Cale> itssomucheasiertoreadwhenitsallsmashedtogetherinlongstringslikethis
18:57:10 <liralen> cmo - modern Hebrew, also, lacks 'vowels'.
18:57:24 <ski> cmoline : but they *are* needed in that case
18:57:38 <cmoline> ski: it just takes practise. i can read leet speak pretty easy now (though not as fast as when written nicely)
18:57:51 <ski> cmoline : "it's" = "it is"   while "its" is genitive of "it"
18:57:57 <liralen> Cale - only among people as adept at you at reading such simple sentences.  You can't write a book that way.  You can't communicate to a non-native speaker as easily, that way.
18:58:15 <Cale> heh - I'm being sarcastic, obviously.
18:58:53 <cmoline> ski: thats true. but i think context is enough to disambiguate it
18:59:27 <cmoline> liralen: thats very insightful
18:59:31 <ski> it's still type^H^H^H^Hsyntactic category error
19:00:06 <ski> (or should it be semantic, perchance ?)
19:01:38 <cmoline> but words can mean different things in different contexts
19:01:51 <ski> that's a problem, too
19:01:59 <cmoline> so why not have one that functions both as a contraction and as a possesive thingy
19:02:21 <Cale> act. ua'lly It hink tha... tpu nctu at-ion a n'dspaci ng sh o-ul d b, e enti-rel yran do!m
19:03:13 <ski> Cale : yuck !
19:03:23 <cmoline> Cale: it would be interesting to write an obfuscated book
19:03:31 <Darius> Go go neural net!
19:03:33 <cmoline> kind of like esoteric programming
19:04:35 * Darius was going to not bother with the "Understanding Monads" thread. *sigh*
19:04:40 <cmoline> its cool hey? how we can accept such noise in our statements. i wish programming languages could handle such noise as easy
19:04:45 <Darius> Oh well, I didn't expect that to last anyways.
19:05:04 <liralen> cmo - "it's", again, but I'll stop reminding you.
19:05:10 <Cale> i tma k es i'tea sier to-go-ba ck an'dre rea-d th' ings y ouw... rotei n't he pas t-sin ceyo-u ca-nrem'emb'e... rby  th' e'for mattin gwha t'yo uwer ewriti.ng
19:05:39 <cmoline> Cale: yeah. i think thats why i can read my handwriting and noone else can
19:05:40 <Cale> ri g?t
19:05:54 <liralen> Cale - I hope you wrote a program to do that, at least =)
19:06:30 * ski sometimes can't read his handwriting
19:06:31 <liralen> cale - hm, but you seem to lean on - and ' quite a bit, which suggests manual typing on a qwerty layout.
19:06:32 <Cale> n -oij- us tty.p-edit
19:06:51 <Darius> liralen: wh yw.he it's soe,a..sy
19:07:23 <liralen> Darius - ooh, typo.
19:07:28 <Psuedonym> Darius: Watch your language!
19:07:53 <cmoline> liralen: i dont want to start a flame war here :), but does it really make my writing so hard to read?
19:08:57 <Darius> liralen: Just because you don't contextually read spaces as 'n's is no reason to say I have made a typo.
19:09:01 <cmoline> did i kill the conversation?
19:09:25 <liralen> cmo - it suggests to me that you don't care about the people that read what you write, and does so fairly immediately, so I get annoyed fairly quickly.  But don't mind me, I said that I'd stop correcting you.
19:09:33 <ski> cmoline : dunno
19:10:09 <liralen> Darius - why does that space turn into an 'n' when the first space doesn't?  Or did you allow spaces to stand for either spaces or 'n's as appropriate?
19:10:34 <liralen> What I think of the logical extension of that design:            =)
19:13:29 <cmoline> say ski, i was wondering would "anonymous unions" be a useful addition to haskell?
19:13:53 <ski> "lightweight sums" ?
19:14:07 <ski> like O'Caml have ?
19:14:15 <cmoline> ie  {integer, float, foo} is exactly the same as data fibbly = hibbly integer | hobbly float | fibbly foo
19:14:33 <cmoline> except the compiler automatically generates the type definition for you
19:14:52 <cmoline> im not really familiar with ocaml.
19:15:01 <cmoline> i know a little of it but not much
19:15:01 <ski> how should it invent the names : hibbly, hobbly and fibbly ?
19:15:23 <cmoline> they would just be randomly generated
19:15:37 <liralen> er, no.
19:15:44 <ski> wouldn't it be better with something like
19:16:06 <ski> {hibbly :: Integer,hobbly :: Float, fibbly :: Foo}
19:16:07 <ski> then ?
19:16:09 <liralen> data Person = {name String, age Int}
19:16:20 <cmoline> so for example you could have a type like flub :: Int -> {Integer, Float}
19:16:22 <liralen> or ::, I suppose.
19:16:22 <ski> s/data/type/
19:16:35 <Darius> liralen: I said "contextually"
19:16:40 <cmoline> its a convienience feature
19:16:56 <ski> cmoline if you just want to return an integer and a float, why not use tuples (in this case pair) ?
19:17:10 <ski> flub :: Int -> (Integer,Float)
19:17:15 <cmoline> not integer and a float. integer *or* a float
19:17:22 <ski> oh
19:17:22 <ski> :)
19:17:28 <ski> forgot that
19:17:42 <ski> flub :: Int -> Either Integer Float
19:18:23 <ski> do you think there is a problem with that (for what you want) ?
19:19:12 <cmoline> well for example say i was writing a gui
19:19:21 <cmoline> widgets have different properties
19:19:32 <cmoline> some of these properties take strings
19:19:39 <ski> ok
19:19:40 <cmoline> or hey better yet records
19:19:48 <cmoline> sets of name value pairts
19:20:25 <cmoline> i dont want [(string, integer)]. i want [(string, {integer, string, foo})]
19:20:32 <cmoline> do you see what i mean?
19:20:38 <ski> hmm
19:21:04 <ski> and you specifically don't want to name the 3 variants ?
19:21:15 <cmoline> the type of the value that is being returned depends on whats passed in as the key
19:22:05 <cmoline> i dont want the hassle of having to create constructors that "carry" the values i want
19:22:18 <cmoline> to go back to my widget example
19:22:34 <cmoline> we have several properties and each is of a different type
19:22:40 <ski> so this is isoprphic to using a type   data Bleh = AnInteger Integer | AString String | AFoo Foo   except you don't want to defined this type *and* don't want to come up with names for the variants ?
19:23:05 <ski> you could look a little at http://caml.inria.fr/ocaml/htmlman/manual006.html#htoc40
19:24:05 <cmoline> yeah i dont want to have to think up a name for the type and i dont want to have to create constructors for that type whose sole purpose is to satisfy the haskell type system. thats tedious and boring
19:24:26 <ski> with "polymorphic variants" you don't need to give a name for the type (so it's anonymous, or lightweight) but you still have names for the variants  (which seems hard to avoid)
19:24:39 <ski> well
19:25:15 <cmoline> i was thinking we could avoid the need for constructors by allowing type annotations in pattern matching
19:25:18 <cmoline> for example
19:25:19 <ski> i presume that you don't like "to create constructors" (in this case), because you cannot use the same constructors in another type, yes ?
19:25:38 <cmoline> foo :: {Integer, Float} -> Bool
19:25:47 <ski> well ?
19:25:48 <cmoline> foo (a :: Integer) = True
19:25:54 <cmoline> foo (a :: Float) = False
19:26:11 <ski> also what about  foo :: {Integer,Integer} -> Bool  ?  disallowed ?
19:26:39 <cmoline> it would be redundant
19:26:46 <cmoline> think of it as a set
19:26:55 <cmoline> of types
19:27:02 <ski> what do you think of my prevous question ?   (the "i presume that ..." one)
19:27:24 <cmoline> i need a second to phrase my response
19:27:31 <ski> sure
19:28:52 <cmoline> ok so imagine, for whatever reason, youre trying to create a function that could return an integer or a float
19:28:59 <ski> yes
19:30:15 <cmoline> to do this in haskell 98 you cant just return an integer or a float. you have to go through an extra step of creating a type and then creating constructors to "carry" the various types i want to return.
19:30:25 <ski> yes
19:30:47 <cmoline> ie instead of foo :: Blah -> {Integer, Float} i have to go
19:31:02 <ski> but with lightweight/polymorphic variants you don't have to create the type !  just use the constructors directly !
19:31:16 <liralen> data foo = Blah Integer Float
19:31:27 <liralen> voila.
19:31:27 <cmoline> data ThinkUpSomeAbitraryNameThatWontConflictWithAnyting = ArbitraryConstructor1 Integer | ArbConst2 Float
19:31:35 <ski> liralen : he was doing variants, not records
19:32:17 <cmoline> am i being more clear?
19:32:26 <Riastradh> Or you can use CPS!
19:32:29 <ski> cmoline : it seems to me, that, indeed, you are complaing about name clashes and namespaces, right ?
19:32:41 <cmoline> no
19:32:42 <liralen> cmo - I want to believe that you have merely trolled for over an hour and a half, but nevermind.
19:32:47 <ski> cmoline : so try polymorphic variants
19:32:54 <cmoline> liralen: sorry :)
19:33:02 <cmoline> sure i will look at them
19:34:21 <ski> cmoline : there is also a concept "lightweight records", of record types that doesn't have to be defined in a type declaration, but just used
19:34:40 <cmoline> maybe my example would be more clear if i changed the name of my name frmo ThinkUpSomeAbitraryNameThatWontConflictWithAnyting to ArbitraryTypeIHaveToCreateBecauseIWantToReturnValuesOfDifferentTypes
19:34:50 <ski> cmoline : note though, that this gives you structual equivalence, instead of "name" equivalence  (IIRC)
19:35:00 <Riastradh> cmoline, just use CPS.
19:35:25 <ski> yes, CPS is a possibility, too
19:35:38 <cmoline> Riastradh: are you willing to explain a bit how this works? i know a little about cps but not much
19:35:52 <lambdabot> Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv!
19:36:17 <ski> flub :: Int -> (Integer -> o) -> (Float -> o) -> o
19:36:34 <ski> lambdabot: Ni
19:36:34 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:37:05 <Riastradh> flub input integerK floatK = ...<'return' an Integer> integerK result...<'return' a Float> floatK result...
19:37:51 <cmoline> oh i see
19:38:00 <cmoline> of course its the obvious thing
19:38:02 <Riastradh> Did you read continuation-tutorial.log?
19:39:15 <cmoline> in a sense i am passing two functions in with my value and then depending on the results of my processing i pass the value to the appropriate function
19:39:29 <cmoline> something like that?
19:39:34 <ski> yes
19:39:58 <ski> two alternate continuations
19:40:55 <cmoline> ah yes. that could work. i would like a list though so i could pass varying numbers. i dont think ill be able to do this. will i?
19:41:13 <cmoline> how would i determine which fun takes which type?
19:41:24 <ski> (Integer -> Absurd) -> (Float -> Absurd) -> Absurd  ~=  Not Integer -> Not Float -> Absurd  ~=  (Not Integer,Not Float) -> Absurd  ~=  Not (Not Integer,Not Float)  ~=  Either Integer Float   :)
19:41:44 <cmoline> and the haskell type system wont allow me to create a list of functions of varying types
19:41:52 <ski> varying numbers of what ?
19:42:03 <cmoline> of continuations
19:42:15 <ski> yes, but in what way ?
19:42:19 <cmoline> for example my widgets
19:43:19 <Riastradh> You could use [[f :: X -> Y -> [(forall t. t, Ans)] -> Ans]], but I don't think that would work very well.
19:43:28 <cmoline> they have a whole bunch of properties of different types. i would like a fun that takes a key and could potentially return any of the types that the properties have
19:43:38 <ski> what would determine how many arguments the function should accept ?
19:43:43 <cmoline> so i could like look up properties
19:44:04 <cmoline> i think a convention of one argument would work
19:44:09 <Riastradh> If you have a particular class of which each of the types in question is an instance, you could use [[f :: X -> Y -> [(forall t. Class t => t, Ans)] -> Ans]].
19:44:18 <ski> cmoline : perhaps you want dependent types :)
19:44:47 <SamB> ski: dependant types don't do what he seems to want, really
19:45:04 <cmoline> i have heard of those but ive never looked at them
19:45:09 <cmoline> maybe i should
19:45:16 <cmoline> actually i think i will
19:45:17 <ski> SamB : not even if we have an env for the types, also ?  ...
19:46:14 <SamB> or maybe I forgot what dependant types are
19:46:40 <ski> SamB : perhaps something like   lookup :: (x :: a) -> (env :: Env) -> tLookup x env
19:47:07 <ski> SamB : with   tLookup :: a -> Env -> *
19:47:45 <ski> SamB : or, um, probably Env should be parameterized by the 'key type' a
19:48:32 <cmoline> i should look up rank 2 polymorphism too
19:48:42 <ski> :)
19:49:47 <cmoline> oh no. gah. i have to leave now. cyall later
19:50:00 <ski> ok
19:50:05 <ski> bye, cmoline
19:53:18 <ski> already back :)
19:53:27 <cmoline> ok. i should be going but i just thought of something
19:53:32 <ski> sure
19:53:56 <cmoline> i dont need a list of continuations. if i want three types i just pass in three functions, and so on
19:54:05 <cmoline> duh
19:54:06 <ski> yes
19:54:16 <cmoline> i can be a bit slow to catch on at times
19:54:24 <ski> that's what i thought would suffice for your demands
19:54:39 <ski> most of us can be
19:54:47 <ski> i know i can
19:55:02 <cmoline> but it still seems like a lot of typing. maybe some elisp in emacs could fix that
19:55:18 <ski> perchance
19:55:31 <cmoline> well anyways i have to go. cya again!
19:55:36 <ski> bye
20:12:27 <shapr> I'm awake!
20:12:40 <shapr> Pseudonym: I guess Psuedonym was your Pseudonym?
20:12:54 <shapr> isomer: g'day anth! how's med school?
20:13:03 <ski> shapr : you are ?                                             :)
20:13:27 <shapr> no, but I can pretend well.
20:13:29 <isomer> so far, it's all stress ... i'm waiting for an offer to get some interviews. how's things going with you?
20:13:43 <shapr> I'm self-employed. That's all stress too.
20:13:59 <isomer> :)
20:14:13 <shapr> we've been working for two weeks solid, 8+ hours a day
20:14:30 <isomer> i'm doing a gov't contract -- mind rotting, but well paying. i'm learning to hate java in ways i didn't think possible before
20:14:50 <shapr> I'm feeling slightly burned out, but I've put off my swedish homework to do work instead, and now I have class in 3.5 hours
20:14:57 <shapr> and I don't feel doing anything useful at all
20:15:10 <shapr> isomer: well paying is a nice thing
20:15:24 <shapr> truly, Java is hatable.
20:15:28 <isomer> yeah -- to both
20:15:36 <shapr> jython makes it more bearable, but only somewhat
20:16:10 <isomer> it's not "approved" for our use :(
20:16:18 <shapr> that sucks
20:22:12 <Pseudonym> I think Java isn't too bad, actually.
20:22:31 <Pseudonym> What I want is to write my "real" program in some other language, then use a CORBA or COM layer to write the GUI in Java.
20:23:10 <Pseudonym> Use Java as a think client (which is what it's best for, IMO).
20:23:17 <Pseudonym> s/think/thin/
20:24:46 <Pseudonym> shapr: Actually, Psuedonym was my alias' Nom de Guerre, AKA my incognito handle's pen name.
20:25:18 <Darius> Surely there are better languages for writing GUIs, so why even use Java for that?
20:25:43 <Pseudonym> I can't think of many which handle cross-platform GUI stuff better than Java.
20:25:57 <Pseudonym> In fact, I can't think of _any_.
20:26:08 <Pseudonym> Maybe the Mozilla platform, if you don't mind C++.
20:26:14 <shapr> the current high deployment + support of CORBA + existing GUI support in Java is its good points
20:26:28 <shapr> what about wxHaskell?
20:26:44 <Pseudonym> Never used it, but Haskell's CORBA support ain't great.
20:27:12 <Pseudonym> Not sure how I'd link it to my "real" app if Haskell were not the most appropriate language to write it in.
20:27:36 <Riastradh> Pseudonym, I do hope you're not suggesting using Swing.
20:27:51 <Pseudonym> Well I didn't suggest it. :-)
20:28:07 <Riastradh> Implying that you suggest it, then.
20:28:15 <shapr> what about http://www.xwt.org/ ? has anyone looked to see if those guys are sane?
20:28:23 <Pseudonym> Did you infer that I may have implied that I suggested it?
20:29:00 <shapr> I think java 1.4 or 1.5 or something got xml descriptions of GUIs, and I was thinking it would be cool to write an applet that accepted those xml descriptions from a server process
20:29:20 <Darius> I don't like what you people think you think the thinks you think.
20:29:20 <shapr> that way you can run the gui in a browser, and download the gui description from the server
20:29:38 <Darius> damn s/the/the other/
20:29:44 <shapr> %-)
20:30:16 * stepcut hopes to be intentionally self employed by the end of the year
20:30:29 <shapr> yay! self-employed is exciting.
20:30:42 <stepcut> so is paying bills
20:30:50 <shapr> yes, I agree.
20:31:30 <Pseudonym> Surely being extensionally self-employed is superior?
20:31:40 <stepcut> I got a professional soldering iron today!
20:32:09 <monotonom> extensionally, as opposed to intensionally? :)
20:32:39 <stepcut> Pseudonym: well, i might be existential self employeed already
20:32:50 <stepcut> existentially
20:33:53 <stepcut> CSS is horrible!
20:34:30 <Darius> Why?
20:35:57 <stepcut> too many simple things are impossible to do
20:36:05 <Darius> Like?
20:38:21 <stepcut> four column layouts?
20:38:37 <stepcut> maybe not impossible, but not simple
20:39:15 <stepcut> many problems can be hack around with absolute positioning
20:40:59 <Darius> Steal the work others have done: http://glish.com/css/8.asp
20:43:50 <stepcut> Darius: i usually do!
20:51:15 <stepcut> unfortunately the problem I have now is more complicated. I have a variable height single column, below that is a 3 column box, and under that is another single column. Because the top box is variable height, I can't use absolute positioning for the 3 column section
20:53:20 <Pseudonym> I hate those unprofessional soldering irons.  They half-do your wires and then skip the country.
20:53:51 <stepcut> Pseudonym: pretty much!
20:53:52 <Darius> Soldering is a whole lot easier with a decent iron.
20:54:22 <Darius> Did it send you a post card?
20:55:02 <stepcut> http://www.action-electronics.com/wewes50.htm
20:55:37 <Pseudonym> It sent me a photo of itself lazing on the beach in Nauru with my desoldering braid.
21:03:03 <stepcut> alright! I beat the CSS into submission.
21:09:17 <shapr> so, I'm googling for info on swedish interjections and rÃ¤kneord, and I find Haskell sources - http://129.16.225.78/aarne/GF/resource/types.Swe.html
21:09:19 <shapr> I am entertained.
21:09:38 <ski> :)
21:10:20 <ski> well
21:10:35 <ski> actually it isn't haskell, but GF (Grammatical Framework)
21:11:15 <ski> but some syntax i quite similar
21:11:17 <ski> is
21:11:23 <shapr> Isn't it written in Haskell, and does language specification in Haskell ?
21:11:45 <ski> well, it's verypossible that it is written in haskell, yes
21:12:00 <ski> "language specification in
21:12:03 <ski> +Haskel" ?
21:13:21 <ski> btw Aarne Ranta is the one who is giving the "compiler construction" course i'm taking ATM
21:14:59 <ski> IIRC GF has a dependent typesystem, and allows specification of both abstract and (possibly many) concrete syntaxes, for any object language  (though i think it was mostly intended for natural languages)
21:16:18 <ski> i find it quite interesting to read the files implementing (parts of) swedish, english, french and so on
21:20:34 * ski invokes MON OH IR RA
21:21:55 <shapr> I can't seem to find a list of swedish interjections on google.
21:22:15 <ski> mhmm
21:22:39 * ski doesn't know of any
21:22:52 <shapr> well, I can do it next week if I can't find anything.
21:23:12 <ski> you've got that in homework ?
21:23:27 <shapr> yup
21:23:37 <shapr> we each do a presentation on parts of speech
21:23:38 <ski> hm
21:23:44 <shapr> I was lucky enough to get interjections and numbers
21:23:55 <shapr> obviously the most fun you can have in a single word class :-)
21:24:30 <ski> well numbers can be interesting
21:24:42 <ski> and interjections is quite diverse
21:25:27 * ski wonders how a numerus for zero would look like
21:26:41 * ski casts YA BRO DAIN into empty flask, gives potion to shapr
21:49:47 * shapr mistakes kvarskatt for kvar katt
21:50:02 <shapr> bye naren
21:50:04 <ski> shapr : oops
21:50:13 <shapr> kvars-katt :-)
21:50:18 <shapr> hello naren
21:50:27 <naren> hi shapr.
21:50:32 <naren> hello everyone
21:50:36 <ski> hi naren
21:51:07 <shapr> kvar skatt = back taxes, but kvar katt = left over kitty
21:51:14 * shapr laughs
21:51:21 <shapr> naren: looking for Haskell info?
21:51:45 <ski> inte alltid lätt, detta
21:52:10 <naren> shapr nothing in particular... Still learing haskell..
21:52:20 <ski> course ?
21:53:04 <shapr> I'm beginning to understand how much humor skrivihop can make.
21:53:58 <ski> shapr : skrivihop ?
21:54:24 <ski> andersca : mja, jag ska nog snart gå hem och lägga mig :)
21:54:31 <shapr> Marvin-- told me about a website called skrivihop or something like that
21:54:40 <ski> aha
21:54:42 <shapr> it's about how one space can make a big difference in swedish words 
21:55:03 <shapr> like "rÃ¶kfri" and "rÃ¶k fri" mean "smoke free" and "smoke freely"
21:55:11 <ski> "sär skrivning" ?
21:55:19 <shapr> yes, that's the word
21:55:53 <LordKinbo> hello people
21:56:00 <shapr> hi Kinbo
21:56:06 <ski> that's the term used for when lots of people who can't spell correctly, tries to write swedish with english style
21:56:27 <ski> shapr : it's very common in e.g. supermarkets
21:56:29 <LordKinbo> how are you all tonight?
21:56:48 <shapr> I'm doing well, and it's nearly 7am for me.
21:56:56 <LordKinbo> yikes
21:56:58 <shapr> how are you?
21:57:09 <LordKinbo> can't complain
21:57:33 <LordKinbo> first time here...searching Haskell help and came across the wiki...very interesting, I should bookmark it
21:57:51 <shapr> yes, it's a good site.
21:58:08 <ski> shapr : varsågod, en sajt som specialiserat sig på stavfel och språkliga fel : http://www.avigsidan.com/   (varning : kan ofta vara mycket rolig)
21:58:09 <LordKinbo> my problem was too specific for it, but it's a good general reference
21:58:24 <ski> LordKinbo : hi
21:58:30 <LordKinbo> hi ski
21:58:32 <shapr> what is your specific problem?
21:59:14 <LordKinbo> well, it's more of a function that I have to write for a class.  Want to try and give me a boost?  Heh.
21:59:31 <shapr> have you seen the HomeworkHelp pages on the Wiki?
22:00:11 <shapr> which means, in summary, we can answer some stuff, but it would unethical for us to do your homework for you
22:00:24 <LordKinbo> yeah
22:00:29 <LordKinbo> I know it would be
22:00:39 <shapr> that said, what's the problem?
22:00:50 <ski> what's the excercise about ?
22:01:03 <LordKinbo> I just need a step in the right direction...
22:01:49 <LordKinbo> I need to write a function that takes two numbers x and y and returns a list of all the lists of length x whose elements add up to y.
22:02:31 <ski> aha, partitions
22:02:40 <LordKinbo> for example, summands 3 5 = [[0,0,5],[0,1,4],[0,2,3],[1,1,3],[1,2,2]]
22:03:06 <LordKinbo> I know it involves some kind of double recursion, but that's one recursion too many for me, haha
22:03:29 <ski> hmm couldn't you use list comprehensions somewhere
22:03:33 <ski> ?
22:04:19 <LordKinbo> see, my original idea was to somehow use list comprehension to form a list of, say, all lists of length x whose elements are <= y
22:04:29 <LordKinbo> and then keep simplifying the list from there
22:04:41 <LordKinbo> like, make sure the elements add up to y
22:04:50 <LordKinbo> and then make sure the elements are in nondecreasing order
22:04:54 <ski> well, i guess you could try a simple generate-and-test
22:05:13 <ski> (though it might be innefficient)
22:05:19 <LordKinbo> but the professor swears that his answer has recursive calls only
22:05:35 <LordKinbo> oh, my idea would be very inefficient
22:05:37 <LordKinbo> heh
22:05:46 <Cale> yeah, it shouldn't be so bad to do that entirely recursively
22:05:49 <ski> well, list comprehensions can be purged, afterwards
22:06:12 <LordKinbo> well, cale, I'm sure it won't seem that bad after the fact
22:07:27 <LordKinbo> I don't know, I wasn't expecting substantial help here.  I was just looking to whine to someone who understood what I was talking about.  My girlfriend was starting to get annoyed, haha
22:07:31 <Cale> you just have to think "how can I turn this problem into a smaller problem"
22:07:37 * ski laughs at Aftonbladet
22:07:46 <Cale> or possibly a list of smaller problems
22:08:37 <LordKinbo> oh well 
22:09:12 <ski> you had an idea of first forming a list, and then doing something with that
22:11:03 <LordKinbo> well, a) the professor said that's not the way to do it, and b) I tried, and I couldn't generate that preliminary list that contained all permutations of lists with x elements, all <=y
22:11:27 <ski> ok
22:13:10 <ski> could you think recursively to try to solve the problem
22:13:12 <ski> ?
22:13:26 <ski> what would a recursively smaller problem be ?
22:14:02 <LordKinbo> though...maybe bigList x y = [lst|lst<-[0..y],((size lst) == x)] where size [] = 0   size x:xs = 1 + (size xs)
22:14:07 <LordKinbo> might do the trick...
22:14:27 <ski> that looks like it might be on the right track ...
22:14:47 <ski> hmm
22:14:57 <ski> lst is not a list, but a number
22:15:13 <LordKinbo> damn, you're right 
22:15:24 <ski> it gets succesively bound to elements of the list [0..y]
22:15:27 <LordKinbo> yeah
22:15:45 <ski> but i think some of this idea is worth working on
22:15:55 <ski> so don't throw it away
22:16:37 <ski> is x or y the sum ?
22:16:50 <ski> y, i guess
22:17:23 <LordKinbo> I think it's the "list of lists" idea that's throwing me, because not only do you have to do recursion within each list (take the first element and recursively call the function on the rest by subtracting the length by 1 and the sum by whatever the first element was)
22:17:35 <ski> btw, your size function already exists in Prelude, although under a different name  ...
22:17:45 <LordKinbo> you have to do recursion to generate every list as well
22:17:55 <ski> hmm
22:19:33 <ski> if you can't use list comprehensions, then i'd guess that you need a helper function
22:20:20 <ski> which of x and y is the length of the sublists, and which is the sum of each sublist ?
22:20:44 <LordKinbo> x = length, y = sum
22:20:49 <ski> ok
22:21:03 <ski> bigList len sum = ...
22:21:13 <ski> perhaps is more readable, then
22:22:07 <LordKinbo> oh yeah, I know...I used similar variable names in my (very) unfinished code...just x and y here because that's what I started with in my explanation
22:22:21 <ski> ok
22:24:43 <LordKinbo> it's definitely the hardest problem this week...the rest was implementing a splay function, which was interesting and easy
22:25:20 <ski> well, if we are trying to think recursively
22:26:04 <ski> the perhaps, a smaller problem could be find lists of length (len - 1) (provided len > 0)
22:26:10 <ski> well
22:26:36 <ski> perhaps you can write what the function should return, if the len is 0 ?
22:27:02 <ski> summands 0 sum = ...
22:27:03 <LordKinbo> yeah, I already have the base case(s).
22:27:27 <ski> what is it ?
22:27:36 <LordKinbo> because I guess summands 1 sum = [[sum]] might be useful as well
22:28:28 <LordKinbo> summands 0 sum = [[]]
22:28:49 <ski> yeah, but that is probably not needed as a special case  (usually one needs zero-elements- and at-least-one-element-cases. not always though)
22:29:28 <ski> (i.e. the 1 case i probably not needed. but then again, as long as it is correct, it isn't doing any harm either)
22:29:31 <LordKinbo> I know...but, even if it isn't a base case that need to be written, it's still useful to keep track of different cases.
22:29:57 <ski> mhfan : greetings
22:30:20 <ski> LordKinbo : yes, it can be
22:30:40 <ski> at least to oneself
22:31:42 <ski> so, then you'll have to think of the general case, i.e. len is some (positive) number
22:32:04 <ski> summands len sum = ..?..
22:33:18 <ski> if we are going to use recursion here, we are probably going to define this in terms of a "smaller instance of the problem", i.e. probably for some smaller len, in out case
22:33:24 <ski> s/out/our/
22:33:46 <LordKinbo> well, yeah, we're going to chop the len down until it's 0.
22:33:55 <ski> what do you think an appropriate smaller len might be ?
22:34:19 <ski> yes
22:34:20 <LordKinbo> well, len-1
22:34:52 <ski> yes, that is probably the easiest to come up with. and it is probable that it is going to work well here
22:35:27 <ski> (because the len is used to count the length of lists and lists are built up incrementally, one element at a time)
22:35:56 <ski> so we probably have something like
22:36:08 <LordKinbo> I've gotten this far.
22:36:20 <LordKinbo> It's just the fact that I have to generate multiple lists that's throwing me
22:36:31 <ski> summands len sum = ... (summands (len - 1) (..someSum..)) ...
22:36:39 <ski> ok
22:37:08 <ski> what should (..someSum..) be ?
22:37:25 <ski> hm
22:37:28 <ski> well
22:37:43 <LordKinbo> the total sum minus the sum of whatever elements we've already put in the list
22:38:14 <ski> this recursive call is going to return a list of lists, each of length (len - 1), and each has the sum (.someSum..)   do you agree ?
22:38:30 <LordKinbo> yeah
22:38:35 <Cale> hmm... I have a solution, but it uses a helper function :)
22:38:42 <LordKinbo> helper functions are fine
22:38:57 <Cale> it's 3 lines - just seeing if I can make it any simpler
22:39:01 <ski> hmm, so what should we do with these lists that all are one element short of what we want
22:39:15 <Cale> it helps to do a bit of math first to determine which recursive cases you'll need.
22:39:21 <Cale> (on paper)
22:39:32 <ski> Cale : yeah, i think one could make it quite concice
22:40:08 <LordKinbo> ski, I guess we append an element onto them
22:40:20 <ski> or prepend  (cons)
22:40:32 <Cale> my current solution is about 180 chars.
22:40:33 <LordKinbo> right, that's what I meant
22:40:40 <ski> but, we probably have to solve the (..someSum..) problem
22:40:45 <ski> ok
22:41:11 <LordKinbo> cale, how much is it worth to you?  just kidding
22:41:16 <Cale> hehe
22:41:40 <ski> i think it would be hard to determine (..someSum..) *after* we've got the results of the recursive call, so probably we have to comput all possible (..someSome..) *before*, then
22:42:11 <ski> what do you think ?
22:42:19 <LordKinbo> I...agree...
22:42:31 <Cale> well, here's one thing to note: if n is the number you're taking the partition of, and k is the number of parts, then the biggest head of the lists that you'll return is n `div` k.
22:42:44 <ski> but (..somSum..) shouldn't be only *one* value
22:43:01 <ski> we have to try many different ones, to genereate all possible lists, i think
22:43:16 <Cale> I'm only generating the lists that work :)
22:43:21 <ski> Cale : well, that is useful
22:44:01 <ski> LordKinbo, i think we need a helper function here
22:44:06 <LordKinbo> yeah
22:44:16 <ski> so what do we have
22:44:28 <ski> summands len sum = helper ...
22:44:31 <LordKinbo> scott is fine...LordKinbo sounds silly
22:44:31 <LordKinbo> heh
22:44:51 <ski> ok
22:45:07 <Cale> then why not make your nick Scott and join the ranks of people who use their real names on irc?
22:45:09 <Cale> :)
22:45:11 <ski> y'know, you probably could /nick scott, if you like
22:45:39 <scott> I usually use LordKinbote, but it's too many characters
22:45:45 <scott> scott works
22:45:48 <ski> Cale : what ? you don't think ski is my real name ?
22:46:01 <Cale> I didn't say that.
22:46:14 * ski sensed Cale thought it
22:46:24 <Cale> though I thought it was more likely to be a reference to the SK calculus.
22:46:50 <scott> I thought it was a reference to...uhh...the sport
22:47:03 <Cale> yeah, but this is #haskell
22:47:05 <ski> scott : no :) i don't do that much
22:47:11 <ski> yeah :)
22:47:14 <scott> true
22:47:20 <Maddas> heh
22:47:26 <Maddas> Don't worry, my real name isn't Maddas :)
22:48:20 <ski> Cale : actually i probably could change nick to something better. but i think this somehow has stuck, and probably people recognise me better under this name
22:48:48 <ski> but, what do i know
22:49:56 <Darius> ski: Well at least you aren't stealing the name of others like -some- people.
22:50:14 <ski> well, i wouldn't do *that*
22:51:58 <ski> hm, so what should helper do ?
22:52:22 <ski> what does (..someSum..) depend on ?  how to determine/compute it ?
22:52:43 <ski> we already have len and sum
22:52:48 <scott> someSum depends on the numbers that have come before
22:52:57 <ski> hm
22:52:58 <Cale> I needed my helper to pass along the minimum head of the lists to generate.
22:53:10 <ski> Cale : i know
22:53:24 <Cale> :)
22:53:27 <scott> heh
22:54:02 <ski> scott : hope you don't mind that i'm trying to make you think (in a good way)
22:54:23 <ski> (nudging you on)
22:54:27 <scott> as I said, I wasn't expecting to come in here and have someone say "Oh, here's the code for you, have a nice day"
22:55:34 <ski> well, i guess i *could* do that. (as Cale surely can). but what would be the *fun* of that ?  (both for me and for you)         (HHOS)
22:56:06 <scott> sadist
22:56:06 <scott> ;)
22:56:21 <ski> mjaha...
22:57:02 <scott> anyway...
22:57:22 <ski> well i think that if you go though this thoroughly, you're going to learn nice things from it
22:57:26 <ski> yes, anyway
22:57:28 <ski> :)
22:57:47 <ski> so, hmm
22:57:57 <ski> where were we ?
22:58:08 <ski> oh, yes
22:58:12 <scott> figuring out how to compute (..someSum..)
22:58:16 <ski> yes
22:58:43 <ski> and this (..someSum..) is the one given to the recursive call (which also get (len - 1))
22:59:01 <scott> I thought that someSum is determined by taking the number(s) we have prepended onto the list already and subtracting them from sum
22:59:04 <scott> am I wrong?
22:59:22 <ski> so that recursive call is going to produce a list of lists, each one being one element shorter than what we want here
22:59:34 <ski> no, you're right
22:59:36 <ski> :)
23:00:26 <ski> only, because these lists produced in the recursive call have length (len - 1), we only have to add *one* element in from of them (each) to make them the correct length
23:00:51 <ski> that means that you can skip the (s) in number(s)
23:01:16 <scott> ok, I guess I have to stop thinking of it as multiple steps and think of it as one recursive step
23:01:23 <ski> we are only going to prepend one element at a time (for each recursive call)
23:01:28 <ski> do you agree ?
23:01:31 <scott> yeah
23:01:40 <ski> ok
23:02:37 <ski> so if we imagine that we already somehow have computed what element to put before ..
23:02:48 <ski> what should we call it ?
23:03:19 <scott> startnum
23:03:44 <Cale> q
23:03:51 <Cale> startnum is okay too
23:03:59 <ski> (this might, of course be a number that is going to be positioned in tthe middle of a final list)
23:04:00 <scott> I'm guessing the helper is the function that computes that element
23:04:04 <ski> but, it is ok
23:04:09 <scott> ?
23:04:20 <ski> yes, probably  :)
23:04:35 <ski> so we now have something like
23:05:02 <ski> helper ... = ... somehow compute startnum ... (
23:05:19 <ski> summands (len - 1) (??)) ...
23:05:21 <ski> oh
23:05:28 <ski> helper ... = ... somehow compute startnum ... (summands (len - 1) (??)) ...
23:05:42 <ski> so, scott, what should the ?? be ?
23:05:58 <scott> num-startnum
23:06:03 <scott> sum-startnum
23:06:04 <ski> num ?
23:06:05 <scott> sorry
23:06:06 <ski> yes
23:06:12 <ski> that seems right
23:06:21 <scott> note to self: don't pick rhyming variables
23:06:22 <scott> heh
23:06:28 <ski> :)
23:07:06 <ski> what are the possible startnum's given len and sum (we get those in summands) ?
23:07:17 <scott> 0 to (sum/len)
23:07:25 <ski> (Cale hinted at this earlier)
23:07:48 <ski> yes, something like that
23:08:04 <ski> hmm, which way should (sum/len) be rounded ?
23:08:20 <scott> um....down
23:08:32 <ski> sure ?
23:08:35 <scott> yes
23:08:35 <ski> hmm
23:08:50 <scott> I had to look at some examples
23:08:54 <scott> hence the um
23:08:55 <ski> i'm just going to try a thought experiment
23:09:06 <ski> say sum = 11
23:09:11 <ski> and len = 4
23:09:30 <ski> that gives floor (11 / 4) = 2
23:09:51 <Cale> [2,3,3,3] is a partition of 11
23:09:55 <ski> isn't [3,3,3,2] a possible result list ?
23:10:19 <Cale> nope, they were specified to be nondecreasing
23:10:25 <ski> aha
23:10:29 <scott> the function isn't supposed to return that list
23:10:37 <ski> no
23:10:54 <ski> but could it be an element of the result list ?
23:11:24 <Cale> at least, scott's example only had the nondecreasing ones
23:11:25 <ski> (i.e. thinking about Cale's example)
23:11:42 <scott> I don't think so
23:11:49 <ski> scott : well, is it true that they must be nondecreasing ?
23:12:01 <scott> yes
23:12:03 <ski> (the element lists in the result)
23:12:05 <ski> ok
23:12:08 <ski> good
23:12:16 <ski> (that we know that)
23:12:21 <scott> and unique...so if you do summands 4 10, you won't get 2 elements that say [0,0,5,5]
23:12:31 <ski> aha
23:12:48 <ski> so no repitition, then ?
23:13:00 <scott> right
23:13:03 <ski> ok
23:13:09 <scott> nondecreasing kills most repetition
23:13:52 <ski> well, i guess it must be, not just nondecreasing, but *increasing*, then. right ?
23:14:03 <Cale> no
23:14:08 <scott> no, because [0,0,5,5] is good
23:14:09 <ski> no ?
23:14:14 <ski> why ?
23:14:15 <scott> but it is not increasing
23:14:17 <Cale> increasing would kill off most of the results
23:14:19 <ski> 0 is repeated
23:14:23 <ski> 5 is repeated
23:14:31 <scott> that's why it's nondecreasing
23:14:42 <ski> or did you mean that none of these *whole* lists must be repeated ?
23:14:50 <scott> if it were increasing, all subsequent elemetns would have to be larger than the last
23:14:50 <Cale> none of the whole lists
23:14:56 <scott> like [1,3,7,11]
23:15:03 <ski> yes
23:15:14 <Cale> i.e. [0,0,5,5] can't occur twice just because you can swap the 5's around the other way
23:15:16 <ski> Cale : ok
23:15:25 <scott> that's what I meant, yeah
23:15:34 <scott> or the zeroes, for that matter
23:15:51 <Cale> right, if you had this problem, you'd likely be getting 4 of them :)
23:16:09 <ski> so [5,0,5,0] would be a proper solution, if it weren't for the fact that this is probably already present earlier in the result list (of lists) ?
23:16:32 <scott> well, more than probably
23:16:34 <scott> definitely
23:16:43 <ski> ok
23:16:46 <Cale> no - 5,0,5,0 doesn't satisfy the condition that it be nondecreasing
23:16:54 <ski> oh, right
23:17:01 <ski> forgot that
23:17:33 <ski> hmm, i wonder if we can construct these lists such that none of the is gonna get replicated
23:17:47 <ski> or do we have to filter away duplicates ?
23:17:47 <scott> I don't think that's necessary...cale can probably back me up
23:17:53 <scott> you didn't need to filter, did you?
23:17:57 <Cale> no
23:18:01 <ski> ok
23:18:22 <ski> well hmm
23:18:24 <Cale> The solution just came out right the first time, modulo some tweaking the base case
23:18:46 <ski> so what is the proper range for startnum, then ?
23:19:10 <scott> if the numbers that helper returns are always between 0 and (sum/len), will they always be in nondec order?
23:19:31 <scott> floor(sum/len) rather
23:19:44 <Cale> sum `div` len might be nicer
23:19:57 <scott> ok
23:20:10 <ski> if we want rounding down. i'm still not sure
23:20:13 <scott> you're right
23:20:22 <ski> [2,3,3,3]
23:20:24 <scott> sum 'div' len will return the division without the modulo
23:20:28 <ski> yes
23:20:34 <ski> so we'll get 2
23:20:41 <Cale> i.e. the minumum thing that still goes it
23:20:42 <Cale> in*
23:20:47 <ski> will we get 3 for the next element ?
23:21:02 <Cale> eh?
23:21:10 <ski> ?
23:21:10 <Cale> that's the last partition you should generate
23:21:16 <ski> yes
23:21:19 <scott> okay, let's say it is summands 4 11.  11 'div' 4 is 2...9 'div' 3 is 3
23:21:31 <scott> 6 'div' 2 is 3
23:21:39 <scott> 3 'div' 1 is 3
23:21:39 <ski> but i want the range of the second elem, given that the first was chosen to be 2
23:21:56 <scott> that gives the largest element possible, [2,3,3,3]
23:21:59 <ski> yes
23:22:02 <ski> you are right
23:22:13 <ski> ok
23:22:21 <ski> so
23:22:43 <Cale> oh, and don't forget, it's backticks: `div`
23:22:58 <scott> oh, ok
23:22:59 <scott> ```
23:23:01 <scott> gotcha
23:23:02 <scott> heh
23:23:18 <Cale> a `blah` b = blah a b
23:23:33 <ski> we still have to generate sublists (with recursive call) for each of the possible startnum's in the current range, and then add this startnum to all of the result lists corresponding to that start num
23:24:37 <Cale> a list comprehension makes this look really nice :)
23:24:41 <ski> and then, we need to take all these (with each length = len) result lists of lists, one for each startnum, and concatenete them together
23:24:46 <ski> Cale : i know
23:25:07 <ski> sounds complicated ?
23:25:28 <Cale> actually, once I got the list comprehension, I didn't need the concat.
23:25:45 <scott> I think the prof would rather have the concatenation
23:26:01 <ski> Cale : i thought he said that he couldn't use list comprehensions
23:26:08 <Cale> oh, perhaps
23:26:25 <Cale> in which case, yeah, probably the concat is needed
23:26:34 <ski> scott : are you allowed to use *any* standard functions, like filter,map,concat ?
23:26:59 <ski> or just ++ and recursion, say ?  (plus arithmetic, of course)
23:27:00 <Cale> and can you use [n..m] notation?
23:27:04 <scott> well, we haven't *seen* that many standard functions
23:27:18 <scott> we could use [n..m] notation, I'm sure
23:27:26 <scott> it's not that I *can't* use anything
23:27:34 <ski> ok
23:27:52 <ski> it would look a bit nicer with concat, i think
23:28:03 <scott> it's just I think he prefers the answer in a certain way. 
23:28:07 <ski> (and perhaps concatMap, as well)
23:28:10 <ski> ok
23:28:18 <ski> well
23:29:02 <ski> for each startnum in the range [0 .. sum `div` len] we should generate a list of lists, and then concatenate all these, once
23:29:22 <ski> how do we generate startnums ?
23:29:38 <ski> i think i can see at least two ways
23:29:52 <scott> it would be nice if I could use a while loop
23:29:53 <scott> heh
23:30:39 <scott> hmm.
23:30:46 <ski> what technique is often used instead of for or while loops, in functional programming languages ?
23:31:08 <scott> recursion?
23:31:21 <ski> (i.e. e.g. for containing the 'current value' of the index, or somesuch)
23:31:23 <ski> yes
23:31:32 <ski> but what style of recursion
23:31:45 <scott> uhhh
23:31:48 <ski> (i'm not totally you've seen it)
23:31:54 <scott> I'm sure I have
23:31:58 <ski> hm
23:32:12 <ski> well, um, you probably have, yes
23:32:20 <scott> it's just this course I'm in is taken 2 years after the last functional programming class
23:32:25 <scott> so things are a bit rusty
23:32:38 <ski> think of the perennial factorial, e.g. :)
23:32:46 <ski> ok
23:33:13 <ski> remember how that is defined, usually ?
23:33:33 <scott> factorial?
23:33:51 <ski> you know  factorial 5 = 1 * 2 * 3 * 4 * 5
23:33:56 <ski> and so on
23:33:59 <scott> fac 0 = 1    fac n = n * (fac n-1)
23:34:28 <ski> isn't the fac argument like an index/counter, counting downwards ?
23:34:33 <scott> yes
23:34:43 <Cale> http://www.willamette.edu/~fruehr/haskell/evolution.html
23:35:08 <scott> I skimmed that a couple weeks ago, ha.
23:35:13 <ski> for (;n > 0;n--) {prod *= n;}
23:35:38 <ski> there's some similarity, yes ?
23:35:58 <scott> ok
23:36:02 <ski> so
23:36:15 <ski> how about making startnum an argument of helper
23:36:43 <ski> we "initialize" it to the biggest value when we call helper in summand
23:36:51 <scott> ok
23:37:01 <scott> and then count down in recursive calls until we reach zero
23:37:03 <ski> and helper will now *also* be recursive
23:37:07 <scott> where we append it?
23:37:28 <ski> and in each of the helper recursive calls, we're going to "count down" startnum
23:37:33 <scott> or prepend, rather
23:37:37 <ski> until it comes down to zero
23:38:06 <ski> upon all lists that the summand recursive call return, i'd guess
23:38:31 <ski> can you write down a rough structure of helper, now ?
23:39:08 <scott> I guess we start off with a base case
23:39:29 <ski> (we can, for the moment, imagine that helper should only have one argument. mayhaps we'll need more later)
23:39:30 <ski> yes
23:39:58 <ski> so what's a good base case
23:40:25 <scott> helper 0 = []?
23:40:26 <ski> (remember, we are now doing recursion over the startnum's in the range)
23:40:43 <ski> well, let us think about it
23:40:53 <ski> (it could well be the correct one)
23:41:05 <scott> yeah, I'm confused as to what the helper is returning.  I know the base case is at zero.
23:41:23 <ski> hmm, ok let's say so for the moment. we can check it again later
23:41:28 <ski> hmm
23:41:54 <ski> is helper going to return the same as summand
23:42:19 <ski> i.e. [[Int]] or whatever numeric type you wanted
23:42:28 <ski> i think so
23:42:33 <scott> yeah
23:42:59 <ski> so, perhaps we should also recall hoe summand looks like
23:43:09 <ski> (i.e. the recursive case of summand)
23:43:21 <ski> summand len sum = ..helper..
23:43:45 <ski> he we must "initialize" startnum, agree ?
23:44:00 <ski> s/he/here/
23:44:23 <scott> what? heh
23:44:34 <scott> oh
23:44:44 <ski> like calling fac with an initial n-value
23:45:23 <ski> so what was the initial value of startnum (given that we're going to count downwards) ?
23:45:30 <ski> remember ?
23:45:41 <scott> sum `div` len
23:45:44 <ski> right
23:46:28 <ski> and, do we need to do anything with what helper returns, i mean before letting summand return it ?
23:47:02 <scott> append it together
23:47:09 <ski> ok
23:47:10 <scott> or concat it rather
23:47:26 <ski> so actually we could do think thing in two ways
23:47:50 <ski> either we could let helper return a list of [[Int]], i.e. a [[[Int]]]
23:47:59 <ski> and then, using
23:48:01 <ski> @concat
23:48:02 <lambdabot> Sorry, I don't know the command "concat", try "lambdabot: @listcommands"
23:48:08 <ski> @type concat
23:48:09 <lambdabot> concat :: [[a]] -> [a]
23:48:30 <ski> we can make it into [[Int]], which summand wants to return
23:48:32 <ski> ok ?
23:48:37 <scott> right
23:48:39 <ski> or
23:48:57 <ski> we could append-them-lists-together-as-we-go
23:49:17 <ski> i.e. letting helper call ++ quite a lot of times
23:49:33 <ski> (this is more or less a stylistic issue)
23:49:38 <scott> well, it would call it once, just over and over until it was done
23:49:56 <ski> mm
23:49:59 <scott> never mind
23:50:06 <scott> I think I'd rather do the latter
23:50:10 <ski> well, which idea do you like to pursue ?
23:50:13 <ski> ok
23:50:29 <ski> then, currently, helper :: Int -> [[[Int]]]
23:50:43 <ski> while summand :: Int -> Int -> [[Int]]
23:50:44 <scott> isn't that the former?
23:50:53 <ski> ?
23:50:59 <ski> oh
23:51:00 <ski> sorry
23:51:02 <scott> heh
23:51:04 <scott> no prob
23:51:06 <ski> you're right
23:51:16 <ski> helper :: Int -> [[Int]]
23:51:19 <ski> so
23:51:22 <scott> I'd rather not deal with lists of lists of lists
23:52:02 <Cale> I want the type a = [a]
23:52:05 <ski> helper (sum `div` len) is then already giving us a list of lists. and that lists contains entries for each of startnum in range 0 to sum `div` len
23:52:20 <ski> Cale : a cyclic type ?
23:52:27 <Cale> heh, yeah
23:52:45 <Cale> you can't have those (they'd be rather silly in practice)
23:53:01 <ski> so, scott, do you think you can write that line of summand, now ?
23:53:34 <ski> Cale : a = (b,[a]), then ?
23:54:00 <ski> Cale : rose tree, isn't it called that ?
23:54:00 <scott> summands len sum = helper (sum `div` len)...
23:54:08 <ski> yes
23:54:49 <scott> although, you need a base case summands 0 sum = [[]]
23:54:58 <ski> and (for the moment) we don't think we need anymore arguments to helper, and we don't think we need to do anything more with what helper returns, so we can leave out the ..., i think
23:55:04 <ski> yes
23:55:14 <ski> you menationed base case(s) before
23:55:22 <scott> right
23:55:24 <ski> we need at least one of them
23:55:34 <Cale> oh, you can have things where you have to call a constructor to get another level down, but think about what a = [a] would mean - it would be the limit of the sequence of types a, [a], [[a]],... where adding another list-of would no longer make a difference
23:55:37 <ski> (i think the one with 0 is going to suffice)
23:55:48 <scott> I think so too
23:56:34 <ski> Cale : i know, but the type l in l = Maybe (a,l) is isomorphic to [a], no ?
23:56:40 <ski> ok
23:56:44 <scott> so helper 0 = [[]]
23:56:44 <scott> and
23:57:33 <Cale> ski: yeah
23:58:11 <scott> helper startnum = startnum: (helper (summands (len-1) (sum-startnum)))
23:58:18 <scott> something similar, at least
23:58:25 <ski> Cale : so one can't say that those kind of things are *inherently* useless. although an explicit constructor might be better..
23:58:45 <ski> mm
23:58:46 <scott> or, wait...
23:58:47 <ski> yes
23:58:53 <scott> hmm
23:58:56 <ski> hmm
23:59:12 <ski> helper shouldn't have the summand call as argument, i think
23:59:21 <Cale> oh, I wasn't implying that limit types would inherently be useless, but a = [a] is such that constructing a value of that type is hard :)
23:59:32 <ski> it should have (startnum - 1), do you agree ?
23:59:43 <scott> yeah, since helper takes a number and summands returns a list of lists
23:59:45 <scott> you're right
23:59:55 <ski> Cale : the empty list ?
