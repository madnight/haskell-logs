01:08:39 <bring> good morning #haskell
01:27:06 <shapr> good morning bring 
01:31:08 <bring> shpar: do you know if there is a standard SQL construct to limit the number of records returned from query. MySQL and Postgre both have LIMIT, but I can't find a reference to that in SQL92
01:31:18 <shapr> I don't know.
01:31:45 <shapr> dennisb knows more about postgresql than I do, he may know.
01:32:31 <liiwi> good almost afternoon
01:33:11 <liiwi> shapr: are you using crypt++el ?
01:33:29 <shapr> I have used it, but not recently.
01:33:39 <liiwi> useful? works?
01:33:51 <shapr> I think so, I don't remember very well.
01:34:43 <shapr> I tried to find some way to easily GPG sign/encrypt emails with gnus, but the biggest problem I found was that very few people knew what to do when they received an email like that.
01:35:03 <shapr> liiwi: if you find a good solution, I'd like to know.
01:35:17 <liiwi> shapr: new gnus and gpg.el
01:35:36 <liiwi> shapr: works like a charm.
01:36:01 <shapr> do you have an $IRCNICK at iki dot fi address?
01:36:11 <liiwi> shapr: does both mime and inline sigs
01:36:13 <liiwi> shapr: yes
01:36:53 <shapr> cool, I'll try it.
01:38:14 <shapr> I want a key with photo-id
01:39:33 <liiwi> what I need is to keep a set of files encrypted
01:40:58 <shapr> loopback filesystem?
01:41:17 <shapr> you'd need to keep #file# backups on the same filesystem though.
01:42:36 <liiwi> nah, tmpfs and bit of smartness to emacs
01:42:49 <shapr> bring: do you know if params are named in xml-rpc? from looking at the standard, I don't think so.
01:43:18 <liiwi> actually just crypt++el propably works
01:44:49 <bring> shapr: you're right, they not. If you want that, you could use a struct
01:45:10 <bring> (assuming you're writing the method)
01:45:14 <shapr> ohh
01:45:18 <shapr> so that's what they're doing.
01:47:32 <bring> if you want to use that from XmlRpc I guess you have to resort to the Value trick
01:55:21 <shapr> which value trick?
01:56:44 <shapr> anyone know the status of darcs in debian? did someone post an ITP?
01:59:38 <dennisb> bring: there is no standard for limit
01:59:48 <shapr> hej dennisb!
01:59:54 <dennisb> hallÃ¥
02:00:17 <dennisb> bring: mysql and postgresql don't use the same by the way. mysql uses LIMIT x,y and pg uses LIMIT x OFFSET y
02:00:31 <dennisb> and some other databases has a TOP x construct
02:00:36 <bring> great
02:00:41 <dennisb> not really :-)
02:00:44 <bring> :)
02:00:45 <dennisb> it sucks
02:01:45 <bring> I don't know how we should handle this sort of thing in haskelldb
02:01:52 <bring> except lowest common denominator
02:02:45 <bring> any ideas?
02:04:20 <shapr> would be nice to have it happen automagically in the background with "take 5 from results"
02:04:33 <shapr> then I don't have to know whether it's LIMIT, TOP, or what.
02:04:34 <bring> yes
02:05:04 <bring> hmm, if we have lazy queries, maybe take would be enough
02:05:20 <shapr> oh, did I tell you about the Oracle FFI binding already?
02:05:34 <shapr> not that I have a copy yet :-)
02:05:44 <bring> shapr: how would haskelldb know which one to use of TOP and LIMIT?
02:05:50 <bring> shapr: you did :)
02:05:58 <shapr> ah, ok.
02:06:21 <shapr> at the moment, you have to use pgConnect or mqConnect or odConnect, etc
02:06:50 <bring> btw, there is a new version of HSQL (1.2.1) since about a week, it has much improved the handling of date types
02:06:50 <shapr> I figured you'd have a generic SQL generator and then more specific implementations of the same stuff.
02:06:55 <shapr> spiffy
02:07:09 <bring> yes, I guess that would have to be the way to go
02:07:35 <bring> sucks though, why isn't stuff like this in the standards
02:08:06 <shapr> on the good side, that would mean that a heavy duty postgresql expert could tune the postgresql SQL generator into much speed.
02:08:17 <shapr> same for each backend.
02:08:55 <shapr> Is the SQL generator modular?
02:12:22 <bring> can't say it is
02:12:47 <shapr> is it a big deal to cut it into modular parts?
02:13:13 * shapr looks at the source
02:13:21 <bring> look at Sql.hs
02:13:41 <dennisb> bring: and even a lot of the things that are in the standard or not implemented in the different databases
02:13:48 <dennisb> is not implemented
02:13:57 <bring> and the second half of PrimQuery.hs
02:14:20 <bring> dennisb: I've noticed :)
02:14:51 <dennisb> and that's just sql92. Then we have sql99 and the sql200x draft
02:16:03 <bring> shapr: I think it would require a bit of work, but ultimately it probably needs to be done
02:16:06 <shapr> first thing that comes to mind is to make a typeclass with instances for each database, but feel too cheesy
02:16:48 <shapr> the ultimate spiffiness would be to generate queries according to a supported features spec
02:17:04 <shapr> I guess that would be a compiler for a little language.
02:17:06 <bring> we could just add another function to the Database structure
02:17:43 <Lunar^> hi
02:17:51 <shapr> salut Lunar^ 
02:17:56 <bring> hi Lunar^
02:18:27 <shapr> how are the IRQ handlers going?
02:19:24 <bring> Lunar^: the latest HSQL version should have thread-safety like what you proposed, but I think Krasimir added it for all the DB drivers, haven't really looked at it
02:21:23 <Lunar^> bring: Happy if I helped
02:51:22 <ham[mer]> hiho
02:59:18 <shapr> yow!
03:00:19 <ham[mer]> darcs! ;)
03:00:23 <shapr> haha
03:00:33 <shapr> hello ham[mer], what's up?
03:01:13 <ham[mer]> nothing much right now
03:01:40 <ham[mer]> and on your end of the cable?
03:02:07 <shapr> having fun with bring's XmlRpc lib and Zope.
03:18:32 <liiwi> there, crypt++el is now playing nice
05:24:38 <shapr> @yow!
05:24:38 <lambdabot> Sorry, I don't know the command "yow!", try "lambdabot: @listcommands"
05:24:43 <shapr> @yow !
05:24:43 <lambdabot> Yow!  Are you the self-frying president?
05:24:47 <shapr> not likely!
05:24:49 <shapr> @fortune
05:24:50 <lambdabot> Life sucks, but death doesn't put out at all.
05:24:50 <lambdabot> 		-- Thomas J. Kopp
05:26:44 <shapr> so, what's going on guys?
05:27:12 <shapr> hi themaximus 
05:28:39 <themaximus> hi
05:28:45 <shapr> what's going on?
05:32:38 <shapr> mm, I just had some nice cheese.
05:32:46 <swisscheese> :-)
05:33:10 <swisscheese> JLouis - you there?
05:33:56 <swisscheese> I can't see why following gives "ambiguous occurance of '==':
05:33:56 <swisscheese> instance Eq Nodes where
05:33:56 <swisscheese> Nodes x _ _ _ _ _ _ _ == Nodes y _ _ _ _ _ _ _ = x == y
05:34:30 <shapr> tried wrapping parens around the Nodes constructors?
05:34:58 <shapr> (Nodes x _ _ _ _ _ _ _) == (Nodes y _ _ _ _ _ _ _) = x == y -- ?
05:35:26 <swisscheese> Just tried it - no help :-(
05:36:29 <norpan> what's the type of the first arg of Nodes
05:36:39 <shapr> tried flipping the rhs and lhs?
05:36:58 <swisscheese> ???
05:37:27 <swisscheese> Says ambiguous between prelude and main.
05:37:37 <shapr> urf
05:37:44 <shapr> do you have the Nodes datatype handy?
05:38:42 <swisscheese> data Nodes = Node Position Int Int Int Int Int Int Int deriving Show
05:38:59 <shapr> what's Position?
05:39:41 <swisscheese> [[Char]]
05:40:50 <shapr> it is "data Position = Position [[Char]]" ?
05:41:09 <swisscheese> type Position = [[Cell]]
05:41:24 <swisscheese> type Cell = Char
05:41:59 <shapr> this may be a stupid question, but why not try "data Nodes = Node Position Int Int Int Int Int Int Int deriving (Show, Eq)" ?
05:42:30 <shapr> swisscheese: oh, I found your problem
05:42:42 <shapr> Nodes in the *type* and Node is the *constructor*
05:43:06 <shapr> for example, try porting your Eq instance code to this: "data NodeType = NodeConstructor Position Int Int Int Int Int Int Int deriving Show"
05:43:06 * Lunar^ is trying to deamonize some Haskell code
05:43:28 <shapr> I'm really good at vilifying Java code, does that help?
05:43:57 <shapr> swisscheese: make sense?
05:44:01 <swisscheese> deriving (Show,Eq) did not help.
05:44:30 <swisscheese> shapr - no :-(
05:45:20 <shapr> swisscheese: comment out your current definition that starts with "data Nodes" and your current Eq instance code, replace the datatype with this: "data NodeType = NodeConstructor Position Int Int Int Int Int Int Int deriving Show"
05:45:26 <shapr> then write the Eq instance again.
05:45:37 <shapr> and I think you'll see what's going on.
05:46:48 <shapr> swisscheese: makes more sense now?
05:46:58 <swisscheese> Thinking...
05:47:20 <shapr> have you tried to write the Eq instance with datatype declaration I furnished?
05:49:10 <swisscheese> I can try it but it seems you are just changing the names and creating redundant code.
05:50:04 <swisscheese> And if I comment out my code I have to change uses of the type all over the app.
05:51:30 <shapr> swisscheese: ok, use this file then: http://shapr.homelinux.net/~shae/ProtoSwiss.hs
05:53:34 <shapr> swisscheese: found the problem?
05:54:57 <shapr> swisscheese: can you write the Eq instance into that file?
05:55:20 <swisscheese> Thanks for the file but I understood such code from the chat. But if I comment out my code my app will not work.
05:58:32 <swisscheese> Same error with:
05:58:32 <swisscheese> module Main where
05:58:33 <swisscheese> data NodeType = NodeConstructor Int deriving Show
05:58:33 <swisscheese> instance Eq NodeType where
05:58:33 <swisscheese> (NodeConstructor x) == (NodeConstructor y) = x == y
05:59:23 * shapr blinks
05:59:33 <swisscheese> c:\ghc\ghc-6.2\bin>ghc -o main main.hs
05:59:34 <swisscheese> main.hs:4:
05:59:34 <swisscheese>     Ambiguous occurrence `=='
05:59:34 <swisscheese>     It could refer to either `GHC.Base.==', imported from Prelude at main.hs:1
05:59:34 <swisscheese>                           or `Main.==', defined at main.hs:4
06:01:54 <shapr> swisscheese: do you have four spaces in front of the second line of that instance declaration?
06:03:40 <shapr> instance Eq NodeType where
06:03:40 <shapr>     (NodeConstructor x) == (NodeConstructor y) = x == y
06:04:11 <shapr> if you don't have any spaces in front of that second line, GHC thinks you're defining a new function/operator named ==
06:04:20 <swisscheese> Oops! But now I get Duplicate instances declaration.
06:04:50 <shapr> what sort of dupes?
06:06:01 <shapr> as in, what's the error?
06:06:20 <swisscheese> OK, seems I had to use deriving Show not deriving (Show,Eq)
06:07:03 <shapr> right, that's because Eq and Show can both be automatically derived
06:07:21 <shapr> but, on the original subject, have you seen the problem with your first instance declaration?
06:07:43 <shapr> instance Eq Nodes where
06:07:44 <shapr>     Nodes x _ _ _ _ _ _ _ == Nodes y _ _ _ _ _ _ _ = x == y
06:07:56 <shapr>     ^^^^^ what's this?
06:08:07 <swisscheese> Yes should be Node
06:08:11 <shapr> right
06:08:28 <shapr> I have that problem myself when I pick too similar names for the type and the constructors
06:09:12 <swisscheese> It seems strange to need two different names for the same thing!
06:09:32 <shapr> but they're not the same thing at all.
06:11:00 <shapr> data Tree a = Nil | Node (Tree a) a (Tree a) deriving Show
06:11:34 <shapr> that says, a Tree is either Nil, or it's a Node holding two other Tree types and some type a
06:12:45 <shapr> so, a bunch of Nodes might be a shape
06:13:10 <shapr> actually, I don't know what you're writing...
06:13:15 <shapr> what do all your nodes do anyway?
06:13:43 <swisscheese> I guess when not using the "|" it seems strange to need two names.
06:15:27 <shapr> maybe there's a better name for this thing that has a position and a bunch of Int ?
06:18:50 <swisscheese> If so I would want to use it as the type and constructor. If we have a type chair and a way of making chairs their still chairs. 
06:23:58 <swisscheese> When you code and you have type data statement without a "|" how do you choose the names? Chair and ChairConstructor?
06:28:16 <jlouis> data Chair = Rocking ... | Sofa ... | NormChair ... | KitchenChair ... | Taburet .... 
06:28:19 <jlouis> etc
06:28:45 <swisscheese> Yes but when there is no "|" then what?
06:29:23 <jlouis> then you have a single type constructor
06:30:05 <jlouis> assume: data Point = PT int int int and data Vector = Vec int int int
06:30:23 <jlouis> without the constructor, how would you know if it were points or vectors?
06:31:11 <swisscheese> OK, it just feels strange to have make up two different names for the same thing.
06:31:27 <jlouis> the point is that they are not the same
06:31:44 <swisscheese> OK
06:31:58 <jlouis> even if they have the same representation in primitive types
06:34:16 * Lunar^ loves Haskell
06:34:36 <Lunar^> Took less than one hour to daemonize my wanabee-daemon
06:35:25 <swisscheese> Thanks guys! Gotta log out. Bye.
06:35:41 <shapr> cya
06:38:36 <cptchaos> Lunar^: how daemonic is your deamon yet?
06:39:24 <Lunar^> cptchaos: Goes nicely in the background, create a PID file, handle HUP and TERM signals nicely
06:39:31 <shapr> neat
06:39:42 <Lunar^> (the nice kind of daemon, you know ;))
06:40:05 <cptchaos> yes neat
06:40:29 <Lunar^> The question is, what to do next... take a nap, or start coding this damn assembler
06:41:15 <Lunar^> Maybe I should write GHC team to ask advice about reusing their datatypes (making 'as' optional to GHC would be great)
06:41:46 <cptchaos> what kind of an assembler do you wand to write?
06:41:51 <Taaus> jlouis: NormChair? Is that one of the barstools from Cheers? ;)
06:42:01 <Lunar^> IA32 to start, we'll need it soon for hOp
06:42:21 <cptchaos> sorry, what is hOp?
06:42:35 <Lunar^> To quote shapr : GHC RTS on the metal
06:42:59 <shapr> yeehaa!
06:43:15 <shapr> "GHC RTS on the bare metal" is more accurate.
06:43:15 <Lunar^> http://www.macs.hw.ac.uk/~sebc/hOp/ and http://etudiants.insia.org/~jbobbio/hOp/
06:43:26 <Lunar^> shapr: ok :)
06:43:42 <cptchaos> hm, I for a while habe been thinkin of an runtimesystem for haskell
06:43:52 <shapr> Lunar^: how're the IRQ handlers doing?
06:44:05 <shapr> I'm looking forward to playing with hOp, but I don't understand much at the moment.
06:44:08 <cptchaos> that shuld be nearly as fast as ocaml, but i am not far jet
06:44:20 <Lunar^> shapr: I'm unhappy with what I found studying JNode
06:44:34 <Lunar^> shapr: It was intersting, but it's not going to help hOp
06:44:53 <Lunar^> shapr: I'm waiting for Marlow's feedback
06:45:18 <Lunar^> shapr: What don't you understand ?
06:45:37 <cptchaos> woot hOp is cool,
06:46:28 <Lunar^> (btw, we're going to have to rewrite the current scheduler, it doesn't handle priority at all, which is quite bad to make an OS)
06:53:01 <jlouis> Taaus: exactly
06:56:20 <shapr> does masked interrupts mean that you get a queue of pending interrupts?
06:56:23 <shapr> or do they just get dropped?
06:57:50 <shapr> iirc, Linux has top-half and bottom-half in each IRQ handler. the top-half must be small and cannot be interrupted, but in can setup larger thing to happen later in the bottom-half, which can be interrupted.
06:57:58 <shapr> it's sort of like kernel/user space in kernel-space.
06:58:55 <jlouis> by the way, when cooking, remember to look at the due-date. I just had to call the continuation set before I started
06:59:15 <shapr> ?
06:59:52 <jlouis> shapr: You've never heard about real-world continuations? Mighty stuff. call/cc before having an argument with your spouse and such
06:59:59 <shapr> :-)
07:00:06 <shapr> would be nice, I admit.
07:00:20 <jlouis> I am just messing around in my kitchen
07:23:19 <Lunar^> shapr: Masked interrupts mean that you get a queue yea
07:23:35 <Lunar^> shapr: Linux kernel is not multi-thread, AFAIK
07:24:08 <shapr> how does it deal with SMP interrupts?
07:24:19 <Lunar^> shapr: We're in a really different set up there, our IRQ handlers just needs to fetch some data and put them in a larger buffer, I think
07:24:34 <Lunar^> shapr: dunno
07:25:07 <Lunar^> shapr: The larger buffer would then be processed by the driver thread
07:25:48 <Lunar^> I think that could work... I no experience in OS programming at all (which is not sebc case)
08:20:25 <liiwi> hi
08:50:18 <shapr> Lunar^: I also have no experience OS programming.
09:12:22 * Marvin-- shudders as he helps a friend with a C++ assignment
09:12:38 <Maddas> Friends don't let friends use C++!
09:13:00 <Marvin--> well, it's either that or flunk for him, I guess
09:13:04 <Maddas> :-)
09:14:15 <ecraven> Maddas: now i have to decide on either a new cpu/mainboard or the keyboard.. :(
09:14:49 <Maddas> ecraven: Think about it this way: What good is a faster CPU if you don't like typing.
09:14:49 <Marvin--> wow, that sounds like an expensive keyboard
09:15:08 <Maddas> s/\./?/, too
09:15:43 <Maddas> I mean hey, with a better keyboard, you'll be having a benefit whenever you type. I doubt your CPU will be notably better for everything :)
09:15:48 <Maddas> But then again, how fast is it? And how fast is what you have now?
09:16:23 * shapr lags horribly
09:16:35 * Marvin-- goes to wash his hands
09:16:46 <ecraven> p3 800.. i'd want something like 2.5 to 3ghz
09:16:49 <shapr> eek: cute nickname.
09:17:03 <Maddas> eek the cat?
09:17:08 <Marvin--> eek
09:17:13 <Maddas> ecraven: Hrm. Where do you live?
09:17:21 <Marvin--> so... we have eek and whee, what's next?
09:17:33 <Marvin--> "Welcome to #onomatopoeia!"
09:17:38 <Maddas> haha
09:17:47 * boing grins evilly
09:17:59 <Maddas> /nick yay
09:18:03 <ecraven> Maddas: austria
09:18:16 <boing> don't you guys have kangaroos?
09:18:22 * boing pretends to be a clueless american.
09:18:22 <Maddas> haha
09:18:24 <Marvin--> hahaha
09:18:25 <ecraven> <*G*>
09:18:36 <eek> boing: thanks - but it is just an abbreviation of my initials...
09:18:41 <Marvin--> well, this was the first time I've coded C++ for several years
09:18:44 <ecraven> well, you'll find some for sure..
09:18:47 <Marvin--> went better than I expected
09:18:54 <ecraven> lots of zoos tend to have them :)
09:18:57 <Maddas> boing: Next thing you need to ask me is if Switzerland isn't that small country under Australia
09:18:58 <Marvin--> forgot some namespace crud and stuff, but after that...
09:18:59 <boing> eek: even so, you could have chosen ee or eie
09:19:11 <Maddas> (Or the one next to Norway with all the large, blonde people)
09:19:54 <Marvin--> Maddas: considering that he's *living* in that country next to Norway with all the large(tall?), blonde people...
09:20:00 <eek> shapr: ee wasn't free at the time - I used to use that.
09:20:46 <dennisb> look at it on the bright side, it's easier to write eek now with tab completion!
09:21:03 <eek> dennisb: *grin*
09:21:04 <Marvin--> note to self: STL is a horrible horrible mess
09:21:06 <Maddas> Marvin--: err, yes, tall, not large :-)
09:21:22 <dennisb> Marvin--: it's very ugly, but not that bad to use
09:21:57 <dennisb> templates is very much C/C++ so don't compare it to haskell (maybe to template haskell)
09:21:59 <eek> Marvin--: everything popular is a horrible mess, unfortunately :-/
09:22:14 <Marvin--> iterators scare me
09:23:12 <shapr> so, eek, are you learning Haskell?
09:23:14 <eek> Marvin--: I'm used to them from Ruby, where they work extremely well - but they used to scare me, too
09:23:18 <Riastradh> Fold is so superior to cursors.
09:23:28 <eek> shapr: I'll probably try to pick it up again - programmed it a little 7-8 years ago
09:25:42 <shapr> have any specific questions?
09:25:49 <shapr> want to write a lambdabot plugin? :-)
09:26:01 <shapr> maybe you're looking at darcs for source control ideas?
09:27:15 <Marvin--> does darcs have a haskell api?
09:27:22 <Marvin--> I mean, like libsvn/python-subversion/et.c.
09:27:29 <Marvin--> that'd be neat
09:27:39 <shapr> you should ask David, that's a good idea.
09:27:57 <Marvin--> course, having a good C api would be cool too
09:28:19 <Marvin--> and shouldn't be much harder
09:30:14 <shapr> Marvin--: hey, I'm going to do some hws-wp maintenance soon in preparation for Hopi, are you too busy/frustrated/burned-out to answer hws-wp questions? 
09:30:34 <shapr> or should I trade proofreading for questions? :-)
09:30:47 <Marvin--> ask away, but don't expect speedy and knowledable answers :)
09:30:51 <shapr> fair enough
09:31:05 <Marvin--> guh, I really really need to get a new release of pyopenssl out the door too
09:32:01 <shapr> wagle: hey, you're at ogi.edu
09:32:17 * shapr wonders if wagle is one of the rich and famous Galois people.
09:32:38 <Marvin--> heh
09:33:21 <shapr> eek: är du dansk?
09:35:01 <eek> shapr: nei - norsk
09:35:11 <shapr> oh, ok
09:35:19 <shapr> jag är Alabamisk ;-)
09:36:03 <Marvin--> eek: hej granne :)
09:36:04 <shapr> let's see, sweden - svenska, norge - norsk, Alabama - alabamisk, right?
09:36:06 <Taaus> Argh! Skandinavien angriber!
09:36:35 <shapr> ja!
09:36:36 <eek> shapr: that should be about right :-)
09:36:46 <eek> Marvin-- hei, nabo :-)
09:37:10 <eek> Taaus: tja - hvis vi slår oss sammen kan vi vinne mot svensken - dansk og norsk er mye nærmere hverandre ;)
09:37:31 <shapr> gee, we could start #haskell-nordic
09:37:34 <Taaus> eek: Sandt nok. :D
09:37:35 <Marvin--> hjÃ¤Ã¤Ã¤lp
09:37:40 * shapr laughs
09:38:04 <shapr> I think the cool clarity of Scandinavia encourages clear and calm thinking, so people choose Haskell.
09:38:21 <Maddas> elmex! now we even have Toothpaste.
09:38:26 <shapr> yay!
09:38:32 <shapr> @yow !
09:38:33 <lambdabot> Are we THERE yet??
09:38:37 <eek> I personally think it's the excessive drinking that gives vision ;)
09:38:42 <shapr> haha!
09:38:43 <Taaus> shapr: And the majestic møøses encourage it as well.
09:38:47 <norpan> sÃ¥ Ã¤r det
09:39:02 <shapr> heey! we can use ø in dns names now, right?
09:39:10 <shapr> I can purchase møø.se !
09:39:11 <eek> shapr: unfortunately, yes.
09:39:26 * shapr dances happily
09:39:37 <shapr> that's almost as good as Scanned In Avian.
09:42:19 <maihem> shapr: "we can use  in dns names now" - what should I have seen in the double space?
09:42:35 * jlouis is not scandinavian then
09:42:36 <Taaus> maihem: o-slash
09:43:04 <maihem> oh
09:43:38 <Taaus> jlouis: Because you don't think clearly, or because you don't drink excessively?
09:43:56 <jlouis> the latter. maybe both
09:44:17 * shapr grins
09:44:29 <shapr> I don't drink excessively either, I never did fit in with the other Alabamiska.
09:45:36 <Maddas> hm, Haskell is good
09:46:07 <Maddas> (But maybe you knew that already)
09:46:11 <Maddas> :-)
09:46:18 <shapr> I agree!
09:46:20 <shapr> all in favor?
09:46:26 <Taaus> Aye!
09:46:27 <bring> ay!
09:46:36 <shapr> the motion is passed.
09:46:42 <Maddas> hooray!
09:47:44 * jlouis mumbles about SML
09:48:02 <eek> Haskell is so far the best functional language I've seen - I've just not quite decided if I like functional languages.  but Haskell definately looks extremely good for its niche.
09:48:18 <Maddas> eek: What niche would you say that is?
09:48:28 <stepcut> Maddas: kickin' butt!
09:48:39 <stepcut> and takin' names
09:48:46 <shapr> I for one welcome our new functional overlords.
09:48:55 <Marvin--> heh
09:49:18 <shapr> I figure Sunday night is a good time to be silly.
09:49:27 <eek> Maddas: functional programming language, type unification based.
09:49:45 <stepcut> so... what's the fastest way to turn a C array into a Haskell Array?
09:50:03 <stepcut> and vice-versa
09:51:48 <shapr> use the FFI?
09:52:00 <norpan> what do you mean by turning it into?
09:53:59 <stepcut> well, the ffi has a function, peekArray that returns a list of the C array
09:54:15 <stepcut> but I want an unboxed array of the C array
09:57:55 <stepcut> something like: GHC.Array.IO.hGetArray but for a Ptr () instead of Handle
10:01:30 <stepcut> actually, to be really specific, I just want to do this operation faster: 
10:01:35 <stepcut> (peekArray length ((#ptr struct mad_synth,  pcm.samples) synth)) >>= (newListArray (1,length))  :: IO (IOUArray Int Int32)
10:58:08 <stepcut> ah, I see now: (STUArray l u ptr)
11:31:32 <shapr> yow!
11:31:47 <shapr> good evening everyone, what's going on?
11:32:12 <shapr> any Haskell questions?
11:32:29 <stepcut> what does the # mean in this line: data MutableByteArray s ix = MutableByteArray ix ix (MutableByteArray# s)
11:32:40 <shapr> unboxed probably
11:33:12 <shapr> the hash almost always means that in cases of array
11:33:24 <stepcut> are MutableByteArray and MutableByteArray# two different data types?
11:33:31 <shapr> probably so
11:33:36 * shapr asks ghci
11:33:53 <shapr> where do you find those?
11:34:13 <Igloo> MutableByteArray# there is a data constructor
11:34:32 <Igloo> Oh, no, I'm cnofused
11:35:20 <Igloo> shapr is almost certainly right, anyway
11:35:37 <Igloo> Hi Syn
11:35:48 <shapr> hey SyntaxLaptop
11:35:57 <SyntaxLaptop> hi shapr, Igloo
11:36:16 <SyntaxLaptop> Igloo: when I uploaded darcs, I got an email that says this. do you know what it means:
11:36:18 <shapr> stepcut: where'd you find thoes guys?
11:36:18 <SyntaxLaptop> Your package contains new components which requires manual editing of
11:36:18 <SyntaxLaptop> the override file.  It is ok otherwise, so please be patient.  New
11:36:18 <SyntaxLaptop> packages are usually added to the override file about once a week.
11:36:18 <SyntaxLaptop> You may have gotten the distribution wrong.  You'll get warnings above
11:36:19 <SyntaxLaptop> if files already exist in other distributions.
11:37:10 <shapr> SyntaxLaptop: oh, you DID package darcs?
11:37:29 <Igloo> Basically if you upload something with a new package name it takes about a week for the FTP guys to sanity check it
11:37:53 <shapr> is that to keep from having new packages named ghcc or so?
11:37:53 <ibid> it can be anything from an hour to several months
11:37:54 <Igloo> They tend to look at basic quality as well as doing things like encryption export notification as necessary
11:37:55 <SyntaxLaptop> shapr: well, I uploaded it with a few small changes :)
11:38:10 <shapr> yay, I'll change the topic of #darcs
11:38:13 <ibid> but i don't know how things are today
11:38:20 * ibid is former ftpmaster :)
11:39:07 <stepcut> shapr: inside a STUArray
11:39:27 <[3N1GM4]> Is it possible to terminate a haskell program from anywhere in the code with a one line error message displayed on termination?
11:39:34 <[3N1GM4]> and if so, how?
11:39:42 <shapr> error ?
11:39:43 <stepcut> error "fail now"
11:39:54 <[3N1GM4]> k, cheers.
11:39:58 <shapr> greetings Si2, have any questions?
11:41:53 <[3N1GM4]> is there a pastebin where I can dump some code?
11:42:24 <shapr> yes
11:42:25 * shapr gets url
11:42:29 <[3N1GM4]> lol, thanks
11:42:37 <shapr> @wiki HaskellIrcPastePage
11:42:37 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:42:45 <ibid> [3N1GM4]: laughing out loud?
11:43:09 <[3N1GM4]> sorry, I got a warped sense of humour, adn I just like usage of /me
11:43:16 * [3N1GM4] like /me
11:44:29 <[3N1GM4]> ok, I've put some code up there, which I want to get to work. It's part of a larger prog, but basically, I need convert to classify a string to a shape, else return the error messgae "Invalid" and exit...
11:45:02 <[3N1GM4]> it's just the syntax of the error that is a problem, the program works fine without it, but cant handle an empty string...
11:45:26 <SyntaxLaptop> OK I uploaded darcs to HE as well.
11:45:29 <shapr> you should check out pattern matching.
11:45:30 <SyntaxLaptop> (in the meantime
11:45:31 <SyntaxLaptop> )
11:45:33 <shapr> yay!
11:45:53 <Igloo> shapr: Can you let me know when you've installed it on whatever machien wikiwiki is in please?
11:45:58 <shapr> yes!
11:46:34 <shapr> installing now...
11:47:13 <shapr> eek!
11:47:17 <shapr> umm
11:47:21 <Igloo> ?
11:47:36 <shapr> I ran convert-repo and got:
11:47:42 <shapr> Already have 20040119235239-03db8-bbc894d110c47837c611c33d2e02819ac71ec941.gz
11:47:42 <shapr> Already have 20040119233002-03db8-39a7f40c9e119cf9ee0509c38ae3444a0932decf.gz
11:47:42 <shapr> Fail: createDirectory: does not exist (No such file or directory)
11:49:16 <shapr> since those are the only two patches in the repo, I assume the repo doesn't need converting, but I think there's still a bug.
11:49:31 <shapr> Igloo: try pushing your patch now.
11:50:10 <Igloo> Mail away...
11:50:22 <shapr> Mail overboard!
11:50:48 <shapr> you should have a reply now.
11:51:49 <[3N1GM4]> ok, but how should I use the error function to get it to do what I want? i.e. if the first word of the string is none of the 3 preset shapes, then terminate prog and show msg?
11:52:29 <shapr> [3N1GM4]: have you seen the Read class yet?
11:52:40 <shapr> [3N1GM4]: yes, using error that way should work.
11:52:41 <[3N1GM4]> I have heard of it...
11:52:49 <shapr> you may want to investigate it.
11:53:01 <[3N1GM4]> it should work the way I am using it now?
11:53:08 <shapr> have you tried to read the Shape type from a string?
11:53:47 <shapr> Igloo: did it work? or did you get a failed patch reply?
11:54:18 <Igloo> Well the file on the website doesn't look to have changed. I'll check mail in a sec
11:54:19 <[3N1GM4]> shapr: no, I split the string into fields using words, becuase number of fields is dependent on the shape, and then I have a function toShape which makes the Shape...
11:54:56 <[3N1GM4]> oh, it's not working, because I use head on an empty list in the case of an empty string...
11:55:56 <shapr> *Shape> read "Circle (1.0,1.0) 1.0" :: Shape
11:55:56 <shapr> Circle (1.0,1.0) 1.0
11:55:57 <shapr> works for me.
11:56:25 <[3N1GM4]> ok, got it working now, but it outputs: "Fail: Invalid", I just want "Invalid"
11:56:39 <shapr> I think you don't get to choose that part.
11:57:18 <[3N1GM4]> ok, I'll do it another way, set up a shape type called Invalid and if that gets passed back, then I'll output the appropriate string without using error
11:57:30 <[3N1GM4]> cheers for your help anyways
11:57:49 <shapr> is it part of your assignment to write a string -> shape function?
11:58:00 <shapr> or do you just need to turn strings into shapes?
12:00:03 <shapr> hey Heffalump, what's up?
12:00:14 <shapr> darcs is also in HE
12:00:33 <[3N1GM4]> it is just part of the assignment...
12:00:37 <Heffalump> not much, apart from various personal stresses (nothing serious, just very annoying)
12:00:43 <Igloo> So far so good... finished merging.
12:00:46 <Igloo> Caught exception:
12:00:46 <Igloo> ./_darcs/inventory: openBinaryFile: permission denied (Permission denied)
12:00:56 <shapr> Igloo: I just noticed that, it's fixed now, (I think)
12:01:08 <shapr> Heffalump: well, I hope it gets better.
12:01:10 <Igloo> Was it your fault or a darcs issue?
12:01:14 <shapr> I find that writing Haskell code relaxes me.
12:01:23 <Heffalump> I'm writing perl to relax, right now :-)
12:01:23 <shapr> it was a darcs issue in 0.9.16
12:01:25 <shapr> haha
12:01:28 <[3N1GM4]> I just need a way to tell if the supplied string is empty or not one of the three shapes, and in that case output a string "Invalid"
12:01:31 <Heffalump> I should probably leave the channel in shame.
12:01:42 <[3N1GM4]> I'll post whole prog so you can see...
12:01:47 <shapr> well, if it relaxes you, keep it up.
12:02:25 <shapr> Igloo: darcs 0.9.16 was using setPermission or something (see thread on ghc-users) so that ended up with _inventory being u+rw and nothing else.
12:02:38 <Igloo> Ah, yes, I remember the thread
12:02:39 <[3N1GM4]> ok, it's at: http://www.haskell.org/hawiki/HaskellIrcPastePage
12:02:58 <Igloo> Woo! http://www.scannedinavian.org/repos/wikiwiki/README
12:03:11 <shapr> yay!
12:03:44 <Igloo> Did it merge that automatically?
12:03:44 <shapr> yes
12:03:44 <Igloo> I wonder how it decided what order to put things in
12:03:44 <shapr> I don't know, that's a good question.
12:04:00 <shapr> anyways, I think darcs can solve your problem with wikis.
12:05:12 <shapr> if each wiki page save is a darcs record, the user could resolve any conflicts automatically.
12:05:19 <shapr> and no info would be lost.
12:06:07 <shapr> MistaHyde: so, you're very specifically requested to write the code to turn a String into a Shape?
12:06:38 <MistaHyde> er, yeah, it's the main part of the assignment I guess.
12:06:45 <MistaHyde> sorry, didnt mean to change name...
12:07:04 <[3N1GM4]> better
12:07:40 <Igloo> shapr: Presumably darcs sometimes tells you to fix conflicts yourself. If you can make a nice web interface on top of that you'd have a good wiki, yes
12:07:40 <shapr> so, does it work?
12:07:52 <shapr> Igloo: would you actually use such a wiki? :-)
12:08:01 <Igloo> (nice web interface could just be a text area if darcs normally expectes you to just edit a file)
12:08:03 <[3N1GM4]> does mine work?
12:08:05 <Igloo> Of course
12:08:31 <Igloo> I have nothing against collaborative editable pages, just stupid conflict resolution on them
12:08:32 <[3N1GM4]> yes, it works fine, but cant yet handle empty lines in the string array or shapes not of the 3 set types...
12:09:27 <Igloo> Well, I'm not a fan of WikiWords, but that wouldn't stop me using it
12:09:39 <Igloo> Do WikiWords in Haskell code got linkified?
12:09:44 <Igloo> s/got/get/
12:10:30 <shapr> for MoinMoin, not if you put {{{ }}} around the code
12:12:27 <shapr> SyntaxLaptop: hah, I like your can of worms response
12:13:36 <SyntaxLaptop> hehe
12:13:57 * Igloo looks confused at the maths on http://www.abridgegame.org/pipermail/darcs-users/
12:13:58 <SyntaxLaptop> I was going to say something like "I don't think I'll ever stop looking inside all those bright, shiny, colorful cans, even though I know they all have worms in them"
12:18:28 <[3N1GM4]> http://www.haskell.org/hawiki/HaskellIrcPastePage This is hurting my brain... I just need to write a function which takes a list of shapes and checks each shape in the list to see if it is Invalid, rather than Circle, Rectangle or Triangle...If it is Invalid, I need it to return a string "Invalid"...
12:18:50 <[3N1GM4]> I mean, if ANY of the shapes are Invalid, it returns that string...
12:19:55 <Igloo> 3N1GM4: So have you attempted to write such a thing?
12:20:34 <[3N1GM4]> yes, I tried to write one which looped recursively through each shape, but I dont see how I will get it to work without some kind of flag, which I also do not know how to do...
12:20:48 <Marvin--> cool, subversion 1.0 on the way
12:21:01 <Riastradh> Bah.  Just use Darcs!
12:21:15 <Igloo> OK, have you got a type signature for what you want? That's generally the best place to start
12:21:55 <shapr> Marvin--: have you tried darcs?
12:22:03 <[3N1GM4]> sure: checkLines :: [Shape] -> String
12:22:05 <[3N1GM4]> yeh?
12:22:15 <Marvin--> shapr: of course I have
12:22:37 <Marvin--> don't currently have a project stored in a darcs repo though
12:22:39 <Igloo> 3N1GM4: OK, so what 2 basic cases do you need to consider?
12:23:05 <[3N1GM4]> a shape which is one of the 3 defined, and then anything else...
12:23:14 <shapr> I have a bunch of plone archetypes stored in one that I use everyday.
12:23:24 <shapr> my work code :-)
12:24:08 * Igloo realises something - what's this function supposed to return if there is no Invalid shape?
12:24:19 <[3N1GM4]> There is an invalid shape.
12:24:36 <Igloo> No, I mean if there is no Invalid shape in the list you pass it
12:25:24 <[3N1GM4]> doesn;t matter, it will be tested by an if, so like: if checkLines a == "Invalid" then.... else...etc
12:25:39 <Igloo> But it needs to return /something/
12:25:45 <[3N1GM4]> just an empty string would be fine then.
12:25:56 <Igloo> OK
12:26:30 <Igloo> So the two cases I meant above were the empty list and a non-empty list. For the empty list case, what should the function do?
12:26:54 <[3N1GM4]> return an empty string.
12:27:13 <Igloo> OK, so how do you write that as Haskell code?
12:27:26 <[3N1GM4]> checkLines[] = ""
12:28:26 <Igloo> Right - what might the left hand side of the next case look like?
12:28:31 <[3N1GM4]> actually, an empty list would need to return "Invalid"
12:28:36 <[3N1GM4]> checkLines[] = "Invalid"
12:28:40 <Igloo> Why?
12:28:51 <[3N1GM4]> because if no shapes are supplied, there can be no output...
12:28:58 <[3N1GM4]> no area and no average centre
12:30:08 <Igloo> OK, I suggest you leave it as "" for now and worry about that later
12:30:25 <[3N1GM4]> ok, I could always test for an empty string array in function shape...
12:30:47 * Taaus mumbles something about the Maybe type
12:30:58 <[3N1GM4]> like shape[] = "Invalid"
12:31:12 <[3N1GM4]> oh, I already have that line!
12:31:14 <[3N1GM4]> whoops.
12:31:22 <[3N1GM4]> ok, so:
12:31:26 <[3N1GM4]> checkLines :: [Shape] -> String
12:31:26 <[3N1GM4]> checkLines[] = ""
12:31:39 <[3N1GM4]> now something along the lines of checkLines(x:xs) = ?
12:32:14 <Igloo> OK. Now, suppose x is Invalid. What should the result be?
12:32:36 <[3N1GM4]> "Invalid"
12:32:52 <Igloo> OK, and suppose it's not Invalid, what should the result be?
12:32:57 <[3N1GM4]> ""
12:33:36 <Igloo> What would that make    checkLines [Rectangle p1 p2, Invalid]?
12:35:05 <[3N1GM4]> wait, what does [Rectangle p1 p2, Invalid] represent? A list of Rectangles? Why the Invalid field?
12:35:09 <[3N1GM4]> bit confused now.
12:35:36 <Igloo> [Rectangle p1 p2, Invalid]   is the same thing as   (Rectangle p1 p2):Invalid:[]
12:36:18 <[3N1GM4]> oh, ok, that's a list where the first element is a rectangle and the second an Invalid?
12:36:24 <Igloo> Yup
12:36:44 <[3N1GM4]> ok, well I would want that to return "Invalid", as one of the shapes is invalid.
12:37:13 <Igloo> OK, but more generally, if you have   checkLines(x:xs)   and x is not Invalid what do you want to return?
12:37:29 <[3N1GM4]> checkLines xs
12:37:39 <[3N1GM4]> carry on looking for an Invalid.
12:37:43 <Igloo> Right! Now can you write that as  Haskell?
12:37:47 <[3N1GM4]> ok, one sec.
12:38:03 <[3N1GM4]> checkLines(x:xs) = 
12:39:07 <[3N1GM4]> if x == Invalid then "Invalid"
12:39:25 <[3N1GM4]> else checkLines xs ?
12:39:34 <[3N1GM4]> that's not right.
12:39:40 <Igloo> Why not?
12:39:49 <[3N1GM4]> no case for a valid list of shapes...
12:39:53 <[3N1GM4]> no return of ""
12:40:06 <Igloo> The [] case returns "", no?
12:40:12 <[3N1GM4]> ah, of course.
12:40:20 <[3N1GM4]> ok, thanks I'll try that now, one moment..
12:42:31 <[3N1GM4]> it doesn;t like: if x == Invalid then
12:42:37 <[3N1GM4]> the == specifically
12:42:58 <Marvin--> that's because you haven't defined how == should behave for Shapes
12:43:29 <Marvin--> but there's a simpler solution, you can use pattern matching instead
12:43:55 <Cale> or you can put "deriving (Eq)" after the data declaration.
12:44:40 <Cale> but if you can use pattern matching, I'd recommend that
12:45:19 <[3N1GM4]> or you can put "deriving (Eq)" after the data declaration.<---------Ok, that works, but why?
12:45:46 <Marvin--> == is defined in the class Eq, like show is defined in the class Show
12:46:04 <Igloo> Pattern matching would look like
12:46:06 <Igloo> case x of
12:46:07 <Marvin--> so a "normal" definition of == would be    instance Eq Shape where x == y = ...
12:46:10 <Igloo>     Invalid -> "Invalid"
12:46:20 <Igloo>     _ -> whateveritwas xs
12:46:43 <Marvin--> [3N1GM4]: but you can have the compiler generate simple Eq (and Show for example) instances automatically
12:46:43 <Igloo> (  _ is a pattern that matches anything)
12:46:57 <[3N1GM4]> right, I think I get you.
12:47:42 <[3N1GM4]> but it works, so yey!
12:52:21 <[3N1GM4]> right, time for dinner then.
12:52:25 <[3N1GM4]> Thanks again for all your help.
14:33:16 <shapr> yow!
14:33:28 <shapr> it's happiness in a bottle!
14:33:36 <shapr> too bad we can't open it!
14:50:47 <DeezNuts> map Char.toUpper "Hello World"
14:50:49 <DeezNuts> isn't working
14:51:42 <shapr> what's wrong with it?
14:52:23 <DeezNuts> Prelude> map Char.toUpper "Hello, World!"
14:52:23 <DeezNuts> ERROR - Undefined qualified variable "Char.toUpper"
14:52:28 <shapr> *Shape Data.Char> map toUpper "Hello World"
14:52:29 <shapr> "HELLO WORLD"
14:52:36 <shapr> DeezNuts: oh, try import Data.Char
14:53:00 <DeezNuts> map Data.Char.toUpper "Hello World"
14:53:02 <DeezNuts> worked
14:53:02 <DeezNuts> thanks
14:53:22 <DeezNuts> dont know why the tutorial would specificy the Char. part but not the Data. part...
14:53:35 <SyntaxLaptop> DeezNuts: the libraries move around sometimes, the tutorial is probably out of date
14:53:44 <SyntaxLaptop> maybe you can email the author to let them know
14:54:31 <Cale> toUpper is in the module Char in Haskell 98 though. import Char should work.
14:55:02 <DeezNuts> i did :load Char in hugs and it didn't work
14:55:12 <DeezNuts> and u can't run import statements in the interactive interpreter
14:55:28 <shapr> try :module + Data.Char
14:55:45 <DeezNuts> :module + Data.Char
14:55:56 <DeezNuts> ERROR - Cannot find module "+"
14:56:10 <Cale> (it's not the same as ghci)
14:56:32 <shapr> DeezNuts: ok, use GHCi ;-)
14:56:40 <shapr> unless you have a slow computer.
14:56:43 <DeezNuts> can't im on linux-ppc
14:56:49 <DeezNuts> i have a fast computer
14:56:51 <SyntaxLaptop> Prelude> :load Char
14:56:51 <SyntaxLaptop> Char> map toUpper "Test"
14:56:51 <SyntaxLaptop> "TEST" :: [Char]
14:56:51 <SyntaxLaptop> Char> map Char.toUpper "test"
14:56:51 <SyntaxLaptop> ERROR - Undefined qualified variable "Char.toUpper"
14:57:06 <SyntaxLaptop> (that's hugs)
14:58:03 <DeezNuts> ya
14:58:10 <Cale> hugs is odd
14:58:10 <DeezNuts> how come Data. works though
14:58:21 <DeezNuts> Data.Char.toUpper worked
14:58:25 <Cale> yeah
14:58:28 <Cale> I don't know
14:58:28 <DeezNuts> even though I loaded Char as you did
14:58:32 <DeezNuts> hm
14:58:38 <DeezNuts> damnit i want ghci
14:58:52 <Cale> If I had a ppc machine around, I'd build it for you.
14:59:06 <Cale> Hey, maybe I can use one of the computer science club's machines.
14:59:07 <DeezNuts> heh thanks man :) if i get into haskell enough i will build one
14:59:17 <DeezNuts> kewl :)
14:59:29 <SyntaxLaptop> DeezNuts: hugs is pretty good, though :)
15:00:03 <DeezNuts> hih I wouldn't know
15:00:06 <DeezNuts> *heh
15:00:16 <SyntaxLaptop> DeezNuts: you use a PPC-based Linux distro? which one?
15:00:21 <DeezNuts> gentoo-ppc
15:00:35 <DeezNuts> its pretty good overall
15:00:51 <SyntaxLaptop> debian offers prebuilt ghc stuff for powerPC: http://packages.debian.org/cgi-bin/search_packages.pl?keywords=ghc&searchon=names&subword=1&version=all&release=all
15:00:52 <DeezNuts> there's even a moderately up-to-date jdk (1.4.1 from IBM)
15:01:02 <DeezNuts> ya but I'm not about to go debian just for that :p
15:01:07 <DeezNuts> but i did see those
15:01:15 * SyntaxLaptop should resist the urge to make everyone use Debian and Haskell :)
15:01:37 <DeezNuts> lol
15:01:40 <DeezNuts> have u tried gentoo?
15:01:58 <DeezNuts> i haven't tried debian but from what i hear gentoo is debian++
15:01:58 <SyntaxLaptop> nope. I promised myself that I would stick to one distro a few years ago so I could truly learn :)
15:02:05 <DeezNuts> kew
15:02:23 <SyntaxLaptop> there's a handful of Debian Developers on here actually. I picked Debian because it's what all my friends use, so it's easy for me to get help.
15:02:26 <DeezNuts> gentoo builds everything from source (or most things)
15:02:33 <DeezNuts> kew
15:02:40 <DeezNuts> i use redhat at work even though i hate it
15:02:46 <SyntaxLaptop> heh
15:02:50 <DeezNuts> cuz its whats most supported for commercial apps
15:03:05 <SyntaxLaptop> yeah.
15:03:26 <DeezNuts> actually ibm does make internal ebuilds for most of their apps
15:03:34 <DeezNuts> so i could prolly get away with using gentoo at work at some point
15:03:50 <DeezNuts> my main blocker at this point is ClearCase
15:04:08 <SyntaxLaptop> DeezNuts: I've heard good things bout gentoo.  if you run into a Debian vs Gentoo comparison, point me to it. 
15:04:13 <SyntaxLaptop> does clearcase use kernel modification?
15:04:31 <DeezNuts> ya
15:04:38 <DeezNuts> clearcase has something called mvfs
15:04:42 <SyntaxLaptop> seems kinda crazy for a VC system to have to modify the kernel.
15:04:55 <DeezNuts> well it installs a filesystem driver
15:05:07 <DeezNuts> so the source control stuff is abstracted a bit
15:05:12 <DeezNuts> it looks just like a regular file system
15:05:18 <DeezNuts> but you have a 'view' to the versions you want
15:05:35 <SyntaxLaptop> yeah. I used clearcase at cisco for a while.
15:05:40 <Marvin--> oh dear
15:05:49 <DeezNuts> kew, its a bit overkill for my project though heh
15:05:56 <DeezNuts> i wouldn't mind just having kept it in cvs
15:06:01 <Marvin--> did I just spend an hour reading through moronic posts on the imdb message boards about Gibson's The Passion of Christ movie?
15:06:02 <Marvin--> damn
15:06:08 <SyntaxLaptop> I was expecting that you work at a pretty big place if you have need for both Redhat and Cisco
15:06:19 <SyntaxLaptop> Marvin--: haha. have any of the morons seen the movie yet?
15:06:20 * DeezNuts works at ibm
15:06:27 <DeezNuts> i didn't say i work with cisco stuff though :p
15:06:35 <SyntaxLaptop> s/redhat and cisco/redhat and clearcase
15:06:43 <DeezNuts> gotchya
15:06:46 <SyntaxLaptop> I was reading marvin's comment while typing. duh
15:06:48 <Marvin--> SyntaxLaptop: well, it was more an argument over whether the movie was based on a true story or not :)
15:06:49 <DeezNuts> i used to work at rational
15:06:55 <DeezNuts> thats how i got into ibm
15:07:16 <SyntaxLaptop> Marvin--: oh, I bet that was constructive.
15:07:29 <SyntaxLaptop> "Let's have a profound religious discussion, but let's base it on a movie we haven't seen yet."
15:07:38 <SyntaxLaptop> DeezNuts: cool.
15:07:43 <DeezNuts> Marvin--: I read a little bit about the movie and heard a little bit on NPR about it.. I hear that actual verses were cut up or ommited which is a pretty serious thing if thats true
15:08:17 <Marvin--> let me put it this way: the discussion had nothing to do with the movie at all
15:08:35 <Marvin--> it was purely about the existence or nonexistence of a certain Jesus
15:08:54 <Marvin--> for many many many many posts
15:08:54 <Cale> oh, damn, this powerpc machine is crippled. No compiler.
15:09:00 <Heffalump> stop tempting me to insult religion in a completely off-topic manner :-)
15:09:05 <Cale> oh well.
15:09:15 <DeezNuts> Cale: heh thanks for trying
15:09:19 <Marvin--> Heffalump: :)
15:09:34 <DeezNuts> Marvin--: the existence of Jesus? isn't that like questioning the existence of Ceaser or some other historical figure?
15:09:37 <Marvin--> sorry for bringing it up, I'm just pissed off at myself for wasting time on it :)
15:09:59 <Cale> anyway, I have to run - time to get some homework done.
15:10:00 <Marvin--> DeezNuts: Dude. Let's drop it. Nothing good will come out of this kind of discussion.
15:10:06 <DeezNuts> Cale: have fun :)
15:10:20 <DeezNuts> Marvin--: uh sure np didn't know it was so touchy
15:10:25 <Heffalump> I think Jesus is reasonably well documented, historically - perhaps not as well as Caesar
15:10:34 <Heffalump> it's the whole son of God thing that's controversial
15:10:53 <SyntaxLaptop> heh
15:11:16 <Marvin--> actually, (sigh, why did I have to bring this up), there are two points of contention, both the son of god thingy and the actual existance at all
15:11:18 <DeezNuts> Heffalump: Yeah its all kind of stupid since Jesus himself was against that sort of shit
15:11:33 <Marvin--> from what I understand, there are very few historical records that indicate that he did in fact exist at all
15:11:37 <DeezNuts> It doesn't matter if he's the son of god or not because theres no way to verify this
15:11:39 <Heffalump> Marvin--: oh, ok. I don't really care that much either way.
15:12:02 <DeezNuts> and i feel its unfortunate that a lot of people who call themselves christians focus on arguing issues like that
15:12:09 <DeezNuts> since it completely misses the mark
15:12:15 <Marvin--> DeezNuts: right
15:12:44 <Marvin--> "book believers" scare me to no end
15:12:58 <DeezNuts> if half the world's christians lived like christ the world would be a very different place
15:13:51 <Marvin--> anyhoo, I'm off to bed
15:13:57 <SyntaxLaptop> deeznuts: yeah... Jesus would use Haskell (ghc), XEmacs, and Debian
15:14:03 <SyntaxLaptop> ;)
15:14:09 <SyntaxLaptop> l8r Marvin--
15:14:11 <Marvin--> no, vi!
15:14:38 <SyntaxLaptop> vi never existed!!!
15:14:41 <Marvin--> all right, let's not go there :)
15:14:52 * Marvin-- waves
15:15:06 <DeezNuts> vi
15:15:07 <DeezNuts> vim!!
15:15:12 <DeezNuts> vim is da shit
15:15:49 <cmoline> i need to look up on why that happens :)
15:16:16 <cmoline> theres lots of cool sites that get high loads right?
15:16:36 <cmoline> like wikipedia and maybe wikibooks
15:17:03 <cmoline> and it would be cool to help support those sites with something i can afford to give
15:17:25 <cmoline> so i was wondering if there was a way to do distributed websites
15:17:39 <cmoline> sort of a really dynamic mirroring thing
15:18:24 <cmoline> if there isnt, it would be cool to implement something like this in haskell :)
15:19:05 <cmoline> maybe some kind of bittorrent server
15:19:28 <cmoline> that could make a webpage availble over bittorrent as well as http
15:19:50 <cmoline> so you could go to bt://www.slashdot.org
15:20:07 <cmoline> and hopefully get a more responsive page
15:20:28 <cmoline> well time for me to stop talking :)
15:20:53 * DeezNuts nods
15:53:34 <Riastradh> Did anyone here think of what kind of morphism map is?
15:56:38 <DeezNuts> what kind of morphism?
15:56:46 <DeezNuts> isn't it just a plain morphism?
15:59:19 <Riastradh> Unfold is an anamorphism; map is a <something>morphism; fold is a catamorphism.  (or maybe I got unfold & fold backwards)  What goes in that 'something?'  
16:00:20 <Heffalump> it's a homomorphism, as Igloo pointed out
16:00:27 <Heffalump> it's also both an anamorphism and a catamorphism
16:00:42 * Riastradh didn't remember Igloo pointing out that it was a homomorphism.
16:04:20 <Heffalump> ah, well he did :-)
16:39:49 <SyntaxLaptop> Igloo: it seems to me that hmake's clean target doesn't get rid of the empty lib directory
16:41:51 <Igloo> OK, ta
17:02:32 <swisscheese> Hi All. Anyone know of any good articles on getting C++ programmers to shift to FP style in preparation for switching to a FP language? I recall shifting to OOPs in C before going to C++ years ago.
17:03:04 <Pseudonym> A lot of the modern C++ books cover functional style.
17:03:15 <Pseudonym> Or some of it, at least.
17:03:35 <Pseudonym> I don't know of any that recommend it _exclusively_, though.
17:03:58 <Pseudonym> The best I can suggest is getting into one or two of the decent libraries and running with it.
17:04:09 <Pseudonym> Boost.Lambda is pretty good, for example.
17:04:40 <Pseudonym> Another possibility is to work with hard and soft layers in your code.
17:04:43 <swisscheese> Thanks. Where is Boost.Lambda?
17:04:54 <Pseudonym> http://boost.org/
17:05:14 <Pseudonym> BTW, if you're a C++ programmer and you're not using Boost, then you're either working on legacy code or you're wasting your time.
17:05:36 <Pseudonym> Every C++ programmer should know about it.
17:05:48 <Pseudonym> http://boost.org/libs/libraries.htm#Function-objects
17:06:19 <Pseudonym> Another useful thing to note is that template metaprogramming is functional programming.
17:06:29 <stepcut> BTW, if you're a C++ programmer, then you're either working on legacy code or you're wasting your time.
17:06:31 <Pseudonym> Because you can't modify variables in templates.
17:06:57 <Pseudonym> stepcut: Or you get paid a lot for it.
17:07:04 <stepcut> :p
17:08:30 <swisscheese> Thanks - I'll look into it.
17:08:40 <Pseudonym> Cool.
17:08:48 <Pseudonym> swisscheese: Is this for you or someone else?
17:11:21 <swisscheese> I manage programmers and am trying to figure out how to maximize productivity (I'm a programmer myself but a bit behind on technology).
17:11:26 <Pseudonym> Ah, OK.
17:11:39 <Pseudonym> I've found that a lot of C++ programmers don't know C++ that well.
17:11:50 <Pseudonym> They tend to write C-with-modules.
17:12:17 <Heffalump> so how does true C++ differ from this?
17:12:46 <swisscheese> I'm considering shifting to H but it seems it's not ready for prime time.
17:12:53 <Pseudonym> C++ has language support for higher levels of abstraction than C.
17:13:12 <Pseudonym> It doesn't necessarily make things less painful, but the pain is more managable.
17:13:20 <SamB> Pseudonym: what abstractions?
17:13:28 <jlouis> swisscheese: you may get the good programmers that way
17:13:39 <Pseudonym> swisscheese: Digital Mars D is also quite interesting.
17:13:41 <SamB> they trade old details for new and worse ones!
17:14:08 <Pseudonym> SamB: Smart pointers are a classic example.
17:14:22 <Pseudonym> I've seen a lot of C++ code, even written recently, full of manual memory management.
17:14:32 <swisscheese> Good point about getting good programmers but I would imagine not may programmers looking for jobs know H for example.
17:14:37 <SamB> Pseudonym: I maintain that C caused more leaks than it prevented!
17:14:40 <jlouis> what is a smart pointer? I've heard them mentioned quite a number of times now.
17:14:43 <SamB> s/C/C++/
17:14:54 * SamB didn't get his lunch time dose of dextrostat
17:15:11 <Pseudonym> jlouis: Oh, a smart pointer is an object which "owns" another, and behaves like a pointer.
17:15:31 <Pseudonym> The basic idea is that a smart pointer is a pointer which also manages the lifetime of the object that it points to.
17:15:44 <Pseudonym> The theory is that when the pointer disappears, the object is deleted.
17:15:52 <jlouis> ah
17:15:52 <Pseudonym> This can be done, for example, via reference counting.
17:16:15 <jlouis> so it is a poor mans GC
17:16:21 <Pseudonym> The key C++ feature which makes this possible is that an object can implement the operations that a pointer supports, so it just looks like you're using a pointer.
17:16:29 <SamB> Pseudonym: I maintain that its better to see whats happening, unless the RIGHT thing is happening.
17:16:37 <Pseudonym> jlouis: No, it's _one_ way to implement GC.
17:16:53 <Pseudonym> It's not the only way, and not always the best way.
17:17:22 <Pseudonym> SamB: If you want to know what's happening, why are you on #haskell? :-)
17:17:36 <Pseudonym> With lazy evaluation, you almost never know what's happening.
17:17:41 <jlouis> Pseudonym: ref-counting will get you in trouble with cyclic structures. So you will need to break those. Anyway a few Java GCs uses ref-counting in their hybrid approach
17:17:44 <monotonom> Because Haskell does the right thing :)
17:17:45 <SamB> Pseudonym: in Haskell, the right thing generally *is* happening!
17:17:55 <Pseudonym> :-)
17:18:33 <stepcut> arg, don't hold down ctrl-n to scroll down in mozilla
17:18:46 <Pseudonym> jlouis: Actually, not necessarily.  C++ programmers also often work with weak references, which are non-owning smart pointers.
17:19:08 <jlouis> Pseudonym: ok
17:19:09 <Pseudonym> While an object is alive, the weak reference is valid.  When the object dies, the weak reference automatically becomes a null pointer.
17:19:12 <SamB> Python uses a mix of refcounting and cycle collection. not that its necessarily a good example, but it does work ;-)
17:19:21 <Pseudonym> You can implement cyclic structures using weak references.
17:19:27 <Pseudonym> Sometimes you can, anyway.
17:19:34 <Pseudonym> And yes, you can do cycle detection.
17:19:58 <Pseudonym> However, my experience is that a programmer generally knows if some data structure is going to contain cycles or not in advance.
17:20:09 <jlouis> indeed
17:20:21 <Pseudonym> Certainly in the case of "owning" references.
17:20:52 <Pseudonym> Consider a tree, for example.  This is fundamentally an acyclic structure, even if children need references to their parents.
17:21:20 <SamB> Pseudonym: what type do the actual values have?
17:21:29 <Pseudonym> SamB: Sorry?
17:21:35 <SamB> Pseudonym: in the tree?
17:21:43 <Pseudonym> It doesn't matter.
17:21:48 <SamB> How do you know they don't reference the tree?
17:21:50 <Pseudonym> I'm talking about trees in the abstract.
17:22:14 <Pseudonym> SamB: The tree as a whole, or subtrees?
17:22:26 <SamB> Pseudonym: does it matter?
17:22:30 <Pseudonym> Sure it does.
17:22:38 <Pseudonym> If you can reference subtrees, the data type isn't abstract.
17:22:56 <Pseudonym> If it's not abstract, then subtrees are part of the interface.
17:23:09 <SamB> if its as abstract as you seem to mean, than it isn't abstractly a tree
17:23:31 <Pseudonym> Yes and no.  Consider, for example, an HTML/SGML/XML DOM tree.
17:23:59 <Pseudonym> "Nodes" are part of the interface for this data type, even though it may well be implemented abstractly.
17:24:00 <SamB> that isn't an abstract kind of tree.
17:24:25 <Pseudonym> It's abstract in the sense that, viewed from the outside, you don't care how it's implemented so long as the interface requirements are satisfied.
17:24:58 <Pseudonym> It could be implemented as a bunch of structs/objects with pointers.  Could be implemented using any number of layers of indirection.
17:25:03 <Pseudonym> Could be files on disk.
17:25:44 <Pseudonym> My point is that if subtrees are not part of the interface, then "values" (i.e. whatever is in a node/leaf of the tree) shouldn't be able to touch them.
17:25:49 <monotonom> A tree could be implemented as an array.
17:25:54 <Pseudonym> Unless that's explicitly part of the data structure.
17:26:02 <Pseudonym> In which case, the programmer knows about it.
17:26:16 <Pseudonym> monotonom: Precisely.
17:26:32 <SamB> Pseudonym: well, if subtrees aren't in the interface, than how do I know the structure in question is a TREE!
17:26:45 <Pseudonym> You do if you're implementing it.
17:27:09 <Pseudonym> If you're using it, you may well not.
17:27:35 <SamB> anyway, it could hold a reference to the entire tree.
17:27:51 <Pseudonym> Ah, now that's a different issue.
17:27:57 <Pseudonym> Yes, it could.
17:28:36 <Pseudonym> However, in that case, the person who put the reference there knows it.
17:28:50 <monotonom> To round up the circle, an array could be implemented as a tree. :)
17:29:10 <stepcut> is there something like mapArray that actually mutates a mutable array, instead of creating a copy
17:29:12 <Pseudonym> That is, whoever is using the data structure from the outside has put a reference to X somewhere inside X.
17:29:26 <Pseudonym> The programmer still knows it's there.
17:29:51 <SamB> anyway, C++ is a pitiful attempt at OO.
17:30:49 <Pseudonym> I'd agree with that, but then, C++ isn't an OO language.
17:31:31 <Pseudonym> Stroustrup has noted this himself several times.
17:32:21 <SamB> Pseudonym: heh. the people in #qt don't seem to know that!
17:33:30 <Pseudonym> This, IMO, is one of the reasons why there are a lot of bad C++ programmers out there.
17:33:39 <Pseudonym> Point them to this some time:
17:33:42 <Pseudonym> http://www.research.att.com/~bs/bs_faq.html#Object-Oriented-language
17:33:55 <monotonom> stepcut: I'm afraid not.
17:34:13 <stepcut> monotonom: there is now ;)
17:34:26 <Pseudonym> BBIAB
17:34:37 <SamB> Even if the only bad thing about C++ was the misconception that it is OO, I still think it does more harm than good.
17:34:46 <stepcut> however, it seems to make no significant performance difference.
17:35:24 <SamB> stepcut: why would it, as long as you have array fusion?
17:35:46 <monotonom> Creating a new array is not noticeably slower than mutating the whole of an existing array. The only extra operation is pretty much a malloc of sorts.
17:36:13 <SamB> monotonom: I thought allocation in Haskell was supposed to be faster than malloc?
17:36:37 <monotonom> The real cost comes after. If you have to copy the content of the new array back to the old one, that sucks.
17:37:26 <SamB> monotonom: why would you have to do that? this is Haskell, isn't it?
17:39:51 <stepcut> I have an Int32 array that is 1.8 million elements long. do 'mapArray id myarray' seems to take about 5 seconds... which seems like a long time...
17:42:32 <stepcut> its an IOUArray at that...
17:43:28 * stepcut does a little test
17:48:46 <stepcut> yeah:
17:48:55 <stepcut> main = do { h <- openBinaryFile "test.b" WriteMode ; a <- newArray_ (1,1800000) ; hPutArray h a 1800000 } <-- runs in 0.080 seconds
17:49:12 <stepcut> main = do { h <- openBinaryFile "test.b" WriteMode ; a <- newArray_ (1,1800000) ; b <- mapArray id a ; hPutArray h b 1800000 } <-- takes 5.7 seconds
17:51:06 <monotonom> odd
22:47:05 <DeezNuts> whats the point of programming in haskell beyond it being a cute toy for math fans
22:47:30 <mgoetze> DeezNuts: uh... writing real programs?
22:47:58 <mgoetze> DeezNuts: what's the point of programming in c++ beyond it being a cute toy for masochists?
22:48:51 <Pseudonym> Depends which area of maths, too.
22:49:20 <Pseudonym> Haskell isn't well-suited for numeric stuff (yet; all it would take would be some nice libraries), but it's extremely well-suited for symbolic stuff.
22:50:48 <DeezNuts> heh apologists aye
22:51:03 <DeezNuts> mgoetze is just confused
22:51:11 <mgoetze> DeezNuts: about...?
22:51:17 <Pseudonym> DeezNuts: All I can suggest is that you try it and see.
22:51:23 <DeezNuts> i am trying it
22:51:34 <DeezNuts> and it seems stupid so far
22:51:37 <DeezNuts> but
22:51:43 <DeezNuts> i know its good for a certain set of tasks
22:51:47 <Pseudonym> You know, I originally thought the same thing about C++.
22:51:57 <DeezNuts> right heh
22:52:01 <Pseudonym> I used to make the same arguments against C++ that most of the naysayers use.
22:52:03 <DeezNuts> you all know haskell is "unique"
22:52:08 <Pseudonym> Until I actually tried writing something nontrivial in it.
22:52:36 <mgoetze> haskell isn't really /that/ unique... it kinda evolved from some other languages, for one thing :)
22:52:38 <Pseudonym> Now I never made the arguments against Haskell that they naysayers use, probably because when I started using it, it wasn't very well-known.
22:52:58 <DeezNuts> hmm let me ask you this
22:53:03 <Cale> DeezNuts: Haskell is actually quite practical for a large set of tasks.
22:53:13 <Pseudonym> You have to try it, I think.
22:53:19 <Pseudonym> You have to try writing something nontrivial in Haskell.
22:53:28 <Pseudonym> Same with most languages.
22:53:33 <DeezNuts> would you write a web application (that generated html, sql, etc and handled CGI stuff, network protocols, yada-yada) in Haskell?
22:53:33 <Pseudonym> It's the only way to have your "Zen moment".
22:53:45 <Cale> DeezNuts: seen wash?
22:53:47 <Pseudonym> DeezNuts: It depends.
22:53:52 <DeezNuts> Cale: wash?
22:54:03 <Cale> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
22:54:08 <Cale> Web Authoring System Haskell
22:54:37 <Pseudonym> Most web scripting languages have a huge set of glue libraries which Haskell doesn't (yet) have.  For example, I don't think there's a Haskell binding to Oracle yet.
22:55:12 <Pseudonym> The upper layers are fine.  WASH is good.
22:55:26 <Pseudonym> But the lower layers aren't there for all of the services that you might want your application to access.
22:56:01 <Pseudonym> Like most open source systems, the reason fort his is that nobody has needed it yet.
22:56:04 <DeezNuts> but your saying that if they were there
22:56:25 <DeezNuts> then haskell would be as good a language as say, perl for the tasks i just described?
22:56:35 <Pseudonym> Yes, I think so.
22:56:44 <DeezNuts> hmm
22:56:48 <DeezNuts> what about for regular people?
22:56:59 <DeezNuts> (ie, dumb people)
22:57:01 <Pseudonym> By "regular people", do you mean "visual basic script kiddies"?
22:57:16 <DeezNuts> nope
22:57:27 <Pseudonym> OK, just thought I'd check.  (You did say "dumb people".)
22:57:27 <DeezNuts> i dont mean kids who spread vb virii
22:57:31 <DeezNuts> i mean regular, dumb people
22:57:57 <Pseudonym> No, I don't mean virus writers either.  I mean people who write very badly-written thin layers of Office glue code.
22:58:07 <DeezNuts> heh or any code
22:58:11 <DeezNuts> i just mean
22:58:12 <DeezNuts> dumb people
22:58:14 <Pseudonym> Which is a significant proportion of the software industry.
22:58:15 <DeezNuts> writing in any language
22:58:32 <Pseudonym> Well, personally, I don't think dumb people should be let near a programming language.
22:58:34 <Etaoin> yum. office glue
22:58:43 <Pseudonym> VB or otherwise.
22:58:43 <DeezNuts> yeah but thats the problem
22:58:46 <DeezNuts> that will never happen
22:58:54 <Cale> I think that, probably anyone who can learn to write in Java can learn to write in Haskell.
22:58:58 <DeezNuts> so haskell will never be viable in the wild
22:59:10 <Pseudonym> I think Cale is right, there.
22:59:11 <DeezNuts> Cale: what about people who write java but dont know how?
22:59:33 <Pseudonym> You need to be at least this (indicates a point on the IQ bell curve) smart to program in Java.
22:59:35 * DeezNuts works with some pretty dimmly lit bubls
22:59:39 <DeezNuts> *bulbs
22:59:43 <dennisb> DeezNuts: like trying to compile "Please mr. computer, open a window" and thinks it's java?
22:59:51 <Pseudonym> I think that people of that intelligence can handle Haskell.
23:00:49 <DeezNuts> dennisb: no i mean people who are confused about such things as the order which statements get executed in a program
23:00:50 <dennisb> Haskell is dead simple, it's thought as the first language in a number of schools. You have no pointers or memory allocation to think about.
23:00:56 <Cale> If you can think logically enough to write code (that works) in any of the popular programming languages of today, you can think logically enough to code in Haskell.
23:01:29 <DeezNuts> Cale: why is it then that IO is such a hassle?
23:01:33 <Pseudonym> Ah, well.  In Haskell you don't have to worry about the order of statements.
23:01:52 <Pseudonym> DeezNuts: IO is a hassle because it's different from other languages.
23:01:53 <Cale> IO isn't such a hassle. You're fighting with it too much. :)
23:01:57 <dennisb> DeezNuts: it's not hassle. You just put your io commands in a sequence, just like in any language
23:02:09 <DeezNuts> i haven't dont it yet
23:02:14 <DeezNuts> but i hear that brought up the most
23:02:22 <DeezNuts> and you have to learn what a monad is, etc
23:02:26 <DeezNuts> or monoid whatever
23:02:26 <DeezNuts> heh
23:02:32 <dennisb> DeezNuts: that is simply wrong
23:02:47 <DeezNuts> haskell myth #1?
23:02:49 <Cale> For some reason there's a stigma amongst non-haskell programmers that IO in Haskell is "hard", but this simply isn't true.
23:03:05 <Pseudonym> It's hard to implement, and it's hard to extend.  It's not hard to use.
23:03:20 <DeezNuts> its hard to implement and extend ?
23:03:27 <DeezNuts> thats pretty rough
23:03:32 <DeezNuts> if u can't handle data properly
23:03:36 <Cale> (i.e. for people designing the language)
23:03:39 <DeezNuts> as a stream of bytes
23:03:44 <Pseudonym> Right, see Cale's comment.
23:03:50 <dennisb> DeezNuts: if you have not used it how can you say it's hard
23:03:51 <DeezNuts> or people writing low-level modules?
23:04:00 <Pseudonym> If you're implementing the Haskell library, it's tricky.
23:04:09 <DeezNuts> dennisb: i haven't used the IO, I said that from what I hear people ask about, it seems difficult
23:04:22 <DeezNuts> well i wont give up yet or anything
23:04:26 <DeezNuts> haven't gotten that far yet
23:04:30 <DeezNuts> but just curious
23:04:31 <Pseudonym> I think it used to be difficult, in the days before do notation.
23:04:37 <DeezNuts> if it really gives that much bang for the buck... whatever that bang is
23:04:42 <Cale> Yeah, I can see that being the case.
23:04:47 <Pseudonym> But we've had that for quite a few years now.
23:05:03 <dennisb> like 10-15 years ago it was hard
23:05:08 <DeezNuts> hmm
23:05:24 <DeezNuts> how would you print data to an arbitrary file-handle?
23:05:38 <DeezNuts> oops i mean
23:05:39 <DeezNuts> io-handle
23:05:42 <DeezNuts> like a socket
23:05:44 <DeezNuts> a file
23:05:45 <Pseudonym> DeezNuts: Oh, by "extend", I'm not talking about implementing I/O on different data types.  I'm talking about... uhm... forget it, it'd take too long to explain.
23:05:45 <Cale> hPutStr handle "something"
23:05:46 <DeezNuts> whatever
23:06:11 <DeezNuts> Pseudonym: i have to know... why would it take too long to explain?
23:06:19 <Cale> or hPutStrLn handle "something" if you want it newline-terminated
23:06:21 <DeezNuts> Pseudonym: if its something that directly effects the language
23:06:35 <Cale> where handle is your socket or whatever and "something" is what to write
23:06:47 <DeezNuts> how do you make a socket?
23:06:59 <Pseudonym> DeezNuts: It doesn't affect the language, really.  The kind of extensions I'm talking about are providing I/O services which aren't already in the library.
23:07:20 <Cale> connectTo host port
23:07:24 <DeezNuts> Pseudonym: what kind of services
23:07:25 <Pseudonym> For example, if you had a new kind of communication mechanism that wasn't a file descriptor.
23:07:31 <DeezNuts> Cale: hmm seems easy
23:07:32 <Cale> handle <- connectTo host port
23:08:17 <Cale> yeah, it's actually surprisingly nice
23:09:02 <DeezNuts> is there anything then, that makes haskell a pain in the ass? any sort of programming issues??
23:09:51 <dennisb> the biggest problem is that not all libs that exist in the world have haskell bindings which makes them hard to call from haskell
23:10:01 <shapr> good morning #Haskell!
23:10:05 <DeezNuts> hi shapr
23:10:12 <Pseudonym> Also, not all libs that exist in the world map naturally onto Haskell's constructs.
23:10:13 <DeezNuts> i actually have a haskell question now heh
23:10:14 <Pseudonym> G'day!
23:10:30 <DeezNuts> my_length = []
23:10:32 <Cale> You can use ffi for a lot of the C stuff, but yeah, it's often rather unnatural.
23:10:42 <DeezNuts> my_length (x:xs) = 1 + my_length xs
23:11:06 <dennisb> It's also a little different from some other languages which makes it harder for people who know exactly 1 language, they usually expect every other language to be the same as the one they know
23:11:08 <DeezNuts> is the cons operator actually breaking off an element from xs?
23:11:14 <Cale> DeezNuts: perhaps you want the first line there to be my_length [] = 0 ?
23:11:45 <DeezNuts> dennisb: hmm actually haskell is different from most languages, and in particular the popular widely used languages. :p dont need to downplay that
23:11:45 <dennisb> DeezNuts: the above is pattern matching (and what Cale said)
23:11:52 <Pseudonym> In particular, one of the paradigms which Haskell doesn't support well is OO.
23:11:55 <DeezNuts> oops sorry about the first line
23:11:58 <DeezNuts> im just typing in an example
23:12:00 <DeezNuts> and i typed it wrong
23:12:03 <DeezNuts> but yeah
23:12:08 <Pseudonym> It's pretty close, admittedly.
23:12:12 <DeezNuts> my_length [] = 0
23:12:22 <DeezNuts> my_length (x:xs) = 1 + my_length xs
23:12:44 <Cale> DeezNuts: (x:xs) matches the head and tail of a list. For instance, with [1,2,3], x gets 1, and xs gets [2,3]
23:12:46 <DeezNuts> the use of the cons operator here confuses me
23:12:51 <dennisb> : is the way lists are constructed and picked apart (pattern matching)
23:13:00 <DeezNuts> AND picked apart
23:13:00 <DeezNuts> ok
23:13:03 <DeezNuts> just checking
23:13:24 <dennisb> : is not just any function, it's a constructor
23:13:26 <Cale> yeah, you can also do x:y:xs, and get the first two elements and the rest.
23:13:40 <dennisb> you can for example not use ++ in your pattern matching
23:13:56 <DeezNuts> what
23:14:07 <DeezNuts> you can for example not use ++?
23:14:10 <dennisb> ++ is the concat operator
23:14:16 <DeezNuts> you can't you mean?
23:14:31 <Cale> you can't do, for instance my_function (xs++ys) = foo
23:14:35 <DeezNuts> ok
23:14:44 <dennisb> you can not write foo (x++y) = length x + length y
23:14:50 <DeezNuts> i get it
23:15:02 <DeezNuts> u just wrote ur sentence odd :p and i got confused cuz im slow
23:15:03 <DeezNuts> ok
23:15:18 <Pseudonym> One exercise that I used to take my students through was pattern matching.  Here's a pattern, here's a value.  Does it match, and if so, what are the bindings?
23:15:28 <DeezNuts> heh
23:15:29 <Pseudonym> We should do one of these in online quiz form.
23:15:32 <shapr> Pseudonym: Haskell Binding to Oracle is on its way into haskell-libs.sf.net :-)
23:15:33 * DeezNuts is a seasoned Perl user
23:15:36 * shapr is reading scrollback
23:15:51 <Pseudonym> Oh, cool.
23:15:57 * Pseudonym is a seasoned Perl user too
23:16:12 <Pseudonym> So you'd be familiar with map, then.
23:16:17 <DeezNuts> yeah im a pretty spicty meatball when it comes to regex ;)
23:16:19 <DeezNuts> es
23:16:20 <DeezNuts> yes
23:16:26 <Pseudonym> Cool, you'll like that.
23:16:34 <DeezNuts> yep i saw map and filter (grep in perl)
23:16:41 <Pseudonym> Yes.
23:16:49 <Cale> folding is also important.
23:16:52 <DeezNuts> btw are there real regular expresions?
23:16:56 <Pseudonym> Have you looked at list comprehensions?
23:17:05 <DeezNuts> ya
23:17:09 <Pseudonym> DeezNuts: Yes, though I don't think the full PCRE has been ported, yet.
23:17:11 <DeezNuts> folr and foldl
23:17:45 <DeezNuts> foldr/foldl are easy enough since i used scheme before
23:17:46 <DeezNuts> btw
23:17:47 <DeezNuts> hugs sucks
23:18:00 <DeezNuts> I can't use (+) args
23:18:03 <DeezNuts> syntax
23:18:07 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
23:18:27 <Cale> Everything seems to make its way into ghc first.
23:18:28 <DeezNuts> I apologize to the authors of hugs btw ;)
23:18:33 <DeezNuts> yeah
23:18:36 <DeezNuts> damnit
23:18:57 <Pseudonym> I think you'll find most people around here use GHC/GHCi more often than Hugs.
23:19:00 <Cale> someone ought to be able to compile ghc for you.
23:19:08 <DeezNuts> i could compile it myself
23:19:09 <Pseudonym> The exception being people doing undergrad stuff where Hugs is what they use.
23:19:15 <DeezNuts> its just a matter of dedicating the time and effort
23:19:22 <DeezNuts> just seems like a daylong thing
23:19:30 <Pseudonym> Yes, it's quite painful.
23:19:34 <Pseudonym> Get a binary distro if you can.
23:19:36 <dennisb> Depends on what you write, hugs is lean and mean
23:19:37 <DeezNuts> i cant
23:19:44 <DeezNuts> i searched high and low
23:19:54 <Cale> DeezNuts: you just need to download and install the 5.04 powerpc-linux one and then compile 6.2 using that
23:19:55 <Pseudonym> What platform?
23:20:12 <DeezNuts> linux-ppc
23:20:29 <DeezNuts> Cale: I'm not too motiviated since ghci isn't included in that binary
23:20:39 <DeezNuts> Cale: so I would have to bootstrap that one
23:20:52 <Cale> DeezNuts: doesn't matter - it's just the hammer you'll use to pound out your new hammer
23:20:53 <DeezNuts> Cale: or even worse heh
23:21:03 <DeezNuts> ok
23:21:06 <DeezNuts> ill download it
23:21:09 <dennisb> hey, the haskell web page have changed (a little)
23:21:10 <Cale> ghci will be included when you compile 6.2 with the 5.04
23:21:30 <Cale> it gets around bootstrapping.
23:21:43 <dennisb> it takes a long time to compile ghc
23:22:10 <DeezNuts> what does it mean "unregistered"?
23:22:20 <Cale> unregistered?
23:22:21 <DeezNuts> (the build being unregistered)
23:22:40 <dennisb> probably some debian term
23:22:45 <DeezNuts> oh ok
23:22:59 <dennisb> do you run debian?
23:23:06 <DeezNuts> Cale: there is a note that says the build is unregistered
23:23:11 <DeezNuts> dennisb: nope, gentoo
23:23:15 <Cale> ah, yeah, I see it there
23:23:36 <Cale> PowerPC/Linux * ghc-5.04.3-powerpc-unknown-linux.tar.bz2  This is an unregisterised build, currently without GHCi support. PowerPC/Linux support is by Sven Moritz Hallberg. 
23:23:53 <Cale> on the GHC download page
23:23:57 <DeezNuts> thats the one
23:24:09 <DeezNuts> i would think if it had to do with debian it would be stated as such
23:24:34 <Cale> I don't know what it means, but it should get 6.2 to compile.
23:24:41 <DeezNuts> ok
23:24:46 <DeezNuts> it will take a little bit to download
23:24:56 <DeezNuts> since my connection maxes out at 16.5Kb/s
23:24:58 <dennisb> Cale: I saw that there too now. The other place it was mentioned was in the debian section for 6.2
23:25:13 <dennisb> maybe it's a powerpc term then. I've never heard it before
23:25:22 <DeezNuts> nah ur prolly right
23:25:43 <DeezNuts> that its a debian thing
23:25:54 <DeezNuts> its also 'unregistered' for gentoo
23:26:02 <DeezNuts> normally i could just say 'emerge ghc'
23:26:03 <dennisb> funny word
23:26:14 <DeezNuts> ya
23:26:28 <Cale> Makes it sound like shareware. :)
23:26:40 <DeezNuts> lol
23:26:42 <DeezNuts> why is that?
23:26:44 <DeezNuts> ohh
23:26:47 <DeezNuts> nm 
23:26:51 <DeezNuts> yeah unregistered copies of shareware
23:26:59 <DeezNuts> are like all copies of shareware
23:27:20 <Etaoin> "An unregisterised build is one that compiles via vanilla C only. "
23:27:23 <Etaoin> http://www.haskell.org/ghc/docs/6.2/html/building/sec-porting-ghc.html
23:27:28 <DeezNuts> ahhh
23:27:29 <DeezNuts> thank you
23:27:36 <DeezNuts> damn
23:27:40 <DeezNuts> so its gonna be dog slow?
23:28:00 <Cale> ah "unregisterised" not "unregistered"
23:28:15 <DeezNuts> unregisterised?!
23:28:22 <DeezNuts> lol
23:28:59 <dennisb> DeezNuts: it will probably take a full day to compile
23:29:06 <Cale> ??!!
23:29:19 <Cale> GHC only ever took 15 minutes for me to compile.
23:29:26 <shapr> fifteen minutes??
23:29:27 <dennisb> Cale: what?
23:29:32 <dennisb> I think not
23:29:33 <shapr> what sort of hardware are you using??
23:29:37 <DeezNuts> heh
23:29:38 <Cale> maybe half an hour
23:29:48 <Cale> not a whole day certainly
23:29:56 <DeezNuts> X takes a whole day
23:30:03 <Cale> I'm on a P4 2.4GHz
23:30:06 <DeezNuts> at least many hours of the day
23:30:06 <dennisb> also, it needs to compile itself without ghci first I think, and then use that compiler to compile itself again with all features (including ghci)
23:30:08 <shapr> It takes a coupla hours for me.
23:30:16 * DeezNuts is on G4/933
23:30:27 <shapr> I'm on a dual 1544
23:30:36 <DeezNuts> what kind of cpu?
23:30:55 <shapr> Athlon MP
23:31:01 <Cale> Perhaps I'm not remembering correctly, but I do remember doing it twice in one night.
23:31:53 <Cale> anyway - it's late and I have class tomorrow morning
23:31:58 <Cale> I should get to sleep
23:32:05 <Cale> g'night all
23:32:08 <shapr> g'night Cale 
23:34:43 <Pseudonym> Night.
23:37:56 <DeezNuts> me too
23:38:02 <DeezNuts> good night peeps
23:38:03 <dennisb> I've not compiled ghc the last 3 years or so, it's nice with binaries
23:38:05 <dennisb> bye
23:48:31 <Pseudonym> Think we have another convert, brethren?
23:48:51 <Pseudonym> I'd say anyone willing to compile GHC counts as "eager".
23:49:22 <dennisb> he is a gentoo user, they do nothing but compile things all day long
23:49:39 <Pseudonym> Good point.
23:49:45 <dennisb> I do to, but usually the same program over and over again
23:49:49 <Pseudonym> Oh, crap.  Just noticed the time.  Must dash.
23:49:50 <Pseudonym> Nytol/
