00:00:00 <Cale> I saw ~~~~~ twice from you
00:00:10 <shapr> hm
00:00:36 <shapr> hello what 
00:00:39 <what> ok darknedd
00:00:42 <what> hey
00:00:45 <shapr> ?
00:00:59 <shapr> what: are you learning Haskell?
00:01:00 <what> darkness
00:01:03 <DarKneSs> hey
00:01:05 <DarKneSs> see ure in
00:01:13 <what> ok r u happy now
00:01:15 <what> ???????????
00:01:19 <DarKneSs> kind of
00:01:23 <Cale> what: what?
00:01:24 <shapr> eh?
00:01:30 <what> oh god now again
00:01:39 <what> not^
00:01:41 <shapr> are you guys here for the programming?
00:01:41 <Cale> heh
00:01:52 <shapr> or is it just the free food?
00:01:53 <DarKneSs> i dont program haskell
00:02:02 <DarKneSs> C programming
00:02:06 <shapr> would you like to program in Haskell?
00:02:14 <DrNerdware> Namaste!
00:02:17 <DarKneSs> naah really
00:02:20 <shapr> we have a twelve step program for C programmers.
00:02:22 <DarKneSs> Kernel: Linux 2.6.09 CPU[1]: Intel(R) Pentium(R) 4 CPU 2.40GHz@2392.218 MHz11 Mem/Use:  246832 kB/   4200 kB8 Vid: Intel Corp. 82845G/GL [Brookdale (rev 3).  13XInfo:4.3.0  Screen #0: @ 1024x768 pixels (302x222 millimeters) /24 bit10 Sound:Ensoniq 5880 AudioPCI (rev 2).8 Uptime: 1:11
00:02:22 * DrNerdware uses Haskell
00:02:26 <shapr> namaste DrNerdware 
00:02:40 <what> oh my god!!!!!!!!!!!!
00:02:47 <DarKneSs> what what
00:03:00 <what> nothin 
00:03:18 * DrNerdware has been using Scheme recently
00:03:44 <shapr> Scheme is nice.
00:03:58 <DrNerdware> esp if you want to write a Scheme compiler ;)
00:04:24 <DrNerdware> of course, i considers compiling Scheme into Haskell...
00:04:33 <shapr> there is a scheme in Haskell
00:04:37 <shapr> Ashley Yakeley wrote it.
00:04:38 <DrNerdware> yep
00:04:40 <shapr> I haven't tried it recently.
00:04:49 <DrNerdware> i tried it years ago. very nice
00:05:45 <DrNerdware> anyway, i alternate between Scheme and Haskell
00:05:54 <DrNerdware> so I'm currently in Scheme mode
00:06:06 <shapr> what: hey, I haven't been in atlanta recently, how's the underground?
00:06:12 <DrNerdware> it all depends on the program
00:06:22 <shapr> yah, different languages for different purposes.
00:06:46 <shapr> C is good for writing device drivers (so I've heard ;-) and Haskell is good for high level code.
00:06:57 * DrNerdware grins
00:07:07 <DarKneSs> C for almost anything
00:07:11 <DrNerdware> C is a good target language for Scheme compilers l)
00:07:29 <shapr> DarKneSs: I would be willing to argue that point.
00:07:45 <DarKneSs> :P
00:07:57 <DrNerdware> not so good for writing Forth interpreters, but it's possible
00:08:13 <shapr> in my opinion, things like explicit loop initialization is unnecessarily complicated..
00:08:21 <shapr> same for manual memory management.
00:08:36 <DrNerdware> Cyclone is neat
00:08:41 <shapr> Obviously those have their place in low level code, but I don't think they're worth it in higher level code.
00:08:45 <shapr> yah, Cyclone is cool.
00:09:37 <DrNerdware> last time i was in here, i'd joined by mistake. i posted a link intended for another place...oops
00:09:49 <DrNerdware> nooooo neeeeeeeeeeeeeeed
00:10:21 <shapr> I've written a lot of Java code, and every once in awhile I get confused as to whether the collection I'm using starts at one or at zero
00:10:35 <shapr> with map/fold/filter I don't have to worry about that.
00:10:37 <DrNerdware> heh
00:10:58 <DrNerdware> off-by-one errors abound
00:11:11 <shapr> right, but not with map/fold/filter and friends.
00:11:23 <DrNerdware> there's probably a joke about ABEND in there somewhere
00:11:34 <shapr> probably so
00:11:53 <DrNerdware> i got an off-by-one error using arrays in haskell
00:11:56 * shapr tries to see he can subtract one from ou to get e
00:12:00 <DrNerdware> dunno how i did that
00:12:04 <shapr> wow, I'm impressed.
00:12:19 <DrNerdware> i kept getting odd bounds errors
00:12:42 <DrNerdware> in some markov-chain code
00:12:49 <shapr> what: Atlanta is a nice city, I've spent some new years' there.
00:13:04 <DrNerdware> someday i'll take another look at that code and see if i can spot my error...
00:13:14 <what> hey whats up people??????
00:13:21 <shapr> what: excitement and happiness!
00:13:37 <what> kool
00:13:42 <shapr> what's up with you?
00:13:56 <what> not very much bein bored
00:14:13 <shapr> do you like programming? I can suggest some unboring things that have to do with programming.
00:14:18 <DrNerdware> ok, breakfast time. cya folks
00:14:32 <what> no i don't
00:14:41 <shapr> oh, what do you like?
00:14:48 <what> hey shapr tell me how to change me nick name
00:14:56 <what> my^
00:15:16 <Cale>  /nick blah
00:15:20 <shapr> you can use "/nick Amber"
00:15:28 <shapr> without the quotes
00:15:38 <what> ok
00:16:00 <what> just type it right im new at this
00:16:05 <what> srry
00:16:05 <Cale> yeah
00:16:07 <shapr> yes, and then hit enter at the end
00:16:19 <what> ok thanx
00:16:41 <what> what the freak
00:16:51 <shapr> who's the freak?
00:16:55 <what> its not workin!!!!!!!!!
00:17:10 <shapr> do you get an error message?
00:17:18 <what> uhh no
00:17:36 <stepcut> there is already someone with the nick amber...
00:17:36 <shapr> what happens?
00:17:42 <what> nothin
00:17:55 <shapr> oh, I see. try "/nick AmberGirl"
00:17:59 <what> after i type it i hit enter and nothin happens
00:18:20 <Aambergurl> ok thats better
00:18:28 <Aambergurl> hold on
00:18:43 <Ambergurl> ok
00:18:47 <Ambergurl> now thanx
00:18:54 <shapr> sure
00:19:02 <Ambergurl> so whats ur a-s-l
00:19:14 <shapr> old,male, and sweden
00:19:20 <shapr> and I'm married
00:19:21 <Ambergurl> how old
00:19:27 <Ambergurl> just askin
00:19:29 <shapr> I'm 100,000 years old in binary.
00:19:34 <Ambergurl> lol
00:19:49 <Ambergurl> y isnt other people talkin
00:20:06 <shapr> because most of them usually talk about programming with the language Haskell, and we're not talking about that.
00:20:18 <stepcut> Ambergurl: do you like monadic IO?
00:20:31 <Ambergurl> what????????????
00:20:49 <shapr> the reason this channel exists is to discuss the programming language Haskell, and code that is written in that language.
00:21:24 <shapr> you may enjoy a channel like #chat or #talk more than this channel.
00:27:08 <stepcut> shapr: dude! now look what you did! She was totally going to play with my monads!
00:27:16 <Cale> ahaha
00:27:30 * shapr laughs
00:27:38 <Cale> http://mathworld.wolfram.com/HairyBallTheorem.html
00:27:47 <earthy> stepcut: yeah, call fail for 'm. )
00:27:48 <Maddas> haha
00:28:16 <shapr> wow, that's totally quoteworthy
00:43:13 <liiwi> yes
00:43:26 <liiwi> good, sunshine filled morning
00:50:11 <earthy> it's quite foggy here
00:52:27 <Lemmih> Parsec question: I would like to get the data between two double quotes (\" should not be interpreted as the end). I tried to do it like this: w <- manyTill anyChar (try (do noneOf ['\\'];char '\"'))
00:52:52 <shapr> I think parsecToken already handles escaped quotes
00:53:05 <shapr> are you doing this for learning how to do CSV or so?
00:53:58 <Lemmih> CSV = Comma separated values?
00:54:11 <shapr> yup
00:54:33 <Lemmih> Well no. I'm code an s-expression parser.
01:34:23 <harsha123> hi naren 
01:34:40 <naren> hi harsha123
01:34:46 <naren> hi everyone
01:39:04 <pnm> hi all
01:39:09 <pnm> quick question
01:39:42 <pnm> is there an easy way to get a function to equal something if the number of arguments isn't the expected number
01:40:13 <Heffalump> not that I can think of
01:40:14 <earthy> ummm...
01:40:15 <earthy> no
01:40:16 <pnm> I can see how to produce output for 2 arguments, or output for 3 - but output for _any_
01:40:20 <Heffalump> oh, yes, using type classes
01:40:37 <earthy> hef: explain?
01:41:19 <Heffalump> class ApplyableF Int where f = 5
01:41:53 <Heffalump> class ApplyableF a => ApplyableF (Int -> a) where f n = n + f
01:41:59 <Heffalump> that doesn't typecheck, but that's the rough idea
01:42:15 <Heffalump> and it'd probably be better to construct a list or something of arguments
01:42:22 <Heffalump> and then do the real work outside the typeclass
01:42:44 <pnm> neat...
01:42:52 <Heffalump> does that make any kind of sense? I need to go shower and get to work.
01:42:53 <earthy> i.e. you're tricking the typesystem into collecting the arguments all the way through curried applications?
01:42:57 <Heffalump> yep.
01:43:14 <Heffalump> it'll make your type error messages incomprehensible when you get things wrong, though...
01:43:21 <earthy> `duh'
01:44:06 <pnm> thanks!
01:44:29 <earthy> I think my understanding of typeclasses is nowhere near complete. :)
01:49:58 * Cale is away: sleep
03:14:03 <shapr> @yow
03:14:04 <lambdabot> Look!!  Karl Malden!
03:14:07 <shapr> where?
03:42:03 <shapr> yeehaa
03:42:29 <shapr> I'll be in gothenburg for europython, let's have a get-together!
03:43:48 * shapr bounces cheerfully
03:43:57 <shapr> blackdog: I expect to see you there :-P
03:44:09 * shapr is bored of writing Python code :-/
03:44:39 <Lunar^> shapr: idem
03:44:54 <shapr> idem?
03:45:22 <Lunar^> shapr: latin word often used in french
03:45:27 <shapr> @wn idem
03:45:28 <lambdabot> No match for "idem".
03:45:33 <Lunar^> shapr: means "the same" I think
03:45:33 <shapr> @wn idempotent
03:45:34 <lambdabot> *** "idempotent" wn "WordNet (r) 2.0"
03:45:34 <lambdabot> idempotent
03:45:34 <lambdabot>      adj : unchanged in value following multiplication by itself; "this
03:45:34 <lambdabot>            matrix is idempotent"
03:45:49 <shapr> oh, in english you say "ditto"
03:46:08 <Lunar^> Thanks
03:46:11 <shapr> I wonder what you say in swedish.
03:46:12 <Lunar^> Saw sebc on orkut ?
03:46:17 <shapr> yes, he's a real person!
03:46:54 <Lunar^> That's amazing how your friend network is international
03:49:16 <shapr> it just happens when you like programming.
03:49:21 * shapr notices three countries in Lunar^'s friends list.
03:50:42 <shapr> Anyways, physical location isn't so important, just people.
03:50:51 <Maddas> I don't know anybody of my country on Orkut.
03:53:25 <shapr> you're in .de, right?
03:53:32 <Lunar^> btw, I couldn't make sebc continue hOp in it's current state
03:53:33 <Maddas> No, .ch
03:53:37 <shapr> oh, whoops
03:53:42 <Maddas> :-)
03:53:42 <shapr> Lunar^: how so?
03:53:50 <Lunar^> He said "We need a pure and strict language" and then fired emacs and started a parser
03:53:59 <shapr> why strict?
03:54:09 <shapr> what about the Robert Ennals' SpecEval branch of GHC?
03:54:12 <Lunar^> He's on holiday after all...
03:54:24 <shapr> I always have lazy holidays ;-)
03:54:30 <Maddas> haha
03:54:48 <Lunar^> shapr: Because we need to be able to know what memory will need a code block 
03:54:56 <Lunar^> dunno about SpecEval
03:55:24 * shapr thinks about that
03:56:12 <shapr> SpecEval won't fix that.
03:56:50 <Lunar^> shapr: Anyway, I will be experimenting with type class and intersection type system in the process, which is quite important
03:56:57 <Lunar^> s/I/he/
03:57:23 <Lunar^> or we... I never know what exactly is my part in this kind of process
04:00:14 <shapr> why do you need to know how much memory a code block will require ahead of time?
04:00:44 <Lunar^> To write a memory manager !
04:04:18 <shapr> could you have a Malloc typeclass? :-)
04:04:25 <Lunar^> ?\
04:04:53 <shapr> so that each type can malloc itself?
04:04:59 <shapr> or is that too crazy?
04:05:35 <Lunar^> I don't know :(
04:06:15 <shapr> I was thinking that you could pass the responsibility for memory allocation to the block that is being executed.
04:06:32 <shapr> then you don't need a strict language.
04:06:44 <Lunar^> interesting
04:07:02 <Maddas> shapr: Heh, lazy memory management. :)
04:07:10 <shapr> I wonder if it would work.
04:07:27 <Maddas> Just throw enough money at it!
04:07:29 * Maddas snickers
04:07:34 <shapr> that worked for C
04:07:41 <Maddas> And Java :-)
04:07:48 <shapr> yes, good point.
04:14:36 <shapr> I don't think you can allocate the memory for a Haskell block ahead of time, especially since the size of the memory will change.
04:15:21 <shapr> I think you'd have to know the maximum amount of memory that the code block could ever use.
04:15:43 <shapr> and for some inputs some code could use infinite space
04:15:54 <shapr> like the length function
04:16:18 * shapr wonders if he's talking crazy
04:21:22 <shapr> bonjour kowey 
04:24:53 <shapr> kowey: have some questions?
04:26:52 <kowey> bonjour shapr, hi all, just hanging around :-)
04:27:31 <shapr> ok, that's fine
04:48:52 <earthy> shapr: you are not talking crazy
04:49:10 <earthy> statically determining the size of memory a piece of code will occupy is nigh impossible
05:01:24 <shapr> greeting termio, looking for Haskell info?
05:05:53 <earthy> hmz.
05:06:05 <earthy> not trivial, trying to reconcile the wiki's CSS with the haskell-org.css
05:12:58 <shapr> how so?
05:13:55 <earthy> their structure is quite wildly different
05:14:06 <earthy> and haskell-org.css does not have to deal with wikiwords ;)
05:14:23 <earthy> *and* moinmoin.css imports 2 sub-css'es.
05:14:47 <earthy> and I barely know CSS. ;)
05:23:36 <Lunar^> I don't like moinmoin CSS 
05:26:11 <shapr> Lunar^: feel free to submit changes
05:27:25 <Lunar^> I'm talking about design here
05:27:28 <shapr> oh
05:27:33 <Lunar^> damn.. not visual design
05:27:52 <Lunar^> The way things are structured
05:37:16 <harsha123> shapr: do you use sawfish?
06:00:32 <earthy> damn. those powerballs really require trained lower arm muscles
06:32:16 <shapr> harsha123: no, I use ion
06:32:24 <shapr> greetz SyntaxNinja
06:36:42 <SyntaxNinja> y0 shapr
06:37:07 <shapr> wassup?
06:37:28 <SyntaxNinja> not much. looking for information about project management training.  Anyone know of any good web sites or anything?
06:45:08 <Lemmih> SyntaxNinja: I don't know if this is relevant but do you know MrProject?
06:46:21 <andersca> Lemmih: I've hacked on that
06:47:18 <SyntaxNinja> Lemmih: yeah, I've been messing with it.  I'm looking for something more like training, though.
06:58:50 <amb> hi
06:59:05 <shapr> hi amb, what's up?
06:59:22 <amb> not much, taking a rest from learning :-)
06:59:35 <amb> how about you?
06:59:55 <shapr> writing for-pay code, and fantasizing about doing it with Haskell.
07:00:07 <amb> :-)
07:00:21 <amb> what do you have to use?
07:00:41 <shapr> Python, which isn't so bad.
07:01:33 <amb> I see :-)
07:02:52 <shapr> what are you learning?
07:03:17 <amb> Comp. sci., I have an exam on friday :-)
07:03:23 <liiwi> schmoo
07:04:17 <shapr> hei liiwi 
07:04:52 <amb> hi liiwi
07:09:36 <liiwi> hi hi
07:20:45 <earthy> dammit. I'm not productive any more
07:20:50 <shapr> I'm sorry.
07:20:51 <shapr> why not?
07:21:05 <earthy> granted, trying to grasp all of nomaware's monad tutorial in one day is asking a tad much
07:21:22 <Riastradh> It's all this arcane theory discussion in #haskell that deters productivity.  Just hack!
07:21:28 <shapr> right!
07:21:33 <shapr> hack hack!
07:21:59 <earthy> well, I know that I want to rewrite some code I have to use ReaderT and ErrorT, but I don't yet quite know how
07:22:43 <Igloo> Is it monadic already?
07:22:54 <earthy> igloo: somewhat, yes.
07:23:12 <earthy> but it needs to be refactored, methinks
07:26:17 <earthy> since the current code is not really geared towards monadic use
08:09:45 <shapr> hey darius- 
08:09:47 <shapr> hej ski
08:10:07 <ski> shapr : hej hå
08:20:59 <darius-> morning shapr
08:33:08 <ski> hi CosmicRay
08:35:28 * shapr bounces cheerfully
08:37:31 * ski taps foot on radiaator
08:42:32 <Lunar^> shapr: Did you took the time to look halipeto ?
08:42:39 <Lunar^> shapr: Seems a lot like ZPT
09:01:46 <shapr> Lunar^: yes, it is based on TAL, I asked andrew.
09:02:56 <shapr> does anyone have a darcs binary that's linked against glibc 2.2.4 ?
09:03:22 <shapr> the debian/unstable binary is for glibc 2.3
09:03:53 <Lunar^> shapr: I think I have that
09:04:25 <shapr> could I grab a copy of the binary? I want to install it on a redhat 7.2 box.
09:04:29 <Lunar^> shapr: Take the .deb for woody in David's repository
09:04:36 <shapr> aha, thanks
09:05:29 <Lunar^> shapr: With Halipeto, what would still be missing for you to drop Zope ?
09:06:58 <shapr> I don't know, I'd have to try it and find out.
09:07:18 <shapr> haskelldb fixes the database part
09:07:27 <shapr> what pieces does Zope have?
09:08:08 <Lunar^> shapr: A web server !
09:08:13 <shapr> haha
09:08:22 <Lunar^> shapr: Halipeto produce CGI right now ?
09:08:27 <shapr> I think so
09:08:48 <Lunar^> shapr: Adding dynamic module loading to hws-wp
09:09:22 <Lunar^> shapr: Dynamic "servlet" loading and reloading
09:09:49 <shapr> I think that would be just a matter of stickin in Hampus Ram's SmartLoader code.
09:10:10 <Lunar^> shapr: What's that ?
09:10:15 * shapr gets url
09:11:50 <shapr> Lunar^: http://www.dtek.chalmers.se/~d00ram/dynamic/
09:12:16 <shapr> hws-wp already uses the ghci runtime loader
09:12:33 <shapr> though I don't know if anyone has tried to get it working with ghc 6.2
09:12:34 <Lunar^> Yeah, but it's kinda broken
09:12:39 <shapr> I'm the hws-wp maintainer though, so...
09:13:05 <shapr> ok, I'll put hws-wp update on my list
09:13:26 <shapr> I would very much like to get the pieces together to have a good answer to "weaving the web with haskell"
09:13:37 <Lunar^> So do I
09:13:44 <Lunar^> I would be glad to help you do so
09:14:03 <shapr> we're just helping ourselves escape from Zope ;-)
09:14:11 <Lunar^> :)
09:14:46 <shapr> of course, we need a name...
09:14:59 <Lunar^> geee templated haskell database formulars
09:15:35 <shapr> HaskellDB is spiffy.
09:15:37 <shapr> have you tried it?
09:15:57 <Lunar^> Still not... maybe we could set up some IRC introduction course
09:16:03 <shapr> forester, bring, viblo, chucky, and others are on the HaskellDB development team.
09:16:06 <shapr> that's a good idea.
09:16:54 <shapr> forester told me about some nifty code that took 53 minutes to typecheck on a 1400MHz Athlon XP!
09:17:08 <Lunar^> !!!!!
09:17:14 <shapr> I was very impressed.
09:17:39 <Lunar^> Type classes fault at first think
09:17:52 <shapr> yes, heavy use of typeclasses.
09:23:45 * ski chuckles
09:24:10 <Lunar^> Hebetude ?
09:24:29 <ski> what's that ?
09:24:29 <Lunar^> Maybe it's not commercial enough
09:28:00 <shapr> @wn hebetude
09:28:02 <lambdabot> *** "hebetude" wn "WordNet (r) 2.0"
09:28:02 <lambdabot> hebetude
09:28:02 <lambdabot>      n : mental lethargy or dullness
09:28:36 <ski> Lunar^ : is some site/blog called that ?
09:29:28 <Lunar^> ski: dunno
09:30:10 <ski> Lunar^ : just wondered why you said it ..
09:30:27 <Lunar^> ski: 18:14 < shapr> of course, we need a name...
09:30:40 <Lunar^> ski: I was thinking on a name with Haskell with Web somewhere
09:30:50 <Lunar^> Maybe "Hedb"
09:30:51 <ski> ah, ok
09:31:05 <Lunar^> Haskell, sounds a bit like "web" and "db" for database
09:31:34 <SyntaxNinja> I'm trying to install ghc on a redhat system where I don't have root... since rpm seems to require access to a database, I used alien on my debian machine to convert the rpm to a tgz. the problem, of course, is that it has aparently compiled-in paths to search for ghc library and needs glibc 2.3 when only 2.0 is installed.  can anyone suggest how I might get ghc onto this poor system?
09:31:55 <Igloo> You can just edit the shell script wrappers
09:33:23 <SyntaxNinja> even for the glibc problem?
09:33:49 <Igloo> Setting LD_LIBRARY_PATH so it finds a new libc might work for the glibc bit
09:34:38 <Igloo> Yes, any other libraries should also see the new one so it all ought to work, I think
09:35:20 <shapr> so, with HaskellDB and Halipeto, we have a partial application ;-)
09:35:26 * shapr smacks himself for bad humor
09:36:12 <Igloo> shapr: Are you trying to make something zope-like for Haskell?
09:36:14 <SyntaxNinja> igloo: it seems to me that it's finding the libc that's installed.  are you suggesting that I install the newer libc as well as ghc? (here's the error: ./ghc-6.2: /lib/i686/libc.so.6: version `GLIBC_2.3' not found (required by ./ghc-6.2))
09:36:17 <shapr> Igloo: yes
09:36:35 <Igloo> Nifty
09:36:42 <shapr> suggestions or ideas for such?
09:37:32 * Heffalump suggests you recompile ghc for this platform :-)
09:37:32 * shapr runs to shop, brb
09:37:46 <Igloo> Syn: But if you put the newer libc from another machine somewhere and set LD_LIBRARY_PATH so that comes first, I think it should work
09:38:09 <Igloo> Well, the real solution is clearly to convince the sysadmins to install Debian and install the ghc6 package  :-)
09:38:57 <Lunar^> shapr: hehe
09:40:55 <SyntaxNinja> Igloo: dude if I suggested that, they'd bite my head off.
09:41:22 <SyntaxNinja> I asked them 3 years ago why they use redhat, out of curiosity, and I got a dogmatic and angry reply.
09:41:32 <SyntaxNinja> they're just like that.
09:42:19 <Igloo> Is this the people you work for?
09:43:26 <SyntaxNinja> no. just sysadmins for the school. 
09:43:33 <Igloo> You could always grab fakechroot from Debian and work in a Debian chroot  :-)
09:43:45 <SyntaxNinja> heh
09:45:10 <Heffalump> can you get binary RPMs designed for the relevant redhat version?
09:45:39 <Heffalump> if so, you can pull the files out of it and probably mess around with the paths enough to get them to work (using ones designed for that version will solve the library issues)
09:46:56 <SyntaxNinja> right. looks like they actually have 2.2.4 on here
09:47:06 <SyntaxNinja> so ghc 5.04.3 might work
09:56:45 <shapr> guten abend cptchaos 
09:57:05 <cptchaos> shapr: guten abend!
09:57:46 <cptchaos> shapr: how are you?
09:57:57 <shapr> I'm awake! it's good!
09:58:11 <cptchaos> :-)
09:58:26 <shapr> I should contact Graham Klyne and Andrew Cooke
09:58:47 <shapr> they'd probably be interested in a coalescent organism like this.
09:58:50 <shapr> hej Marvin-- 
09:59:00 <shapr> does hws-wp reload plugins at runtime?
09:59:04 <Marvin--> evening
09:59:22 <Marvin--> sheesh, it's well over a year since I wrote that code
09:59:33 <shapr> just thought you'd know off the top of your head :-)
09:59:37 <shapr> if not, I'll check the source.
09:59:42 <Marvin--> I don't think I wrote anything for dynamic reloading, other things were higher on the priority list
09:59:51 <shapr> ok
10:00:04 <Marvin--> like, getting something to actually work before the deadline
10:00:09 <shapr> :-)
10:11:12 <ludde> Businesses and consumers stand to gain from the shift to 64-bit processing because 32-bit computers can't take advantage of more than 4 megabytes of memory at a time.
10:11:17 <ludde> quoted from http://www.cnn.com/2004/TECH/ptech/02/09/fortune.ff.amd.chips/index.html
10:11:24 <Marvin--> heh
10:12:23 <cptchaos> hm
10:12:30 <Maddas> What! Why didn't anybody tell me?!
10:12:35 * Maddas sells 508mb of his RAM
10:14:08 <Marvin--> depends on what you mean by "at a time", I guess
10:14:35 <Marvin--> what's the size of size_t on a 32-bit computer vs a 64-bit computer?
10:14:54 <ludde> probably 64 instead of 32
10:15:11 <Marvin--> I'm thinking malloc
10:15:15 <ludde> (bits)
10:15:19 <ludde> yes?
10:15:38 <ludde> i'm pretty sure size_t is 64 bits
10:15:41 <ski> Marvin-- : thinking on aligned mem blocks ?
10:17:24 <Marvin--> ski: that and I think size_t == unsigned long, which surely is 32 bits on a 32-bit machine?
10:17:46 <Marvin--> but heck if I know
10:17:57 <Marvin--> hard to say without knowing what they mean by "at a time"
10:18:32 <Igloo> size_t is the same size as a pointer AIUI
10:18:43 <ludde> Marvin--: in any case 4MB is clearly wrong
10:19:56 <ludde> i don't think any consumer would need 64-bit in the next 5-10 years anyway
10:24:13 <cptchaos> hm, i guess in 5 years you will see the first games needing more than 4 GM memory ...
10:24:30 <cptchaos> s/GM/GB/
11:31:24 <ski> hello CoolPops
11:31:42 <CoolPops> ski: howdy.
11:32:02 <ski> how is haskell ?
11:32:09 <ski> (any questions ?)
11:32:30 <CoolPops> ski: I am liking haskell, but at the same time it can be frustrating.
11:32:54 <ski> ok
11:33:11 <CoolPops> I am trying to make a function to parse a comma delimited string. I pasted a few lines of code (9) to: http://www.pastebin.com/41760 in hopes that someone can help me out.
11:33:53 <CoolPops> bear in mind that I'm a n00b to Haskell, and functional languages.
11:34:02 <ski> ok
11:34:46 <ski> does it typecheck ?
11:35:28 <CoolPops> ski: the function runs but returns a string instead of a list of fields.
11:35:51 <ski> hm
11:36:34 <ski> what's "lst" for, seems it never changes
11:36:49 <ski> ?
11:37:16 <CoolPops> ski: on the 2nd parse_comma, word get's ++ to lst ...
11:37:24 <ski> no
11:37:37 <CoolPops> ski: hm.
11:37:55 <ski> 3D(parse_comma xs x "" lst) ++ word
11:38:01 <ski> (parse_comma xs x "" lst) ++ word
11:38:10 <ski> is your body of that line
11:38:17 <ski> perhaps you want
11:38:23 <CoolPops> ski: so, parse_comma xs x "" (lst ++ word)
11:38:24 <ski> parse_comma xs x "" (lst ++ word)
11:38:28 <ski> yes
11:38:55 <ski> function application binds very tight
11:39:30 <CoolPops> hm. that's confusing, it does the exact same thing.
11:39:38 <ski> and.. what's the "ch :" for ?
11:39:41 <CoolPops> it seems as though the 2nd parse_comma is never matching.
11:39:42 <ski> mhmm
11:40:29 <ski> is it intended to throw away ch in the 1st line ?
11:40:45 <CoolPops> ski: no.
11:41:13 <CoolPops> ski: let me re-think this for a second.
11:41:46 <ski> also ..
11:42:20 <ski> why are you pattern-matching against (x:xs) in parse_it (and passing x and xs on to parse_comma) ?
11:42:51 <ski> (not implying that this must be wrong, just want to know if there's some specific reason you do that)
11:43:31 <CoolPops> ski: I was intending on it being the calling function, so when you wanted to parse a comma line you call parse_it "Fld1,Fld2,Fld3"
11:44:09 <CoolPops> ski: so parse_it would then begin the parse_comma which takes the list, the current character, the current word it's building, and the resulting list.
11:44:30 <ski> i was just thinking that something like 'parse_it xs = parse_comma xs "" []' might be clearer, if you don't need that pattern-match there ...
11:46:09 <ski> (i guess lst is meant to be an accumulator, then)
11:46:20 <CoolPops> ski: yes. 
11:46:49 <ski> ok, hmm
11:48:18 <CoolPops> ski: ok, some minor changes: http://www.pastebin.com/41765
11:48:22 <ski> hm, i think, at least currently, if one calls parse_it, 'word' in parse_comma is always going to be bound to "" (which comes from the parse_it line)
11:48:38 <CoolPops> ski: I think I may be getting some where once you pointed out my word ++ lst problem.
11:48:41 <ski> ok
11:48:47 <ski> looks better, i think
11:48:50 <CoolPops> http://www.pastebin.com/41765
11:51:05 <CoolPops> ski: I got it! http://www.pastebin.com/41766
11:51:42 <CoolPops> ski: thank you for your help. The error you pointed out about the lst ++ word, and then the ch : parse_comma were the two biggies that I did incorrect.
11:52:05 <ski> CoolPops : hmm
11:52:21 <CoolPops> ski: do you see something you would change?
11:52:45 <ski> hmm
11:52:54 <ski> probably
11:53:32 <ski> why these reverse all over the place ?
11:53:46 <ski> hm
11:54:01 <ski> word is built backwards, yes ?
11:54:13 <CoolPops> ski: because it appends the word backward. I was told it's better to ch : word, then when all done do a reverse on it.
11:54:41 <CoolPops> ski: if they are not there, then my words are backwards.
11:54:56 <ski> ok
11:55:14 <ski> i think i would still ditch the extra ch argument to parse_comma
11:55:26 <ski> would be clearer, methinks
11:56:02 <ski> also, i would *not* append things to the end of lst, all the time
11:56:45 <ski> ("it's better to" build it backwards ", then when all done do a reverse on it.")
11:57:16 <ski> CoolPops : what do you think ?
11:58:38 <CoolPops> ski: yes... I need to change my 2nd parse word.
11:58:54 <ski> "2nd parse word" ?
11:58:55 <CoolPops> ski: but I don't understand how ditching the (x:xs) in parse_it would work.
11:59:07 <ski> like
11:59:11 <CoolPops> ski: I need to append word to the front of the list, correct?
11:59:29 <ski> well, that is probably better, yes
12:00:04 <ski> (then you can reverse the whole lst, either in 1st line of parse_comma, or in parse_it. if you want it reversed back)
12:00:30 <ski> re ditching (x:xs) :
12:00:44 <ski> parse_it xs = parse_comma xs "" []
12:01:13 <ski> parse_comma [    ] word lst = lst ++ [reverse word]
12:01:44 <shapr> YOW!
12:01:53 <ski> parse_comma (',':xs) word lst = parse_comma xs "" (lst ++ [reverse word])
12:02:20 <ski> parse_comma (ch:xs) word lst = parse_comma xs (ch:word) lst
12:02:31 <ski> CoolPops : would that work ?
12:02:34 <ski> @yow
12:02:34 <lambdabot> We have DIFFERENT amounts of HAIR --
12:02:38 <CoolPops> ski: can I match a (',':xs) ?
12:02:45 <ski> shapr : hiya
12:02:50 <ski> yes
12:02:56 <CoolPops> ski: ah, ok.
12:03:18 <kowey> bye room, good luck CoolPops
12:03:24 <amb> bbiab
12:04:59 <CoolPops> http://www.pastebin.com/41769 ... updated.
12:06:01 <ski> ok
12:06:19 <CoolPops> hm. that produces: ["9","AN","RPC_H92","This is a description"] ... that's the incorrect order, how did that happen?
12:06:27 <ski> btw, "[x] ++ xs"  is the same as "x : xs"
12:06:55 <ski> you forgot to change order of ++ args in first line
12:07:03 <ski> also forgot to do a final reverse
12:08:14 <CoolPops> http://www.pastebin.com/41770 ... so you are correct :-) ... How's that one look now. It seems to work fine.
12:08:59 <ski> (except you can use ':' once more ;)
12:09:11 <ski> more achanging :)
12:09:15 <CoolPops> ski: ha. your right.
12:09:30 <ski> otherwise it looks quite nice, methinks
12:10:26 <ski> you might perhaps wanna make parse_word a local helper to parse_line, at least after you've finished testing/playing with it
12:10:39 <CoolPops> ski: you were very helpful, thank you.
12:10:56 <CoolPops> ski: hm. I don't know what a local helper is.
12:10:56 <ski> thanks, no prob
12:11:11 <ski> the 'where' keyword. know it ?
12:11:21 <CoolPops> ski: yes I do know it.
12:11:31 <CoolPops> ski: it's one of my favorite things about haskell :)
12:11:38 <ski> :)
12:12:55 <ski> (only sometimes i yearn for an SML-local thingie .. )
12:14:26 <ski> CoolPops : what you've done before ?  (C ?  Java ?  Pascal ?? ..)
12:14:51 <CoolPops> ski: C/C++, Python, PHP. other similar langs.
12:14:59 <ski> ok
12:15:13 <CoolPops> never a functional one.
12:15:32 <ski> (significant indent is not totally alien to you, then)
12:15:33 <CoolPops> well, they all functioned, but you know what I mean :)
12:15:41 <CoolPops> ski: correct.
12:15:41 <ski> yes :)
12:18:10 <ski> what do you think of haskell, so far ?
12:19:13 <CoolPops> ski: it is pretty cool, however very different from what I am use to. One of the tutorials said that when you feel like quitting because things are too odd, stick with it and you'll be happy later.
12:19:32 <CoolPops> ski: the sticking with it part is where I am at... A few times I thought, this is crazy, I'm outahere.
12:19:44 <ski> hehe :)
12:20:03 <ski> it's a paradigm shift
12:20:35 <CoolPops> ski: but I've committed to myself to finish the tutorials, do the exercises and recreate a few simple utilities that I wrote in C and python.... so that's what I'm gonna do.
12:21:04 <Marvin--> be careful that you don't just rewrite the C/python code, that usually leads to crappy haskell code
12:21:29 <CoolPops> Marvin--: actually, I havn't been consulting that code whatsoever for that reason.
12:23:28 <CoolPops> Marvin--: I've been trying to think in Haskell but I don't think that will happen efficiently for quite some time. I've been programming for about 15 years.
12:24:32 <Riastradh> CoolPops, use Catbert's secret unlearning method.
12:24:49 <Riastradh> It works very well for people who are stuck on imperative programming!
12:24:57 <Maddas> Riastradh: Elaborate, please.
12:25:13 <CoolPops> Riastradh: hum... I know dilbert but never heard of that.
12:25:51 <Riastradh> Well, you take the programmer, blindfold him, sit him in a chair, and then get a big mallet...
12:26:00 <ski> haha
12:26:04 <CoolPops> uh, I think I'll pass that method.
12:26:17 <CoolPops> and don't say it too loud around my boss.
12:33:24 <amb> Is someone in here reeeallly bored? :-)
12:33:41 <cybermanco> nop
12:33:46 <ski> what are you implying ?
12:33:47 <amb> ok :-)
12:34:14 <amb> I was just wondering if somebody would like to glance at the horrible source I made and suggest how I could make it a lot cleaner
12:34:33 <amb> As the beginner in haskell I am... it is really disgusting
12:34:51 <ski> i could glance a little at it, i guess
12:35:19 <ski> is it very big ?
12:35:53 <amb> Well, not that big, everything together about 3/4 of a screen
12:36:01 <ski> ok
12:36:06 <ski> where's it ?
12:36:08 <amb> But the most important part (and worst) is only 10 lines or so
12:36:11 <amb> Even less
12:36:15 <amb> On my comp :-)
12:36:20 <amb> Wait, I'll upload it somewhere
12:36:27 <ski> accessible on net somewhere ?
12:36:49 <amb> in a min :-)
12:37:05 <CoolPops> amb: you can use http://www.pastebin.com
12:37:11 <ski> perhaps on hawiki/IrcPastePage or http://www.pastebin.com/
12:37:13 <ski> ok
12:37:42 <ski> [1st]Tek ?
12:38:05 <ski> (prolly not)
12:38:54 <amb> [1st]Tek?
12:39:59 <ski> amb : just wondered which post were you ..
12:40:28 <ski> ('twas the most recent, but perhaps you haven't completed pasting yet)
12:41:41 <amb> http://www.amb-mcm.com/mkv.hs
12:41:44 <amb> Sorry it took so long :-/
12:41:45 <ski> ok
12:42:26 <ski> which part do you feel is ugly ?
12:42:41 <ski> (i.e. where should i look ?)
12:42:41 <amb> specially the strfst
12:43:16 <ski> what should it do ?
12:43:47 <amb> Well, giving me advice on how to make it "nicer" :-)
12:44:20 <ski> (also, it's a little confusing to give different arguments in different lines, the same name ..)
12:44:38 <amb> ouch, sorry :-)
12:44:47 * amb will try to remember that
12:45:12 <blackdog> you might want to give a few type synonyms - much better than comments
12:45:51 <amb> Oh, ok, thanks blackdog
12:46:29 <blackdog> and you can dump '== True' wherever you see it.
12:46:49 <amb> Noted :-)
12:47:21 <ski> s/findit/found/  or perhaps isFound
12:48:30 <ski> can't you ditch searchdot ?
12:49:13 <ski> use   "(foo,bar) = solveRule a (x,ys)"  and s/fst(searchdot)/foo/  and s/snd(searchdot)/bar/ ...
12:49:30 <amb> oh, I see
12:49:39 <ski> (for some well-chosen names foo, bar)
12:49:46 <amb> lol
12:49:56 <ski> prob same with searchnodot
12:50:41 <Marvin--> amb: you seem to be overusing parentheses
12:50:43 <blackdog> i think you also compute ""fst(solveRule a (x,y))" twice
12:51:54 <amb> Hmm, yes, changing that would certainly make it faster, right? :-/
12:54:07 <blackdog> it's not a recursive function, so unless the strings involved are pretty long, chances are it won't make a massive difference.
12:54:22 <blackdog> I think solveRule ought to return "Maybe String"
12:54:49 <amb> Maybe String?
12:54:58 <Marvin--> amb: anyhoo, in    x = (foo bar baz)  the parentheses are completely unnecessary and just clutter the code
12:55:22 <amb> ok, thanks Marvin
12:55:28 <blackdog> Yeah - AFAICT, when the second component is False, you don't do anything with it, which is the Maybe pattern exactly.
12:55:34 <ski> is first arg to solve and solveRule some kind of default ?
12:55:35 <Marvin--> and you never have to write  snd(foo),  snd foo  is equivalent and the usual way we write it
12:55:37 <amb> Oh, I see... I didn't know about that Maybe thing :-)
12:56:44 <amb> ski: no, not necessarily
12:56:54 <amb> ski: It is the string you want to "parse"
12:57:28 <Marvin--> amb: [x]  is syntactical sugar for  x:[]  and it's common practice to use it :)
12:57:30 <ski> solveRule seems to return a as first part of pair when second part is False
12:58:16 <blackdog> that's his Maybe substitute...
12:58:21 <amb> ski: Yep, when it doesn't find a Rule that applies to a, then it just returns a
12:58:36 <ski> that is probably unnessecary
12:58:56 * amb is reading on maybe, thanks for the pointer blackdog
12:59:34 <blackdog> no wuckas.
12:59:54 <CoolPops> What's the standard for function names? parse_file or parseFile? or is there?
13:00:11 <ski> CoolPops : i think parseFile is more common
13:00:50 <CoolPops> ski: ok.
13:29:26 <CoolPops> How can I return a string that I have created in a do block?
13:29:37 <ski> hmm
13:29:47 <ski> perhaps you want 'return str'
13:30:22 <ski> do you want to return the string, or do you want to get a handle on it ?
13:30:25 <CoolPops> hm, somthing is the same as C?
13:30:41 <ski> 'return' in haskell /= 'return' in C !!
13:30:57 <CoolPops> readFile fn = do
13:30:57 <CoolPops>     h <- openFile fn ReadMode
13:30:57 <CoolPops>     l <- liftM lines (hGetContents h)
13:30:57 <CoolPops>     hClose h
13:30:58 <CoolPops>     return l
13:31:23 <ski> don't hClose a handle passed to hGetContents
13:31:35 <CoolPops> ski: opps.
13:31:38 <ski> it's already semi-closed
13:32:06 <ski> so l is the string you want to return ?
13:32:21 <CoolPops> ski: yes, it's actually a list of strings.
13:32:24 <ski> CrewdenX : hi
13:32:28 <ski> ok
13:32:30 <CrewdenX> ski: hi
13:32:49 <ski> you could write :
13:32:52 <ski> readFile fn = do
13:32:56 <ski>     h <- openFile fn ReadMode
13:33:01 <ski>     liftM lines (hGetContents h)
13:33:15 <ski> that'll also return the list of strings
13:33:27 <CoolPops> ski: why are things so obvious when others do them but not when your trying to?
13:33:29 <ski> but perhaps you think the above is clearer ..
13:33:42 <ski> CoolPops : ha ! :)
13:34:00 <Marvin--> CoolPops: because you're still learning?
13:34:03 <ski> you just need a bit more experience :)
13:34:07 <Marvin--> or was that too boring an answer? :)
13:35:51 <CoolPops> hm. I thought liftM would give me a String, not an IO String? But at the ghci prompt, when I type: ":t File.readFile "Hi.txt"" I get File.readFile "Comma.hs" :: IO [String]
13:36:15 <Marvin--> well, what's the type of liftM?
13:36:18 <Marvin--> @type liftM
13:36:19 <CoolPops> (well, obvious filename diffs, but that was my typo).
13:36:24 <Marvin--> @type Control.Monad.liftM
13:36:29 <Marvin--> hm
13:36:32 * Marvin-- pokes lambdabot
13:36:48 <monotonom> liftM : (a->b) -> (IO a -> IO b)
13:37:04 <Marvin--> exactly
13:37:16 <CoolPops> liftM :: forall r m a1. (Monad m) => (a1 -> r) -> m a1 -> m r
13:37:25 <Marvin--> CoolPops: so, what type would  liftM lines  have?
13:37:34 <monotonom> In this case m=IO.
13:37:56 <CoolPops> yes, it would be returning a pair, (a,b) of the IO type.
13:38:09 <ski> lines :: String -> [String]
13:38:12 <ski> a pair ?
13:38:23 <CoolPops> wouldn't it? (IO a -> IO b)?
13:38:31 <ski> that's a function
13:38:46 <monotonom> "But a function is a set of pairs!" :)
13:38:50 <CoolPops> hm.
13:39:02 <ski> (but you aslo pass  (hGetContents h)  to it in your code)
13:39:12 <ski> monotonom : haha
13:39:24 <monotonom> liftM lines : IO String -> IO [String]
13:39:29 <Marvin--> monotonom: that would be a relation
13:39:59 <CoolPops> how do I convert IO String into String?
13:40:08 <ski> Marvin-- : "But a function is a special kind of relation !"
13:40:10 <Marvin--> CoolPops: you don't
13:40:20 <monotonom> unsafePerformIO :: IO a -> a   :)
13:40:20 <CoolPops> How do I use the contents of my file?
13:40:36 <Marvin--> monotonom: *please* don't help him shoot himself in the foot *already*
13:40:45 <ski> monotonom : don't tempt the poor programmer with evil !
13:41:01 <Taaus> A function is a relation+domain+codomain ;)
13:41:03 <Cale> You shouldn't ever need to turn an IO a into an a.
13:41:33 <Marvin--> CoolPops: basically, you can "convert" it locally using the "<-" binding inside a do expression
13:41:40 <ski> Taaus : So a relation has no domains for its arguments ?
13:41:46 <Marvin--> CoolPops: it's all syntactic sugar, though
13:42:09 <monotonom> http://www.google.ca/groups?q=IO+group:comp.lang.functional+author:trebla%40vex.net&hl=en&lr=&ie=UTF-8&oe=UTF-8&selm=4uit5o6ebt.fsf%40vex.net&rnum=1
13:42:22 <Marvin--> CoolPops: you already did it with openFile
13:42:40 <monotonom> That is my serious answer to the question.
13:43:37 <Taaus> ski: A relation is simply a subset of the cartesian product of the two sets involved... I guess you could call those the domain, but it wouldn't make a whole lot of sense (IMO).
13:43:46 <Marvin--> monotonom: well put
13:44:18 <CoolPops> Marvin--: but how do I return that then? l <- hGetcontents h === The last statement in a 'do' construct must be an expression
13:44:20 <ski> Taaus : 'binary relation', you mean ? :)
13:44:29 <Taaus> ski: Naturally.
13:45:02 <Marvin--> CoolPops: that's where the return function (note: function, not keyword) comes into the picture,  return :: Monad m => a -> m a
13:45:47 <ski> Taaus :  IsSubset :: Pred (Set a,Set a)   ?   (Pred is just powerset)
13:45:59 <Marvin--> but you have to realize that it does nothing like C's return statement, it does not jump back to the calling function or anything of the sort, it just creates a monadic value
13:46:28 <Taaus> ski: I'm not sure I follow you.
13:46:42 <CoolPops> Marvin--: ok, but I still can't use my value.... let l = File.readFile "Comma.hs" ... fst l = Couldn't match `(a, b)' against `IO (IO String)'
13:46:57 <monotonom> do { l <- return "hello"; print l }
13:47:09 <ski> Taaus : (oh, just a type with 'domains' for arguments of a predicate)
13:47:25 <ski> Taaus : (in haskellish syntax)
13:47:30 <Cale> do { l <- return "hello"; print (reverse l) }
13:47:33 <Taaus> ski: Ahh. Right. :)
13:47:41 <Marvin--> CoolPops: first of all, you would need   do { l <- File.readFile "Comma.hs" ...  rather than let l = ...
13:47:46 <Marvin--> CoolPops: since readFile is monadic
13:48:18 <ski> CoolPops : why 'fst' ?  do you think it gives the first elem of a list ??
13:48:36 <Marvin--> CoolPops: second, fst (x,y) = x, I think you want head (x:xs) = x
13:48:50 <Marvin--> tuples aren't lists
13:50:47 <CoolPops> Marvin--: yes. I got my func's messed up.
13:51:01 <monotonom> Gosh I responded to Andrew Cooke!  http://www.google.ca/groups?q=IO+group:comp.lang.functional+author:trebla%40vex.net&hl=en&lr=&ie=UTF-8&oe=UTF-8&selm=m37kzkeef5.fsf%40career.localdomain&rnum=2
13:51:36 <Marvin--> monotonom: ... so?
13:51:56 <Cale> coolpops: http://www.nomaware.com/monads/html/ is a nice tutorial
13:52:32 <CoolPops> Cale: thank you, I've bookmarked it and will begin to read it.
13:52:33 <monotonom> The other day Andrew Cooke came to the channel and we were wondering if any of us had conversed with him on newsgroups.
13:53:12 <Marvin--> oh
13:53:14 <Cale> I especially like the little physical analogy in the appendix.
13:53:33 <Marvin--> physical appendix?
13:53:38 <Marvin--> :)
13:54:15 <Cale> heh
13:55:50 <CoolPops> Well, it's quitting time here at work. I appriciate everyone's input today. I'll do some more reading and playing tonight.
13:56:45 <ski> Cale : do you refer to the bodily organ ?
13:56:51 <Cale> no
13:56:57 <Cale> the appendix to http://www.nomaware.com/monads/html/
13:57:06 <ski> thought i'd just check ..
13:57:35 <Cale> http://www.nomaware.com/monads/html/analogy.html
13:57:44 <ski> (Marvin-- said "physical appendix", so i associated it with that ..)
13:58:22 <ski> (english word seems to be blind gut)
13:59:33 * ski thought they *might* have had some joke on that ..
14:00:19 <Marvin--> er, why the heck do they write   (return w) >>= ...?
14:00:52 <ski> who 'they' ?
14:01:00 <ski> MiB ?
14:01:15 <monotonom> Because it saves a line :)
14:01:16 <ski> The troglodytes ?
14:01:56 <Cale> to show the structure a little bit more?
14:03:32 <Marvin--> foo w = return w >>= expr1 >>= expr2   is just...bad
14:03:40 <Marvin--> it should simply be  foo w = expr1 >>= expr2
14:04:08 <Marvin--> especially when they don't have (return w) in the do-variant
14:04:09 <monotonom> True.
14:04:41 <Marvin--> instead they add a stupid  return c''  that looks like it came from C
14:05:17 <monotonom> c'' can't come from C. Oh maybe it can. Haha.
14:05:29 <Marvin--> har. har. you know what I mean
14:05:38 * monotonom designs a new programming language and calls it C''.
14:06:01 <Marvin--> C-biz
14:06:06 <Marvin--> for biznizes
14:06:07 <ski> someone should design a new programming language called C?
14:06:16 <ski> as in "see ?"
14:06:52 <Taaus> c'' looks like "c of equality type" to me... Damn you, ML!
14:07:01 <Marvin--> heh
14:07:35 <ski> Taaus : ''c
14:08:00 <Taaus> Yes. See the similarity? ;)
14:08:38 <ski> "not at all similar", he said
14:09:04 <Taaus> Guess it's just me, then.
14:09:21 * ski was (partly) joking :)
14:09:28 <Taaus> :)
14:17:37 <skew> Marvin--: How does foo w = expr1 >>= expr2 get the value in?
14:19:12 <Marvin--> skew: w is in expr1's and expr2's scope
14:19:15 <skew> Marvin--: Maybe arrow notation. I think foo = expr1 >>> expr2 is equivalent
14:20:18 <ski> skew : expr1 >@> expr2 perhaps ?   (f >@> g) x = f x >>= g
14:20:40 <skew> Oh. I was thinking "expr1" and "expr2" were some functions
14:20:59 <Marvin--> nah, generic expressions
14:21:03 <skew> not expressions you could rewrite to use w directly
14:21:26 <Marvin--> I'd use some LaTeX stuff if it would make it easier ;)
14:24:07 <skew> Is >@> defined anywhere?
14:26:53 <skew> does anybody have a good intuition for arrows?
14:27:19 <skew> I could never make sense of the example of functions on nested tuples
14:28:58 <stepcut> I read about arrows for a few days, but I still don't understand them :P
14:29:10 <ski> skew : IIRC i saw >@> in some paper  (hughes ?)
14:29:43 <ski> skew : what example ?
14:31:29 <skew> one example was SomeType a b = (a -> b) :&& SomeType (a,a) (b,b)
14:31:47 <Marvin--> yaiks
14:32:27 <skew> I'm looking for the paper. They had odd expressions for an arrow that shifted the values, and so forth
14:32:38 <skew> (pushing in a new value from one end)
14:33:21 <ski> skew : that one seems funny. haven't seen it before
14:33:49 <ski> how to define arr and (>>>) for that ?
14:34:05 <ski> hmm
14:34:18 <skew> arr f = f :&& arr (\(x,y) -> (f x, f y))
14:34:44 <ski> (ok, misread : i didn't see SomeType on rhs)
14:34:49 <skew> arr (f :&& f') (f :&& g') = (f . g :&& f' . g')
14:35:44 <ski> hmm, don't get that last line
14:35:58 <Taaus> Arr! Haskell, the language of pirates!
14:36:10 <ski> isn't it the case that  arr :: Arrow ar => (a -> b) -> a `ar` b  ?
14:36:28 <skew> wait, should be f' `arr` g'
14:36:54 <ski> hmm ?
14:38:43 <ski> should that last really be  (f :&& f') >>> (f :&& g') = ...  ?
14:39:58 <skew> yes, read >>> for arr
14:41:37 <ski> did they name a use for SomeType ?
14:42:02 <skew> yeah, I'm reading Hughes paper now to see if I can find it
14:42:53 <skew> nope, maybe in Ross' paper
14:44:11 <skew> Okay, section 4.2 "Homogenous Functions". The type was called "Hom"
14:44:21 <ski> hmm
17:53:34 * stepcut cringes at his incredibly ugly code
17:59:29 <ski> @arr
17:59:29 <lambdabot> Yeh scurvy dog...
18:11:35 <amb> night everyone
18:43:36 <pattern> hi skew
18:43:37 <lament> fight! fight! fight!
18:43:42 <skew> hi
18:43:43 <pattern> now what was it you wanted to say? ;)
18:44:08 <skew> Hi folks. pattern came over from Python, where he's been talking about type systems
18:44:33 <skew> pattern: #python seemed to be getting bored.
18:44:45 <pattern> i'm an ocaml beginner, though... so don't hurt me too bad ;)
18:44:45 <ski> ok
18:44:53 <skew> pattern: I think people here might have interesting things to say about O'Caml and the virtue of types
18:45:06 <skew> if anybodie's listening
18:45:26 <pattern> well, what in particular did you want me to bring up here?
18:45:26 <ski> well, what do you want to say ?
18:45:38 <skew> well,
18:45:56 <pattern> i was explaining the virtues of static typing on #python without much luck
18:46:03 <ski> :)
18:46:09 <pattern> people didn't seem to be listening
18:46:14 <pattern> i think i did a good job, overall
18:46:21 <skew> I think you started from untyped languages and continued into slightly typed languages
18:46:29 <pattern> you can lead a horse to water, but you can't make him drink ;)
18:46:29 <skew> and just into O'Caml
18:46:51 <skew> From your perspective an untyped language is weak, and provides no support
18:47:40 <skew> I think as you get into more powerful type systems it starts to become apperent where they are restrictive
18:47:50 <pattern> i didn't say that.. i think i was talking more about static vs dynamic typing
18:48:13 <ski> skew : where 'what' is restrictive ?
18:48:23 <pattern> you can still have strong typing in dynamically typed languages
18:48:41 <skew> ski: writing programs that type under a particular type system
18:48:53 <skew> ski: e.g, simply typed lambda calculus
18:49:12 <SamB> I like half-static typing. that is, haskell with existential typing. well, on paper anyway ;-).
18:49:13 <skew> pattern: I'm talking static types too
18:49:13 <ski> mm
18:49:23 <skew> SamB: that's completely statically safe
18:49:34 <ski> SamB : is that 'half-static' ?
18:49:42 <skew> pattern: I'm talking about static vs. dynamic
18:50:11 <skew> pattern: Once you've used very flexible type systems you can thing of dynamic typing as an ultimately flexible type system with no compiler support
18:50:29 <skew> pattern: modulo stuff like implementing type class inference yourself
18:50:40 <SamB> well, it is safe, yes, but it allows some things you would do with dynamic typing in Python
18:51:10 <ski> SamB, so ?
18:51:28 <skew> SamB: yes, the point of a type system is proving stuff, not being unable to write code!
18:51:47 <skew> SamB: Of course type systems lead to the latter, to make the former more tractable
18:52:07 <skew> SamB: The proper phrasing is "Haskell has a really awesome type system"
18:52:14 <skew> :)
18:52:43 <skew> pattern: I think a lot of people on #python are pretty familiar with modern typed languages
18:53:05 <SamB> skew: I reserve that comment until after they rework the Prelude with new number typeclasses
18:53:08 <ski> skew : like what langs. ?
18:53:16 <pattern> that may be... but the ones arguing with me were confusing even basics like strong and static typing
18:53:27 <skew> A decent number of people know some degree of Haskell
18:53:51 <skew> one of the main people arguing with pattern had written non-trivial stuff in O'Caml, etc
18:54:06 <skew> pattern: I must have missed that
18:54:20 <pattern> i'd say jemfinch, who's written an irc bot in both ocaml and python was the only one there who seemed to know what he was talking about re: static typing
18:54:21 <skew> pattern: I think somebody misspoke and corrected themselves once
18:54:46 <pattern> yeah, it's not a big deal
18:54:55 <pattern> just noticed some misconceptions
18:54:56 <skew> and where did you get that stuff abuot needing an infinite number of tests anyway? :)
18:55:12 <skew> Yeah, there was that one guy who thought static types = type annotations
18:55:19 <pattern> that too
18:55:23 <pattern> but a seperate guy, i think
18:55:24 <skew> but I know I wasn't the only one to correct him
18:55:27 <pattern> a seperate instance, anyway
18:57:23 <SamB> well, a fair number seem to understand parametric polymorphism
18:57:33 <skew> sometimes the channel lists overlap considerably
18:58:24 <pattern> well, i'm just speaking of most of the people who spoke to me on this particular issue
18:58:45 <pattern> doubtless there were others
19:00:34 <skew> I think part of this is that there are many useful things you can do in Python that would be very hard to type
19:00:51 <pattern> like what?
19:01:20 <ski> skew : subtyping kindof things ?
19:01:35 <skew> adding and removing attributes at runtime
19:01:45 <skew> getattr, stuff like that
19:01:54 <skew> most of it could probably be formalized if you thought hard enough
19:03:37 <pattern> sorry, not familiar with getattr
19:03:45 <skew> looking up an attribute by name
19:03:49 <pattern> seems to be some kind of oo thing, don't know oo
19:03:52 <skew> from a string
19:04:05 <pattern> what do you mean by "attribute"?
19:04:16 <skew> It's more that python is built on dictionaries for namespaces
19:04:27 <skew> And you can access them with the surface syntax, or more like a dictionary
19:04:32 <pattern> dictionaries are associtative arrays?
19:04:37 <pattern> or libraries?
19:04:40 <pattern> or what?
19:04:48 <skew> I think they use hashes, but yes, like associative arrays
19:04:52 <skew> mapping names to values
19:04:52 <pattern> ok
19:05:12 <pattern> so getattr fetches the value of a certain key?
19:05:26 <skew> And you can use them at the "object level", with something like x.y
19:05:43 <skew> Or at the "meta level", where you see that they are a dictionary, like getattr(x,'y')
19:06:02 <pattern> i don't know oo, so i don't know what you mean by using them at the object level
19:06:15 <skew> I'm using that in the sense from formal logic
19:06:38 <skew> where you have a logical system with some symbols, like + or \elem
19:06:48 <ski> skew : are environments dicts too ?
19:06:53 <skew> ski: yes
19:07:08 <skew> modeled with constructions like maybe real sets, or pairs of dictionaries
19:07:09 <ski> skew : indefinite extent ?
19:07:14 <skew> Rather, pairs of integers
19:07:20 <skew> ski: What?
19:07:49 <skew> I'm confusing the logic a little bit here, but the "object level" is working in a system
19:07:51 <ski> skew : when do they expire. when leaving block ?
19:08:10 <skew> and the "meta level" is talking about the system, or how it's built or such
19:08:32 <pattern> is there an analogy you could use with modules?
19:08:33 <skew> ski: scoping is almost at function level
19:08:49 <skew> ski: That is, a few constructs have a name valid only in the scope of that construct
19:09:00 <skew> ski: but aside from that scoping is at function level
19:09:06 <ski> skew : wondering if one can, say capture an env. and return it, then access it..
19:09:16 <SyntaxLaptop> hey all.
19:09:19 <skew> ski: Oh, if you save a reference it would live on
19:09:40 <ski> skew : ok
19:09:54 <skew> ski: You are not guaranteed to be able to change bindings through the dictionary returned by locals(), though
19:10:02 <SyntaxLaptop> can anyone explain "throw" to me a little bit: does it work like Java where it keeps getting thrown at each level and if it doesn't get caught at the top level, it spews an error and exits? or does it spew an error and exit if it doesn't get caught at _any_ level?
19:10:05 <pattern> so with getattr you can inspect part of an object?
19:10:16 <SyntaxLaptop> that's control.exception.throw to which I refer
19:10:24 <skew> pattern: Yes, and with setattr you can add new parts
19:10:42 <skew> SyntaxLaptop: It's only a problem if it makes it all they way up. What is "every level" anyway?
19:11:10 <SyntaxLaptop> skew: every level in the call stack
19:11:12 <ski> SyntaxLaptop : what's the diff. ?
19:11:22 <pattern> skew, with functors, which i am only vaguely familiar with as i'm still learning ocaml, i believe you can transform modules
19:11:38 <skew> pattern: Yes, but it's a pain
19:11:39 <pattern> how are getattr and setattr different?
19:11:46 <SyntaxLaptop> if function A calls function B which calls function C, function C throws an exception, B does not catch it, but A does not get a chance to catch it.  That would be "if it doesn't get caught at any level"
19:11:47 <skew> pattern: can you do it at runtime?
19:11:55 <SyntaxLaptop> which would not be how java works :)
19:11:56 <pattern> skew, i don't know
19:12:07 <pattern> skew, people on #ocaml should, though :)
19:12:07 <skew> pattern: can you have some function that adds a marker field to every object that passes through it?
19:12:25 <skew> pattern: That was rhetorical. You can't, short of spawning and interpreter
19:12:49 <pattern> skew, functors are not an oo feature of ocaml.. they are used with ocaml's module system.. i know even less about ocaml's oo system than i do about functors
19:13:07 <skew> I don't remember much about the oo system.
19:13:15 <ski> SyntaxLaptop : you mean like, abandoning the exn if not caught at next level, up the stack ?
19:13:19 <skew> But I don't think they used any of the odd extensible record types
19:13:36 <pattern> skew, i have a post where xavier leroy discusses ocaml's oo implementation...
19:13:50 <skew> SyntaxLaptop: As far as the call stack goes, I remeber a paper saying they were implemented "normally", by marking the stack
19:14:01 <pattern> skew, http://tinyurl.com/2dp4k
19:14:10 <pattern> and you can also ask on #ocaml
19:15:29 <pattern> skew, "It is true that most OO languages make object fields mutable by default.  However, OCaml also supports immutable object fields, which you use in a functional style by copying them when you need to change a field."
19:15:44 <SyntaxLaptop> skew: what do you mean, marking the stack?
19:15:48 <pattern> don't know if that answers your question... that was from that post by xavier leroy
19:16:01 <skew> SyntaxLaptop: I don't know exactly how it works
19:16:11 <skew> SyntaxLaptop: I think exception handlers are recorded on the stack
19:16:36 <skew> when they are entered, that is. And when an exception is thrown something searches up the stack for the next handler
19:16:57 <skew> pattern: that's not what I'm talking about
19:17:06 <skew> pattern: I'm checking the language definition
19:17:44 <ski> chodapp : hi
19:17:58 <mattam> skew: when you need late binding you can always use classes :)
19:19:17 <skew> was there a polymorphic update operation?
19:19:51 <mattam> an update operation ?
19:21:00 <skew> like object <x = 3>
19:21:27 <skew> The manual says you can do that in a method, but nothing about elsewhere
19:21:31 <mattam> yes
19:22:38 <mattam> http://caml.inria.fr/ocaml/htmlman/manual005.html#ss%3Afunctional-objects
19:22:54 <ski> skew : that's copy-with-modifications, right ?
19:23:00 <skew> I think so
19:23:32 <skew> But I don't see that it's allowed outside of methods
19:23:52 <ski> of course not
19:23:52 <skew> I don't see something like row-variable polymorphism
19:24:01 <ski> which object to copy
19:24:05 <ski> skew : true
19:24:22 <ski> hmm
19:24:23 <SyntaxLaptop> the answer to my question is that "b" doesn't have to re-throw
19:24:35 <skew> ski: Well, something analgous to the Haskell notation, like I'd written "object <x = 3>"
19:25:08 <ski> well, thought i heard someone say that the object types hide an implicit row variable (or something similar)
19:25:13 <skew> pattern: Another thing is that you didn't really explain how type checking catches errors, other that type errors
19:26:22 <pattern> skew, are you talking about pattern matching?
19:26:23 <ski> skew : e.g.   Oo.copy : (< .. > as 'a) -> 'a     that type is different from   < .. > -> < .. >
19:27:24 <skew> Maybe something could work.
19:27:34 <ski> skew : huh ?
19:27:52 <skew> I was wondering if you could express an operation that would add a field to an object
19:28:12 <skew> ideally have cases for whether or not that field existed
19:28:26 <skew> I do have an O'Caml interpreter, so I'll just try some stuff
19:28:56 <ski> skew : not having the type system just allow one or the other, then ?
19:29:24 <skew> ski: Well, an update that replaces any existing field would work too
19:29:45 <ski> hmm
19:29:50 <ski> what kind of fields ?
19:29:54 <ski> methods ?
19:30:04 <ski> public inst. vars. ?
19:30:19 <skew> for now, making an instance var
19:30:33 <skew> I've forgotten most of O'Caml though
19:30:41 <pattern> skew, ask on #ocaml
19:30:46 <skew> I'm remembering how to make a lambda now.
19:31:02 <pattern> fun x -> x
19:31:04 <skew> Which is really quite a lot to have forgotten from a functional language!
19:31:06 <pattern> for an anonymous function
19:31:15 <pattern> let foo x = x
19:31:21 <pattern> for a function named foo
19:32:49 <ski> hmm (hypothetical)    obj : < x : 'b ; .. > as 'a , e : 'b |- <obj | x <- e> : 'a    perhaps .. ?
19:34:44 <skew> It seems reasonable
19:37:10 <ski> pattern : one must explicitely use a self type to make an object "extensible on all recursive layers", correct ?
19:37:31 <pattern> i know nothing about oop, ski, sorry
19:37:36 <ski> ok
19:37:52 <pattern> but if it's an ocaml question someone on #ocaml should know
19:38:10 <pattern> i can ask for you, if you like
19:38:17 <ski> well, guess i could try :)
19:38:21 <pattern> :)
19:40:46 <skew> Hmm. my question was more effective :)
19:41:22 <ski> skew : which one ?
19:41:24 <pattern> the senior channel regulars come and go
19:41:37 <skew> I asked about the polymorphic update before you joined
19:41:42 <ski> ok
19:41:44 <skew> and was told it was impossible
19:41:52 <pattern> also, i think most ocaml programmers don't use ocaml's oo features
19:42:00 <skew> that too
19:42:11 <pattern> there are some who do, but not most, afaik
19:42:18 <ski> skew : impossible in current O'Caml ?  (or in future ones also ?)
19:42:20 <skew> anyways, the point of all this rambling is that there is stuff in Python known to be useful that no current language types
19:42:26 <skew> ski: In the current at least
19:42:47 <skew> although it sounds like there are some issues with static layout of classes that make it hard
19:42:53 <pattern> skew, well, those differences may be philosophical ones
19:43:02 <ski> skew : like ?   attributes ?
19:43:17 <skew> ski: some flexible use of attributes
19:43:33 <skew> ski: like, an object pulling it's methods out of some data structure when it is created
19:43:44 <skew> ski: looking them up based on some arbitrary key
19:43:51 <ski> skew : why is that useful ?
19:44:06 <skew> ski: that's an example of untypeable, not necessarily of useful
19:44:31 <skew> ski: Although I've written similar stuff
19:44:54 <skew> ski: a dictionary thing with several different string comparison modes
19:45:13 <ski> skew : you do't think that would be implementation details of the oo model ??
19:45:31 <ski> hmm
19:45:54 <skew> ski: you tell it what sort of comparison you want it to use, and it copies the appropriate method under the canoncial name for the comparison method
19:46:02 <pattern> again, can't you just use functors for that?
19:46:15 <pattern> not on objects, obviously, but with modules?
19:46:40 <ski> skew : you can't pass a closure, or use a functor ?
19:46:52 <skew> ski: How would that work?
19:47:05 <ski> which ?
19:47:34 <skew> I suppose I could build a class in a function
19:47:49 <ski> do you want to use different comparisions on the *same* dictionary object ?
19:47:57 <skew> perhaps
19:48:05 <ski> themaximus : hello
19:48:09 <pattern> don't know about classes and oo, but you can pass around functions in ocaml, and you can pass around modules with functors
19:48:15 <themaximus> hey ski
19:48:25 <themaximus> good nite
19:48:36 <ski> themaximus : learning haskell ?
19:48:40 <pattern> ski, i don't see why that would be a problem
19:48:53 <ski> not me, either  :)
19:48:57 <pattern> :)
19:49:12 <pattern> again, maybe we should continue this on #ocaml, though
19:49:13 <ski> (except perhaps if one wants to use functors)
19:49:40 <themaximus> ski: yes, who told you?
19:49:44 <pattern> i am interested in the conversation, but i'm just a beginning ocaml programmer, after all, and won't be able to do the language justice
19:49:52 <themaximus> hm?
19:50:00 <themaximus> did lemmih?
19:50:00 <skew> pattern: I'm not particularly talking about O'Caml
19:50:06 <pattern> ok
19:50:17 <ski> themaximus : lord ctulhu, himself.               just kidding, i guessed :)
19:50:20 <skew> pattern: The original rambling was about the utility of type systems, I think
19:50:21 <themaximus> oh
19:50:24 <themaximus> :D
19:50:30 <themaximus> good nite all
19:50:30 <pattern> ahh
19:50:30 <ski> s/ctulhu/cthulhu/
19:51:37 <ski> themaximus : is that intended to be a greeting phrase, or a leave-taking phrase ?
19:51:39 <pattern> well, it seems to me that you can achieve what you want to do, perhaps not by adding object methods (i don't know, maybe you can), but perhaps just by passing around funcitons or modules
19:52:02 <skew> pattern: That's one thing that really bugs me about O'Caml
19:52:26 <skew> To derive a proper printing function or equality for some type
19:52:28 <pattern> that you can do anything in it? ;)
19:52:39 <skew> you need to apply loads of functors yourself.
19:52:52 <pattern> yes, that's true
19:53:20 <skew> How do you make an equality at ([Int],Float,[[Boolean]])
19:53:22 <pattern> but in a dynamically typed language what happens when you try to apply a printing method to something that doesn't work with it?
19:53:32 <pattern> you get a bug
19:53:36 <skew> That's where type classes come in.
19:53:39 <skew> See Haskell
19:53:43 <ski> :)
19:54:16 <skew> pattern: you mean, when you try to invoke the printing method on a object that doesn't have one?
19:54:32 <ski> 'cept one can only have at most a single instance of a class, for some type
19:54:42 <themaximus> skI: huh?
19:54:46 <skew> pattern: Concievably, something nifty goes out and builds the adapter for you
19:54:52 <SyntaxLaptop> are sanity checks supposed to prove that you're insane or that you're not insane.
19:54:55 <SyntaxLaptop> ?
19:55:02 <pattern> i don't really know about objects, skew.. but i mean when you try to "print" a floating point value as a string
19:55:13 * themaximus went shopping today and found a nice striped shirt he liked to wear with a white t-shirt underneath
19:55:19 <pattern> or vice versa
19:55:20 <ski> themaximus : ('tseemed that you were perhaps saying 'farewell' by "good night")
19:55:22 <skew> SyntaxLaptop: They're for when you suspect you're going crazy, but don't have hard evidence :)
19:55:35 <themaximus> oh, no, I mean goodnight
19:55:39 <SyntaxLaptop> I suspect I'm crazy ;)
19:55:50 <themaximus> I hope I am able to keep my computer on overnite :D
19:55:58 <themaximus> btw, I am 10
19:56:26 <skew> I wish I was learning Haskell then
19:56:27 <themaximus> so, for the millionth time, nite :D
19:56:31 <themaximus> eh?
19:56:32 * ski hopes he's crazy
19:56:48 <pattern> skew, in other words when you wind up confusing types by applying inappropriate functions to them in a dynamically typed language
19:56:49 <ski> themaximus : ok
19:56:49 * themaximus is away: ZzZ
19:56:49 <skew> I was learning C++ at 10, I think.
19:57:00 <skew> pattern: Oh, then it fails
19:57:09 <pattern> then you have a bug
19:57:33 <pattern> which is where statically typed languages help
19:57:41 <skew> pattern: With any luck you catch it when you run the thing, or run your tests, or run some super nifty static analysis tool
19:58:01 <skew> pattern: A statically typed langauges catches it at compile time, which is nicer
19:58:01 <pattern> which you get for free with a statically typed lang
19:58:05 <pattern> yeah
19:58:23 <pattern> and you don't need luck, w/st lang
19:58:51 <pattern> it is caught, unless you use obj.magic or the compare operator on functions, as jemfinch pointed uot
19:59:00 <skew> pattern: but you never explained how O'Caml builds the adapter automatically for you
19:59:08 <ski> skew : or, it'll only get invoked when the code's in production, and then at nonpredictable times :)
19:59:21 <skew> ski: Yeah, that's the downside
20:00:03 <pattern> skew, better ask on #ocaml... but it seems possible to me, by passing around functions or using functors to pass around modules
20:00:49 <pattern> sorry to keep referring you ther, but i'm just a beginner
20:01:01 <skew> pattern: You could pair all values with a printing function, and assemble a printer appropriate to your type each place you need to build a new one
20:01:11 <skew> pattern: but it would be a pain.
20:01:17 <skew> pattern: Haskell does it for you
20:01:25 <ski> it doesn't
20:01:40 <skew> ski: Deriving instances of Show?
20:02:15 <skew> ski: granted, you need to write instances, but you don't need to combine them yourself to get a show at (Int,Int) from Show Int and Show a, Show b => Show (a,b)
20:02:17 <ski> in  foo :: Show a => [a] -> Foo   every a in the list is *not* having it's own instance of Show
20:02:36 <ski> just one instance for all of them
20:03:07 <skew> yes (unless you use existentials or something)
20:03:08 <ski> so it doesn't "pair all values with a printing function"
20:03:21 <skew> But to get anything similar in O'Caml you'd need to do the dictionary passing yourself
20:03:23 <ski> skew : yes (was just gonna mention that :)
20:03:31 <skew> and applying the dictionary transformers yourself
20:03:36 <ski> yes
20:03:41 <pattern> well, i'm not famliar with this feature of haskell, so i can't really compare
20:03:51 <skew> and building those transformers from dictionary transformer transformers
20:03:53 <pattern> i'll take your word for it that it's easier in haskell
20:04:08 <skew> pattern: The point here is that Haskell has the feature because it is in the langauge
20:04:36 <skew> And it would be possible to add to a dynamically typed langauge like lisp or Python, but to do it in O'Caml you would need a source transformer at the very least
20:04:36 <pattern> and i mean to learn haskell at some point... i've heard good things about it... but monads scare me, and i need very high efficiency for my project, so i'll stick with ocaml for the interim
20:05:09 <ski> but haskell only allow max 1 instance, this could perhaps be a problem sometimes  (so people use newtype as a workaround, for this case)
20:05:12 <pattern> skew, well, there's also ocamlp4
20:05:21 <skew> pattern: That's different
20:05:34 <skew> pattern: Monads are easy
20:05:45 <pattern> not what i heard
20:05:46 <skew> pattern: Arrows in full generality are still confusing
20:06:22 <pattern> ocaml is my first functional language, i'm still struggling to understand it
20:06:29 * ski suprises pattern in a dark alley, pointing a CPS Monad Transformer at him
20:06:36 <skew> Monads are just a notion of sequencing
20:06:38 * pattern faints
20:07:05 <skew> you just say do this then that
20:07:14 <skew> polymorphic in what "then" means :)
20:07:22 <pattern> hmm
20:07:27 <pattern> doesn't sound so bad
20:07:41 <pattern> but then why do so many people find them so confusing?
20:07:48 <skew> thus, things like "pass along some state too", or "pass along the continuations"
20:07:53 <skew> Big scary categories!
20:08:05 <skew> endofunctors and natural transformations!
20:08:05 <ski> bwahahahaa !
20:08:07 <Pseudonym> skew: What about the list monad?
20:08:15 <skew> nondeterminism
20:08:20 <Pseudonym> That's not quite "just a notion of sequencing".
20:08:21 <pattern> well, lamda calculus is hard for me, so i can't even imagine category theory
20:08:37 <Pseudonym> In particular, list comprehensions aren't really "just sequencing".
20:08:38 <ski> Pseudonym : 'conceptual single-threadedness'
20:09:20 <ski> Pseudonym : (unless you mix things like mplus or other operators not in class Monad into the pic)
20:09:33 <Pseudonym> I get what you mean, though.  MOst monads are used to represent single-threaded execution.
20:09:56 <skew> Pseudonym: I never said "single-threaded"
20:09:56 <Riastradh> Monads are generalizations of computations.  They're not necessarily about sequencing.  A monad is a computation that has an output; one can extend the computation of a monad with extend (>>=), which often 'sequences.'
20:10:16 <skew> Pseudonym: just "sequencing", or maybe "computation" is better
20:11:01 <ski> Riastradh : the (>>=) structure is linear, yes ?
20:11:25 <Riastradh> ski, what do you mean?
20:11:34 <skew> pattern: if you are learning Haskell, "All about Monads" is a good introduction to the monads
20:11:42 <ski> Riastradh : f x >>= g >>= h >>= i >>= j
20:12:05 <Riastradh> ski, what about that?
20:12:22 <ski> Riastradh : it's a linear graph
20:12:26 * skew whispers "A functor equipped with a pair of natural transformations"
20:12:33 <pattern> thanks for the pointer skew, one day... one day... :)
20:12:39 * skew whispers "such that the following diagrams commute"
20:12:49 <skew> pattern: You will be happy learning Haskell
20:12:56 <pattern> i am looking forward to it
20:12:57 <skew> pattern: what are you writing anyway?
20:13:01 <Riastradh> ski, I'm not quite sure what you're saying here.
20:13:12 <ski> skew : what're you whispering about ?
20:13:16 <skew> Ristradh: You do the computations in order
20:13:21 <skew> ski: That's what a monad it...
20:13:24 <pattern> skew, i plan to implement a genetic programming system in ocaml
20:13:27 <skew> ski: That's what a monad is...
20:13:54 <Riastradh> skew, you extend the computations in order, but that does not make them sequential.
20:14:12 <Riastradh> Subthreads are spawned sequentially, but the whole system isn't sequential.
20:14:13 <ski> Riastrash : compare with  f x >>= (\y -> (g0 y >>= h0) `mplus` (g1 y >>= h1)) >>= i
20:14:37 <ski> (which is not sequential)
20:15:33 <skew> pattern: O'Caml provides sufficient performance?
20:15:45 <pattern> i hope so
20:15:53 <pattern> if not it's back to c
20:16:02 <skew> pattern: What performance do you need?
20:16:09 <pattern> very high
20:16:11 <skew> pattern: fast execution of the generated programs?
20:16:11 <ski> Riastradh : yes, i was referring to the "extend the computations in order" bit
20:16:23 <pattern> skew, yes
20:16:31 <Riastradh> ski, but extending the computations in order does not imply sequentiality; that's what my point was.
20:16:50 <skew> Riastradh: It depends what you mean by sequentiality.
20:17:13 <skew> Riastradh: You are certainly sequencing computations
20:17:24 <ski> Riastradh : (which, of course, must not necessarily have anything to do with evaluation order. it's more of like a logical/conceptual order/sequencing)
20:17:41 <skew> Riastradh: assume a sufficiently general notion of sequencing
20:18:01 <skew> pattern: You might be happier generating machine code then
20:18:15 <skew> pattern: if you really need lots of performance
20:18:21 <pattern> skew, i'm not ready for that
20:18:40 <pattern> skew, i prefer to program in a high level language
20:18:45 <Riastradh> pattern, have you ever tried Pre-Scheme?
20:18:58 <pattern> riastradh, nope, never.. what is it?
20:19:03 <skew> pattern: Or, maybe you could generate C and compile that, if you are running the generated programs for a long time
20:19:33 <pattern> skew, well, i'll see how good the performance in ocaml is, and i certainly could generate c if it comes down to it, but i'd prefer to stick w/ocaml if possible
20:20:11 <Pseudonym> Pretty much every language provides sufficient performance for some definition of "performance".
20:20:26 <Pseudonym> They tend to be written to optimise some locally-defined performance model.
20:20:31 <Riastradh> It's like Scheme -- and can be run as if it were Scheme with a minimal amount of support code --, but there are several things that set it apart, such as the HM type inference the compiler performs and the fact that it's nevertheless a low-level language with the same potential for performance as C (perhaps even greater with a good compiler).
20:20:38 <Pseudonym> Even if it's "programmer performance when working on task X".
20:20:48 <pattern> anyway, i'm far from running out of options w/ocaml in regards to this problem... i'm still learning the language, and i'll know much more once i finish implementing my project... then i'll see about real-world performance
20:21:07 <ski> Riastradh : e.g. in list monad,  do { b0 <- flipCoin; b1 <- flipCoin; b2 <- flipCoin; check (b0,b1,b2); return (b0,b1,b2) }
20:22:27 <pattern> riastradh, sounds cool... i also plan to finish learning scheme at some point... it would be very useful, quite apart from how appropriate it is for my specific project... but i've already invested a significant ammount of time to learning ocaml, so i'm not going to switch to learning another language at this point... i'll keep pre-scheme in mind, though, if ocaml proves insufficient
20:22:34 <ski> Riastradh : here i conceptually think of flipCoin as (nondeterministically) giving False or True (effectively splitting the world into multiple-worlds), *then* calling it again, and again, etc ...
20:23:03 <Riastradh> ski, but it's not necessarily that sequential model that you've stuck into your head.
20:23:54 <ski> Riastradh : sorry ?
20:24:11 <skew> Riastradh: It seems a useful one
20:24:19 <Pseudonym> Sure it does.
20:24:24 <Riastradh> ski, it's not necessarily '...*then* calling it again, and again' -- it's just 'for each element of the list, this computation is performed.'
20:24:45 <Pseudonym> Monads are often idiomatically used to simulate sequential computation.
20:24:54 <Pseudonym> That's one reason why they're so damn useful.
20:25:00 <Riastradh> Yes -- a monad _can_ be used for sequentiality, and often is.
20:25:02 <skew> Riastradh: it may be correct to say that other people have different models in their head, so it might be trouble talking to them
20:25:05 <Riastradh> But it isn't _necessarily_ sequential.
20:25:10 <Pseudonym> Right.
20:25:24 <skew> Riastradh: It depends what you mean by sequention. continuations and nondeterminism seem sequential enough to me
20:25:26 <ski> 'in each of the universes the previous universe was split into, continue with the following'
20:25:49 <skew> "sequention" Where did that come from?
20:26:10 <ski> Riastradh : still depends on what you mean by sequential, methinks
20:26:47 <Riastradh> Perhaps it came from the sequent calculus.
20:27:05 <ski> skew : (you know it ?)
20:27:15 <Pseudonym> Ah, here, I have a counter-example.
20:27:16 <skew> Riastradh: Certainly not, if you've adjusted your notions to match that monads capture :)
20:27:20 <Pseudonym> Prelude> :module + Control.Monad.Identity
20:27:22 <Pseudonym> Prelude Control.Monad.Identity> runIdentity (error "foo" >> return 1)
20:27:35 <Pseudonym> What do you know, it returns "1".
20:27:57 <ski> counter-example of what ?
20:28:19 <Pseudonym> That monads imply sequentiality.
20:28:26 <ski> not in my book
20:28:28 <ski> :)
20:28:29 <skew> Pseudonym: huh?
20:28:50 <Pseudonym> skew, what would you expect this to do?
20:28:56 <ski> (i.e. not in the sense i use (conceptual) 'sequentiality', here)
20:29:01 <Pseudonym> error "foo" >> return 1
20:29:09 <skew> Pseudonym: bah, silly unsafePerformIO games
20:29:14 <Pseudonym> OK, then.
20:29:20 <Pseudonym> fail "foo" >> return 1
20:29:22 <Pseudonym> :-)
20:29:30 <ski> skew : unsafePerformIO ?
20:29:31 <Pseudonym> "fail" is a Monad operation, so it's safe.
20:29:34 <Pseudonym> Or:
20:29:48 <skew> Pseudonym: I don't know what fail "foo" >> return 1 should do.
20:29:54 <ski> Pseudonym : fail is defaulted to error, right ?
20:29:58 <Pseudonym> Yes.
20:30:27 <pattern> ok, i'm off to get some food... see you guys
20:30:37 <skew> Pseudonym: error "foo" >> return 1 gives error for me, anyway
20:30:38 <ski> Pseudonym : so ?
20:30:46 <Pseudonym> skew: Hugs or GHCi?
20:30:56 <skew> GHCi. Not sure what it defaulted to for the monad
20:31:38 <ski> skew : make sure you try it for Identity Monad then
20:31:47 <Pseudonym> My point is that if you thought of monads as a sequential computation, you would have to get an error raised.
20:31:54 <ski> why ?
20:31:57 <Pseudonym> But there are 100% genuine monads for which that is not the case.
20:32:19 <skew> Pseudonym: The problem here is that error has wierd semantics
20:32:19 <ski> i don't agree with the premise
20:32:59 <ski> (or rather, my terminology is not quite the same as yours, probably)
20:33:01 <skew> You need a lazy >> for that behaviour, anyway
20:33:05 <Pseudonym> let bottom = bottom in runIdentity (bottom >> return 1)
20:33:10 <Pseudonym> No error there, now.
20:33:39 <skew> I would expext that to fall into bottom when sequencing the bottom and return 1, not when you execute the thing
20:33:47 <tmoertel_moz>  runIdentity (return 2 >> return 1)
20:33:50 <ski> i would not
20:34:19 <skew> rather, I would generally expect >> to be strict
20:34:32 <ski> why, again ?
20:36:56 <ski> i guess my 'conceptual sequentiality' has more to do with the way the program is structured, than the way (order) things will get evaluated ..
