00:00:01 <shapr> yay!
00:03:36 <Matt-W> oooh fosdem
00:17:12 <bring> good morning everyone
00:17:33 <bring> andersca: have fun
00:20:51 <Matt-W> ugh, work time
00:37:14 <bring> shapr: had time to test the authentication stuff?
00:37:20 <shapr> was trying it right now
00:37:35 <shapr> does this look right? (remote "http://shae:haskell@shapr.homelinux.net:9673/shae_stuff/TestDocument" "document_src")
00:37:40 <andersca> bring: too bad I'll miss lennart augustsson :/
00:38:22 <shapr> oh
00:38:22 <bring> shapr: yeah
00:38:25 <shapr> that does work.
00:38:44 <shapr> putting in the real password in place of "haskell" helps :-/
00:38:53 <bring> andersca: right, that's today
00:39:02 <shapr> what's Lennart doing?
00:39:32 <bring> shapr: that's not a good authentication system if it can't figure out that you meant to supply the right password
00:39:44 * shapr grins
00:39:55 <bring> he's giving a lecture in our Topics in Computer Languages class
00:39:59 <shapr> ooh
00:40:05 <shapr> he's a smart guy.
00:40:12 <shapr> I'd like to hear him talk.
00:40:38 <shapr> I actually got email from him once, about IOHCC.
00:40:45 <earthy> good morning #haskell
00:40:54 <shapr> speaking of which, it's probably time to organize Suck Zero IOHCC.
00:41:04 <bring> suck zero?
00:41:11 <shapr> Succ Zero :-)
00:42:05 <shapr> the last IOHCC was the 0th IOHCC
00:42:06 <bring> :)
00:42:15 <earthy> obfuscated haskell
00:42:28 <earthy> is that doing major CPS nastiness? :)
00:42:33 <shapr> Lennart mailed me saying that the 0th IOHCC was not in fact the first IOHCC (and that he noticed that I hadn't claimed that)
00:42:57 <bring> I love this quote from an old GHC manual: "Another extremely efficient way to make your program snappy is to use library code that has been Seriously Tuned By Someone Else. [...] (Incidentally, it doesn't hurt if the Someone Else is Lennart Augustsson.)"
00:43:05 <shapr> heh, yes!
00:43:56 * earthy grinz
00:44:04 <shapr> good morning earthy!
00:44:14 <shapr> the last IOHCC was FUN
00:44:19 <shapr> we got some really cool code.
00:44:35 <shapr> obvious Malcolm Wallace beat everyone else with his entry
00:44:48 <shapr> remorse was just 100% cool.
00:45:10 <shapr> Pseudonym's entry was also very cool.
00:45:32 * bring is off to the compilers lecture
00:45:40 <shapr> have fun! thanks for the auth code!
00:48:16 <earthy> were those 3 winners all entries?
00:48:38 <earthy> is it going to be semi-annually?
00:48:43 <shapr> heck if I know.
00:48:55 <shapr> it's probably going to happen whenever we get enough jurors together.
00:49:05 <shapr> who wants to be a juror?
00:49:05 <earthy> ghe :)
00:49:22 <earthy> not before the HC&A is published I won't. :)
00:49:29 <shapr> that makes sense.
00:49:39 <shapr> you have enough to do already.
00:50:00 <earthy> anyway, next omission in the HC&A found
00:50:04 <shapr> what?
00:50:23 <earthy> Yarrow
00:50:25 <earthy> and the IOHCC
00:50:29 <shapr> oh!
00:51:51 <earthy> that makes for 7 distinct projects/activities I already found that haven't been in the HC&A yet
00:52:09 <earthy> 4 of which could've been in already
00:52:38 <shapr> well, Claus put the responsibility on the project people to enter themselves.
00:58:58 <shapr> I met Claus at ICFP, he's nice.
00:59:03 <shapr> earthy: where were YOU!
01:01:17 <shapr> (not that I'll be at any other Haskell conference anytime soon)
01:02:32 <earthy> ICFP was late august, right?
01:02:38 <shapr> I think so
01:02:54 <earthy> I think I was in southern France with my girlfriend. :)
01:03:06 <shapr> oh, that's a good reason.
01:03:19 * earthy nods
01:03:47 <shapr> women > computers
01:04:08 <earthy> especially given that I had been to Marktoberdorf for the first 2 weeks of august...
01:05:17 <emu> computress
01:05:39 * emu points out that many young women were computers, before it became a job for machines
01:06:16 <shapr> computress > women > hardware
01:06:16 <shapr> :-P
01:06:27 * shapr luvs geekgrrls
01:06:34 <emu> mostly because they couldn't find husbands..
01:07:10 * earthy remarks that Edsger W. Dijkstra lamented the loss of these computers to science
01:07:48 <earthy> as it made finding a woman quite a bit harder for his students than it had been for him. :)
01:07:54 <shapr> haha
02:05:11 <ham[nwn]> hiho
02:10:32 <shapr> yow!
02:10:39 <ham[nwn]> :) hey
02:11:02 <ham[nwn]> ipkiss cool name ;)
02:12:52 <liiwi> squish
02:16:22 <shapr> yow!
02:16:28 <earthy> @yow
02:16:29 <lambdabot> I think I'll make SCRAMBLED EGGS!!  They're each in LITTLE SHELLS..
03:22:54 <Jad> any one knows why x^y (integers) are calculated so fast under hugs /
03:22:55 <Jad> ?
03:26:11 <Marvin--> compared to what?
04:23:19 <Lunar^> shapr: ?
04:44:31 <shapr> Lunar^: yes?
04:48:07 <themaximus> bbl (skiing and breakfast and.......)
04:48:13 <shapr> skiing?
04:48:41 <Jad> hello guys
04:50:20 <shapr> hey Jad 
04:50:46 <Jad> shapr, do you know why does hugs calculate a^b (integers) that fast ?
04:50:56 <shapr> faster than what?
04:51:07 <Jad> than a regular calc on a pc
04:51:08 <Marvin--> <Marvin--> compared to what?
04:51:31 <Marvin--> because a regular calc on a pc is poorly implemented wrt optimization?
04:52:14 <earthy> bc is plenty fast as well though
04:54:06 <Marvin--> yeah
04:54:49 <themaximus> bbl again
04:56:00 <earthy> cool. I broke bc. ;)
04:56:12 <earthy> out of stack space
04:56:12 <earthy> index is too large
04:56:12 <earthy> 37777777643 is unimplemented
04:59:17 <earthy> and that is for the bc variant of [ a ^ b | a <- take 1000 $ enumFrom 0, b <- take 1000 $ enumFrom 0]
05:14:10 <Lunar^> shapr: Is it possible to create a shared arch archive on scannedinavian.org ?
05:20:17 <Marvin--> arch is a tool of the devil! Use darcs!
05:20:22 * Marvin-- coughs
05:21:52 <Lunar^> Marvin--: I need to see what it really offers to implement these features on darcs ;)))
05:24:46 <Marvin--> suuuure
05:37:24 <shapr> Lunar^: yes, I think so.
05:37:36 <shapr> I'll install tla later today.
06:21:21 <Lunar^> shapr: There's no need for tla
06:21:38 <Lunar^> shapr: It just needs one user with sftp access, that's all
06:57:52 <Etaoin> hi
07:22:05 <Zavie[stage]> Yep !
07:23:43 <Zavie[stage]> shapr, may I have a word with you please?
07:24:07 <shapr> Zavie[stage]: er, what for?
07:24:15 <shapr> do I know you?
07:24:23 <Zavie[stage]> No you don't ^^
07:24:27 <Zavie[stage]> Get in #tty :)
07:24:31 <shapr> why?
07:24:35 <shapr> oh!!
07:26:00 * Igloo raises an eyebrow
07:26:02 <Marvin--> #tty?!
07:30:05 <ham[let]> bk
07:30:36 <ham[let]> anyone in here who can tell me something about cartesian closed categories?
07:30:42 <Zavie[stage]> Marvin, TTY is a cute cat ;-)
07:31:11 <ham[let]> tty?
07:31:11 <shapr> yes, TTY is VERY cute.
07:31:46 <ham[let]> lemme see it
07:32:47 <Zavie[stage]> http://www.flipcode.com/cgi-bin/msg.cgi?showThread=11-11-2003&forum=iotd&id=-1
07:32:49 <Zavie[stage]> :)
07:33:42 <ham[let]> i think its a fake
07:33:45 <Marvin--> naming a cat TTY is just as bad as those names they had in UserFriendly
07:34:15 <Marvin--> (Script Kitty and Cat-Five are the ones I can remember)
07:34:32 <Zavie[stage]> Not a fake. TTY is 1 year and a half old, and she lives in south of Paris.
07:35:05 <rubix> true. I've seen her a lot of times :)
07:35:25 <ham[let]> and is a computer hacker
07:35:30 <Zavie[stage]> When playing DDR ^^
07:35:30 <Maddas> Marvin--: haha
07:35:37 <Maddas> Script Kitty
07:35:46 <Igloo> Your cat codes in Java? Having you considered having it put down?  :-)
07:35:46 <rubix> thought she codes in java, I don't know if she code in haskell
07:36:07 <Zavie[stage]> TTY est une script kitty, enorme :-D
07:36:18 <Marvin--> though I don't know if naming a guinea pig "Mollari" for its hairdo is even worse :-P
07:54:41 <esap> ham: what do you need to know?
07:54:41 <ham[let]> esap CCC is just when you can do the cartesian product between all the objects right?
07:54:41 <esap> you also need exponentials.
07:54:41 <ham[let]> what is that?
07:54:42 <esap> in Haskell terms, lambda abstraction :-)
07:55:01 <ham[let]> heh ok and in math terms ? :)
07:55:42 <ham[let]> and why is it said to be so important for computer science
07:55:49 <cm> duh, duh, duh..
07:57:01 <esap> If you have arrow f : AxB -> C, then there is an arrow f* : A -> (B=>C) such that eval o (f* x id) = f, (eval : (A=>B x A) -> B)
07:57:14 <cm> why do I work here, sigh
07:57:29 <ham[let]> what is B=>C ?
07:57:56 <esap> it's an object that represents function space.
07:58:04 <ham[let]> ah dualspace
07:58:45 <ham[let]> but why is f* x id = f?
07:58:48 <esap> oh actually, I meant eval : (B=>C x B) -> C  [for consistency of notation]
07:58:58 <ham[let]> i mean then a would be 1
07:59:36 <esap> f* x id is not f. it's a commuting diagram with two arrows.
08:00:15 <ham[let]> its a dual pairing isnt it?
08:00:31 <ham[let]> ok for me that is nothing but higher order functions right?
08:00:36 <esap> I mean  you have arrows  AxB ---> (B=>C)xB ---> C  (first is 'f* x id 
08:00:44 <esap> I mean  you have arrows  AxB ---> (B=>C)xB ---> C  (first is 'f* x id' and second is 'eval')
08:00:52 <ham[let]> partial application that is
08:01:00 <esap> ham: yes.
08:01:09 <ham[let]> ok :) and why is it of interest?
08:01:23 <ham[let]> i mean i still want to build that stuff for my thesis
08:01:43 <ham[let]> and i think that all the "programs" you build within it are cartesian closed
08:01:57 <ham[let]> but i dont know if its of any interest to mention it
08:02:27 <ham[let]> esap have you had a look at my topic collection?
08:02:48 <Lunar^> I heard about that TTY cat also
08:02:48 <esap> ham: heh, I think it's interesting because CCC is a topos [which allows expressing all mathematics]. The reasons for that are somewhat involved and I'm not sure about all details :-)
08:03:04 <esap> ham: what topic collection?
08:03:11 <ham[let]> esap ok then i will read on topos :)
08:03:22 <shapr> Lunar^: a real script kitty
08:03:30 <ham[let]> esap http://codemages.sf.net/thesis.tex its a textfile you can read it in the browser
08:03:50 <ham[let]> havent added anything though i will do so from next week on
08:04:09 <ham[let]> there is also some topology, graphtheory and automation theory involved
08:04:24 * Lunar^ is digging through the RTS... 
08:08:40 * shapr gets a shovel for Lunar^ 
08:08:51 <Lunar^> thanks.. though that's pretty nice code
08:10:05 <shapr> which emulator do you use for hOp?
08:10:29 <Lunar^> Bochs on my iBook, qemu on intel
08:13:58 <bring> shapr: do you know of any useful xml-rpc services? I have written a haskell library for the damn protocol, but so far I haven't found a single useful public service to use it with. Half of the ones listed at xmlrpc.com are dead, and most of the rest aren't terribly useful
08:14:18 <Marvin--> heh
08:17:03 <bring> what do people actually use it for?
08:17:48 <Marvin--> uh... like any other rpc in a client/server setting?
08:18:21 <shapr> I don't know of any off the top of my head, but everything in Zope is automatically available via xml-rpc
08:18:27 <shapr> so it's really handy for me.
08:20:53 <bring> Marvin--: you're right, I guess the real problem is that I don't currently have an application that needs that
08:22:00 <bring> feels weird to maintain a library that I don't really know how to use :)
08:22:18 <Marvin--> but you've written echo servers and stuff to test it, right? :)
08:23:01 <shapr> I've tested it, it works great with Zope.
08:23:23 <shapr> converting syntax from Python xml-rpc tutorials feels a bit weird, but it works.
08:23:26 <bring> sure, but they are just for testing my existing code, they don't help me understand how to make the library better
08:24:16 <bring> maybe I'll add some stupid service like checking for the latest release of XmlRpc :)
08:24:44 <shapr> checking?
08:24:47 <shapr> oh!
08:24:48 <shapr> good idea
08:25:21 <liiwi> mmm, ideas
08:30:30 <cm> bring: where can we get your xmlrpc lib? :)
08:30:53 <bring> http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/
08:32:18 <cm> ta
08:32:29 <cm> I wonder whether that cvs branch succeeded..
08:32:57 <bring> cm: what cvs branch?
08:33:26 <cm> sorry was just thinking about what i'm doing at work currently ;)
08:33:31 <cm> that library looks nice, though
08:35:39 <cm> started to working on an xml rpc client, too, but i s'pose that isn't necessary anymore :)
08:35:41 <cm> -ing
08:36:04 <shapr> bring: on the good side, you've improved HTTP.hs in several ways.
08:38:58 * bring should stop whining, he's lucky to have a project that someone actually finds useful, that has never happend before
08:40:31 <bring> btw, didn't Graham Klyne post something about that there should be a standard haskell HTTP implemenation a while back
08:41:06 <bring> judging from his new URI library he seems pretty serious about implementing internet standards
08:41:40 <cm> okay cvs sucks (or I do, unsure)
08:43:20 <shapr> bring: let's get on the wagon with Graham :-)
08:43:27 <shapr> cm: cvs does suck.
08:43:52 <Riastradh> cm, use Darcs!  http://www.abridgegame.com/darcs/
08:43:56 <Riastradh> er, s/com/org/1
08:44:09 <cm> can't choose the versioning system at work, unfortunately..
08:44:15 <cm> but if I remove a file from a branch, cvs removes it from HEAD?
08:44:28 <cm> or was I (tortoisecvs) just doing something odd..
08:45:04 <Igloo> It'll remove it from whatever branch it thinks you're in presumably
08:45:06 <cm> hopefully the latter */me tries*
08:45:59 <Igloo> Oh, my brain read that wrong
08:47:22 * shapr watches GHC compile with -DSTANDALONE
08:47:24 <cm> it seems to be gone in HEAD, though..
08:47:37 <Igloo> shapr: Is that hOp?
08:48:22 <shapr> yes
08:49:29 <cm> hOp looks nifty :) who of you guys is reponsible for it?
08:49:54 <Lunar^> Add IRQ handler doesn't seem trivial though
08:49:55 <shapr> Lunar^ and sebc
08:50:00 <Lunar^> adding
08:50:29 * Igloo wonders where I noted the darcs info
08:50:33 <cm> :)
08:53:37 <shapr> I should have timed this.
08:57:52 <bring> shapr: maybe I should fire off an email to Graham
08:58:23 <shapr> I think so.
09:51:31 <bring> is there any way to make the executablesthat GHC produces smaller?
09:53:03 <bring> apart from the advice in the ghc manual
09:54:03 <Marvin--> not that I know of, why`
09:54:04 <Marvin--> ?
09:54:47 <Igloo> Are you running strip on the result?
09:54:55 <bring> well, the simplest little test program that I write for XmlRpc is >1MB, stripped
09:54:59 <bring> Igloo: yes
09:55:19 <Igloo> Are you on x86 with optimisation?
09:55:26 <Marvin--> bring: so?
09:55:38 <bring> x86, no optimization, I'll give -O a try
09:56:15 <bring> Marvin--: limited space on web servers, where you'd typically put XmlRpc server programs
09:56:43 <Marvin--> ah
09:57:15 <Marvin--> fair enough
09:57:41 <Marvin--> the RTS is kinda complicated, though
09:59:24 <DeezNuts> What does this mean: ERROR - Cannot infer instance?
10:03:51 <DeezNuts> YO
10:04:11 <DeezNuts> lots of ppl were wanting to help last night when i didn't have any probs :p
10:04:57 <bring> could you paste your code on the wiki irc paste page?
10:05:57 <DeezNuts> its just a line
10:06:00 <DeezNuts> i can paste it here
10:06:46 <bring> sure
10:06:49 <DeezNuts> and1 a b = if a == b then a else False
10:07:11 <DeezNuts> its straight out of a haskell tutorial
10:07:33 <DeezNuts> oh yeah and I also have and1 :: Bool -> Bool -> Bool
10:07:35 <DeezNuts> above that
10:07:40 <DeezNuts> so whats the biff?!
10:07:44 <[3N1GM4]> Hi all
10:07:54 <Igloo> What's the rest of the error?
10:08:21 <DeezNuts> *** Instance   : Num Bool
10:08:21 <DeezNuts> *** Expression : and1 1 1
10:09:00 <Igloo> and1 takes Bools - you are giving it numbers
10:09:37 <DeezNuts> ugh
10:09:39 * DeezNuts thinks of java
10:09:45 <DeezNuts> ugh
10:10:01 <DeezNuts> haskell sucks ;-)
10:10:07 <DeezNuts> if its that strict
10:10:08 <[3N1GM4]> I just need a quick bit of help on a fairly simple problem I am having. I am writing a function which takes a list of Strings as input and I simply want to display each string one after the other...The problem is, I have an IO module which has been written for us which takes a filename, and passes the lines of that file as the list of strings to the fuction I am writing...and it isn't working... =(
10:10:12 <Maddas> DeezNuts: Uhm.
10:10:23 <DeezNuts> Maddas: uhhh
10:10:24 <Maddas> DeezNuts: Why do you say it's Bool -> Bool -> Bool and then give it numbers?
10:10:37 <DeezNuts> Maddas: im just copying and pasting code from a tutorial
10:10:53 <DeezNuts> Maddas: actually it didn't show an invocation of and1 yet
10:11:29 <DeezNuts> Maddas: but I'm use to languages that allow you to use +-n as true and 0 as false
10:11:37 <DeezNuts> Maddas: I know, "far out" huh?
10:11:50 <Maddas> huh?
10:12:16 <[3N1GM4]> was that huh directed at me Maddas?
10:12:18 <Igloo> You could do that by defining an instance Num Bool, but we'd all be forced to glare at you in disgust
10:12:32 <amb> hi everybody
10:13:13 <DeezNuts> Igloo: nevermind you people dont help I'll read more tutorial
10:13:27 <[3N1GM4]> hi amb
10:13:29 <Igloo> DeezNuts: I'm not sure how we aren't helping?
10:13:53 <Igloo> True and False are the values of type Bool - if you have a function that takes Bools, that's what you need to give it
10:14:52 * amb thinks he passed an exam thanks to Haskell today, Yay! *g*
10:15:26 <[3N1GM4]> If anyone's free and would glance at my very small (probably syntax related) problem above, I would very much appreciate it...
10:16:11 <Igloo> 3N1GM4: What's the actual problem?
10:17:45 <[3N1GM4]> Igloo: right, this is only a very small part of a larger problem, but what I am trying to do is write a function which takes a list of Strings as input and outputs each string seperately. As I mentioned, this list of strings has been generated by a module not written by us, which takes a file and puts each line as a string into the list, before passing it to our module...
10:18:04 <[3N1GM4]> Please ask me if I am not being clear, I type faster than I think!
10:18:26 <bring> mapM_ putStrLn ?
10:18:40 <[3N1GM4]> is that a standard prelude function?
10:18:49 <[3N1GM4]> I know putStrLn...
10:18:57 <bring> @type mapM_
10:18:57 <lambdabot> mapM_ :: Monad a => (b -> a c) -> [b] -> a ()
10:19:16 <[3N1GM4]> but the thing is, the IO module written for us, contains a line with putStrLn...
10:19:21 <[3N1GM4]> ok, Monad?
10:19:59 <bring> you can pretend that the a is IO for now
10:20:11 <bring> IO is an instance of Monad
10:20:14 <[3N1GM4]> err, ok...
10:20:31 <bring> anyway, that might not be what you want
10:20:43 <[3N1GM4]> so: (b -> a c) -> [b] -> a ()? Confused!
10:20:56 <[3N1GM4]> you wanna see the module supplied to me for IO?
10:21:03 <[3N1GM4]> I can DCC it
10:21:17 <bring> pretend that that says: (b -> IO c) -> [b] -> IO ()
10:21:28 <Marvin--> [3N1GM4]: can't you put it on a website?
10:21:43 <[3N1GM4]> could do... there a pastebin for this channel somewhere?
10:21:48 <Marvin--> or on http://www.haskell.org/hawiki/HaskellIrcPastePage
10:23:06 <[3N1GM4]> ok, it is there.
10:23:24 <Marvin--> aiih, put {{{  }}} markers around it :)
10:23:35 <[3N1GM4]> around?
10:23:45 <[3N1GM4]> I cannot change the main module shown there...
10:23:55 <Marvin--> didn't you look at what the page looked like before you pasted?
10:24:12 <[3N1GM4]> yeh, the preview did not show that problem, one sec.
10:24:56 <bring> tested with -O, doesn't really change the size of the stripped executable
10:25:51 <bring> makes the library file 25% bigger though
10:25:57 <[3N1GM4]> sorry, phone, brb.
10:26:10 <bring> guess I need mod_haskell :)
10:26:10 <Marvin--> [3N1GM4]: let me do it, just a sec
10:26:18 <Igloo> If you have a large library of your own you might want to look into object splitting for it
10:26:55 <Igloo> (assuming a significant proportion isn't used by the programs you're talking about)
10:28:05 <bring> hmm, that's a good idea
10:28:49 <bring> for example, the client never parses a method call, and these server never parses a response
10:28:58 <bring> I'll look into that
10:30:06 <[3N1GM4]> ok, it's on there: http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
10:31:44 <Marvin--> [3N1GM4]: based on the code, it looks to me that you should only write a module Shapes with a function shapes :: [String] -> String
10:32:08 <[3N1GM4]> that is what we are supplied with, and we are writing the module shapes which recieves a list of Strings from Main and should (later) return a single string. But right now, I just want to print each line...
10:32:13 <[3N1GM4]> oh, sorry, didnt see you had typed.
10:32:49 <[3N1GM4]> yes, but what code does that function shapes need in it? Nothing?
10:32:56 <[3N1GM4]> I am not asking for the code, just some hints...
10:33:02 <Marvin--> depends on what the assignment is? :)
10:33:27 <[3N1GM4]> say I just want to print out each string from the list on a seperate line, one after the other...
10:34:10 <[3N1GM4]> just to get started
10:34:23 <Marvin--> well, since the processFile function takes care of the printing for you, all you'd need to do is to concatenate the string list with newline markers in between
10:35:06 <[3N1GM4]> right, so take each string from the list and paste em all together, with the newline character at the end of each string (line)...
10:35:25 <Marvin--> right
10:35:30 <[3N1GM4]> is there a standard functon for concatenation?
10:36:00 <[3N1GM4]> and I assume I would need a recursive loop of some kind?
10:36:19 <Marvin--> s1 ++ s2  is the concatenation of the lists s1 and s2 (and strings are lists)
10:36:42 <[3N1GM4]> right, I get that. So I would have s1 ++ "/n" ++ s2 ++ etc...
10:36:49 <[3N1GM4]> but how do I isolate the strings from the list?
10:36:58 <Marvin--> pattern matching is the standard way
10:37:06 <[3N1GM4]> right, I see.
10:37:31 <Marvin--> basically, you'd write two definition lines for your shapes function, one for the base case (empty list: []) and one for the induction step (non-empty list: (s:xs))
10:37:52 <[3N1GM4]> ok, so like shapes [] = ""
10:37:53 <[3N1GM4]> and
10:38:15 <[3N1GM4]> shapes(s:xs) = something?
10:38:34 <Marvin--> sounds like a plan
10:38:58 <[3N1GM4]> ok, and at the end of the induction step line, I would have : shapes xs ?
10:39:37 <[3N1GM4]> no wait, thats wrong
10:40:13 <[3N1GM4]> shapes(s:xs) = s ++ "/n" + shapes(xs)  ??
10:40:21 <Marvin--> "\n"
10:40:30 <[3N1GM4]> ok, but apart from that, yes?
10:40:54 <Marvin--> you don't need the parentheses around xs, but yeah, looks good
10:41:26 <Marvin--> well, the "+" should be a "++" too
10:41:48 <[3N1GM4]> oh yeah, my classic silly mistakes! I will try it now. Much thanks for the help, btw. I am struggling with this language more than I have with others...
10:42:56 <Marvin--> I think you're doing just fine :)
10:43:13 <[3N1GM4]> it's hard starting out!
10:43:46 <Marvin--> it's worth it
10:44:06 <[3N1GM4]> ok, now it compiles, which is always a good start... but it isn't liking the test file I am trying to supply it with...
10:44:24 <[3N1GM4]> I have made a file test.txt in the same folder, which has three lines of text in it...
10:45:10 <[3N1GM4]> but once I have typed at the command line: ghci Main.hs and it's all compiled nicely and I've got *Main>, I am not sure of the syntax for getting it to accept a file...
10:45:28 <Marvin--> ghci is just the interpreter
10:45:35 <Marvin--> I thought you said you compiled it?
10:45:45 <Heffalump> ghci can run compiled code
10:45:53 <Marvin--> then there should be an a.out (or a.exe depending on your OS) that you can run
10:46:01 <Marvin--> Heffalump: well, yeah
10:46:25 <[3N1GM4]> no, I do not have either of those object code files? Shall I compile with ghc?
10:46:26 <Marvin--> Heffalump: getting the arguments into the main function is harder
10:46:47 <Marvin--> [3N1GM4]: ghc --make Main is probably simplest
10:46:51 <[3N1GM4]> ok
10:47:05 <[3N1GM4]> ok, done
10:47:30 <[3N1GM4]> I now have .o and .hi files for both main and shapes and also an a.out file
10:47:39 <Marvin--> goody
10:47:42 <[3N1GM4]> lol
10:48:06 <[3N1GM4]> so now i run a.out or something, with the test.txt filename as an argument?
10:48:18 <Marvin--> yep
10:48:22 <[3N1GM4]> ok, so:
10:48:27 <[3N1GM4]> a.out test.txt?
10:48:42 <[3N1GM4]> a.out "test.txt"?
10:48:52 <Heffalump> 'lo kosmikus
10:48:58 <Marvin--> on a unix system, they should be equivalent, but you may need to write ./a.out
10:49:01 <[3N1GM4]> ah, second one
10:49:12 <[3N1GM4]> oh no, either, my bad.
10:49:17 <[3N1GM4]> but yey, it works!
10:49:30 <[3N1GM4]> is there any way to do that interactively with ghci?
10:49:40 <[3N1GM4]> like a quicker way?
10:50:00 <Marvin--> yes and no, you can't use the main function directly
10:50:11 <Marvin--> but you could use the processFile function directly
10:50:29 <Marvin--> processFile ["test.txt"]
10:50:30 <[3N1GM4]> ok... I guess I'll stick with compiling it like this then...
10:51:35 <[3N1GM4]> ah, I see.
10:51:59 <bring> Igloo: using -split-objs to build the library made the executable 10 % smaller, but the library file is now twice as big
10:52:14 <[3N1GM4]> well, thanks again for the help, really appreciate it.
10:53:48 <Marvin--> [3N1GM4]: now that you've spent the time writing a recursive function for this, let me introduce you to the function "unlines" ;)
10:54:14 <kosmikus> hi Heffalump 
10:54:27 <[3N1GM4]> lol, ok
10:54:34 <bring> shapr: got a reply from Graham Klyne, turns out he's been using the HTTP.hs version from XmlRpc :)
10:54:37 <[3N1GM4]> I love it when this happens!
10:56:03 <[3N1GM4]> I just looked it up, oh how I laughed...
10:56:48 <Marvin--> looked familiar? :)
10:57:16 <[3N1GM4]> Marvin--: lol, for sure. Well cheers again for the help, really useful. Much more friendly than some of the guys on C/C++ channels!
10:57:18 <kosmikus> is there any keyboard layout that has a , at the position where there normally is the 'm' ?
10:58:08 <Marvin--> kosmikus: er? You mean having the whole bottom line sort of shifted one step to the left?
10:58:29 <kosmikus> no
10:58:33 <kosmikus> really strange
10:58:40 <Marvin--> so where'd m go?
10:58:42 <kosmikus> the 'y' produces a 'w', for instance
10:58:50 <kosmikus> I haven't found the 'm' yet ...
10:59:11 <kosmikus> ah, on the ';' position
10:59:11 <bring> what happend to that machine?
10:59:11 <Marvin--> maybe it's azerty or something equally arcane?
10:59:36 <kosmikus> what's azerty?
10:59:47 <Maddas> a keyboard layout
10:59:48 <Marvin--> French keyboard layout
10:59:53 <Marvin--> iirc
10:59:59 <Maddas> yeah
11:00:08 <Igloo> azerty is almost the same as qwerty, just a couple of letters switched around
11:00:09 <kosmikus> this happened after switching a debian machine to the console via alt-ctrl-f1
11:00:26 <Marvin--> if in doubt, press the top left keys and see what happens
11:00:44 * esap has had trouble switching between terminals and X. Sometimes the machine freezes when I switch back to X.
11:00:54 <esap> s/terminal/console/
11:01:50 * Marvin-- sighs, no D&D session today either
11:02:07 * esap uses nethack for that :-)
11:04:28 <Marvin--> maybe it's just as well, I have heard that we're going up a level next session and I have no idea what to do with it
11:08:22 <CrewdenX> Marvin--: actual tabletop or nwn?
11:08:32 <Marvin--> *actual tabletop*
11:08:35 <Marvin--> sheesh
11:08:47 <CrewdenX> heh, well.  it's a dying breed.
11:09:23 <Marvin--> eh, D&D isn't a favourite of mine, I prefer non-level-based low-magic games
11:09:40 <CrewdenX> i like shadowrun.
11:10:17 <Riastradh> D&D is silly.
11:10:24 <Marvin--> but since we've played it a while now, I went down to the gaming store to buy a PHB, but they were sold out *grmbl*
11:12:31 <CrewdenX> Riastradh: imo, that's what used to make it fun.
11:12:47 <CrewdenX> Riastradh: been a long time since i played though.
11:13:04 <[3N1GM4]> ok, another real quickie. I've got a string, but I want it to be a number (double, actually), i.e. "23" -> 23. I've been told something about using the read function to convert numerical items into numbers. But nowt I can find on the net aboot it...
11:13:21 <Heffalump> just call read on your string
11:13:25 <[3N1GM4]> oh, ok
11:13:29 <Heffalump> and use it as a Double
11:13:35 <Heffalump> type inference will do the necessary magic
11:13:41 <[3N1GM4]> so read "23" == 23?
11:13:48 <Marvin--> yes and no :)
11:13:49 <Heffalump> yeah
11:14:00 <Marvin--> the short answer is yes
11:14:01 <[3N1GM4]> lol, but essentially?
11:14:03 <[3N1GM4]> good.
11:14:03 <Heffalump> (though you'd have to give an explicit type to actually get the answer "True" out)
11:14:27 <[3N1GM4]> how do you mean? Cos I am gonna use the result as a double later...
11:14:36 <Heffalump> only thing you may need to be wary of is that if you use functions on the result that also could apply to Float etc, then at some point you'll need an explicit type signature
11:14:39 <Heffalump> that should be fine then
11:15:09 <[3N1GM4]> cool.
11:15:19 <Jad> hello guys
11:42:45 <Marvin--> gotta love OPN
11:42:45 <Marvin--> or whatever it's called this week
11:47:22 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/", "ghc 6.2 is out", "ghc rpms: http://haskell.org/~petersen/rpms/ghc/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html"]'
11:47:22 --- topic: set by shapr on [Sat Jan 24 08:38:50 2004]
11:48:51 * SamB wonders why irc.openprojects.net no longer points here
11:51:08 <Etaoin> I thought they changed their name
11:52:43 <SamB> Etaoin: they did. to freenode.
11:53:13 <Etaoin> that's what I though
11:53:14 <Etaoin> t
12:04:36 <Lunar^> btw, I started a dev log for hOp. We'll see if I keep it
12:04:39 <Lunar^> http://etudiants.insia.org/~jbobbio/hOp/
12:24:19 <basti_> hi
12:24:28 <stepcut> Lunar^: sweet!
12:47:00 <shapr> bring: you busy?
12:47:22 * shapr suspects normal people are out enjoying themselves on friday evenings.
12:47:59 * basti_ suspects that he isn't normal
12:48:03 * stepcut is actually going to look at the haskellDB/GHC stuff this weekend
12:48:19 * stepcut notes that it's only 1pm and he is still at work :p
12:49:21 * ibid notes that it's only 11pm and he's still not tired
12:50:58 <Maddas> it's not! it's 21:50! Are you calling my timezone wrong? Heretics!
12:53:11 <ibid> Maddas: no, i'm just saying your clocks are running late :)
12:53:15 <shapr> Lunar^: how do I invoke qemu with hOp?
12:53:46 * stepcut seriously considers becoming the haskell-mode maintainer
12:54:17 <Maddas> ibid: Swiss clocks running late? Impossible :-)
12:54:20 * shapr stares at the grub prompt
12:54:42 * earthy was enjoying teaching python and elan to kids
12:55:28 * earthy 's swiss clock runs late.
12:55:47 <Riastradh> It's nearly 16.00, you wrong people!
12:55:57 <earthy> it is 21:55 MET+DST
12:56:06 <ibid> 2256
12:56:09 <shapr> yay! it booooots!
12:56:31 <shapr> Lunar^: what do I do now? :-)
12:58:37 <Maddas> earthy: Obviously all your other clocks must be going early :-)
12:59:01 <earthy> maddas: ntp clocks at stratum to do not go early. :)
12:59:05 <earthy> stratum 2 that is
12:59:21 <earthy> (which is what I reference my swiss watch against)
12:59:26 <Maddas> I shall inform my government of your heresy!
12:59:37 * earthy grins
12:59:56 <earthy> it also runs slow when compared with the clock at http://www.leapsecond.com
13:00:11 * earthy thinks that clock is synced off of a hydrogen maser. ;)
13:06:50 <shapr> it feels weird to see asm, C, and Haskell living together so happily.
13:07:11 <stepcut> hehe
13:07:31 <Riastradh> If there's assembly and C involved, likely the programmer isn't in that happy group.
13:08:31 <shapr> I'm looking at hOp, trying to figure out what's going on
13:09:23 <earthy> lunar^ didn't seem too unhappy to me
13:10:12 <earthy> anyway, time for beer
13:11:30 <stepcut> shapr: did you build the source release or just boot the boot floppy?
13:12:20 <shapr> both
13:12:38 <shapr> I wanted to build the source release in hopes that I can do something useful for/with the project.
13:16:50 <stepcut> shapr: is it easy to build? 
13:16:57 <shapr> yes, very.
13:17:00 <Marvin--> I'm scared
13:17:08 <Marvin--> I got two pyopenssl related mails within half an hour
13:17:10 <stepcut> maybe I try it out 
13:17:27 <shapr> stepcut: there's one shell script called build-ghc, I executed it.
13:17:41 <shapr> or maybe I ran make first?
13:17:42 * shapr forgets
13:17:48 <shapr> Marvin--: speaking of which...
13:17:56 <shapr> Marvin--: HOpenSSL?
13:18:00 * shapr grins evilly
13:18:12 * shapr is just being mean to Marvin-- ;-)
13:18:13 <Marvin--> don't you dare
13:18:17 * shapr laughs
13:20:25 <Marvin--> I guess I should release a new version some time
13:23:45 <cybermanco> where can I learn all that ana cata hylo shit?
13:23:48 <shapr> bring: as for GHC binary size - http://www.haskell.org//pipermail/glasgow-haskell-users/2003-November/005994.html
13:24:00 <shapr> cybermanco: the bananas,lenses, and barbed wire paper is good.
13:24:37 <basti_> now as newly joined i can't make sense of that last line. I think the question must have been even more bizarre.
13:26:09 <shapr> http://wwwhome.cs.utwente.nl/~fokkinga/index.html#mmf91m
13:26:18 <shapr> I think that's the one.
13:26:49 <Marvin--> basti_: what, you don't see the connection between bananas, lenses and barbed wire and anamorphisms, catamorphisms and hylomorphisms? :)
13:27:21 <basti_> hmmm
13:27:34 <basti_> oh
13:27:38 <basti_> i think i heard of it
13:27:52 <basti_> i just didn't parse shapr's line well
13:28:41 <Riastradh> If unfold is an anamorphism, fold is a catamorphism, what morphism is map?
13:29:24 <Heffalump> it's both
13:29:27 <Riastradh> ...er, insert the word 'and' strategically there.
13:29:36 <Riastradh> It's a catanamorphism?
13:29:44 <Igloo> Isn't it a homomorphism?
13:29:47 <Heffalump> I'm not sure that means anything
13:29:50 <Heffalump> oh, yes, that too
13:30:09 * basti_ think he heard of pyroclastic streams one time
13:30:14 <Riastradh> Hmmm...'cata-ana'...'catana'...'katana'...
13:30:15 <Heffalump> that's stronger than the combination of a catamorphism and anamorphism
13:30:36 <Marvin--> Riastradh: yes! swordplayisms
13:31:03 <Marvin--> my brother has a katana, wonder if it looks anything like a map
13:31:36 <Riastradh> What does a reified map look like?
13:31:46 <Marvin--> hm
13:32:07 <Marvin--> I have absolutely no idea
13:32:24 <Riastradh> While we're at it, what do reified folds and unfolds look like?
13:32:49 <basti_> x.x
13:34:03 <basti_> oh thats not so hard... -reading mentioned paper-
13:37:43 <cybermanco> hylo = cata + ana
13:37:46 <cybermanco> I think
13:38:16 <cybermanco> I must know this tomorrow
13:38:19 <basti_> hmm
13:38:29 <basti_> what would that be in a program?
13:38:47 * basti_ asks openly for he can't decide.
13:39:26 <[3N1GM4]> Hi, just looking for a little help with this: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview I'm getting a compilation error saying that I cant have a varying number of arguments to centre, but there is only one argument, a shape. It's probs just a syntax thing, anyone?
13:40:42 <Heffalump> you have several arguments after the shape
13:40:47 <Heffalump> centre Circle (x,y) rad = (x,y)
13:40:58 <Heffalump> (for example)
13:41:02 <Heffalump> (and the number varies)
13:41:17 <[3N1GM4]> yeah ok, so why cant I do this?
13:41:32 <ibid> [3N1GM4]: you need parentheses around the argument
13:41:37 <Heffalump> because it doesn't make sense
13:41:39 <[3N1GM4]> [these ones?]
13:41:48 <ibid> those are brackets :)
13:41:49 <[3N1GM4]> (or these ones?)
13:41:54 <[3N1GM4]> (these?)
13:41:56 <ibid> those are parentheses :)
13:42:01 <[3N1GM4]> lol, ok
13:42:28 <[3N1GM4]> so I want: centre (Circle (x,y) rad) = (x,y)  ??
13:42:43 <ibid> [3N1GM4]: as a rule of thumb, always add parentheses around a complex pattern
13:42:44 <Riastradh> Square brackets are [].  Parentheses are ().  Curly braces are {}.  Angle brackets are <>.
13:42:46 <ibid> yes
13:42:56 <[3N1GM4]> ok, thanks a lot again guys.
13:43:22 <basti_> oh i understand
13:43:36 <basti_> i think induction functions are hylomorphisms?
13:44:08 <basti_> i mean functions like "gobble_tree :: Tree a -> (Tree a -> b -> b) -> b" 
13:44:13 <basti_> or something
13:44:36 <basti_> i call them induction functions because I'm pvs spoiled.
13:45:46 <ibid> where does gobble_tree get a value for the second argument of its second agument?
13:46:07 <basti_> hm yes that wasnt Correct.
13:46:54 <basti_> it would in every step get as much b's as this node has children
13:47:06 <basti_> and none at the leafs, so would need more than one function
13:47:21 <basti_> something like
13:48:30 <basti_> "gobble_tree :: Tree a -> (Leaf a -> b) -> (Subtrees (Tree a) (Tree a) -> b)-> b" 
13:48:54 <basti_> btw whats the common name for these all? Morphisms?
13:49:24 <ibid> functions? :)
13:49:49 <basti_> gnn ;)
13:50:02 <ibid> sorry :
13:50:04 <ibid> )
13:50:06 <basti_> hehe ;)
13:57:18 <basti_> hm
14:04:17 <basti_> can you express the type of a such a morphism thing in Haskell generally? I mean the type of morphims generally...
14:05:46 <Maddas> Has any of you guys looked at Needle? If yes, what do you think of it?
14:09:41 <basti_> just via google right now ;)
14:12:42 <Maddas> :-)
14:19:25 <basti_> im compiling it.
14:19:26 <basti_> ;)
14:20:17 <stepcut> i wonder how needle compares to o'caml. It seems that the Object system is more pervasive in needle...
14:24:11 <basti_> sounds cool.
14:37:20 <[3N1GM4]> Hi again! Ok, here's me so far: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview I am now writing the function Centroid, which has to find the average centre of a list of shapes, weighted by their areas... I have the function to find the area and I know that I can use map to apply area to the whole list of shapes, but how do I go about using the area list with the shape list simultaneously to produce the centroid?
14:37:35 <[3N1GM4]> Just some tips would be good, I know it's gonna be loops, but I just cant picture it...
14:38:32 <[3N1GM4]> well recursion, not loops technically.
14:38:35 <[3N1GM4]> i guess.
14:40:03 <basti_> uhm.
14:40:28 <basti_> yes probably.
14:40:30 <[3N1GM4]> it's on the tip of my tongue/fingers, but I cant quite get there...
14:40:50 <basti_> you should decide if you have one Shape and some more, or if you dont have any Shapes left.
14:40:54 <basti_> ;)
14:41:18 <[3N1GM4]> ok, so a case for an empty list like centroid[] = something
14:41:53 <basti_> hmm well
14:41:59 <basti_> lets say that's an error
14:42:19 <basti_> maybe you can see if you have only one Element left?
14:42:25 <[3N1GM4]> well, I mean if I'm gonna be looping, is that not neccessary to halt the recursion and let it all drop out?
14:42:31 <[3N1GM4]> wait, ok...
14:43:19 <[3N1GM4]> so centroid [x] = if x.length = 1 then...something?
14:43:30 <basti_> length?
14:43:38 <[3N1GM4]> cant do that in haskell?
14:43:39 <basti_> -.- ??
14:43:48 <[3N1GM4]> thought lists had a length field?
14:43:54 <basti_> not that way...
14:44:05 <basti_> hmm
14:44:09 <[3N1GM4]> oh sorry, learning too many languages at once...
14:44:12 <[3N1GM4]> =)
14:44:16 <basti_> ill give you a little hint
14:44:18 <[3N1GM4]> ok
14:44:21 <basti_> Pattern Matching?
14:44:32 <[3N1GM4]> ok...
14:44:35 <basti_> how do you "match" lists?
14:44:58 <[3N1GM4]> errr... I honestly dont know, give me a sec...
14:45:10 <basti_> ok
14:46:41 <[3N1GM4]> so something like:
14:47:25 <[3N1GM4]> centroid [x] = something    OR     centroid (x[]) =  something
14:47:32 <[3N1GM4]> that's a list with one element, right?
14:47:56 <[3N1GM4]> and that element is matched/binded to x
14:48:38 <[3N1GM4]> yeh?
14:48:45 <basti|-> that looked good actually
14:48:52 <basti|-> just never seen the second form
14:49:05 <[3N1GM4]> centroid [x] = something    OR     centroid (x[]) =  something ?
14:49:11 <[3N1GM4]> you mean that?
14:49:13 <basti|-> yes i still got that
14:49:13 <basti|-> ye
14:49:40 <[3N1GM4]> ok, kewl, I just zipped pattern matching on lists into google.
14:50:03 <basti|-> google is your friend ;)
14:50:13 <[3N1GM4]> lol, true. right, so I can isolate the case of a list of shapes with one shape in it...
14:50:30 <basti|-> yes you can
14:50:41 <[3N1GM4]> so in that case the centroid is the centre of that shape?
14:50:43 <[3N1GM4]> so:
14:50:55 <[3N1GM4]> centroid[x] = centre x
14:51:05 <basti|-> yes that would be valid.
14:51:10 <[3N1GM4]> ok, progress.
14:52:15 <[3N1GM4]> so now I am guessing I want to use recursion to isolate each shape in the list one at a time? And then average their centres based on their areas to find the centroid?
14:52:21 <[3N1GM4]> somehow.
14:52:52 <basti|-> yep
14:52:54 <[3N1GM4]> ok...
14:53:00 <basti|-> you would probably want to split this into 2 functions
14:53:05 <[3N1GM4]> right...
14:53:22 <basti|-> you can do this either local (with "where" or "let") or global
14:53:36 <[3N1GM4]> k...
14:53:49 <[3N1GM4]> global would require 2 functions, right?
14:54:21 <basti|-> yes.
14:54:27 <basti|-> or, so i suggest
14:54:39 <basti|-> you could do without.
14:54:46 <[3N1GM4]> okey doke.
14:54:57 <[3N1GM4]> just gotta read up on 'where' wuickly...
14:55:01 <[3N1GM4]> *quickly
14:56:12 <basti|-> its like let just behind the function
14:57:19 <[3N1GM4]> yeh, readin up on let too...
15:00:49 <[3N1GM4]> ok, I understand those two. And what I want to find is the sum of each shapes' co-ordinates multiplied by it's area, all divided by the number of shapes..
15:01:05 <basti|-> yeah.
15:01:08 <[3N1GM4]> ok.
15:01:11 <basti|-> :)
15:01:27 <[3N1GM4]> lol, this is always hard!
15:01:32 <basti|-> no ;)
15:03:04 <[3N1GM4]> ok, I got:    centroid(x:xs) =    =)
15:03:19 <[3N1GM4]> I know what I wanna do, but I cant see where I'm going!
15:03:54 <[3N1GM4]> would centre x * area x be a valid expression?
15:04:03 <[3N1GM4]> (centre x)*(area x)
15:04:27 <basti|-> sure
15:04:29 <basti|-> oh
15:04:31 <basti|-> no
15:04:32 <[3N1GM4]> would that multiply both coords by the area?
15:04:35 <basti|-> centre would be a point
15:04:35 <[3N1GM4]> ah
15:04:37 <[3N1GM4]> yes
15:05:06 <basti|-> since a point is a tuple you have to manually break it up
15:05:17 <[3N1GM4]> ok, some pattern matching again?
15:05:40 <basti|-> not really
15:05:44 <[3N1GM4]> lol, ok.
15:05:48 <basti|-> ;)
15:06:07 <basti|-> you could either write a function explicit or use a lambda for example
15:06:21 <basti|-> i dont know, maybe there's already a function that splits a tuple in the library
15:06:47 <[3N1GM4]> oh, I know it for pairs! it's fst and something else for the second one...
15:06:52 <[3N1GM4]> right?
15:07:43 <[3N1GM4]> and snd returns the second one.
15:07:45 <[3N1GM4]> ok.
15:08:28 <[3N1GM4]> so: fst(centre x)*(area x) gives the weighted x coord
15:08:38 <[3N1GM4]> and: snd(centre x)*(area x) gives the weighted y coord
15:08:44 <basti|-> oh yes
15:08:47 <[3N1GM4]> cool.
15:08:50 <basti|-> yea thats them
15:08:58 <[3N1GM4]> lol, makin my brain work.
15:09:48 <[3N1GM4]> still not sure how I'm gonna add up all the weighted values for x and y then divide them by the number of shapes.
15:10:40 <[3N1GM4]> and put them back in a tuple
15:10:41 <basti|-> two functions!
15:10:44 <[3N1GM4]> ok, ok!
15:10:46 <[3N1GM4]> =)
15:10:48 <basti|-> ;)
15:10:56 <basti|-> one weights, one adds and divides
15:11:36 <[3N1GM4]> right, so centroid is one of those functions? Then that calls addDivide or something to do the adding and dividing.
15:12:26 <basti|-> yes
15:12:29 <[3N1GM4]> ok then.
15:17:04 <[3N1GM4]> grrr, I keep getting lost. I feel like I'm going round in circles (ironically enough)
15:17:23 <[3N1GM4]> do I even want the line: centroid(x:xs) = ?
15:17:44 <basti|-> hmm. probably not if you want centroid to be your entry point
15:17:57 <[3N1GM4]> thats what I thought.
15:22:21 <[3N1GM4]> whats the representation of a list with more than one item in it?
15:22:29 <[3N1GM4]> in a general form...
15:22:46 <[3N1GM4]> not [x] or x[]
15:24:52 <[3N1GM4]> because I have:
15:24:53 <[3N1GM4]> weight :: Shape -> Point
15:24:53 <[3N1GM4]> weight x = (fst(centre x)*(area x),snd(centre x)*(area x))
15:25:09 <basti|-> (a:b)?
15:25:17 <[3N1GM4]> ok... one sec then
15:26:19 <[3N1GM4]> because map weight (a:b) should produce a list of the weighted coords, right?
15:26:42 <basti|-> no.
15:26:45 <[3N1GM4]> oh, ok.
15:26:51 <basti|-> there you just need to use the name of the variable
15:26:54 <basti|-> oh
15:27:03 <basti|-> but if you split your list then you're right
15:27:19 <basti|-> that is if "blahbla (a:b) = map..."
15:27:20 <[3N1GM4]> o I can only do map on the head or the tail, not the whole thing?
15:27:26 <[3N1GM4]> oh, ok
15:27:27 <[3N1GM4]> so:
15:27:30 <basti|-> map is on the whole thing!
15:27:44 <basti|-> you wouldnt need to split it, probably
15:28:09 <[3N1GM4]> centroid(a:b) = map weight (a:b) would give a list of the weigthed coords..?
15:28:20 <basti|-> yes
15:28:27 <basti|-> you could replace (a:b) with a now
15:28:30 <basti|-> in both places
15:28:49 <[3N1GM4]> now? What, just any name?
15:29:00 <[3N1GM4]> or it have to be now...?
15:29:10 <basti|-> you dont need to split it
15:29:15 <basti|-> at least not in that combination
15:29:19 <[3N1GM4]> ok, so I can call it whatever I want?
15:29:21 <basti|-> you can just call your list "a"
15:29:24 <[3N1GM4]> ok
15:29:27 <basti|-> or "moof"
15:29:34 <[3N1GM4]> lol, ok I get it.
15:29:37 <basti|-> you dont even need to tell haskell that its a list
15:29:42 <basti|-> =)
15:30:00 <[3N1GM4]> centroid a = map weight a       would give a list of the weighted coords
15:30:45 <[3N1GM4]> which I want to add up and divide by the number of shapes...
15:30:57 <[3N1GM4]> with another function!!! yey.
15:31:04 <basti|-> :)
15:31:24 <[3N1GM4]> I'm getting there, bear with me!
15:31:26 <[3N1GM4]> =)
15:31:41 <[3N1GM4]> you know if add is a keyword?
15:31:55 <basti|-> uhm
15:32:00 <basti|-> dont think
15:32:03 <[3N1GM4]> s'ok, I'll look it up...
15:32:07 <basti|-> type "add" in your interpreter
15:32:08 <SamB> you can use the function sum 
15:32:34 <[3N1GM4]> on a list of tuples?
15:32:41 <SamB> oh, no.
15:32:51 <[3N1GM4]> ok.
15:33:07 <SamB> what kind of tuple, though?
15:33:16 <[3N1GM4]> variable not in scope, so it's not a keyword.
15:33:21 <[3N1GM4]> This kind:
15:33:28 <[3N1GM4]> type Point = (Double,Double)
15:34:03 <SamB> try using unzip
15:34:20 <basti|-> oh. yes.
15:34:22 <basti|-> :)
15:34:39 * SamB wishes again for a signature-based search
15:34:43 <[3N1GM4]> unzip? I'll just look it up!
15:35:39 <[3N1GM4]> ok, cool, so unzip does:   [(x,y)] -> ([x],[y])
15:35:44 <[3N1GM4]> splits the tuple
15:35:50 <[3N1GM4]> into two lists.
15:36:10 <basti|-> yep
15:36:37 <[3N1GM4]> k
15:37:48 * SamB wants to search for functions whose types unify with (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:38:03 <[3N1GM4]> right, now I got this, and I'm about to write add: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
15:38:16 <basti|-> mmh ;)
15:38:25 <basti|-> do you know maybe some higher order function that could help? ;)
15:38:44 * bring also wants type signature search
15:38:44 <[3N1GM4]> me, or SamB?
15:38:53 <basti|-> [3N1GM4] you
15:38:59 <[3N1GM4]> lol, err, one sec.
15:39:18 <[3N1GM4]> sum
15:39:20 <[3N1GM4]> right?
15:39:33 <basti|-> hm
15:39:37 <basti|-> if it exists yes
15:39:37 <[3N1GM4]> no?
15:39:40 <[3N1GM4]> oh, ok.
15:39:53 <basti|-> i dont know it... but i assume it exists when SamB tells about it ;)
15:39:59 <[3N1GM4]> it does: http://www.zvon.org/other/haskell/Outputprelude/sum_f.html
15:40:06 <basti|-> k
15:40:51 <[3N1GM4]> add :: ([Point],[Point]) -> Point
15:40:51 <[3N1GM4]> add ([x],[y]) = (sum [x],sum[y])
15:41:10 <basti|-> why the []?
15:41:11 <SamB> it is sometimes defined in terms of foldr, since you ask about a higher-order function
15:41:23 <basti|-> SamB that was what i wanted to suggest
15:41:49 <SamB> [3N1GM4]: you seem to be confusing type signatures with code
15:42:45 <[3N1GM4]> add (x,y) = (sum x,sum y)
15:42:46 <[3N1GM4]> ?
15:43:27 <basti|-> good.
15:43:32 <[3N1GM4]> k.
15:43:39 <SamB> [3N1GM4]: eh, wouldn't it be better if you moved the unzip into add?
15:44:06 <[3N1GM4]> true
15:44:32 <SamB> add l = (sum x, sum y) where (x, y) = unzip l
15:47:43 <[3N1GM4]> ok, now I'm getting add is being applied to too many arguments, I need to parenthesise? (line 42)
15:48:14 <[3N1GM4]> add map weight a       ->         add(map(weight a))
15:48:23 <basti|-> yup
15:48:43 <[3N1GM4]> now map is applied to too few arguments...
15:48:53 <basti|-> oh
15:48:53 <basti|-> yes
15:48:58 <basti|-> sowwy braino
15:49:00 <basti|-> its late here
15:49:07 <basti|-> map wants 2 arguments, a function and a list
15:49:18 <[3N1GM4]> lol, that's ok.
15:49:21 <[3N1GM4]> so:
15:49:34 <[3N1GM4]> add(map(weight a a))
15:49:43 <[3N1GM4]> no
15:49:55 <[3N1GM4]> it was 2 args before, wasnt it?
15:49:57 <whee> 3N1GM4: you may want to look into the . and $ functions, too
15:50:05 <[3N1GM4]> ok, thanks whee
15:50:15 <whee> (just to make it look cleaner, nothing else)
15:50:20 <[3N1GM4]> kewl
15:51:33 <basti|-> function call binds pretty tight in haskell... thats why you usually need to () when you call a function in a parameter
15:51:54 <basti|-> you have to remember what you want to call and what you want to pass as an arguemnt
15:52:10 <[3N1GM4]> oh, so map(weight(a))?   map(weight)(a)?   map((weight)(a))?
15:52:17 <basti|-> lol
15:52:21 <whee> haha
15:52:36 <basti|-> rule: after ( comes a function that's called
15:52:48 <basti|-> as in, right now
15:52:49 <[3N1GM4]> ok
15:52:52 <basti|-> as opposed to "later"
15:53:01 <[3N1GM4]> hmm
15:53:37 <whee> I entirely lost track of what you're trying to do :|
15:53:44 <[3N1GM4]> lol, I know the feeling
15:53:45 * basti|- .o° ( if some future scientists discover this conversation in 1000 years they will think its some kind of philosophy )
15:53:53 <[3N1GM4]> lol
15:53:58 <basti|-> i want to teach [3N1GM4] how haskell is working ;)
15:54:06 <[3N1GM4]> I am trying to learn!
15:54:11 <basti|-> (a b c) is a call to function a with parameters b and c
15:54:35 <basti|-> (sometimes a function can be written 'infix' to, but not for now ;)
15:54:47 <[3N1GM4]> right, but one of the arguments of map is a function...
15:54:53 <basti|-> yep
15:54:53 <[3N1GM4]> and the other is the list a
15:54:57 <basti|-> so you dont need to call this one
15:55:11 <basti|-> how would you do that? ;)
15:55:33 <[3N1GM4]> hmmm
15:55:35 <basti|-> or, avoid that
15:56:03 <basti|-> i mean, you have two possibilities for an expression... you can do it like (a b c), or you...? ;)
15:56:27 <basti|-> hint: if you dont call a function, you dont write any ()
15:56:27 <[3N1GM4]> err, hmmm, err. I'll get it in a second, I know it!
15:56:34 <basti|-> ;)
15:56:55 <[3N1GM4]> but it's not map weight (a)    ?
15:57:07 <basti|-> no that would be call to a which isnt a function
15:57:08 <[3N1GM4]> or is it?
15:57:10 <basti|-> but its coming closer
15:57:26 <[3N1GM4]> (map weight a)?
15:57:31 <basti|-> yup
15:57:34 <[3N1GM4]> ah, ok.
15:57:46 <[3N1GM4]> Wow, I totally understand that better now! amazing.
15:57:49 <basti|-> map is called with weight and a
15:58:07 <[3N1GM4]> cool.
15:58:23 * basti|- likes these little zen lessons
15:58:50 <whee> heh
15:58:53 * [3N1GM4] does too
15:59:09 * [3N1GM4] still has a compilation error to deal with...
15:59:15 <[3N1GM4]> ok...
16:00:59 <[3N1GM4]> ah, might have solved it for myself this time!
16:01:05 <[3N1GM4]> HOORAY!
16:01:09 <[3N1GM4]> thats good then
16:01:46 <basti|-> :)
16:02:28 <[3N1GM4]> ok, so now I just need to divide the result by the number of shapes I started with...
16:02:57 <basti|-> ;)
16:03:33 <[3N1GM4]> which means finding the length of the list [Shape] supplied to centroid
16:03:45 <basti|-> of the list with the type [Shape]
16:04:00 <[3N1GM4]> sorry, yes.
16:04:02 <basti|-> i think SamB was right, youre confusing type signatures with variables
16:04:18 <[3N1GM4]> i do know the dofference, but i am sloppy.
16:04:23 <basti|-> ;)
16:04:26 <[3N1GM4]> =p
16:26:08 <[3N1GM4]> ok, I now have: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview but it doesn't like me using length a, cos it returns an int, and for some reason it wants a double, I think because I divide x and y (doubles) by l (Int)...
16:26:21 <basti|-> oh theres a function for that
16:26:26 <basti|-> named double i think
16:26:44 <[3N1GM4]> oh, so (double(length a))
16:26:58 <basti|-> i think
16:27:08 <basti|-> hm
16:27:08 <basti|-> no
16:27:12 <[3N1GM4]> no?
16:27:20 <basti|-> no, just checking it
16:27:21 <SamB> actually, I would think fromIntegral would be more appropriate
16:27:33 <basti|-> oh
16:27:55 <[3N1GM4]> oh?
16:28:24 <basti|-> i find people cool who can memorize things like that
16:28:41 <[3N1GM4]> lol
16:29:09 <[3N1GM4]> how do I use fromIntegral then?
16:29:38 <basti|-> (fromIntegral 241)
16:29:51 <[3N1GM4]> ok then, and that will convert to double?
16:30:09 <basti|-> seems like
16:30:15 <SamB> [3N1GM4]: it will convert to whatever kind of number is wanted
16:30:15 <[3N1GM4]> k, seems like a weird name...
16:30:20 <[3N1GM4]> ah, ok
16:32:56 <[3N1GM4]> so, I am putting this where: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview ...in divide? Like: divide (x,y) l = (x/l,y/l) 
16:32:59 <[3N1GM4]> oops.
16:33:02 <[3N1GM4]> divide (x,y) l = (x/l,y/l) 
16:33:04 <[3N1GM4]> argh1
16:33:24 <[3N1GM4]> divide (x,y) (fromIntegral l) = (x/l,y/l)  ?
16:33:29 <basti|-> uhhhh
16:33:39 <basti|-> no.
16:33:43 <[3N1GM4]> ok.
16:33:53 <[3N1GM4]> in each instance of its use?
16:34:03 <basti|-> hmm
16:34:07 <[3N1GM4]> divide (x,y) l = (x/(fromIntegral l),y/(fromIntegral l))
16:34:18 <basti|-> better.
16:34:21 <[3N1GM4]> yeh?
16:34:27 <basti|-> I think
16:34:35 <[3N1GM4]> yes, compiles
16:35:22 <SamB> oh, you should look at the Integral class, it has functions you could probably use
16:35:23 <Cale> shouldn't the type of divide be Point -> Double -> Point ?
16:35:42 <[3N1GM4]> no, because it recieves an Int, then converts it to Double
16:35:46 <[3N1GM4]> right?
16:36:02 <basti|-> you could do it in another combination too
16:36:06 <Cale> Well, Point is already (Double, Double)
16:36:07 <basti|-> convert at another place
16:36:16 <[3N1GM4]> yeh, do:
16:36:30 <[3N1GM4]> divide :: Point -> Double -> Point               and
16:37:05 <[3N1GM4]> no, I'm wrong. I'll leave it how it is, theres nothing wrong with it
16:37:13 <SamB> [3N1GM4]: you might want to leave out the type signature on this one
16:37:49 <[3N1GM4]> where? divide (x,y) l     to something else?
16:38:47 <Cale> or make it divide :: (Fractional a) => Point -> a -> Point
16:38:48 <[3N1GM4]> or you talkin about Point?
16:39:17 <[3N1GM4]> hmm, what is actually wrong with what I have now?
16:39:46 <Cale> nothing - the suggestions here just make things a little more general.
16:40:20 <[3N1GM4]> ok, I will take them on board and perhaps revisit them later, once the prog works!
16:40:28 <[3N1GM4]> =p
16:41:16 <Cale> It seems odd that you'd only allow division by integer amounts when your points are pairs of Doubles.
16:42:00 <[3N1GM4]> but l is only ever going to be an integer amount, cos it's the length of the list a...
16:42:36 <Cale> hm?
16:42:49 <[3N1GM4]> the result of dividing those doubles x and y by l will be double right? Must be, otherwise, it wouldn't be apoint, yeh?
16:43:28 <Cale> sure, I just don't see why you'd want to restrict yourself to only integers.
16:43:52 <Cale> the usual thing is to try to give things the most general type that you can.
16:44:20 <[3N1GM4]> becuase the length of the list will never be non integer? Although, I suppose it might be...
16:44:20 <SamB> the best way to give things general type is to leave out the type ;-)
16:44:40 <SamB> [3N1GM4]: because you might want to use the function again1
16:44:45 <SamB> s/1/!/
16:44:46 <[3N1GM4]> oh, ok...
16:44:49 <Cale> like, what if later you want to divide a point by its distance from the origin?
16:45:08 <[3N1GM4]> ok, so how do I adapt it to make it more general in that way?
16:45:08 <Cale> (i.e. to normalise it)
16:45:32 <SamB> you see, in Functional Programming, reuse is no myth
16:45:42 <[3N1GM4]> I am beginning to see that
16:45:46 <Cale> Just making the type of divide :: (Fractional a) => Point -> a -> Point should work.
16:46:13 <Cale> then any type that allows division will work there
16:46:23 <[3N1GM4]> ok, but what does that mean? Fractional a? I have not encountered "=>" yet...
16:47:18 <Cale> It says that the type of divide is Point -> a -> Point, for any a which is in the Fractional class of types.
16:47:43 <[3N1GM4]> ok.
16:48:22 <Cale> That is, anything for which (/) is defined.
16:48:27 <SamB> Cale: then you would need to coerce a to Double anyway, because (/) :: (Num a) => a -> a -> a
16:48:40 <SamB> er, s/Num/Fractional/
16:49:50 <Cale> oh, was the goal to avoid coercing the type of something? I came in late.
16:54:48 <[3N1GM4]> ok,  http://www.haskell.org/hawiki/HaskellIrcPastePage#preview Now it dont like my shape function. Couldn't match [Char] against Double, have I misused the ++?
16:55:31 <SamB> Cale: no, but it seems like there is very little point in generalizing the type just to coerce back to double...
16:55:43 <Cale> SamB: oh, I see - right
16:55:57 <SamB> on the other hand, Point could be parameterized
16:55:58 <Cale> It would work out if the type of Point was already general
16:56:02 <Cale> yeah
16:56:52 <[3N1GM4]> yeah, I have misused ++?
16:57:44 <Cale> you probably want to show the totalArea before trying to ++
16:58:20 <[3N1GM4]> ok...how exactly do you mean?
16:58:34 <Cale>  show (totalArea(map convert a))
16:58:36 <[3N1GM4]> I have a rigid output from shape function which I must adhere to...
16:58:42 <SamB> define before ++
16:58:45 <[3N1GM4]> right, ok
16:58:51 <SamB> s/ ++//
16:59:09 <[3N1GM4]> word, that compiles, now I can test!
16:59:10 <Cale> SamB: compositionally before
17:00:42 <[3N1GM4]> well it output, now I just gotta check it's right!
17:00:55 <[3N1GM4]> calculator time
17:02:10 <Cale> ooh, a 9p on kgs.
17:09:04 <[3N1GM4]> ok, it works for areas.
17:09:16 <[3N1GM4]> now just gotta get that centroid in there, shoudnt be a problem
17:10:46 <basti|-> ;)
17:11:29 <Lunar^> Damn.. JNode doesn't have any IRC channel ?
17:12:59 <[3N1GM4]> IT WORKS!!!!!!
17:13:02 <[3N1GM4]> hooray
17:14:04 <[3N1GM4]> I cant thank you guys enough for your help, you are truly heroes and life savers.
17:14:23 <[3N1GM4]> Now I just have to build the exact same program in Java, but that can be another day.
17:14:42 <basti|-> ;)
17:15:44 <[3N1GM4]> Well, I shall bid you fine gents goodnight then.
17:15:55 <basti|-> ill go sleeping to by now
20:58:23 <SamB> do we have a fast (x**y) `mod` z?
20:58:43 <stepcut> dunno
20:59:20 <SamB> python has, but it is spelled pow
21:02:22 <SamB> I realize Haskell needs no visible support for this
21:02:58 <SamB> well, hmm, wait. Haskell allows overflow...
21:08:29 <Riastradh> SamB, uh, you don't want to be naive there just because Haskell handles overflow gracefully.
21:09:24 * stepcut finally checks out haskelldb/ghc
21:10:17 <SamB> er, isn't there an Integral power function too?
21:10:53 <SamB> hey, Integer isn't lazy?
21:12:19 <SamB> Prelude Bits> let (<<) = shiftL; (>>) = shiftR; (<<) :: Bits a => a -> Int -> a; (>>) :: Bits a => a -> Int -> a
21:12:26 <SamB> Prelude Bits> (1 << 100000000000) >> 100000000000 :: Integer
21:12:36 <SamB> *silence*
21:41:37 <Swynndla> if: l=[1,2,3,4,5,6] and: add30 n = 30 + n and: map add30 l works ok ...
21:41:54 <Swynndla> and produces the output: [31,32,33,34,35,36]
21:42:13 <Swynndla> then why doesn't this work: map Char.chr (map add30 l)
21:42:28 <Swynndla> if says:         Expected type: [Int]
21:42:29 <Swynndla>         Inferred type: [Integer]
21:43:07 <Swynndla> I mean this works fine and dandy: map Char.chr [31,32,33,34,35,36]
21:43:24 <Swynndla> so I'm confused 
21:46:59 <SamB> Swynndla: you should use let or where...
21:47:09 <Swynndla> oh
21:47:42 <dennisb> Int and Integer are two different types
21:48:02 <Swynndla> how are they different?
21:49:09 <dennisb> Int = 32-bit (on most systems) and Integer = arbitrary big
21:49:30 <Swynndla> so how do I overcome this problem?
21:49:43 <Swynndla> convert the Integer to Int?
21:49:47 <dennisb> If you make sure your list has type [Int] it will probably work
21:50:16 <dennisb> one can convert also, using for example fromEnum
21:50:28 <dennisb> add l :: [Int]
21:51:28 <Swynndla> how should I have made sure that: map add30 l returns Int instead of Integer?
21:51:37 <dennisb> if you have a top level thing where the haskell system does not know if it's Int or Integer then it will default to use Integer. So l = [1,2,3] will ba an Integer list and not a Int list
21:51:51 <Riastradh> Int should be called Fixnum or something.  It's overly misleading.
21:52:17 <dennisb> Swynndla: map add30   works on both Int and Integer
21:52:27 <Swynndla> oic
21:52:30 <dennisb> chr however only works on Int
21:52:46 <dennisb> so give it an Int list instead of an Integer list and it will work
21:53:29 <dennisb> l = [1,2,3] :: [Int]
21:53:40 <Swynndla> so when I do: map Char.chr [31,32,33,34,35,36] then it works so manually typing the numbers must be in the form Int
21:53:41 <Swynndla> oic
21:54:27 <dennisb> it's just when you make a global list l = [1,2,3] that it has to give it a specific type directly, and it will default to Integer when you have not given it a type
21:54:50 <dennisb> make it a local list in a let or where and it will probably have figured out the type for you
21:55:44 <Swynndla> ahhh
21:56:51 <dennisb> Prelude> let l = [1,2,3,4]; add30 n = 30 + n in  map chr (map add30 l)
21:56:51 <dennisb> "\US !\""
21:57:49 <Swynndla> oic oic
21:58:48 <Swynndla> I have to use 'Char.chr' instead of 'chr'
21:59:51 <dennisb> or add a Import Char
22:01:44 <Swynndla> ahhh
22:02:21 <Swynndla> that's the same thing as ':l Char' in ghci?
22:04:22 <dennisb> similar, yes
22:05:03 <Swynndla> oic .. and how would I write this in a file: let l = [1,2,3,4]; add30 n = 30 + n in  map chr (map add30 l)  
22:05:19 <Swynndla> as if I put that in and load it, it has an error
22:06:04 <dennisb> x = let l = [1,2   ...
22:06:44 <dennisb> or you could just do as you do now and tell it that l should have type [Int] and not type [Integer]
22:07:52 <dennisb> a file must contain definition (x = this; y = that), you can not just write a value in a file and load it
22:08:49 <Swynndla> ok ... this didn't work in the file either: let x = let l = [1,2,3,4]; add30 n = 30 + n in  map chr (map add30 l)
22:09:04 <dennisb> skip the first let
22:09:07 <dennisb> x = ...
22:09:14 <Swynndla> ahhhhhhhhhhhhh
22:13:04 <dennisb> It worked I guess?
22:13:35 <Swynndla> not yet ... it now says: Variable not in scope: `Char.chr'
22:13:45 <Swynndla> when I try and load the file
22:14:36 <Swynndla> it works when I do it manually like you did in the interpreter ... but loading from a file is a different story huh?
22:14:44 <dennisb> Swynndla: http://paste.msunix.org/view.php?id=164
22:18:01 <Swynndla> ahhhh thx dennisb, it works!!
22:30:36 <Swynndla> so in the interpreter, Char is loaded by default?
22:32:39 <Swynndla> well, in ghc it is, but hugs it isn't
22:35:19 <Swynndla> thanks for your help dennisb :)
