00:00:23 <Cale> well, perhaps the empty list of list of nested lists ad-infinitum.
00:00:49 <ski> Cale : [] , [[]] , [[],[]], [[],[],[]], ...,[[[]]],[[[]],[]], .... , ....
00:01:17 <Cale> it's not a = Maybe [a], it's a = [a].
00:01:29 <Cale> every element will have infinitely many square brackets
00:01:41 <ski> Cale : hmm, i wonder how similar this is to defining ordinals in ZF Set Theory
00:01:51 <scott> helper startnum = startnum:(helper (startnum - 1))...then where do I call summands recursively?
00:01:55 <ski> Cale : but each list can be empty, right ?
00:02:20 <Cale> hmm... oh, right :)
00:02:23 <ski> scott : well, you're on the way
00:02:48 <Cale> so, yeah, you're right, it's perhaps like possibly infinite rose trees
00:02:48 <ski> hmm
00:03:05 <scott> do I then concatenate *that* onto the recursive call of summands?
00:03:06 <Cale> which is something that could be dealt with rather directly
00:03:23 <ski> scott : i think that's not quite right
00:04:04 <ski> we should have a call  summand (len - 1) (sum - startnum)  somewhere, right ?
00:04:16 <Cale> hmm...
00:04:18 <scott> yes, right
00:04:39 <ski> and this is going to return lists that are one element short
00:05:07 <ski> all the lists that come from this call is connected to this very startnum, agree ?
00:05:29 <ski> (because we pass  sum - startnum, for *this* startnum to the call)
00:05:30 <scott> right
00:06:02 <ski> so each of these lists are possible ways of further dividing up the number (sum - startnum) in (len - 1) parts
00:06:25 <ski> so each of these lists should be prepended by the same number, i.e. startnum
00:06:27 <scott> right...
00:06:28 <ski> do you agree ?
00:06:36 <scott> yeah
00:06:38 <ski> ok
00:06:59 <ski> so how do we prepend startnum onto each of a lot of lists ?
00:07:18 <scott> by mapping?
00:07:25 <ski> that could work
00:07:29 <ski> shall we try
00:07:37 <ski> ?
00:08:20 <scott> ok, well...I know how to map a function onto a list...how would you map a concatenation? similar way?
00:08:30 <ski> how would you prepend the number startnum to a single list, say xs ?
00:08:40 <ski> yes, somewhat similar
00:08:41 <scott> startnum:xs
00:08:44 <ski> yes
00:08:56 <ski> so if we now take away xs
00:09:10 <ski> what is the function that prepends startnum to a list ?
00:09:21 <scott> :
00:09:45 <ski> (i hope you've seen things like map (5 *) [0..10])
00:09:59 <ski> : prepends something onto a list
00:10:12 <andersca> ski: gÃ¥ och lÃ¤gg dig!
00:10:13 <andersca> :)
00:10:17 <ski> which function prepend *startnum*
00:10:27 <ski> andersca : nooooo ! :)
00:11:02 <scott> helper?
00:11:09 <ski> well
00:11:16 <ski> e.g.
00:11:20 <ski> 5 * 2 is 10
00:11:28 <ski> (5 *) 2 is also 10
00:11:32 <scott> right
00:11:42 <ski> (5 *) is the multiply-by-five function
00:11:46 <scott> (startnum :)
00:11:54 <ski> yeeesss ! :)
00:12:08 <ski> good abduction
00:12:16 <scott> I had that a couple minutes ago and erased it because I didn't think that's what you were asking for, heh
00:12:29 <ski> heh
00:12:30 <scott> so (map (startnum :) (summands (len-1) (sum-startnum))
00:12:36 <ski> yes
00:12:40 <ski> that seems good
00:12:45 <ski> what does that give us ?
00:13:10 <scott> that gives a list of lists beginning with startnum
00:13:18 <ski> yeah
00:13:33 <ski> and they're of length len, as they should be !
00:13:37 <scott> right
00:13:47 <ski> but all these lists start with startnum
00:14:12 <ski> so we have to generate all those which start by other startnum's also
00:14:29 <ski> i.e. we have to remember now the recursive case of helper
00:14:30 <scott> so we need to recursively call helper downward?
00:14:34 <ski> yes
00:14:45 <ski> what was that call like, now again ?
00:14:53 <ski> helper  ...something..
00:15:24 <scott> helper (startnum - 1)
00:15:29 <ski> right
00:15:47 <ski> so this is going to give us lists that start with (startnum - 1), right ?
00:16:04 <ski> :)
00:16:06 <scott> right, so we concatenate that onto the mapping we just did?
00:16:12 <ski> yeah
00:16:16 <ski> but not only that
00:16:22 <ski> because it's a recursive call
00:16:49 <ski> that call is also going to generate lists starting with (startnum - 2), all the way down to 0
00:16:55 <ski> godd, huh ?
00:16:58 <ski> good
00:17:04 <scott> the wonders of recursion
00:17:09 <ski> yeah ;)
00:17:32 <ski> so what do you think this helper definition line looks like, now ?
00:17:44 <ski> put together the two pieces
00:18:26 <ski> see how ?
00:18:29 <scott> helper startnum = (helper (startnum-1))++(map (startnum :) (summands (len-1) (sum-startnum)))
00:18:40 <ski> that seems good
00:19:07 <ski> (though, i would rather append the helper-call *after* the other)
00:20:00 <scott> if you prepend the helper call won't that put the sums starting with 0 first?
00:20:00 <ski> (perhaps wou've heard about left-associative append problem)
00:20:15 <ski> yes
00:20:33 <ski> but i think it makes the algorithm much slower also
00:21:01 <ski> in any case, i think you could add a reverse into the summands line, if you want it in the other order
00:21:10 <ski> hmm
00:21:29 <scott> well, the examples the prof gave us of the function in action are in increasing order
00:21:38 <ski> well, actually it's probably better to make summands into a helper, called e.g. summands'
00:21:45 <ski> and say 
00:21:48 <Cale> I got by with just concat and mapping a cons somehow.
00:21:59 <ski> summands len sum = reverse (summands' len sum)
00:22:07 <scott> like summands 3 5 = [[0,0,5],..,[1,2,2]]
00:22:16 <scott> yeah, that makes sense
00:22:20 <ski> i would think so
00:22:23 <ski> but..
00:22:45 <ski> scott, i'm not sure we have made sure the nondecreasing stuff
00:22:49 <ski> yet
00:23:38 <scott> let me check it out...
00:24:08 <ski> Cale : but do you agree that putting the helper call first would be worse that putting it after ?  or am i mistaken ?
00:24:39 <ski> scott : i think you could, now, at least, write down a full code, that one can try out :)
00:26:45 <scott> I'm trying it out...I'm on a PC and I've run into a lot of problems writing code on it...I do my programs in the Sun lab.
00:26:57 <ski> ok, aha
00:27:11 <scott> like the fromInt function doesn't seem to be recognised on the PC
00:27:21 <ski> it's not standard
00:27:26 <scott> I know 
00:27:28 <ski> use fromIntegral instead
00:27:42 <Cale> I'm not entirely sure that it matters too much, though probably the best test would be just to try it. To get the first element, you'll have to run all the way down the helper chain, but in general, that shouldn't be so many steps anyway.
00:28:25 <ski> Cale : i'm thinking about (((...) ++ ...) ++ ...) ++ ...
00:28:29 <Cale> yeah
00:29:07 <Cale> you'll have a tree with a ++ at the top and ++'s running down the left, that you'll have to follow down to get at the first element.
00:29:12 <ski> though helper is also calling summands, so i'm not sure how much that would help
00:29:28 <Cale> but how big are the pieces you're concatenating?
00:29:29 <ski> Cale : and that's of course bad
00:29:41 <ski> Cale : yeah, i'm not sure
00:30:25 <ski> Cale : but i think we're (at least using this method) anyways going to concat them, so better do it in a right-associative way
00:30:54 <ski> Cale : one could perhaps/possibly use an accumulator here
00:30:58 <scott> damn, not getting back what I want
00:31:03 <ski> no :)
00:31:11 <ski> try with 0 and 0
00:31:22 <ski> then with 1 and 0
00:31:29 <ski> and 0 and 1
00:31:41 <ski> what do these yield ?
00:31:50 <scott> all three return [[]]
00:31:53 <Cale> I just had something like the concat of map (\q -> ...) [a .. n `div` k]
00:32:14 <ski> hm
00:32:28 <scott> summands 0 sum = [[]]
00:32:28 <scott> summands len sum = helper (sum `div` len)
00:32:28 <scott> 	where
00:32:28 <scott> 		helper 0	= [[]]
00:32:28 <scott> 		helper startnum = (map (startnum :) (summands (len-1) (sum - startnum))) ++
00:32:29 <scott> 				  (helper (startnum -1))
00:32:32 <Cale> where ... is where the consing happened along with the recursive call
00:32:34 <ski> shouldn't last one be [] ?
00:32:34 <scott> that's the code I have
00:33:15 <ski> i mean
00:33:29 <ski> shouldn't summands 0 1 === []  ?
00:33:36 <ski> sum should be 1
00:33:40 <ski> length 0
00:33:44 <ski> i.e. impossible
00:33:52 <ski> i.e. no solution (empty list of solutions)
00:34:29 <ski> let us try to see what happens
00:34:38 <ski> oh
00:34:40 <ski> yes
00:34:48 <ski> the base case for summands
00:35:09 <ski> if the length is 0, then if the sum is 0, *then* return [[]]
00:35:30 <ski> but if the length is 0, and the sum isn't. *then* return []
00:35:38 <ski> does that seem reasonable ?
00:35:44 <scott> I think so
00:36:02 <ski> so add one more base case, and change the one you've got
00:36:22 <ski> see how ?
00:36:28 <scott> hmmm
00:36:38 <scott> summands 1 0 still = [[]]
00:36:58 <ski> (actually just read what i wrote in words, above. then write that in code)
00:37:11 <scott> I wrote:
00:37:18 <scott> summands 0 0 = [[]]
00:37:22 <ski> yes
00:37:27 <scott> summands 0 sum = []
00:37:39 <ski> i think that is the correct thing to do
00:37:43 <scott> but I'm still getting answers I don't want
00:37:47 <ski> yes
00:37:57 <scott> like summands 1 0 = [[]]
00:38:03 <ski> summands 1 0 should become [[0]], right ?
00:38:04 <scott> it should return [[0]]
00:38:07 <ski> yes
00:38:08 <scott> yes
00:38:14 <ski> so
00:38:23 <ski> let's review this, also
00:38:49 <ski> so, we come to the non-base-case of summands, with len = 1 and sum = 0
00:39:05 <scott> right
00:39:07 <ski> what's (sum `div` len) ?
00:39:14 <scott> 0
00:39:18 <ski> yeah
00:39:48 <ski> and that seems right, because the sum should be 1, so it shouldn't try with some higher startnum
00:39:54 <scott> right
00:40:04 <ski> so now startnum = 0
00:40:12 <ski> and we come to base case, right ?
00:40:21 <scott> oh
00:40:25 <scott> yeah
00:40:32 <ski> hmm
00:40:43 <ski> the recursive calls of helper
00:41:02 <ski> um, hmm
00:41:21 <scott> what if it was helper (-1)?
00:41:41 <ski> well, we could put in catcher cases for such things
00:42:04 <ski> for now, i've just assumed that all Int's really are Nat's (i.e. nonnegative)
00:42:17 <scott> if I change it to helper (-1), I get summands 1 0 = [[0],[]]
00:42:42 <ski> (and if the initial args to summands are nonnegative, then i think no variable is gonna become negative, on the way)
00:43:01 <ski> well, we need to think a bit more i guess
00:43:23 <ski> the problem is that the length is not finished
00:43:33 <scott> hold on
00:43:36 <ski> so in the length 0 = ...  case
00:43:37 <ski> ok
00:43:58 <scott> if I change helper (-1) = [[]] to helper (-1) = [] I get
00:44:09 <scott> summands 1 0 = [[0]]
00:44:15 <ski> hmm
00:44:28 <ski> i don't think this is going to solve the problem
00:44:33 <ski> think of it as this
00:45:00 <ski> each recursive call of summands decreases the length by one, ok ?
00:45:14 <scott> well, actually, if I call summands 3 5 I get all the right permutations
00:45:18 <scott> except for 1 repeat
00:45:26 <ski> hm
00:45:35 <ski> do you agree ?
00:45:48 <scott> I agree
00:45:51 <ski> ok
00:46:01 <ski> and for each recursive call of summands
00:46:19 <ski> there are going to be a whole lot of recursive calls of helper
00:46:34 <scott> right
00:46:35 <ski> for counting startnum down from  sum `div` len  to 0
00:46:38 <ski> yeak
00:46:40 <ski> yeah
00:46:43 <ski> so
00:46:58 <ski> what i wanted to say now is this :
00:47:15 <ski> when we come to helper's base-case
00:47:25 <ski> helper 0 = ...          (the old one)
00:47:44 <Cale> hehe, here's another problem for when you get this one - given a string of u's and d's, find the *number* of permutations of [1..n] (where n = 1 + length of string) following the corresponding pattern of ups and downs. i.e. u = '>', d = '<=', so for "udu", [1,3,2,4] is one you'd count, since 1 u 3 d 2 u 4.
00:47:46 <ski> length is not necessarily zero !!
00:48:12 <ski> Cale : perhaps he can try that when this is solved :) ?
00:48:18 <Cale> yeah
00:48:24 <ski> scott : do you agree ?
00:48:31 <scott> right
00:48:33 <scott> yeah
00:48:34 <ski> so
00:48:56 <ski> length is supposed to tell us how long each list are going to be
00:49:02 <ski> but what are we doing
00:49:03 <ski> ?
00:49:05 <Cale> and for an extra challenge, do it in O(n^3) time where n is max(# of u's, # of d's)
00:49:17 <ski> we're *always* returning lists of length 0 here !
00:49:20 <ski> i.e.
00:49:25 <ski> helper 0 = [[]]
00:49:25 <ludde> what is the syntax for record datatypes in haskel
00:49:25 <ludde> l
00:49:28 <scott> right
00:49:35 <ski> scott : this is bad
00:49:40 <scott> heh, yeah
00:49:43 <Cale> anyway - I'm off to bed
00:49:48 <ski> if the sum is 0 (as the base-case says)
00:49:57 <ski> Cale : good dreaming
00:50:20 <ski> then the rest of the list must be filled with 0's, do you agree ?
00:50:28 <scott> yes
00:50:47 <ski> ludde : data Foo = MkFoo {foo :: Int,bar :: Float} | ...
00:50:55 <ludde> thanks
00:50:57 <ski> so lets do that
00:51:11 <ski> how many 0's should we have ?
00:51:14 <Cale> just for pondering - I have a solution to the problem I just posed using gaussian elimination and binomial coefficients.
00:51:35 <ludde> ski: do the names for the record entries have to be unique across the whole program?
00:51:38 <Cale> it's pretty bizarre :)
00:51:38 <ski> Cale : the "*number* of permutations" thing ?
00:51:41 <Cale> yeah
00:51:48 <ludde> ski: can i have two records that share the same name of a field
00:51:52 <scott> how many zeroes should we have when?
00:51:59 <ski> ludde : across the module
00:52:21 <ski> well, as many as the list should have elements, right ?
00:52:27 <ski> which was ?   :)
00:52:42 <scott> len
00:53:46 <ski> Cale : hmm, interesting problem.  i think i've unconsciously (well haven't actively thought of it as a computing problem) encountered it before
00:53:53 <ski> scott : yes !
00:53:56 <ski> so 
00:54:07 <ski> how do we make a list of len 0's ?
00:54:08 <ludde> ski: can i have two records that share the same name of a field
00:54:51 <scott> concatenate a 0 onto a list of len-1 0's?
00:54:56 <scott> and so on?
00:54:59 <ski> ludde : not in the same module, but the same type can have different constructorsm sharing the same field-name (*must* also share the same type, in this case)
00:55:06 <ski> @type replicate
00:55:07 <lambdabot> replicate :: Int -> a -> [a]
00:55:09 <ski> :)
00:55:16 <ludde> ok
00:55:34 <ski> @eval replicate 5 0
00:55:35 <lambdabot> [0, 0, 0, 0, 0]
00:55:56 <ski> scott : see ?
00:56:00 <scott> yeah
00:56:04 <ski> oh
00:56:12 <ski> one more thing about this base case
00:56:14 <scott> hmm
00:57:09 <ski> there is obviously only going to be *one* solution  (if there were more, all of them would be lists of 0's, and thusly duplicates (because same length))
00:57:15 <ski> so
00:57:22 <ski> helper 0 = [...]
00:57:38 <ski> i think you can fill in the ...  right ?
00:58:06 <scott> replicate len 0
00:58:11 <ski> mm
00:58:29 <ski> helper 0 = [replicate len 0]           see only one element/solution !
00:58:40 <ski> ok
00:58:45 <ski> try
00:58:48 <ski> summands 1 0
00:58:50 <ski> again
00:59:26 <scott> yeah
00:59:31 <scott> that returns the right answer
00:59:35 <ski> good
00:59:49 <ski> so that's also fixed
00:59:54 <scott> but that's screwed up summands 3 5
00:59:55 <ski> is there more to fix ?
00:59:59 <ski> yes
01:00:12 <ski> so what do we have now ?
01:00:18 <ski> (code)
01:00:18 <scott> I was getting a better answer before I added the replicate 1 0 stuff, heh
01:00:22 <scott> I mean len 0
01:00:29 <ski> mm
01:00:49 <ski> (i think there was already bad thing previously there)
01:00:51 <scott> I'm getting the set [0,0,0] fr one
01:01:02 <scott> for one
01:01:06 <ski> ?
01:01:20 <ski> for which two args of summands ?
01:01:27 <scott> for 3 5
01:01:30 <scott> but probably all
01:01:34 <scott> because it's the base case
01:01:53 <ski> it doesn't give any other solution, at all ?
01:02:00 <scott> no, it gives others
01:02:06 <scott> some are right, some are wrong
01:02:06 <ski> ok
01:02:13 <ski> but that one is wrong, at least
01:02:25 <scott> a lot that end in 0
01:02:35 <scott> because of the base case that we wrote
01:02:48 <ski> how does your code look like now ?
01:02:54 <ski> you can perhaps paste it
01:03:01 <scott> summands 0 0 = [[]]
01:03:01 <scott> summands 0 sum = []
01:03:01 <scott> summands len sum = helper (sum `div` len)
01:03:01 <scott> 	where
01:03:01 <scott> 		helper (0)	= [replicate len 0]
01:03:02 <scott> 		helper startnum = (map (startnum :) (summands (len - 1) (sum - startnum)))                                   ++ (helper (startnum - 1))
01:03:07 <ski> ok, thanks
01:03:33 <ski> (um, the parens in  helper (0)  are unnessecary)
01:03:40 <ski> ok, hm
01:04:00 <ski> so
01:04:04 <scott> I know, I used to have -1 there
01:04:25 <ski> i think it doesn't enforce the nondecreasing requirement
01:04:28 <ski> ok
01:04:46 <scott> no, it doesn't enforce the sum requirement either
01:05:16 <ski> mm
01:05:19 <ski> oh, yes
01:05:29 <ski> or, hmm
01:05:45 <ludde> is it not possible to layout a datatype like this:
01:05:45 <ludde> data JVMInstr = 
01:05:45 <ludde> 	JIAdd						-- integer add
01:05:45 <ludde> | JISub						-- integer sub
01:05:49 <scott> when I had helper -1 = [], it did.  It just had some lists that contained the same elements in a different order
01:05:53 <ludde> oops, tabs look completely wrong
01:06:03 <ski> the summands recursive call are generating the tails of the lists
01:06:15 <ski> ludde : no :)
01:07:10 <scott> ski, I might be better off just using a list comprehension to get rid of those few pesky decreasing lists
01:07:15 <scott> and reverse it
01:07:25 <ski> and at each of those recursive calls we are passing (sum - startnum), which are going to become the new sum, in this recursive call
01:07:37 <scott> right
01:07:54 <ludde> data State = State {
01:07:58 <ludde> foo :: Int,
01:08:02 <ludde> bar :: Int
01:08:03 <ludde> }
01:08:07 <ski> and, in summands, when the length drops to 0, we check whether sum is 0 or not
01:08:07 <ludde> why can i not use newtype here?
01:08:36 <ski> ludde : newtype can only be used for a one-constructor-type with one argument
01:08:44 <ludde> oh ok
01:09:06 <ludde> so this is less efficient than using a (foo, bar) tuple then?
01:09:44 <ski> so, scott, what i can see, we *are* checking for the sum  (first and second case of summands)
01:09:55 <ski> hmm
01:10:26 <ski> oh
01:11:03 <ski> but perhaps we are not checking so that (sum - startnum) does not drop below 0.  are we ?
01:11:26 <scott> no
01:11:30 <ski> right
01:11:40 <ski> so therfore sum can become < 0
01:11:54 <ski> thereby sqrewing up the sum = 0 check, probably
01:12:00 <ski> so lets add that checking
01:12:28 <ski> so we should check for  sum >= startnum   i think
01:12:30 <scott> but if sum `div` len = startnum...won't startnum always be less than sum?
01:12:44 <ski> hmm
01:13:20 <ski> well
01:13:32 <ski> umm, seem like so
01:13:39 <ski> so what is the problem
01:13:46 <ski> try summands 1 1
01:14:01 <ski> (should be [[1]] i think)
01:14:02 <scott> I get [[1]]
01:14:04 <ski> ok
01:14:14 <ski> try summands 1 2
01:14:24 <ski> [[2]] ?
01:14:45 <ski> no ?
01:14:54 <scott> yeah...but wait, are we using the replicate etc. base case or the -1 = [] base case
01:14:54 <scott> heh
01:15:08 <ski> the replicate, i think
01:15:20 <scott> because I changed it back...because the replicate seemed to screw everything up
01:15:55 <ski> ok, hmm, i suppose you could comment out the -1 one, and use the replicate one, for now ..
01:16:58 <ski> what do you think ?
01:17:07 <scott> ok...It's just...if we reach the base case, it'll automatically add a list full of 0's.
01:17:21 <ski> hm
01:17:28 <ski> hmm
01:17:33 <ski> well
01:17:38 <ski> it's correct
01:17:49 <ski> for the case that sum was 0 initially
01:18:00 <ski> but not othewise
01:18:10 <ski> (because of nondecreasing)
01:18:26 <ski> summands 4 0 should still give [[0,0,0,0]]
01:19:08 <scott> but the problem is that summands 4 sum gives [[0,0,0,0]]
01:19:22 <ski> mm
01:19:28 <ski> hmm
01:20:07 <ski> we have currently startnum in range 0 .. sum `div` len
01:20:33 <ski> probably we should have it in range oldStartnum .. sum `div` len
01:20:39 <ski> right ?
01:21:04 <scott> I think so
01:21:08 <scott> yeah...
01:21:10 <ski> ok
01:21:49 <ski> so when helper calls summands, it needs to pass startnum to it, so that summands can remember it as olStartNum, ok
01:21:51 <ski> ?
01:22:04 <ski> oldStartnum
01:22:28 <ski> do you agree with this ?
01:22:35 <scott> digesting it
01:22:39 <scott> I think so
01:23:33 <ski> i.e. summands needs to remember oldStartnum, so that, when *it* calles helper (again), helper should know what the lower bound of the new startnum should be
01:24:05 <scott> so you're talking about giving summands a third value?
01:24:08 <ski> sounds complicated ?
01:24:10 <ski> yes
01:24:11 <ski> so
01:24:21 <scott> well, summands is only supposed to have two values
01:24:22 <ski> first we rename summands to summands'
01:24:27 <scott> ok
01:24:28 <ski> and then say
01:24:39 <ski> summands len sum = summands 0 len sum
01:25:08 <ski> thus setting the initial oldStartnum to 0, because, initially the lower bound should actually be 0
01:25:12 <ski> agree ?
01:25:26 <scott> summands' 0 len sum, you mean
01:25:45 <ski> yes :)
01:26:09 <ski> and then
01:26:20 <ski> summands oldStartnum 0 0 = [[]]
01:26:32 <ski> summands oldStartnum 0 sum = []
01:26:35 <scott> well, I can just put _ right?
01:26:40 <ski> yeah
01:26:52 <ski> for sum also, there
01:27:06 <ski> summands _ 0 0 = [[]]
01:27:12 <ski> no
01:27:18 <ski> summands' _ 0 0 = [[]]
01:27:27 <ski> summands' _ 0 _ = []
01:27:42 <scott> right
01:27:54 <ski> summands' oldStartnum len sum = helper (sum `div` len)
01:27:56 <ski>   where
01:27:58 <ski>   ...
01:28:02 <scott> right
01:28:06 <ski> ok
01:28:13 <scott> and then feed startnum into the recursive call
01:28:23 <ski> in helper yeah
01:28:33 <ski> as first argument
01:28:50 <ski> that passes the oldStartnum's around
01:29:03 <ski> now we have to check against the lower bound also
01:29:07 <ski> right ?
01:29:23 <scott> I guess so, because I'm still getting [0,0,0]
01:29:49 <ski> summandshelper startnum
01:30:07 <ski>   | startnum < oldStartnum = ...
01:30:10 <ski> i think
01:30:25 <scott> hmm
01:31:11 <scott> my list comprehension idea with the helper -1 = [] was a lot easier to understand, haha
01:31:15 <ski> the recursive case should still be there below, of course, just with modfied summands' (not the ' !) call
01:31:38 <ski> scott : i still think it would have been wrong  (but not totally sure)
01:32:15 <scott> really, I checked several cases, and the only thing that was wrong was the fact that I had some decreasing lists
01:32:22 <ski> yeah
01:32:43 <ski> and we dont want to generate them in the first place
01:32:58 <scott> I know
01:33:00 <ski> hmm
01:33:10 <ski> i think we should have
01:33:14 <ski> summandshelper startnum
01:33:19 <ski>   | startnum < oldStartnum = []
01:33:35 <ski> i.e. if  startnum < oldStartnum  there should be no solution
01:33:42 <ski> what do you think ?
01:33:46 <ski> try it out ?
01:33:56 <ski> hmm
01:34:00 <scott> where am I using this?
01:34:05 <scott> in the "where" section?
01:34:06 <ski> no that can't be right
01:34:10 <scott> and where am I calling it?
01:34:22 <ski> in the where section, yes
01:34:26 <ski> hmm
01:34:49 <ski> well
01:34:53 <ski> it might be right
01:34:59 <ski> lets try it !
01:35:12 <ski> try
01:35:15 <ski> summands 1 1
01:35:21 <scott> hold on
01:35:21 <ski> summands 2 1
01:35:25 <scott> typing
01:35:26 <ski> summands 1 2
01:35:30 <ski> summands 2 2
01:35:54 <ski> (i hope you've changed the recursive call from summands to summands')
01:35:59 <scott> I did
01:36:01 <ski> good
01:36:28 <scott> where am I calling summandshelper though?
01:36:36 <ski> helper ?
01:36:42 <ski> from summands'
01:37:02 <ski> summands' oldStartnum len sum = helper (sum `div` len)     i think
01:37:14 <ski> and then the   where .... part
01:37:29 <scott> right, but where does summandshelper come in though?
01:37:43 <scott> if it's in the where ... part it needs to be referred to outside of it
01:37:44 <ski> is there a "summandshelper" ?
01:37:51 <scott> oh
01:38:06 <ski> i thought there only was : summands, summands', helper
01:38:06 <scott> I thought you were defining a new helper called summandshelper
01:38:12 <ski> ah, no
01:38:14 <scott> heh
01:38:42 <ski> (mayhaps i forgot some space when typing ..)
01:39:07 <ski> does it go through husg/ghci now ?
01:39:23 <scott> the syntax is funky...I have helper = blah blah
01:39:35 <ski> not
01:39:36 <scott> but you told me to write a guard
01:39:42 <scott> under it
01:39:43 <ski> yes
01:39:55 <ski> well one could also write it like
01:40:09 <ski> helper startnum | startnum < oldStartnum = []
01:40:14 <ski> it's the same
01:40:38 <ski> ok ?
01:40:39 <scott> but where is that in relation to
01:40:42 <scott> helper 0 = [replicate len 0]
01:40:42 <scott> 		helper startnum = (map (startnum :) (summandsa startnum (len - 1)                                              (sum - startnum))) ++ (helper (startnum - 1))
01:40:50 <ski> oh
01:41:07 <ski> well, i think that  helper 0 = [replicate len 0]  is obsolete
01:41:08 <scott> do I put otherwise and then everything I have there?
01:41:11 <ski> comment it out
01:41:12 <ski> :)
01:41:37 <ski> but the recursive case should be retained
01:42:25 <scott> ok
01:42:26 <ski> helper startnum = map (startnum :) (summands' startnum (len - 1) (sum - startnum)) ++ helper (startnum - 1)
01:43:19 <scott> that did it
01:43:30 <ski> try the examples ..
01:43:35 <ski> 1 1
01:43:37 <ski> 2 1
01:43:38 <scott> I did
01:43:38 <ski> 1 2
01:43:40 <ski> 2 2
01:44:15 <ski> what are the results ?
01:44:23 <scott> backwards, but good
01:44:23 <ski> correct ?
01:44:24 <scott> hehe
01:44:38 <scott> yup
01:45:05 <ski> well, i guess you could make startnum count upwards, instead of downwards
01:45:14 <ski> shouldn't be so hard, no ?
01:45:31 <scott> I just used reverse
01:45:35 <scott> it's fine now
01:45:44 <scott> whew
01:46:00 <ski> summands' oldStartnum len sum = helper oldStartnum
01:46:01 <ski>   where
01:46:10 <ski>   max = sum `div` len
01:46:29 <ski>   helper startnum | startnum > max = []
01:46:49 <ski>   helper startnum = map (startnum :) (summands' startnum (len - 1) (sum - startnum)) ++ helper (startnum + 1)
01:46:51 <ski> i think
01:46:54 <scott> I could do that
01:47:00 <scott> but I think summands len sum = reverse(summandsa 0 len sum)
01:47:03 <scott> was much easier
01:47:15 <ski> yeah, that should be usable too
01:47:24 <ski> *phew*
01:47:26 <scott> wow, thanks a lot
01:47:42 <ski> that actually seemed like quite a hard exercise
01:47:50 <ski> (at least the way we did it)
01:47:54 <scott> the professor admitted it, he knew it was hard
01:48:08 <scott> as I said, the rest of the assignment was a splay function
01:48:14 <scott> pretty easy
01:48:21 <ski> (perhaps Cale is laughing at us, having a much clearer and shorter solution :)
01:48:36 <ski> ok
01:48:54 <scott> thanks a bunch for helping me see the solution step by step
01:48:59 <ski> but i hope you understand how this function works, by now
01:49:03 <scott> oh yeah
01:49:06 <ski> good
01:49:30 <ski> and you've probably learned some techniques to use in other situations
01:49:37 <scott> I hope so
01:49:41 <ski> well
01:49:47 <scott> If I see you in the future, I'll let you know
01:49:49 <scott> :)
01:49:54 <ski> it was actually quite fun to help you out
01:50:09 <ski> (even if it this was a bit of hard work :)
01:50:15 <scott> I can imagine
01:50:16 <ski> scott : yeah ;)
01:50:25 <ski> ok
01:50:27 <scott> ok
01:50:31 <scott> thanks again
01:50:44 <ski> i think i'm going home to sleep by now ..
01:50:47 <ski> yeah
01:50:50 <scott> me too
01:50:53 <scott> hasta la vista
01:51:00 <ski> good dreaming, scott
03:36:58 <MMD|Studying> arrrrr
03:37:57 <MMD|Studying> If you were a Prof and part of your course was Haskell , what would you ask in a exam? ( first Haskell course)
03:39:53 <earthy> mmd: all manner of things
03:40:42 <earthy> I'd see if the student understands recursion, map, fold, pattern matching etc
03:40:55 <earthy> some adt's
03:41:02 <MMD|Studying> hmm..
03:41:46 <earthy> why, you deciding which parts you can skip? :)
03:41:51 <MMD|Studying> heh
03:42:04 <MMD|Studying> something like that I suppose
03:42:18 <MMD|Studying> actually I am deciding how far into Haskell I should venture
03:42:46 <MMD|Studying> or if I should just stick to the basics but be 100% sure I understand them
03:42:55 <earthy> stick to basics
03:43:19 <MMD|Studying> yeah , I guess I will..thx
03:43:33 <earthy> understand higher order functions though, that's Important
03:44:00 <MMD|Studying> yeah I know , my prof keeps saying that also
03:44:11 <MMD|Studying> hm..I wonder if my prof is idling here :/
03:44:25 <MMD|Studying> that would be like..weird
03:44:39 <earthy> who's your prof? :)
03:45:02 <MMD|Studying> Dr.Hinze?
03:45:30 <earthy> nope, not as far as I know.
03:45:34 <MMD|Studying> hehe
03:46:50 <MMD|Studying> Haskell is pretty cool , but I just can't imagine programming something except Mathematical manipulations on it
03:51:53 <Maddas> MMD|Studying: Maybe that is because you don't know too much Haskell 
03:53:46 <MMD|Studying> Yeah that is it , but I just like bitching around while studying
04:42:00 <shapr> yow! good afternoon people!
04:42:21 <shapr> MMD|Studying: lambdabot is bitchy too. and he's written in Haskell. and he does Mathematical manipulations too.
04:42:57 <shapr> MMD|Studying: whoa, Ralf Hinze is your prof? You're so lucky!
04:43:38 <shapr> @arr
04:43:39 <lambdabot> I heard andersca is a pirate
04:43:45 <shapr> I heard that too.
04:48:43 <earthy> @yow
04:48:43 <lambdabot> If I pull this SWITCH I'll be RITA HAYWORTH!!  Or a SCIENTOLOGIST!
04:48:50 <earthy> ewwwwww!
04:49:06 <shapr> @yow
04:49:07 <lambdabot> Look DEEP into the OPENINGS!!  Do you see any ELVES or EDSELS...
04:49:07 <lambdabot>  or a HIGHBALL??...
04:57:31 <Lemmih> Is there an easy way to change a value in a data type (return a copy of the type with only one element changed)?
05:00:37 <shapr> Lemmih: either, use a record, or match the constructor and copy everything but that one part.
05:01:23 <Lemmih> use a record?
05:01:42 <shapr> yah, have you seen the curly brace things?
05:02:03 <Lemmih> {member=m}?
05:02:29 <shapr> yah, sort of like that
05:03:02 <ibid> Lemmih: data Foo = Bar { baz :: Int, xyzzy :: String }
05:03:31 <shapr> Lunar^: that tu_sors.php still makes me laugh every few hours
05:03:33 <ibid> Lemmih: then, for x :: Foo, x { baz = foo }
05:03:41 <ibid> Lemmih: then, for x :: Foo, x { baz = 42 }
05:07:13 <Lemmih> setBaz (Bar x) v = x {baz=v}?
05:07:37 <shapr> much simpler with records
05:12:20 <ibid> Lemmih: setBaz x@(Bar {}) v = x { baz = v }
05:13:13 <ibid> Lemmih: or, if there is only one constructor, setBaz x v = x { baz = v } will do
05:55:14 <Lunar^> shapr: hehe
06:36:57 <MMD|Studying> sharp: I hope you are kidding me about Ralf Hinze
06:38:46 <MMD|Studying> or do you really know him?
06:39:26 <_rubix> Lunar^: what is that tu_sors.php ?
06:48:37 <Lunar^> _rubix: ask shapr ;)
06:50:26 * Heffaklump knows Ralf Hinze, though not particularly well
06:51:04 <_rubix> I know http://www.magane.com/Divers/Tu Sors.gif  but I haven't heard of any tu_sors.php...
06:52:15 <MMD|Studying> You seriously know him? Like seen him or are you just bullshitting me?
06:53:53 <Heffaklump> umm, yes, I've met him several times
06:54:51 <Heffaklump> http://urchin.earth.li/photopub/display?photo=/users/ganesh/banana/792&thumb=640x640 is a picture I took over four years ago
06:57:07 <earthy> what I hear of Ralf Hinze is that he's a pretty cool guy
07:09:40 <MMD|Studying> JESUS Christ you are freeking me out
07:09:55 <MMD|Studying> Can't you like call him and ask him what he will ask for in his exam on the 17th ?
07:09:56 <MMD|Studying> :d
07:12:17 <MMD|Studying> The problem with his teaching is not his problem really. It just that it's one Class , 4 hours a week and it consist of : Assebly Programming , Hardware Basics , Haskell , Java , Operating Systems , Boolean Funktions , 
07:12:20 <MMD|Studying> and some other stuf
07:12:20 <MMD|Studying> f
07:12:58 <MMD|Studying> So you go from a simple transistor to the top level programming languages in 4 months. And it all pretty detailed :/
07:14:47 <earthy> what's the ECTS rating for the course?
07:15:17 <MMD|Studying> er... no idea what that is. Not sure we even have that.. I am in Germany
07:15:30 <earthy> ECTS == European Credit Transfer System
07:15:46 <earthy> your university *will* have them, even if not generally published. ;)
07:16:08 <MMD|Studying> ow
07:16:55 <MMD|Studying> well I can find them for many things in my Uni but not for Computer Science..
07:18:11 <Maddas> Is there some overview of ratings for european universities?
07:18:39 <MMD|Studying> Could be 24 for this course..
07:19:16 <earthy> 24 ECTS? that makes on the order of 4 ECTS for each subject you just mentioned
07:19:25 <earthy> that's not *much* but it is reasonable
07:19:55 <MMD|Studying> Yeah but it's WAYYY to compact.. that's why everyone fails this one 
07:20:10 <earthy> is it the `Deskriptive programmierung' course?
07:20:39 <MMD|Studying> no It's "Informatik I/II"
07:20:56 <MMD|Studying> anyway it's complicated..
07:20:59 <MMD|Studying> so can you call him :p
07:21:12 <Maddas> Where do you look those ratings up?
07:21:26 <earthy> it isn't complicated, afaict
07:21:28 <Heffaklump> I bet Oxford doesn't do ECTS.
07:21:34 <earthy> heffaklump: I bet they do
07:21:46 <earthy> or will, soon enough.
07:22:12 <MMD|Studying> I didn't find ECTS per say but some other points that are given in my Uni , and I just guesst that the basis for our system might aswell be ECTS
07:22:21 <Maddas> per se :)
07:22:35 <Heffaklump> you forget that (a) the UK is deeply suspicious of anything European and (b) Oxford just doesn't do "standard" things like having a modular degree structure
07:22:54 <MMD|Studying> Ha! omg
07:23:05 <earthy> (all EU countries have agreed to do bachelors/masters split in higher education, and have agreed to make study credits transferable)
07:23:16 <earthy> heff: you *do* get study credits though, right? :)
07:23:20 <Heffaklump> nope...
07:23:24 <MMD|Studying> nope me neither
07:23:40 <Heffaklump> I keep hearing about this 3+2 split business, but it hasn't darkened our corner of the world yet.
07:23:47 <MMD|Studying> well now *they* do , but I started in 2000 so I am without
07:23:47 <Maddas> earthy: Oh, the credit system is stardardized (equivalent to the ECTS?)
07:24:04 <MMD|Studying> yes then I was right it is 24 points for my exam
07:24:30 <earthy> maddas: the credit system is standardized. 1 credit == 28 hours of full-time study equivalent
07:25:48 <Maddas> Ok. 
07:26:09 <Maddas> I thought that's just something some universities on a individual basis
07:26:14 <Maddas> some universities do
07:26:15 <Maddas> :)
07:26:22 <earthy> not really. ;)
07:26:39 <MMD|Studying> My Uni just changed to that system,..I still with the older system though
07:26:45 <earthy> the change was pretty rough in .nl, as we had a national credit system with 1 credit == 40 hours
07:26:53 <Maddas> Heh
07:27:11 <earthy> (and the entire financing system was built around it ;))
07:36:37 <earthy> sag mal, MakeMyDay, du meinst wohl nur Informatik II, oder?
07:37:02 <earthy> denn die ganzen Folien fuer Informatik I sprechen nicht ueber Haskell...
07:37:37 <MakeMyDay> :o earthy : Das ist die Vordiplomsklausur Informatik I/II. Also beide Vorlesungen in eine Prüfung
07:40:59 <earthy> ah, dass erklaert's 'n wenig.
07:42:06 <MakeMyDay> Ja..und das Problem ist das keiner so richtig Haskell kann , weil ziemlich viel anderes Zeug zu lernen gibt.
07:43:59 <earthy> MMD: verstehst du das Termersetzungszeug?
07:46:46 <earthy> (denn Haskell ist eigentlich nicht viel schwieriger)
07:59:16 --- mode: ChanServ set +o Heffalump
08:15:20 <MakeMyDay> earthy: ja eigentlich schon..Ich verstehe die Programme usw , ein programm aber selber zu schreiben das ist eine andere Geschichte
08:16:00 <earthy> ah. uebungssache.
08:16:47 <earthy> am wichtigsten: fuerchte dich nicht. schwierig ist es meistens nicht. mann muss nur aufpassen.
08:18:30 <earthy> time to go home
08:49:25 <malik> mhm... newtype Set a = SetI [a] ... i thought when using "newtype" you have to use an old type?
08:50:38 <malik> is there a difference to "data Set a = SetI [a]"?
08:51:04 <Heffalump> yes, strictness of the datatype
08:51:16 <malik> strictness?
08:51:18 <Heffalump> and efficiency of most implementations
08:51:28 <Heffalump> if you don't know what that is, you probably shouldn't worry about it for now
08:51:56 <malik> well i think it should
08:52:05 <malik> writing my "klausur" in the next days
08:52:22 <malik> perhaps we use another word for it... could you explain it?
08:55:06 <Igloo> case SetI undefined of SetI _ -> 5    is 5 if you define it using data and bottom (undefined) if defined using newtype
08:57:53 <malik> mhm...
08:59:29 <Igloo> Oh, no, that's not right
09:00:13 <Igloo> case undefined of SetI _ -> 5    is 5 if you define it using newtype and bottom (undefined) if defined using data
09:01:08 <ibid> uhh?
09:01:17 <malik> well doesn't help that much...
09:01:23 <ibid> the first was right, the second is not
09:01:54 <ibid> case tries to evaluate bottom because of SetI
09:01:58 <ibid> in the pattern
09:02:48 <Igloo> The first works in both cases. For newtype all the SetIs get erased and undefined matches _. For the data case it's not strict in its argument so it works.
09:03:09 * ibid tests
09:03:13 <Igloo> The second only works when the SetI from newtype gets erased. It won't match the constructor in the data case
09:04:48 <Igloo> malik: What doesn't make sense?
09:05:18 <ibid> Igloo: seem so. i seem to have misunderstood newtype :)
09:06:55 <Igloo> Ah, right. The way to think about newtype is for its constructors to only be used by the type checker, and to be thrown away before you actually do any execution
09:07:51 <malik> Igloo: i think i have to look for the bigger picture to understand it... well i dont want to bore you... seems i have to read...
09:08:00 <ibid> yeah. i knew the constructor can be erased from the run time representationm, but i did not consider that it's erased also in the semantics
09:09:19 <ibid> i had assumed that newtype is semantically equivalent to single-strict-field-data
09:10:23 <Heffalump> you can't eliminate the implicit _|_ element from a data declaration
09:10:25 <Heffalump> even if you use !
09:10:32 <Heffalump> whereas newtype just doesn't have one
09:10:45 <Heffalump> i.e. _|_ = Foo _|_ for newtype Foo = Foo Int etc
09:12:44 <Heffalump> actually, Igloo thinks that would apply to data Foo = Foo !Int too.
09:13:05 <ibid> _|_ = Foo _|_, if data Foo = Foo Int
09:13:07 <Heffalump> but he's wrong.
09:13:23 <ibid> oh?
09:13:32 <ibid> sorry, meant !Int
09:13:36 <Heffalump> actually, I'm not sure now.
09:13:39 <Igloo> Heff is misunderstanding me  :-)
09:14:21 <Igloo> data ! and newtype both have a single _|_, the difference is you can match it against Foo _ with newtype but not data !
09:14:25 <Heffalump> ok, Igloo is right.
09:14:31 <ibid> yeah
09:16:54 <Jad> shapr ther ?
09:30:17 <fyh> Can somebody explain what f, x, and y represent?  I don't understand what x and y really are:let f x y = if x > 0 then x else x * y in f (2 + 9) (f 9 2 )
09:30:54 <Lunar^> f is a function
09:31:00 <Igloo_> f is a function being defined by the let, x and y are its local variables
09:31:26 <Lunar^> x and y are two arguments   )seems to be numbers 
09:32:40 --- mode: irc.freenode.net set +o Heffalump
09:32:48 <fyh> Igloo, I know haskell is picky about "assignments" but what gets assigned what in this case? does the expression just get evaluated and the result is outputed? I'm new to haskell and things are a little bit obscure
09:34:18 --- mode: irc.freenode.net set +o Heffalump
09:35:00 <Jad> too much netsplits
09:35:00 * Heffalump gives up
09:48:36 <TripleDES> hi
10:17:22 <fyh> shouldn't this (1>0) || (1/0) be true? does this mean that || is strict?
10:17:48 <Igloo> It means it's lazy in its second argument
10:18:41 <fyh> I can't think of an example where || can be strict
10:20:12 <ibid> fyh: it's strict in its first argument (1/0==0) || (1>0)
10:21:07 <fyh> I guess I really have to go back and read about strictness
10:21:15 <fyh> thanks Igloo ibid
10:58:24 <fyh> the "otherwise" keyword in haskell is somewhat confusing. I have a comparison that yields to three different resutls but don't know how to implement it with an if expression: if (a>0> then b else c else d ?
10:58:57 <fyh> sorry that's an if(a>0)
10:59:00 <Darius> otherwise isn't a keyword.
10:59:24 <Darius> And if a is <= 0, how does it decide whether to return c or d?
11:02:15 <fyh> that's what I'm confused about. I know I can do this like f a b | a > b = 4 | a < b = 5 | otherwise = 6
11:02:50 <fyh> My if expression is wrong I guess. I just can't think of a way to implement it that way
11:03:44 <Darius> 'if' in Haskell works like 'if' in most other languages.  If you want a chain of them you go if x then a else if y then b else c
11:04:29 <fyh> I get it. thanks.
12:36:16 <ipkiss> where can i find doc about monads?
12:36:33 <ipkiss> both the mathematical theory and the practical use in haskell
12:37:26 <Darius> Wadler's papers would probably be best.  Just put "Philip Wadler" into google.
12:38:13 <ipkiss> thanks
12:41:45 <vorpal> is there a way to identify a type in haskell?  for instance i would like to specifically handle a case where foo is not an Int, instead of letting the run-time throw some type error
12:42:19 <shapr> you can pattern match on an enumerated type
12:42:49 <shapr> myFoo = myInt Int | myString String
12:43:27 <shapr> myFunc (myInt i) = show i
12:43:33 <shapr> myFunc (myString i) = show i
12:43:35 <shapr> something like tht
12:43:40 <Igloo> Capital 'm's for all but myFunc
12:43:49 <shapr> right, good point
12:43:53 <Igloo> But Haskell doesn't have runtime type errors, the type system is static
12:44:36 <vorpal> thanks =)
12:44:42 <fyh> I thought "patterns" in haskell are implemented through "case." I'm now confused after what I've read.
12:44:45 * vorpal reads on enumerated types
12:45:03 <Igloo> case matches patterns
12:45:09 <Igloo> I'm not really sure what you mean
12:47:24 <fyh> Igloo, I understand that case matches patterns but is there such a conditional way of matching patterns other than case?
12:47:35 <fyh> or if
12:48:12 <bring> @join #haskelldb
12:48:13 <lambdabot> not enough privileges
12:48:44 <Riastradh> @join #haskelldb
12:49:04 <bring> Riastradh: thanks
12:49:41 <Igloo> Well, functions do, but they're just case statements really. I don't see what you're getting at though
12:51:00 <fyh> suppose I had an if else expression that I wanted to redefine using patterns(with maybe guards). how'd you implement it?
12:51:40 <bring> f x = if g x then a else b
12:51:48 <bring> f x | g x = a
12:51:53 <bring> | True = b
12:52:07 <bring> is that what you are looking for?
12:52:26 <bring> (second two lines replace the first)
12:52:59 <Riastradh> fyh, all pattern matching devices end up expanding to case uses.
12:54:35 <fyh> Riastradh, you mean if there are many patterns to match against?
12:54:58 <Riastradh> No, I mean anywhere you use pattern matching that doesn't involve case ends up boiling down to case anyways.
12:55:20 <Riastradh> (Well, maybe not exactly, but it's close enough to the truth.)
12:55:25 <fyh> bring, thanks
12:56:03 <fyh> bring, I'm new to haskell. what's "if g x"?
12:57:06 <bring> "g x" just means "the result of applying the function g to the value of x (like g(x) in for example java or C)
12:57:20 <fyh> I understand thanks
12:57:39 <bring> the semantics are not the same, because of lazy evaluation and whatnot, but the general idea is the same
12:58:06 <Darius> Riastradh: Pattern matching is syntactic sugar for case, guards are syntactic sugar for nested if's, and if is syntactic sugar for case.
12:58:36 <Riastradh> Darius, even let is equivalent to uses of case?
12:59:09 <Igloo> It's not equivalent as let is lazy, case is strict
12:59:16 <Riastradh> See?
12:59:26 <Darius> Let is equivalent to a lazy case match. let [] = x in e == case x of ~[] -> e
12:59:42 <Igloo> And to think of ifs as being equivalent to guards you have to break function definitions up too
12:59:45 <Riastradh> And, if I'm not mistaken, there's some magic in inferring the type of let.
13:00:01 <Darius> Igloo: You'd have to do some transformations for pattern matching as well.
13:05:53 <Darius> Riastradh: I'm not sure whether the monomorphism restriction applies when using a pattern matching let.  I'm pretty sure that top-level matches are monomorphic.
13:22:50 * SyntaxNinja curses
13:22:56 <SyntaxNinja> I always forget how filter works
13:23:00 <SyntaxNinja> I always do it wrong!
13:23:24 * Darius does as well.
13:23:30 <Igloo> Wrong how?
13:23:36 <Darius> I think filter out
13:23:40 <Igloo> Ah
13:23:40 <SyntaxNinja> I think of it as "filterOut" instead of "keepOnly"
13:23:59 <SyntaxNinja> wow. my code works much better this way
13:24:01 <SyntaxNinja> muchmuchmuch
13:30:33 <Marvin--> correct code tends to work better than incorrect, most of the time
13:33:50 <andersca> hmm, I can't get this parser code to look good
13:34:16 <andersca> SimpleExpr :: { Expr }
13:34:17 <andersca> SimpleExpr : Integer { let (Int i, p) = $1 in EInt i p }
13:34:17 <andersca>            | Ident   { let (Ident i, p) = $1 in EIdent i p}
13:34:20 <andersca> that's not very cool now, is it
13:35:38 <ludde> what's that funny { } syntax? i've never seen that
13:35:44 <andersca> oh sorry
13:35:49 <andersca> it's happy
13:35:51 <ludde> oh
13:35:56 <ludde> :)
13:36:08 <ludde> you're not using bnfc?
13:36:51 <andersca> I want position info in my syntax tree
13:36:54 <andersca> which doesn't work with bnfc
14:09:36 <bring> andersca: now I see why you wanted me to write a bnf compiler :)
14:10:21 <Igloo> I suppose someone familiar with nhc98 implementation would be too much to ask for?
14:12:17 <Darius> Presumably the authors are familiar with it.
14:13:04 <Heffalump> I was talking to someone familiar with it yesterday.
14:14:45 <Darius> Igloo: If you have a particular question, you could just ask it and maybe someone will know the answer.
14:15:21 <Heffalump> it might be more effort to phrase it than it's worth if there's noone likely to know the answer around
14:15:23 <Igloo> I think it's going to turn out to be comparatively easy (it's about system returning the wrong thing, but it looks like that maps directly to a builtin)
14:20:23 <earthy> night all
19:23:13 <cmoline> you know what? i should get a tshirt with haskell on the front superimposed over its logo and "we put the funk in funktion" on the back :)
19:23:32 <cmoline> dark blue with white lettering
19:23:49 <cmoline> though maybe the lambda in a circle will be yellow or something
19:24:57 <cmoline> guess no one wants to talk :)
19:26:05 <cmoline> and i should get a tshirt for freebsd too :)
19:26:11 <cmoline> my two favorite things
19:26:11 <monotonom> But we enjoy listening.
19:26:28 <cmoline> so you want me to keep talking? :)
19:26:58 <monotonom> If you have interesting things to share, don't hesitate.
19:27:08 * cmoline is lazy
19:27:38 <cmoline> im going to start in on my category theory book but i just cant seem to get started
19:27:50 <cmoline> im going to work on my irc client instead
19:27:56 <cmoline> yes another irc client :)
19:28:22 <cmoline>  a cool feature i want to have is tab completion for long words
19:28:38 <cmoline> im not aware of any that do that
19:28:45 <Igloo> There's a script to do that from /usr/dict/words for irssi
19:28:53 <Igloo> Although not a particularly efficiently implemented one
19:28:54 <cmoline> really?
19:29:07 <cmoline> i will look at irssi
19:29:11 <Igloo> scripts.irssi.org
19:29:13 <Igloo> (IIRC)
19:29:21 <cmoline> we dont really need more irc clients do we?
19:29:28 <Pseudonym> No, we don't.
19:29:32 <Igloo> A Haskell one would be nice  :-)
19:29:36 <cmoline> though maybe we need a couple more in haskell :)
19:29:37 <Pseudonym> Someone is working on that.
19:29:42 <cmoline> theres hircules
19:29:51 <Pseudonym> That's the one.
19:29:57 <Pseudonym> I think I get the record for the first one.
19:30:05 <Pseudonym> lambdabot is technically an IRC client.
19:30:23 <cmoline> hey i know! i will see if i can collaborate with the author of hircules
19:30:24 * Igloo only knew of the above script as I've just written one to convert non-UTF-8 people's input to UTF-8 so I should have no more ugly boxes  :-)
19:30:53 <monotonom> I am used to nick completion --- type "mono", then tab, and I get "monotonom". Then one day I typed like "fun", then tab, and realized: this is just nick completion, not English word completion, it would not complete it to "function" for me. :)
19:31:24 <cmoline> yeah i should write an imp of haskell thats designed to be embedded in programs as an extension language
19:31:33 <cmoline> that would be super sweet
19:31:43 <liralen> cmo - people keep writing IRC clients because people keep writing poorly-extensible IRC clients because people keep writing IRC clients in poorly-extensible languages because people don't understand that an IRC client need only have enough speed to not annoy the user.
19:32:02 <liralen> cmo - so I wouldn't mind a nice Haskell IRC client =)
19:32:15 <cmoline> with haskell as its extension language! :)
19:32:29 <cmoline> two for the price of one ;)
19:32:40 <cmoline> though it would take me a very long time to do it
19:32:55 <cmoline> but hey think of all the cool shit i would need to learn
19:33:08 <cmoline> i would love to learn more of this stuff
19:33:14 <cmoline> programming, i mean
19:33:17 <liralen> I wouldn't mind having to recompile a Haskell IRC client for every extension -- I don't extend my IRC clients all that much, really.
19:33:35 <cmoline> hmm. well maybe just a shell escape?
19:33:50 <cmoline> i think that would be better than having to recompile your program
19:34:02 <cmoline> it would be easy to write an ffi type thing
19:34:07 <cmoline> for a shell
19:34:27 <cmoline> or no rather sorry
19:34:33 <liralen> cmo - I'd rather just use a different language, but OK.
19:35:07 <cmoline> well thats what i mean
19:35:18 <cmoline> make it availble in c too
19:35:41 <liralen> cmo - sorry, I meant "to write the IRC client in".
19:35:42 <cmoline> and then people could use their ffis in whatever language
19:36:20 <cmoline> oh. i thought we were talking about a way of extending the client
19:37:21 <cmoline> shell escape so you run commands, and the core functionality is written in c but extended with other languages
19:37:30 <cmoline> does that make sense?
19:37:38 <liralen> Indeed.  More verbosely: "Rather than proceed down the insane path of FFIs and 'extension modules' for extensions to an IRC client, I'd rather just write in a programming language with something like EVAL and READ in the first place, because that will ultimately make things more comfortable for me."
19:37:53 <cmoline> yeah
19:38:41 <stepcut`> mmm. erc.
19:38:42 <cmoline> and some way of allowing these extensions to work with other extensions written in different languages
19:38:54 <cmoline> i think the gimp does something like this
19:39:22 <cmoline> stepcut`: do you mean erc is something like what i am talking about?
19:39:42 <stepcut`> cmoline: do you know about erc at all?
19:39:46 <cmoline> nope
19:39:51 <stepcut`> emacs irc client
19:39:54 <cmoline> i dont know much about irc actually :)
19:40:17 <cmoline> oh i see. youre making a suggestion for one i could use
19:40:34 <cmoline> i hate emacs. too slow and too complex
19:40:44 <liralen> cmo - well, you can have the IRC client fork off another program and communicate to it via pipes.  Then you only need a well-defined and powerful protocol -- and, then, you only really need to write a 'thick' UI that implements that protocol and write much of the logic seperately.
19:41:19 <cmoline> thats sounds like something i can do.
19:41:31 <cmoline> can you clarify what you mean by 'thick'
19:41:32 <cmoline> ?
19:43:56 <liralen> cmoline - presumably the UI would make its own IRC connection and do its own PONGs and have its own independent windowing system and key-handling (e.g., to translate ESC[D to "keypress left-arrow")
19:44:37 <cmoline> oh. yes i see what you mean
19:44:47 <cmoline> yes it will be like that
19:45:04 <cmoline> in fact i bet i dont even have to write the c library
19:45:22 <cmoline> theres prolly a c library thats just a library out there somewhere
19:46:40 <liralen> nah.  Just have your UI communicate to N logic-clients (modules), offer them a way to manage and talk to each other, and then offer some standard modules, such as 'basic ircii commands'
19:47:30 <liralen> no, just write the UI and the protocol =)  You can provide a plug-innable intermediary if you like, later.
19:47:41 <cmoline> oh cool! so i can do the core in haskell. thanks for the suggestion lira
19:47:44 <liralen> You'll need something to know what events to send to what modules, anyway.
19:48:15 <liralen> cmo - I like the idea, too =)  Good luck with your client.
19:48:24 <cmoline> you bet
19:49:12 <cmoline> you do realize though that this protocol is going to be practically its own programming language
19:49:18 <cmoline> or am i missing something?
19:49:36 <cmoline> if its going to be as expressive as the one im imagining that is
19:52:44 <cmoline> hey i should do migration!
19:53:07 <cmoline> wouldnt that be cool? change the core library youre using without having to close your current ui?
19:53:22 <cmoline> channels would be importable and exportable
19:53:46 <cmoline> that way if one is a pos, you can fix it easy
19:54:06 <cmoline> more work than neccesary maybe, but hey its my free time :)
20:01:30 <cmoline> tab should complete anything thats completable and there should be a way to tell the client whats completable
20:01:49 <cmoline> i mean for everything
20:02:05 <cmoline> like manpages
20:02:08 <cmoline> words
20:02:31 <cmoline> gah! theres too many places where tab doesnt work and i think it should :)
20:03:54 <Lemmih> I think that would be quite irritating.
20:04:17 <liralen> cmo - since 'tab' defines an unusual key for user input, you could send it to the client seperately from normal user input, and have the protocol allow the client to ask for the current as-yet-unfinished input, the cursor location within that, etc.
20:05:35 <liralen> and I don't see why it needs to define a programming language -- it just needs to have a fairly large set of commands, with lots of tagging.
20:07:00 <cmoline> i think once you see what im trying to do youll agree with me that its a cool way to do it.
20:07:04 <liralen> e.g., you never send just "/msg cmoline hello", you send 'window: 2 text: /msg cmoline hello'
20:07:22 <liralen> or you could just use s-expressions.
20:07:24 <cmoline> right. i am going to have a core language
20:07:28 <cmoline> that has ports
20:07:34 <cmoline> and you send messages to it
20:07:35 <liralen> 'ports'?
20:08:19 <cmoline> er, objects, i guess you can call it. though i hate to use that term cause its too empty
20:08:43 <cmoline> it will be a very simple language
20:08:56 <cmoline> a program in this language will be a stream of tokens
20:09:08 <cmoline> there will be no conditional statements
20:09:13 <liralen> well, yes, you'll want to have a way to specify which window to send output to, to get information when the UI creates or destroys windows, to allow the client to know what all information a window has, get feedback in response to specific commands (maybe long after the client makes them), etc.
20:09:21 <liralen> but OK.
20:09:34 <cmoline> yes. the core protocol wont do any of that.
20:09:42 <cmoline> but it will be extensible
20:09:50 <cmoline> so you could define new protocols
20:09:54 <cmoline> and use them
20:10:10 <cmoline> the gui and the irc stuff will be libraries
20:10:36 <liralen> no, I hate this idea.
20:10:36 <cmoline> its not a programming language you would actuall want to program in :)
20:11:06 <cmoline> but its expressive enough to allow several programs to work together
20:11:09 <cmoline> over pipes
20:11:34 <cmoline> liralen: k
20:11:34 <Pseudonym> Basically, what you want is a Turing-complete scripting language, and let the user write the rest!
20:11:56 <cmoline> well i doubt my core will be turing complete
20:12:10 <cmoline> ok actually it will 
20:12:56 <cmoline> i was thinkg without a conditional you couldnt have a  turing complete language, but actually functions are all you need
20:13:05 <Pseudonym> So what you ACTUALLY want to write is a Haskell implementation.
20:13:12 <cmoline> no
20:13:12 <Pseudonym> :-)
20:13:16 <cmoline> er yes
20:13:53 <cmoline> what i mean is i want to define a simple pipe protocol that will allow my functions in my language to be implemented in any other language
20:14:08 <cmoline> does that make sense?
20:14:27 <Pseudonym> Well, yes, but I was joking.
20:14:40 <cmoline> my core wouldnt actually be used to do any implementing
20:14:50 <cmoline> its just for allowing collaboration
20:18:25 <cmoline> guess i have no sense of humor :)
20:18:25 <cmoline> basically it allows you to transport datatypes over a pipe network
21:00:56 <shapr> good morning #haskell!
21:01:06 <Pseudonym> G'day.
21:01:24 <liralen> good evening, shapr
21:02:55 <shapr> yay, Pete Gammie's PLog is up to 0.0.4
21:03:49 <shapr> http://gungnir.csbnet.se/~peteg/blog/plog.html
21:12:34 <Pseudonym> http://www.kuro5hin.org/comments/2004/2/7/144019/8872/483
21:17:57 <monotonom> hahaha
21:27:45 * isomer pokes shapr
21:27:48 <isomer> s'up man?
21:30:33 <shapr> y0 anth
21:30:40 <shapr> just installing Pete Gammie's PLog
21:30:44 <shapr> http://shapr.homelinux.net/~shae/blog/
21:30:52 <isomer> hey cool... who's that? :)
21:30:55 <shapr> what's up with you?
21:31:22 <shapr> Pete Gammie is a student at the University of New South Wales, who is currently a student in Gothenburg.
21:31:42 <shapr> hey anth, are you on orkut?
21:31:45 <isomer> trying to work on my pool game...neglecting my programming project, and getting into better shape. 
21:31:50 <isomer> yeah, i am!
21:31:59 <shapr> how can I connect to you?
21:32:40 <Pseudonym> shapr: I suggest you grep for FIXME.
21:33:11 <shapr> yes, I've just installed the example config :-)
21:33:54 <isomer> doing any cool coding lately, shae?
21:34:14 <shapr> playing with haskelldb and lambdabot. and doing some mail parsing stuff.
21:34:19 <shapr> HaskellDB is very cool
21:34:24 <shapr> oh, and I'm learning more about darcs
21:34:31 <shapr> I've started using darcs for my client projects
21:34:55 <shapr> mostly because repository synchronization is so easy
21:35:26 <shapr> it's great to be able to push, pull, choose patches, etc with so little effort
21:35:28 <isomer> oh yeah? 
21:35:33 <isomer> significantly better than cvs?
21:35:38 <shapr> *much*
21:35:50 <shapr> for example, if you're using debian you can install the darcs debs
21:35:59 <isomer> gentoo
21:36:11 <isomer> maybe there's an ebuild
21:36:20 <shapr> seems so
21:36:22 <isomer> oh, there is! it's just masked... v0.9.15
21:36:38 <shapr> one it's installed, then "darcs get http://www.ScannedInAvian.org/repos/wikiwiki" will create wikiwiki in the dir you called it in.
21:36:57 <isomer> oh, you can do it through http? that's kinda neat
21:37:05 <shapr> then make some changes (or darcs add to add a new file), and "darcs record" to save the changes, and "darcs push" to put the changes back into the repo.
21:37:16 * Pseudonym is learning the basics of GTK
21:37:25 <isomer> how about branching and merging and all that dirty stuff?
21:37:29 <shapr> darcs push uses sendmail, so you need a working sendmail installed, but it can also use ssh if you can do that.
21:37:57 <shapr> those are much less of an issue in darcs because each repo is a completely independent repository
21:38:12 <shapr> right now, the best way to fork is to just copy the repo
21:38:17 <isomer> oh i see
21:38:32 <shapr> if you decide to switch your 'canonical' repo to the fork, you just push the patches
21:39:11 <shapr> darcs has a deep theory of patches behind it that relies on commutation of patches to move patches around till they don't conflict (which is usually possible)
21:40:11 <isomer> woah
21:40:13 <isomer> that sounds neat
21:40:16 <shapr> imho, cost of entry with cvs is too high
21:40:28 <isomer> steep learning curve, yeah....
21:40:34 <isomer> how far along is darcs?
21:40:37 <shapr> cvs requires a user account on the server, you have to do lots of update, commit, etc
21:40:45 <shapr> it's far enough that I'm using it for my production source
21:41:09 <shapr> I've also found and fixed some small bugs (submitted fixes to David)
21:41:40 <shapr> the internals of darcs are really easy to browse
21:41:49 <isomer> cvs makes it hard to have a developer with only access to the repository, and no shell acct. that really sucks huge
21:41:53 <shapr> the patch commuting theory is the only scary part that I've seen
21:41:59 <shapr> yes, it does
21:42:27 <shapr> also, with darcs, if you and I check out of darcs.sourceforge.net, and sourceforge dies, we can still pull/push patches to/from each other.
21:43:05 <isomer> that's pretty handy
21:43:22 <isomer> do you think it scales to large-ish projects?
21:43:27 <shapr> I have a repository containing my Zope/Plone Archetypes sources both locally and on the client machine, so if I need to make some quick hacks on the client box, I can just pull the diffs
21:43:50 <shapr> darcs still has some speed issues when adding the linux sources to a repository, it takes many hours for that
21:44:03 <shapr> but it doesn't have those problems if you add the same sources in smaller chunks
21:44:24 <isomer> is the repository stored in a readable format, or a database?
21:44:27 <shapr> that's the only scalability problems I've seen so far.
21:44:35 <shapr> it's a readable format
21:44:40 <shapr> you can see it on my webserver
21:44:58 <shapr> http://www.scannedinavian.org/repos/wikiwiki/
21:45:04 <shapr> that's the whole wikiwiki repository
21:45:15 <isomer> nice picture, by the way... what are you holding?
21:45:22 <shapr> eh?
21:45:27 <shapr> which pic?
21:45:27 <isomer> orkut
21:45:32 <shapr> oh
21:45:46 <shapr> http://www.scannedinavian.org/~shae/foto/Image007.jpg
21:45:57 <isomer> :)
21:45:59 <isomer> nice one
21:46:03 <isomer> i agree completely
21:46:07 <shapr> :-)
21:47:08 <isomer> how did you resist using 003?
21:47:34 <shapr> if you look in the _darcs dir, the deepest magic is the patches dir http://www.scannedinavian.org/repos/wikiwiki/_darcs/patches/
21:47:47 <shapr> I think 005 is the best :-)
21:48:06 <shapr> that's the "I get paid to write Haskell" face.
21:48:58 <Cale> Hi - does anyone who is studying category theory happen to recall what a pushout in the category of topological spaces is?
21:49:47 <isomer> shapr
21:49:49 <isomer> indeed!
21:51:21 <shapr> anyways, you should check out darcs, it's really cool. With the information I have, it seems to be the best source control system yet.
21:51:56 <shapr> though I have not yet read much about monotone, codeville, or one or two of the others.
21:53:04 <isomer> i'll definitely check it out
21:53:19 <isomer> especially if it can solve the dont-want-to-give-everyone-an-account problem
21:58:27 <shapr> yes, I like that part.
23:06:33 <det> does darcs have emacs integration ?
23:08:18 <shapr> http://www.emacswiki.org/elisp/vc-darcs.el
