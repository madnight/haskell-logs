04:57:42 <amgine> D:/ghc/ghc-6.2/HSGLUT.o: unknown symbol `_glutMainLoop' 
04:57:42 <amgine> ghc.exe: panic! (the `impossible' happened, GHC version 6.2): 
04:57:42 <amgine>         can't load package `GLUT' 
04:57:42 <amgine>  
04:57:42 <amgine> Please report it as a compiler bug to glasgow-haskell-bugs@haskell.org, 
04:57:43 <amgine> or http://sourceforge.net/projects/ghc/. 
04:57:45 <amgine>  
04:57:47 <amgine>  
04:57:49 <amgine> *Main>
04:57:51 <amgine> any idea ?
04:59:04 <creature> I'd suggest you report it. 
04:59:16 <creature> Maybe to glasgow-haskell-bugs@haskell.org .
04:59:28 <amgine> this is my code maybe that's the reason
04:59:36 <amgine> import Graphics.UI.GLUT.Window
04:59:36 <amgine> test = do createWindow "test"
04:59:39 <amgine> ?
04:59:58 <amgine> it happens when i run test
05:00:06 <amgine> i mean type test at command prompt
05:16:08 <amgine> if i wish to split a long code line what is the proper indentation so haskell understands it ?
05:18:13 <Heffalump> indent the follow-on line more than the beginning of the previous line
05:18:20 <Heffalump> actually, more than that
05:18:48 <Heffalump> it needs to be more than the start of kind of thing you're entering
05:18:51 <Heffalump> so for example
05:18:58 <Heffalump> where foo = bar baz quux ...
05:19:19 <Heffalump> the continuation line needs to be further to the right than the 'f' of 'foo'
05:19:33 <amgine> hmmm i see
05:19:48 <Heffalump> maybe even the 'b' of 'bar', I can never quite remember
05:20:05 <Heffalump> someone else can probably state the rule rather more accurately :-)
05:20:06 <amgine> yep it worked :)
05:20:15 <amgine> after = sign looks good to me
05:23:32 <amgine> what module contains a function that returns the run-name filename
05:25:20 <amgine> is it possible ?
05:26:25 <amgine> is my question clear ?
05:27:56 <amgine> haskell.org is down
05:28:04 <amgine> otherwise i would be looking
05:43:25 <Igloo> Your question is not clear to me
05:43:32 <amgine> uhmm
05:43:33 <amgine> ok
05:43:37 <amgine> i compile a haskell code
05:43:45 <amgine> the name of the file let's say is foo.exe
05:43:56 <amgine> what function would return that "foo.exe" on runtime
05:44:02 <amgine> just incase the filename changes
05:44:10 <Igloo> Oh, System.somethingorother
05:44:19 <amgine> yeah i was looking in there
05:44:20 <Igloo> getProgName
05:44:24 <amgine> i'll look again
05:44:27 <amgine> ohhh crap
05:44:28 <amgine> thanks
05:45:00 <amgine> nope can't find it
05:45:17 <amgine> got it
05:45:21 <amgine> sorry i'm a numptee today
05:57:12 <amgine> i'm trying to store a binary file inside haskell code as a string any ideas ?
05:58:07 <Heffalump> you'll have to encode it somehow
05:58:15 <Heffalump> (why are you doing this?)
05:58:25 <amgine> to be honest as an exercise
05:58:38 <amgine> cause i've already stored a text file as a string (html page it was)
05:59:15 <Heffalump> I guess what you want to do is write a program to turn a binary file into a string and add a small stub for decoding it
05:59:41 <amgine> that would mean using openBinaryFile right ?
06:00:04 <amgine> because reading it as a text file dosen't work
06:01:16 <amgine> any suggestions how you would do it ?
06:01:41 <Heffalump> I would write a program that did use openBinaryFile etc.
06:01:58 <amgine> what kind of encoding would have to take place ?
06:01:59 <Heffalump> And output a Haskell module
06:02:10 <Heffalump> no idea. Go find out what characters you can get away with :-)
06:02:17 <amgine> hmm
06:02:18 <amgine> :)
06:02:23 <Heffalump> an obvious (and stupidly inefficient) one would be a string of 1s and 0s.
06:02:29 <Heffalump> More sensible would be Base64, probably.
06:02:48 <amgine> base 64 ? why ?
06:02:50 <Igloo> You can just use a string and \xxx surely
06:03:03 <Igloo> And then your decoding function is just id  :-)
06:03:15 <amgine> lgloo ?
06:03:17 <amgine> i'm lost
06:03:17 <Heffalump> igloo: oh, true. Only a factor of 4 inefficient :-)
06:03:26 <Heffalump> (and only in the source, then)
06:04:02 <amgine> lgloo i tried reading it as a string and writing it back
06:04:05 <amgine> it corrupts the file
06:05:06 <amgine> if i am not taking your time you may wish to enetratin me :) i might learn something
06:11:32 <amgine> hPutBuf :: Handle -> Ptr a -> Int -> IO  can anyone explain what this ptr a has to do with this ?
06:11:40 <amgine> i've read ptr documentation
06:11:43 <amgine> but it's confusing
06:15:58 <amgine> crap
06:16:19 <Heffalump> I think it's for dealing with blocks of memory that you have a pointer to
06:16:29 <Heffalump> unless you know why you need it, I wouldn't use it
06:17:02 <Heffalump> base 64 encoding uses 26 upper-case characters, 26 lower-case ones, 10 digits and a couple of punctuation characters to encode 6 bits in a single character
06:17:18 <amgine> cool
06:17:19 <Heffalump> I dunno if there's a library to do it
06:17:46 <amgine> but the pointer is required seems to be req for binary operations
06:17:48 <Heffalump> Igloo's suggestion is better if you don't mind your source file being 4 times the size of the binary file
06:17:50 <Heffalump> oh, ok
06:18:03 <amgine> i didn't understand what he suggested
06:18:04 <Heffalump> you presumably want hGetBuf or similar, though
06:18:30 <amgine> what did he suggest ?
06:18:31 <Heffalump> his idea what was to just put each byte of the binary file in the string by using \xxx notation
06:18:48 <amgine> what is \xxx notation ?
06:19:31 <amgine> i'm sorry if i'm asking newb questions
06:19:39 <Heffalump> "\054" is the string containing the single character 054
06:19:46 <Heffalump> (I'm not sure if that's octal, or hex, or decimal)
06:20:11 <Igloo> You can easily optimise by not doing so for a lot of character, of course. In fact you might only need \" \\ and \n
06:20:35 <Heffalump> oh, good point
06:20:37 <amgine> hmm brb
06:20:51 <Igloo> And you probably only want readFile and writeFile, although I'm not sure if they use binary mode so you might need "openBinaryFile f ReadMode" and hGetContents
06:20:54 <amgine> how does haskell understand \xxx ?
06:21:34 <amgine> so if i converted the file into \xxx and used writeFile "foo string' 
06:21:46 <amgine> it would convert those \xxx back to their proper characters ?
06:22:48 <Heffalump> yep
06:22:55 <amgine> hmmm
06:23:23 <amgine> i believe i tried something along those lines
06:23:25 <amgine> let me think
06:23:26 <amgine> brb
06:23:26 <Heffalump> the point is that it's the way you represent literal characters in Haskell source
06:23:37 <amgine> i understand that now
06:24:03 <amgine> i did this
06:24:10 <amgine> read a file using readFile
06:24:24 <amgine> and wrote it to harddrive using writefile (show foo)
06:24:29 <amgine> which worked for html page
06:24:35 <amgine> but dosen't work for binary
06:24:57 <amgine> is this what you are suggesting ?
06:25:25 <Heffalump> roughly, yes
06:25:30 <Heffalump> I don't see why it didn't work.
06:25:37 <amgine> let me try again
06:25:46 <amgine> i am preety much going to read a file and write it as it is
06:26:02 <cptchaos> amgine: in your example, is foo a String?
06:26:15 * Igloo unrelatedly fails to find anything in the HLs that does make a Ptr
06:26:15 <amgine> yes
06:26:25 <amgine> brb guys
06:26:27 <Igloo> Ah, Foreign.Marshal.Alloc
06:26:46 <cptchaos> brb?
06:27:35 <amgine> be right back
06:27:37 <amgine> yep
06:28:07 <amgine> do z <- readFile "foo.zip" ; writeFile "test.zip" z produced 1kb file
06:28:10 <cptchaos> amgine: if you write just "writeFile foo", it should work, or I am missing some thing here
06:28:14 <amgine> the original was 190
06:28:31 <amgine> when i do print z
06:28:32 <Heffalump> cptchaos: the idea was to encode it, though
06:28:35 <amgine> it has a lot of /NUL
06:28:37 <amgine> in it
06:28:53 <amgine> seems readFile reads a text file
06:28:56 <cptchaos> Heffalump: ok
06:29:07 <Heffalump> amgine: hence what Igloo said about opening in binary mode
06:29:13 <amgine> :)
06:29:18 <Heffalump> oh, so readFile won't work
06:29:24 <Heffalump> you want openBinaryFile and hGetContents
06:29:30 <Heffalump> where did I put my watch?
06:29:41 <amgine> ok brb
06:30:38 <amgine> ahhh hGetContents dosen't need that wierd Ptr a
06:30:42 <amgine> brb
06:30:56 <Heffalump> if you're only going for 30 seconds, stop bothering to say "brb" :-)
06:31:05 <amgine> lol
06:31:06 <amgine> sorry
06:31:10 <amgine> just excited
06:31:22 <Heffalump> and someone tell me where my watch is
06:31:36 <Heffalump> ahah, I found it
06:31:44 * Heffalump disappears to get coffee and possibly lunch
06:35:30 <amgine> ok hmmm
06:36:39 <amgine> hmmm test     = do z <- openBinaryFile "foo.zip" (ReadMode) 
06:36:39 <amgine>           re <- hGetContents z
06:36:39 <amgine>           writeFile "test.zip" re
06:36:46 <amgine> produces a file 2kb bigger
06:36:54 <amgine> and still corrupted
06:36:56 <amgine> any ideas ?
06:39:30 <Igloo> You probably need to write in binary mode too
06:39:37 <amgine> good point
06:45:07 <amgine> ahhh crap
06:46:05 <amgine> test     = do i <- openBinaryFile "foo.zip" (ReadMode) 
06:46:05 <amgine>           o <- openBinaryFile "test.zip" (WriteMode) 
06:46:05 <amgine>           re <- hGetContents i
06:46:05 <amgine>           hPutStr o re
06:46:15 <amgine> file is same size but still corrupted
06:47:32 <cptchaos> isnt there a hPutContents?
06:47:51 <amgine> not that i could find
06:48:02 <amgine> so i tried the next thing that made sense
06:48:43 <Igloo> How is it corrupted?
06:48:54 <amgine> when winrar opens it
06:49:01 <amgine> it says unexpected end of archive
06:49:10 <amgine> some of the files are there
06:49:34 <amgine> let me try with a normal text file
06:49:39 <amgine> i'll see the difference
06:50:30 <amgine> the original is slightly bigger
06:50:58 <amgine> ahhh
06:51:16 <amgine> it's read and wrote lazily
06:51:20 <amgine> that could be the problem
06:51:35 <amgine> since i can't access it as it says sharing violation
06:51:41 <amgine> unless i close ghc
06:51:48 <amgine> how do i flush the buffer ?
06:52:11 <amgine> got it
06:52:16 <amgine> man i am talking to myself
06:53:37 <cptchaos> does not matter since, I had a friend complaining about the haskell binary IO yersterday
06:53:59 <amgine> crap
06:54:18 <cptchaos> that was his opinion ...
06:54:36 <Marvin--> what's crap?
06:55:00 <cptchaos> the haskell binary IO, he said
06:55:17 <amgine> let me test something
06:55:32 <cptchaos> so I never used it, so i do not know ...
06:56:37 <amgine> test     = do i <- openBinaryFile "foo.zip" (ReadMode) 
06:56:37 <amgine>           o <- openBinaryFile "test.zip" (WriteMode) 
06:56:37 <amgine>           re <- hGetContents i 
06:56:37 <amgine>           hPutStr o re 
06:56:37 <amgine>           hFlush o
06:56:40 <amgine> what gives ?
06:56:58 <amgine> it still gives me a sharing voliation when trying to open the file unless i close ghc
06:57:05 <Heffalump> DYM ghci?
06:57:11 <amgine> dym ?
06:57:16 <amgine> yeah ghci
06:57:17 <amgine> yes
06:57:34 <Marvin--> what about hClose i and hClose o?
06:57:41 <Marvin--> okay, not on i, since it's semi-closed
06:57:42 <amgine> ahhh ok
06:57:48 <Marvin--> but o needs to be closed, doesn't it?
06:57:56 <amgine> yeah sorry
06:57:57 <Heffalump> yes, it does
06:57:59 <amgine> i thought flush did that
06:58:02 <Heffalump> btw, if you're using tabs for indentation, don't
06:58:05 <Heffalump> it's asking for trouble
06:58:22 <Marvin--> at least with that kind of layout, you're asking for trouble
06:58:52 <amgine> hmmm i see if i can change the settings in my editor settings
06:58:53 <amgine> thanks
06:59:39 <amgine> ok that worked
07:00:41 <cptchaos> hm, i still think, haskell binaryIO is still better, than in C 
07:01:22 <cptchaos> maybe the behavoir of readFile and writeFile is a little confusing
07:02:14 <Heffalump> they're not intended for binary stuff
07:02:32 <amgine> yes so it seems 
07:02:52 <amgine> ok doing (show re) converts it into /xxx right ?
07:02:57 <cptchaos> yes, I know, I guess he run into the same troubles as amgine
07:03:38 <amgine> YES
07:03:40 <amgine> it worked !!!
07:03:43 <amgine> wheew heee
07:03:45 <amgine> you guys rule
07:03:57 <amgine> now the zip file even though roughly 4 times bigger is stored as a string
07:04:00 <amgine> i just wrote that string
07:04:04 <amgine> and got the original file :)
07:04:06 <Heffalump> is it actually 4 times bigger, OOI?
07:04:13 <amgine> less
07:04:15 <Heffalump> I'd have thought show would be sensible about what it encoded
07:04:25 <amgine> not all characters need to be represented as /xxx
07:04:25 <Heffalump> (in the way Igloo pointed out, roughly)
07:04:38 <amgine> smart guys you are
07:04:53 <amgine> some are plain text withing the zip file
07:05:10 <amgine> cool you guys rule
07:05:27 <amgine> thanks Heffalump and logloo
07:14:53 <amgine> YES SHE WORKS
07:15:47 <amgine> under what module is the random number generator ?
07:20:12 <Marvin--> there is a System.Random module, I think
07:20:21 <amgine> yeah i got it
07:39:03 <amgine> how can i instruct ghc to compile for size, and have the file striped already ?
09:10:02 <Leimy> Is "The Haskell School of Expression: Learning Functional Programming through Multimedia" a pretty good book on learning Haskell ?
09:11:47 <SyntaxLaptop> Leimy: I liked it.
09:11:56 <SyntaxLaptop> I learned from that + the gentle introduction.
09:12:09 <Leimy> ok
09:12:16 <Leimy> http://www.amazon.com/exec/obidos/tg/detail/-/0201342758/ref=pd_bxgy_img_2/103-1431517-8436636?v=glance&s=books
09:12:20 <Leimy> that one got some pretty bad reviews
09:12:31 <Leimy> I am wondering if it's any good or these people are just not into FP
09:12:59 <ski> Leimy : i learned from "The Craft Of ..."
09:13:22 <Leimy> ski: according to some folks that book sort of breezed over the Monad topic
09:13:32 <Leimy> is that your opinion
09:13:33 <Leimy> ?
09:13:41 <Lunar^> Leimy: It is a really good book
09:13:53 <Leimy> Amazon has a "get them both" deal
09:13:57 <Leimy> that's why I ask :)
09:14:00 <Lunar^> Leimy: The graphical part is interesting but takes too much place IMHO
09:14:18 <ski> hmm
09:14:21 <Leimy> in the multimedia book?
09:14:29 <Lunar^> Leimy: In Hudak's
09:14:33 <Leimy> yeah
09:14:41 <Lunar^> But it cover most interesting aspect
09:14:43 <Leimy> I think he did that to make it seem more "fun" or something :)
09:14:48 <Lunar^> Even if the last part is now outdated by arrows
09:14:57 <Leimy> and to show you that you can do real stuff in Haskell 
09:15:53 <Lunar^> Sure you can
09:15:59 <Lunar^> hOp can now handle interrupts :)
09:16:07 <Leimy> :)
09:16:07 <ski> Leimy : i had a hard time of stopping reading "The Craft ..." at bedtime's :)   but then, that's me :)
09:16:19 <Leimy> ski: Well I am sort of the same way
09:16:24 <Leimy> I just like programming languages
09:16:53 <SyntaxLaptop> Leimy: I don't think the "get them both" thing is actually a deal as in, it's not cheaper
09:17:00 <Leimy> SyntaxLaptop: sometimes that's the case
09:17:07 <Leimy> sometimes it costs more :)
09:17:09 <SyntaxLaptop> heh
09:17:33 <SyntaxLaptop> Leimy: they're both good books. a friend of mine had "craft" and I had "SOE".
09:17:41 <SyntaxLaptop> I've read craft also for some topics.
09:17:50 <SyntaxLaptop> I found craft to be a better "reference" type books
09:17:58 <Leimy> that's cool
09:18:09 <SyntaxLaptop> SOE is a little tough if you don't follow along and build the tools while you're going. it all builds on itself, so it's sorta a better tutorial
09:18:28 <SyntaxLaptop> you'll learn haskell either way. I wouldn't buy both :)
09:18:44 <SyntaxLaptop> if you like shapes and pretty colors, you should buy SOE
09:18:56 <Leimy> hehe :)
09:19:18 <Leimy> that's cool though
09:19:55 <Leimy> damn bookpool has Haskell School of Expression out of stock but for 23.95
09:20:42 <Leimy> I found a bunch of haskell books for a good deal there that are all out of stock :P
09:21:22 <Lunar^> They're both pretty old now
09:21:26 <Heffalump> SyntaxLaptop: any chance of your company opening an UK branch? :-)
09:21:29 <Leimy> yeah
09:23:21 <Leimy> anyone know of any editors that are written in Haskell?  Or is something that I/O intensive difficult to do in the language?
09:23:28 <earthy> Proxima
09:23:35 <Heffalump> editors aren't particularly IO intensive, are they?
09:23:50 <Heffalump> as in they don't need really efficient IO
09:23:53 <Leimy> user inputs into buffer... buffer saved to disk... disk read into buffer :)
09:24:06 <Leimy> well... no not... high performance I/O :)
09:24:09 <earthy> ummm.. editors are almost completely I/O, right?
09:24:16 <Leimy> just decent asynchronous IO
09:24:36 <SyntaxLaptop> Heffalump: I wish!  some day maybe, not in the short term.  mark is from the UK (as I mentioned yesterday) and we talk about it sometimes.
09:25:01 <Heffalump> but he was able to get a US security clearance?
09:26:48 <SyntaxLaptop> no, he doesn't have a clearance
09:26:53 <Heffalump> ah, right
09:27:09 <Leimy> the closest I've ever gotten to doing any sort of functional programming is playing around with FACT! in C++ and that's not quite there :)
09:27:24 <Leimy> functional programming on the job that is :)
09:41:57 * themaximus is away (Moo.), 
09:42:09 <ski> @moo
09:42:24 <ski> lambdabot is also away, it appears
09:42:33 * themaximus is away (Moo.), 
09:42:41 <Heffalump> themaximus: stoppit
09:44:21 <themaximus> I'M SORRY!
09:44:25 <themaximus> Bersirc's gone bersirc!
09:44:27 <themaximus> *berserk
09:44:35 <themaximus> Has it stopped?
09:44:53 * themaximus is back (Moo.) gone for 1 min 36 secs
09:45:13 <Heffalump> well, you've stopped quitting and rejoining :-)
09:46:25 <themaximus> Yeah, It's back to normal
09:46:31 <themaximus> I am really sorry about that.
09:46:45 <Heffalump> s'ok :-)
09:47:09 <themaximus> For some reason, all of a sudden all my scripts kicked in. Kinda kewl :)
10:05:00 <ski> themaximus : was that your client exiting, or you ?
10:05:15 <themaximus> Me.
10:05:23 <ski> mhmm
10:12:02 * themaximus is away: Lunch
10:17:25 <ski> hello maihem
10:17:43 * Heffalump wonders where shapr is
10:29:16 <tooki> hello, does ne1 know how to make usage of lists faster ?
10:29:38 <Heffalump> yes, use a faster computer
10:29:48 <tooki> mmkay
10:29:50 <ski> who is "ne1" ?
10:30:00 <maihem> hello ski
10:30:01 <Heffalump> more helpfully, use an array
10:30:02 <tooki> -an - y - one
10:30:18 <ski> or, don't copy it so much
10:30:32 <tooki> shall i use the 'listarray' function ?
10:30:49 <ski> tooki : what are you trying to do/have problems with ?
10:30:53 <tooki> or shall i access it by the '!' operator ?
10:31:26 <tooki> for instance i programmed a merge_sort-function
10:31:54 <ski> listArray is one way to *create* arrays, ! is used for *accessing* arrays. they are not exclusive :)
10:32:04 <tooki> it is very slow and stack-hungry
10:32:14 <ski> with lists ?
10:32:19 <tooki> yes
10:32:45 <tooki> because the lists have to be accessed recursively
10:32:45 <ski> and you don't do the usual beginner mistakes of copying too much ?
10:33:02 <tooki> probably i do ?!?
10:33:06 <ski> (or accessing in a bad way :)
10:33:53 <Cale> Perhaps paste your code at http://www.haskell.org/hawiki/HaskellIrcPastePage
10:33:53 <ski> perhaps you can describe what you do (e.g. paste the code here, if it's short. or give an URI to it)
10:33:58 <ski> right
10:34:37 <tooki> merge cmp (a:as) (b:bs) = if (cmp a b) then a : merge as (b:bs) else b : merge (a:as) bs
10:34:52 <tooki> this is a helper function
10:36:01 <tooki> mergesort xs = let n = length xs `div` 2;(a,b) = splitAt n xs in merge (mergesort a) (mergesort b)
10:36:01 <ski> (you need to pass cmp on. but you perhaps do that in your real code. use copy-and-paste !)
10:36:12 <tooki> yes
10:36:23 <tooki> i dont have the orig. code here
10:36:27 <ski> ok
10:36:58 <tooki> i also left out the conditions that end the recursions
10:37:02 <ski> mm
10:37:22 <tooki> i dont know how to do it quicker
10:37:43 <ski> hmm, i think it is a bit bad to recompute the length, all the time
10:37:52 <tooki> there is a function that get a list out of an arry
10:37:52 <ski> (i don't know *how* bad)
10:38:04 <ski> you could perhaps use
10:38:17 <ski> split [    ] = ([],[])
10:38:36 <ski> split (a:as) = (a:as1,as0)
10:38:38 <ski>   where
10:38:43 <ski>   (as0,as1) = split as
10:39:11 <tooki> thats better to enhalf a list ?
10:39:31 <ski> hmm, perhaps a bit better, anyway
10:39:40 <tooki> i still think, its the recursions that make things slow
10:39:43 <ski> i'm not sure if this makes the sort stable, though
10:40:10 <tooki> as i can see, it doesnt break stability
10:40:20 <ski> the recursions in merge-sort (and quick-sort) are part of what makes it fast(er than linear sorting methods)
10:40:46 <tooki> but the merge-function is also recursive, and thats the point
10:41:28 <ski> yeah, but that should be ok, i think  (tail-recursion, or stream-like behaviour)
10:41:50 <tooki> could the compiler eliminate (if possible) recursion if i passed the list through an array before sorting
10:42:20 <ski> hmm, i think merge is already effectively a loop to the compiler
10:42:55 <tooki> but in c its much faster by several times
10:42:59 <ski> you could try an bottom-up merge, also. (instead of top-down, as you're doing)
10:43:04 <ski> hmm
10:43:12 <SamB> tooki: only times?
10:43:14 <tooki> i also thought of that
10:43:57 <tooki> i meant c is several times faster
10:43:58 <ski> anyway, the recomputation of the length is unecessary
10:44:16 <ski> you could pass half the length to the next recursions, i think
10:44:38 <ski> (i.e. only computing the length at the top-level call)
10:44:55 <ski> or, you could do something like my split function
10:45:00 <ski> or, you could use arrays
10:45:40 <ski> hmm ?
10:46:25 <ski> have you tried any of that ?
10:46:30 <SamB> well, if its only times, maybe you should just tell the compiler to create optimized versions for a few types?
10:47:01 <tooki> i think lengrth is a builtin, and thus it simply reads out the length from a builtin field
10:47:15 <SamB> heh
10:47:20 <tooki> length should be executed in const. time
10:47:36 <ski> SamB : probably optimised to the (<=) instances in Ord, for those types then, also.
10:47:54 <ski> no, length takes time linear in the size of the list
10:48:06 <tooki> shure ?
10:48:10 <Heffalump> for lists, yes.
10:48:10 <SamB> ski: yeah, probably
10:48:13 <ski> (at least i think it does)
10:48:15 <Heffalump> for arrays, it probably is constant time
10:48:33 <ski> e.g. what would length of [0..] be ?
10:48:44 <SamB> ski: _|_
10:48:54 <ski> or length of the string given by getContents ?
10:49:21 <ski> SamB : yes, i know
10:49:28 <tooki> but i think haskell list must be organized in some way, e.g. like c++-lists, and thus they should contain a (record-)field that contains the length
10:49:49 <ski> data [a] = []  |  a : [a]
10:50:09 <tooki> ok i understand - lazy eval.
10:50:10 <Cale> Haskell lists are constructed recursively. They can have infinite length.
10:50:26 <ski> probably no length-field, unless the compiler does some tricks or are optimising it very much/good :)
10:50:54 <tooki> yes, thats what i hoped
10:51:30 <SamB> tooki: well, you can have strict lists of this kind. see Lisp
10:51:44 <tooki> ok but even linear length-computation should slow down it like that
10:52:20 <ski> becuause these are lazy lists (so ":" doesn't force it's list argument), then a hypothetical length-field would probably have to be lazy, and only force the list-tail when itself got forced
10:52:34 <tooki> mergesort xs = let strictxs =  (id $! xs) in ...  ???
10:52:44 <SamB> ski: it would only work with Nats ;-)
10:52:52 <Heffalump> id $! xs won't make the entire list strict
10:53:01 <tooki> how then ?
10:53:03 <Heffalump> it only forces it to be in head-normal form
10:53:11 <Heffalump> there's a "DeepSeq" module, but you probably don't need it
10:53:15 <SamB> or not. 
10:53:19 <ski> SamB : of course it would give _|_, for infinite and (partially) defined lists
10:53:21 <tooki> map (id $!) xs ?
10:53:24 <Heffalump> I haven't been paying much attention, but I don't see what your actual problem is
10:53:44 <Heffalump> the map would be lazy
10:54:04 <tooki> how do i make the whole list strict ?
10:54:24 <ski> e.g. DeepSeq
10:55:09 <tooki> sometinhg different : how do i include the nick-name of someone in my answeres ?
10:55:34 <ski> or perchance "foldr (\x xs -> xs `seq` (x:xs)) [] someList"
10:55:52 <tooki> ok ill try that
10:55:53 <ski> tooki : e.g. like this, i suppose
10:55:58 <tooki> yes
10:56:08 <Heffalump> tooki: just type it
10:56:40 <tooki> i thought there would be a trick with 'mirc'
10:56:58 <ski> tooki : i'm not sure, though, that you really need to force the list ...
10:57:07 <Heffalump> my IRC client auto-completes
10:57:10 <Heffalump> tooki: foo
10:57:15 <ski> some irc clients has auto-completion of nicks
10:57:19 <Heffalump> I got that by typing "too: foo"
10:57:27 <tooki> Heffalump : i implemented a merge_sort, but it is about 10000 times slower the in c++
10:57:29 * themaximus is back (Lunch) gone for 45 mins 25 secs
10:57:36 <ski> Heffalump : with or without a tab ?
10:57:41 <Heffalump> without
10:57:52 <Heffalump> I prefer prefix-completion to tab-completion, for IRC
10:57:57 <ski> tooki : oh, that is slow, i suppose
10:58:00 <tooki> mirc works with 'tab'
10:58:03 <Heffalump> though I could tab-complete if I wanted to
10:58:47 <ski> Heffalump : why do you prefer that ?
10:59:02 <Heffalump> dunno. Habit?
10:59:18 <ski> Heffalump : is it much different ?
10:59:25 <ski> ok
10:59:28 * themaximus is away: Outside
10:59:28 <Heffalump> not a huge amount. It's just what I'm used to.
10:59:48 <tooki> i'm using lists, which can only be accessed recursively. and i think the compiler cannot convert end-recursion to iterative-code
10:59:57 <ski> tooki : how big lists are you trying ?
11:00:08 * SamB likes the name "Deforestation: Transforming programs to eliminate trees"
11:00:23 <tooki> 65000 is the maximum, and this take a few seconds
11:00:39 <tooki> in c it takes a few microdseconds ;)
11:00:40 <ski> compilers for functional programming languages usually can convert tail-recursion ("end-recursion") to iterative code
11:01:03 <ski> (though it's not exactly the same, if we have laziness)
11:02:13 * ski realized yesterday that "deforestation" also could mean something about cutting down large forest areas (e.g. rain forests)
11:02:24 <tooki> again my function : merge (a:as) (b:bs) = if a < b then a:merge as (b:bs) else b:merge (a:as) bs
11:02:27 <Heffalump> yes, it means exactly that in normal usage :-)
11:02:46 <Heffalump> I think at the time Wadler wrote his paper, that was a very big issue
11:02:48 <tooki> do you think i should make the lists strict before
11:02:57 <_Codex> I like trees.
11:02:57 <Heffalump> (now it's been somewhat eclipsed by global warming)
11:03:38 <_Codex> function composition (.) on trees is very neat.
11:04:05 <ski> tooki : hmm, i think that merge is quite ordinary-looking (i.e. i don't see much that could be improved)
11:04:21 <SamB> you don't need tail recursion to save stack when recursively building a list in a lazy language, because you have a free trampoline
11:04:21 <ski> tooki : are you compiling or not ?
11:04:40 <tooki> i do not ;)
11:05:01 <SamB> if you just run it in hugs or ghci, of course it will be slow
11:05:02 <ski> SamB : right (see "though it's not exactly ...")
11:05:12 <tooki> but the interpreter should also recognize tail-recursion
11:05:13 <SamB> yes ;-)
11:05:45 <ski> tooki : i think hugs can recognize root-optimisation, but i'm not sure about tail-recursion
11:05:57 <tooki> im not sure, but the compiled code is also slow (i think i compiled it once)
11:05:58 <ski> tooki : do try compiling it ! :)
11:06:15 <SamB> it does
11:06:20 <SamB> Prelude> let x = x in x
11:06:20 <SamB> *** Exception: <<loop>>
11:06:46 <ski> SamB : which hugs ?
11:06:55 <tooki> can the compiler optimize for tail-recursion, only if i specialize the function?
11:07:07 <ski> that shouldn't affect it, i think
11:07:16 <SamB> er, I was refering to "the interpreter"
11:07:18 <tooki> or can it also optimize the polymorphic function ?
11:07:23 <SamB> that is actually ghci 
11:07:31 <ski> SamB : thought so :)
11:07:38 <bring> stupid C
11:07:52 <SamB> tooki: yes, of course it can optimize tail recursion in a polymorphic function
11:08:01 <tooki> that would be nice
11:08:56 <ski> SamB : (though, perhaps, it could use some "tail-rec.-modulo-cons" at times, if more monomorphic. dunno if that would help here, though)
11:09:16 <bring> I happened to have a local function connect() that I had forgot to make static. I couldn't figure out why it kept it getting called twice, when I olny called it once
11:10:30 <bring> turns out the linker somehow mistook my connect() for a connect() that it was looking for in a dynamically linked odbc driver, and so when my connect() called SQLConnect(), it called connect()
11:10:36 <tooki> would this help : let xs = (elems . listarray (...,..)) ys in mergesort xs ???
11:10:44 <bring> I'm glad I don't code in C every day
11:10:49 <tooki> where ys is to be sorted
11:11:17 * bring is talking to himself
11:11:23 <bring> sorry about that
11:11:44 <ski> tooki : how would that help ?
11:12:13 <ski> bring : no problem, we all do, at times  (or is that just me ? :)
11:12:41 <tooki> if the list is passed through an array, maybe the compiler knows (?!) more about the list, or maybe it can treat the list like an array ?!?
11:12:44 <SamB> when I talk to myself on IRC, its usually only because nobody else answers me
11:12:47 <ski> that would convert ys to an array and then back to a list xs
11:13:14 <Heffalump> I doubt it would.
11:13:17 <Heffalump> help, that is.
11:13:29 <ski> SamM : same. (or i'm really tired :)
11:13:32 <bring> SamB: sounds reasonable, there are easier ways to get a message across to oneself than to type it
11:13:35 <tooki> if the compiler knows that the list comes out of an array, maybe this mitght help
11:13:44 <Heffalump> I very much doubt it would.
11:14:03 <ski> bring : saying to to oneself ? singing it ?
11:14:11 <bring> thinking?
11:14:19 <SamB> tooki: if you were to write the algorithm based on arrays, that might help.
11:14:20 <ski> that doesn't always help
11:14:24 <bring> true
11:14:37 <SamB> dunno
11:14:47 <ski> sometimes, one need to formulate it more clearly, in some language
11:14:53 <bring> someone here called it the "tell your grandma" debugging method
11:15:16 <tooki> but i cannot code a for-loop over the array, and thus i have to code a recursive loop again
11:15:28 <SamB> what exactly are you using this sort for?
11:15:56 <ski> tooki : hmm, you mean it might magically convert your internal lists to arrays, and just convert back to a list, on the end of all of it ?? :)
11:16:14 <SamB> ski: is that what array fusion does?
11:16:25 <tooki> nothing special. if i get it executing more quickly, i might use it someday
11:16:37 <tooki> ski:yes
11:16:43 <SamB> tooki: it helps to have a use case before optimizing!
11:16:45 <ski> SamB : i'm not sure if that's included in array fusion.  maybe list-array fusion ?
11:17:28 <ski> tooki : hmm, anyways i think you must do some -O option or something to get fusion  (is this correct ?)
11:17:38 * SamB wonders how tricky an array-based quicksort would be in haskell
11:17:39 <tooki> ok ill email to the developers about this
11:18:22 <ski> tooki : you can code an accumulator-loop, which is more or less a while-loop, IIANM
11:18:27 <tooki> i will try compiling this with the -O2 option
11:18:36 <SamB> there is -O2?
11:18:52 <ski> think so
11:18:58 <tooki> i was wondering what the accumulate-function woulöd be good for ;)
11:18:58 <ski> look in ghc docs
11:19:10 <tooki> yes, i tried it
11:19:24 <tooki> there is a -O2
11:19:32 <ski> accumulator-loops is a programming 'style' !
11:19:45 <Heffalump> tooki: email the Haskell mailing list, not the developers
11:20:09 <tooki> Heffalump: do i have to register first ?
11:20:54 <SamB> tooki: do you want to see the answers?
11:21:04 <tooki> ski : is this an ensured way to create iterative code ?
11:21:28 <ski> tooki : though, perhaps you might be able to use accum and accumArray  (i'm not sure)
11:21:29 <tooki> im not familiar with mailing-list 
11:23:09 <ski> hmm, i think, if you don't decide what to return until base-case-time, then surely the compiler could do all of the loop directly, and thusly it'l be like iteration, in the machine-code ?
11:23:21 <ski> like
11:23:35 <ski> foo ..nonBaseCase... = foo ....
11:23:49 <ski> foo ..baseCase.. = ..returnSomething...
11:24:24 <ski> where the non-base-case can of course use if and let before calling itself
11:24:40 <ski> (and guards and where)
11:25:18 <Heffalump> tooki: I think you need to subscribe, yes
11:25:21 <tooki> i read about xilinx using haskell to develop FPGA's. But the must need much computation power. So do they use other compilers, or do the use better programming techniques ?
11:27:31 <tooki> actually I'm multiplying huge DNF's (boolean algebra). I have it working in c++, and i consider implementing it in haskell. But for this reason must become VERY fast
11:27:51 <ski> what's DNF ?
11:27:58 <tooki> the mergesort must become very fast ;)
11:28:32 <Heffalump> use a BDD instead :-)
11:28:42 <Heffalump> DNF = Disjunctive Normal Form
11:28:48 <ski> Heffalump : what's BDD ?
11:28:51 <tooki> right
11:29:06 <ski> oh
11:29:08 <Heffalump> Binary Decision Diagram
11:29:17 <Heffalump> much more efficient on average but harder work to implement
11:29:42 <tooki> is this a programming techinqe ?
11:29:53 <Heffalump> no, it's an alternative representation of a boolean formula
11:30:28 <tooki> i believe bdd to be recursive also, isnt it
11:30:35 <Heffalump> sorry?
11:30:43 <SamB> tooki: I don't think so...
11:31:16 <tooki> i know about BDD, but i dont know if can use it
11:31:34 <tooki> is multiplications of 2 BDD's faster ?
11:31:44 <Heffalump> YM conjunction?
11:31:50 <Heffalump> Almost certainly
11:31:56 <Heffalump> I don't know of any Haskell implementations, though.
11:31:59 <tooki> please excuse my missprints 
11:32:15 <Heffalump> It's complicated by the need to use pointers and to garbage collect the BDD node table.
11:32:22 <ski> tooki : typos
11:33:04 <tooki> i wrote a solver for boolean equation-systems
11:33:18 <SamB> so you would need the ST Monad?
11:33:57 <Heffalump> samB: probably, yeah
11:34:11 <Heffalump> tooki: aren't there really highly tuned SAT solvers out there already?
11:34:39 <tooki> it can allready retrieve the 2 prime-factors of a product of 2 primes 
11:34:45 <SamB> I got an 800 on the math SAT ;-)\end{joke}
11:35:05 <Heffalump> tooki: in constant time?
11:35:09 <tooki> i'm just experimenting
11:35:26 <ski> Heffalump : :)
11:35:28 <tooki> of course in const. time \end{joke}
11:36:06 * Heffalump can factorise large prime numbers in constant time.
11:36:20 <_Codex> he probably forgot to say it only works for primes less or equal to 1.
11:36:27 <Heffalump> My algorithm is incorrect for composite numbers, sadly.
11:36:38 <ski> _Codex : i.e for no primes ?
11:36:47 <tooki> my sat-generator is implemented in haskell using the State-Monad allready, as it doesnt take much time to create such a problem
11:36:55 <SamB> Heffalump: use a quantum computer!
11:37:06 <Heffalump> wouldn't that still be log-time?
11:38:06 <SamB> Heffalump: well, keep them all at the same order of magnitude or something!
11:38:22 <tooki> well, i cannot stop my quantum-computer opening gates to other universes, and thus it should be more save for me to use my ordinary PC
11:38:49 <SamB> tooki: I thought the idea was to run the calculation in as many universes as possible?
11:39:02 <bring> didn't Bill Gates say something about the diffculty of "factoring large primes"?
11:39:27 <tooki> thats what confunses nature, thus scrabbling everything up
11:39:28 <SamB> bill gates isn't the only one not to realize how silly that is
11:39:58 <tooki> didnt he say something of 640KBytes being enough for anyone ?
11:41:04 <bring> he's widely thought to have said something like that, but I think he denies ever having said it
11:41:18 <Heffalum1> gah
11:41:50 <SamB> its nothing to be ashamed of having said.
11:42:05 <ski> Heffalum1 : there's more of you ??
11:42:20 <bring> otoh, if you don't know that it is a prime, factoring is just as hard as any other large number, right?
11:42:44 <bring> harder even
11:42:45 <SamB> bring: harder, probably
11:42:46 <ski> not if it just has to work for primes
11:43:10 <bring> ski: well, the premise was that you didn't know if it was a prime number :)
11:43:18 <tooki> u can decide if its n polinomial time
11:43:31 <Heffalum1> the place my client is lost net connectivity briefly
11:43:45 <Heffalum1> my client thinks it lost the connection, but the server hasn't noticed yet
11:43:47 <ski> bring : but, do we allow to alg. to answer worngly, if the input is composite ?
11:44:10 <bring> that would be a little silly, wouldn't it?
11:44:16 <bring> factor x = [x]
11:44:27 <Heffalum1> yes, that was my original point
11:44:29 <tooki> Heffalum1 : maybe your client has more computaional power that the server ?
11:44:42 <Heffalum1> I wish the server would notice it's gone
11:44:43 <ski> bring : that's what Heffalumps alg. did :)
11:45:03 <bring> yes, that's why I thought allowing that would be silly :)
11:45:21 <ski> yes, that was the point, no ?
11:45:33 <bring> yes
11:45:53 <ski> do we not realize that we are in agreement ?? (are we in agreement ?)
11:45:59 <tooki> bring : oops
11:46:06 <bring> I think so, yess
11:46:14 <bring> tooki: ?
11:46:39 <tooki> i accidently invited you, didnt i ?
11:46:56 <tooki> i think the server got it
11:47:18 <bring> tooki: I didn't see anything
11:47:40 <tooki> i doubleclicked your nick, and a window came up
11:48:01 <Heffalump> that just means that anything you typed into it would have been msged to him
11:48:03 <SamB> prop_factorPrimeWorks = forAll primeGen \n -> all prime (factorPrime n)
11:48:13 <Heffalump> since you presumably didn't type anything, it didn't matter
11:48:24 <ski> tooki : i seems that a simple accumulator-factorial gets turned into a iterative loop with ghc ..
11:48:25 <Heffalump> samb: :-)
11:48:48 <SamB> okay, somebody write primeGen so I can test ;-)
11:48:53 <tooki> paste the code ?
11:49:03 <ski> which ?
11:49:12 <tooki> the accumulater-thingy
11:49:12 <ski> haskell, or assembler ?
11:49:19 <tooki> haskell 
11:49:20 <ski> it's a bit large
11:49:24 <ski> ok
11:49:29 <ski> the haskell isn't large
11:49:36 <tooki> i assumed that ;)
11:49:40 <ski>   fact :: Int -> Int
11:49:40 <ski>   fact = loop 1
11:49:40 <ski>     where
11:49:40 <ski>     loop :: Int -> Int -> Int
11:49:40 <ski>     loop a 0 = a
11:49:41 <ski>     loop a n = loop (a*n*1234) (n-4321)
11:49:50 <SamB> ski: you said it wasnt large!
11:49:54 <Heffalump> primes = map head $ iterate sieve [2..] where sieve (p:ns) = filter (\n -> n `mod` p /= 0) ns
11:49:56 <ski> note : 1234,4321  just to find it easier in the asm
11:50:05 <Heffalump> should be an easy matter to make primeGen from that :-)
11:50:07 <ski> SamB : it wasn't !
11:50:12 <ski> SamB : :)
11:50:54 <tooki> Heffalump : this consumes too much memory for large primes. e.g. i used a stochastic algo
11:51:27 <Heffalump> that's a minor detail.
11:51:59 <tooki> ski : and this is compiled into iterative code ?
11:52:31 <ski> yeah, with "jmp" and "jne"
11:52:37 <tooki> Heffalump : right, just concering the rec. vs. it. - problem
11:53:24 <ski> (the relevant asm part is about 3 times larger than the haskell code above)
11:53:30 <ski> (in lines)
11:53:49 <tooki> ski : asm's not neccessary
11:53:56 <ski> good :)
11:54:24 <tooki> and it constructs an infinite list ?
11:54:32 <ski> fact ?  no
11:54:47 <ski> it doesn't use lists at all
11:54:49 <tooki> actually i dont understand it 
11:54:55 <tooki> right
11:55:15 <ski> you could change "fact = loop 1" to "fact n = loop 1 n", if you like
11:55:32 <tooki> thats better to read 
11:56:17 <ski> it just initializes an accumulator with 1, and starts iterating downwards on n, multiplying into the accumulator, and lastly returns it
11:56:43 <ski> (so read "loop a n = loop (a*n) (n-1)", instead :)
11:56:54 <tooki> ok i got it
11:57:33 <tooki> how about making the function polymorphic ?
11:57:44 <ski> i haven't tried
11:57:54 <tooki> then dont compiler it to assembler, but to c-code
11:58:00 <ski> you mean (type-class-) overloaded ?
11:58:15 <tooki> fact :: Num a => a -> a
11:58:19 <ski> right
11:58:42 <tooki> fact a n = loop a n
11:58:51 <tooki> fact :: Num a => a -> a -> a
11:59:16 <tooki> fact a n stop = loop a n stop
11:59:49 <tooki> loop a n = if n == stop then a else loop (a*n) (n-1)
12:00:19 <tooki> this should make it ploymorphic
12:00:36 <ski> (hmm, the c code is more unreadable :(, to me at least)
12:01:04 <ski> i just changed the types  (and "fact n = loop n 1")
12:01:18 <ski> why the 'stop' arg ?
12:01:19 <tooki> yes, the c-code is complicated
12:01:34 <tooki> because 1 and 0 are of type INT
12:01:55 <tooki> and i wanted to omit any primitive type
12:01:59 <ski> (and, to get c, i of course has to add "-fvia-c" flag, so probably not exactly same code generation)
12:02:07 <ski> oh
12:02:19 <ski> but you have a 1 in "loop (a*n) (n-1)"
12:02:21 <tooki> to have it polymorphic
12:02:26 <tooki> right
12:02:28 <ski> 1 :: Num a => a
12:02:37 <tooki> use pred n
12:02:39 <ski> all numeric literals are overloaded
12:02:47 <tooki> ok
12:02:57 <tooki> fine
12:03:26 <tooki> so just the accumulator has to be poly.
12:03:26 <ski> 1 expands to something like "fromIntegral (1 :: Integer)", which is probably unfolded/inlined
12:03:51 <ski> (well, not if fact is overloaded, actually)
12:03:59 <tooki> say loop a n = (a*a) (n-1)
12:04:05 <ski> (it doesn't unfold then. i think)
12:04:15 <tooki> this way the accu. is not compined with the counter
12:04:15 <ski> a*a ?
12:05:07 <tooki> what does the assembler code saay ? still iterative ?
12:05:25 <ski> havn't tried asm, yet
12:05:26 <tooki> ok dont matter about a*a
12:05:33 <Heffalump> right, you're too interesting and I should be writing a talk
12:05:38 <Heffalump> see ya :-)
12:06:33 <ski> hmm, looking through asm now
12:06:43 <ski> trying to find the relevant part ..
12:08:13 <ski> labal Foo_fact_entry, probably
12:09:22 <tooki> i will try it myself
12:09:51 * ski smacks himself on head !
12:09:59 <tooki> thanks for the effort
12:10:04 <ski> of course there aren't any mul* instruction now !
12:10:04 <SamB> hmm, does GHC comment its asm?
12:10:10 <ski> it's polymorphic
12:10:28 <tooki> and sitll iterative ?
12:11:21 <ski> i have a bit of a hard time following this
12:11:28 <ski> 'twas a time since i read asm
12:11:42 <ski> and i'm not used to x86 asm
12:12:19 <ski> hmm
12:12:37 <SamB> ski: even somebody used to ASM would have trouble with GHCs output, probably
12:12:59 <ski> Foo_zdwfact_entry is *perhaps* what i'm looking for ...
12:13:03 <tooki> i think a polymorphic function looks more comp´licated in asm than a specialized one
12:13:12 <tooki> maybe ?!
12:13:12 <ski> rightee
12:13:24 <tooki> samb : right
12:13:31 <ski> even a specialized one looks complicated :)
12:14:11 <tooki> yep
12:14:39 <ski> (hmm, perhaps 'twould be easier to run it and see if it smashes/enlarges the stack ?!??)
12:15:12 <tooki> my merge-function e.g. does enlarge the stack
12:15:25 <ski> yeah, of course it does
12:15:32 <ski> hmm
12:15:40 <tooki> well, i must leave now
12:15:43 <ski> (oh, thought you said merge_sort)
12:15:45 <ski> ok
12:15:50 <tooki> bye
12:15:52 <ski> bye, then, tooki
12:20:06 * Marvin-- grumbles noisily about power spikes
12:44:56 <phubuh> Hi!
12:45:51 <Etaoin> hi
12:46:05 <ski> hi
12:46:07 <phubuh> Whoa, {{{#!latex ... }}} on HaWiki is awesome.
12:49:50 <stepcut> yeah
12:49:59 <stepcut> now if it just worked in irc...
12:50:23 <ski> (is it "in irc" or "on irc" ?  both correct ?)
12:50:40 <phubuh> I've heard "on irc" more often.
12:50:51 <phubuh> Hm, an ERC hack to render inline LaTeX would be funky.
12:50:53 <norpan> at?
12:51:09 <ski> norpan : perhaps that too
12:51:09 <SamB> I think it is highly context dependant. basicly, if it feels write, thats the one to use
12:53:23 <ski> SamB : (<pedantic>"feels write" ??  "feels right", "feels good/right to write" ?</pedantic>)
12:55:54 <stepcut> oddly, I usually would say 'on irc' in that sentence. Not sure why I picked 'in' today...
12:58:40 <SamB> ski: thats not pedantic! I was just not paying attention to my spelling
12:59:04 <ski> SamB : ok, if you say so
13:00:21 <SamB> stepcut: are you sure? I think the usage was about the same as "in Haskell", "in English", etc.
13:04:31 <bring> I tend to think about it as "on irc" as in "on the internet", "on the phone", "on radio", "on tv"
13:04:58 <bring> I see irc as being a medium rather than a language
13:05:19 <bring> ("in the newspaper")
13:05:22 <bring> hmm
13:06:57 <bring> maybe "in a chatroom" (a place) and "on an irc channel" (a medium)
13:07:20 <ski> you have a newspaper in front of you. and you are *outside* it. thus "in the newspaper"
13:07:23 <bring> the newspaper being a thing rather then a medium
13:07:30 <bring> exactly
13:07:41 <bring> though the tv is also in front of you
13:08:30 <ski> but "on tv" perhaps refers to the medium, anyway. not to the actual apparatus used to display the info to you
13:08:48 <bring> and you open the paper, so the news is inside
13:08:54 <ski> the newspaper being more physical, perhaps
13:09:08 <ski> mm
13:10:42 <bring> I guess it all comes down to it being a human languages, which is defined by how people happen to use it, but of course there is usually some logic behind why we say things a certain way
13:11:03 <ski> mm
13:11:11 <bring> of course there is no logic behind saying "a human languages"
13:11:20 <bring> jsut sloppiness
13:11:20 <ski> heh
13:11:52 <ski> a psychoanalyst might perhaps find something ...
13:20:53 <swisscheese> Hi all - has anyone used H with C++ using C++ for the UI?
13:21:11 * earthy looks at wxHaskell
13:22:01 <SamB> swisscheese: wxWindows is C++, in case you don't know
13:23:57 <swisscheese> wxHaskell is a H version of wxWindows?
13:24:19 <Cale> yeah
13:24:21 <SamB> haskell bindings, actually
13:26:28 <swisscheese> Thanks. Still trying to get a clear picture whether it makes sense to move some large c++ projects partly to H. 
13:27:41 <swisscheese> It's weird - a lot of stuff is 10 years behind the times like the Hugs GUI but the language is years ahead.
13:27:59 <swisscheese> And hard to get used to not having step by step debugging.
13:28:11 <SamB> swisscheese: that is probably related to whether or not they shrink once you move significant portions to Haskell
13:28:58 <SamB> QuickCheck, anyone?
13:29:07 <swisscheese> No doubt they would but not sure if would be practical to write new stuff in H and not immediately rewrite all the old c++ stuff.
13:29:26 <ski> swisscheese : the WinHugs GUI ?
13:29:44 <SamB> what does all this old stuff you are afraid you'd need to rewrite do?
13:30:03 <SamB> or even some of it
13:31:57 <swisscheese> ski - yes winhugs is a rather un polished UI - even the scroll bar doesn't work right.
13:32:33 <SamB> I think that has more to do with win32 than with haskell, probably...
13:32:35 <swisscheese> SamB - one app is a CAD app - a few mb in size.
13:33:21 <SamB> swisscheese: well, you wouldn't be forced to immediately rewrite all of it, no...
13:34:00 <swisscheese> winhugs also ceases to work if you change any options.
13:34:12 <SamB> huh.
13:34:34 <swisscheese> Yes, it's a major bug I think acked on haskell.org.
13:37:20 <swisscheese> Just checked and I see it was fixed.
13:39:56 <swisscheese> Has anyone mixed H and c++ on a significant project? Is it a hassle (no pun intended).
14:37:02 <amgine> hmmm
14:37:22 <amgine> could someone give me an example of how to use random number generator ?
14:39:56 <amgine> rollDice = do z <- getStdRandom (randomR (1,6))
14:39:57 <amgine>            print z
14:39:59 <amgine> gives an error
14:40:51 <amgine> got it
14:40:59 <amgine> had to specify a type
14:41:12 <ski> monomorphism restriction
14:41:25 <amgine> which means ?
14:41:55 <ski> that values defaults to monomorphic types IIRC
14:42:08 <ski> (if no type signature is given)
14:42:13 <ski> hmm, no
14:42:22 <amgine> ?
14:42:28 <ski> s/values/non-function-definitions/
14:42:32 <amgine> i'm only asking so i understand the error more
14:42:38 <ski> i.e things like
14:42:41 <ski> foo = ...
14:42:50 <ski> foo = \bar -> ...
14:42:53 <ski> x = ...
14:42:56 <ski> (x,y) = ...
14:42:58 <ski> and so on
14:43:01 <ski> but not
14:43:05 <ski> foo bar = ...
14:43:07 <ski> and so on
14:43:11 <ski> (IIRC, i.e.)
14:43:17 <amgine> hmm
14:43:24 <amgine> maybe i know to little of haskell yet
14:43:50 <ski> for what ?
14:44:11 <amgine> to understand what you just told me
14:44:15 <ski> oh
14:44:57 <ski> the first kind of definitions define (syntactically) nonfunctions  (even though \bar -> ... is a function)
14:45:20 <ski> the second kind defines functions (i.e. arguments to the left of "=")
14:48:38 <ski> hmm, "value binding" seems to be the ofiicial name for the first kind
14:48:45 <ski> (official)
14:53:15 <amgine> thanks
14:53:16 <ski> amgine : hmm, it seems at least one issue with (seemingly) value bindings is with sharing
14:53:19 <amgine> i remmember reading that
14:53:22 <ski> e.g.
14:53:28 <amgine> overloading ?
14:53:29 <ski> a = 1 + 2
14:54:09 <ski> if we didn't have mono.restr. then a would effectively be a function (type Num a => a), namely taking a dictionary
14:54:45 <amgine> it would be a function that adds 1 + to something ?
14:55:04 <ski> so, the default is to monomorphize value bindings, unless otherwise stated (by overloaded type in explicit signature)
14:55:08 <ski> no
14:55:24 <amgine> what does monomorphize mean ?
14:55:26 <amgine> same type ?
14:55:33 <clausen> has anyone read this? http://www.informatik.fernuni-hagen.de/thi1/klaus.weihrauch/book.html
14:55:55 <ski> it would be a function, that takes an instance dictionary of class Num, and from that extracts (+), and calls that on 1 and 2
14:56:34 <ski> amgine : monomorphize (spelling ?) = restrict a type to a monomorphic type
14:56:42 <amgine> ok
14:56:49 <amgine> that to an extent makes sense
14:56:56 <ski> (hmm, maybe just to an nonoverloaded type, for this particular problem ??)
14:57:23 <amgine> i have a question is there a function that can pick a nunmber from a list ? [2,4..100] ?
14:57:28 <amgine> i need evens only
14:57:39 <ski> so, the issue would be that the result wouldn't be shared (as one might expect it to be : it looks like *a* *value* binding !)
14:57:55 <ski> pick a number, how ?
14:57:57 <amgine> ski
14:58:03 <amgine> you've lost to be honest
14:58:03 <ski> randomly ?
14:58:04 <Cale> randomly?
14:58:20 <ski> amgine : huh ?  lost what ?
14:58:21 <amgine> hmm i am reading the random class
14:58:29 <amgine> ski for the binding stuff
14:58:42 <Cale> the monomorphism restriction is really a rather deep subject to talk about if you're just starting out in Haskell.
14:58:58 <amgine> yes Cale that's what i bleieve is the problem
14:59:02 <ski> amgine : ok, hmm
14:59:10 <amgine> ski plus i should re-read the book i have
14:59:47 <ski> amgine : (well, just add an explicit overloaded type signature, *if* you want to bypass the monomorphism restriction ..)
14:59:49 <Cale> amgine: you could just generate a random number from 1 to the length of the list and get that element of the list.
15:00:56 <Cale> or if you want a random even integer in some range, generate a random integer in half that range and then multiply by 2.
15:01:04 <amgine> yeah i did the second choice :)
15:01:22 <amgine> sometimes i obvious answer is hard to find
15:03:14 <amgine> hmmm
15:03:39 <amgine> i wish to have a global variable outside any function name
15:03:47 <amgine> this global variable is a random generated number
15:03:50 <amgine> is that possible ?
15:04:17 <ski> variable  or  cell that you can change the contents of ?
15:04:31 <amgine> cell ?
15:04:38 <amgine> what do you mean by that ?
15:04:46 <amgine> it's just a random int
15:05:11 <ski> cell as in IORef and in STRef and in imperative "variable"
15:05:25 <ski> :)
15:05:28 <amgine> crap
15:05:50 <amgine> randomNumber = 3 
15:05:51 <amgine> works
15:05:58 <ski> yeah
15:06:02 <Cale> amgine: remember that once a binding is made, you can't change it.
15:06:04 <amgine> since it's outside of any function
15:06:07 <amgine> it's global scope
15:06:12 <amgine> ahhh
15:06:21 <amgine> so how would i have a cell than
15:06:33 <amgine> global cell so i can bind it to a new value
15:06:52 <amgine> or binded at runtime
15:06:56 <amgine> with the random number generator
15:07:49 <ski> amgine : http://www.math.chalmers.se/~rjmh/Globals.ps
15:08:04 <amgine> thanks :)
15:08:24 <amgine> great i don't have post script reader
15:08:38 <amgine> i'm going to try using let
15:08:45 <ski> it describes some various techniques for (mutable !) global variables in haskell
15:09:32 <Cale> amgine: otherwise, you might just try making the functions that are going to use the random number take it as a parameter, then get main to generate the thing and pass it to them.
15:10:14 <Cale> depending on how unwieldy that this, it might be an option
15:10:22 <ski> or perhaps define the functions needing the "global", in the scope of it
15:10:47 <amgine> Cale hmm
15:11:01 <amgine> Cale i thought about that but it's part of a string
15:12:29 <amgine> crap you figure adobe reader reads .ps files
15:14:08 <ski> amgine use http://..../Globals.pdf if you can't read the PostScipt file
15:14:17 <amgine> thanks
15:15:01 <ski> (also, ghostscript,ghostview can be downloaded. it can read ps (pdf too i think ?))
15:15:15 <amgine> i found those
15:15:27 <amgine> i'll keep them in mind
15:15:33 <amgine> not untill now did i need a .ps reader
15:16:10 <ski> it seems many research papers on the net is in ps format ..
15:16:12 <amgine> that is a heavy article
15:16:53 <SamB> use citeseer, it provides ps, pdf, and djvu versions of every paper it indexes
15:17:14 <ski> (http://citeseer.nj.nec.com/cs)
15:17:18 <amgine> :r
15:17:20 <Cale> are implicit parameters currently supported?
15:17:21 <amgine> sorry wrong window
15:17:34 <Cale> oh, they must be
15:18:29 <ski> in ghc, at least
15:20:22 <ski> Prelude> :t \a -> if %ok then show a else %foo          
15:20:22 <ski> \a -> if %ok then show a else %foo :: forall a.
15:20:22 <ski>                                       (%ok :: Bool, Show a, %foo :: String) =>
15:20:22 <ski>                                       a -> String
15:21:16 <amgine> question
15:21:19 <ski> mm
15:21:24 <amgine> how can i convert an Int to a String ?
15:21:27 <amgine> show ?
15:21:29 <Cale> show
15:21:38 <amgine> hmmm why dosen't it work
15:21:43 <Cale> use read to go the other way
15:21:53 <amgine> cool to know :)
15:22:03 <Cale> Prelude> show 10
15:22:03 <Cale> "10"
15:22:19 <Cale> Prelude> "Hello " ++ show 10
15:22:19 <Cale> "Hello 10"
15:22:44 <amgine> no it works
15:22:47 <ski> Prelude> read "123" * 2
15:22:47 <ski> 246
15:22:52 <amgine> it's just i'm had a syntax error
15:23:05 <amgine> read a show are good to remmember
15:23:19 <amgine> yesterday it let me convert a binary into a string and store inside the haskell code
15:31:03 <ski> Swynndla : hi
15:32:34 <Swynndla> hi ski :)
15:53:02 <ski> i'm leaving now
15:53:09 <Swynndla> bye ski
15:53:21 <ski> bye
17:49:29 * SamB looks forward to when haskell can support numerical array processing properly
17:50:31 * SamB wonders if/when graphics cards will evolve into array coprocessors
18:40:00 <amgine> is there a way to check if a string contains a sub string ?
18:40:06 <amgine> a function to do that ?
18:41:32 <clausen> which language?
18:41:40 <clausen> oops, we're in #haskell :)
18:42:09 <amgine> haha
18:42:16 <amgine> just curious
18:42:23 <amgine> i figure haskel has something like that build in
18:44:02 <creature> I'm not sure if it does, but if it doesn't it shouldn't be too tricky to write your own. 
18:44:15 <amgine> ahhh to lazy right now
18:44:22 <amgine> lol
18:44:51 * clausen wonders if Knuth-Morris-Pratt (?) would be efficient in haskell
18:45:51 <Riastradh> Why would it be any different in Haskell?
18:46:28 <clausen> haskell data structures are often less efficient
18:46:30 <amgine> what is Knuth... ?
18:46:41 <clausen> amgine: an algorithm for finding substrings
18:46:44 <np_hard> string matching
18:47:21 <amgine> how does it work ?
18:47:30 <amgine> ahh nevermind
18:47:32 <clausen> amgine: it builds a finite state machine for the query
18:47:38 <amgine> ?
18:47:47 <amgine> i figured it be a resopnse i don't understand lol
18:48:06 <clausen> amgine: like, it figures out some "tricks", and records the tricks in a compact manner
18:48:12 <clausen> eg: if you are searching for "sex"
18:48:32 <clausen> and the current character is "a", then you can safely skip 3 characters
18:48:48 <clausen> without missing anything
18:48:57 <amgine> ohhh
18:49:05 <amgine> i remmember that in school clases
18:49:06 <amgine> got it
18:49:07 <clausen> (if the 3rd character is an "x", then you might go back)
18:49:27 <amgine> it jumps ahead or back depending what letter it ends up in
18:49:33 <clausen> yep
18:49:54 <amgine> cool
18:49:58 <clausen> so, the idea is: it figures out the rules (based on the search string) first, and then applies the rules afterwards
18:49:58 <Igloo> It only goes in one direction, just not always by 1
18:50:01 <amgine> you figure haskell would have a module for that
18:50:42 <amgine> to search for string
18:50:47 <amgine> *strings
18:51:51 <np_hard> http://haskell.org/hawiki/RunTimeCompilation
18:53:22 <clausen> np_hard: hehe, that was good luck :)
18:54:11 <np_hard> yes
18:54:47 <clausen> so, I guess the memoization would work out to be more efficient than the standard C implementation?
18:54:55 <Cale> amgine: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
18:55:18 <Cale> nobody seemed to be directly answering your question
18:55:26 <amgine> that's why you guys rule
18:55:38 <amgine> i learn bits and pices from all over the place
19:00:18 <np_hard> now
19:00:27 <np_hard> if only I could understand half the things I see here
19:00:28 <np_hard> :)
19:03:21 <amgine> *Main> matchRegex (mkRegex "test") "testasfdblah"
19:03:22 <amgine> Just []
19:03:26 <amgine> why do i get just [] ?
19:04:42 <clausen> perhaps match only tells you if there is a match (not where?)
19:05:22 <amgine> why not return a bool True ?
19:05:23 <Cale> you didn't tell it to return anything from the match
19:05:31 <Cale> matchRegex (mkRegex "(test)") "testasfdblah"
19:05:39 <amgine> ?
19:05:41 <amgine> hmm ok
19:05:52 <Cale> are you familiar with regular expressions?
19:06:03 <Riastradh> You gave it a regexp that matched, but that produced no data from the match.
19:06:20 <amgine> Cale what do you mean ?
19:07:08 <Cale> also known as regexes, it's a way to describe strings
19:07:42 <amgine> can i just make it return True if match if found
19:07:50 <Riastradh> What's wrong with Just []?
19:08:14 <Cale> if it fails, it will return the value Nothing
19:08:31 <amgine> hmmm
19:09:06 <amgine> how can i do a bool statement ?
19:09:45 <Cale> a bool statement?
19:09:49 <amgine> sorry
19:09:59 <amgine> what i mean Nothing is a data Maybe
19:10:11 <amgine> I wish to compare the result to return true or false
19:10:31 <Riastradh> What's wrong with Just []?
19:10:49 <amgine> you mean result == Just [] will work ?
19:11:00 <amgine> or result /= Nothing ?
19:11:06 <Riastradh> Why don't you use case?
19:11:11 <amgine> case ?
19:11:18 <amgine> case statements in haskell
19:11:24 <Riastradh> case matchRegexp ... of
19:11:26 <amgine> crap never used yet
19:11:30 <Riastradh>     Just matches -> ...
19:11:34 <Riastradh>     Nothing -> ...
19:11:34 <amgine> good time to learn i guess
19:12:12 <Riastradh> I restate my suggestion for you to spend a significant amount of time learning Haskell.
19:12:25 <amgine> Riastradh yes :)
19:12:31 <amgine> time to pull out that book
19:12:37 <amgine> i remmember reading about cases
19:12:45 <amgine> but liked gurdians more
20:34:22 * themaximus is away: Sleep
20:59:27 <SamB> are threads cheap enough to use them instead of deferreds?
20:59:57 <Riastradh> SamB, do you really care?
21:00:38 <SamB> you think Python is better to write servers in?
21:01:23 <np_hard> it's the complexity of programming that is the issue, not the cheapness or expense of threads
21:03:45 <SamB> yeah, well I was having a hard time thinking of a truly lazy way to characterize deferreds. now that I think about it, maybe a group of ReactorMonad types could work.
21:05:41 <SamB> I suppose I should remember how one of the guys who created C told the other poeple working on UNIX that function calls were cheap, even though they werent.
21:06:32 <stepcut> mmm cheap function calls
21:06:51 * stepcut beats experimental technology into submission
21:07:07 <SamB> well, they were a lot cheaper in the long run than the alternative
23:25:49 <Etaoin> I like haskell
23:31:23 <ayrnieu> Etaoin - why?
23:41:29 <Etaoin> it is magic
23:41:37 <Etaoin> and fun to learn
23:43:52 <ayrnieu> magic? =)  How?
23:46:11 <Etaoin> non-strict evaluation, currying, type-inferencing
23:47:08 <ayrnieu> Why fun to learn, then?
23:48:23 <Etaoin> I don't know
23:49:51 <Etaoin> it's rather mathy
23:50:39 <ayrnieu> Can you point at any other languages that you've learned and suggest why you have more fun learning Haskell than you did those languages?
23:51:50 <phubuh> Haskell is more fun to learn than, say, Java, because Haskell actually contains interesting concepts.
23:52:13 <phubuh> "A language that doesn't affect the way you think about programming, is not worth knowing"
23:52:30 <Etaoin> yes
23:54:01 <ayrnieu> Interesting concepts such as non-strict evaluation, currying, and type-inferencing?
23:54:33 <phubuh> And type-classes, and monads.  Especially monadic I/O is interesting.
23:55:05 <Etaoin> functional programming itself is an interesting concept
23:55:15 <esap> The module system is no less interesting beast :-)
23:55:26 <Etaoin> but certainly not unique to haskell
23:55:37 <phubuh> esap: It could be more interesting.  And better. :P
23:56:03 <esap> phubuh: I agree [first class modules]
23:56:21 <phubuh> ML-esque functors would be great.
23:56:31 <phubuh> And nested modules!
23:57:15 <esap> I think nested modules come automatically if you have first-class modules.
23:58:02 <phubuh> Unless you're going out of your way to constrain it, yes. :)
23:58:24 <Etaoin> can't you do something like ML-esque functors with type-classes?
23:58:58 <esap> not quite, I think.
