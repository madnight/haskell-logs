00:06:54 <earthy> Good Morning #Haskell!
00:07:30 <shapr> hoi earthy!
00:19:10 <Lunar^> Hi shapr 
00:19:47 <shapr> y0 Lunar^, wassup?
00:20:46 <Lunar^> I'm being anxious thinking that I should be coding Python right now
00:20:56 <shapr> why?
00:21:09 <shapr> hey, the haskell xmlrpc unit tests I'm writing can help you with Zope also
00:21:39 <Lunar^> I think it's the same thing as with school books few years ago
00:22:49 <Lunar^> If I had chosen these books myself, it could have been enjoyable, but because it was not my choice, it was first hard to do it, and then they gave me horror feelings
00:22:58 <shapr> yes, I understand that.
00:25:16 <shapr> I enjoy working with Zope lots more when I get to use Haskell also.
00:25:26 <shapr> you want me to send you my Haskell sources?
00:25:39 <Lunar^> No thanks
00:26:00 <Lunar^> I'm finishing this damn hosting project, it needs more polishing than code now
01:02:58 <shapr> hi eek 
01:05:48 <shapr> what's up?
01:16:37 <eek> hi, shapr :-)  just work - perl :-((((
01:45:56 <shapr> it's better to get paid to write code than to dig ditches.
01:48:54 <eek> maybe.  I think I would be angry less of the time if I dug ditches (and I also think I would have more free time)
01:49:01 <shapr> haha
01:50:14 <shapr> unit testing improves my mood
01:50:20 <Lunar^> :)
01:50:20 <shapr> because then I have more trust in the code.
01:55:25 <Lunar^> shapr: What's that wikiwiki that you where talking yesterday with Igloo ?
01:55:30 <shapr> it's a source wiki
01:56:14 <shapr> since darcs does not require a login to commit code, I turned off the test-on-commit and turned off the GPG key checking, and now anyone can commit anything to the wikiwiki dacs repo.
01:56:15 <Lunar^> shapr: ?
01:56:27 <shapr> Igloo had the idea, I just figured out the details and set it up.
01:56:39 <shapr> darcs get http://www.ScannedInAvian.org/repos/wikiwiki
01:56:55 <Lunar^> shapr: Ok, it's not a webpage
01:57:02 <shapr> not yet
01:57:05 <shapr> but I think it will be
02:12:15 <Lunar^> shapr: What exactly do you unit test with Zope ?
02:14:02 <shapr> nothing particularly nifty at the moment, but my next test is to figure out how to automatically create my archetype instances
02:15:04 <shapr> tests I have right now, check for connect, check for user, execute a python script, execute a dtml method, execute an acquired python method, execute a python script that requires two explicit args, call dtml method with named arguments (like submitting a form)
02:16:02 <shapr> my goal for the tests is to unit test our 3-language code
02:16:40 <shapr> the hoped-for endpoint is to use QuickCheck to find bugs, of which I'm sure I will find many.
02:19:05 <shapr> Lunar^: you want the code?
02:20:14 <eek> shapr: Unit testing definately improves my mood.  writing code in Perl where there are database classes and web server dependencies and "sabotaging" co workers that don't run the Unit tests before committing (and introduce new nasty dependencies) works the opposite direction...
02:22:09 <shapr> Lunar^: http://shapr.homelinux.net/~shae/Test_HaskAlis.hs
02:44:38 <Lunar^> shapr: I don't see well which code do you test
02:45:19 <shapr> I'll pull out the python and dtml and them all into a folder
02:45:26 <shapr> but not right now
02:45:35 <Lunar^> shapr: Can you reproduce user interaction ?
02:46:08 <shapr> I think so
02:46:22 <Lunar^> This could be really interesting in this case
02:46:34 <shapr> what sort of user interaction do you want to reproduce?
02:46:48 <Lunar^> To be able to test workflow I think
02:46:56 <shapr> I want to test registration, creation of object, etc
02:47:00 <Lunar^> It's the question my chief asked when I talked about that
02:48:15 <shapr> I don't know about testing workflow, but I'll try it next time I'm working on the tests.
03:00:32 <earthy> there, new vim syntax highlighter sent off to Bram Molenaar.
03:00:36 <shapr> yay
03:02:29 <earthy> definite yay
03:02:47 <earthy> this one is *quite* a bit better for e.g. literate haskell
03:02:55 <earthy> and fixes some bugs in the plain haskell highlighting
03:03:16 <earthy> ( --+ would be considered as starting a comment)
03:03:38 <Arnia> shapr: Oh my... hOp is quite cool (although kernel hacking isn't my thing ;)
03:03:48 <shapr> yes, GHC RTS on the Bare Metal.
03:03:54 <shapr> and it's easy to build also.
03:05:04 <earthy> almost time to try recreating Jonathan Rees' kernel in Haskell
03:05:50 <shapr> what's that?
03:06:48 <earthy> http://mumble.net/jar/pubs/secureos/
03:07:57 <shapr> that would be interesting
03:08:46 <shapr> heyy, I wonder if I can use this for an on-disk mailing list index: http://www.kimbly.com/code/invidx/haskell/InvIdx.lhs
03:12:44 <Lunar^> earthy: Are you interested in working on hOp ?
03:12:52 * earthy coughs
03:12:55 <earthy> interested, yes.
03:13:12 <Lunar^> shapr: btw, do you know if there's any paper describing GHC RTS ?
03:13:13 <earthy> what I would have to be doing though would be formal verification ;)
03:13:19 <Lunar^> shapr: or more specifically, its garbage collector
03:13:38 <earthy> as in: include a system along the lines of proof carrying code in hOp. ;)
03:13:44 <Lunar^> shapr: The code is quite hard to follow because there's ... 4 different implementations in the same file
03:14:01 <earthy> oh, and there are gc docs
03:14:08 <earthy> for ghc
03:15:53 <Arnia> earthy: Oh for dependent types in GHC :p
03:17:50 <earthy> well, yes and no. :)
03:18:20 <earthy> gimme a nice and properly implemented pure type system any day. ;)
03:18:36 <earthy> a higher order logic will also suffice. ;)
03:20:07 <Lunar^> http://www.doc.ic.ac.uk/~amc4/Papers/IncGCmastersThesis.ps
03:20:22 <earthy> is that in already?
03:21:06 <Lunar^> I don't know
03:21:33 <Arnia> earthy: My uni is researching a simple dependent type system with a clean notation
03:21:49 <earthy> ah! cleaner than (say) Agda?
03:24:34 <Arnia> earthy: I don't know how clean... all I can go on is what I've been told (which isn't much since I'm an undergrad)
03:26:48 <earthy> 'kay
03:26:49 <earthy> ;)
03:27:08 <earthy> dependent types to me seem like a solution in search of a problem
03:27:18 <earthy> (that's already solved mostly satisfactory)
03:27:36 <earthy> but that may be because I haven't invested much time in it
03:28:40 <Lunar^> http://research.microsoft.com/Users/simonpj/Papers/inc-gc.htm <-- I think that should be the most up to date
03:30:19 * earthy nods
03:30:33 <earthy> there was a mailinglistposting from yesterday or today with those links
03:32:42 <shapr> hOp is much more interesting than Zope :-/
04:35:52 <Lunar^> earthy: Which mailling-list ?
04:37:47 <Lunar^> earthy: glasgow-haskell-users, thanks
04:56:19 * Igloo slaps earthy about with 2 copies of a badly-line-wrapped signature  :-P
04:59:41 <earthy> the .sig is 78 characters wide.
04:59:50 <earthy> quit yer whining.
05:00:10 <Igloo> But unless I'm confused your MUA is wrapping it
05:11:04 <Igloo> Anyone know any more on "wxWindows is now called wxWidgets! (and yes, it is due to Microsoft :-)"?
05:11:44 <Igloo> Oh, n/m, the website does
05:13:56 <earthy> igloo: my MUA is wrapping my .sig?
05:14:11 <earthy> not at my end when I'm writing it isn't
05:14:48 <earthy> ah, weird!
05:15:24 <Igloo> Does that mean you've confirmed it is before I go off and double check my end?
05:15:45 <earthy> that means that I get the wrapping when I send to myself
05:15:52 <eek> earthy: I've seen it in old archives on the web, too
05:16:31 <eek> earthy: zapping the ascii art to conform to the old netiquette guidelines would solve it ;)
05:17:04 <Igloo> Presumably it would also wrap deliberately long stuff in the body, so solving it properly would be useful anyway
05:17:14 <eek> earthy: (not that that was ever anything that was universally agreed on - only the size was)
05:17:15 * earthy agrees with igloo
05:17:28 <earthy> the size of the .sig is well within bounds, at 3 lines of 78 chars. :)
05:17:51 <earthy> and I never saw netiquette proclaiming ascii art to be bad. :)
05:18:45 <eek> earthy: I actually also seem to remember a 76 character limit sometime being mentioned (in addition to the common 72-character limit for original body text), but I can't for the life of me remember where that was
05:19:19 <eek> earthy: there was some that proclaimed that; I remember seeing conflicting variants of that when I first got active on news (1990 or so)
05:20:00 <eek> earthy: but it never was universal
05:20:05 <earthy> what's even weirder is the fact that Mail (that I used to send this with) actually displays the .sig correctly
05:20:17 <earthy> eek: ISTR 4 lines of 80 chars max
05:21:22 * Igloo would say 4x79 to avoid potential blank lines
05:21:34 <eek> earthy: less than 80 for stuff to work; 4 lines is correct; "-- " as introducer for news (doesn't matter for mail); and, for some guides, "no ascii art"
05:22:14 <eek> earthy: I just try to remember where the 76 came from.  that number is popping up in my memory, and I can't place what context it was for
05:22:55 <earthy> probably vi with default wrapmargin
05:23:11 <eek> that may be.
05:34:04 <earthy> weirdness
05:46:55 * earthy takes a gun and shoots Apple's Mail.app
06:01:47 <ozone> if i want to make [String] an instance of a type class, what syntax do i use for that?
06:01:58 <ozone> "instance Foo [String] where ..." works with GHC
06:02:03 <ozone> but that's not Haskell 98
06:02:15 <ozone> "instance Foo [] ([] Char) where ..." doesn't work either
06:02:54 <eek> earthy: /2
06:02:55 <eek> oops
06:02:57 <eek> forget that
06:07:48 <Igloo> You don't in Haskell 98
06:07:54 <Igloo> newtype it if you need to
06:08:04 <ozone> Igloo: ah
06:08:11 <ozone> that's a bit yuck :)
06:08:18 <Igloo> Or make an instance for Char and [a] if that suits
06:09:53 <ozone> Igloo: no, but i wish it did
06:10:01 <ozone> i'll post to the mailing list about it
06:13:06 <ozone> ooh, actually, no, fixed it
06:13:09 * ozone bounces
06:13:20 <ozone> now i have perl-ish =~ regex matching 8)
06:14:56 <Igloo> :-)
06:15:34 <eek> ozone: ie, syntax hack?
06:16:39 <ozone> eek: yeah.  i'm a big fan of syntax hacks. :)
06:20:20 <eek> ozone: I'm a big fan of clean syntax for the stuff necessary.  having regexen integrated sounds good.
06:20:21 <earthy> thus you now have  (=~) :: Matchable a -> a -> String -> Boolean   ?
06:21:20 <ozone> earthy: actually, just :: String -> String -> Bool, but only because Text.Regex's matchRegex function can only match against Strings
06:21:27 <ozone> (rather than defining a general Matchable class)
06:24:55 <earthy> may I presume you've also defined !~?
06:25:06 <earthy> and =~ s/ ?
06:25:20 <ozone> nope
06:25:37 <ozone> !~ is probably trivial (says he, who hasn't tried it yet)
06:25:47 <ozone> =~ s/.../ is a bit less trivial, i think :)
06:26:04 <ozone> (mostly because it's hard to find a nice syntax for it)
06:26:05 <earthy> doesn't really fit with referential transparency :)
06:27:14 <ozone> earthy: that's OK, i have a [String] context for =~
06:27:21 <eek> ozone: how about group extraction?
06:27:32 <ozone> so it's not too difficult to get s/.../ish behaviour by manipulating its output
06:27:39 <ozone> eek: check haskell-cafe in a sec
06:28:13 <eek> ozone: haskell-cafe?
06:29:07 <eek> ozone: NOTE: I started looking at Haskell again yesterday (after a 9 or 10 year pause), and haven't had much time at all to check out resources
06:29:18 <ozone> eek: oh, the haskell-cafe mailing list
06:29:31 <eek> ozone: not a member :-/
06:29:34 <ozone> http://www.haskell.org/mailman/listinfo/haskell-cafe
06:29:36 <earthy> wow, eek, do you have stuff to learn. :)
06:30:28 <eek> earthy: I assume so :-)
06:32:07 <eek> earthy: and I can't fully guarantee that I'll like Haskell (I'm very much a Ruby fan), but dennisb has recommended it so many times I thought I'd give it a whirl again ;)
06:32:37 <earthy> well, I don't know much ruby, but from what I hear of it you probably will like haskell :)
06:33:36 <amb> hi
06:36:52 <earthy> btw, ozone, did you release your Objective-C binding already?
06:37:15 <earthy> and what about the XCode ghc stuff you said you had / was building? :)
06:37:35 <ozone> earthy: did you ever get that working?
06:37:54 <ozone> as for the objc binding, no time -- working full-time now, so not much play time for haskell
06:38:04 <earthy> ;)
06:38:05 <ozone> but the good news is, wolfgang thaller's gone crazy with HOC
06:38:17 <ozone> so it's basically working now
06:38:31 <ozone> i think he has to make a few very minor changes to get it working with GHC 6.2
06:38:51 <ozone> but he's got some full sample apps written, which work
06:39:13 <earthy> oh cool!
06:39:43 <ozone> earthy: (including the API generator, so it generates .hs files from all the Cocoa headers)
06:40:06 <Igloo> What do you do, ozone?
06:40:34 <ozone> Igloo: i work on multimedia stuff
06:40:37 <ozone> www.annodex.net
06:40:42 <ozone> very schweet project :)
06:40:59 <ozone> hacking on videolan code at the moment, which is fun yet painful at the same time
06:41:36 <ozone> earthy: http://www.haskell.org//pipermail/haskell-cafe/2004-February/005852.html
06:42:10 <Igloo> Cool
06:42:10 <earthy> I already read the code ;)
06:43:53 <earthy> it prompted those questions, as I tend to forget your nick <-> realname mapping. :)
06:44:47 <ozone> earthy: ah
06:48:27 <earthy> yeehaw
06:48:33 <earthy> that is one massively ambitious project
06:48:42 <ozone> HOC?
06:48:48 <earthy> annodex
06:48:53 <ozone> ah
06:48:54 <ozone> yeah
06:49:04 <ozone> it's lots of fun surfing video :)
06:52:01 <earthy> one problem though: how the heck to author surfable video. :)
06:52:23 <earthy> I for one am *not* going to add video-hyperlinks by hand to a multimegabyte videostream. :)
06:52:24 <ozone> earthy: pretty trivial, actually
06:52:42 <ozone> you can do it by authoring a CMML file, which is what we do today
06:53:10 <ozone> obviously it's a bit nicer to have a video editing tool which can scrub the video and enables you to type in hyperlinks at the appropriate time points, which is something we're working on
06:53:37 <earthy> but that makes me type the exact minute-second-frame offsets, right?
06:53:42 <earthy> blech. :)
06:53:50 <Lunar^> ozone: HOC ?
06:53:52 <ozone> yeah, it does
06:54:12 <earthy> lunar: haskell binding for objective-c libraries
06:54:17 <Lunar^> uhh ok
06:54:17 * Igloo wonders what to call tests that go from giving unexpected output to expected wrong output. Both "Broke" and "Fixed" seem wrong  :-)
06:54:28 <ozone> Lunar^: if you're daring, check out CVS at http://sourceforge.net/projects/hoc/
06:54:36 <earthy> i.e. how to get haskell to interface to cocoa and develop MacOS X native apps in Haskell. ;)
06:54:49 <earthy> Igloo: Caught
06:54:55 <Lunar^> earthy: OpenGL support is already good
06:55:00 <ozone> Lunar^: only problem is that there's no build instructions
06:55:08 <Igloo> hmm
06:55:09 <ozone> if you're interested, pester wolfgang
06:55:16 <Lunar^> ozone: I'll wait I think
06:55:21 <earthy> lunar^: I mean the PDF compositing, the windowing, the file-open stuff... all that joy
06:55:35 <Lunar^> ozone: But it could be cool to use InterfaceBuilder for Haskell :)
06:55:43 <earthy> another gc mail btw, lunar^, on glasgow-haskell-users
06:55:59 <ozone> Lunar^: that's what it allows you to do
06:56:04 <earthy> (The incremental collector is not
06:56:05 <earthy> currently available in a GHC release)
06:56:16 <Lunar^> earthy: thanks.. maybe I should subscribe and stop reading them only with pipermail
06:56:21 <earthy> http://citeseer.nj.nec.com/sansom93generational.html
06:57:22 <Lunar^> earthy: thanks
07:01:44 <Lunar^> That's a bad news for hOp
07:02:00 <earthy> i.e.?
07:02:06 <Lunar^> A first sight, what's described in "Non-stop Haskell" seems promising
07:02:18 <earthy> ah.... yeah... well... WiP.
07:02:35 <Lunar^> WiP ?
07:03:13 <earthy> Work in Progress
07:03:46 <Lunar^> uh ok
07:31:51 <Igloo> Woohoo, my type checker is now only as broken as it should be  :-)
07:32:20 <Lunar^> Igloo: ???
07:33:23 <Igloo> Lunar?
07:36:00 <Lunar^> Igloo: I'm trying to avoid working, leave me alone ;)
07:36:12 <Igloo> lol
07:36:34 * Igloo needs to do some more thinking now
08:09:58 <Tirador> hello
08:10:51 <Tirador> when I've a function Int -> a and I want to give back nothing, is that possible?
08:15:20 <earthy> errr...
08:15:28 <earthy> f :: Int -> a
08:15:28 <ski> what do you mean by "give back nothing" ?
08:15:32 <earthy> f 0 = Nothing
08:15:32 <earthy> ?
08:15:35 <earthy> something like that?
08:15:52 <Tirador> yeah
08:16:01 <ski> earthy : ERROR : too general type in signature
08:16:12 <earthy> ski: true. :)
08:16:35 <Tirador> I tried [] but it doesn't work cause it's type is [a]
08:16:36 <ski> you want to *not* return anything sensoble for some specific inputs ?
08:16:43 <ski> e.g
08:16:47 <_Codex> Would f :: Int -> Just a work?
08:16:56 <ski> yes
08:17:22 <ski> (if you change 'a' to what you want to return otherwise)
08:17:37 <ski> (and change 'normal' returns to use Just)
08:17:37 <_Codex> err.. f :: Int -> Maybe a
08:17:44 <ski> oh, right
08:17:53 <ski> e.g
08:17:58 <ski> f 0 = 0
08:18:01 <ski> f 1 = 10
08:18:08 <ski> f _ = undefined
08:18:08 <Tirador> entry :: Int -> Int -> [(Int,Int,a)] -> a
08:18:08 <Tirador> entry i j [] = a
08:18:08 <Tirador> entry i j ((a,b,x):xs) | (i,j)==(a,b) = x | otherwise = entry i j xs
08:18:12 <ski> this also works
08:18:39 <ski> Tirador, so you sometimes want to return an Int ?
08:18:47 <Tirador> I've a matrix that is defined as list of (Row, Column, Object)
08:18:55 <ski> oh, 'a'
08:18:56 <ski> ok
08:19:06 <basti_> a is defined?
08:19:13 <ski> no
08:19:13 <Tirador> I want to give back the entry at i j, if he doesn't find it, i want to give back nothing
08:19:25 <basti_> then use "Maybe a" as type
08:19:27 <ski> do you want the program to stop then ?
08:19:40 <ski> i.e. is that condition an (programming) error
08:19:43 <ski> ?
08:20:16 <Tirador> entry i j [] = a <- I know that doesn't work but how can I do it, that it gives me nothing back?
08:20:39 <basti_> Tirador you can either cause a programm error with: error "This won't work"
08:20:48 <basti_> Tirador or use "Maybe a" as the return type
08:20:49 <ski> do you want to be able to check, if entry returned this 'nothing' ?
08:21:33 <ski> Tirador : well ?
08:22:14 <Tirador> basti_, that means I've to define Maybe as new data?
08:22:36 <basti_> Tirador no it is a type already defined in the 'prelude'...
08:22:38 <ski> Tirador : Maybe is in the Prelude
08:22:53 <ski> @type Nothing
08:22:53 <lambdabot> Nothing :: Maybe a
08:22:57 <ski> @type Just
08:22:58 <lambdabot> Just :: a -> Maybe a
08:24:44 <Tirador> entry :: Int -> Int -> [(Int,Int,Maybe a)] -> Maybe a <- ok?
08:24:51 <ski> no
08:24:58 <ski> entry :: Int -> Int -> [(Int,Int,a)] -> Maybe a
08:25:11 <ski> you still want to store 'a':s
08:25:22 <ski> but entry should be able to 'fail'
08:25:33 <ski> i.e. it maybe returns an 'a'
08:25:56 <ski> ok ?
08:26:35 <Tirador> yeah but hugs tells me that return type a is incompatible to Maybe a
08:26:42 <ski> yes
08:26:48 <ski> entry i j [] = Nothing
08:26:54 <Tirador> yeah I've that
08:26:54 <ski> entry i j ((a,b,x):xs)
08:27:01 <ski>   | (i,j)==(a,b) = Just x
08:27:06 <ski>   | otherwise = entry i j xs
08:27:13 <ski> see ?
08:27:29 <Tirador> data Maybe a  =  Nothing | Just a deriving (Eq, Ord, Read, Show) (see 6.1.8) <-- ahh ok :)
08:28:13 <ski> then, to check if entry returned nothing or just something ...
08:28:30 <ski> case entry x y matrix of
08:28:34 <ski>   Nothing -> ....
08:28:40 <ski>   Just object -> ....
08:28:45 <Tirador> works fine, thank you!
08:29:05 <ski> (you could also use pattern-matching for this)
08:29:09 <ski> good
08:31:26 <Tirador> somebody works in a company that only uses haskell?
08:32:01 <norpan> only?
08:32:19 <norpan> i don't think that there is such a company
08:32:29 <norpan> we use it quite a bit, but we also use c
08:32:54 <Tirador> Can I merge haskell and c code?
08:33:05 <Tirador> or other programming languages with haskell?
08:33:09 <norpan> you can call haskell code from c, and vice versa
08:33:13 <basti_> yes with the so calles "FFI" (foreign function interface)
08:33:28 <norpan> calling c code from haskell is very simle
08:33:30 <norpan> simple
08:33:35 <norpan> foreign import
08:34:18 <Tirador> sounds cool, I've to take a look at that
08:34:31 <norpan> quite useful
08:35:00 <norpan> marshalling values is a bit of a bore though, even if there are tools that can help you
08:35:59 <norpan> http://www.reid-consulting-uk.ltd.uk/docs/ffi.html <- very good guide to ffi
08:42:25 <Segora> re
08:49:08 <shapr> gee, SPJ says that a particular paper is not for the faint of heart. I'm already scared.
08:49:24 <shapr> Igloo: you got credits on the hat mailing list :-)
08:49:27 <shapr> hej bring 
08:49:58 <bring> hi
08:50:25 <shapr> right, swedish should happen on #haskell.se
08:50:28 * shapr tries ebonics
08:50:32 <shapr> y0 bring, wazzup?
08:50:39 <shapr> :-)
08:50:46 <Igloo> Oh, hmm, that must be another list I'm not on. haskell.org MLs need a big red "I want to know EVERYTHING!" button
08:50:52 * shapr grins
08:50:55 <Igloo> Thanks for the pointer  :-)
08:51:01 <shapr> Igloo: I've been thinking about something like that actually
08:52:04 <shapr> Kragen Sitaker was discussing something called a rumorset. Though I forget what he actually means, I realized I'd like to have tree-shaped subject-oriented rumorset
08:52:27 <Igloo> mailman really really really needs an "I don't care what my password is, just make one up for me please" option, especially if it tried to find a password used onthe same server to use preferentially
08:52:55 <shapr> so the rumorset admin would add various sources in various formats to the haskell rumorset, and you could subscribe to all of it, or limit it by format, by subject, whatever.
08:54:11 <Igloo> Cool, Malcolm mentions Debian
08:54:25 * Igloo crosses fingers for more libraries supported in 2.04
09:02:07 <shapr> y0 SyntaxNinja
09:02:20 <SyntaxNinja> y0 shapr
09:02:29 <shapr> huh, where's solna?
09:04:44 <SyntaxNinja> shapr: darcs builds on Debian SPARC, btw :)
09:04:56 <shapr> wow!
09:07:14 <Igloo> 2 down, 9 to go  :-)
09:07:27 <SyntaxNinja> heh
09:07:38 <SyntaxNinja> the rest aren't my problem right away :)
09:08:27 * Igloo suddenly realises something - does darcs not build with nhc98?
09:08:52 <SyntaxNinja> dono
09:09:04 <ski> shapr : http://www.sna.se/bin/ort.cgi?LANG=SE&S=E&O=solna&OK=S%F6k+ortregister
09:09:28 <shapr> aha, so it's next to sthlm
09:09:30 <Igloo> If it does you should add it as an alternative build-dep so mips, mipsel, arm have a chance
09:09:37 <shapr> ski: that's a handy url, thanks.
09:09:56 <bring> shapr: I talked to Graham Klyne and he likes to idea of creating a central place for unofficial hierachical libs, he would for example like to put his Network.URI there
09:10:26 <bring> what do you say we create a new CVS module at haskell-libs and start putting stuff in?
09:10:41 <shapr> I think it's an excellent idea.
09:11:07 <shapr> the current structure is in chronological order, the oldest stuff is at the bottom ;-)
09:11:17 <bring> :)
09:11:25 <bring> so, the most important thing then, what do we call it?
09:11:49 <Igloo> Bob
09:11:54 <bring> :)
09:12:06 <bring> I thought Microsoft tried that already
09:12:07 <Igloo> Oh, bother, missed a chance to exclaim darcs!
09:12:44 <shapr> I think we should make a structure that can be easily added to the existing library hierarchy.
09:13:09 <bring> I agree, what I mean is what we should call the CVS module
09:13:30 <shapr> I think we should probably have a separate module for each major library and app
09:13:41 <shapr> that should make versioning and separate check-out easier.
09:13:49 <bring> hmm, yes
09:13:58 <bring> it would, you're right
09:14:02 <shapr> but, I don't have a lot of experience using CVS for larger structures, so I'd really like to hear from someone who does.
09:14:51 <bring> fptools has it all in one module, right?
09:14:59 <shapr> it does
09:15:04 <bring> but that's probably not the best way to do it for us
09:15:21 <bring> since it could get arbitrarily large
09:16:01 <bring> otoh, if you need a few libraries (e.g. XmlRpc + HTTP + Base64) it could get messy with to many modules
09:16:05 <shapr> my first thought is to create $NAME/src/$LIBROOT
09:16:21 <shapr> so if you create a Data.Bag, you'd have Bag/src/Data/Bag.hs
09:16:35 <shapr> that's a good point.
09:17:42 <shapr> bring: do you know any experienced CVS users/admins?
09:18:12 <bring> not really
09:18:22 <shapr> I suggest we ask around for cvs structure suggestions and reconvene tomorrow, how does that sound to you?
09:18:31 <bring> sounds good
09:18:36 <shapr> I could post such a request on haskell-cafe
09:18:43 <bring> excellent
09:19:00 <shapr> oh, Alistair's Oracle binding should be in haskell-libs soon.
09:20:17 <bring> sweet
09:28:52 <shapr> hi egorick, looking for Haskell info?
09:29:18 <egorick> hm, type of
09:31:20 <shapr> anything specific?
09:32:24 <egorick> I have 1 small problem in hugs, when writing 'import Debug.Trace'
09:32:55 <egorick> when I load the file eith :l ..., it says ERROR "Debug.Trace" - Unable to open file "Debug.Trace"
09:33:18 <egorick> probably I didn't set something up properly :(
09:34:41 <ski> type :s in hugs and look for line "Search path     : -P..."
09:35:11 <ski> what is your "..." ?
09:35:45 <egorick> Coins.lhs (from current directory)
09:37:05 <ski> hmm, in my hugs it's "{Hugs}/lib:{Hugs}/lib/hugs:{Hugs}/lib/exts"
09:38:11 <egorick> in my too
09:38:15 <ski> ok
09:38:36 <egorick> it's strange, but there is 'Debug' in /usr/share/hugs/libraries/Debug
09:38:41 <ski> i think {Hugs}/libraries should be included for the hierarchial libraries to work
09:38:46 <ski> right
09:38:47 <egorick> but not in lib/Debug :(
09:39:00 <egorick> what's the difference?
09:39:12 <ski> (possible one might have to throw out one of the old lib dirs from the path, then)
09:39:36 <ski> libraries/ are the (new) hierachical libraries
09:41:35 <egorick> ok, and how to include libraries/ by default? (couldn't find it in a fast way:)
09:42:01 <ski> you could put an "-P..." option in HUGSFLAGS, i think
09:44:40 <egorick> hm, this rewrites previous settings and loads Prelude from /libralies/, is that ok?
09:44:43 <ski> "-P{Hugs}/libraries" then, i think
09:45:00 <ski> sorry ?
09:46:39 <egorick> I mean, when I do 'export HUGSFLAGS=-P{Hugs}/libraries' and then start hugs, it loads Prelude.hs from /usr/share/hugs/libraries/Hugs/Prelude.hs
09:46:45 <egorick> it is not as usual
09:47:00 <ski> right
09:47:03 <egorick> and two "Prelude"s differ
09:47:08 <ski> i don't know
09:47:26 <ski> but hugs seemed to get confused with two Preludes in the path
09:47:35 <egorick> oops
09:48:02 <ski> (or perhaps i just was that it had two definition sites for Int,etc ...)
09:48:17 <egorick> looks like I should use Prelude from librarlies/ to use other files from libraries/
09:48:18 <ski> (s/i/it/)
09:48:46 <ski> yes, i guess the other libraries files depend on that one
09:49:07 <ski> cuelebre : hello
09:50:30 <ski> cuelebre : looking for haskell info ?
09:50:35 <egorick> Now I have not determined any problems with both search paths
09:50:51 <ski> mhmm
09:54:06 <cuelebre> hello ski 
09:54:15 <bring> shapr: ok, now I want shrink too
09:54:29 <shapr> ?
09:54:47 <shapr> did you get a generated test case that's a mile long?
09:54:59 <bring> exactly
09:55:02 <egorick> ski, thank you for your help!
09:55:12 <bring> at least long enough to be boring
09:55:17 <shapr> :-)
09:55:52 <shapr> from what Marvin-- said, it cuts down the randomly generated list and check to see if the case still fails
09:57:33 <bring> do you have to use some new class and define shrink for your data, or does it just reduce the test size until it doesn't fail?
09:57:52 <shapr> are you using coarbitrary?
09:57:58 <bring> no
09:58:13 <bring> just arbitrary
10:00:06 <bring> note to self: don't leave frozen foods in bag, put them in freezer
10:00:11 <shapr> :-)
10:00:23 <ski> heh
10:00:52 <shapr> somewhere in QC, a randomly generated list gets turned into a real instance of a datatype
10:01:06 <shapr> I'm not sure if that's only the coarbitrary part or what
10:01:30 <bring> ah, of course, that makes sense
10:01:30 <shapr> but anyways, if you find a randomly generated list that does cause a failure, shrink will cut down that list and check to see if the result still causes a failure
10:01:45 <shapr> that happens recursively until you have the smallest list that does cause a failure
10:01:51 <shapr> so you can actually read the test case.
10:01:57 <ski> how, cut down ?  omit some elements ?
10:02:07 <shapr> yes, I think it does init
10:03:04 <bring> you'd probably want it to start using tail when it can't shrink it at the end any longer
10:03:08 <shapr> right
10:03:23 <shapr> maybe we could do a cleanroom implementation :-)
10:03:30 <bring> haha
10:04:17 <ski> maybe one could record the random choices made during construction, and then try to vary it .. ?
10:04:38 <bring> and see if it makes the test smaller?
10:04:44 <ski> yes
10:05:01 <ski> some sort of structural history of the choices
10:05:32 <bring> basically the list of random numbers generated during construction would be enough, right?
10:05:36 <shapr> yes
10:05:43 <ski> it would be nice if this could e.g. omit an element in the middle of the list, leaving the tail untouched
10:06:02 <bring> that sounds hard to do for arbitary structures
10:06:04 <ski> bring : i was thinking something more complicated, i guess ..
10:06:09 <shapr> this is what I call my "binary error search" where you comment out half the code and see if the error is still there.
10:06:22 <bring> ;)
10:06:23 <ski> :-)
10:06:47 <ski> hello BluRonin
10:07:26 <shapr> we're just doing small permutations of the list of random numbers to see if a smaller list fails, right?
10:07:32 <ski> BluRonin : looking for haskell info ?
10:07:40 <BluRonin> howdy. yup
10:08:07 <ski> shapr : or omissions
10:09:08 <ski> shapr : perhaps also duplications and insertions, but maybe with small probability, then
10:09:26 <ski> BluRonin : what do you know of haskell ?
10:09:53 <shapr> if only init and tail are used, it should be straightforward to iterate those and cut down a list quickly
10:10:09 <shapr> when you start doing stuff in the middle, you probably want to add a search depth limit
10:11:04 <ski> (but perhaps init,tail isn't good enough for making failing tests smaller, for some things to test .. :( )
10:11:09 <shapr> that's true
10:11:24 <ski> it seems quite simplistic
10:11:45 <Lemmih> Am I the only one who can't download HDirect?
10:11:50 <ski> but, IMBW, it might be good for a large part of common problems
10:11:52 <shapr> the whole of QuickCheck.hs is 336 lines
10:12:06 <ski> (as well as being a starting-point)
10:12:06 <shapr> so it probably is simple
10:12:39 <ski> (i meant init,tail shrinking seems a bit simplistic)
10:12:46 <bring> have you all read "A Haskell Lover's Plea"?
10:12:57 <shapr> no?
10:13:01 <shapr> hei esap 
10:13:11 <esap> hei shae!
10:13:17 <shapr> what's up?
10:13:18 <tic> QuickCheck, isn't that Hughes' work?
10:13:21 <ski> bring : i've
10:13:23 <shapr> tic: yes
10:13:28 <tic> schwee :)
10:13:32 <ski> tic : and Koen Claessen
10:13:37 <tic> aha
10:13:49 <esap> shapr: not much, I'm thinking of what to do next for my compiler.
10:15:00 <ski> btw, does QuickCheck currently have a way of showing randomly generated functions ?
10:15:11 <ski> (i guess not)
10:15:14 <shapr> I don't think so.
10:16:31 <ski> that could probably be useful/interesting/hard work :)
10:18:22 <bring> I'll bug John some more about it and offer to help if need be
10:18:29 <ski> shapr : perhaps lambdabot should have some @greet-newbie thing ;)
10:18:49 <bring> and keep a list of regulars?
10:18:54 <ski> maybe
10:19:25 <bring> or interpret the questions people ask to assess their haskell confidence level
10:19:31 <shapr> yes, the bot on #joiito does that, I'd like to have the same functionality.
10:20:08 <ski> (i guess i was mostly thinking of "@greet RandomNewbie","@auto-greet True", ..)
10:20:24 <shapr> bring: you write that one ;-)
10:20:37 <ski> bring : interpreting is harder, of course
10:21:32 <bring> weel, we cound look for fragments that parse as haskell, then do some metrics on that
10:21:56 <ski> @auto-greet would probably require some memory/list of regulars and people it has encountered before
10:21:56 <lambdabot> Sorry, I don't know the command "auto-greet", try "lambdabot: @listcommands"
10:22:11 <bring> like the highest-order function used or something :)
10:22:15 * ski laughs
10:23:17 <shapr> so, you're going to add persistent state to @type, and it records the highest-order parameter from a certain user?
10:23:31 <ski> it could perhaps also look if the person is in #ocaml,#scheme and so on ..
10:23:39 <bring> yes, and it could add warning labels to comments, like: "Warning: Contains explicit quantification"
10:23:44 * shapr laughs
10:24:29 <bring> actaully, that would be useful for haddock to generate
10:25:12 <bring> instead of using "portable" / "non-portable" in the module comments
10:26:10 <bring> maybe the bot could ask newcomers something to the effect of "what is the type of uncurry (+)"
10:26:16 <bring> or something like that
10:26:30 <ski> scaring them away ?
10:26:31 <shapr> what is your quest? ;-)
10:26:35 <bring> :)
10:26:39 <shapr> what is your favorite function?
10:26:47 <bring> undefined
10:26:50 <ski> it could ask a regular that, when a newbie enters !
10:26:56 <shapr> what's the Big O complexity of System F-omega?
10:27:00 <shapr> aieee!
10:27:17 <ibid> shapr: how do you define complexity of a system?
10:27:29 <bring> how long it takes to understand
10:27:33 * ibid only knows complexity of an algorithm...
10:27:34 <shapr> I don't know that! aieeee!
10:27:34 <ibid> heh
10:27:36 <ski> haha
10:27:44 <shapr> ibid: that was perfect :-)
10:28:02 <_Codex> a set of strings of symbols.
10:28:11 <shapr> hi _Codex 
10:28:18 <_Codex> hellos shapr.
10:28:22 <shapr> what's up?
10:28:31 <_Codex> I'm on holiday this week.
10:29:32 <Maddas> shapr: up is a preposition!
10:29:48 <ski> @greet-option style shapr
10:29:48 <lambdabot> Sorry, I don't know the command "greet-option", try "lambdabot: @listcommands"
10:29:49 <bring> haha
10:29:51 <shapr> Maddas: oh, good answer.
10:29:56 * shapr laughs
10:34:52 <keverets> hmmmhas anyone gotten fgl to compile with a debian package of ghc-6.2?
10:42:51 <jameson> The ghc homepage lists the STG paper plus some RTS updates as a description of the ghc execution model. Do these two docs give an accurate account of how 6.2 works?
10:45:18 <shapr> jameson: the eval/apply stuff may also be important
10:46:42 <keverets> I keep getting things like "Failed to load interface for `Data.Graph.Inductive.Graph'", but it should be generating those, no?
10:47:13 <shapr> keverets: are you using the aetion.com version of FGL?
10:47:28 <jameson> shapr: Are there docs on this?
10:47:30 <keverets> shapr: from http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
10:47:46 <shapr> keverets: there's a later version
10:48:01 <shapr> jameson: SPJ's papers, he presented one of them at ICFP2003
10:48:38 <shapr> jameson: I don't know if there's any comprehensive reference or listing anywhere.
10:48:55 <jameson> shapr: I'll have a closer look at his homepage. Thanks!
10:49:00 <shapr> sure
10:49:19 <shapr> keverets: look for FGL in the mailing list archives, end of last year I think?
10:49:30 <shapr> anyways, Isaac Jones was posting about it, that should be a good google term
10:49:37 <shapr> oh, I think the latest FGL is in hslibs too
10:50:32 <shapr> yah, the win32 people were complaining about a directory named Aux (aux: is still significant to win32)
10:51:11 <keverets> shapr: what am I looking for?
10:51:19 <keverets> (in the mailing list)
10:51:33 <shapr> the url to the latest version of FGL that works with ghc 6.2 ?
10:55:36 * ski huh!s
11:00:31 <ski> hi again, egorick
11:07:29 <keverets> what is hslibs?  where do I get it?  where can I read about it?
11:07:37 <keverets> google is not my friend for this.
11:09:53 <shapr> it's a big cvs repo
11:10:05 <shapr> it holds ghc, lots of libraries, all sorts of stuff.
11:10:13 <Igloo> Isn't hslibs just the deprecated part?
11:10:22 <Igloo> Or does it have multiple meanings?
11:10:24 <shapr> oh right, I'm thinknig fptools
11:10:30 <shapr> sorry, it's been a long day :-)
11:10:41 <shapr> %-)
11:10:58 <Igloo> :-)
11:12:25 <shapr> keverets: cvs.haskell.org in fptools/libraries/fgl
11:12:55 <shapr> and I can probably scrape out just the FGL directory into a tgz
11:14:35 * shapr scrapes
11:15:40 <shapr> Igloo: does a login on haskell.org mean I can make real cvs checkout now?
11:16:58 <Igloo> Not sure what the perms are like - I think the public one is faster anyway, so probably easier to use that if you don't need to be up-to-the-minute
11:17:07 <shapr> ok
11:17:08 <Igloo> I suspect you can, though
11:17:59 <shapr> keverets: ok, I just threw the fptools/libraries/fgl subdir into this, so it may not be correct: http://shapr.homelinux.net/~shae/fgl.tgz
11:18:33 <shapr> keverets: tell me if you have any problems
11:19:23 * Igloo isn't sure if you will need the mk or tools bits too
11:19:32 <keverets> looks like it.
11:19:39 <keverets> make
11:19:39 <keverets> Makefile:4: ../mk/boilerplate.mk: No such file or directory
11:19:39 <keverets> Makefile:24: ../mk/target.mk: No such file or directory
11:31:41 <shapr> hi edwinb 
11:32:29 <edwinb> hello
11:32:34 <shapr> looking for Haskell info?
11:33:09 <edwinb> Just discovered this channel existed so thought I'd drop in...
11:33:21 <norpan> welcome
11:33:26 <shapr> oh, you're an experienced Haskeller?
11:33:47 <edwinb> Well, I use it all the time. Wouldn't claim "experienced" though.
11:34:58 <shapr> oh, what do you use it for?
11:35:31 <edwinb> There's a short answer and a long answer ;)
11:35:39 <shapr> oh, I want to hear both!
11:35:44 <edwinb> The short answer is that I'm a type theorist and I hack theorem provers.
11:35:50 <ski> cool !
11:35:52 <_Codex> wow
11:35:57 <shapr> keverets: http://shapr.homelinux.net/~shae/fptools.tgz
11:36:00 <shapr> nifty!
11:36:03 <edwinb> The long answer is my draft thesis ;)
11:36:06 <norpan> typteori minsann
11:36:11 <Maddas> edwinb: heh
11:36:15 <Marvin--> edwinb: heh :)
11:36:41 <_Codex> edwinb: what area of type theory? (I
11:36:43 <edwinb> We're into dependent types here...
11:36:56 <Marvin--> what theorem provers do you hack?
11:37:14 <shapr> keverets: once again, tell me if you have any problems
11:37:25 <keverets> shapr: will do.  Thanks.
11:37:31 <shapr> :-)
11:37:37 <edwinb> I ended up writing one to play with some ideas about compiling dependent types, so none that anyone actually uses...
11:38:20 <Marvin--> edwinb: my master thesis is about using FOL theorem provers for proving stuff about haskell programs</shamelessplug>
11:38:45 <edwinb> Cool. Which ones?
11:39:12 <Marvin--> I've mainly been working with E, but also with Vampire, Otter and Gandalf
11:40:07 <edwinb> Right. I know a bit about Gandalf, not much about the others.
11:40:56 <_Codex> edwinb: sounds interesting. (we've looked here about using category theory to do typing -- and some curry-howard isomorphism etc.)
11:41:17 <edwinb> I run away from category theory ;)
11:41:37 <edwinb> I probably shouldn't though...
11:41:50 <Marvin--> that makes two of us
11:42:02 <shapr> the more I read about CT, the simpler it looks.
11:42:28 <edwinb> People tell me that it's really all about the notation - concepts I understand, but notation I'm not familiar with.
11:42:29 * ski scares edwinb and Marvin-- with a big confusomorphism !
11:42:36 <shapr> oh, that's a good name!
11:42:42 <edwinb> heh
11:42:49 <Marvin--> eek
11:43:15 <jlouis> confusomorphism. What is that?
11:44:05 <ibid> lol
11:44:26 <ibid> jlouis: it's a confusing morphism :)
11:44:50 <ibid> (ie. a morphism whose function is to confuse)
11:45:10 <ibid> (or a morphism that is confusing)
11:45:41 <_Codex> edwinb: recommend us some good papers about typing you've read?
11:45:47 <jlouis> So, I can pick any of endo, auto, iso, homo, homeo and a bunch of others?
11:46:07 <jlouis> the Fundeps paper is an easy read
11:46:11 <edwinb> What sort of things are you looking for? General overview of dependent types?
11:46:18 <shapr> greetings djw, looking for Haskell info?
11:46:51 <edwinb> There's a recent JFP paper "The view from the left" which basically describes what we do.
11:46:51 * djw hides and cowers in the corner
11:47:00 <_Codex> edwinb: naah, something more interesting.
11:47:04 <ibid> i thought typing went out of fashion when computers became commonplace in the office ;)
11:47:23 <_Codex> edwinb: I'll read that and tell you what I think about it.
11:47:23 <ski> (hmm, thought i'd seen something like "Confusomorphisms for dummies", but can't remember where :( )
11:47:25 <shapr> djw: is that a no? :-)
11:47:39 <edwinb> View from the left then ;).
11:47:46 <djw> shapr: I'm just lurking really ;)
11:48:12 <edwinb> McBride's "First order unification by structural induction" is a nice intro to our philosophy too.
11:48:38 <edwinb> And "Faking It", also McBride, describes some entertaining abuse of the Haskell class system.
11:48:52 <shapr> djw: ok, if you come up with questions, feel free to ask.
11:49:01 * esap found lots of republican politics articles with the name 'the view from the left'.
11:49:08 <djw> shapr: I probably will at some time in the future :)
11:49:08 * esap used google.
11:49:15 <edwinb> Yes, I found that. SLightly worrying really...
11:52:16 <shapr> hm, do I write Haskell or watch a movie?
11:52:45 <_Codex> shapr: depends on the movie.
11:53:55 <Marvin--> these days, I find the name "McBride" slightly worrying ;)
11:53:59 <shapr> I still haven't seen 'Bad Luck Love'
11:54:09 <edwinb> Marvin--: Yeah, it's not that one though ;)
11:54:23 <ski> ((m :: Movie) -> Should I (Prefer (Watch m) (Coding Haskell)))
11:54:53 <shapr> ohh, I could try out kimbly's inverted index, see if it works for email searching.
11:56:25 <keverets> hmm... make: *** No rule to make target `../../mk/config.h.in', needed by `../../mk/config.mk'.  Stop.
11:56:35 <keverets> config.status: error: cannot find input file: mk/config.h.in
11:57:40 <shapr> :-(
11:58:23 <shapr> SyntaxNinja: y0, you got a minute? where's a ghc-6.2 compatible release of FGL?
11:59:03 <SyntaxNinja> shapr: Hmm. I guess you could get it from ghc's CVS
11:59:25 <SyntaxNinja> not sure that there's been a release or anything.
12:00:19 <shapr> does the Makefile do tricks? or would it work to just throw the sources into my include path?
12:02:47 <_Codex> edwinb: so you're doing pattern matching? (view from the left seems to be all about pattern matching..)
12:04:39 <SyntaxNinja> shapr: should be pretty portable.
12:05:01 <edwinb> That's part of it, yes - allowing new pattern matching behaviour (rather than the usual matching on constructor forms only)
12:05:02 <SyntaxNinja> shapr: I could send you our tarball too, but I don't know if it'll be the same exactly as what's in ghc's CVS (there will definitely be small changes)
12:05:17 <shapr> yes please!
12:05:36 <shapr> if it's not too much trouble.
12:06:49 <edwinb> _Codex: Perhaps more important than the pattern matching is the kind of types we allow - explicit invariants that can be checked, that sort of thing.
12:09:35 <SyntaxNinja> shapr: http://www.syntaxpolice.org/tmp/fgl.tgz
12:09:39 <shapr> yay!
12:09:55 <shapr> keverets: that url just pasted is likely to work.
12:17:15 * Marvin-- swears over gandalf's lack of useful error messages
12:17:29 * shapr advertises Haskell on #plone
12:18:06 <ski> what's plone ?
12:18:21 <shapr> it's a content management system, it's what I get paid to work with.
12:18:42 <ski> ok
12:18:50 <shapr> for example, here's the site we haven't quite finished: http://august.fim.uni-erlangen.de/alis/
12:18:55 <edwinb> One of the plone team is a student here at Durham. I found him hacking a type system in Haskell in labs once last year...
12:19:32 <edwinb> Apparently our usual questions were too dull for him ;)
12:19:50 * esap is trying to build a type system in Haskell.
12:20:14 <shapr> edwinb: Joe Geldhart?
12:20:21 <edwinb> Actually, I can't help noticing he lives on this channel too...
12:20:26 <shapr> aka Arnia?
12:20:32 <edwinb> yeah ;)
12:21:05 <SyntaxNinja> yay! my blog is on planet debian now! http://planet.debian.net
12:21:32 <Marvin--> we need a planet debian planet too
12:22:10 <SyntaxNinja> if only there were .planet TLDs
12:22:17 <SyntaxNinja> some day...
12:24:37 <edwinb> must go. cheerio. nice to meet you all!
12:24:43 <shapr> cya!
12:25:08 <_Codex> edwinb: see you later.
12:25:41 * shapr yawns
12:25:47 <shapr> SyntaxNinja: that's cool!
12:28:25 * bring realizes SyntaxNinja is the LIP project leader 
12:28:26 <bring> SyntaxNinja: what are your thoughts on having a central respository for various unofficial community-supported libraries
12:29:30 <ski> bring : LIP ?? (doing lip service ??? :)
12:29:32 <SyntaxNinja> bring: i like that idea.  I've been actively supporting it :)
12:29:43 <ski> (oh, library infrastructure project, nevermind)
12:29:59 <SyntaxNinja> especially if we're talking about gforge
12:34:42 <bring> shapr and I have been talking about using haskell-libs at sourceforge
12:36:30 <SyntaxNinja> despite all the argument, I still think gforge.haskell.org is the best of all worlds, except that it's somewhat harder to maintain.
12:41:31 <bring> I'm not familiar with gforge at all, what are the advantages to using SourceForge (more control I guess since we'd run the site ourselves, but what else)?
12:42:04 <bring> that should probably be "compared to using SourceForge"
12:42:09 * Igloo ponders setting up a darcs repo
12:42:21 <Igloo> (unrelated to the curent discussion)
12:51:59 <SyntaxNinja> bring: controlling it ourselves, we could have a darcs repository (for instance), no advertising, easier to use (I think the ads have a big effect on usability, btw).  I also think that the "club house" factor is involved here.  Since it's OURS, people will be more likely to use it, IMO.
12:52:28 <SyntaxNinja> I guess the real question would be "why aren't ppl using sourceforge already" or "if they're not using SF, why would they use projects.haskell.org" or whatever.
12:53:18 <bring> actually my main intrest in it is getting somewhere to put stuff that I'm maintaining
12:55:03 <bring> (and making it possible for other to do the same)
12:55:41 <bring> the main problem with haskell-libs at SF right now seems to be that the repository is unoorganized
12:56:15 <bring> but I don't really care if it's SF och gforge.haskell.org, as long as it works
12:56:23 <bring> s/och/or/
12:56:56 <SyntaxNinja> yeah.makes sense.
12:58:36 <bring> since there's no gforge.haskell.org right now, we can always go with SF and move later
12:58:59 <SamB> SyntaxNinja: sourceforge doesn't have that home-grown feel?
13:02:11 <SyntaxNinja> SamB: I'd agree with that.
13:21:36 <cm> herro
13:23:58 <ski> herro see em
13:24:31 <cm> hi ski :)
14:15:05 <earthy> ah, *good*. Bram responded with some trivialities to fix
14:15:29 <earthy> i.e., as of tomorrow the latest'n'greatest vims will carry new syntax highlighting for Haskell. :)
14:15:57 * Igloo rejoices quietly in the corner
14:16:19 <amb_> Yay!
14:16:38 <earthy> anyway, off to bed.
14:16:49 <earthy> (after some Borges and whiskey :))
14:19:22 <blackdog> ooh, go into that labyrinth and you may never return :)
14:20:12 * shapr yawns
14:21:30 * Igloo bounces
14:22:17 * cm meeps at shapr
14:22:38 * shapr speems back
14:22:57 <cm> :)
14:23:53 * bring wanders off into the darkness
14:24:20 <blackdog> make sure to send us a postcard...
14:24:22 <shapr> it's time for sleep for me.
14:24:23 <ski> bring : watch out for grues !
14:24:40 <shapr> you're in a maze of twisty little research papers, they all look the same.
14:25:08 <blackdog> think i left the sauna on, my thesis is on fire
14:25:28 * shapr laughs
14:25:40 <whee> indeed.
14:26:33 <SamB> shapr: in that case, only read one of them!
14:27:22 <cm> nn shapr
14:29:15 <ski> cm : nn ?
14:30:52 <blackdog> night-night?
14:37:38 <mgoetze> blackdog: sauna? in .au?
14:39:04 <Riastradh> Isn't .au a sauna itself?
14:39:07 * Riastradh ducks.
14:39:55 <mgoetze> i've been to a sauna today, and you? :)
14:48:57 <blackdog> we have saunas. (saunae? Oh no, there I go inappropriately latinising again...)
14:49:42 <blackdog> and, yes, in Brisbane it's been breaking 40C. thank god i'm a sydney boy.
14:50:19 <cm> ski: night night, yeh..
15:44:53 <ski> Elimination rules tell us how we may exploit hypotheses in the course of a proof. Many common elimination rules, such as tex2html_wrap_inline97 and the induction principles for inductively defined datatypes and relations, are parametric in their conclusion. We typically instantiate this parameter with the goal we are trying to prove, and acquire subproblems specialising this goal to particular circumstances in which the eliminated hypothesis holds. Th
15:44:53 <ski> Elimination rules tell us how we may exploit hypotheses in the course of a proof. Many common elimination rules, such as tex2html_wrap_inline97 and the induction principles for inductively defined datatypes and relations, are parametric in their conclusion. We typically instantiate this parameter with the goal we are trying to prove, and acquire subproblems specialising this goal to particular circumstances in which the eliminated hypothesis holds. Th
15:45:10 <ski> oh, so sorry about that
15:45:27 * ski is ashamed
15:49:04 <blackdog> why won't somebody think of the electrons?
15:50:19 <ski> ?
15:51:33 <blackdog> the electrons you callously doomed by pasting profligately...
15:52:02 <ski> how did i doom them ?
15:52:35 <ski> you mean they don't exist as electrons anymore ?
15:53:06 <blackdog> well, in the strictest sense, I suppose you didn't. I'm sure they were dreadfully inconvenienced, though.
15:55:04 <Pseudonym> I fear for the wasted bits.
15:55:19 <Pseudonym> The heat-death of the universe will surely be closer.
15:55:37 <blackdog> 'zackly. a bit here, a bit there, pretty soon you're talking about real entropy
15:55:51 <Pseudonym> Don't argue with thermodynamics.
15:56:12 <blackdog> thermodynamics will throw down!
15:56:21 <amb_> bye
15:56:44 <blackdog> oh dear. i'm scaring the serious people off. if only i had something relevant to post...
15:56:45 <ski> can we speed up entropy increase ?
15:57:00 <blackdog> we could use perl...
15:57:07 <Pseudonym> Sure, let me just stir the photons a bit.
15:57:10 <ski> cheat
15:57:15 <ski> hmm
15:57:54 <ski> is there real, effective entropy increase that wouldn't have occured in some other way ?
15:59:20 <Pseudonym> Not really.  Even if you hadn't pasted that, we'd still be jabbering about something.
15:59:46 <Pseudonym> It's like World War 1.  It was an entropy leap just waiting to happen.
15:59:57 * ski probably shouldn't try to compose deep philosophical, ontological and physical questions in this late time ..
16:01:38 * Pseudonym shouldn't try to compose deep philosophical, ontological and physical questions ever, as it always ends up with embarrassment
16:01:55 <ski> heh
16:02:40 <SamB> serious people are disturbing
16:03:05 <SamB> if by serious you mean "has no sense of humour"
16:03:23 <ski> not HHOS, then ?
16:03:26 <Pseudonym> There is a time to be serious and a time to be silly.
16:03:35 <Pseudonym> I think it's from Ecclesiastes.  Or possibly The Byrds.
16:05:58 <SamB> Pseudonym: well, I know it's in there somewhere, or at least very strongly implied.
16:12:24 <Pseudonym> I think it also mentions that there is a time for imperative programming and a time for declarative programming.
16:12:48 <Pseudonym> King Solomon was very wise, and quite ahead of his time.
16:43:34 * Cale is away: shower, homework.
16:51:39 <Pseudonym> Got to be clean to do homework.
16:54:58 <blackdog> Really? I always thought you had to be clever to shower...
16:55:34 <Pseudonym> Doing homework doesn't make you clever.
16:55:51 <Pseudonym> Arguably, not doing homework is a sign of higher cleverness.
16:56:42 <blackdog> Wow. Really? I wish I'd tried that line with my teachers.
16:57:04 <Pseudonym> Well you don't need to do homework if you're clever.
16:57:12 <blackdog> I might have got fewer "Mark's quite bright but a lazy little ****" report cards.
16:57:28 <Pseudonym> :-)
16:57:37 <Pseudonym> I got quite a few of those, too.
16:58:05 <Pseudonym> If you're REALLY clever, you can convince some teachers that they lost your homework.
16:58:13 <Pseudonym> I got away with that at least twice.
16:58:51 <blackdog> we had a twin grading system - ABCD for quality of work, and +,(nothing),- for effort. I think I was more proud of my "A-"s than anything else
16:59:10 <blackdog> neat trick.:)
16:59:24 <Pseudonym> You can't do it often, and you have to pick your mark carefully.
17:09:30 <Pseudonym> Note to any lawyers present: I am not condoning lying to teachers.
17:10:20 <blackdog> lucky you're writing under a pseudonym, hm?
17:13:31 <viblo> woah, netsplit :/
20:09:01 * ozone giggles
21:46:20 <shapr> good morning #haskell!
21:46:48 <Pseudonym> G'day.
21:47:20 <ski> morn' shapr
21:47:55 <shapr> what's going on?
21:48:20 <jameson> Good evening.
21:50:27 <ozone> sup shapr
21:50:52 <shapr> there's light outside, I'm glad the dark winter is nearly over.
21:51:01 <shapr> I hear .au is nice and cool.
21:51:26 <Pseudonym> It is cool at the moment.
21:51:29 <Pseudonym> .au is a big place, though
21:51:31 <ozone> well, it's raining in sydney right now
21:51:38 <Pseudonym> Brisbane is in a heat wave, isn't it?
21:51:48 <ozone> yeah
21:51:48 <Pseudonym> Or did that end a day or two ago?
21:52:07 <Pseudonym> It's like saying "mainland USA is nice at the moment".
21:52:13 <shapr> yah, I know :-)
21:52:46 <shapr> hey I have a cvs question
21:53:05 <shapr> I'd like to reorganize haskell-libs, but I'm not sure how to do it.
21:53:37 <shapr> a separate top level cvs module for each major application and library would make versioning and releasing easier.
21:54:05 <shapr> but too many pieces would mean lots of separate checkouts/download to get a single thing working.
21:54:08 <shapr> Any suggestions?
21:54:23 <ozone> shapr: provide an umbrella module?
21:54:37 <shapr> can I alias stuff in cvs?
21:55:01 <shapr> or can I checkout a subset of the entire tree?
21:55:34 <shapr> I'd like to make it as easy as possible to glue the sources into the hierarchical lib structure.
21:57:07 <ozone> shapr: yeah, i think you put a 'U' identifier in the modules file, or you can use &
21:57:13 <ozone> check out the cederqvist
21:57:19 <shapr> ok
21:57:30 <ozone> (that's what we do)
21:58:09 <ozone> coffffeeeeeeee
22:28:55 <bring> shapr: some suggestions from Graham: should there be a common (BSD-style presumably) license for modules in the new haskell-libs (for uniformity and possibility of inclusion into the official libraries)?
22:28:58 * Pseudonym is playing with GTK+
22:29:17 <Pseudonym> I choose the MIT licence.
22:29:31 <Pseudonym> I usually use that if I think it might end up in a standard library.
22:29:36 <Pseudonym> (Which none of my code has so far.)
22:30:07 <bring> isn't that the same as the BSD-style license used by GHC etc.?
22:30:51 <Pseudonym> It's spelled differently, but otherwise, yes.
22:33:26 <bring> do you think anyone would be discourage from contributiong a library by having to use a common license?
22:33:52 <bring> (MIT / BSD - style)
22:35:51 <bring> shapr: also, would you be the person for new contributors to contact to get wrtie access?
22:47:24 <shapr> bring: I can give write access to haskell-libs.sf.net, but I have no influence over the standard libs
22:49:06 <liiwi> good morning
22:49:06 <shapr> bring: I'd like to limit haskell-libs to DFSG compatible licenses, other than that I don't mind.
22:49:09 <shapr> hei liiwi 
22:49:30 <shapr> I wonder if Graham does irc.
22:54:17 <shapr> oy, time for class.
22:54:20 * shapr disappears
23:13:30 <Pseudonym> Must away.  Nytol
