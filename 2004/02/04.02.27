00:53:28 <creature> Is there a good doc on functors anywhere? 
01:54:26 * earthy yawns
01:54:33 <earthy> anybodye here know the incubation period for the common cold?
01:56:15 <earthy> ah, on the order of 48 hours... that fits.
01:56:25 * earthy thanks kosmikus. :)
01:57:16 <earthy> err... nope. that was last week... or was it?
01:57:21 <earthy> ah heck. :)
02:40:34 <_Codex> data T = T { d :: Int, e :: Int }; I wonder if it'd be reasonable to generate d::Int->T and e::Int->T functions for each such data.
02:44:41 <ibid> there already are d::T->Int and e::T->Int
02:45:24 <_Codex> yes, the destructors. I was thinking about inverses of the destructors.
02:47:59 <_Codex> To me, its a little strange that there's one constructor T, but several destructors. I never really got that concept..
02:51:07 <earthy> ummm... how would you define d::Int -> T?
02:51:17 <earthy> what would the value of e become?
02:52:10 <Heffalump> _codex: the datatype maps many values to one value
02:52:18 <Heffalump> so it's natural that there's one constructor but many destructors
02:52:44 <_Codex> earthy: the function would need to keep some data inside. i.e. f d = T d 10
02:56:02 <earthy> okay, that doesn't make sense
02:56:50 <earthy> what d are you talking about now, and what is its type? and how would that type fit as an argument to T?
02:59:04 <_Codex> d is Int in the lastest example.
02:59:48 <earthy> ah, 'kay, and f would be your constructor?
03:00:01 <_Codex> f :: Int -> T
03:00:25 <earthy> then what is the argument for not typing it f :: Int -> (Int -> T) ?
03:00:35 <earthy> where f d = \x -> T d x  ?
03:00:56 <earthy> and g :: Int -> ( Int -> T)  where  g d = \x -> T x d   ?
03:01:13 <earthy> trouble is: people 'll want it both ways
03:01:25 <earthy> thus, let them define their own sugaring the way they like it
03:01:33 <earthy> not at all hard (as you can see)
03:01:55 <earthy> languages should provide mechanism, not policy.
03:11:02 <_Codex> All this craziness came from me trying to think how to encode x+y = u+v to haskell. Could do + and = as constructors and encode it as data. (trying to do negative numbers from N)
03:25:01 <tic> heya guys, anyone alive?
03:25:49 <_Codex> tic: not alive, just on last day of the holiday..
03:26:00 <tic> heh, okay.
03:26:05 <earthy> codex: so you're drunk and hungover? :)
03:26:14 <earthy> (trust me, that is possible ;))
03:26:40 <_Codex> recardless of what I said above -- nope, I dont think so.
03:26:46 * earthy grins
03:26:56 <earthy> you weren't gabbling nonsense
03:28:27 <_Codex> its been fun holiday -- got absolutely nothing done.
03:30:16 <earthy> that is very useful at times
03:32:16 <_Codex> though I managed to read "numbers" chapter from Axiomatic set theory -book. That's useful.
03:33:21 <earthy> there is this theory I have: if you seem to be getting nothing done, but still enjoying what you do, you're usually getting something done that you wouldn't at first think is useful but in retrospect seems perfectly chosen
03:33:24 <_Codex> The book shows how to build N, Z, Q and R and all the abstraction layers between them.
03:34:23 <earthy> i.e.: gives axiomatizations in set theory?
03:35:15 <_Codex> yes, the book started from set theory axioms and then eventually manages to build numbers.
03:35:48 <earthy> using peano-like constructions for N, Z and Q I'd imagine
03:35:59 <earthy> and functions for R
03:36:09 <_Codex> yes
03:36:29 <earthy> where functions are again defined in terms of sets
03:36:35 <earthy> very useful ideas there ;)
03:37:48 <_Codex> I'm still a little unsure how to implement equivalence classes.
03:39:23 <_Codex> All of the numbers construction relies on equivalence classes -- but encoding "generic" equivalence classes seems always problematic -- always get several representations of the same thing and strange reductions.
03:43:19 <_Codex> for example, fractions have this 1/2 = 2/4 = 3/6  -equivalence. That gives reduction 2/4 => 1/2... And that leads to gcd(2,4)=2.. I.e. very complex things come from simple equivalence...
03:45:39 <ski> _Codex : you're implementing rationals ?
03:46:21 <_Codex> ski: eventually yes. Need to understand them first.
03:46:27 <ski> heh
03:47:15 <ski> they are a retract of product of Integer and NonZeroInteger
03:47:30 <ski> (that was category-theory-speak :)
03:51:15 <_Codex> ski: how does that category theory def of yours handle  a/b = ap/bp :-)
03:51:43 <ski> the equivalence class ?
03:51:59 <_Codex> yes.
03:52:30 <ski> well, first we define an idempotent over the integer pairs
03:53:03 <ski> it is "divide numerator and denominator with gcd(numerator,denominator)"
03:53:24 <ski> see that this is an idempotent ?
03:53:46 <_Codex> no, I dont know category theory that well. :(
03:54:21 <ski> f is an idempotent means that, for all x in the domain of f, f(f(x)) = f(x)
03:54:34 <ski> that's just standard math terminology
03:54:39 <_Codex> oh ok.
03:55:09 <ski> so this idempotent is the function that e.g. takes (15,10) to (3,2), ok ?
03:55:38 <ski> so it "shortens" the rational pair-representation
03:56:02 <ski> (i.e. such that gcd(numerator,denominator) = 1)
03:56:23 <_Codex> makes gcd(a,b) smaller by dividing it.. (might take to 1 directly if possible)
03:56:24 <ski> gcd = greatest common divisor, or something like that
03:56:37 <ski> yeah
03:56:56 <ski> if we call the idempotent shorten, then it's defined like
03:57:25 <ski> forall n,d  shorten(n,d) = (n/f,d/f)  where f = gcd(n,d)
03:57:28 <ski> right ?
03:57:52 <_Codex> yes.
03:58:42 <ski> so, if you apply this function twice (succesively) to an integer-pair, you get the same as only applying shorten once to it, right ?
03:58:57 <_Codex> right.
03:59:18 <ski> ok, so it is an idempotent (by above def of idempotent)
03:59:30 <_Codex> oh, thats where you get f(f(x)) = f(x) :)
03:59:56 <ski> i.e. it always suffices to apply it once to a pair, we don't get anything new by applying it again
03:59:59 <ski> yes
04:00:08 <ski> another way of saying that is that
04:00:33 <ski> f is an idempotent, if for every x (in f's domain), f(x) is a fixed-point of f, right ?
04:00:57 <ski> i.e. we don't come any further than f(x) .., so to speak
04:01:32 <ski> well, perhaps that alternative def. is not so important here..
04:02:05 <_Codex> One thing I've been trying to do is show the behaviour of "shorten" in the type of it.. Instead of pair->pair, trying to have pair->Q -- that way you cannot apply it twice and need to destroy Q before you can use it again.
04:02:17 <ski> yes
04:02:44 <ski> shorten, sortof takes int-pair into a subset of int-pair
04:02:53 <ski> or, anyther way to look at it :
04:03:09 <ski> shorten takes int-pair into equiv-class of int-pair
04:03:13 <ski> right ?
04:03:42 <_Codex> yes. normal form uniquely identifies the equiv class members.
04:04:07 <ski> so Q is siomorphic to a sub-set of int-pair, and is also isomorphic to equiv-class of int-pair
04:04:27 <ski> (isomorphic, even)
04:05:21 <ski> mm ?
04:06:20 <ski> shall i continue some ?
04:06:28 <_Codex> sure.
04:06:31 <ski> ok
04:06:33 <_Codex> Its very interesting.
04:06:54 <ski> btw, first, do you know about function composition (i hope so)
04:06:56 <ski> ?
04:07:03 <_Codex> yes. f . f = f
04:07:21 <ski> yes so idempotent(f) <->  f . f = f
04:07:22 <ski> right
04:07:51 <ski> so, now we introduce section,retraction-pair :)
04:07:55 <ski> okay ?
04:08:28 <_Codex> sounds good.
04:08:33 <ski> ok
04:08:49 <ski> assume  s : A -> B  and r : B -> A
04:08:52 <ski> ok ?
04:08:57 <_Codex> I dont know what section, retraction pair is. Sounds to me like constructor-destructor pair, but... dunno.
04:09:10 <ski> i'm defining it now :)
04:09:16 <_Codex> great.
04:09:39 <ski> so first we assume that s goes from A to B, and that r goes from B to A
04:09:43 <ski> i.e.
04:09:51 <ski> s : A -> B  and  r : B -> A
04:09:54 <ski> ok ?
04:10:03 <_Codex> ok.
04:10:06 <ski> now
04:10:33 <ski> s and r is a section,retraction -pair if :
04:10:37 <ski> r . s = id
04:10:43 <ski> ok ?
04:10:44 <_Codex> s.r :: A->A ?
04:10:48 <ski> yes
04:10:57 <ski> so its actually id_A
04:11:03 <ski> no
04:11:09 <ski> r.s :: A->A
04:11:25 <_Codex> oh, "inverses cancel". Sounds good.
04:11:30 <_Codex> yes, r.s
04:11:38 <ski> yes, but only in one direction
04:11:48 <ski> i.e. not (necessarily)  s.r = id
04:12:08 <ski> the s is called a section (of r)
04:12:18 <ski> and the r is called a retraction (of s)
04:12:29 <ski> (there are reasons for these names, btw)
04:13:04 <ski> also : A is called a retract of B,  if there exists such a section,retraction -pair
04:13:29 <ski> that was the def. + term. for retracts
04:13:31 <ski> ok ?
04:13:50 <_Codex> ok.
04:13:52 <ski> ok
04:14:03 <ski> now simplify   s.r.s.r  ! :)
04:14:13 <_Codex> id.id = id
04:14:15 <ski> (recall r.s = id_A)
04:14:18 <ski> no !
04:14:32 <ski> we dont' know if s.r = id
04:14:39 <ski> we know that r.s = id !
04:14:45 <_Codex> oh, you had it wrong way :(
04:15:00 <ski> me ?
04:15:13 <_Codex> s.r.s.r = s.id.r 
04:15:13 <ski> oh, right, i get what you mean ..
04:15:17 <ski> yeah
04:15:20 <ski> which is ?
04:15:27 <_Codex> s.r
04:15:30 <ski> yes !
04:15:35 <ski> so s.r.s.r = s.r
04:15:44 <ski> or (s.r).(s.r) = s.r
04:15:49 <ski> what does that mean ?
04:15:56 <ski> :)
04:16:06 <_Codex> f.f = f
04:16:09 <ski> yes
04:16:15 <ski> s.r is an idempotent
04:16:23 <ski> and we can define  f = s.r
04:16:29 <ski> so f is now an idempotent
04:16:40 <ski> ok ?
04:17:29 <_Codex> so, its required that r . s = id to get all that?
04:17:37 <ski> yes sire
04:17:53 <_Codex> nice.
04:18:16 <ski> do you want a more concrete example of such a s,r -pair ?
04:19:02 <ski> well ?
04:19:27 <_Codex> ski: yes. But doesnt every "=" give you such a pair?
04:19:28 <creature> What makes an expression well-typed?
04:19:44 <ski> creature : if it has a type :)
04:20:02 <ski> creature : or if the (formally defined) typesystem accepts it :)
04:20:06 <_Codex> ski: I mean, if A=B, then s: A => B and r:B=>A and r.s = id?
04:20:32 <ski> yes if A=B (or even just isomorphic)
04:20:47 <creature> ski - well, I've got a couple of custom datatypes here, and the question "Evaluate the expression fmap (+half) (Node [Leaf 3, Leaf 4]). Briefly discuss why this expression is well-typed."
04:20:48 <ski> then s,r is such a pair, and also r,s is such a pair
04:20:53 <creature> And am not really sure what it wants from me. :/
04:21:32 <ski> but it's a bit more interesting if A isn't isomorphic to B
04:22:12 <ski> creature : hmm, perhaps they want you to realize/say something about haskells polymorphism (of lists and trees e.g.)
04:22:18 <ski> _Codex : ok ?
04:22:26 <_Codex> ski: ok, lets continue.
04:22:36 <ski> ok
04:22:46 <ski> so i take a concrete example, then
04:23:21 <ski> let B, be the set of (people) members of USA, e.g.
04:23:56 <ski> and let A be the set of people, such that exactly one person comes from each (electorial) district
04:24:14 <ski> so A is a subset of B, in this case
04:24:19 <ski> ok ?
04:24:23 <_Codex> ok.
04:24:45 <ski> so now we define s and r
04:24:55 <ski> s is just an inclusion function
04:25:16 <ski> i.e. given a representative in A, it gives the same person, but now in the larger B
04:25:25 <ski> ok ?
04:25:36 * mgoetze ponders whether the axiom of choice is needed to define set A like this
04:25:56 <_Codex> mgoetze: I dont think so.
04:25:59 <_Codex> ski: ok
04:26:16 <ski> mgoetze : hmm, i don't think they use AC in this basic category theory
04:26:33 <ham> hiho
04:26:44 <ski> r is the function that given a persons representative
04:26:50 <ski> ok ?
04:27:20 <ski> (s/given/gives/ !)
04:27:26 <_Codex> ski: I dont see how r.s = id?
04:27:50 <ski> well, we require that a representative's representative must be himself
04:28:08 <ski> (cause s/he must live in the district that s/he represents)
04:28:42 <ski> r.s = id means :
04:28:51 <ski> r(s(p)) = p   for all p in B
04:28:56 <ski> no
04:29:00 <ski> for all p in A
04:29:47 <ski> so, if we take a representative (in A), and then just include that person into B, using s, and then take that persons representative, by using r
04:29:53 <ski> then we get the same person !
04:29:56 <ski> ok ?
04:30:46 <_Codex> oh, now I see it -- since x :: A => x :: B...
04:30:52 <ski> yeah
04:31:08 <ski> so, thus  r.s = id_A
04:31:16 <ski> okay
04:31:30 <ski> what is f = s.r  (the idempotent), then ?
04:31:40 <ski> well we know that  f : B -> B   right ?
04:31:48 <creature> mgoetze!
04:32:00 <mgoetze> hiya
04:32:01 <ski> f(p) = s(r(p))
04:32:28 <_Codex> nice example.
04:32:50 <ski> for each person (in B), we take her/his representative (in A), and just include that representative (in A) into the set of persons (i.e. B)
04:32:52 <ski> ok
04:32:56 <_Codex> makes equivalence classes (and their representative elements) much clearer.
04:33:05 <ski> so this f is really an idempotent, right ?
04:33:07 <ski> yes
04:33:41 <ski> well ?
04:34:01 <ski> see that ?
04:34:10 <_Codex> yes
04:34:13 <ski> good
04:34:21 <ski> now we vary this example a little
04:34:23 <ski> :)
04:34:28 <ski> we change the set A
04:34:39 <_Codex> all we need is algorithm to find the normal form and we get the idempotent feature. :)
04:35:08 <ski> henceforth it is not a set a representatives, but it is a set of equivalence-classes (i.e. all persons living in each district)
04:35:10 <ski> ok ?
04:35:17 <ski> _Codex : yes
04:35:37 <_Codex> ok
04:35:39 <ski> ok
04:35:44 <ski> so what is r, now
04:35:47 <ski> r : B -> A
04:36:01 <ski> r takes a person and gives an equivalence class
04:36:04 <ski> which one ?
04:36:14 <ski> (easy)
04:36:17 <_Codex> r finds which district a person lives in
04:36:23 <ski> yea !
04:36:30 <ski> and what does s do now
04:36:34 <ski> s : A -> B
04:36:48 <ski> it takes an eqiuvalence class and gives a person
04:36:51 <ski> which person ?
04:37:01 <mgoetze> the canonical person :)
04:37:04 <ski> yeah !
04:37:15 <_Codex> finds representative of "forall x::A"
04:37:20 <ski> mm
04:37:37 <ski> note the difference between these two point-of-views !
04:37:56 <ski> before we had that s "didn't do any real work", it just included A into B
04:38:09 <ski> before r did the real work of selecting the representative
04:38:13 <ski> ok ?
04:38:30 <_Codex> ok
04:38:51 <ski> now r doesn't do much work. just gives the equivalence class that the person belongs to
04:39:09 <ski> but s selects a representative person from an equivalence class
04:39:15 <ski> o'kay ?
04:39:59 <ski> one can of course check that r.s = id and f = s.r is an idempotent in this second variant as well ...
04:40:39 <_Codex> ok -- amazing example :)
04:40:52 <ski> (we don't have to do that now, if you don't want to)
04:41:12 <ski> s/if/unless/  s/don't//
04:41:22 <_Codex> I think its clear we get idempotent..
04:41:23 <ski> yeah, isn't it :)
04:41:33 <ski> now we come to the next part
04:41:53 <ski> think of a generic "retract-system"
04:42:10 <ski> s : A -> B  ,  r : B -> A
04:42:22 <ski> r.s = id_A     idempotent(s.r)
04:42:28 <ski> ok ?
04:42:32 <_Codex> ok.
04:42:42 * earthy looks at ski do the teacher thing
04:42:47 <earthy> `wow'
04:42:53 <ski> now say that B and f = s.r is *known*
04:42:56 <ski> okay
04:43:02 <ski> (remember f : B -> b)
04:43:05 <ski> oh
04:43:09 <ski> f : B -> B
04:43:14 <ski> ok ?
04:43:33 <_Codex> ok.
04:43:43 <ski> fine, now look at this system as en *equation system*
04:43:57 <ski> we want to find solutions for A,s,r !
04:44:07 <ski> (given B,f)
04:44:13 <ski> o'kay ?
04:45:19 <_Codex> sounds difficult, but okay.. I bet you have some way to do that though.
04:46:16 <ski> now : given B and f  there exists an A, unique *upto* *isomorphism* 
04:46:30 <ski> (and corresponding s and r, also)
04:46:39 <ski> one can show this
04:47:14 <ski> do you know groups ?
04:48:06 <_Codex> which direction does the upto goes to? It somehow limits in which kind of situations we can find A?
04:48:25 <ski> (you could also say that there exists an isomorphism class of such triples of (A,s,r))
04:49:09 <ski> upto, just means that, if you are willing to consider isomorphic sets as equal, then there is a unique set
04:49:43 <ski> ok ?
04:50:35 <ski> (two sets being isomorhic if there exists an isomorphism between then. i.e. a bijection)
04:50:43 <ski> (a total bijection, of course)
04:51:30 <ski> earthy : heh :)
04:51:36 <_Codex> so, A and B need to be isomorphic? If not, then there isnt unique A found?
04:51:41 <ski> noo
04:52:10 <ski> perhaps we can find many A's (and corresponding s's and r's) satifying this "equation"
04:52:20 <ski> we can call them :
04:52:36 <ski> A0,s0,r0   A1,s1,r1   A2,s2,r2   and so on
04:52:40 <ski> ok ?
04:52:42 <_Codex> ok
04:52:57 <ski> (just like 0 * x = 0 has many solutions in x)
04:53:03 <ski> now, in this case
04:53:12 <ski> all of those are actually isomorphic
04:53:40 <ski> that is "abstractly the same", some people seem to say
04:53:47 <_Codex> so all the solutions of the equation are isomorphic?
04:54:12 <ski> do you know some group theory ?  (just for a very slim comparision)
04:54:15 <ski> yes
04:54:38 <_Codex> some, not too much. We might be lucky though.
04:55:04 <ski> ok, well, there are "exactly two" groups with four elements
04:55:26 <ski> "exactly two" here also means, considering isomorphic ones equivalent
04:55:42 <ski> one is
04:55:51 <ski> * | 0 1 2 3
04:56:02 <ski> --+--------
04:56:08 <ski> 0 | 0 1 2 3
04:56:12 <ski> 1 | 1 2 3 0
04:56:17 <ski> 2 | 2 3 0 1
04:56:23 <ski> 3 | 3 0 1 2
04:56:56 <ski> you can rename 0,1,2,3 to i,a,b,c if you want !,  that is isomorphism
04:57:24 <ski> oh, should really be +, in upper left corner
04:57:43 <ski> anyway, perhaps this doesn't help you much ...
04:58:02 <ski> anyway, all solutions of the equation previously are isomorphic
04:58:16 <ski> (that is "behaves the same on the outside")
04:58:54 <ski> hmm, still with me, here ?
04:58:56 <ski> :)
04:59:06 <_Codex> yes.
04:59:09 <_Codex> I think so.
04:59:12 <ski> (we're almost done with the theory :)
04:59:36 <ski> so, best i repeat what the equation system was, i think :
04:59:49 <ski> s : A -> B  ,  r : B -> A
05:00:07 <ski> r.s = id_A  ,  f = s.r  ,  idempotent(f)
05:00:40 <ski> and we said that B,f was known, and we wanted A,s,r that satified this system
05:00:53 <ski> that was what we said above
05:01:03 <_Codex> yes
05:01:17 <ski> also, the solution is unique (counting isomorphism as equivalence)
05:01:21 <ski> yes, ok
05:01:52 <ski> so, now say that B is your integer-pair !
05:01:57 <ski> and that f is shorten
05:02:04 <ski> ok ?   :) :)
05:02:34 <_Codex> ok, I still remember what shorten did -- reduce to normal form.
05:02:40 <ski> yes, right
05:03:14 <ski> so it is actually an idempotent (that is actually a 'precondition' to solving the "equation system")
05:03:50 <ski> now, what is the isomorphically unique A, in this case ? :)
05:03:53 <ski> any guess ?
05:04:07 <_Codex> let me think a minute.
05:04:12 <ski> sure
05:04:13 <ham> what are you talking about?
05:05:01 <ski> ham : implementing an ADT (in this case rational numbers), and using the retraction,section -pair concept to understand that kind of problem better :)
05:05:19 <_Codex> A is the equivalence class -- fractions :)
05:05:24 <ski> yes !
05:05:45 <ham> ADT?
05:05:55 <ski> remember we had (at least) two solution to the people representatives problem
05:05:58 <ski> ?
05:06:04 <ski> ham : Abstract DataType
05:06:22 <ski> yes ?
05:06:41 <earthy> damn, ozone unleashed haskell@haskell.org quite nicely. :)
05:07:00 <ski> earthy : mailing list ? or what ?
05:07:05 * earthy nods
05:07:19 <_Codex> ski: ok
05:07:24 <ski> earthy : with his post  (haven't read those threads yet)
05:07:30 <earthy> 20 mails. :)
05:07:33 <ski> _Codex : ok
05:07:37 <ski> earthy : :)
05:07:45 <ski> _Codex : so
05:07:59 <ski> those two solutions were of course isomorphic
05:08:46 <ski> but they corresponded to two different "implementations" of the representative/district set (A set), in that case
05:10:11 <ski> remember that in ADTs one strives to be able to easily change internal implementation without anyone noticing any different result "on the outside"  (except from time and memory consumption, of course, which explicitely isn't counted as "things that should stay the same")
05:10:37 <ski> do you follow so far ?
05:11:09 <_Codex> yes.
05:11:12 <ski> ok
05:11:31 <ski> we can look at ADTs from a slightly different angle
05:12:08 <ski> say we want to implement some type (and some interface, possibly satifying some laws/axioms / behaving in a certain way)
05:12:23 <ski> e.g. the type is the rationals !
05:12:31 <ski> ok ?
05:12:41 <_Codex> ok.
05:13:26 <ski> now, our type-building-blocks are sometimes quite squary and edgy, and doesn't really allow us to express exactly the type we want
05:14:10 <ski> we really want to have a type of pairs of integers, where the two integers are relatively prime (i.e their gcd = 1)
05:14:27 <ski> (i.e they have do common factor other than 1)
05:14:33 <ski> (s/do/no/)
05:14:36 <ski> ok ?
05:14:57 <_Codex> sure.
05:14:58 <ski> so what we actually get is (Int,Int)   (or perhaps Integer, if you like that better)
05:15:08 <ski> so, what do we do ?
05:15:32 <ski> we hide this "implementation type" behind an abstraction interface (i.e. module)
05:15:34 <_Codex> write shorten
05:15:54 <ski> and only export a type-name Rational, and some operations on it
05:16:10 <ski> we'll come to that, yes :)
05:16:28 <ski> now, what do we do with this (Int,Int) type
05:16:47 <ski> one common way is to only use the subset that we are interested in
05:17:00 <ski> also called 'canonical form'
05:17:20 <ski> so the canonical form of  15 / 10  in math is 3 / 2
05:17:39 <ski> so probably we have a function divide, in the interface
05:17:56 <_Codex> I usually call it "normal form" from lambda calc.
05:17:56 <ski> divide :: (Int,Int) -> Rational
05:18:07 <ski> yeah, that's a good term, too
05:19:07 <ski> so, if each Rational, which actually contains (Int,Int), always must be in normal form, then divide must call shorten to shorten the input, before it returns the Rational, right ?
05:19:29 <_Codex> yes.
05:19:53 <ski> and all internal operations like +,-,*,/  must ensure that the Rationals are gonna *stay* normalized/canonical
05:20:29 <ski> (but they can assume, as an invariant, that their Rational *arguments* already are in this form)
05:20:57 <ski> (if they are not, then either there is a bug. or some low-level memory abstraction leak)
05:21:02 <ski> right ?
05:21:02 <_Codex> ski: that is easily done -- only allow construction of Rationals via divide method. All ops need to "destroy" rational to do addition and then reconstruct it with divide :)
05:21:13 <ski> yeah, right ?
05:21:15 <_Codex> right.
05:21:22 <ski> now, to define to functions
05:21:32 <ski> numerator,denominator :: Rational -> Int
05:21:35 <ski> that is easy
05:21:47 <ski> just return the corresponding part of the pair directly
05:21:57 <ski> (they are already shortened)
05:22:31 <ski> yes ?
05:22:42 <_Codex> yes.
05:23:30 <ski> so. this was the "canonical/normalized value" implementation idea   (i.e. to implement the retract A of the type B given it's retraction f  (in this case shorten))
05:24:06 <ski> (remember that the A was called a *retract* of B, while r : B -> A was a *retraction*)
05:24:16 <ski> ok ?
05:24:23 <_Codex> sure.
05:24:44 <ski> now, the other common case, is sort of in the other extreme direction
05:25:05 <ski> it's almost equal to the "equivalence class of values" idea
05:26:09 <ski> so, with the repreasentatives, we actually had A being a type/set of equiv-classes of persons  (i.e. districts)
05:26:32 <ski> now, it's a bit harder to represent equivalence classes in programming
05:26:39 <ski> follow ?
05:26:43 <_Codex> yes
05:26:54 <ski> so, what one often does, instead
05:27:19 <ski> is, say that *any* element of the equiv-class, sortof represents the whole class
05:27:26 <ski> i.e. if we have
05:27:40 <ski> data Rational = R (Int,Int)
05:28:16 <ski> then  R (15,10)  and  R (3,2)  and  R (6,4)  is meant to represent the *same* rational number
05:28:40 <_Codex> comparing them becomes tricky.
05:28:42 <ski> i.e. they ought not be separable (at least from outside the ADT)
05:28:50 <ski> yeah, a little bit
05:29:12 <ski> so e.g if we implement == for this we can't do just this :
05:29:33 <ski> R (n0,d0) == (n1,d1)  =  n0 == n1  &&  d0 == d1
05:29:41 <ski> so this is Worng(TM) !
05:30:11 <ski> (beacuse this says that  R (3,2)  and  R (6,4)  are different. i.e. it separates things that ought not to be separable)
05:30:16 <ski> ok ?
05:30:21 <_Codex> yes
05:30:25 <ski> we can do this instead :
05:30:47 <ski> R r0 == R r1  =  n0 == n1  &&  d0 == d1
05:30:49 <ski>   where
05:31:07 <ski>   (n0,d0) = shorten r0
05:31:15 <ski>   (n1,d1) = shorten r1
05:31:29 <ski> i.e shorten "in the last minute" so to speak
05:31:31 <ski> :)
05:31:35 <ski> ok ?
05:31:52 <_Codex> yes, instead of shortening every time, shorten only when comparing or printing.
05:31:57 <ski> yes
05:32:12 <ski> i.e. only when returning someting that is not Rational
05:32:20 <ski> but
05:32:41 <ski> if we are *really* clever, we can actually do == like *this* :
05:33:03 <ski> R (n0,d0) == (n1,d1)  =  n0 * d1 == n1 * d0
05:33:05 <ski> :)
05:33:14 <ski> see why that works ?
05:33:36 <_Codex> sure. That's the equation they gave in the set theory book.
05:34:20 <ski> (i'm overstating this a bit, of course, this is quite easy to come to think of. but perhaps not a similar thing for a much more complicated ADT with complicated implementation type and operations)
05:34:23 <ski> yes
05:34:25 <ski> right
05:34:32 <Igloo> You ought to have fromIntegrals in there to be safe
05:34:59 <ski> Igloo : you mean re over-/under-flow ?
05:35:05 <Igloo> Yup
05:35:20 <ski> Igloo : actually, when i did this, i used Integer's all the way
05:35:35 <ski> so
05:36:01 <ski> with this kind of idea, we sometimes can get away with not calling shorten at all
05:36:48 <ski> (but, we have to actually check/prove that we don't make things separable that should not be separable)
05:37:04 <ski> so that is the down-side, i guess, with this method
05:37:11 <ski> _Codex : ok ?
05:37:43 <_Codex> sounds good.
05:37:56 <ski> i'm done. i think
05:38:14 <_Codex> thanks for your effort.
05:38:21 <ski> was this an interesting way to think about (at least some kind of) ADTs ?
05:38:43 <_Codex> Very nice explanation, especially the idemponent / equation solving thing.
05:38:58 <ski> you can see http://www.mdstud.chalmers.se/~md9slj/code/Retracts.hs for some pseudo-code i have written on this for some weeks ago
05:39:14 <ski> (though it's not ready)
05:39:25 <tic> given data List a = Nil | Cons a (List a); what's wrong with:  instance Show (List a) where show (Cons a l) = ..... ?
05:39:37 <_Codex> you've already implemented rationals? :)
05:39:52 <ski> yes, i did that as a nice example
05:40:07 <ski> tic : instance Show a => Show (List a) where ...
05:40:19 <ski> tic : you forgot Show a =>  i think
05:40:26 <tic> A-ha.  Why do I need that?
05:40:49 <ski> you can only show a list-of-a's if you can show a's
05:41:19 <tic> a-ha.
05:41:21 <ski> tic : understand ?
05:41:22 <ski> ok
05:41:25 <tic> yup.
05:41:30 <ski> a-ha.
05:41:39 <tic> what if I'd have data List a b then?
05:41:40 <ski> (funny exclamation)
05:41:42 <tic> Show a b => ?
05:41:50 <tic> or something else?
05:42:00 <ski> (Show a,Show b) => ...   if i DWIM you correctly
05:42:15 <tic> aha.
05:42:18 <tic> thanks.
05:43:02 <ski> a-ha, 'twas my pleasure.
05:44:37 <ski> _Codex : this idea with B and idempotent (f) giving retract A (plus section,retraction -pair (s,r))
05:45:35 <ski> ... as applied to "approximation ADTs", seem to work for the kind of ADT where one either thinks of canonical forms or equivalence-classes (or some thing inbetween :)
05:46:05 <ski> i.e we have an idempotent : canonicalize/normalize/shorten on the ADT
05:46:55 <ski> (though perhaps we haven't thought about it explicitely, at least in the represenative-of-equiv-class case)
05:47:26 <ski> so, this idea perhaps/possible/whatever doesn't apply to all ADTs  (or does it ?)
05:47:40 <ski> (i think not. but not entirely sure)
05:47:49 <ski> ok. done.
05:51:16 <_Codex> ski: I bet the idempotent applies to beta-reduction .. and thus about everything we can do with computers :)
05:58:41 <tic> ski, another problem: hugs says it can't find the show function for Nil
05:59:01 <tic> even though I have it defined as: show (Nil) = "[]"
05:59:39 <ski> _Codex : i haven't thought about it from that direction, thanks :)  (must come from your canonicalize=normalize, yes ?)
05:59:45 <ski> tic : hmm
05:59:55 <ski> have you defined it ?
06:00:02 <tic>  instance Show a => Show (List a) where
06:00:03 <tic>      show (Nil) = "[]"
06:00:16 <ski> and the other clause ?
06:00:27 <tic> data List a = Nil | Cons a (List a)
06:00:29 <tic> sec.
06:00:39 <tic>      show l @ (Cons a list) = "[" ++ restOf l
06:00:39 <tic>   
06:00:41 <tic> ...
06:01:03 <ski> and how, pray tell, is restOf, defined ? ;-)
06:01:20 <tic> heh. okay, I'll paste that too.
06:01:28 <ski> (just one clause/definition-line, eh ?)
06:01:31 <_Codex> ski: yes, comes from "normalize" or "proof simplification" being same as "execution" in curry-howard isomorphism. And the reduction for fractions is clearly like that.
06:01:33 <tic>          where
06:01:33 <tic>              restOf (Nil) = "]"
06:01:34 <tic>              restOf (Cons a Nil) = show a ++ "]"
06:01:34 <tic>              restOf (Cons a l) = show a ++ ", " ++ (restOf l)
06:01:35 <tic>   
06:01:41 <tic> (sorry for all the spamming)
06:02:25 <ski> _Codex : so you should run the reflexive-transitive closure as far as possible, to define the idem, then
06:02:31 <ski> no spamming
06:02:40 <ski> (sometimes called flodding :)
06:02:59 <_Codex> ski: yes.
06:03:00 <tic> so anyway - know what might be wrong?
06:03:24 <ski> _Codex : yes, i guess one can define single-step reduction for rationals. hadn't thought much about that either
06:03:37 <ski> tic :ok, lokking now :)
06:03:40 <ski> looking
06:04:24 <ski> hmm, the first clause is unnessecart here
06:04:38 <ski> you only call restOf, from show, if the list is nonempty
06:04:47 <tic> Yes.
06:04:55 <ski> and restOf only calls itself if the tail is nonempty
06:05:01 <_Codex> ski: for negative numbers, we have single-step reduction.. since only (0,10) or (10,0) are allowed and (2,2) is reduced by subtracting to (1,1) and then (0,0). :)
06:05:02 <ski> so the first clause is dead code
06:05:09 <ski> hmm
06:05:16 <tic> ski, what if I want to show the empty List, Nil?
06:05:23 <tic> ski, then I need the first clause, don't I ?
06:05:38 <ski> that should the first clause of show handle, nay ?
06:05:44 <tic> Yes.
06:06:00 <tic> show (Nil) = "[]"
06:06:09 <tic> show l @ .... = ... restOf l
06:06:13 <tic>  where restof ...
06:06:31 <tic> but Hugs says there's no show function for Nil defined.
06:06:33 <ski> _Codex : hmm yes, we could have (Interger,PositiveInteger) perhaps
06:07:08 <ski> _Codex : hmm, "subtracting" (1,1) to (0,0) ??
06:07:34 <ski> hmm
06:07:44 <ski> what is the exact error message ?
06:08:26 <_Codex> ski: well, we have this "nil" + "succ" thing for N. And then negative numbers as pair (a,b) where you can do  (a-1,b-1) reduction so that either a or b is 0.
06:09:28 <tic> ski, me?
06:09:38 <ski> _Codex : oh, now i get what you're talking about. i thought you were talking about negative rationals. but you're actually now talking about implementing integers from pairs of naturals, right ?
06:09:46 <ski> tic : yes, you :)
06:09:51 <_Codex> ski: yes
06:09:58 <tic> ski,  Cannot find "show" function for Expression Nil of type List a
06:10:33 <ski> oh, that !
06:10:38 <ski> try 
06:10:46 <ski> Foo> (Nil :: List Int)
06:11:12 <tic> Hm, okay.
06:11:23 <ski> if you just type  Nil
06:11:26 <ski> then
06:11:30 <ski> Nil :: List a
06:11:42 <ski> so it doesn't know if a is Showable or not
06:11:43 <tic> I'll se.
06:12:09 <tic> ah, yeh.
06:12:18 <tic> Nil :: List Int works.
06:12:20 <tic> thanks.
06:12:30 <ski> (which we might think a bit irritating, cause there aren't actually any values of a in the empty list. but the type system unfortunately doesn't get that)
06:12:36 <tic> mhm
06:12:40 <tic> alright.
06:12:50 <ski> in most cases, when actually programming this won't cause a problem
06:12:53 <tic> okay, so now this works. All that's left is to implemenent a binary tree.
06:12:56 <tic> yup.
06:13:15 <ski> but when trying out things is hugs or ghci or hbci, then one has to be aware of this
06:13:42 <tic> jups.
06:13:51 <ski> (same thing is of course true for empty binary trees (if you have that type of binary tree, i.e.))
06:14:02 <ski> ok
06:17:51 <tic> yup.
06:34:13 <ham> bk
06:56:39 <SyntaxNinja> Aetion is hiring a Haskell developer: http://www.haskell.org//pipermail/haskell/2004-February/013699.html
07:01:01 <Igloo> Unfortunately they're doing so a year or two too early and in the wrong city (well, country too  :-)  )
07:01:17 <earthy> poor igloo ;)
07:01:28 <SyntaxNinja> Igloo: some day maybe we can open up a UK branch. mark is from the UK, and I wouldn't mind living there :)
07:02:06 <Igloo> That would be nice  :-)
07:21:45 <Lunar^> SyntaxNinja: trading Haskell for military work... hard choice
07:50:22 <SyntaxNinja> Lunar^: yeah
08:13:38 <Igloo> Yay, increased workingness
08:19:46 <SyntaxNinja> Igloo: congrats :)
09:17:37 <shapr> good morning #haskell!
09:17:55 <shapr> what did I miss?
09:17:57 <Lunar^> shapr: morning ?
09:18:06 <raver> y0 shapr
09:18:09 <shapr> ok.. good evening #haskell!
09:18:14 <raver> noon
09:18:16 <raver> :)
09:18:24 <shapr> gee, it's 18:17 here.
09:18:28 <Lunar^> shapr: I'm fighting with primops
09:18:41 <shapr> Lunar^: hey, at least that's better than fighting with ZPT, right?
09:18:42 <Lunar^> shapr: That is quite undocumented
09:18:51 <SyntaxNinja> hey shapr
09:18:59 <shapr> I'm finally running 2.6!
09:19:01 * shapr dances cheerfully
09:19:05 <Lunar^> shapr: dunno.. I have 15 minutes of compilation between each try
09:19:12 <shapr> Lunar^: why so long?
09:19:15 <shapr> SyntaxNinja: y0 y0
09:19:17 <Lunar^> (maybe I should turn of -O)
09:20:31 * shapr looks at #haskell logs
09:21:09 <shapr> ohh, Aetion is hiring.
09:21:12 <SyntaxNinja> jaja :)
09:21:23 <SyntaxNinja> sounds like you have some mailing list to catch up on too :)
09:21:55 <shapr> I've been going as fast as I can on this Plone project for a long time.e
09:44:47 <Lunar^> mhhh
09:44:52 <Lunar^> How do I put primops in scope
09:44:54 <Lunar^> ...
09:45:27 <shapr> seafood: y0, ltns
09:56:34 <Lunar^> grr... My new primops are in GHC.PrimWrappers which is generated by genprimops, but they don't get in GHC.Prim (which is a wired in package)
10:05:44 <Igloo> When did darcs go into NEW, Syn?
10:51:09 <Lunar^> damn :(
11:11:25 <Lunar^> Yahoo :)
11:11:30 <Lunar^> inb works :)
11:16:23 <SyntaxNinja> Igloo: when did I upload it?
11:19:10 <SyntaxNinja> well, I uploaded it on the 22nd
11:20:23 <SyntaxNinja> hey CodeWarrior: do you work for Motorolla on their codewarrior product?
11:21:27 <Igloo> Ta
11:22:12 <SyntaxNinja> Igloo: is it usual to wait this long before hearing back?
11:22:23 <SyntaxNinja> do you think I should try to fix the sparc problem and reupload, or should I wait t ohear from them?
11:23:07 <Igloo> I wouldn't do anything until at least 10 days after upload (the mail says a week). I'd ignore the sparc problem until I've seen what the buildd does
11:24:54 <SyntaxNinja> ok
11:39:33 <ludde> i'm getting this weird error that i can't solve:
11:39:39 <ludde> Instances of (Enum Reg, Num Reg) required for definition of cgBinOpInt
11:40:56 <ludde> http://ludde.biz/haskell.txt
11:44:12 <SyntaxNinja> ludde: sounds like the haskell compiler is expecting Reg to be in the Enum and Num classes
11:44:25 <ludde> why would it expect that though?
11:45:37 <SyntaxNinja> don't see anything there to tell me that.
11:45:42 <ludde> me neither :|
11:45:52 <SyntaxNinja> what line is it on?
11:46:01 <SyntaxNinja> where's the cgExp function
11:46:08 <SyntaxNinja> and what are yhou using rr for in cgBinOpInt?
11:46:36 <ludde> I've commented away the lines that used rr
11:46:40 <SyntaxNinja> by the way, you can paste stuff like that on the wiki
11:46:46 <SyntaxNinja> @hawiki HaskellIrcPastePage
11:46:47 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands"
11:46:54 <SyntaxNinja> @wiki HaskellIrcPastePage
11:46:54 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:47:01 <SyntaxNinja> darn, that's not it
11:47:14 <SyntaxNinja> oh, maybe it is
11:47:26 <ludde> okay
11:47:29 <Igloo> ludde: Do 2 implementations both complain?
11:47:37 <ludde> what implementations?
11:47:49 <SyntaxNinja> hugs and ghc for instnace
11:48:05 <ludde> let me see
11:48:22 <ludde> maybe ghc gives me a better error message.
11:48:44 <Igloo> That snippet with
11:48:44 <Igloo> type BinOp = Int
11:48:45 <Igloo> type CodeGen a = Maybe a
11:48:45 <Igloo> type Exp = Int
11:48:49 <Igloo> works for me in hugs+ghci
11:49:07 <ludde>  No instance for (Num ResultReg)
11:49:08 <ludde>     arising from the literal `0' at CodeGenQuad.hs:311
11:49:08 <ludde>     In the first argument of `cgExp', namely `0'
11:49:08 <ludde>     In a 'do' expression pattern binding: cgExp 0 e
11:49:23 <ludde> there we have it
11:49:30 <ludde> I had a 0 instead of a Reg somewhere.
11:50:12 <ludde> funny though
11:50:20 <ludde> I had the 0 in a completely different function
11:50:33 <ludde> not related to cgBinOpInt
11:54:54 <SyntaxNinja> ahh
13:04:42 * SamB isn't entirely sure he understands ST
13:05:55 <stepcut> :p
13:53:56 <Marvin--> wtf
13:57:12 <Marvin--> ooookay, that was weird
13:57:23 <Marvin--> apparently, one of the power plugs in my wall has stopped working
14:04:28 <Odiseo> hello
14:13:12 * SamB is puzzled by the output of :browse Control.Monad.ST in GHC
14:13:24 <SamB> (namely, "foreign import type dotnet RealWorld")
14:13:42 <SamB> specially since I don't have .NET
14:47:57 <cm> hey world
14:49:48 <stepcut> hey
15:34:21 <ahuda> can someone help me implementing a show function for an ADT.. I am very new to haskell
15:34:41 <ahuda> data Array2D a = Array Int Int [(Int,Int,a)], I would a show function for this ADT
15:36:48 <SamB> ahuda: example of what you want the output to look like?
15:45:05 <ahuda> SamB: a list [(0,0,VALUE),(0,1,VALUE), ... (n,n,VALUE)]
15:52:53 <stepcut> ahuda: did you try 'deriving Show' ?
15:53:28 <stepcut> ahuda: or did you want something more customized
15:53:32 <SamB> hey wait. Is that even a a valid type?
15:54:15 <Riastradh> SamB, it looks fine to me.
15:54:38 <stepcut> Its an array of lists of 3-tuples?
15:55:15 <Riastradh> ...er, no.  It's a triple, containing an Int, an Int, and a list of (Int,Int,a) tuples.
15:55:19 <SamB> I'm just confused by the use of the word Array
15:59:09 <stepcut> Riastradh: oh yeah, I should pay attention better.
16:28:33 <amgine> hey all
16:28:37 <amgine> i was wondering
16:28:45 <amgine> since there is write file in haskell
16:29:10 <amgine> could i store a binary file as a string sequence withing haskell and write it to a file as binary ?
16:30:36 <amgine> is that possible ?
16:38:45 <Riastradh> amgine, you make no sense; fixing up your grammar would help.
16:38:56 <amgine> ohhhh
16:38:57 <amgine> ok
16:39:01 <amgine> when haskell reads a file
16:39:08 <amgine> acctually nevermind
16:39:10 <amgine> i'm going to test it
16:39:15 <Riastradh> Good plan.
16:39:24 <amgine> and i'll be back when i understand it more
16:39:25 <amgine> :)
16:50:19 <amgine> i have my question
16:50:20 <amgine> ok
16:50:25 <amgine> i can read a file as a string
16:50:36 <amgine> right ?
16:50:42 <amgine> is anyone willing to follow me here ?
16:50:43 <Riastradh> Yes.
16:50:47 <Riastradh> Yes.
16:51:00 <amgine> ok now i wish to store that string sequence in the haskell code i.e.
16:51:07 <amgine> file = "the string sequence"
16:51:12 <amgine> however i just tried that
16:51:17 <amgine> and it creates lexical errors
16:51:36 <Riastradh> You used the code [[file = "the string sequence"]]?
16:51:36 <amgine> haskell is trying to interpret it as code
16:51:46 <amgine> yes
16:51:52 <amgine> file = " string "
16:51:55 <amgine> [[ ?
16:52:01 <amgine> those brackets mean something ?
16:52:03 <Riastradh> That's just a notation for embedding code within conversational text.
16:52:12 <amgine> hmmm
16:52:15 <amgine> explain
16:52:17 <Riastradh> It's often ambiguous which part of the text is just conversation and which part is code.
16:52:44 <amgine> and [[ ]] tells it whatever inside is not code ?
16:53:05 <Riastradh> No, [[<text>]] means that <text> is code.
16:53:41 <amgine> i'm sorry if this is something i should understand
16:53:49 <amgine> but yersterday was the first program i wrote in haskell
16:53:56 <amgine> could you explain how i could use it ?
16:54:07 <amgine> file = "asdfasdf" string but the string is an html file haskell tries to read as code
16:54:20 <Riastradh> If yesterday you wrote your first Haskell program, you shouldn't be doing file I/O yet.
16:54:33 <amgine> it was an I/o code
16:54:38 <amgine> i've been playing with haskell before
16:54:42 <amgine> but just the functional parts
16:54:45 <amgine> not the nomads
16:54:54 <Riastradh> ...heh...
16:54:57 <amgine> :)
16:55:04 <amgine> i think i understand them enough now :P
16:55:28 <Riastradh> I don't think so.  Go on with the Haskell tutorial you were reading, and wait patiently before arriving at I/O or monads.
16:55:42 <amgine> lol
16:55:49 <amgine> Riastradh just bare with me
16:56:18 <amgine> how can i instruct the interpreter that file = " this stuff here " is a string not read as a code
16:56:42 <Riastradh> Surround it in double-quotes.  (You'll have to escape the nested double-quotes.)
16:56:53 <amgine> ahhh ok
16:56:58 <amgine> let me give that a try
16:57:58 <amgine> nope same thing
16:58:07 <amgine> crap the string is an html page
16:58:40 <Riastradh> You'll have to escape _all_ of the double-quotes in the text.
16:58:51 <amgine> crap
16:58:58 <amgine> i understand what you mean
16:58:59 <Lunar^> dev lOg updated... 
16:59:02 <amgine> any other way ?
16:59:05 <Riastradh> No.
17:00:19 <amgine> crap
17:00:25 <amgine> sorry about that
17:01:04 <amgine> hmmm
17:01:42 <amgine> any easier way to store it in ?
17:01:45 <amgine> using { } ?
17:01:58 <amgine> tell it explicitly this part is a string etc.
17:02:58 <amgine> the lack of cryptic brackets it's haskell strength but i'm sure there should be a way to tell the complier not to use indenation
17:03:42 <Riastradh> Not that I know of.
17:03:47 <amgine> crap
17:03:47 <Riastradh> Why are you hard-coding an HTML page?
17:03:56 <amgine> because i'm just testing
17:04:02 <amgine> see if it can be stored and written to the disk
17:04:16 <Riastradh> You shouldn't be doing file I/O yet, as I said.
17:04:43 <amgine> Riastradh i trust i know enough
17:04:45 <amgine> and i do
17:05:30 <Riastradh> amgine, Haskell isn't like most mainstream imperative languages where if you know one you pretty much know them all.  Haskell can't be learned in just a couple minutes.
17:05:44 <amgine> i've been using it on and off for a year
17:05:46 <amgine> i like it
17:05:49 <amgine> is ski arround ?
17:05:57 <Riastradh> He is.
17:06:04 <amgine> ski msg me
17:06:09 <amgine> wake up stranger lol
17:06:26 <Riastradh> What did you mean when you said you wrote your first Haskell program yesterday if you'd been toying with it for a year?
17:06:43 <amgine> ohhh something that isn't for school
17:06:49 <amgine> and compiled it acctually
17:07:03 <amgine> very simple program to do something tidious for me
17:09:47 <amgine> hmmm anyone able to help me ?
17:10:02 <amgine> to explicitly specify lexcial structure
17:12:10 <amgine> anyone alive ?
17:13:33 <stepcut> amgine: you could store the text in a seperate .html file and then use template haskell to read the .html at compile time and turn it into a string...
17:16:02 <stepcut> something like:  readHTMLFile = do { html <- qIO readFile "my.html" ; lift html }
17:16:19 <amgine> yes stepcut i understand that
17:16:19 <amgine> lol
17:16:24 <amgine> but that is the reason i am asking
17:16:28 <amgine> i wish to store it withing the code
17:16:43 <amgine> i remmember ski was telling me you can explicitly tell haskell the indentation
17:16:46 <stepcut> then: file = $( readHTMLFile )
17:16:58 <amgine> i think that would help
17:17:05 <amgine> stepcut i understand that approach
17:17:11 <amgine> but it's not what i wish
17:17:14 <stepcut> oh?
17:17:21 <amgine> the reason for this
17:17:25 <amgine> i wish to just have one file
17:17:42 <amgine> the files need are stored as string and wrote to disk when needed
17:17:44 <stepcut> you mean, one file when you distribute the binary? Or one source file?
17:17:53 <amgine> one binary
17:18:09 <stepcut> yes, that is what my solution does...
17:18:32 <amgine> true
17:18:36 <amgine> hmmm
17:18:45 <stepcut> file = $( readHTMLFile ) will cause readHTMLFile to be run at compile time
17:18:51 <amgine> yes
17:18:58 <stepcut> it will never look for my.html at run time
17:18:59 <amgine> but the html file is still outside the binary
17:19:06 <amgine> i wish to store it as a string inside the file
17:20:01 <amgine> let me think outside the box
17:20:30 <amgine> let's say i have msg = " foo "
17:20:39 <amgine> and foo is multi lined and has " in them
17:20:53 <amgine> how to tell haskell not to get confused when it interprets the code ?
17:21:22 <Etaoin> " \" "
17:21:23 <stepcut> you have to change all the " to \"
17:21:44 <stepcut> and possible change newlines to \n
17:21:47 <amgine> and when i would write it to a file
17:21:56 <amgine> would \" be written back to " ?
17:22:01 <stepcut> yes
17:22:04 <amgine> ahhh BINGO
17:22:17 <amgine> is the a module that does the proper filtering for me ?
17:22:32 <amgine> i still hope there is an easier way just using the proper lexical grammar
17:22:39 <amgine> *there a module ...
17:23:20 <amgine> i hope i'm not being anoying
17:23:22 <amgine> :)
17:23:38 <stepcut> amgine: how would such a module work?
17:23:44 <amgine> load in a file
17:23:56 <amgine> use filter to replace " to \"
17:24:07 <stepcut> well, that is what the code above does
17:24:20 <amgine> good point
17:24:44 <stepcut> and it does it at compile time, not run-time, so you don't have to distribute the my.html with the binary
17:24:48 <amgine> stepcut you wouldn't know a way to do that with just proper explicit brackets ?
17:25:14 <stepcut> ?
17:25:40 <amgine> ski if i recall told me you can explicitly tell haskell how to interpret the indenation i.e.
17:25:47 <amgine> foo x ; foo2 y ...
17:26:00 <stepcut> how would that help you?
17:26:05 <amgine> i'm not sure
17:26:08 <amgine> that's why i'm asking :)
17:26:27 <stepcut> that format is typically only useful if you have another program that generates haskell code
17:26:37 <stepcut> it has nothing to do with string escaping...
17:26:42 <amgine> hmmm
17:27:14 <amgine> if you were to store a file as a string inside haskell code
17:27:20 <amgine> how would  you go about it
17:27:24 <amgine> i.e. an html code
17:27:34 <amgine> but like i said not in a seperate file
17:27:37 <amgine> put that aside
17:28:09 <stepcut> hold on
17:28:15 <amgine> k
17:28:20 <amgine> thanks for the help in advance
17:28:51 <stepcut> you could write a seperate program that turns the .html into a properly escaped string and then insert the output of that program into your code
17:29:35 <amgine> hmmm
17:29:37 <amgine> brb
17:29:41 <amgine> show does that job for me
17:29:43 <amgine> brb
17:30:56 <amgine> crap
17:31:10 <Riastradh> Don't panic.
17:31:12 <amgine> yeah show does that write (show z)
17:31:15 <amgine> no it seems it works
17:31:17 <amgine> brb
17:31:24 <amgine> man you guys are good mental storming group
17:32:03 <amgine> YES
17:32:05 <amgine> lol
17:32:24 <amgine> doing write somefile (show z) where z is the file i just read converts into a string haskell can understand !
17:32:36 <amgine> you guys rule
17:32:38 <amgine> time to test it
17:34:28 <amgine> IT WORKED 
17:34:29 <amgine> thanks guys
17:34:31 <amgine> you rule
17:36:28 <stepcut> main = putStrLn $( do { file <- qIO (readFile "Test.hs") ; lift file } )
17:36:31 <stepcut> whee1
17:36:33 <stepcut> whee!
17:37:08 <stepcut> that is how *I* would do it personally
17:37:30 <amgine> i see
17:37:33 <amgine> brb crap
17:37:35 <amgine> ":)
17:39:07 <amgine> ahhh DAMN IT
17:39:13 <amgine> it only works with non binary files
17:39:19 <amgine> back to square one for this one
17:39:30 <amgine> html file worked but binary file didn't
17:39:33 <amgine> any suggestions ?
17:39:52 <amgine> zip file acctually
17:40:30 <amgine> stepcut what does your code do ?
17:40:41 <amgine> what lift file ?
17:42:12 <amgine> i'm here
17:42:38 <stepcut> hold on
17:42:51 <amgine> stepcut sure man :)
17:43:31 <stepcut> its fairly advanced code actually
17:43:51 <amgine> i'm fairly listening :)
17:43:55 <amgine> you read the file
17:43:59 <amgine> what does qIO do ?
17:43:59 <stepcut> lift file, lifts file into the Q monad
17:44:14 <amgine> hmmm
17:44:17 <amgine> ok
17:44:17 <stepcut> qIO takes and IO monad and turns it into a Q monad
17:44:26 <amgine> i'm woahh
17:44:40 <amgine> ok
17:44:45 <amgine> so it becomes a Q monad ?
17:44:49 <amgine> what is Q monad ?
17:45:10 <stepcut> the Q monad is used by template haskell
17:45:27 <amgine> you've lost me
17:45:30 <amgine> hmmm
17:45:35 <stepcut> the compile basically compiles that line in two passes
17:45:35 <amgine> would that work for a binary file ?
17:45:58 <stepcut> the first pass it compiles and runs the code inside the $( )
17:46:08 <amgine> ok
17:46:30 <amgine> and it prints the compiled code on the screen ?
17:46:54 <stepcut> then it compiles the file a second-time, but it substitutes the $( ) with the results of what its contents produced
17:47:22 <amgine> ok but it's a vague ok
17:47:28 <stepcut> so in the case, the stuff inside the $( ) reads the file and returns the contents of the file a string
17:47:42 <amgine> ok and that string
17:47:50 <amgine> can be written to a file
17:47:51 <amgine> and run ?
17:47:54 <stepcut> so the second time, it will basically compile: main = putStrLn "the string that was in that file"
17:48:11 <stepcut> I don't know if it will work for binary data
17:48:20 <amgine> ahhh that's my dilemma now
17:48:26 <amgine> i need to store a zip file as a string 
17:48:40 <amgine> show foo.zip returned a lot of \NUL
17:48:44 <stepcut> readFile / putStrLn might not handle binary files too well, so you would have to use something else
17:48:46 <amgine> and a file 1kb big
17:49:00 <amgine> hmmm
17:49:13 <amgine> brb
17:50:16 <stepcut> there is another set of functions, readBinaryFile and writeBinaryFile that might work better for you
17:50:33 <stepcut> or something like that, I can't get to haskell.org right now
17:50:56 <amgine> ohhh it might
17:51:16 <amgine> can that binary be stored as a string within haskell ?
17:51:29 <amgine> is it under IO ?
17:52:02 <amgine> i'm looking at the ghc library help
17:52:10 <amgine> but can't find readBinaryFile
17:53:28 <stepcut> import Data.Array.IO
17:53:35 <stepcut> it will store it as an array
17:54:03 <stepcut> if you just need to be able to write the file out at run-time then that is probably your best bet
17:54:18 <amgine> hmmm i will look into that
17:55:26 <stepcut> actually, its openBinaryFile, hGetArray and hPutArray
17:56:01 <amgine> yeah lol
17:56:03 <amgine> ok
17:56:08 <amgine> i could find the other handles you said
17:56:36 <amgine> hmmm i can't find openBinaryFile either
17:56:40 <amgine> damn the beer is not helping
17:57:31 <stepcut> ah, import System.IO
17:58:13 <amgine> so it's under System.IO
17:58:17 <amgine> lol thanks
17:58:52 <stepcut> its a bit more work than readFile though
17:58:55 <stepcut> you need to open the file
17:59:00 <stepcut> figure out the file size in bytes
17:59:06 <stepcut> create and empty array of that size
17:59:16 <stepcut> then read in the binary file with hGetArray
17:59:32 <amgine> hmm
17:59:53 <amgine> i just wish to somehow store it as a string inside the haskel code
18:00:15 <stepcut> maybe you can, I didn't try...
18:00:25 <amgine> i'll play arround
18:00:30 <amgine> thanks for the help
18:00:33 <stepcut> no problem
18:00:36 <amgine> sorry if i was anoying 
18:00:42 <stepcut> no  problem
18:02:46 <amgine> i'll leave it at that
18:02:48 <amgine> to much to think now
18:02:58 <amgine> thanks for all the help
18:33:56 <Riastradh> Is haskell.org up?
18:39:04 <Igloo> Doesn't look like it
18:39:49 <Riastradh> [riastradh@Slate ~]% ping haskell.org
18:39:49 <Riastradh> PING haskell.org (128.36.229.215): 56 data bytes
18:39:49 <Riastradh> ^C
18:39:49 <Riastradh> --- haskell.org ping statistics ---
18:39:49 <Riastradh> 13 packets transmitted, 0 packets received, 100% packet loss
18:39:59 <Riastradh> Looks down to me.
18:44:23 <TripleDES> for me too
18:44:45 <Riastradh> ...oh, Igloo's response confused me because of my question.
18:45:09 <TripleDES> yeah...
18:45:45 <TripleDES> time to sleep....n8
19:40:22 * stepcut finally gets around to installing darcs
19:41:19 <stepcut> nice, there is even a darcs freebsd port (though its a bit out of date)
19:41:55 <stepcut> or maybe my ports collection is just out of date
19:41:57 * stepcut checks
19:42:19 <stepcut> just me
20:28:37 <stepcut> haha. kuro5hin has an interesting 'learning japanese' article
