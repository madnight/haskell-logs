00:00:18 <Etaoin> I think he means too bad you can't do "foo" ++ 9
00:00:49 <eivuokko> Ah, ok.
00:00:52 <shrimpx> because that would be a good thing? :)
00:01:18 <Etaoin> I'm not agreeing, just translating :)
00:02:24 <DeezNuts> yes it would
00:02:27 <DeezNuts> obviously
00:02:32 <DeezNuts> when in hell would it be a bad thing
00:02:36 <DeezNuts> s/when/why/
00:03:55 <DeezNuts> ohh! thats right biatch
00:03:59 <dennisb> it will always be bad, ++ is list concatenation and 9 is not a list. I want an error if I where to do something like that
00:05:31 <eivuokko> I don't see why would it need to be overloaded for that case, iether.  Writing [] isn't that bad.
00:22:22 <ustenzel> I produced a huge memory leak in pure haskell.  Any pointers how to track the beast down?
00:23:58 <forester> ustenzel: we had a memleak recently, we used heap profiling
00:24:41 <forester> ustenzel: cant say it's that usefull, but right configured it could might give you a hint
00:24:47 <ustenzel> what can be a potential reason?
00:25:13 <forester> ustenzel: no FFI stuff?
00:25:21 <ustenzel> i'm building a large list in a list comprehension.  the list is immediately consumed by minimumBy.
00:25:27 <ustenzel> No, pure haskell.
00:26:11 <ustenzel> I thought, the minimum function might build a huge thunk, but I'm not sure.
00:26:39 <ustenzel> The problem vanishes when I try to reproduce it with simpler code.  Of course then the result is useless...
00:27:15 <ustenzel> If the culprit is inside the comprehension, how do i find out?
00:28:37 <ustenzel> btw, this is on GHC 6.2 with -O.  Deforestation does not seem to help.  I guess something is "too lazy", but how do I find out what it is?
00:31:16 <forester> ustenzel: minimumBy uses foldl
00:31:31 <forester> foldl had a space leak years ago, maybe it still has...
00:31:36 <ustenzel> oh. so no deforestation takes place.  sad.
00:32:08 <ustenzel> however, I replaced the minimum by an explicit foldl' (the strict version) with no difference.
00:32:56 <ustenzel> also, i have no problem when i generate a huge list and find its minimum.  therefore I think, my list comprehension does something awful.
00:34:12 <ustenzel> but there is nothing particularly complicated in there.  some constant lists, a calculation that return a short list and a zip.
00:43:23 <forester> couldn't it be the case that it suspends all calculations and thus has to keep a very large structure in memory?
00:43:32 <forester> "too lazy" that is...
00:44:00 <ustenzel> i think so.
00:44:04 <earthy> full laziness. there was something on ghc-bugs about it
00:44:09 <earthy> there is no way around that
00:44:23 <earthy> (yet, CVS HEAD has -fno-full-laziness)
00:45:20 <ustenzel> However, my data structures are quite small, they are combined to form the long list.  the only real computation in there gives a short list, and that is consumed, too.
00:45:53 <ustenzel> When searching the minimum, everything has to be evaluated.  This should be inherently strict.
00:46:06 <ustenzel> I think... how do I make sure?
00:47:07 <earthy> you can force strictness using $!
00:47:46 <ustenzel> yeah, sprinkled it whereever it fit and still missed the spot.
00:49:17 <ustenzel> Well, I might write that part in C.  It's number crunching anyway and C might be significantly faster there.
00:49:39 <ustenzel> It still bugs me that the haskell program fails so unpredictably.
00:52:46 <forester> ustenzel: have u read http://www.haskell.org/pipermail/haskell/2001-November/008390.html
00:54:31 <ustenzel> so if x is a tuple and I say "seq x" I gain nothing.  if I say "let (a,b)=x in a `seq` b `seq`" I do.
00:55:16 <ustenzel> ...but I already do that.
01:00:20 <ustenzel> I'll fiddle around some more, already get some ideas.  Thank you anyway.
02:22:17 <ham> hi
02:24:15 <Lemmih> yo
02:24:19 <shapr> y0
02:55:16 <det> o/` ho ho and a bottle of rum ... o/`
02:57:35 <blackdog> @yow
02:57:36 <lambdabot> It's the RINSE CYCLE!!  They've ALL IGNORED the RINSE CYCLE!!
02:57:42 <blackdog> wait, wait
02:57:43 <blackdog> @arr
02:57:43 <lambdabot> Aye
02:57:48 <blackdog> that's better.
03:18:56 <det> @arr
03:18:56 <lambdabot> I heard andersca is a pirate
03:19:01 <det> @arr
03:19:02 <lambdabot> Drink up, me hearties
03:20:53 <shapr> andersca: are you a pirate?
03:42:30 <ham[let]> bk
04:22:11 <shapr> ei ole
04:30:00 <mgoetze> shapr: on!
04:30:11 <shapr> minÃ¤ en puhu suomea.
04:30:28 <mgoetze> and you think i do, or what? :P
04:30:37 <shapr> heck if I know.
04:30:58 <mgoetze> just because i happen to be in finland right now...
04:34:58 <shapr> what are you doing in .fi ?
04:35:42 <eivuokko> You didnät ask me, did you?
04:36:02 <shapr> no, but if you want to tell me I won't argue.
04:36:03 <shapr> :-)
04:36:08 <shapr> heivuokko
04:37:41 <eivuokko> Hi :)
04:37:57 <shapr> how's code?
04:38:43 <eivuokko> It's all C++ ;)  
04:40:36 <shapr> yikes!
04:40:43 <mgoetze> shapr: visiting people, and there's a go tournament this weekend
04:40:48 <shapr> oh, neat
04:48:27 <shapr> yay, I have Oracle binding!
04:48:48 <shapr> Alistair Bayley couldn't get into sf.net cvs, I think the servers are still flattened.
04:51:46 <edwinb> hello world
04:52:01 <shapr> greetingz edwinb 
04:59:25 * shapr sighs
05:10:51 <_Codex> Using constructors to do pattern matching: I wonder what's the reason that function type doesnt contain information about constructors matched by the function ? :)
05:11:50 <kosmikus> what would it be worth?
05:12:11 <_Codex> better type checking?
05:12:40 <kosmikus> you cannot decide which constructor a value belongs to, anyway
05:12:47 <edwinb> it'd be tricky to write that type checker without making it undecidable...
05:12:53 <kosmikus> so it would just clutter up the type language, without being really useful
05:13:31 <edwinb> I assume you mean, for example, that "tail" would say it only matched : ?
05:20:06 <_Codex> I'm just trying to think how to get richer types than "m a" -- i.e. what new information to put to the type so it can regognize more differences between expressions. :)
05:20:55 <shapr> you should look at some of the cool type tricks in HaskellDB
05:22:04 <edwinb> You can do an awful lot with the type system if you're prepared to do the setting up.
05:22:25 <shapr> I'd like to see more of what can be done
05:22:31 <shapr> do you have any examples?
05:22:32 <edwinb> http://haskell.org/hawiki/SimulatingDependentTypes
05:23:43 <_Codex> I've been dreaming to put formal languages to the type system somehow; constructor matching looks like a good place for that.
05:24:58 <edwinb> _Codex: I tend to feel that if I'm not matching on all the constructors, I'm using the wrong data structure.
05:27:38 <edwinb> Incidentally, have you seen Cayenne? http://www.cs.chalmers.se/~augustss/cayenne/
05:27:52 <edwinb> Development stopped about 1999, but there's some interesting ideas there.
05:39:51 <kosmikus> edwinb: you working with Conor?
05:41:30 <edwinb> yes
05:41:47 <edwinb> do I seem brainwashed? ;)
05:41:57 <kosmikus> :)
05:42:18 <kosmikus> so, any progress on the dependently typed ultimative PL front?
05:42:51 <edwinb> You mean Epigram? It's nearly running programs now...
05:43:00 <edwinb> It ran "not" the other week ;).
05:43:50 <kosmikus> cool
05:44:13 <edwinb> I think it won't be long before it's actually usable, at least for basic experiments.
05:44:56 <kosmikus> there's not much to see on the web, unfortunately
05:45:06 <kosmikus> but I wouldn't have time for it right now, anyway
05:45:29 <kosmikus> I hope one of you will give a nice demo at Dagstuhl in September
05:45:43 <edwinb> I hope I'm going - I don't know who I'll be working for then though!
05:46:01 <edwinb> Conor's giving a course on it at the AFP summer school, so it has to work by then!
05:48:29 <kosmikus> when's that summer school?
05:49:17 <edwinb> July I think
05:50:15 <kosmikus> ah, good, by then I will have more time for such things; will you release it by then?
05:52:24 <edwinb> It's going to be released Real Soon Now.
05:52:46 <edwinb> As soon as it runs a non trivial program basically.
05:53:55 <kosmikus> is it written in Haskell, btw?
05:54:18 <kosmikus> do you have anything on what the syntax will look like?
05:54:52 <edwinb> I could use this opportunity to plug my draft thesis ;)
05:55:11 <edwinb> Or you could read "The View From The Left" in the latest JFP.
05:55:41 <edwinb> It is written in Haskell. I don't think I'd want to write a programming language in anything else...
05:57:39 <kosmikus> I have seen the view from the left in an earlier version ...
05:57:59 <kosmikus> draft thesis is where?
05:58:56 <edwinb> http://www.dur.ac.uk/e.c.brady/ps/thesis.ps
05:59:09 <edwinb> It's more about how to implement such a beast, although there's quite a few examples.
05:59:44 <kosmikus> it's hard to imagine for me (from view ft left) how all this would look as actual code
06:00:19 <edwinb> Ah, yes, we do like to take advantage of the fact that LaTeX isn't ASCII.
06:01:51 <kosmikus> so, can I run a .tex file through your compiler?
06:02:30 <edwinb> Heh, not quite. The syntax is ASCII. It's a bit weird though, writing natural deduction style declarations in ASCII.
06:02:35 <ozone_> jo
06:02:44 <shapr> j0
06:02:55 <ozone_> any utrecht folks around?
06:02:59 * ozone_ taps kosmikus and earthy 
06:03:06 <edwinb> It's likely to be more visual and interactive.
06:03:14 <kosmikus> ozone_: I'm here
06:03:31 <ozone_> kosmikus: hey :)  tried using type classes in helium 1.2, looks like a no-go
06:03:45 <ozone_> just thought i'd let you know, i'm not expecting it to be fixed :)
06:03:54 <kosmikus> ozone_: you can't define any, if that's what you mean
06:04:48 <kosmikus> edwinb: I've downloaded your thesis, but I'm afraid I won't read it very soon because I have to write my own ...
06:05:04 <edwinb> That's quite reasonable ;)
06:05:13 <ozone_> edwinb: what's your thesis on?
06:05:17 <ozone_> kosmikus: ah, i see
06:05:19 <edwinb> (I have to rewrite mine now...)
06:05:31 <_Codex> I have a nice problem (the thesis above reminded me about it) -- how to do Q such way that addition does not require cuts/reductions (2/4 => 1/2 :-)
06:05:36 <ozone_> so i guess definable type classes aren't implemented yet (or maybe that's what you were referring to in cvs)
06:05:40 <edwinb> ozone_: Implementing a dependently typed programming language.
06:05:53 <ozone_> edwinb: schweet.  have you finished it?
06:06:19 <edwinb> Yes and no. My supervisor still hasn't told me the many thousands of things which are wrong with it...
06:06:20 <kosmikus> ozone_: no, definable type classes are afaik not even in cvs
06:06:28 <_Codex> the reduction makes a number have more than one representation and that's bad.
06:06:51 <kosmikus> the point is to have type classes to the extent to be able to use all standard examples from text books
06:07:02 <ozone_> edwinb: is your thesis write-up available on the 'net?
06:07:11 <ozone_> kosmikus: right, i understand
06:07:29 <kosmikus> helium is, at least for now, not designed to replace Haskell; our students switch to ghci once they get that far
06:07:55 <ozone_> so, i had this idea about the haskell module system, which the recent discussion on the haskell mailing list reminded me of
06:08:06 <ozone_> might as well run it by you folks so i can get shot down now rather than later, right?
06:08:06 <edwinb> ozone_: http://www.dur.ac.uk/e.c.brady/ps/thesis.ps
06:08:29 <ozone_> edwinb: thank you, i'll do my best to read it :)  (10 seconds until it's downloaded)
06:08:43 <ozone_> anyway, idea: per-type namespaces
06:08:47 <ozone_> like you have in OO languages
06:09:23 <kosmikus> so I can say [].[] to refer to the qualified "nil" constructor? 
06:09:35 <ozone_> kosmikus: right, something like that
06:09:43 <ozone_> so if you adopt an OOish syntax with the . as a separator
06:09:49 <kosmikus> and then I can reuse constructor names?
06:09:53 <ozone_> you can write something like foo.cut, and then write bar.cut
06:10:08 <edwinb> Yeah, that'd be useful...
06:10:09 <ozone_> then you can have two different cut functions, with two completely different type signatures
06:10:19 <ozone_> perhaps implemented via syntax sugar
06:10:30 <kosmikus> what's foo and bar in your example?
06:10:31 <ozone_> so foo.cut expands to Foo.cut foo (Foo being the module name)
06:10:39 <ozone_> and foo is of type Foo :)
06:10:57 <edwinb> I'd like to be able to refer to fields of records that way, so I can reuse field names.
06:11:01 <ozone_> the idea being that you get namespace seperation for types
06:11:13 <ozone_> edwinb: well, i think that's a different story, although i'd love that too
06:11:20 <kosmikus> I'm afraid I don't understand it (yet)
06:11:34 <ozone_> kosmikus: okay, so in OO languages, you have methods which belong to classes, right
06:11:39 <kosmikus> yes
06:11:51 <ozone_> one big benefit is that automatically gives you namespace separation of functions
06:12:01 <ozone_> because each class is (usually) a type
06:12:09 <ozone_> so you can write foo.cut and bar.cut, and there's no ambiguity
06:12:17 <ozone_> in haskell, you have a per-module namespaces
06:12:46 <kosmikus> ah, I see
06:12:47 <ozone_> which kinda sucks, because that means once a function name is defined, you cannot call your own function that, even though it may make perfect sense to do so
06:12:57 <ozone_> so you rely on the module system to separate that out
06:13:02 <ozone_> but the module system isn't very powerful
06:13:11 <ozone_> so i had an idea of per-type namespaces
06:13:25 <kosmikus> so, if I write foo.cut, the compiler checks foo to be of type Foo, and then selects the cut function belonging to type Foo
06:13:29 <ozone_> so, like in OO, you more closely associate a function with a particular type
06:13:32 <ozone_> right, exactly
06:13:38 <ozone_> which may be syntactic sugar
06:13:40 <kosmikus> what about polymorphism
06:13:50 <ozone_> kosmikus: ahah, okay, you still have a global namespace
06:14:06 <ozone_> the idea is this: you have per-type namespaces for functions which have a "primary" type associated with them
06:14:06 <kosmikus> f x = x.cut
06:14:35 <ozone_> so for all the functions which are, say, associated with a FiniteMap data type, it makes sense to use fm.functionName notation
06:14:44 <ozone_> but then you lose alot of the benefits of polymorphism
06:14:58 <ozone_> so, the idea is this: you must still have a 'global' (default) namespace
06:15:09 <ozone_> and more functions like map, fold, + etc all belong there
06:15:32 <kosmikus> hmm, so you're saying, cut has a default type, and if I write the function definition above, it will be non-polymorphic
06:15:37 <ozone_> i was toying around with the idea that any functions which belong in the global namespace _must_ be polymorphic
06:16:26 <ozone_> kosmikus: no, i'm saying that you need some mechanism to somehow declare a function which belongs to a particular type's namespace
06:17:24 <ozone_> so, let's say for something like the finitemap data type, you can write: "functions which belong to type FiniteMap { empty :: ...; unit :: ...; toList; ... }"
06:17:36 <ozone_> (instead of "emptyFM", "unitFM", "listToFM", etc)
06:18:00 <_Codex> ozone: so you have two kinds of functions (global vs. per-type), two kinds of constructors/destructors?
06:18:03 <kosmikus> all okay, but what *is* the type of "f x = x.cut" ?
06:18:21 <ozone_> what's "f x" in your example?
06:18:24 <ozone_> and what's the type of x?
06:18:28 <kosmikus> it's a function declaration
06:18:33 <ozone_> oh, right
06:18:51 <kosmikus> to be precise, what's the type of "f" in this declaration
06:18:53 <ozone_> type of 'f x' then takes whatever the type of x's cut function is
06:19:16 <kosmikus> how would you write that as a type?
06:19:17 <ozone_> _Codex: yeah
06:19:42 <kosmikus> I mean, what would ":t f" in ghci tell me?
06:19:56 <ozone_> kosmikus: so, let's concretise the example and say we're dealing with lookupFM
06:20:02 <ozone_> so the type of that is lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
06:20:30 <kosmikus> yes
06:20:40 <ozone_> so now let's say you have a lookup function defined for the FiniteMap type, you can write someFiniteMap.lookup instead of lookupFM
06:21:04 <ozone_> then if you write 'f x = x.lookup', that will have exactly the same type as lookupFM
06:21:22 <ozone_> ah, now i see what you're getting at
06:21:25 <kosmikus> even though I might have "lookup" functions for other types as well?
06:21:54 <ozone_> kosmikus: yeah, i see what you mean, the type of f now changes depending on what context its used in
06:22:42 <kosmikus> right
06:22:50 <ozone_> kosmikus: simplistic solution may be to disallow that kind of thing
06:23:10 <ozone_> since i was toying around with the idea that perhaps things in the default namespace all must be polymorphic
06:23:21 <_Codex> isnt x.cut same as cut x? Thus f x = x.cut is same as f=cut?
06:23:30 <ozone_> (e.g. something like map)
06:23:49 <kosmikus> _Codex: yes, I could have asked what the type of "cut" is ...
06:24:25 <kosmikus> ozone_: have you read all the record proposals?
06:24:48 <ozone_> well, if you can statically infer what the type of x is in 'f x = x.lookup', then maybe that'd work.  (the type of f x is then exactly what the type of x.lookup is)
06:25:02 <ozone_> so if you then use f on something not of that type, you get a type error
06:25:15 <ozone_> kosmikus: i've been looking at Trex a bit, and also at spj's records proposal
06:25:35 <ozone_> haven't read them well enough to think about them deeply, though
06:26:37 <ozone_> _Codex: i think that should be OK, actually.  that assumes that you haven't defined a 'cut' in the global namespace yet
06:26:58 <ozone_> if you haven't, it should be able to infer the type and work it out?  (but i'm not a type theorist, so i dunno if that's true)
06:27:22 <ozone_> and if you have, you get an error because you're trying to redefine a cut function which already exists
06:27:33 <kosmikus> ozone_: as I see it, you either need a record type system, or you need to introduce the dot-notation x.y as a special syntactic construct that only works if x can be inferred to have a monomorphic type
06:27:38 <ham> hiho
06:27:39 <ozone_> so you cannot have the same name for a per-type function and also one in the global namespace
06:28:26 <ozone_> kosmikus: sorry, yes, i should've pointed out that this is if x is a monomorphic type only
06:28:29 <ozone_> (which is a common case)
06:28:49 <kosmikus> kosmikus: next problem is, when can a function belong to a type
06:28:59 <_Codex> ozone_: that would be ideal place for polymorphism -- per-type function would implement part of global function's behaviour.
06:29:00 <kosmikus> you seem to indicate that everything is based on the first argument
06:29:23 <ozone_> kosmikus: yes
06:29:27 <ozone_> (or at least some argument, anyway)
06:29:36 <kosmikus> so I cannot have:
06:29:44 <ozone_> _Codex: you mean that the per-type function could be used as part of a type class?
06:29:46 <kosmikus> foo1 :: Int -> Bool -> Bool  belonging to Bool
06:29:47 <kosmikus> and
06:29:54 <kosmikus> foo2 :: Int -> Int -> Bool  belonging to Int
06:30:06 <kosmikus> well, both under the same name, actually
06:30:54 <_Codex> ozone: yes.
06:31:03 <ozone_> kosmikus: in what case would foo1 belong to bool?
06:32:06 <kosmikus> by definition?
06:32:14 <ozone_> kosmikus: basically, i'm looking at the Data modules now, and i can't see any modules where the function doesn't have the type it manipulates in the argument list
06:32:31 <ozone_> e.g. all of Data.PackedString has functions which take in a PackedString somewhere in their argument list
06:32:32 <kosmikus> foo1 does have Bool in the argument list
06:32:47 <kosmikus> just not as first argument
06:33:35 <ozone_> kosmikus: so, you mean, if we pick the first argument as the type to operate with, then you'd have to define foo1 as :: Bool -> Int -> Bool ?
06:33:44 <ozone_> (instead of the type definition you gave, which is preferable)
06:34:37 <kosmikus> well, yes
06:35:04 <ozone_> then you're forced to change the type definition to :: Bool -> Int -> Bool
06:35:06 <kosmikus> if I understand you correctly, a function foo that is defined as belonging to a type A is not first class in your system
06:35:21 <kosmikus> and can only be used in a context where its first argument's type is known
06:35:46 <ozone_> yes, it can only be used where its first argument type is known
06:36:00 <ozone_> so if you write x.f, x's type must be known so that you can know which f to call
06:36:09 <ozone_> but i'm not sure what you mean by f not being first-class
06:36:31 <kosmikus> "f" does not have a type in your system
06:36:51 <kosmikus> you cannot pass it around as argument to other functions
06:37:10 <ozone_> f does not have a type, but x.f does
06:37:20 <ozone_> (f probably doesn't exist)
06:37:40 <kosmikus> yes, that's why "f" is not first class
06:37:53 <ozone_> ok.  would you consider x.f to be first class?
06:38:03 <kosmikus> yes
06:38:56 <ozone_> i think the question is really whether the type system is powerful enough to be able to deal with such a syntax
06:39:01 <kosmikus> but I'm not sure that is sufficient
06:39:37 <ozone_> if you can always guarantee that whenever you see x.f and you know that x is monomorphic, you know you have to use the right f function, no?
06:39:52 <kosmikus> yes
06:40:56 <ozone_> i think i'll have to actually implement this to see whether it works
06:41:09 <ozone_> my head's too small to think about all the possible issues :)
06:41:18 <kosmikus> I think it works
06:41:41 <kosmikus> it's just not very general
06:41:53 <ozone_> general?
06:42:54 <kosmikus> can't you do the same thing, only better, with a single parameter type class?
06:43:28 <ozone_> you cannot, as far as i understand
06:43:53 <kosmikus> then I'm still missing something
06:43:54 <ozone_> because what you want is different type signatures for a particular type's function name
06:44:08 <ozone_> let me see if i can find an example
06:44:10 <kosmikus> ah, sorry
06:44:13 <kosmikus> my fault
06:44:58 <ozone_> ok, here's one
06:45:10 <ozone_> so there's a "phase" function in Data.Complex
06:45:19 <ozone_> phase :: RealFloat a => Complex a -> a
06:45:25 <ozone_> now, let's say you have a data type called ... "Moon" :)
06:45:46 <ozone_> and you have a "phase" function for that, which has a type signature of, i dunno ... phase :: Moon -> MoonPhase
06:46:14 <ozone_> how do you reconcile those two types into a type class?
06:46:32 <kosmikus> no, sure, as I said, it was my mistake
06:46:36 <ozone_> i mean, you could, but you'd need unrealistically good foresight to implement such a type class in advance
06:47:11 <ozone_> no problem, at least now you made me type out what the crux of the problem i'm trying to solve is
06:47:13 <kosmikus> ozone_: with a multi-parameter type class and fundeps, no problem, but then again, everything can be encoded using those
06:47:25 <ozone_> kosmikus: totally agreed, but the problem is foresight
06:47:34 <ozone_> so once you define phase, it's defined forever
06:47:36 <ozone_> no turning back man!
06:47:48 <ozone_> you can get separation by the module system, but it sucks
06:47:55 <ozone_> (for reasons that alastair pointed out)
06:48:22 <kosmikus> yes, but watch out with your monomorphism restriction ;)
06:48:29 <kosmikus> phase :: RealFloat a => Complex a -> a
06:48:31 <ozone_> and it feels somewhat inferior to be typing in something like 'complexPhase aComplexNumber' and 'moonPhase aMoon' when 'moon.phase' and 'complex.phase' will do
06:48:55 <kosmikus> do you want to already associate phase with "Complex", even without knowing "a"?
06:49:06 <ozone_> kosmikus: hehe, no problem with -no-monomorphism-restriction on ghc ;)
06:49:25 <ozone_> kosmikus: not sure what you mean about not knowing 'a'
06:50:34 <kosmikus> no, well, I guess you should just write down some rules ;)
06:50:53 <ozone_> kosmikus: ok, thanks for the discussion
06:51:03 <kosmikus> np
06:51:05 <ozone_> wanted to see if i was being dumb and if there were some gaping holes that i missed
06:51:17 <ozone_> i think you have given me enough courage to mail haskell-cafe about it
06:51:37 <kosmikus> I think there's something called System O which does overloading on the first argument
06:51:39 <ozone_> (am wondering how long it will take for someone like simon marlow to write a one-line reply saying it won't work because of x)
06:51:42 <kosmikus> Odersky or so
06:52:20 <kosmikus> ozone_: depends on what you want; if you want to have it *in Haskell*, I think that's not very likely
06:52:38 <kosmikus> if you want to demonstrate that it could work, I'm not that worried
06:52:55 <ozone_> interesting, system o is referenced in spj/shield's paper on OO overloading in haskell
06:53:55 <_Codex> I really wonder why people want OO to haskell so much?
06:54:34 <kosmikus> because OO and FP are somewhat orthogonal, and one isn't necessarily better than the other
06:54:35 <ozone_> _Codex: because there's lots of OO frameworks in the world
06:54:44 <ozone_> that too :)
06:55:06 <ozone_> odersky was the guy who did scala, right?
06:55:13 <kosmikus> so it's logical to ask why one cannot have both?
06:55:21 <kosmikus> ozone_: yes
06:55:40 <kosmikus> scala, GJ, Pizza, ...
06:56:30 <_Codex> I feel its just too much overlap/duplicated functinality to have both
06:57:00 <ozone_> _Codex: i think that realistically, it's important to be able to use OO frameworks
06:57:06 <ozone_> simply because of the sheer amount of them that are out there
06:57:13 <ozone_> which implies that you need some OO support
06:57:46 <ozone_> kosmikus: reading the System O paper now, thanks for the tip
06:57:52 <earthy> well, Xlib is somewhat OO
06:58:00 <earthy> and that's interfaced to C...
06:58:29 * kosmikus will work a bit for a change
06:58:31 <earthy> so you *could* implement the objects and inheritance and stuff in a datatype with appropriate functions on it
06:58:55 <earthy> but you'd have to implement your own typing and stuff
06:59:04 <earthy> that's possible right now
06:59:17 <ozone_> yes, which means that integration with such OO frameworks sucks
06:59:26 <earthy> not necessarily
06:59:31 <ozone_> (because you can't work with the constructs of your host language)
06:59:44 <earthy> you wrap the OO framework in a higher level functional interface
06:59:47 <earthy> and hey presto
06:59:52 <earthy> (see e.g. wxHaskell)
07:00:01 <_Codex> you just need foreign interface generator that takes C++ class and outputs some instance declarations.
07:00:43 <earthy> ummm... subtyping? multiple inheritance?
07:01:06 <ozone_> earthy: that means that you have to deal with each OO framework on an individual basis
07:01:10 <ozone_> that's no fun
07:01:38 <ozone_> i agree you get a better functional interface for it, but i don't think that the entire .net framework will have a nice functional wrapping, for instance :)
07:01:50 <earthy> :)
07:01:51 <_Codex> earthy: derived-to-base conversion is just a destructor call.. => MI is just two destructors :)
07:03:10 <ozone_> _Codex: so why aren't there any java->hs or C++ to HS wrappers if it's that easy? :)
07:03:28 <ozone_> it's possible to do
07:03:41 <ozone_> but you usually get zero support from haskell to do it
07:03:43 <_Codex> maybe its because parsing C++ is nasty task.
07:03:52 <ozone_> so it's like you just extern C the entire OO framework
07:04:03 <ozone_> and bring that across to haskell land
07:04:20 <ozone_> which makes using OO things in haskell no fun
07:05:17 <ozone_> you really want to model an OO type system in haskell
07:05:32 <earthy> and have it typechecked statically
07:05:33 <ozone_> otherwise you will end up with function names with types encoded in them, so you know which OO method to dispatch
07:05:35 <earthy> and that's *tough*
07:05:37 <ozone_> and that's all bad
07:06:01 <ozone_> (see ashley yakeley's java<->hs bridge for an example of this)
07:06:45 <ozone_> it makes using that framework in haskell so painful that you'd rather go implement it all yourself, which means that you must undertake a big effort just to use these silly libraries
07:08:12 <SamB> ozone_: no, you want to *not use C++*
07:08:38 <ozone_> SamB: you have little choice if that C++ library gives you everything you want to use
07:08:41 <ozone_> e.g. wxHaskell
07:08:57 <ozone_> or .NET, or MFC, or whatever
07:09:14 <ozone_> (i know that was a joke, but anyway :)
07:10:00 <SamB> you do not want MFC, the license is really bad for you. particularly because it is mostly headers.
07:10:20 <ozone_> SamB: well, take directshow as an example
07:10:41 <ozone_> i'd love to be able to write directshow filters in Haskell rather than C++
07:10:58 <SamB> ozone_: doesn't directshow have a reasonable C interface?
07:11:06 <ozone_> SamB: directshow is C++
07:11:22 <ozone_> there may be a c wrapper for it, but i'm doubtful that it'll expose the entire functionality
07:11:48 <SamB> ozone_: what are the directshow headers called?
07:12:10 <ozone_> i'm not sure what you mean
07:12:48 <SamB> hmm, I guess if all I have is are {d3d,d3d8,ddraw,dinput,dsound}.h, that doesn't include directshow.
07:13:04 <ozone_> indeed :)
07:44:17 <SamB> hmm, it looks to me as if there is a C interface of some kind.
07:48:38 <SamB> yes, there most certainly is. read your headers?
07:49:14 <ozone_> not sitting in front of my windows box right now.  are there msdn docs for a c interface to directshow?
07:49:21 <ozone_> (never mind that this is dodging the point :)
07:55:16 <ozone_> dingding, email sent
07:55:22 <ozone_> let's see how much i get flamed for this
08:01:55 <SamB> ozone_: I was using the wine headers, actually
08:02:38 <ozone_> right
08:02:49 <ozone_> i think it's still dodging the point about OO frameworks, mind you :)
08:02:58 <SamB> ozone_: and it very much resembles the microsoft directx headers I have
08:04:37 <SamB> well, perhaps. but I don't think changing Haskell to make it more like C++ is a good idea.
08:04:58 <ozone_> nothing wrong with stealing good concepts found in other languages
08:06:11 <SamB> well, I don't think that the concept in question would be very good for Haskell.
08:07:00 <ozone_> i think if haskell cannot play well with OO, it will be doomed to be a niche language
08:07:53 <SamB> I'm sure it could play with OO. but it would help if you first started with an OO playmate for it to play with ;-)
08:08:24 <ozone_> C++, .NET ... what other playmates do you want? :)
08:09:26 <SamB> C++ is not OO. somewhere, someone said that stroustroup himself said that. but I forget which channel that was!
08:09:38 <ozone_> that's total bollocks
08:09:44 <ozone_> C++ is multi-paradigm, yes
08:09:51 <ozone_> but it's primarily used in an OO way
08:10:18 <nysin> This: " 	 'I invented the term 'Object-Oriented', and I can tell you I did not have C++ in mind.' - Alan Kay"?
08:11:29 <SamB> nysin: well, that isn't stroustroup, but it will do!
08:11:45 <ozone_> nysin: yeah, i know that quote :)
08:11:55 <ozone_> and my point is still valid
08:12:18 <nysin> Yeah, I haven't ever heard of Stroustrop say anything of the nature, and the quotation I pasted is the standard one to this effect.
08:12:38 <SamB> ozone_: well, C++ is just *too crufty* to integrate
08:12:48 <ozone_> i don't care about integrating C++ into haskell
08:12:56 <ozone_> i do care about using APIs written in C++
08:13:08 <ozone_> because there's a truckload of them out there
08:15:23 <Etaoin> http://www.research.att.com/~bs/bs_faq.html#Object-Oriented-language
08:15:27 <SamB> what you seem to want sounds like it would require some pretty drastic changes to the type system.
08:15:38 <Etaoin> is that what you meant?
08:16:06 <Etaoin> Pseudonym pasted it a few days ago
08:17:02 <ozone_> SamB: maybe.  but either the type system supports it, which makes integrating with OO frameworks much easier, or it doesn't, and integrating with them is a nightmare
08:17:34 <ozone_> i think we're 95% of the way there already
08:17:47 <ozone_> it remains to be seen whether the last 5% can be conquered in the existing type system
08:18:11 <ozone_> (i should probably point out at this stage that my thesis was on integrating haskell with OO languages)
08:20:07 <SamB> the interaction between C++ style overloading and type classes would be very tangley
08:21:32 <ozone_> SamB: see http://www.cse.unsw.edu.au/~chak/papers/PC03.html
08:22:00 <ozone_> as i said, we've got 95% of the way there.  now we just need to do the last 5% :)
08:28:06 <SamB> ok, maybe it would work. but it sounds like a very heavyweight solution!
08:31:36 <ozone_> how is it heavyweight?
09:10:27 <ham[marubi]> bk
09:39:10 <ski> bk ?
09:39:24 <earthy> interesting proposal ozone
09:39:57 <earthy> however, I think Keith Wansbrough has hit the nail on the head: what does your proposal provide that type classes do not?
09:50:10 <jameson> Ummh... first of all, class inheritance != subtyping.
09:52:09 <jameson> Secondly, I'd argue that Haskell does have subtyping... after all, it is possible to define a type class A in terms of a previously defined type class B, which, IMHO, guarantees A <: B. Unless I'm very mistaken, you can always use types T of type class A in places where B is required.
09:52:15 <ozone_> earthy: see reply
09:52:18 <ozone_> earthy: (just sent it)
09:52:23 <ozone_> also see reply to keith :)
09:53:05 <jameson> (That's just wrt the first section of the proposal)
09:53:09 <ozone_> jameson: it's not subtyping because it's not types you're dealing with, it's a number of possible types
09:53:56 <ozone_> you get something of the same effect, but you also don't because type classes have different assumptions (e.g. subtyping is a open-world model, whereas type classes are a closed-world model ... or maybe that was the other way around, i forget)
09:54:44 <jameson> OK; I agree that there's a difference wrt subtyping. However...
09:55:18 <jameson> both models are "open-world" (if I interpret this term intuitively), as, in both cases, you can add new concrete types that adhere to a previously defined type/type class.
09:55:40 <jameson> With a type class, you create a type class instance, or a type class instance of a sub-typeclass.
09:56:01 <jameson> With an OO-style type, you directly create a subtype.
09:56:02 <ozone_> that's right, but the type inference mechanism works differently
09:56:07 <ozone_> where's this example i had ...
09:56:23 <ozone_> ah
09:56:23 <ozone_> instance (SubNSMovie m, SubNSURL u, ObjCArgument u, ObjCMessageReply m, ObjCObject m) =>
09:56:26 <ozone_>                     DirectMessage m ObjCMethodName_initWithURL_byReference (u, Bool) m
09:56:29 <ozone_> instance (SubNSTextField m, SubNSURL u, ObjCArgument u, ObjCMessageReply m, ObjCObject m) =>
09:56:32 <ozone_>                     DirectMessage m ObjCMethodName_initWithURL_byReference (u, Bool) m
09:56:36 <ozone_> so there, you have two instance declarations
09:56:48 <ozone_> in an OO languages, it's no problem to do the equivalent of that with subtyping
09:56:49 <ozone_> but in haskell:
09:56:55 <ozone_> ./DirectMessagingExample.hs:90:
09:56:56 <ozone_>     Duplicate instance declarations:
09:56:56 <ozone_>       ./DirectMessagingExample.hs:90: DirectMessage m
09:57:05 <ozone_> (that's _duplicate_ instance declaration, not overlapping)
09:58:06 <ski> what would that mean in OO langs ?
09:59:00 <ozone_> that's the equivalent of declaring two classes, NSMovie and NSTextField
09:59:10 <ozone_> and declaring a method in both of them named initWithURL_byReference
09:59:45 <ozone_> or rather, initWithURL_ByReference(NSURL, Bool)
10:00:05 <ski> hmm, encoding method-name in the type arg of the class ?
10:00:25 <ozone_> ski: yeah, this is what i did for my thesis (OO-style dispatch in haskell)
10:00:44 <ozone_> ski: http://www.cse.unsw.edu.au/~chak/papers/PC03.html for the summary
10:00:56 <ozone_> (summary == 16 pages, instead of my thesis which is ~70)
10:01:02 <ozone_> (and my thesis is crappier :)
10:01:04 <ski> (ok, then that's why i didn't at first understand what OO thing this was mapped from :)
10:01:27 <ozone_> ski: hehe, that's taken from real-life code that wolfgang thaller is writing
10:01:28 <ski> ozone_ : is it done yet ?
10:01:36 <ozone_> the paper, you mean?
10:01:42 <ski> your, yes
10:01:50 <ozone_> the paper is done now, yes
10:02:00 <ozone_> i think the version on manuel's website is actually the final one, not the draft
10:02:17 <ozone_> the code for the binding is working now too, although it's not documented yet :(
10:02:25 <ski> (i meant *your* thesis)
10:02:27 <jameson> ozone_: I don't see the reason for why it's failing. I guess I should read the paper in its entirety.
10:02:43 <ozone_> ski: oh, sorry ... yes, thesis is finished, thankfully :)
10:02:54 <ozone_> jameson: it's because type classes use type variables
10:02:59 <ozone_> whereas subtyping uses concrete types
10:03:07 <ozone_> so there, those two instance declarations are exactly the same
10:03:08 <ski> jameson : perhaps because the class heads are identical ? (just a guess)
10:03:10 <ozone_> you cannot do:
10:03:52 <ozone_> instance Parent1 t => Child t
10:03:54 <ozone_> and then do
10:03:59 <ozone_> instance Parent2 t => Child t
10:04:04 <ski> right
10:04:07 <ozone_> because the type variable is exactly the same
10:04:28 <ski> class Child extend Parent 1 {}
10:04:39 <ski> class Child extend Parent2 {}
10:04:47 <ski> hmm ?
10:05:09 <ozone_> hmm, maybe that example isn't valid because it uses a multi-parameter type class
10:06:36 <ozone_> (so there's no analogy in OO)
10:06:45 <ski> mhmm
10:08:27 <ozone_> i'm sure some type theorists can point out the differences :)
10:08:36 <ozone_> (which i'm definitely not)
10:08:56 <ozone_> earthy: get the reply?
10:10:35 * ski 's reading the log for today, to catchup with this namespace and OO discussion, will then comment some ..
10:10:52 <ozone_> ski: summary is on the haskell mailing list
10:12:11 <jameson> ozone_: Is there some relation between the TCs SubNSMovie and SubNSTextField in the above?
10:12:57 <jameson> (in particular, is one a sub-TC of the other?)
10:12:58 <ozone_> jameson: they both inherit from a common parent type class (SubNSObject)
10:13:07 <ozone_> no
10:13:25 <ski> ozone_ : summary of what ?
10:13:38 <ozone_> the namespace stuff i was talking about on #haskell
10:19:13 <ozone_> off to bed, nite all
10:19:22 <ski> ozone_ : hmm, which thread ?
10:19:33 <jameson> ozone_: OK, good night!
10:19:39 <ozone_> it was the "Data.Set wishes" thread
10:19:41 <Jad> hello guys
10:20:05 <ski> ozone_ : so you're leaving now, just as i finished reading the log, eh ? ;)
10:20:10 <ski> Jad : hello
10:20:51 <ozone_> ski: oh, okay, hang on a sec :)
10:21:40 <ozone_> ski: my initial post is at http://www.haskell.org//pipermail/haskell/2004-February/013697.html
10:22:40 <ski> hmm, anyway, re some of what you said above here :
10:23:25 <ski> i'm a little bit annoyed about having constructors like e.g. TBool, EBool, VBool
10:23:44 <ski> so i would perhaps like some kind of nested modules
10:24:03 <ski> so i can have Type.Bool, Expr.Bool, Value.Bool
10:24:27 <ozone_> why the three different types?
10:24:36 <ski> and the types are then Type.Type, Expr.Expr, Value.Value
10:24:42 <ozone_> (just trying to wrap my head around the problem)
10:24:59 <ski> Or, in ML style : Type.T, Expr.T, Value.T
10:25:24 <ski> One could also try to sortof merge the type (name) with the module
10:25:36 <ski> so Type, Expr, Value is types
10:25:51 <ski> while Type.Bool,Expr.Bool are constructors
10:26:23 <ski> one could also have programmer-defined values/functions in these modules like Expr.eval, and so on ...
10:27:03 <ski> ozone_ : re "why the three different types?" : this is an example for making an interpreter for an object language
10:27:33 <ski> the types Type, Expr, Value represents those concepts in the object language. clear ?
10:27:43 <ozone_> right
10:28:10 <ozone_> keep going, still trying to make sense of your scenario
10:28:58 <ski> so, either, if one could declare local modules, to declare a type (and perhaps some utility functions, perhaps also, "private" implementation details)
10:29:08 <ski> that would work, i think
10:29:34 <ski> though one would have to type types like Expr.Expr (<module>.<type> i.e.)
10:29:55 <ski> or at least Expr.T (if we name the type T, and mostly use the module qualified)
10:30:21 <ski> *or* one could sortof intergrate this with a single type
10:30:49 <ski> (but still perhaps have the possibility of local programmer-defined values and function)
10:30:50 <ozone_> hmm
10:31:03 <ozone_> my head's spinning a bit trying to understand what you're saying, sorry
10:31:11 <ski> hmm, ok
10:31:25 <ski> first idea is just basically local modules
10:31:32 <ski> module Expr
10:31:33 <ski>   where
10:31:47 <ski>   data Expr = Bool Bool | If Expr Expr Expr
10:31:51 <ski>             | ....
10:31:59 <ski>   eval :: Expr -> ...
10:32:04 <ski>   eval ... = ...
10:32:23 <ski> and then one can use this from the outside, qualified
10:33:02 <ski> (this is already possible in haskell, though one *has* to put this into another file, designated to this module (at least in hugs and ghc, i think))
10:33:04 <ski> ok ?
10:33:46 <ozone_> right
10:33:51 <ski> ok
10:33:57 <ozone_> ok, got that bit :)
10:34:07 <ski> so we'd probably  import qualified Expr as E
10:34:23 <ski> and then use E.Expr and E.Bool,E.If and E.eval ...
10:35:13 <ski> i sometimes would like to put this module as a submodule of another module (often not even exported by the host/parent module)
10:35:47 <ski> i.e. for (internal module) separation of "primitive"/derived operations of some type
10:35:59 <ski> s/i.e./e.g./
10:37:15 <ski> (often this "sub-module" would be quite small, so perhaps a contributing factor to this feeling is an unwillingness to spend a new file + filename on just this single sub-module. or am i just lazy/bad-modularizer ?)
10:37:36 <ozone_> hehe
10:37:58 <ozone_> i think if you have such submodules, the convention with the hierarchical libraries is to call them Foo.Internal
10:38:01 <ski> the other idea i had (based on this), that i was reminded of by your "dot-notation" above was : ...
10:38:11 <ski> hmm
10:38:14 <ozone_> then in Foo, import Foo.Internal as qualified I, or whatever
10:38:51 <ski> is this the syntax for (re)exporting (currently only imported modules) :
10:39:01 <ski> module Foo (module Bar, ....) where
10:39:04 <ski> import Bar
10:39:08 <ski> or is it
10:39:19 <ski> module Foo (Bar(..),....) where
10:39:23 <ski> import Bar
10:39:24 <ski> ?
10:40:04 <ski> maybe (exported) internal modules could be handled somewhat similar to this ..
10:40:20 <ozone_> i think it's the latter, but i can't remember
10:40:24 <ski> ok
10:40:30 <ski> anyway, the second idea
10:40:51 <ski> make the name of the type = the name of the (sub-)module
10:40:57 <ski> perhaps :
10:41:13 <ski> module type Expr = Bool Bool | If Expr Expr Expr
10:41:16 <ski>                  | ....
10:41:18 <ski>   where
10:41:25 <ski>   eval :: Expr -> ....
10:41:28 <ski>   eval .... = ....
10:41:47 <ski> and then, from the outside, Expr is the type
10:41:57 <ski> and Expr.Bool, Expr.If are constructors
10:42:14 <ski> and Expr.eval are programmer-defined values and functions
10:42:14 <ozone_> right
10:42:19 <ski> i.e
10:42:25 <ozone_> (have to go in about 5-10 minutes btw, battery is running low now :)
10:42:27 <ski> what does this buy us ?
10:42:43 <ski> ozone_ : ok, try to not be too slow, then ..
10:42:51 <ski> this buys us :
10:43:09 <ski> we dont have to write Expr.Expr (or Expr.T or whatever)
10:43:26 <ski> we have one type associated with the "module"
10:43:34 <ozone_> hey man, it's nearly 6am, i think i'm allowed to be slow. :D
10:43:44 <ski> (perhaps one could also allow other auxilary types in the module ...)
10:43:49 <ozone_> from within the module, you mean?
10:43:55 <ski> no
10:43:58 <ski> i mean
10:44:15 <ski> if we ask :t eval from outside
10:44:29 <ozone_> but what if you have eval defined in another module?
10:44:30 <ski> we don't get  Eval.eval :: Eval.Eval -> ...
10:44:52 <ski> (sorry, s/eval/Eval.eval/ in previous previously one)
10:45:07 <ski> we get   Eval.eval :: Expr -> ...
10:45:18 <ozone_> oh
10:45:23 <ozone_> i think i see
10:45:30 <ski> (also s/Eval.Eval/Expr.Expr/, can't seem to spell today ;)
10:45:34 <ski> so
10:45:41 <ski> in your syntax above
10:45:45 <ski> we could have
10:45:49 <ski> expr.eval
10:45:55 <ski> my syntax only allows
10:45:57 <ski> Expr.eval
10:45:57 <ozone_> so you have a closer association between the module and the type
10:46:12 <ski> i.e. only dot-notation on modules, not on expressions
10:46:31 <ozone_> right
10:46:31 <ski> (so my idea is less like a class than yours, then, i think)
10:46:46 <ozone_> i see
10:46:49 <ski> so module = type (+ extras)
10:47:00 <ski> instead of module = object (of some class)
10:47:21 <ski> (by module, i here mean a particular module instance, not the interface)
10:47:46 <ozone_> i think i see
10:47:53 <ski> an object can be seen as a kind of module with hidden instance variables
10:48:01 <ozone_> with no state ;)
10:48:06 <ski> my idea is just a module with a "primary" type
10:48:10 <ski> right
10:48:13 <ozone_> i thought about that too
10:48:23 <ozone_> but that creates a tighter coupling between a module and a type
10:48:24 <ski> so i'm not sure if my idea has very much semantic content :)
10:48:28 <ski> perhaps itä'
10:48:28 <ozone_> and i dunno if that's a good idea
10:48:41 <ski> perhaps it's just more convenient ...
10:48:50 <ozone_> i think it's better to have a tighter coupling between an expression and a function to operate on that expression
10:48:51 <ski> tighter ?
10:48:53 <ski> how so ?
10:49:10 <ski> ozone_ : or do you have to leave now ?
10:49:14 <ozone_> because that expression has to have a type anyway, and you can determine from that type what function(s) are available
10:49:26 <ski> sorry ?
10:49:31 <ozone_> hmm, i think i should look over the logs tomorrow
10:49:46 <ozone_> sleep ... taking ... hold ...
10:50:03 <ski> ozone_ : ok, i'll release you then :)
10:50:08 <ski> good dreaming !
10:50:09 <ozone_> hehe, ok
10:50:11 <ozone_> talk to you soon, later
10:50:16 <ski> bye
10:51:38 <ski> (hmm, your idea is perhaps connected to coalgebraic datatypes, btw, which i've thought some little on)
10:57:10 <Marvin--> you and your coalgebras :)
10:57:25 <ski> so ? :)
10:57:40 <ski> haskell has algebras ? why not coalgebras ?
10:58:06 <ski> (haskell's lazy, that proably helps too)
10:59:01 <ski> håhåjaja..
11:20:41 <amgine> hello all
11:20:51 <amgine> i am trying to use the getCPUTime
11:20:54 <ski> hello, amgine
11:20:59 <amgine> what module should i import ?
11:21:40 <amgine> i'm using GHC
11:21:44 <amgine> and tried import System
11:21:49 <amgine> gut says it's out of scope
11:21:49 <ski> CPUTime.getCPUTime :: IO Integer
11:22:03 <amgine> ?
11:22:06 <stepcut> import System.CPUTime
11:22:11 <amgine> hmmm
11:22:12 <amgine> i see
11:22:16 <amgine> so they are subdivided
11:22:17 <amgine> thanks
11:22:22 <stepcut> yeah
11:22:33 <stepcut> they didn't used to be, but they are now
11:22:53 <amgine> System.CPUTime
11:23:04 <amgine> does it mean it's acctually a filename nambed like that ?
11:23:29 <amgine> nevermind i think i andswered my own question :)
11:25:58 <amgine> i have an IO Int how can i display it ?
11:26:05 <amgine> man i'm rusty
11:26:57 <ski> print :: Show a => a -> IO ()   IIRC
11:27:03 <ski> @type print
11:27:03 <lambdabot> print :: Show a => a -> IO ()
11:27:11 <amgine> cool
11:27:14 <amgine> thanks
11:27:24 <ski> hmm
11:27:26 <ski> well
11:27:36 <ski> anIOInt >>= print
11:27:39 <ski> or
11:27:47 <ski> do anInt <- anIOInt
11:27:52 <ski>    print anInt
11:28:21 <ski> ok ?
11:28:34 <amgine> that's to much ski
11:28:43 <amgine> i never really got into haskell that deep
11:29:05 <ski> i just meant that you can't do   print anIoInt 
11:29:14 <ski> so you have to do one of those
11:29:20 <amgine> hmm
11:29:29 <amgine> brb
11:29:41 <ski> (of, if in hugs or ghci, perhaps it also works with just typing anIoInt ...)
11:29:55 <ski> s/of/or)
11:31:20 <amgine> hmm
11:31:35 <amgine> is there an easy way for manipulating files and directories in haskell ?
11:33:04 <ski> hmm, i think there was some example on
11:33:10 <ski> @wiki HaskellNewbie
11:33:10 <lambdabot> http://www.haskell.org/hawiki/HaskellNewbie
11:33:17 <amgine> ha
11:33:18 <amgine> thanks
11:33:23 <amgine> an example would make this so much easier
11:33:24 <amgine> :)
11:33:48 <ski> (i haven't read it through, though)
11:34:40 <amgine> crap
11:34:42 <amgine> ski
11:34:46 <ski> mm ?
11:34:49 <amgine> there are modules for what i was trying to do
11:34:50 <amgine> it's cool
11:34:53 <amgine> thanks for that link
11:35:04 <ski> no prob
11:35:44 <ski> amgine : the wiki contains quite a bit of useful information, in fact
11:35:56 <amgine> i bookmarked her
11:35:56 <amgine> thanks
11:36:04 <ski> i guess you have looked at it before ?
11:36:12 <amgine> yeah
11:36:15 <amgine> but i forgat about it
11:36:25 <amgine> last time i tried getting into haskell was 6 months
11:36:48 <ski> (ok, so you know the start page is hawiki/FrontPage)
11:36:50 <ski> ok
11:37:30 <amgine> :)
11:37:35 <amgine> i figured that out
11:37:57 <amgine> i remmember last time i was seriously trying to learn the distincions between nomands and normal types
11:37:58 <ski> your familiar with wikis, then
11:37:59 <ski> ?
11:38:15 <amgine> i've used them before to read for help
11:38:19 <amgine> and i understand you can add to it
11:38:22 <ski> mm
11:38:27 <amgine> that's about it
11:38:28 <amgine> why ?
11:38:34 <ski> why what ?
11:38:39 <amgine> ohh nothing
11:38:42 <amgine> brb
11:44:15 <amgine> hmmm why Show "TEST" wont work ?
11:44:27 <ski> hm ?
11:44:31 <ski> what did you write ?
11:44:40 <amgine> hmm it does work hold up
11:45:00 <amgine> main                 =  do c <- getCurrentDirectory
11:45:00 <amgine>                               print c
11:45:05 <amgine> c is FilePath IO
11:45:13 <amgine> FilePath is synonym to string
11:46:12 <ski> no  c :: FilePath
11:46:28 <ski> no IO in type of c
11:46:44 <amgine> getCurrentDirectory :: IO FilePath
11:46:46 <amgine> i think i got it
11:46:47 <amgine> brb
11:46:47 <ski> yes
11:47:11 <amgine> i got it
11:47:12 <amgine> thanks
11:47:13 <ski> but the variable to the left of <- get type FilePath (without the IO)
11:47:42 <amgine> so c
11:47:46 <ski> '<-' "evaluates" the IO-action, to get it's returned value (in this case a FilePath)
11:47:48 <amgine> is not IO ?
11:47:53 <ski> right
11:47:54 <amgine> cool
11:48:01 <ski> see
11:48:03 <amgine> kind of comming back now :)
11:48:04 <ski> @type print
11:48:05 <lambdabot> print :: Show a => a -> IO ()
11:48:22 <amgine> so i could have done show c
11:48:29 <amgine> not print c ?
11:48:45 <ski> if you try to print 'IO something', then either it gets a type (class) error, or it just prints ><<IO Action>>"
11:48:52 <ski> no
11:48:58 <ski> you could have done
11:49:04 <ski> putStrLn (show c)
11:49:09 <ski> if you wnated to
11:49:15 <ski> @type putStrLn
11:49:15 <lambdabot> putStrLn :: String -> IO ()
11:49:24 <amgine> so c is not IO
11:49:27 <amgine> but to print it
11:49:28 <ski> or return (show c)
11:49:32 <amgine> i must convert it back to IO ?
11:49:34 <ski> if you want to return the string
11:49:38 <ski> no
11:49:44 <ski> to print it
11:49:48 <amgine> :t retkurn
11:49:51 <ski> you must either pass it to print
11:49:51 <amgine> :t return
11:49:58 <ski> @t return
11:49:58 <lambdabot> Sorry, I don't know the command "t", try "lambdabot: @listcommands"
11:50:02 <ski> @type return
11:50:02 <lambdabot> return :: Monad a => b -> a b
11:50:28 <ski> or first convert it to a string (e.g. with show) and then output that string (e.g. with putStrLn)
11:50:32 <ski> ok ?
11:51:01 <amgine> makes sense
11:51:06 <amgine> return ?
11:51:16 <ski> it is thru that both print and putStrLn given 'IO ()', but that is the io-action of printing the value/string
11:51:16 <amgine> if i did return c
11:51:41 <ski> if you did return c, then main would get type  IO FilePath
11:51:50 <ski> (which it shouldn't have !)
11:52:00 <ski> (because it is *main* !)
11:52:10 <amgine> why ?
11:52:17 <ski> (main should always have type  IO (), IIRC)
11:52:29 <amgine> but return (show c) would return Filepath
11:52:33 <ski> it is similar to  void main(......) in Java
11:52:41 <amgine> would strip the IO part ?
11:53:07 <ski> retuen (show c) would convert the FilePath to a String, and then return it
11:53:15 <ski> (so then main would get type  IO String)
11:53:20 <amgine> lol
11:53:38 <ski> if you are inside the IO-monad, you *can't* get out !!
11:53:41 <amgine> thanks this is refreshing stuff
11:53:48 <amgine> yes
11:53:53 <amgine> that's the last thing i was tackling
11:53:59 <amgine> before i stoped :)
11:54:00 <ski> your function must end in  'IO something'
11:54:04 <amgine> makes sense
11:54:20 <amgine> brb
11:54:39 <ski> from IO-things you can can non-IO-things, but not the other way around
11:55:14 <amgine> yep
11:55:23 <amgine> i understand that
11:55:27 <ski> it's like a thin film of filthyness all over the top over the clear water
11:55:56 <SamB> ski: more like oil
11:56:27 <ski> SamB : yeah.  (was trying to paraphrase Jordans WoT, BTW)
11:56:36 <amgine> what is the comment line symbol ?
11:56:41 <ski> --
11:56:52 <amgine> thnks
11:56:54 <ski> foo = 42 -- this is a comment
11:57:16 <amgine> yes i remmember now
11:57:20 <amgine> but was using ;
11:57:21 <ski> (nested) block ones are {- -} ...
11:57:33 <amgine> ahhh that one i didn't know
11:57:34 <amgine> cool
11:58:06 <ski> (so you can do {- code commented out {- some comment -} this code is still commented out -})
11:58:14 <amgine> yep i understand that
11:58:35 <ski> hmm ';' ?  Lisp ? Assembler ?
12:00:36 <SamB> >>> class heaptype(type): pass
12:00:44 <SamB> ... 
12:00:44 <SamB> >>> class Class(type):     
12:00:44 <SamB> ...     __metaclass__ = heaptype
12:00:44 <SamB> ... 
12:00:44 <SamB> >>> Class.__class__ = Class
12:00:44 <SamB> >>> 
12:00:46 <SamB> arg, not again!
12:00:58 <SamB> ...
12:01:10 * SamB considers restarting xchat
12:01:19 <ski> you're absolved this time, my child
12:01:25 <amgine> xchat was written in lisp ?
12:01:51 <Marvin--> evil person, you're using metaclasses?
12:03:12 <SamB> Marvin--: no, I'm just updating someone elses evil to do whatever it did when it still did something
12:03:45 <Marvin--> oh
12:04:10 <CrewdenX> amgine: no
12:04:20 <SamB> I have no idea why it even works. I think I was expecting an infinite loop.
12:05:16 <ski> (hmm, is there a term for that ?  cargo-cult-programming ????)
12:05:43 <earthy> dang, okay, time to read up
12:14:32 * earthy thinks you have a point with guessing that ozone may want coalgebraic datatypes
12:14:54 <ski> mm
12:15:41 <earthy> given as what he wants is typeclasses that allow either fixed kind for the functions *or* monomorphic co-position
12:16:03 <earthy> (co-argument? I always mix up the terms)
12:16:14 <ski> "fixed kind" ?
12:16:24 <ski> "co-position" ?
12:17:09 <ski> i'm not sure what you mean
12:17:15 <amgine>  No instance for (Ord (IO ClockTime)) 
12:17:16 <amgine>    arising from use of `>=' at D:/LL_Hack/hack.hs:6 
12:17:16 <amgine>  In a pattern guard for 
12:17:16 <amgine>     the definition of `newstFile': 
12:17:16 <amgine>      (getModificationTime file) >= (getModificationTime newest) 
12:17:16 <amgine>  In the definition of `newstFile': 
12:17:18 <amgine>      newstFile (file : files) newest 
12:17:18 <earthy> sorry, I'm not being clear. take a typeclass
12:17:19 <amgine>                  | (getModificationTime file) >= (getModificationTime newest 
12:17:22 <amgine>  
12:17:23 <amgine>                  = newstFile files file 
12:17:25 <amgine>                  | otherwise = newstFile files newest
12:17:28 <amgine> what does this mean ?
12:17:47 <earthy> amgine: it means that you cannot compare times under the IO monad
12:17:52 <ski> amgine : right, use "<-" in a do-block to "convert" the IO ClockTime to a ClockTime
12:17:54 <amgine> ohhh
12:18:15 <amgine> i understand now
12:18:15 <ski> do aClockTime <- anIoClockTime
12:18:22 <earthy> anyway, ski, to explain: take a typeclass. that typeclass has functions in it
12:18:26 <ski>    ... aClockTime <= ...
12:18:33 <ski> ok
12:18:42 <ski> go on
12:18:43 <earthy> currently, each such function always has the exact same kind in every instance
12:18:58 <ski> ?
12:19:07 <kosmikus> sorry, earthy, but functions are always kind *   :)
12:19:17 * earthy thinkssss
12:19:20 <ski> all functions have kind *, right ?
12:19:25 <kosmikus> yes
12:19:34 * earthy is thinking with his head on backwards
12:19:41 <ski> heh
12:19:52 <earthy> and grasping deep down back in old thoughts ;)
12:20:18 <SamB> you mean something analogous to kind, I'm sure, if it isn't called kind.
12:20:27 <SamB> maybe unmeta-kind?
12:20:31 <kosmikus> type?
12:20:36 <earthy> almost type ;)
12:20:44 <ski> you perhaps mean that all those functions has the same "shape" ?
12:20:56 * earthy thinks that might well be the correct term
12:21:01 <ski> (<=) :: Int -> Int -> Bool
12:21:11 <ski> (<=) :: Double -> Double -> Bool
12:21:31 <ski> the "shape" being  a -> a -> Bool
12:22:00 <earthy> anyway, what ozone seems to want is loosen the restriction on shape if the return value is monomorphic
12:22:00 <kosmikus> they are substitution instances of the same type
12:22:07 <ski> (could then type-class style overloading, in Haskell, Clean, Mercury, be called "parametric overloading" ??)
12:22:34 <ski> earthy : hmm
12:22:56 <ski> how do you mean ?
12:23:22 <earthy> weirdfunc :: any -> monomorphic
12:23:31 <earthy> (in weirdclass)
12:23:35 <SamB> ski: you know how C++ is
12:23:36 <ski> with instances like what ?
12:23:50 <ski> SamB : more or less, i guess
12:23:56 <earthy> instance weirdclass int where  weirdfunc :: Int -> Int
12:24:10 <earthy> instance weirdclass bool where weirdfunc :: Bool -> a -> Bool
12:24:17 <ski> oh
12:24:25 <ski> isn't there some such in a paper
12:24:27 <ski> ?
12:24:30 <earthy> dunno
12:24:42 <ski> some overloading/type-class paper
12:24:55 <earthy> probably, as the idea isn't too stupid
12:25:09 <earthy> (many imperative languages supporting overloading allow this ;))
12:25:28 <ski> hmm
12:25:40 <ski> how would this interact with currying and polymorphism
12:25:45 <earthy> that is the problem. :)
12:25:56 <ski> the result would be monomorhic, you say ?
12:26:02 <earthy> would have to be, yes
12:26:02 <ski> the first arg too, then ??
12:26:16 <earthy> not necessarily the first, no
12:26:22 <ski> but some arg ?
12:26:23 <kosmikus> I thought ozone wants to overload on the type of the first argument, not on the result type?
12:26:27 <ski> or just the result ?
12:26:31 <earthy> (at least, if I understand ozone correctly)
12:26:42 <earthy> kosmikus: he wants to overload on the type of just 1 of the arguments
12:27:16 <earthy> (or the result)
12:27:17 <kosmikus> yes, but it's hard to do that if its not the first
12:27:18 <ski> kosmikus : (currentyl trying to understand earthy's understanding of ozone_ (+ maybe his own ideas) ;)
12:27:18 <earthy> sigh
12:27:36 <ski> mm
12:27:41 <earthy> I've been bending my mind around things I don't understand for a bit too long today
12:27:51 <ski> yeah ? :)
12:28:00 <ski> C++ ?
12:28:14 <earthy> nope, the integrated canonicalizer and solver developed at SRI
12:29:12 <earthy> anyway, back to what I think I understand from ozone's proposal
12:29:48 <earthy> is that *if* a function is monomorphic in either the first argument or the result, the number of arguments should not be fixed in a typeclass
12:30:38 <earthy> hm. that still doesn't make sense.
12:31:23 <kosmikus> where did he say this with the result type? that's new, he hasn't talked about that this afternoon
12:32:26 <earthy> he has implied it in all his exampels
12:32:30 <earthy> examples
12:32:49 <earthy> actually, he implied monomorphism in both the first argument and the result
12:33:08 <earthy> if I read correctly
12:33:43 <kosmikus> seems I have to read the mails again
12:35:08 * earthy is rereading as well
12:35:27 <kosmikus> can the monomorphic result type be a function? l)
12:35:31 <kosmikus> s/l/;
12:36:26 * earthy grinz
12:37:08 <earthy> are you going to go for a constant function with a polymorphic result type? :)
12:38:00 <earthy> this very much reminds me of the groping I did in chapter 6 of my master's
12:38:32 <kosmikus> no, what if I have instances for both result type Int, of type Int -> Int, and for result type Int -> Int, of type Int -> Int?
12:38:55 <earthy> uh?
12:41:33 * Marvin-- plays around with KeY
12:42:39 <earthy> kosmikus: you mean the second instance takes no arguments and `returns' a function of type Int -> Int?
12:45:15 <kosmikus> yes
12:45:34 <kosmikus> no, but I don't see ozones proposal as involving the result type
12:45:55 <earthy> upon rereading I'd have to say I agree with you
12:46:06 <earthy> it's just that his examples always imply that
12:46:18 <earthy> s/imply/have/
12:46:20 <kosmikus> the only way I think something like this would be feasible is to distinguish between type-tied and ordinary functions
12:46:45 <kosmikus> so it can be lexically and statically decided what sort an identifier refers to
12:47:32 <kosmikus> if it is a type-tied identifier, it is only *legal* if there is just one type associated with it, or if the first argument is given and monomorphic to disambiguate
12:48:35 <ski> or if the arguments given are enough to disambiguate ??
12:48:38 * earthy needs to take a shower and ponder Barendregt's lambda cube for a bit mroe
12:48:41 <earthy> more
12:49:24 <earthy> I seem to be coming up to this thought-barrier every few months
12:49:29 <kosmikus> ski: that might work, but I feel strange to have expressions like "foo x y" in my language without being able to type them unless there is a third argument ...
12:50:08 <ski> kosmikus : but why allow the same thing on first arg then ?
12:50:26 <ski> ot is it because it's *the*
12:50:29 <ski> object ?
12:50:48 <kosmikus> it's already strange with one argument, but if its application would be syntactically distinguished, so we write "x.foo" instead of "foo x", then it not seem that bad
12:51:16 <kosmikus> ski: I'm not in favor of such a change, anyway
12:51:44 <kosmikus> I would like to have a good record system
12:52:01 <earthy> looks to me like he wants to partially disallow partial application
12:52:05 <ski> what change are you not in favour of ?
12:52:26 <kosmikus> ski: ozone's proposal
12:52:38 <earthy> so that the typechecker gets more information to disambiguate
12:52:48 <kosmikus> ski: I was merely stating a way to make it work
12:52:52 <ski> earthy : we already have that with things like runST, and constructors with poly. args, no ?  or is that restr. lifted in ghc ?
12:53:20 <kosmikus> ski: that restriction is no more
12:53:25 <earthy> dunno, I'm still very much learning these details in GHC
12:53:38 <ski> kosmikus : a record system with possible x.foo syntax ?  (or x#foo or whatever)
12:53:49 <ski> kosmikus : ok
12:54:27 <ski> and lightweight or heavyweight records ?  both ?
12:54:43 <kosmikus> something like in the "First-Class Modules" paper
12:54:57 <ski> hmm, haven't read that
12:54:59 <earthy> oh joy
12:55:05 <kosmikus> earthy: ?
12:55:33 <earthy> I'm noticing I'm way too tired to think very clearly about these things
12:55:45 <kosmikus> why are you so tired?
12:55:48 <earthy> I can't even really understand what I've intended in my master's thesis anymore
12:56:27 <earthy> (why I'm tired? trying to grasp too many concepts and taking too few breaks during the day)
12:57:30 <kosmikus> I discovered today that I had no generalization rule in my type system
12:57:43 <earthy> err... oops? :)
12:57:49 <kosmikus> yes, oops
12:58:07 <kosmikus> I was trying to prove something about a complex type with dependency constraints, and couldn't do it
12:58:21 * earthy 'd guess that, yeah ;)
12:58:27 <kosmikus> so I simplified the problem until I had to prove (in essence) that \x -> x has type forall a . a -> a
12:58:37 <kosmikus> then I discovered I couldn't do even that ;)
12:58:42 <earthy> and you essentiall couldn't introduce the quantor. :)
12:58:44 <earthy> +y
12:59:13 <amgine> is there a command in perlude that can check if a string contains a substring i'm searching for ?
13:00:22 <earthy> maybe I should try to rework my knowledge of typed lambdacalculus in a more operational fashion
13:00:51 <earthy> having learned only the logical point of view is definitely not enough
13:05:05 <ski> earthy : (which part don't you understand operationally good enough, if i may ask ?)
13:07:56 <earthy> oh, the \C parts ;)
13:08:08 <ski> \C ?
13:08:09 <earthy> and the weak-omega part. :)
13:08:20 <ski> what's that ?
13:08:26 <ski> :)
13:08:50 <ski> is \C "type-lambda" ?
13:08:59 <earthy> do you know barendregt's lambda cube?
13:09:06 <ski> not well
13:09:28 <earthy> well, it has simply typed lambdacalculus in the lower left front corner
13:09:36 <ski> mhm
13:09:38 <earthy> and three axes
13:09:43 <ski> yes .. :)
13:10:00 <ski> it's a  cube ! :)
13:10:01 <earthy> one axis going up to \2
13:10:06 <earthy> one going to \P
13:10:06 <ski> ok
13:10:19 <earthy> (these are reasonably easy to grasp operationally)
13:10:29 <earthy> and one going to \weak-omega
13:10:35 <ski> so is \2 hindley-milner style forall-only at top ?
13:11:32 <earthy> roughly, yeah
13:11:41 <ski> and \P is what ?
13:11:48 <earthy> it is also called system F and polymorphic typed lambda calculus
13:11:55 <ski> \2 ?
13:12:18 <ski> is \2 or \P system F ?
13:12:23 <earthy> \2 is system F
13:12:47 <ski> isn't (forall a. a -> a) -> forall b. b -> b in system F ?
13:12:56 <ski> do i remember worngly ?
13:13:59 <kosmikus> ski: no, I think you're right
13:14:04 <earthy> nope, you remember right
13:14:14 <earthy> \P has types depending on terms
13:14:26 <ski> so then \2 isn't just hindley-minler, right ?
13:14:34 <earthy> \weak-omega has types depending on types
13:14:44 <earthy> no, it's not just hindley-milner
13:14:44 <ski> earthy : \P is dependent ?
13:14:56 <ski> earthy : ok, fine then
13:15:14 <earthy> and \C incorporates the features of \2, \P and \weak-omega
13:15:39 <earthy> and well, \2 I can operationally make sense of, \P... harder, but still, but \weak-omega...
13:16:00 <kosmikus> so, Fomega is between \weak-omega and \2 ?
13:16:27 <ski> has \P dependent functions and pairs (like e.g. cayenne) ?
13:16:32 <earthy> ski: yes.
13:16:55 <ski> what is "types depending on types" ?
13:17:03 <ski> lambdas in the types ?
13:17:29 <earthy> well, abstraction in the types, but such that the abstraction can only be `plugged' with another type
13:17:50 <ski> Maybe = \a -> Unit `Either` a
13:18:08 <ski> Maybe Foo = Unit `Either` Foo 
13:18:10 <earthy> kosmikus: `between', if you want to call it that. it is the combining of \2 and \weak-omega
13:18:10 <ski> ?
13:18:18 * earthy nods to ski
13:18:25 <ski> ok
13:18:26 <kosmikus> between, in the cube
13:19:05 <ski> kosmikus, it's one of the three corners next to the top (i.e. \C)
13:19:11 <earthy> ski: exactly
13:19:40 <ski> it's lub(\2,\weak-omega)
13:19:50 <ski> (i guess)
13:19:51 <kosmikus> so, weak-omega is the one where you get kinds
13:20:00 <ski> 'tis ?
13:20:07 <earthy> not sure
13:20:39 <ski> perhaps kinds are another generalization dimension ?
13:20:52 <ski> or perhaps we  have kinds already in \P ?
13:21:07 <ski> (or even in \2 ?)
13:21:17 <ski> hm
13:21:47 <kosmikus> in simply typed and in \2 you only have kind *
13:21:51 * earthy nods
13:22:01 <earthy> yeah, weak-omega allows you to build kinds
13:22:06 <ski> ok
13:22:09 <earthy> *thanks*!
13:22:18 <kosmikus> for what?
13:22:26 <earthy> I never understood that. :)
13:22:35 <ski> so is ghc larger than \2, then ?
13:22:38 * earthy nods
13:22:41 <kosmikus> yes
13:22:53 <kosmikus> ghc Core is essentially F-omega
13:23:06 <ski> (not counting other extensions, like e.g. type classes)
13:23:08 <ski> ok
13:23:21 <kosmikus> type classes are completely translated away
13:23:27 <kosmikus> before going to Core
13:23:27 <ski> right
13:24:10 <kosmikus> and all polymorphism is made explicit by the type inferencer
13:25:54 <ski> yes
13:26:18 <ski> perhaps a little like cayennes inferred arguments ..
13:26:30 <ski> (the |-> things)
13:27:04 <earthy> for a good ref, by the way: Handbook of Logic in Computer Science, volume II, chapter on `lambda calculi with types', section 5.1
13:27:32 <earthy> anyway, I'm off to a shower and a bed
13:27:35 <kosmikus> yes, Cayennes inferred arguments are similar
13:27:40 <ski> ok
13:27:41 <kosmikus> earthy: good night
13:27:43 <ski> bye earthy
13:27:43 <earthy> want to do some coding tomorrow. :)
13:27:59 <kosmikus> will you be back in your office tomorrow?
13:28:03 * earthy nods
13:28:09 <kosmikus> because I won't be ;)
13:28:24 <kosmikus> see you on Sunday, then
13:28:31 <earthy> have a good weekend in Muenster :)
13:28:46 <kosmikus> thx, I will
13:28:47 <earthy> 'till sunday
13:29:24 * kosmikus will be back soon
13:54:09 <creature> How would I find out what a function does? It's been a while since I've done Haskell. In this case, I'm curious about signum. 
13:54:24 <ski> read documentation ?
13:54:37 <ski> randomly try it out ?
13:54:44 <ski> zen the type ?
13:54:56 <ski> (or grok)
13:55:11 <creature> That's also to be taken as "What documentation is there"? :)
13:55:26 <np_hard> mmm documentation
13:55:35 <ski> well, there's the report
13:55:49 <creature> Oh yes, I have a vague recollection of that. 
13:55:49 <ski> and there's implementaion specific docs
13:56:00 <ski> and an addenda to the report, i think  (the FFI)
13:56:28 <ski> and the common libraries of hugs and ghc (nhc partially too ?)
13:56:42 <creature> I'm using hugs. 
13:56:51 <ski> report and addenda is on http://www.haskell.org
13:56:58 <ski> (on some subpage)
13:57:00 <creature> Cool, cheers. 
13:57:10 <creature> I can probably find my way there; I've done this before, back in the sands of time. 
13:57:12 <ski> hugs (and ghc) can also be found from there
13:57:14 <creature> . o O (Last year) 
13:57:21 <ski> (interpreters and compilers)
14:05:42 <amgine> they aren't
14:05:45 <amgine> it's all scripts
14:05:49 <amgine> you download a script
14:05:53 <amgine> you run the script
14:05:57 <amgine> it downloads source code
14:06:10 <amgine> and compiles / installs / setsup
14:06:12 <creature> Wrong window? 
14:06:42 <ski> creature : yes
14:06:50 <amgine> wrong window
14:08:47 <creature> OK, I've got an assignment where I have to do an instance declaration so we can do arithmetic operations on 3-tuples of numbers ("instance (Num t, Num u, Num v) => Num(t, u, v) where..."). One of the things that has to happen is to be able to do "4 :: (Int, Int, Int)" and have it return "(4, 4, 4)". Can I have a hint on how to do this, please? Not an answer, mind.
14:09:41 <kosmikus> creature: integer literals are overloaded in Haskell
14:10:27 <kosmikus> if you write "4", it is as if you had written "fromInteger 4" instead
14:10:48 <creature> OK, that helps.
14:11:08 <ski> fromInteger (4 :: Integer)
14:11:48 <kosmikus> ski: that's the same thing
14:12:04 <ski> i konw
14:12:05 <ski> know
14:12:59 <kosmikus> what's the proper way to do internationalization in Haskell?
15:50:10 <andersca> what are closures that are declared in curried form?
15:50:24 <ski> ?
15:50:33 <ski> huh ?
15:51:02 <SamB> andersca: that makes no sense
15:51:02 <ski> what do you mean ?
15:52:01 <andersca> ski: just reading a paper
15:52:13 <andersca> but I think I understood it anyway
15:52:43 <ski> maybe they mean something about partial application .. ?
15:52:54 <np_hard> now I am curious
15:53:24 <andersca> ski: yeah, I think so
15:53:25 <ski> (\x y -> x + y) 4  , sortof stores 4 in a closure with the function .., just a wild guess .. 
15:54:59 <SamB> the auther of PEP 309 thought curried functions were called closures
15:55:47 <Riastradh> What's PEP 309?
15:55:52 <ski> oh ;)
15:56:31 <SamB> Riastradh: PEP stands for Python Enhancement Proposal
15:56:39 <Riastradh> SamB, uh, I know.  What's 309?
15:57:07 <ski> the proposal number ?
15:57:10 <SamB> PEP: 309
15:57:10 <SamB> Title: Function Currying
15:57:10 <SamB> Version: $Revision: 1.4 $
15:57:10 <SamB> Last-Modified: $Date: 2004/02/21 16:32:30 $
15:57:10 <SamB> Author: Peter Harris <scav@blueyonder.co.uk>
15:57:11 <SamB> Status: Draft
15:57:13 <SamB> Type: Standards Track
15:57:15 <SamB> Content-Type: text/x-rst
15:57:17 <SamB> Created: 08-Feb-2003
15:57:20 <SamB> Python-Version: 2.4
15:57:21 <SamB> Post-History: 10-Feb-2003, 27-Feb-2003
16:29:00 <Heffalump> so does darks work in Cygwin, or not?
16:29:09 <Heffalump> oops, sorry, wrong channel.
16:31:10 <kosmikus> hi Heffalump 
16:31:13 <Pseudonym> So yes, she was asking for it.  Totally.
16:31:17 <Heffalump> hiya.
16:31:19 <Pseudonym> Oops!  Sorry, wrong channel.
16:31:22 <Heffalump> :-p
16:31:36 * Heffalump wonders if kosmikus is aware of #darcs
16:31:38 <kosmikus> seems to become more common ;)
16:37:58 * Riastradh doesn't understand this implicit parameter thing at all.
16:38:45 <ski> isn't it somewhat similar to a fluid-let or what's-it's-name ?
16:39:42 <Riastradh> I don't know!  Why are you asking me?
16:40:31 <kosmikus> Riastradh: what's the problem?
16:40:43 <ski> i thought you perhaps knew dynamically scoped variables/parameter/special-variables in Scheme, better than me ..
16:40:45 <kosmikus> (besides the monomorphism restriction)
16:41:05 <Riastradh> kosmikus, er, I haven't the faintest idea about implicit parameters.
16:41:51 <ski> so you do you ask ?
16:41:56 <ski> you wanna know ?
16:41:57 <kosmikus> have you read the paper?
16:42:23 <Riastradh> See, it would help to mention that there _is_ a paper first on them.
16:42:37 <kosmikus> yes, there is
16:42:57 <Riastradh> Now it would also help to give a link to that paper.
16:43:03 <kosmikus> http://www.cse.ogi.edu/~mbs/pub/implicit_parameters/
16:43:22 <ski> heh
16:46:01 <kosmikus> heh what?
16:55:10 <ham> bk
16:55:30 <ski> kosmikus : Riastradh's remarks
16:56:47 <kosmikus> ski: ?
16:57:00 <kosmikus> ah
16:57:04 <kosmikus> sorry, too tired
18:38:10 <SkyLemon> anyone here good at building GHC?
18:40:27 <ski> (sorry, i haven't built ghc at all)
19:02:04 <SkyLemon> man what a dead channel
19:17:38 <[3N1GM4]> lo all
19:17:59 <[3N1GM4]> when using a Bool, do I refer to true and false, or True and False?
19:18:16 <[3N1GM4]> True and False, right?
19:18:25 <ski> yes
19:18:50 <[3N1GM4]> ok, cheers
19:19:14 <ski> DeezNuts : prolly quite some people are asleep now ... ?
19:19:22 <[3N1GM4]> I get to write a mastermind program this week... how exciting...
19:19:27 <[3N1GM4]> I wish I was sleeping!
19:19:36 <ski> heh
19:20:02 <ski> you're in UK ?
19:20:59 <[3N1GM4]> yeh
19:21:10 <[3N1GM4]> I got a 9am lecture tomorrow, well... today!
19:21:16 <ski> heh :)
19:21:24 <[3N1GM4]> yeh, I know.
19:21:48 <ski> is it 03:20 or what over there, now ?
19:22:00 <[3N1GM4]> yeah, 3:20ish
19:22:05 <[3N1GM4]> you in the US?
19:22:08 <ski> no
19:22:10 <ski> Sweden
19:22:18 <ski> 04:20, here :)
19:22:21 <[3N1GM4]> ah, ok, so you 1 hour ahead.
19:22:23 <[3N1GM4]> oh, ok
19:22:25 <[3N1GM4]> lol
19:22:31 <[3N1GM4]> Why you up so late/early?
19:22:40 <ski> working some
19:22:48 <ski> and reading a blog, currently
19:23:05 <[3N1GM4]> fair. What do you do?
19:23:13 <ski> study :)
19:23:18 <[3N1GM4]> ah, student too.
19:23:26 <ski> rightee
19:23:34 <[3N1GM4]> What is your course? Computer Science?
19:23:52 <ski> in comp. sci. yes
19:24:04 <ski> compiler construction ATM
19:24:18 <ski> (and foundations of computing)
19:24:36 <ski> and you ? :)
19:24:39 <[3N1GM4]> wow, pretty deep stuff. Compilers are pretty complex from what I know..
19:24:54 <[3N1GM4]> I'm doing a Masters in Computer Science at Bristol University.
19:25:10 <ski> any specific courses ATM ? ;)
19:25:34 <Riastradh> Compilers aren't that hard to write or complicated.  It's efficient multi-platform back ends for functional languages that are hard.
19:25:52 <[3N1GM4]> Intro to Software Engineering, Intro to Computer Architecture, Intro to Accounting and Hi-Tec Enterprise...
19:26:01 <[3N1GM4]> at the mo, but we get more options next year...
19:26:11 <ski> o'kay
19:26:31 <[3N1GM4]> That's good to hear about compilers, cos we gotta write one sometime this year I think...
19:26:42 * ski smiles
19:27:43 <Riastradh> Compiler front ends are pretty easy until you get to CFA, which is _really_ hard for functional languages.
19:28:23 <Riastradh> (And parsing is a non-issue, damnit!)
19:28:32 <monotonom> CFA = ?
19:28:37 <Riastradh> Control Flow Analysis.
19:28:47 <ski> Riastradh : yeah, with sexprs, right ;)
19:30:45 <Riastradh> CFA is what allows you to perform such optimizations as common subexpression elimination, loop-invariant hoisting, et cetera.
19:30:49 <Riastradh> ski, yes.
19:31:03 <ski> mm :)
19:36:30 <[3N1GM4]> Do you know anything about \\? It's something to do with removing the first occurrence of each item in one list from another list?
19:36:46 <Cale> It's list subtraction.
19:37:11 <[3N1GM4]> right, do you have an example of how it is used? like: list1 \\ list2?
19:37:33 <Riastradh> Bah, obscure symbols with no useful names whatsoever!
19:37:42 <[3N1GM4]> lol
19:37:45 <ski> heh
19:38:12 <[3N1GM4]> I cant find anything on the net about it...which seems strange... I'll try putting list subtraction in the search...
19:38:25 <Cale> [3N1GM4]: tried the haskell report?
19:38:27 <Riastradh> LSET-DIFFERENCE would be much better.
19:38:37 <Cale> LSET?
19:38:43 <Riastradh> List-set.
19:38:57 <ski> @eval diff [1,2,3,4,5,6,7] [4,5,6,2]
19:38:58 <lambdabot> [1, 3, 7]
19:40:02 <[3N1GM4]> is that what \\ does?
19:40:11 <[3N1GM4]> I understand what it is doing and it is what I need...
19:40:13 <ski> yes (i think so)
19:40:17 <[3N1GM4]> ok...
19:40:28 <ozone_> re
19:40:33 <[3N1GM4]> where exactly in the haskell report should I look for it? Standard Prelude?
19:40:55 <ozone_> it's in the List module
19:41:00 <ski> @eval [1,2,2,3,3,3,1,1,1,2,2,3] [3,1,2,1,3,2]
19:41:01 <lambdabot> type error
19:41:06 <ozone_> import List at the top of your file, then use \\ at your leisure
19:41:10 <ski> @eval diff [1,2,2,3,3,3,1,1,1,2,2,3] [3,1,2,1,3,2]
19:41:11 <lambdabot> [3, 1, 1, 2, 2, 3]
19:43:24 <[3N1GM4]> ok use \\ at my leisure, but how do I use it? I cant find any references to syntax...
19:43:34 <[3N1GM4]> list1 \\ list2?
19:43:47 <ski> right
19:43:55 <ski> like all infix operators
19:43:57 <ozone_> ok, anyone here know what on earth 'intranamespacial parameter type lookup' means?
19:44:13 <ski> errm ..
19:44:39 <ski> hm
19:44:49 <[3N1GM4]> so [1,2,3,4,5,6] \\ [1,4,2,6] = [3,5]   ?
19:45:30 <ski> perhaps they lookup parameter types of some method/function/whatever based on internal name parts of a big name  (FooBarBaz perhaps) ???
19:45:45 <ski> [3N1GM4] : hmm, i think so
19:45:57 <[3N1GM4]> ok, thanks.
19:46:14 <ozone_> ski: i think i'll just reply back to the author and write "hi, WTF?"
19:46:33 <ski> it was in some paper ?
19:46:52 <ozone_> no, in a reply that david bergman sent me
19:47:00 <ski> oh
19:50:01 <[3N1GM4]> Could not deduce (Eq int) from the context ()
19:50:02 <[3N1GM4]>   arising from use of `\\' at Sub.hs:6
19:50:02 <[3N1GM4]> Probable fix:
19:50:02 <[3N1GM4]>     Add (Eq int) to the type signature(s) for `main'
19:50:02 <[3N1GM4]> In the definition of `main': main a b = a \\ b
19:50:22 <[3N1GM4]> I just made a func that took two int lists and returned one int list...
19:50:24 <ski> use Int, not int
19:50:31 <[3N1GM4]> oh, ok
19:50:33 <ski> (or are you doing that ?)
19:50:39 <Cale> main is of type IO a
19:51:36 <[3N1GM4]> yeh, I'll change func name.
19:51:50 <[3N1GM4]> ski:No, I was using int, thanks.
19:51:55 <ski> Cale : ok, so it hasn't got to be IO (), then ?   (i can't remember which)
19:52:09 <Cale> I think it used to have to be IO ()
19:52:28 <Cale> now I think they relaxed that to IO a, but it just ignores the a
19:53:48 <[3N1GM4]> yes, \\ works, I checked it now.
19:53:54 <[3N1GM4]> just so you know.
19:53:58 <[3N1GM4]> =)
19:55:14 <[3N1GM4]> now I need to convert a 4 character string into a list of 4 integers...any clues?
19:55:39 <[3N1GM4]> like: "1234" -> [1,2,3,4]
19:55:42 <ski> foo "1234"  ---> [1,2,3,4]  ??
19:55:47 <[3N1GM4]> yep
19:55:58 <[3N1GM4]> foo?
19:56:21 <Riastradh> @type chr
19:56:22 <ski> whatever you decide to call the conversion function
19:56:25 <Riastradh> @type ord
19:56:27 <Riastradh> Bah.
19:56:37 <ski> Riastradh : in module Char, i think
19:56:59 <ski> Char.ord :: Char -> Int
19:57:05 <ski> Char.chr :: Int -> Char
19:57:15 <Riastradh> (Hint: ord '0')
19:57:18 <Riastradh> (and -)
19:57:44 <[3N1GM4]> so.... ord "3" == 3?
19:57:51 <Riastradh> No.
19:57:53 <[3N1GM4]> and chr 3 == "3"?
19:57:54 <[3N1GM4]> oh
19:57:54 <ski> (hint : Char.digitToInt :: Char -> Int , Char.intToDigit :: Int -> Char)
19:57:54 <Riastradh> @type "3"
19:57:55 <lambdabot> "3" :: String
19:58:02 <Riastradh> @type '3'
19:58:03 <lambdabot> '3' :: Char
19:58:18 <Riastradh> @type Char.ord '0'
19:58:21 <Riastradh> Bah.
19:58:24 <[3N1GM4]> oh, ok.
19:58:26 <Riastradh> ski, eh, digitToInt is cheating.
19:58:41 <[3N1GM4]> how is it cheating?
19:58:41 <ski> hehe heh :)
19:59:07 <ski> you don't have to understand how it works/what it does to be able to use it !
19:59:18 <Riastradh> It just is.
19:59:46 <[3N1GM4]> ok... so for example:   digitToInt '3' == 3?
19:59:52 <Riastradh> Yes, but that's cheating.
20:00:14 <Riastradh> [[chr 13]], for instance, is the carriage return character.  [[ord ' ']] is 32.
20:00:14 <[3N1GM4]> right, so also:   ord '3' == 3?
20:00:17 <Riastradh> No.
20:00:48 <ski> ord '3' == 51  in ASCII
20:00:50 <[3N1GM4]> oh, I see.
20:00:57 <ski> (dunno about EBCDIC)
20:01:28 <[3N1GM4]> how does that help me? I would then have to subtract 48 to get what I want?
20:01:30 <ski> Prelude Char> map ord "0123456789"
20:01:30 <ski> [48,49,50,51,52,53,54,55,56,57]
20:01:50 <[3N1GM4]> ooh, snazzy
20:01:57 <ski> they are contigous (that's all you need)
20:02:12 <ski> (and in strictly increasing order)
20:02:16 <[3N1GM4]> sorry, contigous?
20:02:18 <Riastradh> That they are contiguous and [[ord '0']] is all you need.
20:02:47 <[3N1GM4]> contiguous?
20:03:03 <ski> Riastradh : thanks (re 'uou' in contiguous, thought about that, but someone said no word in english has uou, ..)
20:03:06 <Riastradh> You notice that they are increasing integers with steps of 1, right?
20:03:16 <[3N1GM4]> yep
20:03:20 <Riastradh> ski, that weirdo was wrong.
20:03:30 <Riastradh> [3N1GM4], that's what ski means by contiguous.
20:03:35 <[3N1GM4]> ok
20:03:52 <ski> (yep, i *thought* i had seen such words, but i couldn't remember one, at the time)
20:11:00 <[3N1GM4]> You can treat a String as a list of characters, right?
20:11:13 <ski> type String = [Char]
20:11:17 <[3N1GM4]> cool.
20:11:19 <[3N1GM4]> jus checkin.
20:11:24 <ski> it *is* a list of characters !
20:12:11 <[3N1GM4]> of course.
20:21:11 <det> several words have "uou", non have "ouo"
20:21:26 <det> according to /usr/share/dict/words 
20:22:26 <ski> ok
20:23:41 <det> I feel my presence is /wq r
20:23:43 <det> oops
20:23:55 <det> I feel my presence is superfluous
20:23:59 <det> I shall depart now!
20:24:07 <ski> begone !
20:24:16 <Cale> I feel my presence is /wq r too.
20:24:27 <Cale> I'll be sticking around though.
20:24:44 <ski> and *what* is "/wq r" ?  some irc command ??
20:24:59 <det> what a mellifluous
20:25:01 <det> statement!
20:25:31 <Cale>  Also includes the Law Finance and To Larson totally DECEIVING, If a well respected Washington, DC attorney, Doctor of the United States and the Actual atomic fusion a person's secret Of value for Chemistry and DISSEMINATION of information and solar systems, result from straight above Natural health Research, organization now so much of translational, Vibrational, rotational, opinion, if an INDIVIDUAL Privacy and countries such pronouncements without a comet.
20:25:33 <det> ski: the beginning of a IRC client command, open a new query with some guy named "r"
20:25:54 <ski> @dict mellifluous
20:25:55 <lambdabot> Supported dictionary-lookup commands:
20:25:55 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @prelude @vera @web1913 @wn @world02
20:25:55 <lambdabot> Use "@dict-help [cmd...]" for more.
20:26:12 <det> ski: I have no idea what that means .. ;)
20:26:38 <ski> @all-dicts mellifluous
20:26:40 <lambdabot> *** "Mellifluous" web1913 "Webster's Revised Unabridged Dictionary (1913)"
20:26:40 <lambdabot> Mellifluous \Mel*lif"lu*ous\, a. [L. mellifluus; mel, mellis,
20:26:40 <lambdabot>    honey (akin to Gr. ?, Goth. milip) + fluere to flow. See
20:26:40 <lambdabot>    {Mildew}, {Fluent}, and cf. {Marmalade}.]
20:26:40 <lambdabot>    Flowing as with honey; smooth; flowing sweetly or smoothly;
20:26:42 <lambdabot>    as, a mellifluous voice. -- {Mel*lif"lu*ous*ly}, adv.
20:26:46 <lambdabot> *** "mellifluous" wn "WordNet (r) 2.0"
20:26:48 <lambdabot> [3 @more lines]
20:27:22 <det> "pleasing to the ear"
20:27:25 <ski> @more
20:27:25 <det> apparently
20:27:25 <lambdabot> mellifluous
20:27:25 <lambdabot>      adj : pleasing to the ear; "the dulcet tones of the cello" [syn: {dulcet},
20:27:25 <lambdabot>             {honeyed}, {mellisonant}, {sweet}]
20:27:35 <ski> :)
20:27:40 <[3N1GM4]> heh
20:30:09 <Cale> euphonious
20:31:42 <Cale> or perhaps calliphonious, except that doesn't appear to be a word :)
20:31:59 <ski> euphonious = embellished/beatified paraphrase , right ?
20:32:20 <Cale> Full of or characterized by euphony; pleasing to the ear.
20:33:16 <ski> in swedish "eufemi" is "förskönande omskrivning" which is "embellished/beatified paraphrase" in english, i think
20:34:00 <Cale> euphemism ('ju:fImIz(&schwa.)m). [ad. Gr.
20:34:00 <Cale> epsilon-upsilon-phi-eta-mu-iota-sigma-mu-omicron-sigma-, f.
20:34:00 <Cale> epsilon-upsilon-phi-eta-mu-iota-zeta-epsilon-iota-nu- to speak fair, f.
20:34:00 <Cale> epsilon-upsilon-phi-eta-mu-omicron-sigma-: see prec.]
20:34:00 <Cale>   1 Rhet.  That figure of speech which consists in the substitution of a word
20:34:01 <Cale> or expression of comparatively favourable implication or less unpleasant
20:34:03 <Cale> associations, instead of the harsher or more offensive one that would more
20:34:05 <Cale> precisely designate what is intended.
20:34:11 <Taaus> You mean "euphemism", ski? :)
20:34:22 <ski> oh, right
20:34:26 <ski> *dang* !
20:34:38 <Cale> I love the OED.
20:35:12 <Cale> 1656-81 BLOUNT Glossogr., Euphemism, a good or favourable interpretation of a bad word.
20:35:15 <Taaus> It's all Greek to me...
20:35:25 <Cale> seems to be the earliest use on-hand
20:35:40 <ski> OED is O?? E?? Dictionay
20:35:47 <ski> Dictionary, even
20:35:52 <Taaus> Oxford English.
20:35:52 <Cale> Oxford English Dictionary
20:35:59 <Pseudonym> All English to me.
20:36:01 <ski> mhmm, 'k
20:59:30 <[3N1GM4]> should I be able to do this:
20:59:50 <[3N1GM4]> "This is a test, this is a number: " ++ 4             ???
21:00:01 <[3N1GM4]> to get: "This is a test, this is a number: 4"
21:00:10 <ski> "This is a test, this is a number: " ++ show 4
21:00:18 <[3N1GM4]> ah, that's the one!
21:00:27 <ski> @type show
21:00:28 <lambdabot> show :: Show a => a -> String
21:09:11 <[3N1GM4]> Hmmm, I've got two lists of Int's, of equal length and I need to compare them to find out how many of their elements from identical positions in the list are the same as each other... I'm a little stuck...
21:09:49 <ski> you can pattern-match on both lists at the same time
21:10:08 <ski> (or do you want to use library functions ? :)
21:10:30 <[3N1GM4]> right, I reckon I can do that, but how do I keep a count on how many are the same?
21:10:40 <ski> oh, simple
21:10:59 <[3N1GM4]> yes?
21:11:00 <ski> foo :: Eq a => [a] -> [a] -> Int  would be the type, yea ?
21:11:12 <[3N1GM4]> yea
21:11:33 <ski> so how do you propose implementing foo ?  got any idea ?
21:11:42 <[3N1GM4]> (btw, I dont' put that Eq a => bit on, does that matter?)
21:11:52 <[3N1GM4]> well, something like:
21:12:04 <ski> (hint : recursion + patter-matching + some code to fill out the holes)
21:12:47 <ski> (the Eq bit says that we can compare a's for equality. just forsight of me to think we're probably gonna need that :)
21:12:56 <ski> ok, go on
21:13:44 <ski> (if you make the function monomorphic in Int (so a = Int) instead of polymorphic, then you don't need the Eq bit)
21:13:46 <[3N1GM4]> foo (a:as) (b:bs) = (a == b) + foo as bs...        but I don't know how to turn a == b into 1 when they're equal and zero when they're not...another function?
21:14:12 <ski> try :  if a == b then 1 else 0
21:14:21 <[3N1GM4]> ok...
21:14:22 <ski> you can also use guards for this one
21:14:26 <[3N1GM4]> right.
21:14:41 <ski> (perhaps that a little bit nicer)
21:15:26 <[3N1GM4]> foo (a:as) (b:bs)
21:16:09 <[3N1GM4]>     | a == b = 1 + foo as bs
21:16:32 <[3N1GM4]>     | else foo as bs
21:16:44 <ski> s/else/otherwise/
21:16:44 <[3N1GM4]> close?
21:16:48 <[3N1GM4]> oh, ok...
21:17:06 <ski> and add a '=' after 'otherwise', too
21:17:22 <[3N1GM4]> can I just change else to otherwise, yeh? and put in the =
21:17:31 <ski> yeah
21:17:42 <ski> guards don't understand else
21:17:42 <[3N1GM4]> sweet
21:17:47 <[3N1GM4]> oh yeah, whoops.
21:17:54 <ski> @type otherwise
21:17:55 <lambdabot> otherwise :: Bool
21:18:01 <ski> otherwise = True
21:18:28 <ski> (so, if you really want, you can change otherwise to True. it's the same thing)
21:18:48 <[3N1GM4]> k, fair play
21:19:28 <ski> otherwise (pardon, the pun), your code looks good ! :)
21:20:02 <[3N1GM4]> lol, cheers. Just gonna compile now...
21:21:25 <[3N1GM4]> ok, I can't do:  gold[][] = [][]? Does it want:  gold[] = [], even though there are meant to be two lists?
21:21:39 <ski> huh ?
21:21:46 <np_hard> it's not C
21:21:47 <ski> what's gold supposed to fo ?
21:22:07 <Cale> [][] ?
21:22:08 <[3N1GM4]> just tells me how many of the lists items are the same in the same positions...
21:22:18 <ski> (to *do*)
21:22:27 <Cale> and why is gold [] [] = [][]?
21:22:37 <Cale> Shouldn't it be 0, or something sane?
21:22:46 <ski> so gold :: Eq a => [a] -> [a] -> Int  right ?
21:22:47 <[3N1GM4]> It expects two lists? and if they're noth empty, it returns two empty lists...
21:22:51 <[3N1GM4]> oh, yeh Int output...
21:22:53 <[3N1GM4]> whoops.
21:23:03 <[3N1GM4]> so gold[][] = 0 would be better.
21:23:11 <[3N1GM4]> sorry. =s
21:23:11 <ski> yeah
21:23:20 <ski> more customary to write that as
21:23:24 <ski> gold [] [] = 0
21:23:29 <ski> or even
21:23:30 <[3N1GM4]> okey doke
21:23:35 <ski> gold [    ] [    ] = 0
21:23:40 <[3N1GM4]> yeh?
21:23:43 <ski> gold (a:as) (b:bs)
21:23:49 <ski>   | a == b = ...
21:23:53 <ski>   | ...
21:24:02 <[3N1GM4]> fair enough, that's what I've got...
21:24:09 <[3N1GM4]> ...now
21:24:13 <ski> :)
21:26:31 <Cale> You're not allowed to return more than one value from a function. Of course, you can return lists, tuples, etc.
21:27:49 <[3N1GM4]> err, thanks. I realise that. Did you think I was returning more than one value?
21:30:04 <Cale> well, what is gold [] [] = [] [] supposed to mean?
21:30:38 <[3N1GM4]> oh, yeah. sorry, I realise my mistake now. Thanks.
21:39:14 <Cale> no problem
21:43:43 <[3N1GM4]> Hooray, I have my mastermind program... Now I just have to code it again in java...
21:43:57 <ski> :(
21:44:00 <[3N1GM4]> yeh
21:44:03 <ski> hmm
21:44:06 <[3N1GM4]> but I can do that on monday!
21:44:16 <ski> with GUI, or just some CLI ?
21:44:31 <[3N1GM4]> eh? CLI = command line interface?
21:44:37 <ski> yeah
21:44:39 <[3N1GM4]> Yeah, no GUI for us yet!
21:44:45 <[3N1GM4]> That's later.
21:44:47 <[3N1GM4]> =)
21:44:48 <ski> okidoki
21:45:22 <[3N1GM4]> now I just need to test it to destruction...
21:45:40 <ski> heh
22:01:39 <[3N1GM4]> ok, well I'm going to go have a shower and get ready for my lecture. Thanks again for all you help and I'm sure I'll be seeing you again soon.
22:01:49 <ski> heh
22:01:53 <ski> ok, bye
22:01:56 <[3N1GM4]> laters.
22:30:45 <DeezNuts> hello
22:30:52 <ski> hi
22:30:55 <DeezNuts> I'm trying to write a function that converts a list of strings to a list of numbers
22:31:00 <DeezNuts> i get this error when I try to use it
22:31:01 <DeezNuts> *** Type           : IO [[Char]]
22:31:01 <DeezNuts> *** Does not match : [[Char]]
22:31:10 <ski> you too ?
22:31:21 <DeezNuts> heh
22:31:24 <DeezNuts> ya
22:31:25 <DeezNuts> me too
22:31:32 <DeezNuts> so u can't help?
22:31:48 <Cale> yeah
22:32:01 <ski> (well, not quite the same. [3N1GM4] had convertDigits :: [Char] -> [Int])
22:32:02 <Cale> can I see your program?
22:32:03 * DeezNuts cheers
22:32:08 <DeezNuts> sure
22:32:32 <DeezNuts> module Main
22:32:32 <DeezNuts>   where
22:32:32 <DeezNuts> import IO
22:32:33 <DeezNuts> main =
22:32:35 <DeezNuts>   let a = userPrompt in
22:32:35 <ski> you are trying to use IO something as a something !
22:32:37 <DeezNuts>     my_sum (stringToNum a)
22:32:39 <DeezNuts>     my_product (stringToNum a)
22:32:41 <DeezNuts>     listFactorials (stringToNum a)
22:32:45 <DeezNuts> stringToNum (x:a) = read x : stringToNum a
22:32:49 <DeezNuts> listFactorials (x:a) = do
22:32:51 <DeezNuts>   putStrLn ("Factorial of " ++ show x ++ " is " ++ show (factorial x))
22:32:53 <DeezNuts>   listFactorials a
22:32:57 <DeezNuts> userPrompt = do
22:32:59 <DeezNuts>   putStrLn "Please enter a number (0 to quit):"
22:33:01 <DeezNuts>   userInput <- getLine
22:33:13 <DeezNuts>   if n == 0
22:33:15 <DeezNuts>     then do return []
22:33:15 <ski> DeezNuts> :t userPrompt
22:33:17 <DeezNuts>     else do
22:33:19 <DeezNuts>       list <- userPrompt
22:33:21 <DeezNuts>       return (userInput:list)
22:33:25 <DeezNuts> my_sum []    = 0
22:33:27 <DeezNuts> my_sum (x:a) = x + my_sum a
22:33:31 <DeezNuts> my_product []    = 0
22:33:33 <DeezNuts> my_product (x:a) = x * product a
22:33:36 <Cale> there
22:33:37 <DeezNuts> factorial 1 = 1
22:33:39 <DeezNuts> factorial n = n * factorial (n - 1).
22:33:41 <DeezNuts> hmm brb
22:33:43 <DeezNuts> k
22:33:45 <DeezNuts> what about it
22:33:46 <ski> heh
22:34:06 <ski> quite a big hunk 'o meat
22:34:13 <DeezNuts> wut
22:34:18 <DeezNuts> the big paste?
22:34:27 <ski> don't use let a = userPrompt
22:34:29 <Cale> hehe
22:34:31 <ski> use
22:34:38 <ski> main = do
22:34:43 <ski>   a <- userPrompt
22:34:43 <Cale> let a = userPrompt in ... stringToNum a
22:34:52 <Cale> right
22:35:03 <DeezNuts> which one
22:35:11 <ski> in top of main
22:35:15 <Cale> the let ... is what you have wrong
22:35:30 <ski> userPrompt :: IO Whatever
22:35:54 <Cale> remember that values of type IO a are IO actions, and not values of type a.
22:36:19 <Cale> i.e. they're things that can run to yield a value of type a.
22:36:50 <ski> you have to "run the action" by writing it in a do-block/sequence, optionally capturing it's return value with a "a <-" (like you want in this particular case)
22:37:17 <DeezNuts> ERROR "Main.hs":12 - Last generator in do {...} must be an expression
22:37:24 <ski> use return !
22:37:29 <ski> :)
22:37:45 <DeezNuts> ok
22:37:59 <DeezNuts> what do you act as if its obvious in this language:p
22:38:01 <ski> what do you want to return
22:38:02 <ski> ?
22:38:06 <Cale> return (), if you don't mean to return anything
22:38:15 <ski> yeah, right
22:38:22 <ski> hmm
22:39:00 <Cale> which should happen automatically, if the last line in the do is an IO expression.
22:39:19 <ski> perhaps you want to wrap the three calls to my_sum,my_product,listFactorials  in print calls (to actually *print* the values of those calls :)
22:39:40 <ski> (those calls are in main
22:39:43 <Cale> ah
22:39:48 <DeezNuts> main = do
22:39:48 <DeezNuts>     a <- userPrompt
22:39:48 <DeezNuts>       my_sum (stringToNum a)
22:39:48 <DeezNuts>       my_product (stringToNum a)
22:39:48 <DeezNuts>       listFactorials (stringToNum a)
22:39:49 <DeezNuts>       return ()
22:39:52 <DeezNuts> this is not working
22:40:01 <ski> yeah, use print, probably
22:40:05 <DeezNuts> and when they are all on the same column it doesn't work either
22:40:15 <DeezNuts> but im already printing stuff in the other functions
22:40:29 <ski> (if my DWIM inferencer is working correctly, ATM, i.e.)
22:40:39 <ski> oh
22:41:09 <ski> also indent *all* actions in the same do-block/sequence to the same level !
22:41:38 <ski> (your "a <- ..." is indented 2 spaces less than the next 4 lines)
22:42:03 <ski> (*or* you could use ';'s instead, if you really like to)
22:43:47 <DeezNuts> *** Outstanding context : (Num (IO c), Read (IO c), Num (IO b), Read (IO b))
22:43:57 <ski> oh
22:44:12 <DeezNuts> do I still have to print?
22:44:21 <ski> using IO-actions as numbers, and trying to read in IO-actions, eh ?
22:44:29 <DeezNuts> huh
22:44:37 <ski> wait, i'll look
22:45:45 <DeezNuts> ok, ill smoke pot
22:45:46 <ski> hmm
22:46:00 <ski> actually listFactorials, shouldn't be wrapped in print
22:46:01 <ski> my err
22:46:10 <ski> (mea culpa, i.e.)
22:46:33 <DeezNuts> ohh yah
22:46:35 <DeezNuts> makes sense
22:46:36 <DeezNuts> lol
22:46:41 <ski> it actually calls putStrLn, and thus returns IO something, so it's already an IO-action
22:46:42 <DeezNuts> forgot i didn't print out for those other ones
22:47:08 <Cale> wait, what does stringToNum do?
22:47:33 <Cale> seems to build a list of the digits in a string?
22:47:34 <ski> is n a global constant ??
22:47:43 <DeezNuts> ok we're getting close here
22:47:47 <ski> Cale : yeah, seems so
22:47:52 <DeezNuts> main = do
22:47:52 <DeezNuts>   a <- userPrompt
22:47:52 <DeezNuts>   putStrLn (my_sum (stringToNum a))
22:47:52 <DeezNuts>   putStrLn (my_product (stringToNum a))
22:47:52 <DeezNuts>   listFactorials (stringToNum a)
22:47:54 <DeezNuts>   return ()
22:48:05 <DeezNuts> *** Outstanding context : Num [Char]
22:48:09 <ski> no !
22:48:19 <ski> @type putStrLn
22:48:19 <lambdabot> putStrLn :: String -> IO ()
22:48:23 <ski> @type print
22:48:24 <lambdabot> print :: Show a => a -> IO ()
22:48:29 <ski> use print !
22:48:33 <DeezNuts> just print?
22:48:36 <DeezNuts> dude
22:48:40 <ski> putStrLn can only print strings
22:48:42 <DeezNuts> the book didnt go over explicit data types yet
22:48:46 <DeezNuts> s/book/tutorial/
22:48:57 <ski> my_sum and my_product doesn't give string
22:48:59 <ski> well
22:49:06 <ski> you could do like :
22:49:16 <ski> putStrLn (show (my_sum (stringToNum a)))
22:49:25 <ski> that will also work :)
22:49:34 <DeezNuts> and 'print' will too?
22:49:38 <ski> yes
22:49:38 <DeezNuts> in place of putStrLn?
22:49:41 <DeezNuts> hmm
22:49:50 <DeezNuts> why didn't they show me that first yo?
22:50:02 <Cale> well, it puts quotes around strings
22:50:03 <ski> i think print is defined like that in the hugs Prelude, at least, as a matter of fact (IIRC :)
22:50:32 <Cale> so if you only have print, then you can't print strings without getting silly quotes around everything
22:50:38 <ski> Prelude> putStrLn "abc\tdef\nghi"
22:50:39 <ski> abc     def
22:50:39 <ski> ghi
22:50:39 <ski> Prelude> print "abc\tdef\nghi"
22:50:39 <ski> "abc\tdef\nghi"
22:51:17 <DeezNuts> oh
22:51:25 <DeezNuts> well
22:51:26 <DeezNuts> Program error: pattern match failure: stringToNum instRead_v43 []
22:51:38 <ski> Prelude> putStrLn "abc\tdef\nghi"
22:51:39 <ski> abc     def
22:51:39 <ski> ghi
22:51:39 <ski> Prelude> print "abc\tdef\nghi"
22:51:39 <DeezNuts> wtf kind of error msg is that?
22:51:54 <ski> (sorry about crappy mouse scroller)
22:51:59 <ski> well
22:52:20 <ski> you forgot to add a basae case, just perhaps ?                ;)
22:52:28 <ski> (base)
22:52:37 <DeezNuts> not forgot
22:52:38 <DeezNuts> but
22:52:43 <DeezNuts> i couldn't figure out the base case for that one
22:52:47 <ski> oh
22:53:01 <Cale> that's a crappy hugsism
22:53:01 <DeezNuts> i wasn't sure there had to be one
22:53:06 <ski> well, the kind of error you got is *not* a *static* error
22:53:15 <ski> (like syntax and type errors)
22:53:20 <DeezNuts> i know
22:53:21 <DeezNuts> its runtime
22:53:23 <ski> it's a run-time error !
22:53:25 <ski> yes
22:53:34 <DeezNuts> im not that lowly
22:53:35 <DeezNuts> i program
22:53:38 <DeezNuts> just not in haskell
22:53:44 <DeezNuts> or any other purely functional language
22:53:53 <ski> it just says that it got stuck trying to apply stringToNum on an []
22:54:01 <DeezNuts> no
22:54:04 <DeezNuts> it said it got stuck
22:54:11 <DeezNuts> trying to apply stringToNum to an instRead_v43 []
22:54:44 <ski> DeezNutz : ok, sorry about that. wasn't sure if you were (mostly) a beginner at programming at all, or just at haskell :-(
22:55:00 <DeezNuts> heh its kew
22:55:14 <ski> trying to apply stringToNum to an instRead_v43 and an [] !
22:55:15 <Cale> yeah, hugs' runtime error messages really suck
22:55:15 <DeezNuts> i prolly would get this quicker too right now if i wasn't baked
22:55:42 <ski> (just ignore the instRead_v43, i has to do with overloading and type-classes)
22:55:54 <ski> baked = tired ?
22:56:25 <DeezNuts> baked = high on weed
22:56:31 <ski> heh
22:56:55 <DeezNuts> hmm
22:56:57 <DeezNuts> ok
22:57:04 <DeezNuts> so whats the base-case...
22:57:26 <DeezNuts> stringToNum (x:a) = read x : stringToNum a
22:57:45 <ski> well, you tell me what stringToNum is supposed to do, first :)
22:57:51 <DeezNuts> read x
22:58:04 <DeezNuts> i dunno
22:58:06 <DeezNuts> theres no order
22:58:07 <DeezNuts> apparently
22:58:24 <ski> should it just convert every digit to a number (between 0 and 9) ?
22:58:41 <DeezNuts> it should return the list
22:58:50 <ski> or should it convert, say "123" to [123] ?
22:58:58 <ski> or [1,2,3] ?
22:59:04 <DeezNuts> the former
22:59:08 <ski> oh
22:59:19 <DeezNuts> "123" to [123]
22:59:22 <ski> it's doing the latter ('xcept the base case)
22:59:23 <Cale> you want read then
22:59:51 <DeezNuts> Cale: so stringToNum(a:a) = read x?
22:59:55 <DeezNuts> oops
23:00:01 <DeezNuts> Cale: so stringToNum [] = read x?
23:00:07 <Cale> read converts strings to the proper types
23:00:19 <ski> DeezNuts : do you  want to handle errors in input (in x) ?  (e.g. by returning an empty list)
23:00:32 <Cale> stringToNum x = [read x]
23:00:38 <Cale> the way you described it
23:00:50 <ski> or just return the number, if there is one, otherwise fail (runtime error) ?
23:01:05 * Cale is away: one minute - doing dishes
23:01:31 <DeezNuts> heh kew
23:01:33 <ski> and also
23:02:09 <ski> should you do the conversion "by hand", or are you allowed to use library function ?  (any restrictions on which, then ?)
23:05:01 <DeezNuts> actually it was
23:05:09 <DeezNuts> stringToNum [x] = [read x]
23:05:11 <DeezNuts> as the base case
23:05:23 <ski> huh ?
23:05:37 <DeezNuts> this worked:
23:05:38 <DeezNuts> stringToNum [x]   = [read x]
23:05:38 <DeezNuts> stringToNum (x:a) = read x : stringToNum a
23:05:56 <ski> no
23:06:05 <ski> try on "123"
23:06:13 <ski> i think that given you [1,2,3]
23:06:18 <ski> doesn't it ?
23:06:28 <ski> hmm, well, waitasec
23:07:09 <ski> aha !
23:07:37 <ski> stringToNum gets a *list of* strings as input, not just one string (which is a list characters)
23:07:42 <ski> that explains it
23:07:57 <ski> rename it to stringsToNums, i suggest !
23:08:42 <ski> (or change it so it takes a single string and gives a single number. then map that over the result from userInput)
23:09:16 <ski> oh
23:09:20 <ski> one more thing
23:09:43 <ski> in main, you are computing (stringToNum a) 3 times !
23:09:53 <ski> unnecessary recomputing
23:09:58 <ski> use a line like
23:10:11 <ski> let nums = stringsToNums a
23:10:27 <ski> and then use nums instead of (stringsToNums a)
23:10:29 <ski> ok ?
23:10:31 <DeezNuts> rename it heh
23:10:41 <DeezNuts> cuz u thought it means something different?
23:10:46 <DeezNuts> ;)
23:10:55 <DeezNuts> i dont like using plurals in my code
23:11:06 <ski> yeah. either rename it, or change it so it just converts a single string to a single number, agree ?
23:11:22 <DeezNuts> no way
23:11:28 <DeezNuts> i want my singular
23:11:30 <ski> then i would suggest using "map"
23:11:34 <ski> @type map
23:11:35 <lambdabot> map :: (a -> b) -> [a] -> [b]
23:11:39 <DeezNuts> what does the name have to do with it?
23:11:52 <DeezNuts> ur confusing me heh
23:12:01 <DeezNuts> btw my program works now
23:12:07 <DeezNuts> so whats the problemo
23:12:15 <ski> well, it's unintuitive (fro me, at least. see : i misunderstood the intension of stringToNum ! :)
23:12:20 <DeezNuts> am i doing it round-about?
23:12:28 <DeezNuts> ok
23:12:37 <DeezNuts> how can I use map to do what stringToNum does?
23:12:41 <ski> it's always good to have a readable, clear program
23:12:54 <DeezNuts> shouldn't it be clear
23:12:57 <DeezNuts> if u know the language?
23:13:13 <DeezNuts> cuz it has strong typing
23:13:13 <ski> stringsToNums strs = map stringToNum strs
23:13:25 <ski> or, up in main :
23:13:38 <ski> let nums = map stringToNum a
23:13:53 <ski> oh
23:14:12 <ski> by clear, i meant : clear to a human reader ;)
23:14:21 <ski> ok ?
23:14:37 <ski> but, it's your program. you decide
23:14:38 <DeezNuts> i'll have to learn haskell more before I can say
23:14:49 <DeezNuts> but in perl I'm used to using singular names for arrays
23:15:04 <DeezNuts> and i've come to prefer it since it usually makes sense in my head when reading perl as english
23:15:07 <ski> i can only adive according to what i feel like a nice way of doing things
23:15:11 <DeezNuts> like
23:15:15 <ski> (advice, even)
23:15:17 <DeezNuts> foreach (@sandwich)
23:15:21 <DeezNuts> instead of
23:15:23 <DeezNuts> foreach (@sandwiches)
23:15:55 <ski> yeah, i understand that it can make sense, in that context
23:16:11 <DeezNuts> or: grep { /ham/ } @sandwich and exit
23:16:13 <ski> or (in C)  month[5]  instead of months[5]
23:16:30 <DeezNuts> ya
23:16:33 <DeezNuts> same deal
23:16:49 <DeezNuts> $month[5] it would prefer reading
23:17:18 <DeezNuts> err
23:17:21 <DeezNuts> it/I heh
23:17:24 <ski> but, the idioms are not exacly the same (order of parts, as well as structure), so here plurals often make sense, if one reads the code. IMHO
23:17:53 <ski> instead of foreach (@sandwiches) doSomething
23:17:55 <ski> we have
23:18:06 <ski> map doSomething sandwiches
23:18:25 <ski> (well, not exactly 1-1 mapping, but hopefully you understand)
23:18:28 <DeezNuts> map ham sandwich
23:18:35 <ski> heh :)
23:18:41 <DeezNuts> ;)
23:18:49 * DeezNuts is singularly stubborn
23:19:34 <ski> hmm, well perhaps i can relate a little to the feeling
23:19:47 <Etaoin> quick question: if I'm looking to write a parser for, say, a little calculator program, are monadic parser combinators the most appropriate place to start?
23:19:56 <ski> in some Pascal book they consistently named types as plurals !
23:20:08 <ski> very irritating for me to read !
23:20:26 * DeezNuts never seen any pascal
23:20:37 <ski> i.e Weekdays instead of Weekday
23:20:44 <ski> so to declare a variable
23:21:00 <ski> var day : Weekdays = Monday;
23:21:14 <ski> (in C that is)
23:21:24 <ski> Weekdays day = Monday;
23:22:28 <ski> i dont want to read "day is a Weekdays" ! i want to read "day is a Weekday" !
23:23:02 * DeezNuts caught Cale
23:23:03 * ski 's perhaps typed enough '!'s for while, ATM
23:23:11 <DeezNuts> Cale you googled for that quine yesterday! http://www.ipl.t.u-tokyo.ac.jp/~scm/
23:23:37 <DeezNuts> ahh
23:23:46 <ski> you're at the same uni ?
23:23:51 <DeezNuts> nope
23:23:53 <DeezNuts> i dont go to school
23:24:00 <DeezNuts> i want to though
23:24:00 <ski> oh, soorry
23:24:21 <DeezNuts> we were just talking about quines in #math yesterday
23:24:21 <ski> are you at the same town, then ?
23:24:27 <ski> ok
23:24:59 * ski just got the impression you talked to Cale in person, yesterday
23:26:41 <ski> so you understand how to use map, then ?
23:26:52 <ski> or you want it explained ?
23:27:01 <Etaoin> DeezNuts: either that or that is an idiomatic way to write a quine in haskell
23:27:38 <Etaoin> otoh, that's the first hit on google, so you could be right
23:29:06 <ski> Etaoin : yeah, monadic parser combinators (e.g. Parsec, PRead or ParseLib.  also some others i think) are easy to write parsers with.  you could try alex and happy also, though (which are like lex/flex and yacc/bison, but for haskell)
23:29:21 <DeezNuts> Etaoin: true :) i considered that heh
23:37:56 <ski> @arr
23:37:56 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
23:39:23 <andersca> arr
23:39:37 <DeezNuts> @arr
23:39:37 <lambdabot> Avast!
23:39:39 <DeezNuts> @arr
23:39:39 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
23:39:45 <DeezNuts> @arr
23:39:46 <lambdabot> Get out of me way, yeh landlubber
23:39:46 <DeezNuts> @arr
23:39:46 <lambdabot> Smartly me lass
23:39:46 <DeezNuts> @arr
23:39:46 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
23:39:50 <ski> @arr
23:39:51 <lambdabot> I want me grog!
23:39:58 <ski> @arr
23:39:58 <lambdabot> Smartly me lass
23:40:01 <ski> @arr
23:40:01 <lambdabot> Smartly me lass
23:40:03 <ski> @arr
23:40:03 <lambdabot> This is the END for you, you gutter-crawling cur!
23:40:11 <ski> heh :)
23:40:24 <DeezNuts> damn
23:40:24 <ski> so he did enter that :)
23:40:40 <ski> (quote from The Secret of Monkey Island)
23:40:45 <DeezNuts> ahhh
23:40:57 <andersca> I have all the monkey island games
23:40:57 <ski> if you have heard of it ..
23:40:58 <ipkiss> which one?
23:41:08 <ski> first one, of course !
23:41:27 <ski> (i.e *The Secret* of Monkey Island)
23:41:39 <ipkiss> yeah, i only know the numbers :)
23:42:01 <ski> http://www.geocities.com/TimesSquare/Lair/5529/hints.htm
23:42:28 <ski> @arr
23:42:28 <lambdabot> Drink up, me hearties
23:42:31 <ski> @arr
23:42:31 <lambdabot> Yeh scurvy dog...
23:42:34 <ski> @arr
23:42:34 <lambdabot> Yeh scurvy dog...
23:42:38 <ski> @arr
23:42:38 <lambdabot> I'd like to drop me anchor in her lagoon
23:42:41 <ski> @arr
23:42:41 <lambdabot> Ahoy mateys
23:42:42 <ski> @arr
23:42:42 <lambdabot> Aye Aye Cap'n
23:42:44 <ski> @arr
23:42:44 <lambdabot> Shiver me timbers!
23:42:45 <ski> @arr
23:42:46 <lambdabot> I'd like to drop me anchor in her lagoon
23:42:47 <ski> @arr
23:42:48 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
23:42:50 <ski> @arr
23:42:51 <lambdabot> I'll keel haul ya fer that!
23:42:52 <ski> @arr
23:42:52 <lambdabot> Yeh scurvy dog...
23:42:54 <ski> @arr
23:42:54 <lambdabot> Prelude.(!!): index too large
23:43:01 <ski> oh :(
23:43:11 <ski> a bug !
23:43:27 <ski> @arr
23:43:27 <lambdabot> Smartly me lass
23:43:38 <DeezNuts> heh
23:43:40 <ski> oh, so it didn't die, at least :)
23:43:41 <DeezNuts> @arse
23:43:41 <lambdabot> Sorry, I don't know the command "arse", try "lambdabot: @listcommands"
23:43:51 <DeezNuts> @listcommands
23:43:51 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
23:43:51 <ski> @arr
23:43:51 <lambdabot> Get out of me way, yeh landlubber
23:43:55 <ski> @arr
23:43:55 <lambdabot> Get out of me way, yeh landlubber
23:43:58 <DeezNuts> @karma
23:43:58 <lambdabot> I can't find the karma of nobody.
23:44:02 <DeezNuts> @karma ski
23:44:02 <lambdabot> ski has a karma of 0
23:44:07 <ski> @karma+ DeezNuts
23:44:07 <lambdabot> DeezNuts's karma has been incremented.
23:44:08 <DeezNuts> @help karma
23:44:08 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
23:44:14 <DeezNuts> @karma - ski
23:44:14 <lambdabot> - has a karma of 0
23:44:15 <ski> @karma DeezNuts
23:44:15 <lambdabot> DeezNuts has a karma of 1
23:44:17 <ski> :)
23:44:18 <DeezNuts> @karma- ski
23:44:18 <lambdabot> ski's karma has been decremented.
23:44:20 <DeezNuts> j/k
23:44:23 <ski> :))
23:44:25 <DeezNuts> @karma+ ski
23:44:25 <lambdabot> ski's karma has been incremented.
23:44:27 <DeezNuts> @karma+ ski
23:44:27 <lambdabot> ski's karma has been incremented.
23:44:33 <DeezNuts> @karma+ DeezNuts
23:44:33 <lambdabot> You can't change your own karma, silly.
23:44:34 <ski> @karma- ski
23:44:34 <lambdabot> You can't change your own karma, silly.
23:44:37 <DeezNuts> heh
23:44:57 <ski> shall we restore to 0, again, matey ?
23:45:26 <DeezNuts> sure
23:45:33 <ski> (lambdabot doesn't really persist these things yet, so it's reset to 0 each time it's restarted)
23:45:37 <ski> @karma ski
23:45:37 <lambdabot> You have a karma of 1
23:45:42 <DeezNuts> @karma DeezNuts
23:45:43 <lambdabot> You have a karma of 1
23:45:43 <ski> @karma DeezNuts
23:45:44 <lambdabot> DeezNuts has a karma of 1
23:45:53 <DeezNuts> @gazetteer
23:46:07 <ski> @karma- DeezNuts
23:46:07 <lambdabot> DeezNuts's karma has been decremented.
23:46:12 <ski> there you go
23:46:16 <andersca> @karma andersca
23:46:16 <lambdabot> You have a karma of 0
23:46:18 <andersca> :(
23:46:19 <DeezNuts> why are we doing this again?
23:46:25 <DeezNuts> @karma+ andersca
23:46:25 <lambdabot> andersca's karma has been incremented.
23:46:28 <DeezNuts> @karma+ andersca
23:46:29 <lambdabot> andersca's karma has been incremented.
23:46:29 <DeezNuts> @karma+ andersca
23:46:29 <lambdabot> andersca's karma has been incremented.
23:46:31 <DeezNuts> @karma+ andersca
23:46:31 <DeezNuts> @karma+ andersca
23:46:31 <lambdabot> andersca's karma has been incremented.
23:46:31 <DeezNuts> @karma+ andersca
23:46:31 <lambdabot> andersca's karma has been incremented.
23:46:31 <lambdabot> andersca's karma has been incremented.
23:46:32 <ski> @gazetteer contemptible
23:46:33 <lambdabot> No match for "contemptible".
23:46:38 <andersca> @karma andersca
23:46:38 <lambdabot> You have a karma of 6
23:46:39 <andersca> yay
23:46:41 <DeezNuts> @listcommands
23:46:41 <ski> @gazetteer janitor
23:46:42 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
23:46:42 <lambdabot> No match for "janitor".
23:46:48 <andersca> ah well, time to go to school
23:46:50 <ski> @dict
23:46:50 <lambdabot> Supported dictionary-lookup commands:
23:46:50 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @prelude @vera @web1913 @wn @world02
23:46:50 <lambdabot> Use "@dict-help [cmd...]" for more.
23:46:54 <DeezNuts> @msg andersca karmamadness
23:46:54 <lambdabot> not enough privileges
23:46:56 <DeezNuts> heh
23:47:03 <DeezNuts> @jargon quine
23:47:04 <lambdabot> *** "quine" jargon "Jargon File (4.3.0, 30 APR 2001)"
23:47:04 <lambdabot> quine /kwi:n/ n. [from the name of the logician Willard van Orman
23:47:04 <lambdabot>    Quine, via Douglas Hofstadter] A program that generates a copy of its
23:47:04 <lambdabot>    own source text as its complete output. Devising the shortest possible
23:47:05 <lambdabot>    quine in some given programming language is a common hackish amusement.
23:47:07 <lambdabot>    (We ignore some variants of BASIC in which a program consisting of a
23:47:09 <lambdabot>    single empty string literal reproduces itself trivially.) Here is one
23:47:11 <lambdabot>    classic quine:
23:47:13 <lambdabot> [27 @more lines]
23:47:17 <ski> @more
23:47:18 <lambdabot>   ((lambda (x)
23:47:19 <lambdabot>     (list x (list (quote quote) x)))
23:47:21 <lambdabot>    (quote
23:47:23 <lambdabot>       (lambda (x)
23:47:25 <lambdabot>         (list x (list (quote quote) x)))))
23:47:27 <lambdabot>   
23:47:29 <lambdabot>    This one works in LISP or Scheme. It's relatively easy to write quines
23:47:31 <lambdabot>    in other languages such as Postscript which readily handle programs as
23:47:33 <lambdabot> [18 @more lines]
23:47:39 <ski> and so on ...
23:47:44 <DeezNuts> lol
23:48:01 <ski> it's written in haskell, of course :)
23:48:07 <DeezNuts> not bad
23:48:12 <DeezNuts> shit i gotta sleep
23:48:15 <ski> oh
23:48:15 <DeezNuts> good night
23:48:21 <ski> good dreaming
23:48:22 <DeezNuts> its 3am
23:48:23 <ski> bye
23:48:23 <DeezNuts> heh
23:48:24 <DeezNuts> thanks
23:48:25 <DeezNuts> peace
23:49:11 * ski returns to blog-reading
