04:25:34 <shapr> YOW!
04:25:41 <andersca> hej shapr
04:25:47 <shapr> hej andersca, vad händer?
04:25:56 <andersca> inte mycket
04:26:15 <shapr> jag har just nu kommer tillbaka från skol
04:26:30 <shapr> svenska för invaders.
04:26:45 <shapr> always fun
04:27:07 <shapr> have you tried the new HSQL release?
04:28:14 <andersca> not yet
04:30:09 <shapr> I haven't either, it has some bobbles on debian
04:31:48 <Segora> new hsql release? wow.
04:32:28 <shapr> some part of the network doesn't like Segora
04:33:29 <shapr> Segora: have you tried connecting via ipv6?
04:33:33 <shapr> that might fix your bouncing.
04:43:56 <Segora> shapr: hmm. I've just started using v6
04:44:14 <Segora> shapr: don't have ipv6 on my work machine yet
07:05:50 <shapr> yow!
07:06:15 * SyntaxNinja boots shapr
07:06:25 <SyntaxNinja> @yow
07:06:25 <lambdabot> Place me on a BUFFER counter while you BELITTLE several BELLHOPS
07:06:25 <lambdabot>  in the Trianon Room!!  Let me one of your SUBSIDIARIES!
07:07:33 <shapr> y0 SyntaxNinja, wazzup?
07:07:58 <shapr> hey, after checking LIP out of arch, I'm convinced you should try darcs :-P
07:08:03 <SyntaxNinja> heh
07:08:05 <SyntaxNinja> I will try it
07:08:27 <SyntaxNinja> what bothered you about the arch experience, OOI?
07:09:24 <shapr> repository names/urls are significant, and that I can't just immediatly check out a repo and make changes, and that the whole startup thing seems very complicated compared to darcs
07:09:49 <shapr> on the other hand, I obviously haven't used arch for anything significant, so maybe there are some great benefits that come from that investment of effort
07:11:14 <shapr> even so, it takes one step to check out a darcs repo that allows me to make local changes, and two step to send those changes back to the original repo
07:11:50 <SyntaxNinja> does darcs keep track of all the repositories it knows about?
07:12:14 <shapr> yes
07:12:28 <shapr> wait, what do you mean by that?
07:12:41 <shapr> do you have darcs installedd?
07:12:48 <shapr> I can show you :-)
07:14:01 <earthy> shapr: what he means is `does darcs maintain a table of all the repositories that have been checked out of the local repository'?
07:14:22 <earthy> so that you have at least *some* idea of where the repositories spread to
07:15:02 <SyntaxNinja> shapr: I think I have it installed, but I'm too busy ATM to play with it.
07:15:37 <SyntaxNinja> I think earthy gets my point... the setup for arch is to create a configuration which will keep track of all the repositories you use, which is very handy. I always wanted something like that for CVS
07:15:38 <shapr> ok
07:16:32 <shapr> well, checking for new changes in a darcs repo is just "darcs pull"
07:17:16 <shapr> well, when you do have time, here's the example: "darcs get http://www.ScannedInAvian.org/repos/wikiwiki" make a change, "darcs record" "darcs push"
07:18:03 <shapr> after which, I can run "darcs pull" and get the changes you committed.
07:19:41 <shapr> "keep track of" in the sense of a centralized command for updating all of your arch repos at once? or what?
07:20:32 <shapr> earthy: in the case of "who's checked out my darcs repo" the apache log will show you.
07:21:59 <shapr> if you want to allow people to grab a copy of your repo, you can just ln -s /var/www/repos/myrepo
07:22:12 <shapr> er "ln -s ~/myrepo /var/www/repos/myrepo"
07:23:43 <earthy> shapr: ah, then darcs itself does *not* keep track of the checkouts
07:24:08 <SyntaxNinja> shapr: how about this case: I have a bunch of repositories, one at work, some at home, some for Haskell remote stuff, etc.  arch keeps track of them for me.  I can say "list hte repositories" and "where are they located" etc
07:24:16 <SyntaxNinja> (that's what the initial setup accomplishes)
07:29:06 <shapr> if you put symlinks to the top level dirs of your local darcs repo into a single dir, you could do the same thing, but otherwise "locate _darcs" would do tell you about the local darcs repos you have.
07:29:27 <earthy> but not those on remote machiens
07:30:13 <shapr> darcs can check the remote machines for any patches that you don't have
07:31:20 <shapr> I think there's a basic difference in that once you've checked out a darcs repo, you now have a fully functional independant repository, you have a full fork of the original repo. you never have to talk to the original again if you want.
07:31:54 <shapr> or you can push a bunch of patches a year later, or just pull one patch (any it depends on will get autopulled) that's happened in that year.
07:33:56 <shapr> earthy: why would you want to keep track of checkouts?
07:34:46 * shapr is still yrvaken
07:34:49 <shapr> bonjour kowey 
07:35:00 <kowey> bonjour shapr, hi everyone
07:36:56 <shapr> SyntaxNinja: why do you want to list the repos and where they are?
07:37:51 <SyntaxNinja> shapr: because I can't keep them all in my head :)
07:38:06 <SyntaxNinja> "wait, what was the name of that haskell repository that I share with shapr?"
07:38:54 <Igloo> If it doesn't exist I'm sure it could be easily added
07:39:39 <shapr> 'locate _darcs' will find all darcs repos on your drive, since that's the magic dir
07:40:15 <SyntaxNinja> I'm simply trying to explain to shapr what the startup costs for initializing your repository is for.
07:40:18 <Igloo> I think he means the remote repos a particular local one has exchanged with
07:40:26 <shapr> oh
07:41:36 <shapr> you can find out where this repo 'came from' by looking at the repos or lastrepo files in _darcs
07:41:58 <SyntaxNinja> what's "this repo"?
07:42:17 <Igloo> The thing checked out in . presumably
07:42:28 <shapr> well, "darcs inittree" in a dir creates a _darcs dir that holds all the magic
07:43:34 <Lemmih> shapr: Got time to help me with my 'shortest path' program?
07:43:55 <shapr> Lemmih: I'm sposed to be fixing a Zope server, sorry.
07:44:21 <shapr> Lemmih: do you have a short description of the problem?
07:44:32 <shapr> if it's something simple, maybe I can help anyway :-)
07:46:31 <Lemmih> I have a function which generates a map from a String and I'm trying to make a function which reads a file and generates the map from that data.
07:46:49 <shapr> @type readFile
07:46:50 <lambdabot> readFile :: FilePath -> IO String
07:47:39 <Lemmih> I know the function but I get "Type error in final generator" :|
07:47:55 <shapr> is your source online?
07:47:56 <Lemmih> Here is the code:
07:47:57 <Lemmih> generateFromFile :: String -> Route
07:47:58 <Lemmih> generateFromFile f = do
07:47:58 <Lemmih>   content <- readFile f
07:47:58 <Lemmih>   generateFromString content
07:48:31 <Darius> @type return
07:48:32 <lambdabot> return :: Monad a => b -> a b
07:48:37 <Lemmih> Should it be: "return generateFromString content"?
07:48:40 <Lemmih> ahh :)
07:48:46 <shapr> try commenting out the type signature, loading the code into ghci, and do ":t generateFromFile"
07:49:25 <Darius> Lemmih: return (generateFromString content).  return is a normal function.
07:52:51 <Darius> @type \f name -> fmap f (readFile name)
07:52:52 <lambdabot> \f name -> fmap f (readFile name) :: ([Char] -> a) -> [Char] -> IO a
07:55:57 <shapr> oh, has anyone updated Tomasz' Template Haskell stuff to get it working with 6.2 ?
07:56:31 <shapr> Darius: have you tried Scala?
07:56:53 <Darius> No
07:57:17 <shapr> I wonder if it's worth investigating.
08:04:58 <shapr> oh cool, HasFuse might be the @ghci we've been looking for
08:05:26 <Darius> url?
08:05:37 <shapr> http://www.ki.informatik.uni-frankfurt.de/~sabel/hasfuse 
08:07:07 <shapr> or maybe I'm misreading the description.
08:10:02 <shapr> bah, I think that's only for unsafePerformIO
08:27:27 <Lemmih> How do I manipulate my data structures?
08:31:22 <shapr> what do you want to do with it?
08:34:46 <kowey> i don't suppose anyone's tried to compile happy (the parser generator) recently?
08:35:48 <earthy> what do you mean recently?
08:35:49 <earthy> last week
08:35:55 <earthy> went without a hitch
08:35:56 <kowey> no problems?
08:36:02 <kowey> with ghc 6.0.2 on my mac
08:36:11 <kowey> /usr/local/bin/ghc -cpp -fglasgow-exts -package lang -O -O  -Onot  -c Parser.hs -o Parser.o
08:36:14 <kowey> GenericTemplate.hs:0: lexical error
08:36:33 <kowey> (./configure went fine; this is make i'm talking about)
08:36:39 <earthy> ah, this was 5.04.3 on solaris
08:37:08 <kowey> oops, 6.2, hmm, also 5.04 on linux gives
08:37:18 <kowey> make INSTALLING=0 BIN_DIST=0 - --no-print-directory -r all
08:37:19 <kowey> /usr/bin/ghc -ldl -cpp -fglasgow-exts -package lang -O -O    -c AbsSyn.lhs -o AbsSyn.o
08:37:21 <kowey> Prologue junk?: .globl __stginit_AbsSyn
08:37:23 <earthy> by the by, did you get hugs to work on macOS X?
08:37:25 <kowey> __stginit_AbsSyn:
08:37:28 <kowey>         pushl   %ebp
08:37:30 <kowey>         movl    %esp, %ebp
08:37:33 <kowey> make[3]: *** [AbsSyn.o] Error 1
08:37:39 <kowey> yep, i just installed it with fink, very handy
08:37:44 <earthy> :)
08:37:58 <earthy> that version is 2 years old, you know that? :)
08:38:10 <kowey> *chuckles*
08:38:28 <kowey> maybe one day i'll be eager enough to become a pkg maintainer
08:38:43 <shapr> it sounds like gcc3 problems
08:39:12 <shapr> in that version of ghc, the evil mangler only is happy with gcc 2.95 at the latest.
08:39:13 <kowey> you mean the mac problems or the linux problems?
08:39:22 <kowey> ah, mac is gcc
08:39:23 <kowey> 3.3
08:39:42 <shapr> I think it still mostly compiles okay
08:39:52 <Igloo> kowey: Remove the LINE pragmas from Parser.hs
08:40:15 <earthy> or change them to be correct. :)
08:40:21 <kowey> do those do anything important?
08:40:25 <earthy> nope.
08:40:29 <kowey> same
08:40:43 <kowey> oops... hang on
08:41:58 <kowey> sweet! without a hitch
08:42:08 <kowey> thanks (again) Igloo/earthy/shapr
08:42:21 <kowey> anyone care to explain what happened?
08:46:31 <earthy> yes. See http://haskell.org/pipermail/glasgow-haskell-bugs/2004-February/003862.html
08:46:56 <earthy> (this is conjecturing on what Igloo said)
08:47:00 <kowey> ah... interesting
08:47:10 * kowey needs to sharpen his google-fu
08:48:06 <Lemmih> shapr: I'm trying to access 'width' which is a member of Map.
08:48:47 <earthy> kowey: I only know this due to reading glasgow-haskell-bugs :)
08:49:24 <kowey> is this general curiosity, or watching out for trouble?
08:49:31 <earthy> general curiosity
08:49:41 <earthy> I often read it with the d-button. :)
08:49:43 <shapr> Lemmih: pattern match on the constructor?
08:49:59 <kowey> ah yes, the speed-reading option
08:57:22 <Lemmih> shapr: But what if I want to change the value? Is it possible to do something like: myStruct.value=10;?
08:57:47 <shapr> you could use records
09:25:06 * Marvin-- swears
09:28:38 <Marvin--> I wonder if my harddrive is hosed
10:12:25 <kowey> bye everyone!
11:26:23 * esap just wrote the shortest mandelbrot program I've ever written.
11:27:07 <esap> let m c x | magnitude x < 2 = Just (x*x+c) ; m c x = Nothing in \c x -> unfold (m c) x
11:34:01 <Darius> let m c x = boolToMaybe (x*x+c) (magnitude x < 2) in unfold . m
11:43:09 <Marvin--> hmm, so I have this set of Haskell->Haskell transformations and this set of Haskell->FOL transformations that I use in my program... in what order should I present them in the report?
11:47:09 <Darius> (takeWhile ((< 2) . magnitude) .) . iterate . \c x -> x*x+c (point-free listful style ho!)
11:47:33 <Darius> Marvin--: Are they applied in as certain order?
11:50:29 <Marvin--> Darius: well, the H->H transformations are applied before the H->FOL ones, but many of the H->H transformations don't make sense until you've seen the H->FOL stuff...
11:51:28 <Marvin--> so I'm leaning towards presenting the H->FOL stuff first, discuss what this requires in terms of a simplified syntax tree and then present the H->H transformations that make it happen
11:56:10 <ham[cook]> hiho
12:01:37 <Marvin--> ello
12:26:27 <esap> darius: I think it's important that the return type of the mandelbrot thing is Rec Maybe.
12:29:23 <Darius> length . 
12:30:33 <esap> darius: no I mean, look at the function 'copr(f)(x)' from Hagino's thesis. It's essentially the same as unfold.
12:31:59 <esap> darius: and Hagino describes it as "copr(f)(x) is the number of applications of f to x to get the element of 1, copr(f)(x) = n where f^n(x) \in 1"
12:32:36 <esap> darius: which obviously points to mandelbrot :-)
12:38:53 <Darius> All the types that correspond to final coalgebras will have adjuncts that are "essentially the same as unfold", the adjunct -is- unfold.
12:41:55 <esap> Hmm.. I guess that's true. Very interesting nonetheless :-9
12:43:18 <Marvin--> hm. okay, so I have an AST for a simple functional language with declarations and expressions and I have a set of transformations that simplify the expressions, basically ensuring that some of the constructors in the expression tree will not be present after the transformations... any clever way I could structure my data types for this?
12:44:24 <esap> marvin: do you use Rec for the AST already?
12:44:32 <Marvin--> Rec?
12:45:14 * esap points at http://haskell.org/hawiki/PreludeExts
12:45:23 <Marvin--> right now I have, say, data Dec = Dec Id [Pat] Exp ; data Exp = EApp Exp Exp | EVar Id | ELet [Dec] Exp
12:46:57 <esap> Yea, I usually represent only one level of the tree, e.g. data Exp self = EApp self self | EVar Id | ELet [Dec] self, then use Rec Exp
12:47:09 <Marvin--> but I'd like to have another Exp type without let expressions
12:47:33 <Marvin--> but having to have different constructor names kinda sucks
12:49:44 <esap> it's pretty hard to divide an algebraic data type into parts in Haskell
12:52:10 <esap> But I suggest think of the data types that represent your language as an interface in your program and I think everything will go ok whatever you do :-)
12:54:24 * esap has made the mistake of thinking algebraic data types as if they were OO objects; it didn't work at all well.
12:54:43 <Marvin--> yeah I know
12:55:54 <Darius> There's Daniel Wang's draft paper: http://www.cs.princeton.edu/~danwang/drafts/recursion-schemes.pdf (if this is the one I'm thinking of)
13:05:52 <esap> darius: hmm.. interesting [I wasn't aware of that paper], most of it seems quite trivial [I didn't yet read it fully though]
13:14:56 <stepcut> blah. bit field parsing sucks
13:18:23 * stepcut reads about erlangs bit-syntax
13:24:14 <stepcut> unfortunately, TH does not let you define new syntax
13:26:51 <Darius> Googling for "syntactic macros" or something to that effect will turn up a project/tool that (supposedly) will do that.
13:44:02 <Marvin--> hey Heff
13:44:35 <Heffalump> hiya
14:00:47 <Heffalump> shapr: you around?
14:00:55 * Marvin-- grins at Heffalump
14:01:31 <Heffalump> or indeed anyone else who understands how to install a MoinMoin processor
14:02:14 <Marvin--> wonder if I should wear a HM t-shirt when I present my project
14:02:20 <Marvin--> (if I ever finish it)
14:03:00 <andersca> Marvin--: perhaps you can wear a H&M t-shirt
14:03:06 <Marvin--> eeek, no
14:03:29 * Marvin-- still ponders how to write these data types in a sane way
14:08:35 <Marvin--> argh, there's no instance Data (a,b,c) in Data.Generics
14:15:31 <Marvin--> hm, I could go for some of those linear implicit return values now
14:25:44 <Marvin--> I so don't understand how to use Rec
14:28:04 <Marvin--> hm, maybe I do
14:32:15 <Marvin--> wow
14:32:21 * Marvin-- looks cross-eyed at his code
14:41:41 <Igloo> Does it turn into a 3D picture of a boat?
14:45:20 <Marvin--> alas no, I suck at looking at such pictures
14:50:46 <Marvin--> do e1' <- g (unIn e1) ; e1'' <- f e1' ; e2' <- g (unIn e2) ; e2'' <- f e2' ; return (In (EApp e1'' e2''))
14:50:48 <Marvin--> ooookay
14:50:55 <Marvin--> now to figure out how to rewrite that with fold and unfold
14:52:49 <Marvin--> so I have  g :: Exp (Rec Exp) -> Writer [Dec (Rec Exp)] (ESimple (Rec Exp))  and  f :: ESimple (Rec Exp) -> Writer [Dec (Rec Exp)] (Rec ESimple)
14:57:47 <Igloo> I can't do the pictures either
15:00:16 <Marvin--> yay, snooker on eurosport
15:01:09 <andersca> I don't have a tv
15:01:52 <Marvin--> well, that's you
15:02:21 <Marvin--> jeepers, how the hell do I show Rec stuff
15:02:37 <andersca> perhaps if you didn't have a tv you would know
15:02:47 <Igloo> I was impressed with that Chinese guy. I'm not sure I saw a ball hit the jaws
15:04:21 <Marvin--> andersca: feh
15:04:36 <Marvin--> obviously, deriving Show ain't gonna work
15:04:59 <Maddas> andersca: haha
15:06:03 <Marvin--> huh... I was pretty sure that H98 disallows stuff like  instance Show (Rec Exp) where... is that a ghc extension?
15:06:13 * Marvin-- uses -fglasgow-exts way too much
15:07:38 <Heffalump> yes, it does disallow it.
15:07:55 <Heffalump> you need instance Show (Rec a)
15:08:42 <Marvin--> that's what I thought
15:08:52 <Marvin--> oh well, I have -fglasgow-exts anyway for the generics and stuff
15:11:29 <Darius> andersca: I have a TV but I don't use it.  At least not for television.
15:11:47 <andersca> Darius: then you might almost know how to do the rec stuff
15:12:39 <Marvin--> after fiddling with this for a bit, I think the code will be clearer if I use two distinct data types after all
15:13:00 <Marvin--> rather than nesting the simpler in the complicated and using Rec for recursion
15:45:26 <swisscheese> Anyone know the speed ratio of GHC to HUGs?
15:49:26 <swisscheese> Anyone building large apps - say a few mb of source?
15:50:52 <Vulpyne> ghc is considerably faster, from what I've read.
15:52:22 <Heffalump> "an order of magnitude" is generally quoted
15:52:26 <swisscheese> Thanks - I've just been procrastinating installing it.
15:52:27 <Heffalump> I'd guess at a factor of 10 or so.
15:52:36 <Heffalump> compiling things is quite slow, though
15:55:22 <swisscheese> There always seems to be about 50 guys hanging out and rather quiet - why are then logged in?
15:56:03 <Heffalump> it's usual to leave clients connected even when not physically here.
15:56:14 <Heffalump> Channel poll time! All those physically here, say something! 
15:56:32 <swisscheese> Why stay connected?
15:56:35 <Marvin--> I don't see how you can compare compiled code running time to interpreted code running time
15:56:44 <jasonw> I'm here, mostly.
15:57:08 <Marvin--> hugs vs ghci is a more fair comparison and hugs starts up a lot faster, which can be a boon if you're on a slow computer, but otherwise I prefer ghci
15:57:40 <Heffalump> Marvin--: why can't one compare them?
15:57:50 <monotonom> I am not physically here. This statement is false.
15:57:59 <Heffalump> swisscheese: why not?
15:58:14 <Heffalump> saves having to join when you want to talk, and you have scrollback to read the context of the current conversation.
15:58:15 <Marvin--> well, unless you've done something really stupid, compiled code damn well should be a lot faster :)
15:58:26 <Heffalump> Marvin--: yes, I was commenting about *how much* faster it was...
15:58:53 <Marvin--> well sure
15:59:28 <Marvin--> "so much faster that if you really need speed there's no reason at all to use hugs over compiled code"
15:59:47 <monotonom> I don't see any value in answering every question I cannot answer in order to prove that I am physically paying attention to the channel.
15:59:59 <Heffalump> no, me neither.
16:00:19 <Heffalump> Hence my poll, I was interested in how many people actually were watching and just being silent.
16:00:33 <monotonom> If all you want is 50 people answering "I don't know" to a question, I suggest writing a program to do that.
16:00:37 <swisscheese> OK so what about large apps - trying to decide if can switch some projects from c++.
16:01:03 <Heffalump> they'll get a lot slower if you do that
16:01:17 <Heffalump> even the best code GHC compiles is typically a few times slower than the output from a good C/C++ compiler, AIUI.
16:02:42 <swisscheese> haskell.org makes the point that 90% of code has no need for speed - the other 10% can write in C.
16:03:22 <Riastradh> Yuck, C.  Go PreScheme!
16:04:36 <Heffalump> ghc is also probably a lot slower than a C/C++ compiler.
16:04:58 <door> but should it have to be? :/
16:04:59 <Heffalump> obviously Haskell has lots of advantages too - those are (IMO) the two principle disadvantages
16:05:15 <Heffalump> door: well, it's written in Haskell, and it does a lot of work to make the code faster.
16:05:20 <Riastradh> I'm often here, but I don't always pay attention to this channel!
16:05:53 <door> Heffalump: doesnt it compile to native code?
16:06:24 <Heffalump> yes, but the execution model of Haskell code is fundamentally inefficient
16:06:38 <door> okay
16:07:15 <Riastradh> Heffalump, that's inflammatorily and extremely debatable.
16:07:28 <Heffalump> two words: space leaks
16:07:33 <Riastradh> But that's all I'm going to say; I'm not going to try to live through one such debate.
16:07:38 <Heffalump> two more: updatable thunks
16:07:41 <Heffalump> ok :-)
16:08:15 <Heffalump> I will note, however, that a lot of the work GHC does is to avoid the cost of updatable thunks and space leaks where possible.
16:09:13 <swisscheese> What the heck are space leaks and updatable thunks?
16:09:23 <Heffalump> umm.
16:09:29 <Heffalump> I was about to go to bed :-)
16:09:36 <swisscheese> And what's the URL for PreScheme?
16:09:36 <Marvin--> serves you right :P
16:09:56 <Heffalump> ugh, no, you don't want to use Scheme, it's nasty! </troll>
16:10:19 <swisscheese> OK, then what to mix with H for speed?
16:10:38 <Heffalump> well, C is the language that the FFI talks to
16:10:38 <door> c/c++?
16:10:46 <Heffalump> at least by default
16:10:48 <cleverdra> swiss - www.s48.org; in scheme48 look at such as: ,dis +
16:11:19 <Riastradh> swisscheese, it doesn't have a web site, but there are lots of papers on it, and Scheme48 comes bundled with a PreScheme compiler.
16:11:26 <Riastradh> cleverdra, uh, no, that will show you Scheme48 bytecode.
16:11:37 <Heffalump> why 48, OOI?
16:11:42 <cleverdra> Riastradh - indeed?  What version of scheme48 do you have?
16:11:44 <Riastradh> Look in scheme/vm/ in the Scheme48 distribution for lots of PreScheme code.
16:11:53 <cleverdra> Riastradh - OK.
16:12:16 <Riastradh> cleverdra, doesn't matter: it's been like this throughout Scheme48's existence.  The VM is written in PreScheme, and Scheme48 includes a compiler to its own bytecode format, which the VM interprets.
16:13:07 <Riastradh> Heffalump, originally, as if it could have been written in 48 hours; it was later changed to be able to have been _read_ in 48 hours, and now the authors have become uneasy about how complicated parts of it have gotten, though it's still a _lot_ simpler than most other Lisps.
16:13:47 <Riastradh> By the way, all you #haskell'ers who are spitting upon PreScheme should like the fact that PreScheme involves HM type inference!
16:14:07 <Heffalump> does it have lots of (s? :-)
16:14:09 <cleverdra> Riastradh - who has spat on it?
16:14:12 <Heffalump> meeee!
16:14:16 <cleverdra> also, 'who spat'.
16:14:24 <Riastradh> (The VM was written in PreScheme even before the PreScheme compiler was conceived, in fact.)
16:15:08 <cleverdra> heffa - that doesn't even amuse me anymore.
16:15:34 <Heffalump> maybe not, but it's a concrete reason I wouldn't use Scheme
16:15:52 <Riastradh> Heffalump, the lack of a fascist static type system?
16:16:01 * cleverdra doesn't care to investigate that insanity.
16:16:01 <Heffalump> I like static type systems.
16:17:36 <Riastradh> Static type systems are Good Things.  But they're _far_ too much of a focus, and they shouldn't infect the language and obstruct the programmer in places.  (PreScheme gets exception here: it's necessarily low-level, and low-level code really needs the protection.)
16:18:21 <cleverdra> Riastradh - PreScheme has a static type system?
16:18:30 <shapr> and there was great rejoicing: http://haskelldb.sourceforge.net/
16:18:36 <Riastradh> Yes...I already said that.
16:18:42 <Maddas> shapr: heh.
16:19:01 <cleverdra> Riastradh - difficult sometimes to tell a conceptual error from a surprising assertion.
16:19:01 <Riastradh> shapr, yuck!  A new project spoiled by placement in SF!
16:19:36 <shapr> well, I've given up on gforge for the moment.
16:19:42 <Riastradh> cleverdra, ?
16:19:47 <Heffalump> shapr: why, OOI?
16:20:17 <shapr> We bounced the idea off of the Simons and the haskell.org maintainers, and they pretty much said "we don't see any benefit over sourceforge"
16:20:27 <Heffalump> ah.
16:20:42 <shapr> SPJ said he'd rather people put effort into making LIP happen.
16:20:42 <Heffalump> sourceforge annoys me.
16:20:43 <Riastradh> shapr, did you mention how much SF sucks?
16:20:59 <Marvin--> LIP?
16:21:14 <shapr> yes, I mentioned that SF.net has bandwidth problems, but I think none of them actually use sf that much.
16:21:20 <swisscheese> Thanks for the feedback - dinner is served :-) Bye.
16:21:23 <Riastradh> Library Infrastructure Phthisis?
16:21:37 <Marvin--> shapr: ah, that'd be why they don't think it sucks :)
16:21:43 <shapr> yes, probably so.
16:22:19 <shapr> but
16:22:35 <shapr> I decided to put my effort towards the Library Infrastructure Project instead
16:25:34 <clausen> alioth.debian.org ?
16:25:45 <shapr> alioth is a gforge instance
16:31:04 <stepcut> shapr: my haskell library currently just parses the bitmaps generated by metafont, but eventually I think it will render the .mf files directly
16:31:14 <shapr> neat
16:31:36 <stepcut> but currently I am cursing bit stream parsing in haskell
16:33:06 <stepcut> the gf (generic font) files are essentially run length encoded. Essential it says, draw 56 pixels of black, now 4 of white, now a newline, now 10 pixels black. etc. 
16:33:15 <Igloo> Whether Haskell is significantly slower than C depends a lot on what your code does (especially things like whether you're throwing lists of characters around or unboxable numbers)
16:33:49 <Igloo> And GHC (-O) will be slower than gcc by virtue of calling it to do the actual compilation  :-)
16:35:53 <stepcut> any in my case, the pixels are always 1-bit. So currently I generate a list of 0 and 1, and then after its done, I have a function that takes 8 elements at a time and combines them into a Word8. Then I just do that recursively over the whole list. 
16:35:59 <shapr> Heffalump: still have Moin processor questions?
16:36:26 <stepcut> this method is works fine for proof-of-concept, but its seems rather lame
16:36:59 <Heffalump> shapr: no, I figured it out
16:37:14 <shapr> ok, bug me if you have anymore questions
16:37:26 <Heffalump> wait for Igloo to break it :-)
16:37:30 * shapr grins
16:37:44 <Igloo> You'll have to give me incentive to use it first  :-)
16:38:01 <Heffalump> collaborative research?
16:38:33 <Igloo> An actual concrete instance, though
16:39:06 <Heffalump> remind me I want to talk to you about refactoring and monads.
16:39:20 <Igloo> The matching bitf of trees thing didn't work BTW, so maybe if you have any other ideas that would fit  :-)
16:39:23 <Heffalump> and possibly reopen the conversation about TH.
16:39:29 <Heffalump> the what?
16:39:47 <Igloo> I need to look at the DeclInfo stuff in the recent TH to see if it just became an awful lot easier
16:40:03 <Igloo> Matching errors in the H tree to ?s in the TH tree
16:41:31 <Igloo> Is the talking related to the workshop the three of you are going to in a week or so?
16:41:35 <Heffalump> yes
16:41:41 <Heffalump> so I want to talk to you soon :-)
16:41:46 <Igloo> :-)
16:41:56 <Heffalump> mainly just to replay the conversation we had about introducing monads with TH
16:42:23 <Igloo> Hmmm, when is the workshop?
16:42:26 <Heffalump> Monday.
16:42:37 <Igloo> OK
16:52:03 <Igloo> @info shapr
16:52:03 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
16:52:14 <shapr> ?
16:52:31 <Igloo> What's your e-mail address again?
16:52:36 <shapr> Igloo: no one has written an info manual for me yet.
16:52:39 <Heffalump> shae@scannedinavian.org ?
16:52:46 <shapr> dot com actually
16:52:50 <Heffalump> nearly.
16:52:59 <Heffalump> so you're a Scandiavian .com, are you?
16:53:04 <shapr> though they all work with some level of delay
16:53:07 <Heffalump> s/avian/navian/
16:53:21 * Igloo adds it to his alias file this time
16:53:38 <shapr> that's right, I actually make money while living in Scanned In Avia.
16:53:53 <shapr> though at the moment I could live with a bit less work :-)
16:54:44 <shapr> anyways, self-employed means you happily curse too much work, and have a nice starving vacation when you have too little, so it's all good.
16:55:01 <Heffalump> why not save up in the former times for the latter times? :-)
16:55:42 <shapr> I do, but I want to become rich (my definition of rich is "not having to ask before buying a new PC" =)
16:55:58 <shapr> g'day Pseudonym, ltns
16:56:02 <Pseudonym> G'day.
16:56:11 * Pseudonym was r00+k1t+3d
16:56:16 <shapr> yowch
16:56:20 <Pseudonym> This explains my absence.
16:56:30 <Igloo> :-/
16:56:54 <keverets> now, if most of the system was written in haskell, would that not be much less likely?
16:57:05 <Pseudonym> Could be!
16:57:22 <shapr> truly, script kiddies would cry upon encountering Haskell.
16:57:22 * Pseudonym starts rewriting Linux in Haskell
16:57:53 <Pseudonym> Mmm... money...
16:58:34 <Pseudonym> Oooh, IPv6.
16:58:34 <Pseudonym> In Haskell?
16:59:00 <shapr> I want it!
16:59:09 <cleverdra> I don't care if they use a white cat or a black cat to drive IPv6, so long as I don't have to care about it when I use it.
16:59:11 <shapr> I want to see lambdabot using ipv6 =)
16:59:14 <cleverdra> shapr - I think that script kiddies, by definition, do not program.
16:59:30 <shapr> ergo, building GHC will make any script kiddie cry.
16:59:36 <Pseudonym> The script kiddie who rootkitted me, incidentally, was completely stupid.
17:00:11 <cleverdra> shapr - but I used to call them 'fucking script kiddies', and only dropped the first word of their name for politeness.  Maybe this has created some ambiguity.
17:00:13 <Pseudonym> It wasn't a kernel rootkit (I never allow module loading on machines which aren't behind several layers of firewall).
17:00:34 <clausen> Pseudonym: does that allow any defence?
17:00:44 <Pseudonym> It was all userland, and every affected file was, very kindly, owned by a specific uid.
17:00:49 <shapr> hah
17:00:54 <Pseudonym> clausen: It allows _some_ defence.
17:01:11 <Pseudonym> Obviously it's no guarantee.
17:01:18 <clausen> Pseudonym: it seems like zero defence to me
17:01:32 <clausen> Pseudonym: do you have rw access to /dev/kcore?
17:01:41 <Pseudonym> clausen: No.
17:01:50 <Pseudonym> No user (apart from root, obviously) does.
17:02:02 <clausen> I mean does, root have rw access?
17:02:06 <Pseudonym> Yes.
17:02:22 <clausen> I imagine it wouldn't be too hard to "enable" module support then
17:02:38 <clausen> (it's another question as to whether a convenient program is available for the job...)
17:02:42 <Pseudonym> Well, it would be hard to "enable" module support.  There's code #ifdef'd out.
17:02:59 <Pseudonym> And binary patching a running kernel would be hard, because every kernel binary is different.
17:03:07 <Pseudonym> Having said that, it's possible in principle.
17:03:11 <clausen> I doubt it's very hard
17:03:16 <Pseudonym> It's a higher barrier to get over.
17:03:22 <cleverdra> clausen - but some security exists just so that, even with someone acquiring root, certain damage will not happen.
17:03:29 <clausen> but, the script kiddie might not be the ones jumping the barrier
17:03:30 <cleverdra> clausen - see OpenBSD's 'security levels'.
17:03:37 <Pseudonym> clausen: That's true.
17:03:57 <clausen> cleverdra: there is also SELinux
17:04:21 <clausen> cleverdra: (probably the same thing?)
17:04:21 <Pseudonym> I do maintain that having module loading turned off provides effective protection against certain types of attacker, i.e. script kiddies.
17:04:34 <cleverdra> clausen - I don't know anything about SELinux's security model.
17:04:41 <Pseudonym> A determine attacker will find a way in.
17:04:47 <stepcut> SELinux rocks :)
17:04:58 <Pseudonym> stepcut: How do you back up a SELinux machine?
17:05:03 <cleverdra> Does SELinux use grsecurity?
17:05:27 <emu> does selinux fuck over ghc?
17:05:58 <stepcut> Pseudonym: You create a process that has the capabilities it needs. Oddly enough, it might be possible to create a backup process that can copy the files, but not read them using SElinux
17:06:11 <Pseudonym> Oh, interesting.
17:06:34 <Pseudonym> Yes, my brother had a SELinux machine and had a horrible time trying to back it up over a network.
17:06:47 <Pseudonym> Dumped it in favour of Debian in the end.
17:08:02 <clausen> I guess my point is: if root == "supreme executive authority", then obtaining root is Game Over
17:08:04 <stepcut> Pseudonym: that is where the major work still lies -- writing the security policy files 
17:08:06 <shapr> yay debian
17:08:09 <shapr> boo rootkits
17:08:26 <stepcut> clausen: selinux gets rid of 'root'
17:08:31 <clausen> stepcut: right
17:08:42 <cleverdra> also, aside: Smerdyakov requests (PRIVMSG) comments on his petition, of the text: "Smerdyakov should be unbanned from #haskell unless an argument for continuing the ban is written and made available to the channel. The argument should seek to minimize references to unincluded information."
17:08:49 <Pseudonym> clausen: In principle.
17:09:04 <Pseudonym> Just because something isn't _total_ security doesn't make it useless.
17:09:05 <clausen> why was he banned?
17:09:11 <cleverdra> ah, nifty.  A bit like sudo taken into syscalls? =)
17:09:11 <clausen> url?
17:09:25 <Pseudonym> Because the more hurdles, the better, IMO.
17:09:45 <shapr> lots of stuff in the logs about why he was banned.
17:09:58 <cleverdra> clausen - he just told me about it.  I don't know if he as a URL for it.
17:10:15 <clausen> if he wants to get back in, I guess he should make it easy for everyone to know why :)
17:10:42 <cleverdra> clausen - presumably the argument he requests would serve for that.
17:10:45 <Riastradh> I've been given conflicting and varying reasons as to why he was banned from both shapr and Smerdyakov; I thereby conclude that it was some personal vendetta between the two, and not any specific instance.
17:11:02 <ibid> from a blog:
17:11:17 <ibid> '"I suspect Vera's biggest problem is that functional programming requires adopting a new paradigm for thinking about programs." - he says. OK, I need new paradigm for adoption into a good home. Promise to feed it three times a day.'
17:11:31 <Pseudonym> ibid: Yay, functional programming discussion!
17:11:36 <ibid> yeah
17:11:36 <shapr> ooh, on-topic
17:11:40 <ibid> :)
17:12:09 <cleverdra> shapr - 'differently on-topic', as opposed to the previous security discussion =)
17:12:14 <ibid> oh, btw, good morning everyone, it's another bjuuuutiful day
17:12:29 <shapr> I'm trying to decide between coffee and sleep.
17:12:35 <Riastradh> Coffee.  Definitely.
17:12:36 <cleverdra> ibid - vera?
17:12:39 <shapr> yes, the SELinux stuff is very interesting.
17:12:41 <Pseudonym> shapr: Coffee is good.  Sleep is also good.
17:12:48 <ibid> cleverdra: http://izrailit.blogspot.com/
17:12:51 <Riastradh> Sleep will just be that much more pleasnat when you do get around to it.
17:12:55 <Pseudonym> You can't code while asleep.
17:13:01 <shapr> Pseudonym: have you seen the GHC version of HaskellDB?
17:13:03 <Pseudonym> Though you can design.
17:13:06 <Heffalump> FWIW, I agree with said petition.
17:13:07 <ibid> Pseudonym: but you can? ;)
17:13:09 <Pseudonym> shapr: No, not yet.
17:14:17 <Pseudonym> "I'd rather be performing all the conceivable unnatural acts with C pointers."
17:14:49 <Pseudonym> TMI if you ask me.
17:14:49 <Heffalump> is HaskellDB mainly IO monad based, btw? ISTR some MySQL bindings from a while back that used unsafePerformIO.
17:14:56 <ibid> TMI?
17:15:02 <cleverdra> ibid - Too Much Information.
17:15:02 <Pseudonym> Too Much Information
17:15:07 <shapr> HDB wraps HSQL
17:15:08 <ibid> ahh
17:15:20 <Pseudonym> "Lisp is very annoying to write code in. In fact all the functional languages are very annoying. Is it just me, or are so-called artificial intelligence languages somehow incompatible with natural human intelligence?"
17:15:23 <shapr> HSQL does postgresql, mysql, and odbc
17:15:29 <shapr> oh, and sqllite
17:15:37 <cleverdra> ibid - oh, darn, by understanding too early you've stopped me from giving you a better example of TMI.
17:15:43 <Riastradh> Pseudonym, no, _lack_ of human intelligence.
17:15:48 <Pseudonym> Yes. :-)
17:16:03 <ibid> cleverdra: please, do not pay any attention to my understanding :)
17:16:07 <Pseudonym> Here's the thing I don't get:
17:16:13 <cleverdra> bah, he called Lisp a 'functional language'.
17:16:24 <Heffalump> are you claiming it's non-functional?
17:16:25 <Pseudonym> This person dismisses "artificial intelligence languages".
17:16:32 <Pseudonym> Then says "new paradigm, free to good home etc".
17:16:45 <ibid> cleverdra: who's he, lars?
17:16:50 <cleverdra> Heffa - I claim that it does not usefully clump into the same target of apathy.
17:16:59 <Pseudonym> Isn't that the point?
17:17:07 <Heffalump> I was trying to make a play on "non-functional", without success.
17:17:12 <Heffalump> just ignore me :-)
17:17:24 <Pseudonym> That Lisp in particular is good for AI?  That's its "home", as far as this person is concerned.
17:17:31 * Pseudonym fails to understand
17:18:02 <Pseudonym> You want to write code which does symbolic manipulation, but you don't want to use the paradigms that come with it.
17:18:08 <bring> Heffalump: yes, HaskellDB uses IO
17:18:43 <bring> there is currently not even support for lazy IO
17:18:55 * cleverdra waits for his orkut-suicide to happen.
17:19:00 <ibid> Pseudonym: the context is that they are talking about hedgehog lisp, a lisp variant lars wirzenius made that is used for programming their embedded software
17:19:06 <Pseudonym> "I, like, want to write all this mathematical code, but I don't want to adjust my thinking to work with maths."
17:19:08 <clausen> cleverdra: orkut suicide?
17:19:10 <ibid> orkut-suicide=
17:19:11 <ibid> ?
17:19:25 <Pseudonym> Ah...
17:19:31 <Pseudonym> That could explain a lot.
17:19:45 <Pseudonym> If it's an odd dialect of Lisp, that could be annoying.
17:19:56 <ibid> http://www.oliotalo.fi/hedgehog/hoglisp.html
17:20:00 <Pseudonym> See also: Greenspun's tenth rule.
17:20:08 <ibid> which is?
17:20:57 <Pseudonym> "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp."
17:21:08 <cleverdra> ibid - I joined 'orkut' a few days ago, a 'friendship' network which seems to have acquired some amount of fame (I hear people talking about it in here and in #Lisp and in infobot #Perl -- possibly it appeared on slashdot or like).  In order to unjoin you have to send admin@orkut.com an email which they apparently have a human read.
17:22:13 <Heffalump> why are you leaving, OOI?
17:22:26 <Heffalump> I can see why one might want to, I'm just interested in your specific reasons.
17:22:29 <Riastradh> Yaagh!  This makes _five_ channels on Freenode that have begun to be infected by this Orkut silliness!
17:22:37 <Riastradh> Five that I frequent, that is.
17:22:42 <cleverdra> Riastradh - hey, I didn't start it =)
17:22:48 <Pseudonym> The main exception is Emacs, which contains an ad-hoc, informally-specified slightly faster implementation of three quaters of Common Lisp.
17:23:31 <cleverdra> Pseudonym - #Lisp could probably relieve you of that misapprehension, if you ask them nicely.
17:24:00 <Riastradh> They could probably relieve you even more exuberantly if you asked impolitely!
17:24:06 <Pseudonym> True.  Actually, Emacs doesn't implement much of the Common Lisp environment.
17:24:20 <Pseudonym> It actually implements something closer to Maclisp.
17:24:57 <Riastradh> Coincidentally, MacLisp was the major Lisp that was around when Emacs was started!
17:25:09 <Pseudonym> And it was in the same lab.
17:25:14 <clausen> http://www.schizomaniac.net/haskell.html
17:25:19 <clausen> ^ smerdyakov's #haskell ban petition page
17:25:41 <Pseudonym> The main problem with Common Lisp, I think, is that it's actually about 2.5 Lisp variants cobbled together.
17:25:48 <Pseudonym> There's no rhyme or reason to the library.
17:25:55 <ibid> cleverdra: i'm on orkut, i know what it is ;)
17:25:56 <Riastradh> Yup.
17:25:58 <Pseudonym> Which makes sense, when you consider the amount of legacy code which had to be ported.
17:26:05 <Pseudonym> But it's still ugly.
17:27:45 <cleverdra> Heffa - I don't really know, except that orkut's model of 'friendship' disagrees with mine.
17:27:51 <shapr> there are some factual errors on Smerdyakov's ban petition page. I very specifically banned him because his behaviour was trollish.
17:27:56 <Heffalump> yeah, it does with mine too.
17:28:24 <Riastradh> shapr, there are factual errors on everyone's part.
17:28:27 <shapr> Some people complained to me in private message, and one newbie who had just joined the channel actually said he wouldn't come back because of Smerdyakov..
17:28:41 <shapr> yah, reality is always subjective.
17:28:43 <Heffalump> shapr: if you want to have the argument, I suggest you just write the justification he requests.
17:28:52 <Riastradh> IRC politics are no fun.
17:29:26 <shapr> I don't want to have the argument, I spent hours trying to explain this to him in private message, and he has spent hours trying to convince me that I am wrong.
17:30:03 <Heffalump> well, as I've already said, it needs to be out in the open to be acceptable to others
17:30:05 <shapr> I suggested to him that he invite people to #sml
17:31:15 <shapr> Smerdyakov is the founder of #sml.
17:32:47 <Heffalump> It's up to you whether you provide the justification in the form he requests or not. I will remain unhappy unless you do so. I don't see any point in continuing the discussion in any substantially different form, as you seem to be trying to do now, however.
17:34:31 <Riastradh> shapr, leave all past problems with him behind; next time a newbie complains, request that the newbie express his claims directly to the channel.
17:34:50 <shapr> that newbie who left did express himself directly to the channel.
17:34:58 <Riastradh> Got a log?
17:35:08 <shapr> not handy, but I'll grep for it
17:35:17 <shapr> it's one of the homework discussions
17:35:52 <Heffalump> the justification requested could presumably include appropriate hyperlinks (pity the logs don't have anchors)
17:36:07 <Heffalump> and you could excerpt them.
17:36:24 <Heffalump> If you're going to go to the trouble of grepping, you might as well do that anyway.
17:36:55 <shapr> well, I'll think about writing up a justification page, but I'm not very motivated because I've used up so much time on this already. I have real productive work to do :-)
17:37:09 <Riastradh> shapr, just find the log, please.
17:37:32 <Heffalump> I could probably find it fairly fast, hangon.
17:39:46 <Heffalump> oh, maybe not.
17:40:04 <Heffalump> http://tunes.org/~nef/logs/haskell/04.01.15 at 11am and before is when he got banned, though.
17:46:20 <shapr> Riastradh: sure, I'll find the logs, but I'll do it in my copious free time, like maybe this weekend.
17:47:11 <Riastradh> shapr, stalling will only further the duration of IRC politics, a curse which I've had all too much experience with.
17:49:52 <shapr> anyways, has anyone tried HaskellDB on Debian?
17:50:16 <Heffalump> why on Debian?
17:51:26 <shapr> because I'm still fixing my postgresql config, and was wondering if anyone has gotten there before me :-)
18:49:26 <Pseudonym> @arr
18:49:27 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
18:49:34 <Pseudonym> Oh, I like that one.
18:51:12 <Riastradh> Oh, come on, that's just a cheap John Wayne ripoff.
20:04:26 <stepcut> @arr
20:04:26 <lambdabot> Ahoy mateys
20:04:32 <stepcut> Ahoy!
20:07:49 * stepcut reads about arrows
20:08:04 <Riastradh> stepcut: http://www.flightlab.com/~joe/hxml/arrows.html
20:08:17 <Riastradh> That page is _MUCH_ easier to understand than Hughes' paper.
20:11:34 <stepcut> thanks, hughes has not master the difficult art of technical writting
20:12:01 <stepcut> though he is still better than me at it
20:12:19 <Riastradh> 'Than _I_,' stepcut, not 'than me.'
20:12:46 <stepcut> see!
20:20:23 <stepcut> or perhaps I should say: QED
20:20:33 <Riastradh> Spell it out!
20:21:18 <ibid> "mastered" instead of "master" :)
20:25:21 <Pseudonym> I don't like copulative verbs.  They're an inconsistency with no purpose.
20:25:40 <Pseudonym> stepcut, stand up to the language oppressors!
20:26:27 <stepcut> don't you be oppressing me!
20:26:34 <stepcut> its my language too!
20:26:34 <ibid> copulative verbs?
20:26:50 <stepcut> like f*ck?
20:27:07 <cleverdra> stepcut - grammatical quirks aside, you should probably spell it "writing" and "it's".
20:27:13 <Pseudonym> @wn copula
20:27:14 <lambdabot> *** "copula" wn "WordNet (r) 2.0"
20:27:14 <lambdabot> copula
20:27:14 <lambdabot>      n : an equating verb (such as `be' or `become') that links the
20:27:14 <lambdabot>          subject with the complement of a sentence [syn: {copulative},
20:27:15 <lambdabot>           {linking verb}]
20:27:17 <lambdabot>      [also: {copulae} (pl)]
20:28:20 <stepcut> cleverdra: my spelling and grammar usage has been extra poor today -- probably because I am sick :p
20:28:39 <stepcut> maybe erc needs a built-in spelling and grammar checker :)
20:28:50 <stepcut> and I don't mean the user!
20:30:29 <Pseudonym> The user isn't built in.
20:31:45 <stepcut> Pseudonym: true, I think it's a more symbiotic relationship...
20:54:40 <ibid> Now buy this great IRC client, with BUILT IN USER!
20:55:17 <ibid> No more wasted evening in IRC, the client IRCs FOR YOU!
20:55:22 <ibid> evenings, too
20:58:48 <emu> `is' is the copula
21:00:47 <stepcut> ibid: kinda like VixenLove for emacs?
21:00:48 <cleverdra> ibid - oh, please don't actually use of those.  I started using one of those on a monday, sleeping in my extra time -- and by friday I had two legal 'mail-in' wives and a G-line from EFnet.  I hadn't even gone to EFnet for over a year, then!
21:01:14 <stepcut> http://www.vixenlove.com/Vixen/vixen.php
21:04:09 * ibid has no intention of using prentend-bots on irc
21:11:25 <stepcut> mmmm. tex
21:28:43 * andersca boings
22:00:10 <stepcut> ahhh!
22:00:25 <stepcut> arrows hurt my head
22:04:58 <Cale> perhaps you need this then: http://store.yahoo.com/greatsword/chainmailcoif.html
22:06:20 <durnew> heh, there's gonna be a recount in oklahoma
22:06:25 <durnew> 2000 all over again
22:12:17 <stepcut> ok, i still don't quite understand what the type signature means: arr :: (b -> c) -> a b c
22:14:26 <stepcut> or something like: type Whee a b = a b
22:16:56 <ozone> hi, any VLC Mac OS X coders here?
22:17:18 <ozone> i'm trying to design an app with VLC which has the video output inside one window
22:17:31 <ozone> i.e. one window has both the controller widgets (play/pause buttons, etc) and the video output
22:17:51 <ozone> and would like some advice on refactoring the VLCWindow/VLCControllerWindow/etc classes before diving in the deep end :)
22:21:10 <shapr> stepcut: it means, arrows are a generalization of functions
22:21:28 <andersca> shapr!
22:21:33 <shapr> andersca!
22:21:36 * shapr hugs andersca 
22:21:44 * andersca ghc shapr
22:21:53 <shapr> haha!
22:23:02 <stepcut> shapr: I don't really understand what the type 'a b c' means...
22:23:04 <shapr> stepcut: the arr combinator takes a function from type b to type c, and returns an arrow from b to c
22:23:45 <shapr> stepcut: do you have ghci handy?
22:23:50 <stepcut> yes sir!
22:24:08 <shapr> ok, do ":m + Control.Arrow" to load the arrow stuff into scope
22:24:17 <shapr> then :t show
22:24:24 <shapr> then :t arr show
22:24:55 <shapr> show transforms something into a string
22:25:39 <stepcut> so, what about my contrived example: type Whee a b = a b
22:25:51 <shapr> you can lift show into an arrow with arr show, then you have an Arrow a that transforms an instance of b (as long as they're instances of Show) into a String
22:26:54 <shapr> I don't understand your example.
22:27:07 <stepcut> me neither :) but haskell is happy to compile it
22:27:12 <shapr> :-)
22:27:18 <ozone> err
22:27:24 <ozone> i just realised i typed all that in the wrong window
22:27:25 <ozone> that was clever
22:27:26 <shapr> ozone: no, it's arr ;-)
22:27:35 <shapr> @arr
22:27:35 <lambdabot> This is the END for you, you gutter-crawling cur!
22:27:49 <shapr> g'day ozone 
22:27:56 <Pseudonym> @(>>>)
22:27:56 <lambdabot> Sorry, I don't know the command "(>>>)", try "lambdabot: @listcommands"
22:27:56 <stepcut> how would I write a value of type 'Whee a b' ? is that even possible?
22:28:04 <shapr> have you seen Hampus Ram's extension of your loader?
22:28:05 <Pseudonym> lambdabot is not fully Arrow-compliant
22:28:09 <ozone> g'day
22:28:29 <shapr> oh, I think I may have already told you about it before.
22:29:00 <shapr> mmm, fish skeleton combinator >->>>O>
22:30:24 <stepcut> hehe
22:31:25 <shapr> so, you mean Whee represents an arrow that goes from a to b?
22:31:36 <stepcut> no, no arrows at all. 
22:32:24 <stepcut> I just don't understand what it means when you have a bunch of type variables in a row
22:32:51 <shapr> you mean, what does the  -> a b c part of arr do for you?
22:32:52 <Pseudonym> It's no different in principle from having a bunch of identifiers in a row.
22:32:53 <Pseudonym> f x y
22:33:09 <Pseudonym> It just means that the first identifier, f, must have a function type.
22:33:32 <Pseudonym> Type are "typed" similarly to variables.  The types of types are called "kinds".
22:35:52 <stepcut> sharp: yeah, what does the '-> a b c' mean
22:37:43 <shapr> the a is an arrow, an arrow represents a really general idea of a function.
22:38:24 <shapr> so, it says "you get back from this, a function that takes something of type b, and gives something of type c"
22:41:56 <stepcut> how is that different than '-> (b -> c)'
22:50:48 <shapr> it's not very different actually
22:51:05 <shapr> it's just wrapping up the '-> (b -> c)' part into a datatype.
22:51:10 <shapr> that datatype is the arrow.
22:51:25 <Pseudonym> It's kind of like how monads wrap the concept of a "value".
22:51:48 <Pseudonym> IO a is the I/O computation that returns a value of type a.
22:51:58 <Pseudonym> The monad wraps the "a".
22:56:22 <shapr> so I guess the next question is, what's the point of wrapping up a function?
23:06:33 <Pseudonym> Must away.
23:06:35 <Pseudonym> Nytol!
23:31:22 <stepcut> data Whee z a b = Whee (a -> z b)
23:33:21 <stepcut> I am starting to understand what that means
23:34:46 <stepcut> in that case, z is something like: data Bork a = Bork a
23:35:14 <stepcut> Whee (\x -> Bork x)
23:56:29 <shapr> bonjour kowey 
23:59:10 <kowey> bonjour shapr, morning everyone
