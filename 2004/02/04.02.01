00:56:41 * cleverdra continues to try and compile Q.
01:49:43 <Maddas> Using rexes to parse things is considered bad, isn't it?
01:50:53 <andersca> depends what you want to do
01:51:16 <cleverdra> If by 'rexes' you mean 'regular expressions', yes.  A proper parser will generally do a better job.
01:51:42 <andersca> and you can't parse everything with regexps
01:51:52 <andersca> a^n b^n comes to mind
01:51:54 <Maddas> err, regexes, sorry.
01:51:54 <cleverdra> Why not use write one in Haskell? =)  We have many fine libraries for that.
01:52:33 <Maddas> cleverdra: I'm not writing one, I was just being told that not using regular expressions to parse things is dumb, and something I read on hawiki came to mind :-)
01:53:29 <cleverdra> maddas - a curious assertion.
01:53:31 <Maddas> cleverdra: I do plan to use a monadic parser combination someday
01:54:16 <Maddas> First or latter?
01:54:36 <cleverdra> First.  The one with the 'to be' verb.
01:54:50 <Maddas> Ok.
04:56:05 <emu> Maddas: regular expressions are often used in lexers.  but proper parsers are a step above the capabilities of a regex
06:02:53 <swisscheese> Hi all - could someone lead me to a site with some examples of filling trees?
06:22:30 <TripleDES> hi
06:24:14 <Lemmih> Yo TripleDES
06:58:38 <swisscheese> Anyone know of any channels where I can get some novice help?
06:59:48 <swisscheese> I only have ~2 pages of code under my belt.
07:05:09 <bring> this channel :)
07:06:23 <swisscheese> I don't seem to be getting answers here - I asked for any URLs showing examples of filling recursive data types.
07:08:08 <bring> people might be busy, or not have any URLs to give :)
07:08:52 <bring> is there something specific you want to know?
07:08:53 <swisscheese> Yes, I suppose I should have considered that.
07:10:49 <swisscheese> How to end recursion in defining a tree.
07:11:55 <swisscheese> I'm trying something like the knights-tour and want to end the tree to avoid revisits.
07:14:10 <bring> so you want to have a tree without duplicated subtrees?
07:14:34 <swisscheese> Correct.
07:16:16 <bring> so before inserting a node in any subtree, you want to check if that node already exists somewhere in the whole tree
07:16:22 <bring> ?
07:16:53 <swisscheese> Correct.
07:17:06 <bring> hmm, I think someone asked about the same problem yesterday
07:17:24 <swisscheese> I was discussing the problem with Darius.
07:17:30 <bring> ah, ok
07:17:37 <bring> did it help?
07:18:06 <swisscheese> To some extent but still stuck :-(
07:19:26 <swisscheese> He said to pass around a list of visited positions but this is FP not C.
07:20:40 <bring> :)
07:22:00 <bring> is there an ordering on your positions?
07:22:23 * bring thinks that maybe that should be ordering of
07:23:00 <bring> if so, you could pass them around in another tree
07:23:06 <bring> to make lookup faster
07:24:40 <bring> or is it the idea of passing them around at all that is bothering you?
07:24:41 <swisscheese> Not sure what you mean. There is a tree of positions where a child is one move away from a parent.
07:25:10 <swisscheese> No, the passed positions have no order.
07:25:43 <swisscheese> Creating the list of possible positions has the same problem of termination.
07:25:59 <bring> ?
07:26:28 <Igloo> You don't want a list of possible positions, you want a list of positions already in the tree
07:26:35 <bring> right
07:26:40 <swisscheese> Actually the problem reduces to creating a finite list of possible positions.
07:27:15 <Igloo> When you say this is FP not C, how would you do it in C?
07:27:22 <bring> and previous positions should not belong to that set?
07:28:00 <swisscheese> The list of possible postions has no sense of previous.
07:28:21 <swisscheese> Just a list of all possible board states without dupes.
07:29:19 <swisscheese> i.e. nub (infiniteListOfPositions)
07:30:11 <bring> if you write a function addPos :: [Pos] -> [Pos] that adds one position that is not in the given list to the list and returns it
07:30:31 <bring> then you can repeat that until it doesn't add a position
07:30:44 <bring> probably no the most efficient way of doing it
07:34:14 <bring> you might want ot use a tree instead of a list, for example
07:34:48 <swisscheese> Not sure how to terminate such a recursion for addPos
07:36:50 <swisscheese> Igloo - In C I would just check if a new child is already in the tree.
07:37:47 <bring> how to make addPos terminate, or how to know when to stop calling addPos?
07:38:04 <swisscheese> same thing to me.
07:38:42 <Igloo> OK, so suppose you pass around a list fo things in the tree. Before adding something you check to see if it is in the list and, if not, add it to both the tree and the list?
07:40:04 <swisscheese> Yes but I'm having trouble doing that in a FP framework - maybe it's just that I'm only a few pages of code into Haskell.
07:41:57 <Igloo> The simple way is to add a [Position] as an argument to each function and have a [Position] returned by each function
07:45:04 <swisscheese> OK, let me play with that a bit.
08:00:46 <swisscheese> Igloo - Do you suggest instead of
08:00:46 <swisscheese> data Tree = Node Puzzle [Tree]
08:00:46 <swisscheese> use:
08:00:46 <swisscheese> data Tree = Node Puzzle [Tree] [Puzzle]
08:00:46 <swisscheese> since I pass the Tree around?
08:00:47 <swisscheese> But it seems rather inefficient.
08:01:36 <Igloo> That would do rather than explicitly passing it around as a separate argument. Why is it more inefficient than looking for it in the tree in the C version?
08:01:58 <Igloo> Don't forget only a pointer will actually be passed around, you won't be copying the entire list each time or anything
08:02:53 <swisscheese> OK - the internals are a bit beyond me but I sort of understand. OK.
08:04:01 <phubuh> since the data can't be modified, there's hardly ever a point to pass large data structures by value
08:04:26 <swisscheese> OK
08:06:47 <Igloo> Once you have this working, if you make Puzzle an instance of Ord (probably just a matter of deriving Ord on any datatypes of your own you declare) then you can have a Set Puzzle (import Data.Set) instead of [Puzzle] for logarithmic rather than linear lookups. Another thing you could do is to use a state monad to carry the list/set of Puzzles around, but that's less interesting if it's part of the Tree type, and many people also find monads a large conceptual
08:08:50 <swisscheese> Thanks but let's go slow ;-)
08:09:31 <swisscheese> I'm coding now - back in a few...
08:09:47 <Igloo> Sure - just thought I'd say it now while it was in my mind  :-)
08:37:10 <shapr> what did I miss?
08:37:44 <Heffalump> 42.
08:38:07 <shapr> hi Heffalump!
08:38:09 * shapr boings
08:38:15 * shapr DCCs hunny to Heffalump 
08:39:41 <shapr> hey, any elispers here?
08:40:05 <shapr> Simon Marlow is the current maintainer of haskell-mode, but as I understand it, he's trying hard to change that.
08:40:14 <Heffalump> did you say elithpers?
08:40:18 * shapr grins
08:40:19 <Heffalump> s/say/thay/
08:40:25 <shapr> Yerth Marthter
08:40:25 <Heffalump> s/ers/erth/
08:40:25 <Matt-W> I probably would've learned elisp but I discovered vim first
08:40:25 <Heffalump> gah
08:40:38 <shapr> Igorth are great
08:40:55 <Heffalump> matt-w: hello. You're a wonky person, aren't you?
08:41:18 <shapr> welll, I think elisp is not that exciting, even though I've written some.
08:41:23 <Matt-W> Heffalump: yes
08:41:29 <shapr> what's wonky?
08:41:33 <Heffalump> the world is too small.
08:41:38 <Heffalump> www.wonky.org.uk
08:41:45 <Matt-W> the world is very small indeed
08:41:52 <shapr> oh, neat
08:42:18 <Matt-W> I discovered that when I joined orkut yesterday
08:42:42 <Heffalump> I think this weekend is the weekend for the entire world to join orkut.
08:42:52 <shapr> I'm shae at webwitches nospam com on orkut
08:43:09 <shapr> yes, six or so people just joined from #haskell
08:43:11 <shapr> including Heffalump 
08:43:24 <shapr> phubuh started the Haskell group
08:43:26 <shapr> yay!
08:43:32 <Matt-W> Oh I must join that then
08:44:02 <Heffalump> oh, I didn't link his real name to him
08:44:30 <shapr> Mr Brockman
08:44:47 <Heffalump> yeah, I realise that now
08:45:11 <shapr> yah, we need better name <-> nick mapping on HaskellIrcChannel
08:45:50 <shapr> gutenabend cptchaos 
08:46:13 <cptchaos> shapr: good evening
08:46:21 <shapr> wie geht es?
08:46:47 <cptchaos> shapr: gut, lernst du deutsch?
08:47:10 <shapr> nah, but my woman speaks it every day on the phone, so there's some sort of osmosis...
08:47:35 <shapr> plus I'm learning swedish, and the similarity to deutsch means I'm absorbing more german.
08:47:56 <cptchaos> shapr: ok :-)
08:48:05 <shapr> how's code?
08:48:58 <cptchaos> well, good started a new projetct do try some ideas about writing fast lazy evaluation in asssembly 
08:49:09 <Matt-W> hmm, I'd like to learn Swedish
08:49:10 <Matt-W> and Japanese
08:49:16 <Matt-W> too many languages, too little time...
08:49:42 <shapr> Swedish is nifty.
08:50:00 <shapr> okay, here it is: http://www.haskell.org/hawiki/HaskellChannelPeople
08:51:04 <shapr> I'm going to link in the HaskellUserLocations page as soon as I remember its name.
08:51:16 <cptchaos> :-)
08:51:40 <shapr> oh, that *is* its name.
08:51:40 <shapr> doh
08:52:09 <Matt-W> Of course I don't have a user page to link to yet
08:52:14 <Matt-W> but I'm on the list now
08:52:24 <Matt-W> I really should sort out that patch for haddock I was working on
08:52:25 <shapr> you could create a user page if you like.
08:52:28 <shapr> what patch?
08:52:40 <Matt-W> I was working on man page output
08:52:43 <shapr> oh neat
08:53:00 <shapr> my recent haddock trick: http://www.scannedinavian.org/AvianWiki/HaddockTest
08:54:46 <Matt-W> wiki haddock!
08:54:49 <shapr> yup
08:55:04 <shapr> dynamically generated from the stuff inside {{{#!haddock }}}
08:55:11 <Matt-W> cool
08:55:19 <shapr> only works for one 'file' though
08:55:25 <shapr> module/whatever
08:56:45 <shapr> could be handy for previewing or editing your haddockumented code.
08:57:26 <Matt-W> It's a nice thing
08:57:28 <Matt-W> I like
08:57:40 <shapr> the code is at the bottom if you want to stick into a MoinMoin wiki of your own.
08:57:56 <Heffalump> I want moinmoin to support inline TeX
08:58:01 <shapr> I think it can
08:58:12 <shapr> I was wondering if that would be a good way to turn .lhs files into haddocks
08:58:24 <shapr> or at least, web-based docs
08:58:24 <Heffalump> it can?
08:58:26 <Heffalump> how?
08:58:40 <shapr> I don't know how, but I can find out.
08:59:43 <shapr> anyways Heffalump, what do you think of submitting unit tests via wiki for multi-developer projects like lambdabot?
08:59:58 <shapr> maybe I've already asked you about this, it's been bouncing around in my head for many months.
09:00:28 <Heffalump> I don't see the point in doing it via wiki. It's too free-form.
09:00:47 <Heffalump> surely darcs is the way to do it
09:01:01 <shapr> check this out: http://fit.c2.com/wiki.cgi?SimpleExample
09:01:19 <shapr> near the bottom there's a http:run.cgi link
09:01:37 <Heffalump> that's all very well for simple cases
09:01:50 <Heffalump> maybe it'd work if you made a wiki page that had the right structure
09:01:53 <shapr> supposedly it works well for more complicated cases also
09:01:58 <shapr> that's part of my question also :-)
09:02:19 <shapr> the question I had yesterday when you weren't here was "is darcs cgi or haddock via moinmoin a better way to do this?"
09:02:22 <shapr> or something else entirely?
09:02:34 <Heffalump> I don't see how haddock helps.
09:02:48 <shapr> it already pulls significant stuff out of comments
09:02:56 <shapr> I've seen unit tests in comments before
09:03:09 <shapr> I've seen some that were executed when the code was compiled
09:03:12 <Heffalump> but to produce documentation, not tests
09:03:14 <shapr> maybe a Template Haskell harness?
09:03:31 <Heffalump> I think you're just throwing in ideas without thinking how precisely they'd work :-)
09:03:37 <shapr> sure, I agree
09:03:44 <Heffalump> and I don't have the energy to think through the obvious flaws for you
09:03:50 <shapr> ok, no worries
09:04:08 <shapr> what's obvious to me and what's obvious to other people is rarely the same thing :-)
09:04:21 <shapr> that's why I like to bounce ideas
09:05:44 <shapr> ok, I found a latex.py processor for MoinMoin
09:37:12 <Lemmih> Is it normal that the gtk2 bindings for Haskell are _really_ unstable? (the demo programs crashes when they are resized)
09:37:40 <shapr> it's not normal
09:37:43 <shapr> you should report that as a bug.
09:37:45 <Igloo> The gtk+hs ones worked fine for me (except the missing bits). Never tried gtk2hs
09:39:07 <Lemmih> I could compile gtk+Haskell. (ghc 5.04)
09:40:23 <Lemmih> I get this message: "GdkVisual.chs:109: Variable not in scope: `unsafePerformIO'".
09:41:25 <Lemmih> arhg. s/could/couldn't/
10:20:02 <shapr> Heffalump: http://www.scannedinavian.org/AvianWiki/LatexTest
10:21:11 <Heffalump> COOL!
10:21:23 <Heffalump> Thanks a bunch. I owe you lots of silly question answering :-)
10:21:33 <shapr> :-)
10:22:10 <shapr> next I want to persuade the HaWiki maintainer to upgrade to the latest moinmoin and install the haddock and latex processors.
10:22:39 <Heffalump> you've just made it feasible for my research group to use a MoinMoin for stuff.
10:27:28 <shapr> I had to hack on the processor to get it working with the moin debs.
10:28:25 <shapr> I'll put up the working latex.py source on that page
10:30:59 <eixei> hi
10:31:02 <shapr> hello
10:32:33 <shapr> hey, I'm collecting/polling for bugs/errors/wishlist items for haskell-mode in emacs if anyone has any.
10:33:43 <Igloo> There were some in the Debian BTS last I looked
10:34:35 <shapr> "Forwarded to lapalme@iro.umontreal.ca; 4 years and 128 days old" heheh
10:35:04 <shapr> cool, a bug filed from bluespec.com :-)
10:35:42 <eixei> sahpr, I was just wondering, your nick seems familiar to me, were you on the duffs or the netstat irc servers when they still existed?
10:35:47 <eixei> *shapr
10:36:06 <shapr> which years?
10:36:21 <eixei> hmm, like 1-2 years ago
10:36:51 <shapr> doesn't sound familiar, but I could be wrong.
10:37:21 <eixei> :-)
10:38:33 <shapr> I spent most of my irc time on this network or EFNet before that.
10:38:45 <shapr> before that, I don't really remember, though I know I got on irc a very long time ago.
10:39:16 <eixei> lol, I see
10:39:18 <shapr> Heffalump: are you done editing LatexTest?
10:40:36 <shapr> I think I got on irc in 1989, I vaguely recall that it was a new and cool thing to use.
10:41:07 <eixei> wow, you've really been a long time online then :-)
10:41:44 <Lemmih> Heh I was 2 years old in '89 :)
10:41:51 <shapr> yes, I got a modem in 1988 and now it's eaten up the rest of my life. :-P
10:42:06 <shapr> Lemmih: yow!
10:42:28 <Darius> shapr: Install XYpic and hack the #!latex extension to load it then you can have commuting diagrams on your wiki.
10:42:51 <shapr> cool! what's a commuting diagram?
10:43:09 <Darius> The diagrams you always see in category theory texts.
10:43:21 <shapr> oh, that would be very spiffy
10:43:43 <Lemmih> Can anyone show me how to use the toInt function?
10:43:47 <Darius> XYpic can also do a whole lot of other things.
10:43:52 <Darius> fromIntegral x
10:44:24 <Darius> @type toInt
10:44:31 <shapr> @hello
10:44:35 <shapr> uh oh
10:44:44 <Lemmih> like: fromIntegral 'A' ?
10:45:12 <shapr> interesting "Exception: connect: does not exist (Connection refused)"
10:45:22 <Darius> @type toInt
10:45:22 <lambdabot> toInt :: Integral a => a -> Int
10:45:35 <Darius> @type fromIntegral
10:45:35 <lambdabot> fromIntegral :: (Integral a, Num b) => a -> b
10:45:49 <Lemmih> yeah but hugs says: "ERROR - Illegal Haskell 98 class constraint in inferred type
10:45:50 <Lemmih> *** Expression : fromIntegral '0'
10:45:50 <Lemmih> *** Type       : Integral Char => Integer"
10:45:56 <Darius> Anyways, Char isn't an instance of Integral.
10:46:07 <Darius> ...as the error message says.
10:46:28 <shapr> does XYpic have a deb?
10:46:30 <Darius> Maybe... Hugs sucks.
10:46:57 <Darius> shapr: I haven't the foggiest.  Doesn't TeX stuff have it's own distribution thing.
10:47:15 <shapr> lots of TeX debs
10:47:21 <Riastradh> TeX has CTAN.
10:47:26 <shapr> too many to easily examine
10:47:38 <shapr> zsh/4 5049 % apt-cache search latex|wc -l
10:47:38 <shapr> 168
10:50:25 <shapr> if you find an XYpic deb (or other TeX deb you want), I'll install it on AvianWiki
10:52:12 <Taaus> shapr: Are you sure XyPic isn't installed along with the rest of (te)tex? It was like that on my system (which is Gentoo, but still...)
10:52:38 <shapr> I know almost nothing about TeX
10:55:08 <Darius> There should be an XYpic deb.
10:55:32 <Darius> And as Taaus said, I wouldn't be surprised if it came installed.
10:56:23 <shapr> you could try putting in a commuting diagram
10:59:41 <Darius> I did.  But it won't work because you need to add options to the part of the file between \documentclass and \begin and #!latex puts that part in itself.
11:00:49 <shapr> what needs to be added?
11:01:22 <Darius> \usepackage{xy} after the \documentclass line should work.
11:02:30 <shapr> does that fix it?
11:03:00 <Taaus> Does that load the xymatrix environment?
11:03:48 <Darius> Taaus: I think that loads everything.
11:03:56 <shapr> does the page look right now?
11:04:11 <Taaus> I thought that was \usepackage[all]{xy}, Darius :)
11:04:50 <Darius> Maybe
11:05:11 <Darius> I explicitly load what I want and haven't been messing with it lately.
11:05:25 <Darius> shapr: And no it didn't appear to work, but try what Taaus says.
11:06:18 <Taaus> If [all] works, you can whittle it down to [matrix] (I think) afterwards.
11:07:09 <Darius> I think the minimum I needed was [matrix,arrows,curve], but there isn't too much of a reason not to just load everything.
11:07:30 <shapr> I think it caches the PNGs according to the hash of the source text, can you change the source text so it will re-render the images?
11:07:47 <shapr> I've changed it to \usepackage[all]{xy}
11:10:19 <shapr> hm, looks like it's only text now.
11:10:24 <Taaus> Hmm. Now it breaks in new and exciting ways.
11:10:31 <shapr> fun fun fun
11:10:47 <shapr> ok, switched from all to matrix
11:11:31 <shapr> oh, I wonder if I need to escape [ chars
11:11:32 <Taaus> Didn't make any difference.
11:12:24 <shapr> hrm
11:12:30 <Taaus> Is there anywhere you can see the log tex produces?
11:12:50 <shapr> aha
11:12:54 <shapr> xy.sty not found
11:13:00 <Taaus> Ahhh.
11:13:07 <shapr> does that mean xy is not installed?
11:13:08 <Taaus> Heh.
11:13:12 <Taaus> Yes.
11:13:27 <shapr> any idea if xy is in one of the zillion TeX debs?
11:14:05 <shapr> ok, I've removed the usepackage for now
11:14:19 <Taaus> It appears to exist as a deb. Try apt-getting xypic.
11:15:07 <shapr> maybe it's not in the standard debian archive?
11:15:33 <Taaus> Dunno.
11:36:20 <shapr> looks like xypic was in debian 1.1
11:36:43 <eixei> bye
11:44:22 <Darius> I wouldn't be surprised if your TeX package has a utility to download and install packages from CTAN.
12:02:52 <swisscheese> -- I guess I'm losing it. I can't see why cracks of "ab" for example returns []
12:02:52 <swisscheese> cracks :: [Char] -> [Bool]
12:02:52 <swisscheese> cracks (x) = []
12:02:52 <swisscheese> cracks (x:xs) = (x == (head xs)) : (cracks xs)
12:03:27 <Maddas> swisscheese: "ab" is not an array
12:03:35 <Riastradh> swisscheese, what does this expression evaluate to?
12:03:35 <Cale> huh?
12:03:49 <Cale> @type "ab"
12:03:49 <lambdabot> "ab" :: String
12:03:51 <swisscheese> Should be a list of bools where letters change.
12:03:53 <Maddas>  err
12:03:55 <Riastradh> case [1,2,3] of x -> x; x:xs -> [4,5,6]
12:03:55 <Maddas> never mind, sorry.
12:04:04 <Maddas> I should read what channel I'm in before typing :-)
12:04:31 <Riastradh> [1,2,3] or [4,5,6]?
12:05:23 <swisscheese> ?
12:05:53 <Riastradh> swisscheese, enter [[case [1,2,3] of x -> x; x:xs -> [4,5,6]]] into a Haskell REPL and tell me what the result is.
12:06:34 <swisscheese> Result is [[[1,2,3]]] 
12:06:34 <Cale> swisscheese: what do you want cracks to return?
12:06:47 <swisscheese> [True,False]
12:07:09 <swisscheese> for abb
12:07:22 <Riastradh> swisscheese, now remember that your definition is equivalent to:
12:07:30 <Riastradh> cracks a =
12:07:31 <Riastradh>     case a of
12:07:31 <swisscheese> rather [False,True]
12:07:37 <Riastradh>         x -> []
12:07:49 <Riastradh>         x:xs -> (x == (head xs)) : cracks xs
12:08:11 <Riastradh> "ab" matches...which clause?
12:08:25 <swisscheese> the second
12:08:32 <Riastradh> Really?
12:09:09 <Cale> swisscheese: the problem is that the pattern x will match anything
12:09:11 <Riastradh> Try it; enter this into a Haskell REPL:   case "ab" of x -> True; x:xs -> False   (the True and False just for simplicity's sake)
12:09:43 <swisscheese> I guess your point is I have the pattern matching reversed?
12:09:56 <Riastradh> Yes.  Pattern matching clauses are stepped through sequentially.
12:10:02 <Cale> or better yet, make the pattens not overlap
12:10:17 <Cale> replace x with [x]
12:10:18 <swisscheese> How to not overlap?
12:10:35 <Cale> er
12:10:54 <Cale> and (x:xs) with (x:y:xs)
12:11:44 <swisscheese> OK, thanks.
12:12:12 <Cale> then you can refer to what used to be head xs directly
12:16:14 <cptchaos> uff, my connection is flawfull 
12:17:56 <cptchaos> does anyone know a Haskell parser like Language.Haskell.Parser, that supports hirachical modules and the ffi syntax?
12:24:40 <shapr> there's talk of exposing GHC's internal structures for IDEs to access
12:24:55 <shapr> but I don't know if anything already exists that handles hierarchical modules and ffi
12:26:40 <cptchaos> Language.Haskell.Parser already parses hirachical modules, I think I will try to extend it for ffi
13:19:17 * stepcut attempts to build ghc-cvs
13:20:00 <Igloo> Why, OOI?
13:20:18 <stepcut> 6.2 is just too buggy
13:20:36 <Igloo> !
13:21:00 <Igloo> what bugs are causing you grief?
13:21:11 <stepcut> well, template haskell in 6.2 *IS* buggy. Also, I want the latest version of hopengl
13:21:15 <Igloo> If you really do need to build from CVS, I suggest the stable cranch rather than the HEAD
13:21:45 <Igloo> Oh, well, fair enough
13:21:54 <Igloo> You probably do need the HEAD to make a difference there
13:22:18 <stepcut> yeah... such is life
13:22:30 <stepcut> the new opengl bindings are nice
13:23:02 <Igloo> What changed?
13:24:07 <stepcut> between 6.2 and cvs head, its mostly cleanup stuff, but between the old standalone hopengl and whats in the source tree -- quite a lot
13:24:29 <stepcut> he basically rewrote everything
13:24:40 <Igloo> Ah, right, I thought you meant in the head
13:24:54 * Igloo AFKs
13:29:42 <swisscheese> Bring - you still there? I made progress based on your suggestion but have a problem.
13:30:00 <swisscheese>  Prelude.!!: index too large  
13:30:00 <bring> I'm here
13:30:30 <swisscheese> Don't even know how to start dealing with that :-(
13:30:32 <bring> means that you went past the end of the list
13:30:38 <bring> for example:
13:30:46 <bring> Prelude> []!!4
13:30:49 <bring> Program error: Prelude.!!: index too large
13:30:52 <swisscheese> hmmmm
13:31:08 <bring> (or tried to go past the end, rather)
13:31:10 <apmuf> well, there is not fourth element, is there?
13:31:22 <swisscheese> Yes I get it.
13:32:33 <swisscheese> I use !! in a few places - why doesn't hugs give a little more detail.
13:33:31 <apmuf> it gives you the line number, doesn't it?
13:33:52 <swisscheese> No just "Program error: Prelude.!!: index too large "
13:34:00 <apmuf> mh
13:34:03 <apmuf> thats bad then
13:51:29 <swisscheese> Would the compiler be more informative?
13:57:08 <Cale> You might try ghci.
13:57:39 <Riastradh> You could probably find the code that defines (!!) and change it to give a more informative line number...
13:57:49 <Riastradh> s/line number/error message/1
13:58:33 <swisscheese> You mean modify prelude?
13:59:07 <swisscheese> Where is ghci?
14:00:39 <bring> ghci is an interpreter that is part of the ghc distibution, http://www.haskell.org/ghc/
14:02:38 <swisscheese> Is it easy to setup? Better than hugs?
14:04:48 <swisscheese> ?  s/line number/error message/1
14:11:57 <bring> if you use GHC, you can compile you program with -prof -auto-all and run it with +RTS -xc -RTS, says the GHC FAQ, haven't tried it
14:12:21 <bring> but you're probably better of tracing throught the logic of you program to understand where it goes wrong
14:13:10 <swisscheese> OK but can you explain Riastradh's comment?
14:13:29 <Riastradh> swisscheese, find Prelude.hs in Hugs's source and change the definition of (!!).
14:14:02 <swisscheese> Yes but how does one get the line number.
14:14:26 <Riastradh> Oh, that would be considerably more difficult.
14:14:47 <Riastradh> I was just suggesting changing it so it would print out its inputs for added information.
14:14:47 <swisscheese> Then what's the point?
14:14:57 <swisscheese> OK
14:15:57 <bring> well, one input would be [] :)
14:16:31 <Cale> might not be
14:16:41 <Riastradh> bring, only if the original input to (!!) was []; you could modify it to have an inner loop to preserve the original input and use that in an error message.
14:16:42 <bring> you're right, it's recursive
14:17:09 <bring> I thought it was defined in terms of something else
14:18:59 <bring> or you could use Debug.Trace.trace
14:19:52 <swisscheese> In hugs?
14:19:54 <emu> haskell vindaloo
14:22:09 <bring> yes
14:23:51 <swisscheese> ERROR - Undefined qualified variable "Debug.Trace.trace"  
14:24:07 <bring> Prelude> :l Debug.Trace
14:24:18 <bring> Debug.Trace> map (\x -> trace "hello" (x+1)) [1..5]
14:25:06 <swisscheese> ERROR - Undefined variable "trace"   
14:25:48 <bring> if you are loading a source file into hugs, put import Debug.Trace in it
14:26:03 <bring> what hugs version do you have btw?
14:27:01 <swisscheese> V6.12
14:28:14 <bring> hmm, usually it's something like "November 2003"
14:28:49 <bring> it shoud say when you start hugs
14:29:03 <swisscheese> oops - that was mirc!
14:29:14 <bring> :)
14:29:52 <swisscheese> Help About does not show a version!
14:30:50 <swisscheese> But the (c) is 2003
14:31:10 <swisscheese> Downloaded a few weeks ago.
14:31:54 <bring> ok, that should be fine, the latest release was November 2003
14:32:53 * bring needs to go to bed now
14:33:09 <swisscheese> Now I see on startup Nov 2003
14:33:19 <swisscheese> Thanks for your help Bring!
14:33:55 <bring> dunno if I was much help, but good luck anyway
14:39:25 <shapr> @yow
14:39:25 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
14:40:41 <liiwi> ello
14:41:00 * liiwi sips tea and rips his cd collection
14:41:09 <shapr> hi liiwi 
14:41:15 <shapr> I'm working
14:41:44 <shapr> one day I'll have a scheule based on a 24-hour cycle, but probably not this year.
14:42:36 <liiwi> I'd prefer 30+
14:43:24 <shapr> so would I
14:45:07 <Riastradh> Move to Ringworld.
14:45:26 <Riastradh> It's not crowded there at all, either, unlike Earth.
14:45:34 <Riastradh> And they've got this delicious root down underground in places.
14:47:20 <Riastradh> As well as a wicked cool transportation system.
14:50:13 * liiwi learns more about grammar in 15 minutes than he ever did during decade and half in school
14:50:44 <Riastradh> Quick!  Give an example usage of the subjunctive mood in the past-plurperfect tense!
14:52:40 <liiwi> *burp*
14:52:52 <ecraven> what language has a past-plusquamperfect?
14:53:05 <shapr> I think most of them do?
14:53:31 <shapr> hei Hipo, nice squirrel pix.
14:53:45 <Riastradh> Using the subjunctive mood in that tense would be _really_ weird...
14:53:46 <liiwi> http://www.geocities.com/takasugishinji/japanese/index.html <- cool site
14:54:22 <ecraven> neither german nor french have a *past*-plusquamperfect.. does english?
14:55:08 <shapr> plus quam perfect is "have had" right?
14:55:19 <shapr> "have x'ed" for any verb x
14:55:39 <ecraven> in german "habe gehabt" is perfekt, "hatte gehabt" is pqp
14:55:41 <liiwi> pluskvamperfekti
14:55:57 <ecraven> i'm not sure about english, 'had had' should be that..
14:56:43 <shapr> I had had that before.
14:56:47 <liiwi> hmm, only imported words in finnish can have q in them
14:57:06 <Hipo> shapr: Thanks. :P
14:57:20 <ecraven> liiwi: suomalainen oletko?
14:57:22 <shapr> how'd you get so close to the squirrel?
14:57:31 <shapr> puhutko suomea? ;-)
14:57:39 <shapr> minä olen americalainen.
14:57:41 <ecraven> ei puhun :) or something like that
14:58:00 <shapr> yah, me too
14:58:03 <ecraven> but i want to learn
14:58:07 <shapr> minä ei puhu suomea.
14:58:15 <shapr> wait
14:58:18 <shapr> en puhu
14:58:34 <shapr> I can't even pretend to speak finnish anymore.
14:58:50 <ecraven> :) it's an interesting language
14:58:59 <Hipo> shapr: It was so scared that I could actually touch it. :)
14:59:03 <shapr> wow
14:59:22 <shapr> but you still got it in many poses. I think that squirrel wanted to go to Hollywood.
15:00:43 <shapr> I'm having mental block on parsing mbox format in Haskell.
15:00:51 <shapr> I know, it's sooo simple, but I can't figure it out.
15:01:25 <liiwi> it's sooo easy to corrupt 
15:01:33 <liiwi> ecraven: joo, olen.
15:01:42 <shapr> it should be something like "find the first line that starts with "From " until you find another line that starts with "From " add these lines to an email"
15:02:18 * liiwi pats maildir
15:02:28 <shapr> I have a maildir parser in Haskell
15:02:37 <shapr> but mailmain archives are in mbox format
15:02:55 <liiwi> one more reason not to use mailman
15:03:04 <shapr> haskell.org uses mailman.
15:03:14 <shapr> I want to index their archives.
15:03:31 <liiwi> shapr: have I told you about EoC? http://liw.iki.fi/liw/eoc/
15:04:43 <shapr> doesn't help me parse mailmain archives :-P
15:04:52 <shapr> but I will consider using that in the future.
15:05:21 <shapr> I've sometimes wondered if Linus ever shows up on freenode.
15:05:47 <stepcut> good question
15:07:23 <swisscheese> OK, I can find a function to convert an Int to a String.
15:07:28 <swisscheese> can't
15:07:48 <Igloo> show
15:08:30 <liiwi> anyway, I'm off bedwards
15:08:31 <liiwi> nini
15:08:42 <stepcut> show is one of the top 10 reasons I like haskell better than ocaml
15:08:58 <Riastradh> Typeclasses in general.
15:09:03 <stepcut> yeah
15:09:11 <swisscheese> hmmmm thanks - don't know how I missed it!
15:09:16 <stepcut> and list comprehensions
15:09:50 <Riastradh> List comprehensions are silly: they apply _only_ to lists; they're completely inextensible; there are no array comprehensions, or set comprehensions, or finite map comprehensions, et cetera.
15:10:15 <stepcut> i think concurrent clean has array comprehensions
15:13:09 <det> SML + type classes would be nice
15:13:57 <shapr> oh, I've finally figured out a good internet currency, specifically e-beer.
15:14:44 <Riastradh> shapr, is it _totally_ anonymous & secure?
15:14:58 <shapr> no, but it gives you a nice buzz.
15:16:35 <liiwi> and is proven valuable every time you meet another person who owns you e-beers.
15:16:43 <liiwi> but now I'm off for real :)
15:16:51 <shapr> I think I owe liiwi some e-beers.
15:17:07 <shapr> and I owe his couch an e-beer also.
15:17:29 <shapr> (to be left nearby and later consumed by liiwi, not actually fed to the couch)
15:47:56 <cleverdra> mmm =)  I think Q satisfies fairly well my desire for a dynamically-typed 'Haskell'.
15:48:48 <Heffalump> riastradh: well, monad comprehensions exist
15:48:50 <Riastradh> cleverdra, uh, how about Scheme?
15:48:54 <Heffalump> but those don't help you with sets etc.
15:50:20 <shapr> what would a array/set/FM comprehensions look like?
15:50:48 <Heffalump> same as a list comprehension, basically
15:50:52 <cleverdra> Riastradh - er, what about it?  It differs in many more ways from Haskell than its having a dynamic type system.
15:51:05 <shapr> for an FM, you could just do fmToList
15:51:05 <Heffalump> but things like sets and FMs have a type constraint on the element type, which make monad comprehensions unusable
15:51:16 <Heffalump> that's inefficient and ugly
15:51:56 <shapr> it also sucks because FMs aren't ordered.
15:52:12 <Heffalump> errm, yes they are.
15:52:14 <Riastradh> cleverdra, different standard set of functions, different syntax.  What else?
15:58:19 <cleverdra> Riastradh - I find myself at a loss to argue with you, once again.  Why not ask about Erlang?  Or Perl?  These languages have an *entirely different* 'feel'.  I *don't* program Scheme in a similar manner to how I program Haskell.  I don't start a Scheme program by writing down type-definitions for how I expect to handle my data.  I don't write pattern-matching functions.  I don't make much use of currying.
15:59:30 <Riastradh> cleverdra,  there's nothing that _stops_ you from programming in Scheme like you program in Haskell.  If you _choose_ to program a different way, then of course it will seem different.
15:59:37 <cleverdra> Riastradh - likewise, I do many things in C that I'd never do in Haskell, such as write 2/3 of my program in the form of a user-editable 'configuration'.
16:00:03 <cleverdra> err, Schem.
16:00:07 <cleverdra> Scheme.  Blech.
16:01:22 <cleverdra> Riastradh - I could write Scheme in exactly the same manner as I'd write a C program -- but to what point?  I don't enjoy masochism, to avoid the most convenient manner of expression than a language gives me.
16:01:34 <cleverdra> Riastradh - hence the multiplicity of programming languages.
16:02:34 <Riastradh> cleverdra, what is inconvenient about writing Scheme like you write Haskell?
16:02:46 <shapr> I'd be happy to be a collection of programming idioms in Haskell, I bet I'd learn lots.
16:03:08 <Riastradh> The dynamic type system changes things drastically, as much of Haskell uses typeclasses, but that's a change you were _seeking_.
16:03:19 <det> shapr: I am personally happy being a human being
16:03:37 <shapr> er "to be" -> "to see"
16:03:38 <shapr> argh
16:05:05 <det> ;)
16:05:28 <cleverdra> OK, off to lunch.
16:06:05 <shapr> mm, kumquats are spiffy.
16:08:18 <shapr> Heffalump: how are finitemaps ordered?
16:08:35 <shapr> I couldn't find the efficient sets paper reference in the haddocks
16:08:39 <shapr> and I don't see it in the source.
16:09:07 <shapr> it seems that the keys must be Ord
16:09:49 <Heffalump> yes, precisely
16:09:54 <Heffalump> that way you get a balanced tree
16:10:21 <shapr> oh, I think tree doesn't translate into ordered in my head.
16:10:31 <shapr> I always think of a one-dimensional structure.
16:11:37 <shapr> oh, if you're worried about security in latex.py, it seems likely that someone could write some latex that would eat the other files in the wikipage data dir if they really wanted to...
16:11:46 <shapr> you could get around that by running latex as a different user probably
16:11:58 <Igloo> That way you get logarithmic lookup really
16:13:22 <Heffalump> ok. I'm not too worried about security.
16:13:38 <Heffalump> Igloo won't be happy about it, though (not the security, the thing in general)
16:14:35 <Igloo> What are you planning to do with it?
16:15:19 <Igloo> If you expect people to cowrite papers with it I can forsee them opening it, making some changes and then thinking for a while about something (or getting distracted). Maybe I'm just too cynical.
16:15:22 <Heffalump> use it for group stuff
16:15:35 <Heffalump> I don't mean writing papers, I just mean recording informal discussions
16:15:57 <Heffalump> writing papers will continue to be done with CVS, or possibly darcs if I'm happy with that once I've played with it for a bit
17:35:54 <shapr> hi juhp 
17:36:07 <shapr> long time no see, what's up?
17:36:49 <juhp> hi shapr!
17:36:58 <juhp> yeah, ltns
17:37:18 <juhp> just been too busy with work... :)
17:37:49 <juhp> i hope to squeeze some haskell time in a bit more from now
17:38:15 <juhp> shapr: how are you doing?
17:38:24 <shapr> lots of work also
17:38:29 <shapr> working right now even :-)
17:38:44 <shapr> and squeezing in the occasional Haskell bit
17:39:33 <juhp> :)
17:39:59 <juhp> had time for any haskell hacking?
17:40:08 <juhp> how's lambdabot?
17:40:22 <shapr> I don't think much has changed with lambdabot
17:40:30 <shapr> I've been playing with an XmlRpc library lately
17:40:44 <shapr> I got it talking to Zope, so I hope to use it in my paying work. I could get paid to write Haskell!
17:40:57 <shapr> HaskellDB on GHC has an alpha release coming up soon
17:41:49 <shapr> have you had any time for hircules?
17:42:25 <shapr> I've been playing with darcs, it's cool.
18:25:35 <stepcut> hrm
18:25:59 <shapr> stepcut: oh YEAH?
18:26:04 * shapr ducks
18:27:04 <stepcut> here is an interesting ghc cvs log message from simonpj@microsoft.com: Backslashes should not be escaped in command-line arguments for rawSystem, on Win32.  This only actually causes failures on WinME/98/95, and we can't test that since we don't have it.
18:27:31 <shapr> yes, big discussion about that on ghc-users
18:27:45 <stepcut> the log message or the bug?
18:28:13 <shapr> the bug
18:28:50 <stepcut> I was more interested in the log message that said: simonpj@microsoft.com can't find a WinME/98/95 machine to test on :p
18:29:10 * shapr grins
18:29:43 <stepcut> anyway, he patch is broken
18:29:55 <stepcut> it does not compile unless you have ghc 6.2.1 or higher 
18:30:57 <shapr> the backslash fixing patch?
18:31:36 <stepcut> yeah
18:32:07 <stepcut> apparently in addition to not having Win98, he doesn't have ghc < 6.2.1
18:32:10 <stepcut> :p
18:32:22 <shapr> that's the downside of being the developer, I guess.
18:32:27 <shapr> well, report it.
18:32:37 <stepcut> I did
18:32:42 <shapr> ok
18:32:48 <shapr> I usually forget to report bugs I find ...
18:33:09 <stepcut> its a silly error, should be easy to fix
19:59:55 * shapr blinks sleepily
20:06:06 * Riastradh sleeps blinkily
20:07:04 * Riastradh woonerizes spordily
20:07:39 <shapr> hah
20:08:01 * Cale sporderizes woonily
20:08:23 * Riastradh spoonily worderizes
20:08:26 * shapr beats Plone with an digital stick
20:08:41 * Riastradh pleast Bone with a stigital...heh.
20:08:48 <shapr> :-P
20:09:01 <liiwi> good morning
20:09:13 <Riastradh> Mood gorning!
20:09:19 <Riastradh> Goong mornid!
20:09:58 <shapr> good morning! I need sleep.
20:11:29 <liiwi> your eye feel vevy vevy sleepy...
20:37:22 <shapr> hi tty4 
20:37:25 <tty4> hi
20:37:37 <shapr> looking for Haskell info?
20:37:42 <tty4> yes,
20:37:55 <shapr> anything in particular?
20:37:57 <tty4> i manage to convince my workplace to use Erlang
20:38:11 <shapr> wow
20:38:12 <shapr> neat
20:38:13 <tty4> and was wondering if the Concurrent Haskell is still supported.
20:38:28 <tty4> i like Haskell's syntax much better :)
20:38:34 <shapr> if you mean coroutine-style pre-emptive threads, then yes.
20:38:59 <shapr> yes, I like Haskell's syntax also.
20:38:59 <tty4> what about all the other concurrent features of Erlang ?
20:39:00 <cleverdra> and if you mean Concurrent Haskell as described by concurrent-haskell.ps, pretty much.
20:39:12 <shapr> which features?
20:39:47 <tty4> i guess what convince them was the ease in which Erlang could do high availability, load balancing etc
20:40:20 <shapr> tty4: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
20:40:31 <tty4> i haven't really seen much of the same thing with Concurrent Haskell although I must admit to taking a quick glance.
20:40:31 <shapr> yes, that's Erlang's strong point.
20:41:02 <tty4> is this area actively supported by the Haskell community.
20:41:48 <shapr> Erlang's high availability comes from features like runtime code upgrading
20:42:04 <tty4> that too!
20:42:20 <shapr> Haskell doesn't have runtime code upgrading
20:42:35 <shapr> it does have lightweight preemptive threads
20:42:38 <tty4> darn. was about to ask about this!
20:43:12 <tty4> what about a distributed database like Erlang's mnesia ?
20:43:29 <shapr> I don't think so.
20:43:49 <shapr> Haskell has HaskellDB, which is neat, but it's not distributed.
20:44:13 <tty4> hmm...mnesia would solve some of our sticker problems easily.
20:44:23 * SamB wonders how you would do lazyness together with dynamic code upgrading and haskell's type system
20:44:51 <tty4> AFAIK Concurrent Haskell does partly away with lazyness.
20:44:55 <shapr> Erlang does it by keeping the old type info around as long as any old versions of instances exist
20:44:58 * SamB tries to stop thinking about such a mess
20:45:07 <shapr> all new instances are created with new type info
20:45:20 <shapr> it sounds easy when you say it like that :-)
20:45:36 <SamB> tty4: well it sure ain't strict!
20:46:07 <tty4> SamB: you will have to explain what you mean by 'ain't strict'
20:46:52 <SamB> tty4: I mean that it will have thunks as well as already evaluated values
20:47:26 <tty4> would this be an issue ?
20:48:05 <SamB> tty4: it just sounds messy!
20:48:32 <tty4> *chuckle*
20:49:17 <tty4> another option would be Concurrent Clean but I had a hard enough time with Erlang especially with regards to community support.
20:49:34 <tty4> Does anyone have opinions on Cocurrent Clean ?
20:49:46 <shapr> Haskell community support is excellent (at least, from what I've seen)
20:49:49 <tty4> s/Cocurrent/Concurrent/
20:50:05 <shapr> especially if you use the GHC implementation.
20:50:06 <SamB> well, Clean looks like the source is a mess
20:50:21 <tty4> i like what i've seen with Haskell. i started with Haskell about 2 years ago.
20:51:04 <tty4> b/w Erlang, Haskell and Clean; Haskell seems to be the most actively supported.
20:52:14 <shapr> There's lots of activity in the Haskell community.
20:52:23 <shapr> I like the irc channel also :-)
20:53:49 <stepcut> I started looking at clean, haskell, and ocaml 2 years ago -- ghc seems to be doing the most cool stuff the fastest
20:54:58 <tty4> as an open question, what do people use these days for concurrent programming ? I've looked into Beta, Clean, Erlang, Mozart (?) and Haskell but Erlang seems the most mature in this regards.
20:55:42 <shapr> if you need telephone-quality 100% availability, I'd go for Erlang.
20:56:29 <cleverdra> tty - Haskell, O'Caml, and Erlang all have nice enough ability in this area.  Erlang fairly well wins over everything else, but that language doesn't apply as well to some other program domains.
20:56:41 <cleverdra> (for concurrent and distributed programming)
20:57:02 <tty4> cleverdra: what would these domains (which Erlang isn't good at) be ?
20:57:22 <cleverdra> tty - oh, terminal IO for one.
20:57:45 <cleverdra> If you want to do that in Erlang anyway, take a look at its slang interface.
20:57:49 <tty4> cleverdra: yet for terminal IO you can just use port(s)
20:58:18 <tty4> cleverdra: i did not know it had a slang interface. thanks for the info.
20:59:21 <shapr> my priority is on expressiveness, and in my opinion, Haskell has more than Erlang.
21:00:21 <tty4> that i whole heartedly agree, hence asking these questions on this particular IRC!
21:01:31 <shapr> what sort of application are you developing?
21:01:49 <shapr> maybe we can point you to some related libraries?
21:02:49 <tty4> there are 3 in mind. one deployed as a Java app (little chance of changing but likely we would use Eddie) and 2 others in requirement gathering stage.
21:03:04 <tty4> the first is a point of sale application.
21:03:15 <tty4> the second is network security monitoring.
21:03:31 <tty4> the third is real time (asset) tracking.
21:04:50 <shapr> I've heard that there are many network libraries in Erlang, Haskell does not have many.
21:06:22 <shapr> a POS application could take advantage of runtime code upgrading
21:06:35 <shapr> but could also be written as a Haskell app
21:06:58 <shapr> I don't know anything about asset tracking, do you mean checking out laptops or other portable but trackable items?
21:07:10 <tty4> each one has a different critical requirement. POS is the Java app so its High Availabilty is mostly on the server side (which means Erlang's Eddie lib would do).
21:07:24 <tty4> network security requires a distributed dbase.
21:08:16 <tty4> real time tracking a fully connected network with HA on each node (data gathering point).
21:08:37 <cleverdra> tty - what did you think of Mnesia for that, then?
21:09:12 <tty4> cleverdra: yes, mnesia was what i thought about.
21:09:57 <tty4> shapr: assert tracking - tag items with transponder and access points track location typically within 1 m radius (in door use).
21:13:06 <shapr> sounds like fun
21:14:04 <shapr> I think you could write the network security monitor to send data streams to a single host
21:14:18 <shapr> there are several network monitors that do that.
21:14:33 <tty4> shapr: this is how its typically done.
21:14:50 <tty4> but now you are dependent on having that one host alive all the time.
21:16:53 <tty4> most of them do some fancy spooling to avoid losing data (or events) however it all goes down one pipe to one box.
21:17:23 <shapr> yes, that's true.
21:17:50 <tty4> with a distributed dbase you now have n nodes with the same data replicated.
21:18:07 <tty4> thats a big help when it comes to collecting evidence.
21:18:09 <shapr> yes, that would be a better system.
21:18:44 <tty4> if one node has different logs you can be fairly certain it has been tempared (sp?) with.
21:19:01 <shapr> tampered
21:19:14 <shapr> I'm curious, what's your first language?
21:19:35 <tty4> English but my spelling is atracious!
21:19:43 <shapr> atrocious :-)
21:19:48 <tty4> see :)
21:20:53 <tty4> or I should have said QED!
21:21:15 <shapr> That's much easier to spell, I agree.
21:22:39 <tty4> it just occured to me that in Haskell programs are compiled with a runtime. would this be similiar to having a VM embeded into each program ?
21:23:01 <tty4> why not just use an external VM ?
21:23:37 <shapr> I think Helium does that.
21:24:30 <ibid> tty4: c programs are also compiled with a runtime, do you suggest one should use an external vm
21:24:41 <shapr> good morning ibid!
21:25:02 <ibid> tty4: the reason is that the haskell runtime is not a vm interpreter, unless i am badly mistaken
21:25:05 <ibid> morning
21:25:07 <shapr> glad to see you an orkut
21:25:12 <shapr> "on"
21:25:29 <tty4> ibid: for c programs the only runtime i'm familiar with is the call to main. please explain.
21:26:12 <tty4> call -> bootstrap
21:26:58 <ibid> mainly that, yes
21:27:05 <ibid> perhaps i should have said c++ :)
21:27:15 <cleverdra> ibid - no, your assertion holds well enough for C.
21:27:40 <tty4> cleverdra: could you kindly expand on that ?
21:27:51 <cleverdra> tty - do you understand dynamic linking?
21:28:09 <tty4> yes, however that resolution is done by the OS no ?
21:28:35 <ibid> depends on what you call the os :)
21:28:38 <ibid> not the kernel
21:29:08 <tty4> no thats true however its still an external program.
21:29:41 <tty4> user space program i mean
21:29:44 <ibid> every elf binary includes an interpreter path; every dynamically linked program has the dynamic linker as elf interpreter
21:29:48 <cleverdra> tty - parts of the mechanism that creates dynamic linking exists outside a given C program, sure.
21:31:15 <cleverdra> tty - try a google for "c runtime environment" under groups.google.com/groups?group=comp.lang.c
21:31:25 <tty4> will do.
21:33:42 <shapr> hey darius-
21:33:48 <ibid> shapr: you know the finnish meaning of the name of that site? :)
21:34:01 <shapr> no, but I suddenly want to
21:34:22 <ibid> it's slang for orgasms
21:34:29 <shapr> haha!
21:34:31 <darius-> hey shae
21:34:48 <shapr> darius-: I upgraded haskell-mode, hopefully it works now.
21:34:56 <darius-> great!  thank you
21:35:04 <ibid> shapr: so you see why some of my friends think the invitation mail is spam ;)
21:35:15 <shapr> that's entertaining.
21:35:18 <darius-> i'll bet just about any word that length is slang for sex in some language
21:35:36 <ibid> (my father thought my machine had been infected witha virus...)
21:35:52 <ibid> darius-: but orkut is directly derived from the orgasm word
21:35:57 <shapr> join orgasms.com now!
21:36:13 <darius-> heh, i thought it was the founder's name
21:36:19 <ibid> it is
21:36:28 <darius-> i guess his parents decided to commemorate his conception that way?
21:36:34 <ibid> i mean the finnish slang word...
21:36:55 <ibid> he's not a finn, and if he were, there's no way orkut could be his real name
21:37:27 <darius-> what a pity
21:37:57 * darius- is reminded of some girl in the newspaper named latoilet
21:38:39 <cleverdra> ah, how sad that she has a communist time.  The Little Worker.
21:38:43 <cleverdra> also, name.
21:39:50 <tty4> ibid,shapr,cleverdra: thanks for your input/help. i've to leave now. ttyl.
21:40:08 <shapr> sure, come back soon :-)
21:40:19 <tty4> i will do that. i still don't grok monad :)
21:42:38 <shapr> hi harsha123 
21:43:12 <ibid> (the officials would not accept such a name...)
21:43:41 <ibid> i need to catch a bus, bbl
21:43:46 <darius-> silly officials
21:44:32 <ibid> and that's because it would be against the name act
21:46:06 <cleverdra> I'd think that it would fall well enough under a Child-Abuse Act.
21:47:18 <darius-> like naming your child Richard Butkus?
21:47:46 <shapr> or Snow White
21:47:49 <shapr> or Bob White
21:48:16 <darius-> bob white?  duh, i don't get it.
21:50:32 <shapr> it's the name of a common bird in the southeast USA, and supposedly the sound it makes also sounds like "bob white"
21:50:55 <shapr> the farmer kids in Alabama would definitely pick on someone with a name like that.
21:51:11 <darius-> ah, ok.  well, the kids picked on me too as a kid. :P
21:56:15 <harsha123> hello shapr :) how are you?
21:56:33 <darius-> hi harsha
21:56:42 <harsha123> hi darius-
22:00:54 <shapr> I'm awake!
22:01:30 <darius-> do you code better awake or asleep?
22:06:21 * harsha123 woders if there is any particular method to do a *nick transition*
22:27:05 <shapr> darius-: awake
23:47:07 <shapr> yow
23:47:14 <shapr> Segora: dude, you're bouncing
23:50:13 <shapr> yow!
23:50:57 <darius-> yow
23:51:06 <earthy> @yow
23:51:07 <lambdabot> Thousands of days of civilians ...  have produced a...
23:51:07 <lambdabot>  feeling for the aesthetic modules --
23:54:42 <shapr> ok, I'm going to unspam the channel
23:54:56 --- mode: ChanServ set +o shapr
23:55:47 --- mode: shapr set +b *!*@p4523e3d4.np.schlund.de
23:56:00 <shapr> Segora: msg me or another op when you've got the bouncing fixed
