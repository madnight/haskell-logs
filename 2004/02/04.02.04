00:12:09 <stepcut> aha!
00:12:23 <stepcut> it helps to realized that the following types are equivalent:
00:12:34 <stepcut> show :: forall a. Show a => a -> String
00:12:38 <stepcut> show :: forall  a. Show a => (->) a String
00:14:34 <stepcut> which explains why something with the type 'a b c' can act like a function
00:14:58 <stepcut> too much ocaml makes my brain rusty
00:15:02 <shapr> well, it's way to represent a function.
00:15:26 <shapr> you could say "Function a b" to show that it's a function that takes an a and gives a b
00:16:37 <stepcut> I new the type of 'arr show' was 'a b c', so I was confused why '(arr show) 1' worked, until I realized what was going on
00:16:59 <stepcut> s/new/knew/
00:17:36 <stepcut> those wacky infix type constructors
00:18:27 <stepcut> I am working towards understanding 'Arrows and computation' by Ross Paterson
00:18:42 <stepcut> the 'circuit' stuff in there looks cool
00:19:06 <stepcut> and it seems like arrows could be usefully for complicated graph traversal stuff
00:21:26 <stepcut> actually, I want to get a firm grip on monads, arrows, generics, dynamics, and template haskell :)
00:21:33 <stepcut> then I can actually write some stuff :p
00:21:42 <shapr> I just think they're fun.
00:21:48 <shapr> so many toys!
00:22:07 <Maddas> shapr: The instruction manual is harder than usual for toys, though
00:22:33 <stepcut> I am thinking arrows might be a good way to handle parsing binary data that uses bit fields
00:22:43 <shapr> that's true, but once you've understood the instructions, you have the toys. No purchase necessary.
00:23:04 <shapr> oh, I got the patch to make Tomasz' code work in 6.2
00:23:05 <shapr> you want it?
00:23:10 <Maddas> And they don't wear out as quickly as most others
00:23:14 <shapr> that right
00:23:32 <shapr> I can play with these toys while at the dentists' office lying in the chair.
00:23:33 <stepcut> shapr: maybe later. His code does not support bit fields, does it?
00:23:43 <shapr> iirc, it does not.
00:24:02 <stepcut> the version I saw explicitly claimed it did not
00:24:16 <stepcut> specifically because he has not needed them yet
00:25:02 <shapr> and he suggested a really nice syntax for the bitfields, iirc
00:25:13 <stepcut> Are there SDL bindings for Haskell yet?
00:25:45 <shapr> not supported bindings
00:26:09 <stepcut> I might work on some with a guy at work. We want to do SDL+GL, instead of GLUT+GL
00:26:49 <shapr> look at this - http://shapr.homelinux.net/~shae/hasdl-0.1pre7.tar.gz
00:27:12 <stepcut> I wrote bindings for 3 SDL functions, which is enough to open a GL window and draw in it, but there is a lot more that would be useful
00:31:20 <stepcut> thanks, I will check that out when I get a chance
00:41:10 <Maddas> Riastradh: What was that URL about using continuations (or call/cc, not sure) for web programming (server-side, it was explained with Scheme)?
01:16:18 <shapr> ok, I've got HSQL talking to postgresql.
01:27:27 <earthy> whoa
01:27:40 <shapr> what?
01:27:59 <earthy> a kosmikus joining
01:34:02 <Marvin--> morning guys
01:34:12 <shapr> hej Marvin-- 
01:34:15 <shapr> wassup?
01:34:43 <Marvin--> I'm pondering in which order to present the transformations of my Haskell-to-FOL compiler
02:05:02 <shapr> top down?
02:13:41 <Marvin--> well, basically I have a set of simplification transformations that are Haskell->Haskell, and there's a set of Haskell->FOL transformations
02:14:03 <Marvin--> obviously the H->H transformations happen first, but standalone they don't make much sense until you've seen the H->FOL ones
02:14:24 <shapr> sounds like you should start with H->FOL then.
02:16:01 <Marvin--> yeah
02:16:20 <Marvin--> but they're so frickin' complicated :-)
02:16:32 <Marvin--> especially when describing the general case
02:16:44 <shapr> maybe you can start more specific and generalize?
02:16:44 <Marvin--> take for example the declarations
02:17:04 <Marvin--> a function f taking n patterns with m guards
02:27:17 <earthy> FOL?
02:28:03 <earthy> as in you're translating haskell to first order logic?
02:29:13 <Marvin--> yes
02:29:38 <Marvin--> well, a small subset of Haskell, thankfully :)
02:33:49 <Marvin--> hmm, how was it that \ensuremath worked again
02:35:25 <Marvin--> ah, yes
02:39:50 <bring> anyone what could cause this error when loading a package that uses FFI into ghci: 
02:39:52 <bring> $ ghci -package hsql
02:39:59 <bring> Loading package hsql ... ghc-6.2: can't load .so/.DLL for: c (/usr/lib/libc.so: invalid ELF header)
02:43:00 <Marvin--> wow, there's almost no snow left on the ground now
02:43:17 <earthy> well, duh. :)
02:43:33 <earthy> (we had snow exactly a week ago... now it's 15 degrees centigrade out)
02:44:07 <shapr> it's been snowing most of the last few days here. we have lots!
02:44:32 <Marvin--> earthy: wow
02:45:44 <Marvin--> it's about 5 degrees here
02:45:59 <Marvin--> though given the temperature last week it feels really warm :)
02:54:39 <Marvin--> uh-oh
03:28:56 <shapr> hello shurik 
03:29:14 <shurik> g'day
03:30:36 <shurik>              
03:30:47 <shapr>                  ?
03:30:56 <shurik> oops
03:31:11 <shapr> yay, HaskellDB works on debian with postgresql!
03:31:16 <shurik> could someone recommend a book on Haskell for someone who's already familiar with programming
03:31:32 <shapr> if you like math, try Hudak.
03:31:37 <shapr> if not, try Thompson.
03:31:37 <shapr> @learn
03:31:37 <lambdabot> http://www.haskell.org/learning.html
03:31:47 <shapr> several books and some online tutorials listed at that url.
03:32:25 <shurik> I've seen those books on haskell.org
03:32:31 <shurik> don't know which one to choose
03:32:40 <shapr> I have Hudak and Thompson
03:32:47 <shurik> I don't mind maths
03:32:54 <shapr> so I can give an informed opinion there.
03:34:10 <Marvin--> I haven't read Hudak's book, but Thompson's is okay
03:34:30 <shapr> hej ski
03:34:43 <ski> hej shapr !
03:34:52 <ski> hur gås det ?
03:34:52 <shapr> wassup?
03:35:25 <shapr> jag inte sovit tillrackligt, som altid :-)
03:35:28 <shurik> so what's your opnion?
03:35:34 <shapr> how do I say "as always" ?
03:35:59 <ski> jag har just loggat in och skall (borde) arbeta på kurs-stuff
03:36:18 <Marvin--> I think Graham Hutton is writing a Haskell book, I'm looking forward to that, he's a good writer
03:36:19 <shapr> kul
03:36:30 <Marvin--> shapr: "som vanligt" in this case
03:36:44 <ski> shapr : :) min dygnsrymn är inte helt stabil alltid, heller
03:37:04 <shapr> ski: whoa, you have dots on your a! when did that happen?
03:37:26 <Marvin--> http://www.cs.nott.ac.uk/~gmh/book.html
03:37:26 <ski> i don't know :)
03:37:42 <shapr> oooh
03:38:08 <Marvin--> I wonder if I could trick him into giving me a draft copy
03:38:13 <shapr> me too!
03:38:17 <shapr> well, I'd just want to ask about it.
03:38:34 <ski> jag antar att (åtminstone) en del av burkarna i den nya byggnaden har bättre konfig för dessa tecken
03:38:55 * Marvin-- points ski to #haskell.se
03:38:58 <shapr> whoops
03:39:05 <Marvin--> no need to scare the non-Swedes
03:39:08 <shapr> :-)
03:39:13 <shapr> like me!
03:42:00 * Heffalump looks for people who know Utrecht
03:42:45 <Marvin--> I've passed through the train station, is that enough? :)
03:43:00 <Heffalump> do you know what the nearest airports are? :-)
03:43:06 <Heffalump> and travel times to them
03:43:08 <Marvin--> no :(
03:43:13 <Heffalump> actually, I'm a fool.
03:43:22 <Heffalump> I could go and ask Oege, who would know this in detail.
03:43:25 * Heffalump disappears.
03:44:37 <Marvin--> heh
03:45:34 <earthy> dang
03:45:38 <earthy> just missed hef
03:46:05 <earthy> (nearest airport: Schiphol, roughly 35 minutes by train from Utrecht)
03:46:53 <Marvin--> that's what I would've guessed too, but when I went through Utrecht I had come to .nl by car, not plane
03:47:14 <earthy> ;)
03:48:06 <Marvin--> and when I came to .nl by plane it was just to switch to another plane to Germany, so.. :)
03:50:33 <shurik> some reaaders are suggesting in reviews that Hudak's book provides indepth expalnations and more information than Thompson's book
03:50:57 <shurik> does anyone agree with these opnions?:>
03:51:22 <earthy> haven't read either of 'm, so can't say
03:54:09 <shurik> shapr  which book is yourr favourite??
03:54:19 <Marvin--> I also recommend hdaume's Yet Another Haskell Tutorial: http://www.isi.edu/~hdaume/htut/
03:54:24 <shurik> you've lost both books to the midst of time?:>
03:55:04 <shapr> shurik: they both have good points. I learned from Thompson, since I don't have much math background.
03:55:15 <Marvin--> brb, going to go see if I've gotten today's mail yet
03:59:32 <Marvin--> yes indeed
04:09:13 <shurik> has anyone read athis book and heard about it?
04:09:14 <shurik>   
04:09:14 <shurik> Sign in to turn on 1-Click ordering.
04:09:15 <shurik> 8 used & new from $9.99 Available for in-store pickup now from: $19.00
04:09:15 <shurik> Price may vary based on availability
04:09:17 <shurik> Enter your ZIP Code
04:09:19 <shurik> Have one to sell? 
04:09:22 <shurik> Don't have one?
04:09:24 <shurik> We'll set one up for you.
04:09:27 <shurik> Gödel, Escher, Bach: An Eternal Golden Braid
04:09:29 <shurik> by Douglas R. Hofstadter 
04:09:32 <shurik> oops
04:09:35 <shurik> :>
04:09:37 <shurik> sorry about the flood
04:10:04 <Marvin--> GEB, yes, very good book
04:10:24 <Marvin--> read it :I)
04:10:29 <Marvin--> er, minus the |
04:13:55 <ski> hello gim
04:14:29 <gim> hello. :-)
04:14:42 <ski> know any haskell ?
04:14:55 <gim> a little bit.
04:14:56 <ski> (or, what brings you here ? :)
04:15:10 <ski> got any questions ?
04:15:33 <gim> humm..well...
04:15:56 <ski> learning ?  by yourself ? taking a course ?
04:15:59 <ski> :)
04:16:06 <gim> by myself.
04:16:12 <ski> ok
04:16:17 <ski> that's fine
04:16:41 <gim> :-)
04:17:22 <ski> what langs have you used before ?
04:18:49 <gim> BASIC, Pascal, C, C++, Java, PROLOG, ocaml...
04:18:58 <ski> ok
04:19:51 <ski> what do you think about laziness ?
04:20:07 <gim> terrific!
04:20:24 * Marvin-- likes to be lazy too
04:20:49 * ski is (most often) very lazy about things
04:21:14 <ski> so, 't seems haskell suits us well, then :)
04:21:30 <gim> :-)
04:21:43 <gim> I'm interested in Haskell an Clean.
04:21:48 <gim> and
04:22:48 <Marvin--> I've never looked at Clean in depth, what advantages does it have over Haskell? From what I've seen the syntax is nearly identical except that functions seem to be uncurried by default
04:23:27 <gim> hummm both's syntax are from Miranda. so seems almost identical.
04:23:36 <Marvin--> yeah, exactly
04:24:11 <Marvin--> frankly I don't understand why they do uncurried functions, curried functions is one of the really neat things about Haskell
04:24:12 <gim> But, its semantic are little bit different.
04:24:19 <Marvin--> all right?
04:24:34 <ski> the uniqueness thing is interesting
04:24:57 <gim> 'cause, in Clean, curried thing are to evaluated in parallel.
04:25:09 * ski really someday soon have to look at how Clean does that, in more detail
04:25:32 <gim> yeah, may the Lazyness be with us!
04:26:07 <Marvin--> hmm, how does that work with laziness?
04:26:39 <ski> do they have any parallel implementation, yet ?
04:27:13 <gim> f 1 _ 0 = 3
04:27:21 <gim> f _ 0 1 = 2
04:27:27 <gim> f 0 1 _ = 1
04:27:40 <ski> hmm, maybe there can be multiple 'forcers' at the same time, evaluating parts of the program graph ..
04:28:21 <ski> gim : can they do a commutative && that satisifes  a && False = False ?
04:28:48 <gim> because of situation like that, a b -> c and a -> b -> c are different.
04:29:03 <gim> cammutative?
04:29:27 <gim> What is "commutative &&"
04:29:28 <ski> gim : yeah, a && b = b && a, for all a and b (including _|_)
04:30:10 <gim> yeah, in Clean && might be define like that
04:30:21 <ski> like how ?
04:30:23 <gim> And False _ = False
04:30:26 <gim> And _ False = False
04:30:39 <gim> And True True = True
04:31:24 <ski> so, it will begin evaulating both arguments, yielding False, if one of them does, even if the other loops ?
04:32:22 <gim> yes, evaluating argument is parallely working.
04:32:29 <ski> (weel, i guess it doesn't have to trigger both immediately, just after some magic time they could start the other one)
04:32:32 <ski> ok
04:32:52 <Marvin--> so patterns aren't tried in order?
04:32:52 <gim> seem funny, but useful.
04:33:00 <ski> and, that is in the current implementations ?
04:33:33 <gim> As I know. In fact I'm just beginner in Clean.
04:36:16 <gim> reading book. :-)
04:36:29 <ski> the one online ?
04:36:57 * Maddas tries to figure out how to download books from Safari
04:37:34 <ski> gim : hmm, i suppose they don't have additive pairs in Clean  (or do you know ?)
04:38:06 <gim> what is additive pairs?
04:38:18 <ski> you don't know ?                          :-P
04:38:42 <ski> well, it's a linear(/unique) pair of two things
04:39:17 <ski> so the linear/unique just means that we can't duplicate the pair
04:39:28 <gim> I don't.
04:39:35 <gim> duplicate?
04:39:38 <gim> means unique?
04:39:40 <ski> weah
04:39:43 <ski> like
04:39:49 <ski> Start :: *World -> *World
04:40:00 <ski> we can't duplicate the world
04:40:07 <gim> yes.
04:40:20 <gim> I'm just reading this book.
04:40:21 <gim> http://www.cs.kun.nl/~clean/contents/Clean_Book/clean_book.html
04:40:32 <gim> http://www.cs.kun.nl/~clean/contents/Addison__Wesley_book/addison__wesley_book.html
04:41:55 <gim> by the way, I have to go for fitness.
04:42:09 <ski> so, you know that one cannot use a variable with linear/unique type more that once  (in fact, one cannot *not* use it, either)
04:42:27 <gim> correct.
04:43:02 <ski> ok, the additive mean that, instead of : you must use both parts of the pair, if/when you take it apart
04:43:43 <ski> instead of that, you must use exactly one part of the pair. It's your pick, which one you want
04:44:26 <ski> gim : understand ?
04:45:07 <gim> must exactly one part...
04:45:12 <ski> yes
04:45:58 <ski> so you could offer a tuple of options to the user, and s/he must pick exactly one of them
04:46:18 <ski> (of course it can be easily extended to tuples and records)
04:46:18 <gim> hummm...
04:46:31 <ski> this can someimes be useful, i think
04:46:53 <gim> well. interesting.
04:47:27 <gim> but talk in next time. it's time to go. sorry. :-(
04:47:28 <ski> ok, well, i'll guess i shouldn't keep you away from your fitness more ...
04:47:33 <ski> yes, bye
04:47:37 <gim> bye
04:53:55 <shurik> Haskell is interesting but I think 2/3 tuttorials and Th report will get me started:>
04:58:31 <kowey> a good way to learn would also be to help write the haskell wikibook!
04:58:58 <kowey> http://wikibooks.org/wiki/Programming:Functional_programming
04:59:11 <kowey> and http://wikibooks.org/wiki/Programming:Haskell (empty)
04:59:51 <shapr> let's steal PLEAC and put it on the HaWiki
05:00:18 <shapr> http://pleac.sourceforge.net/pleac_haskell/t1.html
05:01:02 <kowey> already on sourceforge, guess it wouldn't offend them, eh?
05:01:39 <shapr> it's GFDL anyway
05:01:50 <kowey> woohoo!
05:02:05 <shurik> it'd be nice if someone donated a book to Haskell community
05:02:27 <shurik> similar to what Java , Ruby , Ptyhon haave
05:06:27 <Marvin--> eww, GFDL
05:06:57 <kowey> i'd rather the creative commons myself (much simpler)
05:07:09 <kowey> but at least it's wikipedia/books compatible
06:17:43 <SyntaxNinja> is there a debian-packaged version of ghc which has good behavior for the combination of --make and -main-is?
06:19:42 <shapr> have you tried ghc-cvs ?
06:19:57 <shapr> --version gives 6.3
06:23:10 <SyntaxNinja> hmm.
06:23:43 <SyntaxNinja> somehow I fear that the total sum of my problems won't be lessened with ghc-cvs :)
06:27:15 <Marvin--> SyntaxNinja: wuss! :)
06:28:31 <SyntaxNinja> Marvin--: I'm feeling lazy today, that's why I want -main-is :)
06:29:24 <earthy> --main-is has *enormous*advantages* for unit testing
06:29:53 <kowey> out of curiosity, anyone here actually use hunit?
06:29:55 <SyntaxNinja> earthy: that's exactly what I'm doing
06:30:03 <SyntaxNinja> kowey: yup
06:30:20 <earthy> then you're not lazy, you're rightfully asking for a feature. :)
06:30:28 <kowey> does it work well? i've used junit if that's a reference point
06:31:32 <SyntaxNinja> kowey: I like it.  There are a couple of things I wish it did better, though.  One thing in particular, a lot of my calculations can't use == because they're approximations, so I want something a little more flexible sometimes
06:32:03 <kowey> thanks, SyntaxNinja
06:32:03 <SyntaxNinja> as it is, I just use the assertBool with my approximation functions, but that's not as good as it could be
06:32:25 * kowey files the thought for reference
06:32:57 <kowey> couldn't you make your own assert thing? assertAlmostEqual?
06:34:28 <SyntaxNinja> kowey: well, that's not really the problem, assertBool works fine with my approximation operator...
06:34:57 <shapr> I use HUnit
06:35:07 <SyntaxNinja> but there's a nice syntax for making a unit test: ("name of test" ~: "Failure message" ~: expectedValue ~=? testValue) and I'd like to use that syntax
06:35:17 <SyntaxNinja> because the output is nice adn the syntax is nice
06:35:22 <SyntaxNinja> (it shows what was expected and what it got)
06:35:51 <SyntaxNinja> but I'd like to parameterize it by my equality function, instead of forcing it to be in the Eq class
06:36:24 <kowey> would it be possible to do fancy tricks with newtype?
06:37:14 <Marvin--> I've always been annoyed that you cannot operator-ify a partially applied function
06:37:21 <ski> (hmm, is there an environment variable for GHC(I), in which one can put command line options ?)
06:37:30 <Marvin--> especially when I fiddled with Helium and wanted to write things like  xs `eqList eqInt` ys
06:37:33 <shapr> ski: ~/.ghci
06:37:37 <ski> (i know about .ghci files)
06:37:40 <shapr> oh
06:38:13 <shapr> `(x . y)` ?
06:38:15 <SyntaxNinja> kowey: what do you mean?
06:38:33 <kowey> some kind of stub... hang on, i'm still new to this haskell thing
06:38:34 <ski> (if i understood correctly .ghci will only be read if one is standing in the same directory as it)
06:39:00 <kowey> data Approx a = Approx a
06:39:13 <kowey> instance Eq Approx a where
06:39:19 <shapr> I'm almost sure ~/.ghci is read no matter what dir you start in.
06:39:45 <kowey> x == y = approximately_equal x y
06:40:09 <ski> shapr : hmm, yes. you are right, thanks
06:40:58 <SyntaxNinja> kowey: you could do soemthing kinda like that by defining equality for your type to be approximation, but then you'd lose equality
06:41:16 <SyntaxNinja> hmm
06:41:39 <kowey> right, but you could just the Approx just to do unit testing, right? just for the times you want to test the approximation of something, you wrap it
06:42:00 <SyntaxNinja> so your way would be to wrap the things you want to compare with Approx like (Approx expectedValue) ~=? (Approx testValue)
06:42:45 <SyntaxNinja> that's a neat workaround :)
06:42:47 <kowey> something like that; the code might ugly, but might been assertBool... anyway, coffee calls :-)
06:42:59 <kowey> might been / might be cleaner than
06:43:17 <shapr> you could even define those instances in the unit test file only
06:43:21 <Marvin--> wouldn't you need to parameterize that with your approximately_equal function to be useful?
06:43:36 <shapr> on the other hand, I don't think you can hide instances that are defined elsewhere.
06:43:49 <ski> shapr : (yes, it works. only i would like to invoke the shell a little from it ..)
06:44:03 <shapr> what do you mean invoke the shell a little?
06:44:31 <ski> shapr : well, doing things like :s -i`(cd ~komp4 ; pwd)`/BNFC
06:45:00 <SyntaxNinja> Marvin--: yeah in general.
06:45:02 <Marvin--> something like data Approx a = Approx (a -> a -> Bool) a
06:45:39 <Marvin--> ski: taking the compiler course, are you?
06:45:47 <Darius> Alternatively, you could just make an ApproxEq class.
06:45:55 <ski> Marvin-- : how could you tell ? ;) ;)
06:45:58 <SyntaxNinja> now I'm trying to figure out how to unit test signal functions
06:46:06 <Marvin--> ski: gee, I don't know :)
06:46:41 <Marvin--> fun course
06:46:44 <Cale> ski: can't you just figure out the absolute path to that dir? Changing home directories a lot?
06:47:25 <ski> Cale : 'fcourse i can. just thought 'twould be cleaner .. :/
06:47:35 <shapr> SyntaxNinja: quickcheck might be more production for signal functions
06:47:40 <shapr> er "productive"
06:47:40 <Darius> Only two spam/virus emails out of 13, and one with the interesting subject: coffeecup homomorphism.
06:47:52 <Marvin--> Darius: haha
06:47:55 <shapr> neat
06:48:07 <ski> Darius : what in the h**l is *that* ?
06:48:21 <SyntaxNinja> heh
06:48:27 <SyntaxNinja> shapr: why's that?
06:48:52 <Cale> ski:  also, ~ seems to work directly when specifying a file in ghci
06:48:53 <Darius> ski: I imagine a structure preserving function between coffee cups.
06:49:55 <Cale> Darius: homeomorphism of topological spaces
06:50:05 <ski> Darius : would it be possible to make one from a coffeecup into a donut ?  or is the coffee included in the structure ?
06:50:36 <shapr> SyntaxNinja: because testing a signal function for a single input doesn't cover much. If you establish some properties or relationships that should always hold, then QC can generate cases and check them.
06:50:37 <Cale> that's an isomorphism though :)
06:52:04 <shapr> and QC gives you more flexibility with properties
06:52:07 <Darius> Cale: That was my first association.
06:52:16 <shapr> even though it still comes back to Bool
06:52:17 <Cale> maybe there should be a condition that the amount of coffee that it holds shouldn't change
06:53:06 <Darius> Well, the structure of a coffee -cup- would be a cup that holds coffee, so I'd imagine drinking some of the coffee would be a legal homomorphism.
06:53:34 <SyntaxNinja> shapr: OK I'll check it out :)
06:53:41 <Cale> hmm...
06:53:56 <SyntaxNinja> Darius: not in the US ;)
06:54:26 <shapr> on the downside, most developers can write unit tests in their sleep, but QC requires brain cells. That's true for me at least.
06:56:10 <earthy> ugh, how true.
07:23:28 <cybermanco> hiu
07:26:36 <ski> hi cybermanco
07:32:12 <cybermanco> (sorry my bad english)
07:32:28 <cybermanco> I don't know kaskell very well
07:32:39 <cybermanco> I am trying to do an instance of show
07:33:01 <cybermanco> I did a function:
07:33:02 <cybermanco> showBitMap :: (Show a) => BitMap -> String
07:33:21 <cybermanco> but now I can't use it..
07:34:38 <ski> hm
07:34:58 <ski> are you using hugs, ghc(i) or helium ?
07:35:14 <cybermanco> ghc
07:35:31 <ski> if not helum, then you should do an "instance" declaration
07:35:33 <ski> ok
07:35:41 <ski> then write something like
07:35:48 <ski> instance Show BitMap
07:35:50 <ski>   where
07:35:55 <ski>   show ... = ...
07:36:12 <ski> do you understand ?
07:36:28 <cybermanco> I did this:
07:36:28 <cybermanco> instance Show BitMap where
07:36:28 <cybermanco>   showsPrec _ x = showBitMap x
07:36:34 <cybermanco> but it doesn't work
07:36:42 <ski> well, that should work, i think
07:36:47 <ski> doesn't it ?
07:36:51 <cybermanco> nop
07:37:46 <ski> well in any case you shouldn't write the type signature for showBitMap that way
07:37:50 <ski> write
07:37:58 <ski> showBitMap :: BitMap -> String
07:38:03 <ski> ok ?
07:38:27 <cybermanco> hm
07:38:33 <cybermanco> it's working..
07:38:41 <ski> fine :)
07:38:50 <cybermanco> I changed showsPrec _ x = showBitMap x for show x = showBitMap x
07:39:32 <ski> you can also write "showsPrec _ = showBitMap" or "show = showBitMap", if you like. it is the same thing
07:40:04 <ski> the "Show a =>" stuff is used when you want something that will work for any Show'able type
07:40:26 <ski> showBitMap only works for a specific type, so that's why it shouldn't be there
07:42:16 <ski> (also, the context "Show a =>" introduces a type variable "a", that must be used, if you use the context in a type signature)
07:44:38 <ski> gim : hi
07:50:20 <Darius> @type showsPrec
07:50:20 <lambdabot> showsPrec :: Show a => Int -> a -> ShowS
07:50:46 <ski> (yes, thought about that)
07:52:07 <cybermanco> @type show
07:52:07 <lambdabot> show :: Show a => a -> String
07:54:27 <cybermanco> @type <-
07:56:28 <ski> that is not an operator
07:57:10 <ski> and for operators, you have to type like
07:57:14 <ski> @type (++)
07:57:14 <lambdabot> (++) :: [a] -> [a] -> [a]
07:57:42 <ski> <- is syntactic sugar in the do-notation
08:04:44 <SyntaxNinja> @yow
08:04:45 <lambdabot> UH-OH!!  I think KEN is OVER-DUE on his R.V. PAYMENTS and HE'S
08:04:45 <lambdabot>  having a NERVOUS BREAKDOWN too!!  Ha ha.
08:05:10 <ski> haha
08:08:53 <Marvin--> R.V.?
08:18:48 <SyntaxNinja> Recreational Vehicle
08:18:53 <SyntaxNinja> like a motor home
08:19:27 <Marvin--> oh
08:20:34 <earthy> and gone
08:23:01 <kowey> ok room... any users of wxhaskell around?
08:23:20 <kowey> i get a bunch of ugly problems compiling it on my mac:
08:23:21 <kowey> ld: Undefined symbols:
08:23:21 <kowey> _TextziParserCombinatorsziParsecziChar_alphaNum_closure
08:23:21 <kowey> _TextziParserCombinatorsziParsecziChar_oneOf_closure
08:29:47 <Marvin--> wow, White beat Hendry
08:30:13 <SyntaxNinja> can anyone give me a hint as to how to get quickcheck to do more than 100 tests?
08:36:09 <Marvin--> check (quick{ configMaxTest = 200 }) prop   ought to work
08:37:28 <Igloo> Nice. I forgot to put it on to record today  :-(
08:37:48 <Igloo> What was the score? Was White playing well or Hendry badly?
08:38:43 <Marvin--> 6-4, they both played really well until 3-3 and then they started getting nervous and made lots of small mistakes
08:39:03 <Igloo> *nod*
08:39:11 <Igloo> I was sorry to see Ding knocked out
08:39:23 <Marvin--> I didn't follow the game that closely, but I guess Hendry simply made a few more mistakes in critical situations than White
08:39:50 <SyntaxNinja> Marvin--: hmmm. quick is not in scope
08:41:12 <Marvin--> SyntaxNinja: bleagh... then you'll have to look at the source for the Config type so you can define a proper config variable
08:42:01 <SyntaxNinja> yeah
08:42:06 <SyntaxNinja> OK thanks.
08:45:10 <Marvin--> what's the proper way to get something changed in one of the libraries? Send a patch to libraries@h.o?
08:47:13 <Marvin--> I think it makes sense to expose a 'defaultConfig' from the library
08:47:53 <shapr> kowey: you need to add -lHSParsec or something to that effect
08:48:59 <shapr> kowey: Parsec was moved into its own package, so you have to include it when linking.
08:49:26 <SyntaxNinja> Marvin--: I'd say "yes" since that's listed as the maintainer
08:49:33 <SyntaxNinja> we need a bug database for this stuff
08:50:02 <Marvin--> yeah
08:50:35 <shapr> kowey: try -lHSparsec
08:51:22 * SyntaxNinja points to gforge
08:51:44 <Marvin--> I'm just thinking of something like http://sjogren.ost.sgsnet.se:8080/QC.hs.diff
08:52:19 <kowey> will do
08:52:30 <SyntaxNinja> Marvin--: makes sense
08:52:33 * kowey stops compiling older version of wxhaskell
09:06:06 <SyntaxNinja> Marvin--: if you're filing a bug report against QC, I have something for you to add :)
09:09:24 <Marvin--> not really, I just sent the patch to the list
09:09:46 <Marvin--> where are bug reports filed anyway?
09:10:45 <Marvin--> I really should prod Koen and John about releasing a new version of QC
09:10:57 <Marvin--> the shrinking stuff in the newer version is nifty
09:10:59 <SyntaxNinja> Marvin--: I just meant posting to the list
09:11:06 <Igloo> shrinking stuff?
09:11:28 * SyntaxNinja points out that the type of "vector" in the user manual is incorrect
09:12:12 <Marvin--> Igloo: yeah, the newer version has a  shrink :: a -> [a]  function in the Arbitrary class, I think the idea is that when you find a counter example, you apply the shrink function iteratively to try to find the smallest counter example possible
09:13:11 <kowey> shapr: it builds!
09:13:12 <kowey> thanks
09:13:42 <Igloo> Oh, cute
09:13:53 <Marvin--> shrink (a,b) = [ (a',b) | a' <- shrink a ] ++ [ (a,b') | b' <- shrink b ]   and so on
09:14:58 <kowey> and the hello world example runs! ok; i need to put all this stuff on HaWiki
09:15:35 <SyntaxNinja> kowey: cool!
09:17:54 <kowey> anyone remember the advice they gave on happy last night? (it's for the wiki)
09:18:06 <Darius> change the LINE pragmas
09:18:15 <SyntaxNinja> what's this about?
09:18:19 <kowey> thx
09:18:29 <SyntaxNinja> oh, nm
09:18:36 * SyntaxNinja was having haddock troubles w/ cpp last night
09:27:48 <kowey> night everyone.  thanks again (http://www.haskell.org/hawiki/HaskellOnMac)
09:35:04 <SyntaxNinja> I think I detect simonMar editing the wiki: HaskellMode	  [05:44] 	 tide136.microsoft.com 
09:40:20 <Marvin--> heh
09:40:47 <SyntaxNinja> shapr: you owe me an email :)
09:41:19 <shapr> I do?
09:41:26 <shapr> oh, I do!
09:41:30 <Igloo> :-)
09:50:42 <Marvin--> the good thing about having a laptop is that I can use it when my desktop computer breaks down
09:50:53 <Marvin--> the bad thing about having a laptop is that I put off *fixing* my broken desktop computer
09:52:55 <Igloo> :-)
09:53:12 <Igloo> What's the purpose of the desktop OOI? The laptop looked shinier enough I would imagine it's higher spec?
09:54:32 <Marvin--> OOI?
09:55:06 <Igloo> Out Of Interest
09:55:26 <Marvin--> both the desktop and the laptop are pretty new and have roughly the same performance, but it gets tiring to type on the laptop keyboard and I have an old non-usb keyboard that I can't plug into the laptop
09:55:56 <SyntaxNinja> soudns like you can sell your desktop and buy a new keyboard ;)
09:56:10 * SyntaxNinja has had trouble keeping track of both the desktop and laptop machines
09:56:14 <SyntaxNinja> I gave up and just use the laptop pretty mich now
09:56:18 <SyntaxNinja> s/mich/much
09:56:26 <Maddas> I should buy a keyboard, too.
09:57:38 <Marvin--> heh, the desktop has way more hard drive, though
09:57:46 <esap> one good combination is to have a laptop with a separate screen and keyboard. The only problem is that laptops are usually quite hard to upgrade, so you need to buy a new one pretty soon.
09:58:14 <Marvin--> and though it happens rarely, I do play some games on the desktop too
09:58:34 <Maddas> esap: In fact, I'm very happy with my laptop screen. (Having two never hurts, of course)
09:58:34 <Marvin--> Warcraft 3 doesn't run very well on a cheap laptop with shared RAM/graphics memory
09:59:00 <Marvin--> but yeah, it's about time to get a new keyboard
09:59:20 <Marvin--> heck, this keyboard is old enough that it doesn't even have a PS/2 connector, it came with a converter plug
09:59:29 <esap> maddas: ok, maybe it's just me, I prefer to have at least 19" monitor
10:00:13 <esap> maddas: so I can put 4 xterms side by side without trouble reading the text :-)
10:00:32 <Maddas> esap: ah, yeah, size of course. I meant quality-wise :)
10:00:46 <Maddas> I should have bought a smaller laptop and a screen, though.
10:01:49 <Marvin--> actually, I have a quite big laptop precisely because I want a decent-sized keyboard and screen
10:02:08 <Marvin--> it's a 14.1" screen or whazzit
10:02:18 <SyntaxNinja> I'm having fun w/ quickcheck, though I'm not sure I'mg etting much testing done ;)
10:02:41 <Maddas> My keyboard *is* decent-sized, but I really don't like the way the keys are distributed
10:02:58 <Maddas> Left shift is just as large as Enter, which is very thin and easy to miss
10:03:03 <Maddas> (Enter is easy to miss, that is)
10:03:13 <Marvin--> SyntaxNinja: :-)
10:03:25 <Maddas> Marvin--: Heh, I find that rather small. :-)
10:03:38 <esap> SyntaxNinja: Sounds like an ideal tool [for anyone writing tools :-) ]
10:03:43 <Marvin--> Maddas: not for a laptop, surely?
10:03:47 <Maddas> Marvin--: I should have gone for a 12" though, I could easily get a 17" TFT or so for the price difference.
10:04:07 <Marvin--> I went for a cheap laptop :-P
10:05:39 <Maddas> Marvin--: Well, standard for laptops, I guess. I do use my laptop as a desktop system, though, so I compare it to normal screens :-)
10:06:59 <Igloo> Maddas: Can 12"s drive 17" monitors at the res they like?
10:07:20 <Maddas> Igloo: Hm, why not?
10:07:23 * Maddas checks
10:07:49 <Igloo> They might have a max res of what their screen can do
10:08:40 <Maddas> Igloo: I think that is limited by the video card, but I'm not sure.
10:10:17 <Igloo> I guess it's less likely nowadays, when they tend to come in with fancy (by my standards) 3D graphics cards as standard
10:10:27 <Maddas> Yeah
10:11:15 <Maddas> Igloo: The 12" PowerBook -- using a GeForce FX Go5200 -- can run a display with 2048x1536 in addition to the 12" display.
10:11:20 <Maddas> Certainly more than I could afford for :-)
10:11:26 <Igloo> :-)
10:16:41 * Lemmih would like to know how old the average Haskell programmer is.
10:17:15 <Marvin--> ooookay, my dad's going a bit over the top with tracking down info for me
10:17:31 <Marvin--> all I did was ask for some hints on good books on axiomatizations and non-standard models
10:17:54 <Marvin--> I've gotten more mails from him today than the past six months ;)
10:18:06 <ski> Lemmih : should we have a poll somewhere ? here ? hawiki ?
10:19:30 <Marvin--> Heffalump: Schiphol ;)
10:19:50 <Heffalump> I'm flying there, yes :-)
10:21:49 <Lemmih> ski: My general impression is that Haskell users are pretty old ( [25..] ). I was just wondering if I was right.
10:24:02 <Heffalump> I'm not.
10:24:09 <Marvin--> er, I bet that the majority of most programming languages fall into that category
10:24:10 <Heffalump> I won't be 25 for a whole week.
10:25:07 * Marvin-- is 23
10:25:23 <ski> i'm 23
10:25:38 <Heffalump> I feel old :-)
10:25:47 <Heffalump> Igloo is 22. I think.
10:26:00 * andersca is 22
10:26:05 <Igloo> I think I'm 23
10:26:14 <Heffalump> I think wrong.
10:26:32 <Marvin--> shapr: get back here and make Heff feel young
10:26:46 <Maddas> Out of interest, since how long do you guys know/use Haskell?
10:27:03 <Igloo> 4.5 years for me. Eeek.
10:27:19 * bring never remembers how old he is
10:27:23 <Heffalump> since I was 18
10:27:25 <Marvin--> something like 4.5 for me too
10:27:27 * bring thinks he's 24
10:27:33 <Heffalump> so this is my 7th year
10:27:49 <ski> ~ 4 years i think
10:27:57 <Heffalump> so 6 and a bit really.
10:28:08 <Lemmih> about 10 days.
10:31:03 <Marvin--> actually, I'd expect the average age of a Haskell programmer to be lower than for a language "widely used" in the "industry"
10:31:11 <Marvin--> since many Haskell programmers are students
10:31:22 <Maddas> Heh
10:31:52 <bring> esp. COBOL programmers
10:32:07 <Maddas> Marvin--: Aren't "widely used" languages much more popular among universities?
10:33:50 <Marvin--> Maddas: more popular than other languages or more popular than at other places?
10:34:06 <Marvin--> I doubt that universities are the main users of programming languages like Java :)
10:34:08 <Maddas> Marvin--: More popular than Haskell :-)
10:34:47 <Marvin--> what I'm saying is that if a language is widely used, its user base is so much larger than just universities
10:34:56 <Igloo> Oxford seems to have moved towards Java to some degree or other due to popularity  :-(
10:35:02 <Maddas> Wait, that doesn't matter much.
10:35:23 <Maddas> Marvin--: Yeah
10:35:34 <SamB> Marvin--: like, say, kids who haven't started college yet?
10:35:49 <Maddas> Igloo: Our university teaches C++ for the beginners and then moves on to Java
10:36:17 <Maddas> Although people majoring in comp. sci. do learn Haskell later on.
10:36:25 <SamB> Maddas: what crazy things unis do!
10:36:36 <Heffalump> you want some kind of OO language, surely?
10:36:38 <Marvin--> SamB: sure, but I still think that post-college (or post-college-age) people are a larger piece of the cake
10:36:40 <Heffalump> we don't do that much of it
10:38:41 <Marvin--> comp.sci. students here do roughly equal parts Haskell and Java the first year
10:39:13 <Marvin--> later courses typically either enforce Haskell or Java or stick to the any-language-will-do policy
10:39:38 <Maddas> I wish we had a any-language-will-do policy.
10:41:13 <Marvin--> fewer and fewer courses here have it, it's just too much work for the teachers
10:42:18 <Maddas> Yeah, I can understand that
10:43:12 <Marvin--> many compromise by saying "you can use any language you like but clear it with the TAs first, oh and we will only be able to answer questions about language X"
10:44:00 <Marvin--> the data communication course I'm taking now lets us write the labs in either Java or *drumroll* C :(
10:45:11 <Maddas> Can you automatically translate Haskell to C?
10:45:26 <Maddas> I'm sure that makes for some annoyingly hard-to-follow C code :)
10:45:47 <SamB> Maddas: well, when GHC does it it still needs to mangle the assembly, I think
10:46:15 <Marvin--> Maddas: I don't think that'd be a good idea :)
10:46:38 <Marvin--> it gets worse, the first programming assignment is to write a multi-threaded web server *groan*
10:46:57 <SamB> it would be easier for them to help you with Haskell than for them to figure out Haskell compiled to C 
10:47:19 <Marvin--> duh :)
10:47:22 <Maddas> haha
11:08:50 <Marvin--> oh for the love of god, can someone hand that car thief a crowbar so he can get on with the stealing and stop triggering the damn car alarm
11:10:59 <stepcut> haha
11:12:34 <Marvin--> seriously, car alarms are a bleeding nuisance
11:12:53 <andersca> I thought they were just noisy
11:14:27 <stepcut> You could file a noise complaint
11:14:40 <Maddas> Againt the car thief?
11:14:42 <Maddas> against, even.
11:14:54 <stepcut> against the car owner most likely
11:15:00 <Marvin--> at a student residence? :) they'll just laugh at me ;)
11:15:18 <Maddas> "I sue you for having an alarm iny our car!" :-)
11:18:39 <Marvin--> brb, gonna get some sweets before the convenience store closes
12:43:04 <ski> hi CrewdenX
12:43:37 <CrewdenX> ski: know me?
12:43:43 <ski> no :)
12:43:54 <ski> just polite
12:44:07 <CrewdenX> lol, ok. hi =)
12:44:23 <ski> what do you know of haskell, then ?
12:44:37 <ski> got any questions ?
12:45:10 <CrewdenX> i've only done really basic programs with it.  haven't looked into it much yet.
12:45:21 <ski> ok
12:45:30 <ski> learning on your own ?
12:45:44 <ski> (i.e. not course ?)
12:45:49 <CrewdenX> on my own
12:46:50 <ski> what do you think, so far ?
12:47:26 <ski> (when you got questions, you can of course ask them here :)
12:48:00 * Marvin-- watches Pleasantville
12:48:00 <cybermanco> on your own!
12:48:07 <ski> which ProgLangs have you used before ?
12:48:08 <Marvin--> this movie is brilliant
12:48:10 <cybermanco> are you masoquist or qhat?!
12:48:12 <CrewdenX> i don't have any just yet.  i've only read one tutorial, i understand (or at least i think i do) what was explained.
12:48:24 <CrewdenX> cybermanco: hmm?
12:48:39 <cybermanco> (sorry my bad english)
12:48:58 <ski> Marvin-- : oh. i for a split second thought you said "Smallville"
12:49:08 <Marvin--> ski: dear god, no
12:49:36 <cybermanco> masoquist I think is a person that likes to cause pain to himself..
12:49:48 <Marvin--> masochist
12:49:51 * ski makes strange noises supposed to be laughing
12:50:44 <Marvin--> ski: careful with the milk and the nose :-P
12:51:13 <ski> (i.e. regarding Marvin--'s TV watching comment)
12:51:16 <CrewdenX> cybermanco: i understand what you're asking, but i don't understand why your are asking it.
12:51:42 <cybermanco> hm.. haskell is boring
12:52:03 <ski> CrewdenX : have you been using any other Functional Programming Languages (FPL) before ?
12:52:10 <cybermanco> I just use it because I have to do some projects for my school
12:52:21 <ski> cybermanco : you think so ?
12:52:26 <Maddas> why is it boring?
12:52:29 <CrewdenX> ski: lisp (and scheme) to a limited extent.
12:52:49 <cybermanco> because i'm used to c
12:53:40 <ski> CrewdenX : ok, so i suppose closures and programming with higher-order functions isn't new to you, then
12:54:11 <Riastradh> cybermanco, does it bore you to think about _what_ algorithm you're writing, rather than all the extra side-issues regarding how the computer works the algorithm?
12:54:55 <CrewdenX> ski: i may not know them by those names.  are higher-order functions those that accept functions are arguments?
12:55:53 <Lemmih> I think Haskell is fun because I'm used to C :)
12:55:54 <ski> cybermanco : don't you sometimes wish C had muli-return-lists and some tuple-matching-looking syntax for cases when you want to return several things
12:56:05 <cybermanco> ski: no :)
12:56:17 <cybermanco> c is perfect for me
12:56:29 <cybermanco> ok.. sometimes I like c++
12:56:30 <cybermanco> :)
12:56:39 <Maddas> Lemmih: Same here
12:57:23 <Lemmih> Are there any binding for libconfuse?
12:57:35 <cybermanco> I have this opinion because I only use c for things that haskell can not do..
12:58:04 <Lemmih> Can C do things Haskell can not?
12:58:14 <cybermanco> yes..
12:58:24 <Lemmih> crash?
12:58:28 <Lemmih> :P
12:58:29 <cybermanco> nop
12:58:34 <Riastradh> Expose needless vulnerabilities?
12:58:35 <ski> CrewdenX : higher-order functions are functions that take function(s) as argument ior return function(s) as result
12:58:37 <cybermanco> realtime rendering :)
12:58:49 <cybermanco> with quality..
12:58:53 <CrewdenX> Lemmih: and idea what haskell compiler you'd use to produce code for an 8051 ?
12:59:15 <Riastradh> cybermanco, how about the logic to _use_ that rendering system, e.g. the logic in a game?
12:59:25 <Riastradh> C will really complicate your life there.
12:59:46 <cybermanco> for that kind of thing we have script langs
13:00:02 <cybermanco> hm
13:00:04 <Lemmih> CrewdenX: I though that Haskell was compiled into C.
13:00:30 <CrewdenX> Lemmih: it can be.  but how much c?  
13:01:00 <ski> Lemmih : Haskell isn't compiled. (Programs written in) it *can* be compiled
13:01:07 <CrewdenX> Lemmih: in practical terms, c has uses that haskell does not.  i wouldn't look down on it for all purposes.
13:01:18 <Riastradh> CrewdenX, the converse is true.
13:01:19 <Lemmih> Well I dont know what a 8051 is so I'm not really qualified to continue this conversation.
13:01:39 <Riastradh> ...the converse is true as well, that is, not to imply that what you said is false.
13:01:45 <Lemmih> CrewdenX: It was more of a joke than a statement.
13:01:49 <ski> some old microprocessor, i guess
13:01:55 <CrewdenX> Lemmih: i see.
13:01:58 * bring doesn't think any single language is appropriate for all tasks
13:01:59 <Lemmih> CrewdenX: I've been using C for years so I should know...
13:02:10 <CrewdenX> ski: old, but very much alive.
13:02:14 <stepcut> I think ghc has a mode that will generate c code....
13:02:26 <cybermanco> haskell is appropriate for what?
13:02:45 <cybermanco> rotate and zoom BMPs
13:02:53 <cybermanco> like the projects i must do for my school?
13:03:08 <Riastradh> cybermanco, for high-level programs.
13:03:17 <ski> CrewdenX : wasn't diputing that :)  people also still program 6502 asm (incl. myself at times)
13:04:00 <CrewdenX> ski: as an embedded developer or emulation hobbiest? =)
13:04:28 <ski> CrewdenX : none :)  (well, define embedded)
13:05:25 <CrewdenX> ski: crudely, the environment that firmware runs in.
13:05:55 <CrewdenX> ski: code that would run in an antilock breaking system, a depth charge, vcr remote, etc.
13:06:17 <ski> CrewdenX : well, what i was alluding to was coding on a (real) C64
13:06:36 <CrewdenX> ski: ah.  ok.  i was thinking maybe you were coding for a nintendo emulator.
13:06:39 <ski> (i.e. hobby :)
13:06:56 <CrewdenX> ski: just wondering if you were interested in console emulation is all.
13:08:15 <CrewdenX> specialized small-stack 6502s are used a now as lcd controllers.
13:09:07 <ski> CrewdenX : well, i've used some nintendo emus and other such ones, but again, who hasn't ? i haven't thought about how they're impl. and so on, though ..
13:09:41 <ski> aha
13:09:49 <CrewdenX> aha?
13:10:11 <ski> no, just an "aha" as in "umhm" or "ok"
13:10:21 <CrewdenX> heh, ok.
13:10:54 <ski> I even had some plans of making a graph reduction ski machine on the C64 ..
13:11:07 <ski> haha
13:11:24 <CrewdenX> what in the c64 interests you?
13:11:58 <ski> (ski, in this case = SKI combinators, somthing lambda-calculus can be compiled into)
13:12:03 <ski> well ..
13:12:20 <ski> i grew up on it :)
13:12:49 <ski> some older brothers were into the Scene then ..
13:13:13 <cybermanco> scene?
13:13:19 <cybermanco> you are into the scene?
13:13:30 <ski> not me
13:13:33 <cybermanco> ha..
13:13:44 <cybermanco> that would be intresthing
13:13:46 <ski> was too young then ;)
13:13:50 <cybermanco> a haskell coder into the scene :)
13:14:49 <ski> but i still love the music :)
13:15:16 <cybermanco> I will try to participate in a party contest this summer
13:15:26 <cybermanco> I will try to make a game in 64KB
13:15:35 <cybermanco> a thing that haskell can't do.. :)
13:15:40 <phubuh> sure you can
13:16:05 <phubuh> if you count the number of bytes in the source code, and disregard the size of the compiled executable :-)
13:17:56 <ski> cybermanco : which platform ?
13:18:04 <cybermanco> windows.
13:18:20 <cybermanco> or dos..
13:18:39 <ski> ok
13:19:12 <ski> well, my bro's was on the amiga at the time
13:19:32 <cybermanco> how old are you?
13:19:33 <Darius> cybermanco: Why don't you code in assembly?  Assembly can do things C can't do.
13:19:46 <ski> cybermanco : 23
13:19:54 <cybermanco> Darius: I code in assembly sometimes
13:20:08 <cybermanco> I did an exam today
13:20:14 <Darius> Why not all the time?
13:20:17 <cybermanco> exam... is a test
13:20:18 <ski> like continuationy things
13:20:40 <cybermanco> because I'm happy with the things I do in c
13:20:59 <cybermanco> I don't need asm
13:21:20 <Marvin--> and we don't need C, we've got Haskell
13:21:54 <cybermanco> Marvin--: ya.. ok.. that's what I said.. for what I want to do, c is better
13:22:24 <ski> cybermanco : just curious, what do you current want to do ?
13:22:25 <cybermanco> but I must do this projects now..
13:22:53 <cybermanco> ski: I read BMPs stored in txts
13:23:02 <cybermanco> transform them in quadtrees
13:23:06 <Marvin--> hint: learning Haskell will make you a better C programmer
13:23:06 <cybermanco> and then
13:23:09 <cybermanco> rotate them
13:23:11 <cybermanco> and zoom
13:23:17 <cybermanco> etc
13:23:24 <cybermanco> that 's what I must do
13:23:30 <cybermanco> till next monday
13:23:36 <Marvin--> sounds like FRAN stuff
13:23:36 <cybermanco> or..
13:23:47 <cybermanco> I am f"#ked
13:23:51 <cybermanco> FRAN?
13:23:56 <cybermanco> what's that?
13:24:24 <Marvin--> FRAN or PAN, I don't remember which is which
13:24:26 <Marvin--> look it up on google
13:25:20 <bring> cybermanco: one interesting thing you could do in haskell would be to create an embedded language that would compile to tight assembly code and use that to write your tiny game
13:26:18 <cybermanco> bring: that is to much for me!
13:26:29 <cybermanco> I can't do this little project...
13:33:46 <cybermanco> I have one question
13:34:00 <ski> yes ?
13:34:17 <cybermanco> what this error means: parse error on input 'where'?
13:34:36 <ski> hmm, perhaps wrong indenting
13:34:44 <ski> what did you write ?
13:35:13 <cybermanco> instace Show Pixel
13:35:14 <cybermanco>   where
13:35:14 <cybermanco>   show (Pix (a, b, c)) ....
13:35:33 <Maddas> it's instance, not instace
13:35:59 <cybermanco> ho..
13:36:04 <cybermanco> I see
13:36:16 <cybermanco> it's working :)
13:36:42 <ski> mm, btw, why not make the Pix constructor curried ?
13:36:56 <ski> any specific reason not to ?
13:37:12 <cybermanco> Picx is defined already
13:37:17 <cybermanco> Pix
13:37:51 <ski> yes, but why does it take a triple ?
13:38:14 <ski> (just wondering about style, there's nothing wrong with it, i think)
13:38:55 <cybermanco> Pix was defined by my teachers..
13:39:01 <ski> ok
13:39:07 <cybermanco> I just use it
13:39:18 <ski> then i guess you didn't have much choice :(
13:50:53 <cybermanco> ski: do you know c--?
13:51:59 <ski> well, i've read a bit about it
13:52:11 <Lemmih> What's wrong with this code:
13:52:11 <Lemmih> data confTree = confLeaf
13:52:11 <Lemmih>                 | confBranch
13:52:25 <ski> cybermanco : why do you ask ?
13:52:53 <ski> Lemmih : Type( constructor)s must start with capital letters
13:53:04 <Lemmih> oh
13:54:01 <cybermanco> because is a functional lang :)
13:54:14 <Riastradh> Uh, no.
13:54:23 <Lemmih> cybermanco: I think it's just Haskell.
13:54:32 <Riastradh> C-- is designed to be easily targetable by functional language compilers.
13:54:32 <ski> what ? c-- is an FP ?
13:54:53 <Riastradh> It is intended to be a portable assembly language, not a functional language.
13:55:47 <cybermanco> hm
13:56:12 <cybermanco> sorry :|
13:56:12 <SamB> it has tail calls, iirc
13:56:25 <Riastradh> Ooooooo.  That must make it a functional language!
13:56:42 * Maddas nods emphatically
13:56:45 <Marvin--> or assembly
13:57:09 <SamB> er, hmm, *need to read more of what has been said before opening mouth*...
14:03:36 <Lemmih> Is there a function to transform a base 16 number to a base 10 or do I have to code it myself?
14:04:41 <Marvin--> err... id :: Int -> Int?
14:05:07 <Lemmih> No, like "ff" -> Int
14:05:14 <Lemmih> String -> Int
14:06:02 <Lemmih> Or more likely: Int -> String -> Int
14:06:33 <ski> Lemmih : perhaps readHex can be of use ..
14:06:50 <ski> @type readHex
14:06:50 <lambdabot> readHex :: Integral a => ReadS a
14:07:13 <Lemmih> In what module is it located?
14:07:41 <bring> I always use: http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
14:07:49 <bring> to look up functions
14:09:38 <Lemmih> thx
14:18:23 <Lemmih> [code] where (hex,_) = readHex (drop 2 t) [/code] It doesn't work because readHex returns [(Num,String)]. How can I get the Num?
14:20:13 <Lemmih> oh wait...
14:21:10 <ski> well, first you should check that the list contains exactly one pair
14:21:20 <ski> if zero, then there is no parse (parse error)
14:21:36 <ski> if more than one, there is amigous parse
14:22:40 * ski *thinks* parsing in e.g. "123" will yield one parse and not three (one for each of "123" "12" "1"), but is not sure
14:22:54 * bring thinks ski is right
14:23:12 * bring thinks maximum munch applies
14:24:13 <Marvin--> maximum munch is a good rule
14:24:14 <ski> also, if there's only gonna be a hex num in that string (i.e. nothing more after it to use), then you should also check that the second element of the single pair is the empty string (otherwise there is no parse)
14:24:17 <Lemmih> It's working and it's also error checking :)
14:25:27 <ski> hmm, isn't there some function that does this checking for you ?
14:25:44 <ski> if not, i think there should be one ..
14:26:11 <Darius> You mean a version that throws an exception?
14:26:30 <ski> accept :: Read a => ReadS a -> String -> Maybe a
14:26:34 <ski> or something ..
14:26:48 <ski> Darius : well, not sure about that
14:27:15 <Marvin--> eh, what is the String parameter for? and what's the Read a => for?
14:27:21 <Lemmih> The code is here if you want to look at it: http://212.242.49.100/HsConf.Haskell
14:27:49 <Marvin--> 404
14:27:49 <ski> well  type ReadS a = String -> [(a, String)]
14:28:07 <Darius> (fmap fst . listToMaybe .)
14:28:20 <Marvin--> ski: yeah, so wouldn't it make more sense with just ReadS a -> Maybe a ?
14:28:31 <Marvin--> or m a if you want a general monad or something
14:28:34 <Lemmih> Ops change the .Haskell with .hs.
14:29:16 <Marvin--> Lemmih: maybe you should look into Parsec, or Koen's ReadP
14:30:04 <Lemmih> Marvin--: I have absolutely no idea of what your talking about :|
14:30:08 <Darius> @type listToMaybe
14:30:18 <ski> Lemmih : you could paste it into http://www.haskell.org/hawiki/HaskellIrcPastePage
14:30:36 <Marvin--> Lemmih: check the library docs, under Text.ParserCombinators
14:31:43 <Marvin--> http://haskell.org/ghc/docs/latest/html/libraries/base/Text.ParserCombinators.ReadP.html is quite convenient
14:32:26 <ski> Marvin-- : um ? where should the String input to the function arg come from, then ?
14:33:27 <Marvin--> ski: um, right, ignore me, I'm tired
14:33:40 <Marvin--> ski: but I don't see why you should need Read a
14:33:58 <ski> well, you're right
14:34:15 <Marvin--> if you've got a ReadS, you already have a parser
14:34:19 * ski is probably also tired. only hasn't noticed yet
14:35:56 <ski> yes, the point, i guess was to be able to apply this 'accept' to 'readHex'
14:36:02 <Heffalump> doesn't ReadP use Parse{c|k} ?
14:36:36 <Marvin--> Heffalump: no
14:36:57 <Marvin--> but it may use the same techniques
14:37:16 <Marvin--> I think it's pretty much what's in his Parallel Parsing Combinators paper
14:37:19 <Heffalump> ah, ok
14:37:26 <SyntaxNinja> l8r all.
16:20:11 <Riastradh> Quick, someone find a good introduction to functional programming for an experienced imperative programmer!
16:22:47 <Pseudonym> Thge book which taught me more than anything else was Peyton-Jones' "The Implementation of Functional Programming Languages".
16:23:18 <Pseudonym> I really understood FP once I knew what was going on under the covers.
16:23:23 <ski> Riastradh : tutorial ?   on web ?
16:23:36 <Riastradh> ski, anything, though a hard book might be excessive.
16:23:50 <Riastradh> It would be most helpful to use Erlang, but any functional language would do, I suppose.
16:25:03 <ski> isn't there some tutorials on Erlang on the site ?
16:25:26 <ski> or aren't those appropriate ?
16:27:13 <Riastradh> The tutorial I found on erlang.org to learn it a while ago was extremely sparse, and assumes prior knowledge of functional programming.
16:27:56 <ski> um, ok
16:28:06 <ski> could well be
16:28:32 <ski> SICP ???
16:29:02 * ski prolly don't know a good answer
16:29:09 <Riastradh> Hmmmm.  I guess it probably would be better for him to have that much material on such a broad subject.
16:29:14 <cleverdra> ski - erlang.org has half of a published book, a (very good -- and more useful than the book in very many ways) language specification, and a number of other code-focused tutorials.
16:30:01 <Riastradh> cleverdra, you probably meant to address me there.
16:30:09 <cleverdra> Riastradh - no, I didn't.
16:30:47 <Riastradh> cleverdra, I was the one asking for such material in the first place.
16:31:17 <ski> Riastradh : so, you've got to convince h[er|im] that FP isn't crap ??
16:31:22 <cleverdra> Riastradh - so?  I meant to answer ski's almost-question about the presence of Erlang tutorials.
16:31:40 <Riastradh> ski, no, he doesn't really have an opinion on it; but he's interested in an Erlang project.
16:31:42 <cleverdra> Riastradh - anyway, I suspect that the O'Caml book would do an experienced imperative programmer good =)
16:41:08 <ham[nwn]> hiho
16:43:30 <ski> hi
16:44:04 <ski> ham[kell] ?
16:44:43 <ham[nwn]> yep :)
16:45:23 <ski> is the thing in [] some status or something ?
16:45:53 <ham[let]> heh :)
16:46:00 <ham[let]> its something like a class
16:46:09 <ski> class ?
16:47:28 <ham[let]> HAM = { ham[x] | let string be concat( ham, x ) , string \in dict or something funny }
16:48:10 <ski> is kell from "the book of kell's" ?
16:48:17 <ham[let]> heh no :)
16:48:27 <ham[let]> ham[kell] ~= haskell :)
16:48:31 <ham[let]> who is kell?
16:48:34 <ski> oh
16:48:39 <ski> who ?
16:48:53 <ham[let]> the book of kell
16:50:03 <ski> well, IIRC it is some old irish handwriting from early medieval or something
16:50:18 <ham[let]> oh :)
16:50:23 <Riastradh> It's the script that the Celts used.
16:50:41 <ski> i'd guess that David Eddings got the name from there
16:50:52 <Riastradh> David Eddings?
16:51:10 <ski> Fantasy writer.  "Seeress of Kell"
16:51:13 <ham[let]> well well :) ham[*] includes a lot :)
16:53:31 <ski> Riastradh : script ?  used for what ?    was it some new testament ?
16:53:48 * ski don't remember
16:54:16 <ski> ham[let] : is nwn = noone, then ?
16:54:29 <ham[let]> nope its neverwinter nights
16:54:33 <ski> aha
16:54:38 <ham[let]> which i enjoy to play :)
16:54:55 <ski> i've seen it a little
16:55:05 <ham[let]> i play it online its fun
16:55:24 <ski> hmm, you've played Baldur's Gate ?
16:55:28 <ham[let]> pen and paper is better tough
16:55:31 <ham[let]> though
16:55:34 <ham[let]> yep
16:56:31 * ski declares : In the year of the turret, our divine lords will walk among us as equals
16:56:37 <ski> (IIRC)
16:56:48 <ham[let]> of the turret?
16:56:50 <ham[let]> :)
16:57:09 <ham[let]> dont you mean torrette :)?
16:57:31 <ski> for some time ago, i knew all those declamations by heart
16:57:56 <ski> ham[let] : i don't know :)
16:58:48 <ski> but, i occacionally cites some BG line, just for fun :9
16:59:02 <ski> You're all buffle-headed !
16:59:15 <ski> Mutt-mungering riff-raff
16:59:29 <ski> This would be a good place for a henge
16:59:55 <ski> Would you tell me a story about trollops and plugtails, pleeease ?
17:00:02 <ski> and so on ...
17:00:20 <ski> perhaps one could enter some of these into lambdabot
17:00:43 <ski> (and possibly other nice quotes)
17:00:52 <ham[let]> ?
17:00:58 <ski> "?" ?
17:01:01 <ham[let]> heh
17:01:06 <ham[let]> buffle headed?
17:01:15 <ski> Imoen says that
17:01:34 <ski> I have the exact pronounciation in my head
17:02:04 <ham[let]> im no native speaker either 
17:02:17 <ski> of english ?
17:02:38 <ham[let]> yep
17:02:53 <ham[let]> heh i am a native speaker of something of course :)
17:03:08 <ski> so what's your native tounge ?  (assuming you have one :)
17:03:20 <Riastradh> Uh oh.  _joey just joined #ocaml.
17:03:51 <ski> Riastradh : he's talking garbage ??
17:03:58 <ham[let]> german
17:04:02 <Riastradh> Nope, he's silent right now.
17:04:04 <ski> ok
17:04:28 <ski> ham[let] : mine is swedish, if you happened not to have gathered that
17:05:07 <ham[let]> i figured it out :)
17:05:17 <ham[let]> it is the best bet in here i think :)
17:05:35 <ski> hmm, maybe 'tis ..
17:07:29 <ski> you were into some algebra stuff or something, do i recall correctly ?
17:08:03 <ham[let]> somewhat yes
17:08:09 <ham[let]> linear algebra mainly
17:08:28 <ham[let]> but always interested :)
17:13:57 <ski> hm, i thought your coalgebra thing resembled Splittable in haskell somewhat
17:14:37 <ski> d2004xx : trying out lots of different irc clients ?  :)
17:14:50 <ham[let]> i think that lists are something like a bi algebra
17:15:00 <ham[let]> that is an algebra with a coalgebra
17:15:05 <ham[let]> +r
17:15:52 <ski> hmm, you can explain, if you feel like
17:16:01 <ham[let]> yep
17:16:12 <ham[let]> but i am totally not sure about that
17:16:39 <ham[let]> i think the most important thing in there is the multiplication
17:16:48 <ham[let]> and algbra in this case is kind of fuzzy
17:16:57 <ski> well, are you talking about F-[|co|bi]algebras  (or whatever it was) ?
17:16:57 <ham[let]> so its more like a monoid
17:17:15 <ski> but dual, right ?
17:17:22 <ham[let]> that freeness thing is something funny :)
17:17:35 <ski> what freeness ?
17:17:44 <ham[let]> F stands for free doesnt it?
17:17:51 <ski> i dunno :)
17:17:56 <ham[let]> i think so
17:18:14 <ski> Darius used that word IIRC
17:18:21 <ham[let]> anyway
17:18:35 <ski> (i thought it maybe stood for functor)
17:18:36 <ham[let]> that monoid has a multiplication and a 1
17:18:36 <Darius> F in F-algebra just names the functor.
17:18:50 <ski> ok
17:19:03 <ham[let]> Darius do you know how freeness is defined?
17:19:26 <ham[let]> ok if you have such a monoid a free one (which definition i cant tell you now :)
17:19:45 <ham[let]> then you have a multiplication in the sense of an append or so
17:20:14 <ski> "Categories and Computer Science, R F C Walters" : What Does Free Mean?
17:20:35 <Darius> The only formal definition I've seen (that I recall) is the left adjoint of a "forgetful" functor.
17:20:53 <Darius> I do get the general idea though.
17:20:58 <Darius> Or at least believe I do.
17:21:11 <ham[let]> someone told me
17:21:14 <ham[let]> but i forgot it
17:21:20 <ham[let]> was a cool sentence
17:22:11 <ski> (there seem to be something about functors and adjoints in this book, but i don't understand it yet)
17:22:58 <ski> you were going to say something about monoid,multiplication and 1 ?
17:23:12 <ham[let]> yes the empty set is the 1
17:23:14 <ham[let]> []
17:23:22 <ham[let]> list in our case
17:23:36 <ham[let]> that concaternation doesnt change anything
17:23:43 <ham[let]> * = concat
17:23:59 <ham[let]> * [] [bla] = [bla]
17:24:10 <ski> i've think i've read somewhere that lists are a free monoid, or something like that, yes
17:24:22 <ski> yes
17:24:33 <Riastradh> instance Monoid [] where midentity = []; mconcat = (++)
17:24:58 <ski> so i guess we have an inclusion (mono) which constructs singletons
17:26:13 <ham[let]> ok so
17:26:17 <ham[let]> * = concat
17:26:22 <ham[let]> and a coalgebra
17:26:34 <ham[let]> or comonoid would be something like
17:26:38 <ham[let]> head
17:26:49 <ski> ?
17:27:05 <ham[let]> c* : [list] -> [l] x [ist]
17:27:45 <ski> would lists be instances of that comonoid ?
17:27:58 <ham[let]> elements
17:28:17 <ham[let]> its just a structure over a set if you want
17:28:54 <ski> you mean that the operation splits a list (in the case of lists) into it's head and tail ?
17:29:09 <ski> what about the empty list ?
17:29:46 <ham[let]> hm a counit
17:29:58 <ham[let]> i think its also the []
17:30:39 <ski> in monoid the operation has type  a * a -> a  for the a in question, right ?
17:30:53 <ham[let]> yep
17:31:15 <ski> in comonoid, 'twould have the type   a -> a * a  then ?
17:31:42 <ham[let]> yep
17:31:48 <ski> so what if a is e.g. [b]  (i.e. lists over some b)
17:32:00 <ski> [b] -> [b] * [b]
17:32:19 <ski> then what happens when this is applied to [] ?
17:32:33 <ski> 'twould return a pair of empty lists ?
17:32:36 <ham[let]> [] -> [] x []
17:32:43 <ski> ok
17:32:45 <ham[let]> i would say so yes
17:33:09 <ski> so now i guess this op. should be coassociative, right ?
17:33:55 <ham[let]> yep
17:34:02 <ski> so what does that mean ?
17:34:28 <ham[let]> http://planetmath.org/encyclopedia/Coalgebra.html
17:34:57 <ham[let]> if i would only know that :)
17:35:06 <ham[let]> usually its all dead easy
17:35:13 <ham[let]> but one lacks of an example
17:35:33 <ski> forall x. (let (x0,x1) = op x in let (x00,x01) = op x0 in (x00,x01,x1)) = (let (x0,x1) = op x in let (x10,x11) = op x1 in (x0,x10,x11))
17:35:36 <ski> ?
17:36:00 <ski> i would guess something like that
17:36:34 <ski> i.e., if you split it, and then split the first, you get the same as splitting it and then split the second
17:37:04 <ham[let]> ah ok
17:37:24 <ski> isn't this dual to take a triple as input and then combine them in the two different associative ways, to check equality
17:37:45 <ski> do you think this might be reasonable ?
17:38:05 <ham[let]> heh dunno :)
17:38:16 <ham[let]> you mean a triple = monad?
17:38:19 <ski> noo
17:38:30 <ski> triple == plain ole' 3-tuple
17:38:36 <ham[let]> ah ok :)
17:38:48 <ski> associative is, i think :
17:39:08 <ham[let]> a x ( b x c ) = (a x b ) x c
17:39:14 <ham[let]> a x ( b x c ) = ( a x b ) x c
17:39:22 <ski> forall x. let (x0,x1,x2) = x in (x0 * x1) * x2 = x0 * (x1 * x2)
17:39:32 <ski> yes
17:40:18 <Darius> ski: categorically the way you'd say the results are equal up to associativity is, f;fxid = f;idxf which should look familiar.
17:40:33 <ski> (only i explicitely took apart a triple into three parts first, supposed to be dual to constructing the triples in coassociativity)
17:41:13 <ham[let]> commute right?
17:41:41 <ski> Darius : yes, i think there was some kind of diagram of that on some page ham[kell] (i think) referred to, last time we talked some on this
17:41:53 <ham[let]> (delta (x) id) concat delta = (id (x) delta) concat delta
17:41:59 <ham[let]> thats what the site says
17:42:11 <ham[let]> though i wonder what that really means
17:42:29 <ski> http://planetmath.org/encyclopedia/Coalgebra.html
17:42:32 <ham[let]> delta : A -> A (x) A
17:43:04 <ham[let]> ok so what in hell then is (bla (x) bla) concat (bla (x) bla) ???
17:43:32 <ski> ?
17:43:38 <ham[let]> look at the page
17:43:42 <ham[let]> that coassociativity
17:44:08 <ski> where's concat on that page ?
17:44:14 <ham[let]> 0
17:44:15 <ham[let]> er
17:44:16 <ham[let]> o
17:44:25 <ham[let]> that circle
17:44:34 <ski> isn't that composition ?
17:44:39 <ham[let]> ah ok :)
17:44:49 <ham[let]> yes then /s/concat/compo :)
17:45:03 <ham[let]> anyway how can you compose that?
17:45:55 <ski> sorry, is there some type problem ?
17:46:21 <ham[let]> im just confused by that
17:46:31 <ski> by which ?
17:46:46 <ham[let]> the line in wich it says coassociative
17:46:58 <ham[let]> (delta (x) id) comp delta = (id (x) delta) comp delta
17:47:15 <ski> hmm
17:47:33 <ski> well, think of our x as coming into the pipe from the right
17:47:38 <ham[let]> (delta (x) id) comp delta (z) = (id (x) delta) comp delta (z)
17:47:50 <ski> the first delta splits it into a pair (x0,x1)
17:48:10 <ham[let]> (delta (x) id) comp (bla (x) bla) = (id (x) delta) comp (bla (x) bla)
17:48:41 <ham[let]> ok now i dont see a way to compose that
17:49:01 <ski> (z) ?
17:49:10 <ski> (bla (x) bla) ?
17:49:21 <ham[let]> thats a function
17:49:30 <ski> where ?
17:49:38 <ham[let]> f = (id (x) delta) comp delta
17:49:44 <ham[let]> f(z)
17:49:51 <ham[let]> ... and so on
17:49:54 <ski> oh
17:50:06 <ski> thought (z) was some operator like (x)
17:50:13 <ham[let]> nah sorry
17:51:30 <ham[let]> you see my prob?
17:51:42 <ham[let]> if i apply that element from right to left
17:51:55 <ham[let]> i get some of that (bla (x) bla) things
17:51:59 <ski> well, i see it as the right-most delta is splitting the input z, then the (f (x) g) maps f and g "pointwise" over the two elements in the pair, constructing a pair from the results again
17:52:15 <ski> no, i don't see it :(
17:52:26 <ham[let]> hm
17:52:32 <ham[let]> the please eval that
17:52:43 <ham[let]> (id (x) delta) comp delta (z)
17:53:32 <ham[let]> for me the thing on the left is no function
17:53:34 <ham[let]> but an element
17:53:56 <ski> ((D * id) . D)(x) = (D * id)(D(x)) = (D * id)(x0,x1) = (D(x0),id(x1)) = ((x00,x01),x1)
17:54:09 <ski> on the left of comp ?
17:54:16 <ham[let]> (id (x) delta)
17:54:26 <ski> id is a function
17:54:31 <ski> and so is delta
17:54:53 <ham[let]> hm ok you got a point there :)
17:55:09 <ski> so i'd think (x) is here overloaded as "pairwise" application/mapping of id and delta
17:55:11 <ham[let]> but then
17:55:18 <ham[let]> its not the same is it?
17:55:33 <ham[let]> ((D * id) . D)(x) = ((id * D) . D)(x)
17:55:56 <ski> it's not the same as the "type constructor" (x) in e.g. delta : A -> A (x) A   no
17:56:00 <ski> (i think)
17:56:19 <ski> i would think of (x) as a (bi)functor
17:56:40 <ham[let]> ((x00,x01),x1) = (id * D)(D(x)) = (id * D)(x0,x1)
17:56:44 <ski> and the overloaded use of it as it's mapping function/morphism for arrows
17:57:11 <ski> well
17:57:12 <ham[let]> ((x00,x01),x1) = (id * D)(D(x)) = (x0,D(x1)
17:57:20 <ham[let]> ((x00,x01),x1) = (x0,D(x1))
17:57:31 <ham[let]> to me that does not look quite the same
17:57:35 <ski> obviously they take for granted associativity of pairing operation
17:58:18 <ski> ((x00,x01),x1) = (x0,(x10,x11))
17:58:21 <ham[let]> i just dont understand what the comp does here
17:58:42 <ski> i guess it composes two functions ?
17:59:04 <ham[let]> but then its only true if its both id
17:59:46 <ham[let]> hi
17:59:48 <ham[let]> :)
17:59:55 <ham[let]> hes got the rythm! :)
18:00:03 <ski> it seems, with this perhaps naive interpretation of (x) as pairing, that x00 = x0 and x01 = x10 and x1 = x11 must be the case for the coassociativity law to hold
18:00:45 <ski> ham[let] : what ?
18:00:57 <ham[let]> shapr has got the rythm :)
18:01:07 <ham[let]> the sleep rythm
18:01:23 <ham[let]> im a hacker and im ok]
18:01:37 <ski> i sleep all night and i work all day ?
18:01:47 <ham[let]> right :)
18:01:52 <ham[let]> no :)
18:02:19 <ham[let]> i work all nicht and i sleep all day :)
18:03:00 <ski> they did that in german also IIRC :)
18:03:28 <ham[let]> do you know the lisp song?
18:03:41 <ski> For god wrote the world in lisp ?
18:03:52 <ham[let]> sec
18:04:11 <ham[let]> http://www.cs.unm.edu/~williams/cs257/the_eternal_flame_god_wro.mp3
18:05:34 * shapr awakens
18:05:39 <shapr> good morning #haskell!
18:05:47 <ham[let]> :)
18:05:57 <ham[let]> shapr you got the rythm :)
18:05:59 <ski> shapr : good *night* !
18:06:00 <shapr> yes, I got the rhythm
18:06:04 <ham[let]> :)
18:06:05 <shapr> good night ski!
18:06:09 <ski> :)
18:06:10 <ham[let]> bye
18:06:24 <shapr> it's weird to wake up at 3am
18:06:31 <ski> ham[let] : you're leaving now ?
18:06:44 <ham[let]> nope
18:06:49 <shapr> no, I think it's a confusino between good morning and good night
18:06:52 <ham[let]> and nope :)
18:06:56 <shapr> good night *usually* means someone is leaving
18:07:04 <ski> i know :)
18:07:06 <shapr> but in this case, we woke up at night, so it means good morning!
18:07:11 <shapr> goood night #haskell!
18:07:13 <ski> but not this time !
18:07:24 <cleverdra> good evening, #Haskell
18:07:27 <shapr> that really is confusing.
18:08:04 <shapr> hello cleverdra, weren't you located on a large floating piece of metal for some time?
18:08:06 <ski> ham[let] : well, i can't listen to that here unfortunately, so i can't tell
18:08:11 <cleverdra> ham - Monster Magnet refers to a 'flame god' (though not 'the eternal flame god') in their Kiss of The Scorpion song.
18:08:42 <cleverdra> shapr - er, no =)  Why do you ask?
18:08:51 <shapr> sorry, confusion on my part
18:08:55 * shapr quickly drinks coffee
18:09:21 <shapr> has anyone else tried HaskellDB?
18:09:28 <Riastradh> shapr is fantasizing you commanding an aircraft carrier to shoot down the imperialist imperativist evil programmers.
18:09:35 <ski> shapr : here's btw a funny song in swedish : http://home.no.net/snthall/launchpad/documents/fun/jattehaftiga_hacket.txt
18:10:08 <shapr> neat, a swedish programmer song.
18:10:39 <ham[let]> :)
18:10:44 <ham[let]> listen to that song
18:11:00 <ham[let]> does anyone know the band elaikelaist?
18:11:09 <ham[let]> (spelling errors included)
18:11:31 <ski> is that (supposed to be) swedish ??
18:11:41 <shapr> it goes here, it goes there, it goes downwardly recursive, now it starts to backtrack, yes this is a righteous hack
18:11:50 <ham[let]> they make hummpa
18:12:09 <ham[let]> hm swedish i dont know
18:12:22 <ski> just guessed
18:12:52 <shapr> how do I translate jattehaftiga?
18:12:55 <ham[let]> http://www.humppa.com/eng/indexeng.html
18:13:02 <ski> shapr : well, hmm
18:13:09 <shapr> I know it means strongly intense or something
18:13:12 <ski> "very cool" perhaps
18:13:16 <ham[let]> finnish :)
18:13:18 <shapr> yes, okay
18:13:44 <ham[let]> jattehaftiga = karss :)
18:13:45 <ham[let]> er
18:13:48 <ham[let]> jattehaftiga = krass :)
18:13:59 <ski> in finnish ?
18:14:04 <ham[let]> no in german
18:14:14 <shapr> ich habe keine ahnung!
18:14:19 <ham[let]> krass is something like that strong intense thing
18:14:30 <shapr> jag har ingen aning!
18:14:31 <ham[let]> tried to explain that to an aussie
18:14:34 <ham[let]> heh
18:14:44 <shapr> wow, this really is a cool song
18:14:47 <shapr> I want an mp3
18:14:49 <ham[let]> :)
18:14:55 <ham[let]> that lisp song?
18:15:02 <ski> i think i know the melody
18:15:10 <shapr> this "mad programmer" song
18:15:28 <ski> at least the chorus
18:15:42 <ham[let]> its an ethernal flame coversonf
18:15:44 <shapr> oh, I'm learning new words too
18:15:44 <ham[let]> song
18:15:58 <shapr> yah, I gotta save this.
18:16:11 <ski> shapr : i thought you might find it interesting :)
18:16:31 <shapr> thanks!
18:16:32 <ham[let]> where can i get that song?
18:16:36 <ham[let]> hi esap
18:16:39 <shapr> you know I'm a swedish junkie
18:16:42 <shapr> hei Esa
18:16:46 <shapr> do you like humppa?
18:16:51 <ham[let]> me?
18:16:56 <esap> shapr: no, I don't.
18:16:59 <ham[let]> i find it really funny :)
18:17:09 <ham[let]> though i dont understand a word
18:17:16 <ham[let]> and was told its better this way :)
18:17:21 <shapr> I lived in a 75% humppa town for three years. I got REALLY tired of it.
18:17:39 <ski> ham[let] : on the url above ?  or did you mean mp3 or something ?  then, i have no idea :(
18:18:06 <ski> esap : hi
18:18:12 <ham[let]> ???
18:18:20 <esap> ski: hi
18:18:29 <ham[let]> you were talking about a sonf
18:18:31 <ham[let]> song
18:18:31 <shapr> Finland is great, but the town I lived in reminded me of some of the really backwoods towns in Alabama.
18:18:37 <ski> ham[let] : ?   mutual confusion ?  :)
18:18:37 <ham[let]> a mad programmer sonf
18:18:39 <ham[let]> song
18:18:41 <ham[let]> yes
18:18:46 <ham[let]> my normal state
18:18:48 <ham[let]> :)
18:19:03 <ham[let]> shapr heh :)
18:19:05 <ham[let]> rednex
18:19:16 <esap> shapr: I've never been to Alabama, so I wouldn't know :-)
18:19:18 <shapr> One of my friends was watching these Tornio people dancing to humppa and he said "It's terrible what they do to tango, it's like they're moving cupboards"
18:19:44 <ham[let]> hehehehehehahhaheheh
18:20:13 <shapr> esap: I was lucky, I spent time in Oulu and Helsinki and realized that my impression of Tornio was by no means standard finnish.
18:20:21 <shapr> Oulu was a blast.
18:20:29 <shapr> Helsinki gave me a massive hangover.
18:20:53 <esap> shapr: but yes, Tornio is quite far from anything
18:21:05 <shapr> esap: lucky for the rest of the world ;-)
18:21:13 <ski> heh
18:21:24 <shapr> there are bunches of small Alabama towns that are like that too.
18:21:59 <shapr> I lived in a place in Tenneessee that had the record for the most recent attempt at hanging another person for being black :-(
18:22:07 * shapr sighs
18:22:33 <shapr> happily, I think people in general are improving.
18:22:48 <ski> maybe
18:23:05 <shapr> well, it seems so to me.
18:23:22 <shapr> smalltown Alabama is being forced to join the rest of civilization.
18:24:02 <ski> i guess it can be both good and bad ..
18:24:05 <shapr> As much as I like Alabama, I do hope all the prejudice is uprooted at some point.
18:24:15 * shapr is waaay off-topic.
18:24:37 * esap is writing an ordinal number module.
18:24:49 <shapr> oh, do you have the source online?
18:25:17 <esap> I can put it somewhere for you to see
18:25:19 <ski> shapr : you could say that you were planning to compare this prejudice with prejudice of FP, perhaps even defining homomorphisms on your way :)
18:25:29 <shapr> haha
18:26:09 <shapr> I'm prejudiced and against prejudiced people.
18:26:18 <Darius> esap once you have an ordinal number module what are you going to do with it?
18:26:19 <ski> very good
18:26:38 <esap> http://www.kotiposti.net/epulkkin/OrdinalNumber.lhs
18:26:44 <ski> esap : count to *big* cardinals ?
18:27:17 <esap> darius: well I just want to understand them well enough to see what kind of support I need to implement them :-)
18:28:51 <ski> shapr : i think it's good to be a little schizofrenic about some things ;)
18:29:27 <esap> darius: Another point is, I just realized that maybe cardinals can be represented using Rec, but I need ordinals to prove that, I think.
18:30:33 <ham[let]> ok am leaving
18:30:42 <ski> ham[let] : bye
18:30:43 <ham[let]> bis gleich :)
18:35:14 <ski> would perhaps be interesting to compute with general order-numbers or perhaps even relation-numbers
18:35:28 <esap> darius: I'm wondering if I'm getting the representation correct, because I can implement a largest ordinal, which doesn't seem like a good idea :-)
18:35:31 <ski> hm
18:36:15 <ski> esap : is it a largest fixed-point ?
18:38:06 <esap> ski: well it's interesting that it's actually not [you can use successor on it, and you get at least in principle a different one. But it has the property that any comparison with other ordinals will go to an infinite loop].
18:39:50 <ski> problem is possibly that one can write non-terminating programs in haskell (?)
18:40:01 <ski> (general recursion)
18:41:20 <esap> ski: yes. OTOH, I can't really say that my largest_ordinal is a set [that's the theorem, a collection of ordinals is not a set, because the comparison (=membership) does not terminate for it]
18:41:21 <ski> (hm, perhaps an order-number is an (iso-class of) object is a category of those)
18:42:09 <ski> esap : does it terminate for other ordinals (not built upon this one, i.e.)
18:42:15 <ski> ?
18:42:16 <esap> ski: yes.
18:43:00 <esap> ski: I think so, at least.
18:45:00 <esap> omega is represented by 'omega = LimitOrd (In ZeroOrd)'
18:45:17 <ski> esap : do you think one could make a category of ordinals ?
18:46:12 <esap> ski: I guess yes, but I'm not completely sure.
18:46:30 <ski> perhaps it would just be the preorder degenerate case
18:46:52 <esap> ski: that's why I'm doing this, I want to understand ordinals better :-)
18:46:55 <ski> (probably not, if we have general order-numbers instead of just ordinals)
18:48:05 <ski> (LimitOrd makes ordinals without immediate predecessor)
18:48:57 <ski> esap : i guess you could define + and * and so on ..  is fold_ord sufficient for that ?
18:50:28 <esap> ski: I haven't got that far, but I suppose it should be possible [thought the types will get kind of interesting]
18:52:01 <ski> (perhaps dependent or mult-arg-classes w/ fun.dep. ?)
18:52:30 <esap> actually, now that I try to compile it, fold_ord doesn't work.
18:53:40 <ski> esap : hmm, functions (on say R) is not a set for there 'sn't a (decidable) membership relation ?
18:54:36 <esap> ski: no, it's because for ordinals, membership is the same as 'less-than'.
18:55:28 <esap> ski: and you get a Burali-Forti paradox due to requirement that ordinals are well-founded.
18:55:52 <ski> you seemed to mean that ordinals wasn't a set because there wasn't a decidable membership on them
18:56:02 <esap> ski: and the only way out of that is to declare that the set of all ordinals is not a set.
18:56:18 <esap> ski: s/set of all ordinals/collection of all ordinals/
18:56:29 <ski> (of course)
18:56:48 <esap> ski: the undecidable membership is a consequence of the paradox, I think.
18:57:21 <esap> ski: it's only possible because I use general recursion [to define the collection of all ordinals]
18:57:24 <ski> i think i roughly get it
18:58:54 <ski> if 'omega = LimitOrd (In ZeroOrd)' then what is omega * omega ?
18:59:25 <ski> (i.e. omega + (omega + (omega + ...)) )
19:00:02 <esap> I haven't got that far, I guess LimitOrd (LimitOrd (In ZeroOrd)) or something, but I'm not entirely sure.
19:00:18 <ski> hm, was going to suggest something like that
19:00:56 <ski> though + is noncommutative, so it can't be a coproduct in the ordinary sense
19:01:14 <esap> coproduct?
19:01:26 <ski> in the category of (at least) ordinals
19:02:23 <esap> right, I'm pretty sure + is not the same as coproduct.
19:03:08 <ski> it seems somewhat similar though, i think
19:03:51 <esap> I would expect I would be able to write + in terms of fold_ord [but of course, I need to make the fold thing work first :-)]
19:04:48 <ski> was there type error ?
19:04:52 <esap> yes
19:05:21 <esap> the LimitOrd case doesn't work, because it tries to unify 'a' with Rec Ordinal.
19:06:52 <ski> if we had ListF a x = 1 + a * x  and then List a = Rec (ListF a)
19:07:07 <ski> would Ordinal be similar to ListF or List or none ?
19:08:04 <esap> more like List, I guess.
19:08:50 <esap> but it's somewhat a mixture of those. It's all due to the "collection" nature of ordinals
19:09:11 <ski> so then fold :: (OrdinalF a b) -> Ordinal a -> b  or something like that, perhaps ?
19:09:25 <esap> ski: yes, of course.
19:09:40 <ski> um fold :: (OrdinalF a b -> b) -> Ordinal a -> b
19:10:04 <esap> hmm.. no, I think the first was right.
19:10:41 <ski> but for list we have  fold :: (ListF a b -> b) -> List a -> b  no ?
19:11:21 <esap> oh hmm.. ok maybe I'm mixing with one of my types that had the name ListF :-)
19:11:56 <esap> for which foldr could be written as    fold :: ListF a b -> [a] -> b
19:12:19 <ski> hmm ListF a b -> b = 1 + a * b -> b = b * (a * b -> b)
19:12:35 <ski> (using my ListF above)
19:13:23 * esap has to get some sleep. [5am]
19:13:43 <ski> mm
19:14:08 <ski> well, you go do so, then ..
19:14:17 <esap> ok, see you later.
19:14:24 <ski> bye
19:15:25 <ski> well, i think i'll bike home too
19:15:47 <ski> so bye #haskell
21:53:09 <shapr> yow!
21:53:24 <shapr> hello noclouds, looking for Haskell info?
21:53:53 <noclouds> hi
21:54:16 <noclouds> i am a newbie on Haskell
21:54:32 <shapr> do you have any specific questions?
21:54:57 <shapr> hey Verbed 
21:55:06 <Verbed> Hello
21:55:47 <noclouds> no for now, tx
21:56:03 <shapr> ok, feel free to ask any questions you discovec.
21:56:06 <shapr> discover
21:56:11 * shapr goes off to make coffee
21:57:16 <Pseudonym> Mmmm.  Coffee.
22:01:32 <Verbed> I have a pot of Chai tea.
22:59:47 <shapr> yow!
23:05:57 <andersca> hej shapr
23:44:29 <kowey> bonjour shapr, hi all
