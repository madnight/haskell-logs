00:04:58 <skew> does anybody here know much about finalizers?
00:12:12 <Pseudonym> OK, the power is about to go out here, so I have to go.
00:12:17 <Pseudonym> Nytol!
00:12:20 <Pseudonym> Have a good weekend and all.
00:45:48 <hasky|ghosted> what does the error "*** Exception: ((Loop))" mean?
00:46:45 <skew> it means your program ran forever
00:47:10 <skew> or rather, that GHC detected and broke out of an infinite loop
00:47:17 <skew> (Hugs uses a different message)
00:49:26 <hasky|ghosted> hmmm right
01:27:51 <skew> done anybody know much about rewriting systems?
01:28:59 <skew> I think they might be useful for a problem I've got, but I don't know what to look for
01:38:03 <skew> Is anyone at all listening on #haskell, for that matter?
01:47:02 <musasabi> no
01:47:19 * musasabi does not really know much about them
01:47:30 <skew> ah, okay then
01:47:42 <skew> how about coinduction?
01:48:35 <skew> I want to check whether a statement is in the *greatest* fixed point of a set of inference rules
01:48:46 <skew> or something like that
01:50:50 <musasabi> well you would probably write a system of rewriting expressions/trees
01:51:34 <musasabi> then you would prove that making a series of given reductions will produce the greatest fixed point
01:51:40 <skew> I can model the situation with rewrite rules and maybe use some results that way
01:52:06 <musasabi> and then perform all the reductions that apply (avoiding loops) and then use a simple comparison
01:52:24 <skew> by greatest fixed point I mean the (infinite) set of terms admitting a possibly infinite derivation
01:53:05 <skew> I don't see how to do that with rewrite rules
01:54:02 <musasabi> what are you trying to rewrite?
01:54:04 <skew> what do you mean about a series of given reductions that produce the greatest fixed point?
01:54:22 <skew> It's a problem that comes from the type class system
01:55:02 <skew> there's a natural interpretation of a regular instance derivation as a recursive instance dictionary
01:55:35 <skew> and of an infinite irregular derivation as a dictionary that encapsulates the inference rules and applies dictionary transformers on demand
01:55:47 <skew> with some polymorphic recursion mixed in
01:56:33 <skew> I've been thinking a little more theory would be nice
01:57:27 <skew> a nice target would be a nicer restriction than the H98 rule that proves derivations must be regular at worst
01:58:18 <skew> hey, the Cameleon page probably links to some papers that would be pretty relevant
03:20:50 <skew> Chameleon doesn't seem to like recursive instances
04:53:45 <Marvin--> ugh
04:54:58 <Lemmih> Indeed.
04:55:08 * Marvin-- is tired
04:55:20 <Marvin--> (read: hungover)
05:13:26 <shapr> @yow !
05:13:26 <lambdabot> I'm GLAD I remembered to XEROX all my UNDERSHIRTS!!
05:13:35 <shapr> good morning #haskell!
05:14:36 <shapr> howzit goin?
05:15:02 <Marvin--> ugh
05:15:10 <Si\> 19 pages done, nother 41 to go...
05:15:33 <shapr> Marvin--: in finnish they call it krapula
05:28:03 <liiwi> or kankkunen, by more familiar name
05:28:44 <shapr> I like krapula, it sounds great in english
06:15:10 <shapr> I'm getting tired of these chinese spammers on HaWiki
06:17:05 <Marvin--> huh?
06:17:57 <Marvin--> wiki spam? that's new to me
06:18:10 <shapr> this is is the second or third time they've put stuff in there
06:18:24 <shapr> oh, it's becoming popular, sadly
06:18:52 <shapr> but I've thought of a bizarre solution
06:18:59 <skew> yay
06:19:20 <shapr> keep a wiki in a darcs repo, and only pull from those whose changes interest you
06:19:32 <skew> hmm, that's nice
06:19:40 <shapr> I have a demo up
06:19:50 <shapr> but no ne's changed it :-)
06:19:53 <skew> you'd probably want to automate it a bit more though
06:20:02 <shapr> how so?
06:20:09 <shapr> cron darcs pull?
06:20:28 <skew> if the wiki changes a lot, you would have to accept a lot of patches by hand
06:20:33 <shapr> hoi dr_fripp 
06:20:37 <dr_fripp> heya
06:20:41 <shapr> I think you dan pull -a
06:20:46 <shapr> "can"
06:20:57 <skew> but then you get the spam
06:21:02 <shapr> I still can't type very well with this new layout
06:21:05 <dr_fripp> that rhymes
06:21:09 <skew> in theory at least, if everybody starts using darcs for their wiki
06:21:27 <skew> in practice the chinese spammers just go to a wiki not run with weird software
06:21:34 <shapr> skew: nah, you only get spam if you pull from the wrong people
06:21:55 <skew> oh, pull -a doesn't grab everything without asking?
06:22:10 <shapr> sure it does
06:22:30 <shapr> but there's no central wiki server
06:22:36 <skew> oh, you have to pull from all the other people. How do you find them in the first place?
06:22:52 <shapr> just like orkut
06:23:12 <shapr> I pull from you, so people who know me can find you
06:23:43 <shapr> they pull from me, they see that I pull from you...
06:24:06 <shapr> also, you don't have to pull from each other person
06:24:16 <ozone> shapr: the real question is ... do you trust me?
06:24:21 <shapr> the people that you pull from are a filter themselves
06:24:34 <ozone> remember, all australians are convicts, and thus lying bastards
06:24:41 <shapr> ozone: totally, at least until yos start spamming me
06:25:04 <shapr> wait till you hear what all USians are
06:25:33 <Igloo> But all functional programmers are wonderful people. Contradiction. Universe explodes!
06:25:53 <shapr> so, I just need to get enough people together to make some worthwhile traffic
06:26:29 <shapr> plus this should stretch darcs a bit
06:27:34 <shapr> party time, bbl
06:55:37 <SyntaxNinja> Igloo: I re-ran mini-dinstall
06:56:02 <Jon> hi chaps, here's a question for you
06:56:11 <Jon> imagine that you had a tool which maintained associations of documentation to code
06:56:15 <Jon> so it was a repository of associations
06:56:25 <Jon> and some tool would use this info to display your code, and highlight bits which were 'annotated'
06:56:43 <Jon> consider that the tool has a parser for your language of choice, in this case haskell
06:57:00 <Igloo> Ta
06:57:18 <Jon> and that associations are only allowed to be associated with some logical 'chunk' of the code 
06:57:23 <Jon> e.g. a function definition, or call
06:57:43 <Jon> the tool's job is partly to determine if the code has changed, and if so, what changed, and is the doc potentially out of date?
06:58:11 <Jon> so an association between some doc and the use of a function 'foo' would be considered out of date if the program could detect that the function foo had its definition changed since the association was made
06:58:36 <SyntaxNinja> Jon: sounds cool.
06:58:40 <Jon> glad you think so :)
06:58:44 <Jon> I'm building this tool atm
06:59:02 <Jon> I have one that relies on hashing whole files and now I'm going to experiment with one that uses the code's semantics
06:59:27 <Jon> I was thinking, a functional language like haskell would be easier for experimentation purposes, due to the lack of side effects - fewer rules of waht could effect what to have to consider
06:59:51 <Jon> I may resort to an even simpler language though, as I'm on a bit of a deadline right now...
07:00:08 <SyntaxNinja> Jon: are you aware of the haddock tool? or are you writing something from scratch?
07:00:30 <Jon> its from scratch
07:00:36 <Jon> I'm vaguely aware of the haddock tool and similar
07:01:24 <Jon> the focus of my work is on annotating code externally, without touching the code at all - so you can maintain documentation for something you don't write yourself, like the linux kernel for example
07:01:44 <SyntaxNinja> but is it for specifying APIs?
07:02:11 <Jon> no, its really just an electronic replacement for a notepad :)
07:02:22 <Jon> I started off when I was frustrated about drawing diagrams and stuff about data structures
07:02:45 <Jon> its a uni project so my focus is on the writeup rather than a really useful tool atm
07:03:23 * Igloo wonders if anyone is going to AFP
07:03:36 <SyntaxNinja> IC
07:03:56 <Igloo> Jon: Which uni?
07:04:41 <Jon> Igloo: durham uk
07:05:20 <Igloo> Jon: If foo calls bar and bar is changed, would your tool ask you to make sure the documentation of foo was still right?
07:05:27 <Jon> thats correct
07:05:37 <Jon> it changes the highlight colour and you need to use a verify operation
07:06:05 <Igloo> e.g. bar might be changed so you can't pass it a negative integer, and foo's documentation might say that is OK. It would pick that up?
07:06:58 <SyntaxNinja> Jon: are you working between compilation units?
07:07:04 <SyntaxNinja> or just intra-module
07:07:32 <Jon> my intention is that the parser will know when a definition has changed, perhaps by storing hashes of the definitions at association creation time. so the hope is that if bar's definition changed, it would be picked up
07:07:53 <Jon> it all operates at file level at present though
07:08:03 <Jon> so an annotation on foo would only be considered 'tainted' if foo's file changed
07:08:12 <Jon> v. primitive
07:10:10 <Jon> one thing I considered doing was computing a slice on the annotated chunk (in a variable-driven language); and then hashing the slice
07:10:45 <SyntaxNinja> what would the chunk for a slice be?
07:11:08 <SyntaxNinja> so you annotate functions still? or any code that touches the slice?
07:11:30 <Jon> SyntaxNinja: the mechanism for calculating what-depends-on-what will dictate what 'things' can be annotated
07:11:42 <Jon> so in the case of a variable-driven language and a slicing tool, variables will be annotated
07:11:53 <SyntaxNinja> Jon: or lines could be annotated too, 'eh?
07:11:57 <Jon> I'm still working out in my head how it would work in a simple fun language and whether that would be easier
07:12:00 <SyntaxNinja> well, statements
07:12:30 <Jon> yeah I think that would be more useful, to have more free-reign over what you annotate
07:12:32 <SyntaxNinja> you're talking about slicing on a variable, right? so any statement that contains a variable that is in the slice would be tainted
07:12:48 <Jon> yep
07:13:23 <SyntaxNinja> actually, you might want to become more aware of Haddock.  it has module-level annotations and function-level annotations, and it already does parsing of formatted comments and type sigs
07:13:38 <SyntaxNinja> (at least)
07:14:22 <Jon> hm ok I'll give it a closer look, thanks for the advice
07:14:47 <SyntaxNinja> a nice first-pass would be that once you've altered a function, any intra-module things that call that function are tainted, then any inter-modules things that touch that module are tainted
07:15:18 <Jon> yeah that would be good
07:15:26 <Jon> ok I've got quite a bit to consider now, I think I best get some coffee :)
07:15:28 <Jon> thanks for your help
07:15:31 <SyntaxNinja> but doing inter-module function-level tainting would be harder, I think, since you have to figure out where that function came from, which would involve being pretty smart about parsing the imports
07:15:36 <SyntaxNinja> cool. enjoy yr coffee.
07:15:37 <Jon> yeah
07:15:49 <Jon> the purpose of this experiment would be to determine the feasibility of this approach, so a minimal solution is all I need
07:16:00 <skew> it's even worse for tracing if you have higher order functions
07:16:15 <Jon> it is my intention to develop this into something useful post-delivery
07:16:18 <Jon> skew: yes, thats true
07:16:33 <Jon> I might just do it for simple lambda calc 
07:16:44 <Jon> actually forget I said that
07:16:54 <SyntaxNinja> hehe
07:17:35 <skew> hmm, does GHC do control flow analysis?
07:18:06 <skew> It's possible, I just read a (fairly old) thesis about it
07:18:24 <Jon> oh in terms of implementation, it must talk to a program written using the J-word.. so I've got to be a bit careful
07:19:34 <SyntaxNinja> Jon: if it's a proof-of-concept, why does it have to talk to a J--- porgram?
07:19:45 <skew> but it's not simple enough you want to do it just for a text editor thing
07:20:36 <Jon> SyntaxNinja: what I have already is a J-program, but I could do something rudimentary which stood beside rather than worked with
08:14:18 <skew> is anyone here familiar with lout? Pseudonym mentioned it, but he's been offline for several hours
09:22:30 <camio> Can someone explain to me what is wrong with the following code?
09:22:39 <camio> newtype StateTransMany s a = STM( s-> [(s,a)] )
09:22:55 <camio> And now I am trying to make it an instance of Monad:
09:23:03 <skew> good so far...
09:23:05 <camio> instance Monad (StateTransMany s) where
09:23:05 <camio>   (STM p) >>= k = STM( \s0 -> 
09:23:05 <camio>                   let (states, values) = unzip (p s0)  
09:23:05 <camio>                       qs = map k values
09:23:05 <camio>                   in
09:23:07 <camio>                     foldr (++) [] $ zipWith (\(STM a) b -> a b) qs values
09:23:10 <camio>                   )
09:23:12 <camio>   return a = STM( \s -> [(s,a)])
09:23:39 <skew> you get a type error?
09:23:42 <camio> I get an "Inferred type is less polymorphic than expected"
09:24:04 <skew> one trivial thing, foldr (++) [] is concat
09:25:11 <skew> ignoring states looks pretty dubious
09:25:29 <skew> I think the last occurance of states should probably be values
09:25:52 <camio> Ah, yes silly me.  You mean values should be states :)
09:26:15 <camio> Thanks
09:26:17 <skew> right. I'd probably apply k to the value and state all at once, in a list comprehension
09:27:30 <skew> concat [ sfun state | (state,val) <- p s0, (STM sfun) = k val]
09:27:39 <skew> if I've got the syntax right
09:28:45 <camio> Good suggestion
09:32:37 <camio> skew: On my compiler, it didn't work unless the last part was "let (STM sfun) = k val".
09:32:57 <skew> I wasn't sure if there was supposed to be a let.
09:33:11 <skew> I guess I should have assumed it would follow the statement syntax
09:34:02 * Marvin-- yawns
09:45:22 <camio> This mplus stuff is pretty amazing.  I wish I understood it.
09:47:49 <camio> So do normal programmers come to situations where they think, "Ah ha!  I can solve this easily with a specialized MonadPlus monad"?
09:48:02 <camio> s/normal programmers/normal haskell programmers/
09:48:20 <Marvin--> I know I don't
09:48:23 <Marvin--> I very rarely use MonadPlus
09:48:45 <skew> s/normal/pointy-headed/
09:49:07 <camio> :)
09:49:59 <skew> I don't think I've ever seriously used MonadPlus, but I often think a custom monad would be useful
09:50:25 <skew> unfortunately sometimes I'm programming in languages where that isn't an option
09:51:09 <skew> like last summer working at a company where it was a bit of a strech to even be using Python.
09:51:21 <camio> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm <- this page is awesome if you follow the exercises.
09:51:42 <camio> Python sure is nifty.
09:51:52 <tic> yup.
09:51:57 <Marvin--> camio: yeah I think it's a great introduction to state monads
09:52:16 <skew> I'm pretty sure I've used the Mplus instance of Maybe. And of course the equivalent behaviour in parser monads
09:53:13 <skew> To really understand monads I think you need to look at some of the more interesting examples
09:53:37 <Marvin--> yeah, I've only used mplus in backtracking monads
09:53:42 <skew> like backwards-state and continuation
09:53:57 <camio> Hrm, I'll look those up.
09:54:12 <Marvin--> backwards-state? Huh?
09:54:39 <camio> backtracking?
09:54:44 <skew> If you can make sense of the weirder cases then you're like "Oh, I'll just lift IO through StateT and ReaderT here. ho hum. Wish I was coding something interesting..."
09:55:16 <skew> Marvin--: like State, except the state propagates from the end of the computation towards the start
09:55:28 <skew> just wire it up the other way
09:55:36 <Marvin--> interesting
09:56:12 <skew> I might actually use it in real code one of these days.
09:58:59 * Marvin-- likes monad transformers
09:59:53 <tic> Transformers! masters of the universy
09:59:55 <tic> s/y/e
10:00:07 <Marvin--> in one of my programs I had a WriterT on top of a StateT on top of a ListT on top of a StateT on top of a ReaderT
10:00:36 <Marvin--> but then I replaced the reader with implicit parameters instead
10:01:46 <skew> I've just got StateT on ContT on IO
10:02:16 <Marvin--> ListT makes for some funky code
10:02:38 <keverets> "Transformers ... more than meets the eye".  It was He-Man and the Masters of the Universe, iirc.
10:04:21 <skew> that's more appropriate
10:07:08 <skew> continuations make for pretty funky code too
10:07:21 <skew> it's a bit more painful to save a continuation and get a value out than it really should be
10:07:36 <skew> you need to make your own little data type
10:11:18 <emu> ug, tell me about it
10:17:32 <skew> The Cont module should define that sort of thing
10:19:07 <skew> something like ValCont m a = ValCont a (ValCont m a -> m ())
10:19:17 <skew> and some wrappers for calling them
10:20:12 <camio> I'm having difficulty figuring out how to solve a certain problem in haskell.
10:20:36 <camio> I have a list of objects and each object has properties.
10:20:50 <camio> The user should be able to edit each of an object's properties.
10:21:08 <camio> The user should also be able to add more objects to the list.
10:21:57 <camio> properties can be normal datatypes (Doubles, etc.) or other objects.
10:23:30 <camio> Anyone have any ideas?
10:23:48 <skew> the big question is how to give it all a uniform type
10:24:26 <camio> Yeah, I was thinking that each property would have to at least be partially represented as a IORef or something like that.
10:24:40 <skew> if you want to change them
10:24:57 <skew> I was thinking more about being able to edit the properties in a uniform way
10:25:08 <camio> Yeah, the user has to be able to change the objects' properties and the list of objects.
10:25:23 <skew> how much work are you willing to do by hand for each object and property?
10:25:48 <camio> As little as possible.
10:25:53 <skew> I'd probably pair each property with an IO action to be called to edit it
10:26:16 <skew> or something of that nature. A witness to the property "it is possible to edit this value"
10:26:42 <skew> If you want little effort and don't mind a non-pretty interface I would try to use a typeclass or something
10:27:30 <camio> A typeclass for each type of object which can have instances?
10:27:52 <skew> no, to generate the editing things
10:28:14 <skew> do you need to do anything else with the objects?
10:28:29 <skew> never mind. If you are using mutable state you don't need to get them back out
10:28:42 <camio> Well, it's be nice to have multiple operations based on the properties of an object.
10:29:21 <skew> something like [(ObjectName,[(PropertyName,IO ())])]
10:29:42 <camio> Like a smartClone procedure that allows you make clones of an object with user identified offsets for each of it's properties (which are applied incrementally).
10:30:30 <camio> Hrm
10:31:33 <skew> think about how you would solve the problem if you didn't have to make the types match up
10:31:50 <skew> then take the operations you need and package them up with the values (or instead of the value)
10:32:05 <skew> or maybe put them in a typeclass and use existentially typed constructors
10:33:20 <camio> I like the way you're describing it since the user has the potential to create new types of objects at runtime (with a suitible interpreter of course)
10:33:36 <skew> adding new types is a bit tricky
10:34:21 <skew> but you can make a flexible object representation
10:34:25 <camio> Well, if an Object is simply a tuple of ioRefs and actions...
10:34:58 <skew> what are these objects?
10:35:38 <camio> They represent movements on a 3 axis machine (ArcMove . . .)
10:36:05 <camio> This would be an interactive program creator.
10:36:37 <skew> okay, so it's more like instructions or something
10:37:42 <skew> You might want to look at Proxima. I don't know how it's implemented, but just from the screenshots and descriptions it sounds like it might be useful.
10:37:48 <skew> or contain useful ideas, at least
10:37:50 <camio> Yeah, so usually an object is going to have a decompose operator that will return a list of "primitive" objects.  This allows us to have an object box with x y z dimentions and decompose will generate code to fill it in.
10:38:20 <skew> http://www.cs.uu.nl/research/projects/proxima/
10:38:44 <camio> Thanks
10:39:12 <earthy> proxima is implemented in Haskell with wxHaskell, IIRC
10:39:16 <skew> don't be bothered by the "XML".
10:39:18 <skew> yep
10:39:29 <earthy> the XML is non-essential
10:40:19 <skew> It might operate on XML files, but the screenshots make it pretty clear it's designed for editing just about anything, rather than just XML-as-XML.
10:40:21 <camio> It's ugly, but seems to do the trick :)
11:35:26 <Spark_> lol i really should have done some research on typing algorithms before i did this
11:35:54 <Spark_> compare: http://info.dcs.warwick.ac.uk/~spark/3yp/doxygen_output/html/group__type.html#a3   and   page 14 of http://csg.lcs.mit.edu/6.827/lectures/L06-Hindley-Milner-1.pdf
12:50:30 <camio> "Exception: Prelude.read: no parse" should be caught in a normal catch call in the IO monad, right?
12:51:27 <skew> yeah
12:51:38 <skew> I'm thinking readIO comes in here somewhere too
12:52:11 <camio> I must be doing something wrong then.
12:52:35 <camio> editObject o = do
12:52:35 <camio>   sequence_ [ (do putStr n
12:52:35 <camio>                   putStr ": "
12:52:35 <camio>                   a <- readIORef r
12:52:35 <camio>                   b <- catch (interactiveEdit a) 
12:52:37 <camio>                              (\e -> (putStr (show e) >> return a))
12:52:43 <camio>                   writeIORef r b) | (n,r) <- properties o ]
12:52:54 <skew> the docs say that readIO is like read except it signals an error in the IO monad rather then terminating the program
12:53:07 <skew> so maybe a read failure does something silly like System.exitFailure
12:53:18 <camio> hrm
12:54:04 <camio> Great, that works.
12:54:14 <camio> Not intuitive though.
12:54:34 <skew> check the definition of read
12:55:08 <camio> I thought all errors were exceptions that could be caught.
12:56:06 <skew> you can also use reads
12:57:15 <camio> true
12:58:17 <skew> which catch are you using?
12:58:43 <camio> The easy one from the prelude
12:58:57 <skew> ExitException and so on are not IOErrors
12:58:58 <camio> catch :: forall a. IO a -> (IOError -> IO a) -> IO a
12:59:03 <skew> so your catch would miss them
12:59:03 <camio> Ahh, I see
12:59:15 <skew> try the one from Control.Exception and see what was being raised.
12:59:40 <camio> So the Control.Exception stuff and having the ability to catch all errors is a ghc extention?
12:59:48 <skew> yeah
13:00:02 <skew> isn't there a readMaybe somewhere?
13:00:32 <skew> GHC.Read has readEither
13:01:10 <camio> Is there a reason why I should raise exceptions everywhere instead of using things like that?
13:01:16 <skew> no
13:01:21 <camio> shouldn't I mean
13:01:31 <skew> because then code gets pulled into IO
13:01:43 <skew> which might be okay
13:02:01 <skew> it's a bit less clear what's going on, with less local control flow
13:02:10 <skew> it's probably less efficient too
13:02:20 <skew> like that really matters
13:02:31 <camio> lol
13:02:42 <camio> I wish haskell was efficient
13:03:51 <camio> I'm eager for eager haskell to be finished
13:03:53 <skew> you're using pointers to thunks for heap allocated cons cells of pointers thunks for thirty two bit characters
13:04:35 <skew> before the optimizer sees it at least
13:04:57 <skew> I wonder how smart GHC is
13:05:16 <Jon> pretty smart from what I've read
13:05:57 <camio> Not smart enough to be fast, from my experience.
13:06:06 <skew> I wouldn't expect much more than unboxing the cons cells
13:06:25 <camio> yeah
13:06:26 <skew> if you care about speed put a nice stream interface over streams of PackedString
13:08:06 <camio> There's no way to make golbal variables in haskell, right?
13:08:38 <skew> sure there is. {-# NOINLINE #-} var = unsafePerformIO (newIORef val)
13:08:45 <skew> pretty ugly though
13:09:37 <camio> Hrm, I always shy away from those unsafePerformIO calls.  Are they always unsafe?
13:09:50 <skew> it would be easy enough to combine the NOINLINE, unsafePerformIO and newIORef into some (safe) primitive
13:10:46 <skew> no, "unsafe" just means that you are responsible for proving safety instead of the usual case where successful compilation is a perfectly valid proof
13:11:04 <skew> and the only usualy issue with unsafePerformIO is referential transparency
13:11:12 <camio> The thing is, I'm trying to make an Object Factory.  I'd like to be able to get away from having a big list of all objects somwhere.  Each object should "register" itself with the main list.
13:11:46 <skew> although typesafety can be compromized if the unsafePerformIO has a polymorphic result
13:12:03 <skew> camio: that's really not the way to do it
13:12:15 <skew> data doesn't go out and do things in Haskell
13:12:58 <camio> What would be another option (besides falling back to the ffi if that even helps)?
13:13:30 <skew> more important than some paradigm, the objects shouldn't need to know how to add themselves to your list
13:13:36 <skew> or even be responsible for that
13:14:06 <skew> rather than pretending this is an OO language and somehow cramming that "add object to a list" function into the object, put it in a function somewhere and use it
13:15:07 <PhilippaAFK> hmm, I wouldn't go quite that far, auto-registration can be good sometimes - but AIUI that's really more of a type class or template haskell thing depending
13:15:15 <skew> "objects" are exoskeletal things in Haskell
13:15:18 <Philippa> (won't be at the keyboard for long 'mafraid
13:15:44 <skew> the operations for working on an object are external to values of the object
13:15:47 <camio> AIUI?
13:15:56 <Philippa> As I Understand It
13:16:35 <camio> From what I undestand Template Haskell can't do it.
13:16:38 <Philippa> yeah, no argument there. Was really only suggesting that sometimes it's nice to have certain structures built for you automagically rather than having to bash them out manually
13:17:10 <Philippa> hmm, the current implementations are still fairly limited aren't they?
13:17:11 <skew> yeah, but there's no point passing the automagic functions around with the values
13:17:20 * Philippa shrugs
13:17:27 <Philippa> just as true in an OO language IMO
13:17:54 <skew> yeah, but why buy all that shiny method machinery if you aren't going to use it?
13:18:34 <Philippa> syntactic sugar. I'll use vtables in C++, but it's not far off type classes in Haskell
13:18:40 <camio> I guess I'm looking for a haskell preprocesser that'll have something like #put(TotalValue) and $addToo(TotalValue)
13:19:01 <skew> what would those do?
13:20:29 <maihem> I have a question about fundeps: I've got "class Transition s t e | s -> t, s -> e" and "data Transition s t e => StateMachine s = ID s", this doesn't work as I'd expect, I want to define a type "StateMachine", polymorphic in "s" where there is a "s", a "t" and a "e" that satisfies "Transition s t e". How can I describe this? I've tried "StateMachine s t e" but StateMachine is not bothered with "t" and "e", so it seems sor
13:20:29 <maihem> t of wrong.
13:20:30 <camio> When compiling, a TotalValue String would be added too.  So I'd do #addTo(TotalValue) myObject for several objects.  #put(TotalValue) would be tranformed into [myObject,myOtherObject, etc.]
13:21:30 <skew> I don't understand put, but add sounds like it can be an ordinary function
13:21:54 <Philippa> I think the intention's for all calls to addTo to be evaluated before any calls to put
13:22:07 <camio> Yes
13:23:45 <camio> This would be pretty nice actually since doing registration with C++ happens at runtime (before main())
13:24:12 <Philippa> ah, the joys of uncertain construction order...
13:24:18 <skew> what does put do?
13:24:40 <Philippa> skew: looks like the setup's a mildly twisted compile-time writer monad, if that makes sense
13:25:12 <Philippa> put returns everything that's been written
13:25:52 <skew> when used anywhere?
13:26:06 <camio> yeah
13:26:07 <skew> that's going to be really tough to do across files
13:26:32 <camio> Not really as a preprocessing step.
13:27:09 <skew> oh, about the safety of global variables, all you really need to prove is that the order of the variable creating with respect to any other IO operation doesn't matter (beyond data dependancies on the IORef)
13:27:19 * Marvin-- giggles at the LotR Secret Diaries
13:27:51 <skew> and that comes for free when the only thing in the unsafePerformIO is a newIORef around a pure value
13:28:46 <camio> skew: With what I described, there would be no need for a global variable.  It is only variable at compile time.
13:28:53 <camio> If that makes any sense.
13:29:18 <skew> that sounds like an incredibly inflexible way of getting an initial set of objects into the list
13:29:22 <camio> maihem: lass Transition s t
13:29:32 <skew> recompiling the program to load a list of objects from a file!
13:29:45 <camio>                e | s t -> e is what you want I think.
13:30:12 <camio> Why inflexible?
13:30:44 <skew> if you have one global list holding the objects you are editing, and it is filled by a preprocessor that's pretty hard to change
13:31:19 <skew> if you have another mechanism for initializing a list of objects (reading a file, maybe) then you might as well use that for the initial set of objects as well
13:31:55 <camio> The thing is, I want each object to register itself so I don't have to maintain a global list of objects.
13:32:11 <skew> These objects seem to be changing.
13:32:36 <skew> I mean, that doesn't sounds like the usage you were describing earlier
13:32:46 <skew> where the user would add new objects, or new kinds of objects interactively
13:33:19 <skew> It's really quite easy to have a module defining a list of the built in object types
13:33:21 <camio> User objects are easy to make self register.
13:33:57 <skew> it also makes the program a lot more managable
13:34:26 <camio> Not really.  Lets say I have several file and several developers.
13:34:37 <camio> And about 50 built in objects.
13:34:57 <skew> it's much nicer to say "vim ObjectTable.hs" than grep -R "#add" *
13:35:13 <camio> To add an object or delete an object, a developer only needs to call the #add or remove it.
13:35:30 <skew> yes, but to figure out where all the objects come from you need to scan the entire codebase
13:35:52 <camio> Well, not if you say each object is defined in a file of it's name.
13:36:20 <skew> it's not worth the trouble of writing a custom preprocessor
13:37:09 <skew> and I think it's still easier if you have a table in one place. Especially if the UI just gives you a friendly description rather than a path and a line number
13:37:42 <skew> of course that module imports the modules that define the object and just has a list of pairs like ("fancy string formatter",stringFormatterObject)
13:38:19 <camio> I don't need to argue the benefits of Abstract Factories.
13:38:48 <maihem> camio: you're right, but StateMachine should then be polymorphic in s and t, but I have to make it polymorphic in s, t *and* e. That just seems wrong when Transition s t e carries the e type around
13:39:59 <skew> camio: that's different than the preprocessor stuff you were talking about
13:40:25 <camio> The preprocess is adding the ability to haskell.
13:40:34 <camio> Where haskell doesn't have it otherwise.
13:41:39 <skew> it sounds like a pretty useless ability. I don't see the utility of creating a magic list like that
13:42:19 <skew> if it's useful to aggregate a lot of different definitions something similar might be useful
13:42:20 <camio> You must've never used an Abstract Factory before.
13:43:28 <skew> but then if you have massive numbers of objects to define you might be better off with separate files for those definitions rather than embedding them into code
13:43:37 <skew> or constructing objects from descriptions in files
13:43:54 <skew> I've *used* abstract factories. I don't think I've written any
13:44:16 <skew> what's the point again?
13:45:05 <skew> that is, I don't know all the things they are supposed to be good for, and which points you care about here
13:45:14 <camio> So a user can create a class by it's "name" and see a list of options.
13:45:27 <skew> wait a minute. "user"?
13:45:38 <skew> like end user, or developer person?
13:45:49 <camio> Both.
13:46:19 <camio> Kinda the idea of having plugins . . . like photoshop plugins.
13:46:30 <skew> and what's a "class"?
13:46:49 <skew> surely not a type class?
13:46:56 <camio> An object.
13:47:03 <skew> In the context of a Haskell program, I mean
13:47:32 <camio> I guess it would probably be an instance of a class or an instance of a type.
13:47:50 <camio> Usually there is some method to clone the object (prototye pattern).
13:48:49 <camio> But anyway, the global list of objects really needs not to have any specific order.  Have this list be no maintenance is nice.  We get "anonymous" objects.
13:49:05 <skew> I don'
13:49:10 <camio> So we can just add an object to our program by just adding the source file.
13:49:12 <skew> don't think you get that in any language
13:49:32 <skew> maybe with loads of reflection, or in some language I don't know much about
13:49:58 <camio> No reflection. C++ is happy doing it.
13:50:26 <skew> in Haskell you can do that with a map from strings to existentially typed values
13:50:27 <camio> It's how most CAD and 3D design programs work.
13:50:49 <skew> oh right, wrap the constructors in objects, etc.
13:51:03 <skew> the second question is what functionality that provides
13:51:26 <camio> A codebase that scales well.
13:51:49 <skew> what are you writing and how much are you planning on scaling it?
13:52:42 <camio> Well, I've written a large CAD/CAM program in C++.  I'm trying to see if I could do it in haskell (cause it'd make me happer to program in Haskell).
13:52:58 <camio> So I've got a few developers and mostly they work on creating objects.
13:53:00 <skew> I think trying to copy patterns from C++ will probably not work as well as solving problems when you encounter them, when you have more experience implmeneting a feature in Haskell
13:53:28 <camio> That may be the case, but I haven't found a more elegant solution yet.
13:53:50 <skew> I'm still not sure what these objects are doin...
13:54:34 <camio> well, they are run time objects.  They have properties.  Imageine a 3d scene . . . includes box object, cylinder object, etc.
13:54:50 <camio> User changes the properties and the display updates.
13:55:06 <camio> Objects can have children objects . . . these objects are filters.
13:56:00 <skew> now why do you need to implement many sorts of objects?
13:56:38 <skew> as opposed to implementing a few primitives and building objects out of those?
13:56:40 <camio> Because in my system, there are a number of specialized parts it can make.
13:56:55 <camio> Right, there are primitives.
13:57:03 <camio> And other objects that can decompose to primitives.
13:57:33 <camio> So the properties of high level objects are parameters to a function converting it to a list of primitives.
13:57:42 <skew> okay.
13:57:50 <camio> So there are tons of objects.
13:57:52 <Philippa> camio: why not just have a map of primitive name -> constructor somewhere?
13:57:58 <skew> so now we are down to just having some "smart constructor" functions around
13:58:03 <skew> and a few primitive objects
13:58:18 <skew> probably including a "box these primitive up into a unit"
13:58:33 <Philippa> in fact, we're around to define a mini pseudo-functional language
13:58:48 <camio> Well, the user interactively changes the parameters of their high-level objects.
13:59:19 <camio> Philippa: Correct, this is a GUI based programming language in essence.
13:59:28 <skew> yeah, so maybe the boxing primitve encapsulates the smart constructor and an instance dictionary for the edit box
13:59:42 <Philippa> which suggests that your object names go in the equivalent of an environmnet
13:59:44 <skew> gah, an instance dictionary containing instructions for the various editing operations
13:59:48 <Philippa> *environment
14:00:14 <skew> probably including stuff like saving to a file and so on
14:00:53 <camio> I don't know exactly what you are saying.  There does need to be a list of objects (operations).
14:01:34 <skew> well, functional programming is more or less dual to imperative programming
14:01:49 <skew> so we have a primitive object type, with constructors like
14:02:03 <skew> Cylinder End End Radius
14:02:12 <skew> (Materials, etc.)
14:02:24 <camio> Yeah
14:02:34 <skew> and other sorts of solids (meshes, whatever)
14:02:56 <Philippa> d'oh
14:03:14 * Philippa kicks herself for forgetting to run her case fan while taxing her graphics card
14:03:19 <skew> a constructor for applying rigid motion
14:03:22 <Philippa> so, where were we?
14:03:50 <skew> Philippa: I solved that problem by routing the output of my window air conditioner over my CPU
14:04:06 <Philippa> heh
14:04:12 <skew> http://page-208.caltech.edu/pictures/case.html
14:04:17 <Philippa> yeah, I just tend to leave this box to run quiet
14:04:27 <skew> I was defining an algebra of objects
14:04:39 <skew> so we have something like Transform Matrix Object
14:04:56 <camio> But, in the end . . . there needs to be a bunch of things (Objects/operations/whatever) that the user can choose from.  This is where the abstract factory works well.
14:05:00 <skew> maybe with a lable, or with scaling split out, whatever
14:05:26 <Philippa> camio: did my "environment" suggestion come across? Just display a representation of that
14:05:49 <skew> yeah, but those should all be little tiny definition written in terms of a set of primitives designed to make it easy to write such definitions
14:06:14 <camio> Philippa: But this "environment" would have this list, no?
14:06:21 <Philippa> it would /be/ the list, yes
14:06:30 <skew> and moreover, a set of primitives making it feasible to do things like construct these objects at runtime from a simple file format
14:06:38 <Philippa> possibly stored in a slightly different structure, I'm thinking Data.FiniteMap here
14:06:53 <Philippa> skew: bingo. s-expressions^WXML or whatever takes your fancy
14:07:37 <camio> Philippa: Yeah, this is my intention.
14:07:43 <Philippa> though TBH I'd just hack my own format up and rig a parser with parsec
14:07:46 <Philippa> I guessed :-)
14:08:11 <skew> one of your object constructors should repesent an aggregate object, encapsulating a subscene along with enough information to query the user for new paramaters and rebuild the subtree representing that object
14:08:15 <Philippa> camio: you get something very, very similar to the syntax of "data" in Haskell
14:09:00 <camio> Philippa: But I am arguing how to construct this list.  I want it to be automatic instead of defining a list of all objects somewhere.
14:09:04 <skew> when you get into things like letting the user writing these object definitions define aggregates in terms of other aggregates it starts to turn into a functional programming language
14:09:24 <skew> camio: what you are really saying is that you want the list to be randomly scattered througout your codebase
14:09:40 <Philippa> camio: I wouldn't bother. Define all the really primitive stuff in a base environment somewhere, then keep all the "prefabs" as data elsewhere
14:09:56 <camio> skew: Well, you can put it like that to make it sound ugly.  Or you can call it self-registration and make it sound nice.
14:10:03 <skew> functions are data is functions.
14:10:07 <Philippa> the set of primitives ought to be small enough that self-registration's not really needed
14:10:18 <skew> one thing about Haskell, strong typing, whatever, is that you need to decide what you are actually trying to do
14:10:48 <camio> Philippa: But I need a list of all objects, not primitives.
14:10:55 <skew> then record that intent in the structure of your types and program
14:10:58 <Philippa> which you'll generate when you load the rest in as data
14:11:32 <Philippa> that can be spread out how you wish, you can implement whatever loading mechanisms and module systems you like 'cos it's your language
14:11:41 <camio> Sure, but I need most complex objects to be fast and thus compiled.
14:11:45 <skew> I doubt you actually want to be able to pull in objects willy-nilly from all over your code...
14:12:17 <skew> what do you mean?
14:12:24 <skew> they are just made out of meshes and stuff in the end
14:12:30 <skew> make your primitive fast
14:12:53 <skew> the little bit of data about how to query the user won't be nearly as important
14:12:55 <Philippa> I suspect optimising transformations etc. I'd be interested to hear exactly what's being suggested though
14:12:55 <camio> For example, we have one complex object that has a mesh and several variables as properties.
14:13:02 <skew> so you don't have to wory about it until later.
14:13:07 <camio> This decomposes to solid segments.
14:13:12 <skew> so record the mesh.
14:13:14 <Philippa> ah, yeah, if you've got parametric stuff I can see how you'd rather that were compiled
14:13:19 <skew> and only recalculate when it actually changes
14:13:30 <camio> skew, that's the way the C++ version works.
14:13:34 <skew> tricky optimizations make things tricky, of course
14:14:10 <Philippa> OTOH it's inherantly a lazy thing, would expect it to be easier to implement in Haskell
14:14:53 <camio> What would be a negative of having compile-time lists like I described?  I guess that's the real question.  Positives are clear.
14:14:58 <skew> but generating a representation once in terms of relatively high level primitives shouldn't be on your critical path
14:15:34 <skew> camio: the big negative is that the program doesn't tell you much
14:15:48 <camio> skew, it has an opengl preview.
14:15:55 <skew> what is the advantage of writing types in your program?
14:15:56 <Philippa> that's not what he means
14:16:00 <skew> I mean the source.
14:16:08 <skew> Or you have one heck of an editor :)
14:16:41 <skew> the compiler can just infer all the types for you...
14:16:50 <camio> It seems pretty clear to me REGISTER_OBJECT( ... )...
14:16:50 <Philippa> it occurs to me that you've got a pseudo-explicit list in the makefile
14:17:05 <Philippa> which you then have to grep for, which I believe is the point
14:17:09 <camio> Philippa: objects/*.hs
14:17:23 <skew> camio: what about dynamic loading?
14:17:33 <Philippa> yeah, you can always do something outside the language itself
14:17:47 <skew> it's being dual again.
14:17:49 <camio> skew: That's be a cool option, but it involves the same idea.
14:18:10 <Philippa> what we were suggesting would give you it pretty much off the bat
14:18:11 <skew> more or less
14:18:56 <skew> do you want to make it easy to see all the objects included in the program, but require going leaving an objects home file (and going to one central file) to see if a particular object is included
14:18:57 <camio> Philippa: Writing an embedded language for all my objects?  How is that off the bat.
14:19:10 <Philippa> because you've got all but the parser anyway
14:19:22 <Philippa> and the parser's trivial to write with a good combinator library
14:19:41 <Philippa> parsec's a few tokens shy of just handing the compiler an annotated grammar to play with
14:19:46 <camio> skew: I don't understand.
14:19:54 <skew> or easy to look at the file defining an object and see if it's included, but require going through a whole bunch of files / building and running to get a list of all the objects
14:20:08 <skew> about the embedded language, how else were you planning on defining your objects?
14:20:10 <Philippa> and S-expressions are easy to parse, too
14:20:17 <skew> a combinator here, a combinator there, and you almost have one
14:20:24 <Philippa> skew: there're situations where I would favour the latter
14:20:39 <camio> Haskell style
14:20:58 <Philippa> but mostly ones where modules're linked to external resources and, dare I say it, content
14:21:16 <camio> skew: the second one.
14:21:44 <camio> The list of objects should be unimportant to the programmer, but important for the end-user.
14:22:08 <skew> well, that works too.
14:22:27 <skew> never mind, the best solution is probably autogenerating the list somewhere by scanning all your files
14:22:31 <skew> which gives you the best of both worlds
14:23:05 <skew> so, problem solved
14:23:18 <camio> Isn't that what I originally proposed?
14:23:42 <skew> I believe you proposed having another macro that would expand to the list everywhere it was used
14:24:11 <Philippa> skew's suggesting building a file with the list in as part of the make process then importing it as needed, I believe
14:24:18 <skew> I'm being a bit slow, but that didn't immediately imply to me that you would record the list in a file
14:24:21 <Philippa> which certainly avoids cross-module problems
14:24:23 <camio> It would scan through the files to autogenerate the list.  You use the list by another macro.
14:25:01 <Philippa> unless you reduce that to what skew said, you've got versioning problems
14:25:17 <camio> Philippa: How so?
14:25:27 <skew> why not just include the autogenerated module?
14:25:46 <Philippa> you could end up with one compilation unit seeing one list and another seeing a different one
14:25:58 <camio> skew: Sure, that woud work but I don't see the benefit?
14:26:18 <skew> and you need to regerate and recompile all the modules that use the list whenever it changes, rather than just relinking
14:26:23 <camio> Philippa: Not with Makefiles.
14:26:40 <Philippa> tr: "we rebuild the lot /anyway/, who cares?"
14:26:48 <Philippa> fair enough, but where's the gain?
14:27:05 <Philippa> the list module makes a useful artefact on its own IMO
14:27:09 <skew> aggregating a bunch of list entries is something the language does not provide
14:27:25 <skew> importing a list from somewhere beyond into a file is not
14:27:36 <skew> and the list is nice to have around anyway
14:27:54 <camio> skew: One could use my extentions to implement your method.
14:28:02 <camio> They would just be more flexible.
14:28:10 <skew> it's sort of trivial if the #put method is only used once
14:28:20 * Philippa hands camio the untyped lambda calculus for flexibility
14:28:35 <skew> it's more flexible in the sense that writing your CAD program as an operating system unto itself is more flexible
14:28:48 <skew> it doesn't really give you anything and just begs for trouble
14:29:09 <camio> It likely that in my particular case, it would only have one put.  But there are several cases for abstract factories that exist.
14:29:16 <camio> skew: What trouble?
14:29:28 <camio> Seems pretty straightforward.
14:29:30 <skew> well, there's the dependancy trouble of needing to recompile everything
14:29:42 <skew> possibly memory issues from duplicating the list many times over
14:30:22 * Philippa would avoid the dependancy stuff like the plague because she tends to use GHCi - you really don't want to have to do an entire make in that scenario
14:30:23 <camio> It would recompile what is needed, not a problem.  Kinda like header files in C++.
14:30:30 <skew> it's impossible to make it a shared mutable object if each #put is independant
14:31:02 <camio> #put is simply a macro.  One would use "list = #put(MasterList)"
14:31:28 <skew> camio: tell me, what's the disadvantage to sticking the definition of a central data structure into a header file everything imports?
14:31:34 <Philippa> only you don't know what is needed until you've preprocessed everything again and diffed it
14:32:23 <camio> Philippa: Seriously, that's what the makefile generators on Ghc do.
14:32:45 <skew> yes, but it doesn't require you to recompile all your code every time the makefile changes
14:32:57 <skew> actually rexpanding all your code every time the list changes does
14:33:05 <skew> to no apparent benifit
14:33:30 <camio> All I need to do is re-run the preprocessor.
14:33:32 <camio> That is fast.
14:33:34 <skew> how is "myMasterList = $put(masterList)" any better than "import MasterList(masterList)"
14:33:48 <skew> and recompile EVERYTHING which is incredibly slow
14:34:04 <skew> or at least everything that $put's the list
14:34:40 <camio> skew: You don't understand, I would do this.  The user of MasterList would do this.  The MasterList.hs source would have the $put.
14:35:06 <skew> Why bother implementing $put rather than dumping the file?
14:35:08 <Philippa> IOW, "I'm going to have a facility I'm never gonna use just for the hell of it!"
14:35:44 <camio> skew: Why not?
14:35:50 <Philippa> because it's harder work
14:36:00 <Philippa> because there's not been any good use for it demonstrated yet
14:36:09 <skew> hmm, would I rather write more code, or less code?
14:36:49 <camio> I think the code would be about the same.
14:36:51 <Philippa> mapM (\l -> dumptodisk show l) lists
14:37:16 <Philippa> OK, sorry, missed out the filename...
14:37:19 <skew> especially considering the extraction tool could probably be prototyped in about ten minutes with grep and friends
14:37:41 <Philippa> mapM (\l -> dumptodisk (filename l) (show (list l))) lists
14:37:56 <skew> grep -R 'ugly-regex' | sed 'ugly-regex' | cat head - foot
14:38:04 <Philippa> and written in Haskell in another ten :-)
14:38:06 <camio> skew, and the $put coudl be prototyped in about 5 min using sed.  What's your point?
14:39:02 <Philippa> that's an extra unneeded 5 minutes for capabilities we've not seen a safe use for
14:39:04 <skew> and you could add a tic-tac-toe game to the preprocessor in another 5 minutes
14:39:07 <camio> sed "s/#put(Something)/[aClass, bClass]/
14:39:22 <camio> skew: Point is, not much extra code.
14:39:29 <camio> Probably less
14:39:31 <skew> if you don't mind touching all your files
14:39:50 <Philippa> anyway, I gotta go to bed
14:39:51 <skew> It's not that much harder to figure out which ones need to be processed, but why bother?
14:39:54 <Philippa> need an early night
14:40:13 <camio> skew: This is getting rediculous. Your arguments are so pointless.
14:40:58 <skew> I just don't see use for the code.
14:41:06 <skew> put in the 5 minutes after you do.
14:41:06 <shapr> @yow !
14:41:07 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER,
14:41:07 <lambdabot>  grow a LONG BLACK BEARD and wear a BASEBALL HAT!!
14:41:07 <lambdabot>  ...  Although I don't know WHY!!
14:41:24 <skew> much better to worry about how to implement these objects
14:41:28 <shapr> g'night Philippa 
14:41:42 <skew> Oh. right! Bye!
14:41:43 <camio> skew: True
14:42:40 <Spark_> skew: nice case mod :)
14:43:04 <skew> design a nice set of primitives, write some code, factor out useful utility function, make a combinator library out of it...
14:43:07 <Spark_> not particurly asthetically pleasing, but quite functional
14:43:25 <skew> Spark_: that's good asthetics to me.
14:43:31 <shapr> skew: truly, that's slashdot worthy
14:43:38 <camio> Right now I've got:
14:43:45 <camio> data Object = Object{name :: String, 
14:43:45 <camio>                      properties :: [(String, IORef Property)],
14:43:45 <camio>                      toPrimitives :: IO( [Primitive] }
14:44:11 <camio> Obviously it doesn't work so well yet.  ')''s are a bitch :)
14:44:13 <skew> I like little bits exposed for easy fiddling...
14:45:38 <skew> It's probably handier to stick in an IO action for querying for new values, rather than try to deal with all the IORefs yourself here
14:47:26 <skew> nah, your way is probably better
14:47:45 <skew> just write a nice function that takes a list like that and does the querying
14:48:02 <skew> it doesn't really matter whether you use it once when making the object, or every time you want to modify it
14:48:26 <skew> including the values has the bonus that you can present loads of different integerfaces
14:49:29 <skew> When you get to making a scene graph you probably want to put it together with IORef's to children, at least in some strategic places, so you can recalculate parts without rebuilding lots of the graph
14:50:10 <skew> don't be discouraged if I sounded pretty negative about stuff. It sounds like a great project.
14:50:29 <camio> yeah.  I'm not discouraged :)
14:53:42 <skew> I just don't want you to try writing C++ in Haskell. I don't think it would work out so well...
14:54:40 <wagle> if you can write it in C, why not haskell?
14:54:45 <camio> :) Very true.
14:55:04 <skew> wagle: see Simon Marlow's recent post. I'll dig up a link...
14:55:10 <Marvin--> bah, do it the Simon Marlow way!
14:55:13 <camio> The important haskell parts are the algorithmic stuff in decompose
14:55:16 <Marvin--> skew: heh
14:55:19 <skew> decompose?
14:55:21 * Marvin-- high-fives skew
14:55:46 <wagle> Happy?
14:56:25 <skew> http://www.haskell.org//pipermail/haskell-cafe/2004-March/005939.html
14:56:39 <Marvin--> I've put it on QuotesPage too
14:56:50 <skew> Marvin--: what?
14:57:34 <Marvin--> Simon's code
14:57:50 <skew> oh, not a recent change
15:03:17 <camio> skew: to primitives
15:03:36 <wagle> skew: given that my version of gcc would kill the program trying to execute a return statement after running that code, i (jokingly) dispute the accuracy of even Simon's translation..
15:04:25 <skew> camio: for testing, maybe write something similar and not particularly related to your problem?
15:04:39 <skew> I mean simple
15:04:51 <skew> like strings maybe, and some case transformations
15:05:24 <skew> if you don't want to jump straight into rendering objects
15:05:47 <camio> skew: Yeah, that's what I'm doing now.  Just a simple command-line based interface.
15:06:04 <wagle> (I take the original code to be doing a stack smash)
15:06:17 <skew> it sounds like building these higher level constructs is the problem here
15:06:42 <camio> skew: I'll probably use my old haskell-gui example implementation to do the graphics.
15:07:47 <skew> sounds good. I don't know how much work on a toy problem will cary over to the real thing
15:08:23 <skew> there isn't really much point in writing the worlds best string capitalizer and letter repeater.
15:08:39 <skew> well, have fun
15:08:44 <camio> huh?
15:08:59 <skew> ah don't worry
15:09:18 <skew> I should probably focus a bit more on writing the thing I need to be writing...
15:09:27 <camio> :)
15:10:25 <skew> I'm learning a new typesetting system too...
15:10:35 <skew> talk about work for no good reason...
15:16:04 <stepcut> lets say I have imported a module:  import qualified SomeModuleWithALongName as SomeMod
15:16:39 <shapr> stepcut: I think you count as better than intermediate
15:17:10 <stepcut> but let say in one particular function, I use the functions in SomeMod a lot. Is there a way to do something like 'with module SomeMod --> function definition'
15:17:35 <stepcut> shapr: well, it depends how many levels there are
15:18:10 <stepcut> in a four level system, beginner, intermediate, advanced, guru, I might be advanced, in a three level system, I am probably still intermediate
15:18:41 <shapr> ok, wo's advanced?
15:18:47 <shapr> "who" ?
15:18:55 <shapr> The Simons
15:18:59 <stepcut> yeah
15:18:59 <shapr> :-)
15:19:24 <stepcut> there are still a bunch of things I don't really know --> generics, dynamics, kinds 
15:19:28 <shapr> ok
15:19:46 <shapr> kinds will take you an afternoon at most
15:19:49 <stepcut> i have never written a copmiler extension
15:19:58 <shapr> dynamics about the same
15:20:42 <shapr> generics are not quite that easy, mostly because there are more implementations
15:20:55 <stepcut> plus, I don't know how to 'temporarily' import a module
15:20:59 <stepcut> ;p
15:21:04 * shapr grins
15:21:12 <shapr> nor do I
15:21:33 <stepcut> I think I have seen it in other languages, but I can not remember which
15:22:13 <skew> ocmal?
15:22:23 <skew> that lets you define several modules in a file
15:22:23 <stepcut> skew: maybe..
15:22:35 <skew> I don't know any other *ml
15:22:43 <stepcut> skew: that is different than what I want to do
15:23:35 <stepcut> I want to import a module, but instead of doing it at the top level, limit it's scope to a single function (if that makes any sense)
15:23:58 <stepcut> its purely a readability issue
15:26:24 <shapr> I'd like to do that semotimes too
15:31:29 <camio> :bye all
15:31:37 <skew> bye
17:52:04 <skew> well, I learned enough lout to get work due an hour ago in ten minutes ago. Its formatting model is actually documented and understandable, which almost makes it possible to code workarounds for the poorer math formatting in reasonable time. It's an interesting formatting system, probably better for plain text at the moment.
17:53:22 <skew> Also, taking an unsupported claim on the printout, justifying it by scribbling "This is obvious" by it, looking it over again, then spending a good twenty minutes proving it :)
17:53:55 <skew> Isn't math fun?
20:03:15 <skew> zquity
20:35:32 <Spark_> does anyone think its trye to say that recursion is useful because it allows you to precisely specify a computation, without knowing in advance how much computation is actually required?
20:45:37 <Etaoin> Spark_: I don't see anything wrong with it, but I'm no authority.
20:47:41 <Cale> Spark_: you can also get that without recursion
20:48:10 <Cale> i.e. using an infinite loop with conditional return
20:57:25 <Spark_> is that possible in a functional language?
20:58:21 <Spark_> in terms of implementation i suspect recursively calling a function is the same as continually gotoing to the same place :)
20:58:54 <Cale> pretty much
20:59:11 <Cale> depending on what sort of recursion you're using
20:59:56 <Spark_> what types of recursion are there?
21:00:05 <Spark_> i can immediately recall tail recursion, and mutual recursion
21:01:46 <Cale> I think those are the main named ones. Continually gotoing the same place where some stuff changes each time through is similar to tail recursion.
21:01:55 <Spark_> i have this picture in my mind that im trying to justify, that functional languages are designed to have referential transparency, while keeping the expressiveness of procedural languagues with an explicit state
21:02:17 <Spark_> and recursion must be the only way of specifying that kind of computation without an explicit state
21:02:56 <SamB> Spark_: well, it is in lisp (for tail recursion)... I'd have to think about it to figure out if you can compile haskell that way...
21:04:06 <Spark_> there are certain recursive algorithms which would be very hard to implement without recursion
21:05:25 <Spark_> i guess something like quicksort is greatly aided by the fact that the call stack is a language feature, and it can use that as part of the mechanics of the computation
21:06:02 <Spark_> whereas something like bubble sort is not really a 'stack' algorithm so it doesnt fit so nicely into a recursive function
21:06:56 <Spark_> just some thoughts anyway :p
21:12:35 <Spark_> hmm Cale does that mean tail recursion is equivelant to applying some procedure to a datum until it has a specific value
21:13:12 <SamB> well, it is worth noting that the Haskell quicksort is not exactly equivalent to the one in C...
21:14:07 <Spark_> the haskell library quicksort vs the qsort(3) function?
21:22:07 * Cale is away: stargate
21:25:26 <Spark_> i dont suppose haskell has bindings with any gui toolkits does it?
21:25:50 <Smerdyakov> 'Course it does.
21:26:04 <Spark_> cool, gtk?
21:26:11 <Smerdyakov> And it's trivial to write yourself any that don't exist.
21:27:05 <Smerdyakov> Yes. You might want to spend some time browsing www.haskell.org.
21:28:38 <Smerdyakov> You _might_ be able to find a language with more than 100 serious users without a plethora of GUI options, but it would be _hard_.
21:29:36 <Spark_> ah i see you just call the main() function in the traditional way
21:31:20 <Spark_> im just going to have to write a large program in haskell, its the only way to go :)  after my exams though, hopefully by then ill have thought of something to actually do
22:21:01 <SamB> hmm...
22:23:29 <SamB> does sed have a plethora of GUI options?
22:47:51 <Spark_> does english have a plethora of GUI options? :))
22:49:41 <blackdog> are you talking about colourful language?
22:50:38 <Spark_> to be honest with you i dont now what im talking about, 90% of the time
