00:53:40 <shapr> @yow !
00:53:41 <lambdabot> It's 74 degrees, 12 minutes NORTH, and 41 degrees, 3 minutes EAST!!
00:53:41 <lambdabot>  Soon, it will be TUESDAY!!
00:54:09 <shapr> it's excitement!
01:02:28 <Lurc> Heh, Richard Hamilton @UT uses Haskell almost exclusively in CS345 - Programming Languages.
01:08:27 <shapr> University of Tennessee?
01:11:18 <shapr> texas, austin: http://www.cs.utexas.edu/users/ham/UTCS/CS345/
01:11:37 <shapr> Lurc: is that the school you attend?
01:17:20 <Lurc> shapr: indeed.
01:25:42 <shapr> so what's going on today?
01:25:55 <shapr> anyone writing Haskell code?
01:28:18 <shapr> hei vegai
01:28:34 <vegai> hi
01:28:47 <shapr> wassup?
01:29:03 <vegai> testing kernels
01:29:09 <vegai> for no apparent reason
01:29:29 <shapr> sounds like fun
01:29:36 <shapr> greetz Si\ 
01:29:55 <Si\> hi
01:30:01 <Lurc> shapr: nobody writes code here.
01:30:31 <shapr> has anyone heard of any speech recog projects in Haskell, or even SML?
01:30:39 <shapr> Lurc: oh that's toobad
01:31:25 <shapr> you'd think with an expressive language like Haskell, lots of people would be writing code in it
01:32:38 <Lurc> No, this is a university. Nobody programs here.
01:32:57 <shapr> oh, I see
01:33:53 <shapr> that may be why I skipped that whole university computer science thing, I'm just not theoretical enough
01:34:37 <shapr> oh google turns up the MITRE speech recognition system, whic works with GHC 0.19
01:38:58 <shapr> oh boy, it's part of nofib.
01:49:34 <shapr> Lurc: have you written any Haskell?
01:50:34 <shapr> hi elmex
01:50:47 * shapr boings
02:08:17 <Lurc> shapr: yes.
02:08:43 <Lurc> shapr: I'm writing a C99 compiler.
02:09:28 <Shammah> Lurc: any particular reason?
02:12:00 <Lurc> Shammah: because I need a C99 compiler.
02:13:37 <Shammah> Lurc: fair enough.  I wasn't aware there were too many people using C99; I thought most compilers were just picking and chosing various C99 features an claiming support for C89+extras
02:14:16 <Lurc> meh?
02:14:53 <Lurc> Shammah: look, I'm writing a kernel in C99. I just need a compiler.
02:15:51 <vegai> gcc?
02:16:01 * vegai shrugs.
02:16:25 <vegai> I guess it's not ready yet there
02:17:06 <Lurc> have you read gcc?
02:18:33 <shapr> you could use c--
02:20:07 <Lurc> never looked at it...
02:20:32 <Lurc> shapr: I've got a friend who's writing a c->c-- decompiler.
02:20:50 <vegai> have I read gcc?
02:24:42 <shapr> I think c-- is worth investigating
02:40:56 <Lurc> shapr: nope, c-- has no typing.
02:41:59 <Lurc> although... c+- looks promising ;)
02:48:22 <musasabi> objc is kind of nice
03:03:14 <Lunar^> Hi
03:03:51 <shapr> hi Lunar^
03:12:38 <Lurc> alright, the sun is rising. g'night all you parallel programmers.
03:14:32 <Lunar^> shapr: btw, I started daydreaming few days ago about your haiku
03:15:01 <Lunar^> shapr: Maybe I could try doing something graphical about it :)
03:19:11 <shapr> heh, what's so fascinating about my haiku?
03:20:18 <shapr> haiku is easy to write, just count the syllables, and make sure you include a reference to the weather
03:20:32 <Lunar^> shapr: I just love it :)  Do somebody else also mentioned it lately ?
03:20:49 <shapr> if you do make a graphical representation, I want to see it!
03:21:24 <shapr> well, someone put it onthe QuotesPage on the wiki, so there must be some interest
03:21:30 <Lunar^> shapr: I was thinking about a big reduction graph (which will look like a tree), with snow falling on it and a lot of lambda to make the grass
03:21:40 <Lunar^> I did 
03:22:44 <shapr> oh that's much better than my original mental image
03:23:44 <shapr> but I think art should always work like a distorted mirror, you see what's inside yourself, from a slightly different perspective
03:24:06 <Lunar^> hehe :)
04:52:09 <shapr> scary stuff happening in brussels: http://swpat.ffii.org/
04:52:44 <shapr> I hope the EU doen't end up allowing unlimited software patents
04:53:30 <shapr> if they do, I'll move back to the at least slightly limited patents of the USA
04:54:39 * musasabi wonders why governments are so intent on making everything criminal
04:55:28 <vegai> musasabi: they are trying to reduce unemployment rates ;P
04:55:31 <vegai> (more policemen)
04:59:22 <shapr> I think the big companies are trying to make it illegal for consumers to escape
05:01:25 <shapr> "Why yes, I'm a member of the Time-Warner herd, are you a milk cow for Sony or Matsushita?"
05:01:32 <musasabi> yes, corporatism is ugly
06:24:28 <shapr> hi meson 
06:24:55 <shapr> so, what's happenin today guys?
06:25:21 <shapr> holidays make for quiet irc channels
06:25:23 <meson> good day
06:25:42 <meson> today I'm slacking at work by beginning Haskell =)
06:26:18 <shapr> sounds like fun
06:26:28 <shapr> can you use haskell at work?
06:28:03 <meson> hmmm, not immediately.  Everything we do is JSP/Servlet, thought I've done some systems programming in C, some billing report generation in perl, and some XML verification in scheme
06:28:07 <meson> *though
06:28:09 <saz> i'd love to see the day where people don't either snicker and say.. heh, we don't use *thaat*, or shrug in confusion when i tell them i know haskell, at work.
06:29:16 <meson> haskell is just something i've been meaning to learn, especially now that I'm taking CS theory
06:29:39 <Marvin--> saz: still better than the you'll-understand-when-you're-older pat on the head ;)
06:29:44 <shapr> programming folks around here get worried when I say it's my favorite language
06:30:52 <shapr> meson: you could still use haskell (or any other language) for web testing. I use a haskell xmlrpc lib to talk to my zope servers
06:31:10 <saz> Marvin--: hehe, i guess
06:32:16 <saz> so happy
06:32:20 <saz> this actually worked this time
06:33:24 * Marvin-- disappears out to the kitchen to make a chocolate cake
06:33:34 <shapr> saz: what do you do at work?
06:33:42 <saz> i'm not working atm
06:33:48 <saz> was over summer though
06:34:02 <shapr> meson: you want some pointers for learning Haskell?
06:34:12 <shapr> saz: what did you do?
06:34:28 <meson> i'm reading the "gentle introduction" right now, and I've got hugs running
06:34:35 <meson> any other recommendations?
06:34:56 <saz> shapr: just web programming, code monkey stuff
06:34:57 <skew> I was doing some web application testing stuff last summer, Jython over a nice Java library, thinking to myself the whole time "I could really use a monad here"
06:35:00 <saz> and a little sys admin stuff
06:35:18 <skew> I'm looking for pointers on teaching Haskell at the moment
06:35:21 * Arnia prods shapr
06:35:46 <shapr> Arnia: what?
06:36:05 <saz> skew: who are you teaching it to?
06:36:28 <skew> a growing collection of fellow undergrads
06:36:30 <tic> hire Hughes. He's good at it. :)
06:36:40 <shapr> Arnia: did I miss something?
06:38:24 <Arnia> shapr: Just saying hello :)
06:38:30 <shapr> meson: have you seen the url in the channel topic? lots of good resources there. also, I recommend the haskell wik, and the mailing list archives
06:38:34 <shapr> hi Arnia !
06:38:46 <shapr> er, "haskell wiki"
06:38:57 <shapr> @wiki FrontPage
06:38:57 <lambdabot> http://www.haskell.org/hawiki/FrontPage
06:39:13 <meson> shapr, rockin'
06:39:48 <skew> Everybody here has some experience with learning Haskell, right?
06:39:52 <Arnia> shapr: I was also wondering if you'd seen Nemerle and what you thought about it
06:40:01 <shapr> haven't seen it
06:40:22 <shapr> oh, it's for .NET
06:41:37 <atom-z> is .net microsoft's answer to Java?
06:41:57 <shapr> it appears that way to me
06:41:58 <Arnia> No, .Net is a very different idea to Java.
06:42:08 <Arnia> And its an open spec too
06:42:19 <skew> Everything we've done so far is up at http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html, if anybody would like to take a look.
06:42:51 * shapr looks
06:43:08 <atom-z> 404
06:43:17 <skew> huh?
06:43:28 <skew> works for me.
06:43:43 <skew> check you don't include a comma at the end of the URL
06:43:47 <Arnia> The more I look at CLR (the non-marketing name for the .Net initiative's VM), the more I like it. And Mono's impl is currently more up to date with the ECMA standard than the microsoft one
06:44:10 <skew> about all I've heard is that they do tail calls.
06:44:28 <skew> how is the common typesystem stuff for handling polymorphism and so on?
06:45:09 <Arnia> v1.2 of the standard includes Generics to handle parametric polymorphism
06:45:43 <Arnia> This is currently only in Mono 0.32 though, but it will be in the next microsoft release of the .Net runtime
06:45:53 <skew> wasn't that hacked in after the fact?
06:46:04 <atom-z> ah ok, removing the comma fixed it
06:46:14 <skew> vaugely recalling comments from the guy I interviewed with a microsoft, head of the .NET compact team
06:46:44 <shapr> I like the "no tabs" rule, smart move
06:47:12 <Arnia> The first version of the CLR standard doesn't include generics, but they've added them to allow more languages to use the CLR
06:47:15 <skew> He was saying it fit poorly with the code generation and stuff
06:47:55 <skew> maybe he was talking more about their implementation rather than making a general statement about the standard
06:48:14 <shapr> skew: you could link the underlined terms to the report, or HaWiki pages
06:48:33 <Arnia> Heh... their impl hasn't been released yet. Only Mono has implemented it so far
06:49:46 <skew> shapr: that's a good idea. I've just been doing the lectures.
06:49:59 <shapr> skew: also, I'd argue that Haskell is multiparadigm, and supports more than just FP, but that's obviously a minor quibble
06:50:51 <shapr> oh, really nice description of closures
06:53:02 <shapr> ah, the Haskell community has needed a gems page for some years
06:55:12 <shapr> I haven't tried Okasaki's book, but I very much enjoyed rabhi & lapalme's "Algorithms : A Functional Programming Approach"
06:56:27 <shapr> SICP is good for any programming class, regardless
06:56:49 <shapr> tPP is good for those who want to make software as a profession
06:56:52 <atom-z> looks like it will be a good course
06:57:05 <skew> tPP?
06:57:19 <atom-z> but my experiance is rather limited
06:57:28 <shapr> the pragmatic programmer
06:58:10 <shapr> I recommend SICP + tPP as the two first books any professional programmer should own
06:58:29 <skew> I like "Writing Solid Code":
06:58:39 <shapr> sadly, my copy of tPP is always on loan to someone
06:58:44 <skew> I haven't seen tPP.
06:58:48 <Lunar^> shapr: SICP ? tPP ?
06:58:58 <shapr> I've heard of it, but haven't tried it
06:59:00 <skew> SICP seemed pretty basic by the time I read it
06:59:06 <Lunar^> shapr: Uh the Pragmatic Programmer
06:59:12 <skew> I think Writing Solid Code is out of print.
06:59:22 <shapr> Lunar^: oui
06:59:27 <skew> ironically, published by Microsoft Press
06:59:34 <shapr> :-)
06:59:42 <Lunar^> shapr: Read it some time ago, was really hit by the helicopter metaphor
06:59:51 <shapr> I have code complete by mspress
06:59:56 <Lunar^> What is SICP ?
07:00:11 <shapr> Abelson and Sussman's Structure and Interpretation of Computer Programs.
07:00:17 <Lunar^> Never eard of it
07:00:29 <shapr> yah the helicopter is poignant
07:00:49 <shapr> I like tracer bullets and broken windows
07:00:59 <Lunar^> Is SICP fully readable onine ?
07:01:16 <skew> http://www.google.com/search?&q=sicp
07:01:27 <skew> all there
07:02:04 <Lunar^> Cool :)
07:02:13 <Lunar^> There's a lambda on the cover !
07:02:17 <skew> actually, I didn't google for tPP before asking so I shouldn't really complain
07:03:40 <skew> did you check out the slides, the stuff I actually control?
07:04:23 <shapr> just looking at the assignment, looks nice
07:04:26 <skew> they are pretty sparse, with a lot of context filled in. Imagine rambling for a few minutes about each area and you'll approximate the lecture
07:07:59 <skew> the general plan is to try to cover most of the (standard) language, then start with bigger excercises to give some experience with the interactions and implications of the features
07:08:49 <shapr> your if/then/else slide pre-emptively strikes the execution vs evaluatin discussion, but I still think the procedurally experienced will snag on that
07:10:25 <skew> we also put the let bindings out of order for more of a point about evaluation
07:10:38 <shapr> yah, that was cool
07:10:58 <skew> and did the SICP thing with defining your own if while playing in GHCi, to demonstrate that yes, it works in Haskell
07:11:02 <shapr> so the elispers will realize it means let*
07:11:18 <skew> that's like let-rec in scheme?
07:11:36 <skew> the let-rec I know doesn't work on values like that
07:12:23 <skew> For this year's class we have lots of math background, and the people with programming experience know some functional languages
07:12:47 <shapr> neat
07:12:55 <shapr> sounds like a good setup
07:13:26 <skew> the class is happening this year rather than me writing slides in a vacuum because a math major needed to learn Haskell to work on a topology program for summer research
07:14:19 <skew> then two people who knew bits of Haskell said they wouldn't mind taking a course in alpha.
07:16:55 <skew> The evaluation order is definitely something to worry about for later classes, say using Haskell in CS1.
07:17:14 <skew> The typing of the numbers is pretty annoying for introducing Haskell.
07:17:34 <skew> You need to at least handwave at class constraints and foralls if you want to introduct numeric constants and :t
07:18:32 <skew> I was trying to introduce a reasonable fraction of the expression syntax with some motivating examples without needing to talk about defining data types first
07:23:53 <skew> for something completely different, the E website had an interesting proposal for the design of macro systems - ensure the binding structure can be determined without macro expansion
07:47:12 <shapr> skew: that's a neat idea
07:47:55 <Marvin--> E?
07:48:16 <skew> www.erights.org
07:48:43 <skew> I have only read docs, not written any actual code
07:49:41 <skew> I'm trying to track down the note about macros
07:51:51 <shapr> I've written hello world with E, but I've since removed all java dependent software from my system
07:52:10 <skew> I thought you did Java work
07:52:18 * Marvin-- has kaffe installed
07:52:21 <shapr> I do
07:52:37 <Marvin--> and jikes
07:52:48 <Marvin--> and gcj
07:53:17 <andersca> jikes
07:53:32 <Marvin--> gcj is pretty nifty
07:53:33 <shapr> when I do java work, I usually install the latest, read all the what's new in java x.x docs, write the code, give it to the client, and deinstall when the client is happy
07:53:50 <andersca> Marvin--: it is, it is
07:55:30 <shapr> imho, Java's major strong points are that it's (C++)++ and it has a big class library and bunches of 3rd party code
07:56:08 <Marvin--> the strongest point is that it's not C++ ;)
07:56:26 <shapr> but, in what way would you want Haskell to be more like Java?
07:56:39 <Marvin--> not at all
07:56:43 <skew> found it: http://www.erights.org/data/irrelevance.html
07:56:56 <shapr> I'd like better marketing and better editor support
07:57:04 <Jon> oh thats a different 'e'
07:57:08 <Jon> I thought that was http://wouter.fov120.com/e/index.html
07:57:18 <shapr> and more libs and general code
07:57:42 <shapr> wouter writes neat langs, I wish I could play with them all
07:57:56 <Jon> hehe
07:58:08 <Jon> I used to know aard from the doom community
07:58:13 <Jon> at the time I didn't know he was a language guru
07:58:34 <shapr> so, tool and lib support is what Java has that Haskell could use
07:58:34 <musasabi> How can I find the first mathing item to a predicate in a list if some of them may be _|_ ?
07:58:55 <skew> you can't
07:59:34 <skew> you can do other things, like evaluating them all in parallel and taking the first that evaluated enough to satisfy the predicate
07:59:47 <musasabi> skew: that would be ideal.
07:59:50 <skew> there's this little thing called the halting problem ;)
07:59:55 <shapr> I've seen wouter around on freenode
08:00:07 <musasabi> skew: I know that is enough (amb?)
08:01:09 * Jon looks
08:01:13 <skew> I don't know if it's all packaged up in one nice place, but you could build it with stuff from Control.Concurrent
08:01:36 <Jon> hm last seen 1wk ago
08:02:49 <skew> I would try to avoid doing that if possible, though
08:03:09 <skew> why do you need a nondetermanistic choice here?
08:03:38 <musasabi> I am going through a graph
08:05:23 <Marvin--> maybe you can do it with Control.Concurrent and Control.Concurrent.Chan?
08:06:12 <skew> you don't need Chan to code the search.
08:06:56 <skew> just make one MVar, mapM a thing that spawns a process to evaulate a list cell and put it in the MVar if it tests out okay, then have the main process block on the MVar and kill all the threads once it gets something
08:07:08 <skew> probably throw in a timeout too
08:07:28 <skew> but that's a rather crude sort of search.
08:07:30 <Marvin--> hm, true, MVar would be better than a Chan
08:07:54 <skew> most any graph algorithm can probably be expressed without a possibly non-terminating search
08:08:10 <skew> musasabi: what are you doing to your graph?
08:09:10 <Marvin--> you'll need to catch errors too, I guess
08:09:25 <skew> I think the threads just die if you don't
08:09:33 <Marvin--> hm
08:09:39 <skew> either that or they kill your program, I forget which
08:10:50 <Marvin--> kinda critical ;)
08:11:38 <skew> wow, I'm not finding it in the docs
08:12:49 <Marvin--> it seems to kill the thread, yes, but it also prints an error
08:13:26 <skew> yep
08:13:47 <skew> well, if your code can't raise exceptions that's not an issue, but otherwise you should probably catch them
08:14:00 <skew> the exception stuff did sort of split the point
08:14:08 <skew> not just _|_ anymore
08:14:16 <Marvin--> well, _|_ can be many things :-)
08:14:46 <shapr> including an infinite loop
08:14:47 <skew> not semantically
08:15:13 <skew> nowdays, just a set of exceptions
08:15:38 <Marvin--> so, you'll have something like   mapM_ (\e -> forkIO $ when (p e) (putMVar v e) `catch` const (return ())) es
08:16:01 <skew> no, you need mapM to get the threadIds so you can kill them all once one returns
08:17:42 <Marvin--> oh, right, putMVar blocks
08:18:01 <Marvin--> that's why I wanted to use a channel in the first plcae
08:18:10 <skew> I was thinking more about all the threads wasting CPU evaluating sum [1..] or somesuch
08:18:18 <Marvin--> true
08:19:06 <Marvin--> actually, mapM won't help, because it won't even get to the point of being able to kill them
08:19:23 <skew> why not?
08:19:46 <skew> I would think it would return a list of ThreadId
08:20:11 <Marvin--> no, since IO is strict
08:20:19 <Marvin--> you could do it with unsafeInterleaveIO I guess, but...eww
08:20:28 <skew> what?
08:20:46 <skew> forkIO spawns new threads
08:20:58 <skew> and we all know taking an argument isn't enough to evaluate it
08:21:17 <skew> time to write some test code, I think
08:21:27 <Marvin--> that's what I did :)
08:23:06 <skew> it won't be happy if you have an infinite list, of course
08:23:07 <Marvin--> forkIO will spawn new threads, yes, but you won't get a lazy list of ThreadIds
08:23:25 <skew> I was thinking finite list of possibly nonterminating values
08:23:31 <Marvin--> oh, sorry, I missed the 'sum' part of 'sum [1..]'
08:27:11 <musasabi> How would I do create a "sumlist" given a list and a function that produces a list from each element?
08:27:27 <skew> >>=
08:28:10 <musasabi> ?
08:28:42 * Marvin-- added stuff to HaskellIrcPastePage
08:30:18 <Marvin--> > amb even [sum [1..], undefined, 1,2,3,4] >>= print
08:30:18 <Marvin--> 2
08:32:27 <skew> I added a timeout
08:33:04 <skew> ambTimeout 1000000 id [False,error "yip"] >>= print
08:33:09 <skew> Nothing
08:33:23 <Marvin--> good, I was too lazy to do that :)
08:37:25 <andersca> don't tell anyone
08:37:28 <andersca> I'm hacking C
08:38:48 <musasabi> How do I flatten lists? 
08:39:16 <skew> concat will do that
08:39:32 <skew> if you want a function of type [a] -> (a -> [b]) -> [b] then (>>=) will do it
08:39:43 <skew> thanks to the Monad [] instance
08:40:13 <Marvin--> if you think    xs >>= f   is too cryptic, you can use   concatMap f xs   instead ;)
08:44:36 * Marvin-- goes back to fiddling with his character backstory
08:44:48 <Jon> heh
08:46:04 <Jon> beginner question: I need to test whether a is in a list [a]. I defined 'isin b c = find (==b) c /= Nothing'; but I'm pretty sure something must already exist to do this. my mind fails me 
08:46:39 <Marvin--> @type elem
08:46:40 <lambdabot> elem :: Eq a => a -> [a] -> Bool
08:47:24 <Jon> I knew it! thanks
08:47:32 <Marvin--> :)
08:47:47 <Jon> writing a simply typed lambda calculus interpreter
08:48:33 <Marvin--> nice
08:52:56 <skew> not so pretty, but ambLazy 1000000 id (repeat False) >>= print
08:53:00 <skew> Nothing
08:53:23 <skew> no unsafe* needed
08:54:14 <Marvin--> you're right, not pretty :)
08:54:21 <skew> maybe foldM would help
08:56:18 <skew> It's not that bad for what it does
08:56:53 <skew> care to write one in Java?
08:57:01 <Marvin--> true :)
08:57:28 <skew> actually, you wouldn't even a have an empty list in that case
08:57:41 <Marvin--> wonder what it'd look like in Erlang
08:57:45 <skew> uh, an infinite list rather
08:58:32 <skew> the alternative where the new thread ids get pushed down a channel might be cleaner
08:59:12 <skew> foldM seems to be a foldl
08:59:34 <skew> never mind, I think plain foldr gives the semantics I want
09:26:29 <skew> okay, I've got a cleaner function up
09:27:05 <skew> I was looking for a list function to do what I wanted, when I realized foldr building up a lambda worked just fine for threading values along
09:45:53 <Lunar^> Do anyone remember a library for command-line style completion in Haskell ?
09:46:41 <ibid> readline?
09:49:21 <shapr> hi SyntaxNinja 
09:49:49 <Lunar^> ibid: Nope, I remember sawing someone who made a library just for completion techniques
09:50:08 <Lunar^> s/sawing/seeing
09:50:23 <Marvin--> sawing someone, eh? :)
09:50:36 <skew> sounds messy
09:50:36 <Marvin--> you a magician? :)
09:50:48 <skew> like the readline binding
09:50:49 <Lunar^> Marvin--: bad english speaker surely :)
09:51:05 <Lunar^> skew: It's for hOp, I already have the editing and history part
09:53:22 <skew> can hOp run arbitrary C programs?
09:53:40 <Lunar^> No
09:53:56 <skew> so you can't reuse X servers and browsers and such
09:53:57 <Lunar^> The whole idea is trying to push Haskell to its limits
09:56:22 <skew> can you run GHC?
09:56:49 <Lunar^> Still a long way to go before that
09:57:10 <shapr> hey stepcut 
09:57:12 <Lunar^> We need a storage system, an assembler, surely a Linker also
09:57:21 <stepcut> morning shapr
09:57:44 <skew> That's too bad. Otherwise you could go around installing hOp on your computers, for some motivation to write browsers and such
09:57:50 <Lunar^> shapr: Don't see what library I might be talking about ?
09:58:14 <Lunar^> skew: I sure want to write a browser in Haskell
09:58:34 <shapr> me too
10:00:23 <shapr> Lunar^: nothing turns up from a short mailing list search
10:00:47 <Lunar^> shapr: Did I dream it ? :( 
10:01:07 <shapr> I don't think so, it sounds familiar
10:01:11 <shapr> hei esa
10:01:21 <esap> hei!
10:01:29 <shapr> but I'm not sure what keywords to use
10:01:31 <esap> what's up?
10:01:46 <SyntaxNinja> hi shapr
10:01:51 <shapr> chatting about hOp
10:02:03 <shapr> dreaming large dreams :-)
10:02:40 <shapr> Lunar^: http://shapr.homelinux.net/cgi-bin/wash/SearchML
10:02:54 <Lunar^> shapr: Forgot that :)
10:02:58 <shapr> it's still case sensitive atm
10:03:11 <shapr> but the latest HDB can fix that
10:04:18 <shapr> my cpu fans zoom when someone searches, it's entertaining
10:04:53 <shapr> esap: what's up with you?
10:05:21 <esap> shapr: well I've been trying to improve my understanding of OO.
10:05:47 <shapr> are you suceeding?
10:06:12 <Lunar^> hehe
10:06:28 <esap> shapr: Well for some issues, yes, I'm still not quite sure how to combine coalgebras and object destruction.
10:07:13 <esap> shapr: destruction of an object is pretty hard to model properly.
10:09:25 <esap> shapr: one problem is that destruction is supposed to invalidate all object references. But this would break the invariant of the object. So how to model invariants such that they allow an operation that breaks it.
10:10:28 <ibid> that's an oxymoron
10:10:46 <ibid> an invariant that it's okay to break
10:11:22 <esap> right. But If I don't do that, then I can't destroy objects at all, and they must have infinite lifetime. I don't want that.
10:11:32 <ibid> esap: well, most oo languages do that
10:11:53 <esap> Of course, but I'm not assuming garbage collection.
10:12:00 <shapr> y0 d00bring, wassup?
10:12:01 <ibid> i've even heard opinions to the effect that object destruction is harmful
10:12:28 <ibid> esap: however, i don't see immediately how object destruction breaks an invariant?
10:12:59 <Lunar^> dev lOg updated
10:13:07 <shapr> cool
10:13:37 <shapr> Lunar^: wow, did you find it?
10:14:04 <shapr> where, who?
10:14:05 <Lunar^> shapr: No, I worked on that few days ago
10:14:17 <shapr> ah, neat
10:14:32 <ibid> esap: can you elaborate?
10:14:40 <esap> ibid: The object's invariant describes what kind of properties have to hold for the state of the object. Most invariants don't allow the state to be non-existent, I'd say, because that would mean the object cannot support its methods. The purpose of the invariant is to make sure you can invoke all methods without breaking the object.
10:15:04 <Lunar^> shapr: It's based on SimpleLineEditor ( http://shapr.homelinux.net:80/cgi-bin/wash/ShowMessage?%3C%2BRIAAMb%2F4zriNAEA%40cs.york.ac.uk%3E )
10:15:40 <ibid> esap: sure, but object invariant is usually defined to hold after creation until destruction and not necessarily hold within methods
10:15:49 <shapr> oh neat
10:16:15 <Lunar^> shapr: I kept the idea of translating key sequence on abstract actions
10:16:29 <ibid> esap: ie. invariant is a postcondition of all constructors, precondition of destruction and both pre- and postcondition of all methods
10:17:16 <ibid> esap: if you try to make it stronger than that you are going to get problems with creation too
10:17:18 <esap> ibid: True. I'm not thinking of the invariant in terms of pre- and postconditions.
10:17:31 <esap> ibid: Because I think pre and post-conditions are separate from invariants.
10:17:35 <shapr> I wonder if curryspondence would be painfully slow on ScannedInAvian
10:17:37 <ibid> of course they are
10:18:32 <ibid> but pre and postconditions are the primary tools to characterize imperative programs
10:18:43 <esap> ibid: I've defined constructor as a mechanism for establishing the invariant. Clearly, a destructor is an operation that breaks the invariant. It's just not clear how to make that work if there exist references to the object.
10:18:57 <bring> shapr: 'sup
10:19:16 <shapr> bring: hackin, sup wi you?
10:19:20 <ibid> esap: are you working theoretically?
10:19:22 <esap> ibid: I'd count invariants separately as (primary) tools to characterize imperative program. I mean, while loops have invariants as well.
10:19:38 <_Codex> esap: just make type system check that you dont have any references before creation or after destruction.
10:19:43 <ibid> all invariants are secondary to pre and postcondoitions
10:20:03 <bring> shapr: just got back home, been at my parents' over the weekend
10:20:07 <ibid> loop invariants are derived from the wp semantics of loops
10:20:38 <bring> shapr: watcha hackin on?
10:20:40 <ibid> invariants help in proving stuff, but they cannot alone describe the behaviour of a program
10:20:49 <ibid> pre and postconditions can, however
10:20:56 <esap> ibid: I'm separating pre-and postconditions from invariants because I want to associate the invariant to classes, not methods, and leave pre-and postconditions to describe method arguments and return values.
10:21:24 <shapr> bring: work atm, but fun code soon
10:21:26 <ibid> esap: what are you trying to do? a programming language? some theory of programming?
10:21:39 <esap> ibid: a programming language
10:21:44 <ibid> okay
10:21:53 <ibid> i see no problem then :=
10:22:33 <esap> ibid: I'm using Haskell to try to understand how things work, and then transfer those ideas to the language.
10:22:40 <ibid> in a programming language, you can define pre and postconditions as somewhat weaker things
10:23:08 <ibid> i mean, let methods have pre- and postconditions as you intended, and classes have invariants as you intended
10:23:41 <ibid> but define them as such: after constructor has ended, the object state must fulfil constructor postcondition and the invariant
10:24:04 <ibid> a method can be called only if its precondition and the class invariant holds
10:24:07 <ibid> and so on...
10:24:31 <esap> ibid: yes, that's the approach I'm using for constructor.
10:25:05 <esap> ibid: but what is exactly the difference how the theory handles pre- and postconditions and how you'd do it in the programming language?
10:25:11 <ibid> theoretically these pre and postconditions are of course not real pre and postconditions but it does not matter
10:25:46 <ibid> esap: i just would decompose a theoretical pre/postcondition into an explicit condition and invariant
10:25:50 <ibid> in a pl
10:26:25 <esap> ibid: ok, you mean 'method precondition' + 'invariant' = 'theory precondition'?
10:26:37 <ibid> yes
10:27:11 <ibid> i'd use /\ or & instead of + there :)
10:27:14 <ibid> but otherwise, yes
10:27:43 <ibid> esap: you know, if you define a class invariant as a condition that must hold for that class instances' state at all times, it's going to create problems in practice
10:28:13 <ibid> esap: because a method will occasionally need to produce an invalid intermediate state
10:29:00 <esap> ibid: Yes, it's not 'at all times', the method can do anything as long as it leaves the state valid after it exits [or recursively invokes itself].
10:29:23 <_Codex> There was at one time an idea that 'method' = 'destructor' + 'constructor'. I.e. it'd destroy old class invariant and recreate it before end of the method.
10:29:30 <ibid> ... which describes that pre/postcondition approach...
10:29:32 <ibid> :)
10:29:36 <esap> ibid: The basic thing is, a method must be able to assume that invariants are valid when it's entered.
10:29:55 <ibid> esap: yes, and so class invariant is a part of its precondition ;)
10:31:01 <ibid> I /\ pre ==> [S] (I /\ post)
10:31:07 <ibid> using GSL syntax
10:31:36 <ibid> and i think that's also PDL syntax :)
10:33:11 <esap> ibid: I'm distinguishing invariants from preconditions on the basis of what data it applies to. An invariant applies to the state of the data, not to method arguments.
10:33:38 <esap> ibid: So it doesn't make sense to have an invariant that refers to method arguments.
10:34:02 <esap> ibid: s/state of the data/state of the object/
10:34:04 <ibid> yeah, it's a useful distinction
10:34:26 <ibid> as long as we all remember that we are using the words precondition and postcondition polymorphically :)
10:34:40 <esap> of course.
10:36:38 <esap> Anyway, the problem with destruction is how to handle the client's view to the object when the object is being destroyed. Somehow the requirements that destruction cause have to be visible to the interface of the object.
10:36:51 <ibid> from the theory pov, method parameters and object state variables are indistinguishable, they are all merely a part of the state of the computation that is the method body
10:38:52 <ibid> esap: theoretically, i'd just have an "invisible" object state variable, a flag that denotes the existence of the object
10:39:20 <esap> ibid: I think it's more complex than a mere flag.
10:39:47 <ibid> esap: practically, i'd just let accessing destroyed objects be undefined behaviour (theoretically indistinguishable from the magic computation)
10:40:07 <esap> ibid: That's exactly what I don't want to do. It'll break the nice theory.
10:40:09 <ibid> esap: if that is unacceptable, then you need to have something of the object survive destruction
10:40:18 <ibid> esap: how so?
10:40:31 <esap> ibid: Because then I have to distinguish "magic" from "non-magic".
10:41:00 <ibid> esap: what theoretical foundation are you using?
10:41:08 <esap> ibid: category theory.
10:41:17 <ibid> ok, can't talk about that
10:41:44 <ibid> i'm used to thinking in wp-calculcus / refinement calculus terms
10:41:54 <ibid> and there magic is a normal part of life ;)
10:42:19 <Marvin--> how is it magic if it's a normal part of life? :P
10:42:38 <_Codex> I dont think category theory allows you to destroy objects. The objects are just there and you dont have memory that needs to be freed :)
10:43:05 <ibid> Marvin--: magic is the program false --> skip :)
10:43:37 <ibid> Marvin--: of course, since most of us never went to hogwarts, we have to agree that magic is infeasible :)
10:44:17 <_Codex> "Any sufficiently advanced technology is indistinguisable from magic."
10:44:25 <ibid> (false --> skip is the program that, when false is true, behaves like skip)
10:45:31 <esap> I'm hoping I wouldn't introduce magic. I've actually got quite far in describing the language without needing magic. For example, I have rational numbers done [well, at least the concept built with Haskell, not a compiler yet].
10:46:37 <ibid> magic is a very useful concept in program specification
10:46:51 <ibid> if you allow nondeterminism in specs, that is
10:47:17 <esap> Yes, obviously partial specifications are useful. And I'm providing abstractions that can do the same.
10:48:45 <Marvin--> speaking of Hogwarts, how many Potter books *are* there by now?
10:48:54 <stepcut> 5
10:49:06 <Marvin--> how many years is he going to spend at that school anyway? :)
10:49:09 <stepcut> 7
10:49:27 <Marvin--> if you say so
10:49:49 <stepcut> unless he get's held back :)
10:50:46 <skew> nah, he goes straight from undergrad to grad student, to professor
10:51:30 <ibid> it never stops amazing me that a school (below university level) has professors
10:52:10 <Marvin--> "let's throw in some academic terminology"
11:00:49 <_Codex> QED.
11:41:29 <shapr> yow!
11:41:42 <shapr> hi opet 
11:43:51 <shapr> hmm
11:44:37 <opet> hello!
11:45:16 <shapr> Message from syslogd@thunderbird at Mon Apr 12 20:28:10 2004 ...
11:45:16 <shapr> thunderbird kernel: Bank 2: 940040000000017a
11:45:16 <shapr> Message from syslogd@thunderbird at Mon Apr 12 20:28:10 2004 ...
11:45:16 <shapr> thunderbird kernel: MCE: The hardware reports a non fatal, correctable incident occurred on CPU 0.
11:45:27 <shapr> should I be worried?
11:45:56 <shapr> what does MCE mean?
11:46:44 <det> @yow
11:46:45 <lambdabot> Is there something I should be DOING with a GLAZED DONUT??
11:47:00 <det> shapr: very strange indeed
11:47:40 <maihem> memory check error?
11:47:59 <shapr> probably so
11:48:52 <shapr> I have registered ECC check and scrub, I wonder if that means one stick is dying 
11:53:33 <maihem> possibly, or you chipset, or a dry solder joint. I suspect that number 94004.... may tell something
12:39:35 <wagle> lambdabot: i'll show you
12:39:35 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:27:15 <maihem> Kind error: Expecting kind `* -> *', but `StateMachine s t e' has kind `*' When checking kinds in `Monad (StateMachine s t e)' In the instance declaration for `Monad (StateMachine s t e)'
13:27:26 <maihem> I'm unsure what I'm doing wrong here.
13:27:57 <Riastradh> [[StateMachine s t e]] has to be a type that takes another type parameter if you're going to pass it to Monad.
13:27:58 <maihem> It seems that something is expecting a function, and I'm giving it a data type. but my definition for >>= looks okay
13:28:20 <maihem> ah-ha!
13:28:23 <maihem> thanks Riastradh
20:27:20 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","haskelldb 0.7 released","related channels #darcs #haskell.se","http://www.haskell.org/hawiki/EuroHaskell"]'
20:27:20 --- topic: set by shapr on [Thu Apr 01 11:54:54 2004]
