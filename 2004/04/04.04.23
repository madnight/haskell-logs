00:14:49 <blackdog> ghc-pkg is making my life difficult.
00:14:57 <blackdog> *cranky*
00:16:31 <ozone_> ooo, cranky blackdog.  sexy.
00:21:31 <blackdog> tease me not, or i'll delete your account.
02:13:47 <bring> how about an SSL library sprint at eurohaskell?
02:16:38 <earthy> what do you mean?
02:17:42 <earthy> an extension of http://www.haskell.org/crypto/ or a binding to OpenSSL or what?
02:20:22 <Si\> now your talkin bring!
02:21:04 <bring> earthy: whatever is the best way to do it :)
02:21:13 <Si\> is there gonna be a HWS-WP sprint?
02:21:30 <bring> if someone wants to do one
02:21:57 <bring> do you have a suggestion for one?
02:22:37 <Si\> I suppose that isn't n9y a precursor though
02:23:07 <bring> ?
02:23:30 <Si\> well HWS-WP needs to key things, 1) It needs it's HTTP implementation moved to use the data-types in your HTTP/1.1 library and 2) It needs a better plug-in system
02:23:51 <Si\> n9y = neccasarily or however you spell it...
02:24:25 <bring> ah
02:24:47 <Spark> monomorphic is the opposite of polymorphic, right?
02:25:07 <Si\> hmmm, I'm not sure I'd say it's an opposite
02:25:23 <bring> Si\: sounds like a good sprint, would you like to add it to the wiki?
02:25:26 <bring> http://www.haskell.org/hawiki/EuroHaskell
02:25:30 <Spark> a specific case? :)
02:28:20 <earthy> hm. hws-wp. that needs an entry in the hc&ar... pity marvin-- isn't online. :P
02:29:38 <Si\> you can't do anything with HWS-WP until we've got at least dependency tracking in the plug-in system, I can't even make HAC use XML-RPC for it's protocol...
02:30:28 <bring> Si\: come to eurohaskell and we'll work on it :)
02:30:51 <Si\> no can do, too busy
02:32:04 <Si\> Anyway I don't want it written too quickly, I want to put all that in my dissertation :D
02:32:36 <earthy> si\, you're actively working on hws-wp?
02:34:10 <Si\> no
02:34:17 <Si\> not yet anyway
02:34:22 <earthy> ah ;)
02:34:41 <Si\> please don't tag me as maintainer just yet, I barely understand the code ;)
02:36:02 <earthy> I've tagged Marvin-- as maintainer ;)
02:37:17 <Si\> I mean really, it may be a good idea to go for bottom-up restoration, rather than just adding lumps of code on
04:07:41 <earthy> cool... a bug in GHC
04:10:04 <earthy> a true one.
04:10:25 <earthy> (well, in the System/Posix library, really)
04:10:31 <Si\> suprised?
04:10:45 <earthy> not *really*
04:10:59 <earthy> just surprised that I should walk into it.
04:13:35 <earthy> ah, the things you tickle when doing somewhat silly compilations :)
04:34:54 <kosmikus> where are the most current lambdabot sources?
04:35:29 <kosmikus> is the hlibs darcs repo the correct location?
05:15:00 <Shaminotd> someone knows a good haskell environment that highlightens ie types n stuff ?
05:15:08 <Shaminotd> atm im using win hugs 98
05:15:19 <Si\> emacs?
05:15:24 <Jerub> gvim
05:17:36 <Shaminotd> they are free ?
05:17:45 <Jerub> yes.
05:18:12 <Jerub> vim is dontaionware, you're free to use it and encouraged to donate to children in uganda.
05:18:32 <Jerub> emacs is also extremely free.
05:18:36 <shapr> good morning #haskell!
05:18:50 <Jerub> Free even.
05:18:52 <Jerub> shapr: how are you!
05:19:03 <shapr> I am awake!
05:19:06 <shapr> how are you?
05:19:49 <Shammah> emacs almost defines free software :)
05:20:07 <Shammah> shapr: what timezone?
05:20:14 <shapr> CET
05:20:24 <Shammah> gmt +/- ??/
05:20:26 <shapr> ok, so it's after morning
05:20:36 <shapr> GMT + 1 I think
05:20:48 <shapr> bonjour rubix 
05:20:54 <Jerub> its @553. ;)
05:21:06 <Jerub> Shammah: thanks for the paper.
05:21:12 <shapr> it's @556 on my clock
05:21:19 <rubix> bon après-midi shapr
05:21:23 <Shammah> ahh so 9 hours behind us :)
05:21:35 <Shammah> good morning then.
05:21:55 <shapr> rubix: comment allez vous?
05:22:41 <rubix> moi, ça va plutot bien, et vous ?
05:23:16 <Shaminotd> ca va bien merci
05:23:33 <shapr> oui! moi aussi
05:24:02 <shapr> rubix: ecrivez vous Hasell cette jour?
05:24:03 <rubix> on va pouvoir créer #haskell-fr :)
05:24:10 <shapr> oui!
05:24:33 <Shammah> shapr: I must appologise for my inability to speak french :(
05:24:39 <rubix> non, pas beaucoup en ce moment, hélas
05:24:39 <shapr> same here
05:25:01 <shapr> I can't speak french well, but I enjoy what I have
05:26:32 <shapr> my swedish is better
05:26:50 <shapr> rubix: quelle dommage
05:26:54 <Jerub> I have non-conversational mandarin and cantonese.
05:27:01 <shapr> neat!
05:27:03 <rubix> i don't know a single word of swedish
05:27:18 <Shammah> unfortunately I only understand english, and a few words in italiano.
05:27:31 <shapr> rubix: hej == bonjour et tjena == salut
05:27:43 <rubix> tjena shapr :)
05:27:47 <shapr> Shammah: where are you from?
05:27:53 <shapr> tjena rubix 
05:27:53 <Shammah> .au
05:27:54 <Jerub> and I experiemnted with those made up^W^Wdesigned languages a while back
05:27:56 * shapr grins
05:28:05 <Jerub> shapr: shammah is a good friend of mine from meatspace.
05:28:16 <Shammah> where we are notorious for our inability to speak anything but english. 
05:28:26 <shapr> coi Jerub .i xu do tavla mi fo la lojban
05:29:24 <Jerub> shapr: I read about lojban, never learnt it.
05:29:30 <shapr> so, what's new in the world of pure functionality?
05:29:32 <Jerub> I put some effort into esperanto, but never actually learnt it.
05:29:58 <Jerub> err, enough of it.
05:30:22 <shapr> I like the lojban language, interesting stuff
05:34:45 <Shammah> Jerub: no problem, hope you enjoy it.
05:35:42 <Jerub> shapr: I'm mostly thinking about programming language design these days.
05:37:23 <Shammah> what is the current state-of-the-art in gui api design in haskell these days?
05:38:17 <earthy> shammah: dunno. it seems mostly stuck at getting lowlevel stuff working
05:38:30 <Shammah> feh.
05:46:02 <shapr> wxHaskell seems nice, but it's a wrapper around wxWidgets
05:47:35 <kosmikus> shapr: why "but" ?
05:48:07 <shapr> as in, it's not a high-level library like fudgets
05:48:30 <shapr> I was trying to not give a falre impression of it being fudgets-like
05:48:35 <shapr> false
05:48:58 <Si\> I'll bet you're glad I didn't try to create a binding for libxml2 :D
05:49:10 * shapr grins
05:49:24 <shapr> Si\: too bad you can't come to EuroHaskell
05:49:45 <Si\> don't think I'm experience enough anyway
05:49:55 <shapr> I think you are
05:50:36 <shapr> it's more about Haskell-interested parties meeting and learning rather
05:51:16 <Si\> have you had a look at HAIFA Alpha by any chance?
05:51:19 <shapr> kosmikus: do you think you'll come to EuroHaskell?
05:52:20 <shapr> I haven't looked at it HAIFA Alpha yet, but I will soon
05:53:18 <kosmikus> I'd like to, but I consider it unlikely that I find the time ...
05:53:36 <shapr> kosmikus: how's your thesis?
05:54:10 <kosmikus> at 257 pages and constantly growing; still not finished, though
05:54:38 <kosmikus> actually, the final version will very likely have less pages again
05:54:50 <kosmikus> but removing stuff is not yet my priority
05:55:03 <shapr> cool :-)
05:56:32 <Shammah> shapr: mmm that's sort of what I thought. :(
05:56:35 <Shammah> pity really.
05:56:47 <kosmikus> by the time of EuroHaskell, the thesis should already be away, but as I am going to Oxford the week before, I am not sure whether I can afford so much travelling, for various reasons ...
05:58:03 <kosmikus> I have a cool project to work on for the time after my thesis, though ;)
05:58:12 <shapr> oh, what?
05:58:41 <kosmikus> I'd like to keep it a secret for now. Nothing earth-shaking, but I think it could be really useful for a lot of people here on the channel ...
05:59:07 * shapr tries to be patient
05:59:14 <kosmikus> :)
05:59:30 * kosmikus feels shapr struggling
05:59:37 * shapr laughs
05:59:42 <shapr> you know me too well
05:59:55 * earthy has to stop himself from physically strangling kosmikus for the info
06:00:28 <kosmikus> you know, that would mean that you also have to do all future issues of HCAR ;)
06:01:30 <earthy> editing is not a problem... :P
06:01:40 <earthy> doing it from jail might be annoying though :)
06:02:54 <Shammah> earthy: nah.. freedom from distractions.
06:03:18 <earthy> freedom from net connections as well... :|
06:06:37 * shapr laughs
06:11:22 <Jerub> lies! all lies!
06:12:31 * shapr boings
06:17:15 <SyntaxNinja> good morning
06:29:58 <Marvin--> hey syntax
06:30:34 <Jerub> mooooooooorning :)
06:43:33 <shapr> hiya!
06:47:04 <earthy> hey marvin--!
06:47:11 <earthy> care to write up something on HWS-WP? :P
06:53:52 <Marvin--> errr
06:54:09 <Marvin--> since I haven't touched it for about a year and a half... not really
06:58:05 <earthy> 'kay ;)
06:58:17 <earthy> I'll drop it from the topics list again then ;)
06:58:30 <earthy> and wait for si\ to pick up the ball
06:58:34 <shapr> Si\: you've been playing with HWS-WP lately, want to write about it?
06:58:45 <earthy> he doesn't. :)
06:58:52 <shapr> ah
06:59:46 * Marvin-- laughs at Penny Arcade
07:00:03 <shapr> well, I invite anyone to write about haskell-libs.sf.net projects
07:00:18 <shapr> just tell me if you do, so I won't duplicate effort
07:00:29 <Marvin--> http://www.penny-arcade.com/images/2004/20040423l.jpg
07:00:44 <Marvin--> undead + ressurrect = ??
07:03:43 <Jerub> Marvin--: I believe the correct method for healing undead as per the dungeons and dragons-type worlds is an application of negative energy.
07:03:48 <Jerub> i.e. cause light wounds.
07:05:42 <Marvin--> Jerub: yeah
07:05:50 <Marvin--> Jerub: but this is from World of Warcraft
07:06:05 <Jerub> Marvin--: yes, it is confusing.
07:06:16 * Jerub played warcraft 2.
07:06:35 <Jerub> where my holy paladins would simply excorcise the poor little guy and he'd be done in instantly.
07:06:37 <vegai> "I believe the correct method for healing undead..." =D 
07:06:59 <vegai> hmm, I should go out less
07:11:11 <shapr> ?
07:11:31 <Marvin--> vegai: ...
07:15:15 * Jerub toddles off to bed.
07:15:33 <vegai> Marvin--, hmm?
07:15:47 <Marvin--> vegai: I just didn't get your point
07:17:07 <vegai> oh, ok
07:17:14 <kosmikus> Igloo: ping
07:21:39 <Si\> you rang earthy?
07:21:53 <Si\> what you mean write about it?
07:22:28 <shapr> for HC&AR
07:23:58 <Si\> erm, what would I have to write?
07:24:37 <shapr> short description, current status, that sort of stuff
07:24:41 <shapr> for example...
07:25:21 <Si\> current status : pure hackery of the highest degree :D
07:25:23 <shapr> @wiki SandBox
07:25:24 <lambdabot> http://www.haskell.org/hawiki/SandBox
07:25:36 <shapr> I wrote my stuff at the bottom there
07:27:24 <Si\> yeah, reckon I could have a bash at that, but before I commit myself, when is the deadline?
07:27:42 <shapr> I don't remember
07:36:50 <Jerub> hmmm.
07:37:01 <Jerub> I think its the time of year again that I need to start refining my python tutorial.
07:38:02 <earthy> si\: may 7th
07:39:10 <Si\> that's two days after the dissertation goes in...
07:39:35 <earthy> you'd need less than 15 minutes to write up a little statusthingy
07:39:46 <earthy> well.. maybe not less than 15, but not very much more
07:39:52 <Si\> true
07:40:05 <earthy> up to it? :)
07:40:35 <Si\> So what, I need to write the current status of it and where it might be heading?
07:40:46 <earthy> yup, and the fact that you're working on it ;)
07:41:34 <Si\> well it's more a case of drawing bits of code from the mailing list to put it in working order again
07:41:48 <Si\> and it does work I might add
07:42:06 <earthy> well, then... :)
07:42:15 <earthy> there is actvitiy! :)
07:42:24 <earthy> and activity needs reportin... so... ;)
07:43:11 <Si\> I just hope it's still working two weeks on wednesday...
07:43:28 <earthy> it doesn't need to be working! :)
07:43:35 <Si\> and they don't make me try and work it on Solaris...
07:43:50 <Si\> no, not for the report for my demo of HAC
07:44:00 <earthy> ah ;)
07:44:13 * earthy grumbles about solaris
07:44:59 <Si\> and you want me to produce a description of HAIFA and HAC too right?
07:45:08 * earthy smiles broadly ;)
07:45:13 * earthy nods
07:46:30 <shapr> hi juergen 
07:47:26 <Si\> but I'm not the maintainer of HWS-WP
07:47:35 <earthy> I'm just listing contacts
07:47:42 <earthy> willing to report on it
07:47:52 <earthy> which is quite a different thing
07:48:08 <Si\> good
07:48:29 <shapr> right, I'm listed as maintainer on HWS-WP, but I haven't used it in awhile
07:51:02 * earthy gives up on compiling ghc 6.2.1 from just a C compiler on Solaris for now
07:51:43 <Igloo> kos: pong
07:52:16 <kosmikus> Igloo: which gcc version do you use?
07:52:29 <shapr> speaking of which, I gotta get around to updating HWS-WP from Si\'s changes
07:53:13 <Igloo> gcc-3.3 (>= 1:3.3.3-2) for ghc6
07:53:29 <kosmikus> could you try if you can reproduce http://www.haskell.org//pipermail/nhc-bugs/2004-April/000436.html
07:53:33 <kosmikus> ?
07:54:19 <Igloo> Ah, nhc98 used gcc-3.2 until a couple of days ago when I tried 3.3 under pressure from the gcc maintainers. About half the arches failed I think
07:54:32 <Igloo> But x86 worked
07:54:37 <kosmikus> hmm
07:54:46 <kosmikus> it fails on my two machines
07:55:04 <Igloo> Are you using ghc to build nhc98?
07:55:13 <kosmikus> no, gcc
07:55:29 <Igloo> Ah, I could try that
07:55:43 <Si\> shapr: I've got a hws-wp patch I think somewhere...
07:55:54 <Igloo> In fact, those that failed are those that don't have ghc6 plus sparc for an unrelated reason
07:56:42 <Igloo> Yup, mips, mipsel and arm all failed in the same way as that report indicates
07:56:50 <kosmikus> yes, I could try if building via ghc6 works
07:56:54 <Igloo> So if you figure it out I'm all ears  :-)
07:57:01 <kosmikus> but I don't want to have nhc build-depend on ghc for Gentoo ...
08:40:21 <shapr> Si\: cool, would be nice
08:44:07 <Si\> ok sent
08:44:26 <Si\> It includes the changes made to the main server and the CGI plugin
08:44:46 <shapr> spiffy
08:45:00 * shapr bounces
08:45:17 <shapr> today I get to write some small paid Haskell, yay!
08:48:02 <shapr> yay XmlRpc!
08:50:49 <bring> :)
08:52:19 <bring> shapr: CS deparment head said today that eurohaskell is good and that we will get net access and such
08:52:38 <shapr> awesome! we're in!
08:52:49 * shapr dances happily
08:53:47 <liiwi> yo
08:53:52 <shapr> oh, I gotta change my stuff to use Browser?
08:54:10 <bring> you need cookies or something?
08:54:37 <shapr> probly not yet
08:56:57 <shapr> oh, is HaXML not in the debs now?
08:57:37 <keverets> it was before?
08:57:39 <bring> why do you need Browser then?
08:58:22 <shapr> er, I thought the openTCP change meant I'd have to get non 80 ports some other way
08:58:38 <shapr> but I haven't got it installed enough yet to try it
08:58:54 <shapr> keverets: I thought so
08:59:14 <bring> shapr: I add an openTCPPort or something to use non-80 ports
08:59:20 <bring> s/add/added/
08:59:40 <keverets> shapr: I've been adding it manually via source.  It would be great if it was included in a deb somewhere.
09:00:17 <shapr> bring: ah, spiffy
09:03:11 <bring> why do you need openTCP anyway?
09:03:23 <bring> with XmlRPc I mean
09:03:50 <shapr> I wasn't sure if port number stuff is still working
09:07:28 <bring> it should still work
09:07:54 <bring> simpleHTTP, which XmlRPC uses calls openTCPPort with the port number from the url
09:08:18 <shapr> ok
09:10:00 <bring> if it doesn't, consider it a bug
09:11:52 <shapr> ok
09:16:42 <shapr> bring: the current XmlRpc distro has 6.2 in the config.mk, not really a bug though
09:17:24 <bring> hmm, it would need a config system
09:17:30 <bring> but that feels like overkill
09:19:45 <shapr> yup
09:21:02 * Si\ wished he was clever enough to use autoconf and automake
09:21:13 * shapr too
09:21:37 <shapr> speaking of which, a LIP sprint would be nice
09:22:36 <bring> didn't we talk to SyntaxNinja about that a while ago?
09:23:49 <SyntaxNinja> :)
09:24:11 <shapr> maybe so
09:37:03 * ozone wishes he lived in Europe sometimes
09:37:27 <shapr> why? it's cold and rainy.
09:37:54 <shapr> well, snowy today
09:37:55 <ozone> not in the greek islands or spain ;)
09:38:07 <ozone> which wouldn't be quite as far to travel to as it is from sydney
09:39:10 <shapr> well, we have internet, and that's not too bad
09:39:21 <ozone> friend of mine has a saying
09:39:25 <ozone> beer, beef, bandwidth
09:39:27 <ozone> usa, europe, australia
09:39:32 <ozone> in each country, pick two
09:39:37 <ozone> s/country/continent/
09:40:15 <ozone> (although, come to think of it, usa only really has one of those three. :)
09:40:34 <shapr> my priority is bandwidth
09:40:48 <bring> yeah, you can import beer
09:41:04 <shapr> but you left out wimmin
09:42:05 <bring> +1 for sweden
09:43:00 <ozone> you could always extend the three b's with babes
09:43:16 <ozone> although i think it's pretty hard to generalise that: you can find babes in any country
09:43:34 <ozone> and while i'm on the topic of babes, what on earth is the deal with uppsala?!
09:43:37 <shapr> yah, sweden is the best I've seen for babes
09:43:42 <ozone> that place has a goddamn babe ratio i've never seen
09:43:51 <ozone> the rest of sweden is pretty meh, but uppsala?  jesus christ
09:43:55 <ozone> boioioioioioioing
09:44:13 <shapr> it's not just uppsala
09:44:32 <shapr> you gotta check out the north
09:45:02 <ozone> shapr: eh, you should come down here then
09:45:39 <shapr> I really wanna visit, I'm working on it
09:45:42 <ozone> brisbane especially is nearly as babealicious as uppsala is.  (and i hate brisbane :)
09:46:20 <ozone> seafood will disagree about that, mind you, but he's a brisbanite, so his opinion is automatically invalid. :)
09:47:00 <shapr> :-)
09:47:32 <ozone> don't mind me, i'm just procrastinating writing a paper
09:48:04 <shapr> I'm doing fun XmlRpc things
09:51:10 <ozone> you classify XML-RPC as fun?  interesting :)
09:52:00 <shapr> well, I'm getting paid to write Haskell code
09:52:05 <shapr> that qualifies
09:53:28 <bring> shapr: what are you using it for?
09:54:19 <ozone> shapr: nice one
09:54:58 <shapr> I'm trying to slurp Archetype instances out in such a way that I can restore them into a different Zope instance
09:56:05 <shapr> Zope/Plone/Archetypes are powerful stuff, but upgrading and migrating is painful
09:56:21 <shapr> especially if you require i18n support
09:58:05 <shapr> class instances are published,  if you change the class definition, there's no good way to change the existing instances to use that instead
09:58:34 <shapr> so I'm trying to do that myself
10:03:19 <Spark> britain has beer an beef, but bandwidth...
10:03:23 <Spark> 'no'
12:32:39 <shapr> @fortune
12:32:40 <lambdabot> Time is an illusion, lunchtime doubly so.
12:32:40 <lambdabot> 		-- The Hitchhiker's Guide to the Galaxy
12:32:56 <Matt-W> you should send that in to the readers' digest
12:33:00 <Matt-W> they've got a page for people like you
12:33:32 * shapr wonders which page
12:33:44 <Matt-W> I have no idea
12:35:20 <Matt-W> i need to do some more Haskell
12:35:56 <shapr> me too!
12:36:05 <Matt-W> I need to investigate the GTK bindings
12:36:11 <shapr> atm I'm just debugging zope's xmlrpc
12:36:23 <Matt-W> I've been doing lots of C++
12:36:29 <shapr> yikes
12:36:29 <Matt-W> and lots of Perl at work
12:36:39 <Matt-W> And I need to do some PHP at home
12:36:44 <Matt-W> but when I've done all that, Haskell time!
12:36:48 <shapr> yay!
12:37:02 <Matt-W> I need to make the effort to do a serious serious project
12:37:39 <Matt-W> It's all very well talking about how great Haskell is, but if I never use it it's a little hypocritical
12:38:03 <shapr> use it!
12:38:28 <shapr> come to EuroHaskell!
12:39:34 <flaw> eww, php..
12:39:44 <shapr> hi flaw
12:39:47 <flaw> hi
12:39:52 <shapr> wassup?
12:40:00 <flaw> eating :)
12:40:09 <shapr> I think PHP is a good example of Haskell's power actually
12:40:33 <shapr> why is PHP popular? it's easy to script HTML with it.
12:40:57 <shapr> PHP was designed with the domain of HTML scripting in mind
12:41:13 <Riastradh> PHP is popular because it's easy to churn out crap that sorta does stuff without actually using any brain power at all.
12:41:35 <Riastradh> Haskell requires the use of brains, which is not popular amongst most people.
12:41:49 <shapr> why is that good for Haskell? Haskell is really good at designing domain specific languages
12:41:55 <flaw> hehe, /me agrees
12:42:06 <Riastradh> I disagree.  Haskell has no macros.
12:42:33 <shapr> what about Template Haskell?
12:42:36 <flaw> Riastradh: preproc stuff?
12:42:38 <shapr> flaw: how so?
12:42:43 <Riastradh> And Template Haskell doesn't count: it's for running code at compile-time, not for extending Haskell's syntax.
12:43:20 <flaw> shapr: hrm?
12:43:29 <shapr> er, can you give me an example of a macro that extends syntax and can't be done in Haskell?
12:43:43 <shapr> flaw: why do you disagree? with what part?
12:43:46 <Matt-W> Riastradh: doesn't defining a new operator extend Haskell's syntax in a way that most langauges can't manage?
12:43:48 <Riastradh> scsh's AWK macro.
12:43:58 <Riastradh> Matt-W, that's absoloutely trivial syntactic extension.
12:44:18 <flaw> shapr: I was agreeing with Riastradh's statement "Haskell requires the use of brains"...
12:44:35 <kosmikus> you couldn't for example, define list comprehensions in Haskell if it wouldn't have them
12:44:37 <shapr> oh, sorry
12:44:51 <flaw> np
12:44:53 <Riastradh> flaw, writing your own preprocessor for your own DSL makes null & void any advantage you could possibly have had with Haskell.
12:45:28 <Riastradh> ('scsh's AWK macro' was directed towards shapr)
12:45:30 <Matt-W> Riastradh: you can't do it in C++ though
12:45:34 <Riastradh> (we seem to be having communication problems...)
12:45:43 <Riastradh> Matt-W, C++ doesn't enter into this.
12:47:22 <Riastradh> It doesn't matter that certain languages are _worse_ than Haskell at DSLs; what I'm arguing is that Haskell just _isn't_good_ for DSLs, because it lacks macros.
12:48:14 <flaw> macros being preprocessor macros(C/C++-like)?
12:48:24 <Riastradh> No, macros being macros (Lisp-like).
12:48:30 <Matt-W> Perl 6-style?
12:48:37 <Riastradh> I don't even want to think about Perl 6.
12:48:48 <flaw> hehe
12:49:01 <Matt-W> It's got good macros
12:49:37 <shapr> are syntactic extensions necessary for DSLs?
12:50:20 <Matt-W> hmm, ghc 6.2.1 compile... this is going to take a while
12:50:29 <flaw> yep
12:50:29 <Riastradh> shapr, how would you do scsh's AWK facility without macros?
12:50:49 <shapr> what does it do?
12:51:08 <Riastradh> It implements awk, essentially, as a macro in Scheme.
12:51:31 <Riastradh> http://www.scsh.net/docu/html/man-Z-H-9.html
12:52:13 <Matt-W> that sounds impressive
12:52:23 <Matt-W> not sure why anybody would *want* to implement awk, but doing it's pretty cool
12:52:31 <Riastradh> Matt-W, to, uh, process text.
12:52:46 <Matt-W> there are better ways to process text
12:53:11 <Riastradh> There's a better way to process delimited records in the UNIX paradigm?
12:54:21 <flaw> hehe, IFS=,; for r in $rec; do... ;)
12:55:59 * Riastradh prods Matt-W.
12:56:08 <shapr> Riastradh: I'm not convinced that syntactic extensions are necessary.
12:56:46 <Riastradh> shapr, please, demonstrate how you would design a Haskell awk facility.
12:56:49 <Matt-W> Riastradh: delimited records, awk's good at. I rarely have to deal with anything that easy though
12:57:19 <shapr> how does that test Haskell's DSL ability? 
12:57:43 <Riastradh> shapr, do you have a better suggestion, then?
12:58:50 <shapr> we could compare ease of interpreter extensions with monad transformers versus what the lisp family has
12:59:01 <Riastradh> 'Interpreter extensions?'
12:59:27 <deemon> hi
12:59:39 <shapr> extensible interpreters like the @eval plugin 
13:00:12 <Riastradh> OK.  Let's see...Lisp & Scheme have a built-in EVAL function.  What does Haskell have?
13:00:13 <shapr> have you read the paper that deals with monad transformers for extensible interpreters?
13:00:23 <deemon> why the type of    pyth n = [(x,y,z)|x<-[1..n],y<-[x..n],z<-[truncate (sqrt (x^2+y^2))]]    is   pyth :: (Enum a, RealFrac a, Integral b, Floating a) => a -> [(a,a,b)]   ?
13:00:46 <deemon> shouldn't x and y be Int-s ?
13:01:21 <deemon> or something, i'm quite newbie in haskell
13:02:42 <Matt-W> not necessarily
13:02:44 <Riastradh> deemon, no, because they could equally well be Integers, or in fact anything for which there is an instance of Enum, RealFrac, and Floating.
13:02:53 <Riastradh> shapr, no, I have not.
13:04:02 <Riastradh> shapr, what's the general idea of it?
13:05:09 <shapr> in any case, I've seen some nifty and cool DSLs in Haskell, and I don't think they were any more or less difficult to write because Haskell doesn't have syntax macros
13:05:19 <Riastradh> Can you name these DSLs?
13:05:33 <shapr> Dance and Haskore come to mind
13:05:51 <deemon> basically, i want rounded Int from sqrt
13:06:53 <deemon> hmm.. actually i don't what i want
13:07:29 <Riastradh> shapr, do you have any non-trivial examples of their use?
13:08:00 <shapr> the papers that write about them give examples of their use
13:08:15 <shapr> I think Dance is being used with industrial robots
13:08:22 <Riastradh> No, I'm not asking for quick, contrived examples; I'm asking for non-trivial examples that make full use of them.
13:08:47 <shapr> well, there's the child song that comes with Haskore
13:09:01 <shapr> and the various extensions in HasChorus
13:09:13 <shapr> what counts as non-trivial?
13:09:52 <Riastradh> Something that makes full use of Haskore or Dance or whatever, not just a couple example features thrown together to demonstrate their use.
13:10:51 <shapr> the child song is nice, I don't know if it counts though
13:11:01 <Riastradh> Where is it?
13:11:55 <shapr> it's in the Haskore distribution
13:14:56 * Riastradh swears profusely at the Haskore zip file for unzipping into the current directory.
13:15:05 <flaw> hehe :D
13:21:29 <Riastradh> shapr, it looks to me like Haskore manages to be a 'DSL' by cluttering the namespace with zillions of one- or two-character identifiers to be concise.
13:22:46 <shapr> I'd it's a DSL because it gives you first class representations of things in the domain
13:23:00 <shapr> pitch, note, etc
13:23:22 <Riastradh> You could do that with a large library for it, too, which is merely what Haskore really is.
13:23:35 <shapr> ?
13:24:32 <shapr> how do you define a DSL?
13:24:36 <Riastradh> A library for manipulating musical entities gives you first-class representations of that which is in the domain; that's all that Haskore is.
13:24:58 <Riastradh> A _language_ that is specific to a domain, such as awk, which is a language specific to delimited record processing.
13:25:16 <shapr> Haskore isn't a language?
13:25:27 <Riastradh> Haskore is merely an _API_ for manipulating musical entities that feigns DSLdom by using extremely short identifiers.
13:25:52 <Riastradh> No, it isn't, not from what I can see of it.
13:26:53 <shapr> how do you define a language?
13:27:17 <Riastradh> How are _you_ defining a language?
13:27:31 <shapr> where does a language separate itself from an API?
13:27:52 <Riastradh> The AWK macro is not just a library of functions for manipulating delimited record streams.
13:28:32 <Riastradh> There is a supplementary library of functions for use with it, but the AWK macro itself is not that library; it is itself a separate language, embedded within Scheme.
13:32:24 <shapr> does that mean that your dividing line is having a preprocessor built into the language?
13:34:47 <Riastradh> How do you define 'preprocessor?'
13:35:21 <shapr> how is a user written parser different from a macro?
13:37:32 <Riastradh> By writing an entire parser from scratch yourself, you're spending far too much time on irrelevant details, and you then have to start stacking up parser over parser for every individual macro-like device you added to Haskell.
13:39:03 <shapr> do you have the source of the scsh macro handy?
13:39:07 <Riastradh> By having a real macro system instead, you don't have to parse the entirety of Haskell -- just what your macro's syntax is --, you don't have to pile up entire Haskell(+sublanguage) parsers over entire parsers -- the macros are expanded by the Haskell implementation --, and all you're dealing with is your macro itself.
13:39:12 <Riastradh> I do.
13:42:13 <shapr> how is a macro different from a preprocessor?
13:45:00 <Riastradh> shapr, what do you mean by 'preprocessor?'
13:45:33 <Riastradh> A program that digs through Haskell source, operates on it, and spits it out, to be sent to a Haskell compiler or interpreter?
13:45:50 <Riastradh> If so, then I _JUST_ described the difference.
13:58:43 <shapr> it sounds like a preprocessor that's built into the language implementation, allowing you to define any string to map to any source code.
13:59:02 <shapr> does macro expansion happen at runtime?
14:03:56 <Riastradh> No, of course not.
14:04:52 <Riastradh> And it's not 'defining strings to map to source code.'  It's defining functions (in an abstract sense) that map their syntax to Haskell -- or Scheme, or Dylan, or whatever -- syntax.
14:09:27 <jesse> sounds too magical to me. if i were writting a DSL, whatever that might actually be, id rather write the parser myself, if seperate syntax is what qualifies the DSL as something other than a fancy library. In that sense, i dont think implementing any simple language in haskell would be that hard
14:10:47 <Riastradh> jesse, why would you want to waste your time writing an _entire_parser_ when a simple macro that manipulates _only_ the relevant stuff, your DSL embedded in {Haskell,Scheme,etc}, would suffice?
14:11:19 <jesse> it might not suffice
14:11:51 <Riastradh> Sorry, but macros definitely _do_ suffice for the example I've been giving shapr, and no one has so far given me a sufficient way to implement awk embedded in Haskell.
14:13:36 <Riastradh> I'm not talking at a purely abstract level here.  I'm using a _very_concrete_ example, awk, which so far has been supported by macros, and which so far no one has given a way to implement in Haskell aside from writing the _entirety_ of a Haskell parser with extensions for awk, which is: 1. slow; 2. unnecessary; 3. error-prone; 4. unsupportive of _other_ DSLs within the same language, because you have to make your parser work
14:14:20 <shapr> I can see the handiness of syntactical macros
14:14:32 <jesse> originally, there was no concrete example, there was just someone saying haskell is good for DSL implementation
14:14:34 <shapr> but I don't think they're necessary for DSLs
14:14:52 <Riastradh> shapr, so please: show me how to embed an awk-like language in Haskell!
14:15:35 <Riastradh> Write an entire Haskell parser with extensions for awk?  That's not a good answer, for the reasons I described above.
14:15:39 <Cale> how awk-like?
14:15:40 <shapr> your premise is that syntax extensions are necessary for DSLs, which I disagree with.
14:15:58 <Riastradh> shapr, then demonstrate why your disagreement is correct with a _concrete_example_, i.e. awk.
14:16:28 <Riastradh> Cale, it should have all the functionality of the awk language or scsh's AWK macro.
14:16:39 <shapr> awk can be rewritten without using the exact same syntax 
14:16:46 <Cale> Syntax doesn't matter though, right?
14:16:52 <Riastradh> That's right, and scsh's AWK macro doesn't use the exact same syntax as the awk language.
14:17:17 <Riastradh> Cale, you mean the exact same syntax as the awk language or as the scsh AWK macro?
14:17:25 <Cale> Okay, then make an algebraic datatype with all the appropriate information for a program, and then have something evaluate it.
14:17:41 <Riastradh> Cale, uh, that's far too abstract a solution.
14:18:13 <Cale> Still, it should be doable, so an embedding of this sort exists.
14:19:25 <Riastradh> Cale, that's the same kind of argument that shapr is using, and that's not a very useful argument.  I'm asking for some _concreteness_ here.  Is there a way to do this in Haskell aside from writing an _entire_ Haskell parser that frobs the Haskell code containing the awk facility and emits Haskell with the awk stuff preprocessed?
14:22:33 <shapr> but your idea of a Domain Specific Language is one that allows macros, right?
14:24:03 <Cale> Well, I can't see the need for a Haskell parser here, but perhaps a parser for the actual "awk" data structure. On the other hand, it probably wouldn't look all that pretty in the end, but that's another matter.
14:24:07 <shapr> er, requires
14:24:52 <Riastradh> Cale, _how would you implement an awk facility in Haskell_?
14:25:11 <mattam> clearly that'd be ugly
14:25:19 <Smerdyakov> Cale, bad question. Pose an overall problem for which an "awk facility" is the appropriate solution.
14:25:22 <Smerdyakov> Er\
14:25:25 <Smerdyakov> That was to Riastradh.
14:25:46 <Riastradh> Smerdyakov, for processing delimited text records.
14:26:09 <Cale> Like, you could just go about having the user input what would otherwise be the parse tree directly. :)
14:26:13 <Smerdyakov> Riastradh, why Awk instead of a syntax using datatypes?
14:26:31 <Cale> I'm not saying it's a good solution :)
14:27:09 <Riastradh> Smerdyakov, 'a syntax using datatypes?'
14:27:44 <Smerdyakov> Riastradh, instead of "a*", Star (Chr 'a')
14:28:06 <Riastradh> Smerdyakov, regular expressions have _NOTHING_ to do with the issue at hand.
14:28:11 <Cale> yes, this is the sort of thing I was referring to
14:28:31 <Riastradh> I don't see what's so difficult about this.  Just explain to me how you'd implement a DSL for processing delimited text records in Haskell, and also preferrably what it would look like.
14:29:09 <shapr> it would look like Haskell with some useful names and operators
14:29:11 <Smerdyakov> Riastradh, yes, and that was an example of how you can use parse trees directly in your code instead of using a "custom language."
14:29:59 <Riastradh> What I'm looking for is a _CONCRETE_ example, not just 'it would be like this' or something equally abstractly vague.
14:30:12 <shapr> bu I'm working :-)
14:30:16 <Cale> Riastradh: that's work though :)
14:30:32 <Etaoin> what's so bad about writing a haskell function which does the thing equivalent to some awk statement?
14:30:45 <Riastradh> Etaoin, demonstrate an example of it, please!
14:31:02 <Etaoin> I'd have to learn awk first
14:31:07 <Riastradh> Now, I'm not asking for a complete implementation of an awk facility in Haskell.  Nowhere have I requested that.
14:31:53 <Riastradh> Etaoin, OK, then just skim through the section in the scsh manual on its AWK macro, scanning for examples, and convert a couple of them to what you imagine this mythical Haskell awk facility would look like.
14:32:13 <Cale> presumably, you could go a long way by just implementing all the built in functions awk has as functions returning IO (), couldn't you?
14:32:20 <Cale> or IO a
14:32:27 <Riastradh> http://www.scsh.net/docu/html/man-Z-H-9.html is the chapter in the scsh manual that contains the section on the AWK macro.
14:33:55 * shapr shrugs
14:34:18 <shapr> Haskore sure looks like a DSL to me
14:34:47 <Riastradh> shapr, a generic library with some extremely short names constitutes a DSL?
14:35:06 <Cale> Yes, Haskore is a pretty good example of the "make a datatype with all the information you need in it" sort of embedding.
14:35:19 <shapr> if it matches the domain
14:35:45 <shapr> then it's 'Domain Specific', right?
14:35:52 <Riastradh> OK, so if Haskell can do it so easily, then why can't you show me how easily it can do awk, too?
14:36:09 <shapr> Cale said it first :-P
14:36:44 <Riastradh> I'm not accepting Haskore as a DSL; it's just a _library_.  By your reasoning, any library that contains its own data types is a DSL: it's specific to a certain domain!
14:37:05 <Riastradh> However, since you're so convinced Haskell can do DSLs well, then you should be able to come up with another example, right?
14:37:14 <shapr> what about Dance?
14:37:31 <Riastradh> How about awk while I'm looking for Dance?
14:38:19 <mattam> i'd venture to say Haskell do well Domain Specific Combinator Libraries 
14:38:20 <shapr> I'm actually working...
14:38:30 <Riastradh> I'm busy working, too, right now!
14:38:45 <shapr> ok, then we can agree to disagree
14:38:51 <Riastradh> But really.  Is it _that_hard_ to come up with a _mythical_ example of a use of a Haskell awk facility?
14:39:24 <Riastradh> Haskell is so great at DSLs that it ought to be really easy to translate an example of an equivalent DSL in scsh to Haskell!
14:40:49 <flaw> ok, so scsh's awk just parses text in an "awk"ish way directly into list, or array or whatever, yes?
14:40:55 <Riastradh> If you leave this argument right now, you're going to have argued _against_ your own argument by being unable to defend it by coming up with an example of what you consider Haskell _excels_ at!
14:41:05 <Riastradh> flaw, read the manual.  It's not specific to lists.
14:41:14 <flaw> I don't really know haskell, so I should probably avoid this conversion, but I'm strangely intrigued..
14:41:20 <flaw> ugh
14:41:20 <Riastradh> http://www.scsh.net/docu/html/man-Z-H-9.html, in case you forgot.
14:41:23 <flaw> conversation..
14:41:34 <flaw> yeah, I looked at it a bit
14:42:28 <jesse> so.. read a manual, and implement awk in haskell, while you are looking for dancer?
14:42:30 <shapr> Riastradh: I'll probably try that at some point, but right now, I have paying Haskell work, and that's more interesting.
14:42:36 <Riastradh> No, _not_ implement.
14:42:53 <Riastradh> All I want right now is an _example_ of the use of a _mythical_Haskell_awk_facility_.
14:43:22 <Riastradh> Once you've managed that, an _idea_ of how it might be implemented; nothing complicated by detail.
14:43:39 <Riastradh> If Haskell excels so much at DSLs, this sort of thing should be a piece of cake, shouldn't it?
14:43:46 <mattam> (awk (read) (i) ((npos 0)) ((> i 0) (+ npos 1))) is not easily translated
14:44:06 <selmanj> what does it mean if the type signature of a function has something like Eq a => a in it?
14:44:26 <selmanj> ie: levels :: Eq a => a -> Tree a -> [Int] ?
14:44:32 <shapr> selmanj: means it has to be an instance of the Eq typeclass
14:44:44 <mattam> how do you bind i, how to pass the inititialization of npos etc ...
14:44:52 <selmanj> ah, excellent, so that means that a must be comparable to other as
14:45:04 <shapr> selmanj: yup
14:45:09 <selmanj> shapr: thanks :)
14:45:10 <Riastradh> mattam, er, what?
14:45:56 <Riastradh> I gets bound to what READ returned on each successive iteration.
14:46:06 <Riastradh> NPOS begins as 0 and is incremented each time a positive integer is read.
14:46:11 <mattam> if we want a somehow resembling hackell code, then we have this problems
14:46:11 <shapr> selmanj: if you're new to Haskell, I'd recommend the url in the topic, questions here
14:46:25 <Riastradh> mattam, it doesn't have to use present Haskell libraries.
14:46:33 <Riastradh> I'm asking for a _mythical_ awk facility for Haskell.
14:46:39 <mattam> that's not what i'm saying
14:47:09 <Riastradh> What are you saying, then?
14:47:14 <mattam> i'm saying you cannot mimic awk's programming model in Haskell
14:47:53 <Riastradh> mattam, it doesn't matter if it's the same model that AWK uses; what scsh uses is a pretty different model, too: it uses something a lot closer to Scheme.
14:48:14 <Riastradh> What matters is that it's a DSL that processes delimited text fields.
14:48:26 <Riastradh> And that you can translate the scsh examples into their Haskell equivalents.
14:50:03 <flaw> I never really liked awk much myself.. ;)
14:50:28 <Riastradh> flaw, well, right: that's the point: you want to do what you would previously have done with awk in Haskell.
14:51:02 <mattam> then 'awk read (\npos i -> if i > 0 then npos + 1 else npos) O'
14:51:37 <mattam> i'm not sure what you mean by mythical :)
14:51:41 <Riastradh> mattam, OK, how would you go about implementing it?
14:51:51 <Riastradh> (not a real implementation; just give me a sketch of the implementation's design)
14:52:13 <flaw> ok, awk-similar functionality in haskell?
14:52:22 <Riastradh> flaw, yes.
14:52:34 <flaw> so, a parser of sorts?
14:52:49 <Riastradh> mattam, and how would you handle the rich & convenient variety in AWK clauses?
14:53:17 <mattam> i don't know :)
14:53:17 <Riastradh> flaw, not really.  The user of this Haskell awk facility would input the specific field readers, as in scsh.
14:53:29 <Riastradh> mattam, well, that weakens the argument that Haskell is great at DSLs, doesn't it?
14:53:40 <mattam> i completely agree
14:54:23 <Riastradh> ...then why are you trying to give me the example I ask for, i.e. attempting to attack my argument?
14:55:01 <mattam> i'm not attempting to attack your argument
14:55:10 <flaw> hrm, so a parser generator of sorts, no? feed the generator the field readers, "return" generator and then parse IO?
14:55:26 <Riastradh> flaw, er, huh?
14:55:30 <mattam> i just proposed some expression and pointed at problems
14:57:16 <mattam> someone could write a combinator library that handle the rich & convenient variety of AWK clauses though.
14:57:25 <flaw> well, awk is a kind of parser generator, isnt it? a parser is generated/rendered based upon the field readers, right?
14:57:41 <Riastradh> OK, so demonstrate how one might use that for the examples in the scsh manual, mattam.
14:58:08 <mattam> (now i attack your argument you see :)
15:00:35 <mattam> you could have a fields function that split lines and associated field access functions
15:03:09 <mattam> some regexp makers that you could use to match lines/fields , with common control structures 
15:03:56 <mattam> that's approximately all i see
15:05:39 <mattam> maybe some constructions to ease the filtering too
15:08:51 <flaw> there's a rather nifty parser generator for python; simpleparse I think it's called; it's almost fun to use ;)
15:45:31 <selmanj> whats the name of the function that returns the largest element in a list?  
15:45:49 <Smerdyakov> I'll be surprised if there is such a standard function.
15:46:03 <selmanj> Really?  Damnit.  Sorry, I'm new to haskell.
15:46:14 <Smerdyakov> It's very easy to write.
15:46:26 <selmanj> I think I can get around it by using max actually
15:46:26 <keverets> fold a max function.
15:47:08 <selmanj> is there a place i can find a list of all the standard functions in haskell?
15:47:14 <keverets> the prelude.
15:47:40 <selmanj> no online reference?
15:51:45 <bring> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:52:48 <selmanj> thanks
17:19:32 <shapr> hm
17:51:58 <heatsink> parsing symbols separated by optional whitespace, does it matter (in terms of efficieny) whether I make the grammar (Space* Symbol)*, (Symbol Space*)*, or (Space* Symbol Space*)*
17:52:59 <heatsink> ...I guess that question can't be answered without knowing the implementation
17:54:22 <Jerub> heatsink: uhh, better to assuming no leading spaces.
17:54:34 <Jerub> and strip off trailing space, and strip off space before you start parsing.
17:54:38 <Jerub> thats how parsec does it anyway.
17:54:52 <heatsink> alright
17:55:33 <Jerub> and of course you need your whitespace function to observe comments :)
17:58:32 <heatsink> right, I was actually thinking about borrowing CPP for that step
18:22:31 <Jerub> heatsink: I seriously recommend reading the parsec paper, and possibly even using the parsec library.
18:23:13 * heatsink is reading parsec now
18:23:50 <heatsink> I don't know whether what I'm reading is what you mean by the parsec paper
18:24:28 <heatsink> I see a link to the reference guide, and to the technical report on the webpage
18:26:28 <Jerub> "Parsec, a fast combinator parser" by Daan Leijen, published 4th Oct 2001
18:26:43 <Jerub> according to the hardcopy I found directly underneath my laptop.
18:27:58 <Jerub> technical report.
18:28:00 <heatsink> (:
18:28:46 <heatsink> That's what I was reading, yes
18:28:46 <Riastradh> mattam, sorry, I had to leave.  The problem with what you suggest -- defining those functions that split lines, perform regular expression matching, et cetera -- is that by doing that you're implementing only the supplemetary library for AWK, not the AWK macro's equivalent itself.
18:30:00 <Jerub> heatsink: it has some cool stuff, like composing the 'symbol' function with the whitespace function, so that 'symbol "if"' will consume an 'if' token and all trailing whitespace
18:47:22 * heatsink notices suddenly that the author's name is like Da'an from Earth: Final Conflict
19:00:27 <shapr> Riastradh: Haskell does have a macro system, it has all of scheme as a scripting language :-)
19:02:33 <shapr> hscheme.sf.net
19:08:33 <shapr> @yow !
19:08:34 <lambdabot> I'm continually AMAZED at th'breathtaking effects of WIND EROSION!!
22:13:35 <Gahhh> question:
22:13:47 <Gahhh> data Point a b = Pt a b | Pt2 a b
22:13:55 <Gahhh> glut ::			Point a b -> (a,b)
22:14:03 <Gahhh> glut (Pt  x y)		= (x,y)
22:14:07 <Gahhh> hugs says:
22:14:20 <Gahhh> Inferred type is not general enough
22:14:34 <Gahhh> Inferred type : Point a a -> (a,a)
22:14:49 <Gahhh> why does it infer that ?
22:16:10 <dennisb> it doesn't here
22:16:47 <dennisb> you probably have yet another line matching on Pt2?
22:16:54 <Gahhh> yes
22:17:03 <Gahhh> glut (Pt2 x y)		= (y,x)
22:17:15 <dennisb> and there you have it
22:17:30 <dennisb> what type does the first element in the pair have?
22:17:40 <Gahhh> in the 2nd match ?
22:17:44 <dennisb> yes
22:17:48 <Gahhh> type x
22:18:22 <dennisb> no, it has the type that the variable y has, that is type b in the data
22:19:23 <dennisb> Think about an instance where you have Point Int String, now, What type does the first component in the pair have?
22:19:34 <Gahhh> Str Int
22:19:37 <dennisb> It would be String in the second match
22:19:44 <dennisb> and it would be Int in the first match
22:20:24 <Gahhh> oh
22:20:28 <Gahhh> so it reads it as
22:20:38 <dennisb> so, these types has to be the same for that function to work
22:20:47 <Gahhh> glut (Pt2 b a) = (some_a, some_b) ?
22:20:51 <dennisb> thus, the type has to be Point a a -> (a,a)
22:21:16 <Gahhh> ok I got it
22:21:28 <dennisb> I didn't understand the last thing you asked
22:21:44 <Gahhh> never mind that
22:22:58 <Gahhh> thanks
22:23:51 <Gahhh> actually, hugs reported the error for the wrong line.
22:27:08 <dennisb> but what is the correct line is the question
22:27:47 <dennisb> it could be the function that is correct and the type you gave that is wrong. Or it is the type that is correct and one of the two lines in the function that is wrong
22:28:13 <Gahhh> well, I was just messing around
22:28:23 <Gahhh> trying to learn
22:28:42 <Gahhh> I picked a tuple so that it wouldnt have to be homogenous
22:28:48 <Gahhh> but I forgot about the order
22:29:14 <Gahhh> the 2nd line tries to swap the order within the tuple, which is a violation.
22:29:14 <dennisb> my point is that probably the line hugs reported was the correct line, but another line would also have been correct
22:30:08 <dennisb> the function works fine if you just give it another type
22:30:23 <dennisb> it might not do what you wanted it to do however
22:31:37 <Gahhh> yeah. I was just trying to demonstrate something to myself. I learned something else on the way, heh
