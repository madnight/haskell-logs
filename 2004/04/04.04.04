01:47:03 <wglwill> has anyone here sucessfully compile hopengl?
03:01:20 * Marvin-- swears
03:11:40 * XTL yawns
03:12:38 <wglwill> *sigh*, this is frustrating, i can't get hopengl to compile under gentoo linux or cygwin, i think it has to do with greencard generating some faulty .hs files for one reason or another
03:22:31 <Igloo> Are you trying to compile the stnadalone one or the one that comes with GHC?
03:24:30 <wglwill> standalone, is there one included with ghc though?
03:24:41 <wglwill> i didn't even consider that
03:25:01 <wglwill> i figured if it was included it would be compiled
03:25:28 <wglwill> right now i'm bouncing back and forth between my linux install and windows install trying to get at least one to work
03:26:39 <Igloo> Give configure something like --enable-opengl
03:27:31 <wglwill> that would work with the standard 6.2 source package?
03:27:58 <Cale> wglwill: The "standalone" hopengl is old and broken, iirc. You certainly want the one that comes with ghc.
03:28:06 <wglwill> ah i see
03:30:10 <Cale> Check out all the configure options for ghc before compiling. There are probably at least a couple you want to turn on (including hopengl)
03:30:47 <wglwill> ok, cool, i read that that opengl flag only worked with the cvs source on the hopengl page, i guess that must be out of date
03:30:55 <wglwill> so i didn't even try it
03:31:49 <Cale> yeah, as far as I know, the hopengl page is very outdated - in fact, I'm not sure why they don't just replace it with a page saying that hopengl is now distributed with ghc.
03:32:58 <wglwill> well, that's good news, thanks
03:33:41 <Cale> If you got your ghc from your distribution, you might just check whether ghci -package OpenGL works.
03:34:19 <wglwill> i don't think it does, i installed the gentoo package
03:34:29 <wglwill> i'll have to see about editting the .ebuild manually
03:34:45 <wglwill> maybe suggest that as a default option to the maintainer
03:34:55 <Cale> yeah
03:35:14 <Cale> It can't be that much extra compile time percentage-wise :)
03:35:33 <wglwill> hey is making your own partial bindings to an external library extremely difficult?
03:35:53 <Cale> no, I did this the other weekend with Imlib2
03:36:01 <wglwill> at some point i may need bindings to some sdl functions
03:36:23 <wglwill> so would you recommend greencard for doing that?
03:36:27 <Cale> It took me several hours (for the 200 or so functions), and was mildly tedious, but worked great.
03:36:33 <Cale> I did it by hand.
03:36:48 <Cale> Haven't tried any of the preprocessors.
03:37:03 <Cale> You'll probably want to do some thin marshalling by hand anyway.
03:37:32 <wglwill> i guess it would be a good learning experience
03:38:04 <Cale> I should put my code somewhere... hang on a bit, and I'll put it on my website.
03:39:42 <wglwill> haskell has built in support for multithreading doesn't it? with concurrent haskell
03:39:52 <Cale> yep
03:39:58 <Cale> rather nice to use too.
03:40:09 <wglwill> nice, i'm just getting into haskell
03:40:31 <Cale> http://vx.hn.org/haskefl/Imlib2.hs
03:40:44 * shapr boings cheerfully
03:40:46 <shapr> goood morning #haskell!
03:40:51 <wglwill> but i wanted to get this opengl working before i started trying stuff out, graphics programs are fun to make
03:41:03 <Cale> Probably could use some cleaning up here and there, and there are a couple of things not done, but it works.
03:41:08 <Igloo> Hey shapr
03:41:12 <Cale> Hi shapr
03:41:24 <shapr> it's great to be awake!
03:41:32 <wglwill> well, i don't think i could even tell if it did need cleaning up :)
03:41:44 <wglwill> thanks
03:41:54 <shapr> hej phubuh 
03:41:54 <Cale> It's essentially the same thing over and over, mostly. :)
03:42:01 <phubuh> hallÃ¥ hallÃ¥ shapr
03:42:57 <Cale> anyway, it's morning. Time to go to sleep. :)
03:43:11 <shapr> :-)
03:43:16 <Cale> but I'll post a small demo first
03:47:35 <bourbaki> hiho
03:47:42 <shapr> greetings
03:50:49 <Cale> http://vx.hn.org/haskefl/examples/convert.hs
03:51:00 <Cale> I'll have to write a more complex example at some point.
03:51:19 <Cale> but have a look at that, should give some idea of how the library works :)
03:57:14 <shapr> hiya atom-z 
03:57:37 <nate_d> any lisp-to-haskell converts here?
03:57:50 <shapr> I'm a Python to Haskell convert, if that helps any.
03:58:08 <atom-z> i'm not quite converted yet
03:58:25 <atom-z> although i see haskell's usefullness when writing algorithmic programs etc
03:58:34 <shapr> have any questions?
03:58:56 <atom-z> why do you think its better than python?
03:58:59 <nate_d> well, for any-to-haskell converts, can you maybe tell me what class of problems are more easily or more elegantly expressed in haskell?
03:59:26 <nate_d> I'm specifically interested in things related to the type system, currying, and lazy semantics
03:59:30 <atom-z> nate_d: algorithms, especially recursive solutions
03:59:59 <shapr> in my experience, I can get better abstraction with haskell than with Python
04:00:05 <shapr> and 'safer' abstraction
04:00:30 <shapr> Python's primary abstraction is OOP, which cuts state into smaller pieces
04:00:42 <shapr> Haskell moves all the state in a program into a single piece
04:01:14 <shapr> I've had trouble unit testing programs like J2EE because all the objects have to be in the right state for me to test my code
04:01:30 <shapr> it's easier when I can just manufacture a state to test with
04:01:32 <atom-z> i see
04:01:52 <shapr> it seems to also make for code that's easier to reuse, since you don't depend on internal state
04:02:16 <shapr> so, for many things I'd rather use Haskell
04:02:32 <atom-z> hmm
04:02:35 <atom-z> i see
04:02:58 <nate_d> does the strict functionality (no destructive operations) make certain problems exceedingly difficult to express?
04:03:12 <shapr> my favorite features are the conceptual lego of algebraic datatypes, and 'object instance' thingy you get from partial application... I could probably go on
04:03:46 <vegai> nate_d: that's much better than making all problems difficult =)
04:04:03 <vegai> which seriously quite many languages do
04:04:12 <shapr> I think pure FP does make some problems more difficult to express
04:04:28 <shapr> but I wouldn't same exceedingly difficult, just difficult
04:04:29 <atom-z> what about its uses in server-side applications (web-apps), GUI programs & graphics programs?
04:05:00 <shapr> I wrote a small webapp in Haskell recently, I'd be happy to show you the source and the app itself
04:05:26 <atom-z> what does it do?
04:05:33 <shapr> Cale just posted some demo code for his Haskell binding to Imlib2, so I think graphics aren't too hard
04:05:40 <nate_d> can I ask what what your (any of you) favorite "feature" is?
04:05:54 <vegai> typing
04:05:58 <shapr> and you should see Pan, Pancito, and some other image libs out there
04:06:13 <phubuh> nate_d: I adore type inferring combined with type classes.
04:06:46 <shapr> my tiny webapp: http://shapr.homelinux.net/cgi-bin/wash/SearchML
04:07:20 <shapr> the source for my tiny webapp: http://www.scannedinavian.org/~shae/curryspondence0.9.tar.gz
04:07:42 <det> nice name :)
04:07:47 <atom-z> i shouldn't have searched for "code"
04:07:49 <shapr> thanks :-)
04:09:02 <nate_d> how exactly does the type-inference help? compile time checks?
04:09:07 <atom-z> proves it can handle insane data sets though
04:09:17 <shapr> anyway, curryspondence is pretty short, less than two hundred lines I think
04:09:52 <shapr> yah, I have 20k email messages in the database at the moment
04:10:01 <phubuh> nate_d: Static typing without all the annoying, um, typing. :-)
04:10:18 <nate_d> and in practice, how much do you have to explicitly state the types of things
04:10:19 <nate_d> ?
04:10:27 <shapr> less than 1% of the time
04:11:03 <atom-z> well i only really started messing with haskell on friday, but so far i've found it very easy to express problems (e.g. the RSA algorithm)
04:11:05 <phubuh> Most people give their functions declarations anyways.  It's great documentation.  Often, you can figure out what a function will do just by looking at the type.
04:11:17 <phubuh> (a -> b) -> [a] -> [b] anyone? :-)
04:11:27 <shapr> @type map
04:11:27 <lambdabot> map :: (a -> b) -> [a] -> [b]
04:11:43 <shapr> cool, type signature Jeopardy
04:11:47 <atom-z> takes a function and a list and returns a list :P
04:11:59 <shapr> What is map?!
04:12:02 <phubuh> shapr: Yay, you win!
04:12:05 <shapr> w00!
04:12:31 <atom-z> or more specifically takes a list of a's, a function that turns a's to b's and returns a list of b's
04:12:42 <shapr> ok, what about "a -> m a" ?
04:12:54 <phubuh> @type return
04:12:54 <lambdabot> return :: Monad a => b -> a b
04:13:00 <shapr> yup, you got it!
04:13:06 <phubuh> Whee!
04:13:08 <nate_d> I'm afraid I haven't clued in to the whole monad thing yet
04:13:22 <atom-z> yeah i'm finding those kinda annoying
04:13:44 <shapr> they're not difficult or complicated, they're just an abstraction like Objects in OOP
04:13:54 <shapr> and you have to twist your brain into just the right angle to 'get it'
04:14:04 <maihem> I'm just starting to get them. Though I haven't implemented one yet.
04:14:04 <shapr> I'd suggest the nomaware monad tutorial
04:14:09 <maihem> Just working on one now
04:14:20 <atom-z> the tutorial i'm reading says that they represent actions, not functions
04:14:35 <shapr> yup, a monad is like a first class action, one step above a first class function
04:14:40 <nate_d> one of the things that irritates me so far is that the entire language isn't available in the interpreter
04:14:45 <saz> shapr: first class?
04:14:57 <shapr> saz: an action can be a value
04:15:08 <saz> oh.. i see
04:15:14 <shapr> as I understand it, value, function, monad, arrow
04:15:20 <maihem> nate_d: the interpreter runs in the IO monad, rather than the where clause of a module
04:15:26 <shapr> it's like what's his names pyramid of operators
04:15:35 <maihem> nate_d: so you can't import, and you have to use let
04:15:40 <shapr> was it ackerman who did the pyramid of operators?
04:15:47 * saz doesn't really know about arrows
04:15:56 <phubuh> Or Chomsky's language hierarchy.
04:15:58 <saz> i've always imagined monads as state variables
04:15:59 <shapr> saz: sharp, pointy, dangerous ;-)
04:16:19 <Jezral> Problem: http://sdu.projectjj.com/DM22/ - the Heap works and maintains it's sorted state...but I cannot get it to parse if I use newtype instead of type, and I have to use newtype in Set, since I need to define == and <= for the Set type.
04:16:21 <shapr> well, the maybe monad isn't
04:16:43 <atom-z> saz: thats kinda what my tutorial says too
04:16:51 <nate_d> is it difficult to interface with C code?
04:16:58 <saz> you're passing around this implicit state
04:17:00 <saz> i think
04:17:02 <atom-z> nate_d: doubt it, once you know what you're doing
04:17:14 <shapr> the Foreign Function Interface makes it pretty easy to interface with C code
04:17:28 <atom-z> but what about running haskell functions/actions from C?
04:17:30 <shapr> there's a basic FFI tutorial on the HaWiki
04:17:54 <shapr> atom-z: from what I've heard, that's more difficult than just wrapping C functions in Haskell, but not tremendously more difficult
04:18:16 <shapr> I haven't done that myself (my hands feel dirty when I manage my own memory :-)
04:18:44 <shapr> actually, it's just boring to find the bugs I've introduced when I manage my own memory
04:18:45 <atom-z> what about interfacing haskell with faster languages like ocaml?
04:19:33 <phubuh> I see a monad as something with which you can only do one thing: somehow combine it with another monad.  They're abstractions of value combining.  The monad tunnels data from value to value, and while it's tunneling, it can manipulate it -- by, say, tunneling some state through (the State monad), or making sure the data isn't an error (the Maybe monad).
04:19:39 <atom-z> shapr: if you do it for long enough, those bugs dont occur anymore (or when they do occur its something amazingly obscure and you have to use efence to find it)
04:19:43 <det> atom-z: they both interface with C
04:20:02 <det> atom-z: perhaps you could generate a C library with ocaml and wrap it in ocaml :)
04:20:17 <atom-z> hmm
04:20:24 <shapr> atom-z: my priority is to find the most expression with the least amount of code
04:20:42 <shapr> though I agree that sometimes it's necessary to write C, it's just not my preference
04:20:49 <atom-z> mine's the same, except the least amount of time
04:21:09 <atom-z> i only use C for opengl stuff
04:21:22 <shapr> HOpenGL is pretty fast
04:21:34 <phubuh> Lines of code written -- somewhat surprisingly -- is often proportional to the time taken.  No matter how expressive the language is.
04:21:47 <atom-z> the last thing i wrote was a newtonian gravity simulator
04:21:53 <det> atom-z: OpenGL is high-level enough that it can be fast in any language :)
04:22:10 <atom-z> det: i'm aware of that
04:22:36 <det> then why only use C for opengl stuff?
04:22:37 <atom-z> det: except that things like python wrap it in slower libraries like SDL
04:22:55 <det> atom-z: you seem confused
04:23:09 <shapr> there are two Haskell SDL bindings than I know of
04:23:11 <det> atom-z: PyOpenGL doesnt need SDL
04:23:30 <atom-z> det: it doesnt?
04:23:39 <det> atom-z: however, it can use SDL (pygame) for creating a context and event handling
04:23:44 <det> atom-z: it can also use glut
04:23:49 <atom-z> what about glX?
04:24:09 <det> atom-z: if you write your own glx python wrappers, sure
04:24:15 <det> but I dont believe any exist
04:24:23 <atom-z> hmm
04:24:37 <det> and using OpenGL with a context created by SDL isnt slow
04:25:08 <det> atom-z: you are best off just using SDL since you get events and audio, etc as well with it
04:25:13 <det> and it is cross platform
04:25:15 <det> and tiny
04:25:37 <atom-z> well anyway, languages like C can run the sorting/culling/animation/etc algorithms faster than python can, and opengl in C is quite easy, so i have so far written opengl stuff in C
04:25:49 <det> ahh, yes
04:25:59 <atom-z> det: it is slower from my experiance
04:26:04 <det> but that isnt "OpenGL" that is "sorting, culling etc.."
04:26:16 <nate_d> well, thanks for all the help guys
04:26:17 <nate_d> later!
04:26:21 <atom-z> nate_d: bye
04:26:28 <shapr> nate_d: sure, come back and ask questions if you have more
04:27:19 <det> I msut admit, however
04:27:29 <det> PyOpenGL sucked as far as I remember
04:27:59 <det> glTexCoordArray* was broken even!
04:28:22 <det> and it used SWIG
04:28:41 <atom-z> i havent really used it
04:28:51 <det> yeah, well I have moved on from python
04:28:54 <atom-z> python's great for, well, agile programming though
04:29:08 <det> so I havent kept up
04:29:12 <shapr> I think Haskell is great for agile programming too.
04:29:17 <shapr> possibly even better.
04:29:20 <det> what is "agile" programming?
04:29:29 <shapr> agile programming started with XP
04:29:34 <shapr> eXtreme Programming
04:29:42 <det> can you summarize?
04:29:55 <shapr> unit test first, short iterations
04:30:11 <shapr> merciless refactoring, collective code ownership
04:30:28 <det> I see
04:30:28 <atom-z> http://www.oreillynet.com/pub/wlg/3060
04:30:56 <shapr> Uche is a smart guy
04:31:40 <shapr> one complaint you hear about unit-test-first in Java is that the types often have to be rewritten
04:31:48 <det> haskell appears to fail the 3rd party library part :)
04:31:59 <shapr> in my opinion the compile-time dynamic-typing of Haskell is an advantage there
04:32:11 <atom-z> how long has haskell been around?
04:32:17 <det> shapr: compile-time dynamic-typing?
04:32:52 <shapr> type inferencing means you get what is effectively compile-time dynamic-typing
04:33:09 <det> oh
04:33:21 <det> dont most haskell programmers declare the types anyway?
04:33:26 <shapr> some do
04:33:36 <shapr> I only do it where I want to avoid ambiguity
04:33:49 <shapr> or where I know the type but not the function itself
04:34:01 <det> I see
04:35:13 <shapr> atom-z: http://www.haskell.org/haskell-history.html
04:35:29 <shapr> haskell 1.0 standard was 1990, haskell 98 you can guess
04:36:00 <det> shapr: yeah, i really like thinking in types before code :)
04:36:24 <shapr> it can be an advantage at times
04:36:46 <shapr> I'm becoming more persuaded that static typing can be advantageous the more I use Haskell
04:36:54 <det> so, when do you expect functional programming to takeover the world shapr?
04:37:03 <shapr> but I don't think anyone will convince me that Java's type system is a help more than a hindrance
04:37:12 <shapr> I think less than ten years
04:37:39 <shapr> g'day Jerub 
04:38:09 <det> shapr: and when can I convince you to start using SML? :)
04:38:40 <shapr> when it adds type classes, lazy evaluation, and pure functionality ;-)
04:38:53 <det> but then it would be haskell ..
04:38:53 <det> wait
04:38:56 * shapr grins
04:39:07 <phubuh> @type show
04:39:08 <lambdabot> show :: Show a => a -> String
04:39:08 <shapr> actually, I'm sure I'll check it out at some point
04:39:22 <det> shapr: type classes I would really like :)
04:39:23 <phubuh> If SML can give me that, I'll consider it. :-)
04:39:41 <det> shapr: but then you have to decide when to use functors and when to use type classes
04:39:41 <Jerub> whats SML?
04:40:03 <det> shapr: it would be interesting to see a SML with type classes and no functors
04:40:08 <shapr> fram what I know about SML, you lose several of the expressive parts of Haskell to get an increase in execution speed
04:40:34 <det> well
04:40:42 <phubuh> I don't suppose there's some kind of magic a -> String function in some SML implementation's library?  The lack of show is _pesteringly_ annoying.
04:40:45 <det> strict vs normal-order (lazy even)
04:41:25 <det> phubuh: you can always write a pretty-printer :/
04:41:58 <det> no type classes in SML
04:42:16 <det> it has functors
04:42:23 <det> those are the biggest
04:42:46 <det> does haskell have any kind of module system?
04:42:59 <shapr> not a first class module system
04:43:03 <phubuh> Yup.  I like SML's more though.
04:43:15 <shapr> yah, I've heard good stuff about SML's module system
04:43:25 <det> shapr: SML's is compile time only
04:43:32 <shapr> oh
04:43:47 <det> you cant pass around modules
04:44:02 <shapr> too bad
04:44:18 <shapr> I was thinking it would be useful for network portable code
04:44:32 <det> shapr: howso?
04:44:39 <det> and what is network portable code? :)
04:44:50 <shapr> open a socket, send across the module's type signature
04:45:19 <shapr> or just pass around the whole module
04:45:40 <det> well
04:45:52 <det> sending module over sockets is far from first class modules :)
04:46:32 <shapr> first class module might let you do handy stuff like comparing type and implementation equality
04:46:58 <det> I dont understand what you mean
04:47:05 <det> sounds dynamic-typish
04:47:18 <shapr> it is, I guess
04:48:40 <det> python has corrupted you
04:48:49 <det> 10 hail marry's
04:48:52 * shapr laughs
04:49:16 <shapr> just that it would be neat to distribute a computation across multiple running GHC runtimes
04:49:35 <shapr> if you could send across the code to be executed
04:49:58 <saz> marry's!
04:50:21 <Marvin--> damn
04:50:40 <shapr> marriage is great!
04:50:41 <shapr> one...
04:50:51 <shapr> actually, I'm a baptist.
04:51:11 <Marvin--> since I'm able to prove this, but the theorem prover is not, I must've screwed up at least once
04:52:43 <phubuh> Maybe you're just smarter.
04:53:22 <Marvin--> what I mean is that I've either screwed up my proof, or my instructions to the theorem prover (or both)
04:54:29 <phubuh> Oh. :-)
04:57:03 <Marvin--> since the idea is to make the theorem prover work *for* me, that I succeed and it does not is not *progress* ;)
05:02:13 * Marvin-- alternates between swearing and sighing
05:02:20 <maihem> I want to define a data where it can have a class in one of the constructors, eg: data MyData = MyData MyClass; class MyClass; But this is not allowed. how do I get similar behaviour?
05:03:37 <Lunar^> maihem: What are you trying to do ?
05:04:22 <maihem> ah, I know... data MyData a = MyClass a => MyData a ?
05:05:23 <maihem> hm, no
05:06:50 <maihem> yes! data MyClass a => MyData a = MyData a
05:15:16 <det> saz, I have only heard it in spoken form
05:15:21 <det> saz, how is it written?
05:16:03 <Marvin--> det: Hail Mary, perhaps? ;)
05:16:26 <det> so like Hail marys :)
05:18:27 <saz> yeah
05:18:28 <shapr> I think the football term comes from the fact that a long bomb pass is extremely risky, so you better pray :-)
05:18:32 <saz> Hail Marys
05:19:43 <saz> our school made us recite them over and over during lent
05:21:11 <Marvin--> how...nice
05:22:09 * shapr recites some catechism
05:25:28 <shapr> emomisy: neat nickname, what does it mean?
05:25:45 <shapr> @wn emomisy
05:25:47 <lambdabot> No match for "emomisy".
05:26:43 <emomisy> shapr: its made up... no intentional meaning
05:26:49 <shapr> oh, ok
05:27:01 <shapr> emomisy: are you learning Haskell?
05:27:54 <emomisy> shapr: yes, although in fits and starts
05:28:24 <shapr> do you have any questions?
05:29:16 <blackdog>  /whois emomisy
05:29:22 <shapr>   /noclue
05:29:29 <blackdog> ahem. sorry all.
05:29:30 <shapr> blackdog: :-P
05:29:37 <shapr> g'day blackdog, how's the new place?
05:29:54 <emomisy> not at the moment. mostly trying to get my head round differences from ML
05:30:33 <blackdog> maroubra? Still pretty sweet. worked out what I have to do to get the wireless going. It's a bit voodoo magic pixie dust but if i change the channel twice it seems to work.
05:30:51 <shapr> that does sound like voodoo
05:33:25 <blackdog> well, I sorta expected some weirdnesses. I'm running a windows driver with ndiswrapper on one machine and a patched-for-rfmon driver on the other.
05:38:20 <musasabi> How much does ghc do aliasing analysis. That is are cases like "foo ++ bar" optimized to avoid creating a copy of foo if it is possible?
05:38:44 <shapr> it's called deforestation
05:39:12 <shapr> basically means eliminating temporary intermediate structures where possible
05:39:37 <shapr> GHC does that, but I don't how much exactly
05:40:15 <musasabi> is there an easy way to see whether something is deforested or not?
05:43:59 <blackdog> you can eyeball the core code
05:44:06 <blackdog> -fext-core, IIRC.
05:44:19 <blackdog> or dumpcore or something. been a while.
06:06:15 <YveDeLarc> hi
06:11:30 <Jezral> Problem: http://sdu.projectjj.com/DM22/ - the Heap works and maintains it's sorted state. I have to use newtype or data in Set, since I need to define == and <= for the Set type, but then it claims (Set a) isn't the same as (Heap a) or (Int, Int, (Array Int a)).
06:17:57 <Marvin--> Jezral: well, you simply *cannot* declare class instances of type synonyms
06:18:15 <Marvin--> Jezral: you'll have to use newtype
06:18:53 <rob5> Jezral: you'll have to explicitly convert between (Set a) and (Heap a) if you use newtype
06:19:29 <rob5> e.g. empty = Set heapCreate
06:20:14 <rob5> or union (Set x) (Set y) = Set (heapMerge x y)
06:21:09 <Marvin--> hugs' restricted type synonyms are really nifty for this, but ghc still doesn't have them, right?
06:21:30 <Jezral> I am using Hugs
06:22:19 <Marvin--> Jezral: well, in any case you should preferrably be writing code that works with both hugs and ghc :)
06:30:44 <Jezral> Oooh...
06:30:45 <Jezral> Set> (makeSet [1,3,2]) == (makeSet [3,2,1])
06:30:45 <Jezral> True
06:30:54 <Jezral> Ta very muchly...
06:36:01 <Marvin--> Jezral: note that you could write  instance (Eq a,Ord a) => Eq (Set a) where  Set x == Set y = x `heapEquals` y  directly, rather than splitting it up
06:36:38 <Marvin--> and same for Ord, of course
06:36:46 <Jezral> Except I have to define eqSet as per the assignment...so can't do that.
06:36:54 <Marvin--> oh :)
06:37:07 <Marvin--> fair enough, then :-)
06:37:23 <Marvin--> pesky teachers, always getting in the way of pretty code :-P
06:38:18 <Marvin--> can't you generalize the type for heapFold a bit?
06:38:51 <Jezral> What's bad with that?
06:39:13 <Marvin--> what's bad with what?
06:39:19 <Jezral> heapFole
06:39:22 <Jezral> -e+d
06:39:28 <Marvin--> well, it looks to me that the type could be generalized
06:40:07 <Marvin--> like for the normal list folding functions
06:41:31 <Jezral> (a -> a -> a) -> a -> (Heap a) -> a looks pretty much like foldr to me...
06:41:32 <Marvin--> wow, wait a sec here... you do know that you can declare multiple variables in a let ... in ... expression, right?
06:41:53 <Jezral> Yes I know. ;
06:42:03 <Marvin--> Jezral: but both foldr and foldl use two type variables in the type, you just have one
06:42:44 <Marvin--> shouldn't a type like  (a -> b -> a) -> a -> Heap b -> a  be possible here?
06:44:19 <Jezral> Well, (Ord a, Ord b) => (a -> b -> a) -> a -> (Heap b) -> a compiles...so sure.
06:45:46 <Jezral> Ah, only needs Ord b, though...
06:46:02 <Marvin--> having more general types is generally (no pun intended) good :)
06:48:21 <Jezral> Pondering whether I should do advanced suicide by trying to make it work with data Heap a = HeapC {sz::Int, ln::Int, ar::(Array Int a)}...or just turn it in as it is now.
06:50:33 <Jezral> Might even work with newtype...oh well, perfectionism is good...but takes a while...
06:51:19 <Marvin--> :)
06:51:32 <Marvin--> it's often a good idea to use data or newtype rather than just a type synonym
06:51:57 <Jezral> Yeah. I'm converting Heap to newtype now.
06:52:22 <Marvin--> I think you should go with the record version
06:52:52 <Marvin--> if you say    data Heap a = Heap { heapSize :: Int, heapLength :: Int, ... }  you don't even have to define heapSize or heapLength separately
06:55:01 <Jezral> I don't actually use the heapSize or heapLength functions. They are just in case another module wants the size and length.
06:55:20 <Marvin--> you could write heapExchange something like this:   heapExchange h@(Heap{heapA = a}) b c = h{ heapA = a // [(b,a!c),(c,a!b)] }
06:55:56 <Marvin--> (iirc, my record-fu is a bit rusty)
06:59:24 <Marvin--> anyhoo, do whatever feels best
07:01:37 * Marvin-- puts on an Edguy CD and goes back to struggling with Gandalf and Eprover
07:15:03 <shapr> yow!
07:23:00 * Marvin-- laughs at the bonus track
07:27:50 <shapr> @type zipM
07:27:56 <shapr> @type foldM
07:29:30 <Marvin--> iirc, there is no zipM, but  zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
07:29:43 <Marvin--> and foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:29:55 <Marvin--> @type Control.Monad.foldM
07:30:01 * Marvin-- prods lambdabot
07:30:30 <Marvin--> shouldn't it be able to do that?
07:31:18 <shapr> yah, it should
07:31:36 <shapr> but no one's gotten around to fixing it
07:32:31 <shapr> if you've never seen TypeModule.hs, it's written with verve and style
07:32:36 <shapr> almost a shame to change it :-)
07:32:47 <shapr> er TypeModule.lhs
07:33:22 <Marvin--> all right, where's the darcs repo for lambdabot?
07:33:48 <shapr> um, same place I think
07:34:34 <Marvin--> well, I don't have it checked out
07:34:53 <shapr> http://www.scannedinavian.org/cgi-bin/darcs
07:35:06 <shapr> darcs get http://www.ScannedInAvian.org/repos/hlibs
07:36:05 <Marvin--> oh
07:36:32 <Marvin--> it's a pity that a subdirectory of a repo isn't a repo :(
07:36:36 <shapr> one more thing about the TypeModule, if it would read the pipe one more time, it wouldn't leave dead processes hanging around
07:36:40 <shapr> yah, that's true
07:36:45 <shapr> that's why I want to split hlibs 
07:36:58 <Marvin--> I would've preferred to just darcs get .../hlibs/lambdabot  there
07:37:02 <shapr> I agree
07:37:08 <shapr> actually, I wonder...
07:37:23 <shapr> anyways, I'm going to pull it apart when I get around to it
07:37:27 <shapr> all of it
07:39:59 <Marvin--> but isn't there a flag to hugs that lets you use the hierarchical modules? wouldn't that be enough?
07:40:09 <shapr> would it? I don't know
07:40:28 <shapr> if you tell me what that flag would be I can test it out pretty quickly
07:40:39 <Marvin--> apparently not
07:40:49 <shapr> betabot: @dynamic-unload type
07:40:50 <betabot> module unloaded
07:41:04 <Marvin--> actually, the flag seems to be gone and the hierarchical modules are used by default
07:41:18 <shapr> soo... why doesn't it work?
07:41:27 <Marvin--> but apparently hugs simply can't deal with qualified types in :t? :(
07:41:33 * shapr tries
07:42:21 <shapr> ok, how does that work?
07:42:51 <shapr> I have nov2003 hugs
07:42:54 <Marvin--> we could split on the last period in the argument though, and pass the module name as argument to hugs
07:42:56 <shapr> does that make a difference?
07:43:01 <shapr> like what?
07:43:06 <Marvin--> echo ":t foldM" | hugs Control.Monad   <- this works
07:43:15 <shapr> hm
07:43:21 <Marvin--> with nov2003 anyway
07:43:31 <shapr> so it does
07:43:50 <shapr> did you look at the source for TypeModule?
07:44:08 <shapr> I love that use of literate style
07:45:08 * Marvin-- thinks he's sorted out his sorting mess now
07:45:31 <shapr> do you want to fix TypeModule to deal with @type Control.Monad.foldM ?
07:45:42 <Marvin--> not really :)
07:45:45 <shapr> heh, ok
07:48:00 <Marvin--> I'm trying to work out the last technical problem in my report
07:48:59 <shapr> yay!
07:49:10 <shapr> did Koen like what you had to say?
07:49:20 <shapr> did you talk to him about using Generics in concert with QuickCheck?
07:50:36 * shapr considers switching to gnu emacs
07:50:50 <Marvin--> yes, he was generally happy with it, only this one technical detail and a bunch of easily fixed language details
07:51:14 <Marvin--> and no we didn't have time for that
07:51:55 <Marvin--> I pointed out this mistake he'd done with let expressions/where clauses in his manual translations and we discussed the implications of that for a bit
07:53:03 <shapr> I think you've got something cool with Generics + QC
07:53:33 <Marvin--> well, it's an unrelated topic :)
07:53:37 <Marvin--> I'd rather finish this first ;)
07:54:16 <shapr> well, you know my tendency to get distracted :-)
07:54:28 <shapr> anyways, I think your FOL encoding is cooler
07:55:40 <Marvin--> hella complicated to extend though
07:55:54 <Marvin--> The CoVer project are aiming for a FOL encoding of Core instead
07:55:59 <Marvin--> s/are/is/
07:56:24 <Marvin--> which I guess is fine if you trust the theorem prover and your encoding, because the proofs will be completely unreadable
08:09:28 <shapr> betabot: @leave #haskell
08:45:35 <musasabi> CoVer? (does not produce anything sensible in google)
08:47:26 <Marvin--> http://coverproject.org/
08:55:54 <musasabi> thanks
09:10:22 <shapr> phubuh: y0, EuroHaskell details are up, http://www.haskell.org/hawiki/EuroHaskell
09:45:11 <shapr> greetings and salutations hram 
09:47:54 <Jezral> Since I use Array to implement Heap, can I justify that most operations happen in O(lg n)? We were told that a Heap built using List could not satisfy better runtime than O(n)...
09:50:06 <shapr> I know that Arrays are O(1) to read
09:50:12 <shapr> not sure about the rest
09:50:41 <Jezral> And List is O(n) to read? Then it'd fit...
09:51:02 <shapr> I'm not sure about the complexity of list reading
09:51:14 <Smerdyakov> But Arrays must be O(awful) to write. :P
09:51:26 <Igloo> Arrays can be O(1) to O(n) depending on which you use I think
09:51:54 <Jezral> I only create new arrays when the current is out of space, and then I double it to make sure it has space for a while.
09:52:06 <Igloo> O(1) ones being mutable arrays in the IO or ST monads, but Diffarrays probably get close for a lot of uses
09:52:14 <shapr> hram: hOp is cool
09:52:27 <Marvin--> Jezral: but you *update* the arrays
09:52:38 <hram> shapr: probably should look more into it then :)
09:52:51 <Jezral> Fairly sure I read that updating was pretty fast somewhere...
09:52:53 <shapr> yes, hOp is very nifty
09:52:57 * cm shaprs shapr
09:53:04 * shapr cms cm
09:53:13 <cm> hiho :)
09:53:25 <shapr> hram: I've booted the first version, and the recent version with interrupt handlers
09:53:52 <shapr> hram: last I heard Lunar^ is working on a keyboard driver, and then maybe a shell
09:54:13 <shapr> do you know the urls to sebc's page and Lunar^'s hOp development diary?
09:54:35 <hram> shapr: The step from keyboard driver to shell is quite a big one :)
09:54:46 <shapr> yes, that's true
09:55:11 <shapr> I'm looking forward to it
09:55:25 <shapr> I've been vaguely thinking about a network stack for hOp
09:56:33 <shapr> so far, I've only booted hOp on qemu and bochs
09:57:01 <shapr> I wonder if the floppy drive on this 486 still works...
09:58:26 <hram> shapr: too chicken to use it on your own machine? :)
09:58:54 <shapr> definitely, I wonder how hOp would deal with an SMP box...
10:00:08 <cm> hiho :)
10:00:14 <cm> sigh, irc is too hard for me
10:01:36 <shapr> ?
10:07:20 <shapr> konichiwa ikegami
10:10:13 <vegai> -san
10:10:23 <shapr> whoops, thanks
10:10:51 <vegai> I hope that didn't give an otakuish image of me ;P
10:11:50 <Marvin--> ota-what?
10:11:55 <shapr> geek
10:11:59 <shapr> sort of
10:12:26 <shapr> http://en.wikipedia.org/wiki/Otaku
10:13:21 <Jezral> Updating an array performs "primitive primUpdate :: [(Int,b)] -> Array a b -> Array a b"...
10:15:11 <Jezral> But the phrase primUpdate doesn't exist in any other file. Oh well...
10:18:40 <vegai> figures that wikipedia has a page about that
10:18:43 * vegai hides.
10:19:35 <musasabi> Is there a good way to add plugins to haskell applications? 
10:20:42 <vegai> fun how "teacher" and "doctor" is the same word in Japanese
10:20:43 <shapr> you can use the Runtime Loader
10:21:03 <vegai> I wonder if that's true
10:21:13 <shapr> http://www.dtek.chalmers.se/~d00ram/dynamic/
10:21:36 <shapr> there may even be someone here who can answer questions about that DynamicLoader
10:22:04 <shapr> musasabi: is that the sort of plugins you mean?
10:22:20 <shapr> @listcommands dummy
10:22:20 <lambdabot> Module dummy provides the following commands: ["dummy","wiki","learn","moo
10:22:20 <lambdabot> ,"det","shapr"]
10:23:21 <shapr> @dynamic-reload dummy
10:23:21 <lambdabot> module reloaded
10:23:24 <shapr> @listcommands dummy
10:23:24 <lambdabot> Module dummy provides the following commands: ["dummy","wiki","learn","moo
10:23:24 <lambdabot> ,"det","shapr"]
10:23:28 <shapr> whoops
10:23:45 <shapr> @dynamic-reload dummy
10:23:46 <lambdabot> module reloaded
10:23:49 <shapr> @listcommands dummy
10:23:49 <lambdabot> Module dummy provides the following commands: ["dummy","wiki","learn","moo
10:23:49 <lambdabot> ,"det","shapr","musasabi"]
10:26:22 <musasabi> the dynamic loader looks very low level.
10:26:29 <musasabi> does it work with stuff like type classes?
10:27:14 <shapr> I think so
10:27:54 <musasabi> I would like to have plugins to return objects of types unknown to the main program but which are instances of a known typeclass, and handle them correctly inside the main program.
10:28:34 <shapr> I know that Martin Sjögren and Hampus Ram have both written some reports that talk at least partially about this particular sort of dynamic loder
10:28:40 <hram> musasabi: it will probably not work... it's one of the things I havn't done...
10:28:40 <Marvin--> that's what lambdabot does, doesn't it?
10:28:46 <shapr> and I that André Pang wrote some stuff about it too.
10:29:11 <musasabi> well without that the plugins provide very little extra value. 
10:29:11 <shapr> yah, lambdabot uses ozone's loader
10:29:41 <shapr> I keep meaning to switch to hram's loader, since that would cut out some of the complexity in BotConfig.hs
10:29:58 <shapr> hram: hey, the link to your report is broken
10:30:15 <hram> shapr: but they all have the same basic stuff... if one can do it, all can... (shapr: try adding a module with a z in its name with lambdabot)
10:30:30 <shapr> oh, I can guess where that's going
10:30:39 <shapr> GHCzBase
10:32:00 <shapr> I think a DynamicLoader that runs in the compile-time loop of Template Haskell would get around that
10:32:25 <shapr> from what I've heard, it would be slow, but I think it would give you everything that Haskell has in the way of type-safety
10:33:37 <hram> shapr: I do not know what you're talking about really...? How can you use TH in you own program?
10:34:01 <hram> without incorporating the whole ghc that is...
10:34:16 <musasabi> of course one could use something like type Outside a b = FiniteMap String (a -> b)
10:34:31 <shapr> hram: right, it would require the whole of GHC
10:34:40 <musasabi> and then resolve function calls through that... but it is ugly
10:35:09 <shapr> would be worth writing a prototype
10:35:35 <hram> musasabi: The only way to know if it works is to try without any ugly hack first... (and my dynamic loader is currently the best I've seen :))
10:36:30 <musasabi> hram: ok, I'll think about that. got any paper on it?
10:37:12 <hram> musasabi: well, there's a small report but you really need no more than the haddock documentation...
10:38:23 <stepcut> morning shapr!
10:38:24 <shapr> as a silly example of IO happening at Template Haskell compile-time, run ghc --make on this: http://shapr.homelinux.net/~shae/ProtoTemplateHaskell.hs
10:38:28 <shapr> goood morning stepcut!
10:39:06 * stepcut uses IO in template haskell to update the output of --version
10:39:29 <shapr> do you output the value of $Id ?
10:39:40 <stepcut> no, I don't use cvs
10:39:43 <hram> shapr: Yes? Was that something that has to do with dynamic loading?
10:40:22 <stepcut> shapr: instead of do a 'tla log -fr | head -n1' or something
10:40:27 <shapr> yes, can't you load source at the same time?
10:41:17 <hram> shapr: Well. probably, but to what good? Anything happening at compiletime is quite uninterresting.
10:41:44 <stepcut> shapr: did you get a chance to peek at that Arrow stuff I sent you?
10:42:00 <shapr> hram: the whole program can happen at compile-time
10:43:22 <shapr> stepcut: not enough to make any sense of it yet
10:44:14 <shapr> also, the attachments are inline, so I'm not sure about filenames
10:44:31 <shapr> can I assume that the module names will be the same?
10:44:34 <stepcut> shapr: well, I don't think *I* am sure about everything
10:44:43 * shapr grins
10:44:43 <stepcut> shapr: yeah
10:44:47 <shapr> ok
10:45:10 <hram> shapr: Ah, ok. Quite a nasty thing that...
10:45:39 <shapr> but, entirely type-safe
10:45:44 <stepcut> shapr: odd, the filename should be present: Content-Disposition: inline; filename="Unix.hs"][quoted-printable]]
10:45:56 <shapr> ah, maybe gnus is deceiving me
10:46:33 <hram> shapr: A better (simpler) way to make stuff typesafe would be to make symbols include types...
10:47:04 <shapr> even so, you can't guarantee that matching types means matching implementations
10:48:08 <shapr> there are several flavors of 'equality' when you start talking about dynamic loading
10:48:33 <shapr> for example, sort can have the same type signature, the same effect, but be implemented as bubblesort or quicksort
10:49:04 <hram> shapr: I'm not quite sure I understand you there... Yes, do can still do wrong. But how do you compile entire files from within ghc with TH?
10:49:35 <hram> shapr: Yes, but how can you guarantee that with TH?
10:50:49 <shapr> as for compiling entire files from within GHC, I would guess you figure out how to compile a string, and generalize, I haven't done it myself
10:51:12 <shapr> but now is a good time to figure it out :-)
10:52:19 <shapr> Template Haskell can't give implementation guarantees, but if you have all the source handy, you can figure it out for yourself.
10:52:54 <shapr> actually, you're right, having symbols include types would be really handy
10:52:59 <shapr> it would be enough
10:53:15 <shapr> I think Simon Foster said that you could effectively get the same thing if you read the .hi files
10:54:05 * Igloo wonders how best to decide if a curses binding should generate w/mv/wmv variants of functions
10:54:05 <shapr> hram: what do you think? an .so plus a .hi file?
10:55:16 <hram> shapr: It would be safe but cumbersome both to distribute and read the .hi-files.
10:55:40 <hram> shapr: esp. since the hi-files change every now and then...
10:55:51 <shapr> oh, good point
10:56:33 <hram> shapr: but really nothing in my library hinders you from adding such a layer (and I've thought about it myself).
10:57:51 <hram> shapr: and in such a scheme TH would come in handy. (to generate the .hi-inspecting code and a appropriate call to loadFunction)
11:00:18 <shapr> I wonder if I can write up a simple demo of a pure-TH runtime loader
11:00:53 <hram> shapr: one that runs "inside" ghc?
11:01:05 <Marvin--> as if haskell binaries aren't large enough already :)
11:01:21 * shapr grins
11:01:22 <shapr> hram: yup
11:01:37 <hram> it would however show if ghc has any space-leaks :)
11:01:57 * shapr grins
11:02:09 <shapr> sounds like a fun toy
11:02:31 <shapr> I wonder if the Simons would consider it abusive :-)
11:02:44 <hram> I do :)
11:04:48 <shapr> well if it works...
11:06:49 <hram> just hack away and see. it would be fun if nothing else.
11:06:58 <shapr> yes, I agree
11:11:46 <shapr> greetz Udo
11:12:37 <ustenzel> hello.
11:20:57 <LittleDan> Are there any programming languages like haskell but 
11:21:08 <LittleDan> with referential opacity
11:21:15 <Smerdyakov> Yes. ML
11:21:23 <LittleDan> but that doesn't have typeclasses
11:21:28 <LittleDan> or any other form of generic functions
11:21:30 <Smerdyakov> Yes
11:21:35 <Smerdyakov> Whoa, hold on
11:21:38 <LittleDan> it does?
11:21:40 <Smerdyakov> I can't agree on that second point.
11:21:40 <Riastradh> Why wouldn't you want typeclasses??
11:21:53 <LittleDan> I do want typeclasses
11:21:59 <Smerdyakov> LittleDan, do you know what functors are in ML?
11:22:20 <LittleDan> Maybe I'm using the wrong terminology (by generic functions). I mean dispatching on types
11:22:25 <LittleDan> what are functors?
11:22:54 <stepcut> mmm functors
11:23:05 <Smerdyakov> LittleDan, read and see: http://www-2.cs.cmu.edu/~rwh/smlbook/
11:23:32 <Smerdyakov> You're right that dispatching on types has no inherent support in ML's.
11:23:48 <Smerdyakov> Not at runtime, I mean.
11:24:05 <Smerdyakov> At compile time, you can use very small amounts of code where you explicitly specify the types.
11:24:35 <LittleDan> and there's of course OCaml classes, but that uses a whole seperate syntax
11:24:55 <stepcut> A functor is a structure-preserving map from one category to another -- it maps objects to objects and morphisms to morphisms.
11:25:32 <stepcut> In the case where objects are sets and morphisms are functions, you can think of functor F as a polymorphic operator on functions.
11:25:51 <stepcut> does that clear things up ;)
11:25:53 <Smerdyakov> I'm not sure if this definition has a meaningful mapping onto ML functors, but you sure don't need to understand what he just said to use ML functors. :P
11:30:04 <stepcut> LittleDan: in the above 'example', F would have the type signature: F : (a -> b) -> (F a -> F b)
11:30:19 <stepcut> a practical example would be something like:
11:30:41 <stepcut> fmap ((+) 1) (Just 1) ---> Just 2
11:30:53 <stepcut> fmap ((+) 1) (Nothing) ---> Nothing
11:31:11 <stepcut> fmap might be defined as: 
11:31:18 <stepcut> fmap _ Nothing = Nothing
11:31:27 <stepcut> fmap f (Just a) = Just (f a)
11:33:33 <Riastradh> stepcut, LittleDan left.
11:33:55 <LittleDan> so functors are like List.length and Array.length?
11:34:05 <Smerdyakov> No
11:34:27 <LittleDan> oh
11:35:13 <musasabi> why does haskell use put{Str,Char,...} instead of something like put :: (Show a) => a -> IO ()
11:35:54 <LittleDan> What is there besides put{Str,Char}?
11:36:05 <LittleDan> it seems like you need those to be seperate
11:36:12 <Cale> musasabi: are you sure you aren't looking for "print"?
11:36:16 <stepcut> musasabi: there is a 'print' function that does what you want I think
11:36:16 <hram> musasabi: because you do not want to show a String!  (you want print)
11:36:20 <LittleDan> print makes a newline
11:36:27 <LittleDan> you don't always want that
11:36:38 <Cale> and puts quotes around the string
11:36:42 <stepcut> yeah
11:36:45 <LittleDan> but you can always use (putStr . show)
11:36:56 <musasabi> yes, but why do put{*} functions exist (exported from the prelude)
11:37:32 <musasabi> they seem like a step backwards to languages without polymorphism
11:37:40 <LittleDan> You obviously need putStr, and putCh is good for low-level I/O
11:37:49 <LittleDan> putCh is builtin, IIRC
11:37:56 <Cale> putChar
11:38:01 <LittleDan> oops
11:38:13 <Cale> anyway, they're actually different.
11:38:19 <LittleDan> still getting away from C names
11:38:57 <Cale> (putStrLn . show) is similar to print, whereas putStrLn alone is different.
11:39:11 <LittleDan> is there a difference?
11:39:15 <Cale> Try both of those on strings and you'll see.
11:39:32 <LittleDan> quotes with print?
11:39:37 <Cale> yes
11:40:30 <Cale> print is the "polymorphic" version of putStrLn, however, it's not the same with respect to strings, because it ends up quoting them.
11:41:05 <LittleDan> musasabi, if you want a convienence function, just put somewhere in your program
11:41:05 <LittleDan> write = (putStrLn . show)
11:41:14 <Cale> print      :: Show a => a -> IO ()
11:41:14 <Cale> print x    =  putStrLn (show x)
11:41:25 <Cale> from the prelude
11:41:30 <LittleDan> oh
11:41:35 <LittleDan> so show puts quotes too?
11:41:48 <Cale> show will quote strings
11:41:59 <musasabi> LittleDan: of course defining a convenience function is easy. I was just wondering why it was not done so by default.
11:42:26 <Cale> musasabi: print is in the prelude and does what you want. It's just different from putStrLn
11:43:44 <LittleDan> no, it doesn't do what he wants
11:43:55 <LittleDan> you don't want quotes, do you?
11:44:10 <musasabi> putStr is fine for strings.
11:44:25 <musasabi> and one can special case chars.
11:46:22 <shapr> is there an easy way to just execute a string in Template Haskell?
11:50:39 <LittleDan> musasabi, try this:
11:50:39 <LittleDan> class (Show w) => Write w where
11:50:39 <LittleDan>   write :: w -> IO ()
11:50:39 <LittleDan>   writeLn :: w -> IO ()
11:50:39 <LittleDan>   writeLn self = write self >> putChar '\n'
11:50:41 <LittleDan> instance Write String where
11:50:43 <LittleDan>   write = putStr
11:50:47 <LittleDan> instance Write Char where
11:50:49 <LittleDan>   write = putChar
11:51:56 <LittleDan> (is it possible to modify existing classes like Show?)
11:52:00 <musasabi> yep, (and add a default method body for write with write self = write (show self) )
11:52:17 <Cale> or just print self
11:52:38 <LittleDan> no, write doesn't put a newline
11:52:44 <LittleDan> only writeLn
11:52:46 <Cale> ah
11:52:49 <Cale> yeah
11:56:57 <LittleDan> musasabi, how do default method bodies work?
12:00:22 <Cale> LittleDan: they just save you from writing an implementation when you make things an instance of the class.
12:01:41 <musasabi> LittleDan: just add the method body to the class definition
12:01:48 <Cale> For an example, see the RealFrac class.
12:02:37 <Cale> All that's required for an instance of RealFrac is an implementation of properFraction.
12:03:04 <Cale> truncate, round, ceiling, and floor will come for free after that, though you can replace them if you want.
12:03:25 <shapr> Igloo: is there some way to execute a string in TH, or do I need to parse it into the various TH types first?
12:03:52 <Igloo> The only way to execute is to splice in
12:04:21 <shapr> ok
12:08:26 <shapr> I rather like the quote from page 10 of the original Template Haskell paper "Naturally, this power is open to abuse. Ha ha ha."
12:10:34 <shapr> Igloo: the curses binding is really spiffy
12:10:53 <Igloo> Which one?
12:11:08 * shapr is rereading "A Report From the Field"
12:11:09 <Igloo> Yeah, pity they removed it later  :-(
12:11:12 <Igloo> Ah, right
12:16:45 <shapr> so, to splice in a string of code, I'd have to parse it into the right pieces
12:17:08 <shapr> wait, didn't seafood or ozone talk about wrapping an entire module in a splice?
12:20:19 <earthy> ozone, probably
12:20:35 <shapr> they were saying something about that at HW
12:23:30 <hram> shapr: lots of things are talked about that cannot be done yet... TH has lots of restrictions.
12:35:09 <musasabi> Is there any work combining type classes and their invariants?
12:35:15 <musasabi> something like eiffel...
12:52:30 <sysfault> howdy guys.
13:00:08 <Igloo> Bah, forgot I'd have to contend with CPP macros
13:02:06 <Marvin--> macros are evil :(
13:05:04 <np_hard> you down with CPP?
13:05:08 <np_hard> yeah you know me
13:11:56 <eixei> heya guys
13:12:01 <eixei> remember me? :-)
13:12:31 <eixei> oh, sorry...
13:13:02 * eixei really didn't want to disturb #haskell's rest
13:13:08 * Riastradh snores.
13:13:13 * eixei will just be quiet, ok?
13:13:17 <eixei> :-)
13:18:14 <Cale> heh
13:18:55 * eixei whispers: pssst Cale, you'll wake up Riastradh
13:19:03 * Riastradh snorts.
13:19:26 * Cale whispers "I'm not sure if I was around last time you were here. Did you have any questions about Haskell?"
13:20:31 * eixei whispers back: "Not really, I just thought it would be nice to come here again, specially since you guys helped me quite a bit with Haskell :-)"
13:20:46 * eixei wonders how whispering ".-)" sounds like :-/
13:22:15 <Cale> :)
13:22:37 <Smerdyakov> You hold your hand over your mouth while you smile.
13:23:35 <eixei> good idea
13:30:04 <np_hard> welcome to HaskellMUD
13:30:48 * Cale sits down at a nearby table.
13:30:59 * Cale begins to eat some cereal.
13:31:46 <eixei> MUD? Yay!
13:31:56 * Cale says "A Haskell based MUD would be cool."
13:32:09 <Marvin--> cool, anyone up for some Orc hunting?
13:32:14 * eixei is an elven wizard , special spell: Recursion!
13:32:39 <eixei> Orc-hunting? How can you? Those poor orcs...
13:33:01 <eixei> (people have been known to hate me in RPG'S due to my *weird* characters)
13:33:33 * vegai is an Orc. Somebody got a problem with that?
13:33:38 <Marvin--> heh, I've played my share of non-cooperative characters too
13:33:54 * Marvin-- rages and attacks vegai!
13:34:05 <Marvin--> filthy orcses
13:34:30 * vegai dies without much elegance.
13:34:31 <eixei> No!
13:34:44 <eixei> I won't allow you to keep murdering those innocent souls!
13:34:58 * eixei steps towards Marvin
13:34:58 <Marvin--> innocent, my ass
13:35:00 <vegai> (for the record, it wasn't so innocent)
13:35:32 * eixei whispers to Marvin: "unless you give me 200 gold coins and promise not to tell anyone about this whole dirty business..."
13:35:56 * vegai comes back as a security guard dressed in a red uniform.
13:36:35 * vegai twiggles with his phaser settings.
13:36:43 <Marvin--> uh-oh
13:36:47 <vegai> *bbrrzzztt*
13:36:58 <vegai> (another one bites the dust)
13:36:59 * Marvin-- falls down
13:37:06 <eixei> Serves you right Marvin!
13:37:23 * Marvin-- pants "not...again..."
13:37:57 * eixei goes towards Marvins' corpse and tries to find his wallet while mumbling something about "checking... alife.. just making sure..."
13:38:21 * vegai hops back as a bunny.
13:39:40 <eixei> hmm... before this gets boring...
13:40:27 * eixei mumbles "sigwa elerion theorin..", an ancient reviving spell, and casts it upon Marvin-- while making complex movements with his wand
13:40:50 <Marvin--> brrraaaaiiiiinssss....
13:41:36 * Marvin-- happily starts chewing on eixei's head
13:42:08 <eixei> How dare you!
13:42:15 * eixei slaps Marvin around
13:42:22 * vegai sees a monad in the distance.
13:42:28 <vegai> what the hell is that?!
13:42:50 * Marvin-- tries to chew the head off the monad
13:46:28 * Cale flings a comonad at it.
13:48:15 <Marvin--> LOL, channel 5's incompetence is incredible... the current poll on their homepage is "Which air time do you think is best for our movies?" and the poll options are ... *drumroll*
13:48:19 <Marvin--> "Yes" and "No"
13:48:44 <Marvin--> so far, about 4000 people have voted :-)
13:48:46 <eixei> What are the poll results?!? :-)
13:49:14 <Marvin--> It's close, 52.5% for Yes, and 47.5% for No, so far
13:49:39 <phubuh> I can't find that poll. :(
13:50:06 <Marvin--> http://www.kanal5.se/templates/page.aspx?id=2048 and scroll down
13:50:52 <eixei> rotfl
13:50:56 <phubuh> Ah, thanks.  Haha.
13:52:01 <eixei> http://www.kernelconcepts.de/products/fun/stofftiere.shtml
13:52:03 <eixei> Yay!
13:52:09 <eixei> Finally found something nice...
13:52:15 <eixei> Guess what I'm ordering :-)
13:52:29 <Marvin--> aww :)
13:56:14 <mattam> anyone could help me define union in the set category ?
13:57:21 <Cale> mattam: hm?
13:57:57 <mattam> P(A,B,C) = C = A U B
13:58:07 <mattam> P(A,B,C) == C = A U B even
13:59:14 <mattam> using only morphisms, identity etc... Apart from saying there exist injection functions f : A -> C and g : B -> C i can't say that any element of C must be in either A or B.
14:00:26 <Cale> well, disjoint unions are easy, they're just coproducts
14:00:41 <Cale> however, without that disjointness... hmm...
14:02:47 <Cale> ah, hmm... perhaps a suitably chosen pushout to glue together things that are in both A and B in the disjoint union.
14:04:18 <Cale> can you get a hold of the intersection?
14:05:35 <mattam> maybe
14:05:55 <Cale> Saying that I -> A -> C, I -> B -> C is a pushout square would, I think, do it, where I is the desired intersection of A and B.
14:06:41 <Cale> and I suppose that the maps from A to C and B to C are the inclusions.
14:06:58 <Cale> and also from I into A and B.
14:07:50 <mattam> what's a pushout square ? :)
14:08:55 <Cale> http://planetmath.org/encyclopedia/CategoricalPullback.html
14:09:39 <Cale> perhaps I can find a more readable entry
14:10:37 <Cale> Or I can draw one :)
14:12:12 <mattam> i see, but i suppose one could define those with more ease. The exercise is given before defining functors or products.
14:12:40 <mattam> those properties i mean
14:13:09 <Cale> http://vx.hn.org/autoshare/pushout.png
14:14:40 <Cale> The square involving A,B,C,and D is called a pushout square, if for any choice of E, u' and v' which makes the outer square (A,B,C,E) commute, there is a unique map theta from D to E such that the upper and lower triangles will commute as well.
14:15:56 <Cale> If you cover up A, beta and gamma, then the remaining bit is called a coproduct. (i.e. D is the coproduct of B and C)
14:16:52 <Cale> the effect of A, beta, and gamma is to glue some bits of D together in some manner. i.e. identifying the things which came from A along the top and bottom path.
14:18:21 <Cale> in the category of sets, we'd just have that if a was some element of A, then u(b(a)) = v(g(a)) by commutativity.
14:18:31 <Cale> (where b and g there are beta and gamma)
14:18:44 <Cale> (hope you can see the diagram :)
14:18:56 <mattam> i see
14:21:13 <mattam> so once you have found D, you simply have to state a conforming theta to create new coproducts ? (or do theta has to be reversible) ?
14:22:30 <Cale> in some sense, you're finding the "first" thing that works.
14:23:19 <mattam> back to our example, with I A B C being a pushout square, what would be alpha and beta ?
14:24:07 <Cale> the inclusion maps
14:25:15 <mattam> i'm not sure i understand...
14:26:53 <bourbaki> hiho
14:26:55 <Cale> there's a map which takes the elements of the intersection of A and B into A and into B which is a restriction of the identity mapping.
14:27:06 <Cale> there are maps, rather
14:27:34 <Cale> that's what I mean by inclusion
14:28:01 <mattam> you mean beta : I -> A ~= A / I ?
14:28:24 <Cale> in general, if S is a subset of T, then there is a map i: S -> T, by simply mapping the elements of S to themselves in T.
14:28:37 <mattam> yes
14:28:53 <Cale> i.e. {a,b,c} -> {a,b,c,d,e}, by mapping a to a, b to b and c to c.
14:29:47 <Cale> since I is a subset of A and B, this type of mapping exists.
14:30:12 <mattam> sure
14:31:24 <Cale> so use that sort of thing for the mappings marked beta, gamma, u and v.
14:43:21 <eixei> I believe in freedom, I blieve in dreams, I believe in heroes, this is not enough (We are strong enough)
14:43:23 <eixei> ...
15:45:29 <wglwill> hi
16:07:24 <eixei> heya
16:07:30 <eixei> Ok, I got a question
16:07:39 <eixei> I hope there are enough of you to answer it...
16:08:17 <eixei> As you all probably know the TV/Doctors/... are always telling everybody to drink 3 liters a day (while coffee counting as negative)
16:08:24 <eixei> does ANYBODY of you drink that much?
16:08:31 <eixei> I have trouble drinking 2 liters...
16:08:54 <wglwill> no, i don't think anyone except maybe atheletes drink that much
16:08:55 <eixei> HEEEEEEEEEEEEEEEELLLLLLLLLLOOOOOOOOOOOOOOOO!
16:08:59 <eixei> oh, ok :-)
16:09:03 <eixei> Thanks wglwill
16:09:22 <wglwill> that's just like drinking water non stop all day
16:09:42 <eixei> yeah, lol
16:09:52 <eixei> Why do they recommend drinking that much though?
16:10:32 <wglwill> it probably increases the efficiency of your body chemistry
16:10:37 <wglwill> but that's just a guess
16:10:41 <wglwill> keeps things moving around easily
16:10:53 <wglwill> you cells use water to move things between cell membranes
16:11:43 <wglwill> your
16:11:45 <wglwill> *
16:11:49 <eixei> I see
16:11:59 <eixei> Thanks a lot wglwill!
16:12:04 <wglwill> but i'm not totally sure, i'm having trouble remembering this biology stuff
16:14:33 <wglwill> arg, i can't get these hopengl sample programs to compile
16:15:57 <stepcut> wglwill: are you aware there are two incompatible versions of hopengl?
16:16:46 <wglwill> yes someone told me that the old version i was trying to install was broken so i got that fixed
16:16:58 <wglwill> but are the programs that come with 1.05 obsolete as well?
16:17:15 <wglwill> those are the ones i'm trying to compile
16:17:35 <stepcut> yes
16:17:40 <wglwill> blast
16:17:49 <wglwill> so where are the updated demo programs?
16:17:56 <wglwill> seems like everything on the hopengl site is outdated
16:18:01 <stepcut> yep
16:18:13 <stepcut> the demos have been updated in the ghc source tree
16:18:19 <stepcut> what OS are you running?
16:18:27 <wglwill> gentoo linux
16:18:49 <wglwill> ah, so i can just grab them from the cvs tree?
16:18:49 <stepcut> so you have the source to ghc sitting around somewhere?
16:19:04 <wglwill> or better yet, do you mean they are in the source distribution?
16:19:47 <Cale> yeah, they're in the source distribution
16:19:54 <wglwill> :) great
16:19:55 <stepcut> fptools/libraries/GLUT/examples/RedBook
16:21:18 <wglwill> someone defenitely needs to take that hopengl site down or something, it probably leading a number of people on wild goose chases trying to get hopengl working
16:21:26 <wglwill> i just assumed that was the most up to date =/
16:22:38 <stepcut> agreed
16:46:00 <amb> night!
17:13:52 <wglwill> i seem to be having just the worst luck with this hopengl, i finally can compile hopengl programs sucessfully but now I can't use them, whenever i move a window for a hopengl program it gives me a really wierd graphical error that seems to spread to every window on my system
17:17:49 * Cale is away: homework
17:22:13 <stepcut> wglwill: do other OpenGL apps work ok? (like glxgears)
17:24:25 <wglwill> ya, i just tried another one and it works fine
17:24:30 <wglwill> seems to be isolated to hopengl apps
17:24:37 <stepcut> hrm
17:24:39 <wglwill> it's the wierdest opengl bug i've ever seen
17:24:43 <stepcut> dunno
17:24:47 <wglwill> destroys the whole system, have to restart the xserver
17:53:16 <stepcut> php-mode for emacs sucks big time 
17:55:28 <Smerdyakov> What about php-mode for babies?
17:59:22 <Riastradh> stepcut, s/-mode for emacs//1
18:01:00 <stepcut> that too
18:01:53 <Pseudonym> I have a two-year-old who cannot, at this time, comprehend even the lexical language of PHP.
18:02:19 <Smerdyakov> Pseudonym, will you teach her programming soon?
18:02:49 <Pseudonym> She does know how to suspend a process in Unix, so it's only a matter of time.
18:03:00 <Pseudonym> I think it helps if you  read first, though.
18:03:26 <Riastradh> How does she suspend the process?  Hitting the computer and keyboard repeatedly until something happens?  (or stops happening, rather)
18:03:33 <Smerdyakov> 4 years old seems to be about the "sweet spot" to start learning.
18:03:51 <Pseudonym> Control-Z can be operated by one hand.
18:04:16 <Pseudonym> And it's the corner of the keyboard most accessible when you're at the right desk.
18:04:53 <Pseudonym> The other one, unfortunately, has recently discovered the reset button.
21:18:44 <shapr> good morning #haskell!
21:24:20 <liiwi> good morning
21:25:56 <np_hard> http://linux.ucla.edu/~leiz/pictures/wtf/i_know_chmod.jpg
21:31:26 * liiwi snickers at how many web people can be defeated with chattr +i
21:38:54 <shapr> hey tmoertel 
21:38:57 <shapr> what's going on?
21:39:01 <tmoertel> hi, shapr!
21:39:16 <tmoertel> not much, just checking in to see what's up in the Haskell world
21:39:48 <shapr> I'm still having fun with HaskellDB
21:40:00 <shapr> I'm trying to think of a more complicated application
21:40:14 <tmoertel> anybody packaged it yet for RPM ?
21:40:29 <shapr> I'd like to try something that has a lot of tables, and requires a lot of complex selections among those tables
21:40:34 <shapr> I think so
21:41:54 <shapr> oh, the rpm packager is on vacation
21:41:55 <tmoertel> hmm... no rpms on the sf site; no .spec file in the source tarball...
21:42:11 <tmoertel> ah, so there's an official packager?
21:42:23 <shapr> one of the HaskellDB team, I think forester
21:42:39 <tmoertel> great. that saves me the trouble of packaging it up.  ;-)
21:43:10 <shapr> so, been writing any fun code lately?
21:43:27 <sysfault> how do you guys feel about scheme?
21:43:37 <tmoertel> well, I wrote that popen just before you showed me that the old version was still in GHC.
21:43:47 * stepcut is writing a scheme->swf compiler
21:43:52 <tmoertel> http://community.moertel.com/ss/space/Tom%27s+Haskell+code/POpen.hs
21:44:30 <shapr> have you seen shell-haskell?
21:44:42 <tmoertel> no
21:44:55 <shapr> http://www.electronconsulting.com/shell-haskell/
21:45:02 <shapr> seems related
21:45:02 * tmoertel looks
21:45:35 * tmoertel dl's source tarball
21:46:04 <stepcut> seems like the 'launch' function should also return a pid
21:46:46 * stepcut goes to bed
21:47:04 <shapr> g'night stepcut 
21:47:10 <tmoertel> 'night
21:48:29 <tmoertel> i don't see why there's a shell_stub.c in shell-haskell
21:48:41 <tmoertel> i'm pretty sure you can do all that in stock ghc
21:50:47 <shapr> mmm, coffee
21:52:54 <shapr> it does look similar to your popen
21:53:44 <tmoertel> with shell-haskell you get the raw file handles, so you can read and write interactively, if you're careful
21:56:56 <liiwi> heh, currency fluctuations have made ikea's founder richer than bill gates
21:58:12 <tmoertel> so sayeth the Register: http://www.theregister.co.uk/content/7/36782.html
21:59:00 <liiwi> http://www.mtv3.fi/uutiset/talous/txt.shtml?212363
22:00:20 <liiwi> heh, ... "mediocre mass produced gear that requires a lot of assembly" ..
22:00:37 <tmoertel> i actually like Ikea furniture
22:06:57 <Pseudonym> @arr
22:06:57 <lambdabot> Prelude.(!!): index too large
22:07:17 <Pseudonym> Arr, me hearties!  Ye index be too large for ye list!
22:08:00 <Pseudonym> It'd be kinda fun if all of Haskell's errors were in Pirate-speak.
22:08:19 <Pseudonym> $yN+aX 3rR0R!!!!1!
22:08:29 <tmoertel> import HighSeas
22:08:51 <Pseudonym> import Warez
23:18:20 <shapr> Pseudonym: Helium has error templates :-)
