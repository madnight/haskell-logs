00:00:06 <bring> who else has access to that?
00:00:07 <skew> shapr, where is the source to curryspondence?
00:00:14 <shapr> http://www.scannedinavian.org/~shae/curryspondence0.9.tar.gz
00:00:35 <andersca> bring: all of Ã„G
00:00:42 <andersca> but they are trustworthy(tm)
00:00:57 <bring> is there lots of booze in the same room?
00:01:00 <andersca> and you need a keycard to even get in to that area
00:01:01 <andersca> bring: nope
00:01:08 <shapr> hehe, why that question?
00:01:09 <bring> so that people will steal that instead 
00:01:10 <bring> ok
00:01:12 <andersca> haha :)
00:01:14 * shapr laughs
00:01:38 <shapr> that's a very funny idea
00:01:39 <bring> the keycard thing has stopped some of the other thefts
00:01:39 <andersca> bring: I think our area in elkraftshuset is the most secure :)
00:01:52 <bring> s/has/hasn't/
00:01:58 * bring just woke up
00:02:01 <shapr> put enough booze so that one person can barely carry it next to your valuables
00:02:21 <shapr> after a break-in, follow your nose to the passed-out criminal.
00:02:41 <bring> hmm, actually that didn't work when d6 was robbed a month or so ago
00:02:47 <shapr> "I'll just drink enough that it's easier to carry"
00:02:50 <shapr> what's d6?
00:02:54 <bring> I think the just took the money
00:03:44 <bring> the party committe of the Computer Science and Engineering program
00:03:53 <bring> guess you could call them that
00:04:11 <shapr> ok
00:04:12 <bring> "Datateknologsektionens sexmästeri"
00:04:19 <andersca> my apartment is a 10 minute walk from chalmers, could just put it there
00:04:26 <andersca> the sex masters
00:04:41 <bring> why is it called that anyway?
00:04:51 <shapr> I was wondering that myself.
00:04:57 <bring> andersca: you live at Chalmers Studenthem?
00:05:00 <andersca> yes
00:05:00 <shapr> let's see, programmers at a college. maybe it's sarcastic?
00:05:08 <andersca> bring: a "sexa" means a party
00:05:13 <bring> true
00:05:14 <andersca> bring: svensexa tex
00:05:24 <bring> didn't think of that
00:06:16 <bring> hey, why do some things I say not show up in the channel?
00:06:37 <shapr> er, like what?
00:07:03 <shapr> http://tunes.org/~coreyr/read.php?chan=haskell&date=04.04.07
00:07:48 <bring> I just said I was going to have a look in an ethymological dictionary, but it didn't show up in the channel
00:08:03 <shapr> I dunno
00:08:19 <shapr> check your server buffer, maybe there was an error?
00:08:39 <bring> oh, my bad
00:08:41 <bring> thanks
00:08:57 <bring> I had typed /be instead of /me
00:11:00 <bring> anyway, a "sexa" is apparantely a light meal or snack consumed around six in the evening, or, in student circles, in the wee hours
00:11:14 <andersca> oh, neat
00:11:14 <shapr> like a fika?
00:11:24 <bring> first example from 1827
00:11:56 <bring> more of a meal that a fika usually is, and later in the day I'd say
00:14:04 <bring> hmm, it also says that nowadays, it's almost exclusively used of a light meal associated with a friendly or festive gathering
00:14:05 <skew> shapr, it would be nicer if that tarball had the files in a directory
00:26:38 <shapr> skew: good point
00:28:43 <shapr> hej chucky 
00:34:46 <chucky> hej shapr
00:35:03 <shapr> skew: alternatively, I could just stick up my darcs repo
00:46:18 <skew> shapr, have you done any paid work in Haskell yet?
00:46:24 <shapr> I have
00:46:37 <shapr> ms.doc to a custom XML flavor via OOo
00:46:38 <bring> all hail shapr
00:46:39 <shapr> I used HXT
00:46:55 <shapr> and I'm using bring's XmlRpc library with Zope
00:47:18 <bring> all hail me
00:47:25 <shapr> all hail bring!
00:47:34 <skew> hail
00:48:16 <andersca> wow, a real hail storm
00:48:17 <andersca> *drumroll*
00:48:41 <bring> andersca: so, you live in Gothenburg, eh?
00:49:01 <shapr> argh, darcs-createrepo barfs with parens
00:49:47 <bring> I think that's the way to go with getting haskell used in industry, just get work done with it, a lot faster than with other languages
00:50:28 <shapr> yup, I agree
00:50:28 <bring> as in "Beating the Averages", http://www.paulgraham.com/avg.html
00:50:47 <andersca> good ol' paul graham
00:51:22 <liiwi> morning
00:51:37 <bring> good morning
00:51:38 <shapr> I was sposed to write a converter from the custom xml into OOo xml with xslt first, took me a month and some non-standard extensions to get anything decent done
00:52:11 <shapr> when converting the other way, they didn't care about getting code they could reuse after, they just wanted it done, so I wrote the HXT converter in three days
00:53:54 <shapr> bah, I'll fix darcs-createrepo later, but in the meantime http://shapr.homelinux.net/repos/curryspondence if you want to check out my curryspondence sources
00:54:13 <skew> Oh, I already looked it over
00:54:39 <skew> a few lost files are easy to clean up
00:55:07 <bring> "module Articles.Tokenfatgirls"?
00:56:39 <shapr> um
00:56:53 <shapr> where did that sneak in?
00:57:20 <shapr> oh, I see
00:57:49 <shapr> well, Articles.hs wasn't supposed to get into the repo...
00:58:16 <shapr> actually, it isn't in the repo is it?
00:58:51 <shapr> oh, it's in the tgz
00:59:07 <shapr> bring: that's from the test/ dir in HaskellDB 0.7
00:59:15 <shapr> it's the DBInfo demo code
00:59:38 <bring> the tokenfatgirls thing?
01:00:05 <bring> hey, it is
01:00:27 <bring> hmm, that example is a little weird
01:00:53 <bring> chucky: tokenfatgirls, DinMamma, and who is Karin?
01:00:58 <andersca> haha
01:01:20 <Cale> *Main> isPrime 1497301433
01:01:20 <Cale> True
01:01:20 <Cale> (27.58 secs, -1701000396 bytes)
01:01:31 <Cale> heh
01:01:38 <shapr> interesting size
01:01:43 <andersca> yay
01:01:49 <andersca> run it again and you'll have even more memory
01:01:56 * shapr snickers
01:03:35 <chucky> bring: Oooops did I actually commit that? Those names were supposed to be temporary... :)
01:03:45 <andersca> haha
01:03:49 <Cale> If you're wondering about the time, I was using a patently silly algorithm, just wanted to see whether it would work.
01:03:56 <bring> it's in the 0.7 release I think
01:04:06 <bring> yep, it is
01:04:11 <Cale> the memory is rather funny, though :)
01:04:13 <chucky> damn
01:04:30 <Cale> And they say Haskell has problems with memory usage.
01:04:39 <bring> cjucky: let's call it an easter egg
01:04:57 <bring> it being easter and all
01:05:24 * shapr grins
01:08:42 <bring> still, who's Karin?
01:08:52 * shapr is also curious
01:10:02 <skew> cjunky? in #haskell?
01:10:33 <shapr> chucky :-)
01:11:18 <chucky> ha ha. :) Karin is someone from way back. I had been discussing token fat girls with someone when I needed variable names, and Karin is/was? a token fat girl
01:12:00 <musasabi> Would there be an easy way to add caching to haskelldb?
01:12:30 <bring> skew: it was an honest typo
01:12:45 <skew> yeah, mine was a dishonest typo
01:13:15 <bring> oh, now I see, I thought I had typed cjunky
01:13:22 <skew> not quite
01:13:32 <bring> musasabi: what kind of caching? query results?
01:13:51 * shapr grins
01:17:31 <musasabi> bring: something like that. I am thinking of a way of handling permissions efectively... and it ends up in a recursive model...
01:18:06 <bring> but you don't want the database overhead on every query?
01:18:19 <shapr> greetz Si\ 
01:19:07 <musasabi> Groups contain groups and users and when checking permissions one can go through many groups recursively (and has to avoid cycles), so doing it in some cached way seems preferrable.
01:19:45 <musasabi> data Group = Group list User list
01:20:04 <Si\> 'morning
01:20:25 <skew> flatten that so each user has a list of groups, or just a list of permissions
01:20:35 <musasabi> pseudocode... and member group = member user_list or member group_list 
01:20:38 <skew> or rather, cache a flattened copy somewhere
01:21:17 <musasabi> flattening would be good but how to integrate it with the data being concurrently updated in the db?
01:21:25 <skew> very carefully
01:21:43 <skew> a global lock on permission updates is probably acceptable
01:21:53 <shapr> yah, that's the easiest way to do it
01:21:57 <skew> it's not like you need to change permissions on the root group a million times a day or something
01:26:44 <musasabi> so just wrap the permissions inside ST...
01:27:57 <musasabi> but that is quite expensive if I spawn a new ghc for each request... 
01:28:06 <musasabi> that is a ghc generated binary
01:28:41 <shapr> that's one reason I'm looking forward to Si\'s HAIFA
01:29:31 <skew> musasabi: huh? where did the binaries come in?
01:30:13 <shapr> I think he's saying that if you're using WASH+HaskellDB, you have to start up a database connection etc for each webrequest
01:30:15 <skew> actually, I thought you were talking about keeping these permissions in a database
01:30:36 <skew> oh, yeah, but that's completely unrelated to this permissions stuff
01:30:43 <skew> that's a Haskell CGI issue
01:30:58 <shapr> lambdabot is a long-running process, but he doesn't keep an open database connection since I don't know how to persist a connection in the per-module state
01:32:06 <bring> some database client libraries support persistent connections
01:32:49 <bring> that way the haskell code doesn't have to care about it
01:32:52 <musasabi> skew: the "flatten-the-permissions-from-the-db" takes more time than I would like to spend on each request.
01:33:07 <shapr> bring: how does that work?
01:33:08 <skew> I mean keep a flattened permissions table in the db
01:33:34 <bring> shapr: now that you mention it, it is a bit strange
01:34:04 <shapr> for lambdabot, I can only save per-module state that is an instance of Typeable
01:34:39 <bring> lambdabot runs as one process, right?
01:34:52 <shapr> yup
01:35:25 <skew> wait, persistant between runs of lambdabot, or between calls to the particular function that does the database lookup
01:35:32 <bring> so, if it is linked to a database client library, that library could keep the presistent connection handles in it's on data space somewhere
01:35:34 <shapr> only way I can think of is to have an MVar that's actually a database connection
01:35:58 <shapr> skew: atm, persistent between calls
01:36:05 <bring> the connection could be kept on the C heap or something
01:36:13 <musasabi> flattened permissions are around 30kb, not nice to put into db, of course I could work with deltas...
01:36:52 <shapr> the reason for between call persistence only is that lambdabot holds a finitemap of module name to module state
01:37:37 <shapr> so the only way we could find to get the finitemap elements to all be the same type is to make them dynamic types
01:38:06 <shapr> delYsid suggested we use a tuple that gets passed around all the time, and that would work
01:38:25 <shapr> but how would a plugin module register its own state?
01:38:45 <skew> there's always the unsafePerformIO newIORef hack
01:38:48 <shapr> at this point, it could be done with template haskell, since TH can treat a tuple as a sequence
01:39:06 <skew> we could use some mechanism for global variables
01:39:20 <bring> for this particular problem it not an issue if the (C) db driver can keep internal state
01:39:25 <skew> or, for dynamics that can include polymorphic values
01:39:54 <shapr> bring: true, but I'd like to find a more general solution, since I know I'll run across this problem when I start writing commercial Haskell webapps.
01:40:23 <shrimpx> heh
01:40:32 <shrimpx> "haskell commercial webapps" has a weird ring to it
01:40:35 <shapr> the template haskell tuple solution is workable, but not portable
01:40:41 <shapr> shrimpx: why?
01:40:55 <shrimpx> shrug
01:41:00 <Si\> he means Enterprise Haskell :)
01:41:09 <shapr> if I can write a webapp in less time and less money than someone using J2EE, my clients won't care how it sounds :-)
01:41:20 <skew> First we define the category of web applications. Now, let ...
01:41:26 <shrimpx> haha
01:41:35 <bring> I don't now squat about lambdabot, but couldn't plugins have a type parametrized over the type of its state
01:41:51 <skew> the module table would still be a problem
01:41:57 <bring> ah
01:41:58 <musasabi> getting out of cgi would be a first step...
01:42:04 <skew> maybe an existentially typed thing for runtime state would be good
01:42:12 <shapr> musasabi: truly, and Si\ is working on that.
01:42:44 <Si\> shapr: Have you seen that a new version of HXT is out, it might work for you
01:43:10 <shrimpx> shapr: it would be cool to have a haskell software infrastructure that would make haskell a viable web language
01:43:17 <shapr> you mentioned it, but I haven't had time to check it out yet.
01:43:22 <shapr> shrimpx: truly, I agree.
01:43:45 <shapr> we've got xmlrpc, we've got SOAP and haskellettes on the way.
01:43:49 <Si\> HAIFA doesn't use CGI; it uses a remote application server which HWS-WP communicates with via TCP
01:43:57 <bring> haskell server pages too
01:44:08 <musasabi> Si\: do you have any link on that?
01:44:08 <shapr> right, and halipeto
01:44:42 <skew> WASH, but that's still has rough spots
01:44:53 <musasabi> using an application server and halipeto would be possible, but does such a beast exist that suports haskell?
01:44:54 <bring> haskell server pages will not need a new process for each request
01:44:56 <shapr> any particular rough spots?
01:45:00 <Si\> all I have atm is http://www.dcs.shef.ac.uk/~u1sf/haifa.html
01:45:29 <skew> I don't know of any way to use links for navigation without losing state
01:45:45 <skew> the constantly growing state seems like it could be an issue too
01:46:58 <skew> given a Haskell web server you could probably provide the same interface with continuations
01:47:49 <skew> WASH looks like it's plenty useful for quickly and easily writing stuff, but I don't know what to do if you don't like the big buttons everywhere
01:48:07 <shapr> ah, for non-form stuff
01:48:45 <skew> trying to write a whole web application thing in it
01:48:59 <shrimpx> is mod_haskell still being developed?
01:49:09 <shapr> last update for mod_haskell was 2002
01:49:12 <shapr> so I don't think so
01:49:21 <shapr> but they link to a cvs repo, you could check it.
01:50:25 <shapr> skew: do you mean the look and feel? or do you mean how to use WASH with something other than forms?
01:50:29 <shapr> wash is very form-centric
01:50:38 <skew> well, both
01:51:00 <shapr> I think css could solve the look&feel
01:51:15 <skew> the look is easy to fix except for not being able to use links
01:51:36 <skew> css like you said, and combinators with your fancy header and footer in them, and stuff like that
01:51:37 <shapr> you can create links, but they're not automated in the way that zope links are automated.
01:51:58 <skew> just getting keeping state across the links is a puzzle
01:53:49 <shapr> well, there is the Persistent module
01:54:03 <shapr> which appears to stuff everything into /tmp
01:57:50 <shapr> but I haven't tried it with links rather than forms
02:01:26 * earthy could ask Armijn about mod_haskell
02:01:40 <shapr> yes please :-)
02:02:02 <earthy> but I'm pretty sure Eelco doesn't work on it anymore. :)
02:10:09 <earthy> 'kay, I checked. Armijn isn't in, and Eelco considers it to be quite dead and bitrotted
02:11:01 <earthy> the apache 2.0 and ghc support is what one would have to call highly experimental
02:11:48 <earthy> there was someone interested in developing it further a few months ago, but after sending him the CVS repository nothing further was heard
02:15:05 <shapr> oh well
02:25:40 <Si\> that wasn't me was it?
02:25:54 <Si\> I asked about it a few months back
02:26:12 <Si\> when I was doing some research
02:28:52 <Si\> but it's way beyond my skills to resurrect it in any way
02:29:08 <shapr> I'd prefer a long-running Haskell process anyway
02:29:10 <shapr> hej Marvin-- 
02:29:13 <Marvin--> morning
02:30:38 <bring> I think the HSP guys at Chalmers are owrking on having a haskell server process running constantly
02:30:54 <earthy> Si\: unsure. `someone'. :)
02:30:55 <bring> and it communicates over a socket with a simple apache module
02:31:09 <earthy> bring: mod_haskell does something quite like that
02:31:21 <bring> ah, ok
02:31:22 <Si\> HAC does something a lot like that
02:31:40 <earthy> the apache module forks off a hugs interpreter and feeds it stuff
02:32:03 <bring> is that for apache 1 or 2?
02:32:08 * Marvin-- plays with Text.PrettyPrint
02:32:41 <earthy> bring: mod_haskell is supposed to work iwth both
02:33:11 <bring> ok
02:34:11 <bring> I wish the HSP guys would hang out here
02:34:23 <shapr> you could invite 'em over
02:34:27 <bring> I have
02:34:31 <shapr> oh
02:35:44 <shapr> well, if they don't show up, they'll just have to get along with the benefit of our wisdow 
02:35:46 <shapr> wisdom
02:38:23 <Si\> you mean without?
02:38:34 <Marvin--> bring: who are the HSP guys?
02:38:37 <shapr> er, yes
02:38:38 <shapr> without
02:38:40 <shapr> ack, I can't type
02:38:49 <bring> Marvin--: farre and nibro
02:39:11 <Marvin--> hm, nobody I know
02:41:06 <bring> they also wrote HaRP
02:41:22 <shapr> what's that?
02:41:24 <bring> well, it's for HSP, but a separate thing
02:41:38 <shapr> I've heard of that.. but I don't remember what it does.
02:41:50 <bring> shapr: use curryspondence :)
02:42:06 <bring> what's the url for that again?
02:42:18 <shapr> http://www.dtek.chalmers.se/~d00nibro/hsp/
02:42:32 <shapr> I really need a shorter url for that
02:42:37 <shapr> and a threadmode
02:42:49 <shapr> and to use ILIKE instead of LIKE
02:42:58 <bring> right
02:43:17 <bring> stupid not-properly-standardized SQL
02:43:21 <shapr> right
02:43:52 <bring> hey, they link to the original haskelldb
02:44:34 <shapr> this is still it for the moment: http://shapr.homelinux.net/cgi-bin/wash/SearchML
02:44:35 <bring> HaRP is a preprocessor that adds regular-expression-like patterns to haskell
02:45:10 <bring> http://shapr.homelinux.net/cgi-bin/wash/ShowMessage?%3CBAY2-F5231wEf2XfIdC0000e83f%40hotmail.com%3E
02:45:17 <bring> that's HaRP
02:45:45 <shapr> oh speaking of TODO items, Peter Thiemann said I should just Base64 encode the message-id and then it won't cause shell-escape problems
02:46:17 <Marvin--> good point
02:47:04 <shapr> oh, would be handy to auto-url stuff that might be an url
02:47:12 <bring> shapr: what's the problem with the date parsing btw
02:47:46 * Marvin-- swears at conflicting symbol names in PrettyPrint and Parsek
02:47:47 <shapr> probably several, starting with the way I convert WASHMail's RFC2822 date into a calendartime
02:47:58 <bring> 'cause I've got a nice date parsing module sitting around here, watching tv, drinking beer and making a mess
02:48:02 <shapr> haha
02:48:23 <bring> time for it to cut it's hair and get a job
02:48:32 <bring> s/it's/its/
02:48:47 <shapr> great idea :-)
02:50:04 <bring> that's all in MboxToDB, right?
02:50:16 <shapr> yup
02:53:01 <musasabi> what would be a good tool to model a functional program, something like UML to oo-languages?
02:53:20 * earthy doesn't understand the question
02:53:37 <skew> I remember seeing a thesis proposing some notations and so on along those lines
02:54:20 <shapr> isn't there functional pattern systems or something?
02:54:27 <musasabi> earthy: I want to formulate the structure of a program, and am wondering whether good notation/tools exist
02:54:32 <shapr> functional design methodology...
02:54:35 * shapr tries to remember
02:54:42 <skew> I don't seem to have a copy. Something like "functional design methodology"
02:54:59 <skew> FAD
02:55:00 <shapr> yes, that sounds like it
02:55:03 <skew> http://www.cs.kent.ac.uk/pubs/2001/1152/
02:55:04 <earthy> dan russell? fad?
02:55:11 <skew> yes
02:55:22 <shapr> I found it on the original wiki I think
02:55:30 <musasabi> thanks, I'll look into that
02:56:24 <shapr> http://c2.com/cgi-bin/wiki?FunctionalPatternSystemForObjectOrientedDesign
02:56:27 <shapr> that's what I was thinking about.
02:58:15 <Marvin--> I *like* Text.PrettyPrint
02:59:54 <bring> hmm, it looks like some people have broken mail clients or something: "Date: 27 Feb 2001 11:42:58 +0100"
03:00:41 <shapr> and their name is probably Outlook
03:00:57 <bring> that doesn't look like rfc822 format
03:05:36 <shapr> yah, I saw a lot of that
03:07:01 * XTL is fighting very hard not to throw his phone at the wall
03:07:17 <shapr> telemarketers?
03:07:22 <shapr> we got five yesterday.
03:08:07 <ibid> bring: looks to me like rfc822 format
03:08:09 <XTL> shapr: Not that bad. I just ordered a password from the operator via sms and then accidentally immediately deleted the message I got back.
03:08:33 <shapr> oh, that sucks a lot
03:08:35 <earthy> then you should throw your own head at the wall, right?
03:08:48 <shapr> can you get the password resent?
03:08:55 <earthy> it's not the phone's fault, is it? :)
03:09:14 <XTL> earthy: No, but you know, violence and pecking order and all that.
03:09:22 <XTL> It's the user interface designers' fault :)
03:09:52 * earthy grinz
03:17:19 <Marvin--> these proofs are *so* much more readable now
03:17:24 * Marvin-- hugs PrettyPrint
03:26:50 <shrimpx> ls
03:26:54 <shrimpx> er sorry
03:28:22 <earthy> . not found
03:28:56 <shrimpx> heh
03:55:38 <shapr> bring: this is the time format I keep forgetting http://cr.yp.to/libtai/tai64.html
03:56:53 <bring> "Under many cosmological theories, the integers under 2^63 are adequate to cover the entire expected lifetime of the universe; in this case no extensions will be necessary."
03:57:00 * shapr grins
03:58:26 <bring> ibid: you're right, day-of-week is optional, didn't know that
03:58:37 <shapr> hej hampus
03:58:38 <bring> hi hram
03:58:53 <hram> hello!
03:59:18 <shapr> what's going on?
03:59:59 <hram> not, much... some small haskell-coding for school mostly...
04:00:17 <bring> lang tech?
04:00:32 <hram> yepp.
04:02:06 <hram> While doing this I found the -s flag to the GHC rts. A very nice thing!
04:02:36 <shapr> what does -s do?
04:03:27 <hram> It gives you GC-statistics. One of my programs spent ~64% of its time doing GC...
04:05:17 <shapr> oh
04:05:17 <shapr> neat
04:08:20 <earthy> ouch. that's painful, 64% in garbage collecting
04:09:46 <hram> Yes, very much so. Even more painful is the fact that I can figure out a way to make it less memory-consuming...
04:13:45 <bring> damn, wash is pretty serious about dates
04:14:40 <Marvin--> ARGH
04:14:50 * Marvin-- swears at PrettyPrint:s indent function
04:14:56 <shapr> bring: what do you mean?
04:15:13 <Marvin--> the stupid thing uses *tabs*
04:15:13 <shapr> the more I read about libtai, the more I want TAI support directly in Haskell
04:15:19 <shapr> ohh, kill it NOW!
04:15:31 <Marvin--> indent n | n >= 8 = '\t' : indent (n - 8)
04:15:32 <Marvin-->          | otherwise      = spaces n
04:15:34 * Marvin-- swears loudly
04:15:50 <bring> it does leap second correction
04:15:51 <Marvin--> there's not even a flag for it
04:15:52 <shapr> kill!
04:15:57 <bring> I consider that serious
04:17:38 <hram> the guys who invented TAB is almost as evil as the Caps Lock-people... :)
04:21:31 <shapr> happily, I've remapped caps_lock to hippie-expand
04:22:18 <Marvin--> I map caps lock to left ctrl
04:22:31 <Marvin--> *sigh*
04:22:39 <Marvin--> \verbatiminput doesn't like tabs, that's why this looks like crap
04:23:14 <skew> can you just switch to spaces?
04:23:30 <Marvin--> no! There's no flag for that in Text.PrettyPrint!
04:23:46 <Marvin--> I guess I'll have to post-process the damn thing
04:23:57 <skew> I mean change your code
04:24:03 <hram> Marvin--: I would consider that a bug and report it somewhere...
04:24:15 <Marvin--> I just fired off a mail to libraries@h.o
04:26:21 * Marvin-- goes to make some coffee
04:29:45 <Marvin--> tabs_to_spaces = unlines . map f . lines
04:29:45 <Marvin-->   where f ('\t':xs) = replicate 8 ' ' ++ f xs
04:29:45 <Marvin-->         f xs        = xs
04:29:47 * Marvin-- sighs
04:30:18 <Marvin--> hope that it'll get some fusion love
04:30:26 <Igloo> You realise that's not true in general, right?
04:31:05 <Marvin--> I'm only interested in stripping leading tabs
04:31:39 <Marvin--> which is why I do the unlines/lines juggling
04:31:40 <Igloo> Oh, I hadn't even read the code properly, so it is generally true. Just ignore me  :-)
04:31:56 <Marvin--> don't mind if I do :-)
04:32:15 <Marvin--> trouble is, now the proofs are hella-many pages instead
04:32:18 <Marvin--> oh well
04:32:58 <Igloo> Well, your proof can't be going worse than mine, which turns out to be proving something that's false  :-)
04:33:12 * Igloo is hopeful the uber proof is still true, though
04:33:50 <Marvin--> happily, my proofs are computer-generated
04:33:57 <Marvin--> I just have to read them and understand them :P
04:34:16 <Marvin--> (oh, and figure out whether they are actually meaningful after the translation from Haskell to FOL...)
04:34:24 <Igloo> Heh
04:37:08 <bring> hmm, WASHMail does not seem to like rfc822 dates without the day-of-week
04:37:35 <shapr> that might explain a lot of the Nothing entries I have
04:37:40 <bring> that's 184 out of the 192 bad dates in the libraries archive
04:37:45 <shapr> ooh
04:37:58 <shapr> nice
04:39:03 <Marvin--> wow, my email turned into a rant
04:39:03 <Marvin--> oh well
04:39:07 <shapr> heh
04:46:39 <bring> is there even a single type signature in all of WASH?
04:47:15 * shapr dunno
04:47:22 <shapr> but the errors give very exciting type signatures
04:47:29 <shapr> especially when there's HDB in the mix
04:47:34 <bring> :)
04:47:57 <bring> I guess I should be the one to complain about lack of type signatures
04:48:05 <bring> s/should/shouldn't/
04:48:10 <shapr> I've had more than a screenful of 10pt @ 1280x1024
04:48:31 <shapr> got X, expected y
04:48:37 <shapr> and I could only see the bottom of X
04:48:53 <bring> yeah, sometimes the fill the terminal buffer so you can't even scroll to the top
04:49:07 <shapr> I have 800 lines of terminal buffer, so that hasn't been a problem.
04:49:26 <shapr> of course, compared to Java errors, this is small fry
04:49:42 <Marvin--> should I have just one appendix for both source code and proofs (like source code in A.n.1 and proofs in A.n.2) or should I separate them into source code in A.n and proofs in B.n?
04:56:30 <bring> shapr: ok, fixed washmail, just had to add try in one place
04:56:39 <bring> I'll let you figure out where
04:57:08 <shapr> ??
04:57:25 <shapr> well, pass the patch back to Peter
04:57:39 <bring> sorry, bad joke
04:58:05 <shapr> lemme guess, line 237 of MailParser.hs ?
04:58:17 <bring> 236 actually
04:58:20 <bring> good guess
04:58:32 <bring> right before the second do
04:58:34 <shapr> oh
04:58:41 <bring> I'll CC the patch to you
04:58:44 <shapr> awright
05:01:18 <shapr> I suspect my DateTime2822 -> caltime converter is way broken
05:01:38 <shapr> bring: oh, hey, did you look at the README? did it work?
05:02:04 <bring> README?
05:02:05 <shapr> oh, I bet I forgot to mention creating symlinks to the CGI, MAIL, etc dirs
05:02:10 <shapr> curryspondence README
05:02:33 <shapr> you probably need the README less than I do :-)
05:02:34 <bring> oh, I didn't try running curryspondence 
05:02:45 <shapr> well, MboxToDB is part of it :-)
05:03:01 <bring> didn't run that either :)
05:03:06 <shapr> heh, ok
05:03:13 <bring> I just wrote a very simple test program to test the WASHMail date parsing
05:03:14 <shapr> how did you find out about the number of unsuccessful parses then?
05:03:16 <shapr> ah, ok
05:12:15 <bring> there was no README in the file I downloaded btw
05:15:00 <shapr> oh
05:24:08 <Jerub> I just realised an irony.
05:24:31 <Jerub> I moved to mutt because I wanted a prettier email client.
05:25:06 <Marvin--> yay, 30 pages of report and 15 pages of appendix
05:25:30 <Jerub> Marvin--: slacker. you can add at least another 100 pages to that appendix.
05:25:43 <bring> shapr: http://shapr.homelinux.net/cgi-bin/wash/ShowMessage?%3C20030605183345.GF11206%40boris.qub.ac.uk%3E
05:25:53 <bring> is sent on 2003-33-05
05:29:12 <Marvin--> Jerub: :)
05:29:33 <bring> what's that, Floopuary?
05:31:28 <det> Jerub: what did you use prior to mutt?
05:31:36 <Jerub> det: sylpheed
05:31:47 <Jerub> which is gtk1.
05:32:53 <det> I see
05:33:04 <det> did you try -claws, I remember it being much nicer looking
05:33:06 <det> yet still gtk1
05:34:34 <Marvin--> some of these proofs are actually quite nice
05:34:39 * Marvin-- is happy
05:38:07 <Jerub> det: no, didn't like either.
05:38:17 <Jerub> well, I finally moved because it was crashing on me and refusing to send mail.
05:38:20 <Jerub> Marvin--: yay!
05:41:20 <bring> shapr: oh, and the tarball is missing most of the DBDirect-generated files
05:41:40 * bring is picking on shapr
05:42:11 <det> Jerub: oh, that is bad bad bad
05:42:25 <det> Jerub: I've yet to have a problem with gnus
05:46:52 <Jerub> det: I'm not an emacs user.
05:55:45 <bring> shapr: searchML is great, I finally found Simon Marlow's prototype for a new System.Time
05:56:11 <bring> eh, s/searchML/curryspondence/
05:56:36 <shapr> yah, I gotta rename it
05:57:23 <shapr> bring: anyways, I've seen 2002-45-50 or so, so I'm not *that* impressed with Floopuary ;-)
05:57:37 * shapr laughs
05:57:44 <shapr> Floopuary is a great name though.
05:58:00 <bring> it's from a Dilbert strip
05:58:17 <bring> http://www.kidasa.com/news/feb03/index.html
05:58:36 <bring> (no search on official dilbert site)
05:59:00 <Marvin--> Dilbert rocks
06:00:29 <shapr> shite, WASH uses tabs too
06:00:42 <shapr> crap, I gotta go to my root canal appointment
06:00:45 * shapr bails out
06:00:54 * vegai goes 'AUCH' for shapr.
06:53:10 <ozone> uh oh
06:53:15 * ozone has discovered the badness of orkut
06:53:20 <ozone> cannot ... stop ...
06:55:31 <_rubix> ozone, I really understand your problem.
06:56:14 * bring realizes that date format strings are not the best thing since sliced bread
06:58:02 <musasabi> Installing hsql docs fails on debian unstable.
07:06:13 <skew> Keith Wansbrough's proposal for distfix operators is pretty interesting
07:06:33 <skew> I wonder how much they would be used for
07:09:34 <SyntaxNinja> does anyone know of a reference for Debian's version parsing?
07:09:45 <SyntaxNinja> ozone: I can't find anything to do on orkut.
07:09:59 <ozone> SyntaxNinja: orkut is the schnizzle when you're bored
07:10:21 * ozone looks for SyntaxNinja on orkut
07:10:21 <Igloo> I'd try policy, developers reference, dpkg docs/source in that order
07:10:22 <skew> or have work you really should be doing?
07:10:51 * ozone finds haskell community, uh oh
07:11:22 <musasabi> Did haskelldb support autoincrement fields?
07:12:13 <ozone> oh look, shae's on there, what a surprise :)
07:15:17 <bring> musasabi: no, currently it doesn't
07:15:36 <bring> we're thinking about how to do that the right way
07:15:43 <det> skew: distfix operator o_O?
07:16:49 <bring> suggestions are very welcome
07:18:52 <musasabi> bring: on insertions it is often enough to ignore the field.
07:19:15 <musasabi> now if one wants the value it is more complicated
07:19:24 <bring> you can't ignore a field when inserting in haskelldb
07:19:51 <bring> type system guarantees that
07:20:02 <bring> it mostly a good thing, but a problem here
07:20:47 <bring> but, as you say, getting the id (as with LAST_INSERT_ID or whatever it is called) is the biggest problem
07:20:57 <musasabi> what about other fields with default values?
07:21:06 <bring> same problem
07:21:22 <bring> we were thinking of adding a default :: Expr a
07:21:58 <bring> but then there's nothing stopping you from using that in a query instead of an insert, which breaks at runtime
07:22:17 <bring> which is something we generally want to avoid
07:22:23 <bring> maybe a type system hack is in order
07:22:47 <musasabi> What about using a view for the inserts? (that could solve things in postgresql...
07:23:19 <musasabi> having two "tables" and inserting into one and selecting from the other
07:23:57 <bring> that could work
07:24:07 <bring> hacky
07:24:28 <musasabi> yes
07:24:55 * Igloo sighs, sends off a counter-example of what I was trying to prove to my supervisor and thinks about going home
07:25:24 <reltuk> igloo : ouch
07:26:29 <bring> I'm thinking about some extension to haskelldb's type system to allow certain expressions only in certain places
07:27:22 <bring> we need that for restricting where aggregate expressions can be used, and for default values (which should fix auto increment too)
07:40:34 <sineltor> ...hey guys
07:40:56 <sineltor> does anyone know how to use .hi and .o files in ghci
07:41:00 <sineltor> ...when you don't have the .hs file
07:41:12 <sineltor> without moving them into your imports directory?
07:41:25 <sineltor> i've been pouring over the manual for aaaages and can't find it :(
07:49:37 <bring> sineltor: just create empty source files corresponding to each object file, and make sure that the .o and .hi files are newer than the source files
07:50:41 <bring> ghci only seems to look at the name and modifcation date of the source file, if the source file is not newer than the compiled files, it doesn't open it
07:50:53 <sineltor> ok
07:51:02 <bring> bit of a hack
07:51:15 <sineltor> yeah - is there a way to add a path to look for imports?
07:51:19 <sineltor> i tried -i.
07:51:25 <bring> that's it
07:51:38 <sineltor> but it apparently just looked for .hs files there - didn't look for .hi/.o
07:51:59 <sineltor> its automatically checking the .../ghc/lib/ghc-6.2/imports dir
07:52:20 <sineltor> and importing stuff thats there,.. i've been wondering if there's a way to duplicate that behaviour
07:52:27 <sineltor> ...short of copying the files into that dir (which works)
07:53:36 <bring> you could add a fake package using ghc-pkg that tells it to look in your dir, but there must be a better way
07:54:09 <bring> "One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the Prelude and standard libraries such as IO and Complex. If you attempt to load a module for which GHCi can't find a source file, even if there are object and interface files for the module, you'll get an error message."
07:54:29 <bring> so maybe a fake package is the only way to do it
07:57:03 * sineltor nods
07:57:03 <sineltor> ok thanks
07:57:06 <musasabi> What would be a good way to results 50 results at a time from the db? 0..50, 51..100, ...
07:57:06 <sineltor> i'll give that a shot
07:59:32 <bring> hmm, there is a way to get the first 50
07:59:35 <bring> using top
07:59:41 <bring> but not 50-100
08:00:13 <bring> it's bad, the problem is that there is no standardized way of doing it in SQL
08:00:22 <reltuk> what happened to the wiki?
08:00:26 <bring> not even getting just the first N
08:00:38 <saz> sineltor: why hello
08:00:50 <sineltor> hey :)
08:01:01 <sineltor> ...what SQL database you using musasabi?
08:01:08 <reltuk> frontpage got reverted to a version from a year ago
08:01:29 <sineltor> if its mysql then you can tack limit 51,50 onto the end of your select query
08:02:02 <bring> musasabi: oh, are you talking about using SQL or HaskellDB?
08:03:09 * musasabi considers dumping the whole yes
08:03:27 <musasabi> doing without sql might be quite attractive...
08:11:11 <bring> hugs doesn't support explicity kinded quantification, right?
08:15:46 <musasabi> that's it I am dumping the whole sql out of the window.
08:16:03 <musasabi> just keep everything in memory ^_^
08:19:53 <lewis_m> i'm trying to search for BST equality with the func bst_equal (Node n t1 t2) (Node m t3 t4) and what I'm doing is checking the right hand side for n, the left hand side for m and then bst_equal on the union of t1,t2 and the union of t3,t4 - is there a better way to do it?
08:20:32 <lewis_m> it works, but it just seems really messy to me
08:21:42 <reltuk> HashTable is mutable?
08:22:16 <reltuk> oh yeah...it has IO return types
08:24:45 <hram> HashTable is really strange... insert does not work quite as one expects...
08:25:02 <reltuk> what does that mean?
08:25:53 <hram> in:   insert ht "foo" val1 >> insert ht "foo" val2       the later val2 will not remove val1
08:26:36 <reltuk> will lookup ht "foo" return val2?
08:28:07 <hram> Yes, but toList will contain them both (and delete will remove both)
08:28:52 <reltuk> wow...that's screwed
08:29:15 <hram> Yes, quite so.
08:30:06 <reltuk> ghc doesn't use it once :-p
08:31:02 <reltuk> eh, n/m...I messed up my grep
08:46:37 <shapr> reltuk: just as you said, what happened to the wiki?
08:46:47 <shapr> reltuk: I'd tell you to ask the maintainer, but he doesn't know either.
08:47:00 <reltuk> shapr: I don't know...that guy reverted to the frontpage from a year ago...
08:47:07 <reltuk> very strange if ya ask me :-p
08:47:11 <shapr> I agree
08:47:15 <shapr> wtf
08:47:23 <shapr> I'm the maintainer so I better figure it out :-)
08:47:28 <reltuk> haha
08:47:33 <reltuk> good luck :)
08:47:52 <reltuk> (btw, good job with the wiki...invaluable resource :))
08:48:20 <shapr> it's a credit to the community
08:48:41 <shapr> lots of different people from here on #haskell and other places have put up stuff.
08:50:12 <lewis_m> man, functional programming is tricky - i can't figure out how to write a sane scan and compare for this BST at all
08:50:18 <musasabi> What would be a good way to implement a mutable two way association between two pieces of data?
08:50:35 <shapr> IORefs? or rebuild it with the credit card transform
08:50:53 <reltuk> lewis_m: what's "scan and compare" do
08:50:54 <reltuk> ?
08:51:26 <lewis_m> reltuk: well, I just mean to check if their equal - but I can't see how to do it the way I would if I was writing it in say C, or Ada or something
08:51:50 <musasabi> shapr: I need N<->N instead of 1<->1...
08:52:00 <reltuk> lewis_m: check if a tree has the same structure as another tree?
08:52:04 <lewis_m> reltuk, at the moment I have this:
08:52:07 <lewis_m> reltuk, --bst_equal (Node n t1 t2) (Node m t3 t4)
08:52:08 <lewis_m> --  | n == m    = bst_equal (bst_union t1 t2) (bst_union t3 t4)
08:52:08 <lewis_m> --  | otherwise = bst_find n (Node m t3 t4) && bst_find m (Node n t1 t2) && bst_equal (bst_union t1 t2) (bst_union t3 t4)
08:52:44 <lewis_m> reltuk, to see if they both contain all the same nodes
08:52:55 <shapr> lewis_m: have you seen fmap?
08:53:10 <shapr> musasabi: do you need to retain a reference? or could you just use a lookup table?
08:53:57 <shapr> musasabi: for example, the dead simple solution is to make sure your datatypes are instances of Ord and make a FiniteMap
08:54:13 <musasabi> I have a set of tags each associated with a set of images. I need to lookup all images associated with a tag and remove images efficiently. a pair of hash tables would work of course, but I am wondering what would be the best.
08:54:15 <lewis_m> shapr, hmm, not ringing any bells, is it a function?
08:54:21 <shapr> myFM :: Thingy [Thingy]
08:54:59 <reltuk> turn them into inorder lists of hte tree...
08:56:36 <lewis_m> reltuk, that did occur to me as an option actually.. just wasn't sure if it was allowed as far as my assignment goes, which is to implement sets in terms of lists and BST, so I've already done the list equal - i *could* just reuse it, but that probably isn't what they intended that I do
08:57:31 <reltuk> well...it wouldn't be all that slow...depending upon how heavy the thing being stored in the tree is
08:57:57 <reltuk> since the conversion to an inorder list is lazy, you don't have to do the entire thing if early elements differe
08:58:39 <lewis_m> i've just thought of an alternative actually, which might be neater, I could check if the length is the same and the only check if each node of the left is in the right
08:58:45 <lewis_m> that'd get rid of all the union crap I was doing
08:59:19 <lewis_m> well, length as in, number of nodes
08:59:32 <lewis_m> hmm, but then that's just essentially changing it to a list anyway
08:59:32 <shapr> musasabi: I'd suggest starting with an FM, it's easy to implement and you can try something faster later.
09:09:03 <reltuk> lewis_m: in other words, converting to an inorder list is probably the most natural way to do it, and it should be expected by your instructor
09:09:43 <shapr> musasabi: and I'd suggest asking if there's a better solution when the night shift is around, several algorithms people then.
09:09:50 <reltuk> it also only takes 2 n time, instead of n lg n, which is what searching for every element in tree 1 to see if it exists in tree 2 takes
09:12:52 <reltuk> actually...depends on the tree how long inorder traversal takes...
09:13:11 <musasabi> ok, I'll try that.
09:13:26 <reltuk> but yeah, there are heavily documented methods of making it take O(n) time
09:39:15 <reltuk> I think I'm finally starting to understand Monads
09:39:20 <shapr> yay!
09:39:33 <reltuk> lol, like two weeks latter :-p
09:40:47 <reltuk> and it's not like a formal understanding...it's more an intuitive, "this is what you can do, this is how it works"
09:43:46 <Smerdyakov> There's not much to a formal understanding.
09:43:55 <Smerdyakov> Just the Monad class definition and the monad laws.
09:46:58 * esap thinks understanding monads intuitively is much harder than understanding them formally. But both are easy :-)
09:52:30 * XTL rescued two Ultra Axi boards and some scrap
09:52:46 <shapr> what's an Axi?
09:52:50 <XTL> There's still a NeXT there. Maybe they'll spare it or leave it for me instead of throwing it away.
09:52:54 <XTL> Having no car sucks.
09:52:58 <shapr> if you find some 1980's IBM keyboards, call me!
09:53:04 <shapr> whoa say that again
09:53:07 * esap has no car.
09:53:10 <shapr> they're throwing out a NeXT?
09:53:26 <XTL> shapr: Sun board.  Atx board with some Ultra II IIRC.
09:53:49 <XTL> There's a working (last I tried) NeXT Cube there in a pile of Stuff That Has To Go at work.
09:53:57 <shapr> I want it!
09:54:10 <shapr> does that mean they're selling? or just dumping?
09:54:28 <XTL> I don't have room or use for it, really but I feel it's my duty to try to rescue it if they're throwing it. 
09:54:37 <shapr> I have room and use for a NeXT
09:54:44 <shapr> and for some SPARC hardware (for Self)
09:54:48 <XTL> The CEO actually owns it but I don't know if he's taking it back or not. It's been there as a decoration :)
09:55:27 <shapr> well, if it's going for free, I'll pay shipping, handling, and some on top if you can figure out some way to get it over here.
09:55:32 <XTL> Pile of older PC's too, but I don't much care about that.
09:55:49 <shapr> a NeXT is way sexy
09:55:52 <XTL> shapr: Hm. It might not be entirely impossible if I get it here first.
09:56:03 <XTL> Where is there?
09:56:12 <shapr> Boden, Sweden; outside of Luleå
09:56:22 <shapr> not too far, but not exactly Espoo
09:56:34 <reltuk> gotta go home
09:56:36 <reltuk> bbs
09:57:51 <XTL> I'm going north to attend a wedding and to stay a while now. So it even hit a bit of a weird moment. 
09:58:08 <shapr> where north? Tornio? :-)
09:58:43 <XTL> Paltamo :)  (and Kajaani or Oulu possibly. Wedding in RistijÃ¤rvi I think)
09:58:45 <shapr> I'd be willing to take the bus to Tornio and pick it up, might even be able to make Oulu
09:59:12 <XTL> But I can't take stuff with me now either, though.
09:59:31 <shapr> ah
10:00:38 * musasabi is in Espoo ;)
10:01:32 <XTL> Stuff is in Lauttasaari. I'm across Helsinki in KurkimÃ¤ki.
10:02:24 * shapr thinks of how to arrange transport for a NeXT
10:03:49 <musasabi> shapr: getting someone to take it on a boat to sweden might be easy.
10:03:56 <musasabi> many people go there...
10:05:12 <shapr> of course, this is still theoretical unless the CEO does want to get rid of it.
10:07:38 <shapr> sadly, the bus to Lauttasaari is a bit much from Boden, otherwise I'd show up and talk to him myself :-)
10:08:58 <SamB> why would anyone want to get rid of a NeXT?
10:09:15 <musasabi> There was a tool to automatically create updater functions for records?
10:10:09 <esap> What's the point of automatically doing that?
10:11:11 <shapr> you can already do that
10:11:23 <shapr> each field name for a record is the updater function
10:12:30 <musasabi> sorry, missed that... 
10:12:35 <musasabi> thanks anyways
10:12:45 * esap would rather have a tool that automatically generated projection functions (with type r -> Maybe e)
10:19:39 <esap> what's wrong with hawiki front page? Is it supposed to be like that?
10:20:56 <shapr> no, it's not
10:21:13 <shapr> and I will fix it, but I'm trying to fix the EuroPython registration right now, before I look at that.
10:21:43 <esap> ok
10:24:32 <bring> ok, Malcolm Wallace wrote the preprocessor, I'd better take it off the EuroHaskell sprint suggestions list
10:24:51 <Igloo> :-)
10:25:19 <Igloo> Fine him for jumping the start  :-)
10:26:06 <bring> what it yesterday he suggested someone write it?
10:26:16 <shapr> yes
10:27:33 <bring> ok, lets write autoconf then
10:27:44 <shapr> I thought Igloo was already working on that one? :-)
10:27:54 <Igloo> huh?
10:27:59 * shapr is joking
10:28:16 <shapr> I was jumping far from the 'make' clone you mentioned
10:28:35 <Igloo> Ah
10:56:15 <reltuk> wow, the TUNES project soundsn like their bootstrap is closely related to http://www.mallard.cs.uiuc.edu/
10:56:22 <musasabi> I am ending up with [IORef Maybe Foo] and that seems quite foolish...
10:56:50 <reltuk> wait..that's totally wrong
10:57:23 <reltuk> http://maude.cs.uiuc.edu
10:57:25 <reltuk> there we go
10:58:50 <musasabi> the idea is to have Bars have a list of [IORef Maybe Foo] and each Foo have a reference to the IORef pointing to them. Now when one removes a Bar it sets the IORef pointing to it to Nothing and Foos periodically remove entries with Nothing from their lists.
10:59:07 <musasabi> Maybe I should consider building a proper type of lists with weak references.
10:59:39 <Cale> someone appears to have reverted the FrontPage on HaWiki back to its initial state.
11:00:42 <Cale> there we go
12:09:25 <musasabi> Why does Data.HashTable use IO instead of ST?
12:13:26 <Si\> isn't it a C backend or something?
12:14:16 <Si\> otherwise dunno
12:15:03 <Si\> "The implementation is also derived from the one in GHC's runtime system (ghc/rts/Hash.{c,h})."
12:26:46 <reltuk> is ST mutable?
12:27:17 <reltuk> hashtable is implemented with mutable arrays it looks like
12:27:55 <reltuk> eh, IOArray rahter
12:44:12 <reltuk> " Technically, they are not distinguishable from nontermination, so the language includes no mechanism for detecting or acting upon errors. "
12:44:20 <reltuk> heh, that's nice of them
13:07:33 <musasabi> having Data.Unique support Show would be nice... now one is forced to do the same by hand if one wants to save the values.
13:07:48 <musasabi> forget that.
13:31:48 <shapr> bring: hey, you got mentioned on libraries
13:31:58 <andersca> where where
13:32:16 <shapr> In the longer run, I'm hoping that the HTTP module will become part of the Network library module, based on work by Bjorn Bringert.
13:32:20 <shapr> from graham klyne
13:32:27 <andersca> cool
13:32:45 <shapr> yah, nifty
13:32:52 <bring> hmm, I'd better do something about that then
13:33:13 <shapr> Jerub: guess what, strange tingling pains in my left hand.... I've always wanted to switch to right hand dvorak...
13:40:57 <LittleDa1> what is unsafePerformIO and why is it unsafe?
13:41:20 <Cale> Have a look at its type: IO a -> a
13:41:31 <LittleDa1> how does that make it unsafe?
13:41:42 <Cale> It takes an IO action and returns the value gotten by running it.
13:41:48 <SamB> LittleDa1: well, its unsafe because it has a side effect at force-time...
13:41:55 <Marvin--> LittleDa1: consider   unsafePerformIO (readFile "/some/where")
13:42:06 <Cale> However, IO actions might return different values based on context and when they are called.
13:42:11 <LittleDa1> oh
13:42:20 <LittleDa1> when is it safe to use?
13:43:03 <bring> "For this to be safe, the IO computation should be free of side effects and independent of its environment."
13:43:06 <Cale> When you don't care when the IO action gets run, or if it gets run multiple times, and it generally has no side effects on the system and will return the same thing every time.
13:43:40 <LittleDa1> so like for FFI?
13:43:45 <Cale> For example, if you used FFI to import a mathematical function imported from some C library, then you might use it.
13:44:29 <bring> although for that particular purpose, you could just import the math function as a pure function
13:46:24 <SamB> you could also use it for caching the values of long computations, right?
13:46:46 <Cale> Hm?
13:46:54 <Cale> How would you do that?
13:48:18 <SamB> I'm not exactly sure, but I think you could do it.
13:50:01 <SamB> something involving a mutable hashtable...
13:50:37 <SamB> or other mapping, of course
13:51:14 <SamB> or just a mutable reference to one
13:51:22 <musasabi> yes that is doable, the only thing I don't understand is howto do it transparently from the clients.
13:52:04 <SamB> musasabi: simple. you cheat!
13:56:16 <musasabi> SamB: yes, with unsafeIO, but how to bind the map to the function without passing it as a parameter?
13:58:23 <SamB> musasabi: you would have to use unsafePerformIO to create a mutable reference to it, probably at the top level
14:11:28 <skew> musasabi: if you do that, you will need to mess around with the NOINLINE pragma and stuff, creating a fresh empty mutable cell not being referentially transparent
14:14:19 <musasabi> hum, sounds nasty.
14:14:29 <skew> there should really be a better way of making global mutable variables
14:14:55 <skew> if you consider the produced IORef a function of the qualified name you want to give it I think it would be safe
14:16:08 <skew> but I'm not sure how that would compile intelligently
14:29:25 <musasabi> Is timestamping new records good use for unsafePerformIO?
14:35:29 <bring> musasabi: you're not guaranteed that the IO action will be performed every time you use its result
14:36:09 <bring> it could be that it's just done once, and you get the same value every time
14:39:29 <musasabi> so what would be a satisfactory compromise? other than littering the whole code with IO?
14:40:11 <Smerdyakov> Switch to ML? ;)
14:40:22 <Riastradh> Use a language that doesn't have imperativeness tacked on as an afterthought?
14:45:37 <Marvin--> is this blasphemy I hear? :)
14:48:45 <vegai> are Riastradh and Smerdyakov twins?
14:53:51 <Riastradh> No: I'd never suggest ML instead.
14:53:54 <monotonom> You can litter the whole code with unsafeIOPerform, if you don't want to litter it with IO.
14:59:44 <monotonom> linear implicit parameter may be good for timestamping records, if you do not need wall-clock time
15:00:09 <musasabi> yes, but I need wall clock.
15:00:30 <musasabi> but don't care about precicion much +-30secs is the same to me.
15:13:09 <wagle> musasabi: i find an EpochTime in the Posix Time Support library in ghc
15:13:24 <wagle> it does require the IO monad
15:16:50 <musasabi> I use System.Time which should be equally good...
15:17:02 <musasabi> refactoring seems to lessen the problem
15:17:25 <wagle> how do you get ghci to import?
15:19:44 <wagle> being a LAZY programmer, i dont wanna edit a file just to try out System.Posix.EpochTime
15:23:23 <bring> :m
15:30:54 <bring> musasabi: bit of a hack that gives you a infinite lazy list of timestamps:
15:30:58 <bring> ts = liftM2 (:) getClockTime (unsafeInterleaveIO ts)
15:31:05 <bring> timestamps = unsafePerformIO ts
15:31:32 <bring> seems to work in ghc(i) but in hugs it just returns the same time every time
15:32:04 <monotonom> hehehe
15:32:21 <bring> of course it's fargile
15:32:31 <bring> s/fargile/fragile/
15:32:43 <bring> you probably want NOINLINE and such
15:41:41 <musasabi> I'll try to use a functor pattern and generate timestamps at the toplevel...
15:43:31 <wagle> i thought expressions were generally guaranteed to be evaluated once..  why would NOINLINE help?
15:47:08 <stepcut> wagle: -->  :module + System.Time
15:47:17 <stepcut> err
15:47:30 <stepcut> :module + System.Posix.EpochTime
15:47:31 <stepcut> in your case
15:47:56 <bring> stepcut: tomorrow's haskelldb snapshot will finally work with default values and auto_increment
15:48:11 <bring> still no decent wat to get the last insert id though
15:48:17 <bring> s/wat/way/
15:49:06 <stepcut> bring: I have a hack for last_insert_id
15:49:33 <stepcut> bring: one of the examples in the test directory, gets the current time
15:49:42 <bring> ah, yes
15:49:45 <stepcut> you can do something very similar to get the last insert id
15:50:17 <wagle> stepcut: i dont understand your answer  (":module + System.Posix.EpochTime"? i thought the module was System.Posix)
15:50:33 <wagle> what do you mean "+"
15:51:00 <stepcut> wagle: + always you to 'load' more than one module at a time
15:51:18 <stepcut> if you just do :module Module.Name
15:51:39 <stepcut> then you can only access stuff in Prelude or that module
15:51:55 <stepcut> but if you use + you can load a bunch of modules at once 
15:53:22 <stepcut> also, I thought System.Posix.EpochTime was the module name -- I didn't realize that EpochTime was a data type
15:56:05 <wagle> :module System.Posix" seems to do something, but it still doesnt recognize EpochTime
15:56:49 <stepcut> i think EpochTime is in System.Posix.Types
15:56:55 <stepcut> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Posix.Types.html
16:00:23 <bring> stepcut: nasty hack, using haskellDB internals, but it should be possible to hide things like that in a module
16:00:33 <bring> and present a decent interface
16:00:57 <bring> lastInsertId :: Database -> IO Int
16:01:00 <bring> or something
16:01:39 <stepcut> bring: I am sending an email to the haskelldb-users mailing list that includes my current hack
16:01:49 <bring> sweet
16:07:06 <stepcut> done
16:09:53 <reltuk> wow...you know what's dense? The Haskell Report
16:10:30 <stepcut> yeah
16:10:38 <stepcut> not a good intro tutorial
16:14:43 <bring> stepcut: nice hack
16:15:19 <bring> what is the lastinsertid table for?
16:16:25 <bring> oh, and I just realized that BinExpr (OpOther "NOW()") (ConstExpr "") (ConstExpr "") can be written as ConstExpr "NOW()"
16:16:42 <bring> dunno what I was doing when I wrote that
16:17:32 <stepcut> hah
16:18:59 <stepcut> bring: the lastinsertid table is probably not needed. I wrote the LastInsertID module before looking at current_time.hs, so I just put everything I could possibly need in there 
16:19:11 <bring> ah, ok
16:19:41 <bring> hmm, would it actually be enough to just write:
16:19:49 <bring> now :: Expr CalendarTime
16:20:00 <bring> now = Expr (ConstExpr "NOW()")
16:20:16 <bring> then you could use that as an Expr CalendarTime in any query
16:20:35 <stepcut> i think I tried that with the last_insert_id(), and it really seemed like it should work, but I got seg faults in hsql when it tried to read the value out of the field
16:20:52 <bring> strange
16:20:58 <stepcut> actually, let me take that back a bit
16:21:30 <stepcut> sqlnow = (Expr (PrimQuery.ConstExpr "now()"))
16:21:34 <stepcut> I use that all the time
16:21:35 <anduril1> can I do cross compiling with GHC?
16:21:45 <stepcut> 				    B.creation_ts << sqlnow 
16:22:08 <bring> that should work for last_insert_id too
16:22:22 <stepcut> bring: when I tried to do something similar in last_insert_id, that failed very strangely
16:22:56 <bring> I'll try it just to see what happens
16:23:28 <stepcut> the SQL in generated looked fine, but for some reason it would always seg fault or hang  when hsql tried to get the field name out of the results
16:23:36 <stepcut> totally boggled my mind :)
16:25:24 <stepcut> i should try again now that I have a working solution, and see if maybe something else was wrong
16:29:23 <bring> hmm, now I hit an old HSQL bug
16:29:48 <stepcut> oh?
16:30:08 <bring> "The type of def1 field can't be converted to SqlBigInt type"
16:30:22 <stepcut> ah, I had a problem like that
16:30:26 <stepcut> SqlMedInt i think
16:30:36 <bring> I fixed that in HSQL CVS that about a week ago
16:30:54 <bring> seems I don't have that version installed here
16:31:04 <stepcut> I should update then, I probably have not updated since the first haskelldb release
16:31:09 <bring> it works!
16:31:16 <bring> probably a good idea
16:31:22 <stepcut> what worked?
16:31:28 <bring> last_insert_id = Expr (ConstExpr "last_insert_id()")
16:32:11 <stepcut> interesting
16:32:49 <bring> unfortunately haskelldb doesn't seem to like queries without a table, so getting just the last_insert_id doesn't work, I had to get some dummy data too
16:33:05 <stepcut> ah
16:33:18 <bring> I'll look into that
16:33:50 <stepcut> it would be interesting to look into how to call other native functions too, not just last_insert_id
16:34:28 <stepcut> not that I want to be writting lots of SQL in the middle of my haskell code, but...
16:34:29 <bring> I think you could call any function which fits one of the PrimExpr constructors
16:35:17 <stepcut> so far the only things I have needed are now() and last_insert_id(), so hopefully that will be it for a while ;)
16:35:31 <bring> shapr needed ILIKE
16:35:41 <bring> could probably do that the same way
16:36:23 <bring> this stuff makes the code non-portable though
16:37:26 <stepcut> yeah
16:37:44 <stepcut> but is there a good portable way of getting the last_insert_id?
16:38:18 <bring> don't think so
16:38:29 <stepcut> oh, btw, did you know that mysql can be used embedded (like sqlite)
16:39:00 <bring> maybe doing a query to get the max id right after the insert, and wrap them in a transaction?
16:39:21 <stepcut> but not all databases support transactions?
16:39:38 <bring> I've read about using MySQL embedded somewhere, never tried it
16:39:48 <stepcut> i tried it, it works great
16:39:54 <bring> with haskelldb?
16:39:56 <stepcut> but increases your binary size by about 5 megs :)
16:39:57 <stepcut> yeah
16:40:05 <bring> that really nice
16:40:06 <stepcut> its actually pretty easy
16:40:12 <stepcut> I was going to post a howto
16:40:18 <bring> great
16:40:22 <stepcut> its use to hack up, but tricy to do correct
16:40:48 <stepcut> you have to link with different flags (-lmysqld instead of -lmysqclient)
16:40:53 <bring> I think most databases support transactions
16:41:06 <bring> MySQL 4.1 does, if you use the right table type
16:41:24 <stepcut> yeah, transactions are definately more portable than last_insert_id
16:41:52 <bring> then again, auto_increment in itself isn't very portable
16:41:54 <stepcut> in my particular case, I wanted to write a library to talk to bugzilla, which is mysql based, so I am not too worried about portability
16:42:53 <bring> yes, you rarely have the same application running one different databases, I think it's more about avoiding vendor lock-in
16:43:26 <bring> but only having small isolated non-portable things should make porting easy
16:45:23 <stepcut> As for embeddeding mysql, I had to edit my package.conf file and change the linker flags for hsql. But then it always compiled with the mysql server embedded. So, somehow, there needs to be a way to chose the right library to link at compile time
16:50:48 <bring> hmm
16:51:18 <bring> that's a little tricky
16:51:36 <stepcut> yeah
16:52:25 <stepcut> the 'best' I have come up with so far is to have a package 'hsql' and 'hsql-mysql-embedded' and then you can select between the two with -package hsql or -package hsql-mysql-embedded
16:52:30 <stepcut> but its still pretty ugly
16:53:07 <bring> well, I think that's a pretty neat solution
16:53:50 <bring> all it requires is some duplicated entries in package.conf
16:54:06 <bring> beats hand editing it every time
16:54:18 <stepcut> well, I will send an email to the list the weekend with my findings if I get my taxes finished 
16:54:41 <bring> right, april 15:th
16:54:55 <bring> it's not until May 3rd here
16:55:15 <stepcut> i have to do partnership business taxes this year, which are much more complex than personal taxes
16:55:34 <bring> yikes
16:56:26 <stepcut> normally I would hirer someone, but its around $500 to do partnership taxes and our total sales where like $100 ;)
16:56:40 <bring> haha
16:56:58 <bring> and there's a lot of paperwork for $100?
16:57:01 <stepcut> yeah
16:57:03 <bring> oh, that reminds me, I paid income tax in the US last year
16:57:12 <bring> maybe I need to file something
16:57:37 <stepcut> for self employment, you only have to file if you make more than $400, but for a partnership you have to file if you have ANY income/loss
16:57:53 <stepcut> I also have to pay $2 in sales tax that I collected :)
16:58:00 <bring> :)
16:58:17 <bring> what'd you sell?
16:58:22 <bring> hi viblo
16:58:42 <stepcut> music cd's
16:58:59 <stepcut> http://www.theaquapath.com/
16:59:04 <viblo> hi bring
16:59:28 <bring> viblo: did your house move a couple of hours ago?
16:59:48 <viblo> move?
17:00:09 <bring> mine did
17:00:22 <bring> for a few seconds
17:01:02 <viblo> oh
17:01:56 <viblo> I was out in the laundry room a while.. so I might have missed it ;)
17:02:56 <bring> stepcut: like your music
17:03:14 <stepcut> thanks!
17:03:23 <stepcut> i like your database interface :)
17:03:27 <bring> :)
17:03:58 <bring> hope you didn't steal yours from Daan Leijen
17:04:35 <stepcut> haha
17:12:14 <bring> off to bed
17:14:32 * themaximus moos a moo of satisfactuib
17:15:01 <reltuk> is there a regex library for haskell?
17:15:03 <themaximus> *satisfaction
17:15:10 <stepcut> reltuk: yes
17:15:25 <themaximus> :| missed lemmih :-(
17:15:41 <stepcut> Text.Regex
17:15:44 <stepcut> Text.Regex.Posix
17:15:57 <stepcut> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
17:16:29 <reltuk> how perl-like are egrep regexes?
17:16:42 <stepcut> beats me
17:17:19 <reltuk> me too...wiki mentions pcre in hsregex...but the links dead
19:03:32 <Riastradh> Oooo.  One of the guys who bought my HM t-shirt is on the ICFP contest organization team.
19:19:42 <Taaus> The "What part of TYPES..." t-shirt?
19:20:12 <Riastradh> No, the 'gerbil frog garble garble munge-it' shirt.
19:20:38 <Taaus> Wait a minute... You're being sarcastic, aintcha? ;)
19:21:12 <Smerdyakov> I don't see why you'd call that an "HM t-shirt," anyway.
19:22:04 <Riastradh> Which one? -- the 'WHAT PART OF  <the HM type algorithm, whatever it's called> DON'T YOU UNDERSTAND?' t-shirt or the 'gerbil frog garble garble munge-it' t-shirt?
19:51:22 <wagle> whats the "HM" algorithm?
19:51:44 <Riastradh> Hindley-Milner.  It's how Haskell & ML infer types.
19:52:38 <wagle> yeah, darn, just got that
19:53:31 <Jerub> I should really look that up. :)
19:53:58 <Riastradh> Just read the back of the t-shirt!
19:57:09 <lewis_m> might seem like a silly question, but can haskell be compiled or something? so that I can let somebody try some code I've written without letting them see it?
19:57:31 <skew> you can use the ghc
19:57:39 <skew> what are you using now?
19:58:32 <skew> but honestly, we're talking Haskell here. How much would most people get out of the source :)
19:59:00 <lewis_m> skew: well yeah, I just wanna show off my working assignment to another student :)
19:59:20 <lewis_m> skew: I'm just using hugs right now
19:59:28 <skew> Yeah, if it's for a class
19:59:33 <skew> build with ghc
19:59:38 <lewis_m> cool
19:59:55 <skew> I like ghci better than hugs for an interpreter anyway
20:00:09 <lewis_m> i'll give it a whirl then :)
20:00:44 <wagle> there are a few minor diffs between hugs' haskell and ghc's haskell
20:01:45 <skew> the most important thing for interactive use is that ghci accepts the full statement syntax
20:02:19 <skew> you can't make types or anything, but you can do let tempfun = <stuff>, or x <- getChar, or something like that and have it for the rest of the session
20:03:29 <skew> defining new data types would be full support for declarations, which just might happen if somebody does the work so TH could use a splice in the file it was defined
20:04:28 <wagle> why doesnt th allow splices there?
20:04:59 <skew> the problem is you would need to have the definition of the stuff you use in the splice compiled to executable code before even typechecking the splice site
20:05:16 <skew> the granularity of compilation would have to get a lot finer than it is now
20:05:47 <skew> which is why I have this idea it might contribute to ghci letting you define classes on the fly and such
22:01:24 <anduril1> I have a list of ordered pairs (dots in a grid like Conway's life or n-queens) and I want to make a string representation . . . any suggestions?
22:04:41 <Jerub> anduril1: suggestions on how to write the function?
22:04:46 <anduril1> yeah
22:04:56 <anduril1> I can't seem to find a non ugly solution
22:05:16 <anduril1> I wonder if there is some elegant shortcut I'm missing
22:08:38 <skew> anduril1, what sort of string are you trying to make?
22:09:27 <anduril1> like a picture, for queens, it'd be the board with spaces for the empty squares and Qs where the queens are
22:09:45 <skew> try array
22:12:08 <skew> like accumArray (\ a b -> b) empytCell ((0,0),(8,8)) (zip queens (repeat Queen))
22:13:05 <skew> the something like [[board!(x,y) | x <- [0..8]] | y <- [0..8]]
22:14:40 <skew> well, stick characters in the array I guess
22:15:15 <anduril1> yeah
22:15:23 <anduril1> is there a map that works on arrays?
22:15:49 <skew> marray has one
22:15:58 <anduril1> I guess it implements Functor, so I can use that
22:16:49 <skew> oh, right fmap
22:17:40 <skew> sometimes I think we should just drop map
22:40:12 <anduril1> skew: that worked very well, thanks
23:06:34 <Cale> yeah, wouldn't it work the same if we renamed fmap to map?
23:09:16 <reltuk> to create a thunk does haskell really copy the entire environment for each binding?
23:09:38 <reltuk> (I ask because that's how I recently implemented a lazy functional language for a class I'm in)
23:16:11 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
23:16:55 <Cale> I'm not sure, but that paper probably says.
23:21:58 <reltuk> wow, that paper is *hard core*
23:42:39 <reltuk> this is pretty neat...thanks for the link :)
23:42:49 <Cale> no problem
23:59:39 <musasabi> How much overhead do IORefs incur? i.e. is "data DList a = (IORef (Dlist a), IORef (Dlist a), a)" sensible and how much overhead does it incur? Or should I just use FFI?
