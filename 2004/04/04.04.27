00:22:54 <Pseudonym> Nytol.
01:43:21 <skew> Can anyone tell why this code "main = forever (return () >> main)" runs fine, while "main = forever (return () >> a); a = forever (return () >> main)" quickly exhausts the stack?
01:43:32 <skew> (where forever = fix . (>>))
01:54:28 <earthy> skew: the introduction of that a introduces thunks on the stack
01:54:47 <earthy> that you don't have with the first formulation
01:59:46 <skew> I don't see the difference
02:00:11 <skew> you might get one thunk for a, but that should be evaluated
02:00:40 <skew> and then you shouldn't need to introduce any more thunks
02:01:18 <earthy> ah, but the garbage doesn't get collected in time.
02:02:05 <skew> no, once the thunk for a is entered the first time it should be replaced by an indirection to the actuall code
02:02:19 <skew> I don't understand the stack usage
02:02:44 * earthy thinks
02:02:50 <skew> I understand the heap usage pretty well, and the interaction with laziness
02:03:00 <skew> but I don't know what Haskell uses the stack for
02:03:35 <skew> I sort of thought is used heap allocated stack frames, garbage collected like everything else
02:04:19 <skew> possibly with some cleverness to allow garbage collecting between exception handlers and the execution point
02:04:53 <skew> heap is consumed when entering a thunk?
02:07:41 <skew> oh, exception handlers do seem to control exceptions only during the evaluation of the body
02:07:55 <skew> and not exceptions raised later by lazy values returned
02:08:44 <skew> the latter would amount to full continuations, more or less
02:09:22 <skew> why doesn't main = forever (return () >> main) consume stack?
02:10:59 <Jerub> skew: because its tail recursive..
02:11:37 <skew> then why does a pair of functional making tail calls to the other consume stack?
02:11:51 <skew> I'm not sure that's a tail call anyways
02:11:56 <skew> with forever = fix . (>>)
02:12:36 <skew> main = forever (return() >> a); a = forever (return() >> main)
02:12:42 <skew> quickly exhausts the stack
02:15:55 <skew> I'm away for a while, but feel free to pile up answers in my buffer
03:37:30 * shapr yawns
03:37:45 <shapr> good morning #haskell!
03:40:11 <shapr> Heffalump: hiya, what's up?
03:46:32 <Heffalump> 'lo
03:53:14 <liiwi> yo
03:59:51 * Spark blinks
03:59:54 * Spark goes back to wrok
04:00:47 <Jerub> @yow
04:00:47 <lambdabot> Four thousand different MAGNATES, MOGULS & NABOBS are romping in my
04:00:47 <lambdabot>  gothic solarium!!
04:03:52 <Spark> cool
06:33:25 <tmoertel> shapr, you in?
06:33:52 <shapr> yes!
06:34:02 <tmoertel> I have a HaskellDB Q for you.
06:34:09 <shapr> yes!
06:34:25 <tmoertel> I just installed it and I'm trying it out for the first time.
06:35:14 <tmoertel> I created a small database in SQLite, ran DBDirect to generate a Tables.hs, and then loaded Tables into GHCi.
06:35:38 <tmoertel> The problem is, GHCi complains that Data constructor not in scope: `Tables'
06:35:44 <tmoertel> Ever see that before?
06:36:13 <shapr> tried :set -package haskelldb ?
06:36:20 <tmoertel> Yup.
06:37:04 <shapr> hm
06:37:30 <shapr> first, Tables might be a reserved word
06:37:34 <shapr> bring: is it?
06:37:48 <tmoertel> I've tried other names, too.
06:38:07 <shapr> bring and viblo are the HaskellDB devs who are online right now
06:38:14 <shapr> there's #haskelldb also
06:38:47 <shapr> have you tried it with other than  sqllite?
06:39:01 <tmoertel> No, I haven't.
06:39:56 <shapr> have you tried the HaskellDB tutorial?
06:40:11 <shapr> I only tested it with postgres so far
06:40:41 <tmoertel> Maybe DBDirect isn't quite working for SQLite yet.
06:41:03 <tmoertel> (Or maybe I screwed up HaskellDB when I packaged it.)
06:41:05 <shapr> I think it does work, but is limited to strings or something
06:41:20 <tmoertel> That was my understanding, too.
06:41:36 <shapr> afaiu, sqllite is dynamically typed, and all fields are string internally
06:42:03 <tmoertel> That's certainly the way the tables that DBDirect look, too. Every field is a String.
06:42:09 <shapr> can I see your code?
06:42:23 <tmoertel> Sure. Hold on, let me post it...
06:42:28 <shapr> ok
06:42:33 <eivuokko> Maybe you gave dbdirect filename with capital letters, I think I had some prob that way.
06:42:50 * tmoertel tries lowercase only name ...
06:42:56 <eivuokko> Well, the first letter being capital.
06:44:01 <shapr> eivuokko: oh, a new bug? I wanna hear
06:44:30 <eivuokko> shapr, I just recall I had problem, but I don't remember as I had the other problem.
06:45:11 <tmoertel> Lowercase name didn't work, either.
06:45:55 <eivuokko> Ah, ok.  Maybe I recall correctly or mixed up problems.
06:46:40 <shapr> eivuokko: did you get it working on win32?
06:48:16 <shapr> tmoertel: have you tried any of the test code that comes with hdb?
06:48:33 <eivuokko> Well, yes.  It compiles, but now I got some wierd problem with ODBC.  Will tackle that in a couple of days.
06:48:39 <tmoertel> No, not yet. I wanted to use SQLite, so I created a simple db first. I'll strat a full debugging round now.
06:49:04 <shapr> I'd like to try SQLite as well
06:49:04 <tmoertel> One of my servers isn't responding.  :(
06:49:12 * tmoertel must go fix the server
06:49:21 <shapr> just for a portable version of curryspondence
06:49:24 <tmoertel> bbl
06:49:26 <shapr> ok
06:50:00 <shapr> I wonder if curryspondence would be too slow that way
07:29:08 * shapr boings
07:29:25 <tmoertel> shapr, it /was/ capitalization.
07:30:07 <shapr> ah, neat
07:30:44 <tmoertel> turns out, I was being foolish and passed a capped name in as the "file" parameter to DBDirect.
07:38:41 * tmoertel must restart . ..
09:08:18 <fier> hi
09:08:44 <ski> hi fier
09:09:38 <ski> had any question ?
09:10:28 <fier> Can i do "logic" programming in Haskell? Yesterday, you told me it "can be emulated"...
09:10:50 <fier> Or not You but someone here...
09:10:57 <ski> yeah :)
09:11:37 <ski> well, the (don't know) nondeterminism can be emulated quite easily
09:11:45 <ski> e.g. with lists
09:12:01 <fier> Really? So any Prolog program, rewritten with Haskell sytnax & stuff will run?
09:12:26 <ski> the "logic-variable" part is harder to emulate, though
09:13:38 <ski> se e.g. "Typed Logical Variables in Haskell" at http://www.cs.chalmers.se/~peb/papper.html
09:14:26 <fier> ski: Okay. Cheers!
09:14:50 <ski> or do you want some concrete example ?
09:15:15 <fier> ski: Well, if there is one, that would be Great.
09:15:52 <ski> hmm, well, it also depends a bit which modes of the predicate you want
09:16:30 <ski> s/bit/bit on/
09:16:58 <fier> Modes?
09:17:16 <fier> Like f(0, 1).
09:17:21 <fier> f(1, 1).
09:17:30 <ski> yeah, which arguments are input, and which are output, of the call to the predicate
09:18:26 <ski> that predicate could have four modes
09:18:43 <fier> f(N, F) :- N > 1, N1 is N-1, N2 is N-2, f(N1, F1), f(N2, F2), F is F1+F2.
09:19:00 <ski> ok
09:19:38 <fier> This is Fibonacci series with binary recursion.
09:19:40 <ski> then (because of the unidirectionality of 'is' in Prolog) the first argument of f/2 must be present
09:19:44 <ski> yah
09:20:10 <ski> but then f(+,-) is deterministic
09:20:50 <ski> so perhaps it's a bad example of nondeterminism
09:20:57 <fier> :-)
09:21:08 <ski> what about ancestor/2 ?
09:21:18 <ski> ancestor(Person,Person).
09:21:18 <fier> :-/
09:21:55 <ski> ancestor(Ancestor,Person) :- parent(Parent,Person),ancestor(Ancestor,Parent).
09:22:26 <ski> in e.g. mode ancestor(-,+) (nondeterministic)
09:22:51 <ski> (assuming nondet parent(-,+) exists)
09:23:02 <fier> And how is it in Haskell?
09:23:22 <ski> this mode could be modelled with a function of type  Person -> [Person]
09:24:46 <ski> ancestor aPerson = [aPerson] ++ [anAncestor | aParent <- parent aPerson, anAncestor <- ancestor aParent]
09:25:45 <ski> (assuming parent :: Person -> [Person])
09:26:35 <ski> if we instead only had the parent(-,-) mode of person, with type [(Person,Person)]  (basically a list of all facts)
09:26:47 <ski> then we could write ancestor above as
09:28:02 <ski> ancestor aPerson = [aPerson] ++ [anAncestor | (aParent,yetAPerson) <- parent, aPerson == yetAPerson, anAncestor <- ancestor aParent]
09:29:14 <ski> (haskell doesn't support matching againt an already bound variable, in a pattern, so we need to have an explicit equality check instead)
09:29:26 <ski> (s/againt/against/)
09:29:54 <ski> see the difference ?
09:30:50 <fier> Well yes.
09:31:10 <fier> I see it, but it may take a while till i understand it :-(
09:31:18 <fier> :-)
09:31:23 <ski> heh
09:31:39 <fier> But its cool. Then i will continue learning Haskell, and not change to Prolog.
09:32:37 <ski> learn both, I'd say :)
09:33:30 <ski> (or, at least, learn some logic/relational programming language)
09:35:55 <fier> What else is there, other than Mercury...
09:36:24 <ski> hmm
09:36:44 <ski> well, there's a lot of Prolog variants
09:36:55 <andersca> hey ski
09:36:58 <ski> and there's LambdaProlog and Lolli and such
09:37:07 <ski> andersca : hi
09:37:22 <ski> and Oz
09:38:05 <ski> and if you're interested in mixes of Functional and Logic styles, then you might have a look at Goedel and Escher and Curry
09:39:45 <fier> ski: :-) Well, I am interested in pure languages, be functional or logic.
09:39:52 <ski> ok :)
09:40:41 <ski> (hmm, Erlang also has some "left-over" features from Logic programming, e'en though it's not a logic programming language)
09:41:27 <ski> (such as non-linear patterns and multiple-binding sites)
09:42:27 <fier> But it seems logic cannot be pure.
09:42:29 <ski> anyway, in the paper above, they implement/emulate logic-variables in haskell
09:42:35 <ski> why not ?
09:43:26 <fier> I/O, is there logic I/O?
09:43:31 <ski> yes
09:43:35 <ski> in e.g. Mercury
09:44:02 <ski> (through uniqueness/linearity)
09:44:18 <ski> (quite similar to Clean's approach)
09:44:49 <ski> also, there's been stream-based approaches, i think
10:02:38 * esap blinks.
10:03:13 * fier catches fire
10:03:44 * ski types at keyboard
10:03:58 <esap> what's up?
10:04:09 <ski> i dunno
10:05:57 * esap has been thinking about references and referential transparency and OOD etc.
10:06:10 <ski> mhmm
10:06:54 <ski> anythoughts to tell ?
10:07:30 <esap> I think there is a connection between the concept of "reference" in programming and a concept of "role" in OOD
10:08:17 <ski> so, what's "role" ? :)
10:09:09 <esap> In UML class diagrams, you have classes and associations. A role is what you put at each end of an association. There is a paper on that, hold on, I'll find a link.
10:11:23 <fier> OOD?
10:11:30 <esap> Object-oriented-design
10:11:37 <ski> Object-Oriented-design, i presume
10:11:38 <fier> Object Oriented Design?
10:11:51 <fier> (oh, this f*ing lag :-(
10:12:03 <ski> 'lag' ?
10:12:31 <esap> http://citeseer.ist.psu.edu/291670.html
10:12:35 <fier> I have a pretty fast connection, but frenode always lags...
10:12:43 <ski> mhmm
10:12:46 <ski> esap : thanks
10:14:39 <ski> hmm, bbiab
10:26:32 * ski wonders whether 'Conceptual Modelling' is any related to Spark's 'Empirical Modelling'
10:27:07 <esap> what's this empirical modelling?
10:27:36 <ski> Spark : are you there ?
10:27:40 <ski> :)
10:29:01 <esap> conceptual modelling is the basis for OOA, to some extent at least.
10:29:39 <ski> mhmm
10:31:28 <ski> (this seems to be related to knowledge representation (which i don't know much about), right ?)
10:32:23 <esap> Well there are some connections, since knowledge representation uses conceptual modelling as basis as well...
10:33:02 <ski> ok
10:33:34 <esap> But at least I see conceptual modelling as independent thing.
10:34:04 <ski> mhmm
10:34:19 <ski> (just thinking about what i'm reading ..)
10:36:32 <esap> Conceptual modelling is a specific way of modelling that focuses on the identity and relationships between concepts.
10:37:01 <ski> as opposed to which other kinds of modelling ?
10:37:27 <esap> like use case-based analysis
10:38:51 <ski> like CASE ??
10:38:56 <esap> The idea of conceptual modelling is that you start from your requirements, then identify nouns, and then analyze relationships between them.
10:39:53 <esap> In the sense, you identify "things" and try to distinguish them from "relationship" and "roles".
10:40:02 <ski> mhmm
10:41:08 <esap> Then as a result, you get a model of how you should think about the world that the requirements talked about.
10:41:56 <esap> basically, the result is an UML class diagram [or ER-diagram].
10:42:03 <ski> ok
10:43:55 <jak> aha. Just openzaurus-sa was the key
10:44:47 <jak> So you can run oe on an ipod?
10:45:07 <ski> jak : worng channel ?
10:45:17 <jak> ski: thanks!
10:46:52 <bring> tmoertel: did you get get haskelldb problem sorted out?
10:47:13 <tmoertel> bring, yes. it was a capitalization issue, after all
10:47:38 <tmoertel> bring, are you one of the haskelldb developers?
10:47:42 <bring> yes
10:48:08 <tmoertel> if you're interested in HaskellDB RPMs for Fedora, I have built some
10:49:56 <bring> nice
10:50:05 <tmoertel> they're here: http://community.moertel.com/ss/space/RPMs
10:50:18 <bring> you should talk to forester when he comes online, he's been looking at RPMs for us
10:50:35 <bring> he's also a haskelldb developer
10:51:06 <bring> I'll give him the link
10:51:29 <tmoertel> great. i'll be happy to provide any help i can
10:51:40 <bring> was the capitalization issue something that dbdirect could do better?
10:52:29 <tmoertel> it's mainly a documentation issue w/ DBDirect
10:53:30 <tmoertel> if you pass in a name that is capitalized, it is used as is, and that makes the extruded code look to Haskell like a type or constructor, when it isn't
10:54:22 <tmoertel> e.g., the code generated by "DBDirect SQLite mytable ignored mytable" is fine
10:54:37 <tmoertel> but the code generated by "DBDirect SQLite mytable ignored Mytable" will not compile
10:55:59 * tmoertel moves thread to #haskelldb
10:57:30 <jadrian> hello
10:57:42 <ski> hi jadrian
10:57:50 <jadrian> hi ski
10:58:57 <jadrian> question
10:59:10 <jadrian> suppose you got some datatype
10:59:26 <jadrian> data Foo = A | B
10:59:38 <jadrian> which is exported in some module
10:59:55 <jadrian> and you'd like to extend it in some other module where you import it, to
10:59:57 <ski> ok
11:00:05 <jadrian> data Foo = A | B | C
11:00:17 <jadrian> this cannot be done directly right?
11:00:22 <ski> you don't extend datatypes in haskell
11:00:37 <ski> you could try with a type class, though
11:00:46 <jadrian> and the obvious solution is to use yet another type constructor...
11:00:51 <jadrian> something like ...
11:01:20 <jadrian> data Foo2 = AB Foo | C
11:01:43 <jadrian> hmmm how does a typeclass helps?
11:01:52 <ski> yeah, that could also be a way
11:02:05 <ski> class Foo a where { ... }
11:02:14 <ski> instance Foo A where { ... }
11:02:17 <ski> instance Foo B where { ... }
11:02:22 <jadrian> (I've been working on systems with subtyping a lot... so this things keep getting in my way)
11:02:24 <ski> and then, in another module
11:02:27 <ski> instance Foo C where { ... }
11:03:23 <jadrian> hmmm those are completely diferent beasts...
11:03:24 <ski> so type classes could be used a bit similar to abstract base classes/interfaces
11:03:50 <jadrian> not sure if that can solve it...
11:04:01 <jadrian> nah...
11:04:11 <jadrian> no way...
11:04:23 <ski> it doesn't help ?
11:04:27 <jadrian> nope
11:04:36 <jadrian> I can have stuff like
11:04:55 <jadrian> Foo D = Atom D | [Foo D] :=>: D
11:05:04 <jadrian> now I want to extend it...
11:05:18 <jadrian> no way I can use your approch there... 
11:05:30 <jadrian> and even in simple cases I have my doubts
11:05:49 <ski> hmm, why can't you use type classes ?
11:05:55 <jadrian> I just wanted to keep my approach very modular and extend datatypes as I need
11:06:07 <jadrian> how?
11:07:02 <jadrian> so I'd have a type, Atom D that would be an instance of a Foo class
11:07:07 <jadrian> what abou the other one?
11:07:12 <ski> defining a type class for Foo, and make the alternatives/variants into instances of that
11:07:19 <ski> what's D ?
11:07:23 <ski> a type variable ?
11:07:27 <jadrian> yeap
11:07:30 <jadrian> opss
11:07:32 <jadrian> d
11:07:35 <jadrian> :)
11:07:48 <jadrian> Foo d = Atom d | [Foo d] :=>: d
11:07:50 <jadrian> :)
11:08:25 <ski> what operations do you want on these variants ?  ("methods")
11:09:16 <jadrian> many ;)
11:10:13 <jadrian> but it doesn't even make sense to split it in two types with instances of a Foo class
11:10:21 <jadrian> notice the recursivity in the definition
11:10:40 <ski> (i mean ones that have different implementations for the different variants)
11:10:41 <ski> hmm
11:10:56 * ski thinks that could probably be solved with existential types
11:11:12 <jadrian> I'll check it out...
11:11:29 <ski> class Foo foo where { ... }
11:11:48 <ski> newtype AtomFoo d = MkAtomFoo d
11:11:58 <ski> instance Foo AtomFoo where { ... }
11:12:03 <ski> hmm
11:12:29 <ski> do you want those Foo's in that list to be of possible different variants (heterogenous list)
11:12:34 <ski> (prolly yes to that)
11:12:40 <jadrian> of course ;)
11:13:01 <jadrian> brb
11:13:58 <ski> data ArrowFoo d = [SomeFoo d] :=>: d
11:14:25 <ski> data SomeFoo d = forall Foo foo => MkSomeFoo (foo d)
11:14:40 <ski> instance Foo ArrowFoo where { ... }
11:14:44 <ski> and prolly
11:14:50 <ski> instance Foo SomeFoo where { ... }
11:32:46 <_zZzZz> Hiya
11:32:55 <jadrian> back
11:32:58 <jadrian> hi ski sorry
11:32:59 <ski> hello _zZzZz
11:33:08 <ski> wb jadrian
11:33:18 <jadrian> well... not sure...
11:33:19 <_zZzZz> Heya ski, I was redirected here from that Haskell webpage
11:33:30 <ski> _zZzZz : ok ..
11:33:34 <_zZzZz> just working on an assignment, need some help understanding some of the parts, if anybody is available
11:33:36 <jadrian> may end up more complicated than simpy adding another value contructor
11:34:09 <ski> jadrian : i'm not sure about how much more conceptual complication there would be ..
11:34:21 <ski> _zZzZz : we could try, i guess :)
11:34:43 <_zZzZz> hehe, that's much appreciated, let me get some things written down, so perhaps one of you wise ones can enlighten me :)
11:34:56 * ski smiles
11:35:26 <Marvin--> _zZzZz: http://www.haskell.org/hawiki/HaskellIrcPastePage is useful
11:36:20 <_zZzZz> that's ingenious! great thanks
11:37:03 <_zZzZz> I don't know if any of you know the program called "lp2fp" from the York university in UK
11:37:16 <_zZzZz> it's a program that transforms Prolog code into Haskell fp code
11:37:19 <ski> not me
11:37:21 <ski> ok
11:38:10 <_zZzZz> that's mainly what my work will be subjected to, let me try and find you guys a link, if any of you do Prolog coding
11:38:23 <_zZzZz> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/lp2fp.tar.gz
11:38:42 <jadrian> ski: but it might be worth a shot... thanks...
11:38:43 <_zZzZz> it's completely written in haskell
11:38:44 <ski> yah, found it
11:39:14 <_zZzZz> my main question is, if you look at some of the sample .in files, which are in prolog
11:39:25 <_zZzZz> notice how the ";" doesn't serve its usual purpose
11:39:33 <_zZzZz> ; is for "or" in Prolog
11:39:51 <_zZzZz> and in this case, it's used in parameters to differentiate the returning values
11:40:17 <_zZzZz> as in haskell, would be for example, Int -> Int -> Bool
11:40:36 <_zZzZz> this program forces the use of Prolog code as: (integer1, integer2; bool)
11:40:44 <ski> jadrian : perhaps http://onestepback.org/articles/poly/ might be interesting, they have a haskell example
11:41:45 <ski> _zZzZz : hmm
11:42:03 <ski> must (integer1, integer2; bool) be deterministic ?
11:42:22 <_zZzZz> yessir, in this case, whatever comes after the ; means it's the returning value
11:42:40 <_zZzZz> could also be, (a, b, c ;d,e,f) d,e,f would be returning values
11:43:13 <_zZzZz> but then comes the question, what was the "OR" in prolog (;), is now used for values differentiations, so what is now the "or" value
11:43:15 <ski> but it couldn't be semidet. or nondet. or multidet., then ?
11:43:18 <_zZzZz> when doing a simple if else then
11:43:32 <_zZzZz> I wouldn't know, not quite sure
11:43:40 <_zZzZz> just troubled by the code, as it's very dence Haskell programming
11:43:44 <_zZzZz> dense, even
11:44:12 <_zZzZz> just thought perhaps someone could look at it, it's proven to be working, as a good translator from prolog to Haskell
11:44:51 <_zZzZz> but I have no idea what the program looks for, when replacing the usual then (->) and else (;) commands
11:44:57 <_zZzZz> as they are already taken for other purposes
11:45:14 <ski> jadrian : actually, i was thinking of http://www.angelfire.com/tx4/cus/shapes/
11:45:48 <ski> hmm
11:46:42 <_zZzZz> yep, it's not your everyday question/answer, I know :(
11:47:03 <ski> lemme download it and check it a little ..
11:47:04 <_zZzZz> I've been on this for the last 24hrs, since it's an assignment, and this would be my last week of school
11:47:13 <jadrian> ski: yeap, I've seen it elsewhere, that or similar, and I've used that style before...
11:47:16 <_zZzZz> thanks ski, appreciate it
11:47:38 <jadrian> ski: but not with recursive datatypes...
11:47:48 <_zZzZz> please don't hesitate to pm me, if you need help running it, it should be a simple "runhugs Main.hs <file.in"
11:47:59 <Marvin--> hrm
11:48:11 <Marvin--> I compiled it with ghc and it fails
11:48:16 <Marvin--> Fail: ./Basic.hs:81: Non-exhaustive patterns in function cross
11:48:39 <_zZzZz> works here, I used hugs
11:48:47 <Marvin--> same for runhugs (though different error message)
11:48:52 <Marvin--> I used samples.in
11:49:04 <_zZzZz> yep, try "runhugs Main.hs <samples.in"
11:49:07 <ski> jadrian : you can use a list of ExistentialShape/SomeFoo as i showed
11:49:17 <_zZzZz> Marvin--: that should display you the Haskell coding for it
11:49:19 <Marvin--> _zZzZz: that's what I did
11:49:25 <_zZzZz> no luck?
11:49:29 <jadrian> ski: yeap
11:49:31 <Marvin--> $ runhugs Main.hs < samples.in
11:49:31 <Marvin-->  
11:49:31 <Marvin--> Program error: pattern match failure: cross []
11:49:42 <Marvin--> sort.in and standard.in work, though
11:49:49 <ski> _zZzZz : Program error: {cross []}runhugs: Error occurred
11:50:01 <_zZzZz> samples has a lot of coding, try 1-2 functions per .in file
11:50:21 <_zZzZz> C:\HUGS98>runhugs Main.hs <quick.in
11:50:22 <_zZzZz> works for me
11:50:28 <_zZzZz> that should be the quicksort function
11:51:02 <_zZzZz> but as you can see in sample.in, no clue if some of you have done Prolog before, that's my  special more than anything, as I'm trying to learn haskell, but there doesn't seem to be any cases of "if else then"
11:51:24 <_zZzZz> and the else (;) is used in the parameter differentiations, if you look closely in the parameters
11:51:24 <Marvin--> yeah I've done Prolog before
11:51:48 <_zZzZz> usually, in Prolog, if else then is , A > B -> Z is A ; Z is B.
11:52:03 <_zZzZz> but you can't use any of those commands, in this translator
11:52:13 <_zZzZz> and I find that very odd, since the ";" has been used already
11:52:31 <Marvin--> are you asking us why lp2fp does what it does? :)
11:53:07 <_zZzZz> somewhat :( was hoping one of you could look into the coding of that Haskell translator, and perhaps find the parts that needed to be changed, so that it would actually convert REAL prolog into haskell
11:53:36 <ski> like converting if-then-else ?
11:53:48 <_zZzZz> precisely, yep ;(
11:54:33 <_zZzZz> Prolog is not extremely different from Haskell, but Haskell can do much more (in its own ways), and this is what I'm trying to learn, but this translator doesn't seem to do the job, unless there are multiple versions of Prolog, and the one I know for if-else-then is not the one the coder of this translator based himself on to make it
11:54:48 <Marvin--> well, at least you can use cuts to get guards
11:55:20 <_zZzZz> what do you mean Marvin--?
11:55:33 <Marvin--> _zZzZz: look at quick.in and the corresponding haskell code
11:55:36 <ski> see e.g. quick.in
11:56:11 <_zZzZz> ok I see what you mean
11:56:22 <_zZzZz> I'm canadian, might explain why I'm struggling in English :)
11:56:39 <_zZzZz> programming language is somewhat universal though, I guess that's how we can manage to understand each other :)
11:58:09 <_zZzZz> alright, well, what do you suggest I do in this case? use !, to simulate then's and else's?
12:00:15 <Marvin--> but, hm...
12:00:46 <Marvin--> the ";" are all inside the argument lists to other predicates
12:01:08 <Marvin--> what happens if you use an ";" outside an argument list?
12:01:42 <ski> like "p_q(A) :- ( p(A) ; q(A) )."
12:05:46 <_zZzZz> I've tried, no luck, would give me a stupid parsing error
12:06:12 <_zZzZz> I strongly believe the coder has replaced common -> and ; commands with other commands, as he used the ; for argument listing
12:06:49 <_zZzZz> I've emailed him back, but since he lives in the .UK, he should not get back to me before tomorrow morning, and in the meantime my assignment is pending
12:07:04 <_zZzZz> hence why I decide to give you online genious's a try :)
12:07:41 <_zZzZz> and the program requires a ";" to be put in the argument listing, whether it returns a value or not
12:07:50 <Marvin--> what strikes me here is that you aren't writing prolog code for this, you're writing haskell code but with prolog-like syntax
12:08:27 <_zZzZz> exactly, I first thought there was multiple variations of Prolog, and the one I learned was just one of many types
12:08:47 <Marvin--> I'm not a prolog wizard so I have serious problems with cuts ;) but I'm not quite sure that mapping cuts like that directly to guards is always correct
12:09:23 <Marvin--> it seems to me more like someone tried to find prolog concepts that matched haskell concepts rather than the other way around
12:09:35 <Marvin--> can you even run these prolog programs in a normal prolog interpreter?
12:09:56 <_zZzZz> all of his .in files don't compile in Sicstus (ie)
12:10:07 <_zZzZz> obviously linked to those ";" misusage
12:10:41 <_zZzZz> I know this much, in Haskell the type definition is very important, this might explain why he forced the usage of ; in his Prolog programs, to ease his coding of this translator
12:11:32 <keverets> is there an easy way to translate an arithmetic sequence from a string, say "[1..3]" into a [Integer] (in this case: [1,2,3])?
12:12:00 <keverets> I can use read directly for "[1,2,3]", but would like it to accept these sequences as well.
12:12:29 <Cale> I ended up writing a parser that does that.
12:12:38 <Marvin--> _zZzZz: if you're interested in relations between prolog and haskell, have a look at Curry
12:12:39 <Igloo> You'd need to extract the begin and end and then do [begin..end]
12:12:43 <keverets> I'm trying to avoid that, if it's not necessary.
12:12:59 <keverets> Igloo: hmm... might be a workable shortcut.
12:13:03 <_zZzZz> Marvin--: think it can help me translate/convert some of my Prolog coding into Haskell?
12:13:12 <Cale> http://vx.hn.org/autoshare/count.hs
12:13:13 <ski> _zZzZz : itym *mode* information, not type information
12:13:14 <Marvin--> _zZzZz: maybe :) I don't know much about it
12:13:37 <_zZzZz> Marvin--: got a link available?
12:13:45 <Cale> it's not terribly polished, and it has some extra stuff in it that you don't need or want, but it should give you something
12:13:56 <keverets> Cale: cool.  Thanks.
12:14:29 <Marvin--> _zZzZz: no, but google for "curry language" or something like that
12:14:41 <_zZzZz> Great, I'll definately look into it, I'll idle here as I have to leave for a class, but will definately need some more help along the way later on :) thanks Marv and ski, that was greatly appreciated help
12:14:42 <_zZzZz> :)
12:15:04 <Cale> in particular, you'll want to get rid of the colon notation that I have for specifying a padding width there
12:15:44 <ski> http://www.informatik.uni-kiel.de/~mh/curry/
12:15:57 <Marvin--> some of the stuff this lp2fp compiler generates is weird
12:16:07 <ski> like ?
12:16:31 <Marvin--> look at pal.in
12:17:00 <Marvin--> the type of the pal function is Eq a => [a] -> [()]  instead of -> Bool
12:17:06 <ski> ah
12:17:19 * ski wondered if it would do things like that
12:17:29 <Marvin--> whereas a simple  foo(X;).  gives  foo x = True
12:17:58 <_zZzZz> yep, I've noticed that as well
12:18:05 <ski> hmm
12:18:18 <ski> maybe it thinks it might be nondet/multi ?
12:18:54 <Marvin--> seems like it
12:19:10 <_zZzZz> speaking of which, I wanted to ask, I know in Prolog I can write _ to simulate "*" so-to-speak, what would be the similar command in Haskell?
12:19:36 <ski> "*" ?
12:19:43 <Marvin--> the wildcard pattern exists in Haskell too, if that's what you mean
12:19:44 <ski> what's that ?
12:19:46 <Marvin--> foo _ = True
12:19:58 <_zZzZz> so it would be _ ?
12:20:07 <ski> bar ((_,y):xys) = ...
12:20:14 <Marvin--> I don't quite understand what you mean, so I'm guessing :)
12:20:19 <ski> but not  baz x = _
12:20:23 <Marvin--> what do you mean 'simulate "*"'
12:20:24 <_zZzZz> say I have nbrAccount (Account number _ _) = number
12:20:39 <Marvin--> that's perfectly fine
12:20:50 <_zZzZz> how can I retrieve number, without having to specify values to those 2 _'s
12:20:52 <Marvin--> and in haskell it's called wildcard patterns
12:20:56 <Marvin--> ooh
12:21:04 <_zZzZz> is what I meant :)
12:21:13 <Marvin--> well
12:21:21 <Marvin--> you can pass in a polymorphic value
12:21:22 <_zZzZz> when I put _, it obviously says _ is undefined
12:21:30 <ski> you could pass bottom or undefined or some error
12:21:31 <Marvin--> nbrAccount (Account 42 undefined undefined)
12:21:40 <_zZzZz> ohh, not a bad idea
12:21:42 <_zZzZz> Thanks
12:22:11 <Marvin--> note that undefined is not a special construct, it's a plain ol' Haskell variable
12:22:21 <ski> bottom = bottom
12:22:26 <Marvin--> one way of defining it is  undefined | False = undefined
12:22:29 <ski> undefined | False = undefined
12:22:43 <ski> @type error
12:22:44 <lambdabot> error :: String -> a
12:22:44 <_zZzZz> you guys are twins or something? :P
12:22:52 <ski> nah
12:23:08 <_zZzZz> well, I sure hope I'm not the first to say you guys are genious's
12:23:09 <_zZzZz> :)
12:23:18 <Marvin--> we aren't, this is all basic haskell
12:23:32 <Marvin--> well, maybe not *that* basic
12:23:47 <Marvin--> you can happily use undefined without knowing how it's defined
12:23:50 <_zZzZz> Yep, if it wasn't for helpers like you guys, newbies like me in Haskell, would never take the time to even look into it
12:23:55 * ski smiles
12:24:31 * Marvin-- realizes that it sounds weird to talk about how "undefined" is "defined"
12:26:14 <Marvin--> man, Ronnie O'Sullivan is on a roll today
12:26:20 <ski> hmm, maybe we should have an unimplemented constant too ..
12:26:42 <Marvin--> unimplemented = error "FIXME"? :)
12:28:43 <ski> (at least i seem to use undefined as stub body to get something through the system for testing. though some things should possibly really be undefined and not just asOfYetUndefined)
12:29:43 <Marvin--> yeah, I (ab)use undefined for that too
12:30:03 <Marvin--> though I try to use  error "something useful"  instead
12:30:28 <Marvin--> actually, when something really should be undefined and it's an error to try to evaluate it, you're almost always better of using error instead
12:30:40 <ski> should those report internal function name, or just external ones ?
12:31:16 <ski> (e.g. worker/wrapper)
12:32:58 <Marvin--> sheesh, 12-2
12:33:04 <Marvin--> O'Sullivan really lives up to his nickname today
12:34:14 <ski> tennis ??
12:34:25 <Marvin--> snooker
12:36:58 <Igloo> I'm wondering if Hamilton just played a gambit to get Ronnie to go for tricky shots when trying for a 147, what with the unusual breakoff shot and all  :-)
12:37:22 <Marvin--> heh
12:37:55 <Spark> ski: yo
12:38:08 <Spark> ski: just writing my report
12:38:14 <themaximus> Hello All
12:38:16 <Spark> ive run into major problems with clocking and evaluation
12:40:27 <ski> themaximus,Spark : hello
12:40:46 <Spark> ski: you also asked me if an instance could change by itself, to instigate a propogation through a network, the answer is actually yes :)
12:40:48 <ski> Spark : haven't downloaded Eden yet .. :/
12:40:51 <Spark> ah
12:41:05 <ski> ok, how ?
12:41:29 <Spark> you would define a special predefined entity like 'mouse_pos'
12:41:34 <Spark> which would have a single advice and no oracles
12:41:40 <ski> ok
12:41:44 <Spark> and the advice would be of type {int,int} and contain the current coordinate
12:41:55 <Spark> or you could just have two advice etc
12:41:56 <ski> as i thought, then ..
12:42:04 <ski> yeah
12:42:09 <Spark> yeah i misunderstood the question but it was clear when i read the log :)
12:42:26 <Spark> it means you can implement reactive systems
12:42:59 <ski> ok, so there's definitely some external time in the model (even as internal delayed loops)
12:43:47 <Spark> yeah, thats really essential for any kind of input
12:43:53 <Spark> im not sure if you could call it time though
12:44:23 <Spark> i also thought about the whole clocking thing, its possible you could just have an instance that continually spins an integral advice, and then depend on this
12:44:27 <Spark> im not sure
12:45:02 <ski> "continually spins an integral advice" ?
12:45:10 <Spark> yeah like its advice just keeps increasing at a constant rate
12:45:16 <Spark> you can change the rate from inside the environment
12:45:25 <Spark> or maybe it just goes between 0 and 1
12:45:32 <Spark> like a digital electronics clock line
12:45:32 <ski> ok
12:45:50 <ski> (no differential times then, i suppose)
12:46:07 <Spark> yeah
12:46:21 <ski> (differential, like in VHDL)
12:46:50 <Spark> you could have a model clock, that goes 0,1,0,1 as well as a real clock that ticks up once per ms in unixtime, no matter what the state of the model is
12:47:31 <Spark> whats this "conceptual modelling" then?
12:48:17 <ski> something in OOD
12:49:30 <ski> (it prolly isn't related.. i just was reminded of empirical modelling)
12:50:49 <Spark> seems to have some common ideologies
12:51:27 <Spark> you know i half expect to find an exact copy of what ive done, only better, and more complete, just lurking in the debian apt repository somewhere
12:51:43 * ski smiles
12:52:50 <Spark> ah it seems to be just various ways of forming relationships between concepts
12:53:09 <Spark> rather than EM which is about modelling our understanding of interacting processes
12:53:14 <esap> conceptual modelling is a way of modelling requirements for software.
12:53:33 <Spark> like UML?
12:53:51 <esap> well you could use UML class diagrams for conceptual modelling (but often ER diagrams are used)
12:54:06 <Spark> right
12:54:26 <esap> But conceptual modelling is much more strict than UML in terms of accepted ways of modelling.
12:54:36 <Spark> yeah i think functional reactive programming has more in common
12:54:48 <Spark> at least at the technical side
15:22:56 <earthy> nytol
15:32:17 <Riastradh> Nytol?
15:33:09 <Cale> I think it's being used here as a punny way to say "Night all"
15:36:24 <monotonom> nighttoall
15:36:44 <Marvin--> forall x. night x
15:37:23 <monotonom> I say goodnight to those ....
15:47:42 <Spark> nytol is commercial available sleeping pills
15:48:12 <Spark> I apologise for the poor syntax.
17:42:54 * SamB wonders how to say that in Prolog
17:47:57 <stepcut> that.
17:48:31 <SamB> stepcut: no, night all!
17:48:36 <stepcut> :p
18:00:06 <SamB> it would appear that saying 'night(X).' in a source file is sufficient
18:04:34 <Spark> pain(X)
18:04:36 <Spark> .
18:04:37 <stepcut> yeah...
18:05:00 <Spark> 10618/18000 words
20:47:56 <fier> Anyone here?
20:48:15 <Riastradh> Just ask your question if you have one.
20:48:49 <fier> Riastradh: I start ghci, it gives this error when i try to define a functio:
20:48:56 <fier> <interactive>:1: parse error on input `='
20:49:08 <Riastradh> You can't enter top-level declarations into GHCi as you can into a module.
20:49:34 <fier> Riastradh: So, i do:
20:49:35 <Riastradh> The best you can manage is to use let, because GHCi's top level is something like a gigantic 'do' form:
20:49:35 <SamB> use let!
20:49:38 <Riastradh> let f x = y
20:49:43 <SamB> monadic style
20:49:45 <fier> Prelude> module Main where
20:49:45 <fier> <interactive>:1: parse error on input `module'
20:50:00 <Riastradh> No, you can't enter module declarations into GHCi either.
20:50:04 <Riastradh> You have to put the code into a file and then load it.
20:50:08 <anyone> you must also write your modules in a file, too
20:50:12 <SamB> fier: use emacs?
20:50:31 <fier> SamB: EMACS? No. :-( mcedit...
20:50:57 <SamB> fier: crazy!
20:51:31 <fier> Oh, i see.
20:51:59 <fier> SamB: I tried EMACS, honest! It has borked auto-indent, totally uncontrollable! I hate it...
20:52:20 <Riastradh> haskell-mode's auto-indent is usually pretty smart, except with case expressions...
20:52:29 <fier> Riastradh, SamB, anyone: Cheers.
20:52:32 <SamB> so its not as good as for python...
20:53:02 <fier> Riastradh: I also installed haskell-mode, but the whole EMACS is "too smart" for me!
20:53:42 <Riastradh> Emacs modes typically have pretty simple installation procedures: just add (autoload 'whatever 'haskell-mode "Comment.") to your .emacs, and whatever else haskell-mode bids you to do.
20:54:41 <SamB> I'm using Emacs right now
20:56:39 <fier> SamB, Riastradh: No i configured EMACS right, it loaded haskell-mode and all. The hilight was kinda nat, but i dont like the way it messes up indentation.
20:56:47 <fier> Anyways, what is this?:
20:56:54 <fier> Prelude> let fib 0 = 1
20:56:54 <fier> Prelude> let fib 1 = 1
20:56:54 <fier> Prelude> let fib n = fib(n-1) + fib(n-2)
20:56:54 <fier> Prelude> fib 5
20:56:54 <fier> *** Exception: stack overflow
20:56:56 <Riastradh> 'Messes up indentation?'
20:57:10 <fier> Riastradh: Try:
20:57:16 <fier> f n = a
20:57:18 <fier> <tab> b
20:57:19 <Riastradh> fier, that defines multiple fibs, only the last of which is the one that still exists whewn you use it.
20:57:22 <fier> <tab> c
20:57:30 <fier> Riastradh: It messes it up...
20:57:53 <Riastradh> A single tab is typically not what you want; tab a few times and see which one fits best.
20:57:56 <Cale> fier: for anything more than a small, temporary definition, make a file
20:58:41 <SamB> fier: let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
20:59:10 <fier> Riastradh: A simgle tab is what i type to indent in a *normal* editor...
20:59:25 <fier> It a holy war. I just dont like EMACS.
20:59:49 <fier> Cale: Yes, but this is a small, temporary definition...
20:59:55 <Riastradh> In Haskell, indentation is significant, different indentations have different _meanings_.
21:00:06 <fier> SamB: Oh, the solution, cheers!
21:00:07 * Riastradh cleverly inserts a 'so' somewhere in that message to make it a complete sentence.
21:00:34 <Cale> fier: I mean like "let a = 5"
21:00:54 <fier> Riastradh: I know. mcedit just does what i type...
21:01:14 <fier> Cale: :-)
21:28:19 <fier> If i compile with ghc -smp, does it automagically crate a multithreaded binary for me?
21:33:56 <fier> :-/
21:35:44 <fier> Anyone here?
21:35:53 <fier> Also, if I have
21:36:06 <fier> list = 2 : 8 : 9
21:36:11 <fier> What would
21:36:24 <fier> print (show (list !! 1))
21:36:31 <fier> Show?
21:36:38 <fier> 2? 8?
21:37:09 <Smerdyakov> Why don't you run it and see?
21:38:53 <fier> Smerdyakov: It tells me:
21:39:15 <fier> <interactive>:1:
21:39:15 <fier>     No instance for (Num [a])
21:39:15 <fier>       arising from the literal `9' at <interactive>:1
21:39:15 <fier>     In the second argument of `(:)', namely `9'
21:39:15 <fier>     In the second argument of `(:)', namely `(8 : 9)'
21:39:18 <fier>     In the definition of `list8': list8 = 2 : (8 : 9)
21:39:20 <fier> Prelude> let list10 = 2 : 8
21:40:36 <anyone> 2 : 8 : 9 : []
21:40:39 <fier> Smerdyakov: Should I compile even this?
21:41:21 <fier> anyone: Oh, lol, o forgot :[]
21:41:25 <Smerdyakov> Try it as interactively as you can.
21:41:25 * fier kick me
21:41:30 <Smerdyakov> fier, use [2, 8, 9]
21:42:10 <fier> Smerdyakov: Yea, 'salrite now.
21:42:24 <fier> Cheers!
21:46:41 <fier> Hmm... Strange:
21:47:41 <fier> Haskell tail-end recursive Fibonacci-series beats Python generator fibonacci-series at 10000th number
21:48:01 <fier> But Python beats Haskell at 100000th number
21:48:23 <fier> Anyone can suggest why?
21:48:48 <anyone> memory
21:48:52 <Smerdyakov> "Different constant factors"
21:48:54 <fier> anyone: ?
21:49:40 <fier> Python stores only the last two numers, whilst Haskell stores the whole list? Is GHC so insensitive?
21:49:54 <anyone> depends on actual coding
21:50:02 <fier> Sec
21:51:04 <fier> http://rafb.net/paste/results/edf32958.html
21:51:10 <fier> http://rafb.net/paste/results/M1156854.html
21:52:23 <anyone> the whole list will be stored and kept, simply because of fibo = ...
21:52:56 <Smerdyakov> If you made that local to the computation, then the unused list parts would probably be GC'd.
21:53:32 <anyone> let fibo = ... in print ... fibo ...  may help
21:54:39 <fier> Lets see how good GHC GC is :-)
21:56:11 <fier> http://rafb.net/paste/results/RJv25349.html
21:56:15 <fier> Like this ^^^ one?
21:56:41 <anyone> No.
21:56:50 <fier> :-/
21:56:58 <fier> :'-( Then?
21:57:09 <anyone> I think I was very clear.
21:57:41 <fier> in print
21:58:28 <anyone> "let fibo = ... in print ... fibo ..." is an entire piece of Haskell code.
21:58:42 <Smerdyakov> anyone, what's wrong with what he has?
21:58:54 <anyone> syntax error
21:59:35 <fier> Smerdyakov: Parse error 'show'
22:00:52 <fier> anyone: "Possibly incorrect indentation"
22:01:52 <fier> let fibo = 1 : 1 : zipWith (+) fibo (tail fibo) in print (show (fibo !! 100000))
22:02:07 <fier> I dont even indent...
22:02:20 <fier> :-?
22:02:58 <fier> Okay...
22:03:11 * fier decides to go with Binet's formulae
22:12:22 <fier> Oh my god, what is this?
22:12:33 <fier> user@localhost:~/tmp/tmp011$ make
22:12:33 <fier> ghc -O -o binet_hs binet.hs
22:12:33 <fier> binet.hs:10:
22:12:33 <fier>     No instance for (Floating (IO a))
22:12:35 <fier>       arising from use of `fibo' at binet.hs:10
22:12:37 <fier>     Possible cause: the monomorphism restriction applied to the following:
22:12:40 <fier>       main :: IO a (bound at binet.hs:9)
22:12:43 <fier>     Probable fix: give these definition(s) an explicit type signature
22:12:45 <fier>     In the definition of `main': main = fibo 10000
22:12:48 <fier> make: *** [all] Error 1
22:12:50 <fier> ---
22:12:53 <fier> In:
22:12:55 <fier> module Main where
22:12:58 <fier> fibo n = phi**(n+1) - (1-phi)**(n+1) / sqrt 5
22:13:00 <fier>         where phi       = (1 + sqrt 5) / 2
22:13:03 <fier> -- round()
22:13:05 <fier> -- x = (fromInteger n) :: Float
22:13:08 <fier> main =
22:13:10 <fier>         fibo 10000
22:13:12 <anyone> main = print (fibo 10000)
22:13:24 <fier> anyone: print( show (
22:13:30 <fier> anyone: LOL yes
22:13:33 * fier is stupid
22:14:06 <anyone> I don't see the point of print.show
22:14:20 <fier> anyone: is it automagial?
22:14:27 <fier> like, can i do print 5
22:14:43 <anyone> I always right correct Haskell code.
22:14:50 <anyone> s/right/write/
22:15:10 <SamB> anyone: print prints a string, show stringifies something who's type is in the Show class...
22:15:25 <anyone> @type print
22:15:26 <lambdabot> print :: Show a => a -> IO ()
22:15:34 <anyone> @type show
22:15:34 <lambdabot> show :: Show a => a -> String
22:15:46 <fier> LOL, and Python doesnt have sqrt(), strange... BBIH
22:15:53 * fier is reading docs.python.org
22:16:01 <anyone> @type putStrLn
22:16:02 <lambdabot> putStrLn :: String -> IO ()
22:16:38 <SamB> fier: it does! math.sqrt!
22:16:50 <anyone> I always write correct Haskell code. QED.
22:18:25 <fier> SamB: :-D
22:19:08 * SamB made the invalid assumption that there was a point to print.show ;-)
22:19:31 <fier> SamB: user@localhost:~/tmp/tmp011$ time ./binet.py 
22:19:32 <fier> Traceback (most recent call last):
22:19:32 <fier>   File "./binet.py", line 12, in ?
22:19:32 <fier>     print fibo(10000)
22:19:32 <fier>   File "./binet.py", line 10, in fibo
22:19:34 <fier>     return Phi^(n+1) - (1-Phi)^(n+1) / math.sqrt(5)
22:19:37 <fier> TypeError: unsupported operand type(s) for ^: 'float' and 'float'
22:20:39 <SamB> s/^/**/
22:20:52 <SamB> ^ is xor, I think
22:20:58 <fier> Wow!
22:21:12 <fier> I am from Sedna.
22:21:43 <fier> user@localhost:~/tmp/tmp011$ time ./binet.py 
22:21:43 <fier> Traceback (most recent call last):
22:21:43 <fier>   File "./binet.py", line 12, in ?
22:21:43 <fier>     print fibo(10000)
22:21:43 <fier>   File "./binet.py", line 10, in fibo
22:21:45 <fier>     return Phi**(n+1) - (1-Phi)**(n+1) / math.sqrt(5)
22:21:48 <fier> OverflowError: (34, 'Numerical result out of range')
22:22:08 <fier> WHY :'-(
22:22:18 <fier> It could do it with the generator...
22:22:24 <fier> Even 100000
22:22:27 <SamB> fier: what are you doing?
22:22:30 <fier> Not 10000
22:22:43 <fier> SamB: Benchmarking Python vs Haskell...
22:22:59 <fier> (And learning them...)
22:23:08 <anyone> problem with float.
22:23:19 <fier> anyone: Float in Python?
22:23:25 <fier> :-\
22:23:32 <anyone> Yes. But float in anything will suffer the same problem.
22:23:33 <fier> Python is untyped, nope?
22:23:39 <anyone> That's a lie.
22:23:54 <fier> It's a lie.
22:24:02 <fier> Hmm... Okay!
22:24:12 <Cale> phi^10000 is ~7.52x10^(2089)
22:24:24 <fier> So how do I type it?
22:24:41 <SamB> fier: python float is double already!
22:24:43 <fier> To El Camino Big Unsigned Long Long Long Integer?
22:24:54 <fier> SamB: I need integers...
22:24:59 <anyone> double is still very small compared to 10^2000
22:25:18 <SamB> fier: if you want a long, don't use any floats at all...
22:25:43 <fier> SamB: I didnt type at all, I tought Python is untyped.
22:25:53 <anyone> It would help if you could convert math.sqrt(5) to the equivalent of Java's BigDecimal
22:26:26 <fier> http://rafb.net/paste/results/lm451942.html
22:26:28 <fier> ^^^ code...
22:27:30 <fier> (I dont have Java sorry.)
22:27:51 <anyone> Anyway, so much for Binet's formula.
22:28:21 <fier> LOL, And binet_hs Gives: "Infinity"
22:28:46 <fier> While it did return the number smoothly with the tail-end recursive thingy...
22:28:56 <SamB> fier: could you do it in Haskell?
22:29:07 <SamB> did it work?
22:29:09 <anyone> Again, it is because of float vs. big integer.
22:29:10 <fier> SamB: 
22:29:22 <fier> user@localhost:~/tmp/tmp011$ cat binet.hs 
22:29:22 <fier> module Main where
22:29:22 <fier> fibo n = phi**(n+1) - (1-phi)**(n+1) / sqrt 5
22:29:22 <fier>         where phi       = (1 + sqrt 5) / 2
22:29:22 <fier> -- round()
22:29:25 <fier> -- x = (fromInteger n) :: Float
22:29:27 <fier> main =
22:29:30 <fier>         print (show (fibo 10000))
22:29:32 <fier> Compiles.
22:29:38 <fier> Prints: "Infinity".
22:30:40 <Cale> indeed it will
22:31:07 <fier> So, using sqrt in Haskell & Python types thingy to float, even if i dont want to...
22:31:08 <Cale> the number you're asking for is much larger than the floating point type will support.
22:31:25 <Cale> you do want a floating point type there
22:31:33 <fier> The number is:
22:32:00 <fier> Oh, it doesnt fit on a screen sorry...
22:32:04 <Cale> on the order of 10^2089
22:32:18 <fier> But it computed it for me in 3 seconds...
22:32:22 <Cale> that's pretty huge for a double
22:32:44 <fier> Cale: So how do I type it to be HugeInteger?
22:32:58 <Cale> Integer? Don't use sqrt
22:33:12 <fier> Cale: :-)
22:33:20 <Cale> don't use binet's formula, as it relies on real numbers.
22:33:37 <fier> Binet's formula has sqrt, imho i cannot subst it out...
22:33:42 <Cale> right
22:33:51 <Cale> so write a recursive integer definition
22:35:04 <fier> Cale: I did, but it keeps the whole infinity list in memory, and Python outperforms Haskell beyond Fibonacci(80000) or somethingy...
22:35:29 <fier> :-/
22:35:49 <fier> Trying to do it more efficiently in Haskell...
22:35:50 <Jerub> and python is getting lazy generators.
22:36:02 <fier> Jerub: Generators are lazy by nature yes.
22:36:13 <SamB> fier: try it with Psyco?
22:36:19 <Jerub> oh sorry.
22:36:20 <fier> SamB: What?
22:36:23 <Jerub> lazy genreator comprehensions.
22:36:39 <fier> :-D
22:36:41 <Cale> Infinite list?
22:36:41 <fier>    lol
22:36:47 <Jerub> Cale: yes!
22:36:47 <fier>     |
22:37:07 <Cale> um, I'm referring to "<fier> Cale: I did, but it keeps the whole infinity list in memory"
22:37:14 <Jerub> oh, sorry.
22:37:15 <Cale> for generating what?
22:37:15 <Jerub> :)
22:37:33 <fier> Cale: Well, lemme scroll back...
22:37:41 <fier> http://rafb.net/paste/results/edf32958.html
22:37:50 <fier> http://rafb.net/paste/results/M1156854.html
22:38:08 <fier> Thats it, tho the Haskell one is inefficient...
22:38:16 <SamB> fier: Psyco would hopefully make python outperforom Haskell even more
22:38:17 <fier> As i figured out...
22:38:29 <fier> SamB: Psycho?
22:38:37 <fier> SamB: URL? What is it?
22:38:51 <Cale> you could write something like fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
22:39:10 <fier> C would outperform everything, but it doesnt have ElCaminoBigNum_t :-(
22:39:26 <Cale> also, it's painful to use
22:39:35 <fier> Cale: Thats highly inefficient.
22:39:49 <Cale> it might be - have you tried it?
22:39:54 <SamB> psyco.sf.net, I believe ...
22:40:03 <fier> Cale: And takes ages for fibo(100000), in fact, runs out of my 300Meg memory
22:40:37 <SamB> I wouldn't be too surprised if python with Psyco was faster than C...
22:41:17 <SamB> Cale: it is in some cases, this has been demonstrated on c.l.py
22:41:47 <SamB> er, me is confused
22:41:50 <fier> SamB: I only import Psycho?
22:41:56 <SamB> *and* lagged
22:42:12 <SamB> fier: import psyco
22:42:39 <fier> SamB: Of course not installed.
22:42:44 <SamB> no h, no capital P
22:42:44 <SamB> after installing...
22:42:44 <SamB> and than do psyco.jit()
22:42:51 <tmoertel> fier: How long does it take for fib(100000)?
22:43:58 <fier> tmoertel: Ages, wait...
22:44:12 <fier> ---Python:---
22:44:13 <fier> real    0m7.367s
22:44:13 <fier> user    0m7.236s
22:44:13 <fier> sys     0m0.030s
22:44:15 <fier> ---
22:44:51 <fier> ---Haskell:---
22:44:52 <fier> real    0m17.951s
22:44:52 <fier> user    0m17.622s
22:44:52 <fier> sys     0m0.120s
22:44:54 <fier> ---
22:45:03 <fier> Note: Been IRCing meanwhile
22:45:14 <fier> for fibo(100000)
22:45:32 <tmoertel> how fast is your processor?
22:45:32 <fier> Tho Haskell is faster for fibo(10000)
22:45:42 <fier> tmoertel: Bogomips~1600
22:45:42 <Cale> fib x = let
22:45:43 <Cale> 	fibIter 0 a b = a
22:45:43 <Cale> 	fibIter y a b = fibIter (y-1) b (a+b)
22:45:43 <Cale> 		in fibIter x 0 1
22:45:50 <Cale> you could try that one too
22:46:07 <fier> Cale: This is Haskell generator LOL
22:46:23 <Cale> hm?
22:46:38 <Cale> I don't understand
22:46:46 <fier> Celeron2 825MHz, 128M RAM, 256M Linux swap, Linux 2.6.5 with PREEMPT
22:47:11 <anyone> main = let fibo = 1 : 1 : zipWith (+) fibo (tail fibo) in print (fibo !! 100000)
22:48:50 <fier> anyone: Thats what i do...
22:50:05 <Cale> please try my version (the one involving fibIter there)
22:50:19 <fier> Or wait...
22:50:24 <fier> ---Python:---
22:50:30 <fier> real    0m7.229s
22:50:31 <fier> user    0m7.192s
22:50:31 <fier> sys     0m0.028s
22:50:35 <fier> ---Haskell:---
22:50:40 <anyone> Cale: fier wants to compare generators in Python with lazy lists in Haskell.
22:50:45 <Cale> oh
22:51:27 <fier> real    0m18.635s
22:51:27 <fier> user    0m18.370s
22:51:27 <fier> sys     0m0.110s
22:51:29 <fier> ---
22:51:39 <fier> i compile with ghc -O
22:51:47 <fier> Or should i optimize further?
22:52:30 <anyone> I think -O is quite enough. If you really want, try -O2, but there is not much point beyond that.
22:52:38 <fier> anyone: with in print, it even takes longer!
22:53:03 <fier> .6s tho...
22:53:30 <SamB> anyone: is -O3 going to slow it down?
22:53:31 <Cale> I don't think that it's all that unreasonable.
22:55:18 * SamB doesn't think GHC is smart enough to notice the /dev/null he's sending the output too
22:56:01 <fier> real    0m18.036s
22:56:02 <fier> user    0m17.932s
22:56:02 <fier> sys     0m0.097s
22:56:08 <fier> Cale: Your implementation
22:56:10 <fier> ^^^
22:56:25 <fier> And it doesnt print the expected number :-/
22:56:42 * tmoertel had a nasty run in w/ lack of swap  :(
22:56:56 <Cale> you might be off by one in the input, depending on where it's supposed to begin
22:57:01 <fier> http://rafb.net/paste/results/S2472020.html
22:57:28 <fier> SamB: :-)
23:04:30 <SamB> hmm, apparantly multiplying longs is not something that psyco is good at optimizing... however it still does a good deal better than haskell... what algorithm does GHC use?
23:04:49 <SamB> wait, how many algorithms are there for adding longs ;-)
23:06:14 <fier> ?
23:09:56 <SamB> psyco seems to be shaving fractions of a second off the runtime...
23:10:21 <SamB> naesten@hydrogen:~/homework% for x in a a a; do for i in ./fib ./fib.py ./fibpsy.py ; do time ($i > /dev/null); done; done
23:10:21 <SamB> (; $i > /dev/null; )  25.05s user 0.39s system 67% cpu 37.706 total
23:10:21 <SamB> (; $i > /dev/null; )  15.91s user 0.23s system 71% cpu 22.475 total
23:10:21 <SamB> (; $i > /dev/null; )  15.62s user 0.21s system 66% cpu 23.702 total
23:10:23 <SamB> (; $i > /dev/null; )  25.62s user 0.41s system 60% cpu 43.268 total
23:10:25 <SamB> (; $i > /dev/null; )  15.79s user 0.16s system 70% cpu 22.474 total
23:10:27 <SamB> (; $i > /dev/null; )  15.72s user 0.17s system 68% cpu 23.303 total
23:10:29 <SamB> (; $i > /dev/null; )  25.05s user 0.39s system 69% cpu 36.708 total
23:10:31 <SamB> (; $i > /dev/null; )  15.84s user 0.17s system 71% cpu 22.415 total
23:10:33 <SamB> (; $i > /dev/null; )  15.72s user 0.13s system 72% cpu 21.997 total
23:11:21 <tmoertel> I can get fib 10000 in 2.3 secs.
23:11:34 <tmoertel> s/10000/100000/
23:11:36 <SamB> 1st, 4th, 7th are Haskell; 2nd, 5th, 8th are regular Python; 3rd, 6th, 9th are Python with Psyco
23:12:10 <SamB> tmoertel: mod what?
23:12:33 <tmoertel> mod nothing
23:12:36 <fier> tmoertel: I can too :-P
23:12:40 <fier>  
23:13:06 <tmoertel> sorry, I must of have missed something when my computer went offline
23:13:12 <tmoertel> what's the task again?
23:13:15 <fier> tmoertel: No.
23:13:42 <fier> tmoertel: But I can get Fibo(100K) with Maxima, for example, I just cant implement it myself...
23:14:14 <SamB> notice the 0.3 s to 0.07 s that Psyco can shave off ;-)
23:14:15 <Cale> Fibonacci[100000] takes Mathematica 0.007 seconds on my machine.
23:14:32 <fier> SamB: :-)
23:14:41 <fier> Cale: Mathematica?
23:14:44 <Cale> yeah
23:14:54 <tmoertel> Mma 5, right?
23:15:06 <Cale> yep
23:15:06 <fier> fib(100000) takes 0 (??) MAXIMA on my one...
23:15:19 <fier> Mathematica is what?
23:15:25 <fier> Symbolic math suite?
23:15:30 <Cale> yeah
23:15:32 <tmoertel> http://www.wolfram.com/
23:15:40 <fier> I only found MAXIMA...
23:15:42 <SamB> this is presumably because the bulk of the operation is spent in the long.__add__...
23:16:10 <SamB> Mathematica == proprietary math thingy
23:16:12 <Cale> "Fibonacci[n] uses an iterative method based on the binary digit sequence of n."
23:16:36 <fier> Oh, proprietary :-( Try MAXIMA, maxima.sf.net, seems quite neat.
23:16:39 <fier> Done in LISP.
23:16:49 <fier> Follows DOE MACSYMA...
23:17:04 <SamB> said to be a work of art
23:17:04 <SamB> maxima is quite quick at this
23:17:49 <SamB> also apt-get install maxima
23:18:03 <Cale> Fibonacci[10000000] takes 1.64175 seconds
23:18:48 <tmoertel> I've got fib 100000 at ~ 1.7 s in Haskell now
23:18:59 <fier> You won, its still running in Maxima...
23:19:21 <Cale> 100000000 takes 23.7654 seconds
23:19:22 <Cale> :)
23:20:24 <fier> Cale: Seems mathematica has a file with all the Fibonacci numbers :-)
23:20:33 <Cale> heheh
23:20:39 <fier> And just looks it up.
23:21:02 <Cale> I'm not printing them to the screen - that would take quite a bit longer than the actual computation.
23:21:04 <fier> Its what Maxima does with primes :-) Seriously.
23:21:23 <tmoertel> Up to what point?  ;-)
23:21:30 <fier> Cale: Not really... Depends on your terminal...
23:22:05 <fier> tmoertel: Dunno, Debian does not compile this option in...
23:23:02 <Cale> fier: actually, this is in the GUI frontend, and while version 5 is much faster than 4 was at printing large values, it can still be quite slow if the values are sufficiently large.
23:26:31 <fier> Cale: Yes...
23:26:48 <fier> tmoertel: The file is said to be 16Meg :-)
23:26:51 <fier> LOL
23:27:08 <fier> mersenne.org offers the largest prime ever for download
23:27:12 <fier> 6Meg
23:27:27 <fier> But its in string representation!
23:27:37 <fier> The waste 98% of the bandwidth.
23:29:26 <tmoertel> let fib4 n = f n 0 1 where f 0 a _ = a; f m a b = f (m-1) b $! a+b
23:29:49 <SamB> fier: it doesn't support gzip encoding for actual transfer?
23:30:34 <fier> SamB: Maybe, but they'd better bzip2'd the whole thing...
23:30:45 <fier> SamB: HTTP deflate?
23:30:51 <SamB> while we are downloading primes, don't forget to download one or more "illegal" primes
23:31:09 <fier> http://mersenne.org/prime6.txt
23:31:53 <fier> SamB: Illegal?
23:33:01 <fier> URL?
23:33:29 <SamB> fier: see the DeCSS gallery
23:33:42 <fier> DeCSS :-?
23:33:48 <fier> SamB: Where?
23:33:56 <fier> (And whats DeCSS?)
23:35:01 <fier> And whats CSS?
23:35:08 <fier> Cascading Style Sheets?
23:35:27 <fier> Poor smklsmkl has a bad connection it seems...
23:35:45 <fier> SamB: http://www-2.cs.cmu.edu/~dst/DeCSS/Gallery/?
23:36:38 <Jerub> DeCSS == the dvd encryption decryption programing
23:36:41 <Jerub> er program
23:36:53 <fier> #define m(i)(x[i]^s[i+84])<<
23:36:53 <fier> unsigned char x[5],y,s[2048];main(n){for(read(0,x,5);read(0,s,n=2048);write(1,s
23:36:53 <fier> ,n))if(s[y=s[13]%8+20]/16%4==1){int i=m(1)17^256+m(0)8,k=m(2)0,j=m(4)17^m(3)9^k
23:36:53 <fier> *2-k%8^8,a=0,c=26;for(s[y]-=16;--c;j*=2)a=a*2^i&1,i=i/2^j&1<<24;for(j=127;++j<n
23:36:53 <fier> ;c=c>y)c+=y=i^i/8^i>>4^i>>12,i=i>>8^y<<17,a^=a>>14,y=a^a*8^a<<6,a=a>>8^y<<9,k=s
23:36:54 <fier> [j],k="7Wo~'G_\216"[k&7]+2^"cr3sfw6v;*k+>/n."[k>>4]*2^k*257/8,s[j]=k^(k&k*2&34)
23:36:57 <fier> *6^c+~y;}}
23:37:03 <SamB> yep
23:37:56 <fier> :-)
23:37:59 <SamB> fier: but is it PRIME!
23:38:18 <fier> I dont have no DVDplayer nor DVDROM (nor any DVDs)
23:38:40 <fier> SamB: And legal :-)
23:39:14 <SamB> I have a few differently retrieved copies myself, and also no dvd rom, although I've a few DVDs and my family has a player
23:39:24 <fier> And the films i like are not likely to be released on DVD evr :-(
23:39:42 <SamB> unfortunately I don't seem to have kept track of the shellscript to download it from DNS
23:40:13 <SamB> fier: what films are those?
23:40:31 <Jerub> fier: doubt that, I really do.
23:41:14 <fier> SamB: Many... I like Tarkovsky, Antonioni, Resnais, Truffaut, Lynch...
23:41:52 <fier> Helmer
23:42:13 <fier> Bunuel
23:42:23 <fier> ...
23:43:28 * SamB goes for anime
23:43:41 <fier> Oh, I forgot: PPG!
23:43:51 <SamB> so much so, that I am downloading some at 2 KiB/s...
23:44:08 <SamB> well, on good days, its 2 KiB/s
23:44:11 <fier> SamB: 2K/s?
23:44:32 <fier> I have faster connection to Voyager hey!
23:45:03 <fier> (But PPG is on CartoonNetwork here for free...)
23:45:29 <SamB> Voyager?
23:45:37 <fier> The spacecraft
23:45:46 <fier> Leaving the solar system
23:46:17 <SamB> whats ppg?
23:46:32 <SamB> I don't get cable...
23:46:38 <fier> Accesible at voyager1.spaceconn.nasa.gov:670 (ssh -C, user guest)
23:46:47 <SamB> I'm waiting for Gundam Seed to come out on DVD
23:47:59 <fier> I am not at home with anime...
23:48:06 <fier> SamB: ppgworld.com
23:48:11 <SamB> you see, I was at a special IT program at a college for a month, with a really fat connection, and I got hooked on anime, so now I try and download it anyway...
23:49:14 <fier> :-)
23:49:20 <SamB> lately, though, I've gotten smarter and started downloading manga. which is unfortunately a little more difficult to find...
23:50:00 <fier> SamB: hentai being the next step?
23:50:32 <SamB> I don't actually like that
23:50:51 <fier> SamB: But thats impossible to find ;-)
23:52:31 <SamB> its actually rather easy to find on Gnutella, without even trying...
23:56:01 <fier> :-D
23:56:18 <fier> I never used Gnutella...
23:58:28 <SamB> well, lately I've just been using bittorrent because it is a lot more reliable
23:59:48 <fier> SamB: But is it searchable?
