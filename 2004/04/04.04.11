02:59:58 <musasabi> Anyone proficient with Clean here? How would the empty type be marked there "()" ? What about haskell "Tree a a" ?
03:03:05 <skew> I don't know anything about Clean. Do you think it is a good language to learn?
03:03:43 <musasabi> I think uniqueness types are better for many things than monads
03:03:58 <musasabi> but I don't think clean itself is the ultimate answer
03:04:05 <skew> what sort of things?
03:04:16 <skew> IO and state?
03:04:30 <musasabi> mutable datastructures without having mutablity in the signature ;)
03:04:56 <skew> Ah. I tend to be using wierd monads more often than not
03:05:11 <musasabi> for actual IO I like monads better
03:14:10 <skew> I though you had mutability in the signature with clean as well?
03:16:24 <musasabi> well it really depends
03:16:46 <musasabi> types have attributes in clean.
03:16:54 <musasabi> they can be marked unique.
03:18:04 <musasabi> Now destructive update would look like "update:: *Datastructure -> argument -> *NewDataStructure" where * marks an unique type
03:18:40 <skew> more precisely, I thought that the functions actually touching mutable state needing to indicate it explicitly, but generic things like map or whatever wouldn't need to care (unless they tried to violate uniqueness)
03:19:36 <musasabi> afaik one could have such a mutable array inside a normal function and it would not be visible in the signature.
03:19:57 <skew> same with ST
03:19:58 <musasabi> that is one could do mutable things inside modules hidden from outside world.
03:20:22 <skew> and IO takes a RealWorld value from what I've heard, so you can't likewise hide IO
03:20:43 <skew> it sounds like clean lets you leave unspecified the ordering of unrelated imperative operations
03:20:50 <skew> updates to different data structures or something
03:20:51 <musasabi> yes.
03:21:03 <musasabi> and I am missing that very much in haskell
03:21:05 <skew> that's a nice property to have
03:21:18 <musasabi> imho haskell monads break encapsulation in that regard
03:21:38 <skew> not too badly, but yes
03:22:07 <musasabi> skew: so how could one implement that with ST ?
03:22:28 <skew> well, you can make a function with pure signature that uses ST internally
03:22:33 <skew> runST has a pure result type
03:23:06 <musasabi> so why does e.g. Data.HashTable use IO?
03:23:36 <skew> that's a bit of an odd case
03:23:42 <skew> it works by pointer equality, IIRC
03:23:56 <skew> which means tapping into the ffi code for giving values a stable address
03:23:58 <musasabi> skew: it has an user suplied equality function
03:24:16 <skew> Oh, I was thinking the memoize thing in the old hslibs then
03:24:22 <musasabi> new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
03:24:36 <skew> I don't know
03:25:04 <musasabi> btw why has "new" a monadic return type?
03:25:27 <musasabi> No matter how I look at it, it seems pure
03:25:45 * musasabi really hates "pure" functions returning monadic values and thus dirtying all the code
03:25:57 <skew> do the operations mutate the hash table in place?
03:26:12 * shapr boings
03:26:22 <musasabi> yes, but even nonmutating operations have a monadic return value
03:26:40 <musasabi> and *that* is something I cannot grasp 
03:26:42 <skew> I think putting new in IO is done to avoid trouble with inlining
03:27:03 <skew> you wouldn't want to allocate the table twice rather than refering to the same table in two different places
03:27:04 <shapr> good morning #haskell!
03:27:11 <skew> hi
03:27:25 <shapr> musasabi: Maybe is monadic, right?
03:27:34 <skew> the same issue occurs when you hack up global variables with unsafePerformIO
03:27:45 <skew> damn dirty Maybe monad!
03:27:54 <skew> dirtying up his code!
03:28:04 <musasabi> point. Cleans way seems more intuitive to me new:: (key -> key -> Bool) -> (key -> Int32) -> *(HashTable key val) (or something simimlar)
03:28:06 <shapr> dirty dirty!
03:28:28 <skew> yeah, Haskell doesn't like mutable data very much
03:28:50 <skew> how hard would it be to add this stuff to Haskell?
03:29:20 <shapr> Maybe is just a way to wrap a type so that it additionally expresses failure
03:29:45 <musasabi> skew: there has been some discussion about that, but I think the main issue would be library code.
03:29:50 <shapr> Either wraps it so that it can express a failure value
03:30:02 <musasabi> because most existing code is using monads
03:30:07 <skew> I don't see why library code would need to change
03:30:25 <skew> just a few cases actually making mutable values
03:30:32 <skew> like the hash table
03:30:32 <shapr> but, monadic values are pure, right?
03:30:55 <skew> shapr: you are confusing me.
03:31:00 * shapr reads back in the buffer
03:31:13 <musasabi> skew: current code uses monadic libraries and one would create alternative "uniqueness" based libraries and that would make things even harder for a beginner
03:31:21 <shapr> I am also confused, what's the discussion?
03:31:24 <skew> it sounds like you are having a conversation of your own, superficially related to ours
03:31:38 <skew> musasabi was asking about Clean
03:31:49 <skew> I couldn't help him but I asked if it was interesting
03:32:01 <skew> now we're talking about the uniqueness types and what they are good for
03:32:25 <musasabi> basically monads and uniqueness typing are alternative ways of solving the same problem
03:32:43 <skew> well, they both provide sequencing
03:33:00 <skew> I think monads are probably better for sequencing on implicit things, like "the state of the world"
03:33:26 <skew> but uniqueness typing is likely better for sequencing operations on mutable data
03:33:36 * musasabi agrees
03:33:57 <skew> that doesn't seem too incompatible
03:34:31 <skew> better ways of composing monads might help with the fine-grained sequencing
03:34:39 <musasabi> also combining different uniquenently types values seems easier than combining values of different monads
03:35:00 <skew> if you could have a this-new-var-I-just-made monad transformer, or monad mixin I suppose
03:35:02 <shapr> I know SPJ wants syntax suggestions for commutative monads
03:35:32 <skew> and some stuff about automatically combining various (combinable) monads
03:35:33 <musasabi> also monads seem to need more syntax extensions, while uniqueness typing is more complex as a typing system extension
03:38:09 <musasabi> http://www.cs.kun.nl/~clean/CleanExtra/report20/chapter9/index.html is a quite good introduction
03:41:19 <skew> is that the sort of thing you would find if you searched for Clean?
03:41:41 <skew> sorry if I seem a bit helpless now. My mouse is being dead and I don't remember how to run mozilla very well without it
03:42:03 <skew> Everything else works just fine though. ion is an awesome window manager :)
03:42:48 <musasabi> googling for "clean functional" works
03:43:32 <musasabi> then manuals/support -> HTML version of the language report
03:43:45 <skew> okay, so cs.kun.nl/~clean is the main homepage.
03:43:58 <skew> all right. Clean is on my list of languages to learn, under E and prolog
03:44:50 <skew> have any of you learned E?
03:47:11 * musasabi hates java and E needs java...
03:47:33 <skew> Java isn't that bad if you don't actually have to code in it
03:47:35 <skew> witness Jython
03:49:50 <skew> actually, that's mostly about using Java libraries without needing to code Java
03:51:20 <skew> I recommend it if you have a job that wants Java where Java = runs on JVM
03:52:02 <skew> Java does seem to be slowly tending towards not sucking with various language extensions
03:52:33 <vegai> I'm afraid Java is moving towards oblivion'
03:52:39 <skew> well, that too
03:53:04 <skew> I don't see anything poised to replace it except possibly C#, unfortunately
03:53:21 <vegai> Microsoft Java, perhaps ;P
03:54:42 <skew> Java was irrelevant in terms of language features from the day it was introduced
03:55:46 <skew> it takes forever for good ideas to make it from academia to industry, unfortunately
03:56:29 <vegai> usually longer
03:57:59 <skew> but back to my last question, is there anything significantly better than Java that seens likely to approach its popularity?
03:59:24 <musasabi> no :-(
03:59:29 <skew> feel free to explain how to make Haskell insanely popular instead :)
03:59:34 <vegai> python, perhaps
03:59:43 <vegai> but still not likely
04:00:10 <musasabi> python, ruby (shadowed by python), ocaml (ugly syntax)
04:00:36 <vegai> musasabi: we all know that ugly syntax doesn't prevent a language from becoming popular
04:00:48 <musasabi> true
04:00:59 <skew> I guess the first question is what it takes to sell a language. That might include static typing.
04:01:13 * musasabi tries to formulate a monad which behaves like uniqueness typing
04:01:41 <skew> huh? monads provide a nice linear order on operations
04:01:45 <musasabi> a statically typed scripting language would be *very* cool
04:02:08 <skew> I wonder what historically got buisnesses and such to use Java for stuff
04:02:15 <vegai> musasabi, pyrex? =P
04:02:34 * vegai feels that "scripting language" does not mean much.
04:02:53 <musasabi> vegai: "light weight language" better?
04:02:59 <vegai> yes, ok
04:03:11 <vegai> bit vague still
04:03:22 <vegai> python, for instance, can be easily seen as quite heavy
04:03:43 <skew> Haskell is fairly light weight for that matter
04:03:48 <vegai> indeed
04:04:35 <musasabi> skew: so how would I easily create a N*M mapping in haskell (that can be searched and mutated fairly easily and searching is not monadic) ?
04:04:46 <musasabi> N<->M that is
04:04:55 <vegai> binary tree?
04:04:57 <skew> ah, that's better.
04:05:08 <skew> a pair of maps?
04:05:18 <vegai> oh, ah
04:05:27 <skew> If that's not good enough Okasaki's book might have something
04:05:35 <skew> a pair of maps gives you log time for most everythign
04:05:42 <musasabi> skew: there is no map supporting both mutating modifications and nonmonadic searches
04:06:06 <skew> of course not
04:06:18 <skew> searches need to be ordered with respect to the mutations
04:06:18 <musasabi> ?
04:07:10 <skew> let x = lookup 1 map >> insert 1 map >> return y
04:07:13 <skew> uh, x
04:07:20 <skew> when should you look in the map?
04:07:22 <musasabi> and if a method only takes a map and only searches it the whole thing needs to be written monadically?
04:07:34 <skew> before the 1 is added? when the result is demanded
04:07:39 <skew> threads
04:08:09 <skew> well, I guess making the code monadic doesn't help much there
04:08:56 <skew> but yes, at a minimum evaluation would need to be forced in the main IO trunk sometime before the "next" update
04:09:22 <skew> is it really too expensive to use a functional data structure?"
04:09:55 <musasabi> skew: but the sequencing would need to happen outside the method while haskell forces it *inside*
04:10:24 <skew> well, Haskel has no way of guaranteeing that the lookup is going to be performed between the last and next update
04:11:15 <skew> the compiler can hoist the operation as far as data dependancies allow, and laziness can defer it forever
04:11:27 <skew> and data dependancies go all the way back to construction
04:13:57 <skew> you might be able to do something similar to diffarray
04:14:22 <skew> if you really need a non-persistant structure (like a hash table)
04:14:31 <skew> why not just use a purely functional structure anyway?
04:15:04 <skew> if you have any concrete task you are trying to solve, that is
04:15:53 <musasabi> well "howto manage configuration information in a good way" would be nice.
04:16:17 <skew> That sounds more like globals
04:16:25 <skew> which are another problem
04:16:58 <skew> the {-# NOINLINE #-} unsafePerformIO newIORef hack works well enough
04:17:25 <musasabi> getting a value out of the configuration without turning the whole code monadic would also be nice
04:18:40 <skew> that's a very easy problem to solve, as long as you can distribute the information
04:18:51 <skew> why in the world are you using an imperative HashTable?
04:19:51 <musasabi> well if the global is behind an IORef doesn't just reading it make the code monadic?
04:20:19 <skew> the place where the variable is read would be, but not necessarily the code you pass the extracted value into
04:20:57 <skew> or bind to an implicit paramter scoped around, or thread into your homebrew application monad
04:21:12 <skew> (those being the ways I can think of to distribute the information)
04:21:50 <musasabi> skew: and if inner parts of the application would use the configuration information... 
04:22:10 <musasabi> ofcourse I could just litter the code with unsafePerformIO... but that is just a hack...
04:22:24 <skew> that's why they take it as a parameter, or implicit paramater, or something
04:23:25 <skew> if you are already using a monad (for IO, or backtracking or something) you can thread the info through that as well
04:26:20 <skew> the idom where the configuration information is parsed as a record of functions and you call those, which can reduce the need to be extracting it in your code
04:30:00 <skew> if the imperative stuff is more a problem than distributing the configuration, you could build the structrue then use something like unsafeFreezeArray to package it up in a value with a functional interface
04:30:50 <skew> Still, I don't really understand the problem. You want to provide a funtional object - use a functional implementation.
04:31:42 <skew> I don't see how you got "has an imperative implementation" onto your list of desiderata
04:38:37 <musasabi> oh well I suppose trying to use a functional one would work too...
04:39:09 <skew> Haskell isn't exactly designed to encourage imperative programming, you know ;)
04:44:32 <skew> if anything, it's designed to free you from specifying things that don't matter, and force you to specify things that do matter (like ordering of side effects)
04:49:52 <skew> mutable data and the type class system are Haskell's weak areas
07:09:38 <musasabi> am I supposed to get 'ERROR "/usr/lib/hugs/libraries/Hugs/ST.hs":50 - Syntax error in type expression (unexpected `.')'
07:10:16 <musasabi> or is it hugs fault?
07:12:41 <musasabi> -98 fixed it... not very readable.
14:37:20 <heatsink> How can i get xemacs to autoindent the RHS, when i type a :: or = ?
14:41:27 <np_hard> what is it doing?
14:41:33 <np_hard> are you using haskell-mode?
14:42:10 <heatsink> yes
14:42:25 <heatsink> It doesn't autoindent; when I type tab it says "Sole indentation"
14:42:31 <heatsink> It autoindents other things, though
14:42:54 <np_hard> probably doesn't understand what you are trying to line up
14:43:11 <np_hard> you are doing something for style's sake, most likely
14:43:29 <np_hard> I think haskell-mode focuses on the syntactically possible levels of indentation
14:43:39 <heatsink> Hm, okay
14:44:03 <heatsink> I know it works when the RHS doesn't line up between different definitions... I just think it's easier to read when it lines up
14:44:06 <np_hard> you are putting leading or trailing whitespace to make the thing after :: line up, right?
14:44:10 <heatsink> right
14:44:16 <rickjames> hi 
14:44:24 <np_hard> I think you will have to line it up with spaces yourself :)
14:44:35 <np_hard> unless you like to hack emacs
14:44:40 <rickjames> is there a function to get the system time
14:44:54 <heatsink> ok :(
14:45:18 <np_hard> google is good
14:45:30 <rickjames> i found cpuTimePrecision but it is exactly what i need
14:45:40 <np_hard> this is the first link for the search "haskell system time" on google:
14:45:41 <np_hard> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Time.html
14:46:02 <Cale> hehe, was about to paste that :)
14:46:51 <np_hard> though
14:46:58 <np_hard> that is not the greatest doc page
14:47:31 <Cale> http://haskell.org/onlinereport/time.html
14:47:58 <Cale> that could also say a bit more
14:49:45 * heatsink still can't understand what ghc means when it complains about type signatures
14:50:27 <heatsink> What is the type of main?
14:50:32 <Cale> IO a
14:50:36 <Cale> for some a
14:50:40 <Cale> usually ()
14:50:47 <heatsink> oh... I thought it was a function
14:50:51 <Cale> nope
14:51:12 <heatsink> oh... I thought it was a function
14:51:15 <heatsink> oops
14:51:17 <Cale> if you need to get arguments, then you can use getArgs
14:51:22 <heatsink> yes
14:53:51 <shapr> heatsink: use C-c = to line up stuff
14:54:00 <shapr> @wiki HaskellMode
14:54:01 <lambdabot> http://www.haskell.org/hawiki/HaskellMode
14:54:36 <heatsink> shapr: thx
14:55:47 <shapr> in general, C-h m shows you modo specific help, and C-h b shows you all the bindings at any given point
14:56:34 <shapr> with that and C-h f to see the docs for each function, you should be able to figure out anything
15:03:13 <heatsink> argh... I've been doing this for three non-consecutive days and I still get caught up on very simple things
15:03:47 <shapr> well, it's a very different way
15:04:38 <shapr> what do you usually use?
15:05:06 <heatsink> C or Python. I've learned some scheme as well.
15:08:37 <liiwi> hello
15:09:15 <shapr> haskell is quite different from those
15:09:24 * heatsink noticed
15:09:30 <shapr> hi liiwi 
15:09:46 <heatsink> It's more like the abstract algorithms they teach in CS theory class
15:10:13 <heatsink> semi-abstract... written in pseudocode
15:10:22 <ibid> haskell is calculation :)
15:10:27 <shapr> yah, but these actually work
15:10:28 <liiwi> use it for day to day stuff to get familiar with umm.. everything.
15:11:27 * liiwi has recently itched redoing his ~/.bin/*.py in lisp
15:11:40 <heatsink> itched?
15:11:49 <shapr> gah, I'm a slow typist now
15:11:56 <liiwi> not sure if I can do it yet
15:12:12 <liiwi> shapr: why bother typing fast?
15:12:33 <heatsink> shapr: just abbrev :)
15:13:08 <rickjames> i load the Random library and try using a random function over Int and i get errors everytime can someone give me and example of using the random funciton?
15:13:30 <shapr> trying to touchtype on a new layout
15:13:46 <heatsink> dvorak?
15:14:45 <shapr> dvorak right hand
15:16:19 <shapr> I can already touchtype dvorak two hand
15:18:54 <heatsink> 'type' makes one type a synonym of another, 'newtype' makes a type that with same semantics but differnent identity as another, 'data' makes a named type, but if I want to overload operators or have polymorphic functions then I need to use 'class'. Is that right?
15:18:56 <shapr> rickjames: can you paste your code on the wiki?
15:19:18 <rickjames> what wiki?
15:19:37 <ibid> heatsink: no
15:20:04 <ibid> heatsink: type was correct; newtype was close, data was not that close, and class was almost totally wrong
15:20:27 <shapr> @wiki HaskellIrcPastePage
15:20:27 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:22:19 <rickjames> how do i paste it
15:22:23 <rickjames> and where on the page
15:23:05 <ibid> heatsink: data defines a new (possibly recursive) type that is a union of records (almost;); newtype is almost a special case of data where there is only one alternative and that alternative has only one component
15:23:47 <heatsink> okay, that was my understanding of data
15:23:51 <ibid> heatsink: classes are a mechanism to overload functions and operators, but they are orthogonal to those others
15:24:19 <ibid> then i misunderstood your understanding of data :)
15:24:28 <shapr> edit the page, paste in your code, wrap it in {{{ }}} like the other code bits
15:24:30 <heatsink> ibid: Then can you extract the content of a newtype, the way you can from data?
15:24:37 <maihem> I think of a class as a simple predicate, and where that predicate is true, there are zero or more functions with a particular type signature that will behave in a way described in documentation. instance states when that predicate is true, and defines those functions
15:24:50 <heatsink> ibid: IOW do a "conversion" to the original type?
15:24:55 <ibid> heatsink: in almost all aspects newtype behaves like a special case of data
15:24:56 <Marvin--> heatsink: you can use a newtype type anywhere you can use a data type
15:25:19 <shapr> hej Marvin--
15:25:21 <ibid> heatsink: the exceptions are rather subtle, dealing with such things as strictness :)
15:25:30 <rickjames> shapr: its up there
15:25:30 <Marvin--> heatsink: there's one tiny difference and you very rarely have to worry about it
15:25:31 <Marvin--> hej shapr
15:26:20 <maihem> I wonder to what extent such a predicate could be defined as a rule in terms of other predicates, like prolog. how far could one go and guarantee that the compile will terminate ?
15:26:40 <shapr> rickjames: you need to use mkStdGen or so
15:26:55 <heatsink> a class is more like what other languages would call a metaclass?
15:27:46 <ibid> heatsink: haskell classes are a rather unique concept
15:27:55 <ibid> heatsink: very little to do with classes in other languages
15:28:02 <shapr> next (mkStdGen 5)
15:28:10 <ibid> heatsink: but java interfaces are a somewhat accurate analogy
15:29:00 <shapr> rickjames: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
15:30:20 <shapr> any new people coming to eurohaskell?
15:30:38 <ibid> heatsink: one important difference, however, is that while instances of java interfaces are objects, instances of haskell type classes are types
15:30:46 <maihem> where is eurohaskell?
15:31:20 <shapr> @wiki EuroHaskell
15:31:20 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
15:32:42 <maihem> hmm, it's tempting. I haven't been out of this country for many years. I haven;t had a proper holiday for almost as long either :/
15:33:05 <shapr> also, typeclasses can be declared after the fact
15:33:33 <ibid> true
15:33:41 <maihem> I don't want to fly. I hope there a ferry from England/Scotland to Sweden.
15:33:59 <heatsink> I'm looking at the introduction and trying to figure out how instance syntax works
15:35:09 <Marvin--> heatsink: looking at an example should make it pretty clear
15:35:23 <heatsink> it uses the example "instance Eq Integer where ...."
15:35:39 <Marvin--> Eq for Bool would be even simpler
15:35:53 <shapr> maihem: currently looks like you may be the only nonsweden participant, would be cool
15:36:04 <heatsink> Do I parse "Eq Integer" like I parse "IO Integer"?
15:36:15 <Marvin--> heatsink: no
15:36:25 <shapr> heatsink: http://www.scannedinavian.org/AvianWiki/HaskellDemo
15:36:27 <Marvin--> heatsink: IO is a type, Eq is a class
15:36:46 <Marvin--> heatsink: "instance Eq Integer where ..." says "Integer is an instance of Eq"
15:36:46 <maihem> All depends on the ferry
15:36:55 <shapr> I should add that to my demo
15:37:48 <heatsink> Marvin--: That would make sense, but it didn't work for the next one
15:38:01 <heatsink> "instance (Eq a) => Eq (Tree a) where ...."
15:38:27 <maihem> shapr: it's the beer that swayed me
15:38:35 <heatsink> If that were a type signature, it would mean a is of type Eq
15:38:40 <heatsink> or class Eq
15:38:41 <shapr> how to declare class constraints and parameterized types
15:38:46 <shapr> maihem: haha!
15:38:46 <ibid> heatsink: for every type a that is an instance of Eq, Tree a is an instance of Eq
15:38:58 <Marvin--> heatsink: that should be read "For all types a, Tree a is an instance of Eq if a is an instance of Eq"
15:39:46 <heatsink> Why is Eq a in parentheses?
15:39:51 <shapr> maihem: I prefer conferences that are heavy on code and socializing (meaning beer)
15:40:23 <Marvin--> heatsink: *shrug* that's the syntax of a context, a comma-separated list in parentheses
15:40:43 <ibid> the parens can be removed when there is only one element in the list
15:40:50 <heatsink> Marvin--: I'm asking because it's different for function type signatures
15:40:57 <shapr> I'm not so fond of listening to lots of people get up and talk, unless I'm free to wander out when I get bored
15:40:58 <maihem> shapr: I hope I will gain a much better understanding of monads, and more reassurance of my efficiency concerns.
15:41:00 <ibid> apparently this hasn't been done here
15:41:05 <heatsink> Marvin--: myFunc :: RealFloat f => f -> f
15:41:08 <Marvin--> heatsink: as ibid says, if it's just one element in the list, you don't need parentheses
15:41:20 <heatsink> ok
15:41:50 <shapr> maihem: at EuroHaskell? I think EuroHaskell is for people to get together and code and meet #haskell and chalmers Haskellers
15:42:33 <shapr> actually, there are rumors that John Hughes will be there, he probably can say much about monads
15:43:01 <maihem> shapr: it is easier to learn from more skilled people face-to-face and with paper napkins and beer than it is on IRC.
15:43:18 <shapr> maihem: actually, EuroHaskell might be an excellent choice for what you wish
15:43:30 <shapr> yah, I just realized that
15:44:25 <maihem> I will be looking at transport and time off forthwith. And trying to persuade a couple of friends to come for a holiday (though I will not spend EuroHaskell with them)
15:44:36 <shapr> :-)
15:45:08 <shapr> you could also come to europython if such things interest you, but that one isn't free
15:45:54 <maihem> I'm interested in python, but I am far more interested in Haskell and having a holiday. I think half Haskell, and half tourism would be perfect.
15:47:18 <shapr> be warned, eurohaskell is *directly*  after europy and nearyl in the same building, so you may want to make room/travel reservations to beat the rush
15:47:37 <heatsink> In instance Eq Integer where    x == y = ..., the type of (==) is drawn from the class declaration?
15:47:43 <Marvin--> heatsink: yes
15:47:45 <maihem> google's first page talks about the port of G?teborg. Is that the area?
15:48:11 <shapr> actually, it may be in the same building, I've forgotten where EP is happening
15:48:20 <shapr> yes, that's the city
15:49:28 <shapr> darcs was used in building the EuroPython website :-) I was happy to do my part in subverting the Pythoneers
15:49:37 * shapr grins evilly
15:51:06 <heatsink> okay. Can a class operation shadow non-class functions? When a type belongs to multiple classes, how is the method resolved?
15:51:27 <Marvin--> heatsink: no
15:51:58 <Marvin--> heatsink: there's no shadowing, there's just functions
15:51:58 <shapr> I'm to bed, I shall return tomorrow to resume my touchtyping lessons
15:52:18 <ibid> heatsink: all toplevel function names, including methods, have module scope
15:52:41 <heatsink> Marvin--: the same name can not refer to multiple functions?
15:53:08 <ibid> heatsink: only methods can, through class-based overloading
15:53:21 <Marvin--> heatsink: depends on how you look at it, overloading is the way to do that, but that means that by definition you're restricted to classes and instances
15:54:22 <Marvin--> heatsink: and there's no problem at all with a type belonging to several classes, since you cannot put the same function in different classes
15:55:01 <Marvin--> Integer, for example, is in Eq (defines == and /=), Ord (defines <, <=, >, et.c.), Num (defines +, * et.c.) and a whole slew of other classes
15:55:38 <heatsink> So I can't define the function == anywhere else, except in an instance Eq
15:55:44 <Marvin--> that is correct
15:57:30 <heatsink> a subclass can overload its superclass methods
15:57:51 <Marvin--> stop thinking OO
15:57:55 <Marvin--> :)
15:58:55 <heatsink> I can't think anything I haven't learned yet
16:00:48 * Marvin-- tries to figure out why he's still awake
16:01:00 <Marvin--> I really should get some sleep
16:01:00 <np_hard> i have decided that oo is by and large a crock
16:01:12 <Marvin--> three days worth of gaming with scant sleep
16:01:16 <heatsink> since functions curry, there is no type ambiguity, the first operand determines the class, right?
16:02:10 <ibid> heatsink: the type variable that is constrained determines the class
16:02:19 <ibid> heatsink: does not have to be the first argument
16:02:28 <ibid> heatsink: in fact, there may be no arguments at all
16:02:53 <Marvin--> if you have  class Foo a where  f :: Int -> a -> Bool   it's not enough to look at the first argument to f, you have to look at the second argument
16:02:59 <heatsink> right
16:03:39 <Marvin--> if you're asking whether   True == 3   is valid, then no
16:03:57 * Marvin-- guesses wildly
16:04:35 <heatsink> I'm trying to think of a case where the patterns Int -> a -> Bool and a -> Int -> Bool are both applicable and you try to call a function with Int and Int arguments
16:05:25 <Marvin--> well, you can't declare f to have *both* types Int -> a -> Bool and a -> Int -> Bool
16:05:34 <heatsink> okay
16:05:41 <ibid> heatsink: remember that a method belongs to only one class (well, subclasses complicate things but the basic idea is the same)
16:06:23 <Marvin--> in an application  f x y  you already *know* that f has the type  Foo a => Int -> a -> Bool, which means that for this to be valid, x must be of type Int, y must be of type Foo a => a and the result must be of type Bool
16:06:37 <heatsink> I think I understand
16:06:44 <heatsink> shapr: I see the 'deriving' keyword in the HaskellDemo, but I can't find it in the docs
16:07:24 <Marvin--> heatsink: "deriving" is a way to make trivial instances of a bunch of standard classes
16:07:48 <Marvin--> heatsink: basically, the instances will behave "as you expect"
16:08:04 <ibid> (if they do :)
16:08:15 <ibid> (there are situations where they don't)
16:08:18 <Marvin--> ibid: thus the quotes :-)
16:08:22 <ibid> :)
16:08:54 <heatsink> hmm, but classes don't define a default behavior, where does it come from?
16:09:13 <ibid> heatsink: deriving is only possible for standard classes
16:09:17 <ibid> heatsink: it's compiler magic :)
16:09:22 <heatsink> okay
16:09:22 <Marvin--> classes don't define behavior, they define an interface
16:09:27 <Marvin--> just like Java interfaces
16:09:57 <heatsink> right
16:10:03 <Marvin--> and what I just said is semi-true, you can have default implementations of class methods, but they typically depend on each other
16:10:40 <Marvin--> for example,  class Eq a where { (==), (/=) :: a -> a -> Bool ; x == y = not (x /= y) ; x /= y = not (x == y) }
16:11:12 <Marvin--> this basically says that when instantiating Eq, you only have to define one of == and /=, the other is defined in terms of the other (but you can define both if you like)
16:11:23 <heatsink> that's interesting
16:11:29 <Marvin--> yeah, it's really nifty
16:11:37 <heatsink> A different question: Can i print something without needing to pass an IO monad all the way to the call site? It would be useful for debugging.
16:11:57 <Marvin--> there's the trace function
16:12:05 <ibid> heatsink: for debugging purposes, there is trace in some module i forget which
16:12:17 <Marvin--> Debug.Trace iirc
16:12:28 <ibid> heatsink: but never even consider using it for any other purpose ;)
16:12:39 <Marvin--> there's also the Observe module (you need -package util for that) which is a lot niftier
16:12:49 <heatsink> what if I don't actually care when or whether it's printed? ;)
16:12:49 <ibid> what does it do?
16:13:46 <ibid> for a legitimate non-debug use of trace-like functionality i'd probably just roll my own trace :) (so that the actual trace is only used for debugging)
16:13:47 <Marvin--> ibid: it works like trace, only it doesn't affect the evaluation. After the program terminates, it'll print the values of expressions at your check points (but only the parts that were actually evaluated)
16:13:55 <ibid> nice
16:14:21 <ibid> have to try that sometime
16:14:25 <Marvin--> ibid: so you can write silly stuff like   take 4 (observe "foo" [1..])   and it'll print    1 : 2 : 3 : 4 : _
16:14:47 <ibid> it uses _ for the unevaluated thunks?
16:14:54 <Marvin--> yeah
16:15:16 <heatsink> Hm, the haskell98 report doesn't list Debug as a module
16:15:22 <heatsink> library
16:15:25 <ibid> heatsink: it's not standard
16:15:51 <heatsink> ah, it's in GHC
16:15:52 <Marvin--> both hugs and ghc have Debug.Trace though
16:17:05 <Marvin--> if you're using ghc, I'd recommend the Observe module over Debug.Trace :-)
16:18:17 <heatsink> I don't see Observe or util in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
16:18:42 <Marvin--> no, it's still in the old-style module/package hierarchy :(
16:19:07 <Marvin--> you need to add  -package util  to the ghc command line, and import Observe
16:19:12 <heatsink> okay
16:19:21 <Marvin--> http://haskell.org/hood/  has more info on it
16:19:39 <Marvin--> though it's a bit out of date
16:20:12 <heatsink> pretty good
16:20:20 <heatsink> thank you for all the help
16:22:31 <maihem> cool, from http://www.goteborg.com/, On June 12 Paul McCartney plays at Ullevi Stadium.
16:22:42 <Marvin--> yep
16:22:51 <Marvin--> man I'm tired, I'm off to bed
17:08:06 <rickjames> i am using the if .. then .. else construct and my then clause has multiple expressions to evaluate but the interpreter gives me a compile error after the first expression.
17:08:23 <rickjames> i know it isnt an offsides thing becuase i have it lined up correctly
17:08:55 <rickjames> is there a form i need to use when i have multiple expressions for the then clause or the else clause?
17:09:18 <clausen> rickjames: can you cut&paste?
17:09:29 <clausen> (is it short?)
17:09:37 <rickjames> if (not (gameOver newPileTurn1))
17:09:38 <rickjames> 					then 
17:09:38 <rickjames> 					     let comp1 = compPlayer newPileTurn1 maxSticks
17:09:38 <rickjames> 					     putStrLn ("Player1 takes: " ++ show comp1)
17:09:38 <rickjames> 				             let newPileTurn2 = nimTurn newPileTurn1 maxSticks comp1
17:09:39 <rickjames> 				             putStrLn ("Pile size: " ++ show newPileTurn2)
17:09:40 <rickjames> 					     if (not (gameOver newPileTurn2))
17:09:46 <rickjames> 						then (playNim0Human newPileTurn2 maxSticks)
17:09:48 <rickjames> 						else putStrLn ("Player1 wins!!!")
17:09:50 <rickjames> 						     return ()
17:09:53 <rickjames> 					else putStrLn ("Player0 wins!!!")
17:09:54 <rickjames> 					     return ()
17:10:49 <rickjames> this is not how it is formatted in my editor
17:12:26 <rickjames> an example really would be:
17:12:36 <rickjames> if <conditional>
17:12:44 <clausen> you aren't using monads correctly here
17:13:00 <rickjames>    then <expression> <expression> ... <expression>
17:13:09 <rickjames>    else <expression> <expression> ... <expression 
17:13:12 * clausen looks for a good example
17:13:16 <rickjames> ok
17:14:15 <clausen> http://www.nomaware.com/monads/html/iomonad.html#example
17:14:42 <clausen> rickjames: basiclly, you need to use "do"
17:14:47 <rickjames> ok
17:15:37 <clausen> rickjames: I recommend you play around with something a bit simpler until you get the hang of it
17:15:44 <rickjames> ok 
17:15:55 <rickjames> im checking it out right now
17:18:03 <rickjames> great i got it thanks
17:23:32 <heatsink> I don't understand this type error...
17:23:54 <heatsink> data Thing = Foo | Bar; instance Show Thing where {show Foo = "Foo"}; main = do show Foo
17:24:08 <heatsink> show Foo produces an error
17:24:33 <heatsink> expected IO a; inferred String
17:25:43 <monotonom> main = do print Foo
17:26:28 <heatsink> I just wanted to evaluate show, not print it, but okay...
17:26:32 <monotonom> "main" should have type "IO ()" or "IO <anything>".  "show" is not of that type.
17:27:49 <heatsink> But show is inside the do block... I thought expressions inside do don't need to be monad type
17:28:02 <monotonom> You are mistaken.
17:28:49 <monotonom> In fact it is the contrary.  Expression inside "do" must all be of the [same] monad type.
17:29:30 <monotonom> You may like "main = do putStrLn (show Foo)" more. It makes the call to "show" explicit.
17:29:55 <heatsink> Isn't the point of do to serialize operations which are not intrinsically serial?
17:30:14 <heatsink> no, that didn't make sense
17:30:18 <heatsink> Isn't the point of do to serialize operations?
17:30:47 <monotonom> That is an independent issue.
17:33:00 <np_hard> translate do into >> >>=
17:33:10 <np_hard> that helped me figure out what goes on
17:34:45 <heatsink> oh okay
17:35:45 <heatsink> so what is the function to evaluate and discard its argument? the K combinator?
17:37:06 <monotonom> Hmm evaluate and discard...  I have one in mind, but I doubt if it is what you mean.  seq.
17:38:08 <skew> if you just want to discard the argument const works
17:39:02 <heatsink> And I remember there was some way to create a do-nothing monad, but I forgot what it was
17:39:14 <monotonom> return ()
17:39:14 <skew> the identity monad?
17:39:35 <skew> or the monad /\ a -> ()
17:39:58 <heatsink> what is /\a? \a is lambda, right?
17:40:16 <skew> well, it's supposed to be a type lambda
17:40:17 <heatsink> I think it's the lambda a -> () monad I want
17:40:42 <heatsink> monotonom: I was trying return IO (). Why don't I need to specify IO?
17:40:50 <skew> that's just defined by () >>= _ = (), return _ = ()
17:41:27 <monotonom> return () :: IO ()
17:41:32 <heatsink> so const looks like K... it doesn't evaluate its second argument, okay
17:41:44 <heatsink> okay, IO is not a type constructor
17:42:13 <heatsink> is that saying that the type of {return ()} is IO() ??
17:42:21 <monotonom> Um, it is.  That is why one writes "return () :: IO ()" not "return IO ()".
17:42:25 <skew> oh, sorry. if you want an IO action that has no side effects, return () is pretty good
17:42:35 <rickjames> can you use guards within a do
17:42:56 <skew> rickjames: what would you want them to do?
17:43:02 <monotonom> "import Monad" then you can use the "guard" function.
17:44:04 <rickjames> well right now i am using the if then else construct in my do clauses but the guards would help readability of the code
17:44:20 <skew> that works in monads with a zero, like list or parser monads, where you can give up on a computation
17:44:33 <skew> if you want to execute actions only when some condition holds, look at "when" or "unless"
17:44:37 <skew> also in Control.Monad
17:44:43 <rickjames> ok
17:47:59 <heatsink> monotom: I'm not sure what you meant by it is: it is a type constructor, or it is the type of return ()
17:49:12 <monotonom> "IO" is a type constructor.  "IO ()" is a type.
17:50:57 <heatsink> return :: a -> IO a
17:51:19 <heatsink> So how come when I say "IO ()", I get the error "data constructor not in scope"?
17:52:03 <monotonom> If you write "return () :: IO ()" it is alright.  If you write funny things you get funny results.
17:52:44 <monotonom> "IO ()" is a type, and it should not appear where a type is not expected.
18:01:27 <heatsink> Okay, so it's return that does what I was expecting do to do
18:01:49 <heatsink> It's hard to figure these things out when the only thing the compiler tells you is that you're wrong
18:01:59 <heatsink> ...And then you get on IRC and the same thing happens
18:03:27 <heatsink> bye
18:06:23 <monotonom> He was wrong. The compiler did say specifically "data constructor".  I hate illiterate people who complain about compiler messages.
18:09:55 <monotonom> Oh and he complained about us too.  That's absurd.  I was being completely clear, wasn't I?  It is not my fault that he was being dense, is it?
18:11:37 <monotonom> I will never answer this Americanized barbarian again.
18:11:37 <np_hard> as a small argument in his defense the conventional course of study often leaves people underprepared for understanding haskell concepts without a bit more reading than is the norm for picking up a language like, say python
18:11:41 <np_hard> :)
18:17:21 <monotonom> My experience with compiler messages is that hugs, ghc, and smlnj are down-to-the-point, g++ is completely mangled, and perl accepts so ridiculously everything that you never get any error but it never does what you mean.  I am at a lost as to why any educated programmer would think the opposite.
18:26:42 <monotonom> Oh I see, those who complain are students. Can't expect students to be educated.
18:27:23 <Riastradh> No, certainly not: students are at schools, those things that suck education away.
18:29:00 <seafood> wasn't there some joke about this? That universities are places of knowledge. Knowledge is conserved. Therefore students come out less educated as knowledge is sucked from them.
18:30:10 <monotonom> Haha
18:30:44 <seafood> The joke expresses it much more humorously, but it always makes me laugh.
20:03:20 <Arnia> shapr: Have you seen the language Nemerle?
20:13:39 <SamB> hmm... I think I can manage to keep hold of a copy of mine ;-)
