00:09:42 <shapr> hej andersca
00:09:54 <andersca> hejhej
00:10:10 <shapr> what's up?
00:11:13 <andersca> I just woke up
00:26:55 <shapr> need coffee
00:27:07 <andersca> me too
01:47:31 <liiwi> I have coffee
01:47:35 <shapr> yay!
01:55:21 <adept> hello there
02:04:21 <shapr> greetz adept 
02:05:31 <adept> shapr: hi there. I'm in a great need of bind-unbending. Any volunteers? :)
02:05:50 <shapr> what does bind-unbending mean?
02:06:00 <shapr> berkely internet naming daemon?
02:06:02 <shapr> or maybe >>= ?
02:06:49 <adept> shapr: omg. I meant mind-unbending
02:08:32 <adept> you see, my mind is rather bent around issue of space-efficiency
02:10:58 <adept> I'm trying to understand what is the most efficient way to parse looong list of rather small datastructures from laaaarge file so that later i'll be able to process them in lazy way. Somehow, I fail.
02:12:12 <adept> I read Colin Runciman's paper "Heap Profiling for Space Efficiency" and it seems that there is a case exactly like mine. However, it is shown like exercise which is told to have trivial solution. Ha! Trivial....
02:12:14 <shapr> I got it to work with my mbox to database code
02:12:38 <shapr> I can parse and load a 27MB mbox file in such a way that very little memory is used at any one time
02:13:05 <adept> shapr: Q1: do you use strings or packedstrings?
02:13:38 <shapr> strings
02:14:35 <shapr> http://www.scannedinavian.org/~shae/src/haskell/MboxToDB.hs
02:15:03 <adept> shapr: ever tried packedstrings? Teya are dubbed to be "space-efficient", however kust reading 700kb file into PS seems to gobble up to 35 mb of heap(!)
02:15:43 <shapr> if you use readFile you can get lazy reads
02:17:09 <shapr> I haven't used packedstrings
02:18:05 <shapr> if you look at the main function of MboxToDB.hs, you'll see it ends up being a lazy pipeline
02:19:07 <adept> Ok, Q2: even if i'll get lazy reading, there is second obstacle. Largely, my program is doing a kind of clustering: list is sorted, grouped by some complex equality criteria, and then only one member of each group is left. Due to use of sort and group, everything read from file is being retained in memory. I cant help but thing that there should be a way to trick around sort, like there is a way to get rid of "reverse". Any thoughts?
02:22:44 <shapr> I guess it's possible, but if you need to sort the whole list, it'll be difficult to do that lazily
02:22:58 <shapr> at least, it would be difficult for me to figure out how to do that lazily
02:23:21 <shapr> alternatively, you could see if it can be done incrementally
02:25:28 <adept> shapr: sort is just needed in order for group to work. I've been thinking along the lines of famous prime number example - I can take head of list and eliminate all elements similar to it from the tail, then proceed recursively. However, for lists with 2-3 mln elemens this method must collect enourmous amount of closures on stack, no?
02:26:17 <shapr> if you can do a sieve, you'll be able to garbage collect most of the elements immediately after loading/parsing
02:26:35 <shapr> in that case, as long as you watch out for unwanted laziness, I think it would work
02:27:38 <adept> oh. what does it mean "watch for unwanted lazyness"? Like (1+1)+1)+1)+1)+1 ... ?
02:27:45 <shapr> sort of, yes
02:28:16 <shapr> it really means that if you don't evaluate a bunch of calls that have read from the file and loaded stuff into memory
02:28:26 <shapr> but then they haven't parsed and filtered
02:28:57 <shapr> then your memory usage quickly becomes painful
02:28:59 <shapr> I know, I had this problem :-)
02:29:32 <shapr> amusingly, Derek Elkins fixed that with a single $!
02:29:47 <shapr> fixed my problem, that is
02:31:38 <adept> turned out, that packed string indeed are not very user-friendy. My "parse -> print" pipe is running is bounded 120 k (which still seems to be a lot, though).
02:31:51 <adept> My input is a file of records, each record is a "name=value" list, each pair on a separate line. I use FiniteMap String String to represent them in memry. Is it a good choice? 
02:33:07 <shapr> bye?
02:33:39 <liiwi> pie pie
02:34:02 <shapr> hello again
02:34:58 <adept> shapr: i went offline and last thing i seen was about "$!". There was anything else? :)
02:35:07 <shapr> not yet
02:36:28 <adept> shapr: strange, it seems like making a list of (String,String) with length=30 (or 40) and then doing listToFM on it ammasses 120K of heap.
02:36:44 <adept> Each string is <40 chars
02:37:45 <shapr> I don't know, you could try using seq or DeepSeq
02:37:51 <shapr> that might cut down on heap usage
02:42:25 <adept> I'm trying to use breakAll instead of parsing everything by hand ...
02:42:43 <shapr> yah, breakAll is handy
02:53:37 <adept> another silly question. How can I write case XYS of Just (x) -> x ; Nothing -> "default" in monadic way?
02:53:54 <shapr> use fromMaybe
02:54:00 <shapr> oh, monadic?
02:54:14 <shapr> @type fromMaybe
02:54:26 <shapr> guess it's not in the Prelude, but it is in Data.Maybe
02:55:28 <adept> yep. I remember that lost of "case ... of .. -> case ... of ... -> case" could be rewriten neatly using "do" and "<-". I just dont know how to write "Nothing -> def" clause :(
02:55:55 <shapr> oh
02:56:20 <shapr> maybe this? http://www.scannedinavian.org/~shae/src/haskell/ProtoMaybe.hs
02:57:41 <adept> something along the lines. But what is z and what will demo2 do?
02:58:18 <shapr> try it :-)
02:59:12 <adept> oh. I must be blind. Missed "z<-" line
03:34:08 <adept> shapr: yet another silly question. I have "do { records <- liftM concat $ readFromFile files; mapM_ printRecord records;}". Why couldnt I write it as "liftM concat $ readFromFile files >>= mapM_ printRecord" ?
03:41:27 <adept> ok. figured this out myself ;)
03:48:49 <shapr> sorry, was off shopping
03:51:14 <shapr> greetz Si
03:51:43 <Si> hello shapr
04:14:02 <adept> anyone in mood for retainer profiling talk perchance? :)
04:18:59 <musasabi> how mature is WASH for writing largish web apps?
04:19:29 * musasabi wonders whether to use WASH + haskelldb or ruby for a project.
04:19:43 <Riastradh> WASH + HaskellDB, of course.
04:20:21 <musasabi> so can one easily e.g. separate html from the code with WASH ?
04:20:56 <musasabi> that is have multilingual skeletons where only the appropriate places are filled by data from db
04:20:57 <adept> musasabi: take a look at shapr's code for mail-list archive searching
04:22:10 <musasabi> adept: that does not really tell who scalable the solution is. I will have a separate person doing the html/layout stuff and she should not be forced to touch haskell...
04:23:15 * adept thinks that doing prototype in WASH should not be that hard
04:30:27 <musasabi> there is no debian package of wash?
04:44:07 <blackdog> shapr: buy anthing cool?
04:44:59 <Igloo> Grr
04:45:15 <earthy> waht?
04:45:19 <earthy> what, even?
04:46:14 <Igloo> The curses mvw functions are of the form mvw...(WINDOW *win, int y, int x, ...) (i.e. the mv and w arguments are the other way round to the name) so aren't easily treatable compositionally
05:22:32 <shapr> musasabi: for that, you might prefer using halipeto
05:23:53 <shapr> musasabi: on the downside, halipeto is not spiffily typed like WASH, on the upside, you don't need to know anything about Haskell
05:24:06 <shapr> and halipeto was first used for a multilingual website
05:24:28 <shapr> blackdog: nah, just caffeine and noodles
05:24:48 <shapr> I respect all meatless, wheatless, and sweetless days.
05:28:34 <shapr> konichiwa ikegami 
05:28:45 <ikegami> shapr: hi
05:29:19 <liiwi> hillo
05:29:51 <shapr> ikegami: have you found more questions?
05:30:10 <ikegami> yes
05:30:43 <shapr> what are they?
05:30:51 <shapr> if you want to ask them :-)
05:31:43 <ikegami> ok, just a moment... (typing)
05:33:39 * shapr bounces cheerfully
05:34:40 <Jerub> yay shpar.
05:34:58 <shapr> y0 jerubic
05:36:23 <Jerub> :))
05:38:11 <ikegami> ok, my question is: can we define functions in 'Prelude'?
05:38:43 <ikegami> I try like this: Prelude> f x = x + 1
05:38:58 <ikegami> however, system returns the parse error.
05:39:28 <shapr> you can define functions at the interactive prompt if you are using GHCi
05:40:38 <shapr> I usually define functions in a file, and load them into GHCi
05:40:53 <shapr> you can do that with emacs' haskell-mode quite easily
05:42:24 <ikegami> I have emacs with haskell-mode, but, I have never used it
05:42:33 <ikegami> so I'll try emacs
05:44:05 <shapr> for testing functions, it's easy enough to define them interactively
05:44:09 <shapr> > let f x = x + 1
05:44:12 <shapr> > f 1
05:44:12 <shapr> 2
05:44:16 <shapr> that's GHCi
05:44:55 <shapr> but that doesn't save those functions anywhere
05:45:00 <ikegami> nice
05:45:24 <shapr> in emacs, I can hit C-c C-l to load the current haskell buffer into ghci
05:49:37 <ikegami> In this year, I have to use Haskell for our work/business
05:49:52 <shapr> that's great!
05:50:05 <ikegami> because we have to use Agda/Alfa for verifying systems
05:50:13 <shapr> I hope to use Haskell for my work/business more than I do now.
05:50:41 <shapr> that's neat, you should talk to Marvin-- when he's around
05:51:17 <shapr> I know he's working on a paper that encodes a subset of Haskell in first order logic that can be checked by a proof checker
05:51:43 <ikegami> great
05:52:16 <shapr> I like encoding properties in the type system so that the compiler checks some of my code automatically.
05:53:05 <shapr> from what I've read, I think type systems are greatly simplified automated proof checkers.
05:57:05 <earthy> yes, they are.
05:57:19 <musasabi> halipeto seems very nice, much more nicer than wash, but I need some dynamic content too.
05:57:56 <musasabi> and e.g. maintain session data and a quite complex permission scheme.
05:58:18 <shapr> WASH does session data, I don't know about authentication
05:58:39 <shapr> alternatively, a combination of halipeto and HaskellDB wouldn't be too difficult
05:59:03 <shapr> if you look at the halipeto demo, you'll see that everything comes down to a single function call that generates the pages
05:59:12 <shapr> you could do the same thing with a WASH cgi program
05:59:20 <shapr> or maybe even an HWS-WP plugin
05:59:53 <shapr> I think you could just pass a new context into the halipeto generation call
06:00:10 <shapr> obviously, you'd want to generate on a per-page basis :-)
06:00:13 <musasabi> how "heavy" is halipeto? how much load would it generate if used to generate pages dynamically?
06:00:26 <shapr> not very much
06:00:53 <shapr> it's a straightforward implementation from what I've seen
06:01:21 <shapr> I haven't tried it myself for dynamic pages, so I may be missing something big :-)
06:01:46 <musasabi> hum, I'll try to prototype something and see how things go. first get wash working and then look into halipeto.
06:02:41 <shapr> I would be surprised if halipeto is heavier than WASH
06:02:45 <musasabi> having wash as a debian package would help things... (manually installed things allways cause headaches in maintenance)
06:03:04 <shapr> yah, I agree
06:03:14 <shapr> one day I'll get around to learning how to make debs
06:03:36 * musasabi knows how to make debs, but I don't have enough experience with wash...
06:03:47 <shapr> it's the other way around for me
06:04:08 <shapr> I'd also like to have lambdabot, hsql, haskelldb, etc debs
06:07:30 <shapr> I asked Peter Thiemann about having WASH and extensions in ghc-pkg for easier compilation
06:07:39 <shapr> he said that someone else promised to do that and then disappeared...
06:07:47 <shapr> so I guess that means he won't be doing it any time soon
06:08:30 <shapr> musasabi: if you want to the first public copy of curryspondence, it might help you figure out WASH
06:10:57 <musasabi> shapr: that would be nice ^_^
06:11:05 <shapr> ok, lemme make a tarball
06:11:39 <musasabi> mail to ekarttun@cs.helsinki.fi, dcc or a link are all fine.
06:30:51 <shapr> musasabi: http://www.scannedinavian.org/~shae/curryspondence0.9.tar.gz
06:31:08 <shapr> musasabi: I think I got everything in there, but you're my alpha tester, so I'd appreciate feedback :-)
06:40:35 <musasabi> shapr: thanks. except something from me in about a week.
06:40:44 <shapr> heh ok :-)
06:40:53 <shapr> if you have any problems before then, you know where to find me
06:41:38 <shapr> I'll have a curryspondence darcs repo up soon enough
06:41:49 <shapr> and I'm sure there will be more developments in a week
06:52:46 <musasabi> shapr: using message_id for the reference is not very good. using an integer column for that would be better.
06:53:10 <musasabi> shapr: consider what happens if an evil user sends spam with existing message_id 
07:02:25 <shapr> truly, I agree
07:02:43 <shapr> in fact, there are already duplicate message_id values in the haskell@haskell.org mailing list
07:04:22 * tmoertel needs espresso
07:04:27 <shapr> good morning tmoertel!
07:04:31 <Igloo> Really? What are they?
07:04:34 <tmoertel> mornin' shapr!
07:04:55 <shapr> Igloo: I don't remember, but I can figure it out again if you want
07:05:24 <Igloo> Well, I'm only curious, so don't go to any effort
07:06:13 <shapr> part of the reason I'm still using message-id is that HaskellDB doesn't have transparent support for auto-increment columns, and I've found out that the HaskellDB developers add requested features at a surprising rate
07:06:33 <shapr> so I probably won't have to wait more than a week from now to get support for message-id
07:06:35 <shapr> er for auto-increment
07:06:51 <shapr> Igloo: eleven different message-ids have two or more entries
07:07:04 <musasabi> shapr: someone was working on a mysql specific autoincrement
07:07:12 <shapr> iirc, I dropped ~ 27 messages because of that
07:07:14 <musasabi> shapr: it would be nice to have a general one
07:07:26 <shapr> yup, bring has mentioned some ideas for a general one
07:07:52 <shapr> so I think it'll happen pretty soon
07:08:42 <shapr> Igloo: what's the flag to specify a different ghc-pkg file to use when compiling?
07:09:11 <Igloo> -package-conf
07:09:28 <shapr> thanks
07:11:53 <shapr> hoi dr_fripp 
07:11:57 <dr_fripp> heya
07:12:16 <dr_fripp> does anybody here have experience with ghc and win32 (and haskelldb)?
07:13:00 <dr_fripp> and how to compile programs in ghc with linux packages...
07:13:12 <shapr> the -package haskelldb should work
07:13:28 <shapr> but like I said on #haskelldb, I don't know how system-wide ghc packages are setup in win32
07:13:39 <dr_fripp> me neither
07:13:40 <shapr> any ghc win32 users around?
07:13:44 <musasabi> What is the F6 thing?
07:13:55 <shapr> musasabi: it means "pass a collection of six fields"
07:14:11 <shapr> musasabi: you'll notice I strip the values out of the fields in the next call
07:15:12 <shapr> oh, and you get the ProtoWASH.hs bonus file with the first release of curryspondence, so you can hopefully easily try out WASH stuff
07:15:34 <musasabi> yes, but having to specify it explicitely seems ugly, but not prohibitely so.
07:15:38 <shapr> dr_fripp: did you try the -package-conf haskelldb.pkg flag that Igloo suggested?
07:15:48 <dr_fripp> yup
07:15:53 <dr_fripp> it gives the same error
07:16:00 <shapr> musasabi: I haven't yet tried it any other way, there may be a simpler way to do it
07:16:03 <shapr> what's the error?
07:16:37 <dr_fripp> ghc --make -package haskelldb  -package-conf haskelldb.pkg -o insert-update-delete insert-update-delete.hs 
07:16:40 <dr_fripp> gives
07:16:50 <dr_fripp> unknown package name haskelldb
07:16:59 <shapr> is the haskelldb.pkg in that same directory?
07:17:13 <dr_fripp> yes
07:17:17 <shapr> hm
07:17:17 <dr_fripp> ghc --make -package-conf haskelldb.pkg -o insert-update-delete insert-update-delete.hs
07:17:20 <dr_fripp> gives
07:17:40 <dr_fripp> parse error on input 'Package'
07:17:54 <shapr> that's strange
07:17:58 <dr_fripp> (line 1)
07:18:19 <shapr> you could explicitly include the flags that are the package
07:18:24 <dr_fripp> it seems the second option does more
07:18:45 <shapr> a ghc package is just a short name for a few source, link, etc flags
07:19:48 <dr_fripp> ah
07:19:51 <dr_fripp> yes I see
07:20:03 <shapr> for example, -package haskelldb on my system just means -i/usr/lib/ghc-6.2.1/imports -l/usr/lib/ghc-6.2.1/ -LHShdb and depend on base and hsql packages
07:20:24 <shapr> it also includes -fglasgow-exts and -fallow-overlapping-instances
07:20:28 <dr_fripp> ah
07:20:38 <shapr> at least, I think I got those flags right
07:20:40 <dr_fripp> "-fglasgow-exts", "-fallow-overlapping-instances"
07:20:49 <dr_fripp> so these need to be included
07:20:58 <dr_fripp> and more?
07:21:12 <shapr> and whatever the base and hsql packages also require
07:21:28 <dr_fripp> package_deps = ["base","hsql","wxcore"],
07:21:35 <shapr> ah, you've built it with wxWindows
07:22:26 * shapr checks to see if those flags are correct
07:23:13 <dr_fripp> where can I see what the base and hsql packages require?
07:23:19 <dr_fripp> because they're not in the dir
07:23:33 <shapr> try ghc-pkg -l
07:23:46 <shapr> that should show you the packages that are defined
07:23:56 <shapr> and ghc-pkg -s hsql
07:24:10 <shapr> will show you what flags hsql uses
07:24:36 <dr_fripp> can't find package hsql
07:24:51 <shapr> if the ghc-pkg commands work, you'll only need to use -package hsql -package base -package wxcore
07:25:11 <shapr> that's strange, I suspect there's some way to point ghc to the system-wide package configuration file
07:25:17 <shapr> but I don't know how
07:25:37 <shapr> have you looked for a package.conf in the GHC installation directory?
07:26:01 <dr_fripp> let's see
07:26:26 <dr_fripp> I ahve it here..
07:27:10 <dr_fripp> only the base package is there
07:27:19 <dr_fripp> wxcore and hsql are nowhere to be found
07:27:42 <shapr> that's mystifying
07:28:01 <shapr> maybe ghc-pkg works differently on win32
07:28:02 <dr_fripp> yes
07:28:10 <dr_fripp> might be true
07:29:15 <shapr> I'd recommend looking at the win32-specific documentation for GHC
07:29:28 <shapr> I think it will save you time to figure out how packages work with win32
07:31:14 <dr_fripp> ok
07:31:26 <dr_fripp> I am going to take a hard look at this the coming three days
07:31:34 <shapr> spiffy
07:31:40 <dr_fripp> and I'm going to try again on monday
07:31:47 <shapr> if you have more questions (that aren't win32-specific ;-) ask here!
07:31:49 <dr_fripp> so thanks for the help
07:32:05 <shapr> actually, there may be win32 experience people who aren't here at the moment, I'm not sure.
07:32:11 <dr_fripp> I hope we'll find a solution so we can bug you with more interesting stuff
07:32:19 <shapr> cool, sounds good
07:32:25 <dr_fripp> well I'll try to check back regularly
07:32:46 <shapr> :-)
07:33:01 <dr_fripp> I'll have to go now
07:33:09 <dr_fripp> I'll see you later!
07:33:14 <shapr> ok, have fun
07:33:17 <shapr> cya!
07:33:18 <dr_fripp> and thanks again
07:33:20 <dr_fripp> yo!
07:33:44 <shapr> boy I'm glad I don't have to use win32
07:36:19 <shapr> is there something like iterateM? I just realized I do { haskell <- checkboxInputField (attr "CHECKED" "CHECKED") ; haskellcafe <- checkboxInputField (attr "CHECKED" "CHECKED") } and was wondering if I could just iterateM over checkboxInputField (attr "CHECKED" "CHECKED")
07:38:55 <Igloo> There's replicateM
07:39:07 <Igloo> Anything infinite wouldn't work with the IO monad due to strictness
07:47:38 <shapr> Igloo: oh, good point, thanks
08:01:51 * shapr boings cheerfully
08:08:10 <shapr> replicateM and replicateM_ sure are handy
08:57:49 <Igloo> Any LaTeX exports about?
08:58:08 <adept> Igloo: try me
08:59:31 <Igloo> I want to say   \def\pt#1#2#3{  \begin{lrbox}{\frameme}\begin{itemize}\item#1\item#2\item#3\end{itemize}\end{lrbox}\fbox{\usebox{\frameme}}  }
08:59:54 <Igloo> (i.e. I want a 3 argument command that puts its arguments in a list and draws a box around them)
09:00:06 <adept> and?
09:00:58 <Igloo> and I'd like latex to not say "! LaTeX Error: Something's wrong--perhaps a missing \item."  :-)
09:00:59 <adept> whats the question exactly? :)
09:01:25 <adept> aha. wait. i'll sketch sample file
09:01:36 <Igloo> If I just have #1, #2, #3 without the itemize it works
09:03:02 <Igloo> http://urchin.earth.li/~ian/q.tex is an example file
09:03:02 <adept> Igloo: can you show me minimal document?
09:04:54 <Igloo> Hmm, a minipage might be the answer
09:05:17 <adept> Igloo: IMO, minipage is an overkill
09:06:02 <Igloo> Well, I'd prefer a simpler solution but I don't know one
09:06:15 <Igloo> It does fix it, anyway
09:07:45 <Igloo> Hmm, although I can't think how I can get the right width for the minipage
09:09:35 <shapr> cool, Michael Hudson may come to EuroHaskell
09:11:18 <adept> Igloo: IIRC, your are right about minipage. lrbox,mbox,sbox are all for one-line boxes, for multiline stuff you need minpage
09:12:29 <adept> Igloo: why you need width of the minipage?
09:13:33 <adept> Igloo: ah, I see. You dont want minipage to be \textwidth?
09:13:39 <Igloo> minipage takes width as an argument, and that will determine the size of the frame
09:15:23 <Igloo> And \settowidth{\framemew}{\cont} where \cont is the list has the same problem
09:26:07 * Igloo gives up and makes the width the page width for now
09:29:24 <Smerdyakov> What's the usual way to denote matrix subscripts in math? Is the first index the row or the column?
09:29:37 <adept> row IMO
09:29:54 <Smerdyakov> OK
09:40:47 <adept> Igloo: want a solution for your boxing problem? ;)
09:40:55 <Igloo> Yes please!
09:42:18 <adept> 1)\usepackage{fancybox}
09:42:22 <adept> 2)\def\pt#1#2#3{  \fbox{\begin{Bitemize}\item#1\item#2\item#3\end{Bitemize}}}
09:42:38 <adept> notice Bitemize instad of itemize
09:43:25 <adept> it helps?
09:44:07 <Igloo> What is Bitemize? Is it a fancybox thing?
09:44:20 <adept> yep
09:44:44 <adept> read fancybox docs for details. On page 11 there is all you need.
09:45:52 <Igloo> Yup, that's got it. Thanks!
09:52:07 <adept> Igloo: welcome :)
10:56:20 * esap just realized GHC supports real references.
10:58:20 <charon> hello
10:59:50 <charon> i started looking into haskell today and i wondered if haskell or any other functional programming language can pattern match on function bodies. rationale: i could then define a 'derive' function that takes other functions and returns their derivative
11:00:00 <charon> so, does anyone know? :)
11:01:13 <wagle> charon: i dont see what the first part of your question has to do with the second part
11:01:36 <Smerdyakov> charon, you can't.
11:01:49 <Smerdyakov> charon, function code is not available to code at runtime.
11:02:01 <Smerdyakov> charon, however, you can define your own symbolic language of functions within Haskell.
11:02:17 <wagle> Smerdyakov: he said haskell OR ANY OTHER ____
11:02:30 <Smerdyakov> wagle, I think you have misread something.
11:02:43 <Smerdyakov> wagle, like this asdhasjdfh
11:02:46 <Smerdyakov> Waht does it say?? HAHA
11:02:57 <Smerdyakov> I see, I see.
11:03:06 <Smerdyakov> charon, so you can probably do that with Lisp, but I wouldn't recommend it. :)
11:03:22 <charon> wagle: i want to say [pseudo-haskell]: deriv (x * y) = x*deriv y + y*deriv x
11:03:39 <Smerdyakov> charon, what you really want is something like this:
11:03:50 <charon> Smerdyakov: ok, thanks for the answer. i'll try the symbolic language thing, but it's not as nice of course :)
11:03:55 <Smerdyakov> data exp = Const of Int | Plus of exp * exp | Times | exp * exp
11:04:00 <Smerdyakov> er, data exp = Const of Int | Plus of exp * exp | Times of exp * exp
11:04:12 <wagle> you can get at function bodies sortof in template haskell, but i think it would be simpler to just implement your own language / data-structure and interpreter
11:04:13 <Smerdyakov> And without the *'s
11:04:16 <Smerdyakov> So then you get:
11:04:37 <Smerdyakov> deriv (Times x y) = Plus (Times x (deriv y)) (Times y (deriv x))
11:04:38 <wagle> Smerdyakov: wtf?
11:04:47 <Smerdyakov> And without the of's.
11:05:42 <Smerdyakov> wagle, ?
11:06:32 <wagle> charon: since you aren't trying to find the derivative of all haskell functions, just the very few of them that fit a particular form
11:06:40 <wagle> Smerdyakov: this:
11:06:46 <wagle> <Smerdyakov> wagle, I think you have misread something.
11:06:47 <wagle> <Smerdyakov> wagle, like this asdhasjdfh
11:06:47 <wagle> <Smerdyakov> Waht does it say?? HAHA
11:06:47 <wagle> <Smerdyakov> I see, I see.
11:07:04 <Taaus> If you use exp * exp, shouldn't you match on Times (x,y)? Too much SML, eh Smerdyakov? :)
11:07:17 <Smerdyakov> Taaus, I said: "And without the *'s"
11:07:53 <Taaus> Ah, yes.
11:14:20 <wagle> charon: was your question answered?
11:16:04 <charon> i'm trying out Smerdyakov's approach and it looks good
11:16:14 <charon> so, yes, unless problems pop up out of nowhere ;-)
11:16:17 * SyntaxNinja was so confused... I thought he was talking about automatically generating code for deriving clauses (for classes)
11:16:55 <charon> SyntaxNinja: i'm a math student :)
11:18:21 <wagle> hmmm could add "deriving derivatives" to the language..  oh wait, this isnt yesterday
11:27:44 <Smerdyakov> charon, math and CS are the same! ;D ;D ;D
11:30:44 <wagle> "In theory, practice is the same as theory.  In practice, it isn't."
11:31:09 <Smerdyakov> You sound like you think math is theory and CS is practice.
11:32:56 <mattam> what's the word for 'vulgarily' ?
11:33:00 <wagle> scans better if you unify practice with math, and theory with computer science"
11:33:40 <wagle> computer science does have math envy, i think
11:33:52 <wagle> (note that I say that as a computer scientist)
11:34:51 <wagle> hmm..  maybe i'm a systems buy with math envy envy
11:35:22 <Smerdyakov> Like I said yesterday, the basic skills that computer scientists and mathematicians learn are equivalent. The difference between CS and math practioners' skills is about the same as the difference between skills in practioners are different subfields of math.
11:37:38 <wagle> you can say that all you want, but it is not true
11:37:49 <wagle> ... in generel
11:37:55 <wagle> general
11:38:14 <wagle> it is true for SOME computer scientists and SOME mathematicians
11:38:31 <Smerdyakov> If "SOME" includes "good," then I'll agree.
11:38:51 <wagle> but it is not true in general, and in particular not true for my math training, nor for at least half my computer science training
11:39:54 <wagle> eh..  i need to find that frame war between maclane and the other guy
11:40:06 <wagle> ... flame war ...
11:40:18 <Smerdyakov> wagle, what kind of math and CS training do you have?
11:40:48 <Smerdyakov> If you are an expert on writing proofs, then you are an expert on writing programs with minor additional training.
11:40:53 <Smerdyakov> The reverse is also true.
11:42:10 <wagle> you claim the sky is green.  i look outside and see a blue sky.  the burden of proof is not on me.
11:42:40 <charon> Smerdyakov: your Exp strategy works out beautifully
11:43:10 <Smerdyakov> wagle, I've never known a person who was good at one and not the other, and I've known a lot of people good at one or the other.
11:43:59 <wagle> note that i spend 99% of my time in the place where compsci == math, just as you say
11:44:38 <Smerdyakov> It's ALL math. Programming and proving are thin layers over the same mental process!
11:45:17 <SyntaxNinja> Smerdyakov: what about the more "engineering" aspects of writing software? building large systems doesn't seem to me to be much like proofs.
11:45:42 <Smerdyakov> SyntaxNinja, why not? You divide a problem with abstraction and solve the subproblems with precise formal language.
11:45:59 <charon> SyntaxNinja: i disagree. maths require you to wrap up complicated concepts in easy, abstract notation. so does designing OO structures
11:46:50 <SyntaxNinja> so where does planning ahead, gathering requirements, defining scope, designing modules, etc., fit into the analogy?  Are there isomorphic activities in the math world? (I'm not much of a math guy)
11:47:29 <SyntaxNinja> perhaps we're thinking of different levels of abstraction here. on one level, I agree with the similarities you mentioned
11:47:32 <wagle> what isnt math?
11:47:43 <Smerdyakov> "Designing modules" is the easy part, since this is dividing proofs into lemmas.
11:48:16 <Smerdyakov> The other things you list are analogous to what the mathematician does to determine which problems are of interest to the larger community, both mathematicians and people with desired applications.
11:48:55 <wagle> i think the problem is that you think everything is math
11:49:18 <Smerdyakov> wagle, no. For instance, physics is not math because it fundamentally relies on foundations that are not obvious to humans.
11:49:41 <wagle> computers are physical objects
11:49:50 <Smerdyakov> CS isn't about physical computers.
11:49:58 <wagle> and their is goedel
11:50:03 <Smerdyakov> Physical computers show up in _applications_ of the skills learned by computer scientists.
11:50:26 <wagle> speak for yourself.  cs IS about physical computers.
11:50:46 <Smerdyakov> I don't agree. I never think about hardware AT ALL.
11:50:54 <Smerdyakov> And I am a computer scientist.
11:50:59 <wagle> now you speak for yourself
11:51:03 <Smerdyakov> I haven't written a program in months. :P
11:51:15 <adept> Smerdyakov: you could speak for me too ;)
11:51:41 <wagle> i hold that Smerdyakov doesnt do computer science.  he does math
11:51:46 <adept> wagle: which hardware represents Universal Turing Machine, for example? ;)
11:51:47 <Smerdyakov> CS is inspired by physical computers in the same way analysis is by physics.
11:51:55 <Smerdyakov> We don't say analysis IS physics.
11:53:02 <wagle> i never said that there wasnt a "theoretical computer science"
11:53:32 <adept> I'd even say that physical computers as they are today was developed in the contradiction with CS theories in order to overcome physical limitations of the 60th. So CS could be about LISP machines done by xerox long ago, but not about today's hardware, thats for sure
11:54:19 <wagle> adept: i not quite understanding your remark
11:54:28 <wagle> adept: i'm not quite understanding your remark
11:55:12 <wagle> adept: also, there are fields of compsci that dont give a hoot about universal turing machines
11:55:17 <adept> wagle: question - who and when did first computer?
11:55:20 <Smerdyakov> wagle, what do you think is a skill common to all good computer scientists that is not cognate with a skill common to all good mathematicians?
11:55:57 <adept> wagle: another question - was that first computer (computers) using Von Neuman architecture?
11:56:20 <wagle> adept: dunno, when who was the abacus, or maybe the clay slab and chisel?
11:58:15 <adept> wagle: have you ever heard about computers that were able to do symbolic math and compute numbers of infinite precision (limited by memory size) in 70th ? Do you know why they were superceded by what we see around today?
11:59:12 <wagle> adept: dont forget about analog computers
11:59:25 <wagle> i have bignums today
11:59:59 <Smerdyakov> wagle, do you have an answer to my question?
12:00:02 <wagle> i have mathematica, etc today
12:00:42 <wagle> Smerdyakov: i'm thought about it, but now my cube comrades are heading for lunch
12:01:42 <Smerdyakov> Oho! Sneaky weasel exit!
12:08:24 <adept> damn. I missed finale ;)
12:09:55 <Smerdyakov> What?
12:15:18 <charon> Smerdyakov: i've played around a bit, and it's simply great... i haven't seen anything like haskell so far (not that i've tried...). thanks a lot for the help
12:16:30 <Smerdyakov> charon, :)
12:19:36 <stepcut> s
12:45:40 <charon> well i have to go! thanks again, i'll stop by again next time i get in trouble (i will)
12:52:06 <atom-z> ERROR "numbers.hs":6 - Unresolved top-level overloading
12:52:16 <atom-z> i get that error when i try to run my program
12:52:24 <atom-z> err, interpret my program
12:53:41 <Smerdyakov> Well, gosh, I'll just search for "numbers.hs" on Google and be right with you? :P
12:54:24 <atom-z> how did you know my file is called numbers.hs?
12:55:27 <Smerdyakov> Are you serious?
12:55:30 <atom-z> yes
12:55:46 <Smerdyakov> <atom-z> ERROR "numbers.hs":6 - Unresolved top-level overloading
12:56:21 <stepcut> I have some code that does: l <- hGetContents h
12:57:18 <stepcut> how do I force force it to strictly read the whole string instead of lazily
12:57:37 <stepcut> I can never quite remember how to use `seq` correctly
12:57:54 <atom-z> Smerdyakov: yeah i suppose that does kinda give it away
12:58:00 <atom-z> i walked into that one
12:58:10 <Igloo> last l `seq` whatever
12:58:26 <atom-z> l <- getNumbers
12:58:41 <atom-z> let sum = show (foldl + 0 l)
12:58:44 <stepcut> Igloo: odd, I tried that and it did not seem to work :-/
12:58:47 <atom-z> putStrLn sum
12:58:55 <atom-z> seems to be the part causing the problem
12:58:58 <Smerdyakov> atom-z, ah
12:59:04 <Smerdyakov> atom-z, the problem is that 0 has several possible types
12:59:18 <Smerdyakov> atom-z, if you change 0 to (0 :: Int), it should work.
13:00:35 <atom-z> hmm, it gives me a type error now
13:00:52 <atom-z> *** Expression     : (0 :: Int) l
13:00:52 <atom-z> *** Term           : 0
13:00:52 <atom-z> *** Type           : Int
13:00:52 <atom-z> *** Does not match : a -> b
13:01:44 <Smerdyakov> Try (+) instead of +.
13:02:26 <atom-z> *** Expression     : foldl (+) (0 :: Int) l
13:02:27 <atom-z> *** Term           : l
13:02:27 <atom-z> *** Type           : IO [Int]
13:02:27 <atom-z> *** Does not match : [a]
13:04:09 <wagle> Smerdyakov: I know many good computer scientists, and i know many good mathematicians.  none of the computer scientists are great mathematicians, and vice versa.  they all chose their fields according to their talents
13:06:01 <atom-z> Smerdyakov: ah i fixed it, i had changed l <- getNumbers to let l = getNumbers earlier, i just changed it back to l <- getNumbers and it works now. Thanks
13:06:31 <Smerdyakov> wagle, how about naming one skill that separates them?
13:07:24 <wagle> the burdon of proof is on you, not me
13:08:40 <Smerdyakov> wagle, I think of the quintessential skills of BOTH fields as programming and proving, and the close connection between those is easy to show.
13:09:24 <wagle> the limitations of your experience are your problem
13:09:36 <Smerdyakov> So tell me what's the problem!
13:14:30 <Smerdyakov> wagle, helloooo? If you have such greater experience, give me an example!
13:15:10 <wagle> you lost my interest with this: <Smerdyakov> Oho! Sneaky weasel exit!
13:15:12 <wagle> goodbye
13:15:20 * Smerdyakov laughs.
13:15:30 <Smerdyakov> The Dutch never learn.
13:19:55 <atom-z> ERROR - Cannot find "show" function for:
13:19:56 <atom-z> *** Expression : main
13:19:56 <atom-z> *** Of type    : IO a
13:20:48 <atom-z> i dont understand why this error occurs
13:20:56 <Smerdyakov> You are trying to print an IO something.
13:21:18 <atom-z> possibly
13:21:46 <Smerdyakov> That's what the message means. If you aren't explicitly calling show, it's about the interactive environment trying to print the overall expression result.
13:23:19 <atom-z> ok, i commented out the line that would print something but i still get the error
13:23:38 <atom-z> my function:-
13:23:44 <Smerdyakov> You may also be trying to execute an IO action with an unknown result type.
13:23:48 <atom-z> showFactorials l = do
13:23:55 <atom-z>   let n = (head l)::Int
13:24:02 <atom-z>   showFactorials (tail l)
13:24:20 <Smerdyakov> Yup, that's it.
13:24:25 <Smerdyakov> showFactorials never returns.
13:24:28 <Smerdyakov> So it could have any type.
13:24:35 <Smerdyakov> The repl doesn't know how to print "a value of any type."
13:25:14 <Smerdyakov> The "do" seems completely extraneous there.
13:25:46 <wagle> i have stuff more interesting to do that debate sophomoric philosophy.
13:26:21 <atom-z> i thought you needed do if you wanted to use IO functions
13:26:32 <Smerdyakov> wagle, it's far from "sophomoric philosophy." It's a practical debate about how best to organize human knowledge to make problems easy to solve.
13:26:46 <Smerdyakov> atom-z, which IO functions are you using?
13:27:32 <atom-z> putStrLn in that function
13:28:02 <Smerdyakov> atom-z, did you not paste the whole definition of showFactorials?
13:28:14 <Smerdyakov> atom-z, because there's no putStrLn in the part you pasted!
13:28:32 <atom-z> i pasted the function without the putStrLn (i commented it out) becuase it wasnt working
13:28:39 <atom-z> well, isnt working
13:28:46 <Smerdyakov> OK. In that case, the "do" makes sense.
13:29:41 <atom-z> how do i tell haskell it returns nothing?
13:29:57 <Smerdyakov> You probably don't want that function as it is.
13:30:05 <Smerdyakov> It will end by raising an error.
13:30:08 <Smerdyakov> On every call.
13:30:46 <atom-z> ok, how would i fix it?
13:31:30 <Smerdyakov> Do you understand why it will end with an error?
13:31:45 <atom-z> will it never end?
13:32:05 <atom-z> or will it end when head l returns nothing
13:32:43 <wagle> this is reasonable:  It's a practical debate about how best to organize human knowledge to make problems easy to solve.
13:32:56 <wagle> however, there ARE things i needs to be doing now
13:33:14 <Smerdyakov> atom-z, the problem is that head raises an error, not "returns nothing."
13:34:10 <atom-z> okay
13:37:27 <atom-z> showFactorials l = do
13:37:27 <atom-z>     if l == [] then return l else do
13:37:27 <atom-z> 	let n = (head l)::Int
13:37:27 <atom-z> 	putStrLn (show ("Factorial " ++ show n ++ ": " ++ (show (fac n))))
13:37:27 <atom-z>         return (showFactorials (tail l))
13:37:47 <atom-z> but now it gives me "Type error in function binding"
13:38:19 <Smerdyakov> Why are you returning lists from showFactorials?
13:38:30 <atom-z> because it needs to return something
13:38:48 <Smerdyakov> Why are you returning values of a type with multiple values when you don't care what is returned?
13:38:49 <atom-z> its result is never used, so i thought why not return a list
13:39:02 <Smerdyakov> The correct type for such cases is ().
13:39:41 <atom-z> ok, i've changed that
13:40:48 * adept is driven mad by GHC's profilier. What does it mean if something is retained by SYSTEM?
13:40:53 <Smerdyakov> Have you seen pattern matching, atom-z?
13:41:25 <atom-z> not really
13:41:31 <Smerdyakov> atom-z, then you should be reading a tutorial.
13:41:34 <atom-z> i'm not at that stage in my tutorial yet
13:41:47 <Smerdyakov> atom-z, you must be going out of order if you are doing IO before pattern matching!
13:42:13 <Smerdyakov> atom-z, no wonder you have no idea what you're doing with this stuff. :P
13:42:27 <atom-z> pattern matching has been mentioned but not in detail (yet)
13:42:40 <Smerdyakov> And IO _has_ been mentioned in detail?
13:42:44 <atom-z> no
13:42:51 <Smerdyakov> You shouldn't be using it, then.
13:42:58 <atom-z> just putStrLn and getLine have been used
13:43:39 <atom-z> surely thats not complex
13:43:43 <adept> atom-z: once you touch IO, there is no way out of it
13:44:14 <Smerdyakov> atom-z, it is too complex to be worth doing.
13:44:18 <Smerdyakov> atom-z, it brings you _no_ benefit.
13:44:42 <Smerdyakov> atom-z, you get all the IO you need by evaluating expressions and seeing the results.
13:45:17 <atom-z> yeah i've written an implementation of RSA without IO so far
13:45:30 <atom-z> quite neat
13:45:59 <atom-z> just that everything that comes out of an io function seems to be an IO Int or an IO Whatever as opposed to an Int or a Whatever
13:46:00 <Smerdyakov> This isn't really a special case. Good Haskell programmers almost always only use IO in an outer loop that calls pure functional workhorse functions.
13:46:25 <Smerdyakov> Right. Which is why you shouldn't use IO when you don't need to!
13:47:29 <Smerdyakov> For instance, your showFactorial function is a total waste.
13:47:49 <Smerdyakov> You can just evaluate an expression that gives a list of factorials, and the repl will do the work of printing it.
13:48:36 <atom-z> yeah, but why does a function which basically only calls fac for each item in a list not work?
13:49:20 <Smerdyakov> What type do you think your function should have?
13:49:27 <atom-z> void
13:49:40 <atom-z> haskell says it should be IO ()
13:49:50 <Smerdyakov> Neither of those i a function type.
13:49:54 <atom-z> *** Term           : showFactorials
13:49:54 <atom-z> *** Type           : [Int] -> IO ()
13:49:54 <atom-z> *** Does not match : [Int] -> ()
13:50:13 <Smerdyakov> Obviously it can't be [Int] -> () if you use IO in it.
13:50:52 <Smerdyakov> Well, I am done helping you with this. You should erase all your code that uses IO and follow the order in the tutorial you are using.
13:51:07 <adept> atom-z: think from the task, not from the code. If you want to transform list of Int's to list of factorials of those Int's, what will be the type of factorial function, regardless of it implementation?
13:51:32 <atom-z> adept: Int
13:51:35 <Smerdyakov> adept, that's not it. He's just reimplementing show for [Int]. There is nothing specific to factorials involved.
13:51:35 <adept> Smerdyakov: any chance you could help me with profiling? :)
13:51:49 <Riastradh> atom-z, that's not a function type.
13:51:56 <Smerdyakov> adept, no.
13:52:02 <atom-z> Smerdyakov: i am following the tutorial, i'm doing an exercise thats in the tutorial
13:52:10 <adept> Smerdyakov: ah. I dont have the beginning in my scrollback.... Understood.
13:52:23 <Smerdyakov> adept, oops, he added a line that _does_ depend on factorials. Never mind. :)
13:52:38 <Smerdyakov> atom-z, you should not be using IO to do an exercise that comes before IO is introduced.
13:53:50 <atom-z> but IO has been introduced
13:54:05 <Smerdyakov> atom-z, link?
13:55:35 <atom-z> Yet Another Haskell Tutorial - www.isi.edu/~hdaume/htut/tutorial.pdf pg45
13:55:57 <atom-z> i'm doing the exercise on pg46
13:56:04 <atom-z> it seems like a good tutorial to me
13:56:08 <adept> atom-z: ok. How about that: do it without IO and then try to introduce IO without breaking everything. If first will be easy and second - not, then there is too early for IO.
13:57:06 <Smerdyakov> atom-z, you're being silly. You say "IO was introduced," but what it said up to that point is that IO is too complicated to worry about yet!
13:57:47 <atom-z> yes, but i'm just trying to do that exercise
13:57:51 <Smerdyakov> So don't use IO.
13:57:54 <Smerdyakov> And you will have an easier time.
13:58:12 <Smerdyakov> IO is NOT central to Haskell.
13:58:17 <Smerdyakov> It is NOT the default debugging method.
13:58:27 <atom-z> if programs i write in haskell are to be useful they will need IO
13:59:05 <adept> atom-z: keyword is "will"
13:59:21 <Smerdyakov> atom-z, incorrect.
13:59:50 <Smerdyakov> atom-z, you are thinking in an imperative mindset. IO is not fundamental. We don't expect you to understand that yet, but we DO expect that you will come to understand if you just follow the tutorial as it's meant to be followed.
14:02:07 <atom-z> i'm doing an exercise from the bit i just read
14:02:22 <Smerdyakov> The tutorial means for you not to use IO in that exercise.
14:02:29 <Smerdyakov> You will learn less if you use IO.
14:03:15 <Smerdyakov> Since you probably won't even be able to finish the exercise, as this demonstrates!
14:03:23 <Smerdyakov> You'd have been done long ago if you did it the right way.
14:03:47 <atom-z> what is the right way?
14:04:02 <Smerdyakov> Example:
14:04:21 <Smerdyakov> You are trying to write a factorial function.
14:04:25 <Smerdyakov> fact :: Int -> Int
14:04:30 <Smerdyakov> You test it by typing things like:
14:04:31 <Smerdyakov> fact 0
14:04:32 <Smerdyakov> fact 1
14:04:34 <Smerdyakov> fact 10
14:04:35 <Smerdyakov> etc.
14:04:37 <Smerdyakov> No IO involved.
14:04:39 <atom-z> yeah i've done that
14:04:48 <SyntaxNinja> atom-z: You might imagine a library which does not perform any IO, but which is very useful.
14:04:52 <adept> so?
14:05:00 <SyntaxNinja> Smerdyakov is right, even if his attitude is a bit frustrating :)
14:05:20 <Smerdyakov> atom-z, so why do you need anything else..?
14:06:03 <SyntaxNinja> atom-z: IO is not as complex as he's making it out to seem, but it will likely be more fruitful for you to move forward with the exercises trusting that they _will_ be useful programs, but that you'll get to do more IO a little later on.
14:06:36 <Smerdyakov> For crying out loud, the NEXT CHAPTER introduces IO, and he still can't seem to avoid guessing what the right way to do it is. :P
14:06:52 <SyntaxNinja> Smerdyakov: maybe that's a difference between programmers and math people :P
14:06:58 <stepcut> haha
14:07:01 <Smerdyakov> SyntaxNinja, what is?
14:07:13 <atom-z> because thats not what the exercise is:- "write a program that will repeatedly ask the user for numbers until she types in a zero, at which point it will tell her the sum of all the numbers, and, for each number, its factorial""
14:07:16 <SyntaxNinja> the demand to do things we don't understand.
14:07:25 <Smerdyakov> I don't think so.
14:07:49 <Smerdyakov> atom-z, then that's a problem with the tutorial. :\
14:08:20 <Smerdyakov> Since there's no way you'll be able to understand IO-error messages after that less-than-a-page description.
14:08:36 <atom-z> very well
14:08:45 * Smerdyakov goes.
14:08:52 <SyntaxNinja> hm Smerdyakov. maybe you shouldn't have jumped to conclusions about atom-z's way of approachign the problem
14:09:28 * SyntaxNinja goes too
16:22:58 <stu-pid> Who is General Failure and why is he reading my disk?
16:32:24 <saz> hm
16:51:49 <wagle> is like Captain Crunch, only different
19:18:28 * themaximus moos at all
20:22:06 <LittleDan> This is probably a really stupid question, but what's the difference between type, data, and newtype?
20:23:43 <LittleDan> is there a difference at all?
20:24:40 <Riastradh> type introduces a type synonym.
20:24:45 <Riastradh> data introduces an algebraic data type.
20:24:59 <Riastradh> newtype does something else but I don't know what it's called.
20:25:30 <LittleDan> so if you wanted to create an AST, you'd probably use data?
20:27:13 <LittleDan> like if I was doing
20:27:13 <LittleDan> data Tree = Statements [Tree] | Set String Int | Print Tree | Value String
20:27:27 <LittleDan> that would be data, right?
20:27:37 <Riastradh> Only data can define variant constructors.
20:27:46 <LittleDan> ok
20:28:03 <LittleDan> thanks
21:15:33 * Cale is away: stargate
22:38:12 * Cale is away: playing go
