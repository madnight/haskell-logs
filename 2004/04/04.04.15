00:00:18 <Pseudonym> Did that help?
00:00:47 <reltuk> yeah, thanks
00:01:47 <Pseudonym> http://haskell.org/onlinereport/lexemes.html
00:01:53 <Pseudonym> Search for varsym and consym if you care.
00:03:38 <reltuk> hmm...doesn't handle operators correctly...
00:07:13 <Pseudonym> Must away.  Nytol!
00:10:57 <reltuk> ahhh, I see what's going on
00:19:26 <ibid> any ghc hackers present? you might want to look at http://buildd.debian.org/fetch.php?&pkg=bnfc&ver=2.1.2-1&arch=sparc&stamp=1081967930&file=log&as=raw :)
00:20:44 <reltuk> ibid: got pretty close..just need a regex that matches top level declares like blah :: blah and blah = blah...
00:21:35 <ibid> reltuk: while you're at it, why not fix haskell mode :)
00:21:43 <reltuk> what's wrong with haskell-mode?
00:22:00 * reltuk doesn't write enough haskell to know better
00:49:23 <blackdog> ugh. from hacking haskell to trudging through someone's homebrewed shell... what a comedown.
00:49:49 <blackdog> maybe i'll learn scsh or that clean shell, and bemuse everyone who comes after me. :)
00:59:32 <ibid> reltuk: mishandling of keywords within strings and comments, for example
02:30:07 <shapr> @yow !
02:36:17 <skew> hi shapr
02:45:26 <shapr> hi skew
02:53:20 <shapr> what's happening?
02:53:43 <skew> trying to solve some odd type errors in macro generated code
02:54:16 <skew> I'm hacking on my Python interface again, trying to write a macro to generate the import declarations and wrappers
02:54:18 <shapr> using TH?
02:54:22 <skew> yes
02:54:31 <shapr> ah, neato
02:55:04 <skew> does this error make any sense to you?
02:55:10 <skew> Couldn't match `Ptr' against `IO'
02:55:14 <skew>     Expected type: Ptr t
02:55:18 <skew>     Inferred type: IO CString
02:55:22 <skew> In the application `pyString_AsString_ b0'
02:55:26 <skew> In a 'do' expression: rawanswer <- pyString_AsString_ b0
02:56:07 <shapr> sounds like you given it the value intstead of a pointer to he value
02:56:53 <skew> I read that as saying it expects pyString_AsString_ b0 to have a Ptr type
02:57:58 <shapr> I thought maye pyString_AsString_ wants a Ptr to whatever, but you've already read that something from the pointer into a CString
02:58:10 <skew> I think it's probably trying to match CString against IO CString
02:58:27 <shapr> ah
03:00:45 <kosmikus> I don't like this "expected"/"inferred" terminology. Depending on from which direction you look, they are completely interchangeable ...
03:02:29 <shapr> yup, the type slicing stuff is better
03:02:57 <kosmikus> slicing?
03:03:37 <kosmikus> which paper?
03:04:44 <shapr> sebastian carlier
03:04:53 <shapr> lemme get an url
03:05:31 <ski> perhaps top paper at http://www.cee.hw.ac.uk/~haack/papers/ ?
03:06:57 <ski> hm, perhaps http://www.cee.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/ is better to start from ?
03:07:37 <skew> I think I got it. I was forgetting the "module:" part in the patterns for type names
03:09:37 <shapr> http://www.haskell.org/pipermail/haskell/2002-November/010753.html
03:10:00 <shapr> there's a neat link to a demo
03:10:59 <ski> ok
03:12:06 <kosmikus> interesting, but I would still prefer a purely textual description of a type error
03:15:40 <ski> does a dots-term count ?
03:16:01 <skew> those dotted terms need line numbers
03:16:20 <skew> and more context
03:18:06 <skew> the module using my macro compiles now (I thought unsafeForeignPtrToPtr was in IO)
03:57:09 <hasky> if i had a tuple (x,(y,b a a1 a2),z) how can i extract just like a1 from that, or z etc
03:58:58 <ski> extracting z is easy
03:59:06 <ski> if the tuple is in t
03:59:28 <shapr> \(_,_,z) -> z
03:59:36 <ski> then (_,(_,_),z) = t  extracts the z
04:00:06 <ski> you can put that into a 'where' or a 'let'
04:00:31 <ski> extracting a1 is not possible
04:00:39 <hasky> mm i tried that and it said Pattern Syntax in expression context?
04:00:57 <ski> yeah, you must put that into a let or where
04:01:33 <hasky> what if (x,y,z), y = (c, d a a1 a1), could i then extract a1 from y?
04:01:37 <ski> like "let (_,(_,_),z) = theTupleHere in (17,t,"la")"
04:01:38 <hasky> a1 = string
04:02:14 <ski> a1 ia an argument to d, so you can't (generally) recover a1
04:02:37 <hasky> if i recovered d it was would recover all the a's?
04:02:42 <ski> haskell doesn't support higher-order matching
04:02:53 <ski> no
04:03:29 <hasky> hmmm i got to think of a better solution then :P
04:03:34 <ski> but if you know, e.g. that d returns it's second argument in the third part of a four-tuple, then you could do like this
04:03:56 <ski> (_,(_,(_,_,a1,_)),z) = theTuple
04:05:32 <ski> (lambdaProlog partially supports higher-order unification, though)
04:05:53 <kosmikus> hasky: in your above examples, if "d" or "b" are constructors, you can extract the components
04:06:01 <hasky> hmmm what if i had to extract theTuple out of a list first: [(x,y,z)], just first put theTuple equal to something, then that something equal to the part i want to extract
04:06:05 <kosmikus> in Haskell, you can match on constructors, but not on function application
04:06:55 <kosmikus> hasky: the list has only one element?
04:07:09 <ski> hasky : could you be a bit more explicit on what you mean ?
04:09:59 <hasky> if i knew what i meant, i thought i'd have an easy answer :)
04:10:12 <hasky> i best read over what's been said already and play around a bit more
04:11:33 <ski> hasky : (btw of course s/(17,t,"la")/(17,z,"la")/ above)
04:18:56 <hasky> elements are added to the list after each time a function is called, it starts empty, what i'm trying to do is extract the 2nd element of the list and compare it's a1 with another a1 
04:19:06 <hasky> i'm probably going about it a difficult way
04:20:14 <ski> what is d and b ?
04:20:20 <hasky> basically it's train that goes around a network of tracks, i just want to check if the track it's about to turn into is the track it just came off
04:20:48 <saz> ooh
04:20:52 <saz> your assignment is out?
04:21:00 <hasky> yeah :/
04:21:12 <hasky> i was going great but now i'm stuck
04:21:25 <ski> hasky : well ?
04:23:22 <hasky> type Location = (TrackName, Junction)
04:23:23 <hasky> type History = [(Train,Location,Arm)]
04:23:33 <hasky> data Track = Track TrackName Junction Junction
04:23:34 <hasky>    deriving (Show, Eq)
04:23:34 <hasky> data Junction = Junction TrackName TrackName TrackName
04:23:52 <hasky> that should be easier :P
04:24:15 <ski> so is d and b going to be the constructor Track ?
04:24:46 <ski> or mayhaps the constructor Junction ??
04:24:55 <hasky> d is TrackName and b is Junction
04:24:56 <ski> or some other function ?
04:24:58 <ski> ok
04:25:05 <ski> then it is a lot easier :)
04:25:48 <ski> you can match on (c, Track a a1 a1) as well as on ((x,(y,Junction a a1 a2),z)
04:26:23 <ski> you can match on (fully applied) constructor application
04:26:28 <ski> ok ?
04:26:40 <ski> hmm
04:27:04 <ski> or maybe i was misreading you .. ?
04:27:20 <ski> ok
04:27:29 <ski> so what is the type TrackName ?
04:27:51 <hasky> i dont think so, i just want to match the a1 of one tuple with the a1 of another, TrackName = string
04:28:58 <vegai> http://www.peanuts.com/comics/peanuts/archive/images/peanuts21830100040405.gif
04:29:48 <skew> vegai: I can think of plenty of things to say to a bug, mostly unprintable
04:29:54 <ski> anyway, you *can* match on "Junction a a1 a2"
04:30:37 <vegai> skew: don't hate your enemies... just crush them
04:30:39 <ski> so you can get at an a1 that way
04:31:28 <ski> hasky : to match one a1 with another, i think you'll have to use ==, though
04:31:50 <hasky> yeah i got lastTrack == leftTrack
04:32:09 <hasky> just couldn't get those to equal a1s :P
04:32:39 <ski> you're putting that == test in a guard or an if-expression, right ?
05:14:25 <ludde> is there some simpler way than this to change the value of the n:th element of a list? map (\(a,b) -> if a==4 then 'y' else b) $ zip [1..] "hello"
05:15:13 <skew> there isn't really any good way.
05:15:56 <skew> replace n x l = take (n-1) l ++ [x] ++ drop n l
05:16:01 <skew> it's a bit cleaner
05:16:30 <skew> has anybody here worked with ForeignPtrs much?
05:16:36 <skew> my finalizers don't seem to be getting called
05:16:53 <ludde> skew: ok..
05:17:06 <ludde> replace :: (a->a) -> Int -> [a] -> [a]
05:17:07 <ludde> what about this
05:17:31 <ludde> replace f n = map (\(a,b) -> if a==n then f b else b) . zip [1..]
05:17:48 <ludde> can that be simplified ?
05:17:52 <skew> that also truncates the list to n elements
05:18:03 <skew> oh, never mind
05:18:19 <skew> I was thinking replace f = map (\(a,b) -> if a==n then f b else b) . zip . enumFromTo 1
05:18:33 <ludde> same thing..
05:18:44 <skew> not quite. That's like using [1..n]
05:19:16 <ski> skew's replace also avoids (lazily) traversing the whole list
05:19:32 <ludde> hm
05:23:24 <skew> if you need to index elements like this you might want to use arrays anyway
05:23:50 <ludde> it's not so important that it's fast
05:24:24 <skew> arrays support that sort of interface more nicely
06:16:29 * juhp wonders why his GtkMoz mini-binding doesn't seem to work any more with current gtk2hs and ghc-6.2.1...
06:16:49 <juhp> import Hierarchy (WidgetClass(..), mkWidget, unWidget, ObjectClass(..), mkObject, unObject, GObjectClass(..), mkGObject, unGObject)
06:16:53 <juhp> :
06:17:35 <juhp> ./GtkMozEmbed.hs:68: Variable not in scope: `toWidget'
06:17:35 <juhp> ./GtkMozEmbed.hs:69: Variable not in scope: `fromWidget'
06:18:00 <juhp> it worked in November fwiw...
06:18:35 <juhp> same for ObjectClass(..)
06:20:51 <shapr> konichiwa juhp-san
06:22:29 <juhp> hi shapr
06:22:32 <shapr> has your GtkMoz been released?
06:22:42 <juhp> god aften :)
06:23:05 <shapr> jag kan inte tala dansk!
06:23:09 <juhp> shapr: not really
06:23:10 * shapr grins
06:23:24 <juhp> shapr: jeg kan heller ikke Svensk ;-)
06:23:48 <shapr> fair enough :-)
06:24:16 <shapr> johs: and you've got norsk covered
06:25:04 <juhp> shapr: I think I put it on the web somewhere, but it isn't really in a releasable state...
06:25:12 <johs> shapr: Both bokmål and nynorsk, actually.
06:25:21 <shapr> I'd like a copy, can you point me to it?
06:25:33 <johs> s/actually/even/
06:26:14 <shapr> Haskell is popular in ScannedInAvia
06:26:17 <juhp> http://juhp.dyndns.org/jens/haskell/gtk2-exts/
06:26:45 <johs> I'm not sure I like Haskell. I'm just playing with it to see if it's cool.
06:26:56 <vegai> it's more than cool
06:27:03 <johs> There are some cool things.
06:27:06 <vegai> ie. freezing
06:27:10 <juhp> shapr: it needs gtk2hs :)
06:27:15 <johs> But I'm not quite used to purely functional style.
06:27:17 <shapr> johs: I can assure you that it is cool, but it doesn't fit everyone
06:27:40 <shapr> johs: do you have some questions?
06:27:41 <johs> (I'm comfortable with mostly functional (Common Lisp) style, though.)
06:27:52 <johs> shapr: Not at the moment, but I'll let you know.
06:27:56 <shapr> ok
06:29:35 <johs> Actually, I was wondering if there is a particularly nice Haskell-program that I can look at for an idea of how to write good Haskell.
06:29:57 <keverets> hetris is well done, I think.
06:30:02 <keverets> Darcs is pretty good, too.
06:30:16 <keverets> though darcs is rather larger.
06:31:13 <johs> Thanks, I'll have a look.
06:31:53 <shapr> darcs does have nice internals
06:32:02 <shapr> except for that one scary part
06:32:29 <shapr> which almost nobody understands
06:32:38 <keverets> hopefully the author does...
06:32:58 <vegai> does it include monads or arrows? 
06:33:04 <keverets> I've written some stuff that has confused me later.  Literate programming helps with that, as long as I use it ;)
06:33:12 <shapr> no, it has patch theory
06:33:22 <vegai> ohh, that
06:33:30 <shapr> right, that
06:33:32 <johs> Oh. It uses that wacky literate programming stuff, too.
06:33:43 <johs> Heh.
06:41:56 <vegai> I wonder if darcs is compilable by nhc98?
06:43:52 <shapr> I doubt it, but it's possible
06:44:53 <Igloo> It would be nice if someone made it work
06:46:48 <vegai> my nhc doesn't want to compile "Hello World" yet, so the trying darcs might be tad optimistic
06:46:55 <vegai> s/the//
07:01:25 <shapr> ok, I'm soliciting jurors for the IOHCC again
07:02:34 <shapr> so far there's me and Marvin-- as confirmed jurors
07:02:46 <shapr> and several confirmed entrants :-)
07:03:05 <shapr> SyntaxNinja: hey, you want to be a juror?
07:03:52 <shapr> hm, I think I'll ping Wolfgang Thaller for jurorness
07:04:03 <shapr> Does he ever show up here?
07:04:26 <shapr> skew: what about you? want to be an IOHCC juror?
07:05:13 <shapr> I could ask stepcut also
07:06:54 <Igloo> Who are confirmed entrants, or is that top secret?
07:07:16 <shapr> well, you for one
07:07:41 <Igloo> Oh, err, who confirmed me?
07:08:09 <shapr> I thought you did :-)
07:08:31 <shapr> oh, I forgot to ask Pseudonym
07:08:35 * Igloo doesn't remember doing so, particularly as I don't have an entry  :-)
07:09:05 <shapr> do you have any suggestions for jurors?
07:09:56 <Igloo> No-one in particular
07:10:06 <Lunar^> shapr: Are you going to submit something for HC&A ?
07:10:24 <shapr> yes, several things
07:10:57 <shapr> lambdabot, HaWiki, gforge, IOHCC, #haskell, #haskell.se, haskell-libs, and PreludeExts
07:11:08 <shapr> what about you? a hOp entry surely?
07:12:25 <Lunar^> :)
07:12:30 <Lunar^> sebc agreed to do something :))
07:12:44 <shapr> excellent
07:12:46 <SyntaxNinja> shapr: don't think I'll ahve time for that. sorry.
07:12:57 <shapr> SyntaxNinja: no worries
07:13:17 <shapr> I thought that was likely
07:17:15 <shapr> I've been seeing OCaml weekly news on lwn.net
07:17:28 <shapr> I want one for Haskell!
07:17:57 <Lunar^> You know enough people and spend enough time here to do it, I'm sure :)
07:18:01 <shapr> do you guys think there's enough interesting stuff per week to warrant that?
07:18:15 <Lunar^> week... I'm not sure
07:49:09 <shapr> @fortune
07:49:10 <lambdabot> YOW!!  Up ahead!  It's a DONUT HUT!!
07:49:13 <shapr> @fortune
07:49:14 <lambdabot> Proper treatment will cure a cold in seven days, but left to itself,
07:49:14 <lambdabot> a cold will hang on for a week.
07:49:14 <lambdabot> 		-- Darrell Huff
07:51:53 <Lemmih> ?
07:54:38 <shapr> !
07:55:12 <Lunar^> shapr: Malcolm Wallace work on FP within embedded system is really interesting
07:56:36 <shapr> you could ask him about hOp, he may have some good ideas
07:59:33 <shapr> hi anduril1
07:59:44 <anduril1> hello
08:00:18 <shapr> what's going on?
08:00:19 <Lunar^> shapr: I should read his thesis and his other papers carefully before that
08:00:49 <shapr> Lunar^: yes, good idea
08:07:32 <shapr> earthy: have you gotten a bunch of submissions already?
08:15:36 <Lunar^> shapr: earthy is responsible for HC&A ?
08:16:09 <shapr> this time, yes
08:16:33 <shapr> then kosmikus after that
08:18:26 <Lunar^> Good to know that :)
08:20:37 <shapr> should I mention EuroHaskell in the hc&a?
08:26:27 <shapr> man, I wish optimistic haskell had made it into the core
08:26:41 <shapr> I think it's a great improvement
08:26:58 <shapr> Lunar^: are you busy?
08:29:23 <Lunar^> shapr: I'm taking a break right now
08:31:45 <norpan_> eurohaskell indeed
09:05:24 <shapr> unicycling, bbl
10:02:36 <shapr> yay, I can almost steer now!
10:02:55 <shapr> hi stepcut, wanna be an IOHCC juror?
10:05:02 <stepcut> hrm
10:05:08 * stepcut ponders what IOHCC might stand for
10:05:16 <stepcut> is that like IHOP?
10:06:01 <stepcut> ah, the obfuscated haskell contest..
10:07:35 * stepcut just got called for jury duty in san diego
10:12:04 <shapr> oh, is one enough?
10:22:11 <Si\> woah hws-wp has an error log of 54MB
10:22:22 <Si\> that's some size for a prototype web-server
10:25:29 <stepcut> shapr: i might be able to handle two 
12:32:54 <SyntaxNinja> is there any way to increase the stack space for a GHC_compiled program without using the runtime flags?
12:33:04 <SyntaxNinja> (I mean to do it during compilation)
12:35:02 <Igloo> I think there's something in the user's guide about that
12:36:16 <Igloo> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#RTS-HOOKS
12:41:30 <SyntaxNinja> thanks.
13:29:57 <Cale> Anyone know of a paper where HM is described?
13:33:39 <ski> hmm, maybe the SML standard ??
13:35:16 <emu> there are several easier to read books oo
13:35:21 <emu> too
13:35:54 <Cale> I was just looking for something online, as there's a person in #math who is working on type inference who hasn't seen HM yet.
13:36:08 <emu> hehe
13:36:17 <emu> and he's not in #sml, ocaml, or haskell?
13:36:53 <emu> i don't think sml is straight up HM though anyway, it has a module system
13:37:06 <emu> tell this fellow he should get a book 
13:37:22 <emu> "Types and Programming Languages" Pierce, I have, it's decent
13:37:47 <Cale> Here :)
13:38:09 <ski> emu : i've that too :)
13:38:25 <ski> (right in frony of me, actually)
13:40:34 <Spark_> heh
13:40:58 <Cale> <emu> tell this fellow he should get a book 
13:40:59 <Cale> <emu> "Types and Programming Languages" Pierce, I have, it's decent
13:40:59 <ski> 'lo Spark_
13:41:04 <Spark_> oh
13:41:05 <Spark_> lo
13:41:08 <Spark_> im famous
13:41:15 <ski> you are ?
13:41:16 <Spark_> i might visit the uni library then in that case
13:41:21 <Spark_> no i was joking :)
13:41:33 <Cale> Spark_ is the person that I mentioned wrt finding the paper on HM
13:41:36 <emu> infamous
13:41:42 <ski> oh :)
13:42:14 <Spark_> emu: i dont have much time to read a book though :)
13:42:27 <emu> dont have to read the whole thing
13:42:30 <Cale> He's designing a modelling language where he wants to do type inference.
13:43:03 <Spark_> it has been designed and implemented, now im criticising it, and one of the problems is the type algorithm doesnt work
13:43:12 <Cale> It's apparently dynamically typed, so I'm not sure how good of a fit HM is, but it would probably be useful to look at various solutions.
13:43:18 <emu> mostly what you do is create a set of type judgements and resolve parametric types with unification
13:43:28 <ski> Spark_ : are you interesting in just the inference rules ? or algorithm too ?
13:43:30 <emu> if it is dynamically typed, why aer you using type inferenec?
13:43:53 <Spark_> im not really au fait with all this terminology :)
13:43:58 <emu> for optimization?
13:44:00 <Riastradh> emu, uh, so that you get static type information?
13:44:24 <Spark_> emu: sorry i dont understand the question :)
13:44:50 <Spark_> its not that the types are static, and the chekcing is dynamic
13:44:52 <emu> dynamically typed means you don't need a static type system
13:44:55 <Spark_> its that the types themselves are dynamic
13:44:55 <Cale> Spark_: generally languages which are dynamically typed don't infer types.
13:45:19 <emu> though it doesn't preclude one
13:45:40 <Cale> Spark_: could the type of something change without the user editing it?
13:45:50 <Spark_> cale: no, definitely not
13:45:53 <emu> Spark_: what do you mean by that?
13:45:54 <Spark_> that would introduce serious problems :)
13:45:54 <Riastradh> emu, no, it means that type checks to prevent type errors occur at run-time.
13:46:09 <Cale> okay, then it's pretty much statically typed
13:46:18 <emu> Cale: uh, no
13:47:03 <Spark_> but unlike haskell, you can break parts of the network after doing the type inference
13:47:07 <Spark_> and then the types have to 'back down' again
13:47:18 <emu> ok
13:47:20 <Cale> Well, if the user sets up something, it's going to have static types in it.
13:47:28 <emu> you can dynamically redefine types at runtime?
13:47:31 <Spark_> typing has to be implicit too
13:47:38 <Spark_> emu: yeah
13:47:52 <Spark_> emu: like in a spreadsheet, you can put a string in a cell, or a number
13:47:58 <emu> you should check out common lisp; and particularl the python compiler used by cmucl, sbcl, and scl
13:48:16 <Spark_> emu: but here i want to prevent them putting a string in if the cell is used in a dependency which requires an int
13:49:04 <Spark_> those are languages ive never used :|
13:49:21 <Spark_> ive used sml, and i read a bit about haskell, and played with ghc for half an hour or so
13:49:41 <ski> how can one break parts of the network ?
13:49:42 <emu> well cl allows dynamic redef of classes, and python does type inference in CL, so you might find something useful
13:49:43 <ski> in what way ?
13:50:11 <Spark_> ski: its data flow, you break an edge and the data stops flowing, you can then connect it somewhere else
13:51:01 <Spark_> i imagine if the system was statically typed i would reduce all the types to their principal types, and the reconstrain the whole lot based on the remaining edges
13:52:19 <Spark_> this might slightly explain what im trying to do: http://rafb.net/paste/results/d2724335.html (but its quite badly written though)
13:52:54 <ski> how can edges be breaked ? by user only ? or by program ?
13:52:59 <Spark_> by the user
13:53:06 <Spark_> or the 'modeller'
13:54:11 <ski> but not by the program itself ?
13:54:20 <Spark_> no
13:54:23 <ski> ok
13:54:30 <Spark_> data flows and is computer by the program
13:54:38 <Spark_> the user has to be blocked from making edges that break the type rules
13:54:44 <Spark_> (each end of the edge must be the same type)
13:54:54 <ski> this seems related to incremental/adaptive computation, methinks
13:55:08 <Spark_> hmm thats interesting, what are they?
13:55:58 <ski> hmm, wait. i'll see if i can find the papers ..
13:56:31 <Smerdyakov> http://www-2.cs.cmu.edu/~umut/papers/
13:57:16 <ski> thanks smerdy :)
13:57:55 <Smerdyakov> No problem. My undergrad research advisor is one of the coauthors of those papers, so I know where to look. ;)
13:58:54 <ski> hmm, i think http://www.cse.ogi.edu/~magnus/papers/icfp-2002.pdf is also relevant
14:00:03 <Spark_> ill have a long, in the mean time, i just converted my presentation to html, check out http://www.fightingmonkey.co.uk/~spark/moo/img15.html and the slides immediately following it
14:00:11 <Spark_> that best demonstrates what i want to do (i think)
14:01:00 <ski> mm, yeah the first paper on smerdy's link and my one was the main papers i was thinking about
14:02:45 <Spark_> your link is about monads
14:02:52 <Spark_> i dont really understand them :)
14:03:08 <ski> heh
14:03:55 <ski> it's not so hard to understand (some of) what one can do with monads in programming, i think
14:04:21 <Spark_> yeah i guess, they seemed rather abstract though
14:04:37 <Spark_> its probably the sort of thing that you understand with usage, like pointers in C
14:05:09 <ski> i guess
14:06:01 <ski> hmm, what is your nonworking dependency loops ?  cycles in the type structure ?
14:06:53 <shapr> I think it's helpful to approach monads as "just another abstraction" much like objects in OOP
14:07:06 <Spark_> ski: where did i describe that? :)
14:07:16 <ski> http://www.fightingmonkey.co.uk/~spark/moo/img15.html
14:07:45 <Spark_> ah i see yes
14:08:06 <Spark_> my algorithm works only in the case of the network being acyclic
14:08:11 <ski> ok
14:08:15 <Spark_> because it tracks which direction the type is flowing down the edges
14:08:35 <Spark_> if its cyclic, a group of nodes will infer type from each other, even though there is no type to infer :)
14:08:50 <Spark_> check out the bottom diagram in http://rafb.net/paste/results/d2724335.html
14:09:18 <Cale> Monads are an abstraction of the idea of a computation. You can have a computation which always returns the same thing (a constant computation), and there's some way to take a value from a computation and pass it into future computations.
14:09:49 <shapr> hej bring you think EuroHaskell should have a mention in HC&AR?
14:09:56 <ski> basically a conceptual sequencing
14:10:14 <Spark_> cale: so its an alternative way of implementing an iterative language (other than tail recursion)
14:10:18 <shapr> Cale: how does that compare to arrows?
14:10:23 <Spark_> s/language/algorithm/
14:10:54 <shapr> bring: y0
14:11:08 <Cale> shapr: I haven't actually tried using arrows yet, but it seems like arrows allow for more looping.
14:11:26 <bring> was a while since I read an HC&AR, but why not
14:11:31 <shapr> ok
14:11:55 <bring> it's definitely a haskell community thing
14:12:00 <ski> (and the possibility of extracting 'static' info from an arrow)
14:13:39 <ski> Spark_ : hmm, you can't keep a trail (or perhaps mutable flags) to see if you encounter an already visited node ?
14:13:43 <shapr> he's back! don't say any more!
14:13:59 <Spark_> for the algorithm that infinitelooped?
14:14:04 <bring> :)
14:14:05 <ski> yeah
14:14:13 <Spark_> yeah thats a possibility, i havent looked into it
14:14:17 * shapr grins
14:14:35 <Spark_> ill just play with some diagrams and see :)
14:14:43 <ski> heh
14:14:48 <shapr> bring: hey, can you unicycle?
14:15:04 <bring> dunno, I've never tried
14:15:08 <ski> (category theorists play with diagrams, right ? :)
14:15:21 <shapr> ok, just curious
14:15:41 <Spark_> confused people play with diagrams :)
14:15:45 <shapr> I'm taking mine with me to EuroProgram
14:15:55 <Spark_> i have enjoyed being in a constant state of confusion whilst doing this project
14:15:55 <bring> cool
14:15:59 <ski> Spark_ : that too :)
14:16:21 <Spark_> you can actually run the software if you want :) it uses glib
14:23:43 <Spark_> didnt think anyone would want to :)
14:24:17 <ski> heh :)
14:24:54 <Spark_> to be honest, the internals are quite funky but the user interface is pants
14:25:20 <Spark_> its a command line interface with libreadline, but it doesnt have a proper lexer, so it fucks up if you put an extra " " on the end, for example :)
14:25:42 <Smerdyakov> LiBreadLine?
14:25:44 * ski smiles
14:25:46 <Smerdyakov> Why do you want bread with lithium in it?
14:28:39 <ski> hmm
14:28:48 <ski> i'm outta here !
14:28:51 <ski> goodbye
14:29:06 <Spark_> cya
14:29:06 <Smerdyakov> We'll miss you this_________________ much!!!
14:29:27 <ski> ;)
14:29:50 <shapr> hey guys, I put most of my HC&AR stuff here: http://www.haskell.org/hawiki/SandBox I'd be interested in constructive criticism
14:31:20 <shapr> I'm wondering if some of those items need more description
14:36:05 <shapr> hi Philippa 
14:36:10 <Philippa> 'lo
14:36:24 <shapr> what's up?
14:36:49 <shapr> haven't seen you in awhile, how's life?
14:36:52 <Philippa> kinda stressed out atm. Got a crapload of work at uni (it's my final year) and a bunch of other stuff going on
14:37:29 <Philippa> oh, and right now I'm trying to work out what GHCi's type checker's doing, it's coming up with some class memberships that don't make sense to me
14:37:42 <shapr> got some examples?
14:37:52 <Philippa> a nice short one
14:38:05 <Philippa> f a b = 
14:38:05 <Philippa>   do c <- addListToFM a b
14:38:05 <Philippa>      return ()
14:38:30 <Philippa> apparently this results in a requirement that (finiteMap key) is a member of Monad
14:38:38 <Philippa> sorry, FiniteMap even
14:40:11 <shapr> why are you using do?
14:40:45 <shapr> I think the do and return are saying that you want it to be a monad
14:40:51 <kosmikus|away> yes, it does, because you use a FiniteMap value to the right of an arrow <-
14:41:02 <Philippa> kosmikus|away: *d'oh*! Thanks
14:41:06 <shapr> hoi kosmikus
14:41:10 <kosmikus|away> hoi
14:41:14 <kosmikus|away> I'm away ...
14:41:16 <Philippa> usually it's more obvious when I've missed a return out by accident
14:41:23 <shapr> oh, sorry :-)
14:41:49 <kosmikus|away> don't be sorry, I just wanted to state that you shouldn't be surprised if I don't answer anymore ...
14:41:56 <shapr> Cale: hey did I misspell something?
14:42:43 <Cale> yeah
14:43:04 <Philippa> shapr: how 'bout you, anyway?
14:43:15 <Cale> "The #haskell.se is the same sublect but discussion happens in Swedish."
14:43:33 <Philippa> have to admit I wasn't expecting to be remembered given how little time I've spent in here
14:43:49 <shapr> life is good, my bookkeeper is trying to persuade me to buy more hardware
14:43:57 <Philippa> heh
14:44:25 <shapr> oh, and I'm learning more about Haskell, wanna see Curryspondence?
14:44:33 <Philippa> sure, what the hell
14:44:46 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
14:44:49 * Cale is away: stargate
14:44:53 <shapr> Cale: thanks
14:44:59 <Cale> np
14:46:06 <Philippa> hmm, think I'll bookmark that
14:46:31 <shapr> Philippa: that took less than 200 lines of code and about four evenings to write
14:46:47 <Philippa> cool
14:47:09 <shapr> credits to bring and stepcut for lots of HaskellDB and WASH help
14:47:25 <Philippa> I'm playing around with a port of the H-M typechecker from Cardelli's '88 paper atm, want to play around with a few ideas
14:47:56 <shapr> I haven't gotten around to inhaling Cardelli's work
14:48:23 <shapr> looks like it'll be fun though
14:48:35 <Philippa> the '88 paper's just a simple intro, a friend who works mostly with ML pointed me at it. I'll prolly read more later though
14:48:45 <shapr> I'm enjoying Pierce's TaPL
14:48:52 <Philippa> yeah, been bashing my way through that
14:49:23 <Philippa> should go back a second time and do the maths more seriously though, I'm always a bit undisciplined about that and if the book doesn't point out anything deep/important in it in the text as well that's a problem
14:49:43 <shapr> you could also use that book as a self-defense weapon in some cases
14:49:49 <Philippa> heh
14:50:06 <Philippa> I suspect it'd slow me down too much to be worthwhile, but you could shove a strap on it and use it as a shield...
14:50:17 <shapr> I think those bricks on the cover are a visual pun
14:50:43 <shapr> heh, yes
14:51:07 * bring used TaPL to beat his way to a danish liquor store today
14:51:15 * shapr laughs
14:51:28 <Philippa> one thing I do mean to follow up at some point is type systems that were /meant/ to be turing complete, to see if it'd suggest a better way to design something along the lines of C++'s template setup
14:51:34 <shapr> bring: are you stocking up for EuroHaskell?
14:51:39 <bring> yes
14:51:46 <shapr> awesome :-)
14:51:56 <bring> if it'll last til june
14:52:18 <shapr> Philippa: you could come to EuroHaskell in sweden, it's a hackfest
14:52:29 <Philippa> heh. Really can't afford it :-(
14:53:00 <bring> where do you live?
14:53:05 <shapr> lodgings at SGS Veckostader are something like ten euro a night
14:53:08 <Philippa> Nottingham, UK
14:53:18 <Philippa> the travel alone's too much
14:53:34 <shapr> and the entrance fee is one beer to put into bring's fridge
14:53:48 <Philippa> heh
14:54:06 <bring> isn't it like 10 pounds to go with RyanAir Stanstead -> Gothenburg?
14:54:28 <Philippa> I can't even afford to get to Stanstead atm
14:54:34 <shapr> wow
14:54:47 <emu> Philippa: what of higher-order functors?
14:55:04 <bring> maybe your department can sponsor your trip
14:55:15 <bring> we can make up a fancy invitation
14:55:20 <Philippa> not until I know exactly how much my living expenses are next year, anyway, and I'm gonna have to look damn hard to get anywhere that isn't hard up against what I can afford
14:55:21 <Philippa> heh
14:55:35 <Philippa> well, if you want to send one to myself cc'ed to Graham Hutton that might work :-)
14:56:14 <Philippa> unfortunately I don't get the impression they do that kind of thing for undergrads often, but hey
14:56:31 <shapr> well, if John Hughes is showing up, why not Graham Hutton
14:56:58 <shapr> bring: any idea if Koen is interested?
14:57:02 <Philippa> emu: I don't know enough to have a go. My maths is woefully poor, I've got a lot of reading to do, and I haven't really used functors as a programmer so I've no intuition for them
14:57:25 <emu> functors are parameterized modules, basically
14:57:29 <Philippa> shapr: gmh is my dissertation supervisor btw
14:57:39 <shapr> nice
14:57:52 <Philippa> yeah, I'd sort of gathered that much. Unfortunately I've not really had the chance to use a module system more complicated than namespacing and data hiding
14:58:08 <bring> shapr: dunno, don't know him, only met him a few times
14:58:24 <Philippa> but yeah, it sort of makes sense, I'd just need to think properly for a couple of hours :-)
14:58:24 <shapr> ok, I'll prod Marvin--
14:58:35 <emu> for example, if you have a Table functor, you could create an IntTable = Table (structure K = IntOrdering)
14:58:44 * Philippa nods
14:58:53 <shapr> bring: anyone that still needs inviting?
14:58:59 <Philippa> I think I've suggested similar as the one real excuse for the singleton pattern in C++
14:59:00 <bring> I'll try to get around to mentioning eurohaskell to the multigroup
14:59:19 <Philippa> well, one of two, but "I need a constructor!" /really/ screams deficiency
14:59:21 <emu> where IntTable uses the IntOrdering module to find and order table elements
14:59:49 <emu> and higher order functors would be functors that accept and produce functors as arguments and results, as in SML/NJ
15:00:04 <shapr> would be good
15:00:39 <Philippa> which starts to sound a lot like what a "proper" theoretical model for C++ templates would be, I guess. Yeah, makes sense
15:00:53 <shapr> I think I sent that reply to Pete saying he can invite any gothenburg haskellers
15:00:56 <emu> i imagine just about anything would be better than C++ templates =)
15:01:07 <Philippa> well yeah :-)
15:01:13 * shapr checks
15:01:52 <emu> i like functors, but right now SML suffers from problems with mutually recursive modules, and I don't know how to resolve this (though apparently there is someone writing a dissertation on the matter)
15:02:04 <shapr> oh, no I didn't
15:02:07 <shapr> oops
15:02:14 <Smerdyakov> And he should be just about done, if he isn't already, since he already has a postdoc position lined up. :)
15:02:35 <emu> peter lee says he's just about done
15:04:11 <Philippa> bring: could hand you an email addy if you're feeling silly enough to invite myself and Graham :-)
15:06:50 <Spark_> heh lo Philippa 
15:07:07 <Philippa> 'lo Spark
15:07:30 <Philippa> I whoised it to check you're who I thought you were earlier on, figured I'd wait for you to say hi though :-)
15:07:38 <Spark_> heh ok
15:08:12 <bring> shapr: what do you say? are we silly enough?
15:08:52 <bring> Philippa: do you have any cool work that we could invite you to present?
15:08:56 <Philippa> heh
15:09:09 <Philippa> unfortunately not really. A bit of hacking about but nothing actually working atm
15:09:27 <Philippa> would love to otherwise, been in a bit of a state to work on my project recently though :-(
15:09:37 <bring> doesn't have to work
15:09:40 <Philippa> hehehe
15:09:40 <shapr> I am a fount of silliness.
15:09:59 <bring> I said present, not demonstrate :)
15:10:08 <bring> or rather "invite to present"
15:10:49 <Philippa> well, what I'm currently playing around with (and there's nothing down on paper really yet) is adding a fairly simple subtyping relationship to H-M - treat the constructors within an ADT as their own types with the "main type" as their supertype
15:11:34 <Philippa> really basic, was thinking it might be fun to go from a two-layer setup to hierarchical - I can't imagine nobody's done it before, but hey
15:11:39 <shapr> if you furnish the email address, I'm willing to send an invititation
15:11:41 <Philippa> do I have to actually present it? :-)
15:11:42 <Philippa> cool
15:11:56 <Philippa> either flippa@flippac.org or (the uni account) pjc00u@cs.nott.ac.uk
15:12:00 <Philippa> figure you've got gmh's addy already
15:12:21 <bring> damn, we're getting serious about this thing
15:12:33 <shapr> this an emergent gathering, anything can happen
15:12:39 <Philippa> heh
15:12:49 <bring> I'd better make sure that they're going to let us have a room
15:12:50 <Spark_> when is it?
15:12:58 <bring> june 10-12
15:12:59 <Philippa> bring: uh, yeah... :-)
15:13:13 <Philippa> hmm, crap, I'd better check when the grad ceremony here is, I've a horrible feeling it's then...
15:13:21 <shapr> http://www.haskell.org/hawiki/EuroHaskell
15:13:33 <Spark_> just after exams
15:13:34 <Philippa> nope, it's the 5th :-)
15:14:21 <shapr> the original motivation was to get together to write code, do something cool
15:15:12 <Spark_> ive scheduled learning haskell in for that period anyway :)
15:15:30 <shapr> bring: I say inviting lotsa people doesn't necessarily mean serious :-)
15:15:40 <bring> :)
15:16:17 <shapr> our confirmed list is still pretty small
15:16:51 <bring> Spark_: you're coming then?
15:17:11 <Spark_> i dunno i doubt it to be honest :)
15:17:26 <shapr> would be an efficient way to learn Haskell, hack with those who use it lots
15:17:26 <Philippa> I figure you'd learn Haskell pretty damn fast...
15:17:29 <Spark_> ive never gone to sweden but i dont think i can afford it, i also think i might have an interview at that time
15:17:47 <Spark_> thats a good point though, i dont wanna be in anyones way :)
15:18:13 <shapr> I'm looking forward to hacking with the Gothenburg crowd, I'm sure I'll learn lots.
15:18:47 <Spark_> ill wait until closer to the time, when i'll have more of a clue whats going on and if i can afford it, it does sound like a cool experience though
15:18:56 <shapr> Spark_: all skill levels welcome :-)
15:19:29 <bring> ryanair: 2.49 GBP stanstead -> gothenburg
15:19:38 <Philippa> how about back again? :-)
15:20:08 <bring> hmm, 179.99 GBP
15:20:09 <shapr> plus EuroPython is happening directly before, so it should be invasion of the programmers
15:20:37 <bring> ah, there you go,  8.99 GBP
15:20:46 <Spark_> thats pretty damn cheap
15:21:11 <shapr> geez, it's much more expensive to fly from Lulea to gborg
15:21:11 <Philippa> I'd imagine the fact they don't have to do half the security they do with US flights helps
15:21:17 <bring> would probably need to book that pretty soon, I don't think they have a lot of seats at that price
15:21:30 <bring> those prices don't include airport taxes
15:21:38 <Spark_> i went to finland last summer, but that was in the thousands, and we had to go via copenhagen
15:21:57 <bring> plus the airport shuttle probably costs more than that
15:22:18 <Spark_> and getting to stanstead :)
15:22:22 <shapr> I hope they let me take my unicycle on the plane, I should probably check that out beforehand.
15:22:36 <bring> not in the cabin I hope :)
15:22:43 <bring> could be fun though
15:22:45 * shapr laughs
15:23:18 <shapr> that's a great mental image
15:23:55 <shapr> the EuroHaskell logo is spiffy
15:24:20 <bring> Spark_: are you in nottingham too?
15:24:32 <shapr> Spark_: are you part of the Philippa/gmh group?
15:25:14 <Philippa> he's at Warwick last I heard
15:25:15 <shapr> should I add you to the invite list?
15:25:41 <Philippa> I ended up hanging around their compsoc's IRC server for a whole bunch of reasons
15:25:42 <shapr> I've never been to the UK, does that mean far away?
15:26:03 <Spark_> im in coventry
15:26:14 <shapr> I'm not an EU citizen...
15:26:20 <shapr> what does that mean?
15:26:39 <Spark_> heh
15:26:47 <Spark_> i live about... 60/70 miles south of Philippa 
15:26:52 <shapr> ah, ok
15:26:54 <Spark_> i can drive though so its not a problem to get around
15:27:02 <Spark_> closer to stanstead
15:27:12 <shapr> but can you ride a unicycle? ;-)
15:27:43 <Spark_> :)
15:27:48 <bring> should the agenda really be
15:27:51 <Spark_> unfortunately not
15:27:52 <bring> #  Beer
15:27:52 <bring> # ...
15:27:52 <bring> # Profit!
15:28:07 <shapr> leave uot the hacking??
15:28:10 <bring> hmm, missed a # Hacking there
15:28:14 <shapr> whew
15:28:28 <shapr> that's the chewy center!
15:28:35 <shapr> it's the good part!
15:28:48 <bring> cut-and-paste snafu
15:28:56 * Philippa wonders idlemindedly how her boyfriend'd cope
15:29:06 <shapr> of course, beer is good for relaxing and getting to know people
15:29:18 <shapr> Philippa: is he a coder too?
15:29:20 <Philippa> he doesn't code atm, but I've a feeling he'd quite enjoy functional programming after a few hours getting used to the idea
15:29:44 <Philippa> what little exposure he's had to algorithms etc (courtesy of an A level maths module, mind) he's liked
15:30:10 <Philippa> OTOH he might just sit there, decide we're all geeks and then go gooey because he's bi and he /likes/ geeks :-)
15:30:10 <bring> shapr: you're going to have to do a presentation on how to ride a unicycle
15:30:15 <shapr> haha
15:30:26 <shapr> and one on contact juggling
15:32:24 <shapr> I really think we should invite Simon^2 on the off chance they're not busy then
15:32:30 <bring> should we add a list of possible presentations to the wiki?
15:32:37 <bring> sure, why not?
15:32:39 <shapr> yes, good idea
15:33:27 * Philippa wonders idly if anybody calls TaPL "the brick book"
15:33:37 <Philippa> "lob 'arf a brick book at 'im!"
15:33:39 <shapr> oh, let's start that!
15:33:47 * shapr laughs
15:34:23 <shapr> the white book, the wizard book, the brick book
15:34:33 <shapr> the bat book is infamous
15:35:01 <shapr> many people are aware of the Camel book
15:35:30 <shapr> what other famous programming books?
15:35:42 <Philippa> well, I'd been thinking of the dragon book
15:35:48 <shapr> oh, yes!
15:35:53 <Philippa> dunno if anybody refers to Appel's compiler books as the tiger book(s)
15:35:54 <shapr> Aho and Ullman
15:36:18 <Philippa> prolly been used by an O'Reilly as well though
15:36:45 * Philippa wonders if there's a Lemming Book
15:36:59 <Philippa> one of the How to Program in C++ in 24 Hours books, maybe
15:37:13 <shapr> or all of them :-)
15:37:22 <bring> Philippa: someone did call one of the the tiger book here the other day
15:37:25 <shapr> "it's a lemming book"
15:37:47 <bring> Philippa, shapr: put you down for some presentations
15:38:09 * shapr laughs
15:38:24 <Spark_> :o
15:38:31 <shapr> I can't do those at the same time yet!
15:38:52 <Spark_> im concerned about how similar parts of http://www-2.cs.cmu.edu/~umut/papers/toplas04.html are to what ive been doing :)
15:39:23 <shapr> hm, I've got ~ 2 months to learn
15:40:18 <Philippa> Spark_: just write yours from the other POV and brush over it for now, 'shardly your fault given that you started from opposite ends
15:40:57 <Spark_> heh actually im glad cos it means i was right :)
15:41:14 <shapr> Philippa: you prefer personal or uni account for your invite?
15:42:20 <Spark_> dependency was used by beynon et al because it allows the modeller to express a construal in terms of observables and cause and effect
15:42:23 <bring> Philippa: you're welcome to clarify your presentation topic at on th wiki page
15:42:30 <Philippa> hmm. Uni if it's being CCed to gmh
15:42:31 <bring> http://www.haskell.org/hawiki/EuroHaskell
15:42:33 <bring> that is
15:43:13 <Philippa> yeah, I took a look - will do sometime, like when I've found out if uni'll bankroll it or not
15:43:21 <Philippa> I figure I'll have to supply the entrace fee myself :-)
15:43:41 <bring> noooo, not more beer
15:43:58 <bring> well, maybe if it's english
15:44:13 <shapr> heh!
15:44:23 <shapr> they do make good beer over there
15:44:37 <shapr> I'm fond of Boddington's
15:44:46 <Philippa> yeesh, I'll have to bring some *real* beer with me...
15:45:20 <Philippa> a few Hobgoblins might be a good start, that's fun
15:45:27 <shapr> bring: oh hey, we could list the EuroHaskell organizers on that page too
15:45:42 <shapr> or disorganizers as the case may be
15:45:59 <shapr> Philippa: that's a beer?
15:46:04 <Philippa> yeah
15:46:09 <Philippa> a damn nice one, too
15:46:24 <bring> should say something about it all being [dis]organized in #haskell
15:46:27 <Philippa> don't see it in pubs often though, usually it's available bottled
15:46:34 <shapr> yah, good point
15:47:27 <Philippa> bottled ales're generally good over here, boddies doesn't really taste of much in comparison
15:47:49 <Philippa> just shoved a v.brief note on who I am under the obvious place on the wiki btw
15:47:59 <Philippa> just gives a nick for now, but hey
15:48:08 <Spark_> yeah hobgoblin is fantastic
15:48:26 <Spark_> and some of the others from the same brewery
15:48:28 <Spark_> wychwood is it?
15:48:31 <bring> having a wiki for a homepage is really nice
15:49:02 <Spark_> ive seen it on tap once, in the windmill in old spon street
15:49:33 <Philippa> yeah, wychwood
15:49:49 <Philippa> lucky git :-)
15:50:05 <Philippa> bring: yeah, I played around a little with one on my desktop
15:50:14 <Philippa> actually, that might be an excuse for an HTML background
15:50:47 <Philippa> (spot the win32 user - my excuse is gaming...)
15:51:15 <shapr> ut2004 is 64bit only on Linux!
15:51:23 <Philippa> :-)
15:51:31 <Philippa> there's far too much stuff doesn't run at all under it though, sadly
15:51:52 <bring> Philippa: have you tried WineX?
15:52:04 <shapr> I got better performance from CounterStrike in Linux than in win32
15:52:22 <Philippa> nope, probably ought to but I'm not impressed by the development model - mostly because I hack up some DX-based stuff myself occasionally
15:52:56 <Philippa> I'm running linux on my router, had it as a desktop box also running it for a while and would do so again
15:53:21 <shapr> my major problem is drivers
15:53:26 * Philippa nods
15:53:34 <bring> shapr: for what hardware?
15:53:53 <shapr> nvidia drivers are the best, but they still have serious SMP problems
15:54:06 <shapr> but they're closed source!
15:54:08 <bring> hmm come to think of it, I don't have 3D drivers for my laptop
15:54:28 <bring> and I use the nividia drivers on my desktop
15:54:33 <bring> you're right
15:54:36 <Philippa> have to admit I've not had any problems with ATI's drivers on a 9700 under win32
15:54:49 <Philippa> I've no idea what the situation's like under linux though
15:55:07 <shapr> the latest nvidia drivers are so unstable on 2.6 with SMP that I've switched to the nv driver that comes with X
15:56:00 <shapr> I've heard the nvidia drivers are wonderful on uniprocessor machines
15:56:15 <bring> shapr: they're ok
15:57:01 <shapr> do they compare with their win32 equivalents?
15:57:19 <bring> dunno
15:57:33 <bring> haven't used those for years
15:57:55 <shapr> same here, I don't even have a copy of windows
15:58:04 <bring> I only use windows to run windows update
15:58:10 <shapr> oh, I do have win3.1
15:58:11 <bring> which feels a little pointless
15:58:28 <shapr> :-)
15:58:56 <bring> win 3.1, brings back memories
15:59:23 <bring> we seem to have drifted off topic btw
15:59:25 * shapr prods Philippa to write a bit more on her page
15:59:36 <Philippa> heh
16:00:10 <shapr> see, I'm the HaWiki maintainer, so I have a valid reason to ask for more stuff :-)
16:00:14 <Philippa> done
16:00:15 <Philippa> :-)
16:00:36 * shapr snickers
16:01:43 <shapr> bring: hey, BjÃ¶rnBringert doesn't link to you
16:01:54 <shapr> oh, I can make a forward
16:02:16 <bring> ah, I skipped the dots
16:02:37 <bring> I never use those in anything non-swedish
16:04:32 <shapr> dots are cool, we don't have them in the US
16:04:33 <bring> decided that my english name doesn't have dots just to make things easier
16:04:39 <shapr> only ij.
16:05:12 <shapr> a-ring is also very cool
16:05:18 <bring> that's why I thought that US systems would go nuts if I insisted to spell my name right
16:05:26 <shapr> swedish has all the nifty tricks
16:05:43 <shapr> well, MoinMoin was written by a german
16:06:00 <shapr> Juergen Hermann specifically
16:06:11 <bring> I was thinking of ancient student information and payroll systems
16:06:24 <shapr> oh, probably so
16:07:17 * bring likes the czech letter u-ring
16:07:31 <shapr> speaking of swedish, I bet you guys will love my alabama + boden accent
16:07:42 <bring> can't wait to hear it
16:08:02 * shapr grins
16:09:58 <shapr> oh what's the word on a room and 'net connect?
16:10:47 <bring> talk to a friend who works in IT, they'll be able to set it up, but the department may have to pay the a little to do it
16:11:08 <bring> I'll have to check with the department, it depends on their contract with IT
16:11:29 <shapr> cool
16:15:57 <shapr> g'day Pseudonym 
16:16:00 <Pseudonym> G'day.
16:16:15 <shapr> wanna do IOHCC juror again? :-)
16:16:24 <Pseudonym> Oh, we doing it again?  Sure.
16:16:27 * Pseudonym won't enter this time
16:16:41 <shapr> oh gmh spent two years at chalmers
16:17:09 <shapr> yah, Marvin-- is a juror also
16:19:04 <shapr> Pseudonym: you're invited to EuroHaskell, but I bet it's a bit far
16:21:06 <Pseudonym> Yes, it is, but thanks.
16:21:20 <shapr> Pseudonym: reading anything interesting lately?
16:21:24 <Pseudonym> Hey, you can come to the next LUV meeting if you want, but it's also a bit far.
16:21:31 <Pseudonym> http://www.luv.asn.au/node/view/145
16:21:48 <Pseudonym> I'm reading a book on group theory at the moment.
16:22:05 <Pseudonym> 'Cause the book on Galois theory said things like "We recall from group theory that..."
16:22:10 <Pseudonym> And I recalled no such thing. :-)
16:22:20 <shapr> which book?
16:22:35 <Pseudonym> Which one?  I mentioned too.
16:22:36 <Pseudonym> two
16:22:54 <Pseudonym> "Galois Theory", second edition, by Ian Stewart.
16:23:00 <bring> how big and what kind of room do we wnat?
16:23:00 <shapr> Spark_: you want to receive the invite also?
16:23:15 <shapr> bring: what are the options?
16:23:17 <Pseudonym> "A Course on Group Theory" by John S. Rose.
16:23:31 <Pseudonym> Anyway, I'm surprised how much category theory language is worked in without mentioning categories once.
16:23:38 <Spark_> shapr: sure, spark@xdev.net
16:23:39 <Pseudonym> When you read between the lines.
16:23:43 <bring> not sure what we could book
16:23:44 <shapr> is that CT book better/worse than the coceptual math one?
16:24:00 <Pseudonym> shapr: Neither of these are on CT.
16:24:02 <Spark_> i must be one of hte few irc users that has their email address as their user@host :)
16:24:40 <shapr> well, if IPv6 ever hits the big time...
16:24:47 <shapr> Pseudonym: oops
16:25:08 <Pseudonym> One thing I've noticed about these "new ideas" in maths, is that books tend to be either so basic that they barely scratch the surface, or they assume a large amount of prior knowledge.
16:25:39 <shapr> ha --> "There will be pretty pictures. Many of them will feature teapots."
16:25:50 <Pseudonym> I started reading Asperti and Longo, for example, when I noticed a copy on a cow-orker's desk.  Scott Domains (whatever they are) becomes the big running example in chapter 2.
16:26:14 <shapr> never heard of 'em
16:27:23 <Pseudonym> Never heard of 'em either.
16:27:40 <Pseudonym> If I had infinite time, there's a whole series of books begging to be written.
16:27:47 <Pseudonym> Mathematics for amateurs.
16:29:13 <shapr> what's blinn's law?
16:29:18 <Pseudonym> Oh.
16:29:25 <bring> I've never been to a code conference, what do people seem to want, one small room where everyone hangs out and codes, and then once in a while someone presents something there
16:29:28 <Pseudonym> That's the converse to Moore's Law.
16:29:45 <Pseudonym> It's a rule of thumb in the computer graphics industry.
16:29:51 <bring> or should presentations be somewhere else
16:29:53 <shapr> Ive never been to one either
16:30:01 <Pseudonym> Blinn's Law states: The amount of time taken to compute a film frame remains constant over time.
16:30:05 <Philippa> Pseudonym: "Soon, things will be fast"
16:30:17 <Pseudonym> The point being that audience expectation rises at the same rate as hardware improvements.
16:30:51 <shapr> I think it's likely that several (3 or 4 ?) smallish rooms would be best 
16:31:35 <Pseudonym> Oh, shapr, while you're here.
16:31:35 <bring> and one larger room for presentations?
16:31:42 <Philippa> yeah. At least one of them without computers, so there's somewhere to just sit down (and possibly bash stuff out on paper)
16:31:47 <shapr> because then all the hOp hackers can be in one room, all the webapp guys in another, and the presentations in its own
16:32:02 <Smerdyakov> Are you trying to get free space and hardware at a university for an event not really affiliated with that university?
16:32:04 <Philippa> I'm up for hOp btw
16:32:13 <bring> so, would most people bring their own machines?
16:32:15 <Pseudonym> Need you to add someone as a developer to haskell-libs.
16:32:30 <shapr> Pseudonym: aren't you an admin?
16:32:35 <Pseudonym> No.
16:32:37 <shapr> if not, want to be?
16:32:46 <Philippa> hmm. Don't have a lappy. Suppose I could probably pack Shortarse (currently my router) if Damien doesn't complain too much
16:32:52 <Pseudonym> Might as well.
16:32:55 <bring> Smerdyakov: basically, yes
16:33:15 <Smerdyakov> bring, wouldn't it be more reasonable/ethical to split the costs that the university faces to provide these things?
16:33:16 <Pseudonym> The guy who wrote the in-process relational database is interested in hosting it on haskell-libs.
16:33:41 <shapr> Pseudonym: ok, the admin oath, do you solemnly swear to look at the site at least once a year? ;-)
16:33:55 <Pseudonym> shapr: I'll try.
16:33:59 <Pseudonym> Good enough?
16:34:00 * shapr grins
16:34:11 <shapr> yah, that's great
16:34:28 <bring> well, it doesn't really cost them anything, and I've got a professor to agree to the department will help out
16:35:08 <bring> a lot of haskell people in the CS department
16:35:36 <bring> hmm, s/to/that/
16:36:30 <Smerdyakov> It _does_ cost them something. They have to pay for electricity, maintenance, etc..
16:36:47 <shapr> we further the goals of the uni, I think they should pay us
16:36:55 <Smerdyakov> If you aren't using the space, other activities can use it, removing the need to pay for additional electricity, maintenance, etc..
16:37:16 <bring> well, it's during the summer break, not much going on then
16:37:48 <Smerdyakov> Consider just the electricity costs alone of all that computer equipment and activity!
16:38:00 <shapr> Smerdyakov: feel free to organize a better usage of those rooms
16:38:08 <Philippa> Smerdyakov: about the same as heating a couple of rooms with electricity, I'd imagine
16:38:20 <Philippa> at least, assuming nobody runs two computers for themself
16:39:22 <Philippa> anyway, I really ought to head to bed
16:39:31 <Philippa> meant to 3 hours ago, I think Damien's getting fed up :-)
16:39:36 <bring> we're going to wear out the lambda keys on all the keyboards!
16:39:37 <shapr> g'night Philippa 
16:39:42 <shapr> haha!
16:39:44 <bring> good night
16:43:51 <shapr> we need a motto.... hmmm
16:44:31 <Pseudonym> EuroHaskell, you mean?
16:44:50 <shapr> I wonder if "We put the code into CODEpendent" is a little too silly even for me.
16:44:57 <shapr> yes
16:45:08 <Pseudonym> shapr: No, it's not too silly for you.
16:45:13 <Pseudonym> You did ask.
16:45:16 * shapr laughs
16:46:25 <Pseudonym> There might be a good Perlis quote you can use.
16:47:00 <Pseudonym> Oh, good quote!  Not relevant for a EuroHaskell slogan, but still.
16:47:11 <Pseudonym> "A programming language is low level when its programs require attention to the irrelevant."
16:49:32 <shapr> Pseudonym: tada, you're an admin
16:49:37 <Pseudonym> Woohoo!
16:49:51 <Pseudonym> Does the Lady of the Lake throw me a scimitar?
16:50:10 <Pseudonym> Ah, good slogan.
16:50:16 <shapr> no, we're into point-free programming here
16:50:24 <Pseudonym> "There ain't no such thing as a free variable."
16:50:32 <shapr> oh, that's good
16:50:54 <Riastradh> Pseudonym, I dislike that quote.  I find that memory management is very relevant in a garbage collector, yet you typically write a garbage collector in a low-level language.
16:51:45 <Pseudonym> Riastradh: Actually, it makes a lot of sense if you think about it.
16:51:58 <Pseudonym> In some sense, there's no such thing as "low-level" or "high-level".
16:52:02 <Pseudonym> There's only "too low-level".
16:52:08 <Pseudonym> Or "too high-level".
16:52:14 <Pseudonym> For a specific problem.
16:52:55 <Pseudonym> If YOUR program is dealing with irrelevancies out of necessity, then it's written in a language that is too low-level.
16:54:29 <Riastradh> Given a set of programs S and problems M, the high-level languages are those for which there is a large subset of M such that one subset of S is at the right level and another is too low-level; likewise for low-level languages.
16:54:42 <Riastradh> Er, vice versa for low-level languages, rather.
16:55:13 <Pseudonym> Yes, I'll buy that.
16:55:27 <Riastradh> QED.
16:55:29 * Riastradh wins!~
16:55:38 * Riastradh even wins with a tilde, too!
16:55:43 <Pseudonym> However, the definition is circular.
16:55:56 <Riastradh> How so?
16:57:00 <Pseudonym> You defined high-level languages in terms of problems for which some languages are too low-level.
16:57:11 <Pseudonym> Assuming that high-level is the antonym of low-level, that's circular.
16:57:27 <Riastradh> No, because I was provided with the definitions of '_too_ high-level' & '_too_ low-level' by you.
16:57:36 <Pseudonym> Ah, gotcha.
16:57:56 <Pseudonym> So I win by extension?
16:58:04 <Pseudonym> Since your definition is based on mine?
16:58:32 <Riastradh> Certainly not.  I, the winner, allow you a morsel of a cookie for having provided me with those definitions, and nothing more!
16:59:18 <Pseudonym> Cool.  I'm not proud.
16:59:35 * Pseudonym : Will provide technical definitions for food.
17:00:46 * shapr grins
17:02:39 <shapr> I'll worry about a motto tomorrow
17:02:45 <bring> Pseudonym: define mashed potatoes
17:02:56 <shapr> oy :-)
17:03:03 <Pseudonym> bring: Mmmm.  Mashed potatoes.
17:05:00 <shapr> the QuotesPage has some real gems
17:15:51 <shapr> bring: at the bottom of the EuroHaskell page, does that look like a sane invite? 
17:18:11 <bring> it'd make me want to come, though I'm not sure if a CS department would pay for students to go to a "hackfest" with their "relaxing beverage of choice"
17:18:23 <shapr> heh
17:18:41 <shapr> what's better?
17:18:57 <shapr> is there a politically correct way to say the same thing?
17:19:11 <bring> not that the professors would mind, but I have a feeling there are beancounters that would frown upon having that in the expenses
17:19:18 <bring> hmm
17:19:41 <Pseudonym> "Refreshments provided"?
17:20:05 <shapr> actually, I was trying to say BYOB
17:20:09 <Pseudonym> Ah, OK.
17:21:04 <Pseudonym> BTW, caffeinated beverages (the choice of many discriminating hackers) is hardly relaxing.
17:21:14 <Pseudonym> s/is/are/
17:21:55 <shapr> get-together, sprint, and gathering were suggesetd by Marvin-- and Igloo 
17:22:15 <shapr> sprint is a good term
17:22:37 <Pseudonym> Where's the page?
17:22:46 <shapr> http://www.haskell.org/hawiki/EuroHaskell
17:24:17 <Pseudonym> There is no entrance fee, and participants are encouraged to bring any legal refreshments they see fit.
17:24:25 <Pseudonym> I think that covers all bases?
17:26:59 <bring> maybe we coud say something about food and drink not being supplied, that way you don't have to interpret it as "bring lots of beer"
17:27:34 <Pseudonym> Good point.
17:27:44 <Pseudonym> "Food and drink are not supplied, but feel free to bring your own."
17:27:46 <shapr> yes, that's diplomatic
17:27:56 <Pseudonym> "or to share"
17:27:58 <Pseudonym> I suppose.
17:39:00 <shapr> I guess 'gathering and sprint' doesn't imply a 'real' conference, and also doesn't have the word 'hack'
17:39:51 <bring> is that good or bad?
17:40:28 <Pseudonym> In what sense is this a conference?
17:40:33 <Pseudonym> Will there be organised presentations?
17:40:45 <shapr> well, maybe?
17:41:23 <shapr> I'm tempted to give a presentation on dynamic loading in GHC
17:41:47 <bring> I think hram might drop by too
17:42:07 <shapr> oh, he knows more about it than I do
17:42:19 <chucky> I'd love to hear hram talk about that! I haven't had time to look at it, but it seems too cool to pass up
17:43:27 <bring> presentations would be nice
17:43:47 <bring> I'm trying to get John Hughes to present something
17:43:57 <chucky> I like listening to talks about things. So much easier for me than to actually READ something. :)
17:43:57 <shapr> that would be cool
17:44:19 <shapr> I *really* want an arrows talk from him
17:45:06 <bring> that would be nice
17:45:44 <bring> he's in estonia right now, I'll bug him when he gets back
17:46:40 <shapr> cool
17:46:47 <shapr> I hope he shows up
17:49:02 <chucky> John is an excellent talker, so whatever he would talk about, it would be good. :)
17:49:17 <Pseudonym> One thing that would be interesting is the "5 minute talk".
17:49:26 <Pseudonym> You get people to say whatever they want, but they get cut off at 5 mins.
17:49:33 <Pseudonym> They do that at Perl conferences, and it's really interesting.
17:49:43 <shapr> I've only heard him ask questions at ICFP03
17:50:30 <chucky> I've only heard him give introductory lectures on Haskell, and he handled that VERY well
17:51:45 <shapr> I hope he can do the same for Arrows
17:53:32 <chucky> he probably can, he's written a paper (http://www.dcs.gla.ac.uk/fp/papers/giving-a-talk.ps.Z) on how to give research talks. :)
17:53:49 <shapr> Pseudonym: can you really fit useful stuff into 5 mins?
17:54:03 <Pseudonym> You'd be surprised.
17:54:25 <Pseudonym> It encourages people not to waffle.
17:54:33 * themaximus wonders
17:54:37 <shapr> good point
18:05:05 <shapr> bah, sleep time for me
18:05:17 <Pseudonym> Night.
18:13:24 <Spark_> right its 2AM, time for 6 hours of work to begin
19:33:08 <Spark_> anyone awake still?
19:34:58 <Pseudonym> What do you mean still?  It's only midday.
19:35:30 <camio> 10:35pm here :)
19:35:46 <Spark_> heh
19:35:58 <Spark_> am i right in thinking that the *style* of functional programming
19:36:08 <Spark_> is to preconceive exactly how to do what you want
19:36:10 <Spark_> and then just type it in?
19:36:15 <Pseudonym> No.
19:36:36 <Pseudonym> The style of functional programming is, in principle, to say what you want done and let the compiler figure out how to do it.
19:36:39 <Pseudonym> In principle.
19:36:58 <Spark_> but you specify what you want in a rather abstract form
19:37:04 <Pseudonym> Yes.
19:37:14 <Spark_> and you have to work out how to translate what you want into that abstract form without help from the computer
19:37:22 <camio> Personally, if I don't concieve before programming in Haskell, it won't compile.
19:37:43 <Pseudonym> I think that functional programming encourages you to get your data structures worked out first.
19:37:58 <Pseudonym> Think in terms of the data, then write the code to operate on the data.
19:38:18 <Pseudonym> Hungry.  Must eat.  BBIAB
19:38:23 <Smerdyakov> Spark_, I think your view is tainted by prior programming preconceptions.
19:38:34 <Spark_> Smerdyakov: isnt that always the way? :p
19:38:44 <Smerdyakov> Spark_, from our point of view, a functional program _is_ the form you first think of your ideas in.
19:38:53 <Smerdyakov> Spark_, it takes effort to translate that into imperative code.
19:39:12 <camio> Spark_: How could a computer help you translate your ideas into abstract form?
19:39:32 <Spark_> ah i imagine it to be some kind of loosely defined *idea* which you then refine into either procedural or declarative form
19:39:37 <Smerdyakov> Spark_, you have the freedom to train yourself to conceive of problems in different ways. I think most of us would claim that the functional form is the best for helping you think of solutions efficiently.
19:39:47 <Spark_> ok
19:41:15 <Spark_> camio: engineers have typically built prototypes and scientists have experimented with different ideas, and *then* generalised an abstract form from specific empirical results
19:42:25 <Spark_> this seems like an entirely different approach that i'm trying to understand :)
19:43:20 <camio> Spark_: I guess I'm more wondering how one can write a computer program in any language without reaching a working level of abstraction (assuming the code is bugless of course).
19:44:00 <Spark_> i think different paradigms have different levels of abstraction
19:44:25 <Spark_> for example humans often think in terms of sequential steps
19:44:40 <Spark_> then again sometimes they think in terms of recursion too :)
19:46:32 <camio> Spark_: Oh, I think I understand now.  So you're arguing that since people usually think in steps and then form generalizations and functional programming doesn't allow one to work with steps before generalizations?
19:46:52 <Spark_> not as such
19:47:12 <Spark_> im not putting forward an argument really :)
19:47:18 <camio> I think I agree with that much.
19:47:23 <Spark_> hehe
19:47:48 <camio> It's an interesting idea.
19:48:30 <camio> Haskell is really my only functional programming language and I oftentimes lack the words to describe the grandios difference I experience.
19:48:32 <Spark_> have declarative languages been designed specifically to get things like referential transparency (is it called)
19:49:30 <Spark_> and therefore programmers have to fit their requirements into the given paradigm
19:50:01 <Spark_> i guess not since many things are very elegantly expressed in functional programming
19:50:54 <camio> How can we define elegance?
19:51:23 <Spark_> size of the syntax tree maybe
19:51:25 <camio> I could describe a lot of functional solutions that are simple once you understand, but hard to understand.
19:52:19 <Spark_> are they hard to understand because one cant immediately identify with the mechanics of what is going on
19:52:50 <Spark_> for example because theyre not intuitive, because they dont map so well onto what humans normally experience in their environment
19:54:05 <Spark_> im just gonna put some chips in the oven, brb
19:55:32 <Leimy> hello
19:55:44 <camio> I think that this is the case.  Fb encourages new styles an idioms so the code is complex in the array of idioms used.  However, the idioms are more specific to the problem domain than a typical procedural one.
19:55:48 <camio> hi
19:55:53 <camio> s/Fb/Fp
19:58:59 <Spark_> ok
19:59:40 <Spark_> its hard to really know because ive been writting procedural code since I was 8 or something :) so a for loop is the most natural concept in the world for me
20:00:17 <camio> I guess it is hard to draw a line between the processes availible and the applicability each process has to a given problem.
20:01:04 <camio> Damn, I sure wish a fp was my first language :)
20:01:13 <Spark_> :)
20:01:17 <Leimy> fp?
20:01:23 <Leimy> oh
20:01:24 <Leimy> nm
20:01:25 <Leimy> :)
20:01:37 * Leimy is having a bit o trouble with haskell too
20:02:19 <camio> It stinks because I have C++ quit mastered, but the language I really want to know is Haskell.
20:02:23 <Leimy> elemNum a x = length [y | Y,-x, a==y]
20:02:28 <camio> s/quit/quite
20:02:36 <Leimy> camio: I spent a long time with C++ as well
20:02:43 <Leimy> I still wouldn't say I "mastered" it :)
20:02:59 <Spark_> its a bit of a rhino
20:03:01 <Leimy> There probably isn't any concept in it I don't understand... or couldn't :)
20:03:12 <Spark_> i think ive mastered C now
20:03:12 <Leimy> but... it's always got some funky surprises :)
20:03:28 <Spark_> most people think theyve mastered C though, then something bites them :)
20:03:47 <Spark_> yeah it'll be worse in C++ i would expect :)
20:03:52 <camio> Yeah, there's tons of annoying bits of knowledge I know about C++ . . . use 0 instead of NULL | ++i instead of i++ and then template.  Arg
20:03:59 <Spark_> all that template stuff and the extra syntax features
20:04:18 <Leimy> heh
20:04:21 <Spark_> ++i instead of i++?
20:04:22 <monotonom> You can also use 0 instead of NULL in C.
20:04:28 <Spark_> yeah
20:04:28 <Leimy> Actually 0 instead of null is being reconsidered
20:04:35 <Leimy> they are planning a nullptr object now :)
20:04:39 <Spark_> NULL is for readability
20:04:40 <camio> monotonom: That isn't portable.
20:04:48 <Spark_> camio: it is
20:04:54 <monotonom> It is portable.  See the standard or the C FAQ.
20:04:57 <Spark_> 0 is translated to the system null address
20:05:11 <camio> Really?  The C++ faq's argue otherwise :)
20:05:21 <Spark_> heh thats interesting
20:05:23 <Leimy> they differ in their NULL specifications
20:05:24 <Leimy> actually :)
20:05:37 <Leimy> that was the subject of an article in C/C++ Users Journal this month
20:05:42 <Leimy> by Herb Sutter
20:05:47 <camio> Yeah, (void*)0 for C and 0 for C++
20:05:49 <Leimy> and that's where the nullobject came up
20:06:27 <Spark_> do you have to cast it?
20:06:51 <monotonom> There are contextual type promotion rules that will cast it for you.
20:07:06 <camio> No casts for 0 in c++, but you'd have to cast (void*)0 I believe.  This is different to C, right?
20:07:16 <Spark_> probably in varargs and stuff you'd have to cast
20:07:19 <Leimy> there was one iteration of EGCS where I had to use "false" where I wanted a null ptr :)
20:07:26 <Spark_> so printf("%p",0); is a remarkably bad idea
20:07:28 <Leimy> due to an error in it's ambiguity resolution
20:08:08 <monotonom> you are right about printf("%p",0).  But if you have int *p; p=0 it should be alright.
20:08:17 <Spark_> yeah
20:08:38 <Spark_> i guess a small amount of type inference is practically *required* in a programming language
20:09:05 <Spark_> i wonder about int *p = 0l;
20:09:13 <Leimy> void f(int x); and void f(char *ps);  then call f(0);
20:09:16 <Leimy> what happens in C?
20:09:20 <Leimy> what happens in C++? :)
20:09:23 <Spark_> cant overload in C
20:09:23 <Smerdyakov> I prefer not to wonder about C or C++, personally. :P
20:09:24 <camio> Hehe, I had a funny thought yesterday.  C/C++ has some form of lazyness with the && operator.
20:09:37 <Leimy> obviously C won't compile :)
20:09:42 <Leimy> overloading :)
20:09:55 <Leimy> camio: short circuit?
20:10:04 <Leimy> same with ||
20:10:14 <Spark_> short cut its called isnt it
20:10:16 <monotonom> "if b then P else Q" and "b?P:Q" are also some laziness.
20:10:17 <Spark_> </nit>
20:10:21 * Leimy heard short circut
20:10:26 <Leimy> er circuit
20:10:32 <Spark_> lost in translation maybe? :)
20:10:36 <Leimy> could be :)
20:10:41 <camio> hehe
20:10:45 <Leimy> doesn't matter :)
20:10:47 <Cale> I've heard short circuit. :)
20:10:48 <Leimy> it's all OT ! :)
20:11:09 <Spark_> short cut is blatantly a better term :)
20:11:13 <Leimy> so I have "elemNum a x = length [y | y <- x, a==y]
20:11:13 <Leimy> "
20:11:26 <Leimy> and I wanted to try to write that without the list comprehension
20:11:29 <Leimy> and recursion
20:11:35 <Cale> Leimy: i.e. length $ filter (==a) x
20:11:40 <Leimy> hmmm
20:11:44 <Leimy> that's more advanced than me :)
20:11:58 <Leimy> what is $?
20:12:06 <Cale> function application
20:12:09 <Leimy> the assignment in the book says to use recursion :)
20:12:11 <monotonom> it means length (filter (==a) x)
20:12:14 <Cale> i.e. length (filter (==a) x)
20:12:15 <Cale> right
20:12:21 <camio> a $ b c -> a ( b c )
20:12:23 <Leimy> ah
20:12:27 <Leimy> it's like a mapping?
20:12:28 <Cale> oh, you want to write it directly.
20:12:34 <Leimy> yeah :)
20:12:39 <Leimy> I wonder what that looks like
20:12:42 <Leimy> forget filter :)
20:12:54 * camio loves the $ operator.
20:12:56 <monotonom> Alright, just fill in the blank.  elemNum a [] = _____    elemNum a (x::xs) = _____ elemNum a x ____
20:13:13 <Leimy> :)
20:13:28 <Cale> where :: is replaced with :
20:13:34 <monotonom> Oh damn!
20:13:45 <Spark_> heh is than an MLism
20:13:46 * monotonom goes back to the ML channel
20:13:50 <Leimy> heh
20:13:59 <Spark_> they taught ML at my university, i loved that course
20:14:34 <Spark_> is ML considered a bit dead then
20:14:39 <Spark_> maybe a bit like C and pascal
20:14:46 <Spark_> haskell and ml :)
20:14:56 <Riastradh> ML isn't dead.
20:15:01 <Cale> O'Caml is gaining popularity.
20:15:16 <Leimy> weirdly :)
20:15:17 <Riastradh> Pascal is pretty much dead and C _ought_ to have been dead a _long_ time ago.
20:15:32 <camio> Riastradh: What is C's replacement?
20:15:42 <Smerdyakov> Freenode's #ocaml looks like it will double in size over some one-year period that includes today.
20:15:43 <Riastradh> camio, depends on the application.
20:15:53 <Leimy> for system's programming :)
20:15:56 <Leimy> PreScheme :)
20:15:58 <Leimy> right?
20:16:05 <Riastradh> Yes, or Cyclone, perhaps.
20:16:13 <Leimy> Cyclone is pretty neat :)
20:16:18 <monotonom> there is #ocaml! I should join it (and help fulfill the prophecy)
20:16:19 <Leimy> C the way it should have been done :)
20:16:39 <Riastradh> For _very_ low-level systems programming, Forth.
20:16:47 <camio> It's a really low level langauge that is an abstraction over assembly.
20:16:55 <Spark_> i have never even *seen* most of these languages :)
20:17:00 <Leimy> that's ok :)
20:17:13 <Smerdyakov> And ML fans might also want to join #sml. ;)
20:17:15 <Cale> There's a first time for everything :)
20:17:18 <Leimy> http://www.research.att.com/projects/cyclone/
20:17:31 <Riastradh> http://www.bloodandcoffee.net/campbell/code/kelsey97prescheme.ps
20:17:32 <Leimy> it's a "safe" C
20:17:43 <Spark_> it takes a long time to learn a language though, you need to implement something quite big in it
20:17:49 <Smerdyakov> Hey, if you like safe C, I'd might as well plug one of my advisor's projects:
20:18:00 <Riastradh> Pre-Scheme is a low-level dialect of Scheme, with such things as HM type inference.
20:18:16 <Cale> There are so many languages out there and most people don't seem to think past these few popular ones.
20:18:20 <Smerdyakov> http://manju.cs.berkeley.edu/ccured/ <-- CCured. Static analysis compiles memory safe versions of almost all C programs.
20:18:57 <Spark_> Cale: it seems that the popular definition of a 'good language' is one that lots of people know :)
20:19:12 <Leimy> yep
20:19:15 <Leimy> unfortunately
20:19:21 <Leimy> that's no way to improve a situation
20:19:43 <Leimy> I told my boss I was learning about functional programming and he was pleased :)
20:19:53 <Smerdyakov> Is your boss a fig leaf?
20:19:56 <Leimy> nope :)
20:20:03 <Riastradh> Pre-Scheme has a _huge_ advantage over C or Cyclone or such things: it can be run in a regular high-level Scheme environment -- including a high-level debugger, for instance --, which _vastly_ improves development.
20:20:14 <Leimy> neat
20:20:22 <Leimy> so prototyping is easier and safer I take it :)
20:21:17 * camio 's ears go up with information on better-than-C languages.
20:22:34 <Leimy> yeah
20:22:59 <Leimy> I mean... I'll probably alwasy need to know C and C++ ... but if we can move away from those two we might get higher quality software one day :)
20:23:43 <Cale> The articles on Slashdot and K5 seem to have helped awareness.
20:23:56 <Smerdyakov> Leimy, we have moved away from them. People in the know don't use them anymore. :)
20:23:59 <camio> Where can I get a prescheme compiler?
20:24:08 <Riastradh> camio, it comes with Scheme48: http://s48.org/
20:24:26 <Leimy> Smerdyakov: problem is I can't get a job doing FP it seems... at least not as readily as java or C/C++
20:24:35 <Riastradh> There's also the VLISP Pre-Scheme compiler, but I've been unable to find out much about it beyond its existence.
20:24:44 <Smerdyakov> Leimy, then you're clearly not in academia.
20:25:00 <Riastradh> Smerdyakov, purely academic jobs are useless to improving the general software industry.
20:25:15 <Leimy> Smerdyakov: unfortunately  sometimes :)
20:25:25 <Leimy> well... thing spill out :)
20:25:31 <Smerdyakov> Riastradh, I don't agree. It's possible to avoid using most software produced by "the general software industry."
20:25:43 <Leimy> If some incredibly awesome academic research occurs... and has commercial potential
20:25:47 <Leimy> that's all it will take :)
20:25:51 <Riastradh> Smerdyakov, that's irrelevant, though; what's relevant is what the _rest_ of the people do/use.
20:26:07 <Leimy> it's driven by the benjamins :(
20:26:23 <Smerdyakov> Riastradh, I don't care about those people.
20:26:49 <Riastradh> Smerdyakov, that's 99% of the computing industry, and they outnumber you.
20:27:02 <Smerdyakov> Riastradh, so? I don't care about far more than 99% of the world population.
20:27:02 <Riastradh> You can't just ignore that kind of problem.
20:27:27 * Cale has a Haskell job for the summer. :)
20:27:40 <camio> Cale: Where at?
20:28:36 <Leimy> that's great!
20:28:48 <Cale> A professor at another university is working on a new programming language, and I'll be writing a symbolic computation part of it in Haskell.
20:29:06 <Riastradh> Smerdyakov, so you just want to let the C++ bigots trample all over you while you sit in an obscure corner working on purely academic projects and not really contributing to the general software industry?
20:29:36 <Smerdyakov> Riastradh, who says I don't contribute to the realm of "useful software"?
20:29:49 <Riastradh> Smerdyakov, 99% of the computing industry says that.
20:29:58 <Smerdyakov> Well, that's their misconception.
20:30:07 <Riastradh> And you're just _letting_ them misconceive.
20:30:15 <Smerdyakov> I don't care if they misconcieve.
20:30:30 <Smerdyakov> As long as I get the software I want.
20:30:45 <Riastradh> You're rather self-centred, Smerdyakov.
20:31:46 <Smerdyakov> No. The other clued-in people get the software they want, as well.
20:32:51 <Riastradh> Smerdyakov, so what will you do if the other 99% continue to overwhelm the academics and you can no longer get all the software you want?
20:33:14 <camio> As far as software that's out there goes, the really good quality software gets used only if it has all the features of the bad quality software.  Take qmail for instance.
20:33:23 <Smerdyakov> That won't happen, because we're good enough at producing software.
20:33:40 <Riastradh> If there simply aren't enough of you, that doesn't matter, Smerdyakov.
20:33:47 <Smerdyakov> There _are_ enough of us.
20:34:27 <camio> Academics are about the paper, not about the software.  Right?
20:34:41 <Riastradh> Smerdyakov, notice the _if_, and the fact that I was making a hypothetical suggestion in my prior message.
20:35:42 <Smerdyakov> camio, there's a large enough group of people with academic histories who are into producing software for the software.
20:36:12 <camio> Smerdyakov: Can you give me an example?
20:37:42 <Riastradh> So, Smerdyakov, show me an OS produced by these academics that Just Works, runs on PPC, and will run a sufficient quantity of software.
20:37:46 <Smerdyakov> Me :)
20:37:58 <Smerdyakov> Riastradh, PPC sux, dude
20:38:08 <camio> Smerdyakov: I mean an example end user software.
20:38:12 <Riastradh> Got a better & realistic suggestion?
20:38:25 <Leimy> Lennox on sex-86?
20:38:54 <Spark_> we're talking about people here, you cant say much about 'an academic', it just a stereotype
20:39:29 <Riastradh> Leimy, just to make sure, you're joking there, right?
20:39:44 <Leimy> yeah :)
20:39:57 <Riastradh> Spark_, yes, that's correct, but for the purposes of this conversation, 'academic' is sufficiently precise.
20:40:00 <Leimy> everyone know Palm on ARM is the best :)
20:40:10 <Smerdyakov> camio, I don't have concrete examples now. I'm more talking about a stage we are quickly approaching, as advanced PL stuff becomes more popular in universities and more converted people graduate.
20:40:33 <Riastradh> Smerdyakov, you don't have any concrete examples?  Then you were not a very good answer to his question, or what you thought his question was.
20:40:51 <Riastradh> I'm still waiting for a suggestion for such an OS I mentioned above.
20:41:15 <Smerdyakov> Riastradh, that's OK.
20:41:28 <Riastradh> ?
20:41:46 <Smerdyakov> Riastradh, it's OK if I change the question I'm answering. :-)
20:42:05 <Leimy> crap
20:42:11 <Leimy> I forgot the syntax for if/else
20:42:12 <Leimy> that's bad
20:42:22 <Riastradh> The question you answered and the answer you gave to the question you asked were _both_ rather unsatisfactory.
20:42:32 <Smerdyakov> No problem. I forgive you.
20:42:34 <camio> Smerdyakov: PL?
20:42:34 <camio> Oh, NM
20:42:35 <camio> Hehe, my alma-matter's really not doing well with programming languages.  They switched form C++ to java 2 years ago.
20:42:44 <Smerdyakov> camio, which mater is this?
20:42:45 <Riastradh> Leimy, [[if <antecedent> then <consequent> else <alternative>]]
20:43:06 <camio> University of Rochester
20:43:13 <Leimy> Riastradh: pretty sure it's my layout :)
20:43:20 <Smerdyakov> camio, well, no surprise there....
20:43:22 <Riastradh> Smerdyakov, so...you're showing pretty well that useful software out in the world doesn't tend to be produced by academics such as yourself.
20:43:57 <Smerdyakov> Riastradh, regardless of what I may have said, I don't mean "academics" in that sense. I mean people who have been exposed to the philosophy that reigns here and in a good portion of academic CS environments.
20:44:04 <camio> Smerdyakov: Eh, it was 19th in US for CS when I started.  I imagine it no longer ranks as high :)
20:44:07 <Spark_> Riastradh: what about enabling technologies (e.g. RSA)
20:44:31 <camio> Shameless plug: www.nonconformity.net/rsa-haskell
20:45:13 <Riastradh> Smerdyakov, exposed to the philosophy that reigns here?  OK, so how many people here have written a 'complete' (whatever that means) Haskell application that is useful to someone who does not use Haskell?
20:45:13 <Smerdyakov> camio, 19th in what?
20:45:27 <camio> Ranked 19th for undergaduate CS major
20:45:41 <Smerdyakov> camio, who ranks undergraduate CS programs?
20:46:03 <camio> I forget the company, but they publish some book every once in a while.
20:46:03 <Smerdyakov> Riastradh, I'm talking primarily about potential, anyway.
20:46:12 <Spark_> Riastradh: that is unfair since many applications require tight interoperability with other applications and so are best written in a popular language
20:46:25 <Smerdyakov> camio, OK. UR isn't on USNews's top 40 list for CS PhD programs.
20:46:28 <Riastradh> Smerdyakov, potential means nothing to most people.
20:46:36 <Smerdyakov> Riastradh, those poor people.
20:46:54 <camio> Smerdyakov: That makes me happy because most of the graduate students I met where morons.
20:47:14 <Riastradh> And since you're looking for _concrete_software_, potential doesn't seem to be very useful to you, either.
20:47:22 <Smerdyakov> Riastradh, *yawn*
20:47:56 <monotonom> "University" has always been defined to produce graduates who improve the world --- say, industry --- as opposed to succumb to it.  However, if industry wants the opposite, there is not much we can do.
20:48:40 <camio> monotonom: Amen
20:49:02 <camio> Graduates in CS don't get project lead jobs . . . experienced BS's or Master's do.
20:49:25 <camio> They don't make decisions in real software.
20:49:27 <Spark_> i think the CS field is caught in a nasty phase were too many people are making the wrong decisions, but it will eventually get over this and move on
20:49:56 <Spark_> its like every man and his dog are criticising things
20:50:25 <Leimy> so here is the solution I came up with for elemNum...
20:50:28 <camio> hehe
20:50:33 <Leimy> elemNum a x = length (selectList a x)
20:50:33 <Leimy> selectList :: Int -> [Int] -> [Int]
20:50:33 <Leimy> selectList a [] = []
20:50:33 <Leimy> selectList a (x:xs) = 
20:50:33 <Leimy>     if a == x
20:50:34 <Leimy>         then a : (selectList a xs)
20:50:36 <Leimy>     else
20:50:36 <Riastradh> Get out of your academic ivory towers and _make_bloody_software_.
20:50:38 <Leimy>         selectList a xs
20:50:39 <Leimy> sucky :)
20:50:56 <Pseudonym> camio: I disagree with that.
20:51:22 <Riastradh> Leimy, why don't you just iterate across the list and keep a count of the matching elements you've found?
20:51:30 <Leimy> keep a count?
20:51:32 <Leimy> that's what I want to do :)
20:51:38 <Leimy> I couldn't figure out how to express it
20:51:50 <Leimy> pass it as a variable?
20:51:55 <Leimy> er input to the function
20:52:03 <camio> Pseudonym: There are probably exceptions, but my industry experience tells me that CS Phd's don't run the show.
20:52:06 <Riastradh> Well, first, why don't you write a length function?
20:52:21 <Spark_> i know some phds who should be shot
20:52:35 <monotonom> I think Leimy is making it more complicated than necessary.
20:52:41 <Leimy> I know I am :)
20:52:41 <Smerdyakov> Riastradh, you are being unfair to any of us who are still pursuing degrees.
20:52:50 <Leimy> I am trying to do the assignment the way it is assigned
20:52:54 <Smerdyakov> Riastradh, the idea with getting a degree is that it prepares you for doing something else.
20:52:55 <Spark_> lots of people seem to do a phd because they dont want a boring job, isntead they want to bum around for a few more years :)
20:52:58 <Leimy> no list comprehensions or function applications :)
20:53:27 <monotonom> My fill-in-the-blanks template was crafted to be both simple and conformant to the expectation of the assignment.
20:53:30 <Riastradh> Leimy, no function applications?
20:53:36 <Leimy> well not no :)
20:53:40 <Riastradh> You're going to have a _really_ hard time writing Haskell code without function applications.
20:53:44 <Leimy> :)
20:54:02 <Riastradh> So, Leimy, write length first.
20:54:07 <Leimy> doing that now
20:54:08 <camio> Leimy: Do you know pattern guards?
20:54:23 <Riastradh> Smerdyakov, and you can't write software while you're at it?
20:54:40 <Smerdyakov> Riastradh, I have other requirements set upon me that take up time.
20:54:51 <Spark_> Riastradh: good software gets written by teams of experienced individuals, not by students, students produce shit software
20:54:52 <Riastradh> Smerdyakov, and there aren't a lot of academics who already _have_ PhDs who could be writing software rather than sitting in ivory towers thinking on far too theoretical a scale?
20:55:06 <Smerdyakov> Spark_, oh please.
20:55:24 <Leimy> hmmm ok
20:55:29 <Leimy> it is easier than I thought
20:55:29 <Smerdyakov> Spark_, there are good and bad developers in all cross-sections of society.
20:55:37 <Leimy> I need to learn to break it down to smaller pieces first :)
20:55:42 <Riastradh> Spark_, that's preposterous.  That kind of over-generalization is worse than my over-generalizations.
20:55:56 <camio> Smerdyakov: Industry weeds out crappy developers while academia doesn't.
20:56:10 <Spark_> you should see the kind of crap i have to work with
20:56:27 <Smerdyakov> camio, that doesn't contradict what I said.
20:56:41 <monotonom> Industry is already producing more programs than necessary. How does writing yet more programs solve any problem?
20:56:45 <Smerdyakov> camio, since there are many levels of badness. :)
20:57:01 <camio> Smerdyakov: :)
20:57:08 <Riastradh> monotonom, how does sitting up in an ivory tower thinking overly theoretical thoughts solve any problem?
20:57:17 <Leimy> elemNum a [] = 0 
20:57:18 <Leimy> elemNum a (x:xs) = if x == a then 1 + (elemNum a xs) else elemNum a xs
20:57:20 <Leimy> :)
20:57:35 <Cale> How does sitting here arguing about how problems are solves solve any problem?
20:57:35 <Leimy> way nicer
20:57:40 <Riastradh> It's writing _better_ software, not the slipshod junk that pervades the current software industry today, that improves the problems.
20:57:41 <Cale> solved* :)
20:58:01 <monotonom> Thinking is always the first step of solving problems and writing good programs.
20:58:02 <Riastradh> Cale, well, it _would_ if people shut up and agreed with me, duhhh!
20:58:08 <camio> Leimy: Have you used pattern guards before?  You might like them.
20:58:15 <Cale> heh
20:58:17 <Leimy> yeah
20:58:18 <Smerdyakov> <Riastradh> Hello, I'm Riastradh, whine whine whine, waaaaaaaah!
20:58:20 <Leimy> I can do those too
20:58:24 <monotonom> Industry thinks too little and learns from theorists too little.
20:58:25 <Pseudonym> Part of the thing is that just about every problem in industry is a management problem.
20:58:39 <camio> In haskell code I usually see them instead of if then's.
20:58:52 <Pseudonym> monotonom: The converse is also true.  Theorists learn from industry too little.
20:58:55 <Riastradh> monotonom, correct, thinking is necessary, but an unbalance in _either_ direction is disastrous.
20:59:04 <Pseudonym> In the intersection of good theory and good practice... that's where the real joy is.
20:59:18 <Leimy> elemNum a [] = 0 
20:59:18 <Leimy> elemNum a (x:xs)
20:59:18 <Leimy>     | a == x = 1 + elemNum a xs
20:59:18 <Leimy>     | otherwise = elemNum a xs
20:59:18 <Smerdyakov> Pseudonym, I have read "The Psychology of Computer Programming," and I'm still trying to figure out how it changed your life. :)
20:59:35 <Pseudonym> Smerdyakov: I was young at the time.
20:59:40 <Pseudonym> If that helps.
20:59:58 <Pseudonym> First-year undergrad, in fact.
21:00:00 <camio> Leimy: Nice :)
21:00:06 <Riastradh> Too theoretical and you don't get any useful, concrete product.  Too practical and the product is concretely terrible.
21:00:07 <Leimy> well better anyway
21:00:37 <Smerdyakov> Pseudonym, no, I still don't get how reading about tips for mainframe computing changed your life. :)
21:00:43 <monotonom> Industry people says: you academics, you have never written a line of code, you have no right to tell us how to do things.  That is the most flawed attitude.  If anything, it is the detached observer who can see the real problem and the real solution.
21:01:19 <Riastradh> monotonom, academic people say: you engineers, you have never thought about a single line of code you wrote; you have no right to tell us how to do things.  That is an equally flawed attitude.
21:01:49 <Riastradh> Being too theoretical and not practical enough is _just_as_bad_ as being too practical and not theoretical enough.
21:01:55 <monotonom> No academic people say that.
21:02:20 <Riastradh> No industry people say those precise words, either.
21:02:31 <Riastradh> The general idea behind the attitude is the same, however.
21:02:32 <camio> What about industry saying: hey, That language doesn't work with OpenGL . . . that idea isn't understood by anyone on my team. . . . we need support, etc.
21:02:42 <Smerdyakov> <Riastradh> I'm Riastradh, the straw man abused me when I was a child, so now I beat on him all the time!
21:02:44 <monotonom> No, no academic people have that attitude.
21:03:20 <Pseudonym> Smerdyakov: What helped was looking at the way programmers think.
21:03:33 <Pseudonym> The two kinds of programmers... one was "assertive", can't remember what the other one way.
21:03:33 <Spark_> Pseudonym: how do programmers think?
21:03:43 <Pseudonym> "Timid"?
21:03:49 <Spark_> Pseudonym: i should read that book, im interested in psychology anyway :)
21:04:08 <Cale> <Smerdyakov> Hi I'm Smerdyakov. Opinion! Adamant controversial statement! <Somebody> Hello, I'm somebody! Generic Imitation.
21:04:20 <Pseudonym> Can't remember.  Anyway, it sold me on strongly, statically typed languages.
21:04:43 <Pseudonym> Because assertive programmers (like me) really need the extra help from the compiler.
21:04:44 <Spark_> im pretty sold on that anyway :)
21:04:48 <Riastradh> monotonom, have you really never argued or considered that one should think about the program and not just churn out line after line of code?
21:04:55 <Spark_> Pseudonym: have you read any socionics?
21:05:06 <Pseudonym> I can audit my own intent, but I cannot force myself to audit things that the compiler can check.
21:05:12 <Pseudonym> Spark_: No.
21:05:19 <Spark_> Pseudonym: id be interested to see if that theory ties up with the mbti, jung and keirsey stuff
21:05:21 <Pseudonym> I don't even know what the word means.
21:05:24 <Spark_> Pseudonym: www.socionics.com
21:05:33 <Smerdyakov> Pseudonym, I remember that, though I also don't remember the exact name of the other kind.
21:06:31 <Pseudonym> :-)
21:07:02 <Smerdyakov> I wish we still had "machine rooms" for running programs on punch cards. :-)
21:07:05 <camio> My guess is that the "assertive" programmer was the better one?
21:07:06 <Cale> How does socionics do in experimental testing?
21:07:07 <Smerdyakov> Sounded much more contemplative and social at once.
21:08:04 <monotonom> Riastradh's question is loaded.  I think about the problem to be solved and derive, not "just churn out", lines after lines of refinements.
21:08:15 <Spark_> cale: many organisations use mbti to classify their employees
21:08:22 <Cale> What sorts of predictions does it make?
21:08:24 <Spark_> i find it to be quite accurate
21:08:45 <Smerdyakov> Cale, there will be a total eclipse of the sun..... NOW [pulls the curtains]
21:09:15 <Spark_> hmm people are never terribly predictable in that sense, but i do find the 4 dimensions give me a sort of roadmap for understanding different sorts of personalities
21:09:37 <Cale> Have there been proper scientific experiments done?
21:09:40 <Spark_> like 'he is obviously more T and less F than him'
21:10:00 <Spark_> its based on experiment i think
21:10:52 <Cale> That's always the first thing to look at. Scientific theory is meaningless if it doesn't actually successfully predict things.
21:11:34 <Smerdyakov> The fact that you have a theory can allow predictions that someone will pay you.
21:12:28 <Leimy> night all
21:12:34 <Spark_> Cale: when i was choosing my housemates, i arranged there to be two intjs and two entps, and it worked out quite well :)
21:12:46 <monotonom> Classifying personalities... you can't say it is scientific, can you?  I don't mean to say it is unjustified or irrespectible.  I mean it is outside the scope of science.  It is psychology.
21:12:49 <Spark_> also you can observe conflict between S and N types
21:13:00 <Cale> Psychology should be a science.
21:13:03 <Spark_> yeah its very subjective
21:13:34 <Pseudonym> camio: Neither is better.
21:13:36 <Spark_> sometimes you classify people the opposite of yourself simply because you dont like them :/
21:13:39 <Pseudonym> They're just different.
21:14:01 <Pseudonym> Assertive programmers don't check their programs before compiling as much.
21:14:12 <Spark_> i dont like him -> hes a bad person -> im a good person -> hes the opposite of me :)
21:14:48 <Spark_> Pseudonym: thats the difference between perception and judging
21:14:48 <Cale> Spark_: Watch out! Someone intercepted all the apostrophes in your sentence!
21:14:58 <camio> Pseudonym: You mean for syntax errors or for logical errors?
21:15:05 <Cale> :)
21:15:08 <Spark_> Cale: packet loss :)
21:15:15 <monotonom> Well, I suppose you can do a simple personality test on an applicant and immediately predict with good accuracy that he will/won't like Haskell.  Things like that is possible.
21:15:16 <Pseudonym> Both.
21:15:37 <Spark_> you can spot an NT, SJ, NF or SP quite easily
21:15:53 <Spark_> extrovert / introvert can be very tricky though
21:16:00 <Spark_> i still dont even know if i am extrovert or introvert :)
21:16:03 <Smerdyakov> The best test for good programmers is psychosis.
21:16:12 <Pseudonym> Yes.  Some apparent extroverts are just good at putting on a public persona.
21:16:13 <Smerdyakov> Not psychotic enough => not a good enough programmer!
21:16:16 <monotonom> What is psychosis?
21:16:34 <Spark_> how about the witch test
21:16:38 <Smerdyakov> monotonom, some sort of disconnection from reality
21:16:42 <Spark_> if the person sinks, theyre a good programmer
21:16:51 <monotonom> Ah!
21:17:10 <Spark_> hypnosis? :)
21:17:20 <Spark_> hmm ive done no work all night
21:17:26 <Spark_> can i blame all of you?
21:17:48 <Riastradh> No, blame Smerdyakov & monotonom for trying to dissuade people from writing software!
21:17:51 * Riastradh ducks.
21:17:54 * Riastradh wanders off to bed while ducking.
21:17:55 * monotonom goes pick up good programmers from the Internet cafe in the neighbourhood.  "Have you been playing this game for 16 hours straight?" "Yes." "Don't you have a life?" "No, I hate meeting and talking to real people." "You are hired!"
21:18:26 <Riastradh> How experienced he is with programming is of course irrelevant.
21:18:34 <Pseudonym> Do programmers weigh the same as a duck?
21:18:36 <Smerdyakov> monotonom, no, no, I mean things like schizophrenia and bipolar syndrome!
21:18:48 <Riastradh> Pseudonym, only if it has a witch attached.
21:18:57 <Pseudonym> Just checking.
21:19:00 <Riastradh> And definitely not if it is carrying coconuts, though.
21:19:22 * Riastradh is carried by a swallow off to bed.
21:19:28 <Pseudonym> An African or a European programmer?
21:19:44 <Riastradh> Australian, Pseudonym.
21:19:46 <monotonom> How experienced a person is with programming, measured in mere number of years, is of course important.  You expect a programmer touting "40 years of experience" to not understand FP or OOP, for example.
21:19:50 <Riastradh> I really don't know how fast they fly.
21:19:57 <Riastradh> *WAAAAAAAAAAAAAAAAAAAAAAAAUGH*
21:20:05 <Spark_> depends what they did
21:20:25 <Spark_> my dad occasionally writes some basic, hes been doing that for god knows how long
21:20:39 <Spark_> thats how i learnt to program so long
21:20:51 <Spark_> 'dad what does "for" do'
21:20:54 <Smerdyakov> Spark_, same with me. Now we can teach our children FP. :)
21:21:01 <Spark_> :)
21:21:16 <Spark_> they'll have degree level mathematics by the time theyre 10
21:21:20 <Pseudonym> ...and they'll bitch about how we don't know whatever the next cool theory is.
21:21:31 <Spark_> heh
21:21:47 <Spark_> and so science evolves
21:21:57 <Spark_> ill probably always keep in touch with new ideas
21:22:11 <Smerdyakov> I don't know about People in General, but I couldn't do much abstract thinking before age 16 or so.
21:22:21 <Smerdyakov> I think there is biological evidence about changes in brain capacity.
21:22:27 <monotonom> The motto "old dogs can't learn new tricks" is about the only one thing I and the industry both agree. :)
21:22:36 <Smerdyakov> So... the degree level math before age 10 may be a stretch ;)
21:22:44 <Spark_> heh :)
21:22:48 <Spark_> i wonder
21:22:57 <monotonom> I became extremely good at abstract math after 20.
21:23:04 <Spark_> i think i had great trouble grasping certain things
21:23:09 <Spark_> types was one of them
21:23:12 <monotonom> At least the grades said so.
21:23:17 <Spark_> because basic wasnt typed at all
21:24:03 <Spark_> monotonom: i find my supervisor and tutor are so much better at maths than me, since they come from a maths background, and the maths they teach in a compsci degree is quite weak
21:24:28 <Spark_> i was coding this fibonacci number generator algorithm in my language
21:24:52 <monotonom> You have a language of your own?!  Show me! Show me!
21:24:59 <Spark_> and i was confused for a while because if two fib generators were out of phase, but added together, the sequence they produce is still a fib sequence
21:25:15 <Spark_> and he was like 'of course' straight away
21:25:25 <Spark_> it took me 2 mins on paper to prove the same thing :)
21:25:35 <Spark_> its not really a language
21:25:43 <Spark_> its also very weak and doesnt work properly
21:25:55 <Spark_> my report is due in a couple of weeks though :)
21:25:59 <monotonom> I assure you it or something related took them 2 mins once upon a time.
21:26:22 <Spark_> yeah, i guess theres loads of things that they cant do
21:27:58 <monotonom> I mean everyone who looks snappy has gone through unknown hard work before he becomes snappy.  Many people find me snappy; not many have seen how many sleepless nights I had spent on working out simple things.
21:29:07 <Spark_> :)
21:29:44 <Spark_> how useful is all the maths you studied as an undergraduate been in computer science?
21:29:56 <Spark_> s/is/has/
21:30:25 <Spark_> not just all the cookie cutter methods, but the fact you're that much better at thinking abstractly and manipulating symbols or whatever
21:31:17 <camio> Tons for me.
21:31:17 <monotonom> In that regard, yes, it helps tremendously.
21:31:44 <camio> You can really tell the people who don't have it.
21:32:11 <camio> They don't know when they are right or wrong because they don't know how to think deeply enough about their possible solution.
21:32:30 <Spark_> i feel like that a lot of the time actually
21:32:37 <Spark_> i have to go and find help
21:32:39 <Spark_> which reminds me
21:32:45 <Spark_> about this type inference algorithm
21:33:36 <Spark_> im still not sure if its solvable efficiently :|
21:34:12 <camio> For example, most people think they know how to offset a general polygon.  Seems simple enough.  But it turned out to be so hard of a problem, we payed $3,000 for an implementation.
21:34:13 <monotonom> I gained self-confidence after I had finished my math degree.  (Does that mean I was psychotic? :)
21:34:49 <Spark_> im sure i was better at maths at school, than now :)
21:35:21 <Spark_> monotonom: you want to know what my 'language' is
21:36:35 <Spark_> i guess its more of a virtual machine for maintaining dependencies
21:38:14 <Spark_> ok well ill explain it anyway
21:38:38 <Spark_> the idea is that a computer program is a model of some observed (or imagined) behaviour
21:39:14 <Spark_> and the semantics of the model should be providing a direct mapping of the modellers 'construal' of what they understand of the referent
21:39:59 <Spark_> the that is done is with observables and dependency, observables are datums of a specific type and dependencies are functions that constrain the values of some observables to be functions of sets of other observables
21:40:22 <Spark_> so you have a directed acyclic flow of data through a graph with observables for nodes
21:40:39 <camio> Goodbye all
21:40:43 <Spark_> cya
21:41:08 <Spark_> what makes this radically different from declarative programming, is you build up the observables and dependency in the system interactively at runtime
21:41:27 <Spark_> by comparing the behaviour of your model, with the behaviour you observe (or imagine) in the referent
21:42:15 <Spark_> anyone listening? :)
21:42:59 <monotonom> I think I see why you picked fib as a working example. It has simple yet interesting dependencies to showcase your thing.
21:43:10 <Spark_> yeah
21:43:36 <Spark_> hang on ill paste some 'code'
21:48:31 <Spark_> http://rafb.net/paste/results/Sz393020.html
21:48:38 <Spark_> i should really annotate it actually
21:49:29 <Spark_> its overly complex because it has feedback and a default value
21:50:55 <Spark_> "shiver" is a shell around the actual machine, the commands typed are just wrappers around the API calls that are the interface to the virtual machine
21:51:06 <Spark_> ideally you'd want a much more graphical interface
21:52:22 <Spark_> http://info.dcs.warwick.ac.uk/~spark/3yp/presentation/img4.html
21:55:37 <monotonom> It looks neat. Thanks.
21:56:09 <Spark_> you like it?
21:56:26 <Spark_> its based on the empirical modelling research at warwick uni
22:12:09 <Spark_> can you help me with my type algorithm actually
22:12:56 <monotonom> No.
22:13:06 <Spark_> doh
22:13:20 <Spark_> are you sure? :)
22:13:49 <monotonom> Yes. I have my things to do.
22:14:00 <Spark_> fair enough
22:14:24 <Pseudonym> All type algorithms are beyond help.
22:14:34 <Gahhh> I have a newbie question. anybody feeling helpful ?
22:14:46 <Cale> me
22:14:50 <Gahhh> ok
22:15:25 <Gahhh> I wanna throw each element from a list and make a list from the remaining elements, e.g. [1,2,3] -> [ [1,2], [2,3], [1,3] ]
22:15:52 <Cale> okay
22:17:06 <monotonom> The order looks funny.
22:17:18 <Cale> a more general function might return all the lists of length k from a list of length n
22:17:19 <Gahhh> yeah I didnt pay attention to the order
22:17:50 <Cale> (in particular, your function returns all the sublists of length n-1 from a list of length n
22:17:53 <Cale> )
22:18:19 <Gahhh> yeah. special case or general is fine with me. I just cannot see how to do something like this myself.
22:19:14 <Pseudonym> If it helps, think about the recursive case.
22:19:32 <Pseudonym> I don't know what you're calling this function.  (I called it "throw".)
22:19:39 <Gahhh> throw is fine
22:19:43 <Pseudonym> (Since that's a word you used.)
22:19:46 <Pseudonym> Think about throw (x:xs)
22:19:53 <Smerdyakov> I called it "wanna," for the same reason.
22:19:57 <Gahhh> heh
22:19:58 <Pseudonym> Say, throw (1:[2,3,4])
22:20:04 <Pseudonym> Assume you have throw [2,3,4]
22:20:17 <Pseudonym> Now how do you construct the former from the latter.
22:20:18 <Pseudonym> ?
22:20:57 <Gahhh> 1: throw([2,3,4]) ?
22:21:12 <Smerdyakov> Think about the types.
22:21:16 <Smerdyakov> Does that even make sense?
22:21:33 <Pseudonym> Yes, first ask: What's the type of this function?
22:21:44 <Gahhh> it's [a] -> [ [a] ]
22:21:49 <Pseudonym> Right.
22:22:22 <Pseudonym> Think about the recursive case concretely.
22:22:59 <Pseudonym> You want [[3,4],[2,4],[2,3]] (that's throw [2,3,4]) and you want [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
22:23:06 <Pseudonym> How do you construct that second thing from that first thing?
22:23:09 <Gahhh> ok, 1:throw([2,3,4]) wont work because it returns a list, not a list of list
22:23:33 <Pseudonym> Correct.
22:24:27 <Gahhh> do I need to map on throw([2,3,4]) ?
22:24:38 <Pseudonym> Not a bad idea.
22:24:44 <Gahhh> or list comprehension ?
22:24:50 <Pseudonym> Also not a bad idea.
22:25:03 <Pseudonym> When you have a problem with lists, you should think three things:
22:25:12 <Pseudonym> 1. map/filter/fold
22:25:15 <Pseudonym> 2. list comprehension
22:25:18 <Pseudonym> 3. recursion
22:25:26 <Pseudonym> Generally your solution will be one of those three.
22:25:33 <Pseudonym> No particular order.
22:26:37 <Gahhh> something like [ throw(1:x) | x <- throw([2,3,4]) ] ?
22:27:12 <Pseudonym> Is that type-correct?
22:28:10 <Gahhh> infinitely nested lists ?
22:29:14 <Gahhh> sorta implying [a] = [ [a] ]
22:29:53 <Gahhh> this is a strange feeling being unable to type something right.
22:37:41 <Pseudonym> Well, think about throw [2,3,4]
22:37:48 <Pseudonym> Then think about the list you want to construct.
22:38:08 <Pseudonym> Try to think about what, precisely, you need to do to turn one into the other.
22:38:47 <Spark_> hm i just did it in mosml and i havent done functional programming for a year :|
22:38:56 <Gahhh> throw 1:[2,3,4] = [2,3,4] : [ (1:x) | x <- throw[2,3,4] ]
22:39:20 <Pseudonym> Bingo.
22:39:22 <Pseudonym> Now generalise.
22:39:26 <Pseudonym> Then write the base case.
22:41:24 <Gahhh> base case ? is that the case for no elements and 1 element and such ?
22:41:56 <Pseudonym> Something like that, yes.
22:42:08 <Pseudonym> It may not be obvious what throw [] means.
22:42:18 <Pseudonym> If you can't work it out, try writing throw [x] instead.
22:42:58 <Gahhh> throw [x] = [ [] ], but that's not what I really wanted
22:43:10 <Gahhh> maybe I should write throw [x,y] = [ [x], [y] ]
22:43:34 <Pseudonym> Try without it and see if it works.
22:44:06 <Gahhh> nope
22:44:10 <Gahhh> wants to match []
22:44:19 <Pseudonym> Did you put the base case first or second?
22:44:30 <Pseudonym> I think you put it second.
22:44:55 <Gahhh> ok it worked now
22:45:03 <Pseudonym> Do you see why that didn't work?
22:45:35 <Gahhh> well, I actually forgot to uncomment the base case
22:45:39 <Gahhh> it was in the right spot
22:45:40 <Pseudonym> Ah. :-)
22:45:43 <Pseudonym> OK.
22:45:50 <Pseudonym> Now.  Does throw [] make sense?
22:46:18 <Pseudonym> Hint: Try treating throw [1] as a recursive case, and see what throw [] should be to make the recursive case correct.
22:46:24 <Gahhh> if it did, it would have to be
22:46:24 <Gahhh> yeah
22:46:28 <Gahhh> I was going to type that
22:46:34 <Pseudonym> :-)
22:47:26 <Gahhh> umm, throw 1:[] = [] : [ (1:x) | x <- throw[] ]
22:47:40 <Pseudonym> And throw 1:[] = ?
22:47:49 <Pseudonym> What are you trying to make it equal to?
22:47:50 <Gahhh> not defined
22:48:12 <Pseudonym> throw [x] = [ [] ]
22:48:29 <Gahhh> why ?
22:48:34 <Pseudonym> So the equation you are trying to solve is: [ [] ] = [] : [ (1:x) | x <- throw[] ]
22:48:45 <Pseudonym> Gahhh: You wrote it, that's why.
22:48:48 <Pseudonym> :-)
22:48:51 <Gahhh> I didnt 
22:48:58 <Gahhh> I dont want that behavior
22:48:59 <Pseudonym> It is.  It's your base case.
22:49:03 <Gahhh> hmm
22:49:30 <Gahhh> well
22:50:05 <Gahhh> since 1:[] = [] : [ (1:x) | x <- throw[] ], it means that throw [x] is going to be a list that contains an empty list as the first elem
22:50:17 <Spark_> is throw [] = [] and throw [1] = [[]]?
22:50:23 <Pseudonym> I think you made a mistake there.
22:50:37 <Gahhh> me ?
22:50:39 <Pseudonym> You meant [[]] on the left-hand-side.
22:50:41 <Pseudonym> Not 1:[]
22:51:04 <Gahhh> I meant what I typed above
22:51:05 <Pseudonym> []:[] is the same as [[]], of course.
22:51:16 <Pseudonym> No, you didn.
22:51:18 <Pseudonym> 't
22:51:23 <Gahhh> <Gahhh> umm, throw 1:[] = [] : [ (1:x) | x <- throw[] ]
22:51:27 <Pseudonym> Look, you know that throw [x] = [[]], right?
22:52:12 <Pseudonym> You also know that throw (x:xs) = xs : [ x:xs' | xs' <- throw xs ], or however you typed it
22:52:48 <Pseudonym> So therefore you know that [[]] = [] : [ x:xs' | xs' <- throw [] ]
22:52:53 <Pseudonym> Do you see that?
22:53:15 <Gahhh> yes
22:53:20 <Pseudonym> Right.
22:53:38 <Pseudonym> So you didn't mean 1:[] :-)
22:54:01 <Pseudonym> Oh... you meant throw 1:[]
22:54:03 <Pseudonym> Sorry, my mistake.
22:54:04 <Gahhh> no, I meant "throw 1:[]"
22:54:06 <Gahhh> no problem
22:54:07 <Pseudonym> Duh.
22:54:11 <Pseudonym> Anyway.
22:54:13 <Gahhh> my copy-paste bug
22:54:18 <Pseudonym> [[]] = [] : [ x:xs' | xs' <- throw [] ]
22:54:23 <Pseudonym> And you need to solve for throw []
22:54:35 <Pseudonym> You can start by taking the tail of both sides.
22:54:54 <Pseudonym> Incidentally, do you see how equational reasoning helps here?
22:54:55 <Gahhh> [] = [ x:xs | xs <- throw[] ]
22:55:00 <Pseudonym> Treating your program as a set of equations?
22:55:12 <Pseudonym> Functional programming is really, REALLY good for this.
22:55:14 <Gahhh> then throw[] = [] ?
22:55:21 <Pseudonym> Try it and see.
22:55:28 <Pseudonym> Don't forget to remove your previous base case.
22:55:49 <Gahhh> still works
22:55:55 <Pseudonym> There you go.
22:56:06 <Pseudonym> Now, the $64k question: Do you see why this needs to be true?
22:56:21 <Gahhh> why throw [] needs to be defined ?
22:56:24 <Pseudonym> What is the length (throw [1..n])
22:56:27 <Pseudonym> No, why throw [] = []
22:56:27 <Gahhh> or why it should equal [] ?
22:56:46 <Gahhh> n
22:57:04 <Pseudonym> Right.  Therefore, length (throw []) = 0
22:57:19 <Pseudonym> Right?
22:57:35 <Gahhh> interesting reasoning 
22:58:02 <Pseudonym> When you're dealing with combinatorial problems, like permutations, combinations, sublists and so on, it can help to reason using length.
22:58:03 <Spark_> you can do it with filter and map quite nicely
22:58:11 <Pseudonym> Yes, though you don't need filter.
22:58:17 <Spark_> do you not?
22:58:25 <Pseudonym> throw [] = []
22:58:25 <Pseudonym> throw (x:xs) = xs : map (x:) (throw xs)
22:58:28 <Pseudonym> That was my solution.
22:58:41 <Pseudonym> Pretty much identical, except I used map instead of a list comprehension.
22:58:51 <Pseudonym> The problem with introducing filter is that it adds an extra constraint.
22:58:56 <Pseudonym> throw :: [a] -> [[a]]
22:59:01 <Pseudonym> Whereas if you use filter:
22:59:10 <Pseudonym> throw :: (Eq a) => [a] -> [[a]]
22:59:28 <ozone> or, in hugs, throw = ListUtils.subsequences :)
22:59:34 <Pseudonym> Indeed. :-)
22:59:53 <Spark_> i dont understand why filter adds an extra constraint
23:00:00 <Pseudonym> What's your solution?
23:00:01 <Gahhh> need to be able to compare
23:00:07 <Spark_> ah right yeah
23:00:10 <Pseudonym> Right.
23:00:31 <Pseudonym> If you can introduce Eq, there's an even prettier solution.
23:00:40 <Pseudonym> throw xs = [ xs \\ [x] | x <- xs ]
23:00:51 <Gahhh> what's the \\ operator ?
23:00:58 <Pseudonym> Oh, actually.
23:01:01 <Pseudonym> No, that doesn't work.
23:01:07 <Pseudonym> If the elements of xs are not distinct.
23:01:10 <Gahhh> duplicate elements
23:01:39 <ozone> Pseudonym: have you any experience with hugs's trex?
23:01:46 <Pseudonym> ozone: No.
23:01:59 <Spark_> are there any times that arent comparable?
23:02:04 <Spark_> s/times/types/
23:02:12 <ozone> hmm.  am pondering if anybody has used it and has an opinion on it
23:02:29 <Gahhh> user defined types unless they include it
23:02:49 <Pseudonym> Spark_: Sure.  Try throw [(+),(-)]
23:03:23 <Pseudonym> Though you won't be able to show the result.
23:03:27 <Gahhh> why is that a homogenous list ?
23:03:39 <Pseudonym> @type [(+),(-)]
23:03:39 <lambdabot> [(+),(-)] :: Num a => [a -> a -> a]
23:03:44 <ozone> hugs has some really neat stuff in its extra libraries
23:04:08 <Spark_> ah ok :)
23:04:11 <Gahhh> how does it know that '-' is not the unary minus ?
23:04:18 <Pseudonym> Unary minus is special.
23:04:43 <Pseudonym> The compiler turns it into negate.
23:04:46 <Pseudonym> @type negate
23:04:46 <lambdabot> negate :: Num a => a -> a
23:05:17 <Gahhh> like by preprocessing ?
23:05:50 <Pseudonym> Where it gets done is undefined, so long as it gets done.
23:05:57 <Pseudonym> Usually the parser does it, I think.
23:06:14 <Gahhh> so what's a really good book on Haskell ?
23:06:18 <Pseudonym> Or it might be in desugaring.
23:21:51 <haskellNewb> hi, was wondering if anybody could tell me how to add ((a,b,c),d) to [((a,b,c),d]??
23:23:03 <Cale> haskellNewb: what do you mean by that?
23:24:31 <haskellNewb> i need to create a new [((a,b,c),d)] by adding ((x,b,c'),d') on the end of the list
23:24:36 <haskellNewb> i think..
23:24:46 <ozone> newList = list ++ [newItem]
23:26:01 <haskellNewb> oh ok
23:27:36 <Spark_> is there any kind of datatype in haskell that allows you to keep an indexable array?
23:27:55 <Spark_> or a hashtable or something
23:28:08 <Cale> Array?
23:28:10 <Spark_> where you look up straight into the middle of the structure, rather than parsing through a list
23:28:17 <Spark_> oh ok :p
23:28:29 <Spark_> its just that in SML i was told there was nothing that could do that
23:28:37 <Spark_> so i kinda went off it after that
23:29:13 <haskellNewb> [list ++ [((x,b,c'),d')] | (c',d') <- zip [0..50] [m .. 0], x <- [0..9]]....why does this give me a [[a]] and not [a]?? 
23:29:16 <Cale> You can, of course index an ordinary list with the !! operator
23:30:01 <Cale> haskellNewb: because it's a list comprehension where each element is another list.
23:30:23 <haskellNewb> okay, how can i break it into [a]? is this possible?
23:30:43 <Cale> use concat?
23:30:56 <haskellNewb> okay 2 secs...
23:31:07 <Cale> concat :: [[a]] -> [a]
23:31:07 <Cale> concat xss = foldr (++) [] xss
23:31:24 <Cale> (from the Prelude)
23:31:37 <haskellNewb> oops i get a huge error
23:31:37 <Cale> but what exactly are you trying to compute?
23:32:03 <Cale> that seems like an odd computation
23:32:19 <kosmikus|away> you probably want  list ++ [ ... the whole computation ... ]
23:32:21 <haskellNewb> haskell doesn't really make sense to me....first assignment :s
23:32:43 <Cale> what is the assignment?
23:32:57 <haskellNewb> Duckworth Lewis Table calculations
23:34:13 <haskellNewb> the output i get does not match the one im expected to get.....the numbers are right but i cannot get the right format
23:35:23 <ozone> Spark_: Data.FiniteMap (if you're using GHC)
23:35:42 <ozone> there's also a hashtable data structure, but it's destructive-update so you'll need to be in a monad to use it
23:36:11 <Spark_> funky
23:36:28 <emu> Spark_: SML has arrays
23:36:31 <emu> in the basis library
23:37:20 <Spark_> hmm thats weird, my lecturer told me the only way you could do something like that was to interact with natively compiled code
23:37:37 <ozone> what do you mean by 'do something like that'?
23:38:28 <Spark_> if i recall correctly my exact question was "how can one implement a hash table in sml, without an array type with the ability to look up an arbitrary index quickly"
23:39:17 <Spark_> and he said it was impossible, and suggested that i could use some sort of java extension
23:39:45 <Spark_> that was about 14 months ago
23:39:54 <ozone> i'm sure there's plenty of research done on it.  (not saying it's possible, but there will be lots of people who thought hard about the problem).  google around for it, or check out chris okasaki's "purely functional data structures" book
23:41:22 <kosmikus|away> Spark_: quickly = constant time? why do you rule out the array type for implementation?
23:41:34 <ozone> and a trie would probably work
23:42:42 <Spark_> kosmikus|away: i didnt rule it out, i couldnt understand why it shouldnt be possible
23:43:02 <ozone> trie is strictly speaking O(n) lookup, but then again, so is a hash table (which is O(n) where n is the length of the key)
23:43:16 <Spark_> anyway the error is corrected now :)
23:43:28 <ozone> so if a hashtable is O(1), so is a trie :-)
23:43:42 <ozone> how goes it, kosmikus?
23:43:47 <ozone> are you still doing work on generic haskell?
23:44:02 <kosmikus|away> yes, I'm writing my thesis ...
23:44:07 <kosmikus|away> one month to go ...
23:44:12 <ozone> ooo.  good luck :)
23:44:18 <ozone> one month to go, and you've already started writing?
23:44:19 <ozone> impressive
23:44:25 <kosmikus|away> :)
23:44:32 <Spark_> heh
23:44:43 <Spark_> my target is 18000 words in 3 days
23:44:52 <Spark_> i think i wont make that
23:45:04 <kosmikus|away> I wish I had two months additional time ...
23:45:17 <ozone> Spark_: getting off irc would probably help achieve your target
23:45:24 <Spark_> you may well be right
23:45:45 <kosmikus|away> ozone: and how's life in .au?
23:45:51 <ozone> kosmikus|away: hey, i didn't understand what type classes were 4 weeks before my thesis was due. :D
23:46:28 <ozone> kosmikus|away: pretty good.  have to submit an abstract for a paper today (for work, not for haskell, unfortunately)
23:46:29 <kosmikus|away> ozone: but hey, you're referring to a masters thesis there, don't you?
23:46:53 <ozone> kosmikus|away: actually, not even that ... honours thesis, which is only 1 year long
23:47:03 <kosmikus|away> ozone: didn't you say you were at the uni again?
23:47:29 <ozone> kosmikus|away: finished with uni, now i'm a public servant. ;)
23:47:47 <kosmikus|away> cool
23:48:10 <kosmikus|away> so, which public do you serve? I mean, can we post Haskell problems to you and you will solve them? ;)
23:49:09 <ozone> i serve the australian public
23:49:17 <ozone> free haskell problems for australian university students!  not
23:49:35 <ozone> no, working in a research organisation which is heavily government-sponsored (www.csiro.au)
23:50:13 <kosmikus|away> I have to leave, see you around ...
23:50:15 <ozone> there's no programming language research done there, but i plan to hijack the distributed systems group which is the closest thing :)
23:50:18 <ozone> later
23:57:09 * Cale is back (gone 09:12:19)
