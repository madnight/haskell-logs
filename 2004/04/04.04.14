01:03:13 <reltuk> is there a quick easy way to time a function in haskell?
01:03:39 <reltuk> ghc rahter
01:13:57 <Segora> reltuk: doesn't support ghc profiling?
01:14:21 <reltuk> Segora: umm...not really sure...just wanted to know how long the function took to execute from the repl
01:14:50 <Segora> ah
01:15:19 <blackdog> probably be pretty easy to knock one up from the command line...
01:15:24 <blackdog> from the REPL, rather.
01:15:42 <Segora> reltuk: try :?, look at :set +s
01:15:57 <Segora> Prelude> :set +s
01:15:57 <Segora> Prelude> 1+1  
01:15:57 <Segora> 2
01:15:57 <Segora> (0.01 secs, 0 bytes)
01:16:44 <Segora> reltuk: is this what you need?
01:16:52 <reltuk> yeah, that's awesome
01:16:54 <reltuk> thanks :)
01:17:01 <Segora> you're welcome
01:18:57 <Segora> reltuk: you may also want to look at http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-time-options.html
01:19:25 <reltuk> Segora: yeah, had seen that, but ghci -p fac.hs was giving me hell
01:20:39 <Segora> reltuk: I think this option only applies to compilation
01:20:53 <reltuk> *nod*
01:47:32 <bring> good morning #haskell
01:57:55 <blackdog> aw, why'dja wake me...
02:19:51 <shapr> good morning #haskell!
02:20:00 <shapr> hej bring !
02:20:23 <bring> hi shapr
02:20:26 <bring> 'sup?
02:20:42 <shapr> me, almost
02:22:03 <ustenzel> it seems Control.Concurrent.threadDelay does a busy wait (GHC 6.2, Linux) -- can anyone confirm this?
02:22:22 <bring> shapr: :)
02:22:36 <shapr> ustenzel: do you have test code handy?
02:23:43 <ustenzel> shapr: just a minute... the code already rotted a bit when i didn't look.
02:25:28 <ustenzel> 25 lines... I'll put it on the paste page, right?
02:26:41 <shapr> sure
02:27:42 <ustenzel> Done.
02:28:11 <ustenzel> The idea is to read a file while it grows (like tail -f does).
02:28:38 <shapr> er, which paste page?
02:28:47 <ustenzel> At the end of the file I wait for more data.  But both threadDelay and threadWaitRead cause 100% cpu load.
02:28:53 <ustenzel> Oh, there's more than one?
02:29:06 <ustenzel> haskell.org/hawiki/HaskellIrcPastePage
02:29:07 <Lunar^> shapr: seen that : http://haskell.org/pipermail/haskell/2004-April/013949.html ?
02:29:55 <shapr> ustenzel: I just don't see the code, maybe my squid cache is confused
02:30:42 <ustenzel> shapr: Try again.  My first attempt to save didn't produce anything.
02:30:57 <shapr> ok
02:30:59 * ustenzel thinks, wikis don't like him much.
02:31:13 <shapr> takes a bit of getting used to
02:32:06 <ustenzel> Ha!  Just yesterday i edited a wiki page and hit ^W to erase a word.  Closed the browser tab in konqueror.  Not very nice, I tell you.
02:32:56 <shapr> I understand that problem, but there is a solution
02:33:08 <ustenzel> What solution?
02:33:19 <shapr> emacs-wiki can 'proxy' online wikis
02:33:41 <shapr> you can tell it how to map the existing markup to emacs-wiki markup
02:34:22 <shapr> that way all wikis look and act like local in-emacs wikis
02:35:08 <shapr> alternatively, you can use lynx and specify emacs as your textfield editor
02:35:47 <ustenzel> Or vim.  That's what occured to my just after my edits were gone.
02:36:42 <shapr> most wikis work just as well (maybe better) in text-mode browsers
02:38:17 <shapr> ustenzel: yah, it's busy.
02:38:22 <ustenzel> Damn.
02:38:26 <ustenzel> Why?
02:38:36 <saz> ooh
02:38:41 <saz> that's a really good idea
02:38:45 <saz> never thought of doing that
02:38:49 <shapr> I don't know, that is surprising
02:38:50 <ustenzel> There should be a way to block the thread.  All threads for that matter.
02:38:55 <saz> (specifying vim as an editor in links)
02:39:23 <shapr> you can block threads with MVar, right?
02:39:47 <ustenzel> Yeah.  But who would write to the MVar when my file grows?
02:40:05 <shapr> you could use select
02:40:29 <ustenzel> right... once upon a time there was a haskell version of select.
02:40:37 <shapr> though I don't know what's the state of select in Haskell
02:40:42 <ustenzel> where is it?  i can't seem to find it in GHC 6.2
02:41:04 <shapr> I know there are at least two wrappings available
02:41:13 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
02:41:32 <skew> Hi.
02:41:42 <skew> I think I found a use for the reversed state monad
02:41:47 <shapr> y0 skew, how's code?
02:42:00 <shapr> cool, what is that?
02:42:12 <skew> pretty good, just started coding my distributed / component system
02:42:25 <shapr> in Haskell?
02:42:40 <skew> we're trying to make these objects with several input channels, which can be connected together
02:42:45 <Lunar^> ustenzel: threadDelay doesn't make a busy wait
02:42:56 <shapr> skew: arrows?
02:42:58 <skew> with combinators for doing guarded actions and such
02:43:02 <Lunar^> ustenzel: at least with the green thread implentation of the RT
02:43:08 <skew> right now, IO spawning threads reading Chan
02:43:16 <shapr> sounds like Yampa
02:43:39 <Lunar^> shapr: sounds like a driver design for hOp 
02:43:47 <shapr> yah, I agree
02:43:56 <ustenzel> Lunar^: my program is busily doing nothing anyway.  what am i doing wrong then?
02:43:57 <skew> but there is no function for blocking on a (heterogeneous) collection of Chan
02:44:16 <Lunar^> ustenzel: Are you using GHC 6.2.1 ?
02:44:49 <skew> so my friend suggested using a QSem, to be incremented when a message is sent, as an alternative to polling
02:44:56 <ustenzel> Lunar^: no, 6.2
02:45:03 <skew> this requires getting a single QSem per node
02:45:10 <shapr> urg, curryspondence needs orderable search results
02:45:18 <Lunar^> skew: I tried to solve the problem once, it's really annoying
02:45:35 <Lunar^> skew: I think the best thing to do is hack the RTS to add a multiplexing wait operation
02:45:41 <skew> and we want the code to start declaring some channels, then define an IO action to run in the thread, then call some "make me a node" function
02:46:03 <skew> so I think the "make me a node" function should produce a QSem, and propagate it back upwards :)
02:46:13 <skew> Lunar^: ports provides somethig like that
02:46:24 <shapr> Muumipeikko: love the nick
02:46:32 <Muumipeikko> oopsie =)
02:46:43 <skew> well, you can't properly wait on channels of different types all together
02:46:47 <Muumipeikko> minor snafu
02:46:54 * shapr recognizes vegai incognito
02:47:23 <Lunar^> ustenzel: Please try to upgrade to GHC 6.2.1 and add the -threaded flag to your compile options
02:47:50 <ustenzel> Oh well... that might take some time.
02:47:51 <Lunar^> ustenzel: This will tell GHC to link your program with the native thread RTS 
02:51:33 <ustenzel> Lunar^: with native threads i would get true multithreding, not just user space threads?
02:51:34 <skew> perhaps polling a list of exists a. Chan a might work out
02:51:48 <skew> I should play around with that. I'm coding up the state now
02:52:13 <Lunar^> ustenzel: Depends what you call "true multithreading" but GHC will use the underlying operating system threads, yes
02:52:39 <Lunar^> ustenzel: What operating system are you using ?
02:52:51 <ustenzel> Lunar^: that's exactly what I'd like to avoid.  come to think about it, i actually want select.
02:52:54 <shapr> I think native just means that FFI calls don't block, but I could be wrong
02:53:09 <ustenzel> Lunar^: Linux.  Kernel 2.4.something, if it matters.
02:53:13 <skew> ustenzel: RTS threads are premptive, if that's what you mean by "true multitasking"
02:53:25 <shapr> Igloo and I had a discussion about this some time back
02:53:42 <skew> shapr: are you talking about forkOS?
02:53:57 <Lunar^> shapr: There is a bit more than that, but mostly yes
02:57:54 <shapr> no, that makes a new OS thread with thread local state, doesn't it?
02:57:55 <shapr> argh, I need to make a GHC threading FAQ
02:57:55 <shapr> because I keep forgetting the answers!
02:57:55 <Lunar^> skew: when compiled with RTS_SUPPORTS_THREADS, OS blocking functions (eg. getch) don't block the whole program, AFAIK
02:57:55 <shapr> yes, I think so
02:57:55 <shapr> though with 6.2.1 that's the default, akaik
02:57:55 <skew> yeah, that makes a new OS thread for running FFI calls, but the Haskell code is still managed by the RTS
02:57:55 <Lunar^> shapr: Not exactly, you need to specify -threaded on the comand line
02:57:55 <skew> another thing I would like to do is ensure with the typesystem that components are connected together correctly
02:57:55 <skew> some need to start out knowing an input on another channel.
02:57:56 <skew> Types like Chan a -> Chan b -> IO (Chan a, Chan b) plus fixIO work, but I can't see how to make combinators for patterns of connection, like a ring or star topology
02:58:07 <skew> unless all the nodes involved have the smae type
02:58:08 <Lunar^> shapr: But you don't have to keep 3 different GHC compilation on your dev system
02:58:24 <shapr> http://shapr.homelinux.net/cgi-bin/wash/ShowMessage?%3C20031013080204.GC772%40holomorphy.com%3E
02:59:28 <shapr> I'd like to be able to take advantage of SMP
02:59:39 <shapr> since I've already got one
02:59:51 <skew> so instead I'm thinking of making some channels to be used for output, and a function that makes a little process just to shovel messages, once you know where they are supposed to go
03:01:03 <Lunar^> shapr: It's quite an old message
03:05:57 <shapr> I don't see anything else though
03:06:30 <Lunar^> shapr: The scheduler is such a mess... I can be sure of anything
03:06:35 <ustenzel> Oh, the OLD hslibs contain a select binding!
03:07:02 <ustenzel> Thanks guys, I'll try my luck with select.
03:07:20 <Lunar^> ustenzel: I'll be glad to know your progress
03:07:40 <shapr> skew: isn't the problem of Chan types just mentioned on haskell@haskell.org ? are you working with abe?
03:07:53 <shapr> yes, I'll be interested to know
03:07:55 <skew> no
03:07:59 <ustenzel> Lunar^: I'll tell you, as soon as it looks nice.
03:08:09 <skew> I don't remeber anything on the mailing lists recently about Chan types
03:08:21 * ustenzel imagines some ugliness built from select and lots of MVars.
03:08:24 <skew> existential types seem to work just fine for a poll function
03:08:41 <skew> ustenzel: can't you just use threads?
03:08:56 <skew> maybe with the wait-on-file-descriptor function?
03:09:56 <ustenzel> skew: threadWaitRead is exactly my problem.  it does a busy wait.  for no good reason...
03:09:58 <skew> I've written a little poll with type [(PolyChan,a)] -> a -> IO a, where data PolyChan = forall a . PolyChan (Chan a)
03:10:00 <shapr> Lunar^: that database looks wonderful
03:10:22 <skew> ustenzel: Oh, that was the busy wait you mentioned. Too bad
03:10:37 <ustenzel> yeah, too bad.
03:10:38 <shapr> I want to test memory usage etc, but that's exactly what I wanted for curryspondence
03:11:16 <ustenzel> i jumped through some hoops to get a filedescriptor out of a handle and then the wait was useless.  frustrating.
03:11:35 <skew> is the busy wait being a problem?
03:12:26 <skew> I would hope they at least call yield in there
03:13:29 <skew> which would probably work out if you just care about the Haskell program being able to compute
03:14:01 <ustenzel> Of course it is a problem.  If the program does nothing, it should be swapped out, the cpu put to sleep, etc.  it's simply Wrong (with capital W).
03:14:08 <skew> I'm still trying to think about how to reify the need for a component to be connected somewhere as a value
03:14:36 <skew> ustenzel: I'd probably go right ahead and do it, then come back later and hack up something with MVars and a select thread
03:14:54 <skew> you can probably match the interface of threadWaitRead
03:15:11 <skew> If this is the only thing left to do in your program it's a different story, of course
03:16:07 <ustenzel> then again, the "select thread" will not work.  As soon as select blocks, *all* haskell threads block.
03:16:24 <skew> that's where forkOS is supposed to help
03:16:26 <Lunar^> shapr: I'm a bit disapointed that it doesn't have any serialization option
03:16:47 <Lunar^> shapr: Otherwise it could have made a good mini-filesystem for hOp
03:16:50 <skew> I've never used it, but from the docs it sounds right
03:17:00 <ustenzel> yeah, three kinds of fork... i'm already confused enough.
03:17:20 <shapr> Lunar^: we can fix that
03:17:40 <skew> about my code for a moment, right now I implement components that need to start out by sending some data by making a Chan for them to write on, and returning those along with the inputs
03:17:50 <ustenzel> whatever, select might help on it's own.  i'll think about it some more.
03:18:34 <skew> then once I have both ends to connect I make a little thread to be a message pump
03:18:48 <skew> This has the problem that the typesystem doesn't force you to connect all the ends up
03:19:37 <skew> I can't even think of a reasonable way to produce an error about it at runtime.
03:22:22 <skew> hmm, maybe I could use the WASH trick with a Slot UNCONNECTED a type, and the connection function returning Slot CONNECTED a
03:22:55 <skew> to be gathered back up for the sole purpose of witnessing that a connection was made somewhere
03:24:52 <skew> wait, that's no easier than just feeding the actual destinations back
03:25:35 <Lunar^> shapr: Sure :)
03:37:48 * shapr argues about im2000
04:46:36 <bourbaki> hiho
05:24:06 <shapr> gah, how do I enable sticky keys in X?
05:26:01 <ibid> pour some juice on them
05:26:29 <shapr> :-P
05:26:51 <shapr> I want to press shift to have the next key shifted
05:27:30 <shapr> maybe I should just scratch my home keys with my leatherman
05:29:36 <shapr> hmm, that does work
05:29:41 <ibid> hm?
05:31:07 <shapr> I'm using dvorak right hand, trying to touchtype
05:31:52 <ozone> shapr: sure you are
05:32:16 <shapr> I've swapped my keycaps around
05:32:29 <ozone> mr. one handed typist
05:32:31 <shapr> but I keep losing the home keys when I don't look
05:33:32 <shapr> ozone: http://www.scannedinavian.org/~shae/xmodmap-dvorak-right
05:33:35 <shapr> try it :-)
05:34:09 <shapr> I made my owm xmodmap file with xkeycaps
05:34:41 <ozone> shapr: i'd try it if i were on a linux machine running X :)
05:35:26 <shapr> it's not too bad, I think I'll try remapping the weenie laptop we have
05:38:04 <shapr> hi Lemmih 
05:38:11 <Lemmih> yo
05:45:55 <shapr> hi meson 
06:05:53 <shapr> Grettings Oh Ninja of Diplomacy
06:07:12 <SyntaxNinja> greetings, Shapr
06:08:16 <SyntaxNinja> how's it going?
06:11:04 <shapr> I'm slowly relearning touchtyping, what's up with you? how's your adventure of non-portable features?
06:11:17 <SyntaxNinja> hehe
06:11:18 <SyntaxNinja> having fun :)
06:11:49 <SyntaxNinja> you're touch-typing divorak?
06:12:03 <shapr> right hand
06:12:22 <shapr> http://www.scannedinavian.org/~shae/xmodmap-dvorak-right
06:15:37 <meson> hey hey
06:16:05 <vegai> touchtyping?
06:16:32 <vegai> ah, wikipedia 
06:16:46 <shapr> typing without looking at the keyboard
06:17:43 <meson> i hate state machine webapps :/
06:18:13 <shapr> http://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard see the right hand layout there (it's wrong, btw)
06:18:25 <shapr> meson: whatcha doin?
06:18:35 <meson> shapr, working =)
06:18:48 <meson> making VoiceXML webapps in J2EE with servlets/jsps
06:19:06 <shapr> wow, fun
06:19:12 <meson> the people here had made this big state machine platform to base all of our applications on
06:19:55 <meson> The way I see it, session attributes == global variables and redirects == gotos
06:20:36 <shapr> yup
06:20:36 <meson> both of which I am not a fan of :/
06:20:41 <skew> Sounds like a job for a CPS transform :)
06:20:50 <meson> Hah!  I wish
06:21:01 <meson> I suppose I could deploy SISC under their noses =)
06:24:30 <skew> meson: Have you seen anything about the REST architecture? http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm
06:31:24 <meson> looks interesting, has it been implemented by anyone?
06:37:25 <skew> I don't know. I didn't find any comments at all about implementation in a bit of searching.
06:40:28 <SyntaxNinja> Igloo: I see there's a new version of happy; FYI you're welcome to make me co-maint on that and pass me any work you need done... if you upload any pacakges where I'm co-maint, can you update the email address to my debian one?
06:41:08 <Igloo> OK, will do
06:43:14 * Igloo should write down a list of what needs to be done and which tasks depend on each other
06:46:11 <SyntaxNinja> yeah, they really should make software to keep track of stuff like that ;)
06:46:31 <SyntaxNinja> I wish you could "assign" bugs with the debian BTS, I mean assign them to someone besides the maintainer
06:47:12 <shapr> why?
06:51:42 <SyntaxNinja> shapr: because I've got a nice list of the bugs for my packages, but what about if Igloo & I co-maintain a package? he could assign bugs to me and I'd see them on my list and he could exclude them from his list.
06:52:03 <SyntaxNinja> maybe I could even assign bugs to someone who's not a co-maintainer or part of the project whatsoever. like maybe David R. 
06:52:17 <SyntaxNinja> or upstream (rather than having the upstream tag)
06:53:07 <shapr> oh, I see
08:05:54 <shapr> yeehaa!
08:06:14 <cptchaos> yeehaa?
08:07:45 <reltuk> why is fold (flip (:)) O(n)?
08:08:01 <reltuk> foldr (flip (:)) [] rather
08:08:35 <Igloo> Because it does a constant amount of work (make a cons cell) for each element in a list
08:09:41 <reltuk> it's so much prettier than the accumulator version in other functionial languages...
08:09:52 <skew> how do you get foldr (flip (:)) [] to work?
08:09:57 <skew> that gives me a type error
08:10:01 <reltuk> foldl rather
08:11:06 <Igloo> Hmm, is it still linear with foldl?
08:11:25 <skew> yeah, should be
08:11:39 <reltuk> prelude uses foldl...
08:12:14 <skew> I think you get a chain of thunks that will turn into the (:) constructor
08:12:37 <reltuk> skew: so only linear because of laziness?
08:13:02 <Igloo> No, it would be linear if done strictly
08:13:05 <skew> nah, the laziness makes it slower by a constant factor
08:13:23 * Igloo thinks for a second - yup, linear with foldl too
08:13:54 * reltuk wonders why ocaml won't give him curried list constructor
08:14:01 <skew> It takes a:b:c[] and builds (flip (:) (flip (:) ((flip (:)) [] a) b) c)
08:14:17 <skew> which only evaluates down to c:b:a:[] when you traverse it
08:18:26 <reltuk> hmm...I can define reverse in ocaml that way...I wonder how it compares with the accumulator reverse
08:22:08 <shapr> Igloo: did you see the "debian wxhaskell won't load in ghci" thread on h@h.o?
08:23:23 <Igloo> Yes, but I still think the right solution is to split the WX library, which AFAIK hasn't been done yet
08:25:05 * Igloo can't remember if Daan was for or against it
08:27:41 <bring> is anyone working on getting wxhaskell working in hugs btw?
08:35:10 <kosmikus> why doesn't it work in hugs?
08:37:22 <reltuk> man...my email server went down last night and I missed posts to my mailing lists...
08:38:09 <kosmikus> reltuk: no archive?
08:38:58 <reltuk> kosmikus: nah, there are archives...I just like so be able to find parent posts to posts that I'm reading in my client, and now some of them won't be there :-p
08:39:13 <reltuk> (presumably...some ml handlers keep trying to resend until you're back up)
08:43:37 <bring> kosmikus: I think the docs claim that it is possible "in principle"but that noone has created the neccessary
08:43:45 <bring> build system magic
08:45:00 <kosmikus> ah, okay
09:23:54 <shapr> hmm
09:29:22 <shapr> hi monotonom 
09:29:28 <monotonom> hi
09:29:37 <shapr> what's up?
09:33:59 * shapr writes stuff for HC&AR
09:39:14 <shapr> hej tumm 
10:14:31 <bonky> what about exceptions?
10:21:31 <bonky> is there anybody......out there.
10:21:36 <shapr> me!
10:22:06 <shapr> what do you want to know about Haskell exceptions?
10:22:28 <bonky> how does it fit in with no side effects?
10:23:04 <shapr> exceptions are caught in the IO monad
10:23:36 <bonky> so you have to check the IO monad explicitly?
10:24:06 <Si\> yes, that reminds me, is there anyway of getting a read like function to give me Maybe a instead of a, where Nothing is returned on no parse instead of exception?
10:24:31 <Si\> (outside the IO monad of course)
10:24:36 <shapr> alternatively, you can use Maybe or Either to signal errors
10:24:48 <vegai> no-one can be told what the Monad is -- you have to see it for yourself
10:25:26 <shapr> what is the sound of one monad clapping?
10:26:12 <shapr> bonky: look at Control.Exception
10:26:46 <shapr> you can set up your own handler
10:27:18 <bonky> ok. i've been looking at the Hudak book. Is it a good intro?
10:27:47 <shapr> or you can ignore it and your program will stop
10:28:03 <shapr> yes, it's good
10:28:15 <bonky> the topic seems to be multimedia?
10:28:30 <shapr> yes
10:28:53 <bonky> unconventional.
10:30:07 <shapr> if you don't like math, Thompson's book may be more enjoyable for you
10:30:47 <bonky> i like math. that's ok. another question. concurrency in haskell, is there support for that?
10:31:03 <shapr> yes
10:31:12 <bonky> threads and stuff?
10:31:17 <shapr> yes
10:31:31 <bonky> built into the language?
10:31:44 <shapr> look at Control.Concurrent
10:31:49 <shapr> yup
10:33:10 <bonky> are these things covered in hudaks book?
10:33:40 <shapr> you have two models, coroutines with a single OS thread, and a multiple OS thread model that's more useful for foreign calls
10:34:12 <bonky> where is this stuff documented?
10:34:39 <shapr> there are various demos on the wiki and the mailing lists
10:35:06 <shapr> the haskell.org website
10:35:11 <bonky> that's it?
10:35:43 <shapr> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
10:36:10 <shapr> lots of academic papers too
10:36:21 <bonky> a book would be nice...
10:36:33 <shapr> http://www.haskell.org/hawiki/FrontPage
10:37:40 <shapr> I don't think there are any books that deal with threading in Haskell
10:38:15 <shapr> it's not complicated
10:38:19 <bonky> ok. i see that threading is ghc-specific. not standard haskell.
10:39:01 <shapr> I don't know if Hugs or other implementations do threading
10:39:37 <SyntaxNinja> Si\: you might want "reads" there's a discussion on haskell-cafe from 2 days ago about this "handling read exceptions" that doesn't do exactly what you asked, btw.
10:40:31 <shapr> hej Marvin-- 
10:41:48 <Marvin--> evening
10:42:14 * Marvin-- has bought a Go board
10:42:29 <shapr> oboy
10:42:35 <shapr> dangerous
10:42:42 <Marvin--> now I just have to learn the rules :P
10:43:16 <SyntaxNinja> Marvin--: woohoo!!!!
10:43:22 <SyntaxNinja> Marvin--: I recommend the Go wiki actually
10:43:22 <kosmikus|away> the rules are the easy part ...
10:43:37 <shapr> bonky: anything else?
10:43:47 <SyntaxNinja> "A moment to learn, a lifetime to defeat Isaac"
10:43:58 <Marvin--> heh
10:44:06 <kosmikus|away> Si\: you can construct something using unsafePerformIO
10:44:15 <kosmikus|away> let wrap1 f x = unsafePerformIO $ Control.Exception.catch (evaluate (f x) >>= return . Just) (return . const Nothing)
10:44:29 <Marvin--> SyntaxNinja: where's the Go wiki?
10:44:32 <kosmikus|away> let sread = wrap1 read :: String -> Int
10:44:51 <SyntaxNinja> marvin: http://senseis.xmp.net/
10:44:53 <_Codex> Someone just needs to write haskell program that plays go well.
10:44:56 <kosmikus|away> then sread "x" yields Nothing, and sread "5" yields 5
10:45:13 <_Codex> shouldnt be that difficult? :)
10:45:18 <shapr> _Codex: GO for it!
10:45:33 <SyntaxNinja> nice thing about studying Go on a web page rather than a book, is that htey don't mind putting up tons of little example images
10:45:42 <_Codex> shapr: I dont know the rules.
10:45:56 <SyntaxNinja> _Codex: and apparently you don't know that no one has ever written a very good go engine? ;)
10:46:06 <bonky> shapr, not for the moment. I see that the ghc documentions is very good. I'm gonna do some studyin i think. A pity you need internet to learn haskell!
10:46:07 <Marvin--> I'm looking at "The Interactive Way To Go" right now
10:46:08 <kosmikus|away> _Codex: I happen to know someone who just finished his PhD on something related to writing Go software
10:46:23 <kosmikus|away> I should ask what his results are, or read his thesis ...
10:46:48 <_Codex> syntaxninja: well, that's why it'd be a nice thing to try.
10:46:49 <Marvin--> actually, I found a guy at gothcon who I've played go with at another convention and asked him about where to find a nice board
10:47:02 <SyntaxNinja> _Codex: :)
10:47:04 <Marvin--> he gave me some names but what do you know I found a nice one today when I walked into the gaming store :-P
10:47:14 <SyntaxNinja> Marvin--: is it a full sized board?
10:47:21 <shapr> bonky: the docs come with, you can print them out
10:47:23 <SyntaxNinja> around these parts, they don't sell nice boards in gaming stores
10:48:08 <Marvin--> SyntaxNinja: 19x19
10:48:22 <SyntaxNinja> Marvin--: how big are the stones?
10:48:31 <SyntaxNinja> (or the squares, for that matter :) )
10:49:46 <Marvin--> SyntaxNinja: somewhere between 15 and 20mm I think
10:50:18 <shapr> I think this is written in Haskell: http://home.tiscali.be/stevevh/thesis/demo/guiLogon.htm
10:50:44 <kosmikus|away> SyntaxNinja: squares? on a Go board?
10:51:02 <bonky> shapr, ah a printer...
10:51:21 <bonky> shapr, whish I had one.
10:51:33 <SyntaxNinja> sorry, rectangles
10:51:44 <kosmikus> :)
10:51:57 <Igloo> huh?
10:53:34 <bonky> gotta go study...
11:09:59 * Marvin-- tries to figure out Ko fights
11:14:12 <shapr> has anyone else investigated this? --> http://home.tiscali.be/stevevh/
11:14:51 <shapr> at first glance, I don't see how much of a webapp I have to write myself
11:18:36 <shapr> Si\: hey that url might be interesting to you
11:27:43 <shapr> I can't tell if this CWL thing is nifty or not
11:28:29 <Si\> ooo looks shiny
11:29:13 <shapr> yes, but is also useful?
11:29:23 <shapr> hej ski
11:29:33 <Si\> dunnom shinyness can be deceiving
11:30:31 <shapr> yah, that's what I'm looking for
11:30:42 <ski> hej shapr !
11:33:35 <shapr> I've never heard of xmlhttp
11:59:17 <SyntaxNinja> Igloo: you look confused ;)
12:00:21 <Igloo> Probably, but where in particular?  :-)
12:00:49 <shapr> Si\: the pic on page 48 seems to summarize that design
12:01:07 <SyntaxNinja> (13:52:01) Igloo: huh?
12:01:36 <Igloo> Oh, yes
12:01:55 <Igloo> The squares vs rectangles
12:03:19 <SyntaxNinja> oh.
12:03:38 <SyntaxNinja> a go board is not a square
12:03:44 <Igloo> Why not?
12:04:06 <SyntaxNinja> which is because the lines are farther apart in one direction than in another :)
12:04:21 <Igloo> Because...?  :-)
12:04:34 <SyntaxNinja> are you asking why would they do this?
12:04:41 <Igloo> Yes
12:05:48 <SyntaxNinja> no clue
12:06:00 <SyntaxNinja> well, maybe because of perspective
12:06:07 <SyntaxNinja> you're not usually looking at the board from above
12:07:17 <Igloo> Hmm, fair enough
12:07:44 <kosmikus> SyntaxNinja, Igloo: yes, it's because of perspective
12:07:45 <shapr> bah, this requires a JavaScript implementation of soap, which he did not furnish
12:08:13 <kosmikus> you wouldn't do it for a board on a computer screen ...
12:08:20 <shapr> interesting, but unusuable
12:13:17 <shapr> the GUI generation is neat
12:17:57 <SyntaxNinja> kosmikus: thanks
12:24:29 <reltuk> anyone have a reference to the haskell type system?
12:26:48 <shapr> I think you'll find lots if you look at Simon Peyton-Jones published papers
12:27:29 <shapr> but in essence it's Hindley-Milner
12:29:08 <reltuk> shapr : I ask because ocaml screws up something like let reverse = List.fold_left (fun x y -> y :: x) [], where haskell thinks nothing of it
12:30:26 <inkedmn|work> shapr!
12:30:32 <shapr> I dunno much about ocaml, sorry
12:30:39 <shapr> y0 inkedmn|work !
12:30:49 <inkedmn|work> it's been awhile, how's things?
12:30:56 <reltuk> yeah...they're both based on Hindley-Milner...something is wrong with ocaml though
12:30:57 <ski> reltuk : screws up in what way ?
12:31:02 <shapr> code is good
12:31:11 <shapr> always learnin
12:31:38 <reltuk> ski: it's not a true polymorphic function...once you apply it once, it gets stuck to the only working on the types of lists you applied to it the first time
12:31:52 <ski> oh, that
12:32:10 <ski> value polymorphism
12:32:15 <shapr> inkedmn|work: wassup with you?
12:32:17 <reltuk> if you explicitly list the parameter is works, but semantically equivalent statements should have the same type...it's obviously broken
12:32:21 <SyntaxNinja> is there an extension that might let me write a function that operates on heterogeneous lists where all the items are instances of the same typeclass? something like a more generic version of:
12:32:21 <SyntaxNinja> showUs :: forall a. (Show a) => [a] -> [Char]
12:32:21 <SyntaxNinja> showUs s = concat $ map show s
12:33:16 <ski> reltuk : it's a restriction put into the type system because side-effects are present in the language
12:34:06 <reltuk> ski: seems like the type of the application should just be the type of the returned function...
12:34:08 <ski> reltuk : (there are problems with side-effects and polymorphism coexisting naively)
12:34:52 <Riastradh> SyntaxNinja, [[showUs :: [forall a. Show a => a] -> [Char]]] -- I believe that's a Glasgow extension.
12:35:05 <ski> reltuk : essentially, the restriction says that only syntactic 'values' can have their type generalized to a polymorphic type
12:35:32 <kosmikus> SyntaxNinja: not using the [] type, afaik
12:35:41 <kosmikus> SyntaxNinja: if you define your own datatype, you can do it
12:36:02 <reltuk> ski : ahhh...and since that returned function isn't a value (or 'value' rather..functions are first order), it doesn't get polymorphisized
12:37:07 <reltuk> http://www.cse.ogi.edu/~mpj/thih/
12:37:14 <SyntaxNinja> Riastradh: that's the type? I get a parse error
12:37:24 <ski> reltuk : yeah, applications aren't syntactically values, while lambda-abstractions are (and function definitions with arguments on the left of '=' counts as lambda-expressions)
12:37:54 <Riastradh> SyntaxNinja, uh, you're not writing those two outer pairs of square brackets, are you?
12:38:24 <SyntaxNinja> Riastradh: I get a parse error either way :)
12:38:39 <Riastradh> Hmmmm.  I could swear there was some kind of extension like that.
12:39:38 <ski> reltuk : e.g. "let r = ref []" (not totally sure about exact syntax). what type would r get, naively ?
12:39:54 <Riastradh> '_a list ref
12:40:03 <ski> (s/exact syntax/exact O'Caml syntax/)
12:40:09 <reltuk> ski: yeah, and then '_a gets updated when r gets something put into it
12:40:21 <ski> Riastradh : "naively" ?  :)
12:40:36 <ski> reltuk : right
12:41:24 <kosmikus> Riastradh, SyntaxNinja: I'm quite certain that there is no way in GHC to directly instantiate the [] type constructor to a polymorphic (or class-constrained) type.
12:41:26 <reltuk> references are dirty anyway...
12:42:49 <SyntaxNinja> kosmikus: OK
12:45:24 <kosmikus> UHC is supposed to be able to do that, but it will be a long time until UHC is anywhere near to a usable compiler
12:47:25 <SyntaxNinja> I think I'll stick w/ GHC for now ;)
12:47:59 <kosmikus> I wasn't suggesting otherwise ;)
12:51:00 <Marvin--> god I love this game
12:51:09 <Marvin--> sorry Syntax, I abandoned Go for some Ricochet Robot tonight :-)
12:53:45 <kosmikus> anyone going to AFP this year?
13:04:19 <SyntaxNinja> Marvin--: heh
13:06:49 * Marvin-- is kicking ass
13:32:20 <SyntaxNinja> so, I notice that HUnit has a TestLabel constructor... is that label ever used? I would like it to actually output the name of the test suite, if it has one.
13:33:12 <SyntaxNinja> similarly for QuickCheck, I'd like to give names to the tests / test suites
14:02:21 <bring> shapr: didn't we talk about writing a haskell RDBMS just a week or so ago?
14:03:18 <bring> does Alexander Jacobson hang out here?
14:21:41 * Marvin-- mutters something about semai and corners
15:44:36 * Pseudonym yawns
15:45:02 * ski does not yawn
15:45:21 * esap blinks.
15:45:27 <Pseudonym> Never?
15:45:38 <ski> atm
15:48:16 * esap wrote another version of while loop: while :: (t -> Either a b) -> (a -> t -> t) -> t -> (b,t)
15:53:21 <ski> while f g = loop where loop t = either (\a -> loop (g a t)) (\b -> (b,t)) f t   ?
15:54:06 <esap> while cond body z = case cond z of { Left x -> while cond body (body x z) ; Right y -> (y,z) }
15:54:13 <ski> um, s/f t/$ f t/
15:54:46 <ski> yeah, that's the same
15:56:15 <ski> so a is something that the loop produces to hand over to itself in the next run, and b is the final value (t being the state) ?
15:57:09 <ski> hm
15:59:32 <esap> ski: I think of it in terms that the second argument is a constructor that will create a bigger data structure each iteration. The condition just computes whether to continue or not.
15:59:32 <reltuk> it distresses me that I'll never be able to use good programming languages if I ever go into industry
15:59:40 <camio> reltuk: What do you define as good?
16:00:27 <esap> ski: try put (:) as the second argument.
16:00:57 <earthy> reltuk: plus, it depends on where you go into industry
16:00:57 <reltuk> camio: hard to define formally...but the industry (at least currently) is so riddled with C/C++/Java/perl...
16:01:14 <ski> esap : hmm, i see
16:01:14 <reltuk> camio: not saying that C isn't good...if it's what you need, I guess it's ok
16:01:15 <earthy> Rational Rose/RT
16:01:19 <earthy> Ada
16:01:20 <earthy> VDM
16:01:23 <earthy> VDM++
16:02:00 <earthy> Fortran in places
16:02:00 <camio> retuk: You are very correct on your diagnosis on today's software.  However even though my main project is in C++, I use Haskell to prototype any hard code.
16:02:03 <earthy> COBOL in places
16:02:26 <earthy> formal methods and functional programming are finding inroads
16:02:29 <ski> esap : but it could also, say, drop a few initial elements of a stream ..
16:02:32 <earthy> see e.g. Aetion
16:02:42 <Pseudonym> retuk: I disagree on one point.  C is no good.
16:03:02 <reltuk> Pseudonym: what do propose for portable bit-pushing?
16:03:03 <earthy> C is good enough for a certain purpose
16:03:13 <earthy> reltuk: Haskell can do that
16:03:17 <Pseudonym> There is precisely one situation where I would use C, and that's in small embedded systems where C++ executables are too big (due to EH and RTTI).
16:03:22 <camio> Compared to C++, C is pretty simple and elegant
16:03:26 <Pseudonym> SMart cards, boot loaders etc.
16:03:42 <Pseudonym> Even if I only used a C-like subset of C++, I'd still prefer C++ every time.
16:03:43 * earthy notes that smartcards are currently mostly programmed in Java
16:04:04 <Pseudonym> Personal opinion, of course.
16:04:06 <reltuk> oh, you're arguing for C++ over C...I like C++ more than C too
16:04:25 * earthy also notes he's somewhat too drunk to actively participate well in any conversation
16:04:25 <Pseudonym> Of course, you can program C in any language. :-)
16:04:42 <earthy> as you can program functionally in any language.
16:04:44 <reltuk> earthy: hah, what time is it where you are?
16:04:53 <earthy> 00:57
16:05:11 <Pseudonym> Might want to sync your clock there.
16:05:18 <Pseudonym> It's just _past_ the hour.
16:05:20 <reltuk> oh, that's good...it's 6pm here...I was thinking I might have been drunk a few times at 6pm, but I'm pretty sure I wasn't on IRC
16:05:32 <reltuk> yeah, I've got 6:05 over here
16:05:42 <earthy> plus I've had 5 Leffe Dubbel (trappist beers) and 3 or 4 (lost count) Palm
16:06:06 <earthy> pseudonym: true, I'm trying to gather data on the abberrations in the clock on this machine
16:06:10 <earthy> it's slow :)
16:06:13 <camio> Pseudonym: There really isn't anything like opengl for C.  That's I guess one thing that it's good for.
16:06:19 <earthy> it's 1:06 then here, now. ;)
16:06:26 <Pseudonym> camio: Sure there is.
16:06:36 <reltuk> hmm..I had never heard of VDM/++
16:06:40 <Pseudonym> Any C library works with C++, to a first approximation.
16:07:03 <earthy> reltuk: don't make too many assumptions about industry
16:07:09 <earthy> it *will* mostly suprise you\
16:07:12 <camio> Sure, but when programming for graphics, you are usually using the C subset of C++.
16:07:16 <earthy> (it did (and does) me)
16:07:21 <Pseudonym> No you don't.
16:07:34 <Pseudonym> I worked in visual effects for a year.  Apart from legacy APIs.
16:07:40 <Pseudonym> no C
16:07:47 <earthy> some Cg?
16:07:49 <reltuk> camio: that depends...a lot of game engines are C++ now...
16:07:49 <Pseudonym> And there were precious few of those, thankfully.
16:07:58 <earthy> mostly higher level code, I'd guess
16:08:01 <Pseudonym> RenderMan in my case.
16:08:04 <reltuk> with the notable exception of Carmack's, because he's bit-anal
16:08:25 <earthy> anyway, time for bed
16:08:28 <earthy> nytol
16:08:36 <Pseudonym> Night.
16:08:47 <camio> My higher level code usually doesn't include opengl.
16:09:06 <Pseudonym> Interestingly, though, the renderers used to produce most visual effects and animation tends to be written in pure C.
16:09:22 <Pseudonym> Pixar's PRMan and PDI's deep file system, notably.
16:09:40 <Pseudonym> Though others are making headway.
16:09:48 <Pseudonym> The main reason they're written in C is they're so old.
16:10:03 <camio> I do wish there was something nicer than C that could be used to do low-level coding.
16:10:21 <reltuk> imperative ocaml/
16:10:35 <Pseudonym> Well, the thing I think you want to do in general is abstract the low-level bits.  Even C programmers try to do that.
16:10:54 <Pseudonym> Personally, I think mixed-language programming is the way to go.
16:11:34 <camio> I've considered that, however in practice it is to hard to maintain and create new development machines.  When with a team it becomes really hectic.
16:11:36 <reltuk> Pseudonym: ffi can be so obtuse though...
16:11:49 <reltuk> Pseudonym: that's what all the hype was about .net I guess...
16:12:16 <Pseudonym> I actually quite like COM as a base layer.
16:12:24 <Pseudonym> Shame about the Microsoft interface classes.
16:12:29 <Pseudonym> They're all horribly broken.
16:12:43 <Pseudonym> But COM itself is quite clean, IMO.
16:12:52 <reltuk> my expierience with COM made me want to vomit...
16:12:57 <reltuk> but I'm guessing that was the microsoft touch you mention
16:13:08 * Pseudonym nods
16:13:14 <Pseudonym> I'm thinking more Mozilla.
16:13:24 <Pseudonym> Cleaner interfaces built on top of a COM-like layer.
16:15:47 <reltuk> ahhh, I'm not familiar with Mozilla's internals or extension interface
16:15:56 <camio> Pseudonym: Where did you work on visual effects?
16:16:05 <Pseudonym> www.dotcsw.com
16:18:59 <camio> Pseudonym: Did you work on RenderDotC?
16:19:24 <Pseudonym> Yes.
16:19:30 <Pseudonym> A little.
16:19:38 <Pseudonym> Mostly I worked with Maya.
16:19:56 <camio> What did you do with Maya, if you don't mind me asking?
16:20:10 <camio> RIB exporter?
16:20:14 <Pseudonym> Kind of.
16:20:31 <Pseudonym> I can't really say, but it was something like that.
16:20:34 <Pseudonym> It wasn't Mai-Tai.
16:20:57 <camio> Oh
16:21:10 <reltuk> what's mai-tai?
16:21:19 <Pseudonym> It's on the site.  It's a RIB exporter for Maya.
16:21:29 <camio> I did some 3dsMax exporting to a special format a while ago.
16:21:39 <reltuk> oh, iteresting
16:21:40 <Pseudonym> The thing is, RenderMan plug-ins are usually more complex than just exporters.
16:21:46 <reltuk> .3ds is braindead :-p
16:21:58 <camio> Indeed
16:22:08 <Pseudonym> camio: You familiar with RenderMan?
16:22:48 <camio> I've read about it and have done some simple stuff with procedural textures.
16:22:55 * Pseudonym nods
16:23:16 <camio> There used to be that free renderman program out there for a while but it disappeared as far as I can tell.
16:23:24 <reltuk> man...I wish I had a cool graphics project
16:23:59 <camio> bmrt or something like that
16:24:14 <Pseudonym> www.aqsis.com
16:24:28 <Pseudonym> Oh, BMRT.
16:24:31 <Pseudonym> That's a sad story.
16:24:41 <camio> What happened?
16:24:43 <Pseudonym> A lot of people were really angry about what happened there.
16:25:06 <Pseudonym> Oh, well.  BMRT was written by Larry Gritz.
16:25:27 <Pseudonym> He got a job at Pixar, and they used BMRT for a few shots in A Bug's Life.
16:26:00 <Pseudonym> He and a couple of other Pixar employees left and formed a start-up, ExLuna, which wrote their own rendering software.
16:26:16 <Pseudonym> They distributed BMRT, as well as Entropy, their own system.
16:26:33 <Pseudonym> Anyway, Pixar sued them for patent violations and trade secret violations.
16:26:45 <Pseudonym> Being ex-Pixar employees.
16:27:03 <Pseudonym> So nVidia bought ExLuna, and neither BMRT nor Entropy can be obtained any more.
16:27:04 <reltuk> http://www.renderman.org/RMR/OtherLinks/blackSIGGRAPH.html
16:27:16 <Pseudonym> Yeah, that's pretty much it.
16:27:27 <camio> That's rough
16:27:48 <Pseudonym> It really, really sucked.
16:27:57 <Pseudonym> Qute a few people are still angry at Pixar.
16:28:02 <Pseudonym> Not just over that.
16:28:11 <reltuk> eh, sounds typical industry to me...
16:28:20 <Pseudonym> Also, Pixar is still a very software-patent-happy company.
16:28:45 <reltuk> most commercial software i've worked on has even had clauses in the contract saying I can't work on competing software for x years/months after leaving the project
16:29:03 * Pseudonym nods
16:29:07 <camio> reltuk: Most of that isn't enforcible.
16:29:17 <Pseudonym> The thing is, Pixar is making far more money off movies than they are of software.
16:29:28 <reltuk> Pseudonym: this is very true...
16:29:30 <Pseudonym> I really don't see why they're bothering with this.
16:29:46 <reltuk> software patents are a vicious cycle...it's hard to compete if you take the high road and your competitors slam you with them
16:30:37 * Pseudonym nods
16:30:42 <reltuk> Pseudonym: irrational actions usually lead back to people and emotions...maybe they pissed off one of the higher ups...
16:30:52 <Pseudonym> And it's the little guys, like ExLuna, who get hurt the most.
16:30:55 <camio> Yeah, that's what I'm thinking
16:31:28 <Pseudonym> It is possible.  We'll probably never know.
16:33:07 <camio> Pseudonym: Are you concentrated in graphics?
16:38:43 <reltuk> I want to program graphics in haskell because it's funny
16:38:52 <camio> Why is it funny?
16:39:02 <Pseudonym> Not any more.
16:39:12 <Pseudonym> I'm in databases now.
16:39:15 <reltuk> because graphics are so traditionally imperative
16:39:19 <Pseudonym> THough I still hack on Aqsis in my spare time.
16:39:26 <camio> Pseudo: That's quite a change in direction
16:39:33 <reltuk> do you like databases?
16:39:40 <Pseudonym> My trouble is there are too many interesting things in the world.
16:39:47 <camio> lol
16:39:52 <Pseudonym> I do like databases, at least the one we develop here.
16:39:54 * ski smiles
16:39:59 <reltuk> maybe I don't know enough about databases...
16:40:09 <Pseudonym> Well, we're talking text databases.
16:40:21 <Pseudonym> The thing is, this job is highly technical, and I like that.
16:43:51 <Pseudonym> We're solving hard problems.
16:43:51 <Pseudonym> Everyone who works here is very smart.
16:43:51 <reltuk> I like solving hard problems
16:43:51 <reltuk> do you work at google or something? :-p
16:43:51 <camio> hehe
16:43:51 * reltuk notes that google solves hard problems and has very smart employees
16:43:51 <camio> Pseudo: Ever work in computational geometry?
16:43:51 <Pseudonym> http://www.teratext.com.au/ <- for those who are curious
16:43:51 <camio> Funny, that is quite in google's space.
16:43:52 <Pseudonym> Text database are a fast-growing field with lots of discoveries to be made.
16:43:52 <Pseudonym> Look at the number of PhDs Google has. :-)
16:43:52 <Pseudonym> camio: No, though I am interested in computation geometry.
16:43:55 <reltuk> yeah...google takes a crapload of graduate students from one of my professors filesystem research team
16:43:56 <Pseudonym> Well, we don't really compete with Google.
16:44:22 <Pseudonym> Google is not designed to handle general collections.
16:44:30 <Pseudonym> You can't use Google as a library catalogue system, for example.
16:44:49 <Pseudonym> Google is designed for a small number of massive databases.
16:45:05 <Pseudonym> Whereas we're designed for a large number of not-quite-so-massive databases.
16:45:19 <camio> I think google is quite expanding the definition of search tools with their gmail system.
16:45:45 <Pseudonym> Also, we deal a lot with custom applications.
16:45:51 <Pseudonym> Here, let me give you an example of what we do.
16:46:29 <Pseudonym> A large defence contractor has a contract to build a dozen or so warships.
16:46:44 <Pseudonym> They're to be built over ten years.
16:47:11 <Pseudonym> Now of course you don't buy the parts to build a dozen ships and then build them all.
16:47:23 <Pseudonym> You build them one at a time, and buy the parts as you need them.
16:47:37 <Pseudonym> Over the course of ten years, some parts become no longer available.
16:47:39 <Pseudonym> Right?
16:47:46 <camio> sure
16:48:01 <Pseudonym> OK.  SO what you're going to end up with is a dozen ships, all of which are slightly different.
16:48:25 <camio> uh hu
16:48:33 <Pseudonym> They'll have the same panel with the same screws, but what's under the panel might be different.
16:48:43 <Pseudonym> Now consider producing the maintenance manuals for these ships.
16:48:58 <Pseudonym> Each set of manuals is going to be different.
16:49:07 <Pseudonym> But large slabs will be the same.
16:49:11 <camio> Right
16:49:39 <Pseudonym> And if you make a change to one part of one manual, you want those changes to propagate through to all of the manuals for the ships which have the same parts.
16:49:47 <Pseudonym> Well, that's one of the things that we do.
16:50:01 <Pseudonym> Legislation is another example.
16:50:13 <Pseudonym> The law is a constantly changing body of text.
16:50:17 <camio> Okay, so kind of a revision control system with forking branches.
16:50:23 <Pseudonym> And in a court case, what's important is the law as it was at the time.
16:50:31 <Pseudonym> We deal with that, too.
16:50:50 <camio> It's an interesting vertical market.
16:51:02 <Pseudonym> It gets worse if the law is multi-lingual, as it is in Canada.
16:51:09 <Pseudonym> Yes, it is.
16:51:14 <Pseudonym> We do a lot of this specialist stuff.
16:51:33 <camio> As a business owner, I wouldn't know to search for this sort of specialist.
16:51:45 <camio> You must do a lot of marketing.
16:51:46 <Pseudonym> Another example (which we didn't get the contract for, incidentally) is Lonely Planet.
16:51:53 <Pseudonym> No, we answer a lot of tenders. :-)
16:52:03 <Pseudonym> And we go to the right conferences.
16:52:11 <camio> nice
16:52:30 <Pseudonym> Lonely Planet has a travel guide for the USA, one for Hawaii and one for Oahu.
16:52:32 <Pseudonym> For example.
16:52:41 <Pseudonym> That's a document management problem not unlike the warship manuals.
16:53:20 <Pseudonym> Because these travel guides all have some stuff in common and some stuff that's different.
16:53:28 <camio> right
16:53:34 <Pseudonym> So yeah, we solve interesting problems around here.
16:53:36 <camio> What's your sustainable compedative advantage?
16:53:52 <Pseudonym> camio: I don't understand the question.
16:54:25 <camio> Well, what sets your business apart from the current and future competition?
16:54:37 <Pseudonym> Well, first off, we don't have a lot of competition.
16:54:46 <camio> First to market is good.
16:54:50 <Pseudonym> Other people do text, but they tend to base their stuff on top of relational databases.
16:54:56 <Pseudonym> Oracle Text, for example.
16:55:06 <Pseudonym> Modelling text with relational databases is very slow.
16:55:12 <Pseudonym> Our databases are fast and small.
16:55:33 <Pseudonym> Secondly, we have a good track record, especially with legislation.
16:56:03 <Pseudonym> Thirdly, we're partnered with a large US business which people in our target markets have heard of.
16:56:13 <camio> Do you use a specialized proprietary sort of database?
16:56:16 <Pseudonym> Yes.
16:56:20 <Pseudonym> We write it here.
16:56:26 <Pseudonym> That's what I do for a living.
16:56:34 <Pseudonym> I don't hack on the document management applications.
16:56:48 <camio> I mean, if it isn't Relational, what is it?
16:57:02 <camio> That is if it falls into any common paradigm.
16:57:11 <reltuk> Pseudonym: is it done in C?
16:57:13 <Pseudonym> Well, we use Z39.50.
16:57:16 <Pseudonym> reltuk: C++
16:57:27 <Pseudonym> Z39.50 is the latest incarnation of what used to be known as WAIS.
16:57:31 <reltuk> good stuff
16:57:50 <Pseudonym> It's as close to a standard in text retrieval as there is.
16:58:12 <Pseudonym> The best way to think of Z39.50 is to compare it with Google.
16:58:36 <Pseudonym> Google web search (as opposed to usenet, images etc) indexes multiple kinds of documents.
16:58:44 <Pseudonym> It can handle HTML, PDF, powerpoint and so on.
16:59:03 <Pseudonym> But it hides them behind a common abstraction.
16:59:31 <Pseudonym> Similarly, Z39.50 has the notion of physical records (which might be XML, PDF or whatever), and a logical layer above them.
16:59:40 <Pseudonym> So you can search on "title", no matter what kind of document it is.
17:00:38 <camio> Are you an employee or a partner?
17:00:40 <Pseudonym> The other major difference from relational databases, is that relational systems have, as their abstraction, the "stream of tuples".
17:00:43 <Pseudonym> I'm an employee.
17:00:51 <Pseudonym> We're technically owned by RMIT University.
17:01:54 <Pseudonym> Text systems don't work on tuples.  Instead, you manipulate sets of physical records.
17:02:00 <Pseudonym> Or record numbers, anyway.
17:02:50 <camio> You familiar with yaz?
17:02:54 <Pseudonym> A little.
17:03:37 <camio> Incidentally, what's your connection to Haskell?
17:03:46 <Pseudonym> I like it. :-)
17:03:51 <camio> lol
17:03:56 <camio> Where did you hear about it?
17:03:58 <Pseudonym> I've been using pure functional languages since 1992.
17:04:05 <Pseudonym> Started out with Miranda.
17:04:13 <Pseudonym> Then Gofer, then Haskell.
17:04:18 <reltuk> I had toolchains
17:05:12 <camio> reltuk: toolchains?
17:05:38 <reltuk> yeah...trying to point an IDE to a bunch of header files
17:05:53 <Pseudonym> Hey, I just got a spam with this subject line:
17:05:58 <Pseudonym> ghc longlasting erecthions k
17:06:02 <Pseudonym> I didn't know GHC could do that.
17:06:39 <reltuk> hahaha
17:06:43 <ski> heh
17:10:43 <shapr> bring: yes, no
17:11:09 <shapr> bring: at least, I don't think he does
17:11:14 <shapr> g'day Pseudonym 
17:11:19 <Pseudonym> G'day,
17:21:18 <reltuk> monads are a lot like continuation passing style
17:22:10 <Pseudonym> reltuk: There's a paper by Ralf Hinze called "Deriving Backtracking Monad Transformers"
17:22:13 <Pseudonym> Ever read it?
17:22:44 <reltuk> nope...I'll make an effort to thought
17:22:47 <Pseudonym> http://www.informatik.uni-bonn.de/~ralf/publications/ICFP00.ps.gz
17:22:47 <reltuk> though*
17:22:56 <Pseudonym> The connection is interesting.
17:23:12 <Pseudonym> Basically, CPS as a way to derive monads from specifications.
17:23:16 <reltuk> thanks :)
17:23:19 <Pseudonym> Very nice paper.
17:27:49 <skew> Pseudonym: have you made any progress with the component stuff you were trying to write in Haskell?
17:28:03 <Pseudonym> I haven't had a chance to pursue it.
17:28:21 <Pseudonym> Been very, very busy.
17:28:21 <skew> I've just started seriously working on my project.
17:28:25 <Pseudonym> Oh?
17:28:51 <skew> a term project, the main goal being something for simulating little distributed systems
17:28:58 <Pseudonym> Cool.
17:29:12 <Pseudonym> Using something like threads and pipes, I assume.
17:29:15 <skew> well, for distributing them too. Really a Haskell library very close to the formalism
17:29:24 <skew> I'm thinking Chan for simulation
17:29:36 * Pseudonym nods
17:29:42 <skew> I'm checking out Erlang too
17:29:55 <Pseudonym> Erlang, of course, does this natively.
17:30:05 <skew> not as much as I would like
17:30:19 <skew> it doesn't really provide a notion of separate inputs to a process
17:30:30 * Pseudonym nods
17:30:40 <skew> or a declarative way of linking processes into a graph
17:31:00 <Pseudonym> You'd have to use an explicit multiplexer, I suppose.
17:31:02 <Pseudonym> In Erlang.
17:31:17 <skew> do you mean a demultiplexer?
17:31:23 <Pseudonym> Do I?
17:31:25 <Pseudonym> Possible.
17:31:50 <skew> The way receive scans the channel ignoring messages that don't match makes it less of an issue
17:32:11 <Pseudonym> In Erlang, the simplest way would be to create a thread for each separate input, wrap them, then drop them in the channel for the "real" process.
17:32:20 <Pseudonym> Is that a multiplexer or a demultiplexer?
17:32:40 <Pseudonym> I think it's a multiplexer.  Combining different channels to form one channel.
17:33:04 <skew> that part would be a multiplexer, but separating those out into separate logical channels in the main process would be demultiplexing
17:33:09 <Pseudonym> Right.
17:33:55 <skew> and it's more complicated to tell those little processes to start or stop listening on their channel
17:34:03 <Pseudonym> Yes.
17:34:37 <Pseudonym> Mind you, Concurrent.Chan is no better in this respect.
17:34:37 <skew> right now I'm trying to figure out what sort of interface I want to provide
17:34:45 <Pseudonym> You can't really wait on multiple channels.
17:35:49 <skew> I was coding up a little reader/writer program, and playing with an interface where the server accepts a request for permission by returning a Chan that will accept commands
17:36:27 <skew> but it does get fairly messy
17:36:50 <skew> That seems to be more or less the model E is built on.
17:37:55 * Pseudonym nods
17:39:14 <reltuk> why hasn't someone written a better TeX?
17:39:21 <Pseudonym> reltuk: They have.
17:39:44 <reltuk> Pseudonym: not just macros and the likes...I mean things like a real language to get around the constant number of registers, etc.
17:39:47 <Pseudonym> But nobody uses it.
17:39:51 * reltuk still guesses they have, just he hasn't seen it
17:40:03 <Pseudonym> Hang on, let me find a link.
17:41:20 <Pseudonym> http://snark.ptc.spbu.ru/~uwe/lout/lout.html
17:41:22 <Pseudonym> There it is.
17:42:54 <Pseudonym> skew: Seen this? http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/hashtable/
17:43:05 <Pseudonym> I was playing with various ways to implement the same concurrent data structure.
17:43:37 <camio> Hrm, this lout thing is interesting.
17:44:06 <Pseudonym> It's much more functional than TeX.
17:44:38 <keverets> but sadly, used nowhere near as much.
17:44:52 <keverets> the graphing in lout is really nice, or at least easy.
17:44:55 <reltuk> hmm...looks pretty good
17:47:48 <reltuk> it's math typesetting doesn't look nearly as good
17:48:35 <Pseudonym> No, but it has a nice interface.
17:49:04 <skew> Pseudonym: I think the chanel implementation could probably be cleaned up with some helper functions
17:49:17 <skew> for things like querying the table and waiting for a result
17:50:15 <skew> I'm mostly interesting in tyepsetting math at the moment
17:50:45 <reltuk> yeah...the nice thing about TeX is that it looks absolutely gorgeous
17:51:00 <skew> well, produces pretty output
17:51:11 <reltuk> haha, right...*after* it's been processed
17:51:25 <Pseudonym> skew: Go ahead. :-)
17:51:33 <reltuk> so we need to take that backend...and make a better frontend (but more than macros...because they're clearly not enough)
17:52:20 <skew> I will eventually. I think I'll start out implementing something that provides simpler semantics first
17:52:42 <skew> just little state machines passing around tokens and stuff like that
17:54:29 <reltuk> I love that lazy primes function
17:54:49 <skew> which one?
17:55:13 <reltuk> any one...since I don't even know how it works...
17:55:42 <reltuk> but sieve [2..n] where sieve (p:ps) = p : sieve [n | n <- ps, n `mod` p \= 0]
17:56:49 <skew> I should show you some of the lazy code I've written!
17:57:04 <reltuk> haha, I'm sure I would find it facinating
17:57:18 <skew> you don't understand primes?
17:57:36 <reltuk> nah, I do
17:59:10 <skew> have you seen Bird's repMin example?
17:59:31 * reltuk googles
18:00:27 <skew> http://www.cse.ogi.edu/PacSoft/projects/rmb/repMin.html
18:01:21 <ski> that's fun !
18:01:36 <camio> I loved that :)
18:03:33 * ski thinks that's related to attribute grammars
18:03:58 <skew> yeah. It's very close to the code UU_AG produces
18:04:52 <ski> i've been playing around with defining small attribute grammar examples in prolog
18:05:15 <reltuk> that the bejesus does that recursive m do?
18:05:25 <camio> Hrm, I think I prefer latex to lout.  Seems much better for the typist when it comes to equations.
18:05:30 <ski> (though repmin is trivial with logical variables :)
18:05:36 <skew> actually, I think it's identical up to stylized use of lets in the UU_AG code
18:07:32 <ski> hmm, what about if both getMin and putMin have IO effects ?
18:08:00 <ski> will that work ?  how would it be sequenced/interleaved ?
18:08:50 <reltuk> holy crap...every integer in the tree has the same memory address?
18:10:08 <ski> i don't think so ..
18:10:19 <reltuk> then how does it get updated?
18:10:28 <camio> Why not?
18:10:34 <ski> it returns a new tree
18:10:43 <ski> the old is still around
18:10:47 <reltuk> right, I know that
18:10:52 <reltuk> every integer in the new tree...
18:11:16 <reltuk> maybe not the same memory address...they're all probably they're own thunks
18:11:19 <ski> well, i suppose every integer in the new tree is the same thunk
18:11:41 <reltuk> but when they get forced, they read the value from m's memory address, which has been getting changed this whole time
18:12:01 <reltuk> it's almost like destructive updates and pointers...ow my head
18:13:01 <ski> i think they read only the final m, not the intermediate ones ..
18:13:38 <reltuk> right...but it's the same m...
18:14:09 <ski> no
18:14:23 <ski> just the same name
18:14:49 <ski> reltuk : do you know any prolog ?
18:14:55 <reltuk> yeah, just a tiny bit
18:15:44 <reltuk> I'm saying there is no final m...
18:15:54 <ski> there is
18:16:07 <ski> the one that's in replaceMin
18:16:08 <reltuk> when it builds the leafs with L m...somehow those m's become whatever the m in replaceMin ends up being
18:16:16 <ski> right
18:16:40 <ski> because the final m returned into replaceMin is passed as argument to rpMin
18:17:38 <reltuk> right...but it's not...because by the time that m gets returned, we've already been all the way through rpMin...
18:17:43 <reltuk> it's a total mindf*** dude :-p
18:17:46 <ski> so, in the recursive calls of rpMin, the argument m is the final one, while the result m is the intermediate one (which is going to be the final one, at the top call to rpMin)
18:18:04 <ski> yes it is ! :)
18:18:31 <reltuk> that's crazy awesome
18:19:26 <ski> if you code this in prolog as a single-traverse predicate, then the recursive calls are just going to share all the integers in the new tree. *then* at the top-level call, all those are going to be instantiated to the final m returned by the pred :)
18:19:45 <ski> (this is a bit similar to working with pointers, but safer :)
18:19:48 <shapr> I want postfix ops
18:19:58 <reltuk> shapr: what for?
18:20:02 <shapr> I should check out Okasaki's stuff
18:20:12 <shapr> for an embedded Joy
18:23:22 <ski> but is joy is concatenative and not postfix, right ?
18:23:37 <ski> s/but is/but/
18:23:51 <shapr> it is postfix
18:24:07 <ski> what about "dup *" then ?
18:24:15 <shapr> oy, it's nearly 3:30am, no wonder I'm sleepy
18:24:34 * Pseudonym got about 3 hours sleep last night
18:25:01 <shapr> ski: that's "square" 
18:25:07 <ski> yeah
18:25:12 <shapr> 3 dup * gives 9
18:25:30 <ski> surely you can't say that * is postfix there, right ?
18:25:38 <shapr> it is
18:25:56 <shapr> 3 dup * -> 3 3 * - > 9
18:26:03 <ski> if * is postfix, then it should be syntactically after two arguments
18:26:10 <ski> that's how i understand it
18:26:10 <Pseudonym> ski: No.
18:26:11 <shapr> it is :-)
18:26:16 <Pseudonym> No it isn't.
18:26:21 <Pseudonym> It is _semantically_ after two arguments.
18:26:26 <shapr> oh
18:26:29 <Pseudonym> Postfix languages evaluate from left to right.
18:26:59 <shapr> it's fun
18:27:01 <Pseudonym> 3 dup leaves two arguments on the stack.
18:27:03 <ski> then i don't get why it is called postfix
18:27:22 <ski> (which is more or less the same as i said above, i guess)
18:27:22 <shapr> (+ 1 2) is prefix
18:27:32 <Pseudonym> Well, dup is an odd case.
18:27:35 <shapr> 1 + 2 is infix
18:27:37 <ski> infix and prefix and mixfix is related to syntax
18:27:48 <shapr> 1 2 + is postfix
18:27:53 <ski> in "5 !" '!' is postfix
18:27:55 <Pseudonym> "dup" increases the number of things sitting on the stack.
18:28:12 <Pseudonym> So it's not postfix in a syntactic sense.
18:28:27 <Pseudonym> But Joy doesn't really have a parse tree.
18:28:44 <shapr> if dup were prefix, dup * would give * * instead
18:28:46 <Pseudonym> It's syntax is basically a list of tokens, read from left to right.
18:28:55 <Pseudonym> Its, not It's
18:28:56 <ski> that's why i don't think of forth and postscript and joy as postfix
18:29:04 <Pseudonym> Greengrocer's apostrophe.
18:29:17 <Pseudonym> ski: They're postfix in the sense that function invocations come after aguments.
18:29:20 <Pseudonym> arguments
18:29:46 * ski thinks that's concatenative, not postfix :)
18:29:51 <Pseudonym> Possibly.
18:30:15 <ski> (if we're talking about semantics and not syntax)
18:30:31 <Pseudonym> In fact, if you run a Joy function on a virtual stack, what you end up with is a dag, not a tree.
18:30:38 <shapr> sleeptime, cya
18:30:44 <ski> Pseudonym : hmm (re parse tree), what about [...] things in joy, then ?
18:30:56 <ski> shapr : good dreaming !
18:31:04 <reltuk> anyway, gotta log offline for a while..
18:31:07 <reltuk> catch you guys later :)
18:31:07 <Pseudonym> Night.,
18:31:19 <Pseudonym> ski: I'm not sure how Joy implements them.
18:31:42 <Pseudonym> PostScript, for example, handles [...] as operations on the stack.
18:32:01 <Pseudonym> Basically, the "]" token creates an array consisting of everything on the stack up to the most recent "[".
18:32:14 * ski thinks of joy juxtaposition (concatenation) as function composition
18:33:15 <ski> Pseudonym : itym, everything produced on the stack up to the most recent "[", no ?
18:33:34 <Pseudonym> Yes.  Did I not say that?
18:33:40 <Pseudonym> I meant to imply it, anyway. :-)
18:37:47 <camio> Just wondering, what irc clients are you all using?
18:37:56 <ski> ircII atm
18:38:31 <anduril1> gaim
18:38:45 <camio> kvirc
18:39:31 <keverets> irssi
18:40:15 <saz> irssi!
18:40:27 <Riastradh> irssi
18:40:39 <Riastradh> Or, more accurately:
18:40:39 <Riastradh> Irssi 0.8.6 (20021117) - http://irssi.org/
18:40:53 <Riastradh> Hrumph.  I was hoping that /SV would do something more exciting than that.
18:41:05 <keverets> Irssi 0.8.9 (20031210) - http://irssi.org/
18:41:30 <keverets> yup, not very exciting.
18:42:04 <Etaoin> xchat
18:45:14 <Pseudonym> sirc
18:51:08 <camio> Funny that the haskell irc client doesn't show much face here?
18:51:08 <anduril1> didn't know there was one
18:51:08 <camio> http://www.haskell.org/hircules/
18:51:08 <Pseudonym> Well, lambdabot hangs around.
18:55:40 <keverets> I couldn't get hircules to compile the last time I tried.
19:03:07 <camio> I guess I'll try this irssi.  Anything's got to be better than kirc.  I'm surprised nothing's better than mirc for linux
19:04:12 <saz> hm
19:04:15 <saz> i dislike mirc
19:04:22 <saz> like irssi much better :)
19:04:41 <camio> Really?  The last time I used it was over 5 years ago.  What don't you like about it?
19:04:47 <saz> well
19:04:58 <saz> last time i used it, it was about 4 years ago
19:05:02 <saz> and um
19:05:11 <saz> well, i like a text based client much better
19:06:30 <camio> This autocompletion feature makes the text based client as efficient as a graphical one.
19:06:47 <saz> i think it's more efficient
19:06:53 <saz> you don't have to move hands from keyboard to do stuff
19:07:01 <saz> and it can be screened
19:09:55 <camio> Do you use vim or emacs?
19:10:12 <saz> vim
19:10:21 <camio> gotcha :)
19:12:06 <camio> This channel is pretty cool.  People who use advanced editors and think the replMin function is cool.
19:12:51 <saz> heh
19:13:30 * ski smiles
19:13:44 <camio> Seriously, it is quite different from my working "peers" who prefer VB with GUI IDE's.
19:13:50 <Smerdyakov> Are you suggesting that vim is advanced and emacs isn't?
19:14:12 <camio> Oh no.  I was asking if he used "vim or emacs" as opposed to neither.
19:14:13 <ski> well, iirc some structural editors use attribute grammars for incremental/adaptive computations
19:14:30 <camio> I respect emacs users although I am not one.
19:22:53 <skew> I think I should learn emacs more. I want an editor that provides some semantic information about my code
19:23:17 <skew> I don't know if emacs would do it, but it's probably closer than vim.
19:23:46 <camio> like syntax highlighting?
19:24:11 <skew> everything does that. I'm more talking about autcompletions, and "show me the type of this expression"
19:25:13 <camio> I know that vim has very basic support for autocompletions with C++.
19:25:56 <Smerdyakov> I guess that would matter if there were any reason to use C++. :P
19:26:28 <camio> Well, it's done with vim scripts so it'd be a start if someone wanted the feature for language x.
19:27:19 <skew> It would also be nice to work in terms of blocks rather than indentation+autoindent
19:28:31 <skew> things like pulling copying some statements into a do block at different indentation
19:31:53 <ski> (hmm, seem like the repmin example with mdo don't like to perform io effects in both 'passes'. not even in only second 'pass', actually :/)
19:32:34 <skew> do any of you using irssi know how to split a window horizontally? he docs are pretty sparse
19:32:45 <skew> ski: you have to be really careful about strictness
19:33:02 <ski> skew : hmm, what do you mean ?
19:33:21 <skew> I was trying to write a function that connected a bunch of processes in a ring (each Chan a -> IO (Chan a), with forkIO)
19:34:05 <ski> what's the exact semantics of fixIO (or fixST, for that matter), btw ?
19:34:12 <ski> mhmm
19:34:29 <skew> zipping with the list resulting from sequencing, but the sequence is strict in the spine of the list you feed it so that didn't work out
19:34:40 <skew> took me a while to figure out why I was gettin <<loop>> and switch to foldM
19:35:26 <skew> I don't know if there is an exact semantics to IO in the first place, but fixIO pretty much gives you lazy access to the result of the computation
19:35:57 <skew> so take care you are not strict in it!
19:36:32 <ski> i wonder how the state is connected in fix[IO|ST]
19:37:09 <skew> pretty easily I think. IO a  something like RealWorld -> (a, RealWorld)
19:37:40 <ski> so how does fixIO connect it ?
19:38:34 <ski> i was thinking if some part of the IO result not really depends on the iostate, then one can separate it ..
19:39:19 <skew> like you would connect it in your own state monad, I think. fixState (f::a -> s -> (a,s)) = \s -> let (answer,s') = f answer s in (answer,s')
19:39:47 <skew> I'm pretty sure IO is just there to make sure that RealWorld token is passed along in a single-threaded way
19:40:28 <ski> hmm
19:40:31 <skew> so functions taking RealWorld can do all sorts of evil things like play with state, and still be referentially transparent
19:40:32 <Smerdyakov> Anyone here in the USA starting graduate school in the fall?
19:41:15 <ski> skew : so why doesn't doing IO in just the second 'pass' work ?
19:41:49 <skew> I don't know. What are you trying to do? Is there code on the paste page or something?
19:42:12 <ski> i can put it there ..
19:46:31 <skew> is it up yet?
19:46:43 <skew> I don't see anything
19:48:19 <ski> done
19:49:20 <skew> why did you import mfix?
19:49:32 <ski> um
19:49:34 <ski> not sure
19:49:44 * ski smiles sheepishly
19:50:52 <ski> (i guess i thought i was going to use/need it when i made the file for some two weeks ago ..)
19:51:58 <skew> I was wondering if maybe Hugs needed you to import it to use mdo syntax
19:53:16 <skew> I'm pretty sure print is strict
19:53:18 <ski> hmm, maybe 'twas that
19:54:09 <ski> i was thinking that replaceMin2 would work ok, but no, it didn't (in hugs, at least)
19:54:44 <skew> the extra parentheses around the lazy patterns seem to be unecessary
19:54:54 <skew> irrefutable patterns
19:55:02 <ski> prolly
19:55:12 <ski> i didn't write them ..
19:57:50 <skew> hmm, weird things happen
19:58:02 <skew> it prints GlobMin, and then lists the elements again
19:58:41 <ski> (in rpMin2) it seems to me that because the first pass doesn't actually do any IO (it's 'pure'), the second pass would be the one that actually modified the RealWorld ..
19:58:50 <ski> replaceMin1 ??
19:59:36 <ski> for me, replaceMin1 prints "Program error: {_Gc Black Hole}" after the first GlobMin
19:59:59 <skew> mine spins around a few passes before printing <<loop>>. I'm using GHCi for this
20:00:10 <ski> ok
20:00:25 <skew> but it really shouldn't be repeating IO like that!
20:00:35 <ski> yeah, right
20:00:43 <ski> how about replaceMin2, then ?
20:01:00 <skew> that just says loop right away
20:01:05 <ski> ok
20:01:19 <ski> same here
20:01:28 <ski> (i.e. "Program error: {_Gc Black Hole}")
20:01:38 <skew> I think replaceMin1 should be a bug report
20:01:54 <ski> hmm
20:03:44 <ski> in replaceMin0 i think (Tree Int, Int) -> IO (Tree Int, Int) could be explicitely separated into Tree Int -> IO (Int -> Tree Int,Int)
20:04:18 <ski> e.g. the second pass doesn't really do any IO, there
20:05:15 <ski> in replaceMin2, IIANM, i would think (Tree Int, Int) -> IO (Tree Int, Int) could be explicitely separated into Tree Int -> (Int -> IO (Tree Int),Int)
20:05:45 <ski> e.g. there the second pass/stage does IO, but the first one doesn't
20:06:52 <ski> but i guess i'll have to try to check this by hand-calculations, using the functional definition for fix[IO|ST] ..
20:07:14 <skew> which are those?
20:07:37 <skew> fixIO f /= fixIO f >>= f
20:08:02 <ski> i was thinking about the one you showed above ..
20:08:44 <ski> hmm, is fixIO = fixST in GHC ?
20:08:54 <skew> pretty close I think
20:09:31 <ski> (e.g. i wonder if it's semantics is the same as if it would be defined in that way ..)
20:16:00 <skew> okay, I did have the definition about right.
20:16:45 <ski> ok
20:16:53 <skew> I don't know where that looping came from.
20:17:08 <skew> do you want to submit a bug report?
20:17:35 <ski> i don't know how to do that (never done such a thing before ..)
20:18:48 <skew> well, mail the program and associated information to the ghc bugs list
20:19:10 <skew> or use the sourceforge page
20:19:17 <skew> I've already stripped down that example
20:19:38 <ski> hmm, then i guess i'll have to make it ghc friendly (not sure if it already is ..)
20:26:12 <skew> I'll just mail it in then. I've pruned it down to the one case, collected compiler output and all that
20:26:53 <ski> hmm, ok, thanks
20:27:38 * SyntaxLaptop is visiting the UK in a few weeks
20:28:14 <SyntaxLaptop> does anyone here do any backpacking in the UK? I've done the West Highland Way and am looking for another walk where there's a lot of camp sites. was thinking of the cleveland way, but they seem to want you to stay in B&Bs
20:28:24 <SyntaxLaptop> (sorry for the OT, I just know that there are UK folks here)
20:34:45 <skew> ski: my mail server seems to be having trouble
20:35:01 <skew> could you mail something instead? I've collected all sorts of output and stuff, I can DCC a tarball
20:35:51 <ski> yes
20:36:14 <ski> if i can understand how to recieve the dcc, that is ..
20:37:37 <skew> looks like it worked. What IRC client are you using?
20:37:43 <ski> ircII
20:38:19 <ski> (console-based)
20:38:32 <skew> I'm using xchat. I used irssi for a while, but I couldn't figure out how to split the window horizontally, or show different channels in different terminals or something
20:39:02 <ski> well, xchat is not properly installed here yet (i think)
20:39:43 <ski> hmm, ok so where should i send it ?
20:40:04 <ski> is there some bug report template i should use ?
20:41:02 <skew> just mailing it to the bugs list, glasgow-haskell-bugs@haskell.org. Write some little note about describing the problem
20:41:31 <skew> I'd probably cram all the little bits of information except for the ghc -v output.
20:41:49 <skew> Oh, CC me on it brandon@its.caltech.edu
20:45:28 <ski> should i use any specific subject ? none at all ?
20:45:43 <skew> oh, just something like "fixIO bug"
20:56:59 <ski> hmm
20:57:53 <ski> i'm writing some about the 'only IO effects at second pass'-version (in a parenthesis), is that appropriate here ?
20:58:12 <skew> I'd write about the version with the effects in both passes
20:58:28 <skew> the one matching the code I sent you, that produces the wierd output
20:58:36 <ski> i already have
20:59:07 <skew> I'd ask about that on haskell-cafe. print is strict, I don't think there is a mystery there
20:59:12 <ski> i was just thinking that i might perhaps also ask about the last version in a parenthesis, but maybe it doesn't belong there ..
21:00:43 <ski> ok, i'm skipping that, then
21:01:00 <skew> the behaviour in that case seems at least reasonable
21:01:22 <skew> this mdo stuff works a lot better for the code I'm writing with threads
21:01:54 <skew> if every place that actually uses the variables being threaded around in the fixpoint are wrapped inside of forkIO they can block without causing problems, I think
21:02:01 <ski> hmm, just ordinarily attach the dcc:ed file, yes ?
21:02:15 <Pseudonym> Are there any haskell-libs admins here?
21:02:20 <skew> I'd unpack it first
21:02:32 <skew> the output and command lines and such probably go in the message body.
21:02:55 <skew> I think only the ghc -v output is long and boring enough to relegate to an attachment
21:03:31 <ski> hmm, ok
21:03:36 <skew> I'm off for a while.
21:05:14 <ski> skew : ok
23:07:16 <reltuk> anyone have hints on the haskell emacs mode?
23:07:31 <reltuk> like how does everyone get their equals signs to line up? just putting space in?
23:08:18 <ibid> yes
23:08:25 <reltuk> isn't that tedious?
23:09:32 <Pseudonym> i_tend_to put my equals signs
23:09:38 <Pseudonym>   = on_the next line
23:09:48 <Pseudonym> -- Indenting does the rest
23:10:01 <Pseudonym> Not that I use Emacs.
23:10:15 <reltuk> yeah...so much code I see has them all ligned up, with the spacing set as one space away from the longest lhs of the group
23:10:24 <reltuk> seems like a simple emacs function could do that
23:12:26 <ibid> it's not that tedious
23:13:14 <reltuk> ibid: more tedious than it needs to be though...
23:17:53 <ibid> reltuk: i'll agree once i have such functionality in emacs :)
23:18:02 <reltuk> ibid: hah
23:18:18 <ibid> reltuk: before that i'm content with what i have
23:20:32 <reltuk> ibid: wise of you...
23:24:20 <reltuk> wow...I found some code that already does it
23:24:24 <reltuk> that's awesome
23:29:23 <reltuk> it works on the current region...and was apparently written for C...but it works great
23:51:27 <reltuk> anyone know the exact syntax regarding when an equals sign is actually the equals sign?
23:51:48 <reltuk> is it one if there's any alpha-numeric or whitespace before it?
23:52:11 <reltuk> reverse= foldl (flip (,)) [] <--- is that valid or does there need to be a space?
23:55:25 <reltuk> n/m
23:56:16 <ski> i think a space is not required in that case
23:57:08 <reltuk> but in like... :>= is it...
23:58:27 <Pseudonym> The rule is that there's a bunch of operator characters.  The lexer will take as many as it can to form an operator.
23:58:59 <Pseudonym> In the case of reverse=, '=' isn't a valid character for an identifier, so a new token starts there.
23:59:18 <Pseudonym> For, say, ==>, they're all operator characters, so your implementation will take them all.
23:59:31 <Pseudonym> ':' is special, because it's the operator equivalent of a capital letter.
23:59:56 <Pseudonym> If an operator starts with ':', it's a constructor operator.
