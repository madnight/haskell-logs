00:20:34 * reltuk wishes he knew what IORefs and FFI's were  :-p
00:20:40 <reltuk> oh...foreign function interface..
00:38:17 <musasabi> How do I create selfreferences? I want to create a structure containing an IORef to itself...
00:50:40 <bring> good morning #haskell
00:54:15 <musasabi> morning
00:55:38 <musasabi> TyingTheKnot explains how to do it in the lazy case, but that is hard with IORefs...
01:02:19 <musasabi> because creating an IORef is an IO action they have be sequenced. But to create the IORefs I need to have the listnode...
01:08:56 <Si\> I think skew managed to achieve it rather well
01:10:20 <musasabi> hum?
01:11:11 <Si\> let me see if I can find the code...
01:11:56 <Si\> you got DCC?
01:12:23 <musasabi> found http://www.cse.ogi.edu/PacSoft/projects/rmb/doubly.html seems nice.
01:12:33 <musasabi> thanks
01:12:45 <Si\> it might not be what you're looking for, but it might
01:13:22 <Si\> that's not working is it
01:16:03 <musasabi> seems like firewall touble (university server)
01:16:27 <musasabi> DCC can't connect to 192.168.0.10 port 32830
01:17:03 <Si\> dang it's trying to connect to my local machine
01:18:24 <musasabi> can you mail it to ekarttun@cs.helsinki.fi ?
01:18:29 <musasabi> that would seem simpler
01:19:40 <Si\> ok done, the first didn't have the attachment :/
01:22:32 <musasabi> thanks, got it.
01:34:44 <musasabi> hum solved it with mdo.
02:35:42 <skew> musasabi: mdo is unecessary. I just found the code I wrote for Si\
02:37:32 <skew> never mind, Si\ didn't want the looped structure to use IORefs, just contain some, I think
02:38:17 <skew> Isn't a linked list one of the examples in the mdo paper?
02:42:16 <Si\> IAHO, should a null array be array (x,y) [] where x==y, or is it just sufficient to assume that if it has no contents it is null?
02:45:51 <ztre> :-D
02:46:43 <ztre> :-(
02:48:18 <Marvin--> err
02:50:44 <Si\> arrays are a really annoying data-structure
02:51:17 <Si\> there doesn't seem to be a way of figuring out whether it's null or not
02:51:32 <Si\> without raising an exception
02:52:04 <Marvin--> "null"?
02:52:15 <Marvin--> what do you mean by "null"?
02:52:26 <skew> just what I was going to ask. undefined elements are bottom
02:52:37 <skew> bounds should work if you just want to know the size
02:52:57 <Si\> in SOAP it is valid to pass an array with nothing in it, i.e. null
02:52:58 <skew> and "null" as in C is the scourge of the earth
02:53:22 <Si\> so if I get an Array that is "null" I want to convert it to Nothing
02:53:35 <Si\> or Just (Array Int a) if it's valid
02:53:39 <skew> you could use Maybe (Array)
02:53:39 <Marvin--> Si\: and this is represented as NULL in C/C++ bindings?
02:53:54 <Si\> no Marvin--
02:54:10 <Si\> I have a class called Nullable, which defines the null value of any type
02:54:25 <skew> why?
02:54:25 <Si\> using this null value you can convert any a to a Maybe a
02:54:29 <Marvin--> I just don't think that "null array" is particularly well defined
02:54:44 <skew> Why don't you just use Maybe types all over the place?
02:55:06 <Si\> yes, but how do I figure out whether something is Null?
02:55:16 <skew> in the marshalling?
02:55:17 <Marvin--> things that can be either null or a value in SOAP sounds like it should more appropriately be represented by a Maybe in Haskell
02:55:22 <Marvin--> yes, in the marshalling
02:55:50 <Marvin--> surely the marshalling layer knows which arrays are "null" and which are not?
02:56:00 * Marvin-- still doesn't know what a null array is, though
02:57:50 <skew> null values mixed into a type are just a bad idea. Everythings fine, and then you get this one value that raises an exception if you try to do anything to it. Bye bye algebraic laws!
02:58:23 <Marvin--> no kidding
02:59:15 <Si\> ok, so what you're saying is that I shouldn't allow things to be marshalled to Arrays, only Maybe Arrays?
02:59:19 <skew> please, use Maybe if you want to explicitly lift a type over a null element
02:59:33 <Si\> I can do that
02:59:37 <skew> well, I'm saying if you can sometimes get arrays and somtimes not get arrays, that's a Maybe array
03:00:05 <skew> why not unmarshall a missing array into bottom, if you are looking for a null array value?
03:00:28 <Marvin--> because you want to be able to marshal a "null" array back :)
03:00:41 <Marvin--> or so I guess
03:00:55 <Si\> no, I was trying to create a general case for marshalling values which have some concept of a Null Value
03:01:07 <Si\> in SOAP at least
03:01:12 <Marvin--> the general case is Maybe a ;-)
03:01:41 <Si\> so what would happen instead of Marshalling something to a, you'd marshal to Maybe a
03:02:14 <Si\> which would call the marshal function fo a, compare it to the "Null" value and return Nothing or Just
03:02:35 <skew> There's a big difference between a null value that's just a perfectly well behaved value you want to mark for some reason, like 0 in numbers, or [] in lists, or maybe False
03:02:56 <Marvin--> er, wait, marshalling is the process of packing down something into a language-agnostic format, right?
03:03:30 <Si\> In XML Schema any declaration of a type can be called nillable, which means it can be set to nil (or null)
03:03:37 <Marvin--> so you'd have  marshal (Just x) = pack x ; marshal Nothing = packed_null
03:03:43 <Si\> or defined as nillable rather
03:04:11 <Marvin--> that is, marshal :: (Foo a) => Maybe a -> PackedSomething
03:04:28 <skew> yeah, looks good to me
03:04:28 <Si\> just so
03:04:59 <Marvin--> but the marshalling function isn't what's interesting, the packed_null :: PackedSomething value can be put in a type class
03:05:05 <Marvin--> unmarshal is what's important
03:05:08 <Si\> but my Marshalling class doesn't marshal everything to Maybe, because Ints cannot be invalid really
03:05:39 <Marvin--> so have two type clases
03:05:41 <Marvin--> classes
03:05:53 <Marvin--> one with a function that returns Maybe a and one with a function that returns a
03:05:55 <skew> so marshall some things to Maybe and some not
03:06:56 <skew> That shouldn't be a problem if there are only a few types involved.
03:06:58 <Marvin--> unmarshall_Int {representation_of_42} = 42    unmarshall_array_thingy {representation_of_null_value} = Nothing
03:07:10 <skew> I guess if you have schemas and stuff running around it's trickier
03:07:45 <Si\> atm, my marshal class looks like this;
03:07:47 <Si\> class (Typeable a, Show a) => Marshal a where
03:07:47 <Si\>     marshal :: (Value a) -> ParameterName -> IO CallValue
03:07:47 <Si\>     unmarshal :: CallValue ->  IO (Value a)
03:08:15 <Marvin--> and all error handling is done in the IO monad?
03:08:22 <Si\> all values, have to be armoured anyway because any value can be reference
03:08:32 <Marvin--> right
03:08:35 <skew> okay. you can just make instances for Int, Maybe Array, etc
03:08:45 <Si\> so I think I'll just set Null Values to be NulVal rather than Nothing
03:08:55 <Marvin--> that works too
03:09:17 <skew> why do they need to be references, again?
03:09:28 <Marvin--> but then the property that some values cannot be null values is lost
03:09:30 <Si\> data Value a = Val a | Ref (IORef CallValue) | NullVal deriving (Show, Typeable)
03:10:09 <Marvin--> I mean, you'd then have to handle the case of   marshal (NullVal::Value Int)
03:10:36 <Si\> true
03:10:47 <Marvin--> if you instantiate Maybe (Array ...) instead, you'll get that for free
03:10:56 <Si\> but that's the users fault for trying to do something stupid ;)
03:11:02 <Marvin--> otoh,  instance Marshal (Maybe (Array ...))  is not H98
03:11:19 <Marvin--> I'm guessing you're using plenty of non-H98 features anyway, though :)
03:11:28 <Si\> I have to
03:11:41 <skew> I still don't understand the references. I think that's only useful if you assume the haskell is immediately going to perform a stateful computation on those values
03:12:01 <skew> and possibly for constructing explicit sharing in the graph you marshal out
03:12:27 <Si\> skew, I'm sorry but I didn't understand either of those
03:13:10 <Si\> contructing explicit sharing?
03:13:22 <Marvin--> I'm in love with Text.PrettyPrint
03:13:26 <Marvin--> I'm never going to use ++ on strings again
03:14:04 <skew> as I understand the situation SOAP is basically rpc based on marshalling graph structures into XML for transfer
03:14:31 <Si\> yes
03:14:52 <skew> I don't understand the utility to a Haskell programmer of demarshalling a graph into something containing mutable values
03:15:11 <Si\> neither do I :)
03:15:15 <skew> I mean, it's not like you are going to communicate with the other machine by side effect
03:15:42 <Si\> I do have code for doing TyingTheKnot in there
03:15:48 <skew> so how does the IORef in your Value type come in?
03:16:11 <Si\> TyingTheKnot is disabled at the moment
03:16:28 <Si\> right, first stage we parse the SOAP Document
03:16:43 <Si\> put all references into a HashTable and reference them
03:17:22 <Si\> second step convert them into the CallStructure, in which references are (Reference (IORef CallValue))
03:17:24 <Marvin--> "XML: Making Simple Things Hard"
03:17:46 <Si\> step 3, convert CallValues to Haskell data via Marshal class
03:18:20 <Si\> can't be done without a dictionary, so we simply pass back the reference to the CallValue
03:18:38 <Si\> as Ref x
03:19:22 <Si\> well it _can_ be done without a dictionary by comparing references
03:19:26 <Si\> but it's hard
03:19:45 <skew> so why the IORefs?
03:19:57 <skew> rather than laziness? (If I'm reading the description right)
03:20:36 <Si\> my friend gave me a sample SOAP document from the web-serivce he's built
03:20:55 <Si\> it's hideous, a massive web of references
03:21:27 <Si\> now I'm trying to create a generalised system which can deal with any situation
03:21:45 <Si\> in data-processing it's quite possible that people might wanna edit this tree
03:22:08 <Si\> which I can't do it it's lazy
03:22:20 <Si\> s/it/if
03:22:23 <skew> you mean restructure the tree?
03:22:37 <Si\> that's one possibility
03:22:47 <skew> you can build a normal tree with IORefs in the cells easily enough if they just want to edit the values
03:22:53 <Si\> or just change a single data-item
03:23:27 <skew> or they can be good little functional programmers and build a new graph
03:23:45 <Si\> I hate using Value a though
03:23:51 <Si\> I might just throw it away
03:24:13 <skew> but really, won't people mostly be extracting arguments and stuff to do some thinking and build an unrelated response?"
03:25:00 <Si\> Maybe I could have two Marshallers
03:25:08 <skew> or even three
03:25:25 <Si\> one for Laziness and one for Value a
03:25:33 <skew> A purely functional structure is nice to work with
03:25:58 <skew> I'd write that first, and think a bit about how to do the other two if somebody asked for them
03:26:02 <Si\> either way I don't have time before hand in to rewrite the Marshalling system, but I'll be the first to admit it is hideous at the moment
03:26:41 <Si\> that's why I created automarshal, which does all your marshalling automatically if there are no references
03:27:17 <skew> the other two I'm thinking of would be building the graph structure purely, but putting values in mutable cells, and making the whole thing out of IORefs
03:27:26 <skew> Si\: why doesn't it handle references?
03:28:01 <Si\> cuz it uses Read and Show
03:28:09 <Si\> and Show can't Show IORefs
03:28:20 <skew> there are two sorts of reference here
03:28:26 <Si\> just so
03:28:41 <skew> there are mutable values, and then there are the references between different parts of the structure
03:28:54 <Si\> what I plan on doing is to have a flag which you can set if you want to tie the knot or if you want to use the Value thingy
03:29:15 <skew> I think the second could be handled with some way of naming parts of the graph you feed the marshaller
03:30:01 <Si\> I you're right though, transforming the tree is way better because then you can use Data.Generics
03:30:35 <skew> or using pointer equality if you want to force the user to build a structure that is actually recursive (consider replicate x = let res = x : res in res and replicate x = x:replicate x)
03:31:47 <Si\> main problem I came up against was I can't build this thing in a strict Monad, but it just recurses forever
03:32:42 <skew> what has problems in a strict monad?
03:32:57 <Si\> x = do y <- x
03:33:04 <Si\> doesn't stop
03:33:21 <Si\> like x = x does
03:33:28 <skew> why do you need that?
03:33:35 <Si\> I dunno
03:33:41 <Si\> I was probably being silly
03:33:54 <Si\> It's been a learning process for me along the way
03:33:58 <skew> or do you think it would be required to build a graph?
03:34:15 <skew> x = let y = x in y is never very happy anyway
03:34:35 <Si\> well, I have to work in a monad, because HXT uses an IO State monad
03:34:48 <skew> for what?
03:34:54 <Si\> XML Parsing
03:35:01 <skew> you should try to do a lot of your work in pure functions anyway
03:35:33 <Si\> oh I do, I've got all the code to do Tieing the Knot and it worked, I just disabled it because I wasn't sure if it was practical
03:37:31 <skew> so what are you using now?
03:37:57 <skew> a two pass construction using IORefs?
03:41:35 <Si\> yes
03:42:06 <Si\> I won't change the SOAP Stage, that'll still simply shoove refs into a HashMap
03:42:43 <Si\> but, when we convert a SOAPMessage to a Call, I'll have the option (set by flag) to recurse the tree
03:42:58 <skew> like, you resolve references in the graph by making an empty IORef for now, and recording all the reference targets in a table, and then go back an fill in all those IORefs with the actual destination?
03:43:07 <Si\> see I was writing blindly, I didn't know whether the Haskell community would be happy with immutable data
03:43:15 <Si\> but you think they would?
03:43:18 <skew> are you kidding?
03:43:34 <skew> you should be more worried about getting lynched if you only provide an imperative interface
03:43:54 <skew> both could be nice I suppose
03:44:09 <Si\> I might as well have both, the code exists for one
03:44:29 <skew> I may be weird, but I think it's simpler and cleaner to just look up the references in the *final* dictionary while constructing each entry, rather than messing around with two passes
03:46:44 <Si\> what do you mean?
03:47:48 <Si\> I'd have the process XML -> SOAPEnvelope + Dictionary -> Lazy Call | Call with Refs -> Function
03:48:21 <skew> okay, you have these little pieces of data that want to refer to each other. To begin with they have string names and just refer to each other by name, but you would rather have them hold actual refrence to each other. Am I right so far?
03:49:00 <skew> I don't know what a SOAPEnvelope or Dictionary is up there
03:49:41 <Si\> SOAPEnvelope is a data-structure holding the parse SOAP Message, which is basically all the data needed to make the called in SOAP/1.1
03:49:57 <skew> like an XML tree or something?
03:49:58 <Si\> the Dictionary is HashMap associating strings with SOAPParameters
03:50:14 <Si\> ye
03:50:16 <Si\> s
03:50:18 <skew> and is that involved in any of this cyclic reference buisness?
03:50:52 <Si\> yes, we use that HashMap to works out which bits of tree should go where
03:51:08 <skew> okay, well I'm talking about that too.
03:51:27 <skew> I'll keep explaining what I was saying about building cylic structures
03:52:23 <skew> So, we want a table where you can put in a string name and get a direct reference (or the object itself, if you want to think of it like that)
03:52:27 <Si\> one problem I do have is that at each node of the tree we have to reference another HashMap as well
03:53:02 <skew> The problem is trying to fill that table. When you want to put in one piece, what should you do about it's references?
03:53:23 <skew> One solution is to indirect throught an IORef around a real reference or something, so we can leave them empty
03:53:33 <skew> then when the table is full you go back and put in the right values
03:53:46 <Si\> that's what I'm doing at the moment
03:53:59 <skew> It's cleaner to put in the right values from the beginning though, the question is just where to find them
03:54:37 <Si\> but can you see my problem, if I have to reference a HashMap at each and every node in the graph, how do I make it lazy?
03:54:50 <skew> Fortunately, they are all in table you end up with once you have finished adding each cell of the tree
03:54:55 <Si\> should I convert the HashMap to an associative list?
03:55:00 <skew> so, this being Haskell, just look them up in there
03:55:21 <skew> The implementation of the map is irrelevant, as far as I can tell
03:55:32 <Si\> but I'm in the IO Monad
03:55:46 <skew> huh?
03:55:57 <skew> acessing a HashMap isn't in the IO Monad, is it?
03:56:01 <Si\> yes
03:56:09 <skew> Oh
03:56:19 <skew> well, you might need to use a FiniteMap instead or something
03:56:28 <skew> mdo should probably suffice
03:56:35 <Si\> data HashTable key val
03:56:35 <Si\> new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
03:56:35 <Si\> insert :: HashTable key val -> key -> val -> IO ()
03:56:35 <Si\> delete :: HashTable key val -> key -> IO ()
03:56:35 <Si\> lookup :: HashTable key val -> key -> IO (Maybe val)
03:56:46 <Marvin--> why do you desperately have to use Hashtable? Is FiniteMap too slow?
03:57:16 <skew> do you understand my intuitions about the knot tying now?
03:57:21 <Si\> too complicated more like :)
03:57:22 <Marvin--> or is it just that you don't have an Ord instance?
03:58:14 <skew> just make each reference a thunk that will go out and look up the reference
03:58:34 <skew> demanding any of them will force the table to be build, with values having thunks in the references,
03:58:50 <Marvin--> Si\: the only reason that marshal/unmarshal are in IO is the HashTable?
03:59:00 <skew> and then you actually will have a build table around, and the thunks can start being resolved
03:59:18 <skew> using mdo to get a hold of the final table is plenty here
03:59:26 <Si\> no Marshal is in IO because I need to catch exceptions from Read
03:59:41 <Marvin--> right
04:00:27 <Marvin--> and if I'm understanding you right, there's no simple way to just get a nice Haskell value without icky IORefs out of this?
04:00:53 <Si\> no there should be a nice way
04:01:02 <Marvin--> bah, on second thought, I should stay far out of this discussion as I don't really know anything about SOAP
04:01:30 <Marvin--> I think I'm going to focus on nice things like lunch instead :)
04:01:41 <skew> If I understand what Si\ is saying and what I've been saying there is in fact a nice way, and Si\'s brain just hasn't been twisted enough by lazy evaluation to think it is obvious and elegant
04:03:03 <Si\> I wish I hadn't used HashMaps now
04:03:20 <skew> why? just because the IO stuff is ugly?
04:03:43 <Si\> no, because I'll have to change it to FiniteMaps to make this work
04:03:48 <skew> why?
04:03:54 <skew> I would try doing it with mdo first
04:04:00 <Si\> what's mdo?
04:04:23 <skew> well, actually I'd probably rip out the HashMaps because they were ugly, but that's unrelated
04:04:30 <skew> synatactic sugar for fixIO
04:04:57 <Si\> will that stop infinite recursion?
04:05:05 <skew> about like do, except all the bindings are done with a big fixIO
04:05:17 <skew> infinite recursion is a different issue
04:05:43 <skew> but if you want to do something like do x <- return (1:y); y <- return (2:x); print x
04:06:14 <skew> just say "mdo" instead of "do"
04:07:04 <Si\> oic
04:07:57 <Marvin--> nice and evil
04:08:10 <skew> and -fglasgow-exts. There is an -fmdo or something similar, but I think it's been folded into -fglasgow-exts
04:08:34 <Si\> what does that do then?
04:08:39 <Si\> or mdo rather :)
04:09:09 <skew> looks like it's gone now. Used to turn on mdo when it was still a new experimental extension
04:09:09 <Si\> is it as terrifying as unsafePerformIO?
04:09:52 <Si\> oic; fixIO :: (a -> IO a) -> IO a
04:10:21 <Si\> so I just wrap my io stuff with that and that'll stop the thing from going on forever?
04:10:36 <skew> that's a bit different
04:10:45 <skew> you can't express recursive bindings with fixIO
04:11:14 <skew> so if you have something going on forever you are probably having different
04:11:30 <skew> issues, but maybe you are trying to do something you should be using fixIO for instead...
04:12:54 <skew> as an example, fixIO (getChar . (:)) is equivalent to fmap replicate getChar, rather than sequence (replicate getChar)
04:13:28 <musasabi> mdo seems quite simple and nice
04:16:57 <Si\> so if I have the following switch to process the tree;
04:17:02 <Si\>            case (pt, c) of
04:17:02 <Si\>                 -- Simple and Complex
04:17:02 <Si\>                 (SSingle t, SC s)          -> ...
04:17:02 <Si\>                 (SSingle t, SCT s)         -> do
04:17:02 <Si\>                                               ...
04:17:03 <Si\>                 (SArray t sz _, c)         -> do
04:17:08 <Si\>                                               ...
04:17:08 <Si\>                 (t, SR i)                  -> do
04:17:10 <Si\>                                               ...
04:17:21 <Si\> and prefix each do with fixIO $, it'll stop it going on forever?
04:26:09 <skew> that's probably unrelated
04:26:09 <skew> what does do the blocks to?
04:26:10 <skew> fixIO won't help you recurse down an infinite tree, for example
04:26:10 <skew> wow, my CPU is running cold!
04:26:16 <Si\> the switch selects against the type of parameters being processed
04:26:33 <skew> lm_sensors reports -70C. I should get dry ice frost any second now
04:26:46 <Si\> SC is a simple value, so that is the base case effectively
04:26:53 <Si\> SCT is a compound value
04:26:58 <Si\> SArray is an Array
04:27:02 <skew> yeah, but what does an individual block do, and why does it run forever now?
04:27:05 <Si\> SR is a reference
04:27:39 <Si\> because if you get an SR and you're going for tying the knot, you've got to look up all the sub-trees
04:28:09 <Si\> the blocks create a CallValue, or a part of a CallValue
04:28:15 <skew> Oh, rigth
04:28:24 <skew> looking things up is in IO too.
04:28:41 <skew> hmm. I guess you would need unsafeInterleaveIO to sort things out
04:28:54 <skew> probably better to switch maps
04:28:57 <Si\> yup
04:29:14 <skew> although for a proof of concept encapsulating that in a lazy lookup function would be okay
04:29:37 <Si\> which means my whole structure will have to utterly change, which means I'll do it after I've handed in the project
04:29:41 <skew> I wasn't quite thinking about the lookup
04:30:09 <skew> you need to make sure you only try to touch the final table inside a thunk, but if lookup is in IO that doesn't work as well
04:30:36 <Si\> see I've got this thing called the TypeMap Database which is carried around in the State of the StateIO monad
04:30:39 <skew> unsafeInterleaveIO delays an action until the result is demanded, though, so it would do waht you want
04:30:58 <Si\> this maps types from one type-space to another, and is currently implemented as a HashTable
04:31:19 <Si\> well it's actually a list of HashTables of HashTables
04:32:15 <Si\> fortunately it's also and ADT :)
04:32:15 <skew> I think if you use an mdo to get a handle on the final map, and make a new lookup that wraps unsafeInterleaveIO around the old it just might work (and will certainly be rather ugly)
04:32:56 <Si\> nah, I'll stick with IORef method for my project, and put this in the "improvements" section of my report
04:33:00 <skew> how much code do you have?
04:33:14 <Si\> quite a lot
04:33:21 <skew> well, in the little computation here
04:33:52 <skew> that you are thinking of moving to a FiniteMap
04:34:10 <Si\> but my problem is that the TypeMap Database and indeed the environment in which it is encapsulated is intrinsic to the whole project
04:34:20 <Si\> so changing would involve changing most of my code
04:34:45 <Si\> I'm thinking of ditching ever using a HashTable again
04:34:49 <skew> you said it was an ADT
04:35:17 <skew> unsafeInterleavIO . return is always safe
04:35:18 <Si\> it is
04:35:26 <Si\> hmmm
04:35:42 <skew> can't you just change it to finite map, and provide the old interface with gratuitous use of return?
04:36:02 <Si\> but all the functions are currently in the StateIO Monad, I'd need to which to the State Monad instead
04:36:10 <skew> why?
04:36:19 <Si\> no I wouldn't
04:36:23 <Si\> I'm being stupid
04:36:25 <Si\> :)
04:36:28 <skew> actually, isn't your monad choice a type synonym somewhere anyway?
04:36:43 <Si\> StateIO = State on top of IO
04:36:49 <Si\> means you can have a State and do IO
04:36:56 <skew> or class constrained polymorphism in your functions, or something like that
04:37:35 <Si\> it makes dealing with HAIFA Environment so much more elegant
04:39:21 <skew> why is this big old reference table being carried around in the state?
04:39:53 <skew> it doesn't seem like something that matters past the first stages of parsing
04:40:36 <Si\> we're not in the first stages of parsing
04:41:07 <Si\> the first stage of parsing produces a SOAPEnvelope datastructure and a HashTable reference dictionary
04:41:31 <Si\> we're now converting this from a SOAP Message to HAIFA's Common Call Structure
04:41:54 <skew> that dictionary is the only thing involved in the lazy reference stuff I was talking about
04:42:21 <Si\> the dictionary is nothing to do with the TypeMapDatabase
04:42:39 <Si\> the TypeMapDatabase converts SOAP Type Names to Haskell Type Names
04:43:17 <Si\> which is needed before we can produce a Call, it has to be SOAP which deals with how type names are mapped
04:43:38 <skew> I assumed that the Hashtable involved in the lazy reference computation had something to do with the state that goes in the monad when you started talking about that state, but I can't see how it is related
04:43:48 <skew> or is this about the nontermination stuff?
04:43:50 <Si\> no it doesn't go in the state
04:44:09 <Si\> that's be pointless
04:44:13 <skew> okay, so switching from that HashTable won't have a ripple effect on the monad
04:44:25 <Si\> not for the reference dictionary
04:44:31 <Si\> but it will for the TMDB
04:44:45 <skew> is there any reason to change that one?
04:44:52 <Si\> and the TMDB will need changing too since it is queried at each node as well
04:45:06 <Si\> each node may have a type and this data needs relaying.
04:45:24 <skew> that thing gets updated with new types incrementally as you process nodes?
04:45:48 <Si\> just so
04:45:57 <Si\> well theoretically
04:46:09 <Si\> in SOAP it doesn't need to be
04:46:27 <skew> do you actually need to query it at each node too?
04:46:30 <Si\> type data should come from WSDL, so it'll be there already
04:46:41 <skew> and does each node need to know about all the types defined at any other node?
04:47:15 <skew> at worst you need one pass to do all the node construction stuff unrelated to the references, and then one to fix them up
04:47:15 <Si\> nup
04:47:35 <Si\> assume the TMDB is read-only at this point
04:47:43 <skew> if you don't even need that it doesn't affect the computation at all
04:48:02 <skew> just so long as you get ahold of the final reference table with mdo
04:48:52 <skew> do you completely understand the laziness I'm talking about, and fixIO?
04:49:14 <skew> I've been working from the assumption that you don't
04:49:30 <Si\> no I don't, my mind takes a while :)
04:49:35 <skew> or at least, that I need to try to explain what I'm talking about more
04:49:59 <skew> okay.
04:50:09 <Si\> but I don't particularly want to use fixIO if it's unsafe
04:50:17 <skew> it's not remotely unsafe
04:50:22 <Si\> right
04:51:18 <skew> the two critical things in lazy knot tying are getting a reference to the final table while you are building the entries to put in the table, and making sure that looking up an entry in that final table is done lazily, so the implementation can defer that until the final table is actually populated
04:52:27 <skew> even if you need work in IO at the nodes, you can still get ahold of the final table using mdo (or raw fixIO)
04:53:02 <Si\> so right, I've got a HashTable or some data structure with a bunch of SOAP Parameter sub-trees in
04:53:16 <skew> the second is free if you use a pure table like FiniteMap, but even with a table in IO you can get the second by using unsafeInterleaveIO do delay performing the action
04:53:42 <skew> I haven't thought to hard about how unsafe unsafeInterleaveIO really is
04:53:56 <Si\> and my actual SOAP Message which references that
04:54:23 <skew> but I haven't thought of an example where it breaks referential transparency yet
04:54:32 <Si\> so the first thing I'm doing is converting this table of SOAP References into CallValues, is this right?
04:54:47 <skew> what are CallValues?
04:55:00 <Si\> A Value withing a HAIFA Call
04:55:18 <skew> try this: could you implement your algorithm in C?
04:55:18 <Si\> Call is made up of (name, callvalues)
04:55:36 <Si\> I couldn't implement anything in C
04:55:47 <skew> well, some imperative language. Python maybe
04:58:25 <Si\> I think I'll leave it for now, and concentrate on making my Skeleton Generator work
04:58:48 <Si\> I think I'll switch to a FiniteMap though; it'll make things much easier
04:58:57 <skew> anyway, if you could do it in an imperative language it's not the sort of thing I'm thinking of
05:00:09 <Si\> I don't think it would be possible, thanks your help, I'll have a play with mdo
05:02:36 <skew> have fun. I hope you release soon
05:08:11 <skew> section 7.3.3 in the users guide talks about mdo and points to papers
05:58:51 <Si\> Hmmm, another thing; I think my Marshaller will need to be non-monadic too, because it marshals values recursively
06:05:56 <Marvin--> er... what's the problem with recursive monadic functions?
06:06:59 <Si\> if they're infinite they never stop
06:11:11 <Marvin--> and you're likely to build infinite values?
06:11:22 <Marvin--> how would that be marshalled? :)
06:13:13 <Marvin--> can you give me a practical example of where it would be a problem? I'm having a hard time understanding this
06:18:59 <Si\> two people can be friends of each other can't they?
06:19:14 <Si\> and so both would have a pointer to each other
06:19:25 <Si\> if you're not using IORefs, you have to use laziness
06:20:01 <Marvin--> right
06:20:21 <Si\> if you try and manipulate an infinite value in the IO Monad it goes bang
06:20:54 <Si\> unfortunately this means I loose a lot of features like exception handling, but oh well
06:20:59 <Marvin--> yes and no, it depends on *what* you do with it?
06:21:11 <Si\> yes
06:21:27 <Si\> consider this;
06:21:35 <Marvin--> if you want to "do x for every node in the expression tree" then sure, it won't terminate
06:22:00 <Marvin--> but on the other hand, even if you use laziness, you will have to evaluate the expression sooner or later when you're marshalling, won't you?
06:22:23 <Marvin--> or am I completely missing the point?
06:23:01 <Si\> consider this; if I have a simple data structure Person = P{friend::Person}
06:23:30 <Si\> and I get two people records who point to each other, and go for lazy expansion
06:24:17 <Marvin--> this is the unmarshalling we're talking about?
06:24:19 <Si\> so long as all the functions I use are lazy, none of the nodes in the tree will be evaluated until they are called
06:24:36 <Si\> that's one stage
06:25:56 <Si\> Consider, if I've got an infinite tree and I pass it through unmarshal, if unmarshal lazily transforms the tree to Persons, it doesn't matter
06:26:22 <Marvin--> right
06:26:39 <Si\> but it puts a whole bag of restrictions in there as well
06:26:58 <Si\> for example, is read lazy?
06:27:03 <Marvin--> okay, so you want to take the finite tree that comes from the communication layer and turn it into a lazy infinite tree
06:27:29 <Marvin--> or rather, lazy graph
06:27:45 <Si\> just so
06:28:00 <Marvin--> the read function as in the Read class? Yes, it's lazy
06:28:19 <Si\> good, not that it matters really
06:29:36 <Si\> In reality I need two Marshallers, a strict IO one and a lazy one
06:30:03 * Si\ will BBL
07:30:16 <shapr> good morning #haskell!
07:30:22 <Marvin--> "morning"
07:30:35 <shapr> did I miss anything?
07:30:43 <shapr> @fortune
07:30:44 <lambdabot> One family builds a wall, two families enjoy it.
07:30:56 <Marvin--> wow, that was a lame fortune cookie
07:31:16 <shapr> well, ask for another
07:31:25 <ozone> Marvin--: i got one once which said "a secret lover will reveal himself soon" :(
07:31:38 <Marvin--> hahaha
07:31:41 <ozone> (in a real fortune cookie)
07:32:58 <urfie> `himself' :)
07:33:03 <shapr> g'day ozone 
07:33:57 <shapr> Jerub: I've switched to right hand dvorak
07:37:08 <ozone> g'day shapr
08:05:57 * Marvin-- screams in frustration
08:06:48 <shapr> ?
08:07:31 <shapr> anyone what the home keys are for right hand dvorak?
08:07:55 <shapr> I'm not sure if it's aeht or ehtd 
08:08:15 <Marvin--> oh, I just noticed that if I run eprover with -tKBO instead of -tAuto, all my "slow" examples go really really fast, and my fast examples don't go any slower
08:08:16 <Marvin--> neat
08:08:26 <Marvin--> wish I'd thought of it earlier though :)
08:08:57 <shapr> how can I tell which variants are available for a given xkb map?
08:13:09 <Marvin--> oh wait, -tKBO seems to be best for the proof tool, not really for the bug finding though
08:15:59 <Marvin--> I wish I knew what KBO means
08:17:47 <Marvin--> I think it's time for easter break from this
08:25:34 <shapr> is there a typing tutor program that's kb layout agnostic?
08:44:25 <Si\> why can't I declare instances instance (Marshal a, CIndex b) => Marshal (Array b (Value a)) where
08:44:26 <Si\> instance (Marshal a, CIndex b) => Marshal (Array b a) where  
08:44:44 <Si\> when there is no instance of Marshal (Value a)
08:45:05 <Si\> and so Marshal a => a and Marshal a => Value a are mutually exclusive?
08:46:42 <Marvin--> because it doesn't look at the context when determining which instances overlap, IIRC
08:47:00 <Si\> darn
08:47:21 <Igloo> Someone could make an instance Marshal (Value a) in a later module
08:47:21 <Marvin--> so use -fallow-overlapping-instances if you're sure there's no problematic overlaps
08:47:29 <Marvin--> yes, exactly
08:49:52 <Si\> how about I -fallow-overlapping-instances and then instantiate Marshal (Value a) myself but make all its functions throw exceptions
08:49:55 <Si\> would that work?
08:50:50 <Marvin--> doesn't it always pick the most specific instance first though?
08:50:57 <Marvin--> if there is an overlap, I mean
08:55:58 <Si\> well that works anyway, thanks
09:08:31 <Si\> do functions within the type class declaration get called before or after looking at instances?
09:09:57 <Igloo> huh?
09:10:16 <Marvin--> WDYM?
09:10:53 <Si\> class (Typeable a, Show a) => Marshal a where
09:10:54 <Si\>     marshalIO    :: (Value a) -> ParameterName -> IO CallValue
09:10:54 <Si\>     marshal      :: a -> ParameterName -> CallValue
09:10:54 <Si\>     unmarshalIO  :: CallValue ->  IO (Value a)
09:10:54 <Si\>     unmarshal    :: CallValue -> a
09:10:56 <Si\>     marshalIO = marshalLazyError
09:10:58 <Si\>     unmarshalIO = marshalLazyError
09:11:18 <Si\> when does it look at the bottom two funtions, before or after it looks for them in instantiations?
09:12:53 <Igloo> Think of the bottom two functions as being copied into the instances which don't define alternatives
09:13:18 <Si\> good, that's what I hoped
09:13:45 <Si\> ty
10:20:24 <stepcut> i wonder how hard it would be to add KDE/Qt bindings to the fudgets library
10:21:54 <andersca> ugh kde
10:22:04 <stepcut> !
10:24:32 <bring> don't listen to andersca, he's a gnome guy
10:24:35 <andersca> ;)
10:28:22 * stepcut is an emacs guy
10:29:27 <andersca> emacs is gnu
10:29:28 <andersca> gnome is gnu
10:29:39 <andersca> hence, you should add gnome/gtk bindings
10:30:34 <stepcut> except we are a KDE shop
10:31:49 <bring> stepcut: what shop's that?
10:32:29 <stepcut> lindows...
10:33:15 <shapr> xemacs!
10:33:54 <bring> ah, I thought I had seen @lindows.com in some email from you
10:34:04 * stepcut is still waiting for pikamacs
10:35:30 <shapr> pikamacs, keyboard combo attack!
10:37:11 <stepcut> shapr: did you look at that stream processor stuff yet?
10:37:56 <shapr> no, still not
10:38:12 <shapr> but vacation starts tomorrow!
10:38:41 <stepcut> no problem
10:39:05 <stepcut> i am reading the fudgets PhD thesis now because I think it may contain the solution to my problems
10:39:32 <stepcut> i think I need to make unix fudgets
10:41:51 <shapr> I haven't raed that thesis yet, I'll check it out
10:42:41 <shapr> since I can't type with my left hand I expect to do more reading in the near future
10:42:52 <stepcut> its pretty easy reading so far
10:44:03 <Igloo> What happened to your hand?
10:44:26 <shapr> I dunno, too much typing I guess
10:44:32 <Igloo> Oh  :-(
10:45:11 <shapr> anyways, I think it'll get better if I give it a vacation
10:45:23 <stepcut> shapr: the correct response is 'too many fingertip push-ups I guess'
10:45:47 <shapr> so now I'm using dvorak left hand, which is cool
10:45:52 <shapr> stepcut: ha!
10:52:02 <Cale> shouldn't you be using dvorak right hand, given that it's the left one that's hurt?
10:52:15 <shapr> I am
10:52:19 <shapr> oh
10:52:22 <shapr> oops
10:55:03 <bring> hey, cool, I didn't know you could declare the fixity of backquoted functions
10:56:08 <andersca> oh?
10:56:11 * andersca knew that :)
12:26:25 * Cale is back (gone 44:22:44)
12:26:41 * Cale is away: back in a sec
13:05:32 <SyntaxNinja> Igloo: alive?
13:05:55 <Igloo> Yes
13:06:00 <SyntaxNinja> igloo: do you have  any opinion on this:
13:06:00 <SyntaxNinja> > runQ (reifyDecl id) >>= print
13:06:00 <SyntaxNinja> ghc-6.2: panic! (the `impossible' happened, GHC version 6.2):
13:06:00 <SyntaxNinja> 	dsReify reifyDecl GHCziBase.id {- v r8k -}
13:06:00 <SyntaxNinja> Please report it as a compiler bug to glasgow-haskell-bugs@haskell.org,
13:06:02 <SyntaxNinja> or http://sourceforge.net/projects/ghc/.
13:06:34 <SyntaxNinja> does this happen because you are a bad boy?
13:08:47 * Cale is back (gone 00:42:15)
13:09:11 <wagle> where did runQ come from?
13:09:27 <Igloo> runQ (reify (mkName "id")) >>= print   tells me there is no Show Info instance in the HEAD
13:10:07 <wagle> i want to watch the fireworks too..  where do i find runQ?
13:10:14 <shapr> wagle: it's template haskell
13:10:19 <Igloo> Language.Haskell.TH in the HEAD
13:10:57 <wagle> shapr: i'm running ghci -fth
13:11:41 <shapr> :m + Language.Haskell.TH
13:11:45 <shapr> then try that
13:12:39 <wagle> hmm..  i seem to still be running 6.2
13:12:56 <wagle> is this a 6.2.1 ism?
13:13:06 <Igloo> what?
13:13:12 <Igloo> runQ or the module?
13:13:12 * wagle wanders off to figure out why it didnt install right
13:13:25 <wagle> Igloo: yes
13:13:33 <Igloo> Which?
13:13:45 <wagle> inclusive or
13:13:56 <Igloo> Try :m + Language.Haskell.THSyntax then
13:14:10 <wagle> Igloo: lemme install 6.2.1 before you try to figure out my problem
13:14:24 <SyntaxNinja> Igloo: it's your package ;)
13:15:09 <Igloo> Syn: HDYM?
13:15:11 <wagle> :m + Language.Haskell.THSyntax got the panic for runQ (reifyDecl id) >>= print on my powerbook
13:15:39 <SyntaxNinja> HDYM? 
13:15:48 <Igloo> How Do You Mean
13:15:55 <SyntaxNinja> does it crash for you on the HEAD?
13:16:12 <Igloo> reifyDecl doesn't exist in the HEAD  :-)
13:16:32 <SyntaxNinja> I guess I'll report it against 6.2, then, even if its already fixed.
13:16:33 <SyntaxNinja> thanks.
13:17:23 <wagle> apparently 6.2.1 also broke some stuff (according to recent traffic on the ml)
13:17:31 <Igloo> OK - I expect you'll just be told it's fixed in the HEAD (assuming it is - I'll prod further in a sec) and there won't be another 6.2 release though
13:17:49 <Igloo> What did 6.2.1 break?
13:18:14 <wagle> apparently the "confidence builder" example on the website no longer works
13:20:46 <shapr> I think SyntaxNinja just updated it
13:22:30 <wagle> how fregean
13:23:05 <Igloo> Yup, looks OK AFAICT. You need to be in the typechecker monad to do reification though (i.e. in a splice rather than just runQ)
13:24:06 <wagle> i guess i should get in the habit of dereferencing irc pseudonyms
13:27:22 <shapr> wagle: who are you?
13:27:53 <wagle> ?
13:28:02 <shapr> ogi.edu is a big name in Haskell world
13:28:49 <shapr> just dereferencing :-)
13:29:08 <shapr> I'm Shae Erisson
13:30:04 <wagle> Perry Wagle
13:30:24 <shapr> nice ta meetcha
13:30:30 <SyntaxNinja> wagle: I updated it on the wiki, but not in the documentation
13:31:38 <wagle> shapr: and you
13:33:49 <shapr> europython is nearly working, I'll be haskelling again soon
13:34:05 * shapr boings
13:35:07 <wagle> shapr: you are using ipv6 to connect to irc?
13:35:27 <shapr> yup
13:36:07 <shapr> freenet6 deb & irc.ipv6.eu.freenode.net
13:36:51 <shapr> I long for ipv6
13:37:19 <shapr> would make many things easier
13:37:38 <wagle> like?
13:37:46 <shapr> irc
13:38:00 <wagle> how so?
13:38:33 <shapr> multicast would be great for irc, downloading, online games, etc
13:39:01 <shapr> bittorrent is just fake multicst for example
13:39:57 <wagle> ipv4 sortof has multicast
13:40:14 <shapr> but no one supports it
13:40:18 <wagle> but (there at least) multicast has problems..
13:40:36 <wagle> cisco supports it
13:41:07 <wagle> and has for 8 years or so
13:41:58 <wagle> i was using multicast back in indiana, but multicast here has been 6 months away for the past 7 years
13:42:30 <wagle> i guess i'm wondering to what extent ipv6 solves the problems
13:43:03 <shapr> to a great extent, imho
13:43:27 <wagle> why cant you backport that to ipv4?
13:43:41 <shapr> I think the linked list of headers is a major difference
13:45:19 <shapr> one reason the ipv4 flags fell out of usefulness, low end tcp routers ignore them
13:46:11 <wagle> low end routers are going to be compute bound chasing linked lists, i imagine
13:47:11 <wagle> aww darn..  i'm not going to have time for awhile to catch up on the state-of-the-art in ipv6
13:48:37 <wagle> no network guys around here have had any interest in ipv6, so i didnt bother
13:56:42 <wagle> shapr: you using the 6bone, something like that, or really using ivp6 all the way to the irc server?
13:58:37 <det> wagle: ipv6 tunnel broker
13:58:39 <skew> a tunnel
13:58:48 <det> wagle: they give you a ipv6 address over ipv4
13:58:55 <skew> the 3ffe: tells you that
13:59:09 * wagle is off to reading group
13:59:14 <wagle> thanx for info
13:59:18 <det> wagle: check out freenet6 or ipv6tb.he.net
13:59:32 <det> wagle: if you use debian, ipv6 is as easy as apt-get install freenet6
14:11:36 <shapr> @yow
14:11:37 <lambdabot> I feel better about world problems now!
14:19:47 <shapr> yow!
14:22:40 <andersca> boom
14:27:57 <SyntaxNinja> @yow
14:27:57 <lambdabot> Mary Tyler Moore's SEVENTH HUSBAND is wearing my DACRON TANK TOP
14:27:57 <lambdabot>  in a cheap hotel in HONOLULU!
14:28:04 <SyntaxNinja> whoa
16:39:20 <cm> Joachim - is this Joachim Durchholz (sp?)?
16:39:35 <Joachim> Nope
16:39:53 <cm> ah :)
16:39:59 <Joachim> This is Joachim Falk. Someone only recently got interested in haskell
16:42:53 <cm> cool :)
16:46:54 <wagle> anyone know of way to simulate subtypes in haskell?
16:47:23 <cm> anyone know how shapr got the latex processor for moinmoin to work..
18:08:35 <skew> cm: you can simulate subtypes with phantom types, or with typeclasses
18:53:56 <arete> hello , is it possible to compile a 'static' executable on win32? i.e. with all the dependent C libraries compiled in
23:00:41 <shrimpx> does anyone know a good tree drawing package for tex? i'm using ecltree, but it leaves a lot to be desired
23:02:16 <clausen> why not use xfig?
23:02:32 <clausen> (it plugs into latex quite nicely, once you get the scripts going)
23:02:42 <shrimpx> hm, true
23:03:28 <shrimpx> i'm drawing lots of little lambda trees now, a simple tree package seemed like a good idea...
23:04:29 <clausen> you might like dot
23:04:48 <shrimpx> ah good idea
23:05:09 <reltuk> ok...so if I were to write a MUD client in Haskell, and the macros/aliases/triggers had to be written out to files, they would be read in when the program started...but since they would be IO tainted, they would be used in Monads....but since almost the entire program involves manipulating these things (as well as IO to and from the mud) I'm thinking I don't gain much by using a pure functional language
23:05:13 <reltuk> opinions/comments?
23:09:21 <vegai> curiosity: will that be a generic MUD client?
23:09:58 <reltuk> vegai: hopefully
23:10:08 <vegai> so telnet basically
23:10:35 <SamB> reltuk: you could cheat
23:11:16 <reltuk> vegai: basically
23:11:21 <reltuk> SamB: how do you chaet?
23:11:57 <SamB> vegai: mud clients are still a bit specialized...
23:12:23 <vegai> yes, I guess they can be
23:12:39 <reltuk> it's obviously more featureful than telnet...
23:12:39 <Smerdyakov> vegai, it appears you have never used a MUD client. The popular ones are very sophisticated and specialized.
23:13:00 <reltuk> eventually it will have a pluggable scripting interface, a mapper, etc.
23:13:10 <vegai> I've played months and months using Tinyfugue
23:13:27 <vegai> which is basically a telnet client ;)
23:13:46 <SamB> presumably a mud client could be used to connect to telnetd, however the usefullness of this is likely rather low...
23:14:36 <reltuk> SamB: probably as useful as using telnet to connect to telnetd :-p
23:15:09 <vegai> well, I don't know. You could do some nifty shell tasks with tf 
23:16:12 <reltuk> triggers seem mostly unapplicable, and most shells have support for aliases (support more in tune with shell tasks at that)
23:16:47 <vegai> most muds have support for aliases too
23:17:01 <vegai> but anyway, this is mootness
23:17:07 <reltuk> yep
23:17:29 <vegai> (and mootness is a word, I'm suprised to learn)
23:17:37 <vegai> sur*
23:18:36 <SamB> reltuk: overkill is the term for it, I think
23:18:55 <SamB> unless you like word wrapping in your terminal emulator, of course ;-)
23:19:00 <reltuk> SamB: indeed :-p
23:19:14 <SamB> oh yeah... curses would probably break
23:19:41 <reltuk> yeah, probably
23:19:48 <reltuk> but anyway...to the question...is there any point?
23:20:32 <SamB> in using haskell?
23:20:38 <reltuk> yeah
23:20:53 <SamB> err, bragging rights
23:20:59 <reltuk> lol
23:21:31 <vegai> reltuk: material for PhD
23:21:47 <reltuk> vegai: a MUD client in Haskell would be PhD material?
23:22:04 <vegai> the lack of comments here seems to imply that
23:22:05 * reltuk needs to publish in a journal in the next year in an attempt to get into grad school  :-p
23:22:09 <vegai> or then everyone's just on vacation
23:22:28 <Smerdyakov> reltuk, eh, it doesn't matter if you are really good. :P
23:23:27 <vegai> reltuk: ok, material for a paper then
23:23:29 <reltuk> Smerdyakov: the point being, of course, that I'm not really good
23:23:36 <Smerdyakov> reltuk, then why do you want to go to grad school? :P
23:23:41 <reltuk> vegai: yes, that's much more reasonable
23:23:53 <SamB> I think the lack of comments implies that most people who know about PhDs are asleep...
23:24:03 <reltuk> Smerdyakov: that was an over-simplification...I *am* really good, just not on paper
23:24:22 <reltuk> I would have to agree with SamB on that one...at least the ones in the US, east of the rockies
23:24:23 <Smerdyakov> I'm not asleep! :D
23:24:33 <shrimpx> heh
23:24:46 <Smerdyakov> And no, no one would care about a MUD client written in Haskell.
23:24:52 <Smerdyakov> It wouldn't be published anywhere, ever. Sorry. :P
23:25:03 <reltuk> Smerdyakov: I didn't think so...bloody vegai getting my hopes up
23:25:06 <SamB> Smerdyakov: oh, did you finally manage to get unbanned?
23:25:23 <Smerdyakov> reltuk, how much time left until you graduate?
23:25:28 <SamB> Smerdyakov: you do not think it would get into Debian?
23:25:35 * vegai wipes the blood of his shirt.
23:25:36 <Smerdyakov> SamB, this is not a question that should require asking me. :P
23:25:50 <reltuk> Smerdyakov: two years...
23:25:55 <vegai> damn. of/off
23:25:58 <SamB> Smerdyakov: just checking my memory, thats all!
23:26:24 <Smerdyakov> reltuk, OK. Do you have a research advisor?
23:26:38 <reltuk> Smerdyakov: I figure I have to publish by the summer after my junior year, which means I need to solicit to journals by second semester junior year...which means I have a little less than a year, which probably isn't enough time
23:27:04 <Smerdyakov> reltuk, (almost) no one publishes anything he does all by himself.
23:27:24 <Smerdyakov> reltuk, you should be asking professors if they will take you on as a research assistant.
23:27:26 <shrimpx> reltuk: find a prof. that will let you work with him on a research project
23:27:33 <reltuk> Smerdyakov: yeah, I know...I'm in the works of approaching research faculty to join their teams
23:27:36 <Smerdyakov> Oh, and the "no one" above means "no undergrad."
23:28:14 <reltuk> Smerdyakov: even post undergrad, you don't see a lot of single-name papers...
23:28:23 <reltuk> most undergrads just don't publish...at least the undergrads I know
23:28:26 <Smerdyakov> reltuk, a good number
23:29:16 <shrimpx> reltuk: you can be coauthor as an undergrad.. if you do enough good work and your prof is willing to give you props
23:29:25 <Jerub> I've done things that have been considered for publication, but a combination of a) I was an inexperienced undergrad and b) with practically no time, they never were.
23:30:05 <reltuk> shrimpx: I'm sure if I was partly responsible for the findings and the paper, the professors I have in mind would have no problem listing me as a co-author
23:30:20 <shrimpx> cool
23:31:09 <shrimpx> i had the priviledge to be listed as coauthor on a paper that my prof submitted to ICFP last week
23:31:23 <Smerdyakov> reltuk, one thing you should know: functional programming is a dead research area in the USA.
23:31:30 <shrimpx> Smerdyakov: haha
23:31:32 <Smerdyakov> reltuk, there are under 10 professors TOTAL doing it in the country.
23:32:03 <reltuk> Smerdyakov: oh really? /me looks over professor list
23:32:08 <Jerub> really?
23:32:13 <shrimpx> well functional research hides under lots of other areas
23:32:18 <Jerub> I reckon there's 10 professors at my university who are doing fp stuff.
23:32:48 <Smerdyakov> shrimpx, like?
23:33:41 <reltuk> there is some language stuff at my school...
23:34:15 <Smerdyakov> reltuk, careful: I said "functional programming research."
23:34:17 <reltuk> nothing directly functional, but I could get in on a project working on something likemaude.cs.uiuc.edu
23:34:36 <Smerdyakov> reltuk, which means the goal of the research is to advance the state-of-the-art of tools and practices for functional programming.
23:35:04 <reltuk> http://maude.cs.uiuc.edu rather
23:35:38 <Smerdyakov> Yeah, that looks pretty cool.
23:35:47 <Smerdyakov> Certainly "declarative programming" if not "functional programming."
23:36:23 <Smerdyakov> Notice: Even for that, only one American professor on the project.
23:36:33 <reltuk> and Kamin at least used to work on functional programming...at least according to this paper list
23:36:41 <reltuk> Smerdyakov: yeah, I saw that...
23:37:11 <Smerdyakov> Functional programming was popular in the USA from 80's to mid 90's or so.
23:37:17 <Smerdyakov> Recent research is a more useful guide.
23:37:56 <reltuk> he currently has a paper that is "To appear, J. Functional Programming"
23:38:11 <shrimpx> Smerdyakov: it seems that functional languages are becoming increasingly popular with respect to security. (Especially in light of current events.) For example, these guys http://galconn.com/ have been experiencing explosive growth.
23:38:33 <shrimpx> but i don't have any concrete data... 
23:38:38 <Smerdyakov> shrimpx, C is popular with respect to operating systems research. Yet these people don't say they are doing "C research."
23:38:55 <reltuk> lol
23:39:00 <shrimpx> heh
23:39:53 <Smerdyakov> And Galois Connection isn't a research lab, as far as I know. I think they make products to order.
23:40:12 <reltuk> this webpage might be outdated
23:41:53 <Smerdyakov> I'm pretty sure that G.C. is clearly a commercial enterprise.
23:42:20 <Smerdyakov> The professors involved with it have their university positions to do research.
