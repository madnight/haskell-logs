03:09:10 <bring> Igloo: it seems like in ghc 6.2 and 6.2.1 TH is on by default, even without -fglasgow-exts
03:10:29 <Igloo> Do you have anything in the dotfile or env variable?
03:10:57 <bring> nope
03:11:13 <Igloo> Can you give me a small example that makes you think that's the case?
03:11:41 <bring> starting ghci, and typing "$id"
03:11:52 <bring> gives me a TH error
03:11:55 <Igloo> That's not valid Haskell
03:12:02 <Igloo> What TH error?
03:12:20 <Philippa> isn't $expr splice in TH?
03:12:26 <skew> yep.
03:12:34 <bring> i know, but since it is a th error, it must have been interpreted as a splice
03:12:41 <bring> Couldn't match `Language.Haskell.THSyntax.ExpQ' against `a -> a'
03:12:56 <Philippa> try $ id instead of $id
03:13:04 <skew> that's sort of wierd if -fglasgow-exts is off.
03:13:10 <Igloo> Doesn't happen here
03:13:17 <bring> hmm, strange
03:13:23 <skew> nor here
03:13:25 <Igloo> Does it happen with ghci -ignore-dot-ghci ?
03:13:42 <skew> the last GHC install I had let me use overlapping instances and tuff
03:14:11 <bring> yes, but with -fno-th it doesn't happen
03:14:36 <bring> here's valid haskell that fails: "f xs=[e|e<-xs]"
03:15:02 <bring> maybe I compiled ghc with some weird flags
03:15:21 <Igloo> Well, with let on the front if you want it to work in ghci
03:16:24 <bring> sorry, should give the whole context
03:16:53 <bring> "module Test where f xs=[e|e<-xs]" in Test.hs, run ghci Test.hs
03:17:56 <Igloo> Still works fine here with 6.3 and 6.2
03:18:19 <bring> hmm, I'll try recompiling a fresh ghc
03:23:00 <shapr> yow!
03:23:20 <shapr> good morning #haskell !
03:23:40 <kosmikus> bring: you also get this error if you don't load any modules nor packages nor whatever?
03:24:17 <bring> you just typing in the expression into ghci without loading anything else?
03:24:29 <bring> s/you just/you mean just/
03:24:37 <kosmikus> yes
03:24:56 <kosmikus> just start up "ghci" and type "$id" at the prompt
03:25:06 <bring> same thing
03:25:25 <bring> Prelude> let f xs = [e|e<-xs]
03:25:25 <bring> <interactive>:1: parse error on input `<-'
03:26:07 <kosmikus> very strange
03:26:17 <bring> tried ghc 6.2 and ghc 6.2.20040309, on two different machines
03:26:31 <bring> but I compiled both of them myself, maybe I did something strange
03:27:02 <bring> is there a configure option or something that turns on extensions (or just TH) by default?
03:27:27 <kosmikus> do you have an alias for "ghci" to "ghci -fglasgow-exts" or something?
03:27:51 <bring> no
03:29:11 <bring> ah, could it be that I have auto packages that have -fglasgow-exts in extra_ghc_opts?
03:29:17 <kosmikus> do you have an "auto" package in your package.conf that has extra_ghc_opts?
03:29:23 <bring> :)
03:29:24 <kosmikus> ;)
03:29:30 <bring> yes, I do
03:29:37 <bring> of course, that must be it
03:29:58 <bring> hmm, that's not good
03:30:18 <bring> guess I should make it a non-auto package
03:30:30 <kosmikus> or remove the extra_ghc_opts
03:34:56 <bring> but then the user has to add those flags whenever they use that package
03:35:33 <bring> what is the right thing to do here?
03:39:52 <shapr> I'd say don't use TH syntax.
03:40:13 <bring> :)
03:40:14 <shapr> even though you have -fno-th, and you don't always use -fglasgow-exts
03:40:26 <shapr> your code may be used in a situations where those are turned on
03:40:37 <bring> true
03:41:16 <bring> but as dr_fripp showed, legacy code may use what is now TH syntax
03:41:18 <shapr> I think Hal DaumÃ© had to change several thousand lines of code where he was using $(\x -> ...) as $ (\x -> ...)
03:41:25 <shapr> yes, I agree
03:41:42 <skew> It seems like that should be fairly easy.
03:42:12 <bring> another problem is that if glasgow-exts are always on in my ghc, I may use extensions without realizing it
03:42:57 <shapr> and that leads to the occasional discussion "Does Haskell == GHC?"
03:42:57 <skew> I did something similar, realizing I was using extensions, but not remembering to add the appropriate flags in my makefile
03:43:33 <bring> skew: yeah, that's the sort of situation I'm thinking of
03:44:34 <skew> shapr: I think it's getting to be time for a new standard, which would settle some of that
03:44:42 <shapr> yes, I agree.
03:45:05 <shapr> it's been often suggested that "Haskell 98 Plus" be Haskell 98 plus X commonly supported extensions.
03:45:20 <earthy> H98++ >:)
03:45:25 <skew> some of the extensions are a bit rough around the edges
03:45:28 <bring> haskelldb is an auto package and it uses extra_ghc_opts, so anyone who has haskelldb installed has extensions turned on automatically
03:45:52 <earthy> which will beget Brazil, which will beget H98#. :)
03:46:04 <bring> *shudder*
03:46:15 <earthy> `let's not.' yeah. :)
03:46:25 <shapr> I wonder if it would be useful to make a CGI where you upload a bunch of Haskell sources, and the cgi checks to see what extensions could be present.
03:46:36 <skew> like the overlapping typeclass stuff in GHC, handled by bounded search. So inelegant!
03:47:51 <earthy> shapr: componentize it! make a tool that spits out a raw list of necessary extensions and also distribute that
03:47:58 <earthy> (and yes, methinks that would be useful)
03:48:09 <skew> earthy: but then you can't charge for the service.
03:48:29 <earthy> skew: ah, but you can't anyway... not if you want people to use it
03:48:47 <earthy> (they'll just run it through hugs and ghc and nhc and...)
03:49:39 <bring> google should add a haskell interpreter
03:50:00 <bring> haskell: let x = 6 in x*(x+1)
03:50:02 <skew> GHI?
03:50:29 <bring> :)
03:50:34 <skew> they don't do any other languages, do they?
03:50:41 <bring> they have a calculator
03:51:05 <shapr> is it a turing complete calculator? ;-)
03:51:15 <bring> :)
03:51:22 <bring> doubt it
03:52:00 <bring> http://www.google.com/help/calculator.html
03:52:07 <skew> shapr: nah, even the mighty googlebyte RAM array can't quite simulate unbounded tape
03:52:57 <skew> I want to write a little web application thing in Haskell, but I don't know how to handle authentication
03:53:23 <shapr> I've been wondering that myself.
03:53:33 <shapr> you could use haskelldb
03:53:50 <shapr> but that's my guess without actually trying any alternatives
03:54:15 <skew> I don't really care about the mechanics of authentication, but rather just making a session, and representing it in the code
03:54:34 <shapr> WASH has session support
03:55:45 <shapr> WASH really wants to treat everything as a form submission though.
03:55:56 <shapr> that's not too bad in most cases.
03:56:02 <skew> yeah, that's a problem
03:56:16 <skew> using HTML templates would be nice too
03:57:23 <shapr> if you want HTML files that have fields that get filled in, halipeto looks nice
03:57:27 <shapr> though I haven't used it myself
03:57:47 <shapr> it would be neat to combine WASH and halipeto
03:57:57 <shapr> hm, I gotta try that soon
04:29:23 <Lunar^> shapr: That could be a good sprint during EuroHaskell IMHO
04:32:07 <shapr> that's a good point
04:32:52 <shapr> g'day Si\ 
04:32:58 <shapr> how's the sunny south treating you?
04:39:37 <Si\> sunny south?
04:39:44 <shapr> er, sheffield?
04:39:54 <Si\> that's north
04:40:15 <Si\> well it depends what you're relative to
04:40:26 <shapr> right, I'm at the arctic circle.
04:40:37 <Si\> ah, then I'm south I guess :)
04:41:34 <Si\> btw, if you're interested you can download an alpha version of HAIFA with HAC from http://www.dcs.shef.ac.uk/~u1sf/haifa.html
04:41:46 <Si\> there's also Haddocks and a very basic manual there
04:51:17 <earthy> HAIFA with HAC
04:51:20 <shapr> ah, cool
04:52:30 <earthy> simon, would you be so kind as to write a blurb on it to include in the HC&AR? :)
04:52:53 <shapr> oh, I have to send my blurbs off to earthy 
04:53:44 <shapr> earthy: I've put most of my blurbs at the bottom of http://www.haskell.org/hawiki/SandBox
04:53:50 <shapr> is that the sort of thing you want?
04:55:05 <earthy> roughly, yes.
04:55:42 <shapr> ok
04:56:58 <earthy> although your previous report on Haskell User-Submitted Libraries was a bit more complete, and I like that somewhat better. :)
04:57:45 <shapr> more text would be nice?
04:58:45 <earthy> a bit more explanation would be nice, yes.
04:59:02 <earthy> such as what is in the husl
04:59:40 <earthy> I like the cryptic description of the iohcc though. :)
04:59:53 * shapr grins
05:02:55 <Si\> It currently hasn't got a skeleton/stub generator so you have to write them yourself
05:03:11 <Si\> the client bit is tightly bound to SOAP/1.1 and it shouldn't be
05:03:27 <Si\> and HAC needs a whole lot of work, but other than that it works fine
05:04:21 <earthy> si: great! could you email that to hcar@haskell.org? :)
05:09:43 <Si\> I'll do it once I have de-messified my code
05:10:37 <earthy> ;)
05:10:57 <earthy> hey, you're on the list. I'll pester you later this month and early next. ;)
05:12:58 <Si\> I've got little over a week to finish my disseration, and so after then I should be free to sort it out
05:16:00 <earthy> as I said, no hurries. yet.
05:16:29 <shapr> the evil word "yet" follows...
05:42:17 * earthy *likes* darcs, btw
05:45:58 <shapr> me too
05:46:00 <shapr> darcs r0xx0rs
06:20:24 <Lunar^> shapr: u l33t
06:25:07 <SyntaxNinja> good morning, #haskell
06:25:25 <Igloo> Hi Syn
06:26:52 * SyntaxNinja went camping / hiking over the weekend.  it was so incredibly beautiful in the midwest over the weekend.
06:31:50 <SyntaxNinja> so I'm trying to think of a good way to allow items in a collection to refer to each-other, and to be sure that any function can find the referred-to item and alter it... in a C-type language, I'd use pointers/references... in Haskell, I'm thinking of using NodeIDs or something, like FGL does.  maybe I'd have a monad which would keep track of mappings between IDs and objects, and dole out new IDs where necessary.  is there any kind of library for 
06:33:28 <Igloo> I did something using FiniteMaps from Ints to Objects
06:33:40 <Igloo> I think Pseudonym said it was called hash consing
06:34:02 <Igloo> I might be able to dig it out later if you want, but I'm not sure how general it is OTTOMH
06:34:53 <SyntaxNinja> it could be instructive to look at it at the very least ;)
06:34:59 <SyntaxNinja> hash consing, 'eh?
06:35:26 <SyntaxNinja> did you generate unique IDs, and access items in a monad?
06:35:49 <SyntaxNinja> what do you mean by "Object"?
06:40:47 <Igloo> You should have mail
06:44:57 <Igloo> a is a type like data Foo = Foo String Addr Addr | Bar Int Bool Addr | ...
06:57:46 <earthy> hm. nice. a PDF with ISO EBNF notation. that might come in handy
06:58:03 <earthy> `what's that? EBNF! oh no it isn't, looksee here!'
06:59:17 <SyntaxNinja> Igloo: oh, so you maintain a two-way mapping
07:06:04 <SyntaxNinja> Igloo: yeah, this is pretty much exactly what I had in mind....
07:06:49 * shapr cackles happily
07:06:49 <Igloo> Yup
07:07:29 <shapr> there's a unique names monad that came with ghc 6.2 I think
07:08:06 <SyntaxNinja> I'd like to remind everyone to fill in bits of the Fundamental Concepts page on the wiki :) http://www.haskell.org/hawiki/FundamentalConcepts
07:08:17 <SyntaxNinja> it's good for ya ;)
07:14:40 <shapr> right, our community building bit for the day.
07:15:04 <SyntaxNinja> plus, if you don't know about something, then you can learn about it in order to fill in info on the wiki :)
07:15:15 <shapr> hey, who can I ask here about the legal issues involved in changing HaWiki's license?
07:15:33 <SyntaxNinja> or if there's something else you feel like learning, go out and learn, then post it to the wiki :)
07:15:37 <shapr> I want to change the header/footer to explicitly put the content into the GPL, lGPL, something
07:15:51 <SyntaxNinja> shapr: is it already in some other license?
07:16:01 <shapr> I don't think it's in any license
07:16:10 <shapr> because of 
07:16:15 <shapr> @wiki PreludeExts
07:16:15 <lambdabot> http://www.haskell.org/hawiki/PreludeExts
07:16:18 <shapr> I now wish it were
07:16:21 <Igloo> You'd probably need to get permission from anyone who contributed significant content
07:16:53 <shapr> happily, most of the significant contributors are here.
07:17:07 <Igloo> Heff mentioned the ACM just offered to remove stuff the authors weren't happy with in a similar discussion re another wiki
07:17:10 * Igloo goes to look
07:17:18 <shapr> yah, that would be a good pattern to follow
07:17:30 <Igloo> Anything I've put on the wiki (which I think is nothing) can be PDed
07:19:38 * Igloo can't find it now. I'll ask Heff when he reappears
07:22:07 <SyntaxNinja> boy, that's a yucky issue, really. how will you ever know if you've got everyone's content
07:22:16 <SyntaxNinja> anything I've put on the wiki can be PDed too
07:22:24 <shapr> easy, I create another wiki with a specific license
07:22:36 <shapr> that will also allow the dissenters to use the other wiki that has no license
07:23:01 <SyntaxNinja> I mean, what about the content already there?
07:23:11 <shapr> I'll port over the stuff I can get a license to port
07:23:20 <shapr> can you think of a better way?
07:23:41 <shapr> maybe there's another way, but I can't think of it.
07:24:07 <SyntaxNinja> that's very work intensive; but no, I can't think of a better way offhand...
07:28:03 <Lunar^> I hate Zope, I hate Archetypes, I hate Plone, I hate all those damn 100% dynamic technology
07:28:17 <shapr> Lunar^: I'm with you on that.
07:28:20 <Lunar^> sorry for the burden, I need to say that
07:28:22 <shapr> actually, they can be done well
07:28:29 <shapr> but Zope has grown like a cancer.
07:28:51 <shapr> it's very hard to make several independent addons work together smoothly
07:36:19 <Igloo> shapr: Near the bottom of http://www.siggraph.org/publications/newsletter/v34n2/columns/editor.html is "Notice to Past Authors of ACM-Published Articles", and it's also at the front of all the printed proceedings
07:37:18 <Igloo> It would be nice if the licence chosen was one given the thumbs up by debian-legal WRT DFSG-freeness, BTW
07:37:21 <shapr> you think I can put the same sort of notice on the haskell mailing list and the haskell wiki itself?
07:37:32 <shapr> yes, DFSG freeness is my primary goal
07:37:49 <shapr> because I want to try the distributed wiki idea, and I need some existing active content :-)
07:37:50 <Igloo> I say that because Creative Commons wasn't obviously FDSG-free
07:38:01 <shapr> what is?
07:38:05 * Igloo can't remember which of their licences in particular I was looking at
07:38:26 <Igloo> I'd suggest e-mailing haskell@ and putting it on the front page, yeah
07:38:42 <shapr> so, do you think I can get away with that?
07:38:49 <shapr> that would be a far less work intensive process.
07:39:02 <Igloo> Well, PD, GPL, BSD 3 and many more besides  :-)
07:39:28 <Igloo> I'd also make an effort to contact those whose work you can identify easily
07:40:05 <Igloo> And perhaps also remove any code you can't get permission for
07:40:20 <Igloo> So people don't use it only to have someone complain later
08:18:33 * shapr boings
08:18:57 <kosmikus> are there any open source windows installers that are easy to use?
08:23:50 <mattam> maybe winamp's one is
08:24:35 <Lunar^> mattam: PIMP is free software
08:24:43 <Lunar^> (that's a good point also)
08:27:55 <kosmikus> thanks
08:49:21 <kosmikus> how does the windows ghc determine the library path? under unix, it is executed via a script that contains the environment variable setting. how is this achieved under windows?
08:50:23 <saz> you set it
08:50:33 <saz> there's a property you change
08:50:37 <kosmikus> yes, clearly
08:50:45 <saz> you can get to it by right clicking my comoputer
08:50:47 <kosmikus> but how does the program remember? where is it stored
08:50:58 <saz> some registry file
08:51:04 <saz> it's 2am so i can't remember
08:51:25 <kosmikus> okay, so can you access the windows registry from Haskell?
08:52:16 <saz> http://www.cse.unsw.edu.au/~homecomputing/cdrom/html/ghc.html
08:52:24 <saz> there's instructions there
08:52:44 <saz> no, it's a path variable
08:53:41 <kosmikus> yes, I think that's a different setting
08:54:16 <kosmikus> thanks anyway
08:57:02 <Smerdyakov> You can surely access the registry using the FFI, if nothing else.
09:03:00 <kosmikus> I just found Win32Registry.hs ...
09:19:23 <Manny> hi :)
09:20:04 <SyntaxNinja> hi Manny
09:20:17 <shapr> greetings Manny 
09:20:18 * Manny loves C and is a Haskell newbie :P
09:20:40 <shapr> enthusiasm for programming is a good thing
09:20:45 <shapr> hi jadrian 
09:20:46 <jadrian> hello everybody, long time no see
09:20:50 <jadrian> hi shapr
09:20:54 <shapr> yah, wassup?
09:21:10 <Manny> what's Haskell primarily used for?
09:21:13 <shapr> Manny: are you learning Haskell for school or for fun?
09:21:18 <Manny> it looks like a - lets call it - calculation language
09:21:31 <jadrian> shapr: about to start implementing some stuff in haskell... again :)
09:21:36 <shapr> cool
09:21:42 <jadrian> hope so
09:21:58 <jadrian> I'm thinking about updating my ghc
09:21:58 <Manny> shapr: both :P we decided to do functional programming and because I've never really tried it out
09:22:04 <shapr> Manny: I recently wrote a web mailing list search program in haskell, and lambdabot is in haskell.
09:22:13 <jadrian> I got ghc-6.0.1 installed
09:22:22 <shapr> you should get 6.2.1 if you can
09:22:39 <jadrian> yeap, no SuSE rpms there, they say the RH one might work
09:22:45 <jadrian> thinking about giving it a try
09:23:04 <Lunar^> Manny: I made a distributed fax recognition engine controller
09:23:11 <Lunar^> Manny: and... an operating system
09:23:18 <shapr> Manny: there's an url in the topic that has a list of useful links, or I can point you to some random other stuff 
09:23:32 <shapr> I wrote a pure code intro for the thoroughly impatient (like myself)
09:23:33 <Manny> yes, I'm currently reading "Haskell-Tutorial"
09:23:55 <jadrian> Do you know where can I get the older ghc versions?
09:24:03 <SyntaxNinja> Manny: I work for a company that's developing artificial intelligence prototypes using Haskell
09:24:07 <jadrian> in case I remove this one a the new one doesn't work?
09:24:18 <shapr> SyntaxNinja: that's just so cool =)
09:24:23 <Lunar^> SyntaxNinja: I didn't know that :)
09:24:27 <jadrian> SyntaxNinja: nice, what kind of ai?
09:24:53 * jadrian has played around with neural networks in haskell
09:24:59 <jadrian> and I'm moving to automated theorem proving
09:25:26 <SyntaxNinja> jadrian: the AI bit of our work is focused on "abductive inferrence" which is about putting together hypotheses to come up with a good explanation for a piece of information / datum.
09:25:32 <SyntaxNinja> Lunar^: :)
09:25:53 <jadrian> SyntaxNinja: nice
09:26:04 <Manny> argh :: Int
09:26:04 <Manny> ERROR - Undefined variable "argh"
09:26:05 <Manny> why?
09:26:22 <shapr> Manny: if you're using ghci, try "let argh = 1 :: Int"
09:26:32 <Manny> do I need to initialize it by doing argh = somefunc arg?
09:26:33 <SyntaxNinja> Manny: did you supply the type signature, but not the actual value?
09:26:40 <Manny> SyntaxNinja: yes
09:26:45 <Manny> I call it "declaration" :P
09:27:32 <SyntaxNinja> Manny: in Haskell, you don't bring a symbol into scope by supplying a type signature.
09:27:41 <Lunar^> Manny: Haskell is a pure functional language : once a variable is defined, it keeps its value until it becomes forgotten by everyone
09:28:00 <SyntaxNinja> jadrian: http://www.aetion.com for more info
09:28:20 <jadrian> by the way, slightly off topic.
09:28:32 <jadrian> any of you experienced with algebraic specification tools?
09:28:40 <jadrian> OBJ, CafeOBJ, Maude...
09:29:12 <shapr> Manny: http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:29:21 <jadrian> SyntaxNinja: hmm multiobjective optimization, I know people who have some work in that area
09:29:40 <jadrian> SyntaxNinja: amd decision support
09:30:09 <jadrian> s/amd/and
09:30:43 <SyntaxNinja> jadrian: it's an interesting field.
09:30:52 <jadrian> SyntaxNinja: yeap
09:31:07 <jadrian> SyntaxNinja: In fact I know more than one person on it
09:32:58 <jadrian> SyntaxNinja: the main work of the one I know better though, is about k-shortest path
09:33:35 <jadrian> SyntaxNinja: but she ends up solving some multi-objective problems and has some applications to decision theory too...
09:34:04 <jadrian> brb
09:35:54 <jadrian> back
09:36:02 <Manny> Main> somenumber = 1
09:36:02 <Manny> ERROR - Syntax error in input (unexpected `=')
09:36:13 <SyntaxNinja> jadrian: I'd be interested to know what your friend(s) think of our work (from what can be gotten from the web site, anyway)
09:36:28 <Manny> the code sample states that I don't need type signatures
09:36:29 <SyntaxNinja> Manny: which interpreter are you using?
09:36:30 <Manny> mostly
09:36:31 <Manny> hugs
09:36:38 <SyntaxNinja> Manny: no, you dn't need them
09:36:45 <SyntaxNinja> in Hugs, you can't make top-level bindings like that
09:36:59 <SyntaxNinja> instead you could say "let somenubmer = 1 in somenumber + 1"
09:37:08 <SyntaxNinja> in ghci, you can say "let somenumber = 1" to do what you want to do
09:37:22 <jadrian> SyntaxNinja: I may ask her, can't promise anything though since she's finishing her Phd and doesn't have much time on her hands
09:37:30 <jadrian> SyntaxNinja: but I'll show it to her
09:37:38 <SyntaxNinja> but I would suggest not doing that, since it kinda encourages a non-functional view of the interpreter
09:37:49 <Manny> SyntaxNinja: what does the "in" thingie mean?
09:37:53 <SyntaxNinja> jadrian: cool, no big deal
09:38:10 <SyntaxNinja> Manny: basically, you're setting the value of some symbols which will be used inside the "in" clause.
09:38:34 <SyntaxNinja> you can also say "somenumber +1 where somenumber = 1"
09:38:47 <SyntaxNinja> (but you may have to mess with whitespace :) )
09:39:20 * Manny - Haskell flash: where, in clause, *argh*
09:39:26 <Manny> int somenumber = 5 :P
09:39:47 <jadrian> SyntaxNinja: hmm you're using genetic algorithms too... 
09:39:52 <SyntaxNinja> Manny: if you're dealing with a file, then you can make top-level bindings like that.
09:39:54 <SyntaxNinja> just not in the interpreter
09:40:07 <SyntaxNinja> but it's more like a "const" declaration
09:40:19 <SyntaxNinja> jadrian: that's the idea anyway :)
09:40:27 <Manny> SyntaxNinja: well, aren't all declarations/intializations const decl./inits.?
09:40:37 <jadrian> SyntaxNinja: Is the "Evolver" implemented in haskell?
09:41:47 <SyntaxNinja> jadrian: yeah, I think so... the abduction part (Explainer) and the Viewer are my bits, though, so I'm not sure about some of the other bits.
09:42:05 <SyntaxNinja> Manny: yes, basically.
09:42:32 <SyntaxNinja> but there's really not an obvious analog to the C code you posted, where you're declaring and initializing a mutable variable.
09:42:55 <SyntaxNinja> (nothing I would inflict on a newbie anyway)
09:43:51 <jadrian> SyntaxNinja: I had some ideas for a (yet another) genetic algorithm implementation, based on some artificial creativity readings I did, still on my todo list...
09:44:39 <jadrian> I haven't came up with an elegant way of dealing with randomness though
09:45:29 <jadrian> 'my' idea was using state refs on implicit parameters... but by that time ghc had a bug that prevented me from doing the way I wanted too :-/
09:45:45 <jadrian> Anyway, I got to think about theorem proving now :)
09:45:52 <SyntaxNinja> jadrian: ok. ttyl.
09:46:23 <Manny> how can I print out the int result of a function?
09:46:28 <Manny> Increment :: Int -> Int
09:46:38 <Manny> increment x = x + 1
09:46:52 <Manny> simply increment 5?
09:47:03 <Manny> ERROR "test.hs":5 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
09:47:08 <Manny> works when entering into interpreter
09:47:13 <Manny> but not inside the file
09:47:15 <ludde> you need a lowercase letter 
09:47:17 <Manny> argh
09:47:18 * Manny stupid
09:47:30 <ludde> yes
09:47:48 <ludde> i know
09:47:49 <ludde> j/k
09:48:08 <Manny> ludde: what do you mean by a lowercase letter? :(
09:48:11 <ozone> jadrian: supply an infinite list of random numbers?
09:48:14 <SyntaxNinja> > print (increment 4)
09:48:24 <ludde> Manny: you can't use Increment, it must be increment
09:48:42 <Manny> argh
09:48:49 <Manny> I used increment
09:48:57 <SyntaxNinja> Manny: he means in the type sig
09:48:58 <Manny> I just didn't c'n'p ;)
09:49:13 <Manny> but the tutorial doesn't do so
09:49:18 <SyntaxNinja> @wiki HaskellIrcPastePage
09:49:19 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:49:27 <SyntaxNinja> you can paste longish stuff there for questions
09:49:28 <Manny> still doesn't work
09:49:29 <Manny> argh
09:49:29 <Manny> :(
09:49:36 <Manny> ok
09:49:43 <Manny> currently, this is my source code:
09:49:46 <Manny> increment :: int -> int
09:49:46 <Manny> increment x = x + 1
09:49:46 <Manny>                                                                                                                  
09:49:46 <Manny> increment 5
09:49:51 <Manny> thank you all for your efforts, really
09:49:56 <jadrian> I don't have gmp-devel, and there is no such package for SuSE... how bad can that be?
09:50:00 <jadrian> (I do have gpm)
09:50:05 <SyntaxNinja> delete the last line, load the file into the interpreter and type "print (increment 5)"
09:50:07 * Manny isn't ignorant, I just don't get how to think in Haskell :/
09:50:20 <Philippa> SyntaxNinja: you don't need the print
09:50:24 <SyntaxNinja> Manny: but I encourage you to work through more examples in the tutorial before asking too many questions here
09:50:35 <SyntaxNinja> Philippa: ja, but next step will be writing the "main" function :)
09:51:04 <Manny> I simply don't get why particular things can only be entered into the interpreter and others are just functional inside the source code
09:51:06 <Philippa> yeah, though I'd written quite a lot of Haskell before I ever touched the IO monad
09:51:08 <Manny> this is awkward
09:51:09 <Manny> :(
09:51:33 <SyntaxNinja> Philippa: either way.
09:51:35 <Philippa> Manny: the interpreter takes expressions and "that's it". Ignore any mention of IO for now
09:51:40 <ozone> Manny: it's easiest to open a .hs file in an editor, and get GHCI to load that (rather than trying to enter everything into GHCI)
09:51:40 * SyntaxNinja goes to lunch &
09:51:46 <Philippa> seconded
09:51:52 <SyntaxNinja> thirded
09:52:02 <Philippa> I still screw up too often when I attempt to "define" things in the interpreter
09:52:15 * SyntaxNinja &
09:52:21 <Philippa> which is kinda annoying when you're testing a parser or something
09:52:27 <ozone> Manny: and in our code above, replace "int" with "Int" (capital I)
09:52:42 <ozone> s/our/the/
09:54:13 <Manny> ok
09:54:24 * Manny goes ... dinner :)
09:54:26 <Manny> thanks for helping me
11:09:14 <stepcut> mmmm, ocamljitrun
12:50:34 <shapr> yow!
12:51:10 <shapr> yow!
12:53:04 <shapr> juergen: dude, you're bouncing
12:54:50 <SyntaxNinja> shapr: lots of bouncing
12:55:02 <shapr> you can temp ban him
12:55:03 <shapr> or I can
12:55:10 <shapr> I fixed tramp!
12:55:12 <shapr> oh hey SyntaxNinja 
12:55:21 <tic> hello
12:55:22 <shapr> the ghci prompt regexp is broken
12:55:24 <SyntaxNinja> hi shapr
12:55:28 <shapr> but I fixed it
12:55:32 <SyntaxNinja> shapr: hasn't it been like that for a long time?
12:55:38 <SyntaxNinja> oh, cool
12:55:45 <shapr> yes, but this is the 3rd time I've fixed it.
12:55:50 <shapr> I submitted a patch the first time
12:55:53 <SyntaxNinja> heh
12:56:05 <SyntaxNinja> hi juergen!
12:56:10 <shapr> juergen: dude, stop bouncing!
12:56:26 <shapr> since I just crashed gnumacs, I lost the fix again
12:56:37 <shapr> I just put \\. and a space into the regexp somewhere
12:56:53 <SyntaxNinja> shapr: so is this to fix a long-standing problem, or is it jsut the fact that with each new release of GHC, the prompt regExp needs to change
12:56:54 <SyntaxNinja> ?
12:57:05 <SyntaxNinja> when you submitted a patch, did it get integrated?
12:57:09 <SyntaxNinja> (you didn't send it to me, did you?)
12:57:10 <shapr> I thought it did
12:57:11 <shapr> but it seems not
12:57:23 <shapr> now that I've switched to gnumacs, I'm investigating haskell-mode thoroughly
12:58:01 <shapr> I gotta stop saving things in my *scratch* buffer since I'm so good at crashing emacs
12:58:18 <SyntaxNinja> hehe
12:58:27 <SyntaxNinja> don't you have my little notes-taking buffer thing?
12:58:36 <shapr> um
12:58:37 <shapr> I dunno?
12:58:40 <SyntaxNinja> since "scratch is for notes you don't want to save" :)
12:58:47 <shapr> right
12:58:59 <shapr> I want something that saves the file every thirty seconds or so
12:59:32 <SyntaxNinja> I can email it again. it's just a function which opens up a new file in outline mode, based on today's date, in a folder of your choosing (~/notes for example) which I bind to F3
12:59:51 <SyntaxNinja> then I take notes that I mgiht want to save in there.
12:59:57 <shapr> that's sensible
13:00:21 <SyntaxNinja> the solution is obsessive use of "C-x s !"
13:01:13 <bring> my obsessive C-x s:ing has gotten to the point where I do it in all programs
13:01:40 <shapr> emacs irritates me
13:01:44 <shapr> I want a replacement in Haskell
13:01:52 <bring> I do it in the terminal, then wonder why I can't type anything
13:01:58 <shapr> :-)
13:02:46 <Cale> shapr: me too :)
13:07:46 <SyntaxNinja> bring: I had an annoying problem in older versions of netscape mail... in emacs, M-q formats my email the way I usually want them, and I have the habit of doing it every so often when something looks wrong... sadly, M-q in netscape is "quit without saving this email that I'm being so careful in writing that I care about the formatting"
13:07:54 <SyntaxNinja> that made me quit using netscape mail and switch to Gnus :)
13:18:58 <stepcut> SyntaxNinja: haha
13:25:28 <bring> SyntaxNinja: bummer
13:42:19 * Igloo uses GHC extensions left right and center
13:42:22 <Igloo> I feel so...dirty
13:46:54 <SyntaxNinja> Igloo: don't feel bad ;)
13:47:51 <SyntaxNinja> what we need is a new Haskell standard push so that we can finalize at least a handful of the most important and well-understood extensions
13:51:57 <Igloo> Yeah
13:52:22 <Igloo> Anyone know how to write this?  init_colors :: IO ((CShort, CShort) -> (forall a . Integral a => a))
13:52:27 <Igloo> I'm getting "Illegal polymorphic type: forall a. (Integral a) => a"
13:57:05 * SyntaxNinja isn't sure that existential types can be used outside of a data declaration
13:57:07 <SyntaxNinja> data Obj = forall a. (Show a) => Obj a
13:57:07 <SyntaxNinja> init_colors :: IO ((Int, Int) -> Obj)
13:57:09 <SyntaxNinja> I think that works
13:57:22 <SyntaxNinja> well, I changed the input type and stuff
13:57:36 <Igloo> Ah, I think the problem is the "a" in "IO a" gets instantiated with a universally quantified type variable which isn't allowed
13:57:37 <Etaoin> what does the forall do?
13:58:01 <Igloo> I'll try doing the fromIntegral on the value after the computation has run
13:58:08 <SyntaxNinja> data Integralable = forall a. (Integral a) => Integralable a
13:58:08 <SyntaxNinja> init_colors :: IO ((CShort, CShort) -> Integralable)
14:00:07 <Igloo> let col :: (CShort, CShort) -> (forall a . Integral a => a)    is allowed, Syn
14:00:18 * Igloo has a coupel more errors before I'm sure this is going to work, though
14:00:24 <SyntaxNinja> Etaoin: http://www.haskell.org/hawiki/ExistentialTypes
14:01:38 <SyntaxNinja> Igloo: thanks. good to know
14:04:22 <Igloo> Yup, that all looks to be working after giving it an explicit type sig each time it is bound by a let after being taken out of the record
14:04:59 <SyntaxNinja> hi Marvin--
14:05:35 <Marvin--> evening
14:05:41 <Igloo> Bah, that's both libraries and the program itself needing fglasgow-exts now
14:06:15 <Marvin--> heh, I've given those things up a long time ago
14:06:28 <Marvin--> there's just way too much neatness available with -fglasgow-exts
14:06:42 <Marvin--> though I think most of the stuff I use work with hugs too
14:07:18 <Marvin--> SyntaxNinja: I *think* I'm starting to get the hang of the scoring in go now
14:07:25 <Igloo> I'm tempted to ask for flags to enable just existential types, just type synonyms in instance heads and just concrete type arguments in instance heads but the level of granularity would probably be annoying to implement
14:08:02 <Marvin--> probably yes, but it would be good to have
14:08:09 <Marvin--> "explicit is better than implicit"
14:12:09 <SyntaxNinja> hm. I always had the vague impression that all the exts were granularly specifiable (to coin a phrase)
14:12:20 <SyntaxNinja> Marvin--: any questions?
14:12:22 <SyntaxNinja> (about go)
14:13:24 <Igloo> I can't see one for forall-types at least, but I'd love to be proven wrong  :-)
14:14:25 <Marvin--> SyntaxNinja: not really, my biggest problem right now is to figure out how and when to end the game, that is, when the areas of control are becoming apparent, how do I play my stones to limit my opponent's areas best but also not risking ending up with dead stones, stuff like that
14:16:10 <Marvin--> I guess it'll come to me in time
14:16:34 <Marvin--> I lost a game today because I overreached when I tried to mess with the border between our territories
14:17:17 <SyntaxNinja> Marvin--: well, understanding who can control which areas, and at what cost, is really one fundamental aspect to playing the game... it's bigger than just scoring
14:17:26 <Marvin--> well, sure
14:17:46 <Marvin--> I think I'm going to just write off today's mistake as just that - a stupid mistake :)
14:17:48 <SyntaxNinja> or how large the territory outlined by a particular group really is
14:18:30 <Marvin--> but my two comments were largely unrelated, I'm getting the hang of how scoring works, but I have a hard time with the end game
14:19:31 <SyntaxNinja> I see.
14:19:51 <SyntaxNinja> have you found the Go Wiki to be at all useful?
14:19:51 <Marvin--> heh, turns out a friend of mine also bougth a go board last week, completely independent of me
14:20:32 <Marvin--> I haven't read it much, I read through the interactive way to go, and then played a few games with some equally newbie friends
14:22:54 <SyntaxNinja> cool.
14:23:46 <Marvin--> the practical techniques and stuff in the interactive thingy was really informative
14:24:37 <SyntaxNinja> Marvin--: link?
14:24:57 <Marvin--> SyntaxNinja: google for interactive way to go
14:25:31 <SyntaxNinja> ok
14:27:46 * SyntaxNinja goes home
14:27:47 <SyntaxNinja> peace all
14:42:00 <kosmikus> I have made a Windows binary version of lhs2TeX available at www.cs.uu.nl/~andres/lhs2tex -- use at own risk; any problems or suggestions welcome ...
15:54:24 * shapr whispers the secrets of functional programming
15:55:33 <shapr> sure is quiet out there tonight
15:56:11 <anyone> /whois sure
15:56:30 <shapr> :-P
15:57:35 <kosmikus> hi shapr
15:58:01 <shapr> hoi kosmikus 
15:58:11 <shapr> what's going on?
15:58:31 * kosmikus realizes that he is not working ...
15:59:00 <kosmikus> ... altough he should fill in all the remaining TODO's ...
15:59:04 <kosmikus> :)
15:59:23 <shapr> yah, I'm idly reading my swedish book for tomorrow morning's class.
15:59:38 <shapr> gnistrar is a great word
15:59:51 <kosmikus> how long are you learning swedish now?
16:00:02 <shapr> um, fifteen months I think
16:00:20 <kosmikus> isn't that sufficient?
16:00:26 <shapr> I've gotten to the point where I can actually read books without needing a dictionary, and I know most of the words.
16:00:42 <kosmikus> that's good.
16:00:47 <shapr> it would probably be sufficient if I spent more time studying swedish and less time doing fun stuff
16:01:10 <shapr> swedish is fun, but code is more fun.
16:01:27 <kosmikus> yes, I can read Haskell programs without dictionary as well ...
16:01:28 <shapr> have you learned Dutch?
16:01:31 <shapr> heh
16:02:06 <atom-z> what is 'matlab'?
16:02:17 <shapr> it's a math modeling program
16:02:19 <kosmikus> yes, although I did not spend much time on formally learning it -- I only took two courses during the years, and I did not learn very much there
16:02:44 <shapr> how long did it take you to be comfortable with dutch?
16:02:47 <atom-z> shapr: right
16:03:13 <shapr> atom-z: sort of like a really extraspiffy spreadsheet with zillions of built-in functions for certain purposes
16:03:14 <kosmikus> quite long ... about two years, I would say, maybe a bit more
16:04:02 <kosmikus> and it takes a long time to convince my collegues that I can speak Dutch
16:04:32 <kosmikus> by now almost everyone is talking Dutch to me, but that only happened during the last year or so ...
16:04:52 <atom-z> shapr: what use is it when we have mathematica?
16:05:35 <kosmikus> hmm, I could/should prepare tomorrow's roleplaying session -- I'm not going to do serious work anymore anyway ...
16:05:48 <kosmikus> although that almost feels like serious work, too ...
16:14:47 <Etaoin> atom-z: it implements various numerical algorithms for matricies
16:16:56 <np_hard> matlab is for numerics
16:17:02 <np_hard> mathematica is symbolic
16:17:23 <shapr> whoa, netpanzer is nice
16:18:14 <Pseudonym> What is netpanzer?
16:18:49 <shapr> http://netpanzer.berlios.de/
16:20:03 <Pseudonym> Interesting.
16:20:24 <shapr> it's fun too
16:33:32 <Pseudonym> shapr, you're familiar with GTK, aren't you.
16:33:40 <andersca> I am
16:33:44 <andersca> :)
16:33:45 <Pseudonym> Ah, OK. :-)
16:33:57 <Pseudonym> Are there any decent tutorials on implementing your own layout manager?
16:33:58 <andersca> unless you're gonna flame it
16:34:20 <andersca> not really, layout managers are just special widgets
16:34:23 <andersca> how would you like it?
16:34:39 <Pseudonym> It's the specialness I'm interested in.
16:34:53 <Pseudonym> A worked, more-documented-than-usual example would be good.
16:35:39 <andersca> hmm, I'd say some docs about creating new widgets together with the source code for gtkbox would be good
16:36:28 * Pseudonym nods
16:36:56 <andersca> I assume you're familiar with C
16:37:00 <Pseudonym> Yes.
16:37:19 <andersca> http://www.gtk.org/tutorial/ the tutorial has a bit about widgets
16:37:24 <Pseudonym> Though I'm actually building a C++ layer on top.  (Don't ask why I'm not using GTK--, but my reasons are unavoidable.)
16:52:35 <Pseudonym> Anyway, thanks.  I'll give that a go.
16:52:52 <Pseudonym> What I really want to do is avoid GTK altogether. :-)
16:53:05 <Pseudonym> Use a vanilla container and write my layout code separately.
16:53:24 <Pseudonym> Grab the "resize" signal and then just manually resize all the children.
16:53:36 <Pseudonym> But I don't think I can do that.
16:53:38 * Smerdyakov alerts the child protection bureau.
16:53:45 <Smerdyakov> Pseudonym manually resizes his children.
16:53:56 <Pseudonym> No, just the ones in the... container.
16:54:00 <Smerdyakov> LOL
16:54:13 <Pseudonym> I'm digging a deeper hole for myself, aren't I?
16:54:39 <Pseudonym> At least I don't reap zombie children, like Unix does.
16:55:34 <Smerdyakov> I don't know how you do things where _you_ come from, but around _here_, reaping zombies is considered a public service./
16:55:51 <Pseudonym> What about kill -9'ing them first?
16:57:04 <wagle> arent you supposed to reap what you fork?
16:57:49 <Pseudonym> Depends.  Under Linux 2.4, it's also sometimes valid to pthread_join() them.
17:19:44 <Igloo> OK, is it good or bad when you start writing "c <- getch" in C code?
17:21:05 <Pseudonym> Are you trying to enter the IOHCC?
17:21:14 <Pseudonym> If so, it's morally neutral.
17:21:46 <Pseudonym> BTW, I have a suggestion.
17:22:05 <Pseudonym> data FileStream c = Eof | Cons c (FileStream c) | Error IOError
17:22:15 <Pseudonym> hGetFile :: Handle -> FileStream Char
17:22:22 <Pseudonym> Wouldn't that make a lot more sense?
17:24:46 <heatsink> What kind of constructor is "Error IOError"?
17:25:02 <Igloo> Well you'd need something else when you wanted efficient strict reading
17:25:10 <Pseudonym> Igloo: True.
17:25:17 <Pseudonym> But it'd solve the error delivery problem.
17:25:23 <Pseudonym> heatsink: A pretty standard one.
17:26:15 <heatsink> Is IOError a type?
17:26:44 <Pseudonym> @type (undefined::IOError)
17:26:45 <lambdabot> undefined :: IOError
17:26:48 <Pseudonym> Yes.
17:27:08 <heatsink> I don't remember reading about <name> <type> format constructors before
17:27:18 <heatsink> The other two constructors look familiar
17:27:31 <Pseudonym> Well, the second one is pretty much the same.
17:27:35 <Pseudonym> Cons <type> <type>
17:27:42 <Pseudonym> where the first type is c and the second type is FileStream c.
17:27:55 <heatsink> oh
17:27:58 <heatsink> oh, yeah
17:28:02 <heatsink> I confused myself
17:49:26 <heatsink> So I gather that when an entity is to be modified sequentially by many functions, it's a good candidate for encapsulation into a monad
17:51:50 <Pseudonym> Yes.
17:51:57 <Pseudonym> Though it depends.
17:52:22 <Pseudonym> If that's the ONLY thing the functions are doing, then a composed chain of functions might be superior.
17:52:51 <heatsink> that makes sense
17:53:14 <Pseudonym> If they need to do I/O, pass other values etc, then a monad may well be better.
17:53:16 <heatsink> I'm thinking about lexing/parsing... I just found a file online about that, am reading it now
17:53:21 <Pseudonym> Right.
17:53:27 <Pseudonym> Well, lexing and parsing need to do two things.
17:53:36 <Pseudonym> First, they need to pass a stream of tokens between them.
17:53:41 <Pseudonym> Secondly, they may both need to do I/O.
17:54:04 <Pseudonym> They may both need to report errors, for example.
17:54:09 <heatsink> right
17:54:23 <Pseudonym> And a parser, of course, may need to fail early.
17:54:56 <Pseudonym> Though if you're using parsing monads, this will probably be built-in.
18:03:37 <heatsink> Oh, constructors and types can have the same name
18:04:32 <Pseudonym> Yes, which helps a lot.
18:04:33 <heatsink> Okay, now I understand the first three lines of code :)
19:02:47 * Leimy just got his ACM membership
19:02:55 <Leimy> some interesting Haskell papers there :)
19:13:33 <Pseudonym> Yes, there are.
19:13:38 <Pseudonym> The digital library is great.
19:13:46 <Leimy> :)
19:13:58 <Leimy> do you guys have access to a paste-bot here?
19:14:17 <Leimy> I want to show you my code for a "unique" function using very basic recursive functions
19:14:23 <Leimy> and see if you have any suggestions
19:14:56 <Leimy> like I can't think of one using list comprehension but the book I am using says there is one :)
19:16:12 <keverets> @wiki HaskellIrcPastePage
19:16:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:17:24 <Leimy> hmmm
19:20:03 <Leimy> ok I added my stuff at the bottom
19:20:09 <Leimy> I was writing a unique function
19:20:20 <Leimy> and I am sure I overdid it :)
19:27:26 * heatsink can't get past page 2 of this parser tutorial
19:27:30 * heatsink sighs
19:35:45 <heatsink> Could someone help me? In http://www.cs.nott.ac.uk/~gmh/pearl.pdf on page 2 it defines a bind operator p >>= f = Parser (\cs -> concat [parse (f a) cs' | ... ])
19:36:09 <heatsink> I don't understand why the right argument on the bind operator is a function that returns a Parser, rather than just a parser
19:36:15 <keverets> Leimy: unique xs = [x | x <- xs, length [y | y <- xs, x == y] == 1]
19:36:28 <keverets> there's almost definitely a nicer way
19:38:27 <Leimy> that's a pretty good one though :)
19:38:55 <Leimy> mine involved some other functions I had already written :)
19:39:01 <Leimy> I felt like I was cheating :)
19:41:49 <keverets> there's no cheating... just some ways are more elegant than others.
19:42:32 <Leimy> sure
19:42:50 <Leimy> I am at the point where I don't even care about speed of my programs yet too
19:43:00 <Leimy> Just trying to wrap my head around programming in Haskell :)
19:43:04 <Smerdyakov> Liar, liar, pants on fire.
19:43:09 <Smerdyakov> You care if it takes a year to run, I bet!
19:43:16 <Leimy> of course
19:43:28 <Leimy> but I am not trying to optimize the bahjezus out of it 
19:43:46 <Smerdyakov> What?? Are you calling me fat?!
19:44:10 <Leimy> sure
19:47:41 <Leimy> keverets: the list comprehensions version you gave me is basically O(N^2) eh?
19:48:10 <keverets> I didn't say it was efficient...
19:48:14 <Leimy> right
19:48:18 <Leimy> I am just making sure I understand :)
19:49:18 <Leimy> I mean mine is too :)
19:49:23 <Leimy> well... hmmm
19:49:44 <Leimy> actually mine might be a little faster depending.
19:50:36 <Smerdyakov> You need to use balanced trees or similar to do better with functional code.
19:51:23 <Leimy> yeah ... I thought the algorithms in functional programming might be very much data structure dependant
19:51:38 <Leimy> due to the recursive nature.
19:51:56 <Smerdyakov> So imperative algorithms are not very data structure dependent?
19:52:12 <Leimy> depends
19:52:27 <Leimy> you can implemenat a tree like structure by calculating array indicies with a formula in C :)
19:52:35 <Leimy> it's like sort of having a tree
19:52:57 <Smerdyakov> It _is_ having a tree....
19:53:08 <Leimy> without the overhead of two pointers per node
19:53:15 <Leimy> or 3
19:53:19 <Smerdyakov> No asymptotic effect.
19:56:24 <Leimy> actually I think mine only performs better if the list input is unique
19:57:43 * Leimy wonders if any CPUs have SIMD instructions that can take a vector of data and compare each item to every other and return a vector of true/false for less than or greater than.
19:58:32 <Leimy> er min/max
19:58:36 <Leimy> hmmm
19:58:43 * Leimy has to think about that question some more :)
19:59:46 <Leimy> I'd need a matrix as the result
20:02:43 <Smerdyakov> I'd be surprised if that was a much-requested instruction.
20:03:07 <Leimy> yeah me too :)
20:03:20 <Leimy> I can't think of a good application off the top of my head
20:19:28 <wagle> Leimy sounds a little like a z-buffer for graphics
20:19:40 <Leimy> collision detection
20:19:45 <Leimy> I started thinking about that :0
20:20:03 <Leimy> but I am not skilled in that field at all :)
20:21:45 <wagle> well, the graphics card would have the instruction you want (if not whatever the signal processing support is on x86 chips)
20:22:18 <wagle> i cant remember the name..
20:23:21 <wagle> i heard that a recent siggraph (?) had an article on general programming on graphics cards
20:27:03 <wagle> <random> MMX then SSE then SSE2 iirc
20:27:41 <wagle> thats the names of the signal / multimedia processing support on x86..  
20:28:26 <Leimy> yeah
20:28:37 <Leimy> there is SSE3 coming out for the Intel x86_64
20:28:45 <Leimy> and 3dNow for AMD chipsets
20:28:50 <Leimy> and Altivec on PPC
20:28:56 <Leimy> G4 and higher
20:30:01 <Leimy> actually... I don't know if 3dNow is SIMD
20:30:07 <Leimy> I've not seen much 3dnow code :)
20:32:56 <wagle> http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/21928.pdf
20:34:33 <wagle> .. uses the acronym SIMD to describe 21 of its integer instructions
20:36:11 <Leimy> hmmm
20:36:22 <Leimy> I think SSE2 can do double precision floats
20:36:33 <Leimy> Altivec is single precision only
20:36:50 * Leimy goes to bed
20:36:52 <Leimy> night!
20:38:30 <wagle> Leimy_zzz: someone mentions "PNI"
20:46:03 <wagle> (Prescott New Instructions, for the pentium 4)
23:29:16 <Smerdyakov> Anyone have a URL for a good code paste site?
23:34:42 <Pseudonym> http://www.nomorepasting.com/
23:34:45 <Pseudonym> That's the one I usually use.
