01:14:27 <Lunar^> Does anyone know if there will be a Internation Workshop on the Implementation of Functional Languages this year ?
01:15:17 <Heffalump> didn't that merge with the Scottish Functional Programming workshop to become TFP?
01:16:36 <Lunar^> Maybe I don't know
01:17:25 <Lunar^> Heffalump: Last IFL was last year though
01:18:33 <kosmikus> Lunar^: looks like there is one September 8 -- 10 in Luebeck
01:19:01 <kosmikus> http://www.mail-archive.com/haskell@haskell.org/msg14555.html
01:19:27 <Lunar^> kosmikus: Thanks, I was unable to find this mail
01:20:11 <kosmikus> Luebeck is my home town ...
01:20:50 <Lunar^> Maybe we should try submitting a paper about hOp... van Weeldeen and Plasmeijer papers where both presented at IFL
01:22:07 <Heffalump> ok, ignore me :-)
01:23:27 <Lunar^> Heffalump: ?
01:23:49 <ozone> Heffalump: you're right, btw
01:23:52 <Heffalump> oh, ok.
01:23:52 <ozone> well, kinda
01:23:57 * Heffalump gets really confused
01:23:58 <ozone> TFP directly followed IFL
01:24:02 <ozone> at the same place
01:24:16 <Heffalump> right
01:24:20 <ozone> so it wasn't merged, but it was rather close (both in time and space) :)
01:50:18 <Lunar^> kosmikus: URL http://www.isp.uni-luebeck.de/ifl04/index.htm
03:50:54 <shapr> yow!
03:52:16 <Heffalump> BOO!
03:57:09 <shapr> good morning Heffalump!
03:58:15 <earthy> yipes
04:01:33 <Spark> if during function application on an int, the intial function was 'a -> 'a, and the return value changes to int, is there a word for that
04:01:41 <Spark> like 'promotion' but it would really be demotion
04:02:23 <Spark> or is there no term for such a thing, which wouldnt suprise me
04:03:23 <kosmikus> instantiation ?
04:04:02 <Spark> hm i guess that would work, in the context of type
04:04:23 <Spark> because youre picking a specific set from a generic set of values
04:07:22 <shapr> good morning #haskell!
04:07:24 <shapr> how's the code going today?
04:13:04 <Heffalump> I hate perl sometimes.
04:14:19 <shapr> why hate perl?
04:21:58 <Philippa> toothpicks hurt my eyes
04:22:25 <shapr> hi Philippa, how's life?
04:24:01 <Philippa> so-so
04:24:24 <Philippa> looks like I'll prolly get to resit the semester now, thankfully
04:24:33 <Philippa> still need to talk to gmh about the ramifications for my project
04:42:02 <eixei> hi guys (and maybe gals)
04:42:13 <ski> hiya eixei
04:42:24 <eixei> how are you today?
04:42:31 <ski> fine :)
04:42:37 <eixei> nice to hear :-)
04:43:06 <eixei> what have you been up to?
04:43:35 <ski> reading a bit cat. theory :)
04:44:02 * eixei is sorry to ask, but what is cat.?
04:44:17 <ski> category
04:44:33 <eixei> ok :-)
04:44:45 <Lor> Hah, abbreviation wasn't worth it, you ended up typing more than you would have otherwise. :)
04:44:54 * eixei opens up google to fill his ignorance on the topic :-)
04:45:10 * ski smiles
04:45:59 <ski> eixei : perhaps you've heard about 'Monads' ?
04:47:24 <eixei> oh yeah
04:47:25 <shapr> @wiki CategoryTheory
04:47:25 <lambdabot> http://www.haskell.org/hawiki/CategoryTheory
04:47:39 <eixei> thanks shapr
04:47:51 <Lunar^> Hi shapr 
04:48:00 <Lunar^> shapr: Any plan to come to IFL 2004 ?
04:48:07 <ski> shapr : hello there !
04:48:23 <shapr> bonjour Lunar^ 
04:48:29 <shapr> where is ifl04?
04:48:30 <shapr> hej ski
04:49:17 <Lunar^> shapr: Germany
04:49:31 <ski> (IFL = international football league  or somethinng similar ??)
04:49:47 <Lunar^> shapr: http://www.isp.uni-luebeck.de/ifl04/index.htm
04:49:59 <eixei> sounds interesting ski :-)
04:50:21 <eixei> far beyond what I would read for fun but... well :-]
04:50:21 <ski> yeah, i think so
04:51:35 <shapr> actually, it's really useful in programming
04:52:35 <shapr> eixei: http://www.xp123.com/wwake/dissertation/model.shtml
04:52:59 <eixei> thanks shapr
04:53:21 <ski> shapr : looks interesting. thanks
04:55:03 <eixei> hi juergen
04:55:19 <earthy> shaper: that text is scary.
04:56:11 <ski> which part ?
04:57:33 <shapr> gutentag juergen 
04:58:07 <earthy> the concept put forth. :)
04:58:24 <shapr> the concept is just one use of CT though, I think
04:59:53 <eixei> shapr: Does the text continue?
05:00:02 * earthy knows a bit too much about uses of CT in semantics thankyouverymuch ;)
05:00:25 <earthy> (uses of, only, unfortunately)
05:02:37 <ski> huh ?
05:02:48 <juergen> hi and guten tag. I'm new to haskell and want to know, how to debug/trace. Hat doesn't compile for ghc6.2 (for me). Buddha is kind of not ready (Don't work with hierarchical modules...). I can use Hood/Observe to output trace messages and trace, which is very primitive. What do you use (Or is there no need for haskell coders to debug?)?  
05:03:06 * earthy uses his brain
05:03:17 <Cale> I use ghci
05:03:23 <earthy> that's the most portable debugger I've ever used. :)
05:03:29 <eixei> lol
05:03:45 <Cale> another option is Debug.Trace
05:03:45 <earthy> anyway, have you tried QuickCheck, Juergen?
05:03:51 <Cale> yes, and QC
05:04:33 <eixei> juergen.. hmm your nick sounds familiar :-/ Do you come from KA by any chance?
05:06:15 <Cale> You can get a lot of ability to debug out of the interpreter due to Haskell's referential trancparency.
05:06:36 <Cale> transparency*
05:07:11 * Cale struggles to wake up at 8am.
05:08:06 <juergen> I've read about QuickCheck, and that impresses me, but I've not used it. I mean you really need to put a lot of effort into using it with consequence. Debug.Trace and Observe I've both tried. I used ghci as well, but this is not my favorite way of working. What is lol? And no, I don't know what KA means.
05:08:39 <earthy> lol == laughs out loud
05:08:57 <earthy> and the effort is exactly what gets the bugs out
05:09:18 <kosmikus> KA = Karlsruhe ?
05:09:27 <eixei> yep
05:09:32 <Segora> :)
05:09:42 * Segora lives in Karlsruhe.
05:09:48 <eixei> lol
05:10:21 <eixei> Are you going to uni?
05:10:41 <Segora> I learned Gofer in '92
05:10:47 <Segora> at the uni
05:11:15 <eixei> hehe, cool
05:11:24 <Segora> and you?
05:11:30 <eixei> We did Haskell with Good (you know him?) last semester
05:11:43 <Segora> perhaps you mean Professor Goos?
05:11:56 <eixei> oops, a spelling mistake :-)
05:12:03 <ski> lol
05:12:13 <eixei> I'm still in 2nd semester *g*
05:12:28 <Segora> Yes, I know him. He's fascinating.
05:13:17 <eixei> yeah, he truly is :-)
05:13:18 <Segora> Had an examination in compiler construction with him
05:15:03 <earthy> that must've been interesting
05:22:41 <Segora> it was.
05:24:43 <eixei> http://www.xp123.com/g4p/0110a.htm :-)
05:32:28 <shapr> juergen: QuickCheck is less effort than unit tests that cover the same ground
05:36:00 <juergen> I will give QuickCheck a try. (But up to now (of course) I was to lazy for unit tests either). 
05:40:31 <Cale> juergen: what have you been unable to test in ghci? Usually I find that it provides enough facilities for testing functions
05:40:35 <shapr> unit-test-first aka test-driven-programming will keep your code very clean
05:42:23 <juergen> Why does test-driven programming keep my code clean, I thought it would keep my code without errors hopefully, but why clean? 
05:44:21 <shapr> because, if you add in refactoring, your speed of change of code is higher, so it's easier to get it clean and keep it clean
05:44:51 <juergen> Concerning ghci, I have a project with currently ~10 source files and it is quickly growing, and I compile it, but isn't it a bit unpratical to load it all in ghci?
05:45:14 <shapr> ghc compiles .hs files to .o files for loading into ghci
05:45:33 <shapr> I've loaded projects with about a hundred source files into ghci
05:46:05 <juergen> What do you mean with 'if you add in refactoring'?
05:48:19 <blackdog> refactoring is any set of changes that don't change behaviour
05:48:37 <blackdog> but you can't tell whether or not a change alters behaviour unless you have tests
05:50:47 <eixei> hi jesse
05:50:51 <jesse> hi
05:50:54 <juergen> So shapr wants to say: if you have test cases, it is easier to refactor, and that is why the code is cleaner? 
05:51:20 <shapr> shapr would actually like to give you the detailed description, but has to work right now...
05:51:22 <eixei> lol
05:51:23 <blackdog> yep.(sorry to put words in your mouth, shae. :)
05:51:24 <shapr> plus you're not here anyway :-P
05:52:35 <blackdog> the best bit is the little shot of encouragement you get when another test passes. when i can muster the self-discipline to write test-first, I always stay interested longer because it's obvious to me that I'm making progress.
06:17:57 <Spark> fuck i love the smell of turps
06:18:07 <Spark> i could just pour it onto a cloth and breathe through it all day
06:20:55 * ski sighes
06:21:59 <ski> hmm, what's turps ?
06:22:15 <Heffalump> turpentine
06:22:19 <Heffalump> stuff you use to remove paint
06:22:33 * ski tried to look it up but mozilla has bugs
06:22:36 <Spark> or brain cells, in this case
06:22:41 <ski> oh, k, thanks
06:23:17 <ozone> blackdog has self-discipline?
06:23:22 <ozone> blackdog makes progress?
06:27:18 <Lunar^> kosmikus: Do you know if there's any fee for IFL ?
06:27:37 <ozone> there was last year, yes
06:28:17 <Lunar^> ozone: Can you rememebr how much ?
06:29:08 <ozone> Lunar^: sorry, i can't remember at all
06:29:23 <Lunar^> ozone: More than 100e ?
06:30:43 <ozone> no, i don't think it was
06:30:51 <ozone> maybe blackdog can remember (or seafood, if he's online)
06:31:11 * ozone slaps blackdog around with a wet ... snapper
06:31:19 <Lunar^> hehe
06:32:24 * shapr swears at Zope
06:32:31 <kosmikus> Lunar^: no, I don't know
06:34:58 <ski> aarrgh .. not again ...
06:35:25 * ski kills mozilla yet again
06:37:08 <ski> .. and again
06:41:02 <Spark> use a stable mozilla build :)
06:42:14 <ski> helpdesk just closed for today, so i can't go there an' complain :/
06:43:25 <ski> hello mads-
06:43:33 <mads-> Hi ski
06:43:37 <mads-> Do I know you...?
06:43:46 <ski> not that i know :)
06:43:51 <mads-> Or are you just polite to greet me =)
06:44:08 <ski> ya guessed right
06:44:45 <mads-> thx :D
06:44:51 <mads-> From sweden, I see..
06:44:58 <ski> ja
06:45:10 <mads-> I'm kinda angry at swedish ppl..!
06:45:15 <ski> oh
06:45:20 <mads-> You have 100 times faster internet than us =(
06:45:23 <ski> why, pray tell ?
06:45:37 <mads-> Our net sux!
06:45:47 * ski didn't know that
06:46:10 * mads- did :D
06:46:39 <mads-> Naaah, i'm not angry.. Jaloux is more word, I think =/
06:47:05 <ski> s/Jaloux/Jealous/
06:47:08 <mads-> Good at Haskell...?
06:47:13 <mads-> Oh.. Thanks..
06:47:18 <mads-> English is not my strong side...
06:47:25 <ski> well, i like haskell
06:47:50 <ski> are you learning haskell now ?
06:48:04 <mads-> Nope... I'm gonna.. But starting out with OCaml..
06:48:09 <ski> ok
06:48:12 <mads-> I was programming C before..
06:48:23 <mads-> So I kinda have to change methods..
06:48:33 <mads-> From imperativ to functional..
06:49:07 <ski> Change your ways and REPENT ! The END is near !
06:49:14 <ski> (just kidding ;)
06:50:14 <mads-> hehe
06:50:31 <mads-> Been programming for long...?
06:50:37 <ski> learning a new paradigm can be a bit hard, at times..
06:50:42 <ski> not today
06:51:17 <mads-> I've just gotten out of bed..
06:51:28 <mads-> so.. not much for me today =)
06:51:30 * ski smiles
06:51:35 <earthy> oh, no you don't. see e.g. http://www.haskell.org//pipermail/haskell-cafe/2004-March/005939.html
06:52:32 <earthy> no paradigm shifts involved. :)
06:52:39 <ski> lol
06:53:26 * earthy continues reading up on garbage collection
07:06:56 <Spark> whats the deal with garbage collection in functional languages
07:07:27 <Spark> it looks pretty simple on the surface, you just have a stack to deal with
07:07:39 <Spark> but i imagine with unbounded lists and stuff it would get much more complicated
07:08:01 <earthy> well, it's not just a stack
07:08:14 <earthy> and you want to allow circular structures...
07:10:04 <earthy> plus, technically, in a functional language you do *not* know if what one routine has allocated can actually safely be freed when the routine exits, as it may well have been passed as a result
07:10:42 <ski> especially closures
07:10:49 * earthy nods
07:15:35 <Spark> heh there are cyclic data structures
07:16:34 <ski> mm
07:22:15 <Spark> is there a good way of detecting what nodes are no longer connected to a node, if an edge from that node is removed?
07:22:55 <Spark> well actually is it possible to do it without tracing a path to each node after removing the edge?
07:23:07 <Spark> maybe with some caching
07:24:39 <earthy> a refcounting array representation would seem to allow that
07:24:47 <earthy> at the cost of quite some memory overhead
07:24:55 <eixei> and back :-)
07:25:13 * eixei stupidly hit his pc with the foot :-/
07:25:22 <Spark> so you record all the indirect references as well as the indirect ones?
07:25:26 <earthy> eixei: you have not yet sabotaged the off-button?
07:25:27 <Spark> heh
07:25:33 <earthy> spark: exactly. :)
07:25:55 <Spark> mm i wonder what kind of memory overhead we're looking at
07:25:58 <eixei> Well, I didn't hit the off button, rather the gfx-card :-/
07:26:05 <Spark> at worst its going to be O(n^2) for the nodes in the graph
07:26:10 * earthy nods
07:26:44 <earthy> but, as the graph representation itself is probably at O(n^2) of the nodes anyway you only add a factor
07:27:01 <earthy> unfortunately, the factors *do* count. :)
07:27:49 <Spark> :) thats quite cool actually
07:27:58 <Spark> its not perfect but its quite adequate for my purposes
07:28:42 <shapr> if you use an adjacency list representation, that's an easy operation
07:29:08 <shapr> of course, modifying such a representation is painful... 
07:33:24 <earthy> shapr: I was suggesting an adjacency array, in fact
07:33:28 <shapr> ah, ok
07:35:28 <ski> hej igen mads-
07:36:14 <mads-> hej igen ski :D
07:36:25 <mads-> We have lightningbolts here..
07:36:35 <mads-> My computer just said "puff" and restarted..
07:36:54 <ski> 'oops'
07:37:14 <ski> here 'tis just cloudy atm
07:37:25 <ski> (i.e. in gbg)
07:38:00 <mads-> Now it's just raining..
07:38:05 <mads-> Kinda much
07:38:16 <ski> where in denmark are you ?
07:38:42 <mads-> Southern Jutland..
07:38:46 <mads-> Close to germany
07:38:49 <ski> ok
07:39:10 <mads-> So the bad weather have long way from here to you =)
07:42:40 <Spark> if its going west it will hit me after a thousand miles or so :)
07:42:59 <Spark> actually it cant be much more than 250 to the UK can it?
07:48:18 * ski doesn't know
07:49:10 <Spark> wheres a north sea fisherman when you need one
09:09:02 * ski reads bug feedback
09:49:42 <Spark> right its official
09:49:47 <Spark> my exams end 04/06/2004
09:50:03 <Spark> when was that eurohaskell thing?
09:50:51 <bring> June 10-12
09:50:59 <bring> http://www.haskell.org/hawiki/EuroHaskell
09:51:07 <Spark> cool
09:51:15 <Spark> that gives me 6 days to learn haskell then :)
09:51:26 <Lunar^> bring: I'm currently seeing if I can come
09:51:29 <Lunar^> Spark: lol
09:51:41 <bring> Lunar^: sweet
09:52:14 <bring> we talked about having some sprint to write stuff for h0p
09:52:23 <bring> filesystem or shell or something like that
09:53:37 * ski gotta go now
09:53:42 <ski> bye
09:55:15 <Lunar^> bring: If we have a sprint to make, I think it would be integrating GHCi
09:55:52 <Lunar^> bring: filesystem is reallly a complicated part because with sebc, we are pretty convinced that the notion of file is flawwed
09:55:56 <Lunar^> -w
09:56:25 <bring> ok
09:57:49 <Lunar^> bring: There's already a readline like interface which work quite well (but would need some rewriting to improve performance)
09:58:04 <bring> would you like to add something about this to the wiki page?
09:58:06 <Lunar^> bring: What would be fun also is to make a VESA driver
09:58:20 <Lunar^> bring: I still don't know if I'm coming
09:58:22 <bring> these all sound like a lot of fun
09:59:13 <bring> ok, but you are still welcome to add your comment to the wiki page if you want
09:59:31 <Lunar^> Sure.. I will do that in the next days
09:59:37 <bring> great
10:03:22 * Heffalump wonders how one gets to Gothenburg
10:03:50 <bring> ryanair from stanstead to gothenburg city airport is the cheapest
10:04:22 * bring assumes you want to go from somewhere in england
10:05:11 <Heffalump> yes
10:06:03 <Heffalump> what would the accomodation options and likely costs be?
10:06:22 <bring> you are talkng about coming to eurohaskell, right?
10:06:35 <Heffalump> yes - /me is not hugely likely to go, but the gem of the idea is starting to go round in my head.
10:06:59 <bring> hmm, never really had to find out for myself, I'll have a look around
10:07:17 <Heffalump> don't worry just for me, but it might be useful information for the wiki page in general
10:07:44 <bring> yeah, I was just thinking about that today
10:08:11 <Lunar^> Why do I am so doomed ? There's no Ryanair flight from Paris for both Gothenburg and Lubeck 
10:08:42 <bring> there might be other budget airlines flying gothenburg - paris
10:09:22 <Lunar^> I'm searching for that
10:10:17 <Heffalump> moo!
10:10:58 <kosmikus> Lunar^: maybe you can go to Luebeck via London ;)
10:14:02 <Lunar^> kosmikus|away: Sure I can, but Paris-London is not that cheap
10:15:29 * Heffalump likes trains
10:16:00 <bring> hmm, the student housing foundation rents a room with 4 beds for 1 690:- / 3 days
10:16:11 <bring> 3 nights rather
10:16:16 <Heffalump> 1690 euros?
10:16:20 <bring> SEK
10:16:27 <Heffalump> oh yes, you're another sane country
10:17:07 <Heffalump> that's pretty cheap.
10:17:12 <Lunar^> http://z3u.com/ep2004/RoomSharingPage
10:17:34 <bring> that's 181,19 EUR
10:18:39 <bring> Lunar^: yeah, that's the same place I was talking about
10:18:50 <bring> shapr said something about staying there
10:19:30 <Lunar^> bring: I thinking about that too
10:19:41 <Lunar^> Maybe we could get a room full of haskellers :)
10:20:18 <bring> I rent my apartment from SGS, their website says I can get a discount
10:21:28 <Lunar^> How is the weather at that time of year ? Maybe it'll be cheaper to do camping
10:22:08 <bring> the weather is normally pretty good around then, rain is not uncommon though
10:24:26 <bring> would you guys bring you own computers?
10:24:49 <bring> or should we try to get accounts for you?
10:25:12 <Lunar^> How can I say that... I hardely move anywhere without my laptop
10:25:26 <bring> :)
10:25:30 <bring> ok, good
10:25:36 <Lunar^> Dunno about shapr though
10:25:58 <Heffalump> I would bring a computer if I came.
10:26:09 <bring> yeah, shapr said he probably wouldn't bring a computer
10:27:41 <bring> ok, great
10:28:58 <Heffalump> the haskell wiki should get a favicon.ico
10:30:48 <bring> or all of haskell.org
10:30:54 <bring> hi stepcut
10:30:54 <Heffalump> yeah
10:31:30 <stepcut> hey bring!
10:32:04 <bring> Heffalump: let me read your mind, hmm, ..., you are thinking of a greek letter, it's a ... theta?
10:32:45 <Heffalump> absolutely.
10:37:34 <Lunar^> lol
11:55:57 <heatsink> Is there a default implementation of >> in terms of >>= ?
11:57:36 <bring> yes
11:57:40 <bring> m >> k  =  m >>= \_ -> k
11:58:22 <heatsink> okay
11:59:18 <heatsink> BTW is the use of _ to mean "anything" just a convention, or is _ a specially recognized symbol?
11:59:56 <stepcut> heatsink: it must be specially recognized, because you can use it more than once ...
12:00:07 <stepcut> myfunc _ _ _ something = putStrLn something
12:00:30 <heatsink> hm, interesting
12:03:34 <Marvin--> yeah, it's called a wildcard pattern
12:47:04 <heatsink> I think I'm finally starting to understand monads... this manual expression reduction helps a lot...
12:49:44 <eixei> bye everybody
13:32:15 <shapr> foo!
13:32:46 <Marvin--> bar
13:35:47 <andersca> baz
13:39:15 <bring> shapr: are you staying at SGS Veckobostäder for EuroPython / EuroHaskell?
13:40:32 <bring> HeffaLump was asking about accommodation, so I put a link to them in the wiki
13:41:21 <shapr> yes, we'll be there
13:44:18 <blackdog> ozone: notice the all-important word "when", and consider the implications of the null set
13:49:08 <Cale> lookup :: (Eq a) => a -> [(a,b)] -> Maybe b -- is this really the best ordering of the arguments? Wouldn't partial applications usually go the other way?
13:51:03 <shapr> @type lookup
13:51:04 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
13:51:15 <shapr> I'd think so
13:51:19 <monotonom> Yeah
13:51:19 <shapr> but there's always flip
13:52:16 <Cale> yeah, I suppose there is
13:52:44 <shapr> of course, I sometimes wish for flip3 or rotate3 or something
13:52:48 <shapr> Joy has those
13:53:02 <shapr> rollup, rolldown, and something
13:54:05 <Cale> it would also be nice to just be able to stick blanks into parameter spots: i.e. map (f _ blah) xs, would be equivalent to map (\x -> f x blah) xs
13:54:37 <Marvin--> Yeah, dennisb has talked about that too, iirc
13:54:51 <Cale> it seems that many of the lambdas that I use tend to not actually use the variable nontrivially.
13:55:02 <Lor> cale, what would be the scope of the _ ?
13:56:01 <Cale> f _ would be syntactic sugar for (\x -> f x)
13:56:23 <Marvin--> the problem is when you nest them
13:56:41 <Marvin--> (f _ (g _) _)   what does that mean?
13:57:44 <Cale> (\y -> (\x -> f x (\z -> g z)) y)
13:58:38 <Lor> Is that supposed to be obvious?
13:58:38 <Marvin--> and  f _ $ g _  ?
13:58:38 <monotonom> Why not (\y x z -> f x (g z) y) ?
13:58:56 <monotonom> (I think that's Marvin--'s point)
13:59:08 <Cale> (
13:59:12 <Marvin--> yes, my point is that it's very non-obvious
13:59:18 <Cale> hmm...
13:59:23 <Marvin--> and when you don't have parentheses it becomes even more complicated
13:59:46 <Lor> Something like that _would_ be attractive, though.
13:59:50 <shapr> discussion on the Joy list said "what's obvious about rollup, rolldown, and etc?"
14:00:02 <Cale> Is there a more obvious meaning?
14:00:14 <Cale> (to assign an expression like that)
14:00:15 <shapr> the response was interesting, Billy Tankesley suggested swap pattern
14:00:37 <Lor> To me the "most" obvious (not very, though) would be \x y -> f x (\z -> g z) y)
14:00:38 <shapr> abcdef -> defabc
14:00:58 <Lor> Ie. the scope of a _ is the innermost enclosing parentheses.
14:01:17 <Cale> I suppose that would work as well.
14:01:27 <Lor> And several _'s are distinct parameters.
14:01:33 <Lor> When they are at the same level, that is.
14:01:45 <shapr> could you use flip together with "(.).(.)" to do it?
14:01:47 <Marvin--> you could also imagine it being strictly left-to-right or right-to-left regardless of depth
14:01:58 <Marvin--> \x y z -> f x (g y) z
14:02:03 <shapr> lesse, what's a three arg function that fits into @type
14:03:10 <monotonom> @foldl
14:03:10 <monotonom> @type foldl
14:03:10 <lambdabot> Sorry, I don't know the command "foldl", try "lambdabot: @listcommands"
14:03:10 <lambdabot> foldl :: (a -> b -> a) -> a -> [b] -> a
14:03:51 <shapr> @type flip foldl 
14:03:52 <lambdabot> flip foldl :: a -> (a -> b -> a) -> [b] -> a
14:04:04 <shapr> interesting
14:04:12 <Cale> hm?
14:04:26 <Cale> isn't that as expected?
14:04:36 <shapr> @type foldl (.).(.)
14:04:37 <lambdabot> foldl (.) . (.) :: (a -> b) -> [(c -> a) -> c -> a] -> (c -> a) -> c ->
14:04:37 <lambdabot> b
14:05:08 <Lor> Err...
14:05:40 * shapr tries to figure out where this is all going
14:07:01 <shapr> @type flip (foldl (.).(.))
14:07:01 <Marvin--> @type foldl ((.).(.))
14:07:01 <lambdabot> flip (foldl (.) . (.)) :: [(a -> b) -> a -> b] -> (b -> c) -> (a -> b) 
14:07:01 <lambdabot> > a -> c
14:07:13 <Lor> Is there some point to this?
14:07:13 <Marvin--> heh
14:07:23 <shapr> possibly
14:08:36 <shapr> (.) stick together two functions with single args into a single one
14:08:45 <shapr> (.).(.) does it with two argument functions
14:09:39 <Marvin--> shapr: yes and no, one one-argument function and one two-argument function
14:09:55 <shapr> ?
14:10:00 <Cale> (\x y z -> ((.).(.)) flip flip f x y z) = f z x y
14:10:41 <shapr> ah, that looks nice
14:10:41 <Lor> @type ((.) . (.))
14:10:44 <lambdabot> (.) . (.) :: (a -> b) -> (c -> d -> a) -> c -> d -> b
14:12:12 <Cale> ((.).(.)) flip id f 1 2 3 = f 1 3 2
14:24:01 <shapr> how expensive are FPGAs?
14:26:08 <wagle> use the google, luke...
14:26:23 <shapr> I am, I am
14:26:37 * wagle also wants the answer to that question, so is following his own advice
14:26:42 <shapr> :-)
14:26:57 <shapr> I was just thinking... if Haskell is so good at writing compilers, and FPGAs are available...
14:27:25 <shapr> I wonder if there are any PCI cards that a few FPGAs on them that I can reprogram easily from Linux
14:27:41 <wagle> great minds
14:28:45 <shapr> eek
14:28:50 <Igloo> Place+route is computationally, though
14:29:00 <shapr> huh?
14:29:08 <Igloo> And I think NP hard or complete
14:29:21 <Igloo> Deciding which bits of ahrdware go where and what route the wires between them take
14:29:24 <shapr> oh
14:29:43 <shapr> is that how FPGAs take input?
14:30:42 <Igloo> It's the last(ish?) phase of compiling a program to hardware
14:31:34 <shapr> seems like the first task would be to write a place+route program for the FPGAs
14:31:35 <Igloo> Oh, did you see the stuff about building hardware compositionally though?
14:31:53 <Igloo> I can't remember if it was at ICFP/HW or elsewhere i see a talk on it. It might have been FoP.
14:32:02 <shapr> I've seen some stuff about relating to Hawk and Lava
14:33:21 <Igloo> "Satnam Singh: Functional Hardware Description in Lava" on http://web.comlab.ox.ac.uk/oucl/research/areas/ap/fop/info.html is probably what I'm thinking of
14:33:44 <Igloo> Oh, the link isn't very interesting
14:36:42 <wagle> haha..  the first question to ask is "how many logic elements do i want?"
14:41:41 <wagle> shapr: any luck pricing it out?
14:42:01 <shapr> I don't see any PCI cards
14:43:50 <wagle> i'm trying to wring price info from http://www.altera.com/products/devices/cyclone/cyc-index.jsp
14:47:11 <wagle> http://www.altera.com/products/devkits/kit-dev_platforms.jsp
14:51:33 <wagle> probably cheaper to buy without (all of) the software
14:53:20 <wagle> i might try the the $99 gizmo just to get my feet wet...
14:53:43 <ecraven> that's not an fpga, but a cpld
14:54:14 <wagle> awww
14:54:26 <ecraven> not really sure about the difference though.. <*G*>
14:54:43 <ecraven> the cheapest fpga i saw was 249 i think.. but there's cheaper stuff out there..
14:54:48 <ecraven> did you check www.xess.com
14:54:52 <shapr> so, Singh worked at xilinx, and xilinx is one of the biggest FPGA makers. Does that mean Lava compiles into something I can stick into a Xilinx FPGA?
14:54:57 <shapr> yes, it does compile to something that goes into an FPGA
14:55:03 <shapr> and Lava has place combinators
15:08:38 <shapr> I can't find a released version of Lava anywhere
15:09:33 <wagle> even at chalmers?
15:09:58 <wagle> oh
15:10:59 <andersca> shapr: ah, I couldn't find that either :/
15:11:16 <wagle> # The Lava package. NOTE: We are currently investigating licensing issues, so Lava is temporarily unavailable. Please come back later!
15:48:25 <heatsink> In a pattern match, can I match either of two patterns?
15:48:39 <Igloo> No
15:48:44 <heatsink> case x of  'A' OR 'B' -> ..
15:48:47 <heatsink> okay
15:49:36 <Heffalump> but you can say case x of 'A' -> foo \n 'B' -> foo \n where foo = ...
15:49:51 <Heffalump> so what you want would just be a small bit of syntactic sugar
15:50:00 <heatsink> yeah
15:50:01 <Igloo> Not if you're binding things with your patterns
15:50:20 <Heffalump> yes, then you would have to pass the things as parameters to foo too
15:50:23 * heatsink discovers that haskell-mode doesn't indent case statements properly
15:50:30 <Heffalump> it doesn't do anything _properly_
15:50:44 <Heffalump> but it's better than nothing
15:51:16 <heatsink> It's indenting each line to two columns after the previous line
15:53:09 <heatsink> Oh, I see what it is doing now
15:53:34 <heatsink> It thinks my '(' is an opening paren, and it wants to indent the next line to be inside that parenthesis
15:53:57 <heatsink> But it's really a character constant
16:08:34 <stepcut> heatsink: yeah, I have a patch for that (case statements), maybe someday I will become the official maintainer
16:08:57 <heatsink> stepcut: Is it online?
16:09:19 <stepcut> no, and its only on one of my machines, so even I don't get correct tab completion all the time :)
16:09:29 <heatsink> :)
16:39:13 <Hetrish> what emacs mode do you use with haskell files?
16:39:16 <Hetrish> haskell mode?
16:42:44 <mattam> yep
16:44:55 <Hetrish> k thanks!
16:45:00 <Hetrish> wait
16:45:05 <Hetrish> wrong question lol
16:45:11 <Hetrish> that was too easy!
16:45:22 <Hetrish> what emacs mode do you use with *happy* files?
16:45:25 <mattam> yep :)
16:45:36 <Hetrish> also haskell
16:45:37 <Hetrish> ?
16:46:13 <mattam> i haven't edited happy files but i suppose they're somehow like yacc ones ?
16:47:50 <Hetrish> yeap
16:47:55 <Hetrish> but with haskell code
16:48:01 <Hetrish> I used C mode with yacc...
16:55:35 <stepcut> hrm, I just busted the color laser printer, I hope no one wanted to use it...
17:01:04 <Shu> can anyone help me please? ^^
17:01:11 <Pseudonym> You are beyond help.
17:01:25 * Smerdyakov starts filling out the coroner's report on Sh.
17:01:26 <Pseudonym> :-)
17:01:39 <Shu> =(
17:01:44 <Pseudonym> Best just to ask your question.
17:02:06 <Shu> Ah, it was quiet, so..
17:02:41 <Riastradh> It's quiet because no one has a question to answer.
17:03:02 <Shu> Well I have a bunch :P
17:03:09 <Riastradh> Then ask them!
17:03:14 <Shu> Alrighty
17:03:58 <Shu> I need a way to generate an infinite list of 2^n values, using circular list style and list comprehension.
17:04:57 <Heffalump> why?
17:05:26 <Smerdyakov> An infinite list of 2^n values?
17:05:31 <Shu> This works, but its not what I need > powersOf2 = iterate (\n -> n * 2) 1.0
17:05:32 <Smerdyakov> What do you mean by that?
17:05:53 <Heffalump> ah, that.
17:06:04 <Heffalump> what do you mean by "circular list style"?
17:06:28 <Shu> i mean where it starts with 1:
17:06:32 <Shu> and then has the tail in it
17:06:43 <Shu> like it uses itself in the definition
17:07:03 <Igloo> Do you mean you want to write this same thing in 2 different ways?
17:07:08 <Shu> ya
17:07:45 <Heffalump> why do you need this?
17:07:49 <Hetrish> hmmm isn't he using tail recursion by using iterate? :)
17:08:02 <Shu> i'm doing homework ^^
17:08:09 <Shu> and i suck
17:08:21 * Heffalump suggests you look at the definition of iterate
17:08:28 <Heffalump> and try unfolding that into your definition above
17:08:51 <Shu> ok
17:08:52 <Heffalump> and then see if you can change your definition to use a list comprehension
17:09:16 <Heffalump> oh, and use 1, not 1.0, doing it with an integral type is much nicer than doing it with Float
17:09:22 <Heffalump> s/Float/a real-valued type/
17:09:43 <Hetrish> Shu: we don't care if you suck or not... 
17:09:53 <Hetrish> Shu: unless your a good looking college girl and that homework is really important to you that is...
17:10:04 <Shu> lol
17:10:09 <Hetrish> otherwise we'll just give you some tips
17:10:11 <Pseudonym> Hetrish: Difficult to do over IRC.
17:10:24 <Heffalump> the hypothetical she might live nearby
17:10:31 <Hetrish> yeap
17:10:37 <Pseudonym> So that's another precondition.
17:10:46 <Hetrish> haskell is being taught more and more...
17:11:38 <Smerdyakov> Hetrish, your name is funny to say. I shouted it out the window and everyone was afraid.
17:15:22 <Pseudonym> It sounds like an illicit pharmaceutical.
17:24:53 <Shu> I think I got it, can someone check?
17:24:56 <Shu> > powersOf2CL = map (\n -> n * 2) [0 ..]
17:25:15 <Pseudonym> What do you want us to check?
17:25:17 <Shu> is this using list comprehension?
17:25:24 <Pseudonym> No, it's not.
17:25:27 <Shu> hmm.. =/
17:25:37 <Pseudonym> Did you try running it?
17:25:43 <Shu> yes it gives a good answer..
17:25:55 <Smerdyakov> How do you check the answer?
17:26:08 <Shu> oh, i guess it doesn't.
17:26:11 <Hetrish> Smerdyakov: yeap, I know, and I cannot really explain it :)
17:26:16 <Shu> this gives me different :P
17:26:35 <Hetrish> Pseudonym: lol!
17:26:36 <Shu> i was using take 10 to check
17:27:01 <Shu> lemme try again >.<
17:27:46 <Pseudonym> Hey, man, where can a guy score some hetrish?
17:28:03 <Pseudonym> Actually, even more serious is how drug companies sounds like illegal drugs.
17:28:16 <Hetrish> lol!
17:28:21 <Pseudonym> Yeah, I was doing quintiles.
17:28:27 <Pseudonym> Need to score some GSK.
17:28:41 <Pseudonym> Very odd.
17:28:47 * Hetrish doesn't know much about drugs (either legal or illegal
17:28:48 <Hetrish> )
17:28:55 <Pseudonym> I was caught with some pfizers.
17:29:03 * Hetrish needs to get some sleep
17:29:10 <Pseudonym> Yes.  Sleep.
17:29:32 <Hetrish> yeap 1:30
17:29:49 <Smerdyakov> It is not time for Pseudonym to sleep.
17:29:51 <Hetrish> bye!
17:30:17 <Pseudonym> No it is not.
17:30:24 <Pseudonym> Well, kinda.
17:30:30 <Pseudonym> It's time to be getting up about now.
17:30:49 <Pseudonym> Speaking of which, free food.  Must go.
17:42:53 <Shu> humm
17:43:13 <Shu> > powersOf2CL = 1: 2: [ 2^x | x <- [2 ..] ]
17:43:15 <Shu> this ?
17:44:05 <Igloo> Why do you handle 1 and 2 specially?
17:44:18 <Shu> ok like
17:44:40 <Shu> they say you need to use "circular list", and this is what they show as an example
17:44:47 <Shu> > factseq = 1 : 1 : [ f | f <- zipWith (*) (tail factseq) [2 ..] ]
17:45:03 <Smerdyakov> You think that what you wrote is a circular list?
17:45:18 <Shu> no, i think its just list comprehension
17:45:25 <Shu> i need to figure out how to make it circular
17:47:24 <Shu> like that factorial one
17:51:28 <Cale> @yow
17:51:29 <lambdabot> If I had a Q-TIP, I could prevent th'collapse of NEGOTIATIONS!!
18:02:03 * Heffalump suggests you think about how you can generate the powers of 2 starting at 2 given the powers of 2 starting at 1
18:02:24 <SamB> circularize l = x where x = l ++ x -- I think this will do it
18:02:45 * Smerdyakov smacs SamB.
18:02:53 <Smerdyakov> Get with the program. That's not what he's asking about. :P
18:03:54 <Shu> that was cool though :P
18:04:52 <SamB> Smerdyakov: hmm. this is reminding me of #slate. not good. however, it is unlikely that you are as easily angered as water is.
18:05:22 <Smerdyakov> water is Number One King Jerk.
18:05:28 <Shu> > powersOf2 = map (2^) [0 ..]
18:05:32 <Shu> humm
18:05:41 <Shu> thats still not circular is it >.<
18:06:05 <Shu> why do these have to take like an hour :P
18:08:14 <Heffalump> the length of the shortest right-hand side that satisfies your criteria is 11 characters, plus the length of the name you choose.
18:08:59 <SamB> naturalNumbers = 1:(map (1+) naturalNumbers) -- this the idea?
18:09:30 <Heffalump> yes, but this is homework, so don't give the answer away
18:09:43 <Shu> yes
18:09:50 <Heffalump> and he has to use a list comprehension, not a map
18:10:01 <Shu> i dont have to
18:10:09 <shapr> yay, I beat Zope into submission.
18:10:10 <Heffalump> oh, ok
18:10:11 <Shu> i could use a map
18:10:15 <SamB> Heffalump: I managed to restrain myself from giving away the answer ;-)
18:10:28 <Shu> maybe that gives it away though
18:10:29 <Shu> lemme try
18:11:24 <Igloo> A mere 9 plus name length will suffice then  :-)
18:12:24 <SamB> Shu: you at least have to think to understand the analogy, this way
18:13:26 <Shu> ya but i got something wierd
18:13:44 <SamB> Shu: what did you try?
18:13:45 <Shu> 2,4,16,65536
18:13:57 <Shu> > powersOf2CL = 1:(map (2^) powersOf2CL)
18:14:29 <Shu> i try more
18:14:49 <SamB> think about how that expands
18:15:22 <Shu> aj
18:15:23 <Shu> ah
18:15:26 <Shu> 2 to the 16th :P
18:15:46 <SamB> [2, 2^2, 2^(2^2), 2^(2^(2^2)), ...]
18:15:49 <Shu> of course that wouldnt work
18:16:47 <SamB> there is a very simple problem with this...
18:16:56 <Shu> lol i know
18:17:13 <SamB> hmm, is lol permitted here?
18:17:24 <Shu> maybe not use map
18:18:24 <Shu> why cant i do this??
18:18:27 <Shu> > powersOf2CL = 1:(zipWith (2^) (tail powersOf2CL) [2..])
18:19:02 <Shu> it lets me do it with just (^)
18:19:10 <Shu> or (*)
18:19:26 <Igloo> (^) and (*) are 2-argument functions
18:19:31 <Igloo> (2^) is a one-argument function
18:19:45 <Shu> but i need the 2^
18:19:46 <Igloo> How do you zip 2 lists with a one-argument function?
18:20:04 <Shu> yeah
18:20:06 <Shu> i guess so
18:38:12 <Shuu> omg
18:38:17 <Shuu> > powersOf2CL = 1 : [ 2*x | x <- powersOf2CL] ???
18:38:58 <Shuu> probably not
18:40:00 <Pseudonym> Acually, yes.  It works.
18:40:06 <Shuu> is it circular?
18:40:13 <Pseudonym> What is "circular"?
18:40:23 <Shuu> circular list
18:40:40 <Pseudonym> It works the same way as your fibonacci example, if that's what you meant.
18:40:46 <Shuu> Yeah.
18:40:55 <Pseudonym> I wouldn't call that a "circular list".
18:41:56 <Shuu> I thought it had to use the tail somehow
18:42:04 <Shuu> and a list like [2..]
18:42:21 <Shuu> for it to be considered a circular list
18:42:27 <Pseudonym> I would call a "circular list" something like this:
18:42:30 <Pseudonym> twos = 2 : twos
18:42:37 <Pseudonym> Which gets turned into a graph with a cycle.
18:42:45 <Shuu> That's how I need to solve this problem.
18:44:32 <Heffalump> that's not possible
18:44:35 <Shuu> Guess I'll just try more..
18:44:39 <Heffalump> the answer just *isn't* a circular list
18:44:45 <Heffalump> s/answer/result/
18:44:53 <Pseudonym> Exactly.
18:44:56 <Heffalump> the answer you gave above is the one I was thinking of
18:45:04 <Pseudonym> Me too, though I used map.
18:45:04 <Shuu> oh really?
18:45:17 <Heffalump> I didn't purely because I thought he had to use a list comprehension
18:45:31 <Pseudonym> I wasn't paying attention on that point.
18:45:32 <Shuu> Be right back.  Thanks for the help.
18:48:27 <Heffalump> anyway, the version using iterate is clearly more efficient
18:51:05 <Pseudonym> This is homework.  Who cares about efficiency?
18:53:16 <Heffalump> well, indeed
20:06:00 <Shuu> heh
20:06:09 <Shuu> after many hours
20:06:09 <Shuu> i finally think i have got it
20:06:40 <Shuu> > powersOf2CL = 1:2:[2*x|x <- tail (powersOf2CL)]
20:08:30 <Cale> that's the same as powersOf2CL = 1:[2*x | x <- powersOf2CL]
20:09:39 <Shuu> but this computes each element from the preceding one
20:09:51 <Shuu> which is what was asked
20:10:00 <Cale> so does the other, does it not?
20:10:06 <Shuu> i dunno
20:10:12 <Shuu> im a haskell n00b
20:10:23 <Shuu> it takes me hours to solve a problem like this
20:10:40 <Cale> the last thing I said is the same as powersOf2CL = 1 : map (2*) powersOf2CL
20:11:02 <Shuu> now i have a new one
20:11:21 <Cale> think about what happens when you ask for the second element of the list
20:11:26 <Cale> or the third
20:11:33 <Cale> how would it be computed?
20:12:04 <Shuu> 2* that element.
20:12:25 <Cale> 2* the first element, in the second element's case
20:12:36 <Shuu> Ya, I see that now.
20:12:39 <Shuu> You're right.
20:12:47 <Shuu> Wanna look at a new one?
20:12:50 <Cale> sure
20:13:38 <Shuu> i need a function that can compute e^x
20:13:50 <Shuu> using this expansion
20:13:51 <Shuu> e^x = 1 + x + (x^2 / 2!) + ( x^3 / 3!) + ... + ( x^n / n!) + ...
20:13:54 <Cale> okay
20:13:55 <skew> how about iterate (2*) 1?
20:14:03 <skew> for the powers of two
20:14:19 <Cale> skew: sure
20:14:24 <Shuu> ya that works too
20:14:40 <Cale> Shuu: think about a function which computes the kth term of that series
20:14:40 <Shuu> but i was trying to do it with list comprehension + infinite list
20:15:19 <Shuu> powersOf k / fact k
20:15:20 <Shuu> i guess
20:15:41 <Cale> but those are both lists, so...
20:15:45 <skew> zipWith
20:15:58 <Cale> or at least, er...
20:16:32 <Cale> well, that's not the kth term, but it would certainly be more direct if you have functions to compute those already
20:16:38 <Shuu> i do
20:16:43 <Cale> it would be powersOf x / fact
20:16:48 <Shuu> > powersOf x = iterate (\n -> n * x) 1.0
20:16:51 <Shuu> > fact  = 1.0:zipWith (*) [1.. ] fact
20:16:52 <Cale> where fact is the list of factorials
20:16:55 <skew> you can't exactly compute one term in terms of the next
20:17:55 <skew> but you can use the last one, if you know the number of the new term for making the factorial
20:18:19 <Shuu> this one doesn't have to use any special thing
20:18:21 <Shuu> just has to work
20:18:35 <Shuu> actually
20:18:37 <skew> and use that series, right?
20:18:39 <Shuu> can it work with "where"
20:18:45 <Shuu> it gives a hint to use where.
20:18:53 <skew> hmm
20:19:35 <skew> I guess they might want you to define a function for the n-th term with it
20:19:43 <skew> it's just like let.
20:19:48 <Cale> I did it in one line, though, sure a where clause might make it clearer
20:20:13 <Cale> how many terms are you supposed to use?
20:20:35 <Shuu> it says a where clause is the first answer
20:20:40 <Cale> (of course, that's an easy thing to change)
20:20:42 <Shuu> and that a one-liner is more efficient for the 2nd answer
20:20:46 <Shuu> you probably have it Cale
20:21:11 <Shuu> terms?
20:22:25 <Cale> exp n x = sum $ take n $ zipWith (/) (powersOf x) fact
20:22:33 <Cale> is what I wrote
20:22:38 <Shuu> what is that dollar sign do?
20:22:50 <Cale> f $ x = f x
20:22:57 <Cale> but it has low precedence
20:23:07 <Cale> so it's like it wraps things in brackets
20:23:15 <Shuu> can you do it with just exp x = ?
20:23:20 <Cale> sure
20:23:25 <Cale> but you'll need to pick an n
20:23:42 <Shuu> What would n do?
20:23:51 <Cale> consider what you're trying to calculate
20:23:56 <skew> Shuu: do you want a list of successive approximations instead?
20:24:13 <Shuu> oh
20:24:27 <Shuu> e = 2.718 doesn't it?
20:24:35 <Cale> about that, yeah
20:25:18 <Shuu> I don't really understand
20:25:28 <Shuu> why exp n x
20:25:30 <Shuu> and not exp x
20:25:51 <Cale> well, think about the problem a bit more than
20:25:52 <Cale> then*
20:26:09 <Cale> it says to compute exp x using the formula...
20:26:33 <Cale> exp x = 1 + x + (x^2 / 2!) + ( x^3 / 3!) + ... + ( x^n / n!) + ...
20:26:48 <Shuu> yes
20:26:49 <Cale> but this sum has infinitely many terms in it - we can't compute them all
20:27:07 <Shuu> Can we disregard all of them smaller than 0.000001?
20:27:13 <Cale> luckily for us, the terms get smaller and smaller given a particular x
20:27:27 <Cale> you could, yeah
20:27:43 <Cale> It's probably just as easy to pick a sufficient n and stick with it
20:27:50 <Shuu> then, thats the n?
20:27:56 <Shuu> or would the n be the # of times.
20:27:59 <Cale> indeed
20:28:17 <Cale> n is the place where we chop the series off
20:28:46 <Shuu> then how would we do it?
20:29:42 <Shuu> if i want to find e^3.5 say
20:29:50 <Shuu> i type... exp something 3.5
20:30:26 <Cale> right - if you want to do it by hand, you can choose larger and larger n until it becomes roughly stable
20:30:28 <Shuu> exp 100 3.5
20:30:31 <Shuu> and it gets more accurate
20:30:51 <Shuu> oh i see
20:30:56 <Cale> it should become stable quickly
20:31:10 <Shuu> so you used take n
20:31:20 <Shuu> if i wanted to set that limit of 0.000001 i have to used takeWhile?
20:31:44 <Cale> that might be an option
20:35:42 <Shuu> > e2x x = sum $ takeWhile (> 0.00001) $ zipWith (/) (powersOf x) fact
20:35:45 <Shuu> this seems to work
20:35:53 <Shuu> now how could i round this down to like 3 decimal places?
20:36:56 <Shuu> round?
20:37:30 <Cale> sure.
20:37:47 <Cale> together with something that pushes the digits back and forth a bit :)
20:39:29 <Cale> note that takeWhile (>0.0) also works :)
20:40:02 <Cale> it will simply take as many terms as the machine precision will assign nonzero values to. :)
20:40:19 <Shuu> alright
20:40:27 <Shuu> now we have this one
20:40:30 <Shuu> factors 12 = [1,2,3,4,6,12]
20:41:01 <Cale> okay, that should be pretty quick with a list comprehension
20:41:07 <Shuu> ok lemme try
20:41:22 <Cale> what conditions do factors of a number n satisfy?
20:41:57 <Shuu> that x 'mod' 12  = 0 ?
20:42:20 <Cale> so 2 `mod` 12 = 0?
20:42:35 <Cale> (and note that they're backticks)
20:42:44 <Shuu> oh
20:43:00 <Cale> but really, think about that a sec
20:43:01 <Shuu> 12 `mod` 2 = 0
20:43:03 <Cale> right
21:23:26 <Shuu> Cale
21:23:28 <Shuu> is this correct?
21:23:34 <Shuu> > factors x = [ z | z <- [1..x], x `mod` z == 0]
21:26:39 <anduril1> yes
21:26:48 <anduril1> oops, I'm not Cale
21:27:52 <Shuu> hey anduril
21:27:56 <Shuu> wanna help with one?
21:28:08 <anduril1> sure
21:29:00 <Smerdyakov> I think the ethics of "helping with one" are questionable....
21:29:14 <anduril1> oh wait
21:29:26 <anduril1> help as in assignment?
21:29:44 <Shuu> im doing problems
21:29:59 <Shuu> i have a test soon
21:32:44 <Shuu> > beginsWith 't' ["the","only","two","only","words","are","'the and two'"]
21:32:48 <Shuu> " the two"
21:33:05 <skew> that's pretty wierd
21:33:13 <skew> are you sure that isn't supposed to be "the two"?
21:33:26 <Shuu> the answer?
21:33:29 <skew> yeah
21:33:33 <Shuu> yes
21:33:34 <Shuu> i made a typo
21:34:01 <skew> what have you tried?
21:34:36 <Shuu> im just starting on this one actually
21:34:44 <Pseudonym> Well why don't you try it.
21:34:50 <Pseudonym> And let us know how you go.
21:35:22 <Smerdyakov> Pseudonym, candid question: did you really mean "go," or did you mean "do"?
21:35:35 <Pseudonym> I meant "go".  It's an idiom.
21:35:51 <anduril1> "how it goes" perhaps?
21:35:59 <Smerdyakov> Maybe in backwater parts of the world.
21:36:05 <skew> "how it go"?
21:36:15 <Pseudonym> Google the phrase "how you go" and you'll see examples.
21:36:24 <Pseudonym> I believe it has the force of idiom behind it.
21:36:25 <Smerdyakov> Probably all .au.
21:36:44 <Pseudonym> The British do say "mind how you go".
21:40:47 <Shuu> can i use fst on a string?
21:40:59 <skew> Shuu: what istring?
21:41:07 <skew> er, what is String?
21:41:10 <Shuu> can i use fst to grab the 't' from "the"
21:41:18 <Pseudonym> Shuu: Why don't you try it and see?
21:41:23 <anduril1> shuu: fst works on tuples only
21:41:28 <Shuu> head?
21:41:32 <Pseudonym> Actually, PAIRS only.
21:41:34 <skew> do you have an interpreter around?
21:41:42 <anduril1> oops
21:41:43 <Shuu> yes
21:42:12 <Shuu> so head maybe..
21:42:26 <anduril1> the 't' in tuples makes me think of two
21:42:34 <anduril1> we should call them nples
21:42:47 <Pseudonym> Well, they're n-tuples.
22:41:46 <Shuu> Hmm...
22:41:49 <Shuu> I think I may have it..
22:42:20 <skew> what have you got?
22:42:58 <Shuu> > beginsWith firstChar listOfWords = concat ([" " ++ z | z <- listOfWords, firstChar == head(z)])
22:44:33 <skew> that's not quite what you want, is it?
22:44:38 <skew> you have the filtering part down
22:44:59 <skew> but I thought you didn't want the leading space in " one onother"
22:51:58 <Shuu> actually
22:52:15 <Shuu> it wasnt a typo because they show you what the output should look like
22:52:21 <Shuu> and it has the leading space
22:52:25 <Shuu> besides, isnt that necessary
22:52:34 <Shuu> since you need a space at the end if not the beginning
22:54:54 <Shuu> Ok, next one!
22:55:28 <Pseudonym> What's necessary is what the spec says is necessary.
22:55:30 <Pseudonym> No more, no less.
22:55:38 <Shuu> > occurrences [5,2,3,2,4,3,2,5]
22:55:41 <Shuu> [(5,2), (2,3), (3,2), (4,1)]
23:15:28 <Shuu> hmm
23:15:38 <Shuu> its visiting everything more than once though!
23:15:49 <Shuu> can someone explain what i'm doing wrong?
23:15:57 <Shuu> > occurrences8 xs = [(x, howMany x (xs) ) | x <- xs ]
23:16:06 <Shuu> > howMany x xs = length [z | z <- xs, z == x]
23:16:48 <Pseudonym> Do you understand why you get the answer that you do?
23:17:16 <Shuu> yes im getting doubles as they appear because im visiting 5 more than once.. obviously
23:17:25 <Shuu> but how can i make it so that it only writes down (5,2) once?
23:17:54 <Pseudonym> By ensuring that you visit only once?
23:28:58 <Shuu> > occurrences8 xs = [(x, howMany x (xs) ) | x <- nub xs]
23:28:59 <Shuu> ??
23:29:25 <Shuu> hmm it works
23:29:26 <Shuu> ^^
23:29:32 <Pseudonym> That works.
23:29:32 <Shuu> thanks Pseudo
23:29:36 <Pseudonym> No problem.
23:30:17 <Shuu> could you show me a way how to do this with recursion
23:31:00 <Pseudonym> I'll give you a clue.
23:31:11 <Pseudonym> There's a very common recursion pattern which looks like this:
23:31:49 <Pseudonym> Hang on, let me find the precise definition.
23:32:11 <Pseudonym> Ah, here we are.
23:32:15 <Pseudonym> foo [] = []
23:32:26 <Pseudonym> foo xs = f xs : foo (g xs)
23:32:29 <Pseudonym> For some f and g.
23:32:38 <Pseudonym> This is called an "anamorphism", but that's not important.
23:33:04 <Pseudonym> You might like to try finding functions f and g which will do this.
23:33:09 <Pseudonym> f you already know
23:33:10 <Shuu> I see.
23:34:11 <Pseudonym> f (x:xs) = howMany x xs
23:34:20 <Pseudonym> Think about g.
23:35:20 <Pseudonym> What do you want it to do?
23:37:08 <Shuu> i want it to return a pair
23:37:17 <Pseudonym> Oh, yes.
23:37:18 <Pseudonym> Sorry.
23:37:24 <Pseudonym> f (x:xs) = (x, howMany x xs)
23:37:27 <Pseudonym> Duh, you're right.
23:40:34 <Pseudonym> To recap, you have:
23:40:36 <Pseudonym> occurrences [] = []
23:40:49 <Pseudonym> occurrences (x:xs) = (x, howMany x xs) : occurrences (g (x:xs))
23:40:51 <Pseudonym> for some g.
23:41:07 <Shuu> Right..
23:41:25 <Shuu> well i have nub there..
23:41:31 <Shuu> is that wrong?
23:41:42 <Pseudonym> No, you don't have nub there.
23:41:48 <Shuu> hmm
23:41:55 <Pseudonym> Your nub is being applied to the _original_ list.
23:42:07 <Pseudonym> Here you want to apply something to the list of items still left.
23:42:12 <Pseudonym> They're different lists.
23:42:22 <Pseudonym> Do you see that?
23:42:29 <Shuu> Yeah.
23:42:31 <Shuu> The tail.
23:43:13 <Pseudonym> Let's think concretely.
23:43:14 <Shuu> So that first part is saying the answer for the head
23:43:17 <Pseudonym> occurrences [5,2,3,2,4,3,2,5]
23:43:18 <Shuu> concatenate that with
23:43:26 <Shuu> the answer for the head of the tail
23:43:32 <Pseudonym> What list do you _want_ to apply occurrences recursively to?
23:43:46 <Shuu> [2,3,2,4,3,2,5]
23:43:53 <Pseudonym> Really?
23:43:57 <Shuu> umm
23:44:05 <Shuu> oh
23:44:14 <Shuu> [5,2,3,4] ?
23:44:18 <Pseudonym> No.
23:44:24 <Shuu> hm..
23:44:25 <Pseudonym> Think about this for a moment.
23:44:31 <Pseudonym> What is occurrences [5,2,3,2,4,3,2,5]?
23:44:36 <Pseudonym> What should it be?
23:45:06 <Shuu> I'm not sure
23:45:18 <Pseudonym> <Shuu> > occurrences [5,2,3,2,4,3,2,5]
23:45:18 <Pseudonym> <Shuu> [(5,2), (2,3), (3,2), (4,1)]
23:45:21 <Pseudonym> Tjat
23:45:26 <Pseudonym> That's what you said earlier.
23:45:29 <Shuu> Oh the answer..
23:45:34 <Shuu> Yeah.
23:45:38 <Pseudonym> Right.
23:45:42 <Shuu> Its a list of pairs.
23:45:50 <Pseudonym> You know how to produce the head of this list.
23:45:51 <Pseudonym> (5,2)
23:45:59 <Shuu> Yes.
23:46:12 <Pseudonym> So what you want is some list ys such that occurrences ys == [(2,3), (3,2), (4,1)]
23:46:14 <Pseudonym> Correct?
23:46:22 <Shuu> Yes.
23:46:33 <Pseudonym> How would you make that list?
23:46:44 <Shuu> with filter
23:47:04 <Shuu> but
23:47:09 <Shuu> the same way i did it for the head
23:47:12 <Shuu> i would say
23:47:16 <Pseudonym> Show me some code.
23:47:20 <Shuu> ok
23:47:23 <Shuu> let me try
23:50:02 <Shuu> See like my instincts tell me to just occurrences on the xs and have the beginning part take care of it
23:50:10 <Shuu> instead of on the (x:xs)
23:50:37 <Shuu> something like this is what i pictured
23:50:39 <Pseudonym> What do you get if you do that?
23:50:41 <Shuu> but its wrong
23:50:42 <Shuu> > occurrences (x:xs) = (x, howMany x xs) : occurrences xs
23:51:07 <Shuu> i get
23:51:31 <Shuu> [(5,1),(2,2),(3,1),(2,1),(4,0)...
23:51:36 <Shuu> it makes no sense.
23:52:17 <Pseudonym> What's your definition of howMany again?
23:52:25 <Shuu> > howMany x xs = length [z | z <- xs, z == x]
23:53:08 <Pseudonym> Oh.
23:53:16 <Pseudonym> There's a mistake.
23:53:25 <Pseudonym> (x, howMany x xs + 1)
23:53:27 <Pseudonym> Do you see why?
23:53:42 <Shuu> No, it worked in part 1?
23:53:51 <Shuu> Right?
23:53:53 <Shuu> We saw it work.
23:54:11 <Pseudonym> Yes, but then you were applying it to the whole list, xs.
23:54:17 <Pseudonym> Here you're only applying it to the tail.
23:54:23 <Shuu> Wow.
23:54:26 <Pseudonym> If it helps, this would work too:
23:54:29 <Shuu> I would have never realizes such a thing.
23:54:33 <Pseudonym> (x, howMany x (x:xs))
23:54:33 <Shuu> realized*
23:55:05 <Pseudonym> Now once you've done that, this suggests an alternative solution, which I suggest you don't do.
23:55:29 <Pseudonym> Take a look at what this definition of occurrences does.
23:55:32 <Pseudonym> What it returs.
23:55:40 <Shuu> the one i showed you?
23:55:42 <Pseudonym> The answers you want are actually there in the list.
23:55:49 <Pseudonym> Yes, with the modification.
23:55:51 <Pseudonym> The + 1
23:56:51 <Pseudonym> Anyway, this suggests that you could run this function, then post-process the list to get the final answer.
23:56:52 <Shuu> [(5,2),(2,3),(3,2),(2,2),(4,1),(3,1),(2,1),(5,1)]
23:57:03 <Pseudonym> Remove the values you don't want.
23:57:11 <Pseudonym> You could do it with a function like nub.
23:57:18 <Shuu> Yeah!
23:57:22 <Shuu> the +1 owns
23:57:25 <Shuu> ^^
23:57:47 <Pseudonym> Not nub exactly, but something like it.
23:57:50 <Shuu> is that what you meant by g
23:58:16 <Pseudonym> No.  What I'm suggesting as this alternative solution is to write a function _around_ this one that you've called "occurrences".
23:58:28 <Shuu> oh yeah, i can do that though.
23:58:37 <Pseudonym> But I don't suggest you do.
23:58:41 <Pseudonym> I suggest you try to find g. :-)
23:58:49 <Shuu> is it a higher order function ?
23:58:50 <Pseudonym> It's going to look a lot cleaner.
23:59:13 <Shuu> i see..
