00:50:41 <rickjames> avgLineLength :: String -> Float
00:50:41 <rickjames> avgLineLength [] = 0
00:50:41 <rickjames> avgLineLength text = (length text) / (numLines text)
00:51:13 <Pseudonym> Haskell is not a weakly typed language.
00:51:15 <Pseudonym> @type length
00:51:15 <lambdabot> length :: [a] -> Int
00:51:39 <Pseudonym> I'm guessing numLines returns an Int too.
00:51:41 <Pseudonym> @type (/)
00:51:42 <lambdabot> (/) :: Fractional a => a -> a -> a
00:51:45 <rickjames> ok but isnt int / int a float
00:51:54 <rickjames> numLines is an Int
00:51:55 <Pseudonym> Int is not a member of Fractional.
00:52:09 <Pseudonym> @type (%)
00:52:09 <lambdabot> (%) :: Integral a => a -> a -> Ratio a
00:52:14 <Pseudonym> Hmmm.
00:52:37 <Pseudonym> @type fromIntegral
00:52:37 <lambdabot> fromIntegral :: (Integral a, Num b) => a -> b
00:52:42 <Pseudonym> That's the one you want.
00:52:48 <rickjames> how come i can do 2 / 3 in the interpreter line
00:52:56 <Pseudonym> @type 2
00:52:56 <lambdabot> 2 :: Num a => a
00:53:02 <Pseudonym> Does that help?
00:53:18 <rickjames> no i dont think i understand?
00:53:36 <Pseudonym> 2 has any type, so long as it's a number.
00:53:41 <rickjames> ok
00:53:44 <Pseudonym> @type 2 :: Int
00:53:44 <lambdabot> 2 :: Int
00:53:46 <Pseudonym> @type 2 :: Float
00:53:47 <lambdabot> 2 :: Float
00:53:50 <Pseudonym> See?
00:54:03 <rickjames> ok and length and numLines have Int explicitly
00:54:06 <Pseudonym> Right.
00:54:33 <rickjames> so i could just write an instance of Fractional over Int right?
00:54:40 <Pseudonym> So you can do one of two things.  Easiest is to convert both the numerator and denominator with fromIntegral.
00:54:51 <Pseudonym> rickjames: YOu could, I suppose, but many things would break.
00:54:56 <rickjames> ok
00:55:11 <rickjames> fromIntegral is in the prelude?
00:55:18 <Pseudonym> Yes.
00:55:44 <rickjames> ok 
00:55:49 <rickjames> what was the second option?
00:56:03 <Pseudonym> The second option was using % instead of /, and converting the result.
00:56:16 <Pseudonym> % takes two integers and returns a fraction.
00:56:35 <Pseudonym> Float isn't a fraction, so you have to convert the result.
00:56:35 <rickjames> ohhh thats not mod?
00:56:40 <Pseudonym> No.
00:56:43 <rickjames> ok
00:56:44 <Pseudonym> mod is mod
00:56:50 <rickjames> ok
00:56:54 <Pseudonym> @type mod
00:56:54 <lambdabot> mod :: Integral a => a -> a -> a
00:58:54 <Pseudonym> This is an aspect of Haskell that momentarily confuses people who are used to weakly typed languages.
00:58:56 <rickjames> great the fromIntegral works perfect
00:59:00 <Pseudonym> Cool.
00:59:07 <rickjames> let me ask
00:59:44 <rickjames> is there any api, or other documentation of the functions in the prelude
00:59:53 <Pseudonym> Yes.  Hangon.
01:00:04 <rickjames> ok
01:00:16 <Pseudonym> http://haskell.org/onlinereport/
01:00:33 <Pseudonym> There's one section "Standard Prelude", and also the other standard libraries are there.
01:01:02 <Pseudonym> GHC's haddock documentation is also pretty good.
01:01:17 <Pseudonym> Are you using GHC, Hugs or something else?
01:01:56 <rickjames> hug
01:01:57 <rickjames> s
01:02:06 * Pseudonym nods
01:06:48 <rickjames> thanks pseudonym
01:07:22 <Pseudonym> Must head off myself.
01:07:24 <Pseudonym> Nytol!
01:11:15 <shapr> hoi 
01:11:30 <shapr> ik ben een buitenlander!
01:11:57 <^tijn> haha
01:12:04 <shapr> :-)
01:12:06 <vegai> well aren't you a cunning *shoots himself before delivering that awful pun*
01:12:11 <shapr> vegai: aargh
01:12:25 <shapr> James Bond had a better setup with that pun
01:13:12 <dr_fripp> you mean gun
01:13:20 <shapr> that too
01:14:04 <dr_fripp> "I have a black belt in KungFu!"
01:14:12 <dr_fripp> "Sure you do!"
01:14:51 <^tijn> jag ar utlänning!
01:15:17 <shapr> ooh, nice
01:15:40 <shapr> ok, now in my native language: Ah'm a furriner!
01:16:01 <shapr> I have a brown belt in Haskell!
01:16:15 <shapr> see the grading system here: http://www.haskell.org/hawiki/HaskellIrcChannel
01:18:04 <dr_fripp> du ar förståndshandikappad
01:18:11 <shapr> truly
01:18:16 <dr_fripp> :P
01:18:17 <vegai> I'd be green
01:18:20 <shapr> especially when it comes to dutch
01:18:27 <vegai> perhaps just graduating blue
01:18:33 <vegai> perhaps failed that graduation once =)
01:19:28 <vegai> though I haven't entered any competitions yet, but I have been assisting on a white belt course ;)
01:19:38 <shapr> excellent
01:19:39 <vegai> s/but //
01:20:02 <dr_fripp> du ser ut att analöppning
01:20:37 <shapr> I do not!
01:21:05 <shapr> graag gedaan!
01:21:20 <shapr> gezeik!
01:21:34 <shapr> hey, have you guys had any more luck with HaskellDB on win32?
01:21:52 <dr_fripp> nope
01:21:59 <dr_fripp> that's actually why we're here
01:22:06 <dr_fripp> but we're having a bit of fun now
01:22:11 <dr_fripp> bråte, bråte, bråte!
01:22:15 <^tijn> tack!
01:22:40 <shapr> kvatch
01:22:54 <shapr> jag har ingen aning.
01:26:31 <dr_fripp> kanonkula och sprängämne
01:28:04 <shapr> dr_fripp: om du vill, du kan prova #haskell.se :-)
01:45:23 <shapr> ibid: whoa, you deb'd BNFC!
01:46:10 <shapr> ibid: shouldn't it suggest alex, happy, ghc ?
01:47:52 <ibid> shapr: yes, i did :)
01:47:58 <ibid> i think i mentioned that here
01:48:39 <shapr> spiffy
01:48:41 * shapr installs
01:48:48 <ibid> shapr: if it did, it would have to suggest also bison, flex, cup, jlex
01:49:05 <ibid> shapr: i decided against that and just noted the required packages in description
01:49:12 <shapr> yah, I can understand that
01:50:34 <Lunar^> Hi shapr 
01:51:05 <shapr> bonjour Lunar^
01:51:05 <shapr> what's up?
01:51:49 <Lunar^> shapr: It's getting better for my sister, I'm going with her near the sea tomorrow, I'll stay off the net for a few day
01:52:29 <shapr> Lunar^: ok, that's good to hear
01:53:32 <Lunar^> shapr: Ingeniweb's boss was really comprehensive, because I'm missing two work day
01:54:39 <shapr> comprehensive == kind?
01:55:00 <Lunar^> shapr: mhh maybe I'm a little too literal here
01:55:22 <Lunar^> shapr: It's not kindness, it's understanding the situation
01:55:26 <shapr> right, I see
01:56:11 <Lunar^> shapr: I would not have come tomorrow anyway, so I prefer that it is clear
01:57:24 <shapr> well, I hope the seaside is fun.
01:58:11 <Lunar^> shapr: I need to take a lot of reciepe with me, my dad is an awfull cooker
01:58:20 <dr_fripp> could somebody send me ghc 6.2?
01:58:34 <Lunar^> dr_fripp: which form ?
01:58:39 <dr_fripp> windows
01:59:14 <shapr> Lunar^: ha :-)
01:59:20 <Lunar^> dr_fripp: It's here : http://haskell.org/ghc/dist/6.2.1/ghc-6-2-1.msi
01:59:25 <dr_fripp> well
01:59:28 <dr_fripp> that's 6.2.1
01:59:36 <dr_fripp> I specifically need 6.2 :D
02:00:03 <Lunar^> dr_fripp: http://haskell.org/ghc/dist/6.2/ghc-6-2.msi
02:00:18 <Lunar^> dr_fripp: Do you have problems with 6.2.1 ?
02:00:35 <dr_fripp> nope, but haskelldb only installs with 6.2
02:00:47 * Lunar^ hopes that S^2 did not change the build system to much, hOp will suffer otherwise
02:00:51 <dr_fripp> (oh man that link was too obvious :D)
02:01:04 <Lunar^> dr_fripp: don't worry :)
02:02:10 <bring> it's weird that the 6.2 download page only links to the 6.2.1 windows installer
02:03:45 <Lunar^> shapr: How are haskell.org hard disks btw ?
02:18:04 <dr_fripp> it just doesn't extract any database dir into ghc's imports
02:18:17 <dr_fripp> not even with ghc6.2
02:42:04 <shapr> Lunar^: things appear fixed
02:42:15 <Lunar^> shapr: What happened ?
02:42:45 <shapr> from what I heard, something wrong with the hard drive(s), that's all I know
02:48:44 <Lunar^> haskell.org administration should be more open to the community IMHO
02:51:12 <shapr> I think I should resurrect gforge
02:55:29 <shapr> that might help
03:48:31 <shapr> hej Marvin-- 
03:48:33 <shapr> wassup?
03:49:38 <Marvin--> working on the appendices for the report
03:50:16 <Marvin--> well, along with rewriting the sections on typing and the section on the insertion sort example
03:50:18 <shapr> spiffy
03:51:18 <earthy> `org, gablorg, spiff'
03:52:04 * Marvin-- idly wonders what earthy is smoking
03:52:15 <shapr> I think he's reading Calvin & Hobbes :-)
03:52:19 <shapr> Spaceman SPIFF!
03:52:20 <earthy> calvinweed, obviously. ;)
03:53:59 <earthy> `the tv listings say this movie has `adult situations'. What are adult situations?' -- `Probably things like going to work, paying bills and taxes, taking responsibilities...' -- `Wow, they don't kid around when they say "for mature audiences".' -- `I've never understood how thos movies make any money.'
03:54:17 <earthy> (typos mine)
03:54:43 * shapr laughs
03:54:49 <shapr> calvin & hobbes rocks
03:54:55 <shapr> my favorite is:
03:55:07 <Marvin--> yeah, best. comic. ever.
03:55:14 <shapr> Hobbes: Why aren't you working on your book report? It's due in two days!
03:55:24 <shapr> Calvin: I have to be in the right mood to get creative.
03:55:29 <shapr> Hobbes: Oh, what mood is that?
03:55:35 <shapr> Calvin: last minute panic
03:55:41 <vegai> bullseye
03:55:50 <vegai> I'm _just_ like that
03:55:53 <shapr> me too
03:55:54 * earthy grinz
03:56:10 <Marvin--> I like all his crazy plans involving time machines, cloning and whatnot to avoid doing homework
03:56:19 <shapr> the transmogrifier!
03:56:20 <Marvin--> the cloning was friggin' best
03:56:25 <Marvin--> none of the clones wanted to do the homework either
03:56:28 <vegai> that I haven't tried ... yet
03:56:30 <shapr> yes, I loved that :-)
03:56:33 <earthy> very very very recognazible. :) (Wrote the introduction to an article this morning on the train... it had te be done at 09:15 for the writing english for publication course :))
03:57:06 <shapr> when we have a week of vacation between classes, when do I do my homework? the night before it's due.
03:57:35 <Marvin--> of course
03:57:43 <earthy> but, the one that's on my wyteboard is great as well: three panels without text, and then `When you think how well basic appliances work, it's hard to believe anyone ever gets on an airplane.'
03:57:45 <vegai> I hope us using IRC has no correlation to this ;P
03:57:59 <earthy> vegai: of course it doesn't, what do you think.
03:58:13 <vegai> along the lines that we are lazy bastards 
03:58:20 <shapr> I am not!
03:58:23 <shapr> I'm just... creative.
03:58:30 <earthy> (the panels without text are calvin putting bread in a toaster, watching contently as it roasts, and gasping in horror as it burns badly :))
03:58:39 * shapr snickers
03:58:42 <earthy> yeah, I'm a lazy bastard. :)
03:58:43 <shapr> he's got a point
03:58:58 <shapr> if architects built building the way programmers wrote programs...
03:59:13 <shapr> the first woodpecker to come along would destroy civilization
03:59:33 <shapr> hi Joachim 
03:59:53 <Joachim> Good day to you, shapr
03:59:55 * shapr crashes galeon for the sixth time in three hours
04:00:07 <shapr> man, the latest galeon in debian/unstable sucks
04:00:33 <earthy> but then again, if programmers wrote the way architects build, there would be virtually no innovative software and mostly bland and stupid COBOL accounting code.
04:00:45 <shapr> that's a good point too
04:01:18 <shapr> I recently tried to explain the economics of open source and how they relate to communism to some friends of mine who are russian and we only have the swedish language in common.
04:02:15 <shapr> I realize that most people have trouble grasping the concept of near-infinite near-gratis error-free reproduction...
04:02:49 * shapr tries to remember how that connected to innovative software
04:06:17 <Marvin--> I don't understand the economics of FOSS either, I just write code :-)
05:03:47 <hasky> hey guys, i need a hint as to how to go about something, so far I've written this: http://www.geocities.com/mamksau/Expo.txt  and I need to achieve the aim in the first comment, I can make more functions if needed
05:05:41 <Rafterman> hasky: is this for 1011 or 1711?
05:05:51 <hasky> I can see that x^10 = x^8*x^2 which is the values 8 and 2 from [1,0,1,0], but I can't figure out how to do that
05:05:54 <hasky> 1711
05:06:07 <Rafterman> oh, that problem
05:06:16 <Rafterman> (the link still hasn't loaded)
05:06:20 <Rafterman> that's a fun one :-)
05:06:36 <hasky> i've been pulling my hair out
05:06:47 <hasky> i'm real close just this last part
05:08:00 <Rafterman> is this for a brownie point, or just the advanced part of the lab?
05:08:38 <hasky> core mark :/
05:08:43 <Rafterman> ahr
05:08:58 <hasky> unzip and a lock puzzle is for advanced
05:09:04 <hasky> try this: http://treehou.se/~ab/Expo.txt
05:09:12 <shapr> gee, I want to take some Haskell classes.
05:09:23 <Rafterman> hasky: yeah, got it now
05:12:21 <hasky> I can turn [1,0,1,0] back into an number but i can't figure out how to pass 8 by itself and then 2 by itself....or am I thinking wrong
05:13:13 <hasky> i tried making a list [8,0,2,0] and trying to pass the values from the list but that failed aswell :P
05:14:04 <Rafterman> write out a couple on paper and see where you want to do your multiplications
05:14:23 <Rafterman> because remember the reason this is fast is because you cut out heaps of multiplications
05:14:45 <hasky> yeah it should be 4x for x^10
05:16:54 <hasky> what i'm having trouble with is passing the right values through
05:17:40 <hasky> how do i go from [1,0,1,0] to x^8*x^2 
05:19:31 <Rafterman> recursively :)
05:19:55 <Rafterman> notices that x^2 = x*x, x^4 = x^2*x^2, x^8 = x^4*x^4, etc
05:20:04 <cuelebre> i will use reverse , zip and foldr 
05:20:27 <hasky> not allowed to use foldr
05:23:34 <hasky> yeah i got that rafter, what i tried doing is 2^length(tail) of [binarylist] to get the values but i kept passing back 10 instead of 8 & 2, i need a hint on a good way to break up the list
05:32:40 <adept> hello there. I try to do some heavy-weight data processing in Haskell and have run into problems, wich led me to the following "feasibility" task. I have 15-mb text file with ~600000 lines. I try to print all unique lines from this file. I found out that "nub" takes more than two hours to complete on such amount of lines, and "(map head).group.sort" gobbles more than 500 Mb of memory. Is there a way to do this in n log n time and in moderate memory space?
05:34:55 <shapr> adept: what about making a FiniteMap of hash to list of line numbers?
05:35:40 <shapr> then you can use readFile and keep the whole lazy
05:35:46 <shapr> "whole thing"
05:35:49 <adept> shapr: along the lines of "mapM_ putStrLn $ fmToList $ foldl addTo emptyFM contents" ?
05:36:40 * shapr thinks about that
05:37:16 <adept> addTo fm rec = addToFM fm rec () -- or lineNumber instead of ()
05:38:08 <shapr> the advantage of using line numbers is that even with really long lines, you don't use much space, same for hashes
05:38:08 <adept> shapr: I tried it. FiniteMap updates eat memory even quicker than sort.
05:38:12 <shapr> hm
05:38:27 <shapr> that's surprising
05:38:29 <shapr> do you have the source handy?
05:38:37 <adept> I'll try with strict foldl, just a second
05:38:48 <shapr> why are you using foldl rather than foldr?
05:39:14 <shapr> konichiwa ikegami-san
05:39:30 <ikegami> hi
05:39:42 <shapr> do you have more questions?
05:40:27 <adept> shapr: with foldr I got stack space overflow
05:40:57 <shapr> huh
05:40:59 <ikegami> yes, however I get dead drunk now :)
05:41:06 <shapr> haha!
05:41:27 <shapr> I'd love to have some real Sake, I should order some.
05:41:48 <shapr> I've only had gekkikan(sp?) from california
05:41:51 <ikegami> because I join HANAMI (in Japanese, seeing cherry blossom with drinking 
05:42:09 <ikegami> that's Japanese traditional event
05:42:19 <shapr> sounds like fun
05:42:38 <ikegami> in spring
05:42:43 <shapr> adept: I'm trying to get together some pseudocode for that
05:43:11 <shapr> I have trouble drinking just a little bit of Sake, I usually drink all the Sake I have.
05:43:38 <shapr> adept: are you using addToFM_C ?
05:43:39 <Jerub> yick. printing unique lines of large datasets.
05:43:56 <ikegami> since shapr kindly asks me what is my question everyday, I enjoy chatting here
05:44:00 * shapr grins
05:44:03 <ikegami> very good :)
05:44:29 <Jerub> I'm tempted to suggest using a database.
05:44:32 <adept> shapr: no. However, I just understood that I havent got your advice. Just a second, I'm recoding.
05:45:44 <Jerub> you could quite easily just insert the data into a tempoary table, bang an index on (after the inserts ;) and go select distinct(line) from temp_table order by line;
05:45:44 <shapr> main = do conts <- readFile "bigfile.txt"
05:45:45 <shapr>           let myFM = emptyFM :: Hash [Int]
05:45:45 <shapr>           foldr addToFM_C hashMe conts
05:45:50 <shapr> that's what I have so far, I'm not sure if it's clear
05:46:14 <shapr> the _C part of the addToFM should add this line number to the list of Int
05:46:18 <shapr> er, make that Integer
05:46:25 <shapr> and there's no code to check the line number
05:46:32 <shapr> it might be simpler to actually save the whole line
05:47:13 <shapr> then just spit out the elements at the end
05:47:17 <shapr> actually, I think that would work
05:47:23 <adept> shapr: actually, it doesnt matter for me what is the element of hash, as long as key is line ....
05:47:37 <adept> since i'm inetersed in lines, not in line numbers
05:47:57 <shapr> yes, you're right
05:48:13 <adept> Try this code on large file, even with -O2 it will eat space like a pig.
05:48:26 <shapr> the simplest approach is to just use addToFM and be done with it
05:49:20 <shapr> @type addToFM
05:50:05 <adept> can I paste some code here?
05:50:25 <shapr> paste page on the wiki
05:50:34 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:50:49 <shapr> ikegami: would you suggest some brand names of Sake that I should try?
05:51:33 <Jerub> adept: considering the requirements, of course its going to eat space like a pig. its not even a ghc/haskell issue.
05:52:18 <ikegami> ok, we have much great delicious Japanese Sake, which are not written in Haskell
05:52:32 <shapr> haha
05:53:12 <shapr> main = do conts <- readFile "bigfile.txt"
05:53:13 <shapr>           let myFM    = emptyFM :: [Char] ()
05:53:13 <shapr>               results = foldr (flip (addToFM myFM) ()) conts
05:53:13 <shapr>           mapM_ putStrLn $ keysFM myFM
05:53:21 <shapr> adept: that's what I thought up
05:53:29 <shapr> it seems likely to be lazy, but I haven't yet tried it
05:54:02 <ikegami> though they have types
05:54:15 <adept> Jerub: oh? And whose issue is that?
05:54:45 <adept> shapr: see wiki page, last snippet
05:54:58 <adept> shapr: keysFM could not be lazy
05:55:31 <Jerub> adept: you need to sort the data.
05:55:53 <adept> Jerub: and?
05:56:00 <Jerub> adept: which is an O(n) memory operation.
05:57:17 <adept> Jerub: on memory issue I'm just unhappy to have rather large constant factor. >>500Mb RSS memory for 15 Mb of input seems to be rather overkill.
05:57:36 <adept> Jerub: even with PackedString
05:58:06 <Jerub> gah, didn't see the dataset was so small. I'm sorry ;)
05:59:45 <adept> Jerub: and problem is, in real life task I cant sort the data before it gets into Haskell :(
06:00:32 <ikegami> shapr: I recommend Japanese original sprits 'shochu' (today I tried one)
06:00:55 <adept> Jerub: I'd even be happy with "nub" that runs in O(n^2) time, but is eat space too (>2 hours and >200Mb, and still not finished) :(((
06:03:40 * adept fires up "What Can I Do?" on his xmms
06:10:56 <Cale> What does the space complexity of nub as implemented in List look like?
06:13:22 <Igloo> shapr: Is there a reason you aren't using Data.Set?
06:14:20 <Igloo> If you don't mind your data being sorted (and you have Ord on it), sort then a linear-nub will be more efficient
06:16:28 <shapr> no reason at all
06:16:32 <shapr> just the first solution that came to mind
06:16:55 <shapr> ikegami: thank you, I'll try it.
06:17:33 <shapr> what's a linear nub?
06:17:46 <adept> yeah, whats a linear nub?
06:18:13 <Jerub> adept: I was kinda serious when I mentioned the idea of using a database.
06:18:29 <Jerub> its the right tool for the job when you think about it ;)
06:18:41 <ikegami> pub is where we get drunken
06:18:45 <shapr> Data.Set does look handy
06:19:12 <Igloo> ln (x:y:xs) | x == y = ln (x:xs)
06:19:19 <Igloo> ln (x:xs) = x:ln xs
06:19:27 <Igloo> ln [] = []
06:19:29 <Igloo> or so
06:19:47 <adept> Igloo: it's lazy, yes, but it's O(n^2) in time.
06:19:58 <Igloo> ln is O(n) time
06:20:32 <Igloo> And sort O(n lg n), so ln . sort is O(n lg n)
06:21:02 <adept> Jerub: what i'm trying to do is to cluster records based on complex equality function. Records dont have fixed structure, which makes DB difficult to use. This toy example with lines is a rough approximation of the part of the task i'm having most problems with.
06:21:56 <adept> Igloo: sorry, i'm typing before I'm thinking ...
06:22:49 <adept> Igloo: can you take a look at http://www.haskell.org/hawiki/HaskellIrcPastePage, last snippet?
06:22:52 <shapr> main = do conts <- readFile "bigfile.txt"
06:22:53 <shapr>           let mySet = emptySet :: Set [Char]
06:22:53 <shapr>               results = map foldr addToSet myset conts
06:22:53 <shapr>           mapM_ putStrLn $ setToList results
06:22:53 <shapr> ?
06:23:10 <adept> shapr: hav you tried it?
06:23:16 <shapr> no, just a moment...
06:23:26 <Igloo> adept: Ermm, OK, I've looked at it. Now what?  :-)
06:24:23 <adept> Igloo: can you tell me why it uses > 350Mb of memory to process 15Mb file (600.000 lines)
06:24:31 <Igloo> If you do care about line order, you could   zip xs [1..], sortBy compare_first, ln, sortBy compare_snd, map fst
06:25:09 <Marvin--> jeepers, Mark King starts the game with a 138 point frame
06:25:33 <Igloo> Although that wouldn't be any more efficient (asymptotically at least) than yours I don't think
06:26:02 <Igloo> I can't OTTOMH. Have you tried heap profiling it?
06:26:17 <Igloo> Biographical profiling might be useful too, but I'm not so sure
06:26:52 <Igloo> Oh, using Data.Set might save you some space, although I have a feeling it might just be implemented in terms of FM. It's certainly nicer though  :-)
06:27:13 * Igloo wonders which of those imports gets you FM
06:27:28 <adept> import FiniteMap + -package data
06:28:06 * andersca pokes shapr
06:28:33 <Igloo> Ah, OK - that's not in the bottom snippet though :-)
06:29:07 <adept> Igloo: that snippet I posted is DRAGging memory like mad.
06:29:27 <shapr> andersca: wha?
06:29:41 <Igloo> DRAG is memory that has finished being used, right?
06:29:53 <Igloo> Do you know what sort of thing it is that is being DRAGged?
06:29:58 <adept> Igloo: Yes. dragged memory is "printer/Main/CAF".
06:30:28 <adept> Igloo: retainer is SYSTEM :( I dont know what is it :(
06:30:33 <Igloo> Oh, try inlining nub'
06:32:04 <adept> Igloo: no difference. 
06:32:29 <Igloo> Is the memory still used by "printer/Main/CAF"?
06:32:39 <adept> Igloo: no difference at all. Same amount of DRAG, same conses, same retainer
06:33:09 <Igloo> You have   mapM_ putStrLn $ (nub'' emptyFM) $ lines content   now, right?
06:34:24 <adept> Igloo: no, i have {-# INLINE #-}. Stupid me :) Moment
06:34:26 <shapr> I have one that appears to be lazy, and works on a 40k line file
06:34:35 <shapr> at least, I'm getting output
06:36:28 <adept> Igloo: with manual inline, it's still the same figures and same graphs.
06:37:02 <adept> Igloo: there is a small retention by nub'' and huge retention by SYSTEM :(
06:38:23 <Igloo> Actually, would you expect most of the set to drag given most of the tree will probably not be traversed?
06:38:56 <Igloo> cp Q.hs W.hs
06:38:57 <Igloo> Bah
06:39:55 * Marvin-- gets stack overflow
06:40:12 <Cale> have you tried using mkSet?
06:41:01 <adept> Igloo: good point. Then, again, I have 15 Mb of input, and 350 mb of memory :(
06:41:05 <Marvin--> hear ye, hear ye, TH is evil
06:41:06 <Cale> I have no problem with a 9mb textfile, just doing the obvious thing, reading it in and using mkSet.lines
06:41:09 <adept> Cale: mkSet on what?
06:41:20 <shapr> I don't have a stack overflow, but I did get tired of waiting and kill it after two minutes with a 3.2 million line file
06:41:39 <Cale> perhaps I should double the size of my file :)
06:41:50 <Igloo> Well, there is always going to be some constant factor for Haskell lists and suchlike
06:42:05 <shapr> my memory usage topped out at 530mb virt and 400mb res with the 3.2m lines
06:42:10 <shapr> it was still chugging along
06:42:17 <Igloo> mkSet wouldn't work if you care about line order
06:42:28 <adept> I dont care
06:42:28 <shapr> do you care about line order?
06:42:36 <Igloo> You could try the tupling sorting nub I described above and see if that gives you better performance
06:42:45 <Igloo> Ah, well that makes it easier then
06:48:15 <ozone> Marvin--: uh oh, what are you bitten by in TH now?
06:48:40 <Marvin--> I just find the general idea of qIO evil :)
06:49:25 <shapr> adept: I put my solution on the paste page
06:49:32 <shapr> hey stratocaster, haven't seen you around much lately.
06:49:47 <ozone> Marvin--: evil ... but sooooo good!
06:50:06 <Marvin--> o3: I didn't deny that :)
06:50:37 <shapr> hey ozone, were you the guy who was wrapping a whole .hs file in something like theSplice = $( <insert file> ) to import it into another TH file?
06:51:07 * adept tries shapr's solution
06:51:24 <shapr> of course, I built it with -O2 -fvia-C for extra speed
06:51:29 <stratocaster> hey. I just don't use irc much, still plugging away with haskell, though
06:51:40 <ozone> shapr: that would be sean (seafood on irc)
06:51:41 <shapr> stratocaster: cool, have any questions?
06:51:47 <shapr> ok, thanks
06:51:48 <shapr> seafood: y0
06:52:19 <stratocaster> yea, actually. Is there some way to use select() that I've missed, or do I need to use threads instead?
06:52:22 <shapr> I bet his EDSL paper has more details
06:53:33 <shapr> I know select() has been discussed here, but I've forgotten the answers.
06:53:46 <Marvin--> it's not in libraries yet, but there is a version in hslibs
06:54:12 <shapr> adept: works? sucks?
06:54:46 <adept> shapr: sucks memory :)
06:54:52 <adept> why do you put reverse in there?
06:54:53 <shapr> oh, just as bad?
06:55:14 <adept> it used 446 mb of ram on 512 mb machine and was killed by kernel
06:55:21 <adept> + lots of swap
06:55:24 <shapr> because it's foldl, and I think foldl + reverse works like foldr without reverse
06:55:26 <shapr> fooey :-(
06:55:38 <shapr> I was trying to preserve the laziness
06:55:58 <adept> and it's for 15 mb of input..... Maybe there is better datatype than String?
06:56:46 <shapr> strange
06:56:58 <shapr> well, you could try it without the reverse, see if helps any :-)
06:57:03 <shapr> I think it'll just explode the heap though
06:57:08 <stratocaster> great, thanks. here's the docs url in case anyone is interested: http://www.haskell.org/ghc/docs/latest/html/hslibs/select.html
06:57:11 <dennisb> stratocaster: ghc comes with a select function
06:57:22 <Marvin--> well, using strings, don't you have to count on at least 8 bytes per character in the file? *at least*
06:57:48 <adept> shapr: without reverse, it is essentially my code
06:57:52 <shapr> yup
06:58:11 <adept> Marvin--: why?
06:58:25 <Marvin--> adept: type String = [Char]
06:58:32 <adept> Marvin--: and what's an alternative to String in this case?
06:58:49 <Marvin--> Char is a unicode codepoint and there will always be at least a next pointer too
06:59:01 <shapr> a hash would save memory
06:59:07 <Marvin--> there's PackedString
07:00:40 <dennisb> you can think of a String as a linked list with (unicode) characters and Packetstring is like an array of (unicode) characters, much like strings in C
07:00:56 <adept> Marvin--: it's not better, i tried
07:01:25 <dennisb> PackedString I mean of course
07:01:40 <Marvin--> dennisb: heh :)
07:02:35 <Igloo> Aaargghh
07:02:40 <shapr> you screamt?
07:03:00 <Igloo> You'd normally say a -> b <= Int -> Char, right?
07:03:13 <Igloo> No
07:03:31 <Igloo> Int -> Char <= a -> b, right?
07:03:56 <Igloo> So unification goes downwards with bottom and the bottom meaning unification failure
07:04:15 <dennisb> the last I think, there are fewer functions in Int->Char then in a->b
07:04:39 <Igloo> Right, OK, thanks
07:04:54 * Igloo goes through from the start making sure all my comparison functions are consistent
07:05:20 <adept> Marvin--: besides, PackedString does not allow to do "readFile"
07:05:33 <Marvin--> adept: I know
07:06:56 <shapr> adept: you could treat it like a memoising function, write out the string unless you already have its hash
07:07:27 <adept> shapr: <you could treat it> -- I could treat what?
07:07:46 <shapr> the whole program
07:08:12 <shapr> it seems like holding a bunch of strings in memory is wasteful
07:08:13 <adept> shapr: see my code on paste page. I wrote it exactly this way, no?
07:08:28 <adept> shapr: ah. It's hash. I see.
07:09:07 <adept> strange. hGetPS overflows 100Mb stack on my 15mb file ...
07:09:30 <adept> shapr: will need a decent hash (md5?) though ...
07:09:33 <Igloo> Some of the PackedString stuff has performance issues. I mailed one of the lists about it recently
07:11:01 <shapr> adept: even so, memory usage should be equal to the size of the unique hashes up to this point rather than unique lines
07:11:40 <shapr> I'm not sure how much that will help though.
07:12:10 <adept> Igloo: this thread? http://groups.google.com/groups?hl=ru&lr=&ie=UTF-8&inlang=ru&th=b28bef35e70644dd&rnum=1
07:12:49 <Igloo> No, that's not Data.PackedString
07:13:09 <bourbaki> hiho
07:13:13 <shapr> hiya
07:13:41 <Igloo> http://www.haskell.org//pipermail/libraries/2004-March/001750.html
07:14:57 * adept reads through PackedString.hs
07:15:57 * adept starts to think that implementation of algorithm was a lot of joy, but datatypes are going to ruin it ...
07:22:20 <adept> PackedStrings packs memory quicker and better than plain String. PackedString version eats more memory, even
07:23:19 * Igloo wonders why you version and timed me earlier
07:23:47 <ikegami0> i should go to bed now, good night all
07:23:59 <shapr> good night ikegami0 
07:25:12 <ikegami0> shapr: I found you at orkut, and I add you to my list
07:26:05 <ikegami0> see you again
07:26:10 <shapr> see you :-)
07:26:22 <Igloo> With substitutions, is   { a |-> Int } <= { }?
07:32:48 * Marvin-- sighs at the Debian Taiwan debate
07:33:19 <Marvin--> where by "debate", I mean "flamewar"
07:33:30 <Igloo> Aha, I never actually compare substitutions so I can just remove it
07:35:26 <shapr> seafood: y0, can I get some demo code that demonstrates your cool trick of wrapping an entire module in declaration reification brackets?
07:35:37 <Igloo> Oh bother, yes, I do
07:35:47 <Marvin--> Igloo: what are you doing?
07:35:53 <shapr> yes, I want to know also
07:36:22 <Igloo> I'm trying to talk about type systems and getting very confused by about 8 different sorts of <=
07:36:33 <Marvin--> no kidding, you're confusing me too
07:36:40 <Marvin--> is this <= as in subtyping?
07:37:34 <Igloo> The first one was, yeah. I'm happy with that, though, but now trying to work out what the canonical meaning for substitutions is.
07:42:08 <Marvin--> uhm, and what's your subtyping rules for functions?
07:43:02 <Igloo> Oh, I may not mean subtyping exactly. I'm just talking about unification
07:43:35 <Marvin--> oh, phew
07:43:39 <Marvin--> it looked a bit strange :)
07:45:45 * Igloo fails to find anything in anything on my desk so decides the above should hold so  s1 <= s2  means  s1 t <= s2 t
07:48:14 <shapr> hi sysfault 
07:48:30 <sysfault> morning shapr
07:48:35 * Marvin-- wrestles with bottom
07:50:15 <shapr> "your food tastes like _|_ !"
07:51:40 * Marvin-- silently curses Koen for just scribbling notes like "What about _|_?" without explanation
07:51:50 * earthy laughs
07:52:02 <earthy> and starts packing up to go home
07:52:20 <Igloo> He might just mean you should add something saying it obviously works for bottom toto because ...
07:52:36 <Marvin--> if it were obvious, I'd already written about it :-/
07:52:44 <Igloo> Ah
07:52:53 <shapr> "man, that sucks _|_ "
07:52:54 <Marvin--> that's my theory anyway :)
07:52:54 <Igloo> Well, the lack of explanation probably means he didn't know the answer then  :-)
07:53:16 <shapr> gee, I can't believe I haven't noticed the juvenile humor that's available in Haskell's type system.
07:53:47 <Marvin--> shapr: it's even more fun if you write ( | ) instead of _|_
07:54:04 <Marvin--> ... for some definition of fun
07:54:09 <shapr> (_|_) does resemble buttocks.
07:54:24 <Igloo> You have strange buttocks  :-P
07:54:47 <shapr> I weigh 103 kilos right now, how much do you weigh :-P
07:55:16 <Igloo> right now? Do you have scales built in to your chair or something
07:55:32 <Marvin--> anyhoo, I *think* that as long as I only enumerate values for types rather than saying "if X is type T, then X must be ..." this *should* be safe
07:55:35 * Igloo imagines a wmaker applet^W^Wemacs plugin showing your weight continually updated
07:55:38 <shapr> no, I just happened to check last night
07:55:40 * shapr laughs!
07:55:49 <shapr> yes, current-weight.el !
07:56:29 <Marvin--> typeOf(d_False, ty_Bool). typeOf(d_True, ty_Bool). typeOf(not, fun(ty_Bool,ty_Bool)).
07:56:48 <Marvin--> that *should* be safe regardless of bottom, shouldn't it
07:56:54 <shapr> typeOf(not, funny) ?
07:57:31 <Marvin--> hmm, it does mean that you can only conclude typeOf(app(not,X), ty_Bool) if X is d_False or d_True... but that's okay since not is a total function, I guess...
07:57:37 * Marvin-- swears in the general direction of partial functions
08:00:04 <shapr> hmmm "wrap the whole module in declaration reification brackets" 
08:00:20 <shapr> hei Esa
08:00:23 <shapr> wassup?
08:00:46 <esap> Just came from work, so haven't yet done anything...
08:03:07 <shapr> hoi thijs 
08:04:43 * esap has recently written some small things to wikipedia.
08:06:47 <shapr> like what?
08:07:11 <esap> like couple of paragraphs to http://en.wikipedia.org/wiki/Class_(computer_science)
08:07:36 <esap> in the "Structure of a class" part.
08:10:57 * Marvin-- wonders if it's still April 1st
08:11:09 <Marvin--> "On Monday, April 5, 2004, as part of the Shared Source Initiative, Microsoft released the source code for the Windows Installer XML (WiX) developer tool to SourceForge under the IBM Common Public License"
08:11:25 <esap> heh :-)
08:23:46 * Marvin-- ponders sending down a warm hat to hell
08:29:25 <Marvin--> wow, this looks interesting
08:29:32 <Marvin--> "Towards Machine-Verified Proofs for I/O"
08:29:55 <Marvin--> note to self: get to know Sparkle better
08:30:51 <Igloo> Sparkle?
08:31:20 * SyntaxNinja once met a girl named Sparkle
08:33:24 <SyntaxNinja> someone on planet debian was talking about some simple benchmark he wanted to try various programming languages in, so I hacked together a quick Haskell version.  It's on the wiki in case anyone wants to optimize it, (but it should hopefully still be readable): http://blog.syntaxpolice.org/isaac/index.cgi/asciiCount.html
08:34:43 <Marvin--> Igloo: interactive proof tool for Clean
08:34:48 <Igloo> all (== True) (map isAlphaNum w)    is     all isAlphaNum w
08:36:00 <SyntaxNinja> @type all
08:36:01 <lambdabot> all :: (a -> Bool) -> [a] -> Bool
08:36:26 <SyntaxNinja> ahh
08:36:27 <SyntaxNinja> duh
08:36:56 <Marvin--> how on earth did you come up with all (==True) ? :)
08:37:39 <SyntaxNinja> hehe
08:37:46 <Marvin--> even   and (map ...)  would make more sense
08:37:47 <SyntaxNinja> I think I've just done it in other contexts too often
08:38:39 <Igloo> The addToFM in group is just   addToFM_C (+) m w 1
08:39:37 <Igloo> And if you made your tuples the other way round you could just use sort
08:39:48 <Igloo> Oh, no, it goes the other way
08:40:35 <Igloo> You could negate the count if you didn't mind a little hack, though  :-)
08:40:41 <Marvin--> SyntaxNinja: with all that commentary, why not write it in literal style?
08:41:06 * SyntaxNinja debates the addToFM_C
08:41:11 * Igloo would tend to put words on the next line rather than the >>= return . style
08:41:53 <_rubix> SyntaxNinja, why not use liftM instead of the ">>= return" things ?
08:42:18 <Igloo> True, that would be better too
08:42:43 <SyntaxNinja> Marvin--: yeah, I wasn't planning to put so much commentary at the beginning.
08:42:47 <Igloo> It would be nice to catch read failing too  :-)
08:42:53 <Igloo> (i.e. reads rather than read)
08:43:47 <Marvin--> SyntaxNinja: just thought that it would be cute to show off that too :)
08:44:39 <Igloo> Does haddock work with the literate style?
08:45:03 <SyntaxNinja> I don't think so
08:45:10 <SyntaxNinja> does haWiki work with literate style?
08:45:30 <shapr> it's using enscript
08:45:36 <shapr> so if enscript does...
08:45:56 <Igloo> Hurrah for lemmas! Unfortunately at some point I'll have to prove them.
08:46:24 <Marvin--> Igloo: amen to that
08:46:38 * Marvin-- does have a FOL prover to help him
08:47:31 <Marvin--> which at least half of the time means I just have to specify the base case and induction step and it does the rest :)
08:48:10 <Igloo> Maybe I should just feed you my lemmas and you can give me an appendix back  :-)
08:48:33 <Igloo> lemmata I guess I should say
08:48:43 <SyntaxNinja> OK I redid main and implemented some other suggestions
08:48:47 <SyntaxNinja> nice to know about addToFM_C
08:48:53 <Marvin--> no thanks, I have enough problems with my own appendix
08:49:05 <Igloo> :-)
08:49:59 <Igloo> "increment" isn't quite accurate really
08:50:13 <Marvin--> SyntaxNinja: it may be a good idea to stay off the 'group' function name, since there's a function in List by that name
08:50:21 <Marvin--> it confused me at first
08:50:27 <Marvin--> "what the heck is he grouping here?"
08:52:28 <Igloo> I think it would be more natural to map (map toLower) $ filter isGoodWord, so group wouldn't need a helper
08:54:05 <Igloo> The $ after sequence_ is redundant too. I'd probably do mapM_ putStrLn [ ... | ... ]
08:54:46 * Igloo stops pedanting and goes back to work  :-)
08:55:26 <SyntaxNinja> yeah, that's a good suggestion
08:55:48 <Marvin--> or you could use putStrLn $ unlines [ ... ]
08:55:54 <SyntaxNinja> funny how quickly even small things can use refactoring
08:56:08 <Marvin--> no kiddin'
08:56:21 <Marvin--> filter isGoodWord  is definitely a good idea
08:56:28 <Marvin--> shows the power of HOF
09:00:12 <SyntaxNinja> there's some kind of bug where it's inserting the string "output left in -" randomly into my code
09:00:28 <shapr> yow!
09:00:34 <Marvin--> SyntaxNinja: I've seen that elsewhere too
09:00:40 <shapr> oh, I know what that is
09:00:42 <Marvin--> sounds like an enscript bug
09:00:47 <shapr> sort of :-)
09:01:04 <Marvin--> or, well, a bug in the communication between enscript and hawiki
09:01:11 <shapr> yes, I think that's it
09:01:26 <shapr> where does it say that?
09:01:44 <Marvin-->               | count1 == count2  = compare word1  wooutput left in -
09:01:44 <Marvin--> rd2
09:01:54 <Marvin--> on the ninja's page
09:02:15 <shapr> the bug is most likely mine, since I hacked the enscript plugin from an old b0rked plugin
09:02:32 * shapr blinks
09:03:03 <Igloo> It didn't used to do that for me, but does now I've reloaded it
09:03:06 <SyntaxNinja> Marvin--: yeah, I should do that filter isGoodWord thing, but I gotta get back to work. I've spent enough time tweaking this :) Thanks.  I should do code reviews here more often.
09:03:16 <vegai> anything like ncurses exist for haskell?
09:03:38 <vegai> hmm, ginsu has something
09:03:39 <shapr> QuickCheck tests might make the benchmark even more delicious
09:03:54 <shapr> too bad I don't have time to write some up right now
09:05:00 <SyntaxNinja> yeah
09:05:06 <SyntaxNinja> funfun
09:06:53 <vegai> or is there a better way for spewing color on terminals?
09:07:39 <Igloo> I have a curses binding under development
09:08:05 <Igloo> You'll need CVS GHC to compile  it currently though. Possibly a CVS checkout from the future.
09:08:26 <Marvin--> incCount will be muchos prettier if the filtering is moved up
09:08:48 * Igloo checks the list. Yup, Simon hasn't replied to my mail about foreign imports
09:09:15 <Marvin--> and you can still do it pointless^H^H^H^Hfree
09:09:51 * Marvin-- fires off a mail to Koen
09:10:05 <SyntaxNinja> Marvin--: :) 
09:10:09 <Igloo> Eeek, TH is making types with internal foralls
09:10:09 <SyntaxNinja> nono, gotta work
09:12:03 <Igloo> Ah well, at least it lead to an easy-to-fix bug
09:14:04 <SyntaxNinja> Igloo: a bug?
09:14:34 <SyntaxNinja> oh, in TH
09:14:45 <Igloo> No, in hcurses
09:14:57 <SyntaxNinja> IC
09:15:41 <Igloo> I was assuming types were either "t1 -> t2" or "IO t". Oh, actually, maybe the forall was at the outside as I wouldn't have handled it there either. Anyway, fixed regardless :-)
09:16:06 <Marvin--> you're not making sense :)
09:16:46 <Igloo> Which bit?
09:17:06 <Marvin--> never mind, I don't know what you're talking about at all anyway
09:17:28 <Igloo> My curses binding walks over type in foreign imports to change   IO t   to   io t   and   ChType   to   ch
09:17:41 <Igloo> Only it was breaking on ForallT
09:17:49 <Marvin--> oh
09:21:46 * Marvin-- has 6666 mails in the SPAM folder
09:22:28 <shapr> yikes
09:22:43 <Marvin--> maybe I should clean that up One Of These Days
09:24:16 <Marvin--> man, I'm getting fed up with this
09:24:33 <Marvin--> you can tell I'm way too unstructured about this just by looking at my cwd
09:24:34 <shapr> I keep meaning to delete my spams also
09:24:49 <shapr> but I figure I'll wait till it reaches 20k spams
09:24:53 <Marvin--> .../report/examples/3.isort/new/temp/new/prf
09:24:54 <shapr> that should be tomorrow, I think
09:29:57 <SyntaxNinja> KiloSpams!!
09:30:42 <Marvin--> that's kiloSpams thank you very much
09:36:11 <det> ooh, I like term
09:36:17 <det> that term
09:56:22 <shapr> hi lewis_m 
09:56:40 <lewis_m> hey saphr
10:07:00 <shapr> lewis_m: have questions? learning Haskell?
10:14:52 <lewis_m> shapr: I am learning Haskell, and I did have questions when I joined, but I think I've resolved the problem by myself :)
10:15:27 <shapr> ah, ok
10:15:35 <shapr> if you think of more questions, feel free to ask them
10:15:54 <Marvin--> ah, the best kind of questions :-)
10:47:17 <rickjames> can some one tell me why i am getting a type error
10:47:20 <rickjames> testStat = do putStr "Enter file path for statistics>> "
10:47:20 <rickjames> 	      filename <- getLine
10:47:20 <rickjames> 	      text <- readFile filename
10:47:20 <rickjames> 	      putStr "Number of characters in file: " ++ show (length text)
10:47:20 <rickjames> 	      putStr "Number of lines in file: " ++ show (numLines text)
10:47:20 <rickjames> 	      putStr "Average line length: " ++ show (avgLineLength text)
10:47:22 <rickjames> 	      putStr "Maximum line length: " ++ show (maxLineLength text)
10:47:25 <rickjames> 	      putStr "Minimum line length: " ++ show (minLineLength text)
10:47:26 <rickjames> 	      putStr "Number of blank lines in file: " ++ show (numBlankLines text)
10:48:00 <mattam_> you're missing ; on all lines ?
10:48:09 <shapr> huh?
10:48:42 <rickjames> why would i need semicolon???
10:48:57 <shapr> I don't think you do need a semicolon
10:49:04 <rickjames> me either
10:49:11 <shapr> what's the type error?
10:49:32 <rickjames> *** Expression     : putStr "Number of characters in file: " ++ show (length tex
10:49:32 <rickjames> t)
10:49:32 <rickjames> *** Term           : putStr "Number of characters in file: "
10:49:32 <rickjames> *** Type           : IO ()
10:49:32 <rickjames> *** Does not match : [Char]
10:50:02 <shapr> oh
10:50:13 <mattam> really, semicolons aren't needed ?
10:50:19 <shapr> put parentheses around the part after putStr
10:50:26 <shapr> because function calls bind so tightly
10:50:40 <shapr> it thinks you want putStr "Number of ..." then other stuff
10:50:48 <rickjames> you mean....
10:51:02 <shapr> putStr ( <everything else> )
10:51:09 <rickjames> putStr "soemthing" ++ (show 34)
10:51:24 <shapr> putStr ("soemthing" ++ (show 34))
10:51:25 <rickjames> ok
10:51:29 <shapr> or putStr $ "soemthing" ++ (show 34)
10:51:32 <shapr> which means the same thing
10:52:03 <rickjames> great thanks
10:56:31 <Marvin--> rickjames: you probably want putStrLn
10:56:41 <Marvin--> and you don't need the parentheses around show 34
10:56:48 <Marvin--> putStrLn $ "Something: " ++ show 34
10:56:58 <Marvin--> you could also have a look at the function unlines
10:59:15 <rickjames> marvin: yeah i realized that when it ran the first time
10:59:41 <rickjames> thanks
11:01:15 <mattam> shapr: oh well, i have some things to uncluter now :)
11:01:33 <Marvin--> mattam: you never heard of the layout rule?
11:01:42 <mattam> i did
11:02:05 <mattam> but when i wrote the first parsec parser, i got: "Parse error in pattern"
11:02:12 <mattam> so i added a semicolon
11:02:13 <shapr> mattam: yah, one way I learn fast is by giving wrong answers to someone else and getting corrected.
11:02:17 <Marvin--> well, apparently you didn't hear enough :-)
11:02:45 <Marvin--> shapr: sneaky
11:03:01 <mattam> and i also remembered some ; at the begining of lines in some papers using do notation
11:03:28 <mattam> so i just thought 'i have to do this on every line', and i did
11:04:00 <Marvin--> only if you want to completely ignore the layout rule :)
11:04:10 <mattam> yeah
11:04:43 <mattam> how do you insert a case expression using the layout rule ?
11:05:08 <Marvin--> just line up the patterns
11:05:26 <mattam> nm, wrong indentation
11:12:20 <musasabi> If I have one form with a pattern guard how would I speficy another which should match if the first doesn't e.g. instead of "foo n = if n < 2 then A else B" "foo n | n < 2 = A \n foo n <what here> = B"
11:15:44 <Marvin--> a) that's not pattern guards, it's just regular guards
11:16:05 <Marvin--> b) in this particular case you can let  <what here>  be empty
11:16:52 <Marvin--> as a matter of fact,  "foo n = if n < 2 then A else B"  is the exact semantics of  "foo n | n < 2 = A \n foo n = B"
11:18:03 <Igloo> In general " | otherwise = " is what you want
11:18:31 <musasabi> ok thanks
11:18:52 <Igloo> But if you don't want to share a where clause you can just make it a separate clause, like Marvin said
11:20:44 <Marvin--> well, saying  "foo n | otherwise = B"  is kinda pointless
11:20:53 <Marvin--> the normal way of writing it is, in full
11:21:12 <Marvin--> foo n | n < 2 = A
11:21:12 <Marvin-->       | otherwise = B
11:22:33 <Igloo> Ah, yes, I didn't notice the "foo n" was repeated in the question
12:01:18 * Marvin-- goes back to watching snooker
12:09:03 <Marvin--> gah, I can't put all of this crap in the appendix, it's a gazillion of proofs
12:15:24 <Marvin--> and half of the lines in the proofs are completely uninteresting :)
12:15:50 <Marvin--> 53: (leInt x y) /= True  |  --lt_all(x,ys)  |  --(y :: ty_Peano)  |  --(x :: ty_Peano)  |  --(ys :: [ty_Peano]) : pm(44,33)
12:15:50 <Marvin--> 56: (leInt x y) /= True  |  --lt_all(x,ys)  |  --$true  |  --(x :: ty_Peano)  |  --(ys :: [ty_Peano]) : rw(53,39)
12:15:50 <Marvin--> 57: (leInt x y) /= True  |  --lt_all(x,ys)  |  --$true  |  --$true  |  --(ys :: [ty_Peano]) : rw(56,40)
12:15:50 <Marvin--> 58: (leInt x y) /= True  |  --lt_all(x,ys)  |  --$true  |  --$true  |  --$true : rw(57,38)
12:15:51 <Marvin--> 59: (leInt x y) /= True  |  --lt_all(x,ys) : cn(58)
13:02:55 * XTL curses perl
13:04:05 * stepcut kicks perl in the nads
13:05:32 * monotonom locks perl in a dark room.
13:06:03 * vegai comforts perl.
13:06:11 <vegai> there, there. It's not your fault you suck
13:06:15 <monotonom> I am the most evil of you all, hahahahha....
13:07:11 * stepcut blames it all on weird al
13:07:17 <Marvin--> heh
13:08:13 <XTL> On debian you can almost forget how bad it is.
13:08:48 * XTL tried to install http://www.linpro.no/projects/munin/ on RH without wrecking anything.
13:31:32 <shapr> @yow !
13:31:32 <lambdabot> Well, I'm a classic ANAL RETENTIVE!!  And I'm looking for a way to
13:31:32 <lambdabot>  VICARIOUSLY experience some reason to LIVE!!
14:33:42 * maihem is in a comfortable tunnel like hall with a perfectly round green door like a porthole.
19:30:43 <wglwill> hey there, anyone around who wouldn't mind helping me understand something?
19:31:03 <Pseudonym> Understanding is for wimps. :-)
19:31:24 <Pseudonym> Hint: Just ask.
19:31:29 <wglwill> heh ok
19:32:38 <wglwill> well, i guess my problem is i need to learn a certain programming methodology because i'm not sure how to work with data with haskell's single assignment, i completely understand the reason for single assignment and i don't have a problem with it, but i just don't know how to work with it
19:32:54 <wglwill> like say for example i make a simple paint program, the person loads an image and haskell stores the pixels in a matrix
19:33:09 <wglwill> as the user paints i need to store those changes
19:38:36 <wglwill> is the answer to my question something too complicated to explain simply?
19:52:58 <monotonom> Alright, the short answer: Paul Hudak's The Haskell School of Expresssion is a good book to read on this.
19:55:00 <wglwill> i see, i've asked a broad question then
19:55:53 <monotonom> Although I know the answer, my exposition on this topic is very bad and scary.  Hudak explains it very accessibly.
19:56:23 <wglwill> does it have to do with treating the data as a state?
19:56:30 <monotonom> Yes.
19:57:01 <wglwill> ok, so i'll have to use some kind of monad to manipulate it?
19:57:12 <monotonom> Yes.
19:58:03 <monotonom> Hudak makes monads look friendly and easy.  I make monads look abstract and intimidating. :)
19:58:55 <wglwill> actually, i think i have an idea, it talks about something sort of like this in general terms in a monad tutorial i read, i just didn't realize it
19:59:03 <wglwill> state transformers
19:59:46 <wglwill> thanks for the help, i have a lead to follow now :)
20:00:19 <monotonom> You will use an IO monad. It provides facilities for both getting user input and keeping a state.
20:30:26 <SamB> a value of type IO a is a computation which, when performed, yields a value of type a, potentially doing I/O in the process
22:25:10 <Gahhh> anybody around to answer a question ?
22:25:28 <Pseudonym> It would be easier if you just asked.
22:25:33 <Pseudonym> Saves you some typing.
22:25:41 <Gahhh> heh
22:25:42 <Etaoin> not much
22:26:03 <Pseudonym> OK, saves _me_ some typing in having to explain this and then argue about it with you.
22:26:05 <Pseudonym> Better?
22:26:09 <Etaoin> yes
22:26:12 <Pseudonym> Cool.
22:26:36 <Gahhh> well, I am looking for some reading material, preferably online that explains pro's and cons of functional programming in general. Could be haskell as well.
22:27:33 <Pseudonym> "Why Functional Programming Matters" by John Hughes is good.
22:27:42 <Pseudonym> I'd give you a link, but my proxy is down atm.
22:27:46 <Pseudonym> Google knows all, though.
22:28:03 <Gahhh> I read that
22:28:19 <Gahhh> I was not satisfied
22:28:23 <Pseudonym> There are some other links on haskell.org.  There's a good paper about a programming challenge.
22:28:32 <Pseudonym> Curse this proxy.
22:28:36 <Pseudonym> They just put it in today.
22:28:45 <Gahhh> do any of you write in FP at work ?
22:29:10 <Pseudonym> Do you mean "do I do it while at my desk", or "do I get paid for it"?
22:29:15 <Gahhh> get paid
22:29:19 <Gahhh> well
22:29:27 <Pseudonym> I believe shapr does a bit.
22:29:38 <Gahhh> if you write it for work related purposes even though your boss doesn't know you do or doesn't care, it also counts
22:29:41 <Pseudonym> I did once.
22:30:04 <Gahhh> what do you program in at your job ?
22:30:25 <Pseudonym> C++
22:30:33 <Pseudonym> Mostly.
22:30:38 <Gahhh> ok, so do I
22:31:05 <Pseudonym> Oh?  What do you do?
22:31:13 <Gahhh> I am a software engineer
22:31:20 <Gahhh> recently getting interested in FP
22:31:22 <Pseudonym> I worked out that much.
22:31:40 <Gahhh> what exactly do you want to know ?
22:31:45 <SamB> what an awful job title
22:31:59 <Pseudonym> What kinds of products you work on.
22:31:59 <Gahhh> well, HR people should work out a sexier title
22:32:23 <Pseudonym> I'm "software developer", but I seem to do more engineering than anything else.
22:32:36 <Gahhh> yeah I hear you
22:32:41 <Gahhh> I am like that
22:32:46 <SamB> how about Programmer?
22:33:07 <Gahhh> however, I have some freedom in writing stuff that doesn't get released. For instance, I crunch numbers
22:33:13 <Pseudonym> Ah, cool.
22:33:22 <Pseudonym> We don't have many numbers around here.  Mostly words.
22:33:57 <Gahhh> I can say 50% of the software I write doesn't get released, yet it either tests or verifies(err) released code/hardware
22:34:17 <Gahhh> so I can write that part in haskell if I wanted to
22:34:30 <Gahhh> which is why I am asking around
22:34:45 <Pseudonym> Cool.
22:34:58 <Gahhh> I am happy with python at the moment
22:35:21 <Gahhh> but I played around a bit with its "FP" extensions, so I got interested
22:35:39 <SamB> python is also good
22:35:42 <Pseudonym> Well, if nothing else, functional programming has made me a much better C++ programmer.
22:36:08 <Gahhh> well, I believe in value of learning it even though I may not apply it ever
22:36:33 <Gahhh> but I am concerned that it could be a toy of some academic circle
22:37:01 <SamB> it definately changed the way I think
22:37:59 <Gahhh> do you feel equally comfortable with it, or find yourself looking for constructs that exist in C++ et al, or do you wish you could ditch C++ ?
22:38:45 * SamB has no desire to learn C++ any more than he has
22:39:24 <SamB> actually, I am a rabid C++ hater
22:39:29 <Gahhh> heh
22:39:39 <Gahhh> I threw in C++ because he mentioned it
22:39:49 <Gahhh> what would you write in, if it was your call ?
22:40:49 <dennisb> Gahhh: it's simply different tools, it's not just the language that you choose. Other things like for example support libs are important
22:41:11 <Gahhh> true
22:42:05 <dennisb> most of the people here knows a lot of languages but love haskell for it purity and the cool stuff. We cant use it for everything, mostly because library xyz has no haskell binding, but we love it anyway :-)
22:42:17 <dennisb> well, that's my guess about the people here
22:42:49 <SamB> actually, since I'm still in highschool, it is my call -- but I haven't had a lot of programs to write. I would probably write in Python with maybe some C or Pyrex to bring in C libraries...
22:42:52 <Gahhh> I understand that. Fortunately my stuff doesn't require sophisticated libs or toolkits, etc.
22:43:56 <Gahhh> and I love to be able to write code in a language my coworkers do NOT understand, heh
22:44:00 <dennisb> Gahhh: yes, there are lots of programs like that. and as Pseudonym said, knowing FP makes you see different solutions then you maybe did before, good when programming in every language
22:44:37 <Gahhh> I can see that benefit. But, would you prefer FP in general excluding library support issues ?
22:44:50 <SamB> Gahhh: do they understand python yet?
22:44:56 <Gahhh> no they dont :)
22:45:01 <dennisb> for most things, yes
22:45:07 <Gahhh> thx dennisb
22:45:53 <Gahhh> I suppose I'll take the red (or blue?) pill and try haskell for myself
22:46:01 <dennisb> but not all in lazy languages like haskell, especielly low level stuff where memory usage are important
22:46:40 <Gahhh> well, I assume that is because compilers haven't got smart enough for that kinda stuff yet ?
22:47:30 <SamB> well, also, there are a *lot* of pointers
22:47:37 <dennisb> laziness makes it hard also, but there are other FP languages like ML that are not lazy
22:48:14 <SamB> for instance, strings are linked lists of chars, and chars are boxed
22:48:23 <Gahhh> hmm
22:48:24 <dennisb> but laziness is nice for other programs, the right tool for the right job. Sometimes C is the right tool
22:48:28 <SamB> (in Haskell, that is)
22:48:40 <Gahhh> well, performance issues don't bother me for a while
22:49:09 <Gahhh> I spend more time writing the program than it takes for the program to run
22:49:12 <SamB> I don't think I am capable of writing anything entirely in C...
22:49:17 <dennisb> Gahhh: I just don't want to put your expectations up too high :-)
22:49:48 <Gahhh> Nah, you cannot, believe me :)
22:49:51 <dennisb> It is cool but it does not solve all problems in the world
22:49:55 <Gahhh> "take this silver bullet ! "
22:50:41 <Gahhh> not that I am an OO fan, but does FP work well with FP, or are they incompatible, or what ?
22:50:47 <Gahhh> err, FP with OO
22:51:31 <SamB> certainly it does nothing to improve the performance of mplayer
22:51:57 <Gahhh> it = OO in mplayer ?
22:52:10 <SamB> well, it doesn't work too well with OO from what I can see, but it has some similar features
22:52:22 <dennisb> well, Haskell is a bit different and if you ask me it's hard to compare it with OO languages. You don't work with objects like that. But there are FP languages that are more OO. There is even a variant of haskell called O'Haskell
22:52:37 <SamB> err, I am lagged.
22:52:41 <Gahhh> there is objective caml too
22:52:43 <dennisb> but it's just an academic language to see what the mix of FP and OO would be
22:53:15 <Gahhh> I tend to think OO is overrated anyways
22:53:18 <SamB> what I meant was FP/Haskell/Laziness would not be good for playing videos on a PII 450 ;-)
22:53:29 <dennisb> you don't need as much OO in a language like haskell, there are other constructs that better solve some of the things OO is used for
22:53:58 <dennisb> SamB: I use mplayer on my 300MHz laptop, it works great to play divx'es
22:54:22 <Gahhh> I doubt that divx filters are written in anything but c/c++
22:54:53 <SamB> dennisb: hmm. I must need to tune it better or something. anyway, if it was written in haskell that would certainly not help matters ;-)
22:55:35 <SamB> although I can't help but hope that someday it could help matters
22:56:15 <Gahhh> I am guessing that the mpeg-like algorithms are described in a procedural manner
22:56:33 <Gahhh> after all they must be coming from signal processing people
22:56:37 * SamB halls himself off to bed much too late
22:56:41 <dennisb> in the beginning of the OO era OO was used for everything. for example, if you wanted a list you made your object an instance of a Node and then you could put it in a linked list. That's the wrong way to think about lists. Lists are containers that can contain any value
22:56:57 <ozone> Gahhh: you can integrate OO and FP right now to a limited extent
22:57:07 <ozone> well, not even limited
22:57:12 <ozone> let me rephrase
22:57:19 <dennisb> In fact, one can program OO in any language, even in C
22:57:28 <dennisb> (I do that all the time)
22:57:32 <ozone> if you want to have both F and OO paradigms (with language support), that's no problem
22:57:37 <ozone> e.g. o'caml, nemerle
22:57:41 <Gahhh> dennisb: why do you do that all the time ?
22:57:50 <SamB> dennisb: clearly. or else python wouldn't work very well!
22:57:54 <dennisb> because I sometimes write GTK programs
22:58:20 <ozone> Gahhh: there's still some reason going on about whether you can actually encapsulate the OO paradigm in a functional framework
22:58:26 <Gahhh> dennisb: it was a long time ago when I wrote gtk, but what about gtk is OO ? (I mean not gtk++)
22:58:27 <ozone> s/reason/research/
22:58:28 <SamB> ozone: where is this o' in o'caml?
22:58:54 <Gahhh> samb: objective
22:59:03 <ozone> Gahhh: i.e. you can implement OO (classes, inheritance etc) using only the features given to you in a functional language
22:59:19 <SamB> Gahhh: I can't help but wonder if GTK-- isn't less OO than GTK+
22:59:22 <dennisb> Gahhh: it has am object system (called gobject) that contains most OO-features encoded in C
22:59:23 <det> Gahhh: GTK is written to use Gobject, which is a C library for objects
22:59:34 <ozone> dennisb: yeah, and it's totally horrible. :)
23:00:08 <ozone> SamB: have you ever used gtk--?
23:00:18 <ozone> (and gtk+)
23:00:20 <dennisb> it's not nice, but if you look at it from above and don't look at all details it's just another OO program
23:00:30 <Gahhh> ozone: in that sense, would you envision OO+FP surpassing imperative+OO ?
23:00:35 <SamB> Python probably does a better job of OO in C, although there is too much leakage in the area of metaclasses...
23:01:07 <dennisb> you just have to type a lot in C to do things that are one liners in OO programs
23:01:14 <dennisb> OO languages
23:01:43 <dennisb> we have gotten far from haskell now :--)
23:01:50 <Gahhh> my fault, entirely
23:01:56 <ozone> Gahhh: well, i wouldn't call it 'surpassing'
23:02:08 <dennisb> but we do it all the time, we love to discuss languages
23:02:43 <Gahhh> well, in my limited experience, people who know even what haskell is tend to talk about languages in general a lot
23:03:16 <dennisb> that's the thing. It's not a mainstream language yet
23:03:33 <Gahhh> "yet" or "ever" ?
23:03:51 <dennisb> it maybe never will be, but there will be other even cooler functional languages in the future
23:04:23 <ozone> Gahhh: remember, people said the same thing about OO when it was still a research idea
23:04:45 <Gahhh> ozone: I am still not convinced about OO's strengths
23:04:53 <Gahhh> I am sure that made me sound like a newbie
23:05:30 <SamB> Gahhh: I'm not so sure about them either, anymore
23:05:35 <dennisb> it's a tool. as all tools it was overused a lot in the beginning
23:06:06 <Gahhh> I recently interviewed a guy who was all about OO, and he was using it wrong.
23:06:07 <dennisb> if all you have is a hammer everything starts to look like a nail
23:07:12 <Jerub> I have long rants about OO
23:07:16 <Jerub> especially on #php
23:07:25 <Gahhh> did you post them on forums anywhere ?
23:07:31 <Jerub> "PHP5 has much better OOP, we have PRIVATE now!"
23:08:05 <Gahhh> Jerub: I don't know php; were you bashing php or OO in general ?
23:08:29 <SamB> who cares about PHP?
23:08:31 <dennisb> we bash in general :-)
23:08:43 <Gahhh> even bash haskell ?
23:08:50 <dennisb> why not
23:08:55 <SamB> and again, why is it that you are bashing php5 only?
23:09:04 <Gahhh> hell yeah. a bash-friendly, no holds barred channel.
23:09:22 <SamB> haskell has stupid maths
23:09:31 <SamB> someone should fix them
23:09:34 <Jerub> Gahhh: at the moment, I'm holding a 1 man crusade on "Enforced Documentation" != "Object Orientated Programming"
23:09:51 <Gahhh> Jerub: enforced documentation as in Doxygen style ?
23:10:23 <Jerub> as in declaring a method as private 
23:10:32 <Gahhh> ah
23:10:46 <Gahhh> private methods are so "cool"
23:10:50 <SamB> _ is much simpler, I think
23:11:29 <Gahhh> well, there are OO languages that don't offer private anything
23:11:36 <musasabi> I would like a scheme where one would add various "tags" to the methods and when importing specify which tags to import.
23:12:03 <Gahhh> musasabi: I want unix style rwx- flags and a GUI interface in the editor where I click on them.
23:12:33 <SamB> Gahhh: that doesn't make any sense
23:12:51 <Jerub> exactly. the concept of having a lagnuage that enforces private vs. public is doing "enforced documentation"
23:13:01 <SamB> although you might want to look at lambdamoo
23:14:28 <Gahhh> SamB: I would like it if the editor (e.g., in C++) showed private/protected/public using widgets, showing different colors to indicate base class stuff, and I could just click on what I want instead of manually typing all that mumbo jumbo.
23:15:08 <Gahhh> that probably has nothing to do with language itself, but I think verbiage distracts me
23:15:38 <wglwill> hey guys, mind if i interject with a newbie question :)
23:16:14 <Gahhh> not at all
23:16:29 <SamB> Gahhh: and I would appreciate it if C++ would fall into disuse
23:16:36 <wglwill> ok, i'm trying to understand the code here http://haskell.org/hawiki/TyingTheKnot but...
23:16:52 <wglwill> i'm wondering if this line is using arrows mkDList xs = let (first,last) = go last xs first
23:16:57 <wglwill> because i looked up first and last
23:17:00 <musasabi> wglwill: newbie questions are good, as they provide answers which help even non-newbies
23:17:02 <wglwill> and first had something to do with arrows
23:17:38 <wglwill> did he just happen to name that variable first or is it actually this arrow related thing
23:17:54 <Jerub> what?
23:18:05 <ozone> wglwill: just happened to name that variable 'first', i believe
23:18:13 <wglwill> ok then
23:18:16 <Jerub> oh, nvm, I read 'first' as 'fst' there.
23:18:30 <dennisb> yes, this is just standard haskell
23:18:45 <wglwill> ok, i was worried because i'm not ready for arrows yet i don't think
23:18:49 <dennisb> but maybe not a newbe program
23:19:04 <SamB> wglwill: well, first and last are being bound there, so its no relation to anything
23:19:07 <dennisb> newbie even
23:19:15 <ozone> not many people are ready for arrows. :)
23:19:59 <wglwill> do you guys know what they are used for?
23:20:13 <wglwill> i've just heard them referenced a few times, i have no idea what they are or what they would even be useful for
23:20:20 <SamB> I don't understand them, but I have used functions from the module anyway, with a less polymorphic type
23:21:20 <wglwill> ok, one quick question, in that let statement what's being matched against the (first, last) pattern, xs?
23:21:56 <wglwill> or, wait, that wouldn't make sense would it?
23:22:09 <dennisb> wglwill: the function go is called and the return from go is a pair
23:22:29 <wglwill> ok and that is being matched and bound to (first, last)?
23:22:35 <dennisb> yes
23:22:58 <dennisb> the tricky part is that first and last is also inputs to the function
23:23:02 <wglwill> now that's kind of confusing because first and last are on both sides of the =
23:23:07 <wglwill> heh
23:23:15 <wglwill> is it recursive?
23:23:24 <SamB> only in a lazy functional language can you get away with that sort of thing
23:23:38 <dennisb> but it can be inputs since it's a lazy language, you don't know yet exactly what first and last is that you pass in as arguments, but you can do it anyway
23:24:25 <wglwill> now i need to understand this code if i need to do any kind of complicated linked lists or graph data structures right?
23:24:26 <dennisb> as long as it's not used inside the function until it have got a value it's no problem
23:24:53 <wglwill> that's why i'm reading it, i'm working towards my first useful program having some of those types of data structures, i'm reading this because it said something about that type of data structure
23:24:57 <dennisb> not really, 99.9% of the programs you write with normal lists
23:25:23 <dennisb> this is not a newbie program
23:25:29 <wglwill> like this data structure for instance http://www.flipcode.com/tutorials/tut_halfedge.shtml
23:25:44 <wglwill> i will soon be attempting to implement something similar to that
23:26:58 <Gahhh> graphics stuff in haskell ?
23:27:01 <wglwill> yes
23:27:06 <wglwill> that's my primary interest
23:27:35 <Gahhh> I am a newbie as well, but why are you interested in doing graphics in haskell ? Wouldnt performance be an issue ?
23:27:44 <dennisb> traditionally, graph algorithms have been the most difficult to model in haskell. They are typically imperative that you create a graph and you add/move edges. Things that are imperative in its nature maybe should be written in an imperative style. In haskell you can do that using monads
23:28:04 <wglwill> i will be using opengl so it shouldn't be too much of an issue
23:29:00 <wglwill> have you ever heard of wings3d?
23:29:08 <Gahhh> umm no
23:29:11 <Gahhh> what is it ?
23:29:18 <dennisb> haskell do have a nice imperative part also, where you can do things like allocating memory, update variables and so on. You usually stay away from that in the beginning otherwise it might confuse beginners, but it's not hard in itself
23:29:20 <wglwill> it's one of the most popular modellers, used by hobbyists and professional cg artists alike
23:29:24 <wglwill> written entirely in erlang
23:29:53 <SamB> why doesn't my debian wings3d work?
23:29:53 <wglwill> mirai, a pioneering program in subdivision surface modelling and animation is also written entirely in lisp
23:29:54 <Gahhh> dennisb: why is it hard to model graph algorithms ? are they not very mathematical ?
23:30:14 <wglwill> so is it going to be difficult for me to create graph algorithms?
23:30:42 <dennisb> wglwill: it might be a little bit difficult to make it very efficient
23:31:17 <dennisb> you can always model it like putting a name on each node, and all the edges are a list of pairs containing names
23:33:27 <dennisb> in pure haskell values are not updated, if you have a graph and want to add an edge to that graph you would create a copy of the old graph with the new edge and the old graph will be garbage colleted. It's usually essential that you update the one and single graph in some algorithms
23:33:31 <SamB> there are more effective ways, methinks, to write such things
23:33:43 <dennisb> other problems you create the graph once and work on it, that might suit haskell much better
23:33:51 <SamB> (than names)
23:34:03 <dennisb> SamB: totally agree
23:34:20 <Gahhh> dennisb: can you not do something about that via tail recursion ?
23:34:26 <dennisb> it's just the simplest way that anyone can understand directly, and also anyone can see it not optimal
23:34:28 <wglwill> samb do you mean effective ways in haskell, or do you mean effective ways as in i should be using another language :)
23:34:43 <musasabi> adding edges to a graph is cheap in haskell
23:35:05 <dennisb> musasabi: because you share the structure of the old graph
23:35:12 <musasabi> dennisb: yes
23:35:33 <wglwill> do you guys know of some resources that discuss graphs in haskell in more detail?
23:35:39 <dennisb> but it's hard to do it anyway because the pointers are just not movable like in C
23:35:49 <wglwill> sounds like something i need to read up a little more on
23:36:07 <musasabi> http://www.google.com/search?q=graph+haskell
23:36:10 <SamB> wglwill: in haskell.
23:36:17 <musasabi> that contains quite a lot of pointers ;)
23:36:32 <dennisb> If I would work with graphs I would use something like the ST monad
23:37:04 <dennisb> (at least for some algorithms)
23:37:30 <ozone> Gahhh: the problem is that "purely functional" graphs don't allow update-in-place
23:37:55 <ozone> so a lot of algorithms become more expensive because you're forced to make copies where you normally don't want to
23:38:06 <ozone> which is why dennisb advocates using the ST monad
23:38:11 <musasabi> looking at the haskell graph libraries would be a good way to start
23:38:16 <dennisb> unless you use the ST monad where you can do updates in place
23:38:35 <wglwill> ok so in summary, can impelmenting graph algorithms in haskell be better than similar graph algorithms in imperative languages?
23:38:36 <SamB> I don't understand how I would code a graph purely at all
23:38:56 <ozone> SamB: there's some papers by ralf hinze about that, google for ralf hinze graph ...
23:39:15 <wglwill> hmm, i wonder if that might be an interesting area of research for someone someday, it would be really cool if someone figured out how to do graphs really elegantly in pure fp :)
23:39:28 <SamB> however, I should be in bed :-(
23:39:35 <Gahhh> btw, which compiler/interpreters do you people use on Win32/Linux ?
23:40:00 <ozone> ghc/ghci
23:40:06 <dennisb> wglwill: before the monads came along there was a lot of research about it and there was algorithms that no one (so far) could write with the same complexity in pure FP as in an imperative language
23:41:13 <dennisb> it's the same thing as OO we talked about, in the beginning they wanted everything to be functional and pure. But now people are happy to mix imperative and functional
23:41:29 <dennisb> some people even say that haskell is the best imperative language
23:41:57 <wglwill> because of how it generalizes imperative in a fp context?
23:42:13 <dennisb> it does not mean that functional and pure is not important, just that some problems are better solved in an imperative way
23:42:16 <SamB> Win32/Linux must bother RMS a lot
23:42:38 <Gahhh> huh ?
23:43:12 <SamB> dennisb: perhaps because the imperativeness is non-virulent?
23:43:42 <dennisb> maybe
23:44:04 <Jerub> Debian/Win32?
23:44:32 <Gahhh> I dont know what he's talking about
23:45:07 <SamB> It was an awful joke. awful jokes are a family tradition
23:45:33 <wglwill> has anyone used the xml libraries for haskell?
23:46:12 * SamB restrains himself from making another awful joke
23:46:19 <dennisb> http://www.postgresql.org/docs/7.4/static/functions-sequence.html
23:46:28 <dennisb> sorry, wrong window
23:46:35 <Gahhh> SamB: lack of sleep isn't helping, eh ?
23:47:25 <SamB> err, no. I need to get better at extricating myself from IRC conversations
23:53:46 <musasabi> Has anyone implemented pre/postconditions to type classes?
