01:30:03 <shapr> oy
01:30:21 <darius-> vey
01:40:54 * Cale is away: sleeping
01:48:52 <shapr> hey darius- 
01:48:57 <shapr> wassup?
01:56:18 <shapr> @seen wli
01:56:19 <lambdabot> I haven't seen wli
01:56:31 <shapr> @seen saz
01:56:32 <lambdabot> saz is in #haskell.
01:56:38 <shapr> @seen phillipa
01:56:39 <lambdabot> I haven't seen phillipa
01:56:51 <shapr> @seen rubix
01:56:51 <lambdabot> rubix is in #haskell.
01:57:13 <shapr> good morning #haskell!
01:58:23 <saz> hello shapr 
01:58:23 <darius-> hey shae - going to bed for the moment
02:00:55 <shapr> g'night darius- 
02:01:06 <shapr> g'day saz
02:22:04 <eivuokko> Is there a good tutorial kinda thingy what diffrent aspects one might want to take into account when building haskell programs and libraries (packages) (especially in Windows).  It's hard to grasp what things are stored in .a, .hi and what kind of rules .lhs, .pphs require as well as building dependency info?
02:22:57 <eivuokko> Building small progs that depend on no, or single, external libraries is easy enough.  But getting things work in Windows, without cygwin, is kinda pain.
02:26:16 <shapr> the file formats are mentioned in the GHC manual
02:27:36 <shapr> I haven't tried to build in win32, but it is becoming a more common request
02:28:14 <shapr> seems like a wiki page would be handy
02:29:04 <eivuokko> The pain comes from the fact that I feel my lack of knowing haskell comes against me when I try to get libs to build.  HaskellDB being latest pain.
02:29:48 <eivuokko> Yet, building libs shouldn't require, imho, ability to rewrite them as I fee, based on errors I got.
02:29:55 <eivuokko> *feel
02:31:06 <shapr> I agree, it should just work.
02:32:36 <eivuokko> I am trying to make easy-to-install system for generating "reports" from genealogical (if that's the word) database, which could be altered by more technical people (not programmers) quite easily.  Writing such system in haskell is easy to envision except that I can't get things installed myself :)
02:32:41 <shapr> I would start a wiki page, but haskell.org seems offline for the moment
02:35:29 <shapr> there's the #haskelldb channel, and I've seen some win32 support happen there
02:36:10 <eivuokko> Oo, not everything Haskell related is on this channel.  Thanks.
02:37:55 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","haskelldb 0.7 released","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell"]' by shapr
02:39:51 <saz> what's darcs?
02:40:00 <earthy> versioncontrol system
02:40:02 <earthy> *good* one
02:40:03 <saz> ah
02:40:09 <saz> ooh, a good one?
02:40:11 <saz> how so?
02:40:33 <earthy> http://www.abridgegame.org/darcs/ for the URL
02:40:43 <earthy> and well... it is simple and distributed
02:40:59 <earthy> i.e.: I maintain a webpage on my laptop using darcs.
02:41:06 <earthy> I copied that repository over to the server
02:41:17 <shapr> and I use darcs for all my production wosk
02:41:18 <earthy> now, when I edit my local repository, I use  darcs record
02:41:25 <earthy> to put the new version in.
02:41:39 <shapr> work
02:41:46 <earthy> then, when I'm happy, I can use   darcs push login@remotehost:/path/to/repository
02:41:46 <shapr> darcs is written in Haskell
02:41:59 <earthy> and the new patches are in the remote repository as well
02:42:10 <saz> this sounds pretty neat
02:42:18 <earthy> if I do it with --and-apply  I see them applied even!
02:42:26 <earthy> truly a snap
02:42:29 <earthy> and *very* easy to set up
02:42:47 <skew> it's missing revert <filename>
02:43:00 <shapr> and if a user does an anon checkout, they can still contribute without having to checkout a logged in version later
02:43:36 <skew> other than that it's nice
02:43:38 <earthy> skew: minor. :)
02:43:48 <shapr> is revert <filename> planned for 9.20 ?
02:44:46 <shapr> man, I went to the doc today, he said I should take off work for three weeks and stay away from my keyboard to let my hand heal
02:45:04 <skew> shapr: well?
02:45:10 <earthy> that absolutely sucks
02:45:18 <earthy> but, what are you doing here then, dude?
02:45:20 <shapr> I have deadlines
02:45:30 <skew> shapr: that doesn't sound like talking on IRC to me!
02:45:35 <earthy> yea, or dead hands
02:45:37 <childe> Hello world.
02:45:37 <earthy> your pick
02:45:38 <skew> nor that
02:45:51 <eivuokko> What happened to your hand?
02:46:01 <shapr> left hand RSI
02:46:05 <shapr> hi childe 
02:46:06 <childe> Why not make a Haskell based text editor? Just as the LISP based Emacs?
02:46:25 <childe> Haskell is far more beautiful than LISP and why not
02:46:29 <shapr> childe: no type safe dynloading at the moment
02:46:37 <shapr> childe: soon
02:47:01 <shapr> skew: you're right, irc /= work
02:47:05 <eivuokko> Awww.  That must suck a lot.
02:47:30 <shapr> I've switched to right hand dvorak
02:47:46 <childe> shapr: I think a Haskell based editor will be very cool.
02:47:46 <shapr> so my han is geting better, but I type much slower
02:47:54 <shapr> childe: I agree
02:47:57 <skew> GHCi does typesafe loading, but it's not exposed
02:48:27 <skew> it would be very nice if the bits of GHC were available as libraries
02:48:39 <shapr> skew: it is exposed with Dynamic Loader
02:48:50 <skew> where is that?
02:48:55 <shapr> but it's still not totally type-safe
02:49:04 <shapr> ozone wrote the first version
02:49:22 <skew> do you have any references to the opengl optimization example you mentioned?
02:49:24 <shapr> hram has an extended vorsion
02:49:40 <shapr> it's on the HOpenGL maillist
02:49:43 <skew> I thought GHCi was type-safe, or does that depend on the compiler
02:50:04 <shapr> afaiu, GHCi is only mostly typesafe
02:50:44 <shapr> I do think there's a way around it with template haskell, but it's not certain yet
02:51:35 <skew> shapr: unfortunately haskell.org is down and Curryspondence doesn't include the HOpenGL list
02:51:37 <shapr> skew: iirc, I think that GHCi modules do not share their typetable with statically built modules
02:51:40 <shapr> ah
02:52:04 <shapr> ok, just a moment
02:52:17 <saz> is template haskell anything like c++ templates?
02:52:29 <eivuokko> That's why there's separate ghci lib for packages?
02:52:32 <skew> saz: more like macros
02:52:44 <skew> saz: type classes are more like the templates, I think
02:52:51 <eivuokko> Yea, it's not really anything like c++ templates imho.
02:53:00 <saz> skew: yeah, kinda (about type classes)
02:53:11 <saz> polymorphism in haskell is *so* much nicer
02:57:12 <eivuokko> I guess the common denominator for th and c++ templates is that both have access to typesystem on target language if compared to code generation in general.
02:58:31 <saz> what do you mean?
02:58:38 <shapr> skew: http://shapr.homelinux.net/~shae/hopenglgears
02:59:17 <shapr> "I ran it on slow hardware, and got faster (just slightly) frame rates in Haskell than in C. All with the new version having 20% less code than"
02:59:36 <skew> thanks. I was reading out of the google cache
02:59:53 <skew> but your copy is actually in order
02:59:58 <eivuokko> saz, Just musing.  I guess what I mean is that there's not so much actual common ground except ideas, which are mainly those of code generation or "compiler plugins".
03:01:21 <shapr> eivuokko: GHCi uses dlopen, I think
03:02:00 <eivuokko> shapr, Yea, that'd explain the funny step on package-install that requires using ld.  I kinda wondered what it was.
03:02:09 <shapr> I think that's why GHCi needs .o files, but just building an app doesn't
03:02:13 <saz> eivuokko: i was just wondering what you meant by the target language
03:02:51 <eivuokko> saz, Ah, target language for code generation :)  For c++ templates it's C++ and for TH it's haskell.
03:03:02 <saz> oh, right
03:03:04 <shapr> imho, the coolest part of TH is that you get to arbitrarily mix compilation and execution if you're cheesy enough
03:03:35 <shapr> that's why I think TH can do type-safe dynloading
03:03:36 <saz> shapr: dynamic compilation?
03:04:52 <eivuokko> My smallish usage, and as I've understood, TH needs to be triggered explitly, while C++ templates can be triggered by any function call (which includes conversion operators from user types).  I consider this a big diffrence.
03:05:27 <shapr> saz: http://shapr.homelinux.net/~shae/ProtoTemplateHaskell.hs
03:05:41 <shapr> saz: try running ghc --make on that
03:07:07 <shapr> oops, I may broken that file
03:08:08 <shapr> yes, I did break that
03:08:11 * shapr fixes
03:08:53 <shapr> ok, now it's fixed
03:09:09 <shapr> anyway, it just executes arbitrary code at compile time
03:10:10 <shapr> but, I think you could execute the whole program at compile time and get full type safety
03:10:52 <shapr> needs to to have a way to dynamically import new sources at compile time though.
03:11:03 <saz> ProtoTemplateHaskell.hs:5: parse error on input `|'
03:11:11 <skew> shapr: that might work. are you thinking about a splice that adds some includes and some definitions with a further splice that will take advantage of the newly expanded scope?
03:11:47 <shapr> saz: add -fth
03:12:52 <shapr> skew: yah, if a splice adds more source, you have better type safety
03:12:54 <kosmikus> shapr: maybe you should add {-# OPTIONS -fth #-}
03:13:03 <shapr> kosmikus: yes, thanks
03:13:03 <saz> shapr: ah, works now.. I dont understand the code though
03:13:49 <shapr> it just executes putStr at compile time
03:14:49 <saz> what's the [| |] notation?
03:14:58 <shapr> the hard part of this is that TH doesn't have "import". it would require parsing the source and turning it into a syntax tree that TH  understands
03:15:13 <shapr> I think those are called quasiquotes
03:15:30 <saz> what do they do? just like ""?
03:16:03 <kosmikus> no, it a "give me the syntax tree of ..." operator
03:16:25 <kosmikus> whereas $( ... ) is a "take this syntax tree and execute it" operator
03:16:41 <saz> stupid question.. what's a syntax tree (feel free to tell me to rtfm)
03:16:50 <shapr> so, if you can hardwire the module names, you can wrap your whole module in a qquote
03:16:59 <shapr> that was seafood's spiffy idea
03:17:20 <shapr> but, I want to dynamically add modules
03:17:26 <kosmikus> saz: it's an abstract description of the program which you can manipulate
03:17:34 <eivuokko> Syntax tree=structured datastruture describing what user typed down (or generated).
03:20:21 <saz> ah, right
04:39:20 * Marvin-- reads about go nets
04:48:15 <shapr> I wonder if I can make Zope External Methods in Haskell with skew's PHI
04:51:12 <shapr> skew: do you have some demo code?
04:56:12 <shapr> ah, I see how it works
04:56:12 <shapr> neat
05:06:01 <Shammah> evening shapr :)
05:07:17 <phubuh> afternoon shapr :)
05:11:32 <shapr> greetings!
05:11:54 <shapr> skew's PHI is nifty
05:12:02 <Shammah> phi?
05:12:19 <shapr> very sensible too, call python via the FFI
05:12:33 <shapr> I assume it's Python Haskell Interface
05:12:51 <Shammah> ahh. ok.
05:12:59 <Shammah> python's a nice language
05:15:44 <Jerub> I was learning c++ last night
05:15:47 <Jerub> it was a fun time.
05:15:48 <Jerub> fun fun.
05:16:22 <Shammah> heh, it's been a long long time since I found anything to do with C++ fun.
05:17:10 <sgiMIPS> Jerub: INTERCAL is fun, leanr than.
05:18:00 <Shammah> sgiMIPS: or he could try learning perl... after all it has a cleaner syntax.
05:18:47 <sgiMIPS> Shammah: cleaner?
05:19:12 <sgiMIPS> (scheme) has a clean syntax :-)
05:19:26 <Jerub> ;)
05:19:31 <sgiMIPS> parse error: sparse closing paren!
05:19:33 <Jerub> I'm actually trying to make myself more employable.
05:20:11 <sgiMIPS> Jerub: oh. then learn erlang or c# or php
05:20:42 <Jerub> sgiMIPS: I know php, I want to run and hide from the web.
05:20:58 <Jerub> in fact, I've been writing php for 3+ years for $$.
05:21:12 <sgiMIPS> Jerub: why? Haskell CGI roxorz :-)
05:21:32 <sgiMIPS> (and is notably faster than php)
05:22:38 <Jerub> sgiMIPS: really? php is blindingly fast for many things.
05:24:11 <sgiMIPS> (yea maybe databse lquerys which take one message to the RDBMS)
05:24:40 <shapr> skew: do you plan on making it work the other way as well? will I be able to call Haskell from Python?
05:25:49 <sgiMIPS> given the power of UNIX, you an call anything from anything.
05:26:43 <shapr> I'd like the power of unix pipes combined with algebraic datatypes
05:27:40 <sgiMIPS> well, algebraic data types can be represented by strings, nope?
05:28:07 <shapr> somewhat
05:28:14 <Marvin--> sgiMIPS: the point is that parsing sucks
05:29:23 <phubuh> shapr: in other words you'd like monads and functional composition? :-)
05:35:46 <sgiMIPS> Marvin--: well, loading the "native" representation of the "algebrain datatype" is just as much overhead as effificently implmented parsing.
05:35:56 <sgiMIPS> algebraic
05:36:30 <Marvin--> sgiMIPS: the point is that you want *someone else* to do it
05:37:40 <sgiMIPS> hmm, what about passing memory dumps of data via pipes?
05:38:00 <sgiMIPS> they are 8bit clean, nope?
05:44:59 <shapr> phubuh: yup
05:45:20 * shapr dunno
05:45:28 <shapr> that's a good idea
05:45:57 <shapr> unix sockets with values saved via Binary
05:46:46 * Jerub laughs.
05:47:17 * Jerub is being evil and making people use a gecko based browser in order to see my webcam.
05:47:27 <sgiMIPS> and parsing is only a memcpy then :-)
05:47:50 <sgiMIPS> and hope the languages have the same binayr repr for datatypes :-)
05:48:07 <shapr> there is that minor issue
05:48:25 <sgiMIPS> (which is not true, hence the whole thing wont work . :-(
05:50:02 <sgiMIPS> minor?
05:50:19 <sgiMIPS> oh and an other thing: represent an infinite list in binary ;-)
05:51:37 <sgiMIPS> Jerub: whats wong with geckoe?
05:51:50 <phubuh> myInfiniteBinary = toBinary (repeat 1)
05:52:29 <sgiMIPS> phubuh: yeah but its infinite
05:52:51 <sgiMIPS> so only lazy-to-lazy pipes would work...
05:53:06 <Jerub> sgiMIPS: nothing! I'm just forcing them not to use MSIE :)
05:53:15 <phubuh> That's only assuming you want finite load times
05:53:17 <phubuh> !
05:53:35 <Marvin--> it would be interesting to map lazy haskell lists to lazy python generators
05:53:49 <sgiMIPS> MSIE is Gecko based as well, they just dont dare to admit it.
05:56:38 <sgiMIPS> and there is the speed issue... python-to-haskell pipes would underrun
05:58:44 <kosmikus> shapr: I just tried to compile lambdabot for the first time ever, and I get the following error message when I execute the binary:
05:58:48 <kosmikus> EvalModule/LMEngine.o: unknown symbol `__stginit_TextziParserCombinatorsziParsecziError_'
06:01:36 <shapr> is that the 2.0 release from sf.net?
06:02:26 <sgiMIPS> Parsec \-:
06:02:27 <shapr> I think I get that error also, and that it doesn't usually cause problems
06:02:44 <shapr> though I don't remember any details atm
06:04:13 <kosmikus> that's from darcs
06:04:38 <kosmikus> should I pick the release instead?
06:05:28 <kosmikus> well, I get more after that:
06:05:42 <kosmikus> symbol resolution failed
06:05:42 <kosmikus> couldn't load module GhciModule.o
06:05:42 <kosmikus> Running reader loop...
06:05:42 <kosmikus> Exception: <socket: 3>: hGetChar: invalid argument (Invalid argument)
06:11:42 <shapr> the exception is surprising
06:12:11 <shapr> did you change the nick or server in BotConfig.hs ?
06:12:57 <kosmikus> yes ...
06:13:15 <kosmikus> I changed the nick
06:13:31 <kosmikus> and the autojoins, and the admins
06:15:29 <kosmikus> I now removed the ghci and the eval modules, because those two were apparently causing errors, and I now get:
06:15:32 <kosmikus> Running reader loop...
06:15:33 <kosmikus> Exception: thread blocked indefinitely
06:19:00 <shapr> weird
06:19:46 <kosmikus> should it enter the reader loop before or after connecting to the server?
06:22:12 <sgiMIPS> imho, it can only "read" once connected.
06:22:28 <sgiMIPS> so after.
06:22:33 <kosmikus> yes, but apparently it didn't connect
06:23:33 <sgiMIPS> lambdabot? where is the cvs? :-) (sgiMIPSstarts hacking...)
06:26:15 <shapr> sgiMIPS: look at http://sf.net/projects/haskell-libs
06:27:40 <sgiMIPS> shapr: thanks :-)
06:27:46 <shapr> kosmikus: strange, it should connect
06:28:23 <kosmikus> well, at least it never changed its nick to the specified one or joined the specified channel
06:31:59 <shapr> hm
06:39:42 <Spark> how would a turing machine be implemented in a functional langauge?
06:44:18 <shapr> with a tape monad?
06:46:00 <shapr> pass the tape into a one step interpreter function, make a copy of the tape if required to modify, pass that into another call to the one step function
06:46:23 <Spark> mm
06:46:32 <Spark> can you write that code for me? :)
06:46:48 <shapr> no :-P
06:46:56 <Spark> please
06:47:01 <Spark> pretty please
06:47:10 <shapr> sorry, I'm doing paying work
06:47:20 <Spark> ah
06:49:08 * earthy ponders
06:49:17 <earthy> nope, sed isn't really functional
06:49:34 <earthy> (and is the most recent language I've written a turing machine emulator in)
06:49:54 <Igloo> Sure it is. Gotta love that pattern buffer monad!
06:49:56 <Spark> sed is a dataflow langauge probably :)
06:50:10 <Spark> or reactive functional
06:50:19 <earthy> igloo: ah, but you get to modify it *and* jump in your program
06:50:28 <earthy> i.e.: you not only have a pattern buffer monad but also call/cc
06:50:43 <earthy> (or something entirely but not quite unlike call/cc ;))
06:50:58 <Igloo> jumps are just syntactic sugar for functions and function calls  :-)
06:51:01 <Spark> essentially the operation of a turing machine, is a fold on a list isnt it?
06:51:22 <earthy> no. :)
06:51:45 <Spark> how come?
06:52:09 <earthy> IIRC folds cannot capture every kind of computation
06:52:43 <Spark> hm a turing machine can go backwards and forwards cant it
06:52:47 <earthy> exactly
06:52:54 <Spark> if it can only go forwards you're ok
06:53:02 <Spark> i wonder what hte significance of that is
06:53:04 <earthy> ay, but there's the rub
06:53:46 <Spark> need a counter example for the computability of a unidirectional tape :)
06:54:16 <Spark> ohhh i know
06:54:29 <Spark> you have no way of doing a while loop
06:54:31 <Spark> obviously
06:54:44 <Spark> you have a nice realtime turing machine though
06:55:37 <Spark> if you can do if statements i think
06:56:28 <Spark> s/if //1
07:00:49 <Spark> hm jak whats imperial college computing department like?
07:00:56 <sgiMIPS> loops are not needed at all to be turing complete. consider Prolog
07:01:00 <jak> Hi Spark
07:01:09 <Spark> i have an Msc interview in 2 weeks time :)
07:01:26 <jak> Spark: quiet at the moment (I think they are refurbishing at the moment)
07:01:56 <jak> Is this to start an M.Sc?
07:02:00 <Spark> yeah
07:02:10 <jak> cool -- conversion or advanced?
07:02:14 <Spark> advanced
07:02:23 <Spark> im just finishing a bsc at warwick
07:02:50 <jak> Should be a lot of fun :)
07:02:58 <Spark> hehe
07:03:01 <Spark> what do you do?
07:03:40 <earthy> sgiMIPS: prolog has implicit looping
07:03:44 <jak> I'm in the 3rd year of an attempted phd
07:03:54 <Spark> sgiMIPS: i dont understand how that can be true since otherwise you cannot represent the halting problem :)
07:04:00 <Spark> ah right
07:04:07 <jak> I did my undergrad at Imperial (m.eng)
07:04:16 <Spark> whats the phd about
07:04:59 <jak> Contracting agents, mainly focusing on execution, but also monitoring
07:05:17 <Spark> ah
07:05:26 <Spark> havent done anything on agent systems before :)
07:05:53 <Spark> theyre quite big on that sort of thing at ic arent they?
07:07:32 <sgiMIPS> ?: Non-looping algorithms can also be non-halting, nope?
07:07:44 <Spark> how?
07:08:17 <Spark> if it doesnt loop, it is always advancing towards some goal, and therefore it will either reach it, or possibly skip over it
07:08:22 <sgiMIPS> consider reflexctio...
07:08:44 <sgiMIPS> my god!... r e f l e c t i o n 
07:08:46 <Spark> not advancing is a form of loop i gues
07:08:56 <Spark> whats reflection?
07:09:17 <sgiMIPS> self modifying code
07:09:32 <Spark> hm i think it still applies
07:09:40 <Spark> since the modified code can still not go back on itself
07:09:54 <Spark> lol, if an instruction cannot be executed more than once, the execution time is bounded
07:10:24 <sgiMIPS> consider the rule30 1-dim cellular automatom.
07:10:27 * earthy nods
07:10:37 <earthy> rule30?
07:10:52 <earthy> is that that silly turing-capable CA?
07:11:33 <sgiMIPS> http://en.wikipedia.org/wiki/Cellular_automaton
07:11:58 <Spark> theres a dsp chip on recent creative sound cards that can do audio effects, it can process a bunch of instructions, but it has no goto instruction (it has a skip, i.e. goto n ahead), and this is because it has to run realtime programs, and this makes every miniprogram have a finite number of steps
07:13:46 <sgiMIPS> okay i dont know...
07:14:02 <sgiMIPS> anyone knows if HP calculators' RPN is Turing COmplte?
07:16:12 <earthy> well, the problem with running a fold is that you continuously *decrease* the size of the input (or tape, or list) that you will still look at, whereas with cellular automata and turing machines you may as well increase it
07:17:28 <Spark> whats a cellular automata?
07:17:41 <earthy> look at sgiMIPS's link ;)
07:20:10 <shapr> hi mpn 
07:20:20 <mpn> warning: I do not know haskell
07:20:25 <mpn> Hello.
07:20:34 <mpn> Just curious, why don't you link to the new meme.b9.com site?
07:21:10 <Spark> hmm that is interesting
07:21:40 <Spark> re: the cellular automaton link :)
07:21:46 <shapr> haven't gotten around to investigating b9.com enough yet
07:21:52 <Spark> it reminds me of stuff i used to do on a bbc micro when i was young
07:22:01 <shapr> I've played with it, looks nice
07:25:02 <Spark> heh sentences like this must only arise in computer science: "Since life's original inception, new rules have been developed."
07:26:25 <sgiMIPS> wheeee!
08:15:03 * shapr swears at Python's lack of functional style
08:15:16 <stepcut> :p
08:15:49 <darius-> python 3.0 should just be haskell :)
08:16:22 <stepcut> hehe
08:18:06 <darius-> wonder how hard it would be to compile for python's vm, actually
08:18:47 <shapr> if getattr(myproj,'en',None): myproj.en.getProject_description() else: ''
08:19:43 <shapr> oh, I'm doing that in a dict value, maybe it's not happy with the extra colons
08:20:41 <shapr> there must some way to unwrap that if
08:22:21 <Marvin--> shapr: the else is invalid syntax
08:22:27 <shapr> oh
08:22:33 <Marvin--> you need the else on a new line
08:22:40 <shapr> thanks
08:27:10 <shapr> aha, getattr(myproj,'en.getProject_description',lambda :'')()
08:28:11 <Marvin--> shapr: ugh
08:28:36 <shapr> better idea?
08:28:40 <Marvin--> no
08:29:10 <shapr> i18nlayer objects suck
08:29:16 <Marvin--> well, besides having a dummy object with the same interface as the en object
08:29:36 <Marvin--> so you could do getattr(myproj, 'en', ...).getProject_description()
08:29:38 <shapr> en has a different interface for each type
08:30:03 <Marvin--> I haven't used i18nlayer *shrug*
08:30:09 <shapr> lucky you
08:30:15 <Marvin--> heh
08:30:26 <shapr> your idea has merit
08:30:28 * shapr thinks
08:30:39 <Marvin--> it feels like the only "sane" alternative
08:30:50 <shapr> yah, I think you're right
08:31:09 <shapr> at least one or more of en, es, pt will exist 
08:31:32 <shapr> I could fall through on that
08:42:50 <stepcut> ugh
08:43:17 <stepcut> handling '-v' is a pain!
09:45:13 <shapr> hm
09:46:30 <shapr> bring: discussion on #europython just suggested to me that we have at least one organized panel at EuroPython on the future of Haskell 
09:46:44 <bring> huh?
09:48:11 <shapr> I wanted a "questions slot"
09:48:48 <bring> why haskell at EuroPython?
09:48:57 <shapr> er, doh
09:49:04 <shapr> brain too busy...
09:49:23 <shapr> one more time... with clue..
09:50:11 * shapr smacks self
09:50:30 <shapr> I'll bother you again when I'm feeling more coherent :-)
09:50:37 <bring> ok :)
09:50:50 * bring is happy
09:51:06 <shapr> bring: good stuff happening?
09:51:12 * bring just got hram's dynamic loader to load haskelldb drivers dynamically
09:51:17 <shapr> yay!
09:54:31 <shapr> that means that DBInfo stuff will work on the fly now, right?
09:55:23 <bring> ah, that would be neat too
09:56:11 <bring> no, just using the right backend (MySQL, PostgreSQL, ODBC, etc) without having to link them all in
09:56:21 <shapr> oh, that's nice
09:56:42 <shapr> any more thoughts on foreign keys?
09:56:59 <bring> nope
09:58:08 <bring> dunno how it should be done
09:58:57 <bring> you have any ideas?
10:05:31 <shapr> nothing more than I said before
10:05:31 <shapr> I'll think about it
10:50:24 * shapr grumbles at procedural style
10:50:55 * stepcut grumbles at logging facilities
10:52:20 <stepcut> so, lets say I write a bunch of libraries (in haskell), and I want them to log messages with a verbosity level that can be set at runtime (via some -v's on the command-line). How do I make this happen...
10:52:45 <stepcut> I could have each library, parse argv and look for the -v flag, but that seems like a bad idea
10:53:54 <stepcut> I could use stick a mutable variable in each module that represents the verbosity level, and then in my main app, parse the command-line and change the mutable variable for each module
10:54:42 <stepcut> but that is really annoying if I have a lot of modules
10:55:09 <stepcut> hrm
10:55:14 <bring> could you make one logging module that they all import, and then that level keeps track of the verbosity level?
10:55:32 <Marvin--> a generic logging module is the answer
10:55:34 <bring> s/that level/that module/
10:55:47 <bring> exactly
10:56:07 <bring> just exposing something like log :: String -> a -> a
10:56:15 <stepcut> I actually have a generic logging module already
10:56:20 <bring> (like Debug.trace does)
10:56:47 <stepcut> I think I might have a solution though...
10:57:07 <bring> if you want per-module verbosity levels, why not put a map of modules to verbosity levels in the logging module
10:57:11 <stepcut> I should add, that I also would like to be able to configure the logging level of each module independantly if I so desire
10:57:45 <Marvin--> weeell, that's trickier
10:57:46 <bring> and give the log function an extra parameter that is the module name
10:57:48 <Marvin--> maybe an implicit parameter?
10:58:17 <stepcut> bring: I was thinking of something along those lines...
10:58:43 <bring> was there some problem with that approach?
10:59:25 <stepcut> bring: maybe... 
10:59:42 <stepcut> bring: would I have to modify the map in the log module whenever I write new libraries?
11:00:08 <Marvin--> not if they register themselves at run time
11:00:40 <bring> or you could have the map empty be default, and only put values in it if they are given on the command line
11:00:42 <stepcut> Marvin--: right, that is what I thought of after I said 'hrm' ;)
11:00:55 <Marvin--> heh
11:01:02 <bring> and if there is nothing in the map, it gets the default level
11:01:24 <stepcut> bring: yeah... that would actually work out nicely i think
11:04:00 <stepcut> the problem I originally had with that method (including a 'channel' identifier as an argument to the log function), is the potential for name collision. What if two peopl used the channel identifier "debug". As a policy, I could dictate the the channel identifier should include the fully qualified module name since that will be unique..
11:04:23 <shapr> I think I've seen a generic logging module somewhere
11:04:59 <stepcut> so then I was trying to imagine how to get the type-checker to ensure unique names instead of using a plain string and leaving it up to the user.
11:07:20 <bring> come up with anything?
11:09:17 <stepcut> nope
11:11:28 <shapr> you could use the unique name supply
11:11:58 <bring> but then the user wouldnät know what name to use when setting the level on the command line, right?
11:12:27 <stepcut> bring: yeah, exactly
11:13:17 <Cale> perhaps the calls to writeLog could include some parameter which marks what kind of logging event is concerned, and the minimum level at which the message will appear.
11:15:01 <Cale> there's not much you can really do about name collisions -- what if you really want to write to a logging channel that's initially written to by some other module?
11:16:32 <Cale> (sorry if I'm not making any sense, or if this is obvious -- I juuust woke up)
11:16:38 <stepcut> Cale: hrm, that is a point. Originally, I wanted the logs seperated by module. But now that you mention it, there are other schemes that might make sense to
11:29:47 <stepcut> bring: the map in the log module would be a mutable variable?
11:31:55 <bring> feels like it would have to be
11:32:02 <stepcut> agreed
11:32:08 <bring> if you want to be able to set it from main
11:32:47 * stepcut grumbles
12:10:06 <Cale> just be sure not to call your log function log if you plan on doing some numerical calculations :)
12:11:23 <stepcut> Cale: :p
12:28:28 <Marvin--> *cough* import qualified *cough*
12:29:22 <Cale> yeah - I think it would still be funny if you called the logging function ln
12:31:40 * Marvin-- groans
13:18:51 <sgiMIPS> hi
13:18:58 <sgiMIPS> :-)
13:19:01 <heatsink> hello
13:19:06 <sgiMIPS> what do you think about Prolog?
13:19:26 <Riastradh> That's a rather philosophical question, or it's too broad.
13:19:36 <Lor> We think a great many things.
13:20:01 <sgiMIPS> hmm... First, what kind of language is it?
13:20:11 <Riastradh> Logic.
13:20:25 <Lor> It's based on backtracking search and unification.
13:21:05 <Lor> You can simulate prolog nicely in haskell.
13:21:16 <Lor> A nondeterminism monad plus some unification routines.
13:21:20 <Lor> There are a couple of papers about it.
13:21:38 <Lor> Nowadays it would probably be even easier, with generic haskell and whatnot.
13:21:48 <Lor> (Automatic unification)
13:23:52 <sgiMIPS> and if one claims Prolog in imperative?
13:23:59 <sgiMIPS> or at least impure?
13:24:01 <Riastradh> One would be illogical.
13:24:06 <Lor> Well, there are cuts.
13:24:13 <Lor> And an assert() is arguably imperative.
13:24:18 <Riastradh> Don't consider it in terms of imperative versus functional.  It's logic.
13:24:23 <Lor> And so are the I/O operations etc.
13:24:32 <Lor> Mercury does those things much cleaner.
13:25:03 <sgiMIPS> Riastradh: yes, its logic vs imperative
13:25:13 <Riastradh> No, it's not logic versus imperative, either.  It's just logic.
13:25:28 <sgiMIPS> :-)
13:25:41 <Lor> That's pretty simplistic.
13:26:10 <sgiMIPS> Second, is there a usable environment for it? native compiler? interpreter? byte-code mysery...
13:26:49 <sgiMIPS> swiprolog, ciao, they are *slow*... gprolog has no garbage collection.
13:26:49 <Lor> Dunno. swi-prolog is nice enough for playing around, don't know how good it is for bigger applications.
13:26:50 <heatsink> Does prolog see much use? I get the impression prolog use has waned...
13:26:58 <Lor> Well, mercury is better. ):
13:27:23 <Lor> Except that mercury doesn't have skolem variables.
13:27:33 <Lor> Which precludes several programming techniques.
13:27:43 <sgiMIPS> skolem?
13:27:49 * heatsink thinks skolem is a cool word
13:28:01 <sgiMIPS> :-)
13:28:13 <Marvin--> heatsink: heh
13:28:37 <Lor> Skolemization essentially means binding a variable into a fresh unique value.
13:28:40 <Lor> Or something like that.
13:28:55 <Lor> Think of what happens when you open an existential package. What does the existential type variable get bound to?
13:30:18 <sgiMIPS> no idea :-D
13:30:29 * sgiMIPS is not a programmer
13:30:42 * sgiMIPS is _going to be_ one
13:31:13 <sgiMIPS> hmm...
13:31:24 <Lor> Whee, there's a planetmath entry for it: http://planetmath.org/encyclopedia/Skolemization.html
13:31:28 <Marvin--> Skolemization is the process of removing existentially quantified variables and replacing them with unique constants and functions of universally quantified variables
13:32:28 <sgiMIPS> well, i think imperative, functional, logic, theese are programming styles. and it all depends on the person, but for me, well, functional is sure better than imperative, but logic seemesd to fit my way of thinking well... but i cannot find a decent logic programming language...
13:32:28 <Marvin--> you replace  Ex.P(x)  with  P(c), c unique  and  AxEy.P(x,y)  with  Ax.P(x,f(x)), f unique
13:33:20 <Lor> "logic programming" is rather a misleading word. I'd use it for Coq and its kin rather than for Prolog.
13:33:38 <sgiMIPS> Coq?
13:33:47 <Riastradh> Lor, that would be 'programming logic,' not 'logic programming.'
13:33:48 <Lor> Prolog is a search engine. :)
13:34:54 <sgiMIPS> does a better job than Google at least...
13:52:45 * shapr bounces cheerfully
13:57:29 <jesse> could someone point me at some usage examples of ObjectIO?
13:57:49 <earthy> jesse: look at the Clean IDE
13:58:04 <earthy> IIRC that's written in Clean using ObjectIO
13:58:35 <jesse> well i meant smallish examples in haskell, im not familiar at all with clean
13:59:03 <earthy> it looks virtually identical
13:59:10 <earthy> a few arrows less, basically
13:59:10 <jesse> oh
13:59:23 <earthy> and there's a bunch of examples on the Clean webpages
13:59:23 * jesse goes and checks it out
13:59:33 <earthy> and the syntax for class constraints is different
13:59:52 <earthy> (  Num a => a -> a  -> a    would in Clean be   a a -> a | Num a
13:59:54 <earthy> )
14:01:37 <Igloo> Can you still say "foo 5" if foo has that type?
14:05:12 <Marvin--> Igloo: as in partial application? No, clean doesn't have partial application like that, you'll have to explicitly give it type a -> (a -> a)  iirc
14:26:10 <SamB> hmm, whats the best way to get the runs for a list?
14:26:56 * Cale is back (gone 12:44:41)
14:27:42 <SamB> I have:
14:27:50 <SamB> runs [] = []
14:27:50 <SamB> runs (x:xs) = runs' x 1 xs
14:27:50 <SamB>     where
14:27:50 <SamB>     runs' x n []      = [(x, n)]
14:27:50 <SamB>     runs' x n (x':xs) = 
14:27:50 <SamB> 	if x == x'
14:27:57 <SamB> 	   then runs' x (n+1) xs
14:27:57 <SamB> 	   else (x, n):runs' x' 1 xs
14:31:45 <Lunar^> SamB: I think this is quite a good solution
14:31:46 <Igloo> That's a very similar wuestion to one asked on one of the lists in the last week or so
14:32:52 <SamB> Lunar^: I don't think it is very pretty, though.
14:34:18 <Igloo> You could use break and length, or an unfold (although you'll probably have to kludge around the end case)
15:31:11 * SamB_ZenIRC not like ZenIRC
15:53:08 <shapr> er hey!
15:53:17 <shapr> that was SyntaxUK!
15:53:25 <Riastradh> ?
15:53:55 <shapr> SyntaxLaptop was connecting from Simon Marlow's house I think
16:21:37 <yich> I'm just starting. Why, if I type into hugs: f = putStr "asdf", I get a syntax. If I put the same in a file and load the file, I can then type f and it evaluates as I would expect?
16:21:49 <yich> syntax error I mean
16:22:35 <Riastradh> Haskell doesn't support incremental definitions.
16:23:06 <yich> so... why does it work when I load the same from a file?
16:23:34 <Riastradh> Er.
16:23:37 <Riastradh> Hugs, I meant, not Haskell.
16:23:46 <Riastradh> It does support dynamically loading modules, which is different.
16:24:22 <Riastradh> Hugs interactively supports evaluation of _expressions_.  Modules contain _declarations_.
16:26:10 <yich> so if I have the above declaration by itself, in a file, it creates a module for it to be in automatically?
16:26:57 <Smerdyakov> yich, the modules aspect of this is not important.
16:27:15 <Smerdyakov> yich, the problem is that all top-level definitions in a Haskell program are potentially mutually recursive.
16:28:19 <yich> ok... so how is this not a problem, if the same declaration exists by itself in a file?
16:29:11 <Smerdyakov> The file is a closed unit, so there's no issue of a definition being mutually recursive with others past the end of what's already been entered.
16:30:53 <Jerub> yich: learn to use :e from within hugs to edit a file, so you can work semi-interactively on writing functions
16:31:27 <yich> ok I see thanks
16:39:03 <Cale> I actually like keeping a text editor open alongside ghci or hugs, and just reloading when needed.
16:40:27 <Cale> With ghci, you get a little extra flexibility, in that you can say, for instance, let f = putStr "asdf"
16:40:43 <Cale> at the interpreter prompt, and then f will work as expected
16:41:36 <Riastradh> Smerdyakov, of course, this isn't an issue if you just have an intelligent REPL with respect to incremental environment mutation...
16:44:10 <Jerub> it also probably wouldn't be a problem if declarations were only processed in a lazy manner ;)
16:48:29 <Smerdyakov> Jerub, what do you mean? How do you typecheck a forward reference?
16:48:57 <Riastradh> Smerdyakov, infer its type, and if you can't, use an as-yet-undetermined type (like OCaml's '_a).
16:49:32 <Smerdyakov> Icky poo-poo.
16:49:37 <Riastradh> When the definition comes, try to infer it again.
16:50:02 <Smerdyakov> What happens if you make a typo in referencing a local variable?
16:50:03 <Riastradh> Welcome to the land of incremental development where the environment has to interact with the human.
16:50:21 <Smerdyakov> The misspelled identifier gets assigned an undetermined type?
16:50:25 <Riastradh> Then when you try to use the partially-inferred function, the interpreter should signal an error.
16:50:47 <Riastradh> (where the 'partially-inferred function' is the one with the typo in its definition)
16:53:05 <Riastradh> And yes, you assign the misspelled identifier an undetermined type (determined as far as you can infer from context, of course).
17:03:12 <Pseudonym> @seen Pseudonym
17:03:13 <lambdabot> Pseudonym is in #haskell.
17:03:16 <Pseudonym> There you go.
17:03:34 <Pseudonym> So, who's up for implementing DCC2 support?
17:23:22 <skew> SamB: I think your runs function is just map length . group
19:08:39 <SamB> skew: actually, map (head &&& length) . group
19:29:47 <SamB> it is kind of cool to edit code and chat in the same window ;-)
19:40:13 * SamB wants apt-get haircut
19:54:35 <palomer> so...what's the latest in haskell world?
20:06:31 <Riastradh> palomer:
20:06:34 <Riastradh> 22:12 < SamB> it is kind of cool to edit code and chat in the same window ;-)
20:06:34 <Riastradh> 22:22  * SamB wants apt-get haircut
20:06:53 <Riastradh> OK, there might be a more recent email message than those IRC messages.
20:12:32 <SamB> in other news, hugs doesn't like this:
20:12:38 <SamB> import Data.List
20:12:44 <SamB> import Control.Arrow
20:12:44 <SamB> runs = map (head &&& length) . group
20:36:11 <idlehero> I have a question about pattern matching:  is there any way i can match two positive arguments, one positive one negative, etc ?
20:36:22 <idlehero> i am quite new to haskell if you cannot tell
20:36:23 <Riastradh> Use guards.
20:36:42 <idlehero> is that using | in your function definition?
20:37:16 <Riastradh> The syntax for guards involves |, yes.
20:37:59 <idlehero> i'm aware its much more complex than throwing in a bunch of |s.  I just need to find an example of it now.  Thanks
20:38:11 <Riastradh> foo x y
20:38:23 <Riastradh>   | x > 0 && y > 0 = ... -- both are positive
20:38:44 <Riastradh>   | x < 0 && y > 0 = ... -- one negative, one positive
20:38:47 <Riastradh> et cetera.
20:38:53 <Riastradh> The last one is typically:
20:38:55 <Riastradh>   | otherwise = ...
20:39:20 <idlehero> excellent.  thanks a lot, thats exactly what i was looking for :)
21:01:55 <SamB> where otherwise is just a name for True that reads nicer in guards and such
22:42:42 <anduril1> I've written a prime number sieve, and when I give an explicit type of Int, my program runs slower than if the type is Integer
22:43:16 <anduril1> is there a good reason for this?
22:46:47 <anduril1> (using GHC by the way)
22:46:50 <Cale> That's odd, I don't know.
22:47:02 <anduril1> I really don't get it
22:47:10 <Pseudonym> Can I see the code?
22:47:21 <anduril1> yeah
22:48:56 <anduril1> http://cse.unl.edu/~sjanssen/Sieve.hs
22:49:56 <anduril1> its kind of goofy, and not written for other people to look at, but I think you'll see the gist of it
22:50:03 <Pseudonym> That's cool.
22:50:16 <Pseudonym> I figured it'd be something to do with the way it's written.
22:55:08 <Pseudonym> OK, changing (p ^ 2) to (p * p) makes it go faster when it's Int.
22:55:21 <Pseudonym> I suspect it's the implementation of (^).
22:56:28 <anduril1> maybe because p ^ 2 is mixing types?
22:56:42 <Pseudonym> Maybe.  I'm looking up the definition to see if I can tell.
22:56:58 <anduril1> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
22:57:14 <anduril1> thats what ghci says
22:58:35 <Cale> *Main> length $ map (^2) [1..10000000::Int]
22:58:35 <Cale> 10000000
22:58:35 <Cale> (1.85 secs, 725024260 bytes)
22:58:35 <Cale> *Main> length $ map (^2) [1..10000000::Integer]
22:58:36 <skew> @type (**)
22:58:36 <Cale> 10000000
22:58:37 <lambdabot> (**) :: Floating a => a -> a -> a
22:58:38 <Cale> (1.93 secs, 723720708 bytes)
22:58:44 <Cale> I find that memory usage interesting
22:59:02 <Pseudonym> Why?
22:59:09 <skew> Cale: why? It's not strict in the elements
22:59:18 <Pseudonym> Right, like skew said.
22:59:38 <Cale> I suppose that it's reusing space
23:00:12 <skew> Cale: how much ram do you have?
23:00:15 <Cale> and not counting the maximum memory allocated at any one point
23:00:22 <anduril1> if I add "p ^ (2::Int)" it runs much faster, with both Int and Integer
23:00:25 <Cale> 512MB
23:00:30 <skew> It could be counting total allocations
23:00:33 <skew> not peak usage
23:00:44 <Cale> yeah, that's what I think it's probably doing
23:02:07 <Pseudonym> The other thing is that GHC uses Ints instead of GMP bignums when it can.
23:03:12 <Cale> hmm... it took less memory to use Integers
23:03:37 <Pseudonym> data Integer = S# Int# | | J# Int# ByteArray#
23:04:12 <Pseudonym> Sorry, one too many pipes there.
23:05:26 <Pseudonym> Oh... got it.
23:05:48 <Pseudonym> Let me test a theory.
23:06:48 <Pseudonym> Mystery solved.
23:07:06 <Pseudonym> This is from GHC.Real:
23:07:12 <Pseudonym> {-# SPECIALISE (^) ::
23:07:20 <Pseudonym>  {-# SPECIALISE (^) ::
23:07:30 <Pseudonym> SPECIALISE (^) ::
23:07:38 <Pseudonym> Er...
23:07:40 <Pseudonym> Can't paste it.
23:07:50 <Pseudonym> Anyway, GHC.Real specialises the following versions of (^):
23:07:57 <Pseudonym> Integer -> Integer -> Integer, 
23:08:07 <Pseudonym> Integer -> Int -> Integer
23:08:10 <Pseudonym> Int -> Int -> Int
23:08:36 <Pseudonym> If you declare everything to be int, then in (p ^ 2), p is of type Int.
23:08:42 <Pseudonym> However, 2 is Integer.
23:08:51 <Pseudonym> Hence you're using a non-specialised version of (^).
23:08:58 <anduril1> ah
23:09:05 <Pseudonym> If you want equivalent speed, put default(Int) under the module imports.
23:09:25 <Pseudonym> When p is an Integer, you're using the specialised version.
23:09:43 <Pseudonym> So it goes faster.
23:09:59 <Pseudonym> Moral of the story: Never write p^2.  Always use p*p. :-)
23:10:21 <anduril1> what exactly does the default(Int) do?
23:10:52 <Pseudonym> Any Num/Integral types which aren't explicitly typed default to Integer unless you override it.
23:10:58 <anduril1> tells the interpreter that all numbers I've entered are Int's, unless told otherwise
23:11:00 <Pseudonym> default(Int) sets the default to Int instead of Integer.
23:11:04 <Pseudonym> Right.
23:11:05 <anduril1> okay
23:11:23 <Pseudonym> If they can be inferred as something else, they will be.
