00:08:42 <Shuu> is it a function that eliminates the head from the list?
00:09:23 <Pseudonym> I don't understand the question.
00:09:25 <Shuu> i mean, it causes me to call occurrences on a list without the element i just did
00:09:49 <Pseudonym> What should g [5,2,3,2,4,3,2,5] return?
00:10:19 <Shuu> [2,3,2,4,3,2] ?
00:10:38 <Pseudonym> OK, so what should g look like?
00:11:04 <Shuu> g (x:xs) = 
00:11:17 <Shuu> um
00:15:25 <Shuu> [z | z <- xs, z /= x]
00:15:38 <Pseudonym> Try it.
00:16:33 <Shuu> It works!
00:16:40 <Pseudonym> Yay/
00:17:03 <Shuu> I would think there would be a G predefined in Prelude
00:17:10 <Shuu> so i was looking there
00:17:14 <Shuu> but i didnt find it
00:17:15 * Pseudonym nods
00:17:18 <Pseudonym> Well there isn't.
00:17:20 <Pseudonym> One other thing.
00:17:36 <Pseudonym> [ z | z <- xs, z /= x ] == filter (/= x) xs
00:17:46 <Pseudonym> Either works.
00:18:46 <Shuu> i see.
00:20:04 <Shuu> OMG Thank you so much for all your patience.
00:20:17 <Shuu> I am pretty stupid when it comes to this.
00:20:29 <Pseudonym> No problem.
00:20:31 <Shuu> It takes me way longer to get it.
00:20:50 <Pseudonym> When dealing with list-based problems, you might want to think of three things.
00:20:53 <Pseudonym> 1. map/filter/fold
00:20:57 <Pseudonym> 2. list comprehensions
00:21:00 <Pseudonym> 3. recursion
00:21:11 <Pseudonym> Usually you can solve the problem using only one of those three.
00:21:47 <Shuu> Yeah.
00:25:08 <Shuu> sumAndLength [1,2,3] = (6,3)
00:25:23 <Shuu> But the trick is, you're only allowed to make one pass through the list.
00:25:47 <Shuu> so i can't use sum ns and length ns seperately..
00:26:22 <Shuu> I'll try this with recursion
00:27:16 <Pseudonym> OK.
00:28:09 <Shuu> > sumAndLength :: [Int] -> (Int,Int)
00:28:10 <Shuu> > sumAndLength [] = (0,0)
00:41:15 <Pseudonym> Heading off.  Nytol!
00:48:43 <Shuu> anyone helping?
00:59:49 * earthy looks
01:00:18 <earthy> sumandlength :: [Int] -> (Int,Int)
01:00:43 <earthy> sumandlength xs = sumandlength' xs 0 0
01:01:09 <earthy>      where sumandlength' [] sumaccumulator lengthaccumulator = (sumaccumulator,lengthaccumulator)
01:01:13 <earthy> (you do the other case :))
01:02:20 <earthy> (you could do this with a fold, but it'd be somewhat murkier)
01:13:54 <Shuu> i just finished it without looking
01:13:55 <Shuu> at yours
01:14:17 <Shuu> > averageFast ns = sumAndLength 0 0 ns
01:14:20 <Shuu> > sumAndLength 0 _ [] = 0
01:14:23 <Shuu> > sumAndLength a b [] = b / a
01:14:26 <Shuu> > sumAndLength a b(x:xs) = sumAndLength (a+1) (b+x) xs
01:15:27 <Shuu> is that one pass ?
01:16:45 <Shuu> I think it is, so..
01:16:51 <Shuu> Last one and then I'm going to bed..
01:19:56 <earthy> yup, that's one pass. :)
01:20:10 <earthy> but I didn't know you were going for an average. ;)
01:20:15 <Shuu> ya
01:21:07 <Shuu> binCoef [1,2,1]
01:21:10 <Shuu> [1,3,3,1]
01:21:19 <Shuu> binCoef (binCoef (binCoef [1,3,3,1]) )
01:21:22 <Shuu> [1,6,15,20,15,6,1]
01:21:41 <Shuu> (binCoef . binCoef . binCoef) [1,2,1]
01:21:44 <Shuu> [1,5,10,10,5,1]
01:21:49 <Shuu> hmm
01:21:59 <earthy> yes?
01:22:18 <earthy> seem like normal binomial coefficients to me
01:22:20 <Shuu> is this hard?
01:22:30 <earthy> to calculate?
01:22:33 <Shuu> to code
01:22:38 <earthy> nah.
01:23:11 <earthy> should be possible in less than half an hour.
01:23:16 <earthy> *way* less in fact :)
01:23:24 <Shuu> So then
01:23:30 <Shuu> the type would be...
01:23:36 <Shuu> binCoef :: (Num a) => [a] -> [a]
01:23:41 <earthy> yup.
01:23:48 <Lunar^> uhoh
01:23:54 <Lunar^> "cvs.haskell.org appears to have been hacked (with a Suckit rootkit).  It is currently being nuked and repaved, and I expect it will be back online tomorrow.
01:23:58 <Lunar^> "
01:24:09 <earthy> *eeewwwww*
01:24:49 <Shuu> Humm.. Pascal's triangle?
01:24:55 <shapr> that sucks
01:24:57 <earthy> shuu: yup.
01:24:59 <Lunar^> That just arrived on cvs-ghc
01:38:29 <Spark> security patches!
01:38:41 <shapr> where?
01:38:53 <Spark> generally prevent rootkits ruining your life
01:39:00 <shapr> oh, right
01:39:11 <earthy> `generally' i.e. not always
01:39:24 <earthy> plus, there's another method of keeping a system moderately secure
01:39:27 <Spark> specifically not if you dont bother applying them :)
01:39:41 <Spark> or its a debut exploit
01:39:49 <earthy> (try installing a rootkit on a system still running linux 1.09 :))
01:40:25 <earthy> (yes, it is root-hackable, but still being a.out, and not ELF really mitigates a lot of problems ;P)
01:40:56 <Spark> interesting
01:40:57 <earthy> (I've worked in systems security doing Linux, can you tell? :))
01:41:40 <Spark> if linux is still breeding exploits, what about bsd?
01:42:02 <Spark> if all you want to do is run a few userspace servers, surely the way forward
01:42:03 <earthy> same thing
01:42:05 <shapr> hm, chkrootkit says "possible LPD worm installed" how can I find out for sure?
01:42:20 <earthy> shapr: 1. boot from CD
01:42:36 <earthy> (a CD you trust, preferably :))
01:42:43 <earthy> 2. run chkrootkit again
01:43:08 <earthy> 3. walk through the entire bootup process of your system
01:43:29 <earthy> (examining every binary along the way against a known-good binary)
01:43:54 <Spark> ive always been under the impression that bsd is more mature than linux, in terms of stability and security
01:43:58 <shapr> or I could just reinstall
01:44:01 <Shuu> humm
01:44:02 <earthy> spark: not so
01:44:03 <Shuu> think i got it
01:44:08 <earthy> shapr: could. :)
01:44:16 <earthy> but that's the windows-solution
01:44:31 <shapr> actually, I've been meaning to move to this new drive anyway
01:44:42 <earthy> and it doesn't give you any guarantees of not getting rootkitted again within 2 weeks 
01:45:13 <earthy> spark: it's just that there's more people hacking away at destabilizing and hacking linux
01:46:26 <Spark> ah ok
01:47:07 <Shuu> >hamming 3 5 7
01:47:08 <Shuu> [1,3,5,7,9,15,21,25,27,35 ...]
01:47:18 <Shuu> hmm
01:47:36 <Shuu> this is factors?
01:47:42 <earthy> nope, hamming code, I'd guess.
01:47:47 <earthy> non-trivial. :)
01:47:55 <Shuu> not easy?
01:52:37 <earthy> not something I'd try sleepy. ;)
01:58:58 <Shuu> what is merge?
01:59:19 <Shuu> my interpreter can't tell me what it is..
02:05:56 <Marvin--> Shuu: in what context?
02:06:11 <Shuu> nevermind
02:06:13 <Shuu> i think i did it
02:06:45 <Shuu> this is the context
02:06:49 <Shuu> > hamming a b c = hh
02:06:52 <Shuu> >  where
02:06:57 <Shuu> >    hh = 1: foldr merge [] (map (\k -> map (k*) hh) [a,b,c])
02:11:38 <Shuu> thanks for the help all
02:11:40 <Shuu> i'm going to bed ^^
02:11:52 <Shuu> good night
02:14:21 <shapr> Normality: are you really normal?
02:14:55 <Normality> Depending on the definition... no, not really.
02:15:06 <shapr> whew, I was worried.
02:15:10 <Marvin--> "Probability is 1 to 1 against, we have normality!"
02:15:14 <shapr> I thought Haskell had hit the mainstream.
02:15:14 <Normality> Concerning the motto of this channel... who does the "tion" part.
02:15:28 <shapr> that would be Microsoft.
02:15:43 <Normality> No way... it hit my prof though :(
02:15:47 <shapr> Microsoft: We put the "shun" in lots of software.
02:16:05 <Normality> Ok, so we're only short one t now
02:16:38 <shapr> funkttion?
02:16:57 <Normality> Hmm... more like Funk-t-shun
02:17:13 <shapr> I think tion is "shun" in English.
02:17:29 * Marvin-- is bored
02:17:34 <shapr> Marvin--: write code!
02:17:46 <Marvin--> I keep re-reading my report and finding more typos, fix them, re-read again and find more typos...
02:17:54 <Normality> Ok, I'll accept that grudgingly and for the time being :9
02:17:57 <shapr> Normality: so, you learning Haskell?
02:18:36 <Normality> More or less - I'm currently waiting to find out whether my learning Haskell was successful or not - or at least successful enough to pass the exam :)
02:18:56 <Normality> Can't say I'm too fond of the language though
02:19:14 <shapr> why not?
02:19:33 <shapr> lack of curly braces? ;-)
02:19:43 <Marvin--> Haskell has curly braces!
02:19:46 <Marvin--> they're just optional
02:19:50 <Normality> Hell no - I'm 
02:19:53 <shapr> see! we fit into the crowd!
02:19:54 <Normality> disregard
02:20:04 <Marvin--> you're disregard?
02:20:14 <Normality> no. Disregard that half line
02:20:16 * Marvin-- blinks
02:20:19 <Marvin--> :)
02:20:25 * shapr yawns
02:20:33 * Normality tries to insert brain into gear
02:20:33 <shapr> I think I'm going back to sleep.
02:20:42 * shapr tries to get brain out of gear
02:20:45 <earthy> normality: that's gotta hurt
02:21:35 <Normality> Not too fond because I was used to imperative programming and struck a few walls in Haskell at first. But I think the main problem is that we're not doing Haskell but rather Helium at this university. Just can't seem to find any real use for the programs except doing weird stuff to lists
02:22:01 <shapr> huh, are you in the Netherland?
02:22:10 <Normality> earthy: Doesn't hurt so much anymore - but last maintenance was... painful
02:22:15 <Normality> Nope, Germany
02:22:22 <Normality> Why? Does it show?
02:22:35 <Marvin--> well, Helium is a .nl invention :)
02:22:41 <shapr> yup, that's why
02:22:41 <earthy> Helium is rather complete...
02:22:48 <Normality> Come to think of it... of coures
02:22:51 <Normality> *course
02:23:37 <earthy> it doesn't do typeclasses (officially, yet, that is :P) but it does do good errorreporting
02:23:51 <Normality> Only things we did was starters like factorials and such - and a good bit of list comprehension
02:23:59 <Normality> Ok, does that, given.
02:24:08 * Normality welcomes MadGyver
02:24:17 <madgyver> thx
02:24:28 <shapr> you could switch to GHC for non-learning code
02:24:56 <Normality> come again?
02:24:59 <madgyver> does anyone know of a haskell interpreter for PalmPilots? would be a great (pocket) calculator :)
02:25:04 <ozone> nudge.nudge.earthy.need.typeclasses.nudge.nudge
02:25:15 <shapr> madgyver: there is Hugs for the Zaurus
02:25:27 <earthy> madgyver: there was a project porting nhc or hbc to PalmOS once
02:25:35 <madgyver> zaurus is a quite new palm, isnt it?
02:25:36 <shapr> some of the aussies claimed they had an nhc98 runtime on PalmOS
02:25:43 <madgyver> got a IIIxe
02:25:45 <shapr> nah, zaurus runs Linux
02:25:45 <Normality> Of course, Gyvers palm is ANCIENT
02:25:55 * earthy owns a IIIxe as well
02:25:58 <earthy> perfect little machine that
02:26:01 <shapr> I have a IIIc
02:26:11 <earthy> more power in it than in my first PC
02:26:18 <Normality> Can't speak of running anything really... it's more like walking PalmOS -0.5 alpha
02:26:22 <ozone> shapr: hugs has been ported to an apple IIIc?
02:26:29 <shapr> ozone: :-P
02:26:31 <madgyver> earth: oh jeah... :)
02:26:43 <earthy> and that could run Clean already, so there's no real reason not to be able to run a haskell compiler on a Palm
02:26:43 <madgyver> really powerfull that thing:)
02:26:47 <shapr> Normality: anyway, you could use GHC for writing useful Haskell code.
02:26:53 <ozone> shapr: MAIN :: IO (); MAIN = DO PUTSTRLN "GODDAMN CAPS"
02:27:04 <shapr> ozone: haha!
02:27:11 <shapr> that's totally quotable
02:27:42 <Normality> Useful - as in useful for writing a really nifty command line calculator for any OS I crave or useful as in why-learn-java-when-I-have-GHC?
02:27:42 <earthy> ozone: type classes are in the current version, you just can't get at 'm. :)
02:28:03 <shapr> I'd say E) all of the above
02:28:08 <shapr> lambdabot is written with GHC
02:28:10 <shapr> @yow
02:28:11 <lambdabot> Sign my PETITION.
02:28:22 * earthy laughs
02:28:28 * Normality blinks
02:28:31 <earthy> that was an appropriate yow. ;)
02:28:35 <shapr> see, even lambdabot has a Pro-GHC petition :-)
02:28:40 <shapr> @fortune
02:28:41 <lambdabot> The Czechs announced after Sputnik that they, too, would launch a satellite
02:28:41 <lambdabot> Of course, it would orbit Sputnik, not Earth!
02:28:47 <madgyver> hi lamdabot , how are you doin
02:28:59 <shapr> lambdabot: hello!
02:28:59 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
02:29:05 * Normality slinks under the table due to lambdabot
02:29:23 <Normality> lambdabot: @listcommands
02:29:24 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions
02:29:24 <lambdabot> ,"del-definition","det","devils","dict","dict-help","dummy","dump","dynamic
02:29:24 <lambdabot> load","dynamic-reload","dynamic-unload","easton","echo","elements","eval
02:29:24 <lambdabot> ,"foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock
02:29:24 <lambdabot> ,"jargon","join","karma","karma+","karma-","learn","leave","listchans",
02:29:25 <lambdabot> listcommands","listmodules","lojban","moo","more","msg","musasabi","part
02:29:27 <lambdabot> ,"prelude","quit","reconnect","resume","seen","set-fuel","shapr","state
02:29:29 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
02:29:31 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
02:29:36 <madgyver> ...
02:29:53 <Normality> could've whispered that, I guess *sigh*
02:30:25 <madgyver> lamdabot: moo
02:30:31 <Normality> lambdabot: DO_MY_F***ing_LAMBDA_CALCULUS_EXAM
02:30:32 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
02:30:51 <madgyver> lamdabot: @moo
02:30:57 <Normality> nice toy though
02:31:11 <shapr> @eval map (\x -> x + 1) [1,2,3]
02:31:12 <lambdabot> [2, 3, 4]
02:31:16 <madgyver> @moo
02:31:17 <lambdabot>          (__)
02:31:17 <lambdabot>          (oo)
02:31:17 <lambdabot>    /------\\/
02:31:17 <lambdabot>   / |    ||
02:31:17 <lambdabot>  *  /\\---/\\
02:31:19 <lambdabot>     ~~   ~~
02:31:20 <lambdabot> ...."Have you mooed today?"...
02:31:23 <madgyver> lol
02:31:44 <Normality> ok... I like it
02:32:09 * Normality comes out from under the table again - bad view on the monitor, really
02:32:14 <shapr> Normality: here's something I wrote with GHC: http://shapr.homelinux.net/cgi-bin/wash/SearchML
02:32:23 <madgyver> wait.... haskell for free use wherever I got IRC?!? cool....
02:32:33 <madgyver> gotta learn haskell NOW!
02:32:34 <madgyver> :)
02:32:40 <Lunar^> jvm-bridge works quite well
02:32:54 <shapr> so now you can use Haskell and Java together!
02:33:05 * shapr isn't sure if that's really cool, or really painful
02:33:13 <Lunar^> I'm also asking myself
02:33:36 <shapr> I guess it's good for letting everyone else in the company write Java
02:33:37 <Lunar^> But it allows one to easily make use of the Swing API for an interface
02:34:03 <Marvin--> Lunar^: No! Bad Lunar^, bad!
02:34:03 <Lunar^> Letting IDEs build it
02:34:11 <Normality> Ok... so you got me. Haskell is not just wombat
02:34:18 <shapr> what's wombat?
02:34:22 <ozone> earthy: yeah, you can't write your own typeclasses yet, is that right?
02:34:28 <Normality> waste of money, brains and time.
02:34:32 <earthy> ozone: exactly.
02:34:34 <Normality> It's a simple ETLA
02:34:45 <Normality> --> extended three-letter-acronym
02:34:47 <Marvin--> heh, I hadn't heard that one
02:34:49 <Marvin--> good one
02:34:53 <Lunar^> Marvin--: You're talking to the one that is actually trying to build a full operating system out of Haskell ;)
02:34:56 <shapr> ah
02:35:02 <ozone> earthy: i'm guessing the delay is because bastiaan is working on the type inference for it?
02:35:07 <Marvin--> Lunar^: I'm talking about swing
02:35:09 <earthy> partly. :)
02:35:20 <shapr> right, Lunar^ and sebc got GHC running on the bare metal
02:35:21 * Normality is afk for a sec
02:35:33 <shapr> hOp is cool
02:35:36 <ozone> earthy: rightio.  i'd just love to see a competitor to GHC, that's all :)
02:35:46 <ozone> make those lazy simons work harder!
02:35:48 <earthy> ozone: it's also mostly that Helium needs to be *stable*, as it is used in teaching
02:36:00 <earthy> and there's more than enough bugs in it without doing fancy type inferencing
02:36:18 <earthy> (so, Bastiaans time is also spent on fixing the bugs the students unearth)
02:37:03 <ozone> nod
02:37:11 <ozone> need an experimental branch of helium
02:37:13 <ozone> sodium!
02:37:16 * earthy laughs
02:37:21 <Lunar^> ozone: Do you dislike GHC ?
02:37:31 <earthy> bastiaan would have a sweater for it already. :)
02:37:58 <ozone> earthy: that's what i mean :)
02:38:08 <ozone> Lunar^: it's not that i dislike it, it's that i think competition would be good for it
02:38:24 <shapr> I think experimental Helium should be deuterium or tritium
02:38:29 <ozone> it's the only optimising haskell compiler out there right now.  (hbc doesn't count because i can't run it on mac os x :)
02:38:41 <madgyver> Normality comes back ... now
02:38:42 <shapr> does nhc do optimizations?
02:38:50 <shapr> madgyver: are you guys in the same room?
02:39:07 <earthy> hbc is dead mostly, isn't it?
02:39:16 * Normality nods
02:39:32 <shapr> there's UHC
02:39:43 <Heffalump> is that anywhere near doing codegen?
02:39:47 <Normality> Actually I'm just schizophrenic and MadG is a figment of my imagination...
02:40:01 <shapr> oh, neat
02:40:06 <earthy> shapr: no there isn't. :)
02:40:06 <Normality> But that's not too bad - 10 out of 5 psychiatrist say schizophrenia is ok
02:40:07 <madgyver> no... Normality is illusion
02:40:08 <shapr> I always wanted to have an imaginary friend.
02:40:18 <earthy> shapr: http://www.imaginarygirlfriends.com/ :P
02:40:23 <ozone> i thought i was your imaginary friend :(
02:40:34 <shapr> ozone: no, I'm your imaginary friend.
02:40:38 <Normality> shapr: This one is pretty good - the imaginary friend reacts vividly to slapping in the face :)
02:40:43 <shapr> see, I have real friends, but I always wanted an imaginary one.
02:40:48 <ozone> shapr: spiffy!!!!!
02:40:58 <ozone> recursive imaginery friends, yow!!
02:40:58 <shapr> hehe!
02:41:05 * shapr laughs
02:41:08 <Lunar^> ozone: I particulary like the Haskell commuity because most decisions are taken based on consensus
02:41:13 <ozone> ok, dinner time
02:41:21 * Normality ponders slinking back under table
02:41:24 <Lunar^> ozone: I'm not that interested in competition inside it
02:41:40 <Lunar^> shapr: Look for 'Brutus' on my Orkut friends ;)
02:41:42 <shapr> earthy: that's seriously broken
02:41:55 <Normality> Lunar: M$ statement of the day: When you program open source, you're programming COMMUNISM
02:41:59 <shapr> I have TTY on my friends list.
02:42:01 <shapr> but she's real.
02:42:13 <Marvin--> I have plenty of ttys too
02:42:19 <shapr> of course, she likes catnip more than she likes me.
02:42:28 <shapr> I have a picture of TTY on my wall.
02:42:31 <earthy> sick, I'd call it, shapr. :)
02:42:32 <Lunar^> Normality: I mostly define myself as an archist actually :)
02:42:46 <Lunar^> shapr: Brutus is real also :)
02:43:05 <Normality> Um... as in arch-bishop? What does the church say to communism and programming?
02:43:19 <Lunar^> Normality: anarchist sorry
02:43:26 <Lunar^> Normality: interesting lapsus
02:43:34 <shapr> a real script kitty --> http://shapr.homelinux.net/~shae/tty_se_repose.jpg
02:43:40 <earthy> duh... I didn't even bother to make myself of the orkut haskell community. :)
02:44:14 <earthy> how in the frig did you get that picture, shae? :)
02:44:34 <shapr> what, tty_se_repose.jpg ?
02:44:51 <shapr> TTY is my friend!
02:44:57 <Lunar^> shapr: Btw, that means "TTY gets some rest"
02:44:57 * Heffalump loses his breakfast
02:45:05 * Heffalump finds it again
02:45:20 <shapr> yes, she's taking a break from coding.
02:45:29 <earthy> lunar: I understand enough french. :)
02:45:38 <madgyver> * Heffalump loses his breakfast
02:45:38 <shapr> earthy: TTY can be your friend too, look at my friends list on orkut.
02:45:52 <earthy> but yeah, who the bleep was lucky enough to get that shot?
02:45:57 <shapr> under "female, single, france"
02:46:27 <madgyver> oops... didnt mean anything
02:46:45 * Normality wants a datafeed straight to the brain
02:46:50 <madgyver> f******* drag and drop
02:46:52 <shapr> yah, typing sucks
02:46:59 * madgyver feeding Normality
02:47:10 * Normality throwing up all over MadG
02:47:30 <Normality> better him than my keyboard --- what's more useful in the future, I ask
02:47:36 * shapr grins
02:48:01 <earthy> nah, I'd have to add Merlijn and Tristan to orkut and then have them be friends with tty, that'd be much more correct
02:49:40 <Lunar^> lol
02:49:44 <Lunar^> There's a Cat community
02:50:14 <Marvin--> Orkat
02:50:14 * madgyver is hunting for beakefast
02:50:19 <shapr> Marvin--: ha!
02:50:23 <madgyver> ugh
02:50:33 <Heffalump> what or kat?
02:50:36 <Heffalump> dog?
02:50:43 * Normality suggest MadG be washing himself first ...
02:50:55 <Marvin--> Heffalump: no no, it's zen
02:51:10 <Marvin--> there is no dog
02:51:24 <Normality> and god is real until declared integer
02:51:42 <Lunar^> Here's Brutus: http://www.orkut.com/Profile.aspx?uid=1639730372487978774
02:51:50 * Normality ponders that that statement doesn't quite fit the channel
02:52:16 <Lunar^> Normality: What would Hinley-Mindler infer for god ? ;)
02:52:37 <Lunar^> god :: forall a. a ?
02:54:07 <earthy> I *knew* it! the world's a *very* small place.
02:54:54 <Lunar^> earthy: ?
02:55:03 <shapr> ?
02:55:09 <Normality> god :: Question -> Answer; god x = | x in sesible = "maybe" | x in not_so_sensible = "perhaps" | "thou shalt not ask"
02:55:19 <Normality> or something like that perhaps...
02:55:41 <earthy> went to the proving code correct community
02:55:50 <Marvin--> if that's the kind of Haskell code you write, you won't pass that exam ;)
02:55:52 <earthy> saw a `Joseph Kinniry -- Netherlands'
02:56:19 <Normality> Good thing that's not the usual kind... 
02:56:35 * Normality shrinks
02:56:37 <earthy> clicked. bingo. found 2 personal friends of mine, one of whom I didn't know was on Orkut
02:56:58 <madgyver> DID he pass the exam ? :)
02:57:04 <Lunar^> earthy: Orkut is interesting for that
02:57:12 <shapr> yup, lotsa people there
02:57:30 <Normality> I'm still hoping... should've done better on the ADA part... 
02:58:19 <madgyver> we lost normality? whats NOW?
02:58:32 <Normality> damn, that sucked
02:59:08 <Lunar^> Normality: Where are you studying ?
02:59:24 <Lunar^> Normality: Haskell and Ada, that makes a good approach, IMHO
02:59:44 <Normality> University of the German Federal Armed Forces, Munich
03:00:05 <Normality> You may be right. The approach would be a lot better if the professor could actually TEACH
03:00:34 <Marvin--> there is always that, isn't there
03:00:49 <Normality> not always... but it seems to be the standard
03:00:57 <earthy> ah, that's where the Ada comes in. `Armed Forces'
03:01:00 <earthy> I was wondering.
03:01:27 <Normality> Could be... perhaps they just figured C++ (should be named D, anyway) is overloaded and Pascal too simple
03:01:47 <Marvin--> we do Haskell and Java first year
03:01:48 <Lunar^> earthy: I quite like Ada actually. Very constraining type system, which is good for newcomers
03:02:06 <Normality> As did we. Now we're into JAVA and machine-oriented (Assembler)
03:02:11 <Marvin--> used to be Ada instead of Java a few years ago (er, like...five years ago, damn, time flies)
03:02:47 <Normality> lunar: Good for newcomers, bad when you've only known the Pascal/Delphi line hence
03:02:52 <Lunar^> Marvin--: For what I saw, Java is not really suited for beginners
03:02:57 <Lunar^> Normality: Why that ?
03:03:00 <Marvin--> Lunar^: no kidding
03:03:24 <Lunar^> Marvin--: (but to promote Haskell this is quite a nice trick :))
03:03:39 <Normality> very constraining system... plus I personally think the code looks crappy :) +b end if;
03:03:43 <shapr> I don't think Java is suited to experienced programmers either.
03:04:01 <Marvin--> Lunar^: the scary part is that many still prefer Java even though they complain about it a lot
03:04:10 * earthy got taught in an Algol-68 derivative called Elan
03:04:12 <Lunar^> Marvin--: strange... why that ?
03:04:14 <liiwi> after-noon
03:04:18 <earthy> *very* nice
03:04:19 * Normality is still trying to figure out what Java is suited for... but we've only been doing it a couple of weeks now
03:04:31 <Lunar^> shapr: ... you are right ...
03:04:39 <Marvin--> Lunar^: I don't know, I think Haskell scares them :(
03:04:43 <Normality> Why not just start with Commodore Basic *g*
03:05:10 <earthy> oh, I *started* in Applesoft Basic, in fact. :P
03:05:11 <Marvin--> Lunar^: the way I think many see it is that Java is the lesser of two evils, sadly :(
03:05:18 <shapr> I think that's the biggest problem with Haskell, people are scared of it.
03:05:33 <liiwi> without good reason
03:05:44 * Lunar^ is scared when he can be sure of his code
03:05:56 <Lunar^> s/scared/anxious
03:05:58 <shapr> yes, without good reason
03:06:00 <earthy> lunar: because then the bug *has* to be yours? :)
03:06:07 <Normality> shapr: I think the problem is rather that the first language people usually learn nowadays are imperative and going back to functional seems ... unnatural
03:06:29 <Lunar^> earthy: I like being yelled by compilers :)
03:06:40 * earthy grinz
03:06:45 <Marvin--> Normality: I'm talking of both people who know imperative languages beforehand and people who don't
03:06:46 <Lunar^> earthy: I cry when I see NameException in Python
03:06:51 <Normality> lunar: Yeah, at least *someone* talks to you that day :)
03:06:56 <earthy> normality: the current curriculum in Nijmegen starts off with functional
03:06:59 <jesse> most java programmers dont even know what haskell is
03:07:13 <earthy> I'm not sure if Enschede still does, but it did a couple of years ago
03:07:22 <shapr> jesse: that's a point
03:07:23 <earthy> jesse: should they?
03:07:28 <jesse> i dunno
03:07:29 <jesse> lol
03:07:32 <shapr> but I've done my part on informing the #java channel :-)
03:07:37 <Lunar^> shapr: lol
03:07:39 <Normality> Hmm... I got tought TPascal at school
03:07:51 <Normality> lol
03:08:35 <liiwi> wish we were taught lisp back then
03:09:21 <Normality> No, language lessons in schools shouldn't incorporate teaching those impediments...
03:09:24 <shapr> I sort of enjoy stretching my brain to learn new things
03:09:25 <Lunar^> liiwi: SHould I feet the troll ?
03:09:30 <shapr> then I get to see if they're cool or not
03:09:36 <Lunar^> liiwi: feed actually ;)
03:09:45 <Marvin--> yay, troll feet
03:09:54 <Normality> Feet of Clay, so to speak
03:10:17 <Normality> Although I'd prefer a feed of a cray
03:12:24 <shapr> lessee, what code should I write today.
03:12:38 * Marvin-- sighs
03:12:43 <Marvin--> I need to start working on my presentation
03:13:10 <jesse> shapr, well haskell as a new thing is definately one that requires it
03:14:54 <madgyver> <shapr> then I get to see if they're cool or not
03:14:56 <madgyver> <Lunar^> liiwi: feed actually ;)
03:14:56 <madgyver> <Marvin--> yay, troll feet
03:14:56 <madgyver> <Normality> Feet of Clay, so to speak
03:14:56 <madgyver> <Normality> Although I'd prefer a feed of a cray
03:14:56 <madgyver> <shapr> lessee, what code should I write today.
03:14:57 <madgyver> * Marvin-- sighs
03:15:02 <madgyver> bullshi*
03:15:03 <Normality> shapr: A bot for spider solitaire so that I don't have to shove the cards around myself but can just enjoy watching it.
03:15:31 <Marvin--> madgyver: dude, you suck
03:15:41 <madgyver> Mac OS X has great cutnpast capabilities
03:15:56 <Normality> If he does it again, he gets slapped. Has more educational value than banning, really
03:16:26 <shapr> jesse: yah, I think I'll try to stretch myself around some arrows 
03:16:41 <shapr> I've been reading stepcut's Unix Arrows
03:16:44 <Lunar^> shapr: Good idea, I would be glad to hear your attempts
03:16:46 <shapr> but I still don't quite get it.
03:16:52 <Lunar^> shapr: Where's that ?
03:17:24 <shapr> oh, he mailed it to me
03:18:17 <Lunar^> I need really need to shut IRC off this afternoon
03:18:23 <Lunar^> Please kick me if I say anything please
03:18:46 <shapr> heheh
03:18:50 <shapr> yes, I need to work also
03:19:07 <shapr> but I'd rather be writing Haskell code.
03:19:15 <shapr> but nooo, I'm going to write Python all day.
03:19:23 <shapr> well, at least it's not Java.
03:19:50 * madgyver has to learn java NOW....
03:19:53 <Normality> Hmm... I think I'll skip all of that and drive home to my wife in an hour or so... hehe
03:20:07 <madgyver> f*****
03:22:16 * madgyver has to drive over 600km to his wife...
03:23:02 * Normality breaks into sinister laughter
03:23:08 <jesse> ive been trying to swallow haskell whole for the past week (which probably isnt the best idea) but i still dont understand the nature of monads or how they help with 'referential transparency' and IO.
03:23:28 <earthy> jesse: they don't, really
03:23:35 <jesse> thats the impression i got
03:23:44 <earthy> what they do is hide the tedium
03:24:01 * shapr breaks into dextrous laughter
03:24:09 <earthy> think of stuff under the IO monad as an `IO-program' that you're building
03:24:22 <madgyver> normality didnt REALLY laught!
03:24:36 * Normality objects
03:24:38 <earthy> now, in a normal functional setting you'd have to schlepp the program that you're building around
03:24:57 <earthy> using monads you can hide that
03:25:18 <earthy> ofcourse, the implementation doesn't do it quite like that, but it is a good conceptual view
03:25:44 <earthy> (at least for the IO monad)
03:25:48 <Marvin--> "I can't do I/O, but if I *could*, it would look something like this" ;)
03:26:01 <shapr> Normality: dude, we don't have objects around here, we use monads or partial application or something 
03:26:04 <earthy> marvin--: :)
03:26:12 <Heffalump> yeah, basically IO involves writing a function from worlds to worlds
03:26:13 <Normality> lol
03:26:14 <Normality> okay...
03:26:28 <Heffalump> and the IO monad just helps you compose functions from worlds to worlds with each other
03:26:39 <Heffalump> into one big World->World function
03:26:41 <shapr> hi Shammah, how's code?
03:26:46 <earthy> while hiding the fact that you're passing around the world
03:26:50 <Heffalump> then along comes the runtime system, and provides an input World for your benefit
03:26:55 <shapr> worldPeace :: World -> World
03:26:55 <earthy> and allowing for some optimizations. ;)
03:27:00 <Shammah> code's going well.
03:27:09 <shapr> ioError "not while any two humans are alive!"
03:27:13 <Heffalump> deleteWar :: World -> World
03:27:14 <Shammah> although I have a fair bit of refactoring to do in my near future.
03:27:25 <shapr> Shammah: oh, Haskell refactoring?
03:27:28 <earthy> shapr: that would more correctly written   worldPeace :: *World -> *World   in Clean :P
03:27:35 <Shammah> shapr: nope.  java :(
03:27:42 <shapr> ah, too bad
03:27:45 <Shammah> still, could be worse.
03:27:52 <Spark> see plus plus
03:27:54 <Shammah> (could be alot worse!)
03:28:11 <shapr> yes, that's true
03:28:21 <Spark> C, function pointers and structs with other structs as their first members
03:28:25 <Normality> No, let him write it without *... or prevent him from writing it at all. I'd be out of a job if world peace broke out
03:29:02 <Spark> apart from a couple of bangs in the night, world peace pretty much has broken out :)
03:29:13 * madgyver would be happy to loose his job
03:29:33 <jesse> that makes allot of sense, well, it makes enough sense for now
03:29:36 <Normality> Spark: Then I can only hope our government doesn't realize in the next 40 years...
03:29:45 <jesse> @ monad explanation
03:29:46 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
03:29:46 <Spark> safe bet :)
03:29:57 <Normality> good *phew
03:30:12 <Spark> lambdabot: @listcommands
03:30:13 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions
03:30:13 <lambdabot> ,"del-definition","det","devils","dict","dict-help","dummy","dump","dynamic
03:30:13 <lambdabot> load","dynamic-reload","dynamic-unload","easton","echo","elements","eval
03:30:13 <lambdabot> ,"foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock
03:30:13 <lambdabot> ,"jargon","join","karma","karma+","karma-","learn","leave","listchans",
03:30:14 <lambdabot> listcommands","listmodules","lojban","moo","more","msg","musasabi","part
03:30:16 <lambdabot> ,"prelude","quit","reconnect","resume","seen","set-fuel","shapr","state
03:30:18 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
03:30:20 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
03:30:21 <Spark> whoa
03:30:42 <Normality> lambdabot: @karma+
03:30:42 <Shammah> heh, would you mind doing that via /query next-time ;)
03:30:43 <lambdabot> I can't find the karma of nobody.
03:30:55 <Normality> oh, no prob, got some right here
03:31:03 <Spark> @eval print "Good morning Dave."
03:31:03 <lambdabot> unbound variable: print
03:31:05 <Spark> :(
03:31:38 <Normality> I'm sorry, Spark, I'm afraid he can't do that.
03:33:27 <earthy> @eval [ (x,x*x) | xs <- [30..50] ]
03:33:27 <lambdabot> (line 1, column 5):
03:33:27 <lambdabot> unexpected ","
03:33:27 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character
03:33:27 <lambdabot>  "[", string, "(", operator, simple term or ")"
03:33:43 <earthy> @eval [ (x,x*x) | x <- [30..50] ]
03:33:44 <lambdabot> (line 1, column 5):
03:33:44 <lambdabot> unexpected ","
03:33:44 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character
03:33:44 <lambdabot>  "[", string, "(", operator, simple term or ")"
03:33:49 <shapr> he doesn't do list comps
03:33:54 <earthy> ahhhhh. ;)
03:33:59 <earthy> not at all or not toplevel?
03:34:02 <shapr> the Eval plugin is a lambda cal interpreter
03:34:21 <earthy> pity :)
03:34:25 <shapr> if the ghci plugin is plugged in, he does everything, but it's not terribly secure.
03:34:38 <earthy> `duh'
03:34:38 <shapr> @karma+ lambdabot 
03:34:39 <lambdabot> lambdabot's karma has been incremented.
03:34:51 <earthy> @karma shapr
03:34:51 <lambdabot> shapr has a karma of 0
03:34:57 <earthy> @karma+ shapr
03:34:57 <lambdabot> shapr's karma has been incremented.
03:35:01 <earthy> ;)
03:35:04 <shapr> anyway, it's fun to write lambdabot plugins, that's why he's here.
03:35:14 <shapr> too bad he doesn't save karma ;-)
03:35:22 <shapr> we should persuade someone to add that
03:35:37 <Normality> @eval (\g. \a. \f. a f a) ((\x. x x) (\x. x x)) (\x. f x)
03:35:38 <lambdabot> <<EM Dynamic -> EM Dynamic>>
03:35:45 <shapr> wow, that's quite a picture of Frank Atanassow
03:36:00 <shapr> @eval (\x . x x)(\x . x x)
03:36:05 <shapr> that's the omega combinator, yah?
03:36:08 <earthy> it's the default one, also on his website, and, IIRC, on the cs.uu.nl website
03:36:12 <Normality> @eval ((\g. \a. \f. a f a) ((\x. x x) (\x. x x)) (\x. f x))
03:36:20 <lambdabot> out of fuel - use @resume to continue
03:36:20 <lambdabot> <<EM Dynamic -> EM Dynamic>>
03:36:29 <Normality> lol@lambdabot
03:36:42 <Heffalump> hehe
03:36:50 <Heffalump> @resume
03:37:02 <earthy> *boom*
03:37:05 <Normality>  @eval ((\g . \a . \f . a f a) ((\x . x x) (\x . x x)) (\x . f x))
03:37:11 <Heffalump> hmm...
03:37:12 <lambdabot> out of fuel - use @resume to continue
03:37:17 <Normality> @resume
03:37:38 <lambdabot> out of fuel - use @resume to continue
03:37:47 <Normality> Hmm... damn
03:38:48 <jesse> so monads, esentially, hide references?
03:39:38 <Heffalump> not really
03:39:43 <Heffalump> well, what do you mean by references?
03:40:40 <jesse> something that refers to some kind of unique object
03:44:05 <earthy> nope.
03:44:17 <earthy> you can use monads to do that
03:44:43 <Heffalump> monads basically allow you to hide "plumbing"
03:44:55 <Heffalump> of a particular structure
03:50:19 <Marvin--> I think what's important to remember with monads is that they're not completely defined by just defining >>= and return, you also need a "runner" function that lets >>= know what to do with the plumbing
03:50:35 <Marvin--> the IO monad is safe precisely because you do not have access to the run function
03:53:02 <Normality> well, gotta run. Wife's waiting. Farewell
03:53:25 * Normality waves
03:53:31 <earthy> actually, ;) monads *are* completely defined by the type constructor, >>= and return
03:53:53 <Marvin--> well, yeah, but without the run function they're completely uninteresting
03:53:55 <earthy> however, you may not have any use for them unless you write a runner function. ;)
03:54:18 <earthy> not completely interesting. the state monad e.g. does *not* need a runner function
03:54:27 <earthy> +un somehwere
04:01:25 <Marvin--> yes and no
04:01:37 <Marvin--> if you can guarantee that there is no get before there's a set, sure
04:02:27 <earthy> ummm... other example. the Maybe monad. >:P
04:02:46 <Marvin--> that's just because you have access to the constructors
04:02:57 <earthy> *so*?
04:03:00 <Marvin--> if you didn't have access to Just and Nothing it would be kinda pointless
04:03:12 <earthy> you don't *need* the runner function, that's all I'm saying
04:03:14 <Marvin--> in essence, a case expression becomes the runner
04:03:19 <earthy> but it will quickly get uninteresting
04:03:38 <Marvin--> all *I'm* saying is that *in general* you need a runner function to get anything interesting going :)
04:04:10 <earthy> :)
04:09:27 <Marvin--> I think I had my "aha" moment for monads when Koen used them in the context of embedded languages in our advanced functional programming course
04:10:52 * earthy had his `aha' moment when he understood the continuation-passing-style monad transformer. :)
04:11:08 <Marvin--> ContT is pure evil :)
04:11:57 <jesse> i think i get it, but in general, even for the state monad, it symbolizes some kind of referencing. you are dealing with "something" rather than different things of the same type
04:12:12 <Marvin--> I use a  Cont ShowS   in my program to concatenate lots of strings
04:12:28 <jesse> or, thats the illusion they are creating
04:13:16 <earthy> jesse: it is, because that, when you understand monads, is the clearest use
05:17:23 <SyntaxNinja> hmm. so did anyone end up getting a "What part of <H-M type system> don't you understand" t-shirt?
05:18:46 <Igloo> Kirsten did
05:19:55 <Lunar^> GCC 3.4.0 released
05:20:24 <SyntaxNinja> Igloo: did it work?
05:20:52 <Igloo> Yeah - you might want to mail her and ask if it wore particularly badly
05:22:08 <Lunar^> "Optimization of indirect tail calls is now possible in a similar  fashion as direct sibcall optimization."
05:22:55 <earthy> schweet
05:23:08 <keverets> I really need to make a package of HaXml so that I can easily update it everytime I install a new ghc.
05:23:42 <Igloo> What do you mean by package?
06:23:31 <shapr> yeehaa
06:23:37 <shapr> code is a wonderful think
06:23:40 <shapr> er thing
06:24:10 <earthy> the wonderful thing about code is that code is a wonderful thing
06:24:22 <shapr> what a wonderful code!
06:25:35 <ozone> oh, Smerdyakov is back on #haskell?
06:25:40 <ozone> why was he banned?
06:25:50 <shapr> for accumulated amounts of being an asshole
06:26:28 <shapr> he's been mostly nice since I told him being nice is the price of being unbanned.
06:26:30 <ozone> ok.  i won't ask any more since he appears to be back on
06:36:07 <Lunar^> shapr: I'll be glad to talk about that IRL if we met
06:36:25 <shapr> code?
06:36:59 <Lunar^> shapr: but right now I don't think that saying to someone that he's an asshole helps being nice
06:37:26 <shapr> I agree, it doesn't help.
06:38:36 <shapr> and I reserve that expression for cases of extreme frustration.
06:39:50 <shapr> and I must say, Smerdyakov has not been doing that since then.
06:44:41 <shapr> anyway, we now return you to your regularly scheduled Haskell discussion
06:46:11 <Lunar^> *sigh* Die Plone diee!
06:46:38 <shapr> Lunar^: you can come to #plone and maybe I can help you with your problems?
06:47:30 <Lunar^> It's more a feeling than a problem
06:47:39 <shapr> ok
06:49:05 <Lunar^> shapr: That damn skin is now 7400 lines long, which is WAY to much IMHO
06:52:48 <shapr> which skin?
06:53:13 <Lunar^> The project I told you few weeks ago
07:17:05 <keverets> Igloo: debian package
07:17:05 <keverets> unless there is one already somewhere.
07:17:59 <keverets> having to remake a package.conf manually every time I install a new ghc6 debian package is really annoying.
07:39:52 <shapr> yah, I want some debs too
07:39:59 <shapr> I want an HSQL and a HaskellDB deb
07:40:06 <shapr> but not quite enough to actually sit down and make some :-)
07:52:07 <shapr> hi flaw
07:53:13 <flaw> hi
07:53:49 <shapr> are you learning Haskell?
07:54:57 <flaw> yeah, but not aggressively; many other things to do concurrently.. =\
07:55:32 <shapr> I can understand that.
07:55:53 <shapr> well, if you have questions, ask away
07:56:04 <flaw> functional coding appears to be the next Big Thing(tm), so I feel I should keep in touch with it..
07:56:17 <shapr> it sure is cool, I'll say that.
07:56:23 <Lunar^> Solveig laughed a lot when she read "Aggressive usage of the lazy evaluation" on my report.
07:59:05 <Marvin--> ho hum
07:59:08 * Marvin-- wants to play go
07:59:38 * Marvin-- pokes SyntaxNinja
07:59:49 <SyntaxNinja> hi Marvin--
07:59:56 <SyntaxNinja> can't play go, I'm at work and stuff
08:00:00 <Marvin--> dang
08:00:14 <Marvin--> guess I'll go back to pretending to work on my report, then
08:00:52 <SyntaxNinja> there should be other go players here
08:01:04 <SyntaxNinja> maybe you should post to haskell-cafe, such a cafe might be a good place to play ;)
08:01:17 <Marvin--> heh
08:03:19 * Marvin-- hops onto NNGS to watch a game in progress
08:03:27 <Marvin--> 19x19 is really really big
08:04:32 <Lunar^> Marvin--: Did you test ned's work ?
08:04:41 <shapr> yes, his go game is nifty
08:05:24 <Lunar^> shapr: He's a nifty guy... he just lack some self-confidence in his programing ability
08:05:31 <Lunar^> otherwise he would be a wonderful coder
08:06:05 <Marvin--> no? url?
08:06:46 <shapr> well, best way to improve confidence is to write code and see it work
08:06:54 <Lunar^> Marvin--: It's an anarchist Go game: no position has less freedom than any other
08:07:18 <Marvin--> uh
08:08:00 <Lunar^> Marvin--: so the field is actually a torus
08:08:09 <Lunar^> shapr: It was on gforge
08:08:19 <shapr> hm
08:10:46 <shapr> the network and Opengl support of ned's go game was quite nifty
08:11:24 <MakeMyDay> is there somewhere else I can download Hugs for linux ? The main site is refusing my connection (?)
08:12:04 <Lunar^> MakeMyDay: It was compromised lately
08:12:20 <MakeMyDay> ahh
08:12:32 <Lunar^> MakeMyDay: What distro are you using ?
08:12:52 <MakeMyDay> Slaskware
08:12:56 <MakeMyDay> Slackware 
08:13:17 <Lunar^> MakeMyDay: You could get Debian hugs source package maybe
08:20:25 <SyntaxNinja> makeMyDay: http://ftp.debian.org/debian/pool/main/h/hugs98/hugs98_98.200311.orig.tar.gz
08:26:14 <MakeMyDay> ow thx
08:27:18 <flaw> what is the most popular/used haskell compiler? I installed ghc6 but a lot of the hs-* ports want ghc5..
08:27:40 <earthy> um, well. ;)
08:27:42 <Lunar^> flaw: update them ?
08:27:51 <earthy> ghc5 is deprecated, imho
08:28:11 <earthy> which reminds me that I still need to debug the attempt at installing ghc6 here
08:29:22 <flaw> Lunar^: the ports? yeah, I sup them daily..
08:29:45 <Lunar^> flaw: No, I'm talking about updating the ports to work with ghc6
08:31:03 <flaw> Lunar^: I don't think the projects/code supports ghc6.. I've tried to coerce them, but they just don't want to surrender.. [not too sure really, tho]
08:31:35 <flaw> a few do, but I think hs-gtk, hs-gl dont, iirc..
08:33:48 <Lunar^> flaw: hs-gl is in GHC distrib now
08:33:57 <flaw> k
08:34:13 <Lunar^> flaw: --enable-open-gl if I remember well
08:34:22 <Lunar^> flaw: --enable-opengl more probably
08:35:08 <flaw> oh, doh
08:36:20 <flaw> ok, correction hs-gtk2hs uses 6.2
08:45:17 <flaw> nice, compiling it again will hopefully be faster with 512mb than 128mb...
09:30:29 <flaw> wow, ghc takes a _long_ time to compile...
09:31:13 <shapr> it can do that
09:31:36 <Marvin--> compilers often do
09:33:01 <flaw> I think mozilla might have a shorter compile time..
09:36:48 <Riastradh> I bet Stalin has a longer compile-time.
09:41:16 <rt> ghc is the second longest thing I've ever compiled on my box at home.
09:41:58 <rt> i believe that all of the gnome stuff takes somewhat longer.
10:28:57 <flaw> grr, failure while compiling gl BasicTypes
10:36:49 <flaw> grr, damn port.. config.h doesn't define GLENUM or similar HTYPEs for GL...
10:38:42 <flaw> I will see if I can hack in some appropriate values..
11:03:29 <shapr> yow!
11:03:52 <shapr> it's too cold outside!
11:06:08 <Marvin--> nah, pretty nice if a bit windy
11:06:10 <Spark> move to the equator :)
11:06:27 <flaw> 23C here
11:07:17 <stepcut> ha, I searched for 'module functors haskell' and a relavant 'sponsered link' came up
11:07:40 <Spark> hmm what are functors?
11:07:51 <stepcut> well....
11:07:59 <Spark> another mathematical abstraction that from pure fluke happens to be important in FP? :)
11:08:01 <Marvin--> stepcut: heh
11:08:04 <ski> structure-preserving mappings between categories
11:09:21 <SyntaxNinja> actually, it's raining
11:09:42 <Spark> mmk
11:09:52 <stepcut> A functor is a structure-preserving map from one category to another
11:09:52 <stepcut> -- it maps objects to objects and morphisms to morphisms. In the case
11:09:52 <stepcut> where objects are sets and morphisms are functions, you can think of
11:09:52 <stepcut> functor F as a polymorphic operator on functions. 
11:10:26 <ski> Spark : functors are e.g. useful in FP for applying some function to every element of some (collection) datastructure, and get a new one with the 'same structure'
11:10:26 <stepcut> The type of F can be expressed as,  F : (a -> b) -> (F a -> F b)
11:10:39 <Spark> what, like map
11:10:45 <ski> yeah
11:10:50 <ski> @type fmap
11:10:50 <lambdabot> fmap :: Functor a => (b -> c) -> a b -> a c
11:10:54 <Spark> so theyre a special case of higher order function?
11:12:09 <ski> well
11:12:51 <ski> of the morphisms it converts from and to are 'function-like', yes  (they don't have to be)
11:12:57 <ski> s/of/if/
11:13:28 <ski> Spark : hello, btw :)
11:13:49 <Spark> hi
11:14:07 <ski> Spark = Spark_ ?
11:14:12 <stepcut> Spark: in ocaml, functors are used at the module level, instead of the function level
11:14:13 <Spark> yeah sometimes
11:14:23 <ski> right
11:14:30 <Spark> you reccommended i get that pierce book?
11:14:35 <Spark> is that right
11:14:56 <ski> i recommended something ?  when ? :)
11:14:59 <Spark> this is a friendly community, its so different to #c :)
11:15:03 <Spark> mm maybe it wasnt you then
11:15:34 <ski> i might have spoken about it, but i don't remember any recommendation :)
11:15:39 <Spark> "type and programming languages" or something liket hat
11:16:02 <Spark> i couldnt find it except in the US amazon site though, my library had a copy but its not due back until... october :)
11:16:35 <Spark> its possible ive got my wires crossed though
11:16:50 <ski> 2004-04-15 #haskell 13:40:59 <Cale> <emu> "Types and Programming Languages" Pierce, I have, it's decent
11:16:56 <Spark> bingo
11:17:08 <Spark> 3 letter nick name, close enough
11:17:16 <Spark> and theres another one
11:18:06 <Spark> so how is it you recognise me? :)
11:18:19 <Spark> were we talking about eurohaskell
11:19:54 <ski> didn't you talk about some type inference idea for spreadsheets ?
11:20:19 <Spark> yeah thats right
11:20:34 <Spark> ah you were the guy i was talking to in #math
11:20:49 <shapr> our friendliness spreads across channels :-)
11:21:38 <ski> Spark : no, i think you confuse me with someone else. i haven't been in  #math
11:22:17 <ski> possibly Cale
11:22:19 <ski> 13:35:54 <Cale> I was just looking for something online, as there's a person in #math who is working on type inference who hasn't seen HM yet.
11:22:25 <Spark> ah ok
11:22:28 <Spark> looks that way :)
11:22:34 <Spark> theres too many people on this planet
11:23:20 <kosmikus> we could organize a day where everyone on this channel logs in with a randomized nick, and we have to guess who's who ;)
11:23:36 <ski> lol
11:24:16 <Spark> still, yeah, i came to the conclusion that the type algorithm needed to be an extension of the HM idea
11:24:46 <Spark> and that it required to solve the problem of graph reachability, which is quite intensive
11:26:21 <Spark> im actually writing an essay on it now, which is going to become a chapter of my final report
11:26:39 <Spark> and by 'writing an essay on it now', i mean 'avoiding work and chatting on irc'
11:26:47 <shapr> kosmikus: if hostnames aren't hidden, it'd be pretty easy
11:28:46 <ski> Spark : mhmm
11:29:51 <Spark> when you make a redefinition in a haskell interpreter, it totally erases the old definition, and infers the type again from scratch, thats the difference between HM and my problem
11:29:53 <kosmikus> shapr: unfortunately, yes
11:30:16 <Spark> i have to allow the types to back down again, which isnt so straight forward
11:30:58 <shapr> have you looked at type slicing?
11:31:05 <Spark> hmm whats that?
11:31:36 <shapr> I think it does incremental typing of a bunch of code so that you can find out where the types can be inferred and where they clash
11:32:11 <Spark> http://info.dcs.warwick.ac.uk/~spark/3yp/writeup.ps  or pdf, about page 10/11 theres a diagram pretty clearly showing the problem
11:32:19 <ski> Spark : what do you mean by 'make a redefinition in a haskell interpreter' ?
11:32:42 <ski> Spark : like 'let f x = x+x' in GHCi ?
11:32:47 <Spark> yeah
11:32:53 <Spark> i assume you can overwrite definitions in the interpreter
11:32:56 <ski> no
11:32:59 <Spark> otherwise its just a compiler on stdin
11:33:00 <Spark> oh
11:33:00 <Spark> :)
11:33:06 <ski> just a new variable
11:33:20 <Spark> ok you can in mosml, thats the example to compare to
11:33:44 <shapr> Spark: oh, you should look at SPJ's presentation at HIM2003, he talked about backing off to less specific types after getting too specific
11:34:04 <ski> try 'let f x = x*2', 'let g x = f (f x)', 'let f x = x*3', 'g 10'
11:35:52 <Spark> ski: ah i understand now
11:35:59 <ski> :)
11:36:06 <Spark> shapr: where can i find that?
11:36:21 <ski> i would think that mosml would react in the same way
11:36:25 <Spark> ill try
11:36:55 <Spark> right you are
11:37:28 <Spark> that could be corrected with a layer that dealt with the dependencies between function definitions, and redefined a whole bunch of stuff for you
11:37:43 <Marvin--> preferrably not
11:37:43 <ski> corrected ?
11:37:55 <Marvin--> the ghci prompt acts like you're inside a do expression
11:37:57 <shapr> Spark: http://research.microsoft.com/~simonpj/papers/putting/index.htm
11:38:01 <Marvin--> that's a feature, not a bug :)
11:38:08 <ski> right
11:38:17 <Spark> one of my conclusions has been that the EM stuff that i'm working with has so much in common (at the computation level) with functional languages that the whole thing could probably just be a wrapper around some FP compiler
11:39:07 <Spark> yeah well i agree theres no need to do that unless redefinitions are a fundemental part of the environment (like they are in this project) :)
11:39:14 <ski> sorry, what was EM ?
11:39:22 <Spark> Empirical Modelling
11:40:00 <ski> hmm
11:40:14 <Spark> empirical because you're experimenting with ideas in your problem domain, trying to find a solution, and modelling (as opposed to programming) because of hte interactive nature of that process
11:40:55 <Spark> spreadsheets being the most well known example
11:41:27 <ski> i'm not sure how that 'modelling' is not programming ..
11:41:48 <Spark> traditionally programming is an activity of specification, followed by implementation, followed by testing
11:42:17 <shapr> no way!
11:42:21 <Marvin--> followed by specification, implementation and teseting again, and again and again
11:42:25 <shapr> right
11:42:32 <Spark> im a bit crap at explaining this since it confuses me :)
11:42:33 <Marvin--> where specification is often done by implementing
11:42:38 <shapr> I think it's a) guess b) write code that implements that guess c) see where it breaks
11:42:41 <shapr> a) make a better guess
11:43:08 <Marvin--> "specify, implement, test" is a myth
11:43:17 <Spark> the thing is programming paradigms arent too good for that since the period of that cycle is very long
11:43:34 <Spark> hence an environment where you get immediate feedback :)
11:43:56 <Spark> here ill just throw the URL:  http://www.dcs.warwick.ac.uk/research/modelling/
11:44:00 <shapr> in fact, Extreme Programming is all about highly interactive development
11:44:19 <shapr> nay, there's an easy way to get a short period, even in Haskell.
11:44:46 <Spark> well XP is a step in the same direction, but this is much more so
11:45:15 <Spark> my supervisor has often said that XP methodology has some things in common with EM
11:45:23 <shapr> http://www.haskell.org/hawiki/HaskellMode
11:45:37 <shapr> look at the cute trick at the bottom of the page.
11:46:37 <shapr> since I wrote that, I've discovered a way to do test-first with QuickCheck also, but it requires extending QC a bit.
11:47:03 <Spark> cool
11:47:24 <shapr> a lot of XP started on WardsWiki some years back
11:47:42 <shapr> there's an abundance of really useful patterns for quality programming there
11:49:04 <ski> shapr : maybe you could write some about that on the wiki ?
11:49:27 <shapr> http://c2.com/cgi-bin/wiki?SandglassProgramming
11:49:27 <ski> (i.e. re. QC testing)
11:49:34 <ski> oh
11:49:40 <shapr> well, I emailed it to John Hughes
11:49:50 <Spark> shapr: ah yeah i did grab that paper a while back, i didnt really understand it though :)
11:49:58 <shapr> which paper?
11:50:02 <shapr> oh, QuickCheck?
11:50:15 <shapr> QuickCheck beats unit testing with a stick.
11:51:04 <shapr> check this out: http://www.scannedinavian.org/~shae/ProtoQuickCheck.hs
11:51:14 <Spark> http://research.microsoft.com/~simonpj/papers/putting/index.htm  <-- that paper
11:51:19 <shapr> oh, that one
11:51:28 <Marvin--> shapr: yes and no, you still need to verify that your generators are sane
11:51:43 <Spark> unfortunately i have not much experience with FP, and not much with maths either :)
11:51:52 <shapr> have you read Pierce's TaPL?
11:52:20 <Spark> nah i couldnt find it
11:52:45 <Spark> no copies in the library, nothing on amazon, nothing in the book shop
11:52:51 <shapr> If you want to do type inferencing, you should probably buy it, keep it under your pillow :-)
11:53:30 <Spark> mm :)
11:53:41 <kosmikus> Spark: no TAPL on amazon?
11:53:42 <Spark> i really should get a copy
11:53:51 <Spark> its on amazon.com but not amazon.co.uk
11:53:57 <Spark> and shipping times are too long for the US
11:54:00 <shapr> I bought it from amazon.uk
11:54:06 <Spark> really?
11:54:08 <shapr> I must have gotten the last copy :-)
11:54:45 <Spark> its not even listed though last time i looked
11:55:03 <kosmikus> Spark: are you in the UK?
11:55:24 <Spark> yeah
11:55:24 <Spark> coventry
11:56:10 <kosmikus> .co.uk says "usually dispatched within 2 to 3 days."
11:56:24 <Spark> please, give me the direct URL to the book :)
11:56:26 <kosmikus> http://www.amazon.co.uk/exec/obidos/ASIN/0262162091/qid=1082573748/sr=1-7/ref=sr_1_10_7/026-1126151-3234803
11:57:15 <Spark> i searched for exactly that string, and didnt get it
11:57:17 <Spark> amazing :)
11:57:19 <Spark> thanks
11:57:22 <ski> also, pierce's info is at http://www.cis.upenn.edu/~bcpierce/tapl/
11:58:04 <kosmikus> Spark: me neither, but I couldn't believe it, so I persisted ;)
12:00:39 <Spark> cool
12:02:44 <Spark> wonder if theres anything else i should get while i'm at it
12:03:55 <ski> Spark : maybe  Polymorphic Type Inference - Michael I. Schwartzbach - http://www.brics.dk/~mis/typeinf.ps  would be interesting ?
12:04:25 <ski> or do you only want a monomorhic system ?
12:07:57 <Spark> thats quite interesting actually
12:08:05 <ski> yeah :)
12:08:07 <Spark> it mirrors my own conclusions about type :)
12:08:40 <Spark> would you mind reading my essay actually, its not quite finished (4000 words) but its got pretty pictures and stuff
12:09:42 <ski> i can at least look at it, i guess ;)
12:10:00 <ski> (e.g. : no problem)
12:10:20 <esap> the principal type scheme from that paper is pretty awesome.
12:10:32 * ski lols
12:10:35 <ski> yeah
12:11:32 <Spark> cool, i apoligise if it gets boring, ive not written much before :)
12:11:51 <ski> no prob :)
12:11:56 <Spark> esap: which paper?
12:12:07 <ski> where 'sit ?
12:12:20 <Spark> http://info.dcs.warwick.ac.uk/~spark/3yp/writeup.ps
12:12:23 <ski> Spark : Schwartzbach's
12:12:31 <ski> thanks
12:12:33 <esap> spark: the type inference paper, page 17-19
12:12:35 <Spark> ahh
12:13:22 <Spark> lol
12:15:15 <shapr> ahem
12:15:18 <shapr> eurohaskell
12:15:27 <shapr> right, saving failing QC cases
12:15:36 <shapr> if you save the seed, that's compact and simple
12:15:41 <shapr> but it breaks when you change the generator
12:16:29 <shapr> so I was thinking a) save the seed b) have something that generates & saves instances from seeds + generator for when you want to change the generator
12:16:57 <shapr> oh, I spoke to bea about SGS Veckobostader
12:17:15 <shapr> it seems that the three days of the EP conference are getting full fast
12:17:34 <Marvin--> no wonder
12:18:10 <shapr> anyways, if QC can save a failing test case, I can do test-first with QC
12:18:19 <shapr> and then I'll be a very happy camper.
12:18:51 <shapr> oh, I *gotta* send those invites!
12:18:57 <shapr> yow
12:21:22 <bring> john said that if we do the test coverage thing, Colin Runciman might like to come
12:21:41 <shapr> cool :-)
12:21:43 <bring> does he hang out in here?
12:21:47 <shapr> shall we invite him too?
12:21:57 <shapr> I don't think so.
12:22:02 <shapr> he looks like he exercises in his spare time.
12:22:09 <bring> haha
12:22:16 <shapr> have you met him?
12:22:21 <bring> no
12:22:46 <shapr> I think you would have had to add together three or four of the average attendee to get as many muscles as Colin Runciman has.
12:22:55 <shapr> I'm speaking of the ICFP03, that is.
12:23:08 <bring> ok, I'll try to get an extra room
12:23:21 <shapr> just for him and his muscles? ;-)
12:23:26 <Spark> is he tall and green? :)
12:23:32 * shapr laughs
12:24:11 <shapr> most of the ICFP03 attendees looked like me, just slightly out of shape.
12:24:19 <shapr> a bit too round
12:24:38 <shapr> I think that's part of why he stood out so much
12:30:34 <Marvin--> Colin Runciman is one of the Hat people, right?
12:34:44 <shapr> ok, I'll add him to the list of people to get the invite
12:34:54 <shapr> who was on the list again?
12:35:14 <shapr> phillipa, Spark, Graham Hutton, Colin Runciman
12:35:24 <shapr> bring: who have I forgotten?
12:35:44 <bring> you mentioned the simons before
12:35:53 <shapr> oh right!
12:36:04 <ski> which list ?
12:36:11 <Marvin--> that'd be awesome if Simon^2 came
12:36:21 <shapr> the list of people to get an email inviting them to EuroHaskell
12:36:25 <shapr> Marvin--: I think it's highly unlikely
12:36:33 <shapr> but fun to send the invite
12:36:44 <Marvin--> yeah, well...
12:36:45 <bring> I'm starting to think that maybe we should announce it on one of the haskell lists
12:36:46 <shapr> I agree though, would be nice to code with them
12:36:59 <bring> so that people don't feel left out :)
12:37:00 <shapr> bring: that's fine with me, what do you think?
12:37:04 <shapr> heh, good point
12:37:38 <shapr> as long as we preserve the spirit of "focus on writing code"
12:37:42 <bring> up til now it's mostly been know to people who hang out here, or that we happen to talk to
12:37:59 <shapr> I was miffed when the Fun of Programming bash didn't have any programming!
12:38:36 <Spark> im hoping to use this opportunity to acquire a clue :)
12:38:58 <shapr> and reading a bunch of papers isn't nearly as education as sitting next to someone who is writing code
12:39:30 <shapr> Spark: spark at xdev net right?
12:39:35 <Spark> yeah thats it
12:39:50 <shapr> ok
12:43:10 <shapr> ok, anyone else I should add to the invite list? or should I just send a copy to haskell@haskell.org ?
12:44:38 * shapr adds bring to the To: list
12:45:27 <bring> oh, I can come?
12:45:55 * shapr grins
12:46:08 <shapr> I really hope you'll be there, I'm crap at organizing.
12:46:32 <shapr> at least, without having hours to think about the answer to a question.
12:48:37 <bring> btw, formally, EuroHaskell is being organized by the CS department at Chalmers
12:48:55 <shapr> cool
12:49:02 <bring> makes getting rooms and net access a lot easier it seems
12:49:02 <shapr> shall I change that in the invite?
12:49:06 * shapr was just about to send it off
12:49:49 <shapr> or do you think it's sufficient to have a chalmers person as the first listed disorganizer?
12:50:03 <Spark> whats it all about, anwyway?
12:50:03 <Spark> is it like a formal conferance, rior some kind of academic lanparty :)
12:50:12 <bring> the latter
12:50:15 <shapr> right
12:50:21 <shapr> I like that summary
12:50:29 <shapr> an academic lanparty
12:50:53 <bring> let's make an FAQ
12:51:14 <shapr> Spark: this all started some months back when bring said "shapr, you should come down to gothenburg sometie so we can have a hackfest"
12:51:42 <Spark> so its all about sleeping on the floor in a sleeping bag, amidst the hum of solaris machines? :)
12:51:59 <shapr> EuroPython sucked me into being an organizer this year (last time was in 2002), and it just so happens EuroPython will be in gothenburg ... so...
12:52:48 <shapr> so in fact, this is still bring's hackfest, we're just inviting more people than originally expected.
12:53:27 <bring> I don't recall most of this
12:53:46 * shapr grins
12:54:04 <shapr> we started calling it EuroHaskell as a joke on EuroPython
12:54:33 <Spark> if you mix the two together, you get pascal :)
12:54:38 <shapr> aiee!
12:55:15 <SyntaxNinja> oh no
12:55:47 <bring> the wiki seems slow right now
12:56:06 <bring> added FAQ section
12:56:18 <shapr> yay
12:56:50 <bring> not that Spark's question is a faq, they rarley are
12:57:04 <shapr> well, this is the second or third time someone asked that
12:57:12 <bring> oh
12:57:13 <bring> ok
12:57:24 <shapr> I dunno how many is required for frequently
12:58:09 <shapr> so, should I leave the invite the way it is on the wiki? or change it to the Chalmers CS department?
12:59:54 * shapr pokes bring 
13:00:02 <bring> I changed the invitation in the wiki a little
13:00:06 <shapr> ok
13:00:37 <bring> just said "at Chalmers ..." instead of "on the Chalmers campus", that sort of indicates that it is organized by chalmers
13:00:45 <shapr> sounds good
13:01:21 <bring> I don't think we should stress to much that it's organized by the department, then people might try to ask them questions about it
13:01:30 <shapr> that would be entertaining :-)
13:02:34 <shapr> ok, I'm going to send it off to peoples first
13:03:01 <bring> sounds good
13:03:29 <shapr> ok, think it should go to haskell or haskell-cafe as well?
13:03:48 <bring> got it
13:03:54 <shapr> cool
13:04:00 <shapr> Spark: got it?
13:04:26 <bring> maybe haskell-cafe is more appropriate than haskell?
13:04:30 <bring> dunno
13:04:32 <Spark> fetchmail: background fetchmail at 8930 awakened.
13:04:43 <shapr> I dunno either
13:05:50 * shapr flips a coin
13:05:57 <Spark> yep its good
13:06:21 <shapr> the coin says haskell-cafe
13:06:57 <Spark> @eval if random()>.5 then "yes" else "no"
13:06:57 <lambdabot> (line 1, column 11):
13:06:57 <lambdabot> unexpected ")"
13:06:57 <lambdabot> expecting simple term
13:07:07 * bring would like a coin that says haskell-cafe
13:07:42 * bring wonders what you could buy with it
13:08:15 <Spark> ok some more questions
13:08:17 <shapr> haskell coffee made from deforested lambdas?
13:08:22 <Spark> presumably everyone will be able to speak english if required :)
13:08:39 <shapr> I'm from Alabama, I dunno if that counts as english ;-)
13:08:52 <Spark> near enough
13:09:08 <Spark> im not sure about this whole sweden thing you see :)
13:09:08 * bring doesn't speak english
13:09:20 <Spark> its very... foreign
13:09:34 <shapr> Spark: it's hard enough to find people who will speak swedish with me out here in the boonies.
13:09:58 <Spark> i like the idea of a place with goth in the title though, maybe i should wear my net top and leather trousers
13:10:14 <shapr> gothcon does happen in gothenburg I think
13:10:37 <shapr> two of the EuroPython organizers also organize GothCon
13:10:50 <Spark> mm cool
13:10:58 <bring> it has nothing to do with goth though, afaik
13:11:12 <shapr> yah, it's gteborg in swedish (I think)
13:11:30 <bring> I was talking about gothcon :)
13:11:34 <shapr> oh
13:12:31 <Spark> ive never heard of it, but it could potentially be a goth gathering, they happen occasionally :)
13:12:37 <bring> ask Marvin--, he was there
13:12:49 * shapr pokes Marvin-- 
13:13:40 <Marvin--> it's most definitely not a goth gahering :)
13:13:51 <shapr> http://www.gothcon.se/idle/main/index.htm
13:13:53 <Marvin--> it's a gaming convention
13:13:57 <Spark> ah
13:13:59 <Marvin--> Sweden's biggest gaming convention
13:14:10 <shapr> awesome
13:14:25 <Marvin--> and when I say gaming I don't mean computers
13:14:35 <shapr> D&D etc?
13:14:44 <shapr> bring: so, you think haskell-cafe is good?
13:14:46 <Spark> role playing?
13:15:05 <Marvin--> role playing, board gaming, card gaming, tabletop...
13:15:15 <Marvin--> larp
13:15:24 <bring> hmm, all other announcements go to haskell, but they're a lot more formal
13:15:31 <Spark> gotcha
13:16:08 <Lor> marvin, ha, we're bigger.
13:16:21 <shapr> Lor: coming to EuroHaskell?
13:16:31 <Marvin--> shapr: which two people are you talking about?
13:16:35 <shapr> would be fun to see you again :-)
13:16:35 <Lor> ropecon had >3000 people last year.
13:16:36 <Marvin--> shapr: (re gothcon and EP)
13:16:48 <shapr> Marvin--: I thought Jacob said he was part of the organizers of GothCon
13:17:02 <bring> haskell@haskell.org
13:17:02 <bring>     Announcements, discussion openers, technical questions
13:17:02 <bring> haskell-cafe@haskell.org
13:17:02 <bring>     New-to-Haskell, i.e. elementary, Haskell questions; extended discussions
13:17:05 <Lor> well, if I can afford accommodation.
13:17:18 <Marvin--> shapr: he was, several years ago
13:17:18 <shapr> veckobostader is really cheap
13:17:21 <shapr> oh, ok
13:17:30 <bring> looks like it's haskell
13:17:31 <shapr> bring: that implies sending to haskell@haskell.org
13:17:37 <shapr> ok, the coin was wrong
13:17:59 <Spark> whats veckobostader?
13:18:13 <shapr> literally "weekly living spot"
13:18:15 <bring> Spark: see link in wiki
13:18:23 <shapr> sort of like a hostel
13:18:43 <bring> it's the main student housing foundation in gothenburg that rents some of there rooms on a nightly or weekly basis
13:18:46 <Spark> mm i havent bothered looking at the wiki page yet, one sec :)
13:18:47 <shapr> inexpensive, simple, clean
13:19:11 <bring> maybe it's time for a room sharing section in the wiki
13:19:31 <shapr> scary thought
13:19:40 <shapr> bring: you've started a big hackfest! :-)
13:19:52 <Lor> Hm, yeah, a quarter of a four-bed room would be affordable.
13:20:50 <Marvin--> heh, cute, they offer teddy bears for a small fee
13:20:54 <shapr> thing is, I know EuroPython has reserved a bunch of VBS rooms, I dunno what's left over.
13:21:01 <Spark> just get a one bed room and everyone crash on the floor after a few beers :)
13:22:07 * bring doesn't believe he started it
13:22:20 <shapr> well, my fiancee and I already have rooms purchased in the EuroPython reserved section
13:22:29 <bring> Feb 19 20:46:05 <shapr> Since I was drafted into working on the europython conference, I've been thinking about irregular EuroHaskell meetings.
13:22:36 <shapr> whoa
13:22:45 <bring> man, two months ago
13:22:53 <SyntaxNinja> so does EuroHaskell's Hack-a-thon have a software goal?
13:23:04 * SyntaxNinja has too many books to read!!
13:23:21 <shapr> well, we have some sprint suggestions on the wiki page
13:23:30 <shapr> SyntaxNinja: come to Sweden! again! :-)
13:24:01 <SyntaxNinja> shapr: it's not in the cards right now :) thanks, though.
13:24:07 <shapr> fair enough
13:24:22 <SyntaxNinja> I think someone should hack on Haddock-comments for the entire library
13:24:28 <Spark> if philippa is actually coming we can catch the plane together
13:24:30 <Marvin--> aww, do come, I'll bring my go board :-P
13:24:38 <SyntaxNinja> Marvin--: very tempting :)
13:24:45 * SyntaxNinja is going to England next week
13:24:48 <shapr> Spark: she said she'd come only if the uni was paying for her.
13:24:55 <Spark> heh
13:24:56 <SyntaxNinja> I'm going to hack with SimonMar on LIP
13:25:01 * earthy looks at EuroHaskell and goes `hmmmm'
13:25:05 <shapr> SyntaxNinja: nifty!
13:25:16 <shapr> invite him to EuroHaskell! ;-)
13:25:23 <SyntaxNinja> so I don't think I'll get enough vacation to go abroad again any time soon
13:25:28 <shapr> man, hacking with SimonMar must be spiffy.
13:25:45 <shapr> earthy: you coming to EuroHaskell?
13:26:05 <earthy> might, sounds cool.
13:26:07 <Spark> ski: have you fallen asleep reading that ps file? :)
13:26:12 <earthy> but very much `might'
13:26:28 <shapr> kosmikus sounded interested
13:26:40 <earthy> `if he meets his half may deadline'. :)
13:27:07 <SyntaxNinja> maybe I can have a hack-a-thon of my own while you guys are hacking at eurohaskell
13:27:14 <shapr> oh good idea!
13:27:56 <andersca> you can have ushaskell
13:28:39 <SyntaxNinja> hehe
13:28:50 <Marvin--> ninjahaskell
13:29:11 <shapr> heh, NinjaHaskell 
13:29:13 <SyntaxNinja> maybe I could organize an Aetion free-hacking day or something, where we work on free stuff together and hang out on IRC with euroHaskell instead of doing what we normally do
13:29:34 <earthy> oooh, spiffy
13:32:56 <stepcut> shapr: you around?
13:33:00 <shapr> yes!
13:33:20 <stepcut> have you done much work with e-commerce systems?
13:33:21 <shapr> oh, I'm sposed to send this mail, not just stare at it.
13:33:27 <stepcut> haha
13:33:39 <shapr> er, a little bit
13:33:42 <shapr> if you mean webshops
13:34:18 <stepcut> yeah...
13:34:50 <shapr> most people have the catalog and stuff on their own site, and hand off to various webcash providers for the actual transaction
13:35:00 <stepcut> right
13:35:12 <shapr> from what I've seen, you get to hand a CSS sheet to most providers so it still looks like your site
13:35:25 <shapr> but then their site calls back into yours with the result of the transaction
13:35:58 <shapr> that's how EuroPython works with worldpay for example
13:36:23 <shapr> bring: ok, sending to haskell@haskell.org...
13:36:33 <stepcut> have you run across any good 'shopping cart' systems for managing the catalog portion?
13:36:54 <shapr> I recently tried out PloneShop (?) it looks nice
13:36:55 <bring> ok
13:36:59 <shapr> but that's the only one I've tried myself.
13:37:33 * SyntaxNinja goes home
13:37:37 <SyntaxNinja> 'night all
13:37:58 <stepcut> ok. I am pondering making that my next haskelldb project :) But first I want to make sure there isn't something really great that I am missing out on
13:38:26 <shapr> I'm very interested in doing webdev with HaskellDB
13:38:44 <shapr> PloneShop seems nice if you do Plone already
13:38:52 <shapr> g'night SyntaxNinja!
13:39:14 <stepcut> shapr: I hardly do anything webdev related so far, except for haskell
13:39:30 <shapr> it's been my life for years...
13:39:50 <shapr> though I've always wanted to break into development tools like refactoring browsers
13:39:54 <stepcut> yeah, that's why I thought I would talk to you :)
13:40:10 <shapr> sadly, dev tools aren't much good as a service
13:40:41 <stepcut> i can believe that
13:42:52 <stepcut> so do you do mostly custom work on contract ?
13:43:09 <shapr> that's all I do
13:43:19 <shapr> that way I can do everything open source
13:44:22 <stepcut> interesting...
13:45:53 <shapr> that means that I do win32 work about once a year
13:46:00 <stepcut> :p
13:46:28 <shapr> everything else is Linux, Python, Java, SQL, websites, whatever
13:46:55 <stepcut> I am thinking about doing a little business setting up small business with their first website
13:47:27 <stepcut> taking care of registering the domain, making a simple homepage, etc. 
13:47:34 <shapr> sounds cool
13:48:11 <stepcut> I would operate as a 'value added' reseller for pair.com, so they package would include a year's worth of hosting
13:48:47 <stepcut> so I am trying to come up with a bunch of extra's that you could add to a site for a small fee.
13:49:26 <stepcut> For example, if you are a coffee shop, you might want an events calendar. 
13:49:46 <shapr> there are very few decent events calendars
13:50:00 <stepcut> So it might cost $50/year for an events calendar, but I just flip a switch
13:50:35 <shapr> if you can sync your cal with outlook, it'll sell nicely
13:50:49 <stepcut> hrm, interesting idea
13:51:01 <shapr> look at lwn.net
13:51:06 <shapr> see what he says about his scheduler
13:51:33 <stepcut> ok
13:53:53 <shapr> standard features our clients want (off the top of my head): user auth, site membership, mailing lists, web fora
13:54:40 <shapr> check out www.alis-online.org for the site we're putting the most time into at the moment
13:56:47 <Spark> lol Teddybear 35:-
13:58:35 <bring> maybe we could sell stuffed lambdas
13:58:40 * shapr laughs
13:59:06 <shapr> or we could buy a bunch of Riastradh's HM t-shirts 
13:59:51 <ski> which ?
14:00:17 <shapr> the ones mentioned at the top of the quotes page
14:01:00 <stepcut> shapr: yeah, most of our potential clients right now have no clue what they want. They are like 'I want a website, but I don't know anything.'
14:02:30 <stepcut> so, that's why we want to make it easy for them -- take care of the hosting, registration, site design, etc. But on the otherhand, they don't want to pay a lot, so we need to automate it as much as possible.
14:03:18 <ski> shapr : ok
14:06:12 <shapr> stepcut: so far, my experience leads me to think that object publishing like CMF/Plone Archetypes and Twisted's woven/nevow is the way to go.
14:07:06 <shapr> to port that to haskell means some way to give algebraic datatypes a standard html/xml rendering
14:07:16 <shapr> might be too much overhead to start with though
14:08:01 <shapr> but I think that's the right direction to go for a useful Haskell web publishing framework
14:08:49 * shapr isn't sure, will think more about that
14:11:24 <stepcut> shapr: well, I will be involved in the haskell webdev space until atleast the end of the year, so we should compare notes every so often
14:56:07 <camio> Gee, someone please tell me there is some language better then SQL for a database query language.
14:56:19 <Lor> Well, oql. :)
14:56:30 <bring> haskelldb
14:56:35 <Lor> Not _much_ better, I fear...
14:56:44 <kosmikus> oql isn't really bad, is it?
14:57:15 <Lor> It's funny how all databases are relational and programming languages are object-oriented, whereas I think OO is most suitable for modelling _persistent_ data, ie. databases.
14:57:24 <camio> Man, I'm happy to hear alternatives.  I looked through a tutorial and it made me so upset that this is the standard for new applications.
14:57:38 <Lor> No, oql is not horribly ugly.
14:58:17 * Lor has written an oql parser, so ought to know.
14:59:28 <ski> how about deductive databases ?
14:59:34 <ski> like aditi, e.g.
14:59:53 <Lor> What are they? Some sort of a persistent prolog?
15:00:12 <ski> yeah, prolog-like syntax
15:00:26 <ski> http://www.cs.mu.oz.au/research/aditi/
15:01:19 <ski> looks like quite a nice way to express queries, IMUO
15:01:50 <camio> interesting
15:02:44 <ski> they also provide support for recursive extensional predicates/relations (i.e. 'views')
15:03:37 <ski> bottom-up set-at-a-time execution per default, though (so that's different from ordinary prolog)
15:06:56 <camio> HaskellDB seems procedural instead of declarative.
15:08:11 <bring> why?
15:09:24 <ski> maybe because plain monads are totally sequenced ??
15:09:28 <camio> I'm probably wrong.  Just looking at how they suggest solving querys in their example.
15:09:45 <camio> ski: Yeah
15:10:20 <ski> camio : who 'they' ? the aditi people ?
15:10:34 <camio> no, haskellDB people
15:10:37 <ski> oh
15:11:09 <camio> Perhaps these Monads are not normal monads and could potentially allow optimization of queries somehow.
15:11:48 <bring> they are monads, but allow query optimization
15:12:04 <camio> okay
15:12:40 <bring> when a Query is run it produces abstract relational algebra syntax
15:13:03 <bring> which is then optimized and and rendered as SQL
15:13:41 <bring> which haskelldb page are you looking at btw?
15:13:47 <camio> Oh, cool.  So HaskellDB syntax compiles to SQL?
15:13:53 <camio> http://www.haskell.org/haskellDB/example.html
15:14:25 <bring> You might want to have a look at http://haskelldb.sourceforge.net/
15:14:25 <camio> If that's the case, then I'll just assume the SQL server is doing the required optimization.
15:15:04 <bring> well, both acutally happen, the generated queries are awful, so they are optimized a bit before being converted to SQL and sent of to the server
15:15:17 <camio> cool
15:16:05 <bring> http://haskelldb.sourceforge.net/ is a newer version that we are working on, it works with current versions of ghc and hugs, and with multiple backends
15:16:36 <camio> it looks like the haskell.org page is very outdated.  Did you add the "table expressions inside experessions" feature?
15:22:52 <Lunar^> bring: Does it has any support for prepared statement btw ?
15:24:06 <bring> camio: yes, that page is for the original haskelldd written by Daan Leijen
15:24:14 <bring> eh, haskelldb
15:24:33 <bring> we haven't added table expressions
15:26:09 <bring> Lunar^: no, but I have been think about how to do that
15:26:13 <kosmikus> bring: ah, you're the one who's rewriting haskelldb?
15:26:48 <Lunar^> bring: What are your ideas ?
15:26:57 <keverets> what's the "fix" in "putStr $ fix("HELLO\n"++)" ?
15:27:15 <Lunar^> keverets: 1sec I get a link
15:27:21 <bring> not just me; chucky, viblo, forester, mardiee, mary, torma too
15:27:31 <kosmikus> fix f = f (fix f)
15:27:33 <ski> keverets : a fixpoint generator, probably
15:27:49 <kosmikus> bring: didn't know that yet. great work. are the others on #haskell?
15:28:33 <bring> chucky, viblo and forester normally hang out here
15:28:35 <kosmikus> or are you all on #haskell.se, with "se" as in "SEcret society"?
15:28:47 <camio> hehe
15:28:50 <bring> there's even a #haskelldb
15:29:06 <kosmikus> good to know
15:29:40 <Lunar^> keverets: http://lambda.weblogs.com/discuss/msgReader$5463#5466
15:30:02 <Lunar^> keverets: more exactly http://www.scms.rgu.ac.uk/staff/bjm/doc/fics2001.pdf
15:30:48 <Lunar^> bring: Sure, but I'm interested on how do you plan to implement prepared statemetns :)
15:32:31 <bring> Lunar^: I have been thinking of doing some form of partial compilation of expressions like \user -> do{ u <- table users; restrict (u!name .==. constant user)); return u}
15:32:35 <ski> Lunar^ : what's prepared statements ?
15:32:55 <bring> to SQL, something like "SELECT * FROM users WHERE name = ?"
15:33:42 <Lor> ski, precompiled templates.
15:33:45 <Lunar^> ski: The idea is to not reparse the query, reload the index each time an argument changes
15:33:51 <ski> mhm
15:33:55 <Lor> Very kludgy.
15:34:06 <bring> eh, haven't really thought though when the statement is prepared and how to execute it again
15:34:14 <Lor> Properly they should of course be functions.
15:34:53 <Lunar^> bring: That would typically need a mutable map of query <-> statement
15:35:12 <ski> bring : mayybe some kind of arrows could help .. ?
15:37:09 <bring> or something nasty using TH: do { q <- $(prepare (long nasty query)); result <- run (q arg1 arg2); result' <- run q (arg3 arg4) }
15:37:31 <Lunar^> bring: yeah sure
15:37:32 <bring> modolo getting the parantheses right
15:37:48 <Lunar^> TH is damnly cool
15:40:38 <camio> Lunar^: agreed
15:40:56 <bring> with TH you could even do the SQL generation at compile time
15:41:18 <camio> That's an awesome idea.
15:41:20 <bring> I tried that for queries without paramters ad it works of course
15:41:54 <bring> will work on a decent way of allowing parameters next
15:42:49 <bring> if that can be done, I think supporting prepared statments is just a matter of calling the right db client api function
15:45:54 <camio> on the runtime side of things, it would be nice to use haskell-in-haskell to create the specific database's modules automatically.
15:46:27 <bring> so that you don't have to recompile if the db layout changes?
15:46:38 <camio> ueaj
15:46:39 <camio> yeah
15:47:06 <bring> we have a bit of that, not that cool though
15:47:30 <camio> Is the syntax rough?
15:47:52 <bring> you can generate the haskell module from a haskell description of the layout, but that only gets you a file with haskell code
15:48:02 <bring> you still need to compile against that code to use it
15:48:54 <bring> and you can create the database from the same description
15:49:16 <bring> so you can pack a freeze-dried db with your program
15:49:31 <camio> I see.
15:49:44 <bring> the db description looks like the one at the bottom of: http://www.scannedinavian.org/AvianWiki/HaskellDbTutorial
15:50:02 <bring> there's no example of generation a haskell module there though
15:50:16 <bring> s/generation/generating/
15:50:19 <SamB> freeze-dried dbs must taste awfull
15:51:08 <bring> :)
15:51:11 <camio> Lets say I have a client application to a db and someone added a new field to a table I'm interested in.  Would my haskelldb Module for that table need to be regenerated?
15:51:35 <bring> if you want to use that field, yes
15:51:56 <bring> that's neccessary because of the static checking
15:52:03 <camio> lets say I didn't care about writing to that field.  What happens if I just print out the rows?
15:52:16 <bring> you should be ok
15:52:26 <camio> would it print out that field or omit it?
15:52:40 <bring> omit it
15:52:50 <camio> okay
15:52:52 <bring> I've never tried that, but that's how it should work
15:53:15 <bring> since it gets each field by name
15:53:50 <camio> So there isn't any "unnamed" field support?
15:54:43 <bring> you mean like getting all the fields from a table, whatever they are?
15:54:58 <camio> yeah
15:55:14 <bring> well, to the user, there is
15:55:28 <bring> but behind the scenes, it gets all the fields it knows about
15:56:12 <camio> I wonder if a client application would want to regenerate the table module before every run.
15:56:20 <bring> there is no true "get all the fields, whatever they are", since there is no sensible record type to give the result
15:56:39 <bring> that would mean recompiling the program
15:56:46 <bring> which might take a while
15:56:49 <camio> Yeah
15:57:07 <bring> I'd think most applications use rather static db layouts
15:57:38 <bring> and if the layout changes, you normally need to change your code to work with the new layout anyway
15:57:51 <camio> Yeah, probably.  But I can also see when someone is writing a client application for a database that they don't have control over.
15:58:28 <bring> but changing a field that your application cares about will brak your application most likely
15:58:36 <bring> s/brak/break/
15:58:49 <camio> I imagine an application that connects to a database server and prints all fields related to their "name".
15:59:39 <bring> yeah, db browsers and other meta-db-applications are probably hard to write in haskelldb
15:59:52 <camio> Probably not to relevant, but something that SQL based applications can do that HaskellDB couldn't without a bit of recompiling.
16:00:09 <bring> maybe using TH and haskelldb would work for something like that
16:00:13 <bring> true
16:00:57 <camio> Well, I guess that support could be potentially put in haskelldb though, right?
16:01:33 <bring> as always, safety implies loss of freedom
16:02:09 <bring> it would be hard to do it in a type safe way, without recompiling for every run
16:02:23 <bring> even then, what if you want to write a db editor
16:02:37 <bring> it's have to recompile itself after every change
16:02:45 <bring> s/it's/it'd/
16:02:51 <camio> I remember there being some ghc extention for typeless types.  I wonder if that could do it.
16:03:13 <bring> you mean like Data.Dynamic?
16:03:25 <camio> exactly.
16:04:08 <bring> you could run you code in ghci or hugs, then recreate the db module and reload it after chaning the db
16:04:55 <camio> Yeah, that's true.  Do you think using dynamic would allow for one to get around that recompiling stage?
16:05:11 <camio> So when one prints the entire row in a table, it won't omit the members it doesn't know about potentially.
16:05:21 <bring> if you just want the haskelldb syntax without the type system, that would not be too difficult to implement, but I think the type system is one of the major advantages of haskelldb
16:06:09 <camio> I agree, it makes haskellDB (and HXML alike) very cool.
16:06:40 <bring> another way to do that if you just want to print all fields would be to have a function allFields :: Database -> TableName -> IO [[String]]
16:06:56 <camio> Maybe having both strong types and weak ones.
16:07:31 <camio> That's true, but you could get more type information than that from a DB, right?
16:07:41 <bring> there is an untyped layer of haskelldb that sits beneath the phantom typed layer that the user sees
16:08:10 <np_hard> here is a badass thing I saw that my coworker did : he wrote a script to memoize shell command output!
16:08:19 <np_hard> e.g. % c ./a_script_that_takes_a_long_time -foo -bar -baz , run once, will run the script
16:08:20 <bring> we have functions: describe :: Database -> TableName -> IO [(Attribute, FieldDesc)]
16:08:23 <np_hard> run again will display cached output
16:08:26 <bring> tables :: Database -> IO [TableName]
16:09:09 <camio> Ahh, so the only difference is that the fields' types would be found from the DB instead of found by the table module.
16:09:25 <bring> np_hard: what happens if you run date or something like that in it?
16:10:14 <bring> maybe we have been talking about different things, getting the names and types of the fields in a table or a list of all the tables does not need recompilation if the layout changes
16:10:30 <bring> but getting the contents of all the fields in a table would need recompilation
16:11:19 <camio> What is the difference between content and "names and types"?
16:11:30 <camio> Oh, NM
16:12:18 <camio> I mean for one pass, you get the values of the "names" that the table module knows about and you get the "names, types, and value" from those that you don't.
16:12:35 <camio> Encapsulated in Dynamic of course.
16:12:51 <camio> That's the feature I'm thinking about.
16:16:10 <np_hard> bring: it will display the cached date
16:16:13 <bring> you know, that would actually be possible to do now, if you abuse the api a bit
16:16:31 <np_hard> bring: you can set lifetime as a command line option
16:16:34 <bring> that was for camio btw
16:16:35 <camio> That way one could get the best of both worlds, static typing and flexibility.  That's assuming that flexibility is useful.
16:16:55 <camio> bring: Interesting
16:17:14 <bring> np_hard: beats redirecting stuff to a file just because you don't want to rerun the command
16:19:03 <bring> using describe, creating a custom PrimQuery (relation algebra abstract syntax) and passing it to Databade.dbQuery should do the trick
16:19:34 <bring> it would be a little messy, but it could all be wrapped up in a nice function
16:19:51 <bring> s/Databade/Database/
16:20:07 <camio> cool
16:20:10 <np_hard> bring: yep, that's why he did it. I think it would be useful as a shell builtin or something
16:20:19 <np_hard> am wondering if it has already been done somehow
16:21:33 <camio> gtg, bye all
16:22:06 <bring> good night #haskell
16:22:35 <kosmikus> good night
16:23:41 <stepcut> night
16:43:41 <jadrian> hello
16:44:05 <ski> hello jadrian
16:44:08 <jadrian> hi ski
16:44:20 <jadrian> anyone experienced with happy here?
16:44:49 <ski> me, not much
16:44:59 <kosmikus> a very little bit ... I've used frown :-(
16:45:30 <jadrian> it's probably not happy specific... I've just studied compilers a long time ago...to long :)
16:45:51 <jadrian> just making a simple parser for first order logic formulas
16:46:00 <jadrian> I want:
16:46:27 <jadrian> \Ex x . P  &  \Ex y Q
16:46:31 <jadrian> to parse as
16:46:36 <jadrian> \Ex x . (P  &  \Ex y Q)
16:46:52 <jadrian> that is, I want the quantifiers to have the biggest scope possible
16:47:07 <kosmikus> you mean "\Ex y. Q", probably ...
16:47:18 <jadrian> I thought assigning a low priority to token "." would be enough
16:47:38 <jadrian> kosmikus: exactly :)
16:48:39 <kosmikus> so what do you get?
16:48:46 <jadrian> but apparently assigning connectives an higher priority than "." doesn't work
16:48:49 <jadrian> well I get
16:49:01 <jadrian> (\Ex x . P)  &  (\Ex y . Q)
16:49:02 <Pseudonym> Personally, I'd avoid using operator precedence if you can help it.
16:49:12 <jadrian> Pseudonym: why?
16:49:25 <kosmikus> yes, best thing is to write the grammar in an unambiguous way
16:49:36 <jadrian> define best :)
16:49:38 <Pseudonym> Because mixing context-free and operator-precedence grammars is, in my experience, harder to understand than just using CFGs.
16:49:53 <Pseudonym> And I've written a lot of compilers.
16:49:58 <kosmikus> although you might still get a shift-reduce conflict for such widest-scope behaviour, but shift is default and what you want
16:50:03 <Pseudonym> And parser generators, for that matter.
16:51:27 <jadrian> OK guess I'll follow your advice
16:51:45 <Pseudonym> It takes a little more typing, but that's what cut and paste is for.
16:51:51 <jadrian> :)
16:52:03 <jadrian> I just can't think about it as more simple...
16:52:18 <jadrian> the example in happy docs for instance
16:52:26 <Pseudonym> It's simpler to use just CFGs than a mix of CFGs and OPGs.
16:52:31 <Pseudonym> But maybe that's just me.
16:52:31 <jadrian> simple arithmetic expressions with + - * /
16:52:38 <kosmikus> Pseudonym: I agree
16:53:03 <jadrian> damn everybody agrees :)
16:53:16 <jadrian> Ok like I said I guess I'll follow your advice
16:53:31 <kosmikus> jadrian: there the operators are all really of the same category; in your example, "." has a different status than "&", and I think that's why it's getting confusing ...
16:53:36 <Pseudonym> In fact, I think adding operator precedences, except as a mechanism for resolving conflicts, is a misfeature.
16:53:39 <jadrian> still any idea why priority is not enough to parse the way I intended?
16:53:59 <Pseudonym> jadrian: I think it's because "." is actually a _prefix_ operator, like unary minus.
16:54:19 <Pseudonym> Well, "\Ex x ." is a prefix, anyway.
16:54:21 <kosmikus> yes, I'd think so, but I'd have to see your grammar to be sure what's going on
16:54:44 <kosmikus> but I'm probably too tired to make sense of it anyway :)
16:54:46 <Pseudonym> And yacc/happy's operator language isn't expressive enough to express prefix operators natively.
16:54:54 <jadrian> Pseudonym: you can get prefix operators to have low priorities...
16:55:01 <jadrian> Pseudonym: can't you
16:55:09 <kosmikus> if Pseudonym and me are talking at the same time, that's a sure sign for me that I should be in bed ...
16:55:23 <Pseudonym> kosmikus: Daylight savings are off here.
16:55:28 <kosmikus> :)
16:55:31 <jadrian> kosmikus: lol
16:55:31 <Pseudonym> I don't know if that makes it better or worse.
16:55:40 <Pseudonym> But yes, you should go to bed.
16:56:00 <Pseudonym> kosmikus: In yacc, you can do it by using rule precedences.
16:56:22 <Pseudonym> Which are a little-known and poorly-understood feature.
16:56:29 <Pseudonym> Not sure if happy uses it, though.
16:56:36 <kosmikus> I never used yacc.
16:56:45 <Pseudonym> OK.
16:56:50 <Pseudonym> In yacc, you can say this:
16:57:09 <Pseudonym> %nonassoc LOWER_THAN_ELSE  /* This is a pseudo-token */
16:57:13 <Pseudonym> %nonassoc ELSE
16:57:15 <Pseudonym> %%
16:57:27 <Pseudonym> stmt: IF expr stmt2 %prec LOWER_THAN_ELSE
16:57:36 <Pseudonym>     | IF expr stmt2 ELSE stmt ;
16:57:55 <Pseudonym> That resolves the dangling-else confict by applying a precedence to the rule rather than just the operator.
16:58:14 <jadrian> yeap you can do that in Happy
16:58:21 <Pseudonym> OK.
16:58:25 <jadrian> | '-' Exp %prec NEG       { Negate $2 }
16:58:36 <Pseudonym> There you go.
16:58:42 <jadrian> NEG is the pseudo-token
16:58:48 <emu> ack, precedence
16:58:51 * emu runs
16:59:01 <Pseudonym> You could probably disambiguate your grammar using that on the rule for your quantifier.
16:59:09 <Pseudonym> But I wouldn't recommend it.
16:59:16 <Pseudonym> Like I said, nobody really understands it.
16:59:30 <jadrian> I thought I did but I probably don't then :)
16:59:31 <kosmikus> I see. Yes, then there should be a possibility to do the logical formulas, too.
17:00:03 <jadrian> I thought you only needed the pseudo-token there because it depends on the context 
17:00:55 <kosmikus> I don't know if it is just me, but I always find LR parsing hard to understand anyway ...
17:01:12 <kosmikus> I rather go eliminating left recursion than tracking reduce-reduce conflicts.
17:02:08 <jadrian> on more example
17:02:15 <jadrian> in happy docs there is :
17:02:19 <jadrian> Exp   : let var '=' Exp in Exp  { Let $2 $4 $6 }
17:02:37 <jadrian> and a precedence is defined for "in"
17:02:48 <jadrian> this is pretty close to what I was trying to do
17:04:06 <ski> seem so, yes
17:04:24 <Pseudonym> Except I don't think it is.
17:04:31 <Pseudonym> . does not take a formula on its left-hand side
17:04:36 <Pseudonym> Whereas "in" does.
17:05:53 <jadrian> hmm ok so you're saying it works like "an infix operator" applyed to exps
17:06:03 <Pseudonym> Right.
17:06:12 <jadrian> and mine is something like  "a prefix operator" applyed to formulas
17:06:20 <Pseudonym> Yes.
17:06:33 <Pseudonym> I believe that's it, but I'd have to play to be sure.
17:07:03 <ski> or like an infix operator, with a variable on lhs and expression on rhs
17:07:11 <jadrian> I just don't see why should that be a problem. The If than else example is more complicated than mine...
17:08:45 <jadrian> All I'm trying to do then is something like trying to parse:
17:08:56 <jadrian> ! 1 * 3
17:08:57 <jadrian> as
17:09:05 <jadrian> ! (1 * 3)
17:09:20 <Pseudonym> Do you have a copy of Kernighan and Ritchie handy?
17:09:35 <jadrian> I wouldn't exepct not to be able to solve that by definig a lower precedence for !
17:09:44 <jadrian> Pseudonym: just borrowed it a few days ago :(
17:09:49 <jadrian> opss
17:09:50 <jadrian> lend it
17:09:55 <Pseudonym> Ah.  OK, hang on.
17:10:16 <Pseudonym> ftp://ftp.iecc.com/pub/file
17:10:20 <Pseudonym> Grab c-grammar.gz
17:10:40 <jadrian> k
17:10:42 <Pseudonym> I think that grammar will be a bit more enlightening.
17:13:46 <jadrian> nice :)
17:20:35 <jadrian> wait :)
17:20:40 <jadrian> Pseudonym: it's working now
17:20:45 <Pseudonym> Cool.
17:20:56 <Pseudonym> How did you do it?
17:20:59 <jadrian> Pseudonym: and my implementation works :)
17:21:11 <Pseudonym> Trez cool.
17:21:17 * jadrian is sleepy :-/
17:21:29 <Pseudonym> Go sleep, then.  Night.
17:21:39 <jadrian> problem was that suddenly I was thinking that the higher meant higher priority
17:21:51 <jadrian> so I was putting "." below all the others...
17:22:32 <jadrian> now I looked at it and saw something was wrong... because ~ was not on top...
17:22:36 <jadrian> :)
17:23:05 <jadrian> yes sleep bye!
17:23:15 <kosmikus> Pseudonym seems to want to get rid of us ...
17:23:29 <Pseudonym> Yes.
17:23:32 <Pseudonym> Mwwhahahaha!
17:23:50 <Pseudonym> I want you all to SLEEP so I you can be NOT SO TIRED when I do my EVIL work.
17:24:00 <Pseudonym> That sounds like a Zippy quote.
17:24:02 <Pseudonym> @yow
17:24:02 <lambdabot> ONE:  I will donate my entire ``BABY HUEY'' comic book collection
17:24:02 <lambdabot>  to the downtown PLASMA CENTER..
17:24:02 <lambdabot>  TWO:  I won't START a BAND called ``KHADAFY & THE HIT SQUAD''..
17:24:02 <lambdabot>  THREE:  I won't ever TUMBLE DRY my FOX TERRIER again!!
17:24:44 <kosmikus> motivates me to stay awake for yet a few more minutes
17:29:50 <Pseudonym> I can wait.
17:32:42 <kosmikus> what kind of evil work could you do in my absence that I haven't already done?
17:34:43 <Pseudonym> Now why would I tell you?
17:38:23 <kosmikus> so that I can go to sleep without a bad conscience because I know someone will do what needs to be done during my absence?
20:50:56 <heatsink> What is the type of a do {...} block?
20:53:32 <ski> it's 'm a' for some type a and for some Monad m
20:53:43 <heatsink> yeah
20:53:48 <ski> e.g. 'IO String'
20:53:53 <heatsink> It has the same type as the last expression in the block?
20:54:06 <ski> yeah
20:54:10 <heatsink> okay
20:55:03 <heatsink> I find monad operations hard to write because I can't see how the hidden state gets passed around
20:55:07 <SamB> heatsink: it is determined on a case-by-case basis
20:56:19 <ski> in an ordinary state monad, it's just passed lineary/sequentially on, in and out of each call
20:57:11 <heatsink> ski: But sometimes a single operation in the do block is called multiple times, or not at all
20:57:50 <ski> are you thinking about the list monad (or parsing monads) ?
20:57:56 <heatsink> ski: parsing monad
20:57:57 <SamB> than code them with >> and >>=
20:58:16 <heatsink> ski: I'm looking at http://www.cs.nott.ac.uk/~gmh/pearl.pdf
20:59:00 <heatsink> The parser type is defined as
20:59:24 <heatsink> newtype Parser a = Parser (String -> [(a, String)])
20:59:30 <ski> right
20:59:31 <heatsink> i.e. it contains a one-argument function
20:59:32 <SamB> in truth, I don't believe the state IS passed around. its hard to explian. its like you are building a list of actions, almost, but because Haskell is lazy, they begin before the computations are complete.
20:59:42 <heatsink> right, I think I understand that
21:00:31 <SamB> well, for IO, anyway
21:00:45 <ski> heatsink : so a Parser a, eats a State (String), and nondeterministically returns a pair of 'a' and a new State
21:00:47 <heatsink> but the state is passed around once the actions get evaluated
21:00:53 <heatsink> ski: right
21:01:13 <ski> (nondeterministically can be thought of as splitting the universe in multiple parallel ones :)
21:01:27 <heatsink> ski: I figured that out eventually
21:01:54 <heatsink> ski: Each of the result pairs is used as inputs to the next parsers, i.e. it tries all possibilities
21:02:03 <ski> right
21:02:13 <heatsink> What I don't understand is how a later definition of a particular parser is of that type
21:02:29 <heatsink> The definition is
21:02:40 <heatsink> p = do {c <- item; item; d <- item; return (c,d)}
21:02:46 <heatsink> I can see what goes on inside that parser
21:03:12 <heatsink> item is a parser that reads any single character from the string, and returns that as a token
21:03:28 <heatsink> This parser reads three characters, and returns the first and last as a pair
21:03:57 <ski> p = item >>= \c -> item >> item >>= \d -> return (c,d)
21:03:58 <heatsink> What I don't understand is how this do statement is of type Parser (String->[((Char, Char), String)])
21:04:14 <heatsink> ski: even when I write it out that way, it doesn't look like that type
21:04:53 * ski thinks the type should be "Parser (Char,Char)"
21:05:00 <heatsink> um, yeah
21:05:54 <heatsink> But it should be a parser type containing a function from String to [((Char, Char), String)]
21:06:02 <ski> right
21:06:02 <heatsink> which is Parser (Char, Char)
21:06:38 * ski mods
21:06:44 <ski> s/m/n/
21:08:21 <ski> (hmm, wasn't there some theorem by mayhaps Kleene named the s-m-n theorem or something like that ? :)
21:08:51 <heatsink> dunno
21:09:18 <heatsink> oh yes, there is
21:13:14 <heatsink> It seems to be saying that you can take any recursive function of more than one variable, and transform it into a recursive function with a smaller number of variables
21:13:58 <ski> mhmm
21:15:37 <Etaoin> does "recursive function" mean recursive function in the programming sense?
21:16:43 <ski> prolly not
21:17:17 <ski> prolly more like the primitive recursive functions (or mayhaps larger set)
21:19:27 <ski> hello kennith
21:19:35 <kennith> hi
21:19:47 <ski> learning haskell ?
21:20:03 <kennith> yup.
21:20:17 <ski> ok
21:20:26 <kennith> using the book, "haskell: the craft of functional programming"
21:20:26 <heatsink> I recommend not tackling parsers as your first project :)
21:20:28 <ski> got any questions/problems yet ? :)
21:20:34 <ski> ok
21:20:36 <kennith> a lot of questions.
21:20:44 * ski learned from that book too :)
21:21:40 <ski> kennith : feel free to ask them anytime here and we'll try to answer
21:21:45 <kennith> thanks.
21:28:16 <heatsink> is the s an abbreviation for something in names [x:xs] etc.?
21:28:52 <ski> itym x:xs
21:29:03 <heatsink> what?
21:29:10 <ski> the 's' is english plural :)
21:29:15 <heatsink> oh
21:29:16 <heatsink> :)
21:29:38 <ski> and [x:xs] is a list with a single element, namely a list with head a and tail xs
21:29:47 <heatsink> right
22:01:16 <heatsink> Is a `foo` b the same as foo a b?
22:01:36 <ski> it is
22:01:40 <heatsink> ok
22:02:04 <ski> and a  (+) a b  is the same as a  a + b
22:03:40 <heatsink> so, does that mean a `(+)` b is the same as a + b ? :)
22:05:05 <Etaoin> for me, it gives a parse error in ghci
22:05:23 <Etaoin> same with hugs
22:05:57 <ski> heatsink : i would like it to, but it doesn't work :(
22:06:28 <heatsink> ah well, I'm sure I can find a workaround :)
22:06:36 <ski> also  a `f x` b  doesn't work ! :( :(  (this would be really useful, methinks)
22:07:33 <Etaoin> a `f.g` b  ??
22:07:49 <heatsink> what about a (x `f`) b?
22:08:11 <heatsink> wait, that wouldn't do it anyway
22:08:36 <ski> Etaoin : not that either
22:08:41 <heatsink> How about a (`f` x) b?
22:09:49 <Etaoin> wouldn't that be an application of a to two arguments?
22:10:05 <heatsink> yeah, it would be a $ f b x
22:10:38 <heatsink> wait... I don't think I've ever tried to use $ that way
22:10:45 <heatsink> it would be a (f b x)
22:32:25 <heatsink> Does haskell determine types top-down or bottom-up?
22:34:07 <heatsink> It looks to me like it's determing the type of a function, then determining the argument types required for the outer expression to yield the expected type, and so on for those expressions
22:34:25 <heatsink> If that's true, then it would help me understand the type errors haskell produces
22:34:31 <heatsink> ... ghc procues
22:34:42 <heatsink> s/cu/duc/
22:37:45 <heatsink> I've been looking at type-correctness starting with what evaluates first, which usually leads me to see that what type GHC infers is what I expect, and what type GHC expects looks like nonsense
22:39:11 <ski> the order of type checking/inferring prolly hasn't much to do with some run-time evaluation order
22:42:13 <heatsink> I think the "expected type" is determined backwards from the function's return type while the "inferred type" is determined going forwards from the argument types; that's consistent with what I've seen
22:42:37 <heatsink> At least, thinking of it this way, I can figure out what the error is
22:46:04 <ski> that might me (more or less) the way that ghc currently does it
22:46:53 <heatsink> good to know
22:47:39 * heatsink wishes I could have known it ... earlier ... *sigh*
22:53:07 <heatsink> Hey, I think my first parser program works
22:53:26 <heatsink> It just accepts a*b but hey, that's a start
22:58:11 <heatsink> And I can accept (ab)+ as well... cool!
22:58:30 <heatsink> Thanks, ski
23:13:48 <heatsink> Hmm, apparently Kiev is also a programming language
23:14:42 <earthy> it is?
23:15:05 <heatsink> it is an extension to Java
23:15:08 <earthy> oh dear. it is indeed.
23:15:18 * adept pricks his ears
23:15:47 * adept lives in Kiev and one of the authors of Kiev is his former uni pal
23:16:48 <earthy> *ah*. :)
23:17:25 <heatsink> anyway, I'm to bed.
23:17:45 <earthy> g'night heatsink
23:17:54 <earthy> and good morning #haskell!
23:18:05 <adept> morning
23:19:32 <Pseudonym> G'day.
23:27:32 <ski> lo skew
23:27:41 <ski> (s/lo/'lo/)
23:27:43 <skew> hello
23:27:50 <skew> hallo?
23:28:00 <ski> i got some feedback on fixIO ..
23:28:17 <Pseudonym> Does anyone else find it disturbing that "'lo" and "hi" are not antonyms?
23:28:17 <ski> 'hallo?' ?
23:28:55 <skew> I saw one message to the mailing list, but Simon didn't seem to think that repeating IO actions was disturbing
23:29:53 <skew> what did you hear?
23:29:55 <ski> skew : i've 10 more (including responses from me) in my mailbox
23:30:18 <earthy> `hallo' is Dutch for hello
23:30:42 <skew> german as well, I think
23:30:48 * earthy nods
23:31:14 <skew> ski: so, what are people saying?"
23:31:15 <ski> skew : Levent Erkk thought the prob might be solved if i added a hSetBuffering stdout NoBuffering
23:31:15 <earthy> my foreign languages haven't all come on line yet... still booting ;)
23:31:30 <skew> did that actually help?
23:31:56 <ski> skew : that didn't work for me, at least (solaris+ghc6.0.1 and freebsd+ghc6.0.1)
23:32:49 <skew> oops: IO.hs:19: Data constructor not in scope: `NoBuggering'
23:33:27 <skew> turning off buffering on stdout doesn't seem to help
23:33:27 <ski> skew : yeah, and SimonM thought it was because ghc uses lazy blackholing, but proposed an alternate fixIO
23:33:32 <ski> right
23:33:41 <ski> linex+ghc6.2.1 ?
23:33:46 <ski> s/linex/linux/
23:33:50 <Pseudonym> I'm glad that GHC supports the "no buggering" option.
23:33:51 <skew> yes
23:34:18 <ski> ok, that's about as far as we've got yet .. :/
23:34:24 <Pseudonym> I wasn't aware of that.  All my files are completely buggered.  Presumably that's why.
23:35:18 <skew> oh, I was going to try to wade through the core.
23:35:23 * earthy smiles
23:35:31 <earthy> `buggered I/O'... :)
23:36:18 * adept .oO (but I/O cant be buggered anymore ... Almost Pratchett)
23:36:41 <Pseudonym> Mind you, I find it easier to bugger everything up in other languages.
