02:04:26 <Joachim_> ls -la
02:06:22 <Joachim_> Well, this wasn't the shell, my too bad :-)
02:43:08 <vegai> -rwx-rw-r--  1 vegai kv 65 Jun 28 1980 vegai
02:44:44 <ibid> kv?
02:53:54 <vegai> last name ;P
02:56:18 <ibid> ahh
03:19:13 <det> can tuples in haskell have a recursive type?
03:19:49 <ibid> if the recursion is through a data, then yes afaik
03:20:28 <det> but you cant have a type (using sml syntax): type a = int * a
03:20:28 <det> ?
03:20:58 <ibid> don't know the meaning of "type" in sml
03:21:14 <ibid> but not type A = (Int, A), no
03:21:46 <det> Any idea for the rationale?
03:22:00 <ibid> yes
03:22:27 <ibid> data allows transparent addition of type folds or whatever
03:22:34 <ibid> it's the same in ML afaik
03:23:06 <det> type folds?
03:24:19 <ibid> a long story
03:24:30 <det> :)
03:25:19 <ibid> essentially, it is a way of giving the user the benefits of structural-equivalence recursive types while the compiler gets the benefits of name-equivalence recursive type
03:25:23 <ibid> or something like that
03:25:31 <ibid> read the type book :)
03:27:47 <det> so if you want a type in haskell like: "type A = (Int, A)" you have to wrap it in a dummy constructor like: "data A = T (Int, A)" ?
03:27:50 <det> you mean Tapl?
03:28:13 <ibid> yes
03:28:18 <ibid> to the latter :)
03:28:34 <det> and the former? :)
03:28:38 <ibid> data A = T Int A, i'd say, but yes
03:29:34 <det> I see
03:29:46 <det> how much can I find TaPL for?
03:29:56 <det> I hear many possitive things about it here
03:30:02 <ibid> ?
03:31:10 <det> I guess I can look
03:31:29 <ibid> bbl
04:53:03 <Si\> excellent; HXT has been updated to 4.00
05:11:26 <shapr> yow!
05:11:31 <shapr> goood morning #haskell!
05:11:44 <shapr> the snow is finally melting! I'm sooo happy!
05:12:17 * saz hasn't seen snow for yeaaaars
05:13:56 <liiwi> only dust here, no snow
05:14:07 <saz> dust?
05:18:37 * shapr hugs saz
05:18:44 <shapr> hi saz!
05:18:50 * shapr boings hyperactively
05:18:55 <shapr> YOW!
05:19:20 <shapr> I'M AMBISINISTROUS!
05:19:39 <saz> hey shapr!
05:19:56 <shapr> it's a beautiful day in the neighborhood!
05:23:00 <saz> spring!
05:23:48 <shapr> yes! spring!
05:24:20 <liiwi> snow gets all kinds of particles on it, and when snow goes away, only the dust stays
05:25:22 <edwinb> "It was nice yesterday. Spring, I enjoyed that. Missed it last year, I was in the bathroom."
05:25:49 <saz> edwinb: that's honestly more than I'd care to know
05:25:57 <saz> :-P
05:26:54 <shapr> edwinb: haha!
05:27:09 <edwinb> Michael Flanders has a lot to say on the British weather...
05:27:16 <shapr> edwinb: spring isn't *that* short here at the arctic circle
05:28:35 <edwinb> ;)
05:28:46 <edwinb> Actually, we have sunshine today. That usually means it's about to rain.
05:31:20 * shapr grins
05:31:33 <liiwi> wish it would rain here
05:31:44 <shapr> it's usually too cold to rain here
05:32:08 <shapr> mijdrol: hey, are you an EM Forster fan?
05:37:50 <earthy> me wishes it'd stop pouring every half hour just after the sun has come out
05:39:56 <shapr> well, at least you get nicely balanced weather
05:40:09 <shapr> here it's cold and dark for a long time
05:40:16 <shapr> then it's cold and bright
05:40:24 <shapr> then it's warm and bright for a short amount of time
05:40:38 <shapr> repeat until tired
05:41:18 <earthy> balanced? last thursday it was 10 degrees at nights and 20 during the day, now that's down to 3 and 9 respectively
05:42:08 <earthy> oh, and looking out right now would suggest to me to go out in jeans and a t-shirt, but in about 20 minutes it'll be pouring cold rain...
05:42:47 <earthy> it isn't boring, that's a plus. :)
06:08:19 <bring> shapr: what are the plans for another IOHCC?
06:24:16 <shapr> bring: suggest something
06:25:00 <shapr> the plan for the Succ 0th IOHCC is "when we get enough jurors"
06:25:30 <bring> maybe coordinate with EuroHaskell?
06:25:50 <shapr> you think two months is enough time from announce to submission?
06:26:00 <bring> hmm, maybe not
06:26:40 <shapr> I think we should draft SyntaxNinja for that, he's not doing enough for the Haskell community yet.
06:26:51 <bring> we could have small obfuscated haskell contest at EuroHaskell
06:26:51 <SyntaxNinja> sigh
06:26:54 * shapr is teasing SyntaxNinja :-)
06:27:20 <shapr> SyntaxNinja: you're only doing, what, three or four things for the Haskell community? ;-)
06:27:22 * SyntaxNinja tried to write code yesterday, but I think I'm slightly stimied on LIP... I'll have to sit down and make a to-do list.
06:27:23 <shapr> I'm sure I've forgotten some.
06:27:45 <shapr> we could have a LIP sprint at EuroHaskell, *that* would be a great contribution to the Haskell community
06:27:47 * bring got interested in obfuscated haskell when doing his semanctics lab
06:27:57 <bring> yes
06:27:58 <SyntaxNinja> shapr: when is EuroHaskell?
06:28:03 <shapr> that would assume that SyntaxNinja has time between now and then to put out some definite TODO items
06:28:20 <shapr> @wiki EuroHaskell
06:28:20 <betabot> http://www.haskell.org/hawiki/EuroHaskell
06:28:20 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
06:28:24 * bring is tired of messing with autoconf and make
06:28:24 <Jerub> shapr: I noticed a comment you made on the c2.com wiki ;)
06:28:41 <shapr> Jerub: which one? I've been there since near its beginning.
06:28:55 <SyntaxNinja> yeah, I can probably have some to-dos by then :)
06:29:00 <shapr> betabot: @leave #haskell
06:29:16 <SyntaxNinja> poor betabot
06:29:18 <Jerub> uhh, it was regarding haskell using capitialisation for syntax, I think it was on the SelfLanguage page.
06:29:30 <shapr> oh, that was sometime back
06:29:46 <shapr> If Sun had pushed Self instead of Java, this would be a very different world
06:30:02 * shapr shoots Sun repeatedly
06:30:17 * Jerub laughs
06:30:20 <Jerub> have you seen prothon?
06:30:33 <shapr> honestly, they probably did the right thing for them, since Java is (C++)++
06:30:57 <Jerub> I was going to make that cmoment, but left it.
06:31:18 <shapr> well, I like to bash Sun and dream about Self, but I try to hold on to reality also :-)
06:31:20 <Jerub> http://www.prothon.org/
06:31:33 <Jerub> its (python+self)/2
06:31:56 <shapr> python has metaclasses, so it's pretty easy to get that there
06:32:09 <shapr> oh Kragen Sitaker wrote a tiny Self.py that works just fine also
06:32:13 <shapr> doesn't use metaclasses though
06:32:14 <sysfault> shapr: what languages do you know?
06:32:39 <shapr> sysfault: several, Haskell, Python, SQL, Java, Visual Basic (no, I forgot it never mind)
06:32:53 <shapr> JavaScript, elisp, shell scripting sort of
06:33:04 <shapr> probably more that I've forgotten
06:33:11 <sysfault> aah k.
06:33:23 <shapr> oh, I've done some C and some assembly, but I wouldn't say I know them
06:33:36 <shapr> same for Joy, Erlang, Lisp, Scheme, Smalltalk and some others
06:33:39 <Jerub> I'd say I know php, python, java, javascript, bash, sql to an employable level.
06:33:42 <sysfault> cool.
06:34:19 <shapr> imho, it doesn't really matter what languages you know, there's a separate skill that I call "programming"
06:34:24 <shapr> and it's not language specific
06:34:44 <sysfault> I know bash, pretty well, that's the only simple language I can say I know to a great deal about.
06:34:45 <Jerub> shapr: that said, I couldn't sit down and cut code in C++ without 4 weeks learning.
06:34:50 <shapr> so, two people can learn Python and then Haskell in the same amount of time, and one might be an excellent programmer, and one might suck
06:34:51 <edwinb> It's always annoying to me to see job ads specifying "you must know C++/VB/Java" etc.
06:35:00 <sysfault> I can't want until it inherits non-associative arrays.
06:35:01 <edwinb> You can learn a language in no time if you know a couple of languages already.
06:35:11 <shapr> I think I could sit down and write C++ in a very short amount of time
06:35:21 <edwinb> ANd how long to debug? ;)
06:35:36 <shapr> edwinb: *very* small amount of time, because I'd use unit-test-first
06:35:39 <Jerub> shapr: I was reading C++ the other day, the amount of *bullshit* required for string processing was quite amazing.
06:36:00 <shapr> edwinb: that's part of what I mean about 'programming' as a separate skill
06:36:14 <shapr> unit-test-first isn't part of any language, but boy does it help
06:36:22 <edwinb> There's an awful lot of gotchas in C++ though.
06:36:55 <shapr> well, I've written some C++ before, though not very much
06:37:18 <shapr> Jerub: yes, I agree, Haskell is very anti-bullshit.
06:37:44 <edwinb> The amount of stuff you have to do to set up simple data types in C++ is a real pain when you're used to haskell
06:37:49 <Jerub> oh, and I'd say I know parrot imcc, but does that count?
06:37:57 <shapr> if you think it does.
06:38:15 <shapr> I recently met someone who was the technical guy in his company, and he told me he programs html.
06:38:17 <malik> well... but with haskell you normally wont programm a operating system for example
06:38:25 <shapr> malik: why not? what about hOp?
06:38:27 <malik> so haskell is not the solution for everything
06:38:50 <edwinb> there is no solution for everything...
06:39:00 <shapr> yes, I agree there is no solution for everything.
06:39:00 <malik> shapr: i dont know hOp... i just learnt some haskell at university
06:39:03 <malik> not very much
06:39:10 <shapr> this is a good chance to learn more :-)
06:39:24 <malik> mhm :)
06:39:29 <shapr> http://www.macs.hw.ac.uk/~sebc/hOp/ http://etudiants.insia.org/~jbobbio/hOp/ 
06:39:31 <malik> the exam is over :))
06:39:44 <shapr> and life is just beginning!
06:39:48 <malik> *g*
06:40:05 <malik> yes... but i dont know whether i should spend it with haskell :)
06:40:07 <Jerub> malik: good! now you have time to spend on a paper.
06:40:08 <Jerub> ;)
06:40:24 <shapr> malik: I think haskell is *one* thing you should spend it with, assuming you want to be a professional programmer.
06:40:40 <liiwi> shapr: I can't program html.
06:40:48 <shapr> liiwi: I'm happy for you.
06:40:49 <malik> "spend on a paper"? sorry my english is bad
06:40:49 <Jerub> people make fun of me at work becuase I like haskell.
06:40:55 <malik> shapr: yes i agree
06:40:58 <Jerub> but I know they're secretly scared of me.
06:41:06 <sysfault> which languages do you guys use exstensively/daily?
06:41:13 <edwinb> haskell ;)
06:41:20 <Jerub> malik: a paper, as in the kind of thing you read on citeseer
06:41:32 <Jerub> sysfault: python and haskell in my non-work stuff, php for my work stuff.
06:41:48 <malik> shapr: i sharpens your understanding....
06:42:01 <liiwi> sysfault: sh, python, perl, c
06:42:14 <shapr> I use Python for money, and Haskell for a little money and a lot of fun. I also write elisp and shell scripts on a daily basis.
06:42:21 * sysfault nods
06:42:26 <malik> shapr: but i dont know whether it's worth to do more
06:42:48 <shapr> malik: in my opinion, it is worth learning up to the point of fully understanding arrows.
06:42:57 <sysfault> bash is the only language I know atm. Currently learning awk to make my life easier as a shell scripter.
06:43:10 <sysfault> I know sed pretty well, if you want to classify it as a language in it's own sense.
06:43:11 <Jerub> sysfault: yikes. jump ahead to python
06:43:31 <sysfault> I can't really get into python, no idea why.
06:43:48 <sysfault> I was reading "core python programming", and I got up to file I/O
06:43:52 <malik> is there any real point where you use haskell?
06:43:52 <sysfault> and put the book down...
06:44:02 <shapr> malik: what do you mean?
06:44:12 <sysfault> I kno about lists, tuples, dictionaries, etc..
06:44:15 <liiwi> sysfault: just start doing stuff, it comes all together really easily.
06:44:19 <malik> my english... i should go to school or something again
06:44:22 <sysfault> I can make a simple program, but nothing too complex.
06:44:39 <sysfault> liiwi: so i should learn python before haskell? what do you think?
06:44:44 <shapr> malik: well, that sentence could have two very different meanings, that's why I ask for clarification.
06:44:48 <malik> shapr: sorry.... i mean.... do you program in haskell for the "real world" or just for educational purposes?
06:44:52 <shapr> oh, for both
06:45:01 <Jerub> sysfault: okay, meet a python script I wrote for someone
06:45:07 <Jerub> sysfault: it sorts a set of ip addresses.
06:45:16 <malik> shapr: give me an example for a real world program in haske...
06:45:37 <Jerub> http://thorne.id.au/sort-ip.py
06:45:41 <liiwi> sysfault: python will be easier if you _need_ to do something. 
06:45:52 <liiwi> shapr: http://radiohelsinki.fi
06:45:59 <Jerub> ahhh CRAP
06:46:04 <Jerub> http://thorne.id.au/users/stephen/sort-ip.py
06:46:11 <shapr> my first paying Haskell gig was where a client said "turn these ms.doc files into a custom xml flavor, here's the DTD" so I piped the ms.doc files through openoffice, and wrote a Haskell xml transmogrifier that went from the openoffice xml to the custom DTD.
06:46:44 <malik> uh
06:46:47 <shapr> took me three days to write the program, and a coupla hours to convert some large number of files.
06:46:56 <edwinb> malik: Depends what you mean by "educational purposes"
06:47:27 <shapr> oh, recently I wrote some haskell xml-rpc code to test my zope stuff
06:47:29 <edwinb> I use it to experiment with ideas for compiler implementation - it's much easier to concentrate on what's really going on.
06:47:32 <shapr> that was paying work also
06:47:33 <malik> shapr: and haskell is a good choice for something like that?
06:47:36 <Jerub> malik: I'm in the process of writing a compiler in haskell, and it is quite simply the best language I've found for that. :)
06:47:42 <shapr> yes, haskell is a good choice for xml transforms
06:47:46 <shapr> MUCH better than xslt.
06:47:53 <shapr> xslt is like digging a hole with a spoon.
06:48:00 <shapr> oh, I can do xslt also.
06:48:53 <Jerub> postscript?
06:48:58 <Jerub> oh, latex probably counts.
06:49:00 <malik> Jerub, edwinb: yes that's what i mean with educational purposes... we learn it in university to understand types, inheritance, lambda calculus etc at a clear example
06:49:22 <edwinb> malik: But it's also a good implementation language for such things...
06:49:33 <Jerub> malik: I've written compilers using about 6 languages.
06:49:37 <edwinb> In particular, because of its algebraic data types.
06:49:45 <Jerub> malik: after doing it in haskell, I would NEVER willingly use another language.'
06:50:05 <shapr> yah, first time I wrote a parser it was a tiny one in C, didn't seem too bad
06:50:13 <Jerub> (to the point I'll help implement haskell in parrot so I can run my compiler on that platform)
06:50:20 <shapr> then I did some ASN.1 parsing in Java with same sablecc derived stuff
06:50:22 <edwinb> I wrote a compiler in C once. It's unbelievably bad, looking at it now!
06:50:44 <shapr> parsing in Java is like... well, the loss of sanity isn't worth the paycheck.
06:50:45 <malik> well parsing in c is painfull... agreed
06:51:09 <Jerub> I wrote a compiler using a attribute grammar cocktail written (mostly) in a modula-2 dialect! it generated a java language compiler!
06:51:18 <Jerub> that was for university.
06:51:32 <edwinb> I'd certainly claim compilers were real world examples, anyway.
06:51:34 <Jerub> the subject originally used the cocktail for targetting ADA, but they stopped teaching ada.
06:51:42 <shapr> Jerub: wow, your wrists are bad just from banging on the table eh? ;-)
06:51:58 <shapr> or beating up on your teachers maybe?
06:52:18 <Jerub> shapr: you should have heard me when I was writing a VisualC++ assignment.
06:52:22 <edwinb> One of our undergrads once said to me, "Haskell's quite nice, but you couldn't use it for, say, writing a compiler now, could you?"
06:52:28 <Jerub> I've never been more foul mouthed than that day.
06:53:28 <Jerub> shapr: the attribute grammar language we were using was declarative, and fortunatley I know prolog (ooh! another one!) rather well, so it worked out.
06:53:34 <malik> well compiler in haskell... is that efficient?
06:53:40 <Jerub> malik: yes.
06:53:46 <edwinb> why shouldn't it be?
06:54:40 <Jerub> shapr: what was actually more painful was earlier in the semester where we had to add components to the grammar of a recursive decent parser written in java, that had been ported from ada.
06:54:48 <malik> mhm as i said i'm no haskell wizzard... i guessed that because in c there is much less abstraction... more room to optimize nor? direct access to the hardware etc?
06:55:00 <Jerub> malik: for a compiler?
06:55:52 <malik> Jerub: i mean you have a overhead with haskell nor? more abstraction more overhead?
06:55:55 <vegai> if you complete the program a month faster than in another language, does it matter if it runs a bit slower? 
06:55:57 <edwinb> You do get the illusion of control in C/C++, yes...
06:56:43 <Jerub> malik: when talking about a compiler, we're just going from String->List->Tree->String
06:57:07 <Jerub> with a few fancy bits and maybe a symbol table.
06:57:09 <edwinb> I suspect laziness is the biggest overhead.
06:57:26 <Jerub> but laziness is also what makes haskell compilers fun.
06:57:31 <edwinb> Oh yes ;).
06:58:09 <Jerub> (i.e. using parsec, its really String->Tree->String because the List generation is lazy)
06:58:50 <sysfault> Jerub: file not found
06:58:52 <sysfault> sorry i was afk
06:58:59 <Jerub> sysfault: check the second link I gave.
06:59:05 <Jerub> http://thorne.id.au/users/stephen/sort-ip.py
06:59:14 <Jerub> and thats a fully verbose version.
06:59:43 <Jerub> I could probably write it in as many lines of haskell too.
07:00:29 <sysfault> nice, that's pretty small.
07:01:14 <Jerub> sysfault: I do all of my commandline text processing with python
07:01:34 <mijdrol> EM forster ?
07:01:41 <sysfault> Jerub: was python your first language?
07:01:56 <sysfault> what was the first piece of documentation you read?
07:02:22 <Jerub> no!
07:02:26 <Jerub> LOGO was my first language.
07:02:33 <Jerub> which is a lisp
07:02:36 <Jerub> then pascal.
07:02:53 <Jerub> sysfault: I don't recall, I think I jumped on the python.org site to look something up.
07:03:17 <sysfault> ok so I'll learn awk, python, and then haskell...
07:03:19 <mijdrol> shapr: what is the point with EM forster ?
07:03:21 <Jerub> sysfault: I had to use python for a biology subject (we were doing dna sequence alignment algorithms), I just sat down and hacked on code we were given.
07:03:21 <sysfault> from there C, etc....
07:03:44 <shapr> mijdrol: lordjim@
07:03:47 <sysfault> aah.
07:03:50 <shapr> mijdrol: just made me curious
07:04:01 <shapr> thought you might be a great fan of that book.
07:04:17 <mijdrol> shapr: lord jim is a book by james conrad :)
07:04:20 <shapr> mijdrol: hi! are you learning Haskell?
07:04:29 <shapr> huh
07:04:44 <shapr> doh
07:04:48 <mijdrol> shapr: yes as far as i have time to
07:05:01 <shapr> man, I was convinced EM Forster wrote it.
07:05:20 <shapr> I think it's because I read it in the middle of a big EM Forster spree
07:05:48 <mijdrol> i'm mostly focused on ocaml but i'm interested in sml-family languages
07:06:25 <mijdrol> shapr: the other books by conrad are great too :)
07:06:27 <det> shapr: have you played with clean at all?
07:06:55 <shapr> I think Lord Jim is the only one I've read at all, and that was just the first hundred pages or so
07:07:09 <shapr> was interesting, but I got distracted by a new Neal Stephenson book.
07:07:16 <Jerub> I should go to bed.
07:07:18 <shapr> det: nope
07:07:20 <shapr> g'night Jerub!
07:09:58 <shapr> cool, looks like Peter Gammie will come to EuroHaskell
07:10:13 <shapr> mijdrol: well, if you have any questions about Haskell, I'd be happy to help you.
07:10:19 <mijdrol> shapr: yes it's long and not interesting all the way, but maybe you should read under the volcano by malcolm lowry, it's totally boring :)
07:10:33 <mijdrol> shapr: ok thanx :)
07:11:49 <shapr> mijdrol: any suggestions for interesting literature I may not have tried?
07:12:16 <Jerub> shapr: have you read greg egan?
07:13:01 <mijdrol> heart of darkness by conrad is a good one
07:13:13 <shapr> I don't know if I read greg egan.. what has he written?
07:13:20 * shapr googles
07:14:06 <shapr> oh that looks interesting
07:14:30 <shapr> oh, I think I have read some of his books
07:14:39 <Jerub> shapr: diaspora is a good one.
07:14:47 <shapr> I think I've read Permutation City
07:35:19 * Marvin-- sighs
07:38:26 * Marvin-- finds out more about Chinese politics and modern history than he ever wanted to know
07:47:17 * Marvin-- plays with vimspell.vim
08:48:44 <bring> malcolm wallace proposed writing a preprocessor in and for haskell
08:48:50 <bring> EuroHaskell project?
08:48:59 <shapr> throw it in the suggestions bin
08:49:03 <shapr> sounds like a good plan to me
08:52:05 <bring> done
08:52:56 <shapr> I think TH is the most conceptually pure way to write a CPP replacement, but it won't work for older versions of GHC
08:53:38 <Igloo> You have some syntactic limitations too. Admittedly some may be a good thing, but you probably have too many
08:57:21 <shapr> like what?
09:00:22 <Igloo> Things like #ifs in the middle of import lists. Currently you couldn't have conditional import lists (which would suffice given how imports in Haskell work) at all, and even if you could you'd need both splice and quasi-quotes. It just wouldn't be as clean to use as a dedicated Haskell preprocessor
09:00:59 <Smerdyakov> Bleh. Import and export lists are hackish.
09:01:18 <shapr> I like hacking.
09:02:04 <Igloo> Same thing is true of bits of Haskell lists, and you can't hack around not being able to do that so easily
09:02:36 <det> Smerdyakov: is it much different than ascription in SML to limit exports?
09:03:02 <Smerdyakov> det, I think so. Signatures are more "first class" than import/export lists.
09:11:58 <lewis_m> hmm, what's the syntax to define an instance of Read which takes a string and gives me a tree?
09:12:46 <Igloo> deriving Read   or   instance Read Tree where reads = ...
09:13:03 <Igloo> Well, reads s = ...
09:14:48 <monotonom> Make it readsPrec
09:16:13 <lewis_m> hmm, I tried instance Read Tree where read "" = Nil, but I get: ERROR "lists.hs":63 - Illegal type in class constant
09:17:18 <monotonom> yes
09:17:37 <shapr> lewis_m: if you use deriving (Read, Show) after your datatype declaration, then (\x ->  read (show x):: Tree) == x should be true
09:18:43 <lewis_m> shapr, my data type is data Tree a = Nil | Node a (Tree a) (Tree a)
09:19:38 <shapr> data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Read, Show)
09:19:40 <shapr> tried that?
09:19:55 <shapr> hei Esa
09:20:00 <esap> Hei!
09:20:08 <shapr> wassup?
09:20:41 <esap> just read some mail from haskell-list about simulating dependent types with Haskell, quite nice technique.
09:20:52 <lewis_m> shapr, well yes - but I wanted to define my own so that I could read them as something like {1,2,3,4,5} and have it construct a tree rather than having to do (Node 2 Nil (Node 3 Nil Nil) Nil), which isn't very readable, does that make sense?
09:21:18 <shapr> ah
09:21:36 <monotonom> instance Read a => Read (Tree a) where readsPrec s = ...
09:22:31 <monotonom> If it will be a binary search tree of sorts, instance (Ord a, Read a) => Read (Tree a) where readsPrec s = ...
09:25:26 <Igloo> I'd advise against using Show and Read for non-deriving use without good reason as it can make debugging trickier. Well, maybe not so often Read, but certainly Show
11:42:33 <lewis_m> there's some quite interesting stuff in this text book that I don't quite understand, regarding parsing expressions, combinators and stuff.. I need to write a parser to handle something like "Type Operation Arguments", i.e "List Intersection {1,2,3} {4,5,6}" or "List Union {1,2,3} {4,5,6}" and whatnot, is this the sort of stuff I should be looking at?
11:43:41 <Igloo> Parser combinators are one way, happy is another
11:43:45 <lewis_m> happy?
11:44:14 <Igloo> www.haskell.org/happy/
11:46:00 <lewis_m> hmm, looks cool - although it's for an assignment so it might be cheating :)
11:47:29 <Igloo> If you're meant to write it yourself then parser combinators are probably what is intended
11:48:28 <lewis_m> yeah, either that or I'm sure I could do something quite basic to handle the few alternatives that need to be handled, but I think I'll try making sense of combinators
12:03:44 <SyntaxNinja> lewis_m: have you seen Parsec?
12:03:50 <monotonom> I think lewis_m's parsing task can be done by quite elementary means.
12:03:56 <SyntaxNinja> (that might be cheating too)?
12:13:05 <lewis_m> monotonom: yeah, I started writing some basic functions to do it, but I'm a sucker for cool things :)
12:17:39 <reltuk> what kind of a parser?
12:44:56 <reltuk> anybody point me to an example telnet-like program in haskell?
12:46:22 <reltuk> I found one in O'Haskell...but I don't even know what O'Haskell is
13:18:33 <LittleDan> How did Miranda do I/O?
14:26:53 <reltuk> what's the $ operator do?
14:27:26 <vegai> prevents lispisms ;P
14:27:40 <ibid> rearranges parentheses
14:32:19 <reltuk> hmm...meaning what?
14:32:39 <reltuk> like "after this comes something you evaluate like it was enclosed in parentheses?
14:33:01 <rt> uh, is that right?
14:33:28 <reltuk> I don't know...
14:33:30 <Marvin--> f $ x = f x
14:33:50 <reltuk> why not just write f x ?
14:33:58 <Marvin--> the point is that you can write things like    f . g . h $ x   instead of   (f . g . h) x
14:34:01 * rt (haskell novice that I am) thought that it made the function strict in the following argument.
14:34:19 <Marvin--> rt: I think you're confusing it with $!
14:34:22 <Igloo> f (g x) === f $ g x
14:34:32 <rt> marvin: you're probably right.
14:34:43 * rt goes back to his corner.
14:35:01 <Marvin--> so yeah, in a way, it prevents lispisms :)
14:35:16 <reltuk> so it surrounds what came before it in parens?
14:35:21 <reltuk> or what came after it?
14:35:25 <reltuk> or both...
14:35:40 <reltuk> igloo's + marvin's examples seem to indicate both
14:36:08 <ibid> reltuk: basically, you replace $ with an opening paren and you add a matching closing paren as far to the right as possible
14:36:21 <reltuk> 'k
14:36:24 <Marvin--> sort of, yeah,   e1 $ e2 $ e3   is equivalent to  e1 (e2 (e3))
14:37:58 <ibid> $ is in a sense like a shell pipeline, only it flows from right to left
14:40:11 <monotonom> . is more like pipeline
14:40:38 <monotonom> $ and parameters are for wimps. Real programmers write functions pointfree. :)
14:41:02 <ibid> . is not "more" like pipeline, it's just in a different sense like a pipeline :)
14:43:42 <Marvin--> don't you mean pointless?
14:44:01 <Marvin--> oh wait, I always confuse those two
14:44:07 <ibid> "most of my programs are pointless"
14:44:24 <monotonom> pointfree is sometimes called pointless. all the obvious jokes apply.
14:44:48 <vegai> resistance is pointless!
14:45:01 <Marvin--> vegai: no, pointfree!
14:46:07 <vegai> Marvin--: no, 50ohm!
14:46:21 <Marvin--> monotonom: for the record, I'm just teasing, I'm fully aware of what point-free programming is :)
14:46:33 <vegai> "and so on and so on and so forth..." -- Monty Python
14:46:35 <ibid> we are haskell.  mutation is futile.  you will be lifted.
14:48:08 <monotonom> heh heh heh
14:49:00 <ibid> doesn't work as well as "we are debian of org.  resistance is futile, you will be packaged."
14:49:43 <reltuk> what is pointfree programming?
14:50:02 <monotonom> It means you try to never mention the parameters.
14:50:33 <reltuk> why?
14:51:43 <ibid> in the grand tradition of bad jokes: pointfree programming is better called constant programming, as it avoids variables
14:51:46 <ibid> ehe ehe ehe
14:51:56 <monotonom> The same reason a shell programmer composes a lot of filters in a pipeline. Sometimes it helps to emphasize the dataflow rather than the data.
14:52:40 * Marvin-- groans and smacks ibid
14:53:08 <ibid> Marvin--: i thought you might agree :)
14:53:13 <ibid> but i better go to bed
14:55:34 <monotonom> Also if you focus on the functions themselves, you begin to see a useful algebra of functions.
14:57:03 <monotonom> There are times it obscures and hurts, too.  So I don't recommend going pointfree all the way.  I recommend going pointfree more often and see if you gain a new perspective.
14:58:35 <Marvin--> the way I see it, is that it's painful to read code right-to-left, so you should use it in moderation
14:59:08 <monotonom> It is not painful for Middle-East people.  It is actually more natural.
14:59:09 <wglwill> i've seen people do that a few times in tutorial code, kind of irritating to me as a newbie, makes it harder for me to read their code :(
15:00:26 <monotonom> There should also be no problem defining a new operator, say ";", with f;g = g.f  In fact quite a few programming books do exactly that.
15:01:12 <Marvin--> that confuses me even more, since I'm used to function composition from maths :)
15:03:39 <ibid> probably not ; though :)
15:04:33 <Marvin--> no, not ; :)
15:06:02 <ibid> would be nice though :)
15:09:31 <Marvin--> there's always >>= :)
16:03:39 * Cale is back (gone 46:45:49)
16:03:51 * Cale is away: Probably not here.
19:27:24 <reltuk> what are Gaussian integers?
19:30:12 <sysfault>   Gaussian
19:30:13 <sysfault>        adj : of or relating to Karl Gauss or his mathematical theories of
19:30:13 <sysfault>              magnetics or electricity or astronomy or probability;
19:30:13 <sysfault>              "Gaussian distribution" [syn: {Gaussian}
19:30:30 <reltuk> right...
19:30:44 <reltuk> I know (have passing knowledge of) who Gauss was...
19:31:13 <sysfault> should be pretty trivial then.
19:31:34 <reltuk> integers invented by Gaus?
19:31:43 * Pseudonym yawns
19:31:49 <reltuk> s/us/uss
19:32:01 <Pseudonym> Integers not invented by Gauss, no.
19:32:10 <Pseudonym> Gauss did a lot of stuff, though.
19:32:43 <Pseudonym> He did prove the poorly named "fundamental theorem of algebra".
19:32:57 <Pseudonym> That was his doctoral thesis, I think.
19:33:35 <Pseudonym> http://www-gap.dcs.st-and.ac.uk/~history/Mathematicians/Gauss.html
19:33:57 <reltuk> no...I know Gauss didn't invent integers...maybe some way of representing or manipulating them...maybe some formalization or something
19:34:11 <Pseudonym> Might you be thinking of Peano?
19:34:11 <reltuk> "Note that Integral is a subclass of Real, rather than of Num directly; this means that there is no attempt to provide Gaussian integers."
19:34:51 <Pseudonym> No.
19:35:01 <Pseudonym> A Gaussian integer is a+bi where a and b are integers.
19:35:20 <Pseudonym> It's a subring of the field Z(i).
19:35:33 <Pseudonym> Basically, it's the complex equivalent of integers.
19:35:35 <reltuk> like a complex number
19:35:48 <reltuk> only i doesn't necessarily equal sqrt(-1)
19:35:53 <Pseudonym> http://mathworld.wolfram.com/GaussianInteger.html
19:36:38 <reltuk> interesting...I wonder why the gentle introduction to haskell made it point to say they're not provided
19:36:47 <Pseudonym> NO idea.
19:36:55 <Pseudonym> Gaussian integers are hardly "gentle". :-)
19:38:23 <reltuk> heh, looks like it :)
21:39:27 <ZZ> lminus [1,2,3,4] = ((1-2)-3)-4 = -8
21:39:34 <ZZ> lminus xs = second(reduce g (map f xs))
21:39:45 <ZZ> lminus xs = second(reduce g (map f xs))
21:40:14 <ZZ> what are the functions f and g?
21:41:26 <Smerdyakov> You sure won't get responses asking like that.
21:42:05 <Pseudonym> @wiki HomeworkHelp
21:42:06 <lambdabot> http://www.haskell.org/hawiki/HomeworkHelp
21:42:10 <monotonom> I only know that I would rather implement lminus as lminus = foldl1 (-)
21:42:19 <Pseudonym> monotom: Agreed!
21:42:34 <monotonom> (Why would I need a map and a second?)
21:42:43 <Pseudonym> Another option: lminus (x:xs) = x - sum xs
21:42:50 <monotonom> (And why would I need the point xs? :)
21:43:47 <Pseudonym> Actually, to be equivalent, that should read:
21:43:53 <Pseudonym> lminus ~(x:xs) = x - sum xs
21:43:57 <Pseudonym> But that's quibbling.
21:44:21 <Pseudonym> Actually, no, the first one is also equivalent.  I tell a lie.
21:44:48 <Smerdyakov> Lyin
21:44:51 <reltuk> what's ~ do?
21:46:33 <ZZ> sorry about asking rudely :)
21:46:37 <ZZ> i've seen my lecturer
21:46:49 <ZZ> there's a bunch of people here trying to work this porblem out
21:46:53 <ZZ> and we can;t :/
21:47:39 <reltuk> what's a good reference for just looking up what functions like second and reduce do?
21:48:16 <monotonom> I have never heard of them in Haskell.  I have only heard of reduce in Scheme.
21:48:31 <reltuk> ZZ : are they defined somewhere else?
21:48:47 <ZZ> no
21:49:04 <reltuk> I don't see them in the prelude...
21:49:05 <ZZ> we have to work out g and f given what i gave u:/
21:49:45 <reltuk> where do the functions second and reduce come from?
21:49:52 <reltuk> @type second
21:49:56 <Smerdyakov> ZZ, is that Haskell code?
21:50:44 <ZZ> no, but someone in the scheme channel said it looked like it :/
21:51:09 <reltuk> is it scheme?
21:51:20 <ZZ> no
21:51:35 <reltuk> what is it?
21:51:36 <monotonom> But Scheme is supposed to look like (second (reduce g (map f xs)))
21:52:13 <ZZ> i don't know what it is. the question is on functional programming
21:52:20 <ZZ> so it's a general language
21:52:38 <reltuk> and you've been learning scheme?
21:52:53 <reltuk> they're probably the reduce and second from scheme...what the hell do those do?
21:53:23 <Smerdyakov> I have the feeling that this is one of those ridiculous classes on "survey of programming languages" where students are expected to learn functional programming in a week, or similar. :P
21:53:27 <ZZ> second returns the second value in a pair
21:53:29 <Smerdyakov> So don't expect things to make sense.
21:53:48 <ZZ> reduce is like: reduce(x+y, [1,2,3,4]) = ((((1+2)+3)+4+5)
21:53:58 <reltuk> oh, reduce is straight forward...
21:54:12 <reltuk> how is reduce different from map?
21:54:23 <reltuk> I mean, foldr
21:54:35 <reltuk> eh...I'm dumb...foldl
21:54:39 <SamB> reltuk: in name?
21:54:43 <monotonom> It is foldl.
21:55:30 <reltuk> oh...then how is the question hard?
21:56:02 <monotonom> It is hard because there is a more sensible solution using no snd or map.
21:56:17 <reltuk> yeah...contrived questions suck
21:59:01 <lewis_m> monotonom, I got my code for parsing those strings working beautifully, just using a few simple functions - like you said
21:59:11 <monotonom> Congrats.
22:01:01 <reltuk> I want to use Haskell for a project so that I can learn it..
22:01:16 <reltuk> I also need to write a mud client...
22:01:28 <lewis_m> write it in haskell ;)
22:01:56 <reltuk> lewis_m: is it well suited? (/me is so stuck in OO when doing anything except writing interpreters for functional languages :-p)
22:02:12 <lewis_m> reltuk, oh, I was just making a smart-ass remark, I'm only learning Haskell now :)
22:02:19 <reltuk> haha
22:04:41 <monotonom> Haskell may work fine for a mud client.  For a mud server I am not sure.
22:05:22 <monotonom> (OO doesn't buy you anything on the client side, does it?)
22:05:30 <Smerdyakov> OO never buys you anything. :P
22:05:46 <lewis_m> i've got this bst_equal function which is supposed to compare two BSTs, I figure that when giving two trees, there are two possibilities - first is that the top nodes are equal (I guess they don't have to be depending on the order the values were added), in which case I have it returning bst_equal (bst union t1 t2) (bst union t3 t4), is that horribly inefficient?
22:06:07 <reltuk> monotonom: yeah...I don't see how it buys you much on the client side
22:15:31 <Smerdyakov> reltuk, do you really mean "imperative" when you say "OO"?
22:15:43 <reltuk> Smerdyakov: nope...OO
22:15:55 <reltuk> I mean...imperative OO...since that's the only kind I'm familiar with
22:16:28 <Smerdyakov> reltuk, then you ought to specify that. :P
22:16:54 <reltuk> Smerdyakov: heh, functional oo is weird...and so is o'haskell :-p
22:17:05 <Smerdyakov> reltuk, why is functional OO "weird"?
22:17:43 <reltuk> Smerdyakov: because it's unfamiliar and I'm weak?
22:17:59 <Smerdyakov> reltuk, OK. Report to the gas chambers.
22:18:03 <reltuk> lol
22:24:46 <SamB> I couldn't find o'hugs
22:56:51 <Cale> http://www.tt.luth.se/staff/nordland/TimberCourse/
22:58:51 <skew> Hi
22:59:02 <skew> I'm a bit confused without any context there
23:00:27 <skew> Are we supposed to use this language, comment on it, move to Oregon and join the team?
23:00:39 <skew> looks pretty nifty!
23:00:44 <Cale> If you're looking for O'Haskell, I'm pretty sure it's called Timber now.
23:01:04 <skew> Ah!
23:01:23 <skew> I've been thinking I should learn another language
23:01:38 <skew> but I'm thinking I'll probably look at either E or Erlang
23:02:46 <reltuk> what could possibly be better than haskell! :-p
23:02:53 <skew> Lisp and Prolog are somewhere on the list too
23:04:03 <skew> reltuk: Haskell with a fancier type system!
23:04:18 <reltuk> is that erlang?
23:04:55 <skew> no. There was Cayenne but it is apparently unmaintained and bitrotted
23:05:01 <skew> well, erlang is untyped
23:05:37 <reltuk> will new haskell have a better type system
23:05:38 <reltuk> ?
23:05:43 <skew> so if you have a typeOf function you could theoretically build something equivalent to the typeclass machinery and so forth
23:05:48 <vegai> new haskell?
23:05:54 <reltuk> the next version
23:06:13 <skew> there aren't really huge versions
23:06:22 <skew> just people tossing some things into GHC every now and then
23:06:44 <skew> well, eventually people might codify a new standard
23:07:47 <reltuk> I meant the next standard...
23:07:59 <reltuk> the wiki talked about what will be in it...I naturally assumed it was in the works...
23:08:04 <reltuk> or least...being thought about being in the works
23:08:35 <skew> The stuff in E about security sounds pretty interesting, and possibly requiring language support
23:09:48 <skew> although, it might be possible to do with a Haskell library, despite their claims it requires language support.
23:10:23 <skew> unsafe casting could probably break the security though...
23:11:56 <reltuk> do lots of haskell programs spend a lot of time in Monads?
23:12:12 <reltuk> the two short examples on the wiki do...
23:13:30 <skew> maybe. certainly not in IO, and likely not in do syntax either
23:14:04 <Cale> It just depends on how much of the code is dedicated to IO.
23:14:30 <reltuk> I guess both those examples are highly IO bound
23:14:46 <reltuk> so is a MUD client kind of though
23:14:50 <skew> sometimes you can do a lot in non-IO monads, in a compiler or something
23:15:10 <skew> reltuk: not necessarily
23:15:29 <Cale> well, IO is actually quite nice to use in Haskell, once you get to know it a bit.
23:16:04 <skew> a MUD client would be doing a fair bit of IO, but I don't think it would take that much code
23:16:24 <skew> I could see a lot of code in things like macro and tab completion engines
23:17:08 <reltuk> yeah, you're right
23:17:27 <reltuk> macro's, triggers, and mapping ;-p
23:17:34 <skew> but coding in IO isn't really bad in itself...
23:17:53 <skew> as long as you stay away from mutable state
23:18:13 <Cale> It's really an issue of whether you're coding things in the IO monad when you don't have to.
23:20:31 <Cale> Mutable state can be the most natural way to do some things, but if you don't consider the other options that the language affords, you can end up writing code which is harder to deal with than it needs to be.
23:34:58 * shapr yawns
23:35:15 <shapr> good morning #haskell!
23:35:26 <andersca> hej shapr
23:35:37 <shapr> hej andersca, wazzup?
23:35:53 <skew> hi shapr
23:36:08 <shapr> greetz skew 
23:37:40 <shapr> hey andersca, are you coming to EuroHaskell?
23:37:44 <skew> have I missed anything interesting in the last week or so?
23:38:01 <shapr> hm, EuroHaskell organizing, but it may be a bit far away for you.
23:38:09 <shapr> vague plans for another IOHCC
23:39:14 <skew> IOHCC sounds fun
23:39:36 <shapr> yah, it's about time we had another
23:39:38 <skew> I should probably finish reading Categories for that ...
23:40:11 <skew> but I haven't read anything since my bout of flying from school to home to microsoft to home
23:40:16 <skew> uh, school
23:40:20 <shapr> you flew to microsoft?
23:40:27 <skew> interviews
23:40:35 <skew> I wasn't too interested, thought
23:40:41 <shapr> interesting, for which part of microsoft?
23:40:50 <skew> dev job.
23:41:14 <shapr> like, Visual C++, Office, Games?
23:41:20 <skew> I talked to some Visual Studio people, who were apparently just shoehorning version control and bug tracking into the package and calling it Enterprise Tools
23:41:37 <skew> although a classmate was saying something about code analysis
23:42:00 <skew> Then some people making .NET runtimes for tiny devices, which had more interesting stuff
23:42:04 <shapr> last I knew the MS Games people they had a seriously gorgeous and intelligent programmer chick who was totally merciless in her love life :-)
23:42:44 <skew> I didn't see anybody like that
23:43:05 <skew> the .NET compact project lead seemed to pretty much be your sterotypical old time UNIX hacker though
23:43:12 <shapr> heh, neat
23:43:13 <andersca> .NET is cool
23:43:31 <skew> a little mustache, UNIX bigot, loads of C experience
23:43:41 <skew> never heard of Python or Haskell
23:43:43 <shapr> andersca: hey, are you going to add yourself to the EuroHaskell wiki page?
23:43:50 <shapr> never even *heard* of them?
23:43:57 <shapr> has he been living under a rock? :-)
23:43:58 <skew> heard of Python I think
23:44:28 <skew> he had a huge purple python book on his bookshelf, but I guess it belonged to a previous occupant (they were in the middle of moving)
23:44:48 <andersca> yay, peter gammie is coming
23:44:54 <shapr> I'm regularly surprised by the number of programmers who've only vaguely heard of languages and never investigated them. What's up with that?
23:45:23 <skew> I've heard of a lot of languages, and never really followed up on them
23:45:48 <andersca> shapr: is it 100% sure that it will appear after europython
23:46:02 <shapr> andersca: yes
23:46:16 <andersca> shapr: I heard someone talking about it happening before
23:46:26 <skew> what? IOHCC?
23:46:34 <andersca> EuroHaskell
23:46:47 <skew> Oh, "after europython"
23:46:58 <skew> how about "instead of europython"?
23:47:15 <shapr> right, Marvin-- and bring wanted to combine EuroHaskell with the ICFP contest
23:47:22 <andersca> I'm fine either way
23:47:27 <andersca> shapr: you know what would be cool?
23:47:27 <skew> "Guido's introduction to Mondas", etc.
23:47:43 <andersca> shapr: if koen or john could do talks on cool stuff
23:47:48 <shapr> and it's a great idea, but the first day of europython overlaps with the last day of the ICFPc so I'd rather do it after for purposes of informality
23:47:55 <shapr> andersca: yes, that would be cool
23:48:09 <shapr> oh, John said he can probably get us a room
23:48:44 <andersca> cool
23:48:53 <shapr> and bring is half the EuroHaskell disorganizers now, chalmers should be happier having one of their own students part of the disorganizers
23:49:20 <shapr> skew: oh, did I already show you my email searching webapp, named curryspondence?
23:49:37 <skew> no
23:49:54 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
23:49:55 <skew> it's an appropriate name for somthing you wrote
23:50:01 <shapr> :-)
23:50:11 <bring> good morning
23:50:17 <andersca> there he is now
23:50:20 <shapr> good morning Mr EuroHaskell!
23:50:32 <bring> <andersca> shapr: if koen or john could do talks on cool stuff
23:50:36 <shapr> yes!
23:50:45 <shapr> like QuickCheck!
23:50:50 <bring> John seemed like he would be interested
23:51:02 <shapr> spiffy
23:51:03 <andersca> it's nice to have it kinda informal too
23:51:06 <shapr> yup
23:51:22 <shapr> show up, wave your hands around, tell people that you want to give a talk now
23:51:38 <shapr> Discordians Unite!
23:51:52 <bring> yeah, since it's informal, people can present work in progress, or stuff they want to formally present elsewhere
23:52:34 <bring> hmm, what kind of room do we want
23:52:44 <shapr> something with net access
23:52:48 <shapr> ?
23:52:53 <shapr> what are the options?
23:52:56 * andersca ponders
23:53:12 <bring> do we expect everyone to bring theit own machine, or should we try to get one with some machine, and a bunch of guest accounts
23:53:18 <shapr> skew: I've released the code for curryspondence. iirc, it's just under 200 lines.
23:53:21 <bring> dunno if there are guest accounts
23:53:27 <andersca> bring: ES52 or ES62 maybe?
23:53:35 <reltuk> what's curryspondence?
23:53:37 <andersca> ES62 has computers
23:53:48 <shapr> curryspondence: http://shapr.homelinux.net/cgi-bin/wash/SearchML
23:54:05 <bring> there are only two or so ethernet jacks in those rooms, right?
23:54:15 <bring> and reaaly poor wlan reception
23:54:19 <andersca> I dunno
23:54:24 <andersca> they're a bit dark too
23:54:27 <shapr> I can bring a coupla 8-port hubs
23:54:33 <shapr> that's no problem
23:54:58 <shapr> and a few ethernet cables
23:54:58 <bring> we need to talk to the IT people and ask what we are allowed to do
23:55:12 <bring> if we can plug in our own networking gear etc
23:55:50 <bring> can we expect all participants to bring their own machines?
23:56:18 <andersca> perhaps add that to the wiki?
23:56:25 <shapr> yah, good idea
23:56:57 <shapr> I doubt I'll be able to bring much hardware, my dual athlon isn't very portable.
23:57:09 <bring> you have a laptop?
23:57:15 <shapr> 133MHz
23:57:17 <skew> my computer just got extremely nonportable
23:57:18 <bring> :)
23:57:25 <shapr> I could use it for a terminal to my dualie
23:57:31 <bring> what happend to it?
23:57:39 <shapr> skew: yah, what did you do?
23:57:55 <skew> well, it was overheating, so I routed the cool air from my airconditioner to the processor
23:58:01 <shapr> heh
23:58:04 <andersca> just like macgyver
23:58:12 <skew> Apollo 13
23:58:50 <skew> big billowing plastic grocery bags. I should get a picture
23:58:57 <bring> I could bring my laptop and desktop, and I lend you one of them
23:59:17 <bring> hmm, but I don't want to leave my desktop at Chalmers overnight
23:59:23 <andersca> why not?
23:59:28 <andersca> because you want it at home?
23:59:31 <bring> theft
23:59:43 <shapr> I'll try to bring my laptop so I can use it for a terminal to my desktop.
23:59:44 <andersca> I have access to a secure storage room 
23:59:53 <andersca> big iron door etc
23:59:56 <bring> that would come in handy
