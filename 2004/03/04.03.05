01:15:47 <shapr> oy
01:16:00 <Jerub> shapr!
01:16:08 <Jerub> I've been reading that haskell book.
01:16:11 <Jerub> I'm really quite enjoying it.
01:16:30 <adept> hi there
01:16:49 <adept> speaking of haskell books, is there anything interesting available online recently?
01:16:56 <Jerub> haskell really turns the C++ paradigm of inheritance and polymorphism on its head.
01:17:17 <shapr> I'd say it opens it up, but I agree with you.
01:17:49 <Jerub> shapr: when I say turns it on its head, its the same terms, the same concepts, but the implementation is inside out.
01:17:56 <Jerub> its *extremely* fun.
01:18:42 <mnc> Hi folks, I have a beginner question.  Anyone here?
01:18:53 <shapr> adept: nothing new, the best I've seen is YAHT
01:18:53 <shapr> there's the new wiki project mentioned in the topic
01:18:54 <adept> yep
01:19:23 <Jerub> mnc: sure.
01:19:35 <mnc> Next time I have a few spare weekends, I want to learn how to do interactive animation, as nearly "purely functional" as possible.
01:19:52 <mnc> Should I get the original 1997 Fran, and an old Windows?
01:20:04 <mnc> Or is that obsolete, and I should just get Yampa?
01:20:12 <mnc> Should I buy School of Expression?
01:20:17 <mnc> What's the best way to get started?
01:20:27 <Jerub> you don't ask easy questions ;)
01:21:26 <mnc> It's just for learning, I don't expect to create anything worth selling or even giving away,
01:21:42 <mnc> so if obsolete stuff is the best for learning, I'll use obsolete stuff.
01:22:32 <earthy> best choice ofcourse is to take what is current
01:22:49 <shapr> mnc: yampa
01:22:52 <earthy> plus, wxHaskell provides a purely functional interface to UI and graphics
01:22:58 <shapr> Yampa is powerful stuff
01:23:03 <Jerub> earthy: oooOOoo
01:23:09 <earthy> with reactive programming stuff for event handling
01:23:17 <Jerub> I've used wxpython
01:23:45 <mnc> shapr: do you know if Yampa includes everything that was in Fran?
01:24:15 <shapr> I do not, because I've never investigated Fran in depth.
01:25:21 <mnc> What about HSOE, have you guys read it?
01:26:29 <earthy> hsoe is nice
01:26:58 <mnc> What software is good for learning from HSOE?  Linux and Hugs?
01:27:05 <shapr> yah, I agree. It's more mathy than Thompson's Craft of Functional Programming, but that's nice.
01:27:50 <earthy> linux & hugs, linux & ghci, windows & hugs, windows & ghci
01:27:53 <Jerub> shapr: I need a project. I'm considering a haskell based templating system.
01:27:54 <Jerub> ;)
01:28:05 <earthy> you'd not get very very far with Helium, but you might try that as well
01:28:05 <shapr> for what sort of templates?
01:28:14 <Jerub> shapr: uhh, sorry.
01:28:22 <Jerub> I'm a very web centric person, web templated.
01:28:27 <Jerub> er templates.
01:28:27 <shapr> Halipeto is a recent TAL reimplementation in Haskell
01:28:44 <earthy> but, mnc, yampa includes basically all that you might want from Fran
01:29:11 <earthy> maybe not all the sugar, but that can be easily implemented yourself
01:29:12 <shapr> Jerub: check out Halipeto
01:29:44 <earthy> Andrew has done cool stuff with Halipeto and Pancito
01:30:32 <mnc> earthy: thanks.  Sounds like I should read the original Fran paper but not bother to download the software (and just learn Yampa instead) because I'd rather not have to install Windows.
01:30:48 <Jerub> shapr: wow, that looks cool.
01:30:51 * earthy nods
01:31:04 <mnc> You mentioned wxHaskell uses reactive events.  How does wxHaskell compare with Yampa?
01:32:28 <Jerub> ahh, its a *static* page generator.
01:33:10 <shapr> Jerub: with HWS-WP it wouldn't have to be static
01:33:28 <shapr> I have an evil plan to build a web application server that can do everything that Zope can do.
01:33:40 <Jerub> never used zope.
01:34:20 <shapr> well, I would guess you're thinking about Woven or Nevow when you talk about templating systems?
01:34:29 <cuelebre> wash +haxml + hsql ?
01:34:53 <shapr> cuelebre: close :-) HaskellDB rather that HSQL
01:35:02 <Jerub> shapr: or any of the bakers dozen I've experienced with php.
01:35:17 <Jerub> shapr: I'd really be wanting a complete web framework, rather than just a templating system.
01:35:20 <Jerub> but one step at a time ;)
01:35:27 <shapr> right, same here
01:35:51 <shapr> mnc: you might want to check Hudak's "Dance" paper. He mixes Labonotation and Yampa and comes up with something really cool.
01:36:06 <Jerub> and of course, I'd be wanting to move towrads object publishing ala woven rather than html with embedded code ala php ;)
01:36:18 <mnc> shapr: thanks; I'll look for it.
01:38:24 <mnc> shapr: OK, I found the Dance paper; I'll read it tomorrow.
01:39:30 <shapr> The HSOE book has Haskore in it as an example of a Domain Specific Embedded Language
01:40:54 <shapr> Jerub: do you have any representative object publishing code?
01:41:02 <shapr> the only thing I'm familiar with is Archetypes in Plone
01:41:24 <Jerub> shapr: formless is the major example.
01:41:56 <Jerub> shapr: it allows you to, with a very thin wrapper, expose an object on a webpage, including submitable forms that affect the object directly.
01:42:05 <shapr> that sounds like Archetypes
01:42:18 <shapr> can you point me to some formless sources?
01:42:26 <Jerub> yeah, grabbing one now.
01:42:52 <Jerub> http://soundfarmer.com/content/code/formpost.tac <- trivial example.
01:43:06 <Jerub> http://soundfarmer.com/content/code/formpost5.tac <- far less trivial example.
01:43:20 <shapr> http://shapr.homelinux.net/~shae/Observatory.py <- production example of Archetypes
01:44:40 <Jerub> yes, same concept.
01:44:45 <Jerub> very similar implementation.
01:47:31 <mnc> Can you recommend a quick-and-easy introduction to Haskell, preferably on the Web?  Maybe something at about the same level as The Little MLer?
01:48:05 <earthy> http://www.haskell.org/tutorial/
01:48:19 <mnc> thanks.
01:48:48 <Jerub> shapr: small request - can you make .py files text/plain on your webserver ;)
01:50:00 <mnc> I'll read the haskell.org tutorial, then the Fran paper, then whatever docs come with Yampa.  For software, I guess I'll start with Hugs, since you said Helium probably wouldn't get me far enough.  Does this sound like the right plan?
01:50:27 <mnc> (and the Dance paper shapr recommended)
01:52:51 <earthy> sounds good
01:53:03 <earthy> Helium is good for basic understanding of types and functions and stuff
01:53:20 <earthy> but it isn't a complete Haskell 98 implementation
01:53:41 <earthy> (it has *very* helpful errormessages though, comparing with e.g. hugs and ghci)
01:53:50 <mnc> Would it help me to use Helium for a while, before going to Hugs?
01:53:57 * earthy thinks it would
01:54:08 <earthy> while you're still going through the tutorial
01:55:00 <earthy> here at cs.uu.nl we start out teaching on Helium and then let the students migrate to either hugs or ghci (their choice)
01:55:13 <earthy> it seems to be a good path
01:55:42 <mnc> OK, great, I'll start with Helium and the haskell.org tutorial.  And if the tutorial is short, I'll go through it a second time using hugs.
01:56:01 <earthy> that won't be necessary. :)
01:56:12 <earthy> the code you'll write is *identical*
02:02:34 <Lunar^> Does anyone know a good tutorial on TH ?
02:02:50 <earthy> not me
02:02:56 <earthy> (I've been looking for one as well
02:02:57 <earthy> )
02:03:10 <Lunar^> hehe
02:03:38 <Lunar^> Last time I used unsugared constructors, but it seems you can avoid it
02:08:05 <mnc> Thanks, you guys have been very helpful.
02:08:20 <mnc> Another question: is there a Haskell implementation with real-item garbage collection?
02:08:48 <mnc> (I meant real-time)
02:09:36 <shapr> I've heard about the incremental garbage collection paper
02:09:54 <shapr> but I think Lunar^ knows more about various garbage collectors in Haskell than I do ;-)
02:10:20 <shapr> Lunar^: hey, we were talking about you on #plone yesterday :-)
02:10:39 <shapr> I was chatting with odeckym and someone else from ingeniweb.
02:11:55 <shapr> mnc: Hudak has also done some real-time work with industrial robots, that's part of the origin of Yampa.
02:12:29 <shapr> mnc: if you're doing something like machinima, I'd like to be involved :-)
02:12:50 <mnc> What is machinima?
02:13:29 <shapr> making movies with FPS game engines.
02:15:52 * Jerub is watching jackie chan - drunken master.
02:16:04 <shapr> that's a great movie
02:17:06 <shapr> mnc: I've thought that something like Ice Age could be done from the 'director' perspective where you use Yampa to program the behaviour of the actors, then you tell the actors what to do, without having to do all the detail of moving each puppet.
02:17:22 <mnc> Very cool, I'm looking at machinima.com now.  But no, I'm not expecting to do anything like that!
02:18:13 <shapr> ok
02:19:08 <earthy> shapr: it'd still be hard though
02:19:28 <earthy> and you'd have to program the puppets to `know' how to move, at least once
02:20:29 <shapr> it'd be less hard than it is now.
02:20:44 <shapr> yup
02:20:52 <shapr> it'd still be easier.
02:21:30 <earthy> oh, definitely
02:21:58 <earthy> good research project for a movie-science master's. :)
02:22:05 <earthy> (if such a thing exists ;))
02:22:11 <shapr> if you look at the migration scene in Ice Age, I suspect each puppet was hand animated
02:22:37 <earthy> yes, but the movement of the puppets was orchestrated at a higher level
02:24:48 <mnc> After a few minutes of surfing, I still don't understand why they want to make their films in real time.  If you're making something that's not interactive, why wouldn't you want to let the machine crank a bit longer and put more computation into each frame?
02:26:23 <shapr> mnc: do you mean machinima?
02:26:55 <mnc> Yes.
02:27:26 <shapr> from what I've read, the 3D engines in First Person Shooters is the best technology you can get for under five dollars.
02:28:06 <shapr> and it's easier to 'direct' if your actors are longtime FPS players.
02:29:16 <mnc> OK, I get it.  That makes sense.
02:29:51 <mnc> When reading about Haskell, I keep seeing references to microsoft.com.
02:30:08 <mnc> Did they ever make commercial use of the Haskell research they funded?
02:30:26 <shapr> I don't think so.
02:30:45 <shapr> the closest thing to it that I know of, is the MS Excel paper SPJ wrote for ICFP2003
02:31:11 <mnc> Can you give a one-sentence summary
02:31:12 <mnc> L
02:31:14 <mnc> ?
02:31:23 <shapr> do you use Dvorak?
02:31:37 <mnc> Yes.  You could tell just because of the L?
02:31:40 <shapr> yup
02:31:43 <mnc> Cool.
02:31:47 <shapr> since I make that typo too :-)
02:32:46 <mnc> Actually I use the American Simplified Keyboard version of Dvorak, EXCEPT that I moved a few punctuation characters (especially parentheses) for Lisp programming.
02:32:50 <shapr> SPJ's Excel paper could be summarized as "allow reusable functions"
02:33:15 <shapr> yah, I'm not 0ld sk00l dvorak, or I would have swapped the number halves
02:33:35 <mnc> I think that wouldn't work any more anyway.
02:34:13 <mnc> I think his swapped number halves had something to do with the fact that all year start with "19" which is no longer true.
02:41:25 <Lunar^> See the new GHC homepage ?
02:41:29 <Lunar^> http://www.haskell.org/ghc/staging/
02:51:15 <shapr> mnc: actually, it had to do with 0 and 1 being more common than other numbers
02:51:26 <shapr> and especially in our binary world, I think it would still work
02:53:28 <shapr> Lunar^: nice
02:53:37 <shapr> but they got the debian packaging wrong
02:53:54 <mnc> OK, I think you're probably right.  Also, after I wrote that, it occurred to me that all years begin with 2 and 0 which still works anyway.
02:54:27 <mnc> No, wait, I got that wrong, 200x still wouldn't work as well as 19xx.
02:55:02 <mnc> But, anyway, keyboards have separate number keypads now.
02:55:08 <shapr> not mine
02:55:22 <shapr> http://www.kinesis-ergo.com/contoured_usb.htm
02:55:26 <shapr> heavily remapped
02:55:48 <shapr> I've assigned specific keys for iswitchb, hippie-expand, irc, mail/news (gnus), and more
02:57:01 <Jerub> shapr: *awesome*
02:57:12 <Jerub> I've been having serious keyboard-overuse problems recent
02:57:26 <shapr> I have some ideas for that
02:57:30 <earthy> those are quite expensive though
02:57:36 <shapr> earthy: and *totally* worth it
02:57:37 <mnc> Just looked up the keyboard picture.  Very spiffy.  I think it would be even better, with a little touch-pad in the middle.
02:57:42 <earthy> shapr: I know. :)
02:58:13 <earthy> just like the v1 microsoft natural I own totally saved my hands when typing my master's
02:58:39 <shapr> mnc: the kinesis has a keypad button on the top right, but it's sort of cheesy
02:58:44 <earthy> now to get something to connect PS/2 to USB and I'm once more a happy camper
02:59:04 <shapr> I have some ps/2 <--> usb pluggies that came with my logitech mouse
02:59:30 <earthy> well, those tend to be USB -> PS/2
02:59:35 <earthy> I've got a couple of those as well
02:59:55 <earthy> but I need PS/2 -> USB
03:00:00 <earthy> that's somewhat rare ;)
03:00:09 <shapr> ohh
03:00:11 <earthy> I'll deal with typing on the iBook keyboard for now ;)
03:00:21 <earthy> and using a M$ Natural Pro while at work.
03:00:33 <earthy> even thoug it isn't quite the same as the original Natural
03:01:27 <shapr> mnc: yah, I've read about some people who put a cirque trackpad in the middle of their kinesis, so they can mouse with their thumbs
03:01:43 <earthy> that seems inaccurate, mousing with your thumbs
03:02:14 <shapr> in my experience, it works just fine.
03:02:26 <Jerub> generally the way those adapters work is they're just plugs with the wires arranged.
03:02:40 <earthy> Jerub: exactly
03:02:51 <Jerub> the USB mice come with the hardware for PS/2 as well.
03:03:10 <earthy> thing is I have a PS/2 keyboard that does not come with USB hw
03:03:19 <Jerub> earthy: thats a pain.
03:03:21 <earthy> conversion is somewhat pricey. ;)
03:03:28 <shapr> Jerub: most of my keyboard ideas come from Jef Raskin's "Humane Interface" ideas
03:03:49 <shapr> anyways, kensanata introduced that to me, and Damien Elmes has implemented most of those ideas
03:05:29 <mnc> shapr: I have an Adesso keyboard with the Cirque built in.  It's great.  Using the thumb is not quite accurate enough, so I often end up using an index finger.  It's mostly unconscious.
03:17:15 <shapr> mnc: one of my 'standards' is that I try to be able to do everything without lifting my hands from the touchtyping position. Because of that, I've switched to using Ion, lately version 2.
03:17:50 <shapr> maybe not standard, goal would be a better description.
03:23:47 <mnc> What is Ion?
03:23:58 <shapr> it's an X window manager
03:24:13 <mnc> OK, I'll look it up.
03:24:27 <shapr> while not quite as extreme as ratpoison, it does let you do almost everything with the keyboard
03:30:25 <earthy> `almost'?
03:31:05 <shapr> galeon is still a pain to use from the keyboard
03:31:26 <earthy> ;)
03:31:29 <shapr> I'd like to rebind the page-up/page-down functions and a few other things
03:32:36 <shapr> space jumps down a page, typing part of the url name will jump to that url if it's visible, but I've rebound pgup/pgdn/home/end to super and hyper
03:40:38 <Jerub> I used ratpoison for a long while.
03:52:40 * ibid recommends the use of bnfc to my students in next week's exercises
03:59:26 <Jerub> ibid: I used to irc here when I was doing haskell at uni.
03:59:53 <Jerub> I couldn't imagine anything scarier than accidentally talking to my lecturer about assignments/problems ;)
04:01:20 <ibid> oh? hehe
04:03:23 * earthy grins
04:03:47 * earthy recalls a course he's assisted on where one of the tasks was actually to get on IRC and discuss the assignment ;)
04:04:12 <earthy> on a channel where the assistants and the lecturer hung out. ;)
04:06:05 * ibid has attended a course with IRC lectures
04:18:47 <Jerub> ;)
04:19:03 <Jerub> at UQ the haskell and prolog exams were conducted in an 'open-world' fashion
04:19:09 <Jerub> entire class in a computer lab.
04:19:47 <Jerub> the lecturer was so easy going he said "look, you can go on the internet, post questions in chat rooms, read websites, all you want. it probably won't help you pass. :)"
04:20:05 <ibid> in my current course, if you do an excellent learning journal, you don't need to take an exam
04:29:46 <cm> bonjour
05:19:55 <Lemmih> Hey mads-
05:20:04 <mads-> Greeting Lemmih
05:51:13 <_joey_> could someone explain to me how to find the principal type of an expression?
05:51:56 <_joey_> citationb  form Hudak's tutorial
05:52:05 <_joey_> For example, the principal type of head is [a]->a; [b]->a, a->a, or even a are correct types, 
05:52:36 <_joey_> how could a be a correct type for head?
05:58:21 <_joey_> nobody is volunteering to make a comment?:>
05:59:07 <Lemmih> We're all just idling in here (-:
05:59:21 <kosmikus> these are variables used for type inference, they play a different role as type variables in actual Haskell types
06:01:10 <_joey_> either I can't understand your answer or you didn't understand the question,
06:01:32 <_joey_> I am not talking about type variables but the principal types
06:01:59 <kosmikus> the way this is meant is that "a" is a correct type for head if you interpret "a" as a variable which can stand for a type
06:02:21 <kosmikus> then you can substitute "a" by "[Int] -> Int", for example, and you are done
06:02:54 <kosmikus> all the three types you gave are "partial" descriptions of the type
06:02:58 <_joey_> then a could be the pricnipal type for everything in Haskell
06:03:06 <kosmikus> you can give a substitution that maps them to "[a] -> a"
06:04:12 <_joey_> oh man
06:04:14 <_joey_> this confusing
06:04:24 <_joey_> Haskell's typing 
06:04:41 <earthy> not confusing
06:04:46 <kosmikus> no, I think the sentence in Hudak's tutorial is confusing, as it stands
06:05:07 <_joey_> I should start reading authority papers byt thos who actually added the feattures to Haskell
06:05:13 <kosmikus> it shouldn't say that these three are "correct types, but too general"
06:05:32 <earthy> well, polymorphic types were in Haskell from the beginning I think
06:05:38 <earthy> and have existed way longer
06:06:55 <kosmikus> _joey_: forget what it says there ;)
06:07:13 <kosmikus> the principal type is the "best" type you can give to a function in Haskell ...
06:07:23 <_joey_> earthy: dude, do you understand whtat the tutorial says or what ksowere trying to explain?
06:07:27 <_joey_> I didn't
06:07:39 <_joey_> s/ksowerre/kosmikus
06:07:49 <earthy> yeah, I understand what it is trying to say
06:07:52 <kosmikus> to head you could assign "[Int] -> Int", you could assign "[Char] -> Char", or [(a,b)] -> (a,b)", or "[a] -> a"
06:07:53 <earthy> to me it is not confusing
06:08:00 <earthy> in the tutorial, it doesn't make sense.
06:08:02 <kosmikus> all of them are correct types for the function in Haskell
06:08:19 <kosmikus> but the last one is the "best" in the following sense:
06:08:41 <_joey_> okay, why did Hudak suggest about [b]-a
06:08:49 <_joey_> [b]->a\
06:08:56 <kosmikus> the set of functions that belongs to the other types is a proper superset of the set of functions that belongs to the last type
06:09:22 <earthy> [b] -> a   is a valid type for head *if* you instantiate a and b to the same type
06:09:26 <kosmikus> Hudak did confuse two different things, I think
06:09:36 <kosmikus> although it's not like him to do so ...
06:10:00 <earthy> how  a -> a  would match head's type I really really really do not see.
06:10:24 <_joey_> okay , could you instantiate (whatever this could mean in Haskell) [a] to b?
06:10:40 <kosmikus> earthy: yes, that seems really wrong
06:11:03 <earthy> joey: um, yeah. in general you could
06:11:12 <kosmikus> earthy: probably should have been b -> a
06:11:16 <earthy> kosmikus: yup
06:11:21 <_joey_> then I am going to sleep and read it tomorrow again
06:11:33 <earthy> (and joey, disregard that last remark. you could do it the other way around, not the way you put it)
06:12:32 <kosmikus> the part that I explained above is important, I think; this substitution and instantiation business is not, unless you want to understand the details of type inferencing, which is not necessary to be able to write programs in Haskell
06:12:46 * earthy nods at kosmikus
06:13:32 <earthy> g'night, joey. ;)
06:14:34 <_joey_> I am not sleeping yet
06:15:06 <_joey_> The Report 4.1.4 sections defines the principal type
06:15:13 <_joey_> section*
06:15:55 <_joey_> kosmikus: I need to understand this stuff in detail because it will in the exam
06:16:22 <_joey_> exam is some 3 months away:>
06:17:38 <kosmikus> _joey_: yeah, that definition is okay
06:19:48 <_joey_> I am not used to such defintions
06:20:15 <_joey_> would you believe our faculty is using haskell in 1st intro course
06:20:33 <_joey_> they are only confusing most students
06:22:17 <earthy> yes, I would believe that
06:22:41 <earthy> and I'm not sure the choice is necessarily bad
06:23:00 <_joey_> so why in the report  it is suggested that double x = x + x has pricniapl type of a->a and not , say, a
06:23:15 <earthy> because double takes an argument
06:23:57 <_joey_> it is bad, manyu students have never written a single computer and will be overwhelmed, imho
06:24:04 <_joey_> they won't even appreciate haskell
06:24:24 <_joey_> head takes an arghument too
06:24:46 <earthy> ah yes. however, head then proceeds to pry it apart, assuming that argument is a list
06:25:05 <earthy> therefore, for head to work, you're really better off if you state that the argument has to be a list
06:25:35 <kosmikus> _joey_: the principal type of head is "[a] -> a", and nothing else
06:26:34 <_joey_> 00:32  <kosmikus> then you can substitute "a" by "[Int] -> Int", for example,
06:27:04 * earthy grins
06:27:21 <earthy> joey: suppose I have a function  id :: a -> a
06:27:31 <earthy> now, I could apply that id to *anything*, right?
06:27:40 <_joey_> no need to go any further
06:27:41 <kosmikus> _joey_: yes, but I didn't say that this makes "a" the principal type or something
06:27:48 <_joey_> you are not sure what you are talking about
06:27:55 <_joey_> I'd ask my lecturer next week
06:28:29 <earthy> what kosmikus then stated is that the a in the argument position can be instantiated to e.g. [Int] -> Int
06:28:47 <earthy> which would also be an instance of the type of head
06:28:47 <kosmikus> feel free to do so, but if you read the logs once more from the beginning, you will see that what I said is consistent
06:29:09 <kosmikus> the problem is just with that strange sentence in the tutorial, which just shouldn't be there
06:29:38 <earthy> the sentence in the tutorial isn't even semantically correct... ;)
06:29:52 <earthy> hm. guess we scared him.
06:30:37 <kosmikus> maybe ... but he wanted an answer ;)
06:31:03 <earthy> true enough. :)
06:31:14 <adept> /list #xemacs
06:37:10 <Lunar^> Damn.. I need a stage2 GHC in order to do some Template Haskell
06:38:56 <kosmikus> you make it sound as if a stage2 GHC is a very rare and difficult to obtain object ...
06:40:22 <phubuh> sup
06:45:23 <darius-> thanks, but i just ate
06:49:55 <Lunar^> kosmikus: It is when you don't have neither System.IO nor the unix package
06:53:28 <kosmikus> what architecture are you on?
06:53:45 <phubuh> hOp, I'm guessing
06:54:52 <Lunar^> right
06:56:34 <kosmikus> ah, fun :)
06:58:48 <_joey_> I'm back:>
06:59:00 * _joey_ was frustrated a bit
06:59:43 <_joey_> kosmikus: do you know where  I could find Haskell code to learn from?
07:01:18 <Lunar^> Arg
07:01:47 <Lunar^> building stage2 without haskell98 package seems difficult :(
07:12:41 <earthy> joey: http://www.haskell.org/learning.html has links
07:22:15 <_joey_> earthy: where did you find links to haskell code on that page?
07:23:41 <kosmikus> _joey_: what kind of code are you looking for?
07:25:36 <kosmikus> _joey_: you can, for instance, take the "Tour of the Haskell Prelude" from the "Learning" page, and look at the implementations of all the functions from the Haskell Report
07:25:53 <kosmikus> that will expose you to a lot of small useful functions and their implementations
07:28:12 <kosmikus> I see that the "Tour" contains the definitions; even better, then ...
07:34:20 <SyntaxNinja> so did anyone send Aetion their resumes?
07:34:34 <SyntaxNinja> maybe I should go harass the ocaml channel too
07:37:03 <darius-> says they're not currently hiring
07:38:31 * Igloo would have, were it not for the previously mentioned issues
07:46:49 * earthy is not interested in working in the US
07:46:56 <earthy> *and* working towards his PhD. :)
07:47:08 <SyntaxNinja> darius-: don't believe our web page :) http://www.haskell.org//pipermail/haskell/2004-February/013699.html
07:47:13 <darius-> heh
07:49:20 <darius-> i don't object to military apps in principle, but given how unhappy i am with the u.s. government lately...
07:51:40 <_joey_> kosmikus where
07:53:16 <_joey_> kosmikus where's your common sense? I am not looking for aglorithms provided in the functions, I want see a written program in haskell that shows how libraries are set up and used, interface, function, defintions etc
07:53:42 <_joey_> you are yet to make a decent remark
07:53:50 <SyntaxNinja> darius-: yeah, I don't blame you.
07:56:39 <_joey_> I am curious who 'd want to employ a programmer that uses haskell to solve programming problems
07:57:09 <SyntaxNinja> _joey_: I work full time as a haskell developer, and we have 1.5 other haskell developers.
07:57:14 <kosmikus> _joey_: The hugs distribution contains a number of small to medium-sized example programs.
07:58:01 <kosmikus> _joey_: I you want to full-sized program, then pick any Haskell project out there, download the sources and look at them.
07:58:11 <_joey_> oh yeah? i thought haskell is used mainly in universites to present some conepts in CS, no more
07:58:45 <SyntaxNinja> _joey_: in fact, the main GHC developers are employed by microsoft research.
08:00:01 <_joey_> you see, MS can afford to waste money
08:00:21 <_joey_> what kind of research do these people do for MS
08:01:45 <SyntaxNinja> _joey_: do you think a company with 6 people in it can afford to waste money?
08:01:49 <SyntaxNinja> maybe we're just as dumb as MS
08:02:27 <Igloo> Syn: If you have buckets of it then yes  :-)
08:03:05 <_joey_> SyntaxNinja: I didn't say anything about you being dumb but now that you mentioned it:>
08:03:10 <Igloo> I think the answer is "Look at darcs (for example) and stop trolling", anyway
08:03:55 <kosmikus> SyntaxNinja: and you're lucky that _joey_ didn't. He already implied that for me ;)
08:04:19 <SyntaxNinja> kos: it only took a couple comments to realize that _joey_ was trolling :)
08:04:34 <_joey_> SyntaxNinja maybe it's a good language , I just don't enjoy using haskell to solve problems nad nearly every other student in our courses
08:05:25 <_joey_> pkay, when you can't present an argument or have a bit of fun you'd accuse a person of trolling
08:05:28 <SyntaxNinja> _joey_: so you're learning it in school? what else have you had to use? do you usually enjoy programming in any case?
08:05:50 <SyntaxNinja> _joey_: well, I didn't see the entire discussion, but I didn't know you were just joking around.  mea culpa
08:05:56 <_joey_> SyntaxNinja: it's a first , 1st semester of Comput science
08:06:09 <SyntaxNinja> maybe you just don't like programming.
08:06:12 <_joey_> and the faculty uses haskell
08:06:21 <SyntaxNinja> what university?
08:06:21 <_joey_> SyntaxNinja: now you are trolling
08:06:37 <_joey_> I've written many programs using C /Perl and Java
08:06:45 <SyntaxNinja> _joey_: well, you say you don't enjoy haskell, and that it's your first language.
08:06:47 <_joey_> unsw
08:07:13 <_joey_> I've sroted you out man
08:07:23 <SyntaxNinja> oh, maybe that's not what you meant by "it's a first"?
08:07:27 <_joey_> you are trolling, where did you see me saying haskell is first language?
08:07:49 <SyntaxNinja> (11:05:27) SyntaxNinja: _joey_: so you're learning it in school? what else have you had to use? do you usually enjoy programming in any case?
08:07:49 <SyntaxNinja> (11:05:56) _joey_: SyntaxNinja: it's a first , 1st semester of Comput science
08:08:09 <_joey_> and youare on defensive , pretty much like all other guys who use Haskell:)
08:08:37 <SyntaxNinja> so what did you mean?
08:08:53 <_joey_> so how did you come up with an id3a Haskell is my 1st language from that sentence?
08:09:08 <_joey_> it means what it means, troll
08:09:55 <kosmikus> SyntaxNinja: give it up. He has convinced me. I am going to use Java from now on :)
08:09:59 <SyntaxNinja> hm. well, I asked "what other else have you had to use" and you said "it's a first, it's my first semester". I guess I thought, for some reason, that you were answering my question.
08:13:09 <_joey_> kosmikus: I would shyut up if I were you, you didn't make a sensible comment in the last 2 hours and contradicted yourself many times
08:13:25 <_joey_> natural for haskell programmer
08:13:52 <kosmikus> _joey_: don't worry, I do ...
08:14:19 <mattam> is it me or citeseer do not respond for 2 days ?
08:14:38 <_joey_> SyntaxNinja: and I told you are a troll, how difficult it is to see that the comment I made didn't refere to your last statement before the comment
08:14:41 <_joey_> *troll*
08:14:43 <_joey_> heh
08:16:00 <_joey_> I even getting good grades for bloody Haskell
08:16:07 <SyntaxNinja> _joey_: you've made that idea abundantly clear. I see now that, though I still don't know what you did mean, you weren't replying to what I said. in any case, I've found that people hwo come into university and are already pretty good at programming often rebel against the new languages they're forced to learn, because they're either not what they already know, or they're not commonly used in Industry, so they can't go directly onto a resume.
08:16:08 <_joey_> something everyone hates in our course
08:16:43 <SyntaxNinja> it's too bad you're not enjoying it.  many very experienced developers enjoy writing haskell code more than the languages you mentioned enjoying.
08:17:27 <_joey_> and that accurately reflects the number of projects done in C and Haskell
08:18:10 <SyntaxNinja> maybe you could try to be a little more clear. is that a question? a statement? what do you mean by that? are you saying that the fact that there are more programs written in C means that C is more fun?
08:19:08 <mattam> _joey_: there are not very much good writers out there, so bad romans, polars and sci-fi gets the most books out there. 
08:19:15 <_joey_> for me it's fun when you get things done, yeah
08:20:25 <SyntaxNinja> _joey_: what resources are you using for learning Haskell?
08:20:42 <norpan> why are you feeding this guy?
08:20:52 <SyntaxNinja> C is indeed a very practical language.  In my mind, there is a clear distinction between practical and fun, though.
08:21:02 <mattam> i'm bored waiting for an answer.
08:21:06 <SyntaxNinja> norpan: not sure, really. I'm sure I'll give up soon.
08:21:21 <_joey_> SyntaxNinja: Hudak's tutorial
08:21:35 <mattam> ping citeseer.nj.nec.com anyone ?
08:23:04 <SyntaxNinja> _joey_: the gentle introduction, or the book?
08:23:20 <Taaus> mattam: It appears to be down.
08:23:43 <_joey_> SyntaxNinja the tutorial
08:24:09 <_joey_> SyntaxNinja: look dude, I didn't come to rubbish hskell or start flaming
08:24:29 <mattam> Taaus: thx
08:24:31 <_joey_> I don't care about hskell all I need is to get a grade, I just became frustaarted
08:25:19 <SyntaxNinja> _joey_: sorry you're frustrated. I think you'll find that the folks in this room will be very helpful if you have specific questions.
08:26:19 <SyntaxNinja> the haskell community is very friendly, since we enjoy input from outsiders, but if you do want to criticize haskell, you'll be expected to be on-topic and responsive to the counter arguments of others, rather than calling us stupid, etc.
08:44:37 <kosmikus> mattam: what were the results of your compilation tests?
08:59:55 <mattam> kosmikus: ghci doesn't work, ghc does
09:28:33 * shapr sighs
09:28:48 <shapr> poor joey
09:30:06 <shapr> I get frustrated too, but I try to do something constructive to become less frustrated.
09:30:19 * cm pats shapr 
09:31:16 <shapr> That's why I have a unicycle!
09:31:23 <shapr> cm: how do you deal with frustration?
09:31:46 <cm> hm.
09:32:13 <cm> i get migraine ;)
09:32:29 <shapr> exercise works for me.
09:32:37 <Etaoin> is there something similar to map for tuples?
09:33:06 <shapr> I don't think so
09:33:25 <shapr> tuples are unique types in Haskell, rather than being sequences as they are in Python
09:33:48 <shapr> you could write a tuple map in Template Haskell
09:33:50 <Etaoin> but they have a fixed length
09:34:08 <kosmikus> yes, of course you can define them yourself easily
09:34:29 <Etaoin> what I'd really like is to use lists, but somehow specify that they contain exactly n elements
09:34:38 <kosmikus> but it's not possible to define "Functor" instances, because tuple maps take different numbers of arguments
09:35:24 <shapr> Etaoin: oh, there's code to do that in HaskellDB
09:35:54 <shapr> the implementations of limited SQL types like VARCHAR(N) do that.
09:37:31 <kowey> would it not be simpler just to make up your own type?
09:40:16 <kowey> damn... that didn't make any sense.. sorry, sleepy
09:43:29 <Etaoin> shapr: where would that be?
09:43:53 <Etaoin> in the source
09:43:57 <shapr> Etaoin: http://haskelldb.sf.net/ I think 0.6 has something called BoundedList maybe?
09:44:02 <shapr> oh, I'm not sure.
09:44:24 <Etaoin> well what it's called would help me a lot
09:45:07 <shrimpx> heh
09:45:09 <shapr> I think the HaskellDB 0.6 announcement mentioned it by name
09:45:15 * shapr checks
09:47:56 <shapr> Etaoin: http://www.haskell.org//pipermail/haskell/2004-March/013750.html
09:48:11 <Etaoin> found the source
09:48:36 <Etaoin> thanks for the pointer
09:49:11 <shapr> hope it helps
09:57:11 <kosmikus> Etaoin: do you want to specify a maximum number or an exact number of elements?
09:57:25 <Etaoin> exact
09:58:36 <kosmikus> I didn't get the impression that BoundedList was designed to do that
09:59:00 <kosmikus> but maybe HaskellDB has such facilities anyway
09:59:36 <shapr> if it doesn't have the exact choice, I think bring had some code to do that.
09:59:37 <kosmikus> it's easy to define such a thing yourself, although it will be far more inconvenient to use than standard lists are, because you lose the nice syntax
10:00:11 <kosmikus> you can define a (snoc-)list on the type level and make it an instance of Functor
10:00:26 <kosmikus> data Nil x = Nil
10:00:39 <kosmikus> data Snoc xs x = Snoc (xs x) x
10:00:56 <kosmikus> instance Functor Nil where fmap f Nil = Nil
10:01:28 <kosmikus> instance Functor xs => Functor (Snoc xs) where fmap f (Snoc xs x) = Snoc (fmap f xs) (f x)
10:12:23 <shapr> hei esap 
10:12:25 <shapr> what's up?
10:12:49 <esap> nothing that interesting. Been trying to understand equivalence classes
10:14:32 <esap> And I wrote some code to implement integers with just core primitives.
10:15:12 <esap> to understand how they work.
10:17:55 <esap> the most interesting thing there is how to subtract two natural numbers.
10:37:39 <shapr> yow!
10:41:45 <shapr> hi ext 
10:42:21 <maihem> shapr: bored?
10:42:29 <shapr> maihem: maybe ;-)
10:42:59 * rt is busy but bored today.
10:43:11 * maihem is frustrated
10:45:44 <shapr> Lunar^: how's Kernel.Driver.Console?
10:48:50 <shapr> oy, I wish I had partial application in Python.
10:56:21 <Lunar^> shapr: oops... Maybe I should stop writing directly on the HTML page ?
10:57:14 <Lunar^> shapr: It's going fine, I'm struggling with Kernel.Driver.PS2, which works fine until interrupt are sent too fast (I'm trying to clean up interrupt handling a bit)
12:20:45 <amgine2> hey all
12:21:06 <amgine2> getControlText :: Id -> GUI ps (Bool,Maybe String) anyone wish to explain this ?
12:21:40 <amgine2> it returns GUI ps (Bool, Maybe String) how do i grab just the string ?
12:26:27 <amgine2> anyone alive ?
12:37:37 <stepcut> hrm
12:38:15 <stepcut> it looks like GUI is some sort of monad?
12:38:32 <stepcut> maybe you do: (_,_,str) <- getControlText someid
12:38:39 <stepcut> oh wait
12:38:45 <stepcut> i didn't look closely ;)
12:39:05 <stepcut> damn Maybe
12:39:42 <stepcut> since its a 'Maybe String' you need two possibilies, what do if there is a string, and what to do if there is not a string
12:40:36 <stepcut> (_,mStr) <- getControlText someid ; case mStr of Nothing -> "" | Just str -> str
12:41:03 <stepcut> or, if you want to live dangerously, and assume there will always be a Just string:
12:41:16 <stepcut> (_,Just str) <- getControlText someid 
12:41:40 <stepcut> but that will throw an exeception and take down the whole program if getControlText returns Nothing
12:42:36 <stepcut> hrm
12:43:00 <stepcut> or something like that...
12:45:14 <amgine2> ahhh that helped stepcut
12:45:23 <amgine2> i got it working but that looks a lot easier
12:58:58 <stepcut> hehe
12:59:52 <amgine2>  Couldn't match `String' against `(t, t1) -> t1' 
12:59:52 <amgine2>      Expected type: String 
12:59:52 <amgine2>      Inferred type: (t, t1) -> t1 
12:59:52 <amgine2>  Probable cause: `oldStatus' is applied to too few arguments in the call 
12:59:52 <amgine2>      (oldStatus (getControlText statusTxtId)) 
12:59:53 <amgine2>  In the second argument of `setControlText', namely 
12:59:55 <amgine2>      `(oldStatus (getControlText statusTxtId))' 
12:59:57 <amgine2> led, modules loaded: none.
12:59:59 <amgine2> what does it mean ?
13:00:03 <stepcut> I was looking at some of the first code I wrote in haskell the other day, and boy, was it ugly ;)
13:00:33 <SyntaxNinja> amgine2: it probably means that you didn't pass all the arguments to "oldStatus" that it needed :)
13:00:51 <amgine2> updateStatus statusTxtId msg      = setControlText statusTxtId (oldStatus (getControlText statusTxtId)) 
13:00:51 <amgine2>                       where
13:00:51 <amgine2>                          oldStatus ps (b, string) = string
13:00:52 <amgine2> yeah
13:00:58 <amgine2> but i don't see the error i made
13:01:19 <stepcut> hrm
13:01:36 <SyntaxNinja> where's the definition for oldStatus?
13:01:36 <amgine2> it's in relation to what we talked before stepcut
13:01:47 * SyntaxNinja will butt out if he's jumping into the middle of a conversation
13:02:14 <amgine2> getControlText :: Id -> GUI ps (Bool,Maybe String)
13:02:28 <amgine2> so i am just trying to extract the String
13:02:37 <fredrin> I guess this is the place to be if you need some help on functional programming :-)
13:02:45 <amgine2> correct fredrin
13:02:47 <amgine2> :)
13:02:53 <fredrin> Anyone here used the programming language Maude?
13:03:21 <fredrin> http://maude.cs.uiuc.edu/
13:03:51 <SyntaxNinja> is GUI a monad?
13:03:59 <amgine2> yes i believe so SyntaxNinja
13:04:12 * stepcut graduated from uiuc, but still hasn't heard of Maude
13:04:20 <fredrin> amgine2, Have you heard about it?
13:04:24 <amgine2> no
13:04:43 <amgine2> one functional lang. and trying to learn it is enough for me :)
13:04:50 <SyntaxNinja> so you might do something like: do t <- getControlText statusTextid; setControlText statusTxtId (oldStatus t)
13:04:58 <SyntaxNinja> something like that, you have to extract the control text from the monad
13:05:23 <amgine2> hmmm
13:06:57 <fredrin> I havent tried the Haskell but maybe they are not that different, even if Maude is state-of-the-art language. 
13:07:11 <fredrin> :)
13:07:14 <SyntaxNinja> Haskell is pretty state of the art :)
13:07:19 <fredrin> hehe
13:07:24 <amgine2> my head hurts
13:07:28 <stepcut> data    GUI a = GUI !(IOSt -> IO (a,IOSt))
13:07:47 * fredrin dont want to start a flamewar. Haskell is the best
13:07:47 <stepcut> oh wait, that's wrong
13:07:52 <SyntaxNinja> fredrin: hehe
13:07:56 <stepcut> data    GUI ps a = GUI !(IOSt ps -> IO (a,IOSt ps))
13:07:59 <stepcut> that's the one
13:08:14 <amgine2> that gives me a bigger headache
13:08:18 <amgine2> lol
13:08:20 <SyntaxNinja> so tell us about maude, fredrin
13:09:12 <fredrin> ok. 
13:09:24 <amgine2> stepcut i'm not sure how that helps me
13:09:24 <fredrin> Maude is a functional rewriting logic language
13:09:27 * SyntaxNinja has his Haskell flame-war quota filled for the day
13:09:42 <fredrin> and is object oriented
13:09:55 <stepcut> amgine2: it helps me, I needed to know that in order to sort things out
13:10:35 <fredrin> but if you really want to learn more about it you should really take a look at the webpage. http://maude.cs.uiuc.edu/
13:10:40 <amgine2> stepcut i feel this is almost a bit to much for my knowledge however if i figure it out i'll learn a few things
13:10:45 <fredrin> It's quite new
13:11:08 <fredrin> There is no books about it. 
13:12:36 <SyntaxNinja> fredrin: sounds like fun.
13:13:20 <fredrin> but anyway, here's what i'm trying to do. I'm going to write a function isPrime(N), which takes a NonZero Natural number and returns a boolean. I've got some help functions, like gdc(M, N) (greatest common divisor) modExp(m, n, p) == m^n % p  But i'm stuck 
13:13:43 <amgine2>  data    GUI ps a = GUI !(IOSt ps -> IO (a,IOSt ps)) anyone to explain this in plain english ?
13:13:47 <amgine2> what is the ! for ?
13:14:02 <fredrin> the function checks if a number is prime or not. 
13:14:32 <esap> amgine2: it makes the constructor strict.
13:14:43 <stepcut> amgine2: on page ten of the this paper they use getControlText: http://www.cs.kun.nl/~clean/download/papers/2001/achp2001-HaskellObjectIO.ps.gz
13:14:52 <fredrin> eq isPrime(M) = false if M rem 2 == 0 . 
13:14:59 <amgine2> k
13:15:02 <amgine2> examples help
13:15:03 <amgine2> brb
13:15:23 <amgine2> i'm not in linux envi, do you have an html version ?
13:15:46 <amgine2> nevermind got it
13:16:20 <stepcut> let text = fromJust (snd (getControlText inId window)) 
13:16:23 <fredrin> I guess that nobody here can help me :-( 
13:16:41 <amgine2> sorry fredrin
13:17:01 <earthy> time to solve my lack of beer
13:18:20 <amgine2> yeah beer would be nice about now
13:18:41 <amgine2> stepcut yeah i'm reading that
13:18:58 <amgine2> fromJust and snd are they build in ?
13:19:03 <stepcut> yeah
13:19:16 <amgine2> objectIO or base ?
13:19:39 <stepcut> fromJust is in the module Maybe
13:19:54 <stepcut> I think snd is in the prelude (so you don't have to do anything special for that)
13:20:04 <stepcut> snd (1,2) -- > 2
13:20:06 <amgine2> why do they have window
13:20:10 <amgine2> yeah i remember that
13:20:23 <amgine2> and what does fromJust do ?
13:20:34 <stepcut> fromJust (Just "hi") -> "hi"
13:20:42 <amgine2> ohhh
13:20:45 <stepcut> fromJust (Nothing) ->
13:20:46 <stepcut> *** Exception: Maybe.fromJust: Nothing
13:21:14 <amgine2> why is maybe class for ?
13:21:15 <amgine2> anywho
13:21:33 * esap doesn't like pure functions that raise exceptions.
13:21:37 <stepcut> well, all functions must return a value, right?
13:21:48 <amgine2> yep
13:22:07 <amgine2> and ?
13:22:10 <stepcut> well
13:22:20 * stepcut tries to think of a good example
13:22:58 <stepcut> well, what is the head of the list [] +
13:23:00 <stepcut> err
13:23:04 <stepcut> the list [] ?
13:23:12 <Cale> bottom?
13:23:33 <stepcut> yeah, its kinda undefined
13:23:42 <amgine2> ok
13:23:51 <stepcut> so, you can either through an exception (which is what haskell does by default)
13:23:52 <SyntaxNinja> find 4 [1,2,3,5,6,7] should return Nothing
13:24:12 * esap uses headM :: [a] -> Maybe a for it :-) So headM [] = Nothing and headM (a:ar) = Just a
13:24:14 <SyntaxNinja> if it's in the list, it coudl return "Just position"
13:24:27 <stepcut> but, maybe you want to handle that case in your code, so you could instead use maybe
13:24:37 <stepcut> the head of [1,2,3] would be (Just 1)
13:24:39 <amgine2> i see
13:24:44 <stepcut> the head of [] would be Nothing
13:24:58 <amgine2> or Just foo
13:25:01 <stepcut> data Mayba a = Just a | Nothing
13:25:09 <amgine2> cool
13:25:10 <stepcut> err, s/Mayba/Maybe/ 
13:25:13 <creature> stepcut - I think with empty lists, the head can be [] too. 
13:25:22 <Riastradh> stepcut, what's the point of calling head, then?
13:25:49 <stepcut> creature: no, because the type of head is -> head :: [a] -> a
13:25:58 <stepcut> but [] would be type [a]
13:26:20 <amgine2> damn it
13:26:24 <creature> Aren't [] and [[]] equivalent? 
13:26:30 <stepcut> no
13:26:33 <stepcut> one is a list
13:26:40 <stepcut> the other is a list of empty lists
13:26:43 * creature could have sworn lecturers said something about that...
13:27:02 <stepcut> :t []
13:27:02 <stepcut> [] :: forall a. [a]
13:27:07 <stepcut> :t [[]]
13:27:07 <stepcut> [[]] :: forall a. [[a]]
13:27:07 <Riastradh> creature, are you sure they weren't talking about _tuples_?
13:27:14 <Riastradh> @type ()
13:27:14 <lambdabot> () :: ()
13:27:17 <Riastradh> @type (())
13:27:18 <lambdabot> () :: ()
13:27:21 <Riastradh> @type ((()))
13:27:21 <lambdabot> () :: ()
13:27:26 <Riastradh> @type [()]
13:27:27 <lambdabot> [()] :: [()]
13:27:30 <Riastradh> @type [[]]
13:27:30 <lambdabot> [[]] :: [[a]]
13:27:31 <creature> Riastradh - entirely possible. 
13:27:33 <Riastradh> @type [[()]]
13:27:33 <lambdabot> [[()]] :: [[()]]
13:27:38 <Riastradh> @type [(())]
13:27:38 <lambdabot> [()] :: [()]
13:28:55 <SyntaxNinja> @type fromJust
13:29:08 <SyntaxNinja> @type Maybe.fromJUst
13:29:14 <SyntaxNinja> @type Maybe.fromJust
13:31:52 <amgine2> my head hurts
13:31:54 <amgine2> ahhh
13:32:55 <SyntaxNinja> amgine2: what's wrong? :)
13:33:05 <amgine2> that expample
13:33:08 <amgine2> dosen't work
13:33:10 <SyntaxNinja> too much explanation?
13:33:29 <amgine2> well i'm trying to figure it out
13:33:34 <amgine2> let me start from square one
13:33:42 <amgine2> getControlText :: Id -> GUI ps (Bool,Maybe String)
13:33:45 <amgine2> what does it return ?
13:34:24 <amgine2> GUI is a constructor right ?
13:34:28 <stepcut> yes
13:34:40 <esap> GUI in that is a type constructor
13:34:58 <amgine2> getControlText returns the result of GUI ?
13:35:01 <amgine2> i'm lost
13:35:07 <stepcut> yeah
13:35:11 <amgine2> ok
13:35:22 <amgine2> which it contains ps (Bool,Maybe String)
13:35:31 <amgine2> so getText returns ps (...) right ?
13:35:57 <stepcut> um
13:36:32 <amgine2> or is my logic way off
13:37:23 <amgine2> do { Just window <- getParentWindow inId 
13:37:23 <amgine2> ; let text = fromJust (snd (getControlText inId window))
13:37:23 <amgine2> ; error <- asyncSend you (NewLine text)
13:37:23 <amgine2> ; return () }
13:37:30 <amgine2> cuase i don't see why they have window id there
13:37:43 <stepcut> hrm
13:37:58 <stepcut> it looks like that paper and the library are not quite the same
13:38:25 <amgine2> @type getParentWindow
13:38:33 <amgine2> how do those commands go again ?
13:38:44 <stepcut> in that paper the getControlText is of type: Id -> WState -> (Bool, Maybe String)
13:38:56 <amgine2> i see
13:39:02 <amgine2> damn
13:39:08 <amgine2> getControlText :: Id -> GUI ps (Bool,Maybe String) 
13:39:11 <amgine2> what does this return than
13:39:22 <amgine2> like you said result of GUI contstructor
13:40:16 <amgine2> Just window <- getParentWindow inId   and is this legal ?
13:40:38 <stepcut> hold on
13:40:49 <amgine2> k
13:41:24 * stepcut has to go to a short meeting (5 mins)...
13:41:37 <amgine2> cool
13:44:51 <amgine2> FUCK
13:44:56 <amgine2> arrrrrghhh
13:44:59 <amgine2> i need a beer
13:45:05 <SyntaxNinja> heh
13:45:13 <SyntaxNinja> don't drink and derive ;)
13:46:18 <amgine2> lhaha ya
13:53:09 <basti_> heyas
13:53:23 <basti_> anybody know what happened to citeseer? 
13:56:15 <amgine2> YES I GOT IT
13:56:45 <SyntaxNinja> go amgine2!
13:57:06 <basti_> he got what? ;)
13:57:12 <amgine2> thanks
13:57:18 <amgine2> now that was interesting learning experience
13:57:27 <amgine2> updateStatus statusTxtId msg      = do (_,Just text) <- getControlText statusTxtId
13:57:27 <amgine2>                          setControlText statusTxtId (text ++ "/n" ++ msg)
13:57:29 <amgine2> just this to work
13:57:47 <basti_> oh
13:57:52 <amgine2> nothing big
13:57:54 <amgine2> but i'vel earned
13:57:58 <basti_> great
13:58:09 <amgine2> gui is rather almost to compex for me
13:58:17 <amgine2> but hey it's good learning
13:58:45 <basti_> ive just discovered that there are things harier than haskell
14:01:12 <amgine2> ?
14:01:19 <basti_> ;)
14:01:23 <amgine2> now if i could resize the damn dialog 
14:01:23 <amgine2> lol
14:01:40 <basti_> ui's suck
14:02:00 <amgine2> ?
14:02:04 <amgine2> it's fun :)
14:02:08 <basti_> -g-
14:04:09 <amgine2> my head hurts again
14:04:11 <amgine2> damn it lol
14:11:43 <amgine2> YES
14:11:44 <amgine2> i rule
14:11:45 <amgine2> :)
14:12:54 <SyntaxNinja> gogo!!
14:12:55 * SyntaxNinja goes
14:23:02 <amgine2> is there an easy way to get current windows resolution ?
14:49:46 <amgine2> useless
14:49:49 <amgine2> haskell gui is painful
14:52:13 <Cale> what gui are you using?
15:08:15 <amgine2> what is the command for new line ? \n
15:08:40 <tic> that's the ascii code of 10, escaped.
15:08:50 <amgine2> what is the code for new line ?
15:09:28 <amgine2> in haskell
15:09:30 <Cale> that will work
15:09:39 <amgine2> \n ?
15:09:42 <Cale> yeah
15:09:46 <amgine2> DAMN IT
15:09:50 <amgine2> AHHHHH
15:09:57 <amgine2> i give up
15:10:12 <Cale> what are you trying to do?
15:10:39 <amgine2> using a edittext
15:10:47 <amgine2> but when i pass it a string "foo \n foo" 
15:10:54 <amgine2> it just dsiplay a wierd character
15:11:02 <amgine2> in objecIO
15:11:08 <amgine2> EditControl function
15:11:55 <Cale> this is wxhaskell?
15:12:03 <amgine2> ?
15:12:20 <Cale> what library are you using?
15:12:23 <amgine2> yeah
15:12:30 <amgine2> it's a library that comes with haskell
15:12:31 <amgine2> ghc
15:12:38 <amgine2> called ObjectIO
15:13:14 <amgine2> that just puzzles me like hell now
15:13:16 <Cale> ah, the thing that was ported from Clean, hmm... let me have a look
15:13:26 <amgine2> ok
15:13:27 <amgine2> brb
15:13:31 <amgine2> time to grab a sandwitch
15:18:12 <ham> hiho
15:22:05 <shapr> oy
15:22:36 <ham> :)
15:30:56 <shapr> I thought they gave up on ObjectIO in favor of wxHaskell?
15:31:32 <shapr> basti|-: citeseer has moved
15:32:05 <shapr> princeton I think
15:32:48 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental","new HC&A Report - http://www.haskell.org/communities/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html", "Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/"]' by shapr
15:33:29 <ham> what?
15:33:35 <ham> since when?
15:34:14 <shapr> at least several days, up to several weeks.
15:45:20 <amgine2> shapr me ?
15:45:28 <amgine2> what is wxHaskell ?
15:46:10 <Cale> wxHaskell is a fairly nice gui libr...
15:46:24 <Cale> oh well.
15:46:33 <Cale> ah
15:46:39 <Cale> wxHaskell is a fairly nice gui library
15:46:59 <Cale> http://wxhaskell.sourceforge.net/
15:47:45 <amgine2> it's native hmmm
15:49:22 <Cale> I found it pretty easy to get something small done with it.
15:49:31 <amgine2> interesting
15:49:32 <amgine2> brb
15:49:34 <amgine2> reading on it
15:50:42 <amgine2> cool i think it is easy
15:51:07 <Cale> cool
15:52:44 <amgine2> any of use this ?
15:52:45 <amgine2> http://www.cs.uu.nl/research/projects/proxima
15:55:01 <shapr> crap, I killed ScannedInAvian.org
15:58:03 <SamB> shapr: how killed is it?
15:58:28 <shapr> SamB: killed enough that I'll have to take the bus over to my ISP and fix it.
15:58:54 <amgine2> what is the www for ?
15:59:03 <SamB> what did you do to it?
15:59:08 <shapr> amgine2: I don't use proxima, but I've been trying to find an excuse to play with it.
15:59:19 <shapr> SamB: I installed a new kernel image that it didn't like much.
15:59:45 <shapr> amgine2: which www?
16:02:28 <shapr> is this a general questions? what's the purpose of the world wide web? I could make any number of humorous replies to that.
16:02:41 <whee> porn.
16:02:47 <SamB> to kill gopher
16:02:52 <amgine2> crap
16:03:09 <Riastradh> Money.
16:03:33 <Lemmih> more porn.
16:03:40 * shapr laughs
16:03:52 <shapr> CODE!
16:04:20 <amgine2> Cale it won't locate the wx class
16:04:21 <amgine2> damn it
16:04:27 <amgine2> i hate when the install dosen't work
16:04:34 <shapr> me too!
16:05:03 <Cale> you can't -package wx ?
16:05:21 <amgine2> i'm in ghci
16:05:25 <amgine2> and it gives me this error
16:05:41 <amgine2> Can't find module `Graphics.UI.WX'
16:05:42 <amgine2> (use -v to see a list of the files searched for)
16:05:59 <Cale> right, did you start it with ghci -package wx ?
16:06:17 <amgine2> no
16:06:25 <Cale> try that
16:06:40 <amgine2> how come i don't need to to that for the included pkgs ?
16:06:46 <amgine2> like objectIO and such
16:08:34 <Cale> probably your ghc setup has them set to autoload.
16:08:43 <amgine2> i see
16:08:48 <amgine2> that would make sense
16:09:22 <Cale> /usr/lib/ghc-6.2/package.conf I think is the file that describes the packages you have.
16:12:55 <amgine2> ohhh cool
16:13:02 <amgine2> ahhh reminds me of linux days :)
16:13:24 <Lemmih> Can someone guide me though a hdirect installation on a Linux box with ghc6.2?
16:15:30 <Lemmih> Well 'guide' is probably the wrong word.
16:18:29 <Lemmih> I get this error when I try to compile it: "Digraph.lhs: can't locate import `ST'"
16:35:15 <_joey_> has anyone compiled ghc 6.2 version on NetBSD?
16:36:00 <rt> i did it out of ports on freebsd.
16:37:40 <_joey_> reports an error in Unicode.hsc line 126
16:38:10 <_joey_> unfortunately, this version is not available in NetBSD's pkgsrc
16:38:17 <_joey_> only 5.04
16:41:29 <rt> hmmm.   
16:41:34 <rt> The port has this line....
16:42:03 <rt> -#if (defined(HAVE_WCTYPE_H) && HAVE_ISWSPACE) || mingw32_TARGET_OS
16:42:03 <rt> +#if (defined(HAVE_WCTYPE_H) && HAVE_ISWSPACE && defined(HTYPE_WINT_T)) || mingw32_TARGET_OS
16:42:45 <rt> the change is at line 122 in Unicode.hsc
17:04:02 <_joey_> rt: what does install-sh do?
17:04:39 <_joey_> I can't afford to spend anymnore time installing it, and the maintainer of tha packages is keeping quiet:<
17:45:28 <shapr> hej chovy, r du en del av HaskellDB?
17:45:47 <chovy> say what?
17:45:54 <shapr> guess not
17:46:03 <chovy> what's the haskeldb?
17:46:22 <shapr> it's a Haskell database interface thingy.
17:46:47 <shapr> it's really cool, it more directly exposes the set theory ops of SQL databases.
17:46:58 <shapr> http://haskelldb.sf.net/
17:47:31 <shapr> Are you learning Haskell?
17:50:20 <chovy> i'm looking for a technology to write a search engine. 
17:50:45 <chovy> well, i know what technology i want, i just need something to read about algorithms
17:51:10 <shapr> inverted indices and the like?
17:53:12 <chovy> some sort or ranking type of algorithm
17:53:24 <chovy> i plan on writing a search engine companies can use on their own sites
17:53:47 <chovy> and maybe testing it on the web in general, although i don't really have those types of resources to crawl the web.
17:54:07 <chovy> my db will fill up in a few days
17:54:14 <chovy> brb
17:59:33 <chovy> back
22:05:46 * DeezNuts is sad that is platform is unsupported
22:06:07 <Riastradh> Not many people use Linux on PPC.
22:06:08 <skew> what is "is platform"?
22:06:17 <Riastradh> skew, he probably meant 'his,' not 'is.'
22:06:39 <skew> I thought I was leaving that possiblity open...
22:09:57 <skew> There's no GHC for PPC?
22:10:24 <Riastradh> There is, but not for Linux on PPC.
22:10:52 <skew> If there's already a code generator, shouldn't it be easy to fix?
22:11:07 <Riastradh> Well, if so, why don't you do it?
22:11:19 <skew> because I don't use Linux on PPC.
22:11:48 <skew> and have other things I would do first given copious free time
22:12:06 <DeezNuts> I tried
22:12:09 <DeezNuts> but it didn't work
22:12:39 <DeezNuts> and i also have other things to do given copious amounts of free time
23:55:46 <SamB> DeezNuts: what happened?
23:58:22 <DeezNuts> SamB: wouldn't compile even though I installed a prebuilt older version
