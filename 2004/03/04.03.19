00:00:11 <evilcthul> i've been to sweden and gothemburg.. (family is from there)
00:00:15 <shapr> oh, cool
00:00:27 <evilcthul> stockholm i mean not sweden
00:00:33 <shapr> anyways, I shouldn't distract you from your productive code discussion
00:00:46 <evilcthul> sustroming is the most disgusting thing in the world ;)
00:01:00 <shapr> I'll report the IDE errors to the sysadmin and make a backup of the wiki
00:01:07 <evilcthul> filmmjolk is plain weird too
00:01:20 <evilcthul> but anyway i'll try your suggestion cale
00:03:02 <evilcthul> cale the output type of putStrLn doesn't match with [String]
00:03:37 <evilcthul> i tried to add on show..
00:10:21 <shapr> evilcthul: the reason I learn/breathe Haskell is that I think I can develop software with less bugs in less time than with the other languages I've tried.
00:11:15 <evilcthul> i dont live nor breathe it atm but i've been told to use it ;)
00:11:23 <evilcthul> and it's sort of growing on me.. less annoying bug hunting than Cpp
00:11:31 <shapr> yah, I agree with that.
00:18:28 <evilcthul> nearly got the take thing working
00:20:46 <Cale> I've started to write a raytracer in Haskell.
00:24:57 <evilcthul> have any windows gui probs been written in haskell?
00:25:05 <evilcthul> probs = progs
00:25:11 <shapr> windows gui probs are written in every language ;-)
00:25:56 <shapr> wxWidgets the toolset formerly known as wxWindows is the recommend binding
00:26:07 <shapr> from what I've heard, it works equally well on Linux and Win32
00:26:13 <evilcthul> i'll give it a shot
00:26:23 <evilcthul> i know my big project is writing a train control program in haskell to control a model train set
00:26:24 <Jerub> shit
00:26:24 <shapr> http://wxHaskell.sf.net
00:26:28 <evilcthul> that's what we're working towards where we are..
00:26:28 <shapr> oh, neat
00:26:31 <Jerub> I just wrote a simple parser using parsec. I love it.
00:26:35 <shapr> Jerub: right on!
00:26:46 * shapr high5s Jerub 
00:27:02 <blackdog> hey shapr
00:27:04 <Jerub> I'm sure I'm going to hate expressions with infix operators, but I'm tempted to just not implement that.
00:27:10 <shapr> g'day mrak, wassup?
00:27:14 <Jerub> add(left, right) is good enough for anybody.
00:27:21 <blackdog> now that wxHaskell's on topic, has anyone noticed that it produces ****ing massive executables?
00:27:22 <Cale> I love Parsec too
00:27:42 <blackdog> shapr: the sky, the boidies, my blood pressure
00:28:01 <shapr> heh
00:28:10 <blackdog> but that's from sysadminning. haskell always makes the pain go away.
00:28:40 <Cale> Does wxHaskell link statically?
00:28:46 <evilcthul> i was trying to look at apl code
00:28:47 <blackdog> Jerub: infix operators are actually pretty easy with Parsec - they've got a combinator for it. read the intro...
00:28:55 <evilcthul> apl looks like it'll easily raise your blood pressure ;)
00:29:09 <blackdog> ecilcthul: write-only, hm?
00:29:17 <evilcthul> lecturer was telling us how he had to debug some 4 page apl program.. and couldn't work it out and ended up rewriting the whole thing
00:29:44 <evilcthul> write only?
00:29:59 <shapr> I wish Parsec had builtin support for postfix
00:30:18 <shapr> yah, write-once read-never, what I say about Perl
00:30:19 <Cale> well, each character has meaning in APL, and it uses a messed up character set
00:30:20 <blackdog> Cale: not sure, actually. I should check that out.
00:30:30 <shapr> greetings fdvgsd 
00:30:30 <fdvgsd> d
00:30:35 <fdvgsd> hello
00:30:48 <evilcthul> hey bd what course are you studying?
00:30:56 <blackdog> ok, i'm out. flying visit etc... catch you later.
00:31:03 <shapr> flying visit?
00:31:08 <shapr> you gonna fly over and visit me?
00:31:45 <shapr> ubccoolboy: are you looking for Haskell info?
00:31:50 <ubccoolboy> yes i am
00:32:04 <evilcthul> later bd
00:32:13 <ubccoolboy> im trying to make a program to pronounce numbers, but have no idea to go about doing it
00:32:27 <shapr> oh this sounds familiar
00:32:41 <Jerub> ubccoolboy: always start with simple rules.
00:32:48 <evilcthul> lol
00:33:06 <ubccoolboy> yeah i do
00:33:15 <ubccoolboy> i can only do it upto like 20
00:33:25 <ubccoolboy> but i have to do it to like a few billion haha
00:33:57 <ubccoolboy> would i be looking at creating some kind of list?
00:35:50 <evilcthul> i'm out..
00:35:55 <shapr> re reltuk 
00:36:25 <ubccoolboy> ?
00:36:44 <Cale> ubccoolboy: think about how you pronounce the numbers
00:37:00 <reltuk> hello  :)
00:37:22 <Cale> What sort of rules do you use? What information is involved? What is a convenient way to store/access that information?
00:37:55 <ubccoolboy> tens, hundreds, thousands
00:39:16 <ubccoolboy> how would i be able to extract 20 and 5 from a list, so that it prints twenty five
00:39:25 <Cale> When you pronounce a number, like, say 4,357,300,889, what goes on in your head, and what ends up being said as a result?
00:39:58 <ubccoolboy> i see how many numbers there are
00:40:21 <Jerub> ubccoolboy: start at the end.
00:40:29 <Jerub> ubccoolboy: the last triple there, how do you say that?
00:40:32 <reltuk> are we writing a function that takes a string and gives you a the number in the string in a Num type?
00:40:45 <Cale> reltuk: other way around
00:40:49 <ubccoolboy> eight hundred eighty nine
00:40:52 <reltuk> oh ok
00:41:16 <Jerub> ubccoolboy: okay, now all the other triples, you say them the same way, with hundreds tens and ones just prefaced by 'thousand', 'million' and 'billion'.
00:41:27 <Jerub> ubccoolboy: so lets just ignore anything greater than 1000 for the moment.
00:41:38 <ubccoolboy> okay
00:41:39 <Jerub> ubccoolboy: what are your inputs? a string or a number?
00:41:50 <ubccoolboy> a number
00:41:52 <ubccoolboy> Integer
00:42:07 <ubccoolboy> and "and" is allowed to be ignored
00:42:42 <ubccoolboy> ie eight hundred and eighty nine is just "eight hundred eighty nine"
00:42:59 <Jerub> ubccoolboy: okay, now we have a bit of fun. do you have something that converts 1->9 into a string? to use for the hundreds column?
00:43:26 <ubccoolboy> you mean like a function
00:43:27 <ubccoolboy> ?
00:43:29 <Jerub> yeah
00:43:45 <ubccoolboy> yeah, but ium not sure what you mean to use for hundreds
00:44:13 <ubccoolboy> pronounce :: Int -> String
00:44:13 <ubccoolboy> pronounce x
00:44:13 <ubccoolboy>   |number == 0 = “zero”
00:44:13 <ubccoolboy>   |number == 1 = “one”         
00:44:13 <ubccoolboy>   |number == 2 = “two”
00:44:26 <ubccoolboy> etc
00:45:00 <ubccoolboy> wouldnt i also have to define numbers such as thirteen, and twelve
00:45:31 <Cale> a more compact way to do that might store the numbers from 0 to 19 in a list
00:46:42 <ubccoolboy> yes, but im not sure how to go extract the right numbers from the list
00:48:33 <Cale> you might look into the !! operator
00:49:47 * Cale is away: sleep.
00:50:30 <ubccoolboy> oh yeah, thnx cale
00:50:37 <Jerub> crap.
00:50:56 <Jerub> parsec assumes that strings and chars are like "foo" and 'b','a','r'.
00:52:27 <ubccoolboy> cale, but isnt that operator used for input
00:52:45 <ubccoolboy> can i use that in my program, because im suppose to just type in the number
01:00:00 <shapr> there are a lot of strange network problems going around lately, I'm seeing some weird TCP errors on both haskell.org and a german server I have access to
01:00:41 <shapr> I wonder if there's a new TCP/IP exploi
01:00:42 <shapr> t
01:02:52 <Jerub> okay, rape and paste.
01:05:53 <shapr> bonjour kowey 
01:06:21 <kowey> morning shapr, morning all
01:12:27 <ubccoolboy> can anyone tell me if this is allowed in haskell
01:12:27 <ubccoolboy> Type NumberList = [(Int = String)]
01:18:25 <kosmikus> ubccoolboy: no, it's not allowed -- what is that supposed to mean?
01:19:39 <ubccoolboy> im trying to make a list, of integers and how you say them
01:19:47 <ubccoolboy> and then extract them to say larger numbers
01:20:10 <kosmikus> okay, so you want to declare a type synonym
01:20:15 <kosmikus> you can do that with
01:20:20 <kosmikus> type NumberList = ...
01:20:30 <kosmikus> with lowercase "t"
01:20:45 <kosmikus> on the right hand side, the occurrence of "=" is the problem
01:21:25 <ubccoolboy> type NumberList = [(Int, String)]
01:21:32 <kosmikus> looks better
01:21:37 <ubccoolboy> but does this mean int = string
01:21:40 <ubccoolboy> in the list
01:22:15 <kosmikus> what do you mean by "int = string"?
01:22:48 <Jerub> yay!
01:22:53 <Jerub> this absolutely rocks.
01:23:04 <Jerub> I just have to figure out how to emit bytecode now ;)
01:23:10 <ubccoolboy> i mean 1 = "one"
01:23:14 <Jerub> or some form of rudimentary asm.
01:23:34 <ubccoolboy> so in my program when i type in 1 , it will return one
01:23:56 <kosmikus> ubccoolboy: that's something you have to program, not to express on the type level
01:25:33 <ubccoolboy> yes, so when i refer to my list in the program, will it be able to return the associated string
01:25:36 * Jerub goes to have a break.
01:27:18 <kosmikus> ubccoolboy: if you build a value of type NumberList, then you can lookup the string that is associated with a certain Int, yes
01:44:24 <shapr> greetz Si\ 
01:44:35 <Si\> hello shapr, I have good news for you
01:44:40 <shapr> what's that?
01:44:44 * shapr bounces expectantly
01:45:01 <Si\> my supervisor wants me to release a Beta version of the HAIFA Core with SOAP
01:45:02 <Si\> soon
01:45:06 <shapr> w00h00!
01:45:37 <shapr> that's great, I hope you won't mind if I rip out the SOAP code and write a google plugin for lambdabot 
01:45:42 <Si\> the bad news is that I'm currently in the middle of ripping apart how the type mappers work and so it could take a little time
01:45:57 <Si\> yes, I have tested google out and it does work
01:46:07 <shapr> what do you think? one week? two months? one day?
01:46:14 <Si\> but only using the automarshaller and that doesn't work atm
01:46:14 <shapr> oh that's great
01:46:24 <Si\> a week tops
01:46:30 <shapr> sounds great to me
01:46:46 <Si\> but everyone who uses it must give me polite feedback
01:47:03 * shapr grins
01:47:07 <Si\> and I can't accept patches into the main tree until June unfortunately
01:47:17 <shapr> I can promise to give polite feedback
01:47:43 <Si\> anyway now it isn't all cloak and dagger I can explain how it works and generally what it is
01:47:47 <shapr> yay!
01:48:21 <Si\> Basically HAIFA is designed to be a framework for conducting multiple types of interoperability over textual protocols
01:48:58 <shapr> ok
01:49:09 <Si\> it provides a common call structure for converting to and from the various messaging protocols
01:49:32 <Si\> where a Call is a name and a set of parameters
01:50:11 <Si\> once a parser and a converter has been written for a protocol, it can be used server side within HAIFA
01:50:58 <Si\> so you can create a HAIFA Application, which is effectively a tbz2 with a bunch of Haskell objects and some meta information
01:51:54 <Si\> then you have a container (which atm doesn't exist) which sits on a TCP port and converts requests into HAIFA Calls and fires them at the appropriate plugin
01:52:33 <Si\> the plugin returns a Call, which is then converted back to a Response and set back to the Web Server
01:52:41 <Si\> somewhat like Tomcat
01:52:49 <shapr> yah, I see the similarities
01:54:25 <shapr> sounds a lot like J2EE
01:54:27 <Si\> now HAIFA itself provides a Marshaller for Call Data which converts the parameters from within a Call (since they are store in a raw tree to start with) to and from real Data Items in Haskell
01:55:08 <shapr> are you using Data.Generics to do that?
01:55:23 <Si\> and it also provides a TypeMapper (which I've mentioned) to convert local names within namespaces to Haskell types
01:55:42 <Si\> sadly not as such
01:55:46 <shapr> a local name within a namespace is an XML tag, right?
01:55:53 <Si\> just so
01:56:14 <shapr> ok
01:56:26 <shapr> sounds really cool
01:57:00 <Si\> the Marshaller just takes a value (which can either be simple or complex) and the if complex marshals the constituent parts or if simple simply does a read
01:57:20 <shapr> makes sense
01:57:29 <Si\> the whole system relies on the fact that the actual functions are co-erced so that Marshal can figure out what the types should be
01:58:17 <shapr> sounds like it'll be a breeze to use, as long as the user gives the correct type sig to one or two significant functions in his code
01:58:50 <Si\> anyway, I've got a lecture, I'll aim to try and get a Beta version out by the beginning of next week, but it'll only be client side atm because HAC doesn't exist yet
01:59:05 <Si\> cu l8r
01:59:13 <shapr> cya
02:31:47 <Jerub> I've never really done any study of emiting machine code/etc from a parser, but I know lots about parsers, any idea where I should look for info?
02:32:02 <alanl> does anyone know of a stats library for haskell (however basic)?
02:33:47 <shapr> I don't, but I've seen occasional discussions of statistics go across the mailing lists, something might already exist
02:37:12 <Jerub> shapr: I'm attempting to implement a language with a php-like grammar but without its messy implementation.
02:39:18 <shapr> good luck
02:39:18 * shapr grins
02:40:59 <Jerub> I'm instead going to have a DIFFERENT messy implementation ;)
03:06:41 <ubccoolboy> hello
03:06:57 <shapr> hi
03:07:37 <ubccoolboy> hey shapr, is it possible to use the !! operator in written program
03:07:52 <shapr> it is
03:08:54 <ubccoolboy> -- list
03:08:55 <ubccoolboy> list = [(1, "one"), (2, "two")]
03:08:55 <ubccoolboy> -- Pronounce
03:08:55 <ubccoolboy> pronounce :: Int -> String
03:08:55 <ubccoolboy> pronounce number 
03:08:55 <ubccoolboy>   |number = list !! number 
03:09:09 <ubccoolboy> is this possible
03:09:12 <ubccoolboy> not that it works
03:09:56 <shapr> have you tried using that in Hugs or GHCi?
03:09:57 <kosmikus> ubccoolboy: why the "| number = " part?
03:10:22 <ubccoolboy> hmm
03:11:49 <shapr> I usually try out the smallest parts interactively, then when they work, I write them into the file, that way I can slowly build up pieces that work
03:12:09 <ubccoolboy> ill try that
03:12:11 <shapr> for example, if you have hugs or GHCi open, you can try [1,2,3] !! 1
03:12:16 <shapr> do you get a result?
03:12:42 <ubccoolboy> yes 2
03:13:29 <shapr> what about [1,2,3] !! 0
03:13:46 <ubccoolboy> yep 1
03:13:56 <shapr> so, do you see how the !! operator works on a list?
03:14:13 <ubccoolboy> yes i do
03:14:53 <ubccoolboy> -- list
03:14:53 <ubccoolboy> list = [one, two]
03:14:53 <ubccoolboy> -- Pronounce
03:14:53 <ubccoolboy> pronounce :: Int -> String
03:14:53 <ubccoolboy> pronounce number = list !! number 
03:15:05 <ubccoolboy> but now it says undefined variable "one"
03:15:28 <shapr> that's because you have to pass in the list
03:15:37 <shapr> oh wait
03:15:37 <shapr> no
03:15:41 <ubccoolboy> pass in the list?
03:15:43 <kosmikus> because you wrote  one , and not "one"
03:15:47 <ubccoolboy> oh
03:15:48 <shapr> that's because your list refers to a variable named one
03:15:54 <kosmikus> one without quotes is a variable, "one" is a string
03:16:32 <ubccoolboy> thhnx for that
03:19:45 <Si> sorry I left in a hurry shapr, I suddenly realised a had a lecture 2 minutes ago
03:19:56 <shapr> no worries
03:22:07 <shapr> I figured you just had to run to class
03:40:04 <ubccoolboy> hi again
03:40:51 <ubccoolboy> it says i have a syntax error in declaration, unexpected ;
03:40:53 <ubccoolboy> in this line
03:40:54 <ubccoolboy> fortens :: Eq a => Int -> [String] -> String
03:41:11 <saz> look above it?
03:41:15 <ubccoolboy> "possibly due to bad layout"
03:42:04 <shapr> why is it so hard to program for non-cache-coherent NUMA?
03:42:53 <ubccoolboy> ?
03:43:01 <ubccoolboy> this is what i tried to do
03:43:02 <ubccoolboy> -- fortens
03:43:02 <ubccoolboy> fortens :: Eq Int => Int -> [String] -> String
03:43:02 <ubccoolboy> fortens number (x:xs) |number == x = x
03:43:02 <ubccoolboy>                       |otherwise = fortens number xs
03:43:02 <ubccoolboy>                       |where (x:xs) = tens 
03:43:15 <ubccoolboy> tens = ["twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
03:43:20 <saz> ok
03:43:28 <saz> that where is in the wrong place
03:43:42 <saz> and i don't know why you have "Eq Int => " there
03:43:51 <ubccoolboy> what should i have?
03:43:56 <saz> don't use stuff you don't understand
03:44:03 <saz> no need for that bit, take it out
03:44:21 <saz> and look up a function with a where statment in it, and see how it's laid out
03:44:54 <ubccoolboy> okay
03:46:10 <saz> and.. what's that function meant to do?
03:46:33 <saz> think about the type of x and the type of number
03:46:52 <ubccoolboy> pronouce "twenty"
03:46:55 <ubccoolboy> when i input 20
03:47:04 <ubccoolboy> i can use the !! operator
03:47:08 <ubccoolboy> for 1 - 19
03:47:38 <ubccoolboy> but i dont know how i would go about using that for tens
03:48:10 <saz> eh?
03:48:20 <saz> why can't you use the !! operator?
03:48:27 <saz> and, you haven't answered my question about types
03:49:15 <ubccoolboy> the type of x is string
03:49:23 <ubccoolboy> type of number is Integer
03:49:53 <saz> can you compare a string with an int, with == ?
03:51:34 <ubccoolboy> dont think so
03:51:50 <saz> so why are you doing it?
03:52:11 <ubccoolboy> i have no idea, i tried it another way
03:52:11 <ubccoolboy> fortens :: Int -> String
03:52:11 <ubccoolboy> fortens number
03:52:11 <ubccoolboy>   |number == 20 = tens !! 0
03:52:11 <ubccoolboy>   |number == [30, 40..90] = tens !! (number - (number - 1))
03:52:20 <ubccoolboy> but still no success
03:52:43 <saz> think about what you're doing there
03:52:53 <saz> number == [30, 40..90] 
03:53:00 <saz> what are the types on each side of == ?
03:53:14 <ubccoolboy> oh
03:53:40 <ubccoolboy> how would i make it 30 - 90, without putting all of them down
03:53:51 <saz> elem ?
03:55:07 <ubccoolboy> but when i use the elem would i have to put in the list as well
03:55:27 <ubccoolboy> ie elem "strange days" ["the matrix", "strange day"]
03:57:17 <saz> er..
03:58:01 <ubccoolboy> and you said i couldnt compare number with the list of strings
03:59:27 <saz> design your solution before starting to hack on it
04:22:07 <Jerub> amazing.
04:22:34 <Jerub> I guess this is what happens when kids are expected to solve things using programming before they're taught programming.
04:22:38 <Jerub> ;)
04:23:04 <saz> heh
04:23:21 <saz> yeah
04:23:42 <saz> he is a lot more confused than most
04:23:49 <saz> (thankfully)
08:28:48 <shapr> greetings!
08:30:11 <Lunar^> shapr: hi
08:33:35 <shapr> bonjour Lunar^ 
08:35:03 * SyntaxLaptop pokes shapr
08:35:06 * SyntaxLaptop is taking a day off today
08:35:27 <shapr> y0 SyntaxLaptop, wassup?
08:36:34 <SyntaxLaptop> nomuch. i'm going to make some breakfast.
08:38:58 <Igloo> What's the word for things that only matter for looking pretty, not semantics?
08:39:10 <Smerdyakov> Syntactic sugar?
08:39:36 <Igloo> No, I mean for how "2 * 3" looks better than "2*3"
08:39:55 <Smerdyakov> "Coding conventions"?
08:40:08 <Igloo> Ah, aesthetic
08:40:20 <Smerdyakov> Oh. You didn't mean a programming-specific term. :)
08:40:47 <Igloo> No, sorry, should have said  :-
08:40:47 <Igloo> )
08:44:51 <bring> cosmetic?
08:45:51 <Si\> Is the standard DynamicLinker module Thread-Safe?
08:46:36 <shapr> "The PathLoader is a thread-safe high-level module" from http://www.dtek.chalmers.se/~d00ram/dynamic/
08:46:43 <Igloo> Oh, I think that's what I was really looking for - ta!
08:47:06 <shapr> Si\: that implies that DynamicLinker by itself isn't
08:47:07 <Si\> yes, I know the PathLoader is thread-safe, but is the DynamicLinker?
08:47:13 <Si\> oh ok
08:47:28 <shapr> well, you could check the source of PathLoader and see if some explicit thread-safety stuff is done
08:47:33 <shapr> that may clear things up
08:51:07 <Si\> what sort of things am I looking for?
08:51:16 <shapr> I don't know :-)
08:51:27 <shapr> I would guess MVar stuff maybe?
08:52:06 <Si\> nah nothing to do with MVar
08:52:44 <Si\> ah no, I'm wrong
08:53:12 <shapr> you could send an email to Hampus and ask him about thread-safety in DynamicLinker
08:53:15 <shapr> or ask ozone if he's around
08:54:41 <Si\> Who wrote the runtime loader for HWS-WP?
08:54:49 <shapr> ozone: 
08:55:17 <Si\> cuz that's gotta be thread safe
08:55:18 <shapr> actually, to get the entire ancestry straight, someone wrote GHCi
08:55:41 <shapr> then ozone cut it out into the first DynamicLinker, then Hampus made his improved version
08:56:02 <shapr> hws-wp, lambdabot, and some others use ozone's code (with some modifications)
08:57:56 <Si\> The way that HAC will work is the application repository will be stored in an MVar, and then this'll be queried by request threads
08:58:56 <Si\> mind you, I suppose what I ought to have is a HashTable of MVars stored in an MVar, that way each two different apps could be run simultaneously
08:59:44 <Si\> and the Governor thread can refresh the repo every minute or so
09:28:56 * shapr reads the HaskellDB test code repeatedly
09:33:17 <shapr> hi det 
09:33:25 <det> hello
09:33:29 <shapr> what's going on?
09:34:11 <det> I am in-between sleep, general sleepyness confusion :)
09:34:57 <det> I think I may be tired
09:35:23 <shapr> ah
09:36:41 <det> what are you doing these days ?
09:36:51 <shapr> at the moment I'm playing with HaskellDB
09:37:00 <shapr> hi marijne 
09:37:18 <shapr> I'd like to put the @fact plugin back into lambdabot, but it won't be cool unless it's using HaskellDB
09:37:26 <marijne> hello!
09:37:39 <shapr> what can we do for you?
09:38:37 <marijne> oh i have no specific question, i've just started to learn haskell and have been mightily impressed
09:38:54 <shapr> det: I'd like to write up something that shows how HaskellDB is an unwrapper, in that it exposes Set ops directly, and is mostly database backend agnostic
09:39:11 <shapr> this is a good place to continue the learning process
09:39:20 <shapr> have you downloaded GHC and/or Hugs?
09:39:32 <shapr> have you seed the learning page mentioned in the channel topic?
09:39:37 <shapr> er "seen" not seed
09:40:36 <marijne> i've been using GHC, and following a rather nice tutorial
09:41:26 <marijne> http://www.isi.edu/~hdaume/htut/tutorial.pdf
09:41:37 <shapr> yah, that is a nice tutorial
09:41:45 <marijne> the "Gentle Introduction" scared me off for about a week
09:41:52 <shapr> brickbat, isn't it?
09:42:06 <shapr> well, it's for those who have prior FP experience
09:42:29 <shapr> some people have no trouble with the Gentro Intro, but I couldn't handle it myself.
09:42:43 <shapr> I learned from Thompson's book, and lots of discussion here on #haskell
09:43:41 <marijne> i'm doing a formal methods course at university (VDM), and haskell seems to fit in very nicely with what i'm learning there
09:44:06 <shapr> VDM?
09:44:09 <shapr> is that a university?
09:44:42 <shapr> yes, I also think Haskell fits together well with formal methods.
09:45:13 <marijne> heh, no... vdm is the vienna development method
09:45:53 <shapr> oh, neat
09:46:46 <marijne> it's interesting to be able to say what you want something to do, rather than how... and actually have an exectuable at the end of it all... if you see what i mean
09:47:22 <shapr> yes, I see
09:47:31 <shapr> VDM looks nifty
09:47:43 <shapr> has anyone implemented it in Haskell?
09:48:23 <shapr> ah, I see they have
09:48:31 <shapr> http://www.cs.tcd.ie/Andrew.Butterfield/IrishVDM/
09:48:44 <marijne> it does seem that one could translate a vdm spec directly to haskell
09:48:57 <shapr> http://www.cs.tcd.ie/Andrew.Butterfield/IrishVDM/software/IrishVDM-in-Haskell/ivdm-haskell-src-2004-01-19.zip
09:48:58 <Smerdyakov> I think it's a little unfair to say that Haskell is "what, not how" but C isn't.
09:49:13 <shapr> true, you have to have some of both
09:49:31 * SyntaxLaptop notes that aetion is still hammering away at the yampa people to release their code, even when I'm taking a day off ;)
09:49:42 <shapr> SyntaxLaptop: should I send another encouraging email?
09:50:07 <shapr> a Yampa + SDL lib would rock
09:50:09 <SyntaxLaptop> nah. read the list, looks like things might really be happeneing.
09:50:20 <Igloo> Don't suppose any wx people are around?
09:50:36 * shapr points at wxIgloo
09:50:44 <SyntaxLaptop> did I ever tell you that I worked for the university and they rpomised to release my work opensource but never did; turned out that they didn't have the authority to do so or to make that promise.  that's why I don't actually put much stock in their promises.
09:50:57 <shapr> that sucks
09:51:13 <SyntaxLaptop> actually, they have released the code, I should say, but it's not quite free yet.
09:51:24 <shapr> I worked for widian.com, and they said they'd open source I wrote if they didn't use it.
09:51:29 <SyntaxLaptop> s/the university/ohio state
09:51:36 <shapr> they didn't, of course.
09:51:37 <SyntaxLaptop> wxigloo woo
09:51:45 <SyntaxLaptop> hi Smerdyakov; welcome back.
09:51:49 <Smerdyakov> Hi SyntaxLaptop.
09:55:18 <shapr> marijne: so, do you have any questions?
09:56:58 <shapr> any other HaskellDB users around?
09:57:03 <Smerdyakov> I think he already said he has no questions.
09:57:19 <marijne> happily, everything is well so far, so no :)
09:57:30 <shapr> ok, if you come up with some questions, feel free to ask
09:57:47 * Igloo grabs the source - hmm, it certainly /looks/ like SetDefault should do something
09:58:37 <Smerdyakov> Does anyone here know anything about starting and running a cooperative?
10:05:32 * shapr bounces happily
10:05:42 <shapr> yay, I can query with HaskellDB
10:12:13 <Si\> the way I get around University problems is to release under the GPL before they can decide that I'm not allowed...
10:12:47 * shapr grins
10:12:50 <shapr> good idea
10:13:28 <Si\> actually I don't think they'd stop me anyway, because all the libraries I'm using are FOSS
10:14:46 <bring> I do the same
10:14:50 <marijne> surely if you work for the university then they own rights to the code?
10:15:02 <bring> best thing not to ask them
10:15:10 <SyntaxLaptop> ther'es a darcs wiki, right?
10:15:18 <shapr> collabserve.com/darcs
10:15:27 <SyntaxLaptop> has anyone put use cases for darcs that are compelling arguments for it over CVS?
10:15:33 <reltuk> I don't understand how monads are simulated state as opposed to real state...
10:15:50 <bring> I'm a student though, I don't think swedish universities own student's work, but in the US they seem to do that
10:15:52 <shapr> reltuk: real state requires mutable updating
10:16:27 <reltuk> where mutable updating = ...?
10:16:40 <Smerdyakov> reltuk, monads don't inherently provide any new capabilities.
10:16:46 <shapr> you could fake having state by explicitly passing in that state
10:16:49 <Smerdyakov> reltuk, the monad interface happens to be useful for providing a way to get mutation.
10:17:00 <shapr> addMemory 1 state
10:17:15 <Si\> they do in the UK as well by default
10:17:58 <shapr> if you think of a calculator that has an M+ button, that button adds the value shown to whatever value is in the memory
10:18:22 <reltuk> and the monad can't do that?
10:18:41 <Smerdyakov> reltuk, please be more specific. What do you mean by "the monad"?
10:18:56 <shapr> so "addMemory = add state"
10:18:58 <reltuk> a monad...
10:18:59 <reltuk> :-p
10:19:25 <shapr> oh, I know of some great monad examples my Steve Atkin
10:19:52 <reltuk> I'm not smart enough for monads  :-p
10:19:57 <shapr> really you are
10:19:59 <Smerdyakov> reltuk, like I said, monads are NOT a way of adding new capabilities to a language.
10:20:11 <shapr> it's just like objects, you have to look at it from the correct direction
10:20:11 <Smerdyakov> reltuk, so of course monads allow nothing that Haskell without monads doesn't allow.
10:20:22 <reltuk> Smerdyakov, so they're completely implemented in haskell?  (i.e., no support for them outside of convention and Prelude?)
10:20:30 <Si\> you are, I once thought that monads were evil, but now I use them without difficulty, it just takes time
10:20:35 <Smerdyakov> reltuk, no. Monads provide a useful interface for code written in non-Haskell languages.
10:20:54 <Smerdyakov> reltuk, however, most Monad instances are implemented in Haskell.
10:21:01 <Igloo> [18:16] < coder_5> hey igloo, are you sure you want use wxwindows and c++ ?
10:21:02 <Igloo> [18:16] < Igloo> No, I'm sure I want to use wxHaskell
10:21:03 <Smerdyakov> reltuk, for instance, the list monad.
10:21:08 <Igloo> (from #wxwidgets)
10:21:20 <shapr> Igloo: heh!
10:21:46 <Smerdyakov> reltuk, this is a very common confusion. It is similar to thinking like this:
10:21:52 <reltuk> I understand everything (including IO) up to chapter 9 of A Gentle Introduction...
10:22:03 * SyntaxLaptop posts rant to libraries@
10:22:12 <Smerdyakov> String -> () is the type of functions from Strings to nothings.
10:22:30 <Smerdyakov> There might be a special function of that type that allows printing to the screen. (There isn't)
10:22:42 <Smerdyakov> Without that function, you would have no way of implementing its functionality in Haskell.
10:22:52 <shapr> oooh, rant
10:22:56 * shapr looks
10:23:06 <Smerdyakov> That doesn't mean all values of type String -> () have to do with special imperative features.
10:23:54 <Smerdyakov> Monads are similar. They are like a type that is useful for describing things that provide features that must be implemented outside Haskell, but they are not inherently related to such things.
10:23:57 <reltuk> ok...but it's possible to implement a monad, i.e. something that simulates state, in pure haskell without any inherit support for state or simulating state...
10:24:11 <Smerdyakov> Sure. Haven't you ever used fold?
10:24:31 <reltuk> fold doesn't require state...
10:24:40 <Smerdyakov> Right, but it simulates it, which is what you asked.
10:24:50 <Smerdyakov> The accumulator parameter is the state that is changed one list item at a time.
10:26:03 <Smerdyakov> The question of what is "state" and what isn't is a silly one.
10:26:14 <Smerdyakov> It all boils down to optimizations of certain patterns.
10:26:20 <reltuk> really? the accumulator simulates state?
10:26:27 <Smerdyakov> What do you mean by state?
10:26:42 <reltuk> I assumed the accumulator was copied...
10:27:02 <phubuh> haskell makes no promises that it isn't
10:27:15 <phubuh> but what goes on in the low-level details of RAM memory is irrelevant
10:27:17 <Smerdyakov> reltuk, what do you mean by "state"?
10:27:44 <jlouis> phubuh: RAM memory = Random Access memory memory? RAM^2 ??
10:27:56 <reltuk> values which change over tiem
10:28:08 <reltuk> or rather, the result of a function, changing over time
10:28:25 <phubuh> nothing wrong with a little redundancy
10:28:32 <jlouis> phubuh: ;)
10:28:39 <Smerdyakov> reltuk, what is a value?
10:28:42 <reltuk> so if I have a player of a game, and I want to get their health, and I call getHealth(chr), and it can return a different value based on what's happened to the character before....that's state  :-p
10:28:57 <bring> how much RAM do I have again? oh, I'll just have a look in my RAMM
10:29:13 <Smerdyakov> reltuk, so you're talking about a syntactic property of code?
10:29:21 <shapr> SyntaxLaptop: awesome rant
10:29:31 <jlouis> shapr: URL?
10:29:44 <reltuk> Smerdyakov, I can't have this conversation, I'm not knowledgable enough to know what I'm talking about  :-p
10:29:53 <reltuk> but it's a semantic property I would think, not syntactic...
10:30:02 <Smerdyakov> reltuk, I think it should be easy enough to guide you to the problem with your viewpoint.
10:30:16 <Smerdyakov> reltuk, can you describe the semantic property?
10:30:42 <shapr> http://www.haskell.org//pipermail/libraries/2004-March/001870.html
10:30:46 <reltuk> ok, I have a value represented by however the computer represents...
10:30:50 <Smerdyakov> reltuk, (My viewpoint is that what you are _really_ talking about is a guarantee that a particular compilation strategy/optimization is used.)
10:30:53 <reltuk> I apply some operations to it
10:30:54 * jlouis ponders on a function environment, mapping variables to values
10:31:21 <reltuk> the value changes it's value by changing it's representation
10:31:33 <Smerdyakov> reltuk, what is being changed?
10:31:41 <Smerdyakov> reltuk, a word in RAM?
10:31:52 <reltuk> so if I had x = 3, and I wanted to add 3 to it, and I could do x = (3 + oldx), that would be fine
10:32:11 <reltuk> assuming I could chain operations like that...
10:32:13 <reltuk> that would be stae
10:32:18 <reltuk> s/stae/state
10:32:21 <Smerdyakov> reltuk, see above questions
10:32:30 <jlouis> shapr: thanks
10:32:34 <reltuk> A word in RAM could be changed...
10:32:50 <reltuk> but it doesn't have to be
10:32:56 <Smerdyakov> reltuk, your definition is not meaningful unless you define precisely what is being changed.
10:33:00 <SyntaxLaptop> shapr: ta
10:33:24 <reltuk> the result of the expression is being changed...
10:33:38 <Smerdyakov> reltuk, I am asking you to sketch a formal machine model.
10:33:59 <Smerdyakov> reltuk, "the result of the expression" need not have meaning to a programmer.
10:34:15 <reltuk> ok, so a word in RAM...
10:34:26 <Smerdyakov> OK. Now, why should the programmer care about what goes on in RAM?
10:34:30 <phubuh> the result of an expression in haskell is always the same.  a function given a specific set of arguments will always return the exact same result.  to "emulate" state, we just keep our state in the set of arguments itself
10:34:55 <reltuk> because it effects what his program puts in ram (the output of his program)
10:35:16 <Smerdyakov> But we have higher level models that let the programmers perform the same reasoning with less need to worry about details.
10:35:24 <phubuh> a cell of mutable state becomes an argument to the function, and we alter it by tail-recursing with a different argument
10:35:28 <Smerdyakov> Why should the programmer choose to reason about RAM rather than use these higher-level models?
10:35:56 <Smerdyakov> phubuh, I don't think you are helping him. He understands that.
10:36:18 <reltuk> we shouldn't...
10:36:29 <phubuh> OK, i'll be quiet then.
10:36:31 <Smerdyakov> reltuk, OK, then why do you care about a notion of state based on RAM?
10:36:32 <jlouis> shapr: interesting rant
10:36:34 <reltuk> which is why I said the result of the same expression changes from what it used to be  :-p
10:36:52 <Smerdyakov> reltuk, so define what "the result of an expression" is and we can discuss that model.
10:37:52 <reltuk> I can understand how to simulate state if you don't have by-default recursive lexical scoping...
10:38:25 <Si\> is there a more concise way of doing (\x -> f x) >>= g (where f is of type a -> m b and g is of type b -> m c)?
10:39:03 <jlouis> Si\: foobar f g = ... ?
10:39:08 <Smerdyakov> reltuk, you haven't yet defined to my satisfaction what "state" is.
10:39:22 <reltuk> ok, the result of an expression is a value...
10:39:53 <reltuk> let's assume you're talking about expressions which evaluate to integers...so the result of an expression is an integer
10:39:57 <SyntaxLaptop> Si\: why (\x -> f x)? that's the same as "f", right?
10:40:31 <SyntaxLaptop> Si\: f >> = g is the answer, I think
10:40:47 <SyntaxLaptop> or you can say "do x <- f y; g x"
10:41:18 <Si\> sorry you're quite right
10:41:43 <Si\> I mean (\x -> unmarshal x >>= fromVal)
10:42:17 * Si\ is playing how to make his code as concise as is Haskelly possible :)
10:42:25 <SyntaxLaptop> Si\: a dangerous game ;)
10:42:30 <reltuk> Smerdyakov, perhaps a hint on what direction I should be going in?
10:42:36 <Si\> but fun nevertheless
10:42:41 <SyntaxLaptop> absolutely
10:43:15 <Si\> ok, so is there a way of doing that without the lambda abstraction?
10:44:35 <phubuh> (flip (>>=) fromVal) . unmarshal ?
10:45:06 <Smerdyakov> reltuk, OK, so you define a pure function from expressions to values, and the result of an expression is the result of that function applied to it?
10:45:36 <reltuk> yes...
10:45:42 <reltuk> like eval
10:46:03 <Si\> good idea
10:46:04 <Smerdyakov> reltuk, OK. A pure function always returns the same thing by definition, so what does "state" mean in this case?
10:46:18 <Smerdyakov> (always the same thing on the same input, that is)
10:46:25 <reltuk> that the expression changed
10:46:30 <reltuk> but transparently to the user
10:46:35 <reltuk> s/user/programmer
10:48:51 <Smerdyakov> What does it mean for an expression to change?
10:49:46 <reltuk> this is very zen...
10:50:42 <reltuk> then maybe eval isn't pure...
10:52:06 <earthy> reltuk: how could it not be?
10:52:06 <reltuk> for an expression to change, the way in which you calculate the result of the expression must change
10:52:45 <Smerdyakov> reltuk, OK. In what way does it change? You should be able to write a program that models any system you propose.
10:53:40 <earthy> reltuk: so, in your terms, the evaluation method must change
10:53:48 <earthy> i.e. you use a different eval
10:54:16 <earthy> but then the entire expression is different, no? due to the outermost function being different?
10:54:37 <reltuk> earthy, that's not quite what I meant...
10:54:45 <earthy> it seems to be what you said... :)
10:55:02 <reltuk> earthy, I meant if you have x = 3, when you eval x, you eval 3 and return the result....
10:55:26 <reltuk> earthy, but if you could make x = 3 + 3, then when you eval x, you eval 3 + 3, and return 6...
10:55:54 <reltuk> I'm just trying to understand that State Monad in A Gentle Introduction...
10:56:24 <reltuk> it looks like it chains operations together...
10:56:50 <reltuk> or something like that....kind of like continuations, but not quite
10:57:38 <earthy> now you're getting somewhere
10:58:34 <earthy> the trick is that instead of building the entire remaining computation, as you would do with continuations, you merely construct the new state to calculate from and then continue with that state
10:59:17 <earthy> monads allow you to nicely `hide' all the threading
10:59:26 <earthy> but it's still there, under the hood
10:59:43 <reltuk> wow...
11:00:11 <earthy> so, if I have a eval :: Expr -> Val, I could change it to a eval Expr -> State -> Val, but then I'd have to explicitly pass around the `state'
11:01:04 <earthy> e.g.: eval (x `Plus` y) state = (eval x state) + (eval y state)
11:01:35 <reltuk> *nod*
11:02:43 <jdrake> http://davezilla.com/images/FillerUp.jpg
11:03:15 <reltuk> oh well, I'll play with it over spring break
11:04:19 <earthy> (sorry, IRL interruption)
11:04:39 <earthy> the new eval would have to be eval :: Expr -> State -> (Val, State)
11:04:51 <earthy> so, that evaluation results in both a value *and* the new state
11:05:12 <earthy> e.g.: eval (x `Plus` y ) state = ((eval x state) + (eval y state), state)
11:05:20 <earthy> (that one's trivial, the state isn't changed)
11:05:36 <reltuk> *nod*
11:05:56 <reltuk> but haskell programs do have bindings...so they still need to do this type of thing for enviornments
11:05:58 <earthy> but: eval (x `Becomes` y) state = ((eval x state) + (eval y state), update state (eval x state) (eval y state))
11:06:24 <earthy> what do you mean with `haskell programs do have bindings'?
11:06:35 <jlouis> let and where are binding constructs
11:06:52 <earthy> this I know, but binding need not imply state
11:07:00 <jlouis> it has nothing to do with state though
11:07:04 <earthy> lambda calculus has binding constructs
11:07:09 <reltuk> right...I'm just saying eval gets enviornment eitherway
11:07:51 <earthy> (ofcourse in the above code I managed to ignore tuple selection...)
11:08:03 <earthy> (I'm totally not awake enough anymore)
11:08:12 <reltuk> hehe
11:08:21 <earthy> and that at 8pm
11:08:23 <Smerdyakov> eval needn't get an environment.
11:08:33 <Smerdyakov> There are formal models of execution where you replace variable occurrences with their values.
11:08:55 <Smerdyakov> And, since you have a State, you can always consider "the environment" to be in there.
11:09:09 <earthy> smerdyakov: I was trying to explain state-threading, so that relkut could then understand state monads
11:09:18 * Smerdyakov nods.
11:09:39 <Smerdyakov> I was under the impression that he was trying to understand the IO monad.
11:09:52 <Smerdyakov> Maybe without realizing that that was what he was trying to understand. :)
11:10:08 <reltuk> yeah....state threading...
11:10:30 <reltuk> earthy, but haskell doesn't do that (thread state), right?
11:10:31 <earthy> the IO monad is a bit magic, really
11:10:33 <Smerdyakov> I thought I already gave an adequate example of state threading, which is fold functions.
11:10:38 <earthy> reltuk: no, it doesn't
11:10:48 <earthy> smerdyakov: true
11:11:00 <earthy> (as I said, I'm not very awake)
11:11:15 <reltuk> I'll just let it sit...my gf is bugging me to get on the road
11:11:24 <earthy> reltuk: so, how does Haskell achieve stateful effects?
11:11:39 <earthy> well, the trick is that it doesn't really, unless you're under the IO monad
11:12:03 <earthy> which every useful program implicitly is (as it does I/O at least for output of the result ;))
11:12:09 <Smerdyakov> There's earthy being irresponsible, too, using the word "stateful" like that. :P
11:12:23 * earthy grinz
11:12:31 <earthy> that was on purpose ;)
11:12:40 <earthy> maybe I should've added quotes ;)
11:12:51 <reltuk> Smerdyakov, I understand how if I have a list, and I append 3 onto and fold (+) 0 it, then I've increased the value of that expression by 3...
11:13:05 <reltuk> Smerdyakov, but I can't refer to that new list by the same name that I refered to the old list by...
11:13:07 <earthy> no, you've made a new expression
11:13:11 <earthy> exactly!
11:13:15 <earthy> now you seem to understand
11:13:50 <reltuk> earthy, so how is it state at all?  :-p
11:14:03 <earthy> it isn't, which is what we've been saying all along
11:14:14 <earthy> but, Haskell can safely interact with systems that do keep state
11:14:25 <earthy> (such as the world :))
11:14:30 <reltuk> lol
11:15:22 <reltuk> ok, like I said, on the road
11:15:27 <earthy> the trick to doing that is to thread a representation of the world through the program
11:15:30 <reltuk> I'll tlak to you guys lates, thanks for so much help
11:15:35 <earthy> our pleasure
11:15:42 <earthy> and hug your gf for being patient ;)
11:15:53 <reltuk> lol, will do
11:32:06 <marijne> is there a way of accessing element n of a tuple?
11:35:14 <saz> pattern match
11:38:22 <SyntaxLaptop> is ExitCode someplace besides GHC.IOBase?
11:38:38 <SyntaxLaptop> it seems a tad strange to use GHC.IOBase when I am using something from System.Cmd
11:39:34 <SyntaxLaptop> marijne: you can build a generic function to get the nth element of a tuple only in TemplateHaskell, because each different size of a tuple is a different type.
11:40:59 <marijne> the size of the tuple is constant
11:41:34 <saz> so just write a function to get that element
11:42:11 <saz> eg: third (_,_,x,_) = x
11:42:18 <saz> for the 3rd element in a 4 tuple
11:43:01 <SyntaxLaptop> or use a lambda binding (\ (_,_,x,_) -> x)
11:44:01 <marijne> i see, but there's no way of using an Int to 'index' the tuple, is that correct?
11:44:52 <marijne> oh, i guess i could use a case statement
11:45:44 <SyntaxLaptop> getN4 :: (a,b,c,d); getN0 (a, _, _, _) = a; ...
11:45:58 <SyntaxLaptop> oops getN4 0 = (a, _, _, _) = a
11:47:42 <marijne> ah yes, dead on, thank you :)
11:47:46 <Igloo> Only works if all the bits of the tuple have the same type, though
11:49:17 <SyntaxLaptop> oh yeah, good point
11:49:34 * SyntaxLaptop would have seen that if he actually tried to get the type sig right
12:00:09 * marijne curses her ineptitude at recursive problems
12:02:32 <Smerdyakov> Is there any book using Haskell that teaches that skill as well as HTDP does with Scheme? (question to whole channel)
12:03:41 <jlouis> good question. I found HTDP too boring.
12:06:57 * marijne is away: food required.
12:07:58 <ayrnieu> Someone should write The Little Haskeller after The Little Schemer, I suppose.
12:09:16 <Smerdyakov> Nah. It's only Schemers who are little. ;)
12:09:44 <ayrnieu> oh, hey, hello Smerdyakov.
12:11:38 <Smerdyakov> Hello.
12:11:41 <CrewdenX> it sounds like a programming website for teaching kids. 
12:12:59 <ayrnieu> sigh, don't expect me to defend that book -- go research it if you care.
13:17:05 <earthy> the little haskeller ... yeah, that'd be an idea
13:29:42 <Cale> like http://www.cs.kuleuven.ac.be/~bmd/DT/littlehaskeler.ps ?
13:32:50 <jdrake> i found a laser printer in best buy that said it had postscript level 2 emulation, pcl6 and one other. It was something like 250cdn. Does that sound good?
14:53:32 <ecraven> what would you call an operation that maps a function on index values.. like mapping f over all values from (0 0) to (3 3) or whatever
14:53:36 <ecraven> basically calling a function with all indices of a matrix
14:53:38 <ecraven> is there any operation for that? what would it be called?
14:55:19 <Smerdyakov> I'd call it some variety of fold.
14:55:33 <Smerdyakov> That's what such functions that iterate over all cells of a vector are generally called, for instance.
14:56:00 <ecraven> but it should iterate over indices, not elements
14:56:33 <Smerdyakov> There's a Standard ML Basis function List.tabulate that does that for "one-dimensional vectors."
14:56:53 <Smerdyakov> I.e., for all numbers from 0 to n-1.
14:57:16 <ecraven> yea, something like that, but for variable dimensions and iotas
14:59:03 <Smerdyakov> So then you could try for a variation on "tabulate."
15:01:38 <ayrnieu> Cale - belatedly: no, not like that.
17:14:56 <jdrake> do you guys know if a paper from 1993 on haskell (specifically "the little haskeller') is relevant to today's haskell?
17:22:59 <wagle> i didnt have much difficulty porting a monad happy gofer program from 1995 to ghc and hugs a couple weeks ago
17:23:40 <jdrake> i think i need to save up for a decent laser printer, then I can actually print stuff out without breaking the bank
17:23:43 <wagle> main thing was a few names of library function changed, and the monad comprehensions had to be changed to do notation
17:24:11 <jdrake> this postscript file looks awful in the preview, but I can actually read it when printed out
17:24:36 <jdrake> i wonder what this "interactive Haskell B. version 0.999.5 SPARC 1993 Oct 28" is
17:24:51 <jdrake> are there any haskell interpreters around?
17:25:03 <jdrake> it seems I have ghc only
17:25:09 <jdrake> i couldn't get hugs or helium to compile
17:25:09 <Smerdyakov> ghci
17:25:21 <jdrake> much nice
17:25:24 <jdrake> thnk you
17:25:27 <Smerdyakov> Or at least I recall something like that... never used it myself.
17:26:10 <wagle> i've been using ghci
17:26:10 <juhp> heh :)
17:28:19 <jdrake> it looks like I will have to make some changes to the source code the list haskeller gives :-0
17:28:27 <jdrake> i guess a lot changes in 10 years
17:28:40 <jdrake> it has a line like let { x = -10};
17:36:53 <Smerdyakov> That should be fine today.
17:37:35 <jdrake> oh it is the semicolon it didn't like
17:37:59 <jdrake> althought its output it not the same
17:38:15 <Smerdyakov> The syntax with braces is the "real" one. Indentation compiles to braces as "syntactic sugar."
17:38:19 <jdrake> in the 10 year old paper its output is the x :: (Num a) => a
18:13:05 * Cale is now writing a Haskell binding for Imlib 2.
18:30:08 <Smerdyakov> CodeWarrior, any association of your name to the MetroWerks IDE?
18:30:39 <CodeWarrior> Smerdyakov: nope. ( :
18:32:58 <Smerdyakov> Could you pull prior art to get their trademark revoked? ;)
18:33:28 <CodeWarrior> hehehe
18:33:38 <CodeWarrior> we'd wish wouldnt we ( :
21:08:50 <jdrake> does anyone know if you can get ghci to echo out the types of what you enter?
21:09:19 <Riastradh> :t <foo>
21:10:06 <jdrake> the thing I am reading - little haskeller prints the type 'x :: (Num a) => a' for that line I have: let {x = -10}
21:10:28 <jdrake> what ghci prints is x :: Integer
21:10:29 <Riastradh> let x = -10
21:10:37 <jdrake> are those functionally equivelent?
21:11:09 <Riastradh> ...er, oops, I didn't mean to say that, but yes, they are.
21:11:14 <jdrake> Riastradh, i am going by what TLH has written up
21:11:26 <Cale> whee, down to 100 functions left to import.
21:11:29 <jdrake> it is 10 years old so :-)
21:12:00 <Cale> oops, just realised that there is a user named whee here :)
21:12:08 <jdrake> i could use a full screen terminal :-)
21:12:25 <jdrake> i wonder if iterm could be modified for that :-)
21:12:30 <jdrake> make programming easier on the eyes
21:16:18 <jdrake> tlh now has something with the line 'x :: Float' which if I understand correctly by the previous text is supposted to convert the number to a float because it is supposed to be of class 'Num'. Is this a case of ghc not doing it the same way?
22:27:43 <Cale> Down to 59 ccalls left to do.
22:27:51 <jdrake> in an old tutorial I have this is said, along with the error:
22:27:52 <jdrake> Prelude> data Colour = Red | Green | Blue
22:27:52 <jdrake> <interactive>:1: parse error on input `data'
22:28:06 <jdrake> what is the proper keyword I should be looking for there?
22:28:25 <Cale> the point is that you can't declare things on the hugs/ghci prompt
22:28:37 <jdrake> oh
22:28:38 <Cale> you need to put your declarations into a file and load it
22:29:57 <Cale> in ghci, you can use "let blah = foo" to do temporary bindings, but for things like datatype declarations, you need to put them in a file.
22:31:16 <jdrake> that kind of sucks :-(
22:31:53 <Cale> There are commands inside both of them that let you open your favourite editor on the currently loaded file.
22:32:14 <Cale> Though what I do is to run gvim next to the terminal where I have ghci loaded.
22:32:25 <Cale> I just ":re" whenever I make changes.
22:32:45 <jdrake> i found gvim really difficult to work properly (it isn't really a good osx citizen)
22:32:55 <Cale> Well, whatever editor you use.
22:33:03 <jdrake> what does :re do
22:33:17 <Cale> reloads the current file from disk and recompiles it.
22:33:32 <jdrake> but isn't gvim your editor?
22:34:05 <Cale> ":re" is what I type in ghci
22:34:08 <jdrake> oh i see what you mena
22:34:14 <Cale> I type ":w" in gvim
22:34:56 <Cale> It's rather convenient that way.
22:35:24 <jdrake> which is just like cmd-S in any other editor :-)
22:35:44 <Cale> I suppose.
22:36:16 <jdrake> vim has a haskell binding right?
22:36:18 <Cale> C-x C-s in emacs, most likely.
22:36:24 <jdrake> or sorry, syntax mode
22:36:27 <Cale> yeah
22:38:53 <Cale> I'm currently writing imlib2 bindings for Haskell. Only about 1/8 left to go, so I could probably be finished in half an hour if I kept going.
22:39:22 <jdrake> talking on irc is much better though :p
22:40:19 <Cale> Yeah, the haskell ffi is nice, but actually writing out the bindings for ~450 functions takes a long time.
22:41:18 <Cale> I probably should have tried GreenCard or something.
22:41:22 <jdrake> i imagine it would be
22:42:03 <Cale> Most of the imports are trivial, but functions that take pointers to memory where they will place return values are annoying.
22:42:50 <Cale> malloc with type inferencing is cool though. :)
22:44:44 <Cale> you just "b <- malloc" :)
22:45:43 <Cale> and it works out the type of b from how it's used and allocates the right amount of memory based on that.
22:45:54 <Cale> :)
22:48:56 <jdrake> how do you get something that is for imperative to work in functional
22:49:06 <Cale> that's what monads are all about
22:49:21 <jdrake> damn I have to get into those
22:49:23 <Cale> the IO monad gives you a sort of imperative sublanguage of haskell
22:49:24 <jdrake> but in due course
22:49:43 <Cale> using IO is really easy.
22:50:07 <Cale> Really understanding what's going on is slightly trickier, but the difficulty is often overhyped.
22:50:18 <jdrake> not when I am only at data Colour = Red | Green | Blue;  in the tutorial :-)
22:50:32 <jdrake> can you create your own monad?
22:50:36 <Cale> yep
22:50:58 <Cale> monads are sort of a generalisation of the idea of sequencing operations on something.
22:51:05 <jdrake> so theoretically you could create say a gui monad
22:51:11 <Cale> Yeah
22:51:19 <Cale> That's been done, in fact.
22:51:23 <jdrake> how does it do it without side effects?
22:52:00 <Cale> well, the IO monad (and any monads built on top of it, like a GUI monad) is where all the side effects go.
22:52:31 <Cale> You can tell that something can cause side effects, or relies on context based on its type.
22:52:58 <Cale> for example, getChar :: IO Char
22:53:18 <Cale> or putStrLn :: String -> IO ()
22:53:58 <jdrake> are monads ever overused?
22:54:42 <Cale> You can overuse them, and end up using Haskell as an imperative language.
22:55:05 <Cale> There are pure ways to use monads too, though.
22:55:28 <jdrake> hmm: Monad - the Third Octave of Being. When the Soul unites with this ensouling entity, you become an Adept.
22:55:35 <Cale> heh
22:55:58 <Cale> Not all monads encapsulate side effects. (Mostly it's just the IO monad)
22:56:07 <Cale> Maybe, for instance, is also a monad.
22:56:43 <jdrake> hmm, functional philosophy... I think therefore I am
22:56:59 <ayrnieu> jdrake - minus the 'I'
22:57:30 <jdrake> a thinks it is, therefore it must be
22:57:35 <Cale> \x -> implies (think x) (is x)
22:58:17 <Cale> or perhaps, \x -> implies (thinks x (is x)) (is x)
22:59:06 <Cale> \x -> (x `thinks` (is x)) `implies` (is x)
22:59:08 <jdrake> how about some cleaver thing for this: "Multiplane Master - a spiritual teacher who can work in all twelve spiritual domains."
22:59:58 <Cale> The term Monad as used in functional programming, of course, doesn't come from philosophy, but rather category theory, where it is a mutation of the word monoid.
23:00:28 <jdrake> every science and its brother has a word monad
23:03:05 <jdrake> heh "Muni - a saint who observes the austeriy of voluntarily not speaking."  - who can you think of that should dedicate themselves to being Muni?
23:16:25 <anduril1> is there a way I can set the position of the cursor in a console?
23:16:41 <anduril1> I want to repeatedly print something in the upper left corner
23:16:42 <jdrake> anduril1, escape codes likely
23:16:56 <jdrake> for that I recommend \r if it is only one line you are printing
23:17:09 <anduril1> its multiple lines
23:17:27 <jdrake> then escape codes are the only possibility i think
23:20:35 <anduril1> I found the code I want, it is "^[[H" . . . what character value is this?
23:21:17 <ayrnieu> auduri - ESC [ H
23:21:25 <jdrake> how do you get something like this: data Day = Monday | Tuesday | Wednesday | Thursday | Friday; to be comparable, or do I have to define functions for that specifically?
23:21:28 <jdrake> the text I have just acts as if they are already defined
23:21:33 <ayrnieu> auduri - "\027[H"
23:21:34 <anduril1> nevermind, I think I got it
23:22:38 <ayrnieu> auduri - and you don't actually want that for setting the position of the cursor in a console.  You want: atxy x y = "\027[" ++ show y ++ ";" ++ show x ++ "H"
23:22:52 <ayrnieu> or maybe (show (y + 1))
23:23:13 <anduril1> jdrake: add "deriving Eq" after your data declaration
23:23:56 <ayrnieu> auduri - man console_codes under linux, or vt100.net
23:42:02 <anduril1> I've finally made (Conway's) Life work
23:42:04 <anduril1> woo
