03:52:41 <emu> where would math be without greek symbols?
03:53:29 <Riastradh> It would be very boring.  I'd no longer be able to confuse someone by spouting out a complicated assortment of Greek letters and mathematical symbols; just the mathematical symbols are not enough.
03:54:03 <kosmikus> we'd all have to learn the russian alphabet, or hebrew, or klingon?
03:54:21 <emu> many mathematicians are merely hellenophiles
03:54:41 <emu> hey, you can play with aleph
03:54:57 <kosmikus> emu: that's just one letter ;)
03:55:25 <Riastradh> kosmikus, if we learned the Russian alphabet, we'd just be learning the Greek and Latin alphabets again.
03:55:37 <emu> crazy cyril
03:56:03 <kosmikus> Riastradh: true, but you have to be able to pronounce the letters you write
03:56:22 <emu> i can't pronounce all the greek letters i use
03:56:26 <kosmikus> and the assumption was that Greek would not longer be an option ...
03:56:51 <kosmikus> emu: so what if you're going to give a presentation?
03:57:04 <Riastradh> kosmikus, eh, Russian pronounciation is easy.
03:57:07 <emu> i don't use em.  or i say 'that squiggly thing'
03:57:23 <Riastradh> And pronounciation of Russian letters isn't arcanely confusing at all; it's just the letter's sound.
03:57:49 <Riastradh> 'E' is just 'yeh.'  'B' is just 'veh.'
03:58:33 <kosmikus> Riastradh: I wasn't indicating that it would necessarily be hard ...
03:58:55 <Riastradh> kosmikus, right; it's too easy!  I want to be able to confuse people, damnit!
03:59:14 <emu> how about using japanese kana
03:59:31 <Riastradh> Nah.  That's not confusing enough, either.
03:59:45 <Riastradh> Maybe Sanskrit.
03:59:52 <emu> yeah it's too easy to pronounce..
03:59:55 <emu> hmm
03:59:56 <kosmikus> kanji are confusing enough, I think
04:00:33 <kosmikus> Riastradh: but why not design your own symbols
04:00:50 <kosmikus> Riastradh: you can make them as similar-looking as you want, and define your own names
04:01:16 <kosmikus> each of your publications could be accompanied by a 100-page symbol guide where all these symbols are listed, in no particular order
04:01:30 <Riastradh> No, then it would look like I'm _deliberately_ trying to confuse people.
04:01:49 <ski> and you are not ?
04:02:10 <Riastradh> I am.  But it oughtn't to be _apparent_.
04:02:17 <ski> ah, ok
04:02:34 <Riastradh> What should be apparent is that it's wicked confusing -- no _intent_ should be visible --.
04:03:29 <emu> i think 'chet' would do .. english speakers can't pronounce it
04:03:46 <emu> or the spanish 'g' and 'j'
04:05:18 <ski> hmm, maybe we could use scandinavian 'å','ä','ö'
04:05:46 <ski> or the "ew" and "thot" of icelandish
04:05:57 <emu> can't forget \"o of german
04:06:19 <ski> right 'ä' and 'ö' is in german too
04:06:24 <Riastradh> They're all too mundane, though; just slightly spruced up versions of plain old Latin characters.
04:06:32 <ski> hmm perhaps
04:06:41 <emu> chet chet
04:06:54 <ski> some "ligatures", perhaps
04:07:04 <Riastradh> Maybe if we assigned new names to the Russian characters.
04:07:32 <ski> we could always try out old runes, or perhaps tengwar
04:07:41 <emu> next all we need is a new programming language to use these in
04:08:15 <ski> imagine saying "calma raised to the power of tinco squared"
04:10:03 <ski> (well, it might sound nicer in quenya ..)
04:11:06 <ski> also, some various magical symbols might be nice ..
04:13:15 <ski> e.g. http://dmweb.free.fr/Images/DMManual/DMManualPage50.png
04:14:06 <emu> kya-cubed
04:15:09 <ski> FUL IR raised to the power of MON
04:15:15 <ski> :)
04:19:07 <ski> lambda byakhee ....
04:19:27 <ski> (might perhaps be the part of a binding ritual)
04:19:38 <emu> sounds like some sort of indian food
04:19:49 <ski> which one ?
04:19:55 <emu> byakhee
04:19:58 * emu is hungry
04:20:53 <ski> a byakhee is a kind of elder one minion, or something like that IIRC
04:21:06 <ski> (i.e. a kind of moster/demon/whatever ...)
04:21:08 <emu> are they good with curry?
04:21:18 <ski> i haven't tated one myself
04:21:22 <ski> tasted
04:22:10 <ski> personally i try to stay away from those. wouldn't want to be the one that is being "tasted"
04:24:54 <ski> (hmm, gotta go)
04:32:34 <ham[let]> hiho
04:32:59 <Lemmih> I'm having some problems downloading HDirect from it's webpage. Can someone please direct me to a mirror?
05:19:06 <mattam> 
06:03:53 <emu> ñ^2
06:30:10 <shapr> yow!
06:30:26 <shapr> greetings! what's going on in the world of #haskell?
06:32:11 <shapr> anything?
06:32:50 <ham[let]> greetings mortal
06:32:58 <shapr> greetings Mr Ham Sir
06:33:07 <shapr> gutentag, Herr Let, wie geht es?
06:33:08 <ham[let]> heh
06:33:18 <shapr> ich habe keine ahnung
06:33:29 <ham[let]> :))
06:34:51 <shapr> hi shawn_
06:42:09 * shapr boings
07:58:46 <SamB> hmm, fptools/configure isn't very smart... autoconf should be written in prolog!
08:00:36 * earthy grinz
08:00:40 <earthy> or Stratego. :P
08:01:23 <shapr> yay, I won fallout!
08:01:29 <shapr> finally
08:01:44 <ski> what's fallout ?
08:02:00 <ski> hi shapr, btw !
08:02:04 <shapr> it's a single-player game, sort of like a role-playing game
08:02:06 <shapr> hi ski!
08:02:10 <shapr> it's made by interplay
08:02:16 <shapr> it's been around a long time, I don't know how long
08:02:21 <ski> ok
08:02:26 <shapr> it ran on DOS and win95
08:03:19 <SamB> well, something which makes it easy to, after seeing that my installed happy is too old, then go back and see I have checked out happy under the fptools tree...
08:05:41 <ski> Fallout: A Post Nuclear Role Playing Game ?
08:06:05 <SamB> shapr: what does it run on now?
08:07:32 <ski> DOS, Win95,NT,Mac, at least, 'tseems
08:39:17 <shapr> ski: that's the game
08:39:42 <shapr> hi jmob 
08:40:09 * shapr boings
08:40:18 <shapr> SamB: now it runs on wine.
08:40:58 <SamB> shapr: it seems like wine is only good for running old games ;-)
08:41:04 <jmob> shapr, hello
08:41:11 <shapr> that's a good enough reason, I guess.
08:41:18 <jmob> shapr, why doesn't your bot understand scheme
08:41:18 <shapr> jmob: you've been here before, haven't you?
08:41:33 <jmob> shapr, once before
08:41:37 <shapr> because... it's a haskell bot?
08:41:39 <SamB> okay, "only" was not the right word for it, perhaps
08:41:53 <shapr> probably wouldn't be too hard to plug in Ashley Yakeley's HScheme though
08:41:57 <shapr> jmob: you want to write the plugin?
08:42:06 <jmob> shapr, that's no excuse, it should be easy to implement scheme in haskell
08:42:20 <shapr> it's already been done.
08:42:20 <shapr> that's what I was saying.
08:42:26 <shapr> you just gotta write the lambdabot plugin.
08:42:35 <jmob> ah, neat
08:42:57 <shapr> if you write the plugin, lambdabot will use it
08:47:35 * shapr cranks up Sientific American
08:48:38 <ski> shapr : mm
08:51:35 <jmob> shapr, probably
08:51:45 <shapr> jmob: so, you want to learn Haskell?
08:52:09 <jmob> shapr, I'm not convinced of any benefit yet!
08:52:45 <shapr> I wasn't either when I started learning Haskell.
08:52:54 <shapr> same way when I started with Scheme
08:52:56 <shapr> and Python
08:52:58 <shapr> and SQL...
08:53:20 <shapr> now that I think of it, I'm rarely convinced of the benefit of something until I've used it for a bit.
08:53:50 <shapr> but, much like slightly cheesy movies, or fun books with huge plot holes, you suspend disbelief long enough to grab some understanding.
08:53:53 <jmob> shapr, I think right now Scheme is a lot to chew on
08:54:21 <shapr> ok, come back when you have some brainspace left over.
08:54:43 <jmob> shapr, I've never programmed in a functional style before and it's quite fun chewing on everything Scheme has to offer as far as new paradigms.
08:54:53 <shapr> that's good! expand your mind!
08:55:15 <shapr> I always feel like new languages are shoe-stretchers for your brain.
08:55:24 <jmob> shapr, not saying I don't want to see was people who program Haskell have to say though
08:55:25 <shapr> what do they call those things you put in your shoes to stretch them out some?
08:55:25 <SamB> shapr: well, did you think any of them sounded fun before you started learning it?
08:55:36 <shapr> SamB: nearly everything sounds fun to me.
08:56:16 <jmob> shapr, unless the new langauges are in the same style! I didn't learn much new between learning C/Java/Python/Ruby other than better/worse ways to implement the same things.
08:56:20 <shapr> I'd like to learn Forth and PostScript, and Prolog, and Mozart/Oz, and lots more.
08:56:30 <shapr> that's worth learning.
08:56:45 <SamB> Haskell is much different from scheme. believe me.
08:56:47 <shapr> I saw a huge difference between Java and Python
08:57:08 <shapr> but then, Java was my first OOP language, and Python was my second.
08:57:21 <jmob> shapr, I didn't too, I saw how stupid Java is, and how much static notions don't fit into "good" OO.
08:57:24 <shapr> I learned Visual Basic before Java, but it's not an OOP language, imho.
08:57:28 <jmob> s/n't//
08:57:48 <shapr> I'm not very fond of Java either.
08:57:55 <shapr> but I think static notions can fit into OO
08:58:03 <SamB> the difference between java and python is that python makes it easy, simple, and fun, whareas java makes it long, hard, and boring.
08:58:05 <shapr> or you can do it like Self, where it's got both.
08:59:12 <jmob> shapr, I think static notions are the antithesis of what OO design was intended to accomplish.
08:59:29 <shapr> can you give me an example of a static notion?
08:59:54 <jmob> shapr, compile time type checking.
09:01:03 <shapr> what about the inclusional polymorphism that's present in Python?
09:01:37 <shapr> subclasses that also count as their superclass are a form of type checking, right?
09:01:40 <SamB> inclusional polymorphism?
09:02:12 <shapr> just that, subclasses that count as their superclass type also
09:02:39 <ski> subclasses that count as their *own* superclass ?? or what ?
09:02:46 <jmob> shapr, I don't understand "subclasses that count as their superclass type"?
09:03:09 <shapr> class primate: pass
09:03:21 <shapr> class human(primate): pass
09:03:23 <SamB> can you give silly example code?
09:03:24 <jmob> shapr, you can change almost anythin runtime with python
09:03:45 <shapr> but then, compile time and runtime are pretty much the same with python.
09:04:46 <jmob> shapr, there is no "compile time" for python since it's interpretted, the only compilation is compiling to byte-code for faster loading.
09:04:51 <shapr> isinstance(human(),primate)
09:05:22 <shapr> python has runtime dynamic typing, Haskell has compile time dynamic typing
09:05:32 <SamB> jmob: it is compiled too! into bytecode, interleaved with execution
09:06:01 <SamB> shapr: compile time dynamic typing?
09:06:51 <shapr> if you leave off the typesig for something in Haskell, the inferred type sig can change if you change code in the rest of the file
09:08:14 <ski> (is that related top "law of demeter" ??)
09:08:26 <ski> (s/top/to/)
09:08:42 <shapr> http://c2.com/cgi-bin/wiki?LawOfDemeter
09:08:53 <shapr> the Law of Demeter is about coupling
09:09:23 <ski> mhmm
09:09:33 <jmob> class primate: pass; class human (primate): pass; me = human(); isinstance(me, primate); me.__class__.__bases__ = (alien,); isinstance(me, primate); #==> True False
09:09:55 <jmob> +class alien: pass
09:10:37 <Igloo> earthy?
09:11:17 <SamB> jmob: you just said that humans are aliens!
09:12:06 <shapr> jmob: amusingly, Self can be both compiled and interpreted, and it do tricks like that too.
09:12:18 <shapr> Python's getting close to being compiled also.
09:12:28 <SamB> actually, python can be compiled about as much as self can, I think
09:12:45 <shapr> pypy and psyco are neat
09:13:30 <SamB> unless self can be compiled statically, but I doubt it, since I wouldn't think the VM would be written in C++ if it could...
09:13:51 <shapr> jmob: Haskell has nearly convinced me that strong 'static' compile-time type checking can totally kick ass.
09:16:19 <shapr> jmob: I think you should try Haskell, but I may be biased ;-)
09:16:51 <shapr> yay, pix of where I live: http://restoree.interact.se/test2.jpg
09:17:55 <jmob> shapr, it'd  be cool if PyPy made an actual release
09:18:01 <shapr> hi twirl83 
09:18:15 <shapr> looking for Haskell info?
09:18:39 <twirl83> yeah
09:19:25 <shapr> got any specific questions?
09:19:57 <twirl83> no, 
09:20:11 <shapr> any general questions?
09:20:11 <twirl83> I want to know about it in general, and what does that mean function programming ? :)
09:20:43 <twirl83> what is functional programming ?
09:20:44 <shapr> the simplest description is that a function can be a value just like a number or a string
09:21:07 <shapr> because of that, you get some neat tricks
09:21:14 <jmob> everything is an expression that returns a value
09:21:28 <shapr> like, you can use a function like a hammer on a whole bunch of pieces of data at the same time
09:21:38 <ski> the emphasis in on what value expressions and functions compute/evaluate to, not on side-effects as in imperative programming
09:21:38 <shapr> @eval (\x -> x + 1) 1
09:21:39 <lambdabot> 2
09:21:41 <twirl83> aha
09:21:48 <shapr> @eval map (\x -> x + 1) [1,2,3]
09:21:48 <lambdabot> [2, 3, 4]
09:22:34 <shapr> hi monotonom 
09:22:35 <Cale> Map is a function that changes functions on a given type into functions on lists of that type.
09:23:50 <shapr> purely functional programming is more like writing a bunch of equations
09:24:15 <shapr> procedural programming is like writing a list of steps, like the directions you get when assembling ikea furniture or something
09:24:51 <ski> in other words, map takes a function (call it f), and then (gives a function that) takes a list, and give back a new list of values which is the results of applying f to all values in the old list
09:24:51 <shapr> one of the advantages of writing a bunch of equations is that you haven't said *how* to accomplish a certain goal, just what to accomplish
09:25:15 <shapr> so computations can happen in a different order, some computations you've specified may not need to happen at all
09:25:28 <twirl83> ic
09:26:40 * esap distinguishes between equations and definitions, but it might be irrelevant here.
09:26:44 <ski> i.e. you try not to overspecify your code too much, just getting down the relevant/essential bits, letting the implemetation decide on many boring lowlevel issues
09:26:50 <monotonom> Note that to obtain a program that computes square roots, you cannot write "(sqrt x)^2 = x" even in pure functional programming.  Thus you still have to tell the computer how to do things, one way or another.
09:27:39 <twirl83> aha
09:28:05 <ski> but the gap between a nice readable specification and the actual implementation you have to code up is smaller
09:29:01 <ski> (and it is easier to reason about code. because of stressing non-side-effecting code)
09:30:50 <monotonom> The gap is smaller because of built-in data structures such as list and utility functions such as map.  These are not intrinsically pure functional; a well-designed procedural language could also provide them and gain the same narrowing of mental gaps.
09:31:39 <monotonom> As for re-ordering computations and skipping computations, all production-quality compilers of all industrial procedural languages do them.
09:32:15 <shapr> monotonom: so what are the advantages of functional programming?
09:32:17 <ski> pattern-matching is a nice way of writing conditions on when to do/return what, and it's often quite readable as declarative statements about your program
09:32:24 <shapr> sheer sexiness? :-)
09:32:52 <monotonom> The real question is: so why do I come to this channel so often? :)
09:33:05 <shapr> it's because we're cool.
09:33:11 <shapr> I'm sure of it ;-)
09:33:35 <ski> twirl83 : have you seen pattern-matching ?
09:35:12 <twirl83> no, not till now :)
09:35:44 <ski> what do you think of it ?
09:36:54 <twirl83> string pattern-matching ?
09:37:03 <esap> string?
09:37:04 <ski> (or did you mean that you haven't seen it upto this moment ??)
09:37:16 <Cale> No, data structure pattern matching
09:37:21 <monotonom> I think here is why. Although many nice things could in principle be provided in all kinds of languages, usually in practice functional languages are ahead in providing them, and more importantly, in well-designed ways.  That is what I like about functional languages.
09:37:22 <ski> no, data-type pattern matching
09:37:25 <twirl83> ski: yeah :)
09:37:30 <ski> ah, ok
09:37:57 <ski> what shall we show, then ?
09:38:15 <ski> the traditional factorial and naive fibonacci ?
09:38:30 <ski> list functions ? (e.g. length)
09:38:40 <monotonom> list functions.
09:39:10 <ski> then we have to explain what sort of lists haskell has
09:39:31 <ski> twirl83 : or do you perchance know e.g. lisp lists ?
09:39:56 <Cale> A very simple example: (x:xs) is the list with head x and tail xs (: is the operator that prepends an element to a list). The functions head and tail can be written head (x:xs) = x, and tail (x:xs) = xs.
09:40:41 <ski> head takes a list, and gives back the front element of that list. tail takes a list and gives back all but the front element
09:40:51 <twirl83> ski: I don't know about lisp
09:41:19 <ski> twirl83 : no prob. :)
09:42:02 <ski> @eval head (1:(2:(3:[])))
09:42:02 <lambdabot> 1
09:42:08 <ski> [] is the empty list
09:42:16 <ski> @eval head (1:2:3:[])
09:42:17 <lambdabot> 1
09:42:48 <ski> and the ':' operator is right-associative, so we don't need as many parenthesis :)
09:43:04 <ski> @eval tail (1:2:3:[])
09:43:04 <lambdabot> [2, 3]
09:43:09 <twirl83> aha
09:43:24 <esap> @eval (1:2:3:[])
09:43:24 <lambdabot> [1, 2, 3]
09:43:25 <ski> [1,2,3] is syntactic sugar for 1:2:3:[]
09:43:35 <ski> as you can see :)
09:44:19 <ski> i guess length is the next interesting list function
09:44:31 <ski> the length of an empty list is 0
09:44:58 <twirl83> hmm
09:45:00 <ski> the length of a non-empty list is one more that the length of that lists tail (i.e. all but the front element)
09:45:17 <ski> this is written like this :
09:45:22 <ski> length [    ] = 0
09:45:31 <ski> length (x:xs) = 1 + length xs
09:45:40 <twirl83> ic
09:45:59 <ski> so we give two different cases
09:46:15 <ski> one for empty lists, and one for non-empty lists
09:46:46 <ski> do you understand how to read/understand those lines ?
09:47:56 <ski> anyway, this can of course be written with the traditional if-then-else, as well
09:48:11 <ski> then it looks like this
09:48:19 <ski> length xs = if null xs
09:48:23 <ski>               then 0
09:48:34 <ski>               else 1 + length (tail xs)
09:50:18 <ski> what do you think ?
09:52:30 <ski> twirl83 : hmm ?
09:56:36 <shapr> monotonom: I really like that description
10:18:47 <shapr> jmob: so, have you decided to try Haskell? should I send you a promotional pamphlet? ;-)
10:23:07 <jameson> BTW, is there a nice way to trace program execution without lifting everything on top of the IO monad?
10:23:39 <Igloo> There is hat. I don't know if buddah does that sort of thing too.
10:23:56 <Igloo> hat at least is used after the program has run to completion (or failure), though
10:25:13 <jameson> Ah, thanks! Does it require any external support? (working ghci or something?)
10:26:04 <Igloo> On Debian hat should work provided you don't use the bits of the hierarchial libs it doesn't support
10:26:25 <Igloo> With either ghc or nhc98
10:27:43 <jmob> shapr, pamphlet first, learning later.
10:27:51 <shapr> yay!
10:28:13 <shapr> check out http://www.ScannedInAvian.org/AvianWiki/HaskellDemo
10:28:29 <jmob> If you tell how I can avoid Haskell's wack syntax
10:28:43 <jmob> can I write haskell with scheme syntax?
10:28:54 <shapr> you can use braces and semicolons if you want
10:29:38 <shapr> is that better?
10:30:16 <jmob> shapr, yeah,, reading
10:30:33 <Lunar^> buddha is amasing
10:31:13 <Igloo> I almost compiled it yesterday, but then I didn't. I forget why. One of these days  :-)
10:32:50 <shapr> buddha debs? :-)
10:35:11 <shapr> jmob: what do you think of the pamphlet?
10:44:14 <jmob> shapr, interesting
10:44:42 <jmob> shapr, I don't see what benefit partial function applications are, but they sound cool.
10:44:45 <shapr> any questions or comments?
10:44:55 <shapr> it can easily work like an object instance
10:45:09 <shapr> one simple example is (+ 1)
10:53:11 <ski> map (* 5) [0,1,2,3]  ===  [0 * 5,1 * 5,2 * 5,3 * 5]  ===  [0,5,10,15]
10:55:08 <liiwi> sproing
10:55:28 <shapr> jmob: does that seem like a worthwhile benefit to you?
10:55:30 <shapr> hei liiwi 
10:56:04 <shapr> I have a sudden urge to go to Helsinki and hang out with you.
10:56:19 <shapr> but I shouldn't, I have a deadline tomorrow.
10:56:22 * shapr grumbles
10:56:44 <shapr> I want one of those 16-pound laptops.
10:56:50 <ski> map (map (+ 1)) [[0,1,2],[3,4,5],[6,7,8]]  ===  [map (+ 1) [0,1,2],map (+ 1) [3,4,5],map (+ 1) [6,7,8]]  ===  [[0 + 1,1 + 1,2 + 1],[3 + 1,4 + 1,5 + 1],[6 + 1,7 + 1,8 + 1]]  ===  [[1,2,3],[4,5,6],[7,8,9]]
10:57:21 <shapr> jmob: partial application replaces a lot of uses of lambda in Python
10:57:28 <shapr> hej Marvin-- 
10:57:32 <shapr> how many words today? ;-)
10:57:37 <Marvin--> evening
10:57:40 <Marvin--> 0 so far
10:57:42 * Marvin-- sighs
10:57:43 <jlouis> partial application or currying is good for writing good general functions  which can be used many places in the code 
10:57:46 * jlouis whips Marvin-- 
10:57:55 <jlouis> write, Write WRITE!
10:58:04 <Marvin--> I had an interesting thought though
10:58:05 <shapr> ok, tell me about the new wererat ideas you've had then :-)
10:58:09 <shapr> oh, what's that?
10:58:16 <jlouis> type like a monkey on the keyboard
10:58:21 <Marvin--> could you use a theorem prover to derive optimization rules?
10:58:31 <shapr> yes, I think you could.
10:58:58 <shapr> but wouldn't you end up with a lot of local minima with that approach?
10:59:08 <Marvin--> I don't know
11:00:00 <shapr> I think it'd be great to generate a bunch of optimization rules, and then present them to a human as a list of suggestions
11:00:12 <shapr> genetic optimization...
11:00:25 <ski> as a bithday present !
11:00:31 * shapr laughs
11:00:32 <ski> (birthday)
11:00:45 <ski> (sorry, just a wild idea i got :)
11:01:03 <shapr> well, genetics has a lot to do with birthdays.
11:01:17 <shapr> Marvin--: did you have any specific instances in mind?
11:01:20 <shapr> hi Matt-W
11:01:33 <Marvin--> no, not really
11:01:36 <Matt-W> hi shapr
11:01:41 <jmob> shapr, how often have you been accused of being a bot?
11:01:42 <shapr> what led you to this idea?
11:01:45 <shapr> jmob: often
11:01:46 <Marvin--> and re: wererats, no new ideas, I'm in wait-and-see mode right now
11:02:02 <Marvin--> shapr: oh, I was staring at the Future Work chapter
11:02:06 <shapr> jmob: but, I have a good reason for greeting people when they join the channel.
11:02:53 <shapr> my reasoning is that, often the channel isn't busy, and though we might see a lot of scrollback, when someone first joins, the place looks empty, no matter how many people are actually awake,idle, or whatever.
11:03:08 <Matt-W> it's nice to be greeted :-)
11:03:14 <shapr> that too :-)
11:03:15 <Matt-W> especially in a channel full of people as clever as you lot
11:03:23 * shapr points at Marvin-- 
11:03:29 * Marvin-- doesn't feel remotely clever today
11:03:32 <shapr> he's the guy doing the HOT language as FOL
11:03:51 <Marvin--> HOT?
11:03:56 <shapr> higher-order typed
11:04:01 <Marvin--> oh
11:04:13 <shapr> you say that a lot in your paper
11:04:25 <shapr> jmob: what do you think? is that a good reason?
11:04:52 <Matt-W> i think I need to learn more of the theory behind Haskell's type system
11:05:06 <shapr> I think irc would be better if you got the last fifty lines said in a channel when you joined
11:05:13 <shapr> or something like that
11:05:31 <Igloo> But then you'd see all the rude things we say about you when you aren't here
11:05:35 * shapr laughs
11:05:36 <Marvin--> shapr: I do?
11:05:50 <jmob> shapr, yeah, just very bot-esque
11:06:05 <shapr> Marvin--: I thought so; anyways, it's really important to understanding your paper
11:06:07 <Matt-W> shapr: you've got a very good point
11:06:09 <jmob> shapr, probably confuses people for a while, they might think you are a really cool bot.
11:06:13 <shapr> hah!
11:07:22 <shapr> I'll ask one of the freenode dancerd developers about that feature, might be interesting
11:07:35 <shapr> mgoetze: who are those dancerd developers anyway?
11:08:09 <Marvin--> shapr: did you finish reading through it?
11:08:21 <shapr> no, I remembered a deadline I have :-P
11:08:31 <Marvin--> ok
11:08:32 <mgoetze> shapr: asuffield, mainly
11:08:40 <shapr> I'll finish it this weekend, scout's honor :-)
11:08:47 <shapr> mgoetze: thanks
11:08:58 <Marvin--> don't worry, I have programming assignments and an exam to worry about too
11:09:52 <ibid> paper?
11:10:01 <shapr> well, it's easy to read it as long as I leave thunks for the meaty parts
11:10:06 <shapr> but I don't want to do that
11:10:22 <shapr> since that's not the point
11:11:05 <Marvin--> right, feedback on which parts should move around is highly appreciated
11:11:14 <Marvin--> ibid: more like degree project report
11:11:23 <liiwi> shapr: youÃ
11:11:24 <liiwi> erm
11:11:25 * ibid drools on the idea of a paper :)
11:11:32 <ibid> Marvin--: do tell
11:11:37 <liiwi> shapr: you'll want to be here next summer
11:12:21 <liiwi> shapr: http://liw.iki.fi/liw/log/2004-Debian.html#20040208d
11:14:24 <shapr> that would be very cool
11:14:54 <Marvin--> ibid: oh, it's my "encode haskell programs as first order logic formulae" project
11:15:17 <ibid> Marvin--: i want to read :)
11:15:28 * ibid is very interested in stuff like that
11:15:41 <shapr> jmob: any ideas for achieving the same effect without being bot-esque?
11:15:44 <ibid> you know, i'm teaching an automated reasoning course currently
11:15:55 <shapr> oh neat, any notes in english?
11:16:03 <shapr> or swedish?
11:16:26 <ibid> yeah, it's an english-language course
11:16:36 <ibid> but on the quality i can't tell ;)
11:16:50 <jmob> shapr, you could say something novel each time
11:16:51 <shapr> I'm sure it's better than anything I've seen before.
11:17:00 <ibid> http://www.mit.jyu.fi/antkaij/opetus/ap/2004/
11:17:09 <shapr> jmob: like what? M-x yow quotes? fortunes?
11:17:14 <ibid> jmob: it would make him just a really good bot :)
11:17:38 <jmob> shapr, um, say hello in a different language each time
11:18:15 <ibid> anybody here want to proofread my 15-page precis on fol? :)
11:18:28 <jmob> shapr, quote shakespeare
11:18:38 <shapr> I don't know any shakespeare.
11:18:39 <jmob> fol?
11:18:45 <ibid> first-order logic
11:18:46 <shapr> I can say hello in a large number of languages though.
11:19:06 <jmob> ibid, I'll read it
11:19:08 <shapr> I can quote some Tennyson.
11:19:23 <jmob> shapr, http://www.users.totalise.co.uk/~tmd/william.htm
11:19:31 <shapr> it would probably make more sense to quote Curry or Church
11:20:28 <shapr> jmob: sounds like a simple lambdabot plugin to write, want to try it?
11:21:04 * Heffalump wonders what happened to the Smerdyakov ban thing
11:21:26 <shapr> nothing yet, my big deadline was monday, and I have another one for tomorrow :-/
11:21:26 <ibid> jmob: http://www.mit.jyu.fi/antkaij/tmp/aure.pdf, chapter 2
11:21:42 <shapr> on the good side, the monday deadline turned out well.
11:21:53 <Heffalump> goodgood
11:22:16 <ibid> jmob: i know that my epsilon-term stuff is broken, working on it :)
11:22:18 <shapr> the website I've been building for three months was presented in Ecuador at a European/Latin American conference
11:22:52 <jmob> ibid, cool, looks very interesting, gotta go to a discrete math class for now though. :0
11:23:09 <ibid> :)
11:23:18 <ibid> if you want to be of any use to me, 
11:23:30 <ibid> my deadline is 1000+0200 tomorrow :)
11:23:34 <ibid> about 12 hours from now
11:23:57 <ibid> you can, of course, read it for pleasure, if you want :)
11:27:07 <shapr> greetings rt
11:27:11 <shapr> looking for Haskell info?
11:27:13 <rt> howdy.
11:27:34 <rt> I heard about this channel via the haskell community on orkut.  I'm surprised at the relatively large population.
11:27:35 <shapr> jmob: go ahead, tease me about a bot :-P
11:27:59 <rt> Haskell seems to have more proponents than I would expect.
11:28:06 <shapr> well, not everyone talks all the time.
11:29:01 <rt> So, do most people use hugs or the ghc compiler?
11:29:08 <stepcut> ghc
11:29:12 <stepcut> i would imagine
11:29:14 <shapr> from what I've seen, most people use GHC.
11:29:16 <Igloo> both, and nhc98 sometimes too
11:29:19 <shapr> y0 stepcut
11:29:24 <stepcut> hey
11:29:28 <shapr> wassup?
11:29:38 <stepcut> working!
11:29:47 <rt> i've only tinkered a bit with hugs.  haven't converted enough of my braincells to haskell yet, so it remains an uncomfortable language for me to use.
11:29:49 <shapr> good idea, I should do that too.
11:29:56 <stepcut> I might try to fix up the WASH/CGI build process this weekend
11:30:07 <shapr> what do you think of WASH/CGI so far?
11:30:19 <stepcut> its better than when I first looked at it
11:30:20 <shapr> rt: have any questions?
11:30:36 <shapr> I like the MIME support in WASHMail, makes my life easier.
11:31:23 <stepcut> sometimes my code gets a little wacky with the combination of HTML monads, CGI monads, AND io monads
11:31:26 <rt> not really.  I did graduate work in functional programming in the late eighties (nothing anyone would have ever heard of) so I get the ideas fairly well, but my professional experience is with more common procedural languages.
11:31:31 <rt> I suspect it's just a matter of practice.
11:32:13 <rt> I haven't yet acquired sufficient functional idioms to make programming straightforward.
11:32:16 <stepcut> rt: btw, the ghc compiler has an interpreter too (ghci)  [in case you didn't know]
11:32:45 <rt> I did. :-)
11:32:46 <rt> But thanks.
11:33:01 <shapr> the Haskell Wiki has a decent collection of idioms
11:33:02 <ski> stepcut : i think the usual terminology is (interactive) toplevel or repl
11:33:11 <shapr> or you could peruse the lambdabot sources
11:33:16 <shapr> though I dunno how idiomatic they are
11:33:25 <rt> heh.  ski.  good nick.  I'm having combinator flashbacks.
11:33:43 <ski> :) thanks
11:34:06 <shapr> rt: I think you'll like talking to Pseudonym when he joins.
11:34:56 <rt> There is definitely a disconnect between my theoretical knowledge (I implemented SK and supercombinator compilers and machines in the late eighties) and my use of functional programming for practical programs.
11:35:40 <shapr> sadly, there aren't a huge number of practical libraries either, I really wish I had an NNTP.hs right now.
11:35:54 <shapr> it's getting better though.
11:36:18 <rt> most of the programs I write for fun are centered around either computer graphics, web/cgi and tinkering with cryptography.  
11:36:22 <Marvin--> 139-136 for mandatory student union membership
11:36:23 <Marvin--> sheesh
11:36:28 <Igloo> What would you write with an NNTP.hs, shapr?
11:36:43 <shapr> Igloo: this thing I need for tomorrow :-)
11:36:59 <Igloo> Ah, I see  :-)
11:37:01 <shapr> once a year this guy pays me to slurp all the data out of an NNTP server into an MS Access database
11:37:10 <shapr> I've been doing it in Python, but you know what I'd prefer.
11:37:31 <rt> Python does have a nice nntp library.  That's what I'd feel comfortable using. :-)
11:37:43 <rt> But learning isn't often comfortable.
11:38:00 * Marvin-- likes learning
11:38:01 <shapr> rt: I can discuss web/cgi and crypto in some depth, and Pseudonym can discuss computer graphics in depth enough to drown me.
11:38:13 <shapr> what's a Keyes/Keynes rendering pipeline?
11:38:30 <rt> well, computer graphics is my profession, so I'd hope I was pretty good at it (rt stands for RayTracer. :-)
11:38:34 <shapr> hah
11:39:10 <shapr> web/cgi has been my profession lately, and I've done some really basic forpay crypto also. 
11:40:09 <rt> crypto is mostly just a hobby.  For fun I was working on a program to break cryptograms using genetic algorithms.   80 lines of Python.  Works pretty well, not 100% decrypts, but enough to easily suggest the right answers.
11:40:36 <shapr> sounds neat, want to rewrite it in Haskell?
11:40:44 <rt> It would probably be fun.
11:41:00 <rt> I need to pick a short but substantial project like that, and then just wade into Haskell.
11:41:46 <shapr> 80 lines of Python sounds like the right size, and you have past functional experience. I think you'll get into it quickly.
11:41:53 <rt> The other tinker-project I've been working on is a really simple weblog system.
11:42:00 <rt> (it's in python though)
11:42:19 <rt> Again, probably easily portable to Haskell.
11:42:31 <rt> well, the ideas would be anyway.
11:42:32 <shapr> there are a few weblog projects in Haskell
11:43:09 <rt> I liked the blosxom weblog, but it's written in perl.
11:43:17 <rt> The best I can say about perl is.. "yikes."
11:43:41 <shapr> Perl is not my style either, but some people here like it.
11:44:10 <Heffalump> if Haskell had the same volume of libraries and level of web-server support, I wouldn't use perl
11:44:48 <rt> http://orangecode.org is my test site for my python weblog.
11:44:53 <shapr> the web-server support approaches...
11:45:14 <rt> It's only a couple hundred lines of code.  To make postings, you just edit a file in structured text, which gets automatically converted into html by the system.
11:45:15 <shapr> I think Halipeto, HWS-WP, HaskellDB, and some other bits could be the beginnings of a Zope in Haskell.
11:45:28 <rt> It's far from clear to me that Zope is a good thing.
11:45:38 <rt> Many systems are way to complicated for their own good.
11:46:21 <shapr> well, I make a living two layers above Zope, with Plone.
11:46:29 <Heffalump> shapr: as in a proper Apache integration, or what?
11:46:45 <rt> plone is nifty, but again, a bit big for your average hobby/home weblog.
11:47:01 <shapr> true, Plone is massive
11:47:06 <shapr> hiya skew 
11:47:09 <skew> hi
11:47:10 <rt> I use movabletype for my real weblog (brainwagon.org)
11:47:31 <shapr> Heffalump: didn't the cvs version of mod_haskell support GHC?
11:47:45 * rt blinks.  mod_haskell.
11:48:03 <rt> ?
11:48:31 * rt surfs and finds.
11:48:32 <shapr> http://losser.st-lab.cs.uu.nl/mod_haskell/
11:48:33 <rt> Hmm.
11:48:36 <rt> Nifty.
11:49:13 <rt> Last update april 2002?
11:49:19 <shapr> yah, that sucks.
11:49:31 <shapr> sounds like a good project to ressurect though
11:50:13 <Heffalump> doh, I should have asked them about that when I was in Utrecht :-)
11:51:21 <shapr> I want to investigate the inverted index code I found recently, I wonder if that would be a good catalog basis
11:51:29 <Heffalump> for what?
11:51:37 <shapr> for the Haskell Zope
11:51:50 <Heffalump> ah
11:51:56 <ibid> Hope? :)
11:51:59 <shapr> I'd like to find some code for each feature that Zope offers.
11:52:07 <shapr> ibid: or maybe Hopi, as a pun on Apache
11:52:13 <ibid> :)
11:53:34 * rt has hudak's "haskell school of expression", can anyone else recommend books that are "must haves"?
11:53:49 <rt> with an emphasis on practical use, I understand the basics.
11:54:00 <shapr> I'm fond of Rabhi and LaPalme's 'Algorithms'
11:54:22 <ibid> i'd use okasaki's pfds instead
11:54:27 <skew> The only vaugely Haskell related book I have is "Categories for the Working Mathematician" :)
11:54:29 <shapr> I think you'll prefer Hudak's book over Thompson's
11:54:37 <ibid> but apart from that, i can't think of a must-have book
11:54:41 <shapr> skew: does it have Haskell source in it?
11:54:58 <shapr> I'm still working through Lawvere and Schanuel
11:54:59 <skew> shapr: I don't think so. I haven't read much, though
11:55:20 <rt> Oh well, I've goofed off enough to go to lunch.
11:55:25 <rt> thanks for the help everyone.
11:55:28 <skew> Was there a nice memoizing function somewhere?
11:55:44 <shapr> yah, somewhere in the standard libs
11:55:53 <skew> I'm remembering a memo :: (Eq a) => (a->b) -> (a->b)
11:55:56 <shapr> rt: feel free to hang out and ask questions, you'll get answers
11:56:26 <ibid> Marvin--: want to hear the golden rule of writing mathematics? :)
11:56:30 <Marvin--> Okasaki's Pure Functional Data Structures is as close to a must have as it gets, I think, even though it's not just Haskell
11:56:36 <Marvin--> ibid: please
11:56:44 <Marvin--> ibid: I'm a total noob at this
11:56:47 <Heffalump> how would something with that signature handle cache purging?
11:56:56 <Heffalump> or indeed having any kind of cache at all :-)
11:57:09 <skew> I don't know about purging.
11:57:18 <skew> Having cache can be done with black magics.
11:57:30 <shapr> there's the Memo module in the util package.
11:57:55 <shapr> that's what I was thinking about
11:58:08 <shapr> I think it only works with Integers or something
11:58:27 <kosmikus> shapr: yeah, apparently not ported to the new libraries
11:58:33 <shapr> oh no, it specifically doesn't work with integers
11:58:38 <ibid> Marvin--: actually, several: 1) never start a sentence with a symbol 2) never write two separate formulas without at least one word between them 3) all formulas should be treated like nouns, ie. if you read it aloud and say "blah" when you read a formula, instead of reading its semantics, it should still be intelligible english
11:58:40 <shapr> because it uses identity somehow
11:59:25 <shapr> kosmikus: too bad, would be handy.
11:59:38 <shapr> but I think I've seen some generically useful cache code go past on the mailing lists somewher.
11:59:38 <ibid> Marvin--: knuth has iirc a guide about this online
11:59:45 <ibid> Marvin--: and there are excellent books
11:59:46 <kosmikus> it should work with everything, not?
11:59:54 <shapr> it *should*
12:00:15 <skew> It's based off pointer equality and weak references
12:00:17 <shapr> but it uses pointer equality
12:00:42 <skew> What I really want is a String -> Int function that assigns numbers as needed.
12:00:53 <skew> I was trying to write up something with usafeInterleaveST
12:01:04 <ski> skew : hmm, though i saw a technique of doing a cache for memoizing, without using black magic ..
12:01:09 * ibid has one with unsafePerformIO
12:01:21 <ibid> it's a bad trick, anyway
12:01:22 <skew> I think I can do it with a lazily evaluated prefix tree, like the unique supply example
12:01:22 <ski> s/though/thought/
12:02:07 <kosmikus> you can do it with generic programming ...
12:02:21 <skew> How does that work?
12:02:47 * shapr disappears for purposes of offline socializing
12:02:56 <kosmikus> http://www.informatik.uni-bonn.de/~ralf/publications/WGP00b.ps.gz
12:02:57 <Marvin--> hm, the library doesn't have Mathematical Writing
12:02:59 <skew> ski: I don't see how you could avoid a cache in general
12:03:14 <skew> ski: Rather, how you could avoid black magic.
12:03:48 <skew> Without any structure on the values you can't tell whether you have computed for that value before
12:03:53 <ski> hmm, well i'm not totally sure. IIRC they exploited lazy evaluation critically ..
12:04:16 <skew> If you have structure of course you can make some lazily evaluated tree of all possible answers and go to the right cell
12:04:33 <skew> trivial cases being infinite lists of primes and the like.
12:04:40 <ski> yeah, i was possibly somrthing like that
12:04:59 <skew> I can do something like that here, mixing in unsafeInterleaveST to spread around some state
12:06:01 <skew> I enjoy how infinite structures built with unsafeInterleaveST are perfectly referentially transparent.
12:06:51 <kosmikus> skew: since when do you need unsafeInterleaveST to build infinite structures?
12:07:30 <kosmikus> ski: the link I gave explains it, although I think there must be something more recent
12:07:30 <skew> you don't
12:07:45 <ski> kosmikus : ok, thanks
12:07:56 <kosmikus> ski: you can fuse the "tabulate" and "apply" functions into one function
12:09:00 <skew> I just like things like infinite trees where each cell stores the number of other cells you visited first.
12:09:57 <skew> well, the tree factory should like in IO, I guess
12:10:01 <skew> live in IO that is
12:11:31 <ibid> Marvin--: you should probably include publisher name and address for all books in the bibliography :)
12:11:58 <Marvin--> ibid: the bibliography is far from finished
12:12:33 <ibid> Marvin--: it's a good idea to add the full bibliographical data to your .bib file when you first enter it
12:13:07 <ibid> Marvin--: (sorry, i have already advised too many master's students to be able to resist this kind of commenting;)
12:14:31 <Marvin--> ibid: and it's appreciated, but I *cough* don't have a .bib file, never got around to learning bibtex
12:14:36 <ibid> :)
12:14:37 * Marvin-- cowers
12:15:26 <ibid> bibtex is really easy, as long as you don't try to write your own bst's
12:15:39 <Marvin--> bst-what?
12:15:51 <ibid> bibiliography style
12:16:14 <ibid> Marvin--: do you use emacs?
12:16:20 <skew> is citeseer down?
12:16:47 <Marvin--> ibid: no, vim
12:16:49 <ibid> appears to be
12:16:52 <ski> seem so, for me, at least
12:17:08 <ibid> Marvin--: pity; emacs would give you templates to fill :)
12:17:31 <kosmikus> citeseer has been down the whole day ...
12:19:03 <Marvin--> grmbl, so I can't copy&paste bibtex entries from citeseer, how evil of them
12:19:15 <ibid> citeseer bibtex entries are not to be trusted
12:19:24 <ibid> they are frequently garbage
12:19:30 <SamB> skew: not exactly
12:19:31 <Marvin--> too bad
12:19:37 <SamB> skew: it moved
12:19:47 <SamB> http://citeseer.ist.psu.edu/
12:20:00 <ibid> citeseer.org is down
12:20:21 <SamB> oh? there is a .org?
12:20:51 <skew> google needs to update their cache then.
12:21:12 <SamB> skew: they crawl about monthly!
12:21:18 <ibid> is http://citeseer.ist.psu.edu/ an outdated mirror? it does not carry my conference paper
12:21:26 <ibid> citeseer at least used to do that
12:21:42 <SamB> ibid: hmm, I don't know. maybe it didn't really move...
12:22:05 <SamB> citeseer could use a lot of work
12:25:30 <Marvin--> damn it, did the Gast people never actually publish anything? How am I supposed to cite them if they don't publish
12:26:18 <SamB> Marvin--: "in preparation"?
12:26:37 <Marvin--> well, I don't know if it is "in preparation", it's been around forever
12:26:37 <monotonom> The Gast People, "Gast: A Novel Approach to Programming". Unpublished.
12:26:49 <SamB> or do you mean they had it done but didn't publish?
12:26:54 <ibid> Marvin--: how do you know them?
12:27:02 <SamB> do you have a copy of it?
12:27:04 <Marvin--> web site
12:27:11 <ibid> Marvin--: so cite the web site
12:27:21 <Marvin--> yeah, I guess
12:27:28 <ibid> if there is nothing better, that is
12:27:58 <ibid> remember to add a date of access, if the page itself is not dated
12:35:23 <kosmikus> Gast?
12:35:44 <Marvin--> Generic Automated Software Testing
12:36:01 <kosmikus> I needed that today for my thesis ;)
12:36:10 <kosmikus> they have an IFL 2002 paper
12:36:22 <Marvin--> hm
12:36:33 <Marvin--> wonder why citeseer didn't find that
12:36:36 <kosmikus> which is in the LNCS proceedings
12:37:00 <ibid> Marvin--: citeseer does not have all papers
12:37:03 <kosmikus> probably, because all the links containing information are only open for paying people
12:37:21 <ibid> Marvin--: citeseer has only papers that the authors have submitted there
12:37:29 <Marvin--> oh
12:37:43 <skew> google indexes citeseer.
12:37:44 <kosmikus> Marvin--: I'll msg you the bibtex entry, ok?
12:37:58 <ibid> Marvin--: did you try dblp?  springerlink?  acm digital library?  ieeexplore?
12:38:26 <Marvin--> kosmikus: lovely
12:38:38 <Marvin--> ibid: no, no, no and no... I'm a noob, remember
12:38:41 <ibid> :)
12:38:50 <ibid> it's a good idea to use all of them
12:39:05 <ibid> dblp is a golden resource on anything remotely related to logic
12:39:13 <ibid> well, almost anything
12:39:43 <ibid> http://www.informatik.uni-trier.de/~ley/db/
12:40:01 <ibid> http://springerlink.com/app/home/main.asp?wasp=g4pwpktgyqwhlr6lwvtp
12:40:34 <ibid> http://www.acm.org/dl
12:40:47 <SamB> I thought citeseer used google to search for missing cited papers?
12:40:54 <ibid> http://ieeexplore.ieee.org/Xplore/DynWel.jsp
12:41:04 <ibid> SamB: they only take submissions
12:41:31 <ibid> SamB: since they store a copy of the paper, they need a copyright permission
12:42:23 <ibid> i usually start by googling to get any references
12:42:55 <ibid> if any of them are likely to be available from acm, springer or ieee, i search them even if there is an online copy
12:43:03 <ibid> because it's the publisher's version that counts
12:43:13 <Marvin--> anybody got a bibtex entry for the Report?
12:44:06 <ibid> yes
12:44:09 <ibid> stand by
12:44:42 <ibid> hmm, i wonder where i've used it most recently...
12:50:26 <Marvin--> err, where should I look for HW bibtex entries?
12:50:59 <Heffalump> ACM?
12:51:11 <Marvin--> that's what I figured
12:51:17 <Marvin--> stupid search engine won't find it
12:51:51 <ibid> HW?
12:52:07 <Heffalump> Haskell Workshop
12:53:01 <ibid> ah
12:53:25 <ibid> there are no bibtex entries there, but you can find the articles themselves, as well as bibliographic data
12:55:10 <Marvin--> there are "Display in BibTex Format" links
12:55:30 <ibid> yeah, but does even one of them actually display in bibtex format?
12:55:53 <Marvin--> the one I found for QC looked good...
12:56:13 <Marvin--> but then, I don't know bibtex very well...
12:56:18 <ibid> i never got any bibtex data from such links
13:02:29 <Marvin--> hm, so how do I cite a web page?
13:03:03 <Heffalump> you try to avoid it
13:03:09 <Marvin--> no kiddin'
13:03:11 <Heffalump> but if you have to, then just cite it with the name of the web page and a URL
13:03:35 <Marvin--> I meant more technically, how do I write such a bibtex entry :(
13:03:41 <Marvin--> @unpublished?
13:03:41 <lambdabot> Sorry, I don't know the command "unpublished?", try "lambdabot: @listcommands"
13:03:45 * Igloo looks confused at "import Prelude hiding (foo)" working without -fnoimplicitprelude
13:04:11 <Marvin--> Igloo: ghc adds noimpliitprelude implicitly if you import Prelude explicitly
13:04:13 <skew> I'm pretty sure an explicit import of Prelude supresses the implicit import
13:04:16 <Marvin--> wow, did I just say that?
13:04:33 <Igloo> Ah, OK. I thought the concensus was that that would be an evil thing to do
13:04:58 <skew> I don't see why
13:06:53 <Igloo> It was "import Prelude (foo)" meaning less would be imported than without it rather than hiding I think
13:07:20 <kosmikus> Haskell Report, Section 5.6.1 ??
13:08:29 <Igloo> Oh, right! Wow, dunno how I missed that one  :-)
13:09:28 <Marvin--> so, uh, should I put the URL in the title field or something?
13:09:34 * Marvin-- feels lost
13:10:37 <Heffalump> hangon, I'll check
13:11:13 <Heffalump> put the URL in the note field
13:11:27 <Heffalump> I seem to have used @proceedings for the Haskell report (this was before the book came out)
13:11:35 <Heffalump> @proceedings{haskell98report,
13:11:35 <lambdabot> Sorry, I don't know the command "proceedings{haskell98report,", try "lambdabot: @listcommands"
13:11:36 <Heffalump> title = "The {Haskell 98} Report",
13:11:36 <Heffalump> note = "Available from URL: \url{http://www.haskell.org/definition/}",
13:11:36 <Heffalump> editor = "Peyton Jones, S. L. and Hughes, J.",
13:11:36 <Heffalump> year = 1999}
13:12:16 <ibid> the report is not a proceedings
13:12:37 <ibid> i usually use @misc for pure-url citings
13:13:10 <ibid> with pure-url citings, adding a date when it was accessed  is important (unless the document is explicitly dated)
13:14:22 <Heffalump> yeah, I'm not quite sure why I did use proceedings
13:14:29 <Heffalump> probably because I was inexperienced and just picked what worked
13:14:34 <ibid> :)
13:14:49 <ibid> anyway, for the current report, i use @article or @book, depending on mood
13:23:38 <ibid> anybody here willing to do a quick proofread of a 15-page summary of first-order logic?
13:24:32 <ski> is it very theoretic ? with lots of scary theorems ?
13:24:36 <ibid> yeah :)
13:24:47 <ibid> well, lots of scary definitions
13:24:54 <ibid> we are poor on theorems today
13:25:43 <ibid> theorems make themselves scarce around me :)
13:25:58 <ski> heh
13:27:17 <ski> i guess i could try to read it. but it might be well above my level, so i'm not sure if 'twould be much helpful ..
13:27:36 <ibid> anything's helpful :)
13:27:42 <ski> :)
13:28:10 <ski> so where's it, in that case ?
13:30:05 <ski> or is finding it a part of the trial ? :)
13:30:19 <ibid> stand by
13:30:19 <Marvin--> "The first rule of first-order logic..."
13:30:34 <ski> (especially as i don't know its name)
13:30:40 <ski> hmm
13:31:50 <ibid> i'm having latex errors
13:34:13 <ibid> http://www.mit.jyu.fi/antkaij/tmp/aure.pdf
13:34:16 <ibid> chapter 2
13:35:02 <ski> ok
13:38:10 <ibid> as usual, i'm in a hurry with this
13:38:26 <ski> i'm to check for typos and such also, i guess ..
13:38:31 <ski> :)
13:39:05 <ibid> :)
13:39:20 <ibid> semantic consistency would be more useful but also would take time
13:39:31 <ski> mm
13:41:15 <ski> "And such dream" ? should that be "And such a dream" or "And such dreams" ?
13:41:46 <ibid> where?
13:41:52 <ibid> (chapter 2?)
13:41:53 <ski> page 1
13:42:01 <stepcut> ibid: on page 2 (page 4 in the pdy) half way down "ey has no problems assuming that ....", is ey some pharse I don't know, or just a typo for 'eg'
13:42:21 <ibid> i just need the chapter; interactive search works only within a file
13:42:22 <ski> oh, mm, perhaps i was supposed to jump to chapter 2 .. forgot about that :/
13:42:39 <ibid> stepcut: ey is the gender-neutral third person singular
13:42:46 <stepcut> okay :)
13:43:04 <ibid> i.e. "he or she" :)
13:43:42 <stepcut> I do recall seeing that once or twice before, now that you mention it
13:43:43 <ski> i think some people have used "ve" as a non-male non-female third person (e.g. with reffering to AI's)
13:44:16 <Heffalump> those both sound very silly.
13:44:21 * Heffalump would recommend use of "they"
13:44:25 <ibid> yes, and some people use hir for "his or her"
13:44:26 <Riastradh> Rather than trying in vain to fix all of English's deficiencies, why don't you just use a better language?
13:44:34 <ibid> any new word sounds silly at first
13:44:40 <Riastradh> I recommend the use of 'he,' 'her,' or a better language.
13:44:43 <ibid> Riastradh: like finnish? :)
13:44:55 <Riastradh> I don't know Finnish well enough to say how much better it is than English.
13:45:17 <ibid> Riastradh: unfortunately, about half of the people in my class are ukrainan :)
13:46:41 <ibid> (oh, the uninflected hir is sie; it sounds sillier than ey)
13:51:39 <ibid> http://liw.iki.fi/liw/log/2004-03.html#20040303b ;)
13:51:45 <stepcut> I find that whenever someone uses any world besides 'he' or 'they' as a gender-neutral third person singular that it really disrupts my thought pattern. Especially if she uses 'she' as the gender-neutral world ;)
13:52:14 <ibid> stepcut: well, it's going to do that until it becomes commonplace
13:52:25 <ibid> and it won't become commonplace without such a period
13:53:24 <stepcut> of course, but perhaps deeply technical papers are not the best place to start with ;)
13:53:31 <ibid> it's not a start :)
13:53:43 <ibid> i did not invent that
13:53:56 <ibid> actually, i picked it up from reading a friend's weblog
13:54:24 <stepcut> in any case, I am just telling you how it affects me when I read it, not that I think you should change it
13:54:28 <ibid> ey is genderqueer, and so any gender-specific pronoun is going to be inappropriate
13:54:31 <ibid> :)
13:54:43 <ibid> i used to use they
13:54:51 <ibid> but "they are genderqueer" sounds silly
13:54:59 <Marvin--> it sounds queer
13:55:06 * Marvin-- ducks
13:55:08 <ski> what does that word mean ?
13:55:15 <ibid> when i'm obviously referring to one friend :)
13:55:38 <ibid> http://en.wikipedia.org/wiki/Genderqueer
13:57:13 <ibid> on ey: http://en.wikipedia.org/wiki/Spivak_pronoun
13:57:24 <Heffalump> ah, so people who reject basic genetics?
13:58:04 <ibid> no
13:58:24 <ibid> gender as a social construct is different from gender as a biological fact
13:58:52 <Riastradh> Just use 'it' and be done with it.
13:59:30 <ski> http://www.singinst.org/GISAI/meta/glossary.html#gloss_gender-neutral_pronouns
13:59:59 <ibid> civilized languages have a gender-neutral third person singular pronoun different from the equivalent of "it"
14:00:25 <Riastradh> Yes, but English is not one of them.  Deal.
14:00:40 <ibid> i deal
14:00:50 <ibid> by using ey :)
14:01:05 <ibid> in any case, i believe the word occurs only once in the whole booklet :)
14:01:08 <ski> "..., but "it" is simply inadequate to refer to AIs.  Not only is "it" used as a pronoun for inanimate matter, but "it" is also a general anaphor, like "this" or "that".  "It" can refer to anything at all in a sentence, not just the AI, so complex sentences - especially ones that use "it" for other purposes - become impossible to parse syntactically. ..."
14:01:51 <ibid> any comments on the content?
14:02:47 <ski> i'm trying to get through "2. Vocabularies and structures" ...
14:02:55 <ibid> heh
14:03:04 <ibid> what's hard in it?
14:03:16 <ibid> (that's not a rhetorical question)
14:04:38 <ski> hmm the "for all f : F and n : N it holds that s(f) = _|_ is equivalent to n > a(f)" part, i'm currently on
14:04:47 <ibid> ahh, there is a bug
14:04:54 <ibid> should be s(f, n)
14:05:00 <ibid> might make it parse for you :)
14:05:13 <ski> shouldn't s take a natural as well as an f, or is that inferred to be a(f) ?
14:05:18 <ski> oh
14:06:21 <ski> (it seemed a bit strange to forall the n, and then just use it on the rhs ...)
14:12:52 <ski> s(elem,1) = S ??
14:13:09 <ski> s/S/C/  no ?
14:13:15 <ibid> no
14:13:34 <ibid> um
14:13:36 <ibid> where
14:13:48 <ski> in Example 2.4
14:13:58 <ski> you say S = {N,C}
14:14:50 <ski> so shouldn't it be  s(elem,1) = C  and not  s(elem,1) = S  ?
14:14:50 <ibid> yes, C
14:14:55 <ski> ok
14:15:07 <ibid> i was thinking of NBG, which i haven't written yet:)
14:17:12 <ibid> and actually NBG is an unsorted theory :)
14:17:23 <ski> ok
14:29:18 <rt> bleh, my head hurts.
14:29:37 <shapr> liquid lunch?
14:29:44 <ski> too little haskell ?
14:29:55 <rt> nope, just stupid programs.
14:29:59 <rt> and stupid people.
14:30:18 <rt> who would think that computer graphics could be hard?
14:30:23 <shapr> me?
14:30:37 <shapr> looks easy in the movies
14:30:49 <shapr> then I tried some 3D modelling and OpenGL stuff.
14:30:59 <shapr> HOpenGL is nifty
14:31:47 <shapr> rt: what sort of stuff are you doing?
14:32:02 <rt> trying to debug some water effects.
14:32:24 <shapr> have you ever tried unit testing with graphics? is it workable?
14:32:39 <ibid> it would be super if i had all the time in the world to write...
14:32:50 <rt> it would be if people did disciplined development while working on films.  They don't. :-)
14:33:12 <rt> this code was written by somebody who left, and nobody understands how (or even why) it works.
14:33:15 <shapr> disciplined development is just rare.
14:34:24 <rt> I'm sure eventually it will look great.
14:34:45 <rt> it may cause me an embolism in the process, but hey, ya gotta break a few eggs.
14:34:51 * shapr grins
14:35:16 <shapr> I'd rather do programming that doesn't involve blood flow problems.
14:35:18 <ibid> should i start using \varphi and friends for formulae?
14:35:24 * rt decides to loaf for twenty minutes until my next meeting starts.
14:35:41 <ski> ibid : what's that ?
14:35:45 <shapr> do you end up mixing various languages for movie graphics?
14:36:04 <rt> the average technical director knows and uses about 13 different languages.
14:36:05 <ibid> ski: a symbol for phi?
14:36:15 <shapr> yow
14:36:18 <shapr> that's a lot
14:36:25 <rt> it's too many.
14:36:47 <ski> ibid : hm. for which formulae ?
14:36:58 <shapr> I guess I expected a common interchange format and for each group to use their language of choice.
14:38:04 <rt> we use a lot of languages of our own creation, as well as python, perl, shell, various make systems, and two or three different scene description languages.
14:38:46 <shapr> that does sound overly complicated.
14:39:43 <rt> "We put the 'overly complicated' in motion pictures."
14:39:48 * shapr grins
14:40:18 <shapr> web development usually involves only four or so languages.
14:40:53 <shapr> though I'm not sure if html/xml counts as a language.
14:41:24 <rt> yep, by my book it does.
14:41:26 <Riastradh> Language, yes.  Programming language, no.
14:41:43 <ibid> ski: i know use p, q and so on as generic placeholders (metavariables) for formulae in the booklet
14:42:37 <ski> ibid : oh, ok, that.
14:43:03 <ibid> now, not know :)
14:43:25 <ozone> rt: you don't happen to live in canada, do you?
14:43:34 <ozone> morning all
14:43:38 <shapr> g'day ozone 
14:43:39 <ozone> look, i'm up before 11am!
14:43:43 <stepcut> gah! Naming things sucks
14:43:51 <ski> ibid : you now use p instead of (previously) phi ?
14:44:00 <shapr> I'm up after 11pm
14:44:26 <stepcut> you're all wrong, it's 2:45 PM
14:44:27 <ozone> my brain only wakes up at about 11pm
14:44:34 <rt> ozone: nope, San Francisco, CA.
14:44:38 * Marvin-- tries to figure out who Uli Martens is
14:44:54 <ozone> rt: right, just wondering
14:45:06 <ibid> ski: no, i now use p, i am considering using phi
14:45:11 <shapr> Marvin--: appears to be a linux-kernel person
14:45:20 <ibid> ski: how's the booklet?
14:45:33 <ozone> crikey, people use MSYS under win98 to build ghc
14:45:37 <ozone> crazy buggers
14:45:52 <Marvin--> shapr: apparently we exchanged gpg fingerprints at some point
14:45:57 <Igloo> crikey, people use windows
14:46:02 <shapr> Marvin--: seems likely, he's a #debian.de guy
14:46:10 <ozone> Marvin--, shapr: geeks!
14:46:18 <shapr> Marvin--: check it - http://www.youam.net/
14:46:29 <ski> ibid : i've now come to the Big Scary Definitions part (TM), in "3. First-order languages" ..
14:46:30 <shapr> ozone: what, just because you FORGOT to bring your key.
14:46:41 <ibid> :)
14:47:13 <ozone> shapr: much like how i forgot that i didn't need an enema today!
14:47:30 <Marvin--> oh, must've met him at udebcamp then
14:48:26 <shapr> ozone: did you ever send me your public GPG key?
14:49:32 <shapr> actually, key signings is a neat way to check social connections without the requirement of orkut or something
14:49:53 <shapr> rt: oh hey, I'm Shae Erisson, and probably easy to find in the orkut Haskell community.
14:49:55 <Heffalump> have you seen FOAF?
14:50:06 <Heffalump> (google for it if not)
14:50:32 * Marvin-- is probably not easy to find in the orkut community
14:50:52 <ozone> shapr: most likely not, since i don't even think i have a .gnupg directory
14:50:59 <ozone> or maybe i do, and i never use it.  i forget. ;)
14:53:11 <shapr> Heffalump: that's really spiffy
14:54:02 <Heffalump> livejournal can export it, too
14:54:15 <Heffalump> but I don't know of any good way to merge the LJ export with hand-crafted stuff
14:56:54 <stepcut> mmm, pycaml
15:03:12 <shapr> rt: you're a member of both "down with evolution" and "creationists are dumb" communities. you wouldn't happen to be a discordian would you?
15:15:44 <ski> amgine2 : hi
15:15:49 <amgine2> hey ski :)
15:16:20 <amgine2> i'm not sure if it was you that told me but there was a function to see if a string was contain in another string, it would return either Nothing or Just {}
15:16:24 <amgine2> *[]
15:16:52 <ski> not me either :)
15:17:01 <amgine2> crap
15:17:02 <amgine2> lol 
15:17:21 <ski> i don't remember it ATM RN, at least
15:17:32 <amgine2> ?
15:17:49 <ski> (at-the-moment right-now)
15:19:01 <ski> are you looking for such a function now ?
15:19:12 <amgine2> yeah
15:19:15 <amgine2> so it's ok
15:19:31 <ski> what do you mean by contain, here ?
15:19:48 <ozone> amgine2: List.intersect list1 list2
15:19:50 <amgine2> substring i.e. Test in gsdTest would return true
15:19:54 <amgine2> ohhh
15:19:55 <ski> contiguous ? ordered ? just contains all characters ?
15:20:03 <ozone> if the intersection is [] ... well, you can figure it out :)
15:20:12 <amgine2> ozone good point
15:20:15 <amgine2> let me test that
15:20:28 <ozone> (keep in mind that's an intersection only, not a continuous sublist)
15:21:33 <ozone> anyhoo, me off
15:21:53 <ski> ozone : you're leaving now .. ?
15:22:24 <amgine2> ozone i believe that will work
15:22:40 <ski> i'm not sure
15:23:38 <ski> do you want  substring "Test" "Tgessdt"  to give True ?
15:23:48 <amgine2> nope
15:24:00 <ski> or  substring "Test" "tseT"  ?
15:24:20 <amgine2> i just wish to see if a substring is contained withing a string
15:24:25 <amgine2> but the intersect will work
15:24:30 <amgine2> i've just tested it
15:24:45 <ski> i think the intersect will give True for  substring "Test" "Tgessdt"
15:25:00 <ski> am i worng ?
15:25:19 <amgine2> yes
15:25:58 <amgine2> hmm
15:26:02 <amgine2> do you know another way
15:26:06 <amgine2> even though this will work
15:26:18 <ski> List> intersect "Test" "gsdTest"
15:26:19 <ski> "Test"
15:26:19 <ski> List> intersect "Test" "Tgessdt"
15:26:19 <ski> "Test"
15:26:19 <amgine2> for what i need it to do
15:26:28 <amgine2> yeah
15:26:35 <amgine2> you were right about that
15:27:01 <ski> well, you could of course write a recursive function to check it ..
15:27:09 <amgine2> yeah i know
15:27:16 <amgine2> but you would figure there would be one already
15:27:17 <ski> but perhaps one can do somthing else, also ... hmm
15:29:51 <ski> substring as0 as1 = any (and . zipWith (==) as0) (tails as1)
15:29:58 <ski> would that be correct, hmm ?
15:30:16 <amgine2> i'm not sure
15:30:25 <amgine2> that is would take me a bit to understand it
15:31:40 <ski> hmm, that seem not ok, i think i get True when i shouldn't ..
15:32:32 <ski> hmm
15:32:38 <Lemmih> Is it possible to compile HOpenGL with GHC-6.2?
15:32:57 <ski> (oh, now i see my error)
15:33:19 <Igloo> The hopengl that comes with it should work AFAIR
15:33:32 <Lemmih> oh
15:33:53 <Igloo> ski: I'd use isPrefixOf for the inner bit
15:34:08 <ski> yeah, that is prolly better
15:34:30 <stepcut> there are two version of HOpenGL, one on the authors website that is obsolete, and a new version that is included in ghc
15:34:43 <stepcut> and under active development
15:34:54 <ski> substring as0 as1 = any (isPrefixOf as0) (tails as1)
15:35:35 <ski> amgine2 : i think that one is working
15:35:56 <Igloo> as0 `isPrefixOf` reads nicer. It's not efficient, of course.
15:36:06 <stepcut> The stuff in ghc is majorly different from the old HOpenGL, so you need to make sure you use the right documentation
15:36:16 <ski> Igloo : right
15:36:18 <stepcut> namely, the examples and source code included with ghc
15:36:21 <Igloo> But more efficiency gives you a less beautiful implementation
15:37:50 * ski remembers doing some function related to this, when doing approximate string-matching in algs.
15:40:38 <amgine2> ski
15:40:41 <amgine2> i got it to work
15:40:46 <amgine2> intersect is good enough :)
15:41:07 <amgine2> what does any ?
15:41:23 <amgine2> nm
15:41:24 <amgine2> openWindow :: ls -> wdef ls ps -> ps -> GUI ps ps
15:41:32 <amgine2> i wish to creade a window
15:41:50 <amgine2> openDialog :: ls -> ddef ls ps -> ps -> GUI ps ps
15:41:52 <amgine2> or dialog
15:42:13 <ski> any p = or . map p   -- IIRC
15:42:25 <amgine2> what does map do ?
15:42:46 <ski> @eval map (\x -> x * x) [0,1,2,3,4,5]
15:42:46 <lambdabot> [0, 1, 4, 9, 16, 25]
15:43:04 <amgine2> ohh
15:43:20 <amgine2> i recall now
15:45:09 <amgine2> @eval :t isPrefixOf
15:45:09 <lambdabot> (line 1, column 1):
15:45:09 <lambdabot> unexpected ":"
15:45:09 <lambdabot> expecting white space or simple term
15:45:48 <ski> @type isPrefixOf
15:46:01 <ski> @type List.isPrefixOf
15:46:13 <Riastradh> @type \r\n:m List\r\n:t isPrefixOf
15:46:15 <Riastradh> Bah.
15:46:18 <Segora> @help
15:46:18 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
15:46:22 <amgine2> what do is do ?
15:46:22 <ski> d'oh
15:46:23 <Segora> @listcommands
15:46:24 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
15:46:37 <ski> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
15:46:46 <amgine2> if it's of the same type ?
15:47:06 <Segora> looks like the list of commands is truncated
15:47:10 <ski> amgine2 : sorry ?
15:47:28 <amgine2> what does isprefix do ?
15:47:37 <amgine2> a is a comparable class
15:47:40 <Lemmih> How do I compile an OpenGL program with GHC? (I've tried with "ghc -package OpenGL --make [sourcefile]" but it still complains about a missing GLU module)
15:47:46 <Lemmih> (Man, I just hate asking stupid questions)
15:47:49 <ski> List> isPrefixOf "abc" "abcdef"
15:47:49 <ski> True
15:47:49 <ski> List> isPrefixOf "abc" "xabcdef"
15:47:49 <ski> False
15:48:04 <amgine2> wierd
15:48:17 <amgine2> ohhh crap
15:48:21 <ski> it checks whether the first list is a prefix of the second
15:48:21 <amgine2> i was doing something wrong
15:48:41 <amgine2> yeah that's what i figured but i was typing :t isPrefix foo1 foo2
15:49:01 <ski> amgine2 : a is a type that is constrained to be in the Eq type class, above
15:49:25 <amgine2> yes i understand that
15:49:30 <amgine2> a must be comparable
15:49:34 <ski> s/type/type variable/
15:49:42 <ski> mm
15:54:19 <amgine2> containsString :: String -> String -> Bool 
15:54:20 <amgine2> containsString s1 []     = False 
15:54:20 <amgine2> containsString s1 s2      | (isPrefixOf s1 s2) == True = True 
15:54:20 <amgine2>                | otherwise = containsString s1 (tail s2)
15:54:26 <amgine2> cool i acctually made one too :)
15:55:26 <amgine2> now let's try to have some gui
15:56:08 <ski> containsString s1 s2
15:56:24 <ski>   | s1 `isPrefixOf` s2 = True
15:56:38 <ski>   | otherwise          = containsString s1 (tail s2)
15:56:43 <mattam> containsString s1 [] = False ? what if s1 is [] ?
15:56:44 <ski> is better
15:56:58 <amgine2> ohhh cool  forgat about those `
15:57:05 <ski> also, pattern match on s2, instead
15:57:06 <amgine2> not likley going to happen
15:57:12 <amgine2> ?
15:57:27 <mattam> you know
15:57:33 <mattam> :)
15:58:08 <ski> containsString s1 [    ] = null s1
15:58:24 <ski> perhaps
15:58:55 <amgine2> openDialog :: ls -> ddef ls ps -> ps -> GUI ps ps anyidea on how to use this ?
15:59:15 <Igloo> Anyone know if Text.Html is WASH, part of WASH or completely separate?
15:59:28 <ski> also, the function doesn't need to be restricted to just Strings, any Eq a => [a] would work
15:59:38 <amgine2> yes
15:59:43 <amgine2> i understand that :)
15:59:48 <stepcut> Igloo: i would guess independant
16:00:20 <amgine2> anyone has idea on how to use the Graphics.UI.ObjectIO.StdWindow
16:00:24 <ski> amgine2 : are you sure you want all those type variables in the signature for openDialog ?
16:00:29 <amgine2> i can figure out what those parameters mean
16:00:33 <amgine2> no explenation of them
16:01:55 <amgine2> anyone ? :)
16:03:45 <ski> hmm, thought you said you *could* figure out what they meant ..
16:03:56 <amgine2> lol
16:03:57 <amgine2> i mean can't
16:04:00 <amgine2> but working on it
16:04:05 <amgine2> ps might be a pointer like an id
16:04:11 <ski> perhaps there's some docs somewhere that explains them
16:04:41 <amgine2> i am reading the ghc docs
16:04:47 <amgine2> i'll check the net
16:04:51 <ski> (or perhaps it's sufficiently similar to Cleans ObjectIO so that one can look at the (presumably existing) docs for those)
16:11:07 <amgine2> what does initialize do in haskell ?
16:11:33 <ski> i dunno. what module ?
16:11:44 <amgine2> ohhh iguess it's part of ObjectIO
16:11:51 <amgine2> i'm looking at this expample if anyone is interested
16:11:58 <ski> (perhaps it's some ObjectIO-specific thing ..)
16:12:21 <amgine2> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/hslibs/object-io/Examples/ClipboardViewer/Main.hs?rev=1.1.12.1&content-type=text/plain
16:12:28 <amgine2> i believe so :)
16:14:43 <ski> initialise seems to be some function specific to this example module, that is called from main, and whose result is passed to startIO (presumable as some kind of initialization information)
16:15:06 <amgine2> yeah like a process id
16:15:12 <amgine2> i was kind of thinking along those lines
16:15:13 <amgine2> :)
16:16:21 <ibid> ski: any further comments? i'm going to bed soon, and then it's too late :)
16:17:29 <amgine2> is there a way to import all ObjectIO.* ?
16:17:53 <ski> ibid : hmm, i've read a bit more, and nothing i noticed needing commenting. (though i'm a bit tired now also, ...)
16:18:03 <ibid> ok
16:18:09 <ibid> how does it read?
16:19:20 <ski> well, perhaps a bit heavily. but that could well be because i'm tired, and because 'twas some time ago i looked at this kind of definitions in detail ..
16:20:11 <ibid> ok
16:20:13 <ibid> thanks
16:21:10 <ski> (perhaps, i would have liked, first some small motivating examples + standard intuition regaring the interpretation of things like the function 'a' e.g. (arity), instead of taking that afterwards. but i guess that is a style thing ...)
16:21:46 <amgine2> D:/LL_Hack/dialogTest.hs:9: Variable not in scope: `startIO' 
16:21:46 <amgine2> D:/LL_Hack/dialogTest.hs:10: Variable not in scope: `closeProcess'
16:21:50 <amgine2> anyone know where they are ?
16:21:58 <amgine2> they don't appear to be in ObjectIO
16:22:17 <ski> (it's a little bit harder to understand the various definition when one doesn't know the why's yet ..)
16:22:28 <amgine2> lol
16:22:48 <amgine2> ski is there a way to import all ObjectIO.*.* ?
16:23:31 <ski> hmm, i dunno. i'm not so familiar with hierarchical modules
16:23:37 <amgine2> i see
16:23:38 <amgine2> bummer
16:23:44 <amgine2> the damn example won't run
16:23:47 <amgine2> damn it lol
16:24:06 <ski> perhaps they have moved some definitions to other modules .. ?
16:24:16 <amgine2> i know i've been looking into that
16:24:28 <amgine2> but can't find one with StartIO and processclose
16:24:51 <ski> ibid : (you got those comments above, also ?)
16:25:13 <amgine2> ?
16:25:21 <amgine2> wrong person sorry ski
16:25:33 <amgine2> ski thought you meant me
16:27:01 <ibid> ski: i intend to provide the motivation in the lecture (besides, i assume people already know the whys:)
16:27:27 * stepcut reads Generalising Monads to Arrows for the nth time
16:27:40 <amgine2> DAMN IT
16:27:52 <amgine2> usless unupdated docs
16:29:22 <ski> ibid : ok
16:29:46 <shapr> stepcut: ain't that a great paper?
16:29:53 <ski> ibid : (well, 'twas some time agi for me ..)
16:30:26 <stepcut> shapr: not nearly as good as generalising arrows to spears, but still pretty damn good
16:31:21 <amgine2> does anyone know ObjectIO ?
16:32:21 <stepcut> shapr: I am thinking about putting together a "unix" combinator library for piping the output of unix commands around. Similar to what is described on this page: http://okmij.org/ftp/Computation/monadic-shell.html
16:33:04 <stepcut> but, as cool as that is, it only handles stdin/stdout, but not stderr
16:33:07 <ski> StdProcess.startIO
16:33:12 <shapr> stepcut: heh, the spears paper will be out around the same time as my clone of emacs that's written in Haskell. Hemacs!
16:33:55 <ski> amgine2 : heard that ?
16:33:58 <amgine2> ski
16:34:03 <stepcut> So I am thinking, that maybe using arrows, I can make a better unix combinator library which support for stderr and error codes
16:34:05 <amgine2> ski: jesus i looked at that one
16:34:08 * ibid goes to bed, bbl
16:34:11 <amgine2> even did a search on it for startio
16:34:13 <amgine2> thanks man
16:34:19 <amgine2> i can't believe i made that mistake
16:34:23 <ski> ibid : good dreams !
16:34:26 <ibid> :)
16:34:33 * ibid dreams of formulae today
16:34:33 <Pseudonym> Dream of haskell.
16:34:36 <Pseudonym> That's always good.
16:34:46 <Pseudonym> http://www.deftcode.com/archives/every_language_war_ever.html
16:34:49 <Pseudonym> Very amusing.
16:35:02 <stepcut> shapr: you should base in on HOpenGL --> HEmacsGL
16:42:37 <shapr> g'day Pseudonym! you should talk to rt when he's awake.
16:43:14 <Pseudonym> G'day.  Why?  Is he a good conversationalist?
16:43:49 <shapr> from what I've seen, he's a heavy duty computer graphics geek.
16:43:53 <Pseudonym> Ah, cool.
16:44:10 * Pseudonym is hacking on two graphics-related projects at the moment
16:44:15 <Pseudonym> Both in C++.
16:49:05 <shapr> hi jaap, what can we do for you?
16:52:52 <shapr> jaap: looking for Haskell info?
16:54:25 <jaap> shapr: not particularly, i was just curious to see what people talk about
16:55:48 <skew> hi jaap
16:56:02 <skew> where is "stein"?
16:56:23 <jaap> the computer or the village?
16:56:35 <shapr> well, the url to the logs is available in the channel topic, but in summary, functional programming, category theory, and ...
16:56:37 <ski> skew : /whois stein
16:56:41 <shapr> hm, what else?
16:57:10 <ski> programming in general ?
16:57:13 <shapr> ski: since skew is also at caltech, I think he's asking about physical location.
16:57:18 <shapr> that too!
16:57:26 <monotonom> The Stein programming language. :)
16:57:28 <jaap> ah, i see, it's in blacker 51
16:57:40 <jaap> sitting on the floor
16:57:45 <jaap> next to a pillow
16:57:45 <skew> funny, ITS doesn't seem to know about it.
16:58:08 <ski> the OS ??
16:58:30 <skew> "jaap (~jaap@stein.caltech.edu) has joined #haskell"
16:58:58 <jaap> hmmm... i had to ask its for a couple more IP addresses while figuring out OpenGenera, so it may be that they somehow weren't registered properly?
16:59:32 <skew> could be.
17:00:57 <skew> well, I'm brandon. I see nobody took Jaap as a nick
17:01:16 <jaap> at any rate, FYI, there are at least a half dozen villages and towns called stein scattered across europe
17:01:24 <jaap> one of which is my home town
17:02:13 <skew> Ah. It sounded like a reasonably common name
17:04:37 <skew> I'm thinking about modelling commicating components with arrows, for expressing distributded algorithms
17:05:04 <jaap> like dataflow analysis?
17:05:25 <Pseudonym> As a matter of interest, how well do arrows support dynamic topologies?
17:05:45 <skew> not that well, I would think.
17:05:46 * jaap is very ignorant about that sort of stuff
17:06:06 <skew> you can certainly make an arrow taking Either (aarow-to-install-here) value
17:06:26 <skew> that behaves like the last arrow you sent it, but I don't know about general reconfiguration
17:06:44 <Heffalump> I don't quite know what you mean by reconfiguration
17:07:16 <Pseudonym> Well, arrows support "flow" around an arbitrary circuit.
17:07:31 <skew> I mean more general graph like things
17:07:46 <Pseudonym> Whereas monads only support linear "flow", and MonadPlus only supports tree/DAG "flow".
17:07:51 <skew> like taking some output from one arrow and sending it to another
17:08:00 <Pseudonym> My question is: What if you want to change the graph dynamically?
17:08:17 <Pseudonym> This is not theoretical, BTW.  It's a real problem I'm dealing with in some of my C++ code.
17:08:46 <skew> well, if you can draw a box around a subgraph you want to replace you can use a combinator like I described
17:09:04 <Pseudonym> Well, here's a simpler problem.
17:09:08 <skew> Other than that, I'm a bit worried about all these nested tuples running around as well
17:09:28 <Pseudonym> You want to delete a node in a network of stream processors.
17:09:48 <Pseudonym> We'll assume that its output isn't being used by anyone else.
17:09:57 <Pseudonym> Can I do that?
17:10:31 <skew> not exactly
17:10:37 <skew> the network is static
17:10:47 * Pseudonym nods
17:10:52 <Pseudonym> See, I want a dynamic network.
17:10:58 <skew> you can approximate it by making the processor take a control input, that tells it to behave as the null processor
17:11:06 <Pseudonym> True.
17:11:13 <Pseudonym> But I actually want to delete it.
17:11:20 <Pseudonym> Like, it's taking up memory.
17:11:25 <skew> that's just operational semantics :)
17:11:26 <Pseudonym> Hmmm.
17:11:40 <Pseudonym> I don't mind if it's expensive, but I don't want to rebuild the whole network.
17:11:40 <skew> well, memory could be freed if you had a permenant thing
17:12:21 <skew> Actually, if you are writing the arrow yourself you could have operations to alter the network
17:12:28 <Pseudonym> True.
17:12:47 <Heffalump> I'm not sure if there's any benefit to arrows rather than monads then
17:13:04 <Pseudonym> Heffalump: Sure there is.  If the network is static, arrows work.
17:13:05 <skew> it would be more like a functional update performed offline, unless you want to be clever
17:13:13 <Heffalump> one of the main arguments for them is that they make static structure explicit which exposes optimisation opportunities
17:13:34 <skew> Heffalump: I've never heard of optimization as an advantage for arrows.
17:13:48 <Heffalump> read the original paper, then :-)
17:13:48 <skew> at least not by the compiler
17:13:52 <Pseudonym> "Optimization" is possibly the wrong term here.
17:14:07 <Heffalump> yeah, ok
17:14:08 <Pseudonym> Yes, it's not optimisation by the compiler.
17:14:14 <Pseudonym> It's optimisation by the library.
17:14:21 <skew> I have an idea.
17:14:38 <skew> Some of the problems go away if you don't try to directly run the network the user describes,
17:14:40 <Pseudonym> If something provides information, combinators can use that information.
17:14:59 <skew> but instead take apart the structure and make a graph or something out of it
17:15:13 <Pseudonym> Hmmm.
17:15:23 <skew> you still have nice notation for building it, but it should be more flexible
17:15:35 <Heffalump> hmm, I guess arrows can still help
17:15:36 <Pseudonym> So you mean "compile" the graph into a network of arrows?
17:15:53 <Heffalump> the "static" stuff is really run-time anyway
17:15:56 <skew> other way around. Compile a network of arrows into something directly implemented as a graph
17:16:05 <Heffalump> (unless the compiler happens to partially evaluate it)
17:16:11 <Pseudonym> See, that doesn't solve my problem.  I don't mind the operation being locally expensive, but rebuilding the entire network just to do a local change is too much, IMO.
17:16:52 <Pseudonym> I have a suspicion that using Haskell threads and channels/ports might be the way to implement my specific problem in Haskell.
17:16:58 <skew> I mean you invent some data structure that's easy to edit and run values through.
17:17:07 <skew> (maybe a bunch of threads)
17:17:14 <Pseudonym> Haskell threads are fairly lightweight.
17:17:19 <Pseudonym> This would be easier in Erlang. :-)
17:18:10 <skew> then make your combinator for running the arrow translate the computation into that form once, before you run it. (types might be a pain, I guess)
17:18:57 <shapr> the Yampa arrows can change their behaviour
17:19:23 <Pseudonym> Really?
17:19:26 <shapr> yup
17:19:27 <Pseudonym> Interesting.
17:19:33 <shapr> quite thoroughly
17:19:45 <shapr> you can give a list of arrows, and their switchable behaviour
17:19:52 <shapr> and that list can modify itself
17:19:55 <skew> doesn't that work like what I mentioned, where you pass in a new behaviour or something
17:19:56 <amgine2> question
17:20:07 <amgine2> foo <- some result
17:20:15 <amgine2> function foo x1 where
17:20:31 <amgine2> foo is a list of blah, and it uses the prior foo result
17:20:37 <shapr> hey Arnia 
17:20:37 <amgine2> why is it not accessible ?
17:21:00 <Arnia> hey shapr
17:21:03 <Arnia> Boing :)
17:21:04 <amgine2> main = do statusTxtId <- openIds 1     
17:21:04 <amgine2>        startIO NDI () (openDialog () hello) []
17:21:05 <amgine2> ....
17:21:12 <amgine2>      statusTxt = TextControl "TESTING LOSER"
17:21:12 <amgine2>                     [ ControlId statusTxtId ]
17:21:22 <amgine2> why is statusTxtId out of scope now ?
17:21:38 <monotonom> indentation
17:21:45 <ski> amgine2 : bad indentation (premature ending of do-block)
17:21:48 <amgine2> no i don't believe so
17:21:53 <ski> do kljkjjklj
17:21:55 <ski>    kljhkjkljkl
17:22:17 <amgine2> sorry for this paste
17:22:18 <amgine2> main = do statusTxtId <- openIds 1      
17:22:18 <amgine2>        startIO NDI () (openDialog () hello) [] 
17:22:18 <amgine2>        where  
17:22:18 <amgine2>           hello     = Dialog "Blah"  
17:22:18 <amgine2>                     ( statusTxt   
17:22:20 <amgine2>                     :+: continueBtn           -- display continue button 
17:22:22 <amgine2>                  ) [WindowClose (noLS closeProcess)] 
17:22:24 <amgine2>           continueBtn     = ButtonControl "Show"  
17:22:26 <amgine2>                       [ ControlFunction (noLS test) 
17:22:28 <amgine2>                       , ControlTip "Press to Continue" 
17:22:30 <amgine2>                       ] 
17:22:32 <amgine2>           statusTxt = TextControl "TESTING LOSER" 
17:22:34 <amgine2>                     [ ControlId statusTxtId ] 
17:22:36 <amgine2>           test ps = return ps
17:22:40 <amgine2> i don't think it's the indentation
17:22:42 <amgine2> could it be use of where ?
17:22:42 <ski> still bad indentation at top
17:22:56 <amgine2> startIO starts right after do
17:22:59 <ski> the second line should be indented 3 more spaces
17:23:00 <monotonom> statusTxtId is not available inside the where part.
17:23:05 <amgine2> my program does tabs
17:23:23 <Heffalump> turn them into spaces
17:23:34 <Heffalump> tabs cause all sorts of hell getting indentation right
17:23:36 <amgine2> monotonom how so ?
17:23:36 <monotonom> In fact nothing is available in the where part.
17:23:45 <ski> the "startIO ..." should be aligned with "statusTxtId <- ...". *not* with "do ...." !
17:23:49 <monotonom> It is the way it is.
17:24:03 <amgine2> that can't be right
17:24:04 <monotonom> (I didn't design the language this way.)
17:24:06 <amgine2> here is another program
17:24:10 <amgine2> that is an example
17:24:19 <ski> also, you can't use monadically bound variables in the where
17:24:20 <amgine2> initialise [viewid,showid, setid] = openDialog () clipview      -- Open the clipview dialog 
17:24:21 <amgine2>      where 
17:24:21 <amgine2>           clipview 
17:24:21 <amgine2>                = Dialog                    -- The clipview window is a Dialog 
17:24:21 <amgine2>                     "Clipboard Viewer"          -- The title of 
17:24:23 <amgine2> ......
17:24:40 <amgine2> it uses the viewid, showid,setid withing THE where clause
17:24:48 <Heffalump> stuff bound in do generators is not available in where clauses because it's not clear which bit the where part should be associated with
17:24:53 <monotonom> Those are available in the where part alright.
17:25:00 <amgine2> how come ?
17:25:02 <Heffalump> those aren't bound inside the do block
17:25:03 <amgine2> why are they different
17:25:07 <amgine2> ohhh
17:25:14 <monotonom> It is the way it is.  I didn't design the language this way.
17:25:18 <amgine2> they become kindo f like global variables for the entire function
17:25:23 <Heffalump> yep.
17:25:24 <skew> where hangs off an expression, like a backwards let
17:25:27 <amgine2> no i understand monotonom i'm just trying to understand it
17:25:34 <skew> or maybe it's part of the function synatx
17:25:37 <Heffalump> monotonom: there's a good reason, too
17:25:40 <amgine2> i see cool
17:25:49 <Heffalump> skew: it hangs off a declaration, actually
17:26:04 <rt> hmmm.  my version of ghc on this machine is old.
17:26:04 <Heffalump> a let attaches to an expression
17:26:06 * rt updates.
17:26:09 <skew> ok, declaration syntax.
17:26:39 <skew> Anyway, you could rewrite your program (almost?) equivalently by putting those where bindings in a let wrapped around the entire function body instead
17:27:03 <skew> if you write it like that the behvaiour you see should look reasonable
17:27:11 <Pseudonym> Greetings rt.
17:27:26 <Heffalump> you can deal with your where issues either (a) by parametrising the things in the where clause by the variables needed
17:27:37 <Pseudonym> rt: I should warn you that I'm "the opposition".  Used to work for Dot C.
17:27:42 <Heffalump> or (b) by turning the where declarations into lets and putting them at the right places in the do notation
17:27:54 <amgine2> sorry was away
17:28:05 <monotonom> "z = do { x<-y; blah } where stuff" is first translated to "z = (y >>= \x. blah) where stuff", so x disappears altogether by the time you read the where part.
17:28:06 <amgine2> initialise [viewid,showid, setid]  anywho dosen't that mean init... accepts a list ?
17:28:24 * rt doesn't do rendering software anymore.  Just shuffles shots through production.
17:28:34 <Pseudonym> Ah, OK.  No problem then.
17:28:39 <skew> and dies messily if it doesn't have three elements, unless there are other clauses
17:28:50 <Heffalump> amgine2: yep
17:28:54 <Pseudonym> So I guess you're not interested in a half-written optimising shading language compiler written in Haskell, then?
17:28:59 <rt> leaves more time for recreational programming.
17:29:10 <rt> nah, not that much.
17:29:12 <Heffalump> monotonom: it doesn't disappear, the issue is one of scoping
17:29:17 <Pseudonym> Fairy nuff.
17:29:18 <amgine2> it must mean openIds returns a list
17:29:19 <amgine2> cool
17:29:26 <Heffalump> OIC, yeah, it does sort of disappear cos the scope closes, sorry
17:29:30 <rt> if it doesn't run on nvidia hardware, I stopped caring. :-)
17:30:11 <Pseudonym> :-)
17:31:31 <rt> I keep thinking about doing a shading language based upon a functional programming langauge though.
17:31:39 <rt> Maybe some day for my toy raytracer.
17:31:53 <Pseudonym> Yes.  Apparently Toro had one which was based on continuations.
17:32:03 <Pseudonym> Matt keeps meaning to publish something about it.
17:32:37 <rt> that matt pharr's a smart cookie.
17:32:52 <monotonom> Haha it is \x -> blah, not \x. blah
17:32:55 <Pseudonym> He is indeed.
17:34:23 * rt is too easily distraced.
17:34:27 <rt> err.. distracted.
17:34:34 <Pseudonym> I like "distraced".
17:34:59 <shapr> I think I'm going to distrace myself into sleeping.
17:35:05 <shapr> g'night folks
17:35:27 <Pseudonym> Night.
17:35:47 <rt> au revoir, shapr.
17:36:05 <rt> I need to think up a decent but doable project to learn haskell with.
17:36:22 <Pseudonym> My first project is always Eliza.
17:36:33 * Pseudonym has about 30 Eliza implementations in various languages sitting around
17:36:45 <rt> heh.
17:36:52 <rt> That's not a bad choice.
17:37:23 <rt> i've written Conway's Life a bunch of times, starting with my old Atari 400 in Atari BASIC.
17:37:42 <Pseudonym> Not a bad choice either, though it's hard to do functionally.
17:37:55 <rt> you do kind of want arrays.
17:38:03 <Pseudonym> Well Haskell has arrays.
17:38:29 <Pseudonym> But it's not a good first project.
17:38:39 <rt> yep.
17:38:52 <rt> I could write my lunar phase calculator/calendar program.
17:38:52 <stepcut> an irc client?
17:38:59 <stepcut> there aren't enough of those
17:39:02 <Pseudonym> True!
17:39:07 <rt> the world does NOT need another irc client. ;-)
17:39:17 * Pseudonym hangs his head in shame
17:39:20 <rt> hell, it hardly needs any more people on irc. ;-)
17:39:31 <monotonom> The GOL update rule written in Haskell is rather nice and natural and succint.
17:40:47 <rt> hmmm.  I could write my ascii reformatting program in Haskell.
17:40:53 <rt> That wouldn't be a bad choice.
17:43:47 <amgine2> why does this 
17:43:48 <amgine2> genWebSlot :: IO String 
17:43:49 <amgine2> genWebSlot = do z <- getStdRandom (randomR (50,100)) 
17:43:49 <amgine2>              return (show (z*2))
17:44:09 <amgine2> generate this error
17:44:17 <amgine2> Ambiguous type variable `a' in these top-level constraints:
17:44:24 <amgine2>  `Random a' arising from use of `randomR' at
17:44:30 <amgine2>  `Num a' arising from the literal `50' at
17:45:02 <Heffalump> try writing z :: Int
17:45:06 <Heffalump> instead of z
17:45:10 <Heffalump> possibly with some brackets
17:45:11 <amgine2> ok
17:45:19 <Heffalump> do you know about type classes?
17:45:39 <Heffalump> (sorry to patronise if you do, not sure of your level of knowledge at all)
17:45:46 <amgine2> that worked
17:46:00 <amgine2> it's telling haskell exactly that it is of class INT
17:46:09 <Heffalump> type Int, not class
17:46:15 <amgine2> hmmm
17:46:20 <Heffalump> Random/Num are type classes
17:46:44 <amgine2> i recall readng about that
17:46:48 <amgine2> so why did this error happen ?
17:46:53 <amgine2> z is of type Int
17:46:59 <amgine2> class Int i mean
17:47:02 <amgine2> not the same int ?
17:47:03 <Heffalump> no, type Int
17:47:11 <Heffalump> without the type signature, how was it supposed to know that?
17:47:13 <Heffalump> hi ozone
17:47:44 <amgine2> hmm
17:47:45 <amgine2> ok
17:47:47 <Heffalump> it could tell from your use of randomR that z was supposed to be something in the class Random
17:47:58 <Heffalump> and it could tell from your use of 2*z that it was supposed to be in the class Num
17:48:07 <amgine2> yeah
17:48:12 <Heffalump> and probably in Show too cos of show (2*z)
17:48:15 <amgine2> so why wasn't it able to figure it out
17:48:18 <Heffalump> but nothing tied it down to Int rather than Integer
17:48:28 <amgine2> i see
17:48:33 <amgine2> Integer is a class
17:48:37 <Heffalump> no, Integer is a type
17:48:37 <amgine2> interesting !
17:48:38 <monotonom> I thought there is a default for Num (it could be Int or Integer usually), and whenever a Num is not constrained, the default is chosen.
17:48:43 <Riastradh> Number is a class.
17:48:46 <Riastradh> Er, Num.
17:48:47 <Heffalump> monotonom: yeah, I was just wondering that too
17:48:58 <Heffalump> I think it may be because the eventual class was Random
17:48:59 <amgine2> because before i hat genWebSlot :: IO Int
17:49:04 <amgine2> and it didn't generate that error
17:49:12 <monotonom> (This is why 0+0 works.)
17:49:13 <Heffalump> amgine2: yeah
17:49:24 <amgine2> it had three places to get that info from
17:49:29 <Heffalump> what module is Random in?
17:49:34 <amgine2> good now i will understand this error more next time
17:49:35 <monotonom> Random
17:49:43 <Heffalump> doh :-)
17:50:36 <Heffalump> AFAICT the constraints would have been Random and Num. Not quite sure why they weren't defaulted.
17:55:20 <jameson> While we're at type classes: I recently defined a type "data (Num a, Ord a) => Expr a = (...)". Later, I used values of type 'a' (from that context) elsewhere, but hugs complained that it was not able to derive the Num-ness and Eq-ness, so that I had to explicitly type the functions in question. Are these typeclass constraints on algebraic datatypes silently ignored, or am I missing something?
17:55:35 <Heffalump> I think they're silently ignored.
17:55:38 <skew> it's pretty annoying.
17:55:42 <Heffalump> I forget precisely what they are used for.
17:55:51 <skew> They prevent you from using the type class at types without the instances
17:55:59 <skew> your data type rather
17:56:10 <skew> but they don't let you pull out values and use them with that type
17:56:42 <skew> Why did you need to explicitly type everything?
17:56:44 <jameson> That's strange, but at least I now know that my system isn't broken. Thanks!
17:57:12 <skew> I would think you would get inferred types like myfun :: (Eq a, Ord a) => Data a -> a -> Bool
17:57:28 <Heffalump> yeah.
17:57:38 <skew> they really should send along the dictionaries with a type like that
17:57:52 <Heffalump> no, you want an existential type for that
17:58:05 <Heffalump> actually, won't the type get inferred if Data a is in the output type?
17:58:36 <skew> Heffalump: not necessarily. existentials don't expose their types
17:59:03 <Heffalump> I wasn't talking about existentials when I said about the type getting inferred
17:59:50 <skew> what were you referring to when you mentioned existentials?
17:59:59 <Heffalump> [01:57] <skew> they really should send along the dictionaries with a type like that
18:00:24 <skew> that's what I was talking about when I said they types on an existential are not necessarily exposed
18:01:04 <jameson> Ah, no, stupid mistake on my part. It seems to be able to infer everything just fine, unless it is curried.
18:01:08 <skew> It seems like getting a (Data a) should satisfy those class constraints, just like knowing a value is in a subclass of Ord and Eq satisfied things
18:01:08 <Heffalump> the dictionary has to be passed at runtime
18:01:20 <Heffalump> but yeah, you're right about that
18:01:31 <Heffalump> it's not an implementation issue so much as a constraint checking issue
18:01:43 <skew> To get that behaviour a value of data Eq a, Ord a => Data a = ... would need to carry a dictionary in each value
18:01:52 <Heffalump> no, it could all be inlined statically
18:02:02 <Heffalump> it wouldn't happen, cos it's too expensive space-wise
18:02:04 <Heffalump> but it _could_
18:02:13 <Heffalump> whereas for an existential, you _have_ to pass a dictionary at runtime
18:02:17 <skew> what could be inlined? You mean specializing everything?
18:02:20 <Heffalump> yes
18:02:43 <Heffalump> the real point is that any use of Data a should automatically lead to Eq a, Ord a being inferred
18:02:58 <skew> that works (aside from polymorphic recursion, of course)
18:03:22 <skew> Don't you already get the constraints being inferred?
18:03:29 <Heffalump> maybe. I'm confused now.
18:03:44 <Heffalump> I don't quite see what you mean about the dictionary being passed, then.
18:03:51 <Heffalump> If the constraints are inferred anyway, why wouldn't the dictionary be passed?
18:04:57 <skew> now I'm confused. I guess it should all work out
18:06:13 <rt> damn, the temperature in my office is falling.
18:10:36 <skew> It's cold where you are? I'm running an air conditioner.
18:10:37 <amgine2> i forget is this possible ?
18:10:37 <amgine2> tempStatus = tempStatus ++ "NEW"
18:10:54 <skew> it's probably not what you want
18:11:00 <amgine2> ?
18:11:20 <skew> The tempStatus on both sides is the same, so tempStatus ends up being undefined
18:11:36 <amgine2> it starts of us a string
18:11:46 <amgine2> i just wish to update it
18:11:50 <skew> let tempStatus = "NEW" ++ tempStatus gives you an infinite string "NEWNEWNEWNEWNEWNEW ...
18:12:00 <amgine2> hmmm
18:12:03 <amgine2> i'm thinking it terms of c
18:12:08 <skew> no, that would be the "functional" bit :)
18:12:16 <amgine2> would this work ? tempStatus <- tempStatus ++ "NWE"
18:12:21 <skew> I did the same think the other way around when I wrote some C recently
18:12:33 <skew> balking at x = x + 1 because it looked like it would loop.
18:12:41 <amgine2> haha
18:12:50 <amgine2> so any ideas to my inquire ?
18:13:06 <skew> what are you trying to do?
18:13:14 <amgine2> just have a string
18:13:16 <amgine2> that i can add too
18:13:32 <amgine2> and return it at the end
18:13:37 <skew> but what are you trying to build up in the string?
18:13:43 <amgine2> just strings
18:13:51 <skew> it doesn't matter how it gets done, just that it does.
18:14:00 <amgine2> ?
18:14:04 <skew> something like concat list_of_strings should work
18:14:11 <skew> if you can put all the strings in a list
18:14:38 <skew> I try to avoid anything that resembles control logic as much as possible
18:14:56 <amgine2> crap
18:15:01 <amgine2> anywho i have to take a break
18:15:07 <amgine2> my eyes are tired
18:15:12 <amgine2> and can't read no more
18:17:11 <skew> does anyone know of a library for working with two-level boolean logic?
18:18:27 <stepcut> has anyone tested haskelldb with sqlite?
18:18:46 <Jerub> now there's an icky thought.
18:19:43 <stepcut> haskelldb is great, except it requirse a database with subselect support
18:19:51 <stepcut> which won't be in mysql until 4.1
18:20:15 <stepcut> (well, its already in 4.1alpha, but my web host provider does not offer that yet)
