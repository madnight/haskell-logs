03:51:28 * shapr sings
03:54:27 <shapr> gooood morning #HASKELL!
03:54:39 <shapr> how's the code flowing this fine morning?
03:54:44 <andersca> hello
03:54:50 <shapr> hej andersca 
03:55:15 <ski> hej shapr,andersca
03:55:32 <shapr> hej ski, ska du komma till EuroHaskell?
03:55:36 <Jerub> shapr: I've found a kinesis on auction for a sane price...
03:55:49 <ski> shapr : var ?
03:56:00 <shapr> i Götborg
03:56:10 <shapr> i Göteborg även
03:56:16 <shapr> Jerub: cool! buy it!
03:56:16 <Jerub> and the code isn't flowing, I've restricted my home coding to zero hours per day. :/
03:56:18 <ski> shapr : men var i Göteborg ? ;)
03:56:27 <shapr> ski: i din hemma!!
03:56:37 <ski> shapr : vafalls ?
03:56:38 <shapr> kanske :-)
03:56:42 <Jerub> shapr: I'll bid nearer to the end of the auction
03:57:06 <shapr> http://www.scannedinavian.org/AvianWiki/EuroHaskell
03:57:32 <shapr> I'm the official disorganzier of EuroHaskell.
03:57:40 <ski> oj
03:57:53 <ski> du som inte ens bor här
03:58:03 <shapr> :-)
03:58:25 <shapr> I need to get my other kinesis repaired
03:59:09 <ski> men det låter ju kul
03:59:41 <andersca> vi kan vara hos ski
03:59:47 * shapr grins
03:59:57 <ski> shapr : jag är inte helt säker, men jag tror jag inte är bortrest då ..
04:00:06 <Jerub> shapr: what happened to it?
04:00:07 <ski> andersca : det är för stökigt !!
04:00:28 <shapr> Jerub: a release of frustration
04:00:44 <Jerub> shapr: ahh, a common computer injury.
04:01:08 <shapr> my head was uninjured, but the 6fdb keys no longer worked on the keyboard
04:01:40 <Jerub> dvorak?
04:01:48 <shapr> yes
04:01:59 <shapr> 6yhn on qwerty
04:02:21 <ski> 6yhn ?
04:02:39 <Jerub> ski: look at the line of keys down from '6' to 'n'
04:02:45 <Jerub> http://cgi.ebay.com.au/ws/eBayISAPI.dll?ViewItem&item=4120318255&category=51083 <- what I'm looking at
04:06:04 <earthy> err... it's 6tgb on my keyboard.
04:06:24 <Jerub> earthy: on my keyboard thats a wobly line, 6yhn is a straight line
04:07:23 <earthy> there isn't any truly straight line on this kb. but that's what I get from having a M$ Natural
04:15:32 <tic> 6fdb here :'
04:15:33 <tic> :)
04:18:24 <shapr> hi themus, how's sacramento?
04:23:13 * ski bah!s
04:24:26 * shapr usch!s
04:24:45 <shapr> oh, I gave my presentation on interjektioner today in class
04:25:05 <shapr> I tried to get the students to come up with the best swedish swearword they'd ever heard, and a situation where they would use it.
04:25:22 <shapr> but I was the only one brave enough to use swedish swearwords in front of our teachers.
04:26:10 <shapr> anyway, the only decent swedish swearwords I know I learned while playing Counterstrike
04:26:14 <ski> heh
04:26:48 <shapr> that being "javla hora"
04:27:00 <shapr> that was often used to refer to me and my activities.
04:27:09 * ski doesn't swear often
04:27:31 <ski> (best = strongest ?)
04:27:44 <shapr> yes
04:27:47 <earthy> I'd say most appropriate given a situation
04:28:00 <earthy> (which is much *much* harder to get right)
04:28:07 <shapr> that's true
04:28:14 <shapr> my favorite dutch 'swearword' is actually gezeik
04:28:43 <shapr> and it's not really a swearword, more an expression of disbelief
04:29:14 <earthy> or an expression of annoyance
04:29:34 <shapr> I think it's closest to the american "bullshit!"
04:29:39 <earthy> nope. ;)
04:29:43 <shapr> no?
04:30:02 <shapr> oh tell me more :-)
04:30:40 <earthy> it really depends on the inflection used when pronouncing it
04:31:13 <earthy> if you pronounce it somewhat tongue in cheek it does have the `you're bullshitting me' connotation
04:31:42 <earthy> however if pronounced angrily it's more of a `quit yer whining'
04:32:23 <earthy> it *is* always a derogatory form of referring to another person's speech
04:33:00 <ski> hmm, is "bollocks" brittish ?
04:33:12 <earthy> but for `dat gezeik ook altijd met die storingen' when referring to e.g. being delayed due to malfunctioning trains
04:33:21 <earthy> ski: istr it is
04:33:47 <ski> earthy : (sorry, forgot what "istr" means ..)
04:33:52 <earthy> I seem to recall
04:33:58 <ski> mm
04:36:43 <ski> (istr john constantine used that quite a lot ..)
04:56:36 <shapr> yow!
04:56:47 <shapr> earthy: thanks for the cultural info
04:56:48 <ski> @yow
04:56:48 <lambdabot> Someone is DROOLING on my collar!!
04:57:26 * ski is irritated
04:57:40 <shapr> why?
04:58:19 <ski> i heard about some expert system related to asperger, but find no source
04:58:34 <ski> s/source/source code/
04:58:37 <shapr> asperger's syndrome?
04:58:41 <ski> yeah
04:58:45 <shapr> hm, interesting
04:58:55 <ski> shapr : http://www.certec.lth.se/expertsystem/socialsimulator/
04:59:40 <ski> i wanna see the implementation !
04:59:49 * ski whines a bit ..
04:59:51 <shapr> yah, that is interesting
05:01:15 <ski> (though, maybe they describe some of it in the papers.. haven't looked at them much yet)
05:10:58 * shapr bounces cheerfully
05:40:15 <Si> does anyone know of some sort of template engine with which you can have a file with a number of unknowns in it and then given a number of parameters, it will create another file with the unknowns filled in?
05:40:36 <shapr> Halipeto works sort of like that
05:41:59 <Si> See I've got a basic outline for Function Skeletons (or wrappers) and I want to just be able to supply some parameters to it to create a real file
05:42:56 <shapr> have you seen Halipeto?
05:43:17 <shapr> you might like it
05:43:58 <Si> isn't that XML based though?
05:44:05 <shapr> nope
05:44:11 <shapr> at least, I don't think so
05:44:18 * shapr looks
05:45:25 <shapr> hmm, it does require HaXML, so it seems very likely that it is XML-only
05:46:15 <Si> look's like I'll have to hard-code it for the moment
05:47:09 <shapr> you could use the Template Haskell printf code
05:47:09 <Si> I could use Haskell's pretty printers, but I think that's a bit overkill
06:34:22 <ztre> h1
06:34:31 <ski> hi ztre
06:34:35 <ztre> you put fun in funk?
06:34:43 <ski> we do :)
06:38:22 <ztre> funk?
06:38:28 <ztre> i listen to ambient :-(
06:38:50 <ski> function, i guess
06:39:33 <ski> (hmm, actually 'twas "We put the Funk in Funktion")
06:39:55 <ski> "i listen to ambient" ? ambient music ??
06:40:08 <Riastradh> Nah, the 'funk' is general 'funk,' not necessarily 'funk' as in the style of music.
06:40:31 <Riastradh> Ambient music is cool too.  We put the, uh, monad in Brian Eno!
06:40:40 * ski suddenly understands !
06:41:06 <bourbaki> more rock!
06:45:52 <ztre> bourbaki: less rock!
06:46:10 <ztre> Riastradh: and you put the type in new age.
06:46:22 <Lemmih> ztre: more is less.
06:46:36 <bourbaki> :) there is so much techno and pseudo shit
06:46:38 <ztre> Lemmih: more or less
06:46:55 <ztre> bourbaki: pseudo shit?
06:47:04 * ztre being OT :-D
06:47:14 <bourbaki> yeah like all these "bands" that are in the top 10 and so on
06:47:22 <ztre> bourbaki: there is so much shit rock
06:47:33 <ztre> bourbaki: techno is not in the top10 :-/
06:47:48 <bourbaki> well there is a lot of kiddi tecno
06:47:51 <bourbaki> techno
06:48:06 <ztre> bourbaki: kiddi?
06:48:08 <bourbaki> that stuff you hear if you go to a club is mostly shit
06:48:24 <bourbaki> that dance shit
06:48:47 <ztre> bourbaki: hey iam not going to clubs to listen to music :-D
06:49:01 <ztre> bourbaki: i go to the orchestra if i want quality music...
06:49:04 <bourbaki> so what do you hear if you hear techno?
06:49:26 <ztre> bourbaki: what do i hear?
06:49:31 <bourbaki> yep
06:49:37 <bourbaki> what kind of music
06:49:48 <ztre> bourbaki: oh. many kinds
06:50:07 <ztre> bourbaki: :-D ambient, new age, industrial techno ;-D
06:50:20 <ztre> bourbaki: trance, punk, jazz
06:50:23 <bourbaki> i like downbeat a lot ambient is also not bad
06:50:27 <ztre> bourbaki: what else...
06:50:29 <bourbaki> jazz is cool
06:50:42 <ztre> downbeat ?= downtempo?
06:50:46 <bourbaki> do you know tosca?
06:50:51 <ztre> swing > jazz!
06:50:52 <bourbaki> yep
06:51:04 <ztre> tosca? the opera?
06:51:12 <bourbaki> well i like nearly anything that is slow
06:51:17 <bourbaki> now the "band"
06:51:21 <bourbaki> er no
06:52:11 <ztre> i dont
06:52:20 <bourbaki> portishead?
06:52:34 <ztre> one of my favourites is klaus schulze, dunno which genre he plays tho :-/
06:52:52 <ztre> portishead? no... what are theese?
06:53:02 <bourbaki> what?! you have to hear that
06:53:13 <ztre> :-D
06:53:30 <bourbaki> its a bit techno a bit jazz a bit hip hop
06:53:41 <ztre> the cat just ate the cord of my earphones, so i cant hear that now :-(
06:53:43 <bourbaki> like massive attack just slower and more jazz like
06:54:06 <bourbaki> what a CAT - tastrophy :)
06:54:22 <ztre> jazz and hiphop? how
06:54:41 <bourbaki> its hard to describe
06:54:47 <bourbaki> do you know primus?
06:54:51 <ztre> jazz is like __-_-__~ ... hiphop is like -_--_ -_--_ ...
06:55:03 <ztre> primus no :-(
06:55:10 <bourbaki> portishead is like _____-____ ;)
06:55:10 <ztre> seems i am not educated enough
06:55:22 <ski> bourbaki : (speaking of the category of all categories ? ;)
06:55:24 <bourbaki> primus has even its own genre in winamp
06:55:45 <ztre> :-D
06:56:09 <ztre> bourbaki: u heard of "tangerine dream"? my other favourite...
06:56:30 <bourbaki> nope what genre is that?
06:57:07 <ztre> bourbaki: dunno. electronic... maybe they call it dream or space or trance :-?
06:57:52 <bourbaki>  i mostly listen to streams now
06:57:55 <ztre> bourbaki: but i meant hiphop is symmetric while jazz is asymmetric see?
06:58:12 <bourbaki> yes but you can have more then one instrument :)
06:58:22 <bourbaki> listen to primus and you will see what i mean :)
06:58:48 <ztre> maybe
06:58:58 <ztre> i also listen to streams now :-)
06:59:15 <ztre> bourbaki: u heard drone zone? (at somafm i think)
06:59:29 <ztre> bourbaki: its like 1 beat/min
06:59:35 <ztre> :-D
06:59:44 <bourbaki> heh sounds cool
06:59:52 <bourbaki> drone zone?
07:00:49 <ztre> somafm.com
07:00:56 <ztre> listen to it maybe
07:02:07 <bourbaki> k
07:05:15 <bourbaki> sounds good :)
07:05:32 <ztre> pity you... if only i had an other earphone!
07:05:39 <ztre> i mean envy you
07:06:51 <bourbaki> dont you have a hifi decive?
07:08:43 <ztre> bourbaki: :-( i hae one, but totally different jack from the soundcards one
07:09:04 <bourbaki> dang then get a converter
08:28:55 <ztre> :-D
09:04:40 <XTL> This is probably not new, but since there was talk about make a while ago: http://www.cs.york.ac.uk/fp/hmake/
09:04:50 <XTL> Anyone using that?
09:06:11 <Igloo> I use it sometimes. It's not a generic make replacement, though
09:07:47 <XTL> I didn't look at it yet, but from distance it seems intriguing.
09:08:53 <XTL> Something to look at on my copious free time -category :)
09:10:23 <Marvin--> I've never ever used hmake, what's it good for?
09:11:35 <Igloo> It's useful when you want ghc --make, but also want to test with nhc
09:11:54 <Marvin--> oh
09:11:55 <Igloo> Also it knows how to do the hat transformations
09:12:06 <Marvin--> I usually end up using -fglasgow-exts all the bloody time anyway :(
09:12:17 <Marvin--> and I've never used hat either :)
09:12:44 * Igloo has unfortunately never used hat to actually debug a problem, mostly because almost everything I write uses Control.Monad.State  :-(
09:12:49 <XTL> The trace thingy?
09:12:55 <Igloo> Apparently buddah can't handle that either
09:12:56 <Igloo> Yup
09:14:31 <Igloo> Grr, anyone know how to get 2 LaTeX sidewaysfigures to be on the same page?
09:15:46 <XTL> Ah, a figure positioning problem.
09:15:57 * XTL sneaks out stage left
09:22:04 <Marvin--> Igloo: observe should be able to handle that neatly, though
09:22:35 <Marvin--> I find that using observe is often enough for debugging
09:23:01 <Igloo> Is observe the trace-like thing?
09:23:38 <Igloo> The problems I have aren't generally related to Control.Monad.State, it's just the debuggers can't cope with them (probably due to MPTCs or something)
09:23:49 <Marvin--> yeah, but it doesn't affect the evaluation
09:24:12 <Igloo> hat feels like it would be a lot nicer if it worked
09:24:33 <Marvin--> well, I didn't mean to imply that C.M.S was the problem, I just meant that you can use observe just fine even if you're using C.M.S or whatever
09:25:53 <Igloo> Oh, I see what you mean. Yeah, that's essentially what I do at the moment (only using trace for hysterical raisins)
09:26:46 <Marvin--> mmm, raisins
09:27:30 <Marvin--> which reminds me that I'm hungry
09:28:57 * Igloo finds it says rotated pages always take up a full page in the source. Bother.
09:29:09 <Igloo> Oh well, I guess I can reasonably use subfigures in this case.
09:29:19 <Marvin--> huh?
09:29:27 <Igloo> s/pages/figures/
09:34:06 <Marvin--> ooh
09:35:32 <Igloo> ooh?
09:36:55 <Marvin--> the sentence makes more sense that way :)
09:38:02 <Igloo> Ah, yes  :-)
09:42:28 <stepcut> @fortune
09:42:29 <lambdabot> <radix> haha! fear my bamboo stick
09:42:29 <lambdabot> <radix> thwap! swip! donk!
09:42:29 <lambdabot> <itamar> donk?
09:42:29 <lambdabot> <radix> itamar: yeah. stabbing in the forehead with a bamboo stick makes
09:42:29 <lambdabot> that sound.
09:42:53 <stepcut> haha
09:44:07 <shapr> hey stepcut, wazzup?
09:44:42 <stepcut> not much
09:44:43 <maihem> heh, does @fortune take the -o switch?
09:44:54 <shapr> it does not, but I have considered that
09:45:11 <shapr> if you fix it, I'll keep it in the running instance
09:45:14 <stepcut> shapr: I am making progress on the Unix stream processing arrows
09:45:30 <shapr> stepcut: may I see your in-progress code? arrows still fry my brain
09:45:44 <shapr> even written ideas would help I think
09:46:32 <stepcut> shapr: sure, if you are willing to wait a day, I think I might get it actually working today
09:46:37 <shapr> yes, I'm willing
09:47:18 <stepcut> arrows still fry my brain, but I am getting close to really understanding what is going on :)
09:47:29 <shapr> that's good to hear
09:48:04 <stepcut> the stream processing arrows seem very useful for a bunch of different tasks
09:48:29 <stepcut> after I get the unix thing working, I want to try to do the AIM thing using something similar to stream processing arrows
09:51:08 <shapr> I think Unix stream processing arrows might bring together enough pieces for me to really understand them.
09:51:40 <stepcut> shapr: agreed. All the papers are too abstract
09:51:50 <Marvin--> unix stream processing arrows? like pipes?
09:52:07 <stepcut> Marvin--: yes
09:52:53 <Marvin--> cool
09:52:59 <Marvin--> I'm curious too :)
09:53:05 <stepcut> Marvin: but unlike the monadic solutions I have seen, the arrow version will allow you to 'pipe' stdout and stderr seperately
09:54:11 <stepcut> or atleast that is my hope ;)
09:56:05 <Marvin--> the code, show us the coooode! :)
09:56:13 <stepcut> soon!
09:56:44 <ztre> :-D
09:57:04 <ztre> anyone willing to test my (experimental) site if it renders correctly?
09:58:25 <ztre> :q
09:58:29 <ztre> :-( no?
09:58:36 <anduril1> what is the URL?
09:58:43 <ztre> :-D
09:58:52 <ztre> http://www.freewebs.com/lol321
09:59:27 <anduril1> it looks fine
09:59:47 <ztre> anduril1: :-D thanx
09:59:53 <ztre> ~fine
10:49:50 * Igloo wishes for a tool showing callgraphs
10:49:57 <andersca> I think norpan wrote one
10:50:53 <Igloo> Any idea where?
10:51:13 <Smerdyakov> Oh boy! Graphviz to the res-Q!!!
10:52:23 <Marvin--> Smerdyakov: vrms will get you!
10:52:35 <Smerdyakov> Wazzat?
10:53:37 <Marvin--> a Debian package that checks which non-free packages you have installed :)
11:34:32 <hram> Does anybody know of a C++-parser written for happy?
11:41:30 <stepcut> hram: there are precious few C++ parsers at all
11:42:13 <hram> stepcut: Yes, but I'm not looking for a pertfect one, but something that would parse most of it...
11:48:59 <hram> well... sometimes life is hard...
11:54:29 <stepcut> hram: I have looked for C++ parsers in any language in the past and have not found anything, so...
12:14:54 <stepcut> i think i need to go back to the drawing board on my unix arrows problem
12:25:13 <Marvin--> :(
12:27:31 <stepcut> :p
12:28:31 <stepcut> I just need to think harder
12:28:51 <Marvin--> who doesn't :/
12:29:27 <monotonom> What is the unix arrows problem?
12:30:23 <stepcut> monotonom: have you heard about the unix arrows I am trying to implement?
12:33:48 <monotonom> No.
12:34:52 <stepcut> well, I am trying to use arrows to making a nice library for 'piping' unix processes around to each other (including the ability to pipe stdout and stderr seperately)
12:38:18 <stepcut> I thought I could do it using 'standard' stream processer arrows, but now I think that won't be quite that easy
12:41:10 <Marvin--> the exact pipe semantics is a bit tricky
12:43:27 <stepcut> my current problems relate to avoiding blocking
12:43:55 <stepcut> on the one handle, I want to avoid blocking, but on the other hand, I dont' want to spin my wheels if there is nothing to do
12:45:09 <stepcut> the stream processor stuff assumes that each processor will be able to return data immediatel OR that it is acceptable to block if a processor does not have the data immediately available (e.g. waiting for user input)
12:46:31 <Marvin--> well, isn't that the case for unix pipes too?
12:48:17 <stepcut> um
12:48:58 <stepcut> the problem I have is dealing with something like grep, where I don't know when grep is going to produce output again
12:49:21 <monotonom> The traditional solutions to blocking are select and multithreading.
12:49:23 <SyntaxNinja> stepcut: this sounds like a great problem :)
12:49:44 <stepcut> SyntaxNinja: yes!
12:49:57 <SyntaxNinja> stepcut: so would the idea be that each arrow is a thread that operate on the same stream?
12:50:26 <stepcut> SyntaxNinja: something like that
12:51:33 <stepcut> SyntaxNinja: for normal stream processors, you get the appearance that there are a bunch of processes running in seperate  threads each modifying the stream and passing data on to the next stream
12:52:09 <stepcut> SyntaxNinja: but its implemented without actually using any threads
12:53:19 <SyntaxNinja> hm. so is that an implementation detail, or is it not meant to use threads at all?
12:53:47 <stepcut> Its not meant to use threads
12:54:57 <SyntaxNinja> so is the problem that each arrow will block waiting for the previous arrow, which will never get the processor?
12:55:39 * SyntaxNinja only knows a little bit about arrows and IPC, so sorry if I sound ignorant ;)
12:56:34 <Cale> "do" should probably be added to the list of things to make purple in HaWiki's Haskell syntax.
12:57:36 <stepcut> the problem is, in order to get input to feed to a process (like grep), the stream processer needs to be in the 'Get' state. But that means if process now has some output to display, the output will be queued up until it gets some new input.
12:58:51 <stepcut> OR, it will gets caught in a loop where its always outputing, but never looking for new input
13:00:54 <stepcut> so maybe I need to model a unix process as three seperate stream processors, one that only consumes, and two that only produce
13:02:20 <monotonom> select. select. select.
13:02:32 <Smerdyakov> Like mother and father with their baby.
13:02:55 <SyntaxNinja> I'm a little confused.  so it has to be in an inputting state or an outputting state, and while its in its outputting state, it queues input. that all sounds fine.
13:03:04 <SyntaxNinja> is the problem that it doesn't know when to process the input and queue it for output?
13:03:32 <Smerdyakov> stepcut, are you trying to reinvent a subset of Concurrent ML?
13:04:56 <stepcut> SyntaxNinja: but what if it never gets any more input. Then you will have output that is never displayed
13:05:16 <stepcut> Smerdyakov: I don't think so, but maybe :)
13:05:37 <stepcut> Smerdyakov: I am really trying to re-implement a subset of bash
13:06:38 <Smerdyakov> stepcut, CML has a great mechanism to juggle simultaneous input and output.
13:07:22 <monotonom> Bash doesn't do any of this itself, does it?  It just sets up a whole bunch of in/out redirection between two processes, then let go.
13:07:26 <stepcut> Smerdyakov: in what context ? I want to do stuff like: (runProcess "ls") >>> reverse >>> (runProcess "cat")
13:07:29 <monotonom> s/let/lets/
13:07:30 <stepcut> oops
13:07:39 <stepcut> Smerdyakov: (runProcess "ls") >>> (arr reverse) >>> (runProcess "cat")
13:08:09 <SyntaxNinja> stepcut: so you need to know when to switch to the output state in order to get rid of what is queued?
13:08:18 <stepcut> monotonom: good point, maybe that is the right solution in my case...
13:08:19 <SyntaxNinja> but you're blocked waiting for input? 
13:08:30 <keverets> @arr
13:08:30 <lambdabot> I'll keel haul ya fer that!
13:09:26 <stepcut> SyntaxNinja: well, the problem is there is no way to switch the state once you set it. You can only specify what the next state should be
13:10:24 <Marvin--> right, bash just starts the processes, IIRC you have to take care to start the processes in the right order though
13:10:44 <Smerdyakov> stepcut, well, the (arr reverse) process can simultaneously be waiting to receive from ls or send to cat, via rendezvous channels.
13:11:07 <Igloo> Can you not always output while you have output, otherwise read?
13:11:13 <monotonom> The unix "select" function is part of the POSIX standard.  How come it is not in System.Posix?
13:11:33 <Smerdyakov> CML has a much nicer interface than POSIX does.
13:11:46 <monotonom> Yes CML rocks.
13:11:49 <stepcut> Igloo: you can, but once you say 'read' then you HAVE to read before you can go back to outputting
13:12:09 <Smerdyakov> stepcut, you don't have to in CML. :)
13:12:12 * stepcut decides to investigate ConcurrentML
13:12:43 <monotonom> Java does not have select (it may have changed very recently due to obviously popular demand). You know the way a Java programmer has to work around this.
13:13:04 <Igloo> stepcut: What is "you" in this sense?
13:13:31 <Igloo> If reverse has nothing to output then it can safely read knowing it won't want to output anything before it does
13:13:34 <monotonom> CML rocks because it has a "select" like Unix does, only nicer (as you say).
13:13:41 <Igloo> Oh, you mean the >>> operator?
13:15:02 <stepcut> Igloo: well...
13:16:20 <stepcut> the actions are represented as: (Put "whee" (Put "hay" (Get (\x -> (Put x ....)))))
13:16:41 <Smerdyakov> Then you have the wrong way of representing the actions. :)
13:16:46 <stepcut> the >>> is used to try to take streams like that and hook them together
13:17:03 <stepcut> so once you issue a command to Get, there is not way to revoke it
13:17:22 <Smerdyakov> Linear format for nonlinear execution is just silly.
13:17:37 <stepcut> Smerdyakov: well, the stream process arrows themselves are fine i think, its my model of how to wrap them around a unix process that is broken
13:18:30 <Smerdyakov> I don't like your format for the actions!
13:18:39 <stepcut> Well, i didn't make it up
13:18:55 <stepcut> blame it on john hughes or somebody
13:19:00 <Smerdyakov> Good, then you won't feel attached to it, so you can change it. :)
13:19:07 <monotonom> Assuming that every consumer is timely (if you give it data, it won't block you), you only need to wait on producers.
13:19:43 <SyntaxNinja> stepcut: where's the best place to read about the arrow represenation of stream processors?
13:20:11 <stepcut> SyntaxNinja: it was briefly introduced in 'Generalizing Monads to Arrows'
13:20:21 <SyntaxNinja> ok
13:20:46 <stepcut> however, that version does not deal with IO or terminating streams
13:23:31 <Marvin--> god, ghc packages suck
13:24:00 <Marvin--> the System.Posix modules are split up in base and unix packages in some arcane way
13:25:23 <Marvin--> and of course, the modules in the unix package import System.Posix modules from the base package
13:40:10 <g11zm0> heh sometimes when I change nicks to make fun of someone in another channel, I forget that my nick changes in all the channels.
13:42:26 * Marvin-- bonks the g11zm0ninja
14:33:59 <anduril1> I'm having some trouble compiling hws-wp, which I found in haskell-libs
14:34:31 <anduril1> ghc complains about a type issue, but as far as I can tell it is okay
15:12:18 <anduril1> how can I keep a function from the Prelude from loading
15:12:30 <anduril1> similar to "import ... hiding"
15:13:59 <stepcut> anduril1: import Prelude hiding (....)
15:14:16 <stepcut> i think
18:03:32 <reltuk> anyone know if you can build a balanced binary tree from a linked list in linear time?
18:04:38 <Riastradh> A sorted list or an unsorted list?
18:05:32 <Riastradh> And given the length of the list in advance or not?
18:06:16 <reltuk> sorted list, is shouldn't matter if you have the length in advance...you can get it in linear time if you don't, and O(n) + O(n) = O(n)
18:07:23 <saz> well
18:07:36 <saz> if it's sorted, you'd have to either pick smartly
18:07:45 <saz> or shuffle nodes at every insert
18:08:05 <saz> if it's random however, you're less likely to have to do a shuffle
18:08:43 <saz> and taking the nth thing from a list is O(n) isn't it?
18:09:17 <reltuk> yes...which is why i'm asking if there's a clever way to make a perfectly balanced bst from a sorted linked list in O(n) time
18:09:38 <saz> randomise it first?
18:09:40 <saz> ;-)
18:10:04 <reltuk> not necessarily perfectly balanced, and I don't think you can randomize it in O(n) time anyway
18:10:23 <saz> yeah, but you can have a balancing insert operation
18:10:29 <saz> like, say, and AVL tree
18:10:44 <saz> it's just that a sorted list is the worst case for such a data structure
18:10:50 <saz> hm
18:11:23 <reltuk> ofcourse, the other constraint is that you can't use anymore space...you could just make an array and treat it like a complete tree
18:11:31 <saz> yeah
18:11:34 <saz> well
18:11:36 <saz> if it's sorted
18:11:41 <saz> you could get an array of the same size
18:11:49 <saz> and just plonk things in the right place
18:11:50 <reltuk> nah, building an AVL tree with n elements takes O(n lg n) time, not O(n)
18:11:53 <saz> to a good approximation
18:12:18 <saz> oh, yeah, i guess
18:12:37 <reltuk> right, which is why I mentioned the contraint of no extra space (can't copy the elements into an array and then copy them into a balanced bst by treating the array as a complete tree)
18:13:22 <saz> hmm
18:13:31 <saz> copying the entire list into a array
18:13:37 <saz> in teh same order is O(n)
18:13:39 <saz> right?
18:13:51 <reltuk> right, it doesn't satisfy the space constraints
18:13:55 <saz> oh
18:13:58 <saz> true
18:14:20 <reltuk> but he above would satisfy the time complexity constraint (copying into array in sorted order, treating as a complete tree...)
18:14:59 <saz> yeah
18:15:50 <reltuk> the list can be doubly linked though
18:16:01 <reltuk> if that helps at all...
18:44:04 <saz> w/ 5
18:44:06 <saz> oops
18:51:53 <reltuk> interestingly, it is possible
18:53:07 <Pseudonym> reltuk: You can get the length in O(n) time.
18:53:22 <Pseudonym> And once you have the length you can build a perfectly balanced tree in O(n) time.
18:53:27 <Pseudonym> And O(n) + O(n) = O(n).
18:53:32 <Pseudonym> Right.
18:53:35 <Pseudonym> You said that. :-)
18:54:33 <reltuk> Pseudonym, building the tree isn't trivial
18:54:50 <reltuk> Pseudonym, at least not in my opinion...people have different oppinions of trivial I suppose
18:54:59 <Pseudonym> I think it's pretty straightforward.
18:55:07 <reltuk> Pseudonym, what makes you think that?
18:56:28 <Pseudonym> Because O(n) + O(log n) = O(n).
18:56:31 <Pseudonym> Think about it.
18:56:45 <Pseudonym> You can compute the size of each level from the length of the list in O(log n) time.
18:57:01 <Pseudonym> Or the number of elements in each subtree.
18:58:14 <reltuk> you can build the tree, but it's not trivial...finding all elements that are the children, etc.
19:16:42 <Pseudonym> @wiki HaskellIrcPastePage
19:16:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:16:52 <Pseudonym> Took me about 10 mins.
19:17:01 <Pseudonym> 5 plus testing.
19:24:25 <Pseudonym> The tree is balanced, but it's not left-biassed.  Hope that isn't a problem.
19:25:06 <Pseudonym> reltuk_: Guess you missed that?
20:14:24 <reltuk_> Pseudonym, sorry, was afk...I'll take a look
20:16:40 <reltuk_> Pseudonym, that works and runs in O(n) time?
20:51:55 <Pseudonym> reltuk_: Yes.
21:58:37 <stepcut> who-rah for taxes!
22:26:27 <shapr> whee!
22:26:36 <shapr> good morning #haskell!
22:28:11 <Jerub> shapr: I want to die.
22:28:53 <Pseudonym> G'day.
22:29:03 <Pseudonym> Jerub: You and cmoline.
22:29:42 <Pseudonym> (Was that cruel?)
22:30:40 <Jerub> google comes up with :
22:30:41 <Jerub> 01:15:35 <cmoline> i was imagining a forth-like language using arrows in fact
22:30:53 <shapr> he's talking about the message to haskell-cafe
22:31:10 <shapr> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005868.html
22:32:12 <Jerub> oh, nevermind
22:32:20 <Jerub> forth + arrows? I'd kill myself too.
22:32:51 <Jerub> I read some code written by the student who just spent a year with us.
22:32:56 <shapr> and?
22:33:37 <shapr> good, bad, ugly?
22:34:23 <Jerub> well.
22:34:24 <Jerub> I want to die.
22:34:30 <Jerub> I don't want to have to deal with this shit.
22:34:48 <shapr> didn't you guys noticed that in the year that he was there?
22:36:39 <Jerub> its php, it uses variable class functions to access static arrays, it iterates over hashmaps to do lookups by hash-key, and is generally ugly and badly done.
22:37:13 <Jerub> two global variables used to mark state in one part are called $Type and $Output.
22:37:51 <shapr> write it in Haskell :-)
22:38:08 <shapr> this is my solution for dealing with code I that makes me ill
22:39:09 <Jerub> shapr: no option. :(
22:39:13 <shapr> since it's so much more fun for me to write Haskell, by the time I've gotten to the end of rewriting a chunk of ugly code, I understand it better because I had to cast it from procedural to functional, and I feel more cheerful because I did something fun.
22:39:41 <shapr> then I usually write the code a second time in the target language, but that time it's squeaky clean
22:39:48 <Jerub> shapr: hire me.
22:40:21 <shapr> sorry, we don't have any jobs open at the moment
22:40:52 <shapr> the rewriting in a fun language really does work
22:41:02 <shapr> I used to do that in Java -> Python -> Java
22:42:20 <Jerub> oh, I believe you.
22:42:53 <Jerub> I'm actually really quite good at refactoring php.
22:42:58 <Jerub> but this is a weeklong job.
22:43:04 <Jerub> to get it into a passable state.
23:35:44 <shapr> yeehaa!
23:51:55 <Pseudonym> http://www.ananova.com/news/story/sm_903083.html?menu=news.scienceanddiscovery
23:52:07 <Pseudonym> Final proof that my mother was wrong.
23:53:26 <shapr> hah
23:56:46 <polli> :)
23:57:09 <Pseudonym> Must head off.  I don't feel so well.
23:57:20 <Pseudonym> Had a fever on Sunday night, Miranda had one last night...
23:57:20 <shapr> g'night Pseudonym 
23:57:27 <Pseudonym> Kids == illness
23:57:46 <Pseudonym> Night all.
