00:48:23 <fawd> this is an embarassing question. I sometimes make typo mistakes when entering commands in hugs and when i use the upward arrow to correct the last command, hugs just isn't programmed to interpret that scan code. I've seen people with hugs compiled on os x *pull back* the last command no problem but not on my linux compiled one. 
00:49:19 <dennisb> fawd: you don't have readline
00:50:21 <dennisb> most precompiled versions of hugs that I know uses readline. If you compile yourself I assume it would use readline if it finds it on your machine, but maybe you have to tell it to hugs when compiling
00:50:45 <dennisb> I never compile hugs myself so I don't remember how it's handled during compile time
00:51:20 <dennisb> and the command line is pretty useless without readline, that much is sure
00:52:09 <ayrnieu> hugs98-Dec2001/src/unix/configure accepts --with-readline
00:52:54 <fawd> dennisb: ah! thanks a lot. I just checked configure with readline.
00:53:14 <fawd> ayrnieu: thanks.
00:54:09 <dennisb> ayrnieu: most other programs find readline themself without that switch but maybe hugs doesn't
03:16:48 <cookie> leetos
04:19:22 <ham> hiho
06:07:44 <ski> @arr
06:07:44 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
06:49:20 <cuelebre> can anyone suggest me a Database library .I am using ghc in windows ( cygwin avaliable)
07:19:48 <viblo> cuelebre: haskelldb.sf.net
07:25:48 <cuelebre> it depends on HSQL 
07:25:55 <cuelebre> and i cant compile it 
07:28:33 <viblo> I have compiled both hsql and haskelldb on win with cygwin
07:28:53 <viblo> (I'm one of the developers of haskelldb :))
07:29:10 <viblo> what error do you get when you compile hsql?
07:29:54 <cuelebre> configure --enable-mysql (changing mysql_config to point to the correct includedir)
07:30:24 <cuelebre> in windows the information provided by mysql_config is false 
07:32:29 <viblo> ok. I havn't tried directly with mysql.. 
07:32:44 <viblo> have you tried with using ODBC instead?
07:35:39 <cuelebre> yes
07:35:58 <viblo> and it didn't work either?
07:36:14 <cuelebre> can i paste the error ?
07:36:38 <viblo> sure
07:37:53 <SyntaxNinja> has anyone seen a yacc grammar for scheme?
07:40:19 <earthy> why would you need one?
07:41:04 <SyntaxNinja> I'm just trying to find a pretty straightforward example of a yacc grammar
07:41:24 <earthy> and you think the C grammar is too complex?
07:41:25 <SyntaxNinja> I know there are others out there, like for calculators and expressions and such, but scheme would be kinda nice.
07:42:37 <earthy> but, there is a JavaCC grammar for R5RS scheme at http://www.d.kth.se/~d93-hyo/scheme/R5RS.jj
07:46:12 <SyntaxNinja> that might come in handy, thanks.
07:47:01 * earthy is glad his google-fu still rocks. :)
08:30:17 <SyntaxNinja> does anyone know what the "*T" architecture is?
08:39:07 <ski> hmm, is there an Array monad ?
08:39:34 <Heffalump> could you implement it efficiently?
08:39:49 <ski> (Tim Sweeney says something like that on comp.lang.functional)
08:40:16 <ski> i'm not sure how exactly such a monad would work
08:40:50 <Heffalump> you could imagine the direct translation from lists to arrays
08:40:51 <ski> (He says "Also check out Haskell's Array monad (for computations producing multiple values)")
08:40:53 <Heffalump> so it must exist
08:41:00 <Heffalump> (in theory)
08:41:18 <ski> what would return do, e.g. ?  what index bounds to use ?
08:41:21 <Heffalump> in practice you might have to do everything via conversion to and from lists, and therefore it's be hopelessly efficient
08:41:30 <Heffalump> you'd have to use immutable arrays
08:42:41 <ski> the only way i see something like that is to use arrays with size encoded in the type ..
08:43:19 <ski> like Vector2 a = (a,a) e.g.
08:44:07 <ski> (or maybe something clever with church-numerals in the type system + multi.arg.classes+fun.deps., i guess ..)
08:44:42 <Heffalump> why do you need the size encoded in the type? It isn't for lists.
08:44:53 <ski> what should return do ?
08:45:07 <Heffalump> I don't know the exact operations, but it should create a one-element array
08:45:09 <ski> how big array should it make ?  one element ?  which indices ?
08:45:13 <ski> ok
08:45:36 <ski> zero-based indexing, i guess then ..
08:45:48 <Heffalump> doesn't really matter, does it?
08:45:56 <Heffalump> as long as you're consistent
08:45:57 <ski> or at lesat not user-chosen lower & upper bounds
08:46:15 <ski> (s/lesat/least/)
08:46:21 <Heffalump> they could be user-chosen by primitive operations (not return)
08:46:30 <ski> yuck
08:46:31 <Heffalump> and >>= might need to do something sensible with them
08:46:49 <Heffalump> or you could consider equality to be modulo zero-basing
08:46:55 <Heffalump> in which case it doesn't matter what anything chooses
08:47:26 <ski> hmm, what if the index-set is (Int,Int) then ?
08:47:48 <ski> perhaps it'll work anyway ..
08:49:02 <Heffalump> oh, I guess boundedness would cause trouble
08:49:08 <Heffalump> in that there's a limit on the size then
08:49:09 <ski> hmm, anyway i suspect Vector2,Vector3, etc .. are monads  (haven't checked all laws yet)
08:49:15 <ski> yes
08:49:20 <Heffalump> what are Vector2 etc?
08:49:29 <ski> Vector2 a = (a,a)
08:49:36 <ski> Vector3 a = (a,a,a)
08:49:41 <Heffalump> what's the return operation?
08:49:42 <ski> or whatever implementation you want
08:49:50 <ski> return a = (a,a)
08:49:54 <ski> return a = (a,a,a)
08:50:16 <ski> (f)map is easy, of course
08:50:38 <ski> (>>=) we can make from fmap and join
08:50:55 <ski> join ((a00,a01),(a10,a11)) = (a00,a11)
08:51:18 <ski> join ((a00,a01,a02),(a10,a11,a12),(a20,a21,a22)) = (a00,a11,a22)
08:51:29 <ski> sortof a diagonal extraction ..
08:52:05 <ski> or does this violate some of the monad laws .. ?
08:52:20 <Heffalump> I suspect it'd violate the laws.
08:52:40 <ski> join . return = id
08:52:45 <ski> join . fmap return = id
08:52:46 <Heffalump> IM the third one.
08:52:52 <ski> those are ok, i think
08:53:02 <Heffalump> it doesn't "feel" at all associative to me
08:53:17 <ski> and the "associativity" of join, i think, is ok, too
08:54:54 <ski> Heffalump : the (>>=) associativity ?
08:55:09 <Heffalump> join (join ((a00,a01),(a10,a11)),(a20,a21)) = join ((a00,a11),(a20,a21)) = (a00,a21)
08:55:33 <ski> what's that ?
08:55:40 <ski> mixing of Vector2 and Vector 3 ?
08:55:51 <Heffalump> hmm, ok, it does work
08:56:06 <Heffalump> but actually that was plus, not join.
08:56:14 <ski> oh, ok
08:56:37 <Heffalump> and I'm confused anyway.
08:56:59 <ski> join . join = join . fmap join   is the "assciativity" of join i was thinking about, i think
08:57:48 <ski> this has type    m (m (m a)) -> m a   (i.e.  (m . m . m) a -> m a )
08:57:50 <kosmikus> I think it's okay
08:58:15 <ski> the left first merges the outer two "m" levels, and then that with the innermost
08:58:30 <Heffalump> ski: yeah, that's what I mean by being confused :-)
08:58:36 <ski> the rhs first merges the two inner levels and the that with the outermost
08:59:29 <ski> but i can't remember all of the 7 monadic laws (7 for return,join,map formulation), on top of my head :(
08:59:44 <Heffalump> go for the >>= formulation then
08:59:46 <Heffalump> much easier :-)
08:59:52 * Heffalump tries to work out what that is
09:00:05 <ski> so either i'll have to look them up. *or* try to figure out what >>= is doing, in these kind of monads
09:00:21 <Heffalump> (a0,a1) >>= f = (f a0,f a1) or the transpose of that, presumably?
09:00:31 <ski> ma >>= k = join (fmap k ma)   is the generic definition, IIRC
09:00:40 * Heffalump gets his types wrong again
09:00:44 <Heffalump> yeah, right
09:00:45 <ski> yeah
09:00:59 <ski> (a0,a1) >>= k = ...
09:01:02 <kosmikus> (a0,a1) >>= f = (fst (f a0), snd (f a1))
09:01:15 <ski> (a0,a1) >>= k = join (k a0,k a1)
09:01:20 <ski> mm
09:01:24 <ski> or
09:01:29 <Heffalump> anyway, I think it works.
09:01:37 <ski> (a0,a1) >>= k = (b00,b11)
09:01:38 <ski>   where
09:02:03 <Heffalump> it's sort of an abstraction of non-determinism, right?
09:02:03 <ski>   ((b00,b01),(b10,b11)) = (k a0,k a1)
09:02:08 <ski> (or something like that)
09:02:58 <ski> Heffalump : i came up with it when thinking about vectors and matrices and other such "fixed-size" structures, as opposed to "variable-size" structures like lists and trees
09:03:33 <ski> i.e we can easily define map for the "fixed-size" variety, but can we make a monad out of it ?
09:04:31 <ski> (first i thought that to be impossible (except the trivial, like Vector1))
09:04:32 <Heffalump> well, you gave a correct return operation, so yes..
09:04:55 <ski> but it seems it must use copying and killing ..
09:05:25 <Heffalump> in what sense?
09:05:35 <ski> return copies its input
09:05:46 <ski> join kills all elements but those on the "diagonal"
09:05:50 <Heffalump> well, in effect you're abstracting from a list.
09:05:57 <ski> i am ?
09:06:03 <Heffalump> so for lists of one element you need to make up one, and for lists of >2 elements, you need to throw some away
09:06:05 <ski> i don't think so
09:06:22 <ski> hmm
09:06:27 <Heffalump> f [a] = (a,a)
09:06:32 <Heffalump> f as = (head as,last as)
09:06:55 <Heffalump> I think with that abstraction function it's equivalent, but there's no MonadZero instance
09:07:06 <ski> hmm
09:07:11 <ski> Vector3, then ?
09:07:15 <Heffalump> I was just wondering about that.
09:07:38 <Heffalump> ah, yes
09:07:58 <Heffalump> the difference between the two is that other operations are constrained to always return precisely two possibilities for one input
09:08:25 <Heffalump> so if you imagine the List monad with that constraint, then every result will be a list of length 2^n or 3^n or whatever
09:08:35 <Heffalump> so there's enough regularity that you can always pick out the appropriate elements
09:08:42 <Heffalump> with Vector3 it's just the middle one
09:08:49 <ski> hmm
09:08:52 <Heffalump> not quite sure for Vector4 but it's probably not hard
09:08:54 <ski> the "diagonal" ?
09:09:03 <Heffalump> yeah
09:09:11 <Heffalump> just make the n-dimensional view
09:09:29 * Heffalump is hungry
09:09:45 <ski> but the list is then the flattening of such an n-dimensional matrix (tensor ?), then ?
09:10:02 <Heffalump> yep
09:10:13 <ski> hmm, perhaps ..
09:10:30 <ski> isn't InfStream also an instance of this pattern ?
09:10:35 <Heffalump> wossat?
09:10:39 <ski> InfStream = VectorInfinity
09:10:43 <Heffalump> where everything has to branch infinitely?
09:10:51 <Heffalump> quite possibly
09:10:55 <ski> data InfStream a = Cons a (InfStream a)
09:10:58 <Heffalump> yeah
09:11:27 <ski> so, for join, we extract the "infinite diagonal" (from upper-left corner, of course)
09:11:33 <Heffalump> xs >>= f = map (f.head) $ iterate tail xs
09:11:38 <ski> that was interesting
09:11:59 <Heffalump> of course, then flattening has termination issues.
09:12:13 <Heffalump> do you happen to own a copy of the Fun of Programming?
09:12:53 <ski> yeah, if we try to flatten it to a list (which seems pretty stupid, i this case. just use such a join that extracts the diagonal)
09:12:58 <Heffalump> but in any case the material about breadth-first search in http://spivey.oriel.ox.ac.uk/mike/ is sort of related
09:13:00 <ski> no, i don't
09:13:46 <ski> who's written "the Fun of Programming" ?
09:14:47 <kosmikus> many different people
09:15:24 <Heffalump> http://web.comlab.ox.ac.uk/oucl/publications/books/fop/
09:15:38 <Heffalump>  Chapter 9, Combinators for logic programming is what I was referring to
09:15:55 <ski> ok, thanks
09:16:14 <Heffalump> I can't find that chapter online anywhere, though.
09:16:36 <ski> aha, Spivey and Seres
09:18:10 <ski> hmm, so do they do fixed-size of variable-size, or both ?
09:18:23 <Heffalump> I think it's all variable size
09:18:29 <Heffalump> it's the search strategy that varies
09:18:36 <ski> ok
09:18:48 * ski looks a little at the .hs code
09:21:31 <Igloo> Wow, an sprintf(out+j+j, "%02x", Message_Digest[j]); take 4 times as long as SHA1ing a short string in C
09:22:52 <Heffalump> you could write a more efficient specialised version
09:23:22 <kosmikus> Heffalump: where are you now?
09:23:34 <Heffalump> hotel
09:23:41 <kosmikus> ah, okay
09:23:42 <Heffalump> going to leave on foot in 10 mins or so
09:23:48 <Heffalump> (unless you have a better plan)
09:24:29 * Heffalump looks at his map and thinks he might make that 20 minutes
09:24:55 <kosmikus> I could take a bus and walk with you
09:26:05 <Heffalump> I have a feeling that the bus stop I got off at earlier is also the right one for the restaurant, though possibly I should have got off one before.
09:26:39 <Heffalump> oh, hangon, I'm looking at this map upside down
09:28:16 <kosmikus> ah no, I won't get there in time to walk
09:28:25 <Heffalump> ok
09:28:42 * Heffalump stops trying to work out complicated ways to arrange to meet :-)
09:28:57 <kosmikus> I will be on the bus number 11 which should be at "oorsprongpark" at 18:50 ...
09:29:31 <Heffalump> that's not on my map, is it?
09:29:56 * Heffalump remembers he has another one
09:30:12 <kosmikus> it's not on the maps you had with you today
09:30:40 <Heffalump> nope, this one doesn't have it either. Never mind, I shall just leave here in 5-10 mins and see what happens.
09:31:12 <kosmikus> okay
09:42:21 <haskellnoobmonke> brandnew to haskell and have been struggling with something which seems like it'd be very straightforward.  how does one modify a list?  say [(a,b,c)] and I know an (a,b) and want to modify the c.  is it best to write a function that'll be like: function (a,b,c) (x,y) v = if a==x && b==y then (a,b,v) else (a,b,c) ?
09:43:10 <ski> that would work, i guess
09:43:50 <keverets> you would probably want to reverse the arguments of the function so that you could map it over the list
09:43:55 <ski> though, usually one doesn't think in terms of "modifying" (as in imperative programming languages), in haskell
09:44:11 <ski> rather "returning a modified version of"
09:45:30 <amgine2__> how would one go about accessing webcam in haskell ?
09:46:19 <ski> using the FFI, perhaps ?
09:46:33 <haskellnoobmonke> I see ... what I'm doing though, that's more like a modified version of, right?  a level-up, what's the best way to iterate through a list then to see if I can "modify" it?  This is here I have problems because I guess I can't just say, insert [a:rest] (x, y) v = (insert2 a (x, y) v) ++ (insert rest (x,y) v)  {{where insert2 would be the function above}}
09:47:07 <amgine2__> what does FFI stand for ?
09:47:28 <ski> haskellnoobmonke : yes. (so my comment was on terminology)
09:47:51 <ski> amgine2__ : Foreign Function Interface. you can call C libraries and such ..
09:48:01 <amgine2__> i see
09:48:34 <ski> haskellnoobmonke : hmm
09:48:48 <ski> shouldn't [a:rest] really be (a:rest) ?
09:49:03 <haskellnoobmonke> you're right
09:49:07 <haskellnoobmonke> it should be
09:49:10 <haskellnoobmonke> dunno why it isn't.
09:49:31 <ski> (because you're new to the syntax, perhaps ?)
09:50:07 <ski> also, i think you should change the "++" into a ":"
09:50:33 <ski> insert2 is returning a triple, while insert is returning a list of triples, right ?
09:50:47 <amgine2__> ski but no module provided for such operation ?
09:51:29 <haskellnoobmonke> right.
09:51:40 <haskellnoobmonke> but actually, the '.' seemed to do the trick though, no more complaints from hugs.
09:51:49 <ski> amgine2__ : i dunno if somebode has made some bindings for accessing webcams, no. if you know how to do it in, say C, then it should probably be quite easy to write such a binding to that lib yourslef
09:51:53 <haskellnoobmonke> and it works ... well, it appears to so far.
09:52:00 <ski> the '.' ?
09:52:10 <haskellnoobmonke> ya, the '.' instead of the "++"
09:52:16 <haskellnoobmonke> (I swapped in the '.' I mean)
09:52:19 <amgine2__> i see thanks
09:52:24 <ski> not ':', then ?
09:52:37 <haskellnoobmonke> ohh ... sorry, ugh, yes, I used a ":"
09:52:40 <haskellnoobmonke> small text
09:52:41 <haskellnoobmonke> heh
09:52:42 <ski> ok
09:53:35 <haskellnoobmonke> thanks
09:54:11 <haskellnoobmonke> (was reaching my limit of how many "Type error in application" errors I could take)
09:54:20 <ski> heh
10:21:10 <haskellnoobmonke> I'm not sure if I'm thinking about this correctly ... but how does one ignore something?  I have a function to get for values between certain ranges and I'm using an if/then statement but it doesn't have the else and I think hugs is complaining because I don't have the else.  	if x1<a<x2 && y1<b<y2 then c    ... how can I have my program just ignore on anything else?
10:22:13 <ski> what do you want to return if the if-condition is false ?
10:22:33 <haskellnoobmonke> oh, wait, I think I answered my own question ... I forgot that I was adding to a list so I just added an 'else []'
10:22:40 <ski> ok
10:22:58 <haskellnoobmonke> but apparently I can't do x1<a<x2?
10:23:21 <ski> x1 < a && a < x2
10:23:44 <phubuh> That's because x1<a is a boolean value.  You can't compare booleans with the < operator.
10:23:55 <haskellnoobmonke> ahh, makes sense.
10:24:27 <ski> (at least, you can't compare boolean with Ints or whatever numbers x1,a,x2 are)
10:24:49 <haskellnoobmonke> it's tricky coming for iterative languages and jumping into functional languages.  it was like when I had to jump into prolog (well, in the logical sense then)
10:25:12 <ski> yes, it's a different paradigm
10:25:14 <phubuh> Oh, whoops, I didn't realize that you actually _can_ compare booleans with the < operator. :-)
10:25:43 <ski> phubuh : False < True :)
10:25:50 <haskellnoobmonke> haha
10:25:58 <phubuh> Yeah, I just tested it in GHCi and feelt stupid.
10:26:06 <phubuh> Er, felt.
10:27:12 <ski> but you only can compare two things of the same time (that supports ordering, i.e. is an instance of the Ord (type-)class)
10:28:31 <ski> s/time/type/  of course !
10:53:53 <haskellnoobmonke> hrm, apparently the '[]' doesn't work.  here's what I have. arange2 (e,f,g) (xa,xb) (ya,yb) = if (xa<e) && (e<xb) && (ya<f) && (f<yb) then g else []
10:54:06 <haskellnoobmonke> all I care about is getting back an int.
10:54:24 <haskellnoobmonke> is there like a Null-type idea in haskell? or am I thinking about this wrong?
10:55:09 <bring> there is no null as such
10:55:15 <bring> hi shapr
10:55:22 <shapr> hey bring, wassup?
10:55:48 <bring> been hacking on a compiler all weekend
10:55:52 <bring> how about you
10:56:34 <shapr> hacking on the broken bits of i18n support in Plone
10:56:40 <bring> haskellnoobmonke: what would you like to happen in the 'else' part
10:57:10 <bring> not haskell then, well, at least you get paid fot it
10:57:43 <shapr> I'd rather be hacking haskell though
11:00:20 <haskellnoobmonke> oh, sure .. when you messaged me it appeared in another window so I thought you were PMing me.
11:00:39 <shapr> which irc client are you using?
11:00:52 <bring> anyway, Maybe might be what you are looking for
11:00:54 <haskellnoobmonke> oh, normally I'd use mirc but since I was already in moz
11:01:09 <shapr> I've never tried chatzilla
11:01:17 <haskellnoobmonke> it gets the job done
11:01:21 <haskellnoobmonke> heh
11:01:32 <haskellnoobmonke> I'll try out this maybe.
11:14:12 <haskellnoobmonke> I'm brand new to haskell so I think I'm missing the point of this "monadic" maybe.
11:14:46 <keverets> in that case you probably shouldn't worry about whether or not Maybe is monadic.
11:14:47 <bring> I don't think you have to care about it being a monad
11:14:50 <keverets> Just use it and be happy.
11:16:07 <haskellnoobmonke> haha, well lemme run this buy to see if I'm even using it correctly because the examples I found all use it as a data constructor with functions that work differently:    arange2 :: (Int,Int,Int) -> (Int,Int) -> (Int,Int) -> Maybe Int           arange2 (e,f,g) (xa,xb) (ya,yb) = if 	(xa<e) && (e<xb) && (ya<f) && (f<yb)  return g
11:18:22 <keverets> you probably want "then Just g else Nothing"
11:18:28 <keverets> instead of "return g"
11:19:57 <ski> return = Just   (for the Maybe-monad)
11:21:35 <keverets> yup, but that can be more confusing
11:22:57 <haskellnoobmonke> I swapped the "return" with "Just" and now I get that nice ambiguous "Syntax error in expression (unexpected `}', possibly due to bad layout)" error.  how come I get the feeling that I'm going about this in an odd way?  I mean, I just want the Int value if it those 4 conditionals test True.
11:23:17 <haskellnoobmonke> oy, Haskell.
11:23:26 <haskellnoobmonke> heh
11:24:05 <keverets> an "if" needs a "then"
11:24:11 <keverets> I mean "else"
11:24:23 <keverets> well, both, actually.
11:25:02 <keverets> The question is, what do you want it to give you if at least one of those 4 conditionals are False?
11:26:41 <haskellnoobmonke> your answer sounds logically what I want to happen ... I want nothing to happen, I just want the "else" conditioned ignored.  I just want to collect all the cases in which my conditionals all test True.
11:27:53 <keverets> then you probably want to return "Nothing" in the case where they're not all True.  You have to return something, or else it's not really a function.
11:28:58 <haskellnoobmonke> okay.  I never used the "Nothing" thing before because I thought I'd have to define a special datatype to use it ... I didn't know it was built in.
11:29:09 <ski> when ((xa < e && e < xb) && (ya < f && f < yb)) (return g)
11:29:37 <ski> Monad.when :: Monad a => Bool -> a () -> a ()
11:29:43 <ski> or in your specific case
11:29:55 <ski> Monad.when :: Bool -> Maybe a -> Maybe a
11:30:17 <ski> oh
11:30:21 <ski> s/a/()/
11:30:47 <haskellnoobmonke> s/a/()/?
11:31:04 <ski> i.e. i should have said  Monad.when :: Bool -> Maybe () -> Maybe ()
11:31:25 <ski> ok ?
11:31:38 <haskellnoobmonke> yes.  does this replace my other datatype, or is this in addition?
11:32:09 <ski> you could do this instead of the if-then-else, with an annoying "else Nothing", if you want
11:32:22 <ski> it does the same
11:34:12 <ski> understand what i mean ?
11:35:57 <haskellnoobmonke> yes, I believe.  however, when I added that datatype and your when/return statement, hugs borks with "Syntax error in input (unexpected symbol "Monad.when")".  I'm sorry if I'm a drag-- this Monad/When/Maybe stuff is beyond what I know in Haskell.
11:36:21 <haskellnoobmonke> (if that isn't obvious enough, heh)
11:36:33 <ski> you have to "import Monad"
11:37:03 <ski> you did that ?
11:37:50 <ski> hmm, also what "datatype did you add" ?
11:38:06 <haskellnoobmonke> Monad.when :: Bool -> Maybe () -> Maybe ()
11:38:13 <ski> oh
11:38:23 <ski> you shouldn't add that to your source file
11:38:30 <haskellnoobmonke> oh, oops
11:38:43 <ski> that is already in the Monad module
11:38:48 <haskellnoobmonke> so I keep "arange2 :: (Int,Int,Int) -> (Int,Int) -> (Int,Int) -> Int"
11:39:01 <haskellnoobmonke> or do I add the "Maybe" before the last Int again?
11:39:05 <haskellnoobmonke> arange2 :: (Int,Int,Int) -> (Int,Int) -> (Int,Int) -> Maybe Int
11:39:26 <ski> yes, the type signature of arange2 should still look like that
11:40:28 <ski> (i.e. with the Maybe Int as the return type)
11:41:48 <ski> arange2 (e,f,g) (xa,xb) (ya,yb) = when ((xa < e && e < xb) && (ya < f && f < yb)) (return g)
11:42:00 <ski> that should be your difinition now, i thinnk
11:42:34 <ski> still have problems ?
11:43:38 <haskellnoobmonke>  Type error in application     *** Expression     : when ((xa < e && e < xb) && ya < f && f < yb) (return g)     *** Term           : return g     *** Type           : b Int     *** Does not match : a ()
11:44:11 <ski> hmm, oh right, sorry
11:44:29 * ski smacks himself on head
11:44:58 <ibid> bah, anybody know how to typeset the -||- symbol (think \vDash with its mirror image) in latex?
11:45:08 <ski> when is of course only applicable when the "then-branch" of the if would only "do something", and *not* return anything
11:45:25 <ski> hmm
11:46:05 <ski> oh, ok
11:46:46 <ski> so the function that i think about (and mistakenly thought was "when"), could perhaps be defined like
11:46:52 <ski> foo :: Bool -> a -> Maybe a
11:47:00 <ski> foo False _ = Nothing
11:47:05 <ski> foo True  a = Just a
11:47:21 <ski> so then you could use this instead of when
11:47:34 <ski> (and replacing "return g" by just "g")
11:48:18 <haskellnoobmonke> you mean "Just g" or only the single character 'g'?
11:48:58 <ski> haskellnoobmonke : sorry for me mixing it up. so, i guess you could either define such a foo function (can't find it in module Monad or Maybe, ATM). or you could just use an if-then-else with Nothing in the else-branch ...
11:49:33 <ski> Just "g"  (i.e *not* "Just g"   ;)
11:49:36 <haskellnoobmonke> hrm, I'll go back and try the if-then-else again.  Nothing doesn't require the 'maybe' does it?
11:49:51 <keverets> no
11:49:59 <keverets> well, depends what you mean
11:50:05 <haskellnoobmonke> heh
11:50:05 <keverets> it doesn't require you to "import Maybe"
11:50:19 <keverets> but it still needs "-> Maybe Int" on the end of your function signature.
11:50:21 <haskellnoobmonke> but my datatype, does it require the "Maybe Int" at the end?
11:50:24 <haskellnoobmonke> ahh, okay
11:50:31 <shapr> Igloo: John Meacham has his own SHA1.hs in ginsu if you want to compare
11:50:39 <haskellnoobmonke> btw, is it a datatype or function signature?
11:50:48 <haskellnoobmonke> no, signature, you're right.
11:50:50 <haskellnoobmonke> (I see it now)
11:50:52 <ski> haskellnoobmonke :  note : that's not called a 'datatype', but a 'type signature'
11:50:57 <Igloo> Hmm, URL?
11:51:17 <shapr> http://repetae.net/~john/computer/ginsu/drop/
11:51:31 <shapr> I just noticed it in the 0.5.3 tgz
11:52:25 <Igloo> That's a slightly modified copy of mine
11:52:30 <shapr> oh :-)
11:53:30 <shapr> it's very informative to read John's networking code after looking at lambdabot so much
11:56:02 <shapr> though it really boils down to a coupla read/write forkIO calls and a Chan
12:18:46 <haskellnoobmonke> turns out I guess I really don't know what "Nothing" is because instead of returning an empty list when the condtionals failed it returned a list full of "Nothings".  I went ahead and rewrote it to a simple True/False system that only if it's True _then_ grab the value to be stuck into the list.
12:20:19 <ski> use mapM
12:20:27 <ski> @type mapM
12:20:28 <lambdabot> mapM :: Monad a => (b -> a c) -> [b] -> a [c]
12:21:09 <ski> that will give nothing if if some of the elements in the list gives Nothing
12:21:34 <ski> if you just want to skip the Nothings, you could use catMaybes
12:21:41 <ski> Maybe.catMaybes :: [Maybe a] -> [a]
12:22:26 <haskellnoobmonke> haha, *hand motion over head again*, I think I'll settle in this case for my uber-simple method.  hasn't failed me yet :)
12:22:34 <ski> sure
12:22:45 <ski> do what works and you understand
12:22:55 <haskellnoobmonke> thanks a bunch for your guys help thus far though.
12:23:04 <ski> (but try to look at the Maybe way later on, though)
12:23:38 <haskellnoobmonke> oh, I'll definitely keep it in mind.  I only stick to these hack jobs when I'm feeling pinched by deadlines.
12:23:48 <ski> heh :)
12:43:27 <haskellnoobmonke> out of curiosity, do I need to include anything to use "@type mapM"?
12:43:43 <haskellnoobmonke> because hugs borks "Syntax error in input (unexpected `@')"
12:44:36 * Igloo discovers that for Word32s >= 0x80000000 GHC is evaluating c1 + c2 (where c2 is always 0x7FFFFFFF). Got kind of confused when it started doing computation for foo = Con 0x67452301 0xefcdab89 0x98badcfe 0x10325476 0xc3d2e1f0
12:44:51 <Igloo> haskellnoobmonke: Type ":t mapM" in hugs
12:45:06 <Igloo> You'll need to have it in scope, though. ":l Monad" will load the Monad library.
12:48:32 <ski> Igloo : hmm, mapM seems to be in both Monad and Prelude in ghc  (and just in Prelude in hugs 2002 Nov)
12:49:10 <Igloo> Oh yeah, my misteak
12:49:34 <Igloo> Euch, mistake
12:49:37 <ski> (ghci 6.0.1, btw)
12:49:53 <Marvin--> evening
12:50:15 <Igloo> Hi Marvin
12:50:22 <ski> Marvin-- : yes, it is
13:18:17 <haskellnoobmonke> if I have a list of type [(a,b,c)] ... is there a way I can write a function so I can do this ... ((a,b,c):rest)  (ala (h:rest) ) so I can make it a recursive function but also immediately have access to the element within the triplets?
13:18:34 <haskellnoobmonke> elements*
13:19:33 <ski> (h@(a,b,c):rest)
13:20:09 <ski> or did i misunderstand you ?
13:20:35 <ski> you want to be able to use ha *and* a, b, c at the same time, right ?
13:20:44 <ski> s/ha/h/
13:21:52 <haskellnoobmonke> ya, I'd like to be able to use a,b,c and then pass rest recursively onto itself again.
13:22:08 <haskellnoobmonke> before what I was doing was just (h:rest) and then writing another function to (a,b,c) it
13:22:17 <ski> can't you do that with  ((a,b,c):rest) ?
13:22:17 <Marvin--> then @ is what you want
13:22:36 <ski> foo ((a,b,c):rest) = ...a..b..c..(foo rest)..
13:22:45 <ski> ok
13:22:50 <haskellnoobmonke> do I need that 'h' in front of it or just '@'?
13:23:03 <Marvin--> if you want to use the h, then you need h@(a,b,c)
13:23:13 <Marvin--> if you don't want to use the h, you don't need the @ pattern at all
13:23:15 <haskellnoobmonke> okay, then no 'h'
13:23:18 <haskellnoobmonke> oh
13:23:33 <haskellnoobmonke> hrm ... I might've had my signature setup bad before then.
13:23:35 <Marvin--> I thought you wanted to refer to the triplet both by a single name and by its components?
13:23:38 <ski> depends on if you want to be able to refer to the whole triple, or just use the three parts (and the rest part of the list)
13:23:54 <haskellnoobmonke> no, just the three individual parts... I care not for the whole triplet.
13:24:07 <Marvin--> oh, then it's just  foo ((a,b,c):rest) = ...
13:24:08 <ski> the ((a,b,c):rest) should suffice
13:24:09 <haskellnoobmonke> (this is for a sort function and I only need the third element 'c'
13:24:17 <haskellnoobmonke> cool, thanks.
13:24:28 <Marvin--> confusion and misunderstanding galore :)
13:24:47 <ski> if you don't care for a and b here, use :  foo ((_,_,c):rest) = ...
13:25:02 <Marvin--> yeah, wildcard patterns are nifty :)
13:37:29 <haskellnoobmonke> Is this even possible?
13:37:30 <haskellnoobmonke> sort [] 	= []
13:37:32 <haskellnoobmonke> sort ((_,_,f):rest) =
13:37:33 <haskellnoobmonke> 	sort srt_left ++ [f] ++ sort srt_right
13:37:35 <haskellnoobmonke> 	where
13:37:37 <haskellnoobmonke> 		srt_left  = [y | y <- rest, y < f]
13:37:38 <haskellnoobmonke> 		srt_right = [y | y <- rest, y >= f]
13:38:27 <ski> y is a triple there, no ?
13:38:28 <haskellnoobmonke> it's my where clause that's kill hugs.
13:38:33 <ski> right
13:38:57 <ski> use "(_,_,y) <- rest" instead of "y <- rest", i think
13:39:13 <ski> hmm
13:39:47 <ski> so do you want to return a list of triples, or just a (sorted) list of the third elements of each triple ?
13:39:54 <haskellnoobmonke> sorted list of third elements
13:39:58 <haskellnoobmonke> of each triplet
13:39:59 <ski> (you are doing the second, presently)
13:40:00 <ski> ok
13:40:45 <ski> then, wouldn't it be easier to first just replace all triples by their third part, and then sort that
13:41:11 <ski> (so in that way you dont need to use (_,_,whatever) in your sort, at all)
13:41:18 <ski> what do you think ?
13:42:14 <haskellnoobmonke> heh, well, I didn't sleep last night so I'm a little slow right now ... but are you saying I'd write another function to remove the two superfluous items and just keep the third and then rewrite this func w/o the _,_'s?
13:42:25 <ski> yeah
13:42:51 <ski> or just write a function that returns the third element of a triple, and then map that over the list
13:43:18 <haskellnoobmonke> soo, the function above isn't possible then?
13:43:33 <ski> of course it is possible
13:43:44 <haskellnoobmonke> I got this from hugs:
13:43:45 <haskellnoobmonke> ERROR "prog5-3.hs":96 - Type error in function binding
13:43:47 <haskellnoobmonke> *** Term           : sort
13:43:48 <haskellnoobmonke> *** Type           : [(b,c,a)] -> [a]
13:43:50 <haskellnoobmonke> *** Does not match : [a] -> [a]
13:43:50 <ski> just not as easy/clear as it might be  (IMO)
13:43:51 <haskellnoobmonke> *** Because        : unification would give infinite type
13:43:55 <haskellnoobmonke> ahh, gotcha
13:44:04 <ski> hmm, oh right
13:44:24 <ski> so, you could rewrite it to fix that
13:44:37 <haskellnoobmonke> hrm ...
13:45:24 <ski> but i now definitely think it is easier and clearer to remove the first and second parts of the triple *first*, before calling the sort function  (and of course replacing "(_,_,f)" by "f" in sort, also)
13:45:38 <ski> do you know the function "map" ?
13:45:44 <ski> @type map
13:45:44 <lambdabot> map :: (a -> b) -> [a] -> [b]
13:46:55 <ski> @eval map square [0,1,2,3,4,5]
13:46:56 <lambdabot> [0, 1, 4, 9, 16, 25]
13:47:04 <ski> where   square x = x * x
13:47:40 <haskellnoobmonke> (oh, heh, just noticed the bot right now)
13:47:45 <haskellnoobmonke> okay, I'll give that a try.
13:48:28 <ski> haskellnoobmonke : (btw, the @whatever things are just a way of telling the bot some command. it is in no way a part of haskell)
13:48:57 <haskellnoobmonke> gotcha ... that's probably why when I actually put in the "@type map" from before directly into my hs file I got errors, heh.
13:49:11 <ski> heh
13:49:36 <ski> "@type ..." is similar to doing an ":t ..." in hugs or ghci
13:51:16 <ski> (actually i think @type is telling lambdabot to give a :t command to ghci)
13:53:35 <haskellnoobmonke> nifty.
13:55:29 <haskellnoobmonke> okay, I've created:
13:55:31 <haskellnoobmonke> rem (_,_,f) = f
13:55:32 <haskellnoobmonke> for usage in a mapping, say map rem list = f ... I don't really know how to call arbitrary functions though .. I've gotten into a mode where I'm only doing  FUNC = IF BLAH THEN BLAH ELSE BLAH
13:56:08 <ski> hmm
13:56:39 <shapr> wow, we're over 80
13:57:02 <Marvin--> wow
13:57:20 * Marvin-- celebrates by listening to a Blind Guardian live CD he just bought
13:57:23 <ski> say you call the function that takes a list of triples, and returning a sorted list of the third part of each triple .. (oh, where was i ?)   right, we call that function foo, ok ?
13:57:32 <ski> shapr : nice
13:57:48 <ski> so we have perhaps
13:57:59 <Marvin--> \m/ awesomeness \m/
13:58:06 <ski> foo tripleList = sort (map third tripleList)
13:58:07 <ski>   where
13:58:16 <ski>   third (_,_,c) = c
13:58:22 <haskellnoobmonke> ahhh
13:58:28 <ski> see ?
13:58:33 <haskellnoobmonke> yes
13:58:35 <shapr> I just started watching "Fucking Åmål" as self-assigned homework, after twenty minutes (swedish speech and swedish subtitles) I think that's a weird movie.
13:58:55 <Marvin--> shapr: good, though, really good
13:59:06 <ski> but, then you have to purge the (_,_,f) things from your sort function, of course
13:59:08 <shapr> it's slow going for me
13:59:12 <ski> (shouln't be hard)
13:59:34 <shapr> took me an hour to do those twenty minutes, since I needed a handy dictionary for the occasional word
13:59:41 <shapr> äcklig is a new one for me
13:59:43 <Marvin--> ahh
13:59:59 <Marvin--> I guess that'd kinda detract from the story :)
14:00:22 <shapr> I think it's actually pushing the story even more, because I really have to focus on what's going on
14:00:32 <shapr> at the moment I can't stand any of them ;-)
14:00:48 <Marvin--> heh
14:00:51 <Marvin--> that's the point :P
14:01:26 <shapr> anyways, for on-topic discussion, does anyone have any suggestions for existing Haskell source I could adapt/hack/etc into useful bits of an NNTP lib?
14:01:37 <shapr> hi yertle, what can we do for you?
14:01:52 <yertle> i'm trying to write a simple binary tree in haskell... i've read some tutorials, but i keep running into problems
14:02:14 <shapr> any specific problems?
14:02:24 <yertle> well
14:02:28 <shapr> any gale chat users here?
14:02:34 <shapr> Cale: do you use gale?
14:02:48 <haskellnoobmonke> all you guys rock.
14:02:49 <yertle> it's basically trying to just evaluate a simple arithmetic equation
14:02:51 <haskellnoobmonke> thanks so much.
14:02:58 <yertle> Int Op Int Op Int
14:03:05 <yertle> +, *, or -
14:03:14 <shapr> haskellnoobmonke: it's really mostly the scannedinavians that rock, heavy metal is really popular here.
14:03:16 <Marvin--> wtf, they've translated the movie name to Show Me Love?
14:03:20 <ski> haskellnoobmonke : thanks for visiting our merry channel :)
14:03:33 * shapr grins
14:03:49 <yertle> so i started it with "data Node = Int a | Char a | Node Node
14:03:53 <yertle> not really sure though
14:04:00 <yertle> i've just been taking stabs and getting lots of errors
14:04:21 <Marvin--> yertle: why Int a?
14:04:23 <ski> why "Char" ?
14:04:27 <yertle> well
14:04:31 <shapr> is that really a binary tree?
14:04:36 <yertle> the node can either have an int or a char
14:04:38 <ski> shapr : no
14:04:39 <yertle> char would be an operator
14:04:47 <yertle> it needs to be a btree, but it's not =P
14:04:51 <shapr> ski: just sanity checking...
14:05:00 <Marvin--> yertle: what you've written is a data type that has three constructors, Int, Char and Node
14:05:01 <yertle> not sure if it should be like "data Node = Char (Node a) (Node a)
14:05:15 <yertle> hm ok
14:05:18 <ski> if it's a binary tree, surely the Node:s should have 2 subtrees, not 1 ?  :)
14:05:32 <yertle> well that's why i said Node Node
14:05:34 <shapr> wow, 83 this must be the high-water mark
14:05:37 <yertle> I thought that would take in 2 Nodes?
14:05:38 <ski> ok
14:05:55 <haskellnoobmonke> *cough* *cough* CS162?
14:06:03 <Marvin--> yertle: no, that will make a constructor called Node that takes one argument of type Node :)
14:06:19 <Marvin--> yertle: you can use the same name for types and constructors, it's kinda confusing
14:06:22 <ski> yertle : first you state a name (called "constructor") of a specific variant of the type. after that you state the types of the parts of that variant
14:06:25 <yertle> sample input is something like this:
14:06:40 <shapr> haskellnoobmonke: you in LA?
14:06:49 <haskellnoobmonke> SB
14:06:50 <ski> data Node = AnInt Int | AChar Char | ANode ...
14:06:50 <yertle> eval (Node '+' (Leaf 2) (Node '*' (Leaf 3) (Leaf 4)))
14:07:02 <yertle> not even sure what to do with the Leafs yet
14:07:08 <shapr> isomer`: hey anth!
14:07:19 <shapr> geez, 85
14:07:21 <yertle> ok, so if I don't want Node Node, then how do I take in 2 nodes?
14:07:24 <isomer`> yo shapr - what's shakin man?
14:07:32 <shapr> isomer`: san andreas?
14:07:32 <Marvin--> yertle: that suggests having two constructors, Node and Leaf
14:07:42 <ski> yertle : " ANode Node Node"
14:07:43 <isomer`> is it? haven't checked the news
14:07:52 <yertle> oh
14:07:57 <shapr> isomer`: I don't know actually, I was just thinking about the last time I was in california
14:08:05 <yertle> who's from SB?
14:08:07 <Marvin--> yertle: see how the expression is built up by applying Node to three expressions (a Char and two trees) or by applying Leaf to an integer
14:08:10 <haskellnoobmonke> yo
14:08:14 <yertle> aye
14:08:16 <yertle> working on 162?
14:08:23 <haskellnoobmonke> just finished :-D
14:08:34 <ski> yertle : first you have the variant name/constructor/tag, then the parts/arguments for that variant
14:08:36 <yertle> damn
14:08:44 <yertle> ok
14:08:44 <shapr> I should really remember what SB stands for...
14:08:56 <haskellnoobmonke> just north of LA
14:08:59 <haskellnoobmonke> about an hour
14:08:59 <yertle> we're both at UCSB
14:09:08 <shapr> but I can only think of San Obispo, San Onofre, those sorts of places
14:09:17 <yertle> hour south of San Luis Obispo
14:09:18 <haskellnoobmonke> Santa ...
14:09:29 <shapr> haskellnoobmonke: Claus?
14:09:33 <haskellnoobmonke> harhar
14:09:36 <haskellnoobmonke> Barbara
14:09:36 * shapr grins
14:09:51 <yertle> hm
14:09:52 <shapr> I lived in Escondido for a bit
14:09:55 <haskellnoobmonke> I mean, it's where all the yuppies from LA go for the weekend.
14:10:04 <haskellnoobmonke> heh
14:10:17 <haskellnoobmonke> (SB that is)
14:10:30 <yertle> 12«11haskellnoobmonke12» how'd you set up your btree for first problem?
14:10:33 <Marvin--> yertle: constructors are like functions, you apply them to values and they construct abstract values
14:10:48 <yertle> right
14:10:52 <yertle> i just didnt know how to separate them
14:10:58 <yertle> except for |
14:11:23 <Marvin--> yertle: let's call the type Tree instead, so we don't confuse it with the Node constructor
14:11:28 <yertle> ok
14:11:36 <shapr> here's my lazy person's guide to Haskell syntax: http://www.scannedinavian.org/AvianWiki/HaskellDemo
14:11:41 <Marvin--> yertle: so you'd have data Tree = Leaf ... | Node ...
14:12:08 <yertle> so "data Tree = Leaf a | Node a"
14:12:08 <ski> yertle : do you need trees that can contain Int:s and Char:s at the same ?
14:12:14 <yertle> no
14:12:16 <yertle> one or the other
14:12:19 <ski> ok
14:12:25 <yertle> more like Leaf contains Int I think
14:12:25 <ski> then you can make it polymorphic
14:12:30 <ski> right
14:12:35 <ski> data Tree a = ...
14:12:48 <ski> so "Tree Int" is a tree containing Int:s
14:12:48 <Marvin--> yertle: just putting a:s in the rhs of the declaration doesn't make sense
14:13:05 <yertle> so just Leaf Int?
14:13:26 <ski> yertle : Marvin-- is right. you also have to make the type Tree take an argument
14:13:43 <yertle> data Tree = Leaf Int | Node Char
14:13:47 <yertle> ah
14:13:56 <yertle> but then it needs to take more
14:14:02 <Marvin--> yertle: yes, Node needs to take three arguments
14:14:27 <yertle> so if I have "Tree Tree" in there it won't think that's just one argument Tree that is type Tree?
14:14:30 <yertle> data Tree = Leaf Int | Node Char Tree Tree
14:14:33 * haskellnoobmonke crashes hardcore
14:15:10 <Marvin--> yertle: exactly! Now your example expression above will type check
14:15:19 <yertle> ok cool
14:15:21 <Marvin--> well, provided you define the eval function
14:15:45 <yertle> so I start my eval with "eval :: Tree -> Int"?
14:15:51 <yertle> it takes in type Tree and maps to Int?
14:16:04 <yertle> what is the difference between Int and Integer? are they the same?
14:16:11 <Heffalump> Integer is unbounded
14:16:12 <Marvin--> Integer is arbitrary-precision
14:16:18 <yertle> ah
14:16:20 <Heffalump> Int is only guaranteed to be 2^29 or so
14:16:34 <Marvin--> Heffalump: hm, that's interesting
14:16:42 <yertle> ok
14:16:57 <yertle> does "eval :: tree -> Int" sound like a good start?
14:17:04 <Marvin--> yertle: sounds good to me
14:17:09 <Igloo> It's from the days bits of Ints were used as flags AIUI
14:17:10 <Marvin--> but it should be Tree, not tree
14:17:17 <yertle> ah, type
14:17:19 <yertle> typo
14:17:21 <Marvin--> Igloo: yaiks
14:17:35 <Igloo> Is that Swedish for "yikes"?
14:17:44 <yertle> then something like "eval (Leaf a) = a" so that the leaf evaluates out to the value of the integer
14:17:53 <Marvin--> Igloo: hrrm, no, that would be a typo
14:18:04 <Marvin--> or rather, typing without thinking
14:18:05 <yertle> hey! i think i got it :)
14:18:18 <yertle> working for some inputs at least
14:18:22 <Igloo> Ah, right
14:18:33 <yertle> does Int work for negatives?
14:18:37 <yertle> or just unsigned?
14:18:41 <Marvin--> it's signed
14:18:49 <yertle> one of these is supposed to spit out -11 but it's giving 29
14:18:52 <yertle> ah, okay then
14:19:11 <yertle> ah, had a + instead of - in there
14:19:17 <Marvin--> that would be it ;)
14:19:21 <yertle> =P
14:19:22 <ski> copy-and-paste error ? :)
14:19:25 <yertle> thanks for the help
14:19:30 <Marvin--> that's why I never ever copy&paste code
14:19:32 <Marvin--> I always screw it up
14:19:41 <shapr> isomer: hey, have you seen magnatune.com?
14:19:49 <yertle> hah
14:20:32 <yertle> no i wrote my eval myself =P
14:21:07 <Marvin--> well, copy&paste line-by-line
14:21:12 <Marvin--> I screw those up too
14:21:34 <ski> yertle : i meant : did you e.g. copy&paste the line for '+' to the line that should handle '-', but forgot to change the + to - on the rhs ?
14:21:35 <isomer> nope...
14:22:05 <yertle> ohh
14:22:08 <yertle> no, just stupid mistake
14:22:18 <Marvin--> oh, then you just suck :-)
14:22:47 <yertle> now i have to write a program to determine the winning move in a tic-tac-toe game.. but i guess you already know that from the haskellnoob
14:22:54 <yertle> doesn't seem too hard though, just list manipulations
14:23:09 <ski> yertle : we didn't
14:23:12 <yertle> if i have a list, and i do [x:tail] will x be the first element?
14:23:20 <ski> (x:tail)   !
14:23:30 <yertle> oh ok
14:25:23 <ski> yertle : (maybe it's some consolation for you to know that haskellnoobmonke erred in that way, too :)
14:26:01 <yertle> hehe
14:29:22 <Marvin--> damn, D&D is complicated
14:29:28 <shapr> what's complicated about it?
14:29:49 <shapr> Marvin--: I can't believe you would say anything is complicated after your encoding of Haskell into First Order Logic :-P
14:30:05 <Marvin--> I got turned into a wererat, and I'm still trying to work out what that means in game mechanic terms
14:30:31 <ski> Marvin-- : 3rd ?
14:30:35 <Marvin--> ski: yeah
14:30:41 <shapr> it usually means the DM gets to play you
14:30:47 <shapr> unless you fix it fast
14:30:57 <shapr> you have become a tool of evil!
14:31:31 <Marvin--> well, yeah, I was a passive watcher most of last session and by the end I got a note saying "You wake up in your bed tasting blood in your mouth" :-)
14:31:52 <Marvin--> at which point you say "(#&Â¤%Â¤/
14:31:56 <shapr> yup
14:32:06 <Marvin--> well, this could be fun
14:32:23 <Marvin--> it was the last day of full moon, so nothing'll happen until next full moon
14:32:31 <shapr> you should really get that fixed ;-)
14:32:54 <Marvin--> well, if I was AWARE of it...
14:32:59 <shapr> a wish would fix you right up
14:33:07 <shapr> or a major alteration or whatever
14:33:18 <Marvin--> problem is, we're a level 4 party, wishes are kinda way off ;)
14:33:24 <shapr> oh well
14:33:41 <yertle> i'm kinda stumped
14:33:50 <shapr> reminds me of this one psionicist I had
14:34:00 <yertle> i have to find the winning move in tic-tac-toe
14:34:00 <ski> yertle : hmm ?
14:34:01 <shapr> he had no arms or legs, just a personal telekinesis field.
14:34:05 <shapr> He was named Bob of course :-)
14:34:07 <yertle> it takes in 2 lists of moves
14:34:11 <yertle> player 1, player 2
14:34:16 <yertle> just need to find winning move for player 2
14:34:23 <yertle> assuming one exists
14:34:28 <ski> shapr : sounds fun !
14:34:35 <yertle> so i'm thinking i can just define some rules
14:34:36 <shapr> Marvin--: have you heard the disgusting series of jokes like, what do you call a quadraplegic in the swimming pool?
14:34:40 <yertle> like.. 24 of them?
14:34:40 <Marvin--> shapr: otoh, I want to have this character killed so I can play a mage instead, we really really need a mage and we don't really need my fighter
14:34:45 <Marvin--> shapr: er, no?
14:34:47 <yertle> i'm not sure how to do it a better way
14:34:49 <shapr> Marvin--: Bob
14:35:03 <Marvin--> shapr: eh?
14:35:07 <shapr> Marvin--: what do you call a quadraplegic lying in front of your door? Matt.
14:35:14 * Marvin-- groans
14:35:19 <shapr> it goes on like that.
14:35:35 <shapr> quadraplegic in the swimming pool, Bob.
14:35:56 <shapr> anyways...
14:36:44 <ski> yertle : do these lists contain the previous moves, and you should find the single one (if it exists) that makes player 2 win (after these previous moves has been carried out) ?
14:37:04 <yertle> yah
14:37:19 <yertle> i think we're assuming that a winning move does exist
14:37:28 <yertle> the only way i can think of doing it is a gigantic if statement
14:37:31 <yertle> =P
14:37:43 <yertle> 2 lists of tuples
14:37:55 <shapr> anyways, me trying to get Gale to work is actually on-topic, I want to steal some of the guts of John Meacham's Gale client written in Haskell.
14:37:58 <ski> i guess one *could* do a brute-force generate-and-test. (i.e. if you have something that determines if player 2 has won, in some game state)
14:38:18 <yertle> heh
14:38:46 <ski> or do you have any cleverer idea ?
14:38:49 <Marvin--> shapr: so anyway, this could be reall cool to roleplay out, since we have a lawful goody-two-shoes paladin in the party, and wererats are chaotic evil, oh, and I have an intelligent sword and they kinda dislike alignment changes... it could be great fun to see what happens :-)
14:39:03 <shapr> that does sound like fun
14:39:05 <yertle> how do tuples work in Haskell? are they a pre-defined data type?
14:39:08 <yertle> (x,y)
14:39:14 <ski> Marvin-- : haha
14:39:20 <yertle> isn't there a function to get the first and second elements out of a tuple?
14:39:26 <yertle> functions rather
14:39:30 <ski> @type fst
14:39:30 <lambdabot> fst :: (a,b) -> a
14:39:36 <ski> @type snd
14:39:36 <lambdabot> snd :: (a,b) -> b
14:39:45 <Marvin--> shapr: oh wait, you shapeshift when you take damage in combat too, that could be fun :-)
14:39:50 <ski> but often, patternmatching is clearer/enough
14:40:02 <yertle> so fst and snd are pre-defined?
14:40:28 <ski> they are (normally) defined in the Prelude
14:40:36 <ski> nothing magic about them
14:40:36 <Marvin--> GM: "All right, Derick takes a minor hit. Suddenly, his armor falls to the ground and out of it crawls... a big rat!" party: "... wtf?"
14:41:14 <shapr> yes, that should be a blast
14:42:25 <Marvin--> even more fun if I end up in hybrid form and keep using the sword, the sword is likely to get pissed off and take control of me, leaving ample time for the bad guys to kill me off
14:42:56 <shapr> I hate trying to use tools that are smarter than me
14:43:12 <yertle> how would i go about writing a function that checks to see if a tuple is in a list of tuples?
14:43:15 <ski> yertle : but yes, tuples are predefind   (defined as if you could write "data (a,b) = (a,b)" and so on. so the syntax is a but special. otherwise it's like "data Pair a b = APair a b")
14:43:18 <Marvin--> well, in-character I have no idea that it's intelligent, of course
14:43:28 <yertle> isin :: (List a) -> Bool
14:43:34 <yertle> is that how I would start a function?
14:43:46 <shapr> I don't like using tools that think they're smarter than me, whether that's a magic sword or a Java IDE.
14:44:02 <Marvin--> shapr: I failed my will save and got convinced that it was the bestest sword ever
14:44:07 <shapr> yikes
14:44:08 <Marvin--> shapr: heh, point
14:44:10 <ski> yertle : presumable it would also take a tuple to look for in the list ?
14:44:30 <yertle> oh, hehe
14:44:38 <ski> yertle : anyway, if you want what i think, then i think "elem" should be sufficient
14:44:40 <ski> @type elem
14:44:41 <lambdabot> elem :: Eq a => a -> [a] -> Bool
14:44:54 <yertle> what is Eq?
14:45:19 <yertle> equation?
14:45:25 <Lemmih> It's a class.
14:45:25 <yertle> so i can pass a List into that and be ok?
14:45:49 <ski> it the type-class that the types that can be compared by (==) and (/=) is in
14:46:03 <yertle> so I can do "if elem(l, (x,y)" where l is a List
14:46:08 <yertle> oh ok
14:47:00 <ski> Prelude> elem 5 [1,2,3]
14:47:01 <ski> False
14:47:01 <ski> Prelude> elem 2 [1,2,3]
14:47:01 <ski> True
14:47:01 <ski> Prelude> elem (4,8) [(1,1),(4,5)]
14:47:01 <ski> False
14:47:03 <ski> Prelude> elem (4,8) [(3,2),(7,9),(5,5),(4,8),(2,22)]
14:47:05 <ski> True
14:47:17 <yertle> ahh
14:47:20 <yertle> thank you
14:48:32 <ski> you can also write like  "(4,8) `elem` [....]" instead of "elem (4,8) [....]", if you feel that is easier to read
14:48:40 <yertle> ok
14:48:59 <ski> (note, *back-ward* appostrophes around `elem` !)
14:50:21 <yertle> ok
14:51:01 <ski> (btw, use can make your own types be in the Eq type class, as well. (by defining at least one of (==) and (/=) in an "instance" declaration)
14:59:57 <yertle> what's wrong with this? it's saying unexpected ')': "move (a b) = if (elem (1,1) b) && (elem (1,2) b) && not (elem (1,3) ) then (1,3)"
15:00:46 <Marvin--> yertle: first of all, it should just be  move a b  in the lhs
15:01:03 <Marvin--> yertle: second, you forgot the b in the elem (1,3) part
15:01:42 <yertle> ah, typo
15:01:48 <yertle> for the 2nd
15:01:51 <yertle> i'll try the 1st
15:02:12 <yertle> now it says unexpected '}'
15:02:31 <Marvin--> yeah, you don't have an else branch
15:02:33 <ski> you must have an else-branch
15:03:34 <yertle> ah ok
15:03:38 <yertle> i'd cut out my elses to simplify
15:03:42 <yertle> got it going now
15:03:44 <yertle> but i'm getting type errors
15:03:55 <yertle> Inferred type is not general enough
15:03:57 <yertle> hrm
15:04:24 <yertle> for "move :: [pairnum] -> [pairnum] -> pairnum"
15:04:25 <blackdog> anyone done some haskell gui programming lately? is there a standard yet?
15:04:27 <ski> what is your type signature ?
15:04:39 <yertle> it doesnt like that
15:04:45 <yertle> but the bulk of my code seems to be okay
15:04:50 <yertle> just not my move declaration
15:04:56 <ski> move :: [(Int,Int)] -> [(Int,Int)] -> (Int,Int)
15:05:00 <ski> or
15:05:07 <ski> type PairNum = (Int,Int)
15:05:13 <yertle> ah ok
15:05:18 <yertle> stupid of me
15:05:19 <ski> move :: [PairNum] -> [PairNum] -> PairNum
15:06:05 <yertle> nice, it works
15:06:11 <yertle> i just put (Int,Int) in instead of pairnum
15:06:16 <yertle> thanks for the help again
15:06:19 <yertle> 2 down 1 to go
15:07:18 <yertle> I have to write an 2-D array abstract data type
15:07:32 <yertle> with lots of functions
15:07:33 <yertle> bleh
15:08:26 <yertle> do you guys use haskell alot?
15:08:26 <ski> mhmm
15:08:29 <yertle> what do you use it for?
15:08:58 <Marvin--> everything (almost) :)
15:09:04 <yertle> heh
15:09:10 <yertle> you really prefer it to other languages?
15:09:26 <Marvin--> yeah
15:09:30 <creature> Haskell's got some nice bits in it. 
15:09:34 <ski> at least to most other languages (depends on what the problem is)
15:09:35 <yertle> i see
15:09:39 <yertle> yea
15:09:53 <blackdog> we're not here out of masochism, y'know.
15:09:59 <yertle> hehe
15:10:01 <bring> yertle: simple example, I just wrote programs to parse all of FOLDOC, insert it into a database, and export an XML-RPC function for querying the DB
15:10:05 <yertle> i was just surprised there were so many people here
15:10:15 <yertle> ahh, nice
15:10:39 <blackdog> and i just wrote a program to make fun of horny 16yos. :)
15:10:52 <Marvin--> it's really neat for parsing and compiling
15:12:46 <bring> and you need very little code and time to go cool things
15:12:49 <Marvin--> well, I'm off to bed
15:13:02 <ski> bye, Marvin--
15:13:03 <bring> s/go/do/
15:13:06 <yertle> thanks for the help
15:14:05 * bring managed to plug two projects in the same sentence
15:14:19 <Marvin--> bring: go you ;)
15:26:20 <ski> "anamorpzic dependebt" ?
15:26:36 <ski> (taken from Subject of spam)
15:27:38 <ski> seems to be something about anamorphisms and dependent types .. :)
17:23:54 <sam-> does anyone know of an oracle library binding for haskell?
21:44:19 * SamB is surprised by the sudden appearence of purple on page 5 of a research paper
