00:00:02 <Murrito> skew yeah, I know what lazy evaluation is
00:00:12 <skew> I seem to get away with 256 building in Linux.
00:00:17 <Murrito> the 4 hour build wouldn't happen until somebody typed "ghc"
00:00:39 <Murrito> skew how long does it take to build on Linux?
00:00:41 <earthy> that shouldn't take 4 hours...
00:00:54 <skew> O(1) hours
00:01:00 * earthy hits skew
00:01:01 <skew> probably less that 4
00:01:11 <skew> I usually go away and do something else
00:01:37 <earthy> the ultrasparc III @ 500 MHz does it in about 7 hours
00:01:48 <shapr> it takes three or four hours here
00:02:10 <shapr> dual athlon 1544MHz
00:02:34 <earthy> you can quite easily tweak it for speed, really, if you increase the max heap allowed
00:03:02 <earthy> (things like echo "EXTRA_HC_OPTS=-H128M" > mk/build.mk
00:03:03 <Murrito> ok, so my results seem to be in line
00:03:03 <earthy> )
00:03:32 <earthy> methinks the GHC build process defaults to 32M of heapspace
00:03:37 <shapr> it does
00:03:42 <shapr> I haven't tried to change the heapsize
00:03:49 <earthy> it *really* speeds things up
00:04:05 <earthy> you hit gc a *lot* with only 32M heap
00:04:54 <shapr> that's a good point, I hadn't thought of that.
00:05:11 <Murrito> interesting
00:06:04 <skew> shapr, do you know if the -fparr stuff in GHC is maintained?
00:06:41 <shapr> I do not, but I just sent an email to Manual asking what's up with parr.
00:07:27 <skew> that reminds me, I mailed him asking about Ports. no word yet
00:22:54 <skew> is there any particular reason length returns Int rather than an arbitrary Integral type?
00:23:37 <shapr> probably not
00:24:51 <skew> I was using GHCi as a calculator, and noticed that it properly gave 2.3 for average [1,2,3,4], once I had an average defined
00:25:48 <skew> but I had to use fromIntegral or genericLength
00:26:03 <skew> it seems like the sort of change that should be backwards compatible
00:26:27 <skew> although I know we could all write code that would break under it
01:57:26 <Marvin--> huzzah, I think I figured out a workaround for the darcs build problem
02:07:19 * Marvin-- rebuilds for the nth time
02:09:48 <Marvin--> note to self: whine to David Roundy about the configure script
02:24:09 <Marvin--> whu
02:24:22 <Marvin--> this makefile is broken, broken, broken
02:25:04 <Igloo> What's wrong with them both?
02:25:25 <Marvin--> install -c darcs $(PREFIX)/$(bindir)
02:25:43 <Marvin--> now, GNU install ignores -c
02:25:47 <Marvin--> Solaris install doesn't
02:26:05 <Marvin--> and -c expects a directory as argument
02:26:06 <Marvin--> not a file
02:27:16 <Heffalump> what's Igloo doing out of bed?
02:27:32 <Igloo> Have we not got a talk in 33 mins?
02:28:11 <Heffalump> good point
02:28:22 <Marvin--> heh
02:28:27 <Heffalump> shapr: so why the 2.0 lambdabot release?
02:28:51 <shapr> people were downloading 1.0 from sf.net and being mystified.
02:29:38 <shapr> I'd like to clean up haskell-libs, make a real webpage, real releases, and all that jazz.
02:30:56 <shapr> should I clean up cvs? or should I rip it out and switch to darcs and nightly tarballs?
02:31:38 <shapr> does anyone have access to a win32 box where they can try darcs?
02:31:41 <Marvin--> wtf, Solaris install cracks me up
02:31:46 <Marvin--> this is just insane
02:31:58 <shapr> sadly(?), I don't have access to a win32 box.
02:32:53 <Marvin--> > install darcs //usr/ed-pkg/wild/darcs-0.9.17/bin
02:32:59 * Marvin-- wonders why that fails
02:33:01 <Marvin--> the file exists
02:33:04 <Marvin--> the directory exists
02:33:11 <Marvin--> WHAT
02:33:12 <Heffalump> shapr: I do, yes
02:33:16 <Marvin--> WHAT IS THE PROBLEM?
02:33:27 <shapr> Marvin--: you didn't sacrifice a chicken yet.
02:33:37 <Heffalump> shapr: I'm working on a 2-way darcs/cvs gateway, but running into a few problems (see #darcs)
02:33:58 <Marvin--> there's a #darcs?
02:34:16 <shapr> I just cannibalized a CPU fan from one of my other PCs, so I've lost any scrollback I had on #darcs
02:35:07 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!","lambdabot 2.0 released","see our sister channel #darcs"]' by shapr
02:35:22 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!","lambdabot 2.0 released","related channels #darcs #haskell.se"]' by shapr
02:35:55 <shapr> oh, wait, I remember reading what you said about cvsps
02:43:44 <shapr> on libraries@haskell.org, Simon Marlow points out three major flaws of CVS, and says those would need to be fixed for fptools to switch to another source control system.
02:44:26 <shapr> lack of support for versioning of directories, lack of atomic multi-file commits, lack of "good" support for branches and merging
02:44:58 <shapr> http://www.haskell.org//pipermail/libraries/2004-March/001794.html
02:45:52 <shapr> I think darcs fixes the first two, I don't know about the third.
02:46:57 <skew> Ah, you meant that another version control system would need to correct those flaws before they would switch
02:47:25 <shapr> right
02:48:43 <Heffalump> I should hope it fixes the third too.
02:49:20 <skew> what does darcs do for branches?
02:49:28 <shapr> sort of nothing and everything.
02:49:48 <shapr> every 'checkout' of a darcs repo is effectively a branch
02:49:55 <shapr> it is also a standalone repository
02:49:55 <skew> the patch handling should make merging pretty easy, or at least provide the right infrastructuree
02:50:23 <shapr> so, to make a branch, you just make a copy of the repo
02:50:33 <shapr> to merge a branch, you pull patches from the copy back to the 'original'
02:50:56 <shapr> darcs is so distributed, I've claimed it's gnutella as applied to cvs
02:51:12 <shapr> in fact, I'd like to make a wiki that way, where there's no server
02:51:39 <skew> I don't see a nice way to have lots of parallel branches in some central place that way
02:51:48 <shapr> if you emacs-wiki, you can grab my wikiwiki repo and read what I've written about it. darcs get http://www.ScannedInAvian.org/repos/wikiwiki
02:52:06 <shapr> er "if you use emacs-wiki"
02:56:10 <skew> what would happen if you took an existing repository and said darcs pull <some other branch>?
02:56:31 <skew> would end up merging that branch into your repository?
02:56:33 <Heffalump> yes
02:56:35 <shapr> sure
03:00:12 <skew> I don't see a best way to integrate branches
03:00:20 <skew> but it seems like the tagging stuff gets you partway there
03:00:35 <Heffalump> "integrate"?
03:00:45 <skew> give darcs a notion of branch
03:00:53 <Heffalump> you get that from having a repository
03:00:54 <skew> where you can be working on a branch and stuff
03:01:09 <skew> and then change and work on something else
03:01:20 <Heffalump> you need to clone repositories to do that kind of thing
03:01:34 <Heffalump> but that's really just a filesystem management issue
03:01:36 <skew> yes. I haven't decided if that is something to avoid
03:01:36 <shapr> is lambda.weblogs.com down? they have a really cool discussion of darcs.
03:01:38 * Heffalump --> talk
03:01:41 <shapr> cya
03:03:25 <det> shapr: they have been mostly down for about a week
03:03:38 <det> like 10% uptime
03:08:11 <earthy> hm. sounds like subversion has *much*much* better support for branching and tagging
03:08:15 <skew> I think pull with a regexp tagname would work pretty well for tracking a branch
03:08:53 <earthy> thing is, `just a filesystem management issue' still requires support to really make it easy
03:09:27 <skew> I don't see any easy way to say that you want to go to some other tagged version
03:09:36 <earthy> exactly
03:09:50 <shapr> ?
03:09:53 <skew> except for getting a fresh repository
03:10:09 <shapr> oh
03:10:09 <earthy> and making a fresh repository quickly gets expensive. :)
03:10:09 <skew> say there is a tag head-march-03 or whatever
03:10:29 <skew> you can use darcs pull --tag-name head to track current development
03:10:49 <earthy> (think of doing tagging and branching on the linux kernel... several hundred megs of source... you *do*not* want to replicate that just for a new tag)
03:11:31 <skew> but no command will automatically roll back some patches and apply some more to get you to exactly another tag
03:11:41 <skew> although the infrastructure is certainly there
03:11:47 <shapr> doesn't darcs make hard links where possible?
03:12:17 <shapr> why would you want to go to some other tagged version?
03:12:25 <skew> if you have several branches
03:12:44 <shapr> ?
03:13:13 <skew> like the recent spate of backend hacking on GHC, plus the branch that actually still works
03:13:33 <skew> you might want to be working on both
03:13:35 <earthy> thing is, you want to associate a particular state of the repository with a tag
03:13:42 <skew> yeah, you can do that
03:13:53 <shapr> ok, so why can't you work on both?
03:13:54 <earthy> but can you do that *without* making a copy?
03:13:58 <skew> yes
03:14:00 <shapr> not that I know of
03:14:04 <skew> you can say 'tag this version'
03:14:08 <skew> and darcs makes a tag
03:14:34 <earthy> okay, and it remembers the tag through changes?
03:14:53 <skew> in the sense you could extract a copy exactly matching that tag
03:14:55 <shapr> yah, a tag is just an empty patch that explicitly depends on all the previous patches
03:15:10 <earthy> ah, 'kay
03:15:25 <skew> that's fine for history, but I'm thinking about branching
03:15:43 <shapr> interestingly, in arch every patch explicitly depends on all the previous patches, if you look at it from the darcs viewpoint.
03:15:56 <shapr> that's why darcs is better at cherry-picking patches
03:16:22 <earthy> skew: you're asking for a tree structure on the patches
03:16:30 <earthy> that you can then uniquely tag
03:16:37 <shapr> because you could easily grab the ingo molnar O(1) scheduler patch for your kernel and the william lee irwin III rmap patch with no problems
03:16:39 <earthy> and have the entire tree present in a central repository
03:17:02 <skew> well, a tree with collections of patches at each node
03:17:18 <earthy> as opposed to having to clone the repository for each branch in the patch tree
03:17:22 <skew> yes
03:17:34 <skew> at least, I think that's probably a good idea
03:17:44 <earthy> yes, it sounds like one
03:17:59 <skew> I can't see the hardlink thing working if you are pulling both version from a remote repository
03:18:11 <earthy> nor can I
03:18:26 <earthy> thing is that branches are a fine-structure on the set of patches
03:18:33 <earthy> *not* on the set of repositories
03:18:36 <skew> it seems like the central repository would need to be just a patch server, rather than trying to keep a live copy of the source
03:18:37 <earthy> s/are/should be/
03:18:53 <shapr> David has mentioned something like that
03:18:54 <skew> earthy - sets of patches and repositories are equivalent, more or less
03:19:08 <shapr> but the problem is that patches are composed of hunks, and any of the above can be commuted
03:19:14 <earthy> yes, but sets of sets of patches and sets of patches are not. :)
03:19:14 <shapr> patches do not stand by themselves
03:19:20 <shapr> they are only valid inside a certain context
03:19:54 <earthy> a repository is a context with a consistent set of patches?
03:19:57 <earthy> makes sense
03:20:00 <skew> well, ordered collections of patches and repositories are equivalent
03:20:30 <earthy> but to do branching you need a tree of repositories, right?
03:20:39 <earthy> (currently)
03:20:51 <skew> I haven't thought about how this would work if you tried to do it in a working repository, but I've got an idea for letting a central server manage branches
03:21:05 <skew> you just make special empty patches to represent a branch, like the tagging stuff
03:21:06 <earthy> and what you want is to push that treestructure *into* a single repository
03:21:18 * earthy agrees with skew
03:21:34 <earthy> but has *no* time to play with the darcs source, currently
03:21:35 <skew> and patches being pushed are marked to say that they should be added as a dependancy of that branch
03:22:32 <skew> that bit probably takes some testing for conflicts between those patches
03:24:02 <earthy> um, not more than it currently does, right?
03:24:12 <skew> I guess not
03:24:17 <earthy> each branch can still be seen as an ordered collection...
03:24:33 <skew> I was just worried about people submitting patches that conflict, but they can do that anyway
03:24:38 <shapr> I'm not convinced that in-repository branching is worth the extra complexity.
03:24:51 <skew> yeah, I wonder about that too.
03:24:53 <earthy> what complexity?
03:24:59 <skew> It certainly doesn't seem worthwhile client side
03:25:09 <earthy> I think skew just outlined what needs to be done for it
03:25:10 <shapr> just that right now, darcs only requires a filesystem
03:25:29 <skew> the complexity is making patches that add themselves to the dependancy of another patch
03:25:31 <shapr> the implementation is simple, I've hacked on the source some.
03:25:39 <shapr> the only complicated part is the patch theory stuff.
03:26:13 <skew> actually, branch tags should probably be distinct from patches, because they don't fit that theory very well
03:27:17 <skew> is a tag depending on the current patches enough?
03:27:43 <skew> it seems like order matters sometimes
03:27:55 <shapr> you should read the patch theory part of the manual.
03:28:16 <skew> yeah, I know you can find a comutation of the patches
03:29:02 <skew> but I don't see how you can reconstruct a sufficently unique order from an unorderd set of packages
03:29:19 <skew> does a tag depend on an ordered list of packages?
03:31:00 <earthy> looks like branchtrees could be reasonably easily accomodated in the current darcs
03:31:18 <earthy> it'd imply an extension of the _darcs/inventory fileformat
03:31:21 <earthy> and some commands
03:31:27 <skew> how does rollback work with a tagname?
03:32:17 <earthy> I think it rolls back all patches the tag depends on
03:32:28 <earthy> (that would be the sane interpretation)
03:32:42 <skew> except that would also tend to roll back the last tag
03:33:02 <skew> I guess that's fine.
03:34:03 <earthy> yeah, as the tag is still in the repository, just that the version currently in your main tree does not represent that tagged version
03:34:34 <earthy> otoh, I would expect a new tag to then depend on the old tag
03:35:25 <skew> if it did that it would undo the delta between that tag and the previous tag
03:42:12 <earthy> no
03:42:48 <earthy> as the semantics of rollback is to make a new patch that is the inverse of the patch being rolled back
03:43:05 <earthy> i.e.: the new tag would depend on the inverse as wel as the tag rolled bach
03:43:33 <skew> I was talking about rolling back a tag by rolling back its dependancies
03:43:38 <skew> which would seem to undo the delta
03:43:49 <earthy> thus it would both correctly record the state of the tree at that tag and correctly record the history that lead to that tag
03:43:57 <skew> darcs seems to just roll back the tag patch
03:44:09 <earthy> that's slightly weird. :)
03:44:19 <skew> unrecord does some wierd things too
03:44:23 <skew> with tags, I mean
03:44:29 <earthy> not unreasonably though
03:44:32 <earthy> just weird
03:44:52 <skew> well I made a tag then rolled it back
03:45:03 <skew> the inventory was reduced to just that tag and it's inverse
03:45:32 <skew> then unrecording both restored the old inventory file.
03:46:09 <earthy> makes sense, as per the description in the docs
03:46:24 <earthy> but for the `reduced' part for the inventory
03:47:09 <skew> I suppose it makes sense
03:47:28 <skew> I don't think tags should be treated as patches, though. It's just confusing
03:49:00 * earthy nods
03:49:58 <skew> it would be more sorts of things to handle in pulling and repository management, but branches should very much be not-patches
03:51:04 * earthy nods
03:51:17 <earthy> but information on it should very much be part of the inventory
03:51:35 <skew> I don't think that's necessary
03:51:48 <skew> it should be managed by darcs
03:51:59 <skew> but it's information about sets of patches, not patches that can be in the repository
03:52:16 <earthy> um, yeah
03:52:30 <skew> putting it in inventory would be saying "to reconstitute this repository apply 'inital commit'
03:52:50 <skew> then 'HEAD', then 'bugfix 1'"
03:54:50 <skew> keeping a record somewhere of what tags and branch(es?) describe the current repository is at least conceptually typeful, if unecessary in practice
03:55:09 <shapr> well, I sent the 'applied demo' email to libraries@haskell.org so hopefully more people will try darcs.
03:56:27 <Si_> what is darcs?
03:56:44 * shapr cackles evilly
03:56:48 <skew> After some reflection, I think we should get non-Haskell users to use darcs, and maybe use it ourselves
03:56:55 <shapr> another victim! yay!
03:57:33 <shapr> Si_: do you use debian?
03:57:41 <skew> well, use it ourselves but maybe not exclusively for public projects like GHC.
03:57:56 <Si_> no I use gentoo
03:58:03 <shapr> Si_: the short answer, is a source control system written in Haskell, http://www.abridgegame.org/darcs/
03:58:04 <skew> emerge darcs
03:58:07 <shapr> oh, I think there's an ebuild
03:58:22 <Si_> ah I hoped there might be something like that
03:58:56 <Si_> de/centralized?
03:59:02 <shapr> severely
03:59:06 <shapr> decentralized
03:59:21 <shapr> I've described it as gnutella applied to CVS
03:59:31 <Si_> ooooh sounds fun
03:59:47 <shapr> it is *very* cool
03:59:53 <skew> I suppose anybody looking to be pulling GHC and the like out of version control is probably not one to be scared off by our esoteric Haskell version control systems
04:00:03 <Si_> gonna make a rep for hws-wp, it needs *alot* of work
04:00:09 <shapr> a rep?
04:00:15 <skew> ository
04:00:18 <shapr> oh
04:00:19 <shapr> duh
04:00:32 <shapr> Si_: hampus' SmartLinker?
04:00:41 <Si_> with exts :)
04:00:44 <shapr> there's already a darcs repo for hws-wp
04:00:53 <shapr> though it doesn't yet have your changes
04:01:38 <Si_> HTTP should be converted to the RFC HTTP version
04:01:50 <shapr> Si_: send me your public gpg key, I'll add you to the list of committers
04:01:59 <shapr> oh, bring has been working on HTTP.hs
04:02:12 <Si_> unfortunately I haven't got one yet
04:02:13 <shapr> have you seen his version of HTTP.hs in his xml-rpc lib?
04:02:35 <Si_> no, does it remove the annoying limitation of doing everything via 100-continue for bodies?
04:02:44 <shapr> err, possibly
04:02:55 <shapr> I know the body thing was getting in the way of Zope, and bring did something to fix that.
04:03:10 <shapr> iirc, xml-rpc requires http 1.0, and non-chunked bodies, or something.
04:03:25 <Si_> the std version HTTP sends all bodies via 100 continue, i.e. send headers + wait for a 100-continue and then send the body
04:03:27 <shapr> anyways, it works quite happily now with Zope
04:03:34 <Si_> sadly SOAP doesn't like this and hangs
04:03:40 <shapr> same for Zope
04:03:43 <shapr> so bring fixed it
04:03:58 <Si_> non-chunked bodies?
04:04:00 <shapr> I was quite enthused.
04:04:01 <bring> Si_: yes, I have disabled 100-continue for that reason
04:04:07 <Si_> great
04:04:13 <shapr> http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/
04:04:19 * shapr advertises freely
04:04:31 <Si_> I am using a horribly hacky version atm for testing my SOAP client
04:04:37 <bring> I have been meaning to announce that I am taking over HTTP.hs, since Warrick Gray (the original author) is nowhere to be found
04:04:39 <shapr> you should use bring's version, it rocks.
04:04:45 <shapr> yes, announce!
04:05:00 <Jerub> interesting.
04:05:00 <Si_> is XMLRPC on the haskell projects page yet?
04:05:11 <bring> no
04:05:19 * Jerub considers.
04:05:20 <bring> what page is that btw :)
04:05:28 <shapr> I think it's listed on the wiki
04:05:34 <Jerub> haskell web applications could quite conceivably rock.
04:05:37 <shapr> I thought I put it there.
04:05:41 <shapr> Jerub: yes yes!
04:05:55 <shapr> we've nearly reached critical mass.
04:06:01 <shapr> I may have to go on a diet!
04:06:05 <Jerub> shapr: now all we need is some viable applications!
04:06:09 <Jerub> we could write a wiki!
04:06:11 <Jerub> or a blog!
04:06:12 <Jerub> ;)
04:06:12 <bring> Si_: I take it you are writing a haskell SOAP client?
04:06:21 <shapr> actually, there are both wikis and blogs written in Haskell
04:06:25 <shapr> I have them installed in fact.
04:06:30 <shapr> though I haven't used them much.
04:06:32 <Si_> http://www.haskell.org/libraries/
04:06:36 <skew> Si: were you the one I was talking to about reference structures?
04:06:37 <bring> ah, no
04:06:40 <Jerub> I was kidding shapr ;)
04:06:44 <shapr> doh
04:06:46 <Si_> yes, I'm implementing SOAP/1.1 client/server
04:06:55 <Si_> yes I was skew
04:06:56 <bring> cool
04:07:16 <bring> maybe we should have a look at providing simliar interfaces
04:07:24 <Si_> but only as a part of a larger interop system called HAIFA, which will hopefully see an end to interop problems in Haskell
04:07:47 <bring> so the SOAP client is not to be used directly?
04:07:48 <shapr> hey Si_, I was thinking that Binary.hs marshals Haskell values, and I'm sure it can marshal recursive structures
04:07:58 <shapr> so you should see how it works, maybe that'll help.
04:08:05 <shapr> or did you already figure out the reference problem?
04:08:22 <skew> I thought the problem was reading recursive structures from some representation?
04:08:35 <Si_> kinda, but I've left that for the moment to implement WSDL/1.1
04:08:46 <shapr> right, but Binary.hs can both read and write Haskell values, so I assume it has a clue.
04:09:04 * shapr check to see if he has a copy hanging around
04:09:22 <Si_> much of this will have to wait till June, I just want to impress my markers atm
04:09:30 <Si_> and have a decent project to demo
04:09:42 <shapr> I read that as "impress my market"
04:09:47 * shapr snickers
04:09:54 <Si_> which means the infrastructure can be a total mess, because no-one at the uni undestands Haskell anyway
04:09:59 <shapr> heh
04:10:02 <shapr> but we do!
04:10:14 <shapr> and some of us will help you get it moving so we can use it ourselves.
04:10:44 <Si_> you can do that after the project is submitted, atm the moment it has to stay under wraps sadly
04:11:00 <Si_> well parts of it do, the stuff I do with HWS and my plugin system don't
04:12:04 <Si_> basically the bits that have to stay hidden are HAIFA, SOAP and WSDL
04:12:46 * Lunar^ need to study how linkers work for hOp
04:13:03 <Si_> nevertheless if my supervisor says I can release earlier, I will
04:14:32 <Si_> try and think of a good name for a Haskell application container
04:14:35 <shapr> so, how do I bribe your supervisor? ;-)
04:15:04 <shapr> well, I think the servlets could be called "chickens" and then you could curry them...
04:15:28 <shapr> ouch, joey got k-lined? I guess he was trolling on other channels too.
04:15:41 <Si_> Haskell chickens hmmmm...
04:15:47 <shapr> curried chickens!
04:15:48 <skew> k-line?
04:16:59 <Si_> The idea is see you have a threaded server implemented which holds a registry of a bunch of dynamic Haskell applications, which are each basically a bunch of compiled Haskell objects wrapped in a tbz2 with some meta info and maybe other files
04:17:25 <Si_> this thing sits on TCP and waits for connections from a webserver which forwards requests to specific URIs to it
04:17:49 <Si_> it will use XMLRPC for it comm protocol since it works :)
04:17:49 <Lunar^> How different it is from J2EE ?
04:17:54 <Si_> it aint
04:17:57 <skew> Haskell
04:18:05 <Si_> what he said
04:18:49 <Si_> so you can wrap Haskell SOAP/XMLRPC objects and dynamically generated web-pages
04:19:05 <Si_> btw. does there exist anything that could be called HDBC?
04:19:18 <skew> HSQL?
04:19:25 <skew> or whatever that runs on
04:19:29 <shapr> yah, HSQL does ODBC
04:20:09 <skew> yeah, it's HSQL. I was thinking of HaskellDB, which runs on HSQL
04:20:26 <Lunar^> shapr: In Marvin's report about HWS-WP, his work around type checking dynamic module is interesting
04:20:36 <Si_> is HSQL platform independant?
04:20:49 <skew> windows and unix at least
04:21:02 <Si_> type checking dynamic modules? how do you do that?
04:21:08 <Lunar^> shapr: He said that the main problem was that interface informations where kept in different files, there's work for hOp here
04:21:43 <Si_> I thought dynamic modules were instrically (sp?) unsafe
04:21:59 <skew> If you inspect the .hi files, maybe not
04:22:39 <Si_> oh yes, I suppose I ought to store those as well as the object files then
04:22:58 <Si_> how do you interogate them in Haskell?
04:23:23 <skew> it seems Memo uses stable names to do pointer equality
04:23:26 <Lunar^> Si_: .hi files ?
04:23:31 <Si_> uh huh
04:24:19 <Si_> how do you interogate .hi files?
04:24:41 <skew> I don't know, but I think some parts of GHC should really be exposed as libraries for user programs
04:25:05 <skew> In particular, the internals of GHCi would probably make this pretty easy
04:25:15 <skew> all the dynamic loading stuff, that is
04:25:36 <Si_> one thing I noticed it seems impossible to dynamically link from the dynamically linked except by passing forward the load functions, is this correct?
04:26:04 <skew> I don't see why that should be
04:26:08 <Lunar^> Si_: ghc-6.2/compiler/main/BinIface.hs
04:26:18 <Si_> ty Lunar
04:26:29 <skew> what are you doing for linking?
04:26:43 <Lunar^> I start to know this compiler now :)
04:27:04 <Si_> ok, I'll see what I can do with that
04:27:08 <skew> if the dynamically loaded code can find the prelude and similar stuff, it should be able to find the dynamic loading code
04:28:00 <shapr> there's a lot to say about dynamic linking in Haskell, but in short, Marvin-- used ozone's runtime_loader, and ozone just pulled the GHCi code out
04:28:40 <shapr> the major problem is that you cannot compare types for equality between statically and dynamically loaded
04:28:43 <Si_> if you try to load a module containing Hampus Rams dynamiclinker dynamic linker, you get a duplicate code code link error from GHC
04:29:10 <skew> containing it?
04:29:14 <shapr> lambdabot had this problem with the MoreModule
04:29:34 <Si_> well you need the code dynamically linked in so that dynamically linked modules can see it
04:29:42 <shapr> in that case, it's fine
04:29:51 <shapr> but the problem is that type equality is pointer equality in GHC
04:30:08 <Lunar^> Best solution is to write a new linker IMHO ;) (I'm going out, I know)
04:30:09 <shapr> and with both static and dynamic types, you end up with two separate type tables, so never the two can meet.
04:30:37 <shapr> another solution could be ML-style first-class modules where you can actually compare *implementations* for equality.
04:30:55 <skew> and types are not exported with the sort of symbol where the type tables would merge?
04:31:13 <Si_> anyway I'm gonna stick with Hampus for the moment since I don't really need second order dynamic links yet
04:31:14 <shapr> anyway, I have to work now, so I can't go on endlessly, you guys are so lucky ;-)
04:31:29 <Si_> and if I do I'll just pass forward wrapped functions for doing it 
04:32:06 <Si_> e.g. loadModSimple :: String -> a, where String is the name of the plugin to load
04:32:08 <shapr> Heffalump knows more about this than me, you should ask him when he returns. He added the dynamic loader to lambdabot, and fixed the problem with static versus dynamic.
04:32:12 * shapr goes off to work
04:32:26 <Heffalump> how did I fix that?
04:32:31 <Heffalump> I thought you did, by making everything dynamic
04:35:14 <shapr> yes, but you figured out how to fix it.
04:35:27 <shapr> I was just codemonkey :-)
04:48:39 <Si_> so how does this darcs thing work?
04:48:46 <earthy> apt-get install darcs
04:48:55 <Si_> I've installed it
04:49:11 <earthy> darcs inittree
04:49:18 <earthy> darcs add <files>
04:49:24 <earthy> darcs record --all
04:49:37 <earthy> there. one darcs repository. :)
04:50:17 <earthy> edit.
04:50:19 <earthy> darcs record
04:50:28 <Si_> can I get a list of reps or something?
04:50:28 <earthy> there. one darcs repository with new patches. :)
04:50:35 <earthy> reps?
04:50:39 <Si_> repositories
04:51:02 <earthy> ah, a repository is really just a subtree in a filesystem with a _darcs directory with some metadata in it
04:51:10 <earthy> not unlike RCS in that sense
04:52:12 <earthy> so, unlike CVS, you do not really have support for multiple projects in one darcs repository
04:52:20 <Si_> g2g bbl
05:14:38 <skew> ozone, should trying to build TextFilter be giving link errors?
05:15:02 <skew> Oh, and I had to hack the configure script to convice it GHC 6.2 was more recent that 5.04
05:15:21 <Heffalump> lambdabot includes his stuff, and I don't recall that having a problem
05:15:27 <Heffalump> or if it did I fixed it and sent him the patch
05:20:18 <earthy> somehow the words `the patch' trigger a weird connotation given all the spam lately
08:45:17 <eixei> Hi everybody
08:45:23 <eixei> missed me? :-)
08:46:00 <Marvin--> ...
09:55:12 <shapr> ahem
09:55:38 <esap> nice address
09:55:57 <shapr> why thank you
09:55:58 <esap> ipv6?
09:56:01 <shapr> yup
09:56:19 <shapr> modprobe ipv6 && apt-get install freenet6
09:56:49 <esap> hmm.. is there some benefits to actually using it? :-)
09:56:58 <esap> other than the cool address :-)
09:57:40 <shapr> well, real multicast, headers are a linked list rather that being a fixed size, some other stuff
09:58:07 <shapr> sadly, GHC6 doesn't have IPv6 support yet.
09:58:09 <Heffalump> you're connecting via freenet?
09:58:12 <esap> I never found use for multicast, I guess you'd need some software to actually use that. When do we have Haskell binding :-)
09:58:23 <shapr> esap: right, that's the question
09:59:31 <shapr> shouldn't be too hard, but hasn't been done yet
09:59:59 <esap> I'd guess modelling multicast in the type system is somewhat interesting.
10:00:11 <shapr> ?
10:00:44 <shapr> at the moment it's all bindings to the OS
10:00:49 <shapr> would be different in hOp
10:00:58 <esap> ok
10:01:18 * esap is expecting too much.
10:01:46 <shapr> nah, we just have to write a stack when hOp gets to that point
10:02:45 <Lunar^> :)
10:02:53 <Lunar^> You can start my dear sharp :)
10:03:15 * shapr agrees
10:03:44 <shapr> let's see, we'll need a driver for the network card...
10:03:58 <shapr> I think I have a spare 3c509 around here somewhere
10:04:28 <Lunar^> shapr: Start with bochs emulated card :)
10:04:35 <Lunar^> That's really easier to debug
10:04:50 <shapr> ok
10:05:59 <shapr> qemu just ate my mouse :-(
10:06:35 <Lunar^> shapr: Ctrl+Shift
10:06:53 <Lunar^> qemu doesn't work anymore as I now use 2.88Mbps disk (-DDEBUG)
10:06:57 <shapr> no, it ate my mouse and died
10:07:06 <shapr> is that why I get the BIOS panic?
10:07:59 <shapr> aha, I'm back
10:08:20 <shapr> so, I shouldn't expect qemu -fda foo.flp to work?
10:08:24 <shapr> Lunar^: what should I be using?
10:08:44 <Lunar^> shapr: No, if you use the last link I sent to you
10:08:59 <Lunar^> shapr: In .bochsrc, change 1.44 to 2.88
10:09:16 <shapr> hm, I don't have one.
10:14:05 * shapr installs bochs
10:15:45 <Lunar^> shapr: I'm leaving a computer until tomorrow, hope you'll succeed
10:16:16 <shapr> ok
10:16:17 <shapr> thanks
10:22:46 <shapr> hmm
10:24:07 <shapr> Lunar^: wow awesome, how close to a shell? :-)
10:30:27 <shapr> hey Si 
10:31:05 <Si> hallo
10:31:22 <shapr> what's going on?
10:32:12 <Si> well I've got homework on runtime structures to do and I'm in the process of writing HAIFA's type-mapping system
10:33:13 <shapr> I've got homework on "med blottat huvud", write a one-page summary and email it to my teacher.
10:33:46 <shapr> Swedish is nearly as interesting as Haskell, most days.
10:33:53 <shapr> anyways, what sort of mapping are you planning?
10:34:39 <Si> nothing too complicated, a hashtable of hashtables, where the top-level hashtable indexes namespaces and bottom level hashtable indexes localnames
10:35:03 <Si> each type holds a mapping to another type within another type space
10:35:10 <shapr> I've been thinking about the HXML vs HaXML dichotomy as related to WASH vs HSP, just that HXML uses a generic tree and typechecks separately, and HaXML treats each part of a DTD significantly, you can't put a <TD> in a <BODY>.
10:35:30 <shapr> have you seen the SimpleDictionary in Halipeto?
10:35:31 <Si> e.g. urn:XSD/int -> Haskell98.Int
10:35:58 <Si> no
10:36:17 <shapr> you might want to peruse/steal Halipeto and its dictionary code.
10:37:08 <Si> does HaXML have namespaces now?
10:37:45 <shapr> I think Malcolm Wallace added them, but I'm not sure.
10:38:35 <Si> what does this dictionary do?
10:39:19 <shapr> it's a hashtable of hashtables, but iirc, it's on-disk
10:39:23 <shapr> so it may not be so suitable
10:39:35 <shapr> http://acooke.org/jara/halipeto/
10:40:09 <Si> did anyone write a simple serializer for Haskell data-structures; e.g. Something{part1::Int} -> <something><part1>...
10:40:48 <shapr> serialize to xml?
10:40:51 <Si> yes
10:40:57 <Si> but w/o DTD
10:41:21 <shapr> I think I've seen one, at the very minimum ozone sent me some experiments he was doing with Data.Generics
10:41:36 <shapr> his experiments used a typeclass with toXML and fromXML methods
10:41:53 <shapr> and once you implemented the basic types, algebraic types could be derived
10:42:00 <Si> because I did write a name/value pair extractor using read
10:42:22 <Si> just wondering because I'd hate to spend time writing one and then find it was already written
10:42:36 <Si> mind you I don't want to have to link in both HaXML and HXT
10:42:43 <shapr> I can understand that.
10:43:12 <Si> my executables are already over 15MB a piece
10:43:30 <shapr> http://shapr.homelinux.net/~shae/GenericsTest.hs
10:43:32 <shapr> yikes!
10:43:47 <shapr> that's code that ozone wrote, coupla weeks ago I think.
10:43:52 <Si> it's why I want to use the dynamic linker cuz it's faster and less wasteful
10:43:52 <Igloo> That is impressive. What platform is that?
10:44:33 <Si> sorry my mistake it's only 5 MB
10:45:02 <Si> mind you that's without the network stack
10:45:11 <shapr> you're writing your own stack?
10:45:17 <Si> nah GHC's network stack
10:45:20 <shapr> whew
10:45:26 <Igloo> That's still quite large. GHC is 8M stripped
10:45:44 <Si> it's cuz HXT includes its own version of Parsec
10:45:46 <shapr> yah, lambdabot halved in size when stripped.
10:45:51 <shapr> too many petticoats I assume.
10:46:01 <shapr> lambdabot: crazy bot!
10:46:01 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
10:47:01 <Si> I'm not sure of the problem with GHC's Parsec, but when I thought "hmmm they must have fixed with problem in GHC 6.2" and tried to link with GHC's Parsec, no XML documents would parse
10:47:14 <shapr> suckage
10:47:43 <Si> HXT
10:47:48 <Si> is 4MB as a result
10:48:26 <Si> but that does include HTTP, the StateIO monads and a tonne of other useful stuff
10:50:31 <Si> yes this has a simple Serializer, but not a complete deserializer
10:51:05 <Si> oh did you get my recommendations to HWS-WP before release?
10:51:50 <shapr> I saw them go past, but I haven't done anything about them, or made the release yet, so I'll go back and check the #haskell logs when I get time to work on the release.
10:51:59 <Si> ok good
10:52:13 <shapr> thank you for updating it
10:52:15 <Si> just don't want all the junk I added left in
10:52:20 <shapr> right, I understand
10:52:45 <shapr> the occasional Oholobola line of output *really* puzzled me btw :-)
10:53:03 <Si> I was testing bodies in Requests
10:53:30 <shapr> I thought it was some sort of request serial number or something, like in IMAP4
10:54:01 <Si> but IMHO the HTTP in there isn't in the least RFC compliant, it really needs stripping out and replacing with whats-his-names structure
10:54:12 <shapr> warrick grey?
10:54:25 <shapr> in any case, the one from HTTP.hs?
10:54:30 <Si> well there have been various people...
10:54:34 <Si> yes
10:54:48 <shapr> oh, did you check out the updated HTTP.hs in xmlrpc?
10:55:56 <shapr> I think ozone and Igloo took that GenericsTest module a bit further in conversation here on #haskell, but I can't find the logs
10:57:21 <Si> I have now
10:57:24 <Si> :)
10:57:36 <shapr> excellent
10:57:37 <Si> glad he disabled the highly annoying 100-continue
10:57:42 <shapr> yes, me too.
10:58:04 <Si> I'd have done it myself, but the code was quite complex for a 6-month old Haskeller
10:58:21 <shapr> if you've only been doing this six months, you're doing just fine.
10:58:22 <Si> esp. the chunked-transfer encoding method...
10:58:49 <Si> I hated Haskell until I learned about ADTs...
10:59:18 <shapr> yah, ADTs are mental lego.
10:59:28 <shapr> well, structural lego
10:59:36 <shapr> then you reach some sort of process lego with monads
10:59:49 <shapr> and even better process lego with arrows
10:59:55 <Si> Problem is the lead Haskell guy at uni has now left leaving me to fend for myself
11:00:02 <shapr> who was your lead Haskell guy?
11:00:23 <Si> Matt Fairtlough
11:00:31 <shapr> haven't heard of him before.
11:00:42 <Si> http://www.dcs.shef.ac.uk/~matt/
11:00:55 <Si> he posted a few times on the GHC mailing lists a bit ago
11:01:10 <Si> he was my original supervisor
11:01:53 <shapr> I wonder if he got into Haskell via Lava, Hawk, BlueSpec, etc
11:02:03 <Si> I'm trying to build a really good case for continuing this area of research next year
11:02:11 <shapr> I think you're on the right track
11:04:04 <Si> I'm just puzzled as to why IMHO the best projects aren't advertised on the libraries and tools pages of haskell.org
11:04:23 <Si> like XmlRpc
11:04:42 <Si> since that is majorly ground breaking
11:09:37 <Si> I didn't even know it existed until I heard about it on here
11:10:40 <shapr> well, it hasn't been around for very long, from what I heard bring say
11:10:50 <shapr> and I have encouraged him to announce it :-)
11:11:25 <bring> guess I should
11:11:31 <shapr> yay!
11:11:33 <shapr> happiness!
11:11:43 <Marvin--> heh
11:12:00 <shapr> hey Marvin-- can you test a solaris darcs binary I just got ;-)
11:12:10 <Marvin--> shapr: from Hal?
11:12:16 <shapr> yup
11:12:33 <shapr> http://shapr.homelinux.net/~shae/darcs.bz2
11:13:01 <Marvin--> 403
11:13:10 <shapr> whoops
11:13:25 <shapr> ok, one more time
11:14:19 <Si> how long has darcs been around?
11:14:45 <Marvin--> shapr: hm, it doesn't use ncurses or readline
11:15:22 <shapr>  the darcs-users mailing list started in march 2003, if that helps any.
11:15:31 <shapr> Marvin--: that could be an advantage for some people
11:15:42 <Si> wow so quite a while
11:15:57 <Marvin--> shapr: sure
11:16:13 <shapr> good to know
11:16:36 <Marvin--> shapr: for me it was as simple as not managing to figure out how to turn it off
11:16:38 <Marvin--> I guess I'm just dumb
11:16:40 * shapr laughs
11:16:56 <shapr> you should say "just trying to get a build out there as fast as possible"
11:17:01 <Marvin--> seems to work
11:17:32 <shapr> thanks for trying it
11:18:12 <Marvin--> I'm pondering if I should bother tracking down that make bug I seem to have found
11:18:26 <shapr> bug in darcs?
11:18:34 <Marvin--> no, in make
11:18:36 <Marvin--> "make bug"
11:18:38 <Marvin--> :)
11:18:48 <shapr> oh, right
11:19:10 <Si> make as in GNU make?
11:19:16 <Marvin--> yes
11:19:28 <Marvin--> I ran into an "assertion failed" bug
11:19:56 <Si> I wanna see if its possible to use Jam with Haskell...
11:20:42 <esap> you'd think 'make' would be stable against asserts.
11:20:49 <Si> cuz HAIFA will need at least a half decent build system and I'm too thick to use autoconf/automake...
11:21:50 <shapr> I wish hmake did more.
11:22:20 * esap is using ghc as a build system. Works fairly well, at least so far.
11:25:46 <Marvin--> hm, it seems to work in make 1.80, but not make 1.79
11:25:55 <Marvin--> er, 3.80 and 3.79, obviously
11:26:23 <Marvin--> moreover, in 3.79, it does work if I supply -e, but it gives a different result than v3.80!
11:26:36 <shapr> this looks like a job for CategoryTheory!
11:27:44 <whee> I sort of like AAP for builds
11:27:44 <Igloo> Well, if it's fixed it's probably not worth tracking down
11:27:59 <Si> GHC's build system doesn't take care of .in files etc.
11:28:30 <Marvin--> Igloo: I
11:28:40 <Marvin--> I'm more worried about the producing different results
11:29:00 <Marvin--> but then again, what IS supposed to happen if I have a rule   feh: FOO+=bar
11:29:09 <Marvin--> and call it with   FOO=foo make -e
11:29:21 <Marvin--> is $(FOO) supposed to be bar, foo or foo bar?
11:29:55 <Si> I reckon we could do with an Ant equivelant for Haskell
11:30:11 <shapr> yup
11:30:29 <shapr> Igloo investigated make systems recently
11:30:36 <shapr> Igloo: what did you conclude?
11:30:41 <Igloo> I've started work on a build system designed for the way I think I want it to work
11:30:49 <shapr> is it written in Haskell?
11:30:51 <Igloo> Yes
11:30:52 <Si> mind you I reckon we could do with with most Haskell equivelant things in Java
11:30:54 <shapr> yay!
11:31:08 <shapr> you mean like, open source Java? ;-)
11:31:24 <shapr> øy!
11:31:28 <Igloo> I got sidetracked hacking on darcs so my repo would behave how I want though so haven't done much with it recently
11:31:35 <Si> no, I mean everything that Java has I want in Haskell :D
11:31:53 <shapr> not the syntax, please!
11:31:55 <Igloo> I also need something like ghc -M that gives me the transitive closure of object files made
11:31:58 <shapr> or the stupid type system
11:32:11 <whee> I can't think of anything in java that I'd want in haskell :P
11:32:15 <Si> alright not everything
11:32:23 <shapr> I'd like all those implemented libraries, no argument there.
11:32:27 <Si> that was a silly assertiong
11:33:00 <shapr> I'd like lots of advertising, backing from Sun and IBM, and I want fries with that too.
11:33:15 <Marvin--> french or freedom?
11:33:21 * shapr sniggers
11:33:26 <whee> potato!
11:33:45 <Marvin--> oh, pity, I wanted to go peel some french
11:34:18 <Si> I want a Haskell Kebab
11:34:32 <shapr> I want Curried Chicken!
11:34:36 <andersca> shapr wins
11:34:43 * Marvin-- was waiting for that one
11:34:44 <shapr> ooh, I win a chicken?
11:35:31 * shapr keeps plodding through med blottat huvud
11:35:48 <shapr> I enjoy swedish science fiction more.
11:36:06 * Si keeps trawling through block structures
11:36:08 * Marvin-- blinks
11:36:12 <Marvin--> we have swedish scifi?
11:36:15 <shapr> sure
11:36:23 <shapr> pretty cool stuff too
11:36:31 <shapr> oh, we got the invandrare series recently
11:36:36 <shapr> I tried to start it, but man...
11:38:49 <Si> anyone fancy implementing SSL/TLS for HWS-WP?
11:39:43 <shapr> I think this is the closest you'll get --> http://www.haskell.org/crypto/
11:39:52 <shapr> at least, I haven't seen or heard of other Haskell crypto libs
11:39:52 <Si> already got that
11:40:06 <shapr> if you find something else, I'd like to hear about it.
11:40:43 <Si> that should do the job, it's just someone with a whole lot of time needs to trawl through the RFC and apply the crypto stuff to SSL
11:40:57 <shapr> yup
11:41:02 <shapr> sadly that's not me.
11:41:05 <Si> mind you I don't think the current plugin system could cope with SSL
11:41:07 <Si> or me atm
11:41:33 <Si> looks like I'll be demoing with Apache for the time being
11:42:34 <Si> mind you that would require me to write a TCP connection on the Apache side in C which I don't fancy doing
11:42:48 <shapr> you might be able to fake it with mod_haskell
11:43:26 <Si> nah, I'll use HWS-WP without crypto
11:43:40 <Spark> hmm ive been reccommended ghc, ive read about 1/3 of the gentle introduction, but i wanna try out some stuff
11:43:58 <Spark> is there like a hello world program i can nab that i can just paste into the ghc interpreter
11:44:15 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
11:44:20 <Si> main = print "hello world!"
11:45:35 <Spark> when it says Prelude>
11:45:37 <Spark> as a prompt
11:45:41 <Spark> do i have to do something
11:45:45 <shapr> type "main"
11:45:46 <Spark> ive used mosml about a year ago
11:45:47 <shapr> hit enter
11:45:49 <Marvin--> then you can't paste that code
11:45:49 <Spark> ahhah
11:45:58 <shapr> oh, that assumes you've already loaded the file
11:45:58 <Marvin--> just enter 'print "hello world"'
11:46:33 <shapr> oh, fun things to do in GHCi
11:46:50 <shapr> map (\x -> x + 1) [1,2,3]
11:47:05 <shapr> @eval map (\x -> x + 1) enumFromTo 1 5
11:47:06 <lambdabot> type error
11:47:16 <shapr> @eval map (\x -> x + 1) (enumFromTo 1 5)
11:47:16 <lambdabot> [2, 3, 4, 5, 6]
11:47:19 <Marvin--> parentheses, shapr, parentheses :)
11:47:23 * shapr sighs
11:47:26 <Si> I spose you could you GHCi as a kinda matlab replacement
11:47:27 <SyntaxNinja> (shapr)
11:47:30 <shapr> hah
11:47:44 <shapr> SyntaxNinja: I'm feeling tired and lispless.
11:47:48 <Marvin--> SyntaxNinja: actually, it'd be more ((shapr))  or ()shapr()
11:47:56 <Spark> the interactive nature of these things makes them a much better learning tool
11:47:57 <Marvin--> (I did use the plural form, didn't I?)
11:47:58 <Spark> (imo)
11:48:11 <shapr> I agree, I like interaction.
11:48:17 <shapr> emacs' haskell-mode is good for that
11:48:36 <shapr> C-c C-l loads the current haskell buffer into ghci
11:48:43 <shapr> so you can call toplevel bits interactively
11:49:02 <shapr> oh, you could play with http://www.scannedinavian.org/~shae/src/haskell/Mandelbrot-0.1.hs
11:51:24 <Spark> mm im not a mathmo :)
11:51:32 <shapr> I'm not either
11:51:50 <shapr> I had a business calculus course some years back
11:51:55 <shapr> many years back actually
11:52:06 * Marvin-- avoids anything with "business" in the name like the plague
11:52:09 <shapr> twelve years ago, eek
11:53:29 <Spark> ok do you have to declare functions before you define them
11:53:33 <shapr> nope
11:53:40 <Spark> from the tutorial:
11:53:41 <Spark> add                     :: Integer -> Integer -> Integer
11:53:41 <shapr> did you read the HaskellDemo?
11:53:42 <Spark> add x y                 =  x + y
11:54:00 <Spark> yeah i looked at it but i dont understand it at all :)
11:54:19 <shapr> well, the parts in comments give explanations
11:54:25 <Si> nah, but declarations make code so much more readable IMHO
11:54:38 <Spark> is the :: a declaration
11:54:45 <Marvin--> technically, it's not a declaration
11:54:47 <Spark> for type checking and stuff
11:54:51 <Marvin--> it just specifies add's type
11:55:03 <Si> which is implicit anyway
11:55:19 <Spark> how would i go about sticking those two lines into ghci?
11:55:35 <Spark> <interactive>:1: Variable not in scope: `add'
11:55:40 <shapr> if you have a type signature, it's easier to load those two lines from a file
11:55:43 <Si> create a file called demo.hs
11:56:04 <Si> with that lot in and then cd to the directory with it in a type "ghci demo.hs"
11:56:06 <shapr> you could say "let add x y = x + y :: Integer -> Integer -> Integer"
11:57:33 <Marvin--> shapr: uh, no
11:57:43 * shapr blinks
11:57:53 <Marvin--> you could say let add :: Integer -> Integer -> Integer ; add x y = x+y
11:57:53 <Marvin--> though
11:58:14 <Spark> ok doing it via a file works, but i was hoping i could define these things on the fly
11:58:30 <Marvin--> shapr: I don't recall how strictly :: binds, but neither y nor x+y has a function type, so what you wrote would just be...wrong
11:58:42 * shapr bzzts himself
11:59:36 <shapr> you can define them on the fly
11:59:47 <Spark> ahhah i just have to put "let" infront
11:59:50 <shapr> but it's a lot more trouble to declare type signatures on the fly
12:00:27 <Marvin--> shapr: let add = (+) :: Integer -> Integer -> Integer  would work though
12:00:36 <Si> and they disappear each time you do I load I think...
12:01:03 <Spark> when i was playing with sml and mosml, i used to keep an editor and the interpreter up on the screen
12:01:11 <Spark> type stuff into the text editor, then paste it accross to try it out
12:01:26 <shapr> do you use emacs?
12:01:31 <Spark> nah, vim
12:01:55 <shapr> you can always edit a file in vim, save it, and do ":r" in ghci
12:02:05 <Spark> ah right
12:02:06 <shapr> :r is short for :reload
12:02:12 <Spark> thats more likened to a debugger then i guess
12:02:29 <shapr> I don't know if there's a handy vim keystroke to dump the current buffer to ghci
12:03:25 <Spark> so ghci really is just the compiler, with a front end that allows you to evaluate stuff (and make some temporary definitions)
12:03:31 <shapr> that's right
12:03:43 <Spark> fair enough, is that the right terminology?
12:04:11 <shapr> ghc is a compiler, ghci lets you compile and dynamically load stuff
12:04:25 <shapr> lambdabot uses that same code to do runtime reload of plugins
12:04:30 <Spark> ok is "let add x y = x+y" a definition, or a declaration
12:04:34 <shapr> @listcommands dynamic
12:04:34 <lambdabot> Module dynamic provides the following commands: ["dynamic-load","dynamic
12:04:34 <lambdabot> unload","dynamic-reload"]
12:04:43 <Spark> or are haskell programmers not as anal as C programmers about terminology? :)
12:04:54 <Spark> cool
12:05:27 <shapr> I don't know
12:05:55 <Marvin--> I'd say it's a declaration that defines the function add
12:05:58 <Marvin--> but that's just me
12:06:42 <Marvin--> I don't know how anal we are about terminology, around here you'll find people spouting all sorts of category theoretic gibberish though
12:07:37 <shapr> yah, if your code works, you can call it whatever you like.
12:08:24 <Igloo> "let add x y = x+y" is a statement
12:08:34 <Marvin--> Igloo: point
12:08:41 <Igloo> "add x y = x+y" would be a declaration
12:09:01 <Igloo> and "let add x y = x+y in ..." an expression
12:09:29 <shapr> I now declare this to be an expressive statement.
12:22:12 <Si> shapr, you wanted my public key so that you could add me to the HWS-WP commiters, can I email it to you?
12:24:27 <shapr> Si: yeah, sure
13:08:45 <LittleDa1> Could people give me comments on this language design concept I have (or would that be too off-topic)?
13:09:31 <Riastradh> It's only on-topic if it sounds arcanely mathematical enough so that no one understands it.
13:09:37 <Riastradh> s/so that/that/1
13:10:09 <LittleDa1> This doesn't, but it's still fairly arcane :)
13:10:50 <LittleDa1> what if you had a variable model based exclusively on pattern matching, with implicit variable symbols?
13:11:43 <LittleDa1> it would be like
13:11:43 <LittleDa1> x = 5
13:11:43 <LittleDa1> tells the function at "" that if it recieves the variable symbol x it will return 5
13:12:44 <LittleDa1> and if you did
13:12:44 <LittleDa1> x a = 5
13:12:49 <LittleDa1> x b = 6
13:13:28 <LittleDa1> then that would tell it what to do if it recieved "x" as its first argument and "a" or "b"as it's second argument
13:13:49 <LittleDa1> then to evade this you use parens like this:
13:13:49 <LittleDa1> identity (x) = x
13:13:56 <LittleDa1> would that work?
13:15:28 <Igloo> I'm not entirely sure I'm following, but it doesn't sound like you could write useful recursive functions
13:15:40 <LittleDa1> yes you could
13:16:02 <Igloo> So what would the program to calculate n! look like?
13:17:24 <LittleDa1> factorial 0 = 1 -- since 0 not a valid variable name, uses normal pattern matching instead
13:17:25 <LittleDa1> factorial (x) = x * factorial (x - 1)
13:18:35 <LittleDa1> when you write "factorial", unless you've done something horribly wrong to "", it will look up what fits the pattern "factorial"
13:18:45 <Igloo> I think I just don't see the point then. What does it make easier? It feels like you 're going to be reintroducing something like synamic binding
13:19:30 <LittleDa1> you can do things like keyword arguments, namespaces (and modules can be just namespaces), and if you want to for some reason, OO
13:20:08 <LittleDa1> what's synamic binding?
13:20:28 <Riastradh> It's like dynamic binding, but infinitely cooler-sounding.
13:20:41 * Igloo is too busy to think about it right now
13:22:48 <LittleDa1> so what's dynamic binding, riastradh?
13:24:43 <LittleDa1> I don't see how it's at all similar to dynamic binding
13:39:04 <SyntaxNinja> Igloo: was ghc 6.2-3 uploaded in january or so, and is that the latest GHC stable in debian unstable, right?
13:40:21 <Igloo> Yes, if I parse you correctly
13:40:40 <Igloo> I'll probably upload 6.2.1 when it's released with the hope of it getting into sarge
13:41:04 <Igloo> Depends how I feel and how long it takes
14:15:43 <Pseudonym> @arr
14:15:44 <lambdabot> Yeh scurvy dog...
14:17:26 <skew> hi
14:17:35 <skew> how do you find the lambdabot commands?
14:17:43 <Pseudonym> @help
14:17:45 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
14:17:48 <Pseudonym> @listcommands
14:17:49 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions
14:17:49 <lambdabot> ,"del-definition","det","devils","dict","dict-help","dummy","dump","dynamic
14:17:49 <lambdabot> load","dynamic-reload","dynamic-unload","easton","echo","elements","eval
14:17:49 <lambdabot> ,"foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock
14:17:49 <lambdabot> ,"jargon","join","karma","karma+","karma-","learn","leave","listchans",
14:17:49 <lambdabot> listcommands","listmodules","lojban","moo","more","msg","part","prelude
14:17:52 <lambdabot> ,"quit","reconnect","resume","seen","set-fuel","shapr","state","topic-cons
14:17:52 <Pseudonym> There you go.
14:17:54 <lambdabot> ,"topic-init","topic-snoc","topic-tail","topic-tell","type","vera","web1913
14:17:56 <lambdabot> ,"wiki","wn","world02","yow"]
14:18:21 <skew> hmm. It seems to have grown that "try @listcommands" since yesterday
14:18:27 <skew> thanks
14:19:59 <skew> Oops.
14:20:25 <skew> Has your graph program gone anywhere?
14:20:54 <Pseudonym> @wiki StudyGroup/GraphExamplesInHaskell
14:20:55 <lambdabot> http://www.haskell.org/hawiki/StudyGroup/GraphExamplesInHaskell
14:21:24 <skew> Oh, no, I was talking about the program where you wanted a dynamic data flow graph
14:21:34 <Pseudonym> Oh, no.  Haven't tried it yet.
14:21:46 * Pseudonym is actually implementing it in C++, but is thinking about how it would be done in Haskell
14:30:20 <mattam> @fortune
14:30:21 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474, San Francisco, CA
14:30:21 <lambdabot> 94140, USA
14:41:48 <bring> shapr: the deed is done
14:47:29 * earthy congrats bring
14:55:14 <earthy> nytol
14:55:20 <Pseudonym> Night.
14:56:11 <stepcut> lets say I have a function: myfunc f None -> None and myfunc f (Some x) -> Some (f x)
14:56:25 <stepcut> what would be a good name for myfunc?
14:56:36 <skew> fmap
14:57:15 <skew> and what's this Some and None for?
14:57:26 <stepcut> sorry, Some = Just, None = Nothing
14:57:26 <mattam> ocaml's option type
14:57:38 <Pseudonym> Oh, this isn't Haskell code?
14:57:44 <stepcut> forgot to fully translate it haskell code :)
14:57:48 <skew> Oh, it's not haskell?
14:57:49 <Pseudonym> Ah. :-)
14:57:56 <Pseudonym> Well it already exists and it's called fmap.
14:58:06 <skew> well, in haskell that's the fmap method of the Functor instance for Maybe
14:58:14 <stepcut> where is that defined? I did not see it in Maybe
14:58:15 <skew> I don't know about O'Caml.
14:58:25 <skew> it's defined in the class Functor
14:58:25 <Pseudonym> It's in Data.Monad, I think/.
14:58:33 <skew> in the prelude. The instance is in Data.Maybe
14:58:41 <Pseudonym> Ah, OK.  In the prelude.
14:58:42 <skew> maybe Functor is in Data.Monad
14:58:53 <Pseudonym> @type fmap
14:58:53 <lambdabot> fmap :: Functor a => (b -> c) -> a b -> a c
14:58:57 <Pseudonym> Prelude. :-)
14:59:03 <stepcut> ah
14:59:24 <skew> Data.Monad doesn't exist anyway. It's Control.Monad
14:59:31 <Pseudonym> You're right.
14:59:49 <skew> I like this @type thing, I just couldn't remember what it was called
15:00:26 <stepcut> thanks, I knew I say it this weekend, but I could not find it
15:46:06 <saz> hmm.. how do you install packages for use with ghc?
15:46:23 <skew> which one?
15:46:27 <saz> wx
15:46:31 <skew> most have a makefile
15:46:38 <saz> aah
15:47:06 <saz> gotchya
15:47:15 <stepcut> is there someplace that has generic makefiles for people making their own ghc libraries?
15:47:31 <stepcut> something with the targets for install-ghc-files-only: and stuff
15:47:41 <skew> I think there was something slightly odd about getting wxHaskell to add a package description to packages.conf, but hopefully it has cleared up in the two intervening releases
15:50:37 <skew> stepcut, I don't know of any makefile templates like that
15:50:54 <skew> but you could use the makefile from some other package
15:51:08 <skew> I remember one that seemed to be particularly nice, I'll try to find it
15:51:46 <saz> this is weird
15:51:54 <saz> why does it want to run make install before configure?
15:52:01 <stepcut> haha
15:52:05 <skew> that's probably confused
15:52:12 <saz> install libraries at : /usr/local/lib
15:52:12 <saz> error:
15:52:12 <saz>  Unable to find the 'wx-config' program: wx-config
15:52:12 <saz>  Maybe you forgot to run 'make install' on wxWindows?
15:52:12 <saz>  Otherwise, add the install directory of wx-config to your path.
15:52:30 <skew> oh, you need to install wxWindows before you can install the haskell binding
15:52:31 <saz> oooh
15:52:33 <saz> right
15:52:38 <saz> :)
15:53:46 <Igloo> If you are using Debian there are debs in HE
15:54:23 <saz> HE?
15:54:29 <saz> is it wxwin2.4?
15:54:39 <Igloo> Sounds right
15:54:50 <saz> there's headers, examples and docs
15:54:52 <Igloo> http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html
15:54:55 <saz> do i need headers?
15:54:57 <saz> ah
16:02:30 <skew> stepcut, I was thinking of the wxHaskell makefile. They use an interesting approach that seems pretty flexible
16:03:30 <stepcut> ok, thanks
16:03:51 * Jerub read that as 'fixable' ;)
16:04:51 <saz> hm, after installing the wxhaskell package
16:04:58 <saz> it still can't find the package..
16:05:11 <saz> (i just installed the .deb)
16:05:21 <skew> is wx-config in the path?
16:05:39 <saz> no
16:06:01 <saz> i would have thought apt would have resolved the dependencies though
16:09:14 <Pseudonym> Does anyone here have a good intuition about adjoint functors?
16:09:46 <skew> no. what do you need?
16:10:02 <Pseudonym> I'm trying to connect it to the notion of an "adjoint" in an inner product space.
16:11:05 <skew> what was that?
16:11:17 <skew> conjugate transpose?
16:11:27 <Pseudonym> Yes, that's it for the case of matrices.
16:12:01 <skew> well, the adjoint operation seems to be an endofunctor
16:12:18 <Pseudonym> The important property of adjoint operators/matrices is that if you have two vectors x and y, and an inner product < | >, then <A x | y> = <x | A* y> where A* is the adjoint of A.
16:12:40 <Pseudonym> The idea being that you can move the operator/matrix across an inner product from one side to the other.
16:12:42 <skew> that's very similar to the property of an adjoint
16:12:58 <skew> Arr(x,Fy) ~= Arr(F^-1x,y)
16:13:05 <Pseudonym> Oh...
16:13:11 <Pseudonym> Hmmm.
16:13:37 <skew> It's probably just a matter of formalizing the inner product space in the right way
16:13:43 <Pseudonym> Yes.
16:15:25 <Pseudonym> Hang on, if F and G are adjoint functors, you mean here that Arr(x,Fy) and Arr(Gx,y) are isomorphic, right?
16:15:34 <skew> yes
16:16:25 <skew> I think that's enough to require that pairing (if your category has pair) distributes over the adjoint functors
16:29:27 <Spark> is there an online api reference for the haskell standard libaries?
16:29:45 <Spark> i used to do explode "fish" in sml to get ['f','i','s','h']
16:29:58 <skew> no need. String = [Char]
16:30:06 <Spark> oh right
16:30:16 <skew> the documentation is at the GHC website
17:51:56 <Igloo> Grr, input validation in wxHaskell is one of those things where I sit staring at the screen for ages waiting for a path to beauty to spring forth
21:22:55 <skew> I should write a Haskell binding for Python.
21:23:28 <stepcut> like pycaml?
21:23:41 <skew> maybe
21:24:08 <stepcut> i think there are perl<->haskell bindings too ;)
21:24:39 <skew> that goes both ways? Maybe something like that
21:25:04 <skew> I'm mostly interested in access to libraries
21:25:07 <skew> all the web stuff and such
21:25:43 <stepcut> it could be useful...
21:27:36 <Jerub> hmm.
21:28:51 <stepcut> Then again, if someone (like myself) finished the damn Binary.hs file, it would be easier to write native libraries ;)
21:29:47 <skew> a nice interface for packing and unpacking binary data could be useufl
21:29:55 <skew> it doesn't sound very complicated either
21:30:18 <skew> just make a little typesafe combinator language
21:30:25 <Jerub> HTTP.hs got my attention last inght.
21:33:05 <stepcut> skew: yeah, its well known HOW to do it, just nobody has
21:33:34 <stepcut> nhc has a good Binary.hs that even handles bit fields, but no one has completed a port to GHC
21:34:00 <skew> why not?
21:34:52 <stepcut> well, I have not done it because I have not had time yet. I don't know about anyone else.
21:35:09 <skew> why doesn't it just work?
21:36:41 <stepcut> you mean the nhc version?
21:36:47 <skew> yes.
21:36:55 <skew> I remember something about nhc deriving a Binary class
21:37:03 <skew> but that seems inessential to functionality
21:38:51 <stepcut> I don't remember, but here is the last documented activity on the project:
21:38:53 <stepcut> http://www.haskell.org/pipermail/libraries/2002-November/thread.html#697
21:40:15 <stepcut> I emailed Hal Daume III recently, and he has not had time to work on it, so if you feel inspired...
21:42:25 <stepcut> (and I ain't done nothing either ...)
