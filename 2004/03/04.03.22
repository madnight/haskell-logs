00:04:11 <Cale> ah, okay
00:25:53 * shapr boings
00:26:15 <reltuk> yo shapr
00:26:36 <shapr> what's going on?
00:26:51 <reltuk> not much...reading that paper on Monads and still being dumb
00:27:17 <earthy> `that paper on monads' -- too much ambiguity
00:27:36 <reltuk> lol, "Monadic Parser Combinators"
00:27:40 <earthy> moggi's papers? those by Philip Wadler? maybe the ones by Jones? :)
00:27:53 <earthy> ah, Meijer et al, right?
00:28:22 <reltuk> Huton, Meijer...yeah
00:28:26 * earthy nods
00:28:31 <earthy> nice paper
00:28:35 <earthy> blew me away when I first read it
00:28:56 <earthy> especially as S. D. Swierstra had just given a talk on deterministic parser combinators just before
00:29:37 <reltuk> I kind of understand it...
00:29:45 <reltuk> I really don't understand the state monad though  :-p
00:29:54 * earthy grins
00:29:55 <reltuk> which isn't in the paper
00:30:08 <shapr> oh, I might have some help there
00:30:31 <earthy> find Wadlers `The essence of functional programming' or the paper on `Tackling the awkward squad'
00:30:33 <shapr> http://www.cs.fit.edu/~satkin/monads.html
00:31:13 <shapr> I learned a lot about state monads by going through steve atkin's sources there
00:31:29 <reltuk> ahhh, thanks  :)
00:33:00 <Jerub> I've read that paper too.
00:33:34 <Jerub> reltuk: after you read monadic parser combinators, grab the parsec paper to see how we do it nowadays ;)
00:33:40 <shapr> two things that make a big difference in a state monad, first, it's a parameterized type
00:34:33 <shapr> actually, I'm not sure the second thing I was thinking makes any sense ;-)
00:34:42 <reltuk> heh
00:35:12 <shapr> http://www.cs.fit.edu/~satkin/haskell/Eval3.hs
00:36:04 <shapr> reltuk: if you look at that file, what's the type of eval?
00:37:12 <reltuk> a function from a term to a function from an intial state to a result, state
00:38:53 <shapr> so, the monad packages up the pipes into a simpler structure
00:38:59 <shapr> it's an abstraction
00:40:08 <reltuk> so why a monad?
00:41:10 <shapr> greetings wuehlmaus 
00:41:16 <wuehlmaus> hi, shapr :)
00:41:24 <shapr> you want to know how to get a function with two arguments, right?
00:42:08 <shapr> if you look at this page: http://www.scannedinavian.org/AvianWiki/HaskellDemo
00:42:26 <shapr> you'll see the add function near the top
00:42:50 <shapr> since Haskell is based on lambda calculus, it does currying
00:42:52 <shapr> @type curry
00:42:52 <lambdabot> curry :: ((a,b) -> c) -> a -> b -> c
00:43:25 <reltuk> @type flip
00:43:25 <lambdabot> flip :: (a -> b -> c) -> b -> a -> c
00:43:26 <kosmikus> shapr: since when do you know the question before it is asked? you're *better* than any bot ... ;)
00:43:32 <reltuk> hehe...I love that function
00:43:38 <reltuk> @type curry . flip
00:43:38 <lambdabot> curry . flip :: (a -> (b,c) -> d) -> b -> c -> a -> d
00:43:56 <shapr> that means that a single function that takes (x,y) and evaluates to z can be rewritten as two nested functions where the first one takes x and returns a new function that takes y and returns z
00:43:57 <reltuk> @type flip . curry
00:43:58 <lambdabot> flip . curry :: ((a,b) -> c) -> b -> a -> c
00:44:05 <shapr> kosmikus: I've been talking to wuehlmaus on another channel :-)
00:44:21 <Cale> heh
00:44:26 <reltuk> ahh...that's more like it.../me wonders what semantic meaning of curry . flip is
00:45:03 <wuehlmaus> now has it to be nested first?
00:45:05 <earthy> reltuk: isn't it obvious? :)
00:45:15 <shapr> in Haskell, it's automatic
00:45:18 <wuehlmaus> i love learning without nesting functions in the first place
00:45:27 <kosmikus> earthy: where are you today?
00:45:41 <earthy> working at home
00:45:51 <shapr> since (+) is the function that adds numbers,(1 +) is a function that adds one to numbers
00:46:12 <earthy> given that there were barely any trains from Nijmegen to Arnhem *and* an accident dropping all travel between Ede-Wageningen and Driebergen-Zeist
00:46:31 <shapr> I use partial application to get something like object instances in functional programming
00:46:53 <reltuk> (+ 1) does too...so cool
00:46:53 <kosmikus> earthy: I see
00:46:55 <reltuk> @type (+ 1)
00:46:56 <lambdabot> flip (+) 1 :: Num a => a -> a
00:47:03 <shapr> @type (1 +)
00:47:04 <lambdabot> (1 +) :: Num a => a -> a
00:47:20 <shapr> @type (+)
00:47:21 <lambdabot> (+) :: Num a => a -> a -> a
00:48:12 <shapr> the a -> a -> a is right associative, so it really means a -> (a -> a), or "a function that takes an a and evaluates to a new function, the new function takes an a and evaluates to an a"
00:48:29 <shapr> wuehlmaus: does that help?
00:48:45 <wuehlmaus> i am full now :)
00:48:57 <shapr> heh, ok
00:50:12 <Jerub> shapr: I've just recently begun to grok the State monad.
00:50:24 <Cale> The idea is that any function of n arguments is a function which takes its first argument and gives a function of n-1 arguments.
00:50:31 <Jerub> shapr: do notation is deceiving.
00:50:43 <shapr> it's designed to be deceiving in a pretty way
00:50:52 <Jerub> yes! its very pretty!
00:51:05 <shapr> but you're right, I think people should start with >>=
00:51:34 <Jerub> or even that >@> thing.
00:51:36 <earthy> do notation shoves the functional character of the second argument of bind under the rug
00:51:37 <reltuk> shapr, yeah, I thought I had Eval3.hs, but I went to Eval6.hs and got blown away again
00:52:19 <shapr> the Eval examples cleared up a lot of stuff for me
00:52:30 <shapr> I didn't understand all of monads after that, but I understand State a lot better.
00:52:45 <Jerub> oh cool.
00:52:54 <Jerub> this is *exactly* what I was looking for.
00:53:04 <Jerub> a set of examples of funky monadic stuff.
00:54:07 <Jerub> I'm using Parsec, so I've got getState, setState and updateState, its almost *too* simple.
00:54:11 * cuelebre salutes
00:54:19 <shapr> salute cuelebre 
00:58:39 <reltuk> doesn't standard ml have real state?
00:58:46 <kosmikus> what is >@> ?
00:59:02 <shapr> I've seen that combinator, but I don't remember where.
00:59:21 <Jerub> kosmikus: construct used in thomsons craft of functional programming as a monadic thinking training wheel.
00:59:26 <Jerub> he writes a parser using it.
00:59:36 <kosmikus> ok, will look there ...
00:59:58 <Jerub> unfortunately he didn't follow it up by going >@> to >>= to do, he went >@> to do to >>=
01:01:50 <kosmikus> okay, I'd call that "monadic composition"
01:02:43 <kosmikus> maybe with a "reverse" in it ...
01:04:31 <Jerub> @type concat
01:04:32 <lambdabot> concat :: [[a]] -> [a]
01:08:36 <phubuh> reltuk: SML isn't purely functional, if that's what you're asking
01:16:06 <reltuk> Why is Maybe a Monad?
01:16:15 <reltuk> phubuh, yeah...no use for Monads  :-p
01:16:58 <earthy> reltuk: because that allows you to thread `failure'
01:17:28 * Jerub considers how to store type information.
01:18:06 <Jerub> anyone got a paper on implementing a decent type system using a monadic parser combinator, haskell, and ... 3 packets of crispy biscuits?
01:18:38 <kosmikus> a type system *using* parser combinators?
01:19:17 <reltuk> Jerub, "decent type system" like what?  a basic one like ml or haskell has?
01:19:19 <reltuk> (no classes...)
01:19:47 <kosmikus> that would be my next question, yes
01:21:21 <reltuk> when I implemented my ml-like type system, I only needed one destructable data-type, and it was an integer that returned an integer that was one higher than the last one each time it was called... (it could be reset)
01:23:10 <Jerub> i'm trgeting parrot
01:24:14 <kosmikus> reltuk: you could thread that counter explicitly, use a monad, or use linear implicit parameters ...
01:24:24 <kosmikus> I don't know parrot
01:24:25 <Jerub> it'd be nice to have a really nice type system like haskell's, but I don't think I could impleement it.
01:24:46 <reltuk> kosmikus, I don't know what "thread that counter explicitly" means...and I don't think I could do it with a monad yet, but I'm getting there
01:25:02 <Jerub> kosmikus: think register machine, 128 registers, 32 each of integer, float, string and magic cookies.
01:25:08 <reltuk> Jerub, it's pretty easy to implement a type-inferencing system like Haskell or ML has
01:25:16 <Jerub> reltuk: yay!
01:25:21 <Jerub> where do I read about it!
01:25:21 <reltuk> Jerub, I don't know about classes, but I don't think they would be a *lot* harder
01:25:40 <reltuk> Jerub, just a second...let me check
01:25:45 <kosmikus> reltuk: "thread the counter explicitly" means that everything of type "a" becomes something of type "Int -> (a,Int)" instead; very annoying, monad is better
01:25:57 <reltuk> acutally...I can't check unless citeseer is back up
01:26:12 <earthy> http://citeseer.ist.psu.edu/ down again?
01:26:23 <reltuk> was earlier
01:26:26 <reltuk> at least for me
01:26:30 <earthy> damn
01:26:32 <reltuk> still looks like it
01:26:47 <earthy> they should get their act together...
01:27:01 <kosmikus> I agree that it is not really hard, but I don't know any good references, unfortunately.
01:27:09 <reltuk> Jerub, damas-milner type system
01:27:28 <reltuk> or hindley-milner...
01:28:22 <Lunar^> kosmikus: Another solution is using new implicit parameters
01:29:43 <reltuk> Jerub: http://www-courses.cs.uiuc.edu/~cs321/current/lectures/TypeDeriv/TypeDeriv-Slides-Lect.pdf
01:29:48 <reltuk> that will give you the premis of the system...
01:30:08 <reltuk> admittedly probably not what you're looking for  :-p
01:30:40 <reltuk> oh...I guess my type system had implicit state in it's Map...
01:30:48 <reltuk> that sucks...another Monad I guess
01:30:55 <reltuk> Monad's seem so obtuse :-p
01:31:38 <shapr> they're just another way to do abstraction
01:31:55 <shapr> they hide some complexity behind the scenes
01:32:11 <reltuk> I still don't understand how you use them to get a mutable datastructure though
01:33:03 <Jerub> reltuk: you don't!
01:33:05 <Lunar^> kosmikus: see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#LINEAR-IMPLICIT-PARAMETERS
01:33:23 <Jerub> reltuk: the datastructure at the next step is some function of the datastructure at the previous step!
01:33:46 <reltuk> Jerub, but you can't rebind it...
01:34:28 <reltuk> Jerub, so how can I use that to give me a function that returns an integer one higher than the last integer it returned? (and 0 if I called reset)
01:35:36 <Jerub> reltuk: okay, let me think this one through.
01:36:56 <earthy> reltuk: you don't.
01:38:34 <reltuk> ok...then how do you make a counter?
01:40:03 <Jerub> earthy: you DO!
01:40:12 <earthy> jerub: not as he stated it.
01:40:23 <Jerub> well, as I intended it to mean.
01:40:37 <earthy> you *could* build a combination of datatype and functions that allow you to
01:40:37 * Jerub walks down to pick up his textbook
01:41:15 <earthy> you need to explicitly couple the counter with the data that you're traversing while counting
01:41:55 <earthy> then, you abstract over the type of the data traversed
01:42:07 <earthy> and build the functions that maintain the counter abstractly
01:42:22 <reltuk> the data traversed is an abstract syntax tree...
01:42:39 <earthy> reltuk: let's say that you have an AST type a
01:43:09 <reltuk> ok
01:43:18 <earthy> you'd need to then make a tuple (Integer,a) to represent the counter
01:43:37 <earthy> (since it isn't in a)
01:43:43 <reltuk> but the counter doesn't know anything about a...
01:43:52 <earthy> it doesn't need to, does it?
01:44:01 <reltuk> nope
01:44:14 <earthy> but the functions that traverse a need to have access to the counter, right?
01:44:19 <earthy> that's why you tuple it.
01:44:34 <reltuk> oh, ok
01:44:44 <earthy> now, say you had a function  traverse :: a -> b
01:44:51 <reltuk> yeah, I see where this is going...
01:45:01 <earthy> this then has to become a function traverse (Integer,a) -> (Integer,b)
01:45:02 <reltuk> 'cept after the counter changes, you need to recurse...
01:45:07 <earthy> reltuk: exactly
01:45:21 <reltuk> how does a monad help with that?
01:45:40 <earthy> well, a monad is a type constructor with functions bind and return
01:46:04 <earthy> in this case, the type constructor does the tupling for you
01:46:49 <earthy> return injects elements of type a into that tuple
01:46:49 <reltuk> ok, but with a new monad, you still need to recurse to rebind it?
01:47:38 <earthy> bind recurses on the second function using the `returnvalue' from the first
01:48:01 <reltuk> hmm...right...
01:48:05 <reltuk> but the thing that uses the monad...
01:48:31 <reltuk> or am I not making any sense?
01:48:57 <earthy> hands off doing the actual recursion to bind, and only specifies where it should happen
01:49:16 <earthy> (stated in your terms, I find the word `recursion' somewhat misleading here)
01:50:12 <reltuk> hmm...ok
01:52:24 <reltuk> so would you have to traverse the tree in the monad too?
01:52:40 <reltuk> or could you just put the counter in it's own monad and have everything be sane
01:57:39 <reltuk> oh well, I gotta hit the sack, it's like 4 AM
01:57:46 <reltuk> I'll read more about this later...
01:57:53 <reltuk> thanks for the help and patience  :)
02:12:42 <kosmikus> Lunar^: re linear implicit parameters: I said so ... < kosmikus> reltuk: you could thread that counter explicitly, use a monad, or use linear
02:13:01 <kosmikus>                   implicit parameters ...
02:17:29 <Lunar^> kosmikus: Morning illness :)
02:30:06 <Jerub> wow, found an ergonomic keyboard I havne't found yet, http://www.typematrix.com/images/products/keyboard_2020_de_640.jpg
03:06:29 * Lunar^ vient de decouvrir que pour acceder a la fenetre 12 sur IRC il fallait faire Meta-W (qwerty)
03:07:25 * shapr blinks
03:09:52 <Lunar^> oups
03:10:26 <shapr> je ne comprends pas!
03:10:27 <Lunar^> Playing with irssi windoes...
03:10:28 <saz> french?
03:10:35 <shapr> oui, merci
03:10:55 <Lunar^> I was saying that I just discovered that you can jump on irssi window 12 with M-W
03:11:04 <shapr> cool
03:11:20 <Lunar^> But this message was for window 4, not 6... All this windows... on a terminal... urg
03:11:21 <earthy> ah, yes. I didn't parse the `acceder' :)
03:12:03 <Lunar^> Sorry for the noise :(
03:12:22 <shapr> pas de problem
03:12:37 <earthy> nous comprenons.
03:12:44 <shapr> Henrik Nilsson doesn't think the Yampa license thing is a problem
03:12:48 <earthy> (that sounds odd, somehow :))
03:12:56 * shapr sighs
03:13:05 <Lunar^> shapr: What is current Yampa license ?
03:13:23 <shapr> something like "only we can make changes, you can't redistribute"
03:13:41 <shapr> they keep saying they'll change it to BSD
03:13:41 <shapr> and that's good
03:13:47 <shapr> but they haven't done it yet
03:14:32 <Lunar^> shapr: I can study the source code anyway.. I should really do it soon in fact
03:14:40 <shapr> it's powerful stuff
03:14:59 <Lunar^> shapr: Using Control.Concurrent.Chan for IPC is not what we call fast IPC, I think
03:15:06 <shapr> since the repeated emails to the yampa-users list requesting the license change, I think they'll do an interim release of the old code with the new license
03:15:34 <shapr> from whay they've said on the mailing list, they have a new version that's not ready for release
03:15:52 <shapr> well, at the moment functioning IPC is good enough
03:16:40 <Lunar^> shapr: For the keyboard driver, I'm now with : keypressesChan <- launchKeyboardDriver >>= launchKeyboardDecoder >>= launchKeyboardInterpreter
03:17:30 <Lunar^> shapr: with launchKeyboardDriver :: IO (Chan Word8), launchKeybardDecoder :: Chan Word8 -> IO (Chan KeyEvent), launchKeyboardInterpreter :: Chan KeyEvent -> IO (Chan KeyPress)
03:18:07 <earthy> lunar^: so, you don't have a raw I/O mode?
03:18:12 <earthy> only cooked?
03:18:14 <Lunar^> shapr: Each of them forks in a new thread, waiting for data to arrive on the chan (or IRQ for the first one) to produce data on outer chan
03:18:36 <Lunar^> earthy: What do you call "rawI/O" ?
03:19:04 <earthy> in Unix, if you access a terminal in raw mode you get the exact scancodes the keyboard presents you
03:19:34 <earthy> without all the sugaring that cooked mode provides you, such as ctrl-character decoding
03:19:55 <Lunar^> To finish, This really looks like Arrows IMHO
03:20:01 <earthy> oh yeah, it does
03:20:06 <Lunar^> earthy: Sure you can get the first chan and duplicate it !
03:21:17 <earthy> lunar^: yes, but the code as given doesn't, riht?
03:21:54 <Lunar^> earthy: hOp is only a lot of small hack and experimentations at this time
03:22:36 <earthy> and if you consider it as an OS that you program to there is then no way to directly get at it...
03:22:59 <Lunar^> earthy: I still haven't resolved how could each thread could have each own IO state (=> where should putStr go ?)
03:24:01 <Lunar^> earthy: But I sure understand your point
03:25:49 <earthy> okay, I was thinking way too far already
03:27:25 <Lunar^> The question about arrows is quite important now because this could structure the look of the drivers framework
03:29:39 <earthy> well, the arrows would give you plumbing to combine e.g. raw and cooked access to your keyboard and switch `in userland'
03:30:44 <Lunar^> Sure... also between driver components : an IRQ is an impulsion in signal thinking
03:31:01 * earthy nods
03:33:18 <Lunar^> Malcom Wallace work is really interesting for that part (see http://www-users.cs.york.ac.uk/~malcolm/ )
04:05:15 <shapr> greetings cm
04:05:21 <cm> hiho shapr
04:05:31 <shapr> what's going on?
04:05:47 <cm> 2 hours of relaxation between school and school ;)
04:05:56 <cm> and i should decide whether to go to cebit
04:06:00 <cm> how about you?
04:06:32 <shapr> having fun with HaskellDB, writing a SQL -> HaskellDB tutorial
04:06:49 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDbTutorial
04:06:49 <cm> oh cute, where are you gonna publish it?
04:06:53 <cm> ah :)
04:07:04 <shapr> well, I think it's as published as it wil lbe
04:07:17 <cm> let me have a look :)
04:07:22 <shapr> I mostly wrote it as a self-tutorial, but I'd be happy if others can learn from it also
04:09:13 <cm> .==., funky
04:10:07 <shapr> yah, it is
04:10:15 <cm> shapr: say, the "do" isn't really necessary if the body is just a single expression, right?
04:10:59 * shapr thinks about that
04:11:14 <shapr> I'm not sure
04:11:18 <earthy> cm only if that expression is a return
04:11:49 <cm> hrm
04:12:14 <earthy> or something that does a return, basically
04:12:25 <earthy> do notation is just sugar, after all
04:12:33 <ibid> in other words, do is not necessary if its body is just one expression :)
04:12:45 <cm> that's what i thought
04:13:14 <cm> shapr: "query db (table Articles.Articles.articles)" <-- what is Articles.Articles.articles in there?
04:13:41 <shapr> whoops
04:13:54 <cm> ourtable? "ourtable"?
04:13:55 <shapr> that's called a type
04:13:56 <shapr> typo
04:13:58 <shapr> yes, it should be
04:14:03 <cm> :)
04:14:03 * shapr fixes
04:14:26 <cm> (anyway /me nitpicking should be a good sign that i can't find any real mistakes ;-)
04:14:53 <shapr> useful input, thanks
04:15:29 <shapr> some of my other test code uses the Articles.Articles.articles table descriptor
04:15:52 <shapr> I should probably rewrite that page as a LaTeX .lhs so I can build in some unit tests
04:16:05 <shapr> or at least the ability to execute the examples directly from the docs
05:34:13 <Lunar^> shapr: I see clearly your darcs lobying on librairies :)
05:34:22 * shapr grins evilly
05:34:29 <Lunar^> :)
05:34:36 <shapr> I only wish I had a good response for the $Id question
05:36:31 <Lunar^> I don't like Id
05:52:17 <Si\> do you think in an array the size (not the number of dimensions) of the array is a part of its type or a part of its content?
05:53:12 <shapr> interesting question
05:53:18 <ibid> both
05:53:33 <ibid> or, at least, there should ideally be both kinds of arrays
05:53:40 <shapr> I guess it depends on whether you implement an N-dimensional array as N 1D arrays
05:54:05 <Si\> I think that only the number of dimensions is part of the array
05:54:43 <Si\> because if the type also encapsulated it's size then there would be an infinite number of array types
05:55:01 <ibid> so?
05:55:08 <Si\> e.g. int[2] /= int[3] etc.
05:55:27 <ibid> there are an infinite number of function types, too, and i don't see anybody complaining
05:55:47 <Si\> hmmm
05:55:54 <ibid> Si\: obviously, but that has nothing to do with types
05:56:08 <ibid> hmm
05:56:09 <ibid> sorry
05:56:32 <kosmikus> ideally, a language allows you to put as much information into the types as you want
05:56:36 <ibid> for any two arrays, one of which being int[2] and the other being int[3], they are always different
05:56:56 * shapr hides his grocery list in the type of his Hello World function
05:57:24 * earthy laughs at shapr
05:57:49 <shapr> helloWorld :: (InTheFridge eggs, InTheFridge milk) => [Char] -> IO ()
05:58:12 <shapr> would that actually work?
05:58:14 * shapr tries
05:58:25 <ibid> shapr: eggs, milk do not occur in the type
05:58:30 <ibid> hence not valid
05:58:32 <Si\> But if an array of n elements is not the same type as an array of n+1 elements, how come a function takes a parameter Array Int * which encapsulates the set of all arrays of size within the integer range
05:58:43 <shapr> ibid: yah, but, will it compile?
05:58:50 <ibid> Si\: it doesn't
05:59:05 <ibid> shapr: not valid -> does not compile imho :)
05:59:26 <ibid> Si\: if the length is a part of the type, the function will be polymorphic
05:59:52 <Si\> so Array Int * is in reality a polymorphic type?
06:00:18 <ibid> Si\: if the length is a part of an array type, yes
06:00:24 <ibid> Si\: but not unqualifiedly
06:00:48 <ibid> Si\: as i said, both solutions make sense, and so a wise language designed puts both into eir language
06:01:50 <Si\> I'll explain why I ask;
06:02:15 <Si\> in SOAP you can Arrays, and an Array may have the type of say int[6]
06:02:27 <shapr> All of the type variables in the constraint `InTheFridge Eggs' are already in scope (at least one must be universally quantified here)
06:02:36 * shapr scratches his head
06:02:41 <Si\> now if I have an array within that array, then the type is not int[][6]
06:02:55 <Si\> so the array contains elements of type int[]
06:03:10 <ibid> "then the type is not int[][6]"?
06:03:20 <Si\> sorry
06:03:28 <Si\> I can't think of why I wrote not
06:03:32 <shapr> what the heck is it talking about? universally quantified what?
06:03:39 <shapr> oh, I bet I need to use newtype or something
06:03:45 <kosmikus> shapr: what's the input?
06:04:07 <ibid> Si\: typo for "now"?
06:04:15 <Si\> probably
06:04:23 <shapr> I was using "type Eggs = Int" and "helloWorld   :: (InTheFridge Eggs, InTheFridge Milk) => [Char] -> IO ()"
06:04:32 <Si\> yes, that must of been what I was thinking
06:04:45 <shapr> but I think I need to use newtype to make instances that aren't already defined for Int/Char etc
06:05:02 <Igloo> YTou can't give meaningless context info
06:05:08 <shapr> why not?
06:05:08 <Si\> ok, so how come the top level array's type encapsulates size, but the lower level array only encapsulates dimensional size
06:05:12 <ibid> shapr: Eggs and Milk are types, not type variables as they should be
06:05:29 <shapr> oh, right
06:05:30 <shapr> good point
06:05:31 <kosmikus> shapr: because Haskell is overly restrictive ;)
06:05:38 <Igloo> Because the compiler will try to stop you from doing something stupid
06:05:54 <shapr> this sounds like a good rationale for using Haskell actually
06:06:05 <ibid> Si\: i do not know SOAP, but in C-like languages int [][6] means that the "inner arrays" have size 6 and the outer array's size is unspecified
06:06:07 <shapr> "I'm sorry Dave"
06:06:33 <Igloo> You could just name type variables after what you want, e.g. id :: eggs -> eggs
06:07:52 <kosmikus> it's not stupid if you want to write (InTheFridge Int) in a context ...
06:08:31 <kosmikus> you could have this function in a module M, which is imported into a module N where this instance is available, whereas it isn't in M ...
06:08:36 <ibid> only stupid people want ints in the fridge :)
06:09:05 <Igloo> It's zero information given how the typechecker works
06:09:16 <kosmikus> ibid: you're right, mine is full of Char's ...
06:09:24 <shapr> I think this whole conversation belongs on the QuotesPage
06:09:24 <ibid> :)
06:09:56 <shapr> anyways, I do want to see if I can include useless info in the type sig
06:10:11 <shapr> or if GHC will stop me
06:10:16 <kosmikus> Igloo: true
06:10:46 <shapr> can you explain that?
06:11:27 <ibid> kosmikus: a double in the fridge would be nice :)
06:12:11 <shapr> heh
06:13:41 <shapr> helloWorld   :: InTheFridge Int => [Char] -> IO ()
06:13:45 <shapr> same error
06:13:53 <shapr> about universally quantified
06:14:25 <shapr> All of the type variables in the constraint `InTheFridge Int' are already in scope (at least one must be universally quantified here)
06:14:30 <kosmikus> it's a strange error message
06:14:32 <kosmikus> but true
06:14:49 <kosmikus> "all of the" in the case denotes the empty set
06:15:01 <shapr> eh?
06:15:24 <earthy> all of `no typevariables' == the empty set ;)
06:15:38 <shapr> so, do I need to switch to something like forall grocery?
06:18:52 <cm> type Kitchen b a = a
06:18:52 <cm> type Weed = Integer
06:18:52 <cm> helloWorld :: Kitchen Weed [Char]
06:18:52 <cm> helloWorld = "test"
06:18:57 <cm> ;)
06:19:30 <Igloo> Phantom shopping?
06:19:30 <cm> less cool, granted. but works in ghc ;)
06:20:01 <kosmikus> yeah, the Kitchen type is nice; it's also possible to simulate GHC kind annotations in Haskell 98 that way
06:20:23 <cm> and i suppose you can have a list of stuff, too:   helloWorld :: Kitchen (First,Second,Third) RealType ;)
06:20:35 <cm> anyway, off to school.. gotta give a PHP introduction, whee :(
06:20:39 <ibid> tuple of stuff!
06:20:39 <ibid> :)
06:20:48 <shapr> have fun at school
06:20:53 <cm> ibid: true :)
06:20:58 <cm> ta, bye bye everyone
06:22:02 <shapr> that's a neat example
06:27:48 <Si\> afaics then it depends on the language as to whether array size is part of its type, but in both Haskell and SOAP (or rather XSD) it is
06:28:41 <ibid> in haskell it definitely is not
06:30:19 <Si\> I thought you said it was
06:31:50 <ibid> i did not
06:32:53 <Si\> ok
06:34:39 <SyntaxNinja> shapr: so I've had some interesting thoughts on The Pragmatic Programmer as to how it relates to Haskell.  I find myself often thinking, "Boy, this just isn't a problem in Haskell" or "Boy, you just can't do that very easily in Haskell". examples of the later are "attributes" (ala all those talks at icfp'03) error checking tests that can be turned on or off at compile-time or at run-time (eww, threading a monad through everything just to say if we
06:35:33 <shapr> attributes in the sense of object attributes?
06:36:35 <shapr> by error checking do you mean assertions that are optionally compiled in?
06:36:49 <SyntaxNinja> yes, that's what I mean by error checking
06:37:04 <SyntaxNinja> or to be able to check preconditions and postconditions, but only optionally
06:37:40 <shapr> could you do that with arrows?
06:37:41 <SyntaxNinja> now I tend to think that "design by contract" can be mostly fulfilled by the type system in Haskell, so it's perhaps not as important, but there are definitely times when I wish there were some kind of Eiffel-like syntax
06:38:11 <shapr> I'm not sure about postconditions, but arrows are all about preconditions
06:38:28 <shapr> or are they
06:38:32 * shapr thinks more
06:39:07 <shapr> sure, I think you could make some DbC arrows
06:39:22 <shapr> but I'd have to try it to be certain
06:40:05 <SyntaxNinja> heh
06:40:06 <SyntaxNinja> not sure.
06:40:31 <shapr> that would be a fun PhD thesis
07:22:55 <shapr> is there a Right or Bust function?
07:23:04 <shapr> oh, I know how to do it, duh
07:24:01 <shapr> man, I want a concatRight
07:24:21 <shapr> er catRight
07:29:24 <kosmikus> type?
07:42:47 <bring> shapr: as in [x | Right x <- xs]?
07:46:28 <shapr> exactly
07:48:50 <shapr> bonjour bangha 
07:49:02 <bangha> bonjour
07:49:04 <shapr> do you know kowey?
07:49:18 <bangha> yes
07:49:48 <Igloo> s it just me or are the way round for the symbols for join and meet really unintuitive?
07:50:03 <shapr> what symbols?
07:50:13 <Igloo> v and ^ respectively
07:50:16 <shapr> hey hram, what's going on?
07:50:48 <shapr> where are those from?
07:50:48 <kosmikus> Igloo: I think they're okay
07:50:50 <Igloo> Where join goes from the two elements up to find where they join (unless I'm more confused than I think I am)
07:51:15 <kosmikus> join ~= or ~= max; meet ~= and ~= min
07:51:45 <Igloo> Right, so join goes towards the top, hence ^ makes far more sense
07:52:20 <kosmikus> no, it corresponds nicely with "or", which is written v
07:52:50 <Igloo> That's only useful if you come from thinking about lattices on booleans
07:53:31 <kosmikus> it's a generalization of the concept
07:54:32 <kosmikus> also, v corresponds to \cup, and ^ to \cap for sets ...
07:55:41 <Igloo> I guess that lot came first, so maybe the problem is that lattices are drawn the wrong way up and top and bottom have the wrong meanings. Or did they predate lattices too?
07:56:40 <kosmikus> I don't know ...
07:56:54 <earthy> igloo: if you think about the lattice encoding `knowledge' bottom often is `I don't know squat'
07:57:14 <ecraven> Igloo: if you look at v (\cup) to point up with the two lines, instead as pointing down, then it works again..
07:57:15 <earthy> joining knowledge leaves you with somewhat less specific knowledge
07:57:39 <earthy> `it's this or that or both'
07:58:23 <Igloo> ecraven: Sure, you can twist it round, but if they were the other way round it would nicely reflect the lines that you would draw on the Hasse diagram
08:00:54 <hram> Todays problem: How do I name my module? Does it exist some kind of guidelines to module naming (hierarchical modules)?
08:03:05 <hram> For instance I'm currently working with a wrapper for the xosd-library and it doesn't fit in in the current hierarchy.
08:04:23 <hram> Java has that "reversed domain"-thing for packages which really isn't so good, but it's better than nothing...
08:04:25 <Lunar^> GHC 6.2.1 is out :)
08:04:38 <Igloo> Hmm
08:04:59 <hram> Hm, always using HEAD anyways... :)
08:05:20 <Igloo> And crest hasn't even finished the stage1 build of 6.2 yet
08:12:54 <Lunar^> crest ?
08:32:32 <Igloo> m68k machine
08:35:21 <cm> re
08:36:24 <cm> haha awesome, quakenet #c++.de discussed about the Kitchen data type
08:37:10 <jlouis> Kitchen?
08:38:25 <cm> data Kitchen a b = b
08:38:28 <cm> type*
08:51:10 <jlouis> aha
08:57:24 <shapr> hram: yes, Simon Marlow wrote a guide for module naming
08:59:37 <shapr> hram: http://www.haskell.org/~simonmar/lib-hierarchy.html
08:59:56 <shapr> and http://www.haskell.org/~simonmar/libraries/libraries.html
09:00:20 <hram> shapr: Yes, I found it :) Unfortunately it uses a just as stupid naming scheme...
09:00:33 <shapr> argue with SimonMar then
09:00:38 <shapr> I'm sure he'd enjoy feedback
09:03:35 <hram> Yes, probably he would... How many out there accutally name their libraries as "User.Com.Foo.Name_My.MyLib?
09:04:01 <shapr> what's easiest way to make a form to search a database in Haskell? is WASH the best way to do it? or are there other options?
09:04:07 <shapr> nobody
09:04:18 <shapr> so far I've seen Unstable.User.whatever
09:04:20 <shapr> and that's all
09:04:46 <shapr> oh wait, Ashley Yakely does use that naming scheme
09:04:59 <shapr> but I think he uses User.Com.Com.whatever for some reason
09:05:23 <cm> let's do it the java way! org.leetspeak.www.meep!
09:06:14 <hram> cm: Well, it's the java way really...
09:06:40 <cm> can't stand it
09:07:06 <shapr> I wouldn't mind it if it allowed me to automatically download source dependencies
09:07:49 <cm> well, i suppose URLs change
09:07:57 <cm> something like cliki.net is much more sensible IMO
09:08:13 <cm> the lisp guys have the download url of a certain package in the cliki Wiki
09:08:26 <cm> and via cliki.net/Bla?dl=1 or something, clients can retrieve the download url only
09:08:37 <shapr> squeak has that too
09:08:42 <shapr> so does debian ;-)
09:08:42 <liiwi> squish
09:08:45 <shapr> hei liiwi 
09:08:50 <liiwi> hej hej
09:08:59 <cm> yeah, well my point was that it is more sensible than an url package naming scheme ;)
09:09:39 <shapr> hierarchical libs are really handy, no argument there
09:12:05 <hram> But as it is now people seem not to use them, or just add their packages as they please.
09:15:20 <shapr> I use them, but not in a very organized manner
09:16:01 <shapr> can I define new operators in a where clause?
09:16:28 * Marvin-- ponders
09:16:33 <shapr> hej Marvin-- 
09:16:37 <Marvin--> ello
09:16:37 <Igloo> yes
09:17:03 <Marvin--> I can't find decent bibtex entries for HW2000 papers... weren't they published by acm like the more recent years?
09:17:16 <Marvin--> I'm finding plenty of entries for HW2001-2003, but not HW2000
09:17:17 <shapr> spiffy
09:19:07 <Marvin--> I'm finding entries for ICFP 2000 and PLI 2000, but not HW2000
09:19:11 * Marvin-- growls
09:21:15 <Marvin--> dammit
09:23:15 <Marvin--> the HW2000 web site says "ACM SIGPLAN" though, so I guess it would be all right to put that in the bib file
09:31:50 <Marvin--> this is driving me nuts
09:37:22 <Marvin--> aha
09:38:29 <shapr> if it takes me three seconds to load and parse one email message, how long will it take me to load and parse the haskell mailing lists?
09:38:37 * shapr is slightly worried
09:39:10 <Igloo> I hope you have some constant overhead in there...
09:39:18 <shapr> me too
09:39:55 <shapr> anyways, I'll be happy if the code just works at all
09:40:05 <Igloo> :-)
09:40:36 <shapr> even if it takes until tomorrow to load everything into postgresql I don't care, since I have to do my homework and go to class
09:43:48 <Marvin--> aha, the HW2000 papers *weren't* published by ACM
09:44:01 <shapr> who then?
09:44:17 <Marvin--> they're in "Electronic Notes in Theoretical Computer Science"
09:44:54 <shapr> never heard of it
09:45:01 <Marvin--> me neither
09:45:05 <Marvin--> but there was a link from the HW2000 homepage
09:45:07 <Marvin--> :
09:45:08 <Marvin--> :)
09:46:19 <Lunar^> When you publish a paper somewhere, you're not allowed to make it available on the web ?
09:46:38 <Marvin--> I have no idea
09:46:52 <Marvin--> but I was hunting for a good BibTeX entry and couldn't find it on ACM's site
09:47:00 <Marvin--> which isn't so strange after all
09:48:50 * Marvin-- hopes to write a paper for HW this year
09:50:42 <Igloo> I don't think I'll be doing so, and hence I think it's unlikely I'll be able to go
09:50:43 * shapr wants to buy some fast HW this year
09:51:08 * Igloo fails to understand shapr
09:51:09 <shapr> yes, I'm going for Opterons instead of Haskell Workshop, I'm such a weenie.
09:51:21 <shapr> HardWare :-)
09:51:21 <Marvin--> well, first I gotta get this thesis done
09:51:22 <ibid> Lunar^: depends on what kind of a paper you sign prior to publication
09:51:24 <Igloo> Ah
09:51:42 <shapr> Igloo: it's okay, I'll give you an account on my new box and we can have our own HW ;-)
09:51:49 <Igloo> lol
09:52:22 <shapr> especially since I don't think GHC6 runs completely smoothly on x86-64
09:52:42 <Igloo> I thought it did?
09:52:43 <ibid> Lunar^: some publishers have a form that allow a home page copy, some publishers have a form that doesn't
09:53:04 <shapr> oh, I'm probably thinking of IA64, doh
09:53:27 <ibid> Lunar^: djb is advocating that we put our papers to the public domain, allowing the publisher to publish and us to put a web copy :)
09:53:43 <Marvin--> djb?
09:53:45 <shapr> I think he's right
09:53:46 <shapr> bernstein
09:53:51 <ibid> daniel j. bernstein
09:53:59 <ibid> aka the author of qmail
09:54:06 <shapr> shoot the copyright lawyers, shoot 'em NOW
09:54:11 * shapr gets out the minigun
09:54:34 * ibid does not condone violence :)
09:54:58 <shapr> sadly, in these days of VLSI, my minigun was built with the 93nm process, and so has an effective range of half the width of Opteron
09:55:08 <shapr> "of an Opteron"
09:55:20 <Lunar^> ibid: thanks
10:17:10 * rt sighs.  It's going to be a long week.
10:17:59 <Smerdyakov> Spring break!!!
10:18:22 <shapr> rt: I agree
10:20:32 <bring> ok, we're all going to Mexico
10:20:36 <bring> haskell and tequila
10:21:03 <shapr> and Corona with lime
10:21:06 <shapr> mmm
10:21:23 <bring> oh yeah
10:21:40 * liiwi starts drooling
10:22:07 <shapr> @type uncurry4
10:22:10 <shapr> @type uncurry2
10:22:13 <shapr> hm
10:25:10 <liiwi> I had some good curry yesterday
10:25:31 <Marvin--> so did I
10:42:04 <keverets> is anyone using the libwxhaskell from syntaxpolice's haskell experimental apt repo?
10:42:29 <keverets> I can't get the examples to compile.  The build dies during linking with /usr/lib/libwxc-0.6
10:43:35 <hram> probably should be /usr/lib/ghc-6.2/libwxc-0.6.so
10:43:58 <hram> or wherever you have your ghc :)
10:44:08 <shapr> it works for me
10:44:25 <shapr> oh wait
10:45:16 <keverets> ah, I can't install wxhaskell-ghc6 because it contains the same file (/usr/lib/libwxc-0.6.so) as libwxhaskell0.6-ghc6
10:45:40 <shapr> right, remove libwxhaskell0.6-ghc6
10:45:40 <Igloo> keverets: Not even using the Makefile in /usr/share/doc/libwxhaskell-ghc6-dev/example/wx/?
10:45:44 <Igloo> You don't want wxhaskell-ghc6
10:45:53 <shapr> oh, whoops
10:46:05 <keverets> I don't have wxhaskell-ghc6, so that's ok.
10:46:10 <keverets> and no, not even using the Makefile.
10:46:20 <Igloo> What errors do you get?
10:46:22 <hram> what does it say?
10:46:23 <keverets> Chasing modules from: HelloWorld.hs
10:46:23 <keverets> Compiling Main             ( HelloWorld.hs, HelloWorld.o )
10:46:23 <keverets> Linking ...
10:46:24 <keverets> /usr/lib/libwxc-0.6.so: undefined reference to `wxGLCanvas::SwapBuffers()'
10:46:30 <keverets> and more undefined references
10:46:38 <Igloo> What does wxconfig --gl-libs ay?
10:46:41 <keverets> that was with a "make HelloWorld"
10:46:42 <Igloo> s/ay/say/
10:47:00 <keverets> hmm... don't have wxconfig installed.  What package is it in?
10:47:06 <hram> Ah, it has a broken dependency, you should add wx_gtk_gl-2.4 to the deps probably
10:47:18 <Igloo> Sorry, wx-config
10:48:07 <keverets> $ wx-config --gl-libs
10:48:07 <keverets> -lwx_gtk_gl-2.4 -lGL -lGLU
10:48:56 <keverets> that was just after installing the libwxgtk2.4-dev package, which wasn't a dependancy but probably should be.
10:49:11 <keverets> hmm... now I'm getting:
10:49:11 <keverets> Linking ...
10:49:12 <keverets> /usr/bin/ld: cannot find -lGL
10:49:27 <hram> what did you do?
10:49:39 <keverets> installed the wxgtk2.4-dev package
10:50:33 <keverets> I can't find any package that has wxgtk and gl in the name...
10:54:53 <hram> it is named libwx_gtk_gl-2.4.so and is in the libwxgtk2.4 package
10:54:53 <hram> sorry libwxgtk2.4-dev
10:55:55 <keverets> hram: I see it there.
10:56:06 <keverets> not sure why ld is saying "/usr/bin/ld: cannot find -lGL"
11:03:50 <jdrake> so who has one of these shirts: http://www.cafeshops.com/skicalc.6225368?zoom=yes#zoom
11:03:55 <hram> Because of some strange dependency? Do you have libGL?
11:05:45 <keverets> libGL?  Where would I get that?
11:15:32 <shapr> Riastradh: speaking of which, how many of those have you sold?
11:16:01 <hram> keverets: if you don't have it install xlibmesa3-gl and xlibmesa3-glu
11:16:03 <keverets> yay... after mucking around with packages, finally got it to install.
11:16:18 <keverets> needed xlibmesa-glu-dev
11:21:29 <jdrake> why does the cons operator only work like 5:[1,2,3] and not [1,2,3]:5
11:21:53 <hram> jdrake: because of its type.  a -> [a] -> [a]
11:22:30 <jdrake> can't there be a [a] -> a -> [a]
11:22:39 <jdrake> method of it
11:22:47 <hram> jdrake: yes, but not with the same name.
11:23:06 <jdrake> is there one already defined?
11:23:15 <hram> if you need [1,2,3]:5 do [1,2,3] ++ [5]
11:24:36 <Smerdyakov> Adding to the end of a list is significantly less efficient than to the beginning.
11:25:09 <jdrake> Smerdy, yes it would be
11:25:19 <hram> often it makes sense to add at everyting to the beginning and then reverse
11:26:07 <hram> ".. to add everything ..."
11:28:29 <Lunar^> damn... I can't find where GHCi loads the base package
11:34:18 <bring> anyone know how if using wxHaskell with hugs would be feasible?
11:35:26 <shapr> hugs does ffi?
11:36:12 <hram> Lunar^: basePackage defined in ghc/compiler/main/Packages.lhs?
11:36:59 <hram> bring: From the homepage: "In principle, any Haskell98 compiler that supports the standard FFI libraries will also work."
11:37:36 <bring> "in principle" :)
11:37:58 <hram> yes, it's always something :)
11:43:05 <Lunar^> lOg updated.
11:45:05 <shapr> yay
11:48:33 <Lunar^> Why do I feel that GHCi is quite hacky ?
11:49:37 <hram> because ghc is quite a hack?
11:50:10 <Lunar^> I really don't think so
11:54:19 <hram> shawn: What is GenericHaskellServer really supposed to do? Sounds a lot like inetd to me...
11:54:52 <shapr> that's fine with me, Hinetd sounds great
11:55:15 <shapr> I'd like to have something that makes it easy to write simple net services in Haskell
11:55:23 * Marvin-- boggles at a mail he just got
11:55:49 <hram> argh! nickcompletion #@£@£!  not shawn, but shapr.
11:56:18 <hram> shapr: But if one uses inetd it is as simple as writing a program that uses stdin/out.
11:56:54 <Riastradh> shapr, nine.
11:57:46 <shapr> Riastradh: awesome
11:58:04 <hram> shapr: reinventing the wheel in Haskell isn't very funny or groundbreaking...
11:58:23 <Lunar^> hram: Depends how different is the wheel...
11:58:28 <shapr> I'd be just as happy with docs that show how to use inetd
11:58:39 <shapr> but inetd isn't usually installed on win32
11:58:44 <Lunar^> hram: If the wheel is just the tiny little piece that allows an ornitopter to land...
11:59:13 <shapr> ooh, ornitopter
11:59:20 <shapr> 0/2 artifact
11:59:37 <Lunar^> lol
11:59:42 <hram> Lunar^: In this case it would probably be a slightly more squareshaped wheel... (shapr: only look in /etc/inetd.conf and you'll understand)
12:00:01 <hram> was it 0 mana?
12:00:07 <shapr> yes it was :-)
12:00:11 <shapr> man we're geeks ;-)
12:00:15 <hram> yepp
12:00:25 <Lunar^> lol
12:00:42 * Marvin-- wonders what the heck CAITA is and why he gets conference spam
12:00:55 <shapr> at one point, I had everything lotus, moxen, timetwister, ancestral recall, all of it
12:01:08 <Marvin--> I'm instantly suspicous of any mail that says anything about "VIP"
12:01:09 <bring> I got that too, I think the acronym meant different things in different mails
12:01:12 <shapr> I think I still have a library of alexandria, a guardian beast, and some mana drains left over.
12:01:25 <Marvin--> "Dear potential VIP Speaker: ..."
12:01:42 <bring> fooled me too for a while
12:01:47 <shapr> is it a spam?
12:03:39 <Marvin--> I have no idea what to make of it
12:03:57 <Marvin--> depends on how you define spam, I guess
12:04:14 <Marvin--> sure, it was unsolicited, but it doesn't look very commercial :)
12:04:20 <bring> true
12:05:13 <Marvin--> bring: you got one too?
12:05:53 <bring> yes, about a week ago
12:05:59 <bring> two I think
12:07:26 <bring> two mails that is
12:07:32 <bring> can only find one in my trash
12:33:48 <bring> is anyone working on a date parser?
12:35:44 <bring> System.Time.formatCalendarTime backwards
12:37:56 <Lunar^> bring: I want a gregorian calendar implementation ! ;)
12:38:34 * SyntaxNinja casually glances over at the yampa mailing list :)
12:39:30 <bring> SyntaxNinja: url?
12:39:56 <Igloo> They've released it under an OS licence?
12:40:44 <SyntaxNinja> http://mailman.cs.yale.edu//pipermail/yampa-users/2004-March/000053.html
12:40:56 <SyntaxNinja> yeah. I haven't actually verified this, but that's what the announcement says :) :)
12:41:09 <SyntaxNinja> their timing is good since we want to release some of our own work.
12:41:16 <Igloo> Cool
12:41:28 <Igloo> We being Aetion?
12:42:31 <SyntaxNinja> yeah
12:48:10 <shapr> SyntaxNinja: so, whatcha releasing?
12:50:56 <shapr> when can we see it :-)
12:51:28 <SyntaxNinja> abe implemented cairo bindings, as he mentioned on the mailing list
12:51:34 <shapr> cool
12:51:38 <SyntaxNinja> and there's a yampa interface to that which we'll probably release soon
12:51:45 <SyntaxNinja> cairo bindings are Haskell cairo bindings
12:55:03 * Marvin-- tries to remember at what time he was supposed to meet with Koen tomorrow
12:55:38 <andersca> Marvin--: about hwat?
12:58:32 <Marvin--> same old, same old
13:02:03 <andersca> oh right
13:02:05 <andersca> :)
13:17:59 <saz_> hmm
13:17:59 <Marvin--> Hm, what's a good way to write shows-like functionality in a CPS monad?
13:18:36 <saz_> can anyone tell me what this error means?
13:18:38 <saz_>     Failed to load interface for `Graphics.UI.WX':
13:18:39 <saz_>         Bad interface file: /usr/local/lib/imports/Graphics/UI/WX.hi
13:18:39 <saz_>             mismatched interface file versions: expected 6020, found 6021
13:18:43 <saz_> ?
13:20:56 <kosmikus> you have upgraded to ghc-6.2.1, but still have a .hi file of version 6.2 lying around ...
13:21:27 <SyntaxNinja> saz_: IOW your ghc version doesn't match your wx version.
13:21:38 <saz_> hmm
13:21:53 <saz_> right
13:22:49 <saz_> ga, okay, i know exactly what the problem is now
13:22:50 <saz_> thanks
13:24:32 * saz_ needs to run stuff on her own computers
13:24:54 * Marvin-- is getting tired of writing all this stuff with CPS style
13:25:14 <rt> mmm.  cps.
13:26:18 <Marvin--> showsWith :: String -> [ShowS] -> ShowS -> ShowS
13:26:19 <Marvin--> showsWith _ [] k = k
13:26:19 <Marvin--> showsWith c (f:fs) k = f . showl fs
13:26:19 <Marvin-->   where showl []     = k
13:26:19 <Marvin-->         showl (f:fs) = showString c . f . showl fs
13:26:21 <Marvin--> I mean...jeepers
13:28:33 * SyntaxNinja is inclined to use "area of overlap" and "orthogonal" in the same sentence, and is a little disturbed by the fact that they're both geometric metaphors.
13:28:55 <Marvin--> is a  Writer ShowS  enough to get decent complexity when making long strings?
13:29:39 <Marvin--> or should I pull a type of my own out of my noble parts?
13:31:05 <Marvin--> something like newtype M a = M (forall b. (a -> M' b) -> M' b) ; data M' a = Put String (M' a) | Return a
13:32:46 <shapr> ahem
13:32:48 <SyntaxNinja> saz: out of interest, is that wxhaskell? if so, what platform?
13:32:50 <shapr> ShereKahn: nice nickname
13:32:51 <SyntaxNinja> hi shapr
13:33:20 <saz> SyntaxNinja: yes, it's wxhaskell, on debian unstable
13:33:33 <shapr> hi SyntaxNinja 
13:33:36 <shapr> how's life in the big city?
13:35:00 <ShereKahn> shapr thanks ;-)
13:35:20 <shapr> so, you learning Haskell?
13:36:32 <SyntaxNinja> saz: are you using the .deb packages in Haskell Experimental, and if so, do they not match some version of GHC which you get from an apt source? 
13:36:50 <saz> SyntaxNinja: no, everything (including ghc) is compiled from source
13:36:54 <shapr> I've found several duplicate message-ids in the year 2000 haskell@haskell.org mailing list archive, is that normal?
13:36:56 <saz> the deb packages didn't quite work
13:37:05 <SyntaxNinja> the deb packages of wxhaskell?
13:37:20 <saz> yeah, version problems, iirc
13:37:41 <shapr> and you're using debian?
13:37:52 <saz> shapr: me?
13:37:55 * shapr wonders if that was a silly question
13:37:57 <shapr> yah
13:38:03 <saz> er, yeah
13:38:05 <saz> :)
13:38:07 <shapr> huh, wow
13:38:24 <saz> (why would i be trying deb packages on non-debian?)
13:38:31 <shapr> well, I do that sometimes
13:38:41 <shapr> I tend to rip off binaries from debs because they work better
13:38:48 <saz> i guess that's fair enough
13:39:15 <shapr> by the way, what does your other eye look like?
13:39:33 <saz> pretty much the same as that eye
13:39:38 <shapr> well, ok then
13:40:04 <saz> having them both would be a bit of redundant info, dont you think? ;)
13:40:15 <shapr> well, I put both of mine in.
13:40:19 <shapr> but maybe you're right
13:40:27 <shapr> wouldn't you put in at least half your face then though?
13:40:53 <saz> aren't eyes supposed to identify people?
13:41:00 <shapr> that's a good point
13:41:02 <SyntaxNinja> saz: so version problems between wxhaskell and ghc (as above) or bewteen wxhaskell and something else?
13:41:06 <shapr> eye guess so
13:41:08 <saz> I mean, if someone doesn't want to be identified, they cover their eyes.. so I figured...
13:41:25 <saz> SyntaxNinja: wxhaskell, ghc, and gtk, iirc
13:41:55 <SyntaxNinja> ew. OK. well, if you ever figure out more detail, let me or Igloo know. that's not something that we should let get into unstable, once wx moves there.
13:42:29 <saz> SyntaxNinja: sure, seafood knows more about the problem than I do (this is on his computer, he fixed it up while I was at class last week)
13:42:53 <Igloo> We need a Debian haskellers list
13:43:02 <saz> that'd be a good idea
13:43:12 <saz> how well is wxhaskell supported on freebsd?
13:43:31 <saz> cos I'm debating putting freebsd 4.9 on my laptop
13:43:33 <shapr> Igloo: debian@haskell.org right?
13:43:52 <shapr> or haskell@debian.org
13:44:33 <saz> shapr: google doesn't seem to know about either..
13:44:43 <saz> (mailing list, that is)
13:44:51 <shapr> I think that's because they don't exist.
13:45:00 <saz> that could be a good reason
13:45:23 <shapr> I could setup haskdebs@ScannedInAvian.org, but haskell.org would be far cooler.
13:45:51 <SyntaxNinja> Igloo: I once proposed a debian haskell list, but simonMar asked me to just keep everything on libraries@haskell.org
13:45:59 <shapr> btw, are those multi-colored debian logos on your homepage?
13:46:17 <saz> shapr: mine? 
13:46:20 <shapr> yes, yours
13:46:20 <Igloo> It would be nice to be able to make more noise than I think should be on libraries@
13:46:33 <shapr> yah, let's make noise
13:46:35 <saz> shapr: no..I drew them before i even knew about debian.. never thought of them that way
13:46:49 * saz should update her page sometime
13:46:56 <shapr> that red one is very stylish
13:47:07 <Igloo> Ooo, having minidinstall announce to such a list would be nice too
13:47:15 <shapr> heheh
13:47:17 <saz> shapr: thanks :)
13:47:30 <shapr> Igloo: you're trying to get SimonM to change his mind, aren't you ;-)
13:48:05 * Igloo thinks SimonM is wrong on that one, as the traffic will probably just irritate most non-Debian readers
13:48:24 <SyntaxNinja> Igloo: I think the trick would be to make noise on libraries@ for a while until it's obvious that we need our own list :)
13:48:31 <shapr> I agree
13:51:14 <kosmikus> Igloo: what about a general haskell-packaging list, then, that isn't debian-specific?
13:51:35 <saz> hmm
13:52:39 <shapr> that sounds good
13:52:42 * SyntaxNinja feels like no one would subscribe to that list
13:52:46 <shapr> oh
13:52:47 <SyntaxNinja> except packagers themselves
13:53:14 <kosmikus> that's a question of naming it, maybe haskell-linux ?
13:53:24 <SyntaxNinja> it takes some percecption to realize "Hey! I care about haskell packages" whereas it doesn't take much to realize "I care about Debian and Haskell"
13:53:32 <SyntaxNinja> hm
13:54:12 <SyntaxNinja> I think a packaging mailing list will overlap with the libraries list in a way that will also give simonMar pause; but it is perhaps ab etter idea than a debian-only list, if we can name it right.
13:54:26 <Igloo> I'm thikning of a convenient list for people who use Haskell experimental, so can't really use the Debian bug tracking system, but want to report bugs or discuss the packages. Having uploads announced there would just be an obvious extra step IMO
13:54:27 <SyntaxNinja> but then what about BSD packages? it would definitely be nice to have a place to hash out ideas between packages on different platforms.
13:54:54 <kosmikus> yes, that's what  thought
13:55:05 <kosmikus> s/  / I /
13:55:39 <Igloo> I don't really see what mixing Debian, Gentoo and RH traffic into one such list would really gain anyone
13:56:02 <SyntaxNinja> we might run into the same kinds of problems.
13:56:06 <Igloo> And the problem with the existing lists is that it doesn't feel right to people (well, me, anyway) to report such problems there
13:56:28 <SyntaxNinja> I think that saz' problem is appropriate for libraries@.
13:56:51 <Igloo> Perhaps, but then the packagers themselves could be on all the lists. As a Debian user I wouldn't want to be continually updated on what gentoo emerges were available
13:57:02 * Igloo doesn't know what saz's problem was so can't comment
13:57:46 <saz> Igloo: basically, stuff not happily installing together (where stuff = wxhaskell, gtk and ghc)
13:58:14 <cm> rere
13:58:15 <Igloo> But is that an inherent problem, out of date Debian packages or incorrect Debian deps/conflicts
13:58:26 <Igloo> Only the first would belong on libraries@ IMO
13:58:50 <saz> perhaps have different lists for different distros/packages, but have a list which is a superset of all of them for use for discussion like that
13:59:23 <saz> Igloo: yeah
14:04:02 * Marvin-- laughs at Dark Angel
14:04:11 <SyntaxNinja> Igloo: yeah, I think your key point is that the users of packages wouldn't really be interested in a mailing list where the packagers themselves collaborate. I agree with that.
14:05:05 <Igloo> Anyone know if I can play flacs without a GUI?
14:05:12 <shapr> yes, alsaplayer
14:05:18 <Igloo> Aha, ta
14:05:25 <shapr> alsaplayer is great
14:05:48 <shapr> I've written some handy C programs to call the alsaplayer remote control programs, wrapped those in some tiny elisp as well
14:06:01 <Igloo> aplay not so good, on flacs at least  :-)
14:06:06 * shapr shamefully admits to writing C
14:06:21 <shapr> ALSA on my emu10k1 is gorgeous
14:06:31 <shapr> especially with linux 2.6
14:06:57 <shapr> anyways, if you end up liking alsaplayer, I'll ship you my remote control sources
14:07:10 * shapr is a FLAC-addict
14:08:54 <Igloo> IHN remote control
14:09:08 <shrimpx> what do you guys recommend for a good LaTeX book? i'm not a latex newbie, but am feeling the need for a comprehensive reference
14:09:17 * Igloo demands that shapr read the FFI spec in bed tonight
14:09:21 <shapr> what?
14:09:22 <shapr> oh!
14:09:28 <shapr> so I can write alsaplayer bindings!
14:09:28 <Igloo> The LaTeX companion
14:09:37 <Igloo> And rewrite your C!
14:09:38 <shapr> but I don't have it printed out
14:09:42 <shapr> that's a good point
14:13:46 <ztre> howdy!
14:13:49 <Igloo> Cool, workingness. I should purge other players and switch to it.
14:14:47 <shrimpx> Igloo: thanks!
14:27:20 * Marvin-- ponders if  type ShowM = Cont ShowS ; putString s = Cont $ \k -> showString s . k ()  will do the trick
14:32:08 <Marvin--> er, that would make my run function be something like execShowM m = runCont m (flip const) ""
14:40:32 <Marvin--> er
14:41:19 <Marvin--> runCont m (flip const) ""  is a seriously freaky expression
14:41:45 * Marvin-- tries to understand what he's writing
15:00:40 <keverets> the first program that I made using wxHaskell is a alsaplayer remote control program
15:06:29 <Igloo> Heh, ironic  :-)
15:08:36 <Marvin--> what's ironic?
15:09:01 <Igloo> what shapr and keverts last(ish) said
15:11:10 <saz> hm, that's odd
15:11:45 <Marvin--> ah
15:16:10 <Marvin--> oh yes, this monad is so much nicer to work with
15:16:11 <Marvin--> hooray
18:50:22 <LittleDan> What's a good tail-recursive O(n) algorithm for joining linked lists? The Haskell prelude's algorithm is tree-recursive.
18:51:04 <Smerdyakov> What's "joining linked lists"?
18:51:09 <LittleDan> ++
18:51:37 <det> (++) isnt tail-recursive ?
18:51:40 <Smerdyakov> The obvious algorithm reverses the first list and tail-recurses along it.
18:51:41 <Riastradh> There is no better way than what the example implementation is except with uniqueness typing where you can side-effect the list.
18:51:50 <Smerdyakov> Yeah, I'm surprised if the default implementation isn't tail recursive!
18:52:06 <LittleDan> The standard prelude is written for clarity, so everything is tree recursive
18:52:40 <det> is "tree-recursive" a standard term for "grows the stack" ?
18:52:41 <LittleDan> Smerdyakov: That's what I was thinking, but it seemed too unintuitive
18:52:58 <Riastradh> If you build it up in reverse and reverse the intermediate list you're still going to have intermediate storage allocated; the only difference is that it's on the heap instead of the stack.
18:53:15 <LittleDan> Riastradh: So is that more efficient?
18:53:28 <LittleDan> Riastradh: (usually)
18:53:38 <Riastradh> That depends on how fast heap allocation is, how limited your stack is (can it be copied to the heap on overflow, for instance?), and other factors.
18:54:03 <Riastradh> No matter how you do it, you'll end up allocating intermediate storage.
18:55:12 <Riastradh> So unless you have a miniature stack and big lists, go with the clearest definition, and if you don't need to preserve order, use a different function that _can_ run without allocating intermediate storage of size proportional to the input list.
18:55:37 <LittleDan> But with tail recursion, isn't it just one variable (the accumulator) as opposed to a whole stack frame for each list item?
18:55:42 <LittleDan> what do you mean?
18:55:56 <np_hard> the actual implementation of the prelude ++ might differ from the specification in the report
18:56:24 <np_hard> have you checked that your implementation is actually not O(n) ?
18:56:40 <Smerdyakov> This kind of non-tail recursion with lazy evaluation might not even matter, anyway, in a lot of cases.
18:57:07 <LittleDan> np_hard: Which implementation?
18:57:18 <LittleDan> Smerdyakov: How is that?
18:57:51 * Riastradh pastes something.
18:57:57 <Riastradh> (so wait a minute while I write it)
18:58:06 <np_hard> the concatenation isn't even done until you traverse to the end of the list for some other reason
18:58:07 <LittleDan> Smerdyakov: Don't you still need extra stack frames?
18:58:24 <np_hard> and by that time you have traversed the first part of the list for some other reason
18:59:08 <Smerdyakov> LittleDan, you don't need any memory for computations you never perform. :)
18:59:18 <np_hard> LittleDan: what I meant was that the code in the Haskell report's prelude is not necessarily the code that hugs or ghc uses when you cann ++
18:59:22 <np_hard> er, call ++
19:00:35 * Riastradh finishes pasting.
19:00:50 <LittleDan> Smerdyakov: Unless you are dealing with an infinite list, don't you usually perform all of the computations?
19:01:03 <Riastradh> In append1, the intermediate storage is on the stack: each element is pushed on and then the stack collapses into a list.
19:01:12 <Riastradh> LittleDan, not until you need them, due to laziness.
19:01:32 <Smerdyakov> LittleDan, who knows! It's an uncertain world!
19:01:56 <LittleDan> I'm talking about real-world operations with I/O
19:01:58 <Smerdyakov> Oo. A ACM Software Security Summer School administrator sent out a non-bcc e-mail to all the applicants.
19:02:02 <Smerdyakov> Let's see who applied!
19:02:17 <Riastradh> In append2, intermediate storage is created by reversing xs, and all those intermediate cons cells are left unused at the end of append2', so you've gone and allocated intermediate storage that needs to be recycled at the end.
19:02:27 <Smerdyakov> Quite a few non-Americans. Brave souls!
19:03:30 <Riastradh> So either way, you allocate intermediate storage.
19:03:33 <Smerdyakov> But I don't recognize anyone else from here.
19:03:54 <Riastradh> If stack allocation is faster than heap allocation of cons cells and there are no stack overflows, go with append1.
19:04:17 <Riastradh> (I'm talking about
19:04:20 <Riastradh> @wiki HaskellIrcPastePage
19:04:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:04:22 <Riastradh> by the way)
19:04:30 <Riastradh> (or what's on it, anyways)
19:06:16 <Riastradh> If you introduce a new function, appendReverse, which is really just append2', then you can get tail-recursive append with no to-be-discarded intermediate storage allocated, but only if you don't need order to be preserved; append can be defined in terms of it, but, in the end, if you need order preserved, you have to either use side effects or allocate to-be-discarded intermediate storage.
19:07:17 <det> or use a different data structure!
19:08:24 <Riastradh> Yes, you could use something like:  data NestedList a = Nil | Cons a (NestedList a) | Snoc (NestedList a) a | Append (NestedList a) (NestedList a)
19:09:12 <LittleDan> did you just come up with that?
19:09:20 <Riastradh> ?
19:09:27 <LittleDan> Did you just write that?
19:09:36 <Riastradh> Write that data type?
19:09:37 <LittleDan> I mean just now?
19:09:39 <LittleDan> yes
19:09:42 <Riastradh> Yes.
19:45:14 <Pseudonym> Actually, (++) runs in constant stack space.
19:45:45 <Pseudonym> Consuming the list, on the other hand, may not.
21:42:05 <jdrake> why does foldl and foldr have the parameter that it adds to the beginning or end of the operation?
21:43:21 <monotonom> Because they serve as initial or default values. If the input list is empty, foldl and foldr should still return something meaningful.
21:43:37 <ayrnieu> It couldn't otherwise have well-defined behavior on a list of one element.
21:44:41 <ayrnieu> by which I mean 'the behavior it has'
21:47:08 <Jerub> @type foldl
21:47:08 <lambdabot> foldl :: (a -> b -> a) -> a -> [b] -> a
21:48:19 <ayrnieu> mini_fold :: (a -> a -> a) -> [a] -> a
21:48:55 <jdrake> i assume that thing means takes a function which has two operations, and returns the same as the first type
21:49:00 <jdrake> the first part that is
21:52:01 <Smerdyakov> Any function with mini_fold's type must loop forever when the list given is nil.
21:52:48 <ayrnieu> Or you could just only define the function for non-nil arguments, and let the program explode as appropriate.
21:53:34 <Smerdyakov> It's generally nicer to assume that such extra escape hatches are just infinite loops. :)
21:55:20 <jdrake> what is standard comment notation?
21:55:37 <Smerdyakov> It's NOT this:
21:55:41 <Smerdyakov> _ = "This is my comment!"
21:55:50 <monotonom> Haha
21:56:26 <Smerdyakov> It's -- comment haha
21:56:32 <monotonom> Standard comment notation is you write "C" in column 1, then write your comment beginning at column 6.
21:57:02 <jdrake> i am battling with my first compiler problem - indents
21:57:02 <monotonom> oops wrong channel. that was for #fortran
21:57:15 <Smerdyakov> Poor indentation-dependent Haskell can't use the standard comment notation:
21:57:17 <jdrake> monotonom, sounds lovely
21:57:22 <Smerdyakov> Steganographic encoding through whitespace.
21:57:55 <Smerdyakov> monotonom, really, you should be talking about punching holes instead of "writing."
21:58:42 <monotonom> Oh haha I write my program on paper, prove it correct, then my secretary will punch it!
21:58:58 <Smerdyakov> Proofs have no business being on paper.
21:59:16 <monotonom> (I didn't say I write the proof on paper. :)
21:59:30 <Smerdyakov> Then my secretary will punch you.
21:59:35 <monotonom> Hahahaha
22:00:06 <Smerdyakov> That's enough.
22:00:26 <jdrake> is there any better way to say this (this does work as the question wants)? ex36 (x:y:xs) = fst y;
22:01:19 <anduril1> well, the x can be an _ because you don't need it
22:01:35 <anduril1> same with xs
22:02:22 <anduril1> and you can do patterns with tuples, like this f (_:(y,_):_) = y
22:02:23 <jdrake> done :-)
22:02:34 <jdrake> oh good
22:03:07 <Jerub> pattern matching rocks.
22:03:10 <anduril1> yeah
22:03:17 <jdrake> i am not really used to it
22:03:30 <monotonom> Oh "ex36" is the name of the function!  I was reading "(x:y:xs) = fst y" and wonder how it would even type-check.
22:03:31 <jdrake> i did use it once or twice in ocaml, but never really got the hang of it
22:03:41 <jdrake> monotonom, easily :-)
22:04:23 <jdrake> ex36 :: forall t t1. [(t, t1)] -> t   <-- i don't really get this 
22:04:47 <anduril1> monotom: I bet the compiler would complain about conflicting with the Prelude's definition of (:)
22:04:52 <monotonom> If you just look at [(t, t1)] -> t, it makes sense.
22:05:09 <jdrake> oh that is the part i am looking at
22:05:27 <jdrake> is it because lists have to be homogenous that it only lists the one item
22:05:33 <monotonom> Another way to write it is [(a,b)]->a.  Maybe that's less intimidating.
22:05:42 <anduril1> jdrake: kinda
22:05:53 <monotonom> Yes all items in the input list have the same type (a,b)
22:06:58 <anduril1> in English, it translates to: "Given a list of tuples of A and B, I will return an A"
22:07:09 <Jerub> @type fst
22:07:10 <lambdabot> fst :: (a,b) -> a
22:10:32 <Jerub> I'm currently using pattern matching as an aid when writing my parrot code generator.
22:11:40 <Jerub> you can do compile-time optimisations really trivially, stuff like App "++" (Literal x) (Literal y) = Literal (x ++ y)
22:11:42 <jdrake> it almost makes one wonder why one could even program in C :p
22:12:46 <jdrake> i want to be able to use backspace in my terminal! Not even ghci will let me. I can't figure it out :p
22:13:18 <anduril1> you can use backspace in your shell?
22:13:53 <Jerub> control-h ?
22:14:02 <jdrake> backspace works fine
22:14:30 <jdrake> forward delete has never worked in 2 years
22:14:59 <monotonom> You need to make sure you have the "readline" library on your computer *and* ghc can find it.
22:16:14 <jdrake> oh readline support is builtin here
22:16:19 <jdrake> i used a binary ghc 
22:16:31 <jdrake> and it statically linked to it i think
22:17:21 <skew> hi
22:17:26 <skew> does anyone have some good excercises for teaching typeclasses?
22:17:52 <Jerub> for you, or for someone else
22:17:57 <jdrake> skew, are you familiar with haskell in general? I found a awesome tutorial for haskell which is the length of a book
22:18:03 <skew> I'm trying to think up some assignments so my school might teach some Haskell
22:18:05 <anduril1> have you checked out the Gentle Intro to Haskell?
22:18:24 <anduril1> oh, excercises
22:18:38 <skew> I was trying to think of some relatively simple problem that demonstrate typeclasses
22:18:55 <jdrake> that gentle intro isn't exactly gentle
22:19:02 <skew> something on the order of writing a toy set of monadic parser combinators
22:19:07 <skew> in difficulty that is
22:19:32 <skew> jdrake: nope, but it's where I learned Haskell, well, that and the report and Hugs
22:20:23 <skew> I'm having trouble thinking of a sufficiently natural situration where you might want to define your own typeclass
22:21:35 <anduril1> so you want the excercise to create a new class, or implement an existing one?
22:22:50 <skew> well, I'm thinking of having part of the assigment be to implement a new numeric type
22:23:46 <Jerub> skew: thomsons craft of functional programming writes a toy parser combintator.
22:24:22 <skew> but I'd like something more interesting than just saying "Write a typeclass with methods inc and dec and foo"
22:24:54 <skew> for data types I was thinking of providing some library code and having students write a Huffman compression/decompression program
22:25:38 <skew> Jerub: yeah, I think that would be a pretty good execercise for teaching more interesting monads
22:26:30 <Jerub> skew: this is before he teaches what a monad is.
22:27:14 <skew> is he writing a monadic parser?
22:27:55 <Jerub> *kinda*
22:28:23 <Jerub> you'd have to read it, he does the monadic behaviour manually, using his own combinator, >@>
22:28:26 <skew> I'm not really looking for complete assigments either, just a broad outline for the instructor who teaches a "Programming Workshop", with sections in a variety of languages
22:29:02 <skew> Hopefully a Haskell section next term
22:30:20 <skew> The examples of uses of typeclasses that I'm thinking of right now are the properties in wxHaskell, the sorts of monads in Control.Monad (for the transformer stuff), and the slight abuse to get well-formed HTML in WASH
22:31:01 <skew> But those all seem like sort of big systems
22:31:51 <skew> actually, now that I think about it you do need at least a few instances before it's obviously better to make a typeclass.
22:32:28 * rt sets ghc building and wanders off to bed.
22:32:55 <skew> andurill: I'd like to think of an excercise involving building a new typeclass
22:34:24 <monotonom> It may be easier to extend a given or even builtin typeclass.
22:34:41 <skew> yeah, that is easier
22:34:57 <skew> I'm trying to think of something about building your own too
22:35:29 <skew> Hmm, having them extend a typeclass is maybe not such a bad idea
22:35:44 <anduril1> skew: you wouldn't have to limit it to one either
22:35:56 <jdrake> sweet, i have forward delete working now
22:36:05 <skew> Do you have any good ideas for combining them?
22:36:09 <anduril1> for a numeric type, Num, Ord, Eq, Show, and Read are all good choices
22:36:14 <skew> well, making a new typeclass sort of implies you make some instances
22:36:49 <skew> yeah, I was thinking of having people make a new ratio type
22:37:12 <skew> with the appropriate instances to be a standard kind of number
22:37:34 <skew> which seems like a pretty good excercise as far as demonstrating how to make instances
22:37:47 <skew> and that your new type gets along perfectly with old code
22:38:27 <skew> It doesn't seem to be as good an example of what you might use typeclasses for, or what you want to put in them
22:38:43 <skew> I don't have much experience here myself, either
22:39:44 <anduril1> does anybody remember the name of the functional programming book that was on Slashdot a while back?
22:39:50 <anduril1> maybe a week ago
22:39:53 <skew> I'm thinking there may not be problems that can be solved in a page or two of code that really motivate the creation of a typeclass - can you think of counterexamples?
22:40:02 <skew> Haskell School of Expression, I think
22:40:36 <anduril1> skew: I can't think of a good example
22:41:02 <Pseudonym> I can think of one or two.
22:41:03 <skew> that's the first book at htpp://www.haskell.org/bookshelf/
22:41:08 <Pseudonym> Mathematical stuff, mostly.
22:41:25 <skew> is it very deep?
22:41:35 <Pseudonym> I don't think so.
22:41:37 <Pseudonym> Hang on.
22:41:58 <skew> as in, would the math take more explaining than the Haskell.
22:42:08 <Pseudonym> Not really.
22:42:21 <Pseudonym> Let me look.
22:42:44 <skew> sounds reasonable for an assignment then.
22:42:54 <Pseudonym> OK, here's a good example.
22:43:08 <Pseudonym> class Euclidean a where
22:43:08 <Pseudonym>     fromInteger :: Integer -> a
22:43:08 <Pseudonym>     isZero :: a -> Bool
22:43:13 <Pseudonym>     pseudoDivid :: a -> a -> (a,a)
22:43:20 <Pseudonym> That's a Euclidean domain.
22:43:38 <Pseudonym> Oh, plus the mathematical operations like (*), (+) etc.
22:43:59 <Pseudonym> pseudoDivid (which is badly named) is division.
22:44:08 <Pseudonym> A Euclidean domain supports division with remainder.
22:44:17 <Pseudonym> That's why it returns a pair.
22:44:30 <skew> yep, PID plus a division operation
22:44:37 <Pseudonym> Right.
22:44:53 <Pseudonym> So you could get them to, say, implement a Euclidean instance for Integer.
22:45:03 <skew> using divMod?
22:45:04 <Pseudonym> Then implement Euclid's GCD algorithm, say.
22:45:13 <Pseudonym> Yes, or div and mod.
22:45:49 <Pseudonym> And then, if you're really adventurous, implement an interface for polynomials.
22:45:58 <Pseudonym> data Polynomial a
22:46:05 <skew> that sounds pretty reasonable
22:46:05 <Pseudonym> instance (Euclidean a) => Euclidean (Polynomial a)
22:46:25 <Pseudonym> It's just a thought.
22:47:05 <Pseudonym> This idea of pick an example out of maths and implement an interface for it is pretty general.
22:47:14 <Pseudonym> You could, for example, use "groups".
22:47:25 <Pseudonym> And get them to implement an interface for, say, permutation groups.
22:47:30 <Pseudonym> Or the Rubik's cube.
22:47:45 <skew> finding the gaps in the standard numeric classes
22:49:05 <skew> the missing Group, Field, etc.
22:50:00 * SamB drags himself off to bed
22:51:33 <skew> That reminds me type classes are motivated by algorithms, or at least functionality
22:51:50 <Pseudonym> I don't think so.
22:52:02 <Pseudonym> Type classes are actually motivated by policy, originally.
22:52:06 <Pseudonym> Eq, Ord etc.
22:52:24 <Pseudonym> Nowadays they're motivated by just about anything.
22:52:50 <skew> well, at least one way you get a typeclass is generalizing from some concrete implementation
22:53:04 <Pseudonym> Yes.  Interface refactoring.
22:53:07 <skew> What do you mean by policy?
22:53:43 <skew> Being all proper and pure in the face of equality?
22:53:48 <Pseudonym> Take Ord, for example.
22:54:12 <Pseudonym> "sort" just needs to know what the programmer intends "<=" to mean for a given type.
22:54:24 <Pseudonym> What <= means is a policy decision.
22:54:30 <Pseudonym> Get what I mean?
22:55:27 <skew> That view seems to assume the operation makes sense for almost all types.
22:56:47 <skew> I think mostly about whether or not an operation can be performed on a type, and then the implementation
22:57:14 <skew> But there is certainly an aspect of setting the default policy
23:01:38 <jdrake> does ghc by default produce large executables? A one line program outputs a file about 300k
23:02:15 <Pseudonym> ANyway, typeclasses are now properly understood as an abstraction, and it can mean whatever makes sense.
23:02:42 <skew> on unix ghc statically links executables
23:03:31 <jdrake> mixed blessing
23:03:33 <shapr> good morning #haskell!
23:03:55 <skew> hi shapr
23:03:59 <jdrake> good night shapr :p
23:04:13 <skew> morning here by a full hour!
23:04:35 <jdrake> here by a full two hours 
23:04:46 <jdrake> i still consider it night
23:04:55 <jdrake> it is night when I go to bed, always
23:05:01 <jdrake> even if it was 500
23:05:30 <Pseudonym> G'day.
23:06:20 <skew> I'm trying to think about the reasons for making a new typeclass, and come up with a problem for an excercise that will motivate making a typeclass
23:06:23 <jdrake> http://www.thesunmachine.net/image_archive/archive/cookd/saddam_replacement/hitler.jpg
23:06:34 <skew> any sugggestions, morning-fresh shapr?
23:09:09 <Pseudonym> Might also want to take a look at CommonHaskellIdioms.
23:09:12 <Pseudonym> Might be some thoughts there.
23:09:29 <Pseudonym> @wiki TraitsTypeclass
23:09:30 <lambdabot> http://www.haskell.org/hawiki/TraitsTypeclass
23:09:31 <Pseudonym> For example.
23:25:45 <skew> Thanks. My plan is still pretty weak around the typeclasses, but I've got some ideas
23:36:44 <hasky> can someone hint me to what i've done wrong here? http://www.geocities.com/mamksau/Drop1.txt
23:38:46 <Cale> first, what is it supposed to do
23:39:03 <Cale> oh
23:39:10 <Cale> it's supposed to be drop :)
23:39:34 <Cale> well, in the case of "otherwise", what are you returning?
23:40:03 <hasky> errm tail of word after it's minused 1 from n enough times?
23:40:27 <Cale> well, whatever you return ought to be a string
23:40:44 <Cale> so starting out with (n-1) + ... wouldn't be a good plan
23:40:56 <hasky> mmm where can i put the (n-1
23:40:58 <hasky> )
23:41:09 <hasky> i tried it in many places and always got erros
23:41:10 <Cale> well, it's a parameter to myDrop, right?
23:41:29 <Cale> well, stop first and think about how this is going to work
23:42:03 <Cale> to drop n letters from the front of a string, what do you do? You drop the first one, then the next (n-1) of them.
23:42:52 <Cale> what do you do to drop 0 characters from a string?
23:43:29 <hasky> return the string :?
23:43:33 <Cale> yeah
23:43:48 <Cale> so you might write "myDrop 0 word = word"
23:44:39 <Cale> or in the case of using guards, "myDrop n word | n == 0 = word"
23:44:52 <Cale> (or <= 0, if you prefer)
23:45:26 <hasky> hmmm i haven't learnt guards written like that before? how does that read in english
23:45:43 <Cale> read | as where
23:45:53 <earthy> myDrop of n and word where n equals zero is word
23:46:21 <adept> i predict that guards will quickly got messy here ... Consider case where word is empty. What would myDrop do?
23:46:52 <hasky> so to drop wouldn't i just put myDrop (n-1) word | n <= 0 = tail word ??
23:47:23 <Cale> that's an odd relation
23:47:33 <adept> try it on 'myDrop 5 ""'
23:47:37 <Cale> think about it this way
23:47:58 <Cale> let's say that the problem of dropping n-1 characters was already solved for you
23:48:18 <Cale> you just have to figure out how to drop n characters, given this previously solved problem
23:48:57 <hasky> take the tail of word n times
23:49:20 <Cale> the solution to dropping n-1 characters from word is called "myDrop (n-1) word" and you're free to use it in your solution to dropping n characters.
23:49:50 <adept> hasky: no. try to put it like "myDrop n word = something using myDrop (n-1) word"
23:50:05 <hasky> oh
23:50:47 <Lunar^> morning all
23:50:56 <Cale> do you see how it works? You only ever need to take it one step of the way there.
23:51:36 <adept> and only in the end you will need to think about corner cases like empty word or negative n.
23:51:37 <Cale> The only other thing you need to handle is removing 0 characters from a word, or dealing with when the word is empty.
23:51:47 <Cale> yes
23:52:17 <hasky> ok i'll give it another shot :D thanks for help
23:52:31 <Cale> no problem
23:54:37 <hasky> hehehe it worked :D
23:54:41 <hasky> oh man that's simple
23:55:20 <hasky> uh oh soccer training
