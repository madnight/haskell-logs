00:05:33 * shapr boings cheerfully
00:05:43 <det> shapr: how goes it
00:05:49 <shapr> it goes boingily
00:05:52 <shapr> how goes it with you?
00:07:27 <det> much tea consumption
00:07:30 <det> quite boingingly
00:07:45 <shapr> written any cool code lately?
00:08:08 <det> afraid not
00:08:13 <det> not in quite some time
00:08:29 <det> hey
00:08:50 <shapr> hey?
00:08:59 <det> do you know if it is possible to this IRC session to a newly created screen session
00:09:12 <shapr> I know you can move from one screen to another
00:09:18 <shapr> I dunno about moving from non-screen to screen
00:09:22 <det> it's not under screen now :/
00:10:23 <shapr> alternatively, you could start screen when you login
00:10:39 <shapr> so that you always have your apps running in screen, and that way you can move them whenever you like
00:11:26 <det> yeah
00:11:29 <det> I used to do that
00:11:42 <det> until scp started complaining
00:11:48 <shapr> scp complains about screen?
00:11:49 <det> I guess I could test for login shell
00:12:06 <det> it would be a complicated setupi if I recall
00:12:10 <det> yeah
00:12:16 <det> I forget the exact message
00:13:52 <det> screw it
00:13:53 <det> brb
00:15:08 <shapr> is that better now?
00:15:15 <det> yes :)
00:15:25 * shapr grins
00:15:41 <det> I thought my ctrl key was broken for a while
00:15:48 <det> till I realized I wasnt under screen
00:15:58 <shapr> hey, I wrote an mailing list search web app in Haskell, curryspondence :-)
00:16:11 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
00:16:12 <shapr> it's cute
00:16:21 <det> mm :)
00:16:29 <det> does it search mbox or something?
00:16:32 <shapr> yup
00:16:39 <det> neat
00:16:42 <shapr> snip, parse, load into postgresql
00:16:50 <det> I remember you trying to figure out a format
00:16:56 <shapr> uses HaskellDB so I get all the benefits of SQL with none of the disadvantages
00:16:57 <det> oh, just decided to use postgres
00:17:08 <shapr> yah, I'll get around to figuring out on-disk stuff at some point
00:17:11 <shapr> but I wanted results
00:17:25 <det> pragmatism, yay
00:17:47 <shapr> the source is quite small
00:18:02 <shapr> ~80 lines to go from mbox into database
00:18:25 <det> do you parse mbox yourself?
00:18:29 <shapr> yup
00:18:32 <det> erm, I guess mbox is really simple
00:18:34 <shapr> not like it's hard
00:18:47 <det> it found nothing for my name!
00:18:58 <shapr> mboxSplit instring = map unlines $ breakAll (isPrefixOf "From ") $ lines instring
00:19:00 <det> I have posted twice
00:19:05 <shapr> that's my mbox snipper
00:19:23 <shapr> it currently ignores multipart messages, you may have posted that way
00:19:43 <shapr> since the first time I tried to search emails I indexed attachments, which sucked
00:20:19 <shapr> it's pretty speedy for 20k messages
00:22:43 <det> it would be neat if the search returned a link to the official archive
00:22:50 <det> so you could navigate thread
00:22:55 <shapr> I wanted to do that originally
00:23:13 <shapr> but the archive uses offset from the first message
00:23:22 <shapr> at least, that's what I think it's using
00:24:05 <det> so You cant generate the correct index?
00:24:13 <shapr> not that I know of
00:24:27 <shapr> I could try calculating the offset
00:24:32 * shapr thinks about that
00:24:39 <det> cant you just stick the index number in the DB at pasring?
00:24:48 <shapr> maybe
00:26:11 <shapr> that assumes the mbox file matches the thread stuff perfectly
00:26:31 <det> might it not?
00:26:50 <det> I assume thats how mailman generates the index numbers
00:26:50 <shapr> it might not, I found quite a few insane things while parsing the mbox file
00:27:04 <det> if not, see how it does and do that same :)
00:27:05 <shapr> multiple duplicate message-ids, messages that don't appear to have any message-id at all
00:27:14 <shapr> all sorts of weird stuff
00:27:19 <det> oh
00:27:42 <det> the world needs a standard serialization format that is not XML :)
00:27:48 <shapr> truly
00:28:00 <shapr> something with a native set datatype
00:28:10 <det> I have thought about Algabraic data types + sexpressions 
00:29:16 <shapr> any xml comparisons?
00:29:25 <det> I dont know much of XML
00:29:27 <det> but I imagine
00:29:37 <det> DTD/Schema + XML
00:29:41 <det> would be equivalent
00:29:50 <det> like
00:30:40 <det> data intlist = Nil | Cons int intlist
00:30:43 <det> put that in a source file
00:31:03 <det> and have a compiler generate sturcture/serialization functions for your language of choice
00:31:09 <shapr> looks like lambda calculus
00:31:11 <det> binary and s-expressions
00:31:12 <det> yeah
00:31:21 <det> like haskell/sml datatpyes
00:31:32 <det> I forget haskell syntax
00:31:35 <det> was that correct?
00:32:09 <shapr> you could generalize it a bit, data List a = Nil | Cons a (List a)
00:32:15 <det> yeah
00:33:21 <det> I think at some point you would have to do type IntList = List(int)
00:33:29 <det> to maintain cross-language compatiblilty
00:34:13 <shapr> have you seen Pseudonym's ratio numeric code in Haskell-Libs ?
00:34:23 <det> no
00:34:57 <shapr> I've been thinking that Integer ratios are more exact than floating point
00:34:59 <det> google is most unhelpful
00:35:11 <shapr> since floating point calculations are inherently lossy
00:35:14 <det> well, floating cant represent 1/3
00:35:17 <shapr> right
00:35:25 <det> I have thought about the same thing
00:35:39 <det> trying to figure out how to represent ratios without redudancy
00:35:48 <det> like 2/10 = 1/5
00:35:52 <shapr> Pseudonym said that some fractions are easy to represent in binary, but are insane to represent in two number ratio representation
00:36:38 <shapr> then he said there exists some set of three or four number Integer ratios for even the most pathological cases
00:37:25 <shapr> I think this is it: http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/exactreal/
00:37:33 <det> how can you represent 1/3 in binary except as a ratio?
00:37:52 <det> or 1/<any prime>
00:38:30 <shapr> I think he was saying that some numbers are better as rationals, but that standard two number rationals have the same disadvantage, sometimes they suck for stuff where binary is good
00:38:51 <det> hmm
00:38:56 <shapr> and that multinumber rationals can fix that
00:38:58 <det> how can you have multipart ratios?
00:39:05 <det> can you explain the concept?
00:39:09 <shapr> 5 / 6 / 7
00:39:15 <shapr> instead of just 1 / 3
00:39:15 <det> ohhh!
00:39:20 <det> hmmm
00:39:37 <shapr> so he wrote some code to find small rational representations of pathological cases
00:39:51 <det> do you have an example of a case where multi number is superior the standard 2 number ratios?
00:39:57 <shapr> no, I don't
00:40:31 <shapr> I can probably find this discussion in the #haskell logs
00:41:02 <det> I cant imagine any benefiet to multiplying the devisors(correct term)?
00:43:41 <shapr> divisors I think
00:47:16 <shapr> kosmikus: nice hostname
00:47:21 <kosmikus> :)
00:48:13 <det> kosmikus: hmm, freenode does this for you?
00:49:07 <kosmikus> det: yes
00:49:26 <earthy> that's through registering? schweet
00:50:05 <kosmikus> I don't know exactly how it works. It was an offer they made to all Gentoo developers, so essentially I just wrote a mail ...
00:50:13 <earthy> ah. ;)
00:50:13 <det> hmm, there are no @*.debian :)
00:50:34 <det> kosmikus: to attract gentoo users/developers to freenode?
00:51:21 <shapr> det: look at the comment in the top of ICreals.hs
00:51:23 <kosmikus> I don't know anything about the background, but I think there's an overlap between freenode staff and Gentoo management, and that might have helped -- but as I said, I don't really know, I am just footfolk among the developers ...
00:51:51 <det> shapr: ok
01:03:16 <kosmikus> ghc-5.04.3 cannot be compiled by gcc-3.3 <--- is this statement correct?
01:03:51 <earthy> yes.
01:04:44 <earthy> and I can make it a bit stronger: it seems ghc 5.04.3 cannot be compiled (at least on some architectures) by any gcc 3 series compiler
01:05:32 <kosmikus> I remember, although I do not know for sure, that I did compile it successfully with gcc-3.2 ...
01:05:44 <earthy> on x86, I bet.
01:05:56 <earthy> it simply will not compiler with gcc 3.2 on SPARC
01:05:58 <earthy> -r
01:06:17 <earthy> (well, no, not true. it will not compile into a functioning compiler with gcc 3.2 on SPARC)
01:06:26 <kosmikus> yes, on x86
01:11:47 <blackdog> shapr: are you indulging in deliberate mindf**ks?
01:11:52 <blackdog> "the website you have you have typed has been underdeveloped or is no longer in service. "
01:12:14 <blackdog> damn, he's gone. i'll have to harass him somewhere else... sorry all.
03:09:46 <shapr> andersca just had a great idea, planet.haskell.org 
03:11:22 <shapr> it would be a community website where people could link to various things, the hOp log, package announcements, or small nifty things like we see here on #haskell
03:12:05 <shapr> at first thought I'd use Plone, any other suggestions?
03:12:13 <andersca> well, actually all other planet sites are blog aggregators
03:12:26 <andersca> but there's no reason we can't add rss feeds for all sorts of cool things :)
03:14:15 <shapr> so, who here has a blog?
03:14:21 <shapr> I know SyntaxNinja has one
03:14:26 <shapr> and hOp has one
03:14:39 <Lunar^> I had one, and the new just talks about hOp
03:14:50 <Lunar^> I need to switch to a real log system anyway
03:15:17 <Lunar^> lambda could be one of them also
03:15:41 <shapr> yes, good point
03:17:19 <blackdog> i had one. i don't update it often though... just started it for the ICFP comp.
03:21:35 <shapr> so, now I just need to write an RSS aggregator with WASH
03:22:45 <Si\> sounds like fun
03:32:04 <Lunar^> shapr: urgh
03:32:10 <Lunar^> shapr: RSS is a mess!
03:59:36 <Lunar^> shapr: Do you know how to make file read non-blocking with Python ?
03:59:58 <Jerub> Lunar^: do it in steps with a generator is my only advice.
03:59:59 <Jerub> ;)
04:00:06 <Lunar^> Jerub: ?
04:00:36 <Lunar^> Jerub: it's inside a Zope product, so we can't afford to have any blocking operation at all
04:01:50 <Jerub> okay. surely thats a zope faq then?
04:03:09 <Lunar^> good idea
04:09:32 <Jerub> Lunar^: my approach would be to do small chunks of processing and then relinquish before continuing.
04:12:17 <Lunar^> Jerub: That's more a Pyton related problem anyway, that was fixed in 2.3
04:12:33 <Lunar^> Jerub: same problem as GHC with thread and blocking operation
04:43:10 <det> Lunar^: non-blocking IO on files is only available on some OSes
04:43:35 <det> Lunar^: if you want true non-blocking, I think you need to use threads
04:44:05 <det> Lunar^: if you just want it not to be a big operation, you can split it up into chunks of work as suggested, but it may block forever in certain instances
04:44:50 <det> Lunar^: or if you are commited to only, say linux, you can always use select()
04:47:38 <Lunar^> det: Thanks
04:49:29 <det> n/p
04:56:03 * shapr boings
04:56:05 <shapr> hey darius-
04:56:43 <shapr> Lunar^: I currently know nothing about RSS, I'll investigate it soon
04:58:20 <Lunar^> shapr: I've started an RSS agregator for KDE
04:58:27 <Lunar^> shapr: Its little name was syndiKate
04:58:54 <Lunar^> shapr: There's a least 3 running versions of RSS + Atom
04:59:16 <Lunar^> shapr: RSS 0.92 which is classic XML, RSS 1.0 which use RDF XML, RSS 2.0 which use plain XML
04:59:25 <shapr> scary
04:59:55 <Lunar^> shapr: Maybe there is a C library that would do the job know
05:00:04 <Lunar^> shapr: Or there is this agregator written in Python...
05:02:13 <Lunar^> http://home.kcore.de/~kiza/software/snownews/ <-- which FFI maybe
05:03:05 <darius-> hey shae
05:04:10 <Lunar^> Straw is the name of the RSS aggregator in Python
05:46:43 <Si\> is it possible to catch exceptions that have not occured in the top-level functions?
05:47:03 <shapr> ?
05:47:09 <Si\> i.e. if I do catch (x $ f y) (...) and an exception occurs in f
05:47:17 <Si\> normally this won't get caught
05:47:27 <Si\> but catch (f y) will
05:47:35 <shapr> should be easy to try it out
05:47:42 <shapr> write up an f that throws an error
05:47:46 <Si\> I have
05:47:50 <shapr> did it work?
05:47:59 <Si\> if you do catch (f y) it catches
05:48:10 <Si\> if you do catch (g $ f y) it doesn't
05:48:28 <shapr> that seems unexpected
05:51:07 <Si\> I have a data-type data Value a = Val a
05:51:26 <kosmikus> catch probably only evaluates to WHNF
05:51:35 <Si\> if I do catch (read "t") (\_ -> return 0) it works
05:51:54 <Si\> but if I do catch (Val $ read "t") (\_ -> return 0) it doesn't
05:52:00 <shapr> bonjour kowey 
05:52:05 <kowey> hi shapr
05:52:10 <kowey> hi all
05:53:53 <kosmikus> Si\: what catch do you use?
05:54:07 <kosmikus> @type catch
05:54:07 <lambdabot> catch :: IO a -> (IOError -> IO a) -> IO a
05:54:15 <kosmikus> read "t" is not an IO
05:54:50 <Si\> ah CE.catch ((Monad.liftM Val) (evaluate (read "t"))) (\_ -> return NullVal) works
05:55:14 <Si\> the evaluate has to go around only the throwing functions
05:55:30 <Si\> clearly it only evaluates down one level
05:56:26 <kosmikus> yes, that's what I assumed
05:57:46 <kowey> folks, i have an idea for a debugger if you won't mind vetting it
05:58:34 <kowey> the basic principle is to have as small a learning curve as possible
05:58:46 <kowey> and to replicate the experience of pepeppering your code with printfs
05:59:15 <kowey> anybody use Hood?
05:59:31 <shapr> I haven't tried it
06:00:44 <kowey> http://www.haskell.org/hood/basics.htm
06:00:59 <Jerub> imho, 90% of classic programming errors could be caught with a parse tree visualiser. ;)
06:01:22 <Marvin--> yeah I use Hood, it rocks
06:01:25 <kowey> see, with hood, the basic idea uhm
06:01:39 <kowey> well... what i'm doing is taking away all the power of hood, but making it simple
06:01:42 <shapr> I think 90% of programming errors could be caught with unit tests
06:01:59 <Lunar^> kowey: Ever tried Buddha ?
06:02:01 <shapr> or with quickcheck
06:02:13 <kowey> never could get it to compile on my mac,
06:02:19 <shapr> so, who's coming to EuroHaskell?
06:02:22 <musasabi> something like buddha + knowledge about versioning would be nice
06:02:24 <kowey> but does Buddha have the same idea? as it be really easy to use?
06:02:28 <shapr> c'mon, sign up!
06:02:45 <musasabi> so one would just get asked about the code changed in N revisions...
06:03:01 <shapr> darcs has something a bit like that
06:03:12 <shapr> it has darcs trackdown
06:03:24 <shapr> which is a very cool thing to have in a source control system
06:04:19 <kowey> any Marvin--, the first idea was that when i do "observe debugstr foo", i put all my effort into debugstr and no effort into making foo an instance of Observable
06:04:28 <Lunar^> shapr: I'd like to know my planning better but that would be cool
06:04:43 <Marvin--> kowey: you do?
06:04:58 <kowey> right... so i added a default implementation of observe to Observe.lhs
06:05:03 <kowey> observer x = send "" (return x) 
06:05:18 <kowey> now, i would like to make it so that you don't even need the Observable class
06:05:46 <shapr> generics!
06:06:19 <kowey> instead of observer x = send "" (return x) 
06:06:22 <shapr> yes?
06:06:38 <kowey> oops... wrong clipboard stuff
06:06:45 <kowey> instead of observe :: (Observable a) => String -> a -> a
06:06:48 <Marvin--> kowey: what's wrong with the observeBase?
06:07:16 <kowey> we'd have observe :: String -> a -> a 
06:07:20 <Marvin--> observeBase :: (Show a) => a -> Parent -> a
06:07:20 <Marvin--> observeBase lit cxt = seq lit $ send (show lit) (return lit) cxt
06:07:40 <kowey> huh...
06:07:45 <kowey> didn't know that was there :-)
06:07:56 <kowey> wish the doc made me look at that first
06:08:09 <kowey> the other thing is that i don't really want (Show a) either
06:08:16 <Marvin--> Observe.lhs uses it to define the basic instances of Observable, but it's also exported so you can use it yourself
06:08:50 <kowey> the goal is so that you don't have make any instances or anything, i guess if my type was an instance of Show, that would work
06:08:52 <Lunar^> kowey: this observe signature really looks like Debug.Trace.trace
06:09:10 <kowey> ah hah!
06:09:22 <kowey> how does that work?
06:09:41 * kowey looks at the code
06:09:51 <Lunar^> unsafePerformIO
06:10:13 <kowey> so, without doing anything fancy to my code...
06:10:15 <Marvin--> Lunar^: yes, HOOD is inspired by trace, but it works Better<tm>
06:10:25 <kowey> i could just stick in a Debug.Trace.trace and i have my printfs?
06:10:29 * kowey tries
06:10:41 <Marvin--> trace s e  evaluates to e 
06:10:43 <Marvin--> and prints s
06:10:59 <Marvin--> observe s e will not only evaluate to e, but also print out s *and* e
06:11:10 <Marvin--> or rather, it will print out the parts of e that are evaluated
06:11:12 <kowey> right, and printing out e is not interesting for me
06:11:24 <SyntaxNinja> trace is useful. I wish that I could ever get Hat to work well, but I can't. it either doesn't handle extensions I'm using, or it doesn't have the .hat files for the libraries.
06:11:26 <Marvin--> it isn't? That's what rocks about Hood and exactly why I use it! :)
06:11:36 <ztre> csö
06:11:37 <Marvin--> kowey: sounds like trace is what you want then
06:11:45 * Marvin-- loves da hood
06:11:54 <SyntaxNinja> Marvin--: what is hood's niche? I forget
06:11:55 <kowey> it does... i think hood's a nice idea, just not very convenient
06:11:55 * Lunar^ is a Buddha fan
06:12:13 * ztre is a Vishnu fan
06:12:20 <kowey> i'm one of those people that knows gdb is there but still uses printf... sigh
06:12:46 <Marvin--> SyntaxNinja: trace, but Better ;)
06:13:16 <Jerub> I'm a God fan
06:13:20 <kowey> whee! thanks everyone!
06:13:27 <shapr> I'm a Jesus fan.
06:14:13 <Marvin--> kowey: I think it's really convenient, definitely convenient compared to putStr
06:14:15 <SyntaxNinja> Marvin--: I want hat to work.
06:14:20 <shapr> hat hat hat
06:14:22 <Marvin--> SyntaxNinja: I've never tried it
06:14:38 <SyntaxNinja> I've decided that testing is my replacement for debugging, basically.
06:14:42 <shapr> me too
06:14:47 <SyntaxNinja> but that hasn't completely worked in practice, btw.
06:14:54 <shapr> when does it lose out?
06:14:55 <SyntaxNinja> I think it's shapr who convinced me of htat, so it's no surprise that we agree ;)
06:15:02 <shapr> oh :-)
06:15:06 <kowey> Marvin--: really? but all those instances to define! :-)
06:15:07 <SyntaxNinja> shapr: when I don't build unit tests early.
06:15:12 <shapr> oh, that's a good point
06:15:15 <shapr> oh hey
06:15:24 <kowey> well ok, i guess observeBase does help a lot
06:15:25 <shapr> I got distracted, but wanted to respond to your post on libraries
06:15:40 <shapr> I think QC can subsume HUnit if it saves static tests
06:15:51 <Marvin--> kowey: observeBase is good enough IMO, deriving would be neat, but there's no mechanism in Haskell for making your own type classes derivable
06:16:40 <ztre> any *** fans here btw?
06:16:56 <SyntaxNinja> shapr: yeah, I kinda lost in that thread ;)
06:17:10 <SyntaxNinja> but I was dumb to volinteer to take care of hunit.  why do I keep taking on more work?
06:17:20 <shapr> ztre: http://c2.com/cgi-bin/wiki?ThreeStarProgrammers
06:17:32 <ztre> shapr: no :-/
06:17:33 <ztre> :-(
06:17:34 <SyntaxNinja> fortunately, I got over-ruled
06:17:39 <ztre> shapr: VHJ
06:17:43 <ztre> i mean
06:17:48 <ztre> *** you know
06:17:52 <shapr> no?
06:18:58 <ztre> shapr: there are Jesus and Buddha and Vishnu fans
06:19:11 <shapr> ok
06:19:15 <ztre> shapr: *** is the one with the Name Unspeakable
06:19:18 <ztre> :-/
06:19:20 <shapr> hastur?
06:19:24 <ztre> VHJ
06:19:35 <shapr> oh, Yahweh?
06:19:36 <ztre> shapr: who is Hastur?
06:19:43 <ztre> shapr: yes :-(
06:19:51 <SyntaxNinja> so shapr: about that parser for LIP... you should look at the way ghc-pkg uses happy to parse its package file; if we could have something like that, but more general as a library, that would be really nice.
06:19:58 <shapr> technically Yahweh == Jesus
06:20:17 <shapr> that name was originally invented so that people could not speak his name, and therefore not use that name in vain
06:20:19 <ztre> shapr: technically?
06:20:56 <shapr> yes, in the sense that from the standpoint of judaism, the new testament doesn't apply
06:21:16 <ztre> :-/
06:21:22 <shapr> SyntaxNinja: does happy work for all Haskell implementations?
06:21:24 <shapr> is happy h98?
06:21:30 <Jerub> and also from the standpoint of islam, the concept of Jesus = God is ignored.
06:21:35 <shapr> right, that too
06:21:44 <SyntaxNinja> so I take my haskell discussion away from a room where its OT, and bring it here where this room is altogether OT ;)
06:21:46 <Marvin--> I wonder why Hood isn't distributed with ghc
06:21:56 <SyntaxNinja> shapr: I'm pretty sure that the code it produces is H98
06:21:58 <Igloo> I'm fairly sure happy is H98, and generates H98 unless told otherwise
06:21:58 <shapr> so, for protestants and other believers in the new testament Yahweh == Jesus
06:22:34 <shapr> so, happy is the best approach for a LIP parser then
06:22:38 <ztre> shapr: :-/
06:22:58 <SyntaxNinja> shapr: I would expect that to most christians, Yahweh would most closely refer to G_d the father, rather than jesus.
06:23:40 <SyntaxNinja> shapr: I don't know, what do you think? (about happy) it seemed to be the consensus that XML is lame, and it furthermore makes my code less portable across haskellImplementations
06:23:54 <ztre> shapr: to most christians *** refers to the jewish god, not Jesus nor anyone else
06:23:59 <Jerub> I've been using parsec, I've been extremely impressed with it.
06:24:05 <shapr> I agree, XML is lame, but what other or better alternatives are there?
06:24:21 <ztre> xml rocks
06:24:34 <Marvin--> > printO $ take 4 (observe "foo" [1..] :: [Int])
06:24:34 <Marvin--> [1,2,3,4]
06:24:34 <Marvin-->  
06:24:34 <Marvin--> -- foo
06:24:34 <Marvin-->   1 : 2 : 3 : 4 : _
06:24:43 <Marvin--> *that's* what's neat about observe
06:25:11 <ztre> 8-/
06:25:18 * ztre is away
06:25:25 <kowey> that'll take some digesting
06:25:30 <shapr> Jerub: does parsec work for nhc or hbc?
06:25:39 <shapr> or UHC?
06:25:44 <Jerub> shapr: sorry?
06:25:47 <kowey> i think my complaint is pretty personal... stuff gets over my head very quickly :-)
06:25:48 <Jerub> are those compilers?
06:25:52 <shapr> afaik, there's GHC, Hugs, NHC, HBC, and UHC
06:25:58 <shapr> possibly I've forgotten one or two
06:26:16 <Jerub> shapr: no idea, only used it in hugs.
06:26:18 <shapr> I've ignored things like Eager Haskell, GpH, etc
06:26:40 <Jerub> haven't figured out how to use ghc to compile stuff yet. ;)
06:26:41 <shapr> so, the point of LIP is to make a haskell-oriented package system
06:27:10 <kosmikus> UHC is unreleased
06:27:15 <shapr> kosmikus: but nifty!
06:27:22 <kosmikus> Helium exists, though
06:27:45 <SyntaxNinja> shapr: I think parsec is portable.
06:27:47 <ztre> Jerub: hgc -O -o output source.hs
06:27:51 <ztre> ghc
06:27:52 <SyntaxNinja> helium isn't h98
06:28:04 <Marvin--> isch, Observe is in hslibs/util
06:28:08 <kosmikus> neither is hbc
06:28:21 <SyntaxNinja> I'm not too worried about non-h98 compliant compilers.
06:28:42 <kowey> Marvin--: did you ever get GHood to work?
06:29:21 <Jerub> ztre: but how do I compile with multiple .hs files, link them together and run them with a main?
06:29:41 <Marvin--> kowey: haven't tried
06:30:12 <Jerub> SyntaxNinja: are you talkinag about configuration formats for a package manager?
06:30:59 <Jerub> SyntaxNinja: is 'executable code' an option here. its always been my favourite configuration format.
06:31:54 <Igloo> Marvin: Is there a way to do   take 4 ((observe "foo" 1:2:3:b) :: [Int]) where b = b   so I can see the observation without hitting ^C?
06:32:33 <Marvin--> Igloo: I don't think so
06:33:29 <ztre> Jerub: -make
06:33:59 <Igloo> Looks like this doesn't work either:  take 4 (observe "foo" (1:2:observe "bar" (3:b)) :: [Int]) where b = b
06:34:25 <Marvin--> well that's because the expression doesn't terminate
06:35:01 <Igloo> But I can see as much of the foo output as is computed
06:35:10 <Igloo> (by hitting ^C twice)
06:35:29 <Lunar^> Igloo: try adding \n thus you want get buffering
06:35:43 <ztre> Jerub: no :-(
06:35:48 <ztre> Jerub: maybe -package
06:36:14 <Marvin--> Igloo: I don't think Hood pretends at all to deal with non-terminating values
06:36:51 <Igloo> Oh, I hadn't realised hood meant observe
06:38:41 <Marvin--> wow, GHood is pretty neat
06:39:28 <kowey> yeah, but its version of Observe.lhs needs to incorporate changes from the most recent Observe.lhs
06:39:34 <kowey> for ghc 6.2, i think
06:40:06 <Marvin--> it worked for hugs, didn't try it witih ghci
06:40:18 <SyntaxNinja> Jerub: yeah, that's what we're talking about.  why would I want executable code for storing the package information?
06:42:15 <Marvin--> I do wonder why Observe hasn't been moved to Debug.Observe
06:50:14 * Marvin-- goes back to playing Shadowgate
07:02:32 <kowey> ding dong, the bug is dead... thanks again
07:02:39 * kowey walks away, a happy customer
07:31:39 <shapr> @yow !
07:31:40 <lambdabot> I know how to get the hostesses released!  Give them their own
07:31:40 <lambdabot>  television series!
07:31:52 <shapr> hello sysfault 
07:32:09 <shapr> looking for Haskell info?
07:32:41 <Marvin--> yow shapr
07:32:42 <sysfault> shapr: yes sir, I plan on learning haskell.
07:32:54 * sysfault is a neophyte in the programming field.
07:33:09 <sysfault> do you think a beginner can handle it?
07:33:49 * sysfault is also into math, looks like a great language for mathematical evaluations, etc.
07:34:28 <shapr> yes, Haskell is a good beginner language
07:34:52 <shapr> you'll probably find procedural language really bizarre and limiting at first, since Haskell is purely functional
07:35:08 <shapr> but if you like math, Haskell is a good first programming language
07:35:44 <sysfault> what is it capable of?
07:36:07 <sysfault> "software centric"
07:36:25 <shapr> same stuff as any other programming language, but its way of looking at the world is more math-centric, in my opinion
07:36:56 <shapr> you may have heard the Sapir-Whorf hypothesis, which can be paraphrased as "how you speak is how you think"
07:36:57 <sysfault> nice.
07:37:35 <shapr> inaccurately paraphrased, but that's the general idea
07:37:39 <sysfault> can you recommend any good beginner documentation?
07:38:05 <shapr> I would recommend trying Hal Daume's "Yet Another Haskell Tutorial" and "The Gentle Introduction"
07:38:13 <sysfault> shapr: aah, a different approach is always good.
07:38:19 <sysfault> which should I read first?
07:38:21 <shapr> both of those are linked from the Learning webpage mentioned in the channel topic
07:38:42 <sysfault> shapr: yea I'm currently on that page, I simply don't know which one too read first.
07:38:51 <sysfault> I'll go with "The Gentle Intro"
07:38:54 <shapr> well, YAHT is easier to start with, but the Gentle Intro is the hard-core stuff
07:39:08 <sysfault> ooh, ok.
07:39:27 <shapr> yes, I'd recommend trying the Gentle Intro first, and if it seems too confusing, check out YAHT
07:39:37 <shapr> and of course, ask questions here on #haskell, we try to be helpful
07:40:09 <SyntaxNinja> Segora: You should read my review of The Haskell School of Expression, which is a book on Haskell if the tutorials aren't enough for you: http://books.slashdot.org/article.pl?sid=04/03/12/221232
07:40:16 <sysfault> I like math, and I plan on becoming a mathematician, but I surely hope it doesn't get too obscure. Currently, learning algebra. "Self Study"
07:40:43 <shapr> I think you'll like Haskell
07:40:43 <sysfault> I'am supposed to be in the 10th grade highschool, but I'm currently doing home school.
07:40:47 <shapr> spiffy
07:40:52 <sysfault> I hope so.
07:40:59 <shapr> I'm supposed to be working, but I'm reading about Haskell instead ;-)
07:41:05 <sysfault> hehe.
07:41:57 * Si\ is really proud of HAIFA's error handling system
07:42:00 <Smerdyakov> sysfault, be a computer scientist instead!
07:43:30 <ztre> :-D
07:43:32 <ztre> rotfl
07:44:31 * Marvin-- laughs evilly as he finds a bug in Koen's naive FOL translation
07:47:49 <sysfault> Smerdyakov: hehe.
07:50:03 * Marvin-- ammends that to "possible bug"
07:54:24 <Smerdyakov> sysfault, why is it funny?
07:57:20 <sysfault> Smerdyakov: why is what funny?
07:57:26 * sysfault doesn't remember laughing.
08:02:03 <sysfault> what exactly does the tutorial mean when they say "typeful programming language"?
08:02:16 <Smerdyakov> <sysfault> Smerdyakov: hehe.
08:02:50 <sysfault> Smerdyakov: hehe = laughing?
08:02:56 <sysfault> eerm, no.
08:04:49 <Igloo> What do you mean by "hehe" then?
08:05:21 <Smerdyakov> Most everyone takes "hehe" as laughter.
08:06:44 <sysfault> if someone was to say a joke I liked a lot, I'd say "hehe" (meaning hah, good one). Not really laughter in that context.
08:07:02 <sysfault> I use "lol" for that.
08:11:21 <Igloo> I still don't see why that makes it not funny, but hey, whatever
08:11:36 <sysfault> why that makes it not funny?
08:11:43 * sysfault sighs, sure.
08:12:57 <Smerdyakov> sysfault, OK, so why is suggesting CS a joke?
08:14:13 <sysfault> Smerdyakov: I never classified "suggestion CS" as a joke, I simply wasn't interested in your suggestion, and I didn't want to just leave your question out in the open, so I replied "hehe".
08:14:49 <Smerdyakov> sysfault, why weren't you interested in it?
08:15:29 <sysfault> My mind is made up already, I want to be a mathematician.
08:15:43 <Marvin--> that's great
08:15:46 <Smerdyakov> Do you know what computer science is?
08:15:50 * Marvin-- still has no clue what he wants to be
08:16:15 <sysfault> Smerdyakov: eerm, yes I do. 
08:16:30 <Smerdyakov> sysfault, OK, so then you know that computer science is a branch of math.
08:17:08 <Smerdyakov> And one that happens to make your life much easier fundingwise if you specialize in, compared to the average area of math
08:17:43 <sysfault> Smerdyakov: of course, but it doesn't cover the core semantics, nor does it cover the extended topics.
08:17:50 <sysfault> philosophy of mathematics, etc.
08:18:09 <Smerdyakov> Most mathematics programs don't require philosophy of math, as far as I know.
08:18:15 <Smerdyakov> So I don't see the relevance of that.
08:18:33 <sysfault> Smerdyakov: nor, do I see the relevance of recommending computer science to learn math.
08:18:41 <Smerdyakov> And what "the core semantics" and "the extended semantics"?
08:18:50 <Smerdyakov> er extended topics
08:19:12 <sysfault> meaning from basic arithmetic, to extended topics such as "P.O.M"
08:19:15 <sysfault> as I said.
08:20:16 <sysfault> anyway, It doesn't matter, I know what I want to do, and we should end it here.
08:20:21 <Smerdyakov> I have very strong views on this subject. I consider computer science just as good an introduction to math as the classical approach.
08:20:41 <Smerdyakov> The prevalence of analysis is an historical accidentr.
08:21:46 <sysfault> Smerdyakov: computer science _DOES_ not teach you how to distinguish a basic algebraic expression, from a true polynomial, mononomial, binomial, etc. Simply things like that are not explained.
08:21:52 <sysfault> the big distinction.
08:22:09 <Smerdyakov> Sorry, can you summarize what those words means for me? :)
08:22:32 <sysfault> s/Simply/Simple
08:22:38 <Smerdyakov> I mean in particular "a basic algebraic expression"
08:22:38 <sysfault> Smerdyakov: haha :)
08:23:07 <sysfault> a simple algebraic expression.
08:23:22 <Smerdyakov> What is that?
08:23:32 <shapr> Smerdyakov: be nice to newbies
08:23:45 <Smerdyakov> shapr, huh?
08:23:56 <sysfault> shapr: it's ok.
08:24:25 <sysfault> Smerdyakov: 3*x*y + 3*y^2 - 2*x*y + y^2
08:24:26 <Marvin--> gah
08:24:37 <sysfault> Smerdyakov: that's an algebraic expression.
08:24:39 <Smerdyakov> And that's not a polynomial?
08:25:38 * Marvin-- tries to work out whether refutable and irrefutable patterns have to be translated differently in FOL
08:26:33 <Igloo> They have different semantics so I'd have thought so, although I don't know exactly what your stuff does
08:26:34 <sysfault> Smerdyakov: x - 3/ 5*x what's that?
08:26:59 <Smerdyakov> sysfault, what's the associativity?
08:27:13 <Igloo> If   f p = ...   is different to   f v = let p = v in ...   hten yes, though
08:27:28 <sysfault> Smerdyakov: I want to know how much computer science has taught you about practical algebra.
08:27:47 <Smerdyakov> sysfault, practical algebra is not denoted in ASCII, so please tell me how the / associates there. :P
08:28:16 <Marvin--> Igloo: Well, basically you can translate  f x@p = e  to  f x = let p = x in e  which you can translate to  forall x. p = x -> f x = e
08:28:18 <sysfault> technicalities. :)
08:28:38 <Smerdyakov> sysfault, obviously not, since the expression either is or isn't a polynomial in x depending on the answer.
08:28:45 <sysfault> ok look, I want to learn about math "respectively" nothing more nothing less, my interest in computers are pretty limited.
08:29:01 <Smerdyakov> That's OK. Computer science isn't about computers.
08:29:21 <sysfault> Smerdyakov: really?
08:29:30 <Smerdyakov> Yup.
08:29:43 <sysfault> Smerdyakov: so tell me, what is computer science about?
08:29:47 <Marvin--> Igloo: or rather, f x@~p can be translated to that let expression, but depending on whether the variables in p are used in e or not, it's a bit different
08:29:55 <Smerdyakov> sysfault, did you mean physical computers, like the one you are using now?
08:30:35 <sysfault> Smerdyakov: I mean the existence of computers in general, and how they work.
08:30:39 <Marvin--> computer science is a quite wide topic
08:30:50 <Smerdyakov> sysfault, what is the existence of something that is not physical?
08:31:03 <sysfault> Smerdyakov: #philosophy?
08:31:19 <Smerdyakov> sysfault, we shouldn't need to resort to philosophy for you to explain what you meant. :D
08:31:32 <Smerdyakov> sysfault, what do you mean by "computers in general"?
08:32:02 <sysfault> a lot of things exist, not only in the physical/
08:32:34 <Marvin--> Igloo: I mean, f1 xs@(y:ys) = xs  is not the same as  f2 xs@(~(y:ys)) = xs, but f2 is equivalent to f3 xs = let y:ys = xs in xs. I'm trying to figure out if I can use the same encoding for all three, because the exact semantics depends on whether y or ys are in the rhs or not
08:32:40 <sysfault> Smerdyakov: ohh my, I can't win here, thanks anyway.
08:33:00 <sysfault> I would like to go back to reading the haskell intro.
08:33:06 <sysfault> is that ok?
08:33:18 <Smerdyakov> sysfault, you won't make a good mathematician if you can't explain what you mean. :P
08:33:30 <sysfault> Smerdyakov: so be it.
08:33:56 <sysfault> it shouldn't matter too you, my explanations are surely not enough for you.
08:34:18 <Smerdyakov> sysfault, well, in summary, I think you should consider studying CS, since it is a very nice way of conceptualizing math, which you say you are interested in.
08:34:37 <sysfault> Smerdyakov: conceptualizing?
08:34:49 * sysfault sighs
08:35:01 <Smerdyakov> Yes. I say that math is one application of CS.
08:35:23 <Smerdyakov> And vice versa. There is no real technical difference between the two.
08:35:41 <sysfault> does CS cover trigonometric functions?
08:35:45 <sysfault> curious?
08:36:05 <sysfault> Smerdyakov: woa, no real technical difference?
08:36:07 <sysfault> are you serious?
08:36:32 <Smerdyakov> Certainly, since you define trigonometric functions in rigorous logical language, use algorithms to approximate them, use algorithms to reason about them, ....
08:36:43 * sysfault wish he had a little more coherency on the mathematical field to elaborate, but unforunately I don't.
08:36:58 <sysfault> still learning.
08:37:09 <Smerdyakov> Computer science is the study of computation.
08:37:19 <Smerdyakov> Humans use computation for math. We have no other facilities available.
08:37:51 <sysfault> Smerdyakov: ok so where do the rules, procedures, etc come in for math?
08:37:58 <sysfault> does CS teach you that too?
08:38:27 <Smerdyakov> sysfault, there are two categories.
08:38:43 <Smerdyakov> sysfault, first, algorithms you are taught for doing things like long division, integration by parts, etc..
08:38:58 <Smerdyakov> sysfault, second, algorithms learned much more directly for proving theorems in particular domanis.
08:39:00 <Smerdyakov> domains
08:39:08 <Smerdyakov> s/more directly/less directly
08:40:00 <sysfault> ok
08:41:14 <sysfault> well, I have 2 more years of highschool, so I'll try too learn more about these topics before I go disregarding their existence completely.
08:41:42 <Smerdyakov> OK. None of this is taught in usual high school courses, so poke around elsewhere if interested. :)
08:42:32 <sysfault> what languages do you know?
08:42:57 <Smerdyakov> Programming languages?
08:43:19 <sysfault> yes.
08:43:32 <Smerdyakov> Most of the popular ones.
08:43:39 <sysfault> sorry for the inquiry, just curious.
08:43:40 <sysfault> lol
08:43:45 <sysfault> which?
08:44:01 <sysfault> there are a lot of popular ones.
08:44:06 <Smerdyakov> Seriously. Think of one you've heard of, I'm probably competent enough in it.
08:44:18 <Smerdyakov> There are not many different dimensions of variation among languages.
08:44:21 <sysfault> perl, python ?
08:44:25 <sysfault> c?
08:44:27 <Smerdyakov> You can learn a few and be able to pick any of them up quickly.
08:44:53 <Smerdyakov> I can write basic Perl and Python programs with a manual next to me.
08:45:02 <Smerdyakov> I am a C guru, however. :)
08:45:38 <sysfault> nice, nice.
08:45:56 <sysfault> I dislike perl, it simply looks like an explosion at an ASCII factory.
08:46:11 <Smerdyakov> Yes, everyone in the know dislikes Perl.
08:46:26 <sysfault> python is sort of an imaginary language, way too verbose.
08:46:49 <Smerdyakov> "Imaginary"?
08:46:55 <sysfault> function, and method names are as long as paragraphs.
08:47:07 <Marvin--> wha?
08:47:17 <Marvin--> I like python, it looks like pseudocode
08:47:22 <sysfault> exactly.
08:47:35 <Marvin--> that's not a bug, it's a feature
08:47:46 <sysfault> Marvin--: yea.
08:48:34 <sysfault> brb have to find my sister's cellular.
09:07:58 <Si\> anyone any idea why the Dynamic Linker doesn't like functions and module names with underscores in them?
09:10:17 <Lunar^> Si\: z encoding ?
09:10:35 <Si\> ah it's ok, the newest version doesn't care
09:10:52 <Lunar^> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/names.html
09:11:04 <Si\> ty
09:11:32 <Lunar^> Damn.. I start to know this stuff.. :(
09:12:48 <Si\> :)
09:32:53 <Marvin--> meh, I should get off my butt and use the z encoding in my program too
09:57:08 <kosmikus|away> I hope you don't succeed in convincing sysfault to study CS instead of mathematics ...
09:57:27 <sysfault> ;)
09:57:44 * musasabi started to study CS and now most of things I get done are maths
09:57:57 <Smerdyakov> kosmikus|away, weren't you listening? I think CS and math are the same field. :)
09:58:40 <kosmikus|away> I don't think so, unfortunately, and most computer scientists *and* mathematicians I know wouldn't agree.
09:58:43 <Smerdyakov> And the educational approach historically associated with CS is better.
09:59:04 <Marvin--> feh, CS is barely old enough to *have* a history
09:59:06 <Smerdyakov> kosmikus|away, they don't understand the other field well enough. :P
09:59:32 <Smerdyakov> kosmikus|away, proofs are programs are proofs, so they are the same.
09:59:32 <monotonom> I understand both fields well enough, and I say they are still different.
10:00:14 <Smerdyakov> If you take the time to lay exactly what math and CS encompass, and you do it honestly and completely, you'll find that they generate the same set of topics!
10:00:15 <kosmikus> there are a lot of things that count as CS today that don't have anything to do with mathematics
10:00:32 <kosmikus> but of course, as CS evolved out of mathemtics, it's clear that there are similarities as well
10:01:13 <Smerdyakov> Those are social issues, not fundamentals of a reasonable definition of CS.
10:01:26 <kosmikus> if you start from "ideal" definitions of the two subjects, that might be true; but if you look at what is taught in universities, nothing could be further from the truth
10:01:31 <Smerdyakov> You get people in "applied math" doing things with dubious connections to "real math."
10:02:03 <Smerdyakov> I don't agree for the universities I've attended.
10:02:12 <monotonom> In mathematics there is a topic of homology. Tell me which CS topic it corresponds to.
10:02:16 <kosmikus> in fact, I know many computer scientist who *artificially* try to throw math content out of curricula just to attract more students
10:02:32 <Smerdyakov> kosmikus, not at the top schools
10:02:52 <Smerdyakov> monotonom, is homology the study of homomorphisms, isomorphisms, etc.?
10:03:02 <kosmikus> Smerdyakov: you cannot reduce the world to exceptions ...
10:03:12 <monotonom> No.
10:03:24 <monotonom> I thought you knew mathematics.
10:03:26 <Smerdyakov> monotonom, 'fraid I don't know what it is, then, but, that doesn't matter!
10:03:27 * sysfault looks on
10:03:45 <Smerdyakov> monotonom, because it will be discussed using (implicitly) a formal language of terms and proofs.
10:03:52 <Smerdyakov> monotonom, this language corresponds to a programming language.
10:04:32 <monotonom> You are going to say cs = philosophy next.
10:04:43 <Smerdyakov> Philosophy is too ill-defined to go there.
10:04:47 <musasabi> well modelling programs with mathematics is quite hard.
10:04:54 <musasabi> of course simple programs are easy.
10:04:55 <monotonom> And God knows? After that you will equate cs with theology.
10:05:00 <Marvin--> I know how to abbreviate this discussion: X = Y. There, done.
10:05:00 <kosmikus> monotonom: I don't think that topology/homology/higher algebra has much connection to CS, although, interestingly, just topology happens to be *the* mathematical field that uses category theory
10:05:04 * Marvin-- moves on to more productive things
10:05:09 <musasabi> but most of the time an exact mathematical analysis is impossible in CS.
10:05:40 <Smerdyakov> musasabi, what? How exactly do you mean?
10:06:24 <musasabi> Smerdyakov: the problems become so large that obtaining a precise solution is not feasible.
10:06:44 <Smerdyakov> musasabi, well, I research program analysis for a living, so I don't agree with you. :P
10:06:54 <monotonom> What Smerdyakov says amounts to arguing that CS and math sometimes use the same method for some tasks.  This is no evidence for claiming they study the same topics.
10:07:15 <musasabi> Smerdyakov: so how would you simulate *large* queue network or probablistic algorithms in an exact sense.
10:07:34 <Smerdyakov> monotonom, right, right, it's the underlying methodology that really unites a field that has apparently separate subfields.
10:07:57 <musasabi> Smerdyakov: or even do analysis that takes cache exactly into account.
10:08:01 <Smerdyakov> monotonom, I'm saying you can put CS and math together and get the same kind of methodology compatibility as between fields of what are traditionally called math.
10:08:25 <Smerdyakov> musasabi, I'm not involved with that area, but I'm sure people are working on that.
10:08:42 <monotonom> Physics and chemistry sometimes use the same method for some tasks.  This does not imply they study the same topics.  In fact we know they study very different topics.
10:08:47 <kosmikus> Smerdyakov: I would just say that *some* fields in CS happen to use *mathematical* methodology
10:08:58 <Smerdyakov> Physics and chemistry study the concrete world.
10:09:10 <Smerdyakov> CS and math study abstract structures.
10:09:15 <musasabi> Smerdyakov: my point is that in CS one uses approximations rather than exact calculations.
10:09:19 <monotonom> Oh hell almost all intellectual pursuits study the concrete world.
10:09:33 <wagle> computers are concrete objects..  (*ouch*)
10:09:43 <Smerdyakov> wagle, yup, but CS isn't about physical computers.
10:09:59 <Smerdyakov> musasabi, I don't agree.
10:10:07 <Smerdyakov> musasabi, CS is no more approximation based than math is.
10:10:33 <monotonom> Anyway, homology. Until I see someone telling me what that corresponds to, I am not convinced.  If your argument works so well, show me it works for homology.
10:11:00 <Smerdyakov> monotonom, I _told_ you. Studying homology involves learning to write programs in a particular language.
10:11:01 <kosmikus> musasabi: here, I agree with Smerdyakov; both CS and mathemtics use approximations for some things, but not for all ...
10:11:07 <musasabi> Smerdyakov: well let me formulate it in an another fashion. One is forced to use approximation much more commonly in CS than in math research.
10:11:22 <musasabi> of course there are exact things in CS, and numerical methods in maths.
10:11:29 <wagle> mathematics is mostly about what goes on in the heads of mathematicians..  thought that is influences by what they experience physically
10:11:37 <kosmikus> Smerdyakov: would you say that any formal language is a programming language?
10:11:41 <Smerdyakov> wagle, same for the foundations of CS
10:12:00 <Smerdyakov> kosmikus, any language of propositions and proofs used by mathematicians is, yes.
10:12:08 <wagle> computer science is much more about what goes on in a computer
10:12:23 <Smerdyakov> wagle, an _idealized_ computer, as math may study what goes on in _idealized_ physical systems.
10:12:50 <Smerdyakov> wagle, the whole branch of analysis is based on studying idealizations of physics!
10:13:08 <kosmikus> Smerdyakov: usually, if you write a program, you don't have to write the proof for the program, too; who would use Haskell without type inference
10:13:37 <kosmikus> furthermore, for most programming languages, the underlying logic is constructive, an approach that is not at all common in mathematics
10:13:52 <Smerdyakov> kosmikus, you get classical logic from constructive logic by allowing use of continuations.
10:14:37 <musasabi> reallife type systems don't capture everything about program semantics.
10:14:37 <wagle> Smerdyakov: i do both operating systems and programming languages, so my head contains both an engineer and a mathematician
10:14:42 <Smerdyakov> You really just need to add an additional library function to get classical math.
10:14:51 <Smerdyakov> musasabi, so?
10:15:34 <musasabi> Smerdyakov: so typeanalysing a program does not equate a proof of all the program semantics.
10:15:42 <Smerdyakov> musasabi, did I say it did?
10:16:03 <musasabi> Smerdyakov: no
10:16:12 <musasabi> (of course it can be a proof that the program is well-typed)
10:16:32 <Smerdyakov> And it happens that proofs that Haskell programs are well-typed are isomorphic with the proofs used in all of mathematics!
10:17:09 <wagle> the test of a computer program is whether it actually runs on a physical device.  the test of a mathematical object (proof, theorem, etc) is its aesthetics
10:17:31 <sysfault> you guys are too smart.
10:17:41 <Smerdyakov> wagle, I don't agree. Both are judged on utility for particular situations. Often the utility measure is abstracted behind other criteria.
10:18:01 <monotonom> Are computer graphics and database the "same" topic?  According to Smerdyakov's argument, each uses a certain programming language to achieve something, therefore they are the same topic.
10:18:05 <musasabi> my point was that even though one can prove programs to be well typed, it is in general impossible to prove that they are well-behaved (halting problem)
10:18:23 <wagle> i've seen non-logician mathematician complain that the logician's world view that everything is logic is ugly and wrong
10:18:41 <Smerdyakov> musasabi, no, since you can limit the allowable programs.
10:18:50 <wagle> Smerdyakov: i guess it depends on which community in computer science you are in
10:18:52 <Smerdyakov> wagle, they are confused. :)
10:19:01 <kosmikus> wagle: logic doesn't even count as mathematics in some universities ;)
10:19:16 <Smerdyakov> monotonom, no! CS and math are _broad_ approaches to problem solving. The areas you name are areas to which these approaches are applied.
10:19:33 <monotonom> How broad is broad?
10:19:43 <musasabi> Smerdyakov: of course but those languages are quite limited and thus specialized.
10:19:57 <Smerdyakov> monotonom, broad in a sense where they are particular to human cognitive capabilities but little else.
10:19:58 <wagle> i think the programming languages group here would agree, and the operating systems group would disagree
10:19:59 <monotonom> Also I don't define CS or math the way you define as approaches to problem solving.
10:20:47 <Smerdyakov> monotonom, I'm talking about what one has to learn to become an expert in these fields.
10:20:49 <musasabi> CS and math are interested in different problems but use much common methology.
10:20:56 <Smerdyakov> monotonom, the skills are the same in both cases.
10:21:00 <Marvin--> "physicists think they are mathematicians, mathematicians think they are logicians, and ..."
10:21:49 <monotonom> Oh hell I use the same skill --- even the same brain --- to do CS, math, physics, chemistry, politics, philosophy, theology, and astrology.
10:22:04 <Smerdyakov> Nuh uh!
10:22:22 <monotonom> Well *I* do.  If you don't, that's your limitation.
10:22:22 <Marvin--> monotonom: that's what I said, X = Y.
10:22:31 <Marvin--> Now let's drop it, this is way off topic :(
10:23:26 <monotonom> musasabi's last statement is my sentiment and IMO a fair statement.
10:23:36 <kosmikus> hey, we're having a friendly discussion here -- I don't see why it wouldn't have a place on #haskell
10:23:44 <Marvin--> I never saw if Igloo replied, dammit :)
10:23:49 * Marvin-- digs through scrollback
10:24:34 <Igloo> I didn't
10:24:44 <Marvin--> that'd explain it :)
10:25:13 * Marvin-- will have to discuss this with Koen on Friday
10:25:20 <Smerdyakov> I have to go now, but I will make one final statement: I agree with musasabi, and I think we should keep in mind why separate academic fields are maintained in the first place.
10:25:21 <Igloo> Your explanation of what your stuff really does wasn't clear enough for me to be able to answer your ponderings
10:25:38 <Smerdyakov> I say that it is so it is easy to narrow down the set of approaches that are likely to help solve a given problem.
10:25:39 <Marvin--> Igloo: hm.
10:25:58 <Smerdyakov> CS and math use fundamentally identical approaches, so pragmatically they ought to be considered the same field.
10:26:13 <Smerdyakov> Avoids duplication of effort, etc..
10:26:15 <Igloo> Although I wasn't paying that much attention as I'm thinking about something else right now
10:26:49 <Marvin--> Igloo: OK, I don't want to waste your time, I have better things to do myself, too :)
10:26:51 <Igloo> (if anyone know a good thing to read on showing something has principal types I'm interested  :-)  )
10:27:05 <Smerdyakov> Igloo, Definition of Standard ML? ;)
10:27:28 <wagle> Smerdyakov: some CS and some math ...
10:27:39 <Igloo> That doesn't sound like the sort of thing that ought to have a proof of principal types in it?
10:28:37 <Marvin--> are you talking typed lambda calculus, here?
10:29:09 <Igloo> Something like that, yeah
10:29:28 <Marvin--> you want to prove that a certain term M has a principal type?
10:29:51 <Igloo> Smerdyakov: Am I wrong?
10:30:05 <Igloo> I want to know that all typable terms have a principal type
10:30:27 <Marvin--> so a soundness proof?
10:30:58 <Igloo> Ermmm, I'm not sure I'd call it that, but maybe
10:31:42 <Marvin--> er, wait a sec, what's the exact definition of typable anyway?
10:32:19 <Igloo> e is typable if   exists t . \Gamma |- e ==> e :: t
10:32:19 <kosmikus> no, soundness is usually something different
10:33:13 <Marvin--> and the principal type is the most general type of a term, right?
10:33:22 <Igloo> I want a proof that    exists t . \Gamma |- e ==> e :: t and forall u . \Gamma |- e ==> e :: u, t <= u   for all typable e
10:33:31 * sysfault plans on learning c, and haskell only.
10:33:33 <Igloo> Yup
10:33:42 * sysfault wonders which he should learn first, any suggestions?
10:35:38 <Marvin--> sysfault: since they are so fundamentally different either order will involve a paradigm shift *shrug*
10:35:59 <kosmikus> Igloo: for what kind of type system do you want to have such a proof?
10:36:02 <sysfault> why not at the same time eh? :)
10:36:05 <musasabi> Igloo: that depends on the definition of "t <= u" no?
10:37:10 <Marvin--> sysfault: but why C? What low-level stuff are you going to be hacking?
10:37:32 <Igloo> kosmikus: Something resembling Haskell, or some sort of soft type system (well, or both  :-)  )
10:38:02 <musasabi> Igloo: well the subtyping rules are the crucial ones. they will decide whether that holds. iirc
10:38:03 <kosmikus> for classic Hindley-Milner it is relatively simple to prove, I think ... have you checked Pierce's book?
10:38:05 <Igloo> musasabi: Yes, and ==>, and ::  :-)
10:38:06 <XTL> Marvin--: Why, Haskell bindings to C libraries, of course :)
10:38:31 <Igloo> It didn't seem to say much in the obvious place
10:38:35 <Marvin--> Igloo: yeah, I'm not quite sure what kind of judgements you're using here :)
10:38:36 * Igloo checks again
10:38:37 <kosmikus> I don't have it available right now, but I remember that it had something on principal types ...
10:38:42 <musasabi> Igloo: no, one can do subtyping in many wrong ways.
10:39:01 <Igloo> Marvin: Pretending they're Haskellish ones will do
10:39:22 <kosmikus> ... oh, wait, I *do* have it available here ...
10:40:47 <Marvin--> doesn't Hindley-Milner inference automagically give you a principal type?
10:41:20 <kosmikus> Marvin--: yes, it does, but you still have to prove that, of course ...
10:41:26 <Igloo> It says "Proof: By the definition of a solution for (Gamma, t, S, C) and the properties of unification". I was hoping for something a bit more structured, although maybe it just is extremely simple for such a type system
10:41:28 <Marvin--> point
10:41:49 <kosmikus> The "Notes" in that chapter have a few references ...
10:43:26 * Igloo only sees one, and that to something on principal typings...am I being blind?
10:43:36 <kosmikus> first paragraph?
10:44:13 <Igloo> Aha, yes, I am  :-)
10:44:14 <Igloo> Thanks
10:44:50 * kosmikus has to leave ...
10:44:51 <kosmikus> bye
10:45:25 <musasabi> "Principal type schemes for functional programs" by Damas & Milner has the proof afaik
10:46:19 <musasabi> my book just says that it can be prooved after the algorithm and gives the reference :-(
10:47:00 * Igloo heads up to the library - thanks all
11:20:33 <Marvin--> argh
11:20:36 * Marvin-- is stuck *again*
11:26:11 <esap> Hmm.. In arbitrary-precision rational arithmetic, how do I interpret INF/2 ?
11:29:13 <wagle> where do you get that value?
11:29:35 <esap> it's one possible result in my division algorithm
11:30:34 <wagle> 1/0 in ghci is Infinity, and 1/0/2 is Infinity
11:31:28 <esap> Well I'm trying to build the arithmetic from scratch, not using any existing arithmetic as basis.
11:33:21 <esap> and it's then obvious that I need INF as the result of '1/0', but then I also get separate representations for '(1/0)/2'. And I'm not sure I should reduce all of them to INF.
11:33:22 <wagle> well, there are IEEE standards for arithmetic
11:34:03 <wagle> if you are reducing rationals (eg, 2/4 to 1/2), then i would imagine inf/2 reduces to inf/1 and hence to inf
11:35:21 <wagle> both ghci and chez scheme reduce inf/2 to inf as far as i can tell, and both are paying attention to standards, i'm sure
11:35:44 <wagle> .. oops
11:36:20 <esap> hmm.. I define the reduction in terms of gcd, which is defined in terms of subtraction. So of course, I need to then understand how subtraction works for it.
11:36:23 <wagle> chez scheme appears to not want to represent 1/0 in exact numbers, only in inexact (floating point)
11:38:44 <wagle> also chez returns +inf.0 as the result of (/ 1 0.0) and (/ 2 0.0)
11:39:01 <esap> inf.0? :-)
11:39:06 <wagle> i'm using chez scheme since I trust Kent to do it well
11:39:24 <wagle> i dunno what the .0 is
11:40:01 <wagle> but Kent would have put it there for a good reason..  perhaps there are different values of infinity
11:40:12 <esap> I guess it distinguishes between float and integer INFs
11:46:55 <wagle> chez scheme manual just says that "IEEE infinities print as +inf.0 or -inf.0" [paraphrase]
11:47:26 <wagle> i see no reference to other kinds of infinity
11:52:39 <wagle> is there a reason you want to make INF a value in exact integer ratios?
11:53:02 <esap> yes, symmetry.
11:53:21 <wagle> symmetry?
11:54:42 <esap> my current division algorithm is like this: div_nat a b | is_zero a = ZeroRat  | is_zero b = InfRat | otherwise = foldZ one_rat pos_div neg_div (subtractZ a b) where { pos_div x = SuccRat (div_nat x b) ; neg_div y = FracRat (div_nat a (gr y)) (div_nat b (gr y)) ; gr = gcd_nat_nonzero a }
11:54:46 * wagle tries to recall his abstract algebra text's chapters on rings and fields
11:55:22 <wagle> what is 0 / 0?
11:55:30 <esap> zero
11:55:35 <Cale> no
11:55:39 <Cale> it's undefined
11:55:47 <Cale> So is anything over 0
11:55:55 <Marvin--> wagle: rings and fields don't deal with it, there's no 0^-1
11:56:23 <Cale> If you want infinities in your field, then you're going to need infinitesimals as well.
11:56:30 <Marvin--> right
11:57:22 <wagle> Marvin--: herstein doesn't state it that clearly
11:57:27 <Cale> If you're really interested in doing that, you might look into the hyperreals, or the surreal numbers. I can imagine that there will be cases where things will become impossible to compute directly though.
11:57:27 <wagle> hmm
11:57:53 <esap> I've looked at surreals but not hyperreals.
11:57:57 <wagle> someone build a toolkit for the surreals..
11:58:10 <wagle> non-standard analysis
11:58:37 <wagle> i keep meaning to get a round tuit for goldblatt's book
11:59:01 <Cale> Hyperreals are essentially sequences of real numbers, modded out by the relation that we consider two sequences equivalent if we can ignore any finite number of positions, and they are equal on the rest.
11:59:58 <esap> That kind of equivalence might be hard to compute.
12:01:14 <wagle> what are p-adic numbers?
12:01:17 <Cale> for instance, (1,2,3,4,5,6,...) is larger than any n = (n,n,n,n,n,...)
12:01:43 <Cale> and (1, 1/2, 1/3, 1/4, ...) is smaller than any 1/n but greater than 0.
12:02:07 <wagle> (that definition sounds similar to the definition of p-adic numbers i heard)
12:02:46 <wagle> ideals in the powerset lattice?
12:03:12 <wagle> (filters?  i always get them switched)
12:03:26 <Marvin--> hah! Take that you filthy English bastards! :-)
12:03:51 <Cale> The hyperreal construction is an ultraproduct of copies of the reals, using the Frechet filter.
12:04:31 * esap has a model theory book that deals with ultraproducts and filters and ideals, but I never understood very much about it.
12:07:44 <Cale> Basically, the ultraproduct of a set of objects S with respect to some ultrafilter U, is the Cartesian product of the elements of S, modded out by the equivalence relation that two things are equal if they are equal on a set of indices that is in U.
12:09:07 <esap> oh, that's much better description of it than what the book says :-)
12:09:53 <maihem> Sometimes I wish I'd studied maths :)
12:10:03 <Cale> (you'll want to look up ultrafilter, of course -- I don't think I can give a very intuitive description of it, other than it's a filter which is maximal, which means that it contains "about half" the sets)
12:10:34 <Cale> for any subset of the indices, either it, or its complement is in the ultrafilter.
12:11:03 <Cale> The FrÃ©chet filter on S is the one containing all cofinite subsets of S.
12:12:45 * maihem collapses after rapid capital swelling followed by sudden release of energy
12:15:02 <esap> What are ultraproducts useful for? (other than hyperreals?)
12:17:09 <esap> the book states "The definition of ultraproduct is natural and, in short, easy to digest". And I didn't understand anything the writer tried to say to define it :-)
12:17:51 <esap> I guess that definition works well if you already know what it is :-)
12:18:59 * esap is referring to "Poizat: A course in model theory".
13:25:37 <Marvin--> I really should think of a less pretentious title for this stupid report
13:25:53 <Smerdyakov> What's your current title?
13:26:15 <Marvin--> "Proving and Disproving Correctness of Functional Programs -- A First Order Axiomatization of Haskell"
13:26:20 <Marvin--> pretty pretentious, huh? :)
13:26:26 <stepcut> sweet!
13:26:41 <Smerdyakov> Why not "Correctness proofs for Haskell programs"?
13:27:05 <Smerdyakov> I like my advisor's PhD thesis title: "Compiling with Proofs"
13:27:10 <Smerdyakov> Short, sweet, and to the point. :)
13:27:29 <Marvin--> because it's more about disproving than proving, really
13:27:46 <earthy> marvin--: can I see?
13:28:16 <earthy> (and what about: `Proving Haskell programs incorrect' ?)
13:28:23 <Smerdyakov> Marvin--, "Formal reasoning about correctness of Haskell programs"?
13:28:41 <Marvin--> the report is about a FOL axiomatization of a subset of Haskell and two applications of it - one a quickcheck like thingy and one more like a proof assistant
13:29:00 <Marvin--> earthy: ... it's not finished yet, there's so much text in it that still sucks... :)
13:29:09 <earthy> ;)
13:30:17 <stepcut> how about: "Your program is full of bugs, chump!"
13:30:26 <Marvin--> maybe I'll let you guys have at it after I cover up the worst discrepancies Koen finds on Friday
13:30:34 <earthy> :)
13:30:42 <Marvin--> stepcut: I like it :P
13:32:08 <Smerdyakov> Marvin--, why don't you call it "Harry Potter 8"?
13:33:25 <Marvin--> hahaha
13:34:08 <monotonom> "Curry-Howard isomorphism in the special case of FOL"
13:34:42 <monotonom> "Unifying theories for functional programming"
13:35:12 <Marvin--> forget I asked :P
15:26:47 <Ahkron> Hi everyone. I'm new to Haskell, so don't laugh :)
15:27:00 <Ahkron> How do you strip off the IO status of something
15:27:02 <Ahkron> ?
15:27:21 <Smerdyakov> You can't.
15:27:24 <Smerdyakov> This is intentional.
15:27:36 <Smerdyakov> If you could, Haskell would no longer be a pure functional language.
15:27:58 <Ahkron> So I function thats a -> b -> IO b can't be recursable? :\
15:28:23 <Smerdyakov> No, it can.
15:28:30 <Smerdyakov> Have you read about monads?
15:28:45 <Ahkron> I've tried. Don't understand them at all :(
15:29:18 <Ahkron> Got any really good references for them?
15:29:42 <Smerdyakov> No, but I'm sure someone here does.
15:32:08 <Igloo> If f has type a -> b -> IO b   then in   do z <- f x y; g z   z has type b. Does that help?
15:32:38 * Igloo can't give better references than the ones on haskell.org under monads
15:33:41 <Ahkron> Ach. Tried reading them ones. :(
15:33:56 <Ahkron> I'm not a functional programmer really, just been forced to use it for some assignment
16:20:19 <Cale> Ahkron: nomaware has a good tutorial
16:20:36 <Cale> http://www.nomaware.com/monads/html/
16:21:22 <Cale> I think that's probably listed on Haskell.org, but read it anyway.
16:22:00 <Cale> Especially have a look at Appendix 1
16:22:54 <Ahkron> Thanks :)
16:23:02 <Ahkron> Got the IO problem sorted now
16:23:31 <Ahkron> Gonna ahve to write a custom state monad though, which I can't say I'm looking forwards too though.
16:23:38 <Ahkron> But I'll worry about that when it comes :D
16:23:47 <Ahkron> Thanks again for your help :D
22:01:38 <shapr> good morning #haskell!
22:03:30 <Jerub> good morning shapr!
22:03:43 <shapr> how's the lovely land down under?
22:04:39 <Jerub> horrible.
22:04:43 <Jerub> I think I need caffeine
22:04:49 <shapr> oh, me too
22:06:50 <Jerub> yeah, I'm trying to get off it.
22:07:00 <shapr> off of caffeine?
22:07:04 <Jerub> yeah.
22:07:13 <shapr> man, I don't think I'd survive
22:07:16 <Jerub> I've been on one a day for about fortnight.
22:07:22 <shapr> yay, HaskellDB 0.7 !
22:12:42 <Jerub> the web design there stinks.
22:12:46 <shapr> where?
22:12:57 <Jerub> haskell.org/HaskellDB/
22:13:09 <shapr> well, check out haskelldb.sf.net
22:14:04 <Jerub> haskell.org/haskellDB/ rather
22:16:06 * shapr builds haskelldb 0.7
22:19:59 <Jerub> is haskelldb a persitence engine in itself?
22:20:23 <shapr> nah, it's a lovely in-haskell representation of relational algebra
22:20:36 <shapr> making the world safe for database users everywhere
22:21:31 <Jerub> okay, and it generates SQL at the backend?
22:21:44 <shapr> yup
22:22:49 <shapr> did you see my haskell mailing list searchy that uses HaskellDB/
22:36:07 <Jerub> nope.
