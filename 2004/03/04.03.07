00:55:28 * Marvin-- suddenly wants to play Illuminati
03:02:50 * Cale is away: sleep.
03:32:14 <shapr> yow! good morning #haskell!
03:34:13 <Marvin--> bleagh
03:34:29 <shapr> that much excitement?
03:34:51 <Marvin--> I have an exam tomorrow and a sore throat today
03:34:54 * Marvin-- is feeling lousy
03:35:44 <shapr> well, I hope you feel better tomorrow.
03:39:08 <liiwi> tea and honey
03:43:54 <shapr> is haskell.org down?
03:44:58 <Heffalump> seems like it
03:45:08 <shapr> ok, wondering if it was just me
04:10:13 <shapr> I really like this Okasaki review on slashdot.org
04:10:25 <shapr> I'm surprised at the number of FP supporters in the comments
04:10:50 <shapr> maybe we'll really hit mainstream sometime soon.
04:11:23 <shapr> maybe we already are :-)
04:15:15 <ham[mel]> hidiho
04:18:21 <shapr> hi ham
04:20:43 <shapr> greetz Matt-W
04:20:51 <shapr> anything exciting going on today guys?
04:21:12 <Matt-W> not really
04:21:52 <Matt-W> I was wanting to plug my man-page writing library into Haddock, but I can't make head nor tail of how to do it :-(
04:22:47 <shapr> did you check out the semi-functional DocBook writer in Haddock?
04:24:18 <shapr> hi maihem 
04:24:22 <Matt-W> no, I figured that would probably be the best thing to hack at though
04:24:58 <shapr> I learned a bit about the internals of Haddock when I was trying to pull out a 'search by type sig' utility
04:25:06 <shapr> but I never finished that utility, sadly.
04:25:44 <shapr> do you have any specific questions?
04:26:31 <Matt-W> not at the moment
04:26:40 <Matt-W> unless you consider 'what????' to be specific
04:26:54 * shapr grins
04:27:21 <shapr> how would you pull manpage info out of a haskell program?
04:27:25 <Lemmih> is haskell.org down?
04:27:32 <Matt-W> I find Haskell pretty hard to read unfortunately
04:27:37 <shapr> Lemmih: I thin kso
04:27:41 <Matt-W> But then I used to have serious trouble reading Perl, and I got used to that
04:27:49 <shapr> hei kig
04:27:53 <kig> hi
04:27:59 <shapr> looking for Haskell info?
04:28:28 <kig> i guess. i was going to come here and acquire info through lurking
04:28:38 <shapr> ah, ok, I won't bother you then :-)
04:28:45 <Matt-W> mmmm, learning by diffusion
04:29:14 * Marvin-- ponders learning by drinking coffee
04:29:19 <shapr> Matt-W: I had trouble reading Haddock, it's not the most cleanly written imho
04:29:33 <shapr> I think it could be greatly refactored
04:29:37 <shapr> the mainloop is completely scary
04:30:37 <shapr> on the good side, the interface information is 'sold separately'
04:30:42 <Matt-W> heh
04:30:48 <Matt-W> yes, the mail loop is frightening
04:30:51 <Matt-W> main*
04:30:55 <shapr> you can dump out interface descriptions and use that elsewhere
04:31:25 <shapr> you could clean up that mainloop, I'm sure Simon wouldn't mind
04:31:44 <shapr> I got partway into doing that before getting distracted into something else
04:33:20 <shapr> if all of the options were stuffed into a record, it'd be a lot easier to read.
04:33:56 <shapr> of course, Haddock does work, and that's something I aspire to for most of my code.
04:35:17 <Matt-W> heh
04:35:18 <Matt-W> yeah
04:35:29 <Heffalump> hmm, is there any nice way to do a monadic fold over a finitemap, without first converting it to a list?
04:35:35 <Matt-W> I'm not sure I know enough Haskell to do anything to the internals of Haddock anyway
04:35:45 <Matt-W> I have a very shaky understanding of records, and no idea at all what newtype does
04:35:56 <Heffalump> you can read newtype as data
04:36:09 <Heffalump> it has some subtle differences, but none that are particularly important normally
04:36:11 <shapr> well, the best way to learn is to try to do something.
04:36:21 <shapr> and then ask a bunch of questions here.
04:36:33 <Matt-W> heh, maybe
04:36:49 <shapr> Heffalump introduced me to both records and newtype not so long ago :-)
04:36:50 <Matt-W> but if newtype and data are so similar, why have both?
04:37:06 <Matt-W> I understand why you have records, although I'm a bit shaky on how to use them at the moment
04:37:11 <Heffalump> matt-w: newtype is more efficient to implement
04:37:14 <Matt-W> wish I'd known about them when I was doing my dissertation though
04:37:23 <Heffalump> (but more restricted in its use, and has different strictness properties)
04:37:39 <Heffalump> what was your dissertation on?
04:38:26 <Matt-W> I wrote a compiler
04:38:34 <Matt-W> well, more of a translator really since the object language was C
04:38:41 <Heffalump> that's still compilation
04:38:42 <Matt-W> it didn't actually produce runnable output
04:38:43 <Heffalump> what from?
04:38:50 <Matt-W> Triangle
04:38:58 <Matt-W> a rather disgusting language
04:39:07 <Heffalump> was gmh your supervisor?
04:39:08 <shapr> did it have any neat features?
04:39:11 <Matt-W> I believe it was invented for a compiler design textbook
04:39:15 <Matt-W> Heffalump: yeah
04:39:51 <Matt-W> It was a good dissertation though, it let me play with lots of Haskell and write bad things about Java
04:39:59 * shapr laughs
04:39:59 <Matt-W> And I'm always keen to do that :-)
04:52:00 <shapr> does anyone have a win32 GHC hanging around?
04:52:10 <shapr> haskell.org is down and I'd like to try GHC on wine
04:54:56 <ibid> somebody should write a windows program called bread
04:55:05 <ibid> then we could have bread on wine
04:55:32 <shapr> if they ever stop maintaining wine, we could fork the project and call it vinegar
04:56:18 <shapr> I'm going to Port something to Wine. Is that Clare? (er, Claret?)
04:56:39 <maihem> I'm interested in how to control the strictness and memory consumption of haskell programs, I've got a few things, such as let x=foo in bar. But I'm wondering about how I might move it down into the IO monad. The primary thing I care about is producing a certain response in a certain time. If that can be specified in the IO monad (ie, print this at_this_time) it would cause great flexibility along with great simplicity. Ob
04:56:39 <maihem> viously the at_this_time might simply be a priority, ie "I care about the latency of response A more than I do that of response B". Are there any papers on this? What about controlling memory consumtion in the same way, and cpu consumption? This neatly separates the logic and algorithm from the memory use, caches and unclean methods of hinting strictness. So is there anywhere I could look for more info?
04:57:04 <maihem> oh, that was a big message. It didn't feel so big when I was writing it. Sorry :)
04:57:40 <shapr> I'd first suggest you check out Hudak's work on real-time responsiveness with Haskell.
04:57:52 <shapr> He used industrial robots in one of his projects
04:58:32 <maihem> well, I'm more interested in hinting to the haskell compiler that the methods used to store the data should be done to cause the first response to be very quick at the expense of the second response. not really for real-time responses.
04:59:03 <shapr> In my opinion, at this time, space leaks and heap debugging is the hardest obstacle to doing high-quality commercial Haskell.
05:00:38 <maihem> Ie, let the compiler choose to do a calculation strictly and in place to get the first response be quick, but have to repeat it for the second, instead of copying al over the place causing the second to be quick at the expense of the first. and to do that without having to use a particular form in the functions that describe the algorithm
05:03:47 <shapr> have you seen DeepSeq and other ways to force strictness?
05:04:55 <shapr> you can specify strictness in constructors
05:04:58 * shapr tries to think of more
05:08:02 <maihem> I haven't seen deepseq, but I don't want to alter a program for every different size of computer like I do with C. I want to specify the algorithm, and tell the compiler my requirements for the impact of the program on the rest of the world in one place (possibly the IO monad). then a sufficiently sophisticated compiler can decide what needs to be strict, and what needs to be done in place, and what needs to be cached.
05:08:28 <maihem> of course, some of this may be impossible :(
05:08:58 <shapr> I would point you to DeepSeq on the HaskellWiki, but haskell.org is down at the moment.
05:09:10 <maihem> I'll make a note of that, thx
05:09:18 <Heffalump> is their haddock documentation for the hierarchical libraries anywhere useful other than haskell.org?
05:09:20 <Heffalump> s/their/there/
05:10:20 <shapr> hey isomer 
05:10:46 <shapr> maihem: http://users.aber.ac.uk/afc/stricthaskell.html
05:11:03 <shapr> Heffalump: if you specifically mean online, not that I know of
05:11:24 <shapr> If you need something right now, I can point you to the Haddocks on my desktop
05:11:49 <Marvin--> Heffalump: apt-get install ghc6-doc?
05:11:49 <Heffalump> oh, is it in the Debian package?
05:11:54 <Heffalump> doh :-)
05:12:09 <shapr> yup
05:13:34 <isomer> morgen shapr
05:13:54 <shapr> bonjour isomer 
05:31:29 <Heffalump> can anyone explain the compiler error in my code? You can get it with darcs get http://urchin.earth.li/~ganesh/temp/cvs2darcs/
05:33:09 <shapr> I get "can't find GHC.Posix"
05:33:17 <Heffalump> yeah, I just realised that
05:33:18 <shapr> didn't that get moved to -package posix?
05:33:23 <Heffalump> that wasn't the erorr I meant.
05:33:48 <Heffalump> umm. I can't find it.
05:34:08 <Heffalump> oh, I was using ghc5 on urchin. Hmmm.
05:34:26 <Heffalump> perhaps I should just give up on porting the Perl to Haskell :-)
05:34:38 <shapr> it's System.Posix with ghc6
05:34:54 <shapr> personally, I think it's a worthwhile project
05:35:50 <Heffalump> oh great, change GHC.Posix to System.Posix and then you get lots of namespace collisions
05:36:34 <shapr> the regular file thingy is pretty simple, I've fixed it in lambdabot
05:36:52 <shapr> I think it's now a function named regularFile
05:36:54 * shapr checks that
05:38:03 <shapr> ah, isRegularFile
05:38:53 <Heffalump> umm, that's not a FileMode
05:38:55 <Heffalump> it's a boolean test
05:39:40 <shapr> whoops
05:41:11 <Heffalump> ah, it's an FDType we want.
05:43:52 <Heffalump> darcs get http://munchkin.earth.li/~ganesh/temp/cvs2darcs/
05:44:09 <Heffalump> that should compile with ghc 6.2, up till the actual error I need help with :-)
05:44:23 <shapr> pull gave me nothing new
05:44:28 <Heffalump> different URL
05:44:33 <shapr> oh
05:44:34 <Heffalump> s/urchin/munchkin/
05:44:56 <shapr> that's why you said get... I should read better next time ;-)
05:44:57 <Heffalump> [make sure you throw these repositories away once we're done, cos I'm going to unrecord those patches]
05:45:04 <Heffalump> well, s/get/pull/ would work too
05:45:08 <Heffalump> and be more sensible really.
05:45:33 <shapr> seems empty?
05:45:57 <Heffalump> can darcs follow redirects?
05:46:05 <shapr> I don't know
05:46:06 <Heffalump> if not, s/munchkin.earth.li/munchkin.comlab.ox.ac.uk:81/
05:46:17 <shapr> ok
05:47:00 <shapr> IORef error?
05:47:03 <Heffalump> yep.
05:47:11 <Heffalump> I just don't get it. I'm probably being dozey.
05:49:38 <shapr> it looks to me like patchset has a different type inferred somewhere else
05:49:55 <shapr> the inferred type in the error message is correct for newIORef
05:50:00 <shapr> but the expected type is different
05:50:08 <Heffalump> oh, hmm.
05:50:17 <shapr> newIORef :: a -> IO (IORef a) -- from the Haddocks
05:50:24 <shapr>     Couldn't match `(->) (IO t)' against `IO'
05:50:24 <shapr>         Expected type: IO t -> t1
05:50:24 <shapr>         Inferred type: IO (GHC.IOBase.IORef a)
05:50:31 <shapr> from 'make'
05:51:09 <Heffalump> but if you comment out the code from just below it up to the line before putStr "\n", it still gives that error.
05:52:23 <Heffalump> ohh.
05:52:26 <shapr> ?
05:52:28 <Heffalump> nope.
05:52:31 * Heffalump changes his mind
05:52:43 <shapr> what's the expected type of patchset? IORef Int ?
05:52:53 <Heffalump> I think so
05:52:56 <Heffalump> or IORef Integer
05:56:06 <shapr> it gives the same error for rootbranch
05:56:31 <Heffalump> I think some odd type is being inferred for the do block.
05:57:59 <shapr> is it possible there's some shadowing going on?
05:59:03 * Heffalump finds it
05:59:12 <Heffalump> I had the wrong arguments to the function in foldFM
05:59:14 <shapr> what is it?
05:59:21 <shapr> oh
05:59:33 <shapr> very confusing error
05:59:49 <Heffalump> yep.
05:59:53 <Heffalump> thanks
06:00:07 <shapr> glad I could be a cardboard analyst :-)
06:19:05 <Heffalump> bah.
06:19:07 <shapr> ?
06:19:11 <Heffalump> Fail: Text.Regex.Posix.regcomp: error in pattern
06:19:20 <Heffalump> not the most helpful of error messages...
06:19:23 <shapr> truly
06:19:36 <Marvin--> heh
06:24:16 * Heffalump fumes
06:25:49 <shapr> geez, looking at code I wrote several years ago makes me ill.
06:26:10 <andersca> yeah
06:26:30 <Marvin--> join the club
06:37:52 * shapr happily plays with HaskellDB
06:59:09 <shapr> hi tooki 
06:59:12 <tooki> joho
06:59:18 <shapr> how's code?
06:59:31 <tooki> pretty fine
07:00:31 <tooki> i tried to compile my sort-function, and it executed faster, but c is still about 100 teims faster
07:01:00 <tooki> or only 10 times faster
07:01:16 <shapr> execution is not the only cost of developing software.
07:01:39 <shapr> in my experience, programmer time is one of the most expensive parts
07:01:56 <shapr> so in many cases, Haskell is good because you can write a program in less time
07:01:59 <tooki> yes, i exported non-time-critical parts of my project to hasekll ;)
07:02:12 <shapr> if you want to write device drivers, C is faster.
07:02:35 <Riastradh> (Bah!  Use Pre-Scheme!)
07:02:39 <tooki> i wrote a SAT-solver, and this has to be as fast as possible
07:02:51 <shapr> I haven't written any time-critical software yet, so I haven't needed to bind to C
07:02:52 <_Codex> ocaml is supposed to be about the same as C for performance...
07:02:53 <shapr> SAT?
07:03:07 <shapr> _Codex: but, is it the same as Haskell for programmer performance? ;-)
07:03:08 <Heffalump> satisfiability of boolean formulae
07:03:11 <shapr> of
07:03:12 <shapr> oh
07:03:42 <_Codex> shapr: dunno - the concepts in ocaml are pretty similar to haskell ones.
07:04:15 <tooki> or maybe i should write my own super-boombastic haskell-compiler first ;)
07:04:23 <shapr> well, Haskell is pure, and ocaml isn't
07:04:31 <_Codex> I mean, ocaml also uses pattern matching as the main tool to write programs.
07:05:09 <shapr> At first glance, I'd say monads are the main tool in Haskell.
07:05:21 <shapr> but it's hard to find any one "main tool" in Haskell
07:06:25 <shapr> Ocaml and Haskell do have algebraic datatypes in common.
07:07:01 <shapr> OCaml doesn't have referential transparency, typeclasses, what else?
07:07:18 <esap> Ocaml has OO.
07:07:23 <shapr> oh, and OCaml *does* have first class modules, I wish for those in Haskell
07:07:33 <Riastradh> OCaml doesn't have first-class modules, shapr.
07:07:40 <shapr> it doesn't?
07:07:45 <shapr> SML?
07:07:49 <Heffalump> SML doesn't.
07:07:50 <Riastradh> It has parametric, but still _compile-time_, modules.
07:08:00 <Heffalump> I thought O'Caml had dependent records.
07:10:12 <shapr> OCaml doesn't have HaskellDB ;-)
07:11:31 <shapr> tooki: what sort of code are you writing?
07:15:09 <tooki> ??
07:19:19 <tooki> i think i dont need OO, the class-system of haskell should be enough 
07:19:44 <esap> Type classes don't do the same thing as OO.
07:21:42 <Riastradh> But typically it's not an object system (if you can define that well enough to define your needs) you want but rather a generic type dispatch system.
07:22:14 <esap> I think one thing I would want from OO is the ability to define localized resources
07:22:19 <shapr> esap: hey, have you thought about the lack of identity in FP, versus the importance of identity in OO?
07:22:38 <Riastradh> 'Localized resources?'
07:22:59 <esap> riastradh: each object has some resources associated with it [e.g. memory]
07:23:24 <Riastradh> esap, yes...but that's true of any kind of data type.
07:24:03 <shapr> I wish citeseer.nj.nec.com were forwarded to the new url >:-|
07:24:04 <esap> riastradh: the identity of an object represents that resource. That makes objects hard to "move around".
07:24:24 <Riastradh> esap, er, what?
07:24:35 <shapr> I guess I could create a purl for citeseer
07:25:11 <Riastradh> What is it now, shapr?
07:25:29 <shapr> it's in the topic
07:25:33 <shapr> since several people had asked
07:26:24 <tooki> on haskell.org i read about a project for OO-Haskell
07:26:44 <esap> riastradh: well in FP, data doesn't have identity, it's just data. In OO, you can have references to objects, and those fix the location of the object [to the extent that it's represented by the references]
07:27:02 <Riastradh> esap, I still don't see your point here.
07:27:15 <shapr> tooki: if you mean O'Haskell, I don't think it's maintained.
07:27:20 <shapr> would be cool though
07:27:53 <esap> riastradh: My point is, type classes don't really support that kind of concept.
07:28:18 <tooki> i think OO can be emulated with the State-transformer monad
07:28:41 <tooki> inheritance might be a problem
07:28:47 <esap> yes, state monads can be used.
07:29:08 <shapr> inclusional polymorphism is one of the most-used features in OOP, imho
07:29:56 <esap> what do you mean by 'inclusional'?
07:30:17 <_Codex> I think main thing in OO is "grouping of methods", and type classes already gives that.
07:30:39 <shapr> esap: just that a subclass can pose as a superclass
07:30:55 <ibid> the main thing in oo is modelling
07:30:59 <tooki> with the state-monad you can also group you methods with data, as in OOP
07:31:36 <esap> I think the concept of a method is quite hard thing to do.
07:32:05 <esap> Because you need to consider the invariants satisfied by the method.
07:32:36 <tooki> i think functions of the form : f :: ... -> State s a can be thought of as methods for s
07:34:50 <Heffalump> hmm.
07:35:05 <tooki> becaus they work on and modify s
07:35:06 <Heffalump> my Haskell version now works, but is twice as long as the perl, and 3 times as slow.
07:35:12 * Heffalump not impressed.
07:35:27 <tooki> haskell-version of what ?
07:35:45 <Heffalump> a script that parses the output of another program and works stuff out.
07:35:53 <Riastradh> tooki, how would you consider an object system based on multiply-dispatching generic functions?
07:36:06 <andersca> I've always wanted a program that works stuff out
07:36:17 <tooki> sry, i will take me some time to understand 
07:36:25 <tooki> i->it
07:36:55 <tooki> i believe there is a library for parsing, shipped with ghc
07:37:27 <Heffalump> well, this one is using Text.Regex
07:37:27 <tooki> jep and it should work out every kind of stuff in poly-time ;)
07:37:36 <Heffalump> since I was trying to port a perl script over fairly directly
07:37:42 <_Codex> OO is ideal for parsers.
07:38:12 <esap> OO is not ideal for parsers.
07:38:31 <tooki> you should use a parser that uses monads and the list-of-successes-method
07:38:59 <tooki> becaus these ones can also do backtrcking, and are more haskell-like
07:39:28 <tooki> i learned that in the functionalk-prgramming-lesson
07:39:34 * Heffalump has no need of backtracking
07:39:46 <Heffalump> I just wanted to port this perl script.
07:40:22 <tooki> i think you have to do it in another way in haskell
07:40:46 <Heffalump> Haskell really ought to have won this comparison, given it was compiled to native code.
07:41:03 <Heffalump> I'm definitely overusing IORefs, which is the main reason for the length doubling.
07:41:08 <tooki> thats my problem too ;)
07:42:22 <esap> I've often found IORefs too restricted, it's pretty hard to do simple things with them.
07:43:08 <Heffalump> I was literally translating this imperative code.
07:43:27 <tooki> i think to improve your code, you cannot port it directly, you have to do it in the haskell-way ;)
07:44:10 <esap> The design does not improve if you just port the code.
07:44:31 <Heffalump> I'm well aware of that.
07:44:39 <Heffalump> I'm just disappointed that it got so much slower.
07:45:32 <esap> Might also be due to difference in evaluation behaviour between lazy and strict evaluation (?)
07:46:50 <tooki> you might be interrested in that : http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text.ParserCombinators.Parsec.html
07:47:17 <Heffalump> tooki: I'm aware of Haskell parsing technology.
07:47:26 <tooki> did you compile it with -O2 ?
07:47:32 <tooki> ok
07:47:34 <Heffalump> no
07:47:39 <Heffalump> but it's still competing with an interpreter
07:47:57 <tooki> -O2 should do good optimization
07:48:47 * Heffalump still thinks it ought to have beaten the intepreter without optimisation
07:51:04 <Heffalump> hmm, looks like the regex library was to blame
07:52:17 * tooki is testing icq-commands
07:54:13 <tooki> a lib should be more efficient than pure haskell
07:54:35 <Heffalump> well, I guess perl's RE library is better still.
07:55:16 <tooki> i thought perl,sed,c ... all use the same lib
07:56:23 <Heffalump> this one is the egrep library
07:57:05 <tooki> did you compile it with O2 now ?
07:59:33 <Heffalump> there's no point, if most of the time is spent in a C library
07:59:46 <tooki> ok
08:00:24 <tooki> gotta go now, bye folks
08:09:02 <Igloo> If you're mainly comparing [Char] to perl strings perl ought to win easily
08:09:37 <Igloo> And there are currently some issues with the Data.PackedString library. Not sure how many of the functions are affected
08:12:41 <Heffalump> I'm mostly just passing [Char] around, not doing much processing on them
08:12:47 <Heffalump> oh, actually, they're being used as FM keys.
08:13:19 <Heffalump> but anyway, profiling does suggest the time is being mainly spent in the Regex library
08:23:21 <Igloo> But the regexp library is working on [Char] presumably?
08:23:38 <Heffalump> it'll be marshalling into strings
08:23:42 <Heffalump> it's a C library
08:23:49 <Igloo> Ah, right
08:24:22 <Igloo> Haskell is much slower at just reading and writing a large String, anyway
08:24:47 <Heffalump> I guess the time could be wasted in the marshalling.
08:24:58 <Heffalump> is there any good way to improve that?
08:26:17 <Igloo> Reading as a PackedString and converting that might be better
08:26:40 <Heffalump> hmm, I'd have to rewrite the Text.Regex interface then
08:26:42 <Igloo> Or reading directly as the marshalled form if that's possible
08:27:01 <Igloo> Oh, I don't think you can do anything without doing that
08:27:08 <Igloo> Reading the file strictly might make it better
08:27:24 <Heffalump> I'm using hGetLine
08:27:30 <Igloo> Oh
08:28:04 <Igloo> Nothing comes to mind then unless memory usage is high, in which case you might be being too lazy/not lazy enough
08:30:19 <Marvin--> hm, there's no way to directly turn a PackedString into a CString?
08:32:57 <Igloo> You'd have to get from 32bit Chars to 8bit bytes somehow wouldn't you?
08:34:01 <Igloo> Perhaps there is a need for a PackedBytes too?
08:34:13 <Marvin--> eh, you could make the same assumptions that hPutPS/hGetPS
08:34:32 <Igloo> But it would be slow, wouldn't it?
08:34:41 <Igloo> Or did you just mean there's no function to do it?
08:35:00 <Marvin--> I meant that there's no way to do it
08:35:11 <Marvin--> that is, there's no function for it already
09:39:04 * shapr grumbles at python
09:39:14 <shapr> silly language, blanks are for ignoring.
09:40:10 <Igloo> Is there any easy way of having the output of programs I fork/exec go to a subset of the console while there's an untouched line at the top or bottom I can use?
09:41:48 <Marvin--> Igloo: curses can do that, can't it?
09:43:21 <Igloo> I think I'd have to grab stdout/stderr myself which means I'd have to think about buffering etc, but yeah
09:44:02 <Heffalump> shell-haskell provides a nice interface for grabbing the FDs from something you fork and exec
09:44:31 <Igloo> The problem is I don't think I can just get a file handle associated with an ncurses window
09:44:52 <Igloo> I guess it means it's easy to log the output or whatever, so I might want to grab it myself anyway
09:52:20 <shapr> Igloo: ginsu already has a status line at the bottom
09:52:38 <shapr> so you can probably rip it off without too much trouble
09:53:35 <Igloo> Interesting, ta
09:53:52 <Igloo> Is it BSD or GPLed?
09:54:38 <shapr> yes, BSD
09:54:43 <shapr> http://repetae.net/~john/computer/ginsu/
09:55:20 <shapr> which I can't seem to get to at the moment...
09:57:14 <Marvin--> what's ginsu?
09:57:25 <shapr> it's a Gale client by John Meacham
09:57:33 <shapr> it has a bunch of neat features
09:57:48 <shapr> I started using it so I could become familiar enough with the codebase to rip out useful standalone libraries
09:58:01 <Marvin--> what's Gale? :)
09:58:11 <shapr> try google :-P
09:58:21 * Marvin-- is lazy
09:58:38 <Igloo> ITYM "what's google?"  :-)
09:59:04 <Marvin--> I'm lazy, not daft
10:02:48 <Igloo> Hmm, GHC gives -static to gcc on some platforms with no obvious comments as to why
12:57:55 <shapr> and with a snicker snack...
13:00:33 <Marvin--> etc etc
13:00:49 <shapr> He left it dead, and with its head, he went galumphing back.
13:01:07 <Marvin--> I don't know it by heart and I'm too lazy to google for the text
13:02:10 <shapr> Twas brillig and the slithy toves did gyre and gimble in the wabe: all mimsy were the borogoves, and the mome raths outgrabe.
13:03:31 <Riastradh> 'Beware the Jabberwock, my son! -- / The jaws that bite, the claws that catch; / Beware the Jub-jub bird, / And shun the Frumious Bandersnatch!'
13:04:07 <shapr> Marvin--: did you find out about Gale? 
13:04:13 <Marvin--> no
13:04:30 * Marvin-- is trying to decide if he's ill or not
13:06:19 <jlouis> Riastradh: who wrote that one?
13:06:48 * Riastradh snargles at jlouis.
13:06:52 <Marvin--> jlouis: !?
13:07:08 <shapr> o frabjous day! callooh callay!
13:07:11 <Marvin--> uneducated person!
13:07:19 <shapr> jlouis: http://www.jabberwocky.com/carroll/jabber/jabberwocky.html
13:09:01 <jlouis> I remember reading the Jabberwocky, but I did not remember who wrote it
13:09:09 * Marvin-- idly flips through TaPL without being able to concentrate
13:09:31 <shapr> Marvin--: ohh, look at the barendregt cube!
13:09:43 <shapr> I left my copy upstairs or I'd give you the page number
13:10:10 <shapr> oh, I didn't see him, or I would have asked him if he needs help.
13:10:49 <shapr> kig: have you lurked long enough to find questions?
13:13:24 <shapr> jlouis: what's going on with you lately?
13:14:17 <Marvin--> shapr: the lambda cube? Seen it before
13:15:10 <shapr> hm, you could read about System F omega
13:17:50 <Marvin--> which type systems deal with combining subtyping and parametric polymorphism?
13:19:56 <Jerub> wasn't it lewis carol wrote the jabberwocky
13:20:03 <Marvin--> yes
13:20:17 <Heffalump> Lewis Caroll
13:23:52 <kig> oe
13:26:31 <earthy> the barendregt cube is nice
13:26:57 * kig reads a gentle introduction to haskell
13:27:05 <earthy> \-> \2 \weakomega \P \omega \Pweakomega \P2 \C
13:27:43 <earthy> but much easier if seen as combinations of  (*,*) (*,#) (#,*) and (#,#)
13:28:25 <earthy> but I was going to go to bed, not get dragged into interesting lambdacalculus stuff
13:32:01 <LittleDan> Why does inc' x = x+1 make an error in Hugs but not ghc?
13:34:24 <LittleDan> Is anyone here?
13:35:19 <norpan> LittleDan: what's the error?
13:35:35 <LittleDan> ERROR - Syntax error in input (unexpected `=')
13:36:08 <Riastradh> LittleDan, are you running it from the REPL?
13:36:11 <LittleDan> yes
13:36:17 <LittleDan> is there something wrong with that?
13:36:27 <Riastradh> The Hugs REPL accepts expressions only, no declarations.
13:36:31 <LittleDan> oh
13:36:38 <LittleDan> why?
13:37:13 <Marvin--> with ghci you can write   let inc' x = x+1
13:37:31 <LittleDan> what's ghci?
13:37:53 <Marvin--> the interpreter mode of ghc
13:38:58 <Cale> You're expected to put your declarations in a file and load it. Both hugs and ghci make it easy to reload the current source file.
13:39:52 <SamB> haskell isn't imperative at the top level
13:40:15 <LittleDan> I wasn't expecting the variables to be mutable or something
13:41:28 <Cale> using ghci solves the problem if you just want to be able to make up temporary definitions and try them out. Just precede the definition with let and it should work.
13:43:53 <Cale> the difference between hugs and ghci is that hugs is just evaluating expressions, and ghci is (up to possibly adding a "print" to the head of your expression) running the IO monad.
13:44:14 <Cale> so it's like you're inside a do block
13:44:59 <LittleDan> Does let have any other uses in Haskell?
13:45:37 <Riastradh> It ties your shoes, too.
13:46:00 <Marvin--> alas, it doesn't make coffee :(
13:46:30 <LittleDan> Do you use it in monads? (or do you use <- or something?)
13:49:09 <Cale> You use <- to "request" values from computations. Like you might do a <- myRandomIntGenerator to get a random value, while you might just use let a = 5 to locally bind a to the non-monadic value 5.
13:50:07 <Cale> (Given that myRandomIntGenerator would have type IO Int)
13:51:41 <LittleDan> why can't you just use an int within monads? Are they inherently lazy or something?
13:52:41 <Cale> the only distinction here is that while you could go and say "let a = myRandomIntGenerator", what you'd be doing is binding the *generator* to a, and not a value that it outputs.
13:55:24 <Cale> you could also write "a <- return 5", but that seems a bit unwieldy.
13:56:36 <Cale> Conceptually, what that does is to construct a computation that always returns 5, and then pulls a value out of it, binding that to a.
14:01:07 <Cale> make sense?
14:01:29 <LittleDan> Not really, but I'm reading a tutorial on it
14:02:15 <LittleDan> Why is Maybe a monad?
14:02:26 <skew> because it can be
14:02:52 <LittleDan> Don't you want to avoid monads unless you need them?
14:02:53 <Cale> Monads in full generality are just a generalisation of the idea that computations can be sequenced.
14:03:32 <LittleDan> but what does that have to do with maybe?
14:03:36 <jameson> LittleDan: 'Maybe' describes the notion of a computation that may fail.
14:03:49 <LittleDan> I know; what does it have to do with sequencing?
14:03:49 <Cale> You can sequence a bunch of computations that might return a value, and if any one of them fails to return a value, then the sequence fails to return a value.
14:04:32 <kosmikus> ah, monads :)
14:04:52 <jameson> LittleDan: For example, I'm using this monad for looking up a value from an environment (a finite map). If the lookup fails, it returns 'Nothing' and the rest of the computation (which includes another lookup) may be skipped.
14:04:56 <jlouis> are they related to monoids in any way?
14:05:13 <Cale> They're slightly related to monoids.
14:05:22 <jlouis> ok
14:05:37 <skew> how related?
14:05:37 <LittleDan> jameson: So you need a monad to skip computation?
14:05:58 <jameson> jlouis: The 'bind' operation is associative, too... you also have a 'unit' through the 'return'. (IIRC, that is.)
14:06:07 <jameson> LittleDan: No, but that's one way to implement this.
14:06:28 <skew> Oh, right. I was just remembering the canonical example of building a monad from a monoid
14:07:23 <skew> LittleDan: It's not that Maybe only makes sense as a monad.
14:07:25 <Cale> LittleDan: Thinking of Maybe as a monad just makes it a little more convenient to use. Otherwise, you end up with a whole bunch of case constructs when you're chaining things together.
14:07:29 <maihem> jameson: Does that "may fail" mean the function is not defined for some argument or more generally not computable for some argument, or something even more generic?
14:07:53 <skew> LittleDan: Rather, it is possible to write a monad instance, which lets you use all the generic monadic functions
14:08:05 <jameson> Compare "let x = case (lookup k1) of { Nothing -> Nothing ; Just a -> a} in let y = case (lookup k2) of {Nothing -> Nothing ; Just a -> a} in x+y" to...
14:08:25 <jameson> "do {x <- lookup k1; y <- lookup k2; return x+y }"
14:08:43 <jameson> (actually, you'd still have to use the 'Just' constructor in the first example, for 'x+y').
14:08:44 <Cale> maihem: It just means that you have a new value called Nothing.
14:09:00 <jameson> It's just a way to write certain computations in a much more comprehensible fashion.
14:09:10 <jameson> (Recall that \-calculus is already turing complete...)
14:09:21 <Marvin--> jameson: and what you wrote won't type check
14:10:09 <jameson> maihem: The "may fail" here is an explicit failure. You explicitly lift the domain of values you expect, with the new, added element representing 'failure'.
14:10:10 <Marvin--> jameson: you have different types on the case branches
14:10:50 <jameson> OO languages sometimes also do this; they call the lifted value 'null' or 'NULL' or 'nil' or 'void'.
14:11:15 <jameson> Marvin--: You're right.
14:11:35 <jameson> I'd have to nest the cases.
14:11:39 <Marvin--> you'd want case lookup k1 of { Nothing -> Nothing ; Just x -> case lookup ...
14:12:00 <jlouis> Ah, the domain lifting function ;)
14:12:14 <Marvin--> and lookup would normally take two arguments, if it's the standard function, but what the heck ;)
14:12:24 <jameson> case (lookup k1) { Nothign -> Nothing ; Just x -> case (lookup k2) of { Nothing -> Nothing ; Just y -> Just (x+y) } }
14:13:32 <maihem> jameson: so I should still strongly type the domain of the function, and Nothing is a defined result of the application of the function to possibly some arguments?
14:13:58 <jameson> maihem: I'm not entirely sure what you mean, however...
14:14:44 <jameson> Let's consider a function that looks something up in a finite map (assume that the finite has been "curried into" the function already, so we only consider a function with one argument):
14:14:56 <jameson> lookup :: forall a. a -> Int
14:15:05 <SyntaxLaptop> does anyone know how I can pull a particular change from a particular repository in darcs? I know about the -m patch, but I don't see any flags where I can specify the actual repository.
14:15:10 <jameson> THis would guarantee that the function 'lookup' always finds an 'int', for whatever you pass in.
14:15:19 <jameson> Actually, that doesn't make sense...
14:15:34 <jameson> You'd usually want a concrete type in there, which the previous currying would have instantiated; sorry.
14:15:39 <jameson> OK, let's consider an 'Int to Int' map.
14:15:44 <jameson> lookup :: Int -> Int
14:15:56 <jameson> This function promises always to return an 'Int' for whichever 'Int' you pass in.
14:16:20 <jameson> (Unless it doesn't terminate... technically, it's already lifted over nontermination, of course ;-)
14:16:36 <jameson> Now, if you know that you won't always return something, you can say that you 'sometimes' want to return an 'Int'.
14:16:57 <jameson> This is expressed through the types "'a option" (SML) or "Maybe a" (Haskell):
14:17:04 <jameson> lookup :: Int -> Maybe Int
14:17:12 <jameson> ...where "data Maybe a = Just a | Nothing"
14:18:26 <maihem> so instead of defining another function isPresent, and a condition to shortcut, I can just use Maybe. The Maybe can automatically shortcut in the Monad?
14:19:33 <jameson> The part about "shortcutting" is true, but using 'isPresent' won't work if you're dealing with a finite map-- you want to have some way to represent the fact that the value the caller was looking for isn't in your finite map.
14:20:08 <jameson> So, you can have an 'isPresent :: Int -> Boolean', but it won't buy you much.
14:20:45 <jameson> Let's say that your finite Int-to-Int map has the mappings {0 |-> 1, 1 |-> 0}. What are you going to return if someone looks up 2?
14:20:48 <SyntaxLaptop> nm
14:22:43 <maihem> can it be made to take an argument of type (0 | 1)? so you *can't* try to look up 2?
14:24:31 <jameson> maihem: You could describe such a type. But a finite map will allow you to generate its domain at run time, meaning that the type in question would be undecidable in general. This means that this approach doesn't cooperate with the idea of statically typed languages.
14:25:45 <jameson> Consider reading in the finite map from user input (through the IO monad). You absolutely won't know the domain of your map, so you'll want to embed it in a larger type that you do know (such as 'Int -> Int' in the example).
14:26:28 <jameson> Since you know that it's going to be partial, you'll respect the partiality by lifting the type through the 'Maybe' monad.
14:26:31 <maihem> is this why the ST Monad is built in and not implemented in functional code? you couldn't add any thing of a new type to the ST?
14:27:12 <maihem> so the domain of lookup is defined by the previous events during runtime, and Maybe describes that fact?
14:28:09 <jameson> I don't understand the question about the ST monad, sorry. What do you want to add? (I'd guess that it's built in because it's a great hint to the compiler for optimising code in a certain fashion...)
14:28:50 <jameson> maihem: wrt Maybe: I guess you could put it like that.
14:44:28 <LittleDan> What type is ()? Is the type ()?
14:46:09 <Marvin--> ""Armageddon" got some astronomy right. For example, there is an asteroid in the movie, and asteroids do indeed exist. And then there was... um... well, you know... um. Okay, so that was about all they got right."
14:47:40 <maihem> they had stars in the sky
14:50:22 <kosmikus> LittleDan: yes
14:58:42 <SamB> Marvin--: did they think the sun orbited the earth?
15:25:07 <shapr> hi c_monkey 
15:25:12 <shapr> interesting nickname.
15:25:19 <c_monkey> hello
15:25:40 <shapr> is it short for code_monkey?
15:26:21 <c_monkey> well... i no it's more a reference to my being a slave to the c language
15:26:29 <c_monkey> ... not exactly by choice though
15:26:32 <SamB> is that as opposed to AAA monkey?
15:27:17 <c_monkey> i suppose it would be
15:27:34 <shapr> well, this channel is all about breaking the bonds and all that.
15:27:53 <shapr> you, purity, egalite, functionalite
15:28:05 <SamB> you might want to also look into python?
15:28:27 * shapr should really go to sleep
15:28:40 <shapr> c_monkey: interested in functional programming?
15:28:41 <c_monkey> yeah i like python
15:28:46 <shapr> Python is a nice language too.
15:28:55 <Jerub> haskell!
15:28:56 <shapr> I've used Python before.
15:29:03 <shapr> I do prefer Haskell.
15:29:15 <Jerub> shapr: if I were to use a GUI library in haskell, what GUI library would I use?
15:29:20 <shapr> wxHaskell!
15:29:30 <Jerub> really?
15:29:33 <shapr> approved by the king himself, SPJ
15:29:50 <Jerub> I've used wxPython before.
15:30:03 <shapr> c_monkey: so, looking to learn Haskell?
15:30:56 <c_monkey> yes I'm interested
15:31:09 <shapr> greetz deez
15:31:19 <c_monkey> i'm not sure where to start though...
15:31:26 <Jerub> c_monkey: with the tutorial.
15:31:31 <shapr> yes, good place to start.
15:31:39 <shapr> grab the tutorial, read through it once
15:31:45 <shapr> swear mightily, read it again
15:31:49 <shapr> ask lots of questions on #haskell
15:32:01 <shapr> this was just from my personal experience...
15:32:04 <c_monkey> ok that will be my plan
15:32:27 <Jerub> yay1
15:32:32 <Jerub> I like answering questions
15:32:33 <shapr> I think I really started understanding stuff about the fifth time I read the tutorial.
15:32:51 <Jerub> shapr: whats your opinion - should Prelude's map be used in examples first, or should recursion be taught first?
15:33:00 <c_monkey> so what do you guys use haskell for mostly? (what types of apps)
15:33:11 <shapr> I think recursion should be taught first
15:33:31 <shapr> because, nearly everything is a subset of recursion
15:33:56 <shapr> I use Haskell for fun mostly, but I have the occasional opportunity to make money with it.
15:34:02 <kosmikus> me too. I don't like showing things like "map" and "foldr" as magic combinators, as if they were somehow special.
15:34:57 <kosmikus> but introduce "map" early, nevertheless, and ask the students all the time whether a function they've written could be written as a map or a fold or a whatever ;)
15:35:30 <shapr> yes, recursion first, because it's 'lower resolution' but map soon after, because it does so much.
15:36:03 <shapr> c_monkey: lambdabot is written in Haskell, but I killed my server, hopefully I'll fix it tomorrow.
15:36:38 <shapr> @listmodules
15:36:38 <betabot> I have the following modules installed: ["base","dynamic","eval","more"
15:36:38 <betabot> "system"]
15:36:39 <SamB> in #python: <ThomasWaldmann> just in case you are interested: MoinMoin 1.2.1 was released some minutes ago. ;)
15:36:44 <kosmikus> betabot: @reduce
15:36:45 <betabot> Sorry, I don't know the command "reduce", try "lambdabot: @listcommands
15:36:56 <shapr> hrm, it had more modules than that yesterday.
15:37:10 <shapr> SamB: oh, that's good to know
15:37:24 <shapr> I've been thinking of upgrading the Haskell Wiki to 1.2
15:37:25 <kosmikus> what's MoinMoin?
15:37:38 <shapr> it's what the Haskell Wiki uses
15:37:43 <kosmikus> ok
15:37:43 <shapr> but 1.1 right now
15:38:14 <shapr> amusingly, I have my name in the MoinMoin credits... for the partial finnish translation ;-)
15:38:48 <kosmikus> I wish I could use that in my thesis, too: "My brain just exploded."
15:39:01 * shapr grins
15:39:19 <shapr> is that a quote from somewhere?
15:40:28 <shapr> @yow !
15:40:28 <betabot> Did I say I was a sardine?  Or a bus???
15:40:39 <shapr> @dynamic-load ghci
15:40:40 <betabot> couldn't load module GhciModule.o
15:40:42 <shapr> whew
15:41:53 <SamB> kosmikus: you might be able to work it in if you were to mention multi-fire continuations
15:42:27 <shapr> I think implementing 'multi-call' continuations via linear continuations is pretty brain exploding.
15:42:41 <shapr> of course, I think kosmikus' thesis is brain exploding anyway.
15:42:59 <kosmikus> shapr: it's a quote from ghc
15:43:22 <shapr> where? 
15:43:25 <shapr> oh I could grep for it.
15:43:34 <kosmikus> I'm not sure right now.
15:43:39 <kosmikus> used to be several places
15:43:54 <kosmikus> mostly with certain extensions, in cases where Simon didn't know how to implement
15:45:16 <kosmikus> shapr: I'm afraid my thesis will be hard to understand, yes, but I always think it's my fault, because I should find ways to explain it better ...
15:45:40 <shapr> I think programming just has some essential difficulty.
15:46:02 <Jerub> kosmikus: whats the abstract for your thesis?
15:46:08 <np_hard> shapr: foolishness! programming is no different than factory work, just a simple question of scientific management
15:46:10 <np_hard> :)
15:46:15 <kosmikus> Jerub: I don't have one.
15:46:29 <shapr> aha, TcBinds.lhs
15:46:40 <shapr> np_hard: you must have a job writing Java ;-)
15:46:51 <kosmikus> Jerub: it's about Generic Haskell
15:47:02 * np_hard really wishes corporate IT would get it through their head that programmers are closer to architects than to accountants
15:47:09 <np_hard> shapr: how did you guess? :)
15:47:09 <shapr> you know, the black and white packages, half-off at the grocery store.
15:47:27 <np_hard> I had a polite argument with a Java-head at work on friday
15:47:35 <shapr> wow, polite?
15:47:40 <np_hard> I think I may have planted a seed of discontent
15:47:53 <np_hard> when I pointed out that Java's "static typing" is a lie.
15:48:04 <shapr> it used to be better
15:48:09 <np_hard> e.g. it allows you to make the statement String x = null;
15:48:14 <np_hard> which is an out and out lie
15:48:14 <shapr> but now...
15:48:19 <np_hard> null is not a string
15:48:32 <Jerub> bah!
15:48:36 <Jerub> you are arguing semantics.
15:48:50 <kosmikus> that's not much different from   x = undefined :: String
15:48:51 <shapr> and there's the dynamicloading of classes according to a string, that's no good for compile-time checking
15:49:20 <shapr> and there's the (String)MyArray[5] sort of stuff
15:49:32 <np_hard> well, I am schizophrenic as far as he is concerned
15:49:40 * shapr grins
15:49:41 <jameson> Also, Java allows arrays of subtypes to be passed as arguments...
15:49:44 <np_hard> on the one hand I mock java's "static" type system
15:49:50 <jameson> (updateable arrays, that is)
15:49:56 <np_hard> on the other hand I  am always advocating using something like python
15:50:06 <shapr> what's schizophrenic about that?
15:50:11 <shapr> if you want static typing, do it right!
15:50:13 <np_hard> I guess I just don't see the point in Java's verbosity if it is never used :)
15:50:18 <shapr> if you want dynamic typing, do it right!
15:50:23 <jameson> And their generics are pretty broken...
15:50:28 <np_hard> shapr: I don't think he's yet in a position to understand what static typing done right is
15:50:30 <shapr> as for things that Java has done right...
15:50:44 <shapr> Duke is a really cute mascot.
15:50:46 <np_hard> I myself am only just getting the hang of it
15:51:32 <shapr> Sun killed off Self and switched to Java
15:51:43 <np_hard> for example, in the previous example, I now grok the utility of the "Maybe" class
15:51:58 <shapr> what sort of raving stupidity did that require...
15:52:01 <np_hard> more so than I did before, on an abstract level, rather than a haskell level only
15:52:10 <SamB> I want Self on Linux (again. I had downloaded binaries, but they broke inexplicably)
15:52:24 <shapr> http://gliebe.de/self/index.html
15:52:27 <np_hard> a Maybe String in java could be null
15:52:31 <np_hard> but a String could not be
15:52:35 <np_hard> makes sense to me :)
15:52:51 <shapr> so, do you understand the Either type?
15:52:59 <shapr> it's one step past Maybe
15:53:17 <np_hard> never used it, lemme see if I can read up on it
15:53:52 <SamB> np_hard: there is no need to read up on it!
15:54:02 <np_hard> oh well you can just explain it to me if you like
15:54:08 <Jerub> np_hard: I see where you're coming from.
15:54:08 <np_hard> I was prepared to do my own legwork
15:54:10 <np_hard> :)
15:54:17 <SamB> just stare at it for a while
15:54:21 <np_hard> right
15:54:25 <np_hard> I am looking for a reference
15:54:26 <Jerub> np_hard: you dislike how broken java's static typing system is, so you'd rather do without a static typing system.
15:54:48 <SamB> well, you could gain a little info by reading about it
15:54:56 <shapr> I came from Python to Haskell, so I've only recently become convinced that static typing can be really great.
15:55:00 <SamB> data Either a b = Left a | Right b
15:55:04 <np_hard> Jerub: though I must say that the culture of pervasive testing has not yet made it into this organization
15:55:04 <Jerub> np_hard: iirc, the Either type is 'Left a' or 'Right b'. Where a and b can be different types.
15:55:12 <np_hard> Jerub: so perhaps a nanny compiler is a good thing
15:55:17 <Jerub> np_hard: is it web programming?
15:56:09 <np_hard> it should be a simple web programming project but management & other programmers insist on making it more complicated than it needs to be
15:56:50 <SamB> QuickCheck might be fun too
15:57:14 <shapr> quickcheck r0xx0rs
15:57:33 <np_hard> ah, I understand the Either type
15:58:47 <np_hard> shapr: I think I will get much more buyin with Python than with Haskell at work :)
15:59:12 <Jerub> np_hard: web programming I've found is very hard to easily unit-test.
15:59:30 <Jerub> especially if the programmers are in a culture where its code-compile-run-in-browser
15:59:59 <np_hard> jerub: well, it's an interesting mix on this team
16:00:22 <np_hard> one guy is totally infatuated with technological "enterprise solutions" a la EJB or whatnot
16:00:52 <np_hard> another guy writes truly obfuscated Perl code, which is basically the existing app
16:01:13 <np_hard> a couple are more domain-experts-turned-programmers
16:01:34 <chucky> np_hard: What's the difference between truly obfuscated perl code and standard perl code?
16:01:38 <chucky> :)
16:01:53 <np_hard> chucky: you laugh but there is a big difference. http://episteme.arstechnica.com/eve/ubb.x?a=tpc&s=50009562&f=6330927813&m=794007472631&r=138004572631#138004572631
16:02:07 <np_hard> that is me complaining about this perl code
16:02:07 <DeezNuts> chucky: how compact the logic is
16:02:39 <DeezNuts> ppl who complain about perl code don't know perl so aren't justified in complaining :p
16:02:49 <np_hard> no no
16:02:57 <np_hard> this is bad code no matter how you call it
16:03:03 <DeezNuts> np_hard: what?
16:03:12 <np_hard> when run with perl -w it fills a 1G partition with warning messages
16:03:19 <np_hard> in a matter of a minute
16:03:19 <DeezNuts> np_hard: sexy
16:03:44 <np_hard> there are a bazillion string evals in the code
16:04:28 <chucky> heh, I guess he has found a good way to keep his job. There's probably only one person in the world who can maintain the code. :)
16:04:52 <np_hard> i hesitate to ascribe that motive to it but it is a distinct possibility
16:05:25 <chucky> He might just be ignorant, or evil. :)
16:05:25 <DeezNuts> ugh
16:05:33 <np_hard> I am forced to conclude  that he is evil or that he is incompetent.
16:05:34 <np_hard> exactly
16:05:44 * DeezNuts hates when ppl who can't understand someone's code calls it obfuscated
16:05:52 <DeezNuts> not in the case ur talking about
16:05:57 <DeezNuts> but for practical matters
16:06:05 <DeezNuts> like i work with someone who is completely incompetent
16:06:12 <np_hard> DeezNuts: oh, if I put forth the effort to understand it, I'm sure I could.
16:06:13 <DeezNuts> and he will say shit like that and it really pisses me off 
16:06:16 <np_hard> hehe
16:06:37 <DeezNuts> np_hard: the problem is most people dont put forth any effort and if they dont understand something right away they just bitch
16:06:48 <np_hard> I don't think anyone else on the team has a formal CS background of any sort
16:07:03 <Jerub> DeezNuts: imho, you should write all code so that a fuzzy headed idiot can understand it.
16:07:08 <np_hard> one person just received their degree as a nontraditional student at what is essentially a community college
16:07:18 <Jerub> because chances are, 6 months later YOU will be the fuzzy headed idiot.
16:07:18 <DeezNuts> np_hard: lol heh i think most other people on my team have some sort of degree and i just have a GED but they don't know jack shit
16:07:26 <np_hard> Jerub: that's why Python is my great white hope
16:07:26 <DeezNuts> Jerub: bullshit
16:07:31 <DeezNuts> Jerub: that code would be horrible
16:07:46 <DeezNuts> Jerub: and often there are things one must do that just can't be written as simple
16:07:47 <np_hard> DeezNuts: true true, CS degree doesn't mean CS knowledge
16:08:03 <Jerub> DeezNuts: are you aware that 90% of the cost of software is in maintenance?
16:08:16 <DeezNuts> Jerub: maybe its in hiring people who don't know their ass from their elbow
16:08:19 <np_hard> DeezNuts: but for example, I could blame a CS degree holder for not understanding an XML parser... harder to blame them if they have never been taught about that sort of thing.
16:08:47 <SamB> hmm, maybe it really didn't break? maybe I just forgot which one to use.
16:09:15 <SamB> (Self, that is)
16:09:26 <DeezNuts> np_hard: well they could learn whatever it is they need to learn and if they can't then they don't deserve to have the job
16:10:44 <kosmikus> DeezNuts: isn't that what CS degrees are for? that it's easier to learn what you need to learn afterwards?
16:11:14 <np_hard> DeezNuts: aah, but there's the rub. What do they need to learn, really? More importantly, what happens when the hiring decisions about technical positions are made by people with no particular understanding of the technical aspects?
16:11:46 <np_hard> oh
16:11:52 <np_hard> so the Java-technology fetishist
16:12:24 <DeezNuts> np_hard: yeah, thats what I was referring to earlier with "Jerub: maybe its in hiring people who don't know their ass from their elbow"
16:13:01 <np_hard> wrote a system that executes a separate prepared statement for each field desired... e.g. "SELECT a FROM table" then "SELECT b FROM table" then "SELECT c FROM table" instead of "SELECT a, b, c FROM table"
16:13:11 <DeezNuts> kosmikus: hm? i never argued having a CS degree is worthless.. just that it seems plenty of people have them who mysteriously know jack shit about computers
16:13:29 <np_hard> and he also did his own joins by doing that.
16:13:51 <np_hard> basically pulling the data on one record takes over 250 DB calls
16:13:57 <DeezNuts> np_hard: omg
16:14:02 <np_hard> DeezNuts: exactly.
16:14:28 <np_hard> though I have fixed that in spades for him now
16:14:36 <DeezNuts> np_hard: im writing an app involving sql and my coworker also writes code that sends about 250 db calls per row of actually displayed data
16:15:09 <DeezNuts> np_hard: i wrote a module that generates the sql you need, joins and all, but he refuses to use it
16:15:10 <np_hard> DeezNuts: hilarious, we should form one of those societies
16:15:15 <DeezNuts> lol
16:15:17 <np_hard> "coming to grips with incompetence"
16:15:22 <DeezNuts> yeah rofl
16:15:42 <DeezNuts> i actually told my boss recently
16:15:44 <np_hard> well, I just went totally behind this guy's back. he loves the concept of a "business object" even though he isn't quite sure what he means by it
16:16:01 <np_hard> so I gave him factories for these business objects that use a cache
16:16:25 <DeezNuts> i hate to be a 'tattletale' but its just getting so bad.. and on top of that since he's senior he thinks he can tell me what's going on even though he can't manage to code for shit
16:16:30 <np_hard> I think he is actually very pleased with that
16:16:35 <DeezNuts> lol
16:16:36 <DeezNuts> nice
16:16:40 <np_hard> DeezNuts: oh, did I tell you? no one uses CVS really.
16:16:42 <DeezNuts> at least he accepts and uses the solution you provided
16:16:48 <DeezNuts> what do they use?
16:17:01 <DeezNuts> brb gotta drop a spike
16:17:02 <np_hard> DeezNuts: cp -r foo foo.bak
16:17:05 <np_hard> ew
16:17:09 <DeezNuts> lol
16:17:14 <DeezNuts> brb
16:18:35 <kosmikus> btw, one thing I really hate about the unix cp command is the danger of doing something like "cp -r foo/*"
16:19:26 <np_hard> yeah
16:20:16 <np_hard> I wonder if there's any way to fix that
16:20:36 <np_hard> is there an -i that will warn you if you are overwriting a file?
16:20:40 <np_hard> probably I guess
16:21:12 <np_hard> doesn't address the real problem, but then shell wildcard expansion is often knotty
16:22:37 <kosmikus> np_hard: yes, there's -i
16:23:10 <kosmikus> but -i is too cautious
16:23:42 <kosmikus> I think there should be a mode where cp warns only if in such cases the last filename is not a directory
16:24:01 <kosmikus> even better would be a typed shell that could somehow say that you'd want to pass "two" arguments to cp
16:29:22 <Jerub> maybe a haskell shell would be the way to go ;)
16:30:13 <kosmikus> maybe
16:30:25 <np_hard> kosmikus: would it even need a mode?
16:30:39 <kosmikus> but that would imply changes on the OS level as well
16:30:40 <np_hard> kosmikus: wouldn't that be good default behavior in the absence of -f?
16:31:11 <kosmikus> np_hard: no, because the default behaviour should be non-interactive
16:31:20 <kosmikus> otherwise you break a hell of a lot of shell-scripts out there
16:31:24 <np_hard> this is non-interactive
16:31:25 <np_hard> it fails
16:31:29 <np_hard> :)
16:31:53 <kosmikus> oh, I thought you said it should ask
16:32:01 <np_hard> yeah, sorry
16:32:16 <np_hard> I guess I took a leap of reasoning that I didn't document
16:32:17 <kosmikus> but still, I don't want to imagine how many scripts actually make use of this as a feature
16:32:26 <np_hard> they deserve whatever they get
17:08:23 <SamB> hmm, I can't start the gui...
17:08:23 <SamB> (of Self)
17:10:29 <SamB> hmm, I guess building my own image wasn't such a great idea...
17:11:46 <SamB> okay, surprisingly, I managed to get a Self image with a gui to work. Either I didn't try this version properly before, or it unbroke.
17:17:46 * DeezNuts wonders when the latest GHC will work on Linux/PPC
17:19:28 * SamB wants a garbage collector for his home directory
17:21:11 <bring> SamB: have a look at tmpwatch(8)
17:24:50 <Igloo> DeezNuts: It already does, although not registerised or (I suspect) ghci
17:29:01 <SamB> does Self use twospace?
17:31:52 <SamB> hmm. I don't suppose there is a port for PPC Linux?
17:32:32 * Igloo realises he'd left. Oh well.
17:32:39 * Igloo heads bedwards
17:32:41 <Jerub> Self is that sun thing isn't it?
17:33:07 <SamB> Jerub: yeah
19:29:40 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental","new HC&A Report - http://www.haskell.org/communities/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html", "Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/"]'
19:29:40 --- topic: set by shapr on [Fri Mar 05 15:32:48 2004]
19:29:40 --- names: list (clog noclouds _joey jasonw mattam_ np_hard betabot c_monkey SyntaxLaptop skew LittleDan SamB Lunar^ pattern smkl Jad[asc][Away] earthy wax isomer kig chucky Rafterman galority Arnia _Codex Lemmih malik liiwi Hipo norpan skylan whee mgoetze Vulpyne det Cale CrewdenX Riastradh creature cmeme ludde ozone tic rt shawn rubix polli dennisb keverets jlouis edwinb stpeter ibid emu Jerub Taaus andersca Segora juhp jameson eivuokko wagle Igloo kosmikus|away)
19:29:40 --- names: list (jagular djw gdsx jiwon shrimpx)
19:48:44 <np_hard> here's another silly question
19:49:11 <np_hard> with type matching, I have this issue:
19:49:55 <np_hard> data TypeA = TypeB | TypeC
19:50:45 <np_hard> the compiler says, "Couldn't match TypeA against TypeB: Expected type: TypeA Inferred type: TypeB"
19:52:11 <SyntaxLaptop> np_hard: where's it complaining?
19:52:22 <SyntaxLaptop> did you claim something had a type "TypeB"?
19:52:28 <SyntaxLaptop> because that's not a type, but rather a type constructor.
19:53:56 <np_hard> no, I claimed that something has a TypeA and want to use the TypeB nullary constructor to be that TypeA
19:55:14 <np_hard> hmm one sec
19:55:49 <SyntaxLaptop> care to paste?
19:56:02 <SyntaxLaptop> actually, do you have another TypeB someplace?
19:56:11 <np_hard> ah
19:56:14 <np_hard> I know what it is
19:56:16 <np_hard> or I think it is
19:56:20 <np_hard> brainfart here
19:56:25 <np_hard> let's see
20:01:52 <SyntaxLaptop> Sounds like you have a TypeB that you've declared, and you really want something like "TypeA = B TypeB | C TypeC
20:01:55 <SyntaxLaptop> "
20:04:40 <np_hard> hmm
20:04:49 <np_hard> let me make a more concrete example
20:04:59 <np_hard> data CharOrInt = Char | Int
20:05:04 <np_hard> i want that :)
20:05:59 <np_hard> but I don't think that's the right syntax at all
20:06:15 <np_hard> I want a type that both TypeB and TypeC can match to
20:06:43 <Riastradh> You're trying to make both Chars and Ints valid in one place without wrapping them in something else?
20:07:25 <np_hard> ah I see where I am going wrong
20:07:29 <np_hard> brb
20:07:29 <np_hard> :)
20:07:33 <np_hard> thanks Riastradh, SyntaxLaptop
20:07:59 <ozone> np_hard: you want 'data CharOrInt = Char Char | Int Int'
20:08:16 <ozone> you can then construct something of that type by doing "Char 'a'" or "Int 69"
20:09:02 <Riastradh> What you can't do is something like [[type CharOrInt = Char | Int]] and then, given [[f : CharOrInt -> Frumble]], make [[f '4']] and [[f 4]] be both valid.
20:10:07 <SyntaxLaptop> there's a paper somewhere about why haskell is so great for EDSL's, does anyone know where that paper is?
20:10:56 <Riastradh> Haskell has no macros!  Die!
20:11:20 <SyntaxLaptop> #define riastradh false
20:11:44 <ozone> SyntaxLaptop: there's a paper which contrasts DSL implementations in TH, Meta O'Caml and C++
20:11:52 <ozone> although that's not the one you're aftet
20:13:12 <np_hard> better, much better
20:13:19 <np_hard> I honestly am not sure what I was thinking
20:13:24 <np_hard> too much java at work
20:15:27 <SyntaxLaptop> np_hard: heehe
20:15:52 <SyntaxLaptop> ozone: nah. I swear I saw one that was all about why EDSLs are good, and why haskell rules. it might be by hudak. i'll google around ab it.
20:24:05 <np_hard> ah sweet, it worked
20:25:31 <np_hard> baby steps, but now I have something that will wikify styles, eg ''this'' is "<i>this</i>"
20:25:39 <np_hard> next for generating links
20:25:40 <np_hard> :)
20:31:29 <SyntaxLaptop> cool
20:35:58 <Riastradh> np_hard, why don't you just let the user input plain HTML and clean any potentially nasty elements out?
20:39:26 <np_hard> Riastradh: because then it is not a wiki? :)
20:39:46 <np_hard> i am mostly just doing this to work with transforming text in haskell
20:39:51 <Riastradh> np_hard, what does the markup language have to do with the concept of a wiki?
20:41:00 <np_hard> you have a point, I suppose a wiki is pretty much defined with the AutoLinkingOfCapsWords
20:41:22 <Riastradh> No, the auto-linking has nothing to do with it either.
20:41:58 <Riastradh> It's the concept of having a world-editable web site.
20:42:48 <np_hard> i don't buy that
20:43:15 <ozone> definition games -> no fun
20:45:48 <Jerub> np_hard: the simplest online database that could possibly work.
20:45:51 <Jerub> thats the definition of wiki ;)
20:47:28 <np_hard> i dunno
20:47:38 <np_hard> I am trying to envision a Wiki without WikiWords
20:47:43 <np_hard> and it just isn't happening
20:47:56 <Riastradh> Wikipedia doesn't use CamelCase.
20:49:34 <np_hard> ah, I never use that one
21:00:41 <Jerub> mmmhaskel.
