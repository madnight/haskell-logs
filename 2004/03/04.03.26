00:07:26 <shapr> |DarkShadow: do you have any questions about Haskell?
00:07:54 <|DarkShadow> so you're changing chans? *smile*
00:08:06 <shapr> well, #haskell.se is for swedish discussion
00:08:38 <|DarkShadow> then i guess i better put my questions in here :-)
00:09:32 <shapr> do you have some questions?
00:09:43 <|DarkShadow> i've written some staff in haskell and it does not work
00:10:03 <shapr> if it's three lines or less, you can paste it into the channel
00:10:12 <|DarkShadow> but... well... how to show you? :)
00:10:14 <shapr> if it's longer, you can put it into HaskellIrcPastePage
00:10:17 <shapr> @wiki HaskellIrcPastePage
00:10:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
00:10:27 <|DarkShadow> thx
00:12:15 * ski 's happy
00:12:28 * shapr is also happy
00:12:42 <shapr> tic: are you happy?
00:14:42 <tic> yo yo
00:14:49 <tic> shapr, yeah, I suppose... why?
00:15:04 <ski> why not ?
00:16:30 <ski> i'm happy because i'm listening to good music
00:16:52 <shapr> I'm happy because I'm nearly done with the first cut of my email web searching thingy
00:16:54 <tic> okay, then according to that definition, I should be happy too.
00:17:24 <|DarkShadow> well..
00:17:30 <|DarkShadow> gugg :: Char -> String -> Bool
00:17:35 <|DarkShadow> gugg '' _ = True
00:17:40 <|DarkShadow> gugg a "" = False
00:17:44 <|DarkShadow> gugg a (b:bs)
00:17:50 <|DarkShadow> 	| (a==b) = True
00:17:56 <|DarkShadow> 	| True   = gugg (a bs)
00:18:08 <ski> what a funny function name ! :)
00:18:19 <ski> i'll try to remember it
00:18:36 <ski> so '' is a syntax error, i think
00:18:47 <|DarkShadow> why?
00:18:58 <ski> there must be character in between
00:19:13 <ski> such as 'a' or '%' or '\n' or '\\'
00:19:17 <|DarkShadow> the function has to "gugg" if the character is in the given string or not...
00:19:51 <ski> is that a word in some language/jargon ?
00:20:04 <ayrnieu> dark - you probably actually want to look a bit more at the Prelude, though making such functions will surely bring you joy.
00:20:13 <|DarkShadow> well... if gugg searches no character in a string or whatever, it surely will be true
00:20:36 <ski> but there must be a charater in the first argument
00:20:39 <ayrnieu> ski - I lean towards 'personal metasyntatic variable'
00:21:54 <|DarkShadow> ayrnieu: i am not allowed to use the prelude...
00:22:00 <ski> ayrnieu : mm prolly. |DarkShadow just used it in such a way as i thought it might've been a word from somewhere ..
00:22:07 <ski> ok :)
00:22:21 <|DarkShadow> so again
00:22:28 <ski> hmm, also you have another error, i see
00:22:37 <|DarkShadow> i know ;)
00:23:06 <|DarkShadow> but how do i "teach" haskell what i want to say in the line with ''?
00:23:06 <ski> so, i don't think you need to pattern-match at all on the Char
00:23:33 * ski doesn't know what |DarkShadow want to "teach" haskell with that line
00:23:44 * ski doesn't understand it
00:24:10 <ayrnieu> dark - you decide to pass [Char] instead of Char for the first argument, so that you can define this bizarre function's behavior when asked to search for 'no character' in a string or whatever.
00:25:48 <ski> also, your syntax for the recursive call is a bit worng
00:26:07 <ski> do you see why ?
00:26:19 <|DarkShadow> no
00:26:24 <ski> ok
00:26:33 <ski> so look e.g. at
00:26:36 <ski> gugg a (b:bs)
00:27:02 <ski> this is a function "head" that matches some calls to this function
00:27:15 <ski> how many arguments does the function have ?
00:27:23 <|DarkShadow> tw
00:27:24 <|DarkShadow> o
00:27:26 <ski> mm
00:27:38 <ski> now look at your recursive call
00:27:47 <ski> how many args do you pass there ?
00:27:58 <shapr> greetz Cale 
00:27:58 <|DarkShadow> one character and one string
00:28:04 <ski> no :)
00:28:17 <|DarkShadow> but?
00:28:25 <ski> you should use the same syntax for function calling in both places
00:28:57 <ski> you didn't say "gugg (a (b:bs))" in the function head, right ?
00:29:36 <ski> see it ?
00:29:44 <ski> otherwise i'll tell you :)
00:29:45 <|DarkShadow> just the brackets?
00:30:03 <ayrnieu> dark - gugg (a bs) <=> gugg $ a bs <=> (\r -> gugg r) (a bs) <=> (\r1 -> gugg r1) ((\r2 -> a r2) bs)
00:30:28 <ski> parenthesis are used for grouping, but not for function calling, in haskell
00:30:51 <ayrnieu> the basic application operator looks like this:  
00:31:24 <ayrnieu> which, well, doesn't really work.  Sorry =)
00:31:34 <|DarkShadow> :)
00:31:40 <ayrnieu> functions bind more strongly than operators.
00:32:15 <ski> so in "gugg (a bs)", "gugg" gets *one* argument, namely "a bs"
00:32:37 <|DarkShadow> *argh*
00:32:59 <ski> so, what would happen if you just remove that parenthesis pair ?
00:33:03 <ayrnieu> namely (a bs), the application of a function a on one argument bs
00:33:06 <|DarkShadow> thank you
00:33:15 <ski> :)
00:33:33 <ski> it take you see the problem now
00:33:55 <|DarkShadow> i am very glad that the next semester there will be imperative programming...
00:34:02 <ski> oh ?
00:34:32 <ayrnieu> this has very little do with with imperative vs. functional, and everything to do with you simply not knowing the basic syntax of Haskell.  This will pass, if you care at all about making it pass.
00:34:32 <ski> but functional programming is so much more fun ..
00:35:03 <|DarkShadow> you may be right, ayrnieu
00:35:07 <ayrnieu> but if you mean "next semester they will teach me something I already know" ... =)
01:33:31 <shapr> hej Marvin-- 
01:36:07 <Marvin--> morning
01:36:50 <Marvin--> do you feel to test my lhs2TeX debian package?
01:37:04 <Marvin--> er, s/to test/like testing/
01:37:07 <shapr> is in HE?
01:37:27 <Marvin--> no, I've forgotten how to upload to it :)
01:37:38 <Marvin--> it's on www.strakt.com/~martin/lhs2tex/
01:37:41 <shapr> ok
01:43:09 <Marvin--> earthy: comin' or goin'? :)
01:43:34 <earthy> marvin--: coming
01:43:39 <earthy> just switched from cable to dsl
01:43:42 <earthy> that was the hiccup
01:44:20 <earthy> now to see if my laptop still has network connectivity
01:44:31 <Marvin--> ah :)
01:44:56 <Marvin--> fuck
01:45:01 <Marvin--> font problems in LyX
01:45:50 <earthy> annoying, that
01:45:56 <shapr> the deb seems to install just fine
01:46:04 <Marvin--> I *knew* I shouldn't have upgraded yesterday
01:55:50 <earthy> ;)
01:56:41 <Marvin--> ah well, it's readable, but it's ugly
01:57:52 * Marvin-- sets up a chroot
01:58:02 <shapr> how should I test that deb?
01:59:17 <Marvin--> I dunno, run it on some of your .lhs files or something :)
01:59:23 <shapr> ok
02:02:41 <Marvin--> I'm setting up a chroot right now to test the dependencies
02:03:53 <Lunar^> Hi
02:04:19 <shapr> bonjour Lunar^ 
02:07:57 * Marvin-- hugs dchroot
02:40:36 * Marvin-- ponders what paper to cite on Core
02:46:17 <shapr> this sort of works: http://shapr.homelinux.net/cgi-bin/wash/Test 
02:46:27 <shapr> but you have to put %word1% %word2%
02:46:38 <shapr> and it only returns the message-id, subject, and date right now
02:46:43 <Marvin--> oh
02:46:57 <shapr> but it does use HaskellDB, WASH, and WASHMail
02:47:03 <Marvin--> cool
02:47:40 <shapr> I'll write the message display bit tonite
02:48:05 <adept> shapr: wow. what's the backend?
02:48:11 <shapr> postgresql
02:49:05 <shapr> there's one module to split the mbox mailmain archive into messages, parse them, filter out the MIME messages, and load them into the database
02:49:22 <shapr> the other module shows the form, calls the search, and displays the results
02:50:21 <Lunar^> shapr: nice work :)
02:50:25 <shapr> :-)
02:50:42 <shapr> I'll add support for searching all/subset of the mailing lists soon
02:54:15 <shapr> but for now, it's time for paying work
03:05:54 <shapr> adept: since it uses HaskellDB, it's easy to use any of postgresql, mysql, sql-lite, or odbc for the backend
03:07:04 * Marvin-- tears his hair trying to figure out what to write in the stupid preface
03:08:34 <Lunar^> shapr: SQLLite could be well suited for this project, making it a standalone complement to mailman
03:09:04 <shapr> I have wondered about something like that
03:09:49 <shapr> hey Si
03:10:17 <Si> hi
03:10:26 <Si> any luck with Google WS?
03:11:18 <shapr> no, but I did get the first part of my haskell mailing list searchy working: http://shapr.homelinux.net/cgi-bin/wash/Test 
03:11:37 <shapr> because it uses LIKE, you have to use %word1% %word2%
03:12:36 <shapr> seems the servers are still down
03:12:42 <Si> ooooh
03:12:44 <Si> cool
03:12:58 <shapr> :-)
03:13:22 <Si> btw, I have a question which I'm gonna have to ask sooner or later, and I'd like your input on it
03:13:32 <shapr> sure
03:13:50 <Si> what is the point of implementing Web Services (e.g. SOAP/WSDL/XMLRPC etc.) in Haskell?
03:14:07 <Si> sorry I meant I'll be asked
03:14:25 <shapr> I think it's the same answer as the "Why FP?" paper
03:14:59 <Si> like on poster day, people are gonna say, "Well you can do all this in Java, why do we need it in Haskell" (my Uni is a Java Uni)
03:15:18 <shapr> but you can't do all of it in Java
03:15:24 <shapr> you can do web services, sure
03:15:27 <shapr> but that's not all that Haskell does
03:15:49 <shapr> if you just look at Java and Haskell, you'll see that Java has some great GUI libs, it's easy to make windows, menubars, etc
03:16:01 <shapr> and it has good network support for many things
03:16:01 <Marvin--> Java has great GUI libs? where?
03:16:16 <shapr> well, from some people's viewpoints
03:16:29 <Si> relatively speaking
03:16:55 * Cale is porting the Enlightenment Foundation Libraries to Haskell
03:17:10 <shapr> Haskell has a different set of advantages
03:17:15 <Cale> er, through ffi :)
03:17:30 * Cale is incredibly sleepy
03:17:39 <shapr> the whole point of WSDL is not to just let Java talk to Java across TCP/IP, that could be done with a lot less code
03:17:42 * saz is incredibly sleepy too!
03:17:45 * Cale goes to bed.
03:17:47 <shapr> g'day saz!
03:17:52 <shapr> g'night saz!
03:17:55 <saz> hi shapr!
03:17:56 <shapr> g'night Cale
03:18:02 <Cale> g'night
03:18:08 <saz> it's a little early to sleep
03:18:16 <shapr> right, it's just past noon
03:18:27 <saz> up there?
03:18:30 <shapr> yup
03:18:36 <saz> ah
03:18:49 <Si> yes I wrote about Haskell's data processing strengths in my initial report, but one of the problems with SOAP and indeed most of the protocols is that you have to touch a lowest common format
03:18:52 <shapr> anyways, the whole point of these protocols is to allow language agnostic RPC, so that you can mix languages to get the benefits of each
03:19:38 <shapr> input and result data can be simple, and you can still use lots of cool tricks in the processing
03:20:10 <shapr> for example, I plan on using xmlrpc so that I'll have access to HaskellDB from Zope
03:21:03 <Si> now this is exactly the sort of thing I need to know, what solutions can be built easier in Haskell than Java
03:22:31 <Si> I mean obviously a lot is shear conjecture (sp?) since you can never exactly be sure of what Interoperability in Haskell can be used to achieve
03:22:33 <shapr> QuickCheck is one advantage of Haskell
03:22:45 <Si> until it achieves it
03:23:16 <Si> yes I plan on writing about Haskell's atomicity and general safety
03:23:57 <shapr> in my opinion, Haskell allows greater abstraction than Java, and that's the biggest benefit
03:24:46 <shapr> but, Java pays a lot more, so this way I can write a web service in a small amount of code and time in Haskell, and other people can call it from J2EE
03:27:01 <Si> I mean I think one thing I have to make clear is that this project is just one of several building blocks being made to bring Enterprise Computing to Haskell
03:27:33 <Marvin--> gah
03:27:39 <shapr> I think it's a good point.
03:27:40 * Marvin-- hates the E word
03:27:52 <Si> sorry Marvin :)
03:27:53 <shapr> I want to get paid to do Enterprise Computing with Haskell.
03:28:01 <Marvin--> gah, they said it again
03:28:03 <Si> for want of a better of word I guess
03:28:18 <shapr> Humperdink! Humperdink! Humperdink!
03:28:31 * Si wonders why he can't seem to string valid sentences together on #haskell...
03:29:25 <Si> Anyway, thanks for your input, I need all the help I can get
03:29:35 <shapr> sure
03:29:42 <shapr> I'll think about it.
03:29:47 <shapr> maybe I'll come up with something else
03:30:53 <Si> I was talking with my ex-supervisor yesterday and he said, this is all well and good what you're creating and quite impressive, but does it compromise on Haskell's pureness and style
03:31:22 <shapr> depends on how you look at it
03:31:53 <Si> I mean I think I've gotta somehow figure out a way of making the dynamic linker type-safe
03:31:56 <Si> for example
03:32:01 <shapr> yah, I think that's the major deal
03:32:18 <shapr> there is a slow way to do it
03:32:43 <shapr> you can carry the type checker around with you if you dynamically link and run the app in the template haskell loop
03:33:17 <shapr> I don't know if anyone has tried to write such a thing
03:33:33 <shapr> have you read the TH papers?
03:33:45 <Si> well somehow I've got to use .hi files, if I can encapsulate them into my .har files and figure out how to interogate them that might work
03:34:00 <Si> not yet, but I will once I've finished WSDL
03:34:11 <Si> well I've sort of half read if...
03:34:22 <shapr> I think you should ask that question on haskell-cafe
03:34:41 <shapr> about interrogating .hi files, and type-safe dynamic loading
03:34:44 <Si> I will, but the plugin system should suffive atm
03:34:48 <Si> suffice
03:35:06 <shapr> I also think you might start one of the largest mailing list threads of all time with that sort of question :-)
03:35:15 <Lunar^> Si: I'm also interested in it 
03:35:24 <Lunar^> Si: See the last dev lOg entry
03:35:29 <Si> good, I need lots of unanswered questions and which to base a PHd thesis...
03:35:38 <Si> *on which
03:36:16 <shapr> type-safe dynamic loading in Haskell could surely give you enough for a PhD thesis
03:36:38 <shapr> and, once you solve the problem, I'll be able to start writing Hemacs
03:36:43 <Si> oh btw, HAC works!
03:37:22 <shapr> what does HAC do again?
03:37:22 <Si> did I explain what HAC was?
03:37:32 <Si> no I didn't did I
03:37:33 <shapr> I remember you said you had to write it...
03:37:44 <Si> HAC is the HAIFA Application Container
03:38:12 <Si> it holds a repository of dynamically loaded protocol plugins and application plugins
03:38:32 <Si> it hooks up to a Web Server, which passes relevant data to it
03:38:48 <shapr> ah, neat
03:38:48 <Si> uses a protocol plugin to convert the request into a call
03:38:54 <Si> fires the call at an application
03:39:02 <Si> builds a reply and sends it back
03:39:06 <Si> and it works
03:39:27 <Si> my challenge for today is to try and hook it up to HWS-WP
03:39:50 <shapr> hi ham 
03:39:51 <ham> moin
03:40:01 <shapr> Si: sounds exciting
03:40:10 <Si> basically it works by looking a list of URIs and sending replies from the list to the HAC server
03:41:16 <Si> it's only about 300 lines of Haskell
03:41:21 <Si> the server that is
03:48:16 <Marvin--> is "et cetera" abbreviated "etc." or "et.c." in English?
03:48:24 <shapr> etc.
03:48:53 <Marvin--> interesting
03:48:57 <Marvin--> it's "et.c." in Swedish
03:51:17 <Si> I'm about to be cut off, so I'll be brb
03:51:44 <shapr> Marvin--: that explains my confusion over that word
04:33:50 <saz> hm, is there any total newbie guides for running ghci with xemacs on windows?
04:34:38 * saz has never really tried it, and I'd rather not boot into windows to answer an email
04:51:42 * Marvin-- wrestles LaTeX
04:52:25 <Igloo> I feel your pain
04:56:12 <Marvin--> so... if I don't want to use titlepage since I want to have the title and the abstract on the same page... how do I get rid of the page number on that first page?
04:57:05 <adept> Marvin--: something about pagestyle and empty. Look it up in my docs?
04:57:27 <Marvin--> isn't pagestyle document-wide?
04:57:44 <Marvin--> oh wait, \thispagestyle
04:58:08 <adept> yep, exactly
04:59:09 <Marvin--> yay
04:59:20 * Marvin-- ponders how to get roman numbering without using \frontmatter
04:59:38 <adept> Marvin--: roman numbering of what?
05:00:57 <Marvin--> for page numbers
05:01:37 <Marvin--> \frontmatter turns that on, but is only available in the book class, or something
05:01:57 <kosmikus> \renewcommand{\thepage}{\roman{page}}
05:02:11 <kosmikus> alternatively \Roman produces uppercase roman
05:02:59 <Marvin--> hm
05:03:03 <adept> kosmikus: exactly
05:03:33 <Marvin--> how do I get normal numbers back for the main text? and will that restart at 1?
05:03:51 <kosmikus> it won't change the value of the counter, no
05:03:53 <adept> Marvin--: err... what is main text?
05:04:13 <kosmikus> normal numbers are \arabic{countername}, iirc
05:04:28 <adept> Marvin--: will this help? http://www.iam.ubc.ca/~newbury/tex/numbering.html
05:04:38 <Marvin--> well, I want to have roman numerals for the preface and table of contents, and then restart with 1, 2, ... for the acutal content
05:05:37 <Igloo> You could setcounter the appropriate thing to 0 or 1
05:05:46 <Marvin--> ooh
05:06:40 <Igloo> FWIW I find a search for "group:comp.text.tex whatever" on groups.google.com often useful for this sort of thing
05:06:47 <adept> there has to be "resetcounter" as well
05:07:03 <kosmikus> yes, there is
05:07:16 <adept> Igloo: i'd say that it's _always_ usefull :) All questions had been answered before at least a dozen times :)
05:08:07 <kosmikus> adept: oh no, resetcounter does not exist ...
05:08:15 <Marvin--> this is exactly what I wanted, thanks guys
05:17:27 <shapr> y0 SyntaxNinja, wassup?
05:20:54 <SyntaxNinja> y0y0 shapr
05:39:13 <shapr> is there such a thing as a share imap folder? something where multiple people can read from it at the same time?
05:40:13 <Lunar^> shapr: Sure
05:40:15 <shapr> I'm just thinking about how everyone in a company can access all email exchanged with a certain client
05:40:40 <Lunar^> shapr: Courier-IMAP does it, there's also nice SquirrelMail plugin if I remember wqell
05:41:09 <shapr> cool, thanks
05:43:55 <Marvin--> hm
05:44:01 <Marvin--> why haven't I had any coffee yet today?
05:44:58 <adept> shapr: my crystall ball tells me  that you will have a need for a CRM application (namely, for a part called "contact management")
05:48:31 <Marvin--> aiih, I'm almost out of coffee
05:48:40 <Marvin--> the horror
05:50:31 <shapr> adept: in that case, I'll have to write one in WASH
05:50:55 <shapr> or maybe with HAIFA
05:54:16 <adept> :)
05:54:22 <adept> what's haifa?
05:54:39 <shapr> Simon Foster's J2EE/Zope clone written in Haskell
05:54:50 <shapr> it hasn't been released yet, later this year.
05:59:22 <adept> wow. cant wait. Is there a quick peek available somewhere?
06:00:48 <shapr> not yet, but you can ask Si about it when he next joins the channel
06:01:08 <shapr> so far it has SOAP support, which I look forward to pulling into a separate library
06:01:28 <shapr> he said the App Container works now too
06:05:12 <shurik> can a nested function in where see a function defined with file scope?
06:05:16 <shurik> module scope
06:05:34 <Igloo> Yes
06:05:39 <shurik> hmm
06:06:43 <Igloo> hmm?
06:07:19 <shurik> yes
06:07:37 <shurik> my code doesn't get compiled
06:10:02 <Igloo> Well we'll need more info than that if you want help  :-)
06:30:29 <Marvin--> so... does anybody feel like telling me why http://www.mdstud.chalmers.se/~md9ms/ImplParWorks.hs works and http://www.mdstud.chalmers.se/~md9ms/ImplParFails.hs doesn't? :-(
06:32:10 <Igloo> Is the "case mkFE arg of" bit the only change?
06:32:51 <Marvin--> yes
06:33:08 <Lunar^> shapr: http://lambda.weblogs.com/discuss/msgReader$11635 <-- saw this ?
06:33:18 <Marvin--> but actually I want mkFE to have the type String -> Maybe Frontend, that's why I have a case expression there in the first place
06:33:51 <Marvin--> I guess I could change it to String -> IO Frontend and move the error printing there, but that kinda sucks
06:33:57 <Igloo> Oh, I'm not sure of the semantics of implicit options to be sure of what happens in cases like that
06:33:57 <shapr> Lunar^: wow, cool!
06:34:24 <Lunar^> shapr: I'm waiting for sebc's view on it
06:34:54 <Lunar^> "[15:34:28] <sebc> bref, perd pas de temps a lire ca :)"
06:34:57 <Lunar^> Do I need to translate ?
06:35:10 <shapr> yes?
06:35:20 <Lunar^> Don't waste time reading this
06:35:25 <shapr> heh, ok
06:36:36 <Lunar^> He said : it's an inference _algorithm_ for a type system which is not explained, there's nothing on it in the paper, neither proof of correctness, completeness
06:36:59 <Lunar^> I will read it anyway :)
06:37:40 <Marvin--> he presents an algorithm for type inference without presenting the type system?
06:38:01 <Marvin--> gnngh
06:38:23 <Marvin-->     Illegal constraint ?opt :: Options
06:38:23 <Marvin-->     In the type: String -> IO Frontend
06:38:23 <Marvin-->     While checking the type signature for `mkFE'
06:38:33 <Marvin--> how informative
06:39:44 <Marvin--> I don't *want* to move the lookup into the options
06:40:02 <Lunar^> Marvin--: it seems...
06:46:43 <ztre> hi
06:49:09 <ztre> can you tell me why shouldnt i use haskell? ;-)
06:49:30 <Smerdyakov> Focus on logic, not low-level details.
06:50:20 <adept> ztre: you shouldnt use haskell. Why? Come on, really, dont pull our collective leg, everybody know that this question is rhetoric :)
06:53:14 <shapr> I encourage my competitors to use Windows. And Java.
06:53:31 <ztre> :-/
06:53:51 <Smerdyakov> ztre, you are unconvinced?
06:54:03 <ztre> Smerdyakov: no.
06:54:10 <shapr> because if my competitors use those things, I won't have to compete very hard.
06:54:37 <shapr> ztre: I would be happy to compare and contrast Haskell with other language, if you would like to suggest one or two languages to compare to?
06:54:39 <SyntaxNinja> shapr: I see you compete by dastardly means!
06:55:00 <shapr> it's true, I'm underhanded like that.
06:55:13 <ztre> shapr: C, Python, LISP, FORTH
06:55:18 <SyntaxNinja> ztre might not really have meant the question in a negative sense, if he's a non-native english speaker.
06:55:52 <ztre> i am not native :-(
06:55:55 <shapr> C encourages micromanagement, so it's good if you want execution speed, but it's bad if you want development speed
06:56:13 <adept> ztre: C and Haskell cound not be compared, since C is a Char, and Haskell is a String ;)
06:56:15 <tic> ztre, python has some concepts borrowed from Haskell you might recognize; zip, join, lambda, map, filter, ...
06:56:35 <tic> ztre, Haskell's a whole different way of thinking than the imperative languages.
06:56:38 <shapr> Python isn't very fast, but you can quickly write code that works in Python. On the downside, most Python errors are found at runtime.
06:56:48 <ztre> adept: and? cannot you soft a list like ['a', 'b', 'cde', 'h', 'ef']...
06:56:52 <ztre> sort
06:57:15 <adept> ztre: try sort [ 'C', "Haskell" ] ;)
06:57:27 <adept> ztre: and see who comes first ;)
06:57:29 <shapr> FORTH is a strange combination of stack, compiler, interpreter, and lots of crazy and nifty stuff
06:57:34 <ztre> adept: :-( C
06:57:59 <ztre> shapr: FORTH is great hey
06:58:10 <adept> @eval ( sort [ 'C' , "Haskell" ] )
06:58:10 <lambdabot> unbound variable: sort
06:58:11 <shapr> the upside of FORTH is that you can write programs that do not require an operating system, and do not require much memory at all
06:58:36 <shapr> FORTH is not typed though, the creator of FORTH even says that types are crutches for programmers.
06:58:49 <adept> shapr: given stack-based arch, which are not plenty nowadays
06:59:10 <ztre> LISP?
06:59:24 <shapr> LISP has a long history, can be statically compiled, can be fast, has a massive set of libraries, a scary user community (in my opinion)
06:59:43 <ztre> shapr: why scary?
07:00:04 <adept> LISP is a classic. Everyone should read SICP and OnLisp at least once :)
07:00:14 <shapr> most of the lisp users that I know are fanatic users
07:00:29 <shapr> I prefer the view point of being open to change
07:00:50 <ztre> :-) okay
07:00:56 <ztre> brb...
07:01:33 <tic> yeah, theyre fanatics.
07:02:03 <shapr> in my opinion, Haskell allows more abstraction than other languages I've used (but only for *most* things, not *all*)
07:02:40 <shapr> it also lets me ignore most of the accidental difficulties of programming, and concentrate on the essential difficulties.
07:02:45 <Smerdyakov> I don't know how you can measure quantity of abstraction.
07:02:57 <Smerdyakov> I'd say it's better to measure effectiveness of abstraction.
07:03:17 <shapr> good idea, go forth and measure!
07:04:06 <adept> ztre: There is a story that Haskell Curry got his Brilliant Idea while C-tting under the try one sunny morning. All of a sudden large snake (Python? maybe) come FORTH brom branches, and told him (LISPing, or course) basics of type theory.... (/me run out of ideas ...)
07:04:21 * shapr laughs
07:04:43 <adept> shapr: Go FORTH? We are rooting for another team here :)
07:04:53 * shapr snickers
07:06:40 <ztre> re
07:07:04 <ztre> type theory?
07:08:16 <shapr> imo, a type system is a greatly simplified automated proof checker
07:08:28 <ztre> :-?
07:08:36 <shapr> you can choose to encode information in types so that it gets checked when you compile the code
07:08:45 <ztre> like in maths? N, Z, Q...
07:08:56 <adept> ztre: yep, to some extent
07:09:02 <shapr> for example, in HTML the only tag that comes after a closing <head/> tag is an opening <body> tag
07:09:08 <shapr> er </head>
07:09:13 * shapr has done too much XML lately
07:09:23 <monotonom> types are invariants
07:09:24 <ztre> shapr: and?
07:09:47 <shapr> so, systems like HaXML and WASH in Haskell actually check that
07:09:54 <adept> ztre: and? and it's cool :)
07:10:12 <ztre> *what*?
07:10:12 <shapr> if you write head $ table instead of head $ body with WASH, you get an error when compiling.
07:10:34 <adept> ztre: for me, it works like this: if my code compiles, it Just Works Properly. Otherwise, error are being caught by compiler.
07:10:35 <ztre> of course i get an error from validator.w3.org as well :-)
07:10:49 <shapr> HaXML can take a Document Type Description as input, and generate code to make sure the tags are always stuck together in legal ways only.
07:10:57 <adept> ztre: ok. another example
07:11:07 <ztre> adept: sounds good
07:11:55 <adept> ztre: list of ints and list of floats are different things and it's good for me when compiler sees that I try to sum int and float and put it to double and raises hell about it.
07:13:07 <ztre> double? oh no! so haskell has double?
07:13:15 <adept> ztre: compiler know that map produces list of exactly same type as it take as argument, so if I try to map (+1) (map ('a':) ["aaaa", "bbb"]), compiler will see that map's dont exactly match and could not be applied this way.
07:13:29 <ztre> and can there be a list [1, 'b', 3.1415]?
07:13:40 <adept> ztre: haskell has platform-independent and platform-dependent numerals as well.
07:13:49 <adept> ztre: no, such list is not allowed
07:13:56 <Lunar^> But there is tuples !
07:14:13 <ztre> tuples?
07:14:25 <Lunar^> ztre: Never wanted a function to return multiple values ?
07:14:27 <ztre> like in Python?
07:14:28 <adept> ztre: (1, 'b', 3.14) is a tuple.
07:14:53 <shapr> except that in Python, a tuple is an immutable sequence, and in Haskell it is a collection type, and not a sequence.
07:14:54 <ztre> then whats the diff between lists and tuples?
07:14:57 <Lunar^> yes, quite like Python's but they are statically typechecked
07:15:17 <adept> ztre: tuple are immutable
07:15:28 * adept beats himself
07:15:37 * shapr beats adept too, just to be helpful ;-)
07:15:44 <ztre> adept: why?
07:15:51 <ztre> beat?
07:15:51 <adept> ztre: i'm wrong
07:16:07 <ztre> why?
07:16:09 <ztre> no
07:16:12 <ztre> or yes?
07:16:16 <ztre> i dont know Haskell
07:16:19 <shapr> what's the question again?
07:16:30 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
07:16:38 <shapr> that's the introduction for impatient people
07:16:48 <Smerdyakov> Haskell tuples are fixed length with heterogeneous types.
07:16:50 <ztre> shapr: why adept beaten h(im|er)self?
07:16:53 <adept> ztre: list is a collection of indef number of object of the same type, tuple is a fixed number of objects of (possibly) different types
07:16:57 <Smerdyakov> Haskell lists are variable length with homogeneous types.
07:17:15 <shapr> well, it's what I wrote for impatient people, so if you see any improvements, I'd like to hear about them.
07:17:42 <shapr> I don't know why adept beat himself, but it looked like fun, so I was helping.
07:18:37 <adept> ztre: because in Haskell everything is immutable 
07:18:39 <ztre> and if i wanna store indef num of diff types?
07:18:52 <adept> ztre: why do you want to do this?
07:18:55 <shapr> then you can have a list of tuples of the same type
07:19:09 <shapr> [(1,"foo"),(2,"bar")]
07:19:19 <ztre> adept: functional lang --> everything immut, nope?
07:19:50 <ztre> shapr: :-D
07:19:57 <ztre> shapr: its the same as a list!
07:20:00 <adept> ztre: definition of functional lang is very generic nowadays, and include mixed languages like OCaml which has mutable vars.
07:20:00 <ztre> nope?
07:20:28 <shapr> it's a list of the same type
07:20:29 <adept> ztre: what will you do with list ('a', 1, 3.14)?
07:21:36 <ztre> adept: well... store user input?
07:21:43 <adept> ztre: and then ... ?
07:21:54 <ztre> ahem, print it :-D
07:21:57 <adept> ztre: user input is always structured, isnt it
07:22:12 <ztre> adept: depends on the user
07:22:15 <ztre> :-D
07:22:17 <ztre> dunno
07:22:37 <ztre> how is printf() in Haskell?
07:22:38 <adept> ztre: do you need intermediate storage in between read and print? Why do you need heterogeneous list?
07:22:48 <adept> PutStrLn
07:23:05 <Smerdyakov> ztre, there is no equivalent
07:23:11 <Smerdyakov> ztre, maybe in Template Haskell
07:23:24 <adept> Smerdyakov: it too tough for a newbie
07:23:25 <ztre> so can i PutStrLn 'a' 5 3.1415?
07:24:02 <Smerdyakov> ztre, no, but you can PutStrLn (show 'a') ++ (show 5) ++ (show 3.1415)
07:24:04 <Smerdyakov> (I think(
07:24:09 <Smerdyakov> With extra parens :)
07:24:12 <adept> PutStrLn "a" ++ show 5 ++ show 3.14
07:24:26 <adept> @eval (show 'a') ++ (show 5) ++ (show 3.1415)
07:24:27 <lambdabot> unbound variable: show
07:24:31 <adept> damn
07:24:46 <ztre> lambdabot: stupid!
07:24:46 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:25:12 <ztre> lambdabot: f n = f n+1 and rest
07:25:12 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:25:16 <ztre> ?
07:25:18 <ztre> sorry
07:25:35 <adept> oh! I've seen very useful bot on #debian yesterday. It has @topicsmite. Very usefull :)
07:25:40 <ztre> so PutStrLn doesnt do show automagically, but its not aproblem.
07:25:56 <ztre> adept: ?
07:26:06 <ztre> adept: apt+dpkg are bllotbots
07:26:11 <ztre> blootbots
07:26:18 <shapr> lambdabot is a lambdabot 
07:26:20 <ztre> whats topicmite?
07:26:20 <adept> ztre: exactly. Especially since you can work on higher level and let some library code do PuStrLn's for you
07:27:07 <adept> And the wrath of /TOPIC descended with
07:27:07 <adept>  terrible fury upon trans_err.  And all the people marveled, saying, Behold, we 
07:27:07 <adept> too should read the /TOPIC, lest we be stricken.  And all the people read the /T
07:27:07 <adept> OPIC, and went away edified.
07:27:52 <ztre> oh
07:28:20 <shapr> well, if we end up with a lot of repeated questions that are already answered by the topic, I'm sure lambdabot will quickly get such a command
07:28:22 <ztre> adept: the #debian bots are really cool.
07:28:42 <ztre> and they are redundant
07:29:36 <ztre> but wait, a heterogenous list is not so stupid!
07:29:47 <monotonom> redundant? does that mean when you ask "what is the latest version of Debian" you will get 1000 identical answers from 1000 bots?  That's a COOL punishment for not doing one's homework! :)
07:29:55 <ztre> ie how do i add 1 and 3.14?
07:30:00 <adept> ztre: well, come up with real-life task that requires heterogeneous list
07:30:05 <monotonom> You can cast 1 to 1.0 first.
07:30:13 <ztre> monotonom: no!
07:30:32 <ztre> adept: maths
07:30:38 <adept> ztre: 1+3.14 = 4.14 or 4? Explain why you prefer either alternative.
07:30:55 <monotonom> yeah you could also cast 3.14 to 3 first 
07:31:24 <ztre> i can multiply a complex number with an integer... can i in haskell?
07:31:40 <ztre> and i cant cast the complex num to integer :-/
07:31:43 <ztre> so?
07:31:51 <adept> ztre: next, 10/4 = 2 or 2.5 or error. Again, explain your answer
07:31:52 <shapr> but you can cast integer to complex num
07:32:16 <monotonom> Heterogenity is overhyped.  Usually you know upfront what types of things you want to put into the container, and usually the number of types doesn't exceed five.  Use a union.
07:32:24 <adept> ztre: yeah, so? Int + Float = Int or Float, what do you think?
07:32:27 <shapr> my first Haskell program used complex numbers
07:32:50 <shapr> fun with fractals
07:34:09 <ztre> adept: A + B.C = (A+B).C, so float, nope?
07:34:24 <shapr> ztre: anyways, I think the answer to your question is "there is not a reason why you should not use Haskell, Haskell is worth learning"
07:34:32 <adept> ztre: and what if I _define_ Int + Float to be Int?
07:34:35 <ztre> adept: sqrt() is what -> what then in Haskell?
07:34:46 <adept> @type sqrt
07:34:48 <lambdabot> sqrt :: Floating a => a -> a
07:35:04 <shapr> @type sqrt 1
07:35:05 <lambdabot> sqrt 1 :: Floating a => a
07:35:08 <adept> Any floating point type -> the smae type
07:35:09 <shapr> @type sqrt 1.0
07:35:09 <lambdabot> sqrt 1.0 :: Floating a => a
07:35:13 <ztre> adept: that wont be + then, only some funky function.
07:35:29 <adept> @type +
07:35:38 <shapr> you need parens
07:35:44 <adept> @type (+)
07:35:45 <lambdabot> (+) :: Num a => a -> a -> a
07:35:50 <ztre> @type sqrt -1
07:36:01 <monotonom> @type sqrt(-1)
07:36:01 <lambdabot> sqrt (-1) :: Floating a => a
07:36:09 <shapr> @type (1.0 + 1)
07:36:09 <ztre> no!
07:36:09 <lambdabot> 1.0 + 1 :: Fractional a => a
07:36:12 <adept> so, take any pair of numbers of the same type, and obtain number of the same type
07:36:32 <adept> @type (5+5)
07:36:33 <lambdabot> 5 + 5 :: Num a => a
07:36:39 <adept> @eval 5+5
07:36:40 <lambdabot> 10
07:36:41 <ztre> @eval 1.0+1
07:36:42 <lambdabot> type error
07:36:42 <shapr> ztre: one of the neat features of Haskell is that it has a hierarchy of number types
07:36:52 <adept> @eval 1.0+1.0
07:36:53 <lambdabot> type error
07:37:02 <shapr> @eval isn't real haskell, it's a lambda calculus interpreter
07:37:03 <lambdabot> (line 1, column 19):
07:37:03 <lambdabot> unexpected ","
07:37:03 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
07:37:03 <lambdabot>  "(", operator, simple term or end of input
07:37:03 <ztre> :-D
07:37:21 <adept> :)
07:37:35 <ztre> @type (sqrt -1)
07:37:40 <shapr> real haskell does let you add all these things
07:37:55 <shapr> *Main> sqrt (-1)
07:37:55 <shapr> NaN
07:37:55 <ztre> i got confused
07:38:09 <adept> ztre: 5 could be Int or Integer. 5.0 could be Float or Double...
07:38:15 <ztre> sqrt -1 is not NaN!!
07:38:18 <ztre> its i
07:38:20 <adept> ztre: read tutorial then
07:38:29 <Marvin--> adept: 5 could be Float or Double too
07:38:50 <adept> ztre: and since when i is an arithmetic number?
07:38:51 <monotonom> 5 could be quaternion, just for maximum fun
07:38:57 <adept> Marvin--: yep. me bad.
07:39:24 <Marvin--> I think it basically replaces an int k with (fromInteger k)
07:39:41 <ztre> i is a number :-( like e and pi and ...
07:39:51 <shapr> I am not a number!
07:40:05 <ztre> shapr = NaN?
07:40:08 <adept> ztre: NaN = not an arithmetical number, no?
07:40:17 <ztre> NaN = Not a Number!
07:40:24 <Marvin--> oh quit yer whinin'
07:40:37 <ztre> whinin'?
07:40:41 <ztre> @dict whining
07:40:41 <lambdabot> Supported dictionary-lookup commands:
07:40:41 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon
07:40:41 <lambdabot> @lojban @prelude @vera @web1913 @wn @world02
07:40:41 <lambdabot> Use "@dict-help [cmd...]" for more.
07:41:04 <ztre> @web1913 whining
07:41:06 <lambdabot> *** "Whining" web1913 "Webster's Revised Unabridged Dictionary (1913)"
07:41:06 <lambdabot> Whine \\Whine\\, v. i. [imp. & p. p. {Whined}; p. pr. & vb. n.
07:41:06 <lambdabot>    {Whining}.] [OE. whinen, AS. hw[=i]nan to make a whistling,
07:41:06 <lambdabot>    whizzing sound; akin to Icel. hv[=i]na, Sw. hvina, Dan.
07:41:07 <lambdabot>    hvine, and probably to G. wiehern to neigh, OHG. wih[=o]n,
07:41:09 <lambdabot>    hweij[=o]n; perhaps of imitative origin. Cf. {Whinny}, v. i.]
07:41:11 <lambdabot>    To utter a plaintive cry, as some animals; to moan with a
07:41:13 <lambdabot>    childish noise; to complain, or to tell of sorrow, distress,
07:41:15 <lambdabot> [9 @more lines]
07:41:19 <shapr> hm, gaelic
07:41:23 <shapr> I didn't know that
07:41:35 <monotonom> Notice that the Floating typeclass includes the Complex type.  sqrt (-1) can be anything in the Floating typeclass; it can very well be a Complex if you ask for it.
07:41:44 <Marvin--> you can import Complex
07:41:45 <monotonom> @type sqrt(-1) :: Complex
07:41:49 <Marvin--> Complex> sqrt $ (-1) :+ 0
07:41:49 <Marvin--> 0.0 :+ 1.0
07:42:09 <ztre> cool
07:42:24 <ztre> hypercomplex and kvarternion too?
07:42:33 <adept> ztre: but you should learn about typeclasses before
07:42:39 <monotonom> You will have to implement them yourself.
07:42:40 <ztre> :-D
07:42:45 <ztre> :-(
07:43:03 <shapr> I think I saw some quaternion code at the 2003 ICFP
07:43:04 <ztre> and matrix operators?
07:43:18 <ztre> icfp
07:43:20 <ztre> ?
07:43:27 <ztre> @wtf icfp
07:43:28 <lambdabot> Sorry, I don't know the command "wtf", try "lambdabot: @listcommands"
07:43:30 <shapr> international conference on functional programming
07:43:34 <ztre> :-D
07:43:43 <ztre> i will go to that once
07:43:51 <shapr> that's a good idea, I should add a wtf plugin
07:43:54 <adept> only once?
07:43:57 <shapr> ztre: would you like to write the @wtf plugin?
07:44:10 <ztre> shapr: in haskell?
07:44:13 <Marvin--> is the @fact plugin still dead?
07:44:16 <shapr> yes
07:44:21 <Marvin--> too bad
07:44:28 <ztre> shapr: i am currently on the 2. page of the "gentle intro to haskell"
07:44:29 <shapr> I'll probably fix @fact this weekend
07:44:33 <Marvin--> yay
07:44:38 <adept> shapr: any chance of @fact using HaskellDB? :)
07:44:40 <shapr> since I now know how to use HaskellDB
07:44:42 <shapr> of course!
07:44:59 <adept> ztre: try "yet another haskell tutorial"
07:45:11 <shapr> ztre: lambdabot is patient :-)
07:45:11 <ztre> adept: is that better?
07:45:17 <adept> ztre: IMO yes
07:45:24 <ztre> :-/
07:45:26 <ztre> well.
07:45:35 * Marvin-- ponders writing a "Not So Gentle Intro to Haskell"
07:45:38 <adept> ztre: it's bigger too
07:45:48 <shapr> Marvin--: been there, done that, Riastradh sells the t-shirt
07:45:50 <ztre> i dont like the perlman, i adore the python tut. which haskell tutorial is for me then?
07:46:00 <adept> Marvin--: that was my point when Hal started writing YAHT.
07:46:03 <Marvin--> shapr: which reminds me, I have yet  obuy one
07:46:08 <shapr> Marvin--: same here
07:46:26 <Marvin--> I should *so* wear one when presenting my project
07:46:29 <shapr> yes!
07:46:44 <shapr> I could wear that shirt to swedish class
07:46:47 <adept> ztre: yet another ...
07:47:20 <ztre> or is there a haskell tutorial in haiku? i like haiku
07:47:36 <shapr> I think we should buy one of those tshirts each for Simon^2
07:47:42 <shapr> and probably one for John Hughes too
07:47:43 * Marvin-- hates haiku
07:48:05 <shapr> any idea what size t-shirt John Hughes wears?
07:48:12 <shapr> I'd guess L or XL
07:48:21 <Marvin--> no freakin' idea
07:48:23 <shapr> and M or L for SPJ
07:48:42 <shapr> dunno about anyone else
07:48:43 <Marvin--> maybe I should get one for Koen to thank him for supervising my project
07:48:53 <shapr> that would be a cool thank you present
07:49:39 <shapr> ztre: you could rewrite YAHT in haiku
07:49:55 <ztre> :-(
07:50:07 <ztre> yay, yaht is in insane formats!
07:50:16 <ztre> pdf ps dvi?
07:50:20 <shapr> the snow falls slowly, the lambdas are lifting, weak head normal form
07:50:23 <ztre> isnt there an xhtml one?
07:50:30 <Marvin--> what's insane about pdf ps dvi?
07:50:46 <adept> ztre: what's insane about pdf or dvi? :-\
07:50:58 <Lunar^> shapr: T-shirt ? Where ?
07:51:23 <Lunar^> shapr: Haskell haiku ?
07:51:25 <shapr> Lunar^: the one linked from QuotesPage on HaWiki
07:51:30 <shapr> yes, I'm making up Haskell haiku
07:51:45 <ztre> i dont have any ps or pdf or dvi viewers. html is much better, nope?
07:52:18 <Marvin--> well, if you define "X is better than Y" as "I have a viewer for X but not for Y", then ... I guess
07:52:28 <shapr> space, final frontier; I wish you would not leak for me, space profiling sucks
07:52:40 <ztre> Marvin--: ...
07:52:44 <ztre> Marvin--: u guess
07:53:04 <Lunar^> shapr: Talking about HM algorithm t-shirts ?
07:53:06 <shapr> yes
07:53:25 <Marvin--> it wasn't an algorithm, was it? Wasn't it just the type system?
07:53:35 <ztre>  
07:53:46 <Lunar^> shapr: I want to make some "Functional programming is for real" a moment
07:54:01 <shapr> you should talk to Fritz K. Ruehr
07:54:13 <shapr> he's got graphical talent, and he enjoys making FP graphics
07:54:16 <ztre> <poll>what OS do u use?</poll>
07:54:19 <monotonom> html is of course much better. suppose you are on a computer in the 70's. you can still parse html yourself.
07:54:21 <ztre> <so?/>
07:54:49 <shapr> I can read postscript! (I just didn't say how quickly ;-)
07:55:02 <Marvin--> ztre: better give us a dtd for that so we know how to interpret it
07:55:15 * shapr shines a flashlight on the CDROM and spins it quickly
07:55:22 <ztre> dtd:
07:55:41 <Marvin--> I think most people in here are GNU/Linux users
07:55:43 <ztre> poll := <reply> answer
07:55:48 <shapr> <linux distro="debian" flavor="unstable" />
07:56:12 <Lunar^> I also apreciate OS X
07:56:15 <ztre> answer := Mac|Win|BSD|<Linux>|Amiga|Be|QNX|...
07:56:20 <Smerdyakov> <flavor="spicy" !!!>
07:56:32 <Marvin--> I do use Solaris and very occasionally FreeBSD at university
07:56:32 <shapr> <hOp distro="lunarix"/>
07:56:35 <ztre> Linux := Debian|Fedora|Gentoo|Arch|Mandrake|Rubyx|...
07:56:44 * monotonom stares at a CD, eyes rolling rapidly, and begins humming the music on it.
07:56:51 <shapr> monotonom: haha!
07:57:21 <ztre> so linux. okay
07:57:30 <Smerdyakov> Does anyone else here want to declare war on incorrect use of commas?
07:57:42 <shapr> , no
07:57:44 <ztre> i also asked in #c#, they said win --> i wont even try C#
07:57:46 * shapr runs away
07:57:55 <Smerdyakov> I've stopped commenting on them when I proofread people's writing.
07:58:00 <Smerdyakov> It's too draining.
07:58:08 <Marvin--> Smerdyakov: n,o
07:58:08 <shapr> drains sucks.
07:58:30 * Marvin-- sucks much too badly at it himself
07:58:40 <shapr> ztre: actually, it is important to me that programs I write in Haskell will also work on Win32
07:58:53 <monotonom> I just comment "wrong commas all over the place... go back to grade 1"
07:58:57 <ztre> shapr: of coz.
07:59:08 <shapr> but I don't want to use win32 myself
07:59:12 <ztre> shapr: but its also omportant to not to write them on win32
07:59:12 <Marvin--> note to self: don't ask monotonom to proofread my report
07:59:20 <ztre> :-D
07:59:21 <shapr> ztre: right, exactly
07:59:25 <shapr> I see that we agree
07:59:37 <ztre> shapr: do we?
07:59:49 <ztre> shapr: what editor do u prefer?
07:59:53 <ztre> </poll>
08:00:02 <shapr> yes, we want our programs to be able to work on win32, but we don't want to write them on win32
08:00:17 <monotonom> copy con: Quaternion.hs
08:00:27 <shapr> <emacs distro="Lucid" flavor="heavily extended">
08:00:33 <monotonom> Oops we like linux. cat > Quaternion.hs
08:00:39 <Marvin--> heh
08:00:51 <Marvin--> gotta love those device names
08:00:53 <ztre> shapr: see? we dont agree! vim || mcedit
08:01:11 <monotonom> Seriously, I use emacs.
08:01:21 <shapr> if we agreed on everything, it wouldn't be fun to talk to each other!
08:01:32 <shapr> greetz Si\ 
08:01:47 <monotonom> I agree with myself. I find it fun to talk to myself.
08:01:48 <ztre> shapr: no. it *is* real fun.
08:02:05 <monotonom> yeah, real fun too.
08:02:12 <Si\> hi
08:05:10 * Marvin-- struggles with his abstract
08:05:54 <monotonom> Have you done the rest of your report?
08:06:10 <Smerdyakov> I get to write a report soon!!! I bet you are jealous, monotonom.
08:06:44 <monotonom> I am not jealous. I've got a whole bloody PhD thesis to write.
08:07:00 * Si\ is glad to have the WWW back
08:07:12 <monotonom> You can write my thesis too if you want!
08:07:24 <Marvin--> monotonom: the factual parts yes, it's mostly nitpicking left
08:07:45 <Smerdyakov> I have to write one of those some day. In the near term, I just need to write a masters report.
08:07:50 <monotonom> Ah alright then it is a good time to write the abstract.  There should be little struggle.
08:07:55 <Si\> monotonom: how much do you have to write?
08:08:04 <ztre> seriously, which one should i get? PDF, PS or DVI?
08:08:14 <monotonom> Get them all.
08:08:21 <ztre> monotonom: no
08:08:23 <Smerdyakov> monotonom, what is your thesis?
08:08:27 <Marvin--> monotonom: I think to a large extent it's because I'm fed up with it by now :)
08:08:48 <monotonom> It is good thing to hate your own writing.
08:08:54 * Marvin-- needs more coffee
08:09:08 <ztre> @give coffe to Marvin-- 
08:09:09 <lambdabot> Sorry, I don't know the command "give", try "lambdabot: @listcommands"
08:09:24 <monotonom> My problem is sometimes I like my writing too much.  Then it hurts when readers say it sucks.
08:09:27 <ztre> lambdabot: u silly. #debian bots would have done it!
08:09:27 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:09:39 <monotonom> (Not to mention that since I like it so much, I don't improve it.)
08:09:43 <Marvin--> monotonom: :)
08:12:58 <Marvin--> I'm using kosmikus' heuristics
08:13:17 <ztre> ok i got them all ;-)
08:13:23 <ztre> thanx evryun!
08:14:58 <Smerdyakov> monotonom, what is your thesis?
08:16:00 <monotonom> Do you want to write it for me? :)
08:16:28 <monotonom> It is about specifying and proving time bounds of lazy programs.
08:17:24 <Smerdyakov> Oh. The thing no one wants to do.
08:17:52 <Marvin--> heh
08:19:36 <monotonom> Actually, you guys are educated, so why don't I show you my old proposal?
08:21:10 <Marvin--> uh-oh
08:21:15 * Marvin-- looks for the nearest exit
08:21:19 <monotonom> http://www.cs.utoronto.ca/~trebla/thesis-proposal.pdf
08:22:37 <Marvin--> lazy time *and* space?
08:22:39 <Marvin--> yikes
08:23:45 <Marvin--> have you read Gustavsson's and Sands' papers on space-safe transformations?
08:34:31 <amgine2> how does one catch an exception from removeFile for example ?
08:34:46 <shapr> with catch?
08:35:12 <shapr> actually, let me check that
08:35:18 <amgine2> emoveFile :: FilePath -> IO ()      
08:35:18 <amgine2>  
08:35:18 <amgine2> removeFile file removes the directory entry for an existing file file, where file is not itself a directory. The implementation may specify additional constraints which must be satisfied before a file can be removed (e.g. the file may not be in use by other processes).  
08:35:18 <amgine2>  
08:35:18 <amgine2> The operation may fail with:  
08:35:20 <amgine2> HardwareFault A physical I/O error has occurred. [EIO]  
08:35:22 <amgine2> InvalidArgument The operand is not a valid file name. [ENAMETOOLONG, ELOOP]  
08:35:24 <amgine2> isDoesNotExistError / NoSuchThing The file does not exist. [ENOENT, ENOTDIR]  
08:35:26 <amgine2> isPermissionError / PermissionDenied The process has insufficient privileges to perform the operation. [EROFS, EACCES, EPERM]  
08:35:30 <amgine2> UnsatisfiedConstraints Implementation-dependent constraints are not satisfied. [EBUSY]  
08:35:31 <amgine2> InappropriateType The operand refers to an existing directory. [EPERM, EINVAL]
08:35:33 <amgine2> yeah i'm not sure if that's acctually needed
08:35:56 <shapr> yah, I was just looking at that
08:36:43 <shapr> I'd like a lambdabot plugin that searches the GHC haddocks
08:42:28 <amgine2> so how coulod one catch that ?
08:42:35 <amgine2> z <-removeFile
08:42:50 <amgine2> hmmm
08:43:04 <amgine2> if (isPermissionError z) ?
08:43:57 <shapr> @type catchJust
08:44:27 <shapr> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html#v%3AcatchJust
08:46:35 <Marvin--> yeah, catchJust is neat
08:47:01 <Marvin--> or you can use the try function and a case distinction
08:47:03 <amgine2> hmmm
08:47:09 <amgine2> i'm slightly confused
08:47:12 <amgine2> so if removeFile fails
08:47:18 <amgine2> it throws an IOError ?
08:47:29 <Marvin--> right
08:47:44 <amgine2> but if it succseeds it just results in IO () ?
08:47:53 <Marvin--> yep
08:48:03 <amgine2> ahhh that would explain something
08:48:10 <amgine2> and if i wish to make this work i do this ?
08:48:28 <amgine2> what would be the syntax ?
08:48:40 <amgine2> delCache []          = do logMessage "Done clearing jar cache files. Try running the hack again" 
08:48:40 <amgine2>               delCache (f:files)   = do result <- removeFile f 
08:48:40 <amgine2>                                         if (isPermissionError result) 
08:48:40 <amgine2>                                           then logMessage ("...deleteing " ++ f) 
08:48:40 <amgine2>                                           else logMessage ("...Error. Permission denied for " ++ f) 
08:48:40 <amgine2>                                         delCache files     
08:48:43 <amgine2> this is what i have now
08:48:45 <amgine2> it dosen't work
08:49:15 <shapr> hi Leimy 
08:49:21 <Leimy> hello
08:50:13 <Marvin--> amgine2: no, result will be () or it will not execute the code after it at all because you haven't caught the exception
08:50:36 <amgine2> Marvin-- i figured after you said it either results in () or IOError ()
08:50:44 <amgine2> so what would be the correct syntax ?
08:50:50 <Marvin--> amgine2: it *throws* an IOError or *returns* ()
08:51:00 <amgine2> i see
08:51:01 <amgine2> ok
08:51:07 <amgine2> so i must place it in a catch block ?
08:51:36 <Marvin--> amgine2: catch (removeFile f) $ \e -> ...
08:52:13 <amgine2> ok now that's a bit to much for me
08:52:16 <amgine2> care to explain it ?
08:52:24 <amgine2> what is \e ?
08:52:48 <shapr> it means an anonymous function that takes the error and does something with it
08:53:06 <shapr> have you used the Maybe an Either datatypes?
08:53:12 <amgine2> once
08:53:15 <amgine2> but i forget
08:53:39 <shapr> data Maybe a = Just a | Nothing
08:53:46 <amgine2> yeah
08:53:48 <shapr> it's a way to represent a failing computation
08:53:52 <amgine2> it's another way of handling exceptions
08:53:57 <amgine2> ok
08:53:57 <shapr> yes
08:54:01 <amgine2> how can that help me ?
08:54:07 <shapr> fromMaybe
08:54:22 <Marvin--> you could also use try:   result <- try (removeFile f) ; case result of { Left exc -> ... ; Right _ -> ... }
08:54:22 <shapr> fromMaybe 1 (read "a" :: Int)
08:54:53 <shapr> that's a standard idiom in Haskell, where you have two functions, one to call in case of success, one to call in case of failure
08:55:22 <shapr> fromMaybe returns a default value 1 if the result of the function (read "a" :: Int) is Nothing
08:55:28 <Marvin--> er, except that read doesn't return Maybe
08:55:34 <shapr> (actually the read throws an error, but we're ignoring that in this imaginary world)
08:55:43 <Marvin--> oh, imaginary world, check
08:55:46 <amgine2> i see
08:55:46 * shapr grins
08:55:47 <amgine2> ok
08:55:51 <Marvin--> shapr: but then you should write read "a" :: Maybe Int
08:55:52 <amgine2> so i have 3 ways of doing this ?
08:55:56 <amgine2> catch
08:56:02 <amgine2> try
08:56:05 <amgine2> fromMaybe ?
08:56:16 <Marvin--> fromMaybe won't help you, since this is IO errors
08:56:18 <shapr> sorry, I was just talking about fromMaybe to demonstrate the idiom
08:56:24 <amgine2> i see
08:56:28 <amgine2> i think lol
08:56:33 * shapr grins
08:56:38 <amgine2> hey
08:56:42 <amgine2> i am learning :)
08:56:46 <Marvin--> and try is defined in terms of catch
08:56:59 <shapr> switchyFunction (\success -> do stuff) (\failure -> do stuff)
08:57:19 <amgine2> there is a switchyFunction ?
08:57:47 <shapr> and you have idiomatic switchyFunctions like that for Exception, Error, Either, and Maybe
08:57:48 * shapr thinks
08:57:57 <shapr> wait, didn't Exception and Error get unified in ghc6?
08:57:59 <amgine2> what does idiomatic mean ?
08:58:10 <shapr> it means it's a standard well-known pattern
08:58:17 <amgine2> ok
08:58:24 <shapr> @wn idiom
08:58:24 * amgine2 needs a coffee
08:58:26 <lambdabot> *** "idiom" wn "WordNet (r) 2.0"
08:58:26 <lambdabot> idiom
08:58:26 <lambdabot>      n 1: a manner of speaking that is natural to native speakers of a
08:58:26 <lambdabot>           language [syn: {parlance}]
08:58:26 <lambdabot>      2: the usage or vocabulary that is characteristic of a specific
08:58:28 <lambdabot>         group of people; "the immigrants spoke an odd dialect of
08:58:30 <lambdabot>         English"; "he has a strong German accent" [syn: {dialect},
08:58:32 <lambdabot>          {accent}]
08:58:34 <lambdabot> [5 @more lines]
08:59:10 <bring> sort of: Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
08:59:36 <bring> and Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
08:59:48 <amgine2> ok
09:00:07 <amgine2> be back later
09:00:12 <bring> and IOErrors are a special case of exceptions
09:00:32 <shapr> ok, that's good to know
09:00:41 <bring> or, well
09:01:00 <bring> Control.Exception.catch can catch them all anyway
09:02:34 <bring> (catchJust ioErrors) is equivalent to Prelude.catch
09:14:44 * Marvin-- complificates his LaTeX code *sigh*
09:19:08 <monotonom> You can always write macros to simplify things.  Just like programming.
09:20:38 <ibid> nontrivial latex macros are scary
09:23:02 <Marvin--> it's all this mixing of typewriter font and math mode that scares me
09:23:08 <Marvin--> I don't think macros would help
09:26:57 * Marvin-- decides to make dinner instead
09:51:33 * shapr sends reminder emails asking for prices to the licensed Tyan resellers in sweden
09:54:25 <shapr> any suggestions for unit testing WASH?
10:00:48 <shapr> hey stepcut!
10:01:04 <shapr> did I already show my email searchy?
10:01:32 <shapr> I wonder why toCalendarTime eval to IO CalendarTime
10:02:55 <Igloo> It's because it needs to know the timezone isn't it?
10:03:22 <shapr> oh
10:03:38 <shapr> wait, that doesn't make sense because formatCalendarTime takes a TimeLocale
10:05:03 <shapr> stepcut: how's the parsing from socket going?
10:05:16 <shapr> are you actually writing a Haskell tcp/ip stack?
10:06:08 <stepcut> shapr: its going ok
10:06:08 <liiwi> sproing
10:06:09 <shapr> Igloo: I think you're right, toUTCTime isn't IO
10:06:15 <shapr> hei liiwi 
10:06:19 <liiwi> hej hej
10:06:26 <stepcut> shapr: I am just write an AIM library in haskell, nothing too fancy
10:06:37 <shapr> any code to show?
10:06:59 <stepcut> shapr: not yet, maybe next week
10:07:02 <shapr> ok
10:07:38 <stepcut> shapr: any more questions about WASH?
10:07:38 <shapr> I'm tempted to start a tcp/ip stack for hOp, but I wonder if it's more work than I think.
10:16:27 <SyntaxNinja> does wash have any kind of shared memory model, like JavaSpaces or anything?
10:17:46 <shapr> what does JavaSpaces do? distributed naming?
10:19:17 <wagle> JavaSpaces is Linda, more or less
10:19:27 <wagle> (i believe)
10:19:27 <SyntaxNinja> shapr: no, like an object blackboard
10:19:47 <SyntaxNinja> maybe java spaces is defunct, can't find the web page, TSPaces is similar (IBM)
10:20:24 <Marvin--> Linda is cool
10:20:43 * Smerdyakov boo's shared memory! :D
10:21:01 <Smerdyakov> That is, it should all be shared in the first place.
10:21:17 <shapr> We are the JavaSpaces, your ass will be simulated.
10:21:27 <wagle> maybe its all jini now
10:22:36 <SyntaxNinja> Smerdyakov: are you booing protected memory
10:22:43 <SyntaxNinja> wagle: that's what i was thinking. faq doesn't say anything. how lame
10:22:55 <Smerdyakov> SyntaxNinja, I sure am. What a waste and needless complication.
10:22:59 <SyntaxNinja> real clever to let a page like that expire and leave no info about where to find the technology
10:24:37 <wagle> jini page at sun says javaspaces technology is included as part of jini
10:25:45 <wagle> http://java.sun.com/developer/products/jini/index.jsp
10:29:02 <SyntaxNinja> heh. thanks.   I don't know how I missed that, since I was looking at that page.
10:29:24 <Smerdyakov> Why do you want separate address spaces, SyntaxNinja?
10:29:26 <Marvin--> real clever of ya ;)
10:29:38 <SyntaxNinja> Marvin--: shuddup, dude
10:29:47 * Marvin-- giggles and scampers off to his food
10:30:03 <SyntaxNinja> Smerdyakov: I'm going to overwrite your memory!
10:30:27 <Smerdyakov> SyntaxNinja, not if I prove you can't!
10:30:36 <SyntaxNinja> enough about me, let's talk about WASH
10:31:00 <shapr> yay WASH!
10:31:33 <shapr> so, what sort of features are you wanting?
10:32:16 <Smerdyakov> Well, I tried to have a serious discussion with SyntaxNinja, but apparently he declined the offer.
10:32:39 <SyntaxNinja> Smerdyakov: I don't think your comments are relevant to my question.
10:32:46 <Smerdyakov> SyntaxNinja, what question?
10:32:58 <SyntaxNinja> read the log
10:33:20 <Smerdyakov> If you're talking about the question on how to do shared memory in Haskell, I never claimed to be addressing that question.
10:33:36 <Smerdyakov> It just made me think of another possible interesting conversation.
10:34:29 <Smerdyakov> So, you can decide to enter into it or not, but you can't claim that I'm breaking a social rule by inviting you.
10:34:42 <SyntaxNinja> Smerdyakov: relax. I claimed no such thing.
10:35:02 <Smerdyakov> SyntaxNinja, then why did you say "I don't think your comments are relevant to my question"?
10:35:22 <SyntaxNinja> I was explaining why I declined to enter into your tangent
10:35:56 <Smerdyakov> The tangent asked why you wanted shared memory with separate address spaces, but you haven't answered that.
10:36:51 * shapr wonders how to make sort clickies in WASH
10:37:51 <stepcut> sort clickies?
10:38:37 <shapr> column headers that do sort descending/ascending 
10:39:04 <SyntaxNinja> shapr: I sorta want a model like TSpaces, where I can store and retrieve data safely across multiple threads and sights. "TSpaces acts as a reminder service, carries out any tasks that you assign to it, reports incoming messages and delivers outgoing messages, and notifies you of any events in which you're interested. By adding additional client applications, TSpaces can be used as a universal print service, email service, pager service, remote co
10:39:37 <shapr> that sounds more like Si's HAIFA
10:39:58 <SyntaxNinja> Smerdyakov: maybe I don't want separate address spaces, but if you want me to follow you on a tangent, you'll have to be more compelling :)
10:40:20 <SyntaxNinja> Smerdyakov: so please explain what you propose and how it's interesting or relates to my question.
10:40:28 <Smerdyakov> SyntaxNinja, if you don't want separate address spaces, then I have nothing else to say. :)
10:41:18 <shapr> HAIFA is sort of like a service dispatcher
10:45:07 <SyntaxNinja> shapr: link?
10:45:19 <shapr> I don't think any information about it has been published
10:45:26 <shapr> Si\: you around?
10:45:43 <shapr> what I've learned is primarily from conversations with Si
10:45:54 <SyntaxNinja> I found one of those on google heh
10:46:09 <shapr> this it source to my email searching thingy http://shapr.homelinux.net/~shae/ProtoWASH.hs
10:46:20 <shapr> it's very small, I'm writing the actual email display part right now
10:46:26 <SyntaxNinja> it's a haskell tool?
10:46:47 <shapr> HAIFA is, yes.
10:47:10 <shapr> it's sort of like some of J2EE and/or Zope in Haskell
10:47:52 <shapr> you have .har files that work like J2EE's .war files, and the Haskell Application Container is much like the EJB container
10:51:56 <SyntaxNinja> strange. can't find it.
10:52:15 <shapr> I don't think there's any published info about it
10:52:19 <shapr> you gotta ask Si\ when he's awake
10:52:25 <SyntaxNinja> I think I find all the guys named Haskell who live in haifa
10:52:30 <shapr> heh :-)
10:52:45 <Si\> huh, who wants me?
10:52:49 <shapr> heyy!
10:53:11 <SyntaxNinja> so... regale us with tails of HAIFA
10:53:31 <Si\> ok, once upon a time there was this guy called Si
10:53:41 * shapr goes to a watch cheese melt as a spectator sport
10:53:49 <Si\> Si was not satisfied with the current interoperability solutions in Haskell
10:53:55 * shapr grins
10:54:05 <SyntaxNinja> shapr: shush, I'm trying to hear Si\
10:54:13 <Si\> ...actually that's a total lie, I didn't have a clue what interop was when I started...
10:54:52 <Si\> anyway, I started to created a framework for doing text based interoperability in Haskell
10:54:58 <Marvin--> yay, lies
10:55:13 <Si\> a lot of it based around SOAP and WSDL, but more generic
10:55:38 <Si\> HAIFA itself is a system for generically representing an interop call
10:55:44 <SyntaxNinja> would you compare it to a system like TSpaces (read about 20 minutes ago)
10:56:55 <Si\> I don't know to be honest
10:57:57 <Si\> the only thing that would be like it in my project is HAIFA application container; HAC
10:58:49 <Si\> what that does is it encapsulates a number of applications and call protocols and uses the protocol plugins to build generic calls which it chucks at a relevant application plugin and gets a return
10:58:59 <Si\> which is then transmitted back over the network
10:59:32 <Si\> I suppose you could implemented something like that using HAC
10:59:38 <Si\> (TSpaces)
11:00:09 <Si\> Think of HAC of being to interoperability what Tomcat is to webpages
11:01:35 <Si\> sound anything like what you're looking for?
11:09:04 <SyntaxNinja> soudns pretty neat. i don't know what i'm looking for yet, I just feel that I will have a bunch of processes sharing a bunch of data
11:10:50 <Si\> I think I'll updated my website and put some of the diagrams about the thing up, cuz a picture tells a thousand words.
11:14:21 <SyntaxNinja> Si\: cool!
11:16:32 <shapr> wow, that really was cool cheese
11:21:00 <shapr> stepcut: do you have any WASH demo code?
11:37:26 <shapr> hi Heffalump 
11:37:29 <Heffalump> hiya
11:37:30 <Si\> ok, I've put up a bit about it here; http://www.dcs.shef.ac.uk/~u1sf/haifa.html
11:38:50 <Marvin--> hey munchkin
11:38:55 <shapr> looks nice
11:40:56 <Heffalump> who you calling a munchkin? :-p
11:41:33 <Marvin--> :-)
11:42:03 <Heffalump> better than having a machine called sjogren
11:43:34 <monotonom> Both are better than having a user name identical to a machine name.
11:43:36 <Si\> incidently shapr; I don't suppose you had any luck with the client yet?
11:43:40 <Marvin--> the machine isn't called sjogren, that's just the stupid dns crap that I don't have any control of :-/
11:44:11 <monotonom> (Is it human? Is it machine? Half of both? ...)
11:44:14 <shapr> Si\: still don't have a google key
11:44:24 <Heffalump> what makes you think I control my machine name? :-)
11:44:46 <Marvin--> nothing, I just think it's a fun name :)
11:44:57 <Si\> I to do a general release of it, but I don't think I can with HXT being so messy atm
11:45:19 * Heffalump quite likes it too
11:45:40 <Gowilla> This one's quite nice, too
11:45:56 <Marvin--> yep :)
11:47:24 <shapr> stupid question, how do I make a boring old link with WASH?
11:58:49 * Marvin-- ponders
12:02:06 <stepcut> shapr: hlink
12:03:02 <stepcut> hlink "http://www.n-heptane.com/" (text "a link to my website") 
12:03:04 <stepcut> i think...
12:11:08 <Marvin--> time to call up some people and figure out where they went drinking
12:13:29 <Smerdyakov> The bar
12:13:49 <Marvin--> gee, you may have a point
12:14:00 <Heffalump> what's the collective name for terminals and nonterminals in a CFG?
12:14:21 <Cale> Heffalump: symbols?
12:14:22 <Marvin--> er...symbols?
12:14:26 <Heffalump> that's the bunny :-)
12:14:27 <LittleDan> Would it be breaking the definition if you had mutable variables in a single-assignment language?
12:15:45 <LittleDan> hello? Anyone?
12:15:58 <Cale> LittleDan: breaking what definition?
12:16:10 <LittleDan> of single-assignment
12:17:11 <Cale> Somewhat. I suppose that it depends on how you look at it, and how the mutable variables are treated. Certainly those variables aren't single-assignment.
12:25:11 <LittleDan> I'm thinking of having a kind of cell that would hold something, and what it holds could be changed using side-effects
12:25:30 <LittleDan> would that be un-functional?
12:29:37 <LittleDan> Or could that be simulated?
12:29:38 <Cale> These things aren't really cut and dried. Haskell has the ability to deal with side-effects and mutable variables through the use of monads. So there are ways to formalise the interface to side-effects in such a way that you don't break referential transparency as a whole. One important bit here is that putting something in an MVar, for instance is not treated the same way as declaration of proper variables (they have very different sem
12:29:38 <Cale> antics).
12:30:08 <LittleDan> what's an MVar?
12:30:34 <Cale> A mutable variable. Haskell's concurrency stuff has them.
12:30:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.MVar.html
12:31:22 <Cale> Note that the right sides of the function types are typed in IO because they deal with side effects.
12:33:07 <Cale> does anyone else have any opinions here?
12:34:04 <LittleDan> So that's for inter-thread communication?
12:34:09 <Cale> yeah
12:36:08 <LittleDan> How can I find the source code of that module?
12:37:21 <Cale> You might read http://research.microsoft.com/users/simonpj/papers/concurrent-haskell.ps.gz
12:37:48 <Cale> That module is in GHC, so if you want to read their implementation, I'm sure it's around somewhere :)
13:02:01 * shapr boings happily
13:04:16 <shapr> stepcut: thanks
13:12:18 <shapr> hi kinzite, have you been here before?
15:14:02 * Marvin-- yawns
15:15:07 * monotonom hypnotizes Marvin--
15:16:38 <Marvin--> hey!
15:17:26 * Marvin-- watches Scrubs
15:29:38 * XTL yawns
15:30:14 <XTL> And fingers start slipping..
15:34:52 <Marvin--> well done ;)
16:41:06 * themaximus is away: Moo, dinner
17:20:39 * themaximus is away: I'm busy
17:21:29 * themaximus is away: I'm busy
17:24:08 * themaximus is back (gone 00:03:18)
18:48:54 * stepcut adds support for libmysqld to haskelldb
