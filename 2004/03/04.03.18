00:54:56 <reltuk> hmm...so [] is a monad class, but [1] isn't/
00:55:30 <skew> huh?
00:55:38 <skew> the list type constructor is a monad
00:55:50 <reltuk> so lists are monads in general...
00:56:03 <kosmikus> yes
00:56:05 <skew> any monad is a type constructor, kind * -> *
00:59:02 <kosmikus> the symbol [] is used in two different meanings in Haskell: (a) to denote the empty list, and (b) to denote the list type constructor; (a) appears on the value level (i.e. in expressions), and (b) on the type level (i.e. in type signatures or instance declarations)
00:59:48 <reltuk> ahhh, ok
01:01:18 <reltuk> oh...you don't need monad lists for normal lists...you just need them for list comprehensions?
01:01:35 <skew> there are no "monad lists", just lists
01:01:48 <skew> lists are one kind of monad, along with tons of stuff like Maybe and IO and ST
01:01:57 <reltuk> I know, but you don't need lists to be monads unless you want list comprehensions...
01:01:59 <reltuk> or is that wrong
01:02:07 * Si\ didn't know that
01:02:07 <skew> huh?
01:02:07 <kosmikus> you don't need the monad instance of the list type constructor for anything except if you want to use do-notation; list comprehensions are special and built-in
01:02:29 <skew> That's like saying you don't need 12 to be an integer unless you want to find prime factors
01:02:53 <kosmikus> in Haskell 1.4, "list" comprehensions used to work for any monad type, just as do-notation now, but that was abandoned
01:02:56 <reltuk> oh, ok.../me doesn't yet see the use for the do notation
01:03:12 <Si\> isn't do just sugar?
01:03:13 <reltuk> of lists ofcourse
01:03:38 <kosmikus> Si\: yes, but the translation makes use of the fact that the underlying type supports the monad operations
01:03:39 <reltuk> kosmikus, that was probably cool...
01:03:41 <skew> do notation for lists is useful if you are using lists to represent nondeterministic computations
01:04:00 <kosmikus> do-notation and comprehensions are almost isomorphic
01:04:12 <kosmikus> sorry, bad language usage
01:04:17 <kosmikus> they are isomorphic
01:04:27 <kosmikus> but they're almost canonically isomorphic
01:05:02 <reltuk> so why take out the general comprehension and restrict it to lists?
01:05:22 <kosmikus> the error messages were too confusing to Haskell beginners ;)
01:05:25 <skew> confusing error messages and confusing semantics, I think
01:05:29 <reltuk> hehe
01:06:36 <kosmikus> skew: I can't see why the semantics are confusing
01:07:02 <Jerub> I didn't understand do-notation until i saw the definition of >>= and how to translate do foo <- bar;baz using it.
01:07:28 <reltuk> I've seen that definition...I still don't understand it...
01:07:30 <kosmikus> Jerub: that's the best way to understand it
01:07:38 <reltuk> but I think it's just an issue of wrapping my head around it  :)
01:09:04 <skew> kosmikus, comprehension notation suggests the values are something like a collection.
01:09:10 <Jerub> reltuk: do foo <- bar; baz basically means (\foo -> baz) bar, but bar must be evaluated before the lambda is evaluted.
01:09:14 <Jerub> I think at least.
01:10:10 <kosmikus> "do foo <- bar; baz" is equivalent to "[ x | foo <- bar, x <- baz ]" in comprehension syntax
01:10:46 <Jerub> kosmikus: ahh! this would be why the combinator parser paper I read used comprehensions heaps.
01:10:50 <kosmikus> "do foo <- bar; return baz" would be equivalent to "[ baz | foo <- bar ]"
01:13:27 <Jerub> so do notation is *really* just a way of without breaking the functional paradigm, doing a statement-list.
01:13:55 <skew> not quite, it also throws in monadic sequencing
01:14:16 <reltuk> sleep time...
01:14:24 <Jerub> skew: isn't that implicit in the concept of a 'statement-list'
01:14:30 <skew> or, you can think of it as a statement-list polymorphic in the meaning of "sequencing"
01:14:58 <Jerub> I am confused!
01:15:09 <skew> well, do notation can use any monad
01:15:30 <skew> so your "statement-list" can be nondeterministic statements, or statements with continuations, or whatever else you want
01:15:31 <Jerub> does do notation only use a single monad/
01:15:53 <skew> most do statements you write will be in a single monad, but you can use it for any monad
01:16:22 <Jerub> I mean, could I use a Id monad and a IO monad and a State monad all in the same 'do' statement?
01:16:54 <skew> no
01:17:05 <Jerub> okay, that makes more sense to me.
01:17:26 <Jerub> (I've been re-learning haskell from a textbook on the train on my way into my php dayjob)
01:17:37 <Jerub> btw, does the function 'snd' mean anything to you?
01:17:42 <kosmikus> @type snd
01:17:43 <lambdabot> snd :: (a,b) -> b
01:17:53 <kosmikus> selects the second component of a pair
01:17:56 <Jerub> ahh!
01:18:07 <Jerub> of course, that would be why it wasn't explained in the exampe.
01:18:46 <skew> gotta love the free theorems. From that type it's obvious it returns bottom at type b ;)
01:19:03 <Jerub> sorry?
01:20:03 <skew> well, there's only two things a function of type (a,b) -> b can do
01:20:13 <skew> extract the second component or return b
01:20:18 <skew> I mean bottom
01:20:47 <Jerub> whats 'bottom'
01:20:55 <kosmikus> undefined
01:20:57 <skew> because you can do nothing with a value of completely polymorphic type except pass it along
01:21:13 <Jerub> ahh, because otherwise it'd have a class ;)
01:21:13 <Si\> or it could transform b
01:21:25 <skew> yeah, but it doesn't know anything about the type of b
01:21:31 <Si\> true
01:21:58 <skew> and the only functionsof type forall a . a -> a are id and const undefined, and possibly something involving unsafeEvil
01:22:08 <Si\> lol
01:22:15 <kosmikus> `seq` is also quite bad
01:22:23 <Si\> is there such a thing as safeEvil?
01:22:38 <Jerub> @type seq
01:22:38 <lambdabot> seq :: a -> b -> b
01:22:43 <skew> what does `seq` do? I didn't think it broke typesafety
01:22:59 <skew> just messed up the strictness
01:23:01 <kosmikus> no, it doesn't break type safety, but does make the free theorems more complicated ...
01:23:13 <skew> ah, yeah
01:23:19 <kosmikus> it evalutates its first arg to WHNF, and then returns the second
01:23:41 <Jerub> @type WHNF
01:24:07 <skew> well, I must away. I hope the learning Haskell goes well Jerub. Oh, don't wait too long on that @type WHNF
01:24:42 <kosmikus> for example, using seq in a function of type (a,b) -> b you could write a function that will return b as long as a is not bottom; and if a is bottom, returns bottom as itself
01:25:22 <Jerub> kosmikus: ahh, that is a nasty spanner in the works there ;)
01:25:48 <kosmikus> WHNF is short for weak head normal form
01:26:20 <kosmikus> and basically means "evaluate just far enough to know what the top-level constructor of a value is"
03:05:25 <ski> @yow #haskell !
03:05:25 <lambdabot> This TOPS OFF my partygoing experience!  Someone I DON'T LIKE
03:05:25 <lambdabot>  is talking to me about a HEART-WARMING European film..
03:51:28 <BroomStik> can anyone help me with using cygwin
03:51:43 <BroomStik> im trying to run get he gcc package
03:55:20 <saz> why are you trying to run gcc with cygwin?
03:55:39 <BroomStik> to compile c functions
03:55:51 <saz> why did i rad that as ghc?
03:56:00 <saz> er, read
04:01:13 <Riastradh> Why are you asking the Haskell channel?
04:02:28 <BroomStik> cause i know people in here use cygwin,  and just thought i would ask
04:06:26 <Riastradh> Wouldn't it be more useful to ask #cygwin or something?
04:08:23 <BroomStik> i did about 30 mins ago, but no one is answering
06:12:24 <earthy> hm. wikifodder.
06:12:36 <earthy> Simon's cheat sheet for getting fast Haskell code:
06:12:39 <earthy> Rule 1: don't use String I/O.
06:12:45 <earthy> Rule 2: Profile your program.  Find the inner loop.  Look for overloading.      
06:12:48 <earthy> +Squash.  Repeat.  Look for laziness.  Squash.  Repeat.
06:14:43 <Igloo> Something similar is in the GHC users guide
06:15:49 <earthy> doesn't hurt to put it in more places
06:57:50 <Marvin--> hmm... does anyone know how a standard LaTeX abstract env is indented?
06:58:01 <Marvin--> er, know how *much*
06:59:10 <Igloo> It's not obviously in the Companion
06:59:43 <Marvin--> I guess I should just make two envs then, so I get the same spacing
07:00:05 * Marvin-- mutters about department rules
07:00:06 <Igloo> Well, you could look in the .cls
07:00:21 <earthy> it doesn't even seem to be non-obviously in the companion
07:01:17 <Marvin--> wow, abstract behaves differently depending on if you've got titlepage or not? I had no idea
07:04:48 <Marvin--> ah, it appears to just use quotation
08:10:44 <Marvin--> d'oh, stupid me, why don't I just \renewcommand\abstractname instead of defining new environments
08:12:01 <earthy> ;)
08:15:42 <Marvin--> yay, that worked nicely
10:25:59 <mattam> isn't there a standard Monad instance for Either a b ?
10:29:32 <Marvin--> no
10:29:53 <Marvin--> I guess you could make a Monad instance for (Either String), but that's not Haskell98
10:30:28 <mattam> ok
10:30:29 <ski> or just (Either e)
10:30:37 <mattam> i will
10:30:56 <Marvin--> sure, but String would actually be *meaningful* what with the type of fail
10:30:56 <keverets> isn't there?  I thought there was an instance in Data.Either ... Error e => Monad (Either e)
10:31:12 <phubuh> what would the meaning of a Monad (Either a b) be?
10:31:28 <keverets> Oh, Either a b ... my bad.
10:31:48 <ski> ?
10:31:50 <Marvin--> keverets: you're right... still won't work in Haskell98 though
10:32:05 <ski> ( Monad (Either a b) has a kind error)
10:32:07 <mattam> i thought in terms of Either (e :: Error) as you have guessed
10:32:21 <Marvin--> yes, Monad (Either a b) won't work
10:33:01 <mattam> so Error e => Monad (Either e) is glasgow-specific ?
10:33:34 <mattam> Error is already it seems
10:40:38 <mattam> i get an illegal instance declaration, is partial application of type constructors (like Monad (Either Err)) a glasgow exts too ?
10:41:04 <ski> i don't think so
10:41:22 <Marvin--> I think it is
10:41:36 <Igloo> You can't put a concrete type where you've got Err
10:41:40 <Igloo> Has to be a type variable
10:41:41 <ski> though using non-type-var args to the partial application probably is
10:42:13 <mattam> ok
10:45:38 <Marvin--> note that String is an instance of Error, so you could use (Error String) right away
10:49:12 <mattam> but Error is not standard :(
10:49:53 <Marvin--> if you by standard mean haskell98, then no
10:51:07 * Si\ is glad adhering to Haskell 98 was not an aim of his project
10:54:51 <Marvin--> mattam: you could declare your own Error class though, but you couldn't instantiate it with String, you'd have to newtype it
10:55:04 <mattam> i know ;)
10:56:48 <Si\> has there been any word on a new Haskell Standard any time soon?
10:58:03 <Marvin--> it'd be kinda pointless to work on a new standard while the hierarchical libraries are still a moving target
11:00:44 <ahuda> could someone show my how to write a prog that takes a elemet and a list, and removes every other occurance of that element from the list. For instance 5 [1,5,2,5,3,4,5] would give [1,2,5,3,4]
11:00:56 <ahuda> im stuck
11:01:06 <ski> hmm
11:01:07 <Si\> filter (x/=5) l
11:01:20 <ski> should you use explicit recursion ?
11:01:57 <ahuda> don't have too
11:01:58 <Si\> my bad - filter (\x -> x/=5) l
11:02:16 <ski> Si\ : (/= 5) works just as well
11:02:35 <Si\> Ah well, you win some you loose somew
11:02:45 <Si\> guess I can't type and think at the same time
11:03:16 <ski> :)
11:03:25 <ski> ahuda : does that solve your problem ?
11:04:18 <ahuda> ski: what does filter do?
11:04:27 <ski> @type filter
11:04:28 <lambdabot> filter :: (a -> Bool) -> [a] -> [a]
11:04:28 <ahuda> i only need to remove everyother occurance
11:04:39 <ski> filter takes a testing function and a list
11:04:57 <Si\> but I guess what ur in fact asking for something along the lines of f (h:t) n = case h of n -> (f t); _ -> (h:(f t))
11:05:07 <ski> and gives back a list of all the elements of the previous list that tested o'kay with the testing function
11:05:49 <ski> @eval filter even [0,1,2,3,4,5]
11:05:49 <lambdabot> [0, 2, 4]
11:05:51 * Si\ is hoping he has finally typed a valid function the first time
11:06:10 <Marvin--> I think you guys are missing the "every other" part
11:06:45 <ski> ahuda : oh, except the first occurance, you mean ?
11:06:45 <Marvin--> Si\: and I'm pretty sure that you don't mean  case h of n, that'd introduce a new n
11:07:20 <Marvin--> ski: no, he means *every other occurance*
11:07:28 <ahuda> ski: every other occurance
11:07:41 <Si\> dang
11:07:43 <ski> Marvin-- : every other that *which* occurance ?
11:07:47 <Si\> foiled again
11:08:13 * ski looks at ahuda's example again
11:08:18 <Marvin--> ski: "varannan"
11:08:19 <Si\> every other as in it removes the odd numbered elements and not the even
11:08:27 <ahuda> exactly
11:08:31 <Marvin--> ngh. phone
11:08:36 <ski> Marvin-- : aha ! thanks. didn't know that expression
11:08:54 <ski> ok
11:09:18 <ski> so a simple state-machine should probably do, methinks
11:09:21 <keverets> ahuda: why do you wan such a function?
11:09:41 <keverets> sounds like homework.
11:09:52 <ski> keverets : prolly is
11:09:58 <Si\> pass through and extra parameter (a Bool) and invert each time the value is found + remove if True
11:10:07 <ahuda> im studying for a final, and its a practice quesiton
11:10:18 <ski> Si\ : that would work too, yes
11:10:39 * Si\ is wondering if he should give the answer then...
11:11:05 <ski> ahuda : perhaps you want us to make you work for the solution ? :)
11:11:50 <ahuda> i have a final in 50 mins, im trying to get as much done as possible before then :)
11:11:50 <ahuda> its only a practice question for the final
11:12:05 <ski> oh, so soon
11:12:06 <Si\> I'll do you a deal, if you promise to become an experienced Haskell programmed and implement the full SSL standard for HWS-WP for us I'll do it! :D
11:12:15 <ski> haha
11:13:13 <ski> do you see how the rough structure of the solution should look like ?
11:13:26 <ski> (first, recurse on the list, of course)
11:13:28 <ahuda> i promise
11:14:22 <ski> so begin with writing down the start of a base and a recursive case, methinks
11:14:32 <ahuda> everyother element [] = []
11:14:37 <ski> right
11:15:06 <ski> then ?
11:15:47 <ahuda> not sure here
11:15:52 <ahuda> everyother element (e:l) = everyother element l
11:16:07 <ski> depends on how e compares to element, no ?
11:16:08 <ahuda> do i need another function with a bool to toggle
11:16:34 <ski> you *could* do a boolean toggle, *or* another function (without the boolean)
11:16:35 <Si\> you can do it in one simple function, you need 2 switches one way or another
11:17:10 <ahuda> how do i create the new list
11:17:15 <ahuda> thats what im confused on i guess
11:17:23 <ski> anyway, i think you can use a guard (or an if-expression, if you like) to check wheather e is equal to element
11:17:38 <ahuda> everyother element (e:l) = if(e == element) ... everyotherhelp element l
11:18:05 <ahuda> how do i go about building the new list
11:18:11 <ski> (the parenthesis around "e == element" is unnecessary)
11:18:14 <ski> ok
11:18:53 <ski> so if not e == element, then what should we do ?
11:18:53 <ahuda> and if the element is an even occurance, how do i keep the recusrion moving on the to next element
11:19:16 <Si\> if you get the element you want to remove, obviously you simple want to return the function applied to the rest of the list
11:19:28 <ahuda> yea
11:19:42 <ski> but
11:19:55 <ski> you want to remember that you have seen an even occurance, right ?
11:20:24 <ski> if e == element then ... else ...
11:20:37 <ahuda> yea
11:21:11 <ahuda> hmm i don't see how what to do if its not th element
11:21:11 <ski> if we're in the else-branch, then e should not be removed, but we should keep looking for the even occurance in the tail, yes ?
11:21:25 <ahuda> yea
11:21:41 <ski> so, you don't see how to not remove e ?
11:22:56 <ahuda> yea, if i don't remove e, then won't the recusion keep going
11:23:16 <ski> to do that, just return "e : ..the_rest_of_the_answer...", right ?
11:23:56 <ahuda> everyother element (e:l) = if e == element then everyother element l else e : everyother element l?
11:24:07 <ski> yeah
11:24:14 <ski> the else-branch seems ok
11:24:17 <ahuda> so what the toggle now
11:24:25 <ahuda> so what about the toggle now
11:24:27 <ski> the then-branch is almost ok
11:24:31 <ski> right
11:25:17 <ski> if we're in the then-branch we should remember that we've already removed an element, so we shouldn't remove the next (that is == element)
11:25:29 <ski> hmm
11:25:48 <ski> actually, didn't you say to remove odd elements, but not even ?
11:25:57 <ahuda> basically
11:26:02 <ski> yeah, ok
11:26:19 <ski> everyother element (e:l) = if e == element then e : everyother element l else e : everyother element l
11:26:32 <ski> we shouldn't remove the e in the then-branch
11:26:47 <ski> but the next one we stumble upon should be removed
11:27:04 <ski> so we still have to remember that somehow
11:27:20 <ahuda> yea, need some toggle somewhere
11:27:28 <ahuda> in the if-then
11:27:33 <ski> so, if everyother removes odd elements
11:27:46 <ski> we could make a function that removes even elements
11:28:12 <ski> so the everyother function could call that other function in the then-branch
11:28:19 <ski> do you see how that would work ?
11:28:34 <ahuda> it removes the odd occurances of the element
11:28:46 <ski> everyother does that, yes
11:29:25 <ahuda> why would we want to remove the even elements in that funciton
11:29:33 <ski> well
11:29:43 <ski> if we want to remove the odd elements
11:31:00 <ski> then, when the first even element is passed by, then *of the elements that are left in the tail*, if we count from where we are now, the even ones have become odd, while the odd ones have become even
11:31:19 <ski> take   e.g. [1,5,2,5,3,4,5]
11:31:31 <ski> when we skip past the first 5
11:31:40 <ski> the tail looks like [2,5,3,4,5]
11:32:03 <ahuda> can i do this:
11:32:04 <ahuda> everyother1 element (e:l) = if e == element then e: everyother2 element l else e : everyother2 element l
11:32:04 <ahuda> everyother2 element (e:l) = if e == element then everyother1 element l else e : everyother1 element l
11:32:14 <ski> yes
11:32:17 <ski> good !
11:32:27 <ski> you see ?
11:32:29 <ahuda> i got a program error when i tried to run
11:32:33 <ski> hmm
11:32:47 <ski> you still need base cases for both ones, of course
11:33:02 <ski> should be easy to add, no ?
11:33:30 <ski> also, everyother2, should call itself in the else-branch, no ?
11:34:15 <ahuda> yea
11:34:44 <ski> (because, in the else branch, we didn't encounter the element we want to remove even occurances of, so we should still keep looking for *even* occurances)
11:34:59 <ski> does it work as expected now ?
11:36:14 <ahuda> yep
11:36:15 <ahuda> thanks
11:36:37 <ski> ok, i guess that you see the two functions looks almost the same
11:37:15 <ski> so, instead of calling everyother1 and everyother2, one could instead have everyother True and everyother False
11:38:04 <bring> anyone know why "splice [d| f x = x + 1 |]" (Template Haskell) produces a parse error in GHC stable?
11:38:12 <ski> but this way of calling back and forth between a couple of functions are sortof more general and at times more readable
11:38:47 <Igloo> You want $, not splice
11:38:58 <Igloo> And no space after it
11:47:29 <bring> it doesn't like that either, btw, "splice [d| f x = x + 1 |]" is straight from Notes on Template Haskell Version 2
11:47:53 <bring> what is the right way to do a declaration splice?
11:48:20 <bring> (in ghc 6.2.20040309)
11:50:22 <Igloo> Are you doing it at the top level?
11:50:34 <bring> yes
11:50:48 <Igloo> Using -fth or -fglasgow-exts?
11:51:05 <bring> -fth
11:51:39 <bring> I get: "TopLevelSplice.hs:1: parse error (possibly incorrect indentation)"
11:51:52 <bring> File is just "splice [d| f x = x + 1 |]"
11:52:58 <Igloo> $([d| f x = x + 1 |]) works for me
11:54:25 <bring> me too :)
11:54:39 <bring> didn't use the parantheses with $
11:54:48 <bring> thanks
11:55:05 <bring> is the current syntax documented anywhere?
11:55:44 <bring> I should have tried that, sorry about that
12:00:09 <Igloo> I imagine it's in the users guide, although I'm not sure OTTOMH
12:15:46 <bring> you are right again
12:15:58 <bring> I'm just going to shut up now
12:17:31 <bring> for some reason I didn't think to look in the user's guide for documentation :)
12:50:01 <liw> off-topic question: is the specification at http://liw.iki.fi/liw/temp/wordfreq.txt clear and unambigous? i.e., if different people read that specification and write their own program, will the output of each program be bit by bit identical? (assuming no bugs in the programs, of course)
12:50:23 <phubuh> yay, lawyering!
12:50:26 <liw> I'm asking here because #haskell is known to have all the smart people  :)
12:51:29 <bring> no mention of what separates words ([^A-Za-z0-9]?)
12:51:42 <andersca> hey liw
12:51:54 <liw> andersca, greetings
12:52:01 <phubuh> A word consists of the ASCII letters A through Z and a through z
12:52:01 <phubuh> (convert upper case to lower case) and digits 0 through 9.
12:52:22 <liw> bring, hm, you think it should be mentioned explicitly? I might as well
12:52:53 <andersca> liw: haven't seen you for some time
12:52:56 <phubuh> <anal>you should specify what encoding N is given in the command line</anal>
12:53:13 <andersca> phubuh: should be locale encoding
12:53:46 <ibid> liw: "the newline character" is ambiguous
12:53:48 <liw> better?
12:53:50 <phubuh> do locales specify base? :-)
12:54:00 <bring> where do 0-9 come in the alphabet?
12:54:21 <liw> ibid, true
12:54:38 <ibid> liw: specify LINE FEED, for example
12:55:06 <liw> bring, I added "ASCII digits", is that clear enough?
12:55:36 <ibid> liw: alphabetical ordering is ambiguous wrt digits
12:55:52 <ibid> which was bring's point, i presume
12:56:06 <ibid> liw: if you want ASCII code ascending order, say so :)
12:56:26 <bring> yes, that was what I meant, should have said that
12:56:46 <ibid> bring: you were clear enough imho :)
12:56:50 <liw> hm, I wonder how I should phrase this
12:57:12 * ibid is by now thinking formal methods:)
12:58:10 <liw> "words with the same frequency should be ordered in character code order" -- is that better? suggestions?
12:58:19 <ibid> ascending or descending?
12:58:42 <phubuh> just for the hell of it, you should specify some absurd back-up ordering.  "words with the same frequency are ordered increasingly by the product of each ASCII character's 7-logarithm (modulo 188)"
12:58:50 <ibid> i'd also add "lexicographical" somewhere there:)
12:59:13 <ibid> liw: why the exercise?
12:59:41 <bring> why not EBCDIC instead of ASCII? :)
12:59:48 <liw> "words with the same frequency should be ordered in ascending order according to character code"
12:59:57 <phubuh> oh, hey, i actually planned on saying EBCDIC, but i forgot!
13:00:09 <liw> ibid, I want to compare some programming language implementations speedwise
13:00:42 <liw> bring, EBCDIC is dead, as far as I care (but I may do a variant on this spec that specifies Unicode)
13:01:02 <ibid> liw: i'm pretty sure that lexicographic ordering is the only one that makes sense in that context, but it might still be good to mention it
13:01:14 <bring> I agree
13:01:22 <ibid> with who? :)
13:01:36 <liw> I'm still trying to figure out what "lexicographic" means...
13:01:42 <bring> I'm just very agreeable
13:01:54 <bring> with using lexicographic ordering actually
13:02:33 <ibid> liw: dictionary ordering: compare pairs of characters starting from the leftmost characters and stop at first mismatch
13:02:57 <bring> and shorter comes first
13:03:11 <liw> yeah, I found it now - not all dictionaries order words that way, though
13:03:30 <liw> but I'll add the word anyway
13:03:41 <ibid> liw: as opposed to, for example, numeric ordering (compute the numeric value of the strings and compare them)
13:03:43 <liw> there, better?
13:04:33 <ibid> (numeric value being, of course, what we get if we assume a base-256 representation of numbers with characters being digits)
13:04:50 <ibid> better, yes
13:05:10 <liw> #haskell is the second irc channel I ask to review this spec, you're marvelously nitpicky :)
13:05:15 <ibid> i'd spell out LINE FEED, as it is the official name
13:05:19 <ibid> :)
13:05:24 <ibid> what was the first?
13:05:38 <liw> spelt out
13:06:03 <liw> my "home channel" on ircnet, where most of my Finnish friends are
13:06:08 <ibid> ok
13:06:29 <ibid> such channels are not very nitpicky in general, even if occupied by language lawyers :)
13:06:32 <liw> known to be nit pickers occasionally, but not at #haskell level :)
13:06:55 <ibid> saivareenpoimija
13:06:57 <ibid> nice :)
13:07:48 <liw> okay, next I guess I need to make a test and benchmark harness for this that exercises the programs with various inputs and times them and makes a graph of the result
13:08:05 <liw> (I have C, Python, and shell script versions, some day I may ask for a Haskell version :)
13:08:24 <ibid> hmm, i just realized you are on #haskell
13:08:32 <ibid> how come? :)
13:08:48 <liw> <liw> I'm asking here because #haskell is known to have all the smart people  :)
13:08:58 <ibid> it has to be more than that :)
13:09:12 <liw> also, Haskell is one of the languages I'm interested in
13:09:17 <ibid> right
13:09:51 <liw> the basic idea being that I want to pick a new "default" language to replace Python, and speed is one of the factors
13:09:59 <liw> (execution speed)
13:10:03 <ibid> looked at cyclone?
13:10:17 <liw> I have not yet looked at any languages
13:10:21 <bring> wouldn't it just be easier to give a formal specificatio
13:10:25 <ibid> meant, are you aware of it
13:10:38 <ibid> 22:57  * ibid is by now thinking formal methods:)
13:10:45 <liw> ibid, if cyclone is the "C but supposedly safer" then yes, and I'm probably not going to be interested :)
13:10:52 <ibid> yes
13:11:10 <ibid> but i was thinking more of its "C but with cool ML-like features" side :)
13:11:23 <ibid> like tagged unions with pattern matching
13:11:23 <liw> bring, I don't know any formal methods for specification, and even if I did, I don't want the people writing the benchmark implementations to have to know
13:11:25 <ayrnieu> yay, pattern-matching.
13:11:41 <liw> ibid, I wasn't told about those... oh well, I'll have a look one day
13:12:31 <ibid> also, if you are looking for speed, i'd take a serious look at OCaml if i were you
13:12:40 <liw> yes, that is on my list
13:12:49 <ibid> never done anything with it but i have an idea of what it is :)
13:13:11 <ibid> and of course, i have n+1 cool pl projects in the back burner :)
13:13:12 <Igloo> If you want excessive pickiness, then you should specify that word length > 0
13:13:52 <liw> Igloo, done
13:14:10 <ibid> one of my pl projects is a strict haskell which clearly tries to hide its origin :)
13:14:14 <Igloo> I think the first sentence of the second paragraph is technically wrong too, and should be s/consists of/contains only/ or something
13:14:41 <ibid> like, not monads but actions, not functional but multi-paradigm etc etc etc :)
13:14:49 <ibid> make it sound cool to the better Java weenies
13:16:46 <ibid> bnfc is cool
13:17:42 <andersca> yeah
13:17:51 <phubuh> tralala lilla mÃ¥ntuss
13:20:30 <ibid> hö-öns förjusande mö
13:20:35 <ibid> bedtime
13:21:18 <phubuh> night!
13:21:40 <liw> Igloo, I attempted an improvement; unless I broke something, I think this is going to be the final version for now
13:22:29 <ibid> "editing is a rewording activity" - (today's quiz: who wrote that?)
13:22:54 * liw thanks everyone for nitpicking
13:26:25 <shapr> greetings
13:27:02 <liw> shapr, greetings
13:27:42 <shapr> hei liw, ltns
13:27:50 <shapr> what's going on?
13:28:08 <SyntaxNinja> hihi shapr
13:28:28 <shapr> salutations Ninja Jones
13:28:55 <shapr> so, what did I miss?
13:30:20 <shapr> any exciting developments in the world of Haskell?
13:31:05 <shapr> liw: are you learning Haskell?
13:31:24 <liw> shapr, not yet, at least
13:33:47 <shapr> liw: just enjoying the purity? :-)
13:34:22 <Marvin--> ello shapr
13:34:27 <liw> shapr, I came here to ask people to nit pick on http://liw.iki.fi/liw/temp/wordfreq.txt
13:34:36 <shapr> oh, I got the @prelude data from tmoertel
13:35:16 <shapr> oh, neat
13:35:46 <shapr> are you starting a paradigm agnostic benchmark collection?
13:37:11 <liw> shapr, something like that
13:38:04 <shapr> sounds nifty, do you have anything else?
13:38:20 <shapr> we had some recent discussion about a benchmark wiki
13:38:31 <shapr> where you'd have two versions of a program for each language, one for clarity, one for speed
13:39:06 <liw> shapr, nope, but I'll make more (to test things that are important to me, if not to anyone else)
13:39:11 <liw> some day, I'm not in a hurry
13:40:49 <liw> now, however, I'm going to bed
13:40:55 * bring curses cut'n'paste between different GUI toolkits
13:41:31 <andersca> bring: what toolkits?
13:41:38 * andersca gets ready to blame everything except gtk
13:41:43 <bring> esp. to OpenOffice
13:42:22 <phubuh> you haven't felt true cut'n'paste horridness until you've used squeak in X
13:42:40 <bring> but emacs-X11 (whatever arcane toolkit that uses) to Mozilla is sometimes weird to
13:43:20 <andersca> bring: emacs is broken, clipboard wise
13:43:21 <bring> I think I am using programs with 5 different toolkits right now
13:43:27 <shapr> xemacs is less broken
13:43:43 <andersca> gtk is best though
13:43:47 <shapr> anyways, I have two 'paste' bindings in xemacs, one for paste from selection, and one for paste from clipboard
13:43:48 <andersca> ;)
13:44:16 <shapr> and I've configured xemacs to write to the clipboard when copying/killing
13:47:01 <shapr> bring: hey, do you have any side-by-side examples of SQL and the equivalent HaskellDB code?
13:47:32 <bring> we've been meaing to put something like that on the web page, but no, not right now
13:47:42 <bring> you can print the generated SQL though
13:47:54 <bring> put it's not exactly pretty all the time
13:49:02 <bring> just do show on a Query (Rel r)
13:49:44 <bring> but we will write something like that (unless you want to donate an example to us that is)
13:49:48 <bring> :)
13:51:04 <themaximus> Greeting Shapr, person with IPv6
13:51:08 <shapr> if I end up with some, I will.
13:51:09 <themaximus> :-)
13:51:16 <themaximus> *Greetings
13:51:18 <shapr> there's no place like ::1
13:51:31 <themaximus> So I see.
13:51:54 * Igloo bounces
13:51:59 <themaximus> @help
13:52:00 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
13:52:05 <themaximus> okay, lamda
13:52:13 <themaximus> @listcommands
13:52:13 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions
13:52:13 <lambdabot> ,"del-definition","det","devils","dict","dict-help","dummy","dump","dynamic
13:52:13 <lambdabot> load","dynamic-reload","dynamic-unload","easton","echo","elements","eval
13:52:13 <lambdabot> ,"foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock
13:52:13 <lambdabot> ,"jargon","join","karma","karma+","karma-","learn","leave","listchans",
13:52:14 <lambdabot> listcommands","listmodules","lojban","moo","more","msg","part","prelude
13:52:16 <lambdabot> ,"quit","reconnect","resume","seen","set-fuel","shapr","state","topic-cons
13:52:18 <lambdabot> ,"topic-init","topic-snoc","topic-tail","topic-tell","type","vera","web1913
13:52:20 <lambdabot> ,"wiki","wn","world02","yow"]
13:52:25 <themaximus> It would be better in a PM
13:52:35 <themaximus> Just to let the devs know...
13:52:39 <Igloo> Somethings eating a char per line there
13:52:53 <themaximus> As not to disturb the chan, which I felt I just did
13:52:56 <Igloo> s/gs/g's/
13:52:59 <themaximus> @shapr
13:52:59 <lambdabot> needs sleep
13:53:09 * themaximus puts shapr to sleep
13:53:28 <themaximus> @seen Lemmig
13:53:28 <lambdabot> I haven't seen Lemmig
13:53:30 <themaximus> erps
13:53:35 <themaximus> @seen Lemmih
13:53:35 <lambdabot> Lemmih is in #haskell.
13:53:45 <themaximus> Oh, HI LEMMIH!!! :-d
13:53:48 <themaximus> *D
13:54:03 <themaximus> @jargon
13:54:16 <themaximus> What does it do....?
13:54:32 <Igloo> Looks things up in the Jargon file
13:56:09 <Lemmih> Hello themaximus.
13:56:23 <themaximus> Who is it?
13:56:30 * themaximus picks up his IRC-phone
13:56:36 <themaximus> Oh, Hi Lemmih.
13:56:52 * themaximus 's real phone rings
13:57:05 <themaximus> (Someone else got it)
13:57:22 <themaximus> Keeps me from having to get up :-) Yay.
13:58:24 <themaximus> bah.
13:58:29 <themaximus> Homework.
13:59:02 <shapr> I have homework too
13:59:24 <Lemmih> Homework at age 32?
13:59:47 <bring> Swedish?
14:00:30 <themaximus> Eh?
14:00:32 <shapr> yes, swedish homework
14:00:35 <themaximus> Oh.
14:00:42 <bring> you should join our language technology class shapr, lots of swedish grammar and such
14:00:49 <themaximus> 'Cause why wouldn't I have homework at age 10
14:01:03 <shapr> I've checked out the grammatical framework
14:01:09 <shapr> I think it would be useful for SFI
14:01:12 <bring> cool, isn't it?
14:01:25 <bring> did you try the quiz mode?
14:01:25 <shapr> very cool
14:01:32 <shapr> no I didn't
14:02:02 <bring> it does something like:
14:02:07 <shapr> I played with the 'parts of speech' cgi thingy
14:02:07 <shapr> I was pretty impressed, it gave me neat insights into swedish
14:02:38 <bring> flicka [Utr Pl Indef Gen]
14:02:44 <bring> and you have to answer:
14:02:52 <bring> flickors
14:03:27 <bring> GF has dependent types
14:03:29 <bring> yay
14:08:15 <themaximus> eh?
14:12:51 <shapr> actually, I bet SFI would like to use GF 
14:14:03 <shapr> man, some people are impatient.
14:14:11 <themaximus> Like who?
14:14:12 <themaximus> Me?
14:14:22 <shapr> nah, I was just making a smartass remark about Matt-W
14:14:28 <themaximus> :-)
14:14:59 * themaximus yawns
14:15:01 <themaximus> Yawn.
14:15:01 <shapr> is gf 1.2 the latest?
14:15:05 <themaximus> eh?
14:15:09 <themaximus> You askin' me?
14:15:15 <shapr> just broadcast question
14:15:18 <bring> gf = girlfriend
14:15:22 <shapr> oy
14:15:22 <bring> right?
14:15:36 <shapr> yes, GF has dependent types :-)
14:15:53 <themaximus> -----*BROADCAST* Is GF 1.2 the Latest? *BROADCAST*-----
14:16:00 <bring> :)
14:16:07 <bring> I believe it is, yes
14:16:17 <themaximus> Like that annoying emergency warning testing thing that comes on your tv.
14:16:20 <shapr> I'd love to join your lang tech class, but the commute is a killer
14:16:21 <themaximus> BEEEEP
14:16:23 <themaximus> BEEP
14:16:25 <themaximus> BEEP
14:16:42 <themaximus> And it keeps beeping until it gets thrown out the window.
14:16:51 <shapr> huh, I don't watch much TV
14:16:52 <themaximus> Partially hard for people with big screen tv's.
14:16:56 <shapr> my computer did that recently
14:17:11 <shapr> that beeping thing
14:17:15 <bring> lecture notes are online: http://www.cs.chalmers.se/~aarne/course-langtech/lectures/lectures.html
14:17:23 <shapr> I think it had something to do with the dark brown color of the heat sink
14:17:33 <bring> or slides rather
14:18:09 <shapr> I've been thinking of setting up a 'dream site' for SFI that uses skolelinux and some other stuff
14:18:16 <shapr> GF seems like it would be part of such a site
14:19:02 <shapr> I should take pictures of the part of the heat sink that was touching the CPU, it's scary looking
14:19:42 <bring> you can probably sign up for the course, look at the lectures online, and do the labs at home, the only thing you'd have to be here for is the final (if you actually want a piece of paper saying you took the class)
14:20:03 <shapr> oh, VINNOVA is involved in ILT
14:20:13 <bring> ILT?
14:20:18 <shapr> they're involved with one of our clients too
14:20:26 <shapr> Interactive Language Technology
14:20:55 <shapr> heh, I don't care much for pieces of paper that say I took the class, I'm much more interested in really learning the stuff
14:22:51 <Marvin--> bring: except that shapr doesn't fulfill the requirements for the course anyway
14:23:07 <shapr> right, I'm much too far north ;-)
14:23:07 <bring> there are requirements?
14:23:08 <themaximus> uh oh
14:23:11 <themaximus> cruddy
14:23:20 <kosmikus|away> hey, someone asked for lhs2TeX to be included in Gentoo :)
14:23:25 <themaximus> My router just fell off the top of the desk :|
14:23:39 <Marvin--> bring: probably the usual base block requirements when taken as a GU course, I don't know how it works on Chalmers
14:23:43 <bring> shapr: haha
14:23:47 <bring> ok
14:24:21 <bring> wel,, if you don't want the paperwork, you can still look at the lecture notes, and talk to us
14:24:29 <shapr> yah, I agree
14:24:46 <bring> Marvin--: weren't you going to come to today's lecture?
14:24:57 <Marvin--> yeah
14:24:58 <Marvin--> I was
14:25:10 <Marvin--> but I was in the middle of writing
14:25:27 <Marvin--> and I hadn't had lunch :)
14:30:15 <bring> write anything good?
14:30:29 <Marvin--> a first hash of a Conclusions chapter
14:31:52 <themaximus> Gawd
14:32:06 <Marvin--> ?
14:33:33 <`John> @lojban join
14:33:34 <lambdabot> ERROR: 501 Syntax error, illegal parameters
14:33:40 <shapr> whoops
14:43:39 <Marvin--> I'm off to bed, g'night guys
14:43:47 <shapr> g'night
14:55:45 --- mode: ChanServ set +o shapr
14:56:04 --- mode: shapr set -b *!*@206.169.168.190
14:56:21 --- mode: ChanServ set +b *!*@206.169.168.190
14:59:24 <shapr> yes that's right, I'm unbanning Smerdyakov
14:59:35 --- mode: shapr set -b *!*@206.169.168.190
15:00:14 <shapr> greetings Smerdyakov
15:00:25 <Smerdyakov> Yes
15:00:32 --- mode: shapr set -o shapr
15:06:14 <Cale> welcome back Smerdyakov
15:09:04 * Smerdyakov smiles.
15:13:28 <reltuk> ok, since I don't have my head completely around this whole purely functional programming thing...
15:15:20 <Jerub> ok.
15:18:29 <shapr> reltuk: do you have any questions?
15:18:51 <reltuk> yeah, I was going to ask about common data structures...
15:19:26 <reltuk> like union-find sets that work in O(log*(n)) amortized time
15:22:28 <shapr> have you already seen the Trinder, Hammond, et al paper about union-find in GpH ?
15:22:36 <reltuk> no..
15:22:40 <reltuk> but I probably should
15:22:49 <reltuk> I think I just need to read that purely functional datastructures book
15:23:34 <shapr> I haven't read Okasaki's book yet, though it's on my list. I do own Rabhi and Lapalme's functional data structures book
15:23:53 <shapr> I really enjoyed that book
15:24:48 <reltuk> yeah, I don't understand how you could implement pretty much any datastructures functionally
15:25:23 <shapr> the source for the book I own is online, and in Haskell
15:25:33 <shapr> iirc, Okasaki's book is ML
15:26:34 <Riastradh> The Okasaki book has Haskell source code, too.
15:27:33 <shapr> did someone port the ML? or did Okasaki release the book with both versions?
15:27:36 <reltuk> wow, the okasaki's book is online...
15:27:46 <shapr> the whole book?
15:28:13 <Riastradh> The book is sprinkled with ML throughout and an appendix with the Haskell code.
15:28:29 <shapr> neat
15:29:44 <reltuk> yeah, I found the whole book
15:29:53 <shapr> ok, definitely the next book I'll purchase
15:29:53 <reltuk> at least, 182 pages of it
15:30:15 <shapr> did Okasaki release part of it?
15:31:14 <Jerub> shapr: Okasaki's book has haskell parallels for all the ML in the back of the book iirc.
15:31:34 <Riastradh> Jerub, that's what I just said.
15:31:34 <Jerub> I saw the book a week ago, a friend had it out from the library.
15:31:40 <Jerub> oh, okay, sorry.
15:31:41 <Jerub> ;)
15:35:23 <reltuk> I think it's the whole book
15:35:53 <reltuk> http://www-2.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:36:12 <Smerdyakov> Thesis <> book
15:36:13 <shapr> that's his thesis, it's what the book is based upon
15:36:19 <reltuk> oh
15:36:38 <reltuk> but it's so book-like  :-p
15:37:04 * shapr grins
15:37:08 <mattam> Smerdyakov: back ? ;)
15:37:45 <reltuk> wow, relatively recent book
15:38:33 <Jerub> shapr: I should write a parser for a silly language.
15:38:40 <shapr> yes, good idea!
15:38:54 <shapr> an Oook parser would be silly.
15:38:59 <reltuk> anyone familiar with Clean?
15:39:26 <shapr> I've tried to think of a good way to use a grid of colored pixels as 'source' for a language
15:39:37 <Jerub> shapr: yick.
15:39:45 <shapr> well, it would be silly.
15:39:50 <Jerub> shapr: silly languages should be hard to comprehend, but easy to parse.
15:40:12 <reltuk> like whitespace and b*f?
15:40:24 <Jerub> reltuk: exactly.
15:40:26 <shapr> I haven't come up with a good way to combine both an operation and a pointer to the next adjacent pixel in a sensible number of bits
15:40:26 <Jerub> and Oook
15:41:52 <Jerub> sigh.
15:42:06 <Jerub> where's a good reference for writing a parser in haskell without using a parser generator?
15:42:23 <shapr> what about parsec?
15:42:29 <shapr> it's the easiest way to start, imo
15:49:11 <Jerub> okay
15:50:06 <bring> shapr: isn't Befunge 2-dimensional, guess you could give each character it's own color
15:51:13 <shapr> confused turing machines, using colored befunge turing confetti strips
15:51:52 <shapr> I was thinking about how to encode "op, args, result, next"
15:52:03 <bring> rgba
15:52:16 <shapr> for example, if you say add the value of pixel left of me to the pixel right of me, and put the result below me
15:52:20 <shapr> oh
15:52:21 <shapr> yah!
15:52:36 <shapr> greetings jdrake 
15:52:57 <shapr> I guess useful programs would look like colored static
15:53:10 <Jerub> shapr: ahh! you're thinking about having data and operations in the same space.
15:53:26 <shapr> how else can you make a silly language?
15:53:37 <Jerub> ...
15:53:45 <Jerub> what about using 'the game of life' ?
15:53:50 <shapr> separation of such concerns is far too useful and modular ;-)
15:54:04 <shapr> actually, I've been wondering the same thing
15:54:06 <bring> with rgba program composition could be done with alpha blending
15:54:28 <shapr> whoa
15:54:33 <shapr> that's a neat idea
15:54:55 <bring> probably with utterly imcomprehensible semantics
15:55:00 <shapr> I totally agree
15:55:08 <shapr> here let me gimp these two programs together ;-)
15:55:13 <bring> :)
15:55:39 <shapr> I was thinking about cellular automata, the game of life, and their relation to parallel turing machines
15:55:53 <bring> though putting two programs side by side could probably be used for sequencing
15:56:04 <Jerub> okay, this is getting silly.
15:56:12 <shapr> Jerub: yay! just what you wanted!
15:56:33 <bring> drawing the image on a toroid would be nice
15:56:50 <shapr> actually, it might work... parallel turing machines might be a good simulation of ccNUMA semantics
15:56:52 <bring> no nasty edges that way
15:57:03 <reltuk> and you guys wonder why people say haskell isn't useful...
15:57:07 * shapr laughs
15:57:13 <reltuk> it's because haskell programmers sit around thinking of things like this all the time...
15:57:22 <reltuk> it's not the languages fault!  it's the users...
15:58:01 <bring> yeah, stupid users
15:58:09 <bring> wait, who are you talking about?
15:58:13 <reltuk> lol
15:58:14 <shapr> bring: you'd have to model the effects of the transform from a sphere to a toroid, and predict the effects of extending that to 'balloon-art' like the edges of tetrahedron
15:58:25 <reltuk> did anyone know about Clean when I asked earlier?
15:58:38 <shapr> I haven't used Clean, but I think phubuh and some others here have.
15:58:41 <bring> balloon art, like giraffes and whatnot?
15:59:09 <reltuk> haha, balloon figures are awesome
15:59:11 <shapr> well, I was thinking that the sequence of sphere to toroid has its next step at a skeleton of a tetrahedron
15:59:21 <Pseudonym> OOoh, maths!
15:59:27 <shapr> g'day Pseudonym 
15:59:30 <Pseudonym> G'day.
15:59:36 <reltuk> shapr, do you know what's up with it's type system? (i.e., how it's different from monads or just destructable data)
15:59:43 <Pseudonym> Are we playing hunt the wumpus?
15:59:47 <shapr> clean uses uniqueness types
16:00:13 <shapr> which seem to have some relation to linear types from what I've read
16:00:20 <bring> Pseudonym: we are designing a programming language on the surface of a giraffe
16:00:27 <Pseudonym> Ah, okay.
16:00:28 <reltuk> hmm...don't know enough about linear types either
16:00:37 <Pseudonym> I can help eith the reaction-diffusion texturing.
16:00:44 <bring> cool
16:00:53 <shapr> well, haskell has single-assignment variable/constant
16:01:08 <shapr> you can extend that one more step and get single-*use* variables
16:01:09 <Pseudonym> http://www.gvu.gatech.edu/people/faculty/greg.turk/reaction_diffusion/reaction_diffusion.html
16:01:15 <shapr> you can only read from them once
16:01:37 <shapr> that's how I understand linear types
16:01:45 <reltuk> wow...you can only read from them once?
16:01:49 <shapr> h.baker is the expert on linear type theory from what I've seen.
16:02:06 <Smerdyakov> It's not quite like that. You can read from them at most once. Requiring reading from them would be strict types.
16:02:23 * Jerub laughs
16:02:36 <bring> that's nice, synthetic giraffe patterns
16:02:45 <Pseudonym> http://citeseer.ist.psu.edu/wadler90linear.html
16:02:50 <Smerdyakov> Jerub, that wasn't a joke. I worked on a strict type system in my undergrad research.
16:02:52 <shapr> it's not loading for me, I think you guys haskelldotted it.
16:02:58 <reltuk> wow...that sounds a little ridiculous
16:03:02 <reltuk> but maybe it's just foreign
16:03:09 <Jerub> no, I was laughing at the balloon art.
16:03:21 <Smerdyakov> Ah
16:03:29 <shapr> wow, nice pattern
16:03:57 <Pseudonym> Alan Turing actually did this first.
16:03:59 <shapr> hey Pseudonym, did you see SyntaxNinja's review of HSOE on slashdot?
16:04:06 <Pseudonym> Yes, I did.
16:04:22 <Pseudonym> Turing mostly concentrated on zebras and pineapples, thoughl.
16:04:22 * bring is off to dream of abstract giraffes
16:04:32 <shapr> yes, sleep for me also
16:04:39 * shapr disappears
16:04:41 <Pseudonym> Night.
16:04:41 <reltuk> adios
16:04:44 <stepcut`> is this the best way to concat a list of strings with seperator --> concat (intersperse "&" ["1","2","3"])
16:05:07 <Pseudonym> That'll work.  I dunno if it's "best".
16:05:14 <Pseudonym> "Best" is always relative.,
16:05:35 * stepcut` imagines his solution has quadratic run-time
16:05:48 <stepcut`> :p
16:05:50 <Pseudonym> No, it's linear.
16:06:07 <Pseudonym> Linear in the final size of the string.
16:06:24 <stepcut`> ok, I just wondered if there was a premade function for this or not
16:07:38 <reltuk> undefined value "intersperse"
16:07:55 <Igloo> import List
16:07:57 <Pseudonym> The closest is showList, but that's kinda specific.
16:08:42 <reltuk> Igloo, is this ghc or haskell?
16:10:01 <Igloo> Haskell
16:10:54 <Pseudonym> Haskell?  Where?!
16:10:59 <reltuk> how can intersperse work in linear time?
16:11:09 <reltuk> no, never mind...
16:11:39 <reltuk> concat(intersperse ...) is linear, but still traverses the list twice, right?
16:15:03 <Jerub> reltuk: not necesserily, it could do it lazily.
16:15:12 <Jerub> I'm not sure if it *does*, but it might
16:15:24 <reltuk> wow...that would be really cool
16:15:34 <reltuk> lazy would actually make it faster...
16:15:51 <Igloo> It has to do it non-strictly
16:16:12 <Igloo> I suspect no intermediate list would be created, but I'm no expert on such things
16:20:54 <n00bee> Hi all :)
16:21:29 <n00bee> Is there any one awake in here?
16:21:37 <Cale> yeah
16:21:44 <Cale> do you have a question about haskell?
16:22:06 <n00bee> Yeah I do
16:22:08 <n00bee> :)
16:22:10 <n00bee> Cale
16:22:17 <n00bee> Nice to meet you
16:22:40 <n00bee> Cale: are you willing to help me for a minuter?
16:22:45 <Cale> sure
16:22:49 <n00bee> :D
16:22:51 <n00bee> Cheers
16:22:58 <n00bee> I am teaching myself haskell
16:23:07 <Cale> Cool :)
16:23:10 <Jerub> good!
16:23:11 <n00bee> and I am trying to create a function
16:23:49 <n00bee> this function takes a bass value and a top value and an increment value
16:24:06 <n00bee> and gives a list from the base value up to the top value
16:24:11 <n00bee> U know?
16:24:14 <Cale> yep
16:24:21 <n00bee> Like when U type [1..10]
16:24:25 <Cale> right
16:24:34 <n00bee> but I want to use say 0.04 as the increment
16:24:48 <Pseudonym> [1,1.04..10]
16:24:55 <Pseudonym> Like that?
16:25:04 <n00bee> but the problem I have is I need to start off with an empty list and keep adding to it right?
16:25:12 <n00bee> yeah Pseudonym
16:25:44 <Pseudonym> Why don't you just use that? :-)
16:25:53 <Cale> the easiest way might be to start off with the final value, and subtract the step from it as you work backwards, tacking new values onto the head of the list
16:26:06 <n00bee> does a trend work like that?
16:26:21 <Jerub> Cale: but that depends on the definition, becuase if you do [0,2,9] you don't want [1,3,5,7,9]
16:26:36 <n00bee> ok :)
16:26:43 <n00bee> Pseudonym that worked :)
16:27:09 <Cale> oh, right :)
16:27:11 <n00bee> the other 1 I wanted to define was the same...but instead of givving an increment value
16:27:12 <Pseudonym> Be careful with rounding, though.
16:27:21 <Jerub> f start step finish = start:(f (start+step) step finish)
16:27:41 <Cale> oh, of course :)
16:27:44 <reltuk> hugs gets [1,1.04..10] all wrong  :-p
16:27:53 <n00bee> instead you give a value i.e 5 and it will give you 5 evenly spacesd values...including the limits
16:28:05 <Jerub> f start step finish | start < finish = start:(f (start+step) step finish)
16:28:16 <Jerub> f start _    finish | otherwise = []
16:28:26 <n00bee> yeah reltuk ...hugz gets it wrong because it is using floats and not rounding
16:28:37 <Pseudonym> @type enumFromThenTo
16:28:38 <lambdabot> enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:28:42 <Pseudonym> Also useful.
16:28:56 <n00bee> yeah...that is defined in Prelude
16:29:45 <n00bee> but say i had   1(low)   5(high)   and 7 as the number of values
16:29:57 <n00bee> I have no idea how to implement that
16:30:12 <Cale> oh, then you just want to take (b-a)/n to get your step
16:30:28 <Cale> where a is the start value, b is the finish, and n is the number of steps.
16:30:30 <n00bee> my guess would be to take (5-1)/7 anduse that as the increment?
16:30:40 <n00bee> U got it Cale :)
16:31:13 <Pseudonym> Oh, a function that I use a lot to do this sort of thing is lerp.
16:31:32 <Pseudonym> "Lerp" is a term from computer graphics, and it's short for "linear interpolate".
16:31:50 <reltuk> serp
16:31:59 <reltuk> with quaternions...
16:32:33 <Pseudonym> lerp t a b = (1-t)*a + t*b
16:32:49 <Pseudonym> I thought it was slerp.
16:32:55 <Pseudonym> Spherical linear interpolate.
16:35:12 <n00bee> hehe
16:35:17 <reltuk> yeah, it is
16:35:26 <n00bee> Cale: any ideas?
16:35:32 * Pseudonym used to do this for a living; can't fool me with your serps
16:35:36 <Cale> n00bee: hm?
16:36:05 <n00bee> is lerp a predefined funcrtion?
16:36:10 <Cale> well, if you can implement something that makes a list with a given step value, then surely you can use that as your step value.
16:36:14 <Pseudonym> No.
16:36:30 <Pseudonym> HGere's how I defined it:
16:36:35 <Pseudonym> class (Num a) => ScaleRational a where
16:36:35 <Pseudonym>     scaleRational :: Rational -> a -> a
16:36:37 <n00bee> Cale: jsut though U had an idea -> [00:30] <Cale> where a is the start value, b is the finish, and n is the number of steps.
16:36:40 <Pseudonym> instance (Fractional a) => ScaleRational a where
16:36:41 <Pseudonym>     scaleRational x y = fromRational x * y
16:36:47 <Cale> n00bee: look above that
16:36:52 <Pseudonym>     lerp t a b
16:36:53 <Pseudonym>       = scaleRational (1-t) a + scaleRational t b
16:37:07 <Pseudonym> Sorry, lerp isn't part of the instance of ScaleRational.
16:37:12 <Pseudonym> Offside rule problem.
16:37:12 <reltuk> Pseudonym, hah!  don't see much functional graphics programming though
16:37:16 <n00bee> aha
16:37:30 <Pseudonym> reltuk: Yeah, shame about that.
16:37:32 <n00bee> (dont lose me with jargon...am like name n00b)
16:37:38 <Pseudonym> Come pretty close, though.
16:37:56 <n00bee> the accuracy of the logidc looks sound :)
16:37:59 <Pseudonym> Ed Catmull's "shade trees", which the RenderMan SL (and hence Cg) was based on was a functional language.
16:38:08 <n00bee> aha
16:38:15 <n00bee> Like RayTracing
16:38:20 <reltuk> Pseudonym, things like that and gui's and things like MUDs...I'm still not comfortable enough with functional programming paradigm to really see how it can apply to things like that and make them cleaner/easier to maintain/better
16:38:36 <n00bee> U lot are Geezas ;)
16:38:45 <Pseudonym> Toro, Matt Pharr's coherent raytracing system, used a FP-like language for shading, too.
16:38:56 <n00bee> Thats what I thought :)
16:39:09 <reltuk> yeah, shaders are probably different, because they don't carry a lot of state
16:39:14 <Pseudonym> And, of course, there's slinc, which I wrote, but never saw the light of day 'cause I changed jobs at the wrong time.
16:39:31 <n00bee> brb...am gunna try the rest of my function...what I was asking about is only an aux funct :D
16:39:43 <Cale> I think that functional languages would be rather natrural for graphics programming.
16:39:48 <Pseudonym> But slinc is a compiler, and compilers are one of those things that Haskell does well.
16:39:51 <n00bee> see y'all in a mo
16:40:21 <Pseudonym> I've also been thinking recently about render farm management.  I think FP is a natural there, too.
16:40:25 <reltuk> Cale, how-so?  you have 40,000 polygon models...you copy all those polygons each frame to calculate the frame's animation?
16:40:35 <Pseudonym> One of the dominating factors in a farm of renderers is network traffic.
16:40:44 <Cale> reltuk: copy?
16:41:02 <Pseudonym> If a frame needs 12Gb of data, some of which is shared between frames, moving that data around can easily dominate.
16:41:14 <Pseudonym> So it's a kind of optimisation problem.
16:41:40 <reltuk> heh, I'm not talking rendering finding nemo...i'm talking ut2k4  :-p
16:41:50 <Pseudonym> I'm talking about rendering Finding Nemo.
16:41:53 <Pseudonym> Really.
16:41:57 <Pseudonym> :-)
16:42:16 <reltuk> lol, I know  ;)
16:42:43 <Cale> I see no reason why one couldn't have efficiency in a functional language for that sort of work at least on the level of C++.
16:42:54 <Pseudonym> Cale: It depends on the work.
16:43:10 <Pseudonym> Modelling, for example, is a very memory-critical thing.
16:43:33 <Pseudonym> I've had a think about it.  Haskell would be a pretty poor fit, but I think Erlang might excel at that sort of thing.
16:43:45 <Pseudonym> If you did it right.
16:44:16 <mattam> isn't Erlang mainly about processes ?
16:44:26 <Riastradh> Erlang isn't exactly designed to be good at computational intensity.
16:44:31 <Pseudonym> Yes, and so is modelling, on an abstract level.
16:45:20 <mattam> i'd be interested to know at which levels, it seems very monolithic activity to me (being a user).
16:45:40 <Pseudonym> Well, I'm most familiar with Maya, so I'll talk about that for a moment if that's okay.
16:46:13 <n00bee> Maya is WiCkEd!
16:46:20 <mattam> that's okay, i know lightwave and blender myself but they're probably not very different.
16:46:35 <Pseudonym> Actually, they're pretty different, as I understand them.
16:46:35 <n00bee> I used it when it used to be Raydream
16:46:47 <Pseudonym> Maya is a huge dataflow evaluation engine.
16:46:57 <mattam> huhu
16:47:28 <Pseudonym> The objects which it understands are dependency nodes, and when you fiddle with something (e.g. change the value of an attribute), dependencies flow around the system until they reach the visible shapes.
16:47:51 <Pseudonym> This, for example, is how you do animation.  The global "time" is a node.  Things which depend on time depend on that node.
16:48:02 <mattam> k
16:48:26 <Pseudonym> Now, thing node == process, arc == IPC channel.
16:48:31 <Pseudonym> That's basically Erlang's model.
16:48:45 <Pseudonym> Moreover, Erlang allows processes to sit on other machines.
16:49:02 <Pseudonym> s/thing/think/
16:49:59 <Riastradh> Still, Erlang wasn't designed with computational intensity in mind.  I assume that Maya is pretty damn computationally intense.
16:50:22 <mattam> are there really intensive computations in the modeling of an animation i.e. not rendering of frames ?
16:50:31 <Pseudonym> Sure.
16:50:39 <Pseudonym> If you're doing physical simulation, for example.
16:50:43 <Pseudonym> Cloth, fluids etc/
16:50:55 <mattam> right
16:51:17 <Pseudonym> Still, there's no reason why you couldn't implement them in C++ and still use Erlang for the dataflow model.
16:51:47 <Riastradh> Yeeewww.  Why would you use C++?
16:51:50 <mattam> i understand your argument now :)
16:52:18 <Pseudonym> Riastradh: If it's a choice between C++ and high performance FOrtran, I'll pick C++ any day.
16:52:29 <Pseudonym> Although... maybe what you need is a hybrid of Erlang and Sisal.
16:52:39 <Riastradh> You get a choice of C++ and FORTRAN and nothing else?
16:52:39 <Pseudonym> Wouldn't that be a kick-arse language!
16:53:15 <Pseudonym> For numeric programming?
16:53:21 <Pseudonym> You have a better choice, apart from Sisal?
16:53:30 <Riastradh> Pre-Scheme?
16:54:29 <Pseudonym> Looking that up.
16:54:40 <mattam> sisal is a ssa-form language ?
16:54:49 <Riastradh> http://www.bloodandcoffee.net/campbel/code/kelsey97prescheme.{ps,pdf}
16:54:58 <Pseudonym> http://sisal.sourceforge.net/
16:55:08 <Pseudonym> I think I'd prefer Sisal if I had the choice between that and Pre-Scheme.
16:55:50 <Pseudonym> You missed an l in campbell
16:55:57 <Riastradh> So I did.
16:56:06 <Pseudonym> This is interesting.  Must read this.
16:56:26 <Pseudonym> I still think I'd prefer Sisal.
16:57:14 <Smerdyakov> Are y'all talking now about languages to use when runtime efficiency is very important?
16:57:38 <Pseudonym> I'm talking about languages well-suited for hard-core numerics.
16:57:48 <Smerdyakov> What about ML?
16:58:26 <Pseudonym> Sisal was specifically designed as a functional language to compete with High-Performance Fortran.
16:58:49 <Pseudonym> And it's a real joy to program in, too.
16:58:57 <Pseudonym> I don't like ML's syntax, but I'm biassed. :-)
16:59:37 <Pseudonym> I guess the thing to do would be to pick a numeric algorithm and implement it in all of these languages.
16:59:49 <Smerdyakov> One moment. I get you a link.
17:00:01 <Pseudonym> The numeric language shootout!
17:00:10 <Smerdyakov> http://www-2.cs.cmu.edu/~pscico/
17:00:12 <n00bee> Cheers for the help guys :)
17:00:17 <n00bee> it works now
17:00:26 <n00bee> I was writing a plotting function
17:00:27 <Smerdyakov> Scientific computing with ML project, at CMU
17:00:34 <Pseudonym> Oh, nice!
17:00:58 <n00bee> hehe...I know ...a bit simple but its somewhere to start :)
17:01:08 <n00bee> wanna see it?
17:01:17 <Pseudonym> n00bee: Sure, but don't paste it here.
17:01:18 <n00bee> (its really simplistic :)
17:01:24 <n00bee> dont worry
17:01:31 <Pseudonym> Just getting in first. :-)
17:01:35 <n00bee> I have no need to flood the channel LOL)
17:01:49 <n00bee> hehe ok
17:01:54 <n00bee> dcc chat it?
17:02:04 <Pseudonym> @wiki HaskellIrcPastePage
17:02:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:02:16 <n00bee> aha...wiki
17:02:20 <n00bee> wikis are koo
17:02:23 <Riastradh> (Pre-Scheme on second thought may not be what you're looking for.  It's more designed to be a low-level language with some high-level functional abstractions rather than a functional language designed for high-performance numerical crunchiness.)
17:02:23 <n00bee> :)
17:02:32 <Pseudonym> Right.
17:02:44 <Pseudonym> It looks like a pretty decent language, though.
17:02:50 <Pseudonym> Not quite for this kind of work.
17:03:22 <n00bee> HaskellIrcPastePage cant open ! DOH! Firewall blocking it for some reason
17:03:33 <n00bee> oh well
17:03:38 <n00bee> doesnt matter
17:04:58 <n00bee> I started off by defining tuple type for point, then line, then formulae for gradient, interpolation, plotting, straight line, x^2, x^3 etc and so on
17:15:43 <Jerub> interesting . http://srfi.schemers.org/srfi-49/srfi-49.txt
17:18:37 <reltuk> "Recently, using indentation as the sole grouping constuct of a
17:18:37 <reltuk> language has become popular with the advent of the Python programming
17:18:37 <reltuk> language."
17:18:41 <reltuk> I don't know if I would say that...
17:18:58 <reltuk> it's become used in one language...(and kind of haskell...)
17:19:18 <Riastradh> Why would you possibly want to use that monstrosity and not regular S-expressions?
17:19:37 <Jerub> I'm not exactly sure.
17:19:58 <Jerub> I like pythons syntax, but I hate the division between statement and expression (which grates on me in every language that does that).
17:20:59 <reltuk> I like ruby's syntax...I'm not really a big python fan
17:22:11 <reltuk> Riastradh, I agree, in my opinion it greatly reduces readability (over S-expressions)
17:22:53 <n00bee> NN U lot and thanx for the help :) I have to get up in 4 hours for work...so tooldeoo..all have a good weekend ;)
17:24:41 <reltuk> anyone seen/used FunGen?
17:26:37 <Jerub> reltuk: ruby has regular expresisons as part of the syntax, as soon as  I read that I stopped lokoing at it.
17:27:01 <mattam> why so ?
17:27:28 <Riastradh> Regular expressions should be extensions to the syntax in the form of macros, as scsh does.
17:27:54 <mattam> yeah, but better have it integrated than nothing
17:28:29 <mattam> caml has some camlp4 extension for that too.
17:28:39 <Jerub> mattam: they don't deserve special treatment, they should be accessable via functions, not a special case in the parser.
17:29:02 <Riastradh> I'd rather have nothing built-in to having it intrinsically integrated into the language.
17:29:27 <Riastradh> Then again, there are lots of other things done in Ruby that I'd rather not do.
17:29:34 <mattam> i agree
17:29:53 <mattam> especiall $@@ thingies
17:29:56 <Riastradh> My solution to those problems I have with Ruby: just use Scheme!
17:30:21 <mattam> it's kind of an universal solution for you Riastradh .
17:30:37 <Riastradh> Indeed.  It works pretty well.
17:30:39 <Jerub> Riastradh: I have heard complaints that scheme is not very standard access copmilers and platforms.
17:30:56 <mattam> i guess i should put more time in learning it completely.
17:31:07 <Jerub> and thats something I highly enjoy with python. being able to very simply run a (moderately well written) python program on linux + windows.
17:31:21 <Riastradh> Jerub, there is lots of incompatibility between multiple implementations, but these incompatibilities are beginning to be addressed; regarding platforms, that depends on the specific implementation.
17:33:39 <reltuk> Jerub, regular expressions are powerful...I don't see any reason for not having them in the language...
17:33:42 <reltuk> they're quite natural in ruby
17:33:56 <Riastradh> reltuk, why in the _core_language_?  Why are they not _library_ functionality?
17:35:08 <reltuk> Riastradh, because they're more natural and thus more useful in the core lanuage since they can have syntax associated with them
17:35:28 <Riastradh> 'More natural?'
17:35:53 <Riastradh> What makes them more useful in the core language?  As I have _JUST_SAID_, they _DON'T_ need to be in the core language for convenient syntax to be associated with them; look at scsh's regexp package.
17:36:09 <Jerub> reltuk: why is re.replace(subject, 'foo', 'bar') 'less natural' than $subject ~= s/foo/bar/;
17:36:10 <reltuk> scheme is different...
17:36:14 <reltuk> you can define syntax
17:37:00 <reltuk> Jerub, binding of submatches is normally uglier if you push it out to a library
17:37:03 <Riastradh> Yes, that is correct.  So you're either conceding that Ruby is inferiour to Scheme in that regard or you're making an incoherent argument.
17:37:30 <Smerdyakov> reltuk, what kind of operation that uses binding of submatches are you talking about?
17:38:08 <reltuk> Riastradh, I conced that Ruby is inferior to scheme in defining new syntax from within itself
17:38:20 <Riastradh> Er, what?
17:39:41 <Jerub> reltuk: what? binidng of submatches, as in leaking variables into the local scope implicitly?
17:39:52 <Jerub> I consider that to be a design flaw. ;)
17:40:06 <reltuk> Jerub, design flaw or not, it's very useful
17:40:40 <Smerdyakov> I think Template Haskell gives you a much better solution. You can make a matcher that takes a function from the subexpression matches to the final result.
17:40:53 * reltuk isn't familiar with template haskell
17:41:03 <Riastradh> reltuk, how is it any better except in removing a little bit of code from only the Ruby user's perspective than pattern matching?
17:41:12 <Smerdyakov> Even in regular Haskell or ML, you can return subexpression matches as a list and use pattern matching to name the parts.
17:41:58 <reltuk> Riastradh, regular expressions are still part of the library....
17:42:13 <Riastradh> ...?
17:42:19 <reltuk> they're of type Regexp...they just have special syntax associated with them to make them easier to specify
17:43:11 <Riastradh> Just because there's a class for them doesn't make them library components.  Regular expressions are _built_in_ to the _language_implementation_.
17:43:30 <reltuk> like arrays...
17:43:48 <Smerdyakov> Right. Arrays make sense to include as primitives for performance reasons.
17:44:04 <reltuk> Smerdyakov, why would an external-library array be any slower?
17:44:36 <Smerdyakov> It would have to be written in another language to get constant time subscripting, assuming no built-in array-like features.
17:44:54 <reltuk> Smerdyakov, yeah...so it would have to be written in C like the current Array class is...
17:45:15 <Smerdyakov> Array class is a Ruby thing?
17:45:29 <Riastradh> But regular expressions do _NOT_ have to require underlying run-time system support.
17:45:46 <Riastradh> They can just as easily be _pure_ library functionality.
17:45:58 <reltuk> Riastradh, like anything else...
17:46:07 <reltuk> I don't understand...it's just a question of what you put in and what you take out
17:46:20 <Riastradh> Wrong.  The example you _JUST_ provided _CANNOT_ be pure library functionality and still be as useful.
17:46:30 <Smerdyakov> reltuk, we like to minimize the complexity of the core language.
17:46:33 <reltuk> why not?
17:46:41 <Smerdyakov> reltuk, this makes the language easier to learn and understand.
17:47:04 <Riastradh> reltuk, please show me an implementation of Array in _plain_ Ruby with no array-like devices.  It must have _constant_-time subscripting.
17:47:14 <reltuk> Riastradh, I didn't say it would be in plain ruby
17:47:25 <reltuk> Riastradh, but that's irrelevant...neither would regular expressions in a library
17:47:33 <Riastradh> Why wouldn't regular expressions be in a library?
17:47:46 <Smerdyakov> reltuk, that's odd, because regexp libraries for ML and Haskell use only ML/Haskell code.
17:47:53 <reltuk> Riastradh, they could be, but it wouldn't be written in Ruby
17:47:59 <Riastradh> Why not?
17:48:00 <reltuk> I mean...I guess it *could* be written in Ruby
17:48:13 <reltuk> but why not just wrap an interface around PCRE and be done with it
17:48:18 <Riastradh> A regular expression library simply deals with the construction & invocation of NFAs; it's not a low-level concept.
17:48:37 <Riastradh> OK, fine.  (That's what scsh does, I believe.)  It _still_ needn't be language functionality.
17:48:55 <Smerdyakov> That's one way to do it, but presumably you're in pain if you want new functionality for the library. You have to work with crufty C code.
17:49:09 <Riastradh> A library that simply wraps a library from another language is still a library.  Building it into the Ruby language is an entirely other thing.
17:49:57 <Riastradh> There is no rationale for building it into Ruby except some petty whinings about ever so slight convenience that ends up making code less readable in the end which hampers maintainance.
17:50:17 <Smerdyakov> Riastradh, don't Scheme macros make code less readable?
17:50:21 <reltuk> it doesn't make code less readable if you look at it
17:50:27 <reltuk> I mean...if you program Ruby
17:50:33 <reltuk> you're used to the syntax...it's very natural and useful
17:50:38 <Riastradh> Smerdyakov, they _can_.
17:50:48 <Riastradh> So can excessive use of combinators and point-less style.
17:51:04 <Riastradh> Anything can be abused.
17:51:18 <Smerdyakov> So then why does your argument mean that built-in regexps are any worse than macros?
17:51:47 <Riastradh> It's abuse of the core language implementation to build regexps into it.
17:52:13 <Smerdyakov> OK, but I don't think you have an argument based on _readability_ that doesn't also apply (more so) to Scheme macros.
17:52:19 <Riastradh> As you just argued, the core language semantics should be as simple as possible; I am arguing the same thing.
17:52:36 <Riastradh> Smerdyakov, oh, _please_.  Compare a typical PCRE-style regexp with an SRE regexp.
19:08:55 <hasky> are you allowed to ask questions here?
19:09:26 <Pseudonym> Seeing as that was a question, it's a bit late now, don't you think?
19:10:04 <Riastradh> I'm sorry, but questions aren't allowed; we'll have to kill you, now.
19:10:18 <Pseudonym> hasky: Is it homework?
19:10:37 <Pseudonym> If so, see this first. @wiki HomeworkHelp
19:10:52 <Pseudonym> lambdabot: You there?
19:10:52 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:10:58 <Pseudonym> @wiki HomeworkHelp
19:10:58 <lambdabot> http://www.haskell.org/hawiki/HomeworkHelp
19:11:05 <Pseudonym> Aha.
19:11:22 <Riastradh> So a guy approaches a lawyer whom he's heard of and asks, 'so I hear you'll answer three questions for ten thousand dollars; is that right?'  The lawyer says, 'yup.'  The guy asks, 'isn't that kind of a lot of money to ask for three questions, though?'
19:11:29 <Riastradh> The lawyer answers, 'indeed it is.  What's your third question?'
19:12:19 <Pseudonym> hasky: Did you actually have a question or did you just want to work at a meta-level?
19:12:25 <hasky> it's not homework
19:12:32 <Pseudonym> Cool.  Just thought I'd get in first.
19:12:37 <Riastradh> Meta-levels are cool.
19:12:46 <hasky> yeah it's pretty simple q, i just want to find the nth element of a list and return it
19:13:03 <Riastradh> It's really cool when the meta-level of a level X is actually X, such as with the syntax-rules macro system.
19:13:19 <Pseudonym> @type (!!)
19:13:20 <lambdabot> (!!) :: [a] -> Int -> a
19:13:30 <Riastradh> @eval [0,1,2,3] !! 1
19:13:31 <lambdabot> (line 1, column 11):
19:13:31 <lambdabot> unexpected "!"
19:13:31 <lambdabot> expecting operator, simple term or end of input
19:13:33 <Riastradh> Bah.
19:13:43 <hasky> yeah without using pre-built functions :P
19:13:44 <Riastradh> @type [0,1,2,3] !! 1
19:13:45 <lambdabot> [0,1,2,3] !! 1 :: Num a => a
19:13:52 <Pseudonym> I should point out, however, that if you find yourself wanting to do this, you may be solving the wrong problem.
19:14:01 <hasky> i'm trying to learn recursion
19:14:17 <Pseudonym> Ah, OK.  Why not look in the prelude sources and look up the definition of (!!)?
19:14:49 <hasky> where do i find that :P
19:14:53 <Pseudonym> http://haskell.org/onlinereport/standard-prelude.html
19:15:03 <Pseudonym> Search for "subscript".
19:17:21 <hasky> blargh it uses itself in the definition :P
19:17:35 <Riastradh> Yeah...that's the general idea of recursion, y'know...
19:18:00 <Pseudonym> Have to duck out for a moment.  BBIAB
19:18:41 <hasky> oh wait stupid me
19:31:33 <Cale> hasky: yeah, that's recursion, it's rather common around these parts, so you'd best get used to it :)
19:43:53 <Cale> Does anyone have a favourite image (file saving/loading) library for Haskell that works at least under Linux?
21:42:13 <eibwen> I'm a fairly experienced imperative programmer.  A few days ago it was suggested that I learn a 'real' language like haskell.  However, in all the tutorials that I've looked over (including a few on monads) -- it seems that functional languages aren't designed to perform multiple successive, yet distinctly seperate operations on a matrix to be read in from a data file.  Given my brief exposure, is this observation incorrect?
21:44:59 <jdrake> eibwen, i am looking into haskell too
21:45:32 <jdrake> i am absolutely sure you can do what you want to do with a purely functional language
21:45:43 <jdrake> but I can't say for sure yet (i.e. with code)
21:45:45 <Pseudonym> I don't understand the question.
21:45:49 <Pseudonym> Can you be more specific?
21:47:16 <eibwen> I've got a matrix in a datafile.  It is then read in and then Upper/Lower Triangulation and reduction is performed on both said matrix and an identity matrix of the same size -- yeilding the inverse of the input matrix.  Can Haskell do that?  Is it suited to such an application?
21:47:37 <Pseudonym> First: Yes, it can do it.  Haskell has imperative-style arrays.
21:47:44 <Pseudonym> Embedded with monads.
21:48:32 <Pseudonym> So it can be done, and in pretty muich the same way that you'd do it in an imperative language.
21:48:45 <Pseudonym> Though this may not be the most natural way.
21:49:17 <Pseudonym> Secondly, is it "suited" for this kind of application?  That's a matter of opinion.
21:49:39 <eibwen> I'd presume so...  however the docs I've come across haven't (at least not appearantly) lent themselves to populating an array from a datafile.  Given that, I'm fairly sure I could figure it out.
21:49:48 <Pseudonym> We could certainly do with a decent uBLAS binding. :-)
21:50:44 <Pseudonym> Generally, you either build it into a list, then build the array from the list, or you make an array and stick in values as you read them in.
21:50:53 <Pseudonym> There's no magic to it.
21:51:58 <jdrake> http://www.haskell.org/complex/why_does_haskell_matter.html  <-- this is good read
21:52:00 <eibwen> The "magic" would be these monads I keep hearing about...  although I have yet to read one that illustrates how to turn a line (which may contain multiple floats) into successive elements of the array
21:52:31 <Pseudonym> The "line" is some kind of ASCII representation of floating-point numbers, correct?
21:53:16 <eibwen> yep
21:53:32 <Pseudonym> If so, the easiest way is to first split the line into whitespace-delimited "words".
21:53:35 <Pseudonym> Then "read" each word.
21:53:44 <Pseudonym> @type read
21:53:45 <lambdabot> read :: Read a => String -> a
21:54:15 <jdrake> love the mysterious a (whoever picked a anyways?0
21:54:41 <Pseudonym> It's better than Miranda.  Miranda used asterisks.
21:54:45 <Pseudonym> @type foldr
21:54:45 <lambdabot> foldr :: (a -> b -> b) -> b -> [a] -> b
21:54:59 <Pseudonym> In Miranda, that'd be (* -> ** -> **) -> ** -> [*] -> **
21:55:02 <Pseudonym> Even more cryptic.
21:55:06 <jdrake> yes agreed
21:55:41 <Pseudonym> Hell, you can use any identifier you want so long as it starts with a lower-case letter!
21:56:35 <eibwen> Just out of curiousity, after reading is a the string containing the float or the float itself?
21:56:36 <jdrake> ? would this be right as an example function:  cdr x xs = xs
21:57:01 <Pseudonym> @type read
21:57:01 <lambdabot> read :: Read a => String -> a
21:57:05 <Pseudonym> Do you see the type of read?
21:57:18 <Pseudonym> Do you know how to grok a type like that?
21:57:31 <Pseudonym> (Not trying to be superior, this is a genuine question.)
21:58:10 <eibwen> This would be a simplistic exercise in (almost) any imperative language, still fresh of the haskell docs though
21:58:30 <Pseudonym> Yeah, the thing is, compared to Haskell, all imperative languages are pretty much alike. :_0
21:58:34 <Pseudonym> :-), rather
21:58:38 <jdrake> eibwen, the problem (with both of us) is we have been trained in imperative languages :p
21:58:53 <eibwen> jdrake: Every language has it's place
21:59:00 <Pseudonym> Absolutely.
21:59:14 <Pseudonym> Well, not EVERY language.
21:59:18 <eibwen> heh
21:59:22 <Pseudonym> :-)
21:59:23 <jdrake> eibwen, where does basic fit in?
21:59:34 <Pseudonym> Basic is perfect for programming 8-bit micros.
21:59:43 <jdrake> basic i have heard said is damaging to the programmer's mind
22:00:24 <Jerub> I've said that.
22:00:24 <Jerub> ;
22:00:25 <eibwen> basic has been furthered...  but it doesn't exactly promote good coding practice.
22:00:26 <Jerub> ;)
22:00:46 <jdrake> and it certainly is when I end up trying to write a graphical console supporting a locate function. Basic has it reverse of everybody else. Locate y, x instead of  locate x, y
22:01:05 <Pseudonym> Locate is not part of Basic.
22:01:22 <Pseudonym> Have you ever seen the ANSI Basic standard?
22:01:23 <jdrake> Pseudonym, it was in the dialect I had
22:01:26 <eibwen> They're more flavors of Basic than I care to count
22:01:29 <jdrake> Pseudonym, never
22:01:34 <jdrake> at least I don't think so
22:01:37 <eibwen> there even
22:01:43 <Pseudonym> @foldoc ANSI Minimal BASIC
22:01:46 <lambdabot> *** "ansi" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
22:01:46 <lambdabot> ANSI
22:01:46 <lambdabot>      
22:01:47 <lambdabot>         {American National Standards Institute}
22:01:49 <lambdabot>      
22:01:51 <lambdabot>      
22:01:53 <lambdabot> No match for "Minimal".
22:01:55 <lambdabot> [57 @more lines]
22:01:57 <Pseudonym> Hmmm.
22:02:00 <Pseudonym> @foldoc "ANSI Minimal BASIC"
22:02:01 <lambdabot> *** "ansi minimal basic" foldoc "The Free On-line Dictionary of Computing
22:02:01 <lambdabot> (27 SEP 03)"
22:02:03 <lambdabot> ANSI Minimal BASIC
22:02:05 <lambdabot>      
22:02:07 <lambdabot>         <language, standard> ANS X3.60-1978.
22:02:09 <lambdabot>      
22:02:11 <lambdabot>         [Details?]
22:02:13 <lambdabot>      
22:02:15 <lambdabot> [3 @more lines]
22:02:20 <Pseudonym> OK, kinda light on the details.
22:03:02 * ibid has a copy of the standard
22:03:59 <jdrake> why do i think it would be easy for ?-bot  to be flooded off
22:04:09 <Pseudonym> There's also Full BASIC.  X3.113-1987
22:04:58 <jdrake> Q: does haskell support extended character sets, such that you could actually make a ? function or a ? constantÉ
22:05:22 <Pseudonym> Oh, now there's a can of worms.
22:05:47 <Pseudonym> The short answer is "not really".  Haskell distinguishes between upper-case and lower-case letters.
22:05:59 <Pseudonym> It's unclear what to do in languages which don't have the distinction.
22:07:07 <jdrake> has anyone written any really large commonly used desktop applications in haskellÉ
22:08:20 <Pseudonym> I think it's fair to say "no", if by "desktop applications" you mean something with a GUI.
22:08:33 <jdrake> yes something with a gui
22:08:49 <Pseudonym> No, no "really large" Haskell application that I'm aware of has a GUI.
22:09:30 <Pseudonym> There are a few around, but I'm not sure if they're "commonly used".
22:09:42 <Pseudonym> http://www.cs.waikato.ac.nz/Research/fm/amuzed.html
22:09:44 <jdrake> are there any languages one could bind haskell to that are basically gui languages, but do not intrude on the actual logic aspect for which haskell would be better for anyways
22:09:45 <Pseudonym> Like that one.
22:10:01 <Pseudonym> jdrake: Yes.  Haskell has a COM binding, for example.
22:10:16 <Pseudonym> If you're on a Windows platform.
22:10:23 <jdrake> COM is evil isnèt itÉ
22:10:38 <Pseudonym> Only in the sense that it's from Microsoft.
22:10:54 <Pseudonym> COM itself is actually quite clean.  Pity about the stuff built on top of it, like ActiveX.
22:12:00 <jdrake> i always thought of COM as an evil thing that was needed because they chose c++ instead of objective-c
22:12:14 <jdrake> because objective c would have been able to work where com is needed
22:12:27 <Pseudonym> COM was always designed to be multi-language.  Objective-C isn't.
22:12:43 <Pseudonym> They chose COM because they're Microsoft and hence didn't want to use an open system like CORBA. :-)
22:12:58 <eibwen> jdrake: Thanks for sharing the link.  Given that the majority of my apps involving i/o from data files is somewhat time critical I'll probably leave it to C or the like -- particularly for (presumably) much easier parallelization.  Haskell does have its merits though...  It'll be a unique addition to my 'collection'
22:13:30 <jdrake> eibwen, maybe you should look into ada
22:14:01 <jdrake> it has concurrency built in
22:14:07 <Pseudonym> eibwen: I/O and Strings are pretty much universally agreed to be the two things that Haskell doesn't really do elegantly.
22:14:22 <jdrake> it is more verbose too
22:14:57 <jdrake> i have been told by a person more familiar with it that Ada will allow you to shoot yourself in the foot as much as C, but the only difference is that in Ada you have to be more explicit about it shooting your foot for you
22:15:34 <Jerub> in ada, the compiler shoots you in the foot even if you're aiming your gun at the duck.
22:15:57 <jdrake> the compiler is just particular
22:16:59 <Pseudonym> I think GHC might support unsafeShootSelfInFoot.
22:17:09 <ozone> less particular than a haskell compiler, i'd say
22:17:41 <jdrake> Ada also has a lot of syntax elements (what was that I read about imperative languages building up the keywords to clutter a language)
22:19:15 <Pseudonym> Ada, like all Wirth languages, has the principle that any two identifiers or constants must be separated with a keyword or operator.
22:19:33 <Pseudonym> That makes it easier to parse top-down, and it also makes diagnosing syntax errors easier.
22:19:45 <ozone> Pseudonym: can i pick your brain about laziness?  in particular, how much expressitivity do you think it lends to a language?
22:19:54 <ozone> well, not really pick your brain so much as a coffee discussion
22:20:06 <Pseudonym> OK.  Should I get coffee first?
22:20:27 <ozone> if you like.  i have water here in a green tea bottle which used to hold green tea, so that counts :)
22:21:05 <Pseudonym> OK.
22:21:22 <Pseudonym> First, I think laziness adds quite a bit of expressivity to a language.
22:21:47 <Pseudonym> Strict languages have to go to some trouble to implement "short circuiting", which lazy languages get for free.
22:22:14 <Pseudonym> From a data structures point of view, lazy languages tend to automatically turn amortised costs into "real" costs.
22:22:32 <Pseudonym> (Not all of them, but a lot of them.)
22:22:43 <ozone> you mean, makes performance worse?
22:23:04 <Pseudonym> I mean makes performance more predictable, which is ironic.
22:23:16 <Pseudonym> Since performance is so much less predictable the rest of the time. :-)
22:23:33 <Pseudonym> Let me give you an example.
22:23:41 <ozone> sure
22:23:51 <Pseudonym> What does it cost to insert an element into a balanced binary search tree?
22:24:15 <Pseudonym> You might say O(log n), but that's not actually true.
22:24:26 <Pseudonym> If you're going to read it again, it's actually O(1) amortised.
22:24:53 <Pseudonym> Similarly, the cost of reversing a list is O(1) amortised if you're going to scan the whole list again.
22:25:09 <Pseudonym> Similarly with the cost of concatenating two lists.
22:25:10 <jdrake> i understand that common qsort example a little more now
22:25:26 <jdrake> what is all this O(1) and O(n), etc. stuff I see around?
22:25:45 <Pseudonym> jdrake: Oh, you haven't studied much computer science?
22:25:54 <jdrake> no
22:25:54 <jdrake> is O(1) constant time, O(n) linear time?
22:27:26 <ozone> jdrake: yes
22:27:53 <jdrake> i assume that O(log n) is logarithmic time, what other common ones are there?
22:28:37 <ozone> jdrake: O(n log n) (lower bound for general sorting algorithms), O(n^2), O(n^3), O(x^n) (exponential)
22:29:49 <ozone> Pseudonym: hmmm.  you really think something like list concatenation is truly amortised to O(1)?
22:30:01 <ozone> i guess i'm thinking more of arrays.  anyway, go on
22:30:32 <jdrake> ozone, shouldn't list concatenation be basically relinking the chain
22:31:06 <ozone> jdrake: relinking the chain?
22:31:18 <jdrake> like (using psuedo-lisp experience) (= (cdr mylist) myotherlist)
22:31:28 <ozone> if you do, e.g. "list1 ++ list2", then you have to make an entire copy of list2
22:31:39 <jdrake> oh sorry even better: (set-car! mylist mylist2)
22:31:44 <ozone> in a purely functional language, anyway
22:31:46 <jdrake> make that cdr
22:31:48 <jdrake> heh
22:31:53 <ozone> so it's O(n) w.r.t. the length of list2
22:32:11 <jdrake> a list to me implies linked
22:32:37 <ozone> yes, but you have to make a copy of list2, not just link the end of list1 to the start of list2
22:32:43 <ozone> because you can use list2 in other contexts
22:33:09 <Cale> list2 isn't about to change, though
22:33:15 <Pseudonym> ozone: Yes, I do.
22:33:27 <Pseudonym> That list concatenation is O(1) amortised.
22:33:53 <Pseudonym> Think of how it's implemented in Haskell.
22:33:57 <Pseudonym> [] ++ ys = ys
22:34:04 <Pseudonym> (x:xs) ++ ys = x : (xs ++ ys)
22:34:12 <Cale> you don't need to copy list2, just reference it
22:34:23 <Pseudonym> If you need to consume an element of xs ++ ys, you can get it in O(1) time, regardless of how big either xs or ys is.
22:34:37 <Pseudonym> The first element, not "an element".
22:34:46 <Pseudonym> So it's O(1).
22:34:47 <ozone> Pseudonym: totally agree with that
22:35:12 <Pseudonym> And this is my point: Lazy evaluation takes the O(1) amortised time, and turns it into an O(1) /worst case/ time.
22:35:55 <Pseudonym> Interestingly, the standard "quick sort" example, assuming the pivot is sane, takes O(n log k) time where k is the length of the list that you consume.
22:36:02 <Pseudonym> Which is, interestingly, optimal.
22:36:03 <jdrake> what does one do in haskell when one really does want to do one thing before another?
22:36:03 <ozone> hmm.  what about array manipulation?  things that people tend to use as evidence that haskell is slow, for example
22:36:12 <Pseudonym> jdrake: Such as?
22:36:38 <Pseudonym> Oh, one other thing.  Lazy evaluation makes dynamic programming almost trivial.
22:36:48 <Cale> jdrake: one might use a monad of some sort - that's one option. Another is recursion.
22:36:51 <ozone> very much agreed about dynamic programming :)
22:37:11 <Pseudonym> OK, now array manipulation.
22:37:26 <Pseudonym> I think Haskell's array manipulation isn't a shining example of what could be possible.
22:37:38 <jdrake> if one function is actually a binding to an outside function that sets some data up and then you need to call another function to set another piece of data up (which is also bound in a similar way)
22:37:55 <Pseudonym> Yes, Haskell's array support isn't great.
22:38:04 <Pseudonym> I don't think that's a fault of lazy evaluation.
22:38:49 <ozone> ok.  are there other cases in haskell where you think lazy evaluation is often blamed for badness, where it's haskell's implementation that's the problem?  (off the top of your head)
22:39:10 <Pseudonym> Not off the top of my head, no.
22:39:25 <Pseudonym> I think the biggest problem with lazy evaluation is that it does impose an overhead when you don't use it.
22:39:30 <Cale> jdrake: you possibly want to use the IO monad
22:39:41 <np_hard> i tend to run into an issue with unevaluated constructors filling the stack
22:39:59 <ozone> Pseudonym: it seems that the majority of performance issues i've observed with haskell has been with arrays
22:40:24 <Pseudonym> It'd be much better from an efficiency point of view to be able to "turn on" lazy evaluation only when it's needed.
22:40:52 <Pseudonym> See, I don't use arrays that much.
22:40:54 <ozone> Pseudonym: but then you need to annotate your programs with laziness, and your expressitivity takes a nosedive
22:41:00 <Pseudonym> It's probably the kind of code that I write.
22:41:08 <Pseudonym> ozone: Not necessarily.
22:41:17 <Pseudonym> Think about where you want laziness.
22:41:23 <Pseudonym> Only in two places, really.
22:41:31 <Pseudonym> One is in the arguments of data constructors.
22:41:36 <Pseudonym> The other is in arguments to functions.
22:41:53 * Jerub prints the parsec docs.
22:41:56 <Pseudonym> At the moment, Haskell has a punctuation mark, !, to mark "strictness" in the first case.
22:42:09 <Pseudonym> How hard could it be to simply switch the sense?
22:42:20 <Pseudonym> And GHC supports that for function arguments, too.
22:42:32 <np_hard> if you want ML you know where to find it
22:42:40 <np_hard> ;)
22:42:42 <Pseudonym> :-)
22:42:46 <Cale> some people were working on strict Haskell
22:42:51 <Pseudonym> Yes.
22:43:00 <ozone> ghc supports it for function arguments?
22:43:01 <Jerub> strict haskell?
22:43:17 <Jerub> ooh, as in evaluation.
22:43:19 <Pseudonym> Now of course, the overhead is ameliorated a bit because it improves cache and GC behaviour.
22:43:29 <Pseudonym> Chances are, immediately after something is produced, it will be consumed.
22:43:35 <Pseudonym> And will subsequently become garbage.
22:43:45 <Pseudonym> You can't buy locality that good.
22:44:08 <Pseudonym> That's one reason why GHC is one of the very few language implementations which has a generational GC.
22:44:24 <Pseudonym> For Haskell, generational GC is optimal.
22:44:46 <ozone> Jerub: there's a neat project called optimistic haskell (done by robert ennals): in a nutshell, tries to be strict about everything, and falls back to laziness after various heuristics
22:45:07 <ozone> Pseudonym: i can't find anything about strictness annotations for function arguments in GHC's docs
22:46:18 <Pseudonym> Hang on.
22:46:27 <ozone> Jerub: and as a consequence of optimistic haskell, robert also wrote hsdebug, a gdb-style debugger for haskell, which totally rocked. :)
22:47:42 <Pseudonym> Hmmm, you're right.  I've used it, though.
22:48:00 <Pseudonym> I think.
22:48:06 <Pseudonym> Maybe I dreamed it.
22:48:36 <Pseudonym> Anyway, data constructors is the more useful of the two.
22:48:37 <ozone> can you actually make lists strict in haskell?
22:48:46 <Pseudonym> Not the built-in ones, no.
22:48:49 <ozone> i don't suppose you can do something like :: ! [Int]
22:48:52 <Pseudonym> But you can DeeqSeq them.
22:49:10 <Pseudonym> Yes, you can do that, but then only the top-level (:) or [] is strict.
22:50:26 <ozone> Pseudonym: i'm still undecided about whether the usual performance tradeoffs with laziness are worth it
22:50:41 <ozone> (tradeoffs = worse, more unpredictable performance)
22:51:11 * Pseudonym nods
22:51:16 <Pseudonym> I don't know either.
22:51:35 <Pseudonym> Oh, one more thing.  Laziness makes the semantics of the language a lot cleaner.
22:51:56 <ozone> i'm pondering what would happen if you had a simple "use laziness" pragma which affects the current module
22:51:59 <Pseudonym> It makes lots of optimisations possible that otherwise would need extensive analysis.
22:52:12 <Pseudonym> ozone: I don't think that's possible.
22:52:20 <Pseudonym> Laziness affects anyone else who uses the module too.
22:54:15 <ozone> if you have such a lazy module, then would its laziness be restricted to just that module?
22:54:49 <Pseudonym> Well, you'd need to deepSeq any data structure which moved across the module boundary.
22:58:28 <ozone> Pseudonym: i think my main concern is that if you have laziness, it may lead to worse performance
22:58:38 <ozone> and working around that worse performance requires a lot of arcana
22:59:00 <Pseudonym> I think that's generally true.
22:59:12 <ozone> if you have strict semantics, performance is more predictable, and then you lose expressivity, even in a language which has a 'lazy' operator
22:59:25 <Pseudonym> At least, it's true at the moment.
22:59:33 <ozone> yep, sure.
22:59:49 <Pseudonym> Part of the problem is that it was believed that strictness analysis would solve most of the problem.
22:59:54 <Pseudonym> I think we now know that this isn't true.
23:00:06 <ozone> nod, and it hasn't achieved as a big a benefit as originally hoped
23:00:13 <Pseudonym> Right.
23:00:20 <ozone> the arcana bit is annoying
23:00:28 <Pseudonym> OTOH, compilers could do more with strictness annotations on data structures.
23:00:36 <ozone> i think if you had an easy way to work around laziness' performance issues, then it'd be much more acceptable
23:00:37 <Pseudonym> And programmers could use them more!
23:00:59 <Pseudonym> Here's one example.
23:01:06 <ozone> e.g. like a magic "use strictness only" pragma that i was talking about above
23:01:18 <Pseudonym> If you had a list like this: data List a = Nil | Cons a !(List a)
23:01:22 <Pseudonym> With a strict tail.
23:01:33 <ozone> mmm
23:01:39 <Pseudonym> Then "append" on this list could be made to run in O(1) stack space.
23:01:53 <Pseudonym> Using tail-call-modulo-constructor optimisation.
23:01:55 * ozone tries to think
23:03:00 <Pseudonym> Well, think how you'd do it in an imperative language.
23:03:04 <Pseudonym> You could do it with a loop.
23:03:36 <Pseudonym> http://www.dsi.unive.it/~lopstr99/Elect-Proceedings/PS/lopstr99-10.ps
23:03:41 <Pseudonym> See also that paper.
23:03:50 <ozone> ah, right
23:04:10 <ozone> i wish haskell had some syntactic sugar for arrays
23:04:16 <Pseudonym> Yes.
23:04:21 <Pseudonym> I agree.
23:04:25 <ozone> i really should get around to writing that haskell pre-processor i've been dreaming of for the past year
23:04:36 <Pseudonym> Have you had a look at sisal?
23:04:46 <ozone> no
23:04:50 <Pseudonym> http://www2.cmp.uea.ac.uk/~jrwg/Sisal/
23:04:55 <Pseudonym> Take a look.  It might give you ideas.
23:05:16 <ozone> thanks :)
23:06:06 <ozone> btw, i went to a talk a few weeks ago by steve blackburn on combining RC+generational GC techniques
23:06:28 <Pseudonym> Oh?
23:06:39 <ozone> ulterior reference counting, that's what it's called
23:06:48 <Pseudonym> Interesting.
23:06:56 <ozone> http://www.cs.purdue.edu/homes/hosking/690M/urc-oopsla-2003.pdf
23:07:16 <Pseudonym> Thanks, I'll take a look.
23:07:20 <ozone> in a nutshell: as good performance as the best generational collectors, better latency than RC ones
23:07:38 <ozone> he's got a student who wants to put it into GHC :)
23:07:49 <Pseudonym> What's the overhead for each object?
23:08:17 <Pseudonym> Yeah, not surprised that it's for Jikes.
23:08:27 <Pseudonym> Jikes is getting a lot of interesting GC research.
23:08:56 <ozone> not sure what you mean by overhead.  write barrier?
23:09:03 <Pseudonym> I mean space overhead.
23:09:19 <Pseudonym> RC requires a whole additional word attached to each object.
23:09:29 <Pseudonym> Whereas mark & sweep only needs a bit or two.
23:10:47 <ozone> it has the same overhead (word) for objects which are RC'ed, which are the "old" objects (things not in the nursery), i think
23:11:07 * Pseudonym nods
23:17:54 <Pseudonym> Home time for me.
23:17:58 <ozone> ditto
23:17:59 <ozone> later!
23:18:14 <Pseudonym> Night.
23:23:11 <evilcthul> hey anyone alive? :)
23:23:18 <Cale> yep
23:24:54 <evilcthul> can someone help me debug some haskell
23:24:56 <evilcthul> ;)
23:25:24 <Cale> I might be able to
23:25:55 <evilcthul> can i pm you? :)
23:26:06 <Cale> here, let me get a wikipage
23:26:22 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
23:26:34 <Cale> go there, to the bottom, and click edit, and paste the code
23:27:10 <evilcthul> erm?
23:27:34 <Cale> reload, perhaps it will be more obvious
23:27:45 <evilcthul> ahh
23:27:47 <evilcthul> it says paste here
23:27:48 <evilcthul> ;)
23:27:53 <evilcthul> before it had a program in there..
23:28:07 <Cale> if you click the EditText link, you can change the page and paste it
23:28:23 <evilcthul> should be there..
23:28:54 <evilcthul> when i compile it it's giving me possibly incorrect indentation errors on every TS from line 55 downwards
23:29:57 <Cale> how long is the code?
23:30:13 <evilcthul> 413 lines
23:30:15 <evilcthul> including comments
23:30:15 <Cale> just wondering, as the page seems to be taking its time loading :)
23:30:19 <evilcthul> yeah
23:30:22 <evilcthul> erm it's not loading for me either
23:30:27 <Cale> odd.
23:30:33 <Cale> shapr: you around?
23:30:36 <evilcthul> https://cgi.cse.unsw.edu.au/~cs1711cgi/cgi-bin/task1/task1.php
23:30:40 <evilcthul> we're copying this..
23:30:56 <evilcthul> i'm learning haskell and i've just got that cryptic error..
23:31:17 <evilcthul> basically it's just a pronounce tool for WELSH/FRENCH/JAPANESE/ENGLISH 
23:31:44 <saz> what error is it giving?
23:31:52 <shapr> Cale: what can I do for you?
23:32:05 <Cale> The IRC Paste page isn't loading
23:32:29 <Cale> or at least, it's taking a long long time
23:32:32 <shapr> ok, I'll check it out
23:32:41 <evilcthul> sorry in advance if i killed it
23:32:55 <shapr> no worries
23:33:03 <evilcthul> do you guys have any suggestions for haskell text editors? i'm using Context + Haskell Syntax highlighter
23:33:21 <Cale> I use vim.
23:33:24 <shapr> I use emacs
23:33:27 <Cale> actually, gvim
23:33:54 <Cale> try http://vx.hn.org/wiki.pl?RandomPastes
23:34:00 <Cale> and see if that works
23:34:11 <Cale> (same idea applies)
23:34:41 <shapr> eek
23:34:43 <shapr> hda: dma_intr: error=0x40 { UncorrectableError }, LBAsect=75426955, sector=580056
23:34:58 <evilcthul> oh god
23:35:10 <Cale> hehe, don't worry - I have the code now
23:35:10 <evilcthul> http://vx.hn.org/wiki.pl?RandomPastes
23:35:11 <evilcthul> worked..
23:35:12 <shapr> evilcthul: obviously not something you can do remotely :-)
23:35:22 <evilcthul> the formatting is all worng
23:35:25 <Cale> right
23:35:30 <Cale> s'ok
23:35:30 <evilcthul> on the paste that is..
23:36:12 <shapr> andersca: haskell.org runs dbus ;-)
23:36:32 <Cale> now it's at http://vx.hn.org/autoshare/task.hs
23:36:33 <Cale> :)
23:37:21 <evilcthul> or do you want my file?
23:37:47 <Cale> I see the error that you're getting.
23:38:12 <Cale> btw, you know that take3 etc here are better implemented as take 3?
23:38:28 <evilcthul> take 3? sorry i dont understand what your'e getting at
23:38:36 <Cale> take3 :: [Int] -> [Int]
23:38:37 <Cale> take3 listofNums = firstNum:secondNum:[thirdNum]
23:38:37 <Cale>          where
23:38:37 <Cale>               firstNum  = (head listofNums)
23:38:37 <Cale>               secondNum = (head (tail listofNums))
23:38:37 <Cale>               thirdNum  = (head (tail (tail listofNums))
23:38:39 <evilcthul> i've only been learning haskell two weeks so there are lots of higher order functions i can't use..
23:38:50 <Cale> take3 = take 3
23:39:18 <evilcthul> but you can't have a space in a function name?
23:39:52 <Cale> take is a function that takes an Int called n and returns a function which takes a list and gives the first n items.
23:40:09 <evilcthul> oh
23:40:13 <evilcthul> is take already a reserved function?
23:40:22 <Cale> alternately, it's a function of two parameters, the first is an int, and the second a list
23:40:29 <Cale> take is in the Prelude
23:40:33 <evilcthul> wait it is
23:40:39 <evilcthul> yeah but i'm not allowed to use take..
23:40:46 <evilcthul> because we haven't covered it in lectures..
23:40:50 <Cale> so why not at least write it yourself?
23:41:10 <evilcthul> so i have to program it myself..
23:41:13 <Cale> it'll save about 35 lines of code :)
23:41:22 <Cale> well, the Prelude is online
23:41:31 <evilcthul> i'm using GHC
23:41:35 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
23:41:37 <evilcthul> i'll program take recursively i guess
23:41:56 <Cale> take                   :: Int -> [a] -> [a]
23:41:56 <Cale> take n _      | n <= 0 =  []
23:41:56 <Cale> take _ []              =  []
23:41:56 <Cale> take n (x:xs)          =  x : take (n-1) xs
23:42:03 <Cale> is how it's defined in the prelude
23:42:13 <Cale> you might want to try doing it yourself though
23:42:49 <evilcthul> yeah i'll do it myself
23:42:56 <evilcthul> but anyway how do i get rid of the indentation problem?
23:43:08 <evilcthul> i dont see why haskell is freaking.. ;)
23:43:13 <evilcthul> well GHC anyway
23:46:27 <Cale> I haven't caught the parse error yet either.
23:47:03 <evilcthul> maybe it's only with the way my code is formatted 
23:47:14 <Cale> doh
23:47:18 <Cale> missing paren
23:47:25 <Cale> at the end of thirdNum
23:47:38 <Cale> you shouldn't write things that way anyway
23:48:28 <Cale> even if you wanted to do it somewhat like that, a much nicer way to write it might be something like take4 (x:y:z:w:xs) = [x,y,z,w]
23:48:54 <evilcthul> ahh i got it
23:48:56 <evilcthul> thanks
23:49:05 <Cale> also, when you have large chains of compositions like that
23:49:11 <Cale> (head (tail (tail listofNums)))
23:49:16 <Cale> is the same as
23:49:32 <Cale> head $ tail $ tail $ listofNums
23:49:42 <Cale> just a little cleaner to look at
23:49:49 <evilcthul> i haven't learn the $ operator yet ;)
23:49:56 <Cale> it's just function application
23:50:20 <Cale> it's just it has *low* precedence, so it's like you're putting brackets around the stuff on the right
23:50:30 <Cale> f $ x = f x
23:51:24 <evilcthul> ahh ok
23:51:33 <evilcthul> half hte marks for this project are based on style
23:52:04 <evilcthul> i'm trying to set it out relatively neatly..
23:52:39 <Cale> try to think of clever ways to use lists to get around the problem of having lots of cases
23:52:59 <evilcthul> i'll make the take function..
23:54:13 <evilcthul> also another question
23:54:21 <evilcthul> is the haskell character "\n" new line?
23:54:37 <evilcthul> everytime i try '\n' or "\n" it prints the characters..
23:54:52 <Cale> \n should work
23:55:23 <Cale> what are you using to print the string?
23:56:09 <Cale> also, wouldn't it be nice if there was some nice data structure which had all the information on how to pronounce the numbers in a given language?
23:56:28 <Cale> For style points, you might want to think about that.
23:56:51 <evilcthul> -- Crazy helper
23:56:52 <evilcthul> cHelp :: Int -> String
23:56:52 <evilcthul> cHelp num1
23:56:52 <evilcthul>                | num1 /= 2123456789    = (n2e num1) ++ "\n" ++ (cHelp (num1+1))
23:56:52 <evilcthul>                | otherwise              = ""
23:57:06 <evilcthul> i was trying to get it to print out the numbers seperated on lines so i could check the output quickly..
23:57:18 <shapr> I'm not really sure what's going on with the Wiki, I can see that it has something to do with the enscript plugin, but I can't figure out what.
23:57:34 <evilcthul> if i killed it i'm sorry ;)
23:57:38 <Cale> evilcthul: what were you doing to print the string?
23:57:40 <shapr> nah, not your fault
23:57:56 <Cale> if you putStrLn it, it should go onto separate lines.
23:58:03 <shapr> after seeing those IDE errors, I do think I'll grab a backup of the pages though
23:58:10 <Cale> or even just putStr
23:58:11 <evilcthul> well n2e does pronounce "ENGLISH" 212345780
23:58:24 <evilcthul> for example and i'm trying to have it spit out 2123456781-2-3-4...9
23:58:25 <shapr> if haskell.org goes belly up, I'll be able to put up a temporary backup on ScannedInAvian.org
23:58:52 <evilcthul> scannedinavaian.. haha ;)
23:58:58 * shapr grins
23:59:04 <shapr> thank you :-)
23:59:08 <evilcthul> that one is clever..
23:59:27 <shapr> I moved to Sweden, I'm from Alabama originally
23:59:45 <shapr> talar du svenska?
23:59:47 <evilcthul> the coolest was our lecturer though he had a tshirt that said "No iraqis were killed to fuel this bicycle" 
23:59:52 <evilcthul> hej hej 
23:59:54 * shapr gins
23:59:55 <evilcthul> that's about all i can say
23:59:56 <evilcthul> and skoll
