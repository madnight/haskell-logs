00:41:16 <shapr> yow!
00:43:49 <shrimpx> hi
00:44:33 <shapr> hi shrimpx, what's up?
00:44:38 <shrimpx> not much
00:44:52 <shrimpx> hanging out
00:46:04 <shapr> hm, what to do today?
01:27:15 <shapr> swedish homework
01:30:24 <shapr> Has anyone tried Scala?
01:32:31 <kosmikus> I've followed an introductory course on it in summer 2002
01:32:37 <shapr> what did you think?
01:32:46 <kosmikus> seems very neat
01:33:07 <shapr> any comparisons with Haskell?
01:33:45 <kosmikus> it's not mainly a functional language, although it has a lot of functional features
01:33:52 <kosmikus> iirc, it is strict and has side effects
01:34:17 <kosmikus> it supports objects, and has an object type system which is more expressive than what most other languages I've seen can offer
01:35:01 <shapr> that does sound neat
01:35:17 <kosmikus> but it's a long time ago already -- I think it's definitely worth a closer look though, if you have time, especially since it translates to the jvm and can reuse all of java's libraries, if they didn't change that
01:35:39 <shapr> I'll check it out, thanks.
02:12:50 <shapr> yay! I got my TTY/Prologin poster!
04:15:37 <shapr> yow!
04:15:38 <shapr> @yow !
04:15:39 <betabot> My LESLIE GORE record is BROKEN..
04:16:12 <shapr> @arr
04:16:13 <betabot> Avast!
04:18:36 <Cale> @yow
04:18:36 <betabot> "THE LITTLE PINK FLESH SISTERS," I saw them at th' FLUORESCENT BULB
04:18:36 <betabot>  MAKERS CONVENTION...
04:20:20 <earthy> ye scurvy scallywag!
04:20:34 <earthy> @type head
04:20:35 <betabot> head :: [a] -> a
04:24:48 <liiwi> afternoon
04:25:46 <shapr> y0w!
04:30:56 <det> @type brunette
04:32:29 <shapr> I got my TTY poster this morning! - http://www.prologin.org/archives/affiches.php?affiche=affiche_2004_grand.jpg
04:32:34 * shapr bounces happily
04:32:52 <shapr> that's the famous cat named TTY on that poster.
04:32:57 <ibid> tampereen teknillinen yliopisto? :)
04:33:11 <shapr> ei ole :-P
04:33:14 <ibid> ah, cat tty :)
04:33:54 <shapr> I've been trying to persuade two of TTY's friends to teach her Haskell.
04:34:08 <shapr> They said she didn't like ML, so I'm not sure if it'll happen.
04:38:04 <[3N1GM4]> I need to convert a Char to a float in Haskell, anyone got any tips?
04:38:33 <shapr> should be easy enough once you figure out how you want to map from char to float
04:39:35 <[3N1GM4]> sorry, string to float, my mistake
04:39:46 <ibid> shapr's comment still applies
04:40:30 <[3N1GM4]> Hoiw I want to map? I just want to wrote a function which takes one argument (a String) and returns a float:     convert :: String -> Float
04:40:54 <kosmikus> read ?
04:41:20 <[3N1GM4]> how would I use read? Sorry, I am quite ill at the moment and not thinking straight.
04:41:36 <shapr> read "1.0" :: Float
04:41:47 <[3N1GM4]> just like that?
04:41:56 <ibid> if i were mean, i'd say convert _ = 3.14
04:41:56 <ibid> ;)
04:41:57 <[3N1GM4]> read st :: Float
04:42:07 <[3N1GM4]> where st is my string
04:42:30 <[3N1GM4]> yes?
04:42:40 <kosmikus> try it
04:42:43 <[3N1GM4]> ok
04:49:07 <shapr> Jad: what does [asc] mean?
04:49:29 <Jad> this is my work place
04:49:48 <shapr> oh, ok
05:04:40 <Jerub> hmm
05:07:03 <shapr> ?
05:13:50 <Lunar^> shapr: did you fix ScannedInAvian ?
05:14:12 <Lunar^> shapr: Who did you try to persuade ? (names, names)
05:23:29 <shapr> Lunar^: I did not yet fix ScannedInAvian. Persuade about what?
05:23:35 <shapr> ohhh
05:23:52 <shapr> I was talking to Elrond
05:24:02 <shapr> Raphael PÃ¶ss I think?
05:24:22 <Lunar^> shapr: Maybe
05:24:32 <Lunar^> shapr: Strange that you know them
05:24:33 <shapr> he's elrond42 on this irc network
05:24:40 <shapr> why is that strange?
05:24:41 <Lunar^> 42 :)
05:24:51 <Lunar^> dunno... EPITA is everywhere
05:25:00 <shapr> I've known him for several years from #lojban
05:25:12 <Lunar^> What's that !?
05:25:17 <shapr> lojban.org
05:25:30 <shapr> it's an artificially constructed language.
05:25:36 <shapr> it's part of why I started learning Haskell, too.
05:26:03 <Lunar^> Sure... I already read about that
05:26:06 <Lunar^> ??
05:26:14 <ecraven> hehe, how does lojban connect to haskell?
05:26:36 <shapr> because I want to make a spoken programming language, and I think lojban and haskell are the two pieces to combine.
05:26:49 <ecraven> hm.. cool idea :)
05:27:00 <Lunar^> spoken programing language ?!
05:27:06 <Lunar^> I like the idea
05:27:08 <shapr> well, I've gotten distracted into the sheer coolness of Haskell.
05:27:21 <shapr> and then type theory, and group theory, and now category theory.
05:27:25 <shapr> there's so much to learn :-)
05:27:26 * earthy grins
05:27:29 <earthy> and nods
05:27:33 <shapr> greetings cologic, looking for Haskell info?
05:27:44 <shapr> I'm glad there will always be something to learn.
05:29:01 <shapr> Lunar^: sadly, there has been no progress towards a spoken programming language, the major obstacle is that speech recognition is a black art at worst, and vocabulary specific at best.
05:29:33 <shapr> that means that each time you refactored the design of such a language, you may have to rewrite the recognition engine.
05:30:02 <Lunar^> mhhh sure
05:30:32 <cologic> shapr: nothing specific, but it's interesting to me as one of the purer examples of what to me is a nice way of programming. (Though I have a nagging suspicion that was an autoresponse on your part.)
05:30:44 <shapr> cologic: nope, not an autoresponse.
05:30:47 <shapr> I AM NOT A BOT!
05:31:05 <shapr> geez, I think I'm going to add that to the channel topic.
05:31:07 <Jerub> @yow
05:31:08 <betabot> ..  does your DRESSING ROOM have enough ASPARAGUS?
05:31:08 <shapr> y0 SyntaxNinja 
05:31:09 <cologic> You failed the turing test.
05:31:21 <shapr> I hate it when that happens.
05:31:27 <SyntaxNinja> hey shapr
05:31:34 <cologic> Speech recognition works reasonably well, I thought.
05:31:41 <cologic> (I've done more with ML-type languages actually.)
05:31:43 <Jerub> cologic: what planet are you from ;)
05:31:54 <shapr> have you tried the open source speech recog engines?
05:32:02 <SyntaxNinja> shapr: darcs builds :)
05:32:05 <shapr> even better, have you tried to modify one to use another language?
05:32:08 <shapr> SyntaxNinja: happiness!
05:32:11 <SyntaxNinja> auto-builder success is complete!
05:32:13 <SyntaxNinja> well, almost
05:32:27 * Jerub cleans up his public_html dir
05:32:42 <cologic> Jerub: heh. Not one with direct experience, just repeating secondhand sentiments.
05:33:38 * Igloo is worried by the IA64 failure
05:33:44 <Igloo> That should be one of the better supported platforms
05:36:02 <SyntaxNinja> bus error is strange
05:36:16 <SyntaxNinja> so what is workaround anyway?
05:36:35 <SyntaxNinja> is that a ghc bug?
05:37:02 <Igloo> It works around bugs in GHC I think
05:37:15 <Igloo> It's a GHC bug. Amusingly it's possible it's being caused by working around a GHC bug  :-)
05:37:48 <Igloo> My worry is that GHC doesn't /succesfully/ compile anything (outside of configure, at least)
05:38:57 <SyntaxNinja> on that arch?
05:39:10 <Igloo> Yup
05:39:13 <SyntaxNinja> I guess ghc builds itself on that arch
05:39:30 <Igloo> Well, it did in the past  :-)
05:42:39 * Igloo mail d-a to get ghc6 on merulo
05:57:41 <np_hard> ok, is there a Prelude or library function that will do something like this for me? I want to write something like:
05:58:05 <np_hard> | isPrefixOf symbol str = ...
05:58:22 <np_hard> in a guard clause, where symbol is any element of a list symbols
05:58:54 <np_hard> or should I say, | isPrefixOf symbol str = fooify symbol ...
05:58:56 <Igloo> any (`isPrefixOf` str) symbols
05:59:24 <np_hard> right, but I want to refer to the specific one matched 
05:59:42 <np_hard> in the rhs of the guard clause
06:00:32 <shapr> you could use the pattern binder thingies
06:00:56 <np_hard> I suppose I could if I know what you meant
06:00:56 <np_hard> :)
06:01:03 <shapr> p@('T':'E':'S':'T':rest)
06:01:07 <shapr> but that sort of cheesy
06:01:54 <np_hard> plus it only works for one-char symbols right?
06:02:23 <np_hard> or
06:02:27 <np_hard> no, nm, I see what you are saying
06:02:31 <np_hard> that is cheesy
06:02:47 <shapr> yup :-)
06:04:34 <np_hard> I guess I might be able to write/use something that works with Mayve
06:04:36 <np_hard> er, Maybe
06:04:40 <np_hard> that might be the way to go
06:05:35 <np_hard> f sym syms 
06:05:46 <np_hard>     | elem sym syms = Just sym
06:05:51 <np_hard>      | otherwise = Nothing
06:06:00 <np_hard> that seems like it should already exist though
06:06:00 <np_hard> :)
06:09:33 <shapr> what are you trying to do?
06:10:47 <np_hard> tokenize a string without relying on the words function (i.e. do the right thing with "(1+ (2*3) )"
06:11:01 <np_hard> and it is mostly a learning experience so don't point me to a full-featured lexer library
06:11:20 <np_hard> I am just trying to figure out the good approaches in Haskell for these problems
06:11:20 <np_hard> :)
06:15:31 <Cale> np_hard: although you said not to point you at libraries, you should probably have a look at Parsec anyway, as it's pretty cool :)
06:16:09 <shapr> yah, parsec kicks ass
06:16:27 <Cale> It comes with GHC too :)
06:17:01 <Cale> http://www.cs.uu.nl/people/daan/download/parsec/parsec.html
06:17:16 <Igloo> If you actually want a Haskell parser than happy+alex is simpler IMO
06:17:37 <np_hard> nonono
06:17:48 <SyntaxNinja> haha
06:18:06 <np_hard> I just want to compare my silly rpn evaluator in C++ from school to the equivalent in Haskell
06:18:07 <np_hard> :)
06:18:15 <SyntaxNinja> np_hard: did you try yacc? you can use the FFI!
06:18:17 <SyntaxNinja> ;)
06:18:17 <Cale> I know that you're just trying to code something up, but Parsec is a good example of what can be done
06:18:20 <np_hard> arg
06:18:26 <Cale> heheheh
06:18:56 <np_hard> i do appreciate it, obviously the best approach to code is to use someone else's full featured and well tested library
06:19:24 <np_hard> but I am just trying to understand the approaches to these problems that make the most sense in Haskell :)
06:19:31 <np_hard> since I don't know it well
06:19:43 <Cale> Parsec is really cool because you can build your parser at runtime, and parsers are values and can be glued together in various ways.
06:19:54 <np_hard> ah ha ha
06:20:02 <np_hard> right now I just want a lexer
06:20:07 <np_hard> suppose I never want to parse it? ;)
06:20:18 <Cale> not hard to use it for a lexer.
06:20:33 <Cale> Though it's quite possibly overkill :)
06:20:50 <SyntaxNinja> haha
06:44:13 <Lemmih> shapr: Can I get 10mins of your time?
07:05:52 <shapr> Lemmih: what's up?
07:06:59 <Igloo> Bother, "Illegal instruction" on merulo
07:07:39 <shapr> case instruction of "jump off a cliff" -> raise "Illegal instruction"
07:08:05 <shapr> Lemmih: you around?
07:08:12 <Lemmih> yeah
07:09:08 <shapr> Lemmih: what can I do for you?
07:09:39 <Lemmih> Can you help me with a global installation of hasdl (GHC)?
07:10:30 <shapr> I don't know, maybe.
07:11:34 <shapr> oh, it looks like hasdl 0.1-pre7 doesn't have support for a 'global' installation
07:13:18 <kowey> ... hey, what's everyone's favourite debugger?
07:13:23 * kowey is playing with hood
07:14:31 <shapr> Lemmih: I think a global installation of hasdl will probably require massaging hasdl into a global package. I don't think that would be very difficult, but I don't have time to try it.
07:14:36 <shapr> have you used ghc-pkg before?
07:15:11 <SyntaxNinja> Igloo: is that for darcs only?
07:15:29 <Igloo> That's when just typing "ghc"
07:15:59 <SyntaxNinja> yuck
07:16:22 <Igloo> I'll re-port it and see if it works then. I should also add a compile check at the end of the GHC build as well as in the middle
07:16:36 <Igloo> Actually,  think it is at the end, just before all the threaded stuff. Hmmm.
07:17:20 <Igloo> Well, seeing if I can report it is the first step anyway
07:17:27 <Lemmih> shapr: Nope.
07:18:10 <shapr> ghc-pkg isn't scary.
07:18:44 <shapr> ghc-pkg -l shows you all the packages you have on your system, and ghc-pkg -s net will show you the fields involved in using the net package for example.
07:20:16 <shapr> all the info you'd need to see in ghc-pkg is already present in the hasdl Makefile
07:20:41 <Lemmih> ok thx
07:20:44 <shapr> just in a slightly different format.
07:27:20 <SyntaxNinja> any arrow experts around?  Is there something terribly nieve about trying to implement something like:
07:27:20 <SyntaxNinja> mapArrow :: (Arrow ar) => ar a b -> ar [a] [b]
07:27:46 <SyntaxNinja> now my implementation relies on laziness, but I'm not clear if I can do so with the arrow combinators:
07:27:46 <SyntaxNinja> mapArrow sf
07:27:46 <SyntaxNinja>     = proc l -> do
07:27:46 <SyntaxNinja>        h' <- sf -< head l
07:27:46 <SyntaxNinja>        t' <- mapArrow sf -< tail l
07:27:47 <SyntaxNinja>        returnA -< if null l then [] else h':t'
07:27:55 <SyntaxNinja> Is there a better way to implement this?
07:29:26 <shapr> can't you easily find whether you can rely on the laziness?
07:29:44 <SyntaxNinja> now I'm not even convinced it makes sense
07:29:53 <SyntaxNinja> um. well, I know my program doesn't terminate, but i'm not sure why yet.
07:29:54 <shapr> for example, create a list that's four or five elements long, and put a div by zero in the last item, then take the first two?
07:30:30 <shapr> as in, take the first two items of the result list of the map
07:30:47 <SyntaxNinja> well, all I would have to do is test it on an empty list
07:31:11 <shapr> how would that tell if it's lazy?
07:31:28 <SyntaxNinja> well, the head would cause it to fail
07:31:29 <Igloo> Can you not do the test for [] earlier?
07:31:54 <SyntaxNinja> Igloo: I'm not sure how, actually.
07:32:00 <SyntaxNinja> since it's not ArrowChoice
07:32:14 <SyntaxNinja> but I'll try writing an auxilury function
07:32:14 * Igloo doesn't know what restrictions arrows impose so you might not be able to
07:32:45 <shapr> I have two filenames(?), both of which are hardlinked to the same file, if I delete one, does it keep the other?
07:32:51 <Igloo> Yes
07:33:08 <shapr> ah, spiffy, thanks.
07:37:57 <shapr> sometimes I think I should take a remedial course in gnu utilities and their options.
07:41:09 <cologic> (Though this specific example, I believe, involves filesystem semantics more than userland stuff.)
07:41:56 <shapr> over the last two days, I've learned quite a few things about tar and find, and various other useful stuff.
07:42:34 <shapr> I realized my life would easier if I read the entire man page for each of the gnu utilities, and tried out the various options.
07:43:48 * shapr temporarily suspends his own Unix Sysadmin membership.
07:44:12 <cologic> Some of the manpages are rather long; I've seen awk and sed manpages that describe what are entire programming languages...
07:44:50 <shapr> a recent article on one of kragen sitaker's mailing lists showed how to write a general purpose term-rewriting system with awk or sed, I forget which.
07:45:17 <shapr> I've heard that Stratego is a slightly more advanced implementation of sed
07:45:34 <cologic> Only sed is masochistic enough to make such things all that interesting to read about.
07:45:44 <cologic> awk is too powerful really.
07:45:56 <cologic> Ignoring the whole Turing-completeness thing.
07:46:16 <Lemmih> shapr: So the package info should look like this: http://212.242.49.100/hasdl.pkg right?
07:46:51 <shapr> that looks sane at first glance
07:47:00 <shapr> you can try the pkg file without directly installing it
07:47:06 <shapr> I'd recommend that in fact.
07:47:27 <shapr> HaskellDB's test code does that, so you can 'try before you buy'
07:48:36 <Lemmih> But I need to move some file to /usr/lib/ghc-6.2/libHSsdl.a right?
07:49:04 <shapr> or change it for the test config
07:50:50 * Lemmih is confused.
07:51:08 <shapr> ?
07:53:04 <Lemmih> I'm not quite sure which file is the actual library.
08:04:18 <shapr> huh?
08:04:36 <Lemmih> I need to move the library file to /usr/bin/ghc-6.2/libHSsdl.a right?
08:05:03 <shapr> oh, I see.
08:05:38 <Lunar^> Lemmih: Is there any homepage for this ?
08:05:42 <shapr> I don't know how you get a libHSfoo.a file with the ffi
08:05:56 <Lemmih> But I don't believe that it has compiled a library. It look like it's just compiling an example against the hasdl source files. (I don't know much about Haskell so I could be wrong)
08:06:05 <shapr> Lunar^: http://shapr.homelinux.net/~shae/hasdl-0.1pre7.tar.gz
08:06:16 <shapr> Lemmih: yes, you're right.
08:06:52 <Lunar^> shapr: Which magic ?
08:07:46 <shapr> magic?
08:08:00 <shapr> je ne comprends pas!
08:08:01 <liiwi> evening
08:08:15 <Lunar^> shapr: Did you make all the binding yourself ?
08:08:41 <shapr> no, richard braakman made them
08:08:43 <shapr> aka dark
08:09:58 <Lunar^> shapr: Lot of grunt work... cool stuff thanks :)
08:11:15 <Lunar^> shapr: I think I will borrow his Key type for my keyboard driver
08:13:41 <liiwi> hmm
08:13:58 * liiwi wonders where dark is, haven't seen him in a loong while
08:30:31 <shapr> liiwi: last I heard he was playing "A Tale in the Desert" and writing a game in a combination of Haskell and PHP I think.
08:32:41 <shapr> it occurs to me that haskell-libs could become something like the 'great java tree' where there's a searchable list of products, filenames, classes, datatypes, etc.
09:39:31 <shapr> isn't there some new way to burn CDs with linux 2.6?
09:40:16 <mattam> direct IDE ?
09:40:24 <shapr> is that it?
09:40:33 <mattam> i think so.
09:40:50 <cologic> I believe so. Linus really dislikes ide-scsi, as well as cdrecord's author's opinion about it all.
09:41:11 <mattam> you can directly give the --device /dev/cdroms/* to cdrecord (with newer versions).
09:41:38 <shapr> that's handy
09:47:19 <Marvin--> "about time" is another way to put it ;)
09:49:19 <cologic> I recall seeing that the only real users of ide-scsi left were some tape drivers.
09:51:36 <Marvin--> gnome 2.6 looks spiffy
09:52:52 <shapr> whoa, does DiskT@2 require Yamaha hardware?
09:53:19 <shapr> hm, I just want to get this file onto my CDRW.
09:59:28 <mattam> cologic: afaik, usb mass storage devices also use some related scsi code.
09:59:59 * mattam back to bananas
10:33:22 <SyntaxNinja> so does anyone know chris moline (/me is behind on haskell-cafe mail)
10:41:41 <SyntaxNinja> hm
10:41:44 * SyntaxNinja reboots
11:10:43 <stepcut> is there any source for generic autoconf/Makefiles for building haskell libraries
11:11:14 <stepcut> like, if I want to make a third party library, the makefile should  have 'install-ghc-files-only' targets and all that stuff
11:11:34 <SamB> did someone mention a library for constructing SQL queries in here?
11:11:51 <stepcut> SamB: haskellDB perhaps?
11:11:56 <stepcut> haskelldb.sf.net
11:12:18 <SamB> stepcut: probably
11:12:28 <stepcut> do you just need to construct the SQL query, or do you actually want to talk to the database?
11:13:41 <SamB> actually, somebody in #python was looking for something to construct a query with ;-)
11:13:53 <stepcut> ah...
11:14:42 <stepcut> haskelldb is sweet :)
11:15:05 <stepcut> especially now that it does not require Windows+Obsolete hugs
11:19:59 <SamB> what would be the appropriate way to get something like that in Python? translate, or glue?
11:20:23 <SamB> I don't think distutils supports haskell ;-)
11:24:48 <stepcut> what is Python's type system like?
11:25:23 <SamB> stepcut: dynamic
11:26:31 <stepcut> haskelldb is cool for two reasons:
11:26:55 <stepcut> (1) relation algebra notation and 'do' notation look almost the same
11:27:23 <stepcut> (2) the strong typing, and automatic type inference mean you can be sure you queries are type-safe
11:29:02 <stepcut> and, to expand on (1), writing database queries is no different than writing normal haskell code -- you only have to know one language (haskell), instead of two (haskell + SQL)
11:29:26 <stepcut> somehow, I don't that would translate well to python...
11:30:48 <SamB> well, I'm sure haskellDB will at least give the guy in #python some ideas...
11:32:20 <stepcut> yeah, like switching to haskell ;)
11:33:45 <stepcut> but, if they are interested in it, they should read the paper: http://www.haskell.org/haskellDB/doc.html
11:34:31 <jasonw> I used latex from that package and the article document class.
11:34:31 <stepcut> hrm, the links are dead on that page :)
11:34:36 <jasonw> gah, ww, sorry guys.
11:35:08 <stepcut> http://www.cs.uu.nl/~daan/download/papers/dsec.ps
11:35:36 <stepcut> mmm, latex
11:36:03 <bring> stepcut: thanks for the haskelldb patch
11:37:49 <stepcut> bring: no problem!
11:38:14 <stepcut> I need it since my web host isn't likely to start using MySQL 4.1 before its released ;)
11:38:21 <bring> :)
11:39:15 <bring> I found one problem with haskelldb/SQLite, SQLites untypedness makes haskelldb's typing somewhat less useful
11:39:32 <stepcut> hrm, I have not actually tried to use it much yet
11:39:56 <stepcut> I did a "select * from table1" basically, and that was it
11:40:49 <stepcut> what do you mean by untypedness?
11:40:52 <bring> it seems to work fine, the only problem is that HSQl reports (rightly) that all columns have type String
11:41:01 <bring> SQLite does not have column types
11:41:04 <stepcut> ah
11:41:12 <stepcut> I did not know that 
11:41:23 <bring> http://www.hwaci.com/sw/sqlite/datatypes.html
11:41:36 <bring> they claim that it's a feature
11:41:49 <SamB> bring: I thought you could set them, but it didn't really mean anything...
11:42:00 <SamB> except for sorting and equality
11:42:29 <bring> SamB: yes, sort of, CREATE TABLE accepts all normal types, but they have no effect on the table being created, as far as I understand
11:43:33 <bring> you're right on the ordering and equality, but that depends on the type of data it finds in the column, not the declared type of the field
11:45:42 <SamB> bring: I thought it remembered the types from CREATE TABLE and used that in comparisons?
11:46:21 <bring> as a haskell programmer, I would have expected it to, but the link above says otherwise
11:47:01 <bring> it does remember the CREATE TABLE statement, and you can ask for it, but it doesn't seem to use the type info at all
11:47:32 <bring> guess we could parse the CREATE TABLE to find out the column type
11:47:41 <bring> but it seems like a bit of a hack
11:48:05 * stepcut kicks SQLite in the nads
11:48:07 <bring> probably better than pretending that it's all strings anyway
11:48:52 <bring> go stepcut
11:49:27 <bring> guess you're not talking about mo-nads
11:50:32 <stepcut> I wonder how someone comes to the conclusion that strong-typing is a misfeature
11:50:53 <basti_> hi
11:50:58 <bring> ask any lisp programmer
11:51:06 <bring> hi basti_
11:51:50 <SamB> stepcut: I think it might be related to pascal?
11:52:19 <bring> SamB: good point
11:52:52 <stepcut> pascal was my first programming language   (aside from a few lines of basic)
11:56:36 <bring> guess we'll have to write an embedded db engine in haskell
11:59:36 <jameson> stepcut: There are lots of popular, statically typed languages with seriously broken type systems. If you perform abduction on that (which, unfortunately, is fairly popular in practice), you arrive at the conclusion that static typing itself must be broken.
12:00:08 <jameson> The same probably applies to strong typing on some level.
12:02:12 <basti_> jameson can you sa
12:02:15 <basti_> urk
12:02:26 <basti_> tell me a keyword to search for about what you're saying?
12:04:38 <jameson> basti_: Hmm... which part of it?
12:05:02 <basti_> the part where static and strong typing must be broken
12:05:14 <basti_> i mean is there some kind of document about it?
12:05:26 <jameson> No.
12:05:41 <jameson> As I said, you arrive at that conclusion if you perform abduction...
12:05:49 <jameson> ...which is unsound by definition.
12:05:54 <basti_> i see
12:07:32 <jameson> A typical example for abduction is "Cats like to hunt mice. Cats are mammals. Therefore, all mammals like to hunt mice."
12:08:10 <jameson> IIRC, Sherlock Holmes did that all the time...
12:08:44 <basti_> ah thats "abduction"
12:08:49 <basti_> didnt know its called like that
12:10:53 <basti_> what happened to citeseer?
12:12:04 <esap> see topic
12:12:45 <basti_> its incomplete
12:12:51 <basti_> maybe my client
12:13:03 <esap> incomplete?
12:13:10 <basti_> "citeseer now @ http://cit'
12:13:20 <np_hard> is there a value x for which isPrefixOf will always return false for isPrefixOf x s ?
12:13:28 <esap> oh. http://citeseer.ist.psu.edu/
12:13:35 <basti_> thanks
12:14:20 <basti_> np_hard: (s ++ s) ? ;)
12:14:43 <np_hard> i was looking for something more fundamental but oh well
12:14:43 <np_hard> :)
12:14:55 <basti_> hrhr
12:28:33 <jlouis> http://citeseer.ist.psu.edu/
12:28:41 <basti_> yep
12:28:42 <jlouis> not at NEC anymore?
12:28:50 <basti_> apperently not
12:40:53 <LittleDa1> Why isn't it possible to use (++connector++) for (\x -> ((x++connector)++)) (connector is in the current scope in both situations)?
12:41:03 <[3N1GM4]> Hi, I just need to know how I would take a list of strings and check that none of them contain more than 2 full stops (.)... How would I go about this?
12:41:40 <basti_> LittleDa1 good question
12:42:00 <basti_> [3N1GM4] how would you check a single string?
12:42:38 <[3N1GM4]> well, loop through it, counting the number of .'s, but I don't know how I'll count them... Oh wait, now I do!!!
12:42:46 <[3N1GM4]> brb, if it dont work...
12:42:56 <basti_> ok
12:44:15 <[3N1GM4]> something like:
12:44:21 <[3N1GM4]> dotCheck :: String -> Int
12:44:21 <[3N1GM4]> dotCheck "" = 0
12:44:21 <[3N1GM4]> dotCheck(x:xs) =
12:44:21 <[3N1GM4]>     if isDigit x == True then 1 + dotCheck xs
12:44:21 <[3N1GM4]>     else dotCheck xs
12:44:25 <[3N1GM4]> for a single string...
12:44:50 <basti_> sounds good
12:45:01 <[3N1GM4]> so, how do I apply to a list of Strings? map?
12:45:09 <LittleDa1> use foldl
12:45:10 <[3N1GM4]> or all? something like that?
12:45:14 <LittleDa1> or foldr
12:45:19 <[3N1GM4]> foldr?
12:45:39 <basti_> yeah i would use these too
12:45:55 <LittleDa1> it reduces a list by going through and applying a function multiple times
12:46:01 <LittleDa1> that's not a very good description
12:46:03 <[3N1GM4]> ok...
12:46:09 <[3N1GM4]> I'm just looking it up...
12:47:38 <[3N1GM4]> Hmmm, now I'm confused.
12:47:42 <basti_> :)
12:47:58 <LittleDa1> don't worry, most people are confused by FP
12:48:54 <[3N1GM4]> I'm gettin better at functional programmin, but this whole foldr/foldl thing is confusin me...
12:49:07 <[3N1GM4]> I'm sure I've used all or map to dot his before...
12:49:14 <[3N1GM4]> *do this before.
12:49:54 <basti_> actually they're simple
12:50:04 <basti_> foldr (+) 1 [2,3,4] gives you 1+2+3+4
12:50:19 <basti_> that is, 1+(2+(3+4))
12:50:43 <LittleDa1> but it differs from foldl in that it's 1+(2+(3+4))) and not (((1+2)+3)+4)
12:50:49 <[3N1GM4]> oh, ok...
12:51:40 <basti_> you just have to stop thinking about things like "+" and "*" the C way ;)
12:52:14 <LittleDa1> or the OO way, for that matter
12:52:17 <[3N1GM4]> yeh, I guess so...
12:52:19 <basti_> yep
12:52:29 <basti_> @type +
12:52:45 <basti_> not @type?
12:53:42 <basti_> [3N1GM4] are you coming closer?
12:55:01 <[3N1GM4]> yes, I'm beginning to see.
12:55:23 <LittleDa1> What do you mean by @type?
12:55:32 <basti_> heres some script in the bot
12:55:34 <Marvin--> @type (+)
12:55:42 <basti_> oh yes brackets
12:55:47 <basti_> would be an idea
12:55:53 <Marvin--> well, it *could* be because the bot ain't here ;)
12:56:01 <basti_> it should give the type of this expression
12:56:02 <basti_> oh
12:56:10 <basti_> yes that might be a cause
12:56:32 <SamB> somebody mentioned a patch for HaskellDB to make it use sqlite?
12:57:45 <SamB> bring and stepcut, I guess
13:01:34 <[3N1GM4]> out of interest, what is wrong with this?  :
13:01:35 <[3N1GM4]> initialCheck :: [Bool] -> Bool
13:01:35 <[3N1GM4]> initialCheck [] = True
13:01:35 <[3N1GM4]> initalCheck(x:xs) =
13:01:35 <[3N1GM4]>     if x == True then initialCheck xs
13:01:35 <[3N1GM4]>     else False
13:02:22 <basti_> maybe a missing "i"?
13:02:23 <Marvin--> it says initialCheck on the first two lines and initalCheck on the trid?
13:02:26 <LittleDa1> What happense when you run it?
13:02:42 <[3N1GM4]> ah, that'll be it then!
13:02:43 <[3N1GM4]> lol
13:03:02 <Marvin--> [3N1GM4]: if I may ask a question, why do you write   if x == True then...   instead of   if x then...?
13:03:03 <[3N1GM4]> that's better.   =p
13:03:19 <stepcut> SamB: it should be in the latest nightly tarball (on haskelldb.sf.net)
13:03:22 <[3N1GM4]> I dunno, it just reads better to me...
13:03:35 <Marvin--> (and why not if (x == True) == True then...  which is also equivalent?)
13:03:42 <jlouis> [3N1GM4]: you know the ''all'' function from the standard prelude?
13:03:51 <[3N1GM4]> yeah...
13:04:13 <jlouis> [3N1GM4]: can you find a way to express your function from above via it?
13:04:17 <LittleDa1> because if you do if x == True, you can tell immediately that you're testing if it's true. That other thing serves no purpose for readibility
13:04:20 <Marvin--> jlouis: you're not thinking of and?
13:04:50 <jlouis> Marvin--: no
13:04:56 <[3N1GM4]> ok...
13:05:03 <basti_> btw [3N1GM4] your task took me 4 lines (without type declaration)
13:05:05 <Marvin--> LittleDa1: sure, but what's wrong with   if x then...? We already know x is boolean
13:05:23 <jlouis> Marvin--: though ''and'' probably does exactly the same as initialcheck
13:05:53 <Marvin--> jlouis: yup
13:05:56 <LittleDa1> Marvin--: For some people, it's more readable, even if we know what it's doing
13:06:09 * Marvin-- must've missed the start of the conversation
13:06:35 <jlouis> Marvin--: I was thinking of all (\x -> x)
13:07:10 <Marvin--> jlouis: heh, all id is another way of writing and :)
13:07:58 <jlouis> Marvin--: I am from the strict world of SML. We do not have and defined in the standard library, though we have List.all ;)
13:08:21 <basti_> back
13:13:40 <LittleDa1> Why does (**) return a float always but (^) follow the same kind of type coersion rules as (+)?
13:14:05 <SamB> LittleDa1: what coersion?
13:14:05 <basti_> maybe because ** tend to get out of hand, numerically?
13:14:42 <LittleDa1> SamB: If you do something like 1+2.3, it will return a float, not an integer
13:14:51 <LittleDa1> basti_: Why do you need ** at all?
13:15:15 <LittleDa1> and what's the difference between ** and ^^?
13:15:24 <basti_> uhm
13:15:36 <basti_> ^ does integers btw
13:16:52 <basti_> oh now i "get" your sentence
13:17:01 <basti_> honestly i don know
13:18:09 <LittleDa1> basti_: If you do 3.4^1 it returns 3.4, not 3 or a type error
13:18:16 <basti_> yes.
13:18:33 <Marvin--> ^ is implemented by repeated multiplication, ** is implemented with exp and log
13:19:54 <basti_> and ^^?
13:21:19 <Marvin--> x ^^ n = if n >= 0 then x^n else recip (x^(negate n))
13:21:45 <basti_> ah.
13:21:52 <Marvin--> ^ only handles nonnegative n
13:22:12 <Marvin--> (obviously, since it uses repeated multiplication)
13:22:33 <basti_> yep
13:22:38 <basti_> hope LittleDa1 got it too
13:23:22 <LittleDa1> Yeah, I just read the standard prelude (I didn't know it had mathematical operators in it)
13:29:07 <basti_> haskell is a big thing.
13:34:52 <LittleDa1> basti_: what does that have to do with anything?
13:35:33 <basti_> uh just a random muttering
13:37:40 <LittleDa1> In the standard prelude, there are a lot of infinitely recursing definitions like x - y = x + (negate y) and then negate x = 0 - x. How does that work out?
13:38:08 <Riastradh> LittleDa1, the standard prelude is an example of how to implement some of the operations.
13:38:28 <Riastradh> It's not The Prelude Implementation that every Haskell implementation must use.
13:39:14 <LittleDa1> So it's really not possible for any haskell implementation to use?
13:39:23 <Riastradh> No.  It's an example.
13:39:34 <Riastradh> Notice all the unfilled bits.
13:40:55 <Marvin--> LittleDa1: you mean in the class declarations?
13:41:24 <Riastradh> (actually, since those are in typeclass definitions, it would work, as long as your Num instance provided (-) or negate)
13:41:28 <Marvin--> LittleDa1: they're default implementations, when you instantiate Num, you only have to define one of (-) and negate, the other will be defined automatically
14:01:29 <LittleDa1> If most loops in Haskell use tree recursion, does that make haskell programs less efficient?
14:02:10 <Riastradh> Efficient by what measure?
14:02:15 <Riastradh> And as compared to what?
14:03:06 <LittleDa1> runs fast, and compared to something like Scheme which uses tail recursion or C which uses iteration
14:04:07 <Riastradh> Whether you use tail recursion or non-tail recursion does not affect _execution_speed_ of a program; tail recursion prevents only excessive and unnecessary _stack_allocation_.
14:04:42 <LittleDa1> if you use too much memory, doesn't that make everything run slower?
14:05:16 <Riastradh> Yes, but if you're allocating that much, then either you have a bug or your input was wicked huge anyways.
14:05:45 <LittleDa1> ok, but isn't it less efficient in terms of memory usage then?
14:05:59 <SamB> I think most loops in haskell use either tail recursion or lazy lists
14:06:16 <Riastradh> Laziness plays a major role here, but I sha'n't get into that right now.
14:06:48 <Riastradh> Suppose you're writing a map function.  Your two options are: write it non-tail-recursively and hog the stack; write it tail-recursively and _heap_-allocate an intermediate list that you reverse in the end.
14:08:02 <SamB> I suspect the normal definition would work best...
14:08:56 <monotonom> print $ take 10 $ map f [1..]
14:09:55 <monotonom> Code generated by an optimizing compiler for that program will not even build any list, let alone using stack or heap.
14:12:24 <LittleDa1> it would have to be a very intelligent compiler, wouldn't it?
14:12:46 <monotonom> I know you will raise that point.
14:12:46 <Riastradh> No.  Simple partial evaluation will optimize it away.
14:13:20 <Marvin--> surely map is both a good consumer and a good producer?
14:13:28 <Riastradh> Partial evaluation will make it be [[print [1,2,3,4,5,6,7,8,9,10]]], and that list will be statically allocated.
14:13:58 <Igloo> I think he means due to laziness, not partial eval
14:14:31 <Riastradh> Igloo, laziness won't be compiler help there; partial evaluation is.
14:14:59 <LittleDa1> I'm probably really ignorant for asking this, but what does the $ do?
14:15:13 <Igloo> Laziness means it'l run in constant heap and constant stack - wasn't that the point?
14:15:15 <Riastradh> f $ x = f x
14:15:25 <LittleDa1> so how does that help?
14:15:32 <Riastradh> ($) is not at issue here.
14:15:37 <monotonom> Consider: 1. Imperative compilers are no less intelligent, just in different aspects (vectorization, data dependency analysis, ...).  2. There are about a thousand people working on imperative code optimization, and fewer than ten on functional code optimization; the result: imperative programs run just maybe two times faster.  The inference is obvious.
14:15:44 <Riastradh> monotonom could have just as well written [[print (take 10 (map f [1..]))]].
14:15:54 <SamB> LittleDa1: $ gets rid of parentheses
14:16:15 <monotonom> Don't forget deforestation.
14:16:18 <Riastradh> $ gets rid of parentheses but not character counts.  It's pretty silly.
14:16:48 <LittleDa1> so it's right-associative or something?
14:17:15 <SamB> Riastradh: it makes it easier to type and read, I think
14:17:23 <Riastradh> It's non-associative.  It binds less tightly than anything else.
14:17:23 <monotonom> $ relieves me of the obligation to remember to enter closing parentheses.  Tail recursion (of my mind) vs. tree recursion, heh.
14:17:26 <SamB> also saves whitespace!
14:17:43 <Igloo> It's right associative
14:17:47 <Riastradh> Bah.
14:17:52 * Riastradh waves his paw at Igloo.
14:18:09 <jlouis> monotonom: strictness analysis is more important than deforestation
14:18:25 <SamB> monotonom: tail recursion of indentation, too
14:18:39 <LittleDa1> what's deforestation (in the context of programming?)
14:19:09 <Riastradh> It's when programmers dress up as lumberjacks, go out singing the lumberjack song, and skip & jump & cut down trees.
14:19:34 <jlouis> LittleDa1: it is an optimization which removes the intermediate generation and tear-down on lists
14:19:40 <jlouis> of lits
14:19:43 <jlouis> bah
14:20:46 <jlouis> consider map f (map g x). it can be rewritten to map (f . g) x removing the intermediate map g x list. Clear?
14:21:34 <LittleDa1> yeah, but what if you define map? How will it know what to do?
14:22:05 <Riastradh> Magic.
14:22:25 <Riastradh> Compilers have eyes in the back of their heads, so they can see what naughty things like that you're doing.
14:22:37 <monotonom> You say these functional code optimizations are difficult and need intelligence.  I have said the following but I will say it again differently: I took a course on imperative code optimization; some of the analyses and transformations are beyond difficult and intelligent --- they are *insane*.
14:22:41 <SamB> LittleDa1: it won't do anything to any map it might let you define... because the RULE pragmas are attached to a particular symbol.
14:22:43 <Igloo> You can tell GHC rules to optimise such things with pragmas
14:24:29 <jlouis> well, looking at what MLton did, there is not long from the backend to traditional imperative compilers
14:24:55 <jlouis> so every optimization done on imperative code can be done on functional code 
14:25:01 <jlouis> modulo transformations
14:25:20 <Riastradh> (the CPS<->SSA equivalence is very convenient here)
14:26:04 <jlouis> Riastradh: exactly
14:26:07 <mattam> SSA ?
14:26:12 <Riastradh> Single Static Assignment.
14:26:37 <Riastradh> It's an intermediate format used in many compilers of imperative languages where variables are assigned once and only once.
14:26:41 <jlouis> transform the code such that an assignment is in a single static place in the code
14:26:47 <SamB> look at the GHC.Base source to see some of the rules for map
14:27:01 <jlouis> Riastradh: statically once. If you have a loop it is reassigned
14:27:15 <jlouis> but you know that
14:27:24 <mattam> i see, i coded an algorithm that did that some day in fact ;)
14:27:30 <Riastradh> Kelsey pointed out that CPS and SSA are pretty much equivalent, so any optimizations you can perform on one you can perform on the other, really, which is a big win for many optimizations that wouldn't otherwise be applicable to both functional and imperative code.
14:27:34 <Riastradh> jlouis, er, yeah.
14:27:43 <SamB> Riastradh: wouldn't SSA make the intermediate representation functional?
14:28:06 <mattam> interesting
14:28:08 <Riastradh> SamB, SSA says nothing about anonymous closures.
14:28:10 <jlouis> SamB: there is a bijection between ssa and a similiar functional program
14:28:25 <SamB> Riastradh: oh.
14:28:33 <SamB> jlouis: a bijection?
14:29:05 <jlouis> SamB: yes, if you screw enough things. Closures is one of them ;)
14:29:20 <jlouis> they are equivalent
14:29:27 <jlouis> is a better wording
14:29:47 <Riastradh> SamB, http://mathworld.wolfram.com/Bijection.html
14:30:14 <jlouis> mattam: the hard part of ssa-form is what happens when control flow merges
14:30:33 <jlouis> and it is not even that hard
14:30:37 <mattam> merges ?
14:31:34 <SamB> mattam: after if {...} else {...}
14:31:35 <jlouis> if b then x else y; c. Depending on b, the control splits in x and y and then merges again to execute c
14:32:13 <mattam> ok
14:32:21 <jlouis> anyway, if it interests you you should read a book which is better than explaining it than me
14:33:44 <mattam> i did something similar in a soft. eng. course, but it was not that tricky (a fixpoint computation was all that was needed iirc).
14:36:02 <jlouis> you can do it by fixpoint comp. yes
14:36:08 <jlouis> it can get expensive though
14:38:45 <mattam> Is there a known better solution for this particular problem ? 
14:45:35 <jlouis> calculating the dominator tree? 
14:46:32 <mattam> ohoh, what's a dominator tree ?
14:54:17 * mattam found something on the resurected citeseer
14:54:36 <jlouis> it tells which vertexes in the control flow graph is dominated by which.
14:55:05 <jlouis> there is an algorithm, lengaur-tarjan, for computation of the dominator tree quickly
14:56:20 <mattam> the domination is in terms of cardinal of new variables used ?
14:56:51 <jlouis> no.
14:57:45 <jlouis> build the control flow graph of the code. A vertex V is said to be dominated by another vertex D if every path to V goes through D
14:57:55 <jlouis> IIRC
14:58:59 <mattam> k
14:59:59 <jlouis> it is clear this gives a partial order between vertices V and D, which in turn is the dominator tree (again IIRC)
15:20:16 <LittleDa1> In Haskell, what is the difference between classes and instances (it looks completely different than with normal OO languages)? They're both types, aren't they?
15:21:40 <jlouis> A class is a specification. An instance is an implementation which states that the type Foo can be regarded as something of class Bar
15:23:16 <jlouis> they are not types. They are subsets of types
15:23:47 <Jerub> and they're very different to class foo { } and a = new foo();
15:24:51 <jlouis> the name type class reveals more to the fact that it is indeed a subset of types
15:25:53 <jlouis> the class Eq is the subset of types who admit equality checking (==). If we have (==) we also have non-equality (/=) (if i remembeber the haskell operator correctly), because it is the negation of (==)
15:26:56 <jlouis> so, we can take a type and make it an instance of class Eq, which means that we provide code on how to check the type for equality. From there on it can be as regarded in the subset of types who admits equality (Eq)
15:28:07 <jlouis> just ask if something is not clear
15:31:32 <Jerub> makes for much more versitile polymorphism than say, java inheriting arbitary classes and implementing the methods.
17:18:10 <LittleDan> Are there any Haskell REPLs that just take normal Haskell code as if it were in a file?
17:18:53 <Jerub> LittleDan: do you mean 'like hugs, but with the ability to define things'?
17:19:33 <LittleDan> yes
17:19:37 <LittleDan> or like GHCi
17:19:53 <Jerub> haven't seen one.
17:20:06 <Jerub> I generally do tight cycles using :e in hugs.
17:20:32 <LittleDan> Is it possible to create one or would it violate some principle like referential transparency?
17:21:54 <SamB> Why don't you just use a file?
17:22:28 <LittleDan> it's just annoying. I could if it's not possible to do that.
17:22:55 <SamB> or you could use ghci, which lets you use something like monadic lets at the top level...
17:23:03 <stepcut> LittleDan: I usually just run ghci under emacs
17:24:07 <stepcut> LittleDan: I edit in a temp file and then hit, C-c C-l to load the buffer into ghci
17:25:12 <stepcut> if you just want to define some functions in ghci you can do: let f x = x + 1
17:25:42 <stepcut> but I don't think you can define new datatypes or class instances
17:28:36 <stepcut> http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&safe=off&threadm=slrn9pn1oi.c27.qrczak%40qrnik.zagroda&rnum=1&prev=/groups%3Fq%3Dghci%2Btoplevel%2Bdefine%26hl%3Den%26lr%3D%26ie%3DUTF-8%26safe%3Doff%26selm%3Dslrn9pn1oi.c27.qrczak%2540qrnik.zagroda%26rnum%3D1
17:29:16 <stepcut> that is a thread that discusses some of the reasons why it might be hard to make ghci except everthing interactively
19:51:27 <Etaoin> meow
20:19:39 <Pseudonym> OMG, it's the meow army invading #haskell!
20:20:48 * Pseudonym is a Usenet Old Fart(tm)
20:24:00 <ayrnieu> Xah Lee has something for the non-Old Farts =)
20:24:00 <Cale> meow
20:40:29 <Jerub> sigh.
