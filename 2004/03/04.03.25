00:15:39 * Cale is away: sleep
00:22:01 <skew> Yay, I've packaged Haskell as a standalone Python extension!
00:22:50 <skew> I need to figure out how to do it without half a page of linker options copied from ghc -v
00:33:56 <earthy> you've done *what*?
00:35:45 <skew> I've taken some Haskell functions and liked them into something the Python interpreter likes
00:35:57 <earthy> *ah*. :)
00:36:25 <earthy> I read that as `I've built en `eval_haskell' out of ghci and linked it to python'
00:37:10 <earthy> which is orders of magnitude scarier. :)
00:38:11 <skew> I think the hardest part of that would be figuring out how to call ghci...
00:38:17 * earthy nods
00:38:39 <earthy> what I gather that is nontrivial
00:38:58 <earthy> but, methinks shapr will be *more* than interested in this stuff
00:40:34 <skew> do you know of any dynamic loading thing for Haskell that handles types?
00:42:21 <skew> ideally the Python side of things would be able to load any Haskell module
00:46:20 <earthy> umm, no, I don't, in fact.
00:50:45 <Si\> skew: you mean compiled modules?
00:55:42 <skew> yep
00:56:17 <skew> Now you can use the power of Haskell to add a pair of small integers!
00:57:05 <skew> and maybe more someday
00:58:32 <skew> I've got a tiny bit of support on the Haskell side to take functions (in IO) that work on pointers to Python objects, and add them as a module
00:59:30 <skew> use that, foreign export a function that actually adds my Haskell function (+) as a module
01:00:14 <skew> write a little bit of C that's the entry point Python finds, to start the runtime and then call the other
01:00:43 <skew> mix in the linker options from ghc -v, and you're off
01:01:25 <skew> do you think using Python libraries from Haskell, or extending Python programs with Haskell code is more useful?
01:02:52 <Si\> have you looked at how to interogate .hi files?
01:03:21 <skew> no
01:03:52 <skew> have you done much with that?
01:03:56 <Si\> I wish
01:04:11 <Si\> haven't had time yet
01:04:36 <skew> I think that would probably be involved if I wanted to write an import hook or something for Python that would let you load any module
01:04:40 <Si\> but I probably will sooner or later
01:04:48 <skew> I don't know how you would handle polymorphism though
01:05:05 <Si\> that could be really, really difficult
01:05:08 <Si\> if possible
01:05:08 <skew> well, deriving instance dictionaries in particular
01:05:31 <skew> parametric polymorphism would just be a matter of implementing unification
01:06:15 <skew> Hmm, you would need to know where to look for other modules one depends on
01:06:52 <skew> I think the best hope is to get the ghc codebase exposed as libraries
01:07:13 <skew> and just use the actuall compiler code for everything
01:07:19 <Si\> I mean something like SOAP/1.1 doesn't have any form of polymorphism, but I haven't looked at SOAP 1.2, I assume python has polymorphism
01:07:59 <skew> well, I'm just thinking about passing Haskell values around as opaque objects in Python code
01:08:20 <Si\> oic
01:08:39 <skew> so I'm worrying about deciding from the .hi file whether you can call some function with a particular opaque chunk of Haskell value you happen to have
01:09:51 <Si\> yes, could be quite a major project
01:09:55 <skew> do types have any sort of globally unique name in GHC?
01:10:10 <skew> I supose package+module+name
01:10:13 <Si\> you mean within some sort of unique namespace
01:10:28 <skew> I think they do
01:10:37 <skew> at least, somewhere inside the compiler they do
01:10:39 <Si\> that's something I've grappled with, I've settled for module+name for the time being
01:11:21 <skew> If I'm remembering correctly, GHC usues pakcage+module+name
01:11:37 <Si\> Well actually I just call them all Haskell.moduletree.module.function
01:12:06 <skew> I think I'll just make it nice to expose Haskell functions for the moment
01:13:20 <Si\> GHC probably does using package+module+name, but not everything is part of a package
01:21:05 <skew> I won't be able to handle inter-language cyclic garbage ;(
03:06:08 <shurik> could someoe paste few lines of code taht shows how to use nested guards?
03:07:05 <shurik> function arg = | boolean = function wherere function = et  ?
03:07:11 <shurik> or 
03:08:02 <shurik> and also
03:08:43 <shurik> I d like to know how to keep the value of index as you go through the lis
03:08:56 <shurik> I need touse this value later to pull the strings out of the set
03:09:09 <jlouis> value of index?
03:10:19 <shurik> for example, [1,23,5] index of 23 is 1
03:10:50 <shurik> so akward
03:12:34 <Jerub> shurik: you use a helper function.
03:12:35 <ski> you could use an accumulator
03:12:40 <Jerub> and an accumulator.
03:12:49 <Jerub> i.e.
03:12:49 <ski> or zip the list with [0..]
03:12:54 <Jerub> f = f' 0
03:13:14 <Jerub> f' n (x:xs) = f' (n+1) xs
03:13:35 <Jerub> or, of course, zip the list with [0..]
03:13:40 <shurik> wait a minute
03:15:01 <shurik> I need to write a function that takes a list and a value and return its index
03:15:04 <shurik> wicked:>
03:16:56 <ski> that would be even easier
03:17:04 <ski> no acc or zip needed
03:17:29 <Jerub> f e xs = snd $ head $ dropWhile (\(x,_) -> e /= x) $ zip xs [0..]
03:17:39 <ski> (though it might maybe be more efficient with acc or zip)
03:18:16 <ski> shurik : should i show my solution ?
03:18:27 <Jerub> ski: I'd love to see it ;)
03:18:29 <kosmikus> elemIndex ?
03:18:29 <shurik> go ahead
03:18:37 <Jerub> kosmikus: ssshh ;)
03:18:49 <shurik> I was joping to find something in prelude, since you use this feature all the time
03:18:55 * Jerub is having fun actually writing functions in haskell again.
03:18:57 <Jerub> its been a long time.
03:18:57 <ski> f e (x:xs)
03:19:06 <ski>   | e == x = 0
03:19:17 <ski>   | True   = 1 + f e xs
03:19:48 <ski> shurik : it's in module List, IIRC
03:20:08 <kosmikus> as I said, elemIndex, only it returns a Maybe
03:20:13 <ski> yeah
03:20:43 <earthy> but, kosmikus, that's Useful Information
03:20:48 <ski> shurik : see how this works ?
03:20:57 <earthy> that doesn't help shurik learn. :)
03:21:39 <kosmikus> one possible definition was posted before I first said it
03:23:18 * earthy nods
03:24:00 <earthy> searching through the libs is a learned skill as well, however
03:25:28 <Jerub> earthy: one that is taught far too late often too.
03:25:30 * Jerub goes to bed.
03:26:57 * earthy nods
03:27:06 <earthy> g'night jerub
03:40:15 <shurik> could someone help me with something else?
03:41:45 <shurik> I need function that takes an integer say 23409859 and produces [[2,3,4,0],[9,8,5,9]]
03:41:58 <shurik> give out a list of lists of sets of 4 digits
03:43:34 <earthy> fours :: [a] -> [[a]]
03:43:34 <earthy> fours xs = (take 4 xs) ++ fours (drop 4 xs)
03:43:55 <earthy> you can do the split yourself. :)
03:44:03 <earthy> (split into digits)
03:44:06 <shurik> cool
03:44:32 <mattam> `show i` is enough
03:44:38 <shurik> actually what split?
03:44:54 <earthy> mattam: is it? doesn't that turn the digits into characters?
03:44:54 <shurik> I said an Integer , not [Integer]
03:45:02 <saz> is this another first year assignment?
03:45:36 <earthy> shurik: I know. you'd have to take the Integer to a [Integer] yourself, by splitting into digits.
03:45:50 <mattam> earthy: the conversion is probably more efficient than the modulus, or maybe not :)
03:46:11 <shurik> modulo would saffice
03:46:23 <earthy> shurik: so, write it out for all to see. ;)
03:48:03 <shurik> wait
03:48:17 <seafood_> what do you want to use it for?
03:48:39 <ski> earthy : that code doesn't work correctly :)
03:48:48 <earthy> ski: I bet it doesn't. ;)
03:48:57 <ski> Prelude> let fours xs = (take 4 xs) ++ fours (drop 4 xs)
03:48:57 <ski> Prelude> fours [0..9]
03:48:57 <ski> [0,1,2,3,4,5,6,7,8,9^CInterrupted.
03:48:57 <ski> Prelude>
03:49:11 * earthy nods
03:49:15 <earthy> s/++/:/
03:49:43 <seafood_> base case might be nice too.
03:49:47 <shurik> stack a b = revers (substack a b)  where ubstack x y = | x == 0 = [] | otherwise (mod x y) : (substck (div x y) y)
03:49:50 <shurik> there
03:50:06 <earthy> wow, 2 different typos!
03:50:09 <shurik> where b could be set to10K
03:50:23 <ski> earthy : yeah, i was thinking of the base case ..
03:50:24 <shurik> I let you to correct the typs\
03:50:28 <shurik> :)
03:50:45 <earthy> seafood_: ghe. ;)
03:51:12 <seafood_> ghe?
03:51:45 <earthy> a. my code isn't necessarily correct. b. shurik is supposed to still be using his mind, and not mindlessly copying
03:52:05 <seafood_> earthy: Thanks. 
03:52:18 <shurik> copying what?
03:52:20 <seafood_> shurik won't answer my question about whether he's from UNSW
03:52:23 <earthy> and you *are* helping. ;)
03:52:39 <earthy> (`base case? what base case?')
03:52:45 <seafood_> earthy: I just wanted to know what "ghe" meant.
03:53:25 <shurik> seafood_ why do you care where I am from and what I am writing? I am writing a program that will rip all the bytes out of another program and shove it up its author's ass
03:54:17 <seafood_> shurik: Hostility :)
03:54:20 <mattam> hmm, unfold is not in the standard prelude ?
03:54:25 <mattam> @type unfold
03:54:26 <shurik> yep
03:54:36 <shurik> towards pesy irc user
03:54:38 <ski> mattam : in List IIRC
03:54:48 <mattam> ok
03:55:04 <seafood_> shurik: well, if the answer had been no then I think you would have just told me that.
03:55:17 <shurik> get away man
03:57:28 <mattam> how does one import a module in ghci ?
03:58:09 <earthy> :load ?
03:58:10 <saz> you mean load one you wrote?
03:59:38 <mattam> no, i want to import the unfoldr function from List
04:00:52 <mattam> nm
04:01:58 <ski> Prelude> :t List.unfoldr
04:01:58 <ski> List.unfoldr :: forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:01:58 <ski> Prelude> :m List
04:01:58 <ski> Prelude List> :t unfoldr
04:01:58 <ski> unfoldr :: forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:01:59 <ski> Prelude List>
04:02:50 <ski> or possibly ":m +List" is better
04:03:18 <ski> mattam : ok ?
04:04:35 <mattam> yeah is found the prefixed syntax
04:09:47 * shapr boings
04:13:11 <earthy> ?
04:13:46 <whee> I really hate having to use C++ at work. this stupid thing gets too complicated because of the limited type system :P
04:15:02 <ozone> quick q: does anyone know if a generational GC is required to move objects around the address space?
04:15:15 <earthy> yes. no.
04:15:32 <ozone> that's what i thought
04:15:55 <earthy> see e.g. compacting gc's
04:16:42 <ozone> earthy: hate to ask this, but can you provide any links to what a compacting gc is?
04:17:57 <ozone> actually, never mind, i'll just use google :)
04:18:06 <earthy> http://www.iecc.com/gclist/GC-faq.html
04:18:22 <earthy> (I knew what to google for, but it took a few clicks ;))
04:18:24 <ozone> thanks :)
04:21:51 <shapr> @type unfold
04:21:56 <shapr> @type foldr1
04:21:57 <lambdabot> foldr1 :: (a -> a -> a) -> [a] -> a
04:22:21 <shapr> I attended orau.gov for a coupla years.
04:22:58 <ozone> sup shapr
04:23:03 <shapr> g'day ozone 
04:23:08 <shapr> I'm just chillin in the hood
04:23:28 <shapr> that translates to "It's freezing here, boy I'm glad I have a warm hood over my head"
04:24:29 <earthy> shapr: read about what skew's been doin'?
04:24:35 <shapr> yah, looks awesome
04:24:44 <earthy> thought you might like it ;)
04:24:46 <ozone> hmm, 24 deg C over here right now
04:24:49 * ozone rolls around
04:24:53 <ozone> ahh, so comfortable.
04:25:49 <earthy> it was 2 deg C this morning
04:26:20 <shapr> I can see the snow falling.
04:26:34 <shapr> which means it's relatively warm.
04:26:39 <earthy> yes... well...
04:27:08 <earthy> we have seen 20 deg C during the day already...
04:27:14 <earthy> it's some 10 now, probably
04:27:29 <shapr> I wish that would happen here, it'd get rid of the mountains in every parking lot.
04:27:36 <shapr> er "mountains of snow"
04:27:51 <shapr> one thing I like about Sweden, the kommun cleans out the snow mountains on a regular basis
04:27:54 <shapr> I just wonder where they all go
04:28:04 <shapr> maybe they make a profit shipping them to the ski slopes
04:28:36 <shapr> of course, the snow continues to fall, so the mountains return.
04:28:50 * shapr tries to think of a way to power his computer with snow
04:29:49 <Igloo> Easy with falling snow. With fallen snow it's somewhat harder
04:30:45 <earthy> `easy'? not much kinetic energy even in falling snow
04:30:48 <ozone> having mountains in parking lots would suck
04:30:56 <ozone> wouldn't be able to park your car anywhere, i tell ya
04:31:14 <shapr> I have a unicycle, it's much easier to park.
04:31:15 <Igloo> Sure, but there is some, so all you need is enough paddled wheels for it to fall on
04:31:34 <saz> kommun?
04:32:11 <shapr> um, city government
04:32:45 <earthy> igloo: and make them have little friction and generally keep the energy losses *way* down
04:33:12 <Igloo> Sure, but it's conceptually simple  :-)
04:33:41 * earthy laughs
04:33:47 <Igloo> In fact, buckets would be more sensible than paddles. And you could even stack them
04:35:48 <ski> (kommun = municipality, i think)
04:35:54 <shapr> yes
04:36:07 <shapr> I didn't actually realize that's not english
04:36:16 <shapr> that's both cool and scary :-)
04:36:17 <saz> sounds like common in english
04:36:43 <shapr> spoken it's like koh-myun
04:36:50 <shapr> or koh-myoon
04:37:01 <saz> like, commune?
04:37:54 <shapr> exactly
04:39:17 <shapr> saz: you speak persian?
04:43:52 * shapr boings
04:45:44 <shapr> saz: what's lilith doing these days?
04:45:48 <shapr> haven't seen her around much
04:48:23 * saz does speak persian (and in persian, commune means truck ;) )
04:48:31 <saz> she's still around uni
04:49:16 * ski 's off for now
04:49:25 <shapr> bye ski
04:49:28 <ski> bye
04:49:36 <shapr> I haven't been to unsw, maybe someday
04:50:10 <shapr> blackdog offered to let me sleep in his spare room for a few days if I want to visit :-)
04:50:19 <saz> who's blackdog?
04:50:27 <shapr> mrak wotton
04:50:30 <saz> ah
04:50:45 <saz> i'd never encountered him on irc
04:50:50 <shapr> I'm sure you know who seafood is :-)
04:50:56 <shapr> everybody loves seafood
04:51:30 <saz> sure do :-) *waves towards seafood*
04:51:44 <shapr> saz: did you choose your own hostname? does foad mean the same thing there as it does on irc?
04:52:15 <saz> it's the name of a box in the compsoc office, and no I didn't choose it, and yes, it probably means what you think it means
04:52:23 <shapr> ok, just checking
04:54:04 <seafood_> shapr, saz: Aw shucks.
04:54:22 <seafood_> shapr: You're thinking about visiting! Cool!
04:56:30 <ozone> sup seafood, sup sazza
04:57:36 <shapr> yow!
04:57:57 <saz> hey ozone! how goes?
04:58:04 <shapr> seafood: yah, I'd love to drop by, though I dunno how likely it is.
04:58:45 <shapr> I think it's more likely to happen when it's dark and cold here in Sweden, since it'll be warm and light in .au
04:59:08 <shapr> when are you lot coming back to the northern hemisphere?
04:59:17 <saz> isn't it dark and cold in sweden now?
04:59:19 <shapr> any plans for icfp 04?
04:59:27 <ozone> saz: all good, going to see tokyo shock boys tomorrow, which will totally rule
04:59:29 <shapr> nah, it's sort of light and sort of warm
05:00:16 <shapr> three years back it hit -45° C in the next town over, so 0° C is sort of warm :-)
05:00:19 <ozone> shapr: i'll be in the USA once or twice this year, probably, but not at ICFP'04 unless i can find a relevant conference for work which coincides with its dates
05:01:06 <shapr> I vaguely recall that you're doing multimedia stuff, is that right?
05:01:11 <ozone> saz: har, see my ashish email?  teehee
05:01:21 <ozone> shapr: indeedeleedo, neighbour!
05:01:31 <shapr> do you get to write Haskell at work?
05:01:43 <ozone> nay
05:01:55 <shapr> too bad
05:01:56 <ozone> although i should get off my arse some time and write haskell bindings for our libraries
05:02:26 <shapr> you guys make OSS libs?
05:02:28 <shapr> hei Hipo 
05:02:52 <ozone> shapr: ja, http://www.annodex.net/software/index.html
05:02:54 <Hipo> Moi.
05:03:42 <shapr> oh that would be handy
05:03:58 <shapr> hey, do you know of any decent OSS speech recognition engines?
05:04:18 <ozone> no, although my boss and workmate undoubtedly would
05:04:20 <shapr> I've only found sphinx2
05:04:27 <ozone> if you're really interested, i can give you their emails
05:04:36 <shapr> I would like that
05:04:56 <shapr> what's cmml, related to smil?
05:05:05 * shapr tries reading the website
05:05:18 <shapr> continuous media
05:05:18 <ozone> the all-singing, all-dancing Continuous Media Markup Language
05:05:27 <shapr> neat
05:05:33 <shapr> so it is similiar to smil
05:05:49 <ozone> shapr: see http://www.annodex.net/differentiators.html
05:05:59 <ozone> so it's similar to SMIL, but we don't suck
05:06:08 <ozone> or rather, we're actually useful
05:06:17 <shapr> ah
05:06:20 <shapr> heh
05:07:45 <shapr> that's quite spiffy
05:08:15 <shapr> I think you have a typo on the diagrams page, &ltimport should probably be <import
05:09:20 <shapr> I would like to see a Haskell binding for liboggz
05:09:33 <shapr> especially if it can deal with ogg-wrapped flac
05:10:09 <ozone> i'm not sure if it can yet
05:10:23 <ozone> if it can't, it won't be very hard to add in flac support
05:11:38 <shapr> so where do I get a CMML/Annodex browser or plugin?
05:12:23 <ozone> i'm hoping to release the CMML patches for videolan tomorrow 
05:13:07 <shapr> so I'll be able to patch the vlc debs and view Annodex?
05:13:42 <ozone> yeah, should hopefully be integrated by the time they release 0.7.2
05:14:56 <shapr> cool, I look forward to it.
06:28:12 * shapr boings
06:34:52 <shapr> what's going on in the world of Haskell?
06:35:05 <earthy> I was planning on figuring that out next month. :)
06:36:38 <shapr> you need any help?
06:58:35 <shapr> oh this is neat: http://www.vector.org.uk/?fetch=v203/vonthun203.htm
06:58:38 <shapr> Joy is a fun language.
07:28:18 * Igloo drowns in a sea of partial orders
07:29:39 <Marvin--> need a lifeline?
07:31:39 <shapr> or maybe he's just getting orders without payment?
07:32:05 <Igloo> :-)
07:32:25 <Igloo> I think I've got it now, anyway
07:42:37 <Marvin--> gr
07:45:45 <Marvin--> heh, the cover project seems to have split up in two subprojects
07:45:54 <earthy> sea of partial orders? as in cpo? >:P
07:47:42 <earthy> oh well, time to go home
07:48:03 <Igloo> Oh dear  :-)
07:48:18 <Marvin--> oh dear what?
07:48:36 * earthy is punning with semantics
07:49:01 <Marvin--> oh
07:49:03 <Marvin--> duh
07:49:17 <Marvin--> actually, you should be shot with a hammer for that pun
07:49:42 <earthy> good reason for me to going home. ;)
07:49:49 <earthy> +be
07:49:55 <Marvin--> (and I'm not just saying that because I didn't get it at first! ;)
07:58:30 * Marvin-- ponders patching System.Console.GetOpt
08:01:13 <kosmikus> Marvin--: for what?
08:01:30 <Marvin--> kosmikus: to make it play nice with newlines in option descriptions
08:01:44 <kosmikus> ah
08:02:04 <Marvin--> I have some really long flag names and fairly long descriptions of them
08:02:08 <kosmikus> that'd be good
08:02:12 <Marvin--> kinda tricky to make it fit in 80 characters
08:03:50 * Marvin-- checks out cvs
08:04:03 <Marvin--> . . . .
08:05:06 <mattam> shapr: have you read this : http://www.vector.org.uk/cgi-bin/index.php?area=j&page=front ? the code red is very funny
08:07:18 <kosmikus> Marvin--: btw, you were trying to make a .deb out of lhs2TeX a while ago, and ran into some problems -- I've put a new version on the homepage, which should hopefully fix them. It's not officially released yet ...
08:07:46 <Marvin--> kosmikus: cool, I'll try to have a look tonight
08:08:02 <kosmikus> ok
08:08:05 <mattam> kosmikus: i'm very interested!
08:08:29 <kosmikus> the -1.9 is in Gentoo ...
08:08:40 <mattam> nice
08:09:15 <kosmikus> I thought you were mainly an O'Caml programmer?
08:12:02 <mattam> well, that doesn't stop me from loving haskell and doing fun stuff whith it!
08:12:40 <kosmikus> no, of course not
08:13:05 <kosmikus> actually, I would be interested in making lhs2TeX fit for ML-like languages, too
08:13:24 <kosmikus> but that's another thing that'll have to wait until after my thesis deadline ...
08:14:12 <mattam> i've coded a Relational Algebra <-> First Order Formula translator for uni, and used the lhs stuff but couldn't find any way to translate it to tex. You're kind of saving me!
08:14:55 <kosmikus> well, the program exists for a long time already
08:15:04 <Marvin--> Igloo's written such a program too
08:15:11 <kosmikus> right
08:15:35 <kosmikus> and there's at least one other: lambdaTeX or so ...
08:16:00 <mattam> what's the name of yours in portage ?
08:16:09 <kosmikus> dev-haskell/lhs2tex
08:17:27 * mattam wait for his cvs up to finish
08:17:58 <kosmikus> if you don't update the entire tree, you must also update dev-tex, because it depends on new packages there ...
08:18:31 <mattam> i noticed :)
08:19:29 <Marvin--> cool, this was simpler than I expected
08:19:36 <Marvin--> and oooh yeah, it looks good
08:20:07 <kosmikus> do you send the patch to the ghc people?
08:20:20 <Marvin--> going to mail it to libraries@h.o
08:20:24 <kosmikus> ok
08:33:21 * Marvin-- just had a great idea
08:33:32 <Marvin--> more coffee!
08:35:35 <kosmikus> that is indeed a great idea ...
08:37:16 <Igloo> lhs2tex is probably better than mine, at least until either I get some more serious TeX-fu or someone who has some takes it on
08:38:17 <kosmikus> Igloo: do you think there's anything in you program that should go into lhs2tex?
08:39:54 <Marvin--> what annoys me is I'll have to start over from scratch with the packaging since I had the files on another computer, which is right now...well, dead :)
08:40:03 <kosmikus> ah
08:40:54 <Marvin--> mind you, it might not be a bad idea, seeing as I had problems last time
08:41:17 <kosmikus> I could probably give you CVS write access, so that this does not happen again ...
08:41:39 <mattam> kosmikus: USE="doc" -> access violation
08:41:56 <kosmikus> huh?
08:42:06 <kosmikus> I've never built it without, and it always succeeded ...
08:42:16 <mattam> it still builds Guide2.pdf though (with "-doc")
08:42:25 <kosmikus> it doesn't build it
08:42:34 <kosmikus> it takes it from the distribution :)
08:42:43 <mattam> ok
08:42:52 <kosmikus> that's the only difference
08:43:08 <kosmikus> but the manual is a good test if the installation works
08:43:09 <mattam> problem is that it uses latex, so when it tries to generate fonts it access /var...
08:43:19 <kosmikus> that's a latex problem, not mine
08:43:27 <kosmikus> I thought that was fixed long ago
08:43:33 <kosmikus> which version of tetex do you use?
08:43:53 <mattam> 2.0.2-r3
08:44:05 <kosmikus> hmmm
08:44:42 <kosmikus> can you open a bug on that, assign it to me (kosmikus), and cc text-markup ?
08:45:59 <mattam> probably, i would like to find lhs2tex-1.9.tar.bz2 in my distfiles first though!
08:46:27 <kosmikus> ??
08:46:27 * shapr does the happy unicycle dance (which usually involves falling down)
08:46:47 <mattam> damn bash completion, i started with 'tar zxf ' so ...
08:47:02 <kosmikus> I never understood what people find about bash completion
08:47:12 <kosmikus> in 99% of the cases it does *not* what you want
08:47:54 <mattam> it is the first time it does not what i want, so ... :)
08:48:08 <mattam> actually that's entirely my fault
08:48:32 <kosmikus> what is your fault?
08:48:56 <mattam> typed 'x' instead of 'j'
08:48:58 * ski smiles
08:49:02 <shapr> mattam: Code Red is very funny
08:49:10 <shapr> I still have a deluxe slide rule around here somewhere
08:49:17 <kosmikus> oh yes, I thought you meant something relating to the ebuild ...
08:49:23 <shapr> I saved it from the dumpster when my high school bought some computers
08:49:31 <mattam> al-Gebra will rule the world
08:49:49 <shapr> truly!
08:50:06 <ski> al-Gebra ?
08:51:07 <mattam>  http://www.vector.org.uk/cgi-bin/index.php?area=j&page=front
08:51:30 <Marvin--> hm
08:51:40 <Marvin--> kosmikus: why did $(polydir) default to /usr/local?
08:53:01 <shapr> I was quite impressed with the idea behind the slide rule
08:53:10 <shapr> imo, golomb rules are the same sort of thing
08:54:07 <ski> what's a golomb rule ?
08:54:09 <ski> :)
08:54:20 <Igloo> kos: Nah, they're just different from what I remember. One thing, though, ISTR lhs2tex used fonts I don't like, but I may be confused it with another one
08:54:56 <shapr> golomb - http://www.distributed.net/ogr/
08:55:00 <kosmikus> I think it defaults to /usr/local for much the same reason that prefix defaults to /usr/local
08:55:13 <kosmikus> you should manually reset it via --with-texmf=DIR
08:55:21 <kosmikus> Marvin--: ^^
08:55:47 <kosmikus> Igloo: the fonts in lhs2TeX can be configured if you don't like them
08:56:10 <kosmikus> Igloo: if you prefer a different style, I might add it as an option ...
08:56:11 <ski> shapr : interesting ..  thanks for link
08:56:28 <Marvin--> kosmikus: hrm
08:56:42 <Igloo> Sure, it just seems silly to have ugly ones by deafult. Might just be my taste though  :-)    It's possible it was because you needed fixed width fonts though?
08:57:12 <kosmikus> Igloo: no, lhs2TeX does not use any fixed width fonts by default
08:57:46 <kosmikus> and I don't think that the standard configuration is particularly ugly
08:57:59 <Igloo> OK, perhaps just me not liking textsf then?
08:58:11 <Igloo> (sf? ss? sans serif anyway  :-)  )
08:58:30 <kosmikus> also not in the default ;)
08:59:01 <kosmikus> I think it looks pretty similar to what haskell2latex is producing, judging from the example on your page ...
08:59:24 <Igloo> I'm probably just thinking of a different one then
09:00:26 <Igloo> Eww, mozilla is doing something positively horrid to the Greek characters on http://www.jantar.org/lambdaTeX/
09:00:29 <kosmikus> seems to be \lambda\TeX you refer to
09:00:35 <Igloo> s/mozilla/galeon/
09:02:04 <Marvin--> kosmikus: odd, the configure script has  for i in /usr/share/texmf /usr/local/share/texmf; do ...  but for some reason it goes with the /usr/local path anyway
09:02:15 <Igloo> Hmm, probably, although it doesn't look all that bad to me now. *shrug*
09:03:35 <kosmikus> Marvin--: yes, it prefers the local path by default
09:03:41 <kosmikus> Marvin--: I don't know a good solution
09:03:58 <kosmikus> I cannot just respect the prefix, because I must look for a valid texmf tree
09:04:06 <kosmikus> and that might be located somewhere else
09:04:07 <Marvin--> kosmikus: but it does if test -d $$i ; then .. break; fi
09:05:10 <kosmikus> the part with the KPSEWHICH already selects the local path
09:05:32 <kosmikus> the lower part is only a fallback, if the tex distribution does not support KPSEWHICH
09:06:01 <kosmikus> kpsewhich --expand-var='$TEXMFLOCAL'
09:06:08 <Marvin--> ooh
09:06:10 <kosmikus> will probably return /usr/local/.../texmf on your machine
09:06:14 <Marvin--> argh
09:06:31 <Marvin--> and it tries $TEXMFLOCAL before $TEXMFMAIN
09:06:33 <Marvin--> grr
09:06:42 <kosmikus> but as I said, I don't see why you cannot simply override all this detection code and set --with-texmf= directly in the build
09:07:19 <Marvin--> I know, I know, I just wanted to whine a bit :)
09:07:42 <Marvin--> errr
09:07:47 <Marvin--> make clean still seems to loop
09:07:58 <Marvin--> wasn't that the problem we had last time?
09:08:19 <kosmikus> yeah
09:08:21 <kosmikus> or not
09:08:27 <kosmikus> I think it was make depend ;)
09:08:51 <kosmikus> but it doesn't loop for me ...
09:08:54 <kosmikus> strange
09:09:57 <kosmikus> did you download the 1.10 tarball?
09:10:08 <Marvin--> let me see
09:10:15 <Marvin--> d'oh, no, this is 1.9
09:10:33 <kosmikus> that's the same thing that looped last time
09:10:36 <kosmikus> no surprise then
09:10:56 <Marvin--> apparently that wasn't enough coffee
09:12:42 <Marvin--> right, no looping this time
09:12:54 <kosmikus> good
09:14:36 <Marvin--> you might want to mention this texmf issue in INSTALL
09:14:45 <kosmikus> right
09:15:19 <kosmikus> I'll put that on my TODO list
09:17:39 <ski> hmm, would it be better if $ and $! were infixl instead ?
09:17:52 <kosmikus> ski: no
09:18:09 <ski> why ?
09:18:25 * ski is not sure which is the best ..
09:19:00 <kosmikus> because then you can usually go with ordinary juxtaposition
09:19:17 <ski> sorry ?
09:19:31 <ski> (i.e. what do you mean ?)
09:20:25 <kosmikus> because otherwise there would be no difference between  x $ y $ z  and  x y z, and I sure would prefer the latter
09:21:22 <ski> "foo $! i+1 $ xs" instead of "(foo $! i+1) xs", then ?
09:21:28 <kosmikus> but if you like it better infixl, just redefine it, or better, define your own operator
09:22:03 <ski> and already "f $ g $ h $ ..." is the same as "f . g . h $ ..."
09:22:48 <ski> hmm
09:23:20 <kosmikus> there are certainly arguments for both versions, but this is not going to change, because changing it would break almost every larger Haskell program out there
09:23:28 <ski> i guess
09:24:32 <kosmikus> shurik's solution to the four-number problem certainly is quite lengthy, and I don't understand it ...
09:24:51 * ski was just wondering if there was any much better reason for choosing one over the other
09:25:28 <ski> mhm ?
09:25:45 <ski> where's it ?
09:25:51 <kosmikus> haskell-cafe
09:25:58 <ski> oh
09:28:56 * Marvin-- ponders whether lhs2tex should go in the devel or tex section
09:29:18 <kosmikus> that I don't know
09:29:25 <kosmikus> where's lgrind ?
09:30:33 <Marvin--> non-free/tex
09:30:35 <Marvin--> tex it is, then
09:30:55 <mattam> lhs2tex is so good, thanks for advertising it!
09:31:09 <kosmikus> :)
09:31:54 <ham> hiho
09:32:20 <kosmikus> mattam: it's nice if it gets used ...
09:32:42 <ski> ham : hello
09:33:25 <Igloo> kosmikus: Do you know what Daan means by "cvs head lets you give the "--with-opengl" flag to configure."? i.e. do you know what that flag does exactly?
09:33:56 <mattam> What's your PhD about kosmikus ?
09:34:59 <Igloo> (regarding wxHaskell)
09:36:50 <kosmikus> Igloo: moment
09:37:38 <Igloo> Just found it in the CVS repo, doesn't matter
09:39:14 <kosmikus> yeah, it adds the --gl-libs flag
09:39:26 <kosmikus> but that is safe in any case
09:40:16 <kosmikus> and since it won't work at all if you omit it but you have wxwidgets compiled with gl support ...
09:40:26 <kosmikus> ... I think it would be better to just add it always
09:40:49 <kosmikus> mattam: my PhD is on Generic Haskell
09:41:31 <mattam> you've got a group of ppl working on Haskell particularly at your uni ?
09:44:09 <kosmikus> not exclusively on Haskell, no
09:44:26 <kosmikus> but everyone in our group knows what Haskell is, and most are actively using it
09:45:36 <mattam> in my area there are mostly caml riders, so i wondered if it was always so concentrated(?).
09:45:59 <kosmikus> I don't think so
09:46:42 <kosmikus> one of the reasons why I went from Germany to the NL was the fact that there is a group of Haskell people here, and not there ...
09:46:56 <mattam> ha
09:47:23 <kosmikus> I know of several people in Germany doing FP or even Haskell, but not so many in one place ...
09:48:00 <mattam> you switched just for your PhD ?
09:52:44 <kosmikus> why "just"? isn't that a very good reason to switch?
09:53:24 <mattam> there is another nuance of 'just' in france :)
09:53:50 <mattam> somewhat like 'just before'
09:54:15 <kosmikus> oh, sure, then the answer is a simple "yes"
09:54:48 <kosmikus> I studied convoluted mathematics before ...
10:01:33 <Marvin--> kosmikus: hm, no changelog in the release?
10:03:47 <kosmikus> Marvin--: no
10:04:21 <kosmikus> 1.9 was the first release at all, so I think the release announcement pretty much covers it, and 1.10 is not yet released, I will probably write something when I do
10:04:42 <Marvin--> 'k
10:05:18 <kosmikus> does it work now?
10:07:46 <Marvin--> yeah, lookin' good
10:08:00 <kosmikus> fine
10:08:02 <Marvin--> just polishing some of the mandatory Debian thingies :)
10:08:13 <kosmikus> what's that?
10:09:01 <Marvin--> postinst/postrm scripts, control scripts et.c.
10:13:42 <kosmikus> I see
10:14:19 <kosmikus> you probably have to call texhash or mktexlsr somewhere in those, to make sure that the TeX package that is installed is properly added to the database
10:14:32 <Marvin--> I know :)
10:22:06 * Marvin-- grumbles and writes a man page
10:37:40 <ztre> hi
10:37:54 <ski> hi ztre
10:38:14 <ztre> i just began the "gentle intro to haskell" i want to learn it, but
10:38:33 <Si\> message to anyone; if someone said to you "Ok you've brought SOAP and WSDL to Haskell, but why Haskell?" what would you say?
10:38:42 <ztre> i need a fibonacci series impletentation
10:39:15 <kosmikus> ztre: what did you try so far?
10:39:22 <ztre> kosmikus: ?
10:40:32 <kosmikus> you say, you need a fibonacci series implementation
10:40:40 <kosmikus> did you try to write it?
10:40:43 <Marvin--> Si\: I guess "why not?" isn't going to cut it? :)
10:40:44 <ztre> so can anyone write a simple fibonacci series implementation (here?)? one that generates the series in linear time
10:41:35 <ztre> kosmikus: i dont know haskell yet :-(
10:41:51 <kosmikus> yes, but I thought you want to learn it
10:41:55 <ztre> but i just want to benchmark
10:42:12 <ztre> and if the performance is okay, i'll learn it.
10:42:42 <ztre> well okay:
10:42:55 <Si\> sadly not Marvin--, I have to justify to a University full of javaites, why Haskell deserves interoperability in this way, whether SOAP/XMLRPC etc. fits into the FP paradigm and what could it in the real world be used for.
10:43:01 <ztre> is this correct? (i really never seen any haskell):
10:43:24 <ztre> fib n = fib(n-2) + fib(n-1)
10:43:36 <ztre> but this is not in linear time you see?
10:43:39 <kosmikus> well, yes and no
10:43:45 <kosmikus> first of all, it's not linear
10:43:50 <kosmikus> second, it will not terminate
10:43:51 <ztre> yea
10:44:00 <kosmikus> you need to add another case, something like
10:44:04 <kosmikus> fib 0 = 1
10:44:16 <ztre> yea okay, but i need a linear one
10:45:03 <ski> fib 0 = 0
10:45:06 <ztre> kosmikus: well, u know python?
10:45:07 <ski> fib 1 = 1
10:45:18 <ztre> ski: yes sure
10:45:20 <ski> (you need two base cases)
10:45:32 <kosmikus> yes sure
10:45:50 <kosmikus> one trick to make it linear is to keep an extra argument
10:45:54 <ztre> kosmikus: okay, so how is this in haskell?:
10:45:59 <ztre> def f():
10:46:07 <ztre>     yield 0
10:46:10 <ztre>     yield 1
10:46:17 <ztre>     a, b = 0, 1
10:46:21 <ztre>     while True:
10:46:32 <ztre>         a, b = b, a+b
10:46:36 <ztre>         yield b
10:47:00 <ztre>  
10:47:01 <ztre> so?
10:47:13 <ski> fib = (fibs!!)
10:47:22 <kosmikus> the closest correspondence in Haskell would be the famous zip definition ...
10:47:24 <ski> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:47:27 <ski> perhaps ..
10:47:29 <kosmikus> there you go
10:47:43 <kosmikus> ski's faster than I am
10:47:58 <ztre> ski, kosmikus: thanx!
10:48:08 <ski> kosmikus : and i'm even talking in another channel atm .. :)
10:50:15 <ztre> well, what extension should i use?
10:50:23 <ztre> .has?
10:50:26 <kosmikus> .hs
10:50:31 <ztre> kosmikus: okay
10:52:28 <ztre> :-)
10:52:41 <ztre> :-D okay now how do i call it
10:53:02 <ztre> i need something like: 0 1 1 2 3 5 ... \n
10:53:48 <ztre> how do i print the first X fibs?
10:54:08 <ski> in hugs / ghci ?
10:54:13 <ski> or in a compiler program ?
10:54:28 <ztre> i wanto to compile it with ghc6
10:54:37 <ztre> i also have hugs tho
10:54:45 <ski> main = print (take 6 fibs)
10:54:46 <ztre> but for the benchmark, ghc6
10:54:49 <ski> e.g.
10:54:52 <ztre> :-D
10:54:53 <kosmikus> take x fibs
10:54:55 <ztre> simple
11:00:17 <ztre> well, how do i opitimize for i386, i686 and p3?
11:01:43 <kosmikus> ztre: are you aware of http://www.inorg.chem.msu.ru/~cubbi/serious/fibonacci.html
11:01:59 <ztre> kosmikus: :-D no
11:02:04 <ztre> kosmikus: ...
11:05:06 <Marvin--> kosmikus|away: cute :)
11:08:57 <ztre> :-D lol its 15 times faster than python!
11:09:30 <ski> :)
11:09:37 <Marvin--> well, you compiled it, didn't you?
11:09:54 <ski> well, python is bytecode-interpreted, no ?
11:10:03 <Marvin--> exactly
11:10:57 <ztre> it leaved a .hi and a .o... what are theese? can i rm them safely?
11:11:20 <ztre> Marvin--: i compiled haskell yea.
11:12:04 <Marvin--> .hi is type information, .o is the compiled code just as for e.g. C
11:12:17 <ztre> c doesnt leave the .o
11:12:26 <Marvin--> if you compile with -c it does
11:12:31 <ztre> Marvin--: :-)
11:12:38 <ztre> Marvin--: so can i make clean then?
11:12:44 <ztre> them
11:13:14 <Marvin--> well, if you want them to be recreated next time you compile...sure
11:13:29 <ztre> okay.
11:13:48 <Marvin--> I prefer to use ghci or hugs during development, speedier than recompiling all the time
11:15:41 * Marvin-- rebuilds the darn package for the nth time
11:39:31 <Marvin--> any Debian users who want to try the package=
11:39:32 <Marvin--> ?
11:46:49 <ztre> Marvin--: i am a debian user. what package?
11:47:12 <Marvin--> ztre: I just packaged kosmikus' lhs2TeX
11:47:21 <ztre> Marvin--: ?
11:47:46 <ztre> Marvin--: well, i dont know TeX, so i wont be able to figure out if it works
11:48:34 <ztre> (it turned out that haskell fibonaccis are ~20% slower than c :-(
11:56:47 <ztre> whats Prelude?
11:57:09 <Marvin--> the Prelude is a module with commonly used things that are always available without you having to import it
11:58:23 <ztre> Marvin--: i see. i just saw it at the hugs prompt
12:02:40 <maihem> Is there a module for a finite state machine, where I could define all the states in the machine with a data definition, and define a transit function that takes a state and a trigger. There woule be a main function to evaluate the state machine given a list of triggers, which returns a list produced by the transitions (ie each transition adds a Maybe a to a list, and the catMaybe of that list is returned) ?
12:03:08 <maihem> I'm trying to write one, but I'm not very good yet :/
12:04:49 <Cale> l
12:09:36 <maihem> I've got a problem with this attempt (the compiler error is posted with the code): http://rafb.net/paste/results/JN375270.html
12:10:28 <Marvin--> maihem: use HaskellIrcPastePage on hawiki, it's got haskell syntax coloring
12:10:35 <maihem> cool!
12:12:28 <maihem> uh, do I jsut edit the page and delete everything on it?
12:12:51 <Marvin--> maihem: or add a new section
12:12:58 <Marvin--> maihem: but I see the error
12:13:04 <Marvin--> loop s (t:ts) = catMaybes spat
12:13:05 <Marvin-->   where spat = (spit s t):(loop (transit s t) ts)
12:13:18 <Marvin--> spit s t  has type Maybe e, but loop (transit s t) ts  has type [e]
12:13:46 <maihem> doesn't cat maybe return [e] from [Maybe e]?
12:13:55 <maihem> throwing away the Nothings?
12:13:59 <Marvin--> that's not the point
12:14:19 <maihem> ah-ha!
12:14:27 <Marvin--> you have an expression that could be on the form  (Just 3):[4,5]
12:14:39 <Cale> the point is that spat itself will be mistyped
12:14:40 <Marvin--> which would require Maybe e == e, which won't happen
12:15:17 <Marvin--> maihem: you with me?
12:15:45 <maihem> thanks Marvin-- :) I need to do loop s ts = catMaybes (realloop s ts) where { realloop s (t:ts) = (spit s t):(reallop (transit s t) ts) } ?
12:16:01 <maihem> s/realop/realloop
12:16:43 <Marvin--> for example
12:17:15 <maihem> Am I using the class and functional dependancies correctly and as they should be for clean code?
12:17:21 <Marvin--> or you could do  loop s (t:ts) = maybeToList (spit s t) ++ loop (transit s t) ts  or something
12:18:36 <Marvin--> I'm not sure, I'm not that into MPTC
12:18:38 <Si\> does anyone if documentation exists for HWS-WP's plugin system?
12:18:47 <maihem> Marvin--: k, and thanks
12:18:52 <Marvin--> Si\: nothing beyond what I wrote in my report on it, I guess
12:19:33 <Si\> I haven't read your report, where is that?
12:20:00 <Marvin--> Si\: http://www.strakt.com/~martin/hws-wp/report.ps
12:20:44 <Si\> yet that was what I was looking for, ty
12:20:48 <Si\> *yep
12:22:39 <Marvin--> glad to be of service :)
12:52:57 <Marvin--> so anyway, I have this program with pluggable backends and I use GetOpt for options parsing. Different backends have different flags available, plus there are backend-agnostic flags... how should I represent this in a decent way? Currently, I do it with a list of strings for the flags, which kinda...sucks
12:53:54 <Marvin--> I don't know how to make a decent data type for it, since the backends have different flags and options
12:58:42 * Marvin-- ponders if this isn't one of those cases where subtyping would be handy
12:59:16 <ski> hmm
12:59:54 <Marvin--> maybe I can do it with an existential type
12:59:57 <ski> program args should perhaps be records, with sub-records for options to backends ..
13:00:20 <Marvin--> yeah, I have a record for backend-agnostic flags
13:00:59 <Marvin--> I'm using Tomasz Zielonka's technique
13:01:10 <ski> hmm
13:01:13 <ski> which is ?
13:02:38 <Marvin--> http://www.haskell.org//pipermail/haskell/2004-January/013412.html
13:06:20 <Igloo> Wow, configure for splitvt is a C program
13:07:10 <Marvin--> ow
13:11:19 <Marvin--> I so should change the code to use implicit parameters instead of a reader monad for the options
13:24:28 <Marvin--> hm
13:25:16 <Marvin--> newtype Backend = Backend ((?options :: Options) => Program -> String)   won't work?
13:26:56 <Marvin--> meh, it doesn't work well with lambda functions
13:33:22 * Igloo wonders how slow a layer of VT emulation in Haskell would be
13:35:30 <shapr> what's VT?
13:35:48 <Marvin--> virtual terminal
13:35:49 <ski> you don't know about VT100 ?
13:36:05 <shapr> oh, that vt
13:38:29 <Marvin--> the only thing that sucks with implicit parameters is that the type inference falls apart
13:39:02 <ski> in what way ?
13:39:38 <Marvin--> hm, maybe not
13:39:49 <Marvin--> I had some problems with unbound implicit parameters
13:40:15 <Marvin--> seems to work fine now, though
13:40:18 <Marvin--> oh yes, this is neat
13:41:07 <Marvin--> no more ifM crap
13:52:08 <Marvin--> dang
13:52:18 <Marvin--> Illegal constraint ?options :: Options
13:55:40 <Marvin--> this ain't working very well
13:57:30 <ski> it doesn't like it ?
13:58:33 <Marvin--> I'm switching between Illegal constraint and Unbound implicit parameter
13:58:53 <Marvin--> it doesn't seem to like passing around partially applied functions with implicit parameters
13:59:52 * Marvin-- sighs
14:02:41 <ski> perhaps it assumes that if you're giving args to it, then the implicit args must be determined here and now, as well
14:03:03 <Marvin--> hm, actually, I don't partially apply them at all
14:03:20 <Marvin--> I'm wondering if it objects to being passed around in a Maybe
14:03:40 <ski> so it doesn't even like storing things with implicit args in constructors ?
14:03:53 <ski> (like it can store polymorphic functions)
14:09:52 <Marvin--> mkFE "helium" = HeliumFrontend.frontend
14:09:55 <Marvin--> doesn't seem to work
14:12:35 <Marvin--> wonderful
14:13:02 <Marvin--> if I put a context on mkFE, it complains where I *use* mkFE, if I *don't* put a context on mkFE, it complains on mkFE
14:13:25 * Marvin-- swears
14:15:16 <Marvin--> so... I'm guessing that this whole "contexts have to be top level" is seriously messing this up
14:15:58 <ski> what type does HeliumFrontend.frontend have ?
14:16:07 <Marvin--> Frontend
14:16:20 <Marvin--> which is an alias for  (?options :: Options) => String -> Program
14:16:21 <ski> what do should mkFE have ?
14:16:24 <ski> ok
14:16:36 <ski> s/do/type/
14:16:40 <Marvin--> which makes me uncertain what type mkFE should have
14:17:00 * ski wonders why he wrote do instead of type
14:17:18 <Marvin--> neither  String -> Frontend,  (?options :: Options) => String -> Frontend  nor  (?options :: Options) => String -> String -> Program  seems to work
14:17:27 <ski> you want (?options :: Options) => String -> String -> Program, no ?
14:17:33 <ski> hm
14:18:07 <ski> mkFE "helium" s = HeliumFrontend.frontend s
14:18:10 <Marvin--> I think the only solution is to get rid of the type alias :-(
14:18:11 <ski> does that work ?
14:18:44 <Marvin--> hm, good question
14:20:26 <Marvin--> mm, no, didn't seem to help
14:21:13 <Marvin--> Unbound implicit parameter
14:22:51 <ski> even with type sign. ?
14:23:14 <Pseudonym> Greetings.
14:23:21 <ski> Pseudonym : hello
14:23:30 <Pseudonym> Group theory question.
14:23:42 <Pseudonym> "Symmetry group" and "permutation group" are isomorphic, right?
14:23:51 <Pseudonym> By which I mean...
14:24:05 <Pseudonym> | S_n | = n!
14:24:17 <Pseudonym> ?
14:24:28 <Marvin--> eww, this could be bad... the options variable and the usage function are mutually recursive
14:24:37 * Marvin-- gives up for today
14:25:03 <mattam> Pseudonym: hi
14:25:21 <Pseudonym> G'day.
14:25:34 <mattam> night actually :)
14:25:56 <Pseudonym> Can't be.  If it was night, I wouldn't be so damn tired.
14:26:07 <Marvin--> Pseudonym: ISTR so yes
14:26:07 <mattam> i am!
14:26:33 <skew> hi
14:26:41 <Marvin--> Pseudonym: if you want me to be absolutely sure I could whip out Durbin and look it up
14:26:42 <Pseudonym> Marvin--: That's the answer to the group theory question, right?
14:26:49 <Marvin--> Pseudonym: right
14:26:51 <Pseudonym> No, that's fine.
14:27:03 <mattam> you hadn't finished your explanation last night/day, can I ask you to continue ?
14:27:14 <skew> Pseudonym: I think those are the same groups also
14:27:18 <skew> Er
14:27:21 <Pseudonym> This book I'm reading says "permutation group" for one chapter, then whips out "the symmetry group S_5" and I think to myself "hang on..."
14:27:26 <skew> What sort of symmetry group?
14:27:30 <Pseudonym> Just wanted to make sure they're the same.
14:27:57 <Pseudonym> skew: Apparently there's a standard kind of group S_n.
14:27:58 <skew> there's also the dihedral group, of symmetries of a regular polygon in the plane
14:28:06 <skew> Yeah S_n is permutation
14:28:06 <Pseudonym> I'm guessing that it's isomorphic to the permutation group.
14:28:09 <Pseudonym> Right.
14:28:21 <Pseudonym> Except that this calls it "the symmetry group" which, as you point out, is vague.
14:28:36 <skew> shapr: Are you around? Did you hear about my Python interface?
14:28:37 <Pseudonym> The group of rotations in 3-space is also a symmetry group of some physics problems.
14:28:47 <Marvin--> I'm pretty sure that Durbin defines Sym(S) as the group of permutations of a nonempty set S
14:28:53 <Pseudonym> Right, OK.
14:29:02 <Marvin--> and S_n = Sym({1..n})
14:29:04 <Pseudonym> Sorry, mattam: Where was I up to?
14:29:06 <ski> doesn't one sometimes talk about e.g. "the symmetry group of the dodecahedron" ? (or am i misremembering ?)
14:29:17 <skew> yeah, that's the sort of thing I was thinking about
14:29:19 <Pseudonym> Durbin is a good book, BTW?
14:29:26 <Marvin--> Durbin is an excellent book IMO
14:29:27 <Pseudonym> Yes, that has a name in this book too.
14:29:48 <Marvin--> maybe there's a difference between *symmetric group* and *symmetry group*... hang on
14:29:49 <Pseudonym> Cool.  I realised as I was reading this just how much group theory I didn't know.
14:30:11 <Pseudonym> Oh, good point.
14:30:15 <mattam> Pseudonym: i was trying to express P(A) == A = {17} categorically, you talked about terminal objects and said a point is a morphism/function on terminal objects
14:30:40 <mattam> like f :: {a} -> X
14:30:42 <Pseudonym> Ah, OK.  I thought I'd finished that.
14:30:54 <mattam> i opposed it was a partial function
14:31:03 <Pseudonym> Anyway, the thing is, you can't express A = {17} categorically as such, unless you have names for all the morphisms.
14:31:07 <skew> mattam I think you would just use equality of objects
14:31:11 <Pseudonym> No, in Set, all functions are total.
14:31:20 <ski> mattam : f is a total function there, no ?
14:31:27 <Marvin--> I think Sym(S)/S_n are *symmetric groups*, whereas *symmetry groups* are related to rotations and reflections of geometric stuff
14:31:36 <Pseudonym> Ahhhh.
14:31:40 <mattam> it works only for singleton sets
14:31:49 <Pseudonym> BTW, "symmetry group" is actually a far mroe general concept.
14:31:53 <Pseudonym> I remember this from physics.
14:31:56 <mattam> it 'looks inside objects' somehow
14:32:13 <Pseudonym> mattam, all singleton sets are isomorphic, correct?
14:32:13 <Marvin--> I bet it is, it's just what I thought of when I tried to remember
14:32:19 <Pseudonym> Sure.
14:32:27 <mattam> yes
14:32:54 <Pseudonym> As an example, a point in a constant force field has the translation group as its symmetry group.
14:33:11 <Pseudonym> Hmmm.
14:33:15 <Marvin--> right, rotations, reflections, translations...
14:33:19 <Pseudonym> Make that a point in free space.
14:33:37 <Pseudonym> Anyway, an important theorem of physics is that for every symmetry a problem has, there is a corresponding conserved quantity.
14:33:43 <ski> scaling and shearings too ?
14:33:54 <Pseudonym> For example, the translation symmetry group induces conservation of momentum.
14:34:04 <Pseudonym> The rotation symmetry group induces conservation of angular momentum.
14:34:05 <Pseudonym> And so on.
14:34:17 <Pseudonym> I suppose that's a kind of Galois correspondence.
14:34:22 <Pseudonym> Galois connection, sorry.
14:34:31 <Pseudonym> Anyway, back to singleton sets.
14:34:36 <mattam> :)
14:34:50 <Pseudonym> The thing is, you can't define A = {17} by a _universal_ mapping property.
14:34:57 <Pseudonym> If you can name objects, then you can just name {17}.
14:34:58 <Marvin--> ski: I don't think so
14:34:59 * shapr hugs ski
14:35:12 <skew> I'm still wondering how you decided some singleton is '{17}'
14:35:21 <skew> hi shapr
14:35:24 <Pseudonym> If you can name morphisms, then you can name its point.
14:35:25 <shapr> hi skew!
14:35:28 <ski> shapr : oh, why ? :)
14:35:34 <mattam> i can name morphisms
14:35:36 <ski> shapr : hi !, btw
14:35:40 <shapr> ski: just cuz you're cool
14:35:47 * shapr has had a bit too much cognac possibly
14:35:51 <skew> shapr: Have you heard about my Python interfac?
14:35:57 <shapr> I have heard of it
14:35:57 <ski> shapr : i didn't know that :)
14:35:59 <shapr> but I have not seen it
14:36:02 <shapr> and I would like to see it.
14:36:03 <Pseudonym> mattam: OK, then for all objects X, there is a unique morphism f : X -> {17}
14:36:12 <mattam> P(A) = f_17 A = A ?
14:36:17 <skew> well, I put up a darcs repository at htt://page-208.caltech.edu/
14:36:33 <mattam> Pseudonym: yep
14:36:51 <Pseudonym> We'll call this f_{X,17}.
14:37:09 <mattam> is it a standard convention for terminal objects ?
14:37:20 <Pseudonym> Then P(A) === f_{X,17}(A) = A
14:37:24 <skew> I made ffi bindings for a reasonable portion of the Python/C API
14:37:26 <Pseudonym> No, I just made it up.
14:37:31 <mattam> k
14:37:33 <Pseudonym> There probably is a standard convention.
14:38:10 <skew> make a.out to build a program that takes a module name, a function name, and a bunch of numbers, and prints the result of the application (assuming everything is a long)
14:38:18 <skew> try ./a.out operator add 1 2
14:38:21 <Pseudonym> See, if f_{A,17}(A) = A, then f_{A,17} is id_{17}
14:38:33 <Pseudonym> Because {17} has an identity morphism.
14:38:49 <Pseudonym> And because there is always exactly one morphism from X to {17}, if X = {17} then it's the identity.
14:38:52 <mattam> yes
14:38:58 <Pseudonym> Did that help?
14:39:06 <skew> make hadd.so to build an extension module for Python. In an interpreter, try import hadd; hadd.add('a','b')
14:39:11 <mattam> i think so
14:39:12 <Pseudonym> Let me see if there's standard notation for this.
14:39:29 <Pseudonym> (turned out that a colleague has a copy of Asperti and Longo on his bookshelf!)
14:39:38 <Pseudonym> Saves me printing out 300+ pages.
14:39:41 <skew> shapr: I've also started hacking up some marshalling typeclasses
14:39:57 <shapr> cool, so you'll be able to call Python libs from Haskell?
14:40:03 <shapr> that will be especially spiffy
14:40:09 <skew> both ways, actually
14:40:13 <Marvin--> wow, neat
14:40:27 <Pseudonym> OK, this book uses the notation !a : a -> 1
14:40:34 <skew> though I'm not happy with the linking situation for packaging Haskell functions as a Python extension module
14:40:42 <Pseudonym> For the unique morphism which maps a to a terminal object.
14:40:53 <Pseudonym> So I think you could use !A : A -> {17}
14:41:01 <Pseudonym> !A is the name of the morphism.
14:41:07 <mattam> nice
14:41:33 <ski> Pseudonym : i've seen <>_A : A -> 1 used
14:41:48 <mattam> isnt A -> {} a morphism to a terminal object too ?
14:41:54 <ski> no
14:42:00 <ski> {} is not terminal in Set
14:42:01 <Pseudonym> No!
14:42:05 <Pseudonym> {} is an _initial_ object in Set.
14:42:17 <Pseudonym> For every set A, there is exactly one function f :: {} -> A
14:42:25 <skew> Marvin--: thanks. You all grab a copy too, if you want it
14:42:25 <mattam> ok
14:42:25 <Pseudonym> Which is the other way around from {17}.
14:42:31 <ski> []_A : 0 -> A
14:42:34 <Pseudonym> Initial is dual to terminal.
14:42:38 <Marvin--> skew: don't mind if I do :)
14:42:41 <skew> mattam: There are no functions into an empty set from a non-empty set, actually
14:42:54 <Pseudonym> One of the things I've noticed about category theory is that nobody uses consistent notation.
14:43:01 <ski> heh
14:43:03 <Pseudonym> If I ever write a book on this, I'll be sure to make up my own.
14:43:07 <mattam> skew: why ?
14:43:17 <skew> where would it send the elements?
14:43:26 <skew> at least, that's why I don't think there should be any
14:43:40 <Pseudonym> There is a _partial_ function, but Set is the category of sets with _total_ functions.
14:43:47 <mattam> why can't it throw them away ?
14:43:56 <ski> Pseudonym : i think <> and [] was meant to look like degenerate <f,g> and [f,g]
14:44:05 <Pseudonym> mattam: You're thinking in Haskell.
14:44:10 <Pseudonym> ski: Oh, that's a good idea.
14:44:13 <mattam> yes ;)
14:44:14 <Pseudonym> Who uses that notation?
14:44:27 * ski tries to remember
14:44:31 <Pseudonym> In Haskell, every domain is lifted.
14:44:40 <ski> filinski it possibly was
14:44:44 <Pseudonym> (Unless you count GHC's unboxed values.)
14:44:44 <Smerdyakov> mattam, think of functions as relations where first components are unique.
14:44:52 <Marvin--> skew: er, I'm not a darcs wizard... darcs failed:  Failed to download URL http://page-208.caltech.edu//_darcs/inventory error code: 22
14:44:56 <Marvin--> what does that mean?
14:44:58 <skew> shapr: are you more interested in using Python modules?
14:44:59 <Pseudonym> So a function can return "bottom".
14:45:04 <Pseudonym> But not in Set.
14:45:09 <Smerdyakov> mattam, everything computational is expressed with the possibility of mapping values to bottom.
14:45:09 <skew> Marvin--: possibly it's broken
14:45:22 <skew> Marvin--: All I did was point a webserver at the repository
14:45:44 <Marvin--> shapr? clues?
14:45:45 <ski> Smerdyakov : not in charity
14:45:54 <skew> I can get at that file in a browser at least
14:46:00 <Smerdyakov> ski, eh?
14:46:02 <mattam> why would that imply returning bottom ? in f : X -> {17}, what do you do with X's content ?
14:46:17 <shapr> Marvin--: sounds like a read problem to me
14:46:29 <ski> Smerdyakov : (but then it's not turing complete :), but quite expressive anyway)
14:46:33 <Smerdyakov> mattam, you are still thinking of it the wrong way! You should be asking "which value in {17} do you associate with each value in X"?
14:46:42 <shapr> I get the same error
14:46:44 <Smerdyakov> mattam, there is no "doing" anything.
14:46:48 <Marvin--> all I did was  darcs get --repo-name=foo http://page-208.caltech.edu/
14:46:58 <Pseudonym> Yeah, it helps to think of functions in terms of their graph.
14:47:04 <skew> hmm, I'll make the repository not the root
14:47:05 <Pseudonym> To reason about these degenerate cases.
14:47:25 <Smerdyakov> You mean all the degenerate cases in this channel?
14:48:19 * ski smiles
14:48:30 <Pseudonym> http://www.jibble.org/piespy/ <- graph of degenerate cases in IRC channels
14:48:48 <shapr> I've seen that
14:48:56 <shapr> the scary thing is how many of those people I know :-)
14:50:09 <mattam> restating it, f : X -> {} would be a function associating values in X to values in an empty set, which is absurd ?
14:50:32 <Smerdyakov> Pseudonym, is there any place that has searchable PieSpy results for freenode on the web?
14:51:24 <ski> mattam : yeah, f must map each value in X to exactly one value in {}
14:51:38 <Pseudonym> Smerdyakov: No clue.
14:51:55 <ski> but that's impossible, since {} has no values in it  (unless X is also empty. then we're trivially done :)
14:52:04 <mattam> ok, i got it
14:52:26 <mattam> watching tv at the same time didn't help...
14:52:33 <ski> :)
14:52:47 <skew> Marvin--, shapr: I've moved the repository to http://page-208.cltech.edu/phi
14:52:54 <skew> ]A trailing slash seems to mess up darcs get
14:53:15 <Marvin--> ooh
14:53:31 <skew> or my webserver doesn't like multiple slashes
14:54:46 <Marvin--> hm, are incref/decref only available as macros? I thought there were function versions too, but maybe I'm misremembering
14:55:10 <skew> maybe there are functions somewhere
14:55:30 <skew> I found out that many things in the public interface are actually macros
14:56:30 <Marvin--> yeah, a heck of a lot of them are
14:57:44 <Marvin--> heh, this is kinda gritty
14:57:50 <skew> so, does it build and work?
14:58:33 <skew> I don't trust the linker options for hadd.so to be portable, because they were lifted from ghc -v
14:58:41 <Marvin--> well, no, not without hacking the Makefile... there's no -fglasgow-exts there
14:58:50 <skew> huh?
14:59:11 <skew> I set an OPTIONS pragma the one place I thought I needed it
14:59:21 <Marvin--> not in Types.hs anyway
14:59:36 <skew> the only errors I get are CPP errors because HsFFI.h and Python.h fight over some names
14:59:39 <Marvin--> and Modules.hs has overlapping instances
15:00:39 <Marvin--> and why doesn't the Makefile specify -ffi?
15:01:39 <skew> well, I just tossed together a Makefile to organize building
15:01:58 * Marvin-- apt-gets python2.3-dev
15:02:15 <skew> So the makefile is pretty bad
15:02:18 * shapr falls over into sleep
15:02:26 <mattam> so, now i really wonder how to express P(A) == A = {} without resorting to the inverse of f : {} -> X.
15:02:31 <skew> I hardcoded /usr/include/python2.3/ for the python headers also
15:02:36 <shapr> skew: thanks for making the darcs repo available, I'll try this tomorrow
15:02:37 <skew> what version of GHC are you using?
15:02:47 <Marvin--> skew: I found that I had to add OPTIONS to Main and Modules too
15:02:48 <skew> shapr: Have fun!
15:02:53 <shapr> :-)
15:03:00 <skew> It sounds like you might be able to use this
15:03:11 <skew> Marvin--: weird, I just rebuild everything with no complaints
15:03:19 <skew> what GHC are you using?
15:03:39 <Marvin--> 6.2
15:03:53 <skew> so am I
15:03:55 <skew> Linux?
15:03:55 <ski> mattam : P(A) <=> forall B. exist! f : A -> B    ?
15:04:05 <Marvin--> skew: yes
15:04:21 <mattam> oh right
15:04:31 <Marvin--> skew: http://www.mdstud.chalmers.se/~md9ms/phi.diff <- those are the changes I did
15:04:46 <Marvin--> or so I thought
15:05:04 <mattam> but as morphisms are total functions, isn't inverse a well defined operation ?
15:05:05 <skew> What errors did you get?
15:05:27 <ski> mattam : not on all morphisms, no
15:05:39 <mattam> ha ?
15:05:59 <mattam> That would not be in Set for sure.
15:06:04 <skew> mattam: non-injective functions don't have inverse functions
15:06:13 <Marvin--> skew: let me check out a fresh copy and give you all the naughty details
15:06:20 <ski> mattam : e.g.  f : {1} -> {2,3}  f(1) = 2   what's the inverse of f ?
15:06:42 <ski> hmm, no
15:07:01 <ski> i meant
15:07:11 <Marvin--> skew: first of all,  Types.hs:22: Not a constructor: `forall'
15:07:17 <ski> f : {1,2} -> {3}  f(1) = 3  f(2) = 3
15:07:26 <Marvin--> since Types.hs didn't have any OPTIONS
15:07:49 <mattam> f^-1(3) = 1.5 :)
15:07:59 <mattam> i'm kidding
15:08:20 <skew> Marvin--: Odd. It works for me. I wonder why
15:08:22 <monotonom> isomorphisms are the ones that have inverses.
15:08:32 <monotonom> not all morphisms are isomorphisms.
15:08:46 <mattam> haha
15:08:54 <Marvin--> skew: so I fixed that, and then it fails on compiling Prim, because there's no -ffi flag
15:09:05 <monotonom> (What is an isomorphism?  Well the definition of isomorphism essentially says it has inverses... begging the question :)
15:09:19 <skew> Marvin--: Are you running just plain 6.2?
15:09:29 <skew> Marvin--: Sounds like I need to work on portability
15:09:31 <Marvin--> skew: plain 6.2, the Debian unstable package
15:09:33 <Smerdyakov> monotonom, I would like to kiss you now for using "begging the question" correctly.
15:09:47 * monotonom flushes
15:09:51 <monotonom> err blushes
15:09:53 <Marvin--> haha
15:10:24 <monotonom> (Sorry for being too operational by exposing the way blushing is implemented by blood flushing :)
15:10:26 <ski> mattam : (i.e. f : A -> B is an isomorphism <==> exists g : B -> A  such that  f . g = id_B and g . f = id_A)
15:10:46 <skew> Hmm, I don't see any HSOPTS='-fglasgow-mangled-haskell' in my environment. I wonder why this stuff compiles!
15:10:50 <mattam> yup
15:11:00 <Pseudonym> monotom: For additional kissing, define blushing using morphisms only.
15:11:08 * mattam 's moving on
15:11:13 * Pseudonym mistyped monotonom
15:13:39 <skew> Marvin--: why did Main need OPTIONS?
15:14:13 <Marvin--> Overlapping instance declarations:
15:14:14 <Marvin-->   In module Objects: Types.PyArgs a
15:14:14 <Marvin-->   In module Objects: Types.PyArgs [a]
15:16:40 <Marvin--> skew: does it still compile for you with my patch? :)
15:17:13 <skew> yes
15:17:41 <skew> It still works too
15:17:55 <skew> I've patched my repository. Thanks
15:19:00 <skew> Who should I credit that to, other than just Marvin--?
15:20:25 <Marvin--> skew: as in, my realname? :)
15:21:17 <skew> well, I've just named the patch something like "diff from Marvin--" for now
15:21:35 <Marvin--> skew: *shrug* my real name is Martin SjÃ¶gren, if you prefer to use that
15:21:46 <Marvin--> doesn't really matter to me
15:25:23 <skew> Marvin--: I guess it's a question of which name people are more likely to know
15:25:41 <Marvin--> skew: I'm guessing it won't matter much :)
15:25:57 <skew> well, with luck I'll at least have shapr as a user...
15:26:01 <Marvin--> he
15:26:03 <Marvin--> h
15:26:10 <Marvin--> he knows both, though ;)
15:26:34 <skew> and wants to mix them
15:26:40 <skew> or at least use Haskell for web stuff
15:28:46 <Jerub> skew: I'd be really interested in being able to run haskell from python too.
15:28:59 <skew> yay, that makes two
15:29:24 <skew> Jerub: you wanted the marshalling of algebraic data types, right?
15:29:32 <Jerub> skew: I've been writing a compiler in haskell.
15:29:40 <Jerub> skew: that'd be nice, but on reflection I probably wouldn't need it.
15:30:12 <Jerub> skew: as I find that doing the bytecode emission from haskell is actually far easier - pattern matching of algebraic datatypes is invaluable.
15:30:37 <skew> where does Python come in?
15:30:42 <skew> and what are you compiling?
15:30:59 <mattam> correct me if i'm wrong: "A is a singleton set <=> forall X exists f : X -> A and f is unique" ?
15:31:18 <skew> mattam: In the category Set at least
15:31:24 <mattam> in Set yes
15:32:07 <skew> It will be interesting to see if shapr can convince some clients to let him use a yet wierder and more wonderful language
15:32:49 <Marvin--> skew: this is really cool :-)
15:33:03 <Jerub> skew: python would be managing the build process.
15:33:12 <skew> Jerub: I'll probably write that marshalling sometime anyways - I've wanted to build something with Data.Generic for a while, to make sure I understand it
15:33:31 <skew> Jerub: sort of like the perl(?) driving GHC?
15:33:52 <Pseudonym> I find it interesting that programming languages have come a long way in recent years, but "make" technology hasn't.
15:34:04 <Pseudonym> There are some notable exceptions, such as jam.
15:34:14 <Pseudonym> But mostly they're hacks based on top of make.
15:34:18 <monotonom> mattam's wording is not the best.  Usually we say "forall X exists unique f:X->A"
15:34:37 <skew> Marvin--: Thanks. Let me know what you want to see (or code it up yourself ;)
15:35:10 <skew> Pseudonym: I think part of the problem is that operating systems really haven't advanced much
15:35:27 <Pseudonym> Well, that's true.
15:35:29 <skew> If you've just got one language involved you can do all sorts of fancy things
15:35:49 <mattam> monotonom: so no need to define unique ? :)
15:35:52 <Pseudonym> skew: True, but when you have program generators, like yacc or happy, all sorts of things are thrown out.
15:36:16 <skew> yeah. More metadata (typed files?) could help
15:36:23 <skew> or something like that
15:36:30 * Marvin-- grins evilly as he calls into libssl via pyopenssl from skew's program
15:36:38 <skew> Marvin--: yay
15:36:44 <skew> well, I've got to go
15:37:47 <Marvin--> that's be Haskell -> C -> Python -> C
15:37:51 <Marvin--> or something
15:39:01 <Jerub> make is still a very useful tool, and does what it does well.
15:39:29 * Marvin-- puts jam on his to-look-at pile
15:40:02 * earthy adds `enough' to 
15:40:07 <earthy> Jerub's sentence
15:40:09 <kosmikus> mattam: exists unique a. P(a) <==> exists a. P(a) and (forall b. (P(b) implies a == b))
15:40:11 <earthy> and goes to bed
15:41:18 <earthy> kosmikus: where P(a) is a \in set ??
15:41:34 <mattam> a is a morphism kosmikus 
15:41:36 <kosmikus> set theory
15:41:55 <earthy> yeah, I just don't see how this applies to mattam's questions
15:42:08 <kosmikus> sorry, didn't follow
15:42:20 <earthy> as what you say is just basic set theory with properties on elements of sets
15:42:31 <earthy> and mattam was asking something about sets and functions on sets
15:43:48 <earthy> oh well, I've had >3 glasses of tripel, so I really should stop trying to do math ;)
15:43:56 <kosmikus> what you say doesn't seem to be a contradiction
15:44:17 <kosmikus> sets can be elements of sets
15:44:28 * earthy nods at kosmikus
15:44:29 <kosmikus> in fact, all elements of sets are sets
15:44:40 <earthy> in ZF set theory, yes.
15:44:48 <Marvin--> triple tripel glasses
15:45:01 <earthy> well, it's more like 4. :)
15:45:01 * Marvin-- groans at himself
15:45:21 <kosmikus> ZF as opposed to?
15:45:30 <earthy> which in this case makes for 8cl alcohol in my body, theoretically
15:45:49 <mattam> stop doing math!
15:46:11 <earthy> kosmikus: err. ;) `early formulations of set theory, the stuff that Russel built a paradox with'? :)
15:46:42 <kosmikus> ok
15:46:52 <Marvin--> well, there's a reason we don't use those formulations, you know, like...paradoxes? ;)
15:47:00 <kosmikus> anyway .. I cannot think of any other useful definition of "exists unique" right now ...
15:47:07 * earthy nods
15:47:13 <earthy> there isn't any afaik
15:47:33 <Pseudonym> As opposed to, say, Goedel-Bernays set theory.
15:48:01 <Pseudonym> Sorry, von Neumann-Bernays-Goedel
15:48:04 <monotonom> As opposed to applying set theory to people: "the set of all people in the world..."
15:48:06 <kosmikus> Pseudonym: afaik there this statement holds as well
15:48:07 <Pseudonym> http://mathworld.wolfram.com/vonNeumann-Bernays-GoedelSetTheory.html
15:48:20 <Pseudonym> Oh, OK.
15:49:16 <Pseudonym> Doesn't NBG set theory distinguish between sets and classes to avoid the Russel paradoxes?
15:49:43 <kosmikus> it does
15:49:55 <kosmikus> but iirc, you still cannot build sets of classes
15:50:15 <earthy> nope, as proper classes cannot be parts of sets given the axioms
15:50:17 <kosmikus> so every element of a set still is a set
15:50:32 <earthy> (wow, I didn't know I actually had this stored in memory anymore)
15:50:46 <kosmikus> whereas ZF and ZFC simply ignore classes
15:50:53 * earthy nods
15:51:13 <earthy> time for bed. :)
15:51:34 <kosmikus> good night, earthy
15:53:07 * Marvin-- watches SNL make fun of Christina Aguilera
15:53:30 <Pseudonym> I've never seen SNL, but does it always go for the easy targets?
15:54:08 <Marvin--> you mean, like GWB and pop singers? yeah, pretty much :P
15:54:16 <Pseudonym> OK, figured as much.
15:56:59 <Marvin--> I'm off to bed
15:57:22 <Pseudonym> Night.
16:02:16 <kosmikus> me too ...
16:02:29 <mattam> i have a hard time defining set inclusion without injection/surjection :( Got some more time to waste ?
16:03:54 <ski> f is mono <=> forall g,h.  f . g = f . h  =>  g = h
16:04:08 <ski> mono is injective in Set
16:04:20 <ski> well, almost
16:06:18 <Pseudonym> It might be easier to use the property that S \subset T (up to isomorphism) if f : S -> T has a retraction.
16:06:32 <Pseudonym> (Which implies that f is mono.)
16:06:35 <mattam> a retraction ?
16:06:57 <Pseudonym> If r . s = id
16:07:01 <ski> r is a retraction of s if r . s = id
16:07:01 <Pseudonym> Then r is a retraction of s.
16:07:07 <Pseudonym> And s is a section of r.
16:07:26 <mattam> interesting
16:08:07 <Pseudonym> If f has a retraction r, then f . g = f . h implies r . f . g = r . f . h which implies g = h.
16:08:11 <Pseudonym> Because r . f = id
16:08:38 <mattam> i see
16:10:41 <mattam> so there's no way without injection / retraction ?
16:11:05 <Pseudonym> Not in Set, I believe.
16:11:18 <Pseudonym> You could use an alternative category.
16:11:45 <Pseudonym> For example, the category SSet (just made up the name) where there is a morphism from S to T if S is a subset of T.
16:11:50 <mattam> well, the author proposes defining inclusion before injection, hence my question
16:11:59 <Pseudonym> Convince yourself that this is a category, if you like.
16:12:15 <mattam> :)
16:12:36 <ski> SSet has no terminal, right ?
16:12:56 <Pseudonym> I don't think so.  It would be the "universal" set.
16:13:01 <ski> right :)
16:13:01 <Pseudonym> Which isn't a set.  It's a class. :-)
16:13:22 <Pseudonym> I don't think it even has products.
16:13:26 <ski> no ?
16:13:35 <Pseudonym> Though I may be wrong on that.
16:13:45 <ski> is products just intersection ?
16:13:50 <ski> s/is/isn't/
16:13:53 <Pseudonym> Hmmm.
16:13:58 <Pseudonym> Let me think about that.
16:14:16 <ski> X -> A , X -> B  <=> X -> A*B
16:15:10 <Pseudonym> Guess you're right.
16:15:22 <Pseudonym> Does it have map objects?
16:15:32 <ski> i guess so
16:15:39 <ski> hmm
16:15:40 <ski> no
16:15:51 <Pseudonym> If you have the universal set, then it'd be a boolean topos, too.
16:16:28 <ski> ~A + B    union with a complement which is a class yields a class
16:16:31 <Pseudonym> No, I don't think ot does either.
16:16:41 <Pseudonym> Have map objects, that is.
16:16:47 <ski> right
16:17:15 <ski> hmm, it has initial and coproducts
16:17:25 <ski> is it distributive ?
16:17:47 <ski> A * 0 = 0
16:17:59 <ski> A * (B + C) = A * B + A * C
16:18:04 <ski> hmm, first is true
16:18:07 <Pseudonym> What is +?
16:18:12 <Pseudonym> It's not union, it's disjoint union.
16:18:25 <ski> i don't think so
16:18:44 <ski> not when morphisms are the inclusion relation
16:18:56 <Pseudonym> Oh, you're right.
16:19:14 <ski> hmm, i think the second eqn is true, too
16:19:17 <Pseudonym> Does it have coproducts, then?
16:19:27 <ski> of course
16:19:32 <Pseudonym> Oh, ye,s you do.
16:19:33 <Pseudonym> Duh.
16:19:38 <Pseudonym> So it's just union.
16:19:42 <ski> yeah
16:19:55 <Pseudonym> Yes, it's distributive.
16:20:03 <ski> this Category is almost like the category of all subsets of a given set
16:20:08 <Pseudonym> Right.
16:20:25 <Pseudonym> Except the "given set" is the universal set, kind of.
16:20:27 <Pseudonym> Only it's not.
16:20:32 <ski> right ?
16:20:38 <ski> s/?/!/
16:20:41 <Pseudonym> Also the category of subfields, subgroups etc.
16:20:48 <ski> yeah
16:21:11 <ski> so, does it have coexponentials ? ;-)
16:21:22 <Pseudonym> Oh, hang on.  Does any group have a "prime" subgroup?
16:21:29 <Pseudonym> I know that fields have a prime subfield.
16:21:42 <ski> hmm
16:21:49 <Pseudonym> I need to read more group theory.
16:21:57 <ski> i think groups can be factorized
16:22:00 <Pseudonym> This stuff makes SO much more sense when you know some basic category theory.
16:22:12 <Pseudonym> ski: Yes, but are the factorisations unique?
16:22:14 <ski> something like C_2 * C_3 = C_6
16:22:20 <Pseudonym> Up to isomorphism.
16:22:27 <ski> not sure
16:22:41 <ski> i think so, but i don't remember
16:22:48 <Pseudonym> OK, that's something to find out.
16:23:24 <ski> there were something like C_N * C_M = C_(N * M) iff N and M are relative prime
16:23:45 <ski> but i don't remember what C was :(
16:24:30 <Pseudonym> A prime group, according to mathworld, is the unique (up to isomorphism) group of prime order.
16:24:41 <ski> ok, right
16:25:15 <Pseudonym> A "simple group" is a group whose only normal subgroups are the trivial subgroup of order 1 and the improper subgroup consisting of the entire original group.
16:25:18 <Pseudonym> That sounds closer.
16:25:32 <Pseudonym> Moreover, these groups come in only five types.
16:25:36 <Pseudonym> One of which are the prime groups.
16:25:55 <Pseudonym> Thing is, this is only normal subgroups.
16:26:17 <ski> yeah, i remember the "simple" groups :)
16:26:30 <Pseudonym> So you could probably say that the normal subgroups of some group form a category.
16:26:34 <Pseudonym> Right?
16:26:36 <ski> the largest were called the "monster" group, i think
16:26:54 <ski> because it's order were very large
16:26:59 <Pseudonym> Right.
16:27:10 <ski> s/were/was/
16:27:54 <ski> i'm not sure
16:29:25 <ski> oh, i think the C stood for Cyclic group
16:29:30 <Pseudonym> Ah, OK.
16:44:29 <Smerdyakov> Does anyone have a link to a description of a simple algorithm for solving systems of linear equations?
16:45:27 <Pseudonym> How stable does it have to be?
16:45:33 <Pseudonym> Or isn't that an issue?
16:45:52 <Smerdyakov> Not an issue
16:46:09 <Pseudonym> OK.  Are you going to solve similar equations over and over again, or just once?
16:46:15 * stepcut reads 'Generalizing Monads to Arrows' .... again
16:46:53 <Smerdyakov> I'm not going to ever run the algorihtm, just use it for an analysis.
16:47:08 <Pseudonym> Doesn't have to be in Haskell?
16:47:24 <Pseudonym> http://mathworld.wolfram.com/GaussianElimination.html
16:47:25 <Smerdyakov> Doesn't have to be anything but an understandable description.
16:47:58 <Smerdyakov> That doesn't look like an algorithm to me.
16:48:05 <Pseudonym> Well it is. :-)
16:48:23 <Smerdyakov> How so? I've been there. It doesn't say how to choose which row operations to perform.
16:49:22 <Smerdyakov> Though I think I'm vaguely remembering this now from linear algebra class.
16:50:42 <Pseudonym> http://www.flupe.com/code/c++/gauss/gauss.htm
16:50:44 <Pseudonym> How about that?
16:50:55 <Pseudonym> Is it understandable?
16:52:14 <Smerdyakov> I think I remember the algorithm now, actually. Thanks.
16:52:18 <Pseudonym> OK, cool.
17:20:30 <Pseudonym> ;who
17:20:32 <Pseudonym> Whoops.
17:22:10 <Smerdyakov> That was pretty bad.
17:22:43 <Pseudonym> Two mistakes.  First. ; instead of /, secondly, typed enter too early.
17:22:47 * Pseudonym karnt tipe
17:26:32 <monotonom> All mistakes are bisimilar to typing enter too early.
17:55:01 * Smerdyakov always gets mixed up which coordinate in a matrix cell reference (in math) is the row and which the column. :\
17:56:30 <monotonom> heh
19:08:16 <amgine2> hmmm
19:08:21 <amgine2> i'm having a hard time understanding
19:08:27 <amgine2> how to work with getPremissions
19:09:36 <amgine2> could someone help me with that ?
19:10:28 <ski> hmm
19:10:29 <amgine2> data Permissions      
19:10:29 <amgine2> Constructors     
19:10:29 <amgine2> Permissions          
19:10:29 <amgine2> readable, writable, executable, searchable :: Bool
19:10:33 <amgine2> is what is returned
19:10:37 <amgine2> how can i use it ?
19:10:38 <amgine2> so far i have
19:10:53 <amgine2>  = do perms <- (getPermissions f) 
19:10:53 <amgine2>                                         chkPerms perms
19:10:53 <amgine2>                                         where chkPerms (r:w:x:s) = logMessage ("...deleteing " ++ (show w))
19:11:00 <amgine2> i wish to see if the file is writeable
19:11:03 <amgine2> i.e. can be deleted
19:11:31 <ski> in what module is this ?
19:11:39 <amgine2> brb
19:11:47 <amgine2> System.Directory
19:12:06 <amgine2> i got it to show the result of getPermis.. and it's {read = True, write = True, etc...}
19:12:22 <amgine2> i'm not sure how to read that
19:13:00 <amgine2> or extract the info i need 
19:13:02 <amgine2> that's what i mean
19:13:08 <ski> doesn't they just tell the perms of the file or dir ?
19:13:18 <ski> what info do you need ?
19:13:27 <amgine2> if it's writeable
19:13:30 <amgine2> i.e. able to be deleted
19:13:54 <ski> so check if field writable contains True, i guess
19:14:00 <amgine2>      delCache (f:files)   = do z <- (getPermissions f) 
19:14:01 <amgine2>                                         logMessage ("...deleteing " ++ (show z))
19:14:01 <amgine2>                                         
19:14:01 <amgine2>                                         
19:14:09 <amgine2> i know but what kind of patter matching do i use ?
19:14:19 <ski> you do know where ghc's doc for this is ?
19:14:39 <amgine2> Permissions {readable = True, writable = True, executable = True, searchable = False}
19:14:47 <amgine2> i'm not sure what you are asking
19:15:02 <amgine2> is that a list ?
19:15:06 <ski> i mean http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Directory.html
19:15:08 <amgine2> what are those {} brackets
19:15:09 <amgine2> yeah i got that
19:15:13 <ski> records
19:15:14 <amgine2> i've been using that
19:15:28 <ski> records = structs, if you know C
19:16:11 <amgine2> hmmm like foo.age
19:16:16 <amgine2> or foo.sex ?
19:16:19 <amgine2> in C
19:16:22 <amgine2> which i forget all now
19:16:51 <ski> writable permissions  instead of permissions.writable
19:17:03 <amgine2> ok
19:17:20 <amgine2> so it would be z <- getPermissions
19:17:29 <amgine2> if (z == writable permission) ?
19:18:02 <amgine2> i'm not sure how to pattern match
19:18:07 <amgine2> or extract the info i need
19:18:13 <amgine2> btw hi ski
19:18:14 <ski> if writable z
19:18:19 <amgine2> hmmm
19:18:26 <ski> hi amgine2 ! :)
19:18:30 <amgine2> lol
19:18:31 <amgine2> :)
19:18:57 <amgine2> if writable z ?
19:19:04 <amgine2> but that kind syntax is confusing
19:19:08 <amgine2> how does haskell know what i'm asking
19:19:15 <amgine2> writable is not a constructor ?
19:19:27 <ski> do perms <- getPermissions
19:19:33 <ski>    if writable perms
19:19:37 <ski>       then
19:19:38 <amgine2> i understand
19:19:41 <ski>         ...
19:19:43 <ski>       else
19:19:50 <ski>         ...
19:20:04 <amgine2> so writable is a function that takes permissions and checks it's fields ?
19:20:38 <amgine2> i understand the code
19:20:54 <amgine2> but i just wish to understand how we can use just writable perms as a bool ?
19:21:17 <amgine2> from this info in the doc
19:21:18 <amgine2> data Permissions      
19:21:19 <amgine2> Constructors     
19:21:19 <amgine2> Permissions          
19:21:19 <amgine2> readable, writable, executable, searchable :: Bool
19:21:46 <ski> writable is a selector/deconstructor/projector
19:21:58 <amgine2> ?
19:22:11 <amgine2> Permissions is a constructor
19:22:18 <ski> "<amgine2> writable is not a constructor ?"
19:22:19 <amgine2> that has values of readable, writable, ...
19:22:48 <amgine2> ski i would figure it's a value of the new datatype ?
19:22:56 <amgine2> ski or am i way off ?
19:23:06 <ski> yeah you can see it like that
19:23:14 <ski> writable :: Permissions -> Bool
19:23:21 <amgine2> ohhh
19:23:26 <amgine2> where does it say that ?
19:23:29 <amgine2> in the docs ?
19:23:54 * ski thinks that's implicit in the record type definition
19:24:04 <amgine2> hmmm
19:24:13 <amgine2> what do you mean ?
19:24:27 <amgine2> as in we supposed to understand that ? or it's not coded ?
19:25:09 <ski> if we say
19:25:42 <ski> data Color = Color {red :: Double,green :: Double,blue :: Double}
19:26:13 <ski> then the names red,green,blue are selectors (/projections/deconstructors)
19:26:34 <ski> so they get type   WholeRecordType -> FieldType
19:26:49 <ski> in this case all of gets type  Color -> Double
19:26:54 <ski> ok ?
19:27:18 <amgine2> ok
19:27:22 <ski> s/all of/all of them/
19:27:27 <amgine2> by WholeRecordType i.e. struct in C
19:27:32 <ski> yeah
19:27:36 <amgine2> ok
19:27:38 <ski> more or less
19:27:39 <amgine2> i follow that
19:27:49 <ski> though there are some shortcuts
19:28:14 <ski> one color is e.g.  Color 0.2 0.7 0.5
19:28:38 <ski> so the Color constructor has 3 args, namely the fields, in the order given
19:28:44 <ski> but we can write instead :
19:29:06 <ski> Color {red = 0.2, green = 0.7, blue = 0.5}
19:29:11 <amgine2> ok ok
19:29:11 <ski> or even :
19:29:25 <ski> Color green = 0.7, blue = 0.5, red = 0.2}
19:29:30 <ski> (i.e. in other order)
19:29:36 <amgine2> i see
19:29:40 <ski> s/Color/Color {/
19:29:40 <amgine2> so now if i do
19:29:52 <amgine2> z = Color
19:29:55 <amgine2> green z
19:29:59 <amgine2> would return value of green ?
19:30:04 <ski> yes
19:30:07 <amgine2> thanks
19:30:08 <ski> also
19:30:10 <amgine2> i hope i remmember that
19:30:12 <amgine2> yeah ?
19:30:21 <ski> z = Color {green = 0.7, blue = 0.5, red = 0.2}
19:30:26 <ski> then
19:30:35 <ski> z {blue = 0.0}
19:30:43 <ski> evaluates to
19:30:55 <ski> Color {red = 0.2,{green = 0.7, blue = 0.0}
19:30:57 <ski> so
19:31:12 <ski> aRecord {someFieldbindings}
19:31:27 <ski> gives a copy of aRecord, but with some fields changed
19:31:43 <amgine2> ok
19:31:49 <ski> that can be useful if one has many fields, but only want to change a few
19:31:56 <amgine2> yeah
19:32:03 <amgine2> i wish this before for my last school work
19:32:05 <amgine2> really neat
19:32:16 <Jerub> oooo.
19:32:23 <Jerub> keyword args, haskell style.
19:32:24 <ski> sorry ?  "i wish this before for .."
19:32:39 <amgine2> ski nothing thinking outloud
19:32:49 <amgine2> like i said i hope i remember that
19:32:57 <amgine2> cause it simpilifes few things
19:33:35 <ski> Jerub : but unfortunately, one have to define each record type in advance. so it's heavy-weight records  (as opposed to light-weight, in the same way that tuples are light-weight)
19:33:44 <amgine2> if i specify -package foo and foo is not used when compiling will it be linked orno ?
19:34:03 <ski> hmm, not sure
19:34:48 <amgine2> k
19:34:50 <amgine2> just curious
19:35:17 <ski> mm
19:35:48 <amgine2> no worries
19:35:52 <amgine2> thanks for the hlelp ski
19:36:04 <ski> no problem :)
19:36:13 <amgine2> how old are you if i can ask
19:36:18 <ski> hmm
19:36:31 * ski recalls what years it it now
19:36:36 <amgine2> haha
19:36:44 <amgine2> nevermind
19:36:46 <ski> have i had bithday yet ?
19:36:50 <ski> hm
19:36:59 <ski> ok, i think i'm 23
19:37:13 <ski> and you ? :)
19:37:25 <amgine2> 22
19:37:28 <amgine2> lol
19:37:39 <ski> ok
19:43:07 <Smerdyakov> What a weird! I am 22 also!
19:43:25 <amgine2> <hears twilight theme>
19:46:11 <Pseudonym> I feel somewhat relieved that shapr is older than I am.
19:46:30 * amgine2 Drinks to that
19:46:41 <amgine2> question
19:46:45 <amgine2> what do you guys you haskell for ?
19:47:05 <Smerdyakov> Pseudonym, even in dog years?
19:48:03 <Jerub> amgine2: parsing!
19:48:35 <anduril1> amgine2: attracting females
19:48:39 <amgine2> hha
19:48:46 <amgine2> anduril1 : preety much the same reason for now
19:48:57 <amgine2> i just dig it cause it's high level
19:49:10 <anduril1> I wish I knew girls that found Haskell sexy
19:49:14 <amgine2> let's you do the programing instead of the little things you need with other languages
19:50:06 <Pseudonym> Yes, even in dog years.
19:50:14 <Pseudonym> It's a monotone mapping.
19:50:47 <amgine2> like work projects ?
19:50:49 <amgine2> or resarch ?
19:50:50 <Smerdyakov> Oh, so you don't know about the Dog Years Singularity.
19:51:01 <Pseudonym> If it's any consolation, some girls are okay with it.  My wife let me name my daughter after a functional language.
19:51:12 <amgine2> Pseudonym nahh ?
19:51:17 <amgine2> what name ?
19:51:20 <Pseudonym> Miranda
19:51:29 <anduril1> pseudonym: excellent
19:51:38 <Riastradh> That's cheating!  Miranda isn't _just_ the name of a functional language.
19:51:46 <Riastradh> Now, if you'd named her 'ML' or something...
19:51:48 <ski> i think there are girls named Charity, too
19:51:54 <anduril1> if you named your daughter Scheme
19:51:57 <anduril1> or LISP
19:51:59 <Pseudonym> ski: Yes, that's a puritan name.
19:52:00 <Smerdyakov> Riastradh, "Melinda Lee" maybe.
19:52:13 <Pseudonym> Along with Faith and Hope.
19:52:19 <ski> and Joy, of course
19:52:30 <Pseudonym> Joy is her middle name.  Did I not mention that?
19:52:38 <ski> no, not that i remember
19:52:39 <Pseudonym> :-)
19:52:59 <Pseudonym> Haskell is a male first name.
19:53:38 <ayrnieu> My first pet, a pretty Siamese cat, had the name 'Miranda'.
19:54:00 * ski wonders if there's some pet somewhere called C++
19:54:05 <Riastradh> You should change her last name to 'Schonfinkel.'
19:54:28 <Pseudonym> I was thinking Whitehead.
19:54:38 <ski> is that a language ?
19:54:47 <Pseudonym> No, it's a mathematician.
19:54:55 <ski> mm, meknows
19:55:11 <Pseudonym> Figured, but it was for the benefit of the peanut gallery.
19:55:11 <ski> (Alfred or something ..)
19:55:18 <Pseudonym> Alfred North
19:55:22 <ski> yeah
19:56:01 <Pseudonym> If we have an boy in the future, I'm thinking Haskell Brainfuck.
19:56:36 <ski> hmm, what does Befunge mean ?
19:56:38 <Pseudonym> Dylan?  That'd work.
19:56:51 <Riastradh> Dylan is too imperative.
19:56:53 <Pseudonym> Leda isn't too bad, either.
19:56:58 <Pseudonym> As a name, I mean.
19:57:16 <Smerdyakov> Young Leda was petrified around swans...
19:57:36 <ski> is that a fairy tale ?
19:57:36 <Pseudonym> Haskell Erlang
19:58:19 <Smerdyakov> Yes, if you count Greek mythology in there. (or one of them other mythos, perhaps)
19:58:36 <Pseudonym> Oh, Isabelle is a language, too.
19:58:41 <Pseudonym> Isabelle Ruby.
19:58:54 <Smerdyakov> Leda was raped by the chief god in swan form.
19:59:30 <Pseudonym> I also thought of Ada Perl.
19:59:37 * ski thinks of a swedish fairy tale named something like "Lilla ?? och laonga Leda"
20:00:05 <Smerdyakov> Damn. Why can't the Swedish talk like NORMAL people?
20:00:22 <Pseudonym> Smerdyakov: You mean Norwegians?
20:00:36 <ski> whaat ? you're complaining about my speech ?  :)
20:00:47 <Pseudonym> Oh, you mean Greeks.
20:00:49 <Riastradh> Speech?  What speech?  All I can detect is text...
20:01:01 <ski> Pseudonym : whois norwegians here ?
20:01:06 <Pseudonym> Riastradh: According to the US COnstitution, text is speech.
20:01:25 <Riastradh> But ski doesn't abide by the US Constitution, so it's moot.
20:01:46 <ski> Riastradh : isn't the word 'talk' also associated with vibrations and sound ?
20:02:09 <Pseudonym> Smerdyakov brought up "talking".
20:02:33 <Smerdyakov> And now I am to be pilloried for it.
20:02:48 <ski> heh
20:04:20 <Pseudonym> Oh, woohoo!
20:04:28 <Pseudonym> "A New Kind of Science" is available online.
20:05:48 <Smerdyakov> Cool! I knew online toilet paper would become reality in my lifetime.
20:05:54 <Pseudonym> :-)
20:06:16 <Pseudonym> Much as I feel the overwhelming urge to do so, I can't bring myself to call Wolfram a kook.
20:10:00 <Smerdyakov> I don't feel the urge to do that. I feel the urge to read something that doesn't feel like a chore.
22:16:55 * shapr awakens
22:17:21 <ski> mornin' shapr :)
22:17:32 <Pseudonym> G'day.
22:17:34 <shapr> god morgon ski
22:17:38 <shapr> g'day Pseudonym 
22:18:02 * shapr pulls the latest patches from PHI
22:18:07 <ski> Pseudonym : and good day to you also ..
22:22:06 * shapr builds the haskelldb nightly cvs snapshot
22:26:45 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!","lambdabot 2.0 released","related channels #darcs #haskell.se"]'
22:26:45 --- topic: set by shapr on [Mon Mar 15 02:35:22 2004]
23:11:14 * ski smiles
23:38:16 * shapr boings
