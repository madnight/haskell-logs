00:04:02 <shapr> yeehaa!
00:05:34 <Jerub> @yow
00:05:35 <betabot> I just bought FLATBUSH from MICKEY MANTLE!
00:07:48 <Jerub> shapr: I said earlier, but you were idle. within 12 hours of me raising that I've been having rsi problems, I had an occupational health+safety guy inspecting my workstation.
00:08:34 <Jerub> he gave me gel wrist rests, seating advice, and he's looking at getting me a better desk arrangement (my desk is too low+small apparently).
00:25:24 <shapr> Jerub: yay! that's good to hear!
00:25:30 <shapr> ok, back to migrationsverket AGAIN.
02:31:45 <Jerub> shapr: I've moved back to ratpoison
02:33:41 * Cale is away: sleeping.
02:49:42 <ozone> uo
02:49:45 <ozone> yo, even
03:07:00 <shapr> y0
03:11:10 <Lunar^> y0
03:11:24 <shapr> wassup?
03:12:27 <shapr> Jerub: I personally prefer ion2, but switching to less mousing will help your wrists, so it's good.
03:12:42 <Lunar^> shapr: Working on the scheduler again
03:12:58 <Lunar^> shapr: I would be glad to understand why this deadlock suddently
03:13:33 <shapr> sadly, I cannot help there.
03:13:58 <Lunar^> Maybe I should change the way I'm currently taking
03:14:29 <Lunar^> Each time we schedule, run the interrupt handlers
03:29:42 <Jerub> odd.
03:29:50 <Jerub> I've gotta figure out where I'm getting all these web hits from.
03:34:13 <Lunar^> Eureka !
04:12:00 <TripleDES> exit
04:12:06 <TripleDES> ups
04:12:55 <Jerub> ;)
04:13:09 <Jerub> TripleDES: I recommend using control-d instead of exit if you're using unix terminals.
04:18:46 <TripleDES> I tried to close a xterm but I'm using "focus follows mouse" so the pointer was on xchat not on xterm...:)
04:19:06 <Jerub> TripleDES: I guessed as such.
04:19:43 <Jerub> TripleDES: if you used control-d (which sends an 'end-of-file' character) you wouldn't have had that problem, and you'd have 3 less keypresses.
04:19:47 <Jerub> ;)
04:20:12 <TripleDES> yeah it's a good advice :)
06:15:56 <shapr> yow!
06:16:08 <SyntaxNinja> @yow
06:16:09 <betabot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB CHOP!!
06:16:16 <SyntaxNinja> ohno!
06:16:43 <shapr> Lunar^: you found the scheduler problem?
06:20:18 <shapr> greetz kowey 
06:20:25 <kowey> hi shapr, hi room
06:20:45 * shapr looks around for that room guy everyone talks about
06:21:03 <shapr> hi adept 
06:21:12 <kowey> like my friend who wanted to create a store called "The Shop"
06:21:19 <kowey> so that everyone could take their car to it
06:21:29 <kowey> a garage, i meant
06:21:59 <shapr> seems like a good name to me
06:22:52 <kowey> buddies and i were also thinking of forming "The Wrong Band" and crashing other bands' gigs
06:25:01 <kowey> ... anyway, does anybody use alex?
06:25:13 <Lunar^> shapr: Yes !
06:25:17 <shapr> Lunar^: yay!
06:25:38 <Lunar^> shapr: My Haskell code is still locking itself somewhere, but the scheduler doesn't report any deadlock anymore
06:25:49 <Lunar^> shapr: It's quite simple, I forgot what a 'lock' was
06:25:49 <shapr> that's an improvement
06:26:17 <Lunar^> shapr: The scheduler has a lock in order to be able to modify it's structure safely
06:26:54 <Lunar^> shapr: This lock is only used in PAR, SMP, GRAN, or THREADED implementations, otherwise, the macro is not expanded
06:27:20 <Lunar^> shapr: But, I was modifying the scheduler structures within my interrupt handler
06:28:08 <Lunar^> shapr: So, scheduler lock = disabling interrupt
06:32:40 <kowey> yay independent me!
06:32:48 * kowey vows never to put a * in a lex file again
06:34:22 <shapr> no more stars?
06:34:32 <shapr> oh, you've found alex?
06:34:37 <kowey> no more terminating stars
06:34:47 <kowey> i was going to ask if it was normal to get an infinite list of tokens :-)
06:36:31 * shapr drops a spoon
06:38:29 <earthy> `there is no spoon'
06:38:35 * SyntaxNinja kills!!!!
06:38:40 <shapr> aiiee!
06:38:41 * SyntaxNinja just upgraded gaim
06:38:46 <SyntaxNinja> not crashing so far ;)
06:38:51 * shapr upgrades his spoon to a spork
06:39:34 <SyntaxNinja> shapr: did someone really think you were a bot?
06:39:38 <shapr> yes
06:39:41 <shapr> possibly two someones
06:39:55 <kowey> because of your consistent greetingness?
06:40:04 <shapr> yes, that's it.
06:45:44 <kowey> i have an uncanny ability to shoot myself in the foot with regular expressions
06:46:03 <shapr> so do most people.
06:47:32 * Marvin-- sighs
06:47:36 <Marvin--> over 170 dead so far
06:47:43 <Marvin--> damn it
06:48:44 <shapr> yah, it's bad shit :-(
06:50:35 * Lunar^ just found where the Haskell bug came from
06:50:40 <shapr> where?
06:54:38 * Marvin-- giggles at http://www.99-bottles-of-beer.net/
06:57:56 <Lunar^> shapr: See IRCPastePage
06:58:19 <Lunar^> shapr: between "peek" and waitNextInterrupt, if an interrupt happens, I do not see it
06:58:43 <shapr> ah, I see.
06:59:19 <shapr> what can you do about that?
07:00:28 <Lunar^> shapr: think :)
07:01:19 <Lunar^> change "waitNextInterrupt" to make it renable the IRQ
07:01:25 <shapr> the way I remember it, interrupts are masked when one is being handled
07:01:37 <Lunar^> I'm handling them asynchronously
07:02:02 <shapr> so, the interrupts are never masked, you just pull the next one out of the queue and handle it?
07:03:02 <Lunar^> shapr: I'm cheating => the C irq_handler() disable the IRQ and I re-enable it within Haskell code
07:03:25 <shapr> ah
07:04:21 <tooki> joho
07:04:31 <shapr> hei tooki, puhutko suomea?
07:04:51 <tooki> uhhm , ok ?
07:04:58 <shapr> guess not :-)
07:05:05 <shapr> tooki sounds like a finnish name to me.
07:05:33 <tooki> yep something like that
07:05:49 <tooki> someone told me to use BDTs
07:05:53 <shapr> gutentag tooki, wie geht es?
07:06:12 <shapr> maybe guten abend is better.
07:06:12 <tooki> he da hat aber einer über nacht deutsch gelernt
07:06:13 <tooki> ;)
07:06:49 <tooki> no, gutentag is right
07:06:54 <shapr> ok, whew
07:07:06 <tooki> congratulations 
07:07:11 <shapr> I can't speak much german.
07:07:21 <shapr> ich habe keine ahnung
07:07:34 <tooki> i almost thought you were geramn
07:07:42 <shapr> nope, I'm from Alabama!
07:08:08 <tooki> alabama, thats the chick from "true romance"
07:08:09 <shapr> I can muddle along in french, and my swedish is almost up to conversational
07:08:10 <tooki> ;)
07:08:30 <shapr> I'm fluent in southern drawl. Y'all come back now!
07:08:53 <tooki> "ich habe keine ahnung" is all i can say in french
07:09:02 <shapr> http://www.cs.bris.ac.uk/%7Ebradley/publish/bdd/index.html
07:09:16 <shapr> je ne sais jamais!
07:09:22 <tooki> thx
07:09:27 <tooki> ??
07:09:41 <shapr> "I never know"
07:10:03 <shapr> how do you say "jag har ingen aning" in french?
07:10:11 <shapr> that was the swedish form btw, very similar.
07:10:26 <earthy> `ik heb geen idee'
07:10:36 * shapr grins
07:11:00 <shapr> this sounds like a good thing to add to lambdabot, a plugin that can say "I have no idea!" in many languages.
07:11:18 <shapr> then we can ask lambdabot questions like, what's the capital of Assyria?
07:11:30 <earthy> and then parameterise it by nick, so that it responds in the correct language ;)
07:11:36 <shapr> ohh, that would be smooth.
07:12:00 <shapr> we could rewrite lambdabot in Helium so it uses the templated error responses
07:12:34 <SyntaxNinja> smoove
07:12:53 <SyntaxNinja> shapr: is there a dict pluggin?
07:13:13 <shapr> there is
07:13:22 <shapr> @wn jacinthe
07:13:23 <betabot> No match for "jacinthe".
07:13:26 <shapr> @wn jacinth
07:13:27 <betabot> *** "jacinth" wn "WordNet (r) 2.0"
07:13:27 <betabot> jacinth
07:13:27 <betabot>      n : a red transparent variety of zircon used as a gemstone [syn:
07:13:27 <betabot>           {hyacinth}]
07:13:44 <shapr> @listcommands dict
07:13:44 <betabot> Module dict provides the following commands: ["dict","dict-help","all-dicts
07:13:44 <betabot> ,"devils","easton","elements","foldoc","gazetteer","hitchcock","jargon"
07:13:44 <betabot> "lojban","prelude","vera","web1913","wn","world02"]
07:14:29 <tooki> @wn devils
07:14:30 <betabot> No match for "devils".
07:14:39 <shapr> @devils magnet
07:14:40 <betabot> *** "MAGNET" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993
07:14:40 <betabot> "
07:14:40 <betabot> MAGNET, n.  Something acted upon by magnetism.
07:14:49 <shapr> @devils magnetism
07:14:50 <betabot> *** "MAGNETISM" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15
07:14:50 <betabot> 1993)"
07:14:50 <betabot> MAGNETISM, n.  Something acting upon a magnet.
07:14:51 <betabot>     The two definitions immediately foregoing are condensed from the
07:14:53 <ham> hiho
07:14:53 <betabot> works of one thousand eminent scientists, who have illuminated the
07:14:55 <betabot> subject with a great white light, to the inexpressible advancement of
07:14:57 <betabot> human knowledge.
07:15:27 <shapr> gutentag ham[ster] 
07:16:06 <tooki> howdy ham[ster]
07:16:19 <tooki> what language is "hwody" ?
07:16:22 <tooki> howdy
07:16:26 <shapr> cowboy :-)
07:16:29 <ham[ster]> :)
07:16:57 <[super]toki> jk
07:16:58 <shapr> southern USA, from texas to the further southwestern parts.
07:17:24 <shapr> of course, howdy isn't used so much in California, I think "Â¿hola, como est as?" is more common there nowadays.
07:17:37 <[super]toki> i think it meant "howdy" => "how dy" => "how are you"
07:17:43 <shapr> I agree
07:17:45 <earthy> tudo bem, shapr, tudo bem. :)
07:17:53 <shapr> navigaÃ§ao!
07:18:22 <[super]toki> salute, amices !
07:18:48 <[super]toki> (bad latin)
07:18:56 <shapr> better than me
07:19:10 <shapr> illegitimus non carborundum!
07:19:38 <[super]toki> i must consult a dict for that
07:19:55 <shapr> "don't let the bastards grind you down"
07:20:24 <[super]toki> mk
07:20:40 * tooki turnedf godmode off
07:20:53 <shapr> what are you using BDT for?
07:21:10 <tooki> shapr, do you know other pages about BDTs
07:21:28 <tooki> im trying to solve SAT-problems
07:21:48 <Heffalump> BDTs?
07:22:14 <tooki> i will be the god of computer science, if i can do that in poly time ;)
07:22:30 <earthy> tooki: not the god, but famous. :)
07:22:46 <tooki> ok, half-god
07:24:03 <tooki> because i'm would remain human, but my mind would be godlike ....
07:25:22 <tooki> Heffalump, u told me to use BDTs. now i thought about it, and i think
07:25:28 <Heffalump> BDDs.
07:25:35 <tooki> oops
07:25:36 <Heffalump> cos they're not trees :-)
07:26:01 <tooki> BDGs, cause they are graphs *g
07:26:06 * Heffalump likes BDDs. Although the people who solve hard-core SAT problems have gone away from them a little bit, I think.
07:26:10 <shapr> tooki: if you want to become one of the giants of computer science, I suspect you're in the right place for mental advancement.
07:26:30 <tooki> i think so
07:27:12 <earthy> SATsolvers still do use BDDs for parts of the formulas, right?
07:27:23 <SamB> wouldn't god be able to do SAT-problems in constant time?
07:27:27 <tooki> since i use functional programming, ican implement complex algos very quickly, but for real use i have to recode it in c++
07:27:42 <earthy> but, yeah, it's not exclusively bdd's anymore
07:27:57 <tooki> SamB he does it in negative time
07:28:05 <shapr> why do you have to recode in C++?
07:28:26 <shapr> can't you just rewrite any really CPU intensive parts in C++ and wrap them with the FFI?
07:28:26 <SamB> tooki: if you recode in C++, you have to do your own optimizations!
07:28:35 <SamB> that can't be good...
07:28:35 <tooki> haskell's too slow, even after compilation with optimization
07:29:09 <shapr> right, so, use Haskell for everything except the inner loop.
07:30:03 <earthy> which is exactly what he's coding, if I understand correctly
07:30:06 <tooki> me algo has many time-intensive parts, and there's no point for coding just the main loop in haskell
07:30:46 <shapr> ok
07:30:49 <tooki> im really considering to code a haskell-compiler that can compete with c
07:31:05 <tooki> but thats just a dream ;)
07:31:22 <SamB> tooki: why don't you just figure out more optimizations for GHC?
07:31:56 <tooki> i think i allready did. i think it is a general problem with the löanguage
07:33:01 <tooki> in haskell i cannot modify data inplace, i always pass back a modified copy
07:33:34 <shapr> haskell does modify data in place when it's safe to do so.
07:33:48 <SamB> you can too... you just need to do it in a monad
07:33:51 <tooki> the compiler should recognize, that the old datum isnt used anymore and e.g. rcycle the oild object
07:34:00 <Heffalump> it can't always do that, though
07:34:30 <tooki> sry, some missprints 
07:34:52 <tooki> are you talking of STRefs ?
07:35:06 <tooki> havent tried that yet
07:35:22 <shapr> I liked skew's idea of lazy binary streams, that could give the benefits of both String and PackedString
07:37:35 <tooki> if i can generate a BDD of a SAT-Problem, then i just have to asscend from a leaf that has value 1
07:38:21 <tooki> an that can be done in poly time. But the generation of that BDD should take expo. time
07:40:08 <tooki> i need a paper about optimization and about combining BDDs (e.g. by logical and)
07:42:10 <tooki> next, i'm trying to solve SAT with neurons ;)
07:43:51 <tooki> can STRefs be used to replace data inplace ?
07:45:48 <tooki> anyone talking to me ?
07:46:21 <shapr> who are you anyway? ;-)
07:46:28 <earthy> tooki: generating BDD's can not only take exponential time but also exponential space. ;)
07:46:30 <shapr> I'm installing debian
07:46:43 <tooki> earthy right
07:47:16 <Heffalump> not in the size of the input BDDs
07:47:31 <Heffalump> (but it can in the number of variables in the BDD)
07:47:41 <tooki> maybe they can be optimized, so that they are exponential in another basis,e.g. not 2^n but 1.22^n
07:47:55 <Heffalump> sure, just multiply n by log 2/log 1.22
07:47:57 <SamB> I considered saying I didn't think neurons would do well on this kind of problem
07:49:20 <tooki> i'm creating a network that calculates the bool value of a SAT-Formula for a given input
07:50:49 <tooki> then i consider it a a dynamic regulating system, and i put a "voltage" of 1 on the output, and i hope that the solution stabilizes in the inputs
07:51:08 <tooki> after some time
07:51:22 <tooki> a bit freaky
07:52:15 <tooki> shapr, i'm sitting in an inet-cafe, and my time is short, and so my questions sometimes have no conneciotn to eathother
07:52:32 <shapr> ok
07:53:10 <tooki> do you think debain is better that redhat ?
07:53:15 <shapr> I do
07:53:24 <shapr> lots better
07:53:24 <SamB> yes, debian is better than redhat!
07:53:32 <tooki> for security reasons ?
07:53:45 <shapr> no, for usability reasons
07:53:55 <SamB> I switched because people in #python kept telling me to apt-get this and apt-get that
07:54:05 <Heffalump> yyou can get apt-get for RH
07:54:06 <shapr> I switched because I tried to upgrade redhat 5.2
07:54:12 <Heffalump> but Debian is much nicer, in general
07:54:27 <Heffalump> proper upgrade path between distros, and better quality packaging system and packages
07:54:54 * earthy switched to RedHat because his Slackware was getting long in the tooth and a pain to upgrade
07:54:54 <tooki> debian can be configured be hand in the scripts.
07:54:59 <earthy> s/RedHat/Debian
07:55:07 * earthy needs more Tea
07:55:24 <tooki> s/be/by
07:56:04 <tooki> and most distros overwrite you handcrafted scripts-edits during the bootprocess
07:56:09 <SamB> yeah, debian is only slightly painful for me to upgrade, and none of the pain is debian's fault, except perhaps for not keeping the package lists under version control... its just that 56k is slow ;-)
07:56:46 <shapr> most debian scripts have two areas, one for the automagical configuration of the packages, and one for your custom additions.
07:56:47 <tooki> and redhat is more pain to upgrade ?
07:57:10 <earthy> RedHat does *not* have a viable upgradepath for major revisions
07:57:56 <tooki> and so you have to backup the homes and delete you system before upgrading a redhat distro ?
07:57:59 <shapr> I have one hard drive that had slink on it, and now has sid
07:58:04 <shapr> without reinstalling
07:58:17 <shapr> I've forgotten how many major revisions were between.
07:58:17 <Heffalump> I've tended to upgrade Redhat in place using apt-get for RH or rpm itself, but you have to be really careful.
07:59:12 <tooki> ok, gotta go now
07:59:14 <shapr> cya
07:59:20 <tooki> bye
07:59:28 <shapr> was there anything between slink and potato?
07:59:33 <shapr> I don't *think* so.
07:59:42 <shapr> slink, potato, woody, sid?
07:59:43 <SamB> shapr: don't bother trying to remember how many between sid and something else... it will change anyway!
08:01:02 <earthy> slink, potato, woody, sarge, sid
08:01:09 <SamB> I started at woody
08:01:09 <earthy> sid will always be unstable, IIRC
08:01:26 <SamB> but there were directories called potato on the disks, iirc
08:02:08 <SamB> yes, sid is always unstable
08:02:24 * earthy started at debian 1.3 or somesuch
08:02:27 <earthy> might have been 1.2 even
08:03:53 * SamB gives aptitude the green light
08:05:31 * SamB wishes he didn't know how much faster this would be at a college
08:05:50 * earthy gives SamB a nice ADSL link
08:06:43 <SamB> earthy: how long will that take to install?
08:09:21 <earthy> depends on where you live. :)
08:10:11 <SamB> I live in Upper Darby
08:10:37 <SamB> accross a creek from Philadelphia
08:11:13 <earthy> well, it'll take until the local phonecompany provides dslam-access to their local loops
08:33:34 <SamB> and you said you were paying for this, right?
08:34:45 <SamB> fortunately, I'm going to actually be a college student soon enough
09:42:09 <shapr> ok, if all goes well, ScannedInAvian.org should be back up sometime tomorrow.
09:42:09 <Marvin--> huzzah
09:42:09 <shapr> with another 10gb and another 256mb of ram too
12:02:19 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!"]'
12:02:19 --- topic: set by Marvin-- on [Wed Mar 10 13:27:20 2004]
12:02:19 --- names: list (clog Si vorpal `John cptchaos stepcut tic raver ozone Hipo maihem SamB ski SyntaxNinja adept Marvin-- Jad[asc][Away] mattam ecraven rt elmex viblo Lemmih Arnia galority skew bring malik liiwi norpan skylan whee earthy jasonw el_diego CrewdenX shapr betabot _joey_ forester noclouds LittleDan jameson YveDeLarc opet esap Heffalump _rubix _Codex pattern andersca blackdog Etaoin keverets isomer mgoetze Vulpyne det Lunar^ smkl Riastradh cmeme)
12:02:19 --- names: list (ludde polli dennisb jlouis edwinb stpeter ibid emu Jerub Taaus juhp eivuokko wagle Igloo kosmikus|away jagular djw gdsx jiwon shrimpx)
12:02:42 <ski> hmm
12:04:17 <ski> we must be able to convert (finite) list of indices to Int, for this to work
12:04:20 <Heffalump> Si: ok, so first you need to define Ord [Int]
12:04:31 <Heffalump> how would you suggest doing that?
12:05:11 <Si> assuming a column wise expansion
12:05:20 <ski> Heffalump : isn't [Int] already in Ord ?
12:05:38 <Heffalump> errm, maybe. Ignore that for now :-)
12:05:50 <Si> yes
12:05:50 <ski> Heffalump : (by the general instance Ord a => Ord [a])
12:06:06 <Heffalump> (the lexicographic instance would imply that there were an infinite number of lists inbetween any two distinct lists, thus making Ix rather hard...)
12:07:43 <Si> rather hard or impossible?
12:07:43 <ski> hmm, should Ix use the same ordering as Ord ?
12:07:43 <ski> Heffalump : hmm, perhaps if we ignore the infinite lists, that wouldn't be a problem ?
12:07:43 <Heffalump> ski: no, there are still an infinite number of *finite* lists between any two distinct lists
12:07:43 <ski> ok
12:07:45 <Heffalump> e.g. between [0] and [1] is [0,0], [0,0,0], [0,0,0,0] ....
12:07:52 <Heffalump> si: impossible, I think
12:08:23 <ski> so Si really wants a dependently typed list (i.e. with size encoded in type)
12:08:45 <ski> one can do that with type class hackery, i think
12:08:49 <Heffalump> well, you could assume that you would only ever use lists of the same length together, without explicitly encoding that in the type
12:09:00 <Si> that's what I want
12:09:03 <Heffalump> in that case, what would your Ord instance be?
12:09:09 <Heffalump> the lexicographic one still doesn't work:
12:09:25 <Heffalump> between [0,0] and [1,0] are [0,1], [0,2], [0,3], ...
12:09:34 <Heffalump> oh, there are only finitely many Ints, so that's actually OK.
12:09:39 <Heffalump> But it may not be what you want.
12:09:53 <Si> it is
12:10:07 <ski> hmm, i'm not sure
12:10:18 <Si> I don't care if it doesn't _really_ work for high up values, as long as Haskell thinks it does
12:10:42 <ski> Heffalump : my Ord instance for dependently typed version ?
12:11:14 <Heffalump> ski: yes
12:11:46 <ski> Si : hmm, perhaps it doesn't work good for your small values, either ..
12:11:46 <Heffalump> si: wdym by "high up values"?
12:12:51 <Heffalump> note that neither [0,0] or [1,0] are particularly large.
12:12:51 <Si> i.e. for like 100 length lists
12:12:51 <Heffalump> [0,0] are only length 2 :-)
12:13:17 <Si> couldn't you define something like f (h:t) = map (f t) [0..h]?
12:13:20 <ski> Heffalump : well, perhaps something like "instance Ord (DList Zero a)" and "instance Ord (DList n a) => Ord (DList (Succ n) a)" .. ?
12:13:45 <Heffalump> ski: sure, but what will the actually comparison do?
12:14:27 <ski> Heffalump : well, lexicographic, i suppose  (similar to the respective tuple instance)
12:15:04 <Heffalump> ok, so then between [0,0] and [1,0] you have lots and lots of lists, like I said above :-)
12:15:25 <ski> hmm
12:15:31 <ski> oh, right
12:15:55 <gnarf> hi
12:16:05 <ski> hi gnarf !
12:16:24 <ski> Heffalump : how does e.g. Ord (a,b) handle that, then ?
12:16:37 <gnarf> ski: i think i understood the concept of monads :)
12:16:45 <ski> gnarf : nice !
12:17:14 <ski> Si : what would that function do ?
12:17:23 <Si> nothing
12:17:41 <ski> Si : it would just give _|_, right ?  (if it even typechecks)
12:18:15 <ski> Heffalump : hmm ?
12:18:15 <Si> you have to somehow arrive at a base case of map (\x -> [x,y,z]) [x..n]
12:18:55 <Si> or rather (\x -> [x]++(some list)) [x..n]
12:19:43 <Si> where some list is the answer for an n-1 length list
12:19:56 <ski> Si : perhaps you could do "data Nested {- or whatever they call this-} a = Leaf a | Branch [Nested a]" ?
12:20:39 <ski> ("rose tree", is perhaps the name i was looking for ..)
12:21:14 <Heffalump> ski: is there an Ix (a,b) ?
12:21:23 <ski> instance (Ix a, Ix b) => Ix (a,b)
12:21:26 <Heffalump> if so, then it'll have precisely that problem - which may or may not matter :-)
12:22:17 <Si> Ix goes up to Ix (a,b,c,d,e)
12:22:37 <Heffalump> right, well you can do it for fixed length lists too. It'll just have the consequences I stated.
12:22:42 <Si> they'll all be defined by hand with ala map (\z -> (map (\y -> map (\x -> [x,y,z]) [1..10]) [1..10])) [1..10] I imagine
12:23:14 <Heffalump> ah, now you're using a datatype other than Int as the basis.
12:23:21 <Heffalump> Your datatype only has a range from 1-10.
12:23:46 <Heffalump> indeed, you can encode lists of length 3 over the range 1-10 as a number from 1-1000
12:23:47 <ski> Heffalump : when we think of an "(Ix i,Ix j) => Array (i,j) a", we usually think of that as not linear ordered, rather two-dimensional, though of course this is mapped to a totally ordered sequence ..
12:25:23 <Si> yes, you need a mapping defined from [Int] -> Int somehow
12:26:34 <ski> Heffalump : the values of the index type isn't *all* valid indices, there are bounds which restrict to a subtype. you know this, right ?
12:26:40 <ski> Si : no
12:27:20 <ski> you need a mapping from [Int], *within* the bound given by a ([Int],[Int]), to an Int
12:27:24 <Si> quite right, it wouldn't work if you didn't know the list size
12:30:39 <ski> so, if you assume that only index lists of the same length (and arrays intended to be indexed by those respective lengths), are used together, i think this is perhaps doable   (barring infinite index list, also, of course)
12:30:48 <Si> if you have an index of dimension n then you can work out each index by prefixing each value in the nth dimension with all the index values in the n-1th dimension
12:31:20 <ski> hmm, what do you mean ?  example ?
12:31:44 <Si> let's say we have [1..10]
12:32:10 <ski> as index bounds, for some dimension ?
12:32:31 <Si> you get all the values in the second dimensions by prefixing each value with all the values in the first dimension
12:32:54 <ski> what do you mean by "prefixing" ?
12:32:59 <Si> i.e. [1,1],[2,1]...
12:33:22 <Heffalump> ski: oh, right.
12:33:33 <Heffalump> I was just trying to find the definition so I could find out about this.
12:33:39 <Heffalump> What's the type of the relevant member function of Ix?
12:34:18 <ski> Heffalump : so you mean  inRange :: (a,a) -> a -> Bool  ?
12:34:19 <skew> Hey Si, did you get your SOAP thing working?
12:34:37 <Si> and then for the 3rd dimension you need to prefix each value with all the values in the 2nd dimension
12:34:40 <Heffalump> ahh, so everything takes an (a,a) parameter first?
12:34:45 <ski> (s/so/do/)
12:35:08 <Si> so [1,1]++[1],[2,1]++[1]....[10,10]++[10]
12:35:39 <ski> Heffalump : many functions on arrays do, yes  (but not all o'them)
12:36:34 <ski> Heffalump : (e.g. not  (!) :: Ix a => Array a b -> a -> b   bounds :: Ix a => Array a b -> (a,a)   indices :: Ix a => Array a b -> [a]  ...)
12:37:29 <ski> Heffalump : probably, the bounds are kept inside the array implemenation, from the creation of the array
12:37:41 <ski> Si : hmm
12:37:57 <Heffalump> right, but what about the member functions of Ix?
12:38:00 <Heffalump> is inRange the only one?
12:38:17 <ski> class Ord a => Ix a where
12:38:17 <ski>   range :: (a,a) -> [a]
12:38:17 <ski>   index :: (a,a) -> a -> Int
12:38:17 <ski>   inRange :: (a,a) -> a -> Bool
12:38:17 <ski>   rangeSize :: (a,a) -> Int
12:38:36 <ski> those are the ones in the class proper
12:39:17 <Heffalump> so what does 
12:39:19 <ski> Si : i still don't get why you prefix ? (not to mention *what* you prefix :)
12:39:25 <Heffalump> range ((0,0),(1,0)) return?
12:39:47 <ski> Array> range ((0,0),(1,0))
12:39:47 <ski> [(0,0),(1,0)]
12:40:24 <ski> Array> range ((5,8),(6,9))
12:40:25 <ski> [(5,8),(5,9),(6,8),(6,9)]
12:40:38 <Heffalump> ah, so the Ix instance for tuples isn't consistent with the Ord instance.
12:40:42 <Si> you've got a list [x,y,z] which you want to find all the number between it and [0,0,0] right?
12:40:52 <Heffalump> in the sense that a<b<c does not imply b \in range (a,c)
12:42:01 <ski> Si : (sorry,) explain (more)
12:42:31 <ski> Si : what should the output be for, e.g. [2,4,3] ?
12:43:18 <Si> we look at the first dimension which is of length 2 right?
12:43:39 <Si> no
12:43:39 <ski> Heffalump : hmm, that's right
12:43:49 <Si> we look at the last value sorry
12:44:05 <Si> or do we...
12:44:12 <ski> Heffalump : hasn't though of that previously
12:44:18 <Si> f (h:t) y = map (\x -> y:(f t x)) [0..h]
12:44:51 <keverets> what's a value of b such that (5,8) < b < (6,9), but is not in the ranch ((5,8),(6,9))?
12:44:58 <keverets> range
12:45:40 <Si> Occurs check: cannot construct the infinite type: a = [a]
12:45:40 <Si>         Expected type: a
12:45:40 <Si>         Inferred type: [a]
12:45:40 <Si>     In the expression: y : (f t x)
12:45:40 <Si>     In a lambda abstraction: \ x -> y : (f t x)
12:45:57 <keverets> oh, I see with (0,1) not in the range
12:46:16 <skew> It's the other way around, I think
12:46:29 <skew> (5,8)  < (5,100000000) < (6,9)
12:46:32 <ski> Array> (5,8) <= (5,10) && (5,10) <= (6,9)     
12:46:33 <ski> True
12:46:33 <ski> Array> inRange ((5,8),(6,9)) (5,10)
12:46:33 <ski> False
12:47:18 <ski> Si : right :), you probably want something like my Nested above, if you really want to do something like that ..
12:48:15 <ski> hmm
12:48:56 <Si> I don't get why that doesn't work, just let me work through an example on paper...
12:48:57 <ski> Si : once again :), what do you (right now, naively), want that function to return, for [2,4,3] ?
12:49:38 <Si> let me work it out...
12:49:46 <ski> something like [[[...],...],...] ???
12:51:38 <Si> first iteration; f [2,4,3] [] = map (\x -> [] ++ (f [2,3] [x]) [0..1]
12:51:54 <Si> sorry wrong
12:52:02 <Si> first iteration; f [2,4,3] [] = map (\x -> [] ++ (f [4,3] [x]) [0..2]
12:52:41 <ski> Heffalump : hmm, so perhaps the Ord constraint in class Ix, should only be present the totally ordered instances ?  (like Int, but not (Int,Int))
12:53:12 <Si> second iteration (x=0); f [4,3] [0] = map (\x -> [0] ++ (f [3] [x] [0..4]
12:54:06 <ski> shouldn't first be :
12:54:16 <ski> f [2,4,3] [] = map (\x -> [] ++ (f [4,3] x) [0..2]
12:54:17 <ski> ?
12:54:29 <Si> third iteration (x=0); f [3] [0] = map (\x -> [0,0] ++ (f [] [x])) [0..3]
12:54:35 <Si> and then we hit the base case
12:54:38 <ski> well ?
12:54:57 <ski> should it ?
12:55:17 <Si> it could be, if you used : instead of ++
12:55:31 <Si> but I've made an error anyway
12:55:37 <ski> hmm, so how does your f look like, now ?
12:55:53 <ski> previously you said :
12:55:53 <ski> f (h:t) y = map (\x -> y:(f t x)) [0..h]
12:56:10 <Si> sorry
12:56:23 <Si> f (h:t) y = map (\x -> y++(f t [x])) [0..h]
12:56:28 <ski> ok
12:56:37 <Si> but y needs adding to x too
12:56:40 <ski> and base case ?
12:56:56 <Si> f [] y = [y] I think
12:57:00 <Si> it doesn't work though
12:57:13 <Si> trying to work out why
12:57:16 <ski> just type-error ?
12:57:33 <ski> or it doesn't work when you calculate by hand ?
12:58:33 <Si> Occurs check: cannot construct the infinite type: a = [a]
12:58:55 <ski> but, does your hand-calculations work correctly ?
12:59:52 <ski> (btw, you can take a smaller example than [2,4,3]. i just want to see what this function is supposed to do ..)
12:59:53 <Si> give me a chance
13:00:00 <ski> yes, of course ;)
13:05:26 <gnarf> after having read (most of) gentle introduction what is to be read to get rid of evil imperative thoughts (c, c++, perl, etc..)?
13:05:43 <ski> :)
13:05:49 <ski> perhaps other tutorials ?
13:06:07 <ski> the "yet another ..." one ?
13:06:11 <Si> ok, I'll work through an example for f [1,1] []
13:06:14 <ski> the monad one ?
13:06:18 <ski> Si : ok, fine
13:06:24 <Cale> nomaware's monad tutorial is good
13:06:35 <skew> gnarf: figure out want you want to code, then ask people how to do it functionally
13:06:40 <ski> Cale : yes. that one
13:06:42 <mattam> gnarf: there's a gentle introduction to category theory if you really want to get rid of thoughts :)
13:06:52 <Si> so f [1,1] [] = m (\x -> [] ++ (f [1] [x]) [0..1]
13:06:56 <ski> mattam : where ?  :)
13:06:59 <Si> doing the map;
13:07:06 <ski> ok
13:07:14 <mattam> let me check.
13:07:56 <Si> for x = 0; f [1] [0] = m (\x -> [0] ++ (f [] [x]) [0..1]
13:08:00 <ski> gnarf : know where the other tutorials are ?
13:08:32 <ski> you don't have to substitute for x yet, i think
13:09:05 <Si> for x = 0; f [1] [1] = m (\x -> [1] ++ (f [] [x]) [0..1]
13:09:09 <ski> f [1] [x] m (\x' -> [x] ++ (f [] [x']) [0..1]
13:09:14 <Si> sorry I meant for x =1
13:09:20 <gnarf> skew: i dislike asking many questions because i would not like to tell every newbe everything over and over again. indeed i'm simply trying to learn things that seem to be interesting (learning for fun as long as i have enough time). my next aim would be writing a parser for some kind of language.
13:09:25 <ski> f [1] [x] = m (\x' -> [x] ++ (f [] [x']) [0..1]    !
13:09:31 <ski> mm
13:09:34 <gnarf> ski: yes.
13:09:37 <skew> hey, that's a great idea!
13:09:51 <Si> so as such we have [m (\x -> [0] ++ (f [] [x]) [0..1], m (\x -> [1] ++ (f [] [x]) [0..1]]
13:09:58 <skew> parsers are very cool and not imperative.
13:10:18 <Si> I think I see why it won't compile
13:10:18 <mattam> ski: ftp://ftp.cs.utwente.nl/pub/doc/Parlevink/fokkinga/mmf92b.ps.Z
13:10:24 <gnarf> skew: bison gets hairy ;)
13:10:27 <ski> gnarf : monadic parser combinators are very cool !
13:10:42 <Si> doing it this way, for each level are the tree the length of the list goes up 1
13:10:45 <skew> yep, the functional versions are much cleaner :)
13:10:47 <Si> which is impossible
13:10:54 <Si> so we need to folr1 (++)
13:10:58 <ski> hmm
13:11:20 <ski> you mean 'concat', perchance ?
13:11:32 <ski> @type concat
13:11:32 <betabot> concat :: [[a]] -> [a]
13:11:43 <skew> gnarf: if you have coded a lots of imperative languages, and are trying to learn how to write more natural (functional) code, looking at parser combinators would be good
13:11:55 <skew> I'd also suggest looking at some of the interesting data structure stuff
13:12:04 <Si> well it kinda works now
13:12:07 <ski> gnarf : have you grokked (or indeed used) monads yet ?
13:12:12 <Si> f (h:t) y = foldr1 (++) $ map (\x -> y++(f t [x])) [0..h]
13:12:13 <Si> f [] x = x
13:12:13 <skew> generic folds, for example
13:12:49 <gnarf> ski: "yet another..." is only available in pdf/ps/dvi. as i have no access to an X11 terminal this is not easy to be read. have you got another one? perhaps one for c-programmers?
13:12:52 <Si> f [2,3,4] []
13:12:52 <Si> [0,0,0,0,1,0,2,0,3,0,4,0,1,0,1,1,1,2,1,3,1,4,0,2,0,2,1,2,2,2,3,2,4,0,3,0,3,1,3,2,3,3,3,4,1,0,0,0,1,0,2,0,3,0,4,1,1,0,1,1,1,2,1,3,1,4,1,2,0,2,1,2,2,2,3,2,4,1,3,0,3,1,3,2,3,3,3,4,2,0,0,0,1,0,2,0,3,0,4,2,1,0,1,1,1,2,1,3,1,4,2,2,0,2,1,2,2,2,3,2,4,2,3,0,3,1,3,2,3,3,3,4]
13:13:09 <Si> it is doing it I think, but it's putting all my data together weirdly
13:13:10 <ski> Si : hmm, so all the numbers in the first argument to f must be positive ?
13:13:30 <ski> but you want to have a more structured result ?
13:13:31 <gnarf> ski: no. i had no ghc available when reading the rest..
13:13:51 <Cale> gnarf: pdf is easily viewable from a windows machine
13:14:16 <gnarf> Cale: sorry. i wont use any m$ product.
13:14:26 <Cale> oh, what are you using then?
13:14:35 <ski> gnarf : hmm
13:15:00 <Lemmih> gnarf: Don't you have ggv?
13:15:05 <gnarf> anything else. i just dislike people saying "thoughts may be owned"
13:15:16 <skew> so have no X?
13:15:28 <gnarf> skew: my elitegroup board is a bit buggy...
13:15:32 <Cale> Oh, so you're just using a text terminal?
13:15:37 <gnarf> right
13:16:02 <ski> Si : should "f [1,1] 0" become something like [0++[0++[],1++[]],1++[0++[],1++[]]] ?
13:16:05 <skew> even an unaccelerated VGA X won't  work?
13:16:41 <skew> I know there is some way of pulling the text out of a file like that
13:16:45 <Si> I think so...
13:16:52 <gnarf> skew: i found out that it doesn't depend on xmodule or grahpics card. it's just a simple freeze on about 50% of all video mode switches
13:17:07 <gnarf> skew: but this is really getting off topic.
13:17:35 <ski> gnarf : but, i think that tut uses indentation, and perhaps some symbols too, so a plain text extraction of that might be hard to read :(
13:17:58 <gnarf> ski: right. that's why i asked you for another one.
13:18:06 <ski> gnarf : ok, hmm
13:18:30 <skew> you could mail the author and tell him text is good.
13:18:38 <gnarf> lol
13:19:02 <skew> hmm. not being able to view pdf really hurts things
13:19:05 <gnarf> ski: wait. i'll take another machine next week ;)
13:19:16 <ski> gnarf : well, the nomaware tut is in html, at least. have you looked at that yet ?
13:19:29 <skew> most of the stuff I'm thinking of (just little examples) is in published papers, availible as PDF
13:19:51 <ski> skew : (and PS, i assume)
13:20:03 <skew> well, it varies
13:20:06 <skew> but yeah
13:20:12 <gnarf> hm. i could print it (if cups wasn't broken on sid right now ;)
13:20:45 <gnarf> ski: sounds interesting. thanks
13:21:03 <ski> Si : so you want to store something (a number, in your case) at every 'level', right ?
13:21:14 <ski> gnarf : http://www.nomaware.com/monads/html/
13:21:49 <ski> Si : hmm ?
13:21:59 <gnarf> ski: thanks. found the same url.
13:22:13 <ski> gnarf : ok. happy reading ! :)
13:24:06 <Si> I'll be with you, I've nearly cracked it
13:24:52 <gnarf> hm. in most channels i know the most common answer to any kind of question is rtfm. what's so different?
13:24:59 <ski> gnarf : (the only pics (except a few noninteresting icons) are in Appendix I "A physical analogy for monads")
13:25:18 <Heffalump> we feel too much like an endangered species to be nasty to newbies :-)
13:25:23 <ski> gnarf : "what's so different" about what ?
13:25:32 <gnarf> ski: i have access to some diskless clients at school (with X11 ;)
13:25:46 <Riastradh> Functional programmers are better people in general, duh.
13:25:48 <gnarf> ski: i havn't seen a single rtfm answer yet..
13:26:00 <ski> gnarf : oh, ok
13:26:08 <ski> Si : ok
13:26:39 <ski> Riastradh : heh :-)
13:27:02 <skew> It's not really a fair answer when the only docs are people publications, and the stuff is damn confusing anyway
13:31:50 <Si> I don't get it, it works for lists of length 2, but then breaks at length 3?
13:32:14 <ski> what do you have ?
13:32:21 <ski> (the code)
13:34:56 <Vulpyne> :q
13:34:59 <Vulpyne> Oops.
13:35:30 <ski> Vulpyne : you can't turn off the channel like that !
13:38:38 <skew> of course! next time, try C-x C-c 
13:39:23 <ski> skew : does he use erc ?
13:39:40 <skew> apparently he uses vim
13:39:55 <Si> f (h:t) y = foldr1 (++) $ map (\x -> y++(f t [x])) [0..h]
13:39:55 <Si> f [] x = x
13:40:04 <Vulpyne> Heh.
13:40:13 <Vulpyne> I use vi for small jobs, xemacs for large.
13:40:28 <skew> either thad, or there is some new and exciting smily sticking the tounge to the side
13:40:32 <Si> I'm giving up I'll try again tommorow, l8r
13:40:32 <skew> :Q
13:40:38 <skew> hey Si,
13:40:51 <Si^AFK> uh huh
13:40:53 <skew> did you see if my code would be useful?
13:41:07 <skew> for building your graph or whatever.
13:41:34 <ski> Si : i think you want another data structure
13:42:02 <ski> Si : do you want to store elements (indices) at each level ?
13:42:29 <ski> Si : how about the 'bottom' of your structure ? should anything interesting be stored there ?
13:42:58 <ski> skew : you too ?
13:43:13 <skew> me too what?
13:43:17 <Si^AFK> no, we're discussing something different now
13:43:22 <Si^AFK> or were
13:43:31 <ski> skew : are you also trying to get rid of us ?
13:43:38 <ski> (by typing ":Q")
13:43:53 <Si^AFK> you're quite right it is a tree
13:44:03 <skew> no that's the fancy new smiley Vulpyne introduced.
13:44:10 <Si^AFK> but my mind won't work out how to construct it now
13:44:30 <ski> skew : oh, *now* i understand
13:44:39 <skew> I suppose I should read the SOAP thing sometime, to see what exactly you were trying to build
13:44:45 <Si^AFK> frankly all I'm interested in is for working out all the values between [0,0,0...] and [n,n,n...]
13:44:58 <Si^AFK> oh I had it built, that wasn't my problem
13:45:28 <Si^AFK> my problem was trying to marshal to polymorphic references via coercision
13:45:49 <Si^AFK> but I must go, cyall
13:46:26 <ski> something like [[[[0,0,0],[0,0,1]],[[0,1,0],[0,1,1]]],[[[1,0,0],[1,0,1]],[[1,1,0],[1,1,1]]]], for [1,1,1]  ?
13:46:33 <ski> Si : ok, bye
13:46:38 <gnarf> bye. (only 7 hours of sleep left) thank you again for your great help.
13:46:41 <Si^AFK> correct, bye
13:46:51 <ski> gnarf : bye
13:47:52 <gnarf> ski: the nomaware thing is very interesting and seems to fit my knowledge so far. thanks and bye.
13:50:26 <ski> hmm, why is the class named MonadFix, and not just Fix (or something) ?  (in hierarical libraries)
13:50:32 <ski> shapr : hi !
13:51:07 <ski> (typing Control.Monad.Fix.MonadFix seems a bit redundant)
13:53:26 <shapr> hi ski!
13:53:34 <shapr> I've just heard about this great language Haskell
13:53:38 <ski> oh
13:53:45 <Si^AFK> sorry, I know I'm AFK, but the correct (working) function is
13:53:46 <Si^AFK> f2 :: [Int] -> [[Int]]
13:53:46 <Si^AFK> f2 [x] = map (\x -> [x]) [0..x]
13:53:46 <Si^AFK> f2 (h:t) = foldr1 (++) $ map (\y -> map (\x -> y:x) (f2 t)) [0..h]
13:53:50 <ski> where can i learn more about it ?
13:53:55 * shapr laughs
13:54:38 <ski> Si^Really^AFK : but that works for 2 levels, but not 3, right ?
13:54:50 <shapr> Si^Really^AFK: alternatively, you could just keep the same nick all the time and come and go as you please
13:54:54 <shapr> I think that's how most people handle it.
13:55:15 <ski> Si : :)
13:55:18 <Si> no that works forall a . [Int]
13:55:36 <ski> ?
13:55:37 <Si> except you have to map reverse to get it column wise
13:55:48 <ski> there is no free 'a' in '[Int]'
13:55:53 <shapr> there's also the "/away" command that takes a string parameter, then other irc users can do "/whois si" and see "away: sleeping" or whatever.
13:56:05 <Si> I know, I being silly
13:56:13 <shapr> though public away announcments are considered bad form in these here parts.
13:56:36 <Si> but I'm sure you catch me
13:56:42 <ski> shapr : the away param is also used when trying to /msg someone, i think
13:56:50 <shapr> yes, that's true.
13:56:55 <Si> (really gone)
13:56:58 <ski> shapr : (i know (or at least think), you know this, yes :)
13:57:19 <shapr> oh hey, it looks like I get to live here another year.
13:57:38 <shapr> the migrationsverket seemed to approve of me.
13:57:47 <ski> oh :)
13:58:52 <ski> perhaps you're a good working, society-contributing, not-as-of-yet-citizen ..
13:59:24 <shapr> yes, possibly so.
14:00:32 <ski> (s/good/good,/)
14:00:36 <ski> :)
14:11:13 <shapr> g'night Pseudonym 
14:13:54 <Pseudonym> Oh, you going to bed?
14:14:01 * Pseudonym came in early and everything
14:14:08 <Pseudonym> Well, 9am, which is early for me.
14:14:15 <ski> Pseudonym : methinks, he just greeted you
14:14:27 <Pseudonym> Oh, good point.
14:14:29 <Pseudonym> G'day!
14:18:16 <Pseudonym> Any news from the government?
14:19:16 <ski> <shapr> oh hey, it looks like I get to live here another year.
14:19:16 <ski> <shapr> the migrationsverket seemed to approve of me.
14:19:22 <Pseudonym> Oh, cool.
14:19:25 <ski> Pseudonym : if that's what you mean
14:19:28 * Pseudonym learns to read logs
14:19:33 <Pseudonym> Yes, that's precisely what I mean.
14:19:37 <Marvin--> cool
14:19:50 <Marvin--> shapr: so they've figured out what to do with you?
14:48:45 <Pseudonym> @yow
14:48:46 <betabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
14:49:02 <Pseudonym> I swear 9am shouldn't exist, unless approached from the other side.
14:52:40 <Pseudonym> OK, question for the category theory nuts.
14:53:46 <Pseudonym> If you interpret the set of "types" in a program as a category, do the identities at the category level correspond to identities on your data?
14:54:06 <Pseudonym> No, probably not, becuase the identities are usually only correct up to isomorphism.
14:54:49 <ski> the identities for each object (type) ?
14:55:21 <Pseudonym> By "type", I don't mean the language's type system, by the way.
14:55:21 <ski> like  id_A :: A -> A   id_A a = a
14:55:29 <ski> oh ?
14:55:49 <Heffalum1> evening
14:55:50 <Pseudonym> Take a balanced binary search tree, for example.
14:55:53 <Pseudonym> G'day.
14:56:09 <ski> Heffalum1 : yes, it is
14:56:36 <ski> Pseudonym : mhmm
14:56:49 <Pseudonym> As far as the compiler is concerned, a balanced BST is, say, data BST k = Null | Branch BalanceMaintainingStuff (BST k) k (BST k)
14:57:02 <Pseudonym> Where BalanceMaintainingStuff is the metadata that you use to maintain the balance condition.
14:57:13 <ski> mhmm
14:57:17 <Pseudonym> We'll say it's an Int.  That's sufficient to implement most schemes.
14:57:48 <Pseudonym> As far as the programmer is concerned, however, that's a superset of the valid balanced BST.
14:57:57 <ski> right
14:58:04 <Pseudonym> For a start, k has to be a member of Ord.
14:58:38 <Pseudonym> Secondly, "Branch md l x r" has the constraint that any keys in l must be less than x, and so on.
14:58:45 <Pseudonym> Thirdly, the tree must be balanced.
14:58:54 <Pseudonym> Fourthly, the metadata must be accurate.
14:59:00 <ski> the actual BST type is the implementation/representation type, and this is often an approximation of the type one'd really want to express
14:59:05 <Pseudonym> Right.
14:59:14 <ski> right
14:59:17 <Pseudonym> Now an identity on this type might be left rotation, for example.
14:59:31 <Pseudonym> Assuming that the tree is still "balanced" after the rotation.
14:59:58 <ski> you mean that left rotation should give a new tree, that looks the same, from the outside ?
15:00:33 <Pseudonym> The left rotation should give something that is a) a valid binary search tree, and b) identical with respect to the ADT's interface, yes.
15:00:40 <ski> (i.e. left rotation used to keep the tree balanced ?)
15:00:46 <ski> ok
15:00:56 <Pseudonym> OK.  Now a less simple example.
15:01:13 <Pseudonym> Consider the category of irreflexive directed graphs.
15:01:17 <ski> but the input of left-rotation might not be a (fully) balanced tree, right ?
15:01:34 <ski> yes
15:01:42 <Pseudonym> Maybe we should ignore the balance constraint for the purposes of exposition. :_)
15:01:47 <Pseudonym> Anyway.  Graphs.
15:01:50 <ski> yes
15:01:56 <Pseudonym> You have two data types, Dot and Arrow.
15:01:57 <ski> Set ^ A
15:02:12 <Pseudonym> And you have two functions: start : Arrow -> Dot and end : Arrow -> Dot
15:02:19 <ski> inside each object/graph, yes
15:02:29 <Pseudonym> Should use :: to be Haskell-compliant, I guess.
15:02:29 <ski> yes
15:02:55 <ski> (that doesn't matter much, methinks)
15:03:15 <ski> (except if you want to implement this :)
15:03:23 <ski> so, continue
15:03:27 <Pseudonym> Hmmm... OK, to make things concrete, I think we need to be more careful.
15:03:33 <ski> oh ?
15:03:50 <Pseudonym> class Graph g d a | g -> d a where { start :: g -> a -> d ; end :: g -> a -> d }
15:04:06 <Pseudonym> So "g" is the type of the graph, "d" is the type of a dot amd "a" is the type of an arrow.
15:04:44 <ski> okay
15:05:03 <Pseudonym> Let's consider the "arrow graph", which has two dots and an arrow between them.
15:05:08 <ski> yes :)
15:05:27 * Pseudonym is reading Lawvere and Schanuel, can you tell?
15:05:33 <ski> (the book calls that A)
15:05:33 <Pseudonym> OK.
15:05:37 <ski> yes :)
15:05:40 <Pseudonym> Right.  Let's do that then.
15:05:42 <Pseudonym> data A
15:05:56 <Pseudonym> data Dot = Dot
15:06:04 <Pseudonym> Hmmm.
15:06:07 <Pseudonym> No, the graph has two dots.
15:06:15 <Pseudonym> data ADot = ADot1 | ADot2
15:06:16 <ski> data A
15:06:21 <Pseudonym> data A = A
15:06:24 <ski> data AArr = AArr
15:06:27 <Pseudonym> Right.
15:06:30 <ski> data ADot = ADot1 | ADot2
15:06:31 <ski> yes
15:06:37 <Pseudonym> instance Graph A ADot AArr where
15:06:42 <Pseudonym>     start AArr = ADot1
15:06:47 <Pseudonym>     end AArr = ADot2
15:06:49 <Pseudonym> OK.
15:07:03 <Pseudonym> Now, we'll construct the product of A and A.
15:07:07 <ski> (doesn't the book call them source and target, btw ?)
15:07:11 <ski> yes
15:07:13 <Pseudonym> Uhm... yes.
15:07:18 <ski> A * A = A + 2 * D
15:07:25 <Pseudonym> Right.  That's an identity.
15:07:47 <ski> (or at least isomorphism)
15:07:51 * Pseudonym nods
15:07:52 <ski> (not totally sure)
15:07:58 <Pseudonym> That's what I want to find out.
15:08:11 <Pseudonym> So let's do this.
15:08:15 <ski> what's what you want to find out ?
15:08:16 <Pseudonym> First, we need D.
15:08:18 <ski> ok
15:08:32 <ski> data D
15:08:37 <ski> data DArr
15:08:40 <Pseudonym> data D = D
15:08:44 <Pseudonym> data DArr    -- abstract
15:08:45 <ski> data DDot = DDot
15:08:49 <Pseudonym> Right.
15:08:57 <Pseudonym> instance Graph D DDot DArr where
15:09:03 <Pseudonym>     start _ = undefined
15:09:04 <ski> do we need any element in the graph type ?
15:09:06 <Pseudonym>     end _ = undefined
15:09:14 <ski> is DArr abstract ?
15:09:18 <ski> why ?
15:09:29 <Pseudonym> The set of arrows in D is the empty set.
15:09:34 <Pseudonym> Hence, it should be the empty type.
15:09:39 <Pseudonym> 0, the initial object
15:09:40 <ski> right
15:09:44 <ski> not abstrct
15:09:55 <ski> correct ?
15:10:00 <Pseudonym> OK, first question: What _is_ 0 in Haskell?
15:10:08 <Pseudonym> Probably undefined.
15:10:09 <ski> the empty type, of course
15:10:15 <Pseudonym> bottom
15:10:24 <ski> bottom is not a type
15:10:35 <Pseudonym> I know that 1, the terminal object, is ().
15:10:41 <Pseudonym> Oh, so it's "a".
15:10:44 <Pseudonym> A free type variable?
15:10:56 <ski> 1 = exists a. a
15:11:00 <ski> 0 = forall a. a
15:11:06 <Pseudonym> Hmmm.
15:11:13 <Pseudonym> How do you represent it in Haskell?
15:11:14 <ski> (isomorphisms, of course)
15:11:17 <ski> data Void
15:11:22 <ski> or perhaps
15:11:27 <ski> data Void =
15:11:33 <ski> (with no constructors)
15:11:35 <Pseudonym> I think data Void is right.
15:11:37 <Pseudonym> Yes.
15:11:43 <Pseudonym> Though Void is actually ().
15:11:46 <Pseudonym> I think.
15:11:49 <ski> no !
15:11:58 <ski> Unit is ()
15:12:01 <Pseudonym> No, the C "void" type is the equivalent of ().
15:12:13 <ski> no C/C++/Java confusion here, thanks :)
15:12:19 <Pseudonym> :_)
15:12:26 <ski> right C "void" is the unit type
15:12:29 <Pseudonym> OK.  We'll stich with : data DArr
15:12:36 <ski> (also called "unit" in the MLs)
15:12:36 <Pseudonym> Back to the graph example.
15:12:39 <Pseudonym> Right.
15:12:45 <Pseudonym> Called "unit" in Mercury, too.
15:12:48 <Pseudonym> OK.
15:12:59 <Pseudonym> So we have A and D.
15:13:01 <ski> ok
15:13:08 <Pseudonym> Now I want to construct A*A.
15:13:23 <ski> so you need *, then ?
15:13:41 <ski> data Prod g0 g1
15:13:43 <Pseudonym> instance Graph (A,A) (ADot,ADot) (AArr,AArr) where
15:13:50 <Pseudonym> I'll use (,), it's easier.
15:13:55 <ski> ok
15:14:14 <Pseudonym>     start (a1,a2) = (start a1,start a2)
15:14:25 <Pseudonym>     end (a1,a2) = (end a1,end a2)
15:14:26 <Pseudonym> Right?
15:14:33 <ski> instance (Graph g0 d0 a0,Graph g1 d1 a1) => Graph (g0,g1) (d0,d1) (a0,a1)
15:14:35 <ski> no ?
15:14:38 <ski> hmm
15:14:45 <Pseudonym> That's a generic product.
15:14:45 <ski> i think so, yes
15:14:54 <Pseudonym> I'm thinking concretely here, because I want to find the identity.
15:15:02 <Pseudonym> OK.  Now let's construct A + 2*D.
15:15:11 <Pseudonym> I'll use Either to implement +.
15:15:23 <Pseudonym> Hmmm.
15:15:24 <ski> (sorry, when you say identity, i immediately think : the identity function)
15:15:30 <Pseudonym> No, I'll use A + D + D
15:15:37 <ski> ok
15:15:50 <Pseudonym> data Either3 a b c = Inj1 a | Inj2 b | Inj3 c
15:15:56 <Pseudonym> That's going to make things easier.
15:16:11 <ski> so there should be an iso between (A,A) and Either3 A D D, right ?
15:16:25 <Pseudonym> That's what I want to find out.
15:16:29 <Pseudonym> There should be.
15:17:01 <Pseudonym> instance Graph (Either3 A D D) (Either3 ADOt DDot DDot) (Either3 AArr DArr DArr) where
15:17:23 <Pseudonym>     start (Inj1 a) = Inj1 (start a)
15:17:28 <Pseudonym>     {- etc -}
15:17:34 <ski> data A; data AArr = AArr; data ADot = ADot1 | ADot2
15:17:35 <Pseudonym> Right so far?
15:17:45 <ski> data D; data DArr; data DDot = DDot
15:17:55 <ski> (just wanted to have those defs in sight :)
15:17:58 <Pseudonym> Sure.
15:18:02 <ski> yesh, i think so
15:18:24 <ski> foo :: (A,A) -> Either3 A D D
15:18:32 <ski> bar :: Either3 A D D -> (A,A)
15:18:37 <Pseudonym> Yup.
15:18:44 <Pseudonym> That's what we want.
15:18:47 <Pseudonym> OK.
15:18:54 <ski> how to define those, such that  foo . bar = id  and  bar . foo = id
15:18:54 <Pseudonym> Let's look at Either3 A D D a bit closer.
15:18:56 <ski> yes
15:19:08 <Pseudonym> Because DArr is the empty type.
15:19:18 <Marvin--> ADD? Who's got ADD?
15:19:19 <Pseudonym> That means that some of the injections won't exist.
15:19:35 <Pseudonym> Marvin--: This graph was recorded in analogue but mastered in digital.
15:19:59 <ski> (rats ! X or WindowMaker seems to have hanged a little. or something .. :(  )
15:20:28 <ski> (mouse is not working, at least)
15:20:34 <Pseudonym> I can wait if you want to restart X.
15:20:59 <ski> (err, mouse pointer moves, but nothing else is ...)
15:21:20 <ski> oh, now it suddely did all the actions in its history
15:21:27 <ski> ok, all fine now, i think
15:21:33 <Pseudonym> There you go.  Just needed a break.
15:21:42 <ski> yeah :)
15:21:42 <Pseudonym> Incidentally, this is perfect StudyGroup material, IMO.
15:21:54 <Pseudonym> Working out examples as a group.
15:22:08 <Pseudonym> OK.
15:22:09 <ski> perhaps we should quote some of this into the wiki
15:22:23 <Pseudonym> Yes, we might want to, as a subdirectory of StudyGroup.
15:22:31 <Pseudonym> I'll summarise when we're done if you want.
15:22:38 <ski> ok, thank you
15:22:48 <ski> so, where were we ? :)
15:22:59 <Pseudonym> <ski> data A; data AArr = AArr; data ADot = ADot1 | ADot2
15:23:00 <Pseudonym> <ski> data D; data DArr; data DDot = DDot
15:23:03 <Pseudonym> <ski> foo :: (A,A) -> Either3 A D D
15:23:03 <Pseudonym> <ski> bar :: Either3 A D D -> (A,A)
15:23:16 <ski> ok
15:23:17 <Pseudonym> And we want foo . bar = bar . foo = id
15:23:19 <ski> hmm
15:23:20 <ski> yes
15:23:35 <Pseudonym> Moreover:
15:23:37 <ski> hmm, again
15:24:07 <ski> yes ?
15:24:21 <Pseudonym> We want the mappings to satisfy the rules for start and end.
15:24:31 <ski> yes, right
15:24:40 <Pseudonym> OK, we don't want foo and bar.  We want:
15:24:52 <Pseudonym> fooArr :: (AArr,AArr) -> Either3 AArr DArr DArr
15:24:52 <ski> (to be real graph mappings)
15:25:03 <Pseudonym> barArr :: Either3 AArr DArr DArr -> (AArr,AArr)
15:25:09 <ski> yes, i sortof realized that now :)
15:25:10 <Pseudonym> fooDot and barDot similarly.
15:25:44 <ski> A should really be a pair of AArr and ADot, i think
15:25:48 <Pseudonym> And we want: fooDot (start A a) == start D (fooArr a)
15:25:56 <ski> A :: (*,*)  AArr :: *  ADot :: *
15:25:57 <Pseudonym> Right?
15:26:10 <Pseudonym> No, A is abstract.
15:26:25 <Pseudonym> All of its structure is in the types AArr and ADot, and the functions start and end.
15:26:41 <Pseudonym> They're tied by the fundep.
15:26:52 <ski> do you mean that the AArr and ADot is just one impl. of A ?
15:27:07 <Pseudonym> No, the fundep means they are _the_ implementation of A.
15:27:25 <ski> otherwise, i think A should be a type-pair (*not* a pair-type of AArr and ADot, N.B. !)
15:27:26 <Pseudonym> class Graph g d a | g -> d a where {- stuff -}
15:27:42 <ski> ok, anyway
15:27:55 <Pseudonym> OK, was that identity right?
15:27:58 <Pseudonym> fooDot (start A a) == start D (fooArr a)
15:28:06 <ski> hmm, lemme think
15:28:31 <ski> i think it is right, yes
15:28:45 <Pseudonym> Hmmm... not quite.
15:28:48 <ski> hmm
15:31:21 <ski> no ?
15:31:21 <Pseudonym> fooDot (start (A,A) a) == start (Either AArr DArr DArr) (fooArr a)
15:31:21 <Pseudonym> That's it.
15:31:21 <Pseudonym> We've actually got the instances slightly wrong.
15:31:21 <Pseudonym> <Pseudonym> instance Graph A ADot AArr where
15:31:21 <Pseudonym> <Pseudonym>     start AArr = ADot1
15:31:21 <Pseudonym> <Pseudonym>     end AArr = ADot2
15:31:21 <Pseudonym> That should read:
15:31:21 <Pseudonym> instance Graph A ADot AArr where
15:31:21 <Pseudonym>     start _ AArr ADot1
15:31:21 <Pseudonym>     end _ AArr ADot2
15:31:21 <ski> yes, forgot that we want to have a map from (AArr,AArr) to Either AArr DArr DArr :)
15:31:21 <Pseudonym>     end _ AArr = ADot2
15:31:21 <Pseudonym> Left out ='s.
15:31:21 <ski> ok
15:31:21 <ski> lemme read through that
15:31:21 <Pseudonym> That makes it valid Haskell.
15:31:21 <Pseudonym> See, in category theory notation, s and t are properties of a single graph.
15:31:21 <ski> yes
15:31:21 <Pseudonym> We model that in Haskell by passing the graph as the first argument.
15:31:29 <ski> yes
15:31:34 <Pseudonym> OK.
15:31:58 <Pseudonym> fooArr :: (AArr,AArr) -> Either3 AArr DArr DArr
15:32:00 <Pseudonym> barArr :: Either3 AArr DArr DArr -> (AArr,AArr)
15:32:18 <Pseudonym> fooDot :: (ADot,ADot) -> Either3 ADot DDot DDot
15:32:31 <Pseudonym> barDot :: Either3 ADot DDot -> (ADot,ADOt)
15:32:34 <ski> yes
15:32:53 <ski> (modulo s/ADOt/ADot/)
15:32:57 <Pseudonym> Sure.
15:33:00 <ski> mm
15:33:10 <Pseudonym> fooDot (ADot1,ADot1) = Inj1 ADot1
15:33:14 <Pseudonym> fooDot (ADot2,ADot2) = Inj1 ADot2
15:33:22 <Pseudonym> fooDot (ADot1,ADot2) = Inj2 DDot
15:33:29 <Pseudonym> fooDot (ADot2,ADot1) = Inj3 DDot
15:33:45 <Pseudonym> And the inverse.
15:33:56 <Pseudonym> barDot (Inj1 ADot1) = (ADot1,ADot1)
15:33:58 <Pseudonym> -- etc
15:34:03 <Pseudonym> They're obviously inverses.
15:34:11 <ski> hmm
15:34:26 <ski> yes
15:34:48 <Pseudonym> OK, now the arrow mappings.
15:34:52 <ski> right
15:35:21 <ski> fooArr (AArr,AArr) = Inj1 AArr
15:35:23 <ski> i think
15:35:25 <Pseudonym> Yes.
15:35:36 <ski> because DArr is empty
15:35:38 <Pseudonym> Similarly: barArr (Inj1 AArr) = (AArr,AArr)
15:35:44 <ski> yes
15:35:45 <Pseudonym> Inj2 and Inj3 will never appear.
15:35:55 <ski> one could perhaps do :
15:36:02 <Pseudonym> 'Cause you can't construct them.
15:36:13 <ski> barArr (Inj2 impossibleObject) = case impossibleObject of {}
15:36:25 <Pseudonym> It's identical, yes.
15:36:34 <Pseudonym> Or: barArr (Inj2 _) = undefined
15:36:37 <ski> (well, i think one can do that in Agda, anyway. not sure about hugs or ghc)
15:37:06 <Pseudonym> See, part of the problem in Haskell is that you can construct an object with "undefined" in it.
15:37:14 <ski> i guess so, though i think the two other versions are nicer
15:37:18 <ski> yeah
15:37:22 <Pseudonym> Which means you can instantiate the zero type. :-)
15:37:30 <ski> the two first works even without undefined
15:37:38 <Pseudonym> Right.
15:37:42 <Pseudonym> I think we leave the rules out.
15:37:46 <ski> rightee. that's bad :)
15:38:14 <ski> the commutating rules for graph morphisms ?
15:38:21 <Pseudonym> Right, that's next.
15:38:30 <Pseudonym> fooDot (start (A,A) a) == start (Either AArr DArr DArr) (fooArr a)
15:38:36 <ski> so we should try to prove them, then
15:38:38 <Pseudonym> Pick a = AArr
15:38:53 <Pseudonym> fooDot (start (A,A) AArr) = fooDot ADot1
15:38:58 <ski> (induction/case-analysis on AArr)
15:39:01 <Pseudonym> Hmm, type error.
15:39:28 <Pseudonym> The identities are wrong.
15:40:15 <Pseudonym> Should start: fooDot (start (A,A) a1, start (A,A) a2) = ?
15:41:02 <Pseudonym> No.
15:41:05 <ski> start (arrMap arr0) = dotMap (start arr0)    ?
15:41:13 <Pseudonym> Yes, that's it.
15:41:33 <ski> end (arrMap arr0) = dotMap (end arr0)
15:41:57 <ski> (s/arr0/arr/  i thought i needed (to name) more than one)
15:42:02 <Pseudonym> start (Either3 A D D) (fooArr (a1,a2)) = fooDot (start (A,A) (a1,a2))
15:42:10 <Pseudonym> That's it, right?
15:42:43 <Pseudonym> Suck it and see, I guess.
15:42:54 <ski> hmm
15:42:59 <Pseudonym> start (E3 A D D) (fooArr (AArr,AArr))
15:43:22 <Pseudonym> = start (E3 A D D) (Inj1 AArr)
15:43:27 <ski> (yes, i think it should be something like that)
15:44:14 <Pseudonym> = Inj1 (start A AArr)
15:44:21 <Pseudonym> = Inj1 ADot1
15:44:38 <Pseudonym> = fooDot (ADot1,ADot1)
15:44:50 <Pseudonym> = fooDot (start (A,A) (AArr,AArr))
15:44:55 <Pseudonym> Woohoo!  Proven.
15:45:24 <ski> hmm, lemme understand the latter part ..
15:45:35 <ski> (i.e. check)
15:45:56 <ski> right
15:46:08 <Pseudonym> OK.
15:46:15 <Pseudonym> Good, so there is an isomorphism.
15:46:36 <Pseudonym> I don't think we need to work out the other identities for the purposes of this exercise.
15:46:42 <ski> (the end case is of course entirely analogous)
15:46:46 <Pseudonym> Right.
15:46:49 <ski> yes
15:47:05 <Pseudonym> Cool.  That was interesting.
15:47:26 <Pseudonym> It also answers the question that I wanted to ask in the first place.
15:48:04 <ski> hmm, i'll try to encode the Graph category in my dependently-typed-pseudo-code-syntax
15:48:06 <Pseudonym> This identity, A * A = A + 2*D, shows that if you want to represent A * A concretely, representing A + 2*D instead is fine.
15:48:09 <ski> ok, nice
15:48:16 <ski> yes
15:48:35 <Pseudonym> See, what I'm looking for is a way to manipulate data structures.
15:48:43 <Pseudonym> For trivial cases it's obvious.
15:48:43 <ski> ok ?
15:48:54 <Pseudonym> For example, take: 2*Unit = Unit + Unit
15:48:59 <ski> yes
15:49:13 <Pseudonym> That says that, for example, in Haskell, there is an isomorphism between Either () () and (Bool,())
15:49:33 <ski> yes
15:49:56 <Pseudonym> In data structure programming, there are often situations where you have simple operations to get information out.
15:50:14 <Pseudonym> And there are data structures which are "equivalent".
15:50:23 <ski> (and  List a = 1 / 1 - a  :)
15:50:26 <ski> yes
15:50:44 <ski> observationally equivalent implementations of ADTs
15:50:52 <Pseudonym> To go back to the BST example, BSTs with metadata to help maintain the balance condition and BSTs without (but still with the balance constraint) are equivalent.
15:51:03 <Pseudonym> In principle, it should be possible to prove that using categoty theory.
15:51:32 <ski> without the metadata, you have to recompute that every time, no ?
15:51:36 <Pseudonym> You should be able to prove that X * Y = X if Y can be derived from X.
15:51:40 <ski> e.g. height of tree
15:51:41 <Pseudonym> Correct.
15:52:11 <Pseudonym> See, I have this idea in my head that working programmers could use this to work out what data is redundant and what isn't.
15:52:20 <Pseudonym> And to manipulate data structures into equivalent data structures.
15:52:30 <ski> (if the "correct" Y info is paired with an X, yes. i.e. the corresponding one)
15:52:45 <Pseudonym> There should be a way to systematically optimise your data structure for some operation.
15:52:57 <Pseudonym> e.g. for easy balancing, in the caset of balanced BSTs.
15:53:11 <Pseudonym> Do you get what I'm driving at?
15:53:30 <ski> or storing the length of a linked list in a list header
15:53:34 <Pseudonym> Right.
15:54:04 <Pseudonym> Similarly, Chris Okasaki has produced list-like structures with O(1) concatenation, or O(1) reverse.
15:54:15 <ski> it'd be cool if the system could do that kind of thing automatically (if one has stated that one want it, of course)
15:54:20 <Pseudonym> Right.
15:54:44 <Pseudonym> Even if you can't, though, it should be possible to provide a language to do this.
15:54:48 <Pseudonym> Using category theory.
15:54:48 <ski> or, at least semi-automatically
15:55:08 <ski> i.e. without changing the (source-level) datatype at all
15:55:10 <Pseudonym> By "language", I mean notation for the data structure designer, not programming language.
15:55:27 <ski> hmm
15:55:46 <Pseudonym> I have a potential book title in my head: Category Theory for the Working Programmer.
15:55:55 <Pseudonym> It will almost certainly never get written.
15:55:58 <ski> (i was thinking of prog.lang. support for some of these kind of things)
15:56:05 <ski> heh :)
15:56:12 <Pseudonym> But it's something that I've been thinking about reading this book.
15:56:30 <Pseudonym> I've found that trying to actually implement the examples in Haskell has helped a lot.
15:56:32 <ski> i've recently been thinking about retracts in relation to ADTs
15:56:39 <Pseudonym> Oh?
15:57:22 <Pseudonym> Incidentally, there's also a book on API design that desperately wants to be written.
15:57:33 <Pseudonym> There's going to be a lot of universal algebra and coalgebra in it.
15:58:08 <ski> it seems (IMHO) to be somehow related to ADTs where you have a normalizing/canonicalizing function, and the data is either in the canonical form, or one is using a value to represent an equivalnce class of values (in the impl./repr. type)
15:58:16 * Pseudonym nods
15:58:31 <Pseudonym> A good example is Rational, which has a simple "normalised" form.
15:58:47 <Pseudonym> Or you can implement equivalence as so:
15:58:51 <ski> some thoughts are on http://www.mdstud.chalmers.se/~md9slj/code/Retracts.hs
15:58:59 <ski> right
15:59:06 <Pseudonym>   n1 :% d1 == n2 :% d2  = n1*d2 == n2*d1
15:59:09 <ski> can you read minds ?  :)
15:59:13 <Pseudonym> :-)
15:59:39 <Pseudonym> No, but I've re-implemented Rational more times (in pre-Haskell languages, mostly Miranda) more times than I remember.
15:59:41 <ski> anyway, this normalization business seems to be realted to retracts, IMHO
16:00:37 <Pseudonym> Damn, you're right.
16:00:41 <Pseudonym> That is really, really deep.
16:00:44 <skew> hi folks
16:00:50 <Pseudonym> G'day skew.
16:01:12 <skew> discovering deep connections between everything, I see
16:01:19 <skew> that's what category theory is for, I suppose
16:01:23 <Pseudonym> Yes.
16:01:44 <ski> didn't Miranda had some kind of "law" concept ?
16:01:44 * ski has never looked much at Miranda
16:01:44 <ski> the normalize function seems to be the idempotent in the retract
16:02:22 <ski> skew : hi
16:02:22 <ski> Pseudonym : i got the idea when i was reading about retracts in the book :)
16:02:24 <Pseudonym> So let's think for a moment.  We'll pick an operation on Rational and its retract.
16:02:33 <Pseudonym> What's a good operation?
16:02:56 <ski> isn't Rational the retract (of e.g. (Integer,Integer))
16:02:59 <ski> ?
16:03:06 <Pseudonym> Hang on.
16:03:09 <Pseudonym> Let me think about that.
16:03:10 <ski> which operation do you mean ?
16:03:38 <Pseudonym> What's the injection operation for which Rational is the retract?
16:04:02 <Pseudonym> Oh...
16:04:04 <Pseudonym> Duh, sorry.
16:04:06 <Pseudonym> I get it now.
16:04:07 <ski> Pseudonym : (i've talked about this two times before on #haskell, i think. so perhaps one might look it up in the logs ..)
16:04:23 <ski> it depends on what kind of implementation you do, methinks
16:04:31 <skew> do these have something to do with adjoints?
16:04:44 <ski> skew : i dunno
16:04:52 <Pseudonym> skew: Possibly. I didn't understand adjoints (in the category theory sense) when I read about them.
16:04:53 <ski> skew : i haven't grokked adjoints yet
16:05:02 <skew> google is cluttered up with people retracting reviews and whatnot.
16:05:05 <Pseudonym> I understand adjoints in linear algebra and operator calculus, though.
16:05:18 <skew> and MacLane doesn't seem to talk about retracts
16:05:36 <ski> retracts actually seem to be quite a simple subject
16:05:42 <ski> easy to grasp
16:05:49 <Pseudonym> A is a retract of B if s : A -> B and r : B -> A with r . s = (id :: A -> A)
16:06:01 <ski> (but perhaps with deeper connections to things :)
16:06:09 <ski> rightee
16:06:18 <skew> ah, okay. nice and simple then
16:06:27 <Pseudonym> Rational is a retract of (Integer,Integer) if s :: Rational -> (Integer,Integer)
16:06:33 <ski> yes
16:06:37 <Pseudonym> r :: (Integer,Integer) -> Rational
16:06:42 <ski> there is at least two different implementations
16:06:45 <Pseudonym> and r . s = (id :: Rational -> Rational)
16:07:00 <ski> the canonicalize-impl. and the equiv-class-impl.
16:07:09 <ski> right
16:07:14 <Pseudonym> If we take r as canonicalising...
16:07:20 <Pseudonym> Then r . s = id
16:07:22 <Pseudonym> That's true.
16:07:25 <ski> and  s . r is the canonicalizer
16:07:29 <Pseudonym> On the other hand, right.
16:07:38 <Pseudonym> s . r is the divide-by-gcd-of-both operations.
16:07:45 <Pseudonym> Which is indeed idempotent.
16:07:50 <ski> yes
16:07:52 <Pseudonym> You should write this up and put it under StudyGroup too.
16:07:59 <ski> perhaps :)
16:08:27 <Pseudonym> class Retract a b where
16:08:30 <ski> if it really is a useful idea
16:08:49 * ski is unfortunately quite modest
16:08:54 <Pseudonym>     include :: b -> a
16:08:58 <Pseudonym>     retract :: a -> b
16:09:07 <skew> this seems to be related to views as well
16:09:10 <ski> section :: b -> a
16:09:12 <Pseudonym> Yes, it does.
16:09:15 <ski> retraction :: a -> b
16:09:18 * Pseudonym nods
16:09:26 <ski> skew : right
16:09:47 <Pseudonym> It also reminds me of the Ralph Hinze binary tree paper.
16:09:48 <ski> (the book uses those names)
16:09:54 <ski> where ?
16:10:35 <ski> (which name ?)
16:11:04 <Pseudonym> http://www.informatik.uni-bonn.de/~ralf/publications/SearchTree.ps.gz
16:11:08 <ski> thanks
16:11:16 <Pseudonym> Had to look it up.
16:12:54 <ski> hmm
16:12:55 <skew> it looks like an adjunction is related, but with functors
16:13:07 <ski> which ?
16:13:29 <ski> oh, sorry. misread you
16:14:31 <skew> according to MacLane, and adjunction of categories X and A is a pair of functors, F:X->A and G:A->X, and a natural transformation for some consistency
16:15:20 <skew> the natural transformation requires that for any pair of elements of x in X, a in A there is a natural bijection from the arrows on Fx,a and x,Ga
16:15:58 <ski> i haven't grokked natural transformations yet, either. sorry :)
16:16:15 <skew> natural transformations are about as far as I really understand
16:17:11 * Pseudonym nods
16:17:23 <ski> skew : i forgot, are you in the StudyGroup, as well ?
16:17:33 <skew> nope
16:17:35 <skew> what is that?
16:17:36 <ski> ok
16:17:45 <ski> @wiki StudyGroup
16:17:45 <betabot> http://www.haskell.org/hawiki/StudyGroup
16:18:56 <ski> Pseudonym : so were you going to continue ?
16:19:15 <Pseudonym> Uhm... no, I think I'd finished.
16:19:35 <skew> Pseudonym, did you look at ports?
16:19:41 <Pseudonym> I can tell you what an adjoint is in calculus, incidentally.
16:19:48 <Pseudonym> We can see if it's related.
16:19:48 <skew> you mentioned something about goffin, I think
16:20:12 <Pseudonym> I haven't looked closely at ports, but I understand that it's like COncurrent.Channel, right?
16:20:31 <skew> except enpoints are first class values, and it's many to many
16:20:36 * Pseudonym nods
16:21:10 <skew> forkProcess changed in 6.2, but other than that it builds and runs
16:23:26 <skew> it seems like it should be well suited for what you were doing
16:23:37 * Pseudonym nods
16:23:44 <skew> or rather, well suited for dynamically rearanging the communication structure
16:23:47 <Pseudonym> OK, I'll look at it more closely, thanks for the tip.
16:23:56 <skew> types could be an issue
16:45:54 <blackdog> found a beautifully strange bug at work today in the xemacs haskell mode
16:46:25 <blackdog> everything works fine unless your program typechecks ok, in which case it hangs xemacs. :)
16:46:42 <ski> heh :)
16:48:06 <blackdog> bad programmer! include more bugs!
16:48:30 <Pseudonym> You can have some bugs of mine if you like.
16:48:43 <blackdog> you sure? don't leave yourself short...
16:48:53 <Pseudonym> I have plenty to go around.
16:50:16 <ski> cybermanco : hi
16:50:27 <Pseudonym> How about a few off-by-one errors?
16:50:41 <Pseudonym> I'm also not using my offside rule violations.
16:51:32 <cybermanco> hi
16:51:34 <blackdog> off-by-one errors are no good to me, they don't show up till runtime
16:51:39 <cybermanco> news about almbdabot?
16:51:45 <Pseudonym> @yow
16:51:45 <betabot> My forehead feels like a PACKAGE of moist CRANBERRIES in a remote
16:51:45 <betabot>  FRENCH OUTPOST!!
16:51:49 <cybermanco> it's working now?
16:51:58 <Pseudonym> Not sure why it's betabot.
16:52:06 <Pseudonym> betabot: Explain yourself.
16:52:07 <betabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
16:52:21 <Pseudonym> Oh!
16:52:26 <Pseudonym> Moniker error!
16:52:33 <ski> it thinks it's someone else !
16:53:01 <ski> Pseudonym : whatis Moniker
16:53:07 <Pseudonym> @wn moniker
16:53:08 <betabot> *** "moniker" wn "WordNet (r) 2.0"
16:53:08 <betabot> moniker
16:53:08 <betabot>      n : a familiar name  for a person (often a shortened version of
16:53:08 <betabot>          a person's given name); "Joe's mother would not use his
16:53:09 <betabot>          nickname and always called him Joseph"; "Henry's nickname
16:53:11 <betabot>          was Slim" [syn: {nickname}, {cognomen}, {sobriquet}, {soubriquet
16:53:13 <betabot> ]
16:53:44 <ski> ok
17:12:24 <Pseudonym> class (Graph g1 d1 a1, Graph g2 d2 a2) => GraphMap g1 d1 a1 g2 d2 a2 where
17:12:24 <Pseudonym>     fD :: g1 -> g2 -> d1 -> d2
17:12:25 <Pseudonym>     fA :: g1 -> g2 -> a1 -> a2
17:12:34 <Pseudonym> Hmmm.
17:12:52 <Pseudonym> No, because there can be multiple maps in general.
17:12:56 <Pseudonym> Hmmm.
17:13:39 <Pseudonym>     fD :: (Graph g1 a1 d1, Graph g2 a2 d2) => g1 -> g2 -> d1 -> d2
17:13:40 <Pseudonym>     fA :: (Graph g1 a1 d1, Graph g2 a2 d2) => g1 -> g2 -> a1 -> a2
17:13:52 <Pseudonym> I'll use that instead of making a typeclass.
17:14:43 <ski> hmm
17:15:02 <Pseudonym> Maybe.
17:15:20 <Pseudonym>     fD g1 g2 . s g1 = s g2 . fA g1 g2
17:15:22 <Pseudonym>     fD g1 g2 . t g1 = t g2 . fA g1 g2
17:15:31 <Pseudonym> Those are the identities, then.
17:16:17 <ski> mm
17:25:30 <Pseudonym> instance (Graph g1 d1 a1, Graph g2 d2 a2)
17:25:31 <Pseudonym>         => Graph (g1,g2) (d1,d2) (a1,a2) where
17:25:31 <Pseudonym>     s (g1,g2) (a1,a2) = (s g1 a1, s g2 a2)
17:25:31 <Pseudonym>     t (g1,g2) (a1,a2) = (t g1 a1, t g2 a2)
17:25:35 <Pseudonym> That looks right, doesn't it.
17:25:43 <Pseudonym> ('m using s and t here instead of start and end.
17:25:44 <ski> yes
17:28:22 <Pseudonym> instance (Graph g1 d1 a1, Graph g2 d2 a2, Graph g3 d3 a3)
17:28:22 <Pseudonym>         => Graph (E3 g1 g2 g3) (E2 d1 d2 d3) (E3 a1 a2 a3) where
17:28:22 <Pseudonym>     s (Inj1 g) (Inj1 a) = s g a
17:28:22 <Pseudonym>     s (Inj2 g) (Inj2 a) = s g a
17:28:23 <Pseudonym>     s (Inj3 g) (Inj3 a) = s g a
17:28:29 <Pseudonym> E3 = Either3
17:28:35 <Pseudonym> Also correct?
17:28:47 <Pseudonym> And t is similar.
17:28:53 <ski> hmm
17:29:32 <ski> s (Inj1 g) (Inj1 a) = Inj1 (s g a)
17:29:33 <ski> ?
17:29:36 <ski> and so on
17:29:45 <Pseudonym> Right.
17:43:19 <Pseudonym> Ah, wrong.
17:43:29 <ski> oh ?
17:44:07 <Pseudonym> data Sum3 a b c = Sum3 a b c
17:44:14 <Pseudonym> instance (Graph g1 d1 a1, Graph g2 d2 a2, Graph g3 d3 a3)
17:44:15 <Pseudonym>         => Graph (Sum3 g1 g2 g3) (E2 d1 d2 d3) (E3 a1 a2 a3) where
17:44:15 <Pseudonym>     s (Sum3 g1 g2 g3) (Inj1 a) = Inj1 (s g1 a)
17:44:15 <Pseudonym>     s (Sum3 g1 g2 g3) (Inj2 a) = Inj2 (s g2 a)
17:44:15 <Pseudonym>     s (Sum3 g1 g2 g3) (Inj3 a) = Inj3 (s g3 a)
17:44:19 <Pseudonym> Do you see why?
17:44:51 <ski> hmm
17:44:59 <ski> oh, right
17:45:30 <ski> though the values in the Grapg type are just dummy values, no ?
17:45:44 <ski> s/Grapg/Graph/
17:45:58 <Pseudonym> Yes.  I'm passing a value as a proxy for a type.
17:46:27 <Pseudonym> @wiki TraitsTypeclass
17:46:27 <betabot> http://www.haskell.org/hawiki/TraitsTypeclass
17:47:43 <ski> hmm
17:49:58 <ski> data Graph = Arr :: *  &  Dot :: *  &  source :: Arr -> Dot  &  target :: Arr -> Dot
17:50:09 <Pseudonym> Yes.
17:50:15 <ski> we'd like something like that, i think
17:50:31 <Pseudonym> Would instantiable modules help?
17:50:40 <ski> what's that ?
17:50:41 <Pseudonym> Implement Graph as a module?
17:50:46 <ski> hmm
17:50:56 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/first-class-modules/
17:51:38 <ski> is that somewhat similar to how Cayenne does it ?
17:51:48 <Pseudonym> Dunno.
17:52:05 <ski> (in Cayenne a module is just a record)
17:52:33 <ski> (dependent record, of course. with support for both concrete and abstract fields)
17:52:51 <skew> Is there a live Cayenne compiler?
17:53:16 <skew> I had trouble getting lml to build the last time I tried
17:53:32 <ski> skew : i downloaded one for some time ago
17:53:37 <ski> (from kosmikus)
17:53:58 <ski> (i haven't tried building lml, though)
17:54:32 <skew> it's a pitty how things tend to bitrot around here.
17:55:17 <ski> at caltech ?
17:55:23 <skew> no, haskell things
17:55:27 <ski> oh
17:55:28 <skew> fudgets
17:55:30 <skew> for one
17:55:34 <ski> mm :(
17:56:57 <skew> hmm. cayenne needs hbc and lmlc to build, both of which seem to be unmaintained.
18:02:38 <ski> bah !
18:03:26 <ski> i've ran out of letters. crappy finite alphabet !
18:03:35 <skew> use unicode
18:04:00 <ski> i need a successor to 'b' that is not 'c'
18:04:12 <Pseudonym> C++?
18:04:22 <Pseudonym> Oh, I know.  BCPL.
18:04:27 <ski> aargh :)
18:04:37 <skew> á¸?
18:04:45 <ski> skew : ?
18:04:50 <skew> Ã¾?
18:05:03 <ski> skew : sorry ?
18:05:04 <skew> doesn't your IRC client do unicode characters?
18:05:24 <ski> no, i guess not
18:05:50 <ski> ("<skew> a,??","<skew> A??" is what i see)
18:06:13 <skew> well, that was a b with an underbar, and a thorn (with looks like a b with a tail)
18:06:39 <ski> ok
18:06:54 <Pseudonym> @wiki StudyGroup/GraphExamplesInHaskell
18:06:54 <betabot> http://www.haskell.org/hawiki/StudyGroup/GraphExamplesInHaskell
18:07:04 <Pseudonym> ski, I'd be interested in feedback.
18:07:11 <Pseudonym> (Seeing as I credited you as a co-author.)
18:07:51 <ski> heh :)
18:08:01 <ski> well, i'll look at it now
18:08:37 <Pseudonym> Ah, wiki links don't work inside {{{ }}}.
18:08:52 <ski> hmm, btw (at least if it is any good :), shouldn't there be a link from StudyGroup to that page ?
18:09:12 <Pseudonym> Yes, but I want to make sure it's good enough first.
18:09:30 <Pseudonym> I need lunch.  BBS
18:09:35 <ski> ok
18:10:41 <ski> hmm, perhaps we should change Sum3 to (,,) ?
18:10:43 <ski> not sure
18:12:55 <ski> data GraphMap g0 g1 = forall a1 a2 d1 d2. (Graph g1 a1 d1, Graph g2 a2 d2) => GraphMap {fD :: g1 -> g2 -> d1 -> d2,fA :: g1 -> g2 -> a1 -> a}
18:13:01 <ski> would that work ?
18:13:35 <ski> oh
18:13:57 <ski> data GraphMap g0 g1 = forall a1 a2 d1 d2. (Graph g1 a1 d1, Graph g2 a2 d2) => GraphMap {fD :: d1 -> d2,fA :: a1 -> a2}
18:14:09 <ski> is better, i think
18:17:03 <ski> ok, i see that you don't want to use (,,) instead of Sum3
18:18:26 <ski> (though, i'm still not sure if (,,) might be appropriate, anyway)
18:19:04 <skew> what's that about Sum3 being a reified type for E3?
18:20:29 <ski> we want to use the type (E3 g0 g1 g2) as a value
18:20:43 <skew> and then Sum3 is used for the parent graph
18:20:51 <ski> but, we insted use dummy values of the graph types, to pass to s and t
18:20:58 <skew> I understand the sends of refied now
18:21:04 <skew> the sense.
18:21:30 <ski> so we need a type with a dummy *value* that corresponds to the *type* (E3 g0 g1 g2)
18:22:47 <ski> i.e. that "dummy" value is essentially a record/tuple containing the dummy values corresponding to the types g0,g1,g2
18:23:02 <skew> yeah, that was the use of reified there.
18:23:41 <skew> I didn't understand you were trying to reify the type E3 a b c with some value
18:24:37 <ski> Pseudonym : perhaps we could use a type like "data BiImpl a b = BiImpl {forward :: a -> b,backward :: b -> a} for the proofs ?  (just an idea/thought)
18:51:31 <Pseudonym> Back.
18:53:17 <ski> ok
18:54:31 <Pseudonym> Yes, I'm not happy with the representation of maps.
19:20:15 <Pseudonym> OK, moved the digression about Sum3 onto a new page.
19:24:13 <Pseudonym> Reorganised the StudyGroup page a bit.
19:33:56 * ski just discovered a funny part in the logs
19:34:02 <Pseudonym> Oh?
19:34:16 <ski> Pseudonym : will look at the page again, soon
19:34:49 <ski> yeah, an "argument" between you and Riastradh :)
19:35:00 * Pseudonym laughs
19:35:08 <Pseudonym> Oh, I think I know the one you mean.
19:36:58 <Riastradh> I don't.  Which one?
19:37:11 <Riastradh> Oh, the one where we tried to out-arcanify each other?
19:37:15 <Pseudonym> This one, fool!
19:38:05 <Pseudonym> (Self referential _and_ topical.  Damn I'm good!)
19:40:13 * Riastradh reflects Pseudonym out of the channel and proceeds to erase his nodes.
19:52:48 <ski> hmm, how to rename wiki pages ?
19:53:04 <Pseudonym> I don't think you can.
19:53:10 <Pseudonym> Make a new one and clear the old one, pretty much.
19:53:13 <ski> ok, hmm
19:53:54 <Pseudonym> Sent something to haskell-cafe about this.
19:54:03 <Pseudonym> I do think that reified types might be a useful language addition.
19:54:41 <Pseudonym> At the moment, there are only two situations where I've found a use for it, but I suspect more uses would be found if it were standard.
19:55:29 <Jerub> Pseudonym: bear in mind, thats the attitude that brought perl to the point it is today.
19:55:45 <ski> (ok, there, done ! :)
20:03:20 <Pseudonym> Jerub: This is a good point.
20:03:38 <Pseudonym> The thing is, though, that GHC is already based on second-order lambda calculus internally.
20:03:46 <Pseudonym> How hard would it be to expose that to the programmer?
20:04:03 <Pseudonym> It's not like it's an inelegant implementation detail.
20:04:17 <Pseudonym> Indeed, it might make it easier to specify the language.
20:04:36 <Jerub> Pseudonym: I don't actually know what you're talking about, I'm just pointing out that "if it existed I'd probably use it" isn't a motivation for a language feature.
20:05:05 <Pseudonym> True.
20:05:16 <Pseudonym> Well, Simon P-J thought he'd use it, too.
20:05:38 <Pseudonym> FWIW
20:05:53 <Pseudonym> That slightly increases its chances of getting implemented. :_)
20:07:01 <Jerub> well, you've presented some valid use-cases.
20:15:43 <Pseudonym> Actually, my first proposal got rejected.
20:16:08 <Pseudonym> It wasn't to have reified types.  It was actually a much simpler proposal which was no-demand arguments.
20:16:30 <Pseudonym> But I think reified types is a better idea.
20:17:05 <Pseudonym> Mind you, it's probably only one small step to reified typeclasses.
20:17:38 <ski> proposal, where ?
20:17:46 <ski> what is "no-demand arguments" ?
20:18:36 <Pseudonym> http://www.haskell.org/pipermail/haskell/2003-June/012158.html
20:29:46 <Pseudonym> ski, I'm going to remove some stuff from that "duel"
20:30:22 <ski> ok
20:30:37 <ski> some joins and quits and other stuff are irrelevant, i guess
20:30:50 <Pseudonym> Also, a third party is mentioned who doesn't need to be.
20:31:28 <ski> 'twas a bit boring to strip all the time info from every row, so i haven't edited it as much as i should, i guess :/
20:32:03 <ski> yes, just edit out irrelevant stuff !
20:33:14 <Pseudonym> There's another duel on the quotes page.
20:33:39 <Pseudonym> I think.
20:34:01 <Pseudonym> Oh, that's moved off too.
20:34:18 <ski> which ?
20:34:37 <Pseudonym> There used to be on ethere, anyway.
20:35:27 <Riastradh> Which one was that?  The one with Igloo and shapr dualing each other?
20:35:32 <Pseudonym> Yes.
20:35:48 <Riastradh> Uh, that's still there.
20:35:59 <Riastradh> Right after I asked 'What does HFL stand for?'
20:35:59 <Pseudonym> So it is.  My search string was wonky.
20:36:44 * Pseudonym assumes that coffee is the dual of ffee
20:37:11 <ski> what's ffee ?
20:37:18 <Pseudonym> No idea.
20:37:36 <ski> oh
20:37:46 * ski was a bit dense
20:38:18 <Cale> coffee is dual to theorems.
20:38:32 <Pseudonym> No, coffee is necessary, but not sufficient.
20:38:40 <Cale> mathematicians turn coffee into theorems, and comathematicians turn theorems into coffee.
20:39:22 <ozone> Pseudonym: nice proposal
20:39:33 <ski> Cale : is that an iso ?  or is it a section-,retraction-pair ?
20:39:44 <Pseudonym> ozone: Which one?
20:39:56 <Pseudonym> Well, coffee isn't idempotent.
20:39:56 <ozone> traits/no-demand arguments
20:40:17 <Pseudonym> Thanks, though I think reified types might be better.
20:40:29 <ozone> what do you mean by reified types?
20:40:43 <ozone> the only definition of reified i know of is from template haskell ...
20:40:49 <Pseudonym> ozone: Are you in the category theory StudyGroup?
20:41:07 <ozone> Pseudonym: no, i have rather little knowledge of category theory
20:41:12 <Pseudonym> Ah, OK.
20:41:23 <ozone> this is going to take longer than 30 seconds to explain, huh? :)
20:41:29 <Pseudonym> No.
20:41:35 <ozone> excellent
20:41:46 <Pseudonym> But if you were, it would take 0 seconds to explain because I could just point you to a page which uses the category theory material as an example.
20:42:26 <Pseudonym> The idea behind a traits typeclass is that you need to associate things with a type, not a value.
20:42:31 <Pseudonym> Did you get that much?
20:43:13 <ozone> yes
20:43:23 <Pseudonym> OK.
20:43:38 <ozone> i do that fairly frequently myself ... pass 'undefined' as a parameter just to get the type checker to resolve overloading
20:43:42 <Pseudonym> Right.
20:43:58 <Pseudonym> The thing is, you don't actually want to pass a value.  That's just a "proxy" for a type.
20:44:07 <Pseudonym> What you really want to pass is a type.
20:44:18 <ozone> i see
20:44:30 <Pseudonym> So the idea is to allow types to be arguments to functions.
20:44:51 <ozone> you can reify types right now with TH
20:44:55 <ozone> you cannot splice them in yet
20:45:01 <ozone> anyway, go on
20:45:02 <Pseudonym> You don't want to say: mantissaDigits (undefined :: Float)
20:45:11 <Pseudonym> What you want to say is: mantissaDigits Float
20:45:26 <Pseudonym> Or something like it.
20:45:32 <Pseudonym> The syntax is a problem.
20:45:41 <ozone> hmm, so would you write mantissaDigits as a standard top-level function?
20:45:49 <ozone> (instead of using a type class)
20:45:54 <Pseudonym> It'd probably still be in a type class.
20:46:37 <Pseudonym> Traits typeclasses are a decent workaround.
20:46:46 <ozone> you could do that right now by writing 'mantissaDigits [| Float |]'
20:46:53 <Pseudonym> OK.
20:46:57 <Pseudonym> Can you pattern match on types?
20:46:59 <ozone> (if you use TH)
20:47:11 <Pseudonym> That's the situation that came up today.
20:48:55 <Pseudonym> I can't really explain the example in detail (it's on the wiki if you care), but I had a situation where I had a type like "Either a b" and I needed to pull out a and b to pass to another function.
20:49:18 <ozone> right
20:49:35 <ozone> writing '[t| Float |]' returns a value of :: TypeQ
20:49:35 <Pseudonym> In fact it was this type:
20:49:39 <Pseudonym> -- "E" is short for "Either"
20:49:39 <ozone> so you could pattern match on that
20:49:39 <Pseudonym> data E3 a b c = Inj1 a | Inj2 b | Inj3 c
20:49:47 <ozone> (TypeQ is a type defined in Language.Haskell.THSyntax)
20:50:06 <Pseudonym> So what I did was created another type:
20:50:11 <Pseudonym> data Sum3 a b c = Sum3 a b c
20:50:20 <Pseudonym> And passed that as an argument.
20:50:28 <Pseudonym> Sum3 is a "reified type".
20:50:38 <Pseudonym> Because it's a value which represents the type.
20:51:07 <Pseudonym> @foldoc reify
20:51:09 <betabot> *** "reify" foldoc "The Free On-line Dictionary of Computing (27 SEP 03
20:51:09 <betabot> "
20:51:09 <betabot> reify
20:51:09 <betabot>      
20:51:10 <betabot>         To regard (something abstract) as a material thing.
20:51:12 <betabot>      
20:51:14 <betabot>         (1995-03-07)
20:51:16 <betabot>      
20:51:26 <Pseudonym> Get the idea?  An abstract thing (a type) is being used as a material thing (a value).
20:51:49 <ozone> i see, so that's the definition of reify
20:51:56 <Pseudonym> Yes.
20:51:58 <Jerub> @yow
20:51:58 <betabot> BRYLCREAM is CREAM O' WHEAT in another DIMENSION..
20:52:00 <ozone> ok, with TH, [| e |] reifies e
20:52:04 <Pseudonym> It's actually a term from philosophy, I think.
20:52:14 <Riastradh> Reify is a cool term.
20:52:17 <Pseudonym> Like how the ancients personified concepts with deities.
20:52:42 <ski> (who ski
20:52:46 <ozone> Pseudonym: [| expr |] reifies an expression, [d| decl |] reifies a declaration, [t| type |] reifies a type
20:52:53 * Pseudonym nods
20:53:10 <ozone> so it gives the expr/decl/type to you as a data structure which is basically the AST
20:53:11 <Pseudonym> I'm not sure you could use that to do run-time binding, though.
20:53:17 <ozone> which you can then pattern match
20:53:17 <Pseudonym> TH is done at compile-time.
20:53:22 <ozone> Pseudonym: yes, you're right
20:53:26 <Pseudonym> WHich would make it no worse than C++ templates.
20:53:26 <ozone> you could do it via the dynamic class
20:53:42 <Riastradh> Pseudonym, but, uh, doesn't this all need to be at the type system level for the method dispatch?
20:53:42 <ozone> but that may be a bit evil for your purposes
20:53:52 <Pseudonym> Yes, I think it would be.
20:54:15 <Pseudonym> It might be possible that you could use TH to make a reified type automatically from a type declaration.
20:54:38 <Pseudonym> That at least would make it slightly less painful.
20:54:56 <ozone> Pseudonym: for your specific example though, can't you write 'class Foo f where mantissaDigits :: f' ?
20:55:09 <Pseudonym> But partly, the traits typeclass idiom also encourages using types for _ideas_.
20:55:11 <ozone> (i realise that's a limited, specific example, but it'd work :)
20:55:15 <Pseudonym> For example, GreekLanguage.
20:55:28 <ozone> oh, sorry, no, you can't
20:55:29 <ozone> my bad.
20:56:03 <Pseudonym> Now reified typeclasses would be an excellent thing, IMO.
20:56:16 <Pseudonym> I have no idea what they'd look like, but I already have use cases for them. :-)
20:56:30 <ozone> share an example? :)
20:56:34 <Pseudonym> Sure.
20:56:59 <Pseudonym> sortBy :: (a -> Ord a) -> [a] -> [a]
20:57:40 <Riastradh> (a -> Ord a)?  Are you sure you meant that?
20:57:40 <Pseudonym> Uhm... no, better still:
20:57:54 <Pseudonym> class Ordable scheme a | scheme -> a where
20:58:03 <Pseudonym>     getOrd :: scheme -> a
20:58:18 <Pseudonym> sortBy :: (Ordable scheme a) => scheme -> [a] -> [a]
20:58:26 <Pseudonym> Sorry, I meant:
20:58:29 <Pseudonym>     getOrd :: scheme -> Ord a
20:58:40 <Pseudonym> The idea being that you return a typeclass instance.
20:58:42 <Riastradh> @type LT
20:59:18 <Pseudonym> This is a simple example.  The "compare" function would do just as well here.
20:59:35 <Pseudonym> But then, traits typeclasses do just as well for many situations where reified types would be better.
20:59:42 <Pseudonym> Hmmm.
20:59:45 <betabot> LT :: Ordering
20:59:54 <Pseudonym> Something can't be both "just as well" and "better".
21:00:06 <Pseudonym> Bad English.  But you get the idea, I hope.
21:00:23 <Pseudonym> Another example would be implementing the COM QueryInterface operation.
21:01:01 <ozone> having trouble grokking, please go on
21:01:25 <Pseudonym> OK, another example is typeclass downcasting.
21:01:33 <Pseudonym> class Base a where { baseOp :: a }
21:01:41 <ozone> COM QueryInterface should suffice as an example, i think
21:01:45 <ozone> downcasting will do too :)
21:02:03 <Pseudonym> You understand what I mean by "typeclass downcasting"?  Oh, good. :_)
21:02:17 <ozone> yeah
21:02:33 <ozone> e.g. casting between Num/Rational/etc
21:02:36 <Pseudonym> If you could pass instances as first-class objects, it'd be easy to represent.
21:02:39 <Pseudonym> Right!
21:02:46 <ozone> ahhhhhh.
21:02:49 <Pseudonym> Like Dynamic, only at the typeclass level.
21:02:50 * ozone ahhhhhhhhs
21:03:00 <ozone> hey, very clever.
21:03:53 <ozone> hmm
21:04:02 <ozone> i'm having trouble envisioning how you'd actually _use_ reified instances
21:04:16 <Pseudonym> Me too.  I think it's mostly a syntax problem.
21:04:26 <ozone> i.e. how you'd write code to cast between Num/Rational/etc
21:04:30 <ozone> right
21:05:19 <Pseudonym> You'd probably want a syntax that makes passing typeclass instances as they're done now into implicit parameters.
21:05:38 <ozone> that's what i was thinking
21:09:35 <Pseudonym> I'm guessing that if you reify a typeclass instance, it would look pretty much like a record.
21:09:53 <Pseudonym> data Eq a = { (==) :: a -> a -> Bool }
21:10:00 <Pseudonym> data Eq a = Eq { (==) :: a -> a -> Bool }
21:10:38 <Pseudonym> Though I suppose that newtype would be appropriate here, too.
21:10:57 <ozone> data Eq a = Eq { ...; parents :: [TypeclassInstance] } ?
21:11:01 <ozone> (throwing around ideas)
21:11:06 <SamB> this is very appealing
21:13:17 <Pseudonym> Possibly, yes.
21:16:24 <Riastradh> Pseudonym, yeah, when you make explicit an implicit type dictionary you get an explicit fixed dictionary, i.e. a record...
21:16:31 <Pseudonym> Right.
21:16:41 <Pseudonym> Though the implementation has some freedom in how to implement it.
21:17:17 <Pseudonym> For example, if a typeclass has one parent typeclass, they can be put in the same "vector of words" internally.
22:02:56 <skew> maybe something like let syntax?
22:03:14 <skew> let Ord Int = val in <expr>?
22:03:39 <skew> Ah, I guess you've all been quiet for a while
22:04:58 <skew> reified types and type passing like system F would be really cool
22:05:16 <skew> especially if there was access to the inference engine for typeclasses somehow.
22:21:00 <Pseudonym> Yes.
22:21:04 <Pseudonym> The devil is in the details.
22:21:21 <skew> it seems like this would involve dependant types at some point
22:21:33 <Pseudonym> Perhaps.
22:22:05 <skew> maybe I should look over the first class module paper.
22:22:14 <skew> I remember they had records with type components
22:28:02 <Pseudonym> Anyway, must away.  Nytol!
23:36:27 <shapr> yow!
23:36:39 <skew> hi
23:36:50 <shapr> hey skew
23:36:56 <ski> hi shapr and skew
23:37:08 <shapr> how's california?
23:37:34 <skew> warm
23:43:46 <shapr> that makes sense.
23:44:50 <liiwi> good morning
23:44:54 <skew> hi
