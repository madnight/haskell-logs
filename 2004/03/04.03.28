00:04:54 <skew> Hello
00:06:21 <skew> anybody (interested in my Python interface) here?
00:06:37 <blackdog>  any template-haskell gurus in the house?
00:06:59 <skew> I could pretend
00:07:22 <skew> if it's easy.
00:07:28 <blackdog> ok, that'll do: how do i convince TH to run an IO function at compile time?
00:07:50 <skew> I know I've seen that done
00:08:14 <skew> aargh, haskell.org is down. Can't check the docs
00:08:28 <skew> unsafePerformIO is a big hammer here
00:08:41 <blackdog> I thought i had it - had unsafePerformIO on it inside [| |] brackets, but it still waited till runtime to execute it.
00:08:44 <skew> but I thought the TH monad had IO mixed in or something
00:09:07 <skew> Oh, that's probably a different sort of confusion
00:09:27 <skew> the [| |] brackets are for taking a piece of code appart into a syntax tree
00:09:55 <skew> you would want to be using an IO action inside a $ splice
00:10:13 <blackdog> hm. ok. hold on, i'll try something.
00:10:17 <skew> like $(unsafePerformIO (print "Hello" >> return [| 3 |])
00:10:33 <skew> don't use unsafePerformIO unless you have to
00:11:25 <blackdog> yeah, i know. first rule of haskell club. :)
00:12:04 <skew> Here I mean that I really think that IO is mixed into Q, or there's a spliceIO or something
00:12:42 <skew> and using unsafePerformIO in a splice is as silly as using unsafePerformIO just to get IO at all for code alreay in IO
00:13:34 <blackdog> I'm not much of a TH hacker. Still really don't have a good mental model of what's going on.
00:13:58 <skew> I think I've got that part, I just don't keep the fine details in my skull
00:15:09 <blackdog> brilliant, i see how to do it now. CHeers skew. (Have I met you? I'm losing track of who i met at ICFP...)
00:15:16 <skew> maybe
00:15:25 <skew> not at ICFP certainly
00:15:33 <skew> I wasn't there. Perhaps before on IRC
00:15:41 <blackdog> ah, probably just htat, then.
00:15:51 <blackdog> off to try fun stuff. :)
00:16:11 <skew> okay. just found the source, so I could finally be helpful
00:16:32 <skew> hey, runIO :: IO a -> Q a
00:16:34 <skew> there ya go
00:19:39 <skew> Well, I'm off for a few days (interviewing at Microsoft - should be interesting), but I'll play with the binding more after that
00:19:49 <skew> to whoever is reading logs or something...
01:56:04 <shapr> goood morning #haskell !
01:56:22 <shapr> dennisb: how do I change the block size?
01:56:26 <Cale> good morning shapr
01:59:30 <shapr> hey Cale, what's going on?
02:00:05 <Cale> Not much. I probably should be asleep, but at this point, I think I'll just stay up and go to bed early. I'm feeling quite awake.
02:00:19 <Cale> (It's 5am)
02:00:24 <shapr> yikes
02:00:55 <dennisb> shapr: it's a compile time option. But do you really need to index such big strings/objects
02:01:06 <Cale> I've started on bindings for ecore, which is a library which makes writing simple X apps easy.
02:06:01 <shapr> dennisb: it's email bodies from the haskell mailing lists
02:06:21 <shapr> and I'm doing a foldr over LIKE
02:06:56 <shapr> Cale: is ecore part of the Enlightenment libs?
02:07:02 <Cale> yeah
02:07:07 * shapr googles
02:07:21 <Cale> after doing ecore, I'm going to get evas as well.
02:07:40 <dennisb> shapr: are these LIKE comparisions anchored to the left? or of the form %foo%? If they are like %foo% they can not use the index anyway
02:07:41 <Cale> (basically, I want evas)
02:07:49 <shapr> dennisb: oh, I didn't know that
02:08:01 <shapr> I thought indexing would speed up %foo% comparisons
02:08:08 <Jerub> shapr: no!
02:08:15 <Jerub> shapr: but it will speed up foo% comparisons
02:08:33 <dennisb> and index is just a sorting of the values, if your rows are sorted "afoo", "bfoz" then you can not use that sorting to find %foz% faster
02:08:42 <Jerub> unless you have something equivilent to mysql's FULLTEXT index type.
02:08:52 <dennisb> you could use the sorting to find b%
02:08:56 <Cale> The C types of functions are tricky enough to make the marshalling code come slowly though. Ecore_Event_Filter  *ecore_event_filter_add(void * (*func_start) (void *data), int (*func_filter) (void *data, void *loop_data, int type, void *event), void (*func_end) (void *data, void *loop_data), const void *data);
02:09:19 <dennisb> yes, there is full text searching in pg also, look at the tsearch2 package
02:09:24 <shapr> I already use vacuum and analyze, is there anything else?
02:09:32 <shapr> ok, I'll look for it.
02:09:41 <ustenzel> Cale: are you using a preprocessor, like c2hs?
02:09:51 <Cale> not at the moment. I might
02:09:57 <blackdog> any TH gurus around?
02:10:36 <shapr> g'day blackdog 
02:10:41 <blackdog> oh, hey shapr
02:10:49 <blackdog> sorry, i always forget the pleasantries:)
02:11:02 <shapr> no worries
02:11:15 <shapr> I think that's normal for programmers.
02:11:27 <blackdog> what about SMTP?
02:11:36 <Cale> I don't want plain bindings though. I want to make the code relatively nice to use.
02:11:49 <shapr> is SMTP a pleasantry? 
02:12:01 <Cale> So I have set up algebraic datatypes and a typeclass for ecore events.
02:12:17 <shapr> WASHMail has support for creating emails and sending via SMTP
02:12:24 <shapr> you want to see some demo code?
02:12:55 <blackdog> shapr: well, there's HELO at least
02:13:04 <shapr> EHLO
02:13:08 <shapr> VRFY blackdog 
02:13:34 <shapr> I remember using enlighenment on redhat 5.2
02:15:02 <shapr> yay, tsearch is in postgresql-contrib
02:15:40 * shapr drinks coffee
02:15:50 <Cale> It's rather neat the stuff that they've been working on ever since.
02:16:32 <Cale> http://vx.hn.org/autoshare/enstromish.mpeg
02:16:53 <shapr> 403
02:17:03 <Cale> heh
02:17:25 <Cale> try now?
02:17:37 <shapr> yay
02:18:25 <Cale> that's a little recording of a theme for "iconbar". The motion and all is themeable.
02:19:12 <shapr> I can't play it
02:19:31 <shapr> neither gxine nor aviplay will show it
02:19:48 * shapr wonders
02:20:41 <Cale> that's odd.
02:20:48 <Cale> mplayer works for me
02:21:00 <shapr> I'll try mplayer
02:22:24 <shapr> oh
02:22:39 <shapr> looks like mplayer isn't currently installable on debian
02:23:01 <shapr> alternatively, I could just install enlightenment and try out all the goodies
02:23:48 <Cale> iconbar is in CVS.
02:24:23 <Cale> It's not too hard to build the stuff in CVS now, but it's at different stages of polish. The libraries are what's really starting to look done.
02:25:11 <shapr> any screenshots?
02:25:30 <Cale> http://www.atmos.org/edje/ has some
02:26:19 <shapr> pretty
02:27:33 <shapr> when I was working in Seattle, quite a few people got started using Linux by seeing the various themes for Enlightenment and wanting to have them on their desktop.
02:27:50 <Jerub> shapr: tee hee.
02:27:54 <Jerub> shapr: have you seen xfce4 ?
02:28:05 <shapr> I think I've just heard of it.
02:28:27 <Jerub> shapr: its got lots of themes, a taskbar, a panel, a file manager, and practically nothing else. I really like it.
02:28:37 <Jerub> (except that I use ion becuase of the rodent)
02:28:54 <shapr> yah, I like ion
02:29:41 <shapr> ion has a surprising number of goodies lately
02:30:17 <shapr> I look forward to true transparency in X
02:31:18 <Cale> I look forward to functional transparency in X. Transparency could make for some really neat UI widgets if put to work correctly.
02:31:50 <Jerub> shapr: have you heard about the evil plan I have for my toy language?
02:31:58 <shapr> no, what's that?
02:32:04 <Jerub> shapr: type inference!
02:32:04 <Cale> (google for toolglass)
02:32:30 <Jerub> shapr: compile time and run time type checking, without any type annotations.
02:33:07 <shapr> cool
02:33:28 <shapr> toolglass looks powerful, I want one!
02:33:34 <Jerub> i.e. f(x) { g(); return x+x; } where f(y) is called, where y \notin Addable, will fire the error before g() is called.
02:34:22 <Jerub> (and will fire the error at compile time if possible)
02:35:10 <shapr> amusingly, toolglass is a lot like the unix pipeline idea applied to viewable things
02:35:38 <Cale> yeah
02:36:07 <shapr> it's from 93
02:36:17 <shapr> I want implementation in X
02:36:35 <shapr> I know fresco has/had real transparency
02:38:26 <ustenzel> was this "fresco" a widget kit or a real arternative to X?
02:38:40 <shapr> it was a full alternative
02:38:46 <ustenzel> its predecessor (interviews) was a widget kit -- could that do transparency?
02:38:58 <shapr> http://www.fresco.org/
02:39:46 <shapr> http://www.fresco.org/data/screenshots/xggi-xchat.png
02:39:59 <shapr> that's a transparency screenshot
02:42:06 <ustenzel> Oh, frsco today is not the fresco of '93...
02:42:19 <shapr> hej hram 
02:42:32 <hram> shapr: good day!
02:42:43 <shapr> yes it is
02:42:51 <shapr> I get to spend all of today writing fun code!
02:42:52 <ustenzel> first it was interviews, then it bacame fresco, then it was abandoned, then picked up under the name of berlin and now it is called fresco again and doesn't make any progress.
02:42:59 <shapr> hi svens, looking for Haskell info?
02:43:15 <shapr> ustenzel: I think that's the most accurate summary I've heard yet.
02:43:49 <shapr> I think the various projects on free-desktop.org have more of a chance of success.
02:43:58 <shapr> freedesktop.org
02:44:37 <ustenzel> the sad thing is, fresco with its structured graphics would be a perfect fit for haskell.
02:45:07 <ustenzel> just imagine a gui toolkit where almost no operation is in the IO monad
02:45:09 <shapr> I wonder if there's still a place for Haskell
02:45:21 <shapr> I think there will be
02:45:45 <Cale> I think that Haskell is actually quite a nice language even if used imperatively.
02:46:04 <shapr> one important aspect I see is that graphics drivers for a certain card seem to be nearly as difficult to write as operating systems
02:46:40 <Cale> Of course, you're probably not getting the most out of it if you do that. :)
02:46:59 <shapr> at least, that's the impression I get from hearing the ATI and NVidia people talk
02:47:10 <Cale> It's impressive how complicated graphics cards are getting.
02:49:40 <shapr> something has to change there, I don't want to use closed source drivers with spiffy gfx hardware
02:49:47 <shapr> mostly because the closed source drivers suck
02:57:53 <shapr> what sort of features are handy for mailing list search?
02:57:59 <shapr> any suggestions?
02:58:58 <hram> one should be able to restrict search to certain dates.
02:59:24 <shapr> ah, good point
03:01:51 <hram> one should be able to refine the search (i.e. search within found entries only)
03:03:09 * shapr adds that to the TODO
03:04:31 <Jerub> i have a friend who has some very strange ideas about how to program guis.
03:05:01 <saz> oh?
03:05:40 <Jerub> based on the concept "gui programming sucks", he's considering doing stuff with a functional programming language and stuff like: (this is an example explaining his ideas, using haskell like syntax)
03:06:18 <Jerub> my_func mousepos | abs (mousepos - 500) < 5 = do_foo
03:06:34 <Jerub> so that when the mouse position goes within '5' of 500, do_foo is invoked.
03:07:13 <Jerub> but with the ability to do that with all gui elements and inputs.
03:07:39 <Jerub> he had some very long words to explain it, and references to papers I hadn't read.
03:08:05 <shapr> sounds simple enough
03:10:44 <dennisb> and when he have been working on it a couple of years, adding all things that was needed after all, it's going to be yet another equally complex system
03:10:51 <andersca> hey dennisb
03:11:06 <andersca> I don't think gui programming sucks
03:13:17 <Jerub> andersca: well, his rationale is that he's used enough widgetsets to say that he's never found one that didn't suck, so he's working on writing his own.
03:13:24 <dennisb> gui's need a lot of functions, that's just how it is
03:13:59 <andersca> yeah, what dennis said
03:14:19 <Jerub> dennisb: I think he was more talking about the methodology of programming a gui itself, rather than what the widgetsets are.
03:15:14 <Jerub> i.e. event based guis that fall over and seem to freeze when you couple them with network i/o, unless you take great care, kinda thing
03:15:35 <dennisb> my_func above is obviously a callback, guis are all about creating objects and setting callbacks to handle this and that event. From the above I don't really see anything different
03:16:10 <Jerub> dennisb: *shrug*, I had trouble following what he was saying.
03:16:15 <shapr> what's the pattern here? "unescape '$' . unescape '>' . unescape '<' mid" I'm thinking it's something like 'iterate unescape "$<>"' but I don't think that's right
03:16:20 <shapr> Jerub: get him to show up here :-)
03:17:31 <ustenzel> shapr: foldr (.) id . map unescape $ "$<>"
03:17:44 <shapr> thanks
03:18:18 * ustenzel likes pointless... err... points-free style
03:18:44 <shapr> why do you need the 'id .' part?
03:18:48 * shapr thinks about that
03:19:10 <Cale> foldr (.) id
03:19:14 <Cale> composed with
03:19:17 <ustenzel> shapr: let compose = foldr (.) id in compose . map ...
03:19:23 <Cale>  map unescape $ "$<>"
03:19:42 <shapr> oh, I was thinking of foldr1
03:20:15 <shapr> neat
03:20:40 <Cale> you could probably also use foldr1
03:20:59 <ustenzel> oh, there is a foldr1 -- overlooked that
03:23:16 <shapr> that reminds me, I remember seeing a pattern to foldr (.) over two argument functions, I think it was foldr1 (.(.)) or something, but that's not quite right either
03:24:24 <shapr> oh, I could ask my mailing list oracle
03:24:59 <shapr> http://shapr.homelinux.net/cgi-bin/wash/email?%3C8751.12.213.102.246.1058422795.squirrel@webmail.willamette.edu%3E
03:25:25 <shapr> I'd really like to browse followups and references, that's a good feature to add
03:25:34 <ustenzel> shapr: what would you do with binary functions?  they don't compose easily...
03:26:10 <shapr> hello imaginator, looking for Haskell info?
03:26:57 <shapr> ustenzel: what about something like 'foldr1 ((.)(.))'
03:27:21 <shapr> there's also the stuff mentioned in the email whose url I just mentioned.
03:27:32 <imaginator> shapr: Hi.  Yes, I am.
03:27:57 <shapr> imaginator: ok, looking for a summary, tutorials, implementations, or libraries?
03:28:13 <Jerub> (or help with a university assignment?)
03:28:14 <shapr> or maybe example code or entertaining education applications?
03:29:24 <Jerub> ones = 1:ones
03:29:27 <Jerub> is my favourite funtion
03:29:31 <Jerub> er funktion
03:29:44 <shapr> I think funktion is the germanic spelling.
03:30:02 <Jerub> shapr: its also useful when function refers to a different variable. ;)
03:30:08 <Jerub> or is a keyword in your language.
03:30:09 <Jerub> ;)
03:30:15 <ustenzel> shapr: ah, (.).(.) composes a binary and a unary function giving a binary.  useful.
03:30:20 <shapr> that's a good point
03:31:13 <shapr> anyway ,I just foldr and (.) into my searchy http://shapr.homelinux.net/cgi-bin/wash/search
03:31:29 <imaginator> shapr: I have ghc.  I haven't used it yet though.
03:31:30 * shapr adds multi-list searching
03:31:43 <shapr> imaginator: I like ghc. lambdabot uses ghc.
03:35:56 * imaginator is going through a tutorial now
03:39:58 <imaginator> What languages is Haskell most like?
03:40:22 <imaginator> ML?
03:40:25 <Cale> O'Caml, ML in general, I suppose.
03:40:26 <imaginator> Prolog?
03:40:44 <Cale> Not so much prolog.
03:42:09 <Cale> Too bad haskell.org isn't currently up.
03:45:37 <maihem> imaginator: I think the class system (with multiple parameters) begins to look a little prolog-ish, I wonder how far it could evolve in that direction while guaranteeing that a compile always terminates.
03:46:19 <maihem> but I'm still very inexperienced with haskell :/
03:46:54 <saz> haskell is a bit like prolog
03:46:57 <saz> turned on its head
03:46:58 <saz> imho
03:47:16 <saz> (i learnt prolog after haskell though)
03:47:49 <Cale> I suppose that's true.
03:48:15 <saz> prolog does tree searches as a bonus
03:48:18 <maihem> If you work in the list monad, perhaps (then you get backtracking). But prolog doesn't guarantee much in the way of ordering of solutions, haskell will.
03:48:20 <saz> otherwise, they're pretty similar
03:49:07 <Marvin--> is there a way to make your own type classes derivable without hacking ghc?
03:49:14 <Marvin--> like... using TH or something?
03:49:34 <maihem> Is there a Bucket Monad?
03:49:49 <Igloo> You could do it with TH with different syntax
03:50:16 <shapr> Marvin--: there's the Data.Generics stuff
03:50:22 <Igloo> $(deriveMyClass (mkName MyType)) or similar
03:51:16 <Marvin--> Igloo: huh?
03:51:31 <imaginator> What problem was Haskell created to solve?
03:51:51 <Igloo> "huh?"?
03:51:54 <shapr> afaiu, the fact that Miranda was closed source.
03:51:57 <maihem> heh, All Of Them!!
03:52:22 <Marvin--> Igloo: "with different syntax"?
03:52:42 <Igloo> Yes, i.e. you'd have something like my next line
03:52:54 <Marvin--> oh
03:53:04 <Igloo> I could try and find the example I did if you're interested
03:53:18 <Marvin--> so instead of data Foo = .... deriving (Arbitrary), I'd have $(deriveArbitrary (mkName "Foo")) or something?
03:53:39 <Marvin--> well, if it won't take you too much time
03:53:49 <Igloo> Yup (plus a data Foo = ... line)
03:54:00 <Marvin--> well, yeah :)
03:54:51 <shapr> imaginator: here's my code sample for the impatient - http://www.scannedinavian.org/AvianWiki/HaskellDemo
03:55:34 <Marvin--> I'm trying to figure out how to use Data.Generics to make QC work like GAST, but maybe TH is a better way to go
03:56:14 <Marvin--> wow, acronym overflow
03:56:41 <Marvin--> the example from the gmap2 paper doesn't work at all with e.g. Ints
03:57:08 <liiwi> sproing
03:58:00 <kosmikus|away> Marvin--: why not?
03:58:34 <imaginator> shapr: thanks
03:58:40 <shapr> this is something ozone was working on - http://shapr.homelinux.net/~shae/GenericsTest.hs
03:58:48 <shapr> I never did find out what became of that example
04:00:01 <Marvin--> kosmikus|away: short answer: because for Ints, gfoldl _ z = z
04:01:44 <Igloo> Marvin: http://urchin.earth.li/~ian/Derive-snap-1.tar.gz
04:02:00 <Marvin--> > gmapT (mkT $ \(n::Int) -> (n+1)) [42::Int]
04:02:00 <Marvin--> [43]
04:02:03 <Marvin--> but
04:02:07 <Marvin--> > gmapT (mkT $ \(n::Int) -> (n+1)) (42::Int)
04:02:07 <Marvin--> 42
04:03:09 <Marvin--> Igloo: thanks
04:03:14 <kosmikus|away> yes, but you can extend the generic function in some specific way for Int's, or not?
04:03:26 <Marvin--> wooow, files from the future :-)
04:04:00 <Marvin--> kosmikus|away: that's what I'm trying to figure out
04:07:18 <Marvin--> The problem is that the "theoretical" thing I want to do is generate a lazy list of all possible values of a type. The definition of arbitrary would then just be to pick random elements from that list.
04:07:29 <Marvin--> In practice, this approach sucks for e.g. Ints :)
04:07:49 <Marvin--> so there I'd like to fall back to the normal definition of arbitrary
04:15:46 <Marvin--> hm, I probably have time for one cup of coffee before the roleplaying session
04:18:05 <Marvin--> this code is mutually recursive and seriously evil
04:18:32 <Marvin--> "figure out what constructors the first element of the result list is, and generate the result list based on that"
04:19:39 <imaginator> Thanks for the help.  Have a pleasant chat all, I'm off for zzZ. 
04:20:00 <shapr> imaginator: feel free to ask any Haskell questions here
04:20:12 <imaginator> ok :)
04:21:04 <shapr> is there a general purpose un-shell escaper?
04:21:45 <shapr> any arguments to a CGI script are escaped for safe passage through the shell, like \\$ \\<
04:28:52 * shapr boings happily
04:29:14 <maihem> shapr: I don't think you can do that in general. if every dangerous character is escaped, the shell will unescape some as it goes, and not others. so it will be a solution unique to the shell
04:30:42 <shapr> so I guess I have to find out how apache and the shell do the escaping together
04:30:44 <shapr> that sort of sucks
04:31:04 <shapr> but I have a hackish solution that works for the moment (by turning \x into x)
04:32:23 <maihem> problem is, if  you have \x, what happens if you began with \x, and it was escaped to \\x, then the shell returned it to \x.
04:32:57 <shapr> yes, I know that's a problem
04:33:12 <shapr> that's why it's hackish :-)
04:33:33 <shapr> it's just to unescape email message-ids so I don't think I'll find a literal slash in there
04:34:08 <maihem> I think the best answer is to always do your own escaping for a given shell
04:34:41 <maihem> 'course, you can be limited by having to plug-in to someone elses code
04:34:57 <shapr> apache is calling WASH-CGI and I'm using runWithHook to get the command line arguments
04:35:05 <shapr> so I just take what I'm given
04:36:30 <shapr> as you said, to make a real unescaper I need to know how both apache and the shell handle args
04:42:14 <maihem> I've got this little state machine: http://rafb.net/paste/results/o3064959.html
04:43:36 <maihem> it's output is done at the very last moment (yes, I know, ghc is lazy). But how do I tell it to be only lazy until it gets a newline, or be as eager as possible?
04:43:57 <maihem> instead of waiting until it knows there will be no more incoming information?
04:44:09 <shapr> do you know where it waits?
04:44:38 <shapr> there's useful strictness annotation information in the GHC user manual
04:44:52 <maihem> urgh, not seq ! please not seq!
04:45:03 <shapr> stuff like $! with function application and ! for strict data constructors
04:45:23 <maihem> so I can apply print strictly ?
04:46:02 <maihem> hmm, no I want it to print each element of the list strictly, not wait for a whole list to be made and terminated
04:46:25 <maihem> I need to alter "show" for lists
04:46:31 <maihem> and make "that" strict
04:47:29 <maihem> ah ha! it has to wait for it all because of returning Just [...], Since I'm not bothered with using the maybe monad anymore  I can get rid of that :)
04:47:49 <maihem> I think I'm starting to "Get It"
04:48:02 <shapr> that good, cuz I'm lost
04:49:28 <maihem> it can only be determined if it will return Just [...] or Nothing when the input is complete (EOF). In this particular example it will never return Nothing, but that's probably just GHC not optimising hard enough. perhaps -O2 will help.
04:49:32 <shapr> so, any better name suggestions instead of curryspondence?
04:49:42 <maihem> ?
04:49:47 <shapr> email searchy in Haskell
04:50:01 <maihem> laz-e-mail?
04:50:49 <shapr> neither of those have anything to do with searching
04:50:51 * shapr thinks
04:51:51 <maihem> my-cool-haskell-email-searchy-thing-a-ma-bob ?
04:52:02 <shapr> that's an excellent name, but it's a bit long...
04:52:04 <Cale> it also works quite nicely if you replace getContents with getLine
04:52:21 <shapr> I think I'll just go with searchml for the moment
04:53:08 <maihem> Cale: heh, yeah but it terminates after the first line instead of just producing output :/
04:53:15 <XTL> Or you could tase Firesomething to come up with a name like Powerpanda and use that
04:53:29 <XTL> Not that it says much about the application either :)
04:53:52 <shapr> yah, curryspondence is cute but only mentions haskell and email, not searching
04:55:03 <maihem> shapr: I'll think about it in the launderette
04:55:13 <shapr> ok
05:07:32 <saz> what's an emai searchy?
05:07:56 <shapr> http://shapr.homelinux.net/cgi-bin/wash/search
05:08:30 <saz> aah
05:08:31 <saz> neat
05:09:25 <saz> i like curryspondence (the name)
05:10:00 <shapr> yah, it's cute, but doesn't mention searching. Curryspondence would be better for a Haskell email client.
05:10:05 <saz> yeah
05:10:09 <saz> shail?
05:10:16 <saz> (search-haskell-mail)
05:10:23 <shapr> hm, good idea
05:10:30 <saz> or shmail
05:10:39 <saz> (it sounds like smile!)
05:13:58 <shapr> shmail is a good google word too
05:15:25 <saz> another alternative: shasmail
05:15:34 <saz> i like shmail best though
05:17:59 <saz> Rafterman: a few nights ago.
05:19:03 <Rafterman> yeah, I just always forget to autojoin here
05:19:09 <Rafterman> so I'll be lurking for next time :)
05:19:14 <saz> heh
05:19:39 * themaximus looks in
05:19:47 <shapr> oy, I need a Makefile
05:37:27 <shapr> Makefiles suck
05:40:10 <shapr> or just my understanding of them
05:46:01 <ibid> makefiles suck but many "improvements" over makefiles suck even more
05:46:38 <shapr> my Makefile can create .o files, but not link them
05:46:45 <maihem> hm, what does this mean: ghc -fglasgow-exts -o testy test.hs -O1\ncompilation IS NOT required
05:46:51 <XTL> Yes. Although some things in gmake, for example, are quite useful compared to vanilla make.
05:47:30 <XTL> maihem: That testy was compiled from test.hs and test.hs has not been changed since?
05:48:30 <maihem> ah, that's dumb. Compilation WAS required since it was being done with different options :/ THAT'S what makefiles are for.
05:49:19 <XTL> maihem: Well, you didn't mark the Makefile as a thing to watch, so no :)
05:49:54 <maihem> I didn't use a makefile, I just used the compiler at the command line. It is the compiler that decided it didn't need to run
05:49:57 <XTL> I think that if you change the compiler lines or such, people usually run make clean and make again to make sure everything gets built.
05:50:08 <XTL> And the rules just watch the source and header files.
05:50:25 <XTL> Oh. Well, a compiler might do the same. 
05:50:35 <ibid> ghc does that, yes
05:51:08 <XTL> It's always seemed a bit funny to me when things like gnat or ghc try to move make into the compiler.
05:51:32 <ibid> makes sense to me
05:51:40 <ibid> make is, after all a huge hack ;)
05:51:51 <ibid> kluge
05:52:13 <maihem> ibid, the compiler doesn't know under what terms you wish to rebuild. With a makefile the developer sets the rules.
05:52:23 <XTL> So it's better to add another less capable kludge to fail to replace it?
05:52:57 <ibid> which becomes evident when you start hacking around to make make handle dependencies correctly
05:53:05 <ibid> even in C, it's horrible
05:53:42 <ibid> i have no problem using make as a frontend to ghc --make, though :)
05:53:57 <ibid> but that's mainly because people have accustomed to make, make install, make clean etc
05:54:09 <ibid> maihem: what do you mean, under what terms
05:55:02 <maihem> IMHO, there should be a set of programs to help make rules based on language features (imports, #includes, using), but the compiler knows not the structure of a program written in multiple languages with extra unusual linker manipulations
05:56:32 <shapr> hi phj 
05:56:34 <ibid> maihem: i usually let make handle all that, but ghc gets to chase modules :)
05:56:50 <maihem> it gets moved into the compiler in ghc and javac because therein lies the parser, but the parser could, and IMHO, *should* be separate
05:57:25 <shapr> phj: are you learning Haskell?
05:57:39 <XTL> I often wonder how people doing things like the BSD pkgsrc/ports collections got make to stretch that far. Haven't had the motivation to go look yet, though.
05:57:46 <shapr> I want a tutorial on building Makefiles for GHC :_/
05:57:49 <ibid> well, ghc does have a switch to allows you to generate the make rules, but it's as horrible as cc -M
05:58:08 <shapr> phj: do you have any questions?
05:59:10 <phj> shapr: no now.
05:59:25 <shapr> phj: ok, if you find questions, you can ask here.
06:00:49 <shapr> phj: I live in Sweden, but I was born in the USA
06:01:23 <shapr> ibid: do you have a standard Makefile for GHC-using apps that require various -I -L -i -l args?
06:01:39 <shapr> I'm trying to make mine behave
06:03:03 <ibid> shapr: no, i usually write mine from scratch
06:03:16 <shapr> this is my first Makefile...
06:03:47 <ustenzel> doesn't a simple -package switch cut it?
06:03:47 * shapr adds "read a Makefile tutorial" to his TODO list
06:04:11 <shapr> nope, I need to include and link to HaskellDB and several different parts of WASH
06:04:39 <shapr> my currently working commandline is: ghc --make SearchML.hs -o SearchML -package text -i./WASHCGI -i./Utility -i./WASH -I./WASHCGI -I./Utility -L./Utility -lUtility -package haskelldb -Wall
06:04:42 <ustenzel> and haskelldb/wash don't provide package configs for ghc?
06:04:49 <shapr> haskelldb does
06:05:10 <shapr> I don't know if WASH has a package install
06:05:53 <shapr> oh, I think it does have a package install, but that install has troubles with Debian, or did several version back
06:05:55 * shapr tries again
06:06:23 <ustenzel> whatever, just put the working command line into the makefile and you're done.
06:06:39 <shapr> fair enough
06:10:20 <XTL> If many enough lines seem to have the same thing (switches, commands..) you might want to replace them with a variable
06:10:52 <XTL> It's a shame inference rules aren't more.. functional
06:15:12 <shapr> I've heard rumors of a more functional approach that Igloo's working on
06:15:13 <maihem> this is still being lazy, the terminal should be set to line buffered mode by default on Linux - can anybody suggest where to add strictness notations? http://rafb.net/paste/results/w1575188.html
06:16:51 <XTL> Damed Irix clocks' DST not working...
06:17:10 <shapr> Irix is an exciting operating system.
06:29:52 * shapr beats make with a stick
06:34:14 <saz> hm
06:35:20 <shapr> ?
06:35:42 <saz> oh, nothing, wrong channel :)
06:36:23 <shapr> hi ikegami-- 
06:38:20 <ikegami--> hi
06:38:26 <shapr> are you learning Haskell?
06:38:38 <ikegami--> does www.huskell.org stop now?
06:38:58 <ikegami--> yes
06:39:10 <shapr> yes, haskell.org will be back on Monday
06:39:10 <ikegami--> just learning
06:39:17 <ikegami--> ok, thanks
06:39:27 <shapr> do you have any questions?
06:40:30 <XTL> TZ=EET-2DST,M3.5.0,M10.5.0   Isn't that pretty.
06:40:41 <ikegami--> of course, many ;)
06:41:09 <shapr> anything I can answer?
06:41:41 <shapr> well, I guess it's better than nothing.
06:41:45 <shapr> that Timeone
06:41:47 <shapr> TimeZone
06:42:02 <maihem> is there a version of print where I can say "print low_latency (dosm Top s)" and the IO () that it returns will cause the necessary computations to be done to cause output to begin as early as possible? Obviously latency of the second and third elements of the list could suffer, but I hope there are more rules to be given
06:42:15 <shapr> XTL: do you know dark, Viiru, liiwi, and the other Helsiniki FOSS guys?
06:42:34 <ikegami--> shapr: thanks
06:42:39 <XTL> shapr: No. Not that I know.
06:42:47 <XTL> Not that I know many people either :)
06:42:58 <ikegami--> I have a natural question: where is introductions?
06:42:59 <XTL> Hm.. What's FOSS? Doesn't ring any bells right now?
06:43:07 <shapr> Free Open Source Software
06:43:21 <shapr> ikegami--: I recommend Hal Daume's Yet Another Haskell Tutorial
06:43:23 <ikegami--> maybe on www.haskell.org
06:43:28 <XTL> Doesn't sound familiar in any way.
06:44:12 <shapr> XTL: you don't sound very finnish :-)
06:44:36 <shapr> not that I'm a great judge of finnishness
06:44:51 <XTL> shapr: Really? Can you elaborate? :)
06:45:03 <shapr> ikegami--: http://www.isi.edu/~hdaume/htut/
06:45:07 * XTL gets some tea
06:46:47 <ikegami--> that is just one I want to know
06:46:48 <shapr> maihem: what about mapM_ putStrLn (dosm Top s)
06:46:50 <ikegami--> thank you
06:47:40 <shapr> maihem: wouldn't that print each item of the list as it finished evaluating?
06:47:50 <shapr> hei musasabi 
06:48:08 <musasabi> morning
06:50:17 <maihem> I've never heard of MapM_ :)
06:54:05 <maihem> wOOt!
06:54:15 <maihem> What does MapM_ do?
06:56:30 <maihem> does it cause a series of IO ()'s to be returned instead of one for the entire print statement, allowing the runtime to perform them individually?
06:58:07 <ibid> maihem: iirc, it's sequence_ . map
06:59:21 <maihem> ah, so it causes each IO () to be evaluated completely before the next one begins, thus causing low latency? Thanks shapr, ibid!
06:59:40 <maihem> MapM_ is my holy grail :)
06:59:51 * shapr grins
07:00:40 <maihem> It'll let me keep nearly all my time constraints in the IO Monad. leaving only my memory constraints to worry about ;)
07:00:53 <ibid> maihem: no, it takes an a -> IO b, maps it over a list of a's and builds an IO () action that runs the resulting actions in sequence
07:01:53 <shapr> I *really* wish WASH used ghc-pkg
07:01:56 * shapr grumbles
07:01:57 <maihem> ah, so they could still be done later than possible :/
07:03:06 <maihem> s/\(later\)/much \1/
07:03:16 <ibid> maihem: it is my understanding that whether io actions are performed depends on things outside the action's control, but once one is performed, it is performed right away
07:03:52 <ibid> maihem: the io actions are, afaiuic, the mechanism that causes delayed values to be evaluated
07:05:13 <maihem> so I can reasonably expect an IO action to happen as early as possible?
07:05:34 <ibid> maihem: to happen when it should happen, not earlier or later
07:05:39 <ibid> maihem: unless tricks are being played
07:05:46 <ibid> (such as unsafeInterleaveIO)
07:06:25 <maihem> in my case with shaprs suggestion there is no should, but it still happens right after the terminal provides the input
07:07:32 <shapr> Haskell is lazily evaluated, so code is only executed when you ask for the result.
07:08:10 <shapr> [1..] is an infinite list of numbers, but head $ filter (> 6) [1..] still works in Haskell
07:08:19 <Leimy> :)
07:08:40 <Leimy> yes
07:08:43 <ibid> shapr: haskell is a nonstrict language, nothing requires laziness ;)
07:08:51 <shapr> right, that's true
07:09:06 <shapr> the first version of your code asked to print the entire string of the result
07:09:19 <shapr> this version of your code is printing each part of the result list separately
07:10:34 <maihem> I imagine that a haskell program is a simple statement of truth, and the IO monad constructs the program. iooperation >> iooperation >> iooperation is an IO x that describes a program
07:12:09 <maihem> will each IO x then occur at the earliest time possible after running the program, or at the most efficient time for IO bandwidth, or to cause the least memory to be consumed? or will it be different for each compiler?
07:12:11 <shapr> I imagine each haskell program as a sweater with one loose string. the main method pulls the string, and suddenly the sweater comes unraveled.
07:12:24 <shapr> but only as much of the sweater as you pulled out
07:13:19 <XTL> Hmm.. "This is a statement of truth considering how to perform sorting of incoming e-mail into spam and non-spam using adaptive learning algorithms..."
07:13:27 <ibid> maihem: think of the io monad as a standard imperative programming language; non-io expressions are evaluated lazily but io is done as you'd expect
07:14:07 <ibid> (of course, when you start treating io values as values, it becomes hairy)
07:15:14 <ibid> maihem: but basically, the main io value is initiated at the beginning of execution, and it is executed sequentially as determined by >>=; when it invokes another io action, that action acts like a subroutine in an imperative program
07:15:38 <ibid> only when you start playing with non-io stuff does the laziness come into play for real
07:15:49 <maihem> I know that do { let x = 1 * 1; ley y = 2 * x; print 3 } is equal to an IO b that describes the IO action of printing the character '3', and since x and y are not involved in that, they will not happen. but what stops a haskell implementation from waiting for 10 minutes of user-time before doing it?
07:16:24 <shapr> my email searchy program breaks apart an mbox file, parses each email, and loads them into a database. If I had written this in Python, I would probably have broken the entire file into pieces, parsed each piece, and then loaded them all at once
07:16:52 <shapr> because of the non-strict nature of Haskell, my code actually just gets enough text out of the mbox file to parse an email
07:16:54 <ibid> maihem: what stops the C implementation from waiting ten minutes before outputting hello world in int main(void) { printf("Hello world\n"); return 0; }
07:17:23 <ibid> shapr: only if you are using unsafeInterleaveIO
07:17:42 <ibid> (the standard "lazy" input routines do that)
07:17:42 <shapr> isn't readFile non-strict?
07:17:55 <shapr> ah, ok
07:17:55 <ibid> readFile uses uIIO internally
07:18:15 <XTL> What would stop Java implementation from waiting ten minutes before outputting System.out.println("Hello, world\n"). That I'd like to have.
07:18:33 <musasabi> XTL: well it takes nearly ten minutes ;)
07:18:52 <XTL> musasabi: which is why I'd like to have something to make it stop doing that :)
07:18:56 <shapr> hello world on the Nokia 9210 emulator took twenty minutes
07:18:59 <XTL> Not that I use Java, really.
07:19:12 <maihem> ibid, it is defined by the implementation whether a massive empty for loop occurs before returning, what does the haskell definition say? and to what lengths can a haskell implementation use memory to make the io happen earlier, and how can a programmer - knowing how the computer system will be used - describe the memory to be consumed and the delays thus introduced?
07:19:44 <ibid> maihem: the definition says very little pessimization :)
07:19:53 <ibid> about pessimization
07:20:11 <ibid> maihem: what do you mean "use memory to make the io happen earlier"?
07:20:22 <XTL> But Now I'm tempted to try something again...
07:20:25 <maihem> in C I have to make really complex programs to get any reasonable abuse of memory to improve IO on a complex problem, in haskell, it should be really easy
07:20:30 <shapr> the first email searchy I wrote was strict, and so consumed 1.5GB of ram + swap space shortly before dying, and with zero useful output
07:20:37 <ibid> and reasoning about haskell space/time behaviour outside the io monad is quite hard
07:20:55 <ibid> maihem: ?
07:21:14 <maihem> ibid, imagine a program that has four possible inputs, each causes a really complex computation...
07:21:45 <maihem> it is reasonable to cache the result of each input for the next time they occur if the result of the computation is small,
07:22:19 <maihem> but where does one draw the line, and how can the programmer tell the haskell implementation where to draw that line?
07:22:32 <shapr> but it is reasonable to not cache the result if the result is large, and the CPU cost low
07:22:43 <ibid> the haskell implementation does not generally introduce caching as a matter of optimization
07:22:56 <ibid> it's the programmer's job
07:23:03 <shapr> for just that reason
07:23:34 <maihem> in C the answer is easy, write a complex caching routine. In haskell the logic of your program is really simple and easy, you simply state the nature of the data and how it may be calculated, but how do you describe the caching mechanism, and when to cache?
07:24:04 <XTL> There, I repeated my current personal record for largest Hello, world binary.   18042912 (17MB)
07:24:15 <XTL> gcj on Irix(64). :)
07:24:19 <shapr> scary
07:24:34 <ibid> maihem: by writing the program that way, like in any other programming language
07:24:34 <shapr> the Haskell answer can be as simple using a FiniteMap
07:24:38 <ibid> maihem: haskell is not magic
07:25:33 <shapr> it just feels like it most of the time ;-)
07:25:35 <XTL> Last time I was surprised by a compiler like that was when I noticed I didn't have a dynamic libstdc++ on one machine and ended up with a 3M C++ hello.
07:25:45 <maihem> ibid, yes, but surely I could describe the logic of each calculation separately from the desired memory usage?
07:26:17 <ibid> maihem: hard to say in abstract
07:28:28 <maihem> ibid: imagine an mpeg encoder, how does one stop the implementation from caching the result of each DCT without having to write everything with let x = blah in ... (since there may be some that you wish to cache)?
07:28:54 <shapr> argh, what do I need to include to link in the standard stuff like GHC.Base ?
07:29:10 <maihem> fill the code with case statements and switch between let ... in and where ... after profiling your typical input video?
07:30:00 <maihem> I don't mean to troll, but haskell is beutiful until you get to this sort of thing.
07:30:12 <shapr> you could make an MPEGDecoder monad
07:30:20 <musasabi> How would I implement a randomized algorithm without resorting to adding IO to the signature?
07:30:23 <shapr> and it could cache according to conditions you set
07:30:43 <maihem> how so?
07:30:54 <shapr> monads are great for organizing the piping around and between your computations
07:31:09 <shapr> musasabi: you could use a pseudo-random number generator
07:31:38 <shapr> but the result will always be the same for a given input
07:32:01 <musasabi> shapr: using the same prng for all the things internally would be the best solution.
07:32:28 <shapr> lambdabot's fortune and yow commands use a prng
07:32:45 <musasabi> shapr: the random numbers don't modify the result only how much time it takes to calculate them.
07:32:48 <shapr> the initial seed is gotten from the picoseconds field of the startup time, or something like that
07:32:56 <shapr> huh?
07:33:12 <shapr> maihem: have you seen the Maybe monad?
07:33:23 <maihem> shapr: hmm as an argument to dompegmonad, give the rules used to cache? then the monads implementation chooses between storing in a finitemap or discarding?
07:34:26 <maihem> heh, you and ibid look to be winning this argument quite soundly ;)
07:34:57 <shapr> I didn't do it, blame Wadler and SPJ and the smart guys who wrote all this stuff. :-)
07:37:49 * shapr blindly copies from Igloo's lambdabot Makefile
07:39:26 <maihem> heh, I think I can see it now, list of 8x8 blocks used as key into finitemap, if present, use that value, if not present, calculate and consider adding
07:39:45 <maihem> output is list of 8x8 DCTs :)
07:40:09 <shapr> wowo, it compiles!
07:40:12 <maihem> I don't think it even needs a monad does it?
07:40:15 * shapr basks in the reflected greatness
07:40:41 <shapr> it would be nice to have a monad, because you might want to change the pipes later
07:40:50 <maihem> oh, yeah, you must passs the finite map to the next recursion.
07:40:51 <shapr> hi bruno
07:40:59 <shapr> looking for Haskell info?
07:41:13 <bruno_j_melo> hi!
07:42:39 <shapr> what can we do for you?
07:43:05 <shapr> cool, I can actually make an alpha release of this now
07:43:16 <shapr> I think I like curryspondence for the sheer cheeziness.
07:44:39 <Leimy> shapr: what is it?
07:44:40 <Leimy> :)
07:44:50 <shapr> it's a search program for the haskell mailing lists
07:44:58 <shapr> http://shapr.homelinux.net/cgi-bin/wash/search
07:45:10 <Leimy> cool :)
07:45:12 <Leimy> as a bot?
07:45:22 <bruno_j_melo> i trying to make a raytracer in haskell, but a GOOD raytracer, but without success, do you know any good haskell raytracer (open source)?
07:45:23 <shapr> no, but that wouldn't be hard
07:45:27 <Leimy> oh as CGI? :)
07:45:29 <Leimy> hehe
07:45:51 <shapr> bruno_j_melo: have you seen Wolfgang Thaller's Haskell ray tracer?
07:46:30 <Leimy> I have been dedicating a significant portion of my weekends trying to learn Haskell :)
07:46:38 <shapr> http://www.kfunigraz.ac.at/imawww/thaller/wolfgang/vop-intro.html
07:46:44 <Leimy> the more I get into it the more addictive it gets
07:46:45 <shapr> Leimy: cool, do you have any questions?
07:46:45 <bruno_j_melo> no, i will see now! thank you! :)
07:46:56 <Leimy> shapr: not since I got two really decent books :)
07:46:56 <Leimy> hehe
07:47:05 <shapr> which ones did you get?
07:47:09 <XTL> If I search for "newbie" and pick the first one (date column(?) says "Nothing"), it gives an error
07:47:15 <XTL> http://shapr.homelinux.net:80/cgi-bin/wash/email?<"02A2D3AACB65B012*/c=GB/admd=ATTMAIL/prmd=BA/o=British Airways PLC/ou=CORPLN1/s=Steinitz/g=Dominic/i=J/"@MHS>
07:47:17 <Leimy> I have "The Craft" and "The Haskell School of Expression..."
07:47:31 <Leimy> I am currently going through "The Craft"
07:47:40 <Leimy> and thoroughly enjoying it
07:47:57 <Leimy> I've also looked at some of the online stuff
07:48:22 <shapr> XTL: good bug report, thanks
07:48:27 <Leimy> there are a lot of different ways to begin learning to use Haskell but so far the approach I like best is in Haskell: The Craft of Functional Programming Second Edtion"
07:48:42 <shapr> XTL: the Nothing means that I couldn't parse the Date: field
07:48:57 <shapr> but the other bug is that my shell unescaping code has missed something
07:49:57 <XTL> Sounds likely. The server says "The request line contained invalid characters following the protocol string." as well.
07:50:42 <shapr> scary
07:50:54 <shapr> I think I should be urlencoding stuff
07:51:03 <XTL> The asterisk, perhaps?
07:51:30 <shapr> probably anything that's not alphanumeric and a percent, since that would just fix all my char escaping problems
07:51:44 <XTL> No, actually another shot in the dark gives same results. But maybe you'll look for it :)
07:55:03 <shapr> huh, I don't see a function to do url encoding
07:57:50 <shapr> oh, maybe Network.URI.escapeString
08:03:44 <shapr> ok, the binary is now named SearchML, and url escaping should work just fine now
08:04:01 <shapr> http://shapr.homelinux.net/cgi-bin/wash/SearchML
08:05:07 <Leimy> hmmm
08:05:13 <Leimy> I get some Nothings
08:05:16 <Leimy> I searched for GHC
08:05:31 <shapr> that's because the date parsing code I'm using isn't very good
08:05:33 <Leimy> they aren't "sweet Nothings" either :)
08:05:37 <Leimy> hehe :)
08:05:41 <shapr> I'll clean that up later.
08:05:46 <Leimy> ok cool... :
08:05:48 <Leimy> :)
08:06:23 <shapr> two things that are missing right now is support for multiple mailing lists, and inserting text/plain MIME parts into the database
08:06:29 <shapr> right now it just drops any multipart messages
08:07:16 <shapr> bring: is there a HaskellDB logo I could show at the bottom of the page?
08:08:05 <XTL> As a user, I'd probably like to see a thread next/prev and references viewed, clearer header formatting and mbox download links.
08:08:32 <shapr> I'll add that to the TODO list
08:08:38 <shapr> what do you mean by mbox download links?
08:08:43 <shapr> the whole mailman archive?
08:09:18 <XTL> Downloading the whole archive or a months' or such. I hate looking at sf or Yahoo lists or whatever there are which you can' t use and can't go around by getting the archive and reading it in mutt.
08:09:50 <shapr> ok
08:10:28 <XTL> I guess the horizontal scrolling in some messages is caused by long lines and not really easily fixable.
08:10:59 <shapr> I'm using <pre></pre> right now
08:11:05 <shapr> I could use <br/> instead
08:11:37 <Leimy> table rows :)
08:11:56 <XTL> *blink*. Hm.. Some brilliant gaim developer seems to have decided that parsing html from irc channels is a good idea :(
08:12:44 <maihem> <blink>hahaha</blink>
08:13:02 <XTL> maihem: Well, that one it didn't parse :)
08:13:06 <maihem> <marquee>everybody point at XTL and laugh!</marquee>
08:13:11 <maihem> oh, bugger
08:13:27 <XTL> Nor that. But shapr's lines got weird breaks in them.
08:14:31 <XTL> I'm reluctant to give up tirc because other clients AFAIK don't have vi keybindings. Then again tirc doesn't allow multiple servers so I just decided to use gaim (used for Jabber) for freenode as well. 
08:14:47 <XTL> Maybe I'll get something useful instead sometime.
08:15:43 <Leimy> XTL hehe
08:15:50 <Leimy> well You'd probably hate what I use :)
08:15:58 <Leimy> I'm using ERC Version 4.0 $Revision: 1.600 $ with GNU Emacs 21.3.50.1 (powerpc-apple-darwin7.3.0)!
08:16:07 <shapr> I also use ERC
08:16:11 <Leimy> :)
08:18:40 <maihem> hmm, must try that, M-x ???
08:18:46 <shapr> it's just /sv
08:19:07 <shapr> short for "say version" I think
08:19:53 <maihem> shapr: I mean what major-mode?
08:20:06 <Leimy> showversion?
08:20:09 <XTL> Well, irssi is looking tempting again. Even if it has perl.
08:20:13 <maihem> for ERC
08:20:18 <shapr> oh, I don't think it's a standard part of GNU Emacs yet
08:20:24 <maihem> ah
08:20:34 <shapr> but debian packages are available, and you can get it from http://erc.sf.net/
08:20:38 <Leimy> shapr: not yet... http://www.emacswiki.org
08:20:38 <shapr> lots of info about ERC on emacswiki.org
08:20:47 <Leimy> great Emacs site if you use it :)
08:20:55 <Leimy> I found a lot of good tips there :)
08:21:10 <shapr> I'm particularly fond of the EmacsNiftyTricks page there.
08:21:20 <Leimy> shapr: yes :)
08:21:38 <Leimy> hmmm
08:21:48 <Leimy> not linked from the front page
08:22:03 <maihem> heh, debian unstable: erc recommends emacs-chess ;)
08:22:21 <Leimy> maihem: that's because ERC users can play online chess :)
08:22:23 <Leimy> via IRC :)
08:23:09 <Leimy> I might have that installed... I never checked
08:27:55 <Leimy> hmmm eshell is pretty cool too :)
08:28:14 <shapr> yah, eshell is nice
08:33:49 <liiwi> snurr
08:36:08 <shapr> hei liiwi 
08:40:52 <liiwi> hej hej
09:02:36 <shapr> well, I've added some simple table formatting to the output, and I switched from <pre> to <br>
09:02:48 <shapr> so now it should screenwrap correctly
09:02:59 <shapr> hi maihem_erc !
09:03:06 <maihem> hi, oh, errr
09:03:11 <maihem_erc> I mean hi
09:03:14 <maihem_erc> heh :)
09:04:11 <shapr> now you can try /sv
09:04:17 <maihem_erc> I'm using ERC Version 4.0 $Revision: 1.577 $ with Emacs 21.3.1!
09:04:20 <shapr> yay!
09:04:28 <Leimy> heh
09:05:08 <maihem_erc> hmm, need a new window with a user list buffer...
09:05:14 * maihem_erc types C-h b
09:05:27 * maihem_erc loves emacs
09:05:43 <shapr> the erc-speedbar code mostly does that, but there are some speedbar bugs that cause problems
09:08:25 <Leimy> I don't seem to have an erc speedbar :(
09:13:41 <maihem> oops, I switched to haskell-mode... umm, how do I get back :)
09:14:17 <maihem> we need an emacs replacement written in haskell and extendable with haskell :)
09:14:19 <shapr> kill the window, go to your server buffer and "/part #haskell"
09:14:29 <shapr> then you can /join #haskell
09:14:42 <shapr> there may be a better way to do that, but I don't know it.
09:15:06 <Leimy> maihem: yeah :)
09:15:09 <Leimy> I'd be all for that :)
09:15:14 <shapr> me too
09:15:20 <Leimy> M-x erc-mode
09:15:22 <Leimy> shouldn't that do it?
09:15:24 <musasabi> hum a functional text editor...
09:15:30 <shapr> but the primary problem is that runtime loading isn't type-safe
09:15:32 <maihem> there's no erc-mode :/
09:15:37 <Leimy> musasabi: meaning "one that works"? :)
09:15:41 <musasabi> but really a good functional gui toolkit should exist first.
09:15:46 <shapr> if it weren't for that, we could start the project
09:16:08 <Smerdyakov> It's a trivial project to _make_ it type safe.
09:16:08 <Leimy> Bah... do we need GUI? :)
09:16:21 * Leimy want's ncurses based editor! :)
09:16:22 <Leimy> hehe
09:16:35 <Leimy> then I can use it in the gui or not
09:16:54 <Leimy> if we can have a GUI that can do either Text-mode or real GUI I'd be more happy I think :)
09:16:59 <Leimy> er GUI toolkit
09:17:15 <Leimy> SuSE opened up the source to Yast
09:17:25 <Leimy> it seems to have dual back-ends for displaying text mode and GUI
09:17:25 <maihem> musasabi: that's why I'm working on this little state machine. each GUI object is gonna be described by a state machine, the output of that state machine can be used for input into another, thus compound widgets can be constructed :)
09:17:28 <Leimy> but I think it uses Qt
09:17:45 <shapr> yay! haskell.org is back!!!
09:17:49 <Leimy> woot!
09:18:37 <XTL> An user interface toolkit which would accept some simple-ish text streams to control the UI and likewise pass some back would be nice. Sort of like a remote control.  Most languages can read and write text anyway, so it would be failrly easy to "port".
09:18:42 <maihem> I need a set of state machine combinators now
09:18:48 <shapr> good timing, I'm almost done with the multiple mailing list support
09:19:12 <musasabi> XTL: plan9 libcontrol is something like that.
09:19:30 <maihem> Leimy: that should be "w00t!", with the zero's
09:19:52 <XTL> Or maybe just a spec. Then you could have native programs that allow for example IM/ViewKit/Motif GUI on Irix and Gtk and Qt etc.
09:19:58 <Leimy> maihem: yeah :)
09:20:00 <musasabi> http://www.cs.bell-labs.com/magic/man2html/2/control
09:20:12 <XTL> musasabi: I still haven't gotten into trying plan9. I've always tripped over something.
09:20:22 <Leimy> Plan 9 is ok
09:20:43 <Leimy> I actually decided I like full terminal emulation better than the alien mouse interface it uses 
09:21:03 <Leimy> I don't want to click on text :)
09:21:06 <Leimy> I want to click on buttons
09:21:17 <XTL> Something being a statement of "turning off access control" or "Use the mouse. Vi will never be ported". "Deviation from our GUI look will never be allowed". etc
09:21:18 <Leimy> and I sure don't want to be highlighting stuff all day to make my editor work
09:21:24 <Leimy> that requires too much precision
09:21:37 <XTL> Leimy: not to mention much handwaving.
09:21:56 <musasabi> well there are terminal emulators for plan9.
09:22:00 <Leimy> yeah
09:22:06 <Leimy> musasabi: yes... 
09:22:06 <XTL> Maybe if one hand could control a pointer (mouse/trackball) and the other one would soleley handle a chording keyboard or such.
09:22:25 <Leimy> I'd need 3 hands to use Plan 9 as well as I do just emacs :)
09:22:30 <XTL> Then it might make sense to rely on pointing that much. But it would require quite a bit of coordination.
09:22:36 <Leimy> Even though Acme is a kind of neat ide
09:22:37 <Leimy> a
09:22:41 <Leimy> er idea
09:22:44 <musasabi> acme is quite nice when one has learned it
09:22:48 <Leimy> yeah
09:22:57 <Leimy> I have less of a problem with acme
09:23:11 <Leimy> the whole "click on an #include" and it opens up is pretty cool :)
09:23:20 <XTL> And it seems a very closed culture somehow.
09:23:26 <Leimy> indeed :)
09:23:33 <XTL> Ivory tower development maybe.
09:23:52 <Leimy> in a way
09:24:08 <Leimy> I'd think of Plan 9 as a research platform or vehicle
09:24:09 <XTL> I think allowing people to sneak in bit by bit might lure more people into trying those weird and wonderful things later.
09:24:47 <XTL> But the filesystem/namespace thing is wonderful. I'd like that.
09:25:06 <Leimy> I think Ron Minnich of LANL ported that to FreeBSD
09:25:08 <Leimy> or tried to
09:25:12 <Leimy> I can't remember what happened there
09:27:42 <XTL> I wonder if plan9 could be forked. Get some healthy competition going.
09:28:28 * maihem types "C-c w transit" and cackles maniacally
09:29:26 <XTL> Hm. Could the Inferno thing be used to access a plan9 as an "application server" of a sort? Of course you could just run Inferno.
09:30:31 <Leimy> right
09:30:38 <XTL> I haven't gotten around to that either :)  There's even an Irix binary, I think.
09:30:44 <Leimy> heh
09:30:55 <Leimy> Inferno is smaller than most Flash plugins
09:30:56 <Leimy> I think
09:33:04 <XTL> It's pretty small at least. It might make a nice portable virtual machine kind of thing.
09:33:04 * Riastradh sighs at idiots who abuse wikis.
09:33:39 <Leimy> Riastradh: did someone futz with Haskell wiki?
09:33:53 * Riastradh points at the 'sweetscentofpiss' page.
09:34:32 * Leimy hasn't seen that one :)
09:35:15 <XTL> Hmm
09:36:49 * shapr imports haskell-cafe
09:37:50 * XTL goes for a walk
09:38:33 <shapr> oh foo, I just thought of a bug... I've made listname a single field and that won't work for crossposts.
09:41:23 <stepcut> :p
09:42:09 <shapr> I could make separate tables for each list, but that's cheesy
09:44:21 <stepcut> what about one table for the messages, and another table that links message ids to lists?
09:44:55 <shapr> that's the correct way to do it
09:44:59 <stepcut> :p
09:45:10 <shapr> but I'm going to figure out checkboxes first
09:45:19 <shapr> have you done checkboxes with WASH?
09:45:36 * stepcut ponders
09:45:49 <shapr> looks like it's called checkboxInputField
09:45:53 <Leimy> any freebsd fans here?
09:45:55 <stepcut> I have done radio buttons
09:46:01 <Leimy> Groggy cut his beard
09:46:07 <Leimy> it's being auctioned on Ebay :)
09:46:12 <Leimy> http://cgi.ebay.com.au/ws/eBayISAPI.dll?ViewItem&item=3283911043
09:46:16 <Leimy> that's just sick!
09:46:23 <shapr> I need checkboxes because people may want to search multiple mailing lists
09:47:42 <stepcut> shapr: what seems to be the problem?
09:49:13 <shapr> I don't know anything about checkboxes in WASH, and I don't know how to pass multiple fields at once
09:49:25 <shapr> but I think I just found some example code that does passing of multiples
09:49:58 <stepcut> to pass multiple fields you just use F2, F3, etc
09:50:31 <shapr> oh
09:51:38 <shapr> cool, 11670 messages in the database now
09:51:50 <stepcut> checkboxInputField will evaluate to a bool (eventually)
09:53:39 <stepcut> do $ ask standardPage "wheeEEE" $ makeForm $ do { cb1 <- checkboxInputField empty ; cb2 <- checkboxInputField empty ; submit (F2 cb1 cb2) processForm empty }
09:54:44 <stepcut> processForm (F2 cb1 cb2) = let cb1_checked = (value cb1) .....
09:54:50 <stepcut> something like that
09:55:12 <shapr> cool, I'll try that
09:56:50 <shapr> http://shapr.homelinux.net/cgi-bin/wash/ProtoWASH
09:56:50 * shapr grins
09:56:57 <shapr> your example code works well
09:57:10 <stepcut> sweet!
09:57:20 <stepcut> now you just need to add some labels and stuff 
09:57:31 <shapr> yup
09:59:14 <stepcut> btw, for inputfields, in the function that processes the form, if you do something like, 'let phone_number = unPhone (value phoneF) ...'
09:59:55 <shapr> it checks the format?
09:59:59 <stepcut> yeah
10:00:07 <stepcut> there are a few built in
10:00:13 <shapr> nifty
10:00:37 <stepcut> phone, credit card, all digits, and URL (look in Fields.hs)
10:01:26 <stepcut> if the user does not do the right thing, then it WASH will automatically reprompt them for the info with a question mark next to the incorrect fields
10:01:45 <shapr> ah, I've seen that behaviour, but I didn't know it was done.
10:03:20 <stepcut> also, related to that
10:03:55 <stepcut> you can use unNonEmpty to make a field required
10:04:05 <shapr> oh, that's handy to know
10:04:26 <shapr> that'll fix my problem with zero terms
10:04:40 <stepcut> to use those things, you need to use inputField, not textInputField
10:04:59 <shapr> how so?
10:05:42 <stepcut> inputField :: (Reason a, Read a) => HTMLField x y (InputField a INVALID)
10:05:52 <stepcut> textInputField :: HTMLField x y (InputField String INVALID)
10:06:30 <stepcut> when you do things like unPhone, or unNonEmpty, it affects what the type-check puts in for 'a' in inputField
10:07:15 <stepcut> textInputField is equivalent to using inputField, and in the process function doing 'let text = unText (value textF)...'
10:07:41 <stepcut> if you use inputField, and don't use unText, then you have to put quotes around the string when you enter it in the form
10:08:33 <stepcut> err, let me clear up that last statement
10:09:39 <stepcut> if you use inputField and don't do un<Something> then it expects the user to enter a string with quotes and escape charecters
10:09:57 <stepcut> using unText will allow the user to enter a plain string
10:10:23 <stepcut> without quotes or anything funky
10:13:39 <shapr> I'm still trying to get the checkboxes to type check
10:14:37 <stepcut> hehe
10:14:53 <stepcut> mixing WASH/CGI with haskelldb can lead to some very big type-check messages
10:15:01 <shapr> truly :-)
10:15:21 <shapr> have you written some apps that mix them?
10:15:29 <stepcut> yep
10:15:58 <shapr> anything I can look at?
10:17:24 <shapr> I wonder if there's a good way to give a standard look and feel to WASH pages
10:17:34 * shapr thinks
10:17:56 <stepcut> css
10:18:03 <shapr> ah, good point
10:18:09 <stepcut> that's what I do, it works well
10:18:15 <shapr> ok, the checkboxes are in, but they don't work yet: http://shapr.homelinux.net/cgi-bin/wash/SearchML
10:19:30 <stepcut> shapr: by 'look at' did you mean the source? or just the site?
10:20:00 <shapr> either 
10:20:34 <stepcut> I currently don't have any sites on publicly available servers, but I could probably send some code your way
10:20:35 <shapr> I'm more interested in seeing a working site, I just want to see what someone else has done
10:20:43 <shapr> sure, code is good :-)
10:21:06 <shapr> I know John Hughes did the ICFP2003 contest submission stuff with WASH
10:21:40 <stepcut> well, I have to warn you, I am teaching my girlfiend to program, so its all her code ... so it may be useful for figuring out how something works, but its NOT pretty code :p
10:22:04 <stepcut> hopefully by next weekend I will also have a public site up and running
10:22:08 <shapr> if you got your girlfiend to write Haskell, you get lots of cool points from me.
10:22:14 <stepcut> haah
10:22:36 <shapr> my girlfiend is okay with Python, but doesn't see any business applications for Haskell, and so isn't particularly interested.
10:22:54 <shapr> my girlfiend is also my boss and the other owner of our company.
10:23:14 <stepcut> hehe
10:23:22 <Smerdyakov> She's your "boss"?
10:37:07 <Leimy> hmmm
10:37:21 <Leimy> I am having a syntax issue with some guards I am trying to write on a function
10:37:37 <Leimy> but I just realized that I don't need to do it with guards :)
10:40:55 <shapr> I wonder if br/ is a legal function name
10:44:52 <shapr> neat, now 20k messages in the database
10:45:18 <ibid> i'd assume not
10:45:55 <loki> say
10:46:07 <loki> how do you make say a hello world program in haskell?
10:46:25 <shapr> module Main where
10:46:34 <shapr> main = putStrLn "hello world"
10:47:03 <loki> thats wht i have to put in the file?
10:47:07 <shapr> loki: so, are you learning Haskell for fun or profit?
10:47:18 <loki> for fun
10:47:27 <loki> how can you learn it for profit?
10:47:37 <shapr> get paid to write Haskell
10:47:59 <shapr> I've been paid to write Haskell, but usually I get paid to write Python
10:48:15 <loki> well as in a job?
10:48:23 <shapr> we have a few full-time Haskell programmers here.
10:48:29 <shapr> yes
10:48:37 <loki> there isn't all that great a demand for haskell programmers
10:48:38 <loki> as of yet
10:49:07 <loki> brb
10:49:10 <shapr> I predict that will change, the demand will increase.
10:49:23 <Leimy> shapr: what makes you think so
10:49:31 <shapr> my crystal 8-ball.
10:49:34 <Leimy> hehe :)
10:49:38 * shapr grins
10:49:53 <Leimy> what "problem spaces" is Haskell really best suited?
10:50:09 <shapr> I'd say writing correct code in a short amount of time
10:50:17 <shapr> but not necessarily fast code
10:50:17 <Leimy> so Rapid prototyping?
10:50:25 <shapr> yup, that's one application
10:50:31 <Leimy> I tend to agree :)
10:50:53 <shapr> though in my experience, very programs really need to fast, correctness is usually more valuable.
10:51:07 <Leimy> Fast and incorrect isn't that good yeah :)
10:51:58 <Leimy> though there are a lot of times where even though 100% of the input coming into a function won't be processed properly
10:52:01 <Leimy> 80% of it will be
10:52:07 <Leimy> and that's the major subset that is used
10:52:08 <Cale> http://pathfinder.scar.utoronto.ca/~dyer/csca57/book_P/node41.html -- see the second last equation for how that algorithm is expressed in math. Here it is in Haskell:
10:52:14 <Cale> trapezoid f a b n = h * ((f a + f b)/2 + sum [f (a + i * h) | i <- [1 .. n-1]])
10:52:14 <Cale> 	where h = (b-a)/n
10:52:18 <Leimy> and unfortunately maybe 10% is tested :(
10:52:39 <Cale> the only thing that I changed was to factor out the h.
10:52:49 <Leimy> heh
10:52:49 <shapr> Cale: nice
10:52:54 <Leimy> sweet
10:53:00 <Leimy> that's another thing I like about Haskell
10:53:14 <Leimy> the translation from a mathematical formula to the actual code isn't terribly far off :)
10:53:14 <Cale> The code must implement what it's supposed to, because you can just stare at it and check.
10:53:31 <shapr> next use of Haskell: specifications that easy to read and  executable
10:53:38 <Leimy> yeah
10:53:56 <Leimy> I like the way functions compose in Haskell too
10:55:13 <loki> back
10:55:22 <shapr> there must be a more elegant way to take a bunch of Bools and do "if haskell then ((t!listname) .==. constant "haskell") else"
10:55:24 <loki> say can anyone direct me to an example based tutorial?
10:55:28 <loki> i haven't been able to find one
10:55:36 <loki> only conceptual explanations
10:55:38 <shapr> have you tried Yet Another Haskell Tutorial?
10:55:43 <Leimy> loki: A Gentle Introduction isn't good?
10:56:11 <loki> none of them told me how to make a hello world app
10:56:23 <Smerdyakov> loki, that's because it's non-trivial in Haskell.
10:56:25 <Leimy> well "hello world" involves I/O :)
10:56:34 <loki> very true
10:56:36 <Leimy> and I/O involves "state"
10:56:39 <shapr> loki: did you try the hello world code I showed you above?
10:56:48 <loki> yes it worked thank you
10:56:50 <Leimy> so to fully understand it you'd probably need to understand Monads a bit...
10:56:52 <shapr> cool
10:57:08 <Smerdyakov> loki, I/O is a very unimportant part of programming, in terms of learning skills.
10:57:17 <loki> you see i can't learn anything until i can see some kind of result
10:57:24 <Smerdyakov> loki, I think you should reconsider your idea of "conceptual examples."
10:57:27 <Leimy> loki: ah.. well we can help you there
10:57:37 <loki> i can't tell if what i'm doing is right until i see a print statment of my variables
10:57:40 <Smerdyakov> loki, you see results by using the interactive environment.
10:57:45 <Leimy> any example in the ghci interpretter will print what a function returns
10:57:47 <monotonom> Woopie! www.haskell.org is back!
10:57:58 <Smerdyakov> loki, evaluate an expression and it prints the value.
10:58:01 <Leimy> without having to invoke I/O routines
10:58:18 <loki> o
10:58:22 <loki> thnx
10:58:28 <shapr> loki: I wrote a code sample for the impatient, see what you think: http://www.scannedinavian.org/AvianWiki/HaskellDemo
10:58:38 <Leimy> loki: what I do with GHC is run ghci in one terminal
10:58:39 <loki> one sec
10:58:40 <Cale> Using IO in Haskell isn't really that bad.
10:58:52 <Leimy> then I load in examples and run tests :)
10:59:00 <Cale> It's just somewhat different from programming in most imperative languages.
10:59:00 <Leimy> which I wrote in another terminal
10:59:11 <monotonom> It may be time to question the value of a hello-world example.
10:59:13 <Leimy> it's similar to messing with the python interpretter directly in terms of the feedback you get
10:59:26 <monotonom> Let me start that war on lambda the ultimate :)
10:59:32 <Leimy> heh
11:00:13 <loki> no one told me about the interperted before
11:00:22 <loki> i was using hugs and i couldn't even get a comment to work
11:00:26 <shapr> we're here to be helpful :-)
11:00:36 <Cale> yes, use ghci, first of all :)
11:00:43 <shapr> right, I agree with that
11:01:03 <Leimy> loki: heh
11:01:03 <loki> kk :D yay finally progress
11:01:06 <Leimy> ghci or hugs
11:01:07 <Cale> ghci and hugs mostly just evaluate expressions. You're exprected to load a file into them.
11:01:23 <Leimy> in ghci you use ":l somefile" 
11:01:29 <Leimy> where somefile is somefile.hs
11:01:31 <Leimy> or what not
11:01:36 <monotonom> Yeah you should try writing a comment in a file.
11:01:38 <Leimy> then if you edit the program you can use
11:01:39 <Leimy> ":r"
11:01:41 <Leimy> to reload it
11:01:50 <loki> alright
11:01:54 <Leimy> that's how I do all my experimentation
11:01:56 <Leimy> so far
11:02:02 <loki> kk
11:02:24 <Cale> I mostly just keep a text editor open with ghci, and save, then :r the file whenever I make significant changes that need testing.
11:02:26 <Leimy> there is a GHC tutorial on haskell.org/ghc somewhere
11:02:30 <Leimy> that might be where you want to start
11:02:36 <Leimy> or there may be a good Hugs tutotiral
11:02:39 <Leimy> er tutorial
11:02:46 <Leimy> it helped me out a bit when I started
11:03:07 <loki> k so ghci is not the same thing as the python interperter
11:03:36 <Cale> Remember that any declarations (new functions, datatypes, etc.) need to go into a file. You can't type them on the ghci/hugs commandline.
11:03:58 <Leimy> loki: not quite the same no
11:04:07 <loki> alright
11:04:11 <Cale> You can get some form of temporary bindings for functions/variables in ghci with the form "let a = 5", for instance.
11:04:42 <loki> cool
11:04:48 <Cale> I think of ghci more as a nice interactive debugger.
11:05:04 <loki> kk
11:05:08 <Leimy> Cale: same here :)
11:05:50 <Cale> The first thing about IO in Haskell, is not to be scared of it, since lots of people will tell you that it's hard, when it's really not so bad.
11:06:04 <loki> k so i have to have a main defined in every file?
11:06:19 <Cale> You shouldn't need to have main in every file.
11:06:32 <loki> alright
11:06:48 <Cale> I was having problems with a slightly older version of ghci with it complaining about main all the time.
11:07:03 <Cale> If yours does that, put "main = return ()" and it will stop.
11:07:28 <loki> kk thnx
11:07:39 <XTL> AFAIK there's no step or trace or breakpoints or such in ghci or hugs. Is there any nice way to get to look at, for example, values in lets etc?
11:07:43 <loki> Prelude> main = return ()
11:07:43 <loki> <interactive>:1: parse error on input `='
11:07:51 <XTL> .. Where it would make sense, of course.
11:07:55 <Cale> oh, you're already in ghci
11:08:11 <loki> ?
11:08:17 <maihem> let main = return ()
11:08:20 <Cale> you'd want to put that into whatever file you're working on, and it's complaining about for a lack of main
11:08:37 <loki> o alright kk thnx
11:09:21 <Cale> you'll certainly need a proper main if you were going to compile without using ghc proper. (as that would describe what's to be done when the program is run)
11:09:32 <Cale> with*
11:09:50 <Cale> actually, remove the without entirely :)
11:09:55 <Smerdyakov> Wow! loki gave us a line with only abbreviations. :D
11:10:09 <Cale> abbrevs.
11:10:26 <loki> lol
11:10:52 <loki> say why doens't this file work:
11:10:53 <loki> main = return ()
11:10:54 <loki> add1 :: Int -> Int
11:11:04 <Cale> ...
11:11:15 <Cale> you should actually write a definition for add1
11:11:16 <loki> i dono its one of them "examples"
11:11:25 <loki> well isn't that the definition?
11:11:27 <Cale> add1 = (+1)
11:11:29 <loki> the type defintion
11:11:29 <XTL> Exactly _how_ it doesn't work would probably help.
11:11:30 <loki> o alright
11:11:31 <loki> kk
11:11:32 <loki> thanx
11:11:36 <Cale> no, you only wrote the type
11:11:55 <loki> so it has to do something as well? just declaring it is not enough? 
11:12:00 <Cale> what you wrote there says "add1 takes an Int and returns an Int"
11:12:26 <loki> o ok
11:12:31 <loki> k thnx it worked :D
11:12:37 <loki> yay!! :D 
11:12:52 <Cale> try "map add1 [1,2,3,4,5]"
11:13:13 <Cale> or, of course, "map (+1) [1,2,3,4,5]" :)
11:13:22 <Leimy> yep :)
11:14:16 * Leimy is learning the wonders of zip and unzip :)
11:14:40 <loki> er not working
11:15:03 <Cale> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
11:15:34 <Leimy> yeah
11:15:52 <Leimy> nice recursive definition of fibonacci
11:16:04 <XTL> Indeed
11:16:11 <Cale> you can watch the list build itself
11:16:15 <Leimy> I've seen a ton of variations of that
11:16:22 <Leimy> and one that didn't recompute the n-2 number
11:16:27 <loki> say the map (+1) [1,2,3,4,5] line isn't working
11:16:37 <Leimy> loki what's the error?
11:16:43 <Leimy> are you typing that into GHCI?
11:16:45 <Cale> XTL: usually to get at values in lets, I'll lift them to the top level of the module.
11:16:48 <loki> Prelude> :r
11:16:48 <loki> Compiling Main             ( test.hs, interpreted )
11:16:48 <loki> test.hs:5: parse error (possibly incorrect indentation)
11:16:48 <loki> Failed, modules loaded: none.
11:16:52 <Leimy> that's why :)
11:16:57 <Leimy> you are trying to load it in from a file
11:17:05 <loki> o
11:17:13 <Leimy> type it at the ghci prompt
11:17:23 <Cale> I meant "map (+1) [1,2,3,4,5]" as something to type in the interpreter
11:17:25 <XTL> Or put it to the body of main and you can load it :)
11:17:35 <Cale> to test out the "adding 1" function
11:17:57 <loki> k it worked in the interperter
11:17:57 <Cale> yeah, you could do something like "main = print $ map (+1) [1,2,3,4,5]"
11:18:13 <loki> so main is the output?
11:18:36 <Cale> main is the one IO action that runs when your program is compiled and run
11:18:37 <Leimy> main is a bit like main in C
11:18:47 <Leimy> yeah ... what Cale said
11:19:15 <Cale> you build it up out of other IO actions (like getting user input, printing stuff, etc.)
11:19:44 <loki> so does main have to be in front or can it be at the bottom?
11:19:46 <shapr> oy, what's a good way to turn a tuple of Bool checkbox values into a list of HaskellDB .==. clauses?
11:19:47 <loki> of the file?
11:19:51 <shapr> I think my brain is tired.
11:20:03 <Leimy> loki I don't know if it matters
11:20:09 <Cale> the ordering of the declarations in a haskell file mostly doesn't matter.
11:20:10 <Leimy> it will start evaluating from main
11:20:42 <Cale> shapr: what's .==. ?
11:20:53 <Cale> probably mapping some function over the list
11:21:08 <Cale> er, but it's a tuple
11:21:10 <Cale> hmm
11:21:56 <shapr> Cale: http://shapr.homelinux.net/~shae/SearchML.hs
11:22:00 <monotonom> shapr: since it is a tuple, of known length, you can always do it manually.
11:22:01 <shapr> see that big ugly chunk at the bottom of the file?
11:22:03 <loki> say how do i run the main in the interperter
11:22:12 <Cale> ah
11:22:15 <Cale> ugh
11:22:29 <shapr> it doesn't even work :-)
11:22:37 <monotonom> Unless you write a "fold" for a tuple.
11:22:51 <loki> wow its just like c
11:23:01 <Leimy> uhm... no :)
11:23:02 <Leimy> hehe
11:23:07 <loki> well like the main
11:23:11 <loki> now i get it
11:23:28 <Leimy> yeah... I guess
11:23:32 <Cale> loki: thinking that it's *just* like C will get you into trouble, but yeah, the concept of main is.
11:23:33 <Leimy> it's more like Python's __main__ :)
11:23:34 <Leimy> hehe
11:23:52 <loki> well i  was referign to the concept of main
11:23:52 <Cale> shapr: maybe a slight generalisation would help?
11:23:59 <shapr> oh please :-)
11:24:09 <shapr> like what?
11:24:24 <Cale> like, creating an alegbraic type for mailing lists that has the necessary data
11:24:31 <shapr> hm
11:24:36 <Cale> and then just passing a list of them, rather than bools
11:25:46 <Cale> It looks like all your code maps/folds over this implicit list of mailing lists.
11:27:07 <Cale> consider the problem of adding another later :)
11:27:13 <shapr> yes, I agree
11:27:34 <shapr> though for the moment I've reached "I just want it to work"
11:27:45 <loki> are there if and for statments in haskell?
11:27:58 <shapr> the current searching does work, it just doesn't limit by mailing list
11:28:01 <Cale> loki: there's if expressions
11:28:11 <loki> how about loops?
11:28:17 <Cale> loki: there's no builtin for, but you could make your own
11:28:26 <shapr> I think I'll come back later after I've had time to think about a good algebraic type
11:28:31 <loki> Cale: kk thnx
11:28:36 <Cale> you usually use map and fold for what you used to used loops.
11:28:42 <Cale> and zip as well.
11:28:56 <Cale> lists are rather important
11:29:27 <loki> alright
11:29:28 <loki> thanx
11:29:55 <Cale> loki: have a look at the second last equation on http://pathfinder.scar.utoronto.ca/~dyer/csca57/book_P/node41.html
11:30:27 <loki> wait up
11:30:47 <Cale> (I'll show you the Haskell implementation shortly)
11:30:57 <loki> that really long one?
11:30:58 <loki> alright
11:31:20 <Cale> the important bit of that is the part before the first wavy =, and the part after the last =
11:31:40 <Cale> now, you might think that if you wanted to calculate that sum, that you'd need a loop
11:31:54 <Cale> but you'd be thinking at too low a level
11:32:01 <loki> i'm not an expert in math
11:32:07 <Cale> what you really want to do is to sum up a list of numbers.
11:32:17 <Cale> trapezoid f a b n = h * ((f a + f b)/2 + sum [f (a + i * h) | i <- [1 .. n-1]])
11:32:17 <Cale> 	where h = (b-a)/n
11:32:24 <Cale> here's the haskell implementation
11:32:33 <loki> o alright i get ya
11:32:38 <Cale> all that I changed was to factor out the h
11:33:05 <Cale> [f (a + i * h) | i <- [1 .. n-1]] -- this makes a list of the numbers we want to sum
11:33:32 <Cale> applying "sum" to it sums it up, and then the rest is just arithmetic.
11:34:08 <Cale> sum is defined as foldl (+) 0
11:34:35 <Cale> which says "fold the operator + between the elements of this list, and use the number 0 to stop at the end"
11:34:41 <loki> you know i'm in grade 11 math :$ i dont' know what half those symbols mean
11:34:50 <Cale> ah, okay
11:34:52 <loki> and i'm not that familiar with haskell syntak
11:35:05 <Cale> well, it helps to have one or the other
11:35:15 <loki> exactly
11:35:22 <Cale> that formula is used to calculate the area under the function f.
11:35:46 <loki> o alright
11:35:58 <Cale> it does that by making a bunch of little trapezoids and adding up the individual areas
11:37:07 <loki> o
11:37:11 <loki> alright
11:37:20 <loki> that makes sense somewhat
11:37:41 <loki> :|
11:37:53 <loki> more practical applications would be helpful
11:38:11 <Cale> the big sigma (the funny thing that sort of looks like a stylised E) with the (i=1) and (n-1) means "add up the list that you get when i runs from 1 to n-1 of the following
11:38:21 <loki> like say whats that classical recursive function caleld? where you multiply 1*2*3*4*5
11:38:27 <Cale> factorial
11:38:41 <loki> yes so how would you do that in haskell?
11:38:52 <Cale> heh, it's a classic example :)
11:39:02 <Cale> fact 0 = 1
11:39:10 <loki> what?
11:39:13 <Cale> fact n = n * fact (n-1)
11:39:19 <Cale> (two lines)
11:39:34 <Cale> one for the base case, and one for the recursive case
11:39:56 <loki> one sec
11:40:03 <ibid> f n = foldr (*) 1 [1..n]
11:40:04 <ibid> :)
11:40:10 <loki> i'm trying to learn haskell and deal with some girls relationship issues at the same time its hard
11:40:15 <Cale> or just "product [1..n]"
11:40:26 <ibid> ah, so it was product
11:40:32 <ibid> tried prod, did not work :)
11:40:34 <Leimy> Girls == more difficult to understand than Haskell :)
11:40:49 <loki> naw i understand them 
11:40:53 <Cale> definitely. Haskell has much cleaner semantics.
11:41:07 <loki> i don't even understand half of your terminology lol
11:41:20 <loki> liek whats semantics?
11:41:35 <loki> btw how can 0 =1 ?
11:41:42 <loki> fact 0 = 1
11:41:46 <loki> what does fact do?
11:41:48 <Cale> it doesn't say that 0 = 1
11:41:50 <Leimy> fact is the function
11:41:55 <Cale> it says that the factorial of 0 is 1
11:41:58 <Leimy> it takes 1 parameter
11:42:01 <Cale> (which it is)
11:42:01 <Leimy> if you give it 0
11:42:04 <Leimy> then fact yields 1
11:42:08 <Leimy> factorial of 0 is 1
11:42:11 <Leimy> is what you said :)
11:42:17 <Leimy> fact 0 = 1
11:42:35 <loki> o okay
11:42:43 <Leimy> so that the factorial of n is
11:42:46 <loki> theni understand
11:42:52 <Leimy> fact n = n * (fact n-1)
11:43:00 <Cale> so for instance,
11:43:10 <Cale> fact 5 = 5 * fact 4
11:43:17 <Cale> = 5 * 4 * fact 3
11:43:23 <Cale> = 5 * 4 * 3 * fact 2
11:43:31 <Cale> = 5 * 4 * 3 * 2 * fact 1
11:43:38 <Cale> = 5 * 4 * 3 * 2 * 1 * fact 0
11:43:43 <Cale> = 5 * 4 * 3 * 2 * 1 * 1
11:43:49 <Cale> = 120
11:44:22 <Leimy> recursion :)
11:44:52 <loki> k so when fact 1-1 = 0 it will give output of 1 and stop the loop?
11:45:02 <Leimy> correct!
11:45:06 <loki> alright
11:45:11 <Leimy> the recursion is terminated by the base case
11:45:17 <Cale> right, because there's an explicit definition for the 0 case
11:45:30 <loki> kk thanx
11:45:32 <loki> :D
11:46:14 <Leimy> and Haskell tries to "match" the arguments you give against each case top down
11:46:15 <XTL> I wonder if you could keep small irc courses with set times. :) 
11:46:17 <Leimy> so don't do this
11:46:25 <Leimy> fact n = n * (fact n -1)
11:46:28 <Smerdyakov> XTL, that would be bad.
11:46:32 <Leimy> fact 0 = 1
11:46:33 <XTL> If there's enough people, maybe use a moderated channel.
11:46:36 <Leimy> it may never match 0 :)
11:46:44 <Leimy> since the first one matches everything :)
11:46:53 <loki> o alright
11:47:02 <Smerdyakov> XTL, working independently and dropping in to ask questions is optimal.
11:47:22 <Leimy> loki: though I just keyed that into a file and loaded it into GHCi an
11:47:26 <Leimy> and it complained
11:47:29 <XTL> Smerdyakov: Probably so. Even if that means repeating the same things and learning mostly on your own.
11:47:32 <Cale> still, there's a lot you can get across in a lecture :)
11:47:37 <Leimy>  Warning: Pattern match(es) are overlapped
11:47:37 <Leimy>              In the definition of `fact': fact 0 = ...
11:47:48 <Leimy> but it is not an error
11:47:55 <Smerdyakov> XTL, I don't think there are many good hackers who don't learn mostly on their own.
11:47:57 <Leimy> and fact "anything" will be an infinite loop :)
11:48:34 <Cale> loop = loop
11:48:40 <Leimy> heh yes
11:48:47 <XTL> Smerdyakov: Well, it depends on persons and material and things. Assuming certain "level", of course yes.
11:49:10 <loki> how do you call a function?
11:49:17 <Cale> ghc is smart enough to get out of that one though, due to the way that haskell is compiled.
11:49:23 <loki> main = print $ fact 5?
11:49:27 <Cale> sure
11:49:30 <Cale> that works
11:49:37 <Smerdyakov> loki, why don't you read a tutorial instead of asking how to call a function?
11:49:53 <loki> true
11:49:55 <Leimy> for my own benefit mostly and perhaps even GHC's I tend to group functions with their parameters in parenthesis
11:49:57 <Cale> and it's the same as "main = print (fact 5)" just so you know.
11:50:06 <Leimy> like (fact 5)
11:50:23 <Cale> $ helps out when the parentheses get heavy though
11:50:36 <loki> they don't talk about main in tutorials though, as far i can c
11:50:41 <loki> Cale: thanx
11:50:51 <Leimy> But I generally agree with Smerdyakov:... One gets a lot more out of it by learning on one's own :)
11:50:56 <Leimy> it's why they give homework in school
11:50:57 <Cale> loki: that's because the norm is to not talk about IO until much later.
11:51:02 <Leimy> so  you can fall on your face on your own :)
11:51:20 <loki> Leimy: lol
11:51:24 <Leimy> it's true
11:51:27 <Leimy> you learn by doing
11:51:30 <Leimy> and experimentation
11:51:35 <Cale> IO is rather different than in other languages, and for that reason it is seen as complicated.
11:51:37 <Lemmih> loki: Why don't you use an interpreter?
11:51:39 <Leimy> if you get really stuck... that's why we are here :)
11:52:35 <loki> kk i'll go experiment on my own then :D thanx a bunch guys! :D
11:55:27 <lokiAway> wow you all stopped talking simultaneously
11:57:11 <lokiAway> o btw i get the error
11:57:18 <lokiAway> ./fact 
11:57:18 <lokiAway> Stack space overflow: current size 1048576 bytes.
11:57:19 <lokiAway> Use `+RTS -Ksize' to increase it
11:57:33 <lokiAway> when i try running that factorial program
11:57:44 <lokiAway> why is that?
11:57:44 <XTL> Trying to run an infinite loop maybe?
11:57:53 <lokiAway> fact 0 = 1
11:57:53 <lokiAway> fact n = n * (fact n-1)
11:57:54 <lokiAway> main = print (fact 1)
11:57:59 <XTL> Oh, you're printing the whole list of factorials?
11:58:01 <Lemmih> hehe
11:58:07 <lokiAway> really?
11:58:07 <XTL> fact 1 should work, though.
11:58:40 <lokiAway> its not workign
11:59:11 <Cale> certainly it shouldn't eat up a meg of stack :)
11:59:27 <Cale> is that exactly what you have in your file?
11:59:30 <Lemmih> lokiAway: fact n = n * fact (n-1)
11:59:38 <Cale> ah
11:59:42 <XTL> Yes :)
11:59:51 <Lemmih> You wrote: fact n = n * (fact n) -1 
11:59:52 <lokiAway> o right :D thnx
11:59:53 <Cale> right
12:00:12 <lokiAway> typo 
12:00:16 <XTL> It tries to do fact 1 and then substract one from that in the parens :)
12:00:25 <Cale> function application is tighter than anything else
12:00:31 <XTL> Thus, looping infinitely trying to take more fact 1's.
12:00:37 <lokiAway> actually i had n * (fact n -1)
12:00:47 <Lemmih> same thing.
12:01:03 <Cale> probably my fault
12:01:03 <Cale> :)
12:01:15 <Cale> I think I made the same typo above :)
12:01:42 <Cale> I'm a little on the woozy side, as I haven't slept much.
12:01:51 <lokiAway> eh it happens
12:02:20 <Lemmih> It's a very common error. I even believe it has a place in the jargon files.
12:02:33 <XTL> "brain fart"?
12:02:36 <lokiAway> lol
12:04:26 <lokiAway> sorry to ask but how do you call fact in interactive mode?
12:05:02 <Cale> try "fact 5"
12:05:12 <lokiAway> i did
12:05:19 <lokiAway> <interactive>:1: Variable not in scope: `fact'
12:05:30 <lokiAway> Prelude Main> fact 5
12:05:30 <lokiAway> <interactive>:1: Variable not in scope: `fact'
12:05:33 <XTL> Did you fix the loop and reload?
12:05:47 <lokiAway> yes
12:05:47 <XTL> loop.. ahem. Function :)
12:06:04 <lokiAway> lol
12:06:13 <lokiAway> should main be return ()?
12:06:22 <Cale> don't worry about main
12:06:28 <lokiAway> alright
12:07:24 <lokiAway> k it works now
12:07:33 <Lemmih> You probably wrote: 'module Main (main) where'
12:07:57 <lokiAway> nope i had main = print $ fact 4, thats why it wasn't working
12:08:10 <Cale> that shouldn't actually matter
12:08:29 * XTL still bets on not reloading the latest version
12:08:30 <Cale> I think that possibly the file just didn't load correctly
12:08:38 <XTL> Or reload was interrupted.
12:09:17 <lokiAway> i dono once i changed that in the file everything worked
12:09:53 <lokiAway> if i have no main it still works but complains about lack of main function
12:10:27 <monotonom> That is alright.
12:10:51 <lokiAway> what do you guys use as an editor for haskell btw?
12:10:56 <stepcut> emacs
12:11:18 <XTL> I wish there was a better editor for the Ericsson (Psion clone). I do have Hugs in my coat pocket, but using Word to code is a bit.. well, yes.
12:11:20 <lokiAway> i can't get the hang of it cause of all the ctrl's and the alts
12:11:37 <lokiAway> XTL use vim ! :D
12:11:43 <XTL> There's no terminal and that's probably holding ports back.
12:11:47 <stepcut> escape meta alt control shift ?
12:11:52 <XTL> lokiAway: I've looked at the port, but it looked scary :)
12:12:26 <lokiAway> XTL really? its looked great to me, just like the gnome interface, even if a lil to white for me
12:12:32 <stepcut> lokiAway: now ask which editor I use for irc ;)
12:12:41 <XTL> lokiAway: The epoc version? Really?
12:12:47 <XTL> I must try that if it works.
12:13:27 <lokiAway> there is an epoc version?
12:13:47 <lokiAway> stepcut: why do you need an editor for irc :|
12:13:56 <stepcut> :p
12:14:07 <XTL> Well, I was talking about an editor for Psion, so Epoc it is, I believe.
12:15:09 <XTL> http://www.starship.freeserve.co.uk/vim.html  That was it, I think..
12:16:09 <lokiAway> o
12:18:24 <XTL> I use vim elsewhere. It's even the first thing I install (after putty) on a windos machine if I have to use one :)
12:18:28 <lokiAway> what is psion?
12:18:33 <XTL> s/elsewhere/everywhere/
12:18:51 <lokiAway> lol :D
12:19:32 <XTL> http://www.psion.com/  PDA-ish thing. I am borrowing an Ericsson MC218 from work.
12:20:01 <loki> o
12:20:19 <XTL> Hm. Actually that doesn't seem to be a very informative site..
12:20:28 <loki> nope
12:20:41 <loki> its okay
12:20:42 <XTL> If I installed Debian on it, editor problems would probably go away :)  It's a bit of work, though.
12:20:55 <loki> why not gentoo:D
12:32:18 <loki> oi
12:32:23 <loki> damn insane girls
12:32:48 <loki> ordered a large pizza so i would go over to her house and talk to her
12:32:54 <loki> like omg
12:33:02 <loki> wht wrong with this world!!
12:36:43 <Leimy> show up naked
12:36:47 <Leimy> that'll teach her
12:36:50 <loki> lol
12:37:12 <mattam> that would be original at least
12:37:19 <loki> true it would be
12:37:51 <loki> but my gf might think me off for doing that
12:38:10 <Cale> nah, you'll be able to explain that
12:38:26 <Cale> "I had misplaced my pants."
12:38:50 <mattam> "wind got me!"
12:38:50 <XTL> So both of you show up naked.
12:38:55 <loki> lol
12:39:03 <loki> o my
12:39:21 <ibid> planning a betazoid wedding?
12:39:40 <loki> betazoid?
12:39:59 <ibid> not watched star trek tng? :)
12:40:10 <loki> i dont' watch tv
12:40:14 <ibid> ok
12:40:25 <loki> i spend all my free time with my gentoo
12:40:29 <ibid> a distinguishing feature of a betazoid wedding is that everybody is naked
12:40:44 <loki> lol :D
12:40:46 <loki> thats great
12:41:00 <ibid> (betazoids are a humanoid species)
12:41:01 <loki> ever seen that australian sheep picture?
12:41:58 <loki> with all the naked people looking like sheep
12:47:35 <loki> eh
12:47:35 <loki> oi
12:47:37 <loki> ummm
12:47:54 <loki> they sell hemp seeds in our local health store
12:50:06 <mattam> where do you live ?
12:50:14 <loki> toronto
12:50:47 <loki> canada
12:50:57 <mattam> are you really talking about marijhuana(?) ?
12:51:14 <loki> yep they are marijuana seeds
12:51:15 <Smerdyakov> I eat hemp seed waffles every morning.
12:51:38 <Cale> Marijuana is nearly legal in Canada.
12:51:38 <loki> they modified however
12:51:45 <mattam> aren't they treated so as to remove THC ?
12:51:46 <loki> for medicinal purposes yes
12:51:56 <loki> they are treated
12:52:02 <mattam> ok
12:52:03 <Hipo> I want to grow my own kannabis too.
12:52:11 <Cale> It's legal for medicinal purposes, and it's pretty hard to enforce existing laws against it.
12:52:48 <mattam> it's hard to enforce such laws anywhere i would say.
12:52:50 <Cale> Plus, the government is working to legalise it amid much concern and pressure from the US.
12:54:02 <loki> true true
12:54:21 <loki> i g2g
12:54:24 <loki> cya!
12:54:27 <Cale> later
12:54:33 <mattam> that would be the netherlands of north america
12:54:52 <lokiGoneForPizza> she convinced me
12:55:02 <mattam> but i suppose it is hard to produce localy
12:55:53 <Cale> If alcohol is to be legal, I don't see why pot should be illegal. I've seen people drunk, and I've seen them high on pot, and I prefer them high on pot.
12:56:13 <Cale> mattam: what, marijuana?
12:56:39 <XTL> In Finland, melatonine is marked as a prescription drug.
12:56:44 <mattam> yep
12:57:12 <XTL> Sucks, because it seems to be something I could use to help trying to live with DSPS.
12:57:35 <Cale> It's not that hard to produce. The government is doing an okay job of it. Hard to deal with the presently inconsistent laws though.
12:57:36 * mattam just remembers the high-on-thc marijuana traffic in canada
12:58:21 * XTL changes backup tapes
12:58:25 <mattam> i suppose indoor culture is affordable for rich north americans :)
13:22:28 <monotonom> finland is also pretty indoor.
13:23:59 <XTL> monotonom: But mostly not very affordable :)
13:24:45 <monotonom> My ignorant conception of Finnish pastime is hide at home and hack at OS kernels :)
13:26:37 <XTL> And get into heated arguments with the Dutch about it :)
13:28:13 <monotonom> Haha
14:52:11 <Igloo> Would anyone prefer a curses binding to give you IO functions rather than function in MonadIO?
15:01:23 <Jerub> only if it were also a monad.
15:01:47 <Igloo> Huh?
15:02:18 <kosmikus|away> Igloo: I don't understand the question
15:03:20 <Igloo> I think it would be better to have "addch :: MonadIO m => Char -> m ()" rather than "addch :: Char -> IO ()". I'm looking to see if anyone disagrees before I go to effort to do it  :-)
15:04:12 <kosmikus|away> I didn't know that MonadIO exists ...
15:04:48 <Igloo> Ah, it's in Control.Monad.State. Basically  liftIO :: MonadIO m => IO a -> m a
15:04:48 <kosmikus|away> where is it defined?
15:04:58 <kosmikus|away> ok
15:05:12 <Igloo> Oh, probably not really there actually, that probably just reexports it
15:05:24 <Igloo> With instances for IO and the various monad transformers
15:06:14 <Igloo> libraries/mtl/Control/Monad/Trans.hs
15:07:57 <kosmikus|away> what's the advantage? couldn't someone who wants that do the lifting? does it have to be built-in in a library binding?
15:08:23 <Igloo> It means you don't have to have liftIO scattered liberally throughout your code
15:08:59 <kosmikus|away> but there are thousands of other functions anyway that are "only" IO, not MonadIO ...
15:10:16 <Igloo> But would the world be better or worse if they were all MonadIO too?
15:11:11 <kosmikus|away> I'm not sure. Probably it would not be worse, although I am not such a huge fan of type classes ;)
15:14:19 <kosmikus|away> I guess if you have a specialize pragma for each function to specialize to the IO monad itself, then it only gives the user additional choice ...
15:16:04 <Igloo> It doesn't give additional choice, only (possibly) additional performance - or do I misunderstand what you mean?
15:18:49 <kosmikus|away> the fact that you use MonadIO gives the choice over using IO, the pragmas might ensure the same performance ...
15:19:02 <kosmikus|away> but I'm probably too tired to make sense ;)
15:21:25 <blackdog> Igloo: you're a TH guru, right? Any ideas how to do some IO work at compile-time?
15:21:49 <Igloo> $( runIO my_io; return [] )   at the top level
15:22:01 <Igloo> Or maybe qIO instead of runIO depending on what version you have
15:22:26 <Igloo> Oh, and stick a "do" in there too  :-)
15:25:37 * shapr sings drunkenly
15:26:08 <Jerub> shapr: please don't.
15:26:16 <shapr> actually, I'm quite good at singing.
15:26:23 <shapr> even when drunk
15:27:21 <shapr> but now, off to sleep
15:28:26 <blackdog> Igloo: weird - it works in 6.2 but not in 6.0. Of course, i'm being evil and using unsafePerformIO rather than qIO because I can't figure the types, but I wouldn't have thought a minor revision would make such a difference...
15:30:08 <Igloo> What goes wrong with the types?
15:31:50 <blackdog> well, with the code:
15:31:52 <blackdog> main = putStrLn $( qIO $                                                                     
15:31:56 <blackdog>             do                                                                                           
15:31:59 <blackdog>               putStrLn "foo"                                                                             
15:32:02 <blackdog>               x <- readFile "blah"                                                                       
15:32:05 <blackdog>               putStrLn "Bar"                                                                             
15:32:08 <blackdog>               return [| x |] )             
15:32:08 <blackdog>  Couldn't match `Exp' against `ExpQ'
15:32:08 <blackdog>         Expected type: ExpQ
15:32:08 <blackdog>         Inferred type: Q ExpQ
15:32:10 <blackdog> i get
15:32:22 <Igloo> Oh, lose the return
15:32:37 <Igloo> [| ... |] :: ExpQ = Q Exp
15:33:11 <blackdog> ...? That doesn't help, that's in the IO monad...
15:33:47 <Igloo> Ah, you want
15:34:33 <Igloo> do x <- qIO $ do {putStrLn "foo"; y <- readFile "blah"; putStrLn "Bar"; return y}; return [| x |]
15:49:26 <blackdog> Igloo: man, this is a brainfuck... think i'm getting it, though. Cheers mate.
16:21:29 <blackdog> Igloo: still there? Sorry to be so dense, but I can't get your example to work. AFAICT, it's got the type "Q ExpQ", which I can't do much with...
16:21:56 <Igloo> Oh, because having told you to remove the return I then went and copied and pasted it
16:22:26 <Igloo> Does it work if you remove it?
16:22:31 <Igloo> (the last one that is)
16:22:38 <XTL> I was kind of wondering about that. Not that I'm familiar with the actual issue.
16:23:19 <blackdog> Ah, brilliant. It didn't, but that's because I didn't have a "blah" file sitting there. It'd be nice if it actually complained when there's an error in code run at compile time...
16:28:13 <XTL> *** Exception: test: openFile: does not exist (No such file or directory)
16:28:18 <XTL> ghci does complain at least.
16:28:28 <XTL> Didn't try to compile that. Just played around a bit.
16:30:42 <blackdog> hm, that's interesting. cheers, i'll have to remember to play round in ghci when i'm having TH problems.
16:31:13 <Igloo> It used to complain I'm sure. Does it set $? ?
16:33:34 <XTL> I do wonder about runtime errors in general. Maybe it would be better to try to catch (possibly literally) them in the code.
16:33:59 <blackdog> (just checked) yes, it does set $?, but it's no more vocal than that.
16:34:49 <blackdog> hm. one more question: how do you set runtime parameters for things like max stacksize for the ghci TH uses?
16:35:05 <blackdog> I'm trying to read /usr/dict/words at compile time and running out of space...
16:35:46 <XTL> Is there a lazy reader? :)
16:37:01 <XTL> Sense Code: 0x0C Qual 0x09 (write error - loss of streaming) Fru 0x0
16:37:01 <XTL>   ¤%&#¤%&!
16:39:11 <XTL> That's what you get for having something (cd/dvd) in the same IDE bus with a burner.
16:39:34 <XTL> At least it was an RW (8cm) disc, so I can try to blank it and try again.
16:40:05 <Igloo> Something like +CTS -k10M possibly?
16:43:36 <blackdog> just tried the +RTS -K100M flags, and it's still compiling after 2 minutes, which i guess is a good sign. sometimes i forget how much faster compiled code is...
16:44:38 <XTL> Will it load a dictionary file.. into a list of chars?
16:46:58 <blackdog> yeah, then into a finite map. it worked ok when it happened at runtime in my much smaller machine
16:47:19 <blackdog> had to kill it, it was chewing up all available memory. back to the drawing board...:(
16:47:54 <blackdog> I'm sort of reluctant to put too much work into optimising it - it's run once and loaded into the binary.
16:52:47 <Igloo> The problem is probably the amount of code you are generating
16:53:06 <blackdog> 3.44s when i read it in at runtime...
16:53:26 <blackdog> I'm generating one big FiniteMap (and some intermediate lists, I guess)
16:53:57 <blackdog> think it's worth trying to eliminate some of the intermediate lists?
16:54:15 <Igloo> What do you do with the FM?
16:54:51 <blackdog> Nothing until runtime
16:55:03 <blackdog> then i just look up a string in it.
16:55:25 <blackdog> it's probably a pretty big structure - linear in the size of the dict, which is ~1M
16:56:22 <XTL> So in a way just grepping the file? Is there a reason to load it?
16:56:31 * Igloo can't see how this is working, unless FiniteMap is a member of Lift, but I suspect it's just the too much code problem
16:57:49 <blackdog> ok, i misspoke - it's looking up rather a lot of strings in it. I do need it online, and in the runtime version, it's not prohibitively slow: it'd just be nice to run it on slower machine and not have to spend so much time processing the dict.
16:58:32 <blackdog> Igloo: interested enough for me to paste it somewhere? it's not that important, really, I'm just playing aruond.
16:59:55 <Igloo> Well, if it's easy to do I'll have a quick look
17:00:03 <Igloo> Given this, is "" valid for the arguments for a control function expecting 2 parameters? "If the control function has more than one parameter, and some parameter sub-strings are empty, the separators (';') must still be present. However, if the last parameter sub-string is empty, the separator preceding it may be omitted."
17:03:42 <blackdog> ok, it's at http://haskell.org/hawiki/HaskellIrcPastePage
17:05:43 <blackdog> Igloo: oh, that's nasty. i'd say yes, but wouldn't be surprised to be wrong.
17:05:44 <Igloo> buildDict isn't getting run at compile time
17:06:07 <Igloo> yes was what I thought, but my brain hurt sufficiently I thought I'd get a second opinion  :-)
17:06:07 <blackdog> in the top version or the bottom one?
17:06:13 <Igloo> bottom one
17:06:41 <Igloo> That's equivalent to    dict = buildDict "a very large string"
17:06:43 <blackdog> so i should run it outside the [| |] and return the result?
17:06:57 <blackdog> that makes sense... ok, i'll try that. cheers igloo
17:07:13 <Igloo> Yes, but then you will have the problem that FiniteMap isn't a liftable type
17:08:13 <blackdog> oh. <downcast>
17:08:18 <blackdog> is that get-around-able?
17:09:36 <Igloo> Well, you could make some TH code to make a Lift instance for it, or you could copy the Data.FiniteMap module to your program's directory and add one into the source
17:10:02 <Igloo> instance Lift Bool where
17:10:02 <Igloo>   lift True  = return (ConE trueName)
17:10:02 <Igloo>   lift False = return (ConE falseName)
17:10:07 <Igloo> is the sort of thing you'd need for the latter
17:10:48 <Igloo> http://urchin.earth.li/~ian/Derive-snap-1.tar.gz might help you for the former
17:10:57 <blackdog> ok. thanks ian
17:11:40 <Igloo> But the datastructure is going to be just as big as the code so I don't know if GHC will fare any better with it
17:13:38 * Igloo realises the above just breaks for functions with variable numbers of arguments
17:14:22 <blackdog> that's true. bigger, probably. it's really just about splitting words into equivalence classes, so there's probably a more efficient representation, but i'm not sure how much effort i want to put in... it's just a silly little program to help my mother with the Target puzzle in the newspaper. :)
17:14:46 <blackdog> are there any plans to move to using compiled code in the TH part of the compiler?
17:15:33 <Igloo> The TH bit probably isn't the slow bit
17:16:19 <Igloo> But no, NAFAIK
17:16:48 <blackdog> Where do you think the bottleneck's likely to be, then?
17:17:03 <blackdog> oh, wait, i was profiling the runtime version. got distracted.
17:24:32 <Igloo> Well    do x <- readFile "/usr/share/dict/words"; writeFile "test.hs" ("main = putStrLn " ++ show x)    in ghci takes me less than a second whereas compiling the result takes 12s without optimisation and, well, I'll let you know how long with it when it finishes
17:26:40 <Igloo> 2m18s
17:29:13 <blackdog> hm. fair enough.
17:33:24 <blackdog> thanks Igloo, i've got a better understanding of what's going on. I hadn't really thought it through... basically, by writng a Lift instance, I'd effectively be telling GHC how to represent the FiniteMap as a literal, right? So I'd be in effect including it in the source code, which it's not overly happy about even with something as simple as just running 'putStr' over...
17:33:47 <blackdog> i'm almost certain that sentence doesn't parse. oh well.
17:39:00 * XTL mumbles something about hippies
17:43:52 <monotonom> I mumble to those who don't mumble to themselves.
17:47:47 <blackdog> that's very public-spirited of you, monotonom.
17:57:44 <Igloo> Right, blackdog
18:41:31 <SyntaxLaptop> unit testing rules
18:43:16 <loki> k question: is haskell based on recursive functions
18:43:28 <loki> like most things in it are recursive
18:43:31 <loki> or seem to be
18:43:40 <Smerdyakov> What do you mean?
18:44:28 <loki> for instance
18:44:36 <loki> length                  :: [a] -> Integer
18:44:37 <loki> length []               =  0
18:44:37 <loki> length (x:xs)           =  1 + length xs
18:44:59 <loki> it calculates the length right?
18:45:19 <loki> i am somewhat confused as to how and why this works but it seems to be calling itself
18:45:57 <loki> so i have list of 1-10
18:46:10 <SyntaxLaptop> loki: yes, it's recursive.
18:46:14 <loki> alright
18:46:19 <loki> thanx
18:46:25 <SyntaxLaptop> loki: recursion can be a little confusing, but it's everywhere in Haskell.
18:46:34 <loki> thats what i'm saying lol
18:46:40 <SyntaxLaptop> loki: it's rather fundamental actually :)
18:46:50 <loki> o
18:46:58 <loki> doesn't it slow things down?
18:47:06 <Riastradh> Why would it slow things down?
18:47:09 <loki> recursive functions that is
18:47:15 <monotonom> No.
18:47:24 <loki> in most languages you have to open a new instance of the function for every recursion
18:47:55 <monotonom> No.
18:48:01 <loki> so you end up with 200 functions open if you have to get the factorial of 200
18:48:12 <Riastradh> That implementation of length isn't as efficient as it could be, because it uses a sequence of stack frames for its accumulator (ignoring laziness), but it's not the fact that it's recursive that makes it inefficient.
18:48:44 <Riastradh> Most (more experienced) people would probably write it as something like this:
18:48:47 <monotonom> Well, actually you are right.  In most languages it is slow.  The same thing you can say about people: most people are dumb.  But both facts are hardly interesting.
18:48:53 <Riastradh> length list = length' list 0
18:49:13 <Riastradh>   where length' [] len = len; length' (x:xs) len = length' xs (len + 1)
18:49:59 <Smerdyakov> monotonom, do you have a device to determine who is dumb??
18:50:27 <loki> :| Riastradh you really lost me, eh i'll go try some more examples
18:50:42 <loki> i swear your brain has to function at a different level to understand haskell
18:50:57 <loki> monotonom: so are you saying its not slow in haskell? recursion that is
18:51:07 <Riastradh> Smerdyakov, yes.  It's a forked stick, somewhat like those diviners or whatever they're called.  You just have to point it at someone.
18:51:07 <loki> i wouldn't know, maybe when compiled its converted to loops
18:51:09 <monotonom> But try this C function.  unsigned f(unsigned i) { if (i==0) return 0 else return f(i-1); }   Compile it with gcc -O2 -S, look at the assembly code, see for yourself that the recursive call is translated to a simple goto.
18:51:48 <loki> how do you look at the assembly code?
18:51:50 <SyntaxLaptop> loki: the haskell compilers are pretty good at optimization :)
18:52:11 <loki> SyntaxLaptop: alright :D
18:52:15 <monotonom> Well you talk about efficiency. I thought you were qualified to talk about efficiency.
18:52:38 <loki> monotonom: i never said i knew assemble
18:52:46 <loki> assembler*
18:52:50 <monotonom> Then you are not qualified.
18:52:55 <loki> monotonom: alright i'm not
18:53:03 <SyntaxLaptop> monotonom: he was asking a natural enough question.
18:53:09 <monotonom> And please don't just repeat other people's heresay about what is slow and what is fast.
18:53:22 <SyntaxLaptop> monotonom: he wasn't "repeating" he asked.
18:53:26 <monotonom> Some of the heresay was true 50 years ago but not this century.
18:53:36 <loki> monotonom: i do know from experienced that if put it loops it works faster then in recursive functions in cpp
18:54:00 <monotonom> My experience with gcc -O2 is opposite.
18:54:18 <loki> well for the example of finding the fastest way out of a maze
18:54:42 <loki> but thats not a very good one i guess
18:54:43 <loki> nm
18:55:01 <monotonom> Well, I have shown you a recursive program in C and you can benchmark it.
18:55:32 <loki> alright, i won't argue
18:55:45 <loki> *shrugs* it doesn't really matter to me, i was askign
18:55:47 <loki> asking*
19:01:33 <loki> what exactl does : length                  :: [a] -> Integer
19:01:34 <loki> mean
19:01:55 <loki> that its a calculates lists and returns an integer?
19:02:31 <SyntaxLaptop> the input is a list of "type a" which in this case means any type, and returns an integer
19:02:38 <SyntaxLaptop> "::" should be read "has type"
19:03:10 <loki> aliright thanks
19:03:56 <loki> so if it was [z] it wouldn't makes a difference?
19:04:22 <SyntaxLaptop> true.
19:04:36 <loki> just wondering
19:06:09 <loki> are there any standards that should be followed or is it generally believes that you can do as you will with  type definitons and the like?
19:06:32 <monotonom> There are rules.
19:07:12 <loki> is there any place i can read about them?
19:07:21 <loki> can you refer me to sucha  place?
19:07:36 <SyntaxLaptop> loki: in the simple case, it doesn't make much difference, but you might get more complicated...
19:07:37 <SyntaxLaptop> @type fst
19:07:38 <lambdabot> fst :: (a,b) -> a
19:08:02 <SyntaxLaptop> so there's two types there, but the return value is the same type as the first element of that tuple
19:08:49 <loki> er :|, can you give me an example of input and output? please
19:09:02 <monotonom> http://www.haskell.org/onlinereport/decls.html  but if you can't digest it, don't worry now. The rules are pretty reasonably liberal.
19:09:30 <loki> thanx monotonom 
19:09:40 <monotonom> fst (10, "hello")  gives you 10.
19:10:43 <loki> alright, do the () function the same as []? or are they different?
19:10:52 <loki> as in declaring a list
19:11:23 <SyntaxLaptop> loki: are these homework questions?
19:11:25 <monotonom> Different.
19:11:49 <loki> SyntaxLaptop: lol no, sorry i'll check for myself
19:12:17 <monotonom> [Int] refers to lists of Int's, arbitrary length, but all items are Int's.
19:12:47 <loki> alright
19:12:53 <monotonom> (Int,String) refers to pairs (two items), first item must be Int, second item must be String, and the "length" is fixed: always 2.
19:13:25 <loki> okay, so its still like a list?
19:13:29 <loki> just more defined
19:13:43 <SyntaxLaptop> loki: well, they're good questions. understanding them will teach you a lot about Haskell, so I just wanted to check to see if they're homework questions, since if you never really understand them, you'll probably have trouble later.
19:14:20 <loki> no no i'm not taking a course or anything, it just seems like the most logical thing to ask
19:14:39 <Smerdyakov> The most logical thing to do is read the nice material already prepared for you.
19:15:25 <Cale> Smerdyakov: people enjoy helping others learn. He's free to ask all the questions he likes.
19:16:03 <loki> thnx
19:16:04 <monotonom> You can also have (Int,String,Bool), ... fixed length things.  They are generally called tuples.  For pragmatic reasons, we consider tuples very different from lists.  But that's just for pragmatic reasons.
19:16:04 <Smerdyakov> Cale, the problem comes if he learns less well through not taking advantage of well-crafted texts.
19:16:24 <loki> thanx monotonom 
19:17:25 <loki> :|
19:17:31 <loki> Smerdyakov: rather harsh no?
19:17:41 <Cale> Well, yeah, I highly recommend reading through a text. But it's also good to talk to people about how to use the language and how it works.
19:17:43 <Smerdyakov> loki, it's tough love. *big kiss*
19:18:06 <loki> awww *hugs* Smerdyakov your so sweet :D
19:18:32 <loki> i am reading a text actually
19:18:42 <loki> its just it doesn't explain everything
19:19:12 <SyntaxLaptop> Smerdyakov: you should be tolerant of other peoples' learning (and teaching) styles.  not everyone learns in the same way.
19:19:57 <Smerdyakov> I would be very surprised to find someone who learns best in the chaotic environment of an IRC channel shared with other conversations.
19:20:13 <Smerdyakov> Low bandwidth... low signal-to-noise...
19:20:22 <loki> Smerdyakov: i am not talking in any other rooms
19:20:47 <Smerdyakov> What I mean is that others will have conversations in _this_ channel.
19:21:04 <loki> traditionally teaching is taught by a teacher or a group of teachers rather than a text
19:21:15 <loki> Smerdyakov: true, they could
19:21:20 <loki> Smerdyakov: but are they?
19:21:21 <Smerdyakov> Not programming. Programming is learned by doing.
19:21:47 <Cale> Well, everything helps.
19:21:49 <loki> Smerdyakov: very true, and i am doing, but i need the syntax explained in order to understand the errors i'm getting
19:22:16 <loki> Smerdyakov: simple experimintation won't tell you everything you need to know
19:22:30 <loki> Smerdyakov: thats why we are social animals!! :D we share information
19:22:43 <loki> lol :D *hugs Smerdyakov *
19:22:51 <Smerdyakov> I thought we were social animals to coordinate in hunting tofu.
19:22:58 <loki> lol
19:23:13 <loki> naw the reason we got so far is cause we shared information
19:23:28 <Smerdyakov> You're right. That's how they learned to catch textured soy protein.
19:23:30 <loki> thats why all revolutions in information have lead to faster advancement in technology
19:24:00 <loki> Smerdyakov: stop being so thick :P one person learns something then explains it to other people
19:24:23 <Smerdyakov> Like how tofu will be caught by a mousetrap!
19:24:32 <loki> Smerdyakov: but einstein didn't learn everything through experimintation, like he said " i stood on the shoulders of giants"
19:24:42 <loki> oi oi oi
19:24:46 <SyntaxLaptop> Smerdyakov: when I'm reading a text, and I get stuck on something, it is very nice to have someone help me get unstuck so I can move on, rather than trying to keep a stack of things I'm stuck on, poping them one-by-one.
19:25:01 <monotonom> Einstein didn't IRC, that's all I know. :D
19:25:10 <Smerdyakov> SyntaxLaptop, certainly, but I think loki has not exactly been doing that.
19:25:12 <loki> monotonom: :P he would if he had irc
19:25:19 <blackdog> "charlie don't surf" for academia, hm?
19:25:22 <loki> monotonom: full of people that knew more than him about math
19:25:27 <Smerdyakov> <einstein> lol fu
19:25:42 <SyntaxLaptop> hey blackdog, how's it going?
19:25:51 <SyntaxLaptop> black: those wx packages working for you?
19:25:53 <blackdog> Hey syntax. not bad, i'm playing with TH.
19:25:57 <SyntaxLaptop> sweet.
19:25:59 <blackdog> like a dream.
19:26:11 <blackdog> how long till they're in standard debian?
19:27:22 * SyntaxLaptop shrugs
19:27:32 <SyntaxLaptop> ask igloo... I guess he'll be maintianing them.
19:28:59 <blackdog> fair enough. just wondering how long it usually takes...
19:30:17 <SyntaxLaptop> I'm not sure that igloo has even uploaded it yet.
19:34:24 <blackdog> 'k. hacked anything interesting lately?
19:36:31 <SyntaxLaptop> blackdog: hm. interesting stuff at work that I guess I can't talk about much, and working steadily on LIP... also reading The Pragmatic Programmer, which is a great book (shapr recommended it)
19:37:29 <loki> just out of curiosity is anyone here NOT a linux user?
19:37:38 <blackdog> didn't realise it was a book. i did some of the kata on the pragprog.com page... good little figer exercises.
19:37:40 <SyntaxLaptop> blackdog: i was recently thinking that TH could be used to make a nice unit test framework... I htink there's a quickCheck preprocssor that looks for function names with a particular prefix and does something special to them... idono, just a half-baked thought.
19:37:50 <SyntaxLaptop> what's kata?
19:38:53 <wagle> loki: i use all sorts of systems.. why?
19:39:03 <blackdog> it's from martial arts: in that context, it means a fixed sequence of movements. in programming, i guess it's more like a more-or-less trivial exercise meant to hone your ability in larger systems.
19:39:33 <loki> wagle: just wondering what kind of crowd learns such eccentric programming languages
19:39:39 <blackdog> syntax: so it wouldn't even compile if the unit tests weren't satisfied. 
19:39:48 <blackdog> interesting idea.
19:39:51 <loki> wagle: :D
19:39:52 <monotonom> I sometimes use Windows, when I want to play games.
19:40:05 <loki> well ofcourse
19:40:11 <blackdog> loki: who's eccentric? come over here and say that... :)
19:40:31 <loki> blackdog: :P , i never said i was normal lol
19:40:38 <monotonom> I am eccentric.
19:41:12 <SyntaxLaptop> blackdog: heh. that wasn't exactly my idea, I say it's yours. run with it ;) 
19:41:12 <loki> only beer commercials aren't these days
19:41:12 * wagle is a scheme-head who saw the haskell light way back in 1988
19:41:32 <SyntaxLaptop> blackdog: yeah, I've seen those before (in martial arts). they're called different things in different arts, as far as I know.
19:41:43 <loki> wagle: exactly how long has haskell been aroung?
19:41:55 <wagle> 1989?  1990?
19:42:15 <loki> wow, :| most people i ask have never herd of it
19:42:24 <loki> i thought it was a relativly new thing
19:42:34 <Cale> It was properly standardised in 98.
19:42:37 <rt> most new things are in reality old things.
19:42:55 <loki> rt: true, but C is OLD
19:43:06 <Cale> Haskell is actually relatively new as far as language design is concerned.
19:43:27 <rt> it's younger than me, therefore new!
19:43:33 <loki> true
19:43:38 <SyntaxLaptop> eh
19:43:38 <wagle> lots of things about haskell are newer than 1990
19:43:42 <SyntaxLaptop> s/eh/heh
19:44:07 <blackdog> syntax: so where were you going with it?
19:46:53 <wagle> Ahh, here it is: "Report on the functional programming language Haskell" 30 June 1988 (Draft 1)
19:47:20 <loki> wow
19:47:37 <loki> less than a year older than me
19:47:47 <loki> younger*
19:47:55 <wagle> was a year or two before the first implementation..  from what i heard, anyway
19:48:07 <loki> well then its older :P
19:48:21 <loki> or you mean 1990?
19:48:57 <Cale> wagle seemed to be implying that the paper was written a year or two before anyone wrote an interpreter or compiler.
19:49:05 <wagle> Cale is correct
19:49:56 <loki> o
19:49:58 <wagle> this is the original specification of haskell
19:50:09 <monotonom> It is still quite a kudos that Haskell is young and pretty much standardized.  Even C++ took longer.
19:50:28 <monotonom> Similar kudos for SML.
19:50:50 <loki> well the crowd that adopted it, is not your average cracker
19:51:00 <loki> or script kiddie
19:51:07 <blackdog> is it really standardised? I thought we only had a semantics for Core Haskell... it's all a bit handwavey
19:51:28 <loki> well the terminology is rather complex i can say that
19:51:39 <wagle> ... "In September of 1987 a meeting was held at the FPCA Conference in Portland, Oregon, to discuss a small crisis that had emerge in the functional programming community: ..."
19:52:12 <monotonom> And the semantics of C has become rigorous after all these years? :D
19:52:30 <rt> the "small crisis" is still pretty much true: functional programming languages are perceived as being impractical, and the perception isn't entirely misplaced.
19:52:42 <Cale> The terminology is complex because it's at least in part a research language.
19:52:57 <wagle> semantics of C is quite rigorous, just that GCC is a really big and hairy proof
19:52:57 <loki> it's highly mathematical
19:53:03 <loki> most languages don't have pi defined
19:53:17 <Cale> actually, most languages do define pi somewhere
19:53:31 <loki> as a standard library?
19:53:42 <Cale> usually in whatever math library
19:53:49 <wagle> rt: it goes on to discuss standards
19:53:54 <Cale> wherever you find sin, cos, etc defined.
19:54:08 <loki> Cale: but they don't have it in their standard library, math library is understandable
19:54:28 <loki> in ghci pi is defined
19:54:33 <rt> yes, but standards haven't really helped with the bigger crisis: not many people write programs in functional programming languages.
19:54:51 <rt> until that happens, FP will continue to be a fringe academic exercise.
19:54:53 <Cale> using trig functions can get annoying without pi somewhere.
19:55:10 <loki> see
19:55:34 <loki> rt: true, if it wasn't for this irc chat room i would never have been able to follow any of the tutorials
19:55:39 <blackdog> rt: some mainstream stuff is coming in, though. mldonkey's quite a popular filesharing tool, and it's written in ocaml.
19:56:18 <Cale> loki, what do you think the tutorials you're reading could do better?
19:56:29 <loki> someone should really make a layman's tutorial based on all standard language tutorials
19:56:39 <Cale> also, have you tried Hal Daume's tutorial?
19:56:56 <monotonom> I think the future is bright, now that two FP books have been reviewed on slashdot *and* they receive warm welcome in the reader comments.
19:57:06 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
19:57:16 <loki> i have to login to use it
19:57:23 <Cale> not with that link :)
19:57:49 <SyntaxLaptop> monotonom: :)
19:58:02 <rt> it looked bright 15 or more years ago when I first studied this stuff too.
19:58:23 <rt> not really very much has changed in that time.
19:58:46 <loki> can't they have a html tutorial? :(
19:58:47 <Cale> anyway, you might see hdaume around on this channel sometimes, so if you find that his tutorial needs work in places, you can let him know :)
19:58:51 <loki> i don't like pdf, its so bright
19:59:02 <Cale> bright?
19:59:37 <monotonom> Remember that just two years ago the same herd would at best just say "I read SICP (by choice or course requirement) and it opened my mind, although I will continue to program imperatively."  Now they are all jumping up and down saying "I am sold!"  Bear in mind that we are talking about a herd pretty entrenched in Perl and Python.
20:00:13 <rt> there is a difference between being sold and actually making a switch.
20:00:17 <SyntaxLaptop> monotonom: you think people are saying "I am sold"?
20:00:28 <monotonom> Alright I'm exaggerating.
20:00:30 <rt> I suspect that most people's enthusiasm is blunted when they try to program in the large with FP languages.
20:01:46 <loki> the recursivness takes some getting used to
20:02:37 <Cale> I think it's less the need for direct recursion, and more just that people are unfamiliar with map, fold, and filter.
20:02:38 <Jerub> does it?
20:02:47 <SyntaxLaptop> loki: someone once told me that there had been a study suggesting that people who were taught recursion first had trouble learning loops. not sure if that's true, but its interesting.
20:02:51 <rt> I suspect that ideas such as laziness are much harder to deal with.  Recursion seems utterly natural.
20:03:01 <monotonom> I think it is too much to ask for a switch.  (Just like I dislike Perl-only programmers, I see the same problem with Haskell-only programmers.)  But if everyone uses FP 10% of the time, it is good enough.
20:03:55 <rt> if FP offered significant advantages over other programming languages 10% of the time, then that would be good.
20:04:18 <monotonom> Ah I must plug my shameless plug on the subject of recursion vs. loop.
20:04:20 <loki> what are the advantages of FP?
20:04:43 <monotonom> dataflow and data dependency is crystal clear.
20:05:01 <wagle> huh?
20:05:01 <loki> in english?lol
20:05:20 <Cale> Referential transparency: being able to call a function with a particular set of parameters and get the same thing every time.
20:05:34 <monotonom> In Chinese I can do.
20:05:40 <wagle> time and space complexity of lazy programs is notoriously hard to predict
20:06:05 <rt> ergo: if the time and space requirements of your program are important, laziness will mostly just irritate you.
20:06:18 <monotonom> I need to collect all my little writings at a single place.
20:06:33 <loki> wow i must say, it really is chinese to me
20:06:57 <loki> being able to call a function with a particular set of parameters and get the same thing every time, i dono but in C 2+2 is always 4 or i don't understand you
20:07:12 <monotonom> http://www.google.ca/groups?selm=4uhe5s9xee.fsf%40vex.net&oe=UTF-8&output=gplain
20:07:20 <Jerub> the typing system is actually something I've seen quite a few people having trouble with.
20:07:46 <Cale> loki: nope, look at something like a function that gets a character from the user
20:07:50 <rt> in C, if you call a function f(x), it could return multiple different values, depending on some internal hidden state.  That doesn't happen for languages with referential transparency.
20:07:59 <themus> loki is being mischievous
20:08:10 <themus> :)
20:08:45 <Cale> referential transparency is nice, because, for one, it makes things easy to debug.
20:08:53 <wagle> in haskell, i can write a monadic accessor function that returns different values each time
20:08:54 <Jerub> ahh! but 'f' might refer to different functions however ;)
20:09:34 <loki> c i have to learn what all these things are 
20:09:39 <Cale> wagle: but it wouldn't really. You'd write something with type a -> IO b, and it would return the same IO action every time.
20:09:43 <wagle> do { x <- read ; y <- read ; return (x,y) }
20:09:51 <loki> before i can understand why FP is better than traditonal languages
20:10:28 <monotonom> int unconstant(void) { static int r = 0; return (r++); }
20:10:32 <rt> FP isn't better.  It has certain properties which might be desireable.  It has certain properties that might be undesireable.  
20:10:48 <wagle> Cale: yeah, and the state-mangling c function is sortof the same thing
20:11:17 <blackdog> NO WAY DQQD IMPERATIVE LANGUAGES SUX0R HASCAL FOREVER!11!1!
20:11:20 <wagle> i'd use haskell for compilers, perl for sysadmin
20:11:37 <blackdog> *ahem*. scuse me, my inner skript kiddie got out of control for a sec.
20:11:44 <monotonom> Anyway my analysis of recursion vs. looping --- which one is more "natural" --- is a must-read.  URL given earlier.
20:11:48 <Cale> wagle: It's just which level you look at it from.
20:11:54 <monotonom> (Shameless plug)
20:11:55 <SyntaxLaptop> wagle: do you think that there's something about perl itself that makes it good for sysadmin, or do you think that better libraries in Haskell will make it suitable. I suspect that hte later is true.
20:12:11 <SyntaxLaptop> monotonom: speaking of shameless plugs, I sent you a msg :)
20:12:15 <wagle> "string manipulation"
20:12:29 <monotonom> Ah but I set myself up to discard all msgs.
20:12:35 <Cale> In some sense, a value of type IO a is an inert value, and in another sense, it's a computation that will return an a.
20:12:35 <monotonom> Just one moment.
20:12:38 * SyntaxLaptop looks cross-eyed at his own code
20:12:55 <loki> i find bash best for me as sys admin
20:13:24 <monotonom> Alright please send it again.
20:13:24 <wagle> sysadmin 100+ machines for a year or three, then get back to me on bash vs perl
20:13:27 <loki> it is the langauge of my command line lol
20:13:32 <SyntaxLaptop> wagle: do you think that string manipulation libraries would solve the problem?
20:14:10 <monotonom> bash is quite alright.
20:14:14 <loki> bash does suck at the string manipulation level i do admit, but thats what gawk is for :D lol
20:14:31 <blackdog> loki: that's half the problem.  it's trying to serve two purposes, which is rarely good. Olin Shivers' scsh paper has some interesting stuff on the role of shells...\
20:14:57 <wagle> SyntaxLaptop: i think half of it is the build-in-syntax support
20:15:32 <loki> blackdog: how is it trying to server two purposes? 
20:15:36 <blackdog> i'd really appreciate a shell with static typing.
20:15:46 <wagle> SyntaxLaptop: thought the jury in my head is still out..  i've been intending to try out haskell-on-bare-metal sorts of things
20:15:54 <SyntaxLaptop> wagle: :)
20:15:57 <wagle> s/thought/though/
20:16:29 <loki> wagle: planning on making your own os?
20:16:36 <monotonom> All shells have a pipe operator "P | Q" that ties the output of P to the input of Q.  I want one that in addition ties the input of P to the output of Q.
20:17:04 <Smerdyakov> Do you, P, take this as your lawfully wedded Q?
20:17:11 <blackdog> loki: on one hand it's a scripting language, and on the other it's a control language. for a control language, you want it to be extremely terse, with lots of shortcuts: for a scripting language, I think it's more important that it's readable, good support for catching errors, that sort of thing.
20:17:33 <wagle> monotonom: write one
20:17:41 <blackdog> loki: but go read the paper. olin shivers is much smarter and more eloquent than me.
20:17:52 <Cale> monotonom: It's not so hard to get that effect with a fifo.
20:17:58 <SyntaxLaptop> wagle: OOI, have you seen parsec and the regEx library?
20:17:58 <Smerdyakov> monotonom, why would I want that operator?
20:18:16 <loki> blackdog: alright
20:18:33 <wagle> make pipe 1, make pipe 2, fork-dup(1)-dup(2)-exec(P), fork-dup(2)-dup(1)-exec(Q)
20:19:16 <wagle> SyntaxLaptop: no i have seens parsec or regEx
20:19:34 <wagle> SyntaxLaptop: no i havent seen parsec or regEx
20:20:03 <monotonom> It is alright if you don't want one.  But I want one. :)  A computation-intensive Haskell program and a GUI-intensive Java program can be written to talk to each other through stdio, so computations are done by the Haskell program but GUI effects can be done by the Java program.  For example putting a GUI frontend to a theorem prover.
20:20:06 <SyntaxLaptop> is there a portable way to set the permissions, or at least set a file to be non-writable?
20:20:36 <Smerdyakov> monotonom, and you would expect to indicate this coupling yourself with each invocation?
20:20:40 <wagle> we had a pipeline builder that used a more complex notation that specified what sorts of pipes, etc
20:20:55 <loki> Java is sooo SLOOOOW though
20:21:04 <Smerdyakov> loki, incorrect
20:21:09 <loki> how so?
20:21:21 <loki> ever tried drawing a circle on a p1?
20:21:25 <Smerdyakov> Java compilers are reasonably competitive with C compilers.
20:21:28 <loki> there is actual time it takes
20:21:33 <Smerdyakov> The problems come with poor GUI libraries.
20:21:39 <loki> i read some benchmakrs
20:21:54 <loki> C at 5 seconds while java at 14
20:22:10 <wagle> man, i gotta hurry up and figure out why "java is slow" in the face of compiled and jit java
20:22:10 <Smerdyakov> Don't confuse the language with the libraries.
20:22:22 <Smerdyakov> And don't confuse 1998 with today. :P
20:22:25 <monotonom> Let the operator be called |||.  Then I can write a shell script named "superduper" with content "hol98 ||| java HOLGUI".  User can run "superduper".
20:22:58 <Smerdyakov> monotonom, and user must stop this by sending a kill signal to both processes, or what?
20:23:02 <monotonom> Alright I could write a C program to do exactly that, but I am a reuse biggot.
20:23:49 <monotonom> Um why would you ever want to terminate a theorem prover? :D  The GUI frontend can always provide a "quit" command.
20:23:55 <SyntaxLaptop> is the stuff in System.Directory portable?
20:24:20 <loki> buttons have always confused me
20:24:49 <wagle> i thought you always wanted your theorem provers to terminate
20:24:52 <Smerdyakov> Shell scripts with features that are only useful for GUI's seem dodgy to me.
20:25:07 <loki> very true
20:25:11 <monotonom> "terminate" as in "stop using", not "finishing".
20:25:29 <wagle> i left out the *<8-p
20:25:37 <loki> GUI's are evil
20:25:40 <Smerdyakov> WHOA!
20:25:46 <Smerdyakov> NICE smiley, wagle!!
20:25:46 <loki> They should become scriptable
20:26:11 <monotonom> The theorem prover hol98 is quite scriptable.
20:26:35 <Smerdyakov> monotonom, how does it compare to Coq?
20:26:51 <loki> see issue is that you odn't really need a gui if you can script it
20:26:57 <loki> you can use the script
20:27:23 <monotonom> It lacks dependent types. It has a more full-fledged, general purpose programming language (SML).
20:27:24 <wagle> ... you want to interact with it
20:27:42 <monotonom> No I don't always want to script it.
20:28:07 <Smerdyakov> What does it mean that it lacks dependent types?
20:28:48 <Smerdyakov> Like nothing of type nat -> sometype?
20:29:11 <Smerdyakov> That didn't make sense.
20:29:15 <monotonom> I need to recall dependent types.
20:29:17 <Smerdyakov> Oh wait. It did.
20:29:27 <Smerdyakov> Like:
20:29:41 <Smerdyakov> Inductive boundedNat := makeIt : nat -> boundedNat.
20:29:42 <Smerdyakov> In Coq.
20:29:47 <Smerdyakov> That is something not possible in HOL?
20:29:58 <Smerdyakov> I did it again. That was nonsense.
20:30:51 <Smerdyakov> Inductive boundedNat := makeIt : [n,m:nat] (lt n m) -> boundedNat.
20:30:58 <Smerdyakov> Something like _that_? :)
20:31:26 <Smerdyakov> Inductive boundedNat : nat -> Type := makeIt : [n,m:nat] (lt n m) -> (boundedNat m).
20:31:29 <Smerdyakov> That looks like what I want.
20:31:55 <monotonom> What does it say?
20:32:46 <Smerdyakov> There is a family of types boundedNat indexed by natural numbers.
20:33:08 <Smerdyakov> You make one by calling the construct makeIt with two naturals and a proof that the first is less than the second.
20:33:19 <Smerdyakov> This gives you a boundedNat indexed by the second number.
20:34:23 <monotonom> The intention is that "boundedNat 3" is the type that admits just the values 0, 1, 2?
20:34:48 <Smerdyakov> Yes
20:34:56 <monotonom> Then HOL can't do it.
20:35:06 <Smerdyakov> How barbaric.
20:35:27 <wagle> isnt HOL higher order classical logic?
20:35:29 <monotonom> (Well, can't do it in the type system.  You can always introduce predicates, sets, ...)
20:35:46 <monotonom> Yes it's classical.  Simply typed Church thingy.
20:36:17 <wagle> i have the impressions that introducing dependent types generally also introduces undecidability
20:36:18 <Smerdyakov> I just tried what I just typed in Coq, and it doesn't like it. Let's see if I can figure out how to do this. :D
20:37:23 <wagle> Smerdyakov: seemed twice as hairy as the examples I vaguely remember from two summers ago
20:38:07 <monotonom> That is why Coq sticks with constructive logic, I suppose.  By being constructive, you hide incompleteness under the rug.
20:38:48 <monotonom> (It really means it throws the incompleteness ball back at the user. :)
20:38:49 <Smerdyakov> You can do classical logic with Coq...
20:39:06 <monotonom> Yeah but you can't do constructive logic with HOL.
20:39:49 <wagle> yeah, the stress was on constructiveness
20:40:12 <wagle> pretty cool to implement continuations
20:40:18 <wagle> .. in the logic
20:41:07 <monotonom> HOL goes so far as to axiomatize the Hilbert choice operator.  It is stronger than the axiom of choice.
20:41:44 <wagle> which one is hilbert?
20:42:11 <Smerdyakov> (Oh, I was close. I just needed to change [] to () in the code above. :P)
20:42:21 <wagle> (if i actually got to use this stuff, i might remember something)
20:43:33 <Smerdyakov> I wonder why I would want to use silly HOL when Coq is so pretty. :)
20:45:09 <monotonom> For predicate P:T->bool, the Hilbert choice operator @ gives you @P:T.  If there exists x with P(x), then P(@P) is true.
20:45:13 <Smerdyakov> It's pretty damned smooth. Like pretty much the entire logic coming from inductive definitions and lambda calculus conversion rules.
20:48:44 <Smerdyakov> It's like HOL is the 20th century way of doing things and Coq is the 21st. ;)
20:49:12 <monotonom> But HOL provides a 21st-century programming language.
20:49:42 <Smerdyakov> Coq compiles 20th-century proofs into multiple 21st-century programming languages.
20:49:59 <monotonom> That is true.
20:50:19 <Smerdyakov> And the programming capabilities are really quite sufficient for what you ought to be using it for.
20:50:57 <Smerdyakov> It's basically the functional subset of OCaml without some syntactic sugar.
20:51:24 <monotonom> As long as I can use it to write yet another theorem prover I'm happy.
20:52:11 <Smerdyakov> That's not what theorem provers are for!
20:53:39 <wagle> yeah, who wants a provably correct theorem prover?
20:55:31 <Smerdyakov> You don't code it in the theorem prover. You just use the theorem prover to prove it correct.
20:55:33 * wagle runs, stops, looks around, and notices noone chasing him
20:56:48 <wagle> ... someday i will become a touch typist
20:57:19 <monotonom> Well, apparently Coq is written in ML.
20:57:29 <Smerdyakov> But of course.
20:57:33 <Smerdyakov> You didn't know that?
20:57:51 <Smerdyakov> I think the Coq people and the OCaml people are probably on the same floor at whatever building they have at INRIA. :D
20:58:25 * Smerdyakov checks some office numbers. ;D
20:58:38 <monotonom> Yes I know that.  I raise it because ML started out as a programming language provided by some other theorem prover (HOL).
20:59:33 <Smerdyakov> monotonom, I think you may be a bit off. ML was first developed with LCF.
20:59:47 <monotonom> Yeah alright s/HOL/LCF/
21:00:12 <wagle> i dunno..  doesnt Herman Geuvers have something important to do with Coq?
21:02:35 <Smerdyakov> This schematic diagram should help.
21:02:50 <Smerdyakov> wagle ---question---> Smerdyakov ---doesn't know the answer---> ????
21:03:52 <wagle> i've been trying to page his lectures from two years ago back into my brain..  not a small amount of bitrot on the archive medium
21:04:13 <wagle> but he has them on the web at http://www.cs.kun.nl/~herman
21:04:29 <Smerdyakov> I should have known you'd be Dutch with a nick like that. ;D
21:04:58 <wagle> me?  dutch?
21:06:23 <Smerdyakov> You are Dutch. Don't deny it.
21:06:25 <wagle> my great great great great great grandfather (Johan Adam Wegel) did leave Amsterdam on a ship in 1722...
21:06:33 <Smerdyakov> I knew it. Spies everywhere.
21:07:00 <wagle> its too late for you..  surrender
21:07:12 <Smerdyakov> Done and... done!
21:12:39 <loki> dialup :|
21:12:52 <loki> take my 3Mb connection muwahahahha!!
21:12:52 <loki> lol
21:13:12 <wglwill> Hi, can haskell be used as an embedded language very effectively somehow?
21:13:27 <wglwill> Like with the hugs interpreter maybe
21:15:30 <monotonom> Yes.
21:16:04 <monotonom> Actually I don't know. I'm just being optimistic.
21:16:31 <monotonom> I always lie. Don't believe me. I lie to all those who don't lie to themselves.
21:16:50 <wagle> i read something that indicated that ghc intended to be the "motherboard" of haskell implementations
21:16:51 <Smerdyakov> monotonom, I think your phone is ringing.
21:16:53 <wglwill> heh
21:17:02 <loki> hugs can't be, theoretically compiled with ghc it can no?
21:17:09 <loki> its all in assembler one way or another
21:17:37 <wagle> hugs is written in C, its original creator is embarrassed by it
21:18:03 <SyntaxLaptop> wagle: is that true?
21:18:27 <monotonom> Woah?!  I thought real programmers take pride in using magnets to manually enter their programs to disks?
21:18:42 <loki> lmao
21:19:32 <loki> i meant that if you compile haskell programs with ghc, from what i understood of what monotonom you can run it as easily as a C program is one way or another its in assembler or whichever, since you can view both in assembler
21:19:34 <wagle> use sparks from flint to power electromagnet
21:20:03 <wagle> as i remember, some (not all) of hugs is in C
21:20:29 <loki> helium is in haskell
21:20:37 <monotonom> No, use sparks from flint to write to your CD-R.
21:20:56 <loki> you can't do that:P
21:21:01 <loki> what you can do is direct light from the sun
21:21:10 <loki> with a complex array of home made mirrors
21:21:23 <loki> uber leet!!
21:21:23 <loki> lol
21:21:26 <monotonom> What if it is midnight?  Real programmers sleep in daylight...
21:21:34 <wagle> sunlight and programmers?  in the same place?
21:21:56 <Cale> use moonlight
21:21:59 <loki> thats why you have it reflecting from the other side of the planet!! :P
21:22:09 <loki> like no duh!! lol
21:22:22 <loki> like omg!! i'm a lil girl lol oi sorry i'll shut up now
21:22:23 <Smerdyakov> Use the luminiferous ether.
21:22:39 <Cale> that's why you need that "phase of the moon" clock
21:22:40 <wagle> if moonlight is reflected sunlight, howcome its safe?
21:22:49 <Cale> to tell when you should do your cd burning
21:23:23 <loki> lol :D exactly
21:31:05 <loki> :(
21:41:54 <loki> no ops in this room
21:41:59 <loki> 71 people though
21:42:39 <loki> @fst
21:42:47 <loki> o well
21:51:36 <ibid> visible ops are irrelevant on freenode
21:53:46 <loki> ?
21:56:56 <wagle> probably because real ops just (1) tell the server to turn on their privs, (2) do whatever needs doing, (3) turn off privs
21:57:48 <ibid> indeed
21:58:16 <ibid> it seems to be bad form on freenode to display ops when not needing them
21:58:27 <ibid> at least on those channels where i've been
21:59:27 <loki> o
22:04:54 <Cale> shapr is an op here
22:05:00 <loki> o
22:05:11 <loki> didn't know the policy or anything
22:06:07 <wagle> there's a policy?
22:06:22 <loki> i dono a tradition or whichever
22:07:37 <ibid> you learn by watching and listening ... and theorizing
22:09:56 <wagle> no static type system to keep you from Doing Bad Things [TM]?
22:12:45 <wagle> oic: need irc ||| Coq
23:12:06 * rt wonders why books cost as much as a playstation2.
