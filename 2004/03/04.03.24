00:00:02 * juhp uploads a gtk2hs snapshot built with ghc-6.2.1
00:00:19 <jdrake> something like this: if 0==0 then 4 else error "bastard"     how can that work when the types are not the same
00:00:21 <juhp> i should really make an apt/yum repos
00:00:21 <skew> the semantics are pretty clever - the value of an expression is either a normal value, or a set of exceptions
00:00:33 <skew> error :: String -> a
00:00:39 <skew> the types are the same
00:00:48 <shapr> juhp: what's yum?
00:00:57 <jdrake> error :: forall a :: ?. [Char] -> a
00:01:00 <jdrake> what is the ?.
00:01:20 <skew> and the side effect stuff is "actually" catch making a non-determanistic choice of which exception to c
00:01:21 <shapr> juhp: you could ask SyntaxNinja for access to haskell-experimental for a gtk2hs deb
00:01:23 <juhp> shapr: is something like apt-get...
00:01:37 <skew> no class constraint. just forall a . String -> a
00:01:40 <juhp> shapr: these are rpms :-)
00:01:45 <shapr> ok
00:01:49 <jdrake> skew, what is that 'c' at the end of your statement
00:02:05 <skew> should be "catch"
00:02:12 <juhp> Fedora Core ships with yum, and apt-get is available in contrib...
00:02:20 <shapr> neat
00:02:33 <jdrake> how is skyos doing
00:02:40 <juhp> well, we're starting to wake up ;-)
00:09:57 <shapr> is there some sort of standard trick to apply a tuple of functions each to the same value and return a tuple of results?
00:10:43 <skew> that's pretty common, but I don't think there's a library function for it
00:10:46 <skew> or did you mean for tuples of arbitrary length?
00:12:21 <shapr> I guess I was hoping for tupleapply6 or something
00:12:39 <shapr> there's probably a better name for that
00:14:22 <skew> 6?
00:14:37 <skew> that sounds like a lot
00:14:42 <shapr> well, there's zip3 zip4 that sort of stuff
00:14:54 <skew> I think I've seen this called pair
00:15:17 <skew> well, (a -> b) -> (a -> c) -> (a -> (b,c)) called pair
00:15:34 <skew> it comes right out of the category theory
00:15:47 <shapr> right
00:15:54 <shapr> so is there also sextuple? :-)
00:16:31 <skew> not unless you write it. Maybe there should be Control.Combinators for this sort of thing
00:17:12 <shapr> I wonder what else would fit into Control.Combinators
00:17:22 <skew> or some clever way of distributing arrow types over data types
00:17:46 <skew> all the little helper function you write for points-free code
00:18:09 <skew> I can't think of many right now
00:18:30 <shapr> I know arrows use the pairapply thing, I think it's called && in the original paper
00:18:45 <skew> you were saying you could write way better code in Haskell than in Python - what sort of interface to Python modules would you like?
00:19:04 <shapr> hm
00:20:39 <skew> importing single functions by name in the style of the XMLRPC library would be pretty easy
00:22:21 <shapr> I don't know, I'll think about it.
00:22:37 <shapr> hej dennisb 
00:32:10 * shapr boings
00:32:18 <shapr> Si\: google servers still down :-/
00:33:39 <Si\> have you tried it with no password to see if it works?
00:48:07 <ibid> hmm, is there a standard function Eq a => [a] -> a that picks the first element of the list that occurs twice in a row?
00:48:26 <ibid> hmm, no need, actually
00:49:37 <Jerub> ibid: ;)
00:50:24 <ibid> though i'm still curious :)
00:53:55 <Jerub> find_double [] = []
00:53:55 <Jerub> find_double (x:y:xs) | x == y = [x]
00:53:55 <Jerub> find_double (x:xs) = find_double xs
00:54:01 <Jerub> thats what I'd do.
00:54:06 <Jerub> but its Eq a => [a] -> [a]
00:54:30 <Jerub> unless you want a Maybe or something, or there's ALWAYS a double.
00:55:31 <Jerub> in fact..
00:55:57 <Jerub> find_double (x:y:xs) | x == y = x:find_double xs
00:56:01 <Jerub> is probably better.
00:56:31 <ibid> Jerub: i asked for a standard function, i am capable of writing one myself, thank you :)
01:00:20 <Cale> (head . head . filter (\x -> length x > 1) . group) -- :)
01:03:48 <bring> or with a list comprehension:
01:03:49 <bring> (\xs -> head [x | [x,y] <- group xs, x == y ])
01:04:23 <bring> (I know you are capable of writing you own, just seemed like a fun little function to write)
01:04:32 <Jerub> ibid: my implementation was more a demonstration of a possibly erroneous spec rather than anything else ;)
01:05:28 <ibid> ok
01:05:42 <Jerub> bring: funky, does it work?
01:05:52 <bring> think so
01:06:38 <Jerub> hmm, I don't have 'group'
01:06:56 <Si\> List.group
01:07:11 <Jerub> ahh, gotcha
01:07:22 <ibid> f l = fst $ head $ dropWhile (/=) $ zip l (head l)
01:07:25 <ibid> perhaps?
01:08:00 <ibid> oh yes, you may assume that the input is infinite :)
01:08:15 <ibid> parameter, whatever
01:08:17 <Jerub> bring: your implementation doesn't work for [1,1,1]
01:08:27 <bring> true
01:08:33 <ibid> f l = fst $ head $ dropWhile (/=) $ zip l (tail l)
01:08:35 <ibid> actually
01:08:40 <bring> good point
01:08:54 <Jerub> ibid: yeah, definately a better solution
01:09:17 <bring> (\xs -> head [x | (x:y:_) <- group xs])
01:09:27 <bring> y == y is actually redundant
01:09:34 <bring> eh, I mean x == y
01:09:53 <bring> (\xs -> head [x | (x:_:_) <- group xs])
01:09:54 <bring> even
01:11:15 <Jerub> ibid: I like the final 'bring' solution
01:11:27 <Jerub> it passes the
01:11:30 <Jerub> ones = 1:ones
01:11:34 <ibid> f l = fst $ head $ dropWhile (uncurry (/=)) $ zip l (tail l)
01:11:35 <Jerub> (\xs -> head [x | (x:_:_) <- group xs]) ones
01:11:36 <Jerub> test :)
01:12:00 <ibid> yeah, it's nice
01:12:29 <ibid> i just feel list comprehensions as cheating (i have no rational reason to, it's just a feeling:)
01:12:35 <bring> you might want to use listToMaybe instead of head, to get Eq [a] => [a] -> Maybe a, as Jerub pointed out
01:12:51 <ibid> bring: no, this is supposed to be [a] -> a
01:12:56 <bring> ok
01:13:06 <ibid> bring: the argument will always be infinite
01:13:17 <bring> and random?
01:13:43 <ibid> bring: the original motivation was to use it (call it f) as f . iterate g
01:13:49 <ibid> not random necessarily
01:14:05 <ibid> if there is no duplication, then bottom is warranted in this case :)
01:14:57 <bring> true :)
01:15:52 <bring> hmm, yes, that is a nice way to do fixed point iteration
01:16:29 <bring> it's shorter than the one I've used before
01:17:07 <ibid> hmm, i did not realize i was doing fixpoint iteration here :)
01:17:25 <kosmikus> ibid: the world is small :)
01:17:28 <ibid> :)
01:17:45 <bring> fix f y = head [x | (x:_:_) <- group (iterate f y)]
01:17:48 <bring> that's neat
01:18:33 <bring> never would have though of that, I think I used some recursive thing with an if last time
01:19:33 <ibid> of course the question is, does the compiler/runtime realize that only two adjacent elements of the intermediate list need to be live at a given moment
01:20:11 <bring> I think so, but I'm just guessing
01:20:51 <ibid> i think it is clear that the comprehended list is never generated beyond the first element
01:20:51 <bring> or, maybe not, depends on what group looks like, I guess
01:21:38 <bring> I think it has generate two elements, since group uses ==
01:22:16 <shapr> I was impressed that GHC turned my email parse/filter/insert into database into a lazy list without me needing to specify anything
01:22:43 <ibid> bring: two elements of the iterate result, yes, but surely not two elements of the result of the comprehension
01:22:49 <bring> oh, right
01:23:12 <bring> I was thinking of the iterate result
01:24:41 <bring> yeah, the comprehension is implemented as map with a pattern guard as far as I understand, with should be lazy enough
01:24:59 <ibid> i'm concerned that the initial segment of the iterate result might be held on to
01:25:16 <bring> shapr: did you use readFile or something like that for the iput?
01:26:48 <ibid> lunch time :)
01:26:53 <shapr> yah, readFile
01:27:24 <shapr> is readFile lazy or strict?
01:29:39 <Si\> um
01:30:08 <kosmikus> lazy, I think ...
01:31:48 <Si\> I agree
01:32:19 <Si\> I just tried reading in a massive file and it did it instantly, but when I tried to look at the contents it grabbed all my cpu...
01:32:35 <bring> :)
01:33:09 <bring> readFile is a little weird, try reading in a file, chaning someting in the beginnng and write it back out
01:33:14 <bring> using readFile
01:33:26 <bring> don't do it on anything important 
01:34:53 <bring> write it back out to the same file that is
01:40:12 <Si\> GHC is the only program that has ever grabbed all my CPU, memory and swap...
01:40:24 <Lunar^> Hello :)
01:40:27 <Si\> that's over 1.5 GB of storage
01:40:30 <shapr> bonjour Lunar^ 
01:41:06 <Lunar^> Si\: sometimes it goes on infinite loop...
01:41:37 <Si\> this wasn't infinite, it would have been a finite calculation, but may have take several thousand years never-the-less
01:41:57 <Si\> fortunately I have a handy Ctrl and handy C button available
01:42:31 <Lunar^> Type class resolution seems also very costly, best example WxHaskell
01:42:40 <Lunar^> It took ages to build on my G3 laptop
01:43:08 <Si\> yes it took me quite a while to build
01:45:33 <juhp> http://haskell.org/~petersen/rpms/gtk2hs/?C=M&O=D btw
01:49:30 <bring> Lunar^: you mentioned wanting a gregorian calendar implementation the other day, what exactly are you looking for?
01:49:45 <bring> (I've written parts of one)
02:02:04 <Lunar^> bring: Did you look at how is working GHC System.Time ?
02:02:13 <bring> yeah
02:02:54 <Lunar^> bring: I need to replace any external C call
02:03:06 <Lunar^> bring: The main one is currently mktime, which is used to make all adjustements
02:03:14 <bring> ah, for h0p?
02:03:27 <Lunar^> bring: yes :)
02:03:44 <Lunar^> Anyway, having something that could do Date -> Seconds since EPOCH would be fine
02:03:49 <Lunar^> (as a first part)
02:04:04 <bring> do you care about leap seconds?
02:05:51 <Lunar^> We're making an Operatig System... :)
02:06:25 <bring> I'm not sure if all OS's care about leap seconds
02:06:44 <Lunar^> I don't mind if it is slow or be full of naive algorithm, but I would like it to be correct
02:07:26 <bring> the problem with leap seconds is that there is not algorithm, they are announced by an observatory somewhere ad couple of weeks in advance, as far as I understand
02:07:50 <Lunar^> ?!
02:07:53 <bring> damn, my typing is sloppy, please excuse me, I will try to do better
02:08:18 <shapr> as soon as my mailing list search app is done, I'll find that TAO time system I keep talking about :-)
02:08:19 <Lunar^> My english is sloppy, please excuse me, I will try to do better :)
02:08:27 <Lunar^> hehe
02:08:48 <bring> there is a simple algorithm for leap years, but leap seconds are announced once in a while
02:09:20 <Lunar^> bring: Leap year algorithm is not what I call simple
02:09:31 <juhp> ntp is our friend
02:10:11 <bring> isLeapYear year = (year `mod` 4 == 0 && (year `mod` 100 /= 0 || year `mod` 400 == 0))
02:10:40 <earthy> and there's the timezone zoneinfo db
02:10:47 <bring> juhp: true, but then you still have to keep track of leap seconds to do Date -> seconds since epoch
02:10:57 <earthy> bring: yes. but for the fact that this breaks before 1500. ;)
02:11:32 <bring> earthy: true, I only considered the gregorian calendar
02:11:33 <Lunar^> bring: That's a lot more complicated
02:11:58 <Lunar^> bring: GNU Classpath GregorianCalendar seems quite exact
02:12:24 <bring> Lunar^: I'll have a look at that, thanks
02:12:38 <Lunar^> bring: 1 sec
02:12:53 <Lunar^> http://cvs.sourceforge.net/viewcvs.py/jnode/jnode/core/src/classpath/java/java/util/GregorianCalendar.java?rev=1.1&view=auto
02:13:44 <earthy> lunar^: look into http://www.twinsun.com/tz/tz-link.htm as well
02:14:42 <Lunar^> Great thanks
02:17:03 * earthy looks at bring... now I know what ISO 8601 standardizes. :)
02:17:26 <bring> :)
02:18:13 <bring> I still haven't gotten my 0 page PDF
02:28:23 <bring> reimplementing an algorithm from a GPL program in a different language and releasing it under a BSD license should be ok, right?
02:28:48 <bring> since the algorithm itself isn't copyrighted
02:29:12 <bring> esp. is the languages are as different as java and haskell
02:29:19 <bring> s/is/if/
02:30:00 <ibid> bring: basically, yes
02:30:34 <ibid> bring: however, if you refer heavily to the original program while writing the new one, yours might become a derived work
02:30:46 <ibid> bring: and the line is not clear at all here
02:31:12 <bring> true, it'd probably depend on how similar they are
02:32:35 <bring> anyway, no time for that right now
03:05:14 <shapr> any WASH users handy?
03:05:28 <shapr> I'm trying to figure what tr_S vs tr_T does
03:06:04 <shapr> I wish WASH had haddocks
03:18:21 <shapr> WASH is mind altering
03:52:47 * Si\ is hoping for a HWS-WP plugin for WASH one day...
03:56:45 <Si\> If you have a dynamically loaded function, can it be accessed across multiple threads without using an MVar?
04:03:20 <Jerub> Si\: 7.
04:05:42 * Jerub goes to bed.
04:15:03 <_joey_> how do I implement 2-dim array with string values in Haskell?
04:15:28 <_joey_> [[Char]] isn't allowed without extension on ghci 5.04
04:20:10 <kosmikus> _joey_: what do you mean: not allowed? [[Char]] is a valid type ...
04:21:18 <_joey_> Illegal signature in pattern: [[Char]]
04:21:26 <_joey_> Use -fglasgow-exts to permit it
04:21:43 <kosmikus> where do you use it?
04:21:58 <_joey_> use what?
04:22:04 <kosmikus> can you paste the line in your input where [[Char]] occurs?
04:22:28 <_joey_> dude I am not sure what you asking?
04:22:34 <_joey_> to want a snippet of code?
04:22:43 <kosmikus> yes
04:22:46 <_joey_> wait
04:25:12 <_joey_> never mind
04:25:29 <_joey_> I think I found the error
04:26:20 <kosmikus> I've checked myself. You get this if you give a type signature to a *pattern*. That's only allowed as a Haskell extension. Give the type signature for the complete function instead.
04:27:03 <kosmikus> so, instead of "f (x :: Int) = x + 2", write "f :: Int -> Int" and the "f x = x + 2"
04:28:33 <_joey_> I got the sytanx wrong for the signatures
04:38:31 * Si\ wonders what Jerub meant by 7...
04:54:07 <_joey_> kosmikus: 
04:54:47 <_joey_> could you paste a line of code to implement an array of arrays whose values are strings using lists and Char ?
04:57:11 <_joey_> gotcha
06:58:31 <_joey_> I want to write a function that takes to integers continiulsy apllies moudulo , mod a b, and a /= b untill a == 0 and the result in lists of lists
07:02:28 <_joey_> done it
07:09:25 <Segora> re
07:20:05 <shapr> @yow ! canteloupes!
07:20:06 <lambdabot> Put FIVE DOZEN red GIRDLES in each CIRCULAR OPENING!!
07:23:10 <shapr> De4thClaW: did you get your nickname from fallout?
07:23:34 <kowey> hi all
07:24:28 <shapr> bonjour kowey 
07:24:48 <Cale> hello
07:24:51 * shapr sings 'snowflakes keep falling on my head'
07:25:13 * Cale wonders what to do with his Haskell binding for Imlib2
07:25:20 <shapr> post 'em !
07:25:28 <shapr> put 'em in haskell-libs!
07:26:07 <Cale> Hmm, yeah I should probably upload it to somewhere public.
07:26:15 <shapr> I'll host it if you want
07:26:50 <Cale> That would be good. I should also probably document it a little better, and perhaps polish a few things up.
07:27:00 <Cale> It works though.
07:27:18 <shapr> neat
07:28:18 <earthy> More Bindings! More Bindings Good!
07:28:21 <Cale> I think I might go and do all the E foundation libraries at some point.
07:29:02 <Cale> It's incredibly repetitive doing bindings, but also sort of fun.
07:29:21 <shapr> have you seen Wolfgang Thaller's Template Haskell bindings?
07:29:28 <shapr> er, TH + objective C I think
07:29:48 * earthy nods
07:29:49 <Cale> I don't think so
07:29:51 <shapr> anyways, from what I understand, he used Template Haskell to generate all the bindings from the headers, or something to that effect
07:29:55 <earthy> very neat
07:30:13 <earthy> much of it Andre Pang's work as well (ozone here on #haskell, ISTR)
07:30:24 <shapr> on the downside, I've heard that it takes even more hours to build than GHC ;-)
07:31:04 <earthy> ghc connects to the objectiveC frameworks, enumerates all the objects in the framework and from that generates the bindings
07:31:15 <Cale> One thing that I couldn't figure out how to do is dealing with C functions which have "..." parameter lists.
07:31:17 <Marvin--> I don't really believe in generating bindings automatically
07:32:01 <Marvin--> look at what a mess swig is
07:32:12 <earthy> look at what messy languages it targets. ;)
07:32:59 <Marvin--> sure, but it's approximately the same objective, you want high-level bindings to a low-level library
07:33:20 <earthy> yeah... this is in general impossible to fully automate
07:33:55 <earthy> however, to generate the low level bindings to a low level library, i.e. not much more than the marshalling, you want that to happen automatically
07:37:04 <Cale> I haven't done too much more than marshalling, but things are fairly usable. I can't think of what I'd want a higher level interface to look like.
07:38:01 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage has an image converter that I wrote using the binding.
07:38:32 <shapr> wow, smooth
07:38:42 <kowey> Cale: this might be useful for people who use wxhaskell and graphviz
07:39:35 <kowey> that is, drawings made by graphviz are ugly if not in postscript, but displaying ps in wxwidgets is not easy
07:39:42 <Cale> Or anyone who wants to write PNGs from Haskell :) I haven't been able to find another library capable of that.
07:40:02 <Marvin--> "Combining Testing and Proving in Dependent Type Theory"
07:40:05 * Marvin-- found a neat paper
07:40:16 <Cale> I'm not sure if Imlib has a postscript loader or not.
07:40:52 <kowey> is imlib the lib behind imagemagick?
07:41:04 <kowey> 'cuz if i do convert foo.ps foo.png, that works
07:41:23 <earthy> how hard is it to get from the images to say, something that can be used with pancito?
07:41:29 <Cale> No, it's the library that Rasterman wrote for Enlightenment. (Imlib2 is the new one that's being used for E17)
07:41:39 <shapr> yah, would be really handy for pancito
07:41:40 <kowey> oh... nevermind me, then :-)
07:42:41 <Igloo> You can use wxhaskell to write PNGs, although it might be a bit overkill  :-)
07:42:58 <kowey> well, it's reading the ps which is the hard part
07:43:03 <Cale> hehe
07:46:12 <Marvin--> wow, I think I'm going to need some coffee to get through this paper
07:46:31 <kowey> wait, does that mean it's really good, or really bad?
07:48:20 <Marvin--> how about "way over my head"?
07:48:45 <kowey> i.e... too early to tell
07:48:58 <kowey> anyway, back to work... bye!
07:49:02 <Marvin--> seeing as I'm not really familiar with dependent type theory or Agda...
07:49:10 <earthy> doesn't seem too bad from where I'm sitting
07:49:19 <earthy> somewhat short on the meat of the matter, but not too bad
07:49:56 <earthy> anyway, time to go home
07:52:59 <Lunar^> shapr: neat 
07:53:12 <Lunar^> shapr: (Wolfgang TH + Obj-C binding)
07:55:40 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage -- heh, the module export list
07:55:58 <Marvin--> LOL
07:56:01 <Cale> btw, what's that "output left in -" bit that's getting stuck in there
08:02:43 <Cale> seems that the syntax colouring gives up on it after a little while :)
08:02:48 <_joey_> what's wrong with this code ? pStack :: [Integer]->Integer->[Integer] pStack (x:xs) a | length (x:xs) == 0 = [] | otherwise = anotherFunc x a  ++ pStack xs
08:03:03 <_joey_> it gives error , parse error on pStack
08:03:40 <Cale> well, hopefully you're not putting it all on one line like that :)
08:04:15 <_joey_> did you want me to type it on a separate lines in this buffer?
08:04:30 <Cale> no, I know where it should get broken up
08:04:38 <_joey_> Fuck me dead, if I am going to get through Haskell course
08:05:12 <_joey_> you can assume lines are broken up in the file
08:05:15 <Marvin--> _joey_: uh, note that length (x:xs)  can never be 0
08:06:18 <_joey_> how do I test for the condition when it's empty in the bieggining without using pattern matching
08:06:18 <Cale> also, pStack xs is of type "Integer -> [Integer]" and that's getting concatenated with "anotherFunc x a"
08:06:43 <_joey_> which return [Integer]
08:06:54 <_joey_> it would have givne type error at compile time
08:07:15 <Cale> you probably meant pStack xs a
08:07:27 <Cale> I only get type errors in this code
08:07:39 <Marvin--> _joey_: uhh, why would you *want* to test for emptiness without pattern matching?
08:07:46 <_joey_> in the course we can't actually use feature of the language that has been covered in the lectures, so pattern matching isn't allowed yet
08:07:54 <_joey_> features*
08:08:03 <_joey_> silly, really
08:08:04 <Marvin--> uh-huh, but you already use pattern matching
08:08:06 <Marvin--> (x:xs) is a pattern
08:08:34 <_joey_> oh well, now I have to worry bout this too
08:08:38 <Marvin--> I think your best bet in this case is to rewrite it to  pStack xs a | null xs = []
08:08:45 <Marvin--> | otherwise = ...
08:08:54 <Marvin--> and use head xs and tail xs instead
08:09:37 <Marvin--> (feel free to use  length xs == 0  instead of  null xs)
08:10:53 * Lunar^ is rotfl at Marlow's last mail on haskell-cafe
08:11:08 * Marvin-- ponders why he never got around to subscribing to haskell-cafe
08:11:19 <_joey_> I am spending so much time on implementing simple things in Haskell
08:11:33 <_joey_> I may get some sleep and start tomorrow again
08:15:20 <Marvin--> yay, poke and peek
08:15:59 <kosmikus> Lunar^: thanks for the hint :)
08:17:03 <Lunar^> Maybe we could write a C -> Haskell tansformer ;)
08:20:24 <_joey_> that's how I decided to use the stopping case for recursion
08:20:38 <_joey_> Marvin--: 
08:20:41 <_joey_> oops
08:21:00 <_joey_> I am reading your posts from 20 minutes ago:)
08:21:21 <_joey_> [03:21] am
08:22:55 <Marvin--> whoa, you're reading my posts from 20 minutes ago? TIME TRAVEL!
08:25:11 * Marvin-- laughs at every_language_war_ever
08:25:17 <Lunar^> hehe
09:40:15 * Marvin-- swears and adds {-# OPTIONS -fglasgow-exts #-} to one module after anotr
09:41:47 * Igloo swipes at Marvin with the Axe of Instability
09:42:58 <Marvin--> yikes
09:43:13 <Marvin--> that's what I get for using MonadReader
09:43:43 <Marvin--> guess I should use implicit parameters instead
09:43:58 <Marvin--> not that that's more portable :)
09:47:44 <Igloo> ghc 6.2.1 in HE - bug reports welcomed!
09:47:59 <Igloo> (unstable, that is)
09:52:03 * Marvin-- sighs
09:52:44 <shapr> look look! it's flaming death!
09:52:56 * shapr rebounds
09:53:50 <shapr> Cale: you win the prize for largest export list I've ever seen
09:54:19 * Marvin-- gives himself prize for long program flags
09:54:28 <Marvin--> --gandalf-disable-demodulation
09:54:51 <shapr> whoa, that's cool
09:55:05 <shapr> --with-wizard=gandalf
09:55:25 <Marvin--> no, --backend=gandalf
09:55:45 <Marvin--> (it's a theorem prover)
09:55:52 <shapr> --frontend=arwen
09:56:00 <Marvin--> --gandalf-disable-demodulate  Disable demodulation (might give more informative proofs)
09:56:03 <Marvin--> shapr: dude, that's sick
09:56:11 <shapr> um
09:56:15 <shapr> I'm not even going to ask
09:56:19 <Marvin--> ;)
09:56:23 * shapr grins
09:56:38 * Marvin-- tries to collect whatever's left of his mind in the gutter and move on
09:56:44 <shapr> hey, I have a 1 meter poster of Arwen on my wall
09:57:08 <Marvin--> I don't
09:57:18 <shapr> and the poster says "Taru Sormusten Herrasta - sormuksen ritarit"
09:57:28 <Marvin--> and besides, the only available frontend the program has is helium
09:58:53 <earthy> hm. sindarin with a helium-induced highpitched voice...
09:59:01 <shapr> heh
09:59:08 <Marvin--> let. it. go.
09:59:09 <shapr> that's a funny mental picture
09:59:13 * shapr snickers
09:59:33 <earthy> yeah, almost as funny as the SimonM's post on haskell-cafe. :)
09:59:39 <shapr> which one?
09:59:41 * shapr looks
09:59:47 <Marvin--> SimonM has too much time on his hands
10:00:00 <Marvin--> that's the only conclusion I can come to
10:00:26 <Lunar^> shapr: really funy
10:00:27 <Lunar^> -n
10:00:29 <earthy> actually, no. that translation was very true to the C original ;)
10:00:40 <earthy> and probably typed up in half a minute
10:00:48 <earthy> maybe a bit more
10:01:10 <shapr> I like David's memoization optimisation
10:01:20 <Marvin--> Lunar^: "fuy"?
10:01:50 <shapr> oh, that's hysterical
10:02:11 <shapr> that truly deserves a place on the QuotesPage
10:02:16 <earthy> yes, it does. ;)
10:02:30 <earthy> one of the first cases that code actually made me laugh out loud
10:03:20 <Marvin--> yikes, time flies
10:03:23 <Marvin--> I'm supposed to be at the pub
10:03:39 <Lunar^> Marvin--: hehe
10:03:42 <Marvin--> time to celebrate that gnome 2.6 got delayed a week :-/
10:03:48 <shapr> I'm just starting work again today
10:04:01 <Lunar^> shapr: How long ?
10:04:08 <Marvin--> I'll be back later, moderately tipsy
10:04:19 <SyntaxNinja> Marvin--: yr not tipsy yet?
10:04:55 <shapr> I think I'll be working for several years still ;-)
10:04:57 <Marvin--> haven't been to the pub yet
10:05:01 <shapr> I hope I don't retiren anytime soon.
10:05:19 <Lunar^> lol
10:05:43 * shapr is starting to make swedish substantive typos
10:06:32 <SyntaxNinja> shapr: congrats
10:06:56 <shapr> yah, I'm finally learning how to speak swedish :-)
10:07:01 <shapr> just add typos!
10:09:09 <shapr> SyntaxNinja: yay, HUnit!
10:09:34 <shapr> hey, I wrote an assertM function that may have more than one user, since it's for unit testing monadic code
10:12:23 <shapr> I wrote some XmlRpc unit tests with it
10:14:03 <shapr> hey det, wassup?
10:15:08 <SyntaxNinja> shapr: heh
10:15:35 <SyntaxNinja> I think MW was suggesting that someone else should maintain it, and I think simonM was pretending not to understand. hehe
10:15:40 <shapr> hah
10:15:44 <shapr> I didn't see that :-)
10:15:51 <det> shapr: not freenode's IPv6, apparently!
10:16:00 <shapr> I'll maintain it, it's not like it's difficult to deal with
10:16:07 <shapr> det: I'm using it
10:16:12 <shapr> well, the eu ipv6
10:16:22 <SyntaxNinja> I like the kinda "Good idea! thanks for offering to implement it!" replies that stufff on Haskell mailing lists often encourage.
10:16:29 <shapr> yes, I agree
10:16:36 <det> shapr: gerrold and calvins stopped resolving for me and calkins is being flaky
10:17:26 <shapr> in my opinion, there is no usefulness in making a critical comment unless you also have a better suggestion, or are willing to implement the fix yourself
10:17:49 <shapr> so, if you just say "that is bad" what's the point?
10:18:12 <Smerdyakov> shapr, I think I know some people who disagree with that, including almost all engineers. ;)
10:18:37 <Smerdyakov> shapr, it's like the reverse of brainstorming: if you are too critical of criticism, you may not realize the really big problems.
10:18:55 <det> shapr: well, sometimes what you want to do has no better solution because what you are doing is WRONG ;)
10:19:06 <Igloo> Argle
10:19:20 <shapr> det: in those cases, someone can suggest a different thing to do that could come up with the same result
10:19:45 <Smerdyakov> shapr, except that thinking takes time, and there's no reason to let someone waste HIS time while you try to think of something better.
10:19:57 <Igloo> If I combine the most general result of one thing and the least general of another, what do I end up with? I'm looking for a better word than "better"  :-)
10:20:12 <Smerdyakov> Igloo, that's too vague for me.
10:20:25 <shapr> imo, it's easy to find flaws in stuff, everything has a bunch of obvious flaws
10:20:46 <Smerdyakov> shapr, many easy things are worthwhile.
10:20:58 <shapr> linux and emacs suck in a myriad of ways, and yet, they are the best working environment I've found
10:21:05 <Si\> this is so annoying Google is *still* down
10:21:09 <shapr> windows and visual studio sucks in a much larger number of ways
10:21:21 <shrimpx> Si\: google is up
10:21:28 <shapr> api.google.com is down
10:21:43 <shrimpx> not for me
10:21:52 <Si\> we don't mean the site
10:21:54 <shapr> you can login into api.google.com ?
10:21:59 <Si\> the actual backend is down
10:22:06 <shrimpx> ah. sorry
10:22:18 <Si\> well the Web Service is isn't, but the key generation is
10:22:48 <Igloo> Smer: If combining two pairs of types is giving a unification of the fsts and an anti-unification of the snds, what is the combination corresponding to teh most general unification and least general anti-unification?
10:23:11 <det> Igloo: is that a real question?
10:23:19 <Igloo> Ermmm, yes
10:23:28 <Igloo> I don't understand what else it could be  :-)
10:23:47 <det> it sounds like a conjuntion juntion song
10:23:58 <shapr> hi bb, looking for Haskell info?
10:24:08 <shapr> greetings rt, how's the graphics biz?
10:24:20 <det> o/~ the most gener-al un-i-fication and the least gener-al anti-un-i-fication o/~
10:24:28 <rt> it goes.
10:24:32 <rt> or rather, it doesn't go.
10:24:33 <bb> shapr: not right now, maybe l8er :)
10:24:37 <rt> This week is one long f*ck up.
10:24:46 <rt> But I still get a paycheck, so how bad can it be.
10:24:47 <rt> :-)
10:24:58 * Igloo ponders tighter/tightest
10:25:48 <shapr> rt: nice viewpoint
10:25:56 <shapr> bb: ok, if you think of questions, feel free to ask
10:26:37 <rt> sigh, only three shots for review today.
10:26:39 <rt> Pitiful.
10:45:05 <shapr> hey skew, what's going on?
10:45:34 <skew> hacking on the Python thing some more
10:45:49 <Lunar^> "the Python thing ?"
10:45:52 <skew> I think I'll pretend that loading a module is pure ...
10:46:20 <skew> I'm just starting a binding. I've got a pure ffi interface to some funtions
10:46:32 <skew> I've got a little example program running, transcribed from C
10:46:47 <skew> now I'm trying to think of a nice interface
10:47:01 <Lunar^> skew: foreign import python "Moodule.py function" :: IO () ?
10:47:17 <skew> hey, that would be nice
10:47:35 <skew> but I'll avoid messing around with GHC internals for now
10:47:37 <Lunar^> That means hacking the compiler
10:50:38 * rt has 13 minutes to kill.
10:50:46 <rt> I should work on my checkers program.
10:50:55 * rt codes madly for 12 minutes.
10:55:50 <skew> how expensive are foreign pointers?
10:59:31 * shapr wonders about import tax
11:02:27 <Lunar^> lol
11:05:04 <ludde> how expensive is foreign currency ?
11:05:16 <ludde> n/m
11:13:22 <shapr> hey stepcut, what's happenin?
11:13:37 <shapr> had time to check out Concurrent?
11:15:59 * Igloo tries to think if there was anything else I was going to do today
11:16:06 <shapr> sleep?
11:16:38 <Igloo> I've already done all the sleeping I'm likely to do today
11:16:56 <shapr> oh
11:16:57 <shapr> ok then
11:20:03 <stepcut> shapr: yeah, I read the paper ... I have some ideas, but still some unanswered questions
11:20:57 <shapr> like what?
11:21:37 * shapr grumbles
11:21:42 <stepcut> well, the paper talks about how to do an unbound stream ( or something like that )
11:22:15 <shapr> WASH needs to use hierarchical library names
11:22:40 <stepcut> shapr: yeah among other things (regarding WASH)
11:22:52 <shapr> you have cluefulness with WASH?
11:22:57 <stepcut> much
11:23:04 <shapr> oh great master, teach me :-)
11:23:09 <stepcut> :p
11:23:24 <shapr> seriously, I felt like taking a stick to my monitor earlier today
11:23:30 <stepcut> haha
11:23:44 <shapr> I just don't just some of this
11:23:52 <stepcut> like what?
11:23:53 <shapr> what's up with tr_S, tr_T and tr?
11:24:00 <stepcut> ah
11:24:06 <stepcut> there used to only be tr
11:24:12 <shapr> right, I remember that
11:24:23 <shapr> and I tracked through the sources to see that _T means top-level
11:24:26 <shapr> and _S means static
11:24:34 <shapr> but that doesn't help me any
11:24:41 <stepcut> but if you read this paper: http://www.informatik.uni-freiburg.de/~thiemann/papers/simple-caching.ps.gz
11:24:49 <shapr> oh, it's for that
11:25:01 <shapr> I saw him present one of his caching papers
11:25:22 <shapr> neat idea, that's for sure
11:25:47 <Lunar^> stepcut: topic?
11:26:10 <shapr> so, can I use any of {tr,tr_T,tr_S} for a <tr> ?
11:26:32 <stepcut> yeah, but unless you are using the caching stuff, only tr will be beneficial
11:26:38 <shapr> ok
11:27:06 <shapr> I'm just trying to make a nice input form for searching the haskell mailing lists
11:27:13 <Lunar^> shapr: Are you trying to use WASHHtml ?
11:27:15 <shapr> and a nice output page with batching
11:27:34 <shapr> I just looked in WASH-CGI/Examples/ and started trying stuff
11:27:48 <shapr> see my results:
11:27:50 <shapr> http://shapr.homelinux.net/cgi-bin/wash/Test
11:27:52 <stepcut> Lunar^: that paper is about a scheme that lets browsers cache the static portions of dynamically generated webpages
11:28:06 <Lunar^> stepcut: I think I've read it... not sure
11:28:15 <Lunar^> shapr: Why not use Halipeto ?
11:28:15 <shapr> that form just cuts the terms at spaces, and prints each term in its own tr
11:28:36 <shapr> because I'm already using WASHMail, so I figured I'd stick with WASH for the moment
11:28:51 <stepcut> shapr: I have a fairly good understanding of WASH is you have any other questions
11:29:05 <shapr> thanks, I'm sure you'll hear from me.
11:29:07 <Lunar^> shapr: I really dropped WASH-CGI quite fast.... it's really a mess
11:29:30 <shapr> well, I like the typefulness
11:29:34 <Igloo> I'd be interested in an explanation of WASH vs Halipeto?
11:29:54 <shapr> Halipeto is essentially Zope Page Templates for Haskell
11:30:01 <shapr> and ZPT is essentially what JSP should have been.
11:30:36 <shapr> ZPT uses tag attributes for all the programmable stuff, so any html/xml/sgml editor can deal with the source
11:31:10 <shapr> also, ZPT is designed for presentation only, not for doing in-page processing
11:32:04 <shapr> if you've ever hated maintaining inline logic in ASP,JSP or DTML pages, you'll like ZPT.
11:32:35 <eivuokko> Hmmm.  Sounds like you're selling it :)
11:32:46 <shapr> I do actually
11:32:57 <shapr> quite successfully :-)
11:33:00 <eivuokko> Heh :)
11:33:10 <shapr> I have more work than I have time.
11:33:17 <Igloo> Good sales spiel, but unfortunately not an answer to my question  :-)
11:33:34 <shapr> on the downside, I don't think Halipeto checks types at all
11:33:43 <Lunar^> shapr: Interesting point of view : work != time :)
11:33:46 <shapr> just like JSP and friends, it's all about string concatenation
11:34:04 <shapr> WASH is typed, much like HaXML
11:34:09 <Lunar^> ZPT does at least check that you have a valid XML document
11:34:17 <shapr> you can't put table tags in the head, for one example
11:34:20 <keverets> aw, here I was getting excited that I could use wxHaskell from ghci, and instead I get:
11:34:23 <keverets> Loading package wxcore ... ghc-6.2: can't load .so/.DLL for: wxc-0.6 (/usr/lib/libwxc-0.6.so: undefined symbol: _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette)
11:34:48 <Lunar^> keverets: Which OS ?
11:34:55 <Igloo> But when would I choose one over the other?
11:34:56 <keverets> Lunar^: Debian
11:35:20 <Lunar^> keverets: You need to edit your package.conf to ad danother library
11:35:37 <shapr> Igloo: in my opinion, ZPT is great to let people who know HTML write 'code' that does useful stuff
11:35:38 <skew> Well, one really annoying thing about WASH/CGI is that you can't use links for navigation
11:35:42 <keverets> I can compile with ghc with the Makefile from the examples/ directory.
11:36:49 <shapr> Halipeto lets you easily build whole-page templates and fill in the blanks
11:36:59 <Lunar^> keverets: /usr/lib/libwx_gtk_gl-2.4.a <-- here is GLCanvas symbol
11:37:01 <keverets> the makefile seems to add "-optl-pthread -optl-lwx_gtk-2.4 -optl-lwx_gtk_gl-2.4 -optl-lGL -optl-lGLU", but I don't think those are relevant to ghci.
11:37:21 <shapr> you may need to turn the .a into a .o
11:37:23 <shapr> if that's possible
11:37:43 <shapr> WASH does lots of stuff
11:38:20 <Lunar^> keverets: What is in /usr/lib/ghc-6.2/package.conf about wx package ?
11:38:44 <keverets> Lunar^: a bunch of stuff.  What in particular would you like me to tell you?
11:39:04 <Igloo> keverets: If you get it working, please let me know the details
11:39:06 <Lunar^> keverets: paste me the whole Package privately please
11:40:53 <keverets> Igloo: will do.
11:41:41 <Lunar^> keverets: I was wrong, this is not package.conf related then
11:41:58 <keverets> Lunar^: thanks for trying, anyway.
11:42:25 <Lunar^> keverets: wxc-0.6.so is not built correctly
11:43:03 <keverets> ok...
11:43:11 <keverets> is there anything I can do to remedy that?
11:43:35 <Lunar^> keverets: Did you build WxHaskell by hand ?
11:43:55 <keverets> Lunar^: no, used the package from syntaxpolice.
11:44:04 <Lunar^> keverets: ok
11:44:18 <Lunar^> I'm getting the source
11:44:19 <keverets> well, technically from Igloo, I guess.
11:44:56 <Lunar^> Igloo: Can I add deb-src as well ?
11:45:35 <Igloo> Should be able to
11:45:46 <Lunar^> Igloo: work :)
11:46:13 <Igloo> This may be related to the lintian error E: libwxhaskell0.6-ghc6: sharedobject-in-library-directory-not-actually-a-shlib usr/lib/libwxc-0.6.so
11:46:43 <Igloo> (pipe that through lintian-info for a bit of blurb)
11:51:23 <Lunar^> Igloo: found the culprit
11:52:02 <Lunar^> Igloo: ./configure writes in config/config.mk that WXWIN-LIBS=-pthread -lwx_gtk-2.4 which is not enough
11:52:20 <Lunar^> Igloo: The line before has maybe the same problem
11:54:33 <kosmikus|away> Lunar^, Igloo: is this the gl problem with wxhaskell?
11:54:44 <kosmikus|away> that's known, I think
11:55:03 <shapr> I think I've found the haskell-packagers list, aka #haskell
11:56:04 <Igloo> Yeah, but it would be nice to have a list where I could say thing like the ghc 6.2.1 being in HE line without people missing it
11:56:11 <shapr> that's true
11:56:23 * shapr thinks
11:56:46 <kosmikus|away> the Gentoo ebuild fixes that via sed -e 's:wxwinlibs="`$.*$:wxwinlibs="`$wxconfig --libs` `$wxconfig --gl-libs`":' on wxhaskell's configure
11:56:47 <shapr> I could create a Plone instance, then we'd have an RSS feed of news :-)
11:57:11 <Igloo> Well, the right solution is to split it into 2 libs I think
11:57:34 * Igloo makes a note of that fix anyway
11:57:45 <Igloo> Thanks
11:57:56 <kosmikus|away> you're welcome
11:58:43 <kosmikus|away> yes, splitting might be a good idea, although this might lead to a large number of splits soon enough ...
11:59:10 <Igloo> Oh?
11:59:52 <Igloo> It's ertainly silly that the user has to install the GL libraries to run hello world
12:00:27 <kosmikus|away> he doesn't
12:00:44 <kosmikus|away> he just needs to build wxwidgets without opengl support ;)
12:01:19 <Igloo> Euch  :-)
12:02:04 * Igloo heads home
12:04:37 <kosmikus|away> does anyone know what Igloo referred to with "HE" then minutes ago?
12:04:45 <kosmikus|away> s/then/ten/
12:05:08 <keverets> Haskell Experimental?
12:05:15 <shapr> yup
12:05:30 <shapr> it's a repository of debian packages
12:05:37 <kosmikus|away> ah, sure, thanks
12:07:13 <kosmikus|away> shapr: actually, #haskell is fine as a packagers list ...
12:07:53 <shapr> doesn't hold announcements that well though
12:11:47 <kosmikus|away> true, but I agree with SyntaxPolice that a "list" for packaging questions would be unlikely to attract many users anyway
12:12:09 <shapr> so, where to announce stuff like test packages of ghc 6.2.1?
12:12:13 <shapr> libraries?
12:12:33 <kosmikus|away> why not haskell-cafe ?
12:12:39 <shapr> ok
12:13:00 <kosmikus|away> or is there some debian-specific list where it could go?
12:13:23 * kosmikus|away decides to appear officially
12:13:27 <shapr> not that I know of, plus as was said earlier, some packaging questions are package/distro independent
12:14:47 <kosmikus> yes, and I personally would not write a packaging question to any of the Haskell lists, in most cases
12:15:13 <kosmikus> but I think announcements and questions about packaging are really two different things
12:15:32 <kosmikus> the question is, are there more announcements than the existing lists can afford?
12:17:52 * shapr dunno
12:18:16 <shapr> would be cool to have an RSS feed of new packages in HE
12:19:29 <kosmikus> I only know vaguely what that is
12:19:47 <kosmikus> would that mean that such announcements show up automatically on http://haskell.org ?
12:19:52 <shapr> it could
12:28:17 <SyntaxNinja> kosmikus: it would be an infrastructure, rather than an implementation step. the infrastructure would be the ability to query a web page for latest updates, the implementation could be email or an, rss aggregater (like gnus in emacs, or straw, or evolution's summary page)
12:28:59 <SyntaxNinja> it wouldn't actually be very hard, and wouldn't have to be implemented in monk at all. you could do it with apt's libraries
12:29:13 <SyntaxNinja> apt alreay has a way to list new packages and what-have-you, so all you'd have to do is export that to XML.
12:29:38 <SyntaxNinja> so it would even be more generic; you could break it up by apt source and create a different feed for each source.
12:30:05 <SyntaxNinja> just run apt-get update with a cron job, create the new XML-rss based on the new packages, and yr done.
12:31:40 <kosmikus> sounds simple enough
12:32:30 <SyntaxNinja> rss is pretty cool.
12:33:12 <shapr> we could also aggregate gentoo, etc
12:33:40 <kosmikus> I'm not sure, but I don't see any need for that
12:34:18 <kosmikus> Gentoo is more centralized than Debian, is I see that correctly -- if I upload a new ebuild, then everyone will see it at the time of the next synchronisation
12:34:19 <SyntaxNinja> depends whether you want to cut it along the OS line or along the Haskell line :)
12:35:22 <kosmikus> there are no separate trees or package repositories such as HE in Gentoo
12:36:21 <SyntaxNinja> but you might want an rss feed of just the haskell packages so it can be put onto the haskell web site
12:36:40 <kosmikus> yes, that would be great
12:56:52 <shapr> g'day clausen 
12:57:15 <clausen> hi
12:58:17 <clausen> my paper was rejected because they thought it was irrelevant :/
12:58:23 <clausen> (they thought it was good though (!))
12:59:45 <skew> what was the paper?
12:59:53 <clausen> my pagerank cost-of-attack paper
13:00:02 <clausen> I think it is of central importance to the agents community
13:00:15 <clausen> because reputation between agents is a major problem
13:00:38 <skew> where did you send it?
13:01:35 <skew> it sounds pretty significant for anybody using a web of trust
13:02:52 <clausen> skew: AAMAS
13:02:59 <clausen> (autonomous agents and multi-agent systems)
13:03:10 <clausen> so, not everyone in agents is interested in trust/reputation
13:03:14 <clausen> but lots are
13:03:21 <clausen> (anyone interested in ecommerce, say)
13:03:55 <clausen> eg: last year, there were about 10 papers on trust/reputation, and about 20 on auction design
13:05:41 <skew> hmm, sounds like an analyis of attacks on reputations systems would fit right in
13:05:51 <clausen> that is what I would have thought
13:06:11 <skew> you did write the paper from that angle?
13:06:18 <clausen> maybe I just used the wrong terminology, or something
13:06:23 <clausen> I didn't use the word "agent"
13:06:38 <clausen> however, I did make a point of explaining how it could solve real-world problems
13:06:47 <clausen> (which should then make it obvious how it connects with agents)
13:07:13 <skew> well, never assume obvious connections are obvious if you want everyone to understand what you are saying
13:07:38 <clausen> fair point
13:07:40 <clausen> but, I had two options:
13:07:47 <clausen> (1) connect my research with agents
13:07:54 <clausen> (2) connect my research with problems that agents solve
13:08:01 <clausen> I thought approach (2) would make my paper more readible
13:08:04 <clausen> readable :)
13:08:08 <clausen> by a general audience
13:08:30 <skew> if by pagerank you mean the sort of stuff google does
13:08:39 <clausen> yes
13:08:48 <clausen> (but some agents people use pagerank in their systems too)
13:09:02 <clausen> (I didn't have space to list them though)
13:09:07 <clausen> (the page limit was savage!)
13:09:59 <skew> you could have noted the analysis generalizes to any system of entities with opinions of each other
13:11:05 <skew> assuming you didn't explictly mention anything about more dynamic agents
13:11:21 <skew> webpages being the trivial static case of an agent
13:11:52 <clausen> I didn't make that statement
13:12:06 <clausen> (not that precise link)
13:12:23 <clausen> but, I don't think that statement would have made a difference
13:12:24 <clausen> but you could be right
13:12:27 <skew> well, better luck next year and elsewhere
13:13:43 <clausen> thanks
13:15:56 <clausen> (I did mention that PageRank == EigenTrust, and many agents people know about EigenTrust)
13:16:42 <skew> was the analysis completely abstract?
13:18:04 <clausen> I used the webpage intuition
13:18:09 <clausen> but it is maths
13:18:22 * clausen checks
13:20:11 <skew> Were they clear about why they thought it was irrelevant?
13:20:28 <skew> I'm sort of speculating from the assumption they didn't think the work related to agents
13:21:03 <clausen> the first one had no clue as to how it related to agents
13:21:08 <skew> If they saw how it fit, little tweaks probably wouldn't help with other journals or whatever
13:21:33 <clausen> the second one suggested that if the paper were rejected, I should try the trust workshop at the conference
13:21:59 <skew> marhsalling question - I'm trying to make an array terminated with an invalid marker element
13:22:16 <skew> should I add a constructor to the element and handle it in the storable instance,
13:22:27 <clausen> "Furthermore, this paper does not really deal with agents and multi-agent systems'
13:22:41 <clausen> the second reviewer gave the paper glowing praise, though
13:22:49 <clausen> (but gave it a low score for relevance)
13:22:53 <skew> or make a specially function to marshal up an array that writes the last by hand
13:22:58 <clausen> this reviewer seems to have seen the connection, but thought it was tenuous
13:23:19 <clausen> dunno
13:23:53 <skew> well, I'd try the trust workshop, and maybe make it a bit clearer that:
13:24:03 <skew> (1) the analysis is not specific to webpages
13:24:12 <skew> (2) the analysis is pretty intersting for agents
13:24:37 <skew> I suppose it would be difficult for an individual agent to do trust caluculations
13:25:02 <clausen> skew: if an agent has never interacted with another agent
13:25:18 <clausen> then it *has* to use reputation to evaluate if the agent is trustworthy
13:25:32 <clausen> it simply has no other option (except run away!)
13:25:54 <clausen> there is a keyword/category that says "reputation, [other stuff]"
13:26:04 <clausen> so, I thought the fact that the word "reputation" appeard in the call for papers,
13:26:08 <clausen> I wouldn't need to spell out all this stuff
13:27:13 <skew> I haven't written and submitted papers, but that's generally a dissapointing assumption
13:28:04 <skew> The only semi-legitamate objection I can see is that this reputation thing requires central servers somewhere, which is sort of at odds with the idea of independant, free-ranging agents
13:28:34 <skew> Maybe that will be google's next big thing
13:29:47 <clausen> well, it doesn't require central servers
13:29:58 <clausen> the EigenTrust paper (which I cited) shows how to remove this
13:30:18 <skew> without trusting too many other agents? interesting
13:31:18 <clausen> you still have to trust other agents
13:31:24 <clausen> (and it is a legitimate weakness)
13:31:29 <clausen> but I think it is the best option on the table so far
13:32:09 <clausen> many of the algorithms proposed in AAMAS have major security weaknesses
13:32:14 <clausen> it is an unsolved problem
13:44:34 <SyntaxNinja> does the haskell workshop usually have a separate call for papers than ICFP?
13:45:00 <SyntaxNinja> oh, I see it.
13:46:08 * rt sets ghc compiling.
13:46:15 <rt> Perhaps it will be done by the time I get home.
13:47:10 <Igloo> You either have a long trip or fast computer
13:49:17 <SyntaxNinja> hehe
13:49:24 <SyntaxNinja> (says igloo, without a note of pity)
13:49:52 <Jerub> tee hee
13:50:26 * Igloo fails to get what you mean
13:51:01 <rt> It's a 1ghz via, which I know from experience takes over an hour to build.
13:52:22 * SyntaxNinja dances around and pokes igloo
15:00:09 * Marvin-- pops back in
15:26:24 * shapr boings sleepil
15:26:25 <shapr> y
15:26:32 <shapr> usch
15:26:42 <shapr> jag är så somnig
15:29:29 * Marvin-- boings somewhat drunkedly
15:30:04 <shapr> man, I'm giving to the sleep monster
15:30:15 <Marvin--> I've been out celebrating the almost release of gnome 2.6
15:30:26 <Marvin--> guess we'll have to go out next week too, shucks :)
15:52:41 <Pseudonym> Well.  That was an adventure/.
15:54:51 <Pseudonym> Anyone here ever had a car stolen?
15:55:14 <mattam_> yup
15:55:28 <Pseudonym> Did you get it back?
15:55:35 <mattam_> my mother car was stolen 2 times
15:55:40 <mattam_> 1 time !
15:55:44 <Pseudonym> :-)
15:55:57 <Pseudonym> Well, this was my first.
15:56:07 <Pseudonym> Interestingly, it turned up three hours after I reported it.
15:56:26 <Pseudonym> They'd even put petrol in, which was nice of them.
15:56:36 <mattam_> he
15:57:03 <Pseudonym> The only problems were a) the battery was flat, and b) some of the fittings had been slashed.
15:57:24 <Pseudonym> Not very much, though.
15:57:30 <mattam> you're lucky
15:57:45 <Pseudonym> It's what I believe Americans refer to as a POS car.
15:57:52 <Pseudonym> So the damage isn't a huge deal.
15:58:01 <mattam> what's a POS car ?
15:58:23 <Pseudonym> @vera POS
15:58:25 <lambdabot> *** "pos" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002
15:58:25 <lambdabot> "
15:58:25 <lambdabot> POS
15:58:25 <lambdabot>      Piece Of Shit (telecommunication-slang, Usenet, IRC)
15:58:26 <lambdabot>      
15:58:28 <lambdabot>      
15:58:28 <Smerdyakov> The wise man can have no car stolen, for he owns none.
15:58:32 <lambdabot> *** "pos" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002
15:58:34 <lambdabot> [19 @more lines]
15:58:40 <Pseudonym> The others aren't relevant.
15:58:52 <Pseudonym> Indeed.  I only use this car to get to the railway station and back.
15:59:15 <Pseudonym> I could always take a bus, though it would take me a bit longer to do so.
15:59:18 * Smerdyakov grumbles at residential areas not planned properly with respect to public transportation.
15:59:32 <Pseudonym> The bus stop is very, very close to my place.
15:59:54 <Smerdyakov> Wouldn't you save a boatload of money by selling your car, then?
16:00:19 <Pseudonym> It's actually my Dad's car.
16:00:24 <Pseudonym> We're house-sitting for him.
16:00:35 <Pseudonym> He's still paying the registration and insurance, though.
16:00:38 <Pseudonym> So no.
16:01:00 <Smerdyakov> O
16:01:16 <Pseudonym> I would save a small amount because I still have to put petrol in it.
16:01:32 <Pseudonym> But I consider that a decent tradeoff for the time I save.
16:02:23 <Riastradh> You could also just bike.
16:02:31 <Pseudonym> No I couldn't.
16:02:37 <Pseudonym> Clearly you've never met me.
16:02:42 <Pseudonym> :-)
16:02:56 <Pseudonym> Also the area where I live is quite hilly, which makes it even worse.
16:03:31 <Riastradh> Is that clear from physical constraints?
16:03:56 <Pseudonym> I've never ridden a bike in my life.
16:04:06 <mattam> can i ask a Category Theory question ?
16:04:15 <Pseudonym> So it is partly true that I don't have hard evidence on which to base this.
16:04:18 <Pseudonym> mattam: Please!
16:04:21 <amgine2> is this correct indentation ?
16:04:21 <amgine2> = do curDicStr <- getCurrentDirectory 
16:04:22 <amgine2>                 temp <- (getDirectoryContents curDicStr) 
16:04:22 <amgine2>                 delCache temp                 
16:04:22 <amgine2>              where 
16:04:22 <amgine2>              --delete :: [FilePath] -> IO () 
16:04:23 <amgine2>            delCache []           = do logMessage "Done clearing jar cache files" 
16:04:25 <amgine2>            delCache f:files     = do logMessage ("Deleteing " + f) 
16:04:27 <amgine2>                                     delete files
16:04:31 <amgine2> i get parse error
16:04:56 <Pseudonym> amgine2: No, it isn't.
16:05:05 <amgine2> damn 
16:05:16 <amgine2> should the where be where do is ?
16:05:20 <Pseudonym> And it would help if you didn't flood.
16:05:28 <amgine2> sorry
16:05:31 <amgine2> ok
16:05:35 <Pseudonym> Not just bandwidth.  Also the tab stops get messed up.
16:05:44 <jdrake> haskell wouldn't happen to be suitable for searching a directory for files that are greater then 31 bytes, then renaming them, and then modifying all references to them inside html files to the new filenames would it?
16:05:46 <amgine2> i know
16:06:02 <mattam> in Gentle Intro to ... page 12, the author propose to write some properties about the Set category, but give no hints how to do so. The first one's "P(A) === A = {17}". How would you express that categorically ?
16:07:30 <Pseudonym> Hmmm.
16:07:41 <Pseudonym> OK.  {17} is a terminal object.
16:07:51 <Pseudonym> But you can also express it as a point.
16:07:59 <mattam> a terminal object ?
16:08:13 <Pseudonym> Did you not get as far as terminal objects?
16:08:40 <mattam> nope, i stopped approximately at this question.
16:08:44 <Riastradh> Pseudonym, eek!
16:08:44 <Pseudonym> Ah, OK.
16:08:45 <Riastradh> Never?!
16:08:55 <Pseudonym> Riastradh: Never.
16:09:07 <Riastradh> Fix that!
16:09:08 <Riastradh> Now!
16:09:08 <Pseudonym> mattam: OK.  Consider the Haskell type ().
16:09:17 <Riastradh> ...well, OK, continue explaining, and then fix it.
16:09:18 <mattam> yes
16:09:24 <Pseudonym> :-)
16:09:48 <Pseudonym> OK.  Now consider all functions of the form f :: a -> ()
16:10:08 <Pseudonym> Where a is any type.
16:10:15 * mattam follows
16:10:19 <Pseudonym> Let's assume that () is unlifted.
16:10:26 <Pseudonym> That is, these functions can't return bottom.
16:10:39 <Pseudonym> For any type a, how many functions are there which have this type?
16:11:08 <mattam> one doing nothing interesting
16:11:24 <Pseudonym> Right.  More to the point, there is _precisely_ one.
16:11:24 <mattam> ?
16:11:26 <Pseudonym> No more, no less.
16:11:35 <Pseudonym> No matter what type a is.
16:11:47 <Pseudonym> Right?
16:11:55 <Smerdyakov> Not in Haskell!
16:12:01 <mattam> no, i could write anything
16:12:05 * Pseudonym points above
16:12:12 <Smerdyakov> In Haskell, you could return (), loop forever, raise an error, ...
16:12:22 <Pseudonym> <Pseudonym> Let's assume that () is unlifted.
16:12:22 <Pseudonym> <Pseudonym> That is, these functions can't return bottom.
16:12:30 <mattam> ok
16:12:37 * Pseudonym waits patiently for an apology from Smerdyakov
16:12:41 <Jerub> I'm interested now.
16:12:44 <Smerdyakov> Looping forever is "returning bottom"?
16:12:46 <mattam> the fact is i could write 'f = let a = 2 in ()'
16:12:47 <Pseudonym> Yes.
16:12:53 <Pseudonym> Denotationally, it is.
16:13:00 <Smerdyakov> OK. Isn't there a difference in Haskell?
16:13:25 <Jerub> what about raise "Error"?
16:13:31 <Pseudonym> Error is bottom too.
16:14:20 <mattam> i think i've got your point anyway.
16:14:24 <Pseudonym> Denotationally, "bottom" means the function doesn't return for whatever reason.
16:14:34 <Pseudonym> Returning undefined counts.
16:14:41 <Pseudonym> Because it doesn't return.
16:14:49 <Pseudonym> Kinda.
16:14:50 <Pseudonym> Anywa.
16:14:55 <amgine2> can you have a where withing a where ?
16:15:04 <Pseudonym> Yes, amgine2.
16:15:11 <Pseudonym> OK.
16:15:24 <amgine2> what is the proper do where indentation
16:15:30 <amgine2> i've converted tabs to spaces
16:15:35 <amgine2> but still get a parse error
16:15:46 <Pseudonym> Now categorically, if there is an object T such that for all objects X, there is exactly one morphism X -> T, then T is terminal.
16:16:13 <Pseudonym> In sets, a singleton set is terminal.
16:16:17 <amgine2> nm
16:16:17 <amgine2> i got it
16:16:19 <amgine2> i'm dumb
16:16:30 <mattam> ok
16:17:04 <Pseudonym> Convince yourself of this for a moment.  What this is saying that for any set X, there is exactly one function X -> {17}.
16:17:34 <Pseudonym> Do you see why?
16:17:45 <mattam> not clearly.
16:18:03 <Pseudonym> It's like f :: a -> ()
16:18:13 <Pseudonym> Basically, f maps all arguments to the value ().
16:18:22 <Pseudonym> Similarly, all functions X -> {17} must map all arguments to 17.
16:18:39 <mattam> say i have an object X i make a morphism f : X -> {17} for each X ?
16:18:46 <Pseudonym> Right.
16:18:54 <Pseudonym> THis is in the Set category, of course.
16:18:58 <Pseudonym> So morphism == function.
16:19:15 <mattam> there are loads of functions then!
16:19:34 <Pseudonym> Yes, but for each set X, there is only one function : X -> {17}.
16:20:02 <mattam> yes, that's still a lot!
16:20:05 <Pseudonym> Sure.
16:20:33 <mattam> lets continue
16:20:59 <Pseudonym> But what you have here is the notion of a singleton set, but it only uses morphisms.
16:21:03 <Pseudonym> It doesn't look "inside" the set.
16:21:26 <mattam> yes
16:21:29 <Pseudonym> OK.
16:21:47 <Pseudonym> The next definition is: A "point" is a morphism whose domain is a terminal object.
16:22:15 <jdrake> is there any functions that can modify a string, such that it can [effectively] find and replace text
16:22:28 <Pseudonym> In Set, that means a funtion of the form : {a} -> X, where {a} is a singleton set.
16:22:47 <Smerdyakov> jdrake, it should be easy for you to write string transformation functions yourself. Are you primarily asking to see if someone has already written a function you want?
16:23:01 <mattam> its a partial function ?
16:23:08 <Pseudonym> BRB
16:24:17 <jdrake> Smerdyakov, yes (and that usually languages have this sort of thing built in)
16:24:38 <jdrake> it is a matter of determining whether or not I can/should use haskell for a problem I need to solve
16:26:05 <jdrake> which is this: I need to search a directory for files that are greater than 31 characters in length. Rename all of those files to something 31 or less. Then modify all references to those files in html (by links or by img tag) files in that same dir.
16:27:11 <Smerdyakov> Obviously you _can_ use Haskell for this....
16:27:30 <Smerdyakov> Furthermore, we don't generally consider library functions to be "built in."
16:27:56 <mattam> python seems right for the task
16:27:58 <Smerdyakov> Some languages truly have such ridiculous features, but most merely make writing equivalent functions easy.
16:28:12 <jdrake> well, you don't have to, but usually they are defined as that
16:28:14 <Cale> you might also have a look at xml2/html2
16:28:27 <Jerub> I'd either use python, perl, or do it manually with regexxer.
16:28:47 <Cale> I'd probably do it with a shell script and html2 and 2html
16:29:17 <Cale> (which flatten/unflatten html)
16:29:21 <jdrake> i don't know shell scripting
16:29:27 <jdrake> python I can probably pass at
16:29:34 <jdrake> perl would be a challenge
16:29:48 <jdrake> but I consider also that I am learning haskell, albeit at a slow pace
16:30:00 <Cale> yeah, it's certainly doable
16:30:53 <Cale> So you need an IO action that goes and gets the directory list, and filters it for the filenames over 31 characters.
16:31:36 <jdrake> i know how to find the length of a string and all, i haven't gotten into monads
16:31:39 <ayrnieu> well, you can do the filtering seperately.
16:31:41 <jdrake> only basically started filtering
16:31:54 <Cale> You'll need a (probably pure will do) function that takes a long name and returns a short one.
16:32:25 <Cale> if you want to handle collisions correctly, then it'll need to use IO
16:33:01 <jdrake> i was thinking something that turns a long filename into a hash will work
16:34:47 <Smerdyakov> Cale, why doesn't handling collisions correctly force use of IO?
16:34:51 <Smerdyakov> s/doesn't/does
16:35:22 <Cale> Well, at least indirectly. You could pass in a list of filenames not to collide with, or something.
16:35:39 <jdrake> i won't have to worry about filename collision
16:35:46 <jdrake> becuase the filenames I generate will be unique enough
16:44:45 <stepcut> i don't think 'unique' and 'enough' can be used together
16:46:56 <skew> Pseudonym: The events with your car remind me of Douglas Addams' "Long Dark Teatime of the Soul"
16:52:07 <Pseudonym> Sorry, back.
16:52:09 <Pseudonym> Boss key.
16:52:18 <mattam> he
16:53:14 <mattam> maybe my property is "P(A) = myf17 : A -> {17}, myf17 A = A" ?
16:56:27 <Pseudonym> OK, in Set, there aren't partial functions.
16:56:39 <Pseudonym> Though you can represent them by using lifted domains.
16:57:42 <mattam> i mean, the function is defined only for singleton objects 
16:57:48 <Pseudonym> Right.
16:57:58 <mattam> you 'look into objects' somehow
16:58:00 <Pseudonym> The thing is, f :: {a} -> X maps a single object onto... a single object.
16:58:08 <Pseudonym> So it's a way of representing a single element of a set.
16:58:29 <Pseudonym> Crap, another meeting.
16:58:32 <Pseudonym> BBL
16:58:48 <mattam> see you later :)
17:06:19 <amgine2> what command do i need to use to make ghc compile with wxHaskell
17:06:22 <amgine2> it works in ghci
17:06:22 <amgine2> .text+0x18):fake: undefined reference to `__stginit_GraphicsziUIziWX_'
17:06:26 <amgine2> is the error i get
17:06:35 <skew> amgine2: -package wx, I think
17:06:45 <amgine2> hmm i'll try that
17:08:51 <amgine2> what the hell
17:08:53 <amgine2> 8 mb file ?
17:08:55 <amgine2> jesus
17:09:22 <amgine2> does it only include what's needed ?
17:09:37 <skew> mattam: I also need to leave soon, but as {17} is an object in the category Set, I think P would be a predicate on objects that checks if that object is {17}
17:10:11 <mattam> that would be too easy don't you think ?
17:11:13 <skew> well, actually there's the question of how you tell that an element is "17"
17:11:23 <skew> I don't think you can represent that in plain old Set
17:11:25 <skew> well, bye
17:11:30 <mattam> like "P(A) == A = {17}" which is how the property is stated. I need to express it only using objects, morphisms etc... not directly
17:11:38 <mattam> bye
17:21:49 <amgine2> is there any way to optimize the size of haskell code ?
17:21:52 <amgine2> it's rather big
17:22:34 <amgine2> adding gui makes the code 700% bigger
17:22:45 <amgine2> is it because ghc links staticly for now ?
17:22:45 <Jerub> amgine2: a common issue I believe ;)
17:23:07 <amgine2> is it cause it's static linking ?
17:23:44 <Jerub> amgine2: I honestly don't know anything.
17:23:52 <amgine2> k
17:23:54 <amgine2> god damn it
17:23:58 <amgine2> i got a low memory warningl ol
17:25:16 <keverets> not staticly linking... run ldd on your binary.
17:25:30 <amgine2> i'm in windows box saddly
17:25:58 <keverets> in that case I have no idea.
17:26:05 <keverets> You may want to install cygwin
17:26:44 <amgine2> -static
17:26:44 <amgine2> Tell the linker to avoid shared Haskell libraries, if possible. This is the default.
17:26:47 <amgine2> you sure ? 
17:26:53 <amgine2> i'll just do a strip
17:26:56 <amgine2> and exe compress
17:27:00 <amgine2> should be sufficient
17:27:39 <amgine2> -dynamic 
17:27:39 <amgine2>  
17:27:39 <amgine2> Tell the linker to use shared Haskell libraries, if available (this option is only supported on Windows at the moment, and also note that your distribution of GHC may not have been supplied with shared libraries).
17:27:42 <amgine2> than it says this
17:32:21 <Pseudonym> Back.
17:32:53 <Pseudonym> The thing is, {17} is a terminal object.
17:33:15 <Pseudonym> So you can kind of represent P(A) === A = {17} as saying that A is a certain terminal object.
17:38:51 <Pseudonym> But you can't hard-code the number 17, if that's what you meant.
17:39:12 <Pseudonym> After all, {17} and {42} are unique up to isomorphism.
17:41:32 <np_hard> this might sound a bit perverse, but has anyone done functional programming in Perl?
17:42:10 <monotonom> does "sort sub { ... } mylist" count? :)
17:42:47 <amgine2> how do you disable the dos console during compling
17:42:53 <amgine2> so it dosen't show when you start the program ?
17:43:20 <np_hard> :)
17:43:27 <Smerdyakov> amgine2, don't use Windows.
17:44:15 <np_hard> I am talking about the whole shebang ... how hard is it to program in a side-effect-free and higher-order-function style in Perl?
17:44:49 <Jerub> #!
17:44:55 <monotonom> Since there is "sub {...}" and also function application is written as "f x" it is not very hard.
17:44:55 <Cale> np_hard: it's np_hard :)
17:45:10 <Riastradh> np_hard, using existing Perl libraries, wicked hard.
17:45:19 <Riastradh> The Perl _language_ doesn't prevent it, though.
17:45:35 <Riastradh> Since Perl has real anonymous closures, it's a lot better suited for it than most mainstream imperative languages, in fact.
17:46:05 <np_hard> o well
17:46:13 <Jerub> I want real anonymous closures for my toy language ;)
17:46:17 <np_hard> I was wondering how to come to grips with Perl at work
17:46:33 <np_hard> I was toying with the idea of pretending it is Lisp instead of pretending it is C
17:46:34 <np_hard> :)
17:46:45 <amgine2> Smerdyakov you kidding me ?
17:46:46 <ayrnieu> Perl had, at least back when they numbered their releases with funky 5.000 strings, some memory problems with anonymous subs.
17:46:52 <amgine2> there must be a way to turn it off
17:47:01 <amgine2> if i didn't use windows i would never get any desktop work done
17:47:05 <Smerdyakov> amgine2, I don't know. I think hardly anyone here does Windows development.
17:47:18 <amgine2> k
17:47:22 <amgine2> anywho i gotta work
17:47:26 <amgine2> but overall the prog works
17:47:28 <amgine2> thanks for help
17:47:38 <monotonom> If I don't use Windows I will never waste any time playing games.
17:48:07 <amgine2> monotonom true
17:48:13 <monotonom> If I don't play games, I actually get some work done.
17:48:13 <__jt__> side effect free in perl. what a thought.
17:48:30 * ayrnieu manages to waste plenty of time on non-windows systems, somehow.
17:48:33 <amgine2> but this is a long debate, i must say i loved linux and will go back to it but only when i have a spare computer
17:48:50 <Jerub> amgine2: knoppix ;)
17:49:28 <amgine2> WOW
17:49:31 * ayrnieu finds 'I use windows for games!' 'I use windows for desktop things!' hugely tiresome.
17:49:38 <amgine2> striping 7mb file results in 3mb file
17:49:39 <amgine2> not bad
17:49:47 <amgine2> still for 100 lines of code :|
17:49:51 <amgine2> but i still like haskell
17:50:02 <monotonom> I can't get any work done in Windows, unless I install cygwin, emacs, and all that.  But then I may as well install linux altogether.
17:50:06 <keverets> try writing the same in java or c++.
17:50:10 <ayrnieu> amgine - you'll care less as you write programs that contain more than 100 lines of code.
17:50:12 <amgine2> true keverets
17:50:16 <amgine2> that's why i stick with haskell
17:50:33 <amgine2> so does anyone now if ghc links staticly i.e. libraries are put inside the exe ?
17:50:37 <amgine2> the docs seem to suggest that
17:50:42 <monotonom> Yes it's static.
17:50:43 <ayrnieu> amgine - think of it as GHC's 'water level'.
17:51:17 <amgine2> i see
17:51:26 <amgine2> so that would explain the bigger code
17:51:32 <ayrnieu> the bigger object file.
17:51:41 <amgine2> yeah i'm sorry  i meant that
17:52:00 <amgine2> wow
17:52:13 <amgine2> striping and packing the exe reduced the file of 7mb
17:52:15 <amgine2> to .5mb
17:52:16 <amgine2> not bad
17:52:23 <amgine2> that's managable
17:52:38 <ayrnieu> just please try to keep in mind that if you care so much about binary sizes, you will eventually find yourself programming in Forth.
17:52:47 <Jerub> yay forth!
17:52:52 <Riastradh> Nay!  Joy!
17:53:01 <amgine2> lol i know
17:53:04 <amgine2> ayrnieu 
17:53:05 <amgine2> i know
17:53:18 <amgine2> it's just it's nice to keep size resonable
17:53:25 <amgine2> anywho
17:53:28 <amgine2> thanks guys
17:53:28 <amgine2> i'm out
17:53:30 <Jerub> I've seen the forth compiler for parrot.
17:54:55 <ayrnieu> I hope the author finds it at least mildly embarassing, since he calls it a 'forth compiler' instead of 'a proof-of-concept that I didn't take very far'
18:02:00 <np_hard> parrot?
18:02:26 <__jt__> perl 6 vm
18:03:12 <np_hard> gross
18:43:18 <Jerub> np_hard: but its got continuations, it must be good ;)
18:43:59 <Smerdyakov> Continuations are way overhyped.
18:44:07 <Riastradh> Static typing is way overhyped.
18:44:17 <Pseudonym> Computers are way overhyped.
18:44:18 <monotonom> Yeah monads are more general and easier to use.
18:44:38 <monotonom> ("more general" than both continuations and computers!)
18:44:49 <Riastradh> Monads are way overhyped.
18:45:03 <Pseudonym> Hype is way overhyped.
18:45:10 <monotonom> Yeah it's just common sense isn't it.
18:45:13 <Riastradh> ML is way overtyped.
18:45:19 <Pseudonym> Common sense is way overhyped.
18:45:33 <Riastradh> Damnit, you ruined the leftward curve, Pseudonym.
18:45:42 <monotonom> I overhype all those who don't overhype themselves.
18:46:05 <Riastradh> I admit I did raise the bar considerably by using such a short thing as 'ML,' but still!
18:46:17 <Pseudonym> Continuous derivatives are way overhyped.
18:46:32 <Smerdyakov> Oh no. Flashback to analysis class.
18:46:50 <Pseudonym> I don't see why I should maintain any leftward curve.
18:47:03 <Riastradh> Feng shui, Pseudonym, feng shui.
18:47:13 <Pseudonym> Feng shui is... oh, forget it.
18:47:27 <Riastradh> OK.  Back to my Scheme48 image inspector.
18:47:48 <Smerdyakov> That's where Riastradh writes a Scheme program to download porn for him to inspect.
18:48:10 <Pseudonym> Actually, the scheme program analyses it for quality before presenting it to Riastradh.
18:48:20 <Riastradh> And Smerdyakov complains about _me_ making stupid jokes...
18:48:32 <Pseudonym> Yes, he does.
18:50:05 <Smerdyakov> I found out today that the US gov't is going to give me a lot of money to be a PhD student.
18:50:15 <Pseudonym> Woohoo!
18:50:29 <Smerdyakov> Yup!
18:50:30 <Pseudonym> You are going to receive dirty money!  You are one of us!
18:50:45 <Smerdyakov> But I'm doing whatever I want. You're doing what they tel you to do!
18:51:02 <Pseudonym> Hmmm, true.  Damn.
18:51:22 <Smerdyakov> At least I didn't apply for the Homeland Security fellowship.
18:51:32 <Smerdyakov> YES, it's real. I know someone who applied and got it.
18:51:46 <Pseudonym> Fight terrorism with referential transparency!
18:52:00 <Smerdyakov> It's bizarre. This guy's research is in _model_theory_.
18:52:26 <Pseudonym> Well... you never know...
18:52:38 <Pseudonym> Bad people have got to be modelled too.
18:53:05 <Smerdyakov> I assume you know what model theory is? :)
18:53:11 <Pseudonym> Yes, that's a stretch, but so is the Homeland Security fellowship.
18:53:22 <Pseudonym> I guess the question is: Did he get it?
18:53:45 <Smerdyakov> Huh?
18:53:54 <Pseudonym> The money,.
18:54:09 <Smerdyakov> I thought I expressed that. He did indeed get the money.
18:54:20 <Pseudonym> No, you expressed that he applied.
18:54:28 <Pseudonym> Oh, yes.
18:54:29 <Pseudonym> Duh.
18:54:31 * Pseudonym can't read
18:54:44 <Smerdyakov> That fellowship is dirty dirty dirty.
18:55:04 <Pseudonym> Which makes me eminently suitable for writing software to handle maintenance manuals for warships.
18:55:08 <Smerdyakov> It includes an "informal" provision that you will accept a "competitive offer" from a national security related organization after graduation
18:55:27 <Pseudonym> Oh, ick.
18:55:43 <Pseudonym> Well, I guess the NSA might be interested in a model theorist.
18:56:25 <Pseudonym> Or a pure mathematician, anyway.
18:56:26 <__jt__> I considered applying for that. Nothing wrong with taking the departments money and using it for subversive purposes.
18:56:40 <Pseudonym> __jt__: But if you have to work for them afterwards?
18:56:57 <__jt__> no commitment implied I thought. that would be very different ;)
18:57:48 <Smerdyakov> __jt__, yes commitment implied.
18:58:06 <Smerdyakov> __jt__, unenforceable, but very "gentlemen's agreement"-y.
18:58:22 <Pseudonym> And if you decide not to take them up on it, expect your file to get thicker.
18:58:51 <__jt__> oh right, required internship.
18:59:15 <Smerdyakov> See second question at http://www.orau.gov/dhsed/04FAQs.htm
19:00:08 <Smerdyakov> "the purpose of this statement is to make applicants aware of the desired connection between those who accept these awards and the mission of the Department of Homeland Security."
19:00:12 <Smerdyakov> How sinister is THAT? :D
19:00:40 <Pseudonym> "There are many different paths your career could take that would serve the mission of the DHS."
19:01:02 <Pseudonym> I feel nervous just reading this.
19:01:11 <Pseudonym> Makes me wonder what they're going to do with the server logs.
19:02:05 <Smerdyakov> __jt__, are you a CS PhD student in the USA?
19:02:17 <__jt__> yes.
19:03:02 <Pseudonym> Man, makes me glad to be an Australian.
19:04:16 <Jerub> :))
20:18:14 <rt> *yawn*
20:18:39 <Pseudonym> Why do people spend their far-too-tired hours on IRC?
20:19:11 <rt> cuz we work when we aren't tired?
20:19:14 <Pseudonym> (In my case it's because I'm at w*rk and it's more convincing than sleeping at my desk.)
20:46:09 <Jerub> I irc while I work. ;
20:51:43 * juhp does most of his communication at work over irc...
22:01:32 <skew> Yay, Python calls Haskell!
22:01:42 <Pseudonym> What does it call Haskell?
22:02:39 <skew> add
22:03:31 <skew> well, now I have functions for starting up a python interpreter, poking around in it, and extending it with stuff written in Haskell
22:04:08 <monotonom> That is not bad.
22:04:44 <skew> now I'm going to see if I can package a Haskell module up as an extension with this, for a main program in Python
22:21:07 * Jerub blinks
22:21:14 <Jerub> that'd quite seriously, without a doubt, rock.
22:22:38 <Jerub> provided I could actually get back a parse tree from an ADT.
22:22:57 <Jerub> actually, I don't even need that, just a string.
22:30:40 <skew> Jerub: I'm looking for suggestions of how to expose algebraic data type
22:31:50 <Jerub> skew: will tuples be sufficient?
22:32:36 <skew> that could handle the product part
22:32:46 <skew> I suppose you could use constructor tags or something
22:33:31 <Jerub> i.e. Op "*" (Lit "a") (Lit "b") -> ("Op", "*", ("Lit", "b"), ("Lit", "b"))
22:35:25 <skew> I think I can do that
22:35:44 <skew> reading that back could be harder
22:36:09 <skew> what would you want to wrap?
