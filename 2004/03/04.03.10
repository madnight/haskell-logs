01:16:17 <earthy> moin kosmikus
01:21:48 <kosmikus> moin earthy
01:22:05 <kosmikus> (that's not a dutch greeting, is it?)
01:30:17 <earthy> nope, it's german. :)
03:39:25 <shapr> yeehaa
03:44:02 <earthy> what? you're allowed to stay another couple of months?
03:45:26 <shapr> oh, believe it or not the migrationsverket hours as published on their website are nowhere close to reality, so we have to go back again now.
03:45:57 <Jerub> yow
03:46:05 <shapr> @yow !
03:46:05 <betabot> CALIFORNIA is where people from IOWA or NEW YORK go to subscribe to
03:46:05 <betabot>  CABLE TELEVISION!!
03:46:08 <Jerub> i hurt
03:46:16 <shapr> too much coding?
03:46:20 <Jerub> no!
03:46:26 <Jerub> I went to karate for the first time in 6 years.
03:46:28 <shapr> oh
03:46:32 <shapr> I bet that does hurt
03:46:37 <Jerub> my mouse hand was tangibly weak.
03:46:57 <shapr> I haven't done any unicycling in a month
03:47:08 <shapr> maybe even longer
03:47:19 <shapr> I'm getting programmer's belly.
03:48:12 <shapr> of course, cutting down on sugary drinks would probably fix that.
03:48:28 <shapr> yay, citeseer is back up.
03:48:34 * earthy noted! :)
03:48:43 <earthy> and found like a ton of references
03:48:58 <earthy> that he can't, unfortunately, follow quite now
03:48:59 <earthy> :|
03:49:04 <Jerub> shapr: I've still got a figure like a stick insect.
03:49:15 <Jerub> but I've been having worse-than-usual rsi-type problems.
03:49:20 <shapr> earthy: references for what?
03:49:27 <Jerub> I've discovered that workrave counts daily keypresses.
03:49:32 <shapr> what's workrave?
03:49:35 <Jerub> in my 8 hour work day I average 35-38k
03:49:39 <Jerub> shapr: www.workrave.com
03:49:41 <earthy> references *to* `Modular Denotational Semantics for Compiler Construction'
03:49:49 <shapr> oh, neat
03:49:53 <earthy> one of which at least seems highly promising.
03:49:54 <Jerub> application which assists you in taking regular breaks.
03:49:59 <shapr> Jerub: dude, BUY A KINESIS
03:50:15 <earthy> shapr: even then breaks help
03:50:21 <shapr> seriously, as a programmer, your wrists are your livelihood.
03:50:25 <shapr> yah, I agree.
03:50:31 <Jerub> shapr: I'm working out how much medical insurance, salary sacrifice and the australian dollar will help me with buying one.'
03:50:40 <shapr> breaks are not a problem for me, nor is changing posture regularly, etc
03:50:53 <shapr> I have trouble just staying in one place for very long.
03:51:22 <Jerub> I'm mousing with my left hand as of today, and I'm organising to get back to a mouseless window manager.
03:51:27 <shapr> whoa, debian package
03:51:31 <shapr> I can help you with ion2
03:51:31 <Jerub> (just need to get mutt going again)
03:51:42 <shapr> trackball will help also
03:51:45 <Jerub> shapr: I know ratpoison (used it for 4 months)
03:51:52 <shapr> since you don't need to suspend your arm to move the pointer
03:52:11 <shapr> do you use dvorak?
03:52:41 <Jerub> no, I'm a vi user, switching to dvorak is a hard task.
03:52:44 <Jerub> I *can* dvorak.
03:52:56 <Jerub> I learnt it back in high school for kicks.
03:52:58 <shapr> I'm an emacs user.
03:53:07 <shapr> of course, I learned emacs after I learned dvorak
03:53:24 <shapr> anyways, it's worth it, imho
03:53:24 <Jerub> I think I learned vim after dvorak, but never combined them.
03:53:30 <Jerub> I'd love to move to emacs.d
03:53:40 <Jerub> but I can't.
03:53:40 <ecraven> emacs.d?
03:53:45 <shapr> I'm willing to help you with emacs
03:53:46 <shapr> why not?
03:53:47 <Jerub> ecraven: typo.
03:53:55 <shapr> I thought it was like rc.d :-)
03:54:10 <shapr> a pun on emacs as an operating system
03:54:22 <Jerub> shapr: long story, short is, vim is standard, emacs isn't installed, and horsepower on the machines I edit on is at a premium (they're live servers)
03:54:39 <Jerub> s/standard/company standard/
03:54:43 <shapr> so don't edit on the machines, edit in emacs from another machine
03:54:55 <Jerub> shapr: not an option, mandate from above.
03:54:57 <shapr> emacs has tramp, which lets you remotely edit via ssh,scp,telnet,whatever
03:55:02 <Jerub> its a long story, but the short is I simply can't.
03:55:21 <shapr> so, tell your above people that they're killing your wrists because of their overly restrictive policies :-P
03:55:30 <shapr> ok, that's too harsh
03:55:34 <Jerub> there's a long term possibility we'll get a dev server, in which case all bets are off.
03:55:53 <shapr> you can still use emacs for everything else, right?
03:56:38 <Jerub> shapr: there is nothing else, I'm a php programmer.
03:56:41 <Jerub> :/
03:56:58 <shapr> you have to use vi to edit php on your very busy live servers?
03:57:28 <Jerub> shapr: I could tell you things about my working conditions that would make you CRY. I try not to talk about it.
03:57:36 <shapr> I think you need a dev server at least
03:57:50 <shapr> I'm all ready to cry for you.
03:58:02 <shapr> it sounds insane.
03:58:16 <Jerub> let me give you the 10thousand foot view.
03:58:26 <shapr> so, is your health insurance at your job required to take care of you if you blow out your wrists?
03:58:54 <Jerub> we have a single non-load-balanced 4x1.4ghz xeon hyperthreaded web server.
03:59:11 <Jerub> 9ish MySQL database servers and a single (underpowered) oracle box.
03:59:29 <Jerub> the oracle database was designed by a guy who had to be explained to last year was 'normalisation' was.
03:59:48 <shapr> if your company is not obligated to take care of you if you blow out your wrists in extremely difficult working conditions, I would strongly recommend you get another job.
03:59:50 <shapr> eek
03:59:51 <Jerub> and is 12+ years old and was used primarily until 3 years ago for oracle forms. there's a table in there with 290 columns
04:00:18 <Jerub> we have no version control, all source is edited on the web server directly. we have a dev/ and a live/ source tree, we copy from one to the other after testing is complete.
04:00:28 <shapr> holy shit on a stick
04:00:30 <Jerub> there is no procedure for either testing or moving live, individual programmers just do it.
04:00:31 <shapr> dude, run away!
04:00:46 <shapr> it's not worth it no matter what they're paying you.
04:00:54 <Jerub> we have 15 full time programmers, 0 IT support personel in a company with 50+ non-IT staff.
04:01:17 <Jerub> We code in nothing but PHP, no matter what the task, all background scripts are also php.
04:01:48 <shapr> I am surprised that a) you don't have ulcers b) the company can continue to pretend to be profitable
04:02:11 <Jerub> the web server runs at loads of 4+, crippling spikes of up to 100+ happen daily when a database server hiccup.
04:02:43 <shapr> why are you working there?
04:03:16 <shapr> unless you're making a retirement-sized fortune off of writing Dilbert stories from these experiences, I don't see a good reason to work there.
04:04:01 <Jerub> shapr: a) I'm not responsible for anything, I'm just a grunt. A victim of "he's too good at his job to promote him" b) we're a multi-million dollar operation because we're in a very limited market. we sell credit reports, company data and property data. (every real-estate agent in our state either has an account with us or our major competitor)
04:04:50 <Jerub> oh and why I'm still there? I've been working here since I was a unversity student (1+ year ago I graduated, 3+ I started work here)
04:05:17 <Jerub> I'm also married, so quitting and doing contract work doesn't give me the job security I'm after, so I need another fulltime position before I can quit.
04:05:23 <shapr> if your wrists are bothering you one year after graduating from university, you need to make a major change.
04:05:35 <shapr> I understand that :-/
04:06:01 <Jerub> I hate bitching about my work, it spams channels really badly becuase there's just so many horrible things.
04:06:22 <shapr> on the good side, it's always fun to hear about someone else's problems, because you don't have them.
04:06:28 <shapr> if that makes any sense
04:06:33 <Jerub> I understand ;)
04:06:38 <shapr> I've got some great stories myself.
04:06:43 <shapr> some of which are still in progress.
04:07:30 <Jerub> oh, and re: health insurance, I'm in australia, we don't have employer-based health insurance.
04:07:42 <shapr> dude, it's not worth it.
04:07:59 <Jerub> there's something called 'work-cover' which will cover me if my wrists blow. I've also got private medical insurance that I pay for myself.
04:08:05 <liiwi> Morjens
04:08:23 <shapr> if you have to almost starve for a few months to save up enough cash to have the spare time to swap jobs, you should do it.
04:09:05 <shapr> I plan on coding until I'm seventy years old at least, that's why I've invested in learning dvorak, buying a kinesis, trackball, etc
04:09:17 <shapr> and why I've invested in Haskell too
04:09:19 <shapr> hei liiwi 
04:09:21 <liiwi> I just keep my wrists in air
04:09:28 * shapr grins
04:09:41 <liiwi> and change languages as often as my underwear
04:09:44 <liiwi> or well.. not quite
04:09:51 <shapr> talar du svenska? ;-)
04:09:57 <liiwi> en helvetiss√§
04:10:21 <shapr> svenska olen helveti?
04:10:34 <Jerub> http://jobs.qld.gov.au/search/JobDetail.asp?JobId=31000 <- I'm filling out application forms for this position right now actually.
04:10:38 * shapr gives on finnish
04:10:58 <liiwi> I've done c, awk, perl and python today.
04:11:27 <liiwi> shapr: njet, just won't speak it.
04:11:43 <shapr> I've done Python, SQL, elisp, and some shell scripting in the last 24 hours.
04:12:04 <Jerub> I've done sql, python and php in the last 24.
04:12:22 <shapr> oh, I did some Haskell less than 48 hours ago, but more than 24
04:12:36 <Jerub> I've been reading a haskell textbook ;)
04:12:39 <shapr> yay!
04:12:49 <shapr> liiwi: have you done any Haskell recently?
04:13:14 <Jerub> I've been considering learning smalltalk too.
04:13:29 <shapr> I've done a tiny bit of smalltalk, but not enough to say I know it
04:13:40 <Jerub> now that I'm approaching haskell again, I'm realising how different the typing system is to other languages.
04:13:50 <shapr> yah, that's happening to me too.
04:14:06 <Jerub> especially the meanings of type/data/class/instance.
04:14:11 <liiwi> shapr: unfortunately not
04:14:33 <shapr> there's more though, I'm beginning to see some extra resolution, namely, where the IO monad fits into Python.
04:14:39 <shapr> that is *really* cool.
04:15:04 <Jerub> shapr: have you seen python 2.4's generator expressions?
04:15:07 <shapr> it's like having an extra mental lever for prying troublesome bits of code apart.
04:15:17 <shapr> I think I read the PEP
04:15:25 <Jerub> lazy list comprehensions! yay!
04:15:40 <shapr> didn't someone figure out that generators and list comprehensions have subtly different behaviour?
04:16:05 <shapr> anyways, I'm off to migrationsverket, bbl
04:16:06 <Jerub> well, you can't exactly len() a generator ;)
04:16:14 <Jerub> bye!
04:16:19 <Jerub> I'm going to bed shortly.
04:16:24 <shapr> g'night!
04:16:26 * shapr bails
04:53:11 <Si> is anyone available who can answer a question about hetrogeneous lists and State monads?
04:53:41 <Jerub> I wish I could!
04:55:03 <jlouis> maybe
04:56:02 <Si> right, I am trying to create a marshalling environment so that I can store reference data (i.e. if my data structures contain a reference they will point to an item in a list stored within the state)
04:56:27 <Si> data MR = forall a . (Marshal a) => MR (Value a)
04:56:27 <Si> data MarshalEnv = MENV{refReg::[IORef MR]}
04:56:36 <Si> that's the marshalling environment
04:57:05 <Si> basically, a list of IORefs pointing to arbitrary values
04:57:28 <Si> well values, which can be Marshalled by the Marshal class
04:57:48 <jlouis> Beyond my Haskell knowledge. forall a . ... is not even Haskell 98 ;)
04:57:54 <Si> ok
04:58:25 <jlouis> I see what you want though
05:00:08 <Si> trying to simulate marshallable, mutable references in Haskell is not easy
05:01:30 <Si> I'm giving up for the moment, l8r
05:37:25 <ski> (hmm, are there nonconfluent abaci ?)
05:38:16 <shapr> abaci is plural of abacus?
05:38:31 * ski is not sure, just guessed that ..
05:40:18 <ski> ("confluent abacus furnish complain locksmith" is the subject line of a mail (spam) i just got ..)
05:42:52 <ski> hmm, oh. overdue loan .. :(
05:43:05 <shapr> huh?
05:43:29 <ski> shapr : i just got an overdue message from the library ..
05:43:42 <shapr> oh
05:43:46 <CrewdenX> ski  according to my filter i've received 0 good instances and 10 bad instances of "locksmith"
05:44:02 <shapr> my easy solution is, don't checkout books from library, just read them at the library.
05:44:07 <shapr> works for me.
05:44:25 <ski> but i want to take them with me .. :/
05:44:36 <CrewdenX> 2 good instances and 15 bad instances of abacus.     1 good and 4 bad for furnish.      
05:44:37 <shapr> oh
05:44:57 * Marvin-- has a confluent abacus furnish complain locksmith spam too
05:45:08 <ski> ("Categories and computer science" is the book in question. some parts were quite interesting ...)
05:45:46 <ski> CrewdenX : you've got a spiffy spam filter ?  bayesian ??
05:45:53 <CrewdenX> confluent was 0 good and 15 bad.  apparently i've been receiving them or something similar for a while.
05:45:59 <CrewdenX> ski: yeah, it's bayesian.
05:46:41 <Heffalump> ski: what authors?
05:46:58 <ski> CrewdenX : so you've not gotten any mail containing confluent operational semantics, then ? :)
05:47:09 <ski> Heffalump : Walters, R F C
05:47:24 <CrewdenX> ski: i haven't been keeping the spam.  i can only tell you about individual words.
05:48:13 <CrewdenX> semantics says 0 for bad.
05:48:25 <ski> CrewdenX : (oh. i meant a non-spam message about e.g., say, confluent reduction of lambda calculus ..)
05:48:56 <CrewdenX> i'm not on any haskell lists.
05:49:42 <ski> (well, that is not exactly haskell)
05:49:53 <CrewdenX> really I haven't used it for much of anything.  in fact haven't touched it for a few weeks.
05:50:27 <ski> Heffalump : seen it ?
05:54:03 <ski> (in that book, they have a few places with "crazy calculation"s with types. e.g. taking square root and using derivatives of types ;)
05:54:51 <Heffalump> nope
05:55:11 <ski> ok
05:55:27 <Heffalump> I was wondering if you were talking about Barr and Wells, which I have read.
05:55:37 <Heffalump> It has a similar-ish title
05:55:48 <ski> this is a quite lean book
05:58:36 <ski> (hmm, btw, the "crazy calculation"s reminds me of a paper by Conor McBride which talks about (partial) derivatives of types)
05:59:45 <earthy> barr & wells have writen Category Theory for Computer Science
06:00:16 <earthy> which is indeed similar-ish. :)
06:00:38 <ski> there's also a "Basic Category Theory for Computer Scientists" :)
06:00:55 <ski> (by Benjamin C. Pierce)
06:02:42 <earthy> hm. SimonPJ who talks about things as being `a slight hack really.' scary. ;)
06:03:29 <ski> "things" ?  what things ?
06:04:48 <ski> internal structure (like points) of objects in categories ????
06:05:46 <Marvin--> in this case, "things" is let expressions for unboxed values are strict in core
06:06:00 <Marvin--> which is "a slight hack"
06:06:39 <ski> ok
06:06:54 <Marvin--> if I understood it right
06:07:37 <ski> (on mailing list ?)
06:08:19 <Marvin--> g-h-u
06:09:08 <ski> mhm
06:09:40 <Marvin--> hello ninja
06:12:30 <SyntaxNinja> hihi Marvin--
06:18:01 <Marvin--> note to self: running a theorem prover without setting a max memory limit is a bad idea
06:19:19 <andersca> alfa?
06:19:21 <andersca> agda?
06:21:16 <Marvin--> Eprover
06:22:00 <earthy> it starts thrashing and then barfs? :)
06:22:44 * earthy realises citeseer is the scientific-article variant of orkut
06:24:00 <shapr> yah, good point
06:24:11 <shapr> I wonder if I could hack up a research paper wiki plugin for MoinMoin
06:24:22 <shapr> something that leeches urls from citeseer.
06:24:39 <Si> Is it possible to have a function of type (C a) => x -> a where x is a monomorphic type and a is found by applying x to a function in C?
06:25:14 <Si> sorry I mean (C a) => a (IO a)
06:25:41 <Si> wrong again, (C a) => x -> IO a
06:28:10 <Si> because I have a function which takes a list of IORef CallValue and tries to convert it to a list of Marshal a => [Value a] by applying marshal :: Marshal a=> CallValue -> a to the contents of each IORef and it won't and it won't
06:28:24 <ski> hmm, i think, what the type 'a' becomes above is determined by the context of the use of the function of said type ..
06:29:06 <Si> correct, it should allow me to coerce the values when I actual return the values in a stub
06:29:23 <Si> but because IO is strict, I'm not sure if this will work...
06:30:20 <ski> hmm, i'm not exactly sure of what you are trying to do/what your problem is ..
06:30:26 <earthy> huh? wha? IO is strict?
06:30:34 <ski> perhaps you can elaborate more ?
06:30:42 <Si> isn't IO strict?
06:30:56 <earthy> IO is just a monad
06:31:38 <ski> Si : what do you mean by saying that "IO is strict" ?
06:31:56 <ski> normally, it's functions that are strict
06:32:11 <earthy> or evaluation strateges
06:32:12 <earthy> +i
06:32:33 <ski> (e.g. functions living on the value level. one could of course think of IO as a *type function*, living on the type level)
06:32:41 * shapr rates this channel +i - Interesting
06:32:57 <earthy> aw, shoot.
06:33:09 <earthy> I've found an article that may well make my current research superfluous.
06:33:16 <shapr> which article?
06:33:28 <earthy> http://citeseer.ist.psu.edu/318714.html
06:34:02 <shapr> looks like a cool article
06:34:13 * earthy nods
06:34:18 <shapr> imho, it's difficult to search citeseer effectively.
06:34:26 <earthy> it takes time
06:34:39 <earthy> and walking the citationtree up- and downwards
06:34:42 <shapr> hi shawn, how's the great southwest?
06:34:50 <shapr> there must be a better way.
06:36:04 <earthy> shapr: how? :)
06:37:21 <shapr> dump all the citeseer connections into a wiki structure, let people add notes, categories, etc
06:39:11 <Si> I don't really know what I mean, all I know is that when I tried to evaluate an infinately recursive structure in StateIO is went into infinite loop, with a non-StateIO function it didn't
06:39:32 <Si> anyway that obviously isn't the problem anyway
06:39:45 <Si> I'll explain in detail;
06:40:37 <earthy> shapr: that takes work. citeseer is automatic.
06:40:45 <Si> I have a data-structure data CallValue = Simple ParameterData String | Compound ParameterData [CallValue] | CA1 ParameterData (Array Int CallValue) ... CA5 ParameterData (Array (Int, Int, Int, Int, Int) CallValue) | Reference ParameterName (IORef CallValue) | Null deriving (Typeable, Show)
06:40:47 <earthy> that last part is the beauty if oit
06:41:33 <Si> it stores various types of marshalled data
06:41:57 <Si> that has been converted from an XML document
06:42:50 <Si> I also have a class called Marshal, which contains 2 functions marshal :: a -> CallValue, and unmarshal :: CallValue -> a
06:42:59 <Si> well it used to
06:43:06 <shapr> thing is, a wiki records the work that people do, so I think citeseer would be better as a wiki
06:43:16 <shapr> though maybe better as a wiki 'on top of' the current citeseer structure.
06:43:40 <Si> a has now become Value a, because theoretically any value coming over the net can be a reference to another value
06:43:56 <Si> data Value a = Val a | Ref CallValue | Null
06:44:05 <ski> ok
06:44:09 <Si> O
06:44:11 <Si> k
06:44:18 <shapr> K
06:44:19 <shapr> O
06:44:20 <shapr> !
06:44:36 <ski> so
06:44:37 <ski> is
06:44:39 <ski> Value
06:44:40 <ski> a
06:44:42 <ski> Monad
06:44:43 * shapr laughs
06:44:43 <ski> ?
06:45:03 <Si> so, now I've got all this data and I want to a bunch of CallValue s to Value s, the main problem is references
06:45:20 <shapr> can you use TyingTheKnot to build the whole structure at once?
06:45:23 <ski> "CallValue s" ?
06:45:32 <ski> is CallValue parametric now ?
06:45:39 <Si> no, the references must be mutable
06:46:19 <Si> no, I mean Callvalues but the type isn't called CallValues its called CallValue, so I put in a space
06:46:39 <Si> and no it isn't parametric, all values in CallValue are stored as Strings in some capacity
06:47:20 <ski> ok (i would perhaps write that "CallValue's" (or maybe "CallValue:s" ??))
06:47:26 <ski> ok
06:47:26 <Si> ok
06:47:42 <Si> well I changed my marshalling class to reflect references
06:47:53 <Si> by changing it first to marshal :: a -> IO a
06:48:09 <Si> and now to marshal :: a -> StateIO MarshalEnv a
06:48:26 <Si> where MarshalEnv holds a list of all the references
06:49:14 <Si> so I can either dispense of IORef's in CallValue entirely
06:49:17 <ski> so, what exactly do you want to do with the bunch of CallValues ?
06:49:31 <ski> sortof dereference them ?
06:49:35 <Si> marshal em to real values and chuck em at a function
06:49:49 <Si> or rather unmarshal
06:49:52 <ski> to "s" or to "Value s" ?
06:50:11 <Si> and then marshal the returns back to CallValues ready for wrapping up for RPC
06:51:29 <Si> to do this I need to marshal the contents of my references and convert them to IORef's
06:51:58 <Si> i.e. by marshalling the list of CallValues flagged as being referenced to
06:52:34 <Si> so I run unmarshal :: CallValue -> Value a on each one
06:52:36 <ski> "to do this .." ? which direction are you talking about now ?
06:53:06 <Si> to marshal all the data
06:53:11 <Si> or unmarshal it
06:54:11 <Si> you see I have to prepare a marshalling environment before I can marshal any values so that the actual parameters have somewhere to pick up their reference data from
06:54:57 <Si> since if I have two parameters a and b who both have a part which points to c, they need to both have the same IORef
06:55:58 <ski> which type would a and b have here ?
06:56:11 <ski> Value something ?
06:56:15 <shapr> hi robbe^work 
06:56:17 <Si> yes
06:56:19 <robbe^work> hi
06:56:25 <shapr> looking for Haskell info?
06:56:50 <Si> let's say we have Person{name::String, friend::Person}
06:57:01 <ski> Si : so a and b could both contain CallValue's, then ?
06:57:15 <Si> before they are unmarshalled yes
06:57:17 <ski> Si : which "points to the same place" ?
06:57:50 <Si> consider the above data-types, suppose two people have the same friend
06:58:02 <ski> ok
06:58:05 <shapr> guess not
06:58:20 <Si> or they might not
06:58:31 <Si> they might have totally different friends
06:58:38 <ski> shapr : perhaps he thought you were a bot ! ;-)
06:58:42 <shapr> could be
06:58:44 <Si> but, we have to represent both possibilities
06:58:48 <shapr> that seems to happen a lot lately :-/
06:58:53 <Si> :)
06:59:01 * shapr grumbles
06:59:33 <Si> so unfortunately I have to have the horrible data-type Value
06:59:41 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!"]' by shapr
06:59:49 <Si> lol
06:59:51 <ski> Si : so, how would you express the sharing of friends for two people ?
06:59:59 <ski> shapr : heh
07:00:14 * shapr grins
07:00:29 <Si> well, that structure would have to be changed to be Person{name::Value String, friend::Value Person}
07:00:35 <ski> right
07:00:42 <ski> supsected something like that .. :(
07:00:52 <Si> then each part can EITHER be another actual value OR a reference
07:00:52 <ski> (suspected, even)
07:01:03 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!"]' by shapr
07:01:23 <Si> with the previous (or current) data structure I had Value a = Val a | CallValue | Null
07:02:03 <Si> which would have meant that users would have had to first unmarshal the value with the references, then get the CallValue at the references then unmarshal that
07:02:07 <Si> which is ugly
07:02:20 <Si> yah got me?
07:02:26 <ski> hmm
07:02:35 <ski> maybe
07:03:14 <Si> class (Typeable a, Show a) => Marshal a where
07:03:14 <Si> 	marshal :: (Value a) -> QName -> StateIO MarshalEnv CallValue
07:03:14 <Si> 	unmarshal :: CallValue ->  StateIO MarshalEnv (Value a)
07:03:23 <Si> that's the Marshal class ATM
07:04:00 <shapr> greetings gnarf, looking for Haskell info?
07:04:00 <shapr> ps. I am NOT a bot.
07:04:19 * shapr lags
07:04:24 <gnarf> indeed
07:04:49 <gnarf> i'm just about to learn this interesting language though time is lacking a bit.
07:04:57 <shapr> you've come to the right place.
07:06:12 <gnarf> although i don't think i've understood the concept of monads i'd like to do something else. is there a function like take but stop taking elements if an elemt is larger than a given value? (for Ord)
07:06:32 <shapr> @type until
07:06:33 <betabot> until :: (a -> Bool) -> (a -> a) -> a -> a
07:06:44 <shapr> @type take . until
07:06:49 <ski> @type takeWhile
07:06:49 <betabot> takeWhile :: (a -> Bool) -> [a] -> [a]
07:07:11 <gnarf> i think i was looking for exactly that.
07:07:19 <ski> @type takeWhile (< "tralala")
07:07:20 <betabot> takeWhile (flip (<) "tralala") :: [[Char]] -> [[Char]]
07:07:32 <Si> the system works on the basis that function stubs are coerced so that the Marshal class knows exactly what the output should be
07:07:48 <ski> mm, i guessed that ..
07:08:14 <Si> and it works great with non-references
07:09:52 <shapr> gnarf: any other questions?
07:10:31 <Si> What I'd really like is to be able to store a list of data MR = forall a . (Marshal a) => MR (Value a)
07:11:01 <shapr> that looks a bit like the tricks that lambdabot uses to store per-module state
07:11:15 <ski> Si : hmm, so is your problem about designing your types ? or about making a working algorithm ?  (sorry for not getting this yet ..)
07:11:27 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
07:12:03 <Si> unfortunately when I try to do that from the StateIO monad, I get Marshal.hs:2:
07:12:03 <Si>     Ambiguous type variable `a' in the top-level constraint:
07:12:03 <Si>       `Marshal a' arising from use of `MR' at Marshal.hs:188
07:12:03 <Si> Failed, modules loaded: Governor, CallStructure, Constants.
07:12:11 <ski> Si : can't you store such a list ?
07:12:51 <shapr> Si: you have -fglasgow-exts ?
07:13:13 <Si> I think it might work outside of StateIO, but then I couldn't manipulate refs or have a state
07:13:16 <ski> shapr : btw, lambdabot has occationally given an "index too large" error, when using @arr, at least ..
07:13:18 <Si> yes I have exts
07:13:30 <shapr> ski: yah, I know the fix too, just haven't done it yet.
07:13:41 <shapr> I made my own choose random function, and it's broken.
07:13:42 <gnarf> shapr: indeed. i have a strange expression that does works different than i think. but my thinking is probably broken due to programming c for years..
07:13:46 <Si> the line is : y <- mapM (\x -> (io $ readIORef x) >>= um >>= (\x -> return $ MR x)) refs
07:13:57 <Si> where um = unmarshal
07:14:23 <Si> and refs is a list of [IORef CallValue]
07:14:23 <gnarf> i was trying this (must be looking _very_ ugly, right?): primes = 2 : 3 : [ x | x <- [5,7..], foldl (&&) True [ x /= a*b | a <- takeWhile (\t -> t<=x**0.5) primes, b <- takeWhile (\t -> t<=x**0.5) primes ] ]
07:14:26 <shapr> gnarf: if it's a short expression (three lines or less) you can paste it into the channel
07:14:42 <shapr> if it's longer than three lines, there's a page on the Haskell Wiki that we use for pasting.
07:14:48 <Si> well no, it's just a list of IORef CallValue
07:15:22 <gnarf> shapr: you use a wiki for pasting? interesting idea. never thought of that %)
07:15:52 <shapr> it's handy now that the Haskell Wiki has color-highlighting of Haskell source
07:16:15 <ski> Si : hmm, it looks like it doesn't know *which* type 'a' it should try to unmarshall to ..
07:16:25 <Si> exactly
07:16:34 <Si> because I *think* IO is trying to evaluate it
07:17:10 <ski> unmarshal :: forall a. Marshall a => CallValue ->  StateIO MarshalEnv (Value a)
07:17:42 <shapr> gnarf: what's the problem with that line of code?
07:18:12 <ski> is unmarshal checking its input for consistency (i.e. if it really should be unmarshalled to the type 'a') ?
07:18:16 <gnarf> shapr: 15 is not prime
07:19:06 <Si> unmarshal for Int
07:19:08 <Si> instance Marshal Int where
07:19:09 <Si>     marshal a s = return (stdMarshal a s)
07:19:09 <Si>     unmarshal (Simple (_, Single "Int") x) = return (Val (read x))
07:19:09 <Si>     unmarshal (Simple (_, t) x) = error $ "Typer error; " ++ x ++ " is not of type " ++ (show t)
07:19:17 <ski> gnarf : isn't "foldl (&&) True" more or less the same as "and" ?
07:19:17 <shapr> that's a good point
07:19:40 <Si> stdMarshal is simple a wrapper for read
07:19:42 <gnarf> ski: might be. is there a good reference?
07:19:45 <Si> show rather
07:19:49 <Marvin--> and uses foldr
07:20:45 <shapr> right, isn't foldr handier for infinite lists?
07:20:52 <ski> gnarf : well, at least if you use foldr, instead
07:21:00 <gnarf> oh. my problem is another nature. while thinking of haskell syntax all the time i wrote another function i was thinking of...
07:21:08 <Marvin--> it makes more sense to use foldr for &&, since && is normally defined to be strict in its left argument but lazy in its second (sort of)
07:21:26 <gnarf> ski: and is obviously a better choice. thanks :)
07:22:22 <ski> Si : hmm, in the type of unmarshal, 'a', is universally quantified
07:22:44 <ski> i think you perhaps want existentially quantified, in this case ...
07:22:48 <kosmikus> gnarf: your definition is just incorrect
07:23:27 <kosmikus> gnarf: 15 cannot be written as the product of two prime numbers that are smaller than the square root of 15, therefore it's in your list
07:23:49 <ski> Si : it seems to me that you just want to convert the CallValue to "the correct" type. i.e. for some type (sortof an output of the function)
07:24:05 <gnarf> kosmikus: right. i just saw that. thanks.
07:25:06 <ski> Si : what do you say ?
07:25:19 <Si> how do I existentially quantify?
07:25:39 <ski> well
07:25:50 <ski> you don't :)  (at least not explicitely)
07:25:52 <gnarf> can you also tell me a function for converting floating point number into an integer or something like sqrt for integers?
07:26:27 <ski> Si : you use a datatype, like the one corresponding to the constructor MR, IIRC
07:26:44 <ski> Si : how was that type's definition, again ?
07:27:08 <Si> class (Typeable a, Show a) => Marshal a where
07:27:08 <Si> 	marshal :: (Value a) -> QName -> StateIO MarshalEnv CallValue
07:27:08 <Si> 	unmarshal :: CallValue ->  StateIO MarshalEnv (Value a)
07:27:15 <ski> no
07:27:23 <ski> the type with MR as constructor
07:27:34 <Si> data MR = forall a . (Marshal a) => MR (Value a)
07:27:38 <ski> right
07:28:18 <ski> here, 'a' is existentially quantified (depends on from which direction you look at it, of course)
07:28:30 <ski> e.g.
07:28:52 <ski> data X = forall a. MkX (a,a -> String)
07:29:07 <shapr> gnarf: fromIntegral will turn an Int/Integer into a float, if that's what you want
07:30:11 <shapr> turning a float into an Int/Integer requires floor, ceil, etc
07:30:20 <ski> Si : forall a. MkX (_ :: (a,a -> String)) :: X
07:30:36 <ski> Si : forall a. MkX :: (a,a -> String) -> X
07:30:47 <ski> Si : MkX :: forall a. (a,a -> String) -> X
07:30:49 <kosmikus> gnarf: just write "x ^ 2 <= y" instead of "x <= y**0.5"
07:31:00 <ski> Si : MkX :: (exists a. (a,a -> String)) -> X
07:31:20 <ski> Si : there you have the existensial quantifier !
07:31:58 <Si> so what do I need to existentially quantify?
07:33:10 <ski> the result of unmarshal, or hmm, perhaps of a variant of unmarshal (you perhaps want to keep the original version, as well)
07:34:00 <gnarf> kosmikus: thanks
07:34:30 <Si> (y::(forall a. Marshal a => [Value a])) <- mapM (\x -> (io $ readIORef x) >>= um) refs?
07:35:28 <ski> (btw if we have "data X = forall a. MkX {unX :: (a,a -> String)}", then "unX :: X -> exists a. (a,a -> String)", i.e. "unX :: exists a. X -> (a,a -> String)", but we can't write like that in actual haskell :(  )
07:35:51 <ski> hmm
07:37:04 <gnarf> hm. my definition of primes works for now. thanks :) (btw. i only found one shorter definition so far using perl, but it is _extremly_ slow )
07:37:52 <Si> Marshal.hs:188:
07:37:52 <Si>     All of the type variables in the constraint `Marshal a' are already in scope
07:37:52 <Si>         (at least one must be universally quantified here)
07:37:52 <Si>     In the type: (Marshal a) => [Value a]
07:37:52 <Si>     While checking a pattern type signature
07:37:53 <Si>     When checking the pattern: y :: forall. (Marshal a) => [Value a]
07:37:55 <Si>     In a 'do' expression:
07:37:57 <Si>         (y :: forall. (Marshal a) => [Value a]) <- mapM (\ x -> (io
07:38:01 <Si>                                                                  $ (readIORef x))
07:38:03 <Si>                                                                 >>= um)
07:38:05 <Si>                                                         refs
07:38:07 <Si> what does that mean?
07:38:23 <ski> your present unmarshal, seem, to me, to (roughly) take a "CallValue" and give back a "Value a", where the 'a' is decided by the caller of the unmarshal function. if the statically supplied type 'a' doesn't match the type that the CallValue corresponds to, at run-time, then you give some kind of run-time error/exception
07:38:27 <ski> is that correct ?
07:38:47 <Si> correct
07:39:14 <Si> I could return a Maybe , but that would add even more boiler-plate
07:39:21 <ski> mm
07:39:42 <ski> (you could, of course, build that into the monad, as well)
07:40:07 <gnarf> i'll try to understand monads and may be back later. i'd like to thank you very much. :)
07:40:14 <Si> I think I'll just throw a catchable
07:40:19 <Si> atm anyway
07:40:28 <ski> unmarshal' :: exists a. Marshall a => CallValue ->  StateIO MarshalEnv (Value a)
07:40:49 <ski> that is the other kind of unmarshalling function that i considered here
07:41:17 <ski> this one doesn't dynamically check the actual type with the statically supplied one
07:41:48 <ski> simply because there isn't any statically supplied type in the use of this function
07:41:56 <Si> so how would one write that in Haskell?
07:43:04 <ski> what this function (or something like it) would do, is : determine, at run-time, what type the CallValue represents, and return the unmarshalling of the CallValue into that type (something of the form "Value a", for *some* x !)
07:44:30 <ski> s/x/a, of course
07:44:34 <Si> everything was going so well until I realised I had to implement references :(
07:44:46 <ski> hmm
07:45:26 <ski> from the look of your code example a bit above, it seems to me that you want a function like this ..
07:46:04 <ski> data MR = forall a . (Marshal a) => MR (Value a)
07:46:08 <ski> (you said)
07:47:01 <ski> so, an MR, contains a "Value a" for *some* type 'a' (with the additional constraint that 'a' is in the 'Marshall' type class)
07:47:30 <ski> so this seems to fit into the type of unmarshal', i think
07:47:31 <Si> ideally, unmarshallable values should return Null
07:47:41 <ski> right
07:47:48 <Si> Value a = Val a | Ref IORef a | Null
07:48:24 <Si> but I don't know how to get Haskell to accept the constraint Marshal a for all possible values of a
07:48:29 <ski> i.e. totally unmarshallable (no type 'a' exists that this could be marshalled towards)
07:48:52 <ski> hasn't you already done that in the definition of MR ?
07:48:57 <ski> can't we say
07:49:12 <ski> unmarshal' :: CallValue -> StateIO MarshalEnv MR
07:49:13 <ski> ?
07:49:25 <Si> ahhhhh
07:49:27 <ski> hmm
07:49:29 <Si> hold on
07:49:54 <ski> but, now of course, 'a' isn't mentioned in the type at all
07:50:07 <ski> so, where to define this function ?  (and how ?)
07:50:13 <ski> hmm
07:51:01 <ski> Si : you actually seemes to try to convert the result of unmarshal into an MR, anyway
07:52:51 <ski> but you first got "Value a", for universally quantified 'a' (i.e. programmer must statically supply the type 'a'), and then tried to just put it into the MR box (from which we can't statically determine what 'a' unmarshall should check the CallValue against (possibly making run-time error, if mismatching))
07:53:30 <Si> I g2g, but I'll bbl
07:53:33 <Si> got a bus to catch
07:53:57 <Si> ty for your help
07:54:35 <ski> ok
07:54:40 <ski> bye, Si
07:57:55 * ski sighs
07:58:08 <shapr> ?
07:58:33 <ski> another variant of Nigeria scam spam, it seems ...
07:59:20 <ski> (someone claiming to be a princess, blablabla ..)
07:59:28 <shapr> yah, that one
07:59:37 <shapr> I don't think halipeto has to be static
07:59:50 <ski> huh ?
07:59:50 * shapr ponders that thought
07:59:58 <ski> whaddya mean ?
08:00:06 <shapr> oh, Hampus was asking yesterday whether Halipeto was dynamic
08:00:22 <ski> what does that mean, in this context ?
08:00:25 <shapr> right now it's statically generated, but I don't think it would be hard to change that.
08:00:44 <ski> the generated pages ?
08:00:50 <shapr> means that right now, building a website with Halipeto would involve running a command to generate all the html source from the templates + the databasey stuff
08:01:01 <shapr> then copying the html source to a webserver or something
08:01:06 <ski> and then putting it online ?
08:01:08 <ski> ok
08:01:09 <shapr> right
08:01:45 <shapr> but, looking at buildPancitoSite, I don't think it has any requirements that force staticness
08:01:46 <ski> so dynamic is then, making some webserver automatically generate the pages, possibly depending on run-time user input ?
08:02:03 <shapr> nah, dynamic is making the webserver generate the pages each time a user requests them.
08:02:13 <shapr> oh, I think that is what you said :-)
08:02:17 <shapr> in that case, yes!
08:02:21 <ski> yeah :)
08:04:20 * shapr sits in uffish thought
08:04:38 <ski> what's "uffish" ?
08:05:41 <shapr> @wn uffish
08:05:42 <betabot> No match for "uffish".
08:05:47 <shapr> @all-dicts uffish
08:05:48 <betabot> No match for "uffish".
08:06:02 <shapr> well, it's from Lewis Carrol, "The Jabberwocky"
08:06:09 <ski> ok
08:13:06 * shapr tries to build hws-wp
08:21:14 * Marvin-- tries to understand a proof generated by E
08:21:25 <Lunar^> shapr: I will be really happy the day I will do that on hOp :)
08:21:32 <shapr> me too!
08:21:44 <shapr> speaking of which, how's it going?
08:22:16 <Lunar^> I would like to have much much much time
08:22:56 <Marvin--> who doesn't
08:23:51 <Lunar^> shapr: After mangling a lot in the scheduler, I realised that I would need to have the RTS compiled with -DDEBUG
08:23:59 <Lunar^> shapr: That took quite some time
08:24:08 <Marvin--> (ordered (X1:(insert X4 X3))) == True  |  (head (insert X4 X3)) == (head X3)  |  (leInt X1 X4) /= True  |  (ordered (insert X4 X3)) /= True
08:24:29 <Lunar^> shapr: I also figured out that outb(0xE9, c & 0xFF) with c being a char displays it on bochs console
08:24:37 <shapr> neat
08:24:42 <Lunar^> shapr: Thus, I'm now able to debug the scheduler
08:24:50 <Marvin--> cool
08:25:51 <shapr> spiffy!
08:26:21 <Lunar^> Now I need some time to figure out why does my new state BlockWaitingInterrupts destroy everything
08:27:14 <Lunar^> Unfortunately, it seems that adding the debugging take enough time to keep the interrupt handler enough time, reproducing deadlocks will be hard
08:27:54 <shapr> :-(
08:28:28 <Lunar^> shapr: On the other side, I'm metting Emmanuel Chailloux ( http://www.pps.jussieu.fr/~emmanuel/ ) tomorrow
08:28:29 <Marvin--> that's usually the case when debugging such things
08:28:45 <Lunar^> Marvin--: Yeah... that's really disturbing
08:28:53 <shapr> c'est chouette
08:29:09 <shapr> author of the OCaml book
08:29:18 <Lunar^> shapr: Maybe he will have ideas on how I could get back in university
08:30:14 * Marvin-- swears
08:30:48 <Marvin--> this looks wrong
08:38:44 <Marvin--> no, wait, it's correct
08:38:46 <Marvin--> just...complex
08:38:48 * Marvin-- sighs
08:41:39 <Marvin--> now to figure out which of these *six* lemmas I actually need
08:43:09 <Marvin--> damn. most of them
08:43:25 * Marvin-- growls
08:45:45 <ski> proving a sorting alg. actually yields ordered output ?
08:45:51 <Marvin--> yeah
08:46:08 <Marvin--> trying to prove  ordered xs ==> ordered (insert z xs)
08:46:16 <Marvin--> I'm thinkin' I need more coffee
08:46:52 <ski> with the standard insert ?
08:47:07 <ski> (i.e. nothing fancy)
08:48:39 <Marvin--> nothing fancy
08:48:52 <Marvin--> I think the biggest problem is that I use the "optimized" ordered
08:49:26 <Marvin--> ordered (x1:x2:xs) = x1 <= x2 && ordered (x2:xs)
08:50:15 <ski> optimized, how ? not checking all transitive orderings ?
08:51:08 <Marvin--> the "simple" way is that (x:xs) is ordered if x is smaller than all elements in xs
08:51:17 <ski> right
08:51:47 <ski> simple, but inefficient (given that (<=) actually defines an ordering)
08:51:55 <Marvin--> exactly
08:52:16 <Marvin--> but the thing is that if you just have an implementation of <=, you have no idea whether it's an ordering or not
08:52:25 <Marvin--> (until you've proved it, that is)
08:53:13 <ski> can't you assume that you also have a proof of that, when proving the insert preserves orderedness ?
08:53:14 <keverets> but couldn't it be ordered in reverse?
08:54:18 <Marvin--> keverets: okay, the name is a bit misleading, it should probably be called  sorted  instead
08:55:21 <ski> isn't the ordering/sorting relative to <= ?
08:55:41 <ski> what's misleading ?
08:56:21 * shapr finds part of the problem with hws-wp
09:00:25 <keverets> whether it is ordered over <= or >=, it would still be ordered, no?
09:00:44 <ski> right
09:01:22 <ski> same with the word "sorted", no ?
09:01:30 <keverets> true.
09:02:16 <Marvin--> eh, whatever, you know what I mean
09:02:17 <Marvin--> I hope :)
09:02:54 <ski> mm
09:05:59 <shapr> yay, ScannedInAvian.org is being delivered here in 0.5 hour
09:07:04 <Igloo> Oh, does that mean it broke and you'll have to fi it and ship it back?  :-(
09:07:27 <shapr> well, not exactly 'ship'
09:07:54 <shapr> the guy who runs and owns my ISP is bringing it over in his car
09:08:17 <Lunar^> shapr: Cool
09:08:18 <shapr> so I think I can fix it and take it over to his house, and it'll be back online either tomorrow or the next day.
09:08:35 <shapr> yah, I want to get hws-wp running on it
09:08:40 <shapr> hopefully with dynamic halipeto
09:08:49 <Lunar^> hot stuff :)
09:09:14 <shapr> yah, I want a Haskell Web Application Server.
09:17:16 <shapr> http://www.haskell.org/hawiki/HaskellWebApplicationServer
09:19:43 <Etaoin>  would it be extended with haskell and do soem runtime compilation?
09:19:50 <shapr> yup
09:20:09 <Etaoin> neat
09:20:52 <shapr> hey Marvin--, any ideas about this? http://shapr.homelinux.net/~shae/hws-wp-error.txt
09:23:17 <Lunar^> shapr: For the first
09:23:28 <Lunar^> shapr: s/catchError/catch I think
09:23:38 <shapr> thanks, I'll try that.
09:24:02 <Marvin--> shapr: yeah, it was pretty confusing with ghc 5 which functions fit together with which
09:24:18 <Marvin--> that code is as likely to be Simon's as mine
09:24:42 * Marvin-- subtly tries to shift the blame ;)
09:26:21 <shapr> spiffy, that got rid of the first error
09:29:41 * Marvin-- wanders off to make dinner
09:40:07 <Igloo> "computer scientists commonly choose models with bottoms, but prefer them topless" (from Intro to Lattices and Order)
09:41:22 * Marvin-- groans
09:41:47 <Marvin--> that was horrible
09:42:47 * shapr grins
09:43:12 <shapr> aha, I was correct, I put a default=2 instead of default=0 in /boot/grub/menu.lst
09:49:55 * Marvin-- swears
09:50:02 <shapr> yah, me too
09:50:03 <Marvin--> no phone call from the hospital today either
09:50:21 <Marvin--> they were going to get back to me over some test results *yesterday*
09:50:32 <Heffalump> :-(
09:51:08 <Marvin--> hey Heff
09:55:04 <ski> hello esap
09:55:10 <esap> hello!
09:55:22 <esap> what's up?
09:55:42 <ski> just reading a blog, ATM
09:56:32 * esap never understood what's the thing in blogs. I never found useful information from any of the blogs :-)
09:57:25 <ski> useful ? who's talked about useful ? sometimes they are fun to read, though .. :)
09:57:52 <esap> heh ok
09:59:17 <ski> (esap : hmm, btw, have you seen "crazy calculations" with types ? :)
10:00:00 <esap> ski: depends on how crazy you mean. I've seen the C++ sizeof things [=very evil], for example.
10:00:33 <ski> no, i mean like taking square root of types, or computing derivatives of them
10:01:23 <esap> I know how to compute derivates, but square root might be interesting [is it related to modules?]
10:02:07 <ski> i'm not totally sure of how to do it generally. i've only seen one example, so far ..
10:02:50 <ski> (esap : so i guess you've seen Conor McBride's paper on derivatives, then ?)
10:03:17 <esap> I'm not sure I've seen that [...looking up...]
10:04:05 <ski> esap : a link is on http://www.dur.ac.uk/c.t.mcbride/old-home.html
10:04:09 * esap hates it that all google references to citeseer are broken :-)
10:04:35 <Marvin--> yeah, we ought to smack them
10:04:57 <ski> that is irritating, right
10:05:22 <esap> oh actually, I've seen that paper.
10:06:47 <ski> in the example, the square root is computed by binomial theorem
10:07:00 <ski> Si : hi again
10:08:06 <Si> hi
10:08:38 <esap> ski: I wonder how you would take logarithms of a type :-)
10:08:47 <ski> me too :)
10:08:54 * esap guesses it's recursion.
10:08:57 <ski> what type is e ?
10:09:28 <SamB> how hard can it be to make google rewrite a bunch of urls?
10:10:48 <esap> ski: if you have derivate, 'e' should be easy to compute from that.
10:11:06 <SamB> alternatively, you could yell at nec and get them to make the old domain name forward...
10:11:22 <ski> esap : hmm, perhaps
10:12:34 <ski> perhaps this can be related to the "exponential" unary connectives in linear logic
10:12:52 * Heffalump finds DBLP much better than Citeseer anyway. Though Citeseer keeps real documents.
10:15:07 <shapr> what's DBLP?
10:15:23 <Heffalump> http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sittampalam%3AGanesh.html for example
10:16:02 <shapr> neat
10:16:28 <Heffalump> much less stuff, but much higher quality in reference terms
10:21:33 <Si> is it possible to store polymorpic types in a Dynamic?
10:23:11 <Heffalump> yes
10:23:27 <Heffalump> oh. errm. I _think_ so, actually.
10:23:36 <Heffalump> you may need to wrap them up in some datatype
10:24:51 <Heffalump> 'lo
10:25:39 <kosmikus> hi ... without wrapping, I'd be very surprised if it was possible
10:27:16 <Si> I don't think it's possible, because I think typeable only types monomorphic types
10:27:51 <shapr> ircModuleState     :: FiniteMap String (IORef ModuleState)
10:27:53 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
10:28:05 <Heffalump> yeah, but uses an existential type, which is a little different
10:28:18 <Heffalump> do you have an example where the type being wrapped is
10:28:22 <Heffalump> data Foo a = ....
10:28:22 <Heffalump> ?
10:28:42 * shapr thinks
10:29:09 <Si> I don't think it would work anyway, because the data is ambiguous
10:29:21 <shapr> I don't think so.
10:29:30 <shapr> as in, there's nothing like that in lambdabot at least.
10:30:26 <shapr> greetz stepcut, wazzup?
10:30:46 <stepcut> not much... I am finally starting to figure out how to use arrows
10:30:56 <shapr> oh, I want to know!
10:31:55 <stepcut> I am specifically working on using arrows for stream processors
10:32:45 <stepcut> I have a grand vision of trying to use arrows (an possibly dynamic exceptions) to turn haskell into the ultimate unix 'shell' scripting language ;)
10:33:00 <Si> If I have a class C a, will functions working on values of type forall a . (C a) => Cons a be possible?
10:33:33 <Riastradh> stepcut, bah, just use scsh.
10:33:58 <stepcut> Riastradh: I certainly plan to steal good ideas from scsh
10:34:06 <shapr> stepcut: that sounds very cool
10:34:40 <stepcut> put some of the stuff I want to do involves 5% shell stuff and 95% stuff I would rather do in haskell 
10:35:00 <Riastradh> What would you possibly rather do in Haskell than in Scheme?
10:35:02 * Riastradh ducks.
10:36:14 <shapr> stepcut: silly question, but do you end up using any of this stuff for work?
10:36:22 <SamB> Riastradh: most things
10:40:49 <kosmikus> is there a nice English phrase or word for "to look right through something"?
10:41:02 <ski> Si : suppose so. at least if you wrap the polymorphic arguments (dunno if ghc currently supports that kind of higher-rank polymorphism. i.e. including constraints. well, i guess it does, but not sure)
10:41:50 <shapr> kosmikus: in what sense?
10:42:52 <shapr> "to see right a problem" means to fix it instantly, "to see right through someone" usually means to see that someone is lying
10:44:01 <kosmikus> it's a bit in the sense of "don't get confused by the syntax, it's just X that you already know"
10:44:14 <stepcut> shapr: yes!
10:44:19 <stepcut> shapr: all the time
10:44:28 <shapr> wow, awesome.
10:44:33 <stepcut> :p
10:45:25 <shapr> have you seen HsUnix?
10:45:32 <stepcut> it does not hurt that three most senior engineers (in terms of employment with the company) all prefer functional languages 
10:45:38 <shapr> nice
10:47:23 <shapr> stepcut: seen it? http://www.haskell.org//pipermail/haskell/2004-February/013540.html
10:47:25 <stepcut> I don't think I have seen this HsUnix yet, though I did see some similar things
10:49:13 <stepcut> this looks pretty nice -- especially if you speak german ;)
10:49:46 <shapr> truly
10:52:09 * opet pokes Matt-W 
10:53:09 * Matt-W pokes back
10:53:12 <Matt-W> hi opet
10:53:16 <Matt-W> hi shapr
10:53:32 <shapr> greetz Matt-W
10:55:20 <opet> shapr: hm.. I have images of scaring people quite badly with scripts written with that :)
10:55:48 <shapr> with HsUnix? or with arrows?
10:56:00 <shapr> I think using arrows in shell scripting would quite rightly scare a lot of people.
10:56:09 <opet> that hsunix whatsit
10:56:18 <shapr> and thrill anyone not in that first lot
10:57:20 <shapr> I wanted to use HsUnix for something yesterday, but it doesn't have a call that returns the inode of a file.
11:00:25 <stepcut> you don't need hsunix for that...
11:01:54 <stepcut> liftM fileID (getFileStatus "/tmp") >>= putStrLn . show
11:02:18 <stepcut> (import System.Posix.Files and Control.Monad)
11:03:06 <stepcut> I think this HsUnix thing will be a good complement to what I want to do
11:04:09 <stepcut> My arrow stuff would (in theory), beef up the redirecting stdout/stderr section
11:05:40 <Si> ski; did you have anymore thoughts on my problem; I think I'm going to leave it as the unmarshal/getIORef/unmarshal method atm
11:06:40 <Riastradh> shapr, it has no stat?!
11:10:19 <ski> Si : hm
11:13:08 <stepcut> Riastradh: makes sense to me, the ghc standard libraries have a perfectly usable stat
11:14:06 <liiwi> good evening
11:16:38 <ski> Si : we'd prolly want a way to incrementally define unmarshal' ..
11:19:24 <ski> Dynamic -> exists a. (a,TypeRep a)
11:19:28 <ski> hm
11:34:37 <ski> yay, Joachim Durchholz' Survey on Marshalling in Functional Programming Languages is online !
11:35:52 <Heffalump> lol at http://news.bbc.co.uk/1/hi/uk/3545679.stm
11:37:19 <ski> heh
11:37:37 <Si> there a PDF or PS anywhere?
11:38:56 <ski> the survey ?
11:40:14 <Si> yes
11:40:34 <ski> HTML at http://durchholz.org/jo/fpl-marshalling-survey/index.html :)
11:41:23 <Si> thankyou
11:41:57 <ski> there was a lot of discussion on usenet for some while ago
11:42:19 <Si> all I see under Haskell is no and failure
11:42:28 <ski> (where he posted several versions of the survey)
11:43:20 <ski> Implementaion Interoperability : Yes
11:45:27 <Si> ah yes
11:46:56 <shapr> hey skew, wassup?
11:48:01 <shapr> what happened with the exception / error split in ghc6?
11:48:12 * shapr is still staring at hws-wp
11:48:14 <skew> hi shapre
11:48:18 <skew> hws?
11:48:28 <shapr> haskell web server - with plugins
11:48:31 <shapr> http://shapr.homelinux.net/~shae/hws-wp-error.txt
11:48:45 <shapr> once I get past that error, I think hws-wp will work with ghc6.2
11:49:04 <Si>  I got HWS-WP working with Haskell
11:49:09 <Si> it's great
11:49:12 <skew> I think it's something about a different Exception being declared in the preulde and in Data.Exception
11:49:16 <shapr> tell me more :-)
11:49:53 <Si> It's damned hard getting CGI to work, but I now I even got PHP working via CGI
11:49:59 <shapr> wow
11:50:05 <shapr> I wanna know how you fixed that error
11:50:17 <shapr> I'm the supposed maintainer of HWS-WP, I'd like to update it.
11:50:20 <Si> Can't remember the answers on the web, want tbz2?
11:50:25 <shapr> yes please!
11:50:31 <skew> I'd like one too.
11:50:44 <shapr> I'm hoping to make Halipeto a runtime plugin
11:50:52 <shapr> I'd also like to add Hampus Ram's smart loader
11:51:12 <shapr> http://www.haskell.org/hawiki/HaskellWebApplicationServer
11:51:15 <shapr> that's where I'm going
11:51:27 <shapr> expect release 0.1 sometime in the next five years :-P
11:52:19 <shapr> Marvin-- is the author of hws-wp, though he often denies all knowledge of it.
11:52:32 <Si> give me a minute, I'm using HWS-WP (hopefully) to power my iop project
11:52:41 <shapr> spiffy, what's your iop project?
11:53:07 <Marvin--> I can't very well take credit for the whole thing, I built it on Simon's HWS
11:53:07 <shapr> iiop?
11:53:25 <shapr> but you added the runtime loader, and the apache-style hooks
11:54:09 <Marvin--> I wonder where showIOError is from
11:54:10 <Si> I'm building an interoperation framework for Haskell
11:54:16 <shapr> what does it do?
11:54:21 <Si> not much atm
11:54:25 <Si> the SOAP client works
11:54:26 <shapr> Marvin--: doesn't seem to be in 6.2
11:54:33 <shapr> ooh, you have a SOAP client?
11:54:39 <shapr> I want!
11:54:51 <shapr> well, if it's a DFSG compatible license, I want :-)
11:54:57 <Si> can't have, it belongs to my University atm
11:55:01 <shapr> fooey
11:55:09 <Si> but it is GPL
11:55:17 <shapr> that's good to hear
11:55:20 <Si> so you'll be able to have it in a few months
11:55:26 <shapr> spiff
11:55:37 * shapr quickly adds SOAP to list
11:55:58 <skew> shapr, did you think of anything else for a library for making servers?
11:56:14 <Marvin--> shapr: I can't find the damn function in ghc5 either
11:56:48 <shapr> skew: yes, but I don't know how to describe it exactly
11:56:52 <Si> What I plan on creating is an application container called HAC which in concert with HWS-WP will (somewhat like Tomcat) allow servlets and interop applications to be run
11:56:53 <Marvin--> maybe it's defined in the hws source?
11:56:56 <shapr> lemme get an url for you
11:56:57 <shapr> Marvin--: could be
11:57:04 <Si> shapr, did you get my DCC?
11:57:06 <skew> I'm just about to propose some sort of project about declarative specification of distributed systems and Haskell.
11:57:15 <shapr> skew: that's pretty much what I want
11:57:22 <shapr> Si: sorry, I don't DCC in this elisp client
11:57:33 <shapr> what about sendfile/SAFT or email?
11:58:00 <Si> email addy?
11:58:08 <skew> it's pretty easy to describe a state machine, and put IO actions on the transitions, but where to go from there isn't quite clear
11:58:34 <shapr> Si: user shae, host  scanned in avian dot com
11:59:04 <shapr> skew: http://www.ee.oulu.fi/research/ouspg/protos/analysis/VTT2001-functional/index.html
11:59:30 <shapr> various interesting stuff here: http://www.ee.oulu.fi/research/ouspg/protos/index.html
11:59:40 <Si> run that past me again?
12:00:00 <shapr> since this channel is logged, I try not to write it literally
12:00:08 <shapr> I get enough spam already
12:00:10 <Si> ah
12:00:13 <shapr> username is shae
12:00:18 <shapr> host is scannedinavian dot com
12:00:28 <Si> oic
12:00:32 <liiwi> squish
12:00:39 <skew> thats a horrible pun!
12:00:46 <shapr> thank you!
12:00:48 <Marvin--> shapr: right, showIOError is defined in ErrorLogger.hs
12:01:01 <liiwi> pun! pun! pun! good pun!
12:01:04 * shapr grins
12:01:54 <Si> I *think* I got rid of all my munge out of it, but you might wanna check...
12:02:01 <shapr> skew: thing is, the tool described in that thesis creates a 'BNF for a protocol' where all of the states can be wiggled
12:02:10 <Si> I hadn't really started trying to integrate it with anything yet...
12:02:32 <Si> Oh except I altered it to make it read the HTTP incoming body because it wasn't...
12:02:32 <shapr> as I understand it, that's the tool that found the decades old hole in ASN.1
12:02:40 <Si> which is kinda useless for SOAP and XMLRPC
12:02:43 <skew> ah. I read the abstract, and thought the AG bit was the only thing that might possibly be useful :)
12:03:27 <shapr> another useful thing I've noticed from that tool, I think QuickCheck should have 'anti-tests' as well.
12:03:37 <skew> well, relevant. It sounds like QuickCheck for servers, which would be good to have.
12:03:41 <Si> btw, I noted that someone created a libz binding? Is it easy to use?
12:04:02 <shapr> an anti-test is, for all illegal inputs, the code should return an error
12:04:13 <Marvin--> shapr: I think you should just get rid of the IOException constructor
12:04:30 <Marvin--> catchJust ioError :: IO a -> (IOError -> IO a) -> IO a, so...
12:04:33 <shapr> just "(\e@( io) -> " ?
12:04:48 <Marvin--> and type IOError = IOException at least in ghc 6.2
12:05:31 <Marvin--> right, I don't quite understand the ghc version ifdefing there
12:05:53 <shapr> skew: that tool was used to break nokia's phones and centers quite thoroughly.
12:06:06 <Si> shapr: did you get that?
12:06:39 <skew> a test like that should be easy if your function treats errors with Either or Maybe, and a combinator should take care of testing with exceptions.
12:06:40 <shapr> I got it, thanks!
12:07:08 <skew> the hard part is coming up with the idea in the first place, of course.
12:07:11 <shapr> anyways, I realized that most software testing only tests for correct outputs when you have correct inputs.
12:07:22 <Marvin--> right, in ghc5 IOError = Exception, in ghc6, IOError = IOException
12:07:24 * Marvin-- sighs
12:08:14 <Marvin--> so I guess you'd want the version test to be, for ghc < 409 or ghc >= 600 (just guessing), use \e@io, and for whatever's in between, use \e@(IOException io)
12:08:34 <Marvin--> this kinda...sucks
12:08:35 <shapr> I was thinking, "delete compat code for < ghc6"
12:08:49 <Marvin--> that's another way of doing it, and I think it would be saner
12:09:16 <skew> what about using catchIOException?
12:09:30 <shapr> well, it compiles without error now
12:09:42 <shapr> eek
12:10:03 <shapr> oh, runtime_loader has hardcoded path, suck.
12:10:23 <Si> it really needs some work
12:10:28 <Marvin--> catchIOException?
12:10:57 <Si> e.g. I think the plugin system should be overhauled
12:11:02 <skew> Well, make a catchIOException ifdefed in some library. (catchJust ioErrors) for GHC6
12:11:02 <shapr> I agree
12:11:13 <shapr> Si: hampus ram has a smarter dynamic linker
12:11:20 <Si> I know I use it
12:11:20 <Marvin--> skew: ah
12:11:24 <shapr> ah, ok then
12:11:37 <Si> I expanded it though to use several modules compress in a tbz2
12:11:42 <shapr> sounds like you know more than I do
12:11:44 <shapr> ohh, I want that too
12:11:47 <Si> with a meta file and other stuff if required
12:11:59 <shapr> awesome! har files!
12:12:04 <Si> exactly
12:12:30 <Marvin--> har har
12:12:33 <Si> along with an application container you've got Haskell Servlet and a vast amount of possible interoperation
12:12:33 <shapr> oy
12:12:34 <shapr> @arr
12:12:34 <betabot> Prelude.(!!): index too large
12:12:41 * shapr smacks betabot 
12:12:44 <Marvin--> haha
12:13:00 <shapr> Si: great, where do I sign up?
12:13:02 <Marvin--> betabot: tsk tsk, fence errors
12:13:02 <betabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:13:13 <shapr> I know what the bug is, I wrote it myself!
12:13:39 <skew> Si: What's that Haskell Servlet?
12:13:41 <Si> The problem is atm my plugin system uses gzip and tar from the command line
12:14:00 <Si> But I think someone has binded libz
12:14:20 <shapr> I think Igloo did, yah?
12:14:45 <Si> anyway it may work better that way
12:15:11 <skew> Hmm. Is there any opaque type for lazy streams of binary data?
12:15:16 <Si> The plugin system does do backward chasing yet though, so I'd wait a bit
12:15:28 <shapr> backward chasing?
12:15:41 <shapr> are you doing this as a PhD project?
12:15:49 <skew> That is, a replacement for threading String around that allows for buffering, and carrying the data in PackedString and so on.
12:16:42 <Si> nah
12:16:43 <skew> I was just thinking something like that might be good for passing binary data sround.
12:16:48 <Si> it's my third year project
12:16:51 <shapr> oh, neat
12:17:16 <shapr> skew: that would be handy
12:17:29 <shapr> it'd have the good points of both String and PackedString
12:17:38 <Si> it started as simply webservices in Haskell, but I figured I could create a much broader infrastructure for hot pluggable interop protocols
12:17:43 <Si> and so HAIFA was born
12:17:54 <Si> or the conception there of anyway
12:18:05 <skew> I'm thinking of doing webservices.
12:18:30 <shapr> me too
12:18:42 <shapr> bring already did some.
12:18:48 <shapr> he wrote XmlRpc
12:18:53 <skew> I'm organizing my project under a grad student who did something roughly similar in spirit.
12:19:04 <skew> but he uses XSLT as his functional language!
12:19:07 <shapr> eek
12:19:24 <shapr> I'm organizing my project under the heading of "get paid to write Haskell"
12:19:52 <skew> that would be nice.
12:20:07 <skew> get some jobs out there by the time I graduate, okay :)
12:20:25 <shapr> if there are workable web services in Haskell, I think there will be jobs.
12:20:52 <shapr> I know I'll do my best to port my clients from Zope to something Haskell when possible.
12:20:58 <Riastradh> shapr, that didn't work with Scheme; there are definitely Scheme web services out there, but you don't hear much about Scheme jobs...
12:21:28 <Si> fitting SOAP into Haskell is a horrible job though
12:21:38 <Si> 95% is dead easy
12:21:51 <Si> the remaing 5% is virtually impossible
12:21:56 <shapr> most of my clients don't care what language/platform/etc is used, as long they have a nice user interface inside msie/netscape
12:22:15 <skew> what part is hard?
12:22:20 <Si> references
12:22:23 <Si> *Shudder*
12:22:42 <Si> they utterly mess up your data structures
12:22:49 <shapr> that's the part you've been fighting for the last few days, yah?
12:22:55 <Si> yup
12:22:59 <shapr> have you considered asking on haskell-cafe?
12:23:14 <skew> where in the spec is that described?
12:26:05 <Si> look at section 5.2.1
12:26:26 <skew> of Part1?
12:26:41 <Si> now they _look_ perfectly harmless, until you realise that elements can have both ids and references
12:26:50 <Si> I'm looking at SOAP/1.1 not 1.2
12:26:55 <Si> I haven't got that far yet
12:27:02 <Si> probably won't on this project
12:27:34 <Si> btw. how implemented XMLRPC?
12:27:53 <Si> who rather
12:28:31 <skew> what happens if they have both?
12:29:09 <Si> you get theoretically infinately recursive reference structures
12:29:33 <Si> i.e. one element references an element that references it
12:29:42 <skew> Bjorne Bringert. bringert.net
12:30:22 <skew> well, Bj√∂rne.
12:30:56 <shapr> aka bring on #haskell
12:31:25 <Marvin--> Bj√∂rn ;)
12:31:50 * Marvin-- points out bring to skew
12:31:57 <Si> excellent that's one less thing for me to do, I just have to integrate it into HAIFA
12:33:34 <skew> What was the problem with these references?
12:33:42 <skew> taking infinite structures on the Haskell side and folding them up?
12:34:02 <shapr> Si: will you be integrating Halipeto also?
12:34:24 <skew> I thought Halipeto generated static HTML?
12:34:36 <shapr> it does
12:34:40 <shapr> but I don't see why it has to.
12:34:54 <skew> Oh. right.
12:35:21 <skew> Is there a recent HSP preprocessor around?
12:35:41 <shapr> I think hampus is working on one, but I'm not totally sure of that.
12:35:41 <Si> I dunno, it depends how much time I have, I've only got 6 weeks left of programming time, I've already got WSDL looming
12:36:15 <shapr> how much time have you spent on it so far?
12:36:22 <skew> Si, is the problem that you might have a circular reference that never hits an actual string?
12:36:51 <Si> no, I can create the references easily
12:37:13 <Si> I can do it by expanding the tree if needby and relying on lazy evaluation
12:37:35 <Si> but if you do it that way you end up with a static structure and you don't know what refers to what
12:38:08 <skew> these strings should end up mutable?
12:38:41 <Si> it isn't just strings
12:39:00 <Si> a reference can point to any other element that has an id
12:39:23 <Si> wherever it is in the tree
12:40:33 <skew> I don't see a problem yet...
12:42:04 <skew> if you want to preserve the reference structures you can use strings and indirect through an index of named nodes
12:42:09 <Si> if you have an infinately recursive tree like that, how are you going to do transforms on it?
12:43:08 <skew> if your transformation doesn't read infinitely deep down the tree it should make a result.
12:44:06 <YveDeLarc> re
12:44:09 <Si> lets say you have two entities a and b, both of which refer to c
12:44:16 <skew> Just like working on any infinite data structure. If you want to pass back a cyclic structure I think the Haskell code would need to explicitly describe the graph stucture.
12:44:38 <Heffalump> Si: what uni are you at?
12:44:53 <skew> or anything with sharing for that matter, unless you want to mess around with pointer equality. But please continue
12:45:16 <Si> I'm at Sheffield University
12:45:48 <Si> If you then lazily expand out that tree you'll get two entities c1 which a points to and c2 which b points to
12:45:59 <Si> if you change c1, c2 remains unchanged
12:46:02 <Heffalump> is Haskell part of the syllabus?
12:46:11 <Si> yes
12:46:57 <skew> if these are being mutable at all, they are some *Ref. Give me a minute and I'll code up an example of what I'm saying
12:47:00 <Heffalump> what year?
12:47:11 <Si> 2
12:47:22 <skew> Haskell is used in the second year?
12:47:24 <Heffalump> cool.
12:47:30 <Heffalump> it's more common than I thought :-)
12:47:46 <Si> http://www.dcs.shef.ac.uk/teaching/modules/level2/index.html
12:48:02 <skew> My school uses Scheme for CS1 and recently switched to Java for CS2 from Modula3 (a better language, I think)
12:48:38 <Si> there are are two courses on Haskell one in the first, and one in the second semester
12:49:01 <Si> I'm the only person doing a project in pure Haskell though :(
12:49:58 <Si> I could be utterly wrong skew, I hope I am but I just don't see how a structure with references can be stored and muted in a static tree
12:49:58 <skew> I would like to see Haskell used somewhere, but I don't know how to arrange that
12:50:36 <Heffalump> si: well, you could do everything in ST or IO
12:50:43 <Si> I am
12:50:43 <Heffalump> in which case there's no problem
12:50:45 <skew> Okay, I'll get back to coding. I think lazy indirection throught the final map of results, plus fixIO should do it.
12:50:53 <Si> but it's ugly
12:50:54 <Heffalump> then you can use STRef/IORef in your tree.
12:50:59 <Heffalump> Not too pleasant, though.
12:51:10 * Heffalump flips through scrollback
12:51:35 <Si> all values have to be of Value a = Val a | Ref (IORef a) | NullVal
13:24:32 --- topic: set to 'new' by liiwi
13:24:37 <liiwi> euh
13:24:45 <liiwi> sorry
13:25:01 <liiwi> sorry
13:25:14 <liiwi> don't have the topic on my buffer
13:25:18 * liiwi blushes
13:27:20 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Learning Haskell - http://www.haskell.org/learning.html","deb http://www.syntaxpolice.org/haskell-experimental unstable/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","citeseer now @ http://citeseer.ist.psu.edu/","<shapr> no, I am NOT a bot!"]' by Marvin--
13:27:40 * Marvin-- pats liiwi's head
13:27:44 <liiwi> thanks
13:45:35 <skew> Si, I've got some code
13:51:25 <skew> I've tried to keep the parts of the computation relatively separate.
14:02:19 <Si> thankyou
14:02:38 <Si> sorry, can you send it again
14:03:27 <skew> building the cyclic structure and making the cells mutable is totally separate
14:03:41 <skew> the lazy indirection through a finite map can be mind-blowing, I suppose
14:04:38 <skew> Have you heard the joke about grocery shopping in Haskell?
14:04:48 <Si> if it works I am obliged to mention you in my references now :)
14:05:06 <skew> I don't use your data types, but it seems to work
14:05:18 <Si> no, I didn't hear that one
14:05:53 <skew> To shop for groceries in Haskell-land, append an item to yesterdays shopping list and check the unevaluated portion of yesterday's shopping bag
14:06:04 <Si> lol
14:06:16 <Si> so this thing does in fact use IORefs
14:06:32 <skew> I use IORefs to make the state mutable, as you seem to want
14:07:08 <skew> it's unrelated to making the tree circular
14:08:32 <Si> I'm just trying to make sure I can mimic Java's reference behaviour
14:09:02 <skew> If you want to be able to make a refernce point elsewhere you will need to use IORefs there too
14:09:30 <skew> I'm just making the right (functional) reference structure with the map, and putting a mutable value at each node
14:10:03 <Si> hmmmm
14:10:12 <Si> I'll have to think about this some more
14:11:27 <skew> I haven't looked at SOAP. Is the situation that Haskell is supposed to process an incoming node graph thing?
14:11:32 <Si> ok well thanks for your help, I'll have to look at this code tommorrow its late
14:11:50 <Si> kind of
14:12:22 <Si> You get a tree where each branch is a parameter
14:12:42 <Si> and each sub-branch is an attribute of those parameters
14:12:53 <skew> okay
14:13:07 <Si> then you have to convert each of these to an equivelant data structure in Haskell
14:13:53 <skew> That's about what I thought.
14:13:57 <Si> does your method assume every value is an IORef?
14:14:05 <skew> nope
14:14:33 <skew> I tried to make it clear in the code that building a graph with the specified structure was completely separate from the choice of values
14:14:51 <skew> with types like fixItems :: [Item ref a] -> Tree a
14:15:08 <skew> but this sort of thing is pretty hard to present clearly
14:15:34 <skew> Mostly I just put in IORef everywhere to make it clear that the nodes were actually being shared as desired
14:17:18 <skew> I would expect Haskell processing to be mostly functional anways.
14:17:42 <skew> I doubt I would even often want to IORef around the values, but it shouldn't be hard to provide lots of choices.
14:18:28 <Si> ok, I'll look at it properly tommorrow, thanks for the help
14:18:41 <skew> you're welcome. Bye
14:47:11 <Pseudonym> Greetings.
14:47:15 <skew> Hi
14:47:26 <Pseudonym> Well, shapr is still here, so I guess he wasn't deported.
14:47:37 <skew> deported?
14:48:06 <Pseudonym> Long story.
14:51:52 * Pseudonym yawns
14:51:59 <Pseudonym> Caffeine not reached bloodstream yet.
14:52:17 <skew> I know how that goes.
14:52:33 <skew> where are you?
14:52:47 <skew> morning? midnight?
14:52:51 <Pseudonym> Morning.
14:52:58 <Pseudonym> Melbourne, Australia
14:53:11 <skew> Ah. that time of day.
14:53:19 <skew> Written anything interesting lately?
14:53:37 <Pseudonym> Kinda.
14:53:54 <Pseudonym> Not in Haskell, unfortunately.
14:54:19 <skew> I wrote up an example of lazy indirection through a FiniteMap.
14:54:34 * Marvin-- rolls his eyes at algernon
14:54:55 <Pseudonym> Oh, you mean the knot tying-type stuff?
14:54:57 <Pseudonym> Cool.
14:55:38 <skew> Yeah, I think that's my favorite. Si was trying to read some sort of XML graph thing for SOAP, and was wondering how to get the references
14:55:42 <Pseudonym> Lazy indirection is actually a specific case of memoing.
14:55:56 <skew> Really?
14:55:59 <Pseudonym> Sure.
14:56:04 <skew> I don't think this case is
14:56:07 <Pseudonym> You're memoing parts of a potentially infinite structure.
14:56:57 <Pseudonym> If you think about a graph, for example, you can consider it two ways.
14:57:04 <Pseudonym> In one sense, it's a circular data structure.
14:57:09 <Pseudonym> In another sense, it's an infinite tree.
14:57:34 <Pseudonym> The circular view is just the infinite tree view memoed.
14:57:40 <skew> I guess so. It still needs to be lazy memoizing, though
14:57:46 <Pseudonym> Sure it does.
14:57:49 <Pseudonym> http://haskell.org/hawiki/MemoisingCafs
14:58:05 <Pseudonym> The techniques there and the techniques for lazy indirection are basically identical.
15:00:12 <skew> The way I think about it memoization is an application of lazily constructed structures
15:00:50 <Pseudonym> Sure.  It's a small world and all these things are related.
15:00:52 <Pseudonym> :-)
15:02:53 <skew> Just one more thing that makes other languages seem constraining
15:03:02 <Pseudonym> :-)
15:03:26 <skew> You know you're in trouble when Python seems inflexible
15:03:37 * Pseudonym laughs
15:03:44 <Pseudonym> It's funny 'cause it's true.
15:04:09 <Pseudonym> There are really only two places in Haskell where I keep hitting my head against some kind of ceiling.
15:04:40 <Pseudonym> One is that type classes are a bit rough around the edges.
15:04:53 <Pseudonym> You can't, for example, control whether or not they are exported from a module.
15:05:19 <Pseudonym> I think that's a fault in the module system, though.
15:05:26 <Pseudonym> Actually, Haskell's module system is basically crap.
15:05:40 <Pseudonym> That's the real issue. :_)
15:05:42 <skew> Is exporting the type class really a problem?
15:05:59 <skew> At least as long as it's internally associated with the module, and you can control export of members?
15:06:02 <Pseudonym> From an engineering point of view, I want to keep my interfaces and implementations very clean.
15:06:29 <Pseudonym> Anyway, it's a module system problem, not a type class problem.
15:06:36 <Pseudonym> What I want is ML-style instantiable modules.
15:07:00 <Pseudonym> The second problem where I keep hitting my head is that there isn't very good support for component-style programming.
15:07:13 <Pseudonym> It's there, but it's not very good.
15:07:19 <skew> some way to manage multiple instances would be good
15:07:54 <Pseudonym> I want a decent way to program Haskell in the same way that you program Erlang.
15:08:04 <skew> How is that?
15:08:15 <Pseudonym> Do you know about Erlang?
15:08:24 <skew> vaugely. I've never learned it
15:08:39 <Pseudonym> It's a functional language, but the major abstraction is the "process".
15:08:39 <skew> dynamic types and loads of concurrency, that's all I know
15:08:47 <Pseudonym> Right.
15:09:01 <Pseudonym> See, where you would use an "object" in Java or Smalltalk, you use a "process" in Erlang.
15:09:22 <Pseudonym> And all "methods" are basically IPC.
15:09:33 <skew> and in Haskell you use a record of functions in IO sharing some IORefs, I suppose
15:09:58 <Pseudonym> That's one way.  Another is to use channels or Haskell ports.
15:10:10 <skew> ports?
15:10:22 <Pseudonym> http://www.cse.unsw.edu.au/~chak/haskell/ports/
15:10:53 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/hashtable/
15:10:56 <Pseudonym> Also check that out.
15:11:23 <Pseudonym> I implemented that just to see how clean I could make a component.  The amount of boilerplate is horrible, IMO.
15:12:09 <Pseudonym> Now admittedly, that hash table implementation is "more concurrent" than it needs to be.
15:13:47 <Pseudonym> But still, it ain't pretty.
15:13:59 <Pseudonym> I really should rewrite it using mutexes.
15:14:01 <Pseudonym> Just to see.
15:14:50 <skew> it looks like you need some sort of library here
15:14:58 <Pseudonym> Yeah, it kinda does.
15:15:15 <Pseudonym> To use a channel, you need to marshal and demarshal "methods".
15:15:15 <skew> It might take templates, unless you can change that message type
15:15:23 <skew> rather, eliminate that message type
15:15:34 <Pseudonym> Of course, there's no reason why you can't stuff functions down a pipe.
15:15:53 <Pseudonym> But getting the return value back isn't pretty.
15:15:57 <Pseudonym> Oh, hang on...
15:16:02 <Pseudonym> Oh, let me try that.
15:22:22 <skew> why do want to make everything a process communicating through channels?
15:24:51 <skew> you could use forkIO to asynchronously execute a function
15:25:03 <skew> I don't know about getting values back there either.
15:25:37 <Pseudonym> Well, I don't want to make everything a process necessarily.
15:25:53 <Pseudonym> What I want is to have components.
15:26:26 <skew> what do you want them to do?
15:27:11 <skew> rather, what sort of components do you want?
15:28:47 <Pseudonym> @foldoc component
15:28:48 <betabot> *** "component" foldoc "The Free On-line Dictionary of Computing (27 SEP
15:28:48 <betabot> 03)"
15:28:48 <betabot> component
15:28:48 <betabot>      
15:28:49 <betabot>         <programming> An {object} adhering to a {component
15:28:51 <betabot>         architecture}.
15:28:53 <betabot>      
15:28:55 <betabot>         (1997-11-20)
15:28:57 <betabot> [2 @more lines]
15:29:03 <Pseudonym> @foldoc component architecture
15:29:06 <betabot> *** "component" foldoc "The Free On-line Dictionary of Computing (27 SEP
15:29:06 <betabot> 03)"
15:29:06 <betabot> component
15:29:07 <betabot>      
15:29:09 <betabot>         <programming> An {object} adhering to a {component
15:29:11 <betabot>         architecture}.
15:29:13 <betabot>      
15:29:15 <betabot>         (1997-11-20)
15:29:17 <betabot> [16 @more lines]
15:29:19 <Pseudonym> @foldoc "component architecture"
15:29:21 <betabot> *** "component architecture" foldoc "The Free On-line Dictionary of Computing
15:29:23 <betabot> (27 SEP 03)"
15:29:25 <betabot> component architecture
15:29:27 <betabot>      
15:29:29 <betabot>         <programming> A notion in {object-oriented} programming where
15:29:31 <betabot>         "components" of a program are completely generic.  Instead of
15:29:33 <betabot>         having a specialised set of {methods} and {fields} they have
15:29:35 <betabot>         generic methods through which the component can advertise the
15:29:37 <betabot> [10 @more lines]
15:29:39 <Pseudonym> @more
15:29:39 <betabot>         functionality it supports to the system into which it is
15:29:41 <betabot>         loaded.  This enables completely {dynamic loading} of
15:29:43 <betabot>         {objects}.  {JavaBeans} is an example of a component
15:29:45 <betabot>         architecture.
15:29:47 <betabot>      
15:29:49 <betabot>         See also {design pattern}.
15:29:51 <betabot>      
15:29:53 <betabot>         (1997-11-20)
15:29:55 <Pseudonym> That's what I mean. :-)
15:29:56 <betabot>      
15:30:05 <skew> I don't think it matters so much that it be dynamic
15:30:39 <Pseudonym> No.
15:30:43 <skew> in the introspection sense
15:30:53 <Pseudonym> The important part is that it's a "thing" sitting in the system which I can access.
15:31:06 <Pseudonym> Moreover, I don't need to know its concrete type.
15:31:28 <skew> You could define a type class for the opertaions of a particular interface
15:31:32 <Pseudonym> Ane even moreover, I can program by making connections between components.
15:32:48 <Pseudonym> The important point of components is that I want to separate producers from consumers.
15:33:31 <skew> what sort of things are being produced and consumed?
15:33:52 <Pseudonym> I want my program to be a (possibly huge) dynamically modifiable dependency graph.  Make a change, and everything else gets updated.
15:34:21 <skew> I've seen something like that for O'Caml
15:34:27 <Pseudonym> Right.
15:35:08 <skew> building that on a component system would require each component have special logic for handling an incremental change of some input
15:35:49 <Pseudonym> Sure, but that's up to the component.
15:36:02 <Pseudonym> See, I think this is the most sensible way to build interactive applications.
15:36:11 <skew> If your goal is the dynamic update, there are more direct things you can do
15:36:17 <Pseudonym> Fudgets does this quite well, built on top of arrows.
15:36:40 <Pseudonym> However, there is a fatal flaw: Arrows don't support _modifying_ the dependency graph cleanly.
15:37:43 <skew> Oh, back to here. I've got an idea
15:39:17 <skew> first, figure out how to make the sort of graph you want. Communicating processes might do it, if you can reroute the channels.
15:40:00 <skew> next, make your arrow that is executed by turning it into that sort of stuff (might be a bit tricky to turn nested tuples into separate channels - ask Oleg for type class magics)
15:40:47 <skew> if that's possible make a combinator that takes a function from a modifiable controll graph to an arrow, and executes it.
15:41:59 <skew> the combinator passes the reference so you can get the graph inside the arrow structures, to allow your button or whatever to make changes.
15:44:32 <Jerub> shapr: they're getting an OH&S guy in to look at my workarea.
15:44:39 <skew> an arrow taking a nested either type seems like a reasonable model of a component, if you don't have to build the Either type yourself
15:45:16 <Pseudonym> Interesting.
15:45:30 <Pseudonym> There may be a way to mix arrows and channels/ports, incidentally.
15:46:02 <Pseudonym> The trouble is, once you've built an arrow graph, you can't modify it.
15:46:04 <skew> If what I suggested is possible at all it would be a relatively clean interface.
15:46:11 <Pseudonym> You effectively have to rebuild it.
15:46:20 <skew> That depends how you build it.
15:46:39 <skew> I'm thinking of things like the arrow parsers, where an arrow value is some sort of data structure
15:46:52 <Pseudonym> OK, you can always build _around_ an arrow graph.
15:47:11 <skew> and when you go to run it something does a whole lot of rebuilding and analysis to turn the thing you described into something that can be run.
15:47:48 <skew> I think if you can make a flexible graph thing at all, you can probably have an arrow where arrow values are translated into that dynamic graph before anything actually executes
15:48:27 <skew> Think of it as data, like the monads in HSQL, to be analysed and transformed, rather than executed.
15:49:29 <Pseudonym> Hmmm.
15:49:33 <Pseudonym> I'll have a think about it.
15:49:48 <Pseudonym> It may well just be that there isn't a decent library for this sort of thing yet.
15:49:54 <skew> Is there a recent release of Fudgets somewhere?
15:51:18 <skew> the "latest release" on the page at chalmers says it works with the latest GHC 5.02
15:53:59 <Pseudonym> Google will know. :-)
15:54:03 <Pseudonym> Ah.
15:55:46 <skew> "Before compiling, check that you have the following program in your path: ghc-2.01"
15:56:04 <Pseudonym> Eek!
15:56:12 <Pseudonym> Not encouraging.
15:56:31 <skew> that's old documentation, I think it really wants 5.02. At least something with ccall.
15:56:52 <Cale> http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/dist.html was apparently updated  9 Jan 2004 
15:57:20 <Cale> actually, it looks somewhat like the whole site got touched at that point
15:58:00 <skew> none of the tarballs are newer than august 2003
16:06:01 <skew> Pseudonym: If you come up with a good technique for making dynamic graphs in Haskell I would be interested too.
16:06:33 <skew> I will soon by writing a system for describing distributed computations, and being able to support dynamic topologies would be nice.
16:07:34 <Pseudonym> I checked in two more hash table implementations, though it's not on the web-based CVS yet.
16:07:49 <Pseudonym> One which passes functions down the wire and one which uses mutexes.
16:12:23 <skew> how do you pass around functions (while CVS builds)?
16:12:46 <skew> The mutex version is just lighter locking?
16:12:57 <Pseudonym> Concurrent.Channel doesn't care what is passed down it.
16:13:05 <Pseudonym> So long as it's all the same type.
16:13:07 <Pseudonym> So pass functions.
16:13:09 <skew> yeah, but how do you structure your component around that?
16:13:34 <Pseudonym> Well, it means that you can implement "methods" on the component by simply passing it the method as a function.
16:14:08 <skew> so you pass an arbitrary function along the channel and it gets to munge the state?
16:14:14 <Pseudonym> My mutex modules is actually pretty trivial.
16:14:31 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/Unstable/Ajb/Concurrent/
16:14:32 <Pseudonym> Yes.
16:14:53 <Pseudonym> And if you need to pass a value back, pass an MVar and wait for it to be filled.
16:15:18 <Pseudonym> The mutex solution doesn't need MVars.  (Except to implement the Mutex, though you could just as easily use semaphores.)
16:18:04 <skew> they are apparently not in the public CVS either
16:18:18 <Pseudonym> Well I did check them in.
16:18:20 <skew> well, where did you put them? libs/hashtable?
16:18:34 <skew> maybe I grabbed the wrong part. I've also got Unstable/Ajv
16:18:52 <SyntaxLaptop> can anyone find hudak's paper: http://citeseer.ist.psu.edu/hudak96building.html
16:19:16 <Pseudonym> Yes, I put them in hashtable.
16:22:09 <skew> hudak's paper is on portal.acm.org, if you have access
16:34:52 <skew> actually, citeseer seems to have a copy
16:43:00 <SyntaxLaptop> oh, I see it now
16:44:19 <SyntaxLaptop> too many menus
17:34:27 <LittleDan> does this channel have a paste bin?
17:34:45 <Riastradh> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:35:36 <LittleDan> can I delete what's there?
17:36:32 <Riastradh> Why?
17:36:54 <LittleDan> There's an error in some code that I wrote, is it OK to ask here?
17:37:01 <LittleDan> I don't understand it
17:37:22 <Riastradh> Go ahead.
17:44:04 <LittleDan> ok, I pasted it. It's supposed to traverse a list of lists to find corresponding elements, but it gives the error " test.hs:14: parse error on input `|' ". Can you tell what's wrong?
17:46:19 <Cale> put the where block after the definitions for assocGroup, I'd think
17:47:12 <LittleDan> what do you mean? After the rest of the definition instead of in the middle?
17:47:16 <Cale> yeah
17:47:51 <Cale> indent it the same as you are though. iirc, where scopes over multiple guards
17:51:22 <LittleDan> Cale, it said that `a' wasn't in the current scope, but I don't see where I used a except in the type definitions
17:53:36 <LittleDan> Is this line correct?
17:53:36 <LittleDan> type Multigroup = [[a]]
17:53:36 <LittleDan> I have a feeling that's the one I did wrong
17:54:06 <Cale> yeah
17:55:02 <LittleDan> Does it define a type called Multigroup containing a list of lists of any type, or does it do something else?
17:55:21 <Cale> you probably want type Multigroup a = [[a]]
17:55:29 <LittleDan> oh
17:55:33 <LittleDan> thanks
17:55:52 <LittleDan> wait, that makes a type constructor, right?
17:56:19 <Cale> yeah
17:56:34 <Cale> or gives a name to the list of lists type constructor
17:58:33 <Cale> you're also going to get a bunch of type errors because a few of your type declarations are a bit too general
18:00:35 <LittleDan> what does "forall a. " mean? I thought it was implied that it could use any type a.
18:00:54 <Cale> ghc will print the foralls explicitly
18:01:10 <Cale> (whereas in code they're usually left implicit)
18:03:19 <LittleDan> why does Haskell have the forall a. syntax?
18:03:44 <Cale> because you can put foralls deeper into a type
18:04:03 <Cale> there's also exists a.
18:04:12 <LittleDan> what does that do?
18:05:55 <Cale> that would specify that there's some type a that works.
18:07:16 <Cale> There's a neat little example in GHC's documentation here:
18:07:21 <Cale> data Foo = forall a. MkFoo a (a -> Bool)
18:07:21 <Cale>        | Nil
18:08:27 <Cale> since the type variable a doesn't appear in the data type, you can now make a list of things of type Foo where each might have a different a.
18:08:34 <Cale> [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
18:10:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#AEN8511 -- see 7.4.1.4 (scroll down a bit)
18:11:05 <LittleDan> When I left the type definitions up to type inference, it said
18:11:05 <LittleDan> test.hs:14:
18:11:05 <LittleDan>     Couldn't match `Maybe a' against `[a1]'
18:11:05 <LittleDan>         Expected type: Maybe a
18:11:05 <LittleDan>         Inferred type: [a1]
18:11:05 <LittleDan>     In the expression: accumulator ++ rest
18:11:07 <LittleDan>     In a right-hand side of function `removeItem': accumulator ++ rest
18:11:09 <LittleDan> Where did it get a1 from?
18:11:38 <Cale> a1 is just an arbitrary type variable it constructed during inference
18:11:53 <LittleDan> how could I fix the error?
18:11:55 <Cale> you're trying to use a list like a Maybe a
18:12:07 <Cale> perhaps by putting a Just somewhere
18:13:10 <LittleDan> where
18:13:37 <Cale> make it Just (accumulator ++ rest)
18:20:04 <Cale> hmm... what should removeItem do?
18:21:05 <LittleDan> given a list and an item, it returns the list with that item taken out, or nothing if the item isn't there
18:21:20 <LittleDan> But it should never have to return Nothing
18:22:24 <Cale> Wouldn't this be easier to do using filter?
18:22:33 <LittleDan> yes, I'm so stupid
18:24:12 <LittleDan> So that would be filter (\=item) first?
18:25:00 <LittleDan> oops, no
18:25:44 <LittleDan> what's the not equals operator?
18:27:05 <Lemmih>  /= ?
18:27:47 <LittleDan> Thanks. It works now
19:04:43 <Riastradh> Interesting.  Hans Boehm is on the ICFP 2004 program committee.
19:06:10 <Pseudonym> Why is that interesting?
19:07:30 <Riastradh> I'm not sure.
19:19:09 <Heffalump> it's not uncommon to have GC papers there
19:39:43 <Jerub> I wonder if any interesting languages are going to come out of this parrot thing.
19:41:55 <CrewdenX> Jerub: is that the hybrid perl/python thing?
19:42:21 <Heffalump> it's the common bytecode for the two, yes
19:45:25 <stepcut> mmm byte-code
19:45:59 <stepcut> see, perl wasn't bad enough, so now you can make your code even more unreadable by written it a mixture of languages
19:47:09 <Jerub> its actually the perl6 vm, but they're trying to be the be all and end all of VMs for languages.
19:47:14 <Jerub> like .NET's CLR, but perlish.
19:47:39 <Riastradh> And they're going to fail miserably and end up with something that sorta kinda works for Python and Perl and doesn't make sense for anything else.
19:48:25 <Jerub> yeah.
19:49:55 <Riastradh> But they'll persist and say 'ooh ooh look it has continuations so it must work for other languages!' causing more and more people to flock to them more and write more crappy compiler back ends and make the state of the main stream of programming languages suck even more.
19:52:46 <Jerub> :)
19:56:38 <Riastradh> Meanwhile, due to lack of person power, the quality functional language compilers will deteriorate into bitrot, so that the main stream idiots can say 'but look, it doesn't even have a library for X, so it must suck, and I won't even bother thinking about writing it, because my crappy language already has it!'
19:56:53 <Riastradh> Then the revolution will come.
19:57:36 <Riastradh> What happens then I leave up to your imagination, but I can tell you it won't be pretty for the main stream.
20:01:08 <jameson> Riastradh: Are there any specs on their bytecode? I like the idea of register-based representations (as in the Dis VM), actually...
20:01:38 <Riastradh> I'm sure there are lots of specs, all completely incompatible and entirely different ideas but thrown together under the same name of 'Parrot.'
20:16:16 <Jerub> .9~:)
20:16:22 <Jerub> err
20:16:23 <Jerub> :)
20:16:50 <Jerub> jameson: there's an asm that was developed for producing the bytecode, that's the level you'd probably be targetting.
20:26:01 <skew> Pseudonym: The Haskell Ports library might be useful for what you are trying to do, if it works under 6.2
20:26:38 <skew> I grabbed a copy and patched up the one incompatible library changed, but I'm not sure it all works
20:39:58 <ozone> Jerub: i've been playing around with parrot, i'm quite impressed with it
20:47:57 <Jerub> ozone: I've played with it to, written a small copmiler.
20:48:28 <ozone> i'm writing a parrot backend for minhs (a mini-haskell language we're using at uni for teaching)
20:48:35 <ozone> or, rather, i will be writing a backend when i can find the time :)
20:48:46 <ozone> let's see just how fast their continuations run
20:48:58 <ozone> (i'm very impressed with the performance it gets so far with the JIT core)
20:58:01 <stepcut> hrm, DbDirect it totally wacked on my system right now
21:18:22 <Pseudonym> skew: I did mention Haskell ports.
21:22:16 <Pseudonym> I think.
23:14:46 <Etaoin> is there a good way to test whether a monad has failed?
23:15:30 <Etaoin> (I'm thinking mostly about Maybe a or [a])
