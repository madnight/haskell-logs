00:01:17 <jchia> The real problem that led me here... Data.Conduit.Lzma from lzma-conduit. When I use decompress and the input file is bad, it just calls fail. And fail in Monad is just "error". I don't even have a chance to catch it, because the error is not presented as an exception. Would you say this is a design problem with decompress, that they should change the constraint from (MonadResource m) to (MonadResource m, MonadIO m) and deal with errors not by calling fail bu
00:01:27 <jchia> http://hackage.haskell.org/package/lzma-conduit-1.1.3.1/docs/Data-Conduit-Lzma.html
00:04:00 <Lokathor> jchia, so, what's your 'm'
00:04:41 <jchia> I think at the innermost end of my monad transformer stack is an IO
00:04:58 <jchia> let me double check
00:05:06 <Lokathor> well if the whole thing is an IO, can you use try
00:05:09 <Lokathor> :t try
00:05:11 <lambdabot> Exception e => IO a -> IO (Either e a)
00:11:55 <jchia> Lokathor: Do you mean that if I have IO as m, the fail of IO will get used, which throws an IOError?
00:13:10 <Lokathor> well, ... i don't think it works quite like that, but your conduit will blow up at that IO action and be catchable there, and not crash the entire program at least
00:13:56 <Lokathor> ...i think. I've only ever used try on actions that were actual IO actions, like network stuff
00:28:43 <lyxia> you can use a monad with a proper fail to catch it, like MaybeT m.
00:56:53 <jgt> I'm trying to write a parser for rfc5322 email addresses. So, it should either parse "Foo Bar <foo@bar.com>" as `Address (Just "Foo Bar") "foo@bar.com"`, or it should parse "foo@bar.com" as `Address Nothing "foo@bar.com"
00:58:07 <jgt> here's what I have tried: https://gist.github.com/jezen/ffee76a5fc130f8d870e84f51bbfd792
00:59:14 <jgt> but the `many1 (satisfy isAscii)` after the `<|>` is expecting a `ReadP Char`, and instead it's getting a `ReadP [Char]`
00:59:50 <jgt> can anyone make me less confused?
01:01:59 <kadoban> jgt: Is it possible you have the order of parameters to ``between`` mixed up?
01:02:29 <kadoban> It's usually  f open close inside
01:04:21 <jgt> oh. Oops. Right you are!
01:05:25 <jgt> kadoban: does my parser attempt look kinda-sorta reasonable otherwise? This is my first attempt at writing a parser, so I don't trust myself yet to not do something stupid
01:06:23 <kadoban> jgt: Looks like a pretty good start to me. Though I've never used ReadP and such, I always use libraries like megaparsec or whatever other one.
01:08:05 <jgt> Cool. Thanks üëçüèª
01:17:44 <kaiyin> instance Bifunctor (,) where     bimap f g ~(a, b) = (f a, g b)
01:17:53 <kaiyin> What does the ~ mean here?
01:21:29 <nshepperd> kaiyin: the term is "lazy pattern match"
01:21:37 <nshepperd> or irrefutable pattern
01:22:27 <nshepperd> basically, such a pattern match always succeeds immediately, and doesn't force the evaluation of the argument until a and b are actually needed
01:23:43 <nshepperd> in this equation I believe it's the same as bimap f g ab = (f (fst ab), g (snd ab))
01:28:42 <kaiyin> nshepperd: Thanks!
02:03:41 <jle`> kaiyin: usually, if it was just bimap f g (a, b) = (f a, g b), the function would have to check if the input tuple was constructed using the (,) constructor
02:03:50 <jle`> so it'd have to resolve what the constructor is
02:04:56 <jle`> that's actually a "main point" about pattern matching -- that you check the constructor and decide what to do based on what it is
02:05:45 <jle`> but with bimap f g ~(a, b) = (f a , g b), ghc won't attempt to evaluate/resolve the constructor unless it absolutely needs to later
02:17:13 <rickygee> :t Lens
02:17:14 <lambdabot> Lens s t a b -> ReifiedLens s t a b
02:48:21 <jgt> anyone have an answer for this? (should be easy for non-noobs) https://stackoverflow.com/questions/41360380/choosing-the-right-readp-parse-result
02:50:39 <mniip> "Simple types, as found in Ocaml or Haskell are not enough"
02:50:48 <mniip> I sure hope that's referring to report haskell :p
02:51:47 <osa1> where's that from?
02:52:01 <lyxia> jgt: pick the first address whose addressName is Just?
02:53:32 <jgt> lyxia: what if there are none?
02:55:15 <jgt> feels like I have to do something like "parse this string, find the first address whose addressName is Just. If that doesn't fail, run the parser again, this time just taking anything"
02:55:33 <jgt> s/If that doesn't fail/If that fails/
02:55:35 <lyxia> yeah
02:56:16 <jgt> I thought that's what my `withName <|> onlyEmail` would have achieved
02:56:18 <lyxia> I think if you filter out all results with a non-empty remainder, the first result in what's left is the one you want
02:57:33 <lyxia> you can do that by ending your parser with eof
02:58:16 <lyxia> jgt: rfc5322 = (withName <|> onlyEmail) <* eof
02:59:20 <jgt> oh, that's perfect!
03:00:11 <jgt> I think I would have otherwise done rfc5322 = do; address <- withName <|> onlyEmail; eof; return address
03:00:15 <jgt> because I'm not sure what <* does
03:00:25 <lyxia> exactly what you did, just shorter
03:00:34 <jgt> cool. Thanks for the help!
03:01:09 <lyxia> (<*) means run the two arguments in order, and keep the left result
03:01:19 <lyxia> (*>) runs in the same order, and keeps the right result
03:01:49 <lyxia> (<*>) keeps and combines both results (the first must be a function and is applied to the second)
03:04:53 <jgt> I've seen <*> before in Yesod's forms. It'll start with an fmap, and then add applys, like `form <$> field <*> field <*> ‚Ä¶` etc
03:05:24 <lyxia> yeah, that's the typical way to use it.
03:05:45 <jchia_> I'm trying to understand exceptions in the context of Monad 'fail'. The default implementation of Monad 'fail' is essentially calling 'error' with a String. What does 'error' do exactly? What kind of exception do I get?
03:07:39 <merijn> jchia_: Fail is an awful abomination, forget it evers existed (or at least until the MonadFail proposal is updated)
03:07:53 <merijn> :t fail
03:07:55 <lambdabot> Monad m => String -> m a
03:08:09 <merijn> jchia_: Basically, that type makes no sense, as not all monads have a sensible "failure" operation
03:08:14 <jchia_> merijn: I can't forget it exists. I'm using a library that uses it. lzma-conduit
03:08:31 <lyxia> jchia_: if you look at the source for error, it calls errorCallWithCallStackException which ultimately leads to ErrorCall
03:08:33 <lyxia> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#t:ErrorCall
03:08:54 <lyxia> but it's not something you're supposed to catch
03:09:05 <jchia_> it calls fail when the input file is bad, instead of throwing an IOException. I expect this case to result in an IOException and I'm trying to understand why they use fail.
03:09:10 <merijn> Not only not supposed, but really hard to reliably do so
03:10:08 <lyxia> jchia_: I'd use a monad which has a sane implementation of fail, like MaybeT m for any m.
03:10:11 <jchia_> So, what should I do about decompress calling 'fail' essentially calling 'error' when the input file has an error?
03:10:16 <merijn> jchia_: The only reason I can think off is "incompetence" (except I don't mean to sound so harsh/judging, but I can't find a better word)
03:12:25 <jchia_> lyxia: I'm trying to runConduitRes on some ConduitM that could fail because there's a decompress inside. How exactly do I mitigate using MaybeT?
03:15:23 <lyxia> jchia_: Instead of ConduitM i o m, you can have ConduitM i o (MaybeT m)
03:15:48 <lyxia> oh there's a resource in there.
03:16:39 <lyxia> ConduitM i o (ResourceT (MaybeT m)) ?
03:25:10 <jchia_> lyxia: Is the idea to cause the fail of MaybeT to be used instead of the default one from Monad?
03:25:22 <li4ick_> why does haskell consider 0^0 to be equal to 1?
03:26:09 <octarin> li4ick_: by convention, 0^0 = 1
03:26:15 <octarin> in mathematics
03:27:00 <octarin> this is justified by the limit of x^x when x -> 0, which tends to 1
03:27:21 <EvanR> or the convenience of series formulas
03:27:59 <lyxia> jchia_: yes.
03:28:31 <li4ick_> But in every math book you can find that 0^0 is undefined. Why not NaN?
03:30:03 <EvanR> in that math book its probably talking about real to a real power
03:30:17 <EvanR> ^ is for integral power, repeated multiplication
03:30:29 <EvanR> > 0**0
03:30:32 <lambdabot>  1.0
03:31:00 <octarin> https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero
03:33:01 <EvanR> apparently the behavior of pow(0,0) is implementation dependent? 
03:33:16 <EvanR> you could take that to be "undefined" 
03:34:08 <li4ick_> Ok. 0^0 = 1 and 0^^0 = 1.0 and 0**0 = 1.0. I get the limit explanation, I do. But I guess they had to make a decision for 0^0 and chose to be 1, instead of NaN?
03:34:31 <EvanR> that one comes up in series formulas
03:34:58 <octarin> I suppose it‚Äôs more convenient to asign a value to it
03:35:06 <octarin> like EvanR said
03:35:06 <EvanR> but they still put the caveat "where the convention 0^0 = 1 is used"
03:35:45 <EvanR> 0^0 for integral types cant be NaN
03:36:19 <EvanR> and 0.0^0.0 is not well typed
03:39:08 <li4ick_> Ok, it's clear now. The wikipedia article also helped.
03:39:14 <jkramer> Ahoy!
03:39:56 <srhb> hoogle.haskell.org looks very strange right now...
03:40:50 <EvanR> heh "0^0 is the number of functions from empty set to empty set, which is 1"
03:41:34 <jkramer> Is there a nice way to make a bunch of types class instances at once? Something like: instance Foo (Int, Integer, ...)
03:42:32 <implementation_> no, since you usually want different implementations for the methods
03:43:06 <EvanR> alternative answer, yes generics
03:43:42 <EvanR> or worst case scenario TH
03:43:47 <EvanR> template haskell
03:44:28 <octarin> when you say generics you talk about implementing the function into the Foo declaration ?
03:46:29 <EvanR> something like
03:46:39 <EvanR> class Foo a where
03:47:15 <EvanR>   default foo :: Generic a => something involving a
03:47:24 <EvanR>   foo something = ...
03:56:40 <marcx> what is the recommended practice? always defaulting to Text or using String by default and Text only when processing a lot of text and when using String would be the bottle neck
04:02:58 <EvanR> marcx: context?
04:03:18 <marcx> hmm, not sure what context you are looking for
04:03:29 <EvanR> script, application, library, server, redesign of haskell...
04:04:05 <marcx> writing application and library
04:04:26 <marcx> which could include writing a server application too
04:05:34 <EvanR> you really need Text most of the time, the only reason to use [Char] is for convenience with libs that use [Char]
04:06:56 <EvanR> the ability to use [Char] with many list functions and no extensions for literals is a big plus
04:07:36 <EvanR> but that only matters if doing some one-off script or demonstration
04:09:25 <marcx> what if you are releasing a library. should you api accept a string or text? I see that a lot of functions in base accept a string, like readFile for example
04:09:31 <marcx> your api*
04:10:18 <maerwald> marcx: neither, use bytestring for filepath
04:10:20 <EvanR> readFile is a whole nother issue
04:10:39 <maerwald> and for contents, it depends on the content
04:10:44 <maerwald> probably either Text or ByteString
04:10:46 <EvanR> normally for short strings you can get away with String, but FilePaths arent really text in the first plae
04:11:24 <marcx> what do you mean
04:11:27 <EvanR> in general you need Text for text
04:11:37 <marcx> FilePaths aren't really text
04:11:43 <EvanR> theyre just not
04:12:00 <EvanR> we have no way to know what filepaths are encoded as, if anything
04:12:21 <EvanR> like, in the actual filesystem
04:12:59 <EvanR> so dont ask what FilePath = String is actually doing (unless you sit down first)
04:13:12 <marcx> huh :)
04:13:28 <EvanR> does the problem make sense/
04:14:09 <octarin> ghc magic ?
04:14:33 <EvanR> questionable magic, afaiui
04:17:37 <marcx> what magic does it actually involve? and why is it even needed? for supporting some obscure systems?
04:18:29 <EvanR> because String is a list of Char
04:18:42 <EvanR> which is what "text" is
04:18:46 <hexagoxel> btw has anyone bothered to open an issue about Text.IO.readFile vs BS.readFile+decode performance?
04:18:58 <hexagoxel> or is that not an issue?
04:19:15 <EvanR> vector of bytes is not text, unless you can decode it
04:19:50 <EvanR> you can only decode it if you know the intended encoding, or guess correctly
04:20:46 <EvanR> that is why magic is needed
04:22:34 <hexagoxel> (one could use a exactly-one-byte-per-char encoding, and have encoding/decoding be total, right?)
04:22:58 <EvanR> as long as you dont have more than 256 chars
04:24:11 <hexagoxel> right, in that direction it breaks down.
04:25:02 <hexagoxel> but with such an encoding at least String/Text could work to some degree as filepath representations
04:25:25 <EvanR> your hypothetical encoding doesnt solve the "what is the intended encoding" problem
04:25:35 <hexagoxel> (unless your arch byte has other than 8 bits :D)
04:25:43 <EvanR> it just gives you a cant-fail decoding algorithm, in the sense it wont crash
04:25:59 <EvanR> it doesnt mean youll get non-nonsense
04:26:53 <EvanR> the real world case of this is iso8859-1 encoding
04:27:43 <EvanR> it has 256 characters, alot of pages are interpreted by browsers as iso8859-1 and you get broken particular characters
04:27:48 <hexagoxel> is there a lib that does pure BS-based filesystem IO?
04:28:53 <EvanR> i like the abstract FilePath proposal
04:28:55 <maerwald> hexagoxel: hpath
04:30:23 <hexagoxel> neat
04:31:34 <maerwald> EvanR: I wonder when it will be implemented though -.-
04:32:08 <EvanR> it seems to have stalled
04:32:34 <EvanR> it would certainly break stuff
04:34:03 <Gurkenglas> Wasn't backpack supposed to solve that "it would break stuff" problem?
04:34:44 <Gurkenglas> http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/
04:51:37 <EvanR> Gurkenglas: looks like it would in theory if you went back and fixed all the code that would break
04:52:22 <Gurkenglas> Ah, back to https://github.com/aelve/haskell-issues/issues/46 then.
04:56:59 <EvanR> interesting
05:08:42 <jchia_> merijn, lyxia: Any comments on this fix for lzma-conduit? https://github.com/jchia/lzma-conduit/commit/7317e3615dd78ef32017d1f54bb77c22bc9c3164
05:09:03 <marcx> what was that (relatively new i think) ffi library that lets you call C functions directly, without binding them (and the types they use) first
05:13:07 <EvanR> inline C ?
05:13:17 <maerwald> isn't that TH hackery?
05:13:45 <marcx> "Write Haskell source files including C code inline. No FFI required."
05:13:47 <marcx> that seems to be it
05:27:58 <Guest29476> hello. how can I resume the download of "stack new myproject" ?
05:31:46 <lyxia> jchia_: actually IO implements fail exactly like that
05:33:18 <MarcelineVQ> Guest29476: I‚Äã believe the only long part to download of  stack new  is the package index if you don't have it, so  stack update  should download that part
05:33:54 <ertes> yes, inline-c is TH hackery with some really awkward side effects: doesn't properly work with GHCi, so your rapid prototyping goes out the window, and it generates files right in your source tree
05:35:03 <ggVGc> I've never managed to get into using ghci in my normal workflow
05:35:18 <maerwald> ertes: uhh
05:35:27 <ertes> ggVGc: i've resisted for a few years, but i will never go back to writing haskell code without GHCi
05:35:28 <Dreamerz> is there anyone that understands gloss?
05:35:28 <lyxia> jchia_: In which case that modification doesn't bring much, and you can just catch userErrors instead of using MaybeT like I suggested earlier.
05:35:35 <ggVGc> ertes: so how do you use it?
05:36:01 <ertes> ggVGc: i'm just using haskell-interactive-mode for emacs, which has GHCi running in the background
05:36:32 <MarcelineVQ> Guest29476: I should mention it uses git though, so it may not be able to resume if it's interrupted :(
05:38:48 <kuribas> Do you use unicode symbols, like Œ±?
05:39:13 <ertes> Dreamerz: it's best just to ask your question
05:41:15 <Dreamerz> so i'm doing bomberman, now i need to know how i say the user to chose between 0 and 4 players
05:41:29 <Dreamerz> but with graphic
05:43:04 <kuribas> A dialog?
05:43:29 <Dreamerz> yes
05:44:29 <kuribas> Dreamerz: what's your question then?
05:45:49 <kuribas> how to show a dialog?
05:46:34 <Dreamerz> yeap man
05:47:09 <superlinux> what I have done now is that I changed to another WiFi , so the git command is still on , but it was not resuming. so now I gave the `killall -HUP git` and `killall -HUP git-remote-https` and the download resumed.
05:47:14 <ertes> Dreamerz: gloss has no modality other than the current world state‚Ä¶  in other words: while your application is in the "player count dialog state" you display the dialog and handle events accordingly
05:47:21 <superlinux> but I am not sure whether the download itself restarted or actually resumed.. I can see my network meter getting full now after the killall -HUP
05:47:23 <kuribas> Dreamerz: depends on the toolkit
05:48:38 <ertes> Dreamerz: in yet other words: start by designing a type that can hold all the possible states your application may be in:  data World = PlayerSelect { numPlayers :: Int } | ‚Ä¶
05:49:18 <ertes> Dreamerz: this type will become the 'world' type here: https://hackage.haskell.org/package/gloss-1.10.2.3/docs/Graphics-Gloss-Interface-Pure-Game.html#v:play
05:50:25 <Dreamerz> yes i have this already
05:51:34 <ertes> Dreamerz: do you have a more specific question?
05:51:59 <Dreamerz> type State = ([String], Float, [Pictures])
05:52:31 <Dreamerz> [String] is containing the map and the powerups but not the players yet
05:54:13 <ertes> what's the rest?
05:54:30 <Dreamerz> so i now have a function initialState ::[Pictures] -> State  (it will put the pictures on the state to later use them to do the map) , but i also want on this one to let the player chose de dimension of the map and number of players
05:54:56 <Dreamerz> and idk how i will print it on the screen and come to this initialState and change it
05:55:13 <Dreamerz> Float is the ticks
05:55:58 <ertes> Dreamerz: alright, let's work with that one for now (it needs some serious cleanup itself) =)
05:55:58 <superlinux> how many bytes is the stack index?
05:57:10 <tabaqui1> what's the difference between TVar and TMVar?
05:57:15 <ertes> Dreamerz: your application can be in different "modes":  one is the configuration menu where the user selects number of players and grid size, the other is the actual game, and perhaps there is a third, which is just a screen displaying the winner
05:57:20 <tabaqui1> I cannot use first in multithreaded app?
05:57:21 <kuribas> > 2 √ó 3
05:57:22 <lambdabot>  error:
05:57:23 <lambdabot>      Variable not in scope: (√ó) :: Integer -> Integer -> t
05:57:51 <kuribas> > let (√ó) = (*) in 2 √ó 3
05:57:54 <lambdabot>  6
05:58:32 <nshepperd> tabaqui1: as TVar is the STM version of an IORef, TMVar is the STM version of an MVar
05:58:43 <nshepperd> tabaqui1: the main difference is that a TMVar can be empty
05:59:03 <ertes> Dreamerz: you need a type that represents those modes:  data World = PlayerSelect { numPlayers :: Integer } | GridSizeSelect { gridDimX :: Integer, gridDimY :: Integer } | Game { grid :: [String], tick :: Float, pics :: [Picture] } | GameOver { winner :: Integer }
05:59:23 <ertes> Dreamerz: ah, that one was wrong
05:59:24 <Dreamerz> ertes, btw when i have more than 1 player the other players will be my bot (it needs some improvment but i would help to have gloss ready)
06:00:05 <ertes> Dreamerz: data World = PlayerSelect { numPlayers :: Integer } | GridSizeSelect { numPlayers :: Integer, gridDimX :: Integer, gridDimY :: Integer } | Game { grid :: [String], tick :: Float, pics :: [Picture] } | GameOver { winner :: Integer }
06:00:23 <tabaqui1> nshepperd: what is the reason to use tvar? it can't be blocked in one-threaded program
06:00:46 <ertes> Dreamerz: when world = PlayerSelect x, then the application is in player select mode with the value 'x' (between 1 and 4) currently selected
06:00:47 <nshepperd> ertes: shouldn't PlayerSelect be before the number of players is known? so perhaps just PlayerSelect | ...
06:00:57 <nshepperd> oh
06:01:15 <ertes> nshepperd: World is the only state you get in gloss
06:01:17 <nshepperd> with a number of players and a 'go' button, fair enough :)
06:01:27 <ertes> yeah =)
06:01:52 <Dreamerz> ertes, yes
06:02:03 <_sras_> I am seeing a weird issue when an instance declaration yields a "Overlapping instance" error, and its removal produces an "Cannot deduce instance" error...
06:02:17 <_sras_> How is this possible?
06:03:48 <nshepperd> tabaqui1: if your program is completely single-threaded (you never call forkIO) you might as well use IORef
06:04:44 <ertes> _sras_: contexts perhaps?  instances (D a) => C (F a)
06:04:59 <nshepperd> tabaqui1: both TVars and TMVars are appropriate for multi threaded applications
06:05:09 <ertes> _sras_: this is an instance for all (F a), regardless of 'a'
06:05:31 <ertes> _sras_: only when instance resolution is successful the context becomes relevant
06:05:41 <ertes> i.e. the (D a)
06:05:42 <nshepperd> tabaqui1: actually, I think you can use IORefs for multithreaded apps too, if you don't need any synchronization at all
06:06:13 <tabaqui1> nshepperd: but it can't use tvar as shared data between threads? so operation with can't be blocked and tvar is useless, while there are iorefs?
06:07:17 <tabaqui1> *operation with tvars
06:07:18 <nshepperd> tabaqui1: hmm? of course you can use tvar as shared data between threads
06:07:28 <ertes> nshepperd: there is atomicModifyIORef, too
06:08:45 <nshepperd> tabaqui1: TVar is simply a shared writeable variable, that you can operate on atomically (even to operate on multiple TVars atomically, or to wait for a TVar to contain a certain value etc)
06:09:44 <ertes> tabaqui1: here is the good old accounting example: atomically (do modifyTVar v1 (+ 20); modifyTVar v2 (subtract 20))
06:10:54 <ertes> tabaqui1: this is a memory transaction, i.e. the state where 20 was added to v1, but not yet withdrawn from v2 cannot be observed from outside
06:11:06 <ertes> it makes sure that the transaction is atomic (all or nothing)
06:12:38 <tabaqui1> ertes: yeah, of course, but look, I have IORef, TVar and TMVar and seems like (TVar almost equal IORef || TMVar almost equal TVar)
06:13:10 <tabaqui1> I still cannot see conceptual different cases to uses ioref, tvar and tmvar
06:13:29 <ertes> tabaqui1: TVar can emulate IORef, but IORef can't emulate TVar (you can't have transactions with IORef)
06:13:58 <ertes> tabaqui1: (TMVar a) is indeed like (TVar (Maybe a)), but with some useful functions for dealing with "taking" and "putting"
06:14:13 <tabaqui1> ertes: hm, it makes sense
06:14:15 <nshepperd> well, do { modifyIORef v1 (+ 20); modifyIORef v2 (subtract 20) } would leak money into the aether if any other thread accessed v1 or v2 at the same time
06:14:18 <ertes> tabaqui1: here is a TVar example that is impossible to do with IORef:
06:14:31 <nshepperd> which is why you may need TVar's transactions
06:14:43 <ertes> tabaqui1: atomically (x <- readTVar v; check (x > 0); writeTVar v (x - 1))
06:15:08 <ertes> tabaqui1: this transaction waits for v's value to become greater than 0 and then subtracts 1 from it
06:15:24 <ertes> this could be used to implement semaphores, for example
06:15:37 <tabaqui1> so TMVar is the most flexible, and I don't need to use other?
06:15:48 <ertes> tabaqui1: TVar is the most flexible
06:15:51 <_sras_> ertes: Can you elaborate a bit..
06:15:56 <ertes> _sras_: on what?
06:16:11 <ertes> _sras_: ah‚Ä¶
06:17:29 <tabaqui1> hm, ok, I get it
06:17:32 <tabaqui1> thanks to all
06:18:09 <ertes> _sras_: if you could paste your code, it would be easier
06:19:06 <ertes> _sras_: but the important point is that this is actually an instance *for all* 'a':  instance (D a) => Num a
06:19:30 <ertes> you might think that it's an instance for all 'a' such that there is an instance (D a), but that's not the case
06:19:59 <ertes> (D a) must exist when *using* it, but instance resolution will *always* select this instance, because it doesn't look at the context
06:21:42 <ertes> _sras_: instance (Num a) => Num (Maybe a); instance (D a) => Num a  -- this will find two instances for (Maybe ()), so you get an overlap
06:22:15 <ertes> _sras_: instance (Num a) => Num (Maybe a)  -- this will find one instance for (Maybe ()) and then reject it with a "no instance" error, because the context isn't satisfied
06:22:36 <ertes> that's how you can go from "overlapping instances" straight to "no instance"
06:23:52 <_sras_> ertes: Ok. That makes sense. 
06:23:58 <_sras_> ertes: But let me show you the code...
06:27:35 <_sras_> ertes: http://lpaste.net/350564
06:28:48 <ertes> _sras_: why does your class have three arguments?
06:29:18 <_sras_> ertes: The Default class?
06:29:50 <_sras_> ertes: It is part of the Data.Profunctor.Product module...
06:30:08 <lyxia> yeah Opaleye uses that
06:30:29 <ertes> hmm, i see
06:31:47 <aarend> hi, is this the right place to ask questions about intero? not getting it to work on osx
06:35:17 <lyxia> _sras_: Can you implement an instance of QueryRunnerColumnDefault instead
06:35:33 <lyxia> _sras_: then the default instance would be derived from it
06:35:52 <lyxia> though the first parameter would be wrapped in a Column
06:36:06 <_sras_> lyxia: I tried that first. But I got the missing Default instance error..Let me try again.
06:39:29 <_sras_> lyxia: http://lpaste.net/350565
06:39:53 <lyxia> _sras_: you would then call runQuery like this:  runQuery conn (fmap Column query')
06:42:37 <kuribas> Is using a typeclass for operator overloading considered bad practice?  (even if the meaning is approximately the same).
06:42:47 <srhb> Is there a shorthand for long chains of set setter foo . set setter2 bar . ... ?
06:42:55 <_sras_> lyxia: What is "Column"? Error says Data constructor is not in scope
06:42:58 <Athas> kuribas: not if your instance fulfills the same laws.
06:43:32 <lyxia> _sras_: from Opaleye.Column
06:43:38 <srhb> I guess I can only meaningfully get rid of one of & or set...
06:44:06 <_sras_> lyxia: But it is not exported.
06:44:18 <kuribas> For example I have "between :: Num a => a -> a -> a -> a", which interpolates between two numbers, and "betweenPt :: Num a => a -> Point a -> Point a -> Point a", which interpolates between points.
06:44:22 <lyxia> _sras_: ah. You are right.
06:45:00 <kuribas> I might make an "Interpolate a b" class with between :: a -> b -> b -> b
06:46:32 <kuribas> On the other hand Point cannot be a Num instance, because there is no Point * Point
06:46:50 <ertes> could somebody confirm something for me?  i'm noticing that dynamically linked haskell programs have quite a startup delay‚Ä¶  if your pandoc is dynamically linked, try 'pandoc --help'
06:46:59 <ertes> this doesn't happen when statically linked
06:47:15 <ertes> (not to system libraries, but haskell libraries)
06:50:20 <lyxia> _sras_: I don't know for sure, maybe you're supposed to just put Default QueryRunner columnsR (Auditable haskells) in the constraints (with FlexibleContexts)
06:51:19 <kuribas> I guess two functions is more idiomatic...
06:51:28 <_sras_> lyxia: Tried that already...:(
06:52:06 <kuribas> I could make a monoid instance for point (or vector) addition.
06:52:29 <Athas> kuribas: I don't see that pattern often.  What kind of generic function could you write that only uses that interface?
06:52:33 <nshepperd> kuribas: that case seems reasonable. actually it is justified by the fact that your 'between t a b' corresponds to 'scale (1 - t) a + scale t b' in the vector spaces a and Point a
06:52:40 <Athas> It might be OK if it's something local to a module that doesn't escape.
06:53:20 <kuribas> nshepperd: + isn't defined for Point 
06:53:50 <kuribas> nshepperd: because a Num instance needs (*) as well.
06:54:00 <lyxia> _sras_: what happened
06:55:09 <_sras_> lyxia: it Compliles with {-# LANGUAGE IncoherentInstances    #-}
06:55:09 <jchia_> lyxia: Not sure what you mean by "doesn't bring much". Do you mean the fix to lzma-conduit is not worth doing?
06:55:16 <lyxia> jchia_: yes
06:55:31 <nshepperd> kuribas: well, yes but that's Num's fault
06:55:45 <Athas> kuribas: and fromInteger, and signum, which don't really make much sense for points, do they?
06:55:49 <jchia_> lyxia: The fix allows the user to not use MaybeT as duct-tape. Isn't that worth something, at least reducing code clutter?
06:55:51 <lyxia> _sras_: That doesn't sound like a good idea though
06:56:02 <Athas> I find that fromInteger/toInteger spoil many of my attempts to use Num and Integral for clever things.
06:56:14 <kuribas> nshepperd: I could treat point as a complex number ...
06:56:27 <nshepperd> kuribas: Num is a pretty bad typeclass
06:56:38 <kuribas> yeah, it's a mix.
06:56:47 <lyxia> jchia_: Earlier I missed the fact that IO actually has an implementation of fail which does not call error.
06:56:59 <lyxia> jchia_: it throws an exception, which AFAICT you can catch.
06:57:30 <jchia_> the fail from lzma-conduit results in a non-IOException
06:57:48 <nshepperd> you could define 'class Vector a v | v -> a where { scale :: a -> v -> v; (‚äï) :: v -> v -> v }'
06:58:11 <nshepperd> VectorSpace
06:58:16 <kuribas> right
06:58:30 <nshepperd> just have your own plus symbol
06:58:45 <kuribas> :t (**)
06:58:46 <lambdabot> Floating a => a -> a -> a
06:58:50 <jchia_> lyxia: It doesn't matter that I'm using it with IO as the innermost Monad. The fail from lzma-conduit just results in error. So, I'm not sure what you mean. How does the IO fail matter here?
06:58:56 <_sras_> lyxia: Yes. This is the error when I put Default QueryRunner columnsR (Auditable haskells) in the constraints of the readRow function 
06:58:57 <_sras_> http://lpaste.net/350566
06:59:23 <kuribas> nshepperd: not sure if (‚äï) is good for a library.
06:59:39 <nshepperd> heh
06:59:51 <kuribas> nshepperd: idk if the users editor supports unicode chars.
07:00:09 <nshepperd> yes, the unfortunate fact of unicode input...
07:00:49 <nshepperd> anyway, there are other grounds for having a class for Interpolation, I suppose
07:02:09 <kuribas> nshepperd: I probably should use this: https://hackage.haskell.org/package/vector-space-0.10.4/docs/Data-VectorSpace.html
07:02:54 <nshepperd> eg. weighted mixtures of probability distributions are valid even though arbitrary sums and products are not
07:03:09 <lyxia> jchia_: http://lpaste.net/350567
07:04:08 <kuribas> nshepperd: well, my library isn't trying to be so general.  It's for graphics anyway.
07:04:16 <lyxia> _sras_: do you have a link to the whole codebase
07:05:02 <ertes> even GHCi has that delay
07:05:12 <ertes> or rather GHC
07:05:18 <lyxia> jchia_: fail in IO already does what you wrote.
07:05:39 <ertes> % time ghc --help > /dev/null
07:05:40 <ertes>   real 0.283  user 0.236  krnl 0.037  cpu% 96%  mem 97m  ghc --help > /dev/null
07:08:10 <MarcelineVQ> ertes: is there something specific I need to go to make time match that format? mine's just real user sys on their own lines
07:08:42 <ertes> MarcelineVQ: if you're using zsh you can set TIMEFMT
07:09:18 <ertes> MarcelineVQ: https://github.com/esoeylemez/config/blob/master/files/.zshrc#L106
07:09:34 <jchia_> lyxia: I get that. In the following code, calling baz with different arguments result in different things being thrown, and foo2 corresponds to what's happening with lzma-conduit, unhelpable by what you said about IO fail. http://lpaste.net/350568
07:10:18 <ertes> cabal-install has the delay, too:  real 0.306  user 0.278  krnl 0.023  cpu% 98%  mem 34m  cabal --help > /dev/null
07:11:14 <ertes> pandoc doesn't, because it's statically linked against haskell libraries:  real 0.044  user 0.023  krnl 0.013  cpu% 81%  mem 35m  pandoc --help > /dev/null
07:11:20 <_sras_> lyxia: Here it is https://github.com/vacationlabs/haskell-webapps/blob/feature/servant-opaleye/ServantOpaleye2/appcore/src/ApiBase.hs
07:11:45 <ertes> could this be a linker bug?
07:12:11 <ertes> or rather a GHC bug
07:18:25 <lpaste> MarcelineVQ pasted ‚Äúertes‚Äù at http://lpaste.net/350569
07:19:33 <lyxia> jchia_: OK, the Monad instance of ConduitM defaults on the error implementation.
07:19:50 <lyxia> jchia_: Where does lzma-conduit call Conduit's fail
07:20:22 <lyxia> jchia_: ah, the second one is in conduit
07:20:56 <lyxia> jchia_: Okay, I was only looking at the first change to monadThrow, which I was saying is superfluous
07:21:44 <lyxia> jchia_: but I get your point about the second change
07:22:41 <jchia_> lyxia: You're right about the first fail.
07:22:48 <ertes> MarcelineVQ: are those statically or dynamically linked?  see e.g. whether 'ldd `which ghc`' shows any links to libHS* files
07:23:07 <jchia_> I think I still want it for the sake of consistency.
07:23:14 <jchia_> i mean the first monadThrow
07:23:24 <ertes> MarcelineVQ: (you didn't have to go through the trouble of matching up the format‚Ä¶  i thought you were just interested in how to get it) =)
07:24:45 <MarcelineVQ> of those, only ghc is static
07:24:59 <MarcelineVQ> lemme double check for libHS though
07:25:32 <ertes> hmm‚Ä¶  does dynamic linking just take that long?  i'm on an intel celeron here
07:25:57 <ertes> no, that can't be it‚Ä¶  if that were true, pretty much everything would have to be that slow to boot
07:26:27 <ertes> being on slow hardware makes you notice things =)
07:27:05 <MarcelineVQ> I don't see anything with libHS in it with my ldd
07:27:20 <ertes> ok, then it's static
07:34:37 <_sras_> lyxia: Ok. It works now. It requires both the constraint as you told and the instance definition....!
07:36:36 <_sras_> lyxia: I can't make any sense of it.
07:37:31 <lpaste> MarcelineVQ annotated ‚Äúertes‚Äù with ‚Äúertes (annotation)‚Äù at http://lpaste.net/350569#a350570
07:39:05 <ertes> MarcelineVQ: thank you!
07:39:36 <lyxia> _sras_: What do you mean
07:40:15 <_sras_> lyxia: It works when I add the constraint as you suggested, AND the instance definition...
07:43:34 <lyxia> Hm... I can't figure out why that works :P
07:46:45 <c_wraith> I scrolled back and saw Servant, and decided I probably don't know either - without even looking.  I'd like to learn how to use Servant some day, but until I do I feel way out of my depth there. :)
07:46:57 <_sras_> lyxia: It seems that the overlapping instance issue is resolved by adding the additional constraint...
07:47:27 <c_wraith> Constraints on the instance head shouldn't be considered in instance selection, even with OverlappingInstances.
07:47:39 <c_wraith> On the other hand, they might be considered with IncoherentInstances.
07:47:43 <c_wraith> Is that enabled?
07:48:38 <_sras_> c_wraith:  No. I have added the constraint to the function call that trigger the issue..
07:49:07 <c_wraith> Oh, I see.  That's still odd, but at least it's not off in "that seems impossible" territory
07:50:53 <lyxia> I think I know how it resolved that. I missed some instances which were generated by TH and didn't appear in the Opaleye docs
07:54:02 <lyxia> _sras_: which instance definition did you mean, Default orQueryRunnerColumnDefault
07:55:24 <_sras_> lyxia: Default
07:56:33 <_sras_> lyxia: http://lpaste.net/350572
07:58:36 <AndreasK> ertes: Thanks for the hint about logicT a while ago it's almost magical to work with :D
07:59:36 <lyxia> _sras_: why do you not map auditable over the list after running the query?
08:00:04 <lyxia> These constraints still look wrong somehow.
08:00:32 <shapr> Does the warp web server include support for TLS and HTTP/2?
08:01:02 <_sras_> lyxia: I was doing that earlier. But I wanted to compose the Query with other Query'ies with join, so the runQuery function will be called on the final query.
08:01:10 <Clint> shapr: warp-tls and no, i believe
08:01:28 <Clint> shapr: oh, maybe yes
08:01:55 <Clint> shapr: let's start over: warp-tls
08:05:06 <Profpatsch> Can somebody give me pointers as to why I‚Äôd like to encode my recursive datastructures with Data.Fix as opposed to the naive way?
08:05:20 <Profpatsch> Papers/Tutorials
08:05:24 <c_wraith> Profpatsch: practically?  There isn't a good reason.
08:05:24 <pi____> Hi, I installed haskellplatform on debian. It doesn't have a ghci command..Is ghci a separate install?
08:06:01 <Tuplanolla> There are two practical reasons, Profpatsch.
08:06:36 <c_wraith> Profpatsch: it's more of a theoretical tool.  It lets you write proofs for Fix as your only recursive type, and then have proven something for all recursive types.
08:06:54 <Tuplanolla> When you change the type definition, you don't need to modify all the functions that use it if they simply recur.
08:07:18 <MarcelineVQ> pi____: ghci is typically installed with most ghc install methods so that's odd, it's actually a script that calls ghc --interactive and passes it any arguments
08:07:31 <Tuplanolla> You also get guaranteed fusion of compatible catamorphisms.
08:07:53 <c_wraith> pi____: debian packaging for GHC is not very good for developers.
08:07:58 <pi____> MarcelineVQ: thank you, I just saw that it should be installed. maybe it's a PATH issue
08:08:22 <Profpatsch> Tuplanolla: What will fuse them?
08:08:26 <MarcelineVQ> pi____: could be, if you can't solve it then this is the script for ghci http://lpaste.net/350574
08:08:29 <Profpatsch> Other libraries? GHC?
08:08:47 <pi____> MarcelineVQ: I ran ghc --interactive and it said, not built for interactive use
08:09:05 <MarcelineVQ> ah, hmm,
08:09:13 <Tuplanolla> You can manually compose the algebras and run the result once, Profpatsch.
08:09:18 <ClaudiusMaximus> pi____: which architecture?
08:09:45 <pi____> armv7l
08:10:26 <c_wraith> oh
08:11:32 <pi____> is my case hopeless for using ghci on armv7l?
08:11:39 <c_wraith> arm support is rather new. I don't recall if interactive support is built in GHC 8, but it certainly wasn't available before that.
08:11:42 <Tuplanolla> Instead of `cata b . cata a` you have `cata (b . unFix . a)`, Profpatsch.
08:12:13 <ClaudiusMaximus> not hopeless, you probably just need a newer version (apparently ghc 7.8 in Debian unstable circa 2015 supported ghci)
08:12:17 <pi____> c_wraith sudo apt-get install haskellplatform installed ghc 7.6.3
08:12:26 <c_wraith> pi____: yeah, that's ancient.
08:12:36 <Tuplanolla> You can of course use `RULES` to have GHC do it, too, Profpatsch.
08:13:24 <MarcelineVQ> possibly bgamari would know for sure about the current status of arm ghci
08:13:53 <c_wraith> pi____: hmm, looks like 7.10 actually added interactive support on arm
08:14:27 <c_wraith> pi____: You can try out https://www.haskell.org/ghc/download_ghc_8_0_1#linux_armv7
08:14:55 <ClaudiusMaximus> i have ghci-8.0.1 on my rpi3, think it was a the one c_wraith just linked
08:16:18 <pi____> thank you, I'll try it out
08:21:19 <c_wraith> pi____: note that the link I gave was for GHC only - it doesn't include a bunch of tools and libraries that the platform does.  You'll probably want to install cabal or stack (library management tools) if you want to do anything more than play with ghci
08:22:09 <pi____> c_wraith: thank you, I saw that
08:22:38 <c_wraith> Oh, good.  Just making sure.
08:23:09 <ertes> AndreasK: my pleasure =)
08:23:11 <pi____> by chance, anyone know how to run grep so it matches only on `deinstall` and not `install` i.e. grep -v 'deinstall'
08:23:31 <ertes> AndreasK: note that a lot of use cases are covered by [] already, so often there is no need for logict
08:23:40 <ertes> AndreasK: but when there is, it's an amazing package
08:30:03 <shapr> Clint: Someone was just telling me that Golang includes a webserver with TLS and HTTP/2, so I was wondering is that same sort of thing was easily available in stack
08:33:32 <Benzi-Junior> hey, I have been working with the vector library and can't find how to make an instance of the Unbox typeclass 
08:35:32 <lyxia> Are you supposed to
08:36:20 <Benzi-Junior> lyxia: yes I need to be able to take advantage of unboxed vectors
08:36:33 <Tuplanolla> What are you unboxing, Benzi-Junior?
08:36:34 <shapr> Clint: yes thanks, warp-tls looks like what I wanted!
08:40:49 <Gurkenglas> Tuplanolla, wouldn't that cata rewrite only work if each application of a added exactly one layer?
08:40:57 <Benzi-Junior> Tuplanolla: essentially I have a type "DataBlock a" which is a record with a value of type "a" and some additional  all which is of a type that can be unboxed 
08:41:24 <Tuplanolla> ...no, Gurkenglas?
08:43:11 <lyxia> Benzi-Junior: http://lpaste.net/350575
08:43:53 <Tuplanolla> Alternatively use `newtype DataBlock a = DataBlock (a, F a, B, ...)` for which you can derive `Unbox` by unwrapping, Benzi-Junior.
08:46:44 <jmnoz> Is there a way of checking why a package is not in current stackage lts?
08:52:56 <Benzi-Junior> lyxia: is that code example by you, or where did you find it ?
08:53:00 <Clint> jmnoz: you could sift through https://github.com/fpco/stackage/issues
08:54:32 <lyxia> Benzi-Junior: I just made it up
08:55:43 <jmnoz> Clint: thanks
08:58:54 <lyxia> Benzi-Junior: Have you seen http://hackage.haskell.org/package/vector-th-unbox
09:34:04 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706'
09:34:04 --- topic: set by glguy on [Fri Dec 09 10:59:28 2016]
09:34:14 <Wizek_> Hey! Anyone knows of a simple way to evaluate and display 2 lazy lists side-by-side? E.g. as two columns. And in a way that finding a thunk that takes long to evaluate in of the lists doesn't block rendering the other list?
09:37:47 <ClaudiusMaximus> i suspect not blocking requires threads, ie forkIO, deepseq, evaluate, and inter-thread communication (MVar, Chan, STM, ...)
09:38:27 <ClaudiusMaximus> Wizek_: so "simple" seems to be ruled out
09:40:14 <chetshah> Hello all, I am a haskell beginner and was just now grokking sequence function. Got caught up with a simple question.
09:40:31 <ertes> Wizek_: the side-by-side requirement actually makes this much more complicated
09:40:33 <chetshah> sequence [Just 2, Just 3, Just 4]
09:41:37 <chetshah> would return Just [2,3,4] but as soon as I put a nothing inside the whole thing returns nothing.
09:41:53 <ertes> Wizek_: if you don't need it side-by-side, a very simple solution using separate threads could feed you values as they are done evaluating
09:43:50 <chetshah> Ah If I think in terms of desugared do notation, getting nothing anywhere in between would probably return a nothing in the end.
09:44:23 <ertes> chetshah: yes, that's the semantics of the Maybe monad
09:44:52 <chetshah> Yup, got it.
09:45:08 <monochrom> and of sequence being a compact way to write out "do { x1 <- Just y1; ... "
09:45:22 <ertes> > liftA2 (,) (Just 2) (Just 3)
09:45:27 <lambdabot>  Just (2,3)
09:45:31 <ertes> > liftA3 (,) (Just 2) (Just 3) (Just 4)
09:45:33 <lambdabot>  error:
09:45:33 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò(Integer, Integer)‚Äô with ‚ÄòInteger -> d‚Äô
09:45:33 <lambdabot>        Expected type: Integer -> Integer -> Integer -> d
09:45:40 <ertes> > liftA3 (,,) (Just 2) (Just 3) (Just 4)
09:45:43 <lambdabot>  Just (2,3,4)
09:45:48 <Wizek_> ertes, Hmm, what do you mean by 'feed'? 
09:47:01 <Wizek_> ClaudiusMaximus, Yes, I was thinking that it could be done with forkIO and MVar.
09:48:57 <Wizek_> ertes, Yeah, it might make sense to simplify by relaxing the side-by-side requirement. Then I could use a function that takes two lists and merges them in a way that it always takes values from the one that is ready. e.g. `merged <- mergeNonBlocking l1 l2`
09:52:00 <MarcelineVQ> Wizek_: I don't know if it's appropriate here, or if it's not granular enough for the problem but there's http://felsin9.de/nnis/ghc-vis/ which is pretty interesting
09:53:59 <geekosaur> Wizek_, you would probably use Chan instead of raw MVar-s
09:54:03 <Gurkenglas> Wizek_, forkMapM__ (mapM putStrLn) (repeat [0..])
09:55:45 <ertes> Wizek_: https://gist.github.com/esoeylemez/db071c4d4193e75baa22d2cc0c1332fb
09:57:34 <ertes> Wizek_: parQueue [list1, list2] $ \qs -> ‚Ä¶ foldr (<|>) empty (zipWith (\n q -> (n, readTQueue q)) [1..] qs) ‚Ä¶
09:57:37 <ertes> something like that
09:57:52 <Gurkenglas> foldr (<|>) empty = asum
09:58:00 <ertes> :t asum
09:58:02 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
09:58:08 <ertes> cool, thanks!
09:58:27 <ertes> that actually simplifies a lot of my code =)
09:58:42 <ertes> oh, and it's wrong
09:58:59 <ertes> ah, no, it's not
09:59:51 <ertes> yes, it is‚Ä¶  i zipped too early
09:59:58 <ertes> anyway, you get the idea
10:00:46 <Wizek_> not yet, but taking a look at it :)
10:01:10 <ertes> foldr (\nc more -> sequence nc <|> more) empty (zip [1..] qs)
10:01:49 <ertes> :t sequenceA :: (Applicative f) => (c, f a) -> f (c, a)
10:01:51 <lambdabot> Applicative f => (c, f a) -> f (c, a)
10:01:55 <ertes> yeah, there we go
10:02:01 <ertes> the last one should be correct
10:03:07 <ertes> that's a transaction that succeeds each time a new queue item is found, and it gives you both the index (1 or 2 in your case) and the item
10:03:17 <Gurkenglas> asum $ map sequence $ zip [1..] qs
10:04:08 <ertes> i should practice thinking outside the foldr =)
10:04:09 <Gurkenglas> asum $ zipWith (fmap . (,)) [1..] qs -- who needs traversables
10:07:52 <ertes> i seriously had to resist using the kan-extensions package there
10:08:09 <Gurkenglas> do it
10:08:54 <ertes> parQueue :: (Foldable f, Traversable g) => f (g a) -> Codensity IO [TQueue a]
10:14:06 <ertes> parQueue = foldl go (pure []) where go qs xs = do q <- liftIO newTQueueIO; let { evalToQ = traverse (\x -> x `seq` atomically (writeTQueue q x)) }; Codensity (withAsync (evalToQ xs)); fmap (q :) qs
10:15:31 <ertes> (that's so weird‚Ä¶  i'm finding more and more use cases for non-strict foldl)
10:16:33 <Gurkenglas> I was there for one, wasn't that one wrong? Were there others?
10:17:17 <MarcelineVQ> jackhill:  try this out   instance Arbitrary a => Arbitrary (DecimalRaw a) where arbitrary = Decimal <$> arbitrary <*> arbitrary
10:17:35 <MarcelineVQ> allthough without tweaking (like using sized) most numbers will be quite small due to large exponents, despite arbiutrary for Word8 preferring small numbers :X
10:21:45 <ertes> Gurkenglas: hmm?  i think the only other one i mentioned here was 'reverse'
10:22:10 <MarcelineVQ> jackhill: this may be better   arbitrary = Decimal <$> arbitrary <*> fmap getLarge arbitrary
10:22:11 <Gurkenglas> ertes, don't you want to run more only once at the end, when all the Queues are assembled, instead of in each step? (qs is an IO action, not a list)
10:22:44 <Gurkenglas> (ah no it was <kuribas> heh, I actually found a use for non-strict foldl.)
10:23:28 <MarcelineVQ> jackhill: that would need   instance (Bounded a, Integral a) => Arbitrary (DecimalRaw a) where
10:23:33 <Gurkenglas> And why not just return a [TQueue a]?
10:24:16 <ertes> Gurkenglas: i think the two variants should actually be equivalent‚Ä¶  and i am just returning a [TQueue a]
10:24:25 <ertes> in the Codensity variant
10:24:33 <Gurkenglas> Right, but why the Codensity variant?
10:24:51 <ertes> it streamlines the withAsyncs
10:25:18 <ertes> makes the code look sequential instead of cascading
10:28:25 <AndreasK> ertes: I've never used the List Monad before but I can see how it would be similar :)
10:31:48 <guillaum2> Is there a way to extend an ADT by adding new cases. For example, I have an ADT such as as `data ADT = A | B | C` and I want a new ADT which is similar but also introduce `D`. The simplest way I'm thinking about is `data ADT' = WrapADT ADT | D`, but that's painful to use.
10:32:33 <lyxia> There's no general way to do that.
10:33:01 <lyxia> guillaum2: What do you need that for
10:34:42 <AndreasK> guillaum2: You could use Either ADT D
10:34:49 <Gurkenglas> ertes, https://gist.github.com/esoeylemez/db071c4d4193e75baa22d2cc0c1332fb#gistcomment-1958555
10:34:56 <guillaum2> lyxia: context, I'm doing Advent Of Code. This year there is a 3 part challenge which introduce an assemly language on part 1, then extend it on part 2 and 3. I defined an ADT for the assembly language of part 1 and I'm looking for a clean solution.
10:34:57 <AndreasK> But thats probably even more annoying to use
10:36:38 <ertes> Gurkenglas: so you want to rely on garbage collection and blocking to kill those threads?
10:37:07 <ertes> my version makes sure that when the continuation returns all threads are killed
10:38:03 <Gurkenglas> Oh so that's what withAsync's good for? Cool. Hmm that documentation only makes sense once you've already understood it.
10:38:42 <guillaum2> AndreasK: yes, actually the Either solution is similar, ever less "typed" ;)
10:38:48 <ertes> Gurkenglas: yeah‚Ä¶  though not applicable to this use case async also lets you kill the threads properly or wait for them to terminate
10:39:19 <Gurkenglas> But that wasn't the important part, updated the comment
10:39:49 <AndreasK> guillaum2: What is wrong with just adding D to the original ADT?
10:40:13 <ertes> Gurkenglas: that one doesn't work at all, because you're immediately returning from withAsync‚Ä¶  by the time the list of queues is returned all threads will already have been killed
10:40:46 <guillaum2> AndreasK: That's a good question ;) It does not really feel right for me, because it forces me to handle the new case in part 1 even if they are not needed.
10:40:56 <Gurkenglas> wut I thought the first argument finishing aborts the second
10:41:09 <guillaum2> AndreasK: in short, I have the feeling that it does not compose well, separation of concern, bla bla...
10:41:23 <ertes> Gurkenglas: you *need* CPS here (or split this up into starting/stopping)
10:42:05 <ertes> Gurkenglas: withAsync c1 k1 >> withAsync c2 k2  -- by the time the second withAsync is reached the thread that runs c1 will already have received a ThreadKilled exception, because that's what happens when k1 returns
10:43:09 <ertes> Gurkenglas: this is the correct way to let both threads run at the same time:  withAsync c1 (\r1 -> withAsync c2 (k r1))
10:43:21 <ertes> now when k returns both threads are killed
10:44:09 <AndreasK> guillaum2: I would just clone the project I used for Part 1 and then adjust it to work for Part2, especially if the parts have differing requirements as usually the case.
10:44:23 <Gurkenglas> go's last argument and its return type must be equal due to the usage in foldr. go's return type is in IO. qs is used as a list. How?
10:45:00 <ertes> Gurkenglas: the result of the fold is a function of type ([TQueue a] -> IO r)
10:45:06 <ertes> go xs more = \qs -> ‚Ä¶
10:45:37 <guillaum2> AndreasK: actualy that's the solution I initially took. Well, nice to ear that I'm not missing something smart here. Thank you.
10:45:40 <jackhill> MarcelineVQ: thanks!!
10:46:25 <Gurkenglas> Ah. No such thing as a definite last argument in polymorphic (a -> b).
10:46:27 <AndreasK> guillaum2: It really only makes sense to reuse the solution if it's a clean subset. Thats seldom the case with coding puzzles imo
10:46:59 <ertes> Gurkenglas: it's really just a stateful fold: http://ertes.eu/tutorial/foldr.html#stateful-folds
10:47:06 <Gurkenglas> And the CPS is so you know when the TQueues are no longer used so you can clean up the threads that might still be generating.
10:48:27 <ertes> Gurkenglas: yeah, which amounts to just returning from the innermost withAsync (at which point the whole cascade is cleaned up)
10:49:33 <ertes> the innermost withAsync consists of just giving the user's continuation (k) the final state (the [TQueue a])
10:50:01 <ertes> because (more (q : qs) = k (q : qs)), the base case of the fold
10:55:08 <lyxia> guillaum2: http://lpaste.net/350578 is quite awkward looking but might work.
10:56:25 <Gurkenglas> Why do you want non-strict foldl up there?:t traverse $ \xs -> do q <- liftIO newTQueueIO; Codensity $ Control.Concurrent.Async.withAsync $ xs `for` \x -> x `seq` GHC.Conc.Sync.atomically (writeTQueue q x); return q -- ertes
10:56:39 <Gurkenglas> Dammit, meant to remove that pre-:t-part
10:56:42 <Gurkenglas> :t traverse $ \xs -> do q <- liftIO newTQueueIO; Codensity $ Control.Concurrent.Async.withAsync $ xs `for` \x -> x `seq` GHC.Conc.Sync.atomically (writeTQueue q x); return q
10:56:44 <lambdabot> (Traversable t1, Traversable t) => t (t1 a) -> Codensity IO (t (TQueue a))
10:56:49 <guillaum2> AndreasK: actually, you are right, I may have biased myself due to the puzzle context.
10:57:56 <guillaum2> I have another question for today. Is there a way to get profiling INSIDE ghci ?
10:58:29 <emmanuel_erc> Has anyone here taken a look at the structured haskell mode codebase?
10:59:12 <benzrf> hey
10:59:26 <benzrf> has anybody written some kind of graphical tree editor in haskell?
11:00:02 <benzrf> that is to say, some code that takes a tree value, displays a graphical representation, and allows you to do things like drag one node to another in order to swap them
11:00:35 <benzrf> i don't necessarily need a specific implementation, but - if this exists, then the abstractions involved in it would also be useful for the thing i'm writing
11:00:54 <benzrf> so i'm more interested in good approaches to that problem than specific implementations
11:02:00 <cheater> hi
11:02:38 <cheater> in OCaml if you want to use ModuleName.(=) you can do ModuleName.(a = b), is something like this possible in Haskell too?
11:03:36 <monochrom> = may be a bad example
11:03:47 <cheater> make it ~~~
11:03:53 <monochrom> but write like 5 Prelude.+ 6
11:03:55 <Wizek_> chameco,  1 ModuleName.== 2 
11:04:10 <cheater> that's still infix? hmm
11:04:15 <benzrf> cheater: yup
11:04:20 <benzrf> > 1 Prelude.+ 2
11:04:21 <cheater> still, it's not possible to do the parens thing right?
11:04:23 <lambdabot>  3
11:04:25 <Wizek_> You can make it prefix too:
11:04:26 <benzrf> it is not
11:04:33 <cheater> Wizek_: i know
11:04:34 <monochrom> why parens?
11:05:05 <cheater> monochrom: because you might want more than just 1 operator or function.
11:05:14 <lyxia> cheater: you can't open a module locally in Haskell.
11:05:20 <monochrom> I don't understand.
11:05:32 <Gurkenglas> ertes, when someone uses lowerCodensity on that and binds the result into a list of queues, won't he be in trouble because the queue fillers are killed as soon as they're done being started?
11:05:59 <cheater> monochrom: in OCaml you can do MyModule.(a ~~ b &^& c ~!_ d) when all of those operators are in MyModule.
11:06:14 <monochrom> yikes
11:06:23 <cheater> why is that yikes
11:06:26 <cheater> i think that's pretty good
11:06:30 <geekosaur> Haskell doesn't support that, no
11:06:42 <cheater> lyxia i don't think opening modules locally is necessary
11:06:53 <geekosaur> for one, the equivalent Haskell syntax is (MyModule.~~) etc.
11:06:56 <lyxia> Isn't it exactly what this syntax does
11:07:12 <lyxia> Within the parentheses, MyModule is open.
11:07:39 <benzrf> thats kind of interesting cheater
11:07:42 <benzrf> i can see how itd be useful :)
11:08:01 <cheater> i just like how in the parens you can set up some sort of DSL and it's nice
11:08:05 <geekosaur> (that does mean the syntax is available, since I don't think `Foo.(` is a valid token sequence currently)
11:08:10 <cheater> no need for prefixes everywhere
11:08:14 <Wizek_> cheater, You have some more options: e.g. import qualified with a short name then you can (a M.~~ b M.&^& c M.~!_ d)
11:08:24 <cheater> Wizek_: i know of those too
11:08:33 <monochrom> OK, suppose I see the code MyModule.(a + b & c). Am I suppose to just know that the + there refers to Pervasive's +, only the & there refers to MyModule's &?
11:08:41 <lyxia> Oh I know, you can define a record of operators, then pattern match with RecordWildCards
11:08:49 <cheater> but that's not really cool for a file with a lot of modules being used especially ones that define the same syntax
11:08:54 <EvanR> that syntax doesnt make clear which operators are being imported
11:08:58 <Wizek_> lyxia, that works?
11:08:59 <Wizek_> :D
11:09:03 <EvanR> you know because you just wrote it
11:09:12 <EvanR> but you didnt just write it next month
11:09:14 <cheater> monochrom: yes
11:09:16 <cheater> monochrom: you are
11:09:29 <monochrom> That is why my yikes.
11:09:37 <benzrf> EvanR: that happens anyway every time you import non-qualified
11:09:42 <EvanR> i would appreciate a local module open which made it explicit
11:09:47 <cheater> monochrom: in practice it's not as bad as you seem to think it is
11:09:51 <benzrf> EvanR: that's what the syntax *is*
11:09:54 <benzrf> it *is* explicit
11:09:59 <EvanR> no
11:10:04 <monochrom> "in practice" is a lot of YMMV, you know.
11:10:14 <EvanR> if you import a module with a + in it, theres only one
11:10:25 <Gurkenglas> So this is an intermediate yikes between MyModule.+ and import MyModule at the top?
11:10:27 <EvanR> whether you explicitly import it or not
11:10:28 <lyxia> data Ops = Ops { (+-) :: bla -> bla -> bla, (-+) :: bla -> bla -> bla }   ops = Ops { {- define operators -} }     then somewhere in the middle of an expression:  let Ops{..} = ops in (bar +- (foo -+ baz))
11:10:42 <benzrf> lyxia: oh wow haha
11:10:42 <cheater> EvanR: i'm working with code i didn't write and which i don't really understand but the thing monochrom came up with is not an issue at all.
11:10:55 <EvanR> benzrf: by explicit i mean MyModule(+,&,~).(...)
11:10:58 <cheater> EvanR: and it's a large, complex code base with very sparse doc
11:10:59 <benzrf> oh
11:11:15 <benzrf> cheater: in OCaml, do you still get an error when it's ambiguous
11:11:26 <cheater> benzrf: i don't really know
11:11:29 <cheater> :D
11:11:34 <cheater> probably do
11:11:36 <cheater> *shrug*
11:11:37 <benzrf> e.g., if we have "a + b" valid because there is a (+) in scope, and then we do Foo.(a + b) where (Foo.+) exists
11:11:44 <EvanR> eh whatever, the symbol + is obvious from context
11:11:49 <EvanR> no matter what
11:11:52 <EvanR> its addition
11:11:52 <Wizek_> lyxia, nice!
11:11:58 * EvanR leaves
11:12:01 <cheater> benzrf: that's not ambiguous
11:12:10 <cheater> obviously Foo's + will take precedence
11:12:20 <monochrom> I am OK with shadowing.
11:12:23 <EvanR> its not obvious Foo even has a +
11:12:29 <benzrf> ^
11:12:35 <benzrf> *that* is the one case i'd have concerns about
11:12:38 <cheater> no, it's also not obvious Foo has any other things unless you've read the docs
11:12:41 <EvanR> ive definitely been screwed by this before
11:13:02 <benzrf> everything else would already basically be syntactic sugar for haskell's existing name resolution rules
11:13:05 <cheater> you can't just willy nilly type out code using libraries guessing what they do and do not have
11:13:06 <EvanR> personally i like code to be readable without docs as much as possible
11:13:41 <cheater> that's a question of making your module's api nice, not a question of making the syntax overly restrictive
11:13:44 <EvanR> think decoder rings
11:13:48 <benzrf> but this would introduce a case where it's not clear from a glance where a name came from
11:13:55 <monochrom> I support reading the docs oneself. But I also support the author telling the reader which doc to read.
11:13:57 <benzrf> cheater: well no, here's the problem
11:14:33 <benzrf> cheater: the problem is - if i see "a %*% b", and there's no mention of (%*%) in my file, i know it must be imported from one of the modules i imported unqualified, so i can go find it
11:14:33 <EvanR> just have the IDE tell you where the symbol came from ;)
11:14:39 <cheater> i think it's fairly simple, if you're using a symbol being used elsewhere (like +), make sure you only do that if it makes sense for the data type being used in your module
11:15:00 <cheater> and then the person will read it and go like
11:15:11 <benzrf> cheater: but if i see "Foo.(a + b %*% c)", and there *is* a (%*%) in my file, it's suddenly unclear whether or not it was imported from Foo
11:15:17 <monochrom> In production Haskell (ha ha like I write a lot of product code) I write like "import System.Environment (getArgs)". The hope is that when you see me mentioning "getArgs" you can go to the top and see my explicit import and know whose doc you should look up.
11:15:19 <benzrf> and i dont know if i have to go look it up or not
11:15:20 <cheater> "oh he uses +, and it's inside the List module, it's probably concatenation"
11:15:29 <cheater> and then what do you know, it actually is
11:15:59 <EvanR> its unfortunate but a lot of crazy operators arent so obvious
11:16:03 <cheater> whereas if you use + for things like, say, hashes, it doesn't really make sense at all to add hashes
11:16:16 <cheater> so it must be something else from somewhere else (your external scope)
11:16:19 <EvanR> does it make sense to ~~ hashes
11:16:26 <cheater> i don't know, does it?
11:16:29 <EvanR> i dont know
11:16:34 <cheater> is ~~ really used often enough to worry about this?
11:16:42 <EvanR> ok %%
11:16:57 <monochrom> + is an example favourable to your point. But there is also &, which actually there are several conflicting uses on Hackage.
11:16:57 <cheater> it's like worrying you'll be hit by a meteor and bit by a shark at the same time, and you won't know what you died of
11:17:03 <monochrom> And not to mention %
11:17:08 <EvanR> i am griping about imports being explicit, not whether symbols used are obvious
11:17:42 <monochrom> No, the meteor and shark thing is not an analogy. It's a hyperbole.
11:17:43 <cheater> well EvanR i dunno, maybe it makes sense to make an option for imports to be explicit. i mean in haskell i use only explicit imports, because otherwise the namespace pollution is just too much too handle
11:17:44 <EvanR> haskell has way too many common functions and operators to claim our code is "just obvious", unfortunately
11:17:48 <cheater> it is monochrom
11:17:51 <cheater> you are right
11:18:18 <cheater> but on the other hand i think it would be a nice way to do things like not only use DSLs but also select class instances
11:18:24 <cheater> this sort of syntax that is
11:18:39 <benzrf> cheater: for what it's worth, i think the syntax as-is would be an improvement
11:18:40 <EvanR> yes a local context, a local world
11:18:50 <benzrf> i'm just nitpicking the one thing i;d change about it :)
11:19:00 <benzrf> (i.e., not overriding the existing scope)
11:19:03 <EvanR> another thing you can do is
11:19:17 <EvanR> world = Foo(+, ~~, !, shenanigang)
11:19:21 <EvanR> world.(...)
11:19:40 <cheater> yea you could do that too
11:19:52 <cheater> but then if that's necessary then it's just boilerplate
11:19:56 <cheater> and that's terrible then
11:20:09 <EvanR> "necessary" ?
11:20:19 <cheater> yeah, if you have to do that, rather than just having the option
11:20:19 <EvanR> thats an instance of factoring out repetitive code
11:20:24 <cheater> i mean if i just want to go and say
11:20:27 <EvanR> no, optional
11:20:50 <EvanR> you have the option of repeating the same big lambda in many places too, by RT
11:20:53 <cheater> BASIC.(100 PRINT "FOO") then i don't want to have to explicitly say what of BASIC i'll be using everywhere
11:21:19 <EvanR> (\x -> i dont have to factor this out of 9 places (really 2 places) if i dont want to)
11:21:30 <cheater> ya
11:22:15 <EvanR> for secrely shadowed stuff, theres the IDE argument
11:22:33 <Athas> Anyone know if any interesting FP/Haskell stuff will be at FOSDEM?
11:22:56 <EvanR> but code readable without an IDE is an overlooked thing that is good
11:23:45 <cheater> i never use an IDE and as i said, tricky shadowing isn't an issue
11:24:03 <EvanR> when you have the code fresh in your mind thats a different world
11:24:10 <cheater> in fact i'm reading this code in git log
11:24:16 <cheater> so there isn't even highlighting
11:24:40 <cheater> yet i can still understand absolutely everything even without the context of surrounding code (just a few lines of context as usual in git diffs)
11:24:57 <cheater> and the code was written by someone else
11:24:58 <cheater> a long time ago
11:25:13 <EvanR> is the api doc for the opened module fresh in your mind
11:25:26 <cheater> no i haven't even looked at it
11:25:45 <EvanR> a guy told me once that he preferred not to code because he couldnt remember very much at once
11:25:53 <EvanR> like, to memorize entire libraries api
11:25:59 <cheater> yeah i can't do that either
11:26:02 <monochrom> You know what, I support the IDE argument, but I take it to the extreme, more extreme than any IDE argument you've heard.
11:26:05 <cheater> never could
11:26:13 <johnw> monochrom: what extreme is that?
11:26:18 <EvanR> i said, you obviously "just look at the docs"
11:26:18 <cheater> monochrom that's not an argument that's a pamphlet
11:26:24 <EvanR> but now im not so sure
11:26:26 <monochrom> Because for example I want "plain text file" to be abolished too
11:26:36 <cheater> so do i
11:26:39 <cheater> i wish that could work
11:27:02 <Tuplanolla> Abolish "file path" too while you're at it.
11:27:04 <cheater> i wish we could abolish the notion of "list of characters"
11:27:07 <EvanR> lol
11:27:22 <cheater> as well as the finite, one-dimensional topology of code
11:27:27 <EvanR> while we are restructuring the fabric of all computer lore, fix the file path thing
11:27:33 <cheater> code should have any topology it wants
11:27:49 <cheater> it should be a free graph with no beginning or end
11:28:04 <EvanR> graph :(
11:28:07 <cheater> especially good if you're writing recursive code
11:28:37 <EvanR> "i think in graphs"
11:28:45 <Tuplanolla> A proper tagged file system would make life so much nicer.
11:29:16 <monochrom> Haskell code is actually a call graph. The Haskell reports take this view. And I don't mean the graph you do evaluation on. I mean call graph, the graph you do type-checking on.
11:29:21 <Tuplanolla> Perhaps I'd then stop losing files every day.
11:29:38 <EvanR> manually adding tags will get tedious
11:29:44 <EvanR> you really want AI
11:30:07 <cheater> monochrom: i don't even know what a call graph is, but it's nice that there's a graph in there somewhere. i support graphs.
11:30:08 <Tuplanolla> Yes; both are needed.
11:30:15 <EvanR> AI wont be 100% reliable, in which case you need some solid theory, such as file paths ;)
11:31:06 <monochrom> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-890004.5.1
11:32:40 <EvanR> i was almost on board with "any topology you want" until it was "as long as its a graph"
11:33:05 <monochrom> code is discrete. so you will end up with a graph.
11:33:26 <monochrom> If you try to sprinkle code over a torus, you will still get a graph.
11:33:33 <monochrom> If you try to sprinkle code over a Klein bottle, you will still get a graph.
11:33:46 <monochrom> If you try to sprinkle code over a Julia set, you will still get a graph.
11:33:50 * shapr sprinkles code on monochrom
11:33:55 <EvanR> the semantics of code arent discrete
11:34:19 <MarcelineVQ> if you sprinkle code over monochrom you get a monograph
11:34:36 <monochrom> No no no, the domain you use for the semantics of a whole language isn't discrete.
11:34:37 <shapr> oh wow!
11:35:08 <monochrom> But each program is still discrete. Hell, the semantics of one program is just a single point.
11:35:26 <monochrom> hahaha MarcelineVQ
11:36:26 <cheater> monochrom: that's exactly what i mean with the topology vs graph
11:37:13 <EvanR> even if its technically a graph, that doesnt mean a graph is ergonomic to think about
11:37:20 <EvanR> consider "the whole" graph
11:37:29 <cheater> you're confused
11:37:29 <EvanR> like a map of the internet, thats not helpful
11:37:41 <cheater> we're talking about the fact that a text file is a list of chars
11:37:50 <cheater> we would like it to be more than a list
11:37:51 <EvanR> you are?
11:37:54 <cheater> yeah
11:37:58 <EvanR> thats not helpful either
11:38:02 <cheater> no, it's not
11:38:09 <cheater> unless you start making a distinction
11:38:12 <EvanR> we still dont think of source as list of char anyway
11:38:18 <cheater> it's useful for considering that distinction
11:38:50 <cheater> the distinction is me and monochrom would not like to have a list of chars any more, and the most general thing you can build out of chars is a graph
11:38:51 <EvanR> paredit etc
11:39:07 <cheater> paredit is nice
11:39:09 <cheater> i've never used it
11:39:15 <cheater> but it's kinda in the right direction
11:39:16 <EvanR> source = list of chars seems like a straw man
11:39:21 <cheater> but it's still a linear topology
11:39:37 <cheater> you can't use any other topology, other than what can fit inside a list
11:39:47 <EvanR> what, its a tree
11:40:01 <cheater> a piece of code in paredit cannot loop in on itself
11:40:10 <cheater> you cannot share pieces of code
11:40:12 <EvanR> its still not a list
11:40:24 <cheater> no, but i never said it was a list, i just said it could fit inside a list
11:40:31 <cheater> you can fit a tree inside a list, that is a fact
11:40:46 <cheater> you could encode it using parens like in lisp
11:41:04 <EvanR> you can encode a cyclic graph using a list
11:41:50 <cheater> there's a distinction between levels of power you need to encode a tree and a cyclic graph that i cannot precisely describe
11:42:09 <EvanR> youre making negative progress forcing me to come down and comprehend all these primitive forms of concrete syntax!
11:42:10 <monochrom> I don't like encodings.
11:42:20 <EvanR> which youre arguing against
11:42:30 <cheater> i think the best way to say it is that a tree is homeomorphic to a list whereas a graph with cycles isn't
11:42:52 <cheater> if you allow blowing up (like baloons)
11:42:57 <EvanR> its homotopy equivalent
11:43:11 <cheater> no it isn't and that's the point
11:43:35 <cheater> EvanR me and monochrom were talking about concrete syntax, that was the whole point
11:43:43 <EvanR> a tree and a list are
11:43:50 <cheater> ok
11:43:53 <cheater> yeah maybe
11:44:02 <cheater> i don't remember what a homotopy really is
11:45:39 <EvanR> lets try and find a practical virtue to any of this, how about locality
11:46:00 <nitri-xmas> He probably meant it in the sense of Homeomorphism, which we see in graph theory.
11:46:55 <EvanR> the big picture is too complicated, but can we get a useful account of whats going on by looking at code position X and its neighbors
11:46:57 <monochrom> Locality is when you give up your human ability of seeing the whole picture, and gain the computer's tunnel vision and be able to just see one vertex and one edge at a time :)
11:48:44 <EvanR> seeing a very big picture might be why were dwelling on list of characters
11:49:17 <cheater> no we're dwelling on a list of characters because punched cards had to fit in boxes nicely
11:49:26 <monochrom> :)
11:49:28 <EvanR> now were expanding
11:51:30 <monochrom> Be careful about "big holistic picture". Sometimes, what you think of as a big holistic picture, is just one local node in an abstract syntax tree.
11:51:54 <cheater> or a hole
11:52:54 <monochrom> For example I may write "foldr <1000-character long lambda here> <100-character long expression here> <something about foldl and is 5000-character long>>
11:53:07 <maru`> please help me this  code  http://lpaste.net/350579  ,   I tried to convert do notation  to >>=
11:53:24 <maru`> doesn't  compile ^^^
11:53:35 <EvanR> s/>>/>"/
11:53:37 <monochrom> You will say, that's a humongous blob of code, but the "big picture gist" is that I'm using a catamorphism.
11:53:40 <geekosaur> you still need the "return"
11:53:45 <ertes> Gurkenglas: you're right, with the codensity variant i actually don't even need the fold‚Ä¶  the threads are killed once the Codensity is finished
11:53:45 <kadoban> maru`: You left off the return
11:53:56 <geekosaur> also you should include the full error message when you ask for this kind of help
11:54:16 <maru`> oops   yes  :-)
11:54:25 <monochrom> Correct, but unfortunately the "big picture" of "foldr x y z" is but a local tree node in the abstract syntax tree.
11:54:28 <ertes> Gurkenglas: so as part of lowerCodensity's final action, because that's when its continuation returns
11:55:10 <monochrom> This kind of "global holistic" but really local view is the foundaation of doing algebra tricks to your code. Or my code, YMMV.
11:55:42 <monochrom> For example if you do foldr fusion, you take this "global" local view.
11:56:06 <ertes> Gurkenglas: lowerCodensity (Codensity (withAsync c) >>= \r -> Codensity (f r)) = withAsync c (\r -> f r pure)
11:56:23 <ertes> Gurkenglas: so basically (>>=) encodes cascading in the CPS sense
11:59:04 <geekosaur> maru`, hm, actually I am surprised that compiles because module names should always start with an uppercase letter
12:26:20 <hashme> I noticed that there are two types of compilation messages by ghc - (1)filename:line_number:column_number:    message and (2)filename:line_number:column_number:Warning: message
12:26:32 <hashme> y question is are these the only two types that are there?
12:26:40 <hashme> that is error and warning
12:26:52 <hashme> Or are there more types of compilation messages?
12:26:59 <hashme> thanks! :)
12:27:04 <Tuplanolla> There's one more for panics, hashme.
12:27:53 <hashme> Ah :) Tuplanolla: thanks a lot! is documented somewhere - the types of messages? at least in GHC?
12:28:05 <hashme> Are you sure there is only one more - panics?
12:28:22 <hashme> I want to know the different output formats so :)
12:28:50 <Tuplanolla> I'm quite sure. However you can check the user guide to see if it mentions this (probably not).
12:29:50 <hashme> I checked a bit - it was hard to find for some reason :3 these things should be documented
12:31:07 <Tuplanolla> Right, well, a panic has the format "ghc: panic! (the 'impossible' happened)".
12:32:17 <kuribas> Gurkenglas: you found use for non-strict foldl?
12:34:05 <kuribas> Gurkenglas: care to share it?
12:34:07 <sphinxo> so I have a function ppType :: (Fresh m) => Type -> m Doc
12:34:35 <sphinxo> and I want to print the returned Doc
12:35:35 <sphinxo> How do I do this? _ <- liftIO $ (print . render . ppType) <Type>
12:35:43 <sphinxo> something like that? ^^
12:36:07 <geekosaur> you really need to sit down and learn monadic I/O
12:37:13 <geekosaur> do x <- ppType whateverType; liftIO $ print (render x)
12:39:21 <sphinxo> thanks
12:41:53 <kuribas> or ppType whateverType >>= liftIO . print . render
12:43:02 <quchen> Is Danien Gr√∂ber here sometimes (one of the ghc-mod maintainers)?
12:43:18 <quchen> DanielG on Github, if that helps
12:49:21 <maru`> why  this   doesn't  work  in  repl  (+1) <$> (Just 1) <*> (Just 2)  
12:49:38 <maru`> (||) <$> (Just True) <*> (Just True)    is  ok
12:49:53 <kuribas> maru`: (+1) is unary
12:50:12 <maru`> oh  I see
12:53:12 <ertes> sphinxo: i faintly remember giving you a link to an I/O tutorial‚Ä¶  did it not help?
12:53:40 <ReinH> maru`: Why doesn't (+1) 1 2 work??
12:53:55 <ReinH> I really need to fix my stuck ? key. :(
12:54:12 <ReinH> It makes me sound incredulous when I don't intend to be...
12:54:12 <quchen> Remap it! Mine is on caps+H :-)
12:54:18 <ReinH> hah
12:54:23 <codedmart> What is the best way to go from [(a,b,c,d)] to [(b,c,d)]. I am just mapping and de-structuring.
12:54:38 <codedmart> Is there a better way?
12:54:45 <ertes> codedmart: \(a,b,c,d) -> (b,c,d)
12:54:45 <quchen> codedmart: map (\tuuuuple -> tuuuple)
12:54:48 <ReinH> codedmart: Is it always exactly [(a,b,c,d)]?
12:55:22 <codedmart> ertes: that is what I am doing now.
12:55:26 <ReinH> codedmart: There isn't a better way.
12:55:31 <ertes> codedmart: that's also the best way
12:55:36 <quchen> The question is whether a 4-tuple is a good data type for you, and whether a custom type would suit your needs better.
12:55:47 <codedmart> ReinH: yes it is always the same.
12:55:57 <codedmart> Thanks!
12:56:25 <ertes> codedmart: if you're constructing the 4-tuple, you could‚Ä¶  well‚Ä¶  not construct a 4-tuple =)
12:56:41 <ReinH> Haskell doesn't have good tools for working with large (i.e., more than 2 element) tuples, perhaps to discourage people from using them.
12:56:44 <quchen> I don‚Äôt want to stuff my algebraic blindness article down everyone‚Äôs throats, but ‚Ä¶ okay, that‚Äôs exactly what I want, I just don‚Äôt know how to do it in a way that does not sound rude ;-)
12:56:58 <ertes> codedmart: snd :: (a, (b, (c, d))) -> (b, (c, d))
12:57:08 <ReinH> quchen: You can shove it down m... I mean, I would like to read it.
12:57:18 <quchen> https://www.reddit.com/r/haskell/comments/5hksnn/algebraic_blindness/
12:57:26 <ReinH> ertes: heh :)
12:57:39 <quchen> The discussion on Reddit is very constructive and worth reading
12:57:42 <ertes> 2-tuples are really the only convenient tuples in haskell‚Ä¶  anything larger and you should either use a custom type, or you should use binary products (the way i have done it above)
12:57:45 <ReinH> quchen: It seems to be doing well on the reddits :)
12:58:08 <c_wraith> quchen, that is an odd sentence :) 
12:58:19 <quchen> c_wraith: In what sense?
12:58:48 <c_wraith> most discussions on reddit (the whole site) are not. 
12:59:02 <quchen> Ah. Yes, that‚Äôs why i mentioned it specifically.
12:59:20 <quchen> There‚Äôs always that guy that at least says that Haskell is academic nonsense.
12:59:36 <ertes> i think the article the reddit thread links to is missing the point of boolean blindness
12:59:38 <quchen> Which is nonsense of course, because most of what I hear from Haskell and academia is Conor making jokes about it.
12:59:50 <quchen> ertes: Oh?
13:00:06 <guillaum2> lyxia: thank you for your solution, I just saw it (sorry). Interesting indeed.
13:00:09 <ertes> quchen: ah, it's yours =)
13:00:13 <ertes> quchen: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
13:00:23 <kuribas> ertes: but which one to choose: (a, (b, c)), or ((a, b), c)?
13:01:09 <ReinH> quchen: how are you finding github as a blogging platform?
13:01:26 <quchen> ReinH: So simple that it‚Äôs hard to get away from it
13:01:43 <quchen> ReinH: I even get some form of statistics (clicks, unique visitors)
13:01:50 <ReinH> huh
13:01:52 <ReinH> neat
13:02:11 <quchen> Well, it‚Äôs literally a repo of text files, so you get the statistics page that all Github repos have
13:02:20 <ReinH> Right.
13:02:25 <quchen> Writing the table of contents manually is awful, but workable.
13:02:33 <quchen> I should automate this. (Me, 2 years ago)
13:02:33 <pi____> is it still the case that I manually need to download and unpack haskell packages if I get  this error `cabal: failed to parse output of 'ghc-pkg dump'`
13:02:39 <ReinH> You could write something to build it for you, I suppose.
13:02:47 <ReinH> But then why not just use hakyll...
13:03:04 <pi____> I found those instructions here https://ghc.haskell.org/trac/ghc/wiki/Debugging/InstallingPackagesInplace
13:03:29 <ertes> kuribas: it depends: if you want to use fmap on the tuple, do you want to always map over the last element, or do you want to map over the "tail" of the tuple?
13:03:32 <ReinH> quchen: And at least writing it manually scales.
13:03:48 <ReinH> (To a single person writing blog posts.)
13:04:07 <ertes> fmap :: (d' -> d) -> (((a, b), c), d') -> (((a, b), c), d)
13:04:30 <ertes> fmap :: ((b, (c, d)) -> e) -> (a, (b, (c, d))) -> (a, e)
13:04:34 <quchen> ReinH: I thought about switching to Hakyll but then I lose the ability to collect internet points on Github, and I don‚Äôt know about the statistics. What I gain is a custom stylesheet.
13:04:44 <ertes> kuribas: choose between your preferred fmap semantics (or disregard it and just use Bifunctor)
13:04:53 <ReinH> hah
13:04:56 <kuribas> ((a, b), c) probably
13:05:13 <ReinH> quchen: Well, you can add google (or w/e) analytics at least.
13:05:14 <quchen> I even wrote* my own Hakyll everything (*: stole it from Ollie Charles)
13:05:30 <ReinH> Oh did you? Is the code up somewhere?
13:05:38 <quchen> ReinH: Sure, but then I need to worry about how to do that, and whether I want Google watching my site, and so on.
13:05:45 <quchen> ReinH: it‚Äôs in a branch in the repo
13:05:52 <ReinH> I've been thinking about writing my own because my blogging desires are... unconventional.
13:06:07 <ReinH> So far I've been able to hack pandoc and hakyll to support them
13:06:12 <ReinH> And also it's a fun project.
13:06:26 <quchen> ReinH: My version is stripped down from Ollie‚Äôs site, so if you find mine lacking have a look at his version
13:06:29 <ReinH> Cool.
13:06:31 <quchen> ocharles/blog should be the repo
13:06:37 <ertes> ReinH: github is good enough, but its markdown is rather limited, and you can't test it locally before you push‚Ä¶  also you have to impose github's stylesheet on the readers instead of imposing your own =)
13:06:46 <quchen> He has RSS and guest posts and some more goodies
13:07:02 <ReinH> Ah, right, his is a custom hakyll thing too.
13:07:02 <quchen> ertes: Github knows many languages, not just markdown!
13:07:12 <ertes> personally i found custom style and markdown more valuable than the convenience of github (but i'm still using github pages with a custom domain, because it's essentially free web space)
13:07:17 <ReinH> I hacked mine to add bibliographies and margin notes and figures and a few other things.
13:07:40 <ertes> quchen: yeah, but you still can't override github's stylesheet =)
13:07:44 <ReinH> quchen: e.g., http://reinh.com/notes/posts/2015-06-27-theoretical-pearl-l-systems-as-final-coalgebras.html
13:08:00 <quchen> ertes: That‚Äôs true. And if you use promoted data types Github‚Äôs parser is crap.
13:08:19 <ertes> to be fair pandoc's highlighter isn't sunshine either
13:08:41 <ertes> which is why i use very little highlighting in my stylesheet
13:08:43 <quchen> GITHUB WHAT https://github.com/quchen/prettyprinter/blob/master/wl-pprint/src/Data/Text/Prettyprint/Doc.hs#L114
13:08:47 <quchen> Grrr.
13:09:12 <ReinH> Wait, how does it get that wrong
13:09:17 <ReinH> That seemms pretty standard
13:09:20 <quchen> Highlight manually! <span class="keyword">do</span> ‚Ä¶
13:09:26 <quchen> ReinH: Puzzles me
13:09:44 <quchen> At least the ¬ªwhere¬´ fixes it!
13:09:46 <ertes> BTW, i'm just using a Makefile with pandoc‚Ä¶  simplest static site generator ever =)
13:10:08 <quchen> Did you just call makefiles simple? Teach me, sensei!
13:10:51 <ertes> quchen: https://github.com/esoeylemez/esoeylemez.github.io/blob/master/Makefile
13:10:57 <ertes> if you have any questions, feel free to ask
13:11:09 <int-e> makefiles are nice and declarative... with some side effects mixed in... and a crazy macro language... what could possibly go wrong?
13:11:27 <hodapp> Shake is still pretty nice.
13:11:56 <Tuplanolla> I'm going to have to build myself a proper website next year and I already dread it.
13:12:08 <quchen> ertes: Teach me how to remember what $$ $? $% mean. Makefiles put lens soup to shame :-(
13:12:19 <mightymo> got a quick question, is there a way to have a haskell file start with the string "GIF89a" without getting an error?
13:12:32 <ertes> quchen: it's like remembering (>>=), (<*>) and ($)‚Ä¶  eventually it becomes second nature =)
13:12:42 <Tuplanolla> You're playing too, mightymo?
13:12:49 <mightymo> got me;-)
13:12:52 <quchen> ertes: But those follow laws!
13:13:00 <ertes> mightymo: without a module declaration
13:13:13 <ertes> mightymo: GIF89a = GIF89a
13:13:24 <Tuplanolla> That part is easy, but building a valid header from printable characters is not, mightymo.
13:13:36 <puregreen> mightymo: ‚ÄúGIF89a = GIF89a; data GIF89a‚Äù
13:13:43 <puregreen> * data GIF89a = GIF89a
13:13:44 <ertes> quchen: the symbols follow laws? =)
13:13:48 <quchen> Oh, and I can never remember what exactly ($) does so I‚Äôm avoiding it completely in my programs
13:13:56 <ertes> quchen: i guess you could call "<*>" symmetric =)
13:14:01 <quchen> But that‚Äôs another point for when we have nothing to argue about haha
13:14:27 <ertes> quchen: you mean when i grep your code for "\$ *do" i will find nothing? ;)
13:14:35 <quchen> ertes: Yes.
13:14:42 <puregreen> mightymo, Tuplanolla: what are you playing, btw?
13:14:59 <ertes> quchen: nice!  i avoid it a lot, but not completely, "$ do" being 99% of my use cases
13:15:03 <bennofs> puregreen: 33c3ctf
13:15:04 <geekosaur> some kind of c3 challenge
13:15:08 <quchen> ertes: Except maybe an entry in my HLint.hs that forbids usage of infix $.
13:15:20 <Tuplanolla> I'm not playing, puregreen. I dislike programming competitions.
13:15:25 <quchen> ertes: I used it once or twice as a section though.
13:15:28 <geekosaur> people have been popping in asking that question since yesterday, since apparently you don't actually try to solve it, you ask #haskell to solve it for you
13:15:49 <puregreen> well, that's... efficient, I guess
13:15:51 <suzu> what is this question from?
13:15:54 <suzu> i keep seeing it
13:16:05 <quchen> Profpatsch: is this your doing?
13:16:09 <ReinH> quchen: Your 'Modular Keyboard' post no longer exists fwiw
13:16:19 <ertes> quchen: it's easy to remember though:  ($) = id
13:16:21 <MarcelineVQ> a hackerank type challenge for crackers, idr the site name
13:16:24 <mightymo> GIF89a = GIF89a gives me  "Not in scope: data constructor..."
13:16:28 <MarcelineVQ> *challenge site
13:16:35 <ertes> mightymo: see what puregreen wrote
13:16:39 <quchen> ReinH: Yes, I deleted it in the ¬ªdelete things you don‚Äôt care about enough anymore¬´ commit. I now have an Ergodox and it‚Äôs sufficiently great.
13:16:51 <ReinH> quchen: It's referenced in the index though.
13:16:58 <ReinH> Also I also have one and it is indeed sufficiently great.
13:17:30 <suzu> interestingly enough
13:17:37 <suzu> GIF89a is the header for a GIF file.
13:17:54 <ReinH> Not very interesting, really. It's some weird programming challenge.
13:18:01 <Tuplanolla> Is it really a complete one, suzu?
13:18:05 <suzu> no
13:18:16 <geekosaur> suzu, https://33c3ctf.ccc.ac/
13:18:18 <suzu> but perhaps the goal here is to write source code that can be viewed as a gif too
13:18:28 <Tuplanolla> That's my understanding of it.
13:18:40 <suzu> jeopardy style ctf?
13:18:50 <bennofs> yes
13:18:52 <kuribas> the challenge is to create a haskell program that's also a gif?
13:18:59 <kadoban> Yes
13:19:01 <quchen> ReinH: Oh! Thanks.
13:19:01 <ertes> as far as i understand it, it's the same kind of CTF that the DEF CON conference does
13:19:01 <quchen> Infinity?
13:19:42 <ertes> its purpose is to bring people together, because nobody alone has all the various skills to beat the challenge‚Ä¶  since it encourages people to talk to each other i like it =)
13:19:42 <mightymo> ertes: puregreen: thanks, works for me!:-)
13:19:43 <ReinH> I'd recommend having one of those evolutionary fuzzers write it for you.
13:19:52 <magneticduck> should we all be learning programmer's dvorak? discuss
13:20:06 <ReinH> Perhaps discuss in #haskell-offtopic?
13:20:08 <suzu> oh snap
13:20:09 <kadoban> Regular dvorak seems fine to me.
13:20:10 <suzu> this is cool
13:20:12 <suzu> https://archive.aachen.ccc.de/32c3ctf.ccc.ac/challenges/index.html
13:20:17 <suzu> heres challenges from a prev year if anyone wants to see
13:20:20 <suzu> no account needed that way
13:20:34 <suzu> re: dvorak, waste of time
13:20:38 <ReinH> If you want a cool programmming challenge, try ICFP's.
13:20:42 <suzu> i type 110wpm on both qwerty and dvorak
13:20:49 <suzu> dunno how it has ever helped me
13:21:02 <bennofs> ReinH: well this is a security challenge more than a programming challenge. different kind
13:21:05 <suzu> ^
13:21:07 <ertes> it's less of a programming/engineering challenge than a hacking challenge
13:21:38 <ReinH> Ah.
13:22:19 <EvanR> the fast you can type the faster you can hack, have you ever seen CSI
13:22:29 <ertes> that's probably why mightymo was asking that particular question‚Ä¶  i haven't read any of it, but it sounds like it's about making a polyglot file between haskell source code and GIF =)
13:22:35 <suzu> we just need longer keyboards EvanR 
13:22:37 <kuribas> now a program that generates itself, and is also a gif, that would be a challenge!
13:22:42 <suzu> so that we can get a whole squad up on the counter-hacking effort
13:22:47 <suzu> mashin the keys away
13:22:57 <ertes> kuribas: that's actually pretty easy
13:22:57 <EvanR> two levels imo
13:23:04 <EvanR> like phantom of the opera organ
13:23:19 <quchen> magneticduck: We should all be learning Neo‚Äôs 3rd layer. Keep your letters wherever you want them, get awesome special characters next to each other. This is my home row: \/{}*?()-:@
13:23:37 <suzu> is that actually your home row?
13:23:48 <quchen> Capslock plus home row.
13:23:48 <magneticduck> that's horrifying, give me a link
13:24:01 <suzu> lmao why would you do this
13:24:07 <suzu> this has to be a joke
13:24:20 <quchen> Layer 1 is lower-case. Layer 2 is upper-case, shift switches to it. Layer 3 is special characters, caps switches to it.
13:24:55 <quchen> Hover over ¬ªEbene 3¬´ here to see it. http://www.neo-layout.org/
13:25:03 <quchen> Can‚Äôt recommend it enough for programming.
13:25:16 <quchen> Bind is caps+ iio
13:25:28 <ReinH>  That is slightly ridiculous.
13:25:31 <suzu> this is fucked
13:25:31 <quchen> <> is caps+ui
13:25:34 <ReinH> But only slightly.
13:25:35 <suzu> this is actually fucked
13:26:14 <quchen> I wouldn‚Äôt call typing out special characters as fast as letters ¬ªfucked¬´, but everyone has different interpretations of that word.
13:26:31 <bjs> suzu: it's like any other keyboard except neo has lots of extra modifier keys, the "standard" keyboard looks normal-ish, except optimised for German ofc
13:26:33 <magneticduck> suzu: I also type at >110 WPM and am deciding whether dvorak would get me a better highscore on ztype
13:26:51 <quchen> I don‚Äôt use Neo letters, just the special characters.
13:27:29 <anon> What's the difference between Monoid and Foldable? Isn't Monoid supposed to be about folding?
13:27:34 <quchen> :-) is √∂lk
13:27:44 <quchen> Where √∂ is the thing to the right of l on German keyboards
13:27:47 <quchen> [ in US layouts?
13:28:07 <Tuplanolla> Here's the connection, Guest64138: http://comonad.com/reader/2015/free-monoids-in-haskell/
13:28:16 <glguy> Guest64138 / anon: Look at the methods from each of the two typeclasses. They are basically unrelated
13:28:30 <kuribas> Guest64138: the Monoid is usually contained in the Foldable.
13:29:06 <ertes> kuribas: https://gist.github.com/esoeylemez/a993450ace9eedcd761601ee261f905f
13:29:08 <ertes> =)
13:29:21 <Tuplanolla> The point is that foldable things admit a mapping to the free monoid, Guest64138.
13:29:36 <mightymo> Tuplanolla: building the header seemed easy, but executing system commands is hard again:D
13:30:07 <EvanR> monoids are about semigroups with identity
13:30:16 <mightymo> but that might be due to my lacking haskell knowledge
13:30:32 <Guest64138> Tuplanolla, hmmm... I'm afraid I don't know what 'free' monoids are yet :/
13:30:34 <EvanR> semigroups are just about associativity, whats the problem
13:30:53 <ReinH> Guest64138: The connection is easiest to see by looking at foldMap
13:30:55 <ertes> mightymo: https://hackage.haskell.org/package/process-1.4.3.0/docs/System-Process.html#v:callProcess
13:30:58 <ReinH> and how other folds are defined in terms of it.
13:31:03 <Tuplanolla> Once you understand the question, you'll understand the answer, Guest64138.
13:31:40 <Guest64138> Ok. I'll keep looking at it. Thanks :)
13:32:02 <kuribas> ertes: doesn't seem to be a gif.  
13:32:26 <EvanR> .oO( finite lists of X are the classic free monoid over X, but in haskell lists tend to be infinite ... )
13:32:48 <EvanR> thats gotta mess up associativity 
13:32:52 <ertes> kuribas: i didn't bother encoding an actual picture, because i didn't care to learn the GIF grammar =)
13:33:03 <ReinH> EvanR: Indeed, lists are not really the free monoid.
13:33:38 <ertes> kuribas: but it would be easy enough to encode a picture with some artifacts (you could even get some freedom in the characters you use by using QuasiQuotes)
13:33:39 <ReinH> But they are sufficiently close if you can wave your hands quickly enough.
13:33:59 * EvanR spins around until dizzy enough to fall over
13:34:05 <kuribas> ertes: right
13:34:16 <ertes> kuribas: once you know what you want it to display, making it a quine is pretty straightforward, especially in haskell ('show' is really handy for that)
13:35:09 <EvanR> ReinH: more to my thought bubbles originating concern... is monoid [a] even law abiding?
13:35:17 <kuribas> ertes: allright, additionally show something resembling a lambda :-)
13:35:25 <ReinH> EvanR: Strictly speaking, it is not.
13:35:32 <kuribas> that should be a bit harder
13:35:46 <ertes> kuribas: you mean source code that looks like a lambda?
13:35:50 <ReinH> EvanR: Gershom (sclv) had a nice post about this but now I can't find it :(
13:35:58 <mightymo> ertes: i get a "Not in scope: callCommand"
13:36:00 <Tuplanolla> I just linked it, ReinH.
13:36:21 <quchen> ReinH: I think it was Dan Doel?
13:36:23 <kuribas> ertes: well, the image, but a bonus if the source code has a lambda too :)
13:36:26 <ertes> mightymo: oh yeah, that might be a problem, because you need to import the System.Process module, which has to happen before any definitions =)
13:36:30 <ReinH> Tuplanolla: Ah nice
13:36:39 <ReinH> Oh was it Dan? I guess I'm misremembering.
13:36:39 <quchen> ReinH: ¬ª[a] is not the free monoid¬´ or something?
13:36:49 <quchen> I thought that was Dan
13:36:53 <Tuplanolla> It was ten messages before your first one, ReinH.
13:36:59 <ReinH> Ok, I sit corrected.
13:37:03 <ReinH> Tuplanolla: sorry
13:37:03 <EvanR> i have the free monad blog posthttp://comonad.com/reader/2015/free-monoids-in-haskell/
13:37:07 <EvanR> er free monoid
13:37:14 <Tuplanolla> I'm assuming you mean that one.
13:37:14 <ertes> kuribas: may i make it an XBM instead of a GIF?  i really don't want to learn GIF now =)
13:37:30 <EvanR> but i didnt think that addressed whether [a] with ++ was a genuine monoid at all
13:37:46 <kuribas> ertes: yes
13:37:55 <quchen> Wait, [a] is not a genuine monoid?
13:38:02 <EvanR> thats what im wondering
13:38:02 <quchen> Is this our friend ‚ä• flicking us off again?
13:38:09 <ReinH> EvanR: Is let xs = [1..] = (xs ++ xs) ++ xs equal to let xs = [1..] in xs ++ (xs ++ xs)?
13:38:24 <quchen> Extensionally? Sure
13:38:50 <ReinH> ok, is [1..] ++ [] equal to [1..]?
13:38:51 <EvanR> [1..] ++ [1..] is a classic object with non trivial order type
13:39:09 <EvanR> if you rename the second set of numbers
13:39:15 <quchen> Extensionally? Sure -- let‚Äôs stop here, ReinH ;-)
13:39:16 <byorgey> ReinH: yes
13:39:21 <ReinH> quchen: :)
13:39:37 <EvanR> extensionally equal applies to data structures?
13:39:46 <EvanR> or should we say observationally
13:40:03 <byorgey> those are the same
13:40:03 <quchen> Maybe! I don‚Äôt know much about this topic.
13:40:09 <EvanR> oh?
13:40:17 <quchen> s/.*/totally, I‚Äôm an expert/
13:40:30 <EvanR> ive heard of extensional type theory and observational type theory
13:41:13 <EvanR> ReinH: any idea of an interpretation where they are not equal?
13:41:16 <quchen> I wonder whether anything is a monoid in Haskell (2010) if [a] is not one.
13:41:26 <shapr> I'm getting an existential type error.
13:41:45 <byorgey> quchen: who said [a] is not a monoid?
13:41:46 <ReinH> I don't know that [a] isn't a monoid.               
13:41:59 <EvanR> lets just check
13:42:17 <quchen> byorgey: Someone suggested an article that maybe talked about [a] and monoids and that brought up that maybe it‚Äôs not, according to that article.
13:42:21 <ReinH> I made a bad joke about strictness that I guess no one caught :(
13:42:32 <byorgey> quchen: no, that article says it is not *the free* monoid
13:42:42 <quchen> byorgey: Not Dan‚Äôs article
13:42:44 <shapr> ReinH: sorry, that was a humor leak, and we're not out of memory yet
13:42:46 <quchen> ReinH‚Äôs referenced article
13:42:49 <quchen> ‡≤†_‡≤† 
13:42:49 <ReinH> byorgey: I said that "strictly speaking" it is not a monoid.
13:42:51 <sphinxo> How can I stop escaping backslashes when I print?
13:42:52 <quchen> ReinH!!!!
13:42:59 <sphinxo> eg print '\\'
13:42:59 <ReinH> Get it??
13:43:01 <byorgey> ReinH: and why is that?
13:43:08 <geekosaur> sphinxo, putStrLn
13:43:13 <EvanR> > let xs st = [st..] in xs 0 ++ (xs 1 ++ xs 2) == (xs 0 ++ xs 1) ++ xs 2
13:43:13 <ReinH> byorgey: it isn't, it was a joke about strictness and infinite lists.
13:43:16 <quchen> sphinxo: Use putStrLn. Print uses "show" and that adds "quotation marks".
13:43:19 <lambdabot>  mueval-core: Time limit exceeded
13:43:23 <quchen> ?src print
13:43:23 <lambdabot> print x = putStrLn (show x)
13:43:28 <geekosaur> and I see you still have better things to do than learn stuff, just keep asing #haskell to write your program for you
13:43:28 <EvanR> theyre not unequal
13:43:55 <byorgey> ReinH: I don't see what strictness and infinite lists have to do with anything.  [a] is still a monoid even taking _|_ and infinite lists into account, isn't it?
13:43:56 <quchen> geekosaur: Oh, did I just become an outsourcing adversary there
13:44:00 <sphinxo> Thank you!
13:44:10 <ReinH> byorgey: Yes, that's why it was a *bad* joke.
13:44:14 <geekosaur> sphinxo has asked the same basic monad question 3 times in a row
13:44:15 <EvanR> byorgey: it is until proven it isnt? ;)
13:44:22 <geekosaur> and now asks about print vs. putStrLn
13:44:24 <EvanR> i was seriously asking for thoughts
13:44:27 <byorgey> ReinH: ah, ok
13:44:36 <geekosaur> apparently #haskell is how to not bother learning Haskell
13:44:50 <shapr> geekosaur: I'm just getting to that myself.
13:44:59 <ReinH> shapr: o/
13:45:12 <sphinxo> which monad question have I asked three times?
13:45:24 <shapr> sphinxo: are you making lazy evaluation jokes too?
13:45:40 <quchen> That joke sounds forced
13:45:50 <quchen> So strictly speaking it‚Äôs a real joke
13:45:59 <quchen> (I‚Äôll show myself out ok)
13:46:02 <shapr> quchen: arghh
13:46:04 <EvanR> byorgey: i will consider the case where you have an infinite list of infinite lists, and do mconcat
13:46:08 * hodapp slams the door behind quchen
13:46:12 <shapr> quchen: you'll get points for that one day
13:46:32 <shapr> sphinxo: seriously, your life will be much easier if you sit down and learn about monadic IO
13:46:42 <sphinxo> I should to start memoizating #haskell, so I stop asking the same question twice and wasting your time
13:46:44 <byorgey> EvanR: ok...
13:46:52 <sphinxo> s/twice/thrice/
13:46:56 <byorgey> EvanR: the result is equal to the first list
13:47:04 <shapr> sphinxo: after learning about all that monad stuff, you will not need to ask these questions, because you will know the answners!
13:47:04 <mightymo> ertes: alright i got it by using the IO module, thanks for your help:-)
13:47:37 <EvanR> byorgey: but what about a left leaning nest of associations
13:47:38 <quchen> It‚Äôs fine to come here asking questions of course, but people will rarely write your programs interactively with you.
13:47:40 <geekosaur> sphinxo, you have asked three different variants of "how do I get a value out of a monad" so far in the past two days (and log grepping tells me there were a few other kinds of basic Haskell questions in between that I didn't see)
13:47:46 <quchen> Most will try to socratize you.
13:47:49 <EvanR> that would evaluate to bottom
13:47:57 <sphinxo> but hey, at least i'm asking
13:48:01 <Gurkenglas> kuribas, nah I even refuted a lazy foldl use case someone else came up with :P
13:48:03 <ReinH> Anyone have thoughts on Stephen Diehl's Protolude? So far it's the only replacement prelude that I've found compelling.
13:48:13 <shapr> quchen: that's our community's cultural pastime!
13:48:17 <suzu> not classy prelude ReinH ?
13:48:18 <byorgey> EvanR: true.  But the monoid laws do not require anything to be true about infinite applications of mappend.
13:48:23 <EvanR> ah
13:48:40 <sphinxo> geekosaur: ¬Ø\_(„ÉÑ)_/¬Ø
13:48:50 <Tuplanolla> This channel is a big guinea pig pen for teaching dialogue.
13:48:55 <shapr> ReinH: what about lifted protolude?
13:49:01 <byorgey> EvanR: using induction and the associativity law you can show that you have to be able to reassociate any *finite* chain of applications
13:49:05 <Tuplanolla> Now say that quickly five times.
13:49:14 <ReinH> suzu: No, it's a nightmare to work with. We don't need ubiquitous return type polymorphism.
13:49:15 <quchen> sphinxo: The answer to ¬ªhow do I get the value out of a monad¬´ is ¬ªyou cannot¬´. The question you should be asking is ¬ªhow do I work with a monadic value¬´, and the answer to that is learning about the bind operator (>>=), how it interacts with ¬ªpure¬´ or ¬ªreturn¬´, and so on.
13:49:35 <ReinH> shapr: what is lifted protolude?
13:49:57 <EvanR> so if you have ten infinite lists and associate to the left, the result would still be the first list
13:50:03 <shapr> ReinH: https://github.com/parsonsmatt/lifted-protolude/
13:50:09 <quchen> sphinxo: A function of type ¬ªm a -> a¬´ is like asking a recipe to become a cake.
13:50:11 <byorgey> EvanR: right
13:50:15 <ReinH> Thanks. Google was surprisingly unhelpful.
13:50:17 <quchen> (for Monad m)
13:50:23 <sphinxo> thank you quchen, for your answer and also for your set of articles
13:50:53 <Gurkenglas> (Hmm, lowerCodensity feels like atomically - it finishes any ongoing conty wizardry)
13:51:03 <quchen> sphinxo: This is my FBUT entry about monads: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-understand-monads
13:51:18 <quchen> It‚Äôs short, but useful to keep in mind when reading more elaborate resources.
13:52:19 <ReinH> shapr: Oh, I don't tend to use MonadBase{,Control}, so I dunno.
13:53:18 <shapr> ReinH: in that case, I hope to hear the results of your investigation into alternative preludes
13:54:08 <ReinH> shapr: I haven't made a thorough investigation, but I've tried a few of them at different times and been underwhelmed. Maybe it's just that I agree with pretty much all of Stephen's decisions.
13:54:32 <EvanR> i guess the same can be said for addition not being a monoid if you include infinite expressions in the mix
13:54:42 <EvanR> because of conditionally convergent series
13:55:06 <EvanR> or maybe that is related to reordering
13:55:25 <shapr> ReinH: I know he said protolude is an extremely conservative Prelude, I wonder what he'd consider less conservative?
13:55:53 <byorgey> EvanR: no, you're right, you can get weird convergence effects just from reassociating infinite series
13:56:03 <ReinH> shapr: Foundation, for sure.
13:56:08 <byorgey> EvanR: that's a nice observation
13:56:18 <ReinH> classy-prelude, similar
13:56:45 <antalsz> I‚Äôm trying to set up intero and it‚Äôs *super* slow when printing REPL responses.  Like, up to 10 seconds slow for input like ‚Äú345‚Äù.  I think it‚Äôs because of completion.  Has anybody else run into this?
13:56:56 <ReinH> byorgey: wait was I actually right? o_O
13:57:07 <byorgey> ReinH: about what?
13:57:16 <ReinH> [a] not being a monoid
13:57:21 <byorgey> ReinH: no.
13:57:24 <ReinH> Ok good.
13:57:38 <MarcelineVQ> antalsz: is your project stack based?
13:57:50 <shapr> I wonder if protolude has the generalized groupBy (and friends) from the wiki?
13:57:56 <antalsz> MarcelineVQ: Yes
13:58:19 <byorgey> it is a monoid.  The observation is that foldr mappend may not be the same as foldl mappend on *infinite* lists of values, but that's OK because the monoid laws do not say anything about *infinite* chains of mappend.
13:58:25 <ReinH> shapr: Not iirc
13:58:37 <ReinH> byorgey: Ah.
13:58:47 <shapr> aw :-(
13:58:56 <MarcelineVQ> interesting, I have a silimar issue with ghc-mod and have wondered if it's due to having to ask stack if everything's in order before doing the work, not looked into it yet though
13:58:57 <ertes> kuribas: i set myself up for quite a challenge as it seems‚Ä¶  it's not straightforward to polyglot haskell and XBM =)
13:59:03 <ReinH> It does generalize print and putStr{,Ln}
13:59:52 <antalsz> MarcelineVQ: Huh, odd.  On my end, it‚Äôs inconsistent ‚Äì some inputs take ages, some are as fast as they should be
14:00:18 <byorgey> does anyone know of an implementation of Geometric Algebra in Haskell? edwardk?
14:00:23 <MarcelineVQ> there's alos the consideration that intero is not ghc-mod so it may be entirely unrelated
14:00:52 <byorgey> I got a copy of http://www.geometricalgebra.net/index.html for Christmas
14:02:47 <quchen> ¬ªAn object-oriented approach to geometry¬´, woah
14:02:56 <byorgey> I know the 'linear' package has some GA influences but I'm wondering if there's any more direct/complete implementation
14:03:30 <byorgey> quchen: that subtitle is pretty silly.  So far there's nothing particularly object-oriented about it.  It should really say "an algebraic approach to geometry"
14:03:43 <byorgey> but of course it's already called "Geometric algebra"
14:03:46 <quchen> byorgey: It‚Äôs probably a pun on objects in a category?
14:04:33 <geekosaur> that was my guess fwiw
14:04:39 <byorgey> quchen: nah, I don't think there's any CT in this book.  I think they were just trying to appeal to computer scientists.
14:04:47 <quchen> Ah. 
14:04:52 <byorgey> Most people who do computational geometry-related stuff use C++
14:05:05 <byorgey> and they have a bunch of C++ code in the book.
14:05:06 <quchen> Reminds me of a German book ¬ªHaskell for object-oriented programmers¬´, which is complete and utter crap.
14:05:26 <quchen> And contains nothing about object orientation.
14:05:33 <quchen> (Or proper Haskell, for that matter.)
14:05:37 <byorgey> hehe
14:05:39 <hvr> quchen: http://haskellbuch.weebly.com/ ?
14:05:55 <quchen> Yes, that one.
14:07:51 <byorgey> quchen: in this case, the book is high-quality despite the silly title
14:08:14 <shapr> Huh, looks like utility-ht has a pile of fun toys.
14:09:07 <EvanR> if you write a book, how can you miss both things mentioned in the title ;)
14:09:09 <EvanR> impressive
14:11:08 <int-e> EvanR: maybe the title was chosen after the book was completed... wait a second... ;-)
14:11:46 <EvanR> illogical
14:17:46 <kuribas> Wouldn't it be nice to make instances for instances?
14:18:38 <quchen> kuribas: How do you mean?
14:18:57 <kuribas> to make an instance from one class automaticlly an instance of another class.
14:19:11 <quchen> Oh, default superclasses or what it‚Äôs called
14:19:12 <hexagoxel> can i make vty work while debugging with gdb?
14:19:40 <quchen> kuribas: Yes, that would be cool, but it‚Äôs tricky to get right because of the usual diamond problem
14:19:50 <kuribas> quchen: what's the diamond problem?
14:20:28 <quchen> kuribas: Wikipedia has an overview, https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem
14:20:43 <sphinxo> so this is not the same question I've already asked, I have function :: a -> m b
14:20:46 <quchen> kuribas: It usually comes up in OOP when talking about multiple inheritance, but it applies equally in a Haskell setting
14:20:52 <sphinxo> ( I hope )
14:21:16 <sphinxo> and I have [a]
14:21:48 <hexagoxel> ah nevermind, it is the specific gdb gui that only provides a non-cup terminal.
14:21:51 <ProofTechnique[m> mapM solves a lot of problems
14:22:14 <sphinxo> ProofTechnique[m: oh I remember now!
14:22:19 <kuribas> traverse more
14:22:23 <kuribas> :t tranverse
14:22:24 <lambdabot> error:
14:22:24 <lambdabot>     ‚Ä¢ Variable not in scope: tranverse
14:22:24 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
14:22:28 <kuribas> :t traverse
14:22:29 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:22:39 <quchen> sphinxo: https://github.com/quchen/articles/blob/master/functions_comprehensible.md
14:23:35 <MarcelineVQ> sphinxo: as another tool, one thing you can try for problems like that is typing the signature of what you're after in hoogle or hayoo: http://hayoo.fh-wedel.de/?query=[m+b]+->+m+[b]
14:23:59 <MarcelineVQ> that link probbaly doesn't translate on irc, might have to copy/paste :X
14:24:50 <sphinxo> well I've never seen hayoo before, and it's certainly more googleable
14:25:03 <quchen> Hayoo is excellent!
14:25:10 <MarcelineVQ> being able to search by type signature is pretty incredible
14:25:14 * quchen loves Hayoo and prefers it over Hoogle
14:25:45 <sphinxo> I've found alpha hoogle to be pretty good http://hoogle.haskell.org/ 
14:32:00 <MarcelineVQ> you have to help alpha hoogle more than I prefer, but it's pretty nice yes
14:33:46 <MarcelineVQ> e.g.   (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)   will give you mapM but   Monad m => (a -> m b) -> [a] -> m [b]   won't quuiiite
14:34:56 <quchen> Still, the results are fairly impressive!
14:36:51 <MarcelineVQ> it's really great, I just wish it was feature complete, I can't recall which part is the technical holdup
14:41:40 <kuribas> :t ["a"]
14:41:42 <lambdabot> [[Char]]
14:41:48 <kuribas> why not [String]?
14:42:03 <guillaum2> kuribas: String is an alias to [Char]
14:42:05 <sphinxo> :t String
14:42:07 <lambdabot> error:
14:42:07 <lambdabot>     ‚Ä¢ Data constructor not in scope: String
14:42:07 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
14:42:08 <kuribas> I wish ghc would use type synonyms in error messages.
14:42:16 <kuribas> and types
14:42:16 <ludat> :t "a"
14:42:17 <lambdabot> [Char]
14:42:26 * sphinxo facepalm self
14:42:36 <sphinxo> ?src String
14:42:36 <lambdabot> type String = [Char]
14:42:49 <Tuplanolla> Would you prefer every `Int` to be called `Node` when using `fgl`, kuribas?
14:43:13 <MarcelineVQ> It often does use type aliases in errors
14:43:15 <kuribas> Tuplanolla: no, only the ones that use fgl functions.
14:43:26 <Tuplanolla> They mix.
14:44:03 <kuribas> :t tail ("list" :: String)
14:44:05 <lambdabot> [Char]
14:44:36 <kuribas> :t let mytail = tail; mytail :: String -> String in mytail "list"
14:44:38 <lambdabot> String
14:44:41 <kuribas> aha
14:45:52 <geekosaur> there isn't a lot of rhyme or reason to how ghc picks the way to describe a type; usually it will come down to what the last thing it looked at (which might not be the thing specified in the error, or the thing pointed to in source) used
14:46:32 <MarcelineVQ> "what" + 2    No instance for (Num [Char])   show "what" + 2    No instance for (Num String) :>
14:47:27 <kuribas> > ("what" :: String) + 2
14:47:29 <lambdabot>  error:
14:47:29 <lambdabot>      ‚Ä¢ No instance for (Num String) arising from a use of ‚Äò+‚Äô
14:47:29 <lambdabot>      ‚Ä¢ In the expression: ("what" :: String) + 2
14:47:34 <kuribas> > "what" + 2
14:47:36 <lambdabot>  error:
14:47:36 <lambdabot>      ‚Ä¢ No instance for (Num [Char]) arising from a use of ‚Äò+‚Äô
14:47:36 <lambdabot>      ‚Ä¢ In the expression: "what" + 2
14:48:05 <kuribas> geekosaur: it seems it treats string literals as [Char] by default.
14:49:14 <kuribas> geekosaur: perhaps I should file a ticket to ghc?
14:49:42 <MarcelineVQ> What would the ticket say?
14:50:50 <kuribas> well, :t "string" give [Char] by default, while it is more logical to use the type synonym String
14:50:50 <geekosaur> kuribas, this comes up somewhat regularly
14:51:28 <geekosaur> it is emergent behavior of the typechecker, and while it might be possible to make simple cases like that behave the way you want, things fall apart pretty quickly --- it is not, in fact, simple at all
14:51:31 <MarcelineVQ> is it? I'd prefer the baser types be shown if I had to pick a rule about it
14:52:38 <MarcelineVQ> or even have   [Char] ~ String   appear in the error
14:52:41 <Tuplanolla> Treat this one as a special case and replace `[Char]` with `String` everywhere?
14:53:17 <kuribas> Tuplanolla: yeah
14:53:20 <MarcelineVQ> special cases make the baby jesus cry
14:53:32 <kuribas> MarcelineVQ: it's already a special case...
14:54:13 <MarcelineVQ> what is? [mixfix] ?
14:54:53 <Tuplanolla> String literals.
14:54:59 <MarcelineVQ> or the show instance using " " ?
14:55:21 <kuribas> MarcelineVQ: String syntax.
14:55:33 <Tuplanolla> Step up your mind reading game, MarcelineVQ.
14:55:46 <MarcelineVQ> I'll never go pro at this rate
14:56:44 <Tuplanolla> Is this Lisp envy in disguise (reader macros)?
14:57:40 <qnkxsovc> exit
14:57:46 <qnkxsovc> rip
15:00:24 <slack1256> dealing with callback on gtk3 is a pain.
15:00:49 <kuribas> slack1256: hook it upto reactive-banana ;-)
15:01:20 <slack1256> tutorial for it?
15:01:42 <slack1256> I know some of it
15:01:51 <slack1256> I don't see how It can help, though
15:01:55 <vlad__> hey, haven't used haskell in a while, and I hear ghc 8 is out now? what is the right way to install it? I hear stack can handle ghc installs
15:02:40 <kuribas> slack1256: https://wiki.haskell.org/FRP_explanation_using_reactive-banana
15:03:02 <kuribas> slack1256: it takes away the pain of events and callbacks.
15:03:15 <Tuplanolla> I'd wait until 8.0.2, vlad__.
15:03:29 <kadoban> vlad__: stack is one way to handle it, sure. If you use a newish resolver, it'll use GHC 8. GHC 8 is still pretty new though, I'm personally not using it by choice.
15:05:03 <kuribas> slack1256: the API documentation is pretty good: https://hackage.haskell.org/package/reactive-banana-1.1.0.1/docs/Reactive-Banana-Combinators.html
15:05:20 <vlad__> looks like stack is broken, when I do "stack ghci" I get an error
15:05:21 <vlad__> Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
15:05:56 <kuribas> slack1256: you basicly use Frameworks to fire events from IO: https://hackage.haskell.org/package/reactive-banana-1.1.0.1/docs/Reactive-Banana-Frameworks.html
15:08:29 <MarcelineVQ> vlad__: try  stack setup in the same place you're trying stack ghci if you haven't
15:08:37 <glguy> vlad__: What version of stack?
15:08:55 <MarcelineVQ> ^ I always forget to ask that much more important question
15:09:14 <slack1256> kuribas: that is the missing link!
15:09:18 <glguy> vlad__: also, that error message suggest to me that somehow it's interpreting a bunch of stuff as a single package id. maybe your stack.yaml is malformed
15:13:53 <vlad__> stack version: Version 1.3.2 x86_64 hpack-0.15.0
15:14:51 <glguy> That's up-to-date, so perhaps you can paste your stack.yaml to a pastebin
15:15:34 <ertes> kuribas: https://gist.github.com/esoeylemez/5327f998d778572527ee7cbc1d17b6b9
15:15:40 <ertes> took way longer than it should have taken =)
15:16:01 <vlad__> glguy: oh I think I solved it by commenting out some lines of my stack.yaml
15:16:03 <MagBo> I wonder if there are any security experts who are also Haskell enthusiasts on this channel. We need to audit this system ‚Äî https://github.com/input-output-hk/pos-haskell-prototype and some libs in Haskell / C. Reasonably short notice, results should be in mid-February or sooner. If you're interested (or know someone who is) apply here https://iohk.io/careers/#fk0mhkc and say "hi" at jonn.mostovoy@iohk.io
15:16:05 <MagBo> cc: hi@serokell.io
15:16:05 <ertes> XBM of a lambda + haskell quine + lambda in source =)
15:16:47 <vlad__> glguy: I think I had slighty wrong syntax on extra-deps and ghc-options
15:17:02 <vlad__> they were empty anyways so I commented them out
15:17:06 <glguy> Cool, good find
15:17:07 <ertes> kuribas: i didn't bother laying the entire source code out as a lambda, but that's not too difficult either‚Ä¶  perhaps you want to take that as an exercise ;)
15:17:29 <kuribas> ertes: that's quite impressive!
15:19:09 <ertes> kuribas: caveat: some XBM viewers will reject this, because they don't consider XBM full C code, so they won't allow anything other than the actual picture in there
15:19:15 <ertes> can't do anything about those unfortunately
15:19:36 <kuribas> what does void f(/*) mean in haskell?
15:19:48 <ertes> kuribas: void f (/*) = ()
15:19:57 <ertes> defining a function void of two arguments that i ignore
15:20:05 <ertes> you can take arguments with infix names
15:20:12 <kuribas> ah, I didn't know that
15:20:32 <ertes> foldr (>-) z (x : xs) = x >- foldr (>-) z xs
15:20:40 <kuribas> > let test (*) = 1 * 2 in test (+)
15:20:43 <lambdabot>  3
15:21:24 <geekosaur> @src on
15:21:24 <lambdabot> (*) `on` f = \x y -> f x * f y
15:29:56 <vlad__> `/quit
15:50:06 <mounty> Can someone help with installing stack on Gentoo from source.  I don't want to bootstrap stack via its binary but want to build from source.  So I git clone the suppository and cabal install --only-dependencies --verbose=3
15:50:15 <mounty> The error output contains:
15:50:28 <mounty> *** Chasing dependencies:
15:50:28 <mounty> Chasing modules from:
15:50:29 <mounty> */tmp/cabal-tmp-11350/distributive-0.5.0.2/dist/dist-sandbox-6732a773/setup/setup.hs
15:50:31 <mounty> /tmp/cabal-tmp-11350/distributive-0.5.0.2/dist/dist-sandbox-6732a773/setup/setup.hs:16:8:
15:50:32 <mounty> Could not find module ‚ÄòSystem.FilePath‚Äô
15:50:34 <mounty> There are files missing in the ‚Äòfilepath-1.4.1.1@filep_4leOGk2xLu95rkmqsPAp7S‚Äô
15:50:35 <mounty> package,
15:50:37 <mounty> try running 'ghc-pkg check'.
15:50:38 <mounty> Wot next ?
15:51:09 <mounty> I tried rm -r $HOME/.cabal then cabal update but no change.
15:52:43 <hpc> have you tried doing what it recommends in the error message?
15:54:41 <mounty> hpc:  yes but nothing useful from that:
15:55:35 <mounty> Just the usual stuff about haddock and not found when searching the path.
15:55:46 <mounty> There are problems in package distributive-0.5.0.2:
15:55:47 <mounty>   Warning: library-dirs: /home/mounty/.cabal/lib/i386-linux-ghc-7.10.3/distributive-0.5.0.2-52ej8dL2uBm9KITk9G0qcy doesn't exist or isn't a directory
15:55:49 <mounty>   Warning: haddock-interfaces: /home/mounty/.cabal/share/doc/i386-linux-ghc-7.10.3/distributive-0.5.0.2/html/distributive.haddock doesn't exist or isn't a file
15:55:50 <mounty>   Warning: haddock-html: /home/mounty/.cabal/share/doc/i386-linux-ghc-7.10.3/distributive-0.5.0.2/html doesn't exist or isn't a directory
15:55:52 <mounty>   import-dirs: /home/mounty/.cabal/lib/i386-linux-ghc-7.10.3/distributive-0.5.0.2-52ej8dL2uBm9KITk9G0qcy doesn't exist or isn't a directory
15:55:53 <mounty>   cannot find any of ["Data/Distributive.hi","Data/Distributive.p_hi","Data/Distributive.dyn_hi"]
15:55:55 <mounty>   cannot find any of ["Data/Distributive/Generic.hi","Data/Distributive/Generic.p_hi","Data/Distributive/Generic.dyn_hi"]
15:55:56 <mounty>   cannot find any of ["libHSdistributive-0.5.0.2-52ej8dL2uBm9KITk9G0qcy.a","libHSdistributive-0.5.0.2-52ej8dL2uBm9KITk9G0qcy.p_a","
15:56:06 <hpc> oh! you also need to remove ~/.ghc
15:58:03 <mounty> OK, thanks hpc:  trying that now.
15:58:34 <hpc> .ghc has your user package database
15:58:56 <hpc> which points to .cabal which is where it puts things it builds
15:58:58 <mounty> hpc:  should I rm -rf .cabal-sandbox as well?
15:59:18 <hpc> might be fine
16:05:03 <kuribas> If I have "instance Unifiable a e => Unifiable (a, a) e", why does ghc say the coverage condition fails?
16:05:18 <kuribas> with "class Unifiable a e | a -> e "
16:05:43 <kuribas> since a determines e, doesn't (a,a) determine e?
16:07:17 <hpc> it wants every type variable in the 'e' position parameter to occur in the 'a' position parameter
16:07:26 <hpc> meaning e needs to occur in (a, a)
16:07:31 <hpc> http://stackoverflow.com/questions/11959764/what-is-the-coverage-condition
16:09:54 <kuribas> Isn't that implied by "Unifiable a e =>"?
16:10:20 <kuribas> meaning a contains an e?
16:11:41 <kuribas> Since e occurs in a, e occurs in (a, a)
16:13:51 <kuribas> hm, it's really disappointing haskell cannot infer that.
16:14:18 <kuribas> it seems like a no-brainer
16:14:24 <kuribas> unless I am missing something.
16:14:59 <mniip> can you paste the context?
16:15:03 <mniip> should be inferable
16:15:04 <hpc> there might be some relaxed coverage thing, afaict from google
16:15:45 <kuribas> well it seems mtl has the same problem: http://hackage.haskell.org/package/mtl-2.1.2/docs/src/Control-Monad-State-Class.html
16:16:06 <kuribas> for example: instance MonadState s m => MonadState s (IdentityT m) where
16:17:05 <kuribas> if "MonadState s m" satisfies the coverage condition, so should (MonadState s (IdentityT m))
16:17:49 <mniip> kuribas, add UndecidableInstances
16:17:49 <mniip> will make the fundep check recurse into the context
16:19:20 <kuribas> mniip: so the check is because it might not terminate?
16:19:36 <mniip> yes
16:20:13 <kuribas> isn't this like a graph search?  ghc could infer instance a and b don't depend on each other?
16:20:36 <kuribas> strange...
16:20:37 <c_wraith> it could, but that's not what the spec says to do. 
16:21:33 <c_wraith> and if you're going to do something other than the spec, might as well just jump to what UndecidableInstances gives you. 
16:21:49 <kuribas> yes
16:26:20 <kuribas> so UndecidableInstances is relatively safe (despite the name)?
16:26:38 <c_wraith> it's perfectly safe. 
16:27:00 <c_wraith> undecidable isn't a bad word. it just means compilation may fail. 
16:27:05 <kuribas> right
16:30:22 <c_wraith> also, I think you can encode the halting problem in the type system with fundeps and UndecidableInstances. so.. no, can't always figure it out exactly. 
16:31:30 <hpc> there's a depth limit on resolving instances that stops it from happening
16:33:21 <c_wraith> that stops the compiler from going into an infinite loop. it doesn't stop you from writing the encoding. :) 
16:36:11 <kuribas> I see.
16:59:08 <SecretAgentX-9> I have a general Functional question for you all.  If you're building an application that is keeping track of state in-memory, should you treat that "module" as an IO module? 
17:00:38 <SecretAgentX-9> For example, say an ATM that is just in-memory accounts for the hell of it. When you update accounts would all the CRUD actions on an "AccountRepository" be IO even though its really an in-memory list? 
17:02:40 <c_wraith> maybe. depends on your needs and your desired model. 
17:03:21 <hpc> if you're doing it with mutation, it's going to be something like IORef
17:03:47 <c_wraith> if you want to use a concurrent programming model for multiple things that influence each other, you'll need some sort of mutability. 
17:03:56 <ertes> SecretAgentX-9: i consider 'iterate' a stateful function
17:03:57 <SecretAgentX-9> Yes
17:04:03 <ertes> > iterate (1 +) 0
17:04:05 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:04:42 <c_wraith> if you don't need a concurrent model, it's often easier to skip mutability. 
17:05:03 <ertes> SecretAgentX-9: state has nothing to do with mutability‚Ä¶  the latter is just one method to implement the former
17:05:16 <SecretAgentX-9> Perhaps its easier to explain what I'm doing. 
17:05:49 <SecretAgentX-9> I'm making  a fake stock ticker. A user can subscribe to a symbol.  
17:06:17 <SecretAgentX-9> (Subscriber, [Symbol]) 
17:06:39 <SecretAgentX-9> how would you update a list of subscribers and their symobls they are subscribed to in memory if everything is immutable. 
17:08:09 <hpc> you could probably even fake a stock ticker algebraically
17:08:13 <ertes> SecretAgentX-9: recursion with a changed value
17:08:14 <hpc> with some wonky functions of sin and cos
17:08:29 <ertes> SecretAgentX-9: or the countless abstractions of that (state monads, automaton arrows, etc.)
17:08:29 <Gurkenglas> SecretAgentX-9, where do the updates come from? The Internet? An RNG?
17:10:03 <SecretAgentX-9> So I implemented it in JavaScript. When a user first requests a Quote it does an  HTTP request to Google and gets the real current prices. After that it's all just faked by getting a random number and updating the quote
17:11:12 <SecretAgentX-9> http://trader.gilboy.io/  https://github.com/StephenGilboy/ticker-tapi/blob/master/src/domain/ticker.js#L193
17:11:25 <SecretAgentX-9> And I'm trying to clean all that up by making it functional 
17:14:13 <SecretAgentX-9> Sorry, if this is the wrong spot. I'm just trying to grasp updating lists without setting the variable to the new list 
17:17:08 <ertes> SecretAgentX-9: exercise: implement a function that prints the numbers 0 to 99 with the following limitation: the only functions you are allowed to use are 'print', 'pure' and (>>)
17:17:29 <ertes> each number has to be printed on its own line
17:18:02 <SecretAgentX-9> Alright, I will 
17:18:11 <ertes> SecretAgentX-9: another limitation: you must not mention the 'print' function more than once in the function body
17:27:04 <student> Hi, I need some guidence, with Data.Graph library
17:27:14 <yulax> student: are you a student
17:27:24 <student> yes i am
17:27:31 <yulax> that's odd. 
17:27:42 <student> why is it odd
17:27:45 <monochrom> I am a monochrom, too.
17:28:13 <monochrom> ertes: May I use addition or succ?
17:28:36 <ertes> monochrom: thanks
17:28:42 <ertes> SecretAgentX-9: you may use (+), too =)
17:29:13 <ertes> SecretAgentX-9: (also i called it a "function", but it's actually just an IO action)
17:29:41 <student> anyway, is there any way to get a list of certain node on a graph? like with this graph import Data.Graph graph = buildG (1, 6) [(1, 2), (1, 3), (2, 4), (5, 6)], get the neighbours of 1 = [2,3]?
17:35:36 <Gurkenglas> student, the Graph itself has type Table [Vertex] of the neighbors of each vector, which means you can look up the neighbors of 1 using Data.Array's (!): graph ! 1
17:36:09 <Gurkenglas> (Table is also defined in Data.Graph, and means Array Vertex)
17:37:07 <student> Gurkenglas: this is odd, my ghci said Not in scope: '!'
17:37:24 <Gurkenglas> student, you have to import Data.Array
17:37:49 <student> AAAAAHHHH
17:38:08 <student> Gurkenglas: Thank you! :-D
17:38:35 <Gurkenglas> You'd think Data.Graph would reexport that.
18:16:11 <ertes> is there a way to go from one Fd to two Handles, one for reading, one for writing?  i need separate buffering modes for them
18:21:36 <c_wraith> ertes: there is, though the obvious approach doesn't force a distinction between reading and writing.
18:22:06 <c_wraith> ertes: but the buffering mode is part of the file descriptor, not the handle
18:22:58 <ertes> ah, hmm
18:23:04 <ertes> so i need to duplicate that one
18:23:53 <ertes> c_wraith: does hClose also close the underlying fd?
18:23:58 <c_wraith> yse
18:24:00 <c_wraith> *yes
18:24:39 <ertes> c_wraith: so each time i want to create a pair of Handles from an fd, basically i have to duplicate it twice‚Ä¶  right?
18:25:06 <c_wraith> If you want them both to be independent of the starting FD, it would seem that way
18:25:43 <ertes> c_wraith: i pass those Handles to code that is not in my control, and that may close them‚Ä¶  i need a way to create a new pair after that has happened
18:26:05 <ertes> without actually closing the underlying fd, which is a terminal
18:26:12 <c_wraith> I'm not 100% certain everything will work exactly right.
18:26:24 <ertes> ok, i'll just try it then, thanks
18:33:05 <o`connor_> Does anyone have experience getting nvim-hs working? I followed the tutorial and can't run :echo Fibonacci(2000)
18:57:21 <tnks_> I've got too applications.  One is a webserver using Servant, and the other does some FFI calls to rdkafka for backend processing.
18:58:03 <tnks_> the Servant app runs as expected, but the rdkafka one seems to be running my CPUs (and fan) through the wringer.
18:59:17 <tnks_> I did some Googling, and it turns out disabling idle garbage collection (+RTS -I0 -RTS) solves the problem for the app that's acting up.
18:59:41 <tnks> but I'm really not happy just applying a bandaid fix without understanding this more.
18:59:59 <tnks> why might the idle garbage collector be a problem on the Servant application?
19:00:07 <tnks> not be, I mean.
19:05:42 <tnks> ah, this article seems good and relevant:  https://www.well-typed.com/blog/2014/02/ghc-events-analyze/
19:06:19 <how> If I want to simulate a 1d array with a moving pointer I can use a list zipper, is there any data structure that I can use for a 2d analogue?
19:06:57 <geekosaur> a zipper of zippers, maybe?
19:08:54 <how> wouldn't the time complexity be quite bad when I jump from one zipper to the other?
19:10:03 <geekosaur> the implementation would just be shuffling a different set of pointers
19:10:11 <geekosaur> not copying data
19:10:36 <how> geekosaur: can u elaborate
19:11:18 <geekosaur> laziness is implemented by having everything be a pointer internally
19:12:36 <geekosaur> so for the zipper of zippers case, it's going to be pointers to zippers, not the inner zippers themselves, in the outer zipper. likewise for the 1d case, you don't actually have the data in the zipper but pointers to it
19:14:20 <geekosaur> so in both cases, rotating the zipper is copying pointers instead of data
19:14:49 <how> geekosaur: Let's say I want to simulate a n by n array. If I start at position (0,0), move to (n, 0), then move to (n, n), then move to (0, n)
19:15:28 <how> wouldn't a zipper of zipper implementation uses O(n^2) time
19:16:02 <how> Since I have to move the position n times to the right for each zipper
19:16:20 <geekosaur> technically yes. but with a very small constant factor, so n^2 doesn't end up actually being much time
19:17:15 <c_wraith> small n also makes O(n^2) not so bad. :)
19:17:17 <geekosaur> that said, if you are actually working with an array, you probably do not want to simulate it with a list or anything based on a list (such as a zipper); you may want an actual array, along with State / StateT carrying the current indices
19:17:34 <geekosaur> because the real time complexity hit will come from using lists
19:17:41 <how> I'm asking is there a more eficient data structure
19:17:49 <geekosaur> because they are singly linked lists, not really addressable
19:18:08 <geekosaur> (worse, for a zipper it's *two* lists)
19:19:00 <how> Wouldn't StateT Array be even slower since I have to update the whole array every single step
19:19:20 <geekosaur> there are mutable arrays (STArray, IOArray)
19:19:35 <how> the obvious way is to work in a ST monad, but it the makes the code so much uglier
19:19:59 <how> so I'm asking is there a functional alternative
19:20:25 <geekosaur> that said, updating an array isn't necessarily bad --- the implementation splits the array into "cards" and updates those cards as needed, not the whole thing
19:21:11 <how> geekosaur: what do u mean
19:21:20 <geekosaur> plus if it knows that there's only one live pointer to the array, it can cheat and update in-place
19:21:40 <geekosaur> (this is where purity comes in handy, it means the runtime *does* know when it's allowed to cheat)
19:22:09 <how> geekosaur: you mean that is implemented in the array package?
19:22:38 <geekosaur> underneath the array package, since the garbage collector has to know about it
19:22:49 <geekosaur> the array primitives in the compiler implement it
19:23:06 <geekosaur> the array package implements the user visible API, including fancy indexing
19:24:36 <geekosaur> this does mean that you tend to need to know too much about runtime/gc internals to get good performance out of Data.Array. the alternative is nested Data.Vector, which has less magic going on behind the scenes but makes you do more work
19:24:56 <c_wraith> The array package no longer has the DiffArray stuff.  It was a cute idea, but the constant factors just didn't work.
19:25:25 <wespiser> are extensible effects a suitable alternative to mtl, for interpreted languages?
19:26:31 <Gurkenglas> You could also keep track of your position in a https://en.wikipedia.org/wiki/Quadtree , with average-case constant, worst-case logarithmic time per movement step
19:26:53 <Gurkenglas> (Looks like a zipper.)
19:30:35 <how> Gurkenglas: thanks, will look into it
19:31:04 <wespiser> is anyone using EFF for language implementation? I've only seen it used in the white paper, and am looking into using it in industry
19:31:17 <wespiser> *extensible effects
19:31:27 <wespiser> thanks guys!
19:31:56 <Gurkenglas> In fact, if you like lens, https://hackage.haskell.org/package/lens-3.2/docs/Control-Lens-Zipper.html gives you an API for that, though the "lateral movement" parts are on the one-dimensional representation of the four children of a node not the two-dimensional.
19:32:04 <c_wraith> several languages have systems based on extensible effects.
19:32:11 <c_wraith> Purescript, for instance.
19:32:17 <c_wraith> I think Idris, too
19:32:29 <wespiser> thanks, will look into this now
19:40:29 <fosskers> c_wraith, I haven't checked what Purescript has been up to for the past year or so. What's the state of their Effect handling? Last I checked they advocated a mix of Eff + Monad transformers, which seemed to me to defeat the purpose
19:41:02 <c_wraith> fosskers: I don't actually use purescript, so I'm just going by examples others have posted - but it seems Eff is the standard approach now
19:41:55 <fosskers> that would be good news if true
19:46:25 <wespiser> On idris, I know they are using Effect based monads in Idris Actual, looking into Idris implementation
19:49:32 <wespiser> for Idris implementation, they are using a straight state monad
19:49:33 <wespiser> https://github.com/idris-lang/Idris-dev/blob/ad1343827cb052d23196494cd24659d2a38c220a/src/Idris/Core/Evaluate.hs#L48
19:51:07 <wespiser> https://github.com/idris-lang/Idris-dev/blob/ad1343827cb052d23196494cd24659d2a38c220a/src/Idris/Core/Evaluate.hs#L259
19:51:51 <wespiser> it looks like what they are doing is passing in an explicit, "env" and "context", then return an "Eval Value" where Eval is State
19:52:09 <wespiser> I like it!
20:06:03 <newbie07> Hello :) So I implemented a strict STLC, with the Z combinator (actually I have infinite amount of Z for different type). So, now I want to do a denotational semantic of it
20:06:19 <newbie07> But what is the denotational semantic of Z?
20:27:00 <wespiser> is this an example of extended effects?
20:27:01 <wespiser> https://github.com/purescript/purescript/blob/master/src/Language/PureScript/CodeGen/JS.hs#L46
20:27:19 <wespiser> what's going on with the class constraints of m ?
20:38:37 <c_wraith> wespiser: no, that's mtl style
20:38:55 <wespiser> thanks, so both typescript and idris are using mtl style
20:39:00 <c_wraith> internally.
20:39:17 <c_wraith> (*purescript)
20:39:30 <wespiser> sorry, Purescript 
20:39:55 <c_wraith> I was referring to the interface the langauge provides its users, rather than its implementation
20:40:05 <wespiser> I really like how Idris does things, using just a State monad and passing env/context explicitly 
20:40:08 <wespiser> ohh, I see
20:40:30 <wespiser> i'm interested in learning more about extensible effect systems
20:41:55 <wespiser> I think an extensible effects tutorial, or series of examples, would really help it become more widespread. That is, if it is really better than mtl.
22:40:31 <codygman> text-show implements TextShow for (Identity a) but when I do "showt (Identity (1 :: Int))" I get "No instance for (TextShow (Identity Int))". Any ideas?
22:45:12 <wespiser> do you need Int to be an instance of the typeclass TextShow?
22:45:54 <wespiser> otherwise, I would just declare (Identity Int) as an instance of Text show and see what happens
22:51:33 <codygman> wespiser: It looks like for some reason I had an old version of text-show "stuck"
22:51:48 <wespiser> roger! 
22:52:45 <codygman> wespiser: Specifically I was trying to replace the showFields function here with the Text version: https://github.com/acowley/Frames/blob/master/src/Frames/Rec.hs#L52
22:53:25 <wespiser> oh nice! How do you find Frames for data processing?
22:58:36 <codygman> wespiser: Well I had to make some additions (https://github.com/codygman/frames-diff/blob/master/Frames/Diff.hs) but I also have a WIP tutorial here: https://github.com/codygman/frames-example-cdi
22:59:16 <codygman> something else really important in practice was ability to override the inference selectively, but that won't be merged in to master until the test is added which requires refactoring the test harness
22:59:45 <codygman> but statically typed structural typing is **perfect** for data processing IMO.
23:00:12 <wespiser> codygman: thanks, I'll look into statically typed structural typing
23:00:24 <wespiser> btw, nice work on hs-scrape
23:00:37 <wespiser> have you had to render javascript before parsing?
23:03:07 <codygman_> I don't think you'll find much about static/structurally typed stuff, at least I didn't when I was looking for papers.
23:04:20 <wespiser> I haven't, I just found someone talking about how its hard to get right
23:04:43 <wespiser> I've implemented a SQL toy language in haskell, I basically moved all operations on data into dynamic typing
23:05:09 <codygman_> wespiser: Yeah, all I found was people talking about how it's hard to get right too :D
23:05:33 <wespiser> codygman_: if it happens, it will probably be in Haskell
23:05:51 <codygman_> That's cool. I see your interest in something like Frames then, where you could possibly avoid making everything dynamic
23:06:21 <wespiser> yea, I "borrowed" a little bit from frames, basically just the row dominant representation of a table
23:09:03 <wespiser> the tutorial looks good, so far. I like how you break down fold into components, its the exact same thing I do mentally
23:39:54 <purelazy> How do I upgrade the compiler to version 8.0?
23:40:25 <Lokathor> purelazy, depends. with stack you can just set your lts to a newer version and it will get a newer GHC if it needs to
23:40:34 <Lokathor> with haskell platform you probably need to go download it
23:40:55 <purelazy> I just installed the platform on Linux Mint
23:41:03 <Lokathor> from the package manager?
23:41:23 <purelazy> Yeah
23:41:32 <Lokathor> well, it's entirely possible that the package manager didn't deliver you the 8.0 version
23:41:41 <purelazy> I realize that
23:41:58 <Lokathor> what i mean is that you'll possibly have to bypass the package manager
23:42:07 <Lokathor> and use stack or the haskell platform
23:42:09 <purelazy> I was expecting "stack" to run from the command line
23:42:19 <Lokathor> stack should, if you insatlled that
23:42:37 <purelazy> box ~/Desktop/haskool $ stack
23:42:37 <purelazy> No command 'stack'
23:43:07 <Lokathor> you may have to go download stack seperately. I don't know what the repos for Linux Mint are like, but stack isn't the same as ghc and it's also not the same as the haskell platform
23:43:22 <Lokathor> what does "ghc --version" give?
23:43:32 <Harm> in ubuntu you have the package 'haskell-stack' for stack
23:44:53 <purelazy> 7.6.3 - but I need 8.0
23:45:26 <Lokathor> yes, your package system might be lagging quite a bit. Unless Linux Mint does the stable/testing/unstable sort of thing Debian does
23:46:05 <purelazy> Hmmm
23:46:17 <Lokathor> https://docs.haskellstack.org/en/stable/README/#how-to-install this guide can help you install stack without using the package manager, if you want to go that route. or you can look for a haskell-stack type of package
23:47:43 <Harm> I installed haskell-stack and then used `stack upgrade` to upgrade it to the latest version
23:48:11 <purelazy> Mint's haskell-platform looks quite old - 2013.2.0.0.debian3
23:48:20 <Lokathor> yikes
23:48:22 <purelazy> But its installed now
23:48:25 <int-index> On Ubuntu I recommend the Stack PPA
23:48:37 <Lokathor> well "stack upgrade" should be able to move you to the newest stack
23:50:07 <purelazy> Is there no up-to-date platform package I can get from somewhere?
23:50:34 <Lokathor> package managers tend to lag far behind the "recent" versions of things, sadly
23:50:39 <purelazy> As in - un-install this antique, and get a new one
23:50:55 <purelazy> Lokathor - I am aware of that
23:51:06 <Lokathor> well, follow that link above to haskellstack.org
23:51:12 <Lokathor> and it will explain how to get a latest version of stack
23:52:45 <purelazy> As in ... curl -sSL https://get.haskellstack.org/ | sh
23:53:03 <Lokathor> yes, that's most likely to work for linux
23:53:15 <purelazy> Okie dokey
23:53:55 <purelazy> No need to be root then?
23:54:07 <Lokathor> it will use sudo on its own automatically, i think
23:54:37 <Lokathor> i've only used that install method once, but that's how i recall it working
23:55:00 <purelazy> Its running ... 
23:55:05 <purelazy> D/Ling
23:55:18 <Lokathor> shouldn't take too long, stack is only like 6mb on its own
23:55:49 <Lokathor> then "stack setup" will get you the correct GHC for whatever project you're using, or a default GHC when you're not in a project, and that'll be the big download of a few hundred MB
23:58:00 <purelazy> $ stack setup
23:58:01 <purelazy> Using latest snapshot resolver: lts-7.14
23:58:09 <purelazy> lookin good
