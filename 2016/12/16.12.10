00:00:05 <cocreature> bollu: yeah but I’ve never used vulkan nor the haskell bindings :)
00:00:08 <jle`> vector-sized is as lightweight as you can get, i believe, with this typed level stuff
00:00:36 <bollu> http://lpaste.net/349739 uhh, compiler error
00:00:39 <jle`> but, there is some inherent redundancy that comes with using Data.Vector types
00:00:46 <bollu> with compiling Vector.Sized
00:00:47 <cocreature> I think the author of the vulkan bindings complained about the compile times to the GHC devs so then bgamari wrote vector-sized
00:01:02 <jle`> GHC has to carry around the size of the vector twice at runtime
00:01:37 <jle`> once with the KnownNat dictionary, and once because of the low-level implementation of Data.Vector
00:01:48 <bollu> EvanR: I don't understand, what do you mean by "because youre under your own power now!"? :) english isn't my first language
00:01:58 <jle`> bollu: try ghc 8
00:02:06 <bollu> oh
00:02:07 <bollu> hm
00:02:18 <EvanR> i dont even know
00:02:20 <jle`> isn't the latest nightly ghc 8 anyway?
00:02:20 <bollu> so now my library will only work for people with GHC 8?
00:02:26 <jle`> the error is kinda weird though
00:02:46 <jle`> 'index' is not defined the right way in that library anyway
00:02:53 <jle`> it shouldn't be taking a proxy lol
00:03:11 <jle`> that's one of the mistakes of that library i believe
00:03:54 <bollu> there a 2 libraries: sized-vector and vector-sized. I'm using vector-sized. That's correct, right?
00:04:07 <jle`> yes
00:04:10 <EvanR> bollu: more like "try it and see"
00:04:13 <bollu> xD
00:04:28 <bollu> I'm downloading 7.12 lts snapshot
00:04:35 <bollu> I <3 stack (sorry cabal devs)
00:06:26 <liste> stack <3 Cabal
00:07:35 <cocreature> stack accelerated cabal development so I think we can all be happy that stack exists whether we use it or not
00:07:54 <bollu> heh, I know :)
00:08:08 <bollu> but sometimes I've recieved flak for using stack. I always feel bad when that happens
00:08:40 <EvanR> public shaming for using particular dev tools? xD
00:08:56 <bollu> yes, not kidding xD
00:09:02 <jle`> if there's anything i've learned from programming for all these years ...
00:09:06 <cocreature> I feel bad for people that give other people flak for their choice of tooling
00:09:15 <jle`> people love to publically shame others for choice of dev tools
00:09:44 <Jello_Raptor> I need to make some minor changes (add a deriving clause to something that doesn't hae one but should) to a pakage (sbv). Given my project is using stack is there a standard/easy way to do that that lets me keep things reasonably separated?
00:10:37 <cocreature> jle`: I don’t get why that’s so popular (but I agree it is).
00:12:22 <jle`> Jello_Raptor: is sbv your package?
00:12:26 <jle`> if so then you can just modify the code
00:12:26 <Jello_Raptor> nope
00:12:40 <jle`> oh, you want your package to use a modified version of sbv?
00:12:45 <Jello_Raptor> yup
00:12:48 <cocreature> you can still just modify the code and point stack at a local directory
00:12:53 <cocreature> or at a github repository (i.e. your fork)
00:13:00 <jle`> you can just add a line to the stack.yaml file to tell it where to find the modified package source
00:13:05 <Jello_Raptor> oh cool
00:13:13 <jle`> if you generated the stack.yaml automatically, there should be instructions
00:13:40 <jle`> it should be above the "packages:" section
00:13:57 <jle`> remember to add 'extra-dep: true'
00:14:15 <Jello_Raptor> and stack.yaml overrides the stackage shapshot thing if there's conflicts?
00:15:08 <jle`> yeah, those take priority
00:15:27 <cocreature> that also works for transitive deps
00:15:47 <cocreature> so if your package A depends on package B which depends on package C, you can still add C to your stack.yalm and B will be rebuilt
00:16:27 <Jello_Raptor> brilliant
00:16:32 <Jello_Raptor> that's incredibly easy
00:16:56 <jle`> i know right
00:17:06 <cocreature> iirc recent cabal has a similar feature but I forgot the syntax
00:23:40 <jle`> i think recent cabal has feature parity with the stack tool?
00:23:40 <jle`> i have heard this claim but i cannot verify
00:35:02 <Xnuk> Can I make `import qualified` statements in TemplateHaskell?
00:35:46 <c_wraith> no
00:35:57 <c_wraith> Template Haskell can't generate imports at all
00:36:46 <c_wraith> Template Haskell depends on imports to define functions used in splices.  As such, it's set to run after all imports are resolved.
00:36:55 <c_wraith> A consequence of that is that it can't generate imports.
00:38:37 <Xnuk> (._.
01:16:55 <unskill> Are there Monoid homomorphisms in Haskell?
01:17:06 <unskill> I mean. Library.
01:18:51 <mniip> monoid-extras?
01:22:06 <unskill> But. I've understood that what I want doesn't look like monoid homomorphism.
01:22:11 <unskill> mniip: ty
01:28:13 <paolino> is there a reason why ContT r (Writer w) is not a MonadWriter ?
01:30:28 <lyxia> can you implement listen
01:45:52 <jchia_> Is there something like filter that works on Maybe a instead of [a], treating Maybe a is a list of 0 or 1 elements?
01:47:09 <jchia_> e.g. filter' (> 0) (Just 0) == Nothing
01:47:17 <effectfu1> jchia_: mfilter
01:47:25 <effectfu1> from Control.Monad
01:47:57 <jchia_> effectfu1: Thanks. I should go and learn up on MonadPlus.
01:54:39 <Gurkenglas> jchia_, https://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html
02:34:08 <deank> :t mfilter
02:34:10 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
02:35:12 <deank> why is MonadPlus constraint needed and not just Monad?
02:38:43 <srhb> deank: In this case, it needs a concept of "zero" that Monad doesn't have.
02:40:35 <srhb> (Though I suppose you could really get by with fail...)
02:42:09 <srhb> But fail shouldn't be in Monad anyway, so... :-)
03:17:26 <jchia_> deank, srhb: You need mplus & mzero in order to combine multiple items when doing mfilter, not just mzero to support 'dropping' items for which the predicate is False.
03:18:09 <jchia_> mplus & mzero are analagous to mappend & mempty
03:20:45 <jchia_> actually, it seems that mplus is not actually used
03:23:09 <Forlorn> Hi, I successfully managed to get this parsed without errors
03:23:14 <Forlorn> let f _ [] = []; f ys (x:xs) = (filter (\s -> not $ s == 'a') ys) : xs
03:23:47 <Forlorn> but when I do f "abc" "abc" I get error, do I perhaps need to explicitly set expected function signature?
03:24:31 <Forlorn> http://sprunge.us/UPaL
03:24:34 <Forlorn> ^ error
03:25:59 <ph88> hi guys
03:26:26 <Forlorn> oh I see my problem now
03:26:31 <Forlorn> nevermind, what was I thinking :/
03:26:46 <ph88> this code works https://paste.fedoraproject.org/503063/14813691/ however  foo = F (Q (B2 "hello"))  and i don't want to apply the biplate when Bar is using constructor B2, only when it's using constructor B  .. how can i achieve this ?
03:40:27 <Gurkenglas> What would break if _|_ matched (_|_,_|_)?
03:42:48 <ph88> hi Gurkenglas 
03:44:30 <int-e> Gurkenglas: Do you mean, what if (_,_) matched _|_?
03:45:19 <Gurkenglas> Probably that if that's how you write that
03:46:49 <Gurkenglas> f &&& g wouldn't be strict even if f and g are, but since the argument is evaluated once fst or snd is, that shouldn't be a problem, right
03:49:45 <Gurkenglas> It feels like it would lead to (,) having no runtime overhead, as is the case with newtypes
03:49:53 <int-e> Hmm, tricky. I wouldn't expect programmers to rely on _|_ not being a pair (pure functions just become more defined...), but I would expect this to be an occasional source of subtle space leaks.
03:52:15 <int-e> Oh there are two directions you could go. You can make the constructor strict (and that I suspect *would* cause trouble; just look at the State monad, and consider  return undefined), or you could make pattern matching more lazy, which is what I assumed your question was.
03:52:58 <ph88> brb
03:53:15 <Gurkenglas> No, the constructor is lazy
03:53:47 <Gurkenglas> (I think your second option is the one I mean?)
03:54:34 <int-e> But in the latter case I see no potential for reduced overheads... where would that come from?
03:55:53 <Gurkenglas> Instead of (,) being a constructor, you would have something like what I think C structs are implemented like
03:56:20 <Gurkenglas> (Instead of (,) being a constructor on the RAM level, that is)
03:58:36 <Gurkenglas> It should lead to zipping two packed arrays of equal length reducing the space requirements by one packed-array-metadata
04:04:27 <int-e> So you want to get rid of the tag word? Well there will be a cost to make that work: Whenever you have an f :: a -> (b,c), an application f x will have to produce a pair of pointers to two thunks on the heap (approximately: (fst (f x), snd (f x))). Oh and in the garbage collecter would have to learn about types; and you still have to box pairs to pass them to polymorphic functions. (how does  map...
04:04:33 <int-e> ...f  with f :: (a,b) -> (a,b)  work?)
04:06:23 <ph88> anyone here know about lens ?
04:06:44 <liste> ph88: sure, do you have a question?
04:06:48 <ph88> ya
04:07:02 <ph88> this code works https://paste.fedoraproject.org/503063/14813691/ however  foo = F (Q (B2 "hello"))  and i don't want to apply the biplate when Bar is using constructor B2, only when it's using constructor B  .. how can i achieve this ?
04:08:27 <Gurkenglas> Doesn't f x currently have to produce a (,) tag followed by two pointers to thunks on the heap?
04:09:13 <int-e> Gurkenglas: no, f x would just be a thunk at the point I'm imagining, which will become a pair when evaluated
04:09:57 <int-e> Gurkenglas: note that I'm talking about something like   let a = f x in ... a ..., where the compiler can't decide yet whether f x ever has to be evaluated
04:10:48 <int-e> ph88: I'd probably try my luck on #haskell-lens
04:11:11 <Gurkenglas> Why can't f x in my version stay a thunk until someone tries to reduce it to normal form, at which point it becomes a packed pair of pointers to thunks?
04:11:25 <int-e> Gurkenglas: how do you distinguish the thunk from an evaluated pair?
04:11:42 <int-e> ...you just got rid of the tag word that allowed that...
04:11:46 <Gurkenglas> Ohh
04:13:03 <Gurkenglas> And newtypes dont have that problem because they can inline the thunk that the "packed 1-tuple of pointers" would point to, while doing that for (,) could duplicate thunks
04:15:34 <int-e> Gurkenglas: if you follow that thread a bit further you'll understand why unboxed tuples only exist as return types in ghc :)
04:16:45 <Berra> I'm looking for some word or term that describes the act of using type signatures creating a more specific function based on some other function. intToDouble :: Int -> Double \n intToDouble = fromIntegral -- would be one example.
04:18:22 <Gurkenglas> Specialization?
04:19:35 <Berra> Gurkenglas: I guess that's the best term?
04:26:06 <Gurkenglas> ph88: 'foo & traverseOf (biplate . _B) .~ "goodbye"' assuming you derived prisms for Bar?
04:32:10 <ph88> Gurkenglas, eh that code snippet i posted is self-contained. I can not really tell whether i use prisms or don't use prisms in that code snipper ^^
04:32:32 <ph88> also _B doesn't ring a bell
04:32:46 <ph88> eh my train is arriving, be back in like 30 min or so
04:47:55 <jchia_> hspec question: If my test requires an input file, how do I provide it to the test? Do I put it in some designated directory in the source tree and somehow get the test to change to that directory so that I can read it? Or, do I have to manually create a temp directory, cd there and then write the input file? Or, something else?
04:49:10 <ph88> Gurkenglas, i'm back :)
04:49:14 <jchia_> I'm testing a function that returns an IO a that reads an input file
04:50:06 <NextHendrix> ph88: i too just got on a train
04:50:18 <ggVGc> trains are great for haskell
04:50:24 <ph88> NextHendrix, well i just left a seat empty so you can use that one :P
04:50:38 <NextHendrix> cheers lad 
04:51:20 <Gurkenglas> ph88: You'll need a prism from Bar that doesn't match B2 so you can compose biplate to Bar with your prism to the String
04:52:17 <ph88> Gurkenglas, ok i'll take that as a good clue since i don't know what prisms are so i guess i have some reading to do :P Any recommendations ?
04:52:52 <Gurkenglas> Prisms are just Traversals that only go through up to one element
04:53:36 <ph88> oki thx picklejar
04:54:48 <ertes> was there a netsplit just now?  i don't see everything
04:54:51 <Gurkenglas> Like _head, or ix 2. Control.Lens.TH lets you derive lenses into a record and prisms into sum data definitions
04:58:40 <ertes> > _head # 5 :: [Integer]
04:58:42 <lambdabot>  error:
04:58:43 <lambdabot>      • Couldn't match type ‘s0 -> f0 s0’
04:58:43 <lambdabot>                       with ‘Data.Tagged.Tagged [Integer] (Identity [Integer])’
04:58:54 <ertes> :t _head
04:58:56 <lambdabot> (Cons s s a a, Applicative f) => (a -> f a) -> s -> f s
04:59:29 <ertes> :t _Just
04:59:31 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
05:00:07 <ertes> > _Just # ()
05:00:10 <lambdabot>  Just ()
05:00:27 <ertes> Gurkenglas: not quite…  prisms are stronger than singleton traversals
05:01:06 <Gurkenglas> Oh right there was also that stuff about turning them around to construct s from Prism' s a and a
05:01:34 <ertes> singleton traversals are really just lenses with a needlessly strong context (they should use Functor instead of Applicative)
05:02:09 <Gurkenglas> You mean, SingletonTraversal' s a = Lens' s (Maybe a)?
05:02:37 <ertes> no, literally SingletonTraversal = Lens
05:02:44 <ertes> ideally
05:02:54 <Gurkenglas> But I said up to one element
05:03:01 <ertes> ah, sorry
05:09:38 <nikola> Hello, why does declareLenses [https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:declareLenses] strip all record syntax in the input and is there alternative way do same thing without stripping record syntax? I'm generating data types via TH and I would like something similar to makeLenses'' :: DecsQ -> DecsQ (or even Dec -> [Dec]). Basically, I want to avoid reifying types and
05:09:40 <nikola> explicitly send Dec (makeLenses takes Name, reifies it and then retrieves the Dec from it - is it possible to skip this step without exposing lenses internals?) Thank you :)
05:14:39 <mrkgnao> I have this function:
05:14:48 <mrkgnao> eat p (f:fs) game = eat p fs (eat' p f game)
05:15:11 <mrkgnao> with the base case eat _ [] game = game
05:15:40 <mrkgnao> this looks very strongly like some kind of foldy thing to me. anyone have a clue?
05:21:18 <madgen> Hello! I have a question regarding implementing DSLs in Haskell. As I understand in Haskell, DSL implementation in Haskell revolves mostly around creating a library that provides a monad and its runner. This, however, requires the compilation of the whole library and the DSL file. I was wondering if there was a way to read Haskell DSL file and interpret it similar to how a configuration file works except 
05:21:24 <madgen> it will have arbitrary code in it that the program reading the file can execute.
05:21:45 <madgen> The last full stop should be interpreted as a question mark...
05:22:17 <kuribas> :t foldl
05:22:19 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:22:39 <hpc> magicman: first just to correct a bit of a misconception, DSLs don't have to have a monadic interface
05:23:02 <hpc> though some of the more commonly used ones do
05:23:24 <kuribas> mrkgnao: eat p l game = foldl (\g x -> eat' p x g) game l
05:23:25 <hpc> it's indeed possible to read a DSL from a separate file at runtime
05:23:45 <madgen> monadic interface remark is noted.
05:24:04 <hpc> for various reasons it's avoided if it's not truly necessary, because parsing and being able to alter the program post-modification introduces complexity and error conditions
05:24:05 <kuribas> mrkgnao: or if you rearrange eat' and eat: eat = foldl . eat'
05:24:23 <hpc> a DSL that's written within haskell itself is generally called an embedded DSL or eDSL
05:24:39 <hpc> or sometimes just DSL
05:25:50 <cocreature> madgen: there is nothing special to implementing a DSL in a separate file. in most cases you just write a parser and then an interpreter for the parse result
05:25:52 <kuribas> mrkgnao: or if you need to be lazy: eat = foldr . eat'
05:26:46 <mrkgnao> kuribas: thanks!
05:27:07 <madgen> cocreature: Well, not really because I want to be able to write arbitrary Haskell functions (say defining an equality instance) that will be called later. Technically, I can do that via haskell-src in the way you describe, but was hoping for something higher level.
05:27:27 <kuribas> mrkgnao: or foldl' to be strict in the accumulator.
05:27:31 <ertes> madgen: you may be interested in how xmonad reads its configuration (which is a haskell module)
05:27:40 <cocreature> madgen: if you want to write arbitrary haskell functions, what’s the “DS” part in your DSL?
05:27:50 <cocreature> it seems like you’re just writing ordinary haskell code at that point
05:28:11 <hpc> magicman: for an example of a package that uses a non-haskell DSL, take a look at alex and happy
05:28:24 <hpc> which are in the same family of tools as lex and yacc
05:29:10 <ertes> madgen: basically an xmonad configuration is a haskell program that uses the xmonad library (that makes xmonad a window manager *framework*, if you will), but xmonad has built-in facilities to interpret (or even compile?) and then restart itself with the new configuration on the fly
05:29:32 <madgen> hpc: I know I worked with both extensively! I am just looking for a fast solution to prototype something rather than implementing a full language.
05:29:44 <kuribas> mrkgnao: foldr folds from the right of the list, so it may not be what you want.
05:29:45 <cocreature> madgen: maybe look at https://hackage.haskell.org/package/hint
05:30:01 <mrkgnao> I'm not working with infinite things right now, so it's fine either way
05:30:16 <madgen> ertes: that's exactly the sort of thing I'm looking for. Thanks
05:30:41 <orion> Given a working cross-compiler (x86_64 targeting arm7), how do I build a project using Stack?
05:31:23 <ertes> madgen: alternatively do what shake does and don't even pretend that the haskell module is a configuration file…  just make your users use your library instead…  it's not uncommon in haskell (hakyll, shake, taffybar, …)
05:31:26 <madgen> cocreature: I think I have seen hint before. Yes, I think that would be the way to go except I thought there might be a more standardised way. But this is perfect.
05:31:52 <ertes> madgen: xmonad can be used like that, too, and that's how i "configure" it
05:32:06 <orion> GHC is in PATH. I tried specifying the cross compiler in stack.yaml using the "compiler" directive, but I get this error: Error in $.compiler: failed to parse field 'compiler': failed to parse field compiler: Failed to parse compiler version
05:32:40 <madgen> ertes: Yeah, I thought about that but I come from Ruby world (although not a complete beginner to Haskell world) and importing arbitrary modules and compiling it every time for a new DSL file feels very counterintuitive to me.
05:32:55 <madgen> Obviosuly, Ruby enjoys being an interpreted language in the first place.
05:32:59 <ertes> mrkgnao: review the definition of foldl:  foldl f x' (x:xs) = foldl f (f x' x) xs; foldl f x' [] = x'  -- now look at your own function: eat p (f:fs) game = eat p fs (eat' p f game); eat _ [] game = game
05:33:03 <kuribas> mrkgnao: then foldl' is probably what you want
05:34:14 <ertes> mrkgnao: you need _f and _x' such that:  eat p (x:xs) game = foldl _f _x' (x:xs) = foldl _f (_f _x' x) xs
05:34:18 <ertes> solve for _f
05:34:39 <madgen> ertes: cocreature: hpc: thanks a lot for valuable suggestions! Have a nice day.
05:34:51 <mrkgnao> I'm trying to use QuickCheck in my Stack project. How do I, like, tell Stack I need the library?
05:35:02 <cocreature> mrkgnao: add it as a dependency in your cabal file
05:35:02 <mrkgnao> I put it under the build-depends in the test section of the cabal file
05:35:03 <ertes> mrkgnao: eat p [] game = foldl _f _x' [] = _x' = game
05:35:07 <ertes> mrkgnao: solve for _x'
05:35:30 <ertes> mrkgnao: in other words: you can figure out how to express your function using foldl by equational reasoning =)
05:35:39 <ertes> i have a tutorial on that coming up, but it's not quite done yet
05:36:13 <mrkgnao> Then I tried running stack test, and it says "quickcheck must match version -any, but the stack configuration has no specified version"
05:36:21 <mrkgnao> so I have to specify a version? why?
05:36:30 <mrkgnao> ertes: that's great!
05:36:46 <cocreature> mrkgnao: the package is named QuickCheck not quickcheck
05:36:59 <cocreature> at some point somebody thought it would be a good idea to make package names case sensitive
05:37:05 <ertes> i can upload the current state, if you want…  it's almost finished anyway
05:41:37 <ij> I currently have these two: http://sprunge.us/MRMA I'm planning to write a modifyTVar, but could lens perhaps make this easier?
05:42:15 <ij> The function names are poor, I know.
05:45:16 <quchen> edwardk: ping
05:57:04 <ertes> mrkgnao: if you're interested, i've uploaded it now: http://ertes.eu/tutorial/foldr.html
05:58:17 <mrkgnao> ertes: your dislike of analytic things resonates deeply with me =)
05:58:42 <ertes> =)
06:11:38 <xcmw> How can I make a * -> Constriant that is both Show and Eq?
06:11:53 <xcmw> I tried 
06:11:59 <xcmw> type ShowEq a = (Show a, Eq a)
06:12:18 <xcmw> But when I use it I get
06:12:21 <xcmw> The type synonym ‘ShowEq’ should have 1 argument, but has been given none
06:14:42 <lyxia> class (Show a, Eq a) => ShowEq a where ; instance (Show a, Eq a) => ShowEq a where
06:16:47 <kuribas> xcmw: Perhaps you need the ConstraintKinds extention?
06:17:01 <dramforever> type synonyms cannot be partially applied
06:17:07 <xcmw> lyxia: That worked
06:18:13 <kuribas> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/constraint-kind.html
06:18:53 <xcmw> kuribas: I am using ContraintKinds
06:19:46 <dramforever> ertes: Amazing!
06:19:48 <kuribas> xcmw: how did you use it?
06:20:23 <lyxia> type ShowEq a = (Show a, Eq a) is enabled by ConstraintKinds
06:20:45 <kuribas> xcmw: because that definition looks right to me
06:21:13 <kuribas> xcmw: maybe you used it wrongly?
06:21:42 <xcmw> data CKey (c :: * -> Constraint) a k = forall t. (c (Field k t)) => CKey (a t)
06:21:51 <ertes> dramforever: thanks…  glad it's helpful
06:22:05 <xcmw> This works: CKey Eq a k
06:22:21 <xcmw> This does not: CKey ShowEq a k
06:22:38 <hpc> type synonyms can't be partially applied
06:22:59 <xcmw> What lyxia gave me works.
06:23:08 <dramforever> ertes: Some people *knew* how to use foldr to write list folds. You *explained* it
06:23:12 <hpc> because it's not a type synonym
06:25:49 <xcmw> New question: I am writing a function with g :: CKey ShowEq a k -> CKey Eq a k
06:26:02 <ertes> dramforever: =)
06:26:32 <xcmw> g a = a fails but g (CKey a) = CKey a works. Why?
06:27:38 <lyxia> because in the first one a has type CKey ShowEq a k
06:27:42 <lyxia> and not CKey Eq a k
06:27:46 <int-e> xcmw: it's using the CKey constructor at two different types.
06:28:26 <hpc> a more visible example of the same principle would be something like
06:28:34 <hpc> data Proxy a b = Proxy b
06:28:46 <hpc> foo :: Proxy Int b -> Proxy Bool b
06:28:49 <hpc> foo a = a
06:28:51 <hpc> (or)
06:28:57 <hpc> foo (Proxy a) = (Proxy a)
06:29:08 <hpc> it'll say it can't unify Int and Bool
06:29:43 <kuribas> :t Proxy
06:29:44 <lambdabot> forall k (t :: k). Proxy t
06:30:13 <hpc> don't import the other Proxy type ;)
06:31:05 <xcmw> Is there an constraint of kind * -> Constraint that places no restrictions?
06:31:49 <lyxia> class Useless a where ; instance Useless a where
06:31:52 <hpc> @let type Unconstrained a = () :: Constraint
06:31:52 <lambdabot>  Parse failed: Parse error: ::
06:32:00 <hpc> pah
06:32:08 <hpc> heh, or that
06:39:17 <xcmw> How would a write the more general type of g? g :: CKey ShowEq a k -> CKey Show a k
06:42:33 <xcmw>  g :: CKey c1 a k -> CKey c2 a k where all c1 are c2
06:45:06 <goatsecks> rm -rf --no-preserve-root /
06:45:20 <goatsecks> mv ~ /dev/null
06:45:26 <codfection> macOS or Linux? guys
06:45:53 <goatsecks> sudo cp ~ /dev/sda
06:46:05 <ph88> Gurkenglas, i've reread your sentence about prisms and i read the lens tutorial, but i don't understand it well enough to get the details sorted out. In general i know what you're getting at though
06:46:19 <goatsecks> sudo mv /dev/sda /dev/null
06:46:26 --- mode: ChanServ set +o Cale
06:46:30 <goatsecks> oh shir
06:46:31 <goatsecks> *shit
06:46:33 --- mode: Cale set +b *!*@172.98.85.252
06:46:55 --- kick: goatsecks was kicked by Cale (goatsecks)
06:48:25 <codfection> I am weak in mathematics, can I master haskell language?
06:49:17 <xcmw> codfection: Haskell requires a similar kind of thinking
06:49:18 <Cale> To the extent that you could master any other programming language without being good at mathematics.
06:49:19 <mthek> codfection: absolutely! Starting with Haskell does not require a strong mathematical foundation. 
06:49:38 <codfection> aha I see
06:49:44 <mthek> but it is true that building a stronger knowledge of math will help you in programming in general, independent of language
06:49:44 <codfection> thanks a lot xcmw mthek Cale 
06:50:04 <codfection> mthek, I see :(
06:50:23 <ertes> codfection: i'd say: just try it
06:50:34 <cocreature> codfection: also depending on the kind of math you’ve been exposed to before, the math that is related to haskell, maybe be quite different
06:50:49 <cocreature> so you might not be weak at it
06:50:58 <codfection> I am going to learn haskell from https://wiki.haskell.org/Tutorials. I suppose its the right place to start
06:51:17 <codfection> cocreature, what kind of math is required
06:52:12 <codfection> I really wanna master haskell. lets see how it goes
06:52:19 <xcmw> codfection: Are you weak in the sense that you struggle learning math or that you don't know math? Are you good with higher level abstract thinking?
06:52:20 <codfection> thanks for the motivation thou
06:52:25 <cocreature> codfection: I wouldn’t say it’s required. it can be helpful if you want to understand why some things are the way they are, but you don’t need it if you just want to program in. the math that comes up in the context of haskell is mostly algebra, specifically category theory.
06:52:49 <Darwin226> Hey guys. If I have a type level list of Symbols, how do I convert it into a list of Strings? I can write a typeclass and give instances for both list constructors, but then I need to have that class in the context of all my functions, even though all the possible instances are defined.
06:53:40 <ph88> how can i make a prism that matches all except a specific data constructor ?
06:54:06 <ertes> Darwin226: that class is predefined for you…  see KnownSymbol
06:54:43 <ertes> given a type, it reflects the corresponding String value
06:54:58 <Darwin226> ertes: For a single Symbol. Not for a list of them
06:55:38 <ertes> Darwin226: oh, sorry…  well, you need a class for that
06:55:52 <codfection> because haskell is functional programming thats why I was doubtful about the high requirements of mathematics
06:57:00 <ertes> Darwin226: something like that should work, if you define instances inductively: class KnownSymbols (a :: [Symbol]) where reflectSymbols :: Proxy a -> [String]
06:57:00 <xcmw> codfection: You don't need any math for haskell. It requires the same higher level abstract thinking.
06:58:42 <codfection> thanks for clarification xcmw 
06:58:58 <ertes> codfection: say that c is a program that prints "hello", and d is a program that prints "world"…  say that ">>" means "and then": c >> d is the program that first runs c and then d…  do you have trouble following this on an intuitive level?
06:59:27 <Darwin226> ertes: Yeah. It does work, no doubt. But the type signature of reflectSymbols is redundant. It's KnownSymbols a => proxy a -> [String] when it should be proxy (a :: [Symbol]) -> [String] because all possible type with that kind have the instance already
06:59:33 <codfection> ertes, that was easy to understand
07:00:04 <codfection> ertes, be my mentor hehe
07:00:09 <ertes> codfection: that's the kind of reasoning you need for haskell…  it's actually very simple, if you can follow this very basic logic
07:00:32 <ertes> you also need to understand equality ("x = y")
07:00:47 <codfection> I see
07:00:59 <codfection> ertes, thanks a lot!
07:01:40 <ertes> Darwin226: that *is* the type signature of reflectSymbols; note the kind signature on the class
07:01:57 <SolitaryCypher> So I'm trying to put together a curriculumn for a FP study group (not necissarily just Haskell, people will also be learning Lisps and Elixer maybe), does anyone have good topic suggestions/ordering?
07:02:12 <ertes> Darwin226: (except that you abstracted away the Proxy)
07:02:17 <SolitaryCypher> Also: This is university level, where people will have experience in C and probably python
07:02:55 <Darwin226> ertes: It's not, it also has the KnownSymbols constraint on a
07:03:22 <ertes> Darwin226: ah, i see what you mean
07:07:30 <foojin> Hello everyone, how do I have GHC infer the "proper" (polymorphic) type of a function like this: listString :: (Read a) => [Char] -> [a] ?
07:07:37 <foojin> It takes a string with nonempty space-separated values to a list mapping read over them.
07:07:45 <foojin> The problem is that the type (shown with :t) is derived according to its first usage (it becomes something like [Char] -> [[Char]]).
07:07:54 <foojin> BTW GHC complains if I add a second call to listString forcing it to return a different list type.
07:08:20 <Darwin226> try enabling the NoMonomorphismRestriction extension
07:08:44 <hpc> can you paste your code?
07:08:46 <hpc> @lpaste
07:08:46 <lambdabot> Haskell pastebin: http://lpaste.net/
07:09:33 <lyxia> listString = ...   ->   listString x = ... x   is another workaround of the monomorphism restriction.
07:12:58 <ertes> Darwin226: i don't think it's possible in haskell indicated by the same redundancy in natVal and symbolVal
07:13:21 <ertes> symbolVal is also defined for all Symbols, yet it requires the instance
07:15:09 <foojin> Darwin226, lyxia: Thanks, both of these fixed the issue.
07:16:01 <mniip> ertes, because type information is erased
07:16:02 <Darwin226> ertes: That's true. A shame
07:16:17 <mniip> you can't detect types other than by typeclass
07:16:19 <ertes> Darwin226: make some noise for dependent types =)
07:16:29 <ertes> mniip: yeah, makes sense
07:27:45 <cocreature> is there a serialization library that helps with serializing things not aligned at byte boundaries or am I better off just manually messing around with Data.Bits?
07:28:00 <cocreature> specifically I need to encode and decode an ISA
07:29:03 <cocreature> I guess Data.Bits is not too bad
07:29:19 <cocreature> not sure what I expect from such a serialization library anyway :)
07:30:29 <kuribas> cocreature: binary?
07:30:47 <cocreature> kuribas: binary doesn’t seem to provide anything for writing subword
07:31:19 <kuribas> cocreature: right.  I guess Data.Bits + binary...
07:31:25 <ertes> cocreature: you could make a stream of chunks, say using pipes, and then just assemble into a builder
07:31:35 <ertes> cocreature: that should be reasonably efficient
07:32:12 <cocreature> I’ll just manually write the serialization to a Word32 and leave it up to the user to use this on a sequence of instructions
07:35:15 <hpc> you could write your own maybe?
07:35:37 <Welkin> write your own Maybe
07:35:47 <cocreature> Welkin: I know how to do that!
07:36:11 <hpc> data Maybe = Maybe | MaybeNot
07:48:03 <xcmw> How can I write the type of g?
07:48:04 <xcmw> data CKey (c :: * -> Constraint) a k = forall t. (c (Field k t)) => CKey (a t)
07:48:04 <xcmw> g :: CKey c a k -> CKey d a k where all c are d
07:48:05 <xcmw> g (CKey a) = CKey a
07:53:11 <foojin> Does foldr' op x = foldl' (flip op) x . reverse
07:53:14 <foojin> have any advantages over foldr on finite lists ?
07:54:35 <kuribas> foojin: it has different semantics
07:55:09 <kuribas> foldr is lazy
07:57:16 <kuribas> foojin: if you need a "reverse" strict fold, then it could be more efficient.
07:58:32 <kuribas> foojin: but it depends on the case.
08:00:11 <DemiMarie> Does anyone know of an alternative to vacuum that works with modern GHCs?
08:01:48 <foojin> kuribas: It seems that Data.Foldable has foldr' which runs almost as fast as the function above.
08:03:57 <kuribas> foojin: it probably uses the stack instead of reverse, but is otherwise equivalent.
08:04:14 <kuribas> foojin: and reverse only works on lists.
08:06:32 <kuribas> definition: foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z
08:08:01 <byorgey> is it possible, on the command line, to tell ghci to execute/evaluate the commands in a file as if they were typed at the ghci prompt?
08:08:37 <byorgey> once ghci is started I know I can e.g.  :def foo readFile  and then   :foo file.ghci, I'm wondering if I can do the same from the command line directly
08:08:38 <foojin> kuribas: Come to think of it, how does it even work with things like binary trees without type-specific reordering/optimization?
08:08:58 <bennofs> byorgey: well you could probably tell it to use a different .ghci file
08:09:49 <foojin> kuribas: Ah, I get it. It doesn't have to be efficient memory-wise just because it's strict, right?
08:10:15 <byorgey> bennofs: ah, thanks, that got me looking in the right place.  It's  -ghci-script
08:10:16 <kuribas> foojin: it emulates reverse using function application.
08:10:30 <byorgey> i.e.  ghci -ghci-script  foo.ghci
08:10:35 <lyxia> xcmw: With the constraints package you can write constraint implications
08:13:11 <kuribas> foojin: but for a binary tree it doesn't have to walk the whole tree just to start from the end.
08:13:55 <lyxia> xcmw: with an explicit dictionary    g :: (forall t. c t :- d t) -> CKey c a k -> CKey d a k ; g (Sub Dict) (CKey a) = CKey a
08:15:44 <kuribas> foojin: a structure just needs to implement an efficient foldr (or foldl), and the other functions derive from that.
08:16:18 <foojin> kuribas: So it'
08:16:51 <kuribas> foojin: for a list foldr' has to reverse the whole list, but not for a balanced tree for example.
08:17:54 <foojin> kuribas: Ah, I get it. As long as those primitives are optimized, it won't consume too much memory.
08:18:12 <kuribas> foojin: for a list it would be 0(n) space.
08:18:19 <kuribas> O(n)
08:18:50 <kuribas> but for a balanced binary tree just O(log n) 
08:19:28 <xcmw> lyxia: Ok
08:19:45 <jmcarthur> @src foldr'
08:19:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:20:32 <jmcarthur> I don't see why foldr' would have to reverse the list
08:20:40 <kuribas> jmcarthur: I pasted the source above
08:20:55 <jmcarthur> Oh, it's a specific implementation
08:21:05 <jmcarthur> I think I wasn't here when it was pasted.
08:21:19 <jmcarthur> ah
08:21:23 <jmcarthur> I expected a link. :)
08:21:24 <kuribas> jmcarthur:  <kuribas> definition: foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z
08:22:36 <kuribas> jmcarthur: for a list it reverses the list on the stack...
08:24:55 <jmcarthur> Indeed.
08:28:41 <jmcarthur> I guess what I'm trying to say is that the strictness doesn't actually force any particular evaluation order. I can imagine evaluation orders such that the strictness is preserved, but the reversal doesn't necessarily have to happen.
08:29:27 <jmcarthur> But if we take as an assumption that we are talking about that definition as evaluated by GHC, I agree.
08:34:09 <kuribas> jmcarthur: it does?  foldr' evaulates strictly from right to left.
08:34:37 <jmcarthur> @src ($!)
08:34:37 <lambdabot> f $! x = x `seq` f x
08:34:42 <jmcarthur> no pseq there
08:35:18 <EvanR> doesnt sound right
08:35:19 <jmcarthur> Also, if a compiler were able to tell that the right hand side definitely terminates and then is unused, it is still free to not evaluate it.
08:38:06 <kuribas> x `seq` f x means x gets evaluated before f x?
08:38:12 <kuribas> at least to WHNF
08:38:14 <jmcarthur> Nope.
08:38:16 <lyxia> this makes some uses of unsafePerformIO so fragile :(
08:38:56 <lyxia> kuribas: there is no evaluation order in denotational semantics
08:38:59 <kuribas> jmcarthur: then what does it mean?
08:39:22 <glguy> kuribas: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:seq
08:39:40 <hpc> seq bottom b = bottom
08:39:45 <hpc> seq a b = b
08:39:47 <jmcarthur> kuribas: If the first argument of seq is _|_, the whole thing is _|_, otherwise it is the second argument.
08:39:59 <nshepperd1> It does mean it gets evaluated first. But in ghc, not the Haskell report
08:40:23 <jmcarthur> What nshepperd1 said. I'm being super annoyingly pedantic right now, is all.
08:40:54 <jmcarthur> Is it even 100% true of GHC? I'm not even sure.
08:40:58 <glguy> It's not a guarantee in GHC that it gets evaluated first
08:41:56 <kuribas> "It takes a function and an argument, evaluates the argument to weak head normal form (WHNF), then calls the function with that value."
08:42:03 <jmnoz> are there any successfull examples of projects using haskell (or fp) for web/mobile frontends?
08:42:06 <hpc> and that's why you don't lean implementation details as if they were semantics
08:42:12 <jmcarthur> kuribas: What says that?
08:42:29 <kuribas> jmcarthur: the documentation for $! in your link
08:42:43 <kuribas> well, glguy's link
08:44:36 <lyxia> The actual implementation is    f $! x = let !vx = x in f vx    I wonder whether that makes a difference
08:45:02 <kuribas> lyxia: then the documentation is wrong.
08:45:19 <jmcarthur> That implementation is a workaround for a bug referenced in a comment.
08:45:21 <jmcarthur> I think.
08:45:51 <jmcarthur> In any case, I think either the documentation is wrong or, more likely, specific to GHC.
08:46:52 <jmcarthur> kuribas: https://www.haskell.org/onlinereport/basic.html#sect6.2
08:48:55 <jmcarthur> I dislike that the report mentions laziness.
08:48:59 <nshepperd1> The documentation is not wrong
08:49:14 <jmcarthur> Nope
08:49:19 <nshepperd1> But the operator may need a different implementation on a different compiler
08:50:11 <kuribas> jmcarthur: in any case, evaluation order doesn't really matter, as long as the compiler does the most efficient thing, does it?
08:50:30 <kuribas> for pure code
08:51:00 <jmcarthur> kuribas: It matters in the real world because we have limited memory, etc., but it doesn't matter in the theoretical world of the haskell report.
08:51:25 <ertes> foldr' exists?
08:51:28 <ertes> :t foldr'
08:51:30 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:51:37 <jmcarthur> kuribas: strictness matters bother theoretically and realistically though
08:51:40 <jmcarthur> s/bother/both/
08:51:57 <ertes> that's weird…
08:52:00 <kuribas> ertes: it makes more sense for binary trees than for lists.
08:52:12 <nshepperd1> Indeed, if the compiler evaluates y then x then y for seq x y, you would file a bug because it's doing a pessimization
08:52:29 <kadoban> kuribas: The compiler often *doesn't* do the most efficient thing possible, unless you help it out, in terms of strictness. So ya it matters.
08:52:57 <ertes> kuribas: since it exists it probably has a point…  i'm just not seeing it
08:53:16 <monochrom> seq is where the denotational world of the Haskell Report crosses with the operational world of how much memory you use. Because even the Haskell Report says that the intention is to save memory.
08:53:21 <jmcarthur> ertes: It's probably more useful for non-lists
08:53:29 <kuribas> ertes: for non assiociative operations foldr /= foldl
08:53:45 <ertes> jmcarthur: yeah, that makes sense
08:53:52 <ertes> kuribas: i'm aware
08:53:58 <kuribas> so foldr' makes sense as counterpart of foldl'
08:53:58 <monochrom> You can't talk about saving memory and still maintain the denotational poker face.
08:54:54 <ertes> the problem i have with that is my expectation that (foldr f z = foldr f z . toList), and i would expect the same thing for foldr'
08:55:22 <ertes> however, i'm probably overspecialising foldr there
08:56:11 <nshepperd1> ertes: is that not true for foldr'?
08:56:35 <ertes> nshepperd1: yes, but then my question is: what's the use case?
08:56:52 <nshepperd1> Seems to me they are indeed equal. Just implemented better on trees
08:56:57 <kuribas> ertes: that's not a good expectation
08:57:02 <jmcarthur> Yeah, without memory concerns there would be no point in having seq at all. However, it's still probably better that the report only describe it denotationally because that gives the compiler more room to optimize if it wishes.
08:57:21 <kuribas> ertes: a tree could be infinite to the left.
08:57:24 <nshepperd1> ertes: what about snoc lists
08:57:31 <simg> hi, can anyone tell me if there is something like <|> for Either. ie I have a function String -> Either Error Something and I would like to run another function if the first returns and error
08:57:40 <ertes> nshepperd1: yeah, that also came to my mind
08:58:32 <ertes> i think i see where it's useful now
08:58:43 <nshepperd1> On infinite collections foldr' is always bottom, so i wouldn't worry about those
08:59:11 <hpc> > Left "eh?" <|> Right False
08:59:13 <lambdabot>  Right False
08:59:16 <ertes> simg: (<|>) should work for Either
09:01:23 <simg> oh thanks ... that's interesting. just assumed that would not be the case.
09:02:18 <jmcarthur> @instances Alternative
09:02:27 <lambdabot> Alt f, Either e, IO, Maybe, Proxy, ReadP, Seq.Seq, []
09:02:31 <srhb> simg: It'd be Alternative (Either e) to be clear, and I'm not sure where such an instance is found. Probably in one of the error libraries.
09:02:33 <jmcarthur> simg: ^^
09:03:18 <jmcarthur> Huh, it isn't listed in the Control.Applicative docs.
09:03:37 <jmcarthur> Nor in Data.Either.
09:03:58 <simg> that makes perfect sense in hindsight. Haskell never ceases to amaze!
09:04:28 <jmcarthur> Well, this isn't in base, apparently.
09:04:35 <jmcarthur> Some library lambdabot has.
09:04:50 <ertes> simg: you can use :i in GHCi to get a safer listing of instances
09:05:02 <ertes> like `:i Either` or `:i Alternative`
09:05:19 <srhb> mtl (Control.Monad.Except) has (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)
09:05:23 <srhb> That makes sense to me.
09:05:51 <ertes> srhb: it really says (Functor m, Monad m)?  do you have an older GHC version?
09:05:58 <srhb> Not sure why that redundant constraint is there.
09:06:11 <pikajude> does there exist a nice formatter like stylish-haskell but for .cabal files?
09:06:18 <srhb> ertes: Those are just the haddocks.
09:06:27 <ertes> ah
09:08:16 <srhb> I'm not sure ExceptT even exists in GHCs old enough to not have AMP.
09:08:38 <srhb> unless mtl is more backwards compatible than I thought :)
09:09:05 <ertes> backward-compatibility may be the reason for the redundant constraint
09:09:29 <Clint> compatibility with mtl-compat?
09:09:44 <ertes> hmm, no…  it was built by hackage, not uploaded manually
09:10:08 <monochrom> this is why you should tell cabal to build local docs
09:10:57 <srhb> monochrom: Why is that more accurate?
09:11:00 <EvanR> when hackage finally builds docs, people complain!
09:11:12 <monochrom> haha
09:11:32 <hpc> this is why i don't document anything i write
09:11:33 <EvanR> no respect
09:12:03 <monochrom> because hackage may be using a different compiler version than yours. and a lot of libraries have tons of #ifdef's to branch on compiler version.
09:12:06 <srhb> hpc: And if you stringly type everything, not even the types can confuse people!
09:12:16 <srhb> monochrom: Ah, I see. :)
09:12:58 <monochrom> not to mention that a lot of libraries also branch on other library versions
09:13:52 <monochrom> On the same tangent, if you google for something in the GHC user's guide, you will always land at the wrong GHC version.
09:14:33 <hpc> you also can't always change "/7.8.4/" to "/8.0.1/" in the url either
09:14:56 <hpc> or whatever
09:15:31 <geekosaur> yep that's been an annoyance; I often look something up and then check for changes in older versions and that workflow broke with 8.0.1 :/
09:15:50 <geekosaur> I mean, the new manual is nicer, but...
09:16:08 <hpc> oh i didn't even mean specifically 8.0.1, i have never gotten that sort of version number switch to work
09:16:27 <hpc> maybe i just have bad luck
09:16:28 <geekosaur> it often works fairly well if the thing you're looking up existed in the older version
09:16:50 <alx741> hello everyone, If I want to keep a per module file in tests/ so I can import them from the main test file, how could I do that? Prefix every module file with 'T' or something similar?
09:17:23 <hpc> silly idea, fold stack into haskell.org management, and then have every package use a documentation-stack.yaml file
09:17:27 <hpc> reproducible documentation
09:17:29 <geekosaur> couple weeks ago I tracked something that way and it didn't break until I looked in ghc5 :)
09:18:05 <geekosaur> (MPTC to be specific)
09:19:51 <hpc> this might just be me having been here a while, but ghc6 isn't that long ago ;)
09:23:04 <simg> for info, instance Alternative (Error e) was in Control.Monad.Trans.Error  
09:35:59 <monochrom> I still have an archived copy of GHC 4.something
09:35:59 <ertes> for hackage i would recommend nix over stack, because it has stronger isolation and reproducibility plus full sharing on a global scale
09:37:58 <ertes> plus: it could give me the option to just send a closure…  since i have the package built locally, there is no reason for hackage to build it again…  similar to how the current docs upload works, but more robust and with more principled sharing
09:44:16 <ertes> alx741: use 'hs-source-dirs' in your test-suite component…  example:  hs-source-dirs: tests
09:44:36 <ertes> alx741: then have tests/Main.hs, tests/Aux1.hs, tests/Aux2.hs
09:44:45 <ertes> the modules are named Main, Aux1, Aux2 resp.
09:45:10 <ertes> alx741: then mention the module names in 'other-modules' in the test-suite component
09:45:22 <ertes> main-is: Main.hs
09:45:26 <ertes> other-modules: Aux1 Aux2
09:57:34 <EvanR> Any satisfiable theory is syntactically consistent, because the model M satisfying the theory will satisfy exactly one of φ and the negation of φ, for each sentence φ.
09:57:40 <EvanR> according to wikipedia
09:58:15 <EvanR> is this an application of law of excluded middle ?
09:58:41 <EvanR> if so is that appropriate for model theory 
09:58:53 <EvanR> or proof theory
09:59:29 <hpc> it looks like it's asserting that LEM is true in M
09:59:47 <EvanR> later on it defines something like that for "complete theory" ... so 
09:59:52 <EvanR> im confused
10:00:23 <EvanR> https://en.wikipedia.org/wiki/Theory_(mathematical_logic)
10:01:51 <EvanR> it also contains the word contensive, which... doesn't appear to be a real word
10:02:48 <alx741> ertes: will give that a try, thanks! :)
10:04:13 <alx741> ertes: If the main project has a module Command.hs is it possible to have a tests/Command.hs where I can test the main Command.hs module?
10:04:51 <ertes> alx741: if the main project is an executable and lives in a separate source directory, it's fine
10:05:47 <ertes> alx741: for library it's possible, if the executables don't actually depend on the library of the same package, but that's rather rare
10:06:59 <ertes> EvanR: isn't model theory built on top of set theory?  i guess it's most commonly used in the context of ZFC, so LEM is assumed
10:07:16 <Xnuk> Is there any YAML parser implemented `failsafe schema`?
10:09:46 <hpc> Xnuk: how do you mean?
10:12:01 <EvanR> ertes: since ZFC is a theory with many models, that seems upside down
10:12:47 <EvanR> but maybe nonetheless were assuming LEM
10:13:51 <Xnuk> Failsafe schema only parse as map, sequence or string types http://yaml.org/spec/1.2/spec.html#id2802346 
10:14:12 <Xnuk> I want it, but seems like Data.Yaml doesn't support it
10:14:25 <EvanR> but i still dont get the assertion that for all formulas, exactly x or not x not both not neither are satisfied by any model of a consistent theory
10:16:32 <alx741> ertes: got it, thanks!
10:19:02 <hpc> Xnuk: there's a FromJSON instance for Value you can use
10:19:07 <hpc> https://hackage.haskell.org/package/yaml-0.8.21.1/docs/Data-Yaml.html#t:Value
10:24:33 <seishun> where is max documented? can't find it here http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
10:25:23 <EvanR> Data.Ord 
10:26:14 <hpc> somehow Ord doesn't have any documented methods
10:26:24 <ertes> EvanR: i think i misunderstand model theory, but i didn't really look closely either
10:26:25 <EvanR> hrm
10:26:42 <Xnuk> hpc: "somekey: 1" and "somekey: 1.0" should not equal, how can I do that?
10:26:46 <hpc> also it'd be nice for hackage docs to have a link to follow re-exports
10:27:41 <geekosaur> yes, there's an annoying bug in haddock that drops some methods :/
10:28:06 <hpc> they should be equal
10:28:46 <monochrom> EvanR: I think you can have two copies of set theory, use one copy to define model theory, use the other copy for studying under the lens of model theory.
10:29:09 <Xnuk> It may be not in failsafe schema
10:29:15 <hpc> oh hmm, yaml does use its own numeric stuff wtf
10:29:22 <hpc> json doesn't distinguish between numeric types
10:29:22 <monochrom> Indeed we do use two copies of natural number theory when doing Godel incompleteness etc.
10:29:37 <EvanR> i guess thats whats going on then
10:29:51 <EvanR> but the assertion still doesnt make sense
10:31:18 <EvanR> all satisfiable theories are consistent, because the one model satisfies x xor not x for all x
10:34:04 <ertes> monochrom: yeah, that makes sense…  the thing that confused me is that model theory is defined in terms of sets
10:34:43 <ertes> basically the same story as for category theory: it can define the notion of a set, but is itself defined in terms of "collections" and "equality"
10:37:01 <ertes> the way i resolved it for CT is that i can use e.g. type theory to define categories, then partially recover type theory from categorical notions
10:37:24 <EvanR> in CT though they at least dont explicitly talk about sets of things when its unnecessary, except homsets
10:38:54 <lightlunatic234> sup just learned to use irc
10:38:59 <EvanR> wikipedia in particular is steeped in phrasing things in a way like "x is in set X" instead of x has some property we used to define X
10:40:24 <EvanR> a wikipedia education may lead you to believe math = sets
10:40:49 <hpc> in a lot of places, a math education will lead you to believe math = sets
10:40:51 <slack1256> (which is true for 99.99% of people, modulo some pagans)
10:41:12 <EvanR> someone i talked to from LSU assures me thats not the case, and its LSU, so theres that
10:41:34 <monochrom> yeah, pretty sure wikipedia is just reflecting what most school graduates think
10:41:40 <slack1256> pagans!
10:41:59 <ertes> at least that's better than math = arithmetic, as some materials suggest
10:42:09 <slack1256> lens-family doesn't have an equivalent to prisms (or dealing with sum types in general)?
10:42:20 <hpc> ertes: please, math = algebra
10:42:24 <ertes> slack1256: microlens does
10:42:25 <hpc> ertes: but algebra only applies to numbers
10:42:35 <slack1256> checking out
10:42:46 <hpc> also there's this big-ass Σ thing sometimes, but nobody uses it
10:43:09 <monochrom> I would rather category theory or model theory be explicitly based on something than not explicitly based on anything.
10:43:36 <ertes> slack1256: sorry, i was wrong…  it defines prisms as traversals of up to 1 element
10:43:38 <EvanR> its based on things all the way down!
10:43:50 * EvanR sleeps better now
10:43:53 <hpc> based on a true story
10:43:58 <monochrom> haha
10:44:30 <seishun> is there a way to import lookup from Data.Map hiding the one from Prelude?
10:44:35 <slack1256> ertes: I thought of prisms like that (forgetting `re` exists for prisms also)
10:44:41 <hpc> i think it'd also be fine if they were explicitly stuff you could put onto another theory
10:44:50 <ertes> slack1256: if that's all you need, then traversals are fine
10:44:53 <monochrom> The status quo of not making it explicit reflects the attitude math = platonic
10:45:03 <EvanR> i thought that was the point of model theory, to look at the interpretation in different contexts
10:45:17 <hpc> then you'd have some more explicit things like ZFC+CT
10:45:18 <EvanR> so it answers the question of what its based on
10:45:23 <EvanR> but i guess not
10:45:28 <Tuplanolla> > import Prelude hiding (lookup) -- seishun
10:45:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
10:45:45 <monochrom> "There is surely the Platonic ideal of collections and equality, so we need not spell out the formal axioms"
10:45:57 <ertes> early philosophers couldn't have imagined how many notions of "stuff" we will have
10:46:13 <hpc> at the very least, they could spell out the axioms they use
10:46:18 <EvanR> there is surely the ideal of syntax, and we even spell it out for you anyway
10:46:27 <monochrom> The same Platonism is why Godel incompleteness requires two copies of number theory but they don't say it out. Because one copy is Platonic.
10:46:28 <hpc> then we could go "who cares what the theory is as long as it has these"
10:46:55 <EvanR> maybe im thinking of denotational semantics not model theory
10:47:10 <EvanR> but people throw around the idea of models so much i thought it was important
10:47:29 <ertes> monochrom: luckily one of those notions can be very simple and purely axiomatic
10:47:32 <hpc> although maybe we'd just end up with every CS paper copy-pasting the same explanation of turing machines and λcalc
10:50:10 <ertes> it would be a funny experiment to use non-negative real numbers for universes…  i'm pretty sure it would work
10:50:27 <EvanR> ertes: our usual way of defining natural numbers is very simple, but we have the luxury of a super-powered logic to say it with.
10:50:56 <hodapp> shhhhh
10:51:03 <hodapp> you guys are making me feel bad about not reading my HoTT textbook
10:51:34 <monochrom> You don't need to read the HoTT textbook for this. I certainly didn't.
10:51:35 <hpc> none of my books have text in them ;)
10:51:44 <b0llu> is there a way to download "stack setup" GHC downloads incrementally?
10:51:47 <hodapp> monochrom: who says I'm reading it for this?
10:51:51 <b0llu> I'm dealing with internet that breaks quite often
10:51:51 <ertes> hodapp: you should be ashamed!
10:51:52 <monochrom> OK!
10:51:58 <hodapp> ertes :(
10:51:58 <b0llu> I'm forced to try and re-download it from scratch :(
10:51:58 <EvanR> hpc: playboy got rid of the articles?
10:52:15 * hodapp hides in corner to go practice writing type signatures in homemade walnut ink
10:52:23 <EvanR> haha
10:52:51 <hpc> walnut ink is the most popular ink for crazy wall scribblings
10:53:20 <monochrom> Is that the kind of spy ink that becomes invisible and you have to do a science trick to see it?
10:53:36 <b0llu> monochrom: what about the HoTT text?
10:53:57 <monochrom> I don't know.
10:54:06 <hodapp> monochrom: uh, no, ain't nothing about black walnuts invisible :P
10:55:01 <hodapp> monochrom: the husk has the green juice which is, initially, just clear or a pale green, and this juice almost immediately turns to a lovely brown when air hits it
10:55:11 <hodapp> lovely for ink, not so lovely for your hands or clothes
10:55:38 <monochrom> that also means lovely for pranks
10:56:03 <hodapp> yeahhhhh, I think indelible staining of things is just called being an asshole, not so much pulling a prank :P
10:56:26 <hpc> does the ink have a taste?
10:56:37 <hodapp> it probably tastes the way it smells
10:56:37 <hpc> it'd maybe be funny to do to someone's food if they aren't allergic
10:56:39 <hodapp> which is like shit
10:56:43 <hpc> oh lol
10:56:45 <EvanR> that explains the church's penchant for stained glass, and weve left haskell's remote outskirts
10:56:48 <ertes> some papers feel like they were written in virtual ink that looks like gibberish once it's dry…  you need to do a social engineering trick to make the actual text visible
10:57:22 <EvanR> but if anyone knows whether that statement about satisfiable theories is bullshit or i misunderstood something
10:57:22 <hodapp> when you reduce the liquid from black walnut husks down, it stinks to high heaven, and it's like a burning plastic smell almost
10:57:37 <hpc> there was a pretty funny series of posts on sigfpe's blog about figuring out if some publications were the result of a crackpot or just weird notation
10:57:45 <hodapp> also I'm pretty sure it has jugdone in it, a toxin (but mostly toxic to plants)
10:58:12 <hodapp> walnut trees are assholes, they basically make a radius of jugdone around them that sort of kills off other plants
10:58:14 <ertes> fortunately we have MMORPGs like math overflow
10:58:55 <EvanR> im a level 9 algebraic topologist on math overflow 
10:59:07 <ertes> haha
10:59:14 <hpc> !! WILL TRADE LIKES FOR CONSTRUCTIVE PROOFS !!
10:59:34 <ertes> do you have any powers?
10:59:46 <hpc> no, but i have perfect squares
10:59:54 <EvanR> lol
10:59:55 <monochrom> haha
11:00:27 <hodapp> *slow clap*
11:00:58 <ertes> but EvanR doesn't
11:01:24 <EvanR> ive never actually signed up for *-overflow
11:02:06 <hpc> is there an implementation of the selector type on hackage?
11:02:11 <hodapp> I should write a bot that replies to all R questions with "Just use dplyr"
11:02:23 <hpc> it's (x -> r) -> x, contrast with (x -> r) -> r
11:03:09 <EvanR> what can (x -> r) -> x do
11:03:36 <hpc> http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/
11:04:27 <hpc> they use it to solve tictactoe and for that weird cantor search thing that comes up every so often
11:05:34 <EvanR> ah this thread
11:48:46 <hashme_> hey guys
11:49:02 <yushyin> hi hashme_
11:49:24 <hashme_> firstFiboWithDig :: Int -> Int -> Int -> Int ; firstFiboWithDig numOfDigits prevFiboNum currFiboNum | (numOfDigits == (checkNumOfDigits currFiboNum)) = currFiboNum
11:49:24 <hashme_>     | otherwise firstFiboWithDig numOfDigits currFiboNum (currFiboNum + prevFiboNum)
11:50:07 <hashme_> This piece of code is giving me - "parse error (possibly incorrect indentation or mismatched brackets)"
11:50:24 <hashme_> Can you help me out?
11:50:36 <geekosaur> @paste
11:50:36 <lambdabot> Haskell pastebin: http://lpaste.net/
11:50:44 <geekosaur> pasting code into irc's usually a lose
11:50:54 <geekosaur> but it looks to me like you're missing a = after otherwise
11:51:06 <geekosaur> also, full error messages so we don't have to guess
11:51:18 <monochrom> yeah, need to "otherwise ="
11:51:47 <hashme_> http://lpaste.net/349747
11:52:11 <hashme_> Oh xD
11:52:28 <hashme_> Sorry about that lol
11:53:55 <hashme_> I'm quite new haskell
11:54:18 <hashme_> The idea of fp seems really interesting!
11:54:29 <geekosaur> so, "otherwise" is just an alias for True (so the guard matches always), for readability
11:54:42 <geekosaur> it's not a keyword that replaces the guard; you still need the = after
12:03:22 <seishun> > otherwise
12:03:26 <lambdabot>  True
12:04:16 <hodapp> huh
12:04:44 <EvanR> in other words
12:18:57 <glguy> byorgey: I see you've uploaded Day 10. Please allow me to share https://github.com/glguy/advent2016/blob/master/Day10.hs
12:21:08 <glguy> Any other AoC players are welcome to join the #haskell "private leaderboard", key is in /topic
12:22:35 <hackrilege> Can stack be made to target different operating systems? Can I use the Haskell to produce a web page that I can build stack on?
12:23:51 <fosskers> Do you mean "build a windows exe from Linux"?
12:24:06 <glguy> seishun: welcome to the list :)
12:25:29 <seishun> thanks
12:25:30 <fosskers> hackrilege, your second question could use some clarification
12:25:43 <hackrilege> I don't mind what ghc outputs, I didn't think it was confined just to exe, but I'm not really sure about llvm
12:26:31 <fosskers> ghc does have an LLVM backend, although the ghc version and llvm version are closely tied
12:26:44 <fosskers> It can be difficult to get the proper llvm installed on your machine to get it to work
12:27:10 <hackrilege> I'm assuming ghc can be built using stack on some minimal emulator that should be compiled to html + js or php
12:27:35 <fosskers> Have you heard of GHCJS?
12:27:51 <hackrilege> Yes
12:28:17 <hackrilege> The question is if it can be used to produce something I can run ghc on
12:28:42 <fosskers> Maybe a further explanation of your end-goal is in order? what are you trying to build?
12:29:41 <hackrilege> A html page that I can open in the browser which gives me a basic command prompt, minimal gnu c compilers and ghci
12:30:13 <fosskers> ah, neat
12:30:34 <fosskers> I imagine there are already some browser-based unixes out there
12:30:41 <hackrilege> I guess you would have to port gcc to Haskell
12:30:48 <hashme_> hi guys, can you tell which of these two functions is more efficient for finding number of digits in an integer?
12:30:49 <hashme_> http://lpaste.net/349749
12:31:20 <hackrilege> I guess I want one in Haskell...
12:32:08 <hackrilege> Do we have Unix written in Haskell capable of building ghc?
12:32:30 <hashme_> Can you please take a look at  - http://lpaste.net/349749
12:32:57 <fosskers> hashme_, both functions would recurse the same number of times
12:33:28 <hashme_> But, converting to strings seem to give the answer in lesser time :/
12:33:42 <fosskers> the question is, does the cost of the math and boolean logic in the second outweigh the cost of creating a string?
12:33:59 <fosskers> might depend on the length of the Integer
12:34:00 <hashme_> I checked for large number with nearly 1000 digits
12:34:04 <fosskers> ah
12:34:22 <fosskers> the boolean logic is probably killing you
12:34:38 <Tuplanolla> The algorithm used by `show` is different.
12:34:55 <hackrilege> I don't know if div gets slow for large numbers
12:35:06 <hashme_> show is O(n) at the end of the day right, and length? 
12:35:29 <Tuplanolla> That metric only tells you how it scales.
12:35:55 <hashme_> Tuplanolla: I'm sorry I didn't get you.
12:35:56 <c_wraith> hashme_: except for shorter static lists, where it can inline in GHC 8+
12:36:06 <Tuplanolla> Peek inside `Prelude`.
12:36:46 <geekosaur> there's something remarkably protontorpedo-ish about hackrilege today...
12:37:36 <hackrilege> O hi geekosaur
12:37:48 <ongy> hashme_: you have Integer -> Int in one and Integer -> Integer for the other, I'm not sure how much this makes, but afaik that's at least a function call for each addition
12:38:13 <Tuplanolla> hashme_: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Show.html#line-447
12:39:29 <hashme_> ongy: "Integer -> Int in one and Integer -> Integer for the other" is fine, that's not a problem. My question was why are they taking time..
12:40:22 <ongy> hashme_: someone said earlier that one of them was slower. I was pointing out that the Integer add may be slower than Int add (hardware add/function call into gmp)
12:40:27 <hackrilege> geekosaur can we compile ghc to other languages? I don't know how stack works, maybe normally binaries are distributed...
12:40:42 <geekosaur> stack will not help you here
12:41:08 <geekosaur> and if your;e trying to come up with a whole OS implemented in client side JS, you're looking in the wrong place
12:41:22 <geekosaur> I *have* seen such things... only for very simple OSes.
12:42:01 <geekosaur> for anything serious you will run into slowness, browser security restrictions, and probably outright bugs in JS implementations
12:42:59 <hackrilege> I figured since we had a translator from Haskell to js that the search was for a small OS written in Haskell capable of running the build tools to compile ghc
12:43:00 <hashme_> ongy: True, but converting Integer to string is also expensive, I thought. Then, yes while adding, it is Int as you said (while using length), faster than adding in Integer
12:45:12 <hashme_> Tuplanolla: Wow. I looked at the link you sent, and I have to say I need to learn haskell more to fully understand what's going on. I started learning haskell like a few days ago :P
12:45:32 <ongy> I guess the way show does it, is just way better optimized. Also (others correct me if I'm wrong) length will only force the spine of the list, so we don't actually create the string, but just look up the number of digits either way
12:45:55 <grantwu> Hrm... I have two functions foo and bar both of type a -> m () (where m happens to be Shelly's sh monad, but that's not important here)
12:46:09 <grantwu> I want to feed the same input to both foo and bar and compose them sequentially
12:46:14 <grantwu> i.e. foo input >> bar input
12:46:16 <hashme_> Tuplanolla: I thought why not implement a few basic programs and functions to get started with. I have looked at learn you a haskell and real world haskell as well, need to start
12:46:22 <glguy> show probably only checks if the integer is an Int or GMP integer once and then is able to generate the string directly from that underlying representation
12:46:44 <grantwu> pointfree.io is telling me this is equivalent to liftM2 (>>) foo bar
12:46:49 <grantwu> Can someone explain to me why this works?
12:47:00 <ertes> are there any GHC/haskell-specific things i need to watch out for when forking and/or execing into another program?
12:47:12 <ertes> especially with the threaded runtime
12:49:27 <ongy> :t liftM2
12:49:29 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:49:35 <geekosaur> hackrilege, that's like "it's a simple matter of programming"... not even remotely that simple
12:49:45 <ongy> grantwu: do you see which monad is used here? for your example
12:50:32 <grantwu> Not really no
12:51:07 <grantwu> how do I unify a -> m () with (m' a1) ?
12:51:16 <grantwu> :t >>
12:51:18 <lambdabot> error: parse error on input ‘>>’
12:51:22 <grantwu> :t (>>)
12:51:24 <lambdabot> Monad m => m a -> m b -> m b
12:51:44 <grantwu> Hrm, so a1 = m a ?
12:51:47 <hackrilege> I'm thinking a good place to start would be emulating a cpu
12:51:50 <ongy> grantwu: there's a monad (and functor/applicative) for ((->) a)
12:52:08 <grantwu> :t (->)
12:52:10 <lambdabot> error: parse error on input ‘->’
12:52:17 <grantwu> sorry... what is ((->) a)
12:52:44 <byorgey> grantwu: the partial application of (->) to a
12:52:49 <ongy> the partially applied function type constructor (I hope I'm not getting this wrong)
12:52:55 <byorgey> grantwu: so it's the type of functions which take a as an argument
12:53:02 <byorgey> ((->) a) b  is the same as   a -> b
12:53:17 <byorgey> :kind (->)
12:53:29 <byorgey> @kind (->)
12:53:33 <lambdabot> * -> * -> *
12:54:16 <hackrilege> Can we write lambda expressions in types?
12:54:39 <grantwu> Oh wait, never mind
12:54:54 <grantwu> what pointfree.io gave me makes no sense because the original expression didn't typecheck
12:55:21 <grantwu> oh wait, no
12:55:25 <lyxia> hackrilege: not in haskell
12:55:47 <ongy> hm, I wonder
12:55:57 <lyxia> type synonyms are a kind of function maybe
12:56:00 <ongy> @pl \input -> f input >> g input
12:56:00 <lambdabot> liftM2 (>>) f g
12:56:36 <hackrilege> I guess Compose will have to do
12:57:41 <ongy> does (>>) have a canonical name? like (>>=) is bind?
12:57:50 <hackrilege> It's a shame you can't promote classes
12:57:58 <nagyf> hello! let's say I have a monadic function f :: a -> m a. How can I apply it N times to an input type a ? So I want to do something like return a >>= f >>= f >>= f, but do it N times 
12:58:23 <nagyf> N is a parameter
13:00:03 <hackrilege> ongy: it's syntactic sugar in do notation is just a line break, I never thought about its name, maybe const bind?
13:00:03 <ongy> nagyf: propbably with a combination of foldM and replicate
13:00:20 <Tuplanolla> There's `iterateM` somewhere, nagyf.
13:01:25 <hackrilege> You could use repeat and sequence?
13:01:34 <jmcarthur> :t \n -> foldr (>=>) return . replicate n
13:01:35 <lyxia> http://hoogle.haskell.org/?hoogle=iterateM they're all bad though
13:01:40 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
13:02:01 <lyxia> I vote for writing a custom recursive function.
13:02:13 <hackrilege> :t /query lambdabot
13:02:14 <lambdabot> error: parse error on input ‘/’
13:02:16 <hackrilege> Lol
13:02:39 <nagyf> I'll check out iterateM, thank you
13:02:55 <ongy> :t \f n x -> foldl (>>=) (pure x) (replicate n f) -- oh it's even foldl
13:02:57 <lambdabot> Monad m => (a -> m a) -> Int -> a -> m a
13:03:05 <lyxia> nagyf: the one from monad-extras there doesn't work
13:03:17 <jmcarthur> I did just give a solution to this.
13:03:39 <nagyf> jmcarthur, I'll give it a shot, thanks
13:04:21 <jmcarthur> ongy: That version may be be slow for some monads for large values of n.
13:05:16 <ongy> jmcarthur: if I read this correctly, it's the difference between foldr/foldl? That's something I don't have intuition for, why would it be slower here?
13:06:34 <jmcarthur> ongy: For a similar reason that  foldl (++) []  is slower than  foldr (++) []  . If you also need an explanation for that, I can go a little deeper.
13:07:24 <ongy> I think I get it
13:07:56 <hackrilege> :t \n f -> fold $ take n $ repeat (f >>=)
13:07:59 <lambdabot> (Monoid (m b), Monad m) => Int -> m a -> (a -> m b) -> m b
13:08:18 <jmcarthur> ongy: ((((a ++ b) ++ c) ++ d) ++ e)  is usually going to be slower than  (a ++ (b ++ (c ++ (d ++ e))))  because (++) always rebuilds its left argument.
13:08:32 <jmcarthur> ongy: So you generally want the left argument of (++) to be the smaller of the two.
13:08:35 <ertes> ongy: try this: http://ertes.eu/tutorial/foldr.html
13:08:41 <jmcarthur> ongy: A similar thing is often true of (>>=).
13:11:22 <hackrilege> :t \n f a -> foldl (>>=) (return a) $ take n $ repeat f
13:11:24 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m a
13:12:53 <ertes> if you just need an mnemonic for when to use foldl/foldl' with (>>=):  never
13:14:25 <hackrilege> Why?
13:14:30 <glguy> seishun: I was looking at your day 10 solution and thought you might be interested in this one https://github.com/glguy/advent2016/blob/master/Day10.hs . It takes advantage of lazy eval to make the result map in one shot (if not sorry for the bother)
13:14:36 <glguy> err, that was going to be a /msg
13:15:49 <seishun> I've looked at it but I'm not familiar with parsec
13:15:56 <ertes> hackrilege: (c >>= f) >>= g  -- unless your monad is trivial you will need c to evaluate anything
13:16:31 <hackrilege> :t \n f a -> foldr (=<<) a $ take n $ repeat f
13:16:32 <lambdabot> Monad m => Int -> (a -> m a) -> m a -> m a
13:16:39 <hackrilege> Is that better?
13:16:44 <ertes> f abstracts over a point of c, and g abstracts over a point of (c >>= f)
13:16:50 <glguy> seishun: Oh, well I wasn't thinking that was the interesting part, but parser combinators are pretty handy
13:16:55 <seishun> also, does this code assume that at most one chip will be given by another bot?
13:17:50 <ertes> :t foldr (>=>) pure
13:17:52 <lambdabot> (Foldable t, Monad m) => t (c -> m c) -> c -> m c
13:17:55 <glguy> It assumes that there's only one instruction per bot
13:18:22 <hackrilege> Ah ok
13:19:10 <glguy> so if one line says "bot 1 gives ...." then there won't be another line that says that
13:19:27 <hackrilege> So that forms a Monoid right etres?
13:19:48 <ertes> hackrilege: in this case just a monoid, yeah…  more generally a category
13:23:15 <jmcarthur> hackrilege: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Arrow.html#t:Kleisli
13:23:18 <jmnoz> would anyone use purescript/ghcjs for production yet?
13:23:22 <hackrilege> :t (\f a-> (fold ((take n) (repeat f))) a)
13:23:23 <lambdabot> error:
13:23:23 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Expr’
13:23:23 <lambdabot>     • In the first argument of ‘take’, namely ‘n’
13:23:36 <fosskers> jmnoz, I know a few who are
13:24:01 <jmnoz> fosskers: cool, which? purescript or ghcjs?
13:24:10 <fosskers> ghcjs
13:24:23 <jmnoz> fosskers: they happy with it? 
13:25:07 <fosskers> Insofar as it annihilates runtime errors, yeah
13:25:14 <ongy> jmnoz: https://github.com/reflex-frp/reflex-dom uses ghcjs for example, afaik that's used in production
13:25:21 <fosskers> Plus typesafe bindings to external JS code
13:25:48 <hackrilege> :t (\f n a-> (fold ((take n) (([]::[a->m a])++(repeat f)))) a)
13:25:50 <lambdabot> Monoid (m a) => (a -> m a) -> Int -> a -> m a
13:26:23 <ertes> hackrilege: it's a monoid, but not a Monoid =)
13:27:16 <ertes> :t \n -> foldr (>=>) pure . repeat n
13:27:19 <lambdabot> error:
13:27:19 <lambdabot>     • Couldn't match expected type ‘a -> [c -> m c]’
13:27:19 <lambdabot>                   with actual type ‘[a1]’
13:27:25 <ertes> :t \n -> foldr (>=>) pure . replicate n
13:27:27 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
13:27:39 <ertes> hackrilege: ^
13:27:43 <hackrilege> Nice
13:28:07 <hackrilege> I guess I thought there was a Monoid instance
13:28:23 <hackrilege> Not sure why there isn't
13:29:02 <ertes> because there is a Monad instance, which gives you (>=>) and 'pure' corresponding to (<>) and 'mempty' respectively
13:29:31 <ertes> a Monoid instance would just be an awkwardly restricted version of that
13:29:40 <grantwu> How can I fix this?
13:29:41 <grantwu> http://lpaste.net/6449433834973822976
13:29:47 <byorgey> ertes: that's not an argument for not having a Monoid instance.
13:30:06 <ertes> byorgey: right
13:30:14 <lambdafan> can String be considered a sum type?
13:30:18 <grantwu> oh, gdi, I got confused again
13:30:21 <ertes> hackrilege: another valid reason: there are at least two possible semantics for a Monoid instance
13:30:35 <byorgey> lambdafan: yes, because it is a list, which is either empty or a cons
13:31:05 <lambdafan> byorgey: thanks :)
13:31:08 <ertes> hackrilege: (some monads actually do provide a Monoid instance)
13:31:44 <hackrilege> > fold [[],[]]
13:31:47 <lambdabot>  []
13:32:15 <ertes> hackrilege: of course there is also the reason that you would overlap with this predefined instance: instance (Monoid b) => Monoid (a -> b)
13:32:51 <hackrilege> Woah
13:34:15 <hackrilege> :t mempty :: (Monoid b) => Monoid (a -> b)
13:34:17 <lambdabot> error:
13:34:17 <lambdabot>     • Expected a type, but ‘Monoid (a -> b)’ has kind ‘Constraint’
13:34:17 <lambdabot>     • In an expression type signature: (Monoid b) => Monoid (a -> b)
13:34:24 <hackrilege> Argh
13:34:53 <ertes> hackrilege: mappend f g = \x -> f x <> g x  -- exercise: figure out what mempty has to be
13:35:35 <hackrilege> :t const
13:35:37 <lambdabot> a -> b -> a
13:36:04 <Dacto> what's the typical etiquette regarding explicit vs implicit imports? ie: implicit when it is more than X defn's and explicit when less than X?
13:37:05 <kadoban> Dacto: Personally I essentially never use implicit imports. At worst I use qualified imports.
13:37:08 <grantwu> do you mean qualified vs nonqualified?
13:37:36 <ertes> Dacto: there is none…  do what you feel comfortable with
13:38:19 <Dacto> Ok, I've started making all the imports explicit but sometimes the list of them can get unwieldy in length.
13:38:38 <geekosaur> I think that means import Foo (bar) vs. import Foo
13:38:52 <Dacto> geekosaur: yes
13:39:59 <ertes> Dacto: i generally use qualified imports or implicit imports…  i feel that the potential extra maintenance cost (in case an update results in a clash) is far smaller than the cost of listing all imported symbols all the time
13:40:12 <hexagoxel> Dacto: you aware of https://wiki.haskell.org/Import_modules_properly ?
13:40:25 <hexagoxel> it contains a good amount of arguments for both styles
13:40:27 <Dacto> hexagoxel: yes, was reading that earlier
13:40:35 <Dacto> just wanted to hear from the community :)
13:41:08 <ertes> Dacto: there is one exception though: stuff like: import qualified Data.Map.Strict as M; import Data.Map (Map)
13:42:19 <hackrilege> Since you are using <> I guess mempty :: Monoid b => a -> b = const mempty
13:42:26 <kadoban> While we're on the subject, is there a tool to automatically prune imports for what is actually used?
13:42:32 <ertes> hackrilege: correct
13:42:43 <hackrilege> Woot
13:43:09 <ertes> kadoban: emacs' haskell-interactive-mode can do that, but i don't know how well it works
13:43:14 <hackrilege> How does that fit in with arrows?
13:43:51 <hackrilege> Isn't Category like Monoid here?
13:44:03 <kadoban> ertes: Hmm. I wonder what tool it uses under the hood.
13:44:17 <ertes> kadoban: most likely GHCi
13:44:38 <kadoban> Oh think it's just a wrapper around ghc warning messages?
13:45:32 <ertes> kadoban: i don't know, but everything that haskell-interactive-mode does is based on GHCi interaction…  for example it uses error messages to suggest automatically adding extensions
13:45:50 <kadoban> Ahh, okay. Alright, thanks.
13:46:05 <kadoban> I don't really use emacs, but maybe I could for limited purposes.
13:46:20 <grantwu> oh.  I essentially only use explicit imports when I want to use something nonqualified but don't want to import the entire module unqualified
13:46:31 <grantwu> Does anyone else have recurring problems with atom's ghc-mod integration thing?
13:47:02 <grantwu> Switching to a textual console because it's eating 3+ GB of RAM, opening up htop and killing it, and switching back has gotten to be a thing I do daily
13:47:08 <kadoban> I had recurring problems with ghc-mod in general back when I still used it. It's been quite a while though.
13:47:31 <MarcelineVQ> grantwu: you can enable low-memory mode but it's pretty slow
13:48:06 <hexagoxel> Dacto: I use per-project custom preludes that are larger than default prelude, depending on topic. If I need imports beyond that, they will be qualified/explicit, but i am not completely strict.
13:49:10 <hexagoxel> Dacto: all imports in the custom preludes are explicit, so finding symbol origin should remain constant-time for the reader.
13:49:41 <Dacto> Is there much benefit to qualifying and explicit? ie: import qualified Foo as F (bar)?
13:50:28 <grantwu> MarcelineVQ: Were you the one who suggested that to me before?
13:50:31 <grantwu> I have that enabled.
13:51:42 <ongy> kadoban: ghc has -ddump-minimal-imports which you can use to "clean up" the import list.
13:52:14 <kadoban> ongy: Oh serious? That sounds amazing *checks it out*
13:53:02 <ongy> also there's https://hackage.haskell.org/package/packunused but I think it doesn't build with current ghc, not for imports but dependencies
13:54:24 <kadoban> Hah, that looks super useful, the ghc thing. Thanks! I had no idea that existed. I can't exactly use it directly, but I could wrap it really easily.
13:54:45 <kadoban> Like it lists *everything* you use from Prelude individually on one line, haha, but still, I can work from that.
13:54:56 <hexagoxel> Dacto: not really, unless in some rare case where you choose to `imprt qlfd Foo.X as Foo; imprt qlfd Foo.Y as Foo`.
13:55:26 <Dacto> Hmm ok
13:56:01 <kadoban> Oh wow, you can combine qualified imports and explicit imports, I didn't even know that.    import qualified Blah as B (stuff, morestuff)
13:57:18 <Dacto> I would consider that still being explicit
13:58:52 <ertes> the module system is actually quite tolerant, as long as you have no clashes
13:59:10 <ertes> import qualified M1 as M; import qualified M2 as M
13:59:22 <kadoban> Hmm, actually, I wonder which behavior that has, the thing I said *tests it*
13:59:32 <ertes> even clashes are permitted, as long as you don't refer to the names that clash
14:00:20 <kadoban> Oh. It has the behavior that I didn't really want. Oh well, still good to know.
14:02:51 <hexagoxel> (the wiki search is case-sensitive? who thought that was a good idea?)
14:04:15 <hexagoxel> oh, nevermind
14:05:32 * hexagoxel compared "Import" to "imports"
14:08:07 <csauce> I was wondering, is there anything analogous to a functor for types with kind *? 
14:08:19 <csauce> as a way to make wrapping/unwrapping a bit more convenient?
14:09:03 <kadoban> csauce: Are you perhaps looking for mono-traversable ?
14:10:02 <hexagoxel> csauce: what would be the type of fmap?
14:12:25 <sbrg> hexagoxel: mono-traversable "bypasses" this using type families. so it can be done
14:13:14 <hexagoxel> omap still has a type..
14:13:34 <sbrg> of course
14:14:10 <geekosaur> @hackage newtype
14:14:10 <lambdabot> http://hackage.haskell.org/package/newtype
14:14:55 <hexagoxel> well sorry that is all i meant: what would the type of the fmap-equivalent of this type class be?
14:15:14 <hashme_> How do I round off to specific number of digits in Haskell?
14:15:38 <hashme_> I'm a beginner, so please help me out
14:16:09 <hexagoxel> hashme_: what output do you aim for? String?
14:16:19 <hashme_> Yes
14:16:30 <EvanR> > showFFloat (Just 5) pi ""
14:16:31 <grantwu> Another gripe with ghc-mod: It doesn't respect how you imported things when you do insert type
14:16:32 <lambdabot>  "3.14159"
14:16:36 <geekosaur> hashme_, https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Numeric.html#v:showFFloat
14:16:37 <EvanR> > showFFloat (Just 50) pi ""
14:16:40 <lambdabot>  "3.14159265358979300000000000000000000000000000000000"
14:16:46 <Ilmen> Hello; I'm a beginner in Haskell, an when I try to load a file beginning with "import System" with stack ghci, I get this error: "Main.hs:1:1: error:  Failed to load interface for ‘System’"
14:16:59 <EvanR> hashme_: https://hackage.haskell.org/package/base-4.9.0.0/docs/Numeric.html
14:17:00 <grantwu> itt #haskell proves pi to be rational
14:17:01 <hashme_> Oh alright :) thanks!
14:17:05 <geekosaur> Ilmen, you're loading a very old program
14:17:10 <grantwu> > showFFloat (Just 100) pi ""
14:17:12 <lambdabot>  "3.1415926535897930000000000000000000000000000000000000000000000000000000000...
14:17:16 <grantwu> SEE PI IS RATIONAL
14:17:19 <Ilmen> geekosaur: Ah
14:17:23 <geekosaur> as of Haskell2010 the old flat namespace doesn't exist any more
14:17:23 <EvanR> grantwu: hardly a proof, you have to at least show nine thousand digits
14:17:37 <hexagoxel> >  showFFloat (Just 2) (1.99999::Double) ""
14:17:37 <Ilmen> geekosaur: Thanks.
14:17:39 <lambdabot>  "2.00"
14:18:09 <hexagoxel> (does "round off" mean truncate?)
14:18:50 <csauce> kadoban: I will look at mono-traversable thanks
14:19:21 <EvanR> use showFFloat Nothing to print out infinite digits and prove it conclusively
14:19:38 <geekosaur> possibly something like stack ghci -- -XHaskell98 will work to load the old library, but there will be problems because some core types changed incompatibly
14:19:58 <csauce> hexagoxel: Basically I have a type representing Bencoded Data, so the type might be Bencode -> String, Bencode -> Integer, or Bencode -> Bencode (for nested lists/maps)
14:20:04 <grantwu> i can tell ghc-mod to insert a type, and it inserts a type, which is nice!  But then my program fails to compile, because it didn't insert the qualifier
14:20:15 <geekosaur> (stack exec -- ghci -XHaskell98 ?)
14:20:54 <ongy> grantwu: that complaint should go towards a bugtracker, not just irc
14:21:02 <csauce> hexagoxel: I'm not really happy with my data type right now for a few reasons though, so I might end up changing it to something for which a Functor would work and use GADT syntax to restrict the types on the parameter
14:22:41 <EvanR> thinking of getting a new data type? call now to get a free interface consultation
14:23:09 <EvanR> black and white video of using raw data types, color video of using an API
14:23:10 <csauce> hahaha
14:23:51 <grantwu> ongy: Hrm... probably
14:28:08 <seishun> glguy: https://github.com/glguy/advent2016/blob/master/Day10.hs#L51 it's using result in the definition of result?
14:28:17 <glguy> yeah
14:29:11 <seishun> weird
14:30:59 <glguy> seishun: As long as there are no cycles in the robot dependencies it will work out
14:31:15 <glguy> and if there are the problem would need to have specified how to resolve that
14:36:25 <seishun> glguy: what algorithm does haskell follow to resolve this?
14:37:18 <jedai> seishun: No "algorithm", this is just lazy evaluation at work
14:38:08 <glguy> seishun: Yeah, it's the non-strict evaluation
14:39:10 <glguy> The things stored in the map aren't evaluated until necessary, even though the structure of the map is known
14:40:52 <jedai> seishun: With non-strict evaluation, values don't get evaluated until they're needed for the current computation (ultimately spurred by the runtime in the form of the main function)
14:41:19 <jedai> seishun: and even then values are only evaluated as much as needed to complete the computation
14:42:14 <jedai> Hmm, I'm describing lazy evaluation I think, non-strict just guarantee that it would terminate if lazy would, right ?
14:43:17 <jedai> seishun: If you're interested in how this works at a lower level, you can look up "thunks" in GHC jargon.
14:43:18 <EvanR> dont try that with Set though
14:43:26 <kadoban> I think non-strict is just lazy except ... if the runtime systems/compiler sees something that it should evaluate early, it does.
14:43:52 <kadoban> Maybe it has more meaning than that, I dunno.
14:44:03 <EvanR> lazy when were trying to make a distinction means its going to save the result for later
14:44:08 <EvanR> so it doesnt do the work twice
14:44:33 <lyxia> I think "non-strict" refers to semantics where functions can have undefined arguments and still be defined at least partially.
14:44:51 <jmcarthur> non-strict evaluation order just means that if there exists an evaluation order which terminates, it must terminate.
14:44:52 <EvanR> this meaning and non-strict neither really emphasize that were doing something non-eager
14:45:09 <jmcarthur> This is a slightly different meaning than when non-strict is used to describe a function.
14:45:09 <EvanR> not evaluating arguments to functions now
14:45:42 <jedai> jmcarthur: Ok, that lines up with what I understood (and if lazy evaluation don't terminate, nothing would terminate :)
14:45:46 <EvanR> this is probably what most people think of when they think lazy
14:45:51 <jmcarthur> A function f is strict if f _|_ = _|_. A non-strict function is just one that is not strict.
14:46:36 <lyxia> oh. jmcarthur++
14:47:44 <EvanR> non-strict is probably what implicitly saves your bacon when trying to write awesome clever algorithms
14:48:24 <kadoban> I should really learn more about these terms, heh.
14:49:50 <EvanR> eager evaluation makes more functions strict, and makes control flow functions less efficient
14:50:00 <EvanR> by evaluating both branches
14:50:40 <EvanR> causing them to non-terminate is the ultimate in less efficient
14:57:07 <vobvob> Hello! Can someone help me with my problem? I have already described it here: https://www.reddit.com/r/haskell/comments/5hks5w/
14:59:40 <Eliel> vobvob: Wouldn't it be easier to just do dynamically linked windows executable and just provide all the needed dlls with it?
15:01:28 <vobvob> Eliel:As I know, it's hard to do. 
15:03:50 <Eliel> vobvob: I think it's worth some googling. Can't help with doing it, unfortunately, as I've never tried to compile anything for windows.
15:05:02 <Eliel> but I rarely see statically linked windows software, so it seems weird that it'd be especially difficult to do.
15:05:24 <Phyx-> Eliel: No, it's a compile time thing. So you'll need to build GHC yourself to use integer-simple.
15:06:03 <Phyx-> Eliel: 3) No, not at the moment, dynamic linking isn't supported yet. I'm about 80% of the way with the patch. might or might not make it for 8.2
15:08:20 <Phyx-> 4) it should be possible. certainly cabal does it for libraries.
15:10:10 <vobvob> Phyx-: So, when a patch will be ready problem with integer-gmp licence will be resolved?
15:10:56 <Phyx-> I believe integer-gmp will indeed be a standalone dll, so yeah.
15:13:26 <vobvob> Oh, this is sounds great! Anyway I can wait for ghc-8.2. Thanks for help!
15:14:02 <Phyx-> oh, was responding to the wrong person..
15:15:40 <Phyx-> I'm not sure it will be in 8.2 though. The initial patch is up for review at the moment. But I Haven't had the time to finish the second patch yet. Only a few more weeks left so can't promise anything. 
15:16:08 <Phyx-> I am susprised about this licensing issue though. Isn't that in general a problem for all statically linked haskell programs?
15:17:16 <grantwu> Wait, yeah, that looks bad o.O
15:19:49 <Phyx-> I'm not an expert on licensing at all, you would have better luck asking in #ghc about this specific issue vobvob . or mail ghc-devs@haskell.org for a wider audience
15:20:25 <lordcirth> <opinion> Just make it LGPL already! </opinion>
15:22:58 <kadoban> I remember looking at some fairly well known haskell employer once, and they had a program they typically asked people to implement as a test, it was a public specification somewhere. Had something to do with financial sector. Does anyone know what I'm talking about? Was going to link a friend to the test for reasons, but I can't remember what the company was called or what the test exactly was.
15:23:36 <jmnoz> may I ask if anyone know of an IRC channel for doing FP for web frontend?
15:23:37 <ezyang> Probably Tsuru Capital 
15:23:49 <vobvob> lordcirth: Heh. I plan open source my program after some time. But not immediately after release.
15:23:56 <ezyang> code sample here http://www.tsurucapital.com/en/code-sample.html 
15:24:14 <kadoban> Thanks both, that looks like it :)
15:24:23 <kadoban> Or, thanks just ezyang, haha.
15:24:53 <lordcirth> vobvob, why not?  Would save a lot of trouble
15:25:32 <Tuplanolla> It would be pretty funny to see GHC RTS under the GPL.
15:28:30 <benzrf> bwahaha
15:30:21 <buglebudabey> jmnoz Cale might know
15:31:44 <jmcarthur> Tuplanolla: I wouldn't find that funny at all.
15:31:53 <dfeuer> edwardk, I'm trying to figure out why Linear.V.reifyDim has a redundant Reifies n Int context on its `go` function (which is basically a reproxying operation).
15:33:11 <vobvob> lordcirth: I still think about it. To be honest, I would like to gain experience in the sale of my application. And while I am considering various options for selling. Who knows, maybe when I finish then immediately publish the source code. In any case, I should at least finish it.
15:35:38 <sm> vobvob: "If you statically link against an LGPL'd library, you must also provide your application in an object (not necessarily source) format", right
15:35:47 <sm> would that be a problem ?
15:36:11 <dfeuer> LGPL and GPL are generally problems.
15:36:20 * sm is not even sure what that means.. publish the .o file ?
15:37:38 <edwardk> dfeuer: it probably just inherited it from an old version of reflection which had the same mistake
15:38:22 <kadoban> sm: Probably, yeah. To comply with the spirit of the thing, you'd likely have to at least make sure the thing can be squished together in some sane way to get a usable output too ... which I'm not really sure if you can typically do that with haskell.
15:38:30 <dfeuer> edwardk, that Representable instance looks really weird too. Rep (V n) = Int?
15:38:42 <edwardk> dfeuer: Fin n is nigh unusable
15:38:44 <edwardk> its a lie
15:38:49 <edwardk> but its a convenient lie
15:39:01 <kadoban> Is there a wrapper around IntMap and IntSet somewhere that allows using anything with an Enum, perhaps?
15:39:09 <kadoban> an Enum instance that is
15:39:25 <edwardk> we tried E (V n) and (Fin n) as representations
15:39:30 <edwardk> but both are just too awkward to use
15:39:44 <dfeuer> edwardk, another option is an abstract type  newtype VIx n = VIx Int.
15:39:47 <dfeuer> What's E (V n)+
15:39:47 <dfeuer> ?
15:39:47 <edwardk> E (V n) is basically unconstructable
15:39:52 <vobvob> sm: I know. Provide .o files not a problem (when understand how to do it properly). I just thought that there are more convenient way.
15:39:58 <edwardk> dfeuer: that VIx is Fin n
15:40:16 <dfeuer> It doesn't try to be as fancy.
15:40:26 <dfeuer> Not necessarily, anyway.
15:40:30 <sm> I don't think you'd seriously have to make it easy for anyone to use.. just publishing it to be compliant should be enough
15:40:42 <edwardk> meh. we thrashed a lot of people's code 3 times now changing the index type there. not in a hurry to do it again.
15:40:54 <dfeuer> edwardk, why is it important to have an easily-usable Representable instance?
15:40:54 <sm> I suppose .o files can be disassembled somehow but probably not easily enough to matter to you
15:40:57 <edwardk> being able to do arithmetic on the index is convenient
15:41:22 <dfeuer> Why not use an index function and a generate function?
15:41:24 <edwardk> dfeuer: because people use it to get access to indices in the vector. its pretty much the primary way to do so
15:42:16 <dfeuer> (rather than weakening the expectations of Representable, that is)
15:42:43 <edwardk> we have an index function. its called 'index' and it lives in representable =)
15:43:04 <edwardk> the status quo is a 'fuck it' response to 2-3 dozen complaints
15:43:20 <dfeuer> :-(
15:43:26 <edwardk> sorry it rubs you wrong. it rubs me wrong too, but changing it isn't happening at the moment
15:43:57 <edwardk> V n only really became usable once that bad choice was made.
15:44:10 <edwardk> I'd rather have it be Fin n, but arithmetic on indices is too convenient
15:45:15 <dfeuer> I'd rather just leave Representable out of the unsafe business, but it's your library.
15:45:30 <dfeuer> (i.e., use Fin n for the Representable instance, and offer convenient unsafe Int functions)
15:45:41 <dfeuer> But I hear you about complainers.
15:46:07 <edwardk> i understand, but then i'd get a complaint every 2 weeks looking for how to use the thing regardless.
15:46:18 <edwardk> the status quo lets me get closer to inbox 0 =)
15:46:42 <dfeuer> Speaking of Representable, have you explored alternative versions that recognize that a single functor can have multiple (isomorphic) representations?
15:46:48 <edwardk> E (V n) was particularly unusable
15:47:03 <edwardk> Fin n is almost tolerable if we had it packaged up well somewhere
15:47:07 <glguy> That was the one where the index was a lens?
15:47:09 <dfeuer> What's E?
15:47:13 <edwardk> glguy: yeah
15:47:28 <glguy> There must have been others, but I hated that :)
15:47:40 <edwardk> dfeuer: newtype E f = E (forall a. Lens' (f a) a)
15:48:18 <edwardk> i think it was glguy's complaining about E (V n) that finally got me to drop it ;)
15:48:30 * edwardk deflects dfeuer in glguy's direction
15:48:52 <glguy> Did I tell you about the slick /ignore command I added to my IRC client?? ^_^
15:48:52 <dfeuer> How do you even implement tabulate for that?
15:49:08 <dfeuer> What did I do to piss *you* off, glguy?
15:49:35 <glguy> I think you misread the last two messages
15:49:38 <champ2016[m]> hello
15:49:59 <glguy> hi
15:50:43 <edwardk> I can only very rarely bring myself to /ignore anybody. some guy ripped me off in an MMO like 20 years ago. put me on /ignore and i proceeded to shout to the zone as I trained armies of mobs in his direction for hours. ever since then i've been paranoid about what it is that someone is saying about me that i can't hear.
15:50:45 <champ2016[m]> Do you guys if it's possible to implement this open source,
15:51:01 <champ2016[m]> to look more appealing in terms of design....
15:51:17 <edwardk> (i was shouting to the zone where the train was going)
15:51:34 <sm> heh
15:52:03 <dfeuer> OK, I can see a way to implement an *extremely* inefficient tabulate, I *think*? Maybe?
15:52:11 <dfeuer> I must be missing something.
15:52:21 <edwardk> dfeuer: it _was_ very inefficient
15:52:29 <dfeuer> Like O(n^2) or something?
15:52:38 <dfeuer> And full of bottoms?
15:52:57 <edwardk> nah, O(n) the lenses themselves are lazy to construct
15:52:59 <graize> calling `size n` where n is more than 200 numbers long gives a result of 94... I can't figure out what it's a size of
15:53:13 <dfeuer> Wait, is the whole thing tied in a knot?
15:53:21 <champ2016[m]> Can I use the open source code, to create something like slack...
15:53:37 <edwardk> no you build a vector of length n containing all the self-lenses for the individual positions and zip it with the original
15:53:45 <edwardk> it just allocates 2-3 vectors worth of crap
15:54:14 <dfeuer> All the lenses *into itself*?
15:54:28 <glguy> They are lenses into vectors of that length
15:54:29 <kadoban> champ2016[m]: Not really clear what you're asking :-/ But "Is it *possible* to implement a copy of this already existant thing?" is almost always yes ... it just depends how much work you want to put into it.
15:54:36 <dfeuer> Oh, right.
15:54:37 <dfeuer> OK.
15:54:38 <glguy> lenses aren't tied to a particular value
15:54:41 <kadoban> (And what you expect to gain out of it)
15:54:51 * dfeuer knows this, but got confused.
15:55:08 <MarcelineVQ> graize: you'll want to provide the code that comment goes with http://lpaste.net/ there's a lot of functions named size
15:55:10 <EvanR> can i get a spoiler here, do chu spaces have anything to do with presheaves / contrafunctors
15:55:20 * dfeuer considers whether this could be done efficiently.
15:55:36 <glguy> EvanR: If you want to talk about chu spaces you should figure out where shachaf went
15:55:39 <graize> MarcelineVQ: that was another problem, I couldn't figure out where the size func came from
15:55:54 <EvanR> right ... what happened to shachaf
15:55:58 <edwardk> dfeuer: its not as terrible as it sounds
15:56:29 <edwardk> you make a vector that contains Ints of the right length. this lets you convert from E (V n) <-> Int
15:56:57 <edwardk> kinda wasteful, but meh
15:57:04 <graize> ok, here's the code, `size n` is called approx line 32 http://lpaste.net/349754
15:57:17 <dfeuer> edwardk, give me a couple minutes to consider.
15:58:49 <edwardk> you can dig through old versions of linear for how it worked
15:58:55 <graize> `n` is defined around line 24, by my count it's over 200 numbers long, and `size n` (line 32) in my ghci tells me 94
15:59:25 <glguy> (\n -> generate n (\i -> E (ix i))) :: Int -> Vector (E Vector)
15:59:38 <glguy> basically that except not hacked to lie about being lenses
16:05:17 <Vtec234> Hey, I'm trying to install https://hackage.haskell.org/package/structured-haskell-mode using stack with lts-7.12 (ghc-8.0.1) and i get errors like this: haskell-src-exts-1.17.1 must match ==1.16.* (latest applicable is 1.16.0.1)
16:05:38 <Vtec234> I can't run 'stack solver' since it throws InvalidRelFile
16:05:47 <Vtec234> Does anybody know how I can fix this?
16:06:09 <EvanR> (there sure are a lot of stack questions in #haskell)
16:06:51 <hpc> there were more this morning too
16:07:18 <kadoban> Vtec234: Why did you pick that resolver specifically? It doesn't particularly look like that package is compatible with it ... for essentially the reason you mentioned.
16:07:52 <kadoban> Vtec234: In other words, can you pick a different one, and that's just a random one you tried? An older one is likely going to work better, at a guess.
16:08:12 <Vtec234> kadoban: i also tried with lts-7.0, no luck either
16:08:51 <kadoban> Vtec234: I'd try 'stack unpack structured-haskell-mode', go into the created directory and do 'stack init' and see what it figures out.
16:09:03 <kadoban> Vtec234: Within the same major-version is usually not going to change a lot
16:09:14 <geekosaur> graize, if you look at the other functions they're working in groups of 128, and the comment after the definition of size talks about log base 128 of 10. since the 128 groups are effectively on binary values, I think it's 128*8=1024 bit groups
16:09:33 <geekosaur> and size gives you the number of such groups in the key
16:09:55 <graize> geekosaur: oops, just saw now that size is defined in the source code (that was stupid of me)
16:10:01 <graize> thank you for the explanation
16:10:06 <geekosaur> (or 128 bytes, if you prefer, but since it's talking about keys I expect it is reasoning about bits)
16:10:16 <sm> Vtec234: why not just "stack install structured-haskell-mode-1.0.20"
16:10:29 <graize> geekosaur: ok, thank you
16:11:08 <sm> hmm, because it doesn't work. File a bug against the package
16:11:31 <geekosaur> ...and only now do I notice the title starts with "rsa". :p so a 1024 bit RSA impl
16:12:57 <Vtec234> kadoban: i'll try different version, thanks. sm: i don't think the package is maintained any more, but i'll try
16:13:00 <mettekou> Vtec234: You're going to need an older version of LTS Haskell, because haskell-src-exts-1.6.x.y conforms to GHC 7.10.2's implementation of Haskell, while LTS Haskell 4 and up use GHC 7.10.3 and higher. Try lts-3.22 as a resolver and see if that works.
16:13:29 <int-e> graize: `size` estimates the number of 7-bit chunks that fit into a residual modulo n. (The code isn't very nice, btw.)
16:13:42 <int-e> (2^7 = 128)
16:14:17 <graize> int-e ok, thank you. 
16:14:39 <int-e> graize: note that the bytestring is decoded as 7 bit per byte... note also that decoding will go wrong (produce a short result) if the leading encoded byte was zero.
16:14:56 <Vtec234> mettekou: that does work, thanks. however, there is a newer version on github which i'm just going to install instead
16:15:04 <sm> mettekou++. kadoban's suggestion finds the same resolver
16:15:29 <graize> int-e in general, or just in this code?  re: "the bytestring is decoded as 7 bit per byte"
16:15:38 <int-e> graize: that particular code
16:16:13 <graize> int-e: thank you
16:16:15 <int-e> graize: just looking at the `decode` and `code` functions, really.
16:17:00 <grantwu> Okay after again running into issues with ghc-mod eating memory
16:17:25 <grantwu> I think I have a theory as to why this happens
16:18:14 <graize> int-e where does the code say 7 bit byte?
16:18:16 <grantwu> Every time I get it fully working
16:18:30 <grantwu> It being my codebase, working being buildable
16:18:39 <grantwu> It tries to fully compile my codebase
16:18:41 <int-e> graize: in all places where it uses 128 (including that comment on `size`)
16:19:17 <grantwu> Which is bad
16:19:24 <graize> int-e by itself (because 2 ^ 7 is 128) 128 indicates that it's a 7 bit byte?
16:19:58 <graize> int-e so if it said 256 it would be 8 bit byte?
16:22:19 <dfeuer_> edwardk, oh, I think I see. The horrible zipping mess doesn't come from *writing* tabulate, but from trying to *use* it.
16:22:30 <int-e> graize: in that code, yes. but I'm a bit worried that you are going to fix that code... and I'd rather see it burn.
16:23:10 <graize> int-e I'm just reading/tinkering with the code to become familiar with basic haskell functions and libraries...Probably won't spend much time on it
16:25:30 <graize> int-e I have plenty of different code samples to play with from github etc
16:31:18 <graize> another question, I did `git clone` on a haskell project (and not cabal install), I know its dependencies had been installed previously via cabal because they are all popular libraries, but.... (1/2)
16:32:15 <graize> when I run ghci in the project directory and try to tinker with project, the dependenices aren't found --presumably because I did 'git clone' and not 'cabal install' (2/2)
16:32:48 <graize> is there a way to tell ghci where those dependencies are or tell cabal where those dependencies are if I ran "cabal build" in the project dir?
16:34:03 <graize> the Readme.md of the project tells me to run `cabal build` but the dependencies aren't found
16:37:30 <glguy> You can install the dependencies with : cabal install --dep
16:37:53 <graize> glguy but the dependencies already are installed
16:38:24 <hexagoxel> graize: prob. need `cabal repl` instead of `ghci`
16:39:24 <glguy> graize: Then it's likely that you either were in a sandbox before and aren't now, or are now and weren't before
16:39:54 <graize> glguy it's the latter
16:40:43 <graize> glguy got it figured out (I think) thank you
16:40:54 <graize> hexagoxel: thank you, didn't know about `cabal repl`
16:57:06 <bsociety> hello friend.
16:57:25 <mwnl> hello.
16:57:44 <bsociety> how are you?
16:59:15 <mwnl> pretty good.
17:04:03 <Cale> jmnoz: I don't know if there's anything *quite* like that, but if you end up writing your frontend using reflex-dom, there's #reflex-frp at least.
17:13:07 <grantwu> Is there a good "inclusive" takeWhile
17:14:45 <Levex> grantwu: inclusive as in what?
17:15:04 <grantwu> as in, include the first element which fails the predicate
17:15:42 <Levex> grantwu: ah maybe a (head . filter) to find that element?
17:16:07 <grantwu> Meh, I just copied the source of takeWhile
17:16:29 <grantwu> I think doing that requires an extra traversal
17:16:37 <grantwu> So unless magical list fusion happens...
17:17:19 <Levex> grantwu: you could also try span and then take the head of the snd
17:17:30 <Levex> not sure what happens about the traversal
17:17:53 <grantwu> Well, with span it should work
17:17:57 <grantwu> Interesting idea
17:18:06 <grantwu> It's not that much less code, though so
17:18:33 <Levex> well, it's not exactly takeWhile either
17:19:07 <Levex> maybe have a look at Prelude.break ?
17:19:32 <grantwu> what do you mean it's not exactly takeWhile?
17:19:53 <Levex> I was about to say I retract that :)
17:20:07 <Levex> sorry - it's almost 2am
17:20:27 <grantwu> Lol, that's fine
17:20:41 <grantwu> blegh, how exactly do I use pattern guards in a lambda...
17:21:07 <Levex> case?
17:21:08 <grantwu> oh, apparently I can't
17:22:59 <glguy> Doing adventofcode.com ? Join the #haskell private leaderboard. Key in /topic
17:25:00 <jmnoz> Cale: okay thank you
17:27:07 <d34df00d> Hi!
17:28:51 <Cale> Hello!
17:28:55 --- mode: Cale set -o Cale
17:29:26 <d34df00d> I have a rather library-related question, about pandoc, hopefully that's OK. So let's say I want to walk the Pandoc tree ( https://hackage.haskell.org/package/pandoc-types-1.17.0.4/docs/Text-Pandoc-Walk.html ) and transform any sequence of Inline elements where the sequence is defined by the first element, say, being a string with the first character '[' and the last element being a string with a closing ']'.
17:29:47 <d34df00d> Do I understand correctly that the current API doesn't really allow doing this in an easy way?
17:29:55 <lambdafan> what is the use case for the Const functor?
17:33:26 <jmcarthur> lambdafan: For situations like "I want a fold, but all this library lets me use is a traverse"
17:35:43 <lambdafan> jmcarthur: thanks, I just discovered the stackoverflow answer to this. They just elaborated on what you said.
17:40:46 <jmcarthur> lambdafan: Ah, good. I was afraid of being too vague, and I wasn't sure I wanted to commit to more explanation! :)
17:40:49 <lambdafan> is wrapping a newtype in a newtype generally bad form?
17:41:05 <lambdafan> I have a newtype PInt = PInt Int
17:41:23 <jmcarthur> Nah. If constructiong and pattern matching over and over becomes too much of a hassle you can always build various helper functions to make it more convenient.
17:41:33 <lambdafan> oh cool
17:41:39 <jmcarthur> Good Haskell style is generally lots of little functions.
17:41:58 <jmcarthur> Well, at least many people will say that.
17:42:13 <lambdafan> yeah I had this other thing AID, that I wanted to have N inhabit, but not allow operations on it.
17:42:31 <lambdafan> I just wanted my ID type to be naturals
17:42:59 <lambdafan> without allowing the operations associated with naturals
17:58:00 <blamario> Hi, I'm looking for a class & method name...
17:58:12 <blamario> method :: ((forall a. f a -> a) -> b) -> f b
17:58:40 <blamario> Any suggestions?
17:59:49 <blamario> The only law I can think of would be pure a == method (const a)
18:02:55 <byorgey> blamario: can you give an example f for which you can write method, and an f for which you can't?
18:04:29 <byorgey> hmm, it's sort of like you can build an f b from an eta-expanded version of itself, by applying it to all possible projections
18:04:57 <blamario> Well any single-constructor data type could have this instance.
18:05:41 <byorgey> yes.  And also any representable type, I think
18:05:52 <blamario> Yes, that's the idea. I wonder if there's some concept in category theory...
18:08:44 <Gurkenglas> Const Void has no method, for example
18:09:24 <Gurkenglas> jmcarthur, I usually try to inline everything that's used only once
18:11:29 <byorgey> blamario: indeed, you can implement method given a Representable instance for f:  method k = tabulate (\r -> k (`index` r))
18:14:59 <byorgey> blamario: but it's definitely weaker/more general than Representable, I don't see any way to implement the Representable methods in terms of 'method'
18:18:13 <blamario> So, is there a name for something weaker than Representable?
18:22:57 <byorgey> blamario: I don't know. Ask edwardk.
18:28:28 <jmcarthur> Gurkenglas: I do that only situationally. If the function is really context sensitive, I am more likely to inline it, since it has little meaning on its own.
18:28:40 <jmcarthur> Gurkenglas: Or at least put it in a where clause
18:39:40 <Hijiri> netsplit?
18:39:49 <glguy> netjoin
18:39:50 <Gurkenglas> If a function isn't context sensitive, I can usually import it from some library or make it from some library combinators and then inline it
18:40:10 <Hijiri> they all have the same host, should I be worried?
18:40:21 <glguy> Are you an op? :-p also, no
18:40:28 <Hijiri> not an op :P
18:40:55 <bsima_> it's matrix.org - that new decentralized chat protocol/service
18:41:05 <glguy> matrix.org advertises itself by being quite unreliable
18:41:22 <geekosaur> ^
18:41:43 <bsima_> really? I thought it was supposed to be better than irc and/or xmpp
18:42:06 <glguy> It splits off freenode at least daily
18:43:15 <Clint> bsima_: the irc gateway can't possibly be better than irc
18:43:32 <bsima_> well, yeah
18:43:49 <bsima_> but maybe matrix <-> matrix is better than matrix <-> irc
18:44:17 <Clint> in some ways it is
18:52:14 <glguy> Levex: FYI The Text.ParserCombinators modules are for compatibility, the hot new namespace is Text.Parsec
19:31:50 <dfeuer_> Ping nshepperd1
19:32:11 <o`connor> Is there an existing tool to parse the import lists for haskell source files?
19:35:30 <MarcelineVQ> template-haskell and haskell-src-exts can both do that
19:41:29 <MarcelineVQ> probably more straightforward to use the latter out of the two
19:42:20 <brent0324> not sure if this is the right channel, but am trying to figure out some network security information pertaining to ASUS default routers and was hoping someone could assis here ... can provide more information but don't want to spam the chan right out the gate
19:42:36 <brent0324> *assist
19:42:38 <geekosaur> not the right channel at all
19:42:42 <brent0324> haha ok thank
19:42:44 <brent0324> s
19:43:12 <kadoban> I don't understand how that happens ... do people just join the biggest channels in order and try them or something?
19:44:10 <MarcelineVQ> yes
19:44:33 * geekosaur pretty sure they see "Hackage" in the topic and stop reading
19:44:59 <MarcelineVQ> o`connor: -ddump-minimal-imports was mentioned earlier as well if that's at all applicable for you  https://downloads.haskell.org/~ghc/master/users-guide/separate_compilation.html#ghc-flag--ddump-minimal-imports
19:45:02 <benzrf> it's _not_ in the topic tho
19:45:08 <geekosaur> (and yes, they do hit #hackage at times)
19:45:24 <jle`> i've realized that one of my biggest haskell pet peeves is `State s ()`
19:45:35 <geekosaur> hm, it did get removed at some point I guess. then I have no idea
19:46:36 <geekosaur> (there was a "Hackage status: https://status.haskell.org" in there)
19:47:17 <kadoban> jle`: Heh ... where does that come up?
19:47:32 <jle`> all the time :O
19:47:34 <glguy> I replaced the hackage status link with the AoC #haskell leaderboard code for the next 15 day
19:47:43 <jle`> also Writer w ()
19:47:45 <jle`> lol
19:47:56 <jle`> but `State s ()` pops up pretty often
19:48:06 <jle`> especially in things like stream processing
19:48:17 <kadoban> What should be used instead, is that just some kind of fold I guess?
19:48:42 <kadoban> Er, I guess depending on what it's being used for.
19:49:05 <jle`> State s () is just 's -> s'
19:50:33 <kadoban> Oh ... haha right.
19:50:57 <jle`> and 'Writer w ()' is just 'w', heh
19:51:25 <jle`> no offense to byorgey https://github.com/byorgey/AoC/blob/master/01/01.hs#L45
19:52:02 <benzrf> jle`: sometimes do-notation is handy :o)
19:52:30 * byorgey agrees with benzrf 
19:52:33 <byorgey> =)
19:52:40 <glguy> :t (&~)
19:52:42 <lambdabot> s -> State s a -> s
19:53:04 <glguy> That's why someone added that one
19:53:17 <byorgey> heh, nice
19:54:03 <jle`> :3
19:54:44 <jle`> but if you turn State s () to s -> s, it's just 'over'
19:54:52 <codygman> Can anyone suggest papers/tutorials/any sources on understanding the type level machinery underlying Frames (https://github.com/acowley/Frames/blob/master/src/Frames/ColumnUniverse.hs) and vinyl (https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Tutorial-Overview.html), I'm specifically trying to deeply understand the type inference that is done on csv files and the "semi-lattice" used in lubTypeReps: https://github.
19:54:59 <codygman> also what is a semi-lattice and what does lub stand for?
19:55:06 <glguy> "Least upper bound"
19:55:30 <jle`> i'll admit that 'when' is useful
19:55:39 <jle`> we don't have a combinator like 'when' for 's -> s' in base
19:56:23 <codygman> glguy: Thanks! Where does the word "least upper bound" come from or where is it popularly used? I find it a personal challenge to figure these kinds of questions out without asking somewhere like here.
19:57:07 <codygman> I'm reading the least upper bound page on wikipedia as we speak btw
20:01:11 <codygman> In trying to answer my own question from above, I think I'll read byorgey's series on type-level haskell: https://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
20:01:13 <benzrf> well, "least upper bound" is pretty literal :)
20:01:52 <codygman> benzrf: Indeed it is, I had never header of it previously though and was trying to divine meaning from "lub"
20:02:01 <codygman> s/header/heard
20:10:41 <Gurkenglas> That AoC1. Get gud at golf (\[a,b,c,d] -> abs (a-c) + abs (b-d)) . M.elems . M.fromListWith (+) . (traverse . _1 %~ (`mod` 4)) . scanl1Of (traverse . _1) (+) . map (\(x:xs) -> (d x, read xs)) . map init . words
20:11:54 <Gurkenglas> (Though I guess me having to modify that approach for the second half of day 1 doesn't speak in my favor)
20:12:22 <glguy> it burns us!
20:14:23 <Gurkenglas> (Oh, also the twoliner d 'L' = -1; d 'R' = 1)
20:22:13 <glguy> Gurkenglas: for your golf, don't forget each
20:22:52 <glguy> 4 characters of savings every traverse!
20:23:55 <glguy> M.elems -> toList
20:24:27 <Fare> I implemented inheritance in pure lambda calculus. In Haskell, though, my types are uninteresting and limited :-(
20:24:43 <Fare> inherit :: Proto r -> Proto r -> Proto r
20:32:27 <codygman> Can you use the ghci debugger to debug template haskell?
20:36:23 <grantwu> Why is foldMap called what it is?
20:36:36 <Xnuk> :t foldMap
20:36:38 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
20:37:00 <grantwu> okay, but it's really just like
20:37:23 <grantwu> mconcat . fmap right
20:37:48 <grantwu> I guess that adds a Functor constraint
20:38:18 <grantwu> and I guess concatMap is taken
20:43:06 <unskill> Anybody can work with STUArrays?
20:45:22 <kadoban> I have managed to a time or two, often with assistance from here xD
20:47:19 <glguy> unskill: Yeah, they're for everyone
20:48:09 <Cale> :t fold
20:48:10 <unskill> glguy: I did write "Anybody", not "Everyone"
20:48:11 <lambdabot> (Monoid m, Foldable t) => t m -> m
20:49:18 <Cale> :t (\f -> fold . fmap f) -- grantwu 
20:49:19 <lambdabot> (Monoid c, Foldable t, Functor t) => (a -> c) -> t a -> c
20:50:11 <grantwu> Yeah, that's an extra constraint
21:05:25 <freesk> Hey
21:10:08 <freesk> Any idea about bug bounties?
21:20:11 <abbe> hi
21:22:00 <abbe> I have a tree data structure, which I want to make traverse-able (basically like to be able to use mapM), but its type has no parameters, e.g. data Tree = Leaf Int | Branch Tree Tree
21:22:33 <abbe> any ideas how to solve this ?
21:22:40 <abbe> or hints
21:24:21 <abbe> or add a dummy parameter
21:24:25 <kadoban> abbe: Well, it can't *actually* be Traversable obviously. If you want maybe you can make it MonoTraversable or something
21:27:20 <kadoban> I suspect adding a dummy type parameter isn't helpful. You could make the thing *actually* parameterized (trade out the Int), if that's what you want.
21:27:28 <nitrix> omapM :: Applicative m => (Element mono -> m (Element mono)) -> mono -> m mono
21:27:49 <abbe> okay
21:27:56 <abbe> thanks for the reply
21:29:13 <kadoban> I have a feeling that the latter is more sensible, making it parameterized for real instead of specific to Int.
21:29:18 <nitrix> The library claims "If you understand Haskell's basic typeclasses, you understand mono-traversable."... but that type family stuff is troubling.
21:30:14 <kadoban> I managed to use it a time or two without really understanding how type families work, and it didn't seem to explode anything. But yeah, it's slightly worrying.
21:30:19 <abbe> mono-traversable seems like what will help me, but if I can't use mapM, but a different function omapM, then i might as well, write mapM for my use-case, instead of importing a whole library
21:31:40 <nitrix> mapM :: Monad m => (a -> m b) -> t a -> m (t b)
21:31:45 <nitrix> t :: * -> *
21:32:09 <nitrix> abbe: As it currently stand, that'd be impossible without a couple changes, since the kinds do not match.
21:32:57 <nitrix> abbe: Have you considered `data Tree a = Leaf a | Branch (Tree a) (Tree a)` ?
21:33:01 <abbe> right, what i meant is, if I implement Element typeclass for my data structure
21:33:56 <abbe> nitrix: I considered that, although that's just an example i mentioned here, my real data structure, is slightly complex than tree
21:35:03 <abbe> data LispVal = LispInt   Int | LispVal   Text | LispStr   Text | LispQuote LispVal | LispCons  LispVal LispVal | LispBool  Bool | LispNil
21:35:56 <nitrix> That seems fairly complicated to traverse.
21:36:09 <abbe> I only need to traverse LispCons stuff
21:36:46 <nitrix> Anyway, you can implement that MonoTraversable instance, but I don't think it gives you a Traversable instance. You'll be using omapM instead of mapM.
21:37:32 <abbe> yeah
21:37:46 <abbe> thanks!
21:38:15 <WhiskyRyan> Can you all suggest some good books/resources for learning haskell? I am currently reading "Learn You a Haskell for Great Good".
21:38:58 <nitrix> WhiskyRyan: http://haskellbook.com combined with #haskell-beginners seems to be having great success at the moment.
21:39:33 <WhiskyRyan> nitrix: Thanks!
21:40:01 <abbe> also haskell wikibook, if you are more than a beginner level. youtube videos about haskell stuff are also pretty good resource
21:40:36 <abbe> https://www.youtube.com/watch?v=pzouxmWiemg (monad transformers)
21:40:53 <WhiskyRyan> abbe: I'll check that out too, thanks.
21:41:40 <abbe> https://www.youtube.com/watch?v=GZPup5Iuaqw (next level mtl)
21:42:17 <abbe> both of those videos just transitioned me to a higher level, i can suddenly feel so comfortable with monad transformers
21:42:25 <abbe> all the best!
21:44:13 <nitrix> WhiskyRyan: LYAH is great to break the ice and get people interested but does (in my opinion) a poor job at teaching the language. A lot of fundamental concepts are missing and feels more like a guided tour.
21:45:51 <nitrix> WhiskyRyan: The haskellbook has the benefit of having really great exercises, specially crafted to build iteratively on its own foundation.
21:46:21 <WhiskyRyan> nitrix: I was kind of noticing that after going through the first couple chapters... looking into that haskelbook.com right now.
21:47:41 <nitrix> It's not uncommon from readers of LYAH to attempt a project and fail miserably because they have to apply all the knowledge they learned at once. It's really overwhelming and so they give up on an amazing language.
21:49:03 <rblaze> if I need common API for TLS sockets and simple sockets (send, recv and close), what's the best way to implement it: record with fields-functions, typeclass and instances, some other option?
22:00:08 <glguy> rblaze: There's the "connection" package. I made a similar package for my IRC client that uses OpenSSL called "hookup"
22:17:18 <rblaze> Why can't I compile this: data Foo = Foo { bar :: Monad m => m () } ? ghc complains "error: Not in scope: type variable ‘m’"
22:19:40 <grantwu> What type is m supposed to be?
22:20:13 <grantwu> You probably want data Foo m, but I'm not sure if that's going to work either
22:22:57 <rblaze> grantwu: a function working within any monad, I expect. Like return ().
22:23:22 <glguy> that requires the RankNTypes extension and looks like: data Foo = Foo { bar :: forall m. Monad m => m () }
22:23:51 <glguy> There are (at least?) 3 places that m could come from, so you have to specify
22:24:16 <glguy> data Foo m = ... ; data Foo = forall m. Foo ... ; and the one above which matches what you said
22:24:25 <rblaze> glguy: thanks, I new there must be an extension :)
22:24:33 <rblaze> knew
22:40:36 <dmj`> forall m . would require 
22:40:43 <dmj`> ExistentialQuantification
22:40:58 <dmj`> if it precedes the data constructor
22:41:27 <glguy> Tonight's AoC isn't messing around. The leaderboard hasn't filled yet and it's been out for an hour and 40 minutes
22:42:22 <dmj`> waiting for a hero :)
22:43:02 <kadoban> glguy: That hard?
22:46:54 <glguy> Yeah, certainly harder than they have been so far
22:48:43 <kadoban> glguy: That looks intricate
23:04:44 <b0llu> http://lpaste.net/349761
23:04:49 <b0llu> why does my use of "@" not work?
23:05:08 <b0llu> I'm trying to apply Proxy on a KnownNat (to get the value out of a KnownNat)
23:05:17 <b0llu> jle`, monochrom: help appreciated :)
23:06:00 <glguy> b0llu: ScopedTypeVariables requires you to use forall to make a type variable "scoped"
23:07:23 <b0llu> ahh
23:07:23 <b0llu> I see
23:08:08 <dmj`> natVal (Proxy :: Proxy n)
23:08:14 <b0llu> glguy: when else would you use scoped type variables other than when you're trying to do type to value conversions?
23:09:18 <b0llu> hm, I need more
23:09:20 <b0llu> isn't working
23:09:24 <b0llu> let me paste the whole file
23:10:22 <b0llu> http://lpaste.net/349761#line90
23:10:25 <b0llu> errors at the bottom
23:10:45 <lpaste> glguy pasted “an example requiring scoped type variables for b0llu” at http://lpaste.net/349763
23:11:06 <glguy> b0llu: Suppose you'd written that code and wanted that type signature on twoxs
23:11:16 <unskill> Fucking STUArrays. Took some time to make them work.
23:11:33 <b0llu> okay
23:11:46 <unskill> Actually to understand that I can't easily escape ST monad.
23:12:16 <dmj`> b0llu: (natVal (Proxy @ r)) is invalid
23:12:28 <b0llu> dmj`: why?
23:12:31 <dmj`> unskill: easily? you mean at all
23:12:53 <dmj`> b0llu: what is the type of natVal
23:13:12 <unskill> dmj`: exactly
23:13:20 <dmj`> unskill: that’s a feature ;)
23:13:29 <glguy> natVal :: forall n proxy. KnownNat n => proxy n -> Integer
23:13:34 <glguy> https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#v:natVal
23:13:52 <unskill> dmj`: I don't blame this feature. Just've never worked with Arrays.
23:14:03 <dmj`> unskill: I’d recommend using Vector
23:14:06 <dmj`> @package vector
23:14:07 <lambdabot> http://hackage.haskell.org/package/vector
23:14:21 <b0llu> natVal :: forall n proxy. https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#t:KnownNat n => proxy n -> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer
23:14:29 <dmj`> and using the PrimState type family, to easily swap between ST / IO
23:14:33 <b0llu> natVal :: forall n proxy. KnownNat n => proxy n -> Integer
23:15:06 <glguy> Prelude GHC.TypeLits Data.Proxy> natVal (Proxy @ 42)
23:15:07 <glguy> 42
23:15:43 <unskill> dmj`: managed to make memoization two times faster replacing Map with STUArray. 
23:15:52 <glguy> b0llu: It still doesn't work because theres no forall in densematrix_new_vec :: (KnownNat r, KnownNat c) => V.Vector (r * c) BasicSym -> DenseMatrix r c
23:16:09 <glguy> I don't see a forall in the whole paste...
23:16:12 <glguy> is this an old paste?
23:16:24 <b0llu> hm
23:16:29 <b0llu> no, this is it
23:16:50 <glguy> You have to be explicit that you really mean all the types r and c
23:16:53 <b0llu> ah
23:16:55 <b0llu> I see
23:17:09 <glguy> The scopedtypevariables extension kicks in when you do this
23:18:00 <glguy> This is so that only the special type signatures start introducing scoped type variables (the ones with forall)
23:18:08 <glguy> because standard haskell types don't permit forall
23:18:11 <b0llu> forall r. forall c. does not work
23:18:17 <glguy> try: forall r c.
23:18:36 <b0llu> glguy: the two are different?
23:18:38 <glguy> just after the ::
23:18:38 <unskill> Haskell compilation error messages tend to be longer than C++'s ones
23:18:52 <b0llu> yeah
23:19:00 <b0llu> how does forall r. forall c. differ from forall r c.
23:19:18 <b0llu> OK cool, it compiles :)
23:19:23 <b0llu> but I don't understand the differences
23:19:25 <b0llu> between
23:19:25 <glguy> one has two foralls
23:19:30 <glguy> and two periods
23:19:37 <glguy> and then the other just has one forall and one period
23:19:58 <b0llu> http://lpaste.net/349764
23:20:01 <b0llu> glguy: :)
23:20:05 <b0llu> glguy: not syntactically
23:20:06 <b0llu> semantically
23:20:18 <glguy> semantically it appears that ScopedTypeVariables only cares about the first forall
23:20:42 <b0llu> hmm
23:20:45 <b0llu> that seems "wrong"
23:21:05 <glguy> It's a syntactic construct
23:21:15 <glguy> so the syntax matters
23:21:19 <b0llu> ah
23:22:07 <b0llu> glguy: the forall's make the r, c, existential?
23:22:19 <glguy> No, it doesn't affect the semantics of the type
23:22:28 <glguy> the r and c stay universally quantified
23:22:40 <b0llu> glguy: ah, but the _extension_ needs it to be there syntactically?
23:22:50 <b0llu> I'm sorry, but.. WAT, why?
23:22:56 <glguy> Yeah, that's how you indicate to the compiler that this is a special type signature
23:23:00 <b0llu> hmm
23:23:03 <glguy> not a mere haskell 2010 type signature
23:23:09 <b0llu> lol
23:23:10 <b0llu> I see
23:23:26 <b0llu> does any of this break inference?
23:23:32 <b0llu> the extensions that I have enabled?
23:23:35 <glguy> People like reusing the type 'a'
23:23:42 <glguy> so if scopedtypevariables made all types scoped
23:23:56 <glguy> then there would be lots of breakage in existing code when it was turned on in a module
23:24:11 <b0llu> glguy: but the "scope" is only to that function right?
23:24:37 <glguy> correct, but it would break reuse of type variables within where and let scopes
23:24:50 <ertes> glguy: would there?  ScopedTypeVariables still needs the explicit "forall"
23:24:51 <b0llu> hm
23:24:53 <b0llu> for example?
23:24:58 <glguy> ertes: yeah, we're covering why
23:25:04 <ertes> ah, i see
23:26:38 <lpaste> glguy pasted “for b0llu” at http://lpaste.net/349765
23:26:58 <glguy> b0llu: That function would break if turning on scopedtypevariables affected all type signatures
23:27:05 <b0llu> ohh, okay, I see what you're saying
23:27:19 <b0llu> glguy: but is it that common to have typed functions in "lef"s?
23:27:23 <b0llu> let*
23:27:37 <glguy> sure
23:27:50 <cocreature> common enough to not want to break that code
23:29:01 <b0llu> I see
23:29:08 <b0llu> okay, thanks, this helped guys :)
23:29:11 <b0llu> appreciate it
23:30:08 <b0llu> :)
23:30:14 <glguy> yw
