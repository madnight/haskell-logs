00:15:29 <anohigisavay> hello. i'm trying to add a lambdabot to our own irc server
00:15:47 <anohigisavay> there's not much docs out there
00:16:00 <anohigisavay> the only command i found was irc-connect
00:16:42 <anohigisavay> seems the bot is in the server but how to join a channel? `join <channel>` has no effect
00:28:50 <pavonia> anohigisavay: @join perhaps?
00:30:00 <anohigisavay> pavonia, same thing. it just prompts a newline
00:31:13 <Axman6> invite it to the channel?
00:31:41 <anohigisavay> Axman6, let me try
00:42:11 <anohigisavay> i need to be admin first to invite others
00:42:42 <anohigisavay> i tried with some random channel on freenode but kept getting `[ERROR] : welcome timeout!`
00:45:46 <anohigisavay> it's hardcoded in Lambdabot.Plugin.IRC.IRC _(:з」∠)_
00:50:24 <Athas> Does anyone know of parallel Haskell success stories with a focus on computation, not managing IO?
01:00:31 <gracjan> hi
01:00:36 <gracjan> I try to use ghci debugger
01:01:14 <gracjan> I set a breakpoint, then run :main, ghci stops at breakpoint, but when I execute :main again then ghci does not stop at breakpoint anymore
01:01:18 <gracjan> what is wrong?
01:07:21 <gracjan> hmm, I guess I got caught by a CAF
02:16:09 <f-a> hello, I am trying to install this via cabal install http://hackage.haskell.org/package/rasa
02:16:26 <f-a> so I cabal sandbox init, cabal install. But where do I find the executable?
02:18:09 <slack1256> hidden directory
02:18:14 <slack1256> do a ls -a so see it
02:19:35 <f-a> slack1256: mhhh, apparently I have add-source-timestamps  i386-linux-ghc-7.10.3-packages.conf.d  lib  logs  packages  share  world
02:20:01 <f-a> I am going to fetch the package and see if it actually builds an executable
02:20:46 <f-a> and it does not :s
02:21:54 <slack1256> rasa only ships a library, you have to build the editor executable yourself
02:21:56 <slack1256> as in xmonad
02:22:06 <slack1256> thus you don't see a bin directory on $(ls -a)
02:22:16 <slack1256> but it should be there, on the lib subdir
02:22:35 <f-a> yep
02:22:45 <slack1256> in fact, the is a rasa-example-config for such executable
02:24:03 <f-a> thanks
02:41:03 <lkurusa> .
03:14:58 <jophish> ocharles_: is there an overview or example of opaleye-tf anywhere?
03:24:14 <kaiyin> How do you load the current buffer into ghci and run the main function in spacemacs?
03:25:29 <sbrg> kaiyin: You load it using C-c C-l, and AFAIK there is no default binding for running the main function
03:25:40 <sbrg> however, I used to have such a binding before switching to spacemacs and it is pretty trivial to add on your own
03:31:05 <libscott> Is there a neat way to do: [(Either a b, c)] -> ([(a, c)], [(b, c)]) ?
03:32:58 <kaiyin> sbrg: could you give me a little guidance as to how to do this? Thanks!
03:33:36 <sbrg> kaiyin: sec, let me find my binding somewhere
03:33:45 <kaiyin> Cool.
03:34:09 <Tuplanolla> I guess "pretty trivial" means "I have to look it up".
03:35:09 <mfukar> libscott , isn't Either a b exclusively either a or b?
03:35:25 <sbrg> Tuplanolla: lol. I just don't remember the exact name of the function
03:35:45 <sbrg> https://gist.github.com/saevarb/285b45095e3736aa5260f8a3fa388876 is the function that does it. then you just need to bind it to some key when in haskell-mode
03:40:17 <kaiyin> sbrg: you mean modify haskell-mode? is it possible to avoid this and add this in some config file?
03:41:06 <libscott> mfukar: yes, i want to combine partitonEithers with (,)
03:41:08 <sbrg> kaiyin: No, I mean adding the binding so that it is only enabled while in haskell-mode. that is definitely possible. it should probably go in your .spacemacs file, as a hook
03:41:23 <sbrg> probably best if you refer to the spacemacs documentation
03:52:13 <kaiyin> sbrg: great, thanks!
03:54:52 <kaiyin> sbrg: haskell-interactive-mode-run-expr  doesn't seem to exist any more.
03:56:43 <sbrg> kaiyin: exists for me
03:57:50 <sbrg> it's not interactive, so you won't find it in the list of functions you get in M-x
03:57:58 <sbrg> if you do `<Leader> h d f` however
03:58:00 <sbrg> it's there
03:59:22 <sshine`> hi. toying around with stack. I installed GHC in my homedir using stack and have ~/.stack/programs/x86_64-linux/ghc-ncurses6-... for 8.0.1 and 7.10.3, which seems great. but when I want to run my stack project, it complains that I must apply --system-ghc. and Emacs'es flycheck complains likewise.
04:00:18 <kaiyin> sbrg: ah, indeed.
04:00:19 <sshine`> I thought I could just add 'default: stack build --system-ghc' in my Makefile, but it seems to get tedious when Emacs'es calls to various programs give the same errors.
04:00:37 <MarcelineVQ> libscott: it's not exactly pretty but you can copy what partitionEither does: foldr (\(e,x) -> either (left x) (right x) e) ([],[]) where left x' a ~(l,r)=((a,x'):l,r); right x' a (~l,r) = (l,(a,x'):r)
04:01:02 <jmnoz> How should a beginner who doesn't know Lens go about learning to use something like xml-lens, taggy-lens?
04:03:08 <dramforever> taggy-lens has great examples
04:05:01 <jmnoz> I can't figure out how to use it to remove e.g. one type of element from a Node
04:06:30 <sshine`> haha, also, if I run "stack config set system-ghc --global true" (which the command recommends), I get the error message where it recommends me to write that. seems a little recursive. :P
04:17:33 <sshine`> ah. I didn't want to run "stack setup" because I feared it'd put the entire compiler in my project dir. but it seems that .stack-work has only grown to 28M, which is very fine. I don't know if this is because I already installed GHC in my homedir using stack that it just links to that.
04:17:50 <kaiyin> sbrg: here is my first attempt: https://gist.github.com/kindlychung/a81f3a50e1f09242af953648b2f8be2b  Doesn't seem to have effect. What went wrong?
04:18:55 <sbrg> kaiyin: I would help if I could, but I haven't tried adding a keybinding in spacemacs and don't know what the correct way is, unfortunately. the best thing I can do is refer you to the spacemacs people
04:19:10 <sbrg> (there's a #spacemacs channel btw, and the people in #emacs will probably help as well)
04:20:35 <kaiyin> sbrg: understood, thanks.
04:20:48 <kaiyin> \join #spacemacs
04:27:01 <ocharles_> Jophish: not currently
04:28:18 <purelazy> ocharles: ??
04:28:26 <purelazy> ocharles_: ??
04:47:43 <scav> Would anyone have a Haskell plugin to recommend for IntelliJ? I would prefer to use an editor that I am already comfortable with when learning Haskell.
04:48:38 <scav> I have found these, and they look promising https://github.com/rikvdkleij/intellij-haskell and https://github.com/carymrobbins/intellij-haskforce but perhaps someone else has found something better?
04:55:22 <suppi> scav: i don't use intellij so i don't know of any plugins, but looking at the websites of each plugin you linked i'd probably go with the first one
04:55:52 <suppi> it seems easier to setup
04:56:41 <suppi> oh, but it does have a few problematic remarks
04:57:04 <suppi> like no supporting multi package projects or windows (if you use windows)
04:57:12 <scav> Windows as in the OS?
04:57:50 <scav> Im pretty sure I don't need multi package projects when just starting out as I imagine I will just be re-implementing a lot of the stuff already in Haskell just to get a feel for it.
04:58:48 <suppi> right. but you might have to change the plugin later on if it won't support it until then
04:58:55 <suppi> windows as the os, yes
04:59:26 <suppi> well, might as well give the first one a try :)
04:59:31 <lpaste> MarcelineVQ pasted “libscott: a little nicer” at http://lpaste.net/350660
04:59:57 <scav> Thats no problem, I use OSX and Linux. However, I will just start with the first one as suggest, and perhaps move on once I get the hang of it.
05:00:18 <scav> Might even be better to avoid a really helpful editor while I learn, perhaps I should consider that as well...
05:00:21 <suppi> sound like a good plan. good luck and have fun :)
05:00:37 <suppi> yeah, that's also possible
05:01:03 <scav> Thank you, I enjoy what I have done so far a lot and it has made me refactor a lot of my old Java and Scala code :)
05:01:21 <suppi> :)
05:02:16 <scav> But clearly, refreshing my math feels to be immensely helpful!
05:04:25 <suppi> scav: yeah definitely. i felt a lot of cs stuff start to connect when learning haskell :)
05:05:03 <sshine`> I just added haskelldb to my .cabal project file and running 'stack build' now gives "haskelldb must match >=2.2.4 && <2.3, but the stack configuration has no specified version (latest applicable is 2.2.4). Recommended action: try adding the following to your extra-deps in .../stack.yaml: - haskelldb-2.2.4".
05:05:18 <sshine`> my question is this: why must some packages be added to stack.yaml and not others?
05:05:25 <Axman6> isn't haskelldb extremely old?
05:05:34 <sshine`> I don't know.
05:05:35 <scav> suppi total :)
05:05:41 <scav> s/total/totally
05:05:43 <ertes> is there a way to override the std-handles (not the FDs, just the handles) for the duration of an IO action?  such that putStrLn prints to somewhere else
05:05:54 <Axman6> but also, they need to be added if they're not present in the LTS snapshot you're using
05:05:55 <sshine`> Axman6: what does one use instead?
05:05:59 <sshine`> Axman6: ahhh.
05:06:07 <Axman6> sshine`: which database are you connecting to?
05:06:15 <sshine`> Axman6: mysql, probably.
05:06:20 <sshine`> Axman6: I don't really care.
05:07:11 <ertes> ah, hDuplicateTo could work
05:07:13 <sshine`> Axman6: I just heard HaskellDB mentioned in a recent (I think?) Haskell Cast, and I thought that was what one would use. :)
05:07:14 <Axman6> postgresql-simple and sqlite-simple re both excellent low level interfaces
05:07:27 <sshine`> Axman6: I'd like an interface that isn't low level.
05:07:39 <Axman6> persistent attempts to abstract which database you're using away
05:07:51 <sshine`> Axman6: ok.
05:08:13 <Axman6> check out persistent if you want to be able to change databases
05:08:17 <sshine`> Axman6: thanks!
05:08:34 * Axman6 wasn't aware anyone was still seriously uing mysql for new projects
05:09:09 <sshine`> Axman6: as in "... in the Haskell space" or "in general"?
05:09:17 <Axman6> in general really
05:09:32 <sshine`> Axman6: MySQL is widely used.
05:09:40 <sshine`> or... uh... MariaDB. :P
05:09:54 <Axman6> I've only ever seen it used in PHP projects
05:09:55 <scav> Axman6 surprises me every time 
05:13:10 <sshine`> Axman6: it appears that MySQL is not only one of the most popular RDBMSes, but it's also gaining in popularity. http://db-engines.com/en/ranking_trend - http://db-engines.com/en/ranking_trend/system/MySQL ... still, I am quite agnostic about databases and only use MySQL because I know it from my pre-university days.
05:13:42 <suppi> Axman6: i think PHP is also still wildly used :P
05:13:53 <MarcelineVQ> as long as wordpress is a thing mysql will remain in the rankings
05:14:05 <sshine`> and Drupal.
05:14:07 <Axman6> suppi: :'(
05:14:09 <sshine`> ugh.
05:14:34 <Axman6> yeah exactly, the world would be a better place without both of those
05:17:21 <scav> mysql is fine if you know how it works. problem is that once you know how it works, you are going to switch to postgres, oracle or mssql.
05:17:21 <Roxxik> yeah but wordpress is most often used by people who just don't care
05:18:01 <hpc> mysql has a use case
05:18:12 <hpc> it's perfect for people who don't know they need to run initdb to make postgres work
05:18:31 <Guest29499> So... I hate MySQL ... kind of. On the one hand I think things like "cascading deletes" (which it has) and "constraints" (making sure values are within a certain range) - MySQL doesn't support these, it does support referential integrity but it's not checked at commit, it's checked at statement time, these things are application things
05:18:38 <Guest29499> Like you ought not be relying on the DB to do them for you
05:18:58 <Axman6> I couldn't love without PostGIS
05:19:28 <hpc> i vaguely remember mysql having better views and stored procedures than mssql, ever so slightly
05:19:53 <hpc> down to some tiny dumb thing like views referencing other views
05:19:57 <scav> I don't think my RDB of choice would have any impact on my ability to love, but I am not judging Axman6.
05:20:08 <Guest29499> Because of MySQLs limitations it has an optimiser that works REALLY well (when it works) in those limits
05:20:15 <Guest29499> MSSQL supports A LOT more stuff
05:20:38 <Guest29499> scav: he obviously meant "live", spaz.
05:20:38 <Axman6> ha, s/love/live but also, s/love/do my job
05:21:11 <hpc> for a while oracle barely beat out postgres on having materialized views
05:21:12 <scav> Guest29499 ooooooh!
05:22:06 <scav> Axman6 :p
05:22:29 <hpc> the optimizer is pretty minor when you could just be writing good queries to start
05:22:32 <ertes> the standard handles are per process, right?
05:22:54 <ertes> so i couldn't set stdin to something else for only a single thread
05:22:56 <Axman6> I got bitten really badly by materialised views in the past. ended up replacing all that logic in app and making it much faster (but the view was for a query postgres was unable to optimise)
05:23:03 * Guest29499 takes the "spaz" sticker off scav and puts it on hpc instead
05:23:23 <scav> Guest29499 is being a dick getting you far in life?
05:23:33 <hpc> ertes: there's a couple of packages that can redirect output
05:23:34 <Axman6> guardianJ: yeah what are you doing?
05:23:40 <Axman6> uh, Guest20511, not guardianJ
05:23:44 <Axman6> bleh
05:23:44 <hpc> i forget the name of them, but i know one of them has a really nice api
05:23:45 <Guest29499> scav: "it's not arrogance if you're right" - that's gotten me far.
05:23:54 <scav> wow
05:24:02 <Axman6> there are way too many Guest in here
05:24:12 <scav> This guest is going on my ignore list though
05:24:38 <scav> This one is always a classic when talking mysql: https://grimoire.ca/mysql/choose-something-else
05:25:18 <SpazSlayer> OMG I think he actually ignored.
05:25:29 <SpazSlayer> I feel so superior right now because I can ignore without technical assistance.
05:25:36 <Axman6> SpazSlayer: this kind of behaviour won't last long in here
05:25:37 <SpazSlayer> But yeah MySQL... is good at what it does, nothing else though
05:25:50 <ph88> since when does #haskell have flame? omg :/
05:25:52 <kadoban> SpazSlayer: Stop that.
05:26:04 <SpazSlayer> What? The DB chat?
05:27:02 <scav> did he change nick? sigh
05:27:18 <ertes> hpc: those don't quite do what i need…  i really just want to redirect std* without doing anything to the underlying FDs
05:27:28 <ertes> unfortunately hDuplicateTo doesn't seem to do it either
05:28:31 <SpazSlayer> ertes: what are you trying to do?
05:29:24 <ertes> SpazSlayer: i want to run a regular IO action that uses stdin/stdout/stderr and have its input/output redirected to an external terminal
05:30:18 <ertes> currently i require that action to abstract over the handles, but that's really inconvenient, because libraries still use the standard handles
05:30:20 <Axman6> you might be able to do that with (posssibly nasty) shell tricks
05:30:31 <SpazSlayer> Can you give an example
05:30:35 <ertes> Axman6: i need to do it from haskell
05:30:43 <SpazSlayer> Because you're saying "input output redirect" and I'm thinking "use a pipe?"
05:31:36 <ertes> i'm working on this: https://github.com/esoeylemez/rapid-term
05:32:00 <Axman6> ertes: and using things like std_out = UseHandle handleOfTerminal doesn't work?
05:32:10 <Axman6> https://hackage.haskell.org/package/process-1.4.3.0/docs/System-Process.html#t:CreateProcess
05:32:10 <SpazSlayer> Oh I see
05:32:27 <ertes> Axman6: it's not a haskell program, but an IO action
05:32:33 <ertes> i'm not executing
05:32:47 <Axman6> ertes: oh, I thought you mean of a shild process. hmm
05:32:55 <ptek> I want to fill several config templates from data I am having. Do you have a simple templating library in mind you'd use for this?
05:33:09 <ertes> SpazSlayer: thanks for your support, but i'd prefer to talk publicly =)
05:33:57 <ertes> ptek: which format/language?
05:34:04 <SpazSlayer> Thanks for telling me here :) Dick move.
05:34:27 <Axman6> SpazSlayer: quit acting like a child
05:34:28 <ertes> SpazSlayer: sorry
05:34:48 <Axman6> ertes: hmm, hDuplicateTo seems like the right thing...
05:35:09 <SpazSlayer> Good.
05:35:34 <Axman6> but there was a whole discussion earlier which I wasn;t following that seemed to conclude that wasn't the right solution?
05:35:46 <ptek> ertes, the configs are cloud_config, nginx and some application specifig json configs
05:35:54 <ertes> Axman6: yeah, but when i try to use it, i get this for some reason: {handle: <file descriptor: 12>}: hDuplicateTo: illegal operation (handles are incompatible)
05:36:07 <SpazSlayer> Axman6: it seems like he wants to emulate a terminal
05:36:24 <SpazSlayer> That is - unfortunately - one of my "expert areas". Not proud of that because.... terminals are horrible.
05:36:27 <ertes> ptek: if there is a combinator library for your file format, i'd use that together with functions (functions are an excellent templating framework)
05:36:43 <Axman6> read/write modes? clutching at straws here :\
05:36:45 <ertes> ptek: otherwise i'd still use functions, together with a Text builder most likely
05:37:25 <Axman6> ptek: mustache might be a place to start
05:37:36 <ertes> Axman6: it's not the right solution, if you're using it to redirect your input/output within an application, but rapid-term is actually a development/debugging framework
05:37:58 <ptek> ertes, that makes sense. did not think of it this way... thanks. 
05:38:01 <ertes> Axman6: if i can't redirect, i'd require users to abstract over the handles (and therefore no longer use putStrLn, getLine, etc.)
05:38:30 <ptek> Axman6, I have just looked at mustache, and there are 2 libraries in hackage. Seems they compete a little.
05:38:40 <ertes> SpazSlayer: the terminal emulation works…  actually everything works, except this little detail =)
05:38:52 <ertes> and it's highly haskell-specific and has nothing to do with the actual terminal stuff
05:39:38 <ptek> Axman6, I am talking about stache and mustache. The others seem abandoned
05:40:51 <SpazSlayer> Those sound like javascript frameworks
05:42:18 <rdococ> it is nearly new years
05:42:33 <SpazSlayer> It has been for months rdococ 
05:43:13 <Axman6> stache looks a little easier to use. I've never used it in Haskell, only in the front end of the project I'm on in JS
05:43:25 <SpazSlayer> Knew it!
05:43:25 <Axman6> less than 24 hours until 2017 here
05:44:01 <SpazSlayer> I'm looking forward to 2017
05:44:06 <SpazSlayer> Years that are prime numbers are the best years
05:44:13 <MarcelineVQ> a time traveler
05:44:34 <SpazSlayer> Axman6: you mentioned earlier for me to stop acting like a child
05:44:42 <Roxxik> still > 35 hours
05:44:43 <SpazSlayer> "time traveller" at timezones is waaay more childish
05:44:52 <Axman6> ?
05:44:53 <maerwald> :o
05:46:04 <rdococ> it has?
05:46:35 <ertes> this is my current approach: https://github.com/esoeylemez/rapid-term/blob/redirect/src/Rapid/Term.hs#L68
05:46:39 <ertes> and it doesn't work
05:47:43 <SpazSlayer> So like
05:47:48 <SpazSlayer> I love Haskell's type system
05:49:49 <Axman6> ertes: yeah I think either haskell-cafe or the ghc mailing list might be a better place to ask, this seems fairly ghc internals specific
05:50:39 <ertes> indeed, thanks
05:51:08 <Axman6> wouldn't mind knowing the results
05:52:30 <ertes> Axman6: i'll leave the branch alone for now, but when i return to it i'll most likely ask on -cafe…  so if you're reading that…
05:52:42 <ptek> Axman6, ertes, thanks :)
05:54:24 <Axman6> I don't usually read the mailing lists, not enough time in the day with all this IRC ;)
06:04:37 <sshine`> with persistent, what type do I choose for a database column type that has both a date and a time component (e.g. MySQL's DATETIME)? I can only find 'Day' and 'TimeOfDay', but they're separate types.
06:05:33 <SpazSlayer> sshine: database stuff isn't welcome here.
06:05:39 <SpazSlayer> Not joking BTW, it's offtopic or something
06:06:10 <Axman6> sshine`: UTCTime or LocalTime usually
06:06:32 <ertes> Axman6: if i remember i'll let you know =)
06:06:40 <Axman6> Thanks =)
06:07:36 <hodapp> said database question sounds relevant here
06:07:55 <SpazSlayer> hodapp: someone told me to drop it earlier
06:07:58 <SpazSlayer> Take it up with them
06:08:41 <Tuplanolla> They were referring to your behavior, not the database talk, SpazSlayer.
06:08:52 <SpazSlayer> I don't think so
06:08:59 <SpazSlayer> I'd only been saying MySQL stuff at that point
06:09:05 <SpazSlayer> *MARIADB fuck
06:09:08 <sshine`> SpazSlayer: I'm not familiar with any channels that discuss haskell database packages.
06:09:19 <ertes> sshine`: it's fine here
06:09:28 <SpazSlayer> It'd be great if ops oped themselves so you knew who to safely ignore.
06:09:45 <SpazSlayer> kadoban: trusted you
06:09:50 <SpazSlayer> Yeah nvm then carry on.
06:10:08 <kadoban> SpazSlayer: Troll somewhere else. Nobody is amused.
06:10:15 <SpazSlayer> I'm not trolling.
06:10:19 <SpazSlayer> You told me to stop the DB talk. 
06:10:24 <sshine`> SpazSlayer: perhaps you're not doing it on purpose.
06:10:37 <sshine`> SpazSlayer: maybe you're new to freenode?
06:10:49 <SpazSlayer> New to freenode, not IRC
06:10:59 <SpazSlayer> Learning about you guys and PMs, WTF is that about.
06:11:14 <sshine`> huh?
06:11:50 <SpazSlayer> PMing someone on freenode is... like... frowned upon
06:12:14 <sshine`> SpazSlayer: not really. :)
06:12:20 <SpazSlayer> Yeah really
06:12:33 <sshine`> SpazSlayer: you should stop trolling.
06:12:38 <SpazSlayer> No it really is.
06:12:39 <ertes> SpazSlayer: there is a reason i rejected your PM:  if you explained it privately, we would rob others of the opportunity to learn from it as well
06:12:46 <SpazSlayer> It's like talking to someone on a train, just not done
06:12:55 <SpazSlayer> ertes: THANKS FOR TELLING ME THAT HERE A FUCKING GAIN!
06:12:58 <SpazSlayer> You were not my one sample!
06:13:16 <Tuplanolla> Now we know you know, so we can talk about Haskell instead, SpazSlayer.
06:13:21 <SpazSlayer> If it was just one guy I'd assume you were just antisocial
06:13:30 <SpazSlayer> There's a definite pattern.
06:13:47 <hodapp> still not amused.
06:13:51 <sshine`> SpazSlayer: there's nothing wrong with talking to strangers on a train. there's something wrong in assuming they want to help you with private problems, but then there's courtesy. still, this isn't terrible relevant to Haskell or lifting the mood of the channel, so why are we talking about it?
06:14:07 <SpazSlayer> I PMed to help him with his problem BTW
06:14:11 <SpazSlayer> Just FYI
06:14:17 <ertes> that's true
06:14:26 <SpazSlayer> I agree that PMing someone going "You know what gets me in life..."
06:14:28 <SpazSlayer> That's not okay
06:14:30 <Tuplanolla> Can someone enlighten me what `not-gloss` needs `lens` for?
06:14:45 <Axman6> what's not-gloss?
06:14:59 <Tuplanolla> It's... not `gloss`.
06:15:03 <Tuplanolla> Basically `gloss` in 3d.
06:15:34 <Axman6> sounds interesting
06:15:51 <SpazSlayer> @ sshine` 
06:16:34 <kuribas> lol
06:16:40 <ertes> Tuplanolla: not-gloss does not depend directly on lens
06:17:02 <hodapp> sigh, lens is one of those things I've still not gotten around to learning
06:17:10 <ertes> Tuplanolla: there is a transitive dependency via spatial-math
06:22:16 <lordcirth> hodapp, the basics of using lens aren't too hard to learn, but how they actually work under the hood? No idea.
06:22:38 <Tuplanolla> That makes even less sense, ertes.
06:22:58 <Axman6> how lenses actually work is surprisingly simple
06:23:11 <hodapp> the issue is not whether lenses are simple or not
06:23:16 <hodapp> it's that I procrastinate horribly
06:23:18 <davean> Yah, it was always the vocabulary for using lenses that annoyed me
06:23:18 <ertes> Tuplanolla: i can't tell you what it does with lenses…  maybe it's just using them for implementing something
06:23:19 <SpazSlayer> What do you mean by lenses?
06:23:21 <davean> their implimentation is trivial
06:23:44 <ertes> lordcirth: care to do two exercises?  i promise you will understand (the basics of) lenses after that =)
06:23:51 <hodapp> I worked through part of https://artyom.me/lens-over-tea-1
06:24:04 <hodapp> but what I need to do really is implement something with lenses, then I'll make a lot more sense of them
06:24:32 <hodapp> I just learned a bit of Frames, and that relies on microlens, so that's a start
06:24:57 <SpazSlayer> WTF are you on about!
06:24:57 <davean> ertes: I'm curious which two excerises you'd be thinking of 
06:24:58 <SpazSlayer> Explain!
06:25:27 <lordcirth> SpazSlayer, https://duckduckgo.com/?q=haskell+lens&t=canonical&ia=software
06:25:38 <ertes> davean: exercise 1: implement a function that can map over the fst of a tuple:  mapFst :: (a' -> a) -> (a', b) -> (a, b)
06:26:01 <Axman6> hodapp: you might find this a good introduction: https://github.com/tonymorris/lets-lens
06:26:08 <ertes> davean: write it directly, without Arrow/Bifunctor
06:26:56 <hodapp> Axman6: I'll check it out
06:27:07 <SpazSlayer> lordcirth: what do the other parameters mean there?
06:27:20 <SpazSlayer> t= referrer? ia=some sort of type of the search?
06:27:33 <davean> ertes: thats it?
06:27:39 <ertes> davean: that's the first one
06:27:44 <davean> ok
06:27:48 <lordcirth> SpazSlayer, in the link? oh yeah, just a referrer.  Not sure about the ia. I would have stripped that if I was paying attention.
06:29:03 <ertes> davean: do you want to do it, or do you just want to know which exercises i had in mind?
06:29:08 <davean> ertes: mostly the latter
06:29:13 <Tuplanolla> Don't those just mean you're using the default bookmark in whatever browser Ubuntu comes with, lordcirth?
06:29:23 <davean> though I basicly can't read an excersise that simple and NOT do it in my head
06:29:26 <MarcelineVQ> ertes: I want both
06:29:35 <davean> ertes: I'm not sure theres a difference therefor :-p
06:30:17 <ertes> here goes exercise 2:  rewrite that function to work over a target functor:  traverseFst :: (Functor f) => (a' -> f a) -> (a', b) -> f (a, b)
06:30:30 <lordcirth> Tuplanolla, the default search engine that's configured in Ubuntu's Firefox, yes
06:30:53 <ertes> then realise that if f = Identity this function is equivalent to mapFst
06:31:12 <ertes> and realise that if f = Constant a', this function can be used to extract the fst
06:31:17 <ertes> that makes it a lens
06:31:18 <Axman6> with a little wrapping and unwrapping
06:31:22 <Tuplanolla> Thought so, lordcirth. They're just partnership counters to see where users come from, SpazSlayer.
06:32:19 <ertes> runIdentity (traverseFst (\x -> Identity (x + 1)) (1, 5)) = (2, 5)
06:32:36 <ertes> runConstant (traverseFst Constant (1, 5)) = 1
06:33:21 <Roxxik> (1,5) & traverseFst +~ 1; (1,5)^.traverseFst;   ;)
06:33:36 <Roxxik> un-inlined
06:33:45 <ertes> and yes, traverseFst is an actual lens that you can use with the lens library =)
06:34:05 <ertes> when you use (%~), lens uses Identity to change the value
06:34:23 <ertes> when you use (^.), lens uses something equivalent to Constant to read the value
06:34:52 <ertes> x ^. l = runConstant (l Constant x)
06:34:56 <Roxxik> actually it is Const from Control.Applicative
06:35:22 <ertes> yeah, i can never memorise which one…  we have far too many implementations of Constant =)
06:36:25 <MarcelineVQ> the one from applicative is from Data.Functor.Cost even :>
06:36:30 <MarcelineVQ> *Const
06:38:47 <shapr> GOOD MORNING #HASKELL! wheee!
06:38:58 <ph88> weee
06:39:23 <shapr> hoi ph88, hoe gaat het met jou?
06:39:31 <ph88> goed
06:39:54 <ph88> actually i need a shower :P brb
06:40:36 <Roxxik> MarcelineVQ: it is in base -4.9.0, but not in base-4.8.1, where i looked, 
06:40:40 <hodapp> o hai shapr!
06:41:00 <hodapp> shapr: how legit is http://www.simplyrecipes.com/recipes/swedish_coffee_bread/?
06:41:51 <shapr> hodapp: I certainly ate that a bunch of times when I lived in Norrbotten.
06:44:36 <bengt_> legit fika
06:45:19 <hodapp> wut
06:47:08 <NextHendrix> y6tzspp9.z]
06:47:28 <Axman6> better change that NextHendrix :(
06:47:46 <hodapp> maybe it was just a cat walking on the keyboard
06:47:51 <NextHendrix> y6tzspp9.z]#[]c.## =
06:47:58 <Axman6> much better
06:48:01 <hodapp> or... Perl code?
06:49:06 <shapr> bengt_: right on, legit fika
06:50:41 <shapr> Advent of Code got me using lens, that alone was worthwhile.
06:51:08 <shapr> but I also learned many things by reading glguy's solutions after solving the puzzles myself.
06:51:38 <Axman6> such as?
06:51:46 <ertes> the thing i didn't like about AoC was that it was time-bound, not skill-bound
06:52:00 <ertes> so it favoured quick-n-dirty solutions over good ones
06:52:31 <shapr> ertes: that ended up helping me, I learned how to start quick n dirty and then improve by looking at the history in glguy's AoC repo
06:52:56 <Axman6> so, it always favoured wget https://adventofcode.org/solutions/haskell/#n? :P
06:53:39 <shapr> Axman6: oh, strictness annotaions are way more useful than I thought, foldl' is the correct choice 99% of the time, group is lazy and that's awesome, groupBy and friends have better flavors in the utility-ht package
06:54:01 <Axman6> haven't seen utility-ht
06:54:03 <shapr> Axman6: also, parMap is cool, but parBuffer is better for what I do
06:54:06 <Axman6> @hackage utility-ht
06:54:06 <lambdabot> http://hackage.haskell.org/package/utility-ht
06:54:06 <shapr> Axman6: https://hackage.haskell.org/package/utility-ht
06:54:16 <Axman6> ta :)
06:54:59 <shapr> Axman6: I ended up really wanting this: https://wiki.haskell.org/List_function_suggestions#Generalize_groupBy_and_friends
06:55:12 <ertes> shapr: parBuffer : parList/parMap = foldl' : foldl
06:55:26 <ertes> both are useful, but 99% of the time you should use parBuffer instead of parList/parMap =)
06:55:41 <shapr> ertes: yeah, but now I know!
06:55:54 <SpazSlayer> What's up?
06:56:24 <Axman6> shapr: yeah groupBy catches everyone out with that, it feels wrong, and far less useful than it should
06:56:49 <shapr> ertes: I was 'competing' against coworkers using mostly Python and Go, my naive solutions were slower than theirs, but Haskell's parallel magic impressed them.
06:57:05 <Axman6> > map (head &&& length) . group $ "aaabbcccccddabcde" -- about the only useful thing group does
06:57:08 <lambdabot>  [('a',3),('b',2),('c',5),('d',2),('a',1),('b',1),('c',1),('d',1),('e',1)]
06:57:08 <shapr> Axman6: and that led me to alternative preludes like protolude and friends
06:58:19 <shapr> Axman6: my AoC solutions are https://github.com/shapr/adventofcode2016 but they're not nearly as nifty as https://github.com/glguy/advent2016
06:58:58 <shapr> Comparing the two has given me direction on how to be more fluent in Haskell.
06:59:08 <shapr> SpazSlayer: what's up with you? Enjoying Haskell?
06:59:14 <davean> Axman6: How does it catch people out?
07:00:27 <novakboskov> How to avoid binding in case expression when have e.g. symbol d previously bounded to ' ' and want to check if some x is equal to d in case expression like this: isSomething x = case x of d -> True otherwise -> False ?
07:00:30 <Axman6> davean: because most people wuld expect groupBy (<=) to find ascending subsequences
07:00:59 <Cale> novakboskov: Perhaps you wanted to write x == d ?
07:01:03 <davean> Axman6: Huh, I never would have
07:01:10 <davean> Axman6: that seems rather counter to its definition
07:01:18 <davean> I don't mean invalid
07:01:19 <ertes> @let genGroupBy p = foldr (\x0 xss' -> case xss' of (x1 : xs) : xss | p x0 x1 -> (x0 : x1 : xs) : xss | otherwise -> [x0] : xss'; _ -> [[x0]]) []
07:01:21 <lambdabot>  Defined.
07:01:22 <davean> You COULD do that
07:01:28 <davean> but it seems rather against what it claims to do
07:01:42 <Cale> novakboskov: Variables occurring in pattern matches are always bound to the things which are matched, and shadow any outside definition of those variables.
07:01:50 <ertes> > genGroupBy (<=) "abccbcfzdffe"
07:01:53 <lambdabot>  ["abcc","bcfz","dff","e"]
07:01:54 <Cale> novakboskov: However, you can use guards to test for equality
07:01:56 <ertes> shapr: ^
07:02:42 <SpazSlayer> shapr: came for the type system, stayed for the abuse.
07:03:10 <novakboskov> Cale: indeed, it's simple x == d...
07:04:01 <novakboskov> Cale: :D Thanks! I've overthinked it a bit...
07:10:06 <shapr> SpazSlayer: So I take you enjoy the community as well as the type system?
07:10:19 <shapr> ertes: is that equivalent to the definition in utility-ht?
07:12:45 <shapr> Axman6: learned anything nifty recently?
07:13:35 <SpazSlayer> Haha
07:13:36 <SpazSlayer> No.
07:13:47 <SpazSlayer> You guys are assholes! Thanks for asking, you're the first nice one so far!
07:13:53 <ertes> shapr: yes
07:13:57 <SpazSlayer> @ shapr 
07:14:06 <Axman6> classy prism based errors using MonadError. really helped solve an issue I was having where I wanted separate error types thrown by different modules but wanted to be able to unify them
07:14:36 <shapr> Axman6: oh that sounds very cool, is the source online?
07:15:00 <Axman6> SpazSlayer: do you actually have some haskell related disucssions or questions? or are you just going to mope like a moody teenager because we told you your behaviour wasn't appropriate? (and still isn't)
07:15:07 <shapr> SpazSlayer: I have met some nice people in the Haskell community. Are you learning with the "Haskell from first principles book?"
07:15:28 * ertes is not nice
07:15:29 <shapr> Axman6: ah, what happened?
07:15:33 * shapr hugs ertes 
07:15:39 <ertes> awww
07:15:45 <SpazSlayer> Actually studying the type system.
07:16:01 <SpazSlayer> Also see, assholes.
07:16:03 <Axman6> shapr: I pasted some links the other day actually: https://www.reddit.com/r/haskell/comments/5ksagy/what_was_the_topmost_thing_you_learned_about/dbqn12d/
07:16:33 <shapr> SpazSlayer: the rules here are "be nice or get removed from the community"
07:17:09 <SpazSlayer> Those make sense and are what I expected.
07:17:12 <SpazSlayer> *Ahem*
07:17:22 <ertes> and this community is *extremely* patient =)
07:17:40 <Axman6> shapr: the second two links in https://www.reddit.com/r/haskell/comments/5ksagy/what_was_the_topmost_thing_you_learned_about/dbqve25/ are probably the most informative
07:18:34 <Axman6> SpazSlayer: you called someone in here a spaz out of nowhere, and are still using the name you changed to because of that altercation. why do you think people are annoyed?
07:19:19 <SpazSlayer> I genuinely sometimes go by ScavSlayer - it's a Borderlands: Pre-Sequel reference, but I thought that wrong given scav is an actual person here
07:19:34 <Axman6> no one's called the ops on you, no one's told you piss off, we've just said that your behaviour isn't exactly what we expect in here. so quit with the snide remarks and join the discussion instead of complaining. we're here and willing to help
07:19:37 <SpazSlayer> The main "bad guys" are scavs
07:19:59 <SpazSlayer> But I'm open to nick suggestions
07:20:14 <shapr> SpazSlayer: your current nick is fine, but calling other users here names is not okay.
07:20:26 <Axman6> whatever nick you usually go by is fine
07:20:56 <Axman6> ScavSlayer seems perfectly fine to me, I doubt scav would mind, unless actually slain
07:21:55 <ertes> SpazSlayer: i should note: ops are around, and you're still here…  consider that a chance to revisit your notion that it has to be someone else's fault
07:22:09 <shapr> SpazSlayer: so, studying hindley-milner and that kind of thing?
07:22:55 <SpazSlayer> I've taken a great interest in type systems. Ummm.. the book I'm following isn't with me now. It's a hardback book with like a red brick front cover
07:23:00 <SpazSlayer> "classic in the subject" I'm told
07:23:12 <shapr> SpazSlayer: oh, that's Pierce's "Types and Programming Languages"
07:23:15 <shapr> also known as TaPL
07:23:17 <SpazSlayer> Yeah!
07:23:23 <shapr> The sequel is also fun
07:23:31 <shapr> I have both of them, they're heavy.
07:23:41 <SpazSlayer> I've also got "Mitchell's Foundations for programming languages"
07:23:50 <SpazSlayer> There is a sequel?
07:24:20 <Insanity_> @Axman6 thanks for that link, added to favourites and will check some of them out over the weekend 
07:24:20 <lambdabot> Unknown command, try @list
07:24:20 <Axman6> I feel like a bit of a fraud for never really looking into HM directly. I'm sure I have a very good understanding of it but not the precision I could have
07:24:26 <shapr> Yes, once you're done reading TaPL, I suggest ATTaPL
07:24:30 <Axman6> Insanity_: which one?
07:24:35 <shapr> Advanced Topics in Types and Programming Languages
07:24:55 <Insanity_> The reddit link linked to another page
07:25:33 <Axman6> Insanity_: the video is possibly the best introduction.
07:25:57 <Insanity_> Cheers
07:26:13 <Axman6> I would follow those links in reverse order in fact :P
07:26:24 <Athas> Does anyone know of parallel Haskell for computation success stories?
07:26:44 <Axman6> I beliebe shapr does :P
07:26:48 <Axman6> believe*
07:27:04 <shapr> Athas: use parBuffer and you too can get respect from coworkers for solving problems!
07:27:10 <Axman6> (since he was discussing the use of parallel strategies earlier)
07:27:18 <davean> shapr: So, why were your advent solutions slower then python ones?
07:27:30 <davean> shapr: That sort of shocks me
07:27:50 <grazie> question about this: xs@(x:_) <-[[cs | c:cs<-ss, c==a]] ....coming next message 
07:27:56 <shapr> davean: Managing strictness sped up my code dramatically.
07:27:56 <Athas> shapr: sure, there are lot of tools, but I'm looking for stories/examples of people using them.
07:28:08 <Athas> In particular, how they compare performance-wise to corresponding implementations in other languages.
07:28:11 <davean> One of the benefits I derived from Haskell was being able to run servers on live traffic with profiling faster then the python servers ever ran
07:28:27 <grazie> as `xs usually represents tail of list as in (x:xs), what is @xs in @xs(x:_) ?
07:28:43 <shapr> Athas: are there corresponding implementations in other languages? The only one I've heard of is clojure's pmap, and I've heard the overhead is too high to make that worthwhile.
07:29:05 <shapr> Athas: Perhaps I should ask, what other languages have corresponding implementations so I can try them?
07:29:35 <Athas> shapr: no, I mean, implementations of the same *problem* in some other language, and some demonstration of why the Haskell version is better/worse.
07:29:47 <Axman6> yeah I don't believe there are many, if any, other languages with equivalents to the par stuff in Haskell, because basically no other language is lazy and pure, both reatures essential to haskell's parallelism mechanisms
07:29:53 <Athas> Haskell has a giant zoo of parallel primitives, but I can't find many examples of people using them (except for managing IO).
07:30:59 <Axman6> Athas: have you read Simon Marlow's book? I'm pretty sure it talks about some use cases
07:31:03 <shapr> Athas: I switched some calls to map to "parMap rdeepseq" and my program's cpu usage (as shown by "time myprogram) went from ~250% to 758%
07:31:10 <Axman6> but it's true, the parallelism stuff isn't widely used
07:31:30 <shapr> After my recent experience with parMap and friends, everybody should be using those tools!
07:31:49 <shapr> Mind you, it's helps that my laptop has a quad core xeon, but still... use those multicores!
07:31:58 <Athas> Axman6: yes, but I'm looking for production uses, or at least more significant programs.
07:32:23 <Axman6> I usually find that threads tend to be a better way to split my tasks up - I tend to have lots of independant tasks instead of one large computation
07:32:25 <Athas> Especially ones that compare to other languages.  It's no great surprise that parallel Haskell is faster than sequential Haskell, but how does it compare to hand-written parallel C?
07:32:52 <shapr> Athas: oh, I bet hand-written parallel C will always be faster, and STM will always be less work to get right.
07:32:52 <SpazSlayer> Usually unfavourably. 
07:33:10 <MarcelineVQ> grazie: as-pattern http://stackoverflow.com/questions/1153465/what-does-the-symbol-mean-in-reference-to-lists-in-haskell
07:33:15 <shapr> Athas: on the other hand, I can parallel my sequential Haskell code in five minutes.
07:33:17 <Athas> shapr: sure, but how much?  And (probably more interesting), what about compared to other high-level parallel frameworks/languages?
07:33:17 <SpazSlayer> Haskell only usually beats C/C++/Fortran implementations when there's some optimiser the compiler cannot show is safe, or the human has done something daft.
07:33:23 <Athas> These are questions I wonder if there are answers for.
07:33:25 <SpazSlayer> With LTO this is getting rarer and rarer.
07:33:44 <davean> shapr: my problem with par stuff is that I usually don't hold large amounts of computational structure in memory
07:34:04 <davean> shapr: the only time I deal with stuff worth parallelizing involves streaming data in and out of the system
07:34:11 <shapr> davean: so small thunks don't benefit much from parMap et al?
07:34:25 <Axman6> SpazSlayer: there are other things which you can optimise for though, and programmer time is one of the most expensive costs in any organisation developing software
07:34:31 <Athas> You need enough granularity for parallelism to be worthwhile.
07:34:44 <shapr> Axman6: yeah, that's my favorite use case.
07:34:45 <davean> what Athas said
07:34:56 <SpazSlayer> Axman6: one wouldn't run such comparisons unless it was needed
07:34:59 <SpazSlayer> So what's your point?
07:34:59 <Athas> Even functional programming doesn't make parallelism "trivial".  Well, it does, as long as you don't care about performance.
07:35:04 <davean> shapr: https://en.wikipedia.org/wiki/Amdahl's_law
07:35:04 <shapr> I'd be here all year if I had to write a hand-optimized parallel C equivalent to my Haskell code.
07:35:10 <shapr> SpazSlayer: be nice
07:35:19 <ertes> shapr: GHC-haskell can beat C…  i've encountered a few examples of that in the past
07:35:20 <SpazSlayer> No I'm serious.
07:35:26 <SpazSlayer> What's he getting at?
07:35:40 <Axman6> my point is that absolute program speed is often actually not very important
07:35:44 <SpazSlayer> Programmers spend time making stuff fast all the time
07:35:45 <Athas> ertes: for computation, or for IO/event-driven tasks?  For the latter, yes, Haskell demonstrably shines.
07:35:54 <shapr> SpazSlayer: I think he's saying the same thing I just said, hand-optimizing parallel C code takes more human time than using parMap
07:35:57 <SpazSlayer> You guys were talking about RDBMSs earlier.
07:35:59 <ertes> Athas: the former
07:36:09 <Athas> ertes: cool, what algorithms were these?
07:36:10 <davean> shapr: So I usually get more for parallizing the IO portion then the pure portion
07:36:11 * SpazSlayer coughs OpenMP
07:36:12 <Axman6> I've written my fair share of highly parallel (openMP and MPI based) C code in my time. I know where I'd rather be soending my time
07:36:14 <SpazSlayer> All hail Cray.
07:36:22 <Athas> ertes: did you use the vector library?
07:36:28 <davean> shapr: esp when one factors in lower GC overhead of streaming and retaining only small datasets
07:36:31 <Axman6> getting OpenMP right is easier said than done
07:36:34 <ertes> Athas: mostly array stuff and using -fllvm
07:36:42 <ertes> Athas: yes, vector
07:36:44 <Axman6> and MPI even more so
07:36:56 <davean> shapr: parallel is amazing when one has the correct workloads! They just seem to be more rare then people expect
07:36:57 <Athas> ertes: ah, yeah, vector is really damn good within its niche.
07:37:00 <SpazSlayer> Axman6: read the spec once. It takes time but afterwards you gain a clarity.... because you understand the "why it is the way it is" rather than "do this"
07:37:07 <shapr> SpazSlayer: As Axman6 just said, the human time cost for OpenMP is higher than the human time cost for parMap et al
07:37:26 <ertes> Athas: here is one example i've published: http://lpaste.net/101980
07:37:29 <davean> SpazSlayer: Which spec do you mean?
07:37:33 <Axman6> shapr: did you miss the part where I said I have written a fair amount of code using both OpenMP and MPI?
07:37:35 <SpazSlayer> This isn't going to be a productive convo.
07:37:37 <Axman6> uh, SpazSlayer
07:37:50 <Athas> In my search so far, Repa seems like the most general, powerful and efficient Haskell solution to HPC.  But it's hard to find good performance comparisons, and it seems little used in practise.
07:37:57 <davean> Axman6: I'm sure shapr read it
07:37:59 <Athas> Whereas vector is widely used, but much more limited.
07:38:02 <Axman6> I understand OpenMP quite well (or did a few years ago, it hasn't been relevant for a while for me)
07:38:11 <grazie> MarcelineVQ- in the snippet I pasted i.e.  @xs(x:_) will @xs actually be x? because the tail is ignored i.e. _? 
07:38:13 <ertes> Athas: the equivalent C code does exactly the same thing, so i'm not entirely sure why the haskell version beats it…  my explanation is that GHC/STG's "calling" convention is more efficient
07:38:18 <davean> Axman6: of all shapr's numerous faults, failing to read #haskell is not one of them
07:38:23 <shapr> ha
07:38:37 <Axman6> ha!
07:38:44 <ertes> Athas: for example when you use "f(); g();" in C, f returns, then g is called…  in a haskell equivalent it's more likely that f jumps to g directly
07:38:49 <Axman6> yeah, damn that overly happy shapr
07:39:12 <shapr> SpazSlayer: From the way you say things, it sounds like you're convinced you know more than the other people in these conversations. That doesn't lead to productive conversations.
07:39:13 <Athas> ertes: maybe more aggressive inlining by GHC?
07:39:26 <ertes> Athas: yeah, although that didn't seem relevant
07:39:42 <Athas> It might help the LLVL optimiser.
07:39:44 <davean> This is an amuzing place to assume one knows more then the other participants
07:39:57 <ertes> Athas: yeah, but on the C side everything is inline anyway
07:40:02 <Axman6> yeah, that's a lesson I learned mant years ago
07:40:12 <Axman6> many*
07:40:15 <ertes> Athas: and yes, this code even beats C compiled with clang
07:40:16 <Athas> Okay, that's weird.
07:40:24 <Axman6> ertes: which code?
07:40:30 <ertes> Axman6: http://lpaste.net/101980
07:40:42 <ertes> there is a link to the C version in the comments
07:40:57 <davean> Beating C code performance isn't really all that hard, C has a lot of built-in overhead due to how much fails to allow the compiler to understand 
07:40:59 <Athas> ertes: it's a very sequential piece of code, though.  I'm mostly looking for examples of parallelism.
07:41:10 <ph88> Athas, what's the LLVL optimizer ?
07:41:19 <Athas> ph88: LLVM's mistyped cousin.
07:41:20 <davean> Looking at the C standard is rather enlightening as to how to beat C code performance
07:41:23 <Cale> Athas: The thing about comparing some haskell code that someone has splashed some par annotations into and hand-written parallel C code, is that you're comparing something which was often fairly easy to do with something that probably required a bunch of headache pills.
07:41:32 <ertes> davean: yeah, that's my reasoning as well
07:41:55 <ertes> davean: but it doesn't apply here…  the C version is one single loop that should be easy to optimise
07:42:00 <SpazSlayer> shapr: there are two things behind that, you've got the "everyone on the internet is an expert" but none really are. So empirically it's probably true. Then you have the "it's not arrogance if you're right" part. I know I'm right
07:42:04 <davean> ertes: I was talking in general
07:42:08 <Athas> Cale: I'm not saying that there is no point to using Haskell for HPC-like tasks.  I think there are many reasons for doing that.  I'm just looking for examples of doing so.
07:42:25 <Insanity_> ertes: in that code you wrote something akin to " let n = 100000 !maxN =  n - 1" 
07:42:25 <davean> ertes: Mostly a musing because people compare performance to C and are dumbdfounded when you beat it
07:42:34 <shapr> SpazSlayer: if you already know you're right, I don't think you'll learn much here
07:42:34 <Insanity_> Is that a way to define more than one variable or something?
07:42:38 <davean> ertes: which frankly, I can look at almost any C code and make a version thats faster then C
07:42:44 <Athas> Hell, I do functional HPC for my PhD, so clearly I must think this field has potential.  Since Haskell is by far the best (and probably most popular) functional language, and has a ton of parallel primitives, I'm just looking for some experience reports, or just examples.
07:42:46 <ertes> Insanity_: you mean the "!"?
07:42:51 <Insanity_> yeah on the newline
07:42:52 <SpazSlayer> shapr: I know the areas I don't know, and yes, I have nothing to learn in this area.
07:42:59 <Axman6> shelling__: that attitude won;t server you well in life. 
07:43:01 <SpazSlayer> Compiler design and optimisation (GCC) my areas
07:43:14 <ertes> Insanity_: it's just a bang-pattern that makes sure that maxN is evaluated before the loop runs, which gives GHC a few more opporunities for unboxing
07:43:15 <davean> Simply because I know what the author meant while the compiler has to assume they cared about the things the C standard said would happen when that was never the author's intent
07:43:30 <Axman6> cleh, why is glirc's tab completion failing me >_<
07:43:40 <Insanity_> Oh cheers, had not encountered that before :-)
07:43:56 <glguy> Axman6: Let me know if you figure out what went wrong
07:44:16 <ertes> Insanity_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#bang-patterns-informal
07:44:22 <Insanity_> Thanks!
07:44:25 <davean> And yet C produces "good" performance for many people's tasks. An interesting demonstration that performance really isn't very relivent in many cases
07:45:05 <Axman6> SpazSlayer: I topped my HPC class at uni and have worked for scientific institutions on various supercomputers. I'm by no means an expert but I know my stuff. yes you can always write faster C code, but that;s not the be all and end all
07:45:22 <shapr> SpazSlayer: well, try to be nice and considerate to people on this channel, I'd rather not ban you.
07:45:52 <SpazSlayer> Axman6: no offence, but it's the internet.
07:46:09 <SpazSlayer> I've met many "programmers" with "greater" "credentials"
07:46:29 <davean> I should explain that a bit more - people consider performance important but their notion of performance is subjectively aquired
07:46:38 <Axman6> SpazSlayer: there much more to compiler design and optimisation than what you'll find in gcc. there's a whole world of optimisations available to GHC that aren't available to the likes of GCC or LLVM
07:46:42 <SpazSlayer> Unless you've got links to REPRODUCABLE experiments, or actual research
07:46:47 <SpazSlayer> I'm just gonna have to nod
07:47:03 <nitri-xmas> SpazSlayer: You might want to move this discussion to #haskell-offtopic or ##programming.
07:47:05 <davean> if you increase overall performance by changing the shape of performance, the mear act of moving performance around upsets people
07:47:25 <davean> Its a disruption of expectations, not an actual decrease in utility people react to
07:48:18 <ertes> oh, to anyone interested in performance who hasn't seen it yet, this talk by chandler carruth i'd almost call a must-watch: https://www.youtube.com/watch?v=fHNmRkzxHWs
07:48:20 <Axman6> SpazSlayer: you're complaining about "Experts" while pretending to be one yourself. you're surrounded by many extremely smart people, an air of humility would serve you well than one of condescension which you have been
07:48:24 <Athas> Axman6: on the other hand, GHC also has to work harder to remove the overhead of abstraction (unboxing and such).
07:48:36 <Axman6> Athas: indeed
07:48:54 <Axman6> ertes: yeah Chandler does some great talks
07:49:05 <SpazSlayer> Axman6: when someone answers a question on a forum, or IRC, or on a mailing list, they usually give a solution which makes sense or actually fixes the problem, so you can be like "yeah that guy knows this stuff" - because you've had a token of that knowledge
07:49:24 <nitri-xmas> SpazSlayer: Tune it down.
07:49:25 <SpazSlayer> That's not applicable here, it's just your word, now I'm not calling you a liar, honest, you may well, but the number of "experts" I've met...
07:49:36 <Athas> In practice, I don't see much Haskell HPC code.  When Haskell goes really fast, it's usually by writing C-in-Haskell with lots of side effects.  Repa is a (good) exception.  Accelerate is another.
07:49:39 <shapr> Axman6, SpazSlayer: take it to #haskell-offtopic ?
07:49:52 <SpazSlayer> I was just replying, I'll leave it now.
07:50:02 <SpazSlayer> Not trying to offend. 
07:50:09 <Axman6> urgh, you're the one claiming to be an expert here! I'm just demonstrating that actually I"m not as clueless as you seem to think. I'm done
07:50:25 <SpazSlayer> Last word.
07:50:29 <SpazSlayer> :P
07:50:35 --- mode: ChanServ set +o shapr
07:50:38 <shapr> SpazSlayer: be nice
07:50:45 <nitri-xmas> shapr: Just do it.
07:50:48 <davean> shapr: Take off the hat, you look better without it
07:51:01 <ertes> SpazSlayer: the thing that offends people is that you make everything personal…  you always attribute/compare people…  stop that and you'll find it much easier to communicate
07:51:02 <nitri-xmas> SpazSlayer: You're sticking out like a sore thumb. I suggest you observe the kind of collaboration and constructive discussions that we have here as a point of reference.
07:51:15 <Axman6> glguy: yeah, I'm not 100% convinced it wasn't just me fat fingering it, I tend to do that at 2AM. what algorithm does glirc use to chose which nick to complete?
07:51:48 * davean demands most-recently-spoken as his completion order
07:51:51 <ertes> we're talking about science/technology here, not people…  technology doesn't mind being compared =)
07:51:53 <glguy> Axman6: It first matches the prefix you've tab completed with the most recent speaker
07:52:03 <glguy> and then goes alphabetical from there
07:52:16 <Axman6> yeah that's what I thought
07:52:18 <SpazSlayer> ertes: in comparisons though, you should have a reproducible result.
07:52:50 <ertes> SpazSlayer: "how can i reproduce your result?"
07:53:02 <SpazSlayer> I don't have a result I'm claiming here
07:53:04 <drdo> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
07:53:13 <SpazSlayer> Otherwise I'd link you to my wiki full of tests, with dates, graphs and versions :P
07:53:19 <drdo> I don't understand the problem with that example? Where is the ambiguity?
07:53:34 <shapr> SpazSlayer: ertes is suggesting that you take the same approach that you just suggested
07:53:47 <shapr> SpazSlayer: if you give someone else the benefit of the doubt and ask them for more detail, you may learn something
07:54:16 <ertes> SpazSlayer: note the quotes
07:54:31 <SpazSlayer> I didn't have a claim though
07:54:48 * shapr sighs
07:54:59 <SpazSlayer> Are we on the same topic here.
07:55:10 <SpazSlayer> It doesn't matter that much
07:55:19 <davean> Yah, you're on the same topic SpazSlayer, you're just failing to grasp what people are saying
07:55:38 <davean> and I'm a little in the dark as to why you're missing it
07:55:39 <SpazSlayer> The topic of what Axman6 said about past experience and openmp?
07:55:53 <SpazSlayer> Because I didn't make a claim
07:55:57 <pringlescan> How many Haskell programmers does it take to kill a troll?
07:56:06 <SpazSlayer> I'm not trolling!
07:56:13 <davean> pringlescan: Haskell programmers can't kill trolls, they're too pure to take action
07:56:35 <Axman6> pringlescan: it's hard when they troll themselves too
07:56:53 <SpazSlayer> Har har
07:57:07 <jmnoz> any chance I can get someone versed in Lens/taggy-lens to show me how to do a) replace b) remove of a node  http://lpaste.net/350663 ?
07:57:22 <Insanity_> On the topic of trolling here: https://gist.github.com/quchen/5280339#file-trolling_haskell
07:57:35 <glguy> Oh no, not that paste again
07:57:39 <glguy> Do not post that here
07:57:42 <Axman6> drdo: yeah I can't see the issue either, not how the solution fixes it
07:58:45 <Axman6> nor*
07:58:51 * Axman6 -> bed
07:59:01 <purelazy> nn
07:59:07 <dmj`> davean: or too lazy :) 
07:59:24 <davean> dmj`: Oh, I'd say this is being forced
07:59:30 <ph88> https://gist.github.com/quchen/5280339#gistcomment-1340860
08:00:07 <purelazy> For the first time I came across a function where the type signature came *after* the definition
08:00:14 <purelazy> c'GL_FALSE = 0
08:00:15 <purelazy> c'GL_FALSE :: (Num a) => a
08:00:55 <purelazy> Is that a new trend? Does it have any benefit?
08:01:08 <purelazy> Just curious
08:01:15 <glguy> It's not a trend that I'm aware of.
08:01:30 <glguy> You can do other things too, like interleave type signatures and definitions
08:01:32 <davean> purelazy: I've only done that when I was in a rush and didn't decide how it would be shapped untill I'd writen it
08:01:55 <purelazy> See http://hackage.haskell.org/package/bindings-GLFW-3.1.2.2/docs/src/Bindings-GLFW.html
08:02:02 <ertes> SpazSlayer: i mean: if someone presents a result you think is not reproducible, the worst idea is to get personal ("you did not provide a reproducible result"), and the best idea is to ask: "how can i reproduce your result?"
08:02:13 <ertes> SpazSlayer: i.e. what shapr said
08:02:25 <glguy> purelazy: It's useful to have that flexibility when you're trying to convey a relationship between two definitions or type signatures
08:02:46 <SpazSlayer> ertes: please stop
08:02:55 <SpazSlayer> The guy it involved has stoped, so I think we can too
08:03:05 <ertes> SpazSlayer: alright
08:03:30 <glguy> purelazy: for example you can have: x :: Int; y :: Int; x = 1; y = 1
08:03:40 <glguy> or even x , y :: Int; x = 1; y = 1
08:04:12 <glguy> `x,y::Int; (x,y) = (1,2)
08:05:07 <sm> wow. choppy in here this morning
08:05:28 <sm> shapr! thanks for the advent of code discussion, that was pretty interesting
08:06:21 --- mode: shapr set +q SpazSlayer!*@*
08:08:28 <shapr> sm: and more happening soon, hopefully
08:08:46 <purelazy> glguy, davean: The reason you give don't seem to apply in the case I mention - but no big deal
08:09:02 <davean> purelazy: no, but it was the most I had on the situation
08:09:17 <davean> purelazy: you didn't seem to be asking about that specific definition but the gneeral form
08:09:23 <glguy> purelazy: I started my messages with "no, it's not a trend" the rest was just talking about how there's even more flexibility than that
08:09:27 <davean> purelazy: if you meant only that specific situation I missunderstood
08:10:48 <purelazy> davean, glguy: I just saying, I'm none the wiser. I appreciate your answers of course
08:11:02 <purelazy> They make sense 
08:13:18 <davean> purelazy: personally I'm against the style in any longterm codebase
08:13:50 <davean> I consider it an important maintance task to move the definition up if the code gets retained
08:13:55 <purelazy> davean: It's just kinda weird
08:14:05 <davean> purelazy: its kinda annoying for the reader
08:14:23 <davean> purelazy: irrelivent in your example due to its short length mind you
08:14:25 <purelazy> that too
08:14:41 <alx741> hello everyone. I'm trying to run Hspec tests (with automatic dicovery) using `stack test`  but i'm getting:     The IO action ‘main’ is not defined in module ‘Main’
08:14:59 <alx741> why is that?
08:15:05 <purelazy> davean: Maintainers are Schell Scivally <efsubenovex@gmail.com>, Brian Lewis <brian@lorf.org>, Javier Jaramago <jaramago.fernandez.javier@gmail.com>
08:15:35 <alx741> my Spec.hs file have of course the line "{-# OPTIONS_GHC -F -pgmF hspec-discover #-}"
08:15:37 <purelazy> They know who they are!
08:16:21 <Tuplanolla> Oh, I missed a hpc discussion.
08:16:49 <alx741> never mind, I had it commented out
08:16:56 * alx741 runs away
08:17:44 <dmj`> alx741: are you importing the Spec.hs file’s module into Main.hs and calling main :: IO () = hspec Spec.spec
08:18:38 <shapr> Athas: will the results of your investigation be online somewhere? (I mean, before you finish your PhD!)
08:18:50 <shapr> Athas: I'd like to know what other high level parallel frameworks exist.
08:18:58 <alx741> dmj`: I have, I just had the preprocessor line commented out, I'm an idiot, but thanks!
08:19:19 <Athas> shapr: probably not in some publishable form.  I'm just looking for points of reference.
08:19:30 <shapr> maybe a blog post?
08:19:36 <shapr> I just want to know.
08:19:48 <Athas> But I guess someone ought to write something like that eventually.  There's a large amount of work in the imperative world that hasn't really penetrated to the FP community.
08:19:57 <Athas> Yeah, maybe a series of blog posts eventually.
08:20:01 <Tuplanolla> I've tried molecular dynamics and quantum Monte Carlo with Haskell, Athas.
08:20:11 <Athas> Tuplanolla: and did you have a good time?
08:20:30 <Tuplanolla> Yes. No.
08:20:52 <Tuplanolla> It was interesting, but the results took more effort than I was satisfied with.
08:21:08 <Athas> Did it at least run fast?
08:21:19 <Tuplanolla> It did eventually.
08:21:35 <Tuplanolla> I have two and a half draft reports written up that I'll have to publish eventually.
08:22:16 <Athas> Did you compare your implementation to others?
08:22:33 <Tuplanolla> Not rigorously.
08:24:20 <shapr> Tuplanolla: are your sources online?
08:24:37 <Tuplanolla> I did turn one of the attempts into a lecture, which is, shapr.
08:25:04 <shapr> Tuplanolla: ooh, link?
08:26:24 <Tuplanolla> Here's the source code: https://github.com/Tuplanolla/ties341-profiling
08:26:24 <Tuplanolla> Here's the literate file compiled: http://tuplanolla.no-ip.org/tmp/VMCE.hs
08:26:40 <Tuplanolla> Alas I seem to have lost the lecture video itself.
08:26:53 <shapr> Is your lecture in Finnish? I'm fine with English or Swedish.
08:27:06 --- mode: shapr set -o shapr
08:27:07 <Tuplanolla> Let's try the second link again: http://tuplanolla.no-ip.org/tmp/VMCE.pdf
08:27:52 <shapr> I tried to learn Finnish for two years, I gave up.
08:28:01 <Tuplanolla> Good choice, shapr.
08:30:36 <Tuplanolla> The other things I built with Repa, Athas.
08:35:25 <lambdafan> I'm looking for a version of <$> with the arguments reversed
08:35:47 <lambdafan> I couldn't find it in either Control.Monad or Control.Applicative
08:35:52 <lambdafan> does it exist?
08:36:32 <Tuplanolla> @hoogle (<&>)
08:36:35 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
08:36:35 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
08:36:35 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
08:36:42 <Tuplanolla> There it is, lambdafan.
08:36:54 <lambdafan> nice
08:36:57 <lambdafan> thanks
08:38:18 <shapr> Tuplanolla: is Repa more trouble than Control.Parallel?
08:38:35 <Tuplanolla> That's a strange question.
08:39:52 <Athas> shapr: Repa is very different.  It is for fine grain data parallelism.
08:40:07 <Athas> It also does not support nested parallelism, IIRC.
08:40:19 <Tuplanolla> Indeed it does not.
08:41:07 <Athas> Repa is like programming in a functional array language, where Control.Parallel is more task-oriented.
08:45:16 <Tuplanolla> Do you happen to know the Haskell equivalent to `feenableexcept`, Athas?
08:45:50 <Athas> Tuplanolla: nope, sorry.
08:46:51 <Tuplanolla> That's one of my hpc pain points, along with poor support for modular floating-point arithmetic and really long compilation times with the LLVM backend.
08:55:14 <davean> Tuplanolla: aren't there issues with those and threads?
08:55:44 <davean> I mean, theres https://hackage.haskell.org/package/ieee-utils-tempfix but I think it wouldn't work
08:56:14 <Athas> Yeah, personally I find IEEE state to be a terrible thing.
08:56:27 <davean> I don't really like signalling
08:56:29 <Tuplanolla> Terrible is accurate.
08:56:31 <davean> there are some good solutions to rounding at lest
08:57:54 <Tuplanolla> Personally I'd prefer floating-point numbers to behave more like analog signals, but we don't have anything like that.
08:58:02 <davean> Tuplanolla: I'd want to review the RTS and see if it preserves those registers
08:58:21 <davean> Tuplanolla: what do you care about signaling exceptions foor?
08:59:01 <Tuplanolla> It's occasionally useful for finding where nans and infinities come from, among other debugging work.
09:00:26 <mettekou> Does Haddock support documentation for pattern synonym declarations?
09:20:48 <orion> If my Haskell application is slow because of L1 and L2 cache misses, how would I discover that?
09:21:47 <t7> can you discover something after you already thought of it?
09:24:50 <bennofs> orion: perhaps with `perf` on linux?
09:53:19 <n00b101> I'm trying to understand how Haskell or similar languages using  Hindley-Milner Type Inference can be statically compiled. Type Inference gives us the "most general types" for a function, which it seems can often be "any" type. For example, the identify function is just T -> T where T can be anything. But it would seem that such a language cannot then be staticlaly compiled to machine code? For example, if I need to
09:53:19 <n00b101>  return a 32-bit  integer, the compiler needs to know that ahead of time in order to generete the most efficeint machine code?
09:53:29 <ysangkok> how do you even know that your application is vulnerable to L1/L2 cache misses but not L3?
09:54:16 <t7> n00b101: either the compiler generates a new function for each type you use it with or you pass around a void* instead 
09:55:29 <n00b101> t7: the first solution sounds a lot like C++ template instantiation. does haskell have some kind of type annotation to let it know what types will be used? 
09:57:14 <n00b101> or i guess it could be a JIT compiler
09:57:19 <ysangkok> n00b101: surely there must be a way of inferring primitive types in GHC, but that does not need to be exposed in the haskell standard
09:57:33 <ertes> n00b101: GHC uses boxing
09:57:40 <n00b101> oh ok
09:57:58 <ertes> n00b101: fully polymorphic functions don't make any assumptions on the value in the box, so they can't do anything with it other than pass it around
09:58:20 <ertes> n00b101: however, type classes can be (and are often) specialised to specific types
09:59:45 <Demon_Fox> Does Haskell have templates?
09:59:54 <glguy> Somewhat related to that I was playing with some representation polymorphic functions to help making working with unboxed Int's easier rather than passing around boxed things
09:59:58 <ertes> Demon_Fox: what kind of templates?
10:00:11 <glguy> https://github.com/glguy/advent2016/blob/master/lib/UnboxFunctions.hs used in https://github.com/glguy/advent2016/blob/master/Day16-functions.hs
10:00:21 <c_wraith> Demon_Fox, haskell has parametric polymorphism by default, which is one of the main uses of templates. 
10:00:40 <c_wraith> Demon_Fox, other uses have analogues as well. 
10:00:52 <Demon_Fox> Thanks c_wraith 
10:01:21 <ertes> n00b101: if you want to learn more, the search term is "parametricity"…  compiling fully polymorphic functions works because of parametricity
10:02:21 <Demon_Fox> Thanks also ertes
10:03:39 <n00b101> ertes: thanks! 
10:05:38 <n00b101> i need to run these functions on GPUs which involves static compilation to CUDA/PTX. i dont know if boxing would be a good idea there
10:06:00 <ertes> glguy: did that make a non-negligible difference?
10:06:43 <ertes> n00b101: you could use 'accelerate', which compiles a haskell EDSL to GPU code (CUDA is supported)
10:07:04 <ertes> n00b101: boxes exist in haskell land…  the GPU code is unboxed
10:08:02 <n00b101> interesting! i wonder if the library accomplishes this through JIT compilation. that would certainly work
10:08:08 <romano> hi guys!
10:08:09 <glguy> ertes: yes
10:08:24 <ertes> n00b101: the library is a compiler, except the source code is not text, but a haskell EDSL
10:08:44 <ertes> n00b101: in other words: you write haskell code and apply a function to it to send the resulting GPU code to the GPU
10:09:05 <ertes> n00b101: (it's a common design in haskell)
10:09:09 <n00b101> ertes: thanks again
10:09:14 <romano> is there any practical difference between mapConcurrently (from async) and parMap (from monad-par)? 
10:09:17 <n00b101> i'll check it out
10:09:33 <ertes> romano: yes, mapConcurrently can do I/O
10:10:31 <glguy> ertes: It reduces the runtime to 75% of the original
10:10:53 <ertes> glguy: interesting…  i've tried to speed things up by unboxing in the past, but it never made a difference for me
10:11:11 <glguy> ertes: That's typically because GHC does it for your in the optimization pass
10:11:11 <romano> ertes, awesome. thanks. at the moment i'm using both but was thinking i could switch to one (mapConcurrently)
10:11:26 <glguy> ertes: In this case GHC won't unbox the argument to one of its arguments
10:11:35 <ertes> glguy: i see
10:12:00 <ertes> romano: async isn't really a parallelism abstraction though…  if you can use monad-par, you should
10:12:25 <ertes> romano: mapConcurrently is mostly for doing things concurrently like fetching a number of files via the network
10:13:24 <romano> ertes, ok. got it. i guess monad-par being pure should not throw so that's advantageous
10:14:11 <ertes> romano: well, evaluation can throw, so monad-par can throw, too
10:15:20 <ertes> romano: it's just a consequence of having 'error', a deadlock-detecting RTS, async exceptions, etc.
10:16:35 <romano> ertes, head can throw too :) 
10:18:00 <romano> ertes, anyway. thanks for the tip. i will stick with both abstractions for now
10:18:52 <ertes> romano: you can't apply strategies to your problem?
10:22:13 <romano> ertes, i haven't looked at strategies yet but will have a look. 
10:22:45 <ertes> romano: chapters 2 and 3 explain it very well: http://chimera.labs.oreilly.com/books/1230000000929
10:35:30 <danielszmulewicz> Hello everybody, Haskell outsider here (but learning). I have a question about tooling in Emacs. Is there any consensus as to which Emacs setup is the most effective. I see there are several interactive modes. Which should I use?
10:35:36 <Demon_Fox> Anyone know of a good reference for Haskell and some short tutorials?
10:38:24 <Tuplanolla> @google "haskell cheat sheet"
10:38:25 <lambdabot> http://cheatsheet.codeslower.com/
10:38:25 <lambdabot> Title: The Haskell Cheatsheet
10:38:57 <Tuplanolla> Try that one, Demon_Fox.
10:39:28 <Demon_Fox> I am
10:45:40 <danielszmulewicz> Is Structured Haskell Mode worth installing in Emacs?
10:46:48 <srhb> danielszmulewicz: Which Emacs mode you prefer depends on which way you use Haskell
10:46:55 <srhb> danielszmulewicz: For instance, Stack users might prefer intero
10:47:07 <srhb> Though I guess shm is pretty orthogonal to the "main" haskell modes and is mostly an "editing" mode.
10:47:26 <srhb> (ie. afair it doesn't provide any integrations with ghc/ghci/cabal/stack, just buffer editing stuff)
10:48:01 <danielszmulewicz> srhb: Thanks. That was useful. Do you use it? Do you find it useful?
10:48:28 <srhb> danielszmulewicz: I don't. I use Haskell in a way that's sadly incompatible with intero, at least last I checked. I use haskell-mode.
10:48:40 <srhb> shm doesn't really interest me. I tried it once, it was not the way I like editing things.
10:49:05 <danielszmulewicz> srhb: Aha. Very interesting. Are you a longtime Haskeller? 
10:49:24 <srhb> danielszmulewicz: A few years on and off. hobbyist (sadly) :-)
10:50:18 <Demon_Fox> Thanks Tuplanolla
10:50:57 <srhb> danielszmulewicz: If you're just getting started, know that having an editor mode is not mandatory at all.
10:50:58 <danielszmulewicz> srhb: So are you saying that Haskell mode is incompatible with intero and that it is a sad thing? I'm trying to understand the stack/cabal schism. Is this a big deal?
10:51:20 <srhb> danielszmulewicz: I would imagine those two are incompatible, yes, because they essentially try to interface with ghc in two different ways.
10:51:46 <srhb> danielszmulewicz: I don't think it's a sad thing. It's a mild annoyance currently that I imagine will end up bringing us all to a better place in time. Things move really fast in the Haskell ecosystem. :)
10:52:19 <danielszmulewicz> srhb: I am studying Haskell features interactively. I am also a Emacs power user. My main concern is to have the best interactive mode for Haskell. 
10:52:37 <srhb> danielszmulewicz: Then my best advice is to try them all out. As an Emacs power user, that should not be difficult for you. :)
10:53:02 <danielszmulewicz> srhb: Excellent idea. I have installed cabal. Can I install stack side by side?
10:53:14 <srhb> danielszmulewicz: Yes, absolutely.
10:53:45 <danielszmulewicz> Excellent. Is there a consensus about cabal/stack? Are they competing environment or is one going to supersede the other?
10:54:33 <srhb> danielszmulewicz: There is no consensus. Stack is really popular right now, I would say. I don't like it personally. :-)
10:55:38 <danielszmulewicz> srhb: Aha. But you seem to deem intero desirable, am I wrong?
10:55:51 <srhb> danielszmulewicz: No, you are right. I suffer from intero jealousy. :-)
10:57:23 <danielszmulewicz> srhb: Well that is meaningful. intero advertises itself as the interactive development for Haskell. That is a big claim. I better check it out then.
10:58:04 <srhb> danielszmulewicz: Definitely. :) Hope you enjoy it.
10:59:19 <srhb> danielszmulewicz: Guests have arrived. Have fun!
10:59:40 <danielszmulewicz> srhb: Thanks a lot. And a wonderful evening to you.
11:00:12 <chris___> I'm trying to get stack to use a custom-built ghc executable but it keeps saying "No compiler found, expected minor version match with ghc-8.0.1 (x86_64)", it's in my path and I've tried symlinking ghc and ghc-8.0.1 in /bin and /usr/bin to no avail. Could anyone point me towards the stack code that handles looking for a ghc path or what I might be missing to get it to use mine?
11:06:57 <MarcelineVQ> chris___: check out https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-variant and setup-info beneath it or --ghc-bindist, I haven't gone through the whole process but ideally you should be able to build a bindist of the ghc you want to use and point to it with these options
11:08:09 <MarcelineVQ> I'm not sure if the `make binary-dist` option ghc source comes with is quite what stack wants since I've not gone though it, good places to check though
11:20:02 <hackrilege> Could anyone discuss lpaste.net/350663 with me?
11:20:58 <hackrilege> Sorry, lpaste.net/350633
11:22:14 <hackrilege> I fixed the errors I was getting yesterday by adding the 'context' to retain the traversed direction. Neat huh?
11:26:10 <hackrilege> Has anyone seen this approach before? Or any conventional names I should be using?
11:27:45 <hackrilege> :( I'll check back in later
11:28:32 <Steve__> Hi all - Am I missing something, or is there a way to do multiple type aliases at once? a la -> type ball | bat = toy
11:29:21 <lyxia> Steve__: type ball = boy ; type bat = boy is the shortest it gets
11:29:36 <Steve__> ah ok. I thought i just might be missing something. Thank you! :)
11:29:53 <monochrom> Also some of those names ought to be capital case.
11:30:16 <dmj`> Steve__: that would be nice to add
11:30:58 <monochrom> But if you have some name different "type names" referring to the same type, you have an abstraction leak.
11:31:14 <monochrom> s/some name/so many/
11:43:17 <hashme> guys ghc-mod can be installed through the apt package right, you don't really need cabal for it? ( On Ubuntu 14.04 )
11:43:29 <hashme> guys ghc-mod can be installed through the apt package right, you don't really need cabal for it? ( On Ubuntu 14.04 )
11:43:57 <hashme> sorry for the repeat, by mistake
11:45:40 <wilornel> Hey #haskell! So I got warp to work!
11:45:41 <geekosaur> hashme, ubuntu's will likely be fairly out of date and will also only work with ubuntu's ghc (you need to build ghc-mod separately for each ghc you will use it with)
11:46:00 <wilornel> Now, I was wondering, how would I serve an .html file instead of serving a hard-coded html string?
11:46:26 <wilornel> My guess is there should be a function for this. Would I use something that is provided by Haskell, by warp, or some other library?
11:47:28 <hashme> geekosaur, yeah I was thinking the same - it was failing on travis which had Ubuntu 14.04 image and i was using apt package
11:47:44 <hashme> Do you recommend cabal anyway?
11:48:32 <hashme> geekosaur, and what do I do to get cabal on ci? and then use it to install ghc-mod? is there a link probably?
11:48:33 <EvanR> wilornel: going throgh the docs for warp, having never used it... i see getFileInfo, thats a start
11:49:27 <wilornel> I think this would be useful for showing an index of a directory the way apache does 
11:49:34 <wilornel> There is this: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:readFile
11:50:03 <geekosaur> hashme, I don't know as I don't usually deal with ci systems directly
11:50:05 <quchen> hashme: It is important that GHC-Mod is built with the same GHC as the one you’re using for your project, so I recommend compiling it yourself
11:50:35 <EvanR> wilornel: it looks like warp has a file cache if so youd want to exploit that, not manage readFile strings yourself
11:50:39 <quchen> hashme: hvr has a Travis config for dealing with CI shenanigans, multi-ghc-travis it’s called I think
11:51:00 <quchen> hashme: It basically adds his PPA, which supplies Cabals and GHCs
11:51:04 <wilornel> EvanR: It has a cache of the file information I think
11:51:15 <geekosaur> thatnks, I was trying to remember hvr's stuff
11:51:32 <wilornel> "not manage readFile strings yourself" -> That's why I don't want to use readFile and use something that is optimized
11:51:36 <wilornel> Why doens't warp have this?
11:51:42 <EvanR> wilornel: alright. so look at the responseFile function in wai
11:51:45 <quchen> hvr: Speaking of hvr, I’m on the bus to Vienna right now :-D
11:51:47 <wilornel> Should I use a different web framework?
11:51:54 <hashme> quchen, thanks i'll look into it
11:51:58 <geekosaur> wilornel, warp is very low level, look at wai
11:52:06 <quchen> hashme: Found the link, https://github.com/hvr/multi-ghc-travis
11:52:08 <hashme> geekosaur: i'll keep that in mind
11:52:15 <wilornel> Thank you!
11:52:45 <geekosaur> warp just provides a minimal server, all the intelligence is in the application layer and that's where you want to look at wai or something else on top of warp
11:52:53 <geekosaur> (wai, snap, ...)
11:53:13 <EvanR> warp takes a wai Application to run
11:53:23 <EvanR> so i figured it was the other way around
11:53:27 <geekosaur> (note that something like snap sits in warp's application layer, but is itself a framework that has an application layer...)
11:53:42 <hashme> quchen: thanks for the link :
11:53:44 <hashme> :)
11:53:50 <geekosaur> no, it's just Application being used in multiple senses, I think
11:54:11 <wilornel> so wai ~ snap?
11:54:19 <wilornel> wai is similar to snap
11:54:36 <EvanR> warp looks like its built on top of wai
11:54:46 <wilornel> no no warp is very low level
11:54:50 <EvanR> Network.Handler.Wai.Warp
11:54:56 <geekosaur> but wai has an interface to fit on top of warp
11:54:59 <geekosaur> not the other way around
11:55:25 <EvanR> Warp.run :: Port -> Application -> IO ()
11:55:46 <EvanR> Network.Wai.Application
11:56:09 <ertes> wilornel: snap-server is like a combination of wai and warp (i.e. snap does not separate the API (wai) from the implementation (warp))
11:56:33 <ertes> wilornel: but the two projects are unrelated
11:56:35 <MarcelineVQ> chris___: I did some looking into it, here's what came up
11:56:44 <lpaste> MarcelineVQ pasted “chris___: stack with a custom ghc” at http://lpaste.net/350667
11:57:08 <ertes> wilornel: warp doesn't really have a "level" in that sense…  it's an implementation of WAI, which is low-level
11:57:36 <EvanR> ok makes sense
11:58:12 <EvanR> warp is the implementation
11:58:53 <wilornel> I see!
11:59:06 <wilornel> Well, it's still confusing
11:59:07 <EvanR> create a response from a file from responseFile 
11:59:15 <wilornel> so wai is not an implementation, it's a specification
11:59:21 <wilornel> but I can still access some functions of wai
11:59:23 <ertes> wilornel: another note: snap is much higher-level than WAI in that it's a full web application framework, whereas WAI is more like an HTTP framework, on top of which you can build a web framework (example: scotty)
11:59:25 <wilornel> EvanR: It works! :)
11:59:57 <wilornel> ertes: so snap is equivalent to scotty?
12:00:06 <ertes> wilornel: it's on the same level, yeah
12:00:17 <wilornel> cool!
12:00:36 <EvanR> its clear now that levels doesnt really explain these relationships
12:00:45 <wilornel> I'm used to Flask in Python. I think I would be more familiar with scotty, right?
12:01:00 <ertes> wilornel: think of WAI as a specification, warp as an implementation and scotty as an abstraction of WAI
12:01:04 <wilornel> I'm still unclear on how WAI is a specification and not a library
12:01:10 <ertes> wilornel: snap is all of these in one
12:01:22 <wilornel> but I can call things in wai
12:01:25 <wilornel> I can use wai, it's code
12:01:29 <wilornel> not a specification?
12:01:30 <EvanR> specification means something else to me
12:01:31 <ertes> wilornel: the same way Monad is a specification
12:01:36 <EvanR> interface please
12:01:41 <wilornel> Ah!
12:01:58 <wilornel> How can snap be all in one
12:02:21 <EvanR> and abstraction doesnt necessarily mean something specific there
12:02:28 <wilornel> ah, I'm confused! I thnk I should work with these tools before I can understand
12:02:40 <wilornel> For now I just need to move forward I think
12:02:58 <wilornel> Is it possible to reload my app code when I edit it? Instead of building the whole project each time
12:03:30 <Clint> wilornel: `yesod devel` does that
12:03:54 <ertes> wilornel: if you're not using one of those frameworks that do it for you, you can use my 'rapid' library =)
12:03:56 <ertes> @package rapid
12:03:57 <lambdabot> http://hackage.haskell.org/package/rapid
12:04:16 <wilornel> wow!
12:04:23 <wilornel> Can I reload a single function from a whole file?
12:04:50 <ertes> you always reload modules
12:05:03 <wilornel> I'll look into both of these, thanks Clint, ertes
12:05:07 <wilornel> ertes: I see
12:05:28 <ertes> yesod devel basically starts a server and restarts it whenever the code changes
12:05:45 <ertes> rapid is finer-grained, but also requires some setup to work (it's explained in the docs)
12:05:46 <wilornel> ah! So it does more work
12:05:50 <wilornel> Got it!
12:06:43 <ertes> and of course yesod devel only works for the yesod framework =)
12:07:04 <wilornel> do you use rapid while developing rapid?
12:07:35 <wilornel> "Keep resources that are expensive to create in memory and reuse them across module reloads instead of reloading/recomputing them after every code change" cool!
12:07:44 <sm> as fallback, http://entrproject.org is a terrific rerun/restart-on-file change tool I just discovered
12:07:48 <wilornel> I had to code this up in python myself during my last semester project
12:07:57 <ertes> wilornel: yeah
12:09:16 <wilornel> sm: The screenshot at the bottom of that webpage is interesting
12:10:38 <sm> it seems very practical, much better than similar tools I've tried (coughfswatch)
12:11:05 <sm> I just used it to track down a bug, tweaking inputs until it triggered
12:11:59 <sm> but using a haskell web framework with built in support will be better (yesod)
12:13:07 * sm needs a rapid expert to make some cool videos
12:13:22 * wilornel refers sm to ertes
12:13:46 <ertes> sm: feel free to ask =)
12:14:01 * sm tries not to beg ertes directly
12:14:58 <melop> Hello, I've begin to learn Haskell. I've tried to define a hyperoperator function, which generalize common arithmetic operations, by recursion. But it seems to not work. Can someone glance it? http://pastebin.com/xiTTs7f8
12:15:07 <sm> rapid is in my "sounds terrific, might be a lot of fiddling, why is noone using yet" category
12:15:39 <Akii> melop: Int is not a typeclass
12:15:59 <Akii> (Num x, Num y) => Int -> x -> y -> a
12:16:01 <ertes> melop: also you have far too many type variables there
12:16:22 <ertes> sm: well, i'm using it, if that counts =)
12:17:30 <ertes> sm: i suspect that the reason is that there is no quickstart tutorial
12:17:34 <melop> Is typeclass obligtory needed?
12:17:36 <sm> yup
12:17:44 <sm> screencasts would be even better
12:17:53 <ertes> sm: but i'm happy to walk you through the setup process…  a quickstart video would be far better than a quickstart text =)
12:18:13 <sm> https://asciinema.org is fun too
12:18:38 <melop> And if (Num x, Num y) => Int -> x -> y -> a works, why not   hyp :: (Integral n, Num x, Num y) => n -> x -> y -> a  so?
12:19:10 <sm> ertes: for now, thanks in advance - it sounds super usefu
12:19:11 <sm> l
12:19:23 <codygman_> sm: I've used it, there was minimal fiddling
12:23:01 <sm> ertes, codygman_: what do you use it for
12:24:41 <sm> there is a tutorial in the haddock, a bunch of real-world examples just described briefly would sell it even more
12:27:02 <codygman_> sm: i use it to load a csv into memory and then do stuff with it
12:28:30 <codygman_> 4GB csv into memory, filter it down to 1GB, overwrite. Do stuff with 1GB
12:30:01 <sm> codygman_: got a snippet you could paste easily ?
12:30:59 * sm is spoiled for choice/drowning in tools and workflows, compelling examples gets me to try new ones
12:33:40 <ertes> sm: pretty much for everything
12:34:34 <ertes> i haven't had codygman_'s use case yet (keeping stuff in memory), but i commonly use it for long-running applications, and it's especially useful with multi-threaded ones
12:35:17 <ertes> because this is so useful, right now i'm developing a library that will also help with programs that run in the terminal (and require an actual terminal)
12:35:33 <ertes> imagine you could keep a terminal open with your vty app and just reload parts of it =)
12:35:50 <ertes> sm: https://github.com/esoeylemez/rapid-term
12:36:10 <ertes> tutorial for that one is in progress
12:36:49 <sm> woot! sounds awesome
12:40:06 <wilornel> sm: How do you know if someone is using a library or not? Like for rapid?
12:40:23 <codygman_> sm: no but I'm adding it to this tutorial later: https://github.com/codygman/frames-example-cdi
12:40:23 <chris___> it seems like stack's --ghc-bindist option only lets me specify a URL for downloading, I want to point stack at a ghc binary I already have ready
12:41:09 <codygman_> wilornel: http://packdeps.haskellers.com/reverse
12:42:03 <codygman_> chris___: use a file:// URL? Lol
12:42:06 <MarcelineVQ> chris___: it seems to need a distribution rather than being able to specify just a binary, e.g. stack with a custom ghc http://lpaste.net/350667
12:42:40 <wilornel> thanks!
12:43:07 <chris___> I need to use a custom GHC because I'm trying to do a build within a docker container
12:43:18 <chris___> stock GHC have all kids of binary and library paths hardcoded in
12:43:28 <chris___> i finally got a GHC build together that works in a container
12:43:33 <chris___> and stack won't use it :(
12:43:52 <chris___> despite having these --system-ghc options that seem like they should be looking for ghc in $PATH
12:44:24 <chris___> but stack runs this busted function to check if "ghc" exists that doesn't search $PATH
12:44:44 <chris___> ohh maybe if I symmlink ghc into my current directory :-X
12:46:26 <sm> wilornel: by being a haskell junkie and keeping an eye on all discussions and posts :)
12:47:16 <sm> (also by making loose statements in here and watching for corrections)
12:48:04 <MarcelineVQ> if you're making the ghc yourself you can `make binary-dist` and go  stack setup --ghc-bindist "/hard/path/to/ghc-8.1.20161227-x86_64-unknown-linux.tar.xz"
12:51:48 <MarcelineVQ> but it's a pita to specify the version each time you want to build so I'd just have the specific dist in your .yaml like in the link above
12:51:56 <t7> guys if i have 4 sets and i want to find the intersection of all the (any set with any set)
12:52:08 <t7> am i missing a quick and easy way?:
12:53:29 <EvanR> foldl1' intersection sets
12:54:01 <t7> nope
12:54:13 <t7> wait
12:54:46 <t7> [a, b, c, d]  i need to check (a `int` b + c + d) and (b `int` a + c + d) etc
12:56:32 <t7> not sure if im being an idiot . jaypeg
12:57:32 <EvanR> what
12:59:02 <ertes> codygman_: wasn't there a hackage version of that?  because the haskellers.com version is incomplete
13:02:29 <chris___> MarcelineVQ: thanks! did you come across any way to give it an already extracted dir instead of a .tar.gz?
13:03:31 <dgpratt> I have a need for a very simple program that acts as a web server to deliver a generated web page; the page contents will just be a report of some things going on on the machine the program is running on; yesod or snap would seem to be overkill for this, what's a good simple option for this sort of use case?
13:04:00 <t7> warp?
13:04:06 <quchen> dgpratt: Servant+Warp?
13:04:11 <t7> is snap still a thing?
13:04:17 <quchen> Yes
13:04:21 <MarcelineVQ> chris___: Once that worked I didn't try anything else, give it a shot if you like
13:04:26 <sm> dgpratt: I'd use sprinkles
13:04:47 <sm> it can serve data from external processes, among other things
13:05:27 <t7> @hoogle (a -> b -> m c) -> m a -> m b -> m c
13:05:30 <lambdabot> Data.Function.Pointless ($::) :: (a -> b) -> ((a -> b) -> (c -> d)) -> (c -> d)
13:05:31 <lambdabot> Control.Lens.Iso dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
13:05:31 <lambdabot> Control.Lens.Review bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
13:06:11 <dgpratt> thanks for the suggestions, folks, I will investigate
13:08:28 <quchen> t7: I don't think there's a quick and easy way
13:15:35 <MarcelineVQ> @type \f ma mb -> join $ liftM2 f ma mb -- t7
13:15:37 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:18:14 <Akii> wat
13:19:15 <t7> im surprised there is no bind2 or whatever 
13:21:52 <EvanR> :t liftM2
13:21:53 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:22:13 <t7> :t (>>=)
13:22:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:22:25 <t7> not the same
13:22:39 <EvanR> what is the type of bind2
13:23:02 <t7> m a -> m b -> (a -> b -> m c) -> m c
13:23:03 <t7> maybe ?
13:23:30 <mmachenry> :t (\x y z-> x <$> y <*> z)
13:23:32 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
13:23:45 <EvanR> thats liftM2
13:24:03 <EvanR> t7 wants the handler to be an "action function"
13:24:30 <t7> i need the result wrapped in a burrito 
13:24:44 <Akii> let's not go down the burrito thing again
13:28:11 <t7> is there a monadic fold?
13:28:21 <t7> or should i just sequence the end?
13:28:35 <geekosaur> @src foldM
13:28:36 <lambdabot> foldM _ a []     = return a
13:28:36 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:32:37 <digitalmentat> is there anything that already exists for catching async exceptions (within an ExceptT) and re-"throwing" with `throwE` within an ExcepT?
13:33:09 <DemiMarie> How much slower are parsers using Happy and Alex compared to ones using Attoparsec?
13:33:28 <DemiMarie> The grammar is very simple (I'm parsing assembly code)
13:33:58 <t7> am i still a pro-grammer if i use do notation a lot?
13:34:16 <earthy> yes
13:34:23 <johnw> DemiMarie: I think it depends on your grammar
13:34:30 <geekosaur> I'm not aware of any recent timing, but a well written attoparsec parser is far faster than any of the alternatives
13:34:41 <geekosaur> "well written" being the caveat, of course
13:34:45 <johnw> DemiMarie: a main thing that Happy can do that attoparsec cannot is that it's LALR.  What attoparsec can do that happy cannot is be context sensitive.
13:35:03 <johnw> if your grammar is simple LL(1), then it can be encoded with either
13:37:31 <DemiMarie> geekosaur: Do you have any numbers?
13:37:38 <monochrom> parser generators like yacc and happy can be more work to use because they want you to do your tokenizing first. (tokenizers sold separately.)
13:37:58 <geekosaur> monochrom, alex was already mentioned as part of it
13:38:35 <tdammers> tokenizing is also quite hard when tokenization rules are contextual
13:38:40 <monochrom> parser libraries like parsec can be more work to learn because there is a trick to learn to get them to do both tokenizing and grammar at the same time. (trick taught separately.)
13:39:04 <geekosaur> DemiMarie, as I said, not recent. http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
13:39:21 <tdammers> monochrom: isn't the trick just to write small parsers for all the tokens, and then combine them into more complex ones?
13:39:27 <geekosaur> http://stackoverflow.com/questions/3077207/choosing-a-haskell-parser may also be of interest
13:39:59 <geekosaur> (no timings, but a decent overview of what's out there and what each is good at)
13:40:58 <monochrom> tdammers, yes tautologically. But so is "isn't programming just to solve subproblems and then combine them to solve the parent problem?"
13:41:26 <monochrom> And yet people take decades to learn that.
13:41:35 <geekosaur> also notable: the reason for parser/tokenizer generators like happy+alex or yacc+lex was not to simplify parsing, it was to make everything fit into tiny address spaces that were relevant 20 years ago
13:42:16 <tdammers> monochrom: sure, but in this case, I don't see what's special about tokenization in this context, as opposed to writing recursive-descent parsers in general
13:42:45 <geekosaur> (in particular, yacc was not about making parsing easier, it was about shoehorning a parser into a 64k address space)
13:42:53 <DemiMarie> I am tring to rewrite GHC's splitter in Haskell, so I don't know how much speed is important
13:43:24 <DemiMarie> On the one hand, it needs to be able to handle very large volumes of assembler; on the other, it just needs to beat Perl
13:43:31 <monochrom> tdammers: I think what happens in practice is that schools teach you the sold-separately story, so when you later meet parsec you have to unlearn that story.
13:44:22 <tdammers> monochrom: oh, ok, yeah... never been to one of those schools myself ;)
13:44:53 <monochrom> Like the way "if f x = x + x, then f (rand 6) = rand 6 + rand 6" is trivial, but an imperative programmer has to unlearn the imperative narrative to grok it.
13:45:34 <monochrom> In particular the imperative programmer has to unlearn "f x returns so-and-so" and relearn "f x equals so-and-so".
13:46:50 <monochrom> Blessed is the unpolluted mind, indeed.
13:47:54 <tdammers> yeah
13:48:12 <tdammers> it seems that people are irrationally fond of things previously learned, in favor of new things to learn
13:48:36 <monochrom> Oh I used to have an even better saying when I was younger and more arrogant.
13:48:52 <monochrom> "People write-protect their minds after graduation or the age of 21"
13:50:05 <monochrom> I abadoned that after I saw you good people learning Haskell, and succeeding brilliantly, after 30.
13:50:50 <monochrom> Like, just look at ekmett
13:51:02 <monochrom> err, edwardk
13:51:44 <Tuplanolla> I think I didn't begin to learn math properly until that age.
13:52:00 <tdammers> then again, learning Haskell after the age of 30 probably means you've been in a perpetual state of learning new stuff for all your life
13:52:14 <Tuplanolla> (The former.)
13:54:10 <hodapp> You can meet people who are 20 and have already learned everything they're going to learn; you can meet 80-year-olds who are still picking up new things.
13:54:12 <mmaruseacph2> monochrom: I just add a qualifier to that: "Most people write-protect ..."
13:56:57 <hodapp> One of my grandfathers switched to using Macs at the age of 70something and learned to edit video. Another grandfather still refuses to even carry a cell phone or ever learn to use one.
13:57:13 * hodapp shruggs
13:57:19 <chris___> MarcelineVQ: that would be awesome, or if you have any clues in that direction
13:57:24 <hodapp> shrugs! Gah cell phone keyboard.
13:57:48 <monochrom> That proves your cellphone-refusing grandfather's point. :)
13:57:58 <chris___> MarcelineVQ: I published a portable container-friendly ghc build via habitat that i'm trying to get it to use: https://app.habitat.sh/#/pkgs/jarvus/ghc/8.0.1/20161230051538
14:00:01 <hexagoxel> is there haddock magic so my "module Foo (module Export) where import Foo.Bar as Export" stuff gets proper links in haddock?
14:00:51 <hexagoxel> Foo gets an empty haddock output currently.
14:02:21 <monochrom> what happens if you do instead "module Foo (module Foo.Bar) where import Foo.Bar"?
14:03:42 <hackrilege> Anyone use fgl?
14:04:47 <theamytran> Hey all, I'm using aeson and I'm trying to modify a value when I parse it
14:04:53 <theamytran> Does anyone know how to do this?
14:05:02 <hexagoxel> monochrom: yeah that works
14:05:27 <theamytran> as in I have a "Map String String" that I want as a "Map String MyType" instead
14:06:14 <wespiser> theamytran: google Data.Map, then check out the package page
14:06:33 <theamytran> wespiser: I know how to do it if I just have a Map
14:06:41 <wespiser> there is a function, I think map :: (a -> b) -> Map.Map k a -> Map.Map k b
14:06:45 <theamytran> but Aeson has some sort of "Parser" type that i don't really understand
14:06:56 <EvanR> fmap :: (a -> b) -> Map String a -> Map String b
14:07:05 <theamytran> https://hackage.haskell.org/package/aeson-1.0.2.1/docs/Data-Aeson.html#t:FromJSON
14:07:07 <theamytran> This thing
14:07:09 <EvanR> if you literally have a Map String String, thats what you have to do
14:07:26 <hackrilege> The accompanying paper describes a tendency for functional graph libraries to utilise an "imperative" style and introduces fgl as an inductive functional alternative to this (like the zipper stuff). I'm wondering if the situation has changed and if anyone knows any other approaches that I can reference...
14:07:39 <theamytran> sorry let me reask my question, so how would I implement a FromJSON that lets me do something other than the example here https://hackage.haskell.org/package/aeson-1.0.2.1/docs/Data-Aeson.html#t:FromJSON
14:07:40 <wespiser> theamytran: why do you have to do it when parsing?
14:07:42 <monochrom> hexagoxel: Then I think it's a haddock shortcoming.
14:07:52 <theamytran> wespiser: I don't want to create an intermediate data type
14:08:40 * hexagoxel is in a bad mood and considers just putting markdown into comments at the top of the module.
14:08:44 <EvanR> theamytran: in the Parser monad, collect each key, string from the object into a [(k,a)], if something doesnt parse then fail, otherwise return the Map.toList of that
14:09:17 <theamytran> thanks EvanR 
14:09:28 <EvanR> er, Map.fromList
14:09:32 <theamytran> sorry if the questions are dumb haha, i am a beginner
14:09:51 <hexagoxel> monochrom: still, thanks, that probably is a useful workaround.
14:11:18 <RustyShackleford> I want to make some sort of tool for tracking finances and budgeting ahead of time
14:11:33 <RustyShackleford> also want to learn more about functional programming
14:12:01 <RustyShackleford> I'm debating between clojure and haskell. Obviously you all are biased :p 
14:12:01 <hackrilege> Referring to; https://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
14:12:39 <EvanR> the obvious answer is haskell
14:12:52 <RustyShackleford> there java interop seems really nice
14:13:01 <EvanR> ive used the java interop
14:13:06 <RustyShackleford> but I've used a bit of haskell in the past, never used clojure
14:13:24 <RustyShackleford> now I'm trying to figure out how I'm going to store my transactions, budgets, and so on
14:13:41 <EvanR> haskell has a couple of java interop things now
14:13:45 <RustyShackleford> ledger/hledger uses a text file for transactions which I kinda like
14:13:48 <hackrilege> Rusty, mostly we defer conversations surrounding language comparison and instead focus on answering questions designed by the student which show they have committed some time to learning Haskell
14:14:16 <EvanR> i dont think thats true
14:14:40 <monochrom> It is always tricky to speak for the whole channel.
14:14:42 <hackrilege> I'm paraphrasing, guidelines exist, probably, somewhere
14:14:42 <ertes> i don't even understand what that means =)
14:14:45 <RustyShackleford> hackrilege: fair enough. I'm still researching the tools I want to use
14:15:42 <monochrom> And the Dunning-Kruger effect implies that those who know the least are the loudest and with the most assuring tone.
14:16:12 <EvanR> RustyShackleford: for database style stuff my main concern is being able to easily and conveniently "manage" the data offline, without writing code
14:16:17 <ertes> RustyShackleford: i really like the text file approach that ledger uses…  the question is whether you need that
14:16:24 <EvanR> which means using *SQL
14:16:34 <ertes> RustyShackleford: if you mostly modify the state from your own program (instead of a text editor), there may be no benefit
14:16:41 <EvanR> which is what i use for financial records
14:17:01 <hackrilege> I feel it's helpful to safeguard against distraction and repetition of subjective opinion. My personal rule of thumb is that ghc should be useful in answering questions
14:18:28 <ertes> RustyShackleford: for ledger it makes sense that it uses a text file, because it doesn't actually write transactions for you (hledger does to some extent, but i wouldn't call that its main mode of operation either)
14:20:41 <hackrilege> Does anyone know of work building on the concepts introduced in fgl?
14:21:24 <hackrilege> @where fgl
14:21:24 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
14:23:41 <hackrilege> I'm trying to prepare an equivalent library based on a structure like that in http://lpaste.net/350633
14:29:18 <qmm> within the cabal file, i nthe library/exposed-modules section, how might i expose a module that is currently in a subdirectory of src/ (using stack)
14:29:42 <ertes> qmm: hs-source-dirs: src
14:30:27 <qmm> ertes: do i need to change that to: hs-source-dirs: [src, src/foo] ?
14:30:43 <qmm> where foo is the subdirectory
14:31:00 <hexagoxel> qmm: what is the modules full name; what is its path?
14:31:04 <ertes> qmm: you can list multiple directories there…  not sure about the syntax, either with or without comma
14:31:29 <ertes> qmm: remember that if you use module names with dots, you don't need to mention that…  GHC finds those subdirectories by itself
14:31:48 <ertes> so you don't need to mention src/Data for it to find Data.Blah
14:34:51 <hackrilege> Nobody uses fgl?
14:38:00 <qmm> src/Baz.hs src/foo/Bar.hs i'm wondering if Baz.hs needs a declaration such as `module Foo.Bar where` or if it can be `module Bar where` or does src/Baz.hs need to import the module using this syntax: import Foo.Bar
14:38:38 <Nik05> oh const is just pure
14:38:56 <qmm> everything operated until i created a subdirectory and put Bar.hs in it
14:39:07 <qmm> now ghc tells me it can't find the module
14:39:11 <ertes> qmm: do you want to create a module Bar or a module Foo.Bar?
14:40:08 <qmm> i guess Foo.Bar is desirable since i can just use src in hs-source-dirs
14:40:12 <theamytran> Is there something like <$> but in reverse?
14:40:21 <Nik05> flip <$>?
14:40:24 <ertes> qmm: then src/Foo/Bar.hs is the correct name
14:40:42 <theamytran> i'll ask a better question
14:40:56 <theamytran> I want to  turn an `IO Maybe a` into an `IO Maybe b`
14:41:02 <theamytran> and I have a function `a -> b`
14:41:04 <theamytran> what should I be using?
14:41:09 <qmm> ertes: ah, what an eye you have :)
14:41:10 <ertes> theamytran: (IO Maybe a) is a kind error
14:41:15 <ertes> try again =)
14:41:16 <theamytran> sorry
14:41:17 <Nik05> (<$>) is fmap, it brings a morphism from one category to another
14:41:22 <theamytran> IO (Maybe a)
14:41:28 <ertes> theamytran: fmap (fmap f)
14:41:28 <theamytran> into an I`O (Maybe b)`
14:41:41 <Nik05> theamytran do an fmap twice
14:41:44 <Nik05> oh im slow
14:41:45 <theamytran> ooh
14:41:49 <theamytran> thanks
14:41:51 <theamytran> i'll try it
14:42:05 <ertes> theamytran: fmap :: (x -> y) -> IO x -> IO y
14:42:12 <ertes> theamytran: x = Maybe a, y = Maybe b
14:42:22 <ertes> theamytran: fmap :: (a -> b) -> Maybe a -> Maybe b
14:42:30 <qmm> i didn't do anything differently since foo was actually already Foo
14:42:34 <qmm> same error
14:42:52 <ertes> qmm: you still need to mention src, if your source code is in src
14:43:11 <ertes> qmm: by default the source root is the project's root directory
14:43:52 <hackrilege> You need a .ghci file qmm
14:44:00 <qmm> ertes: hs-source-dirs does this, right?
14:44:04 <theamytran> zomg im so happy
14:44:04 <ertes> qmm: yes
14:44:04 <qmm> /dist/x86_64-osx/Cabal-1.24.0.0/build/autogen
14:44:05 <theamytran> it finally works
14:44:09 <theamytran> i love haskell
14:44:11 <ertes> hackrilege: what?  no
14:44:15 <qmm> sorry, full error message: setup-Simple-Cabal-1.24.0.0-ghc-8.0.1: can't find source for Bar in src, .stack-work/dist/x86_64-osx/Cabal-1.24.0.0/build/autogen
14:44:30 <ertes> qmm: do you have a src/Bar.hs?
14:44:41 <qmm> no
14:44:48 <qmm> it's src/Foo/Bar.hs
14:44:57 <ertes> qmm: then the module is named Foo.Bar, not Bar
14:45:15 <qmm> i'm pulling in Foo.Bar from src/Baz.hs
14:45:22 <ertes> qmm: modules don't actually follow a hierarchial structure…  the module's name is actually "Foo.Bar"
14:45:28 <qmm> i should choose better names
14:45:45 <hackrilege> Isn't it Src.Foo.Bar etres?
14:45:47 <ertes> qmm: and the module name *must* correspond to the file path:  Foo.Bar *must* be in Foo/Bar.hs below the source root
14:46:20 <qmm> ertes: it is
14:46:26 <qmm> src is the root
14:46:29 <qmm> Foo is subdir
14:46:34 <qmm> Bar.hs is in Foo
14:46:44 <qmm> Baz.hs is in the root dir (src/)
14:46:53 <ertes> hackrilege: no, 'src' is marked as the source root via hs-source-dirs
14:47:05 <ertes> qmm: ok, so you have two modules:  Baz and Foo.Bar
14:47:18 <qmm> Baz is attempting to use Foo.Bar
14:47:31 <RustyShackleford> sorry I left in the middle of a conversation
14:47:31 <ertes> qmm: so it's importing Foo.Bar?
14:47:36 <qmm> ertes: correct
14:47:38 <RustyShackleford> ertes: do you use ledger/hledger?
14:47:44 <ertes> qmm: and it's still not found?
14:47:50 <ertes> RustyShackleford: yeah (ledger)
14:47:53 <qmm> ertes: correct
14:48:00 <RustyShackleford> I'm thinking ledger can do MOST of what I want
14:48:10 <ertes> qmm: could you put your source directory online somewhere?  like github?
14:48:17 <RustyShackleford> know of any good reading material? Ledger isn't super well documented
14:48:38 <ertes> RustyShackleford: are you familiar with general double-entry accounting?
14:48:47 <hackrilege> In the folder Foo my .ghci file would say :set -i../.. And my module name would be Src.Foo.Bar,
14:48:48 <RustyShackleford> well sort of. I read a bit about it
14:48:59 <RustyShackleford> basically, all money has to come from somewhere
14:49:07 <qmm> ertes: will do
14:49:08 <RustyShackleford> you have a To: line and a From: line
14:49:09 <ertes> RustyShackleford: i'll take that as a "no" =)
14:49:20 <RustyShackleford> pretty much yeah haha
14:49:56 <hexagoxel> qmm: do you have "exposed-modules Foo.Bar Baz"?
14:50:24 <hexagoxel> because the errors hints that you have "exposed-modules Bar Baz"
14:50:46 <ertes> RustyShackleford: i have a medium-paced tutorial online, but it's in german…  other than that the ledger docs attempt to introduce you to the general idea as well as the syntax, but it's faster-paced
14:51:04 <RustyShackleford> hm I can't read german so... lol
14:51:11 <RustyShackleford> are you familiar with YNAB?
14:51:19 <ertes> nope
14:51:32 <RustyShackleford> Thats what I use for budgeting now... good tool but there are little quirks that drive me nuts
14:51:42 <RustyShackleford> and auto-importing transactions is really unreliable
14:51:55 <hackrilege> ...
14:51:59 <ertes> RustyShackleford: i should just translate my tutorial, i guess =)
14:52:18 <qmm> hexagoxel: ah! it was Baz, Bar instead of Baz, Foo.Bar
14:52:21 <qmm> that has to be it
14:53:00 <qmm> that did it
14:53:06 <qmm> thanks ertes and hexagoxel 
14:53:27 <RustyShackleford> ertes: so basically YNAB lets you create virtual "envelopes" for planning ahead
14:53:43 <RustyShackleford> so I get paid, I put next months rent, gas money, lunch money, and so on in an envelope
14:53:56 <RustyShackleford> and then when its all funded, I know I can spend the rest (if I want)
14:54:15 <hackrilege> How is this Haskell related!?
14:54:33 <RustyShackleford> its not. I could take it to a PM or just fuck right off :)
14:54:41 <ertes> RustyShackleford: yeah, we should move this elsewhere =)
14:54:50 <hackrilege> Family friendly language also please
14:55:01 <MarcelineVQ> I don't have family here
14:55:16 <RustyShackleford> my bad. My family talks that way
14:55:22 <hexagoxel> did you just assume my familility ???
14:55:27 <RustyShackleford> I'm really not making a good first impression am I?
14:55:43 <ertes> RustyShackleford: don't worry about it…  hackrilege is probably just having a weird day =)
14:55:55 <hackrilege> !?
14:56:24 <RustyShackleford> okay haskell question: I feel like I heard somewhere that processing text files is quite advanced in haskell
14:56:43 <RustyShackleford> any good reading, libraries, whatever?
14:56:52 <hexagoxel> hackrilege: there are simply better ways to ask them to move to private message if this has drifted too far from hledger.
14:56:54 <ertes> RustyShackleford: stream processing is advanced
14:57:02 <theamytran> Hey all, i'm in the middle of a do block with `IO (Maybe String)` and I want to break out of the program if the Maybe is a Nothing. What should I do?
14:57:08 <ertes> RustyShackleford: example library: pipes
14:57:09 <hexagoxel> the latter being haskell-related
14:57:18 <RustyShackleford> I haven't touched haskell in a few years so I'll have to start with the basics again
14:57:27 <RustyShackleford> but I loved how easy it was to unit test EVERYTHING
14:57:33 <theamytran> in scala I'd do something like "if (!maybe.isDefined) sys.exit(1)"
14:57:35 <ertes> theamytran: the simple way would be to branch, if there is only one such branch
14:57:48 <ertes> theamytran: oh, you want to exit the whole program?
14:57:48 <implementation_> for processing text, you might also want to look at parsec/attoparsec/megaparsec
14:57:48 <theamytran> ertes: can I branch in a do block?
14:58:24 <hackrilege> I think pure Haskell handles text processing fine... Data.String has some good beginner functions, check the source to learn how they can be written
14:58:25 <ertes> theamytran: i'd do the following: import Control.Exception
14:58:39 <RustyShackleford> really I need to decide on my storage method, and choose my tools from there. I love the idea of a text file transaction journal. I could also use json, a database, there are others I'm sure
14:58:42 <ertes> theamytran: myAction >>= maybe (throwIO (userError "Some error message")) pure
14:58:59 <ertes> theamytran: where myAction :: IO (Maybe A), this action is of type IO A
14:59:07 <theamytran> interestin
14:59:17 <theamytran> so exceptions are fine to use for user errors?
14:59:35 <theamytran> I never did that stuff in other languages, haha
14:59:36 <MarcelineVQ> RustyShackleford: sqlite might be a good option for local book-keeping
14:59:37 <ertes> theamytran: if you don't catch the exception, the RTS will catch it and terminate the program with an exit code of 1
14:59:58 <ertes> theamytran: displaying your error message along the way
15:00:06 <RustyShackleford> Then I need to account for security maybe
15:00:21 <hackrilege> How do you mean?
15:00:21 <RustyShackleford> do I want a plain-text journal of all my finances in a private github repo?
15:00:34 <MarcelineVQ> definetly not
15:00:46 <hackrilege> No, but that's not a question for this channel
15:01:06 <ertes> @topic-police
15:01:06 <lambdabot> Unknown command, try @list
15:01:10 <RustyShackleford> eh, I'll take it to ##programming I guess. Trying to design my tool before I start implementing
15:01:15 <sm> hi RustyShackleford.. we also have #hledger 
15:01:28 <RustyShackleford> sm: thanks I'll talk to those guys too
15:01:33 <MarcelineVQ> RustyShackleford: I lost the thread, are you making accounting software?
15:01:42 <sm> ah hakyll.. how you delight in tormenting me when I unsuspectingly try to update a web page
15:01:54 <sm> your days are numbered, my old friend
15:02:06 <ertes> RustyShackleford: FWIW general engineering questions are fine here
15:02:22 <ertes> as long as they remotely relate to haskell
15:02:48 <RustyShackleford> well is it easy to use a database with haskell?
15:02:58 <RustyShackleford> IIRC state get's rather tricky with haskell
15:03:00 <MarcelineVQ> depends on the db hehe
15:03:10 <RustyShackleford> sqlite
15:03:21 <RustyShackleford> i'm not going to set up anything more complex than that
15:03:22 <implementation_> also depends on whether you like Template Haskell or not :)
15:03:24 <ertes> RustyShackleford: just dispatching SQL is as easy in haskell as in other languages, but you do have options beyond that in haskell
15:03:30 <ertes> RustyShackleford: you might call that "easy"
15:03:44 <ertes> RustyShackleford: also state is not tricky at all in haskell
15:03:58 <hackrilege> https://hackage.haskell.org/package/sqlite-simple
15:04:03 <ertes> > iterate (\x -> 1237*x + 1 :: Word16) 0
15:04:05 <lambdabot>  [0,1,1238,24079,32380,11565,19058,47323,14904,20633,29518,10215,53044,13893,...
15:04:08 <RustyShackleford> MarcelineVQ: yeah. I've been reading about ledger/hledger and thinking an accounting tool might be fun to make
15:04:10 <ertes> this is stateful =)
15:04:24 <sm> it's super fun :) 
15:04:30 <hackrilege> https://hackage.haskell.org/package/sqlite
15:04:37 <sm> also a lot of work 
15:05:00 <sm> but you might find a shortcut!
15:05:55 <ertes> actually writing accounting software in haskell has one major benefit:  you can design the query DSL as an EDSL and get all the power of haskell for your accounting needs
15:06:11 <ertes> therefore writing accounting software in haskell is probably not even that much work
15:06:39 <ertes> unlike for example ledger, which needs to parse/interpret its own query language to be as powerful as it is
15:07:49 <hackrilege> Is it bad practice to store raw data in .hs files in Haskell syntax and import them?
15:08:09 <wespiser> what type of data?
15:08:10 <ertes> hackrilege: if the data source is trusted, i think it's fine
15:08:23 <lordcirth> hackrilege, you mean like a file that just says "x = ......" ?
15:08:26 <ertes> hackrilege: don't generate too much data though, because GHC doesn't really like big source files
15:08:29 <sm> ertes: power of haskell for accounting needs, exactly!
15:08:42 <hackrilege> Not so great for real time as it then takes compilation to become visible
15:08:56 <sm> you've still got a complicated parser though if you keep ledger compatibility
15:09:00 <implementation_> hackrilege: it does bear the disadvantage that you need to recompile the project everytime you change the data. that might be really annoying.
15:09:09 <ertes> sm: i'd probably use YAML
15:10:03 <sm> the accountant-readable plain text format is a usability and durability feature.. but I'm all for trying out alternate storage formats
15:10:04 <hackrilege> lordcirth, yeah, I use lists and generating functions to store eg sounds which can then have interpolation to control pitch
15:11:41 <hackrilege> Probably I should use some standard like xml or something, but it's a shame not to be able to store the data as lambda expressions :(
15:12:48 <hackrilege> CSV is good! Then you can just use splitOn ','
15:13:20 <ertes> sm: i'd still not write it by hand
15:13:40 <hackrilege> :t (unlines,unwords)
15:13:41 <ertes> ledger-mode is an important part of the UX of ledger for me…  without it i wouldn't use ledger
15:13:42 <lambdabot> ([String] -> String, [String] -> String)
15:14:41 <hackrilege> Sorry wrong way round. Anyway, since simple standards exist, what's the advantage of sql?
15:14:58 <ertes> hackrilege: compared to CSV?
15:15:04 <sm> ertes: yes for me too (I use it with hledger)
15:15:27 <ertes> sm: out of curiosity: does hledger have a feature that ledger doesn't have that you rely on?
15:15:31 <hackrilege> Or xml, something more expressive but not quite pure Haskell
15:15:47 <RustyShackleford> xml would be a pain to write by hand
15:15:53 <RustyShackleford> or to read honestly
15:15:57 <ertes> hackrilege: SQL is used by some powerful database systems that can handle lots of data and do interesting queries on them
15:16:10 <RustyShackleford> why does xml need to exist. json omg
15:16:12 <hackrilege> I had to use json for web stuff, I guess that's ok?
15:16:25 <sm> ertes: sure, a bunch. They change a bit over time
15:16:51 <ertes> sm: could you name an example?  i'm really interested in what hledger has to offer over ledger
15:16:53 <hackrilege> Ok so it's more about the functions, which I would write in Haskell, I thought it was more about raw storage
15:17:10 <ertes> hackrilege: SQL is just a query language
15:17:35 <ertes> it doesn't have any particular advantages over, say, a combinator interface in haskell
15:17:52 <ertes> in fact it has a few disadvantages:  being a textual language stuff like SQL injection can be a problem
15:18:26 <sm> ertes: it's a bit of a long list, perhaps we should take it to #hledger. hledger-ui is one
15:18:33 <hackrilege> It's a shame employers just think sql is some kind of massive deal
15:18:38 <ertes> sm: i joined
15:19:10 <wespiser> also the scope system in SQL is whack
15:19:36 <hackrilege> I like lists, they are friendly
15:20:09 <crobbins> any hakyll users out there? having trouble figuring out how to rename files but not sure if #hakyll is monitored
15:20:21 <hackrilege> Did anyone see http://lpaste.net/350633, I'm looking for some feedback
15:22:49 <hackrilege> I think its closely related to the approach used by fgl, and I was wondering if anyone knew of any significant advances in inductive graphs since then?
15:26:33 <hackrilege> I guess all the relevant profs are busy being festive! Ok, can't understand why that doesn't get a response, I'll report back if I make any progress, peace and love
15:33:20 <theamytran> How do i pattern match against a 3 element [String]?
15:34:36 <Roxxik> f [x,y,z] = ????
15:35:02 <hexagoxel> let [str1, str2, str3] = foo
15:37:43 <ertes> theamytran: what if it's not 3 elements?
15:38:16 <theamytran> i want to ignore it
15:38:26 <theamytran> the solution above worked, thanks
15:38:29 <theamytran> i was using :
15:44:32 <Roxxik> sure you can do let (x:y:z:[]) = foo
15:58:41 <S11001001> theamytran: it will crash if there aren't 3
16:00:52 <MarcelineVQ> is there a common function for:  ['a'..'d']   ->   [('a',"bcd"), ('b',"acd"), ('c',"abd"), ('d',"abc")]
16:01:06 <Welkin> break
16:01:32 <Welkin> permutation and break
16:01:32 <Welkin> :P
16:03:49 <S11001001> theamytran: that is, it won't match; in a let like Roxxik's example that will crash
16:05:03 <Rotaerk> MarcelineVQ, not exactly; you'll need to construct one
16:05:26 <MarcelineVQ> I've made one but I'm wondering if there's something common I could compare against
16:05:48 <Rotaerk> well wait, I guess some do come up when I use stackage rather than hoogle
16:05:52 <Rotaerk> https://www.stackage.org/lts-7.14/hoogle?q=%5Ba%5D%20-%3E%20%5B(a%2C%20%5Ba%5D)%5D
16:05:57 <MarcelineVQ> mine doesn't preserve order but I'm not especially concerned about that
16:06:58 <Rotaerk> maybe the removeEach one would be good
16:07:37 <MarcelineVQ> Rotaerk: yes, or using it's example:  zip xs (map (flip List.delete xs) xs)
16:10:35 <MarcelineVQ> hmm, or  select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
16:10:36 <ertes> MarcelineVQ: i've reinvented it so many times now that i have almost memorised it
16:10:41 <ertes> @let select = snd . foldr (\x ~(xs, ys) -> (x : xs, (x, xs) : map (fmap (x :)) ys)) mempty
16:10:43 <lambdabot>  Defined.
16:10:46 <ertes> > select "abcd"
16:10:49 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
16:10:59 <Welkin> ertes: what do you need it for so often?
16:11:32 <MarcelineVQ> being able to focus on an element of a list with 'the rest' of the list available is pretty useful in general
16:11:35 <ertes> Welkin: mostly searches when permutations are involved
16:11:47 <Welkin> MarcelineVQ: like a zipper?
16:11:49 <ertes> but yeah, it's useful in general
16:12:42 <EvanR> cool views
16:12:43 <MarcelineVQ> like a zipper, my solution for it started as a zipper actually
16:12:44 <c_wraith> ertes, it's not great for generating permutations, though. it allocates a lot compared to some other approaches. 
16:13:25 <ertes> c_wraith: sure, but it's great for some quick-n-dirty code to search something =)
16:15:41 <MarcelineVQ> selectSplit [] = []; selectSplit (x:xs) = ([],x,xs) : [(x:lys,y,rys) | (lys,y,rys) <- selectSplit xs]   is more zipper-like  https://mail.haskell.org/pipermail/libraries/2008-February/009270.html
16:16:39 <Marvin> Hi all
16:18:04 <NotMarvin> Is there anyway to make emacs show the type of a variable in the minibuffer when the cursor is over it?
16:18:22 <NotMarvin> Like it does for certain Prelude functions like foldl 
16:18:40 <NotMarvin> any way*
16:22:14 <Roxxik> theamytran: it's like S11001001 said: it's most of the time better to match like case foo of { [x,y,z] -> bar; _ -> baz } and if you only ever have 3 Elements, then why isn't this a (String,String,String) ?
16:54:56 <bsima_> I've got this function f(x) = x * 25 mod 192. I want to find a function g which runs that equation on a number, say f(9) which returns 33, and then call the function on that again, f(33) or f(f(9)). I want to keep doing this until the equation returns 9 again, at which point I stop and output a list of all the return values. For example, for g(9), I would get back the list [9, 33, 57, 81, 105, 129, 153]. 
16:55:02 <bsima_> Any ideas?
16:55:53 <hexagoxel> :t iterate
16:55:55 <lambdabot> (a -> a) -> a -> [a]
16:56:09 <bsima_> mmm i see
16:57:49 <hexagoxel> and then takeWhile or some such
16:59:14 <Roxxik> somethin like `g f x = x : takeWhile (/= x) $ tail $ iterate f x`
16:59:39 <bsima_> ah yeah, takeWhile is what I was missing
16:59:55 <hexagoxel> note that iterate returns the 0th application as well
16:59:55 <ertes> bsima_: if you only care about the result you could also use 'until'
17:00:17 <hexagoxel> ah you have tail, my bad
17:00:53 <Roxxik> > take 10 $ iterate (+1) 0
17:00:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:01:02 <Roxxik> tested it before posting ;)
17:01:11 <ertes> bsima_: but i suppose you're more interested in the period =)
17:01:53 <ertes> bsima_: BTW, this particular case would be much more efficient to implement using square-and-multiply…  this gives an exponential speedup over iterating
17:02:31 <ertes> ah, wait…  that doesn't help here
17:02:42 <ertes> but something like baby-step-giant-step or pollard-rho would help
17:03:08 <ertes> which gives at least a quadratic speedup =)
17:03:34 <bsima_> yeah I'm doing a period calculation, so I need each step until it starts repeating
17:03:47 <bsima_> I'm not familiar with baby-step-giant-step or pollard-rho
17:03:57 <ertes> bsima_: are you familiar with floyd/brent cycle-finding?
17:04:17 <bsima_> nope
17:04:23 <Roxxik> the simple but slow function is still handy to have, at least in some quick-check property that makes sure the fast gfunction works as intended
17:04:45 <bsima_> I'm fine with simple but slow for now
17:04:51 <ertes> bsima_: https://en.wikipedia.org/wiki/Cycle_detection#Algorithms
17:05:24 <ertes> bsima_: actually floyd is really simple to implement
17:05:31 <ertes> (a.k.a. "tortoise and hare")
17:05:39 <bsima_> ooh nice
17:06:46 <ertes> (both are simple to implement, but brent's algorithm may be harder to understand)
17:11:07 <ertes> bsima_: i just realised something: since you know the starting point these algorithms may not actually buy you anything in this case
17:11:20 <ertes> feel free to use the naive approach
17:12:13 <bsima_> yeah that's what I'm thinking, always good to at least know that the other ones exist tho! thanks ertes
17:12:40 <ertes> bsima_: BSGS would give you a real speedup though, if you want a challenge…  it's not straightforward to implement, but still easy enough to be a good beginner challenge =)
17:14:01 <ertes> it gives a speedup, because there is an efficient way to apply your step function as often as you want
17:16:25 <ertes> example: make it twice as fast:  take two steps in every iteration (multiply by 25^2 ≡ 49 instead of 25), and check whether you have reached 9 or 9*25…  if you took n steps, the period is 2*n - v, where v = 0, if you reached 9, v = 1 if you reached 9*25 ≡ 33 (because you overshot by 1)
17:17:09 <bsima_> `g f x = x : xs where xs = takeWhile (/= x) $ tail $ iterate f x` works for me, Roxxik's version didn't work, I needed the `where` for some reason
17:17:56 <hexagoxel> heh, (:) vs ($) precedence
17:19:35 <bsima_> i don't really need the speed, I'm just calculating the times table of a circle for string art like this https://s-media-cache-ak0.pinimg.com/600x315/02/33/62/0233628c4de2be0fcfb6a981ed4c9ec6.jpg
17:20:27 <Roxxik> bsima_: ok `g f x = (x :) . takeWhile (/= x) . tail . iterate f $ x` 
17:20:46 <Roxxik> or using $: g f x = (x :) $ takeWhile (/= x) $ tail $ iterate f x
17:20:57 <ertes> sm: rapid-term is online, tutorial is written: https://hackage.haskell.org/package/rapid-term
17:22:45 <bsima_> Roxxik: ah, thx
17:23:42 <Roxxik> :t g f x = (x :) . takeWhile (/= x) . tail . iterate f $ x
17:23:44 <lambdabot> error:
17:23:44 <lambdabot>     parse error on input ‘=’
17:23:44 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
17:23:55 <Roxxik> :t \f x -> (x :) . takeWhile (/= x) . tail . iterate f $ x
17:23:57 <lambdabot> Eq a => (a -> a) -> a -> [a]
17:24:34 <MarcelineVQ> ertes: did you figure out the weird handle issues you were having?
17:29:28 <ertes> MarcelineVQ: yeah, i chose not to try to make putStrLn work
17:29:43 <ertes> you need to abstract over the handles to use rapid-term
17:29:53 <ertes> mainWith :: Handle -> Handle -> Handle -> IO ()
17:30:36 <ertes> there is also a tutorial on how to make vty work (which is surprisingly simple)
17:33:02 <aepictures> Hello there :)
17:37:55 <johnw> hi
18:11:47 <marcx> hi. is it possible to have two executables in a single cabal file?
18:12:30 <marcx> or am I suppose to have multiple cabal files, one for each executable
18:13:00 <ertes> marcx: you can have as many executables, test suites and benchmarks as you want, but only one library section
18:14:01 <marcx> is that a better approach? than having multiple cabal files (that share same sandbox)
18:14:38 <ertes> marcx: do your applications belong together?  for example do they share utility modules?  do they have a common test suite?  etc.
18:14:55 <ertes> marcx: if you can't think of a technical reason why they should be in the same package, they probably shouldn't be
18:16:24 <marcx> I am writing a bunch of really small programs and I want to avoid the boilerplate of creating cabal file and sandbox for each one
18:19:18 <ertes> marcx: maintenance is a valid reason to keep them in a single package
18:19:45 <marcx> single package means single cabal file?
18:19:59 <ertes> marcx: yeah, .cabal files correspond to packages
18:20:27 <glguy> I don't think you need your two executables to use the same cabal file to have them share a sandbox
18:20:52 <Clint> indeed you don't
18:22:46 <marcx> how can I have two packages share the same sandbox
18:24:13 <glguy> check out: cabal sandbox init --help
18:24:14 <Clint> marcx: cabal sandbox init --sandbox /path/to/shared/sandbox
18:27:45 <marcx> interesting.. do i even need a cabal file? can I just have source with main, and have it use packages it needs from the sandbox
18:28:02 <ertes> marcx: you don't need a .cabal file
18:28:30 <ertes> marcx: see cabal exec --help
18:31:39 <marcx> whoa
18:31:43 <marcx> this is perfect
18:31:44 <ezyang> Blah, feeling a bit regretful for choosing the field name 'mixins' 
18:31:48 <ezyang> maybe I should rename it again 
18:35:29 <EvanR> if i want an internal notion of lambda calculus, i could make a data type and muck around with substitutions or environments
18:35:53 <EvanR> and that might give me a way to serialize lambdas
18:36:03 <marcx> glad I asked.. i was creating cabal file for 20 line programs :P. thanks all
18:36:05 <EvanR> but is there some monumentally better way?
18:36:10 <glguy> additives? enhancers? mixers? combinators? 
18:36:49 <EvanR> debruijn indexes? higher order abstract syntax?
18:37:36 <ezyang> glguy: So, what I'm trying to capture is some distinction between version constraints, and actual *imports* 
18:38:08 <ezyang> For example, suppose that you know that you require base < 4.8, but you don't actually *want* any modules from base 
18:38:14 <ertes> EvanR: search for: "i'm not a number, i'm a free variable"
18:38:20 <ertes> a.k.a. the locally nameless approach
18:38:24 <ezyang> With build-depends today, if you add the constraint, everything gets dumped into scope. No good. 
18:38:37 <EvanR> ok
18:38:59 <ertes> EvanR: a clever combination of de bruijn indices with names that has the advantages of both and none of the shortcomings of either
18:39:03 <marcx> btw, a while ago I think I tested compiling program and then running executable vs runhaskell, and I think the former was even faster. is there any mechanism built into ghc/cabal that will compile the file only if executable is older than the source, and then just run executable?
18:40:03 <glguy> ezyang: I'm doing this to work around bugs in my transitive dependencies?
18:40:08 <ertes> EvanR: once you understand how it works, edwardk has written a nice implementation of it
18:40:10 <ertes> @package bound
18:40:10 <lambdabot> http://hackage.haskell.org/package/bound
18:40:17 <ezyang> glguy: I mean, that's not the only motivation 
18:40:25 <ezyang> Backpack needs to "include" a package twice because it can instantiate 
18:40:58 <ezyang> and hypotehtically, if we ever had multiple libraries exposed by a package, you'd want to specify the constraint once, but then say which libraries from the package you actually wanted to bring into scope. 
18:41:01 <ertes> marcx: GHC does that by default
19:08:01 <EvanR> is addFinalizer is System.Mem.Weak the standard way to finalize a "pure value", unless its a foreign ptr
19:08:37 <EvanR> in System.Mem.Weak
19:14:45 <sm> ertes: rapid-term released, nice
19:26:40 <ij> I have a Log = (from, contents) tuple and a BotHistory = Data.Map From Contents, but could I make a type constructor that'd deconstruct Log into from and contents type and apply them to Data.Map?
19:28:54 <marcx> having trouble.. i did cabal update, and now I am getting this error: The package 'cairo' requires Cabal library version -any && >=1.24
19:29:05 <marcx> it installed fine prior to update
19:30:09 <ij> Sounds like using stack might help.
19:30:31 <M0b10s> i see university problems... semp a curtir...
19:31:00 <ezyang> marcx: what command are you using that causes the error? 
19:31:25 <marcx> ezyang cabal install
19:31:53 <wespiser> on the topic, remind my of my university biology teachings on Bot Flies
19:32:44 <ij> M0b10s, You're talking about my problem?
19:33:25 <marcx> http://lpaste.net/350671
19:35:36 <ysangkok> marcx: why not upgrade cabal then?
19:36:00 <ysangkok> marcx: -M for ghc will generate a Makefile...
19:36:43 <marcx> ysangkok I'l try. buy say I screwed up, is there a way to revert what cabal update did?
19:41:53 <ezyang> marcx: Yes but you might need a newer version of Cabal 
19:42:17 <ezyang> run cabal install --help and look and see if you have --index-state= flag in it 
19:42:36 <ezyang> if you do, you can put a timestamp in it to roll back the index to an older update 
19:44:32 <ezyang> unfortunately cabal-install doesn't record old index states so you'll have to guess when the last time you ran update was 
19:44:53 <ezyang> WAIT 
19:45:16 <ezyang> marcx: What if you set --constraint="Cabal == 1.24.0.0"? 
20:33:40 <lpaste> Buttons840 pasted “How to wrap up this Pipe?” at http://lpaste.net/350672
20:34:59 <buttons840> I'm trying to make a pipe that crawls a web page with logic like "get the first page, and follow the shortest 10 links on every page up to 2 deep"
20:51:39 <buttons840> wow, a_pipe >-> another_pipe is a pipe, they compose really nice
20:52:56 <wespiser> buttons840: anything fun with pipes?
20:55:40 <codedmart> What is the best resource I can read about writing a generic for a class?
20:55:54 <codedmart> I have never done that.
20:58:00 <buttons840> wespiser: you're asking what i'm working on?
20:58:13 <wespiser> yea, sorry if I wasn't clear!
20:58:40 <wespiser> I've been admiring pipes for some of the data processing work I've done
20:58:57 <wespiser> haven't gotten into it yet though!
20:58:58 <lpaste> Buttons840 pasted “No title” at http://lpaste.net/350673
20:59:19 <buttons840> wespiser: working on a webcrawler
20:59:45 <buttons840> pretty much done (assuming what i have works, so far it's only typed checked ;)
20:59:51 <wespiser> oh rly
20:59:54 <wespiser> is it open source?
21:00:23 <buttons840> well, right now it's just a snippet in lpaste
21:14:25 <buttons840> wespiser: so, you're welcome to grab some code from my lpaste, but i'm not going to put a license on it or anything right now (it's only like 40 lines of code)
21:23:05 <wilornel> What is Bryan talking about here: https://youtu.be/ZR3Jirqk6W8?t=981 
21:23:29 <wilornel> "The edit and then dump it in the interpreter way of doing things feels like the lisp..."
21:24:03 <wilornel> Can I do that? Or would I have to copy paste stuff over?
21:29:05 <c_wraith> wilornel: it sounds (from listening to a 30 second excerpt) like he's talking about just loading source files in ghci
21:32:03 <c_wraith> wilornel: that's an approach to haskell development I use pretty often.  Write something, load in ghci to see if it typechecks. If it doesn't, edit and reload.  If it does, test it on a few inputs, then possibly edit and reload.
21:32:48 <c_wraith> wilornel: and I *think* that's what he's talking about.  They key is that you do most of the work in the editor, and just go to the interpreter to validate what you've done.
21:34:37 <wilornel> Hmmm does this become harder when you're dealing with more complicated systems?
21:34:55 <wilornel> And some of your inputs/outputs are big structures?
21:37:45 <c_wraith> wilornel: it does, but you can find ways to make it work.
21:37:55 <wilornel> what tools do you use?
21:39:24 <c_wraith> It's more about code organization than anything else. Make sure you have helpers around to let you create your more complex structures easily and to help you run more complex monadic actions interactively.
21:43:27 <c_wraith> Oh, and the occasional pretty-printer for displaying complex output structures really helps.
21:46:02 <wilornel> got it!
21:46:25 <wilornel> It sounds like because it is functional programming, the task of creating the complex structures is not that complicated
21:46:37 <wilornel> It will work the same way every time you run it with the same input
21:46:51 <wilornel> Can it take long to create/compute the complex structure?
21:48:45 <c_wraith> It can.  Anything *can* take long.  :)
21:49:18 <c_wraith> But usually in the size range that's useful for interactive testing, it's not bad.
21:49:32 <c_wraith> Though the interpreter is notably slower than compiled code
21:50:48 <c_wraith> Like, creating a structure with a hundred nodes is basically instant, unless you're doing heavy calculation in the process.
21:51:11 <c_wraith> And that's about the size where interactive testing gets cumbersome and you should be working on more-automated tests.
22:02:55 <orzo> is the llvm currently in really really bad state?  A simple benchmark using the criterion library compiled with -fllvm -O2 just brought my computer down
22:03:03 <orzo> it worked fine without the -fllvm
22:10:24 <JuanDaugherty> probable misuse of definite article
22:10:50 <JuanDaugherty> unless "llvm in my dev env" was intended
22:11:07 <JuanDaugherty> as opposed to say the current llvm distribution
22:11:18 <orzo> i meant the llvm support in ghc
22:11:25 <JuanDaugherty> or that
22:11:38 <orzo> i installed llvm-3.7 as ghc told me too
22:11:57 <orzo> it's the debian build but i doubt they'd mess around with it
22:12:01 <JuanDaugherty> which should just be the join of stable ghc and whatever llvm version is coordinate
22:12:17 <JuanDaugherty> you don't wanna rely on a distro for that
22:12:26 <Gurkenglas> Is there a memoizing library that uses unsafePointerEquality to not even need hashable?
22:12:31 <JuanDaugherty> a linux one anyway
22:13:06 <orzo> do you actually use -fllvm yourself?
22:13:18 <Gurkenglas> (When you want to memoize, say, list lengths)
22:13:35 <JuanDaugherty> you think the answer to that affects the worth of my advice?
22:13:44 <orzo> some
22:14:08 <JuanDaugherty> k good, no i have not used llvm with ghc or ftm period srsly yet
22:14:15 <orzo> "don't rely on a distro for that" is pointless from somebody who doesn't even use linux, for example
22:14:29 <Gurkenglas> (ie add fields to your data without actually needing to keep track of them yourself)
22:15:07 <JuanDaugherty> oh, sorry I tend to presume linux
22:15:08 <Gurkenglas> (say, the size field in sets and maps)
22:15:44 <JuanDaugherty> except in like labview or xcode or whatever
22:16:12 <orzo> i think llvm support is likely somewhat broken in ghc.  trac shows some bugs, https://ghc.haskell.org/trac/ghc/query?status=infoneeded&status=merge&status=new&status=patch&status=upstream&type=bug&component=Compiler+%28LLVM%29&col=id&col=summary&col=status&col=owner&col=type&col=priority&col=milestone&order=priority
22:17:08 <JuanDaugherty> i'm sure it's at the edge of their dev/support envelope
22:17:25 <JuanDaugherty> possibly outside it
22:18:06 <JuanDaugherty> have they even switched to clang over gcc?
22:18:26 <orzo> based on #7297, it sounds like it is easy to break llvm code if you increase parallization and neglect to keep llvm fully informed
22:21:45 <codygman> Any ideas on how to do this date comparision more concisely? http://lpaste.net/350674
22:21:57 <haasn> Implementing the y combinator in Haskell without using recursion and without using a newtype seems to be impossible, how can I prove this? Informally, “tying the knot” requires applying something to itself, which is obviously an infinite type, but I can't seem to find a satisfying reason for why I can't tie the knot without requiring (\x -> x x)
22:22:42 <wespiser> have you looked into Free Monads?
22:23:21 <haasn> I guess maybe the key point is that to get a recursion, you have to be able to access yourself; which requires strictly more than simply accessing a “previous” member of an already infinite stack (like with the functions you pass *to* the y combinator)
22:24:50 <wespiser> is there a way to implement the y combinator with only implementing the previous or next?
22:25:15 <wespiser> maybe this will help: https://aherrmann.github.io/programming/2016/05/28/mutual-recursion-in-final-encoding/
22:25:21 <wespiser> i'm not sure I fully understand
22:28:40 <mniip> haasn, it follows from typed lambda calculus always terminating
22:30:48 <haasn> mniip: Thanks. That's an easy proof
22:31:00 <haasn> Although not as constructive as I would have hoped :)
22:31:05 <orzo> codygman: pure $ filter ( (>= today) . addDays 30 . signupDate ) signups
22:31:12 <mniip> you're proving absence
22:31:16 <mniip> what did you expect
22:31:32 <orzo> hmm, i forgot to add localDay in there
22:33:05 <haasn> mniip: If I'm gaining intuition correctly; adding infinite types regains the full power of the untyped lambda calculus in the typed lambda calculus? (since you can e.g. embed y using newtypes)
22:33:16 <mniip> yes
22:33:16 <haasn> I guess it makes sense since you can just embed T = (T -> T) with infinite types
22:33:30 <haasn> so you have the entire family of lambda functions
22:34:17 <codygman> orzo: No problem, I think I'm wanting more along the lines of time-lens
22:34:25 <codygman> even then though, date stuff is a bit wordy :/
22:35:12 <orzo> codygman: if you are moved to use an alternate time library altogether, take a look at the hourglass package
22:35:23 <orzo> it is used by a lot of crypto libraries
22:35:43 <codygman> How can I get (- 30) to act like "minus" in the way that (+ 30) is a function from Num a => a -> a? Do I *have* to make a lambda?
22:36:12 <codygman> orzo: Thanks, I know there were some weird corner cases not handled totally correctly last I checked... but for my current use case those wouldn't matter I don't think
22:36:29 <codygman> :t (+ 30)
22:36:31 <lambdabot> Num a => a -> a
22:36:34 <codygman> :t (- 30)
22:36:36 <lambdabot> Num a => a
22:36:47 <codygman> :t ((flip (-)) 30)
22:36:49 <lambdabot> Num c => c -> c
22:36:51 <codygman> haha
22:37:01 <codygman> that's less convenient than the lambda tho
22:37:22 <codygman> :t (`-` 30)
22:37:25 <lambdabot> error: parse error on input ‘-’
22:37:57 <codygman> ah I think best I can do is
22:38:06 <codygman> :t (subtract 30)
22:38:07 <lambdabot> Num a => a -> a
22:38:38 <orzo> you could just make your times be PosixTime and multiply 30 by 24*60*60
22:38:57 <orzo> Data.Time.Clock.POSIX
23:03:42 <sshine> davean, sure, Haskellers can kill trolls. their actions just happen to be first-class citizens, unlike trolls! :-P
23:04:48 <Axman6> :o
23:05:18 <nshepperd> unsafePerformIO killTrolls
23:08:17 <codygman> Hey orzo, do you know the hourglass equivalent of getCurrentTime?
23:10:40 <Schoolmeister> Hey, I've got a question. I'm writing a small parser (school assignment). Atm I've got a data declaration for arithmetic expressions declared as "data ArExp = Lit Int | ArExp ArOperator ArExp"
23:11:09 <Schoolmeister> Now, is it possible to declare the ArOperator data type with symbols only?
23:11:43 <Schoolmeister> I could do "data ArOperator = Plus | Minus | ..." but really I'd prefer to havee something like "data ArOperator = :+: | :-: | ..."
23:11:47 <Axman6> Schoolmeister: what do you mean?
23:12:11 <Axman6> oh, no, constructors starting with : must be infix IIRC
23:12:27 <Schoolmeister> Oh, so if I took anything else than : I'd be OK?
23:13:25 <Axman6> you don't have much choice here. wither you use : to make an infix constructor, or you use [A-Z][a-zA-Z0-9'*
23:14:07 <Axman6> @let data Foo = :+ | :* 
23:14:07 <lambdabot>  Parse failed: Parse error: :+
23:14:55 <Schoolmeister> Hm, I think I'll just write them infix then. Thanks!
23:15:15 <orzo> codygman: dateCurrent
23:15:35 <Axman6> I don't think you can write them infix
23:16:13 <Schoolmeister> I meant like this
23:16:37 <Schoolmeister> @let data ArExp = Lit Int | ArExp :+: ArExp | ArExp :-: ArExp
23:16:40 <lambdabot>  Defined.
23:16:48 <Axman6> right, that works
23:31:35 <codygman> orzo: Thanks
