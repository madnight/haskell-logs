00:00:13 <xocolatl> cocreature: would you just use lists for this, or something else?  I've been only using lists (because that's what I know) but that makes some of my solutions slooooow.
00:01:26 <cocreature> xocolatl: I would probably use a vector of unboxed booleans to represent the fields
00:01:36 <cocreature> xocolatl: then you just need a breadth-first search
00:02:06 <xocolatl> unfortunately, I have no idea what that is (a vector of unboxed booleans)
00:02:23 <cocreature> xocolatl: are you familiar with vectors/arrays in other languages?
00:02:36 <xocolatl> arrays yes
00:02:57 <xocolatl> the language I'm most proficient in is delphi/pascal
00:03:32 <cocreature> so the difference between arrays and lists is that the elements in array are in a single contiguous chunk of memory
00:03:42 <cocreature> that makes accesses and traversal significantly faster in most cases
00:05:11 <cocreature> in a boxed vector, you are actually storing a vector of pointers that point to each object
00:05:35 <pavonia> xocolatl: As opposed to others, this one can be easily solved using a simple list-based brute force algorithm
00:05:47 <cocreature> in an unboxed vector, you are storing the actual elements in the chunk of memory
00:06:35 <xocolatl> cocreature: that's probably the best explanation of boxing I've seen so far.  thanks!
00:06:59 <xocolatl> not used to thinking about pointers in haskell (but very familiar with them in pascal)
00:07:24 <cocreature> a boxed vector would work two, but for each access you need to follow a pointer
00:07:31 <cocreature> so that can potentially be slower
00:07:33 <xocolatl> pavonia: okay, I'll try with lists, and then see if I can perfect it with this vector of unboxed booleans business
00:09:50 <xocolatl> cocreature: so what's the difference between a vector and an array?
00:10:13 <cocreature> xocolatl: nothing really, at least not in general
00:10:27 <cocreature> xocolatl: the "vector" package in haskell, provides the arrays you are used to
00:10:43 <cocreature> c++ vectors are arrays that you can append to
00:10:50 <cocreature> so the usage of these terms is a bit inconsistent
00:11:37 <xocolatl> so when I want what I know of as an array, I should use Data.Vector?
00:12:17 <cocreature> yep, there is also an "array" package but imho there is very little reason to use it over Data.Vector
00:12:25 <xocolatl> thanks
00:12:41 <cocreature> xocolatl: there is also Data.Vector.Mutable, Data.Vector.Unboxed and Data.Vector.Unboxed.Mutable
00:13:07 <cocreature> all from the vector package
00:22:31 <fresheyeball> what do you call a Lens where the Setter is guaranteed to succeed, but Getting might fail?
00:25:16 <cocreature> fresheyeball: do you have an example of that?
00:27:25 <fresheyeball> cocreature: sure, how about a Maybe
00:27:32 <fresheyeball> I
00:27:54 <fresheyeball> I'm looking for something like :: Lens' Maybe Int
00:30:45 <fresheyeball> I think it might be Prism
00:30:46 <cocreature> what you can get is a "Prism' (Maybe Int) Int", but calling "set" on a Nothing will not do anything
00:30:59 <cocreature> you can however use review to get a Just
00:31:15 <fresheyeball> I want to setting to always be a Just
00:31:26 <fresheyeball> and getting to sometimes be a Nothing
00:31:39 <cocreature> I don’t think something like that exists
00:32:29 <fresheyeball> oh Review looks right!
00:33:20 <cocreature> if it is great, but it is not "set" it constructs a completely new value rather than setting parts of an existing value (and returning a new value)
00:33:41 <fresheyeball> oh hmm
00:34:09 <fresheyeball> let me be more clear as to what I am trying to do
00:34:37 <fresheyeball> and I warn you, it's dumb and entirely for the sake of aesthetics 
00:34:54 <fresheyeball> I have a piece of code like this:
00:35:40 <fresheyeball> def & foo .~ 3 & baz 9 & bar .~ "b" 
00:36:02 <bollu> quick category theory question: how is D^C x C -> D a bi-function? (if I bi-functor is "f a b", what is the "a" and the "b" in this case? I don't see it)
00:36:21 <bollu> Cale, monochrom, EvanR, anybody :) ^
00:36:29 <bollu> bi-functor*
00:36:40 <fresheyeball> foo :: Lens' B Int, baz :: Int -> B -> B, bar :: Lens' B String
00:36:49 <fresheyeball> I find the incongruity with baz annoying
00:37:11 <fresheyeball> it bothers me that the other things are being set with lenses, but not baz
00:37:40 <fresheyeball> and I can't write a Lens' for baz, because it involves constructing a custom data type
00:37:49 <fresheyeball> I'm new to Lens, and its vast
00:38:01 <fresheyeball> so I figured I'd look and see if there was a thing that fit this usecase
00:38:31 <fresheyeball> cocreature: what do you think?
00:40:55 <cocreature> fresheyeball: there is none, lens does not really target usecases "entirely for the sake of aesthetics". you can write a Setting if that’s all you care about, but tbh just using a standard function seems like the best solution.
00:41:49 <fresheyeball> well sure, aesthetics is what is bothering me
00:42:14 <fresheyeball> but I think its useful to be able to set without a guaranteed get
00:42:14 <cocreature> Lens is for things that decompose as products and operating on one part of them, Prisms are for things that decompose as sums and operating on one part of them
00:42:41 <cocreature> you are trying to have something that can be decomposed as a sum, but "set" should operate on a part that’s not present
00:43:13 <cocreature> it is kind of unclear to me, what rules such a thing should obey
00:43:49 <dmwit> bollu: I suspect you have left out some notation or wording.
00:44:00 <bollu> dmwit: have I? it is from the paper "F is for functor"
00:44:32 <cocreature> bollu: what are D and C? categories? objects?
00:44:41 <bollu> cocreature: categories from what I undersatnd
00:44:45 <bollu> understand*
00:44:49 <dmwit> bollu: Okay, I've opened that paper. Where should I look?
00:44:50 <fresheyeball> Ok, so in Monocle they call these Optionals
00:44:55 <fresheyeball> but I'm not in Scala
00:45:35 <bollu> dmwit: end of page 4
00:45:43 <bollu> dmwit: "… so functor application is a bifunctor. "
00:45:58 <dmwit> bollu: Yes, why did you leave out those words?
00:46:11 <dmwit> "D^C X C -> D" isn't the bifunctor, "functor application" is.
00:46:30 <bollu> dmwit: ah
00:46:31 <fresheyeball> cocreature: https://julien-truffaut.github.io/Monocle/optics/optional.html is this not in Haskell's Lens library?
00:46:31 <dmwit> "D^C X C -> D" is just the "type" of functor application.
00:46:47 <bollu> dmwit: oh
00:46:57 <fresheyeball> cocreature: ok, no I am wrong
00:47:00 <fresheyeball> I see it now
00:47:02 <fresheyeball> ok
00:47:21 <cocreature> fresheyeball: afaik it doesn’t exist, but you might have more luck asking in #haskell-lens
00:47:28 <bollu> dmwit: so, what would "dimap" be?
00:47:45 <cocreature> bimap, dimap is for profunctors :)
00:47:49 <bollu> oh
00:48:13 <bollu> cocreature: am I confused? https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
00:48:30 <cocreature> bollu: it’s called "bimap" there as well, no?
00:48:34 <bollu> cocreature: it seems like "bimap" can define a bifunctor
00:48:43 <bollu> cocreature: right, not "di"map. dang it!
00:48:43 <cocreature> bollu: sure but you said "dimap"
00:48:46 <bollu> xD
00:48:50 <cocreature> which is also a thing, but a different one :)
00:48:51 <bollu> cocreature: right, my bad
00:49:40 <bollu> cocreature: okay, so in this case, if I wanted to encode it as a haskell type, would it be: data F c d = F { (c -> d) -> c -> d) } ? 
00:49:48 <bollu> cocreature: "instance Bifunctor f where …."
00:49:50 <bollu> cocreature: ?
00:50:45 <dmwit> bollu: Aren't the next few paragraphs in that paper explaining what bimap does?
00:52:16 <bollu> dmwit: I don't understand what exactly it's trying to say (and it's less than a paragraph right? after that it moves on to abstraction)
00:52:46 <bollu> dmwit: like, how does "figuring out the bifunctor structure" from the mono-functor instances work?
00:52:47 <dmwit> The explanation extends about halfway into the first column on page 5.
00:53:29 <Lokathor> http://lpaste.net/350055 how decadent
00:53:31 <bollu> dmwit: I got the part with the natural transformations and the "individual" slices of the partially applied functors
00:53:42 <bollu> dmwit: but I still don't get how it is "put together" to form a bifunctor
00:54:10 <cocreature> bollu: the deduction rules at the top of page 5 are probably the most useful part
00:54:56 <bollu> cocreature: isn't that "natural transformations" part? it doesn't give me the whole picture, does it? or am I reading it wrong?
00:55:09 <cocreature> bollu: so D^C are _functors_ from C to D
00:55:38 <dmwit> I'm not really awake enough to explain this well. =(
00:55:39 <cocreature> you can apply a functor to an object in C
00:55:59 <bollu> cocreature: right. as is C -> D. so, I don't get how you can "put this together" to get a bifunctor D^C x C -> D  :(
00:56:06 <bollu> cocreature: OK, go on
00:56:13 <cocreature> so given F:D^C and A:C, you get F A :D
00:57:16 <bollu> cocreature: yes :) and the coherence conditions force you to the the "natural transformation arrows" .
00:57:26 <bollu> cocreature: BUT, now how do you construct a _bifunctor_?
00:57:40 <cocreature> bollu: what do you mean by _construct_?
00:57:47 <cocreature> you have a functor from a product category
00:58:02 <cocreature> now you just need to verify what happens with arrows in the left and the right argument
00:58:52 <bollu> cocreature: okay, I'm missing something. the fact that I have the individual "components" of the functors automatically gives me a functor on the product category?
00:58:58 <cocreature> bollu: you can’t make that an instance of the Haskell bifunctor type class, if that’s what you’re asking
00:59:30 <bollu> cocreature: yes, that was what I was wondering if I could. but why can I not?
01:00:18 <cocreature> bollu: because you can’t express the category of functors D^C in haskell
01:00:28 <bollu> cocreature: ah
01:01:01 <cocreature> maybe you could make something like Hask^Hask × Hask → Hask
01:01:24 <bollu> cocreature: ok
01:02:33 <bollu> cocreature: so, if I have C x D -> E, given two functors C -> E and D -> E, to become a "bifunctor", I just need to check if the individual functors are "compatible"?
01:03:00 <mniip> cocreature, sure can
01:03:10 <cocreature> mniip: oh, how so?
01:03:16 <mniip> not with the stock Functor class of course
01:03:32 <cocreature> well then you also can’t use the stock Bifunctor class, can you? :)
01:03:36 <mniip> right
01:03:37 <cocreature> which is what I was trying to say
01:04:46 <bollu> cocreature: can I go through the "checking if the bifunctorality" holds ?
01:05:16 <bollu> cocreature: let's say given F: C -> E, G: D -> E, I'm trying to construct a bifunctor H: C x D -> E
01:05:48 <cocreature> bollu: so given C × D → E, you need to look at the functors where you fix an object A : C, A × _ → E and the symmetric one for D and verify that these are functors. then you need to verify that if you need to verify that the composition is also a functor, i.e. respects composition and identity
01:06:07 <cocreature> bollu: sorry I need to do some work now
01:06:18 <bollu> cocreature: ok np :) I'll try and take it from here. thanks for the help
01:16:02 <thepreacher> I'm really between Programming in Haskell 2nd Edition (PiH) and Haskell Programming from first principles. Unfortunately try both and see which one works will not cut it here as both cost money. PiH also claims explain everything from first principles and no programming experience is required and yet its only 300 pages while HaskellBook is 1000pages. I've look at both of the table of content and Haskell
01:16:02 <thepreacher> Book has a couple of chapters not in PiH but by-and-large they cover this same things. How do I decide. Like I said HaskellBook is going to cost me $79 (i'm in the UK) while PiG is £30 (amazon uk).  
01:16:45 <sbrg> thepreacher: If money is an issue wrt HaskellBook, you should try contacting the author via email
01:37:25 <bollu1> haskell has ruined me :P I'm literally printing out all the functional pearls I have "for fun"
01:38:58 <opqdonut> tsk tsk, printing is a side effect
01:39:00 <opqdonut> :P
01:39:01 <sbrg> lol
01:39:06 <sbrg> bollu1: functional pearls?
01:39:47 <b0llu> sbrg: yeah, like, small articles that show you how to do cute things :)
01:39:53 <sbrg> aah cool
01:39:59 <b0llu> sbrg: 
01:40:00 <b0llu> https://wiki.haskell.org/Research_papers/Functional_pearls
01:41:37 <sbrg> aaah yeah those
01:41:54 <sbrg> thanks, now I have something to do this morning
01:53:18 <ongy> opqdonut: reading has side effects since it stores things permanantly, just not reliably :(
02:04:35 <shadej> I have never tried haskell: can anyone help me convert this program: http://pastebin.com/Dgm3EnLf
02:04:55 <shadej> to c, c++,java, js, groovy?
02:05:42 <b0llu> shadej: what is the code trying to do?
02:06:18 <opqdonut> shadej: that's a definition of a recursive number sequence
02:06:26 <opqdonut> shadej: looks fairly complicated
02:06:36 <shadej> b0llu http://oeis.org/A002858 , generating ulam numbers
02:07:11 <shadej> opqdonut: yeah I studied few resource on haskel but cant understand it :(
02:07:52 <opqdonut> shadej: so the element n in a002858_list is gotten by applying f to the n-1 first elements
02:08:41 <opqdonut> shadej: and f is this function with five cases it seems
02:08:56 <shadej> ok am following
02:09:19 <lyxia> the definition of the sequence is so much clearer
02:09:38 <opqdonut> shadej: it somehow seems to me this code is more complicated then it needs to. for instance I think u' = last us' so it doesn't need to be tracked differently
02:10:28 <opqdonut> yeah there should be a simpler definition that's closer to the mathematical one
02:10:41 <shadej> opqdonut: do you know ulam sequence? the definition of the problem is very simple as lyxia said it
02:10:55 <opqdonut> yeah
02:12:10 <lyxia> shadej: I just read it on oeis
02:15:39 <lyxia> shadej: why isn't 9=6+3 in the sequence
02:15:56 <opqdonut> because it
02:15:59 <lyxia> because it's also 8+1?
02:16:03 <opqdonut> 's also 6+2+1?
02:16:06 <opqdonut> oh right 8+1
02:16:12 <opqdonut> yeah. _two_ terms
02:16:56 <jgt> Hello Haskellers. How do I find out why my program has high memory usage? I can make guesses, but I want to actually measure.
02:17:27 <jgt> and I don't think this is a leak; it doesn't gradually increase over time
02:17:35 <cocreature> jgt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage
02:17:50 <shadej> sorry was fk
02:17:55 <shadej> *was afk
02:18:01 <lyxia> I now understand why the first argument of f being trivalued makes sense.
02:18:04 <shadej> yeah opqdonutis right
02:18:20 <lyxia> but I also think it could be better written somehow
02:18:38 <opqdonut> yeah
02:19:04 <jgt> cocreature: this documentation hints at using that method to find space leaks. Would it also work for just finding high memory usage that isn't a leak?
02:19:12 <shadej> lyxia: can you write the code in c, c++, java?
02:19:19 <shadej> so that I can understand it
02:19:27 <cocreature> jgt: sure 
02:19:43 <cocreature> jgt: it tells you what parts of your program are using memory. what you use that info for is up to you :)
02:20:03 <jgt> ok, that's helpful. Thanks!
02:20:08 <cocreature> what exactly "parts of your program" means depends on the exact profiling options you use
02:20:21 <cocreature> e.g. you can profile by types, cost-centres, …
02:22:05 <jgt> hmm… This seems currently beyond me. I don't know what a cost-centre is in this context.
02:24:43 <jgt> I thought that to compile my program for profiling, I should do `stack build --ghc-options -rtsopts`
02:26:37 <jgt> …and the command `stack build --ghc-options -rtsopts -prof --force-dirty` fails with “Invalid option `-prof'”
02:28:13 <sbrg> jgt: I think it's `--ghc-options='-rtsopts -prof'`
02:28:22 <sbrg> but I think you should just do `stack build --profiling` or some such
02:29:02 <shadej> can anyone help convert this: http://pastebin.com/Dgm3EnLf to one of this [c, c++, java, js, groovy]?
02:29:48 <jgt> sbrg: I see. Thanks for that. Trying it with quotes does indeed produce “When building with stack, you should not use the -prof GHC option; Instead, please use --library-profiling and --executable-profiling”
02:30:30 <sbrg> yeah, I remember that
02:30:44 <sbrg> but I also remember doing the same you did, because profiling support wasn't very good at the time.
02:31:10 <sbrg> if you had non-LTS dependencies, switching between profiling and non-profiling would rebuild those from scratch. it was very painful. not sure if they improved that
02:33:52 <jgt> `stack build --library-profiling --executable-profiling`… “Progress: 1/186”.
02:33:55 <jgt> Oh goodie…
02:34:15 <jgt> I'm glad this café has good coffee
02:34:23 <ezyang> and power too, right? :) 
02:34:28 <jgt> haha yes
03:13:26 <Aleksejs> Why all f [] is always True?
03:17:48 <EvanR> @src all
03:17:48 <lambdabot> all p = and . map p
03:17:58 <EvanR> @src and
03:17:58 <lambdabot> and = foldr (&&) True
03:18:49 <Xnuk> @src (-)
03:18:49 <lambdabot> x - y = x + negate y
03:18:53 <Xnuk> @src (+)
03:18:53 <lambdabot> Source not found. Wrong!  You cheating scum!
03:19:12 <Xnuk> um okay
03:19:14 <Aleksejs> yes, but should it be so? Wouldn't it be better with all [] = False; all p = and . map p ?
03:19:20 <EvanR> (+) is a class method
03:20:07 <EvanR> Aleksejs: as is conventional in math "for all elements of the empty set, P." is vacuously true, since there arent any. to say its false would require a counter example
03:22:30 <EvanR> and in real situations True is definitely more convenient
03:24:39 <lyxia> it also makes a nice equation hold: all (xs ++ ys) = all xs && all ys
03:25:02 <lyxia> otherwise you would need the condition "if xs and ys are not empty"
03:26:54 <lyxia> something something monoid homomorphism
03:32:07 <cloudhead> is there a function I can use to convert a foldable to a vector directly? I'm currently doing Vector.fromList . Foldable.toList, but not sure if that'll get optimized
03:41:17 <AndreasK>  cloudhead: I would expect that to depend on the implementation of toList for your instance
03:42:36 <bollu> cocreature: can you check if my definition of the "compose" bifunctor is correct? https://photos.google.com/share/AF1QipNLfvdcjhZ0QQrbieZnfegIi7uBa1PbO81EYTUE_O8eQ7D4xL57Y56LT4MbtTwJLw?key=ZmpjUXdwODZiRzVZc2xMX3FiSGd6QmRTSFZFWU53
03:44:31 <bollu> monochrom^ well, any category theory person :)
03:45:56 <AndreasK> Whats a good way to get syntax highlighting for core/stg dumps?
03:50:01 <cloudhead> AndreasK: right so you're saying there's no generic function that would short-circuit it
03:55:13 <AndreasK> cloudhead: At least I haven't come across one, there is unfoldr but it requires you to write your own decomposition function as well so that might end up being worse...
03:55:38 <ocramz> hullo
03:57:24 <jgt> how do I install hp2ps? Maybe I'm being stupid here, but I can't do `stack install hp2ps`
04:00:08 <cocreature> jgt: it’s bundled with ghc. I guess with stack, "stack exec hp2ps" should work
04:02:59 <jgt> cocreature: ah, ok. Works with `stack exec -- hp2ps <filename>`. Is this made obvious anywhere? I am a bit lazy and obtuse and often don't RTFM, but where would I have normally learned this if not from chatting on IRC?
04:03:21 <jgt> (again, thanks very much!)
04:03:23 <cocreature> jgt: no idea
04:03:31 <cocreature> I haven’t read a lot of the stack docs :)
04:08:37 <jgt> oooooo… The graph it produced wasn't at all what I was expecting. http://imgur.com/a/jYnpc
04:09:19 <stefan-__> is there a package for sparse vectors, which are indexed by integer?
04:09:41 <cocreature> jgt: ftr you can pass "-c" to hp2ps and it will use colored output instead of sticking to greyscale
04:10:29 <jgt> and I tried profiling last night on my development VM, compiling with -rtsopts and running with +RTS -sstderr, and it showed total memory usage of 458MB
04:10:59 <jgt> but in _production_ the memory usage goes so high on a 4GB machine, that my program crashes
04:11:12 <jgt> it's a Yesod app, deployed with Keter
04:11:24 <jgt> I wonder if it's actually Keter causing problems, and not my app
04:12:20 <cocreature> 160mb for a webapp seems already relatively large, do you know why it’s so high?
04:14:18 <jgt> I throw about 150 requests at it all at once, and each one of those requests runs a webscraper
04:14:30 <cocreature> ah ok
04:14:36 <cocreature> I guess that also explains the spikes
04:14:50 <jgt> I'm using Scalpel for scraping, and I *think* it may use a bunch of memory because it uses strings? But I'm just guessing here, and I want to avoid guessing
04:15:50 <cocreature> jgt: you can break down your profile by type
04:15:55 <cocreature> -hy iirc
04:16:05 <jgt> cocreature: 160mb is probably reasonable for all those requests and the scraping, right? Or no?
04:16:29 <cocreature> jgt: I know too little about your application to answer that but it could be, yeah
04:16:41 <jgt> what I can't understand is why it's so much higher in production
04:17:55 <cocreature> you have the same number of requests on your production server?
04:18:00 <jgt> yes
04:18:04 <cocreature> weird
04:18:49 <jgt> I tried running valgrind on my production server, and it showed a memory leak in Keter
04:19:03 <jgt> but I'm not sure if this is significant, and I'm also not sure I'm doing it properly
04:19:57 <jgt> but Keter _could_ be the culprit, because that's the main difference between development and production, I think
04:20:18 <cocreature> I’ve never worked with keter or yesod so I can’t help you with your specific problem, sorry
04:20:41 <jgt> that's ok, you've already been a huge help. Thanks again!
04:21:17 <jgt> heading off for a haircut. Ciao!
04:21:36 <cocreature> ttyl :)
04:56:10 <shadej> can anyone help me convert this haskel snippet to java, c, c++, groovy?
04:56:24 <shadej> http://pastebin.com/DRSAavRc
05:01:04 <sras> What is the advantages of splitting a Stack application into multiple packages...?
05:09:22 <lyxia> to reuse parts of it without depending on the whole application
05:15:32 <sras> lyxia: Anything other than code reuse..How does it effect build times? 
05:15:56 <cocreature> afaik only negatively
05:16:12 <cocreature> splitting things in modules can have a positive effect on build times
05:16:17 <cocreature> but splitting modules in packages doesn’t help
05:17:35 <shadej> I never worked on haskel. can anyone help me with this program
05:17:35 <shadej> http://pastebin.com/DRSAavRc
05:17:54 <cocreature> shadej: where are you having trouble?
05:18:08 <cocreature> shadej: if you’ve never worked with haskell, reading some introductory text is probably the best
05:19:44 <shadej> cocreature: you right but am analyzing an algorithm and want to just check the running time. I mean I dont have the intention to work on haskel. 
05:20:09 <shadej> can you help me converting to one of the C style lng like java, c++ etc
05:22:12 <c_wraith> shadej: haskell doesn't really convert to languages without the same features.  It's too different.  Might as well just start from the problem description again.
05:23:01 <shadej> hah really?
05:24:23 <cocreature> this looks like a project euler exercise so you can probably find solutions in all the languages you are interested in pretty easily, no?
05:24:33 <c_wraith> You can use the code as an algorithm description, but it's not going to map to an (idiomatic) implementation in an algol-derived language
05:26:09 <c_wraith> still, I could make the code not look like it's from an obfuscated coding contest.
05:26:17 <c_wraith> That's some truly awful sample code
05:28:05 <shadej> c_wraith: ok, how can I get the solution in other lang?
05:28:29 <c_wraith> in any other language, that'd be a triply-nested loop
05:30:25 <c_wraith> that is utterly bizarre code.  (e - p) * d  doesn't look like an interesting number
05:31:17 <LordBrain> i just walked in and havent seen what you're commenting on but.. i'm already skeptical that you aren't issuing hyperbole
05:32:12 <c_wraith> I mean, it's just basic (if bignumber) arithmetic in a big nested loop, but none of those expressions are common.
05:32:15 <LordBrain> so where can i look at the "bizarre code"
05:32:24 <c_wraith> http://pastebin.com/DRSAavRc
05:33:08 <LordBrain> does that parse? it needs a space doesnt it? between sum and [
05:33:13 <c_wraith> no
05:33:33 <c_wraith> [ isn't an identifier character.
05:33:49 <c_wraith> > sum[1..10]
05:33:52 <lambdabot>  55
05:35:17 <LordBrain> okay
05:35:41 <LordBrain> well i think it is better with a space, albeit a mere stylistic preference
05:36:59 <c_wraith> shadej: so the first thing you need to do is choose a language with big integers.  10^99 is a bit outside the range of a 32- or 64-bit integer
05:37:31 <shadej> c_wraith: I think I got the hint
05:38:14 <LordBrain> indeed
05:38:19 <c_wraith> shadej: It's not an impossible thing to translate.  The code uses basically no interesting haskell features, unless you count list comprehension or big integers as interesting.
05:38:33 <LordBrain> i think blogs and clickbaitiness have affected our culture
05:38:58 <shadej> yeah this is the problem btw
05:38:59 <shadej> https://projecteuler.net/problem=167
05:40:03 <c_wraith> that's odd.  the problem itself claims it's 168. :)
05:40:24 <cocreature> 0 vs 1 based indices :)
05:40:49 <LordBrain> hmm i read it but didn't spot the claim of 168
05:40:56 <LordBrain> where did it do that?
05:41:23 <cocreature> the code shown by shadej uses 168
05:41:40 <c_wraith> the function is named problem_168
05:42:10 <LordBrain> oh i see
05:42:10 <shadej> yeah that is odd
05:42:32 <c_wraith> In any case, some heavy-duty math was used to convert that problem to that solution.
05:42:38 <c_wraith> Which is normal for project euler
05:44:12 <jgt> I'm running my app with +RTS -hy, but what does [] mean here? http://imgur.com/a/5xcna
05:44:32 <c_wraith> jgt: memory used by list constructors
05:45:04 <jgt> ah… which could be strings!
05:45:07 <cocreature> c_wraith: is it both list constructors or is (:) treated separately? I always forget that part
05:45:08 <c_wraith> yes
05:45:19 <c_wraith> cocreature: it shows the type, not the constructor itself
05:45:28 <cocreature> thanks
05:45:28 <c_wraith> there's only one [] constructor in memory. :)
05:45:35 <cocreature> heh, good point
05:46:07 <jgt> I think this validates my suspicion that the scraping library I'm using is not as performant as it could be because it's using strings
05:47:13 <c_wraith> the shape of that profile suggests lots of small batches being processed
05:47:29 <c_wraith> The Y axis says that data is being retained, rather than streamed
05:47:44 <c_wraith> But it doesn't indicate whether that's a bug or not. :)
05:48:51 <jgt> c_wraith: I don't think it's a bug (could be shitty design on my part though!). I'm throwing ~150 requests at my application (a web app). Each request runs a webscraper, which curls a webpage and parses the result
05:50:09 <cocreature> maybe the bug is running the webscraper on each request rather than running it periodically and caching the result but that obviously requires that you scrape the same (set of) website(s)
05:51:06 <c_wraith> I'd say the large amount of position data implies that it's definitely the parser that's resulting in the big spikes
05:51:35 <jgt> yeah, perhaps caching scrape results would be a better design
05:52:45 <jgt> and yes, I'm now quite confident that parsing web pages as strings is not ideal. Maybe I'll open a issue on that project's repo
05:53:14 <cocreature> jgt: you are using scalpel, right?
05:53:46 <jgt> cocreature: yes
05:54:02 <cocreature> at least from the outside that looks like it is mostly polymorphic in the string type
05:55:26 <cocreature> so if you have a "Scraper Text a" rather than a "Scraper String a" it should use Text
05:55:32 <jgt> oh right
05:55:43 <cocreature> at least on the interface it presents to the user, whether it is all String internally I don’t know
05:56:17 <jgt> I'll try making that change and then profiling again
05:56:34 <jgt> that may take a long time though if I have to build everything from scratch again
05:56:43 <jgt> long time = ~1h
05:56:54 <cocreature> ouch
05:57:04 <cocreature> why do you need to build everything from scratch?
05:57:57 <jgt> I'm not sure if I need to, but it decided to rebuild everything when adding the --library-profiling and --executable-profiling flags to stack build
05:58:17 <cocreature> that should only happen once
05:58:24 <cocreature> enabling profiling requires recompilation
05:58:25 <c_wraith> that wasn't recompiling so much as building a second version
06:30:53 <kuribas> @hoogle [a] -> [a] -> [a]
06:30:57 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:30:57 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:30:57 <lambdabot> GHC.OldList (++) :: [a] -> [a] -> [a]
06:31:11 <kuribas> is there a function for interleaving lists?
06:31:59 <Rembane> kuribas: zip xs $ tail xs
06:32:10 <kuribas> ok thanks!
06:32:28 <kuribas> erm wait, that doesn't do interleaving
06:32:30 <Rembane> kuribas: If you want to interleave one list with itself that is.
06:32:42 <kuribas> Rembane: that's zip, not interleave
06:33:38 <Rembane> kuribas: concat $ zipWith (++) $ map pure xs $ map pure ys
06:33:56 <kuribas> interleave [1, 2, 3] [4, 5, 6, 7] => [1, 4, 2, 5, 3, 6, 7]
06:34:35 <kuribas> > let interleave xs ys = concat $ zipWith (++) $ map pure xs $ map pure ys in interleave [1, 2, 3] [4, 5, 6, 7]
06:34:37 <lambdabot>  error:
06:34:37 <lambdabot>      • Couldn't match expected type ‘[f1 a3] -> [[a1]]’
06:34:37 <lambdabot>                    with actual type ‘[f0 a2]’
06:34:43 <Rembane> Hm...
06:34:52 <Rembane> Maybe I should typecheck my advice first
06:36:08 <kuribas> > let interleave [] xs = xs; interleave xs [] = l; interleave (x:xs) (y:ys) = x:y:interleave xs ys in interleave [1, 2, 3] [4, 5, 6, 7]
06:36:10 <lambdabot>  error:
06:36:10 <lambdabot>      • Couldn't match expected type ‘[a1]’ with actual type ‘Expr’
06:36:10 <lambdabot>      • In the expression: l
06:36:50 <kuribas> > let interleave [] xs = xs; interleave xs [] = xs; interleave (x:xs) (y:ys) = x:y:interleave xs ys in interleave [1, 2, 3] [4, 5, 6, 7]
06:36:52 <lambdabot>  [1,4,2,5,3,6,7]
06:37:05 <kuribas> I thought in might be defined somewhere
06:37:37 <Gurkenglas> > concat . transpose $ [[1..10],[101,110]] -- kuribas
06:37:39 <lambdabot>  [1,101,2,110,3,4,5,6,7,8,9,10]
06:37:58 <Gurkenglas> Umm well you get the idea
06:38:03 <Tuplanolla> I've looked for that thing before, kuribas, as well as `merge`, `selections` and lexicographic `permutations`.
06:38:17 <Gurkenglas> (I did check lambdabot with the typechecking first :P)
06:38:23 <kuribas> Gurkenglas: nice
06:39:18 <Tuplanolla> I think they should be in `base` along with integer roots, logarithms and other common combinatorial functions.
06:40:16 <kuribas> yeah
06:42:41 <defanor> i've just noticed that one of my programs (compiled with ghc 8.0.1) appears to allocate 1.000t of memory (virt), right from the beginning, though actual memory consumption is modest. now i just wonder what causes that; it uses a few things that other programs don't use, like pipes, pipes-concurrency, stm; could those cause such a behaviour?
06:43:03 <Tuplanolla> It's a new GHC feature, defanor.
06:43:24 <defanor> Tuplanolla: oh, maybe i just didn't recompile other programs, then. thanks, will look it up
06:44:46 <lordcirth> Tuplanolla, what's the purpose of the feature?
06:44:56 <lordcirth> Faster to use the memory later?
06:45:14 <Tuplanolla> It makes memory block management more efficient or something. I don't remember.
06:45:31 <defanor> yup, found it -- <https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system>
07:01:53 <nshepperd> hm, turns out doing A* for aoc #17 was silly and no faster than breadth first
07:02:26 <amx> breadth-first is my nemesis du jour
07:06:18 <nshepperd> nemesis of the day
07:06:45 <nshepperd> it's a little bit fiddly, usually
07:07:02 <amx> still stuck on #11, I thought doing BFS and cutting off known branches should do the trick
07:07:04 <nshepperd> which probably means the types aren't general enough yet
07:07:22 <amx> but it's been running for an hour so I guess not :)
07:08:51 <nshepperd> heh, I just optimized the BFS really hard for #11
07:09:04 <nshepperd> maybe A* would have helped there
07:11:10 <nshepperd> using the time it would take to carry stuff ignoring radiation as heuristic
07:15:36 <abhiroop> Has anyone worked with Cloud Haskell here?
07:16:58 <Benzi-Junior> hey I am looking for a method to "change" one element of a non mutable vector, and before anyone starts lecturing me on the meaning of "mutable" this doesn't have to happen in place or even be O(1) it just has to give me the same vector with one element changed 
07:18:35 <Benzi-Junior> I know how to do it for lists but was hoping there was a better way than (fromList . changeList . toList)
07:19:01 <Tuplanolla> :t Data.Vector.update
07:19:03 <lambdabot> Data.Vector.Vector a -> Data.Vector.Vector (Int, a) -> Data.Vector.Vector a
07:19:22 <jml> is it possible to restrict the values of type-level string literals such that certain symbols will fail to compile?
07:19:50 <quchen> jml: Use TH?
07:20:22 <quchen> Other than that, I don’t think there’s an easy way.
07:20:24 <Benzi-Junior> Tuplanolla: yes that would be exactly what I was looking for thanks
07:20:57 <quchen> jml: Making some symbols compile by looking them up in a list is easier
07:21:03 <quchen> jml: Servant is based on that
07:21:42 <jml> here I want a regex, so a list wouldn't work terribly well.
07:21:48 <jml> quchen: thanks
07:35:13 * kuribas wishes negate literals wouldn't need parens.
07:38:59 <Welkin> o.o
07:40:53 <LordBrain> What's the best tools to scrape a column from a table out of a web page?
07:41:46 <LordBrain> i wish we didn't have such a thing as static tables... every html page with a table embedded should have some standard query language interface
07:44:56 <cocreature> I’m looking for a semaphore like data structure that has a non-blocking lock, i.e., I want to try to lock and see if it was successful
07:44:59 <Welkin> LordBrain: parse the html
07:45:04 <cocreature> anyone aware of something like that?
07:45:22 <Welkin> LordBrain: use pandoc
07:45:27 <LordBrain> i am looking for recommendations tho, becuase when it comes to parsing html, there's a lot of tools it seems
07:45:32 <LordBrain> hmm i didn't even think of pandoc
07:45:49 <Welkin> I have used pandoc to parse html before
07:45:51 <Welkin> it works very well
07:46:11 <lyxia> cocreature: STM TMVar has tryReadMVar
07:46:17 <LordBrain> which library do you use to download it?
07:46:32 <lyxia> or, tryTakeMVar
07:46:59 <Welkin> LordBrain: http://hackage.haskell.org/package/pandoc-1.19.1/docs/Text-Pandoc-Readers-HTML.html
07:47:01 <cocreature> lyxia: ah thanks, I’ll just build my own semaphore around that
07:47:04 <Welkin> the pandoc library
07:47:59 <lyxia> cocreature: concurrent-extra's lock seems to work similarly
07:48:35 <cocreature> lyxia: I think I can also just copy https://hackage.haskell.org/package/stm-2.4.4.1/docs/src/Control.Concurrent.STM.TSem.html#TSem, and change waitTSem to not retry and return a boolean
08:02:53 <Rotaerk> is there any way to specify on the command line where cabal update puts the 00-index.* files, or do you have to put it in the config?
08:04:03 <ph88> can i use an ADT as key to a hashtable ?
08:04:15 <lyxia> yes
08:04:26 <hpc> you sort of have to
08:11:19 <madgen> Heyya, I have a list comprehension that hangs in the IO monad and I can't seem to figure out why.
08:12:02 <Welkin> madgen: post your code
08:12:08 <Welkin> @lpaste
08:12:09 <lambdabot> Haskell pastebin: http://lpaste.net/
08:12:20 <madgen> I do (someAction >>= \count -> traceShowM count >> traceShowM ([0..(parentCount-1)]))
08:12:31 <madgen> sure
08:14:05 <hpc> that's not a list comprehension ;)
08:14:15 <madgen> http://lpaste.net/350071
08:14:23 <ph88> a lot of compilers use a symbol table but this seems problematic in haskell .. what would be a good alternative ?
08:14:47 <madgen> it is not?
08:14:52 <madgen> hpc: it is not?
08:15:20 <Welkin> that is EnumFromTo
08:15:22 <Welkin> er
08:15:26 <Welkin> erenumFromTo
08:15:35 <Welkin> > [0..10]
08:15:36 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
08:15:49 <hpc> indeed, that's just a list range
08:16:03 <hpc> a list comprehension is of the form [expr | some other stuff]
08:16:08 <hpc> and what you have is do-notation
08:16:12 <madgen> I see sorry for getting ahead of myself
08:16:15 <hpc> which incidentally is closely related to list comprehensions
08:16:33 <madgen> that's fine but I don't think the distinction is important for my actual problem, is it?
08:16:44 <hpc> anyway you're using c'git_commit_parentcount and retrieveParentShas which probably have IO in their type
08:16:53 <madgen> indeed they do
08:17:42 <hpc> so there you go ;)
08:18:00 <madgen> Sorry, I don't follow
08:18:26 <hpc> do-notation translates to uses of (>>=) and (>>)
08:18:29 <hpc> which have particular types
08:18:31 <hpc> :t (>>=)
08:18:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:18:33 <hpc> :t (>>)
08:18:34 <lambdabot> Monad m => m a -> m b -> m b
08:18:52 <madgen> yes, I know that
08:19:02 <hpc> your use of c'git_commit_parentcount and retrieveParentShas creates an equation in the unifier which solves for m = IO
08:19:10 <hpc> and nothing else contradicts it
08:19:17 <madgen> I don't understand how I can trace the parentCount which becomes 0 and still execute mapM leading to a segfault
08:19:23 <hpc> and (>>=) and (>>) carry that through the whole thing
08:19:28 <madgen> or the final traceShowM not to display and just ahng
08:19:30 <hpc> okay, that's a totally different question
08:19:44 <hpc> oh wait no it isn't, i misread
08:20:09 <hpc> > [0 .. -1]
08:20:11 <lambdabot>  []
08:20:21 <madgen> indeed that's what I expect
08:20:39 <madgen> but retrieveParentShas get executed regardless
08:20:45 <hpc> > [0 .. -1] :: CUInt
08:20:47 <lambdabot>  error:
08:20:47 <lambdabot>      Not in scope: type constructor or class ‘CUInt’
08:20:52 <hpc> oh no
08:21:02 <hpc> okay, c'git_commit_parentcount :: Ptr C'git_commit -> IO (CUInt)
08:21:06 <hpc> which is a C unsigned int
08:21:13 <hpc> what's -1 in unsigned-land?
08:21:19 <madgen> argggh
08:21:21 <hpc> > (-1) :: Word32
08:21:23 <lambdabot>  4294967295
08:21:25 <madgen> thx
08:21:28 <hpc> :)
08:21:31 <Welkin> lol
08:21:35 <madgen> seriously though
08:21:38 <madgen> ARGGHHH
08:21:51 <Welkin> unsigned vs signed can be dangerous in C
08:22:04 <kuribas> In haskell too
08:22:17 <hpc> now that you know it's still a thing you'll have a significantly easier time finding it
08:22:25 <hpc> unsigned types stand out like the sorest of thumbs
08:22:32 <madgen> i'm using FFI =)
08:22:46 <madgen> I should always stick to while/for loops in FFI
08:22:57 <kuribas> hpc: they're a low level machine thing
08:23:19 <madgen> Don't worry I know, have done enough C
08:23:23 <hpc> kuribas: i know ;)
08:23:27 <madgen> It caught me off guard in Haskell
08:23:28 <kuribas> hpc: for getting one extra bit :)
08:24:21 <hpc> madgen: you'll hopefully find that haskell's clarity of type signatures makes it easier to anticipate these bugs in the future
08:26:17 <madgen> hpc: It's actually funny because if I was using C, my lint would have caught this.
08:26:26 <madgen> =)
08:26:46 <hpc> heh
08:27:39 <Welkin> o.o
08:27:59 <Welkin> I have tun into so many problems in c because of implicit casting between signed and unsigned
08:28:02 <Welkin> run*
08:29:02 <madgen> yeah, I used to do bug hunting (i <= 0) is always a good place to start when i is unsigned
08:32:10 <kuribas> Numeric code is hard to get right, since it's so easy to misplace numberic arguments.
08:34:28 <gameer> Hey Guys. I have a data structure for a tree. Now I wrote a function to fill the tree with some values. But there is a parse error in the second line from behind (the | odd y). Can u explain me how to correct it? Here is my code: http://lpaste.net/5604659887209447424
08:34:55 <madgen> hpc: Welkin: Sorry, I don't know where I left my manners. Thanks a lot for the help!
08:35:31 <hpc> gameer: you have decreasing indentation
08:35:42 <Cale> gameer: That guard is outside the where clause since it starts in a shallower column than the first non-whitespace character after 'where'
08:35:54 <hpc> gameer: the layout for check starts at the column with the 'c' just after "where"
08:36:01 <Cale> gameer: Indent those lines further, past the 'c' in check
08:36:05 <hpc> and the guard is two columns left
08:36:11 <hpc> so move it right at least 3
08:36:25 <gameer> oh damn, thanks!
08:36:38 <gameer> Didn't knew that is has to be after it
08:37:38 <hpc> non-increasing indentation is a thing that is possible
08:37:41 <hpc> but don't do it ;)
08:38:00 <gameer> Now it says that y is not in scope..is "foldr (check y)" not correct to work with the actual folded element?
08:38:24 <joco42> i am curious how to deal with normalized data structures if the data is immutable ?
08:38:30 <hpc> gameer: where is y defined?
08:38:55 <gameer> hpc: I think nowhere :/
08:38:55 <kuribas> gameer: because y is not in scope
08:38:56 <joco42> `data Man = Man [Woman]`
08:39:07 <hpc> ;)
08:39:10 <joco42> `data Woman =Woman  [Man]`
08:39:29 <gameer> But how can I get the actual folded value?
08:39:30 <Welkin> joco42: what is that supposd to represent?
08:39:42 <joco42> a simple model to model ex girlfriends/ boyfriends
08:39:51 <davean> joco42: ok, whats the question?
08:39:54 <kuribas> gameer: a folded function takes two arguments
08:39:55 <joco42> who slept with whom :)
08:40:00 <Welkin> joco42: that is heteronormative, don't you think?
08:40:04 <joco42> it is circular
08:40:09 <davean> joco42: so?
08:40:18 <joco42> isnt that a problem?
08:40:21 <davean> no?
08:40:28 <davean> Just use laziness?
08:40:47 <joco42> hmm
08:40:51 <hpc> infinite data structures are nothing to haskell
08:41:06 <hpc> try data U = U (U -> Bool)
08:41:08 <joco42> i see
08:41:10 <kuribas> gameer: perhaps you meant check y tree = ...
08:41:35 <kuribas> gameer: and foldr check xs EmptyTree?
08:41:47 <joco42> how do you update such a circular thing?
08:41:53 <Welkin> it is not circular
08:41:56 <Welkin> it is inifinite
08:42:10 <davean> let {x = Man [y]; y = Woman [x]}
08:42:17 <davean> joco42: you can't update immutable tihngs
08:42:31 <gameer> kuribas: 
08:42:33 <kuribas> :t foldr
08:42:34 <davean> joco42: so your question is malformed
08:42:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:42:43 <gameer> But isn't the last statement of foldr the List to fold?
08:42:44 <davean> joco42: you create a new one, sharing any sharable parts iwth the old one
08:43:00 <ertes> joco42: what davean, and haskell does sharing automatically for you
08:43:04 <joco42> for example `data Man = {name: String , exes:[Women]}`
08:43:07 <kuribas> gameer: yeay, so foldr check EmptyTree xs
08:43:08 <ertes> joco42: what davean said, and haskell does sharing automatically for you
08:43:17 <kuribas> gameer: or ommit xs from both sides
08:43:32 <joco42> `data Woman = {name: String , exes:[Men]}`
08:43:40 <joco42> so now one women changes her name
08:44:07 <joco42> `data Man = {name: String , exes:[Women]}` then I have to update all the Man ?
08:44:10 <davean> You could make names References, otherwise you create a new structure and use sharing to make that not expensive
08:44:15 <joco42> who had that Woman ?
08:44:20 <Welkin> ...
08:44:29 <joco42> References ? davean  ? how do i do that?
08:44:32 <davean> you can use laziness to amortize that
08:44:33 <Welkin> just use Person
08:44:46 <kuribas> gameer: your tree isn't balanced, so it will not be very efficient.
08:44:49 <ertes> joco42: you need an actual data structure for that…  what you are modelling is a graph
08:44:57 <Welkin> any person can have a relatioship with another person
08:44:59 <joco42> yes, indeed
08:45:04 <joco42> a graph
08:45:12 <Welkin> male or female
08:45:17 <Welkin> it doesn't matter
08:45:24 <Welkin> that's the reality of the world
08:45:34 <Welkin> your model doesn't make sense
08:45:49 <ertes> joco42: haskell has no "references" per se, but you can assign an identifier (like an Int) to each person and save each person along with their exes (these are identifiers now, not Man or Woman)
08:46:08 <ertes> by "save" i mean: put e.g. into an IntMap
08:46:15 <joco42> ertes:  i see , that makes sense
08:46:32 <joco42> so in some sense i need to model 'references'
08:46:36 <joco42> with haskell
08:46:37 <gameer> kuribas: I just want to write some functions as an exersice to get some practice. I managed to fill always the one side of the tree (with "buildTree xs = foldr treeInsert EmptyTree xs ) and now I wanted to change it a bit so all even go to one side and all odd to the other
08:46:54 <joco42> is there some library for doing that? modelling references?
08:47:01 <ertes> joco42: yeah, and you don't need to do that yourself…  data structures are available that do most of it for you
08:47:18 <ertes> joco42: the containers library has IntMap, which is useful for this
08:47:18 <Tuplanolla> @hackage fgl
08:47:18 <lambdabot> http://hackage.haskell.org/package/fgl
08:47:23 <joco42> ertes:  right, i was thinging this myself
08:47:57 <ertes> joco42: note that these too are immutable, so you don't "update an IntMap", you actually create a new one for every change
08:48:06 <joco42> yes
08:48:21 <davean> joco42: but if you're interested in the abstract problem as a Haskell programming exercise and you're just using it as an example its very hard to solve since names aren't unique and there is no other (proper) form of identity pressent
08:48:29 <joco42> but there is no 'Ref' library ? 
08:48:32 <davean> joco42: you can only really tell if things are equal, not the same
08:48:41 <davean> joco42: there is, but Refs are inherantly not pure
08:48:48 <davean> and they're entirely wrong for what you're doing here
08:48:54 <ertes> davean: i believe this is fine as a beginner exercise…  i don't think beginners should only solve easy problems
08:48:59 <joco42> davean:  hmm interesting
08:49:03 <davean> ertes: hum?
08:49:10 <davean> ertes: I have no idea what you're talking about
08:49:35 <ertes> davean: i may have read too much into your statement =)
08:49:47 <ertes> the "very hard to solve" part specifically
08:50:05 <davean> ertes: that means the format is incorrect
08:50:25 <davean> The abstract problem as posed could only be solved I think by using stable pointers?
08:50:27 <ertes> joco42: containers is your Ref library, along with some others…  it depends on the purpose
08:50:30 <davean> which is kinda hacking the RTS
08:50:31 <kuribas> gameer: sure
08:50:36 <joco42> i am asking this because this kind of `references` thing happens often in scala, as for example here http://ochrons.github.io/diode/usage/ApplicationModel.html
08:50:50 <Welkin> scala is nothing like haskell
08:50:55 <ertes> davean: wait, are you talking about observable sharing now?
08:50:58 <davean> Yes, Scala ... oh god can we not mention the horrible things Scala does?
08:51:03 <davean> ertes: yes
08:51:06 <Welkin> if you try to import concepts from other languages, you will run into trouble
08:51:12 <joco42> i was wondering if haskell world has something similar, or how people here deal with normalizing data structures
08:51:21 <davean> ertes: Clearly? I'm not sure how what I said can be taken otherwise
08:51:34 <davean> ertes: I specificly refered to the lack of unique identifier in the datastructure
08:51:36 <ertes> davean: ah, now i see what you mean…  you meant modelling it directly without IntMap
08:51:46 <ertes> recursively
08:51:46 <davean> yes
08:52:10 <davean> Thats "Hard"
08:52:14 <ertes> it is indeed
08:52:21 <davean> It directly breaks the purity model
08:52:24 <shapr> Is the protolude the best recommend prelude replacement at the moment?
08:52:32 <davean> (And shows you you fucked up somewhere in your design)
08:52:35 <hpc> i wouldn't recommend any replacement prelude
08:52:37 <ertes> shapr: hi…  did you see my link?
08:52:43 <hpc> though if you really have to, the php one is pretty great ;)
08:52:45 <davean> shapr: I think Base is the recomended prelude prelacement ;)
08:52:54 <shapr> ertes: no, what was your link?
08:53:04 <Tuplanolla> How about `subhask`?
08:53:12 <ertes> shapr: http://ertes.eu/tutorial/s6-xsession.html
08:53:19 <shapr> ertes: I just woke up, got coffee, started coding.
08:53:34 <davean> ertes: I think your complain may be I didn't stay beginner enough, not that I was to beginner only?
08:53:36 <davean> ertes: ;)
08:53:38 <ertes> shapr: you were interested in X sessions via s6, so i wrote a tutorial =)
08:53:41 <shapr> ertes: oh that's what I asked you to write!
08:53:44 <shapr> ertes: thanks so much!
08:53:46 * shapr hops cheerfully
08:54:07 <ertes> davean: no, i just completely misunderstood you…  nevermind =)
08:54:20 <quchen> Hello shapr!
08:54:44 <davean> ertes: ok, because I would have taken "You should never mention such horrors to a beginner" as a reasonable chastisement
08:55:29 <shapr> quchen: GOOD MORNING! How's code?
08:56:09 <quchen> Excellent! I rewrote wl-pprint (and extended it with a truckload of examples and so on), now I’m trying to reach the maintainer and make Travis happy.
08:59:29 <lyxia> wow
08:59:51 <lyxia> looking forward to see it on hackage
09:00:41 <cocreature> and those poor wl-pprint-text users don’t get examples :(
09:01:12 <davean> ertes: from your link I looked at S6, I like that guys style "This site is glibc-free, and uses no GNU software during its normal operation."
09:02:33 <ertes> davean: yeah, they are minimalist, though not as much as suckless.org
09:02:48 <ertes> the only complaint i have about s6 is the UX:  --help is useless
09:03:12 <ertes> it only prints a one-line reminder of what options are there with no documentation at all…  might as well not have --help at all
09:03:26 <quchen> Which GHC added Void to Base?
09:03:29 <quchen> 7.8?
09:03:51 <Welkin> what is s6?
09:04:35 <hexagoxel> quchen: "Since: 4.8.0.0" - should be 7.10
09:04:38 <ertes> Welkin: a process supervisor…  something you might use as init, but don't have to
09:05:00 <davean> http://skarnet.org/software/s6/
09:05:09 <davean> Because "s6" is ungoogable
09:06:09 <Welkin> lol
09:06:12 <Welkin> it sure is
09:06:31 <Welkin> I have just been using upstart, because ubuntu
09:06:44 <davean> Because distros always make the wisest choices
09:06:55 <davean> but I think we're getting off topic here
09:08:09 <Welkin> the way they present s6 is offputting, because they are saying outright that "everything else sucks; ours is the best"
09:08:25 <Welkin> I never gave much thought to init systems though, and so just used whatever was available
09:08:30 <shapr> My proof that foldl' is better than foldl in general is that my Advent of Code solutions for day one and day two run in half the time.
09:10:45 <ph88> hi guys, i was reading this http://www.aosabook.org/en/ghc.html under the chapter "no symbol table" it is described that the symbol information is captured in the AST instead of a separate table. But i wonder how can information higher up in the tree be accessed while parsing the source code? I need information which was defined earlier to know which node should be created in the AST. Can anyone shed some light on this ?
09:11:12 <ph88> i'm not parsing haskell code .. but i'm investigating using the same technique instead of a symbol table
09:11:14 <ertes> shapr: in the worst case foldl' forces thunks that have been already evaluated, and in fact GHC might just optimise those away, but there are use cases for foldl, too, as i learned recently
09:11:47 <ertes> :t foldl (flip (:)) []
09:11:49 <lambdabot> Foldable t => t a -> [a]
09:12:49 <shapr> ertes: what cases?
09:13:04 <ertes> shapr: building a data structure starting from the leaves
09:13:12 <ertes> 'reverse' is such a function
09:14:27 <ertes> foldl' won't hurt much, but it has an unnecessary seq to force something that is trivially already evaluated
09:14:37 <shapr> hm, interesting
09:16:09 <Cale> shapr: When you obtained those results, how was the code compiled?
09:16:55 <Cale> shapr: In many cases, enabling optimisations should make the difference go away -- though there might be some where it doesn't, if the strictness analyser fails to figure things out.
09:17:57 <ertes> also in some cases you may want to use foldl' anyway, even when building from the leaves, specifically if you have computations in there that you need to force
09:18:20 * jmcarthur has been developing an opinion that strictness analysis belongs in the type system where it is visible to the programmer, but doesn't know how well that would actually work in practice
09:18:22 <ertes> :t foldl' (\ys x -> let y = x^2 in y `seq` y : ys) []
09:18:23 <shapr> I don't see any optimization settings in either my stack.yaml or cabal file
09:18:23 <lambdabot> (Foldable t, Num a) => t a -> [a]
09:18:31 <ertes> foldl' (\ys x -> let y = x^2 in y `seq` y : ys) [] [1..9]
09:18:35 <ertes> > foldl' (\ys x -> let y = x^2 in y `seq` y : ys) [] [1..9]
09:18:38 <lambdabot>  [81,64,49,36,25,16,9,4,1]
09:18:52 <ertes> foldl would still leave the (^2) part unevaluated in this case
09:19:36 <ertes> in fact it might introduce unwanted sharing
09:24:05 <shapr> jmcarthur: I would also prefer to have strictness visible in the type signature somehow.
09:24:31 <shapr> Cale: looks like the code was compiled with -O1
09:28:35 <davean> shapr: Hum ... why?
09:29:27 <k0ral> Hello
09:30:18 <hexagoxel> hi
09:31:49 <k0ral> I'm looking for a 2D physics engine library in pure haskell; I've seen a couple of projects in that area but I have the feeling most are abandoned
09:32:38 <k0ral> is there a project you would recommend considering I'm willing to contribute in case some features are missing ?
09:32:41 <Welkin> not sure about ones written in haskell
09:32:54 <Welkin> your best bet is to use one with bindings in haskell
09:32:56 <Welkin> o[r write bindings
09:33:25 <ab9rf> there's a couple of haskell games written within the various FRP frameworks that have at least some degree of physics simulation
09:33:38 <k0ral> I'd like to avoid bindings (except if there's an actual high level abstraction over the original C library)
09:34:12 <Welkin> http://hackage.haskell.org/package/bullet
09:34:16 <Welkin> http://hackage.haskell.org/package/Hipmunk
09:34:21 <Welkin> I'm sure there are box2d bindings too
09:34:26 <k0ral> also I'd like to separate the event management (FRP library) with the physics management (physics engine)
09:34:28 <Welkin> I have never seen any pure haskell engines
09:35:25 <k0ral> also, for information, how hard would it be to write a 2D physics engine in pure haskell ?
09:35:35 <Tuplanolla> There are no deterministic physics engines to my knowledge.
09:35:37 <Welkin> it depends on what you want to do
09:35:38 <hexagoxel> (wait, i thought bullet was c++)
09:36:02 <Welkin> https://wiki.haskell.org/Bullet
09:36:03 <Welkin> yes it is
09:36:08 <Tuplanolla> I have a half-finished one, but it's probably not what anyone else wants.
09:36:23 <k0ral> Welkin: Hpysics is an abandoned engine written in Haskell only
09:36:39 <ab9rf> you'll likely have to write your own
09:36:42 <Welkin> just use what you have available
09:36:49 <Welkin> you can always drop in a new solution later
09:37:05 <ab9rf> the haskell community is littered with half-finished projects in areas like this because there's not enough interest to sustain them
09:37:20 <Welkin> there are usually bindings to many different projects
09:37:41 <Tuplanolla> Usually you'll want to write your own engine anyway.
09:37:55 <Welkin> for physics? not really Tuplanolla 
09:38:01 <ab9rf> chipmunk, for exampe, uses callbacks, which will tend to make it difficult to write bindings that are easy to use
09:38:13 <ab9rf> which is why i suspect it's become deprecated
09:38:57 <ab9rf> you could spend years just taking every half-finished project on hackage and making it work in current ghc :)
09:39:02 <Tuplanolla> It's necessary if you want certain guarantees, like reproducibility of runs over different architectures or time reversibility, Welkin.
09:39:24 <Welkin> I just found this https://www.reddit.com/r/haskell/comments/4ci8uu/shapes_optimizing_a_2d_physics_engine/
09:41:00 <ab9rf> last commit on his github is last month
09:42:43 <hexagoxel> how does bullet manage the c++ ffi? i thought this was non-trivial?
09:43:48 <geekosaur> apparently it has a C API already
09:43:50 <shapr> davean: why strictness on type sig? or why -O1 ?
09:44:24 <davean> shapr: I meant the strictness, but I'd take an answer to -O1, though the signature discussion is far more meaningful
09:44:26 <geekosaur> sort of
09:44:30 <ertes> ab9rf: i'm not aware of any FRP frameworks that have physics simulation built-in, and it sounds out of place, too
09:44:33 <geekosaur> "Draft high-level generic physics C-API. For low-level access, use the physics SDK native API's. Work in progress, functionality will be added on demand."
09:46:33 <ertes> k0ral: writing a physics engine in haskell is as hard as in any other language, and it's pretty hard, especially if you want to be accurate and somewhat flexible about time steps
09:47:01 <ertes> even in 2D (3D isn't actually that much more difficult, if you have mastered 2D)
09:47:45 <ab9rf> ertes: i vaguely recall seeing a game someone had written in a FRP framework (reactive, i think) that had some degree of physics simulation in int
09:48:05 <ab9rf> ertes: that would have been a while back, though, porbably last yaer sometime
09:48:13 <Welkin> that depends on what you call "physics simulation"
09:48:24 <ab9rf> that too
09:48:37 <Welkin> that could be very advanced, or something as simple as bounding box collision detection and flipping the vectors for resolving them
09:49:17 <ertes> ab9rf: ah, the *game* had physics simulation
09:49:24 <ertes> yeah, that sounds more reasonable =)
09:49:29 <Welkin> generally, a "physics engine" is an advanced generic system for doing any kind of physics simulation you will need
09:49:40 <ab9rf> ertes: uyes. but you might be able to extract it and make it more general/
09:50:52 <davean> ertes: the math for certain types of collision detection gets more annoying in 3D
09:51:14 <Welkin> in many cases you don't *need* a physics engine
09:51:27 <Welkin> because you would only use a tiny number of the functions in it anyway
09:51:32 <ab9rf> one of my "maybe someday" projects would require large scale n-body gravitational simulation
09:51:36 <Welkin> just write what you need for the game and don't worry about making an engine
09:52:59 <davean> ab9rf: been there, done that in haskell
09:53:02 <davean> ab9rf: its fun
09:53:31 <davean> (I was annoyed the "galaxies" screensaver was wrong)
09:53:35 <ab9rf> davean: heh
09:54:04 <jmcarthur> davean: I want strictness analysis to be a part of the type system so that it is easier to reason about. It would also enable one to constrain types in useful ways. For example, the fix function could require that its argument function be lazy. You could perhaps be prevented from misusing foldr/foldl. Etc.
09:54:37 <ab9rf> i put it aside because iwas having trouble understanding the math for multipole moments
09:54:50 <ab9rf> but mostly because i got distracted by other things
09:55:08 <monochrom> you got distracted by the other n-1 bodies :)
09:55:24 <davean> ab9rf: yes, well, spherical harmonics are the correct place to start
09:55:38 <jmcarthur> davean: In general, I think that awareness of strictness is crucial for writing good Haskell code, despite that a lot of people "get by" without thinking about it (and then get burned by the habit when they create a space leak).
09:55:44 <davean> ab9rf: I just happened to already have some code for that
09:55:58 <ab9rf> davean: yes, it took me about ten minutes of research to figure that out
09:56:02 <davean> jmcarthur: I agree on awareness, but I don't think it should usually limit composability
09:56:08 <jmcarthur> davean: Me either!
09:56:14 <k0ral> so, if I want to do the community a service, I should write my own physics engine, and NOT publish it to avoid filling the already cluttered set of unfinished engines, am I right ?
09:56:40 <ab9rf> davean: i have basic data structures already mapped out conceptually, but i need the math for combining multipole moments and that's the part i hung on at the time.
09:56:52 <ab9rf> k0ral: no, publish it, we like unfinished stuff :)
09:57:01 <jmcarthur> davean: I'm not inclined to something annoying like OCaml's lazy type constructor with explicit forcing or like different strict/non-strict function types (and those don't relate to strictness *analysis* anyway).
09:57:08 <Tuplanolla> Just mark it unfinished, k0ral.
09:57:09 <monochrom> How about filling the already cluttered set of well-finished engines?
09:58:24 <quchen_> Anyone seen sinelaw lately?
10:00:50 <ertes> ab9rf: yeah, i just mean that an FRP framework is not supposed to do physics itself…  it's really only an interaction framework, so it's higher-level
10:01:31 <ertes> davean: of course, but that's really a small problem compared to handling the various numeric edge cases, and your CAS does most of it for you anyway
10:01:36 <maerwald> frp is the answer to everything lately
10:01:42 <k0ral> monochrom: can you exhibit an element from that set ?
10:02:00 <monochrom> I can't.
10:02:08 <davean> maerwald: welcome to 2005?
10:02:18 <ertes> maerwald: recently i kept telling people that FRP does *not* solve everything ;)
10:02:27 <maerwald> ertes: I know, thanks for that
10:02:39 <monochrom> Maybe Tabletop Simulator
10:02:50 <monochrom> and that goat game
10:03:16 <monochrom> Goat Simulator
10:03:17 <ertes> even as a major proponent of FRP neither is it a solution for everything, nor is it as general as people seem to assume
10:05:05 <ab9rf> ertes: i'll definitely agree with that
10:06:37 <ocramz> hullo
10:06:56 <ab9rf> ertes: i'm quite aware of the tendency of people to declare "universal solution" status to their favorite framework. i've been arond node.js people.
10:14:09 <rmrfroot> anyone know the status of `shell-conduit'?
10:14:38 <joko> Hi, I was wondering how easy it is to write the backend of a single page application in Haskell, e.g. an authorization service like OAuth2 and a REST API. Are there any frameworks / libraries you would recommend me?
10:14:47 <monochrom> w00t, I like Joachim Durchholz's "marker type" suggestion for phantom types.
10:14:56 <monochrom> (read from haskell-cafe)
10:15:13 <ab9rf> i kinda haev this idea of finding apparently-abandoned projects on hackage and unabandoning them
10:15:15 <quchen_> Is »layouting« a word? Is »layouted«?
10:15:28 <ocramz> quchen_ : now it is I guess
10:15:31 <monochrom> No, I think neither are words.
10:15:41 <ab9rf> quchen_: layout is a noun, you can't verb it like that without weirding english
10:15:43 <monochrom> try "laying out" instead
10:15:54 <ab9rf> quchen_: it's "laying out" or "laid out"
10:16:16 <ab9rf> a "layout" is the result of the process of laying some things out
10:16:18 <quchen_> Okay, thanks. You’ll be paid by not seeing »layouting« in my docs then. :-)
10:16:38 <ab9rf> if you know german, hyou should recognize this as a separable-prefix verb, except in english it's a separable-suffix
10:16:47 <quchen_> Sure, I know what a layout is, and what doing one is, and that »laid out« is a thing. But I was hoping these other words existed as well :-D
10:16:56 <quchen_> Ja, Deutsch kenne ich recht gut. Habe hier 28 Jahre gelebt.
10:17:06 <ab9rf> very few people will admit that english has separable-suffix verbs
10:17:16 <monochrom> ♫ The Marker of the Opera is there, inside my mind ♫
10:17:46 <monochrom> Deutschsprach is a concatenative language :)
10:18:01 <monochrom> err, maybe Deutschsprachen
10:18:54 <ab9rf> the whole nonsense about "not ending a sentence with a preposition" comes from epople who don't want to admit that english inherited that trait from german
10:18:58 <nitrix> ertes: Mind 2 minutes of FRP thinkering?
10:19:15 <geekosaur> well, who didn't want to admit that English wasn't Latin
10:19:26 <ab9rf> geekosaur: or french
10:19:46 <geekosaur> (as for weirding English, it's about a thousand years too late for that >.>)
10:19:48 <Rotaerk> isn't english chinese?
10:20:05 <ab9rf> Rotaerk: english slowly grows to encompass every other language
10:20:17 <geekosaur> (ok, not quite but close enough)
10:20:20 <Rotaerk> ah, cancerese
10:20:25 <ab9rf> anywhom
10:20:45 <rmrfroot> joko: if you know mind a lot of type wizardry you could have a look at servant: http://haskell-servant.github.io/tutorial/0.4/server.html
10:20:51 <ab9rf> ertes: btw, do you know if anyone has made an effort to write a reflex host for opengl or sdl?
10:20:54 <ocramz> anyone used Pipes here? I have a `eff :: Producer a m ()` and I'd like to collect a finite number of elements of the stream in a `m [a]` for example. I don't understand why `runEffect $ eff >-> P.take n` discards the values 
10:21:17 <ocramz> where P is Pipes.Prelude
10:21:34 <rmrfroot> joko: a cool thing about servant is that you can generate javascript client code for the API automagically
10:21:42 <ab9rf> ertes: i found reflex-gloss, but gloss is a very restrictive subset of gl
10:21:52 <Welkin> please never say "automagically"
10:21:53 <joko> rmrfroot: you got my attention :)
10:22:29 <joko> although I was more willing to try Elm
10:22:45 <Welkin> joko: I use elm with servant
10:22:47 <Welkin> it works fine
10:23:11 <ertes> nitrix: sure
10:23:14 <rmrfroot> Welkin: please never say "never say" without explaining why ^^
10:23:18 <ertes> nitrix: (i mean i don't mind) =)
10:23:28 <Welkin> rmrfroot: because it is a stupid term
10:23:32 <joko> rmrfroot and Welkin: and any suggestion on database connection?
10:23:38 <ertes> ab9rf: none that i know of…  i would just write the host myself…  it's not a major payoff to have a library for that
10:23:41 <Welkin> joko: persistent with postgres
10:23:53 <ertes> ab9rf: also GL is unrelated…  it's just for drawing
10:24:08 <ertes> ab9rf: all interactions are done by SDL, so that's what you should bind to
10:24:13 <ab9rf> ertes: it's something i'm workiing on in spare moments, but i thought i'd ask in case someone's already done it
10:24:19 <ab9rf> ertes: yeah, that was the conclusion i came to as well
10:24:38 <ab9rf> ertes: opengl would require writing most of the interaction layer bespoke, while sdl provides most of it
10:24:49 <ab9rf> ertes: it's not a whole lot of glue from sdl to reflex
10:25:00 <ertes> ab9rf: any reflex-sdl library will most likely either be so trivial that it's hardly worth adding the dependency, or it will impose some control scheme on you
10:25:22 <ab9rf> ertes: probably the latter, but you might be right about the former
10:25:56 <ab9rf> ertes: my experimentation with haskell and sdl has been limited because it has only been recently that getting sdl to work with ghc on windows wasn't a marathon
10:25:58 <rmrfroot> Welkin: why do you *think* it's a stupid term?
10:26:14 <Welkin> rmrfroot: it's not a real word
10:26:26 <Welkin> say what you mean, which it "automatically"
10:26:31 <nitrix> ertes: It appears to me that if one person were to make effectful behaviors; the system needs to me push-based. Consider two behaviors A and B, where A relies on the event `seconds` that changes every seconds in the form `seconds `mod` 3` and it also plays a sound. Now behavior B relies on A, but is needed only rarely, let's say when someone presses a button.
10:26:31 <Welkin> there is nothing magic
10:26:35 <ertes> ab9rf: you got sdl2 to work on windows, or do you mean the legacy SDL library?
10:27:07 <rmrfroot> Welkin: alright, so you don't like slang. 
10:27:30 <Phyx-> ertes: sdl2 should work out of the box with 8.0.2
10:27:34 <nitrix> ertes: In a push-based system, you'd hear a beep every second and we'd compute the seconds module 3, which you'd be able to see when you press a button.
10:27:49 <ertes> nitrix: that…  doesn't really make sense to me…  how can a behaviour have effects?  you probably have something in the controller part that consumes the behaviour and has effects
10:27:50 <ab9rf> ertes: sdl2 is "fairly easy" with current stack. 
10:27:56 <ertes> nitrix: behaviours are inherently pull
10:28:15 <nitrix> ertes: On the other hand... in a pull-based system, you'd obtain the same visual feedback with the seconds module 3, but hear the beep everytime you press the button, none otherwise.
10:28:34 <ertes> Phyx-: nice!
10:28:34 <ab9rf> ertes: you can't do it with 8.0.1 platform without some fairly complicated maneuvering
10:28:44 <nitrix> ertes: Ah, then that means I'm confused. I apologies. I'll continue reading :(
10:29:02 <ab9rf> ertes: you have to modify the mingw toolchain, which is nontrivial with platform but not that difficult with stack
10:29:10 <ertes> nitrix: a behaviour is just a value…  its existence doesn't cause anything to happen
10:29:19 <ertes> like an Int
10:29:51 <nitrix> ertes: I was hoping to attach effects to them but apparently that's problematic.
10:30:00 <nilOps> Is there a way to get function documentation from the repl?
10:30:02 <ab9rf> ertes: i managed to do it a while back but it took me severeal weeks and the toolchain was unstable and ill-behaved
10:30:08 <ertes> nitrix: that doesn't make sense in the same way attaching effects to an Int doesn't make sense
10:30:23 <nilOps> Something like doc in Clojure?
10:30:28 <monochrom> No.
10:30:53 <ertes> ab9rf: i see
10:31:23 <Phyx-> ab9rf: why do you need to modify the toolchain?
10:31:34 <nitrix> ertes: So, effects are outside the FRP graph? Or at the very least, leaves nodes?
10:31:37 <ertes> nitrix: have you used reflex?  it's a proper push/pull framework with event push and behaviour pull
10:31:56 <ertes> nitrix: outside of it…  an FRP application is always split into a semantics and a controller part
10:32:29 <nitrix> ertes: So you'll necessarily have an event triggering the action?
10:32:38 <ertes> the controller part does all effects…  it also creates the root behaviours/events (from effects most likely) and consumes the resulting behaviours/events (and causes effects)
10:32:55 <ertes> nitrix: i strongly suggest that you try reflex
10:33:22 <ertes> it will answer all of these questions
10:34:04 <nitrix> ertes: I've seen it and played with it, but now am on the exploratory realm of why things are this way and what are the consequences behind each decisions of that design.
10:34:24 <ertes> nitrix: have you used raw reflex?  not reflex-dom or any other library built on top of it
10:34:41 <nitrix> ertes: As a matter of fact, I'm not using Haskell at all for that reasoning so there's no model around the concepts of effects, which kinds of get confusing quickly.
10:35:09 <nitrix> ertes: Yeah; but wires was more clear (despite missing PushM and PullM)
10:35:17 <ab9rf> Phyx-: the native sdl library is not present in the toolchain
10:35:21 <nitrix> (The controller part was simpler)
10:36:08 <ertes> nitrix: yeah, the controller part of reflex could be better documented (the dependent-map stuff can be confusing), but it's actually pretty easy once you get over that hump
10:36:27 <Phyx-> ab9rf: that's what --extra-lib-dirs is for..
10:36:28 <nitrix> (... and that weird spider)
10:36:37 <ab9rf> Phyx-: doesn't work on windows.
10:36:44 <Phyx-> ab9rf: it does
10:36:52 <ertes> nitrix: apart from runSpiderHost you don't actually need to concern yourself with Spider
10:36:54 <ab9rf> Phyx-: didn't last time i tired :)
10:37:29 <ertes> Spider is entirely implementation detail, which is kinda beautiful about reflex =)
10:38:02 <AndreasK> ab9rf: https://www.reddit.com/r/haskellgamedev/comments/4jpthu/windows_sdl2_is_now_almost_painless_via_stack/
10:38:07 <ab9rf> AndreasK: yes, i found that
10:38:10 <Phyx-> GHC always honored -L. I don't know about the tools around it though. But at least cabal does, since that's what we use to build.
10:38:12 <AndreasK> Worked for me
10:38:14 <ab9rf> AndreasK: it works, too
10:38:26 <rmrfroot> joko: missed your last question! i agree with Welkin's suggestion to use persistent. that way you can either use sqlite, postgres or mysql without having to change the database code. you could almost say that it works *automagically* ;)
10:38:38 <ab9rf> Phyx-: -L is not enough to get libsdl into the build environment
10:39:36 <joko> rmrfroot: Hahah :D Thanks, I'll give it a shot
10:39:52 <ab9rf> Phyx-: iirc it has to do with getting the .h files to where the imbedded c compiler can see them
10:40:12 <Phyx-> ab9rf: that's what -I is for.. --extra-include-dirs
10:40:28 <ab9rf> Phyx-: i tried all combinations of those and never got it to work without actually modifying the imbedded toolchain
10:41:06 <ab9rf> Phyx-: sdl's build script relies on pkgconfig, you can make the directories aailable thorugh -L and -I but the script still tests for the package being installed and when it finds it missing it aborts
10:41:50 <ab9rf> Phyx-: the only way around htis is to modify hte build script, or to instal the package into the toolchain
10:42:12 <ab9rf> Phyx-: stack makes it fairly easy to install the package
10:42:18 <Phyx-> or just get pkgconfig
10:42:32 <ab9rf> Phyx-: there's already a pkgconfig in the toolchain
10:42:42 <Phyx-> but anyway, I was just wondering if something was broken with the distribution, but seems like it's not.
10:42:42 <ab9rf> Phyx-: but ghc platform makes it REALLY hard to get to
10:43:30 <ab9rf> Phyx-: aalso, the toolchain ionstalled with GHC platform is a minimal toolchain and doesn't support extensions
10:44:45 <Phyx-> ab9rf: I wasn't talking about platform at all. I was just wondering why you had to modify anything in /mingw to get sdl2 to work. 
10:46:23 <ab9rf> Phyx-: indirectly, yes. AndreasK posted a link to the procedure
10:47:07 <ab9rf> Phyx-: it's a fairly significant modification to the toolchain
10:47:20 <shlevy> "After several years exploring the design space, it was decided that a single monolithic revision of the language was too large a task, and the best way to make progress was to evolve the language in small incremental steps, each revision integrating only a small number of well-understood extensions and changes. Haskell 2010 is the first revision to be created in this way, and new revisions are expected once per year." whoops
10:47:48 <ab9rf> shlevy: obvously "year" in that statement has a different meaning than the customary sense
10:48:46 <monochrom> I used to decide to do my PhD incrementally every year, too.
10:49:38 <monochrom> It never works that way. It's always many years of nothing and then one year of let me put my act together and get it all done.
10:49:49 <Phyx-> ab9rf: again, it shouldn't be needed. But I don't know how stack and platform arrange things internally. I can only say that issues with sdl2 working with ghc(i) require an up to date GHC. I was just merely curious if the changes you said you required were due to shortcomings in GHC or surrounding toolchains
10:50:09 <monochrom> One single monolithic thesis.
10:51:10 <monochrom> P. S. It is about lazy evaluation. :)
10:51:23 <Phyx-> ab9rf: but if you ever have trouble with it in ghci then I'd be more than happy to get some details on that!
10:51:28 <geekosaur> they did meet annually to consider extensions for several years. they just never could agree on anything and eventually gave up
10:51:51 <monochrom> Oh, I met with my supervisor every week, too.
10:52:03 <geekosaur> part of the problem is that the one extension everyone really wants to get standardized is also one of the most contentious: MultiParameterTypeClasses
10:52:28 <ab9rf> Phyx-: i'm sure it's the surrounding toolchains. ghc assmes that the c compiler is proprety installed.
10:52:39 <geekosaur> because you need either fundeps or type families to make them usable, and fundeps make the theory wonks unhappy --- but fundeps are the direction the ecosystem went
10:53:24 <ab9rf> Phyx-: fundamentally, it's the fact that platform and stack both rely on mingw to provide a toolchain on the windows platform
10:53:57 <kuribas> mingw is lightweight...
10:53:59 <ab9rf> Phyx-: mingw isn't that great of a toolchain. it would be Really Nice if ghc could use MSVC... but that's not likely to happen any time soon.
10:54:20 <davean> fundeps are so nice and intuitive though :(
10:54:50 <monochrom> I would be OK with postponing MultiParameterTypeClasses on the ground of "let's wait for some poor grad student to figure it out". But meanwhile I would also push for the easy extensions such as LambdaCase and MultiwayIf.
10:55:42 <Phyx-> ab9rf: there's nothing wrong with the mingw-w64 toolchain at all. Even if we switched to MSVC you would still have to tell the compiler where to find external libraries and headers
10:55:57 <Tuplanolla> There's a large number of trivial extensions that need to get in, like `NumDecimals`, `BinaryLiterals`, `PostfixOperators`, ...
10:56:20 <ab9rf> Phyx-: again, we'll have to agree to disagree on this point :)
10:56:46 <Phyx-> I guess so
10:57:30 <monochrom> I need to vote myself into the committee and get it done bwhahahahaha. Please crowdfund me to bribe the electorate!
10:57:48 <ab9rf> Phyx-: i challenge you to take the current Haskell Platform for Windows and compile the sdl2 package successfully
10:58:06 <shlevy> I like the documentation for fixIO in the standard :D fixIO :: (a -> IO a) -> IO a
10:58:08 <shlevy> (that's it)
10:58:09 <ab9rf> Phyx-: if you succeed, write it up because there are people who would live to see how you did it
10:59:19 <monochrom> shlevy, it's meant to be for MonadFix's mfix. So you are supposed to find out about MonadFix instead.
10:59:49 <Phyx-> ab9rf: sdl2 was one of the test projects I used when rewriting GHC's runtime linker in GHC 8.0.1. I can guarantee you that neither stack, nor platform are needed to use it at all.
11:00:42 <Phyx-> There may be some troubles with things that package GHC, but the issues aren't with GHC or the C toolchain we provide.
11:00:44 <AndreasK> ab9rf: Why would the approach i posted earlier not work for platform since it seems to use stack now?
11:01:03 <monochrom> Haskell Platform doesn't use stack.
11:01:06 <ab9rf> AndreasK: you'd have to run elevated
11:01:22 <ab9rf> AndreasK: because platform installs the mingw toolchain in system space
11:01:23 <AndreasK> includes stack then
11:01:35 <monochrom> Then you understand the difference.
11:02:00 <ab9rf> AndreasK: in theory, if you fillowed the steps in that link while in an elevated shell, it should work
11:02:25 <cic> hm, let's say i have two Handles and want to wait for the first one to have things to read from, is there any haskell library/api that lets me do this? something like select in c.
11:02:35 <AndreasK> ab9rf: I assume it requires evelation to install then as well?
11:02:46 <geekosaur> iirc it includes stack now because otherwise the stack folks would need to figure out how to have stack install a usable mingw env so stuff actually works on windows
11:02:50 <ab9rf> AndreasK: elevation is automatic while running an installer
11:02:55 <geekosaur> cic, you use threads
11:02:58 <rmrfroot> cic: something like this? https://hackage.haskell.org/package/async
11:03:15 <ab9rf> stack installs its sandbox versions of ghc in user space, thus no elevation needed
11:03:20 <ab9rf> compilers generally do not need to be elevated
11:03:38 <geekosaur> (note that Haskell threads are very lightweight, and in this case basically amount to the GHC runtime doing the epoll()/select() for you)
11:03:44 <davean> geekosaur, cic: YOu can also use GHC.Event which is far nicer to work with
11:04:23 <ab9rf> geekosaur: the problem is that the mingw toolchain in the platform is too stripped-down to handle installing additional packages
11:04:31 <AndreasK> Sounds like the issue is with the platform installing things a user might need to change in system paths
11:04:38 <ab9rf> AndreasK: that is part of it, yes
11:04:45 <cic> geekosaur, rmrfroot, davean: ah, ok, thanks for all suggestions, i will have a look at them
11:05:10 <ab9rf> the procedure in that link from reddit is bascially "install the missing parts of mingw, upgrade mingw, install the sdl library"
11:05:38 <davean> cic: I will mention that 'Handle' is one piece of truly ugly
11:06:00 <geekosaur> also, the mingw-and-friends env is a moving target. currently msys2 is probably the best option, but that has changed several times over the past 2 years
11:06:07 <davean> It tries to abstract and unify fundimentally different things
11:06:16 <davean> I think Handle was a horrible mistake
11:06:50 <Phyx-> msys2 and mingw are two different things though.
11:07:22 <ab9rf> Phyx-: pkg-config is absent in the platform release of msys2
11:07:34 <monochrom> davean, what is a better way?
11:07:52 <davean> monochrom: simply accepting the things it tries to unify are fundimentally different and not doing that?
11:08:18 <maerwald> davean: that "must abstract" syndrome is pretty common
11:08:29 <monochrom> sure, but "not do that" is very very broad. so broad it includes "don't write any program at all", but I doubt you mean it.
11:08:56 <monochrom> In fact I don't even know what are the fundamentally different things.
11:09:37 <davean> monochrom: start with IODeviceType
11:09:38 <ongy> davean: which things does Handle unify? (The Handle in base?)
11:09:44 <ab9rf> geekosaur: i still think the better solution would be to depend on the environment's native compiler, but of course ghc-in-msvc is a huge undertaking
11:09:56 <davean> Directories, Streams, regular files, RawDevices
11:10:04 <davean> then it does encodings ... because that belongs there
11:10:28 <davean> Half the IODevice members are "error" on any given instance
11:11:12 <davean> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.Handle.Types.html#Handle and https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.Device.html#IODevice just look at that!
11:11:30 <davean> And thats before you get to the code that impliments it!
11:11:57 <davean> I'd say half of it is to abstract platform
11:12:11 <davean> which is almost valid, but you actually STILL have to know the platform to get it to operate correctly!
11:12:35 <Phyx-> ab9rf: You keep saying this, how would that solve pkg-config? How would that solve finding the libraries and headers?
11:12:44 <AndreasK> In my experience it makes little difference if something uses mingw or msvc as a compiler for windows whgen it comes to the effort required to get it running.
11:12:47 <Phyx-> msvc isn't magic. It doesn't sense where packages and headers are
11:12:49 <maerwald> we talked about that "platform abstraction fallacy" yesterday wrt directory package, it's similar there
11:12:56 <Phyx-> mingw isn't msys2
11:13:02 <davean> Oh, also
11:13:07 <davean> It has two newline modes
11:13:11 <ab9rf> Phyx-: dude, believe me, or not. why don't you actually try it, since hyou won't believe what i'm telling you
11:13:14 <geekosaur> ab9rf, that is arguable, but it has its own problems. like Phyx- just said, there's no way to find 3rd party libraries --- it's every library for itself and you have to point the compiler to them explicitly
11:13:14 <AndreasK> It's more about someone providing guides and figuring out all the painful manual steps and automating them
11:13:15 <davean> Which is a pathetic subset of the ACTUAL newline modes out there
11:13:23 <davean> so it doesn't even abstract well in the trivial cases!
11:13:24 <ab9rf> Phyx-: i'm done discussing this with you, since hyou won't accept what i tell you as true
11:13:24 <geekosaur> no pkg-config or alternative
11:13:48 <Phyx-> ab9rf: because you don't seem to understand the root of the problem. But fair enough
11:13:50 <ab9rf> geekosaur: except that sdl2's build script explicitly invokes pkg-config :)
11:13:53 <davean> And it STILL at its core assumes that files are var-length arrays of bytes
11:14:07 <geekosaur> show me the pkg-config that comes with msvc
11:14:16 <ab9rf> geekosaur: shrug :)
11:14:20 <ab9rf> geekosaur: i didn't say it was easy
11:14:21 <geekosaur> it's a *unix* thing, it comes with unix-like envs
11:14:44 <ab9rf> Phyx-: i definitely understand the problem.
11:14:45 <geekosaur> oh? but your whole argument is how much easier things would be with msvc
11:14:50 <davean> maerwald: Yah, its pretty upsetting
11:14:56 <ab9rf> Phyx-: i am now totally done with hyou. jerk.
11:15:00 <davean> maerwald: I try to use the unix package and raw file paths whenever possible
11:15:20 <AndreasK> Didn't he even say sdl2 works with the guide I posted? ...
11:15:32 <geekosaur> and, well, no. same problems, and some of the solutions are worse because Windows doesn't have the tooling conventions so you have to import "alien" ones or just hardcode the lot
11:15:45 <Phyx-> the *only* problem there has ever been with compiled haskell programs and sdl2, was one of finding the packages. 
11:15:58 <Phyx-> since that's what you seem to be talking about.
11:16:00 <ongy> they left, so unless you want to discuss it with each other...
11:16:13 <Phyx-> this is a problem with specifying the right Include and Lib directories
11:16:16 <maerwald> davean: yeah, except raw file paths give no guarantees whatsoever, so I forked the 'path' package (because that wronly uses String for filepath)
11:16:22 <Phyx-> it's not a toolchain problem, It's a dependency one
11:16:42 <davean> maerwald: actually! String isn't as wrong as it might first appear! But yah ... String is fundimentally wrong
11:16:51 <davean> maerwald: there is a valid encoding to and from string though
11:16:56 <maerwald> and then there was a posix-paths package, which allows raw filepath manipulation, but that was just unmaintained, so I forked it as well :P
11:17:01 <davean> maerwald: and what guarentees do you expect?
11:17:22 <maerwald> davean: absolute vs relative
11:17:35 <maerwald> at type level
11:18:06 <davean> Oh, and I ran into a fun bug with Handle where it totally failed to sync files properly
11:18:24 <davean> maerwald: Yes, thats not a concept that POSIX really gives you?
11:18:26 <cic> but will using threads/async stuff be the same thing as using something similar to select? it's important that i get the first result rather than any result (i'm waiting on stdout and stderr from a spawned subprocess). if two threads are blocking on the handlers there's no guarantee that e.g. the stdout reading thread reports back to the main thread before the stderr reading thread if there are data on the
11:18:28 <cic> two handlers more or less at the same time but stdout was first, :/.
11:18:41 <davean> cic: yes
11:18:42 <maerwald> davean: correct
11:18:54 <maerwald> and it's even more annoying on posix, since "/" is a special case
11:18:58 <davean> cic: threads use the system native queue system at the low level
11:19:21 <davean> cic: though if they both come in together they could be scheduled in parallel
11:19:36 <davean> maerwald: yep, which are your packages BTW? This is an area of interest to me
11:19:45 <maerwald> davean: hpath
11:20:22 <geekosaur> cic, but you still have ambiguity even with select. what do you do if both fds are ready?
11:20:40 <ongy> cic: I built something like that with STM before, I don't know how strong the ordering guarantee is though
11:20:58 <cic> i want the one that was ready first in that case, geekosaur , but i'm not sure select would give me that
11:21:22 <davean> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.Handle.html#hFlush
11:21:33 <shock_one> How do I convert a value level integer into a type level integer? Like `(Nat ~ m) => n -> Proxy m`
11:21:38 <monochrom> maerwald: neato
11:21:44 <ongy> cic: select can return both aswell, you then have to have some metric to choose
11:21:46 <davean> cic: with select NEITHER is read first
11:21:49 <geekosaur> it won't necessarily. neither will anything else unless you raise to realtime priority and do other things that basically compromise the system in favor of your process
11:21:54 <davean> cic: select they come in together
11:21:58 <geekosaur> ^
11:22:05 <davean> cic: your basic concept doesn't match the actual system semantics
11:22:24 <davean> cic: I mean, that statement shows a fundimental lack of knowlege of the very signature of select
11:22:37 <geekosaur> well, not just the signature
11:22:40 <davean> cic: a trival look at hte C API for select will show the lie
11:22:51 <monochrom> Most programmers don't even read the man pages.
11:22:53 <geekosaur> the kernel won't drop everything and schedule your process just because one of the select-ed fd-s is ready
11:22:54 <davean> int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
11:23:00 <cic> but the subprocess must have written to either stdout or stderr first, so the information is there ... somewhere
11:23:06 <davean> geekosaur: even if it did
11:23:17 <davean> geekosaur: files can achieve write together
11:23:22 <davean> geekosaur: an actually common occurence
11:23:23 <ongy> davean: looking at C api when programming Haskell shouldn't be necessary (not that I don't do it)
11:23:26 <geekosaur> it bumps the scheduling priority, but may see the other fd also become ready before yoru process gets rescheduled, and then you see both of them ready in the mask
11:23:30 <monochrom> I know because when I was a student I was the only one in the whole class who read man pages.
11:23:34 <davean> ongy: He was refering to the "select" function
11:23:41 <davean> ongy: so to udnerstand what he was refering to, yes it is?
11:23:53 <geekosaur> (or, on a multicore system as is common these days, they can indeed be ready at the same time)
11:23:56 <davean> geekosaur: files become write together when they depend on a common resource to become write
11:23:58 <monochrom> All the other classmates relies on hearsay. Until they heard me saying "read the man page".
11:24:06 <monochrom> s/relies/relied/
11:24:06 <davean> geekosaur: for example depending on a network buffer clear
11:24:08 <geekosaur> sure
11:24:14 <pie__> you guys know any books on software architecture wrt functional programming?
11:24:33 <geekosaur> there's lots of cases that can come up, I was sticking to simpler ones not relying on data dependencies
11:24:54 <pie__> or something like that? or is just programming a lot really the only way to learn how to design larger applications?
11:25:02 <geekosaur> I mean, most people have trouble with even the simple cases much less the complex dependency ones
11:25:05 <Tuplanolla> Check out the functional chapters in AOSA, pie__.
11:25:25 <geekosaur> and multicore and ... --- people just don't think that way
11:25:43 <davean> geekosaur: well the point is he lacks a fundimental understanding of the thing he's referencing and needs to go back an entirely rethink what he knows of POSIX APIs
11:25:59 <pie__> Tuplanolla, i keep forgetting about that book i have so much to do heh
11:26:05 <davean> Which is he has to know what they actually are to refer to them
11:26:07 <pie__> thanks for that reminder
11:27:02 <davean> cic: But you can decide on your own order and tie break with it
11:27:35 <davean> cic: you can make a TChan or something and push events into it for example, or use the timer manager with a lock to force ordering
11:27:42 <davean> but you have to do SOMETHING
11:27:43 <cic> well, if they are ready at the same time (if that is possible ...) then i want stderr, so if there's some api that can give me that that would be perfect
11:27:56 <geekosaur> it is possible indeed. that's the point here
11:27:58 <davean> cic: Its not only possible, its *expected*
11:28:43 <davean> cic: its the usual case
11:29:18 <cic> but i don't see how this is possible with threads, maybe some api can wake the threads in the correct order, but a thread can be told to go to sleep at any time (e.g. before sending a message to the main thread) ...
11:29:36 <jmnoz> so the snap documentation says about it's httpServe that "this function never stops, to shut down the HTTP server, kill the controlling thread." How do I do this exactly?
11:29:48 <davean> cic: you share a concurrency primative and sync on that, also the TChan example
11:30:18 <davean> jmnoz: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:killThread
11:31:10 <jmnoz> davean: cheers, I'm not seeing how to find the ThreadID though
11:31:58 <davean> jmnoz: I think it stays in the thread it starts in?
11:32:09 <davean> so just use myThreadId first
11:32:31 <davean> (and save it to somewhere that some other thread can access it, because httpServe never returns as it says ...)
11:33:03 <jmnoz> davean: thanks! 
11:33:37 <davean> jmnoz: though, frankly, you quite likely forked to make the thread to run said in, and fork calls return the created ThreadId
11:34:05 <jmnoz> running from GHCi
11:34:10 <jmnoz> if that makes a difference
11:34:18 <davean> just use ctrl-c?
11:34:24 <jmnoz> it keeps running
11:34:28 <jmnoz> in the background
11:34:32 <geekosaur> ghci is a special case, yes
11:34:50 <geekosaur> probably just a bad idea to start it from ghci, unless you specifically capture the thread ID for later killing
11:35:09 <jmnoz> It seems to be the fastest way to test new changes
11:35:11 <davean> cic: Why do you want the semantics you want?
11:35:45 <geekosaur> threads are owned by the interpreter, not by the expression; they keep running until ghci exits unless you explicitly capture the thread ID to control it later
11:35:53 <apriori> hello guys. has there been any change on template haskell and cross compilation lately?
11:36:24 <ongy> TH changed a bit going to 8.0.1
11:36:24 <jmnoz> so since httpServe does not return anything, should I use hmm fork to capture the threadID?
11:36:33 <geekosaur> forkIO, yes
11:36:38 <jmnoz> perfect, thanks
11:36:53 <geekosaur> apriori, work has been done but I don't know offhand if it's complete yet
11:37:07 <cic> davean: i want to capture the output from another process, but i don't know if it will write to stderr or stdout (it differs), but i know that it will write to stderr first if it will write to them both. it's a hack, :p.
11:37:22 <cic> or know and know, believe rather 
11:37:47 <geekosaur> cic, your best bet is to dup fd 2 from fd 1 in the spawned process, and just take the first thing written
11:37:49 <cic> now i'm googling on how to do it in other languages to get some ideas
11:37:54 <apriori> geekosaur, ok. so it is expected behavior that a currently built cross compiling ghc 8.0.1 has deactivate TH support?
11:38:02 <geekosaur> yes
11:38:06 <apriori> ok
11:38:07 <cic> geekosaur: but i don't have fds, i have handlers
11:38:45 <cic> and i don't know how to get "the first thing written", that is the problem here
11:39:05 <davean> cic: you can pass in filehandles for created processes you know?
11:39:14 <geekosaur> ... if you dup them, you have *one* handle
11:39:15 <cocreature> cic: can’t you just collect stderr and stdout and append stdout to stderr?
11:39:28 <geekosaur> you really have not studied how POSIX process stuff works, have you
11:39:29 <davean> geekosaur: yes
11:39:40 <cocreature> (I missed the previous discussion so I’m probably missunderstanding something here)
11:40:04 <cic> cocreature: but i don't know when stderr is done, i only know by looking at things in stdout (a marker)
11:40:16 <geekosaur> the process's stdout and stderr are exactly the same fd (or Handle wrapper, since you also seem confused about that) --- when you read from it you get the data from whichever fd was written to first
11:40:25 <cocreature> ah ok, I thouhgt you can just wait for the process to exit
11:41:01 <cic> geekosaur: hm, no? they are two different "streams"?
11:41:03 <geekosaur> and ten your marker will come afterward, regardless of which one it was written to, unless the child process is itself doing weird thread stuff (in which case there is *nothing* you can do to make it work reliably)
11:41:12 <davean> cic: if you program on POSIX based systems more then ... well, never, you really should familiarize yourself with the system API
11:41:16 <geekosaur> cic, F_DUPFD means nothing to you
11:41:17 <geekosaur> ?
11:41:30 <geekosaur> you really need to learn about these things
11:41:43 <geekosaur> or you will keep trying to build Rube Goldberg devices
11:41:59 <cic> i've never used the c posix api as far as i recall <3
11:42:04 <davean> cic: they're not two different streams if you have them be one stream
11:42:17 <geekosaur> (the process thinks they are differen thandles. in the kernel they are *the same*)
11:42:41 <davean> geekosaur: no, the process has two entires for the same thing
11:42:44 <cocreature> tbh, F_DUPFD is not in my working memory either and I would say that I program a fair bit on posix systems. it really depends on the kind of programs you write how familiar you need to be with certain apis
11:42:47 <davean> to be more precise
11:43:16 <ongy> cocreature: but I guess you would know (roughly) what man 2 dup says?
11:43:25 <davean> F_DUPFD is wrong
11:43:27 <davean> you need dup2
11:43:34 <davean> you HAVE TO SPECIFY WHICH ONE YOU WANT IT DUPLICATED TO
11:43:40 <geekosaur> davean, not exactly because if they are wrapped in buffering abstractions the process can't easily determine that they should be shared, so buffering introduces weirdness
11:43:56 <cocreature> ongy: sure, but I wouldn’t consider it essential knowledge
11:43:57 <geekosaur> davean, dup2 is the 1970s api
11:44:06 <geekosaur> fcntl(F_DUPFD) is the modern version
11:44:24 <geekosaur> there are reasons for this
11:44:35 <davean> geekosaur: sorta, you'd have to ... well, F_DUPFD does something notably diferent
11:44:38 <benzrf> OH CRAP
11:44:42 <benzrf> type applications are already in ghc?!
11:44:47 <benzrf> this changes EVERYTHING
11:44:50 <cocreature> benzrf: yep since 8.0
11:44:52 <geekosaur> benzrf, as of 8.0.1 yes
11:45:26 <geekosaur> davean, afaik the only difference is behavior if the target fd is already open
11:45:34 <davean> geekosaur: exactly
11:45:36 <davean> geekosaur: which is huge
11:45:55 <ongy> I love how much the man page says about F_DUPFD
11:46:20 <geekosaur> apparently the linux version thinks dup2 is the real thing, even though it's been deprecated since, oh, 4.2BSD
11:46:45 <geekosaur> so yes, we'll once again pretend Linux is the One True OS and dup2() is therefore the one true API. happy now?
11:46:53 <benzrf> i've been dupfd!
11:47:51 <geekosaur> (there are actually issues with dup2()'s autoclose which are why the behavior was changed. some of those issues have security implications)
11:47:56 <cic> hm, this seems easier to do in java ... http://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html#redirectErrorStream-boolean-
11:48:07 <cic> but they don't say anything about order there ...
11:48:16 <benzrf> does TypeApplications enable ScopedTypeVariables
11:48:19 <geekosaur> only because it'd be impossible in Java if they didn't provide it for you
11:49:35 <cic> but that method would be useless here anyway because they do not give precise semantics for the merging 
11:49:55 <davean> No, the precise semantics are obvious and inherant
11:50:05 <davean> They aren't actually merged
11:50:06 <cic> not to me :(
11:50:08 <davean> they're the same file
11:50:11 <davean> *the same file*
11:50:25 <davean> Litterly the concepts are merged
11:50:33 <davean> stdout *is* stderr and vise versa
11:51:03 <cic> that would solve my problem, but i wasn't able to do that with the System.Process api
11:52:21 <Younder> davean, You mean the streams stderr and stdout are DIRECTED to the same output, surely?
11:53:11 <cic> that sounds more correct, and in that case different merge semantics would be possible
11:53:48 <davean> No, there two references to the exact same thing actually
11:53:50 <ongy> cic: have a look at createPipe and CreateProcess, especially std_out, std_err
11:54:30 <geekosaur> cic, Younder, davean was correct.
11:54:42 <geekosaur> the POSIX API does not have the limitations your understanding has
11:55:10 <davean> cic: as for doing it in Haskell, use https://hackage.haskell.org/package/process-1.4.3.0/docs/System-Process.html
11:55:18 <davean> "UseHandle Handle"
11:55:31 <Younder> I admin my Posix API understanding comes from a C universe
11:55:40 <Younder> admit
11:55:40 <geekosaur> UseHandle uses the dup api, it is what you want
11:55:53 <davean> Younder: The fact you have two names for them doesn't change what they are.
11:56:28 <cic> I could give std_out and std_err the same Handle yes, but i don't know how to create a new Handle and i don't know in which order the things will be merged, :/.
11:56:29 <davean> geekosaur: you create a pipe, pass it in as both, execute. TADA!
11:56:39 <davean> cic: they won't be merged
11:56:43 <ongy> Younder: if you only ever refere to them with the FILE * api you don't care, if you ever looked on the kernel side of things...
11:56:44 <davean> They'll be the same thing
11:56:45 <geekosaur> cic, there is no merge
11:56:49 <geekosaur> they are exactly the same
11:56:55 <geekosaur> seek on one, the other's offset changes
11:57:08 <Younder> ongy, Thank god ;)
11:57:10 <davean> My patience for dealing with people who have never learned how computers work wanes
11:57:17 <geekosaur> because they are pointing to exactly the same thing. no differences, no copying, no which one is first
11:57:22 <geekosaur> *the* *same*
11:58:20 <davean> Honestly this stuff is covered in basic UNIX programming tutorials
11:59:27 <maerwald> davean: you mean the "weird machine"? No one knows exactly how it works ;)
11:59:28 <cic> well, i don't know basic unix programming, i only wanted to write a simple haskell program that would read the output from a subprocess, but apparently it was very complicated :p
11:59:51 <davean> its not! We've given you like 4 3 or 4 line solutions
11:59:54 <geekosaur> but you are not asking for simple
12:00:00 <davean> you just keep insisting its more complicated then it is
12:00:04 <Younder> davean, Are you referring to me? I am perfectly aware how streams in Unix work.
12:00:12 <davean> Younder: I'm referencing cic
12:00:25 <davean> Younder: I've hardly seen enough of your thinking to comment
12:00:40 <davean> Younder: the only thing you've really said was wrong but a debatable wording choice
12:00:55 <Younder> agreed
12:01:03 <davean> Younder: and was more about the use of english then semantics, given the english was poorly enough defined to ask questions about
12:01:18 <geekosaur> cic, but you are asking for this bit about stderr before stdout unless stdout written first... that is simple to do but you seem to be unable to wrap your mind around the key concept
12:01:40 <davean> cic: http://pubs.opengroup.org/onlinepubs/9699919799/
12:02:15 <davean> To be clear, this "key concept" is common to *all* programs running on any POSIX derived system
12:02:38 <davean> infact, if memory serves, the same concept would even be relivent on Windows though with a few layers of complexity
12:02:43 <cic> thanks for all the help angry internet people, i will take a second look at the system.process api things and see if i understands things more clearly now
12:02:57 <davean> I know of no commonly-used non-POSIX derived or Windows system in current use 
12:03:14 <ongy> cic: for creating the handle look at createPipe, and some doc on pipe in general
12:03:22 <ertes> davean: last time i programmed on windows it had completely different semantics…  in particular no forking and no "HANDLE" duplication
12:03:27 <ertes> but it's like 10 years ago
12:03:41 <maerwald> ertes: oh jeez, you've been on the dark side?
12:03:44 <davean> ertes: yes, but they do have a buffer object
12:03:51 <davean> ertes: that you can do similar things with
12:04:03 <ertes> maerwald: yeah, and it was a painful experience
12:04:05 <davean> ertes: but yes, I haven't seen a windows system in a decade, so memory is rather faint
12:04:27 <geekosaur> ertes, anything post-windows me has handle duplication and you can even do it from cmd.exe with similar syntax to the Bourne shell (eg. 2>&1)
12:04:33 <geekosaur> iirc
12:04:37 <davean> I am CONSTANTLY amused when the "someone broke the windows build!" messages hit the mailing list
12:04:59 <geekosaur> that's mostly because there's never a windows builder online though
12:04:59 <davean> geekosaur: I thought the early NTs has the same sort of thing too
12:05:02 <jmnoz> so when I use forkIO in GHCi the output is a bit scrambled, why is that you think?
12:05:13 <geekosaur> davean, that was the point, NT/2000/etc. added it
12:05:25 <geekosaur> winme was the last release in the pre-NT model
12:05:28 <davean> geekosaur: ok, NT predates ME though hence confusion
12:05:34 <MitchellSalad> jmnoz: because putting a string to a handle is not an atomic operation
12:05:44 <geekosaur> and it was intended to be transitional between old-Windows and the NT model
12:06:01 <davean> geekosaur: mmm, but NT is 1993
12:06:02 <jmnoz> MitchellSalad: thanks :)
12:06:06 <geekosaur> (before that Microsoft was targeting the NT line at business and the old line at consumer)
12:06:26 <davean> geekosaur: Sure they both existed though
12:06:31 <geekosaur> yes
12:06:46 <MitchellSalad> jmnoz: sure. either only print to the terminal from one thread, or else acquire a lock before printing
12:07:12 <ertes> geekosaur: my last experience was on XP, but i may just have failed to understand those help texts
12:07:24 <MitchellSalad> jmnoz: also if you are doing some fancy things, this library may be useful: https://hackage.haskell.org/package/concurrent-output
12:07:35 <davean> Early NTs has a POSIX API so you *litterly* had dup2
12:07:37 <geekosaur> XP should have had it, but often those things ended up in different APIs
12:07:40 <geekosaur> Foo vs. FooEx
12:07:59 <davean> XP lost that but had other techniques
12:08:02 <geekosaur> early NTs had a POSIX *subsystem*. you couldn't mix them
12:08:06 <ertes> it's only when you spell out MsgWaitForMultipleObjectsEx and use its awkward API along with the other awkward APIs of windows that you appreciate the simplicity of POSIX
12:08:16 <davean> geekosaur: coudln't mix them but it was an interface to the kernel
12:08:18 <Younder> ertes, I belive Windows 2000 solved most of the problems. But yo the general public, yes, they saw them in XP.
12:08:22 <davean> geekosaur: it wasn't seperate persay
12:08:28 <ertes> or should i say *relative* simplicity (POSIX is not simple)
12:08:40 <systemfault> Windows 2000 was really good
12:08:42 <geekosaur> davean, actually it was. NT is a microkernel. the subsystems run side by side
12:09:12 <jmnoz> MitchellSalad: cheers
12:09:31 <geekosaur> stuff done in one is not necessarily visible to the other. the BashOnWindows stuff currently going on is doing the same thing, it's a separate subsystem/kernel under the microkernel with limited access to other running subsystems
12:10:06 <geekosaur> different system APIs, separate process tables, etc.
12:10:08 <davean> geekosaur: both of what we said is true, the API is a subsystem but backed by the same kernel resources and acting as an interace
12:10:27 <geekosaur> ...
12:10:28 <davean> so sharing things like disk/filesystem access/buffering
12:10:47 <geekosaur> to the extent that that is yet another subsystem providing services to both, yes
12:10:52 <davean> Exactly
12:10:55 <rmrfroot> the word "proc" is not a reserved name in Haskell, right? 
12:10:57 <monochrom> Split personality is so confusing. I need a drink.
12:11:07 <MitchellSalad> rmrfroot: i think only if -XArrows is on
12:11:12 <geekosaur> ^
12:11:34 <MitchellSalad> that is, it *is* a reserved word with -XArrows
12:11:56 <monochrom> But "Hakyll and Hyde use the same stomach" is very little consolation.
12:11:59 <rmrfroot> MitchellSalad, geekosaur: alright, thanks! haskell-mode was highlighting it the same way "data" and "type" is highlighted
12:12:11 <MitchellSalad> yup. "pattern" and "static" too
12:12:23 <geekosaur> yes, it can't know if something is using Arrow extension because it could come from ghc command line or cabal file, etc.
12:12:30 <davean> monochrom: Yah, I replaced Hakyll because very little was a consolation with it :)
12:12:33 <cic> side note: proc is a function in System.Process
12:13:26 <rmrfroot> alright, thanks for clearing that out, geekosaur, MitchellSalad
12:14:09 <rmrfroot> cic: ah ok! currently trying out the library turtle, maybe the proc i'm using is the same thing?
12:14:51 <MitchellSalad> it's a simplified interface, yeah
12:15:07 <monochrom> Oh! turle, shell. haha
12:15:11 <cic> rmrfroot: is it used to spawn new processes?
12:15:51 <cic> (or for creating descriptions for new processes rather)
12:15:52 <rmrfroot> cic: yeah! MitchellSalad was right: https://hackage.haskell.org/package/turtle-1.3.0/docs/src/Turtle-Prelude.html#proc
12:16:03 <rmrfroot> just a simplified interface
12:16:32 <MitchellSalad> for some definition of simplified*
12:16:37 <cic> rmrfroot: high five for using the same function then :p
12:16:50 <rmrfroot> cic: *virtual high five*
12:17:09 <MitchellSalad> o/\o
12:17:20 <rmrfroot> :D
12:19:00 <rmrfroot> everybody was virtu-al high fiviiiing, HOOO HAAA, those kids was fast as lightning
12:20:14 <davean> My, there is no salvation if Handle ever sees a record based file
12:20:35 <ongy> how fast is lightning? C?
12:20:49 <davean> ongy: huh?
12:20:58 <jmnoz> african lightning or north european lightning?
12:21:20 <KaneTW> probably around 2/3rds c
12:21:25 <rmrfroot> that is a very good question
12:21:50 <KaneTW> according to a quick google, around 1/3 c
12:21:51 <rmrfroot> KaneTW: so basically Java then?
12:21:54 <KaneTW> heh
12:21:59 <monochrom> haha
12:22:05 <davean> rmrfroot: when is Java that fast?
12:22:24 <monochrom> @quote monochrom faster.than
12:22:24 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
12:22:30 <davean> rmrfroot: Java hasn't even finished figuring out which interpriter it'll use by the time my C programs are done executing
12:23:33 <rmrfroot> haha
12:24:39 <maerwald> well, your C programs are usually more vulnerable :P
12:25:29 <glguy> davean's programs finish running before anyone has time to attack them. too fast
12:26:05 <ongy> works best by just setting them -x
12:26:20 <davean> glguy: you joke, but since most of my C programs execute on local content I specify I argue definitionally they can't be insecure, they can only do what I tell them to do :)
12:26:38 <maerwald> I disagree
12:27:01 <maerwald> every part of a system can potentially be part of an attack
12:27:16 <ertes> davean: you replaced hakyll?  by what?  i'm currently using a Makefile with pandoc, but i'm not overly happy with it
12:27:25 <davean> ertes: with AlON
12:27:44 <davean> ertes: which is a bit rough, but ... http://code.xkrd.net/davean/ALON
12:28:05 <davean> its rather in the "developers only" phase of use
12:28:21 <davean> but it has a few neat features and I find its desing far more sensible to work with
12:29:19 <rmrfroot> davean: cool beans!
12:29:47 <ertes> davean: ah, i actually need a static solutions, because i'm just using github pages
12:29:51 <davean> ertes: It needs usefriendlyness, I figure I'll be porting that over as I use it and find commonalities between things I make with
12:29:55 <davean> ertes: it can export to static too
12:30:07 <davean> ertes: you just save the resulting DirTree after one step
12:30:15 <davean> though that drops a lot of its more powerful features
12:30:24 <maerwald> oh great, a gitlab hosting without https :P
12:30:25 <jmnoz> is it safe to decodeUtf8 a ByteString supplied as a HTTP request parameter? :)
12:30:28 <davean> though! you can write out to github or S3, or others on update
12:30:33 <davean> from a client computer
12:30:47 <davean> maerwald: Oh, it has HTTPS, but its on the internal VPN
12:30:59 <ertes> davean: if my use case is static, does it have any advantage over hakyll or my more simplistic solution?
12:31:00 <maerwald> which now means I might look at random content
12:31:02 <davean> maerwald: I probably could add the wider internet to that list
12:31:06 <davean> maerwald: it has a cert :)
12:31:11 <maerwald> not for me
12:31:57 <davean> ertes: Hakyll seems to make sense for simple cases. But when you start doing weird things its definition system really fell over for me
12:32:07 <davean> maerwald: thats because its not listening on the public port, I can fix that
12:32:17 <maerwald> davean: and I want to be able to clone via https...
12:32:38 <davean> maerwald: Oh, yah, uh, I never even considered people cloning via not SSH :-p
12:32:52 <davean> IME clone via HTTPS doesn't work
12:32:57 <davean> but thats because I deal with alrge repos
12:33:02 <ertes> davean: yeah, i had a hakyll site, but the way it works is super-confusing…  i have no idea how my tags or even my feed were generated
12:33:10 <hashme> guys can you have a look at this
12:33:13 <hashme> http://lpaste.net/350082
12:33:15 <ertes> everything in hakyll is like:  "do this and this", but none of the steps really make any sense
12:33:18 <rmrfroot> davean: I want to clone over davean: cool beans!
12:33:18 <rmrfroot> davean: cool beans!
12:33:19 <davean> ertes: yes, where as ALON should make that obvious
12:33:19 <rmrfroot> davean: cool beans!
12:33:19 <rmrfroot> davean: cool beans!
12:33:20 <rmrfroot> davean: cool beans!
12:33:22 <hashme> i need to parse float numbers
12:33:26 <rmrfroot> haha :D
12:33:48 <rmrfroot> what just happened
12:34:05 <ertes> hashme: do you want to write a parser for them, or just use a ready-made parser?
12:34:21 <rmrfroot> davean: i was going to say "i want to clone over IPoAC, can you make that happen?"
12:34:30 <hashme> i have sent a link right
12:34:32 <hashme> http://lpaste.net/350082
12:34:32 <davean> rmrfroot: actually, yes
12:34:39 <Tuplanolla> It's incomplete, hashme.
12:34:40 <davean> rmrfroot: I know someone with some birds ...
12:34:42 <rmrfroot> davean: :D
12:34:43 <hashme> how can i improve it :/
12:35:15 <maerwald> davean: I don't see ssh cloning, only git protocol, non-authenticated
12:35:29 <davean> maerwald: yes, I'm just not use to people who don't have accounts :)
12:35:41 <davean> maerwald: most people who interact with it have accounts, and are on a VPN
12:35:44 <maerwald> davean: I'm not creating an account on a HTTP site
12:35:52 <davean> we only exposed it publicly to be able to reference it to people
12:35:56 <hashme> there's a ready made parser for float?
12:35:58 <davean> maerwald: of course
12:36:02 <davean> maerwald: as I said, I'll expose HTTPS
12:36:06 <maerwald> kk
12:36:26 <hashme> ertes: what's the ready made parser?
12:36:33 <ertes> hashme: what kind of improvement are you looking for?  your parser doesn't actually parse floats
12:36:48 <ertes> hashme: as far as i see it accepts something like "...5..."
12:37:01 <hashme> Tuplanolla: I understand, how can I take only '.' only once - I need to eleminate cases like 1.2.3
12:37:04 <ertes> hashme: the ready-made parser would be in the Numeric module in base
12:37:25 <maerwald> davean: btw. I find gogs easier to deploy and work with than gitlab
12:37:26 <hashme> ertes: yeah, i need to take '.' only once
12:37:39 <maerwald> and less ruby hackery
12:38:01 <rmrfroot> maerwald: is memory usage any better with gogs?
12:38:04 <davean> maerwald: maerwald the ruby hackery in gitlab is terrible, but gogs hardly does what I want
12:38:10 <ertes> hashme: do pfx <- many digit; char '.'; sfx <- many1 digit; …  -- this would be a simplistic parser that only requires the '.' and at least one place after the '.'
12:38:11 <davean> or didn't
12:38:16 <maerwald> rmrfroot: definitely and one of the reasons I switched
12:38:34 <maerwald> my vserver only has 2gig ram
12:38:41 <davean> hehe, the memory of the management system is NOTHING compared to what git takes to clone a 150GB repo
12:38:43 <ertes> hashme: so it accepts ".5", "13.623", but not "1." or even "1"
12:39:05 <maerwald> 150gb repos suggest that someone should be fired :P
12:39:07 <hashme> ertes: thanks a lot!
12:39:18 <davean> maerwald: a lot of what is in git isn't code
12:39:26 <maerwald> exactly, fire them
12:39:38 <davean> No, really its terrible that one doesn't version the entire project
12:39:49 <rmrfroot> haha
12:39:55 <davean> version control falls appart if there exists non-versioned components
12:40:31 <kuribas> which language do you use for your job?
12:40:49 <davean> kuribas: that might help if you directed it at someone?
12:40:57 <kuribas> davean: anyone?
12:42:40 <kuribas> A job search gave me 0 results for haskell, but at least 30 for C++ in my regio.
12:42:41 <davean> kuribas: I use Haskell
12:42:59 <maerwald> kuribas: yep, that's normal
12:43:07 <Tuplanolla> What job only requires a single language, kuribas?
12:43:25 <davean> I also do a touch of C
12:43:37 <ertes> kuribas: you don't do job search for haskell jobs…  you keep track of haskell-cafe, reddit, twitter, etc.
12:43:38 <kuribas> Tuplanolla: yeah, C++ and lots of other stuff (sql, qt, etc...)
12:43:43 <davean> Tuplanolla: which ones require multiple? When the language isn't important its pretty arbitrary which you use
12:43:51 <rmrfroot> kuribas: i have a list of companies that use haskell if you're interested?
12:43:51 <hashme> ertes: For parsing integers I did, parseInteger = liftM (Number . read) $ many1 digit
12:44:00 <kuribas> rmrfroot: sure
12:44:01 <davean> kuribas: you have jobs show up in job search places when they aren't filled easily
12:44:21 <ertes> hashme: which parser library?
12:44:22 <hashme> ertes: How can I avoid "1..2" in that - like 1..2 will be parsed as 1
12:44:44 <hashme> ertes: Text.ParserCombinators.Parsec
12:44:49 <kuribas> rmrfroot: not in Belgium by any chance?
12:44:55 <ertes> hashme: the parser you just showed avoids it…  it doesn't accept '.'
12:45:32 <rmrfroot> kuribas: it's a list from a thread at reddit.com/r/haskell, haven't gone through all of them. http://lpaste.net/8388363642130661376
12:45:48 <geekosaur> hashme, that parser will stop at the '.', if '1..2' is being accepted then it's coming from some other part of the parser
12:45:55 <kuribas> rmrfroot: ok, thanks
12:46:20 <hashme> Hmm wait a sec, I'll check the other parsers out
12:46:24 <rmrfroot> kuribas: btw, unrelated to haskell. dutch is spoken in Belgium, right?
12:46:42 <kuribas> rmrfroot: yeah.  And french (in the other part).
12:47:46 <rmrfroot> kuribas: cool. i'm studying dutch, that's why i asked. had a vague memory that dutch was spoken in Belgium :P
12:48:06 <maladiec> Swould spend some of their time explaining me this problem solution, described http://stackoverflow.com/questions/41192722/valuation-a-data-structure-and-eval-function
12:48:08 <sm> davean, ertes: interesting, I'm probably about to replace hakyll with sprinkles, which ALON seems a little like 
12:48:08 <kuribas> rmrfroot: heh, didn't think anyone would be interested in our small language.
12:48:21 <hashme> I removed all the others parsers, and it still doesn't give any errors.. hmm.. :/
12:49:17 <davean> sm: does it do cool tihngs like allow directly pushing deltas to clients in realtime? ;)
12:49:23 <ertes> sm: i'll probably write my own site-specific thing at some point, because i'd like to use lucid and clay for templating
12:49:35 <hashme> ertes: It accepts 1.2 but not ".2", or "an" and all
12:49:54 <ertes> hashme: the last one?
12:49:56 <hashme> ertes: Basically, it accepts if the input starts from that number
12:50:10 <sm> davean: I'm not sure that that means.. it just added ranged download support, if that's relevant
12:50:15 <hashme> parseInt = liftM (Number . read) $ many1 digit
12:50:33 <ertes> hashme: that accepts the "1" part from "1.2"
12:51:12 <hashme> ertes: Yeah, I understand that. But, that's not how an Int parser should work right. I want it give an error. :/
12:51:18 <sm> davean: how dynamic is ALON ? when/for what do you need to compile haskell ?
12:51:38 <davean> sm: you need to compile Haskell when you change the rules that define how your site is generated
12:51:39 <ertes> hashme: why?  is your whole document supposed to be a single integer?
12:51:57 <ertes> remember that your integer parser will most likely be composed with some other parsers
12:52:14 <hashme> ertes: I'm writing an interpreter for Lisp
12:52:42 <hashme> ertes: I started fp and haskell a week back. Still a beginner so.
12:52:42 <ertes> hashme: exactly…  parseInt (you should probably not call it a verb, but a noun like "integer") will be composed with other parsers
12:53:00 <ertes> hashme: suppose you call it 'integer'
12:53:20 <ertes> hashme: this is the parser that parses three integers separated by spaces:  do integer; char ' '; integer; char ' '; integer
12:53:38 <sm> davean: like hakyll then, and I guess you have the full power of haskell available. sprinkles doesn't let you use haskell
12:54:29 <hashme> ertes: basically, that parser like many . digit , that's all 
12:54:43 <hashme> ertes: I dont want that, I want to parse an integer only
12:54:46 <rmrfroot> does hakyll has a lot of limitations on what you can do? 
12:54:56 <ertes> hashme: then you can't use that parser in a larger grammar
12:54:58 <hashme> I'll just write many . digit where I need to use
12:55:06 <davean> sm: yes, AlON is designed to handle full sites, not just the simple cases
12:55:09 <Zemyla> I have a question. Could the axioms of set theory be translated into Haskell types?
12:55:22 <ertes> hashme: if that's really what you want, then you want it to be followed by EOF
12:55:24 <sm> rmrfroot: not as long as you want to generate static files. It won't serve dynamic pages for you
12:55:46 <sm> davean: will check it out
12:55:54 <ertes> hashme: do Number . read <$> many1 digit; eof
12:55:55 * maerwald wishes the whole internet would be static sites
12:55:56 <hashme> ertes: char '\n'
12:55:58 <davean> AlON can serve dynamic files too :) it can also handle time gating files, and a lot of other things
12:56:23 <hashme> ertes: or yeah eof, is eof a built in thing
12:56:29 <sm> static is good, but dynamic pages do simplify things sometimes
12:56:30 <ertes> hashme: that one only accepts a string of digits with nothing following them
12:56:36 <rmrfroot> sm: alright, so it's not like this big framework that you are forced to use in a certain way? 
12:56:38 <ertes> hashme: yeah, it's built-in
12:56:43 <davean> sm: AlON is described as "minimally dynamic"
12:56:56 <maerwald> sm: you can't reason about security when you have a turing complete set of HTML5 + javascript hackery
12:56:58 <davean> sm: it should excell as using static file hosting for serving semi-dynamic sites
12:57:05 <Zemyla> For instance, NBG theory is finitely axiomatized, so could it be translated into a finite number of Haskell (or Coq or Agda or Idris) values?
12:57:21 <hashme> ertes: wait so , even for the parser for float, should i end with eof    o.O
12:57:56 <rmrfroot> maerwald: i just wish you could run websites javascript directly on the kernel
12:57:59 <ertes> hashme: if you want them to *only* parse a float…  parsers like that can't be embedded into a larger grammar
12:58:09 <ertes> hashme: example: you can't use them as part of an s-exp parser
12:58:15 <sm> I would like a fully dynamic site for dev/test, that you can optionally freeze to static files for production
12:58:24 <davean> sm: yep
12:58:25 <ertes> hashme: example string: (1 2 3)
12:58:33 <sm> I believe some commercial app servers work that way
12:58:39 <davean> sm: Infact, AlON can update your *webbrowser* on base file change without a reload
12:58:57 <davean> sm: every resource comes with an event stream that says when it changes
12:59:00 <maerwald> It matters where our systems (especially protocols) are in the chomsky hierarchy. But that has been ignored for most of what we have today and what makes up the internet, which is one of the reasons it's broken.
12:59:03 <ertes> hashme: you can't parse this using:  do char '('; integer; char ' '; …
12:59:10 <sm> great, when is first release ?  :)
12:59:21 <ertes> hashme: that's why using 'eof' is often just sign of a misunderstanding
12:59:55 <pie__> you guys know any disassemblers/decompilers written in haskell? or should i really be looking for reengineering stuff
12:59:56 <pie__> ?
12:59:56 <sm> davean: uh, and what will the real name be :)
13:00:00 <hashme> ertes: Hmm .. I understand, I'll probably need to for a larger point of view... ahh well anyway thanks a lot!
13:00:06 <davean> sm: for AlON? AlON
13:00:10 <davean> thats its actual name
13:00:17 <davean> sm: and it can do the browser update thing right now
13:00:20 <sm> that is not a very marketable name
13:00:27 <sm> no offense intended
13:00:37 <davean> Fuck if I care, its aluminum oxinitride, its strong and transparent :-p
13:00:38 <ertes> hashme: you should understand why accepting "1" from "1.2" is *fine* and the way an integer parser is supposed to work
13:01:04 <hashme> ertes: Yes yes, I think I'll need it later like you said
13:01:05 <davean> er aluminium oxynitride
13:01:06 <sm> I care because I want frameworks I use to have some community support
13:01:25 <sm> anyway, sounds cool, thanks for sharing it
13:01:58 <davean> Why do you tihnk its a bad name BTW? ;)
13:02:39 <ertes> davean: a name like "integer" makes your parser read like a grammar instead of a sequence of instructions
13:02:50 <davean> ertes: yes?
13:03:04 <davean> ertes: Not sure how that relates
13:03:18 <ertes> davean: doManyTimes parseDigit
13:03:19 <hpc> ertes: you crossed the topics ;)
13:03:20 <davean> sm: oh, asking about the name was to you
13:03:24 <ertes> davean: vs. many digit
13:03:29 <davean> ertes: where?
13:03:41 <davean> ertes: which file/line?
13:03:47 <ertes> oh
13:03:59 <ertes> davean: i crossed topics as hpc said =)
13:04:02 <ertes> ignore me
13:04:06 <davean> Oh, you massively confused me
13:04:14 <davean> I'm always happy to ahve code feedback but ...
13:04:39 <ertes> damn fixed-width fonts
13:04:58 <ertes> also i request to ban all sans-serif fonts everywhere
13:05:20 <hpc> there's some really good sans fonts
13:05:31 <hpc> which don't have 1liI 0O problems
13:05:53 <davean> maerwald: gogs seems to have gotten massively better in recent years
13:06:37 <ertes> hpc: that's just part of the problem with sans fonts:  serif fonts have more defined strokes and are more complicated, which actually helps our brain recognise patterns
13:06:41 <maerwald> davean: yeah, I believe only CI integration is what keeps some people from switching. Gitlab is more advanced on that side
13:06:51 <davean> maerwald: mmm, and that is nice
13:07:04 <hpc> ertes: ish
13:07:28 <hpc> this is getting off topic, but there's been research into it and for things like dyslexia, fonts that mitigate it are sans
13:07:51 <sm> davean: it has no meaning or feel-good associations for most people, so will be hard to remember, and the mixed-case spelling makes that worse
13:08:26 <davean> sm: Hakyll doesn't have any meaning or association without jekyll or whatever it is which as far as I know had none to being with?
13:08:32 <hpc> it's no more or less marketable than "haskell"
13:08:54 <monochrom> Oh darn, it was Jekyll not Hakyll.
13:08:58 <sm> I think hakyll is a better name than AlON, but that doesn't matter
13:09:13 <davean> sm: I'm more interesting in your beliefs in naming then anything else ATM BTW
13:09:20 <monochrom> consider A10N :)
13:09:30 <davean> monochrom: oh god
13:09:46 <monochrom> Oh oh did you also know this?
13:09:51 <monochrom> @quote monochrom IO
13:09:51 <lambdabot> monochrom says: In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10
13:09:51 <lambdabot> XML processing using arrows.  The difference in productivity is incredible
13:09:56 <monochrom> err no
13:10:02 <monochrom> @quote monochrom denotation.*IO
13:10:02 <lambdabot> No quotes match. You type like i drive.
13:10:07 <sm> lambdabot, causing chaos as usual :)
13:10:21 <monochrom> @quote monochrom IO.*denot
13:10:21 <lambdabot> monochrom says: <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width
13:10:21 <lambdabot> in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
13:10:27 <monochrom> That one.
13:11:03 <hpc> that's what haskell has been missing this whole time!
13:11:07 <hpc> a formal semantics of the shift key
13:11:39 <davean> sm: I agree on mixed-case which is why I made it all-caps for its actual naming
13:12:03 <ertes> hpc: well, yeah, i didn't consider dyslexia, but i find myself having more trouble with sans texts, especially when they're monospaced…  perhaps i have a form of dyslexia =)
13:12:36 <ertes> if there were any good serif monospace fonts i would switch away from DejaVu Sans Mono, which i'm currently using for emacs
13:13:10 <hpc> i am pretty happy with droid sans mono
13:13:33 <hpc> i can get a 200 character wide terminal on my phone and still be able to read it
13:13:39 <davean> maerwald: I think I might try out gogs, It looks to do at lest the majority of the things I find critical now.
13:13:52 <hpc> (not that i actually do that, but it makes a nice test of a font)
13:14:18 <ongy> hpc: resolution and dpi? very relevant. I'd have 4pixel/char with that
13:14:22 <maerwald> davean: works also well when containerized
13:14:27 <hashme> Guys how can irrational numbers be represented in haskell?
13:14:40 <maerwald> I currently run it via docker
13:15:09 <hpc> ongy: 442ppi, 1920x1080, 5in diagonal
13:15:21 <hpc> (also landscape)
13:15:48 <hpc> hashme: exactly, or approximately?
13:16:09 <hashme> hpc: like a symbolic representation 
13:16:12 <hpc> hashme: also are you looking for a library, or the mechanics behind how to represent them
13:16:17 <hashme> hpc: like in sympy
13:16:47 <hashme> hpc: is there a library? i was thinking how to represent them
13:17:45 <ertes> hashme: as streams of digits, as streams of increasingly more accurate rationals, etc.
13:18:08 <hashme> hpc: how would you approximate like square root of 5, and get the rational value
13:18:19 <hpc> > sqrt 5 :: CReal
13:18:22 <lambdabot>  2.2360679774997896964091736687312762354406
13:18:46 <hashme> whats the module name again
13:18:55 <hpc> > drop 950 $ showCReal 1000 (sqrt 5)
13:18:57 <lambdabot>  "9994822138521773485924535151210463455550407072278724"
13:19:31 <hpc> hoogle should be able to find it for you
13:20:02 <ertes> hashme: what's the use case?
13:20:03 <hashme> alright :)
13:20:40 <rmrfroot> how does hoogle search? text search of the source code? or does it actually compile/evaluate any of the haskell code?
13:20:42 <pie__> hashme, i saw this a while ago https://www.youtube.com/watch?v=LJQgYBQFtSE
13:20:50 <pie__> "Exact Real Arithmetic in Haskell - Mitchell Riley - BFPG 2015-05 "
13:21:58 <hashme> Ahh
13:22:24 <hashme> How do I define new data types and include in another new data type
13:22:26 <hashme> Like
13:22:27 <hashme> http://lpaste.net/350084
13:22:41 <ertes> rmrfroot: hoogle indexes source code, then searches through that index
13:23:21 <roboguy`> hashme: I think you are confusing data constructors and type constructors
13:23:25 <rmrfroot> ertes: alright! 
13:23:36 <roboguy`> You are defining the "Complex" data constructor twice
13:24:10 <roboguy`> It might help to have different data constructor names than type names, to make things more clear. Like: data Rational = MkFloat Float | MkInteger Integer
13:24:50 <hashme> data Complex = MkComplex Real Real
13:25:06 <hashme> and then, data Number = Real Real | Complex Complex
13:25:07 <hashme> ?
13:25:33 <Welkin> o.o
13:25:40 <Welkin> Num is a typeclass in haskell
13:25:43 <roboguy`> hashme: well... That would fix the error. I suspect there is still a misunderstanding though, and I'm not sure exactly what it is yet...
13:26:01 <hashme> Yeahh :P
13:26:08 <roboguy`> hashme: it might be worth pointing out that Haskell already implements a number tower like this
13:26:14 <hashme> Umm can you make the tree for this one?
13:26:16 <roboguy`> (well not "like this")
13:26:23 <hashme> And,can I see it and understand it?
13:26:40 <roboguy`> hashme: it is implemented through the numeric typeclasses (Num, Integral, Floating, etc)
13:26:57 <roboguy`> it is probably best to focus on learning about data types before type classes
13:27:08 <hashme> Yes, I'm doing this because I'm writing a Lisp interpreter
13:27:26 <ertes> with real number arithmetic?
13:27:30 <Welkin> you mean scheme?
13:27:31 <roboguy`> hashme: ahh. Why not have all those kinds of numbers in the same data type?
13:27:55 <hashme> Yeah I could do that, that's a real easy thing to do
13:28:06 <hashme> But, I'm trying out new things so that I understand Haskell
13:28:11 <hashme> I'm learning that so :P
13:29:35 <roboguy`> hmm, well do you understand why it gave an error?
13:29:40 <hashme> Welkin: yeah
13:29:46 <Welkin> you choose them not because they are easy, but because they are haaaaaaaaado
13:30:28 <hashme> hmm, because type constructor is the same (Complex and Complex)
13:30:29 <hashme> ?
13:30:43 <roboguy`> hashme: data constructor not type constructor. Other than that, yeah
13:31:22 <hashme> roboguy`: I guess that's it?
13:31:29 <Welkin> you guess?
13:31:33 <hashme> I mean that's the compile error at least :P
13:32:14 <roboguy`> hashme: let me put it this way: with the original code, what type would you expect a value given by "Complex 1" to have?
13:33:46 <roboguy`> or, how would it know which "Complex" to use?
13:34:01 <hashme> I need Complex to be composed of two real nos, so (Complex 1 1) would make sense
13:34:06 <hashme> (Float, Float)
13:34:39 <roboguy`> hashme: but there is another Complex data constructor which has only one argument: the one defined in the Number type
13:34:57 <hashme> Right
13:35:03 <roboguy`> so they conflict
13:36:16 <hashme> i'll just have to give data contructors a diff name ..
13:37:20 <Welkin> what's the problem with just using `data Number = Real Double | Complex Double Double` ?
13:38:10 <hashme> Welkin: Absolutely no problem, as I told you wanted to use another data type that I had defined somewhere. 
13:38:18 <hashme> Welkin: just to learn how to do thta
13:39:44 <hashme> Welkin: Real can be double or integer
14:02:00 <seishun> is there a maximumBy that returns Maybe? (Nothing on empty list)
14:02:12 <Welkin> :t maximumBy
14:02:14 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
14:03:00 <Welkin> you can write your own wrapper
14:03:11 <Welkin> just check if the input is empty, then produce Nothing
14:03:21 <Welkin> otherwise, run `maximumBy` and wrap it in Just
14:15:25 <seishun> http://lpaste.net/1682493334435659776 this looks kinda ugly... I get the feeling it can be simplified somehow
14:15:27 <MarcelineVQ> ​\f -> fmap (maximumBy f . uncurry (:)) . uncons -- I have no idea how practical this is
14:15:46 <seishun> yeah I'd prefer something readable
14:22:53 <Welkin> seishun: maybe this http://lpaste.net/1682493334435659776
14:24:20 <maladiec> Maybe someone could tell me where's the mistake http://pastebin.com/sRWgT6ej
14:24:22 <seishun> well that's the same thing reordered...
14:24:53 <Tuplanolla> Line 7, you call `eval` on two incompatible types, maladiec.
14:25:29 <Welkin> seishun: yes
14:26:01 <Welkin> something else you could do is this
14:26:06 <hpc> maladiec: the only valid case you have right now is on line 5
14:26:44 <maladiec> Thank you
14:26:47 <hpc> maladiec: if you are doing this as a learning exercise and don't want the solutions fed to you, i suggest commenting out lines 6,7,8 and fixing them individually
14:26:59 <hpc> one at a time so you get clear errors
14:27:27 <Welkin> well, just moving those checks into pattern mathces insitead of if then else
14:27:34 <hpc> your definition of Expr makes this a perfect opportunity to get used to thinking very precisely about recursive definitions
14:27:44 <hpc> and how types unify
14:28:14 <EvanR> lets say a real number is two functions Rational -> Bool
14:28:28 <EvanR> is there a working algorithm for addition
14:28:57 <hpc> EvanR: what do those functions encode
14:28:58 <hpc> ?
14:29:05 <EvanR> dedekind cuts
14:29:36 <lyxia> Isn't Rational -> Bool more or less equivalent to [Rational]
14:30:02 <EvanR> i would say less equivalent
14:30:17 <lyxia> Oh no you can't decide that something doesn't belong to the list
14:30:35 <lyxia> but you can do (Rational -> Bool) -> [Rational] by filter
14:32:11 <EvanR> lower q means q < x, upper q means q > x
14:32:25 <EvanR> false would mean not that
14:32:38 <hpc> (Rational -> Bool) is the cantor space, i think?
14:32:59 <lyxia> EvanR: why does that need two functions
14:33:22 <EvanR> if you only have one side, that defines an infinite half of the real line
14:33:48 <EvanR> you can also relax the conditions on the cut so its not "located" i.e. it doesnt have to be missing a single point
14:33:57 <lyxia> ah I see
14:34:39 <EvanR> so you can get an approximation as close as you want with the two test functions
14:34:42 <seishun> Welkin: did you say anything while I was offline?
14:34:51 <EvanR> but i cant see any way to add numbers
14:35:37 <Welkin> seishun: nope
14:47:44 <lyxia> EvanR: given lowerX and lowerY, lowerXplusY q can be decided by finding a pair (i,j) such that i+j = q and lowerX i = lowerY j, which has to exist...?
14:53:14 <EvanR> lyxia: yes, by finding i and j. whether it has to exist or not... good question
14:53:30 <EvanR> i certainly cant think of a working algorithm to find them
14:54:16 <lyxia> so, either q < x+y, then there are i < x, j < y s.t. i+j = q.
14:54:28 <lyxia> idem s/</>/g
14:54:41 <EvanR> what
14:54:43 <lyxia> s/>/>=/g actually
14:55:03 <Welkin> lyxia: that just adds to the confusion
14:55:05 <lyxia> okay that was not clear my bad.
14:55:11 <Welkin> stop using that s//g vim syntax
14:55:43 <EvanR> you can choose rationals x and y such that q < x+y
14:56:00 <EvanR> then what
14:56:57 <lyxia> We have x and y represented by cuts
14:57:15 <EvanR> so now x and y are reals
14:57:29 <lyxia> let me just paste this
15:03:51 <lyxia> EvanR: http://lpaste.net/350086
15:05:21 <EvanR> either q < z or q >= z, where we dont know real number z yet, sounds like excluded middle
15:05:30 <EvanR> unless you have a way to decide that
15:06:03 <EvanR> thats before we get to the pure existence
15:07:24 <lyxia> Aren't the reals totally ordered
15:08:00 <EvanR> well this is a fine proof
15:08:28 <lyxia> I forgot to write the definition of lowerZ
15:08:30 <EvanR> but it doesnt compute z
15:09:17 <lyxia> it computes lowerZ
15:09:49 <EvanR> however in the language of abstract stone duality, formulas like for all and there exists get interpreted as certain kinds of procedures to do stuff, and addition is continuous so it should work
15:10:02 <EvanR> what we have here is a lot less to go on though... just two test functions
15:10:38 <EvanR> lyxia: no, we dont have a procedure for deciding if x < y. thats not possible
15:10:57 <EvanR> it can only be done with excluded middle
15:11:04 <EvanR> x < y is semidecidable
15:12:09 <EvanR> i.e. if its really x < y, an algorithm can terminate with True, otherwise it may not, (and if it does return False)
15:12:20 <roboguy`> aren't these rationals though?
15:12:29 <EvanR> z is not a rational in lyxia's paste
15:12:36 <EvanR> not necessarily
15:12:47 <roboguy`> ah, I see
15:13:05 <lyxia> EvanR: do your test functions always terminate
15:13:08 <EvanR> yes
15:13:12 <roboguy`> looks like a Dedekind section
15:15:13 <EvanR> im thinking two test functions is too naive an implementation unfortunately
15:15:45 <EvanR> heres a more extensive attempt with dedekind cuts http://math.andrej.com/wp-content/uploads/2008/08/abstract-cca2008.pdf
15:16:04 <lyxia> http://lpaste.net/350086
15:16:28 <lyxia> that should be an executable definition
15:17:09 <EvanR> it doesnt type check
15:18:02 <EvanR> lowerZ q needs to be true if there exists lowerX i, lowerY j such that q = i + j and false otherwise
15:18:24 <EvanR> so the naive algorithm needs to search Q x Q
15:18:41 <EvanR> but if there dont exist i j like that, youll never find anything
15:22:54 <lyxia> But they always exist
15:23:13 <EvanR> no they dont
15:23:44 <EvanR> you may be forgetting the other half of this, the upper functions
15:24:28 <EvanR> for example 1+2 = 3, if i pass 3.1 into lowerZ, theres no lowerX i lowerY j which will add up to 3.1
15:24:42 <EvanR> so it needs to be false
15:24:47 <lyxia> oh right I misread
15:25:48 <EvanR> the highest lowerX and lowerY's can go is 3
15:27:08 <lyxia> I meant that you can always find some i and j such that q = i+j, and such that lowerX i and lowerY j are equal.
15:28:04 <lyxia> So if you pass 3.1, you can get i = 1.05 and j = 2.05 for instance.
15:29:18 <EvanR> theyre both false, so doubly not satisfying the criteria heh
15:30:04 <EvanR> i was abbreviating "lower i lower j" as lower i = True and lower j = True
15:30:22 <EvanR> C style
15:30:56 <lyxia> both false but equal
15:32:12 <lyxia> \lowerX lowerY q -> head [lowerX a | a <- rationals, lowerX a == lowerY (a - q)]  -- for some enumeration of rational numbers
15:32:14 <EvanR> you mean i = j ?
15:32:39 <lyxia> lowerX i == lowerY j
15:33:00 <EvanR> well either being False makes them not count
15:33:11 <EvanR> and i misread your search of rationals
15:34:04 <lyxia> Both being false means that x <= i and y <= j, which implies that x+y <= i+j.
15:34:09 <EvanR> yeah its not hard to choose i and j such that lower i = lower j
15:34:26 <Profpatsch> ansi-wl-pprint cannot vertically horizontal newline Doc’s so they start on the same line it seems?
15:34:36 <lyxia> Sorry for messing up earlier and making things more confusing though.
15:35:10 <Profpatsch> So if I have x = "ab\nbc" and y "de\nef", x <+> y should give me
15:35:14 <Profpatsch> ab de
15:35:17 <Profpatsch> bc ef
15:35:42 <Profpatsch> But instead the first line of the right one starts on the second line of the first one.
15:36:06 <EvanR> lyxia: are you claiming that that is a working lowerZ ?
15:37:20 <lyxia> damn, should be lowerY (q-a)
15:41:06 <lyxia> EvanR: (but at least it typechecked this time.) Yes I am claiming that's the function to get lowerZ corresponding to the sum of x and y.
15:42:12 <lyxia> Profpatsch: right <+> is just a fancy ++.
15:42:52 <lyxia> it's "horizontal" if your documents are one-liners.
15:43:38 <maladiec> http://pastebin.com/f4SxdRPm I would like to ask, what i am actually doing wrong with this one?
15:44:58 <shapr> Is there a lazy sort that works on infinite lists?
15:45:16 <lyxia> id on infinite sorted lists
15:45:36 <Rembane> shapr: How would you sort an infinite list?
15:46:10 <shapr> Rembane: lazily, so I could take generated elements?
15:46:45 <geekosaur> the problem is it doesn't know the smallest element until it has traversed the whole list
15:46:47 <mettekou_> shapr: How would you know if the element was the smallest if there are infinitely many elements (unless the type is well-ordered)?
15:46:49 <shapr> group is lazy, so I was hoping to use that after doing a lazy sort.
15:47:02 <shapr> mettekou_: I just want the amount of the list I've requested to be sorted
15:47:16 <glguy> maladiec: You don't appear to have included the code related to the error message
15:47:35 <roboguy`> shapr: if you have a list with 2 in it, how do you know that there isn't a 1 somewhere?
15:47:38 <geekosaur> maladiec, you needed to say (*) instead of *
15:47:45 <roboguy`> or, I should say, a list with all >1
15:48:15 <geekosaur> maladiec, `eval Op * [...]` means to multiply (eval Op) by the list
15:48:21 <glguy> maladiec: Once you wrap * and + in parentheses, they'll still have the wrong  types, however
15:48:30 <roboguy`> shapr: so I'm not sure how it could ever know what the first element of the result should be...
15:48:32 <geekosaur> if you want to refer to anoperator by name instead of applying it, wrap it in parentheses
15:48:40 <ij> I want to save last n messages, drop the rest. Which data structure should I use?
15:48:42 <glguy> maladiec: YOu can use sum and product
15:48:51 <shapr> roboguy`: you could know what the first element of N elements should be
15:49:05 <roboguy`> shapr: that's a finite list though
15:49:06 <lyxia> ij: a queue
15:49:21 <shapr> An infinite list is just a really large number of finite lists :-)
15:50:29 <shapr> hm, I know a fully lazy sort would do what I want, but oh well
15:50:38 <roboguy`> shapr: but if you have the list [2..], how does it ever know that a 1 doesn't occur?
15:50:57 <shapr> it doesn't matter, it's just about sorting the elements that exist.
15:51:34 <hpc> shapr: can you compute if 1 occurs in [2..]?
15:51:50 <roboguy`> shapr: which elements of [2..] don't exist?
15:51:51 <roboguy`> =)
15:51:56 <shapr> hpc: no, but I can return an ordered list of the amount of [2..] that I've requested.
15:52:11 <shapr> roboguy`: any elements I haven't requested yet!
15:52:21 <EvanR> shapr: lazy group+sort sounds like it might work
15:52:25 <EvanR> but not sort
15:52:29 <roboguy`> shapr: but if you request the first element, you must know which one is the lowest number
15:52:40 <roboguy`> and how can you know that without searching the entire list?
15:52:40 <shapr> EvanR: I'm not able to get it to work, what does it need to look like?
15:52:48 <shapr> EvanR: that's exactly what I'm trying to do
15:53:01 <hpc> shapr: is lazySort [2..] different from lazySort ([2..] ++ [1])?
15:53:17 <EvanR> shapr: do you have an alphabet of all possible things that could appear in the list
15:53:26 <hpc> what's the type of lazySort? what's its first element?
15:53:26 <shapr> hpc: no, because you don't get to the end of either list
15:53:27 <EvanR> if so, map filter equals
15:53:48 <shapr> Yes, what can appear in the list is finite.
15:53:57 <ij> lyxia, Is there a package that implements queues?
15:54:04 <EvanR> so construct a Data.Map mapping those keys to lazy lists
15:54:07 <EvanR> each lazy list is a filter
15:54:37 <Tuplanolla> How would your lazy sort work with an infinite list of lazily generated random numbers between 1 and 8, shapr?
15:55:07 <roboguy`> I don't think I will be convinced unless I see an actual implementation of such a sort. It seems completely impossible to me at the moment
15:55:32 <shapr> Tuplanolla: for something like "take 2 (group . sort) infinitelist" I'd expect to see two unique values
15:55:38 <roboguy`> unless *maybe* you do something weird and unsafe with the underlying pointers
15:55:39 <lyxia> ij: I thought about that exact problem a while ago and the best solution I found is a variation of the amortized queue using two lists.
15:55:54 <shapr> I just want sufficient elements from the infinite list that I can get two unique elements in that case.
15:56:16 <EvanR> lyxia: i now see that your algorithm is technically right! and horribly inefficient, but now i think i see a way to speed it up
15:56:44 <lyxia> ij: Data.Sequence from containers (though it has some overhead because it does more stuff)
15:56:54 <Tuplanolla> Can you answer my question, shapr?
15:57:54 <ij> lyxia, Now and while googling about lists/sequences/arrays/vectors I 
15:58:02 <shapr> Tuplanolla: sure, for my use case where I want to group the results, I want the list to continue generating until I get however many unique numbers I've requested.
15:58:04 <roboguy`> the resulting list cannot change because you request a different number of elements. How would you be able to decide what the first element is, taking that into account?
15:58:12 <ij> lyxia, oops… …kept seeing "amortized" — what's that?
15:58:30 <lyxia> ij: Ah, it exists as the package deque on hackage
15:58:36 <shapr> roboguy`: how about asking for unique elements? does that help think about this problem?
15:58:40 <hpc> shapr: what's the type of your sort function?
15:59:07 <EvanR> roboguy`: since its being grouped, everything in each group is equal ;)
15:59:15 <roboguy`> shapr: probably, since I'm almost 100% sure an infinite sort like you're suggesting is impossible. So you just want 'n' unique elements from an infinite list, for some finite n?
15:59:28 <shapr> roboguy`: yes, that's right
15:59:37 <geekosaur> ij, amortized = spread over multiple operations. one individual operation may prove to be expensive, but the next use of it is extra-cheap: the amortized cost is an average of these
15:59:44 <roboguy`> shapr: you could just go through the list and keep track of what values you've seen so far
15:59:47 <roboguy`> in a function
15:59:52 <EvanR> shapr: youve so far asked for solutions to 3 different problems!
16:00:05 <shapr> If it helps any, I want to use this fully lazy sort to solve part 2 of day 5 of advent of code.
16:00:06 <roboguy`> EvanR: I'm not sure I see how that lets you sort an infinite list though...
16:00:07 * EvanR waits for the real problem
16:00:13 <ij> geekosaur, Ooh, I see.
16:00:14 <shapr> EvanR: I guess I'm not communicating clearly :-(
16:00:19 <geekosaur> so for trees, you may have fast operations unless the tree needs to be rebalanced which could cause one operation to become more expensive, but it happens relatively rarely
16:00:21 <EvanR> roboguy`: it doesnt, that was the first approximation to the actual problem
16:00:21 <lyxia> ij: I mean, a pure queue.
16:00:26 <roboguy`> eacameron: ahhh, I see
16:00:30 <roboguy`> EvanR: ^
16:00:34 <geekosaur> so we speak of amortized costs
16:00:47 <hpc> ij: the classic example of amortized cost is in array expanding
16:01:02 <hpc> ij: initialize an array of length n, then when you fill it with n elements expand it to 2n
16:01:05 <hpc> ij: and repeat
16:01:21 <roboguy`> shapr: what about just take n . nub?
16:01:21 <hpc> ij: every n elements you perform an operation that costs n time
16:01:38 <roboguy`> maybe not the most efficient, but I think it should work
16:01:38 <hpc> which amortizes to constant time appending to that particular interface around an array
16:01:44 <geekosaur> (and the rebalance causes the following operations to be much faster, until the tree gradually unbalances and becomes slower, then we rebalance and it gets fast again)
16:02:31 <shapr> roboguy`: that sounds good, thanks.
16:02:49 <tom7942> can someone explain this little diddy? http://lpaste.net/350091
16:03:04 <shapr> I still think there could be (is?) a fully lazy sort as I described, but I'll just go back to coding :-)
16:03:06 <tom7942> circular definition is confusing me
16:03:10 <roboguy`> shapr: it is probably worth keeping in mind that the Prelude implementation of nub is O(n^2) when it could be O(nlogn) (I think)
16:03:16 <roboguy`> if it had an Ord constraint
16:03:35 <shapr> Is the better nub floating around somewhere?
16:03:43 <roboguy`> shapr: if you find it, you'll have to let me know =). I haven't been this certain of a function not existing in a while!
16:03:44 * ij has absorbed the new lingo.
16:03:54 <roboguy`> probably. Let's see...
16:04:37 <roboguy`> shapr: actually, I think it's faster to use (Set.toList . Set.fromList) as nub, since you have an Ord instance
16:04:46 <shapr> roboguy`: I'm almost certain this fully lazy sort is doable. It's just about sorting the elements that have been lazily pulled through the sort function.
16:05:09 <roboguy`> shapr: but there is no way the sort function can know how many elements you need, unless you pass that as an argument
16:05:16 <c_wraith> roboguy`: that isn't stable
16:05:29 <Tuplanolla> Oh, so you want to pull items from the list and sort them until you reach a certain length, shapr.
16:05:31 <roboguy`> shapr: I mean, what would the "head (sort ([2..] ++ [1]))" give you?
16:05:33 <c_wraith> roboguy`: a fold passing a Set along is better
16:05:43 <EvanR> im not sure if shapr wants to sort anything
16:05:52 <shapr> haha, I'll stop distracting people from learning now :-)
16:06:16 <shapr> Tuplanolla: yes, that's correct
16:06:35 <glguy> roboguy`: What type? for types like Int and Word8 that would work out
16:06:35 <c_wraith> isn't that basically an insertion sort that stops early?
16:06:57 <shapr> Tuplanolla: and wrapping the group around that means I want to ask for N unique items
16:07:31 <Tuplanolla> That's something like `notSort :: Ord a => Int -> [a] -> [a]` then, shapr.
16:07:34 <roboguy`> glguy: well, it turns out that this was a bit of an XY-problem, but shapr was originally asking for a general sort on infinite lists
16:07:53 <shapr> no no, I was asking for a *fully lazy* sort!
16:08:01 <shapr> I must not have been clear at all.
16:08:13 <Tuplanolla> It's not a sort at all, shapr.
16:08:24 <EvanR> shapr: you might mean a group
16:08:28 <c_wraith> a fully lazy sort generating a list is more of a selection sort.
16:08:46 <shapr> EvanR: yeah, I think you're right.
16:08:57 <EvanR> sort means different things outside programming
16:09:10 * geekosaur thinks this is the common definition of sort, rather than the CS one
16:09:14 <EvanR> like sometimes sort means filter
16:09:22 <EvanR> sometimes group
16:09:29 <roboguy`> that is true
16:09:40 <EvanR> sort = filter is really annoying ;)
16:10:15 <shapr> Ok, I retract my statement. What I want already exists. *sigh*
16:10:19 <geekosaur> yet it's established jargon in some industries. one gets used to ir
16:10:21 <geekosaur> *it
16:11:14 <c_wraith> many industries use filter = transform
16:11:33 <EvanR> o_O
16:11:43 <c_wraith> audio filter, video filter, etc
16:12:35 <shapr> I will learn to communicate better at some point :-P
16:15:23 <tom7942> so how do some and many evaluate? the circular reference between many_v and some_v is confusing
16:16:36 <lyxia> tom7942: some does not depend on many actually
16:17:28 <lyxia> oh nvm you wrote many_v and some_v
16:18:12 <tom7942> right, like here: http://lpaste.net/350091
16:28:02 <lyxia> I can't find a good explanation of how that works
16:29:28 <tom7942> yeah, all my material kinda glosses over that
16:30:03 <c_wraith> The most important logic for functions isn't in those functions - it's in the applicative and alternative instances.
16:32:03 <tom7942> i think i understand the applicative, functor and alternative 
16:32:31 <c_wraith> the thing is, there are a lot of instance of Alternative where some and many are useless
16:32:35 <c_wraith> like [] and Maybe
16:33:07 <tom7942> hmm. i haven't really explored those instances. maybe i'm getting ahead of myself.
16:33:18 <c_wraith> > some [0]
16:33:24 <lambdabot>  mueval-core: Time limit exceeded
16:33:31 <c_wraith> They're just infinite loops
16:35:02 <nshepperd> i've only really encountered some and many being useful for parsers
16:35:10 <tom7942> ah, i see. the instances i'm interested are for nanoparsec
16:35:22 <tom7942> http://dev.stephendiehl.com/fun/002_parsers.html
16:37:32 <c_wraith> yeah, I don't think some and many do much interesting for types that aren't like parsers. 
16:40:03 <roboguy`> hmm, yeah I've only seen useful parser implementations too... It seems like maybe you could have one for something like a state machine or something that processes or transforms streams? That might count as "like a parser" though
16:40:33 <EvanR> class LikeAParser where...
16:40:40 <EvanR> very theoretical
16:40:44 <nshepperd> you could use it for IO, to repeat an action until an exception
16:41:08 <roboguy`> nshepperd: I suppose... but you could also use 'forever'
16:41:20 <nshepperd> hGetContents h = many (hGetChar h)
16:41:48 <nshepperd> (except a crappy hGetContents that throws away all exceptions, not just EOF)
16:42:47 <roboguy`> huh, yeah I guess that is productive
16:43:53 <EvanR> "Floating point representations also have limited precision, so at some point the midpoint of [a, b] will be either a or b." pondering this statement
16:44:48 <tom7942> intuition tells me that evaluating the <|> first in the case of many allows the parser to fail by returning "unit []" 
16:45:01 <EvanR> is (a+b)/2 well behaved at that point
16:45:04 <tom7942> rather than just the empty list
16:45:38 <nshepperd> tom7942: so anyway I suppose for a parser you could imagine <|>, <*> and <$> to be data constructors and sort of trace the evaluation of a parser on some string
16:48:01 <nshepperd> parse (some (char 'v')) "vv"   →   parse ((:) <$> char 'v' <*> many_v) "vv"   →   'v' : parse many_v "v"
16:49:43 <nshepperd> then the parser attempts to take the left branch of <|> and ends up at some_v again, and goes around that loop until it gets to...
16:50:47 <nshepperd> parse ((:) <$> char 'v' <*> many_v) ""  which fails at the char 'v' so it stops recursing
16:54:30 <nshepperd> then because that failed you go back and try the right branch of some_v <|> pure [], which ends the parsing
17:17:44 <monochrom> > runExcept (evalStateT (many (do { x <- get; if x==0 then throwError () else put (x-1); return x })) 5)
17:17:46 <lambdabot>  Right [5,4,3,2,1]
17:18:07 <monochrom> elementary example of a non-degenerate many
17:28:57 <monochrom> In general, in order for "many an_action" to be non-degenerate, you want an_action to succeed the first few times, then fails. Then many an_action will put the success values in a list.
17:31:20 <monochrom> The reason "many (Just 'x')" bottoms is that "Just 'x'" succeeds too many times. But before you say "so I should get an infinite list?", <*> for Maybe is pretty strict so you get bottom rather than an infinite list. (You need a lot of non-strictness to get an infinite list.)
17:48:40 <xenon-> hi. is it possible to get all the field names of a data type? as a last resort i would parse "show x" string, but hopefully there is a better way
17:49:27 <geekosaur> see Data.Data module (must derive Data)
17:49:34 <Tuplanolla> Generics and Template Haskell both provide mechanisms for that, xenon-.
17:58:35 <dramforever> I'm not very sure if this is on-topic here, but: Question: What problem does the CPS transformation solve?
18:00:16 <xenon-> cool, it worked! 
18:00:23 <xenon-> constrFields $ toConstr x
18:00:52 <dramforever> I read the 'Representing control [...]' paper, but it starts with 'The usual presentation of the continuation-passing style (CPS) transformation [...]'
18:01:28 <dramforever> And the references of it makes no sense to me. I'm confused
18:01:34 <dramforever> *make
18:01:42 <ertes> dramforever: the CPS transformation can sometimes provide efficiency benefits, sometimes even asymptotic
18:02:16 <dramforever> Uh, looks like we are talking about different things?
18:03:21 <ertes> dramforever: if we're talking about continuation-passing style, then we're talking about the same thing
18:03:49 <dramforever> yeah maybe
18:04:02 * dramforever is more confused
18:04:30 <ertes> dramforever: context would be useful…  why are you asking?  do you have a specific application in mind?
18:05:01 <dramforever> Something related to compiling functional languages?
18:05:13 <dramforever> ertes: ^
18:06:02 <iphy> how come simple haskell programs are easily several megabytes of code?
18:06:25 <iphy> when equivalent ocaml programs are in the hundreds of kilobytes of code
18:06:29 <Rotaerk> you mean the executables?
18:07:04 <ertes> iphy: probably because you linked statically…  note that you can decide separately whether you want to link *haskell* libraries statically or dynamically
18:07:11 <iphy> ertes: same for the ocaml program
18:07:28 <iphy> statically linked, with derived "show" for every type
18:07:56 <iphy> ertes: a simple record type with 4 fields in haskell takes 15KB with derived Eq, Show, and Read instances
18:08:20 <ertes> iphy: try without Read
18:08:58 <iphy> yeah, now it's 7KB
18:10:39 <geekosaur> hm. records are actually boilerplate enough that a lot of that could be distilled into a function
18:11:10 <ertes> iphy: even Show might be fairly complicated for a record type, but i'm not entirely sure
18:11:31 <iphy> https://www.irccloud.com/pastebin/mPj9neaq/ <- Show
18:11:47 <iphy> looks straightforward
18:12:07 * ertes can't read that
18:12:59 <iphy> ok, so the reason I'm wondering about this is that I'd like to run a haskell program on android
18:13:10 <roboguy`> iphy: is that before optimizations? Because I would expect those .s to be inlined...
18:13:21 <iphy> roboguy`: let me try with opts
18:13:23 <geekosaur> great, leaning toothpick syndrome *and* parenthebard
18:13:29 <geekosaur> *parenthebarf
18:13:52 <iphy> yeah, a bit smaller now
18:14:01 <iphy> 6KB instead of 7
18:14:20 <iphy> well, 6.6 instead of 7.4
18:14:47 <ertes> you can probably make the inliner and specialiser less aggressive, but then you're getting into trade-off territory
18:15:28 <ertes> however, *more* aggressive specialising could even be beneficial…  for example when you use only a single instance of a class
18:15:30 <roboguy`> you could use HERMIT to create more specific optimizations that might be able to optimize for size
18:15:40 <iphy> at a high level what I want is: a JVM (java/scala/whatever) client app that spawns a haskell agent and communicates with it via IPC
18:15:56 <byorgey> dramforever: CPS can solve many different problems: (1) it allows you to control the order of evaluation, even when the language being compiled has a different evaluation order than the implementation language (2) it can have performance benefits (3) it can be an important step along the way of transforming functional code into imperative machine code
18:15:57 <iphy> I have all the compilation stuff set up
18:16:06 <iphy> android cross compilers for 8.0.1 are working
18:16:19 <iphy> but now I'm having the problem of absolutely massive programs coming out of it
18:16:20 <geekosaur> mm, that's actually a good point, might be able to abstrat into a function but it might just get inlined.
18:16:23 <iphy> they are easily 27MB
18:16:32 <geekosaur> and, well, it inlines stuff for a reason
18:16:44 <dramforever> byorgey: Hmm
18:16:51 <byorgey> dramforever: but I should also say that continuations are one of those really deep ideas that show up all over the place, and it's completely normal to be confused =)
18:16:59 <dramforever> I guess I have a more specific question in mind
18:17:10 <geekosaur> (performance sucks really badly without it)
18:17:19 <nshepperd> \\
18:17:22 <iphy> all the "how to use haskell for embedded systems" docs I've seen are basically saying "use a free monad and compile the code to C"
18:17:44 <iphy> or some variant of that
18:17:47 <ertes> iphy: those are for devices with far less space than a modern phone
18:17:48 <geekosaur> that's less about memory footprint and more about "most embedded systems don't do well with garbage collection"
18:17:49 <dramforever> What's the 'form' of a CPS transformed program?
18:17:54 <iphy> ertes: right
18:17:59 <geekosaur> tiny memory and fast response
18:18:08 <dramforever> What special properties does it have?
18:18:10 <iphy> it's not that much about memory
18:18:26 <dramforever> Is there a, say, CPS Normal Form?
18:18:29 <iphy> it's more about asking users to download a 30MB package for a simple irc client
18:18:50 <ertes> iphy: in any case you will have to experiment with flags, but you need to do it not only for your own code, but also for all the libraries you're using
18:18:50 <byorgey> dramforever: in a CPS transformed program, all recursive calls are tail calls.  Every function has an extra argument which the continuation function, and instead of returning a result, each function just passes its result to the continuation function
18:18:52 * geekosaur regularly sees things much larger than that coming in Play Store updates...
18:18:54 <ertes> iphy: most notably base
18:19:10 <iphy> ertes: I'm thinking of using the one-object-per-function flag
18:19:16 <iphy> and compiling base with that
18:19:21 <iphy> and everything else
18:19:26 <ertes> iphy: alternatively: don't bother…  space isn't really that much of a concern on phones anymore
18:19:30 <byorgey> dramforever: do you know what "continuation-passing style" means?
18:19:32 <geekosaur> that should be the default for base I think? and core libraries
18:19:40 <iphy> space isn't, download size is
18:19:59 <ertes> iphy: check the compressed size in that ase
18:20:00 <ertes> case
18:20:02 <nshepperd>  
18:20:04 <nshepperd> >>:P\
18:20:06 <nshepperd> -=\
18:20:12 <geekosaur> meow
18:20:22 <iphy> ertes: anyway, I'm going to proceed with the development for now
18:20:22 <dramforever> byorgey: yeah I do
18:20:23 <athan> byorgey: Is that similar to supercombinators?
18:20:26 * nshepperd pushes the cat off the couch
18:20:35 <iphy> and I'll figure out how to solve my size problem later, if it actually becomes a problem
18:20:35 <byorgey> athan: I... don't think so?
18:20:40 <iphy> for now, I was just wondering
18:20:52 <byorgey> athan: I confess I don't know too much about supercombinators
18:20:58 <iphy> because my ocaml programs are tiny in terms of compiled size, compared to haskell
18:21:05 <athan> oop, okay.
18:21:17 <iphy> so I was wondering what makes haskell programs so massive
18:21:36 <geekosaur> iphy, find something else based on graph reduction instead of linear execution and compare those sizes
18:22:18 <iphy> the entire ocaml native compiler is 3.1MB code size
18:22:36 <iphy> (binary)
18:22:44 <jmnoz> do people generally use Safe (atMay) instead of (!!) ? (i think that's the one)
18:22:49 <byorgey> dramforever: so some properties enjoyed by CPS-transformed programs include: (1) every recursive call is a tail call (2) the result of the program is independent of the evaluation order (i.e. strict vs lazy) of the language
18:22:56 <athan> iphy: ocaml is strict though, correct?
18:23:02 <ertes> iphy: i think part of it is due to the design of the base library…  just compare the amount of abstractions we use to other languages…  another part may be String, which is both heavily used and cannot be reduced to simple array loops…  most other languages don't have this problem
18:23:06 <byorgey> dramforever: does that answer your question?
18:23:25 <iphy> athan: yes
18:23:52 <dramforever> byorgey: Yeah, I think now the paper makes more sense
18:23:53 <dramforever> Thank you
18:23:58 <dramforever> ertes: Thank you too
18:24:20 <dramforever> literally continuation everywhere
18:24:39 <roboguy`> jmnoz: generally neither are used if you can help it
18:25:10 <jmnoz> roboguy`: I see
18:25:59 <ertes> iphy: 'strip' can reduce your code size further
18:26:00 <roboguy`> jmnoz: both traverse the list to get the element, and usually you either use things like map, filter, etc or you make your own traversal
18:26:05 <iphy> ertes: how?
18:26:20 <jmnoz> roboguy`: safeHead is better?
18:26:31 <roboguy`> jmnoz: pattern matching is generally better
18:26:41 <jmnoz> roboguy`: thanks
18:27:00 <ertes> iphy: strip -s mybinary
18:28:05 <iphy> I don't think that does anything to the code size
18:28:16 <ertes> iphy: have you tried it?
18:28:21 <iphy> when I talked about code size, I meant the TEXT segment
18:28:24 <ertes> ah
18:28:25 <iphy> which is not affected by strip
18:28:34 <ertes> ELF size
18:28:50 <iphy> that's ignoring all the stuff around it
18:29:03 <iphy> like data (which isn't much in haskell) and ELF headers, debug symbols, etc.
18:29:47 <ertes> (data not being much in haskell is part of the problem) =)
18:30:11 <iphy> how so?
18:30:16 <dramforever> How much data in ocaml?
18:30:40 <ertes> i wouldn't be surprised if adding a (putStrLn "blah") didn't affect the data size at all
18:31:41 <iphy> dramforever: some number of kilobytes, I don't know
18:31:43 <iphy> more than 0 :)
18:32:29 <iphy> I don't really have a fair comparison, because I don't have two versions of the same non-trivial program
18:32:53 <dramforever> :(
18:33:00 <iphy> I have one haskell program that does network and http, which is 21MB code and 2MB bss
18:33:28 <iphy> and one ocaml program that has a parser and about 20 transformation phases and a code generator
18:33:58 <iphy> which is 560KB text, 283KB data, and  54KB bss
18:35:32 <iphy> maybe a fairer comparison is a C parser
18:35:45 <geekosaur> who was asking about TH in cross compiler earlier? https://github.com/ghc/ghc/commit/52ba9470a7e85d025dc84a6789aa809cdd68b566 apparently just landed which is another step forward there
18:36:16 <iphy> in haskell: 4.3MB text, 407KB data, 49KB bss
18:36:23 <iphy> that's a lot more reasonable
18:37:02 <iphy> still kind of large, compared to the ocaml native compiler that's 3MB code size
18:39:31 <iphy> I have one fairly ridiculous program in haskell :) 97MB text, 11MB bss
18:39:43 <iphy> it's called semdoc, and links to pandoc and ghc
18:39:52 * geekosaur thinks that sunds a bit small tbh. sure it's not a driver?
18:40:09 <iphy> which one?
18:40:09 <geekosaur> (compare /usr/bin/gcc which is a driver; the actual compiler is under /usr/lib/gcc)
18:40:16 <geekosaur> that 3MB ocaml compiler
18:40:18 <iphy> ah
18:40:22 <iphy> no, it's the whole thing
18:40:34 <iphy> let me check to make sure
18:40:35 <ertes> what about GHC?  i can't check here, because mine is dynamically linked
18:41:01 <pavonia> GHC's motto for binaries: size doesn't matter
18:41:02 <ertes> it's only 2.2 MiB
18:41:38 <ertes> (again: ELF size…  i'm not looking deeper)
18:41:48 <dramforever> I wonder, what does 'ldd ocamlc' say?
18:41:56 * dramforever is trying to make it fair
18:42:04 <iphy> 2.8MB, the whole ocaml native compiler
18:42:47 <dramforever> wow
18:43:07 <iphy> https://www.irccloud.com/pastebin/2SIv7sC5/
18:43:43 <dramforever> you sure it doesn't call ocamlc or something?
18:43:47 <iphy> my ghc is also dynamically linked, so no idea
18:43:54 <iphy> dramforever: ocamlc is 2.8MB as well, and is the byte code compiler
18:43:59 <geekosaur> ocamlc is the bytecode compiler
18:44:29 <iphy> I guess they are basically the same code, just calling an internal function with a different argument
18:44:53 <geekosaur> that would again suggest driver though
18:45:17 <dramforever> ocamlc (--version says 4.03.0) is statically linked here (ldd says 'not a dynamic executable'), and is 11M
18:45:17 <iphy> it would, but it's not
18:45:44 <iphy> ok, then it includes libc and libm
18:45:55 <iphy> mine is dynamically linked against libc and libm
18:46:32 <iphy> and libdl
18:46:44 <dramforever> ok, ocamlc.opt is dynamically linked against libc and libm and libdl and is 6.5M
18:46:58 <iphy> code size?
18:47:05 <dramforever> Oh code size
18:47:12 <iphy> -rwxr-xr-x 1 root root 4.3M Aug 12  2015 /usr/bin/ocamlopt.opt*
18:47:16 <dramforever> no it's elf size :facepalm:
18:47:17 <iphy> that's file size
18:47:26 * dramforever leaves this and continues pretending 'size doesn't matter'
18:47:27 <dramforever> :(
18:47:45 <iphy> 2.8M code, 1.48M data,   54kb bss
18:47:55 <dramforever> :(
18:48:19 <iphy> but I expect ghc to be larger than ocamlc, given complexity
18:49:05 <iphy> but then a C parser in haskell is larger than the whole ocaml compiler, which is not really in proportion
18:49:49 <iphy> maybe I can roll out updates as binary diffs :)
18:50:23 <iphy> or actually dynamically link my android binaries and just roll out updates to the main binary that should be quite small
18:52:23 <ertes> iphy: pandoc (static against haskell) is 36 MiB of ELF here, but zip-compressed it's only 7.2 MiB
18:52:36 <ertes> i think APKs are just ZIP files
18:52:43 <iphy> good point, yes they are
18:52:57 <ertes> that's why i said earlier: compare the compressed size
18:53:32 <geekosaur> hm, the interpreter depends on ocaml-compiler-libs which is a decent chunk of stuff (looking at ubuntu)
18:54:28 <iphy> 2.1M gzipped for my test program that I want to run on android
18:54:33 <iphy> that's not too bad
18:54:46 <iphy> 9.5M unzipped
18:55:06 <dramforever> (Things are going better I suppose)
18:55:16 <iphy> dramforever: I think I'll be fine
18:55:25 <dramforever> :)
18:58:25 <ertes> iphy: even just 4.5 MiB with xz -9
18:59:56 <ertes> you could perhaps put an XZ file there and have the java part extract it before running it
19:02:45 <iphy> yeah, that makes sense
19:10:57 <maladiec> Simple and fast learning question. There is written date types and types, and on the 5th line code i'm trying to excecute. The main idea, that i would actually want to know why that variable isnt correct? Is there is any possibility to make a "testing variable" like that?  It is fully for testing purposes, just trying to make my uni exercise :/
19:13:15 <roboguy`> maladiec: testing variable?
19:13:18 <maladiec> http://pastebin.com/FCeYzkpp
19:13:23 <maladiec> Sorry Forgot to link it
19:15:03 <roboguy`> maladiec: it isn't working?
19:15:22 <roboguy`> oh, I see
19:16:40 <roboguy`> maladiec: The problem is (*). The type is wrong
19:16:44 <roboguy`> You need a function there that takes a list
19:17:50 <maladiec> Thank you, will try to work around that and find actually out whats the problem!
19:20:53 <dramforever> maladiec: Do you have an error message?
19:22:05 <geekosaur> maladiec, that syntax does not work at the top level of a file
19:22:08 <geekosaur> leave off the "let"
19:22:14 <geekosaur> you use it in ghci, or in a do block
19:22:34 <geekosaur> (and starting in ghc 8.0 you don't need it in ghci either)
19:23:02 <dramforever> So, error message?
19:23:08 <maladiec> http://pastebin.com/HQ7deqMG Thats the error
19:23:24 <codygman> Is there a way to tell what MonadReader instance Control.Lens.view is defaulting to in ghci for a given expression?
19:24:08 <dramforever> maladiec: You don't understand what it means, right?
19:24:11 <geekosaur> maladiec, if this is related to earlier, weren't you told (*) had the wrong type?
19:25:39 <maladiec> dramforever, yes, i actually do not know what that means.
19:25:59 <dramforever> error message line 3 and 4: An 'Ops a0' is needed, but '[a0] -> [a0] -> [a0]' is given, which made GHC confused
19:27:08 <dramforever> (Ops a0) is ([a0] -> a0), and (*) has type...
19:27:10 <dramforever> :t (*)
19:27:11 <lambdabot> Num a => a -> a -> a
19:27:58 <maladiec> geekosaur, the main idea, that the overall example is given by professsor (if whole example would be): Op* [Op+ [EVar ‘x’, Lit 10], EVar ‘y’] So i am pretty confused.
19:28:24 <dramforever> Which takes two arguments, say, x and y and returns one value z. x y z all have the same type a. a must be numeric (that's what 'Num a' means)
19:28:41 <geekosaur> maladiec, but Op* is not a valid token, and * is already taken for something else (yes, also in the (*) form) which does not have the type you need
19:28:52 <dramforever> And it doesn't match ([a0] -> a0)
19:29:42 <dramforever> maladiec: Are you sure your professor is talking in Haskell?
19:30:50 <quinn95> I'm writing a simple haskell game using the state transformer with IO. I'm running into the problem of having to lift every IO statement, such as print, even though I'm not storing the value of the print statement. I understand why you have to lift getLine. Is it bad form to use print in a stateT do block? 
19:31:16 <maladiec> dramforever Yes i am pretty sure. Probably there is a mistake in the exercise or given example? (if i understood what i've been told right now)...
19:32:27 <Gurkenglas> quinn95, no. print is not MonadIO m => String -> m () for legacy reasons afaik
19:32:36 <dramforever> Using {braces} to delimit things, {Op*} {Op+} are not valid Haskell identifiers
19:32:37 <Gurkenglas> *putStrLn. You get the idea.
19:33:18 <dramforever> maladiec: Any chance that you are supposed to 'translate' them to {OpMult}, {OpPlus}, etc?
19:33:59 <Gurkenglas> Maybe we should make a list of things we could fix if we could annotate each patch of a library with a bijection of code using that library
19:34:10 <dramforever> quinn95: if you have an entire block of do { liftIO this; liftIO that } you can just do { liftIO $ do { this; that } }
19:34:19 <Gurkenglas> The PvP even fits neatly around it: The leftmost number would be used for patches that are not annotated with such a bijection
19:34:32 <geekosaur> also there's a great many packages that locally define io = liftIO
19:34:57 <maladiec> dramforever Well, the data types were given in exercise.. So probably not, but i will just change it probably, in that way everything is pretty clear :)
19:35:15 <dramforever> :)
19:35:17 <maladiec> dramforever, geekosaur thank you!
19:35:19 <dramforever> Glad you solved it
19:35:24 <dramforever> you're welcome
19:37:54 <quinn95> wait, so is it standard form to put lift infront of print and putstrln inside of StateT IO () do blocks?
19:38:13 <dramforever> quinn95: What's your code like?
19:39:37 <quinn95> game ans = do
19:39:37 <quinn95> 	guesses <- get
19:39:37 <quinn95> 	lift (print guesses)
19:39:52 <dramforever> If you're, say, doing liftIO (print blalah), just define printL = liftIO . print and nobody will blame you (okay, at least I won't blame you)
19:40:10 <geekosaur> "get" might already be that kind of thing for reading...
19:40:26 <geekosaur> although no, probably not, this is StateT?
19:40:34 <geekosaur> be a particularly bad choice >.>
19:40:40 <quinn95> game :: String -> StateT GameState IO ()
19:40:41 <quinn95> game ans = do
19:40:41 <quinn95> 	guesses <- get
19:40:41 <quinn95> 	lift (print guesses)
19:40:53 <geekosaur> ok.
19:41:05 <dramforever> :t liftIO
19:41:06 <geekosaur> if you are doing that a lot, just create a convenience function like dramforever saud
19:41:06 <lambdabot> MonadIO m => IO a -> m a
19:41:09 <geekosaur> *said
19:41:53 <quinn95> I'm just confused why I have to do that. It's because print returns an IO (), which isn't StateT GameState IO (), right?
19:42:32 <geekosaur> correct
19:43:15 <quinn95> Ok cool. Is it bad form to have a monad do literally everything my program is supposed to do? I can practically build an imperitive program inside of a stateful IO monad
19:43:21 <geekosaur> and, Haskell does not do inheritance or automatically "fudging" types. if it's IO () then it matches IO () or IO a (or a, but that's not very useful) but not something else
19:44:13 <geekosaur> best form is usuually to use pure code wherever you can... but generally for a state monad you're using it for a reason and abstracting it away gives you back the problem you were solving with the monad
19:44:38 <quinn95> Ok. I guess I'll just keep tinkering and see how it goes. Thanks!
19:53:26 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/46
19:57:01 <geekosaur> I think generalization of things like `print` has been discussed before. and while it was turned down by the libraries committee, there are some alternative Preludes that incorporate it
20:11:35 <Maxdamantus> Saying it matchis `IO a` is even a bit weird since `IO a` isn't actually a type.
20:11:55 <glguy> sure it is
20:12:12 <Maxdamantus> if you enable something like rank 2 types, you have types like  `forall a. IO a`.
20:12:17 <Maxdamantus> but that's not really Haskell.
20:12:53 <Maxdamantus> afk anyway.
20:13:12 <EvanR> no true haskell
20:13:32 <EvanR> :k IO a
20:13:34 <lambdabot> error: Not in scope: type variable ‘a’
20:13:49 <bollu> has ministg bitrotted?
20:14:09 <bollu> I've been looking for an accessible STG implementation (since to me, the paper isn't super clear with the operational semantics)
20:14:15 <bollu> I know STGi exists as well
20:14:22 <bollu> but, well, the more the merrier :)
20:15:14 <bollu> what I don't understand is, in a lambda form in the STG ((vs \pi xs) ws), what the "vs" and "xs" are. (from a machine point of view). ws are values and pi is the "update" flag, but what exactly are 
20:15:21 <bollu> but what are "vs" and "xs"?
20:15:29 <bollu> I'm quoting terminology form the STG paper
20:15:33 <bollu> from*
20:15:37 <bollu> any help would be appreciated
20:19:12 <geekosaur> bollu, the bottom of page 19 might be of interest
20:20:19 <geekosaur> (starting there and into page 20)
20:26:26 <geekosaur> well, make that page 21 with a related big table on page 20
20:32:55 <stepcut> If I am building GHC, do I have to do anything special to enable LLVM? Or it will happen automatically if ./configure finds llvm?
20:34:22 <glguy> automatic if it finds it and you can help it if it didn't find it automatically in your path
20:35:46 <stepcut> it says, Using LLVM tools,  llc   : /nix/store/qqnalv8sf6p8fb7f52h86jfy16ln5h6p-llvm-3.7.1/bin/llc,  opt   : /nix/store/qqnalv8sf6p8fb7f52h86jfy16ln5h6p-llvm-3.7.1/bin/opt
20:35:52 <stepcut> so hopefully it works!
20:36:15 <stepcut> but I'm not going to bet on it
20:46:52 <isovector> is there a lens that removes the data constructor from something like `data X = X Int`?
20:47:08 <glguy> Even better, there's an Iso
20:47:14 <isovector> or do i need to make it a record?
20:47:34 <glguy> You can use makePrisms ''X to generate _X
20:47:52 <isovector> glguy: but that keeps the data constructor
20:48:24 <isovector> looking for a `Lens' X Int`
20:48:29 <glguy> One of us doesn't know what the other means, then. Could you show me what you mean?
20:48:48 <glguy> Yeah, _X gives you that
20:49:07 <isovector> really? even in the case of `data X = X Int | Y String`?
20:49:21 <glguy> No, that's different, now it's not possible to get a lens
20:50:12 <isovector> i'm using wrong words, BUT you're right! _X works. i was accidentally using `review` instead of `preview` in my tests and things got confusing
20:50:24 <isovector> thanks glguy! you're fantastically helpful always. cheers!
20:50:32 <glguy> ^_^
21:07:27 <glguy> Weeee, #1 on both parts for tonight's AoC ^_^
21:07:37 <glguy> Haskell #1
21:11:32 <isovector> haskell master race
21:14:54 <isovector> glguy: is there a built-in `(isJust .) . preview`?
21:15:23 <Gurkenglas> :t (^?!)
21:15:25 <lambdabot> s -> Getting (Endo a) s a -> a
21:15:57 <pavonia> glguy: Congrats :p
21:18:21 <glguy> isovector: has
21:18:51 <isovector> glguy: thanks again :) is it just me or is lens notoriously hard to find things in?
21:19:14 <glguy> It helps to memorize it
21:19:14 <isovector> (i guess that isn't what notorious means, but...)
21:20:07 <glguy> But yes, there's definitely a lot there. You have to know where to look for stuff
21:20:30 <Gurkenglas> Ah, misread that isJust as fromJust
21:23:33 <chetshah> Hello all, I am a haskell beginner. Wanted to know more about typeclasses.
21:23:40 <chetshah> Are there any examples of recursive definition of typeclasses ?
21:23:42 <Eduard_Munteanu> Hi.
21:25:06 <isovector> chetshah: what do you mean? are you looking for *instances* of typeclasses defined in terms of that typeclass?
21:25:25 <Eduard_Munteanu> chetshah, yes.
21:26:32 <Eduard_Munteanu> e.g. instance MonadReader r m => MonadReader r (MaybeT m) where ...
21:27:09 <isovector> chetshah: if so, http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-314 -- `Maybe a` is eg. a `Monoid` if `a` is one
21:27:15 <chetshah> I was going through this book : Haskell road to logic, math etc. 
21:28:11 <chetshah> And its defined like following : class TF p where
21:28:17 <chetshah>   valid :: p -> Bool
21:28:44 <chetshah> where TF stands for truth formula
21:29:12 <chetshah> base case is defined like following :
21:29:20 <chetshah> instance TF Bool
21:29:27 <chetshah>   where
21:29:32 <chetshah>   valid = id
21:29:52 <chetshah> and other instances can then be built upon this instance
21:30:13 <chetshah> instance TF p => TF (Bool -> p)
21:30:15 <chetshah>   where
21:30:32 <chetshah>     valid f = valid (f True) && valid (f False)
21:31:05 <chetshah> Yes So Recursion on instances is what I meant to say probably.
21:31:18 <isovector> chetshah: cool, yeah. the standard library is riddled with them
21:31:31 <isovector> chetshah: do you have any question in particular?
21:32:49 <chetshah> Are there any particular rules or other examples around this. recursive instances, When and why would we need them. Just some intuition probably if there is.
21:34:29 <geekosaur> most of the standard ones are for convenience
21:34:30 <Eduard_Munteanu> Well, the constraint (the stuff before =>) must be on a "smaller" type than the instance.
21:35:25 <isovector> if you're writing a library, a good rule of thumb is "write them if it's meaningful to". if you're making something else, write them as you need them :)
21:35:26 <chetshah> Oh cool, You mean structurally smaller ? In order to be able to structural recursion, right?
21:36:00 <Eduard_Munteanu> Yes.
21:36:10 <geekosaur> instance MonadIO m => MonadIO (SomeMonad m) where liftIO = lift . liftIO -- this "relays" a MonadIO through a stack of monads, provided the base of the stack is IO (the "base case" of MonadIO; its liftIO = id)
21:36:28 <codygman> Can someone help me figure out what MonadReader instance would satisfy GHC and work for my use case? https://github.com/acowley/Frames/issues/73#issuecomment-267801053
21:37:32 <isovector> codygman: you can enable PartialTypeSignatures, and keep the underscore, and then ask ghci :)
21:38:28 <codygman> isovector: In this instance I don't see how I could, but I've been taking advantage of that technique quite a bit :D
21:38:59 <codygman> isovector: Yeah I can't because it's a typeclass constraint
21:39:24 <isovector> really? doesn't work in constraints? :( that's a bummer
21:39:30 <codygman> I need a constraint that will make Lens.view work in this context.
21:40:00 <isovector> ahh, your'e right. super lame!
21:40:02 <codygman> Sucks because I was so close to having a structurally typed "diff" pipe using vinyl
21:40:35 <codygman> Right now I'm reading up on MonadReader to figure it out and then will try to figure out how/why view needs the MonadReader constraint
21:42:06 <isovector> codygman: looks to me like you're trying to pull a `Rec Identity rec1` out of a monad reader of `Record rec2`
21:42:36 <geekosaur> it's using the trivial Reader monad on Record rec2
21:42:42 <isovector> the base case of monad-reader is just a function
21:42:44 <geekosaur> (aka ((->) e) )
21:43:03 <codygman> isovector:  I'm wanting to specify the lens to use to pull a column out of the Frames Record to build a map with and use to filter incoming rows from a pipe somewhere else
21:44:29 <codygman> geekosaur: "it's using the trivial Reader monad on Record rec2" That sentence doesn't really mean a lot to me, and I don't understand (->), perhas that will change after reading "Functional Programming with Overloading and Higher-Order Polymorphism" as suggested by transformers docs for MonadReader.
21:44:47 <geekosaur> that was more for isovector but they clarified right after
21:45:29 <geekosaur> but, any function that takes one parameter (and in Haskell, that means any function) is a reader monad, because the core of MonadReader is just passing a parameter to a function
21:45:35 <isovector> codygman: newtype Reader r a = Reader (r -> a)
21:46:38 <geekosaur> and, the real problem is: instance MonadReader r ((->) r)
21:46:44 <codygman> isovector: Ah.
21:46:51 <geekosaur> but here you have mismatched types
21:47:02 <geekosaur> which suggests something is not right
21:47:40 <codygman> geekosaur: So are you saying I have a wrong type but it's showing up as a missing constraint on Monad reader?
21:48:01 <geekosaur> that's what it looks like to me
21:48:54 <geekosaur> since the standard MonadReader instance requires that (Rec Identity rec1) be the same as ((->) (Record rec2))
21:49:40 <codygman> Rec Identity rec1 == ((->) Record rec2)     ?
21:49:41 <geekosaur> (or, maybe it is the same type and what you are missing is the part of the type that proves it)
21:49:58 <codygman> Yeah, I thought the problem is that I'm missing part of the type that proves it
21:50:03 <isovector> is there some variant of a mealy machine that can terminate?
21:50:08 <geekosaur> instance MonadReader r ((->) r)
21:50:16 <geekosaur> not (->) r1
21:50:32 <geekosaur> so they need to be the same type, but it thinks they are different
21:50:46 <geekosaur> but I don't know offhand what proof you need for this
21:51:09 * geekosaur not a lens expert, nor familiar with the types involved here
21:54:24 <geekosaur> oh, and having those types differ does not make sense, since it's going to pass the r as a parameter to the function, so obviously the function needs to accept an r
21:54:40 <geekosaur> (which may also suggest you have a parameter swapped, come to think of it)
21:55:15 <codygman> geekosaur: I wonder if it's in my Pipe actually, I'm still kind of fuzzy on those  types
21:56:15 <geekosaur> hm, that is possible since the MonadReader is the *result* of lens
21:56:18 <geekosaur> er, of view
21:56:25 <geekosaur> :t view
21:56:27 <lambdabot> MonadReader s m => Getting a s a -> m a
21:57:17 <codygman> It looks like typed holes thinks I have the right values inside of Pipe
21:58:42 <geekosaur> wait, if I am reading this right, you might have a rec2 where you wanted a rec1
21:59:24 <geekosaur> since you insert something related to a Record rec1 into the map, but it looks like you then check for a Record rec2 in it?
22:00:19 <geekosaur> or perhaps filter a rec2 against it (also not familiar with Pipe) and maybe one of the Record rec2-s in the Pipe type wants to be a Record rec1?
22:00:43 <codygman> geekosaur: Yes, I build a map based on rec1 using lens compositeKey and then I create a Pipe that treats the map derived from compositeKeys in rec1 as a lookup table, filtering out rec2's which do not match
22:01:29 <geekosaur> I... don't think that can work. not as written at least. um, lens might need a polytype?
22:02:53 * geekosaur has reached type confusion and should probably retire :/
22:03:49 <geekosaur> but, the second (view lens r) is fed a Record rec2, but the type of lens is Getting key (Rec Identity rec1) key?
22:04:18 <geekosaur> maybe that is right /o\ lost now
22:04:22 <codygman> geekosaur: I think I fixed it by annotating the r in P.filter explicitly as a rec2
22:04:43 <geekosaur> but your paste shows that annotation ... and the type error right below
22:05:08 <geekosaur> and the type error includes the annotation
22:05:58 * geekosaur gives up and lets someone who knows what they are doing take a shot
22:06:00 <codygman> geekosaur: You are right, I actually named it a record whose type variable doesn't exist and it compiled for some reason :S
22:06:07 <codygman> geekosaur: thanks for the help!
22:07:31 <codygman> :t Pipe
22:07:33 <lambdabot> error: Data constructor not in scope: Pipe
22:46:20 <isovector> :t starve
22:46:22 <lambdabot> error:
22:46:22 <lambdabot>     • Variable not in scope: starve
22:46:22 <lambdabot>     • Perhaps you meant ‘state’ (imported from Control.Monad.State)
22:46:33 <isovector> machines makes my head hurt :(
23:14:37 <meretrix> it seems the matrix libraries are not so great for multiplication of small dimensions..
23:15:07 <meretrix> hand-coding with Vector.zipWithN shaved 80% of the execution time off of my program :/
23:41:04 <EvanR> how do you get a decimal rendering of a rational
23:41:25 <EvanR> truncated in general, obviously
23:46:56 <EvanR> > printf "%.2f" pi
23:46:58 <lambdabot>  error:
23:46:59 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M107540895747...
23:46:59 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:47:02 <EvanR> > printf "%.2f" pi :: String
23:47:04 <lambdabot>  "3.14"
23:47:10 <EvanR> > printf "%.2f" (1 % 3) :: String
23:47:13 <lambdabot>  error:
23:47:13 <lambdabot>      • No instance for (PrintfArg (Ratio a0))
23:47:13 <lambdabot>          arising from a use of ‘printf’
23:47:27 <MarcelineVQ> > showFFloat (Just 2) (fromRational $ 1 % 3) ""
23:47:29 <lambdabot>  "0.33"
23:47:49 <EvanR> what if i want a truncation to 30 places
23:48:08 <EvanR> > showFFloat (Just 30) (fromRational $ 1 % 3) ""
23:48:10 <lambdabot>  "0.333333333333333300000000000000"
23:48:17 <EvanR> i cant go through float
23:48:19 <Myrl-saki> ...
23:48:23 <MarcelineVQ> I don't know enough about floating point numbers to make predictions about accuracy
23:48:25 <Myrl-saki> I feel disgusted seeing that. lol.
23:48:42 <Myrl-saki> EvanR: Long division it?
23:48:42 <geekosaur> there's also fromRat but it also goes through RealFloat
23:48:58 <EvanR> fromRat ?
23:49:08 <MarcelineVQ> EvanR: Have you seen Data.Scientific?
23:49:26 <geekosaur> in Numeric. not sure what the difference wrt fromRational is, but it seems to avoid fromRational
23:49:27 <EvanR> that doesnt represent arbitrary rationals
23:49:32 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/src/GHC-Float.html#fromRat
23:49:59 <geekosaur> oh, but then there are RULES that map it to fromRational for Float and Double.
23:50:01 <geekosaur> wheee
23:50:30 <EvanR> Myrl-saki: yes... last resort
