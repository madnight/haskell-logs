00:00:15 <purelazy> Lokathor - what platform do you use as a matter of curiosity?
00:00:38 <sbrg> purelazy: the script on the stack website will do the Right Thing™ which may involve using the distro's package manager to install stack, so you may need root. but when you upgrade stack via `stack --upgrade`, it'll install itself into ~/.local/bin which doesn't require root
00:00:48 <Lokathor> well i installed stack on a debian virtual machine a long while back, but stack can upgrade itself so i never installed it again
00:01:14 <Lokathor> similarly, my home computer is windows, but stack can upgrade itself as of late so i haven't intsalled it from scratch in a while there either
00:02:48 <purelazy> I'm gonna refresh an old partition with some fresh Mint today
00:04:19 <Lokathor> sbrg, what is the logic behind when it builds the newer stack from scratch and when it just downloads it?
00:04:50 <sbrg> Lokathor: If I'm not mistaken, stack from 1.3.0 and onwards will default to downloading a binary instead of building it from scratch
00:04:58 <Lokathor> oh good
00:05:35 <Lokathor> i noticed the difference just now when i told all my various spare machines to upgrade, and some started compiling and some jsut did a download
00:07:04 <sbrg> i'm not sure if it did something to determine which path to choose before 1.3.0 tbh. but I had ~40ish students that I helped install stack, and it seemed to build it from scratch in all the cases where they had an old version.
00:07:17 <sbrg> granted, for some strange reason, some of them had been running 0.1.x
00:07:41 <Lokathor> 1.1 seems to build
00:07:45 <Lokathor> 1.3 downloaded
00:07:51 <Lokathor> (to 1.3.2)
00:08:19 <sbrg> can confirm
00:08:25 <sbrg> just upgraded from 1.3.0 now
00:08:28 <sbrg> took like 10 secs
00:08:29 <sbrg> how nice
00:09:38 <purelazy> Taking its time here ...
00:09:48 <sbrg> it's a one-time cost
00:09:52 <sbrg> thankfully
00:10:06 <Lokathor> purelazy, to download stack?
00:10:25 <purelazy> doing stack setup
00:10:33 <Lokathor> oh, yes, that'll take a bit
00:12:09 <purelazy> so what is it downloading that's soooooo huge?
00:12:20 <sbrg> it's downloading the compiler
00:12:23 <Lokathor> GHC itself, which is a few hundred MB
00:12:27 <sbrg> for the 'global stack project'
00:12:32 <Lokathor> depending on connection, that can take a bit
00:12:46 <purelazy> Ok
00:13:03 <purelazy> Wow
00:13:35 <Lokathor> stack will also manage different compiler versions, sometimes it might need to grab a different version
00:14:04 <purelazy> I'm not new to Haskell - but new to stack
00:14:27 <purelazy> I understand
00:14:37 <Lokathor> ah, of course then
00:15:06 <Lokathor> well at least we're not rust, with a new compiler every 6 weeks :P
00:16:27 <purelazy> rust?
00:16:40 <Lokathor> it's another programming language
00:16:51 <purelazy> Oh that
00:17:02 <Lokathor> went "1.0" relatively recently, they're still in the rapid development era
00:17:26 <purelazy> What do you think of Rust
00:17:33 <Lokathor> cool stuff
00:17:49 <Lokathor> if you like Haskell, but you want to program more like C, then rust has your back
00:19:29 <Lokathor> once they've got a better story for C interop, I think there'll be much less reason to keep writing new C projects. At the moment, Haskell unexpectedly has a better C interop :P
00:19:52 <Lokathor> oh man, two emotes. brain is too full of coffee
00:21:36 <purelazy> \o/ :o)
00:22:09 <purelazy> I think I tried Rust a few years back
00:23:16 <purelazy> Installing GHC ...
00:23:25 <purelazy> :D
00:24:16 <int-index> Lokathor, Rust is very different from Haskell, I don't think that "if I like Haskell" then "Rust has my back"
00:24:35 <int-index> The biggest thing they have in common is probably type classes / traits
00:24:54 <sbrg> well, some parts of rust feel somewhat familiar if you've written Haskell. but sure, they are different languages
00:25:04 <int-index> Parts such as?
00:25:18 <bjz> ADTs, pattern matching, type classes
00:25:27 <sbrg> like traits, and sum types via enums, etc.
00:25:27 <Lokathor> int-index, there's a conjunction in my statement, which is logically equivalent to an AND operation
00:25:32 <sbrg> but they're missing important things like HKTs and such
00:25:41 <bartavelle> and GC :)
00:25:56 <bartavelle> it's a completely different language, even though some features are similar
00:26:06 <bartavelle> those are not the important features IMO
00:26:33 <int-index> Lokathor, there's also implication in your statement which I object to
00:26:45 <bjz> bartavelle: I dunno, I feel Rust is much closer to Haskell than languages like Java
00:27:16 <Lokathor> int-index, well, i'm not sure. Do you want to program more like C? If not, you're hardly a counter example to my satement :3
00:27:22 <bartavelle> bjz, well, what I find really different with rust is how you have to manually handle the lifetimes/sharing all the time, so in that sense Haskell is closer to Java
00:27:31 <Lokathor> sbrg, they've got higher kinded types actually
00:28:10 <sbrg> Lokathor: they do? I remember reading a proposal regarding HKTs in rust
00:28:18 <int-index> Lokathor, since when? It's an open proposal, not implemented yet
00:28:24 <sbrg> well, the proposal was for something similar
00:28:26 <sbrg> not quite HKTs IIRC
00:28:36 <Lokathor> ah, i may be mistaking HKT
00:28:41 <int-index> https://github.com/rust-lang/rust/issues/8922
00:28:54 <Lokathor> They have their own versions of, for example, Maybe and Either
00:29:09 <bartavelle> as I understand it, it can't be like haskell, as you can't have even a Functor instance (in the same way that Vector.Unboxed can't)
00:29:29 <bjz> Lokathor: Rust doesn't have HKT
00:30:06 <bjz> http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/
00:30:08 <Lokathor> ah, well, I guess i can't tell HTK from normal generics then
00:30:26 <bjz> http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/
00:30:27 <bjz> http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/
00:30:36 <Lokathor> i will take your word for it
00:30:36 <bjz> http://smallcultfollowing.com/babysteps/blog/2016/11/14/parallel-iterators-part-3-consumers/
00:30:36 <sbrg> that's the one
00:30:57 <purelazy> does one use stack to compile, rather than ghc?
00:31:07 <bjz> Those are from one of the key designers of Rust's type system
00:31:18 <sbrg> you use stack to manage your dependencies, which includes the compiler and the packages, on a per-projectb basis
00:31:31 <sbrg> stack then calls ghc with the right parameters/environment variables and builds your project
00:31:44 <purelazy> OK - will search for a stack tutorial
00:32:02 <purelazy> I'm sure is vv simple
00:32:28 <purelazy> is=it's
00:32:36 <sbrg> `stack build` should build your project. `stack exec <your-executable-name>` will run it. `stack build --exec <your-executable-name>` will do both
00:32:53 <sbrg> where <your-executable-name> is the name specified in the .cabal file
00:35:01 <Lokathor> purelazy, stack reads a foo.cabal file (named after the package you're working with) just like cabal does, it also reads a stack.yaml file (always called stack.yaml) for additional info
00:35:31 <Lokathor> and then weaves it all into the correct GHC calls (or other calls, such as haddock)
00:36:04 <purelazy> Do I need to use cabal any more?
00:36:37 <purelazy> Which I think I use to get packages
00:38:13 <purelazy> I need to get the vulkan package
00:38:48 <purelazy> Lokathor: do I use stack, or cabal install vulkan?
00:39:02 <Lokathor> stack install <package>
00:39:20 <purelazy> Lokathor: OK, thanks
00:39:34 <Lokathor> however, in the case of vulkan, i'm not sure there's an LTS that will build it without extra configs
00:39:44 <Lokathor> i remember the dependencies on that one being a little fiddly
00:42:08 <purelazy> Lokathor: It does output some dependency issue stuff and then says ... You may also want to try the 'stack solver' command
00:42:34 <purelazy> [after  $ stack install vulkan]
00:42:54 <Lokathor> personally, i would suggest trying the thing about adding an extra dependency to your config file before trying the solver, if it's all the same to you
00:43:10 <Lokathor> i've usually had more luck that way when trying to figure dependencies, compared to stack solver
00:43:24 <purelazy> OK
00:43:38 <purelazy> I think I can edit a file ;)
00:43:44 <rdococ> hi
00:44:28 <Lokathor> purelazy, the trick is that someimtes one extra dependency suddenly demands another... then you might end up lost in the woods
00:45:19 <purelazy> Lokathor: But if you keep going, you should come out
00:46:17 <bartavelle> you also might end up playing solver manually, but in my experience it always worked out
00:46:20 <Lokathor> depends. you can get into version hell if you're not careful. that's the point of the normal LTS, system, to avoid dependency hell
00:46:37 <purelazy> LTS?
00:47:15 <purelazy> As in long-term-service?
00:47:17 <Lokathor> stack picks versions for packages based on an LTS profile, which is set in the stack.yaml on a project or global level
00:47:49 <Lokathor> yes, long term stability is what it's about, i believe. the LTS versions are issued by stackage, and they're based on collections of pakages that are known to all compile together correctly
00:48:07 <srhb> Long term support*
00:48:43 <purelazy> It seems to be installing vulkan ok
00:48:46 <Lokathor> https://github.com/fpco/lts-haskell#readme here we go
00:49:01 <purelazy> I don't think there should be anything to weird about vulkan
00:50:12 <purelazy> API bindings is quite a common pattern
00:50:48 <purelazy> Hehe: I spoke too son
00:50:59 <Lokathor> ;)
00:55:27 <Lokathor> can someone go back and explain higher kinded types
00:56:04 <Lokathor> specifically: aren't types with kind * -> * higher kinded, and doesn't Maybe count as a higher kinded type, and if so why is rust's Option type not higher kinded
00:57:44 <sbrg> Well, Maybe is a type on its own. Option in rust isn't
00:58:11 <bjz> Lokathor: Option<T> always need a T applied to it
00:58:26 <bjz> *needs
00:58:42 <Lokathor> hmm
00:59:05 <srhb> I don't think * -> * is considered higher kinded anyway
00:59:05 <Lokathor> where can one use Maybe instead of (Maybe a)
00:59:11 <srhb> It's just Type -> Type anyway.
00:59:35 <jmnoz> can someone recommend me a library for parsing HTML? 
00:59:37 <srhb> Lokathor: instance Functor Maybe where...
00:59:45 <sbrg> Lokathor: in cases where you have a type that takes a type of kind * -> * as an argument
00:59:56 <sbrg> like, say, StateT s Maybe a
01:00:04 <bjz> Lokathor: you can define parametrised types, you just can pass around the unapplied types and abstract over them
01:00:29 <Lokathor> ah, right
01:00:45 <Lokathor> the 'a' with the StateT isn't an 'a' on the Maybe
01:00:56 <Lokathor> perhaps i've had too much and too little coffee at the same time
01:01:09 <srhb> Lokathor: Perfect coffee balance is very important. :)
01:03:19 <purelazy> Lokathor; Does stack --resolver lts-7.14  look like something I should type in?
01:04:22 <Lokathor> that would... change the resolver of the action from the current global / project setting to be the version specified, if i recall
01:04:51 <Lokathor> so, maybe that's what you want, but it's probably part of a bigger command
01:04:59 <bjz> Lokathor: All this said, HKTs won't be as useful in Rust as they are in Haskell because Rust isn't lazy. They will probably see most use for abstracting over smart pointers though.
01:05:08 <Lokathor> such as, "stack install vulkan --resolver lts-7.14", or some such
01:05:45 <Lokathor> guys I just remembered that I rewrote an SDL thing the other day and went from 20fps (via ByteString) to 130fps (direct pixel access) and it was totally sweet
01:07:51 <Lokathor> bjz, I don't even think I use HKTs much now, other than the monad transformer stuff
01:09:29 <srhb> Lokathor: How about something like data Foo a b = Foo (a b)
01:09:42 <bjz> HKTs are important to help library authors, that then goes on to help users. If you use fmap and `do`, then you are already using them all the time
01:10:03 <Lokathor> well i do fmap my do blocks i guess
01:10:20 <Lokathor> srhb, I don't personally ever write code like your example
01:10:25 <Lokathor> perhaps a library uses it
01:10:29 * srhb nods
01:11:21 <bjz> srhb: what is `data Foo a b = Foo (a b)`  useful for?
01:11:24 <bjz> ohhh
01:11:41 <srhb> bjz: Just illustrating application of one (type) parameter to another in a simple example :)
01:11:58 <srhb> Things get higher kinded quickly (if that definition is admitted)!
01:12:16 <Lokathor> I need to write a ReaderT thing soon enough
01:12:25 <bjz> data Foo (a : Type -> Type) (b : Type) = Foo (a b)
01:12:35 <Lokathor> ReaderT (MVar [Char]) IO a
01:12:49 <rdococ> foo
01:12:51 <Lokathor> i guess... mvar is higher kinded in that example?
01:12:55 <bjz> I always find it hard to reconstruct the inferred kind signatures
01:13:03 <bjz> or forget to...
01:13:15 <bjz> in my head
01:13:46 <srhb> Lokathor: Why?
01:13:57 <Lokathor> why which?
01:14:07 <srhb> Lokathor: Why do you guess MVar is higher kinded in that example?
01:14:26 <srhb> Lokathor: How do you define higher-kindedness?
01:14:46 <Lokathor> well it's consuming another type, aren't the * -> * (or more) types the higher kinded ones?
01:14:56 <int-index> No.
01:15:00 <srhb> By that definition, every non-nullary type constructor is higher kinded.
01:15:19 <int-index> It's higher kinded as soon as one of its parameters contains an arrow, e.g. (* -> *) -> * -> *
01:15:30 <srhb> Just like with functions :)
01:15:35 <int-index> Yes
01:15:44 <srhb> map is higher order because its first argument is (a -> b)
01:15:46 <Lokathor> int-index, where where you when i first asked 5 minutes ago :P
01:18:05 <Lokathor> atomicPrintLn :: MVar [Char] -> String -> IO () ===> atomicPrintLn :: String -> ReaderT (MVar [Char]) IO ()
01:18:43 <Lokathor> still a pretty bulky type. guess i'll want a newtype over that ReaderT nonsense after all
01:20:39 <exio4> does anyone have a link to that paper which explained parser combinators with the typical StateT String [] implementation? 
01:25:08 <exio4> this will be useful http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
01:39:42 <duga> Hi I'd like to ask you about creating writer  monad. I've tried to do this in accordance to http://learnyouahaskell.com/for-a-few-monads-more but I've failed http://pastebin.com/yYJSwwVx I've also tried to do this in this way http://stackoverflow.com/questions/11684321/how-to-play-with-control-monad-writer-in-haskell but it also didn
01:39:48 <duga> succes
01:40:12 <duga> how could I properly use writer monad? 
01:41:02 <sbrg> posting errors without code is not very useful, duga
01:41:13 <duga> ok
01:42:31 <duga> sbrg: 
01:42:32 <duga> http://pastebin.com/eSaqfydz
01:42:47 <duga> this code comes from the 
01:42:51 <duga> tutorial
01:43:43 <sbrg> try using the `writer` function as opposed to the `Writer` constructor
01:43:44 <sbrg> so lowercase
01:46:10 <duga> sbrg: ok, it works. Thanks
02:01:13 <indi_> Hallo. I'm not sure how to best answer this question, so I'm might ask here. What is the most important benefit that stack gives us that cabal alone does not?
02:01:42 <sbrg> the curated package sets, I'd say
02:02:56 <indi_> but aren't the required packages (and versions) specified in the .cabal file?
02:03:14 <Lokathor> i don't add versions to my cabal files actually, i let lts figure it out
02:03:36 <sbrg> yes, but not all packages specify their bounds correctly, which may cause cabal to pull the newest versions down when you try to build, which may or may not work
02:03:59 <indi_> right, and by not specifying the versions directly, and letting stack do it, we don't enter dependency hells
02:04:36 <sbrg> yes. using stack, there is only one version of a package available for a given snapshot, and that version is guaranteed to build correctly with all packages it depends on and packages that depend on it
02:04:47 <sbrg> in that snapshot
02:05:17 <sbrg> but sandboxing and some other stuff cabal can do now as well, if i'm not mistaken
02:05:36 <sbrg> but you're still at the mercy of package maintainers' version bounds if I'm not mistaken
02:05:52 <sbrg> NB: I might be out of the loop when it comes to some cabal features, since I haven't used it on its own since I started using stack.
02:06:33 <indi_> that's ok. i'm going with stack and i was curious, and you've explained heaps. thanks.
02:06:45 <sbrg> yw
02:07:27 <spocot> How do I go about printing a Maybe value in main?
02:07:57 <sbrg> you can just use `print`, assuming that the `a` in `Maybe a` is an instance of Show
02:08:48 <EvanR> > print Nothing
02:08:50 <lambdabot>  <IO ()>
02:08:56 <spocot> alright, thats what I was trying, my indentation was off at the top of the file and I didnt realize it haha
02:13:00 <slack1256> can pipes-network be used on UNIX_AF ? its module says TCP, yet it takes initiated sockets
02:17:46 <mpsag> im trying to do shell scripting with haskell/stack and once in a while it tells this or that module or interface failed to load. since there's only a script.hs and no cabal file, how am i supposed to add those?
02:18:43 <Wizek> Hey! Can I forkIO in a way that makes sure that all child light-weight-threads are killed whenever the parent is killed?
02:18:52 <danilo2> Hello guys! Is there any way to reify a context of a function in TH in such way that it will be expanded as much as possible? For example: `type Foo a = (Show a, Read a); foo :: Foo a => a` If I reify 'foo I see context `Foo a` instead of expanded one
02:19:31 <danilo2> However (and thats very interesting) - if I create function bar = foo and doesnt type it explicityl and reify it, I've got the expanded one. I just want to get the expanded without the need to create such dummy functions by hand
02:20:12 <srhb> Wizek: Isn't that exactly what happens with forkIO?
02:20:40 <Wizek> srhb, as far as I can tell, no. 
02:20:46 <slack1256> Wizek: Not simply, you can keep the ThreadId and send killthread exceptions to them
02:20:49 <srhb> Wizek: Oh, right, I was thinking "main"
02:20:55 <srhb> Which of course kills everything :-)
02:21:07 <Wizek> srhb, yes
02:22:44 <Wizek> https://gist.github.com/Wizek/03609383bcf7054ac127a8e7f7bd2dc7 <- I've started to write a function like this
02:22:59 <Wizek> so the keeping track of thread id's is encapsulated
02:23:34 <Wizek> but I wanted to take a second to ask if there may be anything similar out there
02:25:39 <Wizek> And as you can see this is handling posix signals. I am also unsure if killThread can be listened to in any way or if I'll likely need an encapsulated killThread too.
02:26:53 <mpsag> explain in 10 words or less what is a monad
02:28:06 <danilo2> mpsag: a buritto :P
02:29:40 <slack1256> a context
02:29:49 <slack1256> preserving
02:29:51 <slack1256> framework
02:30:01 <Wizek> mpsag, Sequential computation in a given context. (e.g. the context can be the RealWorld, or Maybe)
02:31:10 <danilo2> Wizek: monad is not always a sequential computation. 
02:31:48 <Wizek> danilo2, Yeah, I was indeed unsure about that part. But isn't it mostly though?
02:32:10 <danilo2> Wizek: "mostly" ? what is mostly in the terms of monads. Just no :)
02:32:20 <srhb> Are we doing monadsniping?
02:33:39 <slack1256> yep
02:34:13 <slack1256> it a fine past time on #haskell, that and convulted ways to write factorial functions
02:34:58 <slack1256> (btw, fact as a product on a foldr encoded foldl is the best)
02:35:49 <mpsag> how do i add System.INotify to my stack.yaml? :__:
02:37:38 <osa1> mpsag: 1) find which package exports that module by searching for it in Hayoo 2) add that package to your .cabal
02:37:41 <MarcelineVQ> mpsag: it's on stackage so you just add it to your project's build dependencies in ytour .cabal file
02:37:59 <mpsag> i dont get it
02:38:03 <mpsag> i dont have a cabal
02:38:06 <mpsag> its just a shell script'
02:38:14 <mpsag> https://www.fpcomplete.com/blog/2016/11/scripting-in-haskell
02:38:22 <osa1> mpsag: step (1) is still relevant
02:38:41 <osa1> mpsag: step (2) is now "pass that package to your stack command" I don't remember the exact argument format
02:38:55 <mpsag> aaaah
02:39:29 <MarcelineVQ> if you go to 6:38, you'll see how they use --package at the top so that's where it would go
02:40:50 <mpsag> m(
02:40:57 <mpsag> thank you all
02:45:25 <danilo2> Hello guys! It is possible to expand type synonyms in TH?
02:47:40 <MarcelineVQ> probably, expand to in whatway?
02:47:55 <MarcelineVQ> *expand in what way
02:48:39 <kuribas> a monad is a type with operations (bind :: m a -> (a -> m b) -> m b) and (return :: m a)
02:49:38 <danilo2> MarcelineVQ: If I reify in TH something like `foo :: Foo a => a` I get context `Foo a` - I want to expand it, if it is defined like `type Foo a = (Show a , Read a)`
02:52:31 <kuribas> it's the only accurate description of a monad (and the laws).
02:53:02 <ertes> kuribas: and also incomplete =)
02:53:27 <kuribas> ertes: you mean the laws.
02:53:28 <kuribas> ?
02:53:31 <ertes> yeah
02:54:26 <ertes> monads in 10 words or less:  monoids in the category of endofunctors =)
02:54:48 <ertes> probably not useful, but at least accurate and complete =)
02:55:13 <Wizek> What could be a good, reproducible, deterministic way to assert whether a thread is still alive or no longer in a unit test?
02:56:27 <ertes> Wizek: if you created it using the async library, you can use 'poll' or 'pollSTM'
02:58:34 <ertes> Wizek: if you haven't created it using the async library, create it using the async library
02:59:02 <ertes> Wizek: if you want to come up with the necessary signalling framework yourself, don't, because you will be reinventing the async library
02:59:03 <ertes> =)
02:59:54 <lyxia> danilo2: what happens if you reify Foo
03:00:05 <Wizek> ertes, hmm, this does indeed seems like a simpler/safer abstraction than forkIO. I'll give it a try, thanks.
03:00:13 <Axman6> kuribas: return :: a ->  m a*
03:00:24 <danilo2> lyxia: you canniot reify type synonym
03:00:46 <kuribas> Axman6: lol, right :)
03:02:00 <danilo2> lyxia: wait
03:02:17 <danilo2> lyxia: ugh, my bad, you can reify it and yeh it works. Hmm, that was stupid, thanks!
03:07:08 <lyxia> yw!
03:09:35 <hiro`> Hey all, I'm trying to play around with the recursion-schemes library, but it does't seem to be available to stack. Is there a way to tell stack to pull the package directly from its github repo?
03:11:04 <ertes> hiro`: i don't know the answer, but you should probably pull it from hackage instead
03:11:17 <saurabhnanda> does anyone know how to integrate Scotty with a DB connection pool? https://github.com/scotty-web/scotty/issues/198
03:12:38 <sbrg> hiro`: stack can download from git repos, but you should also just be able to add it to your stack.yaml to get it from hackage
03:13:03 <sbrg> the extra-deps field
03:13:54 <hiro`> sbrg: ah yes, just got that message on the command line and now seem to be able to build the project.
03:14:24 <ertes> saurabhnanda: you don't
03:14:42 <ertes> saurabhnanda: withPool (\pool -> scotty …)
03:14:46 <saurabhnanda> ertes: :) why do you say that?
03:15:23 <saurabhnanda> and how do I pass the pool down to the handlers? via the same reader approach?
03:15:34 <ertes> saurabhnanda: just pass it =)
03:15:42 <ertes> myHandler pool
03:15:49 <saurabhnanda> ertes: but conceptually that's exactly what I did. Except that it's a single connection. Why isn't the app holding the connection?
03:16:24 <ertes> saurabhnanda: you mean why Scotty has no built-in reader for your favourite DB handle? ;)
03:16:40 <saurabhnanda> ertes: is this because of runReaderT?
03:16:53 <ertes> saurabhnanda: you could always just use ReaderT, but i'd encourage you to try it without
03:16:57 <saurabhnanda> ertes: this = this behaviour of not keeping a single persistent DB connection?
03:17:19 <ertes> saurabhnanda: the way to keep a single connection/pool is by creating it outside of 'scotty'
03:17:25 <saurabhnanda> ertes: I'm trying to understand what's making scotty connect to the DB with every request. Because if I'm reading the code logically, that should not be happening.
03:17:40 <saurabhnanda> ertes: that's exactly what I did -- https://github.com/scotty-web/scotty/issues/198
03:20:15 <ertes> saurabhnanda: that appears to be correct, as far as i see
03:20:35 <saurabhnanda> ertes: would you expect that code to hold a persistent connection to Pg?
03:21:50 <ertes> saurabhnanda: i can't say for sure, because it's a bit difficult to see all the dependencies (try without ReaderT), but from a cursory read i'd lean toward "yes"
03:22:30 <saurabhnanda> basically is this understanding correct -- in `scotty port (app)` -- app is evaluated once? 
03:23:53 <ertes> saurabhnanda: i don't know, but evaluation doesn't really matter here…  it's execution that matters, and 'app' is only executed once
03:24:21 <ertes> saurabhnanda: you can think of it this way: every ScottyM action is executed once, while every ActionM action is evaluated per-request
03:25:08 <ertes> saurabhnanda: i'd generally use this scheme with scotty (or really any framework):  withDb (framework . webApp)
03:25:48 <saurabhnanda> so, if it's executed only once, the connection should be held
03:25:55 <saurabhnanda> let me try by replaced with `threadDelay 1000`
03:26:05 <libscott> does it seem dangerous to anyone to get a TypeRep from a function by calling with as such: let resultTypeRep = typeOf (f undefined) ? it does work, just not sure if it can go wrong?
03:26:39 <ertes> saurabhnanda: if you get rid of all the ReaderTs, your dependencies will become a lot clearer (and i promise that your code will also get shorter) =)
03:27:22 <ertes> saurabhnanda: you've literally devoted 9 lines of that code to just dealing with ReaderT
03:27:31 <saurabhnanda> ertes: but it won't give my my daily Haskell headrush :)
03:27:54 <saurabhnanda> ertes: I have to write a lot of handlers -- which is why the ReaderT
03:28:29 <ertes> saurabhnanda: your code will still be shorter without ReaderT
03:28:39 <saurabhnanda> btw, could this behaving differently in GHCi?
03:28:47 <ertes> unlikely
03:30:28 <saurabhnanda> something else is wrong
03:30:56 <saurabhnanda> here's what I'm doing: connect => threadDelay => exit -- even then the connection is not being held. Is it because of some laziness?
03:31:10 <saurabhnanda> the connection is not actually being used in the latest test
03:31:36 <saurabhnanda> ertes: how do I make my `conn` variable strict?
03:32:30 <ertes> saurabhnanda: using 'seq', but if that changes the behaviour, you should report a bug ;)
03:33:37 <saurabhnanda> ertes: where do I put `seq`?
03:34:03 <ertes> saurabhnanda: where you want to make sure it's evaluated
03:34:29 <ertes> saurabhnanda: have you tested this outside of scotty?
03:35:20 <saurabhnanda> just did that right now
03:35:25 <saurabhnanda> this test is outside scotty
03:36:00 <saurabhnanda> https://gist.github.com/saurabhnanda/75872a96c8501f72e135d8324d483860
03:36:32 <saurabhnanda> ertes: can you please help me with making `conn` strict at https://gist.github.com/saurabhnanda/75872a96c8501f72e135d8324d483860 ?
03:40:27 <ertes> saurabhnanda: conn `seq` threadDelay …
03:40:56 <ertes> saurabhnanda: but again: if that makes a difference, it would be a very unlikely bug in your PQ library
03:41:29 <saurabhnanda> nope -- no difference
03:41:35 <saurabhnanda> is this due to GHCi?
03:41:48 <ertes> again: unlikely
03:42:07 <ertes> saurabhnanda: how do you determine that there is no connection?
03:42:29 <saurabhnanda> select * from pg_stat_activity;
03:42:53 <ertes> that's an error?
03:43:53 <saurabhnanda> ertes: error? no. it doesn't show any connection from haskell.
03:44:45 <ertes> saurabhnanda: what do you mean?  what behaviour are you observing, and what behaviour do you expect?
03:45:13 <saurabhnanda> take a look at the output of that SQL query at https://github.com/scotty-web/scotty/issues/198
03:45:29 <saurabhnanda> ertes: I'm expecting TWO connections. One from `psql` commandline and the other from scotty.
03:46:32 <adbmal> hi, has somebody found the functional hot spot assembly at 33c3?
03:48:21 <lassulus> adbmal: yes, its between the infodesk and the big hackcenter
03:49:36 <adbmal> great, thanks
03:49:53 <adbmal> is the assembly specifically planning something today?
03:50:23 <saurabhnanda> what could be causing the linker to fail even when the app builds perfectly in intero? https://gist.github.com/saurabhnanda/4df111e8fb3600b024ff10e5809e05db
03:53:33 <saurabhnanda> let it be -- was missing 'exposed-modules' -- bah!
03:53:51 <mpickering> Linker failures are almost always because you forgot to list a module in your cabal file
03:58:03 <osa1> is there a way to evaluate a type application in GHCi ?
04:40:27 <stu> Hello
04:42:14 <hiro`> I'm trying to work through this tutorial on recursion schemes: https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29#.8sjguq3h4 One issue that I'm having is that whenever I try to evaluate an expression in ghci because "No instance for (Data.Functor.Classes.Show1 NatF)". This seems to be because of Fix, as there are derived Show instances for everything else. Is there any way to ensure that the types involving fix can
04:42:14 <hiro`> also be printed?
04:43:21 <hiro`> Sorry, that came out a bit mangled: I'm getting errors when I try to evaluate expressions like `Fix ZeroF`
04:50:19 <lyxia> hiro`: Implement Show1 for NatF
04:54:05 <lyxia> hiro`: http://hackage.haskell.org/package/deriving-compat-0.3.5/docs/Text-Show-Deriving.html this can do it automatically
04:55:47 <smack> hello, anyone here?
04:56:37 <hpc> nope
04:56:50 <hpc> all 1600 people in here stepped out for coffee at the same time :D
04:57:00 <smack> nice :-)
04:57:15 <smack> i tried to understand pointfree for some time
04:58:43 <smack> test x y = not (and x y) should in my mind translate to test = not . and, but some tool told me its (not .) . and
04:59:10 <smack> why is this the case?
04:59:41 <lyxia> not . and = \x -> not (and x) = \x y -> not (and x) y
05:01:03 <smack> that means i need a point for every left out parameter?
05:01:52 <lyxia> kind of.
05:03:04 <lyxia> smack: (.) is just a function, and you can better understand what expressions do by reducing function applications like I did.
05:03:36 <smack> well, i understand what you did, but how to do it the other way around?
05:04:09 <hiro`> lyxia: :+1:, works like a charm!
05:04:21 <lyxia> hiro`: yw
05:04:42 <lyxia> smack: you can try to pattern match the definition of (.) with your expression.
05:06:07 <smack> i'll try, thx
05:06:07 <lyxia> (f . g) z = f (g z)        not (and x y) = not ((and x) y) = f (g x)    for f = not, g = and x, z = y    substitute in the left hand side of the definition    (not . and x) y
05:15:40 <smack> what is the translation of (f .)
05:17:34 <Axman6> (\g -> f . g) which becomes (\g x -> f (g x))
05:17:58 <Axman6> or, \g -> \x -> f (g x) if you prefer
05:18:41 <magneticduck> in Haskellspeak, "compose f after something"
05:27:43 <ph88> using haskell as a target language .. is that a thing ?
05:29:00 <lyxia> Sure
05:29:08 <mbw> Hello all. I tried to subscribe to the mailing lists haskell, haskell-cafe and beginners about two days ago with the digest option. However I haven't gotten any emails up until now. Are these subscriptions confirmed manually by moderators? Also I used an email alias. Could that be the issue?
05:30:13 <lyxia> ph88: It's pretty convenient to compile high-level DSLs via Template Haskell
05:32:11 <ph88> what if you have the interpreter stage at runtime .. you initially have some overhead from transformation of source code to haskell functions .. but then after is execution speed good? Or is it better to generate code and then compile it with ghc and have a seperate executable ?
05:34:47 <lyxia> You'll have to pay some overhead
05:35:25 <ph88> oh ok
05:36:07 <ph88> what about compilation (possible with TH) and then loading in the code after it was compiled ?
05:37:20 <lyxia> this would generally be faster
05:37:41 <ph88> and you have to ship your program with ghc linked to it ?
05:38:29 <geekosaur> mbw, you should probably ask in #haskell-infrastructure
05:38:55 <kuribas> what happens if you export a class method, but not the class?
05:40:04 <shirt> what's better: compiling my language to haskell as the target language, or compiling my language to ghc-core as the target language?
05:40:31 <Axman6> shirt: the former is probably easier to debug, and gets you thing like typechecking for free
05:40:37 <mbw> Ok, thanks geekosaur I will do that. While we're at it, where would I go about asking questions about getting the vim-plugin for ghc-mod to work nicely with stack?
05:40:53 <ph88> shirt, interesting question !
05:41:10 <geekosaur> that one can be asked here, or possibly #haskell-stack (but that channel doesn't actually seem to get much use in my experience)
05:41:27 <Axman6> I wouldn't say that ghc core was ever designed as anything other than a target for GHC Haskell, and might change at any time
05:41:32 <ph88> lyxia, do you know an example of generating code from language with TH ?
05:41:38 <MarcelineVQ> ghc-mod is stack aware already and should prefer to use stack when in a stack project, if there isn't a dist/ folder in your project, I'm not sure how it's affected by vim though
05:41:50 <Axman6> (though, SPJ is pretty proud of the fact Core hasn't changed at all in a very long time)
05:41:57 <geekosaur> shirt, one problem with targeting ghc-core is there's no good way to get core into ghc's popeline
05:42:01 <geekosaur> *pipeline
05:42:22 <geekosaur> external core bitrotted years ago and was finally removed a few ghc versions back
05:42:38 <geekosaur> (it wasn't even the same language as internal ghc-core)
05:42:47 <lyxia> ph88: shakespeare
05:43:32 <ph88> haskell has some great stuff for parallelism http://chimera.labs.oreilly.com/books/1230000000929/index.html so you get that for free when you have haskell as target language .. but the compilation times are not so nice
05:43:34 <mbw> The problem is as follows. Before using stack, i.e. with the ghc from my distro's repository (7.10 I think), errors would be highlighted in red inside vim. Now, highlighting only works for hlint warnings (in blue), but I have to jump the errors manually.
05:44:21 <ertes> saurabhnanda: when you connect from the command line chances are that you will not see a TCP connection, but a unix socket connection
05:44:23 <mbw> The errors/warnings get propagated correctly after each write, it's just inconvenient that highlighting doesn't work.
05:44:34 <ph88> shirt, what's your language ?
05:45:11 <shirt> ph88: don't have one, i'm just curious :)
05:45:48 <shirt> i don't think i'm smart enough today to make a language that is better than haskell (even though i have some fuzzy ideas...) maybe in the future
05:45:57 <ph88> shirt, i would like to have parallelism and fast compile times, hard to get it seems :P
05:47:45 <MarcelineVQ> mbw: other than making sure your vim plugin is up to date, and checking it's issue page if it has one,  not much else I know to check
05:50:12 <shirt> ph88: you mean haskell "par", or threads?
05:50:53 <ph88> both .. and all other stuff that is in the book
05:51:48 <ph88> lyxia, eh that idea with TH .. i think it won't work because it requires the DSL to be compiled at the same time as the haskell code. In my situation i have a compiled haskell program that does parsing and then from there needs to generate IR
05:53:35 <mbw> I think there's also hdevtools, right? Is ghc-mod strictly more powerful and a de-facto standard? I wouldn't really say I was able to make an "informed choice" between the two.
05:55:08 <geekosaur> ghc-mod is second generation (hdevtools being first generation). intero is third generation and seeing increased use, and solves some of the ghc version skew issues that come up with ghc-mod
05:56:29 <ph88> intero matured already ?
05:56:57 <mbw> Wow I haven't even heard of that one. Good to know.
05:57:45 <geekosaur> still developing
05:58:26 <geekosaur> in fact that was kind of the point there; the whole IDE-plugin ecosystem is still evolving rapidly
05:58:59 <jmnoz> what would you use to do stuff like removing particular nodes of a (possibly malformed) HTML document?
05:59:52 <c_wraith> jmnoz: you mean for manipulating a DOM?
06:00:03 <mbw> This seems to be an emacs thing though.
06:00:10 <c_wraith> jmnoz: or do you have some other thought?
06:00:37 <mbw> And other vim related solutions seem to completely hijack it, assuming a clean vim install
06:00:39 <jmnoz> c_wraith: I suppose manipulating a DOM, not sure what other options exist
06:00:48 <jmnoz> c_wraith: rather avoid regex
06:00:55 <c_wraith> jmnoz: well, you could try to do some sort of tag soup filtering
06:01:10 <ertes> does intero have an advantage over haskell-mode?
06:01:31 <c_wraith> ertes: it probably has better stack integration, if you're into that sort of thing
06:01:40 <ertes> i'm not
06:02:01 <ertes> so i couldn't use intero even if it had an advantage, but i'm curious
06:02:14 <MarcelineVQ> geekosaur: intero has similar issue as ghc-mod for versioning, it's just clearer about what to do about it :>
06:02:39 <jmnoz> c_wraith: okay thank you
06:03:08 <jmnoz> does haskell mode have goto-definition? intero does
06:03:11 <c_wraith> jmnoz: It depends on whether you want to work with a stream of elements or a tree of them.
06:03:17 <mbw> Thank god my rate determining step in programming with Haskell is still thinking, so I'll probably just stay with what I got.
06:03:41 <ertes> jmnoz: i'm pretty sure haskell-mode has everything intero has, except perhaps some stack-specific stuff
06:04:17 <lyxia> ph88: that's too bad then
06:04:37 <MarcelineVQ> to avoid version issues with ghc-mod you   cabal install ghc-mod   for each project you use a sandbox for, or   stack build ghc-mod   for each project you use stack for. intero will tell you a similar thing, to stack build intero for each lts resolver you use
06:04:54 <ertes> ouch =)
06:05:17 * ertes hugs nix and haskell-mode
06:06:26 <ph88> lyxia, you said it :P
06:06:39 <mbw> Oh that reminds me. Using the ghc from the global stack project, is there a convenient way to add dependencies? Right now I find myself creating project templates even for trivial stuff that needs mtl, for instance. Since I'm still learning and don't work on larger projects, this fill kinda off.
06:06:44 <mbw> *feels
06:07:37 <ertes> mbw: you don't have to use nix/stack for everything, or even cabal for that matter…  i have a directory with a Makefile that just compiles individual source files
06:08:14 <MarcelineVQ> stack build mtl   outside of a project if you want mtl available in the global-resolver, you'll only run into issues if somehting needs extra-deps
06:08:54 <ertes> mbw: https://github.com/esoeylemez/config/blob/master/scripts/Makefile
06:09:01 <MarcelineVQ> sometimes if I want a few I'll go: stack ghci --package mtl vector text   etc to set them up
06:09:41 <ertes> mbw: builds all *.hs files that start with a lower-case letter as a program, so you can use capitalised file names as utility modules
06:10:12 <shirt> also don't forget about ghc --make
06:10:36 <ertes> this *is* ghc --make
06:10:38 <ertes> --make is the default
06:11:04 <ertes> oh, and ignore the 'install' target…  it's nix-specific
06:12:16 <mbw> Ok these seem to be options I should try out, thank you very much.
06:14:01 <mbw> Speaking of mtl... :/
06:16:59 <mbw> For learning purposes, I tried to newtype a transformer stack and implement MonadReader instances etc. manually, however I quickly ran into a brick wall. From what I can tell, there should probably be a systematic way using mapReaderT, mapWriterT and the like. Is there a resource I can look up in that regard? I didn't find anything, since GeneralizedNewtypeDeriving seems to be the standard way. Or just 
06:17:09 <mbw> making a new monad, I guess.
06:18:30 <mbw> The problem is, I think I know how to use transformer stacks, but until I figure out these details at least to some extent, it just doesn't feel like I've understood the topic really.
06:25:25 <kuribas> mbw: newtype MyMonadStack = MyMonadStack (...), then instance MonadState s MyMonadStack where get = MyMonadStack get; put x = MyMonadStack $ put x
06:26:51 <mbw> Wait really? Is it always f = MyMonadStack . f?
06:27:23 <mbw> This would be kind of embarrassing...
06:27:31 <lyxia> you need more or less points depending on the number of arguments to f
06:28:03 <kuribas> a >>= f = myMonadStack $ runMyMonadStack a >>= runMyMonadStack . f
06:28:20 <lyxia> This doesn't work very differently from GeneralizedNewtypeDeriving though
06:28:43 <mbw> My problem was with local
06:28:45 <kuribas> mbw: it's just wrapping and unwrapping.
06:29:31 <c_wraith> mbw: local is a bit weird.  It actually prevents several things that could otherwise be an instance of MonadReader from being one.
06:30:09 <kuribas> :t local
06:30:11 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
06:31:05 <kuribas> try this: local f m = MyMonadStack $ local f (runMyMonadStack m)
06:31:53 <mbw> wow
06:33:40 <mbw> For future reference, is there a systematic way to go about this, maybe using type holes? I find this a viable approach most of the time when I'm stuck, but here I couldn't really make this method work. Or how would you systematically go about it in this case?
06:34:21 <mbw> First of all, thanks for the definition of local!
06:34:43 <sbrg> mbw: there's GeneralizedNewtypeDeriving
06:34:46 <sbrg> for most of it
06:35:25 <mbw> sbrg: Yes I know. I was trying to define these instances on foot for educational purposes only.
06:35:35 <sbrg> ah 
06:36:49 <codedmart> Is there a function `(a, m b) -> m (a, b)`?
06:38:08 <codedmart> If I have a tuple `(1, Just "string")` and I want to go to `Just (1, "string")`.
06:39:00 <mbw> sequenceA?
06:39:21 <pavonia> > sequenceA (1, Just "string")
06:39:25 <lambdabot>  Just (1,"string")
06:40:51 <codedmart> Thanks!
06:51:40 <noraj> Hi guys, tricky question. I have to hide some haskell code into a GIF so my haskell programm absolutly need to begin with `GIF89a` but the probleme is beginning with an uppercase letter, so GIF89a can't be a function or a variable only a data constructor but I can't prefix it with `data`. Someone has an idea to generat a valid haskell code beginning with `GIF89a` ?
06:52:53 <geekosaur> can we just add a link to that discussion to the /topic, please, apparently everyone doing that CTF is going to come in here and ask the same question
06:53:18 <sbrg> which CTF?
06:53:26 <yushyin> 33c3 ctf
06:53:45 <noraj> lel so I'm no the first
06:53:55 <yushyin> sbrg: https://33c3ctf.ccc.ac/
06:54:02 <sbrg> cheers
06:55:23 <noraj> geekosaur can u give me the link of teh discussion please ?
06:55:42 <bennofs> noraj: you could probably just search for GIF89a in the channel logs
06:55:48 <geekosaur> ^
06:56:08 <noraj> you're right
06:56:16 <geekosaur> anyway, short answer is you start the file with a pattern match
06:57:20 <geekosaur> GIF89a x = x; data GIF89a x = GIF89a x; -- or similar; Haskell lets you use before definition
06:57:29 <hodapp> gif89a?
06:57:31 * hodapp rubs eyes
06:57:34 <hodapp> what year is it?
06:57:47 <noraj> geekosaur : at least I have discovered haskell syntax by reading a lot of documentation ^
06:57:52 <mbw> Is there recommended way to use lambdabot offline, using a stack ghc? In the long run, I would be interested in using ghci on acid globally. But since 'stack install lambdabot' wants me to add a gazillion dependencies to the global stack.yaml, I don't know if this is the correct way to go.
06:58:39 <geekosaur> hodapp, as every year, it's the year of "must support ancient browsers that only support ancient image formats" :p
06:58:56 <hodapp> 9_9
06:59:06 <geekosaur> hey, at least they're not asking how to run Haskell inside of IE6
06:59:37 <bennofs> does GHCJS support IE6?
06:59:48 <geekosaur> doubt it
06:59:48 <bennofs> probably not xd
06:59:59 <noraj> Is it not criminal to use IE6 in your country ?
07:00:03 <geekosaur> IE6's JS was ... really terrible
07:01:15 <geekosaur> mbw, use a stack sandbox to install lambdabot, then install the goa component in the global stack project
07:07:10 <mbw> So goa does not depend on lambdabot? Because this sounds like I could use lambdabot only in corresponding projects, right?
07:07:35 <geekosaur> goa requires the lambdabot binary to be on $PATH
07:07:46 <geekosaur> it doesn't require the lambdabot modules or source
07:09:08 <geekosaur> (unless something changed since the last time I looked at it, but I can't see that happening; lambdabot was not designed to be used as a plugin)
07:10:15 <geekosaur> you might need to install goa in each project where you'd want to use it, but you could use the same installed lambdabot with all of them
07:10:29 <mbw> But a stack sandbox is just a dummy project, right? Like stack new lambdabot simple or something?
07:11:19 <geekosaur> get the lambdabot source, 'stack init' to make it a separate project, build and install?
07:11:37 <geekosaur> (or manually create a stack.yaml for it)
07:11:44 <mbw> oh boy
07:13:19 <mbw> I think what made me curious about it in the first place was unmtl. Maybe lambdabot is overkill for this? Or are there any more indispensible functions it has?
07:14:07 <MarcelineVQ> you can write   stack unpack lambdabot   to have stack fetch the source for you
07:15:25 <MarcelineVQ> afterward  stack init --solver  in the lambdabot directory should figure it out
07:16:27 <mbw> I think you mentioned earlier to stack unpack mtl to make it available globally. What exactly does unpack do?
07:16:35 <MarcelineVQ> no I mentioned stack build mtl
07:16:39 <mbw> oh
07:16:42 <mbw> excuse me
07:16:53 <MarcelineVQ> which builds it for the resolver that .stack/global-project/stack.yaml specifies
07:17:38 <mbw> Ok and stack unpack just downloads the project source?
07:17:42 <MarcelineVQ> yes
07:18:49 <mbw> Ok, making progress. Also, I was wondering how to search for specific packages without having to go on stackage? Is there similar functionality for stack like hoogle?
07:19:26 <mbw> That is probably asking too much. I would already be happy if I could just grep a package list.
07:19:35 <MarcelineVQ> there's   stack hoogle  , but I couldn't get it to work when I tried it
07:21:50 <mbw> I thought stack hoogle was related to browse project specific haddock documentation.
07:21:58 <mbw> Say I need a linear algebra package.
07:22:07 <mbw> And don't have a browser installed :/
07:22:24 <mbw> Is there a way to browse the local package index?
07:23:27 <mettekou> I would like to implement notation à la Coq or Agda using parser combinators (Megaparsec). Is there a better way to do this than to wrap ParsecT in a StateT which holds the parsers generated at run-time?
07:23:43 <MarcelineVQ> mbw: I'm not sure
07:25:27 <geekosaur> mbw, you'd be installing the hoogle package, which includes a command line client
07:25:50 <geekosaur> http://hackage.haskell.org/package/hoogle
07:26:30 <geekosaur> (and afaik the cabal and stack hoogle commands just build the database; you need the client to search it)
07:27:10 <mbw> I do have installed the local hoogle package.
07:27:30 <mbw> If this is the way god intended, I shall become more familiar with it.
07:28:05 <Welkin> who is god?
07:28:09 * geekosaur does not pretend to know what god intended...
07:29:29 <MarcelineVQ> stack exec -- hoogle generate   should get you a good swath, afterwards you could use stack exec -- hoogle "Text -> Text -> Text"   or probably just hoogle "Text -> Text -> Text"  
07:29:54 <MarcelineVQ> idk if the stack part matters at all for that one or if it's just hackage
07:30:48 <mbw> I think I just didn't realize stackage and hackage were this tightly coupled.
07:31:19 <mbw> On the other hand I should've, since cabal is the back end.
07:31:33 <mbw> I don't know what I'm doing
07:32:07 <Welkin> stackage is just a list of packages that work together
07:32:09 <geekosaur> hackage is everything, stackage is a subset known to work well together
07:33:42 <mbw> Regarding that. Is everything that comes with GHC (except GHC modules) part of the "standard library"? Like transformers and bytestring?
07:33:59 <Welkin> only base
07:34:30 <Welkin> http://hackage.haskell.org/package/base
07:34:33 <Welkin> isn't that right?
07:34:40 <Clint> depends on what you mean by "the standard library"
07:35:11 <geekosaur> ghc has some "interesting" versioning requirements, which mean that as little as possible gets bundled because anything bundled cannot be safely upgraded
07:35:19 <MarcelineVQ> hmm, idk, possibly anything being maintained by libraries@haskell.org is potentially standard libraries
07:35:23 <geekosaur> so it is a very minimal core, not a "standard library"
07:35:50 <mbw> I come from a C/C++/fort *ahem* /FORTRAN background, where the standard library is, well, part of a standard. So I tend to think in those terms.
07:36:00 <JuanDaugherty> i like HP for that slot
07:36:24 <JuanDaugherty> sumo std
07:36:24 <geekosaur> to the extent that there is a standard of that nature (the libraries part of the Language Report), it's the Prelude and nothing else :)
07:36:26 <Welkin> what does harry potter have to do with it?
07:37:07 <Welkin> whose prelude, though?
07:37:09 <lifter> When I compile my project on macOS 10 El Capitan I don't get any warnings, but when I compile on Ubuntu 16 I get redundant constraint warnings for "HasCallStack". I am compiling with GHC 8 on both systems (on Mac it's GHC 8.0.1.20161117, on Ubuntu it's 8.0.1). Anyone know why I get these warning on Ubuntu but not on Mac?
07:37:11 <Welkin> bach? chopin?
07:37:23 <Clint> /kick Welkin
07:37:27 <Welkin> o.o
07:37:58 <glguy_> mbw: You can check out the Haskell Report to see what parts are part of the standard. It's a reasonable document to read and reference.
07:38:26 <MarcelineVQ> lifter: that's a very good question to ask in #ghc so people are aware of it  note that it's slow though so you may not get a response for awhile
07:39:33 <lifter> MarcelineVQ: Ok, I'll do that. It's puzzling to see this warning at all, I don't understand why I see it for some functions and not others.
07:39:58 <EvanR> the redundant constraint warning behavior did change, i think
07:40:06 <EvanR> i.e. it now warns
07:40:16 <geekosaur> mbw, the whole standard library thing is a bit fraught on several levels, so there is not currently a standard defining the libraries beyond the Prelude. the community has several de facto standards --- but also a certain amount of fragmentation
07:40:31 <Welkin> and there are many preludes
07:40:52 <geekosaur> but only one is (a) shipped with ghc (b) specified by the Language Report
07:40:53 <mbw> Do you mean protolude and the like?
07:41:13 <Welkin> I kind of like classy=prelude
07:41:16 <geekosaur> and mbw specifically mentioned standards
07:41:16 <mbw> This is kind of scary
07:41:18 <Welkin> classy-prelude
07:41:22 <Clint> basic-prelude
07:41:22 <Welkin> never tried protolude
07:41:33 <EvanR> protolude, interlude, damnSmallLude
07:41:39 <MarcelineVQ> lifter: if you're using ImplicitParams you're more likely to see it, but people using that are usually aware they're using that
07:41:47 <hackrilege> I'm reading about bidirectional put lenses; https://goo.gl/1r6PC7
07:42:20 <lifter> MarcelineVQ: I don't seem to be using that anywhere
07:42:44 <hackrilege> Monadic Combinators for “Putback”
07:42:45 <hackrilege> Style Bidirectional Programming
07:42:45 <hackrilege> Hugo Pacheco Zhenjiang Hu
07:42:45 <hackrilege> Sebastian Fischer
07:42:49 <hackrilege> Sorry...
07:44:05 <hackrilege> The package however has bloated overhead, while the paper seems to indicate a simple implementation should be possible; https://hackage.haskell.org/package/putlenses
07:45:56 <MarcelineVQ> mbw: just means you got options when you need them :>
07:45:58 <mbw> Let me give an example. At my university, the hpc systems have an older ghc installed. So if I wanted to compile on that machine, I could probably make a stack project using the same ghc version and make a source tarball, or some other fancy option stack offers. Would that be portable, i.e. compile on the other machine?
07:46:29 <g3ol4d0> Guys , in haskell there is something like a #define in C ?
07:46:35 <hackrilege> I'm also wondering how record syntax can be used in place of lenses, but am concerned by the presence of template Haskell in the dependencies of this package. Does anyone know if this put based approach can be implemented in a simple way?
07:46:37 <Welkin> mbw: no, just have stack install a new ghc
07:46:51 <g3ol4d0> or something that runs before the compiling ?
07:47:00 <Welkin> g3ol4d0: we have literally #define, but that is for the cpp
07:47:13 <mbw> That would however require stack or caball on that machine.
07:47:33 <g3ol4d0> Welkin: you have a example ?
07:47:41 <geekosaur> hackrilege, record updates are not first class and not very composable. currently you need TH to autogenerate composable accessors/mutators for records
07:47:54 <Welkin> g3ol4d0: no, I don't even know why/how it's uses
07:47:57 <geekosaur> (or you could write a whole lot of annoying boilerplate)
07:48:02 <Welkin> I've seen it in lots of base libraries though
07:48:04 <MarcelineVQ> Welkin, mbw: I wouldn't say no, you _can_ do either, but I agree you should use a newer ghc if possible.
07:48:23 <g3ol4d0> Welkin: you have the link of some ?
07:48:39 <MarcelineVQ> but you have that option, that's why there's a resolver list on the stackage main page about what lts is what ghc version
07:48:48 <ph88> anyone have experience with loading compiled haskell code? do i have to use extern keyword ?
07:49:23 <geekosaur> ph88, take a look at hint and/or plugins (those are hackage packages)
07:49:36 <hackrilege> Thanks geekosaur, could you help me understand what you mean by autogenerating composable mutators? And where can I learn about how to use template Haskell in this way...
07:49:58 <ph88> oh cool !
07:49:59 <mbw> Ok, that's good to know. Even if I would just use Haskell instead of Bash for a job script, for instance.
07:50:35 <ph88> what would be the recommended way to generate haskell code to load it with hint? Generate haskell code as strings? or as syntax tree?
07:50:51 <Welkin> here is something http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Conc.Sync.html#line-100
07:50:58 <Welkin> I can't find #define anywhere though
07:51:00 <Welkin> you can look around
07:51:04 <Welkin> or check the haskell report
07:51:13 <g3ol4d0> Welkin: thanks
07:51:42 <geekosaur> hackrilege, http://hackage.haskell.org/package/fclabels was one of the first lens-like packages, and is still one of the simplest to understand. and includes TH to derive accessors
07:53:06 <geekosaur> but, essentially, you create your records with field names prefixed with an underscore, and then apply a top level splice (e.g. `` makeLenses ''MyRecord ``) which creates a typeclass instance for each field
07:55:04 <geekosaur> g3ol4d0, it's uncommon for CPP to be used to define macros in Haskell code; it's generally used to do conditional compilation based on available libraries (that is, the Haskell code will have #ifdef-s making use of macros defined by the build system)
07:55:08 <Eduard_Munteanu> geekosaur, isn't that makeClassy?
07:55:24 <geekosaur> the name varies...
07:55:33 <MarcelineVQ> Welkin: #define is part of the -XCPP (C preprocessor) language extention, and you use it with flags passed to ghc such as -DMyDefinedThing
07:55:39 <geekosaur> I didn't check which fclabels is using
07:55:41 <Eduard_Munteanu> Oh, I'm thinking of 'lens'.
07:56:29 <geekosaur> there's only about a dozen different lens packages, not counting the ones that are attempts to cut down the dependency list of ekmett's lens
07:56:40 <Welkin> lens-family :D
07:57:52 <yushyin> g3ol4d0: and maybe check this out https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#c-pre-processor
07:58:12 <Eduard_Munteanu> You can still use the #ifndef-#include pattern as in C.
07:58:28 <g3ol4d0> tnks guys
07:58:29 <Eduard_Munteanu> Er, #ifndef-#define include pattern.
07:59:47 <Eduard_Munteanu> I wonder if there's a nice alternative prelude which uses CPP to provide qualified imports.
07:59:49 <Matias_> hi guys
08:00:01 <Matias_> is it possible to make a type declaration of data constructors?
08:00:02 <g3ol4d0> Hi Matias_ 
08:00:18 <purelazy> hi
08:00:18 <Eduard_Munteanu> Matias_, hi. Yes, with GADTs.
08:00:47 <Eduard_Munteanu> {-# LANGUAGE GADTs #-}
08:00:49 <Matias_> e.g. data Maybe a = Just a | Nothing
08:01:07 <Matias_> can I specify Just :: a -> Maybe a
08:01:26 <Eduard_Munteanu> data Maybe a where { Nothing :: Maybe a; Just :: a -> Maybe a }
08:01:56 <Matias_> so something like Just :: a -> Maybe a is not accepted by the grammar, right?
08:02:56 <Eduard_Munteanu> Not without GADTs.
08:03:15 <Matias_> Eduard_Munteanu: me and g3ol4d0 are competing to see if someone can come with a haskell statement which begins with an uppercase letter
08:03:21 <geekosaur> (why do I suspect this is (at least an interesting variant of) the CTF?)
08:03:26 <geekosaur> heh, thought so
08:03:37 <Eduard_Munteanu> Um, capture the flag?
08:03:43 <yushyin> geekosaur: :D
08:04:01 <geekosaur> Eduard_Munteanu, https://33c3ctf.ccc.ac/
08:04:58 <Eduard_Munteanu> Heh.
08:05:11 <Matias_> geekosaur: any idea? :P
08:05:12 <mizu_no_oto_work> Matias_: https://www.cis.upenn.edu/~sweirich/talks/GADT.pdf
08:05:13 <yushyin> geekosaur: we really should update the topic with a paste howto start a haskell programm with GIF89a
08:05:19 <geekosaur> hint: pattern matching
08:05:26 <Matias_> geekosaur: thanks!
08:05:51 <Eduard_Munteanu> Ah, good one.
08:06:07 <bennofs> i must be the only one who solved this without #haskell :D
08:06:59 --- mode: ChanServ set +o geekosaur
08:07:10 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706 | CTF hint: pattern matching' by geekosaur
08:07:14 --- mode: geekosaur set -o geekosaur
08:07:53 <puregreen> what's AoC?
08:08:01 <g3ol4d0> bennofs: probably
08:08:02 <geekosaur> advent of code. probably can go away now
08:08:25 <geekosaur> (but I'm not following it and not certain of that, so I left it)
08:09:35 <sm> noo, let's keep the haskell AoC leaderboard accessible for a while
08:10:01 <ninjaaron> So, I don't actually know Haskell. I'm just currious if there are some sort of key, value mapping data types...
08:10:04 <glguy> The leaderboard will stay available to people who've already joined it
08:10:07 <ph88> geekosaur, could you take a look at this schematic? i wonder if this will work https://i.imgur.com/kIdca6a.png
08:10:10 <sm> though that cryptic code in the topic doesn't do much
08:10:16 <Clint> ninjaaron: yes
08:10:19 <yushyin> ninjaaron: a map
08:10:22 <glguy> but I doubt anyone will join the leaderboard at this point
08:10:41 <geekosaur> Map or HashMap
08:11:01 <ninjaaron> Are they lazily evaluated?
08:11:15 <ninjaaron> I was trying to think about that an my mind was blown.
08:11:43 <geekosaur> keys are necessarily strict, values will depend on what variant you use
08:12:17 <geekosaur> ph88, looks like it. although you may want to look at using ghc-api directly if you are compiling stuff on the fly
08:12:18 <sm> fair enough
08:12:43 <ph88> geekosaur, why i may want that ?
08:12:58 <geekosaur> (hint is a simplified wrapper over ghc-api; depending on what you are doing, it may be too simple)
08:13:33 <geekosaur> or, you may be able to pipeline stuff better if you use the api directly
08:13:56 <geekosaur> that said, ghc-api is moderately hairy, which is why things like hint exist
08:14:07 <ninjaaron> geekosaur: That makes sense.
08:14:14 <ninjaaron> I was trying to think about lazy keys.
08:14:21 <ninjaaron> I did not succeed in having that thought.
08:14:31 <geekosaur> no, that one would be ... rather tricky
08:17:17 <EvanR> ninjaaron: theres also IntMap
08:18:01 <lpaste> stdnt pasted “readFile” at http://lpaste.net/350606
08:18:30 <Matias_> geekosaur: did it, a million thanks.. I should have spotted it in the grammar before :P
08:19:37 <lpaste> stdnt revised “readFile”: “readFile” at http://lpaste.net/350606
08:20:25 <lpaste> stdnt pasted “input.txt” at http://lpaste.net/350608
08:21:47 <stdnt> Hi, Im trying to read a file in haskell in a format of the first line is the number of case, and the following 3 line is the argument for each case, like on this input file, there are 3 cases: http://lpaste.net/350608
08:22:12 <stdnt> so far i tried to do this http://lpaste.net/350606 but i'm afraid it's still produces error
08:22:16 <hackrilege> Geekosaur, what do you mean by "boilerplate" in this context? Do you mean that template Haskell can by bypassed?
08:23:10 <glguy> stdnt: Your code only reads two lines per case
08:23:52 <glguy> stdnt: the 'return "done"' doesn't do anything
08:24:04 <stdnt> glguy: oh is it?  i though there are 3 readLine...
08:24:05 <geekosaur> hackrilege, yes, you can define the necessary instances by hand if you know what the package expects for them, or if you want to do something special the TH can't do for you (like special name mangling)
08:24:20 <stdnt> sorry, getLine
08:24:27 <glguy> stdnt: Oh, you changed the code
08:24:44 <hackrilege> Oh, so it's like a fancy deriving tool
08:24:51 <lyxia> stdnt: what's the error
08:25:25 <stdnt> lyxia: dice.hs:26:3:     Couldn't match type ‘[Char]’ with ‘()’     Expected type: IO ()
08:25:50 <stdnt> glguy: yea, i pasted the wrong version.
08:25:50 <glguy> stdnt: That's because your main definition has the type IO ()
08:26:02 <glguy> but your process definition has the type: Int -> IO String
08:26:03 <hackrilege> So should I use template Haskell where instances are generated algorithmically, such as generating lenses from records?
08:26:20 <glguy> and String is a synonym for [Char]
08:26:37 <geekosaur> hackrilege, generally yes because it saves you typing out a lot of noisy stuff
08:26:50 <geekosaur> it's a convenience, and a fairly nice one
08:27:07 <EvanR> TH is really convenient
08:27:12 <glguy> stdnt: Instead of 'return "done"' you can write 'return ()'
08:27:18 <EvanR> while your TH is compiling you can get coffee
08:27:28 <tmciver> glguy: I know I'm late to the party as I just found out about AoC (you made me aware of it last week); is it going away?
08:27:35 <stdnt> glguy: ah
08:27:49 <glguy> tmciver: The website will stay up all year. You can even go back and do the 2015 stuff
08:27:57 <glguy> The #haskell leaderboard works for 2015 and 2016 challenges
08:28:12 <glguy> But new challenges won't come out until next December
08:28:12 <tmciver> glguy: but they won't be adding new puzzles?
08:28:31 <glguy> It's "advent" of code, so you get one challenge a day from Dec 1-Dec 25
08:28:51 <EvanR> they need all year to come up with the puzzles
08:28:51 <tmciver> Ah! I didn't get that! :|
08:29:00 <glguy> so that's 50 2-part tasks to work on
08:29:39 <tmciver> glguy: do you mean 25 2-part tasks?
08:29:51 <glguy> No, 50 because there are 2 years so far
08:29:56 <hackrilege> I'm concerned that as I get closer to understanding lenses that most applications can simply use pure Haskell record syntax, I think it's the main advantage of using lenses that they are composable, can I get an example of where this allows me to do things I would struggle to do without a lens library?
08:29:59 <tmciver> glguy: Ah
08:30:41 <EvanR> hackrilege: for one thing, update something in a nest of records
08:30:43 <geekosaur> hackrilege, the usual example is modifying a record contained in another record
08:30:43 <MarcelineVQ> composeable and you can reach arbitrarily deep into a structure
08:30:47 <glguy> hackrilege: The main advantage is that they are first-class values
08:30:57 <tmciver> glguy: I'm embarassed to say that I've only worked on the one from 12/21/2016 and I've spent many hours on it. :(
08:31:13 <glguy> nested record updates is a minor, but common use-case
08:31:31 <lyxia> \x y -> x { field1 = (field1 x) { field2 = (field2 (field1 x)) { field3 = y } } }
08:32:00 <hackrilege> What's the deal with first class values? I understand how composition allows nested updates
08:33:03 <lyxia> being first class means it doesn't need too fancy language features to use and compose
08:33:18 <lyxia> it's just a value like any other
08:33:41 <hackrilege> Can I get an example of a second class value?
08:33:43 <EvanR> like, you can factor out common components of a lens
08:33:50 <geekosaur> nested record updates are the gateway drug of lens :p
08:33:58 <EvanR> second class, record update syntax
08:34:53 <geekosaur> hackrilege, record update syntax cannot, for example, take the field to be updated as a parameter; so you would have to define a separate updater for each field
08:35:35 <geekosaur> this could also be done with TH but (a) more annoyingly (b) if you're doing that anyway, might as well make it a lens and get even more bang for your buck
08:35:47 <hackrilege> That could be by pattern matching on Int for example
08:36:01 <EvanR> Int o_O
08:36:33 <EvanR> that would be unmaintainable, type unsafe
08:36:47 <hackrilege> I guess that's not as sweet as using something like fst to derive a lens
08:37:00 <EvanR> or just having a separate updater for each field
08:37:09 <EvanR> generated by TH or not
08:37:15 <glguy> hackrilege: Here's an example that I was just playing with: https://github.com/glguy/advent2016/blob/master/Day11.hs#L101-L102 I wanted to use the same "move" logic with two fields of my record type once from the first field to the second and once from the second back to the first
08:37:22 <hackrilege> Thanks!
08:37:58 <mbw> I also have a question about algebraic data types. Recently I came across a situation where I had defined a type like data T = T1 Int String | T2 Int Double | T3 Int . I could also define this as T' = T' Int (Maybe (Either String Double)). My impression was that pattern matching becomes increasingly annoying, since it moves "further to the right" and uses either specific functions like maybe/either or case 
08:38:04 <mbw> expressions. On the other hand, the first definition clearly has a lot of redundancy. Are there some "best practices" regarding this issue?
08:38:10 <hackrilege> Can I do this kind of stuff using arrows?
08:38:23 <hackrilege> If not, what are they good for?
08:38:33 <glguy> that's an open question
08:38:38 <glguy> (the second)
08:38:45 <EvanR> mbw: you can encode any ADT using nothing but Either and (,)
08:38:50 <EvanR> but you probably dont want to
08:39:18 <EvanR> and ()
08:39:27 <EvanR> so Maybe is redundant, Either () a
08:39:35 <geekosaur> hackrilege, tbh many of the things one might think one could do with arrows, you either can do with applicatives instead, or can't do at all with arrows
08:39:36 <mbw> ok.
08:39:57 <EvanR> make a more descriptive type for your particular use case
08:40:11 <mbw> Still these isomorphisms, while neat, kind of got me on the wrong track where I tried to be "overly clever"
08:40:24 <lyxia> mbw: data T = T Int TField ; data TField = T1 String | T2 Double | T3
08:41:07 <mbw> But generally there is no one size fits all I assume?
08:41:07 <Akii> I've a transformer stack that returns Either a (b,c); totally will transform that into a data type next! thanks!
08:41:17 <EvanR> mbw: all?
08:41:21 <hackrilege> That's not encouraging me to investigate arrows much!
08:41:54 <mbw> A systematic way on how to construct the most suitable representation of data.
08:42:19 <EvanR> designing data structures isnt exactly a systematic thing
08:42:43 <EvanR> you have different things in your toolbox, each one took a Phd to invent
08:42:47 <mbw> I guess design will stay dirty, even in haskell
08:43:14 <EvanR> and then how to put the tools together takes practice
08:43:15 <mbw> by which I mean an iterative process
08:43:26 <e> <mbw> A systematic way on how to construct the most suitable representation of data.
08:43:29 <e> how could there be
08:44:00 <mbw> I merely meant some best practices
08:44:08 <EvanR> are you thinking of something like database design techniques?
08:44:31 <hackrilege> Factor out common higher order components, decompose into primes...
08:44:41 <geekosaur> hackrilege, yes, that's kinda the point :) arrows were an interesting early diversion, but 90% of their use cases are better handled by Applicative or Control.Category
08:44:55 <geekosaur> I think only some FRP implementations still use arrows
08:45:16 <geekosaur> and HXT because it was written when people still thought arrows were interesting >.>
08:46:00 <mbw> Nothing of that dimension. Like in my above in examples, there are always some pros and cons to a particular representation. I just don't have a clear grasp on what those pros and cons are and how to weight them. And I thought "someone must have said something clever about this".
08:46:26 <hackrilege> Seems a shame to discard such a body of work as uninteresting, I'm sure there are gems of insight, but I can accept they may be better expressed in some of the more recent approaches
08:46:52 <geekosaur> (arrow based parsing was thought to be a use for arrows once. then people realized they really wanted applicative parsers)
08:46:52 <EvanR> as far as haskell goes, just writing code will reveal some common rules of thumb, like not using (,,) (,,,) etc, rather make record types
08:47:21 <geekosaur> hackrilege, it is interesting in terms of history, basically.
08:47:41 <EvanR> of course, knowing when something is a list and when its a mapping table, or a record, or an array
08:47:57 <hackrilege> mbw, try not to reinvent the wheel, that's the criticism of Foldable if I understand correctly, since List can be used instead
08:47:59 <geekosaur> it helped shape applicatives and Control.Category, but in and of itself the `arr` combinator makes it annoyingly non-general
08:48:17 <EvanR> also haskell has a large number of numeric data types, which i think is great because each one has its own pros and cons
08:48:27 <EvanR> Double for everything is a sad state of affairs in some languages
08:49:24 <hackrilege> I understand Applicative, but what's up with Control.Category?
08:49:41 <EvanR> category is for things that can be composed
08:49:43 <EvanR> as in
08:49:45 <EvanR> :t (.)
08:49:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:50:04 <hackrilege> :t <*>
08:50:06 <lambdabot> error: parse error on input ‘<*>’
08:50:16 <geekosaur> :t (Control.Category..)
08:50:17 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
08:50:24 <polyguy> :t (<*>)
08:50:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:50:59 <hackrilege> I don't see why pure and <*> are not sugared away with something like do notation
08:50:59 <EvanR> (.) :: Category cat => cat b c -> cat a b -> cat a c
08:51:24 <geekosaur> hackrilege, ApplicativeDo extension... but it's not quite as simple as you think
08:51:25 <fosskers> hackrilege, they are with the ApplicativeDo language extension
08:51:32 <EvanR> id :: Category cat => cat a a
08:51:33 <fosskers> geekosaur, ;)
08:51:37 <geekosaur> also, there was some work on "idiom brackets"
08:51:49 <hackrilege> Woot, I like it when I find things like that!
08:52:03 <EvanR> idiom brackets seems more like what youre thinking of
08:52:14 <EvanR> i wonder why that didnt catch on 
08:52:26 <EvanR> maybe syntax extensions are suspcious to ghc people
08:52:31 <geekosaur> too much action at a distiance for my tastes
08:52:54 <geekosaur> (not that I can speak for anyone else)
08:53:14 <EvanR> i can only guess you dont like that it looks like function application
08:53:30 <EvanR> and you have to look at the edges to see its a different context
08:53:33 <hackrilege> Are they ready for use? My main priority is to communicate useful developments to my prof, no point my report containing obfuscation
08:53:36 <geekosaur> that it looks like function application while being something that isn't quite, yes
08:53:47 <mbw> This is reassuring. Having used Haskell for only a view months, from reading a lot of books and seeing how much work went into abstractions like Monads, Applicatives, Foldable/Traversable etc., you get the impression that you always should strive to write code as cleverly as possible. At least I find myself doing that, in hopes to gain some new "algorithmic insight" or something.
08:54:22 <EvanR> "write code as cleverly as possible" i think is the wrong way to go, and it becomes more important not to as you learn haskell
08:54:27 <geekosaur> (or rather, it is but it's also additional stuff going on)
08:54:43 <EvanR> haskell is great for being able to write code as dumb as possible and get somewhere
08:54:51 <EvanR> sometimes thats overlooked though
08:55:29 <t7> i have invented a purely functional language without garbage collection
08:55:33 <geekosaur> could see it being rephrased something like view patterns, but then you have pretty much the same syntax noise as Applicative, so.
08:55:35 <mbw> Well, after having read "this can be written more compactly like ..." for a few hundred times...
08:55:37 <t7> with a slight extension to linear types
08:55:44 <t7> kinda like rust
08:55:51 <t7> invest in my kickstarter?
08:55:58 <EvanR> mbw: if its a common pattern, factor it out, thats FP
08:56:25 <EvanR> special syntax gets in the way of that
08:56:26 <lyxia> hackrilege: ApplicativeDo is usable but still rough around the edges
08:57:13 <lyxia> hackrilege: that it's turned on for a whole file may be annoying when you're working with multiple instances of Applicative/Monad together.
08:57:17 <danilo2> Hello! Is there in Haskell any magic type that could have just any Kind? I've got some type alias like `Foo a b c` with free type variables and I want to put there just anything that matches their kind just to hide these variables from exposure in some type family aplication in type alias
08:57:24 <EvanR> mbw: a good example of cleverness to avoid is "pointless style", which when taken overboard leaves you with an unreadable mess of lambda calculus
08:57:49 <haasn> how long until we get native idiom brackets (| |) in haskell
08:57:59 <haasn> translating to do syntax, of course, which thanks to ApplicativeDo works for applicatives
08:58:06 <hackrilege> I feel like I have hit a bit of a wall, a lot of what was difficult when I was less experienced was baffling, and when I read my old code I feel like while I'm able to reduce the syntax and eliminate redundancy, this actually gives me less to report on. If my use case can omit use of lens, but I can only notice this once I understand lens, I don't feel the report is appropriate and I find myself searching for an excuse t
08:58:24 <t7> haasn: what is this idiom thing
08:58:38 <EvanR> f <$> x <*> y <*> z
08:58:42 <haasn> t7: (| f x1 x2 x3 |) translates to f <$> x <*> y <*> z
08:58:44 <EvanR> (| f x y z |)
08:58:50 <haasn> err x1 x2 x3 in my example not x y z
08:58:51 <mbw> I find myself doing that quite often...
08:58:59 <danilo2> I need it cause we do not have currently impredicative polymorphism and its just a dirty trick
08:59:00 <t7> gross
08:59:03 <haasn> it basically lets you left an arbitrary expression “into” an applicative
08:59:28 <EvanR> liftA3 f x y z
08:59:28 <t7> is it template haskell?
08:59:38 <haasn> no
08:59:45 <haasn> but you can implement idiom brackets using template haskell
08:59:50 <haasn> e.g. [i| f x y z |]
08:59:53 <haasn> but that's so ugly in comparison
09:00:09 <geekosaur> http://hackage.haskell.org/package/applicative-splice
09:00:12 <EvanR> thats quasi quoters
09:00:18 <lyxia> looks the same to me
09:00:23 <geekosaur> ^
09:00:38 <haasn> [i| f x |] is so much noise compared to (| f x |) but oh well :p
09:00:51 <EvanR> fmap f x
09:01:07 <iversen> Hey, I'm at a loss. I'm new to Haskell and am trying to make one function which takes an IO Int n, then sends that n to another function, which in turn asks for an IO Int n times. Ultimately I want those n Ints to be added and the sum returned. But I seem to be mixing IO and non-IO types in ways that is not allowed. For example, I send my n from the first function to the helper function intReader' :: Int ->
09:01:09 <iversen> IO Int. There I want to loop n times, each time adding a new Int x to the total sum. Like this: return ((read x :: Int) + intReader2' (n-1)). But the compiler tells me I can't use + on an IO Int. So I'm wondering how I can add IO Ints by using this recursive call? 
09:01:10 <haasn> and [appl| is even worse
09:01:52 <EvanR> IO Int isnt an Int so you cant add them
09:01:53 <geekosaur> iversen, >>= or do notation
09:02:28 <geekosaur> ...or fmap for one-offs
09:03:05 <iversen> geekosaur, I used the do notation like this:
09:03:07 <monochrom> iversen, you may need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
09:03:12 <iversen> intReader2' n =  do
09:03:15 <iversen>                     x <- getLine
09:03:17 <iversen>                     if n > 0 then
09:03:19 <iversen>                         return ((read x :: Int) + intReader2' (n-1))
09:03:21 <iversen>                     else
09:03:23 <iversen>                         return 0
09:03:24 <geekosaur> @paste
09:03:24 <lambdabot> Haskell pastebin: http://lpaste.net/
09:03:50 <geekosaur> and yes, the proble,m is you need to use <- for the recursive call as well
09:03:56 <iversen> monochrom, thanks, I'll check it out
09:04:02 <mbw> Regarding readability: I also often try to convert do notation to applicative style, for reasons stated above, and also because I assumed that I would make some degree of parallelism explicit "for potential later use". Of course it can become less readable than do notation. Is this also something that should only be done if needed?
09:04:38 <geekosaur> if n > 0 then do { n' <- intReader2' (n - 1); return ((read x :: Int) + n') } ...
09:04:47 <EvanR> i find liftA3-ish application very readable
09:05:19 <monochrom> "readable" is a moving target
09:05:27 <hackrilege> Perhaps I'm just frustrated that I will need to both learn and then report on template Haskell before I can do the same with lenses. It's quite far removed from discussing the actual algorithm, but I guess it's a significant enough aspect of functional programming to justify such attention
09:05:43 <haasn> well for example compare (| f x + g y |) versus (+) <$> f x <*> g y  or liftA2 (+) (f x) (g y)
09:05:53 <haasn> both add syntactical noise that you then have to first deconstruct
09:06:06 <EvanR> liftA2 (+) (f x) (g y)
09:06:31 <mbw> Exactly. When I ned to refactor, I find myself converting back to do/let statements at some point.
09:06:41 <haasn> or, say, (| 3*sin + 5*cos |)  :p
09:06:51 <haasn> although to be fair that could just be a Num instance
09:06:54 <EvanR> not convinced of the utility
09:06:55 <Welkin> expressions, not statements
09:07:07 <geekosaur> and that last example is where I start becoming annoyed
09:07:10 <EvanR> haasn: actually, i have been advised to NOT use Num
09:07:18 <Welkin> what's with the banana quotes?
09:07:19 <EvanR> use liftAN
09:07:56 <EvanR> however for complex numbers or vectors, you should just use the linear algebra operators
09:08:11 <EvanR> well complex numbers already are Num
09:08:17 <nurfed_> Is there any way to force a variable starting with a capital letter?
09:08:21 <geekosaur> and no, please don't use a Num instance, it's even more confusing *and* invites the compiler to treat typos as something you didn't expect
09:08:35 <geekosaur> nurfed_, see end of /topic
09:08:57 <c_wraith> the topic now covers the ctf?
09:09:00 <nurfed_> geekosaur: lol
09:09:01 <Welkin> we have a haskell ctf?
09:09:03 <Welkin> since when?
09:09:09 <c_wraith> we don't
09:09:11 <monochrom> yesterday
09:09:26 <glguy> We don't, but someone does. All the people doing it come here to learn how to
09:09:29 <geekosaur> https://33c3ctf.ccc.ac/ and this is actually the 3rd day of people popping in and asking that :)
09:09:43 <MarcelineVQ> danilo2: I don't know enough about that space to have a useful answer, but be sure to check out -XPolyKinds or -XTypeInType in case there's an answer there. one example that matches any Kind I can think of is, type Foo x = x with PolyKinds on
09:10:26 <nurfed_> geekosaur: haha I didn't see that one coming. thnx :P
09:12:48 <Hyke> good evening fellas
09:12:50 <iversen> geekosaur, thanks, using <- for the recursive call did the trick! I'm still a bit confused by the whole IO thing though.
09:13:14 <geekosaur> [29 17:02:46] <monochrom> iversen, you may need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
09:13:34 <Hyke> is this channel still active?
09:13:41 <hackrilege> No
09:13:44 <lyxia> We're all bots.
09:13:49 <Hyke> ahaha
09:14:14 <monochrom> what is "channel"?
09:14:15 <Hyke> friendly people, i see
09:14:23 <Hyke> a brand
09:14:37 <monochrom> like Chanel?
09:14:41 <Hyke> yeah
09:14:56 <haasn> iversen: ‘IO Bool’ is not the same thing as ‘Bool’; if your function is f :: Int -> IO Bool, you can't write “foo && f 3”, the ‘f 3’ call has type IO Bool
09:15:07 <byorgey> I saw an advertisement for Channel No. 5, how do I join it?
09:15:11 <haasn> that's, basically speaking, why your program failed to type check
09:15:16 <mbw> Is there some actual literature on "Haskell code smells"?
09:15:21 <glguy> byorgey, monochrom: if you need help with IRC, try #freenode
09:15:25 <Hyke> now seriously
09:15:47 <Hyke> anyone willing to teach me a couple of tricks with rubber ducky? just bought one
09:15:54 <hackrilege> It's an expensive drink
09:16:06 <Cale> nurfed_: Variables and data constructors are kept syntactically separate by insisting that variables start with a lowercase letter and data constructors with an uppercase one, so that when matching a pattern it is easy to distinguish which parts are variables to be bound, and which parts are data constructors to be matched.
09:16:28 <haasn> nurfed_: the closest you can do is use _Foo as your variable name
09:16:32 <EvanR> unless you do shit like X = X
09:16:39 <EvanR> at the top level
09:16:39 <byorgey> Hyke: wat?  This is a channel for discussing the Haskell programming language: http://www.haskell.org
09:16:47 <glguy> EvanR: I hate the name X, too
09:17:00 <Hyke> ups talking in the wrong one ahah
09:17:18 <Clint> ...
09:17:27 <mbw> I thought it was an oop joke
09:17:41 <hackrilege> lol
09:17:42 <MarcelineVQ> man, I gotta know, what channel similar to haskell has rubber duckies
09:17:50 <haasn> F#
09:18:01 <EvanR> rubber duck programming
09:18:35 <monochrom> rubber duck also refers to explaining your question to a rubber duck so you organize your thought and get closer to thinking up an answer.
09:19:13 <MarcelineVQ> the things people come up with :>
09:19:15 <haasn> I thought the universally accepted method of doing that was explaining it to your cat
09:19:27 <byorgey> any inanimate object works
09:19:28 <haasn> Then again, some people are weird and don't have cats
09:19:39 <haasn> Any animate object works too
09:19:41 <Welkin> most people don't have cats
09:19:42 <Welkin> o.o.
09:19:44 <sm> haasn: https://en.wikipedia.org/wiki/Rubber_duck_debugging
09:20:02 <byorgey> haasn: animate objects are more likely to walk on your keyboard though
09:20:04 <monochrom> Most people have computers so they use IRC instead.
09:20:15 * sm thinks rubber ducks are much better at this than cats
09:20:31 <monochrom> Philosophy question of the day: Is IRC an animate object or an inanimate object?
09:20:32 <Welkin> use a plant
09:20:35 <mbw> huh
09:20:36 <Welkin> talk to the trees
09:20:43 <MarcelineVQ> irc is vibrating sand
09:20:51 <haasn> monochrom: misleading question, “Is IRC an object”?
09:21:01 <mbw> I was looking for a technical term for debugging openMP thread races. Thanks
09:21:03 <MarcelineVQ> though, when I ​have a problem big enough to annoy other people with I just ask about it. there's not a lot of problems that size though
09:21:48 <sm> actually, here's the proper link: http://www.rubberduckdebugging.com
09:21:49 <byorgey> monochrom: I reject your Law of Excluded Middle-inspired question
09:22:13 <meoblast001> hi. with cabal (1.24.0) when i do "add-source" i get "unrecognised command: add-source"
09:22:14 <haasn> monochrom: also, programmer answer of the day: yes
09:22:38 <haasn> meoblast001: cabal sandbox add-source
09:22:39 <meoblast001> the exact command is $ cabal add-source ~/Development/paypal-rest-client/
09:22:44 <glguy> meoblast001: did yout forget "sandbox" ?
09:22:50 <meoblast001> oooh. thanks!
09:22:50 <byorgey> meoblast001: you want 'cabal sandbox add-source'
09:23:03 <meoblast001> somehow i missed that word in the documentation
09:23:04 <meoblast001> thanks
09:24:10 <hackrilege> So in a comonadic zipper context I can spawn multiple parallel processes, is this faster? Suppose I increment each element if a list with the average the n nearest neighbours, I could traverse the list and fork the thread at each element, but I don't know how to rationalise the cost of the information gather and distribution
09:27:18 <haasn> hackrilege: how is your zipper implemented? regular lists? or indexable vectors with an associated index?
09:27:53 <MarcelineVQ> that's the kind of question that invites questions instead of answers
09:27:53 <haasn> in the latter presentation you could parallellize your ‘extend’ without much o verhead
09:27:53 <haasn> and if you're going for performance that ought to be better to begin with
09:28:11 <hackrilege> The situation becomes more involved in a cyclic graph where the context cannot be updated until the full traversal had been complete, because a branch may close at an element not visited until later in the traversal
09:29:34 <hackrilege> I'm using trees rather than lists, and the zipper is a pair of forward and backward trees
09:30:07 <chasebase> new haskeller here stuck on the silliest thing involving type casting and strings
09:30:27 <hackrilege> Perhaps with something to store unsatisfied closed branches to be updated as the relevant element is accessed during traversal
09:30:56 <geekosaur> "type casting" is not a thing. so, what are you trying to do?
09:31:14 <hackrilege> I guess I should prepare a paste. I have a compiler note which should help!
09:31:21 <hackrilege> Now*
09:33:11 <chasebase> type conversion then?  i am using blaze-svg and have got my program working but one of the lines uses a constant, and i can't successfully replace it with a variable because i'm using an Int and it wants some type I have no idea how to construct from an int
09:33:13 <chasebase> svgDoc (x,y) = S.docTypeSvg ! A.version "1.1" ! A.width "400" ! A.height "400" $ do
09:34:02 <geekosaur> fromIntegral may be your friend
09:34:17 <chasebase> when i try to replace the "400" with my variable baseScale the errors start.  I've tried (show baseScale) and importing Data.Text, trying to pack to get it into a type that will work.  
09:34:32 <chasebase> ah fromIntegral.. that has saved my ass before will try now
09:34:41 <glguy> fromIntegral won't do: Int -> Text
09:36:35 <chasebase> when i replace "400" with (fromIntegral baseScale) the error is No instance for (Num S.AttributeValue) arising from a use of `fromIntegral'
09:37:09 <chasebase> i don't even understand what I need to study to get this... frustrating for noob who has seemingly made harder stuff work
09:37:43 <glguy> You can look in the documentation for what an AttributeValue is and what operations are available to construct one
09:37:44 <glguy> https://hackage.haskell.org/package/blaze-markup-0.7.1.0/docs/Text-Blaze-Internal.html#t:AttributeValue
09:38:01 <glguy> There are lots of ways to make one
09:39:10 <chasebase> glguy, i have done that and A.width is such a constructor, there is no general AttributeValue constructor.  
09:39:48 <glguy> No, A.width expects an attributevalue argument
09:40:07 <chasebase> right so from your link toValue is the constructor? 
09:40:07 <glguy> You can see that looking at the documentation here: https://hackage.haskell.org/package/blaze-svg-0.3.6/docs/Text-Blaze-Svg11-Attributes.html#v:width
09:40:25 <glguy> and then when you click on "AttributeValue" on that page it takes you to my link
09:41:01 <glguy> There's a second called "Converting values to attribute values."
09:41:09 <glguy> section*
09:42:47 <chasebase> glguy got it so I need textValue it looks like
09:43:02 <chasebase> thanks much i was trying to read source and getting lost
09:43:21 <chasebase> so would "type converstion" be appropriate term since someone said type casting wasn't?
09:43:57 <glguy> There's not really any term, you just need a function with the right type. Most functions have different types in their arguments and results
09:44:10 <glguy> so:    stringValue . show :: Int -> AttributeValue
09:44:31 <geekosaur> yes. (when people say "type casting" they are usually trying to use type ascriptions as casts, like C does. but (x :: Text) will not cause an x of type Int to be converted to a Text)
09:45:39 <EvanR> (x :: Text) means x has type Text, if it doesnt, then its an error
09:46:25 <EvanR> i say "conversion" for stuff like T.pack, fromIntegral
09:48:01 <chasebase> glguy thanks and your explanation makes sense.  blaze-svg uses overloaded strings and TExt internally so i jsut came up with this (compiles)
09:48:02 <chasebase> svgDoc (x,y) = S.docTypeSvg ! A.version "1.1" ! A.width (S.textValue . T.pack . show $ baseScale) ! A.height "400" $ do
09:48:50 <chasebase> should i worry about this, or should i worry if i do the same thing more than once later on?  using Overloadedstrings if that matters
09:49:57 <geekosaur> if you're doing it often, just define     toA = S.textValue . T.pack . show     and use (toA baseScale) or whatever
09:50:49 <chasebase> geekosaur I understand the helper function, what i wonder if i should bother routing for text.  in principle efficiency doesn't matter in this program but i hear builtin strings are slow and good to learn working around
09:51:24 <chasebase> i mean routing "through Data.Text" myself, or just let library do it's own internal conversions
09:51:46 <k0ral> Hello
09:51:58 <chasebase> versus using glguy's example using builtin strings?
09:54:11 <k0ral> how can one write a concurrent program within a `MonadFree f m` monad, given that `FreeT` isn't a `MonadTransControl` instance ?
09:54:56 <geekosaur> chasebase, might use http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Read.html to skip the String intermediate, but (a) for short Strings it's hardly worth worrying about (b) this has its own overhead
09:56:09 <chasebase> perfect thanks so much.  can't believe i got through my first monadic composition bugs on my own and this is what stumped.  you guys are the best!
10:00:01 <t7> mapM is traversable now?
10:00:09 <t7> was it never only for list?
10:01:03 <Cale> k0ral: Perhaps one can't? You could devise your functor f to have a constructor which served as an explicit analogue to forkIO
10:01:04 <geekosaur> https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/base-4.7.0.2/Control-Monad.html#v:mapM
10:01:30 <t7> man i havnt written any haskell for years
10:01:32 <t7> this is fun
10:01:36 <t7> stack is cool too
10:04:54 <t7> whats the idiomatic way to write this: fmap (Set.delete y) (free e)
10:05:22 <EvanR> like that
10:05:36 <k0ral> Cale: hasn't that area been explored already ? am I to roll my own ad hoc solution ?
10:05:38 <geekosaur> or: Set.delete y <$> free e
10:05:39 <Ferdirand> maybe with fmap = <$> ?
10:06:38 <EvanR> fmap is easier to type and is less likely to cause noobs reading the code to complain about haskells huge array of esoteric operators
10:07:01 <EvanR> and using <$> like that feels like "using operators for the hell of it"
10:08:11 <fsestini> guys do you know of any library like compdata that works by composing bifunctors instead of plain functors? (or perhaps a way to adapt compdata to this)
10:09:55 <t7> @hoogle Bool -> b -> m b ()
10:09:58 <lambdabot> HIndent.Pretty withCaseContext :: MonadState (PrintState s) m => Bool -> m a -> m a
10:09:59 <lambdabot> Control.Concurrent.Async.Lifted race_ :: MonadBaseControl IO m => m a -> m b -> m ()
10:09:59 <lambdabot> Control.Concurrent.Async.Lifted.Safe race_ :: (MonadBaseControl IO m, Forall (Pure m)) => m a -> m b -> m ()
10:11:03 <t7> i wanna do sequential tests with early failure
10:11:07 <t7> in a do block
10:11:27 <t7> if test then Left "my error" else return ()
10:11:35 <geekosaur> MaybeT or EitherT?
10:13:06 <geekosaur> I guess ExceptT these days
10:15:43 <monochrom> I am not "use operators for the hell of it" per se. But I am sometimes "use infix for the hell of it".
10:16:06 <haasn> “avoid parens at all costs”
10:16:09 <monochrom> And only sometimes. Because the other times I am "use prefix for the hell of it"
10:16:34 <Lokathor> http://lpaste.net/350616 am i missing some C file that I need?
10:16:36 <haasn> t7: sounds like you want ExceptT yeah
10:16:46 <t7> i will have a look
10:16:48 <haasn> or perhaps even ContT
10:16:49 <monochrom> Generally I write code for the hell of it, and there are only two choices, infix or prefix. I have to choose one for the hell of it anyway.
10:18:03 <monochrom> ExceptT is simpler. ContT is more work (because it is more flexible).
10:18:11 <EvanR> avoid parens at all costs is also silly
10:18:34 <monochrom> I know how to avoid parens at all costs for the hell of it, too.
10:19:12 <monochrom> For each function, prepare 18 versions of it, one version for one fixity declaration.
10:19:18 <geekosaur> Lokathor, did you build bindings-GLFW on that machine?
10:19:50 <monochrom> For example, addition: infix 4 ....+.... ; infixr 4 ....+; infixl 4 +....
10:20:09 <geekosaur> if not, I would guess that you have version skew between whatever it was built on and your current machine (at the msys/mingw/whatever glibc level)
10:20:33 <Lokathor> uhm, hmm
10:20:50 <monochrom> Then you will never need to write "(x+y)*z" again. You write "x .+. y ...*..." or something.
10:21:11 <geekosaur> and to think they invented typeclasses to get away from ancient SML
10:21:14 <geekosaur> s .+ :p
10:21:26 <Lokathor> geekosaur, adding bindings-GLFW to the cabal file gives the same error, so I assume that bindings-GLFW is already built from GLFW-b depending on it
10:22:18 <geekosaur> already built from something, anyway. but it expects a symbol that is normally provided by libc, and which yours doesn't
10:25:13 <monochrom> I actually got my idea from Roland Backhouse's mathspad. Of course his is serious whereas mine is hilarious.
10:26:23 <monochrom> mathspad does not say "each operator has 18 versions". Each operator has only one precedence level. No different from convention.
10:27:23 <monochrom> But how much space is inserted around an operator in an expression is computed from how far its node, in the abstract syntax tree, is from the leaves.
10:28:08 <monochrom> So for example "x+y*z" mathsapd displays that with a little more space around + than around *. This is to remind you visually how tightly the operators bind.
10:28:35 <rdococ> x  +  y * z
10:29:38 <monochrom> Now, it is a GUI and it enjoys pixel-level spacing, so "more space" can be just 2 more pixels rather than the very coarse and brute and blunt "one more space character". (Plain text files die die die.)
10:30:06 <Sonolin> I read an article about documenting code that way - makes reading formulas much more pleasant
10:31:24 <Lokathor> geekosaur, https://github.com/bsl/bindings-GLFW/issues/48 seems i simply cannot build the LTS version of the package
10:32:36 <MaybeBom> in gloss if u have a list like "pct" how do u say that p need to be on a certain position and how can you put BMP together and scale them because im having errors
10:32:50 <Cale> monochrom: In the early days of mathematics notation, something like what you're suggesting was actually used -- with dots placed over things in order to indicate that they bind more weakly.
10:33:14 <Lokathor> GHC 8.0.2: Release candidate by mid-October 2016.     Me: :(
10:34:06 <monochrom> But I prefer putting dots around, horizontally, to take up space :)
10:34:38 <EvanR> colors yall
10:34:42 <EvanR> colors
10:34:46 <monochrom> x .....+..... y * z helps you see "the x is so far away..."
10:35:25 <implementation_> so would explicit parentheses: x+(y*z)
10:35:45 <geekosaur> 8.0.2 ran aground on Sierra and Xenial issues
10:35:48 <EvanR> dont be so modern
10:36:09 <geekosaur> I think rc2 is out now? and hoping to release shortly after new years
10:36:46 <monochrom> Yes RC2 was out in celebration of Boxing Day Sale.
10:37:27 <Cale> Parentheses also beat out the convention of using an overline or "vinculum" (in everything apart from nth roots for some reason) just because they were easier to typeset.
10:38:31 <NextHendrix> i have a list of records, and am trying to print the record with the highest of one parameter
10:38:36 <monochrom> I support parentheses but you need more of them for fillers. x+(((((y*z))))) :)
10:39:08 <monochrom> @type maximumBy
10:39:09 <Cale> NextHendrix: maximumBy (comparing someField)
10:39:10 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
10:39:20 <monochrom> yeah
10:39:24 <Cale> comparing is from Data.Ord
10:39:27 <NextHendrix> ah
10:39:32 <NextHendrix> i was fiddling with compare
10:39:32 <geekosaur> :t maximumOn
10:39:33 <lambdabot> error:
10:39:33 <lambdabot>     • Variable not in scope: maximumOn
10:39:34 <lambdabot>     • Perhaps you meant one of these:
10:39:36 <geekosaur> bah
10:39:45 <Cale> comparing p x y = compare (p x) (p y)
10:39:55 <byorgey> ... = compare `on` p
10:39:58 <NextHendrix> in fact i was just about to head down a gorrible convoluted rabbit hole with elemIndex
10:40:08 <NextHendrix> *horrible
10:41:08 <Cale> Since it's a field extraction, there's no point, but in case you wanted to compare on some function which was more expensive, you might consider pairing the elements with the result of that function beforehand, so as to avoid recomputing it.
10:41:31 <Cale> (and then you could use the standard maximum function on pairs, or comparing fst)
10:42:24 <MaybeBom> is there someone that understand some gloss, because im having some errors when trying to put BMP
10:42:52 <Cale> MaybeBom: Sure... what errors?
10:44:35 <MaybeBom> so i have a function and the start point to put BMP is (x,y)=(-300,300), and it goes incresing my x and when i got to a certain point it comes back to -300 but decreases my y, like a chess table
10:45:08 <MaybeBom> but when im on the first one i did like Translate x1 y1 (Scale t t p)
10:45:23 <MaybeBom> where p = Pictures [chao,pedra]
10:46:32 <MaybeBom> it says that's not picture type but Pictures puts it at picture type
10:46:44 <shapr> Just Bom
10:48:30 <monochrom> No no no shapr, the values of Maybe BOM are Just BigEndian, Just LittleEndian, and Nothing.
10:49:59 <shapr> monochrom: tudo bom?
10:50:38 <Cale> MaybeBom: Can you put the code and error you're getting on lpaste.net?
10:51:46 <Cale> MaybeBom: The part that you described sounds fine to me, unless chao or pedra are not of type Picture.
10:53:18 <lpaste> MaybeBom pasted “Gloss” at http://lpaste.net/350619
10:53:48 <MaybeBom> the code is awful i now but im trying just to get something out of gloss
10:53:53 <MaybeBom> know*
10:55:15 <MaybeBom> i=0,(x1,y1)=(-300,300),t=600/dimension of map, d = dimension
10:56:25 <dfeuer> Hi Cale!
10:56:32 <dfeuer> How lazy should munzip be for Data.Tree?
10:58:51 <miscyb>  i'm trying to use sourceHandle from conduit-extra and it's causing a strange type error. When trying to use a type "MonadIO m => Handle -> Producer m ByteString", I get the error "Illegal polymorphic type: Producer m ByteString".
10:58:57 <miscyb> anyone know what that means?
11:00:31 <lyxia> miscyb: what are you doing with a value of that type
11:01:13 <miscyb> lyxia: i'm creating a conduit source using sourceHandle
11:01:16 <lyxia> this is an error you can get when trying to put a polymorphic type in a container
11:01:22 <miscyb> https://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Binary.html
11:01:31 <miscyb> is the package with that function
11:01:51 <lyxia> can you paste your code
11:01:53 <miscyb> https://github.com/mr/ftp-client/blob/master/ftp-conduit/src/Network/FTP/Client/Conduit.hs
11:02:01 <miscyb> this file has the interesting stuff
11:03:25 <miscyb> ideally this function would be at the top of a runConduit chain
11:03:27 <lyxia> Oh. because Producer is a polymorphic type
11:03:39 <lyxia> Turn on RankNTypes 
11:03:55 <miscyb> lyxia: alright i guess i'll have to read what that does
11:06:05 <miscyb> lyxia: that fixed it thanks
11:06:10 <lyxia> yw
11:11:14 <ysangkok> i can't find <&> in hoogle...
11:11:44 <ysangkok> it is used here https://github.com/lamdu/lamdu/blob/master/Lamdu/Main.hs#L139
11:13:37 <sm> http://hoogle.haskell.org/?hoogle=%3C%26%3E
11:14:46 <kuribas> :t (<&>)
11:14:47 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:15:21 <ysangkok> ah, i tried https://www.haskell.org/hoogle/?hoogle=%3C%26%3E
11:15:32 <kuribas> ysangkok: it's from lens
11:16:02 <implementation_> @src (<&>)
11:16:02 <lambdabot> Source not found. stty: unknown mode: doofus
11:16:10 <NextHendrix> are there any types where deriving Eq doesn't make sense
11:16:20 <EvanR> yes
11:16:22 <ysangkok> i didn't realize there were two hoogle deployments under haskell.org
11:16:27 <ysangkok> thanks everyone
11:16:41 <EvanR> NextHendrix: you cant derive Eq if the constituents arents Eq themselves
11:17:28 <kuribas> NextHendrix: functions
11:17:32 <implementation_> newtype Foo = Foo (Bar -> Bar)
11:17:57 <EvanR> newtype Foo = Foo (Parser Bar)
11:18:00 <EvanR> newtype Foo = Foo (IO Bar)
11:18:20 <EvanR> any abstract type without Eq
11:18:44 <NextHendrix> good point, i didn't think that deep
11:18:50 <Guest11705> Hey #haskell!
11:18:58 <EvanR> another one is real numbers
11:19:04 <wilornel> I am trying to get used to stack
11:19:25 <NextHendrix> my only real thought was "obviously you can't order some things, but its always obvious when two things are the same whatever they are"
11:19:33 <EvanR> no matter how you define them, it doesnt make sense to derive Eq because theres no decidable equality test
11:19:39 <wilornel> I did `stack new simple` and have added a simple `import HSP` line to the generate src file in simple
11:20:14 <wilornel> I have modified simple.cabal and stack.yaml to have happstack-7.3.8
11:20:35 <sm> wilornel: I don't think HSP comes from that package, check the api on hackage
11:20:37 <wilornel> I can stack build and stack exec simple-exe and it works, I get to run the src file
11:20:47 <EvanR> NextHendrix: if you are given two mathematical expressions, is it obvious if they are equal (via some manipulations or identity)
11:20:50 <wilornel> However! 
11:20:53 <sm> oh. never mind.
11:21:22 <wilornel> I CAN run `stack ghci` outside of that project. Say for example in ~. BUT, if I go inside simple and try to run `stack ghci`, I get
11:21:40 <wilornel> The following package identifiers were not found in your indices: happstack-7.3.8
11:21:43 <wilornel> Warning: build failed, but optimistically launching GHCi anyway
11:21:45 <wilornel> The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
11:21:54 <wilornel> and ghci does not launch
11:22:12 <wilornel> Now, I saw this issue opened (and closed) by bitemyapp: https://github.com/commercialhaskell/stack/issues/533
11:22:25 <wilornel> I think my issue is similar. However, I do not understand his fix
11:24:16 <wilornel> Is anybody out there?
11:24:20 <geekosaur> not similar, bitemyapp's was a package issue and yours is a (weird, since ghci is always -threaded) command line option
11:24:36 <wilornel> hmmmm
11:24:58 <wilornel> Oh! It also says:
11:24:59 <wilornel> GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
11:24:59 <wilornel> <command line>: cannot satisfy -package happstack-7.3.8 (use -v for more information)
11:25:08 <wilornel> I was relunctant to paste too many lines into irc
11:25:47 <EvanR> lpaste for large pastes
11:25:54 <geekosaur> @paste your stack.yaml ?
11:25:54 <lambdabot> Haskell pastebin: http://lpaste.net/
11:26:58 <wilornel> http://lpaste.net/3762991229378232320
11:27:48 <Cale> MaybeBom: oh, sorry, was distracted for a bit there...
11:28:11 <Cale> MaybeBom: It's the (++) which makes it see that as a list.
11:28:30 <Cale> MaybeBom: Perhaps you meant to use (:)
11:28:56 <MaybeBom> oh.. thx i'll check that, and when the map finishes
11:29:40 <MaybeBom> like i have no stop case on that because i dont know what Picture can be when map is over
11:30:17 <geekosaur> wilornel, there is no happstack-7.3.8. did you mean happstack-server-7.3.8?
11:30:44 <wilornel> And here is stack.yaml: http://lpaste.net/56298263812243456
11:30:51 <geekosaur> otherwise, if you have one obtained from elsewhere, you need to flag it as such
11:31:00 <wilornel> (gotta brb in ~1hour)
11:31:04 <wilornel> I see!
11:31:07 <wilornel> Thanks for the notice
11:31:24 <wilornel> I think stack was suggesting happstack-7.3.8 before I added it to stack.yaml
11:31:26 <geekosaur> happstack package got split up after 7.0
11:33:34 <geekosaur> probably you just have to make that change from happstack-7.3.8 to happstack-server-7.3.8
11:33:51 <MaybeBom> Cale, it's still wrong... Couldn't match expected type ‘Picture’ with actual type ‘[Picture]’
11:37:20 <Cale> MaybeBom: Well, in which expression?
11:37:59 <MaybeBom> on the translate thing
11:38:22 <MaybeBom> and on the follow one : desenhaMapaAux...
11:39:45 <Cale> MaybeBom: Oh, well, your type signature claims that desenhaMapaAux will produce a Picture
11:39:46 <MaybeBom> i need to get a Picture at the end of this function will all the bmps
11:39:52 <MaybeBom> yes
11:40:01 <Cale> But if the result is something of the form x : xs, then that is a list, clearly.
11:40:25 <MaybeBom> Yeap, gloss is killing me right now
11:41:59 <Cale> Perhaps do the following:
11:42:12 <Cale> 1) Define a function Char -> Picture which explains how to draw a single thing
11:43:03 <Cale> Skip the translation and scaling there, just handle choosing the appropriate combination of chao and other things...
11:43:16 <MaybeBom> okay,i'll do that
11:44:26 <Cale> 2) Construct the list of type [(Float, Float)] of positions to which you're going to translate the pictures
11:44:54 <Cale> 3) Use a list comprehension and zip, or map and zipWith, to put everything together, and obtain a list of translated and scaled pictures.
11:45:06 <Cale> 4) Apply the Pictures data constructor to that to get a combined image.
11:46:02 <Cale> The idea being that you can map the function Char -> Picture over your list of Char values to obtain a list of unscaled, untranslated versions of the pictures you want to have, and then lay those out in a grid separately
11:46:35 <Cale> You shouldn't need to write anything recursive
11:47:53 <chasebase> hi i wrote a recursive function to build up a list of SVG Paths returning a monad of type S.Svg from blaze-svg.  i think it would work if i could figure out how to write the dang bang case.  there doesn't seem to be a way to return 
11:48:21 <chasebase> to return "nothing" that is, or apply an identity function is what i need
11:49:32 <chasebase> so i'm writing mkPentagonList :: [CairoCoords] -> S.Svg, have mkPentagonList ((x,y):zs) working but can't figure how to code mkPentagonList [] =
11:49:58 <geekosaur> @paste
11:49:59 <lambdabot> Haskell pastebin: http://lpaste.net/
11:50:22 <geekosaur> will be easier to understand what you're asking with actual code for what you have so far
11:51:58 <chasebase> thanks for lpaste, http://lpaste.net/7936460574953570304 I need to add a base case to the function shown 
11:53:01 <chasebase> so my first thought was return "nothing" markup but I don't see any constructor that does that.  my next thought was just return the monad context unchanged somehow but not sure how
11:54:19 <chasebase> thinking also i could do some fancy pattern matching to avoid having a [] base case maybe
11:54:26 <geekosaur> http://hackage.haskell.org/package/blaze-markup-0.7.1.0/docs/Text-Blaze-Internal.html#t:MarkupM
11:54:43 <geekosaur> Svg is a type alias for that, and it has a constructor Empty
11:55:44 <chasebase> ha i got as far as looking at that library and missed it.  and i almost tried like wrapping in an Empty monad or something.  anyhow that's clearly the ticket, i will try reading docs even more next time
11:56:51 <geekosaur> actually that looks like it would be a bad idea
11:57:13 <geekosaur> it will probably dislike anything not created by S.docTypeSvg
11:57:56 <chasebase> yeah Empty isn't exported
11:59:27 <geekosaur> oh
11:59:30 <geekosaur> return ()
11:59:35 <chasebase> geekosaur S.docTypeSVG is like the root node combinator.  Svg just an alias for MarkupM might there be a way to translate 
11:59:36 <geekosaur> because Markup = MarkupM ()
11:59:45 <chasebase> ok that makes sense will try
12:00:20 * geekosaur was misled by M suffix often indicating a specific type of monad transformer...
12:01:00 <chasebase> aand it compiles, thanks again
12:01:17 <chasebase> hopefully i can make just not one funky pentagon now but a cairo pentagonal tiling!!
12:01:53 <dfeuer> Silly computer.
12:01:58 <dfeuer> Ping Cale.
12:03:47 <dfeuer> Anyway, I was looking for help with MonadZip instances.
12:04:02 <dfeuer> Trying to figure out how strict they should be for Data.Sequence and Data.Tree.
12:04:23 <dfeuer> munzip, specifically.
12:15:03 <shapr> dfeuer: I heard that had patent problems, and we now use munzip2
12:15:14 <dfeuer> shapr, PFFFF
12:15:16 <shapr> :-)
12:15:33 <dfeuer> shapr, but really, the strictness is ... hard to choose.
12:15:57 <shapr> ask on the mailing list maybe?
12:16:56 <dfeuer> For Data.Sequence, especially, where the well-behaved implementation has strange strictness properties that make it a Bad Idea to use it if the sequence has any undefined elements.
12:17:07 <dfeuer> Yeah, I'll ask the mailing list.
12:17:20 <shapr> Wait, what's that about Data.Sequence?
12:17:34 <shapr> finger trees have strange strictness properties?
12:18:37 <dfeuer> shapr, well, yeah. I think the answer is almost certainly to be a little lazier than I wanted.
12:18:42 <dfeuer> With Data.Sequence.
12:18:48 <dfeuer> I think my hand is pretty much forced.
12:18:58 <shapr> then it won't be lazy!
12:19:10 <dfeuer> Har dee har.
12:19:21 <shapr> I should get more sleep tonight so I can contribute actual content to #haskell 
12:19:32 <dfeuer> I'll have to fill the result sequence entirely with thunks, which I hate.
12:19:36 <shapr> Mind you, I've been having fun reading about finger trees and stuff today
12:19:40 <dfeuer> Unless I'm willing to have weird strictness properties.
12:21:25 <dfeuer> Yeah, I think it's probably not worth trying to be stricter... 
12:21:45 <dfeuer> Marginal likely performance benefit, and weird semantics.
12:22:44 <dfeuer> It's pretty stupid that MonadZip even is a Monad thing. It really should be FunctorZip.
12:24:59 <shapr> dfeuer: submit a proposal
12:25:08 <dfeuer> That's an invasive change.
12:25:16 <shapr> dfeuer: put up a PR for protolude or something and see if anyone complains?
12:25:24 <dfeuer> protolude?
12:25:32 <shapr> smdiehl's prelude replacement
12:25:55 <shapr> dfeuer: https://github.com/sdiehl/protolude
12:26:05 <yushyin> so many preludes nowadays
12:26:32 <shapr> yushyin: I think that matches Haskell's exploratory approach
12:26:41 <shapr> yushyin: do you think there are too many?
12:26:47 <geekosaur> ands then there's
12:26:52 <geekosaur> @hackage fugue
12:26:52 <lambdabot> http://hackage.haskell.org/package/fugue
12:27:26 <dfeuer> shapr, I'm not sure. MonadZip is a bit weird.
12:30:57 <ertes> dfeuer: i agree, and it's not just MonadZip
12:31:02 <ertes> MonadFix should be FunctorFix
12:31:38 <geekosaur> I think both of those predate AMP, so Functor would have limited their usefulness?
12:31:54 <geekosaur> (we're still paying for history...)
12:32:22 <shapr> put up a PR for protolude and see if it starts a discussion?
12:32:55 <yushyin> shapr: No I think it is ok because it will be still my choice which prelude I use.
12:33:17 <shapr> yushyin: which one(s) do you use?
12:36:39 <ertes> geekosaur: we'll always be paying for history as we learn new, better ways of doing things…  as long as we don't lock ourselves into the past in the name of backward compatibility as most languages seem to do
12:37:06 <lucca> is there a way to use a typeclass as the type in an instance specification, e.g. instance Class1 Class2 where ..., or am I asking for something foolish?
12:38:18 <geekosaur> not like that and it wouldn't do what you wanted anyway
12:38:55 <lucca> hm, ok
12:38:55 <lyxia> lucca: what is that for
12:39:00 <geekosaur> instance Class2 m => Class1 m where ... -- BUT! this will match all types, and check for Class2 only after matching. This is almost certainly not what you intend
12:39:13 <geekosaur> (and yes, it must work this way)
12:39:22 <yushyin> shapr: until now I tried some, inlcuding, classy-prelude, basic-prelude and base-prelude. I still like base-prelude because of no deps besides base and protolude is new to me.
12:39:31 <lucca> yeah, I tried that and it hit all types rather than just those meeting Class2 m, which... doesn't work, as you say.
12:40:12 <lucca> lyxia, essentially a shorthand for instance Class1 TypeA where, instance Class1 TypeB where, etc etc for all types meeting Class2
12:40:36 <lucca> probably a sign of bad modeling of classes, heh
12:40:38 <geekosaur> thing is, typeclasses are shorthand for passing a dictionary of operations. they are not inheritance, and not magical
12:41:10 <ertes> lucca: class (Monoid a) => Inverses a where inverseMaybe :: a -> Maybe a  -- would something like that help?
12:41:20 <geekosaur> and you can't use just a class to figure out how to populate the dictionary
12:41:33 <EvanR> ertes: with undecidable instances maybe
12:41:44 <ertes> EvanR: hmm?  no
12:41:59 <EvanR> oh i read that as instance
12:42:03 <ertes> the way i understand it lucca wants to have Class2 be a richer version of Class1
12:42:27 <ertes> "everything Class1 has, but with these extra functions", for example
12:42:39 <EvanR> what would the inverse of a monoid element do
12:42:46 <lucca> not quite; as geekosaur said it isn't able to use the set of types implementing Class2 to populate the instance list for Class1
12:43:18 <EvanR> x x^-1 = x^-1 x = e ?
12:43:36 <lucca> more concretely, I have a set of different data types that implement Class2, but are internally structured very differently.  Class2's methods are a sufficient interface to implement Class1, which is in this case Num
12:44:10 <EvanR> what are Class1 and Class2 and people here maybe give you help thinking about it a different way
12:44:12 <lucca> So I end up with many instance Num TypeA where ... with duplicated ...s for each type in Class2.  
12:44:19 <EvanR> i.e. time to get even more concrete
12:44:33 <EvanR> often type classes are the wrong idea
12:45:06 <ertes> lucca: it's a common problem:  for instance every Applicative gives rise to a Num instance, but you have to write it by hand
12:45:11 <lucca> Well, okay.  I'm playing with computational geometry and mesh manipulation in 2D and 3D, including spatial query analysis and e.g. delaunay triangulation
12:45:50 <lucca> ertes, ahaa
12:46:17 <ertes> lucca: all of those instances look exactly the same:  (+) = liftA2 (+); (-) = liftA2 (-); negate = fmap negate; …
12:46:31 <EvanR> ertes: its not a good idea to make this Num instance
12:46:55 <ertes> lucca: the best you can do is to write some template haskell helper
12:47:11 <ertes> EvanR: which one?  i didn't talk about any particular one
12:47:25 <EvanR> instance Applicative a => Num a (even if that would work)
12:47:32 <ertes> i didn't suggest that
12:47:45 <EvanR> (+) = liftA2 (+)
12:48:09 <lucca> thanks, this has helped me understand.
12:48:12 <MaybeBom> Cale, sry was doing something else, alright i've done 1) and 2) and i did map (convertedList) (map)
12:48:16 <ertes> that's still not what i suggested…  i said it's a common problem that you have to implement an instance for every type manually
12:48:30 <EvanR> ok so Applicative Num was an example?
12:48:45 <MaybeBom> Cale, Why would we use now zipwith? i need to do Sclae first dont i?
12:49:00 <lucca> a good example, as what I was doing with Num is likely similarly dubious
12:49:20 <shapr> lucca: are you FPing "Geometric Algebra for Computer Scienc : An Object-Oriented Approach to Geometry" ?
12:49:32 <ertes> EvanR: it's a common problem:  every Applicative gives rise to a Num, but you have to write the instance out manually, because there is no way to derive it other than template haskell
12:49:45 <lucca> shapr, no, but I guess I'd better look that up
12:49:52 <ertes> why am i even repeating this?  just read what i wrote without skipping half of it ;)
12:50:12 <EvanR> ertes: i specifically was replying to that, but im not going to repeat it again
12:50:31 <EvanR> so go back and read that
12:50:40 <EvanR> and take the fixed point
12:50:45 <shapr> lucca: byorgey was asking if there was Haskell code for that book earlier, so I thought you might have joined him in that effort.
12:50:47 <ertes> lucca: it's not dubious…  you could think of it as an example of the expression problem in haskell
12:51:08 <EvanR> Applicative Num is a good example of thing you dont want to solve
12:51:19 <ertes> lucca: it *should* be easy and mechanical to do it, but it's not, because the language support is not there
12:51:37 <lucca> might be a good excuse to learn template haskell better
12:51:58 <EvanR> not for this. but for some other example you might be able to leverage generics instead
12:52:01 <ertes> go ahead…  the more people learn TH the better, because that makes it less likely that *i* have to learn it =)
12:52:27 <kadoban> Haha
12:52:37 <lucca> sounds about right, heh
12:53:20 <MarcelineVQ> ertes: It's pretty neat
12:53:33 <ertes> lucca: there is another option, which always works and is only slightly awkward:  a newtype wrapper
12:54:07 <ertes> lucca: newtype AppNum f a = AppNum { fromAppNum :: f a }  deriving (…)
12:54:21 <ertes> instance (Applicative f, Num a) => Num (AppNum f a) where …
12:55:44 <lucca> hmmm.  A bit awkward.
12:55:58 <ertes> conal solved it in a funny way:  using CPP instead of TH
12:56:15 <ertes> #define APPLICATIVE MyType
12:56:20 <lucca> CPP would be sufficient for this, I suppose
12:56:29 <ertes> #include "ApplicativeNumeric-inc.hs"
12:56:48 <EvanR> AppNum is even worse than just using liftA2 (+) directly
12:56:51 <ertes> https://hackage.haskell.org/package/applicative-numbers
12:56:58 <conal> Maybe a combination of AppNum and CPP would be better still.
12:57:10 <conal> generating less code.
12:57:19 <conal> (via CPP)
12:58:07 <conal> probably not much, though, since each method would still have to be defined.
12:58:36 <ertes> conal: i'd expect that to be even longer, because you'd have to do all the wrapping/unwrapping
12:59:02 <conal> ertes: that bit can be made terse, but i still don't recommend it.
12:59:20 <ertes> ditto
12:59:23 <conal> ertes: probably not terser than fmap and liftA2
13:00:00 <ertes> newtype GolfyAppNum f a = A { u :: f a }
13:00:11 <ertes> x + y = u (A x + A y)
13:00:12 <ertes> =)
13:00:55 <conal> (+) = viaA2 (+)
13:06:18 <geekosaur> that or we're back to banana brackets / idiom brackets again >.>
13:11:19 <haasn> I can't come up with a prettier way of expressing this: https://0x0.st/pQ0.txt
13:13:06 <codygman> haasn: Possibly totally wrong, but just glancing at that I'm thinking "FoldM/fromMaybe"
13:13:10 <codygman> foldM*
13:15:49 <geekosaur> the disgusting way to do it is change ds to (d:ds) and catch the exception on pattern match fail...
13:16:14 <geekosaur> or ds@(_:_)
13:18:55 <ph88> im trying to use foundation, anyone know what's the function to concat strings ?
13:19:18 <Cale> haasn: Well, why do you expect the search to recover more stuff the second time around?
13:19:43 <haasn> Cale: ‘downloadDoc’ removes the unprocessedTag
13:20:03 <haasn> and ‘commit db’ commits that to the database, so the next search will no longer return the documents I just processed
13:20:19 <lyxia> ph88: Strings are Monoids
13:20:26 <haasn> it basically loops while (there are documents that are not processed)
13:20:38 <Cale> lyxia: String *is a* Monoid
13:20:53 <ph88> is there a short for `mappend` ?
13:20:56 <haasn> ph88: <>
13:20:56 <Cale> <>
13:21:16 <ph88> ah that's nice, thanks guys
13:21:25 <Cale> haasn: Right, but why would there be unprocessed documents after you just finished processing them all?
13:21:38 <haasn> Cale: each iteration only processes them in batches of size ‘limit’ (e.g. 100)
13:21:50 <Cale> ahh
13:21:52 <haasn> search db query limit
13:21:53 <Cale> the limit
13:22:16 <ph88> when ghci finds multiple .ghci files, do they overwrite each other or only 1 is chosen ?
13:22:21 <haasn> this keeps the operations nice and atomic
13:23:19 <hexagoxel> haasn: fmap (fromMaybe ()) $ runMaybeT $ forever $ do { ds <- search .. >>= \case { (_, ds@(_:_)) -> return ds; _ -> mzero }; forM_ ds ..; commit db }
13:23:46 <Cale> ph88: Why did you decide to use foundation btw?
13:23:59 <ph88> wanted to give it a try
13:24:17 <ph88> got hello world running but my .ghci file is not compatible
13:25:17 <haasn> hexagoxel: that looks like even more syntactical noise :(
13:25:52 <haasn> I guess I could wrap my search into Maybe and use some sort of whileM-type combinator though
13:25:53 <Cale> I don't mind the current code
13:27:09 <Cale> If you don't like defining this go and then immediately applying it afterward, you might just use fix
13:27:43 <Cale> fix $ \loop -> do (_, ds) <- ... ... loop
13:28:21 <lyxia> unless (null ds) $ do ...
13:28:33 <c_wraith> fix is nice inside of do blocks when you want a recursive function that closes over something bound earlier in the block. 
13:28:38 <Cale> ah, yeah, that might be an improvement
13:28:59 <lpaste> hexagoxel pasted “haasn: the nice thing is it is "flat"” at http://lpaste.net/350628
13:29:49 <c_wraith> though its advantages decrease as you add more arguments to the function. 
13:30:13 <c_wraith> need fixWithN combinators. :) 
13:30:44 <haasn> https://0x0.st/pQ7.txt ‘unless’​removes one level I guess
13:32:15 <lyxia> you could move forM_ out of it and squash commit db >> go in one line.
13:34:49 <jackhill> Hi, I'm looking for a for a library or techniche that will help me with the following problem: I want to do calculations where values are normalized per time-period.
13:35:17 <MaybeBom> Cale, do u remember that function Char -> Picture it keeps telling that the pictures are not in scope...
13:36:03 <jackhill> e.g. I want to have something like data TimeDependentValue = TDV LenghthOfTime Value , and be able to create values over different lenghts of time, but be able to compare them resonable (e.g. multiple the monthy value by 12 to compare with the yearly value).
13:36:21 <jackhill> what is a good way to deal with the different units of time?
13:42:21 <EvanR> jackhill: for attaching unit information with types, you can use newtypes over whatever number type
13:43:04 <dfeuer> Hi Cale. Still trying to figure out the best way to munzip sequences.
13:43:19 <EvanR> you can also use phantom types to track the units and type families to automatically deduce what (*) does to units
13:43:22 <kwantam> Folks, has anyone done any work with Autobahn, and if so, can you give me some impress of its usefulness / quality?
13:43:24 <dfeuer> Laziness gets complicated.
13:43:45 <jackhill> EvanR: cool, I guess I still would need some help dealing with time units
13:43:47 <kwantam> (Autobahn = https://github.com/Genetic-Strictness/Autobahn )
13:44:01 <EvanR> i dont understand, how is that not what i was talking about?
13:44:11 <EvanR> time units is a subset of units
13:44:22 <dfeuer> Really complicated.
13:45:11 <jackhill> EvanR: yes, but I don't want to have to figure out how the convert them myself. Does Data.Time provide a resonable interface for that?
13:45:36 <EvanR> Data.Time is for time *types*, any sort of time difference is in seconds
13:45:53 <EvanR> for calendrical calculations, everything is in number of days
13:46:21 <EvanR> it sounds like you are using various application specific units for things involving time, not "time itself"
13:47:06 <EvanR> you generally need to figure out all the conversions yourself, and the type system can help you not mess up
13:48:08 <breadmonster> How is Haskell for numerics?
13:48:14 <sydneyhacker> Hi I have a beginner category theory question - good place to ask?
13:48:19 <jackhill> great, thanks!
13:53:06 <suzu> sydneyhacker: yup
13:53:13 <suzu> breadmonster: what do you mean?
13:54:15 <sydneyhacker> thanks - just reading a book on the subject - and wanted to prove something simple i.e. if you have an arrow f, and define inverse f' so that f'.f = ID(A) and f.f' = ID(B), that f' is unique
13:55:01 <sydneyhacker> so wanted to check what unique (or equality) means for arrows. I assume it means f . a = g . a (for all a)
13:56:00 <pringlescan> Hello, I'm having issues using stack to build postgrest. It takes over 45 minutes and requires gigabytes of memory. Here is the script I'm running on a fresh Ubuntu 16.04 instance (KVM, 2GB of Memory, SSD) http://lpaste.net/7176600574467506176
13:56:10 <dfeuer> shapr, I just sent a message to the list about what Data.Tree should do for unzipping. Chime in if you care.
13:56:10 <lyxia> sydneyhacker: that begs the question if you pick a = id
13:56:36 <breadmonster> suzu: Umm, do people do scientific computing in Haskell?
13:57:59 <EvanR> breadmonster is asking if haskell can crunch numbers hella fast
13:58:21 <EvanR> like BLAS or a naively written fortran program
13:58:28 <sydneyhacker> lyxia : thanks I have over complicated it :-) I can get rid of the "a" from my proof entirely
13:58:34 <suzu> ah
13:58:37 <suzu> i dont think so tbh
13:59:01 <kwantam> breadmonster: I usually prototype numerical stuff in Haskell and most of the time that's good enough. But when necessary I'll rewrite it in something faster. But I am a dilettante, numerically.
13:59:05 <suzu> here's a good writeup of how mature haskell is when applied to different tasks
13:59:07 <suzu> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
13:59:32 <dfeuer> breadmonster, one of the bigger problems is that Haskell doesn't have proper support for SIMD as yet.
13:59:51 <carter> Inner loops are gonna be in assembly for any decent stuff. But first getting the lag Erie
14:00:09 <carter> Suzu dfeuer stay tuned. :)
14:00:16 <sydneyhacker> Let f' and f'' be inverses of f then f' = id.f' = (f''.f) . f' = f'' . (f.f') = f''.if = f''
14:00:20 <dfeuer> carter, what the heck is a lag Erie?
14:00:28 <carter> Auto correct on my phone
14:00:33 <carter>  It sounds cool though
14:00:38 <dfeuer> And what was it *supposed* to be?
14:01:04 <carter> I meant to say modelling your problem right matters first. Cause you can shave orders of magnitude off your compute with some care
14:01:33 <carter> Still lots of room for better support for that
14:01:48 <carter> In alll the tools
14:01:55 <pringlescan> @carter: where is a good room to ask for support with stack?
14:01:55 <lambdabot> Unknown command, try @list
14:02:16 <carter> pringlescan: google it? I tend to only support cabal :)
14:02:21 <EvanR> #stack
14:03:32 <pringlescan> I don't necessarily need to use stack, I just need to be able to build in less than 45 minutes
14:03:53 <EvanR> stack is building postgres the database system?
14:04:27 <carter> Cabal New build is pretty sweet as a build cache
14:04:28 <pringlescan> Nope, an awesome project that exposes your PostgreSQL database as REST: https://github.com/begriffs/postgrest
14:04:42 <EvanR> clever
14:05:42 <NextHendrix> a space leak is a cool sounding problem
14:06:55 <EvanR> space sounds like a funny resource to find scarce
14:06:59 <sm> pringlescan: #haskell-stack
14:07:04 <pringlescan> If anyone wants to be a hero and optimize the build process it will really reflect well on the Haskell community. This project serves as a gateway drug into Haskell in production.
14:07:15 <sm> but it may not be stack-related
14:07:16 <pringlescan> sm: thank you, I'll poke around in there.
14:07:31 <sm> (try building with cabal to find out)
14:07:32 * EvanR volunteers pringlescan for this duty
14:07:36 <slack1256> ghc_worker is the generic name for process that run capabilities right?
14:09:51 <sm> pringlescan: more to the point, try to find out which package it's building when memory blows up (stack build -j1 or something will build one package at a time)
14:10:44 <sm> then you can focus on that. Also, you could compare building with --resolver lts-6.27 to see if it's something pathological in GHC 7
14:11:58 <geekosaur> slack1256, yes, roughly. https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/GHC-Conc.html#v:labelThread
14:12:30 <pringlescan> sm: the very first one (I know this isn't helpful, I can try to run it on an anemic instance again)
14:13:25 <sm> use top to check if your system is swapping, a common cause of slowness
14:13:36 <pringlescan> passing -j in and using a larger instance is helping, but about a year ago the last time I tried this the more cores you used the slower it got (it would use more CPU to do the same amount of work)... I saw this on multiple tickets
14:14:28 <pringlescan> sm: If I have 2GB of ram I'm not swapping at all
14:14:46 <pringlescan> (I have verified this, 1GB is not enough to avoid swapping)
14:15:06 <sm> yes that's right
14:15:11 <sm> (depending on package)
14:15:39 <sm> and compiler version, and how many building at once
14:16:24 <bennofs> pringlescan: well it's building 143 packages
14:16:32 <geekosaur> pringlescan, also note that haskell is known to give ld, even gold, fits
14:16:47 <geekosaur> (but especially binutils ld will use insane amounts of memory)
14:16:49 <bennofs> pringlescan: so depending on how big those packages are, 45 min for initial build sounds kinda ok
14:17:22 <pringlescan> I was afraid you'd say that.
14:17:52 <bennofs> pringlescan: but once you built it one time, it should be faster since the dependencies are cached
14:18:08 <pringlescan> Are there any plans to improve this or enable binaries (I'm not sure if this is possible)
14:19:07 <bennofs> pringlescan: well stack does cache binaries, so if you build another project against the same snapshot version  then you do not need to compile the shared dependencies again
14:19:23 <pringlescan> I hope you can understand that a build process that's 45 minutes and requires GBs of RAM makes it impractical to push builds in a CI environment.
14:19:50 <bennofs> pringlescan: you can cache dependencies even in a ci environmen
14:19:58 <pringlescan> is there anything built in that I can use to do a "snapshot" and push that to blob storage and pull it down to avoid grabbing all of the dependencies and then just update the out of date ones?
14:21:28 <bennofs> pringlescan: saving and restoring ~/.stack between builds should do that
14:28:24 <sm> pringlescan: I think Travis examples on fpcomplete's blog have some trick to keep travis alive during that first slow build.. I don't seem to have it handy
14:29:29 <sm> alternately, you could tell travis to build some lower level dep that succeeds, which will update the cache, then work your way up to the goal
14:29:53 <sm> in any case, enabling the cache is a must
14:31:09 <sm> stack can't reuse binary builds (except for GHC) at the moment, I think that's waiting on GHC's support for deterministic builds 
14:33:19 <Zef> Hey folks! Finally got my lib ready to upload and uploaded it via `stack upload .`, I've read that it's good practice to build and upload the hackage docs yourself since hackage is a bit unreliable here, is there a good way to do this using stack?
14:33:45 <geekosaur> that shouldn't be an issue now, doc server was overhauled a couple months back and has been fairly reliable since
14:33:53 <geekosaur> er, doc builder
14:34:28 <Zef> Oh okay, so I can just wait for it to build? Any ETA on how long that takes?
14:34:31 <geekosaur> although if your library binds to C libraries not present on a standard Linux distribution then you may still want to upload docs
14:34:55 <Zef> @geekosaur, I'm not binding to c-libs so should be okay there
14:34:55 <lambdabot> Unknown command, try @list
14:35:27 <geekosaur> I don't know what the current delay is, you could ask in #haskell-infrastructure or #hackage
14:35:38 <lyxia> It takes a couple of hours
14:36:03 <Zef> Okay sure, I'm assuming I can expect similar results to `stack haddock`?
14:36:31 <lyxia> Yeah.
14:36:33 <Zef> Also, do most people gpg-sign their packages?
14:36:52 <Zef> Stack had a few errors until I set that up, but couldn't find any reference to it online
14:37:20 <lyxia> stack haddock produces a directory structure that's a bit different from hackage's
14:37:37 <lyxia> but visually it's the same
14:38:47 <pringlescan> sm: yeah... I tarred up the .stack directory and restored it to the same box and tried to run the same build and it insisted on reinstalling ghc and ignoring all the files
14:39:04 <pringlescan> I must have misunderstood how the cache would work
14:40:01 <geekosaur> there is also .stack-work
14:40:33 <geekosaur> and, there may well be full pathnames in various places because ghc likes to do that with packages
14:42:15 <pringlescan> :( ... I'll see if keeping .stack-work helps.. just gotta wait another 45 minutes lol
14:45:03 <sm> pringlescan: or build some of the smaller deps first
14:45:21 <bennofs> pringlescan: yeah you could easily test it with a smaller example
14:47:23 <pringlescan> bennofs: Any suggestions? I thought this was small but that appears to be wrong given the 2GB of dependencies.
14:47:53 <pringlescan> weird, almost all the space is in hackage indices (a tar file)
14:48:31 <pringlescan> hm, all the binaries of the libs are in stack, as you guys said I guess they're just not used
14:48:43 <pringlescan> *.stack
14:52:32 <haasn> what's the go-to Prolog-in-Haskell / logic monad?
14:52:37 <haasn> LogicT?
14:54:14 <geekosaur> last I heard, yes
14:55:13 <wilornel> Hey #haskell! Hey geekosaur
14:55:49 <wilornel> I'm back. I read what you said and tried it, but if I do this, then `stack build` won't work
14:56:24 <wilornel> If I try to get happstack-7.3.8, I can build and exec.
14:56:32 <wilornel> The issue is that I cannot do `stack ghci` in that directory
14:56:56 <wilornel> let me send the result of `stack -v ghci`
14:57:13 <sm> pringlescan: bytestring might be a good low-level dep to try first
14:59:15 <geekosaur> wilornel, https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
14:59:33 <geekosaur> (and the link taking me there noted that "stack ghci" is one of the places where this matters...)
15:00:12 <Zef_> Another question for you here, why is it that for some packages I need to add the package to my stack.yaml and others I don't?
15:00:12 <wilornel> oooh!
15:00:24 <wilornel> So I'm trying to write a small web server
15:00:28 <wilornel> I am not looking to make a library
15:00:35 <wilornel> I should not be dealing with all these things, then?
15:00:42 <Zef_> For instance for my new hackage upload I need to specifically add the given versions of each package to stack.yaml, but for most others I don't
15:00:43 <wilornel> Remove happstack from simple.cabal and stack.yaml?
15:01:00 <wilornel> geekosaur: What page led you to this one?
15:01:02 <wilornel> lead*
15:01:21 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#multi-package-projects end of section
15:01:44 <johnw> what is currently regarded as the best introductory book/online course?
15:01:56 <johnw> my sister-in-law is interested to learn Haskell, and I'm unsure what to recommend
15:02:07 <geekosaur> I should note that I don't use stack, just use the manual a lot for questions in here :)
15:02:13 <geekosaur> @where learnhaskell
15:02:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:02:18 <wilornel> cool!
15:02:22 <geekosaur> should have links to a couple of online courses
15:02:26 <johnw> i've heard rather mixed reviews about that book
15:02:28 <sm> johnw, it depends of course. Slow or fast, friendly or severe ?
15:02:31 <wilornel> I read `learn you a haskell`
15:02:35 <johnw> sm: moderate, friendly
15:02:38 <wilornel> However, it does not cover this stuff
15:02:50 <geekosaur> lyah is good for reading haskell, doesn't help much with writing it
15:02:50 <johnw> it's just for interest's sake at the moment, not professional necessity
15:02:56 <sm> I would suggest https://leanpub.com/haskell-cookbook
15:03:05 <johnw> thanks, sm
15:03:18 <Zef_>  wilornel: I used http://haskellbook.com/
15:03:32 <hpc> @where cis194
15:03:32 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
15:03:34 <Zef_> Worked well for me as someone completely new to haskell at the time
15:03:41 <geekosaur> right, the readme for that link points to two basic courses and an intermediate course
15:03:46 <hpc> that was used for a semester or two in a real classroom setting
15:03:55 <geekosaur> cis194, nicta; cs240h
15:03:58 <hpc> then it got changed and the general consensus is for the worst
15:04:01 <hpc> *worse
15:04:28 <MarcelineVQ> Zef_: stack is about reproducable builds, stackage does this with lts versions, but there's no gurantee like that on hackage so you have to specify the version of a hackage package when you use it with stack
15:05:02 <MarcelineVQ> So that it isn't updated on you in the future and suddenly not compile anymore
15:05:28 <wilornel> I think this might be very good: http://www.scs.stanford.edu/14sp-cs240h/slides/
15:05:34 <wilornel> Thank you Zef_
15:06:12 <glguy> You'll still want to specify your version bounds with stack when you're building a library for sure
15:06:32 <glguy> and to help when building an executable for which API changes you're compatible with when moving between lts
15:08:06 <wilornel> Ah, dependencies are confusing with Haskell and stack
15:08:08 <MarcelineVQ> Yes you still should, especially if you're going to share it, since with version bounds in your .cabal file people can build it with anything they like
15:08:40 <wilornel> from ~ I can do `stack ghci; import HSP` and it works fine
15:08:57 <wilornel> if I do into that `simple` template project, and do the same, I need to modify simple.yaml and stack.cabal
15:09:04 <wilornel> I mean stack.yaml and simple.cabal
15:09:25 <wilornel> *if I go into that*
15:09:44 <wilornel> now, I add happstack in both, and get: 
15:09:45 <wilornel> The following package identifiers were not found in your indices: happstack-7.3.8
15:09:58 <wilornel> So I had to  modify stack.yaml, simple.cabal, and now I need to edit my indices
15:10:11 <Zef> Sorry I cut out there for a second, did I miss anything?
15:10:43 <wilornel> and an interesting part is that hsp IS in lts!
15:11:00 <wilornel> Zef: I'm talking about an issue I brought up earlier today, about 4 hours ago I think
15:11:06 <wilornel> I had to brb
15:11:16 <wilornel> But essentially, I want to write a small webserver
15:11:22 <wilornel> I found that hsp is used for this
15:11:23 <lpaste> MarcelineVQ pasted “Zef” at http://lpaste.net/2183613299441008640
15:11:30 <wilornel> oh
15:11:57 <wilornel> It's very confusing
15:13:17 <geekosaur> hsp is one thing used for it. warp is a simpler webserver used/usable by a number of haskell web frameworks
15:13:42 <glguy> wilornel: There isn't a 7.3.8 version of happstack
15:14:06 <wilornel> Alright, let's see why did I introduce 7.3.8
15:14:16 <glguy> There is of happstack-server, however; so you'll need to figure out what package you're actually using http://hackage.haskell.org/package/happstack-server
15:14:17 <wilornel> There was a message at some point about this so I put it there
15:14:37 <wilornel> I'd like to first just import HSP
15:14:44 <wilornel> in both the build and ghci
15:14:59 <wilornel> it's the issue I encountered and it seems like it should be straightforward enough
15:15:22 <wilornel> so I cleanup extra-deps in stack.yaml and build-depends in simple.cabal
15:15:28 <wilornel> stack build
15:15:36 <Zef> Oh also I was asking how I get my libs included in an LTS release, does that happen automatically? Or are they curated?
15:15:56 <MarcelineVQ> Zef: https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
15:16:13 <wilornel> `stack build`: http://lpaste.net/350630
15:16:40 <wilornel> It's weird becuase it is a meber of the hidden package, but we cannot import it still
15:16:44 <wilornel> member*
15:17:00 <codedmart> If I need to keep track of a few incrementing numbers in my app and ensure that numbers are not repeated and also holds between app restarts how should I go about that?
15:17:30 <MarcelineVQ> wilornel: important line of the error "Perhaps you need to add ‘hsp’ to the build-depends in your .cabal file."
15:17:42 <wilornel> So I add `, hsp` to build-depends for executable in simple.cabal
15:18:03 <wilornel> same error now. Let's see. I think I need to specify a version
15:18:11 <MarcelineVQ> Well consider the error source 
15:18:13 <haasn> Hmm, LogicT just gives me access to backtracking computations, but it won't let me do stuff like run a predicate with variables to find a solution set for that variable
15:18:35 <buttons840> in pipes, can the output of a producer go into two or more consumers?
15:18:36 <haasn> I wonder if there's a library like that; which will basically let me embed a query like livesIn(Hawaii, x) to get a set of solutions for ‘x’
15:18:39 <wilornel> MarcelineVQ: It's an import statement I added
15:18:40 <MarcelineVQ> "[1 of 1] Compiling Lib" that suggests to me you need to add it to the build-depends for the library not the executable yeah?
15:18:56 <wilornel> ah, alright!
15:19:07 <wilornel> `stack build` makes an executable I thought
15:19:10 <wilornel> trying again
15:19:16 <wilornel> whew
15:19:17 <wilornel> !
15:19:34 <wilornel> it works!!?
15:19:37 <MarcelineVQ> It can if it should, but this error while compiling Lib.hs
15:19:54 <wilornel> alright, so I don't understand the library vs executable builds
15:19:56 <thx> ¡
15:20:06 <wilornel> thx :)
15:20:29 <wilornel> I'll read up on library vs executable in stack
15:20:36 <wilornel> I don't understand why we're dealing with the two
15:20:51 <wilornel> I did `stack new simple` and did not think simple was a template _library_
15:22:42 <MarcelineVQ> oh. you're using the default template if you have an executable and a library, perhaps you meant to do    stack new myprojectname simple
15:23:31 <MaybeBom> someone know in gloss if i can have a [Picture] with all the pictures on it translated, and when o pick them they will be on the "zone" that i choose?
15:23:38 <wilornel> that would only make an executable project?
15:23:42 <MarcelineVQ> yes
15:23:46 <wilornel> what does it mean to have a library and executable project?
15:23:50 <wilornel> it has two parts?
15:24:24 <MarcelineVQ> yep, a .cabal file can define one library and many executables iirc
15:24:52 <wilornel> so a physics library and a simulation executable, for example
15:26:05 <ph88> anyone know what these errors mean? https://paste.fedoraproject.org/514862/05391814/
15:26:06 <lucca> or various other utilities related to the library in some way
15:28:01 <wilornel> Oh like building tools for setting up the library!.. ?
15:28:18 <sm> wilornel: you may find https://www.haskell.org/cabal/users-guide/developing-packages.html helpful
15:28:27 <glguy> haasn: You can do that with LogicT, or just [] by enumerating all of the possible values of x and checking your livesIn predicate
15:29:03 <haasn> you mean like foos :: Logic String; foos = <enumerate all possible strings> ?
15:29:04 <glguy> neither of them is as smart as an actual prolog implementation about finding assignmenst, though
15:29:30 <sm> wilornel: and https://docs.haskellstack.org/en/stable/GUIDE/#stackyaml-vs-cabal-files
15:29:31 <glguy> haasn: Hopefully x didn't have type String but some other type like Hawaii did
15:29:42 <haasn> I guess
15:29:55 <haasn> well I mean in prolog I can do it for stuff like arbitrary strings too
15:30:07 <glguy> Yeah, this isn't that
15:30:07 <haasn> or arbitrary integers, by simply reversing the direction of the predicate
15:31:05 <wilornel> thank you sm
15:32:30 <wilornel> geekosaur: And it works! Getting happstack-server as you were saying
15:35:45 <thx> 1/join #chat
15:39:26 <wilornel> It is clear!
15:39:49 <wilornel> I can do `stack build package`, but if I want to use it in my project, I need to add it to build-depends 
15:42:34 <nchambers> thx, its /join ##chat
15:48:12 <ph88> how does snap compare to happstack ?
15:50:50 <wilornel> There are so many available similar tools for web servers! 
15:51:19 <wilornel> I'd like to work with the most popular ones. I wish there was somewhere I could find the popular ones
16:01:50 <ertes> ph88: snap supports streaming and has a built-in system for components (called snaplets)
16:02:18 <ph88> http streaming? websockets ?
16:02:22 <ertes> ph88: on the other hand snap doesn't support things like web-routes very well
16:02:26 <ertes> HTTP
16:02:50 <ph88> any framework mix http with websockets so you can easily use both ?
16:03:52 <geekosaur> @hackage websockets-snap
16:03:52 <lambdabot> http://hackage.haskell.org/package/websockets-snap
16:03:56 <ertes> ph88: you can use the websockets library really with any framework with the caveat that you can't have both on the same port
16:04:06 <haasn> Is the complexity of garbage collection related to the size of my heap in bytes, or is it related to the size of my heap in nodes? Like if I have a list of 100 vectors, each with a million elements, is that going to take the same amount of time to GC as a list of a million vectors, each with 100 elements?
16:04:21 <haasn> If the GC works by following pointers I imagine that a large Vector would take basically no time to process
16:04:33 <haasn> ah then again that's only true for unboxed vectors
16:14:32 <wilornel> It seems like `stack` is not using the {-# OPTIONS_GHC #-} I set up
16:15:10 <geekosaur> that's not up to stack to decide
16:15:22 <geekosaur> did you make sure to place it before any code (including the module definition)?
16:15:31 <wilornel> yes!
16:15:39 <wilornel> it's on the first line
16:15:42 <wilornel> -- {-# OPTIONS_GHC -F -pgmF hsx2hs #-}
16:15:52 <wilornel> I did `sudo apt-get install hsk2hs`
16:16:22 <wilornel> and running `hsk2hs src/Lib.hs` outputs with success
16:16:32 <wilornel> `hsx2hs src/Lib.hs`
16:17:19 <wilornel> running `stack -v build` does not show the options passed to ghc?
16:17:31 <geekosaur> stack does not interpret that line, ghc itself does
16:17:42 <wilornel> ah, gotcha
16:17:44 <geekosaur> which may mean -F and/or -pgmF can't occur in OPTIONS_GHC
16:18:53 <Azad> Hey there, I'm currently learning Haskell coming from a background in primarily Python. I'd like to print the value of a variable while debugging but I cannot for the life of me figure out how to do it. Here's my code. http://pastebin.com/C0C0WZng Do you know how to do it?
16:18:56 <geekosaur> hm, ghc manual says both options are dynamic, so ti should work
16:19:13 <red_> is this fairly active?
16:19:13 <wilornel> hmmmm yes it's a simple example code I found online
16:19:25 <wilornel> seems like it should work
16:19:29 <geekosaur> Azad, Debug.Trace.traceShowId
16:19:38 <geekosaur> (or the other trace functions)
16:20:01 <wilornel> how can I get ghc to be verbose during compilation?
16:20:23 <glguy> Azad: Generally you won't be printing from a function like that. Things won't necessarily evaluate in a simple order, which will make the output interleave in a potentially unexpected way
16:20:25 <wilornel> what if I do {-# OPTIONS_GHC -v #-} ?
16:20:59 <geekosaur> wilornel, should also work and might be a good test of whether the pragma is working at all
16:21:10 <wilornel> yes and it seems like the pragma is not working!
16:21:11 <Azad> This is how I usually debug my programs. How do you do it in Haskell. (By the way, am I expected to whisper?)
16:21:30 <wilornel> Azad: whipser?
16:22:25 <geekosaur> Azad, if you are in pure code, Debug.Trace is the only way to do it. it will however reveal details of the actual evaluation order, which may not be what you expect
16:22:53 <glguy> Azad: Generally you'll debug them by breaking your programs up into small pieces that you can understand and then test those pieces to see that they behave how you wanted in GHCi
16:22:59 <glguy> or by writing some tests to run with them
16:23:10 <Azad> Well, how do you test program chunks?
16:23:15 <Azad> By writing unit tests?
16:23:30 <wilornel> Yeah, would you not have to have some fixture data to pass into your tests? 
16:23:58 <wilornel> What if the fixture data is the result of a big computation and is not serializable through text? Does haskell have fixture serialization packages?
16:24:23 <Azad> Good questions, none of which I am able to answer I'm afraid
16:24:44 <glguy> Azad: Something that complicated probably won't just be a pure function, so you could print in the course of executing your IO
16:26:03 <Azad> I suppose I'll just keep studying for now and solve my problem with Python since I can hardly understand what you are saying. I'm currently doing this course http://learnyouahaskell.com/chapters Do you recommend it or do you think I should choose something else?
16:26:05 <haasn> actually re: my earlier question, in a mark and sweep GC there's no choice but to copy over the vector contents to the other half of the heap
16:26:12 <haasn> unless the vector itself is allocated from non-GC'd memory?
16:26:14 <haasn> I guess that's possible
16:27:04 <haasn> well not mark and sweep, but that “split heap” gc thing
16:27:43 <geekosaur> Azad, the main problem with LYAH is that it will teach you to *read* Haskell code.
16:27:57 <wilornel> Does OPTIONS_GHC pragma work when compiling libraries?
16:28:07 <geekosaur> But you'll have no clear idea of how to *write* it, much less how to use the facilities available for debugging and such
16:28:16 <geekosaur> wilornel, yes
16:28:23 <Azad> Yeah, it has no excercises. That's why I was doing Project Euler excercises using Haskell, ran into a problem and now I am here
16:28:46 <geekosaur> @where cis194
16:28:46 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:28:47 <wilornel> @where learn
16:28:47 <lambdabot> https://wiki.haskell.org/Learning_Haskell
16:29:21 <Azad> Thanks wilornel, I'll have a look at that. Have a good day!
16:29:32 <wilornel> thank geekosaur hahah :)
16:29:33 <wilornel> oh!
16:29:46 <wilornel> ach :S
16:30:56 <codygman> Can anyone help me figure out how to create this "proxy" value and understand this typeclass definition I've never seen before: https://github.com/acowley/Frames/blob/master/src/Frames/RecF.hs#L64
16:31:44 <glguy> codygman: proxy is a type variable there
16:31:57 <glguy> you can use any type you want as long as it has the correct kind
16:32:32 <codygman> glguy: How can I find the kind of proxy?
16:32:59 <codygman> ah, by giving the wrong one
16:33:36 <codygman> glguy: Do you think it was put like that so the user could specify the return type such as List or Vector?
16:34:00 <wilornel> Alright, if I do `ghc ... build ... --ghc-options "... -F -pgmF hsx2hs", it works!
16:34:04 <glguy> The Proxy type is the most common choice
16:34:08 <wilornel> The full command I got from `stack build`
16:34:09 <glguy> but you could use Maybe or whatever
16:34:20 <codygman> glguy: Yeah I did this: columnHeaders (asProxyTypeOf r)
16:34:31 <wilornel> Now, how do I get to pass these flags to ghc properly without a pragma, then?
16:34:53 <codygman> glguy: Needing to do that seems kind of pointless but I know it's not. I just don't know why it's necessary.
16:35:24 <geekosaur> wilornel, what version of ghc are you using?
16:35:25 <MarcelineVQ> wilornel: what does your code look like where you use the pragma http://lpaste.net/
16:35:50 <glguy> codygman: Needing to do what?
16:36:05 <wilornel> geekosaur: ghc-8.0.1
16:36:08 <geekosaur> I looked the status of those up in the manual for 8.0.1 but there were various differences in earlier versions (although I thought in particular the preprocessor related ones were old enough to not matter...(
16:36:10 <wilornel> MarcelineVQ: http://lpaste.net/350632
16:36:31 <wilornel> oh! I was checking `man ghc` 
16:36:33 <MarcelineVQ> don't comment it out dear
16:36:53 <geekosaur> oh, you actually had the -- in front. don't do that
16:36:59 <wilornel> ah! I was sure I copy/pasted it with a comment in front of it
16:37:03 <wilornel> thank you!
16:37:19 <wilornel> it works!! AGAIN!
16:37:25 <geekosaur> I had considered asking about that... should have, sorry
16:37:31 <wilornel> hahaha it's fine :P
16:37:40 <codygman> glguy: I mean to say, I don't understand why the definition is "columnHeaders :: proxy (Rec f cs) -> [String]" rather than "columnHeaders :: Rec f cs -> [String]"
16:37:41 <wilornel> that's good learning right here
16:37:41 <geekosaur> being able to comment out pragmas is useful
16:38:10 <glguy> codygman: Your alternative type would require the user to have a value of that record type in order to find out the column headers
16:38:14 <wilornel> Woot!
16:38:15 <wilornel> It works :)
16:38:27 <wilornel> It's serving html
16:38:39 <codygman> glguy: Oh, so this is so that you can just have a dummy proxy value and get the column headers from it?
16:38:44 <glguy> codygman: also you might find it interesting that while you used asProxyTypeOf in your example code, that you didn't actually use Proxy
16:38:44 <Axman6> wait, how does `hello compile? o.O
16:38:59 <glguy> codygman: You used a function type that just happened to have the correct result type
16:39:09 <glguy> and happened to take a Proxy argument itself
16:39:34 <glguy> so you chose proxy = Proxy yourRecord -> yourRecord
16:39:44 <hackrilege> http://lpaste.net/350633
16:39:44 <glguy> err
16:39:53 <glguy> proxy = (->) (Proxy yourRecord)
16:40:04 <MarcelineVQ> Axman6: pgmF preprocessor maybe
16:40:21 <Axman6> aaahhh, missed that! cool
16:40:37 <geekosaur> yes, the whole point of this was to get a custom preprocessor into the loop, presumably to handle that syntax
16:40:39 <Axman6> that looks really useful!
16:40:44 <codygman> glguy: So what does that mean and what implications does it have?
16:41:09 <houli> anyone else getting control codes instead of functioning backspace when using functions like getLine with compiled programs?
16:41:24 <glguy> It means you took advantage of the flexibility afforded by using a proxy type variable instead of the actual Proxy type, just accidentally
16:41:26 <houli> this must be some recent update that broke this as i could have sworn it was working a few weeks ago
16:42:25 <codygman> glguy: What flexibility do I get by using `asProxyTypeOf` as opposed to `(:) []`?
16:43:17 <hackrilege> I'm having a nightmare trying to do this tree zipper... It's getting all scrambled and keeping track of unraveling it is difficult
16:43:30 <glguy> codygman: No, without the flexibility what you wrote wouldn't have typechecked
16:47:06 <geekosaur> houli, compiled (as opposed to interpreted) programs do not use a line editor (haskeline/readline/editline) unless you specifically wrote them to do so. backspace is one of the keys that is supported by the standard tty driver line editor... but depends on current stty setting
16:47:14 <houli> the same program works with backspaces fine on my system GHC 7.10 but not on the stack installed GHC 8.0.1
16:49:41 <wilornel> These haskell concepts seem so arcane! Lenses for example
16:50:15 <Cale> houli: Check the input buffering mode -- make sure you have it set to LineBuffering
16:50:18 <Axman6> what do you mean?
16:50:58 <Axman6> lenses are so incredibly powerful, I can hardly imagine programming haskell without them
16:51:19 <geekosaur> the lens package is certainly arcane, but van Laarhoven lenses themselves aren't really
16:51:27 <Cale> I mostly program in Haskell without them. There are a few places where it's nice to use them though.
16:51:48 <geekosaur> they're just a getter and a setter packaged together
16:51:52 <Cale> Yeah
16:52:25 <Cale> dfeuer: To answer your question from earlier, I don't really use Data.Tree, so I'm not sure :)
16:52:36 <dfeuer> Hi Cale.
16:52:40 <Axman6> I had a project where I needed to process some awful json, and being able to directly modify things many layers deep in the bytestring made the program much saner
16:52:43 <Cale> Hi
16:52:55 <houli> Cale: actually just seems to be a consequence of stack exec
16:52:55 <dfeuer> Too bad you can't answer. I wonder who could....
16:53:05 <houli> works fine when i run the executable manually
16:53:17 <wilornel> Wow lenses are very powerful!!
16:53:24 <Axman6> yes
16:53:29 <geekosaur> houli, that seems odd. might be worth filing a bug against stack; it might be leaking a bad stty mode
16:53:31 <dfeuer> Also, I'm worried that GHC may defeat the GC trick described in that classic paper.
16:53:37 <dfeuer> How can I prevent that, generally?
16:53:44 <wilornel> Looking at examples was very helpful to understand them
16:53:47 <houli> yes stack update in past week has me wary that they've broken something
16:53:48 <Axman6> turns out that a very large number of operations you might want to perform on data can be done with lenses
16:53:49 <wilornel> well, understand what they are for
16:53:53 <Cale> dfeuer: I dunno what you're referring to...
16:53:55 <wilornel> the description made no sense
16:54:48 <wilornel> "This package comes "Batteries Included" with many useful lenses for the types commonly used from the Haskell Platform, and with tools for automatically generating lenses and isomorphisms for user-supplied data types.
16:54:52 <wilornel> "
16:54:55 <Cale> wilornel: I think it might help to consider a more obvious (though ultimately less elegant) implementation of lenses which was the first approach used:
16:54:57 <geekosaur> (e.g. if it runs the program with the terminal in -icanon, you will see all the control characters)
16:55:14 <Axman6> while they are "just getters and setters", there are different classes for when you can get/set exactly one thing, zero or one thing and zero to infinite things (lens, prism and traversal, respectively)
16:55:45 <Axman6> wilornel: you might find this useful: https://github.com/tonymorris/lets-lens
16:55:57 <geekosaur> yoiu could test that by comparing "stty -a" to "stack exec -- stty -a"
16:56:10 <Cale> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
16:56:14 <dfeuer> Cale, "Fixing some space leaks with a garbage collector". Wadler didn't invent the technique, but he wrote the paper. Unfortunately, it's fragile under optimization.
16:57:47 <Axman6> it goes through a few different iterations of lenses, the (a ->  b, a -> b -> a) one, the a -> (b, b -> a) version and then finally the van laarhoven version we know and love today
16:58:13 <houli> geekosaur: exactly as you said 
16:58:18 <dfeuer> Cale, the obvious implementation is  munzip !xs = (fst <$> xs, snd <$> xs). But that retains the seconds until all the firsts are forced.
16:59:06 <dfeuer> The desirable thing is to let the seconds go as soon as possible.
16:59:59 <jmcarthur> How is munzip supposed to be different from unzip? I have no context, but I'm curious about this conversation.
17:00:41 <dfeuer> jmcarthur, munzip is a method of Control.Monad.Zip, a somewhat peculiar class with a greatly over-strong superclass.
17:00:44 <dfeuer> er...
17:00:50 <dfeuer> Control.Monad.Zip.MonadZip
17:01:04 <dfeuer> It *should* have just a Functor constraint.
17:01:19 <jmcarthur> Huh.
17:01:54 <jmcarthur> And you are looking into how to define that more efficiently (generically)?
17:01:58 <dfeuer> [With just a Functor constraint, we could have a lot more instances, like Data.Map.]
17:02:16 <dfeuer> jmcarthur, no, I'm looking to add appropriate instances thereof to containers.
17:02:21 <jmcarthur> Ah.
17:02:27 <dfeuer> The fact that it should be Functor rather than Monad is an aside.
17:03:06 <jmcarthur> Ah, it's interesting for containers because many of the spines of those data structures are strict.
17:03:25 <jmcarthur> You want to construct both results at once.
17:03:43 <dfeuer> jmcarthur, none of those strict-spined things are Monads, so at the moment that's totally irrelevant. :/
17:04:13 <dfeuer> But there are two containers that can support it: Data.Tree and Data.Sequence, and both have lazy spines.
17:04:42 <dfeuer> Data.Sequence is semantically strict, but operationally lazy, in its structure.
17:07:46 <Axman6> is there any reason Data.Sequence couldn't be a monad?
17:07:50 <Cale> Data.Tree is an odd inclusion in containers
17:08:41 <Cale> I don't think I've run into any instance where I really wanted to use Data.Tree rather than just defining my own tree datatype, apart from at some point converting a tree structure to Data.Tree solely for the purposes of prettyprinting it.
17:08:42 <dfeuer> Axman6, it is a Monad. Data.Map and Data.IntMap cannot be monads, but support zipping and unzipping (intersectionWith and such)
17:09:10 <dfeuer> Cale, it is indeed an odd inclusion in containers, and Data.Graph is even odder.
17:09:21 <Axman6> oh I never realised it was. how handy
17:10:20 <dfeuer> Axman6, its monad instance is extremely boring; it's not possible to make it particularly efficient.
17:11:02 <Axman6> right
17:11:27 <dfeuer> It might be possible to improve it a little, sometimes, but that way lie a slew of trade-offs I don't know how to make.
17:17:38 <ph88> anyone know what these errors mean? https://paste.fedoraproject.org/514862/05391814/
17:19:07 <glguy> ph88: You can start by specifying the types you expect things to have to resolve the ambiguities
17:19:29 <glguy> It'll help to untangle that mess of >>= with do notation so you'll have some variables that you can annotate the types of
17:20:34 <glguy> Incidentally, when mixing >>= and ., it's nice to use =<< instead 
17:23:19 <slack1256> https://i.imgur.com/ZV6qnoS.png 
17:23:43 <ph88> how does  >>= .  make =<<  ?
17:24:46 <slack1256> rasa stole my momemtum :-(
17:24:50 <geekosaur> ph88m the idea is that (.) us right to left and so is (=<<)
17:24:58 <geekosaur> whereas (>>=) is left to right
17:25:06 <geekosaur> ...typing /o\
17:25:18 <geekosaur> ph88, the idea is that (.) is right to left and so is (=<<)
17:25:36 <geekosaur> so they fit together a little more sanely
17:28:51 <houli> geekosaur: tracked down the likely suspect :D https://github.com/commercialhaskell/stack/commit/6c876293a4ca215c2645de162aa0314f415fb754
17:29:11 <houli> issue opened so hopefully the stack team can come up with a proper workaround for the other users issue and mine
17:48:21 <riaqn> Hi, is there any fast way to access the element wrapped in newtype?
17:48:36 <riaqn> now I just do a pattern match
17:48:38 <glguy> pattern matching
17:48:41 <Axman6> lens' Wrapped class lets you do that
17:48:56 <Axman6> :t wrapped
17:48:58 <lambdabot> error:
17:48:58 <lambdabot>     • Variable not in scope: wrapped
17:48:58 <lambdabot>     • Perhaps you meant one of these:
17:49:01 <Axman6> :(
17:49:04 <glguy> or you can have a function that "unwraps" the newtype
17:49:15 <glguy> newtype N = C { unN :: T }
17:49:29 <glguy> is the easy way to generate such a function
17:49:41 <Axman6> a typeclass like Wrapped is the only generic way to do it
17:49:53 <geekosaur> houli, yeh, and this is basically the side effect that has always had me feeling dubious about ghc's runtime conflating NoBuffering and stty modes :/
17:52:46 * geekosaur commented on ticket, since strictly speaking this is not a stack bug so much as unintended behavior
18:01:12 <riaqn> glguy: Axman6: Thanks!
18:12:45 <haskell632> help! i got an error that i don't understand
18:13:03 <haskell632> http://lpaste.net/350636 -> parse error on input 'print' http://lpaste.net/350636
18:14:17 <geekosaur> haskell632, you are not in a do block, let must have expression syntax (let <bindings> in <expr>)
18:14:29 <geekosaur> likewise you probably can
18:14:44 <geekosaur> likewise you probably can't use that print, because you probably are not in IO
18:22:15 <dfeuer> riaqn, there are situations where it's faster to use Data.Coerce.coerce to wrap/unwrap newtypes: particularly when they're buried in other data structures.
18:22:30 <haskell632> geekosaur: thanks, i removed the 'let' all together :-)
18:22:55 <dfeuer> But often pattern matching is perfectly free.
18:26:48 <codygman> Can you modify a given value at the type level and assign other typeclass constraints in a where binding? context: https://github.com/acowley/Frames/pull/78#issuecomment-269723379
18:27:10 <codygman> I'm guessing the answer is either no or "define a top level function".. 
18:29:11 <dfeuer> codygman, try using a type signature for the binding instead of one for the expression defining it.
18:29:52 <dfeuer> codygman, that is, try   uncolRows :: (AsVinyl ts, ...) => ...., uncolRows = rows
18:30:17 <dfeuer> Er .... actually, no.
18:30:22 <dfeuer> I mean, sort of.
18:31:04 <dfeuer> codygman, why do you even define uncolRows?
18:32:02 <hardmath123> Quick question -- 
18:32:03 <codygman> dfeuer: Because the writeCsv function requires the same argument but has different typeclass constraints
18:32:25 <hardmath123> I had to write some bad haskell for a CTF competition
18:32:33 <hardmath123> and surprisingly, http://lpaste.net/350638 compiled
18:32:45 <hardmath123> i'm curious why that works / what it does
18:32:55 <codygman> dfeuer: I require a version that has the ColumnHeaders constraint, then I would like to actually use UnColumns which erases the columns at the type level, and finally pass it to writeCsv
18:33:12 <geekosaur> hardmath123, the Haskell standard doesn't dictate much in the way of ordering, and all it does is a useless pattern match that isn't used for anything
18:33:37 <hardmath123> geekosaur: uhhh could you explain the "useless pattern match" bit?
18:33:53 <hardmath123> like, syntactically what is Foo = Bar
18:34:21 <geekosaur> `Foo = Bar` is not an assignment. it says to match the constructor Bar against the pattern Foo, but it doesn't say anything about what to do with it and you can't refer to it afterward
18:34:43 <hardmath123> ah, so it's kind of like a bare expression at the top level? like "1+1"?
18:34:48 <codygman> so you can have "anonymous" pattern matches on the top level?
18:35:33 <geekosaur> hardmath123, you can't have bare expressions at top level. it's kinda a degenerate case of defining a binding, where you left out the binding part but kept the pattern ("arguments")
18:36:19 <geekosaur> this syntax is actually useful in let, especially when deconstructing something: let (x:xs) = someListExpr in ...
18:36:20 <dfeuer> codygman, I'm just looking at the code and not seeing at all what you mean. You write uncolRows = rows :: blah blah, where blah blah looks an awful lot like the constraint on the writeCsv type.
18:36:29 <geekosaur> or let Just x = someMaybeExpr in ...
18:36:45 <hardmath123> won't that fail if someMaybeExpr is Nothing?
18:36:51 <geekosaur> it would, yes
18:37:02 <geekosaur> but only if you used x
18:37:25 <geekosaur> here, you can't even use the Foo because you didn't bind anything from it. so it's harmless and does nothing
18:37:31 <dfeuer> codygman, do you mean to give writeCsv a rank-2 type, like making the rows parameter have type (forall ts . AsVinyl ts, ... => ...) ?
18:37:47 <geekosaur> > let Just x = Nothing in 0
18:37:49 <lambdabot>  0
18:37:59 <ph88> how can you hide some functions from prelude ?
18:38:00 <dfeuer> codygman, Is it being applied to ts other than the ts in the writeCsv signature?
18:38:11 <hardmath123> whoa
18:38:14 <hardmath123> that's trippy
18:38:15 <geekosaur> ph88, import Prelude explicitly, using the hiding syntax
18:38:16 <hardmath123> okay
18:38:28 <ph88> oh ok
18:38:29 <geekosaur> the implicit export only happens if you don't import it explicitly
18:39:13 <codygman> dfeuer: the first time that rows is used, it is to generate rows'. rows' is then used in columnHeaders which requires the ColumnHeaders constraint. Later I need to pass rows to writeCsvRow which requires the UnColumn constraint that is the opposite of the HasColumns constraint. The value is always the same though. I just need to change the constraints at the type level. I get around this now by passing the same value twice but wit
18:39:15 <jchia> Megaparsec question: I have a Parser that matches a line and returns a value of type a if matching succeeds. I have a file with multiple lines some of which could match. I want to parse the file ignoring the lines that don't match returning a value of [a] for the lines that do match. How do I express the idea of "ignoring lines" that don't match in MegaParsec? I think one way is to use <|> to return Maybe a (Just for match and Nothing for non-match) and then 
18:40:26 <dfeuer> codygman, you cut off, but it sounds like you want a rank-2 type.
18:41:03 <codygman> dfeuer: You might be right
18:42:24 <codygman> dfeuer: here was my full comment that got cut off: http://lpaste.net/350640
18:44:24 <dfeuer> Try with a rank-2 type, yeah.
18:44:48 <dfeuer> Why are vinyl records so strict?
18:44:52 <dfeuer> That feels weird.
18:45:46 <dfeuer> rmap, in particular, doesn't quite obey the functor laws.
18:46:25 <codygman> dfeuer: In regards to strict I just watched "Programming in Vinyl" and the same question was asked. The answer was "you can use Thunk to make it lazy and making it strict made things easier"
18:46:55 <kyousanshugi> i need to take a list of files, a byte length, and then produce a list of hashes of bytes of appropriate length, without respect for file boundaries. in other words, i need to hash a procession of fixed-length chunks of a number of files, as if all the files were concatenated together
18:47:11 <kyousanshugi> if anyone knows, this is how bittorrent hashes chunks
18:47:23 <kyousanshugi> what's the best way to do this? i'm a noob haskeller
18:47:45 <dfeuer> codygman, HRMPH. I don't think that's the right answer, really.
18:47:57 <kyousanshugi> looks like i need some sort of special monad or something, as there's simply too much to keep track of (current file handler, current position in file, list of files, the hash) to do it the nieve way
18:48:08 <dfeuer> Dunno what the right answer is though.
18:48:09 <geekosaur> most of the crypto libraries have an interface where you create a hash, feed it strings, and then extract the hash when done; it doesn't care whether you added the strings from separate files
18:49:07 <kyousanshugi> geekosaur: yeah, that part isn't the problem. i'm just not sure how to best create the function that's going through my list of files and keeping track of all the state
18:51:24 <codygman> dfeuer: I do't think rank-2 type is applicable, I believe I'll actually need to use this refiyConstraint function: https://github.com/VinylRecords/Vinyl/blob/29d7268fd46c4739e481786f80c6debb07ed8109/Data/Vinyl/Core.hs#L195
18:52:05 <kyousanshugi> FWIW i started writing my function type... and it's terrible, which brought me here: hashNextChunk :: (FileHandler, [FilePath], FilePosition) -> ChunkSize -> IO (FileHandler, [FilePath], FilePosition, Hash)
18:52:21 <kyousanshugi> maybe i could stick all that in a custom data type, but that would also feel wrong as it's not really fixing the problem
18:52:34 <geekosaur> kyousanshugi, probably you want StateT Ctx IO with Ctx being the incremental state used by all the hashes in http://hackage.haskell.org/package/cryptohash
18:52:37 <ph88> how can i help to compiler resolve this constraint ?  http://lpaste.net/7525432784546955264
18:52:44 <dfeuer> codygman, have you tried the rank-2 approach?
18:53:06 <glguy> ph88: Do what I said earlier
18:53:33 <geekosaur> in your loop, use: modify (update theByteStringYouRead)
18:54:10 <geekosaur> (where update is the incremental update function from the hash you chose)
18:54:16 <codygman> dfeuer: I don't see how it would apply actually, unless it would let me erase the typeclass constraints somehow between these two functions: https://github.com/codygman/Frames/blob/a6c12c1442edbf8e2e52ec66264ee32fdeeb3b8b/src/Frames/CSV.hs#L171
18:54:28 <codygman> writeCsv and writeCsvRow
18:54:56 <kyousanshugi> geekosaur: okay, thanks. i'll take a look at that
18:56:28 <riaqn> Hmm, is there some alternative to fromIntegral where I can know in case of overflow?
18:56:29 <geekosaur> hash <- finalize <$> execStateT (readLoop listOfFiles) init
18:56:51 <riaqn> that is, Word16 -> Maybe Word8
18:57:07 <dfeuer> codygman, I don't see where you're talking about HasColumn or whatever.
18:57:56 <codygman> dfeuer: One second I'm not seeing my updated code there
18:58:53 <wespiser> I'm playing with Free monads and have run into a problem: I define a Free ADT, define the functor, then get an error telling me I need to define applicative?
18:58:54 <wespiser> http://pastebin.com/4Ve5wxaA
18:58:56 <wespiser> thanks!
18:59:50 <codygman> dfeuer: Alright here you can see where I have to use two versions of the same argument with different typeclass constraints: https://github.com/acowley/Frames/pull/78/files#diff-cb3db915996afc19d348ed033a8b6785R172
19:00:10 <dfeuer> wespiser, you can write  instance Functor f => Applicative (Free f) where pure = return; (<*>) = ap, where ap is from Control.Monad.
19:01:00 <dfeuer> codygman, you're saying these two producers are actually always the same?
19:01:18 <wespiser> dfeuer: thanks, I'm trying to get old code to work: is the error due to the addition of Applicative as a superclass of Monad?
19:01:20 <dfeuer> [this makes considerably more sense than what was pasted in the Github comment]
19:01:55 <dfeuer> wespiser, yes. Usually these days you should actually define pure and let return have its default value (otherwise you may get a warning).
19:02:29 <wespiser> dfeuer: thanks a lot! 
19:03:26 <dfeuer> codygman, I think you want writeCsv :: FilePath -> (forall ts . AsVinyl ts, ColumnHeaders ts, RecAll Identity (UnColumn ts) TextShow => P.Producer (Record ts) IO ()) -> IO ()
19:03:49 <dfeuer> And just use it twice (no need to bind an extra name)
19:04:14 <dfeuer> Er ... oh, I see what you're saying now. Maybe not that.
19:04:59 <codygman> dfeuer: Ah good, I'm glad we are on the same page
19:05:26 <dfeuer> codygman, what is the type of the producer you're actually passing to writeCsv?
19:07:52 <codygman> dfeuer: It is originally ( AsVinyl rs , ColumnHeaders rs) => P.Producer (Record rs) IO ()
19:08:20 <codygman> dfeuer: but writeCsvRow requires the column names to be erased at the type level
19:09:36 <dfeuer> codygman, if that's its type, then you can safely use  (forall rs . AsVinyl rs, ColumnHeaders rs => P.Producer (Record rs) IO ())  as the type of the argument to writeSsvRow.
19:09:55 <dfeuer> But I don't understand where those other constraints come in.
19:24:17 <dfeuer> codygman, I don't see anything in that PR that *uses* writeCsv.
19:28:32 <rockbmb> Hello, quick question: aside from TemplateHaskell/Data.Data.dataTypeOf, what ways are there of getting a string with a datatype's name? 
19:30:37 <dfeuer> rockbmb, Generics.
19:32:45 <rockbmb> dfeuer, I took a look at GHC.Generics and I didn't find anything that explicitly did that. Sorry, but can you be a little more specific, please?
19:33:44 <dfeuer> rockbmb, oh wait, the *type* name. Sorry I was thinking of data constructors. I think you probably want Data.Typeable.typeRep, which gives you something you can show.
19:36:41 <haskell632> request for help again: http://lpaste.net/350636 i got an error of non type-variable argument in the contraint: Num [t] on line 10
19:37:01 <haskell632> i don't know what does it means
19:39:13 <Axman6> haskell632: paste the error too
19:39:32 <Axman6> sounds like you're treating a list as a number though
19:40:24 <haskell632> Axman6: http://lpaste.net/350646
19:40:29 <Axman6> and why are your type signatures commented out? that'll make finding bugs much harder because you haven't told the compiler what you expect the type to be, so it can come up with anything that might be valid
19:40:47 <Axman6> haskell632: you can update pastes on lpaste. when asking for help, always include the error
19:42:29 <haskell632> Axman6: im not sure how to write it out yet, especially the graph data type...
19:43:43 <Axman6> writing the types should probably be your first step, then writing the implementation
19:44:02 <haskell632> Axman6 i couldn't find separate column for writing the error on lpaste, should i just paste the error on the bottom of the source code?
19:44:25 <Axman6> yes
19:46:05 <haskell632> Axman6: I'm not sure what type is the graph, that's why i commented the types on the explore2OutNode function...
19:46:17 <monochrom> There are so many things wrong with this code. And the commented-out type attempts would be way off, too. You so need some more basic lessons before you are ready for this.
19:47:01 <haskell632> monochrom: could you point me to the right direction?
19:47:03 <Axman6> haskell632: comment out the code, and start writing the types. 
19:47:19 <Axman6> then start writing the implementation.
19:47:21 <monochrom> I already did. You need more basic lessons.
19:48:39 <Axman6> it's ok if you get the types wrong, just start writing what types you think you need. if you forgot an argument, you can modify the type signature and add in the missing argument to the function declaration
19:49:06 <Axman6> but we definitely can't help without types. at the moment it's just lots of names without real meaning
19:49:24 <haskell632> monochrom: could you give me a single thing for now the thing i need to change, so that i have something to work with..
19:49:47 <Axman6> haskell632: we honestly can't, we don't have any idea what's supposed to be happening
19:50:25 <haskell632> Axman6: will do, I'll start with the types :-)
19:50:32 <Axman6> good ;)
19:50:44 <Axman6> we can help with that if you tell us what each function is supposed todo
19:51:01 <Axman6> to do*
19:51:34 <haskell632> Axman6: I'll get back to you after i figured out the types
19:53:06 <mi5anin> hi
19:57:09 <Axman6> hello mi5anin
20:33:11 <rockbmb> dfeuer, using Data.Typeable.typeOf and friends, I was able to cook up a solution. It's present in the stackoverflow question titled "Haskell — get TypeRep from concrete type instance", if anyone else is interested (not sure what IRC's policy on links is, sorry). It's better than Data.Data, in my opinion, because it's requires only one class instance instead of two.
20:33:22 <buttons840> how would you remove duplicate lines from a file using pipes?
20:33:22 <dfeuer> rockbmb, great.
20:33:34 <dfeuer> rockbmb, you can definitely link, as long as it's not spam.
20:34:16 <buttons840> rockbmb: and you generally don't have to ask permission to link; again, as long as it's not spam :)
20:47:26 <fizbin> I am trying to develop a data structure that will be useful in answering questions like "in the past hour, how many requests of each type have we had? In the past minute? The past second?"; I'd like some feedback because although I think I got the interface right and the asymptotic behavior right, the implementation is a royal mess.
20:48:03 <mi5anin> Axman6: hey 
20:48:32 <lpaste> fizbin pasted “Weird statistics summarizer” at http://lpaste.net/350647
20:51:44 <fizbin> Basically, I've got something that assumes you have observations (like "1 successful request" or "2 failed requests") that form a commutative Monoid, and then I have a structure you can feed (timeIndex, observation) pairs to and ask it things like "what's the msum of every observation since timeIndex 12345" or tell it "forget all observations before time Index 1212"
21:35:49 <erikd> what is the correct way of terminating a thread started with forkIO ?
21:39:58 <dfeuer> erikd, killThread.
21:40:06 <dfeuer> Or you can use throwTo more generally.
21:45:30 <Lokathor> when might lpaste ever add additional langauge support?
21:46:13 <dfeuer> Lokathor, just submit a pull request to https://github.com/chrisdone/lpaste
21:46:53 <Lokathor> hmm
21:47:19 <dfeuer> I know that's not a simple matter, but it is how things get done in the open source world.
21:47:30 <Lokathor> seems like i will have to read how this works
21:47:47 <monochrom> Pay someone to do it for you.
21:47:56 <Lokathor> there's even SQL involved!
21:48:09 <erikd> dfeuer: thanks, but it seems that i dont need to do anything. it seems the thread terminates by itself when it comes to the end of the forkIO-de function.
21:48:27 <monochrom> That too.
21:49:05 <dfeuer> erikd, oh, well, yeah.
21:49:26 <dfeuer> s/function/action
21:50:36 <erikd> dfeuer: yeah IO action
21:53:57 <orzo> hi
21:54:18 <lpaste> orzo pasted “No title” at http://lpaste.net/350648
21:54:42 <orzo> When I added that logic to my code, i was surprised by the slowdown
21:54:56 <orzo> all it's doing is counting open/close tags to find a tags closer
21:55:13 <orzo> can anyone see something wrong or inefficient with my logic?
21:56:20 <orzo> i'm using tagsoup and Control.Arrow
21:58:45 <orzo> dfeuer, monochrom, erikd: still around?
21:58:56 <dfeuer> Yeah, but I don't know the answer.
21:58:58 <codygman> dfeuer: I'm back :D That didn't quite work, it did inspire a more explicit approach by me though: https://github.com/acowley/Frames/pull/78#issuecomment-269735470
22:00:18 <dfeuer> codygman, it is indeed late, and I need to head toward bed. I'm going to be pretty busy for the next two days, but if you're still struggling after, maybe we can figure it out together.
22:00:37 <dfeuer> In any case, let me know how it all goes.
22:00:39 <codygman> dfeuer: Thanks for all the help!
22:00:42 <codygman> gnight
22:00:46 <dfeuer> Night.
22:10:01 <lpaste> orzo revised “No title”: “No title” at http://lpaste.net/350648
22:10:51 <orzo> i found an inefficency and updated my paste
22:11:07 <orzo> it cut the runtimein half from 2.6 seconds to 1.3
22:12:34 <orzo> i'm not sure if it shouldn't be even faster though.
22:14:02 <Cale> Possibly by avoiding the use of pairs and first...
22:14:38 <Cale> There's going to be a lot of construction and deconstruction of pairs here unless the compiler is being quite clever.
22:14:57 <Cale> (it might be clever enough, I'd have to look at the results)
22:15:44 <orzo> it's occured to me i could zip inits with tails to do what you say
22:16:57 <Cale> I was thinking of something which carried along two function parameters, and only built the pair at the end
22:18:14 <Cale> Oh, also, it appears to me that this definition isn't quite complete
22:18:36 <Cale> (What if the list starts with something which isn't a TagOpen?)
22:19:22 <orzo> well, i'm not using it that way
22:20:14 <orzo> well, the inits and tails version took 1.4 seconds, not an improvement
22:22:43 <orzo> i'm not seeing how to do the two parameters thing unless it means reversing a list at the end.  Is that what you have in mind?
22:23:56 <Cale> You can accumulate a function instead
22:24:15 <Cale> In order to not have to reverse
22:24:44 <orzo> my foldr is accumulating a function, i guess you're suggesting that functoin also accumulate a function?
22:25:10 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/350648#a350650
22:28:38 <orzo> Cale, your version took 1.479, just a litle slower than the inits+tails version
22:28:46 <Cale> hm
22:28:49 <lpaste> stdnt annotated “stdnt” with “stdnt (annotation)” at http://lpaste.net/350636#a350651
22:28:50 <orzo> the best version so far is the one i have with just tails
22:29:06 <Cale> also, how are you compiling?
22:29:18 <lpaste> stdnt revised “stdnt (annotation)”: “stdnt (annotation)” at http://lpaste.net/350651
22:29:30 <orzo> i'm not using cabal, just running ghc with the file name and no options
22:29:42 <orzo> ghc 8.0.1
22:29:43 <Cale> Oh, make sure to use -O2 (or at least -O)
22:29:52 <lpaste> stdnt revised “stdnt”: “stdnt” at http://lpaste.net/350636
22:29:57 <Cale> Performance results don't mean much without it.
22:30:31 <orzo> ghc doesn't do -O0 by default does it?
22:30:48 <stdnt> Hi, it's me again, I'm stuck with an error I didnt know how to fix, can someone help? http://lpaste.net/350636
22:31:00 <orzo> hmm, the man page says it does.  Was it always that way?  I thought O1 was default
22:31:12 <Cale> It was always that way as far back as I can remember
22:31:36 <Cale> Which is like 5.0.2 or so :)
22:31:49 <lfairy> I think Cabal sets -O by default?
22:32:18 <Cale> That may be the case
22:32:22 <plll> How do I get a string representing the home directory (or result of "echo $HOME") and concatenate it 
22:32:26 <plll>               with another string? 
22:33:02 <Cale> plll: getEnv "HOME" :: IO String
22:33:27 <Cale> (That's from System.Environment)
22:34:06 <Cale> So, something like   do homeDir <- getEnv "HOME"; return (homeDir ++ anotherString)
22:35:06 <Cale> You might also use  getUserDocumentsDirectory
22:36:09 <lfairy> also the </> operator joins two paths with a slash, which is probably what you want to do with $HOME
22:36:55 <plll> Fantastic! Thank you so much
22:36:59 <Cale> On unix-like environments getUserDocumentsDirectory will get you $HOME, while on Windows, it asks Windows for a suitable location, which will typically be C:/Users/<user>/Documents
22:37:40 <plll> I had attempted using the getHomeDirectory function but I'm still fairly new, and wasn't sure what to do with an IO Filepath
22:37:58 <orzo> Here are the results with -O2.  inits+tails: 1.241s, tails: 1.312s, Cale: 1.429s, original: 2.304s
22:37:59 <Cale> oh, right, that exists too
22:38:06 <Cale> orzo: cool
22:38:34 <lfairy> plll: if you've got the documentation open, you can click on the "FilePath" link to get its definition
22:38:41 <orzo> the only difference in the ordering of the speeds is that with -O2 the inits+tails version beats the tails only version
22:38:45 <lfairy> plll: if I remember correctly it's just an alias for String
22:38:51 <Cale> orzo: I'm not sure exactly why mine's a little bit worse
22:40:08 <Cale> plll: Yeah, FilePath is just an alias for String
22:40:26 <Cale> and the typical thing to do with an IO t, when you want a value of type t, is just to execute it.
22:41:29 <Cale> i.e. in a do-block (which will denote another IO action), write "v <- x" which means "execute the action x, and name whatever its result is v"
22:41:35 <Cale> and if x :: IO t, then v :: t
22:42:47 <Cale> The type of the whole do-expression will be IO s for some other type s (it will match the type of the last action in it, since that action's result will be the result of the whole combined action)
22:49:16 <tippenein> Is there a way to reverse the order of do-notation? e.g something -> g instead of g <- something
22:50:06 <lfairy> you can use the desugared form: something >>= \g -> ...
22:50:25 <orzo> Cale: your version drops to 1.33 if i use seq to force the incrementing an decrementing of d before entering 'go'
22:51:28 <orzo> can't seem to optimize it enough to match inits+tails though
22:53:15 <tippenein> lfairy that's going to look pretty ugly 9 deep
22:53:40 <tippenein> I think I can make a blasphemous custom operator to fake that tho.. maybe
22:54:30 <lfairy> can you lpaste some example code? maybe there's another way to tidy it up
22:55:03 <lfairy> my other suggestion would be the kleislifish operators <=< and >=>
22:58:46 <plll> Cale: How do you solve the issue of "couldnt match type IO [Char] with Char", when I'm already inside a do?
23:06:32 <lpaste> tippenein pasted “operator curiosity” at http://lpaste.net/350654
23:07:13 <tippenein> lfairy this is what I had in mind.
23:08:36 <Tuplanolla> How does `>>=` not solve this problem, tippenein?
23:09:23 <fizbin> So no thoughts on how to make the implementation of http://lpaste.net/350647 less ugly?
23:12:57 <lpaste> tippenein revised “operator curiosity”: “operator curiosity” at http://lpaste.net/350654
23:13:08 <tippenein> Tuplanolla ^
23:13:47 <Tuplanolla> Try `{-# LANGUAGE NondecreasingIndentation #-}`, tippenein.
23:14:05 <tippenein> lolwhut
23:14:16 <Tuplanolla> That should allow you to keep the same indentation.
23:15:04 <cobreadmonster> I seem to have really fucked up my Haskell install.
23:15:13 <cobreadmonster> So I don't know how to wipe it all and start again.
23:17:06 <mzhang> hey i'm new to haskell
23:17:21 <mzhang> are there simple projects that i can work on to get the hang of it
23:18:02 <tippenein> Tuplanolla: that's not a terrible suggestion. My linter barfs all over with the "redundant do"'s but it might be alright
23:18:37 <Tuplanolla> You don't really need the `do` unless you want it, tippenein.
23:19:22 <tippenein> that's not what the compiler says ;)
23:20:42 <tippenein> oh, I have some interspersed 'let' statements in there.. so _those_ need the 'do', which breaks the whole chain
23:21:01 <Axman6> mzhang: not really, no. there are fundamental things which you need to know before you can really get started, loke how the type system works. you're best bet is to start with a tutorial/book. the fundamentals aren't obvious if you've never used a language like haskell
23:22:18 <mzhang> i've started reading some tutorials and i think i kind of get some of the fundamentals but i don't think i'm getting anywhere just reading
23:23:39 <lpaste> tippenein revised “operator curiosity”: “operator curiosity >.>” at http://lpaste.net/350654
23:24:26 <tippenein> I think I'm fighting the do-notation sugar by trying to make an operator to fake that ^
23:25:36 <Axman6> tippenein: searchForm <!> (eventsResponse, requestEvents) looks like you're trying to define something which pattern matches on the right side, like <- does on its left?
23:27:06 <Axman6> you shouldn't need any of those do's in the last function
23:28:07 <Axman6> you can use let ... in ... if you don't want to use do notation
23:30:04 <tippenein> yeah, that's gonna look even more like vomit tho
23:30:33 <tippenein> but yes, you're right about what my intentions about this fictional (<!>) were
23:30:38 <Axman6> what exactly do you want? and what's wrong with just using do notation?
23:30:39 <Tuplanolla> Use `MonadComprehensions` instead for maximum stupid, tippenein.
23:31:54 <tippenein> thanks glob: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#monad-comprehensions
23:33:53 <tippenein> Axman6: I want the pattern matching assignments on the right side
23:34:10 <tippenein> without all the noise*
23:34:25 <tippenein> this is just a curiousity, tbc.
