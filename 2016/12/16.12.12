00:13:08 <EvanR> shiona: btw IntMap should be quite a bit faster than Map Int
00:16:33 <shiona> EvanR: but its Map Reg Int. I guess I could do a mapping from Reg to Int, but I find that kind of ugly.
00:16:54 <jle`> you can abstract over it
00:17:14 <jle`> newtype RegMap a = RM (IntMap a)
00:17:23 <jle`> and build functions for accessing >_>
00:17:29 <grantwu> There's an EnumMap somewhere
00:17:29 <jle`> and updating <_<
00:17:42 <EvanR> if there are 4 Regs
00:17:48 <grantwu> @hoogle EnumMap
00:17:49 <lambdabot> Data.IntMap.EnumMap2 newtype EnumMap k a
00:17:49 <lambdabot> Data.IntMap.EnumMap2 EnumMap :: IntMap a -> EnumMap k a
00:17:49 <lambdabot> package EnumMap
00:17:51 <EvanR> then Map Reg a is really (a,a,a,a)
00:18:02 <EvanR> assuming all spots are filled
00:18:20 <EvanR> thatll take up a lot less than a Map
00:18:35 <grantwu> i think shiona wanted to know something that worked for 8 or 32 too
00:18:59 <EvanR> unboxed vector time
00:58:46 <quchen> Can I somehow create my own Stack template (and put it in my ~/.stack dir or something)?
00:59:02 <quchen> It’s a bit annoying to always copy over my .stylish-haskell.yaml for example
01:16:51 <sdx23> quchen: https://github.com/commercialhaskell/stack/issues/137#issuecomment-113108658 ?
01:21:44 <quchen> sdx23: Hm, I can pass the template file explicitly I guess.
01:21:55 <quchen> stack new getpass ~/.stack/templates/quchen
01:29:47 <maerwald> is there a policy framework somewhere for the GHC RTS, similar to RESIN?
01:32:04 <merijn> maerwald: What is RESIN?
01:33:21 <maerwald> merijn: https://www.cs.columbia.edu/~junfeng/09fa-e6998/papers/resin.pdf
01:37:11 <Wizek> Hey, anyone knows if I can automatically execute some command in GHCi after it started, without it exiting right after? for example, I tried `echo "1+1" | ghci` which launches ghci and prints 2 as expected, then quits. Can I prevent the quitting part somehow and stay in GHCi?
01:37:34 <sbrg> Wizek: I think you can if you simply put it in your .ghci
01:38:02 <sbrg> AFAIK, the lines in the .ghci files are just executed as-is. this includes normal haskell expressions, I think
01:38:57 <Wizek> sbrg, so if I would want to specify something from the shell, then I would need to write it as a temporary .ghci, say .ghci-tmp and tell ghci to load that?
01:39:30 <merijn> maerwald: oh, no, the RTS design (and really all of haskell) is that the entire application has the same privilege/authorisation
01:39:40 <merijn> maerwald: You can freely mess with the entire memory, etc.
01:40:08 <merijn> maerwald: If you want a more security aware approach you;d be better of developing a DSL/TH library enforcing that at compile time
01:40:16 <sbrg> Wizek:  I'm not entirely sure. I think it may be possible to pass ghci a single expression to run, but it won't keep running I think. I can only recommend the user guide
01:40:39 <Wizek> sbrg, looking at it now
01:41:01 <merijn> Wizek: The reason why it quits is because the pipe replaces ghci's stdin (normally the terminal) with the stdout of "echo", once echo exits, it's stdout is closed and ghci detects it's stdin being closed and terminates too
01:42:04 <maerwald> I don't see how that's a problem. The idea would be to be able to define policies (especially for IO) that are enforced during runtime and throw exceptions when they are not followed. And do that nicely, not manually everywhere.
01:42:44 <lyxia> Wizek: ghci -ghci-script <(echo "1+1")
01:43:31 <lyxia> this makes the stdout of process (echo "1+1") as a file for the command ghci.
01:43:32 <merijn> maerwald: Yes, but my point is that the second you allow IO you allow the entire policy to be subverted, as running programs are free to modify/change the RTS currently
01:43:46 <Wizek> lyxia, That's a great idea! 
01:43:55 <Wizek> lyxia, It worked like this: `ghci -ghci-script =(echo "1+1")`
01:44:00 <merijn> maerwald: The sort of design you'd want for what you describe is pretty fundamentally different from how the RTS is currently designed.
01:44:28 <Wizek> lyxia, thanks! Didn't know about the "-ghci-script" option.
01:44:40 <merijn> maerwald: Now, you COULD design an RTS like that. I'm just saying you can't retrofit it in ghc's current RTS (and probably wouldn't want to anyway)
01:44:53 <merijn> maerwald: It'd be interesting to have an alternate RTS like that, though
01:45:18 <maerwald> don't have the time (or knowledge) for that :P
02:48:39 <jchia1> Question about filename encoding used in System.Posix.Files: AFAIK, filenames on linux are just bytestrings, but System.Posix.Files uses "type FilePath". So, what encoding are they using when interfacing with the underlying filesystem. Are they just implicitly using UTF-8?
02:48:52 <jchia1> :t FilePath
02:48:54 <lambdabot> error: Data constructor not in scope: FilePath
02:49:05 <jchia1> :i FilePath
02:49:30 <jchia1> Anyway FilePath is just String
02:57:20 <sbrg> Hey guys. We have an extra session in the haskell course where I'm TA, and I was hoping to use it to show the students some nice examples of 'real world haskell'. Perhaps showcase some libraries/programs in Haskell that demonstrate why Haskell is really cool to use for many 'real world' applications. I was thinking about showing them servant, at least. Anyone have any cool ideas?
02:59:16 <sbrg> I have also thought about diagrams, since it's so cool, but that doesn't quite scream 'real world' even though it's very elegant
03:02:01 <sdx23> shellcheck, pandoc, xmonad come to my mind. Also something with Parsers.
03:02:24 <sbrg> xmonad is a cool idea since I'm already running it, and I can demonstrate the code very easily.
03:12:49 <mpickering> I think servant is better as most students will not have considered building a window manager
03:16:46 <sbrg> nope, but it's still a cool example. I'm thinking that something like servant + persistent would be pretty real-world
03:21:10 <stobix> I'm planning on explaining monads to a friend of mine. Would it be correct to say that a monad is something that is both a functor and a monoid at the same time?
03:22:01 <lyxia> That's how I would describe applicative functors...
03:22:11 <stobix> ah. heh, sorry. 
03:22:30 <stobix> both applicative and monoid... but you say that applicative functors are monoids as well‽ 
03:22:37 * stobix needs to think things over a bit more, it seems
03:22:59 <lyxia> I'm not sure that makes sense
03:24:27 <liste> stobix: http://stackoverflow.com/a/3870310/1283954
03:31:10 <stobix> Hm. Now I have, from stackoverflow, "A monad is just a monoid in the category of endofunctors" and "monads are just applicative functors that support >>=". Would it be true that (>>=) is what it takes for an applicative functor to behave like a monoid in a broader sense?
03:32:58 <opqdonut> that's join I think
03:33:13 <opqdonut> (but you can implement join with >>= and vice versa if you have return and fmap)
03:33:52 <stobix> ah. right.
03:35:12 <stobix> Yeah, I was kinda thinking that join was at least one/the thing that was the difference between Applicatives and Monads...
03:35:31 <stobix> (>>) feels really like mappend one level up
03:35:34 <mpsag> Is anyone here using haskell inside a vagrant box on windows? This computer isn't so bad, however when I run `stack install ghc-mod` or anything like that, cabal just hangs at build with zero progress. 
03:36:03 <lyxia> stobix: Are you sure your friend is able to wrap their head around the fact that join is just like a monoidal product in some sense
03:36:29 <cocreature> mpsag: try passing --verbose or --cabal-verbose
03:36:45 <lyxia> stobix: (>>) also exists as the applicative-only (*>)
03:37:01 <stobix> lyxia: my friend has not even the most basic grasp of types. I need to think this through enough to explain it without all the details but still get the message through.
03:37:10 <stobix> lyxia: ah, good point.
03:37:24 <merijn> tbh, the "monads are just a monoid in the categor of endofunctors" is pretty useless to know, imo
03:37:25 <opqdonut> stobix: my favourite monad explanation is "overloadable semicolon"
03:37:40 <merijn> stobix: Have you read Wadler's original paper?
03:38:06 <stobix> merijn: probably not. Do you have a link?
03:38:15 <lyxia> opqdonut++
03:38:27 <merijn> stobix: http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
03:38:40 <cocreature> “monads are just monoids in the category of endofunctors” is especially confusing in haskell since they are not instances of the Monoid typeclass (in general)
03:38:47 <stobix> opqdonut: well, yes, in a sense. But in what way is that not true for applicatives, monoids and the likes?
03:39:07 <stobix> (the semicolon thing)
03:39:10 <merijn> stobix: It's surprisingly simple to read, so I'm sad not more people do. It basically shows 4 different examples of code, then illustrates how they all boil down to the same pattern and how you can capture that using Monad
03:39:11 <cocreature> so you’ll end up having to explain the difference between Monoid and mathematical monoids
03:39:46 <opqdonut> stobix: well monoids have nothing to do with semicolons. I guess it could apply to applicatives, but applicatives don't have do-notation
03:39:57 <opqdonut> stobix: Monad is pretty much "a thing for which do-notation makes sense"
03:40:00 <lyxia> now they do
03:40:01 <stobix> merijn: sounds nice. I'll read it when I have the time.
03:40:12 <lyxia> no pun intended
03:40:24 <stobix> opqdonut: ApplicativeDo is almost a thing now. :)
03:40:26 <opqdonut> stobix: and the two pieces of do-notation are assignment (<-) and semicolon (putting statements in a sequence)
03:40:49 <opqdonut> stobix: so "overloadable semicolon and assignment" is more precise, but less catchy
03:41:14 <mpsag> cocreature: yea, it just hangs there at `Progress: 0/57` - no further information
03:41:30 <stobix> The reason why I am asking the question to begin with is that my simple monad examples I was preparing all just needed to be applicatives to work. And I realized that once he saw the types, he would ask, and I'd have to explain the difference between Applicative and Monad.
03:41:53 <cocreature> mpsag: how long have you been waiting? how’s the cpu usage?
03:42:10 <merijn> stobix: The functionality of Monad is a superset of Applicative, so yes, your examples can sometimes be boiled down to Applicative instead of Monad
03:42:24 <merijn> stobix: I have a useful exercise for figuring out the difference
03:42:56 <merijn> stobix: Does the following type make sense to you (i.e., do you understand it, whether you see where it might be useful is not important): data Const k a = Const k
03:43:06 <stobix> f m1 m2 = do { x <- m1; y <- m2; return (x+y }  is apparently just an applicative if done without do notation. It has both semicolons and assignment.
03:43:18 <opqdonut> stobix: yes
03:44:16 <opqdonut> and do { x <- m; return (succ x) }  is just fmap
03:44:19 <stobix> merijn: Yeah, a "let's filter out things already in the function type specification" type. :)
03:44:39 <mpsag> cocreature: cpu usage is in the one digit realm. i've been waiting for hours. tried this on various bento boxes
03:45:06 <merijn> stobix: Try and implement Functor, Applicative and Monad for that type. Check that the laws hold. Some instance may require additional constraints to be lawful.
03:45:27 <stobix> opqdonut: yeah, so what do I need to need for it to be a monad?
03:46:06 <stobix> merijn: hm. Might do. Unless my head explodes. But it ought to be a good practice, I guess.
03:46:09 <cocreature> mpsag: maybe try --cabal-verbose
03:46:09 <cocreature> ghc can be slow (and is for ghc-mod) but it shouldn’t take hours
03:46:21 <lyxia> stobix: actually if your friend doesn't even know about applicative functors, it might not be helpful to make the distinction in a first explanation.
03:46:36 <opqdonut> stobix: you need to perform a "true >>=", which means basically "x <- m1; ...; m2 x"
03:47:00 <merijn> stobix: This exercise will help you figure out the exact limitation of Applicative vs Monad :)
03:47:05 <stobix> lyxia: I basically want to be able to gloss over it in a way that is comprehensible. Which basically means that I have to be able to grok it myself.
03:47:44 <stobix> opqdonut: ah. Good. That really helped, actually.
03:48:36 <opqdonut> stobix: you might be interested in Week 6 of https://github.com/opqdonut/haskell-exercises (shameless plug)
03:48:57 * stobix eats shameless plugs for breakfast
03:49:23 <stobix> Good, now I really have some stuff to think about. Thanks y'all.
03:49:31 * stobix runs away to an appointment that starts in 10 min.
03:51:03 <mpsag> cocreature: just sits there. sigh
03:51:33 <cocreature> mpsag: sorry not sure what’s going on there
05:01:57 <quchen> Is there an 'is' lens that tells me whether a prism does match?
05:02:11 <quchen> There is »isn't«, but I cannot find »is«.
05:02:29 <quchen>  > is _Just (Just 123) -- True
05:03:42 <moongazer> b0llu, Hey
05:03:55 <b0llu> moongazer: hello :)
05:07:18 <tdammers> wait so that's what Prisms are
05:07:47 <supki> quchen: there's is in Control.Lens.Extras
05:08:15 <supki> quchen: (or just use has)
05:09:30 <quchen> Ah!
05:09:34 <quchen> That looks right.
05:30:42 <b0llu> https://github.com/bollu/symengine.hs/blob/master/src/Symengine/DenseMatrix.hs#L137
05:30:47 <b0llu> I want to be type safe
05:30:51 <b0llu> but that type signature is so clunky to use
05:31:02 <b0llu> you need to provide the getting row and col with type application
05:31:14 <b0llu> is there a neat way to index a matrix without losing static guarantees?
05:33:16 <b0llu> jle`, monochrom, lyxia, Cale: type level magic help please
05:33:17 <b0llu> :)
05:34:14 <jle`> b0llu: the way you have it isn't too practical, because usually indexing happens with indexes you get at runtime
05:34:27 <jle`> use a type like Finite
05:34:30 <jle`> http://hackage.haskell.org/package/finite-typelits
05:34:40 <jle`> a 'Finite n' is a type with n inhabitants
05:34:50 <b0llu> jle`: ooh
05:34:53 <b0llu> jle`: interesting
05:34:55 <b0llu> jle`: thanks :D
05:34:58 <jle`> and it has a convenient Num/Integral instance
05:35:07 <jle`> so you can use fromIntegral on it to get a number from 0 to (n-1)
05:35:08 <b0llu> jle`: omg haskell type level magic feels like rediscovering haskell all over again ^_^
05:35:12 <b0llu> neat
05:35:19 <jle`> ^_^
05:35:25 <b0llu> <3
05:35:45 <b0llu> jle`: I'm just worried about usability though. Already only GHC 8.0.1 is supported
05:35:48 <b0llu> and higher
05:35:53 <b0llu> because of @ usage and all
05:37:33 <jle`> yeah, it's something you have to live with :|
05:37:49 <b0llu> :(
05:39:12 <ph88^> hi guys
05:39:59 <dsub> hola
05:40:24 <ph88^> this code works https://paste.fedoraproject.org/503063/14813691/ however  foo = F (Q (B2 "hello"))  and i don't want to apply the biplate when Bar is using constructor B2, only when it's using constructor B  .. how can i achieve this ?
05:53:07 <kuribas> How do you solve "temporary actions" in reactive banana?
05:53:27 <kuribas> Like drawing a rectangle by dragging the mouse in a drawing app.
05:54:26 <merijn> kuribas: What does the "temporariness" of the action have to do with things?
05:54:53 <kuribas> merijn: well it should only use the mouse event while dragging, not afterwards
05:55:41 <kuribas> Say mouse down: mouse event => change size of rectangle, after mouse up, select all objects in rectangle.
05:55:49 <merijn> kuribas: I don't know reactive-banana that well, but let me describe an example
05:56:18 <merijn> kuribas: Suppose there's a "draw shape" type, I'd assume it has a monoid instance where mappend composites shapes and mempty is the empty shape
05:56:52 <merijn> kuribas: Drawing something for the duration of a mouse click would be a Behaviour that returns a rectangle based on mouse coordinates during said mouse event and then mempty after
05:56:53 <Aruro> \quit
05:57:45 <kuribas> merijn: yes
06:01:40 <kuribas> merijn: what if it's more complicated?  For example, the first left mouse click starts drawing a line, the second one stops drawing it.
06:02:11 <kuribas> (in a certain "mode" of the app)
06:03:20 <merijn> kuribas: Mode switches would be an event and the actual current mode would just be a Behaviour that has the same value as the last fired mode event
06:05:01 <kuribas> I wonder if I could make a continuations based behaviour...
06:05:16 <kuribas> Which handles mode switches implicitly.
06:06:03 <merijn> kuribas: Well, you could have "Behaviour (Foo -> Bar)" where the function is mode aware
06:06:46 <merijn> "Behaviour (Behaviour CursorState -> SelectShape)" ? :)
06:06:54 <merijn> Or rather
06:07:50 <merijn> "mouseHandler :: Behaviour (Behaviour CursorState -> Behaviour SelectShape)", "mouse :: Behaviour CursorState", and then combine those things
06:08:45 <kuribas> ok
06:09:38 <merijn> kuribas: The biggest problem (or advantage, depending on your point of view) that you need to rethink common design of things like UIs to make the description not imperative :)
06:11:34 <kuribas> yeah.  So tool selection would result in a behaviour (Behaviour ToolMode).
06:11:51 <merijn> kuribas: Right
06:13:48 <kuribas> Then drawing the line would be "isDrawingLine :: Behaviour Bool"
06:19:36 <comerijn> The you can have "currentMode :: Behaviour Mode" and "tools :: Mode -> Canvas -> Canvas" for your tools, so that "currenTool :: Behaviour (Canvas -> Canvas); currentTool = tools <$> currentMode"
06:22:17 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard http://adventofcode.com/2016/leaderboard/private 43100-84040706
06:23:49 <anks> hi, im trying to get ghcjsi working.. Is there any version of ghcjs that supports --interactive yet? This is the error i receive ghcjs-0.2.1.9007001-8.0.1.bin: --interactive is not yet supported.
06:26:13 <danza> anks, try in #ghcjs ... about versions of GHCJS ... is there any? I didn't know it was versioned, yet
06:29:29 <tsahyt> Hello! I'm about to write some testing code for a parser and I was wondering what the best way to go at it would be. I was thinking of setting up positive and negative examples, but maybe there's a better/additional way
06:30:04 <luite_> danza: i have sometimes bumped the version number when the object format changed, to prevent confusing errors
06:30:26 <tsahyt> I was thinking of also testing with a pretty printer, i.e. generate ASTs first, then use the fact that parsing the printed AST must be equal (or at least equivalent) to the original AST, but that leaves me with the problem of testing the pretty printer
06:30:53 <anks> danza, luite_: so I should join ghcjs and ask there?
06:31:16 <luite_> anks: --interactive was dropped temporarily from the 8.0 branch due to changes in the underlying mechanism, unfortunately it measn that you have to use 7.10 to get ghcjsi for now
06:31:37 <luite_> anks: you could, but i'd probably give you the same answer there ;)
06:31:46 <anks> damn :|, this will be painful
06:32:29 <anks> or maybe not, i need to learn how to sandbox development independently of systems compilers
06:32:32 <anks> :)
06:33:51 <anks> thanks anyway and <3 for ghcjs
06:34:12 <anks> are there any plans on resuming ghcjsi support?
06:34:21 <luite_> i use a fairly primitive system where i have a shell script that adjusts the PATH environment variable. i think that for a cabal sandbox, you could perhaps add a config file that sets ghc = ghc-8.0.1 or similar
06:34:53 <luite_> anks: yes, shouldn't take too much longer, but i have to admit that until i have it working again, i'm not sure how much work it's going to be
06:35:30 <anks> Ok, I'm going to try something like this. Thanks again
06:50:55 <tsahyt> @hoogle [IO a] -> IO [a]
06:50:57 <lambdabot> Control.Concurrent.ParallelIO.Global parallel :: [IO a] -> IO [a]
06:50:57 <lambdabot> Control.Concurrent.ParallelIO.Global parallelInterleaved :: [IO a] -> IO [a]
06:50:57 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
06:51:14 <merijn> tsahyt: Sounce like you want sequence
06:51:17 <merijn> :t sequence
06:51:18 <tsahyt> I do indeed
06:51:20 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
06:51:34 <tsahyt> merijn: I had it mixed up with sequence_
06:51:39 <merijn> and/or mapM, depending on how you got that list :p
06:53:02 <tsahyt> merijn: I'm just fighting tasty and hspec here. tasty-hspec produces IO TestTree, tasty everywhere else seems to want a pure TestTree
06:53:08 <tsahyt> sequence does just fine
06:55:29 <ph88^> this code works https://paste.fedoraproject.org/503063/14813691/ however  foo = F (Q (B2 "hello"))  and i don't want to apply the biplate when Bar is using constructor B2, only when it's using constructor B  .. how can i achieve this ?
07:33:33 <sdx23> Is there some haskell <-> mathematica dictionary out there? I'm close to getting insane.
07:33:56 <c_wraith> most of haskell doesn't have analogues in mathematica
07:34:46 <c_wraith> and a good portion of mathematica is much more awkward in Haskell, for that matter
07:35:59 <quchen> In terms of type safety, Mathematica is much closer to Lisp than to Haskell.
07:36:15 <quchen> Lists are everywhere, and you have to keep a lot in your head.
07:37:09 <sdx23> c_wraith: I've more the contra impression. Lots of awkward mathematica stuff coming out of my fingers. However, that may well be because I've no clue of what I'm doing...
07:37:28 <c_wraith> Their underpinnings are entirely different.  Mathematica is based on term rewriting.  Haskell is based on graph reduction.
07:39:28 <merijn> c_wraith: I fail to see how those are "entirely different"
07:39:42 <merijn> I would, in fact, consider them "basically the same"
07:39:53 <merijn> Depending on the order in which you rewrite
07:40:20 <geekosaur> only at a high level; both are rewriting, but mathematica is algebraic, while haskell is numerical
07:41:20 <geekosaur> well. for values of "numerical" that might not actually be numeric, but work out that way if you're actually using numbers
08:01:46 <kuribas> Why should I avoid typeclasses?  I dislike having different functions meaning the same thing...
08:02:14 <kuribas> I mean + working for Int, Double, etc... is pretty convenient.
08:02:26 <mniip> what made you think you should?
08:03:32 <kuribas> Some people think so.
08:04:07 <mizu_no_oto_work> Typeclasses are great for some things, and less good for others.
08:04:16 <kuribas> That libraries with many typeclasses are a design flaw.
08:05:17 <mizu_no_oto_work> There's a lot of people who think that typeclasses should come with laws rather than being entirely ad hoc.
08:05:39 <kuribas> mizu_no_oto_work: that makes sense.
08:05:51 <mizu_no_oto_work> Additionally, typeclasses aren't good if you want heterogenous collections
08:06:20 <kuribas> what do you mean?
08:06:47 <mizu_no_oto_work> like, "Renderable r => [r]" isn't that useful if you have separate Triangle, Square, etc. types
08:08:55 <mizu_no_oto_work> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:08:55 <kuribas> Right, you need a union type.
08:09:36 <mizu_no_oto_work> Or existential quantification, if you're trying to shoehorn a typeclass in there
08:10:21 <mizu_no_oto_work> i.e. data AnyRenderable = forall r. Renderable r => AnyRenderable r
08:10:37 <mizu_no_oto_work> But there's no real reason to use that over a record of functions
08:11:51 <kuribas> right
08:12:17 <mizu_no_oto_work> On the other hand, typeclasses are really good for some other things.  There's a reason, for example, that C# doesn't have a Functor interface, but instead chucks it into IEnumerable
08:13:09 <mizu_no_oto_work> Namely, the type system of C# forces them to downcast the return type of map ('select', in C#) to the type of the interface that it's declared in
08:15:03 <mizu_no_oto_work> Since they don't have higher kinded types, so you can't play tricks with f-bounds (i.e. "interface Functor<F implements Functor<F>>" where )
08:15:19 <Younder> C# is type sensitive as I recall, why is that?
08:17:15 <mizu_no_oto_work> Younder: type sensitive?
08:18:27 <ertes> helo
08:19:10 <Younder> ertes, hello to you too
08:19:12 <glguy> 501 Syntax: HELO hostname
08:22:18 <mizu_no_oto_work> Younder: what do you mean by C# being type sensitive?
08:23:14 <Younder> mizu_no_oto_work, Well I mean .NET (or mono) is type sensitive.
08:24:07 <Younder> mizu_no_oto_work, Anyhow as an Haskell-er would you not prefer F#.
08:24:31 <mizu_no_oto_work> Type sensitive as in the semantics of a term depend on its type?
08:25:24 <c_wraith> depends on how much you like higher-kinded abstraction. you might consider F# to be a painful read in that it's so close, and yet so far. C# is just different. 
08:25:57 <ertes> in other words F# has the same type system as C#
08:26:03 <mizu_no_oto_work> I haven't used C# since mid college, at a couple co-ops.  But the IEnumerable thing is a good example of a place where OO falls on its face when trying to make small interfaces.
08:29:05 <c_wraith> that said, Foldable also failed to be small in the name of performance. :) 
08:30:04 <mizu_no_oto_work> c_wraith: IEnumerable isn't small in the name of performance
08:30:27 <c_wraith> bad grammar on my part. 
08:30:36 <mizu_no_oto_work> It's large because once you call any of the IEnumerable methods, all you can do is call IEnumerable methods
08:30:42 <c_wraith> in the name of performance Foldable failed to be small and simple. 
08:31:07 <mizu_no_oto_work> you've forgotten the fact that you're working on a List or a Tree and only remember the fact that you're working on an IEnumerable
08:31:39 <geekosaur> there's a fair difference between "optimization hack" and "needed for the thing to work at all"
08:31:58 <mizu_no_oto_work> Which means IEnumerable has to be large to be remotely useful as an interface.
08:34:36 <c_wraith> hmm. I was just thinking about null (in the context of Foldable) and its interaction with infinite Cons lists vs infinite Snoc lists
08:35:03 <c_wraith> in that case, it's a bit more than a performance hack to move null into the class. 
08:36:10 <c_wraith> unless.. unless you use unamb. 
08:37:31 <c_wraith> though that approach will still fall down with certain data structures. there is no solution in terms of foldMap that's correct for all structures, I think. 
08:44:51 <ph88^> anyone going to a lecture about quickcheck this evening ?
08:49:23 <ph88> :)
08:53:16 <roconnor> ski: Coq can prove the consistency of Z, and proof the consistency of ZF under some mild assumptions IIRC.
08:53:45 <roconnor> I worry that Z is not consistent though.
08:57:20 <b0llu> how do I get lambdabot to send a message?
08:57:46 <kadoban> @tell b0llu like this?
08:57:46 <lambdabot> Consider it noted.
08:57:57 <b0llu> oh thanks
08:58:00 <b0llu> :)
08:58:06 <kadoban> 'welcome
09:07:08 <Gurkenglas_> Does "Z is consistent" mean anything when whether it's true depends on your axioms?
09:16:36 * JuanDaugherty assumed it was the standard ring of integers
09:19:48 <b0llu> is there a canonical ".travis.yml" file that I can look at?
09:19:53 <b0llu> I'm trying to adapt this
09:19:54 <b0llu> https://github.com/bollu/symengine.hs/blob/master/.travis.yml#L57
09:20:04 <b0llu> it is frustrating to have to match GHC and cabal version
09:20:33 <sm> I think fpcomplete/michael snoyman blogged about it
09:20:58 <b0llu> it was somewhat old IIRC
09:21:01 <b0llu> I borrowed mine from stack
09:21:10 <b0llu> but even they do the same thing
09:21:15 <b0llu> hardlink cabal and GHC versions
09:21:20 <b0llu> it's pretty sucky :(
09:21:24 <b0llu> is there a better way?
09:23:10 <sm> what's the problem exactly ?
09:23:25 <c_wraith> isn't that the point of Travis? 
09:23:39 <c_wraith> testing on specific, fixed configurations? 
09:29:29 <Ordentlig> Hi, how can you print a tree with indentation?
09:30:09 <Ordentlig> data Tree a = Empty | Node a [Tree a]
09:30:11 <Ordentlig> of this form
09:30:32 <Ordentlig> Node 'r' [Node 'b' [Node 'a' [],Node 'c' [Empty]],Node 'c' [Node 'a' [Empty]]]
09:30:43 <Ordentlig> pretty unreadable in this current form.
09:31:05 <Ordentlig> would be nice with new line and 4 space indentation per level.
09:31:08 <kuribas> @hoogle foldlM_
09:31:08 <lambdabot> MonadUtils foldlM_ :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
09:37:40 <Ordentlig> :/
09:39:28 <Gurkenglas> I'd first define a catamorphism b -> (a -> [b] -> b) -> Tree a -> b, and then use it by combining lists of lines of a shown subtree into the list of lines for the shown whole tree
09:40:27 <Gurkenglas> (Note that defining your recursive data structure using Fix or an equivalent gives you catamorphisms and more for free)
09:43:18 <Ordentlig> kuribas, thanks, I haven't learnt about monads yet
09:44:06 <kuribas> Ordentlig: erm, you're welcome?
09:44:34 * kuribas not sure what he did...
09:50:12 <Gurkenglas> kuribas, Ordentlig thought your lambdabot query was a response to his question
09:50:48 <kuribas> Gurkenglas, Ordentlig: it wasn't, but I'm glad it helped ;)
09:51:36 <Gurkenglas> I think he just felt obligated to thank an honest attempt at helping :P
09:51:47 <kuribas> lol
09:51:50 <Ordentlig> kuribas, it wasn't? lol
09:54:07 <drdo> It would be so nice if we could overload constructor names
09:54:23 <sm> #haskell discussions often spawn emergent answers
09:55:11 <kuribas> drdo: that would introduce ambiguity.
09:56:34 <Gurkenglas> Ordentlig, http://lpaste.net/5472767145265856512
09:58:08 <drdo> kuribas: How so? Obviously type inference might no longer be possible in general, but is there a more serious problem?
09:58:43 <kuribas> drdo: that sounds like a serious problem.
09:59:00 <drdo> Doesn't sound like a serious problem to me
09:59:27 <kuribas> drdo: type inference is a core part of haskell.
10:00:51 <kuribas> drdo: haskell without type inference isn't haskell.
10:01:02 <drdo> ...
10:01:51 <Tuplanolla> Type inference already breaks with type families, higher-rank types and other such things, so overloaded record fields seems like a minor thing.
10:02:12 <drdo> I don't mean record fields, I mean constructors
10:02:24 <Ordentlig> Gurkenglas, thanks a lot!
10:02:31 <Tuplanolla> Sure, why not.
10:02:50 <drdo> Tuplanolla: Yeah, it sounds fine to me at a first glance
10:02:56 <kuribas> It would make errors harder.
10:03:01 <drdo> But maybe there are sketchy interactions
10:03:32 <drdo> kuribas: So go back to the simply typed λ-calculus
10:03:40 <kuribas> drdo: what would you gain?
10:04:02 <drdo> The ability to not have to make up silly names for things
10:05:13 <drdo> Specially when you want to have types that are morally a subtype of another by removing certain construction rules
10:06:01 <kuribas> Tuplanolla: what I would like is partial record names returning Maybe?
10:07:36 <seishun> is there a way to import Data.Map so that thing that conflict with Prelude need to be prefixed with Map. but the rest can be used as-is?
10:08:04 <ertes> kuribas: i don't mind adding features that break type inference for those parts that use the feature…  in particular dependent types break type inference, so if we ever want to get there, we will have to live with limited type inference…  but if you only use the parts of the language where type inference works right now, it will still work
10:08:06 <Lokathor> https://ghc.haskell.org/trac/ghc/ticket/2189 :(
10:08:21 <mettekou> seishun: import Data.Map hiding (lookup) import qualified Data.Map (lookup)
10:08:25 <ertes> seishun: import qualified Data.Map as Map
10:08:30 <ertes> oh
10:08:33 <ertes> sorry, misread your question
10:08:40 <mettekou> Oops, that lookup was unnecessary at the end.
10:08:52 <seishun> let me try that...
10:08:52 <mettekou> No wait.
10:08:53 <kuribas> seishun: import qualified Data.Map (thingthatconflicts); import Data.Map hiding (thingthatconflicts)
10:09:31 <seishun> wait, is adding "as Map" at the end not necessary?
10:09:32 <mettekou> kuribas seishun: Yeah, my initial answer/kuribas' answer is correct.
10:09:53 <seishun> "import qualified Data.Map as Map"
10:09:55 <mettekou> seishun: If you want to refer to it as Map instead of Data.Map, then it is.
10:10:05 <seishun> oh, that makes sense
10:15:06 <ertes> seishun: it's probably more convenient to just import it qualified
10:15:09 <Ordentlig> Gurkenglas, http://sprunge.us/OOYV
10:15:13 <ertes> type M.lookup isn't that bad
10:15:29 <Gurkenglas> Yes?
10:15:30 <ertes> seishun: (also for most use cases you'd probably want to use Data.Map.Strict instead)
10:15:36 <seishun> Map.! however looks silly to me
10:15:49 <Ordentlig> Gurkenglas, http://sprunge.us/AiCf
10:15:50 <ertes> seishun: you get used to it
10:15:58 <kuribas> seishun: M.! is a bit better
10:16:09 <Ordentlig> Gurkenglas, I get these errors, I don't get it :(
10:16:24 <kuribas> seishun: I use one or two letter prefixes normally.
10:17:35 <Gurkenglas> Ordentlig, it's saying that your type signature is "Tree a -> [String]", but "unlines . go" is "Tree a -> String"
10:17:54 <savrem> seishun, you can do import Data.Map ((!)) and import qualified Data.Map as Map, as long as you don't already have a different ! in scope that'll work
10:19:06 <seishun> I think I'll prefer consistency
10:20:05 <kuribas> seishun: if you have another one in scope you can always hide it.
10:20:47 <ertes> i wouldn't mind having a slightly different syntax for qualified operators
10:21:06 <seishun> I guess it will look weird if I use some Map functions qualified and others unqualified
10:21:07 <ertes> but i don't know what it would look like
10:21:27 <ertes> seishun: i do that with Data.Sequence all the time
10:21:56 <ertes> import Data.Sequence (Seq, ViewL(..), viewl)
10:22:03 <ertes> but use stuff like 'split' qualified
10:25:21 <seishun> I see, I'll do that too then
10:26:29 <ertes> i wouldn't do it with (!) though…  'viewl' is fine, because the probability of confusing it with something else is rather small
10:46:35 <pt16> Any updates on Haskell summer of code for 2017 ?
10:50:35 <athan> Are intersection types practical? If so, how?
10:51:56 <ertes> athan: what do you mean by "intersection"?
10:53:52 <athan> ertes: I'm reading Barendregt right now; something like "terms have a set of applicable types"
10:54:41 <athan> and it seems like there's an intersection operator of those sets. I think these are the "Curry" lambda type systems, while stuff like the calculus of constructions is a Church type system, meaning a term has a unique type (if it is legal)
10:55:22 <athan> (and I think terms can be derived from types in the case of CoC, because of its wicked injectivity or something)
10:59:42 <myrma> how can I convert generically a Real a => a to a Double ?
11:00:42 <athan> myrma: I think it needs to be Floating too
11:00:55 <athan> or something like that. I don't have a ghci up :x
11:01:06 <athan> @type sin
11:01:08 <lambdabot> Floating a => a -> a
11:01:14 <myrma> ok but what if i want to include Int, Integer, CInt, etc... ?
11:01:17 <athan> what function are you using myrma?
11:01:28 <athan> you'll need to convert with `floor` etc
11:01:34 <athan> @type round
11:01:38 <lambdabot> (RealFrac a, Integral b) => a -> b
11:01:53 <athan> @type fromIntegral
11:01:57 <lambdabot> (Num b, Integral a) => a -> b
11:02:10 <myrma> yeah but I have to make two functions for both cases then
11:02:22 <myrma> one for Integral a => a and another for Floating a => a
11:02:54 <myrma> what I want is a generic way to do this
11:03:24 <Berra> I cannot just looking at the definition of Monoid grasp how getSum and getProduct can return the correct results using the same Monoid http://lpaste.net/3564619849755787264 ? Anyone?
11:05:02 <hashme_> hey guys
11:05:11 <hashme_> I have been learning functional programming and haskell for a couple of weeks, and I would like to contribute to a beginner open source project in haskell
11:05:22 <hashme_> Can you guys tell me about any projects that I can contribute to?
11:05:32 <hashme_>  Mostly beginner work, so that I learn more
11:08:38 <athan> Berra: Sorry I can't open that link (my tablet breaks down worse than my truck). What do you mean, though? Are you wondering how Sum/getSum work?
11:09:01 <athan> @type Sum
11:09:02 <lambdabot> a -> Sum a
11:09:05 <athan> @type getSum
11:09:07 <lambdabot> Sum a -> a
11:09:34 <athan> given that `a` is a Num, then it will use summation as the operator for mappend, and 0 for mempty
11:09:37 <athan> Berra ^
11:09:50 <athan> similarly, Product uses * as mappend, and 1 as mempty
11:10:05 <Berra> athan: I'm wondering how the Monoid carries the entire history of the monoid (3 <> 4 <> 5 <> 6) so that both product and sum are correct.
11:10:31 <athan> > foldMap $ fmap Sum [1,2,3,4,5]
11:10:34 <lambdabot>  error:
11:10:34 <lambdabot>      • Couldn't match expected type ‘a -> m’
11:10:34 <lambdabot>                    with actual type ‘[Sum Integer]’
11:10:34 <Tuplanolla> Nothing is done until the instance is known, Berra.
11:10:36 <athan> er derp
11:10:41 <athan> > fol $ fmap Sum [1,2,3,4,5]
11:10:43 <lambdabot>  error:
11:10:43 <lambdabot>      • Variable not in scope: fol :: [Sum Integer] -> t
11:10:43 <lambdabot>      • Perhaps you meant one of these:
11:10:45 <athan> agh keyboard
11:10:50 <Berra> Given a Monoid x defined from (3 <> 4 <> 5 <> 6). How is the number series stored inside the monoid?
11:10:51 <athan> > mconcat $ fmap Sum [1,2,3,4,5]
11:10:54 <lambdabot>  Sum {getSum = 15}
11:11:24 <sophiag> hi. i'm new to haskell and trying to get this port of the UNIX wc program working in order to wrap my head around composing State monads. right now it's compiling, but i'm having some trouble printing the output just testing it in GHCi: http://lpaste.net/349832
11:11:42 <athan> Berra: The type itself designates the behavior: Sum is a type
11:12:38 <athan> the type is like a modifier for the `Num a`, giving it a Monoid instance that's specific
11:13:18 <Cale> sophiag: You probably meant evalState (clwcm "this is a test") ..
11:13:35 <athan> You can't have duplicate instances for a single type, so we use these Sum and Product to specify which we'd like to use, but in a way that doesn't forget anything
11:13:57 <Berra> athan: Sure but what I'm not getting is the data structure of the Monoid. How the number constituents of the Monoid is accessed when Sum or Product need to calculate the result.
11:14:02 <Cale> sophiag: Note the type signature of clwcm says that it's a function which accepts a String argument, so you want to apply that first, to obtain the State computation that you're going to run
11:14:08 <athan> Monoid isnt data
11:14:22 <Berra> athan: Which is why I'm not getting how it's done
11:14:25 <athan> monoid is a template
11:14:26 <Tuplanolla> Each `<>` is secretly passed a dictionary that contains the functionality for the specific type, Berra.
11:14:34 <athan> the data is in Sum and Product
11:14:37 <athan> @type Sum 1
11:14:39 <lambdabot> Num a => Sum a
11:14:47 <athan> @type 1
11:14:49 <lambdabot> Num t => t
11:14:51 <Cale> athan: When someone says "the monoid", they're referring to the type which is an instance of Monoid though.
11:15:08 <Tuplanolla> You can generate GHC Core from your code and see how, Berra.
11:15:09 <sophiag> Cale: yeah, missed the parens. but i still get an error that it's not an instance of Show
11:15:26 <Cale> sophiag: right, because there's still another argument to provide: the initial state
11:15:35 <sophiag> ah, i see
11:15:43 <Berra> When you have some (Monoid a, Num a) => a. And that was constructed using (3 <> 4 <> 5). I can apply both getSum and getProduct to the same monoid. I don't get that.
11:16:13 <athan> well, no you can't Berra
11:16:18 <athan> look at the type of getSum
11:16:28 <athan> it needs to be a `Num a => Sum a`
11:16:36 <athan> not just any old monoid
11:17:47 <kuribas> > (Sum 3 <> Sum 3, Product 3 <> Product 3)
11:17:50 <lambdabot>  (Sum {getSum = 6},Product {getProduct = 9})
11:18:21 <Berra> http://lpaste.net/4631863920812883968 This compiles and produces the expected results. I don't get why. And from what you're saying it appears you think this should not work. 
11:18:25 <athan> > bimap getSum getProduct $$ -- will it blend? :D
11:18:27 <lambdabot>  <hint>:1:48: error:
11:18:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:18:30 <athan> aw shoot
11:18:52 <athan> can you point lambdabot to previously evaluated expressions?
11:19:26 <Berra> >bimap getSum getProduct $$
11:20:16 <AbelianGrape> Anyone use Persistent? I'm trying to do an "upsertBy" to replace a database entry with a unique label, but I'm getting uniqueness constraint violation errors. The whole point is that I want to replace something that has a unique key with a different thing with the same unique key
11:20:25 <kuribas> :i Sum
11:21:01 <athan> kuribas: :i isn't lambdabot friendly :/
11:21:03 <Berra> athan: Not able to read the paste?
11:21:09 <kuribas> Berra: it works because Sum has a Num instance.
11:21:45 <kuribas> Berra: so the literal 3 will become (Sum 3)
11:22:34 <Berra> kuribas: But at sum point doing multiplication on the Sum 12 isn't the same as multiplying the numbers leading up to that sum
11:23:24 * athan 's pun sense is tingling
11:23:42 <kuribas> > getProduct (3 <> 4 <> 5)
11:23:45 <lambdabot>  60
11:23:59 <kuribas> Berra: that looks correct
11:24:15 <athan> > getSum (3 <> 4 <> 5)
11:24:16 <lambdabot>  12
11:25:22 <kuribas> Berra: the instance definition for fromInteger is probably: fromInteger i = Sum $ fromInteger i
11:25:40 <kuribas> Berra: so it becomes "getSum (Sum 3 <> Sum 4 <> Sum 5)
11:26:22 <kuribas> Berra: don't forget that number literals are overloaded.
11:26:48 <sophiag> Cale: welp, i got it to print...but it's not incrementing :/
11:28:16 <Berra> kuribas: I'm not even a tiny bit closer to understanding how both sum and product can be gotten from the same monoid. How is all the numbers stored? I guess they aren't - but how is it then possible...
11:28:25 <kuribas> Berra: you should read it as "getSum (fromInteger 3 <> fromInteger 4 <> fromInteger 5), with fromInteger == Sum for Sum.
11:28:29 <Berra> kuribas: You saw the paste?
11:29:04 <Berra> Sure, but does Sum store the previous numbers? How is the product calculated?
11:29:08 <kuribas> Berra: typeclasses use dictionary passing underneath.
11:29:30 <Tuplanolla> I mentioned this 15 minutes ago, Berra.
11:29:34 <Berra> kuribas: Well I guess I have to go read it then
11:29:40 <athan> Berra: Look at the definition for the Sum type, it's stored in the simplest way
11:29:42 <Berra> Tuplanolla: Sorry
11:31:08 <kuribas> Berra: the fromInteger and <> functions are passed with the dictionary.
11:31:51 <Tuplanolla> @google scrap your type classes
11:31:54 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
11:31:54 <lambdabot> Title: Haskell for all: Scrap your type classes
11:32:21 <Tuplanolla> Read that for more, Berra.
11:32:38 <Berra> So what's happening is that the definition of the Monoid is both computed using Product and Sum by invocation of getSum and getProduct?
11:33:32 <athan> Berra: Sum and Product, getSum and getProduct are all artifacts of their data type definitions
11:33:43 <athan> getSum is just an accessor, like how fst is for a tuple
11:33:47 <athan> @type getSum
11:33:48 <lambdabot> Sum a -> a
11:33:49 <kuribas> Berra: no, getSum and getProduct determine the instance.
11:33:50 <athan> @type fst
11:33:51 <lambdabot> (a, b) -> a
11:33:53 <Cale> sophiag: It seems there are a few places where you're setting the number in the state to 0 or 1... I'm not sure that's the right thing to do.
11:35:06 <sophiag> it should be incrementing it based on a true false. it's based on a hack in the C code
11:35:45 <Cale> Well, there's the one in wcmBody, that increments the previous value
11:37:17 <sophiag> oh, i think i got it
11:37:20 <Cale> sophiag: So let's see... this thing loops first over the entire input String, getting the state (n,w), and then setting it to (1,w), repeatedly, for each character
11:37:32 <kuribas> Berra: think of x as a function "x fromInteger mappend = fromInteger 3 `mappend` fromInteger 4 `mappend` fromInteger 5"
11:37:45 <Cale> and it's just returning the characters unchanged there in ccmBody, so that'll just result in the same String as the input in the end
11:38:34 <kuribas> Berra: and "xSum = getSum $ x sumFromInteger sumMappend"
11:38:40 <Berra> kuribas: Right, that helps
11:38:49 <Berra> kuribas: I want to see the core
11:38:58 <Berra> kuribas: -fext-core isn't a flag in my ghc
11:39:30 <sophiag> Cale: i got it to count characters....so almost there...
11:39:39 <Berra> kuribas: But I was under the impression that 1 <> 2 produced a monoid.. so any history of previous values is gone at that point.
11:39:43 <Cale> and then it loops over it again, this time setting the state to 0 or 1 depending on whether each character is a newline (and still passing along the 'w' part), but since it doesn't make any other decisions based on that, it reaches the end, and the state will be 0 or 1 there based on whether the last character in the input was a newline
11:39:47 <Berra> That 1 and two made up the monoid is gone.
11:40:24 <kuribas> Berra: which previous values?
11:40:43 <Berra> m = 1 <> 2  <> 3
11:40:55 <kuribas> Berra: that's m = 1 <> (2 <> 3)
11:40:58 <Berra> The resulting monoid (Monoid a, Num a) => a
11:41:29 <Berra> But isn't it reduced into a monoid.. how is the history of what values made up the final monoid left?
11:42:11 <kuribas> Berra: you're not making any sense
11:42:14 <kuribas> :t (<>)
11:42:16 <lambdabot> Monoid m => m -> m -> m
11:42:25 <kuribas> Berra: there is no history
11:42:30 <Tuplanolla> Pass `-ddump-simpl -dsuppress-all` if you want to see the related GHC Core, Berra.
11:43:29 <Berra> kuribas: mappend = (<>) ?
11:43:50 <kuribas> yes
11:46:21 <Berra> kuribas: Ok so looking at the core it's obvious yes that the monoid is sort of like a function you can call, but this goes against my intuition of the monoid type class.
11:46:39 <Berra> I thought it was a concrete value
11:46:43 <Tuplanolla> It's an implementation detail, really, Berra.
11:46:49 <sophiag> Cale: ah, i think the issue with this was that the example i took it from used both the writer and state monads and that was important in order to log characters, words, and lines. with just state i'd have to choose only one to keep a tally of
11:46:57 <kuribas> Berra: no, Monoid is a typeclass
11:47:02 <Berra> 1 <> 2 <> 3 = new monoid representing 6
11:47:11 <Cale> sophiag: I was considering mentioning that a Writer monad might be way more appropriate
11:47:31 <kuribas> Berra: why 6?
11:47:40 <Cale> sophiag: Writer will apply the operation for whatever monoid you choose to accumulate the values that you 'tell'
11:47:45 <sophiag> Cale: but then i need to use StateT to compose them?
11:48:02 <Tuplanolla> Theoretically, with a closed universe, it could evaluate the expression for all the instances and choose the appropriate one at the call site, Berra. However the only practical option is delaying the evaluation until the instance can be inferred and passed in.
11:48:23 <Berra> kuribas: To me it's not clear from reading the definition of the monoid how the entire combination stack would remain. In the core efter application of <> becomes a nested function application stored inside the value of the monoid.
11:49:06 <kuribas> Berra: "combination stack"?
11:49:10 <kuribas> Berra: what's that?
11:49:26 <Berra> My intuition was that when you mappend a monoid you get another monoid back... history is lost. It's just a monoid representing the current value that can be further combined with the binary operator.
11:49:26 <Cale> You might want StateT to maintain state from one character to the next, though I kind of find this whole thing to be a bit of a questionable application of the machinery :)
11:49:49 <Berra> kuribas: I was hinting at the nested applications of <> fromInteger
11:49:58 <byorgey> Berra: yes, but in order to do that you have to first decide *which* mappend operation to use.
11:50:46 <Berra> byorgey: Sure, but I don't get by what mechanics Haskell decides to just go out and create this underlying nested function containing all the history of all <> applications.
11:50:48 <sophiag> Cale: ha. it's an example from this paper: https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
11:50:48 <kuribas> Berra: your terminology is very confusing.
11:50:54 <Berra> It goes against my intuition.
11:50:54 <Cale> sophiag: You could just as well use a function parameter which just gets passed forward for that
11:51:05 <mnoonan> when you say "new monoid" you mean "new element of (the same) monoid"
11:51:16 <Berra> mnoonan: Yes
11:51:30 <kuribas> Berra: history isn't a haskell concept
11:51:31 <Berra> mnoonan: mappend :: a -> a -> a
11:52:02 <Berra> kuribas: Yet instead of having a Monoid a I somehow in core have a function containing a nested series of <> ?
11:52:55 <Berra> I expected that having a Monoid for a concrete type a if I mappend that with another a I will indeed get a Monoid a for a new value of that concrete type.
11:53:01 <byorgey> Berra: you have a function which, *given a choice of a particular instance of Monoid to use*, will apply the particular definition of <> for that instance and reduce 3 <> 4 <> 5
11:53:59 <byorgey> Berra: you keep saying "a Monoid", "the Monoid", but there is no such thing.  Monoid is a type class.  You can't have "a Monoid", but you can have a value of type  Sum Int, or a value of type [Char], or any particular type which is an instance of the Monoid type class
11:54:19 <Berra> byorgey: Ok - but to me it was not at all intuitive to realize that the applications of mappend would somehow be saved underneath.
11:54:26 <cocreature> jle`: ping
11:54:27 <c_wraith> Berra, it's important to keep type level and value level separate. values aren't monoids. types are monoids. 
11:54:44 <byorgey> Berra: they're not really "saved", it's just that they haven't been evaluated yet
11:55:08 <cocreature> jle`: nvm :)
11:55:09 <byorgey> they can't be evaluated yet, because we don't yet know which actual implementation of mappend to use
11:55:36 <byorgey> once you pick a specific type, and hence a specific instance of Monoid, the particular definition of <> for that type can be used
11:55:45 <Berra> byorgey: Yes it's starting to make sense to me but it was far, far from my intuition of what a type class was able to do.
11:56:00 <byorgey> Berra: I do agree that this is not intuitive.
11:56:03 <Berra> Or laziness, if that's what coming into play I guess. Non-strictness.
11:56:11 <byorgey> Or rather, it can be intuitive, but you probably have to retrain your intuition first.
11:56:15 <c_wraith> not laziness. 
11:56:19 <byorgey> It's intuitive to me, but I have been doing this for a while =)
11:56:33 <c_wraith> instance selection is (usually) done at compile time. 
11:56:35 <kuribas> Berra: I showed you an expansion for x.
11:56:45 <c_wraith> it's just deferred until the type is known. 
11:56:51 <Berra> byorgey: Sure. I'm glad for all your help. I hope I can get some better intuition for it now.
11:57:19 <kuribas> Berra: I see nothing in my expansion to suggest "saving" values, and "history".
11:57:23 <Berra> c_wraith: Yes I guess so, the core code revealed that to me.
11:57:59 <kuribas> Berra: core is difficult to read.  
12:00:09 <Berra> The way I have to bend my mind to get the proper intuition is that the definition of x = 1 <> 2 <> 3 really becomes a function waiting for a mappend. That realization was truly missing for me.
12:00:28 <Berra> Thanks a lot, all of you.
12:00:56 <kuribas> Berra: http://lpaste.net/4631863920812883968
12:01:29 <Berra> kuribas: Yes that's a perfect illustration of it
12:03:05 <kuribas> Isn't that why haskell choses a monomorphic instance for constants by default?
12:04:35 <kuribas> The dreader Monomorphism restriction?
12:07:18 <Berra> kuribas: The solution being always hand write rules - or does it go deeper than that?
12:07:29 <Berra> hand write signatures I mean
12:07:57 <kuribas> Berra: for toplevel yes.  Inside functions it can help too.
12:09:26 <tdammers> writing out types is a pretty good strategy anyway
12:09:31 <tdammers> type-driven development and all that
12:10:21 <kuribas> I am now starting to write signatures inside my functions, and I find my code easier to read.
12:12:00 <Berra> kuribas: That is to say for all values in even if no hinting is needed for the compiler?
12:12:11 <kuribas> yes
12:12:30 <Berra> kuribas: Makes code easier to get back into I would guess
12:12:38 <kuribas> Berra: type signatures are for the programmer as much as for the compiler.
12:12:40 <sophiag> Cale: here's my next try...http://lpaste.net/349832 not sure why i'm getting the error from the second tell and the Sum monoid? also don't quite understand monad transformers yet
12:12:43 <kuribas> Berra: exactly
12:13:25 <sophiag> oops link didn't show up: http://lpaste.net/349832
12:14:10 <Berra> sophiag: Depends on how bad the regex in ones IRC client is : )
12:15:43 <sophiag> i'm on a web client rn actually. doubt it uses regex
12:16:09 <sophiag> that's my next project to learn haskell though. regex parser ported from C
12:16:28 <Berra> sophiag: On a web client I'm even more certain it uses regex. Javascript's poor regex even.
12:17:55 <sophiag> true. all javascript parsing is regex and awful
12:18:18 <maerwald> and regex is not proper input validation, so half of the web is vulnerable =)
12:19:10 <Berra> kuribas: I find it interesting that this kind of underlying function nesting of mappends only happens if there are multiple instances for a specific type, otherwise the behavior follows my initial intuition.
12:19:50 <kuribas> Berra: no, it happens also if there is just one instance.
12:20:59 <kuribas> Berra: ghc can inline those of course.
12:23:12 <Berra> kuribas: Hm, you're right
12:23:57 <Berra> kuribas: Isn't this very inefficient for uses where there are long series
12:24:00 <Berra> of mappend
12:25:44 <kuribas> Berra: dictionary passing is slow.  That's why ghc does specialization and inlining.
12:34:50 <platz> in Cont/ConT hell... why does go_p2 print '7' *twice* ? http://lpaste.net/349843
12:37:29 <ssarah> can i use those conditionals pipes with where? like where x | y < 0 = 1 | otherwise = 0
12:45:45 <kuribas> > Just 2 <> Just 3
12:45:48 <lambdabot>  error:
12:45:49 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M363665810714...
12:45:49 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:51:59 <lyxia> ssarah: sure you can
13:03:40 <glguy> If you're doing adventofcode.com this year, join the #haskell leaderboard! Key in /topic
13:07:37 * mmaruseacph2 agrees with the above message
13:10:31 <Lokathor> ugh
13:10:54 <Lokathor> i've created the beginnings of a console app that strangely works on windows but not on linux
13:11:25 <Lokathor> all i want is unbuffered input!
13:13:12 <mmaruseacph2> look for hSetBuffering
13:13:35 <Lokathor> does not work
13:14:15 <Lokathor> the problem is that the terminal itself doesn't send the data in to the program for the program to read it in unbuffered mode
13:14:36 <c_wraith> set the terminal to unbuffered 
13:14:58 <Lokathor> that's the unportable part
13:14:59 <platz> i've determined that since p1 calls 'f' twice, p2 results in (k H7) being called twice
13:15:39 <Lokathor> so now I've got this code here: http://lpaste.net/349844
13:19:06 <Lokathor> alert readers will note that my main.hs has an unfortunate number of non-haskell lines within it
13:20:17 <monochrom> so does it mean you're fighting both Haskell buffering and C buffering? :)
13:21:19 <Lokathor> monochrom, haskell's buffering scheme is limited by what the terminal will do for it. hSetBuffering is fine for actual files on disk and all, but a terminal file "handle" is not so fine
13:22:17 <geekosaur> ghc's runtime on unix conflates no-buffering with termios
13:22:29 <Lokathor> oh
13:22:35 <geekosaur> (I'm not fond of this even if it's easier for simpler programs)
13:22:40 <Lokathor> well then it's just ghc's windows runtime that's at fault
13:23:02 <Lokathor> i actually found a GHC bug to this effect in the bughandler since 6.x
13:23:13 <Lokathor> pushed back over and over until 8.later
13:23:31 <sm> that's an impressive proportion of C code
13:23:34 <Lokathor> https://ghc.haskell.org/trac/ghc/ticket/2189
13:23:48 <geekosaur> likely. the windows dev population among ghc devs is frighteningly small
13:24:23 <c_wraith> isn't the number of people contributing windows code to ghc somewhere around 1?
13:24:23 <Lokathor> so the reason that i want this is because i want to be able to intermix terminal output and input
13:24:42 <geekosaur> I think I've seen exactly one who actually knows what;s going on; the rest are about at my level, know some things but we;re basically unix types scrambling in twilight
13:25:05 <Lokathor> that is, i want to be able to print out things while the user has half-entered a command without their command being lost
13:26:05 <sm> I wonder if http://hackage.haskell.org/package/concurrent-output might have some ideas
13:26:23 <Lokathor> oh my gosh
13:26:46 <Lokathor> Dependencies: ... , unix (>=2.7.0 && <2.8.0)
13:26:48 <Lokathor> Me: :(
13:26:57 <xcmw> How can a write a partially appliable (using type classes) version of:
13:26:57 <sm> ah, drat
13:27:00 <xcmw> type Maybify c b = (c b) => Maybe b
13:27:26 <Lokathor> ansi-terminal is what i planned to use though
13:27:59 <Lokathor> ansi-terminal + mvar + reading input 1 char at a time into a program-internal buffer that's always put on the bottom line
13:28:01 <lyxia> xcmw: doesn't seem like something you can partially apply
13:28:06 <lyxia> in any way
13:29:00 <xcmw> lyxia: I'm trying to use it a contraint
13:29:41 <ertes> is there a good FFI tutorial somewhere that covers stuff like importing constants from C headers and other boilerplate work?
13:30:22 <xcmw> lyxia: How do I contrain a type to Maybe a where (c a)? c is another contraint 
13:30:26 <Lokathor> ertes, my advice is to use this package here, https://hackage.haskell.org/package/inline-c
13:30:28 <nshepperd1> xcmw: that's a type, not a constraint
13:31:28 <xcmw> nshepperd1: How can I make it a constraint?
13:32:08 <lxpnh98> hello
13:32:17 <geekosaur> based on its name, you can't. Maybe is a type not a constraint
13:32:53 <geekosaur> well, maybe with a type equality constraint
13:33:14 <xcmw> geekosaur: String can be made into a contraint with ((~) String). Can the same be done with Maybe?
13:33:33 <mekeor> Lokathor: maybe just install gnu/linux :P
13:33:34 * mekeor is a missionary
13:33:42 <geekosaur> that's what I was just starting to set up. it can, if done right
13:33:44 <Lokathor> mekeor, but my steam games!
13:35:14 <Lokathor> mekeor, I do have 3 linux devices in my house. A rpi1, rpi3, and i386. GHC doesn't work period on rpi1, and stack doesn't work well on rpi3 (though it will work at all)
13:35:19 <lxpnh98> hi, I'm using gloss, and I want to have transparency in my images only using gloss itself. Anyone know how to do it?
13:35:19 <geekosaur> type Maybeify c = (c ~ Maybe) -- might work by itself, might need (c :: * -> *); I am still not good at type level shenanigans
13:36:50 <nshepperd1> xcmw: why do you even want this? Why not just write Maybe a in your type signature
13:37:07 <Ordentlig> Hi, is there a function like `print` that actually interprets '\n' and doesn't escape it?
13:37:27 <blackdog> Ordentlig: putStrLn
13:37:27 <Lokathor> Ordentlig, putStr "like\nthis?"
13:38:04 <geekosaur> also your understanding of what is happening is confused
13:38:15 <Ordentlig> blackdog, Lokathor thanks!
13:38:49 <blackdog> Ordentlig: "print x" translates to "putStrLn (show x)".
13:39:04 <blackdog> so you have to be putStrLn-ing something that is actually a string, not just showable
13:40:14 <xcmw> nshepperd1: I trying to implement records with GADTs and make a typing changing map function. I need the contraints on the record fields to be transformed correctly. If I apply Just to every field then the original constraint must be on the a in Maybe a.
13:41:09 <xcmw> nshepperd1: I have to use a constraint because I have to say that all of the field types are constrained by that constraint
13:41:57 <Lokathor> blackdog, actually, if you use print on a string you end up with extra double quotes
13:42:29 <Lokathor> I don't think Haskell has a way to do one thing for one type, and a default thing for any other type :/
13:42:32 <blackdog> Lokathor: yes. is that in conflict with what i said?
13:42:35 <geekosaur> it doesn't
13:43:06 <blackdog> if you wanted the behaviour of show except for the newlines, you could postprocess, i guess.
13:43:07 <geekosaur> > text "\n"
13:43:09 <lambdabot>  Terminated
13:43:20 <blackdog> but really, show's just for debugging anyway.
13:43:20 <geekosaur> heh, whoops, guess it dislikes that :p
13:43:29 <Lokathor> blackdog, i guess it's not a contradiction quite
13:43:51 <monochrom> > text "\n"
13:43:53 <lambdabot>  Terminated
13:43:59 <monochrom> oh, interesting
13:44:05 <monochrom> > not True
13:44:07 <lambdabot>  False
13:44:16 <blackdog> > text "hi"
13:44:18 <lambdabot>  hi
13:44:22 <geekosaur> probably our favorite side effect conflicts with prettyprinter implementation
13:44:44 <geekosaur> (that being what we're abusing)
13:44:45 <lxpnh98> sorry to be spamming here, but does anyone know how one wouuld go about implementing transparency in gloss (perhaps just using a color like pink and not rendering it)?
13:45:22 <ertes> Lokathor: thanks, that looks really useful
13:46:40 <geekosaur> lxpnh98, I saw the question but don't know the answer. Might ask on haskell-cafe list or stackoverflow if nobody here can help, or ask in a couple hours as the active users change over time
13:47:14 <lxpnh98> ok thanks anyway
13:48:10 <Lokathor> ertes, you asked at a good time, I just setup a "minimal inline-c example" of sorts, https://github.com/Lokathor/galaxy-break
13:48:44 <ertes> Lokathor: i appreciate it, but i'll try to do that myself first, in the context of my application =)
13:49:18 <Lokathor> no trouble
13:50:17 <Lokathor> so, if you use forkIO and async and such, but you don't use the -threaded option when you compile... what happens?
13:50:34 <Lokathor> will the compile fail? or the program explodes as soon as you actually try to run it or what?
13:51:02 <ggVGc> Lokathor: haskell threads are not OS threads
13:51:03 <geekosaur> Lokathor, green threads
13:51:05 <ggVGc> so it'll be fine
13:51:13 <Lokathor> ah
13:51:16 <ggVGc> it just won't ever run on different physical cores
13:51:20 <geekosaur> also, even the "non threaded" runtime is threaded; the I/O manager uses a thread
13:51:21 <ertes> Lokathor: most of the time it will just work, but if you do something that actually needs multiple OS threads, it will fail
13:51:21 <ggVGc> but it might not do that anyway
13:51:26 <geekosaur> (OS thread)
13:51:46 <Lokathor> i thoguht i read one time that the vty library requires -threaded or it'll crash, maybe they did something extra weird
13:52:03 <ggVGc> Lokathor: if you use forkOS and really need an os thread, then yes
13:52:06 <ggVGc> it'll break at runtime
13:52:11 <ggVGc> in some bad way probably
13:52:26 <Lokathor> vty just locks up
13:52:27 <geekosaur> that would surprise me because terminal output is rather aggressively anti-threading (even green threads)
13:53:03 <ertes> Lokathor: in other words: if in doubt, use -threaded…  sometimes it's not necessary, but most of the time it won't hurt either
13:53:05 <geekosaur> although maybe in dealing with that they did something that requires OS threads
13:53:23 <geekosaur> until you use the wrong GUI library and it breaks
13:53:39 <Lokathor> hmm
13:53:41 <ertes> Lokathor: the threaded RTS is just more complicated than the non-threaded one
13:53:54 <Lokathor> current vty doesn't seem to give that same warning in the docs, maybe they fixed that up
13:54:13 <geekosaur> (GUI libs are also often not thread friendly. X11 "works" only if you call a certain function, but that function tells it to wrap every single operation in a global lock)
13:54:21 <Lokathor> ertes, all i know about threaded is that i tried to profile a parallel computation one time and it went about 4x slower :P
13:54:49 <Lokathor> my workloads were too small to justify the context switching times
13:54:51 <geekosaur> that doesn't sound like threading... profiling kills optimization
13:54:55 <geekosaur> ah
13:55:30 <jackhill> ,/win 33
13:55:45 <geekosaur> note also that the threaded runtime is much better tested than the non-threaded one; you *can* find obscure bugs in the non-threaded runtime
13:56:12 <geekosaur> (maybe that was the vty issue, even)
13:56:43 <Lokathor> if threaded is better tested, why isn't it the default?
13:57:26 <geekosaur> because there are still too many FFI libs that break with OS threads, and quite a few Haskell packages defer to the FFI
13:57:47 * Lokathor shakes his fist at the sky
13:58:47 <geekosaur> that said, ghci is always threaded and most stuff seems to work. might just be people are afraid to pull the switch
13:59:36 <Rembane> I've heard that Functors, Applicative Functors and Monads should be taught in that order. Why should they be taught in that order?
13:59:46 <Lokathor> well, this is all good i guess. Step 1 of making my IO is done
14:00:05 <Lokathor> i guess concurrent-output or whatever it's called is basically what i want, but unfortunately unix only
14:00:40 <blackdog> Rembane: because they nest. if something is applicative, it's also necessarily a functor.
14:00:40 <Lokathor> Rembane, they're slightly increasingly complex and build directly upon one another conceptually
14:01:00 <Lokathor> it's like learning about polygons, then rectangles, then squares
14:01:48 <Rembane> blackdog, Lokathor: OTOH, if the only thing you do is optimizing the areas of rectangles you don't really need to know very much about other, more general shapes.
14:02:18 <dmwit> "should" is a loaded term.
14:02:36 <blackdog> Rembane: you will have to do exactly the same amount of learning either way, even if you only want to understand monads.
14:02:47 <shapr> Is there a bytestring cookbook? How to read in a file and do basic bytestring operations without using String?
14:03:14 <Rembane> blackdog, Lokathor: So if I want to go from concrete to abstract I could learn how to use them first with do-notation and all that, and then learn the principles behind them.
14:03:28 <Lokathor> shapr, https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#g:26 ?
14:03:32 <ertes> do i have to do anything extra when i declare 'c-sources' in my cabal file?
14:03:49 <Rembane> shapr: Use the same ideas and methods from String but with the functions from Data.ByteString and ask questions here if things misbehave.
14:04:02 <ertes> the linker doesn't seem to be able to find my C stuff
14:04:10 <Lokathor> ertes, nope. the c source genertated will be the same path as the .hs file it's being generated from. stack figures it all out somehow
14:04:12 <monochrom> Functor and Applicative are very easy to motivate.
14:04:25 <ertes> Lokathor: i'm not using stack
14:04:39 <Lokathor> well, i think cabal will also probably figure it out
14:04:40 <ertes> i'm using cabal (the library), i.e. Setup.lhs
14:04:56 <monochrom> And if you have gone over them first, by the time of Monad you will not have any issue with kind *->* classes.
14:04:57 <dcoutts> ertes: it often makes sense to declare the primary non-C-stdlib includes in the cabal file too in the includes field. This way cabal can check that the required includes are available on the system, or translation tools can more easily work out what system packages provide those .h files
14:05:16 <dcoutts> ertes: e.g. the zlib binding declares: includes: zlib.h, because that's what it needs on the system to work.
14:05:25 <ertes> dcoutts: my C source doesn't need any libraries/includes
14:05:36 <dcoutts> then you don't need that feature :-)
14:06:08 <ertes> (it will eventually in the real project, but currently it doesn't)
14:06:08 <dcoutts> ertes: nothing else springs to mind
14:06:12 <ertes> hmm
14:06:37 <dcoutts> ertes: do I take it from your "hmm" that something isn't working? :-)
14:06:55 <ertes> yeah, as i said the linker fails to find my C function
14:07:14 <Rembane> monochrom: Good point.
14:07:37 <Lokathor> ertes, does it work if you use the manual build steps it has an example at the bottom of the inline-c readme?
14:07:53 <hexagoxel> ertes: you have c-sources in cabal, right?
14:08:02 <dcoutts> ertes: using inline-c ? or classic ffi?
14:09:34 <dcoutts> ertes, Lokathor: note that inline-c's "feature" of the .c file ending up next to the .hs file is really a bug not a feature, though not so trivially fixed. But that's unrelated to this linker issue I expect
14:09:52 <Lokathor> what an odd bug
14:10:09 <dcoutts> well, by bug I mean mis-design
14:10:28 <dcoutts> putting generated files in the src dirs causes problems
14:13:14 <ertes> Lokathor: with the manual steps it works
14:13:19 <ertes> hexagoxel: yeah
14:13:24 <ertes> dcoutts: inline-c
14:13:41 <Lokathor> welp.
14:13:46 <ertes> while i appreciate the convenience of inline-c i feel that i should properly learn the FFI
14:14:13 <Lokathor> ertes, depending on how much C you need, quite possibly
14:14:14 <ertes> i don't like how it writes source files during compilation
14:14:22 <ertes> and then returns to depend on those files
14:14:24 <hexagoxel> ertes: i have a project with pure inline-c parts that works fine with cabal.
14:14:27 <ertes> it just feels wrong by design
14:14:33 <dcoutts> ertes: it's pretty straightforward, all the complicated stuff is in the marshalling anyway
14:14:35 <ertes> (but i can't blame inline-c for that)
14:14:48 <Lokathor> ertes, that's what happens with any TemplateHaskell stuff really
14:15:22 <ertes> dcoutts: yeah, and i suppose inline-c doesn't really save me from having to do that, right?
14:15:29 <dcoutts> ertes: not as far as I know
14:15:59 <ertes> dcoutts: are there any helpers to import things like constants from C headers?
14:16:32 <dcoutts> the sweet spot for inline-c afaik is avoiding having to have these little cbits/*.c files for writing little wrappers on the C side which are sometimes needed when the C api is not quite right for binding as-is
14:16:43 <dcoutts> ertes: hsc2hs is the classic approach for that
14:16:57 <ertes> dcoutts: is it the one you would recommend?
14:17:17 <dcoutts> the hsc2hs pre-processor is supported out of the box, and most of the classic FFI packages use it
14:17:28 <dcoutts> all the core libs that use ffi do
14:17:33 <ertes> i'll take that as a "yes" =)
14:18:28 <knupfer> Is anyone aware of a composable hash function in following sense:  f (f x ++ f y) == f (x ++ y)
14:19:40 <EvanR_> getting a weird effect with standard numeric classes and my real number type... i defined properFraction in RealFrac, and the default definition of round throws error "*** Exception: round default defn: Bad value"
14:19:50 <EvanR_> here is the code for round https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Real.html#round
14:19:57 <knupfer> In plain english: Where the hash of the hashes of chunks of a file are the same as the hash of the file
14:20:18 <ertes> knupfer: a cryptographic hash?  you may be looking for homomorphic encryption, which can be used as a hash, but it's all very experimental
14:20:29 <EvanR_> now, my signum function definitely only returns 1 or -1, never zero, either way its never _ which triggers an exception
14:20:56 <ertes> knupfer: you're looking for a hash function that is (at least) a semigroup morphism from the concatenation semigroup to some other semigroup
14:20:59 <lyxia> knupfer: do you know about merkle trees, it's not quite the same but sounds similar
14:21:13 <EvanR_> what weird behavior of case analysis of 1 and -1 am i missing
14:21:23 <ertes> knupfer: if you also require f mempty = mempty, you have a monoid morphism
14:21:26 <Koterpillar> knupfer: note that your _hash_ function has a _collision_ by definition
14:21:28 <knupfer> ertes: Perhaps a bloom filter would fit the bill
14:21:38 <Koterpillar> knupfer: and a way to generate collisions for arbitrary input
14:21:49 <ertes> knupfer: it does, if it fits your use case
14:22:30 <knupfer> Koterpillar: every hash function has collisions (besides id), but would you mind to elaborate how to generate arbitrary collisions?
14:22:33 <ertes> knupfer: but keep in mind that the naive bloom filter is easily oversaturated
14:22:56 <knupfer> ertes: Is 100.000 keys easily possible?
14:22:59 <Koterpillar> knupfer: by running that same hash function on the contents!
14:23:25 <knupfer> Koterpillar: I don't get it
14:23:29 <ertes> knupfer: with a large enough bloom filter yeah…  i think wikipedia has a formula for the size you need
14:23:40 <knupfer> ertes: Thank you!
14:23:41 <jle`> knupfer: i think you might have miswrote what you stated before
14:23:51 <Koterpillar> knupfer: for any input z, you need to split it into arbitrary x and y and replace z with f x ++ f y
14:23:52 <jle`> knupfer: do you mean that f x ++ f y = f (x ++ y) ?
14:23:54 <ertes> knupfer: but you're going to use megabytes of bloom filter
14:24:01 <lyxia> knupfer: the point of hash functions it to make collisions hard to do on purpose
14:24:15 <Koterpillar> knupfer: so z and (f x ++ f y) produce the same hash
14:24:15 <ertes> it's still a hash function, but not a very efficient one in any sense
14:24:18 <jle`> knupfer: because if you really meant f (f x ++ f y) == f (x ++ y), then just running f on the result should give you a collision
14:24:23 <Koterpillar> ^
14:24:32 <knupfer> Koterpillar: Yeah, exactly this property I was after
14:24:53 <Koterpillar> knupfer: ok, but note that this means you have collisions for arbitrary input
14:24:54 <ertes> i assume that the outer (++) is not quite the list function (++), but some mappend
14:25:18 <ertes> if you mean it literally, then yes, it's probably not a good idea
14:26:25 <lyxia> Have you heard about the XY problem
14:26:52 <knupfer> no
14:27:15 <knupfer> Thanks to all!
14:27:22 <monochrom> The XY problem: http://www.perlmonks.org/index.pl?node_id=542341 
14:27:34 <jle`> @where xy
14:27:35 <lambdabot> http://xyproblem.info/
14:27:59 <monochrom> wow it get its own dedicated domain and web server!
14:28:49 <jle`> not sure when this got added @where haha.  just took a shot in the dark
14:28:54 <ertes> dcoutts: yeah, i'm going with the FFI now…  unlike inline-c it doesn't break GHCi as far as i see, which is a *huge* bonus
14:29:09 <ertes> i don't want to give up rapid prototyping just because there is some C in there
14:29:13 <dcoutts> ertes: oh right yes
14:30:27 <ertes> there is also the Y->X problem (i don't know if there is a common name for it)
14:30:56 <ertes> you really want to do Y, but because Y is uncommon people assume that there has to be some X, and Y is the wrong solution for X
14:31:11 <lyxia> hahaha
14:31:48 <EvanR_> Y -> X problem... wait, do XY problems form a chu space
14:32:44 <ertes> #git suffers from that problem a lot…  a few weeks ago i learned the hard way that darcs-inspired workflows aren't well received by git people =)
14:34:50 <geekosaur> non-git workflows are in general not well received by git people. and often not by git :/
14:35:41 <geekosaur> (works up to a point and then explodes)
14:36:41 <ertes> i managed to recover pretty much all my darcs workflows with git without too many problems, otherwise i would still be using darcs
14:37:54 <ertes> the only issue i have is that unlike in darcs patches aren't first class in git…  i had to get used to the fact that patches only exist in my head now
14:38:19 <maerwald> sure they are, the dependencies are just more dumb
14:38:36 <maerwald> you can cherry-pick anything
14:39:55 <ertes> maerwald: the first thing any advanced git course taught me was that technically patches don't really exist, and each commit is pretty much a full representation of the state at that point (semantically)…  then things like "diffs" are actually on-the-fly notions
14:40:04 <ertes> and it makes a lot of sense to me
14:40:44 <maerwald> I commit is just a patch with one or more parent commits (which are patches)
14:41:25 <maerwald> if you cherry-pick a commit, you don't cherry pick the full state, so I slightly disagree there
14:41:55 <ertes> maerwald: technically you can make two completely unrelated repo states and declare that one is the parent of another…  "parent" is really just a dumb pointer notion: "this is my parent, because at the time when the user committed me that one was state they modified"
14:42:37 <ertes> cherry-picking uses that on-the-fly diff thing i mentioned earlier…  technically there is no such thing as "cherry picking"
14:43:21 <maerwald> where does cherry-picking use "diff"?
14:43:39 <maerwald> it just uses the commit, while ignoring the pointers to the parents
14:43:54 <ertes> you're at commit A and want to cherry-pick Y, and Y's parent is X:  git computes the diff between X and Y and applies that diff to A to reach B, then declares A the parent of B
14:44:01 <maerwald> I don't think so
14:44:22 <ertes> but that's what happens
14:44:43 <maerwald> see http://shafiulazam.com/gitbook/1_the_git_object_model.html
14:44:55 <maerwald> I don't see where a cherry-pick would need to do anything diff-like
14:46:44 <ertes> maerwald: yeah, if you read that carefully you will notice that a commit is a full snapshot, and "parent" is just a pointer to an arbitrary other commit
14:47:07 <ertes> there is sharing, but it's the same kind of sharing that haskell does:  semantically it's a copy
14:48:30 <Sonolin_> maerwald you can see what ertes is talking about by doing `git ls-tree COMMIT`
14:48:37 <Sonolin_> which should show the full project tree
14:49:08 <Sonolin_> I found it quite interesting because I was under the impression git only stored the diff
14:51:09 <sophiag> ok...going to try this again. i'm still having trouble with this code: http://lpaste.net/349832 . not sure why i'm getting an error from the second tell in the Writer monoid, but aside from that i haven't really wrapped my head around monad transformers yet so am not sure about how to compose everything at the end
14:52:01 <glguy> sophiag: You're applying tell to an Integer, but you need to apply it to a Sum Integer
14:52:16 <maerwald> ertes: indeed, I wonder how I mixed that up
14:52:19 <glguy> hence:     • Couldn't match type ‘Sum Integer’ with ‘Integer’
14:52:35 <sophiag> glguy: but isn't it the same as in the first tell?
14:52:43 <glguy> sophiag: no
14:53:12 <sophiag> i'm confused by that. they're both integers
14:53:21 <monochrom> At line 11 you're looking at "tell (1 :: Sum Integer)" not "tell (1 :: Integer)"
14:53:24 <maerwald> on the other hand... it should also work with diffs only forming a "linear" history, but that might have performance implications for checkouts I guess
14:53:27 <glguy> No, on like 11 you'll applying tell to a Sum Integer
14:53:34 <glguy> and then on like 19 to an Integer
14:53:36 <monochrom> Do not think that 1 is always an Integer.
14:53:44 <sophiag> ah ok
14:53:49 <xcmw> How can a make a type constraint that is (Eq a) => Maybe a that is of kind * -> Constraint
14:54:08 <sophiag> so i can just change the signature of my test function probably?
14:54:14 <monochrom> > 1 :: Complex Integer
14:54:16 <lambdabot>  error:
14:54:16 <lambdabot>      • No instance for (RealFloat Integer) arising from the literal ‘1’
14:54:16 <lambdabot>      • In the expression: 1 :: Complex Integer
14:54:18 <ertes> maerwald: yeah, it's really useful to know that…  it helped me a lot to make sense of git, and how i can map my darcs workflows to it (a lot of rebasing is part of the story, so i actively encourage it instead of having the much more skeptical attitude the wider git community seems to have)
14:54:20 <glguy> sophiag: Looks like it
14:55:10 <maerwald> merge commits are always funny to review, but fixing conflicts for huge rebases is just... not practical
14:55:14 <sophiag> hmm, except then it'll throw an error in the other call
14:55:29 <sophiag> i guess maybe i need to make that a Sum monoid as well
14:55:56 <kadoban> Did list comprehensions lack 'let' at some point? I'm look at some code from a paper and seeing stuff like [stuff | (x:xs) <- somelist, (b, c) <- [f a]]   was that end part necessary some part in the past?
14:56:18 <sophiag> glguy: ok, thanks. so fixed that one easily
14:56:20 <monochrom> you can easily have Num a => Bool -> a
14:56:38 <glguy> kadoban: Maybe they wanted to force the pattern match to happen
14:56:53 <monochrom> 1 is not always Integer but it is always Num a => a
14:56:57 <monochrom> @type 1
14:56:58 <lambdabot> Num t => t
14:57:00 <monochrom> QED
14:57:18 <kadoban> glguy: Hmmmm, it has different strictness than   let (b, c) = f a   you mean?
14:57:23 <glguy> yeah
14:58:10 <sophiag> monochrom: except i'm testing equivalency of Chars
14:58:17 <kadoban> Not seeing it, heh ...
14:58:44 <jgt> hey folks
14:58:58 <monochrom> > [ () | (b,c) <- [undefined] ]
14:59:00 <lambdabot>  *Exception: Prelude.undefined
14:59:06 <ertes> can i tell GHCi to load *.o files in the REPL?
14:59:25 <monochrom> > [ () | let (b,c) = undefined, d <- [()] ]
14:59:25 <jgt> sometimes I have a string that looks like "Found on: some company". I'd like to return just "some company" if the string begins with "Found on: "
14:59:28 <lambdabot>  [()]
14:59:45 <glguy> > [ () | let (_,_) = undefined]
14:59:45 <jgt> I know I can use Data.List.isPrefixOf somehow, but should I?
14:59:50 <lambdabot>  [()]
14:59:56 <ertes> maerwald: i'm going to write about my git workflow at some point…  rebase conflicts are rare for me simply because of the way i use it
15:00:04 <glguy> jgt: check out stripPrefix
15:00:06 <kadoban> glguy: That's ... weird. Hmm, maybe that's it.
15:00:16 <ertes> maerwald: and if they happen, there is usually a good reason for it other than: "git is too stupid to figure it out"
15:00:27 <jgt> glguy: that's perfect. Thanks!
15:01:20 <xcmw> I tried:
15:01:20 <xcmw> class (a ~ Maybe b, Eq b) => K a where
15:01:21 <xcmw> instance (a ~ Maybe b, Eq b) => K a where
15:01:29 <ssarah> is there a way to use pattern matching to see if it's a int number?
15:01:42 <xcmw> But got Not in scope: type variable ‘b’
15:01:45 <geekosaur> ssarah, as opposed to what?
15:02:02 <maerwald> ertes: https://www.youtube.com/watch?v=FMZ2_-Ny_zc this is sorta crazy (git-imerge)
15:02:14 <ssarah> Sorry, I get a string as an argument, and I want to process it different wether or not it can be turned into a number
15:02:17 <ssarah> an int number
15:02:30 <geekosaur> @index readMaybe
15:02:30 <lambdabot> Text.Read
15:02:30 <monochrom> look for Text.Read.readMaybe
15:03:08 <ertes> maerwald: bookmarked…  i'll watch it tomorrow, because it's late and i still need to get some stuff done =)
15:03:10 <geekosaur> then you can case on Nothing -> not a number; Just theNumber -> ...
15:05:08 <ertes> dcoutts: do you happen to have an answer?  do i *need* to restart GHCi to load extra objects?
15:06:52 <jgt> In this context, `author` either contains "some company", or "Found on: some company". In either case, I just want the "some company" part. What I have works, but is it idiomatic Haskell? Or would it be frowned upon? `fromMaybe author $ stripPrefix "Found on: " author`
15:08:32 <c_wraith> jgt, that looks good to me. 
15:08:53 <jgt> Ok, great! 😁
15:12:15 <geekosaur> ertes, afaik you must restart
15:14:08 <ertes> geekosaur: that's my impression as well…  thanks for confirming it
15:14:47 <geekosaur> I suspect that's not intrinsic, just not implemented. (I'd be looking at :add as a possible place to put it)
15:15:26 <geekosaur> ...ooooh
15:16:08 <geekosaur> ":set -lz" seems to work, or at least not be an error
15:21:37 <neonfuz> What is the nicest way to convert a "Map.Map a Integer" to an "IntMap.IntMap a" where the Integer in the first map is the key?
15:22:24 <monochrom> I would go through toList, swap, fromList
15:22:29 <neonfuz> would it to be to convert the first map to a [(a,Integer)] and then use IntMap.fromListWith
15:22:35 <neonfuz> monochrom: yeah
15:22:46 <monochrom> and a conversion from Integer to Int
15:23:12 <neonfuz> oh yeah, of course
15:26:14 <lpaste> xcmw pasted “Contraint Problem” at http://lpaste.net/349847
15:27:48 <Lokathor> http://lpaste.net/2159790997045772288 and now we can read a whole line of input
15:30:27 <Koterpillar> xcmw: why not: instance Eq b => K (Maybe b) where ?
15:32:36 <xcmw> Koterpillar: Don't I also need a class K declaration?
15:33:28 <xcmw> Koterpillar: class Eq b => K (Maybe b) fails with Unexpected type ‘Maybe b’
15:33:40 <Koterpillar> xcmw: don't constrain the class
15:33:53 <Koterpillar> xcmw: class K a where ... ; instance Eq b => K (Maybe b) where ...
15:35:04 <xcmw> Koterpillar: That would prevent me from infering Eq and Maybe from K
15:35:43 <Koterpillar> well
15:35:51 <Koterpillar> how about just declaring it as K b
15:35:53 <Koterpillar> ?
15:36:20 <Koterpillar> and then switching the operations to have Maybe b
15:36:58 <xcmw> I'm not sure what you are saying
15:37:41 <Koterpillar> can you show at least some of the class body?
15:37:53 <xcmw> There is no body
15:37:54 <sophiag> can anyone explain to me what i'm doing wrong with the type signature on line 28 here: http://lpaste.net/349832 ? i don't think i fully understand monad transformers yet
15:38:08 <Koterpillar> xcmw: then some usage of the class
15:38:45 <Koterpillar> sophiag: StateT is not a constraint, you probably meant MonadState
15:38:57 <Lokathor> so can i have a conditional dependency in a .cabal file?
15:39:30 <xcmw> Koterpillar: Do you want the real thing or a simplified example?
15:39:38 <Koterpillar> xcmw: simplified
15:39:56 <xcmw> I will write one
15:40:25 <sophiag> Koterpillar: can i use MonadState directly as a constraint like that without specifying an instance?
15:40:57 <Koterpillar> sophiag: MonadState is a typeclass, so it must be used as a constraint. StateT is a concrete type, so it must be used as you did in line 34
15:41:31 <Koterpillar> sophiag: what you wanted is perhaps wcmBody :: MonadState (Sum Integer, Bool) m => Char -> m Char
15:41:50 <Koterpillar> sophiag: wcm :: MonadState (Sum Integer, Bool) m => String -> m String
15:42:20 <Koterpillar> sophiag: note that wcm isn't using the Reader part at all
15:44:30 <sophiag> Koterpillar: it throws an error if i leave the Reader part out though
15:44:42 <Koterpillar> sophiag: show what you've done
15:44:44 <sophiag> and i'm also not sure how to compose them now at the end
15:46:32 <sophiag> oh here wait
15:46:32 <Koterpillar> clwcm has to have all the constraints
15:46:32 <Koterpillar> clwcm :: (MonadReader ... m, MonadWriter ... m, MonadState ... m) => m String
15:46:48 <sophiag> ah i see
15:47:45 <danilo2> Hello guys! I've got a dynamic list of IO functions. Can we somehow estymate how big will be overhead of running a function from this list assuming that the listi n mayority f cases has only one leement of `return ()`. Will it be somehow optimized by lazy evaluation? Is ghc wise enough to do it?
15:47:55 <lpaste> xcmw revised “Contraint Problem”: “Contraint Problem” at http://lpaste.net/349847
15:48:12 <xcmw> Koterpillar: ^
15:50:04 <sophiag> Koterpillar: you mean like this: clwcm :: (MonadWriter (Sum Integer, Bool) m, MonadWriter (Sum Integer, Bool) m, MonadState (Sum Integer, Bool) m)) => m String ?
15:50:06 <geekosaur> danilo2, that sounds halting problem-ish to me
15:50:35 <Koterpillar> xcmw: you're inverting constraints there, I'm actually not sure what you're trying to do :(
15:51:17 <Koterpillar> sophiag: no... you've (potentially) got three separate contexts, one for reading from, one for writing and one for state
15:51:24 <Koterpillar> sophiag: they are all independent
15:51:56 <Koterpillar> sophiag: I'm not sure what that thing does, but some things read from the Reader context, some things write to the Writer context, some things modify state
15:52:10 <Koterpillar> sophiag: if you're asking, maybe you don't need all three
15:52:23 <sophiag> well, i only actually need the integers as a triple output
15:52:32 <Koterpillar> integers?
15:52:34 <Koterpillar> a list of them?
15:52:36 <sophiag> but also i should read up on monad transformers
15:53:04 <geekosaur> danilo2, if the only thing you know is it's in IO, you can't do that at all. an effects system might be able to do it, possibly a sufficiently clever free monad (which would pretty much be implementing an effects mechanism)
15:53:23 <sophiag> yes, the sums from each of the three monads as a list would be ideal
15:53:43 <Koterpillar> sophiag: forget about monads for a while, what is your task?
15:53:47 <sophiag> and this hasn't helped me to understand much...obviously: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
15:53:53 <ssarah> How do I import this module? https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html
15:54:20 <geekosaur> ssarah, install the "split" package
15:54:28 <ssarah> aw crap
15:54:31 <ssarah> cant
15:54:33 <ssarah> ty
15:54:39 <sophiag> Koterpillar: one sums characters, one sums words, and one sums lines
15:55:06 <Koterpillar> sophiag: where do that the summands come from?
15:55:20 <lpaste> xcmw revised “Contraint Problem”: “Contraint Problem” at http://lpaste.net/349847
15:55:34 <xcmw> Koterpillar: ^
15:56:16 <Koterpillar> xcmw: I see; I think my half-thought-out solution doesn't fit this use case
15:56:46 <sophiag> Koterpillar: the first monad just counts characters, the second resets on linebreaks, and the third on spaces. since the first two are writers they should keep a log, yes? so i guess i'm not being so exact with the output
15:57:09 <geekosaur> danilo2, if the only thing you know is it's in IO, you can't do that at all. an effects system might be able to do it, possibly a sufficiently clever free monad (which would pretty much be implementing an effects mechanism)
15:57:16 <danilo2> geekosaur: I was thinking exactly that. Anyway I'm just thinking if there **could** be some magic involved. In fact I can in runtime check if the function is just `return ()` or sometihng else. But hmm, doesnt GHC "sees" that it encountered `return ()` and coudl in runtime using lazy evaluation optimize it away?
15:57:53 <danilo2> geekosaur: thanks so much for re-poting the answer! I've just checked it in the logs
15:58:08 <sophiag> Koterpillar: the end result is supposed to be just a word count...tbh i'm not sure how you get there from chaining together the three monads
15:58:20 <sophiag> although i understand how they work independently
15:58:32 <sophiag> it's the composition step that's throwing me
15:58:37 <geekosaur> your notion of how things work is dubious at best, I think. also which "runtime"? evaluation via graph reduction is where laziness occurs; this is separate from execution
15:58:40 <Koterpillar> sophiag: this sounds like a finite automaton, which has single state
15:58:47 <sophiag> basically
15:58:53 <geekosaur> and graph reduction doesn't know what an IO a is
15:58:59 <sophiag> that's how it goes from character counting to word counting
15:59:17 <sophiag> hence one state monad that resets on spaces
15:59:30 <geekosaur> could it, in theory, be done? yes with custom modifications to the runtime and possibly disabling some optimizations so the modifications work reliably
15:59:36 <sophiag> i'm just saying i don't know how the three functions get that result from composition
15:59:40 <geekosaur> but not as ghc currently works
15:59:40 <danilo2> geekosaur: hmm if I understand correctly, during execution we've got thunks that after get computed become values (in pure code). 
15:59:52 <geekosaur> that is evaluation
15:59:54 <Koterpillar> sophiag: you have _one_ state
16:00:03 <Koterpillar> sophiag: so something like: data Counter = Counter { coChars :: Int, coWords :: Int }; countWords :: String -> State Counter ()
16:00:18 <danilo2> geekosaur: I was talking about evaluation
16:00:43 <geekosaur> ghc does interleave evaluation and execution in practice, but neither hand knows what the other is doing
16:00:47 <geekosaur> by design
16:01:19 <danilo2> geekosaur: very interesting. Do you know why it is so separate by design ?
16:01:44 <geekosaur> because this is Haskell, not Python or etc.?
16:01:55 <geekosaur> if they are not isolated, there is no purity
16:02:37 <sophiag> Koterpillar: you're saying to use that for constructor for the type of the function at the end? shouldn't the state monad just handle that and i can just discard the bool?
16:02:51 <geekosaur> also, in theory since you are in IO you can invoke a monitor function that can examine all memory accessible to the process... but ghc is under no obligation to make the things you are interested in easy to spot
16:02:54 <Koterpillar> sophiag: what bool?
16:03:12 <Koterpillar> @unpl State String Bool
16:03:13 <lambdabot> State String Bool
16:03:18 <Koterpillar> @unmtl State String Bool
16:03:18 <lambdabot> String -> (Bool, String)
16:03:33 <geekosaur> as distinct from easy for it to use in its intended way
16:03:35 <danilo2> geekosaur: By "isolated" i mean - taht they dont know aobut reach other. Look - if we've got this IO function and evaluation engine could geti nformation that this function just does "nothing" in IO it could optimize it away during evlauation
16:03:41 <Koterpillar> sophiag: see above, the State monad isn't magic
16:03:49 <danilo2> geekosaur: am I thinking about it in wrong way?
16:04:40 <geekosaur> de facto I imagine (return ()) is usually optimized away during code generation... but if you are sticking it in a list and that list can't be fused at compile time, *something* must exist
16:05:04 <geekosaur> and you are reduced to poking around in RAM directly looking for what you hope represents that (return ())
16:05:12 <geekosaur> ghc has no reason to make that easy for you
16:05:47 <geekosaur> and likely several reasons to do something harder to decipher
16:06:05 <danilo2> geekosaur: exactly - it must exist. And if we sequence this list (keeping it in a State and it doesnt change) - than we've got a thunk and this list as a value. So if during runtime GHC **could** understand that tihs IO action does nothing - it could just omit it - like lazy computation
16:06:08 <geekosaur> although here I get to point you at #ghc and let them break your heart
16:06:19 <danilo2> geekosaur: sure, I'd have to poke into RAM unles s GHC supprots it out of the box
16:06:31 <danilo2> and I dont want to do it. I'm jsut thinking why ghc doesnt do it by desing
16:06:57 <geekosaur> because that;s a special case it has to deal with, instead of handling everything the same way
16:07:02 <danilo2> geekosaur: hehe, I'd love my hart to get broken there! I' dl ove to understand this design better
16:07:20 <danilo2> geekosaur: for me this sounds like a internesting optimization case
16:07:29 <geekosaur> special cases have their own overhead. for something like this, the cost of checking for the special case is almost certainly higher than just jumping through a pointer to asm("ret")
16:07:44 <danilo2> geekosaur: so I understand why GHC doesnt have it. The question is - if it would be interesting for GHC to have it in the future
16:08:24 <geekosaur> I doubt it, but that's a question for the ghc-devs mailing list probably
16:08:25 <danilo2> geekosaur: hmm, that could be good point
16:09:07 <danilo2> geekosaur: (about the checking overhead). Anyway I suspect it could be much lower if the execution engine would easily discover such situation (And it could) and then just change something in evaluation engine - only when it happens
16:09:20 <danilo2> geekosaur: still, ghc devlit is where I'll post the question!
16:09:30 <danilo2> geekosaur: tank you for the conversation!
16:09:36 <danilo2> :)
16:10:12 <geekosaur> I'm not sure it can, without doing something like tuirning IO into a GADT with return as a special case so it can track it separately at compile time
16:10:23 <geekosaur> which will complicate a whole bunch of other stuff
16:10:37 <geekosaur> (and possibly break every existing use of unsafePerformIO...)
16:12:12 <danilo2> geekosaur: sure, there would be needed additional magic for usnafePerformIO or just allowing using IO in top-level modules and with foreign code only
16:12:26 <geekosaur> oh, potentially there's also a bunch of other weirdness relating to CPU pipelines and such, but ... I don't think ghc codegen currently does anything at all in tht area
16:13:06 <danilo2> geekosaur: arent pipelines etc "managed" and optimized later by LLVM backend? at least to some extend?
16:13:17 <geekosaur> (partly because every time it has to take the path of jumping through a pointer like that, you;ve stalled the CPU pipeline anyway)
16:13:56 <geekosaur> llvm (a) is not the default backend (b) needs sufficient information (IR annotations) to do that optimization, and ghc doesn't currently provide much in that area
16:14:12 <danilo2> a) I know it b) oh
16:14:30 <geekosaur> there's something in the wiki and maybe even an open ticket on improvements to the LLVM IR codegen
16:15:19 <danilo2> geekosaur: cool. This topic is super-interesting for me. I'll write to ghc-dev-list and see if what we were tlaking aobiut is somehow resonable, at least in theory.
16:15:36 <danilo2> geekosaur: Thank you so much for so great set of important information!
16:17:19 <royc_> hey guys, is there an IRC room dedicated to opaleye quesetions? or could I ask here?
16:17:57 <geekosaur> oh and (c) unless this changed recently, ghc produces IR that is already CPS transformed, and this confuses the heck out of LLVM's optimizer which falls through to the slow codegen path
16:18:33 <geekosaur> (and iirc needs ghc devs to design annotations and get them upstreamed so LLVM can understand ghc's flavor of CPS transform)
16:19:57 <geekosaur> royc, no specific IRC channel I'm aware of; ask here, or on stackoverflow
16:20:22 <royc_> I'm just having trouble making it typecheck with Maybe and Nullable
16:21:42 <royc_> could someone point me to an example or documentation?
16:22:43 <b0llu> so I'm wrapping an imperative API
16:22:51 <b0llu> which has APIs like "set matrix at row r, column c"
16:22:52 <b0llu> https://github.com/symengine/symengine/blob/master/symengine/cwrapper.h#L419
16:22:54 <b0llu> to make it functional
16:23:02 <b0llu> I need to incur the cost of a matrix copy on each set? :(
16:23:10 <b0llu> (to be referentially transparent)
16:23:18 <b0llu> is there any way to provide both APIs?
16:23:26 <b0llu> a "pure" one for people who don't care about speed
16:23:28 <b0llu> and a faster one?
16:30:25 <neonfuz> Do haskellers usually do global or local imports first?
16:35:59 <sm> global
16:37:33 <jle`> i do my imports alphabetically hehe
17:01:51 <jle`> vap:!sort
17:02:53 <jle`> * vip:sort
17:15:12 <ssarah> You guys got an example of that method where you add an extra argument to a function to simulate an iteration?
17:15:25 <ssarah> method = pattern
17:16:00 <glguy> sum acc [] = acc; sum acc (x:xs) = sum (acc+x) xs     Is that what you wanted perhaps?
17:16:44 <sophiag> ssarah: i think i'm working on what you're talking about right now... https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
17:17:45 <sophiag> they do it a few different ways and settle on traversal
17:17:57 <ssarah> sophiag, which page?
17:18:21 <sophiag> well, i'm not sure exactly what code you're talking about
17:19:18 <sophiag> the whole thing is about the iterator pattern
17:19:49 <Cale> > let { fib a b 0 = a; fib a b n = fib b (a+b) (n-1) } in map (fib 0 1) [0..10]
17:19:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55]
17:20:17 <Cale> ^^ perhaps that's a clearer example of one
17:21:22 <hpc> honestly, adding an argument for iteration is just a special case of iteration on the arguments you already have
17:21:25 <hpc> @src map
17:21:26 <lambdabot> map _ []     = []
17:21:26 <lambdabot> map f (x:xs) = f x : map f xs
17:21:26 <Cale> You can translate many imperative programs into functional ones in this sort of way, where each point of control in the imperative program becomes a function whose parameters are the values of the mutable variables which would have been in scope.
17:22:11 <Cale> and then each function will apply another one (according to the control flow of the original program) to possibly updated values for those variables
17:22:45 <sophiag> i think their main point is that if you use traversables you get easier composition and logn time complexity
17:24:33 <sophiag> i realized that was the problem with my wordcount code... i was confusing the latex notation... they don't use kleisli arrows, they use a special data type constructor i'm now having trouble getting working
17:25:20 <sophiag> like this:
17:25:34 <sophiag> https://thepasteb.in/p/wjh0JV1wOV3iv
17:27:15 <sophiag> i'd like to do a similar port of K&R's tiny C regex parser, but am struggling so much with just this so far :p
17:37:25 <HactarCE> Is there a function :: [IO ()] -> IO () ?
17:38:03 <HactarCE> I found sequence :: [IO ()] -> IO [()] but that doesn't work in a "do" block, which wants only IO ()
17:38:23 <geekosaur> :t sequence_
17:38:25 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
17:38:32 <Clint> HactarCE: is your [IO ()] produced by map?
17:38:49 <HactarCE> It's produced by concat [[IO ()]]
17:38:54 <pavolzetor> System.Random.MWC.Distributions.categorical: bad weights!
17:39:14 <pavolzetor> I get this error and not sure why
17:39:44 <HactarCE> What I'm actually doing is taking a [[SomeDataType]] and doing a double list comprehension to turn it into [[IO ()]]'
17:39:58 <geekosaur> also... if you don't care about the result of something like that there is void and there is >> return ()
17:40:24 <c_wraith> though sequence_ can be notably more efficient than sequence
17:40:56 <HactarCE> Oh duh never mind :) My main method had an incompatible type sig :)
17:40:58 <HactarCE> Thanks
17:41:06 <HactarCE> Adding `return ()' to the end fixed it
17:41:20 <c_wraith> HactarCE: well, yes.  But so would using sequence_ instead
17:41:49 <c_wraith> HactarCE: there's nothing magical going on.  Just types being obeyed.
17:42:48 <HactarCE> yep
18:28:18 <haskell105> Hi, how does the haskell callstack work for reporting error? I have a crash and I have no idea where it is because all I see is "error, called at libraries/containers/Data/Map/Base.hs:489:16 in containers-0.5.7.1:Data.Map.Base"
18:33:09 <lordcirth> The error was thrown in Map? That's annoying
18:33:44 <Axman6> are you using GHC8?
18:40:07 <haskell105> yep I'm using ghc 8
18:45:15 <grantwu> There's some way of getting raw source out of hackage
18:45:20 <grantwu> http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Map.Base.html
18:45:48 <glguy> Yeah, you click the 'source' links next to a definition
18:46:50 <grantwu> But that's still highlighted
18:47:06 <grantwu> I can't do wget http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Map.Base.html#elems | vim - 
18:47:12 <grantwu> er s/wget/curl/
18:48:28 <grantwu> haskell105: Your error is in find
18:49:35 <grantwu> So, since find isn't exported, that would be in (!)
18:49:39 <grantwu> Are you using that anywhere?
18:50:17 <b0llu> how hard would it be to add GHC support to warn you of typos in module names?
18:50:25 <b0llu> (I would like to take this up)
18:51:23 <haskell105> is there a better way of doing this?
18:51:39 <haskell105> like just print the callstack
18:52:37 <ezyang> Hey guys, is there a difference between DatatypeContexts (data Show a => F a = ...) and data F a = Show a => ...? 
18:52:59 <amx> b0llu: it actually does?
18:53:00 <ezyang> (more concretely, 'data Show a => F a = MkF a' versus 'data F a = Show a => MkF a') 
18:53:06 <b0llu> amx: does it?
18:53:24 <b0llu> amx: it doesn't seem to do it for me when I am importing from my own library that I am building
18:53:41 <amx> b0llu: ok, so you are talking about imports.
18:53:45 <b0llu> yeah
18:53:56 <b0llu> amx: module import typos :)
18:54:08 <amx> b0llu: when I import Date.Text, as I regularly do, It does try to suggest Data.Text
18:54:24 <amx> so there is some support for that
18:54:37 <b0llu> I'm not sure why it isn;t happening, maybe because I am importing "within the same module"
18:55:12 <Sergio965> Also interested in ezyang's question.
18:55:53 <ezyang> Oooh there is something existentially going on with the latter 
18:56:02 <amx> b0llu: maybe the Hamming/Levenshtein distance is too great?
18:56:07 <geekosaur> ezyang, iirc the former gives you a useless context only available during construction, and the latter is an existential
18:56:49 <geekosaur> (basically the latter is a GADT minus the part that makes GADTs usable)
18:57:37 <ezyang> geekosaur: So, am I correct in thinking of the latter as something like data F r = forall a. (Show a, a ~ r) => F a? 
18:58:33 <grantwu> haskell105: There might be, but it's likely to be annoying...
18:58:36 <geekosaur> pretty much. but you can't recover the existential context from it, so there's very little you can do with such a value
18:59:00 <geekosaur> whereas with a GADT pattern matching the constructor gives you the context
19:00:57 <haskell105> what's the way?
19:01:41 <jchia1> I need help modeling data for a GUI. I need to have a list of heterogeneous things with a common interface. How do I model that in Haskell? Specifically, I'm showing in a GUI a list of different types of processes. They all have names, and they all can be checked for status. So, for each process, I can get its name and its status, but the way to get status is different for different types of process.
19:03:06 <jchia1> Do I just represent each item in the list as a pair of IO Text, one for getting the name and one for getting the status?
19:03:18 <geekosaur> jchia1, that's going to be annoying no matter what.
19:05:20 <jchia1> geekosaur: Do you think the (IO Text, IO Text) way makes sense, though?
19:06:15 <jchia1> You don't need to know the 'what', just the how, and that's captured in IO Text, basically something I can 'call' to get the result.
19:07:22 <jchia1> In order to be able to identify the items, so that at least I can delete them, I can use (Int, IO Text, IO Text), using the first item in the tuple as the ID.
19:08:40 <geekosaur> that is one way, and if it is sufficient then it's better than many of the other ways
19:09:07 <geekosaur> "list of heterogeneous things" is pretty much always horrible in Haskell
19:09:17 <b0llu> what will "flip" do to a function with the type a -> b -> c -> d? intuition says it will read it as a -> b -> (c -> d) which will give me b -> a -> c -> d. Correct?
19:09:42 <Koterpillar> :t flip (\a b c d -> (a, b, c, d))
19:09:44 <lambdabot> t1 -> t -> t2 -> t3 -> (t, t1, t2, t3)
19:09:49 <b0llu> yeah
19:09:50 <b0llu> cool
19:09:59 <b0llu> what if I want to take a -> b -> c -> d to b -> c -> a -> d
19:10:16 <Koterpillar> just write it
19:10:23 <b0llu> xD
19:10:27 <Koterpillar> you can probably @pl it, but you won't like the result
19:10:30 <jchia1> :t flip . flip
19:10:32 <lambdabot> (a -> b -> c) -> a -> b -> c
19:10:42 <jchia1> :t flip <$> flip
19:10:44 <lambdabot> (b -> a -> c) -> b -> a -> c
19:11:02 <b0llu> I want to point free this
19:11:03 <b0llu> @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
19:11:03 <lambdabot> f a b c d = a d b c
19:11:10 <b0llu> lol
19:11:10 <b0llu> okay
19:11:27 <Koterpillar> @pl \a b c d -> a d b c
19:11:27 <lambdabot> (flip .) . flip
19:11:30 <b0llu> @pl (a -> b -> c -> d) -> (b -> c -> a -> d)
19:11:31 <lambdabot> (line 1, column 6):
19:11:31 <lambdabot> unexpected '>'
19:11:31 <lambdabot> expecting operator
19:11:32 <b0llu> wow
19:11:36 <geekosaur> this tends to be the kind of thing where pointfree = pointless obfuscation
19:11:41 <b0llu> yes
19:11:48 <b0llu> but I'm quite curious about things like this
19:11:52 <b0llu> since I still can't come up with them
19:12:02 <b0llu> monochrom is quite good at that IIRC?
19:12:15 <b0llu> geekosaur: deconstruct it for me intuitively? :3
19:12:56 * geekosaur is not especially good at it
19:13:05 <geekosaur> (mmostly because I quickly get a headache)
19:55:47 <dfeuer> Hi people.
19:56:26 <c_wraith> hi person
19:59:37 <pavonia> Sigh, it seems you can't have a complete JS parser, interpreter and pretty printer together in a single package
20:00:40 <dfeuer> pavonia, why would you want that?
20:01:13 <pavonia> To parse, pretty-print and interpret JS, of course :p
20:01:31 <dfeuer> I mean, that as opposed to the four or so logical units separately.
20:02:42 <pavonia> Because you'd have to convert between the different ASTs otherwise
20:02:45 <dfeuer> I'd expect a family of packages, including one defining the Javascript syntax tree, one defining a parser for it, one a pretty-printer, and one an interpreter.
20:02:57 <dfeuer> Oh, yeah, if they're incompatible that sucks.
20:05:17 <geekosaur> isn't getting one AST that works even for parsing + prettyprinting considered something of a hard problem?
20:06:01 <c_wraith> not if you throw away the original formatting
20:09:16 <pavonia> If you ignore all whitespace in the AST, the parsed and pretty trees should be the same, no?
20:18:26 <orion> Is it possible to build GHC using clang/llvm?
20:18:32 <Kushi> Hello, I am new to haskell. Would someone mind telling me what is wrong with this? http://pastebin.com/8JbBdsjf
20:19:19 <geekosaur> orion, people do so on Macs. the main problem is not building it, but that quite a few uses of -XCPP fail in odd ways with clang's cpp
20:19:53 <lordcirth> Kushi, in ghci, run ' :t pythag '
20:19:57 <geekosaur> and the easiest way to avoid problems is to build ghc with gcc so it picks up gcc's cpp as the default
20:20:05 <Kushi> okay thanks
20:20:06 <lordcirth> :t **
20:20:07 <lambdabot> error: parse error on input ‘**’
20:20:11 <lordcirth> :t (**)
20:20:12 <lambdabot> Floating a => a -> a -> a
20:20:36 <geekosaur> Kushi, what exactly did you do to start ghci, and in it once started?
20:20:45 <lordcirth> Kushi, (**) is for Floats, you need a different one for integrals, iirc
20:20:53 <Kushi> oh
20:21:05 <geekosaur> the type is a bit of a red herring as you're not even getting that far
20:21:08 <orion> geekosaur: I see.
20:21:14 <Kushi> So what do I need I need for intergrals?
20:21:30 <lordcirth> Oh, yeah, did you load your code with :l ?
20:21:35 <jle`> Kushi: have you imported 'pythag' into ghci?
20:21:36 <Kushi> yea
20:21:36 <geekosaur> it's more complex than that --- sqrt needs Float or Double
20:21:43 <Kushi> I did :l code
20:21:58 <lordcirth> :t sqrt
20:21:59 <jle`> is "code" a file containing the definition of pythag?
20:21:59 <lambdabot> Floating a => a -> a
20:21:59 <Kushi> and imported in that way and ran the function in the ineterpreter
20:22:03 <geekosaur> so you need the ** there. but the error says it can't *find* your pythag
20:22:16 <jle`> yeah, (**) is definitely not the problem here.
20:22:23 <geekosaur> not that the type is wrong (the type is just inferred from the usage, lacking other information)
20:22:27 <Kushi> the pastebin link I sent was the file I just add in the log
20:22:31 <lordcirth> oops
20:22:39 <jle`> Kushi: you did ":l code", but waht does the 'code' file contain?
20:22:44 <jle`> is it empty, or ...?
20:22:55 <jle`> try "cat code" at the command line
20:23:02 <jle`> to see what is inside the file
20:23:19 <jle`> i suspect that "code" doesn't contain 'pythag'
20:23:39 <Kushi> this is the full file and all of it's contents http://pastebin.com/eZcbZnE0
20:23:56 <jle`> Kushi: yes, but is that the file that you load into ghci?
20:24:09 <lordcirth> Kushi, and when you load it, does it succeed?
20:24:09 <Kushi> that is the file I loaded, yes
20:24:22 <Kushi> yes no errors
20:24:36 <Kushi> do you want a screen cap?
20:24:54 <jle`> just a paste of your ghci session, maybe.
20:25:02 <Kushi> okay
20:25:07 <jle`> i'm trying it on my end and i'm getting no problems :|
20:25:42 <pavonia> The "Prelude>" is an indication that the module isn't loaded, I think
20:25:42 <Kushi> wait now it's working for some reason
20:25:54 <jle`> hooray :D
20:26:05 <Kushi> lol well I don't want to question it!
20:26:30 <Kushi> but I have a quick question I know I should look up but since I am here
20:27:01 <Kushi> can I assign a variable value to parameters in a function in the function?
20:27:16 <grantwu> What do you mean by that?
20:27:21 <jle`> Kushi: do you mean like, default arguments...?
20:27:59 <Kushi> like if I have the arguments size can I assign the value of Integer inside the function?
20:28:03 <Kushi> oh wait nvm
20:28:05 <Kushi> I am dumb
20:28:10 <jle`> Kushi: you can just not take an argument
20:28:16 <jle`> and define it locally, like size = 10
20:28:25 <jle`> otherwise why even expect it as an argument, lol
20:28:31 <Kushi> lol
20:28:56 <Kushi> this is like the nicest irc chat centered around programming I have been in
20:29:14 <Kushi> no wonder haskell is the happiest language
20:29:26 <grantwu> You cannot have default arguments, if that's what you're asking
20:29:26 <jle`> :D
20:29:39 <grantwu> You can somewhat emulate them with partial application
20:29:52 <jle`> or w/ record types hehe
20:29:53 <Koterpillar> Kushi: there are no varaibles...
20:30:05 <Kushi> oh yea I forgot constants
20:30:12 <Kushi> I feel like I am triggering rn
20:30:15 <Kushi> lol
20:30:25 <grantwu> kwit
20:30:27 <grantwu> *wot
20:30:37 <jle`> well, haskell does has variables
20:30:40 <jle`> s/has/have
20:30:49 <jle`> the report is very clear about that :)
20:31:00 <Rotaerk> f x = x  -- x is a variable ... it varies from call to call
20:31:13 <jle`> they're just variables in the math sense, not in the traditional programming sense
20:32:04 <jle`> i like to compare haskell variables to cpp macros
20:32:05 <Kushi> rn I am using "Learn You a Haskell for Great Good!" is that any good?
20:32:14 <jle`> er wait, wrong reference, forget that i said that :)
20:32:34 <jle`> Kushi: a lot of people like it, but a lot of people believe that it's not the best for learning because it doesn't really have any exercises
20:32:45 <jle`> it's more of a fun tour around haskell than a method for learning how to write haskell, they'd say
20:33:46 <jle`> (for what it's worth, i was introduced to haskell through LYAH, and I turned out fine.  but there was still a lot of holes to fill in after finishing lyah)
20:33:49 <Kushi> While reading it I thought for 2 hours that a :: Integer what how you declared a constant
20:33:53 <jle`> turned out "fine"
20:34:34 <grantwu> Kushi: oops
20:34:35 <Kushi> the quotes make that statement even more assuring lol
20:36:21 <jle`> "fine" just because how much can you trust someone who self-assesses themselves as "i turned out fine", heh
20:36:35 <kadoban> jle`: Completely? :)
20:36:46 <Kushi> lol
20:37:07 <jle`> "i did heavy drugs as a child and i turned out fine"
20:37:45 <jle`> it could potentially paint a misleading picture of causality
20:37:51 <Kushi> I did "heavy" wrestling with my uncle as a child I turned out "fine." 
20:37:58 <Kushi> This is really a big paradigm shift for me though. I am coming from Java.
20:38:04 <lordcirth> I've heard a few people say "i turned out fine" who definitely did not
20:38:08 * kadoban wanders off before this gets weird
20:38:14 <glguy> (Yes, I know you probably heard me earlier, but just a few more advertisements) If you're doing adventofcode.com this year, join the #haskell leaderboard. Key in /topic
20:38:34 <jle`> yeah, "turned out fine" sometimes is an indication of survivorship bias too
20:38:44 <jle`> Kushi: that's a pretty big jump :o
20:39:07 <jle`> glguy: oh, didn't realize there was a leaderboard :o  might motivate me to try to catch up haha
20:39:14 <jle`> i feel like i'm too far behind
20:39:25 <glguy> I mean... some people have 0 finished
20:39:32 <glguy> so it's never too late
20:40:00 <glguy> I consider the leaderboard interesting to see how far along everyone is rather than who is on top
20:41:23 <jle`> i just didn't want to start and not finish because i ran out of time.  but having a leaderboard makes it fun, in the sense that you're all doing things together
20:41:53 <glguy> many of us have links through to our solutions on github
20:43:14 <lordcirth> Just joined the leaderboard.  Might do some puzzles later
20:47:39 <jle`> woo hoo me too
20:48:10 <jle`> i'll try to catch up after finals :)
20:52:56 <glguy> jle`: That doesn't look like waiting until after finals!
20:53:28 <glguy> Or did you already have that one done
20:53:42 <jle`> yeah i did that one last weekend heh
21:08:00 <glguy> cool, got #4 tonight
21:08:17 <glguy> (and #1 on the first start)
21:10:57 <byorgey> glguy: nice work!  I got #7/#8
22:12:04 <moriarty> hello all
22:31:46 <mmaruseacph2> nice, nice :)
22:31:55 <mmaruseacph2> I won't play more until I'm done with HCAR
22:32:12 <mmaruseacph2> got too much sidetracked with thesis and work :(
23:21:00 <Philippa> is there a good lenses-and-prisms-and... intro around that's appropriate for the kind of irritating nerd I am?
23:21:33 <Philippa> which is to say, gets to the gist fast but doesn't rely too much on me following notation to do it? Preferably covers enough for me to know why I might care about profunctors or might not?
23:22:03 <Philippa> I mean, "there's this guy you might know, ask him" has the problem that I keep crappy logs these days :-)
23:22:24 <Philippa> but I suspect I'm toying with a problem that's the same thing in a thin disguise, give or take some transitivity
23:23:27 <Philippa> (anyone suggesting I google it is welcome to observe what happens when you look for how to build interpreters in Haskell: we've managed to pollute Google's idea of what's wanted by not separating near-research from actually-the-basics enough)
23:24:29 <Philippa> ...oh, right, this is probably also an appalling time of day for me to ask given even the US folks're thinking about sleep
23:24:50 <grantwu> What's that
23:25:19 <Philippa> er, there's a lot of possible "that"s: do you mean "what are lenses-and-prisms-and..."?
23:25:54 <grantwu> Sorry, it was a joke
23:25:59 <grantwu> What's sleep? /s
23:26:10 <laudiacay> Philippa: i kinda liked this https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
23:26:33 <Philippa> thanks, taking a look
23:26:43 <laudiacay> also like don't ever bother looking at type sigs
23:26:53 <laudiacay> it's like > :t (lens things)
23:27:08 <laudiacay> *screams emit from computer speakers*
23:27:26 <Philippa> *nods* - yeah, I know the level of abstraction involved
23:27:33 <laudiacay> like the system of learning things by looking at types just do not work here
23:27:43 <laudiacay> i learned this the hard way
23:28:02 <meretrix> Is there any way to create a data type using a type variable like this:
23:28:05 <MarcelineVQ> Philippa: lens itself has some good material https://github.com/ekmett/lens/wiki/Examples  https://github.com/ekmett/lens/wiki/Derivation   if you want hands on stuff there's https://github.com/NICTA/lets-lens
23:28:07 <meretrix> data D = D { x :: a, y :: a -> IO () }
23:28:10 <Philippa> yeah, understandable. I know some people who basically do that by default, watched a close friend work out how to actually do anything with monads that way for example
23:29:05 <laudiacay> meretrix: you mean record syntax?
23:29:12 <Philippa> MarcelineVQ: it's probably a bit difficult for me to pin down exactly what I'm looking for because I've got my LARPing-a-researcher hat on
23:29:21 <laudiacay> meretrix: https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
23:29:26 <meretrix> yes, thanks
23:29:27 <grantwu> meretrix: Can't you just do:  data D a = D { x :: a, y :: a -> IO () }
23:29:50 <meretrix> ah, that's right
23:30:45 <Philippa> I should probably keep the derivations page on hand though. And yeah, the types being full of s t a b is kinda the classic problem I think?
23:31:02 <Philippa> One of those times when it's be really useful to be allowed to switch between long and short names for the same type variable
23:31:20 <laudiacay> s t a b made me giggle a lot
23:32:02 <Philippa> it's infamous, yes :-)
23:32:24 <laudiacay> also ooh there was a really cute lens/prism tutorial with cartoons somewhere. wasn't LYAH... lemme look around
23:32:53 <MarcelineVQ> http://adit.io/posts/2013-07-22-lenses-in-pictures.html
23:33:35 <Philippa> strictly speaking I'm enough of an old fart to not quite be used to Traversable (bloody embarrassing on a personal level, but that's another story), I gather "sequence for things that aren't lists" is accurate enough?
23:33:52 <laudiacay> MarcelineVQ: that's it! :D
23:34:18 <Philippa> ...yup
23:34:54 <Philippa> I kinda want to hit the "so why was anyone playing with profunctors?" point though, which I imagine is going to be more difficult because I'm not really up to too much raw category theory today
23:35:21 <Philippa> anyway: thanks, both!
23:35:54 <laudiacay> is anyone ever up to raw category theory though
23:36:03 <laudiacay> i hope i am by the time i graduate
23:36:14 <Philippa> (I always preferred fold-as-catamorphism rather than fold-as-flatten-then-that-catamorphism, but the fact one of those is easy to make into a typeclass and one isn't kinda settled /that/ argument)
23:36:30 <Philippa> eh, I'm a dropout. Formally speaking, just coming up to my tenth anniversary
23:36:39 <laudiacay> of... dropping out?
23:36:49 <Philippa> I'm also, er. I haven't been in here much lately, but I'm very much one of the old guard by now
23:36:52 <Philippa> yeah
23:37:14 <Philippa> don't get me wrong: I also gave a talk to Conor McBride's lot the other month? But yeah, no degree here and never been in work
23:37:21 <laudiacay> oh cool! nice to meet you
23:37:39 <Philippa> hi liyang!
23:37:45 <Philippa> and likewise!
23:39:30 <laudiacay> Philippa: who's conor mcbride? the first sentence of his wikipedia page says he doesn't wear shoes.
23:39:35 <laudiacay> this is all i have read so far
23:39:36 <Philippa> *grins*
23:40:07 <laudiacay> tbh that's my dream occupation
23:40:11 <Philippa> he's a researcher, based at Strathclyde at the moment. Lots of little things we take for granted are his fault, he mostly works with dependent type theories though
23:40:33 <laudiacay> anything requiring a phd and no shoes? but anyway what's dependent type theory
23:40:37 <Philippa> I dropped out (having not actually studied) around when he was actually working in my city
23:41:41 <Philippa> so it's a subfield of formal logic that resembles the type systems of languages like Haskell if you can do things like directly put what we think of as "terms" in "types" and vice versa
23:42:07 <laudiacay> i'm seeing it as "an alternative to set theory" on wikipedia
23:42:09 <Philippa> beyond that? It's 7:40am and I've been up all night :-) Sometimes easier found as "dependent types"
23:42:30 <laudiacay> and i understand i think the type system of haskell and how that can apply to like, arithmetic/calculus/group theory 
23:42:35 <Philippa> heh. Yeah, that's wikipedia for you. Yes, dependent type theories are a possible foundation for mathematics, so what? :-)
23:42:46 <laudiacay> but how is it like, an alternative so set theory?
23:42:51 <laudiacay> *to
23:43:14 <Philippa> an appropriate one is capable of being used as a foundation for the entire of mathematics, the same way that ZF[C] set theory commonly is now
23:43:21 <laudiacay> like if i understand correctly, set theory is like "these numbers are in this set and this function maps from blah set to blah other set"
23:43:27 <laudiacay> and how is that not basically type theory
23:43:28 <Philippa> and unlike set theory it shows you how to navigate things
23:43:38 <Philippa> um, really really fundamentally?
23:43:42 <laudiacay> (sorry I'm a 1st year undergrad please forgive my dumb)
23:44:01 <laudiacay> i guess I'm misunderstanding the basics of both then
23:44:03 <Philippa> okay, so in set theory you start off with a number of small axioms from which you can build all possible sets
23:44:09 <Philippa> (at least, foundational set theory)
23:44:16 <laudiacay> okie
23:44:23 <Philippa> what set theory can't do is keep track of anything whatsoever about what those sets were supposed to mean
23:44:44 <laudiacay> should i read about ZFC to get a grasp on those axioms?
23:44:57 <laudiacay> but also in what sense "what those sets were supposed to mean"?
23:45:02 <Philippa> newtype USD = USD Rational; newtype Sterling = Sterling Rational; -- these are two very different types if you're a banker
23:45:20 <laudiacay> ohhhhhh that makes a lot of sense actually
23:45:24 <Philippa> they're mathematically isomorphic, but a banker will care a /lot/ about which currency you're talking about :-)
23:45:37 <laudiacay> and sets would only distinguish between "hmm they are both rationals to me!"
23:45:44 <Philippa> yup
23:46:13 <laudiacay> i think i have an example from multivariable calculus, can you tell me if it's right?
23:46:19 <Philippa> secondly, in type theory /everything/ is "described by" something/has a type
23:46:19 <Lokathor> http://lpaste.net/8044744482966470656 I've got a complete "debug only" version of bufferless console input.
23:46:26 <Lokathor> next step is to hook it to an MVar
23:46:30 <Philippa> I can't, because my calculus is thoroughly rotted
23:46:53 <Philippa> closest I come to it is judging jumps in platformers these days, sorry!
23:46:56 <laudiacay> ok lol :D I think i get it though
23:47:03 <MarcelineVQ> Lokathor: woo
23:48:01 <MarcelineVQ> psst, all the cool kids are doing adventofcode.com with the private leaderboard code in the channel topic
23:48:25 <Philippa> eh, I'm too old to bother passing for one of the cool kids, even if people keep thinking I'm a decade younger than I am in person...
23:48:31 <laudiacay> set theory is like "oh boy we can have all these different groups of things but as far as i can tell they are all just things" and then type theory "we have lots of different kinds of things"
23:49:07 <Philippa> yeah, and then it can talk specifically about maps from one type of thing to another
23:49:12 <laudiacay> oh coool
23:49:15 <Philippa> which set theory can't, we just jury-rig it
23:49:18 <laudiacay> that makes sense i think
23:49:25 <laudiacay> i didnt realize that part was jury-rigged at all
23:49:36 <laudiacay> or at least my teacher did not present it as such
23:49:45 <Lokathor> MarcelineVQ, my hope is to get a system where the program can print stuff to the console while the user has a partial line written, and it will know to preserve that and restore it after the print operation
23:49:47 <Philippa> well, I'm arguably being unkind? And most mathematicians don't like being told it is :-)
23:50:00 <Philippa> but the rules for type theory "understand" what a function is directly
23:50:03 <laudiacay> does linear algebra and different vector spaces have a rooting in type theory?
23:50:16 <MarcelineVQ> Lokathor: like tracking your cursor as you type?
23:50:22 <Philippa> I've not studied them using type theory as a foundation, but I'd be shocked if you can't do good work there
23:50:23 <Lokathor> yes
23:50:34 <laudiacay> hmm okie
23:50:35 <Philippa> they arose independently though
23:50:49 <Philippa> (type theory the formal discipline is fairly new: 70s, IIRC)
23:51:06 <laudiacay> i honestly don't think we used any sort of foundation in my "bullshit some vectors during the first week of quantum physics crash course class" intro to linear algebra
23:51:27 <laudiacay> but the whole idea of vector spaces feels like it would fit in well with type theory
23:51:33 <Philippa> yeah, most mathematicians only really use set theory if they're actually working with sets
23:51:38 <Philippa> and yes, very much so
23:52:00 <laudiacay> very cool and exciting
23:52:09 <laudiacay> thanks
23:55:29 <spoonm> guys, I'm trying to understand something: XMonad.Core does type WorkspaceId = String, and I'm trying to make a Map WorkspaceId String
23:55:58 <spoonm> [("id", "string")] doesn't work, how can I force the map to be WorkspaceId String?
23:56:13 <Lokathor> fromList [...]
23:56:40 <spoonm> oops
23:56:43 <spoonm> thanks
23:59:36 <Philippa> liyang: found an old article of yours re profunctors, think that did the trick at least as far as enough intuition to shoot myself in the foot with goes
