00:25:10 <tsahyt> What'
00:25:34 <tsahyt> What's the best way to define operations that can be performed in several monadic regions that share the same phantom parameter?
00:26:22 <tsahyt> e.g. I have a Region1 s monad in which most of my stuff runs, but from that another Region2 s is created which allows some different operations, but needs to also support some of the same operations
00:27:43 <tsahyt> I'm thinking typeclasses might help, but usually when I think that, I'm wrong.
01:02:38 <lolisa> Hi my friends, I am back for a PL question :) How do I define equivalence with functional extensionality formally, in STLC? I thought I should use logical relation, but I got a very complicated proof (not even finished) of eq_refl, is this normal?
01:05:38 <kadoban> How is accumArray in terms of constants? Is it going to be any faster just manually doing some IO mutable array nonsense, anyone have a feeling for that?
01:28:08 <Unhammer> Does ghc do any memoisation of top-level definitions? E.g. if I have a top-level bigwords = Set.fromList [longlist], and at any point during the program I might check if x ∈ bigwords, how/when will the runtime (re-)create bigwords?
01:32:07 <kadoban> Unhammer: Typically monomorphic top level bindings are evaluated at most once, IIUC. So, it will never recreate bigwords.
01:33:18 <Unhammer> ok, cool :)
01:36:25 <AnitaBi-42> 42 bi f from CT, on business tip in Shenyang, China, In hotel room now
01:37:06 <mvdw> Just what I was looking for.
01:43:13 <zomg> sometimes I wonder how these people who clearly have no clue about what irc is find their way on irc...
01:45:58 <ngWalrus> is that where you upload the pictures
01:47:34 <liste> ^that
01:59:51 <jophish> Is there an orphan instance for Arbitrary Vector anywhere?
02:02:42 <neoncontrails> I'm awfully curious: how's build management in Haskell? I see there's a few different build systems available, do they compare favorably to Maven/CMake?
02:04:12 <liste> neoncontrails: most build systems are just wrappers around the Cabal library, which does a lot of things right
02:04:15 <cocreature> neoncontrails: build management of haskell projects or general build tools like make written in haskell?
02:04:31 <cocreature> if you are talking about the former liste is right
02:04:48 <liste> neoncontrails: I mostly use Maven, and I only end up missing the rich plugin ecosystem
02:05:06 <liste> neoncontrails: when I use the Haskell build tools
02:05:06 <cocreature> compared to cmake, the cabal configuration is more “canonical”
02:05:30 <cocreature> whereas cmake is more a language for “writing your own buildsystem”
02:05:49 <Glitchy> ^ This. I wouldn't compare Maven to CMake.
02:06:14 <Glitchy> (we use Maven to build C/++ projects at work)
02:06:44 <neoncontrails> Build management of Haskell projects I think. I'm relatively new to dependency management, but the tooling in Clojure (mostly Maven based) seems painfully fragile
02:08:39 <neoncontrails> It offers some build tools, but in general I find if the project is more than, oh, a year old, it probably won't build correctly
02:09:19 <tdammers> clojure does a strange dance in order to be both a lisp and a jvm language
02:10:26 <liste> neoncontrails: stack doesn't have that problem, all the packages in stackage/lts are guaranteed to build together correctly
02:13:20 <neoncont_> tdommers: sorry, wifi issues. What was that about Clojure's strange dance?
02:13:38 <Glitchy> neoncont_: Clojure has to compromise *a lot*.
02:14:13 <tdammers> ^ this, pretty much
02:14:37 <tdammers> clojure tries to be functional, but in order to run well on the JVM, it has to be a relatively shallow abstraction layer on top of Java's semantics
02:15:01 <tdammers> it tries to have a sensible namespace and module system, but it's limited by how Java does it
02:15:30 <tdammers> and because of all that, it also has to somehow ride on top of the existing Java build and packaging ecosystem
02:15:36 <neoncont_> Glitchy: I don't doubt it. I often feel like I'm implementing something *like* static typing in a typical Clojure program, but of course it's more laborious than in a statically typed language
02:15:43 <tdammers> which, from a lisp point of view, isn't ideal
02:16:05 <tdammers> typing discipline is a similar weird spot
02:16:45 <tdammers> clojure tries to be dynamic, but it also wants to interface with Java's half-assed static type system, so it has to do a strange dance where your code does get compiled, but it mostly feels as if it were interpreted dynamically
02:19:13 <neoncont_> oh, completely. I think that's part of what I like about it – at least, I enjoy being able to build tools that can modify their own compiled source as appropriate
02:20:41 <neoncont_> But I haven't been particularly productive the past month as I've attempted to build a moderately complex Clojure/CLJS web app 
02:21:09 <Unhammer> neoncont_,  I use stack (which in turn uses cabal in a very "managed" manner), and it really works great
02:21:20 <neoncont_> I've spent most of that month chasing down mysterious build conflicts and opaque error messages
02:21:39 <Unhammer> stack has these "curated" lists of dependencies, guaranteed to work together, but you can of course specify that you want e.g. foo-1.0.3 from your own github fork or whatever
02:27:38 <neoncont_> Unhammer: that sounds pretty promising. When importing some arbitrary, user-defined utility library from Github, can it usually be integrated with the rest of a project's dependencies automatically?   
02:28:52 <liste> neoncont_: user-defined as is something you wrote yourself?
02:29:55 <neoncont_> liste: or something another Haskell user wrote. Non-canonical Haskell libraries in other words
02:30:40 <liste> neoncont_: most of Haskell libraries are in Hackage, and those are easy to add as dependencies
02:30:55 <Unhammer> yeah; pretty much all hs projects have a .cabal file that defines the project name and dependencies, it's quite standardised in that way
02:35:02 <neoncont_> I'm increasingly jealous/interested. What's a good starting place to learn how to build web apps in Haskell? 
02:37:09 <tdammers> neoncont_: depends how much you already know about web dev
02:37:38 <sdx23> I'd say "lookup hakyll", as I keep to increasingly dislike "web-apps". But it's a static site generator, so maybe not what you're looking for...
02:38:17 <amx> use servant
02:38:25 <neoncont_> tdammers: somewhat proficient, but still have much to learn. I'm particularly curious how it integrates with the front-end. In Clojure there's Clojurescript which transpiles to JS, but I haven't heard of an analogous tool in Haskell
02:38:36 <liste> neoncont_: there's GHCJS
02:38:38 <tdammers> frontend is a bit of a sore spot
02:38:51 <tdammers> there's GHCJS, but it's not trivial to get set up, and documentation is a bit spartan
02:39:04 <neoncont_> Thanks for the warning :)
02:39:10 <tdammers> then there's Fay, which is simpler than GHCJS but also more limited
02:39:27 <liste> and Haste
02:39:29 <luite_> that is true, although stack setup makes it easy to install GHCJS
02:39:48 <tdammers> was about to mention that
02:39:53 <tdammers> (both of them)
02:40:07 <luite_> and things like reflex-platform also come with an easy way to get up and running
02:40:17 <tdammers> another option is to use something that's not actually Haskell, like Purescript
02:40:21 <luite_> still i should wrap up a proper release :)
02:40:44 <tdammers> if I were to pick one, I'd probably still go with GHCJS right now
02:40:49 <MarcelineVQ> no love for yesod? :>
02:41:25 <tdammers> MarcelineVQ: Yesod doesn't really cover the Haskell-in-the-browser part
02:42:10 <tdammers> that said, Yesod does come with Shakespeare templates, including Julius, which you might consider a way of "integrating with the front-end"
02:42:18 <neoncont_> tdammers: Innnnteresting. This looks like a much better alternative to TypeScript
02:42:45 <tdammers> neoncont_: I think Elm also deserves mentioning, even though my own experience with it was rather disappointing
02:42:48 <MarcelineVQ> Does ghcjs? making phone users download the rts is a bit much, I wonder how Cale et all handle that part
02:44:48 <neoncont_> tdammers: I had a similarly "meh" experience with it, but I think it was just the wrong tool for the job I was using it for (namely animating things)
02:46:18 <tdammers> MarcelineVQ: maybe so, but considering how our Angular web app at work also clocks in at 2 MB of javascript, ...
02:46:57 <tdammers> neoncont_: maybe so, but I'm having a hard time coming up with a job where it is a better tool than a properly documented ghcjs would be
02:46:58 <MarcelineVQ> I don't know much about it so ​I'm honestly curious now about the % of handwritten they use on their frontend
02:47:36 <luite_> MarcelineVQ: reflex-platform has some optimizations that will probably be rolled into the upstream code once there's a proper way to do that. some other optimizations come from ghcjs (dedupe reduces duplication in the result, often nearly cutting code size in half)
02:48:03 <MarcelineVQ> luite_: exciting stuff
02:48:46 <luite_> dedupe is on the ghc-8.0 branch, which unfortunately was incompatible with closure compiler's ADVANCED_OPTIMIZATIONS for some time, due to an oversight on my side. should work again now though
02:57:00 <luite_> MarcelineVQ: i'm working on more improvements. I hope we can also start thinking more seriously about adding a WebAssembly target soon (would be a longer term project, requiring some improvements in the WA spec). Once WA is enabled mobile Chrome we can reach most lower end mobile devices. Desktop and other platforms may be stuck with various versions of JS for now, but they tend to have enough power to work with larger payloads without too much trouble
03:05:58 <MarcelineVQ> luite_: pretty cool, I'd only heard about webassembly fairly recently but it seems to be moving pretty fast
03:11:44 <bwe> Hi, how can I install a package from a hg repo like bitbucket directly using `cabal install`?
03:13:52 <luite_> MarcelineVQ: my goal is to keep the Haskell side pretty much the same, including JavaScriptFFI support and the ghcjs-base API, with the compiler generating the necessary bridge code, but it's not quite clear yet how close it can be without significant compromises
03:18:46 <rydgel> I've got this function "abba = zip4 `ap` drop 1 `ap` drop 2 `ap` drop 3". It seems to be that it looks a lot like a liftM4 one. But I can't manage to refactor it that way
03:19:14 <Axman6> bwe: have you cloned it locally?
03:19:28 <Axman6> cabal has no idea about git or mercurial repositories
03:21:11 <liste> :t (liftM4 zip4 (drop 1) (drop 2) (drop 3), zip4 `ap` drop 1 `ap` drop 2 `ap` drop 3) -- rydgel 
03:21:12 <lambdabot> (([a] -> [d]) -> [a] -> [(a, a, a, d)], [a1] -> [(a1, a1, a1, a1)])
03:21:19 <liste> oh wait
03:21:21 <luite_> cabal does support installing from http though, perhaps bitbucket has a way to download an archive snapshot from a url?
03:21:23 <liste> they're different types
03:22:35 <rydgel> liste: yeah, that's my problem actually :p
03:22:54 <rydgel> by looking at the definition it should be the same
03:27:57 <MarcelineVQ> :t liftM4 zip4 id (drop 1) (drop 2) (drop 3)
03:27:59 <lambdabot> [a] -> [(a, a, a, a)]
03:28:09 <rydgel> oh
03:28:33 <rydgel> omg I'm dumb yeah, it makes sense, thank you MarcelineVQ 
03:29:02 <ski> @type liftM4 id zip4 (drop 1) (drop 2) (drop 3)
03:29:04 <lambdabot> [a] -> [(a, a, a, a)]
03:33:18 <ski> (since  mf = id `liftM` mf = return id `ap` mf  so  mf `ap` ma `ap` mb `ap` mc = id `liftM` mf `ap` ma `ap` mb `ap` mc = return id `ap` mf `ap` ma `ap` mb `ap` mc = liftM4 id mf ma mb mc  and similarly for other arities)
03:36:48 <miladz89> I have a question. what happens when I install a newer version of a package ? eg : cabal install ghc-mod
03:44:39 <delYsid> I have a non-deterministic parser like StateT [a] (ListT (Either e)) b where b is a monoid.  I have a number of alternative monadic parsers I run with fmap fold . whileM (gets $ not . null).  So far, so very nice.  However, I will need to be able to look at all results produces so far from inside of a monadic operation.  I was first pondering WriterT, but as far as I can see listen will only allow me to see a certain piece of output.
03:44:39 <delYsid> So I wonder if I should put the output into the state, and have the monadic return values changed to (), using execStateT instead of evalStateT?  This looks so weird, is there a better way that I am missing?
03:45:15 <Profpatsch> Coud it be that forkIO doesn’t like it if sockets come from the outside?
03:45:26 <Profpatsch> > runTCPClient (clientSettings 6667 "irc.freenode.net") (\ad -> forkIO ((appSource ad) $$ (awaitForever print)))
03:45:28 <Profpatsch> <interactive>: recv: invalid argument (Bad file descriptor)
03:45:29 <lambdabot>  error:
03:45:29 <lambdabot>      Variable not in scope: runTCPClient :: t0 -> (t2 -> t1) -> terror:
03:45:29 <lambdabot>      Variable not in scope: clientSettings :: Integer -> [Char] -> t0error:
03:45:30 <Profpatsch> ThreadId 4586
03:49:06 <Profpatsch> That is: Even with green threads I don’t get to use a socket connection from another thread apparently.
03:49:33 <Axman6> that sounds unlikely, because that's basically how you write network servers in Haskell
03:50:12 <Axman6> listen on a socket, then fork once you get a connection and pass the handle produced to the forked thread
03:53:06 <bwe> Axman6: Okay. So `hg clone ...` then `cd cloned_dir`, eventually `cabal install ./`? 
03:53:17 <Axman6> just cabal install
03:53:54 <Axman6> btw, stack understands git and lets you install packages directly from their repos
03:54:44 <Profpatsch> Axman6: Hm, then it maybe is the fault of Data.Conduit.Network.
03:59:13 <bwe> Axman6: Thanks. the hg clone is okay for me as of now.
04:01:32 <delYsid> > fmap (map snd) $ runExcept $ runListT $ flip execStateT ([1::Int,2],[]::[Int]) $ whileM (gets $ not . null . fst) $ do { x:xs <- gets fst; ys <- gets snd; put (xs, ys<>[x]); pure ()}
04:01:35 <lambdabot>  Right [[1,2]]
04:12:55 <Philonous> Is there something like -XLiberalTypeSynonyms for type families?
04:14:55 <zyla> Profpatsch: runTCPClient probably closes the socket when the supplied action finishes
04:15:17 <zyla> and forkIO returns immediately
04:17:57 <lyxia> Philonous: what are you trying to do
04:18:22 <Philonous> Well, this is what I'm doing: https://gist.github.com/Philonous/0a4a76d7c04717f9ec6710cf6e3d632b
04:19:41 <Philonous> I woud assume that the "no partial application of type synonyms" rule wouldn't apply because after expansion there are no type synonyms left
04:20:59 <Philonous> And :kind! seems to be happy with the type, but if I try to use the type somewhere I get the error
04:21:20 <lyxia> that rule always applies
04:21:34 <Philonous> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/data-type-extensions.html#type-synonyms
04:21:37 <Philonous> Apparently not
04:22:15 <lyxia> hm
04:22:23 <Philonous> Sorry, wrong GHC version: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#liberalised-type-synonyms
04:24:55 <lyxia> okay, it could work with type families
04:25:22 <mpickering> I never knew about that extension heh
04:25:26 <Philonous> Actually, :kind! is happy with partially applied type synonyms even without -XLiberalTypeSynonyms, so maybe :kind! does something else entirely
04:26:41 <Philonous> (:kind too, for that matter)
04:29:31 <mpickering> Isn't this the same problem as you can't partially apply type families?
04:30:17 <Philonous> Well in my example the type family is fully applied
04:30:39 <mpickering> My point is a type family is a generalisation of a type synonym
04:31:26 <mpickering> If you manually expand the type synonyms then I guess it works?
04:32:37 <Philonous> Well the outer application is the type family. If I manually expand that it works, yes
04:32:55 <Philonous> In that case the type synonyms are fully applied anyway
04:34:43 <mpickering> You can write a type synonym as a type family with one clause
04:34:55 <mpickering> I think we are misunderstanding each other
04:44:08 <Philonous> Hmm ok, so there doesn't seem to be a way to work around this. 
04:44:14 <Philonous> At least for now
04:53:19 <Guest6399> Hey all
04:53:39 <b0llu> Hey :) 
04:54:08 <b0llu> I wanted some help with proof reading a haskell tutorial
04:54:26 <b0llu> I'm not great at writing, and English isn't my first language
04:54:39 <b0llu> So, well, could someone please go through and give me some feedback?
04:54:41 <b0llu> http://bollu.github.io/teleport/
05:00:14 <Profpatsch> zyla: Ooooh, you are right.
05:00:31 <Profpatsch> I had >> threadDelay 5000 in my original example.
05:00:48 <Profpatsch> But I read MILLIseconds, it’s MICROseconds
05:00:52 <bwe> mypackage.cabal reads `executable some_exec`. I run `cabal install`. It runs through successfully. `some_exec` is nowhere in $PATH. Where does `cabal install` put the `some_exec` binary?
05:01:21 <Profpatsch> So with >> threadDelay 5000000 it doesn’t crash immediately.
05:01:28 <bwe> How do I install the binary in $PATH correctly?
05:01:34 <Profpatsch> thanks!
05:01:51 <tdammers> bwe: IIRC it goes in either ~/.cabal/bin, or ./.cabal-sandbox/bin
05:02:12 <tdammers> bwe: depending on whether you're using a sandbox or not
05:03:41 <bwe> tdammers: It actually went into ./.cabal-sandbox/bin. I want to package thes stuff rightly. May I assume an end user to have ~/.cabal/bin in $PATH? 
05:07:40 <tdammers> depends on the end user
05:07:47 <hpc> you can assume they'll do what's necessary to use the binary
05:08:03 <hpc> either add ~/.cabal/bin to path, copy it out, symlink it, or some other thing
05:08:19 <hpc> or call it by full path
05:08:50 <tdammers> for source installs, saying that you need ~/.cabal/bin on the $PATH isn't a strange thing to do
05:09:03 <tdammers> for binary installs, it's nicer to have it go into /usr/local/bin
05:12:14 <bwe> tdammers: How can I let it go to /usr/local/bin (which I expected originally)?
05:12:28 <tdammers> bwe: depends how you package your binary install
05:14:08 <bwe> tdammers: What do you mean by this particularly?
05:14:57 <tdammers> bwe: you put the binary in a zipfile or a tarball, and you probably have some sort of install instructions or maybe even an installer script
05:15:23 <hpc> this gets into packaging, and now it depends on if you're packaging it as a tarball or some kind of self-installing shell script, or a deb file, or an rpm, or whatever pacman uses
05:15:39 <hpc> or something weird and gentoo-y where the user builds from source but it's "packaged" so it goes somewhere in particular
05:15:45 <mniip> is there a ghc trick to check what type a function has in a particular place?
05:15:56 <mniip> typed holes are impairing inference here
05:16:44 <hpc> i would expect the hole types to be printed during typechecking
05:16:52 * hpc hasn't used holes yet though
05:17:01 <mniip> yes they are
05:17:05 <mniip> but they print the wrong type
05:17:18 <mniip> as in, their presence alters the typechecking
05:17:35 <hpc> as in if you change a hole to undefined you get a different type?
05:17:52 <mniip> if I have 'f x' and I replace it with '_ x', the constraints associated with 'f' disappear
05:18:11 <mniip> _ infers a more general type
05:18:16 <hpc> well, yes
05:18:19 <mniip> and then instance resolution kicks in and it's all goo
05:18:43 <hpc> you lose the type information associated with f
05:18:53 <mniip> yes
05:18:57 <mniip> I was hoping to avoid that
05:19:32 <hpc> you need to formulate it in a way that the type information where you use f is preserved
05:19:46 <hpc> specifically the type of what f currently is, and the other ways in which it's being used
05:20:00 <hpc> so you probably want to give f an explicit type signature where it's defined and let its implementation be _
05:20:09 <hpc> (if it's something you're defining elsewhere)
05:20:33 <hpc> if it's a function parameter, not sure
05:21:22 <mniip> f is a GADT constructor
05:21:49 <hpc> maybe try asTypeOf
05:21:56 <hpc> (_ `asTypeOf` f) x
05:22:03 <hpc> asTypeOf _ x = x
05:22:07 <hpc> asTypeOf :: a -> a -> a
05:22:57 <hpc> that's probably as close as you can get to querying an expression's type in-place
05:25:08 <quchen> Good gracious, shift/reset are hard to understand.
05:25:19 <quchen> And I thought I understood Cont.
05:26:30 <mniip> hpc, hmm that works better
05:27:01 <Philonous> quchen, I find shift/reset easier to understand than undelimited continuations 
05:27:27 <quchen> Philonous: I don’t even understand the difference between delimited and undelimited.
05:27:43 <quchen> I’ve seen Oleg’s paper and I’m still clueless :-/
05:28:02 <Philonous> quchen, Well, Haskell doesn't even have undelimited continuations
05:28:23 <quchen> I do understand »basic Cont« and callCC.
05:28:36 <quchen> I have no idea what reset/shift are even supposed to do.
05:28:39 <mniip> I admit I don't think I've ever seen a functor instance as complicated as this
05:29:25 <Philonous> quchen, Yes, well, callCC gives you "the rest of the computation" the difference is just that in the undelimited case that means the rest of the entire program, in the delimited case it means the rest of the computation that's wrapped in a reset
05:30:25 <quchen> Philonous: My understanding of callCC is that it allows you to inject the parent continuation into your current computation.
05:30:27 <Philonous> quchen, So the continuation shift gives you is the rest of the computation until reset. Which also means that it actually returns
05:31:45 <Philonous> Yes, it gives you a handle on the continuation. Bascially an invocable pointer of the program position after the callCC 
05:32:17 <quchen> So when I write reset (... >> shift (\k -> X) >> ...), what is k bound to? What is X?
05:32:56 <granomoly> Hey guys! I asked the other day about using haskell as a theorem proover and then I ran into LiquidHaskell. I cannot get over the fact as to how sexy calculus is, and even more-so developing the fundamental theory of calculus through category theory unto directed homotopy type theory. Is there anyone here I can speak to more about using haskell as a theorem
05:32:57 <granomoly> prover, specifically for the development of the theory of calculus? 
05:33:01 <Philonous> Suppose your have reset ( ... >> shift (\k -> X) >>= f) then k is just f
05:33:49 <quchen> Alright.
05:34:02 <quchen> And X? can I somehow execute »the rest« differently in this case?
05:34:58 <Philonous> X is an arbitrary expression you write that can call k
05:35:20 <Philonous> The difference is that k will actually return
05:35:25 <Philonous> So you can call it multiple times
05:35:32 <Philonous> difference to the undelimited case
05:35:45 <mettekou> Do Stack and GHC 7.10.3 work on macOS 10.12 (Sierra) or has the load commands size bug fix not been backported to GHC 7.10.3? I think Stack uses binary versions of GHC, so it shouldn't be a problem?
05:37:18 <quchen> Philonous: Are there applications of shift alone (reset alone)?
05:37:40 <Philonous> You mean if you can use one without the other?
05:37:53 <quchen> Yes.
05:38:08 <mniip> hmm
05:38:24 <Philonous> rest without shift doesn't do anything. Shift without reset isn't allowed, but in ContT there's an implicit reset with runContT
05:38:41 <Philonous> s/rest/reset
05:39:07 <quchen> :t Control.Monad.Trans.Cont.shift
05:39:09 <lambdabot> ((a -> r) -> Cont r r) -> Cont r a
05:39:19 <quchen> That looks allowed to me, reset or not
05:39:36 <quchen> :t Control.Monad.Trans.Cont.reset
05:39:37 <lambdabot> Cont r r -> Cont r' r
05:39:42 <quchen> And this one has an awkward type ;-)
05:39:48 <Philonous> Yes, in Haskell there's always an implicit reset
05:42:05 <mniip> hmm
05:42:56 <quchen> Philonous: The reset being runCont?
05:43:04 <Philonous> Yes, exactly
05:43:09 <quchen> I.e. in order to get something out of a Cont, we have to add reset
05:43:23 <quchen> well, reset is pretty much exactly runCont
05:43:31 <quchen> evalCont*
05:43:32 <Philonous> + lift
05:43:51 <Philonous> reset = lift . evalContT
05:47:31 <quchen> Philonous: My head hurts :-(
05:47:35 <Philonous> quchen, Btw. here's a cutesy example of how to use it: https://gist.github.com/Philonous/2908e026000f9d4e92799d376a4a3e21
05:47:49 <Philonous> The idea is that "split" is a function that "returns twice"
05:48:43 <quchen> Just like »cont (\k -> k 1 + k 2)« “returns twice”?
05:49:15 <Philonous> cont = callCC ?
05:49:19 <quchen> :t cont
05:49:21 <lambdabot> ((a -> r) -> r) -> Cont r a
05:49:29 <quchen> Cont’s smart constructor
05:49:34 <Axman6> :t callCC
05:49:36 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
05:49:41 <Philonous> quchen, Ah, cont = shift
05:49:47 <quchen> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
05:49:51 <quchen> cont = Cont
05:49:58 <Philonous> Yes, and Cont = shift
05:50:02 <quchen> Huh?
05:50:07 <quchen> Okaaaay ..?
05:50:29 <quchen> Shift has the second »r« different though
05:50:32 <quchen> :t cont
05:50:34 <lambdabot> ((a -> r) -> r) -> Cont r a
05:50:38 <quchen> :t Control.Monad.Trans.Cont.shift
05:50:40 <lambdabot> ((a -> r) -> Cont r r) -> Cont r a
05:50:56 <Philonous> Hmm, wait
05:52:25 <Philonous> OK, I seem to be misremembering 
05:52:45 <quchen> Well, Cont r r ~ r, no?
05:52:48 <quchen> :t evalCont
05:52:49 <bwe> tdammers: Is it a good idea to let `make build` execute `cabal build` which places the binary to dist/bin/my_bin? Then to let `make install` just copy it to /usr/local/bin?
05:52:50 <lambdabot> error: Variable not in scope: evalCont
05:53:00 <quchen> :t Control.Monad.Trans.Cont.evalCont
05:53:03 <lambdabot> Cont r r -> r
05:53:09 <quchen> :t pure :: r -> Cont r r
05:53:11 <lambdabot> r -> Cont r r
05:53:53 <quchen> Philonous: ^
05:54:12 <mniip> :t cont . (pure .)
05:54:13 <lambdabot> Applicative f => ((a -> f a1) -> a1) -> Cont (f a1) a
05:56:21 <mniip> :t cont . (Control.Monad.Trans.Cont.evalCont .)
05:56:22 <Philonous> Yes, I think Cont r r ~ r ist true
05:56:22 <lambdabot> ((a -> r) -> Cont r r) -> Cont r a
05:57:00 <c_wraith> In some sense, any value of type Cont r a is equivalent to a value of type r
05:57:20 <c_wraith> Except for how it composes with other values.
05:57:24 <quchen> I see, so shift/reset are just a different APIs for mixing cont/runCont
05:57:29 <c_wraith> (potentially)
05:57:46 <Philonous> quchen, In a way, yes
06:04:17 <Philonous> quchen, Well Cont(T) is the delimited continuation monad, so in a way it's not surprising that it's fundamental operations (cont, evalCont) turn out to (almost) be shift/reset, no?
06:05:21 <quchen> I didn’t know that
06:05:30 <quchen> Trying to change your example to cont/runCont :-)
06:10:06 <quchen> Okay, giving up :-s
06:10:28 <quchen> At least I gained some intuition about shift.
06:10:31 <quchen> Thanks for that!
06:11:27 <Philonous> Oh, no problem :)
06:17:15 <mniip> what was the name for the "data D a = D (b -> a) b" pattern?
06:17:27 <mniip> oh, the store comonad, right
06:17:39 <mniip> hmm no, that is unqantified
06:18:05 <c_wraith> It's Coyoneda Identity, but I don't think that's what you were looking for. :)
06:18:45 <c_wraith> Err, no it's not.  that has the existential on the other side
06:19:01 <mniip> well
06:19:15 <mniip> D :: forall b. (b -> a) -> b -> D a
06:20:01 <c_wraith> Hmm, I was right the first time.  It is Coyoneda Identity
06:20:16 <c_wraith> Plus or minus some newtype noise
06:21:08 <c_wraith> https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Coyoneda.html#t:Coyoneda
06:25:20 <Philonous> quchen, I've added an example of the use of reset: https://gist.github.com/Philonous/2908e026000f9d4e92799d376a4a3e21
06:36:53 <ocramz> hullo!
06:37:07 <ocramz> can criterion profile multithreaded runs as well?
06:37:58 <ocramz> I observe a sizeable variance when running `parallel` code using 1 or 2 cores
06:38:03 <ocramz> threads, I mean
06:41:01 <Shockk> hello, I have a couple of questions 
06:41:05 <quchen> Philonous: Excellent, thanks!
06:41:53 <quchen> Philonous: Super helpful, thanks! You might even consider adding this as doctests to the actual lib!
06:42:28 <Shockk> I'm looking at the example for existential quantification on this page https://wiki.haskell.org/Heterogenous_collections and I see that it maps `show` over the list of heterogenous values that are all constrained by Show
06:43:24 <Shockk> the first thing I'm wondering is,does this do some sort of runtime lookup of each Show instance? because I'm not able to see a way for it to happen at compile-time
06:45:53 <mniip> Shockk, what do you mean exactly
06:45:54 <quchen> Shockk: The runtime representation of Show is a function (a -> String) for each a that is an instance of Show.
06:46:22 <quchen> Shockk: So what that list contains is equivalent to »forall a. (a -> String, a)«.
06:46:26 <mniip> MkShowable includes the Show instance
06:46:37 <Shockk> I mean, to determine which instance of Show should be used when calling `show`, is that done at runtime?
06:46:41 <mniip> no
06:46:54 <quchen> Forall? Exists, rather.
06:47:04 <Shockk> hmm
06:47:20 <mniip> Shockk, instance lookup happens when you construct MkShowable
06:47:48 <mniip> @let data Showable = forall a. Show a => MkShowable a
06:47:51 <lambdabot>  Defined.
06:48:01 <mniip> @let foo = MkShowable 123
06:48:03 <lambdabot>  Defined.
06:48:13 <mniip> foo now contains 123 and Show Integer
06:48:37 <Shockk> hmm okay
06:48:46 <mniip> > case foo of MkShowable x -> show x
06:48:49 <lambdabot>  "123"
06:48:56 <Shockk> so that instance is sort of packed/stored along with the 123?
06:49:05 <mniip> here we unpack (x :: a) and (Show a) from MkShowable
06:49:25 <mniip> well, not packed, just a reference
06:49:29 <Shockk> right
06:49:34 <mniip> a typeclass is like a datatype
06:49:40 <mniip> an instance is like a global object of that datatype
06:49:41 <Shockk> hmm okay that makes sense
06:49:53 <mniip> in fact, lemme dig up some of my hacks
06:50:23 <lpaste> mniip pasted “instance representation” at http://lpaste.net/1856395241695739904
06:51:44 <mniip> the unsafeCoerce between 'Dict c' and 'Box (DictRep c)' is where the representation equivalence magic happens
06:53:07 <Shockk> I'm unsure if your code is related (it looks like it might possibly be but I can't tell), but: my sort of larger, related question is; is there something similar to Dynamic, but for typeclasses? for example, if I have a Dynamic, or, let's actually call it DynInstance or something
06:53:56 <Shockk> would there be some way for me to have something like a DynInstance that retains information about what instances the value has, and for me to look up the value constrained by one of those instances, if that sort of makes sense
06:54:16 <Shockk> for example er, 
06:55:00 <Shockk> fromDynInstance :: c a => DynInstance -> Maybe a
06:55:02 <Shockk> or something like that?
06:55:11 <Shockk> where c could be Show or Num or etc
06:56:05 <Shockk> if I'm not explaining what I'm trying to ask very well please let me know
06:56:40 <mniip> uhh
06:56:52 <mniip> DynInstance a, right?
06:57:10 <Shockk> a?
06:57:26 <mniip> "DynInstance that retains information about what instances the value has"
06:57:28 <mniip> which value?
06:58:06 <Shockk> ah, let me try and show an example of what I'm wanting to do
06:58:19 <mniip> anyway what you're suggesting sounds impossible
06:58:52 <Shockk> a list of Dynamic values would be something like [toDyn 123, toDyn "hello", toDyn True], right?
06:58:58 <mniip> because such a function allows you do witness absence of a typeclass
06:59:02 <Shockk> hmm
06:59:09 <mniip> which shouldn't be allowed
06:59:15 <Shockk> ah 
06:59:39 <sclv> you could create a custom Dyn that baked in some constraints
06:59:48 <Cale> MarcelineVQ: People watch YouTube videos on their phones now, a few hundred KB of Haskell runtime isn't so bad.
06:59:51 <sclv> and captured the dictionary
06:59:57 <sclv> it would be a DynWithShow or etc
07:00:08 <Shockk> what I'd really like is to be able to take that above list, and do something like
07:00:48 <Shockk> case fromDynInstance (head list) of
07:00:54 <Shockk>   Just x -> show x
07:00:58 <Shockk>   Nothing -> undefined
07:01:05 <Shockk> I can see why this might be impossible yes
07:01:12 <mniip> witnessing absence of a typeclass
07:01:24 <mniip> of an instance rather
07:01:38 <Shockk> I don't fully understand what witnessing absence means but I sort of see what you're saying
07:02:32 <sclv> for your specific case, imagine you wrote (and this isn't a general pattern, but a specialization of one)
07:02:57 <sclv> `data DynWithShow = DWS (Maybe String) Dyn`
07:03:19 <sclv> and your `toDynWithShow` also just showed the value and stuck it in a Just
07:03:28 <sclv> then, you can see how to write what you suggested, right?
07:03:41 <sclv> for any given dictionary there's something _like_ that you can sort of do
07:04:20 <sclv> but for binary functions (i.e. >, + etc) then it won't really be useful on its own without some further poking around
07:04:23 <Shockk> hmm right I see yes
07:04:46 <sclv> i'm not advocating you do that per se, but seeing that pattern lets you often break through the roadblocks in the first place that sort of "drove" you to looking for that :-)
07:05:00 <mniip> Shockk, the basic idea is,
07:05:12 <mniip> if you take a value witnessing absence of an instance
07:05:22 <mniip> and then in another module define the instance and import the value
07:05:25 <mniip> you're breaking RT
07:11:16 <lpaste> Shockk pasted “Pong.hs” at http://lpaste.net/349659
07:11:31 <Shockk> mniip: sclv: this is more or less what I've been thinking about
07:12:31 <Shockk> (just elaborating to clear any confusion on why I was asking about this)
07:12:48 <Shockk> where Sprite, Bounds, Phys, and Position are all typeclasses that I'd like to be able to lookup on values
07:14:24 <Shockk> but where my main engine code wouldn't necessarily need to know about any of these typeclasses, and where I could make a new typeclass something like Printable maybe, and write some additional bit of code that can lookup Printables from the engine without the engine needing to know about it
07:17:52 <mniip> Shockk, see point 1
07:18:21 <mniip> the best you can do is
07:18:26 <Shockk> point 1?
07:19:08 <mniip> class AssociatedData a where position :: Postition; position = error "Not implemented"; velocity :: Velocity; velocity = error ...
07:19:20 <mniip> i.e plop all typeclasses into one, with default method implementations
07:19:35 <Shockk> hmmm ah right.. I see
07:21:35 <Shockk> what I'm doing currently is instead of trying to do this with instances, I'm just using actual separate data types for each of these components, and I associate the Dynamic for each of those with the Dynamic for the original value (i.e. the Ball or LeftPaddle or RightPaddle)
07:22:26 <Shockk> I thought of the instances thing because it might be cleaner to write than what I was doing previously, but what you said makes sense about why I can't do that
07:23:13 <sclv> my main thought would be -- why do you want the `Dynamic` at all?
07:23:29 <sclv> like... why not just have a sum type that encompasses precisely the types you want and no others?
07:24:03 <Shockk> sclv: hmm one sec 
07:25:38 <Shockk> sclv: http://i.imgur.com/d7e82mG.png
07:26:32 <Shockk> in my design I have an engine core that holds all the objects that currently exist in the engine as well as their components (position, phys, sprite, etc)
07:27:12 <Shockk> but I'd like someone to be able to add some new system that operates on a new kind of component
07:27:24 <leshow> hey guys. im trying to work through how the types match up for (fmap . fmap). can someone help me out with the substitution of the fmap into (.) arguments?
07:27:26 <Shockk> like a VoxelWorld system that operates on BlockRep components
07:27:31 <sclv> Shockk: ah, someone else entirely you mean
07:27:34 <Shockk> and in that case, I want the engine core to still work with that
07:27:35 <Shockk> yep
07:27:37 <Shockk> i.e. not me
07:28:04 <sclv> so yeah, i'd just do a list of effectively tuples
07:28:08 <Shockk> and at some point in the future I'd also want to think about adding support for hint, to be able to load stuff dynamically
07:28:17 <sclv> with the data that your system knows about in one component
07:28:32 <sclv> and the data that only they know about packed into the `Dyn` of the other component
07:28:41 <sclv> or even, with the other component being not dynamic, but just parameterized over
07:28:59 <sclv> so they can just write the sum type that works for them :-)
07:29:51 <Shockk> what I actually have right now is a HashMap of TypeRep => InnerStructure
07:30:02 <mniip> hmm, how would I express
07:30:10 <Shockk> hmm 
07:30:14 <Shockk> I forgot what the structure is now
07:30:19 <mniip> forall a b. ((a, C a) -> (b, C b)) -> ...
07:30:22 <leshow> like, what is "a" in (.) :: (b->c)->(a->b)->a->c for (fmap . fmap)
07:30:31 <mniip> without resorting to Dict
07:31:56 <Shockk> sclv: ah right, I remembered; I have a hashmap of TypeRep => InnerStorage, where InnerStorage has an indexable Vector of Dynamics, and it also has a HashMap from TypeRep to KeyStorage, where KeyStorage is a HashMap from Int to Int
07:31:58 <Shockk> lol
07:32:18 <mniip> leshow, if (.) :: (b -> c) -> (a -> b) -> a -> c; fmap1 :: (d -> e) -> p d -> p e; fmap2 :: (f -> g) -> q f -> q g
07:32:50 <mniip> then in fmap1 . fmap2, (b -> c) ~ (d -> e) -> p d -> p e, (a -> b) ~ (f -> g) -> q f -> q g
07:33:12 <Shockk> that sounds weird but it means I can store multiple values of the same type, for every type, and then for each of those types, I can also store keys of any type, that map to one of the values
07:33:44 <leshow> mniip, what is a and c then?
07:33:44 <mniip> a ~ (f -> g), b ~ (d -> e) ~ (q f -> q g), c ~ (p d -> p e)
07:33:57 <leshow> hmmm
07:34:15 <mniip> d ~ q f, e ~ q g
07:34:43 <mniip> resulting type, (a -> c) ~ (f -> g) -> p (q f) -> p (q g)
07:35:42 <mniip> :t fmap . fmap
07:35:43 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:36:19 <leshow> yeah, you got it. im gonna have to work through that again to get it i think. i didnt get how the fmap would be divided into a and c
07:36:40 <mniip> well
07:36:53 <mniip> if 'a b ~ c d' then 'a ~ c' and 'b ~ d'
07:37:01 <mniip> and (->) is no different
07:37:15 <emutu[m]> really?
07:37:17 <mniip> if 'a -> b ~ c -> d' then 'a ~ c' and 'b ~ d'
07:37:30 <mniip> and (->) ~ (->) but that's tautology
07:37:58 <byorgey> emutu[m]: really
07:37:58 <mniip> leshow, maybe try a simpler example first
07:37:58 <leshow> but in this case isnt is a -> b -> c ~ (c -> d)
07:38:03 <mniip> such as "flip id"
07:38:10 <byorgey> although this does not apply to type family applications
07:38:10 <leshow> because its got like 2 args and a return
07:38:26 <mniip> leshow, "a -> b -> c" = "(a -> b) -> c"
07:38:29 <mniip> errrrr
07:38:35 <mniip> leshow, "a -> b -> c" = "a -> (b -> c)"
07:39:12 <leshow> right, ok
07:39:27 <mniip> again, go try "flip id" first
07:39:31 <leshow> ill try it on paper, thanks
07:40:37 <lyxia> leshow: http://lpaste.net/349660
07:40:59 <lyxia> += layout
07:41:37 <leshow> lyxia, thank you this helps a lot
07:46:22 <grazie> Hi, is there a way to run this to ensure that result is a list of Int, and not Integer? `nps <- replicateM n (randomRIO (minp, maxp))`
07:48:32 <grazie> I'm passing the result to a function that's expecting type Int, not Integer
07:49:10 <lyxia> make minp and maxp Ints
07:50:18 <grazie> lyxia: right now, when I set the args for n, minp, maxp  in ghci, I'm simply doing `:set args 2 3 6`. What should I do instead to make them Int?
07:50:44 <grazie> lyxia: i guess they're being interpreted as type Integer when I set the args
07:51:44 <lyxia> grazie: how are you reading the args
07:52:15 <grazie> lyxia:  'n: minp: maxp: rest <- fmap (fmap read) getArgs'   (it's not my code)
07:52:53 <grazie> (I'm just tinkering with someone else's program in ghci but ran into this type issue)
07:53:07 <sdx23> :t \n minp maxp -> replicateM n (randomRIO (minp, maxp))
07:53:09 <lambdabot> Random a => Int -> a -> a -> IO [a]
07:53:10 <lyxia> annotate like this: n : minp : maxp : rest <- fmap (fmap read) getArgs :: IO [Int]
07:53:11 <sdx23> :t \n minp maxp -> replicateM n (randomRIO (minp :: Int, maxp))
07:53:13 <lambdabot> Int -> Int -> Int -> IO [Int]
07:54:41 <grazie> lyxia: thanks, trying it now (I tried s/t similar before but got syntax wrong)
07:59:03 <grazie> thank you for your help
08:00:05 <grazie> sdx23: so this sets maxp and not merely minp to type Int too?  `(randomRIO (minp :: Int, maxp))` 
08:01:27 <sdx23> grazie: observe that the two had the same letter, "a", in the type signature - so the must be of the same type.
08:01:28 <lyxia> I'm not sure why, but your previous code seemed to be defaulting n, minp, maxp to integers.
08:01:42 <lyxia> 'Integer's
08:02:15 <sdx23> :t replicateM
08:02:17 <lambdabot> Applicative m => Int -> m a -> m [a]
08:02:24 <grazie> sdx23 ok, great, I get it now, thank you
08:04:02 <lyxia> grazie: read is a bit tricky to use, because its behavior depends on the output type, which can often not be inferred in an interactive session.
08:04:07 <grazie> lyxia: actually to do my testing, I ended up setting those variables like so in ghci `let minp = 3` - that's where it default ed to Integer
08:04:26 <lyxia> oh that explains it
08:04:26 <grazie> lyxia: I wasn't sure which read the program was using - it doesn't import Prelude
08:04:47 <lyxia> uh, prelude is implicitly imported
08:05:01 <lyxia> did you mean that this was turned off
08:06:58 <grazie_> lyxia: sorry my internet cut off, Prelude is not explicitly imported
08:07:24 <grazie_> lyxia: I (still a novice) assumed htat it had to be explicitly imported as I've seen that in many projects
08:07:38 <grazie_> lyxia: is it being explicitly imported simply to limit or hide some parts of the Prelude?
08:07:48 <geekosaur> only when something is explicitly being hidden (or parts imported qualified)
08:08:28 <geekosaur> often because someone wants I/O from Text or ByteString instead of the String-based ones in Prelude, but there are other similar reasons
08:09:02 <grazie_> geekosaur: ok, thank you, I probably read that somewhere early on... so the `read` func  would be from Prelude 
08:09:15 <geekosaur> there's also a quick hack for backward compatibility with parts of Control.Applicative being migrated to Prelude in 7.10
08:13:10 <grazie_> thank you for clearing that up 
08:19:22 <niez> hi, is there a way to add standalone deriving instances for all data types in a module? I have to manually add deriving (Eq, Ord, Read, Show, Generic, ...) to every data type, maybe there is a TH function that would allo to give list of types and list of type classes?
08:22:05 <lyxia> It should be possible to implement in TH, but I haven't heard of an existing implementation.
08:24:51 <sdx23> niez: do you really need it? People tend to forget code readability over comfort while writing.
08:28:37 <younder> Well I find versions of documentable programming easier to maintain over time.
08:29:31 <oherrala> niez: use editor macro or template or such? :)
08:30:05 <niez> sdx23, the use case is: I have a module where I defined data types for groundhog, I have about 50 types (tables), and I want to show my example project in haskell to my co-workers, and they are used to python/ruby/whatever, this repeated line over and over again is just silly
08:30:56 <ertes> helo
08:31:29 <niez> sdx23, the same thing with data type with only one data contructor, data Client = Client { ... }, data Something = Something { ... }, this doesn't look good
08:31:46 <ertes> niez: what's the question?  you want to hide the redundancy?
08:31:50 <niez> a lot of boilerplate
08:31:55 <anoe> Hello, what is wrong with this error: http://pastebin.com/zXpbX5r3 (thanks for help)
08:32:01 <niez> ertes, yes
08:32:13 <ertes> niez: to promote haskell?
08:32:49 <anoe> (error in the Right r pattern)
08:33:52 <niez> ertes, I'm looking for a way to remove boilerplate code in typical web app scenario, where you have some data types mapped to database tables
08:34:38 <niez> ertes, repeating this and that doen't present Haskell like a good choice
08:34:46 <ertes> niez: well, in haskell that's not redundancy, so it would be honest if you just showed both the type and data constructor, and then explain the difference (perhaps show them a sum type like Maybe for comparison)
08:36:52 <ertes> niez: the thing is (in my experience): if you show everything, people will ask questions, and you should be prepared to answer those questions…  if you hide stuff, and people are actually interested enough to check it out, then they will more likely go "WTF!", and you're no longer around to explain
08:37:14 <niez> etrepum, if I have only one data constructor, why GHC can't 'guess' the name? I know that I can make a data type without data constructors, but what if I do it like this: data SomeType = { something :: Text }, maybe GHC could 'guess' that name for this data constructor?
08:37:20 <lyxia> anoe: paste the full error message. We're missing its location.
08:37:33 <lyxia> anoe: the full code would help provide context too.
08:38:18 <ertes> niez: why doesn't python guess the 'def'?  why doesn't C++ guess the 'void'?  at least in haskell the data constructor has meaning and isn't just a syntactic quirk =)
08:39:19 <niez> ertes, well, in this case I think it could be simplified, negative syntactic sugar or something
08:39:40 <ertes> niez: to answer your question: haskell *could* pick the type name as the default for single-constructor data types, but it doesn't…  and you shouldn't hide that fact
08:40:17 <niez> ertes, maybe good idea for new GHC extension?
08:41:06 <niez> I don'tknow all the implications, but it looks very very simple
08:41:21 <ertes> niez: i constantly complain that -XTupleSections is not standard…  and yes, i even complain in front of an audience that is new to haskell (i give haskell workshops from time to time)…  the end result is that people appreciate my honesty, even though it's pretty clear that i like haskell =)
08:42:53 <ertes> niez: feel free to write a proposal (maybe address it to the haskell-cafe first)
08:43:42 <niez> ertes, ok, thanks for your explanations
08:44:16 <niez> but this standalone deriving thing should be doable using simple TH function, right?
08:44:32 <ertes> niez: standalone deriving thing?
08:44:51 <niez> "is there a way to add standalone deriving instances for all data types in a module? I have to manually add deriving (Eq, Ord, Read, Show, Generic, ...) to every data type, maybe there is a TH function that would allo to give list of types and list of type classes?"
08:45:09 <anoe> lyxia: thanks, I am close to find it.
08:46:19 * mniip prods edwardk 
08:46:54 <ertes> niez: yeah, you could do that using TH, but it comes at a cost: firstly TH eliminates global references (TH makes scopes less obvious), secondly TH makes reasoning from source code much harder
08:47:24 <ph88^> https://www.fpcomplete.com/blog/2016/12/concurrency-and-node
08:47:26 <ertes> niez: in other words: i recommend that you derive explicitly, even if you do it with an editor macro
08:49:09 <niez> ertes, ok, got it, it's just... I'm scrolling over my code and I se over and over again a pattern, and this is Haskell, right? common patterns should be abstracted, right? or not always?
08:49:58 <ertes> niez: semantic patterns, not necessarily syntactic patterns
08:53:51 <niez> hm, is TH able to _modify_ my data types? for example, make all fields stict by adding ! in front of a tyle in all fields?
08:54:14 <byorgey> niez: no
08:55:06 <niez> byorgey, and what do _you_ think about this repeated deriving pattern?
08:55:29 <pez> "Haskell and Python are'nt all that different" <-- what's your opinion on that topic? 
08:56:48 <JuanDaugherty> dumbass
08:57:49 <pez> thanks, that's the answer i was looking for. have a nice day :) 
08:58:24 <geekosaur> well, they're not all *that* different if you are talking about layout
08:58:41 <geekosaur> but that's also where the similarity ends
08:58:44 <JuanDaugherty> :) hopefully if you work with that person you are making much money
08:59:35 <JuanDaugherty> and they're both more or less general purpose computer programming languages
08:59:42 <sras> I cannot get stack to use the local patched version of a library. I have included the dir path under the package key in stack.yaml and ran stack build.
09:00:55 <grantwu> ugh, ghc-modi is continually crashing under atom and I have no idea why..
09:01:12 <glguy> sras: First step is probably to share your stack.yaml on a pastebin
09:02:19 <niez> sras, I would go with cloning original repository, make changes in your repository and use that using location/git/commit in stack.yaml so your environment could be reproduced by others
09:03:27 <sras> glguy: this is my stack.yaml http://lpaste.net/6710944880274702336
09:03:44 <sras> glguy: mime-mail is the package in question..
09:04:25 <ocramz> has anyone ever benchmarked `parallel`-based code using `criterion`? I'm trying to gauge the variance of the one-shot results
09:04:57 <ocramz> I'd be happy even if someone can point me to a codebase that does it
09:05:33 <kadoban> sras: Did you try setting extra-dep true as well? You might have to use the syntax that starts with "- location: mine-mail" or something possibly (look up in the comments in your file)
09:06:28 <sras> niez: kadoban location format can take a file path?
09:09:21 <niez> sras: it looks like it can: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
09:10:11 <niez> sras, directory path to be specific, in case of a file it looks like it expects .tar.gz or something
09:11:02 <dazednconfused> Hi guys. I'm working on an assignment to unify two expressions. I've almost finished it but I'm stuck at a point and could really use some advice
09:11:16 <dazednconfused> Care to help a newb out? :)
09:11:37 <liste> dazednconfused: what do you have so far?
09:12:55 <sras> niez: kadoban glguy Ok guys. I was editing the wrong file. Sorry. 
09:13:23 <lpaste> dazednconfused pasted “Stuck” at http://lpaste.net/349668
09:14:22 <dazednconfused> So I'm stuck when trying to unite two functions. The idea is that if the function symbols match, I try to unify the first two terms of the list, which returns the new terms and a new substitution list
09:14:50 <dazednconfused> I then need to apply the substitution list to all of the list, and then proceed to try and unify the next two items of the list
09:15:23 <kadoban> sras: Ah, okay, cool. Ya I think it can take a file path.
09:16:38 <dazednconfused> If I remove the tryUnify function call from line 15 and just return the tuple, I can see that I have the right answer till then
09:17:36 <pavolzetor> I updated from LTS to nightly and now the runGet with vector seems sto have no huge memory usage
09:18:26 <pavolzetor> (for those helping yesterday)
09:19:04 <nitrix> https://github.com/ezyang/ghc-proposals/raw/backpack/proposals/backpack/unit-identifier-pictorial-equivalence-example-2.png
09:19:16 <nitrix> How would one describe what is happening here to the two `g`'s?
09:19:31 <nitrix> It looks similar to stream fusion to me.  map f . map g = map (f . g)
09:19:40 <pavolzetor> I mean now it uses about 320 MB instead of over 1 GB
09:20:39 <dazednconfused> liste?
09:21:20 <pavolzetor> I stick with storable vector for now, but nice to see that improvement
09:28:42 <nitrix> I have a similar question, f . g being the composition of f over g, meaning the output of `g` has the same type as the input of `f`, what would be the name of the property of two similar functions whose inputs type must be identical?
09:28:53 <nitrix> As in \f g x -> (f x, g x) ? Distributive?
09:29:55 <mniip> 1481217549 [20:19:09] <nitrix> It looks similar to stream fusion to me.  map f . map g = map (f . g)
09:30:12 <mniip> that's called "map preserves composition"
09:30:52 <mniip> (also in the linked picture I think that's a q)
09:31:01 <nitrix> mniip: How about reducing my question of "composing" two functions that takes the same input type?
09:31:14 <nitrix> IS there a name for that?
09:31:19 <mniip> well there's no equation there
09:32:27 <mniip> as for the operation name,
09:32:36 <nitrix> unknown :: (a -> b) -> (a -> c) -> a -> (b, c)
09:32:41 <mniip> the docs for Control.Arrow.&&& is called "fanout"
09:32:50 <mniip> it's
09:32:54 <spion> How does forkIO work in Haskell?
09:33:04 <spion> Is there a backing thread pool for cpu-intensive tasks?
09:33:05 <glguy> reliably
09:33:10 <mniip> magically
09:33:25 <spion> What happens if that thread pool is exhausted i.e. each thread is doing CPU work
09:33:31 <spion> Does it resize automatically?
09:34:04 <grantwu> it sends an email to SPJ and asks him to personally rewrite your code in an event loop style
09:34:07 <dazednconfused> nitrix: Do you think you can help me out?
09:34:13 <mniip> spion, GHC threads of execution can switch between OS threads
09:34:50 <glguy> spion: You might be interested in https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#Capabilities
09:35:02 <spion> glguy: thanks!
09:35:06 <grantwu> spion: https://www.fpcomplete.com/blog/2016/12/concurrency-and-node might also be useful
09:35:18 <spion> grantwu: thats what prompted the question
09:35:59 <grantwu> oh.  well, then it's not going to be useful :P
09:36:04 <spion> grantwu: so even haskell's green threads can context-switch in the middle of cpu-bound work?
09:36:29 <grantwu> I personaly have no clue.
09:38:09 <dazednconfused> guys is there a "haskell newbie" channel?
09:38:19 <geekosaur> there is #haskell-beginners
09:38:23 <dazednconfused> thanks
09:38:42 <grantwu> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#TheSchedulersmainloop seems to imply there is some sort of time slicing thing
09:39:33 <geekosaur> spion, I think it only context switches at a memory allocation or a yield for I/O wait
09:40:15 <geekosaur> (or a "safe" FFI call since that gets migrated to a dedicated thread)
09:41:41 <grantwu> geekosaur: Did you look at the "In Node.JS concurrent computations starve each other of resources" section?  I'm not 100% sure if it contradicts what you are saying
09:42:54 <spion> geekosaur: so then I guess its possible to cause starvation in Haskell as well, by running N forkIO threads that do cpu-intensive stuff.
09:42:56 <geekosaur> mm, it does mention time slicing there. and pretty much nowhere else, so. :/
09:43:03 <spion> thats what I'm wondering about
09:43:18 <geekosaur> grantwu, I'm looking at the ghc docs. Node.js is relevant?
09:43:31 <grantwu> geekosaur: Sorry, the https://www.fpcomplete.com/blog/2016/12/concurrency-and-node post
09:43:45 <grantwu> which is what prompted spion to ask
09:44:30 <grantwu> Judging by the benchmark results they give, it would seem like they will preempt cpu-intensive stuff
09:45:09 <geekosaur> mm, possibly. but in a functional program, yielding at memory allocations gives you more timeslices even in more CPU intensive code :)
09:45:23 <grantwu> haha
09:45:32 <geekosaur> (and any program could yield there anyway because of GC)
09:46:24 <spion> Ah, thats definitely an improvement then. But normally in node this is dealt with by spawning several workers and sending things (e.g. request file descriptor) to the non-busy ones
09:46:25 <geekosaur> then again if something fuses, you have no allocations. but I'm dubious about time slice handling because that's a *known* screw case
09:46:28 <geekosaur> (in ghc)
09:47:13 <geekosaur> delayed responses to interrupt/^C etc.
09:47:38 <geekosaur> (you won't see this in ghci because it is unoptimized so nothing is ever fused)
09:50:09 <granomoly> Is there anyone here I can speak to more about using haskell as a theorem prover, specifically for the development of the theory of calculus? 
09:50:47 <geekosaur> I suspect you'd have better luck on the haskell-cafe mailing list
09:52:10 <Cale> granomoly: Haskell is not a theorem prover, it's not really suitable for that purpose.
09:52:24 <granomoly> apajx: Yes, I actually saw that yesterday and was mindblown by the timing.. It's too new it seems, and so I don't expect any experts. Having some familiarity with HoTT in Haskell however, I figured someone may know more about theorem proving in Haskell.
09:52:53 <granomoly> Cale: I realize it's not a theorem prover in the same way C or Scheme is not a theorem prover.
09:53:03 <Cale> granomoly: If you regard Haskell's type system as a logic, it is inconsistent, because Haskell is Turing complete: it lets you write a fixpoint combinator via recursion: fix f = x where x = f x
09:53:18 <Cale> fix :: forall a. (a -> a) -> a
09:53:33 <Cale> and so, by applying that to the identity, you get a "proof of anything"
09:53:57 <Cale> You can also see that as a justification of circular reasoning
09:54:05 <Cale> "If a implies a, then a"
09:54:32 <granomoly> Luckily, I've yet to concede haskell's type system as a... type.. of logic :p
09:54:56 <Cale> Well, that's basically what you're asking for, or at least, that's how I read it.
09:55:16 <Cale> If you want a type system which *is* fit for this purpose, try Coq or Agda
09:55:38 <granomoly> I do wonder however, in the same way I can construct all kinds of logics in Agda and Prolog, moreso Coq, if there's a similar manner haskell will leave me some room to prove things constructively
09:55:44 <granomoly> oh.
09:55:57 <granomoly> But.. I want Haskell :(
09:56:09 <AndreasK> Someone used Template haskell as a prover I think
09:56:20 <Cale> Note that what I'm talking about is different from writing a proof assistant *in* Haskell
09:56:21 <AndreasK> Theres a post about it on the haskel subreddit but I haven't read it
09:56:34 <Cale> You can of course do that: Agda is written in Haskell for example.
09:57:05 <granomoly> Cale: are you familiar with LiquidHaskell?
09:57:18 <Cale> You could also have some sort of embedded language of proofs and a runtime proof checker.
09:57:31 <Cale> Yes.
09:58:24 <granomoly> LiquidHaskell too is a different dimension from Coq? Should I simply use Mathematica then? *sigh*
09:58:39 <Cale> Mathematica isn't really suited for doing *proofs*
09:58:48 <granomoly> I agree, entirely. 
09:58:50 <Cale> It's really just for doing *calculations*
09:59:13 <granomoly> Well, so then Agda it is.. :(
09:59:27 <granomoly> Thanks so much Cale.
09:59:28 <Cale> If you want to do calculations in Haskell, that's fine -- there's only a limited amount of libraries which have been written, but there's some stuff hanging around.
09:59:40 <JuanDaugherty> it's pretty good for that though i use this Solve  [180/ xw == 0.935, xw] to find my lean body weight
10:00:04 <Cale> That's pretty lazy
10:00:08 <Cale> haha
10:00:43 <JuanDaugherty> or actually the reverse
10:00:59 <JuanDaugherty> and yeah you can just do the division igess
10:01:07 <Cale> yeah
10:01:13 <granomoly> Maybe there's some kind of proof assistant already written in haskell, for haskell? :O
10:03:19 <JuanDaugherty> (meant bodyweight for given lbw, didn't realize to late you could just divide by the ratio, so still have it in a notebook)
10:03:29 <JuanDaugherty> *till late
10:05:20 <orion> Can c2hs's "{#get" be used to access a value many levels deep within multiple layers of structs?
10:05:26 <orion> (safely)
10:34:27 <tom___> \join #puzzles
10:49:40 <cocreature> is there a package that provides something like weird Word1, Word2, …? I don’t care if they are implemented as wrappers around the next larger power of two
10:50:23 <nek0> Hi folks. I have a short question, I can't seem to find the answer for myself. How can I profile Haskell programs without installing profinling packages?
10:50:44 <glguy> No
10:50:45 <cocreature> nek0: you can’t. that’s what profiling packages are for :)
10:51:31 <yulax>  /buffer 18
10:51:43 <Tuplanolla> With `/usr/bin/time`, nek0.
10:52:00 <nek0> cocreature: I don't have all the profiling packages. There are some libraries I built myself.
10:52:13 <cocreature> nek0: then rebuild them with profiling enabled
10:52:49 <cocreature> nek0: stack or cabal new-build will do this automatically. it’s been too long since I’ve used plain cabal to remember if it just gives an error or actually rebuilds things
11:00:15 <grantwu> I'm starting to think that the fp complete article is just bad
11:00:54 <grantwu> It ignores advances in JavaScript syntax and doesn't actually explain the differences in scheduling
11:02:06 <grantwu> There's definitely room to do better I think
11:02:46 <Lokathor__> onlyAttemptOnce act = act `orElse` (return ())
11:03:47 <Lokathor__> I now know how to undo STM's re-attempts. Whee
11:06:48 <ertes> Tuplanolla: you're talking about benchmarking, which isn't quite the same thing
11:06:58 <AndreasK> cocreature: Words as in 1-byte 2-byte etc? Theres Data.Word for that
11:07:20 <AndreasK> cocreature: Not sure of it does arbitrary sizes though
11:07:21 <cocreature> AndreasK: no sorry should have been more precise. I want 1bit, 2bit, …
11:07:28 <ertes> cocreature: type-level-indexed?
11:07:44 <cocreature> ertes: not necessarily
11:08:00 <cocreature> currently I just define a few newtypes myself but I feel like somebody should have done this already
11:08:16 <AndreasK> There is also Data.Bits for accessing the nth bit (or setting it) afaik
11:08:50 <ertes> cocreature: my last search for such a package is about 1-2 months back, and i couldn't find any…  ended up going with Word
11:09:02 <ertes> cocreature: the arithmetic is the same anyway
11:09:18 <Lokathor__> cocreature, most don't need a 10-bit word, so it doesn't quite make it into the libs
11:09:21 <cocreature> ertes: well depends on how you do overflows
11:09:27 <cocreature> but I don’t need any arithmetic
11:09:46 <cocreature> I’ll just go with my newtypes, thanks
11:10:14 <Lokathor__> That's how I made my Word10 type when I needed it
11:10:34 <cocreature> at some point I should throw together a package defining only these various newtypes
11:12:27 <AndreasK> cocreature: What do you use them for?
11:12:50 <cocreature> AndreasK: I’m defining data types for an ISA and some fields in an instruction have weird bit lengths
11:15:13 <AndreasK> Makes sense. I've needed to decode bytecode a while ago but I just upsized the fields to int instead.
11:17:06 <ertes> cocreature: i'd probably define a Nat-indexed type family for that…  advantage: you get the size neatly encoded in the type, and a static choice of the most efficient underlying word type
11:18:22 <cocreature> ertes: yeah I’ll probably do that at some point, but I only need three different word sizes so far so the lazy solution of using newtypes is good enough
11:26:22 <grantwu> Eww, FilePaths are strings
11:27:17 <ongy> there's a proposal somewhere to fix that, but it would break a bunch of stuff, so...
11:27:42 <ertes> it needs to be broken
11:36:45 <MitchellSalad> Eww, strings*
11:40:55 <grantwu> Has anyone used Shelly before?
11:41:15 <grantwu> Having trouble figuring out how we're supposed to actually do something with a value of type Sh a...
11:41:31 <grantwu> is there a "perform Sh action" function somewhere I can call in IO?
11:42:22 <MitchellSalad> i haven't used it, but there's this: shelly :: MonadIO m => Sh a -> m a
11:43:10 <grantwu> Oh
11:43:16 <grantwu> Hrm.... I think that does what I want
11:48:02 <mutantmell> ertes: ezyang was talking about using backpack to modularize against String representations, in a way that wouldn't break back-compat
11:49:29 <ertes> mutantmell: i forgot what that was…  a module system extension or something?
11:51:04 <grantwu> Hrm... why is "run" take a filepath as the first argument?  Is that supposed to be the FilePath for the command to run?  What if I want to have it be looked up in $PATH?
11:51:14 <mutantmell> yeah, it's a way to provide indefinite modules that are parameterized by types, and functions on those types
11:51:30 <mutantmell> https://github.com/ezyang/ghc-proposals/blob/backpack/proposals/0000-backpack.rst
11:52:54 <mutantmell> So indefinite modules can say "I need a type STRING with a couple methods", and you can slot in String/Text/hypothetical UTF-8 lib/ByteString (x {Strict,Lazy})
11:53:18 <mutantmell> I think the proposal was to have a definite base module, and various broken-out indefinite libs
11:53:45 <geekosaur> grantwu, it does PATH search per the source. I think the point is that a PATH search is conceptually a relative pathname
11:55:19 <grantwu> geekosaur: I suppose...
11:56:58 <ertes> mutantmell: from a first glance i'm not sure how this is different from type classes
11:57:08 <grantwu> Blegh, not a big fan of only being able to turn escaping on and off on a per command level
11:59:26 <ertes> grantwu: escaping b c >>= escaping b . f = escaping b (c >>= f)
12:00:02 <grantwu> ertes: Uh... what is that?
12:00:45 <ertes> grantwu: (do x <- escaping b c; escaping b (f x)) is the same thing as (escaping b (do x <- c; f x))
12:01:04 <grantwu> does this let me not escape a single argument to run?
12:01:14 <ertes> oh, that's what you mean
12:01:16 <ertes> nevermind
12:01:24 <geekosaur> ertes, typeclasses introduce runtime complexity when used to switch e.g. String to Text. backpack does it at compile/link time
12:02:30 <ertes> geekosaur: specialisation does that, too…  is there a difference?
12:02:43 <geekosaur> you could think of it as typeclasses at the module level instead of the type level
12:04:17 <geekosaur> specialisation can't always be resolved at compile time (leading to e.g. the cases when mono-traversable unexpectedly degrades to non-fused String operations)
12:04:51 <geekosaur> (or worse, to code that constantly packs and unpacks and repacks)
12:04:59 <M96528[m]> is this irc ? 
12:05:17 <grantwu> M96528[m]: yes
12:05:17 <ertes> i see…  but my intuition is correct?  it's *basically* a class approach?
12:05:27 <geekosaur> at a different level, yes
12:05:46 <geekosaur> it's doing it to the module system itself, instead of to the code
12:05:48 <M96528[m]> wow!
12:05:57 <ertes> ok…  also i see that orphans would be the norm rather than the exception
12:06:51 <hask> Hey! I have a problem where my prints get mixed up, as I try to print stuff in parallel. My code is " loop list m = forM_ list $ \x -> print (lookup x m) " where forM_ is imported from the Control.Monad.Parallel package. I want my prints to be abcabcabc etc (everything in the map returns abc), but I get aabcaabcaaaaaaabb for example. Any suggestions on how to fix this?
12:07:11 <glguy> hask: Yeah, do all the stuff that came up last time you asked
12:07:38 <ertes> =)
12:07:48 <hask> I've tried with chan but I didn't really get it to work
12:08:30 <glguy> Then focus your questions on the part you don't understand. There's not some other automatic solution that we're holding back until you ask again
12:09:52 <hask> Okay, one moment. Let me try to summarize what I've tried so far!
12:12:12 <grantwu> Blegh... Anyone have any idea how to deal with this?
12:12:22 <grantwu> er, sorry, meant to have an lpaste
12:13:39 <grantwu> http://lpaste.net/3799400083758252032 Anyone have any idea how to deal with this?  I'm not sure what a system-filepath-0.4.13.4:Filesystem.Path.Internal.FilePath is or why that's an expected argument
12:15:53 <glguy> grantwu: FilePath from System.FilePath isn't the same as Shelly's unfortuantely named FilePath
12:16:31 <MitchellSalad> use `Filesystem.Path.CurrentOS.decodeStringz
12:16:34 <glguy> so you can't use inputFile :: System.FilePath.FilePath with toTextIgnore directly
12:16:37 <MitchellSalad> that 'z' should be a `
12:17:06 <MitchellSalad> sorry, encodeString*
12:17:23 <grantwu> glguy: (╯°□°)╯︵ ┻━┻
12:18:11 <glguy> It looks like you just want: Data.Text.pack there
12:18:49 <grantwu> what confuses me is that "data FilePath" is listed under "re-exported for your convenience"
12:18:51 <hask> glguy: Alright. So something like this: http://lpaste.net/6440404933249335296 is what I've tried. I'm quite unsure on where to place my print method though. When I run this code I don't see any parallel behavior at all. The printing gets stuck when it reaches a key that doesn't exist/takes a long time to find. So I my out put gets "stuck" at something like ["abc","abc",".
12:19:04 <grantwu> And it's supposed to be using system-filepath
12:19:25 <grantwu> Or at least, that's what it claims
12:19:35 <glguy> grantwu: If it's supposed to use system-filepath's FilePath, then don't import System.FilePath
12:19:51 <grantwu> Wait... is System.FilePath no system-filepath?
12:19:53 <grantwu> *not
12:20:02 <MitchellSalad> correct, it's from `filepath`
12:20:44 <glguy> Yeah, system-filepath is an unfortunately named package that exports an unfortunately named datatype
12:21:32 <glguy> Also, system-filepath is deprecated in favor of filepath
12:21:49 <grantwu> argh.  but Shelly claims in its docs "is modern, using Text and system-filepath/system-fileio"
12:22:18 <grantwu> so, I guess system-filepath is no longer the "modern" option and it's now the "deprecated" thing?
12:22:19 <nshepperd1> hask: you need to evaluate the value inside that forked thread
12:22:27 <maerwald> filepath is unsafe though, because it uses String
12:22:39 <nshepperd1> Before writing it to the Chan
12:25:06 <M96528[m]> Shrike (Matrix Account):  Hi :)
12:27:54 <hask> nshepperd1: Thanks for the suggestion, but I don't think that changed anything. Should I perhaps try not to use forM_ from the Control.Monad.Parallel package, and instead use the normal one?
12:28:51 <glguy> hask: You should include what you tried that didn't work
12:30:55 <lpaste> glguy annotated “No title” with “closer to this” at http://lpaste.net/6440404933249335296#a7458451373701464064
12:30:55 <hask> I moved the "forkIO $ do" to above the let solution = show (lookup x lu), and tried running it again. Had the same behavior in the output.
12:30:56 <MitchellSalad> grantwu: it won't solve your file path woes, but `turtle` is an alternate to `shelly`
12:31:07 <MitchellSalad> that I prefer
12:31:47 <glguy> Updated to evaluate the solution rather than the show of solution
12:32:21 <grantwu> MitchellSalad: Hrm, might check it out later, right now I just need to bash out something to run llvm CLI commands
12:39:25 <kadoban> If I'm doing some mutable array imperative nonsense, is doing it in IO going to be substantially faster, or will ST be about the same speed?
12:40:01 <MitchellSalad> same exact speed
12:40:26 <MitchellSalad> IO = ST RealWorld, in fact
12:41:18 <kadoban> Cool
12:43:08 <barrucadu> An IORef is a newtype wrapper around an STRef
12:47:55 <hackrilege> I have data FreeTree a = Stick a | Branches [FreeTree a] [FreeTree a], does that look right? Is it the same as data Tree a = Leaf a | Branches [Tree a]?
12:48:01 <hask> Thanks glguy! That seems to be a step in the correct direction. I now get my prints on one line each! It however seems as if nothing gets printed until everything has been evaluated. I can however see that it has been processed in parallel, as the hardest key to find gets printed at last. Do you know if there is a way to print the results as soon as they are evaluated, and not at first when all elements in the list have been processed?
12:49:39 <MitchellSalad> hackrilege: no, FreeTree has an additional list in the branches =P
12:51:27 <glguy> hask: then the forM_ you're using probably doesn't do concurrent execution
12:52:32 <hackrilege> Could you put them into a list in order of which evaluates first?
12:54:49 <hackrilege> MitchellSalad, I was trying to oneline Free and data Tree a = Tree [a] [Tree a] so replacing a with Tree a and making a basecase
12:55:14 <hask> If I let the first element in my list be a key that doesn't exist in the map, it get's printed as Nothing at last, with all other values as Just x. So I guess that's a sign that it does process it in parallel, right?
12:55:57 <hask> Otherwise I would believe that Nothing would have been printed at first, if it was sequential?
12:56:49 <hackrilege> Sounds ok
12:58:14 <hask> I'm not sure if it matters, but I'm just running my code through WinGHCi without any flags or such. The forM_ seems to execute in parallel after some experimenting, so I haven't thought more about how I execute my program. Could this be a problem, that I'm running my program in the wrong way?
12:58:48 <hackrilege> :t forM_
12:58:50 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
12:59:09 <hask> It's the forM_ from the Control.Monad.Parallel package
12:59:18 <hask> forM_ :: MonadParallel m => [a] -> (a -> m b) -> m ()
13:01:27 <hask> If I run the normal forM_, I get the printouts in the same order as in the list I'm providing to the function. So it seems that the parallel forM_ indeed is parallel
13:03:20 <hackrilege> Seems to rely on par and pseq in bindM2
13:05:22 <hackrilege> https://hackage.haskell.org/package/parallel-3.2.1.0/docs/Control-Parallel.html
13:07:30 <hask> I get this exception after the printing is done by the way: *** Exception: thread blocked indefinitely in an MVar operation
13:08:12 <glguy> hask: getChanContents is for when the chan isn't going to stop producing results
13:08:17 <Tuplanolla> What's the Haskell way to enable trapping nans?
13:08:32 <hask> Is there a way to close a chan?
13:08:54 <glguy> I think what's happening is that your computation doesn't have any allocation in it, and the run time system isn't switching threads until it finishes the expensive lookup operations
13:09:17 <hackrilege> Wow iv never seen the function lazy before... https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Conc.Sync.html#pseq
13:09:25 <t0by> So. Lately I've started using Haskell for "real" things and I'm enjoying it. However, I would now try to add a simple GUI to a program. How can I/what's the best way? Googling yields a lot of obscure and/or unmantained packages, with no obvious choice.
13:10:26 <pumita> Hi, I want to write a parser that reads a line till a newline character
13:10:30 <Cale> t0by: What kind of GUI do you need? If it were me, in many cases now I'd probably use reflex to do it (and just compile with GHC for a desktop application rather than a web app.
13:10:33 <pumita> I'm not able to do that
13:10:41 <Clint> pumita: why not
13:10:49 <Cale> )
13:10:56 <pumita> Clint I want to read an store all sentences
13:10:58 <t0by> Cale, what do you mean by "kind"?
13:11:04 <t0by> Cale, I did not know about reflex
13:11:19 <t0by> is there a decent tutorial somewhere?
13:11:22 <pumita> this way: "hello world \n" -> should return `Right ["hello", "world"]
13:11:58 <hackrilege> http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Exts.html#v:lazy
13:12:06 <glguy> hask: OK, here's the problem, I think
13:12:08 <pumita> I've written this: do {many1 (letter <|> space); newline}
13:12:15 <pumita> but it doesn't work
13:12:18 <pumita> any hint?
13:12:21 <glguy> your parallel forM_ doesn't return until all of the computations are done
13:12:36 <unskill> What is recursive scheme?
13:12:45 <glguy> hask: so you need to forkIO the parallel forM_ itself so that it doesn't block the loop that prints results as they arrive
13:13:58 <hask> Dude. That totally solved it!
13:14:28 <hask> *applause* :)
13:18:56 <hask> Thanks a bunch glguy and hackrilege!
13:19:06 <kadoban> Can anyone give me a hint of how the hell I give a correct type annotation to Data.Array.MArray.newArray such that it can figure out that I'm using a ... Data.Array.ST.STUArray ?
13:21:46 <Profpatsch> When I say
13:21:53 <Profpatsch> newtype Foo a = Foo a
13:22:48 <Profpatsch> Is it possible to derive all instances of a for Foo a?
13:23:13 <unknownln> Yes actually, I think there's an extension for that
13:23:31 <mutantmell> Profpatsch: As in, derivie instances for Foo that a has, or derive ALL instances
13:23:33 <mutantmell> ?
13:23:36 <glguy> No, you can't derive all. You can using GeneralizedNewtypeDeriving to derive some, though
13:23:41 <Profpatsch> Okay
13:23:51 <unknownln> That's what I was thinking of, thanks glguy
13:24:29 <augur> anyone know if its possible to get copy, in some form, of hoogle's type signature index?
13:24:29 <Profpatsch> And that will probably throw an error for e.g. deriving (Show) for Foo Bar when Bar doesn’t instantiate Show?
13:24:49 <tdammers> augur: you can install hoogle locally
13:25:07 <augur> tdammers: would that let me extract the index?
13:25:14 <Profpatsch> augur: Hoogle just parses Haddock definitions, these should be generated by cabal on build.
13:25:25 <augur> i really just want a bunch of type signatures, really
13:25:26 <Profpatsch> And then you can build a database from them with the hoogle command.
13:25:37 <augur> tho probably a local hoogle install would probably be useful
13:25:49 <Profpatsch> augur: If you use nix it’s trivial.
13:25:50 <augur> i want to try a new search technique on it :)
13:26:04 <augur> i dont really know what nix is
13:26:09 <Profpatsch> then nvm
13:27:10 <ukldash> So if I install hoogle locally, I can use it to search packages that aren't normally indexed by hoogle?
13:27:18 <Profpatsch> Yes.
13:27:54 <ukldash> How does that interact with using stack for projects? Do I have to install packages I want to search using cabal as well?
13:27:55 <Profpatsch> ukldash: You might be lucky with using    +package function   though.
13:28:13 <Profpatsch> e.g. +lens (^.) in the official hoogle.
13:28:21 <ukldash> Did not know that was a thing!
13:28:45 <Profpatsch> I don’t know if stack is configured to compile haddock databases by default.
13:28:45 <Koterpillar> it's in the sidebar...
13:28:57 <Profpatsch> I’m pretty sure it can be made to, thogh.
13:28:59 <Profpatsch> *though
13:30:25 <ukldash> Koterpillar: sidebar?
13:31:09 <Koterpillar> once you search on Hoogle, you see a list on the left suggesting you to add packages
13:32:44 <ukldash> Oh that's what that's for. I must have thought that was a list of things it was already searching or something when I first used hoogle, because I don't remember looking at it in forever
13:33:05 <Koterpillar> it's not that intuitive, to be honest
13:33:20 <sm> true
13:33:37 <hask> glguy: One last thing if you have time! About the "*** Exception: thread blocked indefinitely in an MVar operation". You said it had something to do with getChanContents never closing, right? Do you have any ideas on how to avoid this exception? Maybe by closing the chan, or something like that? By the way, thanks once again for the support!
13:34:13 <sm> http://hoogle.haskell.org searches more packages by default
13:34:28 <glguy> hask: You can do what I did in my example
13:34:42 <glguy> Only take as many elements from the channel as you expected there to be
13:37:14 <hask> hask: You mean something like "msg <- getChanContents chan; mapM_ print (take n msg)"?
13:37:23 <hask> glguy* lol
13:37:43 <glguy> hask: That or only readChan n times like I had
13:38:28 <hask> glguy: When you said "I had", do you refer to this: http://lpaste.net/6440404933249335296#a7458451373701464064 ?
13:39:38 <hask> glguy: Yeah it worked with take n msg! Thanks!
13:39:46 <glguy> hask: no
13:41:06 <glguy> Maybe I never posted the other version?
13:41:29 <hask> glguy: No, I think not! However I got disconnected for some minutes. Maybe I missed it? Care to post again?
13:41:44 <kadoban> Any hints here? Do I just need type annotations? Can't figure it out. http://lpaste.net/3460709038788968448
13:42:11 <kadoban> Oh, line numbers are off by 73, sorry.
13:42:28 <lpaste> glguy annotated “No title” with “other version” at http://lpaste.net/6440404933249335296#a349686
13:42:37 <glguy> hask: That's what I was using to test
13:43:27 <t0by> So, besides reflex, is there anything else worth considering for GUIs?
13:43:44 <t0by> That includes web stuff.
13:45:13 <kadoban> I swear, every time I try to mess with ST arrays ...
13:47:10 <hask> glguy: Okay, thank you! Would you say there are any advantages of using that version instead? It's nice that you no longer need the parallel forM_ 
13:49:28 <glguy> this version doesn't do the bookkeeping you sidestepped and relies on no external dependencies
13:49:53 <t0by> Cale, when I try to install reflex I get:  base: needed (>=4.7 && <4.9), 4.9.0.0 found (latest applicable is 4.8.2.0)
13:50:11 <t0by> is it actually incompatible with the latest haskell-platform or is there a workaround?
13:51:43 <byorgey> t0by: try --allow-newer ?
13:51:48 <grantwu> hindent is erroring for me on line 59 of Main.hs no matter what I do, it seems
13:52:24 <t0by> byorgey, oh, thanks, let me try that. I'm sorry, but while I'm getting semi-proficient at haskell itself, the stack is still pretty obscure to me
13:52:24 <grantwu> Does anyone know how I can fix this
13:52:29 <hask> glguy: I'll try to experiment with that version, looks good. What do you mean by bookkeeping in this context by the way?
13:52:33 <t0by> grantwu, let's see the code?
13:52:42 <grantwu> t0by: https://github.com/chrisdone/hindent/blob/master/src/main/Main.hs ?
13:52:45 <byorgey> t0by: sure, fair enough
13:53:06 <grantwu> t0by: line 59 of the hindent source, not my code
13:53:38 <byorgey> t0by: the ? was just meant to convey "perhaps this will work", it was not meant to convey any sort of condescension
13:54:28 <t0by> byorgey, I know. Still, I thought I'd ask forgiveness for not RTFM - or rather, not noticing the --allow-newer option :)
13:55:26 <monochrom> I don't usually play the RTFM card when it comes to cabal because its user manual is lagging behind a bit and its --help can be overwhelming.
13:55:47 <hexagoxel> kadoban: are you asking if you need type sigs, about type annotations or what sigs make this work?
13:56:01 <monochrom> However, I do play this card when it comes to a well-documented and not-too-big library.
13:56:33 <kadoban> hexagoxel: I'm asking how to make it work, and if a type signature somewhere is all I need. And if so, where and what.
13:57:46 <hexagoxel> kadoban: go :: forall s . ST s Int and tally <- MA.newArray @(AST.STUArray s) @_ @(ST s) (lo, hi) 0
13:58:40 <MarcelineVQ> ​@_ @
13:58:41 <hexagoxel> kadoban: ah, the last two type applications are not necessary
13:58:46 <kadoban> hexagoxel: What's that syntax on the last bit? Is that GHC 8?
13:58:53 <hexagoxel> type applications, yes
14:00:26 <kadoban> Hmm, thanks ... *tries to figure out if I can do that in 7.10*
14:00:36 <byorgey> t0by: 'cabal install --help' is 254 lines long.  Even I don't know all the options =)
14:01:17 <glguy> kadoban: This was enough:           tally <- MA.newArray (lo, hi) 0 :: ST s (MA.STArray s Int Int)
14:01:42 <hexagoxel> yes, or           tally :: AST.STUArray s Int Int <- MA.newArray (lo, hi) 0
14:02:18 <hexagoxel> with ScopedTypeVariables
14:02:29 <kadoban> Hah, thanks much both. That seems to have worked, or at least it compiles.
14:02:30 <hexagoxel> but foralls were used already
14:07:50 <t0by> > reflex-0.4.0 failed during the building phase.
14:07:51 <t0by> :(
14:07:52 <lambdabot>  <hint>:1:47: error:
14:07:52 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:08:56 <ab9rf> i actually managed to get an environment with reflex, reflex-sdl, and sdl2 to actually compile something the other day
14:08:57 <ij> Isn't there some typeclass that converts to string? I am, of course, able to do TL.unpack . decodeUtf8, but trying to find the right functions is a little tiring sometimes.
14:09:07 <t0by> ab9rf, which ghc?
14:09:16 <ab9rf> t0by: 8.01 i'm fairly certain
14:09:27 <monochrom> Show is the typeclass that converts to string.
14:09:29 <ab9rf> but honestly i didn't notice which version stack installed
14:09:52 <chinaman> do people actually think haskell is an intuitive language?
14:10:01 <monochrom> Yes, I think so.
14:10:02 <Tuplanolla> Yes.
14:10:08 <ab9rf> chinaman: i think it is 
14:10:13 <Koterpillar> +1
14:10:21 <Koterpillar> (but you are asking on #haskell...)
14:10:28 <ab9rf> chinaman: although the more exposure to "traditional" progarmming languages you have, the less intuitive it likely seems
14:10:49 <Koterpillar> ^ mildly disagree
14:11:01 <chinaman> you wouldn't get people on a c++ chatroom going "yayyy i got something to compile, what a miracle"
14:11:04 <pikajude> Is it possible to convert a Digest from cryptonite into something useful?
14:11:05 <monochrom> I actually know a friend who saw BASIC when as a kid and considered "X = X+1" counterintuitive.
14:11:13 <t0by> chinaman, I don't. I'm fairly sure my 70 year old mother wouldn't be able to do anything with it by sheer intuition. On the other hand, she makes some really delicious gnocchi.
14:11:16 <pikajude> cryptonite's rewrite of the Crypto.Hash module took out both digestToByteString and digestToHexByteString.
14:11:29 <jle`> chinaman: to make a fair comparison, the similar thing in a C++ chatroom would be "yay i fixed a logic error"
14:11:31 <ab9rf> chinaman: it's not haskell that's the problem, it's reflex and even more so sdl :)
14:11:32 <pikajude> The recommendation given in the cryptohash docs doesn't typecheck.
14:11:33 <Koterpillar> monochrom: when I saw that, I entered "X + 2 = 5" and was confused when it didn't work.
14:11:35 <t0by> monochrom, was your friend one Charles Hewitt? :P
14:11:42 <monochrom> no
14:11:43 <jle`> chinaman: because compile-time errors in haskell roughyl correspond to run-time and logic errors in other languages
14:11:55 <ab9rf> it was moer a packaging issue, not a language issue
14:11:59 <jle`> so fixing a compile-time error in haskell is like fixing a run-time/logic bug in other languages
14:12:10 <osfameron> I suspect people do sometimes have issues compiling C++ too ;-)
14:12:16 <ab9rf> and i've never encountered a language/devenv that didn't have packaging issues.
14:12:26 <Tuplanolla> You'd enjoy Coq, where every error is a compilation error, chinaman.
14:12:29 <monochrom> chinaman, when are we going with your line of dialogue?
14:12:33 <monochrom> s/when/where/
14:12:43 <glguy> I liked the when question  better
14:12:46 <ab9rf> the difference is that C++ will blithely link against the wrong librariss and your program ends up turning the cat into toast
14:12:48 <monochrom> heh
14:13:16 <monochrom> For example why does anyone here care how C++ programmers work?
14:13:33 <chinaman> venting frustration at the fact i've been trying to get unix time as an int for about an hour...
14:14:01 <monochrom> OK, you're rightfully frustrated, because int is wrong for this.
14:14:28 <monochrom> IMO the Haskell "time" library does it right. It is not a simple number.
14:14:40 <Koterpillar> it has diffTimeToPicoseconds though
14:14:41 <glguy> fmap truncate Data.Time.Clock.POSIX.getPOSIXTime :: IO Int
14:14:42 <glguy> however
14:14:43 <kadoban> chinaman: Actually, you do get people in ##C++ saying "Yay, it compiles!"
14:14:52 <ab9rf> chinaman: that's because time is a complex idea that cannot readily be reduced to an integer
14:14:56 <Tuplanolla> Don't we still have the leap second problem, monochrom?
14:15:06 <ab9rf> it can bem but there's no obviously "right" means to do so
14:15:09 <monochrom> Yes.
14:15:27 <Tuplanolla> (Collective "we computer users".)
14:15:48 <ab9rf> Tuplanolla: only sorta. they've decided that there will be no further leap seconds
14:16:19 <ab9rf> hm, no, apparently they've only decided to discuss having no further leap seconds
14:16:28 <Koterpillar> Google decided to.
14:16:30 <ab9rf> the decision to do away with them has not yet been made
14:16:45 <Tuplanolla> I don't see how that would be possible.
14:16:47 <Koterpillar> ab9rf: so is the proposal to adopt smeared time?
14:17:03 <Tuplanolla> Smeared time is a horrible compromise.
14:17:12 <ab9rf> the ITU-R hopes to have a comprehensive proposal ready by 2023
14:17:30 <ab9rf> "In 2015 the ITU-R decided not to decide whether the calendar will also become disconnected from the rotation of the earth. There is currently no open question about leap seconds at the ITU-R, so they will take no further action until 2023. The request from the ITU-R at WRC-15 was for a bunch of external international agencies (none of which is involved in setting standards for computing systems) to try to forge some agreement which the 
14:17:48 <monochrom> Heh, decide to undecide.
14:18:14 <ab9rf> https://www.ucolick.org/~sla/leapsecs/ if you want to unlearn more
14:18:28 <ab9rf> they've been arguing over this issue since 1972
14:18:34 <monochrom> People can't even agree on time schemes. So nevermind programming languages.
14:18:59 <Tuplanolla> I've read all that and still fail to see what there is to argue.
14:19:27 <glguy> Tuplanolla: Would you like to argue about arguing?
14:19:28 <Cale> I actually don't think it's that horrible a compromise. Maintaining continuity is nice.
14:19:37 <Tuplanolla> It can all be solved with two different seconds: one atomic and one astronomical.
14:19:42 <ab9rf> Tuplanolla: most of the obstructionism is from civil authorities, not from scientific or technical authorities
14:20:20 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #1 :)
14:23:40 <Tuplanolla> We might have to add one more second to the mix if we ever begin large-scale space travel.
14:27:06 <jle`> i'm not even sure how that would work
14:27:36 <Tuplanolla> It wouldn't, really. Every accelerated observer would disagree.
14:27:43 <jle`> :|
14:27:44 <ab9rf> the problem is that civil authorities want "day" to be defined as "one rotation of the earth" while most everyone eles wants day to be defined as "86400 seconds"
14:28:07 <jle`> Tuplanolla: even just being on a planet rotating around a sun would cause your time to be off from earth time
14:28:18 <drdo> ab9rf: Why would you not want day to be defined as a rotation of the Earth?
14:28:21 <Tuplanolla> Indeed.
14:28:34 <ab9rf> astronomers, and most other physical scientists, realize that "one rotation of the earth" is not a constant, and thus a crappy way to define something
14:28:41 <hvr> drdo: becasue the earth rotation is not exact
14:28:42 <Koterpillar> let's submit a proposal involving large-scale thrusters to fix the earth rotation instead
14:28:45 <monochrom> Consider the fact that many governments still want to keep "daylight saving time". So good luck convincing them to give up leap seconds.
14:28:47 <drdo> hvr: So?
14:28:54 <drdo> We still have to deal with that fact
14:29:03 <drdo> You can't just define reality away
14:29:16 <ab9rf> it means your computer has to be able to know how fast the earth has been rotating lately in order to properly keep time
14:29:16 <hvr> drdo: we do that all the time ;-)
14:29:19 <Clint> #define PI 5
14:29:40 <hvr> drdo: whenever we model something in a computer, we're using a simpler model
14:29:47 <hvr> drdo: that what reality would require
14:29:58 <Koterpillar> days defined as 86400, 100000 or 65536 seconds would be easy but not *useful*
14:30:04 <drdo> hvr: We care very much that the day represents an actual day
14:30:09 <drdo> It has a meaning
14:30:14 <drdo> It's not just some arbitrary amount of time
14:30:19 <jle`> humans do, but do astronmers?
14:30:25 <hvr> drdo: yes, and we're using a very good approximation 
14:30:34 <drdo> hvr: Yes, and that's fine
14:30:40 <ab9rf> astronomers who ahve to use the *actual* rotation will *measure* it
14:30:54 <Tuplanolla> All scientific measurements would slowly become wrong or the units themselves would become time-varying, drdo.
14:31:05 <ab9rf> rather than making assumptions about future expectations based on past performance
14:31:21 <drdo> Tuplanolla: The unit is time-varying
14:31:28 <drdo> It's not actually a unit even
14:31:32 <ab9rf> the problem is that "day" is not a consistent length of time
14:31:32 <Tuplanolla> High-energy physicists would still get cranky about their statistical significance.
14:31:49 <glguy> The conversation seems to have drifted off the topic of Haskell
14:32:00 <hvr> glguy: don't be a buzzkill :-)
14:32:08 <drdo> The off-topic police has arrived
14:32:08 <ab9rf> it's 86400 seconds, plus or minus some random slop based on the earth's recent geoplanetary behavior
14:32:42 <drdo> Stop using day as a unit of time and you'll have no problems
14:32:48 <kadoban> Anyone see a logic difference between http://ideone.com/B9pAV2 and https://gist.github.com/kadoban/946dd38361cd94e417c56ed9283cf98c ? I'm trying to replicate some C++ code for comparison and I seem to have screwed up some logic somewhere, getting different answers :-/
14:32:59 <ab9rf> anyhow, the reason why haskell doesn't offer a trivially easy way to get "time" as an integer is because (a) time is complicated and (b) haskell programmers tend to be the sort who don't just sweep complexity under the rug
14:33:00 <drdo> A day has a real meaning, it's one rotation of the earth
14:33:32 <monochrom> Let's just call it a day.
14:33:42 <ab9rf> ba dum tish
14:33:43 <hvr> or a night...
14:33:48 <drdo> :D
14:33:56 <glguy> monochrom: Give me a second to think about that
14:34:07 <monochrom> \∩/
14:34:51 <kadoban> drdo: sidereal or stellar?
14:36:25 <qmm> is ghci considered a repl?
14:36:28 <ab9rf> yes
14:36:43 <ab9rf> at least by me
14:36:57 <monochrom> yes
14:37:00 <qmm> i've considered it a repl, but i've never seen the term "repl" mentioned on haskell.org
14:37:01 <Tuplanolla> It has all the four essential features.
14:37:14 <blackdog> can you define new datatypes at the repl yet?
14:37:22 <monochrom> yes
14:37:33 <ab9rf> yet? have you ever not been able to?
14:37:33 <monochrom> I would rather it not, but it's done.
14:37:36 <glguy> Maybe it's a REPT, read eval print tailcall
14:37:39 <monochrom> yes
14:37:39 <muyfine> I'm trying to comine maybe and io monad more elegantly instead of cracking open the maybe value
14:37:46 <muyfine> I have this http://lpaste.net/349687
14:37:57 <ab9rf> i admit that i don't use ghci much
14:38:21 <muyfine> but I would like to be able to combine the two better
14:38:30 <muyfine> as it is harder to follow
14:38:33 <jle`> i use ghci pretty often
14:38:49 <jle`> muyfine: there's a function in Prelude that does that
14:38:51 <jle`> 'traverse'
14:38:55 <ab9rf> muyfine: isn't that just a traverse?
14:38:56 <jle`> or mapM
14:39:08 <muyfine> oh?
14:39:16 <monochrom> @type traverse
14:39:17 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:39:39 <monochrom> @type traverse return
14:39:41 <lambdabot> (Traversable t, Monad f) => t b -> f (t b)
14:39:49 <jle`> traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
14:39:54 <monochrom> Now let t=Maybe, f=IO
14:40:13 <jle`> traverse f Nothing = pure Nothing; traverse f (Just x) = Just <$> f x
14:40:29 <jle`> which is pretty much exactly what you wrote :)
14:40:32 <monochrom> although, all traverse does is to unpack the Maybe for you again, so you are merely shoving code under a rug.
14:40:43 <ab9rf> but it's a pretty rug
14:40:49 <jle`> it looks like shoving-under-the-rug is the entire purpose of this exercise, though
14:40:58 <c_wraith> also, it's someone else's rug. 
14:41:00 <jle`> so i think it'l work :)
14:41:02 <muyfine> ahh
14:41:05 <muyfine> yeah, that's what I want
14:41:08 <c_wraith> (part of the standard library) 
14:41:10 <muyfine> under someone else's rug!
14:41:22 <jle`> isn't shoving-under-a-rug the entire purpose of higher order functions? ;)
14:41:39 <ab9rf> muyfine: all this shows is that someone else already had this idea, generalized it, and gave it a name you didn't expect :)
14:41:41 <muyfine> sweet, thanks!
14:41:54 <jle`> muyfine: but yeah, it's neat that you basically implemented traverse/mapM from scratch
14:42:02 <jle`> great minds think alike
14:42:31 <jle`> traverse f = maybe (pure Nothing) (\x -> Just <$> f x)    -- following the pattern that you wrote in your lpaste
14:44:15 <muyfine> yeah, I've run into traverse a couple of times, but never though to use it combining maybe monad with io monad
14:44:30 <muyfine> and I've got so many places where I want exactly that
14:45:11 <jle`> technically here it's using Maybe as a Traversable
14:45:15 <jle`> not as a mond :)
14:45:18 <jle`> *monad
14:45:43 <muyfine> right
14:45:56 <muyfine> think that's what I'm missing thinking about the problem
14:45:58 <ab9rf> it's also using IO as an Applicative
14:46:16 <ab9rf> you could use mapM, which uses IO as a Monad (but Maybe is sitll a Traversable)
14:46:45 <jle`> yeah, thinking of Maybe as "only" a Monad might restrict the ways you use it
14:46:48 <ab9rf> same guy different shirt
14:47:05 <muyfine> yeah for sure
14:47:19 <ab9rf> i have honestly lost track of how many different classes Maybe is an instance of
14:47:33 <kadoban> All of them
14:48:02 <ab9rf> every few weeks it seems like there's a new one
14:51:20 <codedmart> I have never dealt with NonEmpty before. Anyone that could give me a quick direction to look based on this comment? https://github.com/ocharles/logging-effect/pull/13#discussion_r91301695
14:52:21 <codedmart> Does that mean he wants this https://github.com/codedmart/logging-effect/blob/7806af382af7b21a200043dbbc675b8ac5fbcca4/src/Control/Monad/Log.hs#L466 to be `(NonEmpty message -> IO ())`
14:52:28 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List-NonEmpty.html
14:53:18 <codedmart> glguy: Yeah I was looking in there. I'm just trying to understand.
14:53:33 <jle`> codedmart: yes that is probably what he wants
14:54:27 <jle`> codedmart: use nonEmpty :: [a] -> Maybe (NonEmpty a) on 'messages'
14:54:35 <jle`> and then pass the result to 'flush'
14:54:47 <jle`> nonEmpty returns Nothing if the list is empty
14:54:51 <jle`> and returns Just xs if the list ain't
14:55:01 <jle`> (where xs :: NonEmpty a)
14:55:40 <jle`> (where 'NonEmpty a' is the type of a non-empty list)
14:56:26 <uiop> lambdabot: > id 9
14:56:30 <uiop> oops
14:56:33 <uiop> > 9
14:56:35 <lambdabot>  9
14:56:48 <codedmart> jle`: So the type would actually be `(Maybe (NonEmpty message) -> IO ())`
14:57:04 <jle`> codedmart: it'd be NonEmpty messages -> IO ()
14:57:09 <uiop> i forgot how to /msg for a second there
14:57:17 <jle`> but if it's NOthing, you'd rturn pure stillOpen
14:57:25 <uiop> :t id
14:57:27 <lambdabot> a -> a
14:59:15 <jle`> codedmart: i'm looking at https://github.com/codedmart/logging-effect/blob/7806af382af7b21a200043dbbc675b8ac5fbcca4/src/Control/Monad/Log.hs#L494
14:59:20 <jle`> case nonEmpty messages of
14:59:25 <jle`>   Nothing -> pure stillOpen
14:59:36 <jle`>   Just msgs -> do flush msgs; pure stillOpen
14:59:43 <jle`> um
15:00:00 <codedmart> jle`: That is what I was trying as well, but that doesn't feel any cleaner to me.
15:00:09 <jle`> which could probably just be mapM_ flush (nonEmpty messages)
15:00:24 <jle`> codedmart: the difference is that your types convey more of what the function expects
15:00:30 <jle`> codedmart: it's like using Int instead of Double
15:00:33 <jle`> if you only want Int's
15:00:35 <ezyang> nitrix: It's common sub-expression elimination 
15:00:54 <jle`> codedmart: or, like, using replicate :: String -> a -> [a]
15:01:03 <jle`> where the string input is the length of the list you want, as a string
15:01:12 <jle`> but like, if you want a length, why not just ask for an Int?
15:01:41 <ezyang> ertes: Well, I'm happy to answer questions about it. It's not type classes because it's not type directed, and compiled all away (you never have dictionaries) 
15:02:21 <jle`> codedmart: it's about using a type that describes what you actually are giving it :)
15:02:50 <jle`> which is kind of like The Point(tm) of Haskell
15:05:31 <codedmart> jle`: OK thanks trying to see if I can fix the next error thanks!
15:05:41 <uiop> jle`: technically if you want a length a Word would best though ;)
15:05:52 <jle`> ;)
15:06:09 <jle`> or a Natural
15:06:24 <uiop> size_t
15:06:55 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Numeric-Natural.html#t:Natural
15:07:16 <uiop> yes or Natural to handle infinite ram
15:08:29 <ab9rf> i need to get me some infinite ram
15:08:30 <uiop> or when length() isnt constrained by physics
15:09:15 <uiop> ab9rf: amazon.com will happily sell it to you
15:09:28 <codedmart> jle`: OK now I think I am just complicating myself. This is the error that comes from the other changes https://gist.github.com/codedmart/822703a4e50f4d2cd7c30e656b139c23
15:09:32 <jle`> i was thinking from more of a denotative standpoint than an operational/physical one :)
15:09:40 <ab9rf> uiop: actually i'd be more likely to see it for sale on alibaba :)
15:09:53 <ab9rf> alibaba will sell anything, even things that can't possibly exist
15:10:03 <ab9rf> amazon still has to deal with the FRC
15:10:04 <ab9rf> er FTC
15:10:13 <ab9rf> but i digress
15:10:21 <jle`> codedmart: you can probably just add (.... . toList) to the end of your chain of functions
15:10:36 <jle`> :t \f -> (f . toList)
15:10:37 <lambdabot> error:
15:10:37 <lambdabot>     Ambiguous occurrence ‘toList’
15:10:37 <lambdabot>     It could refer to either ‘F.toList’,
15:10:41 <jle`> ok lambdabot
15:10:42 <codedmart> Yup over complicated it.
15:10:44 <ab9rf> yeah, most likely that's enough
15:10:45 <jle`> :t \f -> (f . F.toList)
15:10:47 <codedmart> Damn it
15:10:47 <lambdabot> Foldable t => ([a] -> c) -> t a -> c
15:11:10 <jle`> (\f -> f . toList) :: ([a] -> b) -> (NonEmpty a -> b)
15:11:15 <ab9rf> NonEmpty is just a list that's guaranteed not to be empty?
15:11:18 <codedmart> jle`: Thanks!
15:11:22 <jle`> ab9rf: yup
15:11:25 <jle`> codedmart: no problem!
15:11:43 <codedmart> Yeah I was letting the type signature scare me and throw me off.
15:11:49 <codedmart> I get it now. I appreciate it.
15:12:18 <jle`> no problem :)  yeah, in general, if you want a (b -> c) but want an (a -> b), you can pre-compose it with an (a -> b) if you have one
15:12:26 <ab9rf> which means that head and tail are total
15:12:33 <jle`> ab9rf: yup
15:12:37 <jle`> neat right
15:12:46 <jle`> also foldl1, foldr1
15:12:49 <ab9rf> but tail.tail isn't :)
15:12:49 <nineonine> hello there
15:12:50 <Fare> What's the easiest way to use row polymorphism in Haskell?
15:12:50 <jle`> maximum, minimum
15:13:00 <Fare> Is there already a simple OO library using Row Polymorphism?
15:13:01 <ab9rf> jle`: yeah, i see the value
15:13:02 <codedmart> So just to be sure. NonEmpty was part of semigroups before base 4.9 right? So ghc 7 would need semigroups right?
15:13:20 <nineonine> could someone shed some light on how to use EitherT properly ?
15:13:25 <edwardk> fare: at this point my usual approach is to build a language for it ;)
15:13:25 <jle`> yeah, NonEmpty wasn't in base before 4.9
15:13:31 <nineonine> im using 'either' package
15:13:42 <jle`> nineonine: why not just use the one included in 'transformers'? :)
15:13:52 <uiop> jle`: yeah, but there's something to be said for defaulting to the bounded-size type if you've gotta choose one
15:13:58 <nineonine> you mean ErrorT ?
15:14:01 <jle`> ExceptT
15:14:14 <jle`> but yeah, did you have a specific question?
15:14:15 <edwardk> fare: you can of course build something with a data types a la carte approach
15:14:23 <nineonine> hmm
15:14:28 <lyxia> ErrorT is deprecated. EitherT is going to be deprecated. in favor of ExceptT.
15:14:29 <nineonine> :)
15:14:58 <jle`> edwardk: yea when are we going to deprecate EitherT :o
15:15:00 <codedmart> jle`: Thanks again!
15:15:00 <lyxia> but EitherT and ExceptT are mostly the same.
15:15:02 <jle`> or do you still think it has value?
15:15:52 <uiop> what's a nice demonstrative ExceptT oneliner?
15:15:55 <nineonine> wow I actually realized that using ExceptT is better
15:15:58 <uiop> does lambdabot have that in scope
15:15:59 <edwardk> jle`: i'm going to kill it pretty soon. transformers-compat really kills the major concerns that led to its retention by making ExceptT available even to consumers of old transformers packages
15:16:23 <nineonine> because I am trying to plug in my monad transformer into servant route handlers 
15:16:25 <jle`> oh, nice.
15:16:37 <erisco> is there a data structure for a -> b and b -> [a] ? there is Bimap which is a -> b and b -> a
15:16:39 <implementation_> what exactly is the difference between EitherT and ExceptT?
15:16:46 <jle`> there is no difference, except ExceptT comes with ghc
15:17:18 <glguy> alaf ExceptT traverse :: (Traversable t, Monad m) => (a -> m (Either e a)) -> t a -> m (Either e (t a))
15:17:22 <erisco> a -> [b] and b -> [a]  I mean, whoops
15:17:22 <glguy> exceptT one-liner
15:17:36 <pikajude> :t alaf
15:17:38 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
15:17:39 <edwardk> implementation_: EitherT came first, but was randomly bikeshedded when it was moved into transformers to become ExceptT. This means that user migration became complicated.
15:17:41 <glguy> types like this generally aren't particularly useful for one-liners
15:17:46 <jle`> uiop: the nice thing is that you can use the Monad-polymorphic fucntions from Control.Monad and give the Eithery behavior
15:18:04 <shirt> ab9rf: eh?
15:18:31 <implementation_> and ErrorT only had the difference that it has the constraint (Error e), right?
15:18:31 <codedmart> So what is the proper way to do that. Just include semigroups in the cabal file and it will work for ghc 7 and ghc 8?
15:18:33 <erisco> I can write this module just using Map under the hood as Bimap does...
15:18:39 <codedmart> Regarding NonEmpty.
15:18:53 <edwardk> implementation_: yes, but that constraint was enough to cause a bunch of problems
15:18:57 <glguy> ErrorT and ExceptT different in how they treat fail
15:19:10 <edwardk> ErrorT still has a place, (i kinda wish it wasn't deprecated, but meh)
15:19:35 <glguy> marking it deprecated just leads to annoying deprecation warnings
15:19:38 <jle`> i do see that ErrorT has a place.  the deprecated message is kind of scary
15:19:38 <uiop> > alaf ExceptT traverse (\a -> return (Right a :: Either () Int)) [0..9]
15:19:41 <lambdabot>  error:
15:19:42 <lambdabot>      • Couldn't match expected type ‘m0 (Either e0 [b0])’
15:19:42 <lambdabot>                    with actual type ‘Unwrapped (ExceptT e0 m0 [b0])’
15:19:54 <jle`> but *most* usages of it are probably improper, so it scares away those people
15:20:03 <uiop> :t alaf ExceptT traverse
15:20:05 <edwardk> When we really switch over to MonadFail would have been a good time to deprecate it
15:20:05 <lambdabot> (Unwrapped (ExceptT e m (t b)) ~ m (Either e (t b)), Rewrapped (ExceptT e m (t b)) (ExceptT e m b), Rewrapped (ExceptT e m b) (ExceptT e m (t b)), Traversable t, Monad m) => (a -> Unwrapped (ExceptT
15:20:05 <lambdabot> e m b)) -> t a -> Unwrapped (ExceptT e m (t b))
15:20:06 <jle`> the ones who know what they're doing would be ok
15:20:36 <glguy> uiop: lambdabot is probably outdated on its lens version
15:21:00 <implementation_> what's the advantage of ErrorT in those places?
15:21:01 <glguy> Prelude Control.Lens Control.Monad.Trans.Except> alaf ExceptT traverse (\a -> return (Right a :: Either () Int)) [0..9] 
15:21:01 <glguy> Right [0,1,2,3,4,5,6,7,8,9]
15:21:22 <edwardk> i have thousands of lines of deprecation warnings from intentional use of ErrorT that I've had to suppress increasing the risk of other things slipping through that really are errors and no improper usages yet stopped by the deprecation.
15:21:52 <uiop> glguy: ah thx
15:22:16 <jle`> uiop: basically you would use it to get things like mapM/traverse, replicateM, etc. work with eithery semantics
15:22:49 <uiop> ah cool
15:22:59 <jle`> for example, if you wanted to replicateM an (a -> m (Either e a))
15:23:04 <jle`> and wanted it to short-circult properly
15:23:11 <jle`> er, an `m (Either e a)`
15:23:19 <jle`> to get an `m (Either e [a])`
15:23:31 <jle`> replicateM :: Int -> m (Either e a) -> m (Either e [a])
15:23:36 <edwardk> implementation_: ErrorT gets you a monad with working fail. ExceptT gets you a monad that doesn't have a useless constraint when you don't magically add 'fail' to your consideration of what constitutes a monad.
15:23:38 <jle`> you'd wrao it in ExceptT, and it'll give you the proper behavior
15:23:49 <jle`> *wrap
15:24:29 <jle`> also traverse :: (a -> m (Either e b)) -> [a] -> m (Either e [b])
15:24:37 <jle`> that short-circuits like you'd expect
15:24:43 <edwardk> implementation_: there is a comonad for (,) e and a monad for Either e. these notions are dual in a very nice way. adding Error e => as an extra constraint on the latter isn't required by the underlying concept of a monad until it is adulterated with fail.
15:24:47 <Fare> edwardk, hi!
15:25:59 <ab9rf> in other words, fail is a fail
15:26:02 <Fare> edwardk, I built a library of functions in Jsonnet, a pure lazy FP with a very simple OO core. I'm considering porting it to Nix. But I'd like to demonstrate in Haskell or some other language how the basic mechanism works.
15:26:47 <edwardk> you want to have access to the raw versions of these things without Error for lots of reasons. recursion schemes give rise to interesting ways to use distributive laws for monads/comonads with anamorphisms, catamorphisms, etc. the monad you need for an apomorphism is really Either e, without a constraint on e. the generalization of that is to use EitherT e.
15:26:47 <edwardk> this was actually the original reason i wrote EitherT.
15:26:55 <implementation_> edwardk: is fail really something that is used? I mean, we're talking about exception-handling monads, where we have throw* functions for this, so what's fail still for?
15:27:12 <nineonine> is there a function like bimapEitherT but for ExceptT ?
15:27:22 <ab9rf> shirt: sorry, i was talking about the garment, not about you :)
15:27:32 <Fare> basically, a prototype is a \ self super -> record; and instantiate prototype = let self = prototype self bottomObject in self
15:27:45 <edwardk> implementation_: yes. fail is quite common. it gets used in the desugaring of do notation when you have a partial match.
15:27:56 <edwardk> it also gets used manually in lots of things like parsing combinators
15:28:14 <ab9rf> parsec uses fail extensively
15:29:08 <implementation_> okay, thanks.
15:31:15 <edwardk> nineonine: nope. sadly, when EitherT was stored in the transformers bikeshed, that was one part of the bike that was removed rather than repainted.
15:31:39 <nineonine> got it ! thanks
15:32:54 <jle`> fail is really great but it doesn't belong in Monad
15:33:10 <jle`> i...actually think it used to be not in Monad at one point
15:33:14 <jle`> but people were like "...naw, let's just throw it in"
15:33:31 <jle`> and we were like "ok i guess"
15:34:01 <kadoban> You monsters
15:34:40 <c_wraith> it will be not in monad again "soon" 
15:35:06 <jle`> it's kind of ironic that things used to be how we want them now but we decided to mess things up
15:35:07 <c_wraith> the MonadFail proposal is underway. it's just going to be slow. 
15:35:22 <ij> Can you instantiate an empty MVar without IO?
15:35:30 <jle`> well
15:35:35 <jle`> no
15:35:37 <jle`> but
15:35:44 <jle`> it depends on what you really want to do
15:36:28 <jle`> https://wiki.haskell.org/Top_level_mutable_state
15:40:09 <nineonine> the 'impossible' happened
15:40:09 <nineonine> what
15:40:11 <nineonine> :D
15:40:25 <nineonine> this happend when i run "stack build"
15:40:38 <nineonine> ghc says this is a bud and it should be reported
15:40:41 <nineonine> should i ?
15:41:21 <monochrom> If you have time to search GHC's bug tracker for something similar to yours, that will be great. But if not, file anyway.
15:41:24 <kadoban> nineonine: Possibly. Can you narrow it down, what's causing it?
15:41:25 <grantwu> Is there a function to concatenate two Texts?
15:41:32 <grantwu> Or should I just use concat [a, b]
15:41:40 <kadoban> grantwu: <>  ?
15:42:00 <monochrom> There is also the third option that you don't even have time to file a bug report. That's OK too.
15:42:12 <grantwu> oh, right
15:43:19 <nineonine> it happens after It tries to compile this module --> http://lpaste.net/349688
15:43:20 <hexagoxel> "ghc - makes the impossible happen (periodically)"
15:43:45 <grantwu> nineonine: Was this something about running out of simpl ticks?
15:43:51 <nineonine> yes !
15:44:02 <nineonine> Total ticks: 22209
15:44:08 <grantwu> I think this just happens when you have compile time constants that are expensive to compute
15:44:09 <kadoban> hexagoxel: Nice
15:44:13 <grantwu> nineonine: use uh
15:44:14 <nineonine> Simplifier ticks exhausted When trying UnfoldingDone $fNumInt_$c+
15:44:39 <nineonine> what is uh ?
15:44:40 <grantwu> {-# OPTIONS_GHC -fsimpl-tick-factor=250 #-}
15:44:46 <grantwu> Use that ^
15:44:57 <nineonine> thanks !
15:45:14 <nineonine> should I put it in a failing module ?
15:45:35 <grantwu> Put it at the top of the module that isn't compiling, yeah
15:45:52 <nineonine> it worked ! awesome !
15:45:54 <nineonine> thanks 
15:45:58 <monochrom> @quote autrijus impossible
15:45:58 <lambdabot> autrijus says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
15:46:03 <glguy> nineonine: Are you aware of multi-line string literals?
15:46:18 <grantwu> Essentially what I *believe* is happening is that ghc detects infinite loops in its simplifier by just bounding the amount of work it does
15:46:19 <nineonine> yes I am just prototyping atm
15:46:36 <nineonine> i guess this is so trivial that i should fix that right away
15:46:43 <grantwu> And, you took more work than its threshold, making it think it had run into an infinite loop
15:46:54 <erisco> why haven't they made [,] a function yet
15:47:05 <monochrom> what does [,] do?
15:47:06 <hexagoxel> kadoban: it nicely matches the double meaning in "avoid success at all cost" :)
15:47:08 <jle`> i'd like list sections
15:47:16 <nineonine> " multiline /
15:47:18 <erisco> like (,) does
15:47:20 <kadoban> Seems kind of surprising that *that* module is enough to make it crash ... is that really it?
15:47:26 <nineonine> right ?
15:47:33 <jle`> map [1,,3] [1,2,3] == [[1,1,3], [1,2,3], [1,3,3]]
15:47:38 <grantwu> Which ought to be impossible, presumably they have some sort of way of proving that something terminates
15:47:54 <monochrom> oh GOd
15:47:56 <grantwu> kadoban: Yeah, I had it happen with a big string in my file that was inline assembly
15:48:20 <grantwu> (it's a compiler - not inline asm for Haskell)
15:48:26 <jle`> i've wanted list sections for a while
15:48:40 <jle`> i think iceland_jack has written a patch for GHC
15:48:49 <jle`> where is iceland jack these days anyway
15:48:59 <grantwu> are they not in iceland?
15:49:14 <jle`> presumably :p
15:49:19 <monochrom> in a journey of hunting down GHC devs to convince them, face-to-face, to accept the patch
15:49:31 <kadoban> Haha
15:49:36 <monochrom> it does take a while to go around the world
15:49:41 <jle`> maybe whenever he moves he changes his irc nick
15:49:44 <monochrom> presumably 80 days
15:49:49 <jle`> so that's why tab completion doesn't work
15:50:06 * jle` cycles trhough every country
15:50:43 <grantwu> kadoban: So it doesn't seem like Text is an instance of Monoid...
15:50:56 <erisco> hm, it wasn't smart enough to see that  M.unionsWith f [x, y]  is just  M.unionWith f x y
15:51:00 <glguy> grantwu: That means you didn't import enough modules
15:51:00 <jle`> text should be an instance of monoid
15:51:22 <Clint> instance Monoid Text -- Defined in ‘Data.Text’
15:51:34 <grantwu> glguy: Hrm... what modules should I be importing?
15:51:44 <glguy> This probably brought to you by orphan instances
15:51:46 <glguy> problem*
15:51:53 <hexagoxel> -fsimpl-tick-factor only raises the limit but does not reduce number of ticks taken/necessary, right?
15:55:06 <hexagoxel> (i had a Text-concatenation-heavy module recently where i turned off optimizations because compiletime became unbearable; is why i ask. although i have not tested whether ticks caused this..)
15:55:28 <hexagoxel> s/Text/Text-literal/
15:55:40 <grantwu> hexagoxel: I do not think that flag makes computing them any faster
15:55:53 <erisco> oh I see, it is more complicated of a rewrite than I thought
15:56:49 <erisco> well, ish, it has to know that  fmap f [x, y]  is  [f x, f y]  and then it can fire
16:00:34 <hexagoxel> so the number of ticks that are executed is a given, without any optionality to it?
16:03:49 <uiop> hexagoxel: yeah i imagine it only raises the threshold before it gives up
16:04:31 <uiop> rather than is a factor the compiler somehow uses to scale how hard it tries
16:05:07 <erisco> well that's a problem
16:05:16 <hexagoxel> thanks, that matches my interpretation of the ghc docs.
16:05:26 <erisco> unionsWith is inlinable, so can't really write rules for it
16:06:03 <erisco> and it inlines to another inline function, which in turn is a local definition
16:08:03 <erisco> oh well
16:24:17 <orion> In c2hs, if the value of {#sizeof foo_t#} differs from the output of "printf("%lu\n", sizeof(foo_t));" does that indicate an issue with c2hs?
16:25:40 <geekosaur> could be c2hs, could conceivably be missing or incorrect #include-s due to missing -I options
16:26:27 <orion> geekosaur: Ok, I'll file a bug report.
16:32:50 <Axman6> @hoogle (a -> Bool) -> [a] -> ([a],[a])
16:32:53 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
16:32:53 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
16:32:53 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
16:33:15 <Axman6> > span (=='0') "00012300"
16:33:17 <lambdabot>  ("000","12300")
16:33:21 <Axman6> excellent
16:35:26 <erisco> ah ha, heh, Map a (Set b) * Map b (Set a) is just a relation, and there is Data.Relation !
16:35:49 <erisco> I only had to redefine a quarter of the module to realise this
16:36:14 <laudiacay> hey I'm looking at the implementation of bind for the list monad, and it's in terms of a list comprehension- but I thought list comprehensions were just syntactic sugar on do, and do was just syntactic sugar on bind?!?!?
16:36:17 <laudiacay> what's happening here?
16:37:12 <kadoban> laudiacay: I don't think they're actually implemented in terms of do/bind, list comprehensions that is.
16:37:35 <Koterpillar> laudiacay: there's MonadComprehensions extension IIRC, which makes them
16:37:53 <laudiacay> kadoban: are you sure? my instructor said they were
16:38:02 <c_wraith> :t flip concatMap -- laudiacay, for what it's worth...
16:38:04 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
16:38:19 <laudiacay> where is the source for them
16:38:22 <kadoban> lambdabot: Not really
16:38:31 <c_wraith> :t flip concatMap `asAppliedTo` -- laudiacay, more precisely
16:38:33 <lambdabot> error:
16:38:33 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:38:37 <laudiacay> c_wraith: what? why
16:38:39 <c_wraith> :t flip concatMap `asAppliedTo` []
16:38:41 <lambdabot> [a] -> (a -> [b]) -> [b]
16:39:06 <c_wraith> laudiacay: flip concatMap happens to be bind for []
16:39:52 <laudiacay> c_wraith: what??? https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-734
16:39:54 <laudiacay> you are wrong
16:40:13 <laudiacay> see the note on list comprehensions and inlining
16:40:56 <nshepperd1> laudiacay: list comprehensions are built into the compiler
16:41:06 <c_wraith> laudiacay: and yet, that's a correct implementation
16:41:08 <laudiacay> nshepperd1: where is the source for that? sorry super curious
16:41:23 <laudiacay> c_wraith: it's /correct/ but it's not how it works under the hood which is what i'm curious about :)
16:41:41 <c_wraith> laudiacay: if you want to know how it works under the hood, you're in for a *very* long day
16:41:43 <kadoban> laudiacay: I think it's one of those things where there's like a set of three things, each of which could be implemented in terms of the other. So as long as one of them is implemented, it's not really important which, you just implement the others in terms of it.
16:41:46 <nshepperd1> laudiacay: unless you rename MonadComprehensions, in which case they're desugared into monad operations i think
16:41:52 <c_wraith> laudiacay: because you will need to look up foldr/build fusion
16:42:07 <laudiacay> c_wraith: thanks dude :D
16:42:12 <nshepperd1> I don't know where you'd find this stuff in ghc
16:42:54 <laudiacay> thanks guys :D
16:43:42 <c_wraith> laudiacay: for what it's worth, using concatMap as a model will teach you everything worth knowing
16:43:52 <c_wraith> laudiacay: since concatMap is written in terms of foldr/build fusion already
16:44:07 <laudiacay> c_wraith: but concatMap makes sense to me and foldr/build fusion does not
16:44:59 <erisco> Data.Relation does not have a Strict variant though D:
16:45:31 <c_wraith> laudiacay: https://github.com/quchen/articles/blob/master/build.md is a good starting point
16:46:15 <erisco> seeing as I always end up touching every key and value it is a great advantage to have the Strict version
16:46:58 <erisco> well, keys are always evaluated regardless
16:47:42 <erisco> though, if you have a map in both directions, maybe it doesn't matter, I am not sure
16:47:59 <erisco> presumably, since they are boxed, they will point to the same thunk
16:48:17 <erisco> and so one map will evaluate the values of the other thunk
16:48:23 <erisco> I mean values of the other map
16:49:39 <erisco> or am I crazy? is  Map a b * Map b a  effectively strict?
16:51:43 <erisco> eh, I dunno, and Relation doesn't have its fields strict either, so it certainly isn't if you're only querying one side of it
16:52:17 <erisco> is the spine of Data.Map strict?
16:52:37 <erisco> boxception
16:53:14 <geekosaur> erisco, it's ... more complicated than that
16:53:22 <t0by> Um
16:53:30 <geekosaur> the data structure itself is not inherently strict in either spine or values
16:53:38 <laudiacay> when was parsec last well-maintained?
16:53:42 <geekosaur> the functions in Data.Map.Strict strictify the spine
16:53:49 <geekosaur> the ones in Data.Map.Lazy do not
16:54:01 <t0by> Hi, when I try to run stack build on my stack project that has wx as a dependency, at some point the build halts with an error: Could not find module `Data.List.Split'
16:54:05 <t0by> same as here: https://hackage.haskell.org/package/wxc-0.92.1.0/reports/2
16:54:13 <t0by> except that I have wxc-0.92.2.0
16:54:17 <geekosaur> the ones in Data.Map are, IIRC, *mostly* the lazy ones with a few being strict instead, to replicate the original Map behavior
16:54:26 <t0by> split *is* in the generated dependencies by stack solver
16:54:36 <t0by> ...what do I do?
16:54:52 <asdfasdf01> guys, a quick question: how to i make a ByteString out of (Ptr Word8)? ghc tells that it `Couldn't match type `GHC.Word.Word8' with `Foreign.C.Types.CChar'`
16:55:18 <ab9rf> t0by: add it as dependent module in the cabal file
16:55:24 <t0by> ab9rf, how?
16:55:29 <ab9rf> by adding it? :)
16:55:34 <Koterpillar> t0by: to wxc...
16:55:40 <Koterpillar> you might want a local copy of it
16:55:55 <Koterpillar> fork it, fix it, reference in stack.yaml
16:56:10 <t0by> oh I see.
16:56:29 <ab9rf> add "split" to build-depends in your local .cabal file
16:56:29 <t0by> I'm not sure I know how to do this.
16:56:36 <t0by> ab9rf, I have uit
16:56:40 <t0by> *I have it
16:56:48 <Koterpillar> t0by: is wxc your project?
16:56:55 <t0by> Koterpillar, oh no
16:56:58 <t0by> I'm just using it
16:57:07 <t0by> split apparently gets built *before* wxc
16:57:08 <geekosaur> asdfasdf01, Foreign.Marshal.Array.peekArray0 to convert the Ptr Word8 to a [Word8], then ByteString.pack
16:57:09 <t0by> which is funny
16:57:21 <Koterpillar> t0by: wxc is missing its dependency on split
16:57:22 <geekosaur> note that peekArray0 is necessarily in IO, so you can't just compose it directly
16:57:39 <Koterpillar> t0by: this means it's broken, and you have to add split to *its* cabal file
16:57:48 <t0by> Aw shucks
16:57:53 <ab9rf> yeah, if wxc is missing a dependency, you'll need to make a local copy, edit its cabal file, and tell stack to use the local copy instead of the repository copy
16:57:59 <t0by> I am just starting out with stack
16:58:14 <t0by> I thought it would make my life, er, easier.
16:58:18 <ab9rf> t0by: it really does
16:58:19 <Koterpillar> it actually does
16:58:25 <ab9rf> t0by: this would be MUCH harder to fix without stack
16:58:29 <Koterpillar> if you weren't using stack here, you'd have... ^
16:58:37 <t0by> Can anybody help me doing this>?
16:58:48 <Koterpillar> what's making it _hard_ is broken wxc, not stack
16:59:08 <t0by> note that in theory I do have split in my stack
16:59:13 <ab9rf> i'm impressed by how easy it is to tell stack "If uyou need this library, you'll find it here"
16:59:21 <t0by> it's in the deps and gets built *before* wxc
16:59:26 <glguy> If cabal bashing taught us anything is that you don't get to blame the bad packages for our troubles
16:59:30 <geekosaur> t0by, that doesn't matter. what matters is that stack knows it has to expose split to wxc
16:59:36 <t0by> i see
16:59:37 <geekosaur> but wxc doesn't tell it to do so
16:59:41 <geekosaur> so stack keeps it hidden
16:59:50 <ab9rf> plus, it has to know WHICH stack to expose
16:59:54 <t0by> https://hackage.haskell.org/package/wxc
16:59:59 <t0by> > All reported builds failed as of 2016-11-29 
17:00:00 <t0by> very nice
17:00:00 <ab9rf> er, which split
17:00:01 <lambdabot>  <hint>:1:31: error: parse error on input ‘of’
17:00:17 <t0by> https://hackage.haskell.org/package/wxc-0.92.2.0/reports/3
17:00:19 <t0by> is it me
17:00:28 <t0by> or this thing is ridiculously broken and unmantained?
17:00:30 <geekosaur> (if stack didn't hide things like that, you would constantly run into conflicts because different things grab whatever they want from whatever they can see)
17:00:33 <t0by> wxc, that is
17:00:49 <geekosaur> I haven't seen an update to wx / wxc in a while
17:01:07 <t0by> are there any decent alternatives around?
17:01:22 <t0by> I thought I'd *start* learning wxhaskell
17:01:29 <geekosaur> (that doesn't mean there hasn't been one, but I was under the impression recent WxWindows releases made the Haskell binding harder to maintain. it's hard to begin with because it's C++)
17:01:29 <t0by> but if it's on its last legs...
17:01:51 <ab9rf> C++ is a pain to bind to
17:02:26 <t0by> um
17:02:30 <t0by> the wxc .cabal
17:02:33 <t0by> *does* have split?
17:02:34 <t0by>   build-depends:
17:02:34 <t0by>     base >= 4.6 && < 5,
17:02:34 <t0by>     wxdirect >= 0.90.1.1,
17:02:34 <t0by>     split > 0
17:02:36 <t0by> whops
17:02:40 <t0by> sorry for long paste
17:02:51 <t0by> https://hackage.haskell.org/package/wxc-0.92.2.0/src/wxc.cabal
17:03:17 <t0by> geekosaur, how bad have I got it there? ^
17:03:17 <geekosaur> then maybe we need to see the actual build log (to lpaste please)
17:03:19 <geekosaur> @paste
17:03:19 <lambdabot> Haskell pastebin: http://lpaste.net/
17:03:27 <t0by> sure
17:03:44 <ab9rf> yeah, might not be wxc that's erroniating
17:03:49 <geekosaur> also there's other ways it can go wrong
17:04:01 <geekosaur> there's a known issue with stack and packages needed by Setup.hs
17:04:13 <ab9rf> prepackages!
17:04:15 <geekosaur> and not all packages provide the right information for it to even try to handle that
17:04:45 <geekosaur> (and it sometimes has problems even when they do provide it, the gtk2hs suite being an example)
17:06:01 <asdfasdf01> geekosaur: thanks, seems like it works now
17:06:03 <t0by> geekosaur, http://lpaste.net/1538968992125812736
17:06:46 <geekosaur> t0by, died in configure phase, that'd be the Setup.hs issue
17:06:57 <t0by> soooo what do i do
17:07:10 * t0by cries in a corner
17:07:43 * t0by opens bottle of whiskey
17:08:02 <glguy> I've had the most success making non-web GUIs with GTK in Haskell
17:08:10 <Koterpillar> patch Setup.hs not to use split?
17:08:20 <geekosaur> if you have a recent enough Cabal library, you could add to the cabal file:   setup-depends: split > 0
17:08:37 <glguy> I've also make a Cocoa GUI and attached my Haskell project to that as a library
17:08:47 <geekosaur> there's also an equivalent yaml stanza for stack to do it itself iirc
17:08:50 <ab9rf> i so hate GTK but it's probably the best
17:08:55 <t0by> geekosaur, my cabal file or...? 
17:08:58 <t0by> wxc's?
17:09:00 <geekosaur> wxc's
17:09:05 <ab9rf> in part because it's a pure C API, thus fairly easy to bind to
17:09:09 <geekosaur> since its setup needs the dependency
17:09:43 <t0by> oo-okay
17:09:45 <t0by> s-so
17:09:53 <t0by> once i've modified the .cabal file
17:09:55 <t0by> what do i do?
17:09:59 <t0by> sorry, I am a total newbie
17:10:03 <t0by> and this is... more than I expected
17:10:21 <geekosaur> try rebuilding it and see if stack obeys the setup-depends: you added
17:10:30 <ab9rf> add the path to where you unpacked it to the stack.yaml file under "packages"
17:11:09 <ab9rf> t0by: amazingly enough, this is LESS painful than dealing with these problems in most other build environments
17:11:19 <ab9rf> t0by: don't even get me started on javadeps
17:11:24 <t0by> waiwaiwat.
17:11:25 <t0by> a second
17:11:27 <geekosaur> and for stack https://docs.haskellstack.org/en/stable/yaml_configuration/#explicit-setup-deps may be needed to force it to expose the split package to Setup.hs
17:11:37 <t0by> I am inside my "test" project.
17:11:46 <t0by> My "fixed" wxc is somewhere else.
17:11:48 <t0by> what do I do.
17:11:55 <ab9rf> t0by: god, it should be somewhere else
17:11:59 <ab9rf> t0by: good that is
17:12:18 <t0by> what's the stack command line now?
17:12:24 <t0by> (or a vague hint)
17:12:33 <ab9rf> t0by: in the stack.yaml for your project, add, under "packages" and after '.', the local filesystem path to your wxc project root
17:12:38 <geekosaur> you need to point stack.yaml to the fixed wxc as a local dependency https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
17:12:41 <t0by> ab9rf, thanks
17:12:42 <ab9rf> (should be the directory with the wxc.cabal file in it)
17:12:51 <orion> If you're writing bindings for a library and the author used #pragma pack(1), are you SOL?
17:13:55 <Zemyla> Is this a C library?
17:13:57 <ab9rf> t0by: https://gist.github.com/ab9rf/3a1d912e6f47c75b32e00356493306f3 is a stack.yaml for a project i'm working on atm
17:14:01 <orion> Zemyla: Yes.
17:14:01 <basquerano> hello, I have a question about the following "Both Text and ByteString are quite similar to lists, in that they represent a sequence of values. All three data types have very similar APIs, which you've already seen some of in the synopses above. Functions you're already used to like take, drop, break, foldl', and others are all available. For the most part, if you're familiar with the list API, you can stick a S. or T. in front 
17:14:11 <ab9rf> t0by: there's two local copies of other packages listed there
17:14:30 <basquerano> how come we can't use the exact same functions instead of reimplementations?
17:14:40 <geekosaur> stock c2hs might not handle it. gtk2hs's build involves a modified c2hs (gtk2hsc2hs) which might work better. hsc2hs would probably also work but you'd have to rewrite all the special pragmas in the .chs file
17:14:59 <glguy> basquerano: Because all the implementations work differently even if they are similar in spirit
17:15:10 <basquerano> isn't that what typeclasses are for?
17:15:12 <Koterpillar> basquerano: the functions were originally defined for String, and not for a typeclass
17:15:22 <Zemyla> orion: You aren't SOL, but you may have to write the bindings yourself.
17:15:22 <Koterpillar> basquerano: and some even for [a]
17:15:40 <glguy> basquerano: Those functions aren't similar enough to share a simple typeclass
17:15:43 <geekosaur> basquerano, there's a package for that: mono-traversable. the problem is, when it works it works well but when it fails you get a VERY slow program
17:15:46 <Koterpillar> basquerano: particularly take, drop all work on [a]
17:16:05 <Zemyla> basquerano: They have the wrong kind.
17:16:18 <geekosaur> because, while you can do it with typeclasses, it can only do it by exploding a Text or ByteString into a normal list and packing it back up again
17:16:23 <basquerano> i find it odd that those functions were defined for list when its obvious they generalize to 'containers' or whatever the typeclass is (traversable?)
17:16:25 <orion> Zemyla: Is it overkill/inefficient to write a slew of C struct accessors? hs_get_field_a_from_foo(foo_t *f) { return f->a; }
17:16:30 <geekosaur> mono-traversable tries to avoid doing that, but sometimes fails
17:16:42 <ab9rf> geekosaur: ouch
17:16:49 <t0by> nope
17:16:50 <t0by> no joy
17:17:04 <t0by> i have latest haskell platform, mind you
17:17:06 <Zemyla> You could do Functor and Foldable, at least, through Coyoneda encoding.
17:17:09 <geekosaur> basquerano, the point you may be missing is that ByteString and Text are fundamentally arrays, but lists are singly linked lists
17:17:10 <glguy> mono-traversable helps with some of it, Each goes even further
17:17:16 <glguy> neither of those classes handles all of it
17:17:22 <ab9rf> t0by: believe it or not, i had to UNINSTALL the platform in order to get stack to work reliably.
17:17:32 <basquerano> aren't those implementation details? it makes sense to take, drop, length etc all of those
17:17:33 <t0by> that's it
17:17:40 <t0by> i'm switching to clojure.
17:17:51 <t0by> (not.)
17:17:51 <Zemyla> data ByteStr a = ByteStr (Word8 -> a) ByteString.
17:17:57 <geekosaur> basquerano, for those 3 it's fine, but consider map
17:18:08 <geekosaur> or folds
17:18:13 <basquerano> yes?
17:18:36 <t0by> so, I basically still have no idea of how to install wxc
17:18:37 <geekosaur> now you have to explode the array into a linked list, or else you are talking about fundamentally different operations
17:18:47 <t0by> i added     split > 0
17:18:49 <t0by> but...
17:18:49 <ab9rf> t0by: if stack detects a GHC installation it'll use it, efen if it's not quite right. if no GHC is installed, it'll make a local installation specific to the project you're building
17:19:00 <basquerano> i don't understand why you would need to convert the data type, as long as you have some sort of iterable structure
17:19:05 <t0by> ab9rf, and is that a bad thing?
17:19:21 <geekosaur> typeclasses do not save you; arrays are more efficient at the expense of making operations like map or fold fundamentally more difficult to implement
17:19:24 <athan> iirc it installs it in the system, something like ~/.stack ab9rf
17:19:57 <ab9rf> t0by: it can be if you are trying to build a package that the version of GHC installed on the system cannot build that particular package
17:20:03 <athan> Has anyone here looked at linear types?
17:20:22 <t0by> ab9rf, cam
17:20:28 <t0by> can't --install-ghc save me?
17:20:33 <ab9rf> t0by: sometimes
17:20:41 <athan> I'm wondering if other substructural weights could be used, instead of strictly "just one" use of an abstracted variable
17:20:44 <t0by> i... 
17:20:50 <t0by> am pretty desperate right now.
17:21:13 <athan> t0by it should
17:21:16 <ab9rf> t0by: maybe try using gtk instead? :)
17:21:16 <athan> --no-system-ghc too
17:21:34 <t0by> I have no idea what to do, except that I am inclined to consider wxhaskell utterly borked 
17:21:42 <ab9rf> t0by: windows or linux?
17:21:45 <t0by> ab9rf, don't think i am not considering it.
17:21:47 <athan> oh it's a package? it might be :/
17:21:48 <t0by> ab9rf, linucks.
17:21:57 <ab9rf> hm, shouldn't be as troublesome on linux
17:22:08 <ab9rf> windows is a pita because the version of msys in the platform is kinda sucky
17:22:19 <athan> t0by does it fail with the inability to resolve dependency versions?
17:22:22 <basquerano> ok, i think i got it. these containers are not polymorphic
17:22:53 <t0by> athan, http://lpaste.net/1538968992125812736
17:23:29 <t0by> *oh*
17:23:38 <t0by> that's why I have skipped gtk2hs
17:23:38 <t0by> http://projects.haskell.org/gtk2hs/
17:23:44 <t0by> > 404
17:23:45 <lambdabot>  404
17:24:06 <athan> t0by: try using --no-system-ghc --install-ghc
17:24:14 <athan> did you install stack via nix, btw?
17:24:23 <t0by> athan, nope
17:24:28 <athan> nix has a tendancy to hoard dependencies in a hard to find way :)
17:24:31 <glguy> t0by: That's just a stale website for the project. Stuff happens on github now
17:24:35 <athan> what did you install with nix?
17:24:37 <Koterpillar> t0by: also try gi-gtk
17:24:59 <t0by> Koterpillar, pros/cons?
17:25:21 <Koterpillar> t0by: you get all of gtk, instead of the possibly-mismatched handwritten bindings
17:26:30 <t0by> fantastic
17:26:32 <t0by> thank you all
17:26:34 <t0by> i'mgoing to bed
17:26:37 <t0by> i'm mostly dead
17:26:40 <t0by> 2AM here
17:26:42 <athan> sleep is for the dead!
17:26:45 <athan> :v
17:26:58 <t0by> well
17:27:00 <t0by> i'm mostly dead
17:27:03 <t0by> so i'll mostly sleep
17:27:11 <t0by> mostly nite
17:27:58 <athan> monotone sleepism
17:28:09 <sm> t0by: also, if gi-gtk doesn't work consider fltkhs
17:28:57 <erisco> geekosaur, the functions strictify so that the modules can share the same data type?
17:29:06 <geekosaur> yes
17:29:26 <erisco> sounds like data type contexts all over
17:29:31 <geekosaur> you'd have to ask someone involved with the containers package why they made that decision
17:30:41 <erisco> it is better for APIs which want to expose Maps
17:31:02 <geekosaur> (but the answer is probably flexibility, plus maps don't have the issue that arrays do with respect to laziness needing them to be split up; map nodes are already split up by necessity)
17:31:22 <glguy> geekosaur: The functions in Data.Map.Lazy are also spine strict
17:31:31 <glguy> it's the values that are lazy
17:31:39 <glguy> stored on that spine
17:32:35 <Zemyla> I kind of wish ropes were either in the containers or vector package.
17:33:04 <erisco> with data type contexts everyone came to recognise that it inhibited generality by prescribing a context
17:33:25 <erisco> so the same follows with strictness
17:35:00 <Zemyla> If we do get unboxed, lifted types, will foldl' and foldr' be obsoleted in favor of folding into an unboxed value?
17:36:19 <erisco> does that mean that # types are *'s?
17:36:46 <glguy> Zemyla: Probably not, you'd still want to be able to use foldl' where the "accumulator" was a normal boxed type
17:37:11 <erisco> boxiness and strictness are not synonymous
17:37:54 <Zemyla> I may actually be thinking of boxed, unlifted.
17:38:48 <erisco> what does "lifted" mean here?
17:40:06 <MarcelineVQ> lifted terms can be bottom
17:42:21 <erisco> I don't know what sense "unboxed and lifted" has then
17:48:00 <erisco> mkStrictRel !m !n = Relation m n
17:48:10 <erisco> and the same pattern for other types
17:48:27 <geekosaur> occurs to me boxed may relate to the constructor tag?
17:49:32 <geekosaur> whereas lifted might be whether it's a pointer or just a chunk of memory
17:49:32 <erisco> there is a pointer to the value and crammed into the pointer is a constructor tag, last I knew
17:50:29 <Zemyla> One of the two was a proposal for having types in GHC which can't be thunks.
17:50:53 <MarcelineVQ> boxed is the pointer relation, Array# is boxed for example
17:51:14 <erisco> yes
17:51:37 <MarcelineVQ> unlifted and boxed
17:52:18 <erisco> what is the significance of a strict type? (what I presume you mean by "can't be thunks")
17:52:36 <erisco> we see in Data.Map.Strict you can add strictness by use
17:52:52 <erisco> and it doesn't change anything in the foldl case as far as I can tell
17:54:32 <Zemyla> True, foldl and foldl' have different execution orders, I think.
17:54:51 <erisco> the problem is to get the value you have to evaluate  f x y, but then x = f x' y', and x' = f x'' y'', and so on
17:55:40 <grantwu>  Uh... noob question
17:55:44 <grantwu> How do I cd in ghci?
17:56:10 <yushyin> grantwu: :cd
17:56:23 <orion> What hackage category would libnfc (near field communication) bindings fall under? 
17:56:43 <grantwu> yushyin: :(
17:56:59 <grantwu> Okay, how do I start a repl in a certain working directory?  I don't want to unload all loaded modules...
17:57:14 <grantwu> eh, nvm, I'll just move the file I'm interested in
17:57:15 <erisco> yes, foldl' goes the other way around, so first you evaluate  f x'' y'', then f x' y'  knowing x' = f x'' y'', then f x y knowing x = f x' y'
17:57:25 <grantwu> actually, no, I would still like to know the answer to that question
17:57:50 <erisco> so you just need to remember the last result, as opposed to the stack of evaluations of foldl
17:57:58 <nshepperd> @src foldl
17:57:58 <lambdabot> foldl f z []     = z
17:57:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:58:50 <erisco> all through the ghc magic of seq
17:59:25 <nshepperd> if z is an inboxed type there, presumably that means the runtime must evaluate (f z x) before entering the recursive foldl there?
18:00:00 <nshepperd> inboxed, lol. I mean unboxed of course
18:01:09 <grantwu> Just got bit by FilePath being a String >.>
18:02:46 <grantwu> ugh.
18:02:52 <erisco> maybe you're right
18:03:33 <erisco> my thought was that application is not strict, but then if the type cannot store a thunk there is no way to call foldl again without evaluating f z x
18:03:42 <grantwu> Does shelly seriously not support piping binary data?
18:03:53 <grantwu> grumble grumble...
18:04:35 <erisco> and this is of course different than a data type with strict fields
18:05:16 <erisco> a data type with strict fields can be thunked, like Array# as MarcelineVQ mentions
18:05:24 <erisco> (unboxed implies strict)
18:06:04 <erisco> but semantically it still has bottom, no? how not?
18:06:58 <nshepperd> in that the computation can fail to terminate, yes
18:07:25 <erisco> er, I don't know what Array# is, I was thinking UArray
18:07:42 <nshepperd> so, like bottoms in strict languages
18:08:27 <erisco> so I suppose it would make foldl' obsolete
18:08:56 <erisco> now, is this a type operator * -> *?
18:09:12 <nshepperd> I suppose so, but then again who really wants to use unboxed values all day
18:09:18 <nshepperd> sounds horrible
18:09:20 <erisco> then you could, say, have  Maybe (Strict Int)  for example
18:09:33 <erisco> not unboxed, they are boxed, but strict
18:09:48 <nshepperd> it would be * -> # or something
18:09:54 <erisco> they are not unboxed though
18:09:59 <nshepperd> or maybe you'd invent a new kind for them
18:10:18 <erisco> well if it is a new kind you cannot use them with type constructors :(
18:11:37 <athan> So GHC uses a supercombinator implementation when compiling to SystemFC_pro right?
18:11:48 <athan> (or whichever the new one is for TypeInType)
18:12:00 <athan> or wait
18:12:23 <athan> derp, I mean after SystemFC_pro to STG <.< nobody saw that right?
18:12:30 <nshepperd> I suppose things wouldn't break per se if they were boxed but 'strict' and they were in *, but polymorphic functions wouldn't do the right thing when handed a Strict _
18:13:04 <Rotaerk> athan, I saw that; but don't worry, I don't even know what you're talking about
18:13:27 <erisco> hm, yeah, it would have to be something else, something like Lazy in some other languages where Lazy is like an annotation rather than a type function
18:13:35 <erisco> even though syntactically it looks the same
18:14:23 <athan> :U shoot okay, yeah I'm just trying to understand g-code, it's a tricky one
18:14:28 <erisco> or a type constructor
18:14:44 <erisco> (i.e. not a type constructor either)
18:16:58 <erisco> I wonder what you'd do for code gen... seems a disaster if you have to give a version of a function for every combination of strict arguments
18:17:14 <nshepperd> eatsMaybe :: forall k (a :: k). Strictness k => Maybe a -> Foo
18:17:27 <erisco> but I don't know how compiling against Haskell libs works
18:18:09 <erisco> a kind context? oO
18:19:13 * nshepperd wonders if that's actually allowed and not crazy-person talk
18:19:58 <erisco> I have never seen a kind in that position before
18:21:02 <erisco> why not just  Strict a => Maybe a -> Foo
18:21:16 <erisco> you lose precision though, say  a -> a -> a
18:21:28 <erisco> Strict a -> a -> a  or  a -> Strict a -> a  or any other combination
18:22:27 <erisco> and don't we want kinds to mean something?
18:22:30 <erisco> :k Maybe
18:22:31 <lambdabot> * -> *
18:23:07 <athan> erisco you mean Strictness? Wait... ooh la la...
18:23:20 <athan> kinda
18:23:22 <athan> :X
18:24:03 <erisco> you could steal ' to mean strict, so  a' -> a -> a  for example
18:24:48 <erisco> then it doesn't confusingly look like a type constructor or type function
18:26:39 <erisco> though that conflicts with DataKinds
18:27:12 <erisco> or does it use prefix '
18:27:26 <erisco> '[a]' lol
18:28:10 <erisco> but that's okay, because suffix ' is illegal on non-* values
18:29:37 <erisco> I just think you're screwed on code gen unless you preserve that annotation in libraries
18:30:46 <erisco> I mean unless you preserve the original polymorphic version, not committed to lazy types
18:30:55 <erisco> not sure how that ecosystem works
18:33:58 <winter_> Hi there
18:34:20 <dfeuer> JuicyPixels sure takes a while to build. 
18:34:31 <winter_> I want to know why (>>) is left associative 
18:35:00 <winter_> Is there any problem is i change  (>>) to right associative?
18:35:37 <dfeuer> winter_, well, left associative works better for lazy state and reader.... But that does seem weird.
18:35:46 <dfeuer> Really weird.
18:36:10 <winter_> Can you explain more on lazy state?
18:36:54 <dfeuer> Oh wait.
18:36:59 <dfeuer> I think I figured it out.
18:37:12 <dfeuer> It's left associative because >>= is left associative.
18:37:17 <winter_> OK, thanks, I'm just wondering isn't right associative (>>) more 'nature' or 'performance' to most of Monads.
18:37:24 <lpaste> nshepperd pasted “strictness silliness” at http://lpaste.net/349697
18:37:40 <nshepperd> erisco: ^^
18:37:40 <dfeuer> And they're the same precedence, so doing it that way means you can write things like a >> b >>= f
18:38:01 <winter_> Ah ~ i see
18:38:23 <dfeuer> winter_, well, for lazy state, the "earlier" parts of the computation are driven by the "later" ones.
18:38:37 <dfeuer> So   m >> pure x   is just pure x.
18:38:44 <nshepperd> that system is kind of lame though because it requires you to put this constraint in basically everything
18:39:45 <dfeuer> So for lazy state, it's (slightly) better to have a >> b >> c >> d, which turns out to be (a >> b >> c) >> d, so if d doesn't look at the state, nothing else even has to be *looked at*. It's never *run* in any case.
18:39:57 <dfeuer> But the real reason is syntax.
18:40:01 <winter_> Yes, that makes sense.
18:40:36 <dfeuer> >> mixes with >>=, and >>= really should be left-associative.
18:41:12 <winter_> Yes, I can see why (>>=) is arranged this way.
18:43:05 <winter_> Thank you, dfeuer!
18:43:13 <dfeuer> No problem.
18:43:55 <winter_> I'm reading the CPSed Maybe Monad: newtype MaybeCPS r a = MaybeCPS { runMaybeCPS :: (a -> r) -> r -> r }
18:44:26 <winter_> And wondering why don't we just replace (>>) with a right associative one
18:45:12 <winter_> Now it seems the reason is quite obvious ; )
18:45:25 <dfeuer> *nod*
18:49:45 <erisco> mm, an example of why closed classes would be cool
18:49:54 <erisco> then you don't need to instance all types
18:51:25 <erisco> aint no one going to work with that, though it is a solution
18:58:39 <nshepperd> well, we could define 'newtype Lazy a' also and then have an instance for that, then make you explicitly choose between Lazy and Strict
19:03:15 <nshepperd> but I think being able to define my own kind (of boxed values) instead would be coolest. 'newtype Lazy (a :: *) :: LazyKind = Lazy a; instance Strictness *; instance Strictness LazyKind;'
19:06:27 <mekeor`> Q: can you use package.yaml instead of projectname.cabal now?  – i'm just seeing it the first time
19:06:49 <glguy> You can but it requires you/your users to have extra tools installed ot build your package
19:07:32 <mekeor`> which extra tools? cabal and stack are also extra tools...
19:08:09 <glguy> beyond having  cabal install you'll need the hpack tool
19:09:57 <mekeor`> oh, well. hpack has quite some dependencies. i see
19:11:22 <nshepperd> cool, one can indeed define instances for kinds like *
19:11:45 <mekeor`> Q: is `stack build` supposed to generate haddock, too? (`stack haddock` works for my project but `stack build` doesn't generate haddock.)
19:12:23 * mniip prods edwardk some more
19:13:37 <MarcelineVQ> mekeor`: stack haddock is probably just stack build --haddock    check out --haddock  --haddock-arguments and --haddock-deps flags for stack build for more info
19:18:48 <nitrix> Oh fancy, I just learned you can do :set -package name in GHCi to load a package, instead of a dummy cabal file.
19:19:31 <mekeor`> i think my question doesn't even make sense. (i wanted `stack build` to automatically generate haddock, too. But that decision should be taken by the person building the package, not by the package author.)
19:19:54 <mekeor`> nshepperd: can you give an example?
19:28:37 <unskill> Why Control.Monad.Error deprecated? Why Except better?
19:32:58 <glguy> It's not better, it's just different. ErrorT catches fail, ExceptT passes it to the transformed type
19:36:42 <unskill> sry, don't see it from ErrorT and ExceptT definitions
19:37:54 * edwardk is prodded.
19:38:08 * edwardk then wonders why he was prodded and looks.
19:38:38 <nshepperd> mekeor`: no useful examples. but you can indeed do things like 'class Foo k where { foo :: Proxy k -> String }; instance Foo (*) where { foo _ = "the kind of values!" }'
19:39:43 <edwardk> winter_: cps'd maybe is really MaybeCPS a = MaybeCPS (forall r. (a -> r) -> r -> r)
19:40:34 <edwardk> unskill: look at the constraint on the Monad instance for ErrorT vs. the lack of a constraint for EitherT
19:41:08 <edwardk> instance (Error e, Monad m) => Monad (ErrorT e m)  vs. instance Monad m => Monad (ExceptT e m)
19:43:08 <winter__> edwardk: aye
19:43:46 <winter__> but if i understand right, CPSed Maybe Monad is faster only because it can 'exit' faster
19:43:51 <winter__> is that ture?
19:44:02 <edwardk> well. 'faster' is relative to what you use it for
19:44:25 <edwardk> CPS'd maybe can be asymptotically much worse if you inspect the result multiple times or inspect the result, then bind it, etc.
19:44:29 <winter__> relative to normal maybe monad: data Maybe a = Just a | Nothing
19:44:42 <edwardk> what matters is what you do with it
19:44:45 <unskill> edwardk: ehm... so ExceptT is just less constrained?
19:44:49 <edwardk> it isn't faster than Maybe in all situations
19:45:06 <winter__> ah.. my brains hurt
19:45:17 <winter__> i'm trying to understand 
19:45:41 <winter__> Can you show a concrete example that CPSed Maybe is not the right choice
19:45:43 <edwardk> unskill: fail is bolted into Monad but isn't part of the mathematical definition. ErrorT bends over backwards to make itself have a useful fail definition. ExceptT doesn't
19:46:45 <cdepillabout> Hi, I feel like I've heard of a package that lets you use template haskell to grab ahold of types and constructors.  Does anyone know the package name?
19:47:06 <edwardk> winter__: sure. take a MaybeCPS computation x. then runMaybeCPS x Just Nothing. look at the result of that. if you like it, runMaybeCPS (x >>= somethingelse) whatever whatever, otherwise don't.
19:47:19 <cdepillabout> As an aside, I believe at least one package doing this was created by someone at Tsuru in Tokyo.
19:47:24 <edwardk> if you 'run the computation' in MaybeCPS twice you pay for everything twice
19:47:36 <edwardk> this is the same problem codensity has or cps'd calcs have in general
19:47:55 <unskill> edwardk: got it. (or not)
19:48:02 <edwardk> this was the motivation for reflection without remorse
19:48:46 <edwardk> unskill: ErrorT was written back in the day before someone thought maybe overcomplicating the monad just to support fail at the expense of working for any 'e' wasn't worth it.
19:48:51 <winter__> Ah, i see. because CPSed (>>=) always create a new lambda
19:49:12 <cdepillabout> Oh, I'm sorry, I meant to say " I've heard of a package that lets you use template haskell to grab ahold of UNEXPORTED types and constructors.  Does anyone know the package name?"
19:49:16 <winter__> so it's not memorized
19:49:22 <edwardk> winter__: yeah. if you (runMaybeCPS x Just Nothing)   then do it again. you have to pay full price twice
19:49:56 <winter__> OK, very good example. Thank you!
19:50:28 <edwardk> free monads have a similar issue. you can use the 'church encoded' free monad or a 'codensity based free monad' to get cheaper >>= but it comes at the cost that inspecting the result pays full price for the entire computation up to that point, and converting back and forth is expensive.
19:51:08 <edwardk> for Maybe converting from Maybe -> MaybeCPS is constant cost, but for something like [] vs. a "ListCPS" has potentially more than one 'a' in it and has to pay n units of work for n items to convert.
19:51:32 <edwardk> so if you do something that say, inspects the list then you >>= the result based on that information, ListCPS would be asymptotically worse
19:51:52 <edwardk> this is what 'reflection without remorse' was invented for. to try to get the best of both worlds. cheap >>= and cheap inspection
19:51:57 <edwardk> but the constant factors are awful =(
19:52:06 <geekosaur> cdepillabout, http://hackage.haskell.org/package/true-name
19:52:18 <cdepillabout> geekosaur: That's what I was thinking of!  Thanks!
19:52:30 <winter__> Okay, i'll read 'reflection without remorse' to see if i can get a better understand.
19:52:32 <edwardk> so most of the time you are better off reasoning about whether you'll inspect the result more than once and using cps'd tricks or not based on that
19:52:52 <edwardk> winter__: you may want to rummage around on comonad.com looking up codensity and 'free monads for less'
19:53:13 <edwardk> both of those topics arise fairly often in some of my older articles there
19:53:39 <winter__> Thanks, i will read them for sure ; )
19:54:18 <edwardk> We spent months in #haskell-lens trying to build more efficient forms of reflection without remorse =(
19:54:49 <edwardk> alang9 wrote some of the most complicated haskell i've ever seen in the process
19:55:10 <winter__> Ah, that's spectacular.
19:55:44 <edwardk> https://github.com/alang9/deque/blob/master/Data/Deque/Cat.hs
19:55:52 <edwardk> check out the size of some of those case statements
19:56:04 <edwardk> every single one of them matters
19:56:58 <winter__> OH MY HOLY..., The whole context is that i'm preparing a internal training material for my company
19:57:01 <winter__> https://github.com/winterland1989/magic-haskell/blob/gh-pages/haskell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%40didiFP/haskell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B5.pdf
19:57:05 <edwardk> this was our attempt to get a working tarjan-mihaescu deque (a catenable deque with O(1) worst case performance for all operations
19:57:31 <winter__> And i'm falling into this CPS rabbit hole.
19:57:32 * nshepperd opens the _reflection without remorse_ paper. "Ah, this is the Data.Sequence of free monads"
19:57:33 <Koterpillar> I like how the only comments are pragmas.
19:57:59 <Koterpillar> Actually, no, there are a few, but...
19:58:00 <edwardk> Koterpillar: there is a "paper" that motivates the design
19:58:28 <edwardk> https://www.cs.princeton.edu/courses/archive/fall03/cs528/handouts/Notes%20on%20Catenable%20Deques.doc
19:58:32 <edwardk> that doc is the only writeup
19:58:39 <edwardk> and it lies so hard
19:59:00 <winter__> nshepperd: i have the same impression last time i read it.
19:59:14 <edwardk> it leads you to believe it'll be easy. then the last paragraph in the first section says 'ignore all that and do this other thing instead' -- which requires you to know how a kaplan-tarjan deque works
19:59:28 <edwardk> and then it does the same thing in the last paragraph of the second section
19:59:43 <edwardk> i first thought 'oh this'll be a day;s work banging out a cute data structure'
19:59:46 <edwardk> oh hell no
20:00:22 <edwardk> the thing is. tarjan implemented the thing in fricking scheme. no types. i can barely wrap my head around it with full types at my disposal.
20:00:49 <winter__> (╯°Д°）╯
20:01:46 <edwardk> and that is after i have spent long years studying all of tarjan's little tricks i can find -- as they are really useful for building data structures
20:02:24 <edwardk> anyways the key thing about that code of alang9's above is the entire thing is non recursive. that makes it pretty easy to show the O(1) worst-case bound =)
20:02:40 <edwardk> the cases are ridiculous though
20:04:18 <bollu> hey guys
20:04:25 <bollu> I want to get line numbers from my .lhs file
20:04:34 <bollu> like, when I generate a markdown file with pando
20:04:36 <bollu> pandoc
20:04:42 <bollu> I would like to have line numbers
20:04:43 <edwardk> anyways if you have a c.s. grad student you hate, give them that .doc file and ask them to go implement it as a significant part of their grade
20:04:45 <bollu> does anyone know how to do this?
20:04:57 <bollu> edwardk: context? :)
20:05:04 <edwardk> https://www.cs.princeton.edu/courses/archive/fall03/cs528/handouts/Notes%20on%20Catenable%20Deques.doc
20:06:27 <kadoban> edwardk: O.o is that code above all hand written?
20:06:31 <bollu> does anyone know how to use pandoc to generate line numbers on a .lhs file?
20:06:35 <edwardk> kadoban: yes
20:06:46 <kadoban> edwardk: Wow.
20:08:49 <edwardk> kadoban: i have another version of it around somewhere thats a bit smaller, but i never finished all the cases.
20:09:15 <edwardk> alang9 moved all the constraints into the types, so he was able to typecheck his bugs as he went
20:09:25 <edwardk> the nice thing is that pretty much nothing illegal _can_ typecheck
20:09:30 <kadoban> That's rather scary code. I can't imagine ever being able to fit all of it in my brain to even understand it.
20:09:31 <edwardk> so the code does largely write itself
20:09:47 <edwardk> you don't need to fit it all into your head. just the context for each line as you write it
20:09:55 <kadoban> That sounds impressive, and almost necessary with that amount of code.
20:11:17 <alang> "<edwardk> alang9 wrote some of the most complicated haskell i've ever seen in the process" I feel like this needs to go on my linkedin page
20:11:22 <Gurkenglas> As in, bruteforcing all of codespace constrained by the types checking out would generate that code from those types?
20:11:27 <edwardk> alang: =)
20:12:16 <Gurkenglas> bollu, *googles* https://github.com/jaspervdj/hakyll/issues/148#issuecomment-17839336 how about this?
20:12:21 <edwardk> Gurkenglas: yeah. you could just sit there with agda and autocomplete your way to glory with all the type alignment constraints
20:12:43 <Gurkenglas> dangit we never got around to finishing up exference
20:14:34 <bollu> Gurkenglas: from wat I know, the ~~~ is not .lhs
20:14:37 <kadoban> exference is not complete until it can generate that file above
20:14:40 <bollu> at least, It doesn't compile for me :(
20:18:21 <orion> I have a program which does two things: 1. fetches JSON data from the Internet every 5 minutes in one thread. 2. a different thread reads that data when it needs to perform a computation. I can guarantee that the data will only ever be written from one thread, ever.
20:18:31 <orion> Is ST/STRef a good choice in this case?
20:20:51 <Gurkenglas> Sounds like pipes/conduits should apply in some fashion?
20:21:45 <Gurkenglas> https://hackage.haskell.org/package/pipes-async-0.1.1/docs/Pipes-Async.html#v:buffer
20:40:16 <Gurkenglas> I want the following feature in do notation: In place of any last line in a do block reading "foo $ \x -> do", you can put "x <-- foo" (or some other operator in there) and continue in the same do block.
20:43:55 <Koterpillar> Gurkenglas: that changes the type of the later lines
20:47:40 <Gurkenglas> Even restricting the types of the later lines needing to stay equal, this'd for example cover the case "i <-- forM [1..10]".
20:49:17 <Gurkenglas> Or, like, any Traversal
20:50:46 <Koterpillar> it would look quite strange with signal handling type things
20:51:02 <Koterpillar> but one doesn't have to use it...
20:57:02 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/45 n8
20:57:10 <codygman> Is there an existing way to find "zero values" for common types such as Int,String,Double? 
20:57:59 <lordcirth> codygman, what do you mean?  A common function which outputs 0 for all these types?
20:58:37 <Koterpillar> codygman: they are all instances of Monoid, so mempty
20:59:43 <codygman> lordcirth: Yes. Koterpillar: I was thinking that might be it but was confused when mempty (0 :: Int) returned unit
20:59:51 <codygman> > mempty (0 :: Int)
20:59:53 <lambdabot>  ()
21:00:00 <glguy> Neither Int not Double are instances of Monoid
21:00:11 <codygman> glguy: Ah okay
21:00:16 <glguy> codygman: In your example you're using the function and () instances of monoid
21:00:24 <Koterpillar> > mempty (Sum (0 :: Int))
21:00:27 <lambdabot>  ()
21:00:37 <Koterpillar> ...hmm?
21:00:47 <glguy> Koterpillar: : In your example you're using the function and () instances of monoid
21:00:48 <Koterpillar> :t mempty
21:00:50 <lambdabot> Monoid a => a
21:00:55 <Koterpillar> bah
21:01:01 <Koterpillar> > mempty :: Sum Int
21:01:03 <lambdabot>  Sum {getSum = 0}
21:01:07 <codygman> glguy: ah
21:01:08 <codygman> > mempty ("test" :: String) :: String
21:01:11 <lambdabot>  ""
21:01:19 <Koterpillar> > mempty :: String
21:01:22 <lambdabot>  ""
21:01:32 <Koterpillar> > mempty :: (String, Sum Int, Sum Double, Product Int)
21:01:34 <lambdabot>  ("",Sum {getSum = 0},Sum {getSum = 0.0},Product {getProduct = 1})
21:02:23 <codygman> thanks Koterpillar and glguy, I think I know how I can make this  work now
21:03:51 <ab9rf> heh
21:09:30 <mniip> edwardk, do you think an applicative LR parser in haskell has any potential use?
21:10:54 <edwardk> you can do a full applicative CFG parser
21:11:08 <mniip> I mean, an actual LR instead of LL
21:11:09 <edwardk> LR has some opportunities but not as many as that
21:11:11 <edwardk> sure
21:11:18 <edwardk> and i meant full CFG, not LL
21:11:19 <edwardk> =)
21:11:31 <mniip> I think .*parsec uses top-down parsing
21:11:49 <edwardk> things you might want to look into are GLR parsing, and peter pepper's grammar transformation parser
21:12:13 <edwardk> parsec is an LL style recursive descent parser
21:12:21 <mniip> yeah
21:12:31 <mniip> that has poor worst case asymptotics doesn't it
21:12:36 <edwardk> but you can use observable sharing to make a form of CFG from an aplicative grammar
21:12:58 <mniip> observable sharing?
21:13:06 <edwardk> then you can apply something like http://www.cse.chalmers.se/~bernardy/PP.pdf
21:13:27 <edwardk> type safe observable sharing in haskell: http://ku-fpg.github.io/practice/observablesharing/
21:13:53 <edwardk> the code in data-reify probably doesn't work for you here. i usually reimplement it when i need to work with applicatives
21:14:01 <edwardk> but its packaged as data-reify on hackage
21:14:11 <edwardk> older versions of 'ad' used it heavily
21:14:18 <mniip> hmm,sounds like it breaks RT
21:14:33 <mniip> anyway-
21:14:35 <edwardk> it does so but only via IO
21:14:57 <edwardk> anyways you can play games to recover referential transparency by being careful about what you do with the graph
21:15:06 <edwardk> that is what i do in AD
21:15:24 <mniip> if you want syntax-directed translation, which you pretty much always want to do in applicative parsers
21:15:30 <edwardk> the fact that i can see the graph structure of your arithmetic expression doesn't change the result from the expanded out tree, its jut way way way way way more efficient
21:16:03 <mniip> ok, lemme rephrase that
21:16:03 <edwardk> the problem is ultimately that without observable sharing you always get an infinite grammar
21:16:16 <edwardk> with observable sharing you might get a finite one
21:16:23 <mniip> say we want to implement a shift-reduce parser
21:16:26 <codygman> At the end of the vinyl tutorial (https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Tutorial-Overview.html) it shows this example of using rtraverse to give either a record or nothing: 'let mbadPerson = rtraverse getCompose badPersonResult'  Rather than giving back nothing I'd like to give back default values such as String => "", Int => 0, Double => 0.0 but I feel a little out of my depth and wondered if anyone coul
21:16:48 <mniip> a parser datatype would then be a list of reduce rules, and combinators would combine and extend the rule set
21:16:53 <edwardk> the problem is that you need to have the entire grammar to compute conflicts for an LR style parser
21:17:13 <mniip> yeah, the 'parse' function would do that
21:17:24 <mniip> but the thing is
21:17:33 <mniip> if you want syntax-directed translation
21:17:42 <mniip> and you want it to happen at more than one type
21:17:51 <mniip> you need your reduction rules to be typed
21:18:06 <dfeuer> Which is better?  collect f = P . collect (unP . f), or collect = (P .) #. collect #. (unP .) ?
21:18:07 <edwardk> and what i'm saying is that something like observable sharing is needed to deal with stuff like 'many' or at least for less trivial recursion in the grammar
21:18:19 <mniip> yeah no, that's very much not my point here
21:18:23 <edwardk> you can either force all recursion to go through some fancy combinator or observe sharing
21:18:31 <mniip> I'm just saying that,
21:18:33 <dfeuer> Hello, edwardk.
21:18:41 * edwardk hides fro dfeuer
21:18:46 <dfeuer> :'(
21:19:01 * dfeuer is not going to dump a ton of hard questions on edwardk today.
21:19:02 <mniip> I came up with a way to automatically label nonterminals in applicative parsers,
21:19:03 <edwardk> the groundhog sees his shadow
21:19:13 <mniip> as well as store type information in the reduce rules
21:19:16 <dfeuer> It's safe, edwardk! Safe!
21:19:40 <mniip> wondering if it could be useful anywhere
21:20:32 <edwardk> mniip: the issue is you can't just do so recursively, as the 'tree' is infinite for any interesting grammar
21:20:53 <mniip> well that's a problem that could be solved using observable sharing
21:20:56 <mniip> I solved it differenly
21:20:59 <dfeuer> edwardk, I'm just looking at Linear.Affine and wondering if I should define (>>-) = ((P .) . (. (unP .))) #. (>>-) .# unP, and suchlike. Coerce all the things...
21:21:11 <edwardk> what is the different solution?
21:21:14 <mniip> by introducing a recursion detection combinator
21:21:48 <mniip> the simple idea is something like..., lemme find it in my logs
21:22:09 <edwardk> mniip: i'm not particularly partial to that form of solution. one of the beautiful things about haskell is you can write your grammars in a nice way. having to write everything in terms of a special knot tying combinator really limits the forms your grammars can take
21:22:33 <mniip> well not everything
21:22:41 <mniip> just gotta place one in every loop
21:23:32 <edwardk> yeah, but now if you later on add a "(" exp ")"  -- and exp is way above it in the grammar, you need to go through your combinator.
21:24:01 <edwardk> the issue is that things like 'hidden' right or left recursion can be awkward to state the way you're proposing
21:24:17 <edwardk> i've written grammars that way in javascript and scala and ml-like languages
21:24:45 <mniip> could add "(" rec exp ")" instead
21:25:01 <mniip> doesn't really matter at what point it is used
21:25:12 <slack1256> with pipes-safe, should I use SafeT (Producer ...) a or Producer (SafeT IO) a ?
21:25:13 <edwardk> there is a third style that also is popular which is to name productions in some outer monad. i think frisbee did that?
21:25:23 * edwardk shrugs.
21:25:26 <mniip> well
21:25:35 <mniip> explicitly naming productions is one of the things I avoided
21:26:02 <edwardk> i don't really like either the explicit 'rec' or naming solutions
21:26:32 <mniip> well, whatever, it could use RT-breaking instead, not the main point here
21:26:33 <edwardk> one of the reasons i like haskell is that you _can_ use, say, data Conat = Z | S Conat       and define inf = S inf
21:26:35 <dmvianna_> Anyone knows of Oracle database support in latest stackage?
21:27:18 <edwardk> that is the one point compactification. rather than having to define data AlmostConat = Z | S !AlmostConat | Inf    and then relying on all sorts of laws to claim S Inf = Inf, etc.
21:27:30 <edwardk> and making sure nobody screws up the equality when inspecting values
21:28:17 <dfeuer> edwardk, doesn't relying on observable sharing risk all sorts of trouble if the optimizer doesn't like you?
21:28:18 <edwardk> knowing if you should use exp or 'rec exp' requires annoying global knowledge
21:28:43 <edwardk> dfeuer: observable sharing risks trouble in that if you have an infinite production it'll never terminate.
21:29:16 <edwardk> foo n = (:) <$> whatever n <*> foo (n + 1)
21:29:25 <dfeuer> edwardk, could one of those show up when it's not supposed to?
21:29:29 <edwardk> because the grammar actually does have an infinite number of states
21:29:57 <edwardk> no, i've not been able to get observable sharing to misfire the way you suggest
21:30:02 <mniip> why are you so fixed on recursion :(
21:30:48 <edwardk> mniip: because grammars get complicated
21:31:20 <mniip> I'm proposing something completely orthogonal to that?
21:31:49 <edwardk> anyways i was bringing it up because in the presence of truly infinite grammars the power of an applicative grammar is actually sufficient to parse any _context sensitive_ grammar, not just cfg
21:32:33 <edwardk> well context sensitive grammar over a finite alphabet
21:33:02 <mniip> is it decidable for a finite word?
21:33:12 <edwardk> http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html
21:34:34 <edwardk> you can basically produce a gigantic applicative tree with one branch for every expression parsed by the context sensitive grammar.
21:34:59 <edwardk> and the finite alphabet means that you only need a finite number of <|> nodes at each step
21:35:11 <edwardk> so its actually computable
21:37:14 <mniip> anyway!
21:37:17 <mniip> types!
21:37:32 <edwardk> if you charge consumed symbols and only recurse until you consume as many characters are in your input you can actually finitely elaborate a prefix of the infinite tree and parse with it, even without observing sharing, but the costs are absurd.
21:37:46 <edwardk> which is a fourth technique for producing such a grammar
21:37:59 <edwardk> or rather producing enough of it to parse whatever you're given
21:39:51 <edwardk> anyways, talk about the thing that is bugging you
21:40:11 <mniip> yeah well,
21:40:16 <mniip> I manly address the typing issue
21:41:07 <mniip> in applicative, each nonterminal needs to have a type, and each concatenation is associated with a function
21:41:24 <mniip> being in haskell, we obviously want it to be well-typed and whatnot
21:41:41 <mniip> and avoid resorting to Typeable
21:42:16 <edwardk> well, there are lots of 'Parser String' things you'll produce in most parsers. e.g. for producing identifiers, keywords...
21:42:32 <wowlad> haskell
21:42:33 <wowlad> haskell
21:42:33 <wowlad> haskell
21:42:33 <wowlad> haskell
21:42:38 <mniip> sure, but at some point it will be something else
21:42:42 <edwardk> you can say that every parser is uniquely identified by the carried type by convention, but applicative does nothing to enforce this
21:42:50 <mniip> nonono,
21:42:52 <mniip> the other way around
21:43:25 <edwardk> if you're trying to label productions by their type you're effectively just reinventing labels and shoving them to the type level by convention
21:43:26 <mniip> like, in "number ::= number digit | digit"
21:43:30 <mniip> digit :: Char
21:43:32 <mniip> number :: Int
21:43:55 <mniip> and the concatenation between number and digit is (\x y -> x * 10 + digitToInt y)
21:44:39 <edwardk> i'm just trying to say that there are lots of Parser Char's in say http://hackage.haskell.org/package/parsers-0.12.4/docs/Text-Parser-Token.html
21:45:33 <edwardk> my concern with your 'rec' is figuring out which thing you're recursing into
21:46:03 <mniip> well in reality rec has a label
21:46:15 <mniip> if you need to handle mutual recursion
21:46:17 <edwardk> and there it is. the necessary convention i was looking for
21:46:33 <edwardk> labels as strings or types or whatever
21:46:51 <mniip> well, 'Eq a' in this implementation
21:46:57 <edwardk> i was pushing observable sharing to avoid that
21:47:06 <mniip> sure, whatever
21:47:26 <edwardk> where is the 'a' for your Eq a chosen?
21:47:43 <mniip> at the use site of 'rec'
21:47:49 <mniip> the parser type is parameterized by it
21:47:52 <edwardk> does it show up in your parser type?
21:47:54 <edwardk> ah k
21:48:01 <edwardk> thats what i meant
21:48:38 <mniip> so, well
21:48:58 <edwardk> so your use of rec provides the convention that by scanning the applicative tree and stopping when you re-enter the same label you'll find the mappings from your labels to all sub-expressions
21:49:00 <edwardk> sure
21:49:05 <edwardk> easy enough
21:49:24 <mniip> uhh, no
21:49:33 <mniip> rec is only to break recursion
21:49:41 <edwardk> yes
21:50:37 <mniip> "if I am called with a list of labels that includes myself, then return a dummy value, else call the protected value with the passed list plus my own label"
21:50:44 <edwardk> what i'm talking about is how to do a 'visited set' style walk to find all 'named' productions. http://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html
21:51:16 <edwardk> the only ones that have to be named is at least one in each recursion
21:51:30 <edwardk> and i presume you handle many/some specially to avoid cluttering your namespaces
21:51:44 <mniip> but yeah, the labels in rec are not used anywhere other then in rec itself
21:52:18 <mniip> they aren't enough to describe the grammar of a parser either
21:52:37 <edwardk> that is one way to do it. another would be to do the preprocessing walk i described building the map of named productions to applicative sub-expressions.
21:53:01 <mniip> what I've done is, assign a unique (within a single Parser datum) identifier to each subpart of the parser
21:53:24 <edwardk> the applicative itself is almost a 2NF (with epsilon productions for (<$>) uses), so you can easily reconstruct a traditional grammar with your 'rec's in place.
21:53:41 <kock> I hate haskell
21:53:45 <kock> haskell is dumb poop
21:53:53 --- mode: ChanServ set +o edwardk
21:54:02 --- kick: kock was kicked by edwardk (kock)
21:54:02 --- mode: edwardk set +b kock!*@*
21:54:08 --- mode: edwardk set -o edwardk
21:54:19 <mniip> so yeah
21:54:24 <mniip> the fancy part is,
21:54:37 <mniip> the labels actually exist on the type level too,
21:54:53 <mniip> and there is a map from each label to the type of the respective part
21:55:19 <mniip> and the whole construction is strong enough to let me apply functions to values when reducing, without any kind of Typeable or unsafeCoerce
21:55:35 <edwardk> yeah that is the tricky part. you need to do that or use something like the vault trick
21:55:50 <mniip> well, only problem being "rec" because I can use the same label twice at different types
21:55:57 <edwardk> yep
21:56:19 --- mode: ChanServ set +o glguy
21:56:20 --- mode: glguy set +b-bo *!*@2601:181:8301:16fd:* kock!*@* glguy
21:56:22 <edwardk> this is the thing solved by the frisbee approach
21:57:04 <mniip> so yeah well
21:57:29 <edwardk> frisby style https://www.irccloud.com/pastebin/k3iwuww6/frisby.hs
21:57:30 <mniip> question is, is it worth to continue digging in that direction
21:57:56 <edwardk> ^- the above has the benefit that it avoids the 'trust me' rec declarations
21:58:22 <edwardk> at the cost of using 'newRule' to produce productions
21:58:37 <mniip> or is it a) useless b) well-studied c)
21:58:41 <mniip> s/c)//
21:59:17 <edwardk> well, i think the issue you're encountering is reasonably well understood by those of us who tried to do the same sort of thing.
21:59:28 <edwardk> i don't think there is a magic solution that makes 'rec' safe anywhere
22:00:00 <edwardk> the frisby style (which is the third solution i mentioned early on) avoids the rec safety issue
22:00:36 <edwardk> observable sharing risks undetected infinite recursion accidentally causing non-termination. frisby style avoids that as well
22:00:55 <mniip> anyway, if you want to take a look https://bpaste.net/show/ec86704cd663
22:01:09 <edwardk> the fourth technique (finite elaboration of an infinite grammar) relies on all recursion consuming input, so it also admits infinite spinning
22:01:40 <edwardk> the NAD total parsing combinator approach requires stylized recursion patterns, which makes me unhappy, but is provably correct
22:02:01 <edwardk> and avoids all these potential-spin-at-runtime problems
22:02:33 <dfeuer> edwardk, where can I read about this frisby style?
22:02:35 <edwardk> the reason i was hitting the recursion thing so hard is that space of four solutions are all i know
22:02:46 <edwardk> dfeuer: meacham probably has a post somewhere
22:02:53 <edwardk> or you can dig around in the frisby code
22:03:08 <edwardk> https://hackage.haskell.org/package/frisby
22:03:32 <dfeuer> Thanks.
22:03:53 <mniip> so you're saying a good recursion handling mechanism is the crucial missing part
22:03:56 <edwardk> mniip: one other option might be using static expressions
22:04:59 <edwardk> mniip: i haven't explored the 'static' option yet
22:05:22 <edwardk> https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/static-pointers.html
22:05:55 <edwardk> with static pointers you can make rec take a 'static exp' instead of an exp
22:05:58 <edwardk> then it can't go wrong
22:06:29 <edwardk> and it can't capture any of the environment in ways that cause the infinite recursion problems mentioned before
22:06:57 <edwardk> this wasn't a language feature back when i last tried this
22:08:29 <mniip> coming up with something useful that hasn't been thought of before is hard :(
22:08:46 <edwardk> yep
22:08:47 <mniip> anyway gotta run
22:08:51 <edwardk> later
22:09:36 <edwardk> another another option is to do all this production stuff at template haskell time
22:09:52 <edwardk> then you can actually 'type check' the grammar using custom TH
22:18:17 <bollu> if I'm writing a library, how do I share a "private" function between modules? I can't write it in a separate module, that will cause a cyclic dependency
22:19:52 <pavonia> bollu: Why is that cyclic?
22:20:56 <bollu> pavonia: because there is a module M1 which has the "f". there is also M2 which wants f. I can't split the f in a separate Minternal, since M1 will want Minternal (for f) and f wants M1 (for other things in M1)
22:21:08 <bollu> if I take the transitive closure of f's dependencies, it will want most of M1
22:21:16 <bollu> so I can't "split it out"
22:22:53 <pavonia> GHC can deal with cyclic modules to some extent
22:23:55 <bollu> really?
22:24:53 <pavonia> I can't find a good reference atm, but yes
22:32:53 <Rotaerk> bollu, why not put f and all the stuff it depends on into Minternal, then make M1 and M2 depned on that
22:38:10 <Dacto> So, ReadP_to_S returns a list of tuples, i dont understand the meaning the tuple's snd value.
22:39:52 <dfeuer> Dacto, the remainder of the string.
22:40:37 <Dacto> dfeuer: oh shoot.
22:40:50 <Dacto> thx
22:40:50 <dfeuer> So if you use   ReadP_to_S (whatever :: ReadP Integer) "1279 hello", you'll get [(1279, " hello")].
22:41:03 <dfeuer> Or something very much like that, anyway.
22:41:15 <Dacto> Yeah...i noticed that but didnt think it was so simple
22:41:18 <Dacto> Thx
22:42:57 <dfeuer> No problem.
22:56:45 <DemiMarie> I am trying to figure out how GHC optimizes toEnum . (someUArrayOfInts!)
22:57:19 <DemiMarie> to the same performance as \x -> case someUArrayOfInts!x of I# x -> tagToEnum# x :: Bool
22:57:41 <DemiMarie> note that someUArrayOfInts is known at compile-time
22:58:37 <DemiMarie> but I didn't think that GHC had the machinery to show that the bounds-check in toEnum would never fail
22:59:06 <DemiMarie> also, this is with -fasm, not -fllvm
22:59:13 <DemiMarie> GHC 8.0.1
23:10:53 <cocreature> DemiMarie: are you sure that the bounds check is actually getting eliminated? maybe it simply has no significant impact on the performance
23:14:19 <DemiMarie> true
23:14:57 <DemiMarie> on the other hand it would happen over 300 million times
23:15:27 <cocreature> have you tried dumping the core or stg?
23:21:46 <DemiMarie> I have tried dumping the core
23:22:10 <DemiMarie> cocreature: diffing is somewhat tricky because of the random-ish names GHC generates
23:22:55 <DemiMarie> but I can tell that toEnum got inlined
23:25:17 <ania123> does one know a page where I cann see haskel problems and its solutions?
23:25:48 <sophiag> hi. i'm just learning haskell and figured i'd try hacking together a prime sieve function to see if i'm getting the hang of things, but apparently not. can anyone tell me what i'm doing wrong here? http://lpaste.net/349701
23:25:59 <cocreature> ania123: https://github.com/NICTA/course/ has exercises and https://github.com/tonymorris/course has the answers
23:26:22 <cocreature> ania123: obviously you should try to solve the exercises without looking at the answers :)
23:26:44 <glguy> adventofcode.com is up again this year and has a bunch of little things to implement
23:29:09 <ania123> cocreature: https://github.com/tonymorris/course
23:29:19 <ania123> I do not see problems there
23:29:27 <ania123> in whhich dir it is?
23:29:56 <cocreature> https://github.com/NICTA/course/tree/master/src/Course
23:30:17 <cocreature> https://github.com/NICTA/course#progression lists the recommended order
23:31:30 <ania123> I need some interesting problems :(
23:31:35 <ania123> what the hall it is :)
23:32:27 <cocreature> I just gave you a link to problems. I don’t know what you find interesting so I can’t help you more
23:51:36 <NextHendrix> my list comprehension is getting stuck, mental block what am i missing
23:51:42 <NextHendrix> primes = 2 : [x | x <- [3,5..], y <- primes, rem x y /= 0]
23:52:08 <NextHendrix> sticks at [2,3,
23:57:00 <sophiag> NextHendrix: oh, about my question?
23:57:09 <sophiag> i realized i wasn't tested for all the primes, yeah
23:58:05 <sophiag> i tried something like this: http://lpaste.net/349701
23:58:13 <sophiag> still not getting it :/
23:58:59 <NextHendrix> sophiag: lol no this is my question, ill have a look at yours though
23:59:07 <sophiag> ha
23:59:11 <sophiag> same i think
23:59:12 <cocreature> NextHendrix: are you sure you’re getting 3? it’s stuck after 2 for me which seems to make sense
23:59:17 <NextHendrix> sophiag: 3 is prime so theres that
23:59:30 <nshepperd> NextHendrix: you probably want a takeWhile somewhere in there so that you only check the primes that are less than your number
23:59:31 <sophiag> oh, yeah, my list is wrong
23:59:34 <NextHendrix> cocreature: take 5 primes give [2,3,endlesswait
23:59:53 <cocreature> hm I don’t get why you would see 3
