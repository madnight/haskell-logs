00:15:54 <superlinux> hello
00:16:27 <superlinux> how can I resume the download of "stack new myproject"?
00:19:25 <cocreature> superlinux: I don’t think you can resume it, you need to remove the "myproject" directory and run it again
00:19:42 <cocreature> the download should be relatively small iirc
00:19:47 <cocreature> I think it only downloads the template
00:20:56 <superlinux> cocreature, looks like I must buy a UPS for my modem. I live in Beirut. power cut off is very frequent
00:21:00 <MarcelineVQ> it'll download a package index if you need it which can be a bit sizeable, I'm not sure if that resumes on its own
00:21:47 <cocreature> ah right, I forgot about the package index
00:21:56 <superlinux> git is already slow in downloading. i wish it can do multithreaded download
00:23:41 <superlinux> cocreature, i am still in the step "Updating package index Hackage " and I cannot advance to the next step
00:24:11 <cocreature> superlinux: sorry not sure what you can do about that
00:24:54 <superlinux> it says : Updating package index Hackage (mirrored at https://github.com/commercialhaskell/all-cabal-hashes.git) ... Running /usr/bin/git clone https://github.com/commercialhaskell/all-cabal-hashes.git all-cabal-hashes/ -b display in directory /root/.stack/indices/Hackage/git-update/ exited with ExitFailure 128
00:25:19 <superlinux> the failure was because I was disconnected
00:34:01 <MarcelineVQ> superlinux: you might be able to work around it by having someone send you their .stack/indices folder in a resumable form but eventually it'll need to update them again so you may just end up with the same problem. you may want to stick with cabal-install, recent version of cabal have `cabal new-build` which may be appropriate for you, I'm not sure http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
00:34:40 <ezyang> MarcelineVQ: To be fair, "cabal update" also takes a long time on bad connections 
00:34:49 <ezyang> it's a little better in that it's not Git though ^^ 
00:34:54 <MarcelineVQ> That's the part I wasn't sure about :(
00:35:14 * ezyang knows from personal experience on some crappy Japan internet 
00:35:18 <MarcelineVQ> the root issue is that git clone isn't resumable, or at least nothing I've found shows it to be
00:35:19 <ezyang> at ICFP 
00:37:24 <cocreature> can "cabal update" resume partial downloads?
00:37:32 <ezyang> Yeah 
00:37:35 <cocreature> nice
00:37:48 <ezyang> because your "current index" is actually just this monotonically increasing file 
00:37:55 <ezyang> subsequent cabal updates are just slapping more data on the end 
00:38:28 <ezyang> BUT we don't have any tests for this so I wouldn't rely on it haha 
00:41:11 <Lokathor> can a MonadIO instance ever not also be a Functor?
00:43:46 <ThawedFox> Hello world. What does 'filterPrimes' on haskell.org compile down to? [2..] -> emit 2, filter (x `mod` p /= 0) -> emit 3, filter ...; Each element must be compared against every previous result. If this were C... How would this look?
00:44:59 <EvanR> Lokathor: MonadIO instances are Monads so
00:45:02 <MarcelineVQ> Lokathor: A MionadIO is a Monad is an Applicative is a Functor
00:45:04 <MarcelineVQ> oop
00:45:09 <Lokathor> yeah
00:45:34 <superlinux> MarcelineVQ, thanks. I'll stick to the normal way
00:45:34 <Lokathor> the sdl2 docs has a func, createTexture :: :: (Functor m, MonadIO m) => ...
00:46:06 <EvanR> goofy
00:46:37 <MarcelineVQ> possibly pre-AMP signature? depends how old MonadIO is
00:46:40 <Gurkenglas> Hmm https://en.wikipedia.org/wiki/Blocks_(C_language_extension) sounds like it should allow infinite single-linked lists so we could do a 1:1 translation of filterPrime :P
00:47:03 <Lokathor> MarcelineVQ, nope, sdl2 got a big ground-up rewrite that was post AMP
00:47:58 <MarcelineVQ> could have been habbit, dunno :>
00:48:02 <ThawedFox> Does Haskell chew into the stack to resolve 'primes' ? Conditional per iteration doesn't fit TCO, does it?
00:48:32 <ThawedFox> Rather, per depth in the stream
00:50:15 <EvanR> ThawedFox: TCO doesnt really apply, and you can easily do a conditional per iteration with constant space
00:51:24 <ThawedFox> EvanR: Yeah; as I expected. I corrected myself to 'per depth' as per this example
00:52:20 <ThawedFox> So.. the `primes` on haskell.org will eat into the stack until out of stack?
00:52:38 <EvanR> nope
00:52:50 <ThawedFox> Good; but how?
00:53:17 <EvanR> there is no stack *mystical soundtrack plays*
00:53:38 <ThawedFox> Heap for many lambdas? :P
00:54:03 <EvanR> that example is a good exercise to evaluate by hand
00:54:35 <EvanR> evaluate filterPrime [2..] to WHNF
00:54:46 <ThawedFox> WHNF?
00:55:38 <EvanR> weak head normal form. haskell is lazy and you dont evaluate more than necessary
00:55:47 <EvanR> so thats the basic unit of evaluation
00:56:10 <EvanR> expression is in WHNF if its a constructor or a lambda. but in the above, its a function application
00:56:25 <EvanR> so you need to do something
00:56:55 <ThawedFox> EvanR: I know how it'll evaluate. Pull the 2 off the set [2..]; emit it and filter it with a new generator; where only one element is pulled from at a time - which goes through every depth from the initial [2..] to many filters.
00:57:33 <EvanR> well you can literally write it out, which suggests what kind of memory its going to use
00:57:40 <ThawedFox> The question is how would it compile to? Linked-list of lambdas getting called?
00:58:22 <EvanR> i think its more instructive to understand how it evaluates first, because how stuff eventually compiles is not necessarily anything like that
00:58:36 <EvanR> filterPrimes [2..], to WHNF
00:59:23 <EvanR> 2 : filterPrime [x | x <- [3..], x `mod` 2 /= 0]
00:59:38 <EvanR> ok
01:00:22 <EvanR> if i am a terminal, i can show the 2, and continue with the rest of the list
01:00:34 <EvanR> filterPrime [x | x <- [3..], x `mod` 2 /= 0], evaluate this to WHNF
01:01:07 <ThawedFox> I do understand how it evaluates. I do know Haskell. I just noticed this code and it got me thinking about how to implement it in another language. So, how it would compile down to. As an infinite iterator, yielding and filtering at each depth; it needs to keep track of all elements it's omited and check against them. Either resolving and continuing down to the next filters and eventually to where the 
01:01:12 <ThawedFox> prime is used, or skipping the element and going back to the first iterator and back down in depth
01:03:46 <EvanR> so the next iteration is going to be passed a lazy list based on the passed in list
01:04:09 <EvanR> and at this point, theres going to be sharing going on
01:05:03 <EvanR> theres only ever one original list, but the filters for each prime will keep piling up
01:05:16 <EvanR> one for each prime
01:05:31 <ThawedFox> filterPrime [ x | x <- [5..], x `mod` 2 /= 0, x `mod` 3 /= 0, x `mod` 5 /= 0 ]
01:05:34 <ThawedFox> Right
01:06:49 <EvanR> to do it in another language, you could keep a list of primes as a state
01:07:16 <EvanR> and see if any of them divide the current number, short circuiting if it does
01:08:20 <ThawedFox> And iterate over those until the filter fails, then go to the next and so on. In this case we've got a list of numbers. Not lambdas. Which is cheaper; but we need to preallocate the space, or allocate and move it, or construct a linked list of N elements and grow as needed.
01:08:58 <EvanR> well, the costs of doing any of this depends heavily on the choices made for you for all time by language implementors
01:09:22 <EvanR> lambdas are not expensive in haskell
01:10:00 <EvanR> individual numbers might be even more expensive than them in ruby for instance
01:10:01 <ThawedFox> So what does Haskell do here? It can't set an upper bound for a list unless you've got 'take N' to bound it; which won't work with `!! 5000` 
01:10:31 <EvanR> what do you want to do? take 5000 of them?
01:10:37 <EvanR> or show the 5000th or
01:11:19 <ThawedFox> That was an example; 5k is easy to preallocate a list of primes; while 5000th is ... okay bad example; that can be preallocated too :P
01:11:26 <EvanR> huh?
01:11:57 <EvanR> what does haskell do when what, i mean it could stop at 2:filterPrimes [all that], 
01:12:19 <EvanR> whats the scenario
01:13:31 <ThawedFox> I wanted a non-bounded example. Both take 5k and 5k-th are bounded. Lets just iterate until the N-th element (conditionally checked to be equal to a known value). 
01:14:07 <EvanR> so show all the primes until N?
01:14:13 <ThawedFox> Like takeWhile (/= 499)
01:14:13 <EvanR> show first N primes
01:14:35 <EvanR> ok, that gives you a finite list (not necessarily evaluated yet)
01:14:58 <ThawedFox> Note /=, not <; so not bounded in length. (Though maybe the compiler can know the difference and detect that... lets just say it can't)
01:15:21 <EvanR> that would definitely bound the list in length
01:15:29 <EvanR> itll stop at 499
01:15:48 <ThawedFox> Well yes; but the length of primes is unknown.
01:16:04 <EvanR> it doesnt care
01:16:34 <ThawedFox> Neither that program, or the compiler know the length of such an output list. So it can't preallocate an array to populate with the primes. 
01:16:35 <EvanR> it will do a check for 499 each time you consume an item, and we know itll stop at 499
01:16:45 <ThawedFox> Right
01:16:50 <EvanR> no it will not preallocate anything, its lazy
01:17:19 <EvanR> but you can do it manually by converting that takeWhile (/=499) list into a vector
01:17:21 <ThawedFox> Exactly. So where does it store all the primes that it mod's against each round?
01:17:32 <EvanR> those pile up as filters
01:18:05 <EvanR> @src filter
01:18:05 <lambdabot> filter _ []     = []
01:18:05 <lambdabot> filter p (x:xs)
01:18:05 <lambdabot>     | p x       = x : filter p xs
01:18:05 <lambdabot>     | otherwise = filter p xs
01:18:18 <EvanR> so something similar to the filterPrimes expression
01:18:23 <EvanR> one for each prime
01:18:40 <ThawedFox> I know... I mean, where do we store those such filters? A linked list of 'next filter', falling back to the initial generator pointing to the first filter,  and so on?
01:19:07 <EvanR> itll be an expanding graph of "app nodes"
01:19:55 <ThawedFox> app nodes?
01:20:14 <EvanR> right, like if you just stop at 2 : filterPrimes [...], that looks like
01:20:37 <EvanR> constructor(:) 2 (app <filterPrimes> [...])
01:21:00 <ThawedFox> So Haskell would implement this as a linked list if unbounded; and may optimize to a fixed-size array if it knows the upper bound?
01:21:05 <EvanR> think of an object with three fields
01:21:20 <EvanR> the third field points to an app node, which has two fields, the function and the argument
01:21:56 <EvanR> it never compiles any lists to an array as far as i know, that wouldnt work
01:22:10 <ThawedFox> Okay
01:22:15 <EvanR> however a linked list of filters is exactly what you want here
01:22:45 <ThawedFox> As I initially expected. Except I misspoke in saying stack instead of on the heap.
01:22:55 <ThawedFox> Yay GC langauges working on heaps.. :P
01:23:02 <EvanR> yes if it was a call stack... wed be in trouble
01:23:12 <ThawedFox> Right
01:23:55 <ThawedFox> EvanR: Thank you for confirming my expectation (and correcting that "minor" detail) and sorry for the miscommunication issues.
02:01:13 <gameer> Hey guys, I have a short question. When I want to calculate ^2. Why is (^)2 wrong and (^2) correct?
02:02:08 <gameer> Task was to take a number and the result should be a List with [number+1,numer*2,number^2] :   calculateIt x = map ($x) [(+)1,(*)2,(^)2]
02:02:26 <Liskni_si> (^)2 is (2^) not (^2)
02:02:46 <gameer> Ah okay, thanks
02:03:07 <gameer> So simple :D
02:12:55 <ocramz> hullo!
02:21:23 <ocramz> I'd like to simulate random walks; the semantics of the program are: get the previous state, generate a random number, produce the new state using the previous state and the random number. This AFAICT requires a monad transformer. Since the random generator draws from IO, we should `lift` the r.g. action, so this would give us `StatT a (Prob m) a`. I am using `mwc-probability`, so one typical state transition would look like : `ft1 f =
02:21:23 <ocramz> do { x <- get; w <- normal 0 1; let y = f x w; put y; return y}`
02:21:44 <ocramz> oops I mean `w <- lift $ normal 0 1`
02:23:39 <ocramz> I'm puzzled on what's the correct execution though; sampling and state transformation should be interleaved
02:25:25 <ThawedFox> ocramz: FWIW: You can use a pseudorandom source and avoid I/O
02:26:25 <ThawedFox> If seeded; it also allows you to replay / debug significantly easier.
02:29:52 <ocramz> ThawedFox : it's not the presence of IO that bugs me (in fact the PRNG runs in PrimMonad), but I'd like to understand how to thread these two computations together in general
02:31:33 <ij> I want to make a monad that'd capture all the returns and all the liftIOs, save them in a list inside it and then execute them, BUT the returns would be put inside an STM's atomically and could access state while the liftIOs wouldn't. Does this sound doable?
02:32:03 <ThawedFox> ocramz: Sure; and for that I don't personally have any suggestions. It's been a while since I really played with Haskell. My suggestion was just a general tip (and *that* PRNG may run in PrimMonad, but a PRNG could be a simple state you pass around)
02:33:14 <Lokathor> > using 'fromIntegral' is the programmer's way of saying 'come on you know what I mean GHC just do it already'.
02:33:17 <lambdabot>  <hint>:1:46: error: parse error on input ‘of’
02:36:20 <lyxia> ij: return is not supposed to have any effect
02:36:30 <lyxia> ij: and something similar applies to liftIO
02:37:23 <Lokathor> ij, do you want to capture the returns of some OTHER monad than the one you're making?
02:42:33 <ij> I've a TVar and I want to hide away read/write and have its value in state, so I could lens with it.
02:45:51 <ij> That would require me to do some IO in the middle of STM, so I can't do that.
02:54:24 <paolino> hello, is it possible to execute the same arbitrary test twice, so I can crosscheck 2 implementations ? 
02:54:51 <paolino> with QuickCheck
03:01:28 <xocolatl> I'm having trouble understanding how  f x = x + x  is the same as  join (+)
03:01:34 <xocolatl> is Num a monad?
03:02:15 <cocreature> xocolatl: no, (a ->) is a monad
03:02:29 <cocreature> :t join
03:02:30 <lambdabot> Monad m => m (m a) -> m a
03:02:37 <cocreature> now substitute (b ->) for m
03:02:47 <cocreature> and you end up with b -> (b -> a) -> b -> a
03:03:05 <cocreature> eh (b -> (b -> a)) -> b -> a
03:04:09 <xocolatl> hmm
03:04:11 <paolino> :t join (+)
03:04:13 <lambdabot> Num a => a -> a
03:04:24 <xocolatl> makes sense, but I'll need to let it sink in
03:05:14 <cocreature> xocolatl: I don’t think there is a lot of knowledge to be found here, you just need to work through the implementation of join in terms of >>= and look at the implementation of >>= for (a ->)
03:05:47 <xocolatl> can lambdabot give me the definition?
03:06:07 <cocreature> dunno, but the haddocks can https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-645 :)
03:07:24 <cocreature> xocolatl: implementing join in terms of >>= is a nice exercise so you might want to try that yourself. if you get stuck I can ofc help you with it
03:07:37 <xocolatl> I'll try
03:07:47 <cocreature> you can just play type tetris
03:09:42 <xocolatl> not too sure where to start :(
03:09:50 <cocreature> xocolatl: alright, let’s look at the types
03:09:52 <cocreature> :t join
03:09:53 <lambdabot> Monad m => m (m a) -> m a
03:09:53 <cocreature> :t (>>=)
03:09:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:10:09 <xocolatl> so far so good :)
03:10:31 <cocreature> cool, so we want to implement join
03:10:41 <cocreature> that means we are given an m (m a)
03:11:02 <cocreature> >>= takes an "m a"
03:11:11 <cocreature> but >>= works for all a s!
03:11:20 <cocreature> so we can just set a = m a'
03:11:30 <cocreature> does that make sense?
03:11:53 <xocolatl> no
03:12:23 <xocolatl> yes
03:12:27 <geekosaur> might help to rename some type variables there
03:12:32 <cocreature> yeah I realized that halfway
03:13:12 <cocreature> so let’s go with "join :: Monad m => m (m a') -> m a'
03:13:14 <cocreature> "
03:13:25 <cocreature> then that probably makes more sense
03:14:07 <xocolatl> so bind is getting  m a'
03:14:20 <xocolatl> which is  m (m a)
03:14:40 <gameer> Is it correct, that !! gives me the Position of a value in an array? I'm to stupid to find !! via google
03:14:59 <cocreature> xocolatl: you switched a and a' compared to what I wrote, but these names don’t matter, so yes
03:15:37 <geekosaur> gameer, they're lists not arrays. (this matters; they are singly linked lists. !! is *slow*)
03:15:43 <geekosaur> but, yes
03:15:43 <cocreature> xocolatl: so what’s the type we get after applying >>= to our m (m a)?
03:15:56 <gameer> oh sorry, my fault. Ofc list
03:15:58 <geekosaur> there is an actual Array type, and ! is the equivalent operator for them
03:16:08 <gameer> geekosaur: thanks :)
03:16:23 <cocreature> gameer: you can use hoogle to search for these operators http://hoogle.haskell.org/?hoogle=(!!)
03:16:25 <geekosaur> there is also a Vector type, which is better for many things than Array
03:16:54 <gameer> cocreature: Oh cool, thanks
03:17:17 <xocolatl> cocreature: (>>=) m (m a) :: (m a -> m b) -> m b  ?
03:18:14 <cocreature> xocolatl: the type is correct, but you are mixing up terms and types on the left side. you apply >>= to an expression (e :: m (m a)) not to m (m a)
03:18:38 <xocolatl> okay
03:18:47 <cocreature> xocolatl: anyway, now you can still chose what you want b to be. any ideas what you can chose here to get an "m a" out like join requires you to?
03:20:07 <xocolatl> just "a", no?
03:20:11 <cocreature> yes!
03:20:30 <cocreature> xocolatl: so now you need to find a function of type "m a -> m a" that you can pass to >>=, any ideas?
03:20:37 <xocolatl> id?
03:20:43 <cocreature> exactly, you got it!
03:20:48 <cocreature> :t \x -> x >>= id
03:20:50 <lambdabot> Monad m => m (m b) -> m b
03:21:00 <xocolatl> and that's join
03:21:03 <cocreature> yep
03:24:00 <xocolatl> I'm trying to see how  join (+)  fits in here
03:24:41 <cocreature> xocolatl: start by rewriting "join (+)" as "(+) >>= id", then substitute the definition of >>=
03:24:44 <Draznel> hey guys. I have a problem, could someone help me? I have to write a certain function, and I have done that, but not in a way I would like it to be. More info here: http://pastebin.com/JuYRh8yt   Basically I wrote a total bruteforce way of solving this problem, but I think there must be a better way to do so.
03:25:47 <Draznel> What I did was convert the map to list, and have a binary bruteforce by using all possible combinations to find the solution. But that's way too brutal :D
03:26:57 <aidecoe> I have 1: RWS A B X () and 2: RWS A B Y (). Is it possible to transfer state of Writer in monad 1 to monad 2 within monad 1?
03:27:49 <aidecoe> i mean in a bit more elegant when rather then executing monad 2, passing everything and appending results back to monad 1
03:30:28 <Draznel> can anyone help me? :) I repasted the code to lpaste: http://lpaste.net/350109
03:31:23 <geekosaur> aidecoe, not with RWS. if you used the separate monad transformers, there is mapWriter
03:31:51 <geekosaur> (or mapWriterT)
03:34:03 <c_wraith> Draznel: when the change-making problem is generalized to cases where greediness doesn't work, like you have there, it's possible to use dynamic programming
03:34:30 * geekosaur should not be up now, sigh.
03:34:51 <c_wraith> hmm.  despite the way the text looks, that's not a change-making problem.
03:34:56 <c_wraith> that's a subset-sum problem
03:35:01 <aidecoe> geekosaur: maybe i should use transformers then. Thanks.
03:36:07 <Draznel> don't know much about dynamic programming. What would be possible in for example java, is to have a recursive method which would recurse several times in each iteration. For example go deeper in to the solution tree with map without one of the 50 coins and with amount -50 that current. Then, if the solution was not found. Do the same, but with a smaller value, like 20. and so on
03:36:39 <c_wraith> you can still do dynamic programming with the subset-sum problem..  But the worst case runtime for all known algorithms will be exponential
03:38:59 <c_wraith> Draznel: you can get clever with bounding the search, but in the end you'll still be doing a backtracking search
03:39:38 <Profpatsch> lyxia: Thanks, do you know whether there is a library that can do a real “besides”?
03:40:05 <c_wraith> Draznel: you can do cute things to organize the code though:  https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet
03:40:35 <c_wraith> Draznel: while that's a somewhat different problem, the solution technique will work for your problem too
03:40:49 <Draznel> but wouldn't that be a bruteforce method?
03:41:30 <c_wraith> it's the subset-sum problem.  all known methods are brute force.
03:45:01 <Draznel> I was wondering, is there a way to implement such function in haskell? http://lpaste.net/350110
03:45:52 <Draznel> I think it's possible, but I don't know how that for loop with a possible return could be implemented
03:50:30 <ij> I want to improve this code: http://sprunge.us/Qgab I just realized I only use a single TVar, so this code could be simpler. # But I could also make getTVar/setTVar into "useMyState f" = atomically { runStateT (initial TVar value) f, saving the final State and returning the final Value } # So that I can play with lens inside because of state. # Does this sound good?
03:56:20 <geekosaur> Draznel, it can be done in several ways, none of them especially friendly. one is to use a fold with a Maybe resultType in the state and short-circuit when that is Just. another, decidedly more baroque, is to use continuations (Cont monad)
03:57:05 <Cale> I was going to say it's pretty simple. You just use recursion to handle the loop.
03:57:09 <geekosaur> continuations would allow you to actually stop early instead of just short-circuiting iterations, but make the logic considerably harder to follow
03:57:47 <geekosaur> and yes, it does look like this particular one can be done with recursion that bottoms out early
04:03:04 <Profpatsch> Can I fork/exec from a Haskell program?
04:03:32 <Profpatsch> Or better: Just exec.
04:03:37 <ij> Yeah. https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Process.html
04:03:51 <Profpatsch> ij: There’s no exec function.
04:04:01 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/350110#a350111
04:04:03 <Profpatsch> Or is executeFile it?
04:04:08 <ij> executeFile yeah.
04:04:14 <Cale> Draznel: ^^ see paste
04:04:22 <ij> Profpatsch, There's also more high-level functions in System.Process.
04:04:28 <Profpatsch> ij: Oh, cool.
04:05:35 <Cale> Draznel: There's stuff which could be done to further tighten that up, but I tried to keep the program close to the imperative one as far as thought process goes :)
04:05:52 <Draznel> ok. will check the paste
04:06:44 <Cale> Draznel: makeChange' basically computes the result of the program from the point of control at the for loop.
04:07:05 <Cale> Draznel: and it takes the list of values left to iterate over as an argument
04:07:51 <Cale> I don't actually think the first line of makeChange' which handles the amount = 0 case is actually necessary, but I included it anyway
04:08:04 <Cale> (the reason is that makeChange itself handles that case)
04:20:29 <Draznel> Cale: Thank you a lot! It works like a charm!
04:46:08 <ph88> hi guys, i was reading this http://www.aosabook.org/en/ghc.html under the chapter "no symbol table" it is described that the symbol information is captured in the AST instead of a separate table. But i wonder how can information higher up in the tree be accessed while parsing the source code? I need information which was defined earlier to know which node should be created in the AST. Can anyone shed some light on this ?
04:48:06 <geekosaur> ph88, have you ever noticed that haskell usually does not care what order you define things in? (Template Haskell being a necessary exception)
04:48:21 <geekosaur> there is no "defined earlier"
04:48:46 <geekosaur> it builds the AST, then goes over it and fixes up references
04:48:54 <ph88> geekosaur, ok but i'm not parsing haskell code .. does that mean i can't use this technique ?
04:48:59 <geekosaur> (this leads to some "fun" when dealing with fixity)
04:50:03 <ph88> maybe parsing haskell is not sensitive on context ?
04:50:25 <geekosaur> you might be able to do it. it does have some complexities, like the one I just mentioned --- in effect, if it has not seen the definition of an operator yet, it has to put a dummy into the AST and replace with the real subtree once it has learned the operator's fixity
04:50:45 <ph88> i have stuff like    foo(1);   where foo can be either a function call or indexing an array
04:51:18 <geekosaur> there are ways to do that. but you need to consider the tradeoffs involved
04:51:50 <ph88> so either the array and/or the function   foo   was defined earlier in the source code. That's why i need to "look back" to figure out whether i should create a node for a function call or a node for array indexing at that point
04:52:35 <geekosaur> there is also supporting () as a postcircumfix operator, and then having that operator determine at runtime whether to dispatch to array indexing or function call based on its left operand
04:52:46 <ph88> i can not construct the AST fully with all references resolved
04:53:11 <geekosaur> ...and I guess all that stuff I said about fixity meant nothing and was ignored. ok
04:53:22 <ph88> eh i mean .. i can not construct the AST on-the-go without looking back while resolving all references
04:54:18 <ph88> it was late yesterday, my brain lags a few minutes behind :P
04:54:42 <geekosaur> I have to admit I am wondering if you have bitten off more than you can chew...
04:55:15 <ph88> it's new territory :P
04:55:24 <geekosaur> you can define a language such that all references can be resolved when parsed, but in that case you must have the references declared before their uses are parsed
04:55:36 <ph88> i'm betting on time & perseverance
04:55:49 <geekosaur> if you want to not require ordering like that, then you need to resolve references in a later pass, either over the source or over the AST
04:56:28 <geekosaur> you can't have both, unless your parser has a built-in time machine
04:56:29 <ph88> i'm pretty sure the language is defined in such a way that the references must be declared before their uses ! 
04:57:05 <ph88> let's say it does require ordering like that
04:57:49 <geekosaur> ok, so in that case you want to store the refernces in a lookup table / symbol table; you don't want to try to extract it from the tree *while* parsing, because that requires holding an extra reference to the tree and that will complicate building the tree (for the garbage collector, at least)
04:58:01 <geekosaur> and done wrong could introduce some horrendous space leaks
04:58:02 <ph88> if i would work with a symbol table then i could but that as my state variable .. but if i want to keep stuff in the AST tree then how can i look at nodes higher in the tree which were already created ?
04:58:26 <ph88> alright sounds like good advice
04:58:33 <geekosaur> ghc does it by making one pass over the source to build a provisional AST, then additional passes over the AST filling in information
04:58:54 <ph88> sounds very slow :P
04:59:12 <geekosaur> (the Commentary on the GHC Trac wiki might be of interest, if you want to see how ghc does these things)
04:59:39 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary
05:00:40 <geekosaur> but, Haskell is a language where the designers chose to torment the implementors instead of the users --- it requires you to do the multipass stuff so the user can define things in whatever order is most convenient (or most logical to them / the use case, or whatever)
05:01:38 <geekosaur> if you have a simpler language where you always know how to resolve e.g. postcircumfixes, then you should use that information while building the AST
05:02:01 <grantwu> Heh I like that
05:02:05 <ph88> so that multiple pass algo would look something like:  for all unresolved nodes: for all references: match node with reference  .. you can see that this will be a lot of passes
05:02:27 <grantwu> "decided to torment the implementors instead of the users"
05:02:43 <grantwu> For what it's worth, depending on your parsing strategy
05:03:11 <grantwu> Requiring declaration before use can actually be more annoying than some alternatives
05:03:38 <geekosaur> depends on how you built the AST. instead of a symbol table, you can keep a "hole table" of things that need to be filled in as you build the AST, then a second pass to collect the information for the holes, then a third pass to fill them in
05:04:02 <grantwu> It makes certain things stateful/serial
05:04:23 <ph88> interesting idea
05:04:26 <grantwu> I'm not completely sure of the context here though
05:04:39 <ph88> have you seen such a "hole table" used somewhere or it's a fresh idea ?
05:04:49 <geekosaur> (or even remove one of those passes, since the hole table knows what is missing so you can fill that into the hole table as you complete the parse, then only need the pass to patch the AST according to the hole table)
05:05:42 <geekosaur> I am pretty sure I saw that technique, in Haskell, in an example parser
05:05:54 <geekosaur> might have even been parsing (a subset of?) Haskell
05:05:56 <ph88> another concern was that without symbol table information gets duplicated a lot. In case you have a variable used twice and you put the info in the AST then you need the same info in both places
05:06:41 <geekosaur> mm, not actually an issue with Haskell, since you have bindings --- which, not being updatable, are simpler to track
05:07:26 <ph88> yeah i just thought memory increase a lot .. but maybe it's not that much actually
05:08:04 <geekosaur> well, if you do it right, you can be inserting lazy references. (I think I've seen that done somewhere too. Possibly in a discussion of ghc internals)
05:08:24 <ph88> aaaahh
05:08:35 <geekosaur> "tying the knot" type stuff, although that can be rather tricky in practice
05:08:42 <ph88> that's pretty crazy :P
05:09:45 <ij> Is *> == >> for IO?
05:10:27 <ph88> i was thinking a possible downside of a symbol table is that it needs scope, so i need a symbol table hierarchy .. which then is a different structure than the AST. I mean you have your symbol table tree and your syntax tree .. and you can not map them onto each other. That's why i saw storing stuff in the AST itself as a major benefit
05:10:40 * geekosaur .. had "fun" parsing that question...
05:10:59 <geekosaur> ph88, hint: ReaderT, local
05:11:35 <ph88> thanks for the help
05:11:49 <ph88> i will think about it some more before starting implementation
05:12:57 <geekosaur> but again, you may not be able to use local when you have actual variables. bindings, once out of scope you don't care.
05:17:28 <geekosaur> that said, I wouldn't waste a lot of time trying to come up with clever ways to do things or picking over 50+ years of parser development for tricks. sometimes simple is best, especially for a simple language
05:20:34 <matrium> hi, can I somehow parse CSV data using cassava without mapping it to a specific model? my use case is that I have a set of CSV files with different columns. but each file has a "timestamp" column. I now want to write a program, that creates me filtered csv files, based on a specific timestamp range
05:32:13 <Boomerang> matrium: From the cassava documentation "Treating CSV data as opaque byte strings", if your timestamp is in the first column yo could do something along the line of: decode NoHeader "1234,John,27\r\n5678,Jane,28\r\n" :: Either String (Timestamp, Vector (Vector ByteString)), then you filter on timestamp and reencode it.
05:34:08 <matrium> Boomerang: unfotunately, it's in the last. but I will have a look at the "Treating CSV data as opaque byte strings"
05:34:24 <Boomerang> actually that probably wouldn't work, you might have to parse the whole thing as a Vector ByteString and then decode the relevant ByteString manually
05:34:57 <Boomerang> I don't cassava could decode as a mix of a tuple and a vector anyway. If you know the index it should be fine though
05:35:51 <Boomerang> Well if it's the last element you could just use last form Data.Vector :)
05:43:47 <geekosaur> oh, grantwu? while I've been saying things like that about Haskell for years, that particular formulation of it is by Larry Wall
05:44:19 <effectfu1> Where does stack hide ghc? I'm using stack normally, but now I wrote a simple program which I want to just compile and run without bothering with stack projects
05:44:28 <effectfu1> but ghc is not on my path
05:44:36 <grantwu> stack exec -- ghc
05:44:41 <grantwu> I think that should work
05:45:00 <geekosaur> somewhere under ~/.stack-work, you can use stack paths if you must --- but "stack exec" is better
05:45:05 <effectfu1> grantwu: seems to work, thank you
05:45:12 <grantwu> geekosaur: well, I haven't been around for years
05:45:23 <geekosaur> also, uh, don't install stuff into that ghc's package db unless you want to confuse stack
05:51:15 <ShalokShalom> hi there
05:51:49 <ShalokShalom> Haskell provides full Qt5 support?
05:54:45 <ongy> ShalokShalom: https://wiki.haskell.org/Applications_and_libraries/GUI_libraries#Qtah you may want to take a look at the 2 things here. But I haven't used either
05:54:56 <ShalokShalom> yeah, i already see that one
05:55:45 <ShalokShalom> the german wiki page of Qt lists qtHaskell
05:55:56 <ShalokShalom> is that one replaced by Qtah?
05:56:18 <ShalokShalom> Ah and HsQML is also there..
06:00:35 <zoran119> is there a way for me to tweak readMaybe to be able to read a list without the square brackets? or use something else instead of readMaybe?
06:01:10 <zoran119> i'd like to read a list of Int from user input at the prompt (that's the end goal)
06:01:21 <zoran119> any suggestions welcome :)
06:02:44 <Boomerang> zoran119: Is the list comma separated?
06:03:03 <ongy> zoran119: I'd probably try to make my own with readInt and unfoldr, that uses ByteString instead of String though
06:04:47 <Boomerang> If the list is comma separated and all you're missing is brackets you could do: readMaybe ("[" ++ input ++ "]")
06:05:10 <zoran119> Boomerang: yes
06:05:59 <zoran119> Boomerang: or space
06:06:00 <Eduard_Munteanu> :t split
06:06:02 <lambdabot> Splitter a -> [a] -> [[a]]
06:06:18 <Eduard_Munteanu> Bleh.
06:06:33 <Boomerang> Then a proper implementation like ongy suggested is better :)
06:06:37 <Eduard_Munteanu> :t Data.Text.split
06:06:38 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
06:06:45 <Eduard_Munteanu> :t Data.Text.splitOn
06:06:48 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
06:07:27 <Eduard_Munteanu> :t catMaybes . map readMaybe . Data.Text.splitOn ","
06:07:29 <lambdabot> error:
06:07:29 <lambdabot>     Variable not in scope:
06:07:29 <lambdabot>       readMaybe :: Data.Text.Internal.Text -> Maybe a
06:11:28 <ongy> :t mapMaybes
06:11:29 <lambdabot> error:
06:11:29 <lambdabot>     • Variable not in scope: mapMaybes
06:11:29 <lambdabot>     • Perhaps you meant one of these:
06:11:31 <ongy> :t mapMaybe
06:11:32 <lambdabot> (a -> Maybe b) -> [a] -> [b]
06:12:19 <onintza> Is there something like (.) but for functors?
06:13:21 <ongy> onintza: what would be the type for that?
06:14:20 <zoran119> Boomerang: space or comma separated, not both, but one (that should make it easier)
06:15:56 <ongy> zoran119: do you want to be the result [Maybe Int] or Maybe [Int]?
06:16:12 <onintza> ongy: I'm searching for some :: ((t a) -> f (t b)) -> f (t a) -> f (t b)
06:16:35 <zoran119> ongy: Maybe [Int]
06:16:44 <Boomerang> onintza is your functor also a monad?
06:17:01 <onintza> Boomerang: yes, f :: Maybe a
06:17:10 <Boomerang> try (>>=)
06:17:13 <onintza> Oh, shit, now I see
06:17:40 <onintza> Awesome, thanks, I don't know how it went under my eyes unoticed
06:17:45 <Boomerang> :)
06:18:04 <zoran119> ongy: but i'm guessing i could use sequence to go from [Maybe Int] to Maybe [Int]
06:20:53 <ongy> :t sequence . (fmap . fmap) fst . map BS.readInt . BS.words -- Replace the words by something better for your usecase. But it isn't really pretty
06:20:55 <lambdabot> error:
06:20:55 <lambdabot>     Not in scope: ‘BS.readInt’
06:20:55 <lambdabot>     Perhaps you meant one of these:
06:21:11 <ongy> readInt is from Data.ByteString.Char8
06:27:50 <Boomerang> > let f input = on (<|>) (traverse (readMaybe :: String -> Maybe Int)) (splitOn " " input) (splitOn "," input) in (f "1,2,3,4", f "1 2 3 4")
06:27:53 <lambdabot>  error:
06:27:53 <lambdabot>      Variable not in scope: readMaybe :: String -> Maybe Int
06:30:35 <ertes> is optparse-applicative still the sanest command line parser?  i'd like to have something with less overhead
06:31:31 <Eduard_Munteanu> If overhead in cmdline arguments is a concern, I'd just not use cmdline arguments, but a proper input file.
06:32:02 <ertes> Eduard_Munteanu: i mean programming overhead, not efficiency
06:32:13 <Eduard_Munteanu> Ah.
06:33:15 <maerwald> how is input file less overhead... then you gotta deal with even more potential errors
06:34:31 <ertes> well, for an input file i could just use aeson/yaml =)
06:35:27 <Eduard_Munteanu> By input file I mean either a file or a pipe like stdin.
06:35:46 <maerwald> yes, that introduces more error cases
06:37:18 <Eduard_Munteanu> I thought it was about efficient parsing.
06:41:54 <cocreature> ertes: if you can get away with it, optparse-applicative-generic is quite nice
06:42:00 <ongy> even then, why would it be more efficient to parse?
06:45:26 <maerwald> if you're unlucky, you even end up with a turing complete configuration file format
06:46:24 <ongy> do we have a getArgs with bytestring (or text), or do we have to go over string?
06:46:37 <maerwald> ongy: in the unix package
06:46:59 <maerwald> or somewhere
06:47:05 <m`> I'm wondering why the follwoing function does not work in point-free: f x xs = reverse . sortWith (g x) $ xs ; I'd expext it to work like so: f = reverse . sortWith . g; as it does when the reverse is omitted. 
06:47:16 <maerwald> ongy: https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Env-ByteString.html#v:getArgs
06:47:36 <ongy> looking at it, I was wondering if avoiding String can speed up things, but this avoids string aswell
06:48:10 <ertes> cocreature: yeah, i was aware of that one, but i was hoping for a less rigid solution…  perhaps it's just time for another library
06:48:24 <lyxia> (reverse .) . sortWith . g, m`
06:48:27 <cocreature> dunno, optparse-applicative works pretty well for me
06:50:45 <meretrix> I've placed Set Cost Centers on every line of my function.  The SCC on the first line, which is just "do", is recording 27% of the execution time on its own.  What exactly is it measuring?
06:51:20 <meretrix> The function uses the ST monad.
06:52:09 <ertes> cocreature: one symptom of the problem is that i can't memorise its API…  also it has a few short-comings like forcing users to write "-a -b -c" instead of "-abc"
06:52:58 <ertes> cocreature: if i write a library i can actually handle command line, environment variables and configuration file in one go…  that would be nice =)
06:53:03 <ertes> i think i'm going to do that
06:55:25 <lyxia> the -abc thing might be fixable
06:58:53 <m`> lyxia: actually, your propose seems not to work
06:59:06 <m`> :r
06:59:08 <ShalokShalom> what is aahhkllmooss? :) http://funkyimg.com/i/2m8zV.png
06:59:34 <m`> (sorry for the :r :-)
07:00:21 <lyxia> oh? 
07:00:56 <m`> lyxia: srry, it does work
07:01:13 <m`> lyxia: I'm still wondering why..
07:02:31 <lyxia> m`: in yours, applying to x results in reverse (sortWith (g x))
07:03:18 <lyxia> but what you really want is ((.) reverse) (sortWith (g x))
07:03:18 <m`> but with a dot, inbetween, no?
07:04:26 <lyxia> there's a dot before applying, and it goes away after applying.
07:04:47 <lyxia> f . g $ x = f (g x)
07:05:10 <m`> Oh really, I'd expext that only the second dot goes away after applying an x
07:05:24 <lyxia> f . g . h $ x = f (g (h x))
07:06:39 <m`> oh, I see
07:06:43 <lyxia> an intermediate step being f . g $ h x
07:11:42 <m`> lyxia: Ok, I got it now. but, would you really write it like this in the code, or is there maybe another convenient option?
07:12:00 * geekosaur would skip the pointfree
07:16:22 <shlevy> If I'm interfacing with a C library that requires you to explicitly acquire and release a resource (underneath the hood it's just opening and closing an fd, but that's not exposed), is it better to use a finalizer or expose the release function and expect users to bracket or whatever?
07:17:43 <geekosaur> expose the release function, as part of a lower level API; higher level API might expose a bracket construct or etc.
07:18:24 <shlevy> OK, that's where I was leaning. Thanks!
07:19:30 <mohsen_> Is Hapstack the most popular Haskell web framework?
07:20:29 <nure> yesod, miku, salvia, servant, retarded question
07:21:16 <jxv> mohsen_, no. it hasn't been popular for many years.
07:22:51 <mohsen_> I'm new to Haskell world, but I need to write a web applciation using Haskell, but don't know what framework to use.
07:23:41 <geekosaur> there's no One True Framework
07:24:12 <geekosaur> people these days use scotty, spock, snap, yesod, ...
07:25:22 <mohsen_> I see
07:25:51 <orion> mohsen_: I use scotty in production for a financial company.
07:26:06 <orion> 10/10 would use again
07:27:52 <mohsen_> orion: Let me look it up
07:28:15 <vctrh> anyone using repa here?
07:28:23 <HKei> woah, I just tried yesod after a long time. Don't remember it being this fast
07:28:48 <vctrh> i've switched over to servant these days
07:29:32 <HKei> servant does look pretty neat, I might try it once I'm actually done building a whole site with yesod so I can make a fair comparison
07:30:21 <vctrh> i still use julius for js because well
07:30:28 <vctrh> don't see many other options out there
07:35:15 <ertes> vctrh: as a dynamic JS template system jmacro comes to mind
07:35:23 <ertes> vctrh: but GHCJS is also an option
07:35:59 <vctrh> ertes yeah jmacro, tried that a bit but not in depth
07:36:50 <ertes> vctrh: it's not comparable to julius though, at least not to the version of it i used many years ago, because jmacro does a lot more than JS with substitution
07:37:20 <vctrh> i want to get into ghcjs more but the heavyweight code build debug cycle is demotivating
07:38:20 <vctrh> ertes really? i was under the impression jmacro was pretty basic/lightweight.
07:38:59 <ertes> vctrh: you can develop/test JS applications natively using GHC (ghcjs-dom works with native/webkit as well as GHCJS), and only when they work you can compile them with GHCJS
07:39:12 <ertes> vctrh: it's also useful to know that `ghcjs --interactive` works now
07:39:40 <ertes> so you can integrate interactive GHCJS into your editor the same way you can integrate GHCi
07:39:59 <ertes> jmacro *is* lightweight, but that doesn't stop it from being pretty featureful =)
07:41:01 <vctrh> ertes is there a tutorial for spacemacs/intero integration somewhere? it seems like setup is one of the barriers to ghcjs adoption
07:41:28 <ertes> i have no experience with intero, but with haskell-mode it's pretty straightforward
07:41:40 <vctrh> that works for business logic (compiling to js at the end) but a big part of the loop with webdev is seeing how stuff works in the browser
07:42:20 <ertes> either set haskell-process-path-ghci to 'ghcjs --interactive' or write a wrapper script that decides which one to use based on project
07:42:38 <vctrh> it feels like ghcjs compilation is slower, although haven't timed it
07:43:00 <ertes> as i said you don't need GHCJS for development…  if you compile natively you can just fire up a webkit browser widget and ghcjs-dom and related libraries will just work
07:43:14 <ertes> compile/interpret
07:43:36 <vctrh> wait compile natively and view it in a browser?
07:43:39 <vctrh> how does that work?
07:43:41 <ertes> in fact reflex-dom makes this fully automatic
07:44:03 <ertes> not in a browser…  you write a mini-GUI application that uses a webkit widget
07:44:15 <vctrh> oh
07:44:29 <vctrh> and use ghcjs-dom natively...
07:44:33 <vctrh> didn't know you could do that
07:44:36 <ertes> yeah
07:45:07 <vctrh> that's an interesting trick, although it's still overhead to get up and going though
07:45:38 <ertes> well, not if you use reflex-dom…  the webkit part becomes entirely transparent =)
07:46:11 <ertes> and it's certainly possible to write a library that makes it transparent for ghcjs-dom in general, if you don't want to learn/use FRP
07:46:33 <vctrh> hmm need to play with it more i suppose. i don't mind learning/using frp
07:46:37 <Eduard_Munteanu> If you're writing a web application as in a single-page app, it's probably best to skip Julius et al. and develop your client-side code completely separate.
07:47:23 <vctrh> i toyed with reflex-playground a bit and it seems pretty rewarding. it's more the setup/iteration cycles that i'd like to cut down on
07:47:51 <ertes> vctrh: you may also find this library useful: https://hackage.haskell.org/package/rapid
07:48:14 <ertes> i.e. don't even destroy the window during development…  just reload the parts of your application that changed
07:48:23 <vctrh> i've seen that before that and it looks cool. has anyone tried using that for ghcjs?
07:48:33 <ertes> "that" being rapid?
07:48:50 <vctrh> yes
07:49:03 <ertes> won't work, because it needs the foreign-store library, which needs C
07:49:14 <vctrh> ah
07:50:48 <ertes> perhaps foreign-store can be patched to switch between a C and a JS version, then rapid will also work with GHCJS --interactive
07:51:10 <ertes> it's actually a pretty simple library, so it may be possible
07:52:38 <gameer> Hello. I have a data structure for a point (data Point = Point Double Double). With this function I can chance the first value of the point: setX x (Point y z) = Point x z  (type is: setX :: Double -> Point -> Point). Why this input doesnt work: setX 3.1 (Point 6.4 7.5) ? :()
07:53:30 <vctrh> bit of an aside, repa works with ghcjs while hmatrix does not right?
07:53:35 <xenon-> gameer what error are you getting?
07:53:56 <ertes> gameer: need more context…  the code you wrote here so far looks fine
07:55:13 <gameer> No instance for (Show Point) arising from a use to 'print' In a stmt of an interactive ghci command: print it
07:55:28 <geekosaur> that would be correct, you did not derive Show for Point
07:55:29 <ertes> gameer: data Point = Point Double Double  deriving (Eq, Ord, Show)
07:55:41 <seishun> is there a version of transpose that drops elements from shorter lists?
07:55:59 <ertes> gameer: that gives you (==), (<=) and 'show' among some other functions for Point
07:56:16 <gameer> i tried that
07:56:16 <seishun> *from longer lists
07:56:24 <gameer> parse error on input deriving
07:56:57 <xenon-> then you tried something similar to that, but different
07:57:50 <gameer> oh damn
07:58:20 <xenon-> :P
07:58:33 <gameer> I wrote it behind my function and not behind my data structure
07:58:35 <gameer> Thanks!
07:58:42 <xenon-> interestingly, ghci repl in emacs can somehow display Point, even without deriving Show
07:58:49 <ertes> > foldr (\xs xss -> zipWith (:) xs xss) (repeat []) ["abc", "def", "ghi", "jk"]
07:58:52 <lambdabot>  ["adgj","behk"]
07:59:11 <ertes> seishun: like this?  or should it actually stop and keep all results?
08:00:06 <seishun> like this, yeah. but I think I found a better way
08:00:16 <ertes> better than this?
08:00:46 <ertes> > foldr (zipWith (:)) (repeat []) ["abc", "def", "ghi", "jk"]  -- ok, slightly shorter =)
08:00:49 <lambdabot>  ["adgj","behk"]
08:01:03 <ertes> in any case just replace (zipWith (:)) to get the semantics you want
08:01:09 <seishun> a different approach. I just made the lists the same length, since I'm making them in the same function anyway
08:02:29 <xenon-> it can display functions too without error.. cool
08:02:44 <xenon-> not sure how it does it, but i like it
08:04:58 <shlevy> Is it safe to pass a FunPtr to a haskell function to a C function that takes a callback and calls it asynchronously (after returning)?
08:07:23 <vctrh> is there a good library for text mode plotting?
08:09:40 <hexagoxel> shlevy: given that you have to manually freeHaskellFunPtr, i think the safety is entirely in your hands.
08:10:07 <vctrh> i see textPlot but that looks a bit toy-ish and isn't in stackage
08:18:28 <vctrh> is there a way to get intero to print function signatures when a function is evaluated by default?
08:18:53 <vctrh> showing error message seems like a step back from the ghci default behavior
08:21:59 <sm> vctrh: let me know if you find one
08:22:19 <sm> (a good way to do text plotting)
08:25:16 <vctrh> sm wasn't there some hamiltonian physics package that was released recently?
08:25:38 <vctrh> i remember they had some text-mode animations that looked nifty.
08:26:07 <vctrh> i'm trying to remember the name of the package, it was posted on reddit within the last few weeks but i can't find it now
08:27:30 <meretrix> https://github.com/mstksg/hamilton
08:28:03 <vctrh> meretrix that's it thanks! now what is it using for those plots...
08:28:18 <vctrh> looks like it's build into the package
08:28:24 <vctrh> don't see any obvious dependencies there
08:44:53 <ertes> i wish 'where' blocks would work for lambdas
08:45:19 <jmcarthur> The new Data.Map.{Lazy,Strict}.Merge look really great.
08:45:46 <jmcarthur> It's easy to shrug off new stuff you see until you need it.
08:51:27 <shapr> jmcarthur: Got a link? What's cool about Merge?
08:52:06 <shapr> I'm reading about TransformListComp, at first glance TransformListComp looks like all the LINQ tricks I used in C#
08:54:55 <jmcarthur> shapr: http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Strict-Merge.html
08:55:29 <jmcarthur> shapr: The cool thing is that it's really general and is designed to be pretty efficient.
08:56:13 <shapr> jmcarthur: Are you saying there are Haskell modules that don't combine those two attributes? ;-)
08:56:16 <jmcarthur> However, now I'm seeing some ways that it is not actually general enough for my purposes, so meh.
08:57:27 <jmcarthur> I think what I'm doing fundamentally can't benefit from these efficiency tricks anyway.
08:57:46 <shapr> :-(
08:58:18 <shapr> I like the way ghc docs have improved from early 7.x to 8.x
09:01:35 <danilo2> Hello! Is there a way in haskell to tell that a particular instance could NEVER be overlapped? 
09:03:51 <ph88> what's StackSetupShim ?
09:04:19 <MitchellSalad> danilo2: what do you mean?
09:04:44 <shapr> If I run with -with-rtsopts=-N does that only count "real" cores or does it include hyperthreaded cores?
09:05:06 <danilo2> MitchellSalad: something like `instance {-# NOOVERLAPPABLE#-} ...` but such flag doesnt exist if im not wrong
09:05:21 <MitchellSalad> ah. yeah, the design prohibits that
09:05:33 <MitchellSalad> so as to allow overlapping instances w/o modifying upstream code
09:06:20 <glguy> shapr: I don't know, but you can check the value with http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:getNumCapabilities
09:06:28 <glguy> and then work backward to guess what it did
09:06:37 <shapr> glguy: ooo actual data, thanks!
09:07:04 <glguy> shapr: report what you find!
09:07:31 <danilo2> MitchellSalad: this is not exaclty true. In fact we can have what I want using SafeHaskell. Hoverwer I'm looking for anoter way to do it if its possible. Of course the desing is as is, but it doesnt tell that such things would be impossible, for example from the security point of view
09:11:38 <lyxia> Why do you need that much enforcement
09:11:39 <shapr> glguy: for a Xeon E3-1505M v5 with four 'real' cores and four more hyperthreaded cores, I get 8 for getNumCapabilities
09:12:04 <lyxia> danilo2: Can't you tell your users not to implement overlapping instances?
09:13:13 <Boomerang> shapr: I think you want to set N to the number of physical cores. Or were you asking for when you don't specify the number manually? This blog post might be relevant https://simonmar.github.io/posts/2016-12-08-Haskell-in-the-datacentre.html
09:13:19 <shapr> So yes, hyperthreaded cores count towards the total number of cores used by the GHC runtime
09:14:19 <shapr> Boomerang: I was asking what happens when I don't specify the number manually, but I was wondering if real+hyperthreaded or just real would give better performance.
09:17:04 <shapr> Boomerang: the link in that post implies (but is not explicit) that hyperthreaded cores count as real cores: https://phabricator.haskell.org/rGHC6c47f2efa3f8f4639f375d34f54c01a60c9a1a82
09:17:23 <shapr> Boomerang: that's good stuff, thanks!
09:21:02 <Boomerang> shapr: Just tested it with multithreaded code I had lying around, and automatic -N uses 8 threads on my quadcore
09:23:07 <sm> vctrh: good point
09:28:23 <ph88> is there a way so that i can avoid typing arbitrary three times in this snippet ? https://paste.fedoraproject.org/509062/14820820/
09:28:41 <ph88> at first i was thinking about desugaring the do-notation but that doesn't help that much actually
09:31:16 <lyxia> did you mean SI n tm c, without the dollar
09:31:35 <ph88> yes that too ^^
09:31:47 <MitchellSalad> ph88: nope
09:31:47 <lyxia> @hackage generic-random
09:31:47 <lambdabot> http://hackage.haskell.org/package/generic-random
09:31:51 <ph88> i meant   return $ SI n tm c
09:31:52 <danilo2> lyxia: I can, but still it would be better to enforce sometimes some design than jut implement it "by words in the docs"
09:32:04 <Akii> (n, tm, c) <- arbitrary
09:32:10 <Akii> maybe
09:32:16 <ph88> o_O
09:32:16 <MitchellSalad> ph88: deriving Arbitrary
09:32:28 <MitchellSalad> deriving (Generic, Arbitrary) rather
09:32:45 <Akii> ah I get it, doesn't work because the compiler can't infer the type
09:32:55 <ph88> MitchellSalad, why do you think that Arbitrary can be derived ?
09:32:57 <Akii> maybe there is syntax for that still
09:33:21 <MitchellSalad> err, not deriving Arbitrary, I misspoke... 
09:33:24 <ph88> lyxia, did you make generic-random ?
09:33:32 <MitchellSalad> derive Generic, then just write "instance Arbitrary MyType" with no definition
09:33:33 <lyxia> yes indeed
09:33:48 <lyxia> MitchellSalad: Arbitrary doesn't have a Generic default
09:33:51 <ph88> how come on github there is an extra s in your name ?
09:34:10 <lyxia> ph88: my nick was already taken :(
09:34:16 <ph88> :(
09:34:20 <ph88> mine was too :/
09:34:35 <ph88> well not my irc nick that is, but anyway ^^
09:34:49 <MitchellSalad> so it doesn't
09:35:20 <ph88> lyxia, why can't hoogle and hayoo not find genericArbitrary of your package ?
09:35:47 <ph88> lyxia, did you know there is another package that provides genericArbitrary? any idea how the implementations compare?
09:36:24 <ph88> lyxia, on that first question i just forgot i know the answer, and also i opened an issue for it ^^
09:39:08 <lyxia> ph88: IIRC think for product types it's pretty much the same.
09:46:24 <ph88> does anyone know if nix is a good choice to manage packages for making software? like a stack or cargo
09:46:38 <ph88> or it is mainly for OS packages ?
09:48:12 <Boomerang> Nix is great to make software too! But in my opinion it has a steeper learning curve than stack
09:51:30 <lyxia> ph88: quickcheck-arbitrary-adt has no way to avoid generating infinite values of recursive types (though it doesn't necessarily happen).
09:51:34 <ph88> so if you have a couple of git repos then you can use nix to get the right versions to make your program ?
09:51:42 <maerwald> try cabal it doesn't have a learning curve
09:52:06 <ph88> lyxia, seems a clear downside to it ^^
09:53:17 <Boomerang> Yes you can use a git repo, a local directory, a directory through ssh (I think). But I'm pretty you can do that with stack too if git is your only requirement
09:53:32 <Boomerang> *pretty sure
09:54:12 <kadoban> If all you're trying to do is use some packages from git as dependencies, yeah stack supports that well.
09:54:32 <maerwald> cabal can do that too
09:55:08 <Boomerang> for stack, in packages:
09:55:09 <Boomerang> - location: git: git@github.com:commercialhaskell/stack.git commit: 6a86ee32e5b869a877151f74064572225e1a0398
09:55:16 <Boomerang> (on newlines)
09:55:39 <ph88> no actually at work we have ancient version control system which needs to be replaced .. and also we have no system to track dependencies of software packages
09:55:56 <ph88> it's not for haskell
10:00:28 <ph88> lyxia, why is genericArbitrary not working in this code? https://paste.fedoraproject.org/509152/08398114/
10:00:44 <ph88> oh maybe because i forgot to derive Generic
10:00:47 <ph88> d^oh
10:01:39 <lyxia> heh
10:09:10 <ph88^> lyxia, does using genericArbitrary cause runtime overhead compared to manually implementing arbitrary ?
10:10:16 <lyxia> Yes :/
10:11:10 <ph88^> ^^ i don't think that is technically impossible to do it on compile time .. seems to be a limitation of ghc
10:11:14 <jmcarthur> I'm looking for a function with a type like  (Applicative f, Ord k2) => (k1 -> a -> f (Maybe (k2, b))) -> Map k1 a -> f (Map k2 b)  . I don't think containers has it. Does anybody know of a nice way other than going via an intermediate list?
10:11:21 <ph88^> well it doesn't matter that much though since it's used for testing only anyway
10:11:35 <jmcarthur> It's like traverseMaybeWithKey except that the keys can change, too.
10:11:49 <ph88^> jmcarthur, maybe i'm saying the obvious here but did you try hoogle or yahoo ?
10:11:53 <ertes> jmcarthur: this may be a weird way to do it, but you can use Data.Map.*.Merge
10:11:57 <jmcarthur> I did.
10:12:06 <jmcarthur> Merge doesn't allow you to change keys.
10:12:12 <ertes> ah, i see
10:12:26 <jmcarthur> That's part of how Merge stays efficient.
10:12:40 <ertes> well, if you're changing keys, then you have to go through construction again anyway, so going through a list shouldn't really matter
10:13:02 <jmcarthur> Of course. It just seems a bit ugly, I guess.
10:13:28 <lyxia> It could be done efficiently if the keys remain in the same order.
10:13:39 <jmcarthur> In fact, in my case the keys will remain in the same order.
10:13:53 <ertes> in that case you would just use fromAscList
10:14:15 <ertes> but i hear that it doesn't make a noteworthy efficiency difference anyway
10:14:21 <jmcarthur> Doesn't fromList actually have basically that optimization these days?
10:14:23 <jmcarthur> Yeah.
10:15:08 <jmcarthur> fromAscList can still be more efficient if the Ord instance is kind of slow.
10:15:18 <jmcarthur> Which in my case it is.
10:15:31 <jmcarthur> Anyway, I guess this is what I'll do. Thanks.
10:16:08 <ertes> jmcarthur: do you need the ordering?  because if not and your Ord instance is slow anyway, then HashMap would be a better idea
10:17:33 <jmcarthur> Good suggestion.
10:20:49 <vctrh> why was safe indexing removed in repa 3.2
10:20:50 <vctrh> ?
10:24:48 <jmcarthur> It turns out it's easy for me to just roll my own trie for this key.
10:25:31 <codygman> Would pipes for database queries make sense? I suppose it would. I guess I could just splice in limit queries to do paging? I think pipes-bytestring uses the notion of chunks, that would definitely be needed here I think.
10:29:49 <lyxia> ph88^: BTW thanks for telling me about the issue, I somehow missed that.
10:30:19 <Eduard_Munteanu> codygman, 'persistent' provides conduits for queries
10:30:34 <Eduard_Munteanu> @hoogle select
10:30:37 <lambdabot> Text.Blaze.Html4.FrameSet select :: Html -> Html
10:30:37 <lambdabot> Text.Blaze.Html4.Strict select :: Html -> Html
10:30:37 <lambdabot> Text.Blaze.Html4.Transitional select :: Html -> Html
10:30:47 <Eduard_Munteanu> @hoogle selectDistinct
10:30:47 <lambdabot> Database.Esqueleto selectDistinct :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]
10:30:47 <lambdabot> Database.Esqueleto.Internal.Sql selectDistinct :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]
10:30:47 <lambdabot> Database.Esqueleto selectDistinctSource :: (SqlSelect a r, MonadResource m) => SqlQuery a -> Source (SqlPersistT m) r
10:30:55 <codygman> Eduard_Munteanu: Thanks, I'll see what they do and copy it probably.
10:45:58 <kuribas> Should a "ReaderT r (MonadState s m) a" be merged into "MonadState rs m a" ?
10:46:08 <kuribas> well MonadStateT
10:46:19 <xa0> @pl let f x = g . h x
10:46:20 <lambdabot> (line 1, column 18):
10:46:20 <lambdabot> unexpected end of input
10:46:20 <lambdabot> expecting variable, "(", ".", "`", "!!", operator, ";" or "in"
10:46:32 <xa0> @pl let f x = g . h x in f y
10:46:32 <lambdabot> g . h y
10:46:54 <xa0> ..there's a way of removing the 'x' from that isn't there
10:47:54 <xa0> @pl \x -> g . h x
10:47:55 <lambdabot> (g .) . h
10:48:54 <ph88^> lyxia, :D <3
10:50:36 <ph88^> leaving train, bye bye
10:51:39 <tom7942> nshepperd1: thanks for explaining that evaluation of 'parse (some (char 'v'))'
10:55:56 <lyxia> kuribas: that's up to you
10:57:03 <lyxia> I think merging them makes things a bit easier
10:59:01 <kuribas> lyxia: and faster probably...
11:02:16 <lyxia> hmm... there is a trade off between passing around one more reference vs building up larger records.
11:03:08 <c_wraith> lyxia: yes.  A larger record means more allocation (slightly) if you're frequently updating part of it while not touching a different part.
11:03:51 <c_wraith> lyxia: while passing an additional reference has all the expected impacts of passing an extra argument - more registers used for argument passing, making it easier to need to spill arguments to the stack, etc
11:04:41 <c_wraith> lyxia: as well as additional pointers to dereference to use all the data.
11:14:58 <mettekou> Do 'seq' and '($!)' force evaluation to weak head normal form or to normal form?
11:15:15 <kadoban> seq is WHNF. I'm not familiar with $!, but I think it's the same.
11:15:17 <Lokathor> weak head
11:15:42 <mettekou> kadoban Lokathor: is there a way to force evaluation to normal form?
11:15:49 <Lokathor> there's deepseq if you need full evaluation, but it's in an extended library
11:16:07 <Lokathor> i think the package is also called deepseq, it provides an NFData typeclass
11:16:08 <kadoban> Yeah, 'force' from deepseq library or other friends in there
11:16:11 <c_wraith> deepseq also has $!! for normal form analogous to $!
11:16:38 <kadoban> Be a bit careful with it though, it's easy to ... do a bunch of extra work and kill performance. Sometimes there's something more efficient that makes sense.
11:16:58 <c_wraith> There's always something more efficient, but deepseq is a good debugging tool
11:17:47 <kadoban> Sure, I just mean, don't throw deeqseq everywhere without thought and call it good. ... or at least try to go back later and figure out if they're all needed.
11:17:55 <mettekou> kadoban c_wraith: Yeah I need it in conjunction with 'Debug.Trace', not in an actual program.
11:18:21 <Lokathor> if you print a thing, calling show on it would generally force the entire value
11:18:34 <Lokathor> unless it contains thunks that don't get into the show output i guess
11:19:25 <mettekou> Lokathor: 'traceShowId' doesn't seem to show anything in some cases.
11:19:42 <c_wraith> whatever's going on there isn't laziness
11:20:18 <kadoban> Well, that could be ^, since if the value you're using traceShowId on isn't ever evaluated, neither will the show. No?
11:21:30 <Lokathor> yeah, the trace itself does need to be forced at some point or you get nothing
11:21:38 <c_wraith> Oh, true.  Debug.Trace *is* highly sensitive to laziness in general
11:22:33 <Lokathor> trace only lets you juke the type system, other haskell concepts still (largely) hold true
11:23:07 <quchen> Juke the type system?
11:23:19 <quchen> Trace is orthogonal to typing, it just has a hidden side effect
11:23:25 <Lokathor> do things the type system tells you that you should not do
11:23:27 <quchen> unsafeCoerce lets you juke the type system ;-)
11:23:34 <c_wraith> In my opinion, that's actually what it's there for - the order (and presence or absence) of output is just as important as the content of the output.
11:23:40 <Lokathor> specifically: print value (an IO effect) within non-IO code
11:24:27 <quchen> Hm, alright, I guess you could say that.
11:24:52 <Lokathor> quchen, i would argue that "hidden side effect", within the concext of haskell's overly explicit type system, is enough of a juke
11:25:01 <Lokathor> if this were C it wouldn't be a big deal
11:25:13 <quchen> Okay okay. :-)
11:26:23 <Lokathor> i'm sad that ByteString doesn't have a "repeatX" operation of its own
11:28:40 <quchen> Is there a reason for »local« having only (r -> r) in its type, not (r -> s)?
11:28:41 <quchen> :t local
11:28:43 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
11:29:02 <quchen> (MonadReader r m, MonadReader s n) => (r -> s) -> m a -> n a
11:29:08 <Lokathor> local replaces the contextual data
11:29:13 <glguy> quchen: local's a class method of MonadReader
11:29:21 <Lokathor> but unless you start up a whole new Reader, the data must stay as the same type
11:29:23 <quchen> glguy: Oh, is it?
11:29:29 <quchen> glguy: In that case it’s clear.
11:29:36 <quchen> Hadn’t thought of that.
11:32:43 <quchen> Lokathor: ByteString has replicate, ByteString.Lazy has repeat
11:32:48 <quchen> What do you mean with »repeatX«?
11:34:36 <kuribas> quchen: a monad can only vary in the last type variable.
11:35:15 <kuribas> I mean when binding monads.
11:35:38 <quchen> But I’m not binding here, I’m creating a morphism between readers
11:36:40 <Lokathor> quchen, repeatX :: ByteString -> Int -> ByteString -- repeats a single bytestring X times in the output. eg, repeatX "\r\n" 3 == "\r\n\r\n\r\n"
11:36:52 <kuribas> quchen: well local is meant to be used inside a do block, or >>= 
11:37:23 <quchen> Lokathor: Sounds like replicate.
11:37:30 <quchen> Lokathor: Repeat gives you an infinite result.
11:37:47 <Lokathor> quchen, no replicate only replicates a single Word8, that's my problem
11:37:54 <vctrh> what's the standard way to add a constant to a vector in repa?
11:38:35 <c_wraith> vctrh: pointwise?  wouldn't that just be a map (whatever repa names mapping)?
11:38:43 <vctrh> yes I can sort of do it with map, but that seems kinda verbose. it also does something strange with unboxed vectors
11:39:07 <vctrh> c_wraith so let t = fromListUnboxed (Z :. 10 :: DIM1) ([1..10] :: [Double])
11:39:13 <quchen> Lokathor: Oh! Strange.
11:39:19 <vctrh> type of t is t :: Array U DIM1 Double
11:39:23 <Lokathor> for now, i'm using something like: repeatX input x = B.concat $ take x $ repeat [input]
11:39:35 <vctrh> let foo = (R.map ((+) 3) t)
11:39:52 <vctrh> foo :: Array D DIM1 Double
11:40:10 <vctrh> so yeah, slightly ugly for just adding a constant
11:40:23 <c_wraith> Well, you can use a section to make things cleaner
11:40:29 <Lokathor> technically i guess i could rig what i want with unfoldrN
11:40:30 <c_wraith> R.map (+3)
11:40:32 <vctrh> also foo doesn't have a show instance hile t does
11:40:45 <quchen> Lokathor: Looks inefficient (not sure about whether this fuses). Maybe build something based on ›cycle‹?
11:40:54 <c_wraith> vctrh: yes, that's part of repa's optimzation strategy
11:41:09 <quchen> … or unfoldr
11:41:25 <vctrh> what's the difference b/w Array D DIM1 Double vs. Array U DIM1 Double
11:41:32 <vctrh> i can show the latter but not the former ..
11:41:39 <quchen> Eh, unfoldr is out since it also just produces Word8.
11:41:44 <c_wraith> vctrh: U = Unboxed.  D = Delayed
11:41:53 <vctrh> ah, the output of the map on the latter results in the former
11:42:04 <c_wraith> vctrh: Delayed arrays are stored as "the old array + the transformation function"
11:42:06 <vctrh> so i guess i'm looking for some sort of strict map operation
11:42:19 <Lokathor> quchen, well... you can rig a function that has the "seed" be the lookup into the source bytestring, and the "next seed" be the next index (with looping at the end)
11:42:28 <c_wraith> vctrh: that representation allows repa to avoid a lot of intermediate copying without depending on fusion
11:43:06 <quchen> Lokathor: Sounds like a lot of looping for something that should be very simple computationally.
11:43:21 <vctrh> c_wraith point taken, but what if i just want to get it back into unboxed form?
11:43:22 <Lokathor> exactly!
11:43:54 <Lokathor> all i want is to duplicate a particular 4 byte pixel width*height times
11:44:36 <c_wraith> vctrh: then use computeP or computeS to apply the transformation in parallel or serially
11:44:49 <Lokathor> seems like an obvious enough thing. also sadly, ByteString doesn't seem to have a version to use in ST or IO like Vector and co do.
11:45:03 <c_wraith> vctrh: ok, it is a bit verbose, but repa is a bit low-level in the name of precise performance control
11:46:02 <quchen> Lokathor: You can at least save the »take« if you use replicate instead of repeat,  repeatX input x = B.concat (replicate x input)
11:46:27 <Lokathor> is take worse than replicate? I honestly don't know
11:46:56 <Lokathor> either way it's doing a test on a value every iteration of the loop that's formed
11:47:42 <Lokathor> seems base agrees with me :P
11:47:43 <Lokathor> replicate n x           =  take n (repeat x)
11:49:51 <hexagoxel> Lokathor: use repeatX width $ repeatX height $ foo. even if that has overhead, it will be O(height+width) instead of O(_*_)
11:50:36 <Lokathor> strong point
11:51:42 <Lokathor> in a few itertions it won't be the same thing all over though
11:52:19 <Lokathor> that is, i'm following another project building the haskell version, and this day is monocolor showing, and then next day it actually does a thing using sin
11:52:24 <Lokathor> to make a gradiant
11:52:41 <Lokathor> unfoldrN would actually be quite good there I think
11:53:10 <quchen> Lokathor: Huh, okay, nevermind then.
11:53:14 <quchen> I’m not a big help here haha
11:53:32 <Lokathor> no, no, it's nice to have someone to talk to, even if they're as lost as you
11:53:58 <quchen> I guess take and repeat fuse
11:54:08 <quchen> So they might not be as bad
11:55:04 <Lokathor> well there's nothing to fuse really, since B.concat is the consumer
11:55:41 <Lokathor> repeat produces 1 element at a time, take passes along 1 element at a time, and then B.concat gloms on one element at a time, so it should be minimal space used
11:56:00 <Lokathor> we don't traverse the list more than once
11:56:07 <quchen> I’m surprised I can’t find a function that combines chunks of a lazy BS
11:56:31 <quchen> If you have 100 chunks of size 1, it might be a good idea to combine them instead of doing 100 jumps on each traversal, no?
11:57:11 <domenkozar> how does one correctly special cross-platform path for "foreign import"?
11:57:27 <tremon> but if you know you have 100 chunks of size 1, then you have traversed them at least once already, right?
11:57:31 <domenkozar> foreign import ccall "foo/string.h"
11:57:33 <domenkozar> and
11:57:36 <domenkozar> foreign import ccall "foo\string.h"
11:57:40 <Lokathor> quchen, as i understand it the chunks at least have a fixed size between 4kb to 32kb
11:58:04 <Lokathor> tremon, was that to me?
11:58:34 <hexagoxel> quchen: yeah, i am puzzled by this as well. vector::Vector is Monad at least, so join might be implemented efficiently.
11:58:34 <quchen> Lokathor: I don’t think so, consider the »cons« function, it’s literally a singleton BS consed onto a BS
11:58:36 <quchen> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Lazy.html#cons
11:58:43 <tremon> Lokathor: not really, I responded to quchen's last comment and was still reading up on context :)
11:59:12 <quchen> hexagoxel: That was for someone else, wasn’t it?
12:00:17 <quchen> Speaking of ›join‹, since it’s not in Monad yet, we cannot implement it efficiently :-(
12:01:25 <hexagoxel> yeah true.. i had some obscure hope there would be a way to still optimize it.
12:01:26 <quchen> Lokathor: I think cons' is a bit better in this regard, it uses a strict-bytestring-cons if the argument is too short
12:01:35 <hexagoxel> quchen: nah, i was considering alternatives for BS; Vector Char8 is not that different
12:02:04 <quchen> Good point.
12:02:10 <quchen> What kind of Vector though?
12:02:17 <hexagoxel> especially when the usecase is image data anyways
12:02:18 <quchen> Unboxed, probably?
12:02:19 <quchen> Storable?
12:02:28 <exio4> what are the recommended courses for learning Haskell nowadays?
12:02:49 <yushyin> exio4: see topic
12:03:10 <quchen> Topic says »AoC: 43100-84040706«, what does that mean?
12:03:11 <Lokathor> quchen, BS.cons isn't the same as (:) though, repeat and take are both from Data.List, so they're only going to use 1 element at a time.
12:03:44 <Lokathor> hexagoxel, you would THINK that Vector Char8 or Vector Word8 would be allowed, but the sdl2 package would tell you otherwise
12:03:55 <yushyin> exio4: oh wrong channel, I’m sorry :)
12:04:03 <Gurkenglas> quchen, http://ircbrowse.net/browse/haskell?q=43100-84040706
12:04:38 <quchen> Oh, Advent of Code
12:06:45 <exio4> yushyin: alright
12:11:44 <hexagoxel> Lokathor: well there are unsafe methods of constructing the BS..
12:13:03 <yushyin> exio4: I liked the NICTA course https://github.com/NICTA/course
12:13:56 <exio4> ok
12:15:37 <Lokathor> exio4, for very beginners, http://cis.upenn.edu/~cis194/spring13/ will be a good start
12:15:55 <Lokathor> and if you have the 60 to spare, http://haskellbook.com/
12:16:22 <Lokathor> as i recall, NICTA is more of an intermediate course that's better once you'd finished cis194
12:20:45 <kadoban> Ya, NICTA on its own would have killed me, it gets hard quickly. Maybe it's easier when done with a guide like it's actually presented in person.
12:21:59 <yushyin> it helped me alot to understand the functions in prelude and base, but yes it is not an easy task!
12:22:15 <kadoban> By the way, the authors of haskellbook seem quite willing, even eager, to give discounts for a variety of reasons. So even if you don't have the purchase price to spend, can contact them.
12:47:15 <Lokathor> so, ForeignPtrs are used for both Vector and ByteString internally, can you convert between them without much worry about the garbage collection?
12:52:07 <sm> exio4: also: http://haskell-lang.org/documentation , https://leanpub.com/haskell-cookbook
13:09:08 <elpfen> How is haskell-cookbook?
13:11:45 <sm> very good
13:11:47 <lpaste> f-a pasted “reactive banana” at http://lpaste.net/350128
13:12:38 <f-a> question regarding the above paste: is that the proper way to express the even graph (line 27 and on)?
13:13:26 <f-a> Apparently I have to have a parameter (which I named "key" or "k") on every function, which basically is the input stream of key events
13:13:56 <f-a> It seems logical (and it works), but I wondered if that's the correct way to write it
13:49:50 <peddie> Lokathor: I've converted between them a lot just by reusing the `ForeignPtr` and never had a problem
13:50:17 <Lokathor> peddie, :3
13:50:31 <Lokathor> -O2 might even make it a noop
13:52:50 <peddie> Lokathor: I guess most of the time when I am working with loading binary data as vectors of numbers, the price of a single pointer cast per data source is negligible either way :)
13:54:40 <Lokathor> my case is for a game where the bytes are color channels in a pixel. So, at 30 or 60fps that overhead would matter a lot
13:55:19 <peddie> I don't totally understand the situation, but good luck and I hope there is little overhead :)
13:56:28 <peddie> I'll venture that since the GHC runtime does not know about types, there is no reason for casting a `ForeignPtr` to have any runtime cost . . .
13:56:54 <Lokathor> peddie, that is, the bytes are a buffer for pixel data (one bite per channel, r/g/b/a) and so each frame of drawing i need to arrange the whole buffer in an effective manner, then send that to SDL
13:57:26 <Lokathor> yeah, a lot of the number conversions are also no cost at runtime since they're all the same bits internally
13:57:28 <peddie> Lokathor: I think what I was getting at is that any calculation or rearrangement of the data is likely to be much more costly than converting the underlying type of the pointer
14:05:25 <Lokathor> true
14:07:31 <peddie> Lokathor: what kind of game are you building?
14:12:21 <Lokathor> I'm doing the Handmade Hero tutorial series
14:12:26 <Lokathor> but using Haskell + SDL
14:12:34 <Lokathor> so, it'll be a 2d zelda-like
14:14:17 <peddie> not familiar with that series, but sounds like fun :)
14:20:10 <htmldrum> I've just run `stack exec COMMAND` on a servant API and it's fetching a 800MB package index - is this normal?
14:22:01 <Lokathor> doesn't sound normal for exec, should only fetch package index with update, i thought
14:22:18 <Koterpillar> well, if you never had that snapshot, it will
14:22:39 <geekosaur> stack exec will ensure that a compiler and default resolver are present
14:22:48 <htmldrum> Thanks. Might not do this in a container then. Will deploy a binary.
14:24:15 <Koterpillar> if you are building a container, do "stack build" as the last step
14:25:16 <htmldrum> I've got a CMD of "stack exec foo-executable"
14:26:18 <Koterpillar> htmldrum: right, add EXEC stack build before that
14:26:23 <Koterpillar> or RUN
14:26:29 <Koterpillar> been a while since I've done this...
14:26:45 <htmldrum> thanks
14:27:42 <Eduard_Munteanu> What's the state of art regarding vcache / tcache / perdure these days? Anything up-to-date?
14:29:17 <Monoide> ça y est, je viens d'attendeindre 39mn
14:29:24 <Monoide> oups sorry wrong buffer :o
14:34:48 <Benzi-Junior> hey guys is there a way to have ghci evaluate but not show the results ?
14:35:15 <monochrom> consider "seq x ()"
14:35:23 <Koterpillar> Benzi-Junior: let x = ...
14:35:31 <Koterpillar> oh, sorry, listen to monochrom
14:35:40 <monochrom> bring in tools from Control.DeepSeq if you want more than WHNF
14:35:48 <Hafydd> That's how ghci worked before they added IO to Haskell.
14:37:10 <mettekou> Is there a better way to check the preconditions (predicates on arguments) for a function than using Debug.Trace? A form of assertions as in imperative languages?
14:37:27 <mettekou> Just for debugging I mean.
14:37:43 <monochrom> There is also :force but it evaluates a lot more than seq
14:37:55 <monochrom> Read the GHC Users Guide for more.
14:39:32 <monochrom> Control.Exception has assert. It even becomes noop when -O
14:40:41 <geekosaur> there is also :set -fno-print-bind-result
14:54:07 <mpickering> What is the recommended way to "stack repl" with -Wall, is it "stack repl --ghc-options="-Wall""?
14:57:42 <MarcelineVQ> seems reasonable it's --ghci-options appearantly though
15:00:58 <xcmw> acowley: I have a couple more questions about vinyl. Would ypu be willing to help me?
15:01:19 <MarcelineVQ> mpickering: not quite sure why that disctinction was made though
15:01:44 <mpickering> It couldn't have been the same as cabal ;)
15:02:34 <MarcelineVQ> well it's just odd because --ghc-options is used elsehwere and ghci isn't something other than ghc
15:10:48 <geekosaur> probably because command line options mirror stack.yaml options, and it's entirely reasonable to want different options for interactive use (same way ghci defaults to turning off monomorphism restriction for interactive expressions)
15:11:19 <radzen> Hi all, I'm trying to write a scan for rose trees that traverses in breath first order. Any thoughts?
15:11:50 <mpickering> Have you succeeded? 
15:11:52 <monochrom> you will need a queue for breadth-first walk
15:13:21 <MarcelineVQ> geekosaur: I see
15:14:05 <radzen> I've got an awkward one that is pretty close to depth first. Now I'm getting hung up on needing to deal with list append instead of consing to do BF...
15:15:06 <monochrom> this is why you need a queue rather than a stack
15:17:35 <radzen> That makes sense from a performance perspective. But I'm still trying to wrap my head around how I add to the queue while scanning
15:18:26 <Eduard_Munteanu> Define a helper that threads state around or use State.
15:19:02 <Eduard_Munteanu> It needn't be a one-liner.
15:19:04 <monochrom> add children to queue
15:20:31 <monochrom> Now I wonder if there is a tie-the-knot lazy list trick
15:21:21 <radzen> Absolutely, no desire to get this down to one line. Just want to understand how I'm keeping track of all the intermediate scans for the children that I'm adding to the queue 
15:22:16 <Eduard_Munteanu> radzen, you should add children, then process as you dequeue them.
15:23:04 <radzen> And I'm doing this during recursive calls?
15:23:51 <Eduard_Munteanu> Dequeue can be a pattern-match / step case.
15:24:51 <neodevelop> hey hi !
15:25:04 <Eduard_Munteanu> neodevelop, hi
15:25:27 <Eduard_Munteanu> radzen, you can also use Writer to 'tell' visited nodes, if it makes it any easier.
15:25:40 <neodevelop> what do you think? _programming haskell_ of graham hutton or _learn haskell for a great good_?
15:26:39 <monochrom> programming haskell
15:26:55 <monochrom> actually why not both. you only pay money for one.
15:27:17 <neodevelop> well, time, I really want to read both
15:27:36 <monochrom> then programming haskell is more efficient
15:27:51 <neodevelop> thanks for the opinion
15:27:57 <radzen> Eduard_Munteanu, I've never used Writer, so I guess a dequeue it is
15:28:19 <monochrom> your decision is basically "I have a spare 2 hours, should I watch a 2-hour movie or should I watch a 2-hour trailer?"
15:29:03 <neodevelop> mmm interesting
15:30:03 <Eduard_Munteanu> radzen, Writer was meant to produce output as you go without keeping track of it.
15:30:42 <Eduard_Munteanu> You can just cons manually outside the recursive call though.
15:32:48 <radzen> I think it's consing that's the problem with BF. Unless I'm missing something, since I want intermediate results of the traversal, ordered from top of the tree down, I need to append not cons
15:34:56 <Eduard_Munteanu> Yes. But you also have to produce a result, which is a list of traversed nodes.
15:37:01 <Eduard_Munteanu> Or maybe you're just searching by a predicate, you tell me.
15:39:37 <radzen> Not searching, just traversing, at least for now. But I see your point.
15:40:01 <lpaste> radzen pasted “Current try” at http://lpaste.net/350135
15:41:13 <Eduard_Munteanu> radzen, you should add the forest to the queue, not the current node
15:42:18 <Eduard_Munteanu> And you should start with the root node added.
15:44:40 <Eduard_Munteanu> I propose     treeScan = treeScanGo . (:[]) where treeScanGo :: [Tree a] -> [a]
15:49:31 <radzen> I think I see what you're saying, but I'm pretty sure I want treeScanGo :: [Tree a] -> [[a]]
15:51:31 <Eduard_Munteanu> radzen, if you intend to get the nodes grouped by level, that won't be straightforward.
15:52:29 <radzen> I think that's what I'm after...
15:53:07 <Gurkenglas> :t Data.Tree.levels -- this?
15:53:08 <lambdabot> Tree a -> [[a]]
15:53:51 <Eduard_Munteanu> Not sure if they want to implement it as an exercise.
15:57:36 <Gurkenglas> radzen, I wouldn't carry that accumulator down through the tree, having every a only once in the [[a]] is enough, right?
15:58:22 <Gurkenglas> And then by keeping track of all the nodes on one level in a [Tree a], you can make sure the order is correct
16:02:14 <radzen> Gurkenglas: Yeah, pulling the accumulator along is not going to be nice on the memory. I think it may be possible to do something like levels but use a map to keep track of which level it appears on then construct the scan
16:02:59 <Gurkenglas> (BFS is of course not going to be better than linear space)
16:29:50 <onintza> In "abcd-efg-h-ijk-3" I want to parse <combinations of lowercase and -><-><digit>, so I'd get ("abcd-efg-h-ijk", 3)
16:30:18 <onintza> I have tried using manyTill and notFollowedBy, but with no luck
16:30:30 <monochrom> that is going to be tough because every time you see a hyphen you don't know whether it's the last hyphen
16:30:49 <onintza> monochrom: that's right, i have to look ahead by 1 char
16:30:57 <johnw> (,) <$> many (try (many chars <* char '-')) <*> digit
16:31:19 <johnw> you'll need to strip the "-" from the end of the character string, and concat them back together
16:31:38 <johnw> I guess if 'chars' is only alphabetic, you don't need 'try'
16:32:05 <onintza> johnw: i managed to parse the strings including the last '-', but i hoped there was a better way
16:32:36 <johnw> then: what monochrom said :)
16:34:45 <xocolatl> why do we have <$> instead of just using `fmap`?
16:34:57 <monochrom> "lookAhead" exists, but I don't like it.
16:35:25 <monochrom> because we have <*> instead of just using `ap`
16:35:54 <Eduard_Munteanu> xocolatl, it's nicer for Applicative-style stuff
16:36:06 <Gurkenglas> Also fmap f
16:36:10 <Gurkenglas> Argh
16:36:17 <Gurkenglas> "Also $ vs `id`"
16:36:56 <xocolatl> ok, rephrasing slightly:  when would you use <$> over fmap (or map for lists)?  this is probably a style question
16:36:59 <monochrom> We need a professional hacker to hack into all haskell blogs and replace $ by `id`
16:37:21 <onintza> room = (,,) <$> many1 (lower <|> char '-')
16:37:21 <onintza>             <*> (read <$> many1 digit)
16:37:21 <onintza>             <*> between (char '[') (char ']') (many1 lower)
16:37:33 <monochrom> We need this done on March 31 so on the next day we get a lot of beginner questions :)
16:37:47 <onintza> xocolatl: I was just writing this
16:38:01 <monochrom> "Hi what's the difference between id and . ?" :)
16:39:10 <Gurkenglas> "No no, . is `fmap`."
16:39:45 <monochrom> hahah that would be the best April 1st ever
16:40:02 * xocolatl feels mocked
16:40:33 <shapr> xocolatl: the functor chapter of "Haskell From First Principles" gives a good motivation.
16:40:39 <Lokathor> so if my program doesn't have a notable difference between ghc-options: -O2 or not is that because stack is turning optimizations for me automatically or because my particular program just doesn't have many optimizations to trigger?
16:41:08 <monochrom> the latter. -O is enough for many many programs
16:41:26 <shapr> xocolatl: It's true, <$> is fmap, and <*> is the perfect matching flavor.
16:41:32 <monochrom> bytestring and text tend to be the rare cases where -O2 makes a difference
16:41:53 <Lokathor> monochrom, i'm constructing a new bytestring with unfoldrN every frame of the game >_>
16:42:47 <monochrom> ah but it's -O2 when compiling the bytestring library rather than -O2 when using
16:43:42 <shapr> onintza: looks like one of the AoC puzzles?
16:43:53 <xocolatl> shapr: is that book final?
16:44:26 <shapr> I'm fighting with day seventeen of advent of code. What's the standard approach to lazily constructing a Data.Tree for searching?
16:44:48 <Lokathor> monochrom, how do i make stack compile the library with -O2?
16:44:48 <shapr> xocolatl: I don't know, but the content is excellent and the homework questions are the best ever.
16:44:56 <monochrom> I don't know stack.
16:45:04 <EvanR> books that are not finished, lets wait. programs that are not continuouslly being modified, forget it.
16:45:09 <shapr> Lokathor: add it to your cabal file?
16:45:09 <onintza> shapr: it is :D
16:45:30 <xocolatl> shapr: so I should go ahead and buy it? (EvanR)
16:45:41 <shapr> onintza: ah, I know which day you're doing, I got frustrated with that and did a different problem.
16:45:49 <Lokathor> well i have ghc-options: -O2 in my cabal file, but on the executable, not on the library for bytestring
16:45:55 <shapr> xocolatl: I'm a fan, but you should certainly get more opinions.
16:46:02 <EvanR> dunno i just thought that was a funny dichotomy
16:46:18 <shapr> I guess the book is non-strict.
16:46:41 <EvanR> people buy video games now which are not and might never be finished
16:46:49 <EvanR> maybe books are next
16:46:55 <xocolatl> it's kind of expensive...
16:46:56 <onintza> what book are you talking about?
16:47:06 <xocolatl> Your card will be charged US$70.80, including $11.80 for VAT in France.
16:47:29 <monochrom> "is it finished?" is an uninformative boolean flag.
16:48:01 <EvanR> will it terminate however
16:48:02 <monochrom> "unfinished" lumps together both "there is only 1 page done, more to come" and "there are 1000 pages done, more to come"
16:48:09 <xocolatl> not really.  here's a "book" that is definitely not finished: http://dev.stephendiehl.com/fun/index.html
16:48:16 <monochrom> a completely misleading lumping
16:48:24 <Lokathor> Haskell Programming From First Principles is both currently "unfinished" and also an excellent book even in the current state
16:49:03 <monochrom> You should be asking yourself "is the current price worth the currently done parts"
16:49:28 <shapr> xocolatl: The big advantage of Haskell from First Principles is that its large contents match with the current state of the Haskell ecosystem.
16:49:55 <shapr> I bought two Haskell books in .. 1999(?) or so, and they're not very helpful right now.
16:50:06 <xocolatl> monochrom: what are the currently done parts, though?
16:50:07 <EvanR> how about, is it convergent
16:50:12 <johnw> I'm waiting for Haskell from Second Principles
16:50:26 <shapr> xocolatl: http://haskellbook.com/progress.html
16:50:33 <EvanR> if you buy it and it looks like X, then it transmutes into a totally different book Y, that sucks
16:50:34 <shapr> johnw: is that your next project?
16:50:47 <jle`> vctrh: yeah i just used vty and a custom plotting function heh
16:50:50 <monochrom> A lot is already done. Basically has exceeded every other finished Haskell books.
16:50:58 <Lokathor> aside, (spooky? no) is an excellent subtitle to a chapter
16:51:25 <monochrom> It is now approaching the cathedral kind of "unfinished" rather than the beta-test kind of "unfinished"
16:51:35 <xocolatl> does anyone have an offer code? ;)
16:52:22 <Lokathor> xocolatl, if you're a student or some such you could contact the authors, they often give discounts to those sorts of people i hear
16:53:15 <xocolatl> Lokathor: haskell is a hobby for me, and I'm long past being a student.  I'll just pony up.
16:54:25 <monochrom> reading books is a hobby for me. and yet I bought a Kindle Paperwhite.
16:54:29 <xocolatl> or not.  the site doesn't seem to want my credit card
16:54:45 <EvanR> i wouldnt
16:54:59 <monochrom> and before that, I also paid money for Harper's book
16:55:10 <xocolatl> EvanR: you wouldn't what?
16:56:03 <monochrom> If you don't spend money on hobbies, what are you spending money for? For an opportunity to work?
16:56:38 <xocolatl> most of my money goes to my kids :)
16:56:41 <MarcelineVQ> if you don't spend money on a hobby it's not a hobby it's an interest
16:56:55 <synProgrammer> xocolatl: you can read this book: http://learnyouahaskell.com/ web version are free
16:57:09 <xocolatl> I've read that one already
16:57:19 <monochrom> "I pay Google $70/hour to work there; I receive $70/hour from Steam for playing games."
16:57:46 <xocolatl> huh?
16:57:48 <synProgrammer> Well I'm a beginner in haskell so this book helped me
16:57:50 <monochrom> You know what, I may actually love that.
16:58:03 <EvanR> youd have to pay me that much to play steam
16:58:17 <synProgrammer> Idk if the book it's good but it's simple 
16:58:34 <Lokathor> xocolatl, I vote that you don't read Learn You A Haskell, it's not a helpful use of time
16:58:55 <EvanR> what was the other haskell tutorial with funny pictures
16:59:09 <EvanR> not as well known as LYAH
16:59:09 <synProgrammer> Lokathor: why? 
16:59:18 <Lokathor> EvanR, https://leanpub.com/happylearnhaskelltutorialvol1 ?
16:59:32 <EvanR> yes
16:59:42 <EvanR> happy learn haskell tutorial
16:59:49 <EvanR> HLHT
17:00:27 <Lokathor> synProgrammer, LYAH breezes over much of Haskell in a way that ends most people up able to look at haskell source a bit but not know how to write haskell programs well at all
17:00:30 <EvanR> what is haskell in that picture and whats with the unibrow
17:00:46 <Lokathor> looks like haskell is a hip flask
17:00:50 <EvanR> lol
17:01:14 <synProgrammer> Lokathor: so KYAH is for the very begginers? 
17:01:22 <EvanR> after doing too much java at work, you sneak haskell out from your drawer and take a swig
17:01:36 <monochrom> is there a volume 2?
17:01:51 <monochrom> oh there is, in beta
17:02:08 <monochrom> and "7% complete"
17:02:14 <Lokathor> synProgrammer, http://cis.upenn.edu/~cis194/spring13/lectures.html is what I would suggest for beginners that don't want to spend the 60 dollars. Though it does specify specific parts of LYAH as additional reading
17:02:52 <synProgrammer> Mmmm I'll take a look at https://leanpub.com/happylearnhaskelltutorialvol1
17:03:00 <monochrom> I think you will need volume 2 pretty soon.
17:03:26 <synProgrammer> Lokathor: fortunately I have the book. I bought it in a humble bundle
17:03:38 <EvanR> synProgrammer: its available online http://www.happylearnhaskelltutorial.com/
17:03:42 <Lokathor> Haskell Book was in a humble bundle?
17:03:47 <monochrom> wait, there are humble bundles for books now?!
17:03:53 <Lokathor> monochrom, oh yes
17:04:05 <MarcelineVQ> someone should have told this person that two-column pdf is awful on an ereader
17:04:23 <monochrom> yes, two-column is an old-school monster
17:04:52 <synProgrammer> Lokathor: Yes, there are
17:05:21 <Lokathor> MarcelineVQ, which book uses two-column?
17:05:57 <MarcelineVQ> this happylearnhaskelltutorial sample
17:06:04 <Lokathor> oh
17:06:10 <Lokathor> unfortunate
17:06:19 <Axman6> <3 two column papers though
17:06:22 <MarcelineVQ> the content isn't bad at all in this sample but the pictures are completely wasted space
17:06:59 <synProgrammer> Lokathor: I will take a look at CIS 194. The other book https://leanpub.com/happylearnhaskelltutorialvol1 is good or it's like LYAH
17:07:03 <MarcelineVQ> it's much better than its bullet-points suggested
17:07:20 <Lokathor> synProgrammer, I've never read the Happy Learn book
17:08:14 <synProgrammer> Ok, thank you
17:09:02 <EvanR> sometimes you need a funny picture
17:09:55 <ij> Shouldn't these be the same regardless of what atomState/config is? The first one compiles well.         «save c = atomState $ config .= c»; «save = atomState . sets config»
17:10:13 <EvanR> whats .=
17:10:49 <Axman6> @pl save c = atomState $ config .= c
17:10:50 <lambdabot> save = atomState . (config .=)
17:10:52 <ij> From lens. Oh, I see I they're not aliases of the same functin.
17:11:00 <Axman6> @pl save c = atomState $ setsconfig c
17:11:00 <lambdabot> save = atomState . setsconfig
17:11:06 <Axman6> @pl save c = atomState $ sets config c
17:11:06 <lambdabot> save = atomState . sets config
17:11:46 <ij> The alias is called assign.
17:15:29 <ij> So «save = atomState . assign config» // I simplified a getTVar/setTVar for a function and I'm happy about that today. http://sprunge.us/XhgJ
17:23:13 <Gurkenglas> ij, if you define "instance MonadState BotState Bot where state = atomState . state", you can even say "save = assign config"
17:24:15 <Gurkenglas> (Of course in that case you could inline atomState and get rid of its top-level definition)
17:26:19 <Gurkenglas> (And then you wouldn't even give save its own definition, just say "config .= c" whereever you would say "save c")
17:27:31 <uiop> > foldr (.) id (replicate 100000 (+ 1)) 0
17:27:33 <lambdabot>  100000
17:29:05 <jle`> > foldr mappend mempty (replicate 100000 (+ Sum 1)) 0
17:29:07 <lambdabot>  Sum {getSum = 100000}
17:29:40 <jle`> ;)
17:29:52 <uiop> blasphemy!
17:30:12 <ij> Gurkenglas, state = atomState . state?
17:31:25 <Gurkenglas> ij, state = (atomState :: State BotState a -> Bot a) . (state :: (BotState -> (a, BotState)) -> State BotState a) :: (BotState -> (a, BotState)) -> Bot a
17:32:13 <ij> My question is "should it be circular"?
17:32:50 <Gurkenglas> It stops being circular if you inline atomState
17:33:00 <Gurkenglas> But yes, I intended to write this like that
17:33:51 <Gurkenglas> For an example of "circular"ly defined instances, look at http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-314
17:41:02 <lpaste> Gurkenglas pasted “ij, Spoilers on how to do that MonadState thing with inlining done” at http://lpaste.net/350138
17:42:19 <ij> Sweet, can't belive this will work.
17:47:28 <ij> Gurkenglas, Should/will this work with: type Bot a = StatefulIRC BotState a
17:47:47 <ij> http://sprunge.us/MaeF
17:48:51 <Gurkenglas> I don't know what StatefulIRC is, but you'll want at least "MonadState BotState (StatefulIRC BotState)" here. If you didn't define StatefulIRC, that might in fact already be in place!
17:49:25 <Gurkenglas> (more like "MonadState s (StatefulIRC s)" probs)
17:50:54 <ij> Well I write the save = assign config, the I get a No instance for (MonadState BotState IO), although it does live in StatefulIRC BotState IO, not just IO.
17:51:22 <ij> s/e IO,/e,/
17:52:50 <Gurkenglas> Sounds like you tried to use save in a block that was inferred to be in IO? But try replacing Bot with (StatefulIRC BotState) in that instance definition first
17:53:20 <ij> Did that.
17:54:20 <Gurkenglas> Annotate save with the type signature you want it to have? :/
17:55:03 <Gurkenglas> (has form "_ -> Bot ()")
17:55:03 <ij> Seems that it wasn't. http://sprunge.us/HMgQ <-- Please don't mind the irrevelant bits.
17:55:48 <Gurkenglas> Lol looks like StatefulIRC is also a type synonym
17:56:05 <ij> Ah, I'll go find it then.
17:56:22 <ij> https://hackage.haskell.org/package/irc-client-0.4.4.1/docs/Network-IRC-Client-Types.html#t:StatefulIRC
17:57:23 <Gurkenglas> "type StatefulIRC s a = ReaderT (IRCState s) IO a" That explains why it complained about IO not being MonadState - ReaderT already provides a MonadState instance, by assuming its base monad provides it
17:57:50 <Gurkenglas> For this to work, Bot will have to be a newtype :/
18:00:01 <Gurkenglas> (Anyone, when instances overlap, how is the used instance chosen?)
18:00:35 <monochrom> specificity
18:01:07 <monochrom> the GHC Users Guide has a section on overlapping instances to talk about this
18:01:23 <ij> Too late for this tonight, it's 4 AM.
18:01:32 <ij> On a sun… monday.
18:02:08 <ij> … to map uncharted horizons
18:02:35 <monochrom> Yes, it's time to play a game instead.
18:03:13 <ij> It's time to go to sleep. :o)
18:03:36 <jmnoz> so with string I can do "foo" ++ "bar" ++ "baz", can I use Data.ByteString.append like this?
18:03:51 <monochrom> what is the type?
18:03:56 <monochrom> @type BS.append
18:03:56 <jmnoz> ByteString
18:03:57 <lambdabot> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
18:04:49 <monochrom> you need to be more precise about types. but yes, the type answers your question.
18:05:11 <monochrom> Indeed, in order for types to answer questions, you need to be precise about types.
18:05:24 <monochrom> the type of && is not going to be just "Bool".
18:05:53 <lpaste> Gurkenglas pasted “ij, try this?” at http://lpaste.net/350139
18:06:53 <jmnoz> monochrom: roger, thanks
18:08:15 <jmnoz> just curious, could (++) not be made to function as `append` if the type is ByteString? Why is this not done?
18:09:07 <ij> Gurkenglas, I will try it in a couple of days when I have more time, sorry. :/
18:09:45 <monochrom> Several people did it but no one uses it.
18:09:50 <Lokathor> monochrom, you mentioned -O in comparison with -O2, but is there a reason to not just use -O2? (assuming that you want optimizations in the build to begin with)
18:09:55 <glguy> jmnoz: ++ is specifically defined to work with lists, but Data.Monoid has <>, and that can work with bytestrings and lists both
18:10:44 <monochrom> I don't know.
18:11:27 <monochrom> There has been a lot of hearsay and no data on the pros and cons of -O2
18:11:41 <monochrom> but cabal still defaults to -O
18:12:33 <monochrom> but see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#O2 for how to config this across the board. you wouldn't believe it could be done like this :)
18:13:52 <Lokathor> monochrom, hmmmm
18:19:43 <Lokathor> wiki says there's no big difference between 0 and 02
18:19:50 <Lokathor> er, O and O2
18:23:06 <Rotaerk> O is generally an ion, O2 is crucial for life
18:23:36 <Lokathor> not so
18:23:51 <Myrl-saki> ...
18:23:53 <pacak> O2 is not the same as O₂
18:23:58 <Myrl-saki> =_=
18:23:59 <Lokathor> i am a robot living in the future transmitting EM radiation into the past to masquerade as an IRC user
18:24:06 <MarcelineVQ> you too?
18:24:23 <Lokathor> MarcelineVQ, aren't you a vampire and not a robot?
18:24:29 <MarcelineVQ> my friend, let me tell you about tachyons
18:24:55 <Myrl-saki> I feel ashamed I get the references.
18:24:58 <Myrl-saki> *sigh*
18:25:16 <Myrl-saki> Well, only one reference.
18:25:46 <Lokathor> don't worry, if you can brave the anti-entropic fields then you can join me in the future by just stepping through the time tombs
18:25:54 <Lokathor> there ^, two references
18:26:28 <Myrl-saki> Too young to get the references, sorry. :(
18:26:42 <Lokathor> mine is only from the 90s!
18:26:53 <MarcelineVQ> cantos and canticles
18:27:42 <Lokathor> oh my gosg, reference got / 10
18:28:31 <Lokathor> well, i don't know what "canticles" is, i've heard of A Canticle for Leibowitz, but don't recall any tachyeons unless there's some time travel in the last 8th of the book i never read
18:30:02 <MarcelineVQ> only forwards
18:30:30 <Lokathor> yeah i was up into the bit where the guy gets sent to another colony last time i was reading it
18:30:43 <MarcelineVQ> /sendbuffer #haskell-offtopic it's all spirals though
18:50:43 <shapr> for anyone doing Advent of Code, should day seventeen part two take a really long time to run?
18:52:13 <ania123> can one help me?
18:52:31 <ania123> I want to give students following problems in the exam
18:52:49 <ania123> can one look it whether it is stated clearly ?
18:52:49 <ania123> http://pastebin.com/FuTTE5zL
18:54:24 <c_wraith> ania123: clear enough, though I might argue that without specifying types, 1 is technically impossible to answer. :)
18:55:04 <mniip> map map (>3)? that's an ill type
18:55:30 <c_wraith> ania123: I might also specify a type for minimum in problem 2 - unless it's part of the problem to figure out the correct type.
18:55:49 <c_wraith> hmm, yes, I glossed right over that typo.
18:56:22 <mniip> does 2) expect a solution like \(x:xs) -> foldr min x xs?
18:56:32 <mniip> or foldr1 min
18:57:40 <ania123> mniip: it is typo
18:59:35 <ania123> 4) Define a function perms that returns all permutations of a given list. 
18:59:47 <ania123> is it clear stated?
18:59:58 <c_wraith> that's massively harder than the first 3.
19:00:04 <c_wraith> Is that jump in difficulty intended?
19:00:23 <ania123> 4) Define a function perms that returns all permutations of a given list. For example: > perms [ 1 , 2 , 3 ] [ [ 1 , 2 , 3 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 1 ] , [ 1 , 3 , 2 ] , [ 3 , 1 , 2 ] , [ 3 , 2 , 1 ] ]
19:00:24 <mniip> indeed, it is much harder
19:00:41 <mniip> no, the problem is very clearly stated,
19:00:52 <mniip> but solving it requires much more skill
19:01:57 <ania123> agree
19:02:02 <ania123> let me change...
19:02:41 <mniip> I don't know of a readable solution that wouldn't use the list monad or list comprehensions
19:03:01 <ania123> 4) Define a function subs that returns all subsequences of a list. For example: > subs [ 1 , 2 ] [ [ ] , [ 2 ] , [ 1 ] , [ 1 , 2 ] ]
19:03:45 <c_wraith> > filterM (const [False, True]) [1,2]
19:03:47 <lambdabot>  [[],[2],[1],[1,2]]
19:03:52 <mniip> list monad
19:04:14 <ania123> ?
19:04:15 <c_wraith> That's a lot less difficult, though, even without filterM
19:04:22 <ania123> is it clear stated? 
19:04:27 <monochrom> ania123: that is ambiguous and the example doesn't help because what happens to "subs [1,2,3]", will [1,3] be part of the answer?
19:04:54 <monochrom> it will cause your students to have very loud debates on what "subsequence" means.
19:04:59 <uiop> anachrome: in other words, do you mean subsequences or subsets\
19:05:20 <c_wraith> subsets is a third thing
19:05:22 <uiop> anachrome: err, and if subsequences, what are the rules
19:05:27 <ania123> subsets 
19:05:33 <monochrom> no, "subset" is orthogonal.
19:05:47 <uiop> anachrome: my bad meant ania123 
19:06:15 <petercommand> orthogonal?
19:06:31 <uiop> monochrom: yeah i read "subsets" first time i read your msg, but you meant "clarify your def of sebsequences"
19:07:31 <uiop> <monochrom> ania123: that is ambiguous and the example doesn't help because what happens to "subs [1,2,3]", will [1,3] be part of the answer?
19:07:48 <uiop> monochrom: actually, if [1,3] is part of the answer, then is that not "subsets"?
19:07:58 * uiop thinks
19:08:01 <mniip> uiop, "sets" implies uniqueness of every element
19:08:05 <mniip> hence "orthogonal"
19:08:09 <uiop> mniip: oh yes good point
19:08:17 <monochrom> "subset" would accept [3,1]
19:08:56 <monochrom> more pedantically [] is not set and prepending [] to be set is morally wrong
19:09:18 <uiop> monochrom: only if [1,3] isnt equivalent to [3,1], since if it was subsets we'd apriori be considering order to be unimportant presumably, but yes
19:09:28 <monochrom> s/prepending/pretending/
19:10:00 <ania123>  subs [1,2,3] [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
19:10:19 <monochrom> no no, if you asked me to implement subset, then subset [1,2] = [[], [2,1], [1], [2]] would be accpetable.
19:10:24 <uiop> tbh i was reading two things at once and ended up defending a hypothetical based on a misreading, which i strove to valiantly ;)
19:10:56 <uiop> monochrom: if you need to use "sort" for every (==), why not maintain a sorted invariant?
19:11:04 * uiop playes devils advocate
19:11:21 <monochrom> but I am not using sort for every (==)
19:12:27 <uiop> monochrom: touche, i should have said equalsConsideredAsSets :: (Eq a) => [a] -> [a] -> Bool
19:12:51 <uiop> but im not sure what we're really talking about anymore
19:14:02 <uiop> *s/Eq/Ord/ in equalsConsideredAsSets
19:14:08 <uiop> since i want sort!
19:14:19 <ania123> last question :)
19:14:21 <ania123> 5) Using examples explain pros and cons of lazy evaluation 
19:14:51 <monochrom> That is a good question.
19:15:08 <monochrom> But be sure to give 0 marks to those who give no examples.
19:15:36 <ania123> monochrom: could you please reformulate this question in a such a way to be more clear?
19:15:44 <ania123> my first language is not english :(
19:15:50 <monochrom> This should not be an essay-writing contest. Programming never is. This should be an empirical contest. Programming has always been.
19:15:57 <ania123> is there any english error
19:15:58 <ania123> ?
19:16:10 <monochrom> It is already clear.
19:16:33 <ania123> is there any english grammar error?
19:16:55 <monochrom> Oh, maybe s/explain pros/explain the pros/
19:17:50 <ania123> 5) Using examples explain the pros and the cons of the lazy evaluation method 
19:17:52 <ania123> like this?
19:18:13 <monochrom> I think you just need one "the". "pros and cons" is an idiom.
19:18:42 <ania123> is your mother langiage english?
19:18:53 <monochrom> no, but you won't tell the difference
19:19:00 <ania123> 5) Using examples explain the pros and cons of the lazy evaluation method 
19:19:02 <uiop> mine is and i agree with monochrom 
19:19:04 <ania123> is it ok no?
19:19:16 <Clint> yes
19:19:25 <ania123> thx
19:19:37 <Clint> you should put a comma after "examples"
19:19:41 <ania123> the article is neede in front of lazy?
19:19:44 <kadoban> Could probably use a comma. Using examples, explain the pros and cons of lazy evaluation.  <-- also the last part I'd word like that
19:20:07 <monochrom> yeah there is no need to add "the method"
19:20:08 <uiop> ania123: yes
19:20:22 <uiop> or just lazy evaluation
19:20:27 <ania123> thx
19:20:28 <sophiag> really simple question, but i'm having trouble figuring out the correct syntax: how do i map printing the same value over a series of monads? so if my main looks like: do contents <- getContents; print $ m1 contents; print $ m2 contents; print $ m3 contents; etc.?
19:21:13 <ania123> http://pastebin.com/3zi0kGuf
19:21:19 <ania123> I would be very happy
19:21:26 <ania123> if you can look it once more
19:21:26 <uiop> sophiag: mapM_ print . fmap ($ contents) $ [m1,m2,m3]
19:21:29 <kadoban> mapM_ print $ zipWith ($ contents) [m1, m2, m3]  ?
19:21:32 <ania123> and point me for english errors
19:21:35 <kadoban> Err, not zipWith, ya.
19:22:15 <sophiag> uiop: thanks. i thought i tried that, but must have gotten some part of the syntax wrong
19:22:33 <monochrom> maybe you used too many $'s last time
19:22:39 <sophiag> or maybe i tried mapM_ and fmap but separately
19:23:27 <sophiag> i think the issue is you need to compose mapM_ for print and fmap for the argument?
19:23:42 <sophiag> i surely didn't understand that to begin with
19:23:42 <uiop> sophiag: you can do (print . ($ contents) in a single mapM_, but imo separating IO part from non-IO part in a mapM_ and an fmap is cleaner
19:23:52 <MarcelineVQ> are m1 m2 m3 the same type?
19:24:02 <sophiag> no, they're not...
19:24:13 <sophiag> so i probably can't do that, right?
19:24:16 <uiop> good point MarcelineVQ 
19:24:22 <uiop> sophiag: no
19:24:35 <sophiag> liftM?
19:24:52 <uiop> :t [liftM, fmap]
19:24:52 <monochrom> No, you simply can't build the list [m1, m2, m3] in the first place.
19:24:53 <lambdabot> Monad m => [(a -> r) -> m a -> m r]
19:25:06 <Koterpillar> ania123: what is the language the course is taught in?
19:25:47 <monochrom> a simpler example is you can't have "map show [(), False, 34]" because you can't have that list to begin with. It does not matter how "map show" is alright.
19:26:02 <nitrix> Hi, this might appear curious from an intermediate level haskeller, but despite the relative ease to use and combine (and reason) about StateT, if a large size of an application happens in such monad, isn't it essentially equivalent to a global variable? And as such, it seems to me there's actually very little control over the effects.
19:26:06 <monochrom> @quote monochrom river
19:26:06 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
19:26:06 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
19:26:06 <lambdabot> show the_boolean, show the_character, show the_integer]
19:26:52 <sophiag> oh, that simple?
19:27:03 <byorgey> nitrix: indeed
19:29:00 <sophiag> so if i wanted to do it without parentheses could i do this? mapM_ $ print . $ contents $ [show m1, show m2, show m3]
19:29:21 <monochrom> You got the wrong message.
19:29:32 <sophiag> ah, crossed wires?
19:30:19 <uiop> let x = contents in mapM_ print [m1 x, m2 x, m3 x]
19:30:43 <kadoban> nitrix: Only difference I can think of is that at least what the state is will be explicit. But quite similar.
19:30:54 <uiop> sophiag: in other words, 
19:30:57 <uiop> mapM_ print [m1 contents, m2 contents, m3 contents]
19:31:00 <uiop> is the best you can do
19:31:07 <sophiag> ah gotcha
19:31:11 <nitrix> kadoban: In that regard, I'm starting to see some of the benefits of FRP here.
19:31:36 <monochrom> no, why are m1, m2, m3 of different types?
19:31:53 <monochrom> contents :: String is true across the board
19:32:24 <monochrom> This means m1 :: String -> ???, m2 :: String -> ??? and the ??? part has to differ
19:32:33 <nitrix> kadoban: Assuming the application is defined such that some time-varying values are based of others; suddently it's a lot less scary to have such "global mutation" happens, as the parts of the program involved with it immediatly would know.
19:32:47 <monochrom> This means [m1 content, m2 content] is still not going to type-check
19:32:53 <uiop> monochrom: oh good catch
19:33:53 <uiop> mapM_ print . fmap ($ contents) $ [show . m1, show . m2, show . m3]
19:33:55 <kadoban> nitrix: Yeah, I still don't understand FRP that well, but the times I've written stuff in reflex it's been quite a joy, especilaly in that regard.
19:34:09 <sophiag> ah cool
19:34:12 <uiop> so monochromes quote applies even more literally here
19:34:26 <sophiag> yeah, that's what i was thinking before
19:34:27 <nitrix> kadoban: byorgey I appreciate the feedback. I'm just making a lot of realisations lately :)
19:34:37 <byorgey> except you don't want to 'show' and then 'print', you want to 'show' and then 'putStrLn'.
19:34:38 <kadoban> :)
19:34:42 <byorgey> 'print' includes a call to 'show' already.
19:34:45 <uiop> sophiag: and s/print/putStrLn/
19:34:45 <nitrix> Sorry for the rubber ducking, hehe :p
19:34:55 <byorgey> nitrix: sure =)
19:35:26 <sophiag> ah, ok
19:35:36 <sophiag> and also i could get rid of the fmap if i wanted?
19:35:56 <uiop> mapM_ f . fmap g === mapM_ (f . g)
19:36:58 <sophiag> so would this work? mapM_ putStrLn . $ contents $ [show . m1, show . m2, show . m3]
19:37:24 <uiop> you need to wrap in parentheses when you're partially applying an infix operator
19:37:39 <uiop> in other words "$ contents" ===> "($ contents)"
19:37:44 <sophiag> ah ok
19:37:51 <uiop> and also you need more parenthese than that too
19:38:07 <sophiag> mapM_ (putStrLn . ($ contents $) [show . m1, show . m2, show . m3])
19:38:25 <sophiag> oops
19:38:26 <uiop> almost
19:38:29 <sophiag> yeah i know
19:38:40 <sophiag> mapM_ (putStrLn . ($ contents) $ [show . m1, show . m2, show . m3])
19:38:51 <uiop> almost
19:38:56 <sophiag> ahok
19:39:06 <sophiag> mapM_ (putStrLn . ($ contents)) $ [show . m1, show . m2, show . m3]
19:39:16 <uiop> got it
19:39:22 <sophiag> lol thanks
19:39:27 <uiop> heh np
19:40:07 <sophiag> also i'm not sure what i changed, but getContents is working when i pipe strings in with cat, but not just taking a string as an argument
19:40:27 <uiop> becuase argv isnt stdin ;)
19:40:38 <monochrom> getContent does not read from arguments
19:41:08 <sophiag> huh, i thought i had it doing that before. must have been confused
19:41:25 <sophiag> i was probably using getArgs !! 0
19:42:31 <m5> is this the right place to ask for haskell help, or is it more a discussion of the langue?
19:43:20 <ania123> Koterpillar: Georgian, but university police is to have questions in english and in georgian
19:43:24 <kadoban> m5: Yep, both are welcome
19:45:01 <m5> I'm trying to write an Amazon Mechanical Turk client, and I want to the operation on creation, but it looks awkward
19:45:06 <m5> http://pastebin.com/SmaB1Ug2
19:45:30 <sophiag> uiop: wait, how would make it so it can read both a string on the command line and piped from a file?
19:45:58 <m5> *(to validate the operation)
19:48:58 <uiop> sophiag: you'd have to call both getArgs and getContents, then do whatever you have in mind with those two pieces of data
19:49:08 <m5> I want the mkSearchHITs to return an Either failure string if one of the validations fail, but I don't know how to do that (http://pastebin.com/SmaB1Ug2)
19:49:59 <sophiag> uiop: hmm...so like have a conditional where i check if they're empty? or just concat them assuming one is empty?
19:50:45 <uiop> sophiag: if that is the logic you have in mind, then yes
19:51:48 <uiop> in other words, getArgs and getContents will provide you with the raw data you need to implement the "smart input data gatherer" you're hinting at
19:52:07 <sophiag> i'm thinking there's probably a smarter way to go about that. like send both into an Either type and have it fail if it's empty?
19:52:59 <m5> Thank you for the reply!
19:53:26 <m5> I'm trying to have the whole mkSearchHITs fail if any of the "validations" fail
19:53:58 <riaqn> Hello, where can I learn some compilation techniques for FP, and optimizations, etc.?
19:54:54 <hodapp> hmmm, I believe SPJ has some good papers on those topics
19:55:11 <m5> oh whoops...I realize now that you weren't talking to me...awkward
19:55:58 <sophiag> oh haha np
20:02:39 <sophiag> so i can't just do: content <- getContents; args <- getArgs; text <- contents : (args !! 0);
20:02:55 <Koterpillar> sophiag: you have to use readFile
20:03:13 <sophiag> i don't actually want to read a file tho
20:03:35 <Koterpillar> still, types don't match
20:03:40 <Koterpillar> :t getArgs
20:03:41 <lambdabot> error: Variable not in scope: getArgs
20:03:55 <sophiag> yeah that's the error, but i thought they were both strings
20:04:01 <Koterpillar> ++
20:04:10 <Koterpillar> > "both" ++ "strings"
20:04:11 <sophiag> i tried with both : and ++
20:04:13 <lambdabot>  "bothstrings"
20:04:33 <sophiag> i get a type mismatch error either way
20:04:36 <Koterpillar> show what happens with ++
20:06:38 <sophiag> "Couldn't match type ‘[]’ with ‘IO’; Expected type: IO Char; Actual type: [Char]"
20:09:02 <Cale> Looks like you tried to use a String as if it were an IO action, or vice-versa
20:10:37 <Clint> sophiag: what do you want "text <- contents : (args !! 0)" to do
20:10:58 <sophiag> it just seemed like an easy hack since one or the other would be empty
20:11:17 <sophiag> so that way i could either supply a string as an argument or pipe strings in
20:12:30 <Koterpillar> sophiag: good point; let text = ...
20:15:51 <Cale> sophiag: When you write v <- x it means "execute the action x, and name its result v" -- in order for that to work, x needs to be an action in whatever monad it is you're hoping to use.
20:16:22 <Cale> sophiag: Contrast this with  let v = x  which simply defines v to be the same thing as x.
20:16:33 <sophiag> Koterpillar: that compiles, but worst of both worlds when it runs...obviously i'm not getting command line args since they're at the end and getContents is failing, but not sure why that's happening. it says "Prelude.!!: index too large"
20:17:09 <Cale> Perhaps args is empty?
20:17:16 <sophiag> Cale: thanks, that's a better explanation than i've gotten so far. explains a lot in terms of errors i get inside main
20:17:48 <sophiag> yeah, the idea was that one or the other would be empty
20:18:16 <Clint> you're not explicitly handling either failure
20:18:26 <sophiag> no, it's kind of a hack
20:18:34 <Cale> case (contents ++ args) of (x:_) -> ... ?
20:18:50 <Cale> actually those first parens are unnecessary
20:19:20 <sophiag> oh that's easy. lemme try it
20:20:18 <Cale> That also gives you the opportunity to handle the case when they're both empty
20:20:59 <Cale> I'm not sure what types they have, maybe that should be contents : args
20:21:01 <Cale> or something
20:21:04 <Cale> er...
20:21:18 <Cale> Well, that wouldn't work
20:21:21 <uiop> concat args
20:21:26 <uiop> would go along with theme
20:21:34 <Cale> You'd want to match on whether contents was empty or not and use args accordingly perhaps
20:21:43 <Cale> Or vice versa
20:22:00 <Cale> I haven't seen the overall program, so I'm just guessing a bit
20:22:59 <sophiag> yeah it's throwing an error if i try (_:x) ->
20:23:18 <Cale> (_:x) would be the tail of the list
20:23:34 <Cale> What do we actually want to express, and what are the types of the things involved?
20:23:40 <sophiag> they're strings, but it seems consing them would be more straightforward if it doesn't matter
20:23:58 <Cale> Both contents and args are strings? Or is args a list of strings?
20:24:12 <sophiag> args is a list of strings
20:24:41 <Cale> Okay, so if there are args, you want to use those, and only if args is empty, use contents?
20:25:03 <sophiag> or vice versa
20:25:34 <Cale> Should contents count as if it was a single arg, or do we want to do something to combine the args?
20:26:04 <Cale> i.e. are we producing a list of strings, or a single string?
20:26:14 <sophiag> a single string
20:28:07 <Cale> So perhaps we want to do something like  let text = case args of [] -> contents; (_:_) -> unwords args
20:28:28 <Cale> (which would combine together the args with spaces in between)
20:28:44 <Cale> We could also just take the first arg in that case, by matching it
20:32:55 <sophiag> i'm confused as to why this isn't working: http://lpaste.net/350143
20:34:27 <shapr> Cale: is there some obvious reason why line 36 doesn't terminate? https://github.com/shapr/adventofcode2016/blob/master/src/Seventeen/Main.hs 
20:36:33 <shapr> I will assume it's not obvious.
20:37:05 <Cale> Yeah, I don't see an obvious reason, I think I'd have to understand what you're computing
20:37:14 <Cale> What output do you get?
20:37:29 <Cale> It looks like you're doing a graph search of sorts?
20:37:30 <shapr> I get the correct output, but then it sits and spins forever.
20:37:42 <shapr> Yes, I'm solving adventofcode.com/ day seventeen
20:38:25 <MarcelineVQ> iterate is a good place to focus on when it comes to non-termination
20:39:42 <shapr> oh, I bet it's returning a pile of empty lists
20:40:05 <shapr> well dang
20:43:01 <Cale> Ah, I see, the reason you're not accounting for cycles is that this is potentially an infinitely large maze :)
20:43:29 <Cale> (and you can't really retrace your steps, walking around in a square really gets you somewhere new)
20:44:47 <sophiag> oh wow, my whole issue with the case expression was a matter of whitespace... going to have to get used to this ;p
20:45:04 <sophiag> didn't mean for that emoji to be winking, but i suppose it fits :p
20:45:33 <Cale> sophiag: Yeah, 'of', 'where', 'do', and 'let' are layout keywords -- the first non-whitespace character which follows them sets the indentation level for the following block
20:46:05 <Cale> Subsequent lines which start in the same column as that character will be part of the block. Any line starting in a shallower column will close the block.
20:46:23 <Cale> (Lines which start at a deeper column will be treated as a continuation of the previous line)
20:49:28 <sophiag> yeah i'm coming from a lisp background mostly so not used to having to think about that
20:49:35 <sophiag> although i prefer the brevity
20:50:26 <sophiag> it's funny how little "functional programming" is actually helping me with haskell :p
20:54:24 <nitrix> It's probably best to leave that knowledge in a little mental drawer somewhere.
20:55:44 <nitrix> But of my experience on #haskell-beginners, it'll still be somewhat beneficial, be it only for the terminology or breaking the mold.
20:56:09 <geekosaur> "functional programming" is more of a style. Haskell encourages that style, but it is not defined by it; laziness and purity are more important there, and any FP experience you might have won't help much with them
20:56:51 <Maxdamantus> If Lisp were functional, they presumably wouldn't've needed to invent closures; you could just copy the values instead of encapsulating references.
20:57:16 <kadoban> Maxdamantus: For certain definitions of "functional"
20:57:21 <geekosaur> Lisp combines a bunch of things, *some* of which are FP
20:57:23 <riaqn> hodapp: thanks! could you maybe provide some links or keywords?
20:58:16 <Rotaerk> "functional" is too vague an umbrella term to be very useful IMO
20:58:22 <nitrix> It is my understanding that the only requirement for being a functional language are first-class functions / higher-order functions.
20:58:31 <xenon-> Lisp is just as vague :P
20:58:33 <nitrix> Everything else vary, including even purity.
20:58:35 <Rotaerk> should just refer to specific concepts, e.g. laziness, purity, as mentioned above
20:58:45 <kadoban> nitrix: Especially purity.
20:59:04 <Maxdamantus> I think that is orthogonal to "functional".
20:59:25 <kadoban> Maxdamantus: What is?
20:59:28 <Maxdamantus> I can imagine languages that are purely function without higher-order/first-class functions.
20:59:34 <Maxdamantus> purely functional*
20:59:38 <riaqn> well, my understanding of FP is purity.
20:59:45 <Maxdamantus> ^
20:59:50 <nitrix> There's probably a more semantic definiton of functional and a more popularized definition, as it happens so often with other words.
20:59:57 <riaqn> FP without purity, IMHO, is not FP.
21:00:02 * geekosaur started learning Haskell with some experience in various "functional" languages including SML, APL/J, and various Lisps. none of which prepare you for laziness, or pervasive purity
21:00:08 <kadoban> Well ... most languages that people think of as FP aren't pure, AFAIK, so that's a weird definition IMO.
21:00:33 <Maxdamantus> I don't think it needs to be enforced at a language level to be considered functional.
21:00:57 <Maxdamantus> It's just a matter of tending to think in terms of .. functions .. something that just transforms one value into another value.
21:01:01 <riaqn> as many benefits of FP is results of purity. Say, no internal states, so reasoning is easy.
21:01:05 <xenon-> non-haskell programmers likely have looser definition of FP
21:01:29 <shapr> true that
21:01:35 <riaqn> otherwise, C is FP, since there is function pointer, etc.
21:01:39 <kadoban> xenon-: Well, if FP only means what it means to haskell programmers, that doesn't sound good.
21:01:52 <nitrix> It's probably just a matter of exposure. There are really funky languages out there :)
21:01:56 <shapr> I bet non-Smalltalk coders have a looser definition of OOP
21:02:21 <sophiag> wow, i went to push some commits and came back to this discussion i started.lol
21:02:22 <nitrix> shapr: That's a cute one :P
21:02:35 <riaqn> a FP language without benefits of FP, then why we call it FP?
21:02:53 <xenon-> kadoban since there's no consensus on the definition haskell programmers' definition is as good as any other
21:02:59 <sophiag> my lisp background is NOT common lisp... it is largely pure functions, but not entirely. still doesn't translate well to haskell
21:03:14 <Maxdamantus> and more importantly, if FP doesn't mean "working with things that simply transform values into other values", what do you call that?
21:03:18 <kadoban> xenon-: My point would be, if everyone has their own definition, we no longer have words, we have ... I don't even know what.
21:03:24 <riaqn> sophiag: I think even scheme is not pure. you have set-car! or something like that.
21:03:24 <geekosaur> riaqn, I would say FP as such is just the style of *using* functions as first class entities that can be passed around.
21:03:43 <nitrix> riaqn: Because extending the meaning beyond its definition is edging elitism.
21:03:44 <geekosaur> I would also say that laziness and purity vastly expand what you can *do* with that style
21:03:45 <riaqn> geekosaur: yes, of course it's very subjective. just expressing my thoughts.
21:04:12 <xenon-> kadoban, the fact that we can't even agree in #haskell should make it clear that there's no consensus
21:04:14 <kadoban> xenon-: Scheme coders think Scheme defines what FP is. Haskell programmers think haskell defines what FP is, same for clojure, etc. The term seems to come to mean "acts like the language I lke".
21:04:25 <nitrix> riaqn: The guarantees and safety that we like to have in a functional language (some of which Haskell adopted) aren't mendatory for a functional language.
21:04:29 <sophiag> riaqn: it's just not enforced... recently i've mostly used Clojure, which is the purest lisp, but you can still mutate values all you want. same with OCaml
21:04:46 <Maxdamantus> 18:02:51 < geekosaur> riaqn, I would say FP as such is just the style of *using* functions as first class entities that can be passed around.
21:04:50 <Maxdamantus> That's exactly what HOP is.
21:04:59 <Maxdamantus> well, at least HOP over functions.
21:05:16 <Maxdamantus> theoretically you could do HOP over other things, but the obvious thing is functions.
21:05:24 <sophiag> i'm just saying in general for me immutability is a less of a paradigm shift than working with haskell's type system
21:05:39 <sophiag> like it took a little thinking when i was learning lisp, but not as much as i'm going through now
21:06:25 <xenon-> kadoban or "act as the only functional language I know"
21:06:37 <xenon-> or the functional language i like the most
21:07:03 <sophiag> and you could argue about scheme...people really don't use all the set-whatever! functions much, but you still generally mutate values unlike idiomatic Clojure. the definition of FP has changed a lot over several decades
21:07:45 <Lokathor> http://lpaste.net/350145 so I want to make a module that re-exports the platform specific version of code
21:07:52 <Lokathor> but GHC says i'm making a module export itself
21:08:09 <xenon-> yeah lisp and scheme are about as functional as python. the only difference is in the community and attitude toward FP
21:08:11 <riaqn> I would call lisp-like languages "macro-programming", as most of its power is resulted from the raw exposure of AST and the ability to manipulate it.
21:08:34 <riaqn> otherwise it's nothing.
21:08:35 <codygman> What data type will be fastest for lookups? Right now I'm inserting a lot of values into a Data.Map and some useless constant value, but I'm considering using Data.Hashmap. Is there any structure that could give me better than O(log n) lookups?
21:09:10 <sophiag> riaqn: except homoiconicity doesn't imply macros. Scheme doesn't use macros nearly as much as CL
21:09:38 <geekosaur> Lokathor, what's the module declaration in Control\Console\Win32.hs?
21:09:42 <xenon-> racket uses macros more than CL
21:09:45 <kadoban> codygman: Arrays, vectors, IntMap kind of. I think Hashmap is a wrapper around something like IntMap, unless I'm mistaken (could be)
21:09:51 <riaqn> sophiag: by homoiconicity you mean "code is data"?
21:10:01 <Lokathor> geekosaur, module Control.Console.Win32 ( ...
21:10:06 <sophiag> yup, p much
21:10:11 <riaqn> well, that's another result of the exposure of raw AST.
21:10:16 <sophiag> i'm sure there's a more technical definition
21:10:38 <sophiag> yeah, that is the main defining feature of all lisps
21:10:44 <codygman> kadoban: I know that hashmap's in other languages have O(n) lookup but Haskell's seem to be O(log n). I think the best I can go with for now is Hashmap.
21:10:49 <geekosaur> hm.
21:10:53 <riaqn> and what I was "manipulate it(AST)"
21:11:00 <riaqn> and what I was saying *
21:11:10 <sophiag> yeah i get it
21:11:46 <geekosaur> codygman, most languages lie about it
21:11:47 <sophiag> that was wadler's whole point when he wrote that essay about sicp. homoiconicity is confusing, essentially
21:12:17 <codygman> geekosaur: Oh? Do tell me more :)
21:12:28 <Lokathor> sophiag, essay?
21:12:39 <sophiag> Lokathor: one sec, lemme find it
21:12:46 <kadoban> codygman: It's a bit of a corner case of asymptotic notation, is the kind interpretation. Here's a question: how many bits does it take to encode an address, if you need to address N items?
21:13:06 <sophiag> Lokathor: https://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
21:14:07 <geekosaur> what kadoban said, basically. there's also aspects that tend to get ignored as not part of the "real work": hashing itself, possibly dealing with collisions (or the overhead of trying to avoid them), etc.
21:14:58 <geekosaur> there's also that laziness tends to alter it in the sense that you pay for things at different times than you would in a completely strict context
21:15:41 <geekosaur> ...and Haskellers kinda need to know that bit, so we're generally more careful about our big-Os and any special cases that affect them
21:17:11 <geekosaur> so it's not a lie in the sense of being deliberately misleading, so much as "this is the part you probably need to care about" --- but in Haskell you need to care about a bit more
21:17:31 <geekosaur> after all, big-O is about approximations.
21:18:11 <geekosaur> and assumptions, some of which don't hold in Haskell
21:19:44 <geekosaur> Lokathor, I'm still looking at this thing and am not seeing it --- I think we need to see more to figure out what's going on
21:20:08 <geekosaur> like, more than just this module
21:20:19 <riaqn> Well, I think we have to talk about the gap between models.
21:20:19 <Lokathor> geekosaur, same thing happened in #haskell-beginner, https://github.com/Lokathor/galaxy-break here's the entire current code as a repo
21:20:19 <geekosaur> any chance you can toss the whole thing onto github/gist or etc.?
21:20:24 <geekosaur> hah
21:20:30 <Lokathor> only about 3 haskell files there
21:20:33 <riaqn> classical complexity talks about algorithms on turing machines.
21:20:41 <riaqn> but Haskell is not turing machine.
21:20:55 <Lokathor> riaqn, oh?
21:21:06 <Lokathor> this is mildly news to me
21:21:17 <riaqn> So the real think we are talking here is: "what this haskel program, compiled by GHC to a turing machine language, will behave in time complexity?"
21:21:45 <riaqn> Lokathor: of course Haskell is turing-complete, but the model is totally diferent.
21:21:58 <geekosaur> Lokathor, this may or may not be the cause of your problem --- but rename either the Windows interface module or its C inclusion
21:22:14 <geekosaur> because both will attempt to create lib\Control\Console\Win32.o
21:23:12 <Lokathor> geekosaur, the C file is auto-generated by inline-c using template magic that I don't know the details of
21:23:14 <geekosaur> (under dist, but still they will fight over the same output filename)
21:23:18 <geekosaur> oh, grrr
21:23:29 <geekosaur> right, and this is a known screw case with inline-c
21:23:31 <Lokathor> but if i don't try this re-export thingy the inline-c works fine
21:23:32 <geekosaur> :/
21:23:54 <Lokathor> i could just give up on trying to be fancy with the CPP
21:23:55 <geekosaur> I gather it works under some circumstances and fails badly in others
21:25:17 <codygman> I'm trying to write a join function with pipes, but I'm not quite sure how multiple inputs to a pipe should look. Anyone have ideas or examples?
21:25:49 <geekosaur> hm. so this looks like it should otherwise work to me :/
21:26:16 <geekosaur> and I can't try it locally as I don't have a win32 dev environment (or the extra memory to set up one that would be usable)
21:27:14 <Lokathor> geekosaur, MarcelineVQ solved it. The flag was the problem, if i change it to not match with any of the module naming suff it works
21:27:28 <geekosaur> ..... oy
21:27:49 <geekosaur> yeh, I can see that, except that `Control.Console.` should not be a legal module name
21:27:56 <geekosaur> (with the trailing dot)
21:28:31 <geekosaur> arguably something should be throwing a better error there, although this may actually be the Cabal library and not ghc that is doing the wrong thing
21:28:50 <geekosaur> I'd file that as a Cabal bug
21:29:07 <Lokathor> where does one file cabal bugs
21:29:38 <geekosaur> https://github.com/haskell/cabal/issues
21:29:41 <Cale> codygman: Pipes' Proxy type is already a monad, so you should be able to join...
21:29:52 <Cale> codygman: Unless you mean something different
21:30:02 <codygman> Cale: I mean like a database inner join
21:30:13 <Cale> ah
21:30:14 <codygman> Cale: so I'll need to take a left and right source as input
21:31:44 <Cale> codygman: Perhaps ListT will do what you want
21:32:34 <Cale> codygman: You could write something like  enumerate $ liftM2 (,) (Select producer1) (Select producer2)  to get a full join
21:32:53 <Lokathor> geekosaur, the CPP is part of cabal?
21:32:54 <Cale> (just a Cartesian product of all possible combinations)
21:33:27 <codygman> Cale: I've been implementing joins by just creating lookup tables with maps. It didn't seem like generating the cartesian product was very efficient
21:33:33 <geekosaur> Lokathor, no, but after CPP is applied to the module its declaration reads "module Control.Console. (..."
21:33:57 <Cale> Well, it certainly isn't...
21:33:58 <geekosaur> which should be illegal. but ghc isn't reading it, Cabal is, and Cabal is just stripping the final dot instead of reporting it as illegal
21:34:33 <Lokathor> ah ha
21:34:40 <Lokathor> that makes my bug report explanation much simpler
21:34:53 <geekosaur> because the phase where it errors out is where Cabal is reading stuff and figuring out what depends on what
21:35:03 <geekosaur> (as invoked by Setup.hs)
21:35:52 <Lokathor> i was not aware that Setup.hs was produced and/or used by stack, I thought stack did its own thing.
21:35:59 <codygman> Cale: :) I need to finish reading up on how databases actually implement joins and steal their tricks
21:36:53 <Cale> codygman: Well, probably Pipes isn't really the place to do it -- you want to build some index data structure, like a Map, and use that
21:37:01 <geekosaur> Lokathor, stack still uses Cabal-the-library, and Cabal-the-library is what reads a custom Setup.hs or uses a default that invokes Cabal-the-library defaults
21:37:36 <geekosaur> and it needs to use Cabal-the-library because that is what provides access (for both ghc and other build tools) to the package databases
21:37:42 <Cale> codygman: In general you may need to fully consume one of your two producers to be able to construct that index and begin doing lookups.
21:38:57 <codygman> Cale: Yeah, here's an example of where I do it just for finding some differences: https://github.com/codygman/frames-diff/blob/master/Frames/Diff.hs#L67
21:40:08 <Cale> As far as I know, the way databases do it is just to store the indices forever and maintain them whenever things get updated.
21:40:31 <Cale> (and if you don't have an appropriate index, you just get shitty performance as you'd expect)
21:41:08 <Lokathor> geekosaur, http://lpaste.net/7053771244310626304
21:41:43 <Lokathor> like that?
21:42:56 <geekosaur> yes
21:43:17 <geekosaur> I'd also mention as a would-be-nice that it check the same thing ghc does for sanity: the filename should match the module name
21:43:21 <geekosaur> which would also have caught this
21:47:31 <MarcelineVQ> I'm able to reproduce this with unrelated code
21:47:46 <MarcelineVQ> rather I can reproduce -Dflagname eating modulenames
21:48:47 <jmnoz> so I'm dabbling with a rss reader. I want to somehow make sure each item - containing html - presented closes all its tags, is there a package for such a thing?
21:55:30 <kadoban> There's w3c's validator, heh. Though I'm not sure RSS is actually close enough to HTML or not.
21:56:27 <Koterpillar> I'm assuming you are generating Atom feeds; yes, there is an Atom validator: https://validator.w3.org/feed/
21:56:55 <jmnoz> no I'm consuming RSS/Atom feeds which contain HTML Fragments in description
21:57:05 <jmnoz> As I'm presenting these fragments, I want to make sure they are well formed
21:57:16 <Koterpillar> ah. So something like Beautiful Soup?
21:57:24 <jmnoz> possibly?? :)
21:59:09 <Koterpillar> tagsoup
21:59:31 <Koterpillar> it parses possibly-malformed HTML, and from there you can generate nice HTML
21:59:42 <jmnoz> excellent, thank you
21:59:53 <Lokathor> write your own HTML parser from scratch, clearly the best option
22:00:02 <kadoban> That's a bit different than validating though, just in case it wasn't clear.
22:17:18 <Lokathor> http://lpaste.net/350146 yay.jpg
22:17:54 <Lokathor> oh man but some of my comments there are all out of date now that lineGrab is in the platformless code
22:26:06 <saurabhnanda> has anyone done real world projects in Haskell AND erlang here? How does the dialyzer stack-up wrt pragmatic typechecking?
22:38:45 <kadoban> What does "Error in array index" actually mean? That's not an index out of bounds, is it? I thought that message was different.
22:43:59 <MarcelineVQ> it's the default error for out of bounds argument to Ix's index function, the type you choose didn't override it possibly :X
22:44:20 <kadoban> Oh, hmm. Okay thanks
22:49:35 <Justatech> does any body has any reousrces to learn assembly languages kind of struggling a bit please hel
22:50:31 <monochrom> Learn Haskell first. It's easier. :)
22:51:24 <monochrom> http://www.happylearnhaskelltutorial.com/
22:56:28 <Justatech> monochrom a video lecture about assembly languages would be great
22:58:45 <tyoverby> what's the easiest way to get started with haskell?  Haskell stack? cabal?
22:59:42 <saurabhnanda> is there a channel for servant?
23:00:21 <MarcelineVQ> #servant
23:12:06 <Lokathor> gotta say, been editing haskell in notepad++ all afternoon, and it's a lot simpler than using emacs
