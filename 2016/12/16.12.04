00:03:40 <codygman> pacak: My next step is trying to raise my own error if the type synonym A already exists. Perhaps my non-working attempt will show you any fundamental misunderstanding I may have here: https://github.com/codygman/th-upsert-typesynonym/blob/master/src/TH.hs#L14
00:10:47 <mari_mari> can someone help me who has access at thomson database?
00:12:37 <pacak> codygman: just "error"?
00:13:40 <codygman> pacak: That's just a placeholder until I get it working, meaning I can look in the environment to see if something exists and then conditionally do one thing or another. I figure that "doing something" is the trivial part after figuring that out.
00:35:27 <mari_mari> can someone help me who has access at thomson database?
00:38:25 * hackagebot parseargs 0.2.0.8 - Full-featured command-line argument parsing library.  https://hackage.haskell.org/package/parseargs-0.2.0.8 (BartonMassey)
00:38:32 <cocreature> mari_mari: if nobody is answering your question there is probably no one that can help you. there is no need to repeat it every 5 minutes
00:58:27 * hackagebot gi-atk 2.0.7 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.7 (inaki)
00:58:29 * hackagebot gi-cairo 1.0.7 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.7 (inaki)
00:58:31 * hackagebot gi-gdk 3.0.7 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.7 (inaki)
00:58:33 * hackagebot gi-gdkpixbuf 2.0.7 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.7 (inaki)
00:58:35 * hackagebot gi-gio 2.0.7 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.7 (inaki)
01:03:37 * hackagebot gi-girepository 1.0.7 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.7 (inaki)
01:03:39 * hackagebot gi-glib 2.0.7 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.7 (inaki)
01:03:41 * hackagebot gi-gobject 2.0.7 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.7 (inaki)
01:03:43 * hackagebot gi-gst 1.0.7 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.7 (inaki)
01:03:45 * hackagebot gi-gstaudio 1.0.7 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.7 (inaki)
01:03:48 <Lokathor> oh no!
01:04:06 <ongy> no?
01:05:31 <MarcelineVQ> no
01:08:47 * hackagebot gi-gstbase 1.0.7 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.7 (inaki)
01:08:49 * hackagebot gi-gstvideo 1.0.7 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.7 (inaki)
01:08:51 * hackagebot gi-gtk 3.0.7 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.7 (inaki)
01:08:53 * hackagebot gi-gtkosxapplication 2.0.7 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.7 (inaki)
01:08:55 * hackagebot gi-gtksource 3.0.7 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.7 (inaki)
01:13:57 * hackagebot gi-javascriptcore 3.0.7 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.7 (inaki)
01:13:59 * hackagebot gi-javascriptcore 4.0.7 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.7 (inaki)
01:14:01 * hackagebot gi-notify 0.7.7 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.7 (inaki)
01:14:03 * hackagebot gi-pango 1.0.7 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.7 (inaki)
01:14:05 * hackagebot gi-pangocairo 1.0.7 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.7 (inaki)
01:19:07 * hackagebot gi-poppler 0.18.7 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.7 (inaki)
01:19:09 * hackagebot gi-soup 2.4.7 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.7 (inaki)
01:19:11 * hackagebot gi-vte 2.91.8 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.8 (inaki)
01:19:13 * hackagebot gi-webkit2 4.0.7 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.7 (inaki)
01:19:15 * hackagebot gi-webkit2webextension 4.0.7 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.7 (inaki)
01:24:17 * hackagebot gi-webkit 3.0.7 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.7 (inaki)
01:24:19 * hackagebot mwc-probability 1.3.0 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.3.0 (JaredTobin)
01:24:21 * hackagebot mcmc-types 1.0.3 - Common types for sampling.  https://hackage.haskell.org/package/mcmc-types-1.0.3 (JaredTobin)
01:24:23 * hackagebot mighty-metropolis 1.0.4 - The Metropolis algorithm.  https://hackage.haskell.org/package/mighty-metropolis-1.0.4 (JaredTobin)
01:24:25 * hackagebot speedy-slice 0.1.5 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.5 (JaredTobin)
01:29:27 * hackagebot hasty-hamiltonian 1.1.5 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.5 (JaredTobin)
01:29:29 * hackagebot declarative 0.3.4 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.3.4 (JaredTobin)
01:43:28 * hackagebot classyplate 0.2.1.0 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.2.1.0 (lazac)
02:03:24 <ocramz> hi all!
02:03:53 <ocramz> is anyone familiar with the internals of `vector-space`? why does it rely on MemoTries ?
02:18:30 * hackagebot classyplate 0.2.2.0 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.2.2.0 (lazac)
02:28:30 * hackagebot generics-sop 0.2.3.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.2.3.0 (AndresLoeh)
02:41:17 <GreatSammy_C> :t 200
02:41:18 <lambdabot> Num t => t
03:03:32 * hackagebot serokell-util 0.1.2.3 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.2.3 (volhovm)
03:31:18 <Hi-Angel> How do you use OverloadedLists extension? I enabled it, imported Data.Vector, but now it asks whether I mean Prelude.any or Data.Vector.any. I could qualify it explicitly as V.any, but, well, couldn't ghc just infer the Vector?
03:31:41 <jle`> Hi-Angel: haskell doesn't do ad-hoc overloading like that
03:31:46 <jle`> Hi-Angel: otherwise you could define too foo's in the same file
03:31:54 <jle`> and expect haskell to just infer which one you mean...?
03:32:28 <jle`> that's the whole reason typeclasses were invented
03:32:37 <jle`> so you wouldn't have crazy things like that, heh
03:32:41 <liste> Hi-Angel: overloadedlists concerns only list literals
03:33:10 <jle`> but, yeah, this issue is unrelated to overloadedlists
03:33:17 <Hi-Angel> jle`: but it's an explicit info here: the function works on Vectors, so I mean Data.Vector.any. I guess the problem arises that ghc couldn't figure out that the function a là "foo :: [a] -> [b]" meant to work on Vectors, not on Lists
03:33:40 <jle`> yeah, that's what i mean by ad-hoc overloading
03:33:55 <jle`> if you use foo :: [a] -> [b], it's supposed to be different than foo :: Vector a -> Vector b ?
03:34:26 <Hi-Angel> jle`: well, is there a way to prohibit the module to think about Lists at all?
03:34:37 <jle`> you can hide the import of foo for lists
03:34:45 <jle`> but normally you'd use vectors by importing it qualified
03:34:49 <jle`> import qualified Data.Vector as V
03:34:52 <jle`> that's how it's meant to be used
03:35:07 <Hi-Angel> Vectors are faster, so I'd like to use them instead of Lists
03:35:17 <Hi-Angel> That's why I enabled OverloadedLists
03:35:39 <jle`> lists have their own use cases; the cases where lists are useful and the cases where vectors are useful has almost no overlap
03:35:50 <jle`> but idiomatic style is that you import vector qualified
03:36:51 <jle`> importing vector unqualified and prelude qualified is definitely...very unusual, and would probably go against almost every style guideline
03:37:02 <jle`> and would probably make your code unreadable to most people
03:37:21 <jle`> but actually you're in luck here because 'any' from Prelude should work on vectors
03:37:32 <jle`> so if you just import qualified Data.Vector as V
03:37:37 <jle`> you should be able to just use 'any' on your vectors
03:37:42 <jle`> and not V.any
03:38:31 <cocreature> jle`: at least for immutable vectors
03:38:38 <jle`> at least for vectors from Data.Vector
03:38:50 <jle`> there are some immutable vectors w/o Foldable instances too
03:38:57 <jle`> but i was referring to Data.Vector vectors :)
03:39:29 <cocreature> jle`: btw I just stumbled upon your hamilton package, cool stuff! looking forward to the explanation of the implementation
03:39:35 <Hi-Angel> well, indeed, qualified fixed the problem too. Thank you!
03:39:39 <jle`> cocreature: thanks!
03:40:04 <jle`> Hi-Angel: no problem :)
03:40:49 <cocreature> jle`: how is the performance? e.g. could you use this to generate fluent animations (so let’s say 30fps)?
03:40:52 <jle`> Hi-Angel: btw, the type of overloading you're thinking about is called "Type-directed name resolution", and for the record, it is something that people do sort of ask for or implicitly expect very often
03:41:22 <jle`> Hi-Angel: but in the end most people agree that it's a bad idea(tm)
03:41:27 * osfameron tries to figure out a link between bezier curves and everyone's favourite rap musical
03:41:38 <jle`> idris has TDNR though.  i wonder how it fares
03:42:27 * osfameron finds https://blog.jle.im/entry/introducing-the-hamilton-library.html and is disappointed to learn it's "just" the name of the scientist, dammit ;-P
03:42:29 <jle`> cocreature: i haven't tried using it for anything other than toy demos but 30fps is pretty comfortable
03:42:57 <cocreature> jle`: cool, I’ll have to write a nanovg frontend for prettier visualizations at some point :)
03:43:15 <jle`> :D let me know if you do
03:43:29 <jle`> right now the limits of my fps is my ssh connection heh
03:43:46 <jle`> osfameron: sorry ;-P
03:44:09 <jle`> osfameron: but if you were looking for a link to the musical in question, there's https://www.youtube.com/watch?v=SZXHoWwBcDc :P
03:44:36 <jle`> s/link/connection
03:44:41 <osfameron> jle`: hehe, thanks
03:45:30 <jle`> cocreature: btw, i remember you asked about when tensor-ops would be ready for an accelerate backend.  it's been "ready" for a while, but i was waiting to implement a neat way to test backends before putting it out there for people to write backends
03:46:04 <cocreature> jle`: ah great, too busy atm to write one but I put it on my list of things to do :)
03:46:44 <jle`> cocreature: but for the record i isolated what needed to be implemented to just this simple BLAS interface
03:46:47 <jle`> https://mstksg.github.io/tensor-ops/TensorOps-BLAS.html#t:BLAS
03:47:25 <jle`> i'm not sure though if it's important to make the results "monadic"/returned in a context
03:47:45 <jle`> my intuition is no, because no control flow branching ever happens and all operations are known up-front
03:48:00 <jle`> but i haven't written anything that works in IO yet.
03:52:17 <myrma> is there a function like bind2 f x y = join (f <$> x <*> y) defined in Control.Monad ?
03:55:03 <jle`> myrma: people ask for this sorta-often, but, no
03:55:43 <jle`> and it's probably doesn't happen often enough to pass the fairbairn threshold
03:55:55 <jle`> fwiw i usually just use do notation for that
03:56:05 <jle`> it's one of the situations that i feel like do notation was specifically designed for :)
03:59:38 <myrma> jle`: ok thanks
04:03:09 <myrma> jle`: what's the faibairn theshold ?
04:03:45 <zof> you are unaware of the faibairn theshold?
04:03:51 <jle`> myrma: sometimes something is rare enough that it takes more effort to remember the name or look it up than it is to just define it/re-implement it
04:04:41 <myrma> jle`: ok thats what I thought but I couldn't find any simple definition, thanks again
04:11:12 <mrkgnao> o/
04:12:02 <matematikaadit> \
04:14:55 <t0by> Hi, I'm sorry. Why don't this code compile? http://pastebin.com/raw/CJDaNFwM
04:15:10 <t0by> In particular I have a data Foo = Foo (MVar Integer)
04:15:40 <t0by> and I try to: main = do (...) m <- newEmptyMVar; foo <- Foo (m) 
04:21:44 <jle`> t0by: what's the error?
04:26:57 <matematikaadit> t0by: instead of `clock <- Clock (m)`, use `let clock = Clock (m)`
04:36:58 <ij> Is it good practice not to include everything but just a list of things if you've got tons of imports?
04:42:04 <ij> Can I also prevent generic (To|From)JSON instances from including a value of MVar type?
04:46:22 <oherrala> ij: I like to import only things I need (it's easier to find where a function comes from), or do qualified imports.
04:52:02 <lyxia> ij: what does it mean for an instance toinclude a value
04:52:43 <ij> Sorry. By that I meant that it wouldn't be included in the JSON, because you can't serialize sockets.
04:53:30 <lyxia> ah.
04:53:40 <lyxia> You can't.
04:53:51 <ij> Oh, but I could just make it be serialized as nothing and give back nothing as well, since MVars are maybe-ish.
04:54:00 <ij> Though the M stands for mutable.
04:54:26 <lyxia> Sure. I don't think Generics give you that level of control
04:54:51 <ij> You couldn't automatically know how to de-serialize it.
04:55:05 <ij> You could theortically prevent values with a prefix from being serialized.
04:55:42 <lyxia> right
04:58:37 * hackagebot publicsuffix 0.20161204 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161204 (wereHamster)
05:03:58 <kuribas> ij: it prevents nameclashes.  It might also give faster compile times.
05:04:25 <ij> Are they noticable?
05:05:05 <kuribas> I never tested it 
05:05:46 <kuribas> I usually don't bother, unless I get clashes.
05:06:02 <kuribas> And for things like Data.Map I always import qualified.
05:07:54 <ij> Me too. I just saw that Data.Aeson has all imports either qualified or restricted and thought it may be a great idea.
05:15:14 <kuribas> Data.Map has a lot of overlap with the Prelude.
05:48:21 <cocreature> jle`: https://mediacrush.coding4.coffee/CYGDf9oIH6Fb :)
05:53:39 * hackagebot dib 0.6.0 - A simple, forward build system.  https://hackage.haskell.org/package/dib-0.6.0 (blajzer)
06:10:57 <obadz> in linear type systems, you can't have any sharing between data structures, can you?
06:30:43 <ertesx> obadz: operationally only one part of the code can ever access a unique value
06:34:17 <codedmart> I have a servant app. I have some func in my app such as emailing the user when certain things happen. The email can fail `Either String Message`. I still send a success back to my user since the actual operation happened successfully. I would like to log things like this? Is `monad-logger` `LoggingT` what I am looking for or do I need something else?
06:36:33 <obadz> ertesx: I don't understand how this limitation translates to what you can do in practice
06:37:15 <ertesx> obadz: you mean how linear types are useful?
06:39:46 <obadz> I assume they're useful because they eliminate the need for both elaborate GC and manual memory management?
06:40:03 <obadz> Is that right?
06:40:17 <c_wraith> ertesx: do language with linear type systems usually give you a primitive to duplicate a value?
06:40:38 <ertesx> obadz: currently we need a separate language for mutable memory like mutable arrays…  with linear types we could just use regular immutable values (semantically)
06:41:11 <c_wraith> Or at least.. flat values.
06:41:12 <ertesx> c_wraith: good question…  i don't know if that would make sense logically, but for individual data types you certainly can have such a function
06:43:05 <ertesx> linear types would be especially useful if we could abstract over uniqueness…  then we could literally use the same APIs for unique and non-unique e.g. arrays
06:44:16 <mettekou> Say I have some monad transformer stacks which each are StateT state wrapped in ExceptT error and only differ in the error and state type variables, but some of these stacks need to use actions from others and grant them access to part of their state. When I expose these actions as pure functions (with an explicit argument for the state and explicitly returning Either error result), this leads to nested calls to either (or case expressions) and
06:44:16 <mettekou>  explicitly extracting the part of the state of one stack the other needs. Is there a better solution to this problem?
06:44:37 <ertesx> obadz: linear/affine types would eliminate pretty much all use cases of ST, and many use cases of IO
06:45:37 <obadz> can a language where all types are linear be useful?
06:46:02 <obadz> or is it only good as an "add-on" ?
06:46:36 <ertesx> i doubt it, but perhaps it would lead to a new paradigm i'm not aware of…  it might be worth exploring =)
06:47:24 <ertesx> but even just writing a function like 'iterate' would become impossible, at least in that straightforward way
06:47:52 <ertesx> iterate f x = x : iterate f (f x)  -- two references: invalid
06:48:41 * hackagebot hasbolt 0.1.0.0 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.0.0 (zmactep)
06:49:49 <obadz> ertesx: right so not turing-complete?
06:53:00 <obadz> Isn't there a result that says that allocated memory release is undecidable in a turing complete language?
06:53:33 <ertesx> obadz: i don't know how linear types interact with recursion…  intuitively i'd say that you need non-unique types for recursion
06:54:18 <ertesx> fix f = let x = f x in x  -- that's two references to 'x', but one of them is a recursion…  logic is always very picky about recursion, and i would expect linear logic to be so, too
06:54:42 <lyxia> mettekou: have you tried mtl
06:54:55 <lucasem> is it possible to write a function is haskell which takes no arguments and returns a count on how often it's been called? I can do something close to this with State but I have to maintain the state between calls, which isn't what I'm going for..
06:55:21 <lyxia> lucasem: it wouldn't be pure
06:55:21 <ertesx> obadz: howevernope
06:55:25 <ertesx> whoops
06:55:36 <ertesx> lucasem: nope…  also there is no function that takes no arguments
06:56:13 <obadz> lucasem: in IO you can..
06:56:27 <lucasem> obadz: tell me more!
06:56:30 <lucasem> :D
06:56:49 <obadz> lucasem: with an IORef no?
06:57:04 <obadz> I suppose that's equivalent to doing it in State, what's wrong with that?
06:57:33 <mettekou> lyxia: I'm using mtl for StateT and ExceptT, but I don't see how I can share part of the state in one ExceptT StateT stack with another. I guess I need the MonadState and MonadError type classes for sharing state and propagating errors respectively?
06:59:04 <lyxia> mettekou: Can you paste some code so I get a better idea of your proble;
06:59:16 <lyxia> s/;/m
06:59:36 <mettekou> lyxia: Sure, I'll try to rework my code into a minimal working example, just a minute.
07:01:09 <cobreadmonster> Hello.
07:01:42 <hodapp> Hello.
07:03:42 * hackagebot hinterface 0.5.0.1 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-0.5.0.1 (SvenHeyll)
07:03:44 * hackagebot b9 0.5.30 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.30 (SvenHeyll)
07:11:41 <nitrix> ertesx: ping (ecs & frp)
07:17:50 <nitrix> ertesx: My question is a big question, but the part that you could answer is: how does Entity Component Systems architechture compares with Functional Reactive Programming?
07:18:04 <ggVGc> nitrix: 42
07:18:18 <nitrix> ggVGc: What does that mean?
07:18:22 <ggVGc> I was making a joke :(
07:18:23 <ggVGc> sorry
07:18:25 * ggVGc hides
07:18:32 <ggVGc> nitrix: the answer to the big question is 42
07:19:03 <nitrix> The 42 one is an even bigger question :P
07:19:04 <ij> lyxia, But I can't "deserialize" MVar to an empty one, because making such a value requies IO, but parseJSON is pure?
07:20:06 <ij> Perhaps I should use unsafe.
07:23:39 <lyxia> ij: I think you shouldn't
07:23:56 <ij> It's probably a bad idea, yes, but isn't it pretty safe though?
07:24:23 <lyxia> I didn't understand why you need unsafePerformIO though
07:24:42 <ij> I want to instantiate an empty MVar.
07:25:25 <ij> Within FromJSON.
07:25:28 <mrkgnao> '"Don't use unsafePerformIO." - Gregor Samsa' - Bartosz Milewski
07:25:43 <mrkgnao> \me goes back into hibernation
07:25:52 <mrkgnao> ...
07:25:58 * mrkgnao tries
07:26:07 <ij> But it would work, right? I'm interested even if I won't use it.
07:26:08 <ertesx> nitrix: pong
07:26:13 * mrkgnao (finally) goes back into hibernation
07:26:15 <ij> Without breaking anything.
07:26:30 <ertesx> nitrix: i couldn't answer that, because i'm not familiar with ECS
07:26:36 <ertesx> nitrix: sorry =/
07:27:03 <nitrix> Want to move to #haskell-game for a moment :) ?
07:27:46 <ertesx> sure
07:30:08 <ij> Is leaving no newline between instances (with where clauses) ok sometimes? I've (To|From) JSON instances for a single datatype that I wouldn't mind keeping together.
07:33:43 * hackagebot amazonka-core 1.4.5 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.5 (BrendanHay)
07:33:45 * hackagebot amazonka 1.4.5 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.5 (BrendanHay)
07:33:47 * hackagebot amazonka-test 1.4.5 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.5 (BrendanHay)
07:33:49 * hackagebot amazonka-elbv2 1.4.5 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elbv2-1.4.5 (BrendanHay)
07:33:51 * hackagebot amazonka-opsworks-cm 1.4.5 - Amazon OpsWorks for Chef Automate SDK.  https://hackage.haskell.org/package/amazonka-opsworks-cm-1.4.5 (BrendanHay)
07:34:28 <mettekou> lyxia: Here you go, https://gist.github.com/mettekou/b775bcabf7753390ea6396632034f5e5.
07:38:53 * hackagebot amazonka-importexport 1.4.5 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.5 (BrendanHay)
07:38:55 * hackagebot amazonka-certificatemanager 1.4.5 - Amazon Certificate Manager SDK.  https://hackage.haskell.org/package/amazonka-certificatemanager-1.4.5 (BrendanHay)
07:38:57 * hackagebot amazonka-elastictranscoder 1.4.5 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.4.5 (BrendanHay)
07:38:59 * hackagebot amazonka-kinesis 1.4.5 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.4.5 (BrendanHay)
07:39:01 * hackagebot amazonka-appstream 1.4.5 - Amazon AppStream SDK.  https://hackage.haskell.org/package/amazonka-appstream-1.4.5 (BrendanHay)
07:44:03 * hackagebot amazonka-cloudsearch-domains 1.4.5 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.4.5 (BrendanHay)
07:44:05 * hackagebot amazonka-dynamodb-streams 1.4.5 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.4.5 (BrendanHay)
07:44:07 * hackagebot amazonka-cloudfront 1.4.5 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.4.5 (BrendanHay)
07:44:09 * hackagebot amazonka-sts 1.4.5 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.4.5 (BrendanHay)
07:44:11 * hackagebot amazonka-cognito-sync 1.4.5 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.4.5 (BrendanHay)
07:46:32 <kuribas> mettekou: why not use mapExceptT and mapStateT?
07:47:01 <kuribas> mettekou: also Error and Error' are almost the same
07:47:39 <mettekou> mettekou: It's a minimal working example, in reality Error and Error' are sum types with multiple branches.
07:47:44 <mettekou> kuribas **
07:49:13 * hackagebot amazonka-elasticache 1.4.5 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.4.5 (BrendanHay)
07:49:15 * hackagebot amazonka-cloudformation 1.4.5 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.4.5 (BrendanHay)
07:49:18 * hackagebot amazonka-emr 1.4.5 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.4.5 (BrendanHay)
07:49:19 * hackagebot amazonka-marketplace-metering 1.4.5 - Amazon Marketplace Metering SDK.  https://hackage.haskell.org/package/amazonka-marketplace-metering-1.4.5 (BrendanHay)
07:49:21 * hackagebot amazonka-kinesis-firehose 1.4.5 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.4.5 (BrendanHay)
07:54:24 * hackagebot amazonka-rekognition 1.4.5 - Amazon Rekognition SDK.  https://hackage.haskell.org/package/amazonka-rekognition-1.4.5 (BrendanHay)
07:54:26 * hackagebot amazonka-swf 1.4.5 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.5 (BrendanHay)
07:54:28 * hackagebot amazonka-kinesis-analytics 1.4.5 - Amazon Kinesis Analytics SDK.  https://hackage.haskell.org/package/amazonka-kinesis-analytics-1.4.5 (BrendanHay)
07:54:30 * hackagebot amazonka-sdb 1.4.5 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.5 (BrendanHay)
07:54:32 * hackagebot amazonka-workspaces 1.4.5 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.4.5 (BrendanHay)
07:55:56 <lyxia> You could express the fact that both states have the same field with a typeclass with a lens
07:56:57 <hexagoxel> mettekou: one of the constructors of the outer Error wraps an inner error?
07:58:04 <mettekou> lyxia: a call to makeClassyLenses for both types handles that automatically, right?
07:59:34 * hackagebot amazonka-rds 1.4.5 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.4.5 (BrendanHay)
07:59:36 * hackagebot amazonka-codedeploy 1.4.5 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.4.5 (BrendanHay)
07:59:38 * hackagebot amazonka-cloudwatch-logs 1.4.5 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.4.5 (BrendanHay)
07:59:40 * hackagebot amazonka-codecommit 1.4.5 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.4.5 (BrendanHay)
07:59:42 * hackagebot amazonka-efs 1.4.5 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.4.5 (BrendanHay)
07:59:54 <lyxia> I can't remember the exact incantation
08:00:09 <mettekou> hexagoxel: Yeah, that's a possibility, but I think the type class approach makes it more flexible.
08:00:13 <lyxia> but I believe it's one of these yes
08:01:37 <mettekou> lyxia: I think another approach would be to create a type class for the monad transformer stack with the narrower type and have the broader one implement it as well?
08:01:55 <lyxia> as for the error that seems a bit oversimplified to mean anything to me
08:01:59 <mettekou> The type class would then expose the actions available to both.
08:02:58 <mettekou> lyxia: Well, my real life use case is a dependently-typed programming language with the type checker (a monad transformer stack) calling the evaluator (another one).
08:04:26 <ggVGc> I still often wonder if the troubles we go through to make our types match up is actually worth it in the long run
08:04:44 * hackagebot amazonka-gamelift 1.4.5 - Amazon GameLift SDK.  https://hackage.haskell.org/package/amazonka-gamelift-1.4.5 (BrendanHay)
08:04:46 * hackagebot amazonka-elasticbeanstalk 1.4.5 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.4.5 (BrendanHay)
08:04:48 * hackagebot amazonka-health 1.4.5 - Amazon Health APIs and Notifications SDK.  https://hackage.haskell.org/package/amazonka-health-1.4.5 (BrendanHay)
08:04:50 * hackagebot amazonka-datapipeline 1.4.5 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.4.5 (BrendanHay)
08:04:52 * hackagebot amazonka-support 1.4.5 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.4.5 (BrendanHay)
08:04:52 <ggVGc> do our programs really get better enough in relation to the work needed to write them 
08:05:37 <c_wraith> It's not like you can ignore type safety in other languages.
08:05:44 <c_wraith> You just get crashes instead of compile errors
08:06:15 <c_wraith> (or weird bugs that are hard to track down)
08:07:21 <lyxia> mettekou: in your example one state type is just a subset of the fields of the others, same for error
08:08:12 <lyxia> If that doesn't actually hold I'm not sure you can do much...
08:09:27 <mettekou> lyxia: It does hold for now, but although I assume it will continue to, it might not. 
08:09:54 * hackagebot amazonka-iot-dataplane 1.4.5 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.4.5 (BrendanHay)
08:09:56 * hackagebot amazonka-sns 1.4.5 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.4.5 (BrendanHay)
08:09:58 * hackagebot amazonka-polly 1.4.5 - Amazon Polly SDK.  https://hackage.haskell.org/package/amazonka-polly-1.4.5 (BrendanHay)
08:10:00 * hackagebot amazonka-cloudtrail 1.4.5 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.4.5 (BrendanHay)
08:10:02 * hackagebot amazonka-opsworks 1.4.5 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.4.5 (BrendanHay)
08:10:12 <Xnuk> amazonka time
08:11:08 <mettekou> lyxia: That's why I propose a MonadEvaluator type class which exposes the methods both stacks need. That should at least confine the wrapping and unwrapping to the instance declaration for the type checker, instead of scattering it everywhere throughout the code.
08:11:52 <mettekou> lyxia: I think Agda takes a similar approach, but I'm not sure.
08:15:04 * hackagebot amazonka-snowball 1.4.5 - Amazon Import/Export Snowball SDK.  https://hackage.haskell.org/package/amazonka-snowball-1.4.5 (BrendanHay)
08:15:06 * hackagebot amazonka-cloudwatch 1.4.5 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.4.5 (BrendanHay)
08:15:08 * hackagebot amazonka-lightsail 1.4.5 - Amazon Lightsail SDK.  https://hackage.haskell.org/package/amazonka-lightsail-1.4.5 (BrendanHay)
08:15:10 * hackagebot amazonka-cognito-identity 1.4.5 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.4.5 (BrendanHay)
08:15:12 * hackagebot amazonka-codepipeline 1.4.5 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.4.5 (BrendanHay)
08:18:02 <lyxia> Can't you just write runEvaluator :: Evaluator a -> TypeCheck a
08:18:04 <ertesx> whenever there is an amazonka update, i fear that ircbrowse might turn into a black hole
08:20:14 * hackagebot amazonka-pinpoint 1.4.5 - Amazon Pinpoint SDK.  https://hackage.haskell.org/package/amazonka-pinpoint-1.4.5 (BrendanHay)
08:20:16 * hackagebot amazonka-ssm 1.4.5 - Amazon Simple Systems Manager (SSM) SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.4.5 (BrendanHay)
08:20:18 * hackagebot amazonka-ml 1.4.5 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.4.5 (BrendanHay)
08:20:20 * hackagebot amazonka-waf 1.4.5 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.4.5 (BrendanHay)
08:20:22 * hackagebot amazonka-ses 1.4.5 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.4.5 (BrendanHay)
08:25:24 * hackagebot amazonka-inspector 1.4.5 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.4.5 (BrendanHay)
08:25:26 * hackagebot amazonka-glacier 1.4.5 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.5 (BrendanHay)
08:25:28 * hackagebot amazonka-sqs 1.4.5 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.4.5 (BrendanHay)
08:25:30 * hackagebot amazonka-iot 1.4.5 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.4.5 (BrendanHay)
08:25:32 * hackagebot amazonka-ds 1.4.5 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.4.5 (BrendanHay)
08:30:34 * hackagebot amazonka-route53 1.4.5 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.4.5 (BrendanHay)
08:30:36 * hackagebot amazonka-cloudsearch 1.4.5 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.4.5 (BrendanHay)
08:30:38 * hackagebot amazonka-storagegateway 1.4.5 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.4.5 (BrendanHay)
08:30:40 * hackagebot amazonka-cognito-idp 1.4.5 - Amazon Cognito Identity Provider SDK.  https://hackage.haskell.org/package/amazonka-cognito-idp-1.4.5 (BrendanHay)
08:30:42 * hackagebot amazonka-kms 1.4.5 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.4.5 (BrendanHay)
08:35:02 <ph88> wow the hackagebot is going crazy
08:35:27 <mettekou> lyxia: Hadn't thought about that, certainly seems like the same effect with much less code. I'll try it out, thanks!
08:35:44 * hackagebot amazonka-autoscaling 1.4.5 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.4.5 (BrendanHay)
08:35:46 * hackagebot amazonka-elb 1.4.5 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.4.5 (BrendanHay)
08:35:48 * hackagebot amazonka-redshift 1.4.5 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.4.5 (BrendanHay)
08:35:50 * hackagebot amazonka-lambda 1.4.5 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.4.5 (BrendanHay)
08:35:52 * hackagebot amazonka-servicecatalog 1.4.5 - Amazon Service Catalog SDK.  https://hackage.haskell.org/package/amazonka-servicecatalog-1.4.5 (BrendanHay)
08:36:14 <mettekou> lyxia: Wait, that would still require a way to convert error types, so whether I use a wrapper constructor or a type class there, it's just as much code for that part.
08:38:29 <lyxia> yes it should be about the same to implement but a single function is simpler to use :)
08:38:41 <ertesx> i'd like to have -Wrecursive-shadowing
08:38:54 <ertesx> x = f x  -- if x is in scope outside of this definition, warn me
08:39:40 <ertesx> i just wasted 15 minutes trying to figure out my error, when all it was was shadowing that caused unintended recursion
08:40:17 <ertesx> it should have been: myX = f x
08:40:27 <jmcarthur> Is llvm-general still the recommended llvm package? It doesn't seem to have been updated in quite a while now.
08:40:54 * hackagebot amazonka-application-autoscaling 1.4.5 - Amazon Application Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-application-autoscaling-1.4.5 (BrendanHay)
08:40:56 * hackagebot amazonka-config 1.4.5 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.4.5 (BrendanHay)
08:40:58 <mettekou> lyxia: The difference is that I need to call that single function explicitly everywhere I use the evaluator within the type checker, whereas the type class solution requires no calls to the runEvaluator function in the type checker.
08:40:58 * hackagebot amazonka-cloudwatch-events 1.4.5 - Amazon CloudWatch Events SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-events-1.4.5 (BrendanHay)
08:41:00 * hackagebot amazonka-apigateway 1.4.5 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.4.5 (BrendanHay)
08:41:02 * hackagebot amazonka-ecr 1.4.5 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.5 (BrendanHay)
08:44:43 <hexagoxel> ertesx: i don't see how that is not caught by regular shadowing warning (?)
08:46:04 * hackagebot amazonka-cloudhsm 1.4.5 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.4.5 (BrendanHay)
08:46:06 * hackagebot amazonka-dynamodb 1.4.5 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.4.5 (BrendanHay)
08:46:08 * hackagebot amazonka-sms 1.4.5 - Amazon Server Migration Service SDK.  https://hackage.haskell.org/package/amazonka-sms-1.4.5 (BrendanHay)
08:46:10 * hackagebot amazonka-stepfunctions 1.4.5 - Amazon Step Functions SDK.  https://hackage.haskell.org/package/amazonka-stepfunctions-1.4.5 (BrendanHay)
08:46:12 * hackagebot amazonka-iam 1.4.5 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.4.5 (BrendanHay)
08:47:08 * hexagoxel votes to disable hackagebot
08:47:20 <maerwald> I consider that a DoS on hackagebot :P
08:50:59 <geekosaur> either hackage or hackagebot needs to be taught about package suites like that, probably by prefix. sadly it's a bit of a slowloris so hard to catch properly --- unless we can talk #hackage and/or the Cabal folks into some extra metadata for suites (and then package maintainers into using it)
08:51:07 <ertesx> hexagoxel: well, i have that warning disabled, because i found it too annoying =)
08:51:14 * hackagebot amazonka-discovery 1.4.5 - Amazon Application Discovery Service SDK.  https://hackage.haskell.org/package/amazonka-discovery-1.4.5 (BrendanHay)
08:51:16 * hackagebot amazonka-marketplace-analytics 1.4.5 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.4.5 (BrendanHay)
08:51:19 * hackagebot amazonka-route53-domains 1.4.5 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.4.5 (BrendanHay)
08:51:21 * hackagebot amazonka-directconnect 1.4.5 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.4.5 (BrendanHay)
08:51:23 * hackagebot amazonka-elasticsearch 1.4.5 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.5 (BrendanHay)
08:52:20 <ertesx> hexagoxel: i'd like to have a limited form of the shadowing warning…  it should only warn when shadowing introduces recursion
08:54:51 <bonnie> hey guys, im a beginner so apologize my stupid question, but im confused why this function doesn't work although it compiles
08:55:45 <bonnie> can anyone help me out? http://lpaste.net/349513
08:56:25 * hackagebot amazonka-devicefarm 1.4.5 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.4.5 (BrendanHay)
08:56:25 <cocreature> bonnie: what is your test case?
08:56:27 * hackagebot amazonka-ec2 1.4.5 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.5 (BrendanHay)
08:56:29 * hackagebot amazonka-s3 1.4.5 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.5 (BrendanHay)
08:56:30 <c_wraith> bonnie: First off, to pattern-match a list, use (x:xs) instead of [x:xs]
08:56:31 * hackagebot amazonka-budgets 1.4.5 - Amazon Budgets SDK.  https://hackage.haskell.org/package/amazonka-budgets-1.4.5 (BrendanHay)
08:56:33 * hackagebot amazonka-xray 1.4.5 - Amazon X-Ray SDK.  https://hackage.haskell.org/package/amazonka-xray-1.4.5 (BrendanHay)
08:56:46 <c_wraith> bonnie: the latter matches a list *inside* a list of length one.
08:56:58 <c_wraith> bonnie: it blows up on any other length of outer list
08:57:01 <bonnie> c_wraith its a list of lists
08:57:11 <c_wraith> bonnie: but it's still wrong
08:57:33 <c_wraith> bonnie: unless your use case is only input lists of length 0 or 1
08:57:40 <c_wraith> bonnie: in which case [] is the wrong type
08:58:30 <bonnie> c_wraith: but how do you write a variable for a list of lists then?
08:59:08 <c_wraith> bonnie: depends on what you're doing.  What *are* you doing, anyway?  The function name doesn't describe anything like what it's trying to do.
08:59:13 <bonnie> c_wraith: i just respected the case of a string with minimum length 3
08:59:21 <abhiroop> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
08:59:44 <abhiroop> has anyone faced the issue in ghc version 8.0.1 that despite adding the extension {-# LANGUAGE GeneralizedNewtypeDeriving #-} the type checker complains
08:59:58 <c_wraith> bonnie: are you trying to perform the same transformation on every element of the outer list?
09:00:05 <bonnie> c_wraith: yes it does . its supposed to make a list of the 3 last letters of every Char in a String
09:00:20 <lyxia> bonnie: [x : xs] is a list with exactly one element, and that element is the list (x : xs) with a head x and a tail xs.
09:00:23 <c_wraith> bonnie: that description doesn't come close to matching the type
09:00:33 <pavonia> abhiroop: Complains about what?
09:00:52 <lyxia> bonnie: (x : xs) is a list with a head x and a tail xs, and the head could very well be a list, so x : xs would be a list of lists
09:01:12 <c_wraith> bonnie: what are you actually trying to do?  For instance, what's expected input and output?
09:01:13 <geekosaur> > 1:2:3:[]
09:01:16 <lambdabot>  [1,2,3]
09:01:17 <abhiroop> @pavonia the GeneralizedNewtypeDeriving despite being enabled
09:01:18 <lambdabot> Unknown command, try @list
09:01:35 * hackagebot amazonka-ecs 1.4.5 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.4.5 (BrendanHay)
09:01:36 <abhiroop> the type checker complains about it not being enabled
09:01:37 * hackagebot amazonka-codebuild 1.4.5 - Amazon CodeBuild SDK.  https://hackage.haskell.org/package/amazonka-codebuild-1.4.5 (BrendanHay)
09:01:39 * hackagebot amazonka-shield 1.4.5 - Amazon Shield SDK.  https://hackage.haskell.org/package/amazonka-shield-1.4.5 (BrendanHay)
09:01:41 * hackagebot amazonka-dms 1.4.5 - Amazon Database Migration Service SDK.  https://hackage.haskell.org/package/amazonka-dms-1.4.5 (BrendanHay)
09:01:43 * hackagebot R-pandoc 0.2.2 - A pandoc filter to express R plots inside markdown  https://hackage.haskell.org/package/R-pandoc-0.2.2 (CorentinDupont)
09:02:00 <lyxia> abhiroop: show your code
09:02:23 <c_wraith> abhiroop: do you have the pragma at the top of the file?
09:02:28 <geekosaur> and full error message
09:02:30 <geekosaur> @lpaste
09:02:30 <lambdabot> Haskell pastebin: http://lpaste.net/
09:03:15 <abhiroop> @c_wraith you are right sorry I was declaring it after the module name
09:03:15 <lambdabot> Unknown command, try @list
09:03:39 <c_wraith> abhiroop: does that solve it?
09:03:46 <abhiroop> yes
09:03:54 <abhiroop> @c_wraith thanks
09:03:54 <lambdabot> Unknown command, try @list
09:04:21 <c_wraith> I have no idea how I guessed that. :)
09:04:43 <geekosaur> seems to come up every week or two
09:04:55 <c_wraith> Huh, it's not something I recall seeing.
09:04:59 <lyxia> You may have special powers.
09:05:12 <eniac[m]> @list
09:05:12 <lambdabot> What module?  Try @listmodules for some ideas.
09:05:14 <c_wraith> Sadly, I totally failed to help bonnie there.
09:05:51 * geekosaur just thinks of it as "sure, it needs to know exactly what language to parse before it starts parsing the actual language"
09:06:30 <c_wraith> I'm surprised the pragma didn't generate an error message saying it was out of place
09:06:45 * hackagebot superbuffer 0.2.0.1 - Efficiently build a bytestring from smaller chunks  https://hackage.haskell.org/package/superbuffer-0.2.0.1 (AlexanderThiemann)
09:11:14 <unskill> Tab characters are not welcome in haskell sources?
09:11:38 <c_wraith> unskill: they are treated as enough spaces to move to the next multiple of 8 indentation level
09:11:52 <c_wraith> unskill: which interferes quite painfully with layout-based code
09:16:26 <hpc> or doesn't interfere at all, if your editor happens to display it that way
09:16:48 <hpc> but tabs are inherently variable-width so there's no single consistent meaning haskell can give them
09:16:51 <hpc> so don't use them ;)
09:17:07 <ongy> unless your editor is set up for 8spaces tabs. but Spaces are more portable in general
09:17:42 <hpc> vertical tabs are webscale
09:17:58 <ongy> I don't think I have ever seen vertical tab in practice, or noticed them when I did
09:18:42 <Tuplanolla> Embrace the diagonal tab.
09:19:08 <hpc> tragically, there is no diagonal tab character
09:19:11 <yushyin> unskill: I used tabs but since ghc enabled the tabs in use warning on by default I switched to spaces only.
09:19:25 <c_wraith> I've seen Form Feed characters in the wild before - but not vertical tab.
09:21:08 <unskill> It is funny that in indentation-based syntax ppl do something more like alignment than indentation.
09:21:51 <c_wraith> it's not indentation-based, though.  It's explicitly alignment-based
09:22:09 <isoroku> Does anyone know if you can make a rect clickable in Haste?
09:22:36 <unskill> c_wraith: example?
09:22:38 <hpc> in fact, you can turn on a language extension that allows for non-increasing alignment to denote nested blocks
09:22:42 <hpc> meaning you can have
09:22:45 <hpc>         outer
09:22:47 <hpc>     inner
09:23:02 <hpc> as long as they are different
09:23:33 <c_wraith> unskill: GHC doesn't care how many spaces are in front of something - just that it's the same number as are in front of everything else in the same block.  that's alignment.
09:23:54 <geekosaur> actually it's on by default unless you explicitly specify Haskell98 or Haskell2010
09:24:36 <hpc> oh, fun
09:25:05 <unskill> c_wraith: Ah I see. I meant something different under alignment. E.g. that you aling "where" keyword on the next line so that it starts after `= ` in function clause
09:25:29 <geekosaur> that's not a rule of layout though
09:25:33 <c_wraith> unskill: well, that doesn't happen.  But other cases do that though
09:25:36 <EvanR> i dont like that i put where on the previous line
09:25:51 <EvanR> otherwise its a waste of an indent
09:26:10 <unskill> c_wraith: it is not necessary to align in such a way, but ppl tend to do so
09:26:16 <EvanR> 1 level of indentation, 2 and youre screwed
09:26:23 <geekosaur> (also, how does this differ from the cuddled-braces bikeshed in C/C++?)
09:26:24 <EvanR> (linus style)
09:26:45 <geekosaur> ...heh
09:27:18 <hpc> the right way is to right-align your code and make sure every line in a block is the same length for the compiler
09:27:36 <Tuplanolla> I prefer the "place braces by mood" style.
09:27:42 <hpc> (for academic papers, justify your code to both margins)
09:27:51 <EvanR> at any cost
09:28:05 <EvanR> even very wide letter spacing like old style newspapers
09:28:32 <geekosaur> lead type coding >.>
09:29:48 <hpc> https://metacpan.org/pod/Acme::Bleach - relevant
09:30:43 <EvanR> i see
09:31:42 <EvanR> http://i.imgur.com/7Wh0B2l.png
09:31:59 <EvanR> used litmus ;)
09:32:23 <ongy> how much of that bleaching could we do in haskell?
09:32:26 * geekosaur just swiped over it out of curiosity
09:33:20 <gargawel> Hi, I just managed to make GHC crash (7.10.3 and 8.0.1) : https://gist.github.com/gdeest/d06966777a19cc1574cdd2a8910c98f4
09:33:38 <gargawel> Does anyone know if it is a known bug ?
09:34:14 <c_wraith> gargawel: It's not a bug, exactly.
09:34:17 <unskill> But... Haskell code can't crash or I am mistaken?
09:34:36 <geekosaur> "simplifier ticks exhausted" does come up every so often, but some programs are more likely to trigger it than others
09:34:36 <c_wraith> gargawel: the compiler explicitly gave up because inlining was going on for too long
09:34:52 <gargawel> c_wraith: I am not requesting any inlining...
09:35:04 <gargawel> AND it compiles just fine with -O0
09:35:05 <geekosaur> if you have optimization enabled then it's inlining
09:35:06 <c_wraith> gargawel: are you using any libraries at all?
09:35:22 <c_wraith> gargawel: yes, -O0 disables inlining
09:35:25 <gargawel> hum, yes, just a few 
09:35:37 <gargawel> how may I know where it comes from ?
09:35:43 <geekosaur> aggressive inlining is why ghc generated code has anything like reasonable performance. it even inlines across modules, by exporting part of your source in the .hi file
09:36:21 <c_wraith> gargawel: it's probably the result of the code generated by all that TH
09:36:23 <unskill> g++ crash http://ideone.com/jODNCS (already fixed in gcc 7)
09:36:24 <geekosaur> (which is why ghc gets so persnickety about exact module versioning, and you often need magical tools to get things to work around it...)
09:36:45 <c_wraith> err.  "all that" isn't actually that much.  Nevermind. :)
09:37:06 <gargawel> I would expect GHC to abort inlining when it goes too far and fallback to non-inlining instead of aborting altogether
09:37:20 <c_wraith> gargawel: well, normal users aren't expected to hit that case
09:37:41 <geekosaur> anyway, any program can crash. in haskell it's just not going to be wild pointers; it's usually logic errors, or (as in this case) code that watches for excessive looping
09:37:42 <c_wraith> gargawel: that case is expected to be hit by GHC developers experimenting with new optimizations (or breaking the optimizer)
09:37:59 <geekosaur> > head []
09:38:01 <lambdabot>  *Exception: Prelude.head: empty list
09:38:02 <c_wraith> gargawel: It's very strange to hit it outside of those cases.
09:38:13 <geekosaur> an exception is a crash, if it's not caught by something
09:38:23 <unskill> geekosaur: it is not crash, it is bottom
09:38:26 <c_wraith> gargawel: If you think your code is fine, bump the simplifier ticks and report how you hit the limit
09:38:29 <gargawel> So, am I, or am I not, supposed to report this as a bug ?
09:38:42 <geekosaur> unskill, bottom is by definition a crash / nontermination
09:39:05 <gargawel> I've tried that already, it just loops for some time and then crash
09:39:09 <davean> c_wraith: it happens all over the place
09:39:10 <gargawel> so arguably, there is an inlining loop
09:39:19 <geekosaur> either a crash or an infinite loop, except *some* cases can be caught in IO
09:39:20 <davean> c_wraith: almost any user of vector for example
09:39:39 <c_wraith> davean: Hmm.  It used to be somewhat harder to hit.  Had to use vector-algorithms, at least.
09:40:17 <c_wraith> That code doesn't appear to be using anything more than Text that would lead to lots of inlining.
09:40:54 <c_wraith> I guess maybe the number of constructors of Propositional also has an impact
09:42:23 <gargawel> c_wraith: Yeah, but then I guess just increasing the number of ticks would solve the issue
09:43:13 <c_wraith> gargawel: as the error message says, if you think your code is reasonable, report a bug
09:43:21 <geekosaur> gargawel, actually, if I read that trace correctly, no number of ticks will help; it's repeatedly failing to reduce the same thing
09:43:43 <gargawel> geekosaur: that's also my understanding
09:43:55 <c_wraith> that might actually be a worse bug
09:43:57 <snowowl> hi, so i'm working with haskell and yesod for the first time and i can't seem to get a scaffolded site up and working
09:44:04 <geekosaur> which to me says either bug or you have managed to write something that really does have an infinite loop at type level
09:44:05 <davean> c_wraith: I have to reporting then and just bump it at the start of any new project now
09:44:06 <c_wraith> GHC should definitely not be trying to do that.
09:44:08 <gargawel> and it looks like it's trying to simplify toProp / toProp', which does NOT rely on text
09:44:31 <geekosaur> (which is entirely possible, and why the compiler has a simplifier tick limit among other things)
09:44:42 <gargawel> geekosaur: then, -O0 wouldn't help, would it ?
09:44:52 <c_wraith> It still disables the simplifier
09:47:50 <geekosaur> anyway I think I would indeed file a ghc bug with as much information as possible (e.g. -ddump-simpl-iterations and other -ddump-* options)
09:48:42 <gargawel> So, just adding a NOINLINE pragma to the toProp' method stops the problem from happening
09:49:20 <gargawel> I will simplify my code a bit and file a bug, just in case
09:50:36 <gargawel> I actually think the INLINE pragmas in Data.Bifunctor.Wrapped are to blame: https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/src/Data-Bifunctor-Wrapped.html#WrappedBifunctor
09:51:28 <ania123> I need a help from a person having  access to Thomson database..
10:03:13 <lyxia> what does that have to do with haskell
10:03:53 * hackagebot HMarkov 1.0.1.1 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.1.1 (swizzard)
10:06:43 <Jello_Raptor> good lord 
10:06:47 <orion> If you need to pause a computation (yielding output and waiting for input), under what conditions would you choose the following solutions?: 1. Cont Monad, 2. Coroutine, 3. Pipes/Conduit
10:06:48 <Jello_Raptor> the tardis monad is weird 
10:07:39 <jmcarthur> Tardis is weird just for the sake of being weird.
10:07:50 <jmcarthur> The reverse state monad is a distillation of the weird part.
10:08:10 <unskill> Under zigohistomorphic prepromorphism
10:08:17 <jmcarthur> Tardis just transforms it with a state monad, which makes it a little weirder seeming.
10:11:55 <hpc> the reverse state monad isn't even that weird either, it's just a confusing presentation of knot tying
10:12:29 <hpc> plus the amusing observation that it's legal to transpose your old and new state in the let-ins of State's definition
10:12:51 <kuribas> Isn't RWS just ReaderT (WriterT StateT)?
10:13:12 <hpc> kuribas: and Identity ;)
10:13:37 <hpc> (also there's RWST, which could easily be an x86 instruction)
10:13:38 <kuribas> hpc: writeT then...
10:13:52 <kuribas> hpc: erm yeah, that one
10:14:43 <hpc> orion: all three are specific instances of CPS, which is where you get the yielding from
10:14:54 <hpc> orion: so it comes down to the extra stuff those types do
10:15:29 <hpc> Cont isn't very much more than assigning CPS to an in-language name, so you'd probably end up using it to define your own control flow
10:15:42 <hpc> i haven't done much with pipes/conduit so i couldn't say for sure with those
10:16:15 <hpc> Coroutine / FreeT work nicely when what you're dealing with is fundamentally recursive in the particular way they encode
10:16:52 <ania123> I need a help from a person having  access to Thomson database..
10:16:52 <orion> "encode" -- what do you mean by that?
10:17:35 <hpc> basically being a defined representation of something abstract
10:17:44 <hpc> for instance, Maybe is an encoding of computations that can fail
10:17:47 <hpc> as is Either
10:22:09 <orion> hpc: What is a concrete example of a problem best solved by Coroutine / FreeT and one that is best solved by Cont? In other words, what is an example of something "findamentally recursive"?
10:22:28 <orion> s/findamentally/fundamentally
10:23:38 <hpc> what we were discussing the other day with writing an interpreter for a DSL is recursive
10:23:43 <DemiMarie> I am hacking on the GHC RTS and am trying to figure out how to do a few things from the RTS's C code
10:23:48 <hpc> the recursion being "traverse the tree of the DSL"
10:24:19 <hpc> for something more suitable for Cont, perhaps writing computations that short-circuit in non-trivial ways
10:25:01 <hpc> Cont captures the continuation that is "what we will do after the current step"
10:25:15 <hpc> and a trivial use of that continuation is to just not use it
10:25:22 <hpc> which is the same as aborting early with a result
10:25:34 <hpc> (as distinct from Maybe or Either which is aborting early without a result)
10:26:41 <hpc> https://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.Prim.html#ParsecT - sometimes Cont isn't perfectly suited, such as in the case of multiple continuations
10:27:01 <DemiMarie> - get a Weak# from a Weak
10:27:03 <kuribas> hpc: you can pass continuations with callCC
10:27:15 <hpc> a parsec parser consists of a bit of state plus four continuations
10:27:25 <hpc> consume input and succeed, consume input and fail
10:27:33 <hpc> do not consume and succeed, do not consume and fail
10:27:51 <hpc> when you write a parser, you're building those continuations
10:28:16 <Gurkenglas> :t until -- aborting early with a result <- like this?
10:28:17 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
10:28:54 * hackagebot th-lift-instances 0.1.11 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.11 (BennoFuenfstueck)
10:29:39 <hpc> sort of
10:30:33 <Gurkenglas> :t Control.Monad.Loops.iterateUntilM -- monadic, then? or do you mean (a -> b -> Maybe a) -> a -> [b] -> a?
10:30:35 * hpc lpastes
10:30:35 <lambdabot> Monad m => (a -> Bool) -> (a -> m a) -> a -> m a
10:32:01 <hpc> http://lpaste.net/7796789956474568704
10:32:10 <hpc> more like being able to write that
10:33:00 <Gurkenglas> return (x * -1) doesn't look like ()
10:33:21 <hpc> argh, that's horribly wrong
10:33:34 <hpc> yeah
10:33:39 <hpc> that's not even the first of its issues
10:34:42 <hpc> http://lpaste.net/7796789956474568704
10:34:45 <hpc> run runFoo in ghci
10:35:30 <hpc> and between lines 9 and 10 you can add liftIO $ putStrLn "side effects"
10:35:46 <hpc> to make it really visible what's going on
10:37:01 <hpc> runFoo :: IO Int, as well
10:38:11 <kuribas> > flip runCont id $ foldlM (\a b -> cont $ \next -> if even b then a+b else next(a+b)) 0 ([1, 7, 13, 5]++[2..])
10:38:14 <lambdabot>  28
10:39:05 <hpc> yeah, that's more golfy but shows the same idea
10:39:27 <hpc> and formulates it as explicit continue rather than explicit stop
10:39:52 <hpc> which on its own is a rather neat thing to be able to mix
10:42:14 <hpc> i wrote something a while back that did short-circuiting in the other direction, with image manipulation
10:42:27 <hpc> if the result image was already on the filesystem, it wouldn't do any of the build-up computations
10:42:49 <hpc> it ended up being something like State (IO Image) a
10:42:56 <kuribas> > flip runCont id $ callCC $ \exit -> foldlM (\a b -> if even b then exit(a+b) else return (a+b)) 0 ([1, 7, 13, 5]++[2..])
10:42:59 <lambdabot>  28
10:43:11 <kuribas> it's a bit more verbose
10:43:34 <hpc> someday i might make it reasonably CPS
10:43:56 <hpc> but the continuation goes in reverse of the decision of if to use that computation
10:45:08 <lpaste> Gurkenglas annotated “No title” with “Looks like EitherT” at http://lpaste.net/7796789956474568704#a349521
10:46:14 <hpc> Gurkenglas: you can't compose that foo with anything else, though that example doesn't really make it that clear
10:46:27 <hpc> you're changing the last return line into an abort line
10:47:10 <lpaste> Gurkenglas revised “Looks like EitherT”: “This, then?” at http://lpaste.net/349521
10:47:11 <hpc> you couldn't write unNegatedFoo = do {negated <- foo; return (negated * (-1))}
10:47:15 <orbital> hi! A tool related question regarding parser generators: looking for a way to combine a parser generator with an interactive grammar editor to generate a parser for a simple binary format (midi sysex), but my searches are coming up short. On the editor side there are IntelliJ plugins for working with BNF and Antlr4, but none of those produce anything happy can use. Where else might one look?
10:49:02 <hpc> Gurkenglas: yeah, s/Void/Int but otherwise more or less matches my example
10:51:39 <hpc> orion: anyhoo, that's one pretty trivial manipulation of continuations - the continuation is an ordinary function so you can do all sorts of other stuff to it as well
10:52:06 <hpc> which is written about elsewhere
10:52:55 <Gurkenglas> Can you build a use of ContT which I can't mimic with some other transformer stack?
10:53:46 <hpc> sec
10:58:56 * hackagebot hexml 0.1 - XML subset DOM parser  https://hackage.haskell.org/package/hexml-0.1 (NeilMitchell)
11:01:11 <hpc> http://lpaste.net/4858230051889479680 - Gurkenglas
11:01:54 <Tuplanolla> You don't use `abort` on purpose, hpc?
11:02:23 <hpc> in the second example?
11:02:34 <hpc> yeah, abort isn't expressive enough
11:02:55 <hpc> it isn't skipping the whole computation, just certain parts of it
11:03:06 <hpc> as captured by the two continuations outer and inner
11:03:18 <hpc> neither of which is right at the end
11:03:50 <hpc> (in fact, abort also skips things outside of foo, such as if we ran foo >> foo)
11:05:02 <hpc> it's tricky to come up with example behaviors unique to Cont because you can use it to re-implement any other monad
11:05:16 <hpc> (modulo some hairy details)
11:05:17 <hpc> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
11:07:25 <hpc> that new example also doesn't really give any insight as to why Cont is defined the way it is
11:07:43 <hpc> you just see it uses callCC and does some particular things, then you read callCC's definition and it's totally O.O
11:08:22 <lpaste> Gurkenglas annotated “No title” with “hpc, untested” at http://lpaste.net/4858230051889479680#a349526
11:10:33 <hpc> Gurkenglas: :P
11:11:12 <Gurkenglas> Keep trying, if our game bottoms out I win :D
11:15:01 <orbital> (rephrasing earlier question) is there a tool for generating a haskell parser from an antlr4 grammar definition?
11:15:39 <hpc> Gurkenglas: http://lpaste.net/4858230051889479680
11:15:55 <hpc> Gurkenglas: you're starting to push the limits of my ability to write weird code with Cont ;)
11:16:44 <Gurkenglas> hpc, what's line 18 do?
11:16:51 <Tuplanolla> I think ANTLR 4 only has code generators for imperative languages, orbital.
11:17:10 <Gurkenglas> Oh, nvm
11:17:14 <lyxia> Tuplanolla: so, Haskell? :D
11:17:32 <hpc> Gurkenglas: abort ()
11:17:43 <hpc> Gurkenglas: i am trying to make it something less trivial as we speak ;)
11:17:55 <Tuplanolla> With `inline-java`, lyxia...
11:18:03 <hpc> or something like it, rather
11:20:26 <Gurkenglas> orbital, I don't know any but if I wanted to write such a tool I'd use TemplateHaskell
11:20:29 <unskill> ￾
11:22:28 <hpc> Gurkenglas: !!
11:22:37 <hpc> Gurkenglas: http://lpaste.net/4858230051889479680
11:22:42 <hpc> i don't even know how this one works
11:23:01 <hpc> in fact it's so weird i am saving it to look at later
11:23:56 <orbital> :sad panda:
11:24:06 <orbital> Gurkenglas Tuplanolla thanks
11:24:10 <Gurkenglas> hpc, ">> return ()"? (Does it compile?)
11:24:20 <hpc> it compiles and runs
11:24:28 <hpc> try it with input "outer" and input "inner"
11:25:01 <Gurkenglas> Do you need to call two variables inner?
11:25:32 <hpc> no, that was just for my own benefit
11:25:37 <hpc> one of them shadows the other
11:26:33 <hpc> actually i think now i see what it does
11:27:21 <unskill> ‮
11:28:48 <hpc> Gurkenglas: i gotta go now, but i thiiiiiiiiink that one you won't be able to write a similarly structured version of in EitherT
11:28:55 <hpc> and if you can, i concede because my brain hurts
11:34:43 <hexagoxel> the classic usecase of ContT are `with..` functions; and hpc's code does not seem to contain any function that resembles that, so my guess is that it can be transformed.
11:57:50 <Tuplanolla> I wouldn't mind someone writing such a code generator, orbital.
11:59:34 <fabio_> pl \x y -> x + 1
11:59:42 <fabio_> @pl \x y -> x + 1
11:59:42 <lambdabot> const . (1 +)
12:00:11 <fabio_> @pl \x -> x  1
12:00:11 <lambdabot> ($ 1)
12:07:28 <fabio_> @pl \x -> f x x
12:07:28 <lambdabot> join f
12:07:37 <fabio_> @pl \x -> f x (z x)
12:07:37 <lambdabot> ap f z
12:07:39 <lyxia> you can pm lambdabot
12:08:03 <fabio_> @pl \x -> cons x (k (lconst x))
12:08:03 <lambdabot> ap cons (k . lconst)
12:08:42 <ania123> I need a help from a person having  access to Thomson database..
12:09:45 <ij> If I've a typeclass that lets you implement FaceCount of an object and a typeclass that represents Cubes, then I could implement face count of all Cubes. Can I make a generic instance just like that?
12:11:04 <Tuplanolla> You have `class FaceCount a => Cube a`, ij?
12:12:44 <ij> Wouldn't that simply require that instances of Cube already have a FaceCount instance?
12:13:09 <Tuplanolla> You want it to be optional?
12:13:59 <geekosaur> ij, actually not quite. consider how Applicative got retrofitted into Monad instances for 7.10 compatibility
12:14:44 <ij> Tuplanolla, No, I want to make instances for all class members.
12:15:22 <Tuplanolla> I don't follow.
12:15:23 <geekosaur> there are reasons not to just do it generically (it'd overlap anything that already had such an instance) in that case, but for yours it might be sufficient. you'd actually use the opposite constraint though (and then not define any explicit instances)
12:15:39 <geekosaur> that said ... I am wondering why these need to be classes to begin with, Cube in particular
12:16:09 <geekosaur> (also you only get to do that once since it overlaps every other FaceCount instance...)
12:16:28 <geekosaur> basically this feels like you may not be using typeclasses appropriatelyt
12:19:01 * hackagebot rei 0.4.0.2 - Process lists easily  https://hackage.haskell.org/package/rei-0.4.0.2 (kerkomen)
12:20:02 <fabio_> @pl (\ x y z -> x z (y z))
12:20:02 <lambdabot> ap
12:36:52 <niez> hi, I have trouble with some advanced features of type system, I'm playing with servant and persistent, in my api I want to use /persons?order_by=name or /persons?order_by=age, and that should be translated into persistent query like selectList [] [Asc PersonName] or selectList [] [Asc PersonAge], I need a function like this: http://lpaste.net/349520, but GHC complains that my function returns different types, basically PersonName and PersonArea are different 
12:36:52 <niez> types, as I understand
12:38:39 <lyxia> wow this hamilton thing is amazing https://blog.jle.im/entry/introducing-the-hamilton-library.html
12:38:48 <cocreature> lyxia: yep!
12:39:03 * hackagebot praglude 0.1.1.0 - A pragmatic Prelude  https://hackage.haskell.org/package/praglude-0.1.1.0 (TobiasDammers)
12:40:00 <laudiacay> what does @pl do?
12:40:08 <laudiacay> also where's the lambdabot source?
12:40:27 <cocreature> laudiacay: https://github.com/lambdabot/lambdabot
12:40:36 <cocreature> laudiacay: @pl transforms code to pointless mode
12:40:41 <lyxia> almost makes me want to give up cs for physics
12:40:47 <hexagoxel> @hackage pointfree
12:40:47 <lambdabot> http://hackage.haskell.org/package/pointfree
12:40:57 <cocreature> or pointfree :)
12:41:03 <cocreature> also s/mode/code/
12:41:15 <laudiacay> cocreature: nice
12:41:44 <lyxia> niez: indeed you can't write such a function
12:41:45 <cocreature> lyxia: I still need to figure out how hamiltionian mechanics actually work
12:42:47 <laudiacay> cocreature: if you teach me monads well enough to pass my test on friday, I'll teach you hamiltonian mechanics
12:43:23 <cocreature> laudiacay: it’s really simple, a monad is just a monoid in the category of endofunctors!
12:43:32 * laudiacay screams
12:43:46 <cocreature> laudiacay: going back to being serious, what are you confused about?
12:44:04 <laudiacay> literally everything? i dunno, I am having a lot of trouble with the typeclassopedia
12:44:24 <cocreature> I’ve found that monads become really confusing if you try to find analogies but if you just accept the definition there is not much too it
12:44:34 <cocreature> laudiacay: do you understand functor & applicative?
12:44:50 <laudiacay> i get functors. they're things you fmap over
12:45:03 <laudiacay> applicatives... I just dont get the point of boxing up a function like WTF is that
12:45:26 <cocreature> laudiacay: <*> seems weird indeed (at first), but you can also define Applicatives in terms of liftA2
12:45:28 <cocreature> :t liftA2
12:45:30 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:45:30 <cocreature> :t fmap
12:45:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:45:35 <laudiacay> this is just all so confusing. i thought I was smart but then i met haskell and j k
12:45:37 <laudiacay> anyway
12:45:39 <cocreature> so it’s basically fmp for two arguments!
12:45:41 <cocreature> *fmap
12:45:48 <laudiacay> like what
12:45:59 <laudiacay> i dont get lifta2 either haha
12:46:12 <cocreature> laudiacay: so let’s say you have two Maybe Ints
12:46:21 <cocreature> laudiacay: and you want to add them to get a new Maybe Int
12:46:33 <cocreature> you can just use liftA2 (+) (Just 1) (Just 2)
12:46:42 <cocreature> if one of them is nothing, the result will be nothing
12:46:44 <laudiacay> how would you do that with just fmap
12:46:55 <cocreature> laudiacay: you can’t! that’s why we have Applicative!
12:46:56 <laudiacay> oh
12:46:58 <Tuplanolla> Hamiltonian mechanics is a terrible trade. It's all fun and games until friction gets involved.
12:47:20 <laudiacay> Tuplanolla: as long as it's not kinetic ur fine though
12:47:27 <laudiacay> anyway cocreature ok i think i kinda get it
12:47:40 <ania123> I need a help from a person having  access to Thomson database..
12:48:03 <laudiacay> applicative is like a muscled up functor for when you want to fmap multiple things but cant because fmap only does unary functions
12:48:10 <cocreature> exactly
12:48:13 <laudiacay> okay.
12:48:15 <cocreature> in addition to that it includes "pure"
12:48:22 <cocreature> but pure is fairly simple
12:48:23 <laudiacay> and pure is like "box the thing"
12:48:43 <cocreature> the box analogy only goes so far but for things where that makes sense, yes
12:48:47 <laudiacay> and you can do either:
12:49:08 <laudiacay> pure f <*> boxedInputA <*> boxedInputB
12:49:25 <geekosaur> ania123, at this point I don't think you're getting that help here. try stackoverflow or etc.?
12:49:27 <laudiacay> or f <$> boxedInputA <$> boxedInputB
12:49:40 <cocreature> laudiacay: or liftA2 f boxedInputA boxedInputB :)
12:49:42 <laudiacay> those are equivalent right cocreature 
12:49:45 <laudiacay> ohhh tru
12:49:46 <cocreature> yep
12:49:50 <nshepperd> f <$> boxedInputA <*> boxedInputB
12:49:54 <laudiacay> how many liftwhatevers arethere
12:49:56 <cocreature> laudiacay: eh no you need <*> in the second example
12:50:04 <laudiacay> oh that was a typo sorry
12:50:23 <laudiacay> okay so i think a tentatively get applicatives
12:50:37 <cocreature> so now we have monads
12:50:42 <cocreature> monads have return, but return = pure
12:50:42 <laudiacay> wait wait slow down aaaaaaaaaaa
12:50:44 <laudiacay> sorry
12:50:47 <cocreature> so you already understand that
12:50:53 <laudiacay> hold on aaaaaaa
12:50:57 <cocreature> sorry :)
12:51:02 <cocreature> where did you get lost?
12:51:03 <laudiacay> can we go through some typeclassopedia problems first together
12:51:04 <nshepperd> I think there are or could be liftA3, liftA4 etc, but they would just be convenience
12:51:13 <laudiacay> im not lost i feel like i just havent locked down applicatives yet
12:51:18 <cocreature> laudiacay: sure, but I only have about 10 minutes :)
12:51:29 <cocreature> laudiacay: any specific problems you’re looking at?
12:51:31 <nshepperd> you can still do 'f <$> boxedInputA <*> boxedInputB <*> boxedInputC' with Applicative
12:51:32 <laudiacay> ok nm explain monads then you're amazing at explaining things
12:51:43 <laudiacay> ill ask other channel people about applicative problems later
12:51:44 <ania123> geekosaur: stackoverflow  what is that?
12:51:56 <cocreature> alright so monads give you the bind operation
12:51:58 <cocreature> :t (>>=)
12:52:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:52:10 <cocreature> this is confusing, but there is a version that is more similar to fmap
12:52:15 <cocreature> :t (=<<)
12:52:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:52:17 <geekosaur> ania123, https://stackoverflow.com ?
12:52:21 <laudiacay> i really really do not see how that transforms into the awesome do notation that i know and love
12:52:22 <cocreature> that’s just >>= with its arguments reversed
12:52:26 <laudiacay> okay
12:52:30 <cocreature> :t fmap
12:52:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:52:33 <cocreature> :t (=<<)
12:52:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:52:41 <laudiacay> ooh that looks pretty close
12:53:20 <cocreature> so if you had a function "f : a -> m b" and you run fmap f a where (a :: m a) you get m (m a)
12:53:31 <laudiacay> so from the types that looks like "unbox thing a, whap it with a function, and out comes a boxed thing b"
12:53:32 <cocreature> but now you have this weird nested layer of monads
12:53:37 <laudiacay> yeah
12:53:45 <cocreature> =<< joins these two layers
12:53:46 <laudiacay> so you have to like kinda concat them together
12:53:54 <laudiacay> which made me super uncomfortable with the list monad
12:54:18 <cocreature> you can in fact implement =<< in terms of fmap and a join operation of type "join :: m (m a) -> m a"
12:54:22 <cocreature> for lists join = concat
12:54:30 <laudiacay> okay that makes sense
12:54:33 <cocreature> that’s really all there is to it
12:54:35 <cocreature> no magic
12:54:37 <laudiacay> so basically all monads are like
12:54:47 <laudiacay> the things inside have to be crunchable together somehow
12:54:49 <laudiacay> ?
12:54:56 <cocreature> yeah
12:55:04 <laudiacay> so they're all monoids?
12:55:06 <cocreature> laudiacay: as an exercise try implementing =<< in terms of fmap and join
12:55:12 <cocreature> laudiacay: monoids in the category of endofunctors :)
12:55:18 <laudiacay> wat
12:55:42 <cocreature> laudiacay: don’t worry about that. that’s just categorical jargon
12:55:53 <laudiacay> so f =<< ma = join (fmap f ma) ?
12:55:59 <cocreature> laudiacay: exactly!
12:56:15 <cocreature> laudiacay: so now we can look at how do notation works
12:56:19 <laudiacay> (admission of guilt: i just looked up the list monad's bind implementation 20 minutes ago)
12:56:20 <laudiacay> but anyway
12:56:34 <laudiacay> is join from the monoid implementation?
12:56:39 <laudiacay> also yes please do notation
12:56:45 <nshepperd> they're not haskell Monoids
12:56:55 <laudiacay> oh okay, but they have to be functors?
12:57:01 <laudiacay> or was it applicatives that have to be functors
12:57:04 <niez> lyxia, so how can I convert name incoming as text from http request to EntityField (so I can pass that to selectList) ?
12:57:06 * laudiacay continues screaming
12:57:16 <cocreature> laudiacay: monads are applicatives and applicatives are functors
12:57:20 <cocreature> laudiacay: so monads are functors
12:57:23 <laudiacay> okay, cool
12:57:30 <laudiacay> where do haskell monoids fit in to all this
12:57:37 <cocreature> they don’t
12:57:38 <geekosaur> they don't
12:57:41 <laudiacay> i thought functors contained monoids
12:57:45 <cocreature> nope
12:57:56 <cocreature> Haskell Monoids are for things that take no type argument
12:58:13 <laudiacay> hmmmmm we did monoids in class and my teacher fit them into functors somehow
12:58:25 <geekosaur> the "monoid" in that description is talking about category theory, which is several levels of abstraction above what Haskell can represent. or if you prefer, it's theory rather than actual language/library features
12:58:27 <cocreature> that seems wrong
12:58:33 <nshepperd> 'join' and mconcat from Monoid look superficially similar, but aren't really for the same purpose
12:58:42 <laudiacay> nshepperd: i think that was it
12:58:47 <nshepperd> join :: m (m a) -> m a
12:59:01 <laudiacay> http://cmsc-16100.cs.uchicago.edu/2016/Lectures/13-monoid-foldable.php
12:59:09 <nshepperd> mconcat :: [m a] -> m a -- (when specialised to Monoid (m a))
12:59:09 <laudiacay> there's this and http://cmsc-16100.cs.uchicago.edu/2016/Lectures/12-functors.php
12:59:20 <laudiacay> idk somehow he related them i forget
12:59:30 <laudiacay> ill work it out later when i understand this stuff
12:59:34 <cocreature> laudiacay: so do notation is implemented in terms of >>=
12:59:36 <lyxia> niez: wrap the result in Asc
12:59:40 <laudiacay> okay 
12:59:42 <cocreature> >>= is just =<< with its arguments flipped
12:59:44 <cocreature> :t (>>=)
12:59:46 <laudiacay> okay 
12:59:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:59:48 <cocreature> :t (=<<)
12:59:50 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:59:55 <lyxia> niez: this will hide the fact that the contained types are different
13:00:08 <cocreature> so now let’s say we have "do x <- doX; f x"
13:00:11 <michael[m]> what's the state of the art circa almost 2017 for using dynamic programming in Haskell?
13:00:18 <cocreature> this is translated to "doX >>= f"
13:00:28 <laudiacay> oh lord what is that abomination
13:00:46 <cocreature> laudiacay: which one? :)
13:01:10 <Tuplanolla> The thing is that `return` and `join` are related to `mempty` and `mappend`, but the relation involves more than one category, laudiacay.
13:01:15 <laudiacay> when we indent it all nicely it looks like this right? http://pastebin.com/24SdRVnD
13:01:29 <cocreature> laudiacay: yeah, I just wanted to fit it in one line :)
13:01:30 <laudiacay> Tuplanolla: can i ask you about that in detail later
13:01:35 <dolio> geekosaur: You can do that sort of very general monoid in GHC, but it probably won't be great to use in practice.
13:01:37 <laudiacay> cocreature: ok cool i was just confused
13:01:42 <Tuplanolla> It's not important until you have a good understanding of the concepts, laudiacay.
13:01:52 <Tuplanolla> It's probably not even important then.
13:01:53 <lyxia> niez: how is your EntityField defined for your record
13:02:12 <Tuplanolla> Not for programming at least.
13:02:16 <laudiacay> cocreature: ok so do notation is just simplyfying it
13:02:22 <laudiacay> *simplifying
13:02:25 <cocreature> laudiacay: do notation is just syntactic sugar
13:02:30 <cocreature> it’s easier to read than >>=
13:02:35 <cocreature> but it just uses >>= behind the scenes
13:02:49 <laudiacay> into "we take it out of the box, we whap it with the function", because i am slow and need this level of explanation :)
13:03:21 <cocreature> just be careful with that box analogy. not every instance of Monad fits into that scheme
13:03:21 <laudiacay> so as long as i think of bind as join (fmap f ma)
13:03:31 <laudiacay> which ones do not?
13:03:52 <cocreature> hm, I guess the simplest one is probably Proxy
13:03:56 <cocreature> are you familiar with that?
13:03:59 <laudiacay> oh boy sounds waaaay above my head
13:04:04 <laudiacay> let's go, confuse me :)
13:04:05 <niez> lyxia, it compiles now! :)
13:04:06 <cocreature> no it’s really simple!
13:04:12 <cocreature> "data Proxy a = Proxy"
13:04:18 <laudiacay> huh?
13:04:21 <lyxia> niez: okay nice!
13:04:22 <cocreature> so it never uses the type argument a
13:04:27 <laudiacay> the constructor is just kinda... sitting there
13:04:31 <laudiacay> what does it do
13:04:42 <cocreature> laudiacay: implementing fmap is really easy, "fmap Proxy = Proxy"
13:04:45 <Tuplanolla> I guess `Cont` makes for quite a silly box.
13:04:54 <laudiacay> why would you ever need that
13:05:22 <laudiacay> i mean i guess i can think of it as "empty useless box that is a vortex to another dimension for its type argument"
13:05:44 <cocreature> Tuplanolla: yeah but I wanted to avoid Cont :)
13:05:55 <niez> lyxia, EntityField is defined by persistent/TH, I can paste :info from GHCi if that will help, but anyway, it works now
13:05:57 <laudiacay> oh i saw cont/reader/writer earlier in the typeclassopedia
13:06:20 <lyxia> niez: Yeah it's fine, that was just in case it didn't work.
13:06:23 <laudiacay> immediately took a cereal break because i was concerned for my sanity
13:06:33 <cocreature> ignore Cont at the beginning
13:06:36 <laudiacay> okiedoke
13:06:40 <cocreature> it can be quite confusing :)
13:06:41 <laudiacay> we did state in class, and i think i get that
13:06:43 <cocreature> at least it was to me
13:06:56 <cocreature> laudiacay: state is actually a good example, there’s not really a box there
13:07:02 <laudiacay> there kinda is a box idk
13:07:02 <cocreature> laudiacay: since it’s just a functino a -> (s, a)
13:07:10 <cocreature> eh s -> (a, s)
13:07:16 <Tuplanolla> If you have a polymorphic type inside a function that's not related to any of the types in its signature, `Proxy` can be used to carry information about it, laudiacay.
13:07:28 <Tuplanolla> This tangent isn't important either.
13:07:28 <geekosaur> there's no actual box, it's just passing and returning parameters
13:07:33 <laudiacay> Tuplanolla: aaaaaa
13:08:04 <laudiacay> never mind maybe i forgot the state monad
13:08:21 <Tuplanolla> Often `ScopedTypeVariables` serves you better than `Proxy`.
13:08:25 <cocreature> laudiacay: sorry I have to go to bed, I have an algebra lecture at 8:00am tomorrow. I’m sure someone else can help you or we can pick this up another time
13:08:34 <laudiacay> cocreature: goodnight and THANK YOU SO MUCH
13:08:38 <cocreature> np
13:11:24 <laudiacay> wait functions are functors
13:11:28 <laudiacay> so fmap is just .
13:11:34 <laudiacay> aaaaa haskell are you high
13:13:54 <laudiacay> oh my goodness this is amazing http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
13:13:54 <latro`a> in hindsight, it's interesting to me that the state monad is even interesting much less useful, because it is just sugar
13:14:41 <maerwald> wat?
13:14:42 <latro`a> and yet it seemed so profound at the time...
13:14:52 <maerwald> how is the state monad sugar
13:15:17 <latro`a> its Kleisli arrows, after stripping newtypes, are a -> s -> (a,s)
13:15:26 <maerwald> I don't see how that is sugar
13:15:28 <latro`a> this is the curried version of (a,s) -> (a,s)
13:15:39 <Gurkenglas> You mean "It has an implementation"?
13:15:42 <latro`a> the composition of State's Kleisli arrows is...composition of (a,s) -> (a,s)
13:15:52 <maerwald> that's still not sugar, what Gurkenglas said
13:16:20 <latro`a> it's not quite sugar, but it's surprisingly close; all you are doing is composing (a,s) -> (a,s) functions, where s is fixed and a is not, in a convenient way
13:17:47 <lyxia> I thought sugar is about syntax.
13:17:54 <glguy> It is
13:18:08 <latro`a> you could implement the state monad through a syntax transformation
13:18:09 * geekosaur feels like this is looking at the forest v looking at the trees
13:18:33 <Gurkenglas> Well depending on where you draw the boundary between the user level and the compiler level, the prelude definitions could also count as sugar
13:18:34 <latro`a> it would be tedious to do this in a way that would remain compatible with do notation, but you could do that, too
13:18:41 <nshepperd1> Well, the state monad (transformer) automates doing something boring and obvious
13:18:48 <nshepperd1> Which is why it's so great
13:19:00 <laudiacay> everything is syntactic sugar on 0's and 1's come on guys
13:19:05 * hackagebot hlint 1.9.39 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.39 (NeilMitchell)
13:19:29 <nshepperd1> But that's true of all of them really eg. Either e
13:19:50 <latro`a> yes, ultimately the exact meaning of "sugar" is always blurry, but that doesn't invalidate the point that what it's doing is very simple
13:20:02 <maerwald> it's not blurry
13:20:24 <Gurkenglas> It's blurry to him ok
13:20:25 <maerwald> there is a desugaring process during compilation
13:20:27 <maerwald> it either happens or not
13:20:30 <nshepperd1> The benefit is that you can use generic functions rather than hardwiring the behaviour of State into everything
13:20:32 <latro`a> that's relative to the compiler
13:20:36 <latro`a> not relative to the user
13:20:40 <maerwald> err wat
13:20:40 <latro`a> the compiler can be rewritten
13:20:46 <latro`a> to do more desugaring
13:21:03 <latro`a> and in the case of state this actually wouldn't be very hard
13:21:14 <latro`a> no one would actually do this, but you *could*
13:21:15 <maerwald> yes, but it's not sugar in GHC.
13:21:36 <latro`a> sure, I should've said "blurry for the user", with a fixed compiler something is either sugar or not
13:21:39 <latro`a> fair point
13:21:49 <Gurkenglas> Is there a difference between maerwald-style sugar and compilation beyond what ghc calls the different sections of work?
13:22:58 <fabio_> @pl (\n -> if n = 0 then lhd else lnth (pred n) % ltl )
13:22:58 <lambdabot> (line 1, column 14):
13:22:58 <maerwald> is that trolling?
13:22:58 <lambdabot> unexpected " "
13:22:58 <lambdabot> expecting operator
13:23:19 <nshepperd1> Well, syntactic sugar is generally less... principled than data? State monad functions have a type and a denotation
13:23:21 <fabio_> @pl (\n -> if n = 0 then lhd else lnth (pred n) . ltl )
13:23:21 <lambdabot> (line 1, column 14):
13:23:21 <lambdabot> unexpected " "
13:23:21 <lambdabot> expecting operator
13:23:44 <fabio_> @pl (\n -> if n = 0 then lhd else lnth (pred n) . ltl)
13:23:44 <lambdabot> (line 1, column 14):
13:23:44 <lambdabot> unexpected " "
13:23:44 <lambdabot> expecting operator
13:23:50 <nshepperd1> It's not c++ style arbitrary metaprogramming either
13:24:26 <Gurkenglas> maerwald, I'm just checking your definition for whether it gives indistinguishable things different names
13:24:49 <maerwald> there is no maerwald-style sugar, so your question does not make sense
13:25:15 <Koterpillar> fabio_: try (==)
13:25:31 <Gurkenglas> By "maerwald-style sugar", I meant the sort of sugar that maerwald described
13:25:52 <fabio_> @pl (\n -> if n == 0 then lhd else lnth (pred n) . ltl)
13:25:52 <lambdabot> ap (flip if' lhd . (0 ==)) ((. ltl) . lnth . pred)
13:27:01 <laudiacay> @pl (\(a,b,c) -> (a,b)
13:27:01 <lambdabot> (line 1, column 8):
13:27:01 <lambdabot> unexpected "c"
13:27:01 <lambdabot> ambiguous use of a non associative operator
13:27:03 <laudiacay> @pl (\(a,b,c) -> (a,b))
13:27:03 <lambdabot> (line 1, column 8):
13:27:03 <lambdabot> unexpected "c"
13:27:03 <lambdabot> ambiguous use of a non associative operator
13:27:16 <laudiacay> porQUE
13:28:04 <Gurkenglas> @pl (\(a,(b,c)) -> (a,b)) -- pl does not know (,,)
13:28:04 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,))
13:28:10 <geekosaur> it has to parse to recognize those, and the parser doesn't bother handling 3-tuples because there's no way to make them pointfree
13:28:34 <geekosaur> (there are fst and snd, but not thd + fst/snd don't generalize over N-tuples)
13:28:39 <laudiacay> ohhhh 
13:28:40 <laudiacay> cool
13:29:07 <lyxia> fabio_: you can not spam #haskell by sending lambdabot private messages
13:29:09 <laudiacay> there was a guy playing with that in here the other nice
13:31:07 <Gurkenglas> laudiacay, http://hackage.haskell.org/package/tuple provides combinators but usually you want pattern matching, lenses or records.
13:32:15 <laudiacay> Gurkenglas: yeah i think the guy was talking about lenses
13:33:14 <laudiacay> also what was the rationale to not make indexable tuples
13:33:17 <Gurkenglas> laudiacay, one of these? http://ircbrowse.net/browse/haskell?q=lens
13:33:33 <laudiacay> that was jchia_ yeah
13:33:59 <laudiacay> like fst and snd are great but we really should go up to at least like 3
13:34:15 <laudiacay> nested 2-tuples are really ugly 
13:34:34 <Gurkenglas> 5-tuples are also ugly
13:34:51 <laudiacay> at some point you want to just use record syntax or whatever
13:34:58 <laudiacay> but 3 tuples are totally a manageable thing
13:35:22 <Gurkenglas> 2-tuples make sense for key-value pairs. Where do 3-tuples make sense?
13:36:09 <laudiacay> Gurkenglas: key-value-value setups are things ive used a lot
13:36:23 <laudiacay> like if you are dealing with a database, a value, a name, and some info
13:36:47 <Gurkenglas> Sounds like (key, (value,value)) would make it work with all the libraries that do (key,value) stuff
13:37:00 <laudiacay> Gurkenglas: true, but why should haskell enforce that?
13:37:38 <laudiacay> wouldn't it be easier/faster to deal with 3-tuples instead of the mary poppins' purse of tuples
13:37:58 <laudiacay> or like, 3-dimensional coordinate spaces
13:38:15 <MarcelineVQ> Dim x y z ?
13:38:30 <Koterpillar> once you give concrete meaning to these tuples, they are better represented by a concrete data type
13:38:39 <laudiacay> tuples are way prettier for that i think
13:38:53 <ongy> laudiacay: it's not enforced by the language. It's just easier to only deal with 2-tuples.
13:39:00 <laudiacay> like, in math, they're uncurried, shouldn't haskell reflect that?
13:39:01 <niez> lyxia, http://lpaste.net/349532, far from ideal solution, but it will work, do you have any hints? the worst thing is that I need to manually map field names
13:39:46 <laudiacay> i think there's definitely an argument to be made for indexing higher-order tuples
13:40:20 <geekosaur> that argument has indeed been made; and it leads to lens
13:40:33 <laudiacay> ooh
13:40:47 <geekosaur> (more generally, to van Laarhoven lenses)
13:41:16 <laudiacay> im looking at a lens tutorial and it looks terrifying
13:41:43 <koz_> laudiacay: It's really not that bad.
13:41:56 <koz_> However, it is almost always overkill for what you need to do.
13:42:11 <geekosaur> might start with a simpler implementation. ekmett's lens library is quite complex and general, but the concepts behind it are fairly simple
13:42:19 <laudiacay> like, we have map vs fmap specifically to cater to beginners, even though that's an incredibly ugly solution just for the purpose of "beginner friendly"
13:42:49 <koz_> laudiacay: Try this: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
13:42:58 <koz_> It's a little bit funnier and less intimidating.
13:43:11 <codedmart> I have a web app with a logging function. If I pass it a Handle I created when I started my app nothing is ever appened. But if I run the openFile in the logging function then it is appened. Anyone that can tell me why?
13:43:33 <laudiacay> why would you enforce using lens to index tuples when it could be implemented as just a crappy "get_nth_argument :: Int -> (something,somethingelse) -> Maybe (something or somethingelse)
13:43:43 <geekosaur> because it can't be
13:43:50 <geekosaur> you can't iterate a tuple
13:43:56 <laudiacay> koz_: why is that in my history already haha
13:44:05 <koz_> laudiacay: Dunno, lol.
13:44:23 <laudiacay> geekosaur: and i suppose it /would/ be really ugly to implement 19023 implementations of that for all the tuples
13:44:29 <Gurkenglas> laudiacay, what would be the concrete x in "Int -> (a,b,c) -> x"?
13:44:29 <laudiacay> with cases of the int
13:44:38 <laudiacay> Gurkenglas: sadness i suppose
13:45:28 <Gurkenglas> niez, looks like something that deriving FromJSON could help with?
13:45:34 <niez> laudiacay, regarding lenses, you can try with focus from Elm first: https://github.com/evancz/focus http://package.elm-lang.org/packages/evancz/focus/latest/Focus library is very simple, attached links are very good resource (for example https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation)
13:45:39 <geekosaur> codedmart, that description doesn't provide anywhere near enough information. @lpaste code?
13:45:50 <laudiacay> niez: oooooh
13:45:54 <geekosaur> also, which web framework?
13:46:07 <codedmart> geekosaur: I guess my question is doesn openFile close the Handle at some point automatically?
13:46:17 <geekosaur> nope
13:46:48 <niez> Gurkenglas, how?
13:47:02 <codedmart> ok thanks! I will try and debug some more and get some pastes together.
13:47:28 <geekosaur> withFile does; things like hGetContents manage the Handle behind your back; openFile requires manual management of the Handle's lifetime
13:47:48 <laudiacay> niez: this looks like "my nail polish is wet so i don't want to pick this thing up" "OK SEND IN ARNOLD SCHWARZENEGGER HE'S REALLY GOOD AT LIFTING THINGS AND ALSO A CRANE" levels of overkill
13:47:53 <geekosaur> (it may close at some point after the Handle becomes unreferenced, but you would have no control over when)
13:48:20 <geekosaur> tuples aren't the only problem people want to solve. there's also the problem of reusing record field names
13:48:20 <Gurkenglas> niez, I'd need more context to say more, and this is just a hunch
13:48:48 <laudiacay> geekosaur: true, it seems like a lot to learn if you want to do general tuple-indexing stuff
13:49:37 <geekosaur> they're the same problem in slightly different guises
13:49:45 <nshepperd> lenses are great and I'd encourage everyone to learn about them
13:50:15 <codedmart> geekosaur: Is it safer to just use openFile in the logging function then so I know it opens each time?
13:50:19 <geekosaur> as is "iterating" over the fields in data Pair a = Pair a a
13:50:22 <laudiacay> i will once i manage to not ruin my chances of CS grad school by passing this final
13:50:28 <nshepperd> just don't panic :)
13:50:38 <codedmart> Because the next call on the logger func doesn't throw an error so it must not still be open.
13:50:58 <niez> Gurkenglas, I'm playing with servant and persistent, and I have /area endpoint which gives me list of objects, now I want to add sorting, so request would look like /area?sort_by=name or /area?sort_by=something-else, so I need to convert incoming string into SelectOpt to pass that to selectList
13:51:08 <geekosaur> hm? if it were closed then you'd get a handle closed exceptionj
13:51:30 <codedmart> No I mean you get an error when it is already opened don't you?
13:51:38 <laudiacay> nshepperd: too late haskell gives me anxiety
13:51:40 <geekosaur> nope
13:51:49 <codedmart> Oh I thought you would.
13:52:02 <codedmart> Hmm... ok well some more digging then. Thanks!
13:52:05 <geekosaur> iirc that once did happen but it was removed
13:53:20 <lyxia> niez: the main problem is that you have a result type that depends on the string value
13:54:04 <lyxia> wrapping in Asc hides that, but that is the reason why it is difficult to write this function generically
13:55:22 <codedmart> geekosaur: So I should be able to call openFile when my app starts, pass that handle around writing to that file, with no problems?
13:55:38 <niez> lyxia, can I do something about that? it looks like this is the way persistent works
13:56:30 <niez> lyxia, I just want to sort by given column, very basic thing I think
13:58:45 <Gurkenglas> niez, if you only use the result of toSortingOption in one place, couldn't you pass the String through instead, case match on that instead of the Asc, and save Asc's definition?
13:59:29 <lyxia> oh you can probably use persistFieldDef to derive the strings on the left from the constructors on the right
14:03:37 <niez> lyxia, there are some strings but I can't see how it is associated with EntityField defined through TH, can I somehow get a map like [("name", PersonName), ("age", PersonAge)] ? 
14:06:34 <niez> Gurkenglas, selectList expects select options as [Asc PersonName], the problem is mapping from string ("name") to field (PersonName), or directly to option (Asc PersonName), as lyxia pointed out, I can't make a function that returns PersonName or PersonAge
14:07:22 <niez> Gurkenglas, but this isn't so bad, I can wrap it in Asc, but manual mapping is not acceptable, I have about 100 tables
14:14:01 <niez> lyxia, this example: http://lpaste.net/349533 (from http://www.yesodweb.com/book/persistent), there is persistFieldDef defined, but it is one way mapping as far as I understand haskell, I can't reverse that mapping (because it is done by function definition and pattern matching)
14:14:24 <lyxia> Are you working with a particular backend already, or does your code have to stay generic with parsistent
14:14:56 <niez> lyxia, no
14:15:03 <laudiacay> how does GHC keep track of memory addresses so that it can do things quickly?
14:15:26 <niez> lyxia, well, I would like to use postgres as backend
14:15:37 <laudiacay> also, under the hood, lists aren't just linked lists, right? like, there's a pointer or something to every element?
14:16:03 <laudiacay> please tell me list indexing isn't o(n) in haskell
14:16:22 <geekosaur> lists are just linked lists, indexing is O(n). if you want indexed access, you use Vector or Array
14:16:33 <laudiacay> wait, there are arrays? I was lied to!
14:16:40 <laudiacay> also how does GHC handle memory locations?
14:17:07 <davean> laudiacay: of course there are arrays, if there eren't you could just write them
14:17:17 <lyxia> niez: It's missing a way to enumerate the fields
14:17:38 <davean> lyxia: as for handling memory allocation, thats complicated, but bassicly it adds to an offset pointer
14:17:39 <geekosaur> Array exists, Vector is better optimized for the use cases it supports but Arrays handle a number of things Vector doesn't (at least not directly)
14:17:41 <laudiacay> davean: true but how would you define them not-recursively
14:17:50 <lyxia> niez: but given a list of wrapped fields you can get the mapping Text -> wrapped fields
14:17:52 <davean> lyxia: huh?
14:18:08 <davean> lyxia: recursively?
14:18:08 <laudiacay> also low-level GHC anyone?
14:18:25 <lyxia> davean: what?
14:18:35 <geekosaur> laudiacay, as to your other question, what aspect(s) of memory locations?
14:18:41 <laudiacay> like everything idk
14:18:41 <davean> laudiacay: I have no idea what you mean by recursively
14:19:00 <laudiacay> davean: like how would you implement an array yourself
14:19:31 <laudiacay> an n-tuple?
14:19:35 <laudiacay> like I'
14:20:02 <geekosaur> you do not access memory directly by address, except as part of the FFI for communicating data between Haskell and C. Haskell is garbage collected, and handles allocation and deallocation for you (aside from the FFI since lifetimes may depend on usage/availability of memory in C)
14:20:04 <laudiacay> I wouldn't know how to do it besides something really yucky with like defining a variable for every index
14:20:21 <laudiacay> geekosaur: FFI?
14:20:40 <davean> laudiacay: www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
14:21:14 <geekosaur> laudiacay, Foreign Function Interface
14:21:28 <laudiacay> davean: oh this is fab thanks
14:21:55 <davean> laudiacay: there exist amortized constant time methods
14:22:09 <laudiacay> geekosaur: hmm. any resources about that?
14:22:29 <laudiacay> davean: this is awesome tbh
14:22:40 <davean> laudiacay: theres a PDF of it BTW
14:22:44 <davean> laudiacay: it was his thesis
14:22:46 <laudiacay> yeah i found the PDF
14:22:50 <laudiacay> cmu, right?
14:22:57 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008 and https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html
14:23:04 <laudiacay> thanks geekosaur!
14:23:36 <davean> geekosaur: technically thats not haskell still, right? ;)
14:23:37 <laudiacay> woah what's the haskell report?
14:24:13 <geekosaur> davean, it was formally adopted as an addition to Haskell98, and as such included in Haskell2010
14:24:29 <davean> geekosaur: as an interface, the other side of it isn't Haskell ;)
14:24:55 <geekosaur> right, I cited it as an exception to Haskell's own handling
14:25:03 <laudiacay> so lazy evaluation, does that happen at runtime or compile time
14:25:16 <davean> geekosaur: oh, missed that
14:25:19 <davean> laudiacay: runtime
14:25:50 <laudiacay> davean: so the "This is x and its definition is sitting over there or smth" happens at runtime and is encoded into the executable
14:25:52 <laudiacay> hmm
14:26:32 <davean> well, its more "this is the defintion of x, or the value, we'll tell you when you look"
14:26:39 <laudiacay> hm okay
14:27:01 <laudiacay> thanks
14:27:13 <davean> The first time you look its how to calculate it, the second time you look its what was calculated
14:27:25 <davean> Or maybe the first time you look its what was calculated
14:27:34 <davean> thats up to the compiler to decide
14:27:42 <laudiacay> yeah, ezyang's adorable lil webcomic taught me that
14:27:46 <laudiacay> have you seen it it's so cute
14:27:52 <laudiacay> i squealed for like 10 minutes straight
14:28:07 <laudiacay> there are presents and ghosts and kitties and a ghost-o-matic
14:28:08 <Welkin> o.o
14:28:13 <Welkin> are you a hog?
14:28:18 <maerwald> in addition, you don't easily know what is lazy or if you broke it
14:28:29 <laudiacay> no just a teenage girl in the presence of cute things
14:28:29 <maerwald> it's not part of the types either
14:28:38 <laudiacay> maerwald: huh?
14:28:42 <Koterpillar> laudiacay: liiiiiiiink
14:28:52 <maerwald> laudiacay: I don't understand the question
14:28:57 <davean> laudiacay: anyway, why is an array the correct thing for what you're doing?
14:29:10 <davean> laudiacay: and I can't recall if I saw that one
14:29:16 <davean> laudiacay: I've lost track of webcomics over time
14:29:16 <laudiacay> Koterpillar: LOOK THEY HAVE LIL EYES http://blog.ezyang.com/2011/04/the-haskell-heap/
14:29:25 <laudiacay> davean: oh it's not i was just curious
14:29:36 <Welkin> laudiacay: you must love LYAH
14:29:39 <laudiacay> maerwald: what do you mean "lazy or broke it"
14:29:41 <laudiacay> Welkin: do i ever
14:29:55 <maerwald> just what I said
14:30:31 <laudiacay> sorry i don't understand :( like, what do you mean "broke"? can't haskell only "break" when it doesn't typecheck?
14:30:43 <davean> laudiacay: I mean, theres bottom
14:30:45 <laudiacay> and isn't that taken care of before it runs,?
14:30:51 <davean> laudiacay: this isn't a dependantly typed language
14:30:52 <laudiacay> what's bottom again? someone taught me that
14:31:02 <maerwald> laudiacay: no, you can "break" laziness, depending on how you pattern match etc
14:31:04 <davean> laudiacay: its when something fails to be computable basicly
14:31:23 <davean> laudiacay: say, for example you have a partial function like "head", which somehow even made it into the prelude
14:31:26 <laudiacay> ohhhh okay maerwald you mean like non-exhaustive patterns
14:31:31 <maerwald> no
14:31:49 <davean> Thats a bottom, or two computations that hold MVars the other needs to progress can be a bottom
14:31:50 <laudiacay> but is that an error of "breaking laziness"?
14:31:58 <maerwald> see https://wiki.haskell.org/Maintaining_laziness
14:32:01 <laudiacay> davean: wait wait
14:32:05 <davean> Technically infinite recurions can be seen as a bottom too
14:32:10 <laudiacay> what is a partial function
14:32:16 <davean> laudiacay: one thats not fully defined
14:32:23 <laudiacay> like, you mean in that head can fail on an empty list?'
14:32:25 <davean> isOne 1 = True
14:32:40 <davean> is only defined for 1, all other values passed to it lead to bottom
14:32:45 <laudiacay> ohh okay
14:32:47 <mckeankylej> What package would allow me to big endian encode an int to a bytestring with the most minimal set of deps?
14:32:48 <davean> laudiacay: yes
14:32:51 <Welkin> total functions are what you want
14:33:02 <davean> laudiacay: also "error ____" and "undefined" are bottoms
14:33:04 <lpaste> lyxia annotated “No title” with “to niez (annotation)” at http://lpaste.net/349532#a349534
14:33:07 <laudiacay> ooh okay
14:33:10 <maerwald> I want partial functions though
14:33:24 <maerwald> and a theorem prover telling me if I use them safely
14:33:29 <davean> laudiacay: do you have a programming background with other languages?
14:34:02 <laudiacay> so you can catch all the bottoms with maybe i'm guessing? and davean yes very much, but the only thing i've ever come close to functional stuff with was mathematica and some python stuff
14:34:05 <Cale> ahahaha, I love the ghost analogy for seq
14:34:10 * hackagebot rei 0.4.0.3 - Process lists easily  https://hackage.haskell.org/package/rei-0.4.0.3 (kerkomen)
14:34:16 <Welkin> Cale: what ghost?
14:34:39 <Welkin> how have I never heard of these before
14:34:46 <Cale> http://blog.ezyang.com/2011/04/the-haskell-heap/
14:34:56 <davean> laudiacay: ok, I was just getting a bit confused with the questions you were asking about what you might know or not which is helpful to understand when trying to answer questions usefully instead of mearly correctly
14:35:00 <niez> lyxia, thanks
14:35:08 <Cale> "Some presents explode when you open them, others are haunted by ghosts that open other presents when disturbed."
14:35:19 <Welkin> oh
14:35:45 <davean> Cale: I try to be very carely not wrap bombs
14:35:53 <laudiacay> davean: sorry :( i have extensive programming background in other languages, not much as far as functional goes, but i am studying for a final in an honors intro cs class in haskell
14:35:57 <niez> lyxia, and what about generics? can I use that for some type information at run-time or at compile-time?
14:36:00 <davean> *I try to be very careful about not wrapping bombs
14:36:19 <laudiacay> but i keep getting distracted by the intricacies of GHC because GHC is cool
14:36:20 <davean> laudiacay: ok, well then bottom corresponds to non-computability
14:36:26 <davean> laudiacay: they're only sort of catchable
14:36:26 <laudiacay> oh okie that makes sense
14:36:47 <laudiacay> but you can try to catch it with maybes and eithers and that's the point of them right?
14:36:57 <davean> laudiacay: SOMETIMEs they are under very specific circumstances but actually trying to catch them in gneral leads to the haulting problem
14:37:00 <laudiacay> like just adding in an f _ = Nothing as a last case
14:37:06 <davean> laudiacay: no you can only catch them in IO
14:37:13 <laudiacay> haulting problem?
14:37:14 <davean> you can AVOID them with Maybe and Either
14:37:20 <laudiacay> mmm true
14:37:22 <davean> hum
14:38:12 <davean> I'll just refer you to wikipedia for en.wikipedia.org/wiki/Halting_problem
14:38:44 <laudiacay> oh no a wikipedia page with the word theory in it
14:38:47 <davean> Its a well known CS theory proof about undecidability, you should familiarize yourself with it in general and I can't do it justice over IRC
14:38:48 <laudiacay> time to not study parsers
14:38:51 <laudiacay> thanks though :D
14:39:09 <davean> Its pretty fundimental to our understanding of computability
14:39:17 <davean> hell, it basicly *is* our understanding of computability
14:39:43 <laudiacay> ok i'm not babai but like
14:39:50 <laudiacay> can't maybes just avoid all of this
14:39:55 <davean> No
14:40:07 <davean> citation: godel
14:40:20 <davean> also: halting problem
14:40:27 <Welkin> also, the chinese box
14:40:28 <laudiacay> just throwing around nothings to handle things that aren't in the domain of every single function won't help
14:40:31 <laudiacay> ?
14:40:46 <davean> laudiacay: nope, because domain isn't decidable
14:40:56 <davean> I take it you have no theory background?
14:40:57 <laudiacay> w ha t 
14:41:21 <davean> This might get longer then is sensible for this channel
14:41:26 <laudiacay> i am a college freshman in my first proof-based math class, and occasionally i read wikipedia pages
14:41:31 <Welkin> what kind of cs class is this?
14:41:38 <Welkin> seem more like a pure math class
14:41:55 <davean> Welkin: all the good CS classes are pure math classes
14:42:02 <davean> Welkin: the rest seem pretty useless in retrospect :)
14:42:18 <Welkin> the only ones I ever took were about data structures and algorithms
14:42:24 <davean> I think the only non-math CS class I still get *anything* out of is my OS class 
14:42:35 <laudiacay> Welkin: uchicago honors intro, we just do haskell and went up to like parsers/states then jumped to logic and quine's method. i'm studying for the final and kinda got sucked down a wormhole of wikipedia pages that looked cool
14:42:41 <davean> Welkin: no foundations/theory of computation? languages?
14:42:47 <lyxia> niez: I don't know enough about persistent, but the GADT is quite incompatible with generics.
14:43:06 <Welkin> davean: I never finished the degree, so I didn't end up taking OS or compilers
14:43:11 <Welkin> but it was computer engineering
14:43:15 <Welkin> so it was more hardware based
14:43:20 <laudiacay> ok can someone tldr me godel/halting problem and why we can't make a totally failsafe haskell program with IO
14:43:29 <davean> Welkin: well, a few years after school the theory classes were all that were still useful to me
14:43:30 <Welkin> very practical
14:43:50 <laudiacay> davean: what do you do where the theory was useful?
14:43:51 <davean> Welkin: the rest were eclipsed or replaced with more relivent learning
14:43:55 <davean> laudiacay: basicly anything
14:44:07 <davean> laudiacay: I can try, but lets do it in PMs?
14:44:14 <davean> I think it is a bit off topic here
14:44:22 <laudiacay> davean: like, careerwise, do you use this theory and how?
14:44:25 <laudiacay> and yes please!
14:44:52 <Welkin> pretty much everything I use to build real applications I learned here, or from some books/tutorials/blogs/wikis
14:45:04 <Welkin> almost nothing I learned from classes
14:45:12 <MarcelineVQ> davean, laudiacay: there's also #haskell-offtopic if you want to also share to an audience
14:45:45 <davean> Welkin: exactly, but the theory sticks with you because its just true and fundimental 
14:45:52 <laudiacay> davean: let's do that
14:46:07 <maerwald> "it's just true" :o
14:47:30 <Tuplanolla> > it
14:47:32 <lambdabot>  Just True
14:47:45 <Welkin> Tuplanolla: cheating with PMs
14:48:10 <Tuplanolla> There's no `RULES`.
15:19:13 * hackagebot timespan 0.2.0.0 - Useful timespan datatype and functions  https://hackage.haskell.org/package/timespan-0.2.0.0 (AlexanderThiemann)
15:36:17 <Jello_Raptor> You know, there's got to be some metric by which we can judge colorings of jellybeans 
15:36:40 <Jello_Raptor> there's some score for level of compatibility of different flavours 
15:36:48 <Jello_Raptor> and another for the similarity of colors 
15:37:43 <Jello_Raptor> and some way to assign a map from colors to flavours that allows you to judge compatibility of flavours by seeing the similarity of colors 
15:38:19 <mnn> Why does fmap length Just [1, 2, 3] == 1 but fmap (length Just [1, 2, 3]) == 3?
15:38:20 <geekosaur> did you want -offtopic perhaps?
15:38:47 <geekosaur> mnn, are you missing some parentheses?
15:39:02 <Jello_Raptor> there's an -offtopic? 
15:39:07 <mnn> geekosaur, My bad: Why does fmap length Just [1, 2, 3] == 1 but fmap length (Just [1, 2, 3]) == 3?
15:39:20 <mnn> > fmap length Just [1, 2, 3]
15:39:23 <lambdabot>  1
15:39:25 <mnn> > fmap length (Just [1, 2, 3])
15:39:27 <lambdabot>  Just 3
15:39:42 <mnn> I understand what's going on in the second case
15:39:50 <mnn> But what is the fmap doing in the first?
15:39:57 <geekosaur> :t fmap length Just
15:39:59 <lambdabot> a -> Int
15:40:35 <mnn> > fmap (length Just) [1,2,3]
15:40:37 <lambdabot>  error:
15:40:37 <lambdabot>      • Couldn't match expected type ‘Integer -> b’
15:40:37 <lambdabot>                    with actual type ‘Int’
15:41:19 <geekosaur> two things happening: (1) it's mapping over the Applicative instance for ((->) e) (functions); (2) a Maybe is a Foldable, whose length will be 0 (Nothing) or 1 (Just _)
15:42:15 <mnn> Hm okay, I guess I need to think about the applicative instance for functions
15:42:33 <geekosaur> well, strictly the Functor instance not Applicative
15:43:16 <mnn> so it's basically just composition
15:43:32 <geekosaur> in this case, it turns a function (Just, which turns an a into a Maybe a) into a function that produces the length of the result of applying that function
15:44:13 <mnn> So why is the result not equivalent to (length . Just) [1,2,3]
15:44:21 <unskill> What is Applicative? I know what Functor is and what Monad is and why it is monoid in category of endofunctors. But Applicative...
15:44:28 <mnn> mnn, Never mind, it is :)
15:44:37 <geekosaur> heh
15:44:46 <mnn> geekosaur, Thanks as usual :)
15:45:35 <geekosaur> it does take some getting used to --- and the Foldable instance for Maybe is considered by some to be a wart (it does have its uses, but they're somewhat rare and in return you get a bit of a confusing "trap")
15:46:24 <kadoban> I really like Maybe being Foldable, it makes sense and it makes for cute little constructions.
15:47:29 <Gurkenglas> We could call it teachable moment instead of trap
15:47:44 <geekosaur> and Functor/Applicative/Monad for functions is very useful but also highly confusing when you aren't expecting it
15:47:46 <unskill> Applicative is something which is not so PRed.
15:48:08 <geekosaur> Applicative is much younger than Functor or Monad, in terms of Haskell
15:48:13 <geekosaur> @where typeclassopedia
15:48:13 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:49:05 <c_wraith> Heck, isn't isolating Applicative as an interesting mathematical abstraction more recent than the isolation of functor and monad?
15:49:05 <geekosaur> ...and to make things worse, they used to not be called applicatives. Many older papers etc. about them called them "idioms"
15:52:02 <unskill> 've you heard about Bartosz Milewski?
15:53:49 <mettekou> geekosaur: That's interesting; do you recall the titles of some of those papers?
15:54:11 <geekosaur> @google idioms are oblivious
15:54:13 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
15:54:13 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
15:54:34 <geekosaur> ^ that was the paper that really put them on the Haskell map
15:55:00 <Welkin> lol
15:55:01 <geekosaur> sometime after that people started calling them applicative functors, later shortened to applicatives
15:55:14 <Welkin> what is with academics and ridiculous/cheesey paper titles?
15:55:22 <dolio> That paper is way later.
15:55:41 <geekosaur> there has to be something to compensate for the often rather dry content...
15:55:52 <MarcelineVQ> Welkin: gotta stand out somehow
15:55:59 <geekosaur> (granted, Haskell related papers are less dry than many)
15:56:10 <Welkin> I like SPJ's papers
15:56:22 <Welkin> yeah that is true
15:56:30 <Welkin> I've tried reading some biology and chemistry papers
15:56:34 <Welkin> no idea wtf is going on
15:56:46 <Welkin> doesn't even seem like english
15:57:15 * geekosaur reads those and even mostly understands them. (also physics and math papers but often with less understanding)
15:57:36 <geekosaur> ...they're often heavy going even when you do understand them
15:57:37 <dolio> The original paper on applicatives was called "Idioms: Applicative Programming with Effects." I think.
15:59:15 * hackagebot stb-image-redux 0.2.1.0 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.2.1.0 (sasinestro)
16:03:16 <dolio> And even though it looks like they were both published in 2008, Control.Applicative was already in the GHC libraries by 2006, so the 'Applicative Programming with Effects' paper had been known before that.
16:04:32 <dolio> Just not published in a journal.
16:09:41 <grazie> running `cabal install Data.Random.Normal`  says `The file does not exist 'Data.Random.Normal'     
16:09:46 <grazie> how would you install https://hackage.haskell.org/package/normaldistribution-1.1.0.3/docs/Data-Random-Normal.html
16:10:06 <grazie> it doesn't say on the linked to page
16:10:18 <Welkin> install it using the package name
16:10:22 <Welkin> normaldistribution
16:10:43 <Welkin> you can include the version number too if you want to specify
16:11:12 <grazie> oops, thank you
16:24:17 * hackagebot exception-transformers 0.4.0.5 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.5 (GeoffreyMainland)
16:42:14 <jle`> lyxia: why not both CS and Physics? :)
16:42:57 <fr33domlover> hello. what do you think about randomly throwing exceptions from various places if i know they'll be caught and handled? for example, in Yesod, HTTP error statuses are signaled by throwing an exception. But if I freely use that in my handlers it may be hard to track the flow. I feel better about using ExceptT instead and throw the result once, in one place in the code
16:43:03 <fr33domlover> does that make sense? :P
16:43:46 <fr33domlover> (i mean non trivial cases, say a handler function wants to throw at least in 4-5 different places
16:51:16 <davean> fr33domlover: I think exceptions are a really ugly way to handle control flow
16:51:22 <davean> fr33domlover: and it  becomes really annoying to maintain
16:51:49 <davean> While its not really incorrect, it sure pushes work to the future you
16:53:20 <davean> Of course, maybe you hate future you
16:54:27 <fr33domlover> davean, i feel somewhat the same, that's why i prefer to use ExceptT there
16:54:55 <fr33domlover> which doesn't do any magic
16:55:51 <davean> fr33domlover: ExceptT is better, I think just returning the response straight up is usually nicest, but ExceptT is better then exceptions.
16:56:00 <davean> Of course it always comes down to the code base
16:56:25 <davean> theres value in consistency but that value is highest inside a code base if its large
16:56:34 <davean> the smaller it is, the more value there is to have consistency between code bases
16:56:47 <davean> I won't even try to say whats right for your specific case
17:02:51 <lucky> http://lpaste.net/349539 I've been banging my head against this problem for a while now, the basic idea is that I want to compute a list of offsets from a start time, but it just hangs, I meanit should be an infinite list generating an infinite amount of output but it just hangs an I don't even know how to begin to debug that tbh
17:03:47 <Gurkenglas> lucky, gendates offset just keeps calling itself with ever longer x's
17:04:23 <lucky> Gurkenglas: i don't see the problem with that, it's an infinite list but I won't normally be treating it at as such, see the take 40 
17:04:41 <Gurkenglas> It can't ever find out even the first element of the result list
17:05:14 <Gurkenglas> Consider f x = f (x ++ x)
17:05:52 <geekosaur> lucky, infinite lists work by producing something *before* recursing. yours immediately recurses; it can never produce something
17:05:55 <Gurkenglas> f [1,2] is evaluated to f ([1,2] ++ [1,2]) is evaluated to f (let x = [1,2] ++ [1,2] in x ++ x) and so on
17:05:59 <lucky> won't that just produce an infinite list of x's concatenated together if evaluated?
17:06:58 <Gurkenglas> Okay, consider f (number:xs) = f (number - 1:number:xs)
17:07:22 <Gurkenglas> *"f (number:xs) = f ((number - 1):number:xs)"
17:08:02 <lucky> geekosaur: I don't see how it's supposed to "produce something" without halting the recursion?
17:08:07 <geekosaur> > let inf x = x : inf (x+1) in take 30 $ inf 0 -- produce a partial result, *then* recurse
17:08:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:08:37 <Gurkenglas> f [10] -> f [9,10] -> f [8,9,10] -> f [7,8,9,10] -> … -> f [0,1,2,3,4,5,6,7,8,9,10] -> f [-1,0,1,2,3,4,5,6,7,8,9,10] -> …
17:08:50 <geekosaur> laziness "happens" at constructors; it's the (:) there that lets the partial result be consumed before generating the rest of the list
17:09:09 <lucky> so basically I should prepend, not postpend 
17:18:42 <lucky> so i've been at it again for another 15 minutes and http://lpaste.net/349540 
17:19:11 <lucky> I really am ... I guess i'm just not understanding recursion, I still haven't really "got it" and have to reason about it in terms of iteration I dunno if that's just some sort of mental block I'm having
17:24:18 <ab9rf> you really do need to move past an iterative model 
17:25:30 <lucky> And I really do not understand the examples you're giving, the notation is very weird and I have yet to find a place that explains these f and x's which I assume are standard abbreviations 
17:26:07 <lpaste> geekosaur pasted “recursion (lucky)” at http://lpaste.net/349541
17:26:36 <geekosaur> I didn't complete my description of how recursion works, because I realized I needed more than IRC's line at a time
17:27:23 <geekosaur> so your current version recurses on the left value; this will never reach the end of the list, and can't be lazy (or ever finish)
17:28:35 <lucky> so i was almost right about prepend, don't post-pend 
17:28:47 <lucky> in particular don't require the result to depend on previous computations 
17:29:00 <lucky> or rather, future
17:29:08 <geekosaur> for laziness to work, the recursive call must be to the *right* of the (:); the value on the left must be computable without recursion, or the recursion will never be able to produce a partial value, it must process the whole list to produce anything
17:29:38 <lucky> I thought I already knew that, I don't understand why my code doesn't meet those criteria :/
17:29:41 <Gurkenglas> "future" <- yep that's the gist of it, when your first list item depends on an infinite number of future computations, you'll have to wait infinitely for that first list item
17:30:47 <geekosaur> because it's <recursive case> : xs
17:31:04 <geekosaur> it needs to be <something> : <recursive case>
17:31:05 <lucky> yes, I see that now
17:31:18 <lucky> okay, I'll see if I can make this work
17:36:46 <jayjayjay> is there a way to use + operator as prefix? lisp like (+ 3 5)
17:37:03 <Gurkenglas> (+) 3 5
17:37:11 <jayjayjay> wow thanx
17:37:19 <lucky> yes any operator which is purely symbols can be parenthesized to make ita prefix operator
17:37:31 <lucky> just as any textual operator can be wrapped in `...` to make it infix
17:37:59 <jayjayjay> thx :)
17:39:41 <Gurkenglas> Why do we restrict the operator precedence relation to factor through a set of numbers, let alone [0..9]?
17:41:14 <hpc> Gurkenglas: couldn't say for the 0-9, but numbers are easily orderable and representable
17:41:18 <Tuplanolla> Rationals between 0 and 1 would indeed be a better idea.
17:41:59 <lucky> success!  thanks geekosaur and Gurkenglas 
17:42:07 <lucky> I just had to think more carefully about what I was trying to achieve.
17:43:28 <geekosaur> fixities/precedence is a pain no matter how you do it, sadly
17:45:49 <unskill> What is sad is that quite often IO functions are called "unsafe" (without quotes).
17:46:37 <jle`> can you give an example?
17:47:26 <davean> unskill: I mean, unsafe ones are ...
17:47:32 <davean> unskill: I'm not really sure what you're getting at
17:47:39 <unskill> Not unsafe, sry. impure
17:47:47 <jle`> i've heard IO functions called a lot of things, but 'unsafe' is not one i've heard
17:48:17 <davean> unskill: yah, when you say things with the wrong words they're confusing :)
17:48:21 <davean> that makes a lot more sense
17:48:34 <jle`> ah yeah, i've heard people call 'putStrLn' an impure function
17:48:53 <jle`> or functions involving the IO type as impure, and tha'ts kind of unfortunate
17:48:56 <hpc> there's a certain perspective in which IO can be considered impure
17:49:03 <hpc> but fortunately in haskell it's a wrong perspective ;)
17:49:08 <geekosaur> often "impure" is abused to mean "you don't actually have a value at this point, you're registering something to happen if/when a value does appear"
17:49:19 <hpc> the point of IO as a distinct type is that you get that purity back
17:49:23 <unskill> I've heard people saying "Haskell is good because pure and impure functions are clearly separated by marking the latter ones by IO type"
17:49:33 <davean> The purity of IO is sort of a phylisophical/moral question
17:49:35 <jle`> the IO type can definitely be considered to describe impure effects, but functions on IO are as pure as cna be
17:49:45 <jle`> putStrLn is a pure function under any interpretation
17:49:55 <jle`> given the same input, it returns the same output every single time (an IO ())
17:50:02 <jle`> and doesn't do any effects in the process of producing that IO ()
17:50:03 <Gurkenglas> Well sure if functions that produced IO were impure they'd be wrapped in IO
17:50:26 <davean> jle`: sure it produces an effect, it allocates and memory effects are rather more observable then not in haskell
17:50:44 <davean> We just choose to usually ignore that
17:50:51 <jle`> i guess it's pure under any interpretation that considers anything in haskell to be pure
17:50:56 <davean> When you get right down to it though we can't really ignore that
17:51:03 <jle`> in this sense it's not different than any function like (+1) or show
17:51:07 <davean> jle`: yah, and frankly, nothing in Haskell is really all that pure
17:51:12 <davean> it just is pure enough to be useful
17:51:29 <davean> the impurity is something I think about all the time
17:51:47 <jle`> well, the denotations are pure
17:52:10 <jle`> the process of computing what they evaluate to can't be pure ofc
17:52:52 <jle`> but i can clarify what i said earlier; putStrLn is considered pure in every sense that would call (+1)/show/negate/etc. pure
17:53:03 <davean> Haskell casts pure shadows on teh wall and we pretend their the universe
17:53:19 <davean> ... holy storm
17:53:26 <hpc> who are all these [m] people?
17:53:29 <geekosaur> glitch in the matrix.org
17:53:54 <geekosaur> (web irc gateway with extra features)
17:54:12 <hpc> ugh, it's the new cgiirc
17:55:00 <haasn> strongly recommend turning on a smart filter that hides joins/parts for people who haven't been active within the last X minutes
17:55:10 <haasn> (and also a netsplit detector and mass highlight blocker :p)
17:56:09 <davean> haasn: it happens so rarely on moderately decently run IRC networks I actually kinda enjoy seeing it
17:56:13 <hpc> stock irssi 4 lyf
17:56:50 <ogkloo> on that note, anyone know a decent explanation for getting an irc bot to connect over ssl?
17:57:01 <hpc> but yeah, it's usually convenient enough to ignore effects at the layer of "makes your cpu warmer"
17:57:21 <hpc> there's some other invisible sources of impurity in haskell if you squint a bit
17:57:24 <hpc> such as the size of Int
17:57:34 <hpc> > maxBound -- not always the same
17:57:36 <lambdabot>  ()
17:57:39 <hpc> er
17:57:42 <hpc> > maxBound :: Int
17:57:44 <lambdabot>  9223372036854775807
17:58:07 <hpc> imagine running a 32-bit and 64-bit compilation of the same code
17:58:14 <hpc> or running the same code in a differently-compiled ghci
17:58:15 <haasn> Haskell is (or tries to be) pure in the sense of referential transparency
17:58:29 <haasn> I'm not sure that really holds across ABIs
17:58:34 <hpc> yeah
17:58:39 <haasn> Or makes any sense in that context
17:58:41 <hpc> it's definitely outside the realm of a single program execution
17:58:58 <hpc> so it depends on how broad your idea of reference is
17:59:06 <hpc> but still a good thing to be aware of
17:59:30 <haasn> That's also the sense in which putStrLn etc. are pure: you can replace  do putStrLn "foo"; putStrLn "foo"  by let x = putStrLn "foo" in do x; x
17:59:31 <hpc> as is the allocation cost of evaluation, the effects of memory overflow from that evaluation, etc
18:00:10 <hpc> yeah, that's closer to what a formal definition of referential transparency would be
18:00:38 <hpc> where you would define it as two expressions being equal within the language semantics
18:00:46 <hpc> er, equivalent
18:00:48 <haasn> The only thing I'd say is strictly non-pure about formal haskell are exceptions (which are imposed by the environment due to e.g. memory limitations), but Haskell gets around it by making it so you can only catch exceptions from IO
18:00:54 <hpc> (since not everything is comparable for equality)
18:01:00 <haasn> obviously excluding unsafe* stuff here
18:02:40 <haasn> hpc: yeah not to mention literally replacing “foo 42 ++ foo 42” by “let x = foo 42 in x ++ x” might cause your program to suddenly start crashing due to different memory requirements and stack behaviors
18:02:44 <haasn> or even type checking issues
18:03:04 <haasn> so it's important to clarify in which sense referential transparency is semantical idea and not a literal idea
18:03:30 <hpc> haasn: there's even some funny situations where adding parallelism reduces memory usage
18:03:58 <hpc> because effects of parallel evaluation include not just reducing to normal form but releasing references
18:04:38 <Gurkenglas> "print $ [1..n] ++ [1..n]" takes constant space and "print $ let x = [1..n] in x ++ x" takes n space
18:05:38 <haasn> technically that's all an implementation detail based on GHC's ad-hoc optimization heuristics
18:06:24 <hpc> lucky: btw, https://en.wikibooks.org/wiki/Haskell/Recursion
18:06:56 <lucky> thank you
18:06:58 <hpc> lucky: er, https://en.wikibooks.org/wiki/Haskell/Lists_III
18:07:31 <hpc> lucky: there's a notion of induction and recursion that you will end up unconsciously using a lot with list functions you write
18:08:03 <hpc> and some of the stuff on that page will be good for seeing the structure behind it
18:14:01 <lucky> hpc: thanks, none of the ideas are new to me (having used them in imperative languages) i've just never written anything nontrivial in Haskell before 
18:28:23 <unskill> Reading "Applicative programming with effects". Holy cow, I'll never get used to Applicative.
18:29:23 <ogkloo> okay so being confused about applicatives is normal
18:29:56 <unskill> shitshtorm again
18:30:20 <unskill> ...
18:30:55 <haasn> If (<*>) is too confusing, try approaching Applicative from the perspective of liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c,  or even from the perspective of liftA2 (,) :: Applicative f => f a -> f b -> f (a, b)
18:31:12 <haasn> In this context, applicative just lets you “merge” two values together in an associative sense
18:31:20 <haasn> and it also provides an identity for this merging operation
18:31:39 <haasn> It's basically like a higher-order version of a monoid
18:32:22 <codygman> How can you do something like "variableName = 1" with template Haskell, where Variable Name is spliced in? Then when called from another file invoking variableName would return 1.
18:32:34 <haasn> for something like Maybe, the monoidal operation is “both must succeed” or “failure propagates”
18:32:43 <haasn> for something like [], the monoidal operation is the cross product
18:32:50 <codygman> my difficulty is because none of the quasiquoters seem to support "x = 1"
18:33:00 <haasn> and for something like IO, the monoidal operation is “first the left, then the right”
18:35:18 <unskill> haasn: may be liftA2 is better. It is like Monad. You don't understand >>= until someone come and show you >=> and you see that monad is just function composition of special kind of functions.
18:35:29 <unskill> *maybe
18:35:47 <codygman> Looks like I was looking for the d quasiquoter
18:36:11 <haasn> yeah I think (>=>), or alternatively join, are the more primitive building blocks with which to understand monads
18:36:40 <haasn> if applicative lets you “merge” operations side by side, monad lets you “chain” an operation that returns another operation
18:36:58 <haasn> e.g. in the context of IO, applicative merges side effects, monad chains them
18:37:58 <unskill> Activated "Join/Part Hiding" in Pidgin. Hope I won't see shitstorms anymore.
18:48:16 <fuffy0x> wow i should have used that weechat filter years ago
18:54:27 * hackagebot pgdl 10.5 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.5 (sifmelcara)
18:57:41 <unskill> Lol. One time I was thinking to write FUSE driver for web directory listings. But then I went to sleep.
19:11:34 <javjarfer> Hello all, if we are talking about a functor type being "data F a = F { f :: (s ->a) }" and we define fmap as a function which first argument (a -> b) really takes the first "a". Are we really taking about a "Functor" in the categorical sense? Because it maps functions (s->a) to F a but it doesn't map morphisms between that functions.
19:13:01 <Cale> javjarfer: uh
19:13:11 <Cale> fmap :: (a -> b) -> (F a -> F b)
19:13:23 <Cale> fmap is the action of the categorical functor on arrows
19:13:32 <Cale> F is the action of that functor on objects (which are types)
19:14:00 <Cale> fmap takes a function a -> b, and turns it into a function F a -> F b
19:17:57 <javjarfer> Cale, exactly but in that case the mapping between arrows and the mapping between types doesn't match
19:18:39 <Cale> hm?
19:18:47 <Cale> What do you mean?
19:19:47 <Cale> In CT literature, you'd likely see fmap written as "F" as well, just when it's applied to arrows rather than objects, it's understood that you're talking about that half of the definition of a functor.
19:20:15 <unskill> May he means that the functior is contravariant
19:20:23 <Cale> It's not though.
19:21:33 <unskill> Isn't s -> a == (->) s a with fixed `a' is contravariant in `s' ?
19:23:20 <javjarfer> Cale, yes, I meant that F maps functions "(s ->a)" the objects, but fmap, maps functions "(a -> b)" which aren't morphisms between those objects
19:23:55 <Cale> javjarfer: uh
19:24:09 <Cale> javjarfer: F sends each type a to the type F a
19:24:16 <Cale> (which is implemented as (s -> a))
19:24:30 <Cale> javjarfer: and fmap sends each function (a -> b) to a function F a -> F b
19:24:39 <jchia> How do people decide whether to use strict or lazy ByteString (especially in libraries)? E.g. why does the binary package use lazy ByteString instead of strict? When using two libraries that have different strict/lazy convention (e.g. binary & hedis), my code is littered with toStrict & fromStrict. Is there a better way?
19:24:44 <Cale> which, if you like, is the same as a function (s -> a) -> (s -> b)
19:26:09 <Cale> jchia: Well, it's a performance thing. Lazy ByteStrings are good if you'd like to take advantage of their ability to stream, and not have the entire thing in memory at once.
19:27:00 <jchia> Cale: That much I know, but I can I explain why some libraries use lazy and some use strict?
19:27:11 <jchia> "...but how can i explain..."
19:27:22 <unskill> Cale: ah, it is just reader functor.
19:27:31 <Cale> unskill: yes
19:27:39 <Cale> jchia: Well, a lot of them actually don't decide on one or the other, but provide interfaces for both...
19:27:42 <unskill> Cale: sry, I'm unskilled.
19:28:57 <unskill> BTW, why "reader"?
19:29:10 <jchia> Cale: I think binary & hedis are not among them. Do you have an example of a library that provides both strict & lazy interface?
19:33:18 <javjarfer> Cale, I never thought about it the opposite way... So "a" mapped to "(s->a)" instead of the opposite way
19:34:59 <javjarfer> Cale, it's so clear now, maybe the function was confusing me. Maybe it's too late xD. Thanks you so much, I can sleep now xD
19:45:42 <unskill> fmap ::  Functor f => (a -> b) -> (f a -> f b) -- type of "fmap" means we have functor "f" which only knows how to lift objects and needs "fmap" to lift morphisms
19:45:42 <unskill> (<*>) :: Applicative f  => f (a -> b) -> (f a -> f b) -- doesn' this mean that functor "f" is able not only lift objects, but also exponentials?
19:46:08 <javjarfer> Cale, sorry just one thing. In the case of Maybe for example, you have Just who maps you from a to F a and fmaps who maps the function. So this time, you have think about the relationship backwards, simply because you can, true?
19:48:00 <Cale> javjarfer: Nope, Just has nothing to do with it
19:48:21 <mnn_> Can someone help me understand the applicative instance from here please :) : https://github.com/dmvianna/haskellbook/blob/master/src/Ch25-Twinplicative.hs
19:48:26 <Cale> The action of the functor on objects (types) is provided by Maybe itself
19:48:40 <Cale> e.g. Maybe sends the type Integer to the type Maybe Integer
19:48:47 <mnn_> In particular, stuck on   (Compose f) <*> (Compose a) =            Compose $ ((<*>) <$> f) <*> a
19:49:00 <Cale> and then fmap sends a function Integer -> String to a function  Maybe Integer -> Maybe String
19:49:13 <javjarfer> Cale, okay so just taking about type constructors. 
19:49:18 <Cale> So that's the part of the functor which acts on arrows
19:49:20 <mnn_> Which I rewrote as (Compose f) <*> (Compose a) = Compose $ (fmap <*> f) <*> a
19:49:25 <javjarfer> Talking about***
19:49:28 <Cale> right
19:49:44 <Cale> The data constructors don't necessarily correspond to anything on the CT side of things
19:50:17 <Cale> (well, they often do, but it's probably some natural transformations related to the functor in question)
19:50:25 <mnn_> In particular, I'm a bit confused about what the type of f and a are
19:50:43 <javjarfer> Cale, okay, I think that leads me to the confusion when I through about the inner function.
19:50:52 <Cale> e.g. Just :: forall a. a -> Maybe a can be thought of as a natural transformation from the identity functor to Maybe.
19:51:23 <jle`> i like Compose f <*> Compose a = Compose (liftA2 (<*>) f a)
19:51:35 <unskill> Cale: every monad is a natural transformation from the identity functor to other functor
19:51:48 <unskill> endofunctor
19:51:52 <mnn_> jle`, I guess I'm getting confused because of the <*> operator
19:52:06 <jle`> all you're doing is lifting (<*>), w/ liftA2
19:52:18 <mnn_> jle`, What are the types of f and a?
19:52:31 <mnn_> Here's the link again, https://github.com/dmvianna/haskellbook/blob/master/src/Ch25-Twinplicative.hs
19:52:40 <jle`> you can ask ghc :)  Compose f <*> Compose a = Compose _
19:52:50 <jle`> the compiler message will tell you the type of 'f' and 'a'
19:53:24 <jle`> but yeah, in this case, f is f (g (a -> b)), and a is f (g a)
19:53:47 <javjarfer> Cale, a beautiful way of seeing it... I'm just starting to make bigger associations about category theory and sometimes I get really confused but seeing analogies like that, helps me a lot. Thanks
19:53:49 <jle`> so actually maybe one way to write it would be (liftA2 . liftA2) ($)
19:53:53 <jle`> :t liftA2 ($)
19:53:54 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
19:54:01 <jle`> :t (liftA2 . liftA2) ($)
19:54:02 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> c)) -> f (f1 a) -> f (f1 c)
19:54:14 <jle`> you're basically lifting ($) over two layers of applicatives
19:54:23 <jle`> so liftA2 to lift it once, (liftA2 . liftA2) to lift it twice
19:54:36 <unskill> Applicative in some sense related to internal hom functor?
19:55:22 <Cale> unskill: Well, the 'return' of every monad is.
19:55:51 <mnn_> Would :t f :: f g (a -> b) ? Sorry, not following
19:55:54 <jle`> javjarfer: so if <*> for 'one layer' is liftA2 ($), the <*> for 'two layers' (your composed functors) is (liftA2 . liftA2) ($)
19:56:04 <jle`> er that was meant for mnn_ 
19:56:09 <jle`> mnn_: it'd be f (g (a -> b))
19:56:30 <Cale> unskill: and join :: M (M a) -> M a will be a natural transformation from M . M to M
19:56:50 <mnn_> jle`, I tend to find the types confusing with record syntax is used in general. Is there a good way to tell what's going on?
19:57:37 <jle`> mnn_: the type of (<*>) is Compose f g (a -> b) -> Compose f g a -> Compose f g b
19:57:45 <jle`> and what is "in" a Compose f g (a -> b) ?
19:57:46 <unskill> Cale: yeah
19:58:00 <jle`> mnn_: just look at the definition -- Compose f g a = Compose (f (g a))
19:58:07 <jle`> so a Compose f g (a -> b) contains an f (g (a -> b))
19:58:48 <jle`> so you have an f (g (a -> b)) and an f (g a), and you want to get an f (g b)
19:59:08 <jle`> so you want to just map ($) over two layers of functors
19:59:22 <mnn_> Hmm
19:59:24 <jle`> liftA2 ($) :: f (a -> b) -> f a -> f b
19:59:28 <javjarfer> unskill, For what I know, applicative can be compared with a lax monoidal functor, together with two natural transformations and a strength
19:59:36 <jle`> (liftA2 . liftA2) ($) :: f (g (a -> b)) -> f (g a) -> f (g b)
20:00:07 <mnn_> jle`, I see, still don't think I'd be able to do this myself though :/
20:00:10 <jle`> liftA2 :: (a -> b -> c) -> (f a -> f b -> f c), for the record
20:00:20 <javjarfer> unskill, source here, http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
20:00:22 <jle`> mnn_: like i said, you can ask ghc what the types of your 'f' and 'a' bindings are
20:00:34 <unskill> javjarfer: Now it is much more clear
20:00:34 <unskill> (no)
20:00:46 <jle`> mnn_: but, liftA2 is a common pattern for lifting a function over two functoral values
20:00:52 <jle`> > liftA2 (+) (Just 10) (Just 8)
20:00:55 <lambdabot>  Just 18
20:01:22 <mnn_> jle`, How would I ask ghc? wouldn't i actually need an example?
20:01:27 <jle`> if you have an (a -> b -> c) and an 'f a' and an 'f b', you'd get an f c with liftA2
20:01:31 <jle`> mnn_: i mentioned eralier
20:01:43 <jle`> Compose f <*> Compose x = Compose _
20:01:52 <jle`> and the compiler will tell you what types all your in-scope bindings are
20:02:05 <jle`> where the hole is
20:02:24 <mnn_> jle`, As in if I tried to compile with that, it's tell me what the bindings for f and x were based on the newtype declaration and the type of <*>?
20:02:34 <jle`> yeah
20:02:43 <jle`> but you don't have to take my word for it :)
20:03:04 <mnn_> jle`, Yep, I see what you were saying now
20:03:16 <mnn_> jle`, thanks :)
20:03:21 <jle`> no problem!
20:03:36 <jle`> but yeah, having an 'f a' and an 'f b' and combining it with an (a -> b -> c) is a common pattern
20:03:54 <javjarfer> unskill, sorry, I think it's simply a special case of functor and that isn't related with that
20:07:24 <unskill> javjarfer: I just did want to say that the type of (<*>) is looks like "Well, `f`, you've mapped internal hom, now let's turn it into non-internal one"
20:14:11 <unskill> Is not right?
20:14:58 <unskill> *it is
20:15:01 <mnn_> How is (Monad f, Monad g) => f (g a) -> (a -> f (g b)) -> f (g b) :: (Monad f, Monad g) => f (g (f (g a))) -> f (g a)?
20:16:05 <jle`> not sure how to parse that
20:16:14 <jle`> how is some type :: some other type?
20:16:26 <mnn_> As in the first can be rewritten as the second
20:16:47 <mnn_> (supposedly according to haskell book)
20:17:21 <jle`> mnn_: they're not the same type
20:17:25 <jle`> but if you have one, you can have the other
20:17:40 <mnn_> jle`, How can we go about figuring that?
20:17:55 <jle`> the first one is like (>>=) and the second one is like 'join'
20:18:04 <javjarfer> unskill, it really looks like that for me too... But maybe it's beyond my knowledge, don't trust too much
20:18:15 <jle`> `(f . g) a -> (a -> (f . g) b) -> (f . g) b`
20:18:20 <jle`> like m a -> (a -> m b) -> m b
20:18:25 <jle`> where m is (f . g)
20:18:35 <mnn_> jle`, Oh, because m is like f g here
20:18:35 <jle`> the second one is (f . g) ((f . g) a) -> (f . g) a
20:18:44 <jle`> (f . g), yeah
20:18:58 <mnn_> jle`, I see, will continue to struggle with this ;) Thanks
20:19:22 <jle`> i thiiink if the book makes that claim, it'll also try ot justify it too the way i did
20:19:58 <mnn_> jle`, Yea, it's been pretty solid up until now, but explanations are becoming rather spotty :/
20:20:17 <mnn_> jle`, Part of it is i'm handling stuff that's much newer to me now
20:20:39 <jle`> i'm sure bitemyapp (one of the co-authors who hangs out here) would appreciate any feedback :)
20:24:50 <unskill> javjarfer: http://stackoverflow.com/questions/35013293/what-is-applicative-functor-definition-from-the-category-theory-pov#comment57862620_35047673
20:26:34 <unskill> javjarfer: closed functor means that it preserves exponentials
20:27:51 <unskill> which are internal homs in first place
20:29:29 <unskill> So I was right asking "does it mean that functor `f` is Applicative if it maps not only objects, but also exponentials"
20:31:21 <javjarfer> unskill, so you were right in several things xD. It seems to me very curious than there exist that controversial
20:33:19 <unskill> I'm just glad that I'm not completely stupid and noticed something which agrees with Kmett's observations.
20:35:56 <javjarfer> unskill, If I would have notice something like that, that would totally make my day. I'm far from that kind of observations
20:36:38 <javjarfer> unskill, but I have something more noted for read tomorrow
21:01:52 <martinium> can I use the read function to convert a string stored in a variable?
21:02:31 <martinium> convert it to an Int?
21:02:49 <Koterpillar> martinium: yes, because Int is an instance of Read
21:03:06 <Koterpillar> martinium: also, try and find out:
21:03:14 <martinium> so I did x <- getLine
21:03:16 <Koterpillar> > read "160243" :: Int
21:03:19 <lambdabot>  160243
21:03:21 <martinium> then entered 25
21:03:28 <martinium> i want to convert x to an int
21:03:33 <martinium> but get an error
21:03:43 <Koterpillar> what kind of error?
21:04:12 <martinium> *** Exception: Prelude.read: no parse
21:04:22 <Koterpillar> what's the code?
21:04:39 <martinium> read x
21:05:31 <martinium> tried assigning a type but get the error
21:05:37 <martinium> this is all in repl
21:06:31 <Koterpillar> when you type "read x" in a repl, GHCi doesn't know that you want an Int
21:06:35 <Koterpillar> and it defaults to ()
21:06:50 <Koterpillar> the only possible value of that type is (), and its string representation is "()"
21:06:53 <Koterpillar> > read "()"
21:06:55 <lambdabot>  ()
21:06:57 <martinium> I tried read x :: int
21:06:57 <Koterpillar> > read "25"
21:06:59 <lambdabot>  *Exception: Prelude.read: no parse
21:07:09 <Koterpillar> int or Int?
21:07:25 <martinium> ah
21:07:27 <martinium> there it is
21:07:32 <martinium> int was the problem
21:07:35 <martinium> neded to be Int
21:07:39 <martinium> needed*
21:08:04 <martinium> capitalization problem
21:08:07 <Koterpillar> Haskell is case sensitive.
21:08:23 <martinium> good to know
21:08:47 <martinium> thanks
23:03:52 <geppettodivacin> @pl \f g x y -> f (g x y)
23:03:52 <lambdabot> (.) . (.)
23:44:23 <jle`> geppettodivacin: i usually do \x -> f . g x
23:44:55 <geppettodivacin> Thanks, jle`.
23:45:37 <jle`> np!
