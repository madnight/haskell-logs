00:23:17 <quchen> Haddock supports property markup nowadays using »prop«. How can I spread those properties over multiple lines?
00:50:40 <liyang> barrucadu: you named all the *Config fields in irc-client with an _ prefix, as if you were intending to include lens accessors, but they're nowhere to be found. What was the intention?
00:52:53 <paolino> are functor, monad and typeclasses laws coming from commutativity in graphs of CT ?
01:04:19 <c_wraith> paolino: I'm not completely sure what you're asking, but profunctors and monads definitely come from CT, and their laws more or less come from the commutativity graphs
01:05:02 <c_wraith> paolino: I'm not sure profunctors are called out specially in CT - they're just bifunctors that are covariant in one side and contravariant in the other.
01:06:04 <jle`> quchen: oh, the line didn't come off as smug to me
01:06:19 <quchen> jle`, OK :-)
01:27:39 <niklasb> hey, quick stupid question: http://lpaste.net/4645347292033843200 can somebody tell me how the first line is valid and what it does?
01:30:12 <RoxxikM2> Giving x a value, on the top level, by pattern matching? Didn't know this was possible
01:30:25 <MarcelineVQ> it's a pattern match that brings x into scope, try it out in ghci and type x afterwards. you can also write (y,z) = splitAt 1 "foo" and see what y and z are
01:30:38 <niklasb> oh I see
01:30:45 <niklasb> didn't know you could do that
01:31:18 <RoxxikM2> Sure, but it's uncommon to do at the toplevel
01:35:49 <MarcelineVQ> It's fairly uncommon, but not fundamentally different than    foo = x    foo just doesn't scrutinize any constructors
01:41:06 <MarcelineVQ> however you will see it very commonly in let and where expressions
01:46:18 <paolino> c_wraith, I'm wondering like "where does extend f . extend g = extend (f . extend g) come from ?"
01:46:52 <paolino> or any other law I have to check for the classic instances
01:47:45 <c_wraith> yeah, those laws come from how the diagrams commute.
01:48:09 <c_wraith> After all, that equality is just saying "here are two equivalent paths between these points"
01:48:24 <c_wraith> err, two equivalent paths to this point.
01:48:34 <paolino> so, now my question is why people are telling not to study CT to do haskell
01:50:14 <paolino> or, maybe is just not do it up to a point where you have to write your instances
01:50:19 <Gurkenglas> paolino, usually there's some sort of combinator f (b, c) -> f (a, b) -> f (a, c) that is supposed to satisfy the same laws everytime: Associativity and the existence of identity, like in a monoid
01:50:38 <lyxia> paolino: because you can understand the laws without explicitly learning about CT
01:50:39 <Gurkenglas> Where I mean f as a function that takes for example b and c and turns them into some type
01:51:05 <Gurkenglas> For monads, f (b, c) = b -> m c
01:51:26 <Gurkenglas> For comonads, f (b, c) = m b -> c (I think?)
01:51:34 <paolino> yes
01:51:54 <Eliel> paolino: I tried simulating in my mind what those two expressions do and the results turned out identical. So, it's just really two different ways of expressing the same thing.
01:52:16 <Gurkenglas> For Applicatives, f (b -> c) (I think?)
01:52:25 <Gurkenglas> *f (b, c) = m (b -> c)
01:53:23 <paolino> Eliel, after a couple of days it start to make *some* sense but I don't feel at ease to learn like this
01:54:28 <paolino> Gurkenglas, it's fine, I see the point of the common monoidal structure
01:54:46 <paolino> but we are already talking about CT now, isn't it ?
01:55:16 <Gurkenglas> From what I remember you'd need like the first half of the first chapter of a CT book for this
01:56:04 <Gurkenglas> I mean, with more you might be able to justify why exactly these f (b, c) mappings.
01:56:55 <paolino> well they are the simplest kind mapping probably
01:57:39 <c_wraith> paolino: we don't tell people to learn CT in order to learn haskell for two main reasons.  1. It isn't necessary.  2. Too many people already are afraid of haskell because they think it's necessary.
01:58:56 <Gurkenglas> Sure if you're Ekmett you might use advanced CT to decide what library to write next
01:59:27 <paolino> but, if seeing these structures in your code is necessary to reuse the basic haskell tooling, isn't understanding laws a precondition ?
02:00:34 <paolino> c_wraith, I'm not suggesting to change politics :-)
02:01:55 <paolino> I'd like to understand how to get the meaning of the various compositional laws without studying CT, really
02:05:05 <paolino> My question was actually: is a trie a comonad ?
02:06:23 <paolino> how to define it, to be it
02:12:01 <lyxia> non-empty tries, perhaps
02:12:41 <Gurkenglas> ((:->:) a), you mean? What are extract and duplicate?
02:13:25 <Gurkenglas> Sounds more like it might be a monad (except for the same reason set has), like ((->) a)
02:16:46 <paolino> lyxia, an empty trie has a focus on [] or any mempty for it and duplicate to itself I guess
02:18:52 <paolino> Gurkenglas, I was interested in the comonadic aspect of it to inspect prefixes at different depths
02:20:59 <lyxia> How does "duplicate to itself" type check
02:21:49 <lyxia> "a focus on []" do you mean that to be a default element of tries? Basically making a trie a map String -> a?
02:21:54 <int-e> paolino: It's quite possible to discover fairly abstract ideas in Haskell without knowing CT. An example (in which I was involved myself), is the type Control.Monad.Free.Church.F, http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html#v:F ... which is explained by Edward Kmett in two blog articles in terms of the Codensity Monad, written in 2011. However, exactly the...
02:22:00 <int-e> ...same type already appears in https://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/Control-Monad-Prompt.html#t:Prompt from 2008. In that case, it was found by applying the insight that the CPS transform (embodied in the Cont monad) could be specialized to the case of the prompt monad (which again is a very operationally oriented name for the free monad). Where CT does shine though is in...
02:22:06 <int-e> ...making this idea even more reusable; for example, it invites you to think about the meaning of duals, something that operationally makes little sense (at least to me).
02:22:44 <paolino> lyxia, duplicate E = E
02:23:06 <lyxia> E of type?
02:23:11 <lyxia> What is the type of E?
02:24:10 <lyxia> How do you extract []?
02:24:18 <paolino> data Trie a b = N b (Map a (Trie a b)) | E b -- guessing 
02:24:52 <paolino> duplicate (E x) = E (E x)
02:25:14 <lyxia> Okay I guess I should have asked about your definition of a trie first.
02:25:34 <lyxia> This one is never empty so you can always get something out of it.
02:26:02 <paolino> I don't have one, which is just a comonad, Iwould like to understand how to reason about making one that is
02:27:03 <paolino> but id b is a Monoid
02:27:05 <lyxia> I just stare at the laws and smash things until they fit.
02:27:33 <lyxia> Someone else may have a more principled approach.
02:27:36 <paolino> data Trie a b = N b (Map a (Trie a b)) | E  -- should fit
02:30:35 <paolino> int-e, good point, thanks, Free is on my tolearn list
02:51:03 <augur> anyone know how one might grab ahold of a bunch of usefully-represented type signatures from hackage?
02:51:26 <augur> like perhaps from a hoogle database or something?
03:02:03 <augur> or should i just resort to scraping source code for type sigs manually
03:03:57 <JuanDaugherty> i'd look at something in leksah or eclipsefp
04:02:35 <haskell20020> Has anyone looked into Matrices as a category?
04:02:53 <haskell20020> They're basically functions
04:04:04 <haskell20020> You can write an instance of them for Category if you ignore that Category only takes things of kind * -> * -> * and not any k -> k -> *
04:30:08 <lyxia> where objects are numbers and morphisms between n and m are matrices of dimensions n,m ? I'm sure it's something known.
04:42:53 <nshepperd1> lyxia: there's the category of vector spaces of finite dimension
04:43:15 <nshepperd1> With linear maps (matrices) as the morphisms
04:43:25 <ij> Can a Monadask'ed 
04:44:15 <ij> Can a newtype (that has a type that's MonadMask'ed inside) get a derived MonadMask(a: apparently not)? Can I write one?
04:44:17 <nshepperd1> Also iirc category got the polykinds treatment recently, so you should actually be able to use it for Nat -> Nat > *
04:44:30 <ij> (cc Gurkenglas)
04:44:58 <Gurkenglas> GeneralizedNewtypeDeriving is the relevant extension
04:45:10 <ij> I've got it enabled.
04:45:56 <palmerlao> Hi! I'm new to using stack and am trying to split up a test suite. I have the default test/Specs.hs file, from which I wish to use a module called Set1.Tests in test/Set1Tests.hs, but stack build doesn't seem to be able to find this file
04:46:22 <Gurkenglas> Dunno then. (Ask on stackoverflow too?)
04:46:48 <Gurkenglas> (After giving ppl time to respond here that is)
04:47:36 <dramforever> ij: Does this help? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#stand-alone-deriving-declarations
04:59:48 <MarcelineVQ> why did you leave palmerlao, you could have learned about the relation between modules and folders :(
05:05:23 <praveen> 5
05:12:06 <praveen> I am reading this code online. I want to try similar thing. But it throws me error. this is the line `let query = queryString req :: [(ByteString, Maybe ByteString)]`
05:13:41 <praveen> when I try `let foo = "hello" :: ByteString` . I get Couldn't match the type ByteString to actual type [char]
05:14:28 <ertes> praveen: string literals are of type String by default, so you either need 'pack' from Data.ByteString{.Lazy}, or you need the OverloadedStrings extension
05:14:30 <dramforever> praveen: Are you sure you typed in everything?
05:14:37 <ij> Do «:set -XOverloadedStrings»: http://sprunge.us/NXLC
05:14:59 <praveen> oh no I didn't
05:15:20 <praveen> what is it called in haskell. Infrence ? 
05:15:30 <ertes> praveen: type error =)
05:16:17 <ertes> praveen: type signatures aren't *declarations*, but merely *assertions*
05:16:43 <ertes> you asserted that "hello", which is a String, is a ByteString
05:16:52 <ertes> and the compiler tells you: "you're wrong!"
05:17:49 <praveen> ertes made a lot more sense now
05:20:31 <ij> I'm not quite sure how StandaloneDeriving could help me or even works; I couldn't make it make me a MonadMask instance: http://sprunge.us/jhDi
05:21:56 <dramforever> ij: Looks it's not standalonederiving. You have another problem
05:22:03 <dramforever> No instance for (MonadCatch Bot)
05:22:20 <ij> Aaaah. This I should've noticed myself.
05:22:23 <dramforever> How about deriving (..., MonadCatch, MonadMask)
05:23:03 <ij> Yup, that + MonadThrow.
05:24:00 <ij> \o/
05:31:18 <chrissound> Spacemacs keeps giving me a "invalid option `--ghc-options=-ferror-spans'". Anyone know what might be causing this? 
05:42:23 <quchen_> chrissound: The »'« at the end looks like it’s the problem.
05:43:22 <Darwin226> Hey guys. I have a question about how concurrency works here http://stackoverflow.com/questions/41313777/how-does-the-rts-detect-that-a-thread-is-blocked-indefinitely-on-an-mvar-operati
05:43:35 <Darwin226> I'd appreciate if someone would take a look and  comment/answer there.
05:47:16 <hpc> Darwin226: http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/
05:48:08 <Darwin226> hpc: Thanks very much. This seemed impossible to google
05:48:54 <Darwin226> So it means there's a chance that it works exactly like I hoped?
05:50:50 <chrissound> quchen_: Yeah I've just installed spacemacs though so no idea where that command is. Something to do with the 'haskell sesison' it seems.
05:53:34 <quchen_> chrissound: I’m using Atom, so I’m not the right person for Emacs questions I’m afraid :-
06:08:56 <kuribas> :t (>>)
06:08:58 <lambdabot> Monad m => m a -> m b -> m b
06:09:27 <kuribas> Why does ghc warn about discarding arguments in do, since do a; b is equivalent to  a >> b?
06:15:29 <lyxia> I found the warning useful sometimes
06:17:26 <dramforever> Monadic functions generally don't return random results you almost always want to discard
06:19:19 <dramforever> If they have no meaningful 'result' it's almost always a m ()
06:27:47 <riaqn> Hi, how to let foo = foo + 1, where the later foo is in the outer context?
06:28:09 <riaqn> I tried it in haskell, and it seems to be some deadloop. i.e., haskell thinks I'm writing a recursive program.
06:28:42 <riaqn> While actually I'm not: I want a inner foo which is outer foo plus 1
06:29:13 <dramforever> How about let foo' = foo + 1
06:30:20 <riaqn> dramforever: I'm using the same name to make logging easier. If the outer logger name is "Main", then inner logger name is "Main.func".
06:30:55 <riaqn> then I only have to write "infoM foo something", wherever I am.
06:31:15 <riaqn> where foo is "Main" in outer context, and "Main.func" in inner context.
06:33:54 <chrissound> Does anyone know any good introdution for snap's heist templating? I'm just looking to do simple things? I'm googling around various resources but if anyone knows of anything please let me know. :)
06:34:18 <pavonia> riaqn: That doesn't make sense, Main is a module name, while Main.func is a function name
06:35:02 <kuribas> dramforever: In parsec I have a lot of results I want to discard.
06:35:12 <Axman6> chrissound: how about the snap website? pretty sure it's got tutorials
06:35:34 <kuribas> dramforever: for example "do char '('; return Paren"
06:35:39 <dramforever> Ah, that
06:35:46 <dramforever> Have you tried Applicative things?
06:36:13 <dramforever> like char '(' *> return Paren
06:36:21 <chrissound> I've been through them, didn't find what I need.
06:36:26 <dramforever> or for *this* example, Paren <$ char '('
06:36:26 <kuribas> dramforever: no, I'll give it a shot :)
06:36:30 <dramforever> :t (<$)
06:36:32 <lambdabot> Functor f => a -> f b -> f a
06:37:46 <chrissound> In fact here is where I got stuck last time. http://stackoverflow.com/questions/41125841/how-do-i-render-a-heist-template-with-splices
06:39:41 <Gurkenglas> Has someone implemented type error slicing for Haskell?
06:45:04 <MarcelineVQ> quite possible, what is it?
06:56:52 <Gurkenglas> Instead of giving a type error, you give a set of places that are all necessary for the type error
06:58:13 <Gurkenglas> (Which lends itself easily to the user finding such a place where he can tell which side of the type mismatch he meant to be correct, halving the set until he knows exactly where his mistake is)
06:59:27 <Gurkenglas> (I mean I thought of that application and then someone pointed out to me that type error slicing is what that's called)
07:02:38 <MarcelineVQ> is it possible to make an example of what you mean? It sounds interesting
07:03:00 <Gurkenglas> Put another way, how does GHC currently decide which type error to display? Would be nice if it gave the one with the shortest mismatching inferred types instead
07:03:03 <Gurkenglas> hmm lemme see
07:04:30 <Gurkenglas> Nah probably better if I link the paper instead of improvising something http://www.macs.hw.ac.uk/~jbw/papers/Haack+Wells:Type-Error-Slicing-in-Implicitly-Typed-Higher-Order-Languages:SCP-ta.pdf
07:11:13 <ph88> hi all
07:12:33 <xcmw> Hi
07:15:48 <kuribas> Wouldn't it be nice to have TeX as a EDSL in haskell?
07:16:09 <kuribas> with TH quasiquotes for inline text?
07:18:42 <ertes> kuribas: for what?
07:18:56 <kuribas> ertes: document processing?
07:19:02 <kuribas> with a sane language
07:19:26 <kuribas> easier to customize and or to interface with other tools.
07:19:52 <ertes> well, why would you reuse TeX then?  it's about as horrible as a language can get ;)
07:20:17 <ertes> i'd probably go with something more lispy
07:21:00 <ertes> or even try a completely different approach to define layout, e.g. through a constraint solver
07:21:11 <ph88> i'm trying to make my function accept polymorphic value instead of a specialized value .. can anyone help? I hope this paste explains well enough what i would like to do. I don't know which technique to use  https://paste.fedoraproject.org/511865/48259277/
07:21:19 <haasn> How come DuplicateRecordFields is so weird? duplicate record fields that I'd normally expect to be easily selected by something like a type instance selection algorithm end up ambiguous instead
07:21:39 <kuribas> ertes: of course, only with the good things of TeX.
07:21:45 <haasn> I mean even the trivial ‘class Has (field :: Symbol) a’ manages to disambiguate record fields just fine
07:21:47 <ertes> kuribas: so nothing
07:22:08 <kuribas> ertes: yes, the paragraph breaking algorithm and the math layout.
07:22:19 <haasn> so I'm not sure why it's so difficult for DuplicateRecordFields to support something like foo = name x where x = Person "example"
07:22:27 <haasn> I have to write foo = name (x :: Person)
07:22:27 <ertes> kuribas: ah, you mean of the TeX system, not the language
07:22:42 <kuribas> ertes: yes
07:23:36 <ertes> ph88: there seems to be a misunderstanding what "polymorphic" means
07:24:21 <ertes> ph88: in simple terms (i.e. when we ignore the RankNTypes extension) a type is polymorphic, when it has type variables
07:24:31 <ertes> ph88: polymorphic:  id :: a -> a
07:24:43 <ertes> ph88: polymorphic:  (+) :: (Num a) => a -> a -> a
07:24:59 <ertes> ph88: not polymorphic:  fooParser :: String -> Parser Foo
07:26:01 <ph88> ertes, i meant you have the structure   Parser a   and then you put your type in so it becomes   Parser Foo  .. isn't that Parser taking a polymorphic value ?
07:26:43 <kuribas> ertes: first I need to finish metafont in haskell
07:26:52 <dramforever> ph88: Nah, only functions can be polymorphic
07:27:15 <ertes> ph88: nope…  polymorphism is a type-level thing
07:27:29 <kuribas> dramforever: what about Num a => a?
07:27:37 <dramforever> functions can have polymorphic types
07:27:42 <ertes> dramforever:
07:27:43 <ertes> :t 0
07:27:45 <lambdabot> Num t => t
07:27:49 <dramforever> ouch
07:27:57 * dramforever needs more sleep
07:28:35 <ph88> ertes, ok so i used the wrong wording for the problem, but i hope the rest of the stuff i wrote still makes clear what i would like to achieve ?
07:30:02 <ertes> ph88: at least in line 39 it seems like what you want is scoped type variables, and we have an extension for that:  ScopedTypeVariables
07:30:39 <ertes> ph88: if you enable it and bind your type variables explicitly, then you can refer to them within the corresponding definition
07:31:07 <nevere> Trying to understand data kinds here. Why does not this type check? http://lpaste.net/350428
07:31:51 <lyxia> Cat is not of kind *
07:31:54 <ertes> @let myMap :: forall a b. (a -> b) -> [a] -> [b]; myMap f = go where go :: [a] -> [b]; go [] = []; go (x:xs) = f x : go xs
07:31:56 <lambdabot>  Defined.
07:32:05 <ertes> > myMap succ [1,3,5]
07:32:06 <Cale> nevere: Because Cat isn't a type which has values.
07:32:07 <lambdabot>  [2,4,6]
07:32:20 <Cale> nevere: The kind of (->) is * -> * -> *
07:32:35 <ertes> ph88: see how in myMap's type i've bound the type variables 'a' and 'b' explicitly, so that i could refer to them in the type signature of 'go'
07:32:47 <Cale> nevere: i.e. both the thing on the left and the right of the -> needs to be something of kind *, but Cat is of kind Animal instead.
07:33:00 <ertes> ph88: "explicit binding" means "forall"
07:35:28 <ph88> ertes, when i use ScopedTypeVariables and put "a" i get a lot of errors:  https://paste.fedoraproject.org/511868/14825936/
07:35:30 <orion> http://i.imgur.com/4nzijje.png <-- in this formula (regarding simply typed lambda calculus), what does the "sideways T" mean?
07:36:08 <kuribas> ertes: my next project would be to improve the "computer modern" typeface.
07:36:10 <nevere> Cale: Ok. So where can I use the type (Cat, Dog) created by this data definition. What is the point?
07:36:10 <ertes> ph88: you *must* bind the variable explicitly:  qcrp :: forall a. Parser a -> …
07:36:59 <ertes> kuribas: i'd ask you to take inspiration from dejavu serif, which is quite a nice screen font
07:38:19 <kuribas> yea, it is nice.  But CMR is a neoclassical typeface, so it would need to be moddeled after those.
07:38:47 <kuribas> ertes: like https://www.myfonts.com/fonts/mti/monotype-modern/
07:39:13 <ertes> ph88: oh, and…  "Main.hs:2368:22"…  remember that haskell has a module system, which really helps keep individual source files small and quick to compile =)
07:39:15 <ph88> ertes, when i add forall a. i get a different set of errors https://paste.fedoraproject.org/511870/48259387/ but i think i can solve them by putting more constraints
07:40:00 <Cale> nevere: You can define a type which accepts a parameter of kind Animal
07:40:06 <ertes> ph88: yeah, apparently you're assuming Show on 'a'
07:40:14 <Cale> nevere: Perhaps a GADT is the most common case
07:40:20 <ph88> ertes, i have over 150 grammar rules, each rule as a parser, printer and arbitrary generator .. i thought it would be a good idea to keep them in the same file
07:40:49 <kuribas> ertes: you know you can already use truetype fonts in TeX?  It's a bit cumbersome, but possible.
07:43:44 <ph88> oh ertes thank you very much, this was very difficult for me :) A question about forall .. last time i was here some people said that by default forall is already there and you only need to put it for Rank-N-types or existential types .. but i think i use neither and i still have to put forall ?? why is that ??
07:44:17 <ertes> kuribas: i haven't really done much style-wise in TeX, mostly because it's impossible to memorise all the necessary commands, and because TeX installations are mostly opaque until you actually browse the filesystem
07:44:38 <S11001001> ph88: forall is also needed for ScopedTypeVariables
07:44:52 <ph88> why though ?
07:45:00 <ertes> kuribas: if you really want to improve the situation, make a typesetting system that can be programmed interactively like haskell or scheme
07:45:42 <ertes> ph88: it's not necessary *in principle*, but in order for ScopedTypeVariables not to break a lot of code it requires explicit binding
07:45:50 <ertes> ph88: so it's a compatibility thing
07:46:08 <kuribas> ertes: yeah, adding fonts amounts to generating like 5 extra support files, putting them in special locations, then recompiling the whole database.  It's pretty involved for something so common.
07:46:32 <kuribas> ertes: what do you mean interactive?  Scheme and haskell aren't interactive?
07:47:10 <kuribas> ertes: you mean something like lyx?
07:47:31 <ertes> kuribas: i can load a file, see what's in scope, which modules are available, etc…  with scheme the experience is even more interactive, because i can reevaluate individual expressions
07:48:11 <ph88> ah ok i get it just to help the compiler a bit ^^
07:48:27 <ertes> ph88: nope, the compiler doesn't need that help
07:48:50 <ertes> ph88: if ScopedTypeVariables wouldn't insist on explicit bindings, it would break a lot of code
07:49:29 <ph88> is it recommended to use "a" or use a word for clarity ?
07:49:54 <ertes> ph88: look at the myMap example from earlier, and remove the "forall"…  it's a different and ill-typed piece of code…  ScopedTypeVariablesWithoutExplicitBinding would make that code suddenly well-typed
07:50:58 <ertes> ph88: that's up to you…  typically you would prefer "descriptive (by convention) single letters" over words, but use words where extra clarity is necessary
07:51:18 <ph88> ok :)
07:51:40 <ertes> ph88: for example you wouldn't write:  forall value monad. (Monad monad) => [monad value] -> monad [value]
07:51:58 <ertes> that's actually harder to read than:  forall a m. (Monad m) => [m a] -> m [a]
07:52:23 <ertes> the length and wordiness obscures the structure of the type, which is the most important aspect of it
07:52:50 <ph88> ah ok
07:59:17 <lyxia> there are some variable names that can be useful, like proxy, instead of a concrete Proxy.
08:01:34 <nitrix> Why is only IdentityT a comonad? What about the other transformers?
08:02:21 <edwardk> nitrix: if you look at the comonad transformers in the comonad package you'll notice they put together the parts just a little different than the monad transformers
08:02:33 <edwardk> usually they'll be something like (e, m a)   instead of m (e, a)
08:02:51 <edwardk> this is because you're using distributive laws to go in the opposite sort of direction
08:03:09 <edwardk> IdentityT works because its easy to take off and put on a newtype wrapper in either direction
08:03:27 <nitrix> Does it mean they could theorically be comonads, had we chosen better representations/wrappers?
08:03:34 <Myrl-saki> Merikuri everyone~
08:04:24 <edwardk> well, they aren't comonad transformers, and they aren't comonads in any obvious canonical way.
08:04:31 <ph88> nitrix, i heard that the list monad does not have a comonad because you can not always extract something from the list (if it's empty). But the non-empty list could have a comonad
08:05:28 <edwardk> ph88: true, but note that the non-empty list comonad and the non-empty list monad don't really have a whole lot to do with each other other than sharing the same algebraic form. return and extract, (>>=) and extend are all basically unrelated operations
08:05:39 <nitrix> My intuition tells me `StateT m` should be able to let you extract the state somehow (as a comonad); I just don't see how the types fit.
08:05:55 <edwardk> nitrix: indeed they dont fit =P
08:06:13 <edwardk> you might want to look into Store as the comonadic form of tate
08:06:15 <edwardk> er state
08:06:26 <edwardk> (s, s -> a)   vs. s -> (a, s)
08:06:28 <nitrix> But I can do runState and obtain it, so there must be something I'm missing.
08:06:35 <nitrix> edwardk: Oh?
08:06:43 <ertes> nitrix: you can only runState when you have a state
08:06:57 <ertes> 'extract' can't rely on state
08:07:08 <edwardk> you can runStateT sure, but that doesn't mean you can build up such a state monad out of simpler parts if m is just a comonad.
08:07:09 <ertes> extract :: State s a -> a  -- it doesn't have access to an s
08:07:35 <edwardk> and to ertes' point: extract :: (s, s -> a) -> a  -- is quite simple
08:08:37 <nitrix> I see what's happening now.
08:08:47 <nitrix> edwardk: Great example.
08:08:52 <edwardk> nitrix: anyways the key insight is that none of the other monad transformers are useful comonad transformers. all the compositions are a little wrong. the laws fall apart
08:09:46 <edwardk> took me a while to find all of the expressable proper duals to the usual transformers
08:09:48 <nitrix> edwardk: I was trying to reinforce my understanding of comonads, which currently isn't better than "extracting from a monad". Now I see that there's more to it.
08:10:04 <edwardk> comonads feel very different from monads when using them
08:10:24 <edwardk> you can build your whole program out of one monad, stitching together bigger and bigger pieces
08:10:30 <ertes> nitrix: monads and comonads have two things in common:  flipped arrows and the word "monad"…  they really aren't as related as you might think
08:10:38 <edwardk> but 'extend' doesn't change the shape of the structure. it just redecorates it.
08:10:48 <nitrix> Cofunctors weren't that bad. I actually enjoyed learning them, other than the negative/position position that took me a while to understand the implications.
08:10:54 <nitrix> edwardk: Gotcha.
08:11:14 <edwardk> if you have data Tree a = Bin (Tree a) (Tree a) | Leaf a -- and you 'extend' a computation on it, you don't change the shape of the tree, you just change out the decorations on the leaves
08:11:26 <edwardk> on the other hand Tree as a monad grafts on new branches below existing leaves
08:11:51 <hodapp> ChristmasTree?
08:12:20 <edwardk> cofunctor = functor.    (a -> b) -> (f a -> f b)   becomes (b -> a) -> (f b -> f a) which is right where you started. ;) please think of what you called cofunctors as contravariant functor otherwise your intuition for 'co' will be all fucked up
08:13:13 <ph88> haha look what i found http://ircbrowse.net/haskell
08:13:20 <ph88> top words like geekosaur and monochrom :P
08:13:21 <edwardk> as comonads have nothing do with such 'co'-functors. comonads are covariant functors after all just like monads
08:13:29 <nitrix> edwardk: Ah yeah, you're right.
08:13:35 <nitrix> edwardk: So I meant contravariant then.
08:13:56 <ph88> eh i'm on that myself too o_O
08:14:08 <nitrix> Someone's abusing that `co` in every names D:
08:14:13 <edwardk> hodapp: =)
08:14:51 <ertes> and Cale is the center of everything =)
08:14:58 <edwardk> nitrix: folks are slowly being won over to the correct terminology ;) there were a couple of posts a few years ago that caused an outbreak of 'cofunctor' syndrome, and we're slowly stamping it out
08:15:05 <nitrix> Whoho! I'm on top of Cale c:
08:15:28 <ertes> i'm orthogonal to dfeuer
08:16:52 <sm> ha ha this is depressing. Average times of top AoC solvers: http://www.gicentre.net/aoctimes (possible spoiler, your call)
08:16:58 <ph88> any reason that there is less conversation here year-by-year since 2009 ?
08:18:05 <nitrix> ph88: Temptatively, maybe we're being replaced by AIs?
08:18:36 <ertes> ph88: community fragmentation perhaps
08:18:38 <ph88> lambdabot, is gonna take over !
08:19:05 <sm> (actually it is a bit spoilery, don't read too much)
08:19:08 <ertes> we have quite a few haskell channels, and more "modern" alternatives to IRC have popped up
08:19:16 <nitrix> Community fragmentation is very real. I'm not sure why IRC isn't more popular.
08:19:18 <ph88> looks like europeans are more active here as well ^^
08:19:28 <sm> summary: average time among top 100 AoC solvers is ~15m 
08:19:31 <nitrix> Slack and others are just glorified IRCs afterall. Same concept with rooms and modes.
08:19:31 <ertes> nitrix: perhaps because IRC is about the worst protocol in existence
08:19:39 <nitrix> ertes: "But it works".
08:20:06 <ertes> nitrix: it really doesn't…  here is a symptom: i have to check online logs when my client reconnects
08:20:15 <sm> glguy: how long do you take ? ^^^
08:20:39 <ertes> nitrix: another symptom: you can't use IRC from a phone on the bus
08:21:12 <nitrix> I just want to see all the haskellers in the same room :<
08:21:23 <sm> ph88: you should consider all #haskell-* channels
08:21:25 <nitrix> My ivory tower.
08:22:01 <nitrix> edwardk: ertes Thanks for the help by the way.
08:22:15 <edwardk> np
08:22:41 <xcmw> My biggest problem with irc is that it does not load messages sent before you connect
08:22:43 <edwardk> nitrix: if you want to see all the haskellers in the same room come to ICFP ;)
08:22:51 <ertes> nitrix: sure
08:23:11 <edwardk> xcmw: thats why i defected to irccloud. got sick of missing messages
08:23:15 <glguy> xcmw: It does when you use a bouncer
08:24:01 <xcmw> glguy: I should not have to configure it. It should just work.
08:24:06 <glguy> ok
08:24:20 <nitrix> Actually, one more question: How does one gets that haskell developer cloak?
08:25:22 <ertes> nitrix: you…  err…  what?
08:25:26 <xcmw> glguy: I use ircbrowse
08:25:35 <glguy> I use ZNC
08:25:50 <Clint> i use irssi proxy
08:26:39 <xcmw> glguy: Does ZNC work if your computer is off?
08:26:42 <nitrix> ertes: I've seen it flying around. glguy has one, edwardk too. I'm an unaffiliated sad panda.
08:26:57 * sm leaves erc running in a dtach'd emacs on server.. easy peasy
08:27:06 <ertes> bouncers are another symptom of IRC's ag…  godawfulness
08:27:08 <glguy> xcmw: Yeah, I have it running on a raspberry pi that never turns off
08:27:13 <edwardk> nitrix you ask me, and i batch a bunch up and request them from the ircops
08:27:26 <ertes> xcmw: ZNC itself has to keep running, so you need another machine in that case
08:27:34 <edwardk> i usually do a batch every 3 months or so
08:27:45 <nitrix> edwardk: Is verbally here okay or I should send an email to you?
08:28:09 <ph88> ircbrowse is nice :)
08:28:10 <edwardk> an email would make sure i don't forget. just include 'cloak' in the title to make sure i find it
08:28:18 <ertes> edwardk: count me in then =)
08:28:26 <edwardk> ^- 
08:28:29 <edwardk> =)
08:29:12 * ertes notmuches for edwardk's address
08:29:55 <ph88> glguy, does znc also work to see missed messages or is it only for private messages ?
08:30:09 <ph88> i mean missed channel messages
08:30:13 <glguy> It records as much as you tell it to
08:30:18 <xcmw> Chat protocols should not require additional hardware to view previous messages. Or require you to go to a website
08:31:01 <glguy> It just depends on if you're trying to get the best experience for the current state of the world or want to complain about it
08:31:05 <ph88> i think you can ask directly for a cloak in #help but maybe that's a general cloak and not a haskell specific one ?
08:31:54 <glguy> ph88: That'd be for an "unaffiliated" cloak
08:32:03 <ph88> yeah
08:32:10 <ph88> i used to have those
08:32:14 <ph88> maybe i still do
08:32:29 <ph88> not sure how to check that in my irc client :D
08:32:34 <ph88> anyway got to go
08:32:35 <ph88> bye all
08:32:35 <glguy> You don't appear to
08:33:33 <Clint> xcmw: they should also not be centralized or perform any logging
08:34:37 <xcmw> Clint: If it is decentralized how would you stop logging?
08:35:25 <Guest82808> I am a "math guy" who has heard small parts about the interesting math surrounding haskell, and it seems interesting. I have learned a bit of haskell (read through Learn You a Haskell), but I feel like I want to learn more about the theoretical underpinnings
08:35:31 <Guest82808> Where would be a good place to start/get an overview?
08:35:57 <Tuplanolla> An overview of Haskell or the math, Guest82808?
08:36:09 <Guest82808> The math, Tuplanolla 
08:36:15 <Guest82808> You may wonder which underpinnings I am talking about, but the problem is that I don't have a good overview of them
08:36:39 <Guest82808> Mainly things about how category theory and type theory is used in or to reason about haskell
08:36:45 <yulax> Guest82808: are you interested in lambda calculus?
08:37:14 <Guest82808> yulax: Yes! Lambda calculus, logic, type theory, category theory, algebra in general, stuff like that
08:37:27 <parsnip> ertes: I'm on phone
08:37:40 <yulax> lambda calculus is quite a major part of it. you should read up on that in particular.
08:37:41 <Guest82808> I know about lambda calculus from before though so the thing I am mostly interested in is its connections to haskell
08:37:54 <Guest82808> And how it can be used to reason about haskell programs
08:37:59 <yulax> Guest82808: everything in haskell is expresable as a lambda expression.
08:38:02 <lyxia> Types an programming languages might be a good read
08:38:03 <sm> you'd probably enjoy bartosz milewski's blog
08:38:08 <Tuplanolla> @google software foundations
08:38:09 <lambdabot> https://www.cis.upenn.edu/~bcpierce/sf/
08:38:48 <Guest82808> Thanks for the recommendations, will check them out briefly right now
08:38:58 <Tuplanolla> That book that goes over the math and then some, Guest82808. It's not exactly Haskell, but related.
08:39:06 <Guest82808> ah
08:40:11 <Guest82808> By the way (not that it necessarily changes anything), I am more interested in Haskell for the sake of using math than I am in Haskell or math for the sake of programming
08:40:19 <Guest82808> If that gives a good view on my interests
08:40:44 <Guest82808> So mainly just trying to use/think about math in different contexts for the sake of it, not for any actual "use" in applications a priori
08:41:34 <Guest82808> Tuplanolla: The book still seems to perhaps be interesting. Looking quickly at it, it feels like it is at the right "abstraction level" for me
08:41:41 <Guest82808> Keeping the interesting parts of Haskell still
08:41:41 <Tuplanolla> Haskell is all about practical applications and compiler design. Other kinds of math are often shoved under the rug, Guest82808.
08:42:10 <Tuplanolla> We have no proof systems or algebraic simplification tools for example.
08:42:17 <Guest82808> Tuplanolla: Really? Is there some other languages that are more "about" algebra, category theory and type theory and that stuff?
08:42:58 <Tuplanolla> Coq's in the book, Guest82808. Agda can be found elsewhere.
08:44:39 <kuribas> idris maybe?
08:45:27 <Tuplanolla> Sure. There's a handful with various design goals.
08:45:33 <Welkin> kuribas: blasphemer!
08:46:21 <monochrom> Mathematica is all about algebra and calculus.
08:47:03 * kuribas would like to see a symPy port in haskell
08:50:10 <jabsed> For the native English speakers here, would "lead move" be a correct alternative to "leading move"?
08:50:34 <Welkin> looks like lead, the metal
08:50:44 <monochrom> like "project lead" instead of "project leader"?
08:50:44 <sm> neither is terribly clear to me jabsed 
08:50:48 <Tuplanolla> Too bad it's proprietary and pretty much impossible to integrate into other programs, so it might as well not exist, monochrom.
08:50:53 <jabsed> I was thinking "lead/leading actor"
08:51:25 <jabsed> sm I explain the meaning in the text, that shouldn't be a problem i think
08:51:59 <jabsed> I just don't know if it's proper English to use "lead something" rather than leading
08:52:15 <Welkin> in context, perhaps
08:52:21 <Welkin> but by itself, it can be confusing
08:52:34 <jabsed> Right :/
08:52:38 <Welkin> you don't know if "lead" is the metal or the idea
08:53:28 <monochrom> In 1951 Alan Turing was already writing "real good", so I guess you will be safe too.
08:53:37 <jabsed> Going to look for better terms in a thesaurus
08:53:39 <Welkin> maybefbi: are you like schrodinger's cat?
08:53:55 <ertes> parsnip: with a stable connection i presume
08:55:10 <MarcelineVQ> are you just trying to avoid ing?
08:55:24 <jabsed> MarcelineVQ it's shorter
08:55:26 <Welkin> maybefbi: he don't like gerunds
08:55:36 <jabsed> Nothing very profound
08:56:21 <parsnip> ertes: I have weechat running in a VPS
08:56:35 <MarcelineVQ> could go with first move then
08:56:40 <maybefbi> Welkin, maybe
08:56:49 <parsnip> ertes: and weechat-android as the client
08:57:05 <maybefbi> :: Maybe FBI
08:57:39 <jabsed> They are actually the last move
08:57:53 <jabsed> But i think of the last move as being in front
08:58:28 <jabsed> And i could go with last move but that generalises to plays
08:58:48 <jabsed> And subplays and then last doesn't make sense
08:58:59 <Welkin> the ultimate move
08:59:09 <Welkin> rather than penultimate
08:59:49 <jabsed> Welkin or the friendliest just for the hell of it
09:00:15 <Welkin> or the caboose
09:00:36 <MarcelineVQ> are these moves describing prophecies? why would your leading move be your last move :X
09:02:03 <Clint> xcmw: you wouldn't stop it, you'd not bake it in
09:03:05 <parsnip> jabsed: decision?
09:06:08 <parsnip> is last move in subplays, or other way around?
09:07:18 <jabsed> MarcelineVQ For the same reason that in a:b:c:[ ] the a is the head even though it was the last to be added
09:08:44 <jabsed> parsnip   x1 ... xn , is a play and within its structure are ocurrences of subplays
09:09:22 <jabsed> The subplays whose last move is a submove of xn are lead/leading subplays
09:10:52 <jabsed> So suppose each x is in A*B, so i have moves on the left and on the right
09:11:28 <jabsed> This means i can project x1...xn onto to subplays, one of moves in A another of moves in B
09:11:53 <jabsed> A+B i mean
09:13:23 <jabsed> If xn is in B then the leading subplay will be the projection to B (the one that filters out moves in A)
09:14:58 <jabsed> <2,b> <1,a> <2,b'> is a play,  b b' is a leading subplay
09:15:12 <jabsed> or whaterver i call it
09:15:56 <jabsed> b' is a leading submove
09:23:47 <seanparsons> Has anyone had any weird issues with http-client in a Docker container? In my case it seems to block as it makes a request and just hangs there.
10:11:03 <xcmw> I got ghc in an infinite loop (not my program the compiler)? How do I fix it?
10:12:46 <suzu> are you using UndecidableInstances?
10:12:57 <xcmw> suzu: Yes
10:13:04 <suzu> well.. there you go
10:13:05 <suzu> :P
10:13:17 <monochrom> even then, GHC has a loop counter to stop itself
10:13:34 <xcmw> monochrom: I has gone on for minutes
10:13:39 <xcmw> It*
10:13:41 <suzu> what ver of ghc is this?
10:13:46 <xcmw> 8.0.1
10:13:51 <suzu> oh really
10:13:53 <suzu> hmm
10:14:18 <xcmw> I am using vinyl + other complex type level code
10:15:00 <xcmw> I figured out the block of code causing the loop
10:16:44 <ertes> perhaps it's time for a type system profiler =)
10:18:03 <monochrom> recompile GHC with profiling
10:18:33 <xcmw> monochrom: I will try that if I can't figure it out. I have to go.
10:18:56 <monochrom> that will be a big project
10:19:48 <monochrom> it is best to not shoehorn dependent typing into haskell
10:19:53 <suzu> h'es gone
10:19:57 <suzu> s/he's *
10:20:08 <monochrom> yeah, but I'm telling everyone
10:20:16 <suzu> oh ok
10:24:58 <praveen> why do I need extran pair of parenthesis when in this expression `concat $ (["a","b"] :: [String])`? I get error without them.
10:25:15 <praveen> *extra
10:25:57 <monochrom> giving a type to a subexpression has always required parentheses. $ does not mean "omit parentheses"
10:26:48 <praveen> make sense. I think $ is just for function application 
10:27:16 <monochrom> function application still does not mean "omit parentheses"
10:28:07 <ertes> praveen: "::" is not an operator, and it binds looser than all operators
10:28:22 <ertes> f $ x :: T = (f $ x) :: T
10:30:07 <praveen> ertes: could you please explain it. or tell me where to read about it
10:31:08 <monochrom> Perhaps the Haskell 2010 Report, which lists the grammar, in which you can find where :: stands
10:31:46 <praveen> okay thanks
10:31:52 <geekosaur> it's syntax and it always scopes over an entire expression. so it can't scope over, say, a comma between list elements; but it will scope across ($) because it's part of the expression
10:32:42 <geekosaur> in this case it can't get a full expression by crossing the left parenthesis (because it won't have the matching right parenthesis), so it stops there
10:34:21 <praveen> geekosaur: got it. thanks :)
11:11:50 <xcmw> monochrom: I figured out the type level expression that it causing the loop. The problems is it depends on many others.
11:16:42 <xcmw> Is there a way to have ghci run a type expression?
11:23:46 <MarcelineVQ> not sure what you mean, give :kind! a try though
11:23:58 <mmaruseacph2> HCAR has been finally published
11:26:55 <yushyin> thx much!
11:27:02 <xcmw> MarcelineVQ: Kind of except it does not always simplify. Sometimes I have to write type E = ... ; :kind! E instead of :kind! ... 
11:27:15 <xcmw> in order to get the simplified type
11:27:35 <athan> xcmw: For type families?
11:27:40 <athan> or just type aliases?
11:29:17 <xcmw> athan: Both
11:29:50 <athan> what were you trying to reduce?
11:30:38 <xcmw> athan: A combination of type operators, type synonyms, and type families
11:32:53 <xcmw> athan: http://lpaste.net/350430
11:32:58 <athan> Hm :S I guess it doesn't know what it should "forget"
11:34:18 <xcmw> athan: Is there away to just get the second output?
11:34:35 <athan> Iirc you have to explicitly try to coerce certain types or something to make :kind! work like that
11:34:45 <athan> but I'm not sure :x
11:39:10 <saurabhnanda> what's the most accessible generic programming tutorial for Haskell? If I need to write a generic JSON parser (with additional logic as compared to Aeson)?
11:42:24 <xauth> cabal newbie here. Does this ring a bell with anyone? "ghc: unable to load package 'ghc-prim-0.4.0.0'" ; "failed to install fgl-5.5.3.0"
11:42:50 <suzu> use stack and not cabal directly
11:43:27 <xauth> Oh. That explains everything.
11:43:43 <StarsC> when i type 2+2 in ghci, what is actual type of the result in internal representation?
11:43:44 * xauth starts looking for stack.
11:43:58 <suzu> xauth: are you familiar with stack at all?
11:44:08 <xcmw> I have type level code causing ghc to loop? monochrom told me to compile ghc with profiling. How would I do that? Are there any other ways? I have isolated the code causing the issue but it is quite complicated.
11:44:27 <xauth> Not at all. I just got cabal installed.
11:44:41 <suzu> ah ok
11:44:45 <athan> StarsC: It's complicated :)
11:44:46 <suzu> what os are you using?
11:44:54 <StarsC> athan: Integer?
11:44:57 <xauth> Heh. openbsd 6.0.
11:45:01 <suzu> :)
11:45:03 <athan> Oh, yes that should be the default decision
11:45:22 <StarsC> athan: i mean its probably not Int?
11:45:46 <suzu> `cabal install stack` should.. work
11:45:59 <suzu> give that a shot xauth 
11:46:38 <xauth> I should have thought of that. :)
11:47:08 <suzu> once you have stack working, don't touch cabal directly again
11:47:11 <suzu> it's never worth it
11:47:21 <suzu> let stack deal with all the dependency juggling
11:47:28 <suzu> :P
11:48:11 <xauth> Working on it now. It's a long list to install. Might have to come back tomorrow. :)
11:48:14 <Social-Reject> how do I zip two lists in haskell
11:48:36 <suzu> Social-Reject: `zip`
11:48:45 <Social-Reject> only zip?
11:48:50 <suzu> > take 10 $ zip [1..] [2,4..]
11:48:53 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20)]
11:49:04 <Social-Reject> cool
11:49:36 <athan> StarsC: Yes you're correct that it is Integer, and not Int
11:49:38 <xauth> Is stack using cabal underneath?
11:49:42 <xcmw> Social-Reject: Also zipWith
11:49:43 <suzu> xcmw: yes
11:49:46 <suzu> err**
11:49:49 <suzu> xauth: yes
11:49:52 <athan> Floating defers to Double, too StarsC
11:49:58 <suzu> stack uses caba;
11:49:59 <suzu> cabal
11:50:05 <Social-Reject> thanks
11:50:42 <StarsC> athan: ty :)
11:50:51 <Tuplanolla> Are you using GHCi, StarsC? If so, `:set -Wall` and try `2 + 2` again.
11:50:54 <suzu> xauth: you can read more about stack here: https://docs.haskellstack.org/en/stable/README/
11:51:06 <StarsC> Tuplanolla: yes, ghci
11:53:38 <StarsC> Tuplanolla: ty, that helps :)
11:54:59 <xcmw> Anyone know steps to figure out why ghc is looping when evaluating a type level expression?
11:55:38 <xauth> suzu: bookmarked. Thanks.
11:56:56 <ertes> i should set up a timer that dumps a message into this channel periodically: "«use stack» is not the correct answer"
11:57:06 <ertes> like every hour perhaps?  what do you think?
11:57:22 <geekosaur> shhh, True Believers cannot accept such falsehoods
11:57:28 <vctrh> hi all
11:57:50 <geekosaur> or permit them
11:57:57 <vctrh> is there a way to add extra-lib-dirs to stack.yaml such that the path is relative to the top-level project directory
11:58:04 <vctrh> and not an absolute path?
11:58:15 <athan> vctrh: I do so all the time
11:58:26 <athan> usually with a location
11:58:58 <athan> so `location: - ../something \n  extra-dep: true` or similar
11:59:05 <vctrh> athan how? if i add extra-lib-dirs: ['./foo']
11:59:15 <vctrh> stack build fails saying that an absolute path is required
11:59:27 <athan> the comments in a fresh stack.yaml generated by stack init should be more informative
11:59:53 <vctrh> "# Extra directories used by stack for building"
12:00:04 <ertes> saurabhnanda: a parser with more logic than aeson?
12:00:23 <vctrh> no hint of how to specify a relative path also https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#extra-include-dirsextra-lib-dirs
12:00:34 <vctrh> says "Paths should be absolute"
12:00:48 <ertes> saurabhnanda: ok, aeson doesn't capture comments, which is a bit unfortunate…  do you need that?  or is there some other part of the grammar that aeson doesn't pick up?
12:01:03 <ertes> (i don't even know whether JSON supports comments)
12:01:14 <saurabhnanda> ertes: omittable fields
12:01:28 <ertes> saurabhnanda: aeson supports that
12:01:43 <ertes> saurabhnanda: also now you're talking about marshalling, not parsing JSON
12:01:43 <saurabhnanda> ertes: not nullable, omittable. 
12:01:49 <ertes> saurabhnanda: yes
12:02:16 <saurabhnanda> ertes: how does aeson support omittable fields?
12:02:35 <ertes> saurabhnanda: write a ToJSON instance that omits the field, if it's Nothing
12:03:40 <saurabhnanda> ertes: already done that. it's parseJSON that is making me reach out for generic programming.
12:04:08 <xcmw> Is the a verbose version of :kind! which will print out every step so I can see where it is looping?
12:04:30 <ertes> saurabhnanda: well, you have to write FromJSON yourself, too…  the API doesn't insist on fields being present
12:04:30 <saurabhnanda> ertes: here's what I have till now -- https://gist.github.com/saurabhnanda/d5aebb75bda6d203825c43b7c65cb820
12:05:06 <ertes> saurabhnanda: if you need that as a generically, i would just write a different generic deriver for aeson that omits fields instead of nulling them
12:05:18 <ertes> saurabhnanda: without reinventing everything else in aeson
12:05:47 <saurabhnanda> ertes: could you elaborate please? any pointers on how I can do this quickly?
12:07:17 <ertes> saurabhnanda: look into the source code of the generic-deriving library to get the general idea, look into the generic deriver for aeson specifically, and perhaps read ocharles_' tutorial: https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html
12:08:43 <ertes> basically you implement your algorithm for specific sum/product types and then use Generic to establish the translation between those and arbitrary ADTs
12:08:48 <Eduard_Munteanu> Um, what does Nothing map to, then?
12:09:16 <Eduard_Munteanu> > toJSON $ object ["foo" .= Nothing]
12:09:21 <lambdabot>  error: Variable not in scope: toJSON :: t0 -> terror:
12:09:21 <lambdabot>      Variable not in scope: object :: [m0 ()] -> t0error:
12:09:21 <lambdabot>      • Couldn't match type ‘[Char]’
12:09:58 <ertes> Eduard_Munteanu: object (maybe [] ("foo" .=) mx)
12:10:24 <ertes> that's how i understood saurabhnanda's description
12:11:27 <ertes> hmm…  actually this might be quite tricky to solve generically
12:11:34 <saurabhnanda> Eduard_Munteanu: is that related to my question? 
12:11:50 <Eduard_Munteanu> Yes. As I understand, Nothing maps to omitted fields.
12:11:54 <saurabhnanda> ertes: I'm a little confused when you say "driver"
12:12:02 <ertes> saurabhnanda: dEriver
12:12:48 <saurabhnanda> Eduard_Munteanu: no, Nothing maps to (Omittable (Maybe x)). The absence of a key in the JSON maps to Omit. The presence of a key maps to (Present x)
12:12:59 <ertes> saurabhnanda: anyway, i think you will run into a nasty problem:  at the point when you're constructing the object you have no information about the component types yet, so you can't omit fields
12:13:27 <ertes> this will require either some type trickery or a post-processing pass
12:15:48 <newToHaskell> hello
12:15:55 <Eduard_Munteanu> newToHaskell, hi
12:16:00 <newToHaskell> if anyone could help me with a quick question, im trying to learn haskell
12:16:10 <xcmw> newToHaskell: Post it
12:16:23 <newToHaskell> i'm trying to figure out the concept of explicit type declaration of a function
12:16:36 <newToHaskell> in ghci, I typed in the following
12:16:48 <newToHaskell>  contrived :: ([a], Char, (Int, Float), String, Bool) -> Bool
12:16:57 <saurabhnanda> ertes: you mean contructing the object during parsing?
12:17:06 <geekosaur> in ghci, things on different lines are different unrelated expressions
12:17:13 <newToHaskell> but I get an error variable not in scope
12:17:21 <newToHaskell> oh
12:17:32 <geekosaur> use a semicolon to join the type sig and definition into one line, or enable multi-line input (which has its own pitfalls)
12:17:46 <newToHaskell> ill try to use a semicolon one sec
12:17:56 <Tuplanolla> One more option surfaces, newToHaskell: use `:{` and `:}`.
12:18:00 <geekosaur> also, for ghc 7.10.3 and earlier you need to start it with "let"
12:18:05 <Clint> or load it from a file
12:19:08 <saurabhnanda> ertes: are you basically saying that at the very end of the tree, where I'm dealing with an atom, if it's absent (i.e. no key), what do I parse it into? If that's what you meant, then the idea was that this logic needs to be at one level above leaf nodes.
12:19:29 <newToHaskell> oh nice, the semicolon solution worked
12:19:38 <newToHaskell> thanks a ton
12:19:44 <geekosaur> basically, ghci is not the same as things in a file and has some weird behaviors
12:19:51 <newToHaskell> i suspected as such
12:20:04 <newToHaskell> any alternatives to ghci you'd recommend?
12:20:10 <geekosaur> not currently
12:20:30 <geekosaur> there was a project to hook haskell to ipython/jupyter but it stalled
12:20:43 <newToHaskell> how about this atom package that i installed
12:20:49 <Social-Reject> is there 'reduce' function like in javascript [1,2].reduce(()=>{});
12:20:50 <newToHaskell> ghci mod or something
12:21:03 <ertes> saurabhnanda: no, during toJSON
12:21:15 <ertes> saurabhnanda: parsing is no problem
12:21:19 <geekosaur> editor interfaces tend to be tricky at best. ghc-mod is highly sensitive to which ghc version (and sometimes even exact build) is in use :/
12:21:34 <systemfault> Social-Reject: Are you joking? :P foldl my friend
12:21:45 <Social-Reject> haha no :D thanks
12:21:49 <Tuplanolla> GHCi is a mix between the stuff you can write inside a `do` block and some top-level things, newToHaskell.
12:22:06 <geekosaur> foldl tends to be the least useful of the folds... foldl' (strict) or foldr preferred
12:22:46 <newToHaskell> hmm maybe i'll look into loading from a file
12:23:01 <newToHaskell> for now ghci is fine for just learning I guess
12:23:12 <Tuplanolla> You'll get used to it, newToHaskell.
12:23:13 <ertes> newToHaskell: GHCi is much more useful when you load a file
12:23:24 <saurabhnanda> ertes: doesn't this look write for toJSON? https://gist.github.com/saurabhnanda/d5aebb75bda6d203825c43b7c65cb820
12:23:45 <ertes> newToHaskell: if you happen to use emacs, then you get very good GHCi integration, too
12:24:01 <newToHaskell> i might look into emacs
12:24:04 <newToHaskell> but right now i use atom
12:24:37 <ertes> saurabhnanda: not quite…  how can you create an object with multiple fields, of which one is omittable?
12:25:02 <ertes> newToHaskell: this is a statement about emacs in isolation, not in relation, mostly because i have little experience with other editors =)
12:25:20 <ertes> newToHaskell: although i've heard some pretty nasty things about ghc-mod (like unreasonable memory usage)
12:25:35 <saurabhnanda> ertes: every field is going to be wrapped in an Omittable. eg data Contact = Contact { name :: Omittable String, age :: Omittable Int }
12:25:58 <ertes> saurabhnanda: and what does toJSON for Contact look like?
12:26:44 <ertes> saurabhnanda: try to write it to see what i mean
12:27:12 <saurabhnanda> ertes: I was expecting the generic toJSON would work. let me try.
12:27:30 <ertes> saurabhnanda: not quite the way you're probably imagining it =)
12:27:36 <newToHaskell> anyways thanks ertes, back to learning :)
12:32:18 <xcmw> How do you debug ghc loops?
12:32:44 <geekosaur> various -d options
12:34:28 <xcmw> geekosaur: I know my issue is type level and have isolated the expression. What flags do I use?
12:35:01 <xcmw> geekosaur: Is it best to do it in ghci or ghc?
12:35:47 <Liskni_si> are there type level list operations in base or am I supposed to use singletons/type-list from hackage?
12:36:27 <Liskni_si> (to be more specific, I need a type family that _appends_ a servant Header)
12:36:52 <geekosaur> xcmw, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html#options-debugging read that and you'll know as much as I do. I suggest filing a ghc bug, since even if you induced the loop by an error ghc should be catching the loop and reporting it
12:37:47 <xcmw> geekosaur: Thank you. Will file a bug once I figure out why it is happening.
12:38:18 <geekosaur> I'd actually do it first, since the ghc devs are more likely to have an idea of where to look
12:40:30 <xcmw> geekosaur: Ok
12:40:58 <saurabhnanda> ertes: it worked without any problem. But didn't give the output that I expected it to. 
12:41:42 <saurabhnanda> ertes:  (encode $ toJSON $ C2 (Present "Saurabh") Omit) ==> "{\"age\":{},\"name\":\"Saurabh\"}"
12:42:03 <saurabhnanda> ertes: the "age" key shouldn't even be present
12:43:13 <saurabhnanda> ertes: so this logic also needs to go to the (n-1) level
12:54:34 <ertes> saurabhnanda: exactly =)
12:54:44 <ertes> saurabhnanda: but it's more like the logic needs to go in *both* levels
12:55:26 <ertes> toJSON isn't quite powerful enough, so you'd need to go through a separate function that can communicate: "if my Value is going to be a field value, please omit me"
12:56:00 <ertes> omittableToJSON :: (OmittableToJSON a) => a -> (Bool, Value)
12:56:30 <lpaste> xcmw pasted “Can someone tell me what this error means?” at http://lpaste.net/350437
12:56:58 <ertes> saurabhnanda: your Omittable type needs to communicate whether omission should occur one level up…  then the level above should respect that information
12:57:21 <ertes> and at the very end you write a ToJSON instance by just ignoring the Bool
12:57:30 <ertes> toJSON = fst . omittableToJSON
12:59:38 <ertes> saurabhnanda: now the idea is that OmittableToJSON is a class that is not implemented by users, but for generic types like (:+:)…  then you write a function 'defaultToJSON' that just does the Generic roundtrip, so you can write ToJSON instances this way:  instance ToJSON MyType where toJSON = defaultToJSON
12:59:42 <saurabhnanda> ertes: at the non-leaf level I was planned to inspect the types of each record field and either call ommitableToJSON or toJSON depending upon the type.
12:59:45 <ChaiTRex> What does the AoC mean in the topic?
12:59:56 <Tuplanolla> @google advent of code
12:59:57 <lambdabot> https://adventofcode.com/
13:00:04 <ChaiTRex> Oh. Thanks
13:00:55 <ertes> saurabhnanda: there is no need to do that…  omittableToJSON is strictly more powerful…  if you don't want omission, just set the Bool False for your type and get null behaviour
13:01:01 <ertes> set it to True to get omission
13:01:35 <ertes> (or vice versa depending on what your Bool means…  perhaps create a separate type with more descriptive constructor names than "False" and "True")
13:02:44 <NextHendrix> i hear the word expressive tossed about a lot, what does it actually mean with regards to haskell
13:03:35 <geekosaur> xcmw, normally that would mean there is a bug in time-1.6.0.1: the module Data.Time.Clock.CTimespec is not listed in either exported-modules or other-modules, so was not included in the library. but the cabal file does show it in other-modules
13:04:02 <geekosaur> ...oh
13:04:37 <geekosaur> whole module is inside #if !defined(mingw32_HOST_OS) && HAVE_CLOCK_GETTIME
13:05:32 <geekosaur> if you are not on Sierra then this will yield an empty module, but some other part of the package is expecting getCTimespec to be defined
13:07:19 <geekosaur> (also this may be impacted by a bug in the Command Line Tools for 10.11)
13:08:22 <saurabhnanda> ertes: is it easier to do this at value level? for fields with Omit values, give them a special value, say "_$_" and remove all keys containing that value at a higher level?
13:08:23 <geekosaur> in any case you probably want to (a) try time-1.7.0.1 in case it was resolved there (you have 1.6.0.1) (b) if not fixed by that, file a bug at https://github.com/haskell/time/issues
13:09:25 <geekosaur> since they should probably be looking for a way to deal with the CLT bug, since Apple apparently has decided it's not a bug that their CLT partially exposes a syscall not present on 10.11 :/
13:10:54 <how> hi what is the recommended way to convert unboxed vector of word8 into bytestring (copy is allowed)
13:11:01 <how> rightnow i only know foldMap
13:11:42 <Tuplanolla> There's probably a disgusting constant-time way to do it, how.
13:12:00 <Tuplanolla> Check if either package has "internal" utilities for that.
13:13:20 <ertes> NextHendrix: example: take two functions (f :: A -> X) and (g :: B -> X) for some types A, B and X
13:13:38 <lpaste> geekosaur annotated “Can someone tell me what this error means?” with “Can someone tell me what this error means? (annotation)” at http://lpaste.net/350437#a2891446875011940352
13:14:08 <ertes> NextHendrix: if for every (a :: A) there exists a (b :: B) such that f a = g b, then g is at least as expressive as f
13:14:38 <ertes> NextHendrix: in other words:  all values of type X that can be expressed in terms of f can also be expressed in terms of g
13:15:19 <ertes> NextHendrix: there are other, related notions of expressivity, for example for the kind of information that you can encode in types
13:15:42 <ertes> saurabhnanda: i wouldn't do that
13:16:01 <ertes> saurabhnanda: doing that is wrong for the same reason C's "error return values" are wrong
13:17:01 <ertes> how: there is no way other than actual and explicit copying…  if you want a less manual approach use storable vectors instead…  then you can use a memory copy
13:18:34 <ertes> how: in fact you could even get away without the copying, because a storable vector is just a ForeignPtr anyway, which you could reuse
13:23:16 <how> ertes: I know I need to copy (I have explicitly said that copying is allowed), I just want a fast copy (that only create a single bytearray and copy all the values instead of concatenating arrays)
13:23:23 <NextHendrix> ertes: interesting, i was under the impression it had something to do with how clear the syntax was
13:23:55 <NextHendrix> "expressive type system"
13:25:59 <ertes> how: if you can, use a storable vector…  if not, an easy way is to just go through an intermediary list (it adds cost, but is reasonable)
13:26:17 <ertes> B.pack . V.toList
13:28:02 <ertes> NextHendrix: type system expressivity is more difficult to express formally, because ultimately haskell (for example) is just another turing-complete language, and those languages are all equally expressive
13:28:25 <ertes> NextHendrix: a useful (but informal) notion is:  how much domain-specific information can you give the compiler about the code?
13:29:33 <how> ertes: ya that's probably the easiest i just thought there may be a faster way since i already know the length needed for the array
13:30:40 <ertes> how: ByteString has an awkward API =/
13:30:55 <ertes> honestly i think it would be best to just dispense with the bytestring library and use vector
13:31:07 <ertes> but history…
13:31:17 <ertes> and legacy…
13:48:45 <max33> i'm trying to install a cabal package and i'm having a stupid problem: running ./setup configure gives me a list of unmet dependencies but i can't figure out how to get cabal to satisfy them
13:49:37 <max33> install one by one i get `cabal: Could not resolve dependencies: trying: aeson-1.0.2.1 (user goal)`
13:50:27 <max33> and i've run cabal update
13:52:04 <byorgey> max33: just run 'cabal install' in the package directory
13:52:47 <byorgey> max33: installing packages one by one is likely to fail, since cabal will just pick the latest version, but it can't guarantee they will all work together.  You have to let it figure out an entire set of consistent packages to install.
13:53:28 <byorgey> max33: you might want to use a sandbox.   'cabal sandbox init; cabal install'
13:53:37 <max33> thank you byorgey 
13:59:00 <xcmw> geekosaur: I am not using the time package. Or at least direcly. I am on Sierra. I am using stack. How do a change it to a different version?
13:59:20 <xcmw> geekosaur: I assume it must be a dependency of a dependency
13:59:27 <qmm> i don't think this is necessarily #haskell, but related...
13:59:34 <qmm> 1/ if a network request (http) is sent to an application while it's being garbage collected, will the message be dropped?
13:59:49 <qmm> 2/ are there facilities which instruct the client to retry?
14:00:16 <qmm> 3/ what is the difference between live values and working set in garbage collection?
14:04:46 <Iceland_jack> Hey #haskell
14:05:12 <oherrala> hi
14:05:16 <suzu> hihi
14:08:32 <Iceland_jack> May you have a type-checked Christmas
14:08:58 <Iceland_jack> WELL-typed :--)
14:10:54 <geekosaur> xcmw, presumably. note that I do not know your package or its dependencies and cannot have any idea where the dep comes from or how to fix it
14:12:50 <geekosaur> qmm, why would it be dropped?
14:15:56 <qmm> geekosaur: my understanding is that an application becomes unresponsive when the world is stopped. is there a mechanism for storing the message during this time?
14:16:04 <geekosaur> it's called the kernel
14:16:42 <qmm> geekosaur: are there resources for understanding how the kernel stores a message until the application is responsive again?
14:16:59 <geekosaur> although if you are talking about Windows, sometimes its behavior makes me think most of the stack is userspace and all bets are off
14:17:13 <qmm> i don't care about windows machines, really
14:17:29 <geekosaur> on unixlikes the kernel will queue data until it hits a high water mark and then reject packets; this causes retries on the sending end
14:17:46 <geekosaur> (again, at kernel level, your app does not see this)
14:18:44 <qmm> that's useful to know! thanks geekosaur, i'll research further 1 and 2
14:19:06 <geekosaur> I suggest Stevens' _TCP/IP_Illustrated_
14:20:29 <geekosaur> for stream sockets, it is not up to the application to provide things like queueing and retries, that is the network stack's job --- which runs in the kernel and does so regardless of whether a socket-using application is currently blocked/busy
14:21:09 <geekosaur> (datagram/UDP is a different story, but if you are using HTTP then you are not using UDP.)
14:22:56 <geekosaur> as for your third question, in my experience "live values" are considered per generation, whereas "working set" is the collection of all live values across all generations.
14:24:24 <geekosaur> so when GCing the nursery, live values in the nursery are promoted to the next level up (by default this is the general heap; there are RTS options to specify additional generations)
14:24:27 <xcmw> geekosaur: I had some dependencies not on stackage I updated them and that fixed it. Thanks for your help. Now I get to isolate the loop so I can make a bug report.
14:26:56 <houli> anyone here have experience with edward kmett's zippers? is it suitable for traversing a syntax tree such as this https://github.com/houli/looper/blob/master/src/Program.hs#L16-L21
14:30:59 <trepta> hi guys
14:31:20 <trepta> How do I know which version of a package I am using in my .cabal file?
14:33:36 <houli> @trepta if you're using stack you can use stack list-dependencies
14:33:36 <lambdabot> Unknown command, try @list
14:33:47 <houli> trepta: 
14:34:19 <buttons840> I have a list of urls that appear in a get response; any suggestions on how to make the relative urls absolute?
14:34:28 <trepta> houli: that did the trick
14:34:32 <trepta> thanks
14:35:09 <houli> trepta: you can limit it to just your dependencies and not the transitive ones with stack list-dependencies --depth=1
14:35:48 <trepta> ok, better than greping I guess hehe
14:36:58 <qmm> geekosaur: thank you for your excellent response, again!
14:38:23 <buttons840> are there any libraries that help break a URI down into it's parts? if not, it sounds like a good starting project since it's just parsing strings and maybe reading some w3c specs
14:38:48 <max33> trying to install partial-isomorphisms and i get `    Not in scope: data constructor ‘RecGadtC’`
14:38:51 <max33> won't install
14:39:06 <geekosaur> buttons840, http://hackage.haskell.org/package/network-uri
14:43:49 <buttons840> geekosaur: perfect, thank you -- i was just wondering why it disapeared from the base network library
14:44:14 <geekosaur> mostly so things that wanted to manipulate URIs didn't need to haul in all of network to do it
14:55:29 <xcmw> How can I pass ghc flags when using stack?
14:57:09 <geekosaur> --ghc-options='...'
14:59:38 <haasn> is there an indexed free monad?
14:59:43 <haasn> for indexed functors
15:00:06 <johnw_> https://hackage.haskell.org/package/indexed-free-0.3.1/docs/Control-Monad-Indexed-Free.html
15:00:12 <haasn> ah great
15:00:47 <xcmw> geekosaur: I used some of the debug options you gave me and nothing is printed
15:00:48 <haasn> Oh oops
15:00:58 <haasn> I was trying to write that instance, but the wall I thought I hit didn't turn out to be a wall after all
15:01:03 <haasn> my type error was in a typo elsewhere
15:02:19 <xcmw> geekosaur: Do you know how to get the output?
15:04:27 <geekosaur> xcmw, stack uses -ddump-to-file so you will find the files under ~/.stack-work with names Modulename.dump-ds etc.
15:04:58 <geekosaur> (somewhere under ~/.stack-work, subdirs by platform/compiler/package/whatever)(
15:06:08 <xcmw> geekosaur: dist, install, or logs?
15:06:21 <haasn> it's amazing how you can make an indexed monad by just bashing types together in the only way possible
15:06:33 <geekosaur> in the source dirs, next to the source files involved
15:06:47 <geekosaur> Foo.hs gets Foo.dump-whatever files next to it
15:07:02 <geekosaur> they might end in dist but I thought not
15:07:40 * geekosaur would probably use find to locate them anyway, with -ddump-foo look for files with .dump-foo extension
15:07:49 <xcmw> geekosaur: I am running this command:
15:08:01 <xcmw>  stack build --ghc-options='-ddump-to-file'
15:08:11 <xcmw> I don't see it in src
15:08:17 <johnw_> haasn: well, it's a lot about composition, and you're just composing at two levels now: types and arrows
15:08:23 <geekosaur> ...
15:08:32 <geekosaur> -ddump-to-file does nothing by itself
15:08:36 <geekosaur> it is not -ddump-all
15:08:40 <xcmw> geekosaur: Found it
15:09:17 <xcmw> geekosaur: -ddump-to-file dumps lots of stuff
15:09:58 <geekosaur> it shouldn't turn anything on by default (although, as I said earlier, stack itself uses -ddump-to-file and passes various of its own options)
15:10:20 <geekosaur> someof which might or might not be useful to you; stack wants them for its own purposes
15:10:44 <xcmw> geekosaur: The files have about 1000 lines of stuff in them
15:10:56 <xcmw> geekosaur: Does it write live or after the fact?
15:11:47 <geekosaur> I presume live, you'd have to ask a ghc dev to be certain
15:11:56 <xcmw> geekosaur: Because I don't see the one I need. I have to kill it to the loop.
15:14:49 <xcmw> geekosaur: Well I guess I try to make a minimal reproduction of the problem and file a bug report.
15:16:29 <haasn> I wonder if ‘do’ monad could somehow be reworked so that it supports both monads and indexed monads. This would require some sort of superset of both monads and indexed monads which both can be instances of; but I can't think of any sane ways such an abstraction could work - maybe you could use extreme type trickery to eliminate away the extra phantom parameters for something like Maybe?
15:18:03 <johnw_> haasn: I believe predicate monads are the superset you're thinking of
15:18:56 <lyxia> I saw the words "polymonads" and "supermonad" floating around recently.
15:19:03 <lyxia> https://hackage.haskell.org/package/supermonad
15:20:53 <Eduard_Munteanu> haasn, it does work with both, you just need the right kind of return and bind in scope
15:22:12 <johnw_> haasn: see http://stackoverflow.com/questions/28690448/what-is-indexed-monad more discussion of theory
15:40:27 <haasn> johnw_: lyxia: interesting, thanks
15:40:58 <haasn> oh right, you can just pick a different m/n/p and let the instance choose
16:18:27 <trepta> does anybody know a good tutorial for optparse-applicative?
16:18:41 <trepta> I've trying to figure it out all day with no success
16:20:07 <jaspervdj> trepta: you can probably figure it out from some existing code
16:20:43 <trepta> probably, all the examples I have seen are rather simple comparaed with what I want to do
16:21:03 <jaspervdj> What are you looking for specifically?
16:23:44 <trepta> something like this.   jot [-a | -r  [n] ]    if jot is called without any arguments then it is equivalent to jot -a,  if it's called with just an -r without a number, then I want to get  a Remove Nothing, if  it has a number then a Remove (Just n)
16:24:40 <trepta> if  there are no options present, then it should return a String or Text including spaces
16:25:43 <jaspervdj> trepta: I would do that by just having `Maybe` for `a` and `r`, basically model the data as close to the CLI options as possible
16:26:17 <jaspervdj> trepta: Then just write a function that converts it to what you want (or fails with a helpful error message, e.g. "-a and -r not allowed together")
16:26:22 <trepta> i'm trying to parse it into data Mode = AddNew Text | ListAll | DeleteOne (Maybe Int)
16:27:10 <jaspervdj> Yeah, so I'd do it that in two steps.  data Options = Options { optAll :: Maybe Text, optRemove :: Maybe ... }
16:27:30 <jaspervdj> Then `optionsToMode :: Options -> Either String Mode`
16:27:50 <trepta> sounds good
16:28:16 <trepta> I'll try that
16:28:19 <trepta> thanks
16:30:18 <haasn> johnw: hmm, I'm chewing my way through the ekmett answer in that SO post; and I'm getting to the part where he regains the Atkey representation from the McBride representation; thus claiming it's a more powerful formulation. But I don't understand how this works - how would a mcbride-style  IxState s t a  ~  s -> (t, a)  look?
16:36:24 <haasn> cc edwardk
16:39:37 <xcmw> geekosaur: I figured out how to make GHC not loop. I still have no idea why it was looping but I know what was causing it to loop.
16:39:45 <trepta> is there something like a safeRead :: Read a => String -> Maybe a   ?
16:39:58 <xcmw> trepta: readMaybe
16:40:20 <xcmw> from Text.Read
16:40:46 <trepta> cool
16:40:48 <trepta> thanks!
16:52:43 <monochrom> trepta: http://hackage.haskell.org/package/options is smaller and maybe you can figure out it first, and then you will be ready for optparse-applicativ
16:53:15 <f-a> hello, I am depending on this package http://hackage.haskell.org/package/hspec-discover , which apparently does not specify bounds
16:53:46 <f-a> cabal is confused: "package hspec-discover-2.2.4 requires directory-1.3.0.0", but really directory-1.2.2.0 would do.
16:54:44 <f-a> is there a way to tell cabal: use 1.2.2.*? I put in both build-depends (executable and test suite) directory==1.2.*, but that seems not to fix it
16:59:55 <monochrom> I'm pretty sure the cause is elsewhere.
17:00:33 <f-a> monochrom: you mean I should axe my ~/.cabal?
17:00:42 <f-a> (and see if that helps)
17:02:25 <f-a> monochrom: https://hastebin.com/zoxuwidilu.rb this is complete error, I can provide with tar/repo if needed
17:03:35 <geekosaur> --constraint=directory=1.2.2.0
17:04:25 <geekosaur> one of (perhaps the worst) of the old-build shortcomings is a tendency to use the latest version of things, even when that's not a good idea as here
17:04:46 <geekosaur> cabal new-configure / new-build / etc. might work better
17:06:05 <f-a> geekosaur, question: I put constraints in my cabal file, http://www.ariis.it/link/t/lentil.cabal Are they not enough?
17:06:24 <geekosaur> (also where did this remove ~/.cabal meme come from as that's either wrong or insufficient; it is never, by itself, correct)
17:06:36 <hodapp> "commitBuffer: invalid argument (invalid character)" oh, piss off, hakyll
17:06:55 <f-a> geekosaur: because it worked at least once in my case
17:07:29 <geekosaur> f-a, those constraints apply only to your package, not transitively to hspec-discover
17:07:37 <f-a> mhhhh
17:07:43 <geekosaur> you might need to manually install hspec-discover with that constraint
17:08:11 <f-a> argh, but that would mean that people downloading it via hackage (cabal instll lentil) would find themselves with a broken build, right?
17:08:26 <geekosaur> unless they use new-install, yes
17:08:29 <gmz> Hello all
17:09:16 <geekosaur> this is a shortcoming of the old dependency checker, that it does not take into account that the other packages want directory-1.2.2.0, it just sees "any version" and selects the newest, and only afterward realizes that's wrong
17:09:45 <geekosaur> since you specified cabal-version >= 1.24, you could document that people should use new-install instead of just install
17:10:18 <f-a> geekosaur: can I force it somehow?
17:10:25 <geekosaur> no
17:11:49 <f-a> thanks geekosaur 
17:12:14 <geekosaur> hopefully new-install will become the default soon
17:12:26 <geekosaur> since the dependency stuff is a lot better
17:12:37 <geekosaur> (they're still tracking some rare corner cases though)
17:45:21 <imalison> I'm having trouble compiling my xmonad config using stack: https://gist.github.com/IvanMalison/95a970b90b6673ce1578b5385bbcbc65
17:46:26 <imalison> The critical part seeems to be the following NB: ‘Cabal-1.24.2.0:Distribution.Simple.UserHooks.UserHooks’
17:46:26 <imalison>                 is defined in ‘Distribution.Simple.UserHooks’
17:46:27 <imalison>                     in package ‘Cabal-1.24.2.0’
17:46:27 <imalison>               ‘Distribution.Simple.UserHooks.UserHooks’
17:46:29 <imalison>                 is defined in ‘Distribution.Simple.UserHooks’
17:46:33 <imalison>                     in package ‘Cabal-1.24.0.0’
17:56:37 <monochrom> http://hackage.haskell.org/package/lentil has an explicit  directory==1.3.* requirement.
17:57:09 <monochrom> I cannot understand why you would attribute it to hspec-discover
17:58:13 <f-a> monochrom: sorry, I forgot to mention I was working on my local copy. (as you can probably see by the .cabal I pasted)
17:58:54 <f-a> some good person volounteered to add my package to stack so I was "downgrading" some dependencies. One of them is directory
18:09:31 <f-a> monochrom: http://www.ariis.it/link/t/lentil.zip this is the actual thing. cabal configure runs ok, cabal configure --enable-tests fails b/c solver
18:26:41 <solidus-river> hey all, i'm thinking of writing a streaming group voice chat service in haskell, anyone have a reason as to why I would want to avoid haskell for this service? I'm planning on prototyping it in go, haskell, and erlang to see how each fits but I'm wondering if anyone has any good advice on the matter
18:27:04 <solidus-river> also, happy festivus all :P
18:27:12 <Lokathor> my advice is that you should skip the golang version and just pick among erlang and haskell :P
18:28:32 <solidus-river> Lokathor, whats your reasoning behind that? Go seems pretty good at concurrency / cpu intensive tasks
18:29:58 <xcmw> geekosaur: Turned out the loop was caused by PartialTypeSignatures
18:30:07 <Lokathor> Haskell would be my default choice, because we're here after all. However, Erlang has a good amount of stuff available for this exact sort of thing, and so it's quite competitive. Particularly, erlang beats haskell in the area of live code reloading and recovery by quite a bit.
18:31:12 <Lokathor> Unless there's already some sort of complete library for this in golang, I'm not sure what go would offer that Erlang and Haskell don't have
18:35:50 <solidus-river> Lokathor, thanks for the advice! Haskell's my first choice too but i realize elang is pretty tailored for this kind of thing. I was going to check out go just becuase I was curious about the language, but also it doesn't require a vm and I worry about montioring / scaling any service that runs on top of a vm (based on bad experience with java services)
18:35:57 <solidus-river> but come to think of it, I
18:36:20 <Lokathor> oh dear :/
18:36:22 <solidus-river> *I've had no need to ever mess with the erlang vm's settings, so maybe thats more a flaw in the jvm
18:36:58 <solidus-river> why the oh dear? :P
18:37:16 <Lokathor> large JVM servers :P
18:37:47 <Lokathor> In terms of scaling, Erlang, if constructed carefully, scales very easily
18:38:09 <Lokathor> you can just spread a program to more "nodes", and then it starts doing magic *even more concurrently*
18:38:31 <Lokathor> Haskell also has that but it's less built in
18:39:10 <Lokathor> I've only done one small project in Haskell, but it made me miss static typing very quickly
18:39:12 <dave_uy> Is there a recursive directory copy function in hackage?
18:39:21 <Lokathor> er
18:39:24 <Lokathor> in Erlang :P
18:40:32 <athan> dave_uy: Like a cross-platform one? I bet turtle has someting
18:40:34 <athan> thing*
18:40:51 <athan> (or shelly, not sure which would build utils like that)
18:41:43 <solidus-river> Lokathor, interesting, I've never heard of haskells version of erlangs scaling, are you talking about cloud haskell? or i guess what library?
18:42:09 <Lokathor> yes
18:42:15 <dave_uy> POSIX only is fine. I couldn't find a recursive copy anywhere in hackage.
18:42:35 <dave_uy> Was about to make an issue and pull request for System.Directory.
18:42:35 <athan> why not just invoke `cp -r` then? :p
18:42:37 <solidus-river> Lokathor, i'd probably design it to be clustered as opposed to using cloud haskell but I've never taken a serious look at the project
18:42:38 <Lokathor> i've never used cloud haskell myself, just read about it in a book, but they say "erlang style" in the opening sentence on their website
18:43:20 <athan> iirc System.Directory is more oriented toward gathering metadata of directories, and doing subtle cross-platform operations, but I might be wrong
18:43:26 <athan> there should be enough kit to write one though
18:43:28 <Gurkenglas> I've installed Leksah in I think 2014 and just reinstalled it. First startup's terminal window gives me http://lpaste.net/7251887348256866304
18:44:18 * solidus-river goes to cloud haskells site
18:44:31 <Gurkenglas> Help -> Manual puts "Can't find browser executable firefox" in the terminal. Win-R -> firefox works
18:44:51 <dave_uy> athan: That's fine. I'm fine with creating another package for extra directory functions.
18:45:34 <Lokathor> solidus-river, Yeah I don't really know too much about it, so I can't advise there
18:46:15 <dave_uy> I wasn't sure where it should go, or if recursive copy already exists. My friend wrote this for his program: http://hub.darcs.net/dino/hsinstall/browse/util/install.hs#290
18:49:29 <solidus-river> Lokathor, thanks for the input! it's time for festivities over here but I'm sure i'll see you more throughout the next couple mothns. :)
18:49:36 <solidus-river> cheers all
19:00:20 <Iceland_jack> Hii
19:27:37 <root_> hello
19:28:25 <max33> how do i resolve something like ` rejecting: blaze-markup-0.7.1.1, 0.7.1.0,  ... (global constraint requires..)`
19:30:24 <Iceland_jack> My favorite Applicative? (Const e)
19:31:30 <geekosaur> max33, you make sure everything uses the already installed instance instead of having it try to mix multiple versions
19:32:23 <max33> and i do this how exactly?
19:32:52 <geekosaur> the error means something is locking the currently installed version; that may be a constraint in ~/.cabal/config, or a frozen config, or possibly a stack resolver
19:33:18 <geekosaur> but that line by itself says nothing about why it's balking
19:33:57 <max33> how do i discover the root cause? there's nothing in config
19:35:59 <davean> you can user verbose
19:36:07 <davean> it'll show you whats restricting what
19:36:42 <max33> the issue is another constrained package whose version i cannot find
19:36:55 <max33> err the version which it's asking i can't find
19:37:06 <max33> http://pastebin.com/2A0uf5Ey
19:38:08 <max33> http://pastebin.com/92uX37UA
20:00:21 <max33> i deleted all packages and i'm still getting this reject blah blah blah error
20:02:17 <cads> hey guys this isn't really a haskell question, but I think you guys may have a lead. I'd like to learn how to write low level code with formal security guarantees.
20:02:58 <cads> Can you guys recommend environments for that? Is agda-II or Idris ready for that?
20:07:17 <cads> I know that the l4 guys did some work with Coq, Haskell and C to produce a formally verified kernel, and I've also heard about compcert c compiler with coq correctness proof
20:07:52 <cads> I mostly want to find a place where people that do this kind of programming come to chat
20:20:44 <JuanDaugherty> your client doesn't have a search function? #security e.g. has > 1k people right now
20:21:46 <JuanDaugherty> #securifucks looks promising
20:23:30 <Lokathor> how does one do a memcopy like operation with a mutable vector
20:23:41 <Lokathor> "copy from here to here, this many elements"
20:24:04 * JuanDaugherty doubts one does
20:24:17 <Lokathor> i only see funcs for doing complete vector copies, not limited quantitiy copies
20:31:29 <liyang> cads: you could try poking around in #agda or #idris…
20:32:14 <cads> liyang, though I'd bug ya guys first ;)
20:32:46 <cads> happy holidays btw, liyang, JuanDaugherty 
20:40:22 <liyang> belated happy festivus!
20:54:36 <athan> anyone here know of many circuit developing, strongly typed languages? i feel like there are parallels between sums-of-products and parallel/series circuits
20:55:12 <athan> plus it would be nice to not have capacitors blow bc of incorrect polarity :x
20:55:44 <athan> er, algebraically emphasised languages*
21:00:42 <cads> athan, like a type theory for analog circuits?
21:01:21 <athan> cads: possibly also including layout engines
21:01:38 <athan> because physical proximity raises concers about electrodynamics
21:01:47 <cads> Haven't heard of anything like that
21:01:53 <cads> let me know if you do, though
21:01:55 <athan> which is contrary to the effectless idea of lambda expressions
21:02:00 <athan> er context free
21:02:06 <athan> will do :)
21:04:30 <cads> lots of other effects to dirty up the clean idealized representation or simulation of circuitry - notrivial stuff like how circuits respond and amplify noise spectra
21:05:59 <cads> athan, it would be nice if it was extensible to let you model effects in given domains
21:06:49 <athan> you mean physical domains cads?
21:07:12 <cads> yeah
21:07:31 <athan> that would be cool :) radiation bombardment ho!
21:18:31 <JuanDaugherty> happy baby jesus day cads
21:19:00 <mmaruseacph2> Happy Newton's day :P
21:29:01 <Lokathor> oh boy do i hate SDL sound nonsense
21:31:20 <systemfault> Make your game without sound :) FTFY
21:31:56 <Lokathor> i've been copying the Handmade Hero days
21:32:10 <Lokathor> and sound seems to be... very dodgy with the sdl2 package
21:32:45 <systemfault> Oh, that's unfortunate :/
21:33:37 <Lokathor> I don't really know how it works, but i guess you can either queue audio, or you can have it run a callback. sdl2 only supports the callback as far as i can tell, and the callback doesn't seem to call back often enough
21:33:49 <Lokathor> so instead of a clear test tone, you get a "doot ... doot ... doot" sound
21:47:03 <Sinestro> Is it not possible to "sample" a behavior at the time that an event fires in reactive-banana?
21:55:01 <cads> Lol, you said "reactive bannana"
21:58:04 <Lokathor> ouch
21:58:11 <Lokathor> looks like I get about 20fps :P
21:58:21 <nshepperd1> Sinestro: you can combine an event and a behaviour to get another event
22:46:11 <praveen> Could someone suggest a reading material for continuous passing style. I couldn't follow through the haskell wiki page.
22:55:40 <edwardk> praveen: take a function like you'd normally write in javascript function foo(x,y,z) { compute a bunch of stuff; return whatever } then make one small change. remove 'return' from your vocabulary, but remember you can still pass functions around as variables
22:55:50 <edwardk> so pass 'what to do next' as an argument
22:56:11 <edwardk> function foo(x,y,z,return_) { compute a bunch of stuff; return_(whatever); }
22:56:41 <edwardk> foo(x,y,z,print) would take the place of var w = foo(x,y,z); print(w);
22:56:53 <edwardk> this is the essence of continuation passing style.
22:57:17 <edwardk> now, this doesn't work exactly as written in javascript because you keep wasting stack frames
22:57:21 <edwardk> but the idea is the same
22:59:55 <edwardk> once you pass the function that describes the entire future of your computation in you get new powers. you can hold onto it, and call it later, maybe after doing something like passing it to window.setTimeout to simulate a 'sleep' function... you could ignore it... you could hold onto it for use multiple times settingit up like a pachinko machine you drop an
22:59:56 <edwardk> answer into like a ball and watch something come out the other end.
23:01:51 <praveen> edwardk: make total sense. You mean speacify callbacks.
23:01:53 * edwardk finds himself vaguely disappointed that his IRC client didn't decide to color Sinestro yellow when assigning colors to nicks.
23:01:58 <edwardk> yeah
23:02:16 <Sinestro> edwardk: that's a travesty!
23:02:23 <edwardk> CPS is basically the usual callback idiom just cranked up to 11.
23:02:58 <edwardk> Sinestro: You wound up orange. I believe it is now mandatory to change your nick to Larfleeze.
23:07:30 <praveen> edwardk: 
23:35:34 <Axman6> woah, it's a christmas miracle, edwardk on irc on christmas day, delivering lambdas and types to one and all!
23:35:42 <edwardk> =)
23:35:59 <Axman6> (by which I mean, it's been a while since I've seen you on IRC, and it's good to see you around)
23:36:00 <edwardk> one jolly fat man, check.
23:36:04 <edwardk> heya
23:36:04 <Axman6> ha
23:37:09 <Axman6> is it daytime in the US yet?
23:37:19 <edwardk> nah. 2:30am or so here
23:37:34 <edwardk> still delivering presents to all the good boys and girls on my list
23:37:45 <Axman6> heh, about the time I went to sleep here in Aus. I'm not very full and sleepy
23:38:35 <Axman6> now*
23:39:41 <edwardk> i'm thinking about wandering to bed soon. started kicking he tires on my old transients code to see if i can get it into a shape suitable for a talk for lambdajam in May.
23:39:55 <edwardk> I never did give a talk on transients in haskell
23:40:14 <edwardk> so it'd be good to get a package finished and fully working and give a talk on the topic
23:41:02 <Axman6> edwardk: I've been playing with CPS'd implementationf of the standard monad transformers. if you've got some time another day I wouldn't mind wracking your brain about whether some of the conclusions I've come to are true or not
23:41:17 <edwardk> have you looked at my ancient monad-ran code?
23:41:29 <Axman6> that'd be great. I'll definitely be there in May, Sydney's just a drive up the street compared to going to brisbane
23:41:43 <Axman6> no, I've been working on the mtl-c package
23:41:46 <edwardk> with it i showed all the monads you can write in a strict language can be turned into 'right kan extension' transformers
23:41:58 <edwardk> http://hackage.haskell.org/package/monad-ran
23:42:01 <edwardk> its about 7 years old
23:42:11 <edwardk> but you can skim through the code to see how all the transformers adapt
23:42:12 <Axman6> I'm finding things like it appears to be be impossible to implement MFunctor from mmorph for ExceptT, which is pretty frustrating
23:42:37 <edwardk> the mmorph concept doesn't work with really anything on a CPS basis, yeah.
23:42:48 <edwardk> the 'm' occurs in positive and negative position
23:42:58 <edwardk> this is the clue that the type you're working with is in some sense 'too big'
23:43:19 <edwardk> its like how DLists have both positive and negative occurrences of a.
23:43:24 <edwardk> and you rely on conventions
23:43:24 <Axman6> ah right, that makes complete sense, I hadn't thought of it like that
23:44:17 <Axman6> I'll have to take a look at the monad-kan stuff, seems quite relevant
23:44:19 <edwardk> mappend embeds a monoid m into the larger Endo m, then we apply it to mempty to get it back down
23:44:59 <edwardk> anyways in there i wrote transformers to do state, writer, reader, decomposed IO into a pair of functors i could feed to Ran, etc.
23:45:28 <edwardk> its not perfect. there are monad transformers we use in haskell that can't be expressed this way. they are the same ones that sort of give the whole effect system world trouble though
23:45:32 <edwardk> lazy state, lazy writer, etc.
23:45:49 <Axman6> right
23:45:49 <edwardk> because those aren't sequences of requests and responses.
23:46:42 <Axman6> I'd forgotton how ugly old haddock looked =)
23:46:43 <edwardk> you can think in terms of Ran Request Response a = forall r. (a -> Request r) -> Response r
23:47:11 <edwardk> you can't see the most important parts of each instance in haddocks that old, either.
23:47:16 <edwardk> the type families
23:47:19 <Axman6> yeah
23:47:43 <Lokathor> Axman6, I read a book the other day that said that CPS StateT was like 5% faster than normal StateT
23:47:46 <Axman6> is it on github? I'll run haddock locally if it is
23:48:00 <edwardk> https://github.com/ekmett/monad-ran
23:48:15 <edwardk> no idea if it will compile on anything newer than a 7 year old ghc
23:48:44 <edwardk> it was a throwaway proof of concept back when matt morrow was still stomping around in the community
23:48:49 <Axman6> Lokathor: yeah that's what I've been seeing in the mtl-c benchmarks. everything except ReaderT is currently faster IIRC (seems that strictness is pretty important, but I haven't looked deeply into it)
23:49:21 <Axman6> edwardk: what happened to Matt anyway? I remember he worked on something I was really impressed with and then he kind of disapeared
23:49:22 <edwardk> Lokathor: normal StateT is entirely demand driven. this isn't surprising.
23:49:24 <edwardk> otoh, you can't write
23:49:40 <edwardk> foo = do foo; modify (1:)       and use it with cps'd state.
23:50:38 <Lokathor> I've been doing the beginnings of the handmade hero thing in Haskell
23:50:42 <edwardk> i don't have anything beyond hearsay. copumpkin apparently reached out to his folks and found out he'd gone off to live in the mountains or something. he added me on linkedin a couple of years back, so i guess he's still alive
23:50:53 <Lokathor> I'm on day 10, with performance counters added. Getting a whole 20fps
23:51:02 <Lokathor> rough stuff
23:51:18 <edwardk> Lokathor: strictness will kill you in game code if you aren't careful
23:51:35 <Lokathor> right now it just animates a moving color gradiant
23:51:36 <Axman6> edwardk: yeah I was worried that's wht'd happened. good to hear he might still be around
23:52:16 <edwardk> Lokathor: ouch
23:52:58 <edwardk> Lokathor: i watched a few of the homemade hero videos. they were amusing
23:53:18 <Lokathor> well, there mught be a few ways to go faster by using Surface in place of ByteString
23:53:26 <edwardk> mostly just because they made me think about 'how the heck _would_ i explain this stuff to someone who never lived through this era of development?'
23:54:26 <Axman6> I have no idea what "handmade hero" is... anyone care to enlighten me?
23:55:09 <Lokathor> zelda-like game programming project
23:55:15 <edwardk> Lokathor: if you're looking for a good old school game dev reference manual once you get through as much of the handmade hero stuff as you want to. you might look at something like michael abrash's black book. sadly almost everything about assembly or talking to vga chipsets or tricking vga into mode x, etc. in it is outdated like whoa
23:55:30 <edwardk> axman6: https://www.google.com/search?q=handmade+hero&oq=handmade+hero&aqs=chrome..69i57.1636j0j4&sourceid=chrome&ie=UTF-8
23:55:32 <edwardk> er
23:55:36 <edwardk> https://handmadehero.org/
23:55:41 <edwardk> stupid helpful chrome
23:55:42 <Axman6> Cheers
23:55:45 <Lokathor> in C, absolutely minimal libraries used in the official version. he doesnt even like importing math.h
23:56:17 <edwardk> basically its what happens when an old windows GDI era dev decides he wants to walk people through making a game in that style.
23:56:25 <Axman6> that's pretty cool, looks like fun!
23:56:41 <edwardk> its nice in that it assumes more or less zero base knowledge
23:57:19 <edwardk> gives people a bunch of weird habits out of the 'what's source control?' and 'who needs a makefile?' era, but everyone has to start somewhere
23:58:23 <edwardk> for folks who never wrote software before, its an incredibly patient few hundred hours of a guy walking through every single step
23:58:37 <Lokathor> if only my adl haskell version was over 20fps. i have to ask more knowledgeable sdl folks once theyr back from winter break stuff
23:59:05 <edwardk> Lokathor: if you move more stuff into IO and use fewer immutable things you can fix that, but it won't feel 'haskelly'
23:59:57 <Lokathor> ill have to settle perhaps
