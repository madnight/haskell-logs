00:50:34 <cocreature> what kind of trouble am I getting myself into if I use "bracket" from lifted-base inside ExceptT? afaik ExceptT is not a valid instance of MonadMask (which is why bracket from the exceptions package can’t be used) so it seems like I should except some weird behavior
00:50:59 <cocreature> ah I guess if the action returns Left, my finalizer is not run
00:51:14 <cocreature> that’s not good :(
00:51:42 <ph88> anyone know why i'm getting this error ?  Couldn't match type ‘State’ with ‘t a’   for   filterP predicates = filter (all predicates) (states :: [State])
00:52:47 <cocreature> ph88: what is the type of filterP supposed to be?
00:53:25 <cocreature> ph88: the problem is that "all" expects a Foldable but you are passing a "State"
00:53:34 <ph88> filterP :: [State -> Bool] -> [State]
00:53:37 <cocreature> which has the wrong kind
00:53:50 <ph88> i thought since it's a list it's automatically foldable
00:54:09 <cocreature> ph88: the argument to filter is applied to individual elements not to the whole list
00:56:10 <ph88> it's suppose to be equivelant to    filter predicate1 (filter predicate2 (filter predicate3 states))  .. and so on
00:56:37 <cocreature> ph88: ah so you need to flip the arguments you pass to all
00:56:39 <cocreature> :t all
00:56:41 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
00:56:47 <cocreature> the second argument should be "predicates
00:57:08 <cocreature> :t \s ps -> all (\p -> p s) ps
00:57:09 <lambdabot> Foldable t => t1 -> t (t1 -> Bool) -> Bool
00:58:55 <saurabhnanda> has anyone managed to install GHCJS on Mac OSX? Failing due to integer-gmp for me. Help would be appreciated.
00:59:12 <cocreature> ph88: try something like "filter (\state -> all (predicate -> predicate state) predicates)"
00:59:55 <cocreature> or filter (\state -> all ($state) predicates) if you want a shorter version
01:00:15 <ph88> maybe use flip ?
01:01:06 <cocreature> I find code that uses flip hard to read in most cases
01:02:00 <ph88> i have this now  https://paste.fedoraproject.org/509982/48222449/
01:02:10 <cocreature> you can probably use "filter (flip all predicates . (flip ($)))" but that’s not an improvement
01:02:42 <cocreature> ph88: if you want you can replace "\p -> p s" by ($s) but the code is perfectly fine as it is
01:03:06 <ph88> i thought maybe \s is bit redundant there
01:03:32 <cocreature> explicit lambdas are not necesarrily a bad thing :)
01:14:59 <osa1> I'm getting this from stack: base-4.9.0.0 must match >=4.3 && <4.8 (latest applicable is 4.7.0.2) any ideas what does this mean?
01:18:09 <cocreature> osa1: looks like you have some dependency that requires base < 4.8 but the ghc version chosen in your stack.yaml implies base-4.9
01:18:43 <osa1> cocreature: how did you parse that sentence? I don't understand which version is what here
01:19:42 <cocreature> osa1: (take this with a grain of salt) the first one is the one that you have instaled, ">=4.3 && <4.8" is the constraint of a dependency (or your own package), 4.7.0.2 is the latest version satisfying the constraint that is on hackage
02:22:26 <dmwit> s/on hackage/in the chosen resolver/
03:09:32 <quchen> TIL Text has linear `length`, I thought it was cached and constant time
03:10:11 <Axman6> no, because it counts um... runes? anyway some of the 16 bit values can be surragates
03:10:24 * Axman6 's terminology is probably way off
03:10:57 <quchen> Axman6: Sure, but I thought it had it stored internally anyway
03:11:14 <Axman6> no, only length and offset IIRC
03:11:20 <quchen> Axman6: Just like Set has the size of its subtrees stored, despite the fact that this is unnecessary
03:11:32 <quchen> … regarding correctness
03:11:54 <Axman6> yeah. I wonder what sort of penalty you'd have from adding that
03:12:12 <geekosaur> codepoints, and yes, some of them can be surrogates. but if it can be updated, updating a cached grapheme length is nearly impossible without going back to the beginning and reparsing the whole string
03:12:19 <Axman6> there can't be that many cases where you're creating a Text value without processing each character anyway
03:13:45 <geekosaur> conceivably it could keep a flag "no surrogates/variable length graphemes present" and in that case optimize, but I would wonder if that would actually be a win in general
03:13:47 <Axman6> and in many cases any "changes" should be able to calculate the delta pretty easily (like if you modify codepoint n, you only need to check if the old value was a surrogate, and increment or decrement the value accordingly
03:14:40 <Axman6> geekosaur: is it though? can't you just look at the current codepoint and the previous one and keep going back until you find one that isn't a surrogate? usually that would be a pretty short search
03:14:42 <geekosaur> except you have to do that everywhere that can modify something and it's absurdly easy to miss one or two and end up with a persistent off-by-one
03:14:45 <quchen> Which GHC started unpacking strict word-sized fields again? 7.10?
03:15:30 <Axman6> I mean, it's not that often you come across text like http://stackoverflow.com/a/1732454/19872
03:25:29 <NibbleNinja> A question we just had "f x = div 0 x + div x 0", what would f 42 result in? I picked "a run-time error". Is that correct?
03:28:08 <Axman6> I believe so, pretty sure div complains when dividing by 0
03:28:19 <Axman6> but, that also depends on the type of 42
03:28:31 <NibbleNinja> It was either that or type error or syntax error.
03:28:54 <Axman6> if you have instance Num MyAST where div x y = Div x y, then you're just get back the AST :)
03:29:20 <Axman6> > div x 0 :: Expr
03:29:23 <lambdabot>  x `div` 0
03:29:47 <Axman6> so, it's not necessarilly an error, depending on the Num instance
03:30:56 <NibbleNinja> What about this one Axman6 https://gist.github.com/anonymous/ff4ac777566cb4f6106d814eb062772e
03:31:31 <Axman6> what do you think it is?
03:31:38 <NibbleNinja> I answered 2.
03:31:50 <Axman6> and why do you think that?
03:32:15 <NibbleNinja> first it calls it inside the () so 0 + 1 = 1, then f (1) = 2.
03:32:37 <Axman6> but what about the outer function called f, is that relevant?
03:32:50 <NibbleNinja> not more than it's passing in the 0 I assume?
03:33:17 <NibbleNinja> I don't think it is since I declared a local function, or?
03:33:26 <Axman6> yep. the definition of f in the let shadows the outer function called f
03:33:37 <NibbleNinja> So 2 is right then?
03:33:45 <Axman6> I believe so
03:33:47 <NibbleNinja> WOOOO
03:34:14 <Axman6> but, without types, the answer should really be "probably 2, deoending on what type x is"
03:34:29 <NibbleNinja> Yeah
03:34:35 <Axman6> the answer might be "(0 + 1) + 1"
03:34:58 <NibbleNinja> We only had numbers to pick from so I think the type to choose from was just them.
03:35:13 <Axman6> yeah, it's almost certainly Integer
03:35:26 <NibbleNinja> mhm 😎
03:35:44 <Axman6> but worth thinking about. type classes let you do some pretty cool things. x could be a matrix for example
03:35:56 <NibbleNinja> matrix is a nested tuple or?
03:36:02 <NibbleNinja> or 2 dimensional?
03:36:32 <Axman6> are you familliar with matricies in maths?
03:36:55 <NibbleNinja> Not really, but I've heard from others that they've used it when sorting binary.
03:37:45 <Axman6> hmm, not sure how they're used for that but sure. anyway if you're not familliar with them ignore the example :P
03:38:18 <NibbleNinja> well, I know for a fact that it is a task I have to do in like year 2 of university, just heard of it.
03:38:39 <NibbleNinja> But they are just 2 dimensional tuples right?
03:39:00 <Axman6> yeah, you'll almost certainly do some linear algebra at uni if you do any maths courses
03:39:25 <NibbleNinja> yep, next year it is.
03:39:29 <NibbleNinja> doing just algebra atm
03:40:11 <Axman6> https://en.wikipedia.org/wiki/Matrix_(mathematics) may or may not be useful. they're a very useful tool that can be applied to a huge number of problems
03:40:40 <NibbleNinja> Oh yeah, like a map of coordinates
03:40:48 <NibbleNinja> well at least their positions
03:41:42 <Axman6> more like a two dimentional array of values. but anyway, it's probably not important at the moment
03:41:56 <Axman6> feel free to go an learn some stuff though, wouldn't want to stop you doing that!
03:48:10 <quchen> Anyone else been getting linker errors because of mwc-random recently?
03:56:57 <quchen> thoughtpolice: ^ ping
03:57:04 <quchen> You seem to know more about this issue?
03:57:22 <quchen> Log: http://lpaste.net/350206
03:57:38 <quchen> Seems related to https://github.com/bos/mwc-random/issues/54
03:57:51 <quchen> (I’m on Linux x64 here)
04:32:41 <hvr> quchen: what distro?
04:32:59 <quchen> hvr: Xubuntu
04:33:07 <quchen> 14.04 I think
04:33:08 <quchen> Let me see
04:33:14 <hvr> so nothing bleeding edge...
04:33:21 <stobix> Hm. Do we have some class with a behaviour like (Monad m, Monad w) => m a -> ( a -> w b) -> w b ?
04:33:22 <quchen> 16.04
04:33:32 <hvr> ok, that's the most recent LTS
04:33:39 * hvr tries to reproduce locally
04:33:41 <quchen> hvr: Fails with LTS-7.0 as well
04:34:00 <quchen> hvr: FWIW try "stack bench" here: https://github.com/quchen/prettyprinter
04:34:06 <quchen> That’s where I get the error
04:34:37 <hvr> for that I'd have to install stack first... I'll try with plain cabal first :-)
04:34:45 <quchen> Okay :-)
04:34:54 <quchen> If it fails to install, please do tell me so I can fix it! :-)
04:35:18 <quchen> stobix: Looks like a generalized indexed monad
04:35:24 <quchen> Way generalized!
04:36:02 <quchen> iBind :: m i a -> (a -> m j b) -> m j b
04:36:52 <Axman6> perhaps polymonads?
04:37:12 <quchen> Hm, I think I was even missing an index there.
04:37:22 <quchen> m i j a -> (a -> m j k b) -> m i k b
04:37:27 <Axman6> yeah indexed monads usually have two indices
04:39:27 <Axman6> quchen: I hadn't seen prettyprint, really nice to see a more modern pretty printer!
04:40:02 <quchen> Axman6: It’s just an overhauled wl-pprint that I haven’t released yet. I’m trying to reach the maintainers to maybe make a major version bump out of it
04:40:13 <stobix> quchen: yeah, i was kinda thinking about the difference between Applicative and Monad and thought that there might be something similar "one level up".
04:40:41 <quchen> Axman6: There are so many prettyprinters of varying quality based on Wadler/Leijen :-/
04:40:52 <Axman6> yeah
04:41:00 <Axman6> is that one on hackage?
04:41:35 <stobix> quchen: oh, so you basically "cheat" by being in the same "generalized indexed monad", and thus still can use bind and pals?
04:42:24 <quchen> Axman6: Not yet, as I said, I’m thinking about making it a new version of the well-known (ansi-)wl-pprint
04:42:37 <quchen> Have a look at the Haddocks of the new lib: https://quchen.github.io/ansi-wl-pprint-docdump/haddock/
04:43:09 <quchen> I’m hesitant releasing yet another independent prettyprinter :-/
04:43:45 <Axman6> yeah. spoken to edwardk about it?
04:44:39 <quchen> Axman6: Yes, Edward said he would be open to this. Problem is he’s only the maintainer of ansi-wl-pprint, not wl-pprint.
04:44:48 <quchen> Most of what we need is in wl-pprint (or should be).
04:44:57 <quchen> Very little about prettyprinting is about terminals. That’s just a form of markup.
04:45:14 <quchen> So my rewrite has the bulk in the wl-pprint module, and the ansi part is just one possible renderer.
04:45:22 <quchen> Other renderers are HTML or Markdown, for example.
04:45:32 <Axman6> yeah right, makes sense
04:47:47 <quchen> Plus it’s very un-String.
04:47:52 <Axman6> there's a json format I have to use from time to time which I've wished I had a nice pretty printer for. it's for geospatial data, like GeoJSON, but represents coordinates as [Number] with x, y, z, x, y, z... having them aligned would be so nice.
04:47:57 <Axman6> good =)
04:48:19 <quchen> The only thing String that I have is one list [c,c'], and the Pretty instance for Char.
04:48:44 <quchen> It’s a bit faster, but not a huge amount. Still, not worse at least! :-)
04:49:03 <quchen> The difference is very large when concatenating lots of short bits though
04:49:55 <quchen> See here: https://quchen.github.io/ansi-wl-pprint-docdump/benchmark/benchmark.html
04:50:15 <quchen> The data is a bit old, in the current version the Text version is consistently faster
04:50:29 <quchen> Forgot that length for Text is not O(1) so I didn’t cache it
04:50:42 <quchen> s/O(1)/fast in general/
04:52:44 <Axman6> is it all built on top of a Text Builder?
04:55:18 <quchen> Axman6: No, that would have terrible performance, because during the layouting phase we have to concatenate the Text in many different ways to see how to make it fit nicely
04:55:42 <theamytran> Hey everyone! How could I turn an IO String to an IO ()?
04:55:48 <quchen> I’m using fields of strict text; they are then put together by the layout algorithm to simpler fields of strict text. Printing *that* is then done using builders.
04:56:01 <theamytran> Right now I have something like `readProcess "ssh" ["-fNL", portStr, host remote] [] >>= ()`
04:56:01 <AndreasK> thallada: void
04:56:04 <theamytran> but that doesn't work
04:56:20 <AndreasK> theamytran: void iirc
04:56:31 <theamytran> @AndreasK can you show me an example?
04:56:31 <lambdabot> Unknown command, try @list
04:56:49 <AndreasK> void $ (yourValue :: IO String)
04:57:22 <AndreasK> That executes the action and throws away the result
04:57:47 <theamytran> oh kool
04:57:51 <theamytran> gonna try it thanks :3
04:58:27 <jle`> theamytran: void :: IO a -> IO ()
04:58:28 <theamytran> damn you were right thanks!
04:58:37 <theamytran> How would I implement `void` myself?
04:58:39 <theamytran> in theory
04:58:49 <AndreasK> void a = a >> return ()
04:58:54 <theamytran> ah i see
04:58:56 <jle`> for IO, void a = do a; return ()
04:58:57 <theamytran> gotta look into >>
04:58:57 <theamytran> thanks
04:59:20 <jle`> but also void a = fmap (\_ -> ()) a
04:59:23 <AndreasK> >> is just >>= which doesn't pass the result along
04:59:59 <Axman6> quchen: right, makes sense. I hadn't thought about the problem too deeply; they seemed like a useful tool but wasn't sure exactly where
04:59:59 <AndreasK> But it's a bit confusing when you deal with it the first time
05:08:14 <Axman6> quchen_: it might be nice to include an example of what happens when the Doc is wider than the width in all cases, reading hsep, I immediately wanted to know what it looks like when the width is say 10
05:12:24 <quchen_> Axman6: The answer is »nothing happens«, but I get your point
05:12:42 <quchen_> Axman6: I’m a bit afraid of drowning the definitions in too many examples though
05:13:17 <Axman6> I've always found pretty printers a little difficult to understand (though haven't used them too deeply either I guess)
05:14:10 <Axman6> might be useful in glirc...
05:14:25 <quchen_> Axman6: They’re not really all too difficult, but I agree that finding access is a bit of a hurdle
05:14:29 <stobix> hm is "data ...1 where \t ...2 \n \t ...3 \n  " equivalent to "data ...1 = ...2 | ...3 \n " ?
05:14:52 * stobix has never seen the "data ... where" syntax before
05:15:00 <Axman6> that's for GADTs
05:15:07 <quchen_> stobix: It’s GADT Syntax
05:15:17 <stobix> quchen_: ah, that explains it
05:15:55 <stobix> Maybe it's time to learn that monstrosity after all. Maybe.
05:16:04 <quchen_> stobix: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaring-data-types-with-explicit-constructor-signatures
05:16:12 <kuribas> stobix: it's pretty usefull.
05:16:13 <quchen_> stobix: GADT syntax is independent of GADTs
05:16:32 <Axman6> GADTs are pretty simple really
05:16:33 <kuribas> quchen_: it is?
05:16:35 <quchen_> stobix: It’s really just a sometimes nicer way to write new data definitions
05:16:40 <quchen_> kuribas: Yes, see my link above
05:16:53 <stobix> kuribas: I'm sure it is. But until I've grok'd it, it will hurt my brain.
05:17:09 <kuribas> quchen_: right, thanks
05:17:24 <stobix> quchen_: it is? Huh. I guess I'll start with the syntax and learn about GADT's later then.
05:17:43 <quchen_> data Maybe a where
05:17:43 <quchen_>     Nothing :: Maybe a
05:17:43 <quchen_>     Just    :: a -> Maybe a
05:17:52 <hpc> GADT syntax is arguably easier to understand than regular ADT syntax
05:18:02 <quchen_> This is equivalent to your trusty »data Maybe a = Nothing | Just a«.
05:18:07 <kuribas> stobix: it simply means you have a type variable, but the data type doesn't have to have a containing element of that type.
05:18:11 <stobix> ah, yeah. That example kinda clarified it all.
05:18:16 <quchen_> :-)
05:18:41 <stobix> More precise, more wordy, I guess.
05:18:49 <hpc> stobix: if you understand that, you're ready for GADTs themselves
05:19:17 <hpc> stobix: so with regular ADTs in the form of data A b c d ... = constructors
05:19:25 <Axman6> data AST a where ABool :: Bool -> AST Bool; AInt :: Int -> AST Int; AIf :: AST Bool -> AST a -> AST a -> AST a; AEq :: AST a -> AST a -> AST Bool -- a simple language implmented using GADTs that gives you type checking "for free"
05:19:29 <hpc> stobix: every constructor's type signature ends with "A b c d ..."
05:19:40 <hpc> stobix: GADTs loosen that restriction
05:19:53 <quchen_> Axman6: If you have more comments, why not open a ticket where you collect them all? I’d be glad if someone looked over the lib a bit, I developed it completely alone without review
05:20:03 <kuribas> stobix: the extra type variable is there just to help you restrict the possible types.
05:20:34 <hpc> you can also do things like
05:20:44 <hpc> data Which a b where
05:20:49 <Axman6> quchen_: yeah I might have a play with it, see how hard I find it to do some useful things
05:20:49 <hpc>   Neither :: Which () ()
05:21:03 <hpc>   Both :: a -> b -> Which a b
05:21:15 <quchen_> Axman6: If the documentation fails you, that’s a bug :-)
05:21:15 * Axman6 C-C-C-C-COMBO BREAKER
05:21:15 <hpc> er
05:21:17 <hpc>   Both :: a -> b -> Which a a
05:21:24 <hpc> er
05:21:29 <stobix> I guess my problem with this at one point was that I was thinking of types as structure, not functions returning stuff. Which GADT's kinda seem to suggest.
05:21:35 * hpc is still waking up it seems
05:21:52 <Axman6> =)
05:21:54 <kuribas> stobix: you can think of it as an extra annotation.
05:22:24 <Axman6> I wonder if newcomers would find Haskell easier to learn if they were introduced to GADT syntax first
05:22:32 <hpc> i have wondered the same
05:22:52 <quchen_> Some people would like GADT syntax to be part of Haskell 2020
05:23:03 <Axman6> Maybe I'll suggest that to dibblego as an experiment for the Data61 (nee NICTA) course next time we run it
05:23:15 <quchen_> And I don’t see what would speak against that (without having thought about it much)
05:23:19 <Axman6> quchen_: why not Haskell 2017? =)
05:23:21 <hpc> type signatures are just so damn good for making code obvious
05:23:22 <kuribas> stobix: that's why it's also called "phantom type".
05:23:25 <stobix> kuribas: well, yes, but that extra annotation looks very much like something a function would have. I have to rewire my brain to think from "T a b is a thing in itself" to "T a b basically has the type a -> b -> T a b"
05:23:47 <stobix> kuribas: ah. 
05:23:56 <kuribas> stobix: a function that constructs types, yes.
05:24:01 <hpc> Axman6: suggest sharing the results of a semester or two with us :D
05:24:11 <stobix> kuribas: ah. Of course. True.
05:24:42 <Axman6> hpc: yeah, I'll see what he says
05:25:11 <quchen_> Axman6: We’ll see about the number :-)
05:25:22 <kuribas> stobix: T has kind (* -> * -> *)
05:25:54 <kuribas> stobix: meaning it takes two types, and produces a type.
05:26:22 <kuribas> though type variables are more like logic programming variables than functional programming variables, right?
05:28:04 <theamytran> Does anyone know how I can get a `Just x` for some index of a list?
05:28:46 <quchen_> theamytran: Drop N elements off the front of a list, convert to Maybe using listToMaybe (= »safe head«)
05:29:09 <Axman6> so, disappointingly, @hoogle Int -> [a] -> Maybe a
05:29:13 <Axman6> bleh
05:29:17 <Axman6> @hoogle Int -> [a] -> Maybe a
05:29:20 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
05:29:20 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
05:29:20 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
05:29:29 <Axman6> @more
05:29:33 <stobix> Hm. So a GADT basically gives me a way to have a list of different types, yes? If I have data Foo a where A :: Int -> Foo Int; B :: [Char] -> Foo [Char], can i do [A 3,B "lol"]?
05:30:01 <Axman6> stobix: no, those have different types
05:30:41 <stobix> Hmkay
05:30:47 <Axman6> you could do data Foo a where A :: Int -> Foo a; B :: [Char] -> Foo a (I think, I don't think a has to be mentioned anywhere)
05:32:11 <stobix> Axman6: The "Term a" example at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs does stuff analoguous to what I did above (without putting the type in a list, that is)
05:33:25 <stobix> So, I can make a function that can have different return type depending on the return type of the type it is called on, but not have a list with different types in it.
05:33:41 <pumita> Hello, I'm writing a parser from a language like markdown that compiles a latex document for a school project. I'm modelling the type of my language with a monad transformer, that is, a main WriterT and inside it a State monad. What should the parser parse? I mean, it should return the AST as is. or it can compute the state, and be more monadic whi
05:33:41 <pumita> le parsing the AST?
05:33:53 <nshepperd> you don't need a GADT to put different types in a list. 'data Bar = A Int | B String'
05:34:21 <stobix> nshepperd: hah. true. Didn't think of that.
05:35:07 <lyxia> pumita: monadic parsers like parsec return the AST
05:35:21 <nshepperd> GADTs are good for having more fine grained divisions of values though
05:35:38 <lyxia> pumita: it's not practical to have the state contain the result of parsing, as its type is not fixed
05:36:33 <Axman6> stobix: the thing to take note of in the GADT example you linked to is that the type of a is determined by the Term a that is passed in. eval is basically a proof that if you get an Term a, you can produce an a, because all ways of making a Term a lead to something which can be evaluated as an a
05:36:51 <nshepperd> 'data Expr a where { Lit :: Int -> Expr Int;  Plus :: Expr Int -> Expr Int -> Expr Int;  IsZero :: Expr Int -> Expr Bool }' -- now [Expr Int] can contain Lits and Pluses but not IsZeros
05:36:54 <pumita> lyxia: thanks, I'm using parsec as well. I'm using a state to keep track of some important variables for the latex document, like title and author. Should these be computed inside the parser or somewhere else? (I've seen that ParsecT carries out a generic state, that's why I'm asking this)
05:36:55 <kuribas> stobix: the return type of "eval" depends on the phantom type.
05:38:31 <Axman6> stobix: it's worth noting that the final type doesn't have to match the type of anything contained in the constructor: data Foo a where F :: Int -> Foo Char is perfectly ok
05:39:16 <lyxia> pumita: do you need this information to parse the rest of your file
05:39:56 <kuribas> stobix: without GADT you could write Lit "string" :: Term String
05:40:13 <pumita> lyxia: I'll need it later, when compiling to latex, and the only way to obtain it it's when parsing, or when traversing the AST again
05:41:19 <lyxia> IMO it's good enough to just put it somewhere in the resulting AST.
05:41:31 <kuribas> stobix: then "eval (Succ t)     = 1 + eval t" wouldn't typecheck.
05:42:05 <pumita> lyxia: do you mean something like `Parser (AST, State)`?
05:43:55 <lyxia> that's one possibility, though I was more thinking that your AST type would already contain whatever's in State
05:44:56 <lyxia> Anyway, to parse markdown, I don't think you need state.
05:45:04 <pumita> lyxia: yes, my main monad is something like this: type MyType a = WriterT AST (State DocState) a
05:45:16 <pumita> I don't know if I can return that in a Parser
05:45:23 <pumita> like `Parser MyType`
05:45:41 <pumita> for example `Parser (MyType ())`
05:46:00 <pumita> lyxia: I need the state to create the latex later
05:46:24 <robstewartUK> I'm quite surprised to run `stack exec --verbosity silent -- intero --version` and get "Intero 0.1.19", because I have cloned 0.1.20 of intero. How do I find out which `intero` executable that `stack exec` is using?
05:46:31 <pumita> for example, if you have a title, you need to tell it at the start of the document
05:46:57 <pumita> and write `\maketitle`
05:47:05 <Axman6> robstewartUK: stack exec which intero
05:47:19 <lyxia> pumita: Okay maybe we misunderstood each other. By AST I actually meant whatever type that represents the document as a whole.
05:47:48 <pumita> lyxia: yes, that's my AST... it's just a monoid with the structure of the document
05:47:50 <lyxia> pumita: What is Parser
05:48:05 <robstewartUK> Axman6: excellent thank you! How do I change the order of paths it looks into for the intero executable file?
05:48:25 <lyxia> pumita: But if it represents the document, then wouldn't "State" be redundant?
05:48:42 <pumita> lyxia: type Parser = Parsec String ()
05:49:17 <robstewartUK> Axman6: actually, now I understand...
05:49:18 <Axman6> robstewartUK: edit your $PATH variable (however you are supposed to do that for your shell, often by editing ~/.profile)
05:50:42 <stobix> kuribas: Why wouldn't it? Is it because eval t doesn't have to be an Int?
05:51:33 <kuribas> stobix: eval has type Term a -> a
05:51:37 <lyxia> pumita: Parser (MyType ()) doesn't look like anything to me. Usually, a parser of some document just has a type Parser Document.
05:52:04 <pumita> lyxia: I mean, AST represents the document as a tree. Then, I need to keep a state for, let's say, if the document has a title (which is represented in the AST as `Md Title String`). This state will help me later on when building the latex element. Otherwise, I'll need to parse the AST again to check if it has a title
05:52:55 <pumita> lyxia: That's my current parser, actually
05:53:04 <pumita> it just returns an element of the AST
05:53:21 <robstewartUK> Axman6: thanks for the `stack exec which intero` advise. All sorted now.
05:53:58 <kuribas> stobix: if you would type "eval :: Term Int -> Int" it wouldn't work for (IsZero (Lit 2)) for example.
05:54:21 <kuribas> stobix: because "IsZero (Lit 2) :: Term Bool"
05:54:32 <pumita> lyxia: I was thinking on something like `ParsecT String DocState Identity AST` to calculate the state when parsing, but I don't know whether this is OK or not
05:55:03 <kuribas> stobix: that's why you need "eval :: Term a -> a"
05:55:27 <lyxia> pumita: it is fine
05:56:38 <pumita> lyxia: thanks :) . I'll give a try and see what happens
05:57:30 <lyxia> though traversing the AST to reconstruct DocState is not that much of a deal either.
05:58:34 <Axman6> pumita: just checking, but what you're working on you're doing because you've been told to do it right? if not, you should definitely be looking at pandoc :)
05:58:35 <stobix> kuribas: yeah. I kinda found a smaller example myself. "data A a where IA :: Int -> A Int; DA :: Double -> A Double" lets me write "extract :: A a -> a ; extract (IA a) = a; extract (DA a) = a", but if I have "data B a = IB Int | DB Double" i cannot write such a function.
05:58:58 <Axman6> stobix: exactly
05:59:24 <kuribas> stobix: right
05:59:46 <stobix> Also, I noticed that unless I add an explicit type signature, I get some rather interesting errors. :)
06:00:12 <kuribas> stobix: yeah, ghc can't infer all types with GADTs.
06:01:04 <Axman6> you can even do really funcy things like: data Lang a where B :: Bool -> Lang Bool; I :: Int -> Lang Int; Fun :: (a -> b) -> Lang (a -> b); App :: Lang (a -> b) -> Lang a -> Lang b
06:01:13 <Axman6> (Fun is probably wrong there)
06:01:31 <stobix> (Should probably be Boring)
06:01:39 <Axman6> yeah
06:02:51 <stobix> Axman6: it seems to compile at least
06:04:14 <Axman6> hmm, now I can't remember how you'd represent functions in a language like that. usually you'd have some sort function argument name and then be able to substitute in the value being applied to to execute the function, but it's late and I can't think how
06:04:37 <Axman6> HOAS is the technique though (higher order abstract syntax)
06:05:02 <stobix> :t App (Fun (==3)) (I 3) gives me Lang Bool
06:05:04 <lambdabot> error:
06:05:04 <lambdabot>     • Data constructor not in scope:
06:05:04 <lambdabot>         App :: t0 -> t1 -> t2 -> t3 -> t4 -> t5 -> t
06:05:12 <stobix> hi lambdabot 
06:05:13 <Axman6> yeah
06:06:11 <slack1256> " let label = case turn of One -> "X" ; Two -> "O" " weren't the ; only valid on { } blocks?
06:06:25 <Axman6> slack1256: no
06:06:42 <Axman6> you can use them to separate things which would normally be separated by lines
06:06:42 <quchen_> > let n = "n"; o = "o" in n <> o
06:06:46 <lambdabot>  "no"
06:07:15 <slack1256> nice, then why do I need the { } explicit blocks then?
06:07:23 <Axman6> Haskell is like JavaScript, the semicolons are optional and get magically inserted for you
06:07:25 * Axman6 ducks
06:08:10 <quchen_> slack1256: When you spread the definitions over multiple lines, {;} syntax gives you more liberty in how much to indent them
06:08:22 <quchen_> It’s mostly used for code generators, and by SPJ’s code style.
06:09:00 <slack1256> Got it!
06:09:00 <quchen_> {} basically gives you the same freedom C gives you in placing your semicolons and definitions.
06:10:38 <Axman6> oh of course, Fun :: (Lang a -> Lang b) -> Lang (a -> b)
06:16:37 <stobix> Axman6: Hm. I managed to write an executeLang for the previous definition. I'm not sure how I would do it for that one.
06:19:32 <Profpatsch> Urgs http://lpaste.net/350211
06:19:48 <Profpatsch> I’m trying to catch the relevant errors and encode them in something more reliable.
06:20:02 <Profpatsch> But it’s turning out to be a lot of boilerplate.
06:20:44 <Profpatsch> `catchIO` is from safe-exceptions
06:21:55 <Profpatsch> Basically both functions throw the same errors, except reading can fail because the json is malformed.
06:21:56 <stobix> Axman6: If we keep Fun :: (a->b) -> Lang (a->b) and add LFun :: (Lang a -> Lang b) -> Lang (a->b) we can do LFun (App (Fun someFun))
06:23:38 <Profpatsch> But I kind of need the file path of the config to create good error messages outside.
06:32:03 <Yuras> Profpatsch: Just use exceptions. Alternatives are not yet well established.
06:32:20 <Profpatsch> I notice, yes.
06:32:30 <Yuras> (It is my opinion, others may have other pov)
06:32:30 <ertes> helo
06:32:35 <Profpatsch> I’m not sure there *are* very good alternatives.
06:32:53 <Profpatsch> Without mountains of boilerplate.
06:33:06 <ertes> alternatives to exceptions?
06:33:34 <Yuras> Profpatsch: resent one: https://www.reddit.com/r/haskell/comments/5jc9mt/control_flow_with_an_open_sum_type/
06:33:55 <Profpatsch> I changed the code to just propagate exceptions and documented what can be thrown: http://lpaste.net/350211#a350215
06:34:08 <Profpatsch> It’s a bit easier now. :)
06:35:35 <Yuras> Profpatsch: I agree. Also, less code => less typos :)
06:36:12 <yhhko> i'm trying to mess around with datakinds and type families, and i've run into a weird problem. here's my code http://lpaste.net/350216  If i ask ghci for the kind of "TakeBla (Constant ())" it happily reports *. but if I ask if "() :: TakeBla (Constant ())", it starts complaining about missing type arguments. ideas?
06:37:33 <ertes> yhhko: your Constant family is actually just a regular type synonym, and those must be fully applied in most contexts
06:37:58 <yhhko> ertes: so why does it accept it the first time around?
06:38:17 <ertes> yhhko: because the synonym is not incorrect, your usage of it is incorrect (in haskell)
06:38:28 <yhhko> i'm still confused
06:38:49 <ertes> @let type Cnst a b = a
06:38:51 <lambdabot>  Defined.
06:39:02 <ertes> @let type Idnt a = a
06:39:05 <lambdabot>  Defined.
06:39:20 <ertes> > Nothing :: Maybe (Idnt ())  -- this one is fine, because Idnt is fully applied
06:39:22 <lambdabot>  Nothing
06:39:36 <ertes> > Nothing :: Maybe (Cnst ())  -- this one is not, because there is one type argument missing
06:39:38 <lambdabot>  error:
06:39:38 <lambdabot>      • Expecting one more argument to ‘Cnst ()’
06:39:38 <lambdabot>        Expected a type, but ‘Cnst ()’ has kind ‘k0 -> *’
06:40:06 <yhhko> ertes: this is a different example. i evaluate constant against two arguments in the end.
06:40:30 <ertes> yhhko: different example for the same error
06:40:30 <yhhko> ertes: TakeBla (Constant ()) yields a constructor TakeBla (Constant () 'Bla)
06:40:44 <yhhko> just by substitution
06:40:47 <ysangkok> how do i get the contents of the previous line in the intero repl?
06:40:49 <ertes> yhhko: you still need to apply it fully…  this could be fixed, but right now you need to apply it fully
06:40:54 <ysangkok> like arrow up in a shell or readline
06:41:09 <ertes> ysangkok: most likely M-p
06:41:18 <ysangkok> aaah thanks ertes
06:41:18 <ertes> ysangkok: that would be typical for emacs REPLs
06:41:20 <yhhko> ertes: are data families a solution here?
06:41:29 <ertes> yhhko: yes
06:41:35 <yhhko> thanks
06:41:57 <sanett> ?bot
06:41:57 <lambdabot> :)
06:42:00 <ertes> yhhko: any data/newtype type works for partial application
06:56:53 <Jayce381> Should I learn Haskell after JavaScript?
06:57:12 <Liskni_si> before
06:57:34 <Jayce381> I spent last 2 years in JavaScript. What now?
06:57:37 <Jayce381> Haskell?
06:57:49 <ertes> Jayce381: would you like to learn haskell?
06:58:11 <travv0> Why not try it and see if you like it?  Of course the people here are going to say you should learn it.
06:58:25 <Jayce381> I want to be better programmer 
06:58:46 <ertes> Jayce381: that's not the question…  would you like to learn haskell?
06:59:34 <travv0> Jayce381: Then becoming familiar with multiple paradigms is a great place to start, and Haskell is a great choice for a functional language
06:59:44 <Jayce381> I can`t answer... I want to be better developer, will I be better if I learn haskell
07:00:14 <Monoide> everything you learn make you better, whatever it is
07:00:26 <Monoide> in the worst case you'll stay the same
07:00:26 <travv0> The more you program, the better you'll get at programming.  Try learning some Haskell and see if you enjoy using it
07:00:36 <ertes> Jayce381: yes, definitely, but it requires commitment, because haskell needs more time to learn in general, especially if your brain has been wired for a JSy way of thinking
07:01:08 <ertes> Jayce381: my personal opinion is:  yes, you should learn it, but that's subjective
07:01:18 <ertes> Jayce381: just as much as your question is =)
07:01:23 <Jayce381> :-))
07:01:42 <Jayce381> Would you suggest a person who`s programming 2 years a haskell?
07:01:44 <kuribas> Jayce381: learn haskell, C, assembly, prolog, GUI toolkits, networking, basic algorithms & datastructures, and you'll be a better programmer :)
07:02:09 <ertes> kuribas: and ~15 years older =)
07:02:15 <Jayce381> :-))
07:02:30 <kuribas> ertes: you could do that in 2 years of intens studying.
07:02:48 <kuribas> Jayce381: what do you want to achieve?
07:02:55 <ertes> Jayce381: this may be surprising, but haskell is actually the easier to learn the less experience you have with mainstream languages
07:03:29 <kuribas> ertes: except that most tutorials & teaching material presumes prior knowledge?
07:04:05 <Jayce381> kuribas : I want to be better at thinking like programmer
07:04:11 <ertes> yeah, sadly
07:04:18 <ertes> if you happen to live near stuttgart, germany, i'll be giving a beginner's workshop in march =)
07:04:28 <Jayce381> :-))
07:05:01 <kuribas> Jayce381: haskell will be very helpful then, except that you will want to rewrite all other code into functional style ;-)
07:05:21 <ertes> also there are two functional paradigms
07:05:31 <ertes> 1. haskell, 2. every other functional language
07:06:19 <ertes> even if you had scheme knowledge haskell would be rather different…  only languages from the ML family are really similar
07:06:47 <ahihi> Elm is quite similar too
07:07:07 <Jayce381> So there is two sides of coin with me
07:07:25 <kuribas> Jayce381: there are many ways to approach problems, and functional programming is just one of them.
07:07:26 <Jayce381> First one is I want to get job in web dev(JavaScript). Second I want to better programmer
07:07:40 <xenon-> even ML family languages are significantly different, they are neither lazy nor pure
07:07:45 <Jayce381> I though spending two hours on haskell a day would make me a better programmer
07:08:06 <kuribas> Jayce381: it probably will.
07:08:46 <ertes> Jayce381: the most common web languages are all very similar to each other…  since you know JS you will be able to learn most of them very quickly…  haskell belongs to the kind of languages that make you a better programmer
07:09:14 <kuribas> Jayce381: you should have a look at purescript: http://www.purescript.org/
07:09:49 <Jayce381> I will
07:10:35 <kuribas> purescript looks like haskell, but it's strict, not lazy.
07:10:55 <ertes> purescript is like JS done right, and it compiles to JS
07:11:12 <ertes> you may take it as an intermediary step toward haskell
07:11:27 <Jayce381> nice. I`ve been playing with typescript...
07:11:39 <Jayce381> because of angular 2
07:11:51 <ertes> also i've heard of people for who xmonad was the entry into haskell, because the configuration language is haskell
07:12:06 <ertes> so if you're using linux/unix, you might want to try xmonad
07:14:12 <Jayce381> Is it possible to have two goals. 1. Learn technologies that will get me job 2. Learn technologies that will make me better programmer (haskell)
07:14:57 <ertes> Jayce381: that's another subjective question, and really the only person who can answer that is yourself
07:15:55 <Jayce381> You are right..
07:16:57 <travv0> It's never a bad move career-wise to improve your programming skill, though
07:18:24 <Jayce381> understood.. But after I`ve been to few interviews i saw they are looking more person who know technologies (like angular2, react) not a person who might be good programmer
07:19:46 <Jayce381> Ok.. One haskell question. I'am on windows. I edit haskell .hs file in sublimetext. I save it with ctrl-s, then GHCI don`t detect that save
07:19:58 <Jayce381> I need to restart console to detect change
07:20:23 <kuribas> Jayce381: haskell may not be very helpful on your resume.
07:20:52 <Jayce381> why is that kuribas
07:20:53 <jophish> Jayce381: you can use ':r' in ghci to reload files
07:21:12 <Jayce381> thanks jophis
07:21:14 <Jayce381> it works
07:22:00 <kuribas> Jayce381: because most companies know little about it, and it's not relevant to their technology stack.
07:22:35 <Jayce381> you are right
07:22:37 <kuribas> Jayce381: unless they already use haskell or purescript.
07:22:48 <stobix> Axman6: If I wanted to show Fun from our example above, would I need to extend the type? I came up with this solution (Langx), is it ok or am I wrongthinking: http://pastebin.com/XCHG5ZRB
07:23:06 <ertes> it doesn't hurt though…  haskell on the resume is taken as a sign of enthusiasm, which is often a positive thing
07:24:10 <ertes> ("this person didn't just learn half-assed programming in school, but they actually like programming as an activity")
07:26:44 <ertes> stobix: side note:  showsPrec d = showsPrec d . execute
07:27:10 <ertes> always implement Show in terms of showsPrec, unless you are certain that you will never need parentheses within an outer scope
07:27:22 <kuribas> Jayce381: I'd say, give it (or purescript) a try, and see if you like it :)
07:28:19 <Jayce381> I`l try kuribas :-)
07:28:37 <ertes> stobix: test case:  show (Just (V (Just ())))
07:28:56 <ertes> with your current instance this is the resulting string:  Just Just ()
07:29:51 <stobix> Yep. No way to see if I'm still "inside" Lang or not when showing right now.
07:30:03 <Apocalisp> I'm getting an error I don't quite understand when deriving a `Data` instance for a GADT parameterized on a data-kinded type: https://gist.github.com/runarorama/81892035fee01383ea9f905145da55a8
07:30:06 <stobix> what would I use showsPrec for?
07:30:21 <ysangkok> how do i restart the repl in intero? i accidentally made it block... ctrl-c does not work
07:30:40 <ertes> stobix: 'show' is implemented in terms of 'showsPrec', which is 'show' with precedence information and…  uhm…  "cat lists"
07:30:46 <stobix> ooh
07:30:50 <stobix> parentheses
07:31:32 <ertes> stobix: it uses functions of lists with composition instead of lists with concatenation, because that makes sure that all appends are right-associated
07:31:41 <glguy> Apocalisp: You probably just can't derive a Data instance for that type
07:32:03 <Apocalisp> ah, probably just need to write one then
07:32:47 <ertes> ysangkok: you can probably just kill the buffer
07:32:48 <stobix> ertes: What about the thing I did to Langx? I'm trying to think more 'haskelly', so if there's a better way to do what I did there I'm kinda interested. :)
07:33:25 <ertes> stobix: i don't know what your goal is…  are you trying to come up with an AST that you can fully examine?  like for a compiler?
07:34:45 <athan> How do I supply ghc options to stack install? `stack install foo --ghc-options bar` doesn't do the trick
07:35:49 <quchen_> It should
07:36:10 <stobix> ertes: Hm. I think my goal, inasmuch as I can be said to have one, is to be able to show things that are not showable - to have a way to say "waitaminute, this can't be shown, so I better send a message about what it is instead".
07:37:18 <stobix> ertes: I wanted to be able to show Lang (a->a), basically. The overall goal is to program haskell until I can fully understand it.
07:37:34 <onintza> https://paste.debian.net/903470/ The first parser does not stop at "marker", the second does but consumes the marker, any idea?
07:37:41 <ertes> stobix: if you take out Lift, this type looks showable to me…  even Fun is showable with some engineering effort, if you add support for variables
07:38:31 <ertes> stobix: accelerate does something similar to compile an AST like this into GPU code via CUDA/OpenCL
07:38:37 <joe9> Tuplanolla: are you the same guy as this author?  Other markets
07:38:41 <glguy> Apocalisp: I don't think this type is going to admit a Data instance
07:38:49 <joe9> Tuplanolla: ^^ http://users.jyu.fi/~sapekiis/cheat/
07:38:58 <Tuplanolla> Yes, joe9.
07:39:04 <joe9> Tuplanolla: cool.
07:39:17 <Apocalisp> glguy: At all? Any tips on writing a generic traversal of it then?
07:39:35 <joe9> Tuplanolla: I am looking for a simple C programs testsuite. probably, something that can replicate a little bit of quick check.
07:39:38 <stobix> ertes: Why is Lift a problem but not Fun? How would I know more about Lang a -> Lang b than a -> b?
07:40:01 <Tuplanolla> It's not quite QuickCheck, but you might still find it useful, joe9.
07:40:02 <joe9> Tuplanolla: can I pm you to discuss? will not take too much of your time.
07:40:18 <ertes> stobix: because with Fun you can control the argument
07:40:18 <Tuplanolla> Sure. User feedback is always appreciated.
07:40:42 <ertes> stobix: just pass the function a variable
07:41:53 <stobix> ertes: I must be missing something fundamental here. Couldn't I do that with a normal function as well? How do you mean?
07:43:04 <athan> did you see the paste? --ghc-options doesn't do it right I think :|
07:43:11 <glguy> Apocalisp: You can derive a Data instance for (Value 'Ref)
07:43:16 <athan> unless that's a cc option
07:43:20 <athan> shoot...
07:43:22 <glguy> and you can probably write one by hand for Data (Value 'NoRef)
07:43:30 <ertes> stobix: forall a b. Lang a -> Lang b  -- Lang is under your control…  if you add a variable constructor (say: Var :: Text -> Lang a), you can apply this function to a variable and see what it returns
07:44:04 <ertes> all the usual alpha-equivalence problems happen here, so this requires engineering, but it's possible
07:45:45 <glguy> actually... since we can wrote those two instances we might be able to make a new ValueData class and write the data instance in terms of it
07:47:16 <stobix> ertes: I guess I don't really see the difference between creating a variable and applying it to a function to see what it returns, and creating a value and applying it to a function to see what it returns. I guess the second implies that we know how to do that, but apart from that I see no difference.
07:47:22 <athan> can anyone see that log I posted a minute ago?
07:47:32 <quchen_> I can’t.
07:47:42 <ertes> stobix: try to write a function of the following type:  (a -> b) -> b
07:48:01 <stobix> athan: If you tried to post a lot of lines, it probably got filtered away. Put it in a pastebin and post the link here if that's the case.
07:48:30 <athan> http://lpaste.net/350217
07:49:00 <athan> quchen_: ^
07:49:19 <stobix> ertes: I have no idea how that would be possible. Is it?
07:49:28 <ertes> stobix: it's not =)
07:49:48 <ertes> stobix: now try:  (Show b) => (a -> b) -> String
07:49:49 <stobix> ertes: and I assume it is relevant to what we said above somehow? :)
07:50:04 <ertes> stobix: this one is possible, but the resulting string has nothing to do with the argument
07:50:25 <stobix> Ah. Well, yes. Do we need the Show b constraint even?
07:50:36 <ertes> yeah, sure…  you still have V
07:51:01 <ertes> ah, nevermind, but it would still be necessary *if* you could come up with an 'a'
07:51:10 <athan> .
07:51:16 <athan> ugh
07:51:20 <athan> sorry
07:51:59 <ertes> stobix: the problem is that functions in general are completely opaque, unless you can control what the function is able to do with its argument…  in the Lang case you have full control over that
07:52:33 <athan> can I supply ghc-options to all the depend
07:52:37 <athan> dependencies of foo?
07:56:12 <kuribas> :t ($ fix id)
07:56:13 <lambdabot> (a -> b) -> b
07:56:23 <stobix> ertes: hm. I guess. But any value I'm about to send into the fun I'll know in both cases, and if I need to actually apply something to the function, the application in itself is still opaque. I don't see what I could do with App (Fun lf) x that I could not do with App (Lift f) x in terms of showing it. Unless, of course, I bake in some metadata for the function in the type itself.
07:56:42 <MarcelineVQ> athan: possibly relevant https://github.com/commercialhaskell/stack/issues/2712
07:56:43 <kuribas> :t ($ fix id) -- ertes, stobix
07:56:46 <lambdabot> (a -> b) -> b
07:57:00 <ertes> > ($ fix id) id
07:57:06 <lambdabot>  mueval-core: Time limit exceeded
07:57:07 <ertes> kuribas: ^
07:57:13 <ertes> that's a partial function
07:57:21 * kuribas cheated
07:57:44 <stobix> ertes: Ah. So, basically, for a Lang a -> Lang b, I get a Lang a in, and that has more metadata than a pure a
07:57:48 <stobix> ertes: right?
07:57:48 <yhhko> what's wrong with partial functions...
07:57:59 <stobix> s/more/possibly &/
07:58:03 <ertes> kuribas: why didn't you just use (undefined :: (a -> b) -> b)? =P
07:58:10 <ertes> same thing =)
07:58:19 <yhhko> ertes: actually no, it's not the same thing
07:58:23 <kuribas> ertes: for obfuscation
07:58:26 <Tuplanolla> > ($ fix id) (const 42)
07:58:27 <ertes> yhhko: it is semantically
07:58:31 <lambdabot>  42
07:58:34 <yhhko> ($ fix id) (const 3)
07:58:37 <yhhko> > ($ fix id) (const 3)
07:58:40 <yhhko> there we go :)
07:58:41 <lambdabot>  3
07:58:42 <ertes> wait
07:58:45 <ertes> huh?!
07:58:46 <ertes> ah
07:58:49 <ertes> of course =)
07:59:06 <ertes> kuribas: why didn't you just use (($ undefined) :: (a -> b) -> b)? =P
07:59:20 <ertes> same thing (now it is) =)
07:59:29 <Profpatsch> Hm, pattern guards in lambdas?
07:59:30 <stobix> :i fix
07:59:49 <stobix> :t fix
07:59:51 <lambdabot> (a -> a) -> a
07:59:56 <Profpatsch> v… `catchIO` (e | isFooError e ->
08:00:15 <ertes> stobix: the result type also has to be a Lang, otherwise you're not showing a *function*, you're actually just showing the *result* of a function
08:00:20 <stobix> :inWhatModuleDoIFind fix
08:00:32 <quchen_> Control.Function
08:00:35 <quchen_> Data.Function?
08:00:38 <quchen_> ?hoogle fix
08:00:42 <lambdabot> Data.Function fix :: (a -> a) -> a
08:00:42 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
08:00:42 <lambdabot> Agda.Compiler.JS.Substitution fix :: Exp -> Exp
08:00:49 <quchen_> Hooray Hoogle!
08:01:10 <ertes> stobix: example:  (5 +)  -- you can easily come up with an argument for that one (say 5) and observice its result (10), but there is no way to recover the function itself (\x -> 5 + x)
08:01:31 <Profpatsch> fix f = let x = f x in x
08:01:33 <stobix> ertes: Ah, now I get what you mean. If I want to show "this is a function from A to B" instead of "this is a function. period." I need Lang a -> Lang b.
08:01:36 <ertes> *observe
08:01:49 <kuribas> stobix: the body of the function is passed as argument to the function, and then returned.
08:01:53 <ertes> stobix: "this is a function defined as: …"
08:02:02 <stobix> ertes: would that be possible ever?
08:02:12 <kuribas> stobix: like a dog chasing its own tail.
08:02:21 <ertes> stobix: well, you can't show the underlying haskell function, but you can show the function written in your AST
08:02:36 <yhhko> ertes: actually, even ($undefined) is different
08:02:46 <yhhko> > ($ undefined) (const 0)
08:02:49 <lambdabot>  0
08:02:51 <yhhko> > ($ fix id) (const 0)
08:02:54 <lambdabot>  0
08:02:57 <yhhko> eh, not what i meant
08:03:04 <yhhko> > ($ fix id) undefined
08:03:04 <stobix> different execution times at least
08:03:07 <lambdabot>  *Exception: Prelude.undefined
08:03:08 <yhhko> > ($ undefined) undefined
08:03:11 <lambdabot>  *Exception: Prelude.undefined
08:03:19 <yhhko> bah. let me figure this out
08:03:21 <ertes> yhhko: they are the same thing =)
08:03:27 <quchen_> stobix: Here are a couple of well-known functions implemented using ordinary recursion, and then using fix. https://github.com/quchen/articles/blob/master/fix.md#examples
08:03:37 <ertes> yhhko: fix id = ⊥, undefined = ⊥
08:03:42 <yhhko> ertes: well the point i wanted to make is that undefined raises an error, whereas fix id simply doesn't terminate
08:03:56 <kuribas> yhhko: fix id == fix (\a -> a).  It's the same as saying a == a, which is trivially true for any value.  So it doesn't define a.
08:03:58 <ertes> yhhko: sure, but semantically they are the same thing
08:04:08 <Tuplanolla> You can squeeze a different exception out of it, but that's all, yhhko.
08:04:31 <Tuplanolla> The compiler is allowed to turn unproductive loops into exceptions.
08:04:46 <yhhko> > ($ undefined) id
08:04:49 <lambdabot>  *Exception: Prelude.undefined
08:04:51 <yhhko> > ($ fix id) id
08:04:57 <lambdabot>  mueval-core: Time limit exceeded
08:04:59 <yhhko> there we go
08:05:16 <ertes> put differently: even though we could observe different behaviours in IO, pure code can't tell the difference…  yet differently: we don't distinguish between them in equational reasoning
08:05:32 <yhhko> ertes: if you want to say they're the same thing semantically, then you have to tell me which semantics you meant. because those outputs are different.
08:05:58 <MarcelineVQ> not an answer now and not an answer later is still not an answer, I guess
08:06:16 <ertes> yhhko: https://en.m.wikibooks.org/wiki/Haskell/Denotational_semantics
08:06:36 <stobix> ertes: Hmmm. Would even Lang a -> Lang b work there, or would I have to have something like LangFun a b? Wouldn't an Lang a -> Lang b function be just as opaque as the rest?
08:06:57 <yhhko> ertes: then i agree.
08:08:03 <ertes> stobix: as i said, haskell functions are opaque, but when you apply a Fun to a variable the result is an expression that is a function in your Lang language
08:08:13 <ertes> stobix: so you're not actually showing a *haskell* function, but a Lang function
08:09:06 <onintza> What is the most straightfordward way of ignoring all whitespace with parsec?
08:09:26 <quchen_> skipMany space, something like that?
08:09:26 <Tuplanolla> Compile it with `-O2` and you'll get different behavior again, yhhko.
08:09:27 <yhhko> onintza: filter it all out before shoving it into parsec
08:09:33 <ertes> onintza: filter (/= ' ')
08:10:05 <stobix> ertes: Hm, so, given that we have no Lift, everything can be showable - is that more or less what you're saying?
08:10:20 <quchen_> onintza: spaces it’s called, http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html
08:10:23 <ertes> stobix: you also need a constructor for variables
08:10:35 <onintza> quchen_: that requires you to explicitly use them everywhere
08:10:39 <stobix> ertes: V is not enough then?
08:10:46 <quchen_> onintza: Yup
08:10:55 <quchen_> It’s the most straightforward way.
08:11:00 <onintza> ertes, yhhko: I wanted to do it using parsec
08:11:02 <ertes> stobix: at this point i recommend that you look into the accelerate package
08:11:10 <onintza> quchen_: it's not, you have to modify a hell of a lot of code
08:11:47 * stobix tries finding enlightenment by beating his head against accelerate
08:12:27 <yhhko> quchen_: what do you have to modify that you wouldn't like to modify?
08:12:33 <yhhko> err, onintza *
08:13:19 <onintza> yhhko: imagine I have some "read <$> (many1 digit)"
08:13:27 <onintza> I would need to modify that, for example
08:13:58 <onintza> in a non-trivial way
08:15:00 <yhhko> onintza: you mean, you have to figure out all the ways in which spaces can be between digits?
08:15:15 <Tuplanolla> Here's a delightful parser, onintza: `join between spaces`
08:15:57 <Tuplanolla> :t Control.Monad.join Text.Parsec.Combinator.between Text.Parsec.Char.spaces
08:15:59 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
08:17:04 <stobix> ertes: I assume you mean I should rtfs Data.Array.Accelerate.Interpreter ?
08:17:15 <robstewartuk> This should be self explanatory, as to what I'm trying to do: http://lpaste.net/350219
08:17:41 <robstewartuk> GHC doesn't accept this. How can I say that Baz requires an Ord instance?
08:18:07 <robstewartuk> The error is "parse error on input ‘deriving’"
08:18:15 <onintza> Tuplanolla: how would I use that?
08:18:37 <onintza> "join between spaces (many anyChar)" only skeep enclosing spaces
08:18:40 <onintza> skips*
08:19:17 <Cale> robstewartuk: You can't ask it to derive an Ord instance, but you can insist that one exists in the class head:  class (Baz a) => Foo a where ...
08:19:22 <Tuplanolla> How about `many (join between spaces anyChar)`, onintza?
08:19:26 <Cale> er, sorry
08:19:34 <Cale> class (Ord (Baz a)) => Foo a where ...
08:19:56 <onintza> Tuplanolla: oh, wow
08:19:59 <yhhko> Cale: can you somehow satisfy this requirement afterwards?
08:20:02 <Tuplanolla> There are better ways to do that, but sometimes this thing is useful, onintza.
08:20:37 <Cale> yhhko: Sure, by making sure to write or derive an Ord instance for the Baz type provided by the instances of the class.
08:20:56 <quchen_> onintza: Usually, we write our tokenizing parsers so that they skip all whitespace after them. In the parser you don’t have to worry about whitespace then.
08:20:57 <robstewartuk> Cale: thanks!
08:21:06 <quchen_> onintza: I suggest putting the tokenizers in their own modules.
08:21:18 <quchen_> You can also use a proper tokenizer of course, but I don’t have experience doing that.
08:21:51 <yhhko> if you want to use existing tokenizer technology, perhaps look into megaparsec, which put some effort into that
08:22:09 <onintza> Whitespaces aren't used for tokenizing in my case though
08:22:19 <Tuplanolla> In my experience separate tokenization is not worth the effort, especially if you want to carry source positions through.
08:22:19 <onintza> They don't convey any information
08:23:33 <quchen_> onintza: Whitespace may separate tokens, but some tokens don’t need whitespace after them. »(x)« has three tokens in Haskell, but no whitespace.
08:24:00 <quchen_> onintza: If you really just want to delete whitespace before you parse, then what others suggested with using »filter« is good enough I guess.
08:25:27 <onintza> Is it not possible to define functions starting with !?
08:25:35 <onintza> That is, with "!"
08:25:52 <onintza> Like "(!_) = join between spaces"
08:25:56 <Tuplanolla> :t (!!)
08:25:58 <lambdabot> [a] -> Int -> a
08:26:07 <onintza> Illegal bang-pattern (use BangPatterns):
08:26:13 <quchen_> Haskell does not support prefix operators, no.
08:26:19 <quchen_> User-defined, that is.
08:27:42 <kadoban> onintza: _ has meaning in patterns, it's like a binding without a name. So !_ means ... not what you want at all.
08:28:13 <kadoban> You can define operators made of all symbols, but some things won't work. I think I'd just avoid _
08:28:16 <Profpatsch> quchen_: And we’re better off because of that.
08:28:23 <onintza> Right, it looks like I can't use _ at all
08:28:29 <onintza> I was thinking of "wo_" but no
08:28:36 <Profpatsch> But isn’t a function basically a prefix operator already?
08:28:37 <quchen_> Profpatsch: I agree, but be careful saying that around Agda people ;-)
08:29:17 <Profpatsch> f a = … is a prefix operator: f 1 :)
08:29:30 <quchen_> Pfff.
08:29:43 <lpaste> glguy pasted “Data instance for apocalisp's GADT” at http://lpaste.net/350220
08:29:43 <quchen_> The Report only calls infix operators »op« as far as I remember.
08:29:49 <glguy> Apocalisp: I think this is how it can be done
08:29:58 <Apocalisp> ooh
08:30:04 <Apocalisp> thanks, glguy
08:30:16 <glguy> You should play with that if you decide to use it. I haven't
08:31:10 <quchen_> > let ()<>!!! x = not x in ()<>!!! True -- The prefix operator ()<>!!!
08:31:12 <lambdabot>  False
08:31:14 <quchen_> Profpatsch: Take that!
08:31:56 <Profpatsch> Oh lol, because () is Unit?
08:32:03 <Profpatsch> wow
08:32:05 <quchen_> :-)
08:32:11 <Tuplanolla> This is on the level of the "approaches" operator in C, quchen_.
08:32:30 <quchen_> :t (<<>~)
08:32:32 <lambdabot> Monoid m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
08:32:36 <Profpatsch> Next up: the nbsp operator
08:32:45 <Tuplanolla> Like so: `while (x --> 0)`
08:33:09 <Profpatsch> Tuplanolla: Oh, is this x--  >   0 ?
08:33:16 <Tuplanolla> It is.
08:33:19 <Profpatsch> lol
08:33:29 <quchen_> What are they called again, the tadpole operators?
08:33:38 <quchen_> x <~ 0
08:33:41 <quchen_> Something like that
08:33:50 <Profpatsch> It’s like smoking some crazy stuff … like Camel (on a dromedar).
08:33:52 <quchen_> There’s a great paper about them.
08:34:10 <bollu> quchen_: it was an article on MSDN right?
08:34:14 <bollu> quchen_: IIRC?
08:34:15 <quchen_> Could be.
08:34:30 <Profpatsch> (bonus point for getting the perl reference, another for the Marsimoto ref)
08:34:35 <stobix> lol @ -->
08:34:52 <marchelzo> yes it was an april fools thing on MSDN
08:34:53 <stobix> Like c needed further obfuscation. ;)
08:35:13 <marchelzo> about new "tadpole operators" in their C++ compiler
08:35:18 <ertes> > let wo_ = id in wo_ ()
08:35:21 <lambdabot>  ()
08:35:41 <quchen_> ..?
08:35:55 <quchen_> > do do do do do 1
08:35:58 <lambdabot>  1
08:36:32 <stobix> marchelzo: It's kind on the same level as the exponentiation operator. #define PWR_OF_THREE(x) = 3^x
08:36:51 <maerwald> is there any haskell sql library that utilizes langsec with proper DSL parsing to avoid sql injection?
08:37:49 <Tuplanolla> Have you been reading Sassaman recently, maerwald?
08:38:10 <ertes> quick OT question: "pastime" refers to the spare time *activity*, not the spare time itself, right?
08:38:11 <maerwald> obviously
08:38:26 <maerwald> or rather: Patterson
08:38:36 <Tuplanolla> That works too.
08:38:50 <maerwald> well, basically everything on langsec.org
08:38:54 <MarcelineVQ> that which you do to pass time
08:39:41 <maerwald> don't see any sql library advertising that approach, so I guess all they do is naive sanitation, a bit of TH hackery and then hope the types are enough (which they are not)
08:40:04 <bollu> maerwald: what is "langsec"?
08:40:17 <bollu> also, I was hoping for some way to read the bananas, lenses, and barbed wire
08:40:18 <maerwald> bollu: http://www.langsec.org/ https://www.blackhat.com/presentations/bh-usa-05/BH_US_05-Hansen-Patterson/HP2005.pdf
08:40:24 <bollu> I don't understand cata in terms of Mu
08:40:31 <bollu> (the fixpoint definition of cata)
08:40:36 <bollu> where can I read about them?
08:40:52 <bollu> maerwald:interetin
08:40:58 <bollu> interesting*
08:48:36 <Profpatsch> maerwald: Everybody should read everything Sassamann/Patterson have done on langsec.
08:48:49 <Profpatsch> The world would be so much better.
08:49:12 <Profpatsch> I hope Patterson will be around on Congress.
08:49:12 <maerwald> it would be useful to have a library that just provides high-level "parsers" for sql stuff, like for certain keywords or things like an SQL string (which must not contain unescaped "), then you can just build your own sql sublanguage for a given query
08:49:41 <Profpatsch> Isn’t SQL escaping a solved problem?
08:49:51 <Profpatsch> I mean SQL databases do it themselves with ?
08:50:03 <maerwald> I'm talking about parsing
08:50:07 <Profpatsch> So there is native support for that already, you just have to use it.
08:50:24 <Profpatsch> Hm, you mean parsing SQL statements when you are not a database?
08:50:33 <maerwald> ofc
08:50:47 <maerwald> that's what the SQL injection solution is about in the paper I linked
08:51:24 <maerwald> define an SQL sub-language, write a parser for it
08:52:01 <bollu> can someone help me understand catamorphisms, please?
08:52:15 <maerwald> then, even if your escaping (which is not a reliable solution) doesn't detect the problem, your parser will
08:52:31 <ertes> bollu: do you understand how to define recursive types as fixed points of non-recursive types?
08:54:05 <bollu> ertes: yep, I do
08:54:09 <bollu> ertes: using Fix
08:54:31 <ertes> bollu: ok, let F be the non-recursive type for a type T, (i'll call F the base type)
08:54:41 <ysangkok> how do i add another module to the scope of the repl in intero without taking the exciting out of scope?
08:54:49 <ertes> bollu: cata :: (F a -> a) -> T -> a
08:55:24 <ertes> bollu: in simple terms a catamorphism is a reduction function that doesn't lose information and doesn't do anything more than reducing
08:55:33 <bollu> ertes: how do I use this? :( 
08:55:42 <bollu> ertes: and, like, what is the inutiion?
08:55:44 <bollu> intuition*
08:55:51 <ertes> bollu: well, what is ListF, the base type for lists?
08:56:11 <onintza> With Parsec, is it possible to parse an already parsed string through a second parser?
08:56:48 <onintza> I might be missing something
08:56:52 <cocreature> omilu: do you want to process the result of the first parser or just pass the same string to two different parsers?
08:56:59 <ertes> bollu: catamorphisms are a generalisations of 'foldr', 'maybe', 'either', etc.
08:57:04 <peddie> ysangkok: does  :m +Module.Name  work?
08:57:19 <xenon-> (defun foo () (let ((foo-x 10)) (bar)))
08:57:22 <xenon-> woops
08:57:31 <Hafydd> Wow.
08:57:38 <ertes> bollu: in fact you will find that (cata :: (ListF a b -> b) -> [a] -> b) is just foldr (you need to apply some type algebra to see it)
08:57:40 <onintza> cocreature: process the results of the first parser through the second
08:57:41 <cocreature> onintza: both is possible, for the first, you can change the "s" type parameter in ParsecT to use a different stream type
08:58:11 <bollu> ertes: List a = [] | a: List a, so, to generate it, I would need ListF f a = [] | a : f a, List a = (Fix ListF) a?
08:58:27 <bollu> ertes: I think of Fix as just a "type level Y"
08:58:35 <ertes> bollu: not quite
08:58:43 <bollu> hm
08:58:47 <onintza> cocreature: cheers, i'll have a better look
08:58:54 <ertes> bollu: data ListF a x = NilF | ConsF a x
08:59:05 <cocreature> onintza: if you have a concrete problem I’m sure we can help you more :)
08:59:15 <xcmw> Is there a type level function that combines two lists and not duplicate elements. ['X, 'Y] + ['Y + 'Z] = ['X, 'Y, 'Z]
08:59:22 <bollu> ertes: ah, hm
08:59:27 <preyalone> is there a name for Haskell's feature of allowing exclusive types, like type Derp = OneThing | Another ?
08:59:33 <ertes> bollu: now this is a sum type, right?
08:59:49 <bollu> ertes: yes
08:59:54 <ertes> ListF a x = 1 + a*x
09:00:25 <ertes> cata :: ((1 + a*x) -> x) -> [a] -> x
09:00:39 <ertes> do you see how this type turns into the type of foldr?
09:00:55 <ertes> (is isomorphic to it)
09:01:27 <onintza> cocreature: https://paste.debian.net/903483/ In compressed there, I would want to process "s" through "segments"
09:01:54 <bollu> :t foldr
09:01:56 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:02:04 <ertes> bollu: assume t = []
09:02:12 <cocreature> onintza: what’s the type of s?
09:02:56 <onintza> cocreature: Parser String
09:03:12 <Soldalma> I tried to import Add3 package just below } where in Main.hs and got Failed to load interface for `Add3`. What did I do wrong?
09:03:21 <bollu> ertes: the types don't align, do they?
09:03:32 <ertes> bollu: you need some type algebra =)
09:03:37 <bollu> ertes: ah :)
09:03:41 <bollu> ertes: OK, let me try
09:04:26 <bollu> ertes: I need ((1 + a*x) -> x) ~ (a -> x -> x) -> x
09:04:37 <bollu> (since b ~ x)
09:04:41 <ertes> bollu: nope
09:04:44 <bollu> ertes: no?
09:04:52 <ertes> bollu: use the full type, otherwise you will run into silly mistakes
09:05:12 <ertes> foldr :: (a -> x -> x) -> x -> [a] -> x
09:05:15 <bollu> ((1 + a*x) -> x) -> [a] -> x ~ (a -> b -> b) -> b -> [a] -> b
09:05:16 <cocreature> onintza: the easiest solution is to just call "runParser" inside of your parser
09:05:27 <ertes> foldr :/: ((a -> x -> x) -> x) -> [a] -> x
09:05:35 <bollu> right
09:05:41 <onintza> cocreature: right, thanks!
09:06:06 <bollu> ((1 + a*x) -> x) -> [a] -> x ~ ((a -> x -> x) -> x) -> [a] -> x
09:06:26 <bollu> so, ((1 + a*x) -> x) ~ ((a -> x -> x) -> x)? 
09:06:30 <ertes> bollu: same mistake =)
09:07:02 <ertes> bollu: keep in mind that (->) is not associative
09:07:05 <bollu> ah
09:07:46 <bollu> (((1 + a*x) -> x) -> [a]) -> x ~ (((a -> x -> x) -> x) -> [a]) -> x     just for maximum emphasis. Correct so far?
09:08:00 <ertes> bollu: worse
09:08:08 <ertes> bollu: A -> B -> C = A -> (B - C)
09:08:11 <bollu> ertes: what? a -> b -> c == a -> (b -> c)
09:08:18 <bollu> god damn it
09:08:19 <bollu> right
09:08:26 <ertes> *->
09:09:26 <onintza> cocreature: is there any mechanism to propagate parsing errors through nested parsers?
09:10:07 <bollu> ((1 + a*x) -> x) -> ([a] -> x) ~ ((a -> x -> x) -> x) -> ([a] -> x)
09:10:28 <bollu> so why can't I just unify the right hand side and write ((1 + a*x) -> x) ~ ((a -> x -> x) -> x)?
09:10:34 <ertes> bollu: your right hand side is wrong
09:10:48 <bollu> oh
09:11:38 <bollu> ((1 + a*x) -> x) -> ([a] -> x) ~ (a -> x -> x) -> (x -> ([a] -> x)) 
09:11:44 <bollu> now?
09:11:50 <ertes> now it's correct =)
09:12:05 <ertes> but i don't think the extra parentheses really buy you anything
09:12:07 <bollu> that looks impossible to unify :O
09:12:25 <ertes> your goal is not to unify, but prove that they are isomorphic
09:12:53 <bollu> ertes: so I need to write f -> g and g -> f?
09:13:01 <bollu> ertes: write/implement
09:13:06 <ertes> first notice that types form a commutative semiring with sums and products
09:13:20 <ertes> so you get stuff like:  a * b ≃ b * a
09:13:56 <ertes> then use the fact that a -> b ≃ b^a
09:13:57 <bollu> ertes: OK, but how does -> interact with everything else?
09:13:59 <bollu> ah
09:14:08 <bollu> ertes: but, wait, what does "exponentiation" even mean in this context?
09:14:19 <ertes> repeated products =)
09:14:27 <bollu> ertes: hm
09:14:35 <ertes> x^2 ≃ x * x
09:14:50 <bollu> ertes: for that to make sense, you need some notion of |a| ?
09:14:51 <ertes> now consider that 2 ≃ Bool and see why that works
09:14:56 <bollu> (how many times do you repeat)
09:14:57 <bollu> oh
09:15:05 <bollu> the number of "branches" in the type?
09:15:23 <ertes> you can establish the "natural number types" by repeatedly adding 1 ≃ ()
09:15:33 <bollu> ertes: dang, that is slick :)
09:15:45 <ertes> and of course 0 ≃ Void
09:15:56 <bollu> ertes: you literally build (0, 1, +, x)
09:16:00 <bollu> ertes: that is so cool
09:16:13 <ertes> it's not quite enough to get all powers, but it works as an intuition =)
09:16:15 <bollu> ertes: OK, back to type massaging
09:16:21 <ertes> (exponents don't have to be countable)
09:18:48 <bollu> (1 + a*x) -> x = x^(1 + a * x) = x^1 * x^(a * x) = (x, (a, x) -> x) = (x, a -> x -> x) 
09:18:53 <bollu> I think this will help
09:19:09 <ertes> that's correct =)
09:19:25 <bollu> ertes: cool :)
09:19:36 <bollu> ertes: that was quite gimmicky :P is there an intuition for it?
09:19:43 <ertes> bollu: minor nitpick: they aren't equal, but isomorphic
09:19:51 <bollu> ertes: ah, right, my bad
09:20:03 <ertes> yeah…  cardinalities are a useful intuition
09:20:18 <bollu> ertes: hm
09:20:34 <bollu> ertes: what is the rigorous way to build this up, though? the "type algebra"?
09:20:35 <ertes> in fact you may have seen the power notation for functions from ordinary set theory
09:20:41 <ertes> stuff like ℝ^ℕ
09:20:42 <bollu> yes
09:20:45 <ertes> it's the same thing
09:21:05 <bollu> ertes: hm
09:21:14 <ertes> well, the rigorous way is to establish an equivalence relation for isomorphicness
09:21:25 <ertes> then build a semiring on top of it
09:22:32 <bollu> ertes: interesting
09:22:37 <bollu> ertes: OK, back to cata
09:22:44 <bollu> ertes: can you show me how to use it on List, for example?
09:22:51 <ertes> you need the…  i don't even know what it's called…  constructive notion of semirings that doesn't insist on equality, so it has two extra axioms
09:23:05 <bollu> ertes: which are?
09:23:09 <ertes> well, you just saw that 'cata' is just 'foldr' in disguise
09:23:20 <ysangkok> peddie: no, each time i press C-c C-l, it loads a new module and i can't load any modules but itself and its dependencies though :m
09:23:48 <ertes> bollu: ∀ a1 a2 b1 b2. a1 ≃ a2, b1 ≃ b2 → a1 + a2 ≃ b1 + b2
09:23:54 <ertes> bollu: same for (*)
09:24:09 <bollu> ah
09:24:50 <peddie> ysangkok: ah, OK, sorry, don't have any other guesses, but maybe someone else knows
09:25:06 <bollu> ertes: OK, so, like, how would I use it on a list? :)
09:25:15 <bollu> ertes: how would I implement factorial for example?
09:25:19 <ertes> bollu: here is my definition of "constructive" semigroups (not semirings): https://github.com/esoeylemez/agda-simple/blob/master/Algebra/Group/Semigroup.agda#L13
09:25:40 <bollu> ertes: I need to pick up Agda :/
09:25:43 <ertes> bollu: do you really want to start with a stateful fold? =)
09:26:12 <bollu> ertes: xD I'm not sure, I want to see the fix-based based definition used
09:26:14 <ertes> bollu: actually i have an almost finished draft of my foldr tutorial online: http://ertes.eu/tutorial/foldr.html
09:26:16 <bollu> ertes: what would you recommend?
09:26:32 <ertes> bollu: all you need to do is to translate between foldr and cata, which is really straightforward
09:26:45 <bollu> ertes: I see
09:26:56 <bollu> ertes: so, the power of the Fix based cata is the generality?
09:27:03 <bollu> ertes: or do you "actually" gain power?
09:27:12 <bollu> and 2. is there some cat. theory interpreation for this?
09:27:13 <ertes> bollu: generality
09:27:15 <MarcelineVQ> some of this stuff is covered in your RankNTypes tutortial I keep not finishing iirc
09:27:39 <ertes> bollu: generality sometimes comes with theorems for free, too
09:27:53 <ertes> bollu: for example:  cata id = id
09:28:00 <ertes> uh, no
09:28:09 <ertes> needs some Fix wrapping to be true
09:28:17 <bollu> ertes: xD
09:28:36 <ertes> but there exists an identity for every 'cata'
09:28:48 <bollu> ertes: "generality comes with theorems for free" I don't see how you get "extra" theorems. That's like you telling me that we weakening Z to a ring gives me "more" theorems?
09:28:57 <bollu> s/see/understand
09:28:58 <ertes> MarcelineVQ: i covered church and scott encoding there, but it's not really too related to this
09:29:26 <ertes> bollu: f1 :: Int -> Int  -- could be anything
09:29:38 <ertes> f2 :: a -> a  -- must be the identity function (or have bottoms)
09:30:00 <bollu> ertes: hm, I see what you mean, polymorphism gives you less to work with
09:30:29 <ertes> bollu: yeah, the feature is called parametricity
09:30:39 <ertes> most languages don't have it, but haskell does
09:30:54 <bollu> ertes: right
09:31:59 <bollu> ertes: and hylo and ana are the same
09:32:01 <bollu> ertes: ?
09:32:15 <bollu> ertes: the original bananas.. paper doesn't explain where the types came from :(
09:32:22 <bollu> ertes: is there a source that explains it in detail?
09:32:29 <bollu> ertes: like, history / originally?
09:32:45 <ertes> i don't know, sorry
09:33:05 <ertes> ana is the dual to cata (it produces) and is the corresponding unfoldr for lists
09:33:12 <bollu> ertes: right
09:33:20 <bollu> ertes: and hylo is a unfold then a fold
09:33:29 <bollu> ertes: I know the non-polymorphic variants
09:33:35 <bollu> ertes: now that you showed me the type algebra
09:33:44 <bollu> I will try and convert one to the other
09:34:15 <ertes> bollu: yeah…  just implement foldr in terms of cata to see how it works =)
09:34:22 <bollu> OK! thanks a lot :)
09:36:35 <ertes> bollu: interesting side note:  hylo is not too useful on its own, but can be used as the underlying theory of list fusion
09:36:46 <bollu> ertes: go on, if you're free
09:36:59 <ertes> or rather *fusion*, because it applies to all recursive types
09:37:22 <athan> holy tamole thank you so much MarcelineVQ, that did the trick
09:38:21 <ertes> bollu: the basic idea is that you can show that a hylo can be implemented without ever actually producing the intermediate data structure
09:38:31 <bollu> ertes: interesting
09:38:52 <ertes> so you can go through a list/tree/whatever *semantically*, but have a tight loop or recursive procedure operationally
09:39:09 <bollu> hm
09:39:40 <bollu> ertes: so, "fusion" in this sense means exactly what? the ability to have an efficient implementation that does not build up the intermediate repr?
09:40:00 <ertes> bollu: yeah, get rid of intermediate data
09:40:05 <bollu> I see
09:40:09 <bollu> ertes: why is it called fusion?
09:40:22 <athan> anyone here know if it's possible to supply a cabal file... or stack.yaml in a haskell comment, for a truly literate 1 file haskell executable?
09:40:42 <ertes> bollu: because it generally fuses two separate passes into one, and that's what eliminates the need for intermediate data
09:40:58 <bollu> hm
09:41:08 <bollu> ertes: so, can I fuse n passes into one gigantic pass?
09:41:12 <ertes> bollu: that's why i generally recommend not to write list functions recursively…  you would lose that benefit =)
09:41:19 <bollu> I see
09:41:33 <ertes> bollu: if it fits a fusion rule, sure
09:41:43 <bollu> I see
09:42:56 <Zemyla> Hmm, would a sensible way to represent a turn-based game be with a phantom parameter?
09:43:25 <Zemyla> Like availableMoves :: Game p -> [Move p] and makeMove :: Game p -> Move p -> (forall q. Game q -> r) -> r?
09:43:54 <Zemyla> That way, you can't make an invalid move in the game?
09:44:20 <ertes> Zemyla: if you need that information on the type level, then sure…  but you probably also need a way to branch, so you may find the reflection library useful
09:44:27 <Jayce381> Should I think when I'am writing haskell in procedural way?
09:44:34 <Jayce381> line by line is executed?
09:44:37 <Zemyla> ertes: Why do I need a way to branch?
09:44:58 <Zemyla> Jayce381: You should always think when you're writing Haskell, whether it's in a procedural way or not.
09:45:04 <ertes> Zemyla: if 'q' encodes the remaining moves, then within the continuation you have lost all information about which moves are valid
09:45:10 <maerwald> Jayce381: huh... no. Unless you mean IO
09:45:21 <maerwald> (wrt line by line is executed)
09:45:31 <maerwald> or some special monad that gives a similar guarantee
09:46:15 <Zemyla> ertes: I was mainly thinking more along the lines of p just being phantom so you can't, like, save a move from an earlier boardstate and try and pass it to a later one.
09:46:38 <Zemyla> Doing type-level validation seems harder than just type-level "Choose from this list only".
09:46:46 <ertes> Zemyla: ah, i see…  this is a way to do it, yeah
09:47:45 <Zemyla> Actually, there should be a generic move representation, something like GMove, and availableMoves :: Game p -> Map GMove (Move p).
09:48:13 <Zemyla> So you don't have to search a giant list every time you believe you know what move you want to make.
09:48:45 <ertes> Zemyla: you may find the dependent-map library useful, which lets you choose the *type* of the map entry based on the value of the key
09:54:25 <ertes> Zemyla: imagine a game of tic-tac-toe:  data Move :: * -> * where Forfeit :: Move (); PlaceO :: Move (V2 Int); PlaceX :: Move (V2 Int)
09:54:48 <ertes> Zemyla: then (DMap Move Identity) is the type of "possible moves"…  if it has the Forfeit key, the player can forfeit
09:55:06 <ertes> if it has the PlaceO key, the player can place an O (together with a position)
09:57:47 <ertes> in order to close the gap between checking which moves are possible and actually moving you can even do this:  Forfeit :: Move (Game p); PlaceO :: Move (V2 Int -> Game p); PlaceX :: Move (V2 Int -> Game p)
09:58:01 <ertes> because of the rank-2 type only the proper player in the proper round can actually perform a move
09:58:17 <ertes> you can't accidentally pass a possible move from an earlier game state
10:02:59 <johnw> I wish I could have function-local imports, while a "where import" clause
10:03:02 <johnw> s/while/like
10:04:23 <bollu> could someone give me feedback on my tutorial writing? http://bollu.github.io/teleport/
10:04:33 <bollu> it's not super long
10:04:38 <bollu> I would appreciate on how to write better
10:05:24 <johnw> I didn't read through it in depth, but I liked the parts that I did read
10:05:38 <johnw> it's purposive, a good example, and pretty clear
10:06:07 <johnw> where you say "let jsonResult = JSON.eitherDecode' rawInput ; case jsonResult of", I wouldn't bother naming the intermediate value
10:06:32 <johnw> the formatting of the article gets a little hard to follow further down, with all the <hr> separators
10:06:52 <ertes> bollu: too many types =)
10:06:58 <johnw> i'd recommend using a style similar to what ocharles does for the 24 days of hackage
10:07:16 <bollu> ertes: xD
10:07:22 <bollu> ah, I see
10:07:33 <bollu> ertes: I was hoping that would help people and not hurt
10:07:41 <ertes> bollu: data Command = … | CommandAdd { _addName :: Text, _path :: FilePath } | …
10:07:44 <bollu> ertes: I tried to find a way to make them tooltips, but lhs is too brittle for that
10:07:52 <bollu> ertes: ah, fair
10:08:28 <bollu> johnw: how would you want me to split it?
10:08:55 <ertes> bollu: (disclaimer: it's a matter of taste, so if you prefer multiple types, go with it) =)
10:09:05 <bollu> ertes: right :)
10:09:15 <bollu> ertes: I was hoping that making the separate types would make it a little easier to follow
10:09:21 <bollu> ertes: but I think your style is nice
10:10:18 <bollu> johnw: I was hoping the <hr> would keep different sections from bleeding in
10:10:26 <bollu> johnw: how would you structure it?
10:11:11 <ertes> bollu: i found that indenting and perhaps outlining code helped…  see code samples in the foldr tutorial
10:11:58 <bollu> ertes: OK, lemme see
10:12:02 <bollu> ertes: thanks for the feedback BTW
10:12:07 <bollu> ertes: does it "read" OK?
10:12:35 <bollu> also, I found out that writing is super hard when doing this
10:12:54 <bollu> ertes: oh, you changed the CSS to have a border around the code
10:13:19 * JocoseJan is waiting to ask a question
10:14:46 <ertes> bollu: and a left margin (depending on viewport width)…  you have a "no bullshit" style of writing, which i personally like =)
10:14:49 <ertes> JocoseJan: just ask
10:15:24 <bollu> ertes: I see, thanks :D I'm glad you like the style at leasy
10:15:30 <JocoseJan> Thanks, ertes. Hi everybody. I'm a newbie from Lima, Perú, SouthAmérica. Please, I need help to compile lastest wxHaskell (FromGitHub) for Windows 8.1 and  wxWidgets 3.1.0. Help please! Thanks. Problems on 
10:15:59 <ysangkok> JocoseJan: your messages was truncated after "Problems on"
10:16:32 <ysangkok> JocoseJan: if you use irssi, you can use splitlong.pl
10:17:59 <JocoseJan> Sorry. I had forced "wxc\Setup.hs" wxCompatibleVersions = ["3.1", "3.0", "2.9"] -- Preferred version first but then there are errors on wxc\src\cpp\eljcursor.cpp, wxc\src\cpp\eljlog.cpp, wxc\src\cpp\extra.cpp, wxc\src\cpp\wrapper.cpp
10:18:45 <geekosaur> I think wx and wxc are known broken because the upgrade to wxwindows 0.9 made the haskell bindings non-maintainable :/
10:19:36 <JocoseJan> I'm forcing wxc\Setup.hs to wxwidgets "3.1" version ... but then there are some errors wxc\src\cpp\eljcursor.cpp, wxc\src\cpp\eljlog.cpp, wxc\src\cpp\extra.cpp, wxc\src\cpp\wrapper.cpp
10:21:17 <JocoseJan> I had Build wxWidgets 3.1.0 Ok. Now I'm tryng to Build wxHaskell from GitHub, but there are some errors.
10:21:46 <Phyx-> geekosaur: interesting, what happened there?
10:21:54 * geekosaur notes hackage says "no successful builds"
10:22:31 <geekosaur> I do not recall details, just a flurry of updates none of which fixed it and then the maintainer apparently giving up
10:22:39 <geekosaur> a couple years ago
10:23:21 <JocoseJan> Is there a way to compile wxHaskell for Windows 8.1 with wxWidgets 3.1.0 ?
10:23:30 <geekosaur> binding to C++ is always difficult unless a good `extern "C"` binding is available
10:24:18 <xenon-> is gtk still the goto gui library for haskell? what is status for Qt
10:24:31 <maerwald> I think they work equally bad
10:24:33 <mmaruseacph2> gtk also has a lens-based interface
10:24:53 <xenon-> mma cool, didn't know that
10:25:24 <ertes> there was a toolkit that had "easy to build on all supported platforms" as one of its primary goals
10:25:34 <mmaruseacph2> http://people.inf.elte.hu/divip/LGtk/LGtk.html
10:25:39 <mmaruseacph2> ertes: wxWidgets?
10:26:04 <ertes> this one: https://hackage.haskell.org/package/fltkhs
10:26:18 <mmaruseacph2> I managed some years ago to get all 3 (wxWidgets, Qt and Gtk) build on all 3 platforms (windows, mac, linux) but only the C version, not the haskell one
10:26:52 <geekosaur> last I heard there was an experimental QML/QtQuick binding (hsqml) and a non-building normal Qt binding
10:26:56 <geekosaur> hackage seems to agree
10:26:57 <maerwald> LGtk is outdated
10:26:59 <JocoseJan> I had build wxWidgets succefully for Windows 8.1 , now my problem is build wxHaskell :(
10:27:07 <ertes> JocoseJan: if you have choice, maybe try that one
10:27:55 <geekosaur> gtk2hs is still a bear to build but currently the best working GUI binding
10:28:15 <johnw> geekosaur: I wonder if it even builds on Nix today...
10:28:21 <johnw> oh yes, it does
10:28:29 <JocoseJan> So you suggests to try gtk2hs?
10:28:30 <johnw> the only thing I need it for: threadscope
10:28:54 <maerwald> gtk sucks, if you don't hate Qt (like I do), you should check out Qt
10:29:45 <maerwald> the treeview alone is a mess and lacking fundamental features, now they start removing support for trayicon, support for iconlists...
10:29:48 <ertes> JocoseJan: there have been a few suggestions, but at least gtk2hs has a lot of momentum as a project
10:29:50 <mmaruseacph2> Qt sucks, if you don't hate Gtk (like I do), you should check out Gtk
10:29:51 <mmaruseacph2> :P
10:30:10 <mmaruseacph2> but yes, I agree with maerwald on the second line
10:30:27 * geekosaur generally thinks gtk has no future, because the gtk folks have explicitly stated they only care about it working with gnome
10:30:34 <maerwald> yes
10:30:45 <johnw> well, it is Gtk after all
10:30:47 <maerwald> I can't say my opinion on gtk upstream out loud in this channel
10:31:06 * mmaruseacph2 agrees with geekosaur 
10:31:17 <JocoseJan> I would like to work with xwHaskell
10:31:20 <johnw> gtkosaur
10:31:21 <mmaruseacph2> on the other hand, my main computer is running gnome
10:31:43 <maerwald> johnw: a dev responded on a transmission bug report afair: "Sorry, I don't know what xfce is"... basically mocking half the user base, while happily breaking other use cases
10:31:48 <maerwald> *gtk dev
10:33:16 <ertes> there is a slim change that they really didn't know what xfce is =)
10:33:17 <geekosaur> JocoseJan, at this point the only way you will be able to work with it is to take the package over and fix it. Sorry
10:33:19 <ertes> chance
10:33:37 <geekosaur> the former maintainer gave up on it some time ago
10:34:59 <JocoseJan> Thanks, geekosaur. Thanks everybody. I'll try it (please, wish me good luck)
10:35:10 <sm> good luck JocoseJan 
10:35:16 <ertes> has anyone tried fltkhs?  i liked the presentation of the initial author, but of course it doesn't have the huge predefined widget set that more established solutions like GTK and Qt have
10:35:52 <ertes> the GTK/gnome thing is weird…  are they going to drop windows support, too?
10:36:11 <maerwald> ertes: like the biggest non-gnome consumer of gtk?
10:36:17 <maerwald> yeah, surely...
10:36:23 <sm> ertes: I haven't, but I think FLTK is actually older than those others and there's a large number of widgets available
10:36:46 <sm> also it appears relatively easy to make new ones
10:36:48 <ertes> sm: hmm, i see…  then maybe the binding is just still a work in progress
10:37:21 <sm> deech made a post about it
10:38:44 <ertes> the project grew since i last looked at it…  nice =)
10:38:57 <sm> the only obvious downside is its non-native look & feel
10:38:59 <ertes> and it seems a *lot* more complete now
10:39:15 <ertes> windows changes its native look with every release anyway, so who cares
10:39:28 <ertes> as long as you can still make out what a button is =)
10:39:33 <sm> :)
10:42:00 <ertes> if you really want look/feel consistency across the board there is only one OS:  emacs =)
10:42:16 <bollu> ertes: electron ;)
10:42:22 <sm> squeak & pharo
10:42:50 <sm> and java I suppose
10:43:27 <sm> speaking of which, it's supposed to be possible to use java for GUIs now (inline-java ?)
10:44:07 <ertes> sm: no, it's not possible!
10:45:03 * geekosaur considers snark about threepenny-gui
10:45:17 <cocreature> sm: whether that’s a good thing is debatable :)
10:46:07 <ertes> it's not debatable…  repeat after me: it's IMPOSSIBLE!  don't even consider a parallel universe where this might be possible
10:46:37 <sm> ertes: but there's an example right here.. http://hackage.haskell.org/package/inline-java
10:46:48 <ertes> sm: no, there is not…  it's just pseudo-code
10:47:18 <vansu> I am a beginner to Haskell, I am having a lot of trouble setting up my development environment.
10:47:52 <cocreature> ertes: keep telling you that until you start writing haskell in an editor written in java :P
10:48:28 <bollu> ertes: better now? index.html
10:48:31 <bollu> >_<
10:48:35 <sm> indeed, I mean, there is at least one extremely good app written in java: intellij
10:48:40 <vansu> I have installed stack, done stack upgrade --git, stack setup, stack path and stack exec ghci which work
10:48:47 <bollu> ertes, johnw: better now?
10:48:48 <bollu> http://bollu.github.io/teleport/
10:48:52 <ertes> cocreature: i can't even picture that, or it would look goofy like eating an anvil or something =)
10:48:55 <bollu> I was hoping for some review on the tutorial I wrote: http://bollu.github.io/teleport/
10:49:04 <sm> vansu: how about https://www.reddit.com/r/haskell/comments/5izxxc/setting_up_a_haskell_development_environment/
10:49:31 <cocreature> vansu: what’s the part that is not working? :)
10:49:35 <vansu> I find that stack ghci, stack install hdevtools, stack install ghc-mod, stack install hlint and stack install ghc-mod hlint throw an error
10:49:36 <sjpet> Hello folks, I have a style question if someone would be so kind as to indulge me. What is the view on incomplete guard constructs. I have a fuction declared 9 times with various pattern matches. Each of these have guards that invariably end with the same "otherwise" clause. Is it considered poor form to skip these and put a single "myFunction _ _ = ..." at the bottom? Or is there some other stylish way to
10:49:38 <sjpet> handle situations like this?
10:49:54 <vansu> Using resolver: lts-7.14 from implicit global project's config file: /home/vamsi/.stack/global-project/stack.yaml Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
10:49:58 <cocreature> vansu: 1. you probably don’t want hdevtools and ghc-mod, they do similar things
10:50:00 <ertes> bollu: better, though you have two code styles there, and you're only applying it to one of them…  if you're using pandoc pay attention to which style you're using
10:50:19 <ertes> bollu: --indented-code-classes can make this more convenient, but also slightly more confusing
10:50:33 <bollu> ertes: what is the second style you are referring to?
10:50:45 <kadoban> sjpet: I don't see why that'd be poor form
10:50:52 <vansu> ok, but neither of them installs
10:50:56 <ertes> bollu: search for "by default, current working directory is used"
10:51:19 <vansu> so how can I get at least one of them to install??
10:51:35 <bollu> ertes: ah
10:51:37 <lyxia> sjpet: it's a fine alternative to multiple "otherwise" guards.
10:51:48 <cocreature> vansu: sorry, I’ve never seen that error before
10:52:00 <cocreature> vansu: is there any other output?
10:52:43 <bollu> ertes: where do I send the flag to? GHC?
10:53:00 <ertes> sm: (i was just joking of course, but i'll use all my potential to control java growth) =)
10:53:19 <ertes> bollu: i don't know how you're creating the page
10:53:23 <MarcelineVQ> vansu: that's an error you'd sometimes see with an old stack version but you've said you updated so I'm not sure what it could be, what does stack --version say?
10:53:38 <johnw> bollu: it is better, but perhaps there's still "too much code"; but I'm not sure, I can't read it with beginner's mind anymore
10:53:55 <bollu> I see
10:54:02 <bollu> johnw: so how do you recommend I do this?
10:54:14 <johnw> ask some beginners for their opinions :)
10:54:17 <vansu> @cocreature Version 0.1.10.0 x86_64
10:54:18 <lambdabot> Unknown command, try @list
10:54:34 <bollu> johnw: where do I find beginners to ask ?
10:54:36 <MarcelineVQ> I see so it's using your old version instead of the updated one, try adding the folder in your home directory /home/myuser/.stack/bin to the front of your $PATH
10:54:46 <johnw> bollu: #haskell-beginners, maybe, or #nothaskell?
10:54:53 <bollu> ah
10:54:55 <bollu> ty
10:54:55 <MarcelineVQ> er sorry it's .local/bin
10:55:28 <ertes> bollu: i'd say your text is not for complete beginners…  if you want to learn more you should understand what assumptions about the reader's competence you're making
10:55:44 <bollu> ertes: right. I would call it as "intermediate people"?
10:55:57 <bollu> ertes: perhaps "beginner" was the wrong choice of the word
10:56:05 <haskell819> Hello, I'm Haskell newbie and I'm stuck with simple authentication program (code fragment here http://lpaste.net/2106471215743893504). Should I use lift* or something (and how)? Thank you.
10:56:08 <ertes> bollu: not sure if there is a totally ordered set of competence classes
10:56:38 <bollu> yes, I was targeting people who know functor, applcaitve, monad, (maybe) foldable, but can't "put things together"
10:56:47 <sm> vansu: also, "type -a stack" may show what stack binaries are in PATH
10:56:56 <ertes> bollu: one option is just to be explicit about your assumptions
10:57:08 <bollu> ertes: I see, let me do that at the top then
10:57:45 <sm> hmm, what provides "C library: jvm" on osx
10:57:57 <mmaruseacph2> 13:44  * geekosaur considers snark about threepenny-gui <--- what about it?
10:58:12 <bollu> erteis —indented-code-classes for pandoc?
10:58:12 <geekosaur> runs in the browser, not on the desktop
10:58:22 <bollu> ertes: is* —indented-code-classes for pandoc?
10:58:25 <ertes> bollu: yeah
10:58:34 <bollu> I see
10:58:59 <ertes> bollu: but i don't know if that applies to you, as i don't know how your website is produced =)
10:59:31 <vansu> I added export PATH="$HOME/.stack/bin:$PATH" to my zshrc
10:59:39 <vansu> still shows me the same version.
10:59:41 <MarcelineVQ> .local/bin
10:59:51 <bollu> ertes: I create it out of a .lhs file
10:59:59 <mmaruseacph2> geekosaur: ah, that, yes
11:00:23 <mmaruseacph2> vansu: open a new terminal
11:00:49 <geekosaur> vansu, did you also run that in your open shells?
11:01:03 <geekosaur> they don't automatically reread .zshrc
11:01:57 <MarcelineVQ> vansu: stack places the executables it makes from stack install or stack upgrade in .local/bin which is why that needs to be at the front of your $PATH
11:02:05 <vansu> still the same error @geekosaur
11:02:18 <sm> "which stack"
11:03:02 <sm> I should say: $ which stack
11:04:35 <vansu> which stack says /usr/bin/stack while echo $PATH says /home/vamsi/.stack/bin:/home/vamsi/.rbenv/plugins/ruby-build/bin:/home/vamsi/.rbenv/bin:/home/vamsi/.nvm/v6.2.0/bin:/home/vamsi/.rbenv/shims:/home/vamsi/.rbenv/bin:/usr/local/bin:/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
11:04:47 <MarcelineVQ> .local/bin
11:05:16 <sm> vansu: you missed MarcelineVQ's corrections. It should be .local, .stack
11:05:20 <sm> .local, not .stack
11:06:44 <vansu> stack version 1.3.1
11:06:59 <sm> much better. How does that one work
11:07:08 <vansu> seems to be installing
11:07:15 <vansu> hlint and ghc-mod
11:07:39 <Soldalma> JOIN #JULIA
11:07:43 <sm> this path thing trips up a lot of people
11:12:00 <bollu> ertes: I had written an "intended audience", but I assume it wasn't clear enough
11:12:09 <bollu> ertes: I made it a lot more obvious now
11:12:18 <bollu> ertes, johnw: it's not too "trivial", right?
11:12:22 <bollu> I was worried that it might be
11:12:41 <johnw> bollu: I didn't think so
11:13:06 <bollu> johnw: okay, ty
11:27:02 <Zef> Hey folks! I'm having a bit of trouble lining my types up and I'm wondering if you can help me out, should be pretty simple.
11:27:12 <Zef> I've got the following types:
11:27:16 <Zef> MonadState a m => m
11:27:19 <Zef> l :: Lens' a [b]
11:27:22 <Zef> f :: b -> m c
11:27:32 <Zef> I want to end up with: m [c]
11:27:52 <Zef> I'm trying something like this right now: get >>= mapMOf l f
11:28:08 <Zef> Doesn't line up :P Anyone have ideas?
11:29:14 <Zef> This works: use l >>= mapM f
11:29:26 <Zef> Is there a way I can express that in a single statement?
11:29:35 <fosskers> do you need to be using lenses here?
11:29:54 <Zef> Yeah, I'm working in a pretty deep nested state
11:29:57 <fosskers> seems like straight composition of vanilla things does what you need
11:30:04 <sm> dang, aoc 11 is refusing to surrender
11:30:39 <Zef> It's working with use l >>= mapM f, just wondering if I can express that in a single monadic action using lens :)
11:32:17 <ezyang> Yet another use-case for Backpack: Alex parsers 
11:32:17 <Gurkenglas> As far as I know, the only lens thing that allows you to combine two monadic actions is <~
11:35:48 <hodapp> I need to read about Backpack
11:36:49 <Zef> Hrmm, k thanks @Gurkenglas @fosskers
11:38:42 <sm> ha! I see a big problem! Rubber Duck debugging is magic!
11:39:12 <sm> my issolved function expected all floors to be clear of items. No wonder it found no solutions.
11:39:28 <c_wraith> software development is trivial for rubber ducks. 
11:39:39 <mmaruseacph2> no spoilers, sm :)
11:39:50 * mmaruseacph2 is still late on doing the AoC :(
11:41:02 <theamytran> Hey all! I'm having trouble using HUnit with Stack. I'm getting this error: Failed to load interface for ‘Test.HUnit’
11:41:28 <mmaruseacph2> theamytran: add it to the cabal file
11:41:40 <theamytran> mmaruseacph2: what do I add?
11:41:51 <theamytran> "base" is already in there
11:42:19 <mmaruseacph2> tasty-hunit
11:42:24 <mmaruseacph2> and tasty, I think
11:42:26 <theamytran> oh
11:42:28 <theamytran> weird lol
11:42:32 <theamytran> what a weird name
11:42:39 <mmaruseacph2> actually, no, HUnit
11:43:05 <mmaruseacph2> tasty is better for testing as it allows you to have HUnit and QuickCheck in the same test tree
11:43:13 <sm> mmaruseacph2: right you are, no spoilers
11:43:14 <theamytran> what should I use for testing?
11:43:18 <theamytran> tasty?
11:43:26 <theamytran> what do most people use?
11:43:27 <mmaruseacph2> theamytran: this seems to be the consensus
11:43:31 <theamytran> Ok
11:43:32 <mmaruseacph2> (this = tasty)
11:43:42 <sm> theamytran: doctest
11:43:59 <mmaruseacph2> for stack, try stack new name tasty-travis
11:44:07 <mmaruseacph2> where you can replace name with whatever you want
11:44:24 <mmaruseacph2> has tasty (HUnit, QuickCheck and doctests) and travis integration ready
11:44:33 <theamytran> tasty-travis
11:44:36 <theamytran> that sounds kinda weird lol
11:44:38 <theamytran> But ok
11:45:01 <mmaruseacph2> tasty-travis is the name of the template, it's Tasty and Travis :P
11:45:19 <theamytran> Whose idea was it to name this thing tasty haha
11:45:27 <theamytran> i feel violated
11:45:37 <Tuplanolla> We have plenty of good names here.
11:45:50 <Tuplanolla> @hackage gooey
11:45:50 <lambdabot> http://hackage.haskell.org/package/gooey
11:46:32 <mmaruseacph2> that's a cool one
11:47:27 <mmaruseacph2> but seems incomplete
11:47:54 <theamytran> okay I'm going to just use HUnit for now
11:48:00 <theamytran> I'll use tasty when i get... er... tastier
12:16:16 <niez> hi, I'm looking for a function with type Maybe (Maybe a, Maybe b) -> Maybe (a, b), hayoo and hoogle aren't helpful here
12:21:12 <johnw> :t \x -> (,) <$> (x >>= fst) <*> (x >>= snd)
12:21:13 <lambdabot> Monad m => m (m a1, m a) -> m (a1, a)
12:21:26 <johnw> i don't think that's pre-defined anywhere
12:26:12 <niez> johnw, thanks
12:26:57 <kazagistar> I would prefer the do notation version, but applicative is readable enough
12:29:29 <kazagistar> Or just the specific version, where you match on both Justs
12:32:04 <Gurkenglas> :t (>>= (liftA2 . liftA2) (,) fst snd)
12:32:06 <lambdabot> Monad m => m (m a, m b) -> m (a, b)
12:34:31 <Akii> the only question I have is this: is it considered "bad" when you end up with Maybe (Maybe a, Maybe b)
12:34:47 <c_wraith> it is a type I would be suspicious of. 
12:34:52 <sm> yes. Eh, no. I feel unsure
12:34:57 <Akii> thank_you.gif
12:35:00 <c_wraith> it's not necessarily bad. 
12:35:19 <c_wraith> but I'd want to think about why it has that much nesting. 
12:36:05 * Akii is just accumulating intuition
12:38:30 <Akii> suspicious is the perfect description I think
12:38:40 <Liskni_si> :t (>>= uncurry (liftA2 (,)))
12:38:41 <lambdabot> Monad m => m (m a, m b) -> m (a, b)
12:39:33 <Akii> anyone can come up with a lens for that?
12:41:23 <Akii> guess it's time to watch another random talk from edward
12:44:52 <o`connor> johnw: can you add pipes-files to stackage.org?
12:46:27 <crobbins> is there a name for the a data structure like ([a], a, [a]) ? basically, it's a list with a "focus"
12:46:44 <ezyang> zipper 
12:47:19 <crobbins> there we go
12:47:24 <crobbins> thanks ezyang!
12:47:27 <niez> Akii, I have something like that: http://lpaste.net/350241, and I'm trying to chain Maybe's with do notation
12:48:07 <Akii> woah
12:48:07 <Gurkenglas> niez, you want MaybeT
12:48:31 <niez> hm
12:48:44 <crobbins> hmm, it seems like zipper is more like ([a], [a])
12:49:31 <sm> I tried to derive Arbitrary using DeriveAnyClass, but GHC warns and quickcheck gives an error. Is it not possible to derive ?
12:49:33 <crobbins> or maybe not, from looking at other implementations
12:49:55 <johnw> o`connor: what does that entail?
12:50:05 <glguy> sm: DeriveAnyClass doesn't mean "magically materialize a definition for me"
12:50:39 <glguy> sm: It just means "let me put arbitrary stuff into the deriving clause instead of writing separate instances and don't write any methods for them)
12:50:55 <sm> hmm, thank you
12:51:23 <lpaste> Gurkenglas annotated “No title” with “niez, have an annotation. You probably also want to pull all of runCmd into that” at http://lpaste.net/350241#a350242
12:53:35 <Akii> nice idea
12:53:38 <o`connor> johnw: I'm not actually sure, but I was reading this: https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
12:53:40 <sm> now I discover http://hackage.haskell.org/package/derive and wonder where this fits in
12:53:45 <o`connor> and got to the part where it says "you should drop the package maintainer a note first"
12:54:05 <sm> also, my real question is how to generate arbitrary values of a sum type
12:54:21 <c_wraith> there needs to be a way to specify constraints in automatic instances more succinctly than using StandaloneDeriving 
12:54:51 <o`connor> johnw: it looks like the next bit is "After doing that, send a pull request"
12:55:33 <codedmart> I seem to have been relying on generic to much? I can't remember how to write a FromJSON where I could have `data SomeType = Address SomeAddress | OtherThing SomeThing` and I want `{"address"...}` -> `Address` and `{"otherThing"...}` -> `OtherThing`.
12:56:04 <sm> I guess I can pick a random element from a list of constructors. It seems like there must be a convenience for this already
12:56:33 <onintza> What do you think is the best data structure for a list bounded in length [0..2]?
12:57:21 <codedmart> Wait I am being dumb.
12:57:25 <codedmart> Now I rememeber.
12:58:07 * sm wonders where the easy "pick a random list element" API can be found
12:58:31 <lpaste> Gurkenglas annotated “No title” with “niez, *looks at Haskeline* this should work” at http://lpaste.net/350241#a350243
12:59:02 <Gurkenglas> sm, http://hackage.haskell.org/package/MonadRandom-0.4.2.3/docs/Control-Monad-Random.html#v:uniform
12:59:30 <codedmart> Brain farted for a minute.
13:00:05 <mmaruseacph2> sm: https://byorgey.wordpress.com/2016/03/23/boltzmann-sampling-for-generic-arbitrary-instances/
13:00:26 <mmaruseacph2> now it's on a hackage package
13:00:39 <mmaruseacph2> but I don't recall the name
13:01:31 <mmaruseacph2> there's https://hackage.haskell.org/package/quickcheck-arbitrary-adt but not the one I was thinking of
13:01:43 <sm> thanks both. I see, MonadRandom is a higher level api using random
13:02:17 <Gurkenglas> Wait, looks like InputT doesn't lift underlying Alternative instances. niez, one would have to write that orphan instance for that last annotation to work :/
13:02:31 <mmaruseacph2> sm: this one: http://hackage.haskell.org/package/generic-random
13:02:35 <sm> should I be messing around with random just to quickcheck my custom sum types ?
13:03:24 <sm> oh generic-random has a very relevant-looking example
13:03:54 <glguy> sm: The QuickCheck package itself has lots of helper functions in Test.QuickCheck.Gen
13:03:59 <glguy> and other modules
13:05:04 <lpaste> Gurkenglas revised “niez, *looks at Haskeline* this should work”: “niez, I guess manual lifting can do it as well but that's not gonna be pretty once you add more monad transformers in between there.” at http://lpaste.net/350243
13:05:12 <sm> glguy: thanks, I had not checked all of the modules
13:06:01 <sm> still, do you happen to know how to generate arbitrary sum type values ?
13:06:21 <sm> I don't see that, or any official doc explaining it
13:07:23 <johnw> o`connor: I'm happy to accept such a pull request; I have no objection to it being on stackage
13:08:13 <o`connor> johnw: ok, cool
13:09:14 <niez> Gurkenglas, many thanks
13:09:45 * sm gives smallcheck a try
13:15:31 <theamytran> What's the best arg parsing library?
13:16:10 <MarcelineVQ> I really quite enjoyed using https://hackage.haskell.org/package/optparse-applicative
13:16:58 <mtjmullen> I also enjoy optparse-applicative
13:17:50 <Gurkenglas> Oh, haskeline doesn't lift instances because it doesn't depend on transformers because if it did ghc would because ghc depends on haskeline?
13:19:11 <niez> theamytran, you can try optparse-generic
13:23:19 <Gurkenglas> (Another point for local dependencies https://github.com/aelve/haskell-issues/issues/47#issuecomment-268363052 )
13:30:49 <lyxia> sm: I wrote generic-random!
13:32:42 <lyxia> sm: the easiest is to put all alternatives in a list and use oneof
13:33:42 <lyxia> sm: oneof [Left <$> arbitrary, Right <$> arbitrary] :: (Arbitrary a, Arbitrary b) => Gen (Either a b)
13:36:27 <mmaruseacph2> optparse-generic? I have always used optparse-applicative
13:36:34 <mmaruseacph2> lyxia: cool :D
13:39:40 <orion> What is the canonical way of converting a String to a type of the exact same name?
13:40:35 <glguy> Anyone know if there's a way using gi-gtk to load an object from a glade builder and cast it to the correct type all in one shot?
13:40:47 <glguy> Do I need to use #getObject and castTo each time?
13:41:38 <sm> lyxia: nice! thank you
13:41:40 <mmaruseacph2> glguy: afaik yes. That's why I tend(ed) to write my gtk form by hand
13:42:19 <sm> aside, I can see why quickcheck & friends aren't used routinely. It's hard to get going
13:43:33 <glguy> mmaruseacph2: It's definitely not enough to drive me to want to use hand-constructed forms. I can bundle up the two-steps into one. I'm just trying to see how to use this
13:44:28 <mmaruseacph2> sm: not really, I just stack ghci and import QuickCheck to test random stuff within it
13:45:15 <kazagistar> orion: What if there are multiple types available? Do you want the compiler to somehow remember the names all the types visible at the call location? Are you trying to write macros maybe?
13:45:36 <hexagoxel> how does gi-gtk relate to gtk/gtk3?
13:45:48 <sm> mmaruseacph2: sum types ?
13:46:01 <glguy> hexagoxel: It's a binding
13:46:37 <mmaruseacph2> sm: well, no, simple times
13:46:40 <mmaruseacph2> *types
13:47:11 <sm> right, I mean it's not used routinely in real-world haskell projects
13:47:27 <sm> which is a pity
13:48:22 <mmaruseacph2> it is, afaik
13:48:26 <orion> kazagistar: I have a JSON file where one item within an object is a string representation of a Haskell type.
13:48:46 <glguy> sm: It's not hard to write arbitrary generators for sum types
13:49:01 <glguy> or at least not harder than any other kinds of types
13:49:14 <orion> I want to convert that string to a Type for the purpose of creating a parameterized datatype.
13:49:50 <geekosaur> you can make a TypeRep. Types themselves are not runtime values
13:50:01 <sm> I expect it's easy, my point is it's hard for a newcomer to discover how
13:51:13 <orion> Ed Kmett told me I could refactor all of this: https://github.com/centromere/cacophony/blob/master/tests/vectors/Types.hs
13:51:23 <kazagistar> orion: it feels like an xy problem. There isn't much useful that you can do with a type at runtime. Are you trying to deserialize a json type into one of many types?
13:51:27 <orion> He said I didn't need to use GADTs at all. I could use TypeReps.
13:51:55 <orion> (If I remember correctly, that's what he said)
13:56:01 <lyxia> you can kinda lift a string to type level with GHC.TypeLits.someSymbolVal
13:59:04 <lyxia> No idea how to structure a program around that though
14:16:27 <lpaste> glguy pasted “automatically populating from a builder” at http://lpaste.net/350247
14:16:42 <glguy> mmaruseacph2: This is what I have so far for automating loading from builders
14:17:32 <glguy> It let's me automatically populate a record as long as the record's field names and types match the glade file
14:17:37 <mmaruseacph2> glguy: sounds cool
14:17:46 <mmaruseacph2> make it a hackage package afterwards :D
14:30:43 <c_wraith> lyxia, you have to structure the program around the string being known at compile time, then sneak it in dynamically at the outermost layer. 
15:12:11 <mmaruseacph2> can optparse-generic also generate short flags?
15:28:01 <mmaruseacph2> answer: no (or not easily)
15:56:52 <isovector> i'm looking for some lensy `foo` such that `foo _Left 5 $ Right "ok"` = `Left 5`
15:57:39 <isovector> it's almost `set` except i want it to change the sum type
16:01:06 <dfeuer> isovector, and what would foo _Left 5 $ Left 3 be?
16:01:29 <isovector> ddfeuer: `Left 5`
16:01:46 <dfeuer> So it totally ignores the rest of its argument?
16:01:48 <isovector> dfeuer: ^ too many d's, sorry
16:02:04 <mckeankylej> If you define natural numbers with data Nat = S | S Nat how do you go from a KnownNat n to Nat? I want to take advatage of the type literal syntax but I cant figure out how to go from a type lit to an inductive nat
16:02:35 <dfeuer> mckeankylej, last I checked, KnownNat was oddly tied up to Integer.
16:02:38 <isovector> dfeuer: yeah. essentially `const` but over something lenslike
16:02:47 <dfeuer> isovector, what's wrong with const?
16:02:54 <EvanR> natVal :: forall n proxy. KnownNat n => proxy n -> Integer
16:03:08 <isovector> the actual sum type i want to change is deep in a structure
16:03:25 <EvanR> then you can convert Integer into a Nat
16:03:50 <mckeankylej> EvanR: but I really need a function fromKnownNat :: (KnownNat n) => SNat n where SNat is a singleton natural I defined
16:04:04 <mckeankylej> going to an int would kill the type info
16:04:21 <EvanR> KnownNat is already this thing
16:04:26 <EvanR> type level nat
16:04:54 <mckeankylej> EvanR: but that Nat isnt defined inductively
16:05:02 <EvanR> it sounds like you need a instance with a => in it, not a function
16:05:28 <mckeankylej> EvanR: sorry do you mean make an instance of knownNat
16:05:47 <dfeuer> mckeankylej, type family toNat n where toNat 0 = 'Z; toNat n = 'S (toNat (n - 1))
16:05:50 <EvanR> you said data Nat = Z | S Nat
16:06:06 <mckeankylej> dfeuer: thats it!
16:06:16 <dfeuer> Then you can write  class RealKnownNat n where knownRealNat :: SNat n
16:06:32 <mckeankylej> thanks guys #haskell is the best
16:06:42 <EvanR> failed again
16:06:53 <dfeuer> ?
16:07:25 <EvanR> im getting worse at seeing what the real question is
16:08:26 <mckeankylej> EvanR: dont worry I am pretty terrible at explaing things. Also irc is a group effort
16:29:30 <dmwit> isovector: Just use a lens to the sum type...?
16:30:21 <dmwit> > set _1 (Left 3) (Right "ok", True)
16:30:23 <lambdabot>  (Left 3,True)
16:30:30 <dmwit> > set _1 (Left 3) (Left 5, True)
16:30:36 <lambdabot>  (Left 3,True)
16:39:47 <dfeuer> Ping bitemyapp 
16:50:37 <cdsmith> Any hints on debugging why GHC takes a long time?  Can I get timing for each stage of a compile, or a log of actions with timestamps, or something like that?
16:52:22 <hodapp> Hmmmm, I suppose one place to start is with verbose outputs
16:52:52 <cdsmith> How would I do that?
16:53:33 <cdsmith> Is that just -v3?
16:56:36 <mmaruseacph2> yep, -v3 should give a verbose output
16:56:52 <mmaruseacph2> you can also try getting the compiler to dump the files after each stage
16:57:16 <cdsmith> Ah!  It does indeed, but also causes a segmentation fault. :)
16:59:15 <cdsmith> Wait, never mind.  The seg fault happens anyway.  It didn't with 7.10
16:59:31 <cdsmith> Probably a GHCJS thing!
17:07:40 <lpaste> cdsmith pasted “GHCJS verbose output from failing compile” at http://lpaste.net/350260
17:08:13 <cdsmith> If anyone wants to take a look, that's what I see.  Might be GHCJS, but then again, It looks like it's crashing before it gets to STG?
17:09:50 <c_wraith> demand analysis is before ghcjs takes over, but ghcjs is still affecting things at that point.. 
17:10:05 <c_wraith> it has its own version of all the wired in libs
17:10:19 <c_wraith> which definitely could affect demand analysis 
17:12:16 <cdsmith> I suspect it's a failed allocation that's not handled.  This builds with a GHCJS based on GHC 7.10, but takes about 7 minutes to compile 30 lines of code.  With GHC 8.0.1, it dies with the segfault.
17:15:28 <cdsmith> c_wraith: Thanks.  I'm off to look up what demand analysis is. :)
17:22:27 <codedmart> OK having a hard time with this. https://gist.github.com/codedmart/27ddeea0c76c89a3d59f02879b946f5b#file-easyposttypes-hs-L28-L40
17:23:04 <codedmart> I can have flat objects come back `{...}` or wrapped with the key `{"address":...}`.
17:23:35 <codedmart> This compiles but when parsing an address it parses as a `Shipment`.
17:24:03 <codedmart> I am sure I am overcomplicating or missing something,
17:27:19 <cdsmith> codedmart: If it's a flat object, how to expect to tell whether it's a shipment or an address.  Looks like (Shipment <$> parseJSON ep) will always succeed.
17:28:05 <codedmart> cdsmith: So should I not have the top level EasyPost type?
17:28:49 <codedmart> cdsmith: Can I just parse at EPAddress the flat object or `address` key while still using the generic options I am using now?
17:31:26 <cdsmith> codedmart: If you know it's an address, I suppose I would try to parse it as an EPAddress.  But I don't know your domain as well as you.
17:36:45 <codedmart> cdsmith: I guess I am unsure how to write my FromJSON instance for EPAddress to parse either the flat object or the key `address` and still use the same func I am using with generic. Been using generic to much and have forgot.
17:41:35 <kadoban> Is there an existing type somewhere I'm not thinking of that has the property that  compare a b == EQ, but a and b can be differentiated nonetheless? I'm trying to quickcheck a data structure implementation for something like stability of ordering.
17:41:53 <kadoban> I can just write one of course, but thought there might be one around I can just use for testing.
17:48:18 <kadoban> Yaaa, I'll just write one, nm.
17:49:10 <cdsmith> codedmart: Sorry, I'm a little unfamiliar with aeson.  Let me poke a bit and clarify some things.
17:50:21 <codedmart> cdsmith: no worries I can try again in a bit. Thanks for your help.
17:50:41 <cdsmith> codedmart: I think it may be as simple as changing the order of your alternatives.  The problem is that since there are no required fields in Shipment, parsing any object as a flat Shipment always succeeds.
17:50:57 <cdsmith> codedmart: Hence why I asked what logic you want to use to distinguish.
17:51:58 <cdsmith> codedmart: If you want to parse anything with an 'address' field as an address, and so on, then try moving those alternatives up ahead of the flat object choices.  But, you'll still have to specify how to tell the difference between a flat Address, and a flat Shipment.
18:56:36 <lpaste> slack1256 pasted “alternatives to threading IORef” at http://lpaste.net/350263
18:57:04 <slack1256> I am starting in GUI programming. What are my alternatives to threading state manually by IORef to events?
18:57:52 <slack1256> I would do a eventloop, but GTK already does the eventloop
18:59:15 <c_wraith> slack1256, have you read the reinversion of control blog post? 
18:59:31 <slack1256> no, I've only heard about that term
18:59:42 <c_wraith> slack1256, http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
19:00:54 <EvanR> "immediate mode gui" is pretty inspiring
19:01:17 <c_wraith> it's glut. that's what it gives you. :) 
19:03:02 <c_wraith> slack1256, the main idea is that you can use ContT to make callbacks read as straight line code. 
19:03:03 <slack1256> EvanR: "inmediate mode gui" is blogpost or paper?
19:03:31 <slack1256> c_wraith: yeah, it seems to fit well.
19:03:38 <EvanR> its this thing edk mentioned, and exists as code in C++ https://github.com/ocornut/imgui
19:03:45 <c_wraith> slack1256, the modern approach would use Codensity instead of ContT, as it works out to be a bit more type safe. 
19:06:00 <slack1256> haha, he explicitly mentions avoiding IORef with this style
19:36:16 <xcmw> Does anyone know how to combine two record in vinyl? Rec s ['X, 'Y] ++ Rec s ['Y, 'Z] = Rec s ['X, 'Y, 'Z] I tried using the <+> operator but then I get repeated fields in the type ['X, 'Y, 'Y, 'Z]
19:36:55 <lilred> xcmw: so basically a join? (no idea)
19:43:13 <byorgey> xcmw: you might be able to build something like that using the subset/slicing stuff in Data.Vinyl.Lens
19:43:18 <byorgey> but I'm not really familiar with vinyl
20:14:38 <vozz> How can I use a streaming library to stream new lines appended to a file, rather than every new line in a file? I don't want it to stream existing content in a file when it starts, but only lines that are added after it is already streaming.
20:18:53 <EvanR> pipe tail -F into your program ;)
20:19:17 <EvanR> you can also monitor the file with file system notifications
21:22:55 <mpcsh> hey guys, I'm completely new to haskell but I have good experience with scheme. I have a question about ghc: does it produce compiled binaries, or does it "feel" like an interpreter?
21:24:39 <EvanR> it produces compiled binaries, theres also an interactive interpreter ghci
21:26:06 <mpcsh> EvanR: I was hoping for binaries. So from the CLI standpoint, it's like GCC? I just get an executable file that I can call from the shell?
21:26:17 <EvanR> yes
21:26:48 <mpcsh> EvanR: lovely, thanks! Thinking of writing a little helper for my dotfiles in haskell. is I/O easy to handle in haskell?
21:27:12 <EvanR> yes
21:27:48 <EvanR> :t readFile
21:27:50 <lambdabot> FilePath -> IO String
21:28:07 <EvanR> how much easier could it be? ;)
21:28:27 <jle`> haskell is my favorite language for IO :)
21:28:27 <mpcsh> EvanR: ooh, neat. I'm unfamiliar with haskell types, is "IO String" just a byte stream?
21:28:48 <EvanR> its an action which returns a String when executed
21:29:18 <mpcsh> EvanR: hrm, how are strings represented in haskell?
21:29:24 <EvanR> you use it by combining it with a String -> IO Whatever
21:29:26 <EvanR> and so on
21:29:36 <EvanR> String = [Char]
21:29:40 <monochrom> To many people, FilePath -> String is even easier
21:29:43 <jle`> mpcsh: in Haskell, you "describe" IO actions, as if it were a data structure, with convenient higher-order functions and combinators
21:30:04 <jle`> so an 'IO String' is the type of an IO action that would produce a string
21:30:41 <monochrom> each Char is a unicode codepoint, so you are totally not looking at bytes
21:30:59 <jle`> 'FilePath -> IO String' is a function that takes an filepath and returns a program/IO action producing a string
21:31:00 <monochrom> To many people, FilePath -> [Byte] is even easier
21:31:14 <jle`> 'String' itself in Haskell is a bit of a wart, but that's a different story, heh
21:31:28 <mpcsh> jle`: interesting. so what would, say, running a regex consist of?
21:31:37 <EvanR> or just [Byte]
21:31:56 <jle`> mpcsh: running a regex would probably look like 'runRegex :: Regex -> String -> Mathces'
21:32:24 <mpcsh> jle`: where the string comes from one of those 'IO String' actions?
21:32:40 <jle`> yeah, one nice thing about the IO type is that you can transofrm them on convenient ways
21:32:54 <jle`> you can take an IO action producing a String and turn it into an IO action producing Matches
21:32:57 <monochrom> time to read my http://www.vex.net/~trebla/haskell/IO.xhtml
21:33:19 <mpcsh> monochrom: you wrote that?
21:33:22 <monochrom> yes
21:33:39 <mpcsh> monochrom: wow, looks great, thanks for the link
21:52:44 <DemiMarie> Why is unsafeSTToIO unsafe?
21:53:39 <Lokathor> an FFI lib is giving me a Ptr (), is comparing that to the nullPtr constant the correct way to check for null? or is there something somehow trickier?
21:53:47 <jle`> DemiMarie: because you could extract dangling STVar's
21:54:20 <jle`> er, STRef
21:54:50 <jle`> unsafeSTToIO (newSTRef 0) :: IO (STRef s a)  ... oops
21:55:15 <jle`> ST is carefully cunstricted so that STRef's never leave the ST action they are executed in
21:58:58 <monochrom> Lokathor: comparing to nullPtr is right
21:59:22 <monochrom> unless the doc says no
21:59:36 <Lokathor> http://lpaste.net/350265 is what i did. the doc just says that nullPtr is a constant
22:01:15 <chetshah> Hello all, I am a haskell beginner had some question about type constructor in general : 
22:01:36 <chetshah> Would you consider (,) the tuple maker a type constructor for product types? Also a value constructor ?
22:01:59 <chetshah> As in (String,String) and ("hi","hello")
22:02:17 <Lokathor> (,) at the type constructor, and at the value level is a value constructor, correct. Types and Values live in their own realms
22:02:35 <monochrom> there is a type constructor, it is called (,). there is a value constructor, it also happens to be called (,)
22:03:02 <monochrom> you can do the similar thing to your own types too. "data X = X". Now you have two X's.
22:03:18 <monochrom> the left X is a type, the right X is a value
22:03:32 <chetshah> SSo unlabeled product types have (,) as their type constructor? same goes for sum types  we define with data ?
22:04:36 <monochrom> I hope you will next ask about DataKinds so we will have four X's.
22:05:37 <Lokathor> i'm not sure there are unlabaled sum types
22:05:48 <Lokathor> the data keyword gives them a label
22:06:02 <fresheyeball> hello out there
22:06:12 <monochrom> in fact (,) is a label too
22:07:08 <fresheyeball> I have a dumb problem
22:07:26 <fresheyeball> I am trying to build the "gloss" libraries examples
22:07:38 <fresheyeball> and it uses OpenGLRaw-3.2.4.0
22:07:53 <fresheyeball> the build fails on "Missing C library: GL"
22:08:41 <fresheyeball> I've installed all I can and googled about, but no luck
22:08:53 <fresheyeball> any idea why cabal might not be finding the C library?
22:09:09 <shiona> which OS?
22:12:08 <chetshah> What I am meaning to ask is that : Just like (,)/ {} are type constructors for product types, What would be equivalent notion for sum type ?
22:12:18 <chetshah> Or am I getting ahead of myself here?
22:13:52 <shiona> chetshah: Either
22:13:58 <c_wraith> the most iconic type constructor for a sum type is Either
22:14:02 <c_wraith> No special syntax for it
22:14:21 <chetshah> Oh Cool.
22:16:49 <c_wraith> anything with multiple value constructors is a sum type, really.  Either is just a nice pure sum of two arbitrary types
22:20:08 <chetshah> Yes, that makes sense.
22:23:41 <jle`> anonymous sums coming into ghc soon in some cases
22:30:37 <jle`> and maybe for unboxed types some day too
22:30:50 <MarcelineVQ> They are specifically for unboxed aren't they?
22:31:01 <jle`> yes, the ones that are in the works
22:31:09 <jle`> but hopefully some day we'll get them for unboxed types too
22:35:00 <MarcelineVQ> I don't think I understand what you're saying, (# t_1 | t_2 #) t_1 and t_2 can be unboxed as well
22:36:43 <jle`> oh huh yeah, they are unboxed sums of boxed types
22:36:46 <MarcelineVQ> Word32, String, Float#, Maybe Int are among the example types
22:47:33 <fresheyeball> grr
22:47:35 <fresheyeball> cabal: Missing dependency on a foreign library: * Missing C library: GL
22:47:37 <MarcelineVQ> Allthough, I can't get an example with Float# to work despite that
22:47:38 <fresheyeball> is still killing me
22:51:30 <sm> fresheyeball: which OS
22:51:49 <fresheyeball> ubuntu
22:53:48 <sm> fresheyeball: apt install mesa-common-dev 
22:54:18 <fresheyeball> I have that already
22:54:41 <fresheyeball> yup verified, newest version
22:55:46 <sm> fresheyeball: ok, and also libgl1-mesa-dev ?
22:55:55 <fresheyeball> let me double check
22:56:14 <fresheyeball> ok, yes, newest version
22:56:29 <sm> not sure then.. those are the packages providing Gl.h and libGL.so on my ubuntu system
22:56:57 <sm> in standard places, which cabal should find by default
22:57:02 <fresheyeball> sm: lame, you have any idea where those libraries live? Can I pass it explicitly to cabal?
22:57:56 <sm> /usr/include/GL/gl.h, /usr/lib/i386-linux-gnu/libGL.so, etc. here
22:58:25 <sm> cabal tries those paths, /usr/local/* too
23:00:18 <sm> which package are you trying to cabal install ?
23:00:41 <sm> or rather, which package is it trying to build when it gives that error
23:00:52 <fresheyeball> gloss
23:00:59 <fresheyeball> I just cloned the gloss repo from github
23:01:08 <fresheyeball> and am trying to build the example directory
23:01:10 <sm> does cabal install OpenGL work then ?
23:01:41 <fresheyeball> same error
23:01:57 <fresheyeball> so I think the issue is just OpenGLRaw
23:02:16 <sm> your system seems to be behaving oddly
23:02:36 <fresheyeball> sm: my cabal is installed by nix
23:02:41 <fresheyeball> could that be an issue?
23:02:49 <sm> I'm not sure
23:03:25 <sm> you could try the cabal from apt install cabal-install
23:04:03 <sm> or apt install haskell-stack
23:06:24 <fresheyeball> I can't use stack
23:06:30 <fresheyeball> it fails with the cabal file
23:17:05 <MarcelineVQ> jle`: Got it, dummy me I forgot to write 1.2# instead of 1.2  anyway you can mix and match all kinds of stuff appearantly, it's really neat
23:19:01 <MarcelineVQ> I have no idea what to use them for though
23:38:44 <haskell673> i am gtting this error, any idea how to fix it : Couldn't match expected type `Char -> Int'                 with actual type `[(Char, Int)]'
23:40:06 <haskell673> hello
23:40:23 <pavonia> You need to show your code
23:40:26 <pavonia> @lpaste
23:40:26 <lambdabot> Haskell pastebin: http://lpaste.net/
23:41:25 <haskell673> pasted
23:41:48 <haskell673> http://lpaste.net/350267
23:42:23 <pavonia> :t group
23:42:25 <lambdabot> Eq a => [a] -> [[a]]
23:43:23 <pavonia> You type signature says the function takes two parameters, but you only have one in the pattern
23:44:01 <pavonia> Also, your result type is wrong, the result is a list
23:44:49 <Rotaerk_> try removing your type specification and use ghci to get the type of it
23:44:59 <haskell673> let me fix and show again
23:45:15 <Rotaerk_> the expression itself is valid, it just doesn't match the type you specified
23:47:00 <haskell673> yup it works
23:47:45 <haskell673> can you tell if i write "happy is sad" its counting space too, how can i remove it
23:49:34 <pavonia> You could use filter
23:49:37 <pavonia> :t filter
23:49:39 <lambdabot> (a -> Bool) -> [a] -> [a]
23:50:42 <haskell673> how to use filter
23:51:23 <pavonia> > filter (/= 0) [0,1,0,2,0,3,0,4]
23:51:26 <lambdabot>  [1,2,3,4]
23:52:09 <pavonia> Hint: String = [Char]
23:52:19 <haskell673> i am new to haskell let me still try it
23:53:24 <haskell673> http://lpaste.net/350268
