00:04:23 <Unhammer> http://sprunge.us/ZKcV?hs compiled with 7.8.4, but 7.10.3 gives http://sprunge.us/eGJH – what happened? I can't see anything relevant in https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10 :-/
00:07:40 * hackagebot exception-transformers 0.4.0.5 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.5 (GeoffreyMainland)
00:07:40 * hackagebot pgdl 10.5 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.5 (sifmelcara)
00:08:08 <jle`> Unhammer: is it the same version of Array ?
00:11:20 <Unhammer> 0.5.0.0 → 0.5.1.0
00:13:30 <Unhammer> http://git.haskell.org/packages/array.git/blob_plain/HEAD:/changelog.md
00:13:33 <Unhammer> ## 0.5.1.0  *Mar 2015*
00:13:35 <Unhammer>   * Bundled with GHC 7.10.1
00:13:37 <Unhammer>   * Add role annotations for GHC >= 7.8 (#9220)
00:13:39 <Unhammer> hm
00:26:55 <Unhammer> ugh https://ghc.haskell.org/trac/ghc/ticket/9220#comment:11 even says it's a breaking change, but https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html has no mention of it :(( 
00:31:33 <Unhammer> so how does one use an Int-newtype as an UArray index?
00:47:37 * hackagebot classyplate 0.3.0.0 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.3.0.0 (lazac)
01:11:50 <kqr> anyone know what's up with this? http://lpaste.net/raw/4406180569277267968
01:22:39 * hackagebot safe-access 0.3.1.0 - A simple environment to control access to data  https://hackage.haskell.org/package/safe-access-0.3.1.0 (thoferon)
01:32:40 * hackagebot mnist-idx 0.1.2.6 - Read and write IDX data that is used in e.g. the MNIST database.  https://hackage.haskell.org/package/mnist-idx-0.1.2.6 (muzzle)
01:35:32 <cocreature> kqr: are you on debian? iirc there were some problems because they changed the default of gcc to use -fPIC. this should be fixed in 8.0.2 which should be released soon
01:45:11 <Koterpillar> I'm using web-routes. How do I get a MonadRoute context without running a site?
02:07:42 * hackagebot Annotations 0.2.2 - Constructing, analyzing and destructing annotated trees  https://hackage.haskell.org/package/Annotations-0.2.2 (MartijnVanSteenbergen)
02:13:36 <kqr> cocreature: oh dear. Soon can't come soon enough. My xmonad isn't starting! 
02:13:59 <kqr> cocreature: is it implemented in whatever dev branch of 8.0.2 that is available? 
02:14:24 <cocreature> kqr: there is a release candidate that should fix it
02:15:31 <cocreature> kqr: https://mail.haskell.org/pipermail/glasgow-haskell-users/2016-November/026410.html
02:16:41 <kqr> cocreature: do you happen to know of  there is some other way to set this as a global default for gcc in the interim? I might run older ghc versions too... 
02:17:25 <cocreature> kqr: sorry not sure, I don’t use debian so I haven’t been hit by that bug myself and thereby haven’t looked into it
02:22:27 <tdammers> I'd really like for xmonad to be able to use a cabal or stack sandbox
02:23:39 <quchen> That’s what keeps me from trying it again too
02:28:16 <cocreature> iirc I managed to get it working with cabal sandboxes at some point but I stopped using it since
02:30:55 <tdammers> I'm still using it, and just do everything else in sandboxes, so that the system-wide GHC keeps working
02:31:00 <tdammers> but it's not ideal
02:47:45 * hackagebot hasbolt 0.1.0.1 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.0.1 (zmactep)
02:51:30 <kqr> okay, apparently upgrading to gcc 6 on debian has that effect. downgrading to gcc 5 helped
02:52:45 * hackagebot patat 0.4.5.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.4.5.0 (JasperVanDerJeugt)
03:12:55 <nevere> What is a good library to send multipart html emails in Haskell?
03:22:32 <MonadHendrix> @pl \f g x y -> f (x ++ g x) (g y)
03:22:32 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
03:24:54 * mrkgnao is horrified
03:26:29 <camm> Hello everyone, I'm having a problem with stack. I try to install the GHC from lts-3.5 and I get the following error: "Supported versions for OS key 'linux64-ncurses6': GhcVersion 7.10.3, GhcVersion 8.0.1" I have installed ncurses6 in my OS (Manjaro). Would you mind helping me to solve this problem?
03:27:04 <lyxia> why do you want something as old as lts-3.5
03:27:39 <lyxia> hmm it's not as old as that.
03:28:42 <lyxia> but it works with ghc-7.10.2 ...
03:29:13 <camm> I need it because a package uses it and I'll have to compile it with that version.
03:31:16 <lyxia> sorry I don't know how to help you
03:32:23 <Unhammer> camm,  I got that on arch linux, where I think the recommended solution is to install ncurses5 
03:32:41 <MonadHendrix> ncurses5-compat-libs
03:33:42 <mrkgnao> doesn't Manjaro also use pacman and everything?
03:34:28 <Unhammer> (ie. if I understood correctly, the error message is actually trying to say "you have ncurses6, which supports 7.10 and up, and you tried to use one that ncurses6 doesn't support, but we're not going to tell you what you relly need")
03:36:45 <Unhammer> *7.10.3 and up I guess
03:38:31 <camm> Mmm it seems that ncurses5-compat-libs is not in the repository list. "$ sudo pacman -S ncurses5-compat-libs" throws "error: target not found: ncurses5-compat-libs" :/
03:40:33 <MonadHendrix> i think it was in the aur last time i checked
03:40:44 <MonadHendrix> camm: https://aur.archlinux.org/packages/ncurses5-compat-libs/
03:40:56 <MonadHendrix> i needed to install it for matlab
03:45:20 <nevere> What is a good library to send multipart html emails in Haskell?
03:46:30 <camm> I tried it with yaourt and it works. However, I still having the same problem when I run stack `setup --resolver lts-3.5`
03:47:49 * hackagebot generics-sop-lens 0.1.2.1 - Lenses for types in generics-sop  https://hackage.haskell.org/package/generics-sop-lens-0.1.2.1 (phadej)
03:55:56 <camm> Upps I installed a different version of ncurses5-compat-libs :-/ I've solve the problem thanks MonadHendrix and Unhammer
04:03:31 <Drezil> is there a swagger-codegen for Haskell?
04:04:00 <Drezil> i could not find one that builds me a library for interfacing with a swagger-API .. just packages for writing one myself..
04:05:58 <MonadHendrix> well hoogle is just great
04:06:29 <kuribas> Aren't monad transformers an ugly part of haskell?  They don't really compose well, you have to provide an instance for each transformer.
04:06:44 <jle`> an instance for each transformer?
04:06:50 <jle`> you have to provide a monad instance for each monad, too...
04:07:04 <jle`> and an Ord instance for every comparable type
04:10:06 <kuribas> jle`: that's the problem, they compose, so you have to have a typeclass for every kind of transformer, instead of just a datatype.
04:10:17 <kuribas> they don't compose I mean
04:10:27 <jle`> a typeclass for every kind of transformer
04:10:36 <jle`> in what sense?
04:10:59 <kuribas> ReaderT, StateT, etc...
04:11:18 <jle`> those are types
04:11:20 <kuribas> MonadReader, MonadState, etc...
04:12:06 <jle`> MonadReader doesn't really relate to the type ReaderT though; it's just because they share similar letters in their name, it's a bit confusing
04:12:16 <jle`> but MonadReader doesn't have anything fundamental to do with ReaderT and monad transformers
04:12:25 <jle`> most useful MonadReaders *aren't* implemented using monad transformers
04:12:34 <jle`> MonadReader is unrelated to the idea of monad transformers
04:13:15 <jle`> in fact, the most common MonadReader instance that people use the most often is *not* ReaderT :)
04:13:21 <kuribas> So you can have monad stacks without typeclasses?
04:13:32 <jle`> monad transformers exist without typeclasses, yes
04:15:16 <kuribas> So the typeclasses are just a convenience?
04:15:23 <merijn> kuribas: Yes
04:15:31 <merijn> kuribas: I rarely use said classes
04:15:43 <jle`> just like how 'Ord' is a convenience api for numbers and strings and lists of things
04:15:50 <kuribas> merijn: you manually lift things?
04:16:08 <merijn> kuribas: Yes, or just avoid deep stacks and export a limited number of operations
04:18:11 <kuribas> Is it more efficient to manually lift instead of using the typeclasses?
04:18:28 <kuribas> Does MonadState, etc... come with overhead?
04:18:39 <jle`> a lot of people don't directly work with monad transformers; they just operate on abstract interfaces
04:18:47 <jle`> like if you write 'sort', you don't work directly with comparing numbers
04:18:52 <jle`> you work abstractly on all Ord's
04:18:55 <jle`> :t sort
04:18:57 <lambdabot> Ord a => [a] -> [a]
04:19:02 <jle`> it's not sort :: [Int] -> [Int]
04:19:27 <jle`> so often times, people just write to abstract interfaces, like MonadState and MonadReader, and don't worry about whether or not they're going to be using monad trnasformers or not in the end
04:20:01 <kuribas> right
04:20:03 <jle`> at the end of it all, they have to actually build the instance of the interface eventually.  Monad transformers are a very convenient way of building types/monads to give you the interface you want
04:20:51 <jle`> so if you write a function that works on all (MonadReader r m, MonadIO m, Alternative m), etc. ... eventually you need an 'm' that can implement all of that interface
04:21:01 <jle`> monad transformers are one of the most convenient ways to conjure up an 'm'
04:21:08 <jle`> *such an 'm'
04:21:09 <fizruk> Drezil: there definitely was, but I'm not sure if it's up-to-date
04:21:49 <kuribas> Can a type be both MonadState A m, and MonadState B m, where B is part of A?
04:21:56 <fizruk> Drezil: this looks like it: https://github.com/swagger-api/swagger-codegen/tree/master/samples/server/petstore/haskell-servant
04:22:51 * hackagebot binary-tagged 0.1.4.2 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.4.2 (phadej)
04:23:25 <lyxia> kuribas: mtl's MonadState has a dependency which means every m has a single state type.
04:23:36 <kuribas> ah I see
04:24:06 <lyxia> a lens may be useful for what you described
04:28:17 <fizruk> kuribas: lyxia: something like https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html#v:zoom
04:29:30 <magthe> in solving today's Advent of Code puzzle I found myself wanting to use mapAccumL, but with control over termination, is there such a thing? something like (a -> b -> Maybe (a, c)) -> a -> t b -> (a, t c)
04:31:24 <kuribas> magthe: does it end with Nothing?
04:31:38 <mniip> you could let c be Maybe c
04:31:42 <kuribas> magthe: or take all "Just" values
04:31:47 <mniip> and then add 'takeWhile (isJust . snd)'
04:32:04 <magthe> kuribas: yes, it would stop on Nothing, similar to how unfoldr works
04:32:15 <mniip> then a could even be undefined where c is Nothing
04:32:58 <magthe> the thing is that `t b` is infinite, so I can't really afford traversing the whole list ;)
04:34:31 <mniip> magthe, so?
04:34:37 <mniip> mapAccum is obviously lazy
04:35:11 <mniip> oh, left one
04:35:40 <kuribas> magthe: or a right fold?
04:35:41 <mniip> oh, hmm, it is not lazy in a
04:36:01 <mniip> yeah I think you need a regular fold
04:36:06 <mniip> or a custom combinator
04:36:46 <magthe> mniip: my `t b` is infinite, it holds pairs (Int, q), I want to take the first 8 pairs, where the integers are [0 .. 7], and no duplicates
04:37:33 <mniip> no duplicate pairs, or just integers?
04:38:37 <kuribas> mniip: why wouldn't mapAccumL work?
04:39:10 <magthe> no duplicate integers
04:40:35 <magthe> so if the series starts with [(1,'a'),(0, '1'),(1,'b')...], I want the output to start with [(1,'a'),(0,'1'), ...]
04:42:27 <mniip> take 8 . filter (inRange (0, 7) . fst) . nubBy ((==) `over` fst)
04:43:13 <mniip> err
04:43:15 <mniip> s/over/on/
04:43:38 <kuribas> :t inRange
04:43:41 <lambdabot> Ix a => (a, a) -> a -> Bool
04:44:03 <magthe> ah, yes, nubBy will keep the first, so I'm guessing it's lazy
04:46:13 <kuribas> :i inRange
04:46:56 <kuribas> @hoogle inRange
04:47:00 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
04:47:00 <lambdabot> Data.Ix.Enum inRange :: Enum a => (a, a) -> a -> Bool
04:47:00 <lambdabot> Data.Ord.HT inRange :: Ord a => (a, a) -> a -> Bool
04:48:28 <kuribas> How can people not like the new Base libraries...
04:57:53 * hackagebot hasbolt 0.1.0.2 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.0.2 (zmactep)
05:02:07 <magthe> mniip: thanks, it worked nicely with `nubBy` :)
05:07:54 * hackagebot praglude 0.1.2.0 - A pragmatic Prelude  https://hackage.haskell.org/package/praglude-0.1.2.0 (TobiasDammers)
05:16:37 <tnks> I'm finding contradictory comments online.  Do MTL classes have or not have laws?  And if so, what are specific examples?
05:17:09 <hpc> https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans
05:18:20 <hpc> there aren't really any laws for the others other than "don't define weird bottom-y nonsense"
05:18:56 <hpc> though you could probably come up with some like get >>= put === return () for MonadState
05:20:13 <hpc> for actual laws that you should care about, i would go only by the documentation for the package
05:20:33 <tnks> hpc okay, bottom, that might explain the instances not there for all n^2 possibilities.
05:20:48 <hpc> what in particular are you looking at?
05:21:28 <tnks> passing comments on whether mtl is "lawless" or "has laws, but they aren't documented"
05:21:42 <hpc> ah
05:21:55 <tnks> but clearly, all n^2 instances aren't there.
05:22:30 <tnks> I don't know if that's because parametrically some are impossible to construct.
05:22:49 <tnks> or if there are constructable instances that are invalid.
05:24:17 <tnks> but now that you point out the MonadTrans law, that helps.  I missed that.
05:24:18 <nevere> What is a good library to send multipart html emails in Haskell?
05:25:05 <kuribas> What does Alan Kay have against monads?  I find them not hard to use, once you get used to them...
05:27:18 <hackrilege> Can't smart constructors be used to ensure laws are satisfied?
05:27:55 * hackagebot line 2.1.0.0 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-2.1.0.0 (noraesae)
05:29:32 <codedmart> Anyone that can spot what I am doing wrong based on what I provide in this gist? If I create an handle when I start my app and pass it into my `withLogging` function the log file is never written to (https://gist.github.com/codedmart/14d6521d90e75957fdf3109fc8f4dfae#file-notworking-hs-L37-L39), but if I create the handle in `withLogging` the log file is
05:29:32 <codedmart> written to (https://gist.github.com/codedmart/14d6521d90e75957fdf3109fc8f4dfae#file-working-hs-L42-L46).
05:40:23 <hackrilege> codedmart, is it because you use the constructor of InfoLog to hold the handle instead of simply working within the IO monad as in the working version?
05:41:15 <codedmart> hackrilege: If I have `IO Handle` in `InfoLog` and just pull it out in `withLogging` would that work?
05:41:51 <codedmart> I guess I can try :)
05:41:55 <codedmart> Thanks!
05:42:26 <hackrilege> I can't see exactly what's happening, but maybe you are creating 2 InfoLog objects and one has a blank handle...
05:42:56 * hackagebot heterocephalus 1.0.1.2 - A type-safe template engine for working with popular front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.1.2 (arowM)
05:42:58 * hackagebot language-c-quote 0.11.7.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.7.1 (GeoffreyMainland)
05:43:17 <codedmart> If I print out handle in `withLogging` it shows the proper information ie ("handle path/to/file.log").
05:46:34 <hackrilege> I can't see why accessing it in different ways would create copies, but then I can't see why else it would fail
05:47:08 <hackrilege> Second opinion needed!
05:47:57 * hackagebot find-source-files 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/find-source-files-0.1.0.0 (oisdk)
05:48:41 <hackrilege> I have never seen a problem like that before, it's pretty interesting though, id like to get a decent explanation of what's going on from one of the dons, but maybe it's lunchtime!
05:52:59 <codedmart> hackrilege: I think you are right. If I change `Handle` to `IO Handle` in `InfoLog` and use that in `withLogging` it works. Thanks!
05:53:34 <codedmart> I didn't even think of that, but now that you mention it makes sense.
05:54:57 <sphinxo> Anyway I can shorten/make this easier to read?: (fst a <= fst b) && (snd a <= snd b)
05:55:23 <sphinxo> where a and b are of type: (Float,Float)
05:56:16 <sphinxo> does a <= b do the same thing?
05:57:06 <kuribas> > (1, 3) < (2, 2)
05:57:09 <lambdabot>  True
05:57:24 <kuribas> sphinxo: no
05:59:16 <codedmart> Is there a difference between return and pure. Why have both?
05:59:29 <codedmart> If they aren't different.
05:59:57 <kuribas> pure is for applicative, return for monad?
06:00:19 <Clint> yes
06:00:23 <codedmart> Ah right
06:00:30 <codedmart> I forgot that.
06:00:32 <codedmart> Thanks!
06:00:46 <kuribas> codedmart: it may be applicative, but not a monad.
06:02:51 <merijn> codedmart: Historical reasons
06:03:02 <merijn> codedmart: For a long time Applicative was not a superclass of Monad
06:03:09 <merijn> codedmart: Thus Monad couldn't reuse pure
06:03:30 <codedmart> OK cool to know, so you can use pure in place of return now then?
06:03:55 <merijn> codedmart: Applicative was made a superclass of Monad not THAT long ago, so pure and return were both kept for backwards compatibility, but can now be used interchangeably, yes
06:04:09 <codedmart> merijn: Thanks!
06:07:02 <hackrilege> I can define bind for types I can't define <*> for
06:08:28 <hackrilege> Maybe I'm mistaken
06:09:03 <kuribas> merijn: so new code shouldn't use return?
06:09:18 <merijn> kuribas: I still use return out of habit. It shouldn't really matter
06:09:34 <hackrilege> I don't really understand applicaive style, why not just use fmap?
06:09:56 <merijn> hackrilege: fmap only works with functions with one argument
06:10:08 <merijn> :t elem
06:10:10 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
06:10:22 <merijn> :t fmap elem
06:10:24 <lambdabot> (Foldable t, Functor f, Eq a) => f a -> f (t a -> Bool)
06:10:31 <byorgey> hackrilege: you are mistaken.  If you have bind and fmap, then you can define <*>
06:10:32 <merijn> hmm, not the best example
06:11:02 <byorgey> hackrilege: (which makes for a nice exercise)
06:11:04 <merijn> Actually, why not just
06:11:07 <merijn> :t (:)
06:11:08 <lambdabot> a -> [a] -> [a]
06:11:10 <merijn> :t fmap (:)
06:11:11 <lambdabot> Functor f => f a -> f ([a] -> [a])
06:11:30 <merijn> hackrilege: How would you ever do anything useful with the result of "fmap (:)"? :)
06:11:48 <hackrilege> So basically if i fmap a function of 2 arguments then I would need to use applicative to apply the other argument?
06:12:10 <merijn> hackrilege: Study what this type does
06:12:13 <merijn> :t liftA2
06:12:15 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:12:16 <hackrilege> I guess I get upset having to infer the shape when I could just fmap into it
06:12:35 <merijn> hackrilege: If fmap works you don't need Applicative in the first place
06:12:47 <merijn> hackrilege: The point is, Applicative can do things that fmap can't
06:12:57 <merijn> hackrilege: Try writing liftA2 with just fmap
06:13:35 <merijn> > liftA2 (:) (Just 'z') (Just "test")
06:13:37 <lambdabot>  Just "ztest"
06:13:55 <merijn> :t fmap (:) (Just 'z')
06:13:57 <lambdabot> Maybe ([Char] -> [Char])
06:14:19 <merijn> hackrilege: You need to somehow get the "[Char] -> [Char]" out, which you can't do for every Functor
06:14:20 <hackrilege> > liftA2 (:) [[]] [[]]
06:14:23 <lambdabot>  [[[]]]
06:14:44 <merijn> :t (<*>)
06:14:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:15:16 <merijn> hackrilege: Note that <*> has to get a function "out" of 'f' and an 'a' out of 'f' to be able to produce a 'b'
06:15:25 <hackrilege> Can't I just fmap the other argument *into* The Functor?
06:15:43 <merijn> hackrilege: The second argument is inside an 'f' too
06:15:54 <merijn> hackrilege: How do you get it out of the functor so you can fmap it in?
06:16:14 <merijn> hackrilege: Note that "a -> b" takes an 'a', NOT an 'f a'
06:16:30 <hackrilege> > fmap [] $ fmap (:) [[]]
06:16:31 <merijn> hackrilege: So you need to get an 'a' from 'f a', which fmap can't do
06:16:32 <lambdabot>  error:
06:16:33 <lambdabot>      • Couldn't match expected type ‘([[t1]] -> [[t1]]) -> b’
06:16:33 <lambdabot>                    with actual type ‘[t0]’
06:16:38 <hackrilege> Argh!!
06:16:47 <merijn> hackrilege: How did you get the [] out?
06:17:32 <hackrilege> Yeah ok I get it, the [] is not of the type required by the argument of fmap
06:17:49 <hackrilege> What a headache
06:18:03 <merijn> hackrilege: Actually, what you wrote could work if you abuse $
06:18:14 <merijn> > fmap ($[]) $ fmap (:) [[]]
06:18:16 <lambdabot>  [[[]]]
06:18:25 <merijn> hackrilege: But you still have no way to get that first [] :p
06:18:41 <hackrilege> :t ($[])
06:18:42 <lambdabot> ([t] -> b) -> b
06:18:50 <hackrilege> Interesting
06:20:45 <hackrilege> But yeah, suppose I want to use Applicative to fmap a function over a complicated tree, do I have to make a tree of that shape filled with the function and then take a product? Isn't that more expensive than just traversing the tree applying the function?
06:21:41 <merijn> hackrilege: That depends on what a sensible Applicative for said tree is
06:21:54 <merijn> hackrilege: Applicatives, unlike Functors are not necessarily unique
06:22:49 <hackrilege> > zipWith (\(a,b)->a b) (repeat (+1)) [1,2,3]
06:22:52 <lambdabot>  error:
06:22:52 <lambdabot>      • Couldn't match type ‘Integer -> Integer’
06:22:52 <lambdabot>                       with ‘(t0 -> Integer -> c, t0)’
06:24:15 <hackrilege> merijn, I guess you mean about cross product types or something
06:24:35 <Ferdirand> mhh
06:24:39 <hackrilege> diagonals... I'm not sure
06:24:50 <Ferdirand> formally, how do you show that lawful Functor instances are unique ?
06:25:07 <merijn> hackrilege: For trees I dunno, tbh. But lists have two applicatives, for example (the regular and the ZipList newtype)
06:25:08 <Ferdirand> i get it for fmap id == id 
06:25:17 <Ferdirand> it's less clear for the second law
06:25:25 <merijn> Ferdirand: Actually, it follows merely from "fmap id == id" plus parametricity
06:25:36 <merijn> Ferdirand: The second functor law is a free theorem of fmap in Haskell
06:26:04 <Ferdirand> :t fmap
06:26:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:26:29 <merijn> Ferdirand: The first functor law guarantees that fmap can't change the "structure" (if you will) of your functor
06:26:36 <hackrilege> The most general trees are just nested lists so I guess the concept should extend simply
06:26:52 <Ferdirand> well that guarantee is upheld by parametricity, yes ?
06:27:01 <Ferdirand> it's the formalization of parametricity that I don't get
06:27:03 <merijn> Ferdirand: Parametricity guarantees that all 'a' (at least the parametric ones) in 'f' MUST be updated, else it wouldn't typecheck
06:27:06 <Ferdirand> I mean, intuitively it makes sense
06:27:40 <merijn> Ferdirand: So the structure can't change and any 'a' MUST be replaced by applying the argument function to 'a' (else you can't obtain a b)
06:29:14 <Ferdirand> merijn: I agree with all that, but how do you show it formally ? do you need to use induction the definition of haskell datatypes ? or is there a simpler shortcut ?
06:29:34 <merijn> Ferdirand: Ah, that's a rather harder question that I can't answer in an IRC conversation :p
06:29:44 <merijn> Ferdirand: Some pointers: Wadler's "Theorems for Free!" paper
06:29:58 <merijn> And if you wanna learn to prove it yourself, the (excellent) book Software Foundations
06:30:01 <merijn> @where sf
06:30:01 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
06:30:01 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
06:31:02 <Ferdirand> tbh i'm just being lazy, i've read the aforementioned paper, several times. But my understanding of it faded away quickly
06:31:18 <Ferdirand> I was wondering if someone here would have an intuitive explanation that might be easier to memorize
06:31:33 <Ferdirand> btw I think I understood why there is no need for other sorts than BOX in haskell
06:31:44 <quchen> Oh?
06:31:49 <quchen> Explain!
06:31:53 <quchen> I never got that
06:32:28 <Ferdirand> kinds of different sorts would not be populated by any types, just like types not of kind '*' cannot be populated by values ?
06:32:53 <merijn> Ferdirand: Well, tbh, that depends on your underlying theory :)
06:33:00 * hackagebot language-puppet 1.3.3 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.3 (SimonMarechal)
06:33:39 <Ferdirand> i know "meh, good enough" is not a proper answer
06:35:03 <merijn> Ferdirand: My grasp on this isn't strong enough to explain, but you're thinking along the right lines, as in "what kind of expressiveness would be accommodated by kinds not in BOX?"
06:35:41 <merijn> quchen: The lambda cube paper covers this, iirc
06:35:52 <merijn> Ferdirand: ^^^ that goes for you too
06:36:06 <merijn> "Introduction to Generalised Type Systems" it's called
06:36:06 <quchen> merijn: »The lambda cube paper«?
06:36:12 <quchen> Ah, thanks.
06:36:15 <merijn> by Barendregt
06:36:32 <merijn> quchen: Basically, you only need one sort to cover everything on the lambda cube
06:37:13 <merijn> If you wanna see something where multiple sorts DO occur, you'll want to look at the Calculus of Constructions (or maybe it was the Extended CoC)
06:37:13 <hackrilege> http://www.diku.dk/hjemmesider/ansatte/henglein/papers/barendregt1991.pdf
06:37:19 <merijn> But I don't have a good intro paper for that
06:37:33 <merijn> I read Luo's ECC paper, but tbh I struggled and only got like half of it :)
06:37:52 <merijn> Yeah, that one
06:38:00 * hackagebot morph 0.1.1.1 - A simple database migrator for PostgreSQL  https://hackage.haskell.org/package/morph-0.1.1.1 (thoferon)
06:38:21 <hackrilege> In a few decades I will have this stuff down
06:38:37 <merijn> hackrilege: If you want a more readable intro, start with TaPL
06:38:43 <hackrilege> But I need a job sometime this decade...
06:38:49 <merijn> hackrilege: That will at least gently introduce all the type theory notation
06:38:58 <hackrilege> link?
06:39:09 <merijn> hackrilege: Also, TaPL (unlike that paper) was written for undergrads :)
06:39:12 <merijn> @where tapl
06:39:12 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:39:17 <hackrilege> Thanks
06:39:48 <merijn> hackrilege: You don't need to read the whole thing, I think that half way through you already know enough to implement a "Haskell without extensions" type system
06:39:57 <hackrilege> Oh that's no good there is no pdf
06:40:18 <merijn> hackrilege: Yeah, it's not available for free, unfortunately. Most university libraries should carry it, though
06:40:56 <hackrilege> I'll check. It's a shame the casual observer can't partake
06:42:09 <nevere> What is a good library to send multipart html emails in Haskell?
06:42:14 <hackrilege> https://www.google.co.uk/url?sa=t&source=web&rct=j&url=http://ropas.snu.ac.kr/~kwang/520/pierce_book.pdf&ved=0ahUKEwjxy6G1pN3QAhUEKsAKHa3PDEIQFghGMAo&usg=AFQjCNGhNRV_tRSxJs4qO9ytpyjPZ41a5A&sig2=_ml3FHTZ4zSm5JofP33lWA
06:42:36 <hackrilege> Sorry i should have shortened that
06:43:18 <quchen> merijn: The lambda hypercube!
06:43:49 <quchen> That won’t work though because it’s hard to extend STLC with sorts and nothing else.
06:43:53 <quchen> :-(
06:46:05 <hackrilege> Yowch that's heavy reading, I'll wait until I'm retired
06:55:55 <tsahyt> Hello! I'm writing high level bindings to a C API and I've got a function of type (forall s. Handle s -> IO r) -> IO r to keep a handle from leaking out. However, within this context I can call a function in which the handle itself must never be used. Is there some way to encode this in the type system?
06:56:22 <tsahyt> this function I can call is higher order and would ideally have a very similar type
06:57:07 <PileOfBirds> Would it be a good idea to use Haskell in discrete math research?
07:03:02 * hackagebot line 2.1.0.1 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-2.1.0.1 (noraesae)
07:03:13 <ongy> tsahyt: if the user really wants to extract it, I don't think there's currently a way to prevent it if IO is allowed. IORefs can do it pretty easily
07:04:41 <hackrilege> PileOfBirds, how do you mean? Like graph theory? I think Haskell is pretty good for that
07:04:59 <c_wraith> hackrilege: he timed out
07:05:11 <hackrilege> Ok
07:05:25 <tsahyt> ongy: I mean prohibiting the user from using the outer handle inside the function providing the inner handle
07:06:04 <c_wraith> tsahyt: it takes more than that - you have to pin the type of the Handle to the context in which it's used.
07:06:31 <benzrf> lumpenproletariat 2: trumpenproletariat. much worse this time
07:06:39 <benzrf> oops wrong channel :(
07:06:53 <c_wraith> tsahyt: that's the only way to prevent the Handle from being used in multiple contexts.
07:07:07 <tsahyt> i.e. foo :: (forall s. Handle s -> IO r) -> IO r, and inside of that call a function bar :: Handle s -> (forall q. Handle2 q -> IO p) -> IO (), but using the Handle s inside of the function provided to bar must be illegal
07:07:57 <tsahyt> to my understanding it should be impossible to pass the Handle s outside of foo. At least that's how ST does it.
07:08:13 <c_wraith> tsahyt: ST does it by pinning the reference type to the ST type
07:08:20 <c_wraith> tsahyt: ST s a, STRef s a
07:08:27 <c_wraith> tsahyt: the important part is that both use s
07:08:36 <tsahyt> c_wraith: with what I have now, trying to pass it out results in a compiler error
07:08:41 <tsahyt> s/compiler/compile time
07:08:44 <c_wraith> tsahyt: readSTRef :: STRef s a -> ST s a
07:08:54 <tsahyt> I haven't tried any sneaky stuff like IORefs yet
07:09:01 <c_wraith> tsahyt: every operation that works on an STRef pins the ref type to the context type
07:09:07 <c_wraith> tsahyt: that's why ST works
07:09:52 <c_wraith> tsahyt: as for your actual question, though..  I can only make it work by putting the operations in different contexts.
07:11:33 <tsahyt> c_wraith: different contexts meaning what here?
07:12:49 <c_wraith> tsahyt: different types that represent the computations you're doing.  Basically, you need an analogue to ST to go with your analogue to STRef
07:15:05 <nevere> What is a good library to send multipart html emails in Haskell?
07:16:17 <c_wraith> nevere: are you looking for something that also does the SMTP, or just for something for composing the email?
07:17:01 <nevere> c_wraith: Need something that also does the SMTP..
07:17:14 <Cale> nevere: The receiving part is a bit... janky
07:17:32 <tsahyt> c_wraith: hmm. I think I might be able to come up with a more indirect way to do this here. but back to the original handle, how could you pass this out? I've now tried using an IORef and I get a compile time error about type variable s escaping its scope
07:17:35 <Cale> There's postie, which will get you... most of the way
07:17:36 <c_wraith> nevere: I actually know of nothing in that area at all.  Just prompting additional information for people that do. :)
07:17:53 <c_wraith> apparently like Cale :)
07:18:36 <c_wraith> tsahyt: It's less about passing it out, and more about creating one and then sharing it in a bunch of computations.  
07:19:11 <c_wraith> tsahyt: Since you don't bind the lifetime of a handle to a single computation
07:19:14 <tsahyt> well what I need to prevent is sharing it outside of this wrapper function. anything that happens "below" this function is fine
07:19:27 <tsahyt> what the wrapper does is creating the handle and tearing it down on exit/exception etc
07:19:31 <c_wraith> tsahyt: nothing prevents creating it outside the wrapper function though
07:19:50 <tsahyt> how? I'm not exporting anything that could possibly create it
07:19:55 <c_wraith> ah, except for not exporting any functions to do so. :)
07:20:09 <tsahyt> ahh, so you were referring to something like newSTRef
07:20:23 <c_wraith> tsahyt: but in that case, you have no way to prevent it from being used wherever it's in scope
07:20:34 <tsahyt> good. I was getting worried there for a moment, because a lot of the memory correctness of this library hinges on this thing not leaking out
07:20:59 <c_wraith> Well, it can leak in an existential, but..  that doesn't actually make it usable if it does.
07:20:59 <tsahyt> it's fine to share it. well, except for this one particular part.
07:21:47 <c_wraith> Err, maybe an existential is enough.
07:21:58 <tsahyt> yeah as long as it's not usable that's okay. it's really just a pointer underneath and when that becomes invalid and functions get called on it, bad things happen
07:22:25 <c_wraith> what's the type of some arbitrary function that uses a Handle?
07:23:03 <tsahyt> MonadIO m => Handle s -> Foo -> Bar -> m ()
07:23:09 <tsahyt> something of that form
07:23:16 <tsahyt> () might be some other concrete type
07:23:20 <c_wraith> Ok..  Then existential leakage is actually enough.
07:23:27 <tsahyt> how so?
07:24:47 <c_wraith> data ExtHandle where WrapHandle :: Handle s -> ExtHandle.  then run an action that's essentially return . WrapHandle
07:25:20 <c_wraith> Then outside of the wrapper, you can pattern-match on WrapHandle and use any function that works on Handle values
07:25:46 <tsahyt> well crap
07:25:47 <c_wraith> It doesn't matter that the exact type of s is unknown
07:25:55 <tsahyt> I'm not gonna change that though, because I won't rewrite the whole thing again
07:26:07 <vozz> Does anyone know of any Haskell certifications? Do they exist?
07:26:09 <c_wraith> You need to bind the reference type to the context to prevent that leakage from working.
07:26:10 <tsahyt> if a user goes out of their way that far to break it, it's none of my business
07:26:40 <Cale> vozz: Not as far as I'm aware.
07:27:58 <c_wraith> vozz: if you can explain the operational semantics of foldr and answer a few intermediate-level type questions, I'll offer my personal certification, all for a low fee of $0 :)
07:27:58 <Cale> vozz: It's actually a bit interesting to have people asking about that -- the scale of industrial use of Haskell is yet small enough that I'm not sure it makes sense to have a separate organisation just for doing that.
07:28:03 * hackagebot smsaero 0.6.2 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.6.2 (NickolayKudasov)
07:28:11 <tsahyt> c_wraith: this might seem stupid, but what if I don't export the Handle type constructor?
07:28:37 <tsahyt> other than making the library a pita to use
07:28:46 <c_wraith> tsahyt: I...  think that would work, but it makes things a royal pain.  Yeah. :)
07:28:55 <vozz> I'm being made to do a Java one for work and I'm actually surprised at how good it is, it'd be really cool to do something like it for Haskell.
07:30:06 <tsahyt> yeah, it segfaults with the existential thing
07:30:06 <Tuplanolla> What is the use of certification?
07:32:06 <c_wraith> seriously, though, the full operational semantics of foldr are surpringly subtle.
07:32:28 <Cale> Tuplanolla: I would tend to see it as a way for job interviewers throughout the industry to share some of the workload of verifying that a candidate can do what they say they can.
07:32:56 <tsahyt> c_wraith: so what's keeping me from having an existential wrapper around a STRef then?
07:33:11 <c_wraith> tsahyt: you can create one, but it ends up not being usable after unwrapping.
07:33:24 <Tuplanolla> I can see how that can be useful for some people.
07:33:29 <tsahyt> oh right because all the functions on it bind to an ST s context
07:33:31 <c_wraith> tsahyt: that's because the type variable s in the STRef must match the type variable s in ST s
07:34:05 <tsahyt> I might fix that one day. It'd require a custom monad, but then you can at least still build arbitrary stack on that base so there's that
07:34:20 <tsahyt> the reason why I have this general signature atm is really because I want to limit the user as little as possible in their choice of monad
07:34:30 <vozz> I don't doubt the quality of a c_wraith certification :) There are a few MOOC courses though aren't there?
07:34:32 <tsahyt> but since this compromises safety..
07:34:50 <c_wraith> tsahyt: the custom monad would also solve your original problem - the subcomputation would just be run in a different custom monad. :)
07:34:55 <Tuplanolla> How's the Java certification like, vozz? Is it like a bunch of puzzles from the puzzle book?
07:35:55 <c_wraith> tsahyt: it could be a custom transformer, even.  kind of like lightweight monadic regions.
07:36:41 <c_wraith> ...  given that monadic regions are also about solving this exact problem...
07:36:41 <ongy> Cale: also, grab some money from people that are in the job market
07:37:21 <c_wraith> I've never seen someone fake Haskell knowledge the way I've seen done with some other languages.
07:37:33 <Cale> ongy: Haha, yes.
07:37:34 <c_wraith> That pattern can't last forever, though.
07:39:12 <quchen> vozz: I heard the courses by FP complete are really good. You don’t get a certificate, but it’s probably as close as it gets.
07:39:23 <slack1256> has anybody bought used ergonomic keyboards? if so where?
07:39:41 <reactormonk> c_wraith, "fake knowledge" as in?
07:39:42 <c_wraith> quchen: those are probably fantastic, but they can't be done as self-study online. :)
07:39:58 <reactormonk> slack1256, still waiting on that keyboard 101
07:40:02 <c_wraith> reactormonk: some people try to pass developer interviews without actually knowing how to program.
07:40:05 <ongy> I think I have some proof that I passed my course that used haskell, is that a haskell-certificate?
07:40:07 <quchen> They’re really close by, if you happen to live in London in October. ;-)
07:40:12 <reactormonk> slack1256, ehh wait.
07:40:34 <c_wraith> reactormonk: I've never seen that from someone that claims to know Haskell not actually know Haskell, though. :)
07:40:43 <reactormonk> slack1256, found it. Model 01
07:40:53 <slack1256> I don't know haskell, I know lambdabot
07:41:05 <slack1256> (sorry my keyboard question, I thought this was blah)
07:41:19 <reactormonk> yeah, google model 01
07:41:34 <quchen> c_wraith: I’ve seen plenty. 5/10 Haskell, does not know folds.
07:41:43 <ongy> slack1256: are you saying we are off topic? :)
07:41:54 <reactormonk> quchen, what does 5/10 mean here?
07:42:16 <c_wraith> quchen: In all honesty, I was writing lots of production software in Haskell before I knew how to write foldl with foldr. :)
07:42:50 <quchen> c_wraith: I’m not talking about subtleties here, but really having no idea about folds, and struggling with basic syntax.
07:43:14 <Tuplanolla> Could there be a Haskell Puzzlers book like there's the Java Puzzlers book?
07:43:27 <quchen> c_wraith: By the way, I regularly forget foldl in terms of foldr, and it’s a great experience to rediscover it every couple of months ;-)
07:43:41 <quchen> The gift that keeps on giving!
07:43:56 <c_wraith> quchen: I figured it out late one night a couple years ago, just to answer a SO question that asked about it. :)
07:44:00 <frontendloader> I tried learning haskell several times between 3-5yr ago, and still don't know what a monad is
07:44:10 <frontendloader> now I just sit in here :/
07:44:10 <c_wraith> And by late, I mean it was about 3am when I finished.
07:44:31 <vozz> Tuplanolla: it's basically training you to do the job of the compiler, so a lot of whacky code that you have to figure out compiler errors or output for. It feels very thorough, and gives you knowledge for occasional weird issues you might run into. 
07:44:35 <ongy> I'd have to check which one is which first.... I think I know the difference, but I'm not 100% sure I understand it
07:44:35 <frontendloader> and write enterprise java at my job
07:44:58 <Tuplanolla> Ah, I take that as a yes, vozz.
07:45:22 <c_wraith> frontendloader: just hanging out here is actually a good way to learn.  It's what I did to go from beginner -> intermediate in Haskell.
07:46:34 <frontendloader> I can write /some/ haskell, but its a slow process and I get types wrong all the time
07:46:45 <vozz> Never seen this puzzle book :) yeah something similar for Haskell would be cool
07:47:29 <Tuplanolla> I read it when I wrote more Java, vozz. Most of the puzzles are quite trivial, but there are some interesting surprises in there.
07:48:00 <Tuplanolla> For example `return` and `finally` interact in silly ways.
07:48:53 <ongy> they do?
07:49:57 <frontendloader> finally runs even after a return
07:49:57 <quchen> C’s return and Haskell’s return interact in silly ways.
07:50:11 <ongy> that's why we use pure :)
07:50:24 <haasn> Lack of a C return in haskell pisses me off quite often
07:50:29 <haasn> What monad do I add to allow early return
07:50:34 <quchen> Cont
07:50:35 <ongy> Maybe
07:50:38 <ongy> oh, maybe doesn't sorry
07:50:51 <haasn> I had a feeling it was cont, but I've never really used cont in practice enough to understand how I use it
07:51:18 <quchen> For *C* return, consider unsafeCoerce in random place
07:52:04 <haasn> Say I want to type type MyMonad = .... such that I can write a foo :: String -> MyMonad Bar  in which I can write something like:  when (<partial check is true>) $ earlyReturn someValue
07:52:14 <haasn> where someValue :: Bar
07:52:48 <haasn> sort of like how in C I often write if (error condition) { return false; }
07:52:49 <quchen> callCC (\earlyReturn -> … when (partial check) (earlyReturn someValue) ...)
07:53:20 <haasn> hmm
07:53:20 <quchen> callCC is pretty much exactly “allow early returns from this argument”
07:53:40 <haasn> So I'd write something like foo = callCC $ \ret -> do <newline> and then use ‘ret’ to return anywhere I want to?
07:54:05 <quchen> No, when »ret« is evaluated, the result of the entire callCC is ret’s argument.
07:54:28 <haasn> That's what I mean by ‘return’
07:54:32 <haasn> Not sure what else it's supposed to mean
07:54:40 <haasn> ‘return foo’ means the result of the entire thing is ‘foo’
07:54:48 <nitrix> No in Haskell.
07:54:52 <quchen> You don’t return »anywhere«, you jump to the end of the callCC block
07:54:52 <nitrix> *Not in Haskell.
07:55:07 <haasn> Oh, we're using ‘anywhere’ differently
07:55:17 <haasn> I mean return out of ‘foo’ anywhere inside foo
07:55:24 <Tuplanolla> From anywhere, not to anywhere.
07:55:31 <quchen> Exactly, Tuplanolla.
07:55:39 <haasn> Yes, that's what I meant
07:55:53 <quchen> If you want to jump around more, you can nest callCCs. 
07:56:06 <nitrix> People usually call this sort of function `abort`.
07:56:12 <Tuplanolla> So... how about a `longjmp` monad?
07:56:17 <quchen> And if you want to go really wild you can use it to implement Goto and have all the unstructured terrible code that you know and love from the 60s. :-)
07:57:03 <nitrix> Hey, it got us on the moon.
07:57:22 <quchen> Yes, and sailboats brought us to the Americas.
07:58:04 <hexagoxel> didn't we have this discussion like half a day ago?
07:58:33 <ongy> so, #haskell is history?
07:58:38 <nitrix> Presumably, Haskell is growing an interest amongst the C crowd :)
07:58:46 * hexagoxel still believes that EitherT is completely sufficient for early returns, but has no better arguments than before.
07:59:12 <hodapp> first-class return is a curious thing to think about.
07:59:28 <nitrix> And/or combined with MonadPlus.
07:59:28 <haasn> EitherT is good for fail-anywhere
07:59:32 <haasn> but it's not good for early positive return
07:59:33 <haasn> if that makes sense
07:59:46 <nitrix> MonadPlus offer choice and failure :)
08:00:03 <haasn> the problem is that Either deliberately separates the type of ‘error’ conditions to a fixed parameter ‘e’ which is constant in your stack
08:00:41 <haasn> you'd need to have your EitherT layer on the outside and constantly wrap/unwrap it
08:00:43 <haasn> on a per-function basis
08:00:54 <haasn> which doesn't exactly generate much cleaner code than the nested ‘when’ blocks I'm trying to avoid
08:01:25 <nitrix> ConT seemed like a good approach.
08:01:40 <zipper> What is the point of signum?
08:01:47 <zipper> `signum`
08:02:02 <ongy> > signum 1
08:02:04 <lambdabot>  1
08:02:05 <ongy> > signum (-1)
08:02:07 <lambdabot>  -1
08:02:23 <hodapp> zipper: some operations are just much simpler to write with it available.
08:02:28 <ongy> well, that shows it pretty well... The sign of a number can be pretty useful for some arithmetic
08:02:41 <quchen> haasn: If it helps, I wrote about Cont some time ago. https://github.com/quchen/articles/blob/master/cont_monad.md
08:02:58 <quchen> It’s a text on a monad though, possibly subject to the usual fallacy.
08:03:12 <zipper> > (-1)
08:03:14 <lambdabot>  -1
08:03:23 <hodapp> > signum (-10)
08:03:25 <lambdabot>  -1
08:03:26 <zipper> I see no need for signum but whatever
08:03:31 <zipper> hmmmm
08:03:35 <Tuplanolla> Take a look at `man copysign`, zipper.
08:03:40 <zipper> hodapp: Ok that was interesting
08:03:51 <Sose> > signum 0
08:03:53 <lambdabot>  0
08:03:54 <ongy> yeah, my example was just stupid
08:04:07 <tsahyt> zipper: It just gives you the sign of the number, represented by -1 or 1
08:04:12 <ongy> > let abs x = x * (signum x) in abs (-26523)
08:04:14 <lambdabot>  26523
08:04:48 <hodapp> I've used it in algorithms where otherwise I'd have required a branch or something like that.
08:04:50 <tsahyt> zipper: that is pretty useful in lots of operations, say methods for calculating determinants
08:04:57 <hexagoxel> haasn: but the type of the value that you return early _must_ be constant.
08:05:14 <Carl`> ^ determinants, good example
08:05:20 <hexagoxel> or is this about fmap for ContT being easier than \f -> bimapEitherT f f?
08:05:45 <ClaudiusMaximus> > signum (1 :+ 1) -- works for complex numbers too.  ongy i think you need to divide?  abs * signum = id  or so
08:05:47 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
08:05:48 <haasn> hexagoxel: that seems like a given. If you have a foo :: MyMonad Bar, I already know it's going to return a Bar. But the point is that I can use ‘do bar <- foo; somethingElse <- bat’ where ‘foo’ and ‘bat’ have different types, while staying inside the same monad
08:06:08 <haasn> Can't do that with EitherT, unless you want ‘do bar <- either id id <$> runEitherT foo ’ or stuff like that
08:06:12 <hodapp> ClaudiusMaximus: division by 0 is going to cause some problems with that
08:06:25 <hodapp> multiplying by -1, 0, or 1 should be fine
08:06:37 <ClaudiusMaximus> hodapp: but complex numbers will rotate the wrong way
08:06:54 <haasn> hexagoxel: although based on your second comment it sounds like that's sort of what you're proposing?
08:06:57 <seishun> I was looking for MD5 implementation and found cryptohash, which says it's deprecated and points to cryptonite which doesn't have MD5. Should I just use pureMD5?
08:06:57 <ongy> ClaudiusMaximus: probably, I don't work in C often, usually just R
08:07:05 <hodapp> I am supposed to give a talk on R in a week
08:07:11 <hodapp> R makes me cringe but some stuff is really easy in it
08:07:16 <haasn> runExceptT*
08:07:20 <hodapp> I need to see if my distro's issues on HaskellR are solved yet
08:07:29 <zipper> Ok I think I get it now
08:07:37 <hexagoxel> haasn: so neither foo nor bat can early-return?
08:08:13 <haasn> both ‘foo’ and ‘bat’ can early return in this example, that's the point
08:08:44 <hexagoxel> but then they would have types EitherT e m a and EitherT e m b, so the same monad
08:08:54 <grantwu> > let x = [1, 2, 3] in [x, x, x]
08:08:57 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
08:08:59 <haasn> I guess at the end it comes down to whether I want to write foo = evalContT . callCC $ \ret -> do ...  or bar = fmap (either id id) . runExceptT $ do ...
08:09:14 <shapr> @quote
08:09:14 <lambdabot> otters says: lens law #1: the implementation must be shorter than the type
08:09:18 <quchen> seishun: MD5 is not cryptographic, so it makes sense to not have it in a crypto lib.
08:09:23 <ongy> grantwu: trying to tell us something?
08:09:24 <haasn> but the advantage of the former is that I could reuse the same ContT in my stack and move the ‘evalContT’ to the top level of my program
08:10:03 <haasn> hexagoxel: Yes, which is a contradiction, which is why I said you can't do it with ExceptT unless you constantly wrap and unwrap an ExceptT from the top level
08:10:06 <haasn> not sure where we're going with this
08:10:06 <quchen> seishun: Nevertheless, cryptonite does support it. Probably for legacy reasons.
08:10:07 <grantwu> ongy: no, sorry, just trying something out I saw on Hacker News.  Probably should've used a pm for it
08:10:10 <quchen> http://hackage.haskell.org/package/cryptonite-0.20/docs/Crypto-Hash-Algorithms.html
08:11:55 <seishun> no usage examples though
08:12:39 <nitrix> grantwu: If you're curious, the `x` is supposed to be monomorphic and shared for the three x's there; so it'd be computed only once had the example been more computationally intensive.
08:14:24 <nitrix> grantwu: let x = length [1..100000000] in repeat x, you'll see what I mean.
08:14:42 <shapr> I really want a github repo of usage examples for Haskell libraries, starting from the most popular on down.
08:15:07 <nitrix> grantwu: You'll get a long pause for the length of the first element being computed, then the rest of the list will be very fast :)
08:15:14 <quchen> shapr: 24 days of Hackage?
08:15:20 <nitrix> grantwu: I don't know if that's what you were toying with?
08:15:20 <grantwu> Hrm, wouldn't that get computed at compile time
08:15:28 <hexagoxel> haasn: i will have to think more what ContT in middle of stack gives you. still seems to be more/different than just early return :)
08:15:33 <shapr> quchen: yes!
08:15:57 <sm> shapr: sounds nice, what would be the maintenance strategy ?
08:16:02 <grantwu> nitrix: no, I am just very tired and for a moment thought that code snippet I posted had an infinite type
08:17:00 <haasn> hexagoxel: I think conceptually, ContT gives you nothing more than simply inserting an ExceptT wrapper wherever you would otherwise use ‘callCC’
08:17:09 <haasn> although it might simply be nicer to use
08:17:11 <nitrix> :t foo 42 = 42; foo x = foo
08:17:13 <lambdabot> error:
08:17:13 <lambdabot>     parse error on input ‘=’
08:17:13 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
08:17:18 <nitrix> :t let foo 42 = 42; foo x = foo
08:17:20 <lambdabot> <no location info>: error:
08:17:20 <lambdabot>     not an expression: ‘let foo 42 = 42; foo x = foo’
08:17:30 <nitrix> I hate lambdabot :(
08:17:51 <nitrix> How am I supposed to do a multi-line let?
08:17:58 <quchen> I would hate Lambdabot if it allowed non-Haskell expressions.
08:18:10 <quchen> > let x = 1:y; y = 0:x in x
08:18:12 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
08:18:28 <nitrix> Mhhh, oh I see.
08:18:35 <nitrix> @let foo 42 = 42; foo x = foo
08:18:37 <lambdabot>  .L.hs:160:1: error:
08:18:37 <lambdabot>      • Occurs check: cannot construct the infinite type:
08:18:37 <lambdabot>          t ~ Integer -> t
08:18:39 <quchen> “let” works a lot better when you prefix its body with “let” ;-)
08:18:42 <nitrix> There's your infinite type :D
08:19:08 <quchen> That one cannot be typed at all, can it?
08:19:20 <haasn> it can be typed, I think
08:19:21 <shapr> sm: I'd track the latest stack LTS for maintenance, try to do updates every six months or so.
08:19:26 <shapr> and also accept PRs :-P
08:19:47 <nitrix> quchen: afaik they aren't allowed.
08:19:54 <sm> six months! This is 2016 man :)
08:20:07 <shapr> sm: what's better?
08:20:07 <haasn> Oh no, ‘f x = f’ can't be typed
08:20:18 <haasn> because the type of f would be a -> <type of f>
08:20:28 <shapr> sm: I'd prefer that examples get integrated into the libraries they use, then the maintainers get to do that work.
08:20:34 <haasn> The f 42 = 42 line is irrelevant
08:20:37 <sm> shapr: how do you mean track the latest stack for maintenance ?
08:20:47 <quchen> :t let f [] = (); f (x:xs) = f (zip xs xs) in f
08:20:48 <lambdabot> error:
08:20:48 <lambdabot>     • Occurs check: cannot construct the infinite type: b1 ~ (b1, b1)
08:20:49 <lambdabot>       Expected type: [(b1, b1)] -> ()
08:20:53 <quchen> :t let f [] = (); f (x:xs) = f (zip xs xs) in f
08:20:54 <lambdabot> error:
08:20:54 <lambdabot>     • Occurs check: cannot construct the infinite type: b1 ~ (b1, b1)
08:20:54 <lambdabot>       Expected type: [(b1, b1)] -> ()
08:20:56 <sm> hmm, doesn't that goal continually make your repo unnecessary ?
08:21:03 <quchen> :t let f :: [a] -> (); f [] = (); f (x:xs) = f (zip xs xs) in f
08:21:05 <lambdabot> [a] -> ()
08:21:10 <quchen> That is one that can be typed, but not inferred
08:21:19 <hexagoxel> haasn: i think uses of ContT for with(Ptr) type functions cannot be expressed with EitherT/ExceptTand i am mildly certain that you could not expressed that with EitherT/ExceptT.
08:21:33 <shapr> sm: yup, I'd much rather create examples for the libraries and then push them into the library repo
08:21:33 <hexagoxel> whoops
08:21:55 <c_wraith> hexagoxel, but shouldn't you be using Codensity for that purpose? 
08:22:07 <sm> shapr: I see, so a temporary repo as part of an initiative to increase examples included in library docs.. hmm
08:22:25 <hexagoxel> c_wraith: "should" for what reason?
08:22:33 <sm> maybe you don't need a repo, more of a status report/dashboard ?
08:22:43 <shapr> hm, yeah
08:23:03 <shapr> Then motivated coders can see which libraries still need examples.
08:23:19 <c_wraith> hexagoxel, it's smaller... in that it can express fewer things, so you're more restricted to doing what you mean to do. 
08:23:22 <sm> yeah. I would be concerned about having just another unknown place for contributions to disappear into
08:23:49 <shapr> that's a fair point
08:24:35 <hexagoxel> c_wraith: ah, fair. that might be the case. certainly possible given that i am not sure how powerful ContT really is :)
08:25:18 <shapr> sm: motivation stems from hearing "Haskell libs don't have good examples" for the past few years.
08:25:40 <sm> indeed!
08:26:27 <sm> related, the new "haskell tutorial and cookbook" book seems to have a few good ones
08:26:45 <haasn> hexagoxel: I'm not familiar with that use, how does it work?
08:27:04 <haasn> withFoo $ \foo ->  withBar $ \bar ->  ...   gets transformed to?
08:28:09 <sm> shapr: probably one good way to get traction would be to add something to hackage package pages
08:29:15 <sm> a lot of things seem to come back to "add features to hackage"
08:29:30 <shapr> sm: can you think of something better than manual annotation? Does cabal have an examples stanza?
08:29:37 <c_wraith> haasn, something like foo <- ContT withFoo ; bar <- ContT withBar ;... 
08:30:02 <c_wraith> haasn, I'm probably a bit off, but it's close to that. 
08:30:11 <sm> well, eg a prominent colourful icon or percentage showing at a glance which packages have examples (and being able to search/sort by that)
08:30:31 <hexagoxel> c_wraith: seems reasonably accurate
08:31:39 <davean> shapr: Litterate Haskell rendered into publication worthy PDFs?
08:32:05 <shapr> Although I've seen examples (github) where examples exist, but haven't worked for several versions.
08:32:15 <davean> shapr: We should talk ... not here
08:32:18 <shapr> davean: sounds pretty, but working code is all I want
08:32:36 <sm> red: no examples, amber: untested examples, green: tested examples :)
08:36:03 <hexagoxel> haasn: maybe a more complex example: ([[B]] -> IO b) -> [[A]] -> (forall r . B -> (A -> IO r) -> IO r) -> IO b
08:37:09 <shapr> sm: I like it, simple and straightforward. Once examples exist, then we can quibble about depth/size/quality.
08:38:08 <hexagoxel> haasn: can be implemented via something along runContT (mapM (mapM _ _) _)
08:39:28 <sm> shapr: so how do we detect examples, I wonder
08:39:31 <Benzi-Junior> hey can typeclasses be used to define data, i.e. if one where to instanciate the class you would give a constructor for the new data type rather than a function ?
08:39:46 <sm> doctests in haddock = tested examples ?
08:39:54 <haasn> c_wraith: ooh, that makes sense. Because you essentially use ContT to build up a log of what other function call you eventually need to call to wrap that part of your program in so you can access the intermediate result you're using inside the rest of that ContT?
08:40:16 <sm> other haskell code in haddock = nontested examples ?
08:40:27 <shapr> sm: simplest would be to assume that a cabal test-suite stanza includes examples, but an explicit examples stanza might be better?
08:40:28 <sm> s/haddock/haddock&readme/
08:40:47 <c_wraith> haasn, I dunno. I just make the types work. :) 
08:41:02 <sm> oh you would count test suites as examples ? I wouldn't
08:41:04 <haasn> hexagoxel: I don't understand what that's supposed to be an example of; that type reads like nothing I can make sense of
08:41:15 <unskill> haasn: I've found <*>  easier to understand than liftA2
08:41:29 <haasn> fair enough
08:41:29 <shapr> tests can easily be worthwhile but inscrutable, I'd like for every vaguely popular library to include a "hello world" example and a "stereotypical usage" example.
08:41:46 <haasn> They're really similar anyway
08:41:53 <haasn> since (<*>) is just liftA2 id
08:42:12 <haasn> You could either claim (<*>) is a generalization of liftA2, or vice versa :)
08:42:46 <haasn> (because in reality, they're equivalent)
08:42:59 <hexagoxel> haasn: you have a [[A]] and a with-function on A that "exposes" B, and want to use [[B]] -> m x
08:43:15 <unskill> haasn: you just need to look at (<*>) more closely. Did you see ~12 hrs ago dialog here?
08:43:16 <ongy> :t liftA2
08:43:17 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:43:25 <unskill> :t (<*>)
08:43:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:43:46 <hexagoxel> haasn: supposed to be an example where ContT is "useful"
08:43:51 <sm> shapr: I guess a first step would be a tool that checks a local package and reports the presence of examples
08:44:34 <shapr> How could that be done? Code coverage?
08:45:21 <unskill> Better to explicitly add parens: Applicative f => f (a -> b) -> (f a -> f b) and you see that Applicative is a functor which preserves internal homs. And (<*>) turn internal hom f (a->b) into non-internal one (f a -> f b)
08:45:43 <sm> well, eg the things I suggested above: if there are doctests, we have tested examples; otherwise if there is haskell code in haddocks/package description/readme, we have untested examples
08:46:13 <hexagoxel> Benzi-Junior: sounds like https://wiki.haskell.org/GHC/Type_families#An_associated_data_type_example
08:46:53 <haasn> Benzi-Junior: also if that's your only use for a type class, it sounds like you just want to use a regular data family instead
08:49:17 <haasn> although I'm not sure if there's a useful example of a data family that's not in connection with some type class that actually gives its instances meaningful operations
08:49:44 <Benzi-Junior> hmm 
08:50:00 <Benzi-Junior> it looks  like I should have a more in depth look at those
08:51:31 <c_wraith> haasn, I've done that before. 
08:52:13 <haasn> c_wraith: got an example?
08:52:23 <c_wraith> haasn, I had a data family associated with a free monad construct. the interpreter also defined the data instance. 
08:53:45 <c_wraith> I mean, multiple interpreters could also use the same instance, but it let the interpreter choose the data representation for values created and used in the free monad.
08:54:38 <haasn> I'm not sure if I can visualize that example from that description alone. If your only concern is allowing the interpreter freedom to choose the representation, why not just use regular polymorphism?
08:55:01 <shapr> Has anyone seen a ":help" command for ghci that does the same thing as Python's "help(reduce)" ? Something that would return the haddock for a function?
08:56:09 <c_wraith> haasn, because the free monad was also doing the ST thing, where a phantom type variable was attached to the constructed values. 
08:59:16 <haasn> c_wraith: the phantom type was a parameter to the data family, to keep the data type consistent?
08:59:21 <haasn> or something like that?
09:00:20 <glguy> shapr: There is/was such a utility on hackage
09:00:44 <c_wraith> haasn, basically. I should put this example online sometime. I'll probably have to rewrite it. 
09:01:02 <shapr> glguy: do you happen to remember the name?
09:01:16 <glguy> Nope, but I'm trying
09:01:31 <shapr> thanks, I'm also trying to discover the name
09:02:01 <glguy> http://hackage.haskell.org/package/haskell-docs
09:02:26 <shapr> glguy: thanks!
09:03:26 <shapr> ah, another chris done package
09:11:23 <Eduard953> hi
09:11:38 <lambdabot> Hello.
09:12:14 <Eduard953> could someone of you help me with some haskell stuff?
09:12:48 <yushyin> Eduard953: just ask
09:13:09 <byorgey> Eduard953: there are lots of people here who can help, just go ahead and ask your questions, and if there is someone willing & able to answer your question they will.
09:13:59 <seishun> is there a way to pattern match on an n-character string that contains a '_' anywhere inside it?
09:14:18 <cocreature> seishun: no
09:14:21 <haasn> seishun: Not directly, at least not in any clean way
09:14:24 <byorgey> seishun: no, just use a guard with  '_' `elem` theString
09:14:40 <cocreature> you could use ViewPatterns but you don’t gain anything by doing so
09:14:53 <haasn> or a view pattern, if you need this to be part of a larger pattern match and don't need more checks than that
09:15:44 <seishun> alternatively, any better way to pattern-match on a string with '_' in a specific position other than `fun (c1:c2:c3:'_':xs)`?
09:15:44 <haasn> yeah even then, you gain nothing from writing f (check -> True) = ... over f x | check x = ...
09:16:03 <Eduard953> i need to write a function which makes the following: Main> lines "some text .. blubbla\n more text bla\n end of the text brhbla\n
09:16:20 <haasn> seishun: if you know the string length you could do something like [_,_,_,'_',_,_] but that's about it
09:16:20 <Eduard953> and it has to get into a list without \n
09:16:23 <haasn> and that only covers one case
09:17:35 <EvanR> what would it give you if there more than one _?
09:18:07 <Eduard953> isPoem 3 "some text ….. blubla\n more text … bla\n end of the text brrhbla" => True does someone know how to write this function?
09:18:33 <byorgey> Eduard953: is this an assignment for a class?
09:18:34 <haasn> Eduard953: yes, but have you tried writing it? and if so, where did you get stuck?
09:19:03 <Eduard953> yes it is an assignment for class, but i just do not know how
09:19:38 <oherrala> Can you write in text how you would solve it?
09:19:54 <byorgey> Eduard953: we are happy to help if with specific questions, for example "I wrote this function but I don't understand why I get output X instead of Y", or "can someone explain this type error I am getting"
09:20:04 <byorgey> Eduard953: but we will not do your asignment for you.
09:20:15 <Eduard953> i know
09:20:15 <seishun> I also have a list of elements... let's say (Char, Int) for simplicity, and I need to pattern-match if the Int denotes an index in the string that contains '_'. If all patterns fail, I pick the next element from the list
09:20:19 <byorgey> Eduard953: if you are unsure how to even start you should probably go talk to your instructor or TA
09:20:22 <haasn> Alternatively, can you find a simpler function that you do know how to write
09:20:31 <haasn> Like doing it for a single \n instead of arbitrarily many
09:21:09 <seishun> since there are only 8 characters in the string, I think I'll just write a pattern for each
09:22:41 <haasn> seishun: given (c,i,s) you want to see the character at the position ‘i’ in the string ‘s’ is equal to ‘c’?
09:22:51 <haasn> Why do you need a pattern match for that?
09:23:11 * hackagebot dhall 1.0.1 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.0.1 (GabrielGonzalez)
09:25:31 <codedmart> If I have `data FilterValue = FilterText Text | FilterNumber Double | FilterBool Bool` and need a func `toFilterValue :: Text -> FilterValue`. What is the most effcient way to handle that. I have a mix of `maybe` and `readMaybe` buts feels bloated and redundant.
09:26:26 <glguy> toFilterValue = FilterText   is going to be pretty efficient
09:28:17 <seishun> haasn: you're probably right and it can be done simpler, but I want to try it with pattern-matching anyway out of curiosity. I can show you the result later if you're interested
09:29:14 <codedmart> glguy: I get text in. So it could be "text", "2.31", "true". Which I would want as `FilterText "text"`, `FilterNumber 2.31`, or `FilterBool True`.
09:29:53 <haasn> seishun: solving that with pattern matching sounds like solving multiplication with case x of 0 -> 1; 1 -> y; 2 -> y+y; 3 -> y+y+y; 4 -> y+y+y+; ...
09:30:21 <haasn> 0 -> 0 *
09:31:25 <byorgey> codedmart: I don't think there's any way to avoid calls to readMaybe and case analysis.
09:31:43 <codedmart> byorgey: OK that is the answer I was looking for. Thanks!
09:31:44 <glguy> codedmart: You could generate a lexer (alex for example)
09:32:00 <haasn> sounds like codedmart is doing string parsing
09:32:01 <glguy> which could efficiently check for the longest match
09:32:14 <haasn> in which case a parser/lexer/whatever-type library would probably end up the most efficient, depending on which one you pick
09:32:40 <codedmart> Thanks guys, will take a look.
09:37:05 <Josue> hi
09:37:19 <lambdabot> Hello.
09:37:30 <Josue> im new on the irc
09:37:40 <Josue> this seems pretty awesome
09:37:58 <EvanR> "whoa"
09:40:39 <seishun> haasn: http://lpaste.net/7115016344080220160 "password" function
09:42:20 <Josue> seishun, wat is the program for?
09:42:28 <seishun> advent of code
09:42:28 <lpaste> glguy pasted “for codedmart - alex example” at http://lpaste.net/3473286111780929536
09:42:53 <codedmart> glguy: Thanks!
09:43:42 <byorgey> Josue: welcome!
09:44:20 <Josue> ty byorgey 
09:45:13 <Josue> wat do u guys talk about in here
09:45:27 <Eduard953> isPoem 3 "some text ….. blubla\n more text … bla\n end of the text brrhbla" => True
09:45:38 <Eduard953> i need to get a function for this
09:45:57 <maerwald> first you need a formal definition of what a poem is
09:46:00 <byorgey> Josue: this channel is for discussing the functional programming language Haskell --> https://haskell-lang.org/
09:46:14 <Josue> ohh ic
09:46:37 <Josue> is there any channels for hacking/pentest...
09:46:40 <Josue> ???
09:46:50 <glguy> This wouldn't be the right place to find out
09:46:58 <Josue> hahah k
09:48:01 <Eduard953> alexgordon можешь помоч
09:49:00 <alexgordon> Eduard953: Блядь ?
09:49:09 <maerwald> Eduard953: this is an english channel
09:49:24 <Eduard953> how to private message?
09:53:10 <ogkloo> ./q <name> <message>
09:53:13 <ogkloo> without the .
09:53:59 <alexgordon> Eduard953: I think you must have me confused with someone else
09:54:10 <alexgordon> someone who speaks russian
09:55:29 <Eduard953> I think not, you just do not know me cause i am freshman on the university
09:58:13 * hackagebot marvin 0.0.2 - A modular bot for slack  https://hackage.haskell.org/package/marvin-0.0.2 (justus)
10:01:31 <alexgordon> Eduard953: there are many alex gordons in this world, there's a baseball player and also a giant cat http://static.toomkygames.com/download-free-games/images/small/Alex-Gordon-320x240.jpg It's a common name
10:06:14 <glguy> alexgordon: You're not the giant cat, then?
10:06:25 <alexgordon> no comment
10:11:32 <grazie> is there a way to install the docs for any random package? such as https://downloads.haskell.org/~ghc/6.12.2/docs/html/libraries/containers-0.3.0.0/Data-Map.html#v%3Ainsert
10:11:45 <grazie> i.e. so I can view on computer rather than online
10:17:41 <sm> grazie: one way: stack haddock PKG-VERSION --open [--no-haddock-deps]
10:19:14 <byorgey> grazie: also, note the docs you linked are from a very old version of GHC.  I'm guessing you found them by googling.  If so I suggest you use  haskell.org/hoogle  instead.
10:20:26 <grazie> thank you both
10:21:01 <grazie> sm: do you know, should I run that command from the dir where I'm located or will stack put it somewhere central on system?
10:21:51 <grazie> byorgey: I noticed that about the version but it was still ok for my purposes, will obviously install proper version
10:23:05 <simg> hi, I'm trying to use https://hackage.haskell.org/package/zip-0.1.3. I've "successfully" extracted an entry from the archive but it has a type of ZipArchive ByteString. Probably obvious to you guys, but how do I get just the ByteString?
10:24:03 <grazie> dir not found  :  stack haddock containers-0.5.8.1 --open [--no-haddock-deps]
10:28:49 <unskill> (<*>) is unfortunate name. Should have been named (<$>).
10:30:14 <hexagoxel> simg: withArchive, probably with m==IO. of course that only gives you `IO ByteString`.
10:30:58 <simg> hexagoxel: IO bytestring would be ok, but what do you mean by m==IO ?
10:31:26 <grazie> found it
10:32:00 <hexagoxel> simg: the m in withArchive's signature
10:33:16 * hackagebot process-extras 0.7 - Process extras  https://hackage.haskell.org/package/process-extras-0.7 (DavidFox)
10:34:15 <unskill> :t (<$>)
10:34:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:34:17 <lpaste> simg pasted “Haskell Zip Archive Extraction” at http://lpaste.net/349562
10:34:59 <simg> hexagoxel: sorry to be dim :), would you be able to take a quick look at the code I just posted?
10:41:35 <hexagoxel> simg: you probably want to `accounts <- withArchive ..` and make it so that `importAccountFile :: EntrySelector -> ZipArchive ByteString -> ZipArchive AccountFull`
10:43:16 * hackagebot cabal-debian 4.35.6 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.35.6 (DavidFox)
10:44:01 <skapazzo> is there a zippers (Control.Zipper by Kmett) tutorial somewhere? Do you feel there is need for one? Or is it the wrong zippers library to focus on?
10:44:55 <unskill> :t <*>
10:44:56 <lambdabot> error: parse error on input ‘<*>’
10:44:58 <unskill> :t $
10:45:00 <lambdabot> error:
10:45:00 <lambdabot>     parse error on input ‘$’
10:45:00 <lambdabot>     Perhaps you intended to use TemplateHaskell
10:45:08 <simg> hexagoxel: but how would I pass the ZipArchive ByteString into parseHTMLInput :: ByteString -> IO (AccountFull)?
10:45:10 <unskill> :t (<*>)
10:45:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:45:13 <unskill> :t ($)
10:45:14 <lambdabot> (a -> b) -> a -> b
10:45:17 <glguy> unskill: You can play with lambdabot in /msg
10:45:29 <unskill> k
10:45:54 <unskill> But. ($) is (<*>) for identity functor, isn't it?
10:47:28 <hexagoxel> :t [liftA2 ($), (<*>)]
10:47:30 <lambdabot> Applicative f => [f (a -> c) -> f a -> f c]
10:49:20 <unskill> (<*>) should be renamed into (<$>) and (<$>) into "amap"
10:52:00 <hexagoxel> simg: (>>=) and liftIO
10:54:57 <simg> hexagoxel: what I mean is, how do I deconstruction ZipArchive ByteString into ByteString? Looking at zip source there is a unZipArchive function but that isn't exposed. https://github.com/mrkkrp/zip/blob/5d907576203b5732760e409bf85cd8724f888602/Codec/Archive/Zip.hs
10:55:05 <hexagoxel> :t \f x -> x >>= liftIO . f -- simg
10:55:07 <lambdabot> MonadIO m => (a -> IO b) -> m a -> m b
10:57:48 <simg> hexagoxel: hmm, interesting. will think about that for a bit, thanks
10:58:16 <hexagoxel> simg: even though your code already made use of the fact, i think you have not really realized that ZipArchive is a monad :)
10:58:20 <davean> meta-actrl/buf34
10:58:58 <simg> hexagoxel: oh no, I realise it's a monad alright. it's just that doesn't help me :)
11:00:37 <hexagoxel> simg: then: what is the type of `\content -> liftIO (parseHTMLInput content)`?
11:03:10 <simg> hexagoxel: it will be IO (AccountFull), but at the moment it just prints out debug messsages using putStrLn
11:06:45 <hexagoxel> simg: it should at least be a function type, and even then..
11:07:59 <simg> hexagoxel: I think I'm missing something fundamental. am I supposed to extract archives out of withArchive before doing anything to them?
11:08:05 <Drezil> fizruk: that link is for servers and "only" or specifically for servant .. i just need something using a simple thing like http-conduit or so..
11:08:18 * hackagebot process-extras 0.7.1 - Process extras  https://hackage.haskell.org/package/process-extras-0.7.1 (DavidFox)
11:08:50 <hexagoxel> simg: no, that is not strictly necessary (but also possible)
11:10:14 <hexagoxel> simg: you probably just have not wrapped your head around how to make use of (a->IO b) in context of ZipArchive. But liftIO is all you need to make that work.
11:14:17 <simg> hexagoxel: I haven't totally wrapped my head around liftIO in any context :) though I am starting to get it.
11:17:16 <hexagoxel> simg: you should try answer the type question again, as IO AccountFull was mostly wrong.
11:19:18 <simg> hexagoxel: are you sure? bear in mind I'm using HXT for the html parsing, so it uses IO even though it could be pure
11:48:07 <grantwu> Spock and Scotty are supposed to be a lot easier to use than Yesod, right?
11:49:34 <c_wraith> they're supposed to have a lower barrier to entry 
11:49:56 <c_wraith> which is not the same as easier when things get larger. 
12:00:46 <Ben__> Hello all. I've created a gitter community for Haskell. If you're interested check it out https://gitter.im/haskell-chat/Lobby
12:07:42 <hoppfull> hello haskellers
12:10:31 <oherrala> hi
12:10:44 <shapr> howdy oherrala 
12:16:03 <[exa]> Hm guys. Why is monomorphism (the one from the restriction) called monomorphism?
12:16:52 <sm> I am monomorphism of restriction. Resistance is useless.
12:17:22 <[exa]> Like, does it have any relation to category monomorphisms?
12:17:24 <geekosaur> no
12:17:33 <[exa]> who invented the name?!
12:17:45 <[exa]> :D
12:17:47 <geekosaur> it means that the typechecker insists that some things not have a polymorphic type
12:18:09 <geekosaur> so something like `a = 5` that would normally be (Num a => a) is forced to be some specific type
12:18:25 <geekosaur> (with the defaulting rules in effect by default, that type will be Integer)
12:18:31 <hackrilege> Is there a way to import an lpaste into a lambdabot query?
12:18:34 <[exa]> yeah, that's what I got, and what led me to question the name. :D
12:18:46 <[exa]> Should be 'monotypic' afaik
12:19:00 <geekosaur> but we call the other one 'polymorphic'
12:19:11 <geekosaur> therefore it is 'monomorphic'
12:19:27 <[exa]> yeah it seems reasonable
12:19:32 <geekosaur> blame whoever wanted to show off their Greek :p
12:20:15 <[exa]> funny how a bit of wrong naming can cause such amount of confusion
12:20:27 <geekosaur> (and just to confuse things even more, there are times when we speak of 'polytypes')
12:20:36 <hackrilege> I just don't want to have to @define a bunch of stuff each time my client crashes
12:20:53 <[exa]> someone should write the definition better, at least to the haskell report
12:21:23 <[exa]> the definition there is "a is monomorphic in Preds => Type if a is free in Preds => Type
12:21:44 <geekosaur> but it sounds like you are being confused that the same term means different things in different branches of math (category theory vs. typed lambda calculus). and if that's your problem, this is far from the only instance of it...
12:21:56 <[exa]> having "monomorphic in = not polymorphic in" would be, well....would have me saved a hour now. :D
12:22:28 <[exa]> yep
12:22:32 <geekosaur> hackrilege, there is @letlpaste but do remember that the global definitions of lambdabot are a shared resource across many lambdabot users in many channels
12:22:34 <hackrilege> Great scene in red dwarf where lister kissing a polymorph
12:22:35 <[exa]> thanks for clarifications, anyway :]
12:22:56 <[exa]> lister = monomorph
12:24:03 <hackrilege> geekosaur, do you mean that two users in separate private queries with lambdabot could alter each other's definitions?
12:24:27 <geekosaur> yes
12:24:47 <geekosaur> there's only one L.hs, not one per person/channel
12:25:19 <maerwald> funny race conditions
12:25:42 <hackrilege> My analog machine is down so I'm stuck on Android again... Can't figure how to keep coding
12:27:06 <hackrilege> I don't want to spam up the irc channel by working with lambdabot but it's the only compiler I have access to...
12:27:27 <jophish> hackrilege: you can pm lambdabot 
12:27:44 <hackrilege> Apparently that affects a shared namespace
12:27:45 <geekosaur> the state is still shared across all users, jophish
12:27:56 <jophish> ah yes, only read the most recent message
12:28:36 <hackrilege> So long as there is only me working on it it would be fine but if I keep undefining stuff it could be annoying for someone else
12:29:36 <geekosaur> people sometimes toss @undefined around a lot in here
12:29:45 <geekosaur> which would also make you unhappy
12:29:58 <hackrilege> Yeah that especially!
12:30:11 <geekosaur> (pretty much any time someone does @let data Foo ... and gets an error, they'll @undefine and do it again)
12:31:12 <ongy> hackrilege: just call everything hackrilege_<name>
12:31:28 <ongy> also I'm not sure if lambdabot is that useful for such things. do you have access to a vps?
12:31:55 <geekosaur> there's also stuff like ideone.com
12:32:02 <hackrilege> You want to give me an account!? I was thinking of setting up something with Amazon or something
12:32:17 <geekosaur> sadly I think fpco shut down their online IDE?
12:32:52 <ongy> 1) I don't know you, 2) I'm to lazy to set up an account for untrusted users. so sadly I can't help you with that. I just wanted to recommend setting a dev-setup up on one
12:33:30 <shapr> geekosaur: I loved that IDE, I used it to teach "Intro to Haskell"
12:34:58 <ongy> hackrilege: if your android device is powerfull enough, there was someone in here a while ago who said they got ghc on a linux-emulator on android or something. But I'm not sure if they were only here to troll or serious
12:35:54 <hackrilege> Yeah that was me
12:36:03 <hackrilege> I used gnuroot
12:36:10 <hackrilege> Which is now bitrotten
12:36:12 <grantwu> c_wraith: well, what is easier when you get larger?
12:40:36 <hackrilege> Ok I'll try that again see if any thing like that works, it's been a while maybe the situation has changed.
12:48:10 <danilo2> Hello! I remember this topic was covered a long time ago here, but I cannot find any sources now. So, I'd love to kindly ask for explanation! Why we would ever need to use `unsafeCoerce` if `unsafeCoerce#` is faster (it doesnt allow for bottom type if I recognize correctly).
12:48:24 * hackagebot gi-atk 2.0.8 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.8 (inaki)
12:48:26 <danilo2> Is the only reason allowing for bottom type or are there any other caveats?
12:48:40 <atk> I have bindings?
12:50:57 <danilo2> atk: :D
12:52:11 <koala_man> danilo2: according to the documentation, unsafeCoerce# is GHC specific and unsafeCoerce just calls it
12:53:25 * hackagebot gi-cairo 1.0.8 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.8 (inaki)
12:53:27 * hackagebot gi-gdk 3.0.8 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.8 (inaki)
12:53:29 * hackagebot gi-gdkpixbuf 2.0.8 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.8 (inaki)
12:53:31 * hackagebot gi-gio 2.0.8 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.8 (inaki)
12:53:33 * hackagebot gi-girepository 1.0.8 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.8 (inaki)
12:58:35 * hackagebot gi-glib 2.0.8 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.8 (inaki)
12:58:37 * hackagebot gi-gobject 2.0.8 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.8 (inaki)
12:58:39 * hackagebot gi-gst 1.0.8 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.8 (inaki)
12:58:41 * hackagebot gi-gstaudio 1.0.8 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.8 (inaki)
12:58:43 * hackagebot gi-gstbase 1.0.8 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.8 (inaki)
13:03:45 * hackagebot gi-gstvideo 1.0.8 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.8 (inaki)
13:03:47 * hackagebot gi-gtk 3.0.8 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.8 (inaki)
13:03:49 * hackagebot gi-gtkosxapplication 2.0.8 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.8 (inaki)
13:03:51 * hackagebot gi-gtksource 3.0.8 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.8 (inaki)
13:03:53 * hackagebot gi-javascriptcore 3.0.8 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.8 (inaki)
13:05:06 <kadoban> hackagebot :(
13:06:01 <cocreature> I should add a gi-* filter rule in addition to the amazonka rule I already have in place
13:06:18 <hexagoxel> cocreature: neat, thanks
13:06:30 <cocreature> hexagoxel: hm?
13:07:00 <hexagoxel> oh, client-sided?
13:07:07 <cocreature> yeah
13:07:07 <hexagoxel> pssh
13:07:10 <hexagoxel> :)
13:07:51 <kadoban> Ya, my client kinda sucks so I can't do that that I know.
13:08:20 <cocreature> wait, the gi-* updates seem to only upgrade the stack.yaml
13:08:55 * hackagebot gi-javascriptcore 4.0.8 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.8 (inaki)
13:08:55 <ezyang> Hey, if I have a stack.yaml, am I supposed to distribute it as part of the extra source files when I make a source distribution? 
13:08:57 * hackagebot gi-notify 0.7.8 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.8 (inaki)
13:08:59 * hackagebot gi-pango 1.0.8 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.8 (inaki)
13:09:01 * hackagebot gi-pangocairo 1.0.8 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.8 (inaki)
13:09:03 * hackagebot gi-poppler 0.18.8 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.8 (inaki)
13:09:11 <ezyang> Don't know what the SOP here is 
13:09:20 <cocreature> ezyang: I add it to repos but I don’t add it to hackage
13:09:43 <cocreature> and I think that’s what most people do
13:09:47 <ezyang> cocreature: ok 
13:10:02 <cocreature> I don’t see why you would add it to hackage like the gi-* packages seem to be doing
13:10:14 <ezyang> Hahaha, that's what prompted the question 
13:10:43 <cocreature> hackagebot is quite busy spamming updates of basically nothing
13:10:48 <stoopkid> hello, where can i find the source for Prelude?
13:11:00 <ezyang> stoopkid: on the Haddock page click 'Source' 
13:11:20 <cocreature> I guess the only reason where a stack.yaml on hackage is useful is if you want to contribute to a package and for some reason you don’t want to clone the repo but download from hackage
13:11:26 <cocreature> but I don’t understand why you would want that
13:11:56 <Tuplanolla> You'll have to check the source tree link on the contents page if you want to chase down things imported from internal modules, stoopkid.
13:12:08 <kadoban> cocreature: I guess it'd help in cases where people do 'stack unpack' for some reason
13:12:08 <stoopkid> ezyang: ah, convenient, thanks
13:13:15 <cocreature> kadoban: yeah but I never found myself wanting to use that (same for cabal unpack)
13:13:23 <cocreature> I always want to clone the repo if I want to look at the source
13:13:28 <cocreature> but maybe that’s just me
13:14:05 * hackagebot gi-soup 2.4.8 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.8 (inaki)
13:14:07 * hackagebot gi-vte 2.91.9 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.9 (inaki)
13:14:09 * hackagebot gi-webkit2 4.0.8 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.8 (inaki)
13:14:11 * hackagebot gi-webkit2webextension 4.0.8 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.8 (inaki)
13:14:13 * hackagebot gi-webkit 3.0.8 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.8 (inaki)
13:14:18 <ezyang> spam spam spam 
13:14:20 <MarcelineVQ> if you use --pvp-bounds on your stack sdist it makes sense to not include the stack.yaml on hackage
13:14:25 <kadoban> cocreature: Ya, can't say I have either. I always figured there was some reason the commands existed though, heh.
13:14:39 * cocreature tries to figure out how to add ignore rules
13:14:44 <stoopkid> do you know where it normally gets stored when you install ghc or haskell-platform or where it is in the ghc source though?
13:14:53 <MarcelineVQ> does hackage check for enforced version bounds on uploaded packages?
13:15:43 <Tuplanolla> You have to configure that before installing, stoopkid.
13:15:44 <sphinxo> so I have added monadrandom to my .cabal file and i'm getting   monadrandom must match -any, but the stack configuration has no specified version
13:15:53 <sphinxo> when I stack ghci
13:16:16 <sphinxo> tried putting monadrandom under extra deps in stack.yml
13:18:53 <hexagoxel> MarcelineVQ: no
13:19:15 * hackagebot idris 0.99 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.99 (EdwinBrady)
13:19:17 * hackagebot unfoldable 0.9.1 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9.1 (SjoerdVisscher)
13:19:19 * hackagebot nonfree 0.1.0.2 - Free structures sans laws  https://hackage.haskell.org/package/nonfree-0.1.0.2 (ShachafBenKiki)
13:19:21 * hackagebot idris 0.99 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.99 (EdwinBrady)
13:19:23 * hackagebot unfoldable 0.9.1 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9.1 (SjoerdVisscher)
13:19:53 <hexagoxel> spam broke the bot?
13:20:53 <cocreature> ah filter in place, the madness is over
13:23:13 <sm> hackagebot simply reports hackage uploads, 5 at a time.. once in a while there's a flurry of uploads. What should it do when that happens ?
13:24:25 * hackagebot nonfree 0.1.0.2 - Free structures sans laws  https://hackage.haskell.org/package/nonfree-0.1.0.2 (ShachafBenKiki)
13:24:27 * hackagebot idris 0.99 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.99 (EdwinBrady)
13:24:28 <hexagoxel> sm: nub
13:24:29 * hackagebot unfoldable 0.9.1 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9.1 (SjoerdVisscher)
13:24:31 * hackagebot nonfree 0.1.0.2 - Free structures sans laws  https://hackage.haskell.org/package/nonfree-0.1.0.2 (ShachafBenKiki)
13:24:33 * hackagebot idris 0.99 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.99 (EdwinBrady)
13:24:52 <sm> hexagoxel: more details please ?
13:24:58 <hexagoxel> woah, 4 new idrises
13:25:29 <hexagoxel> sm: are you sure that idris-0.99 was uploaded 4 times?
13:25:29 <cocreature> but 4 time the same
13:25:54 <cocreature> afaik you can’t update a package without changing the version
13:25:58 <sm> hmm, that is not good
13:26:06 <maerwald> that is good
13:26:22 <hexagoxel> we have a reason to kill the bot? :D
13:26:50 <sm> reannouncing the same package version, I mean. I guess I'd better shut it down till I can investigate (just cooked lunch)
13:27:29 <hackrilege> Haha take that hackagebot
13:27:40 <hexagoxel> no, need to see if there are more idrises
13:28:35 <joshfreck> Quick intero question: I'm new, and have been botching up the install. `company-ghc-diagnose` reports `nil` for completions from my required packages, yet somethings can complete and others can't. Any chance someone knows whats up?
13:29:13 <implementation_> go home hackagebot, you're drunk
13:29:24 <hackrilege> Ok I give up trying to get debian to work on my phone
13:29:37 <sm> it is usually quite well behaved, I can't think what came over it
13:29:37 <hackrilege> It's just not the solution
13:30:16 <hackrilege> You shouldn't give it so much sugar
13:32:10 <cocreature> you shouldn’t give it so much idris
13:32:37 <implementation_> and so much nonfree
13:33:18 <hexagoxel> nonfree sugars are bad for your evaluator
13:38:41 <implementation_> a week of GNU/LibreSugar only should help getting the nonfree devil out of the bot
13:44:18 <TallerGhostWalt> Anyone else having trouble with +RTS -N on arm boxes?
13:50:51 <LordBrain> I'm getting a parse error on an example i cut and pasted from this tutorial on template haskell: https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial
13:51:06 <LordBrain> its the mapN function in section 2.1.1
13:51:44 <LordBrain> The very last line, immediately after the back tick, i get: parse error on input [
13:52:05 <LordBrain> What do i need to do to fix it?
13:53:37 <alcuadrado> Can anyone help me understand structural vs primitive recursion in Haskell? I thought I got it, but this exercise confused me: http://pastie.org/pastes/10977210/text?key=dynftuwmiyxchpoip55etw
13:54:51 <geekosaur> LordBrain, that ... is not a Haskell error message
13:55:22 <MarcelineVQ> LordBrain: change ` to ' but there's another error after that related to consPatts I'm not sure about
13:55:24 <LordBrain> geekosaur, what's it from then? I got it running ghc directly
13:56:11 <LordBrain> MarcelineVQ, thanks, I'll do that, and wait for more help
13:57:59 <geekosaur> hm, I guess it is. smells more C / CPP-ish to me though
13:58:03 <LordBrain> MarcelineVQ, well it compiles with that change
13:58:08 <hackrilege> alcuadrado, I don't get what you're asking...
13:58:54 <geekosaur> it's kinda prototypical yacc / bison error, which I guess happy copied verbatim
13:59:14 <lpaste> Koen pasted “Failed yi install” at http://lpaste.net/349566
13:59:44 <koenvg> Hey guys! Can you help me installing the Yi editor?
14:00:09 <geekosaur>     There are files missing in the ‘oo-prototypes-0.1.0.0’ package,
14:00:09 <geekosaur>     try running 'ghc-pkg check'.
14:00:30 <geekosaur> did you by any chance remove ~/.cabal at some point without also removing ~/.ghc?
14:01:49 <koenvg> ooohh, yes, I did remove .cabal without removing .ghc. Should I try to remove both of those and start from scratch?
14:02:38 <geekosaur> ~/.cabal removes the libraries, but the registration is still under ~/.ghc so ghc thinks libraries are installed that don't actually exist
14:02:48 <geekosaur> so yes, you'd want to remove both
14:03:03 <koenvg> alright, I didn't have anything else installed anyway. Let me try
14:10:01 <geekosaur> also, I would suggest using a sandbox. although I don't know what data files yi might need copied out of the build sandbox offhand
14:14:39 <koenvg> well I tried installing yi again, and now it it failed for a different reason, haha - error in the build process
14:15:00 <koenvg> I guess sandboxing wouldn't help with that, though I'll keep it in mind
14:15:06 <Tuplanolla> Is Yi usable yet?
14:16:32 <koenvg> Not able to install... Maybe I'm still doing something wrong. I have to off, thanks for the help geekosaur!
14:16:44 <geekosaur> would need more detail
14:18:45 <MarcelineVQ> LordBrain: oh I see the error I saw is just an hlint error
14:19:24 <LordBrain> MarcelineVQ, ah, good, yeah it seems to be working fine now
14:20:52 <Darwin226> Hey guys. Does anyone remember this talk about writing extensible haskell code, or general tips about writing haskell? It was pretty funny. I remember one of the jokes is that if you don't write instances for your types, Ed will steal your package
14:24:49 <LordBrain> hmm i see  $(deriveFunctor ''Tree) there in the previously mentioned tutorial, why is there two quotation marks there instead of one?
14:25:50 <Ben__> Hello all
14:27:34 <MarcelineVQ> LordBrain: ask ghci :>
14:28:14 <MarcelineVQ> ​:t 'Just   :t ''Maybe   :t 'Maybe  :t ''Just
14:29:51 <MarcelineVQ> ' and '' are shorthand for making a Name from a constructor. ' operates on data constructors, '' operates on type constructors
14:29:53 <LordBrain> So it switches from the data namespace to the type namespace
14:30:05 <LordBrain> i see
14:30:57 <MarcelineVQ> '' works on classes too appearantly
14:31:09 <ogkloo> so like if I wanted a variable called 'Maybe?
14:31:26 <ogkloo> oh wait
14:32:40 <MarcelineVQ> ogkloo: it's part of the AST for template haskell https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH.html#g:13
14:33:38 <MarcelineVQ> ' and '' are just nicer to write than lookupValueName/lookupTypeName or newName
14:42:34 <Ben__> If anyone is curious, check out our Gitter community at https://gitter.im/haskell-chat/Lobby
14:46:03 <anks> hi, is it possible to implement a function with this type type > ServiceFun ss m r = forall sr. (Monad m, ss ⊆ sr)
14:46:22 <anks> where ⊆ comes from vinyl library
14:47:02 <anks> oops.. this one:  type ServiceFun ss m r = forall sr. (Monad m, ss ⊆ sr) => ReaderT (Rec (Attr m) sr) m r
14:47:08 <yushyin> Ben__: you already posted that
14:48:23 <anks> 'cause i can't get compiler to deduce types within passed type-level list 
14:55:42 <LordBrain> where do i get getQ and putQ functions? for template haskell? The example expects them to be in scope but they are not
14:56:27 <dev987> How do I apply (a -> a-> Maybe a) to two (Maybe a)s?
14:58:10 <Lokathor> dev987, you have to unwrap both (Maybe a) values into (a) values and then apply it. You could even use a do block, something like { one <- firstMaybe; two <- secondMaybe; func one two }
14:58:15 <kadoban> dev987: Easiest way conceptually: use case to pattern match each
14:58:28 <MarcelineVQ> LordBrain: Language.Haskell.TH.Syntax you can use sites like http://hayoo.fh-wedel.de/?query=getQ to find out, but most of the time something you want for TH will be in Language.Haskell.TH or Language.Haskell.TH.Syntax
14:58:32 <ongy> or use join and liftA2
14:58:42 <dev987> So with (a -> a -> a) it's easy: (*) <$> (Just 7) <*> (Just 5)
14:58:52 <ongy> :t \f x y -> join $ liftA2 f x y
14:58:54 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
15:00:21 <anks> dev987: since you get (Maybe (Maybe a)), you can just use join
15:00:37 <anks> :t join
15:00:39 <lambdabot> Monad m => m (m a) -> m a
15:02:16 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.72.43.138.234
15:02:26 <dev987> anks + ongy: it works! thank you :)
15:02:48 <anks> : - )
15:02:57 <athan> Hi everyone. Could someone describe "full laziness" for me?
15:03:19 <monochrom> in what context? in the context of ghc's "-fno-full-laziness"?
15:04:14 <athan> monochrom: just from a compiler implementation perspective. I think this is the same idea
15:05:48 <solrize> we have -fno-full-laziness now?  what is that?!!
15:06:12 <athan> solrize: iirc it's a semantic concern dealing with graph reduction or something :S
15:06:21 <athan> or might be from refactoring expressions into an LC
15:06:23 <solrize> erm
15:06:37 <solrize> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/options-optimise.html
15:06:39 <MarcelineVQ> you don't have to guess my darlings, there's a wonderful ghc manual avaialble here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
15:06:53 <solrize>     Turns off the full laziness optimisation (also known as let-floating). Full laziness increases sharing, which can lead to increased memory residency.
15:06:57 <athan> MarcelineVQ: Beautiful :) thank you!!!
15:07:25 <athan> oy! thanks solrize!
15:07:40 <solrize> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html?highlight=full-laziness#ghc-flag--ffull-laziness
15:07:44 <monochrom> But you wouldn't want to read it from version 7.4.1
15:07:54 <solrize> well that's what the search engine found :)
15:08:03 <monochrom> Here, read mine: file:///usr/local/haskell/ghc-8.0.1-x86_64/share/doc/ghc-8.0.1/html/users_guide/using-optimisation.html#ghc-flag--ffull-laziness
15:08:43 <geekosaur> heh
15:08:52 <solrize> file:/// ?  heh
15:08:54 <MarcelineVQ> why won't this link load, windows98 must need a defrag
15:09:18 <monochrom> It's what my wetware search algorithm found
15:13:17 <MarcelineVQ> I made my manual from HEAD and keep going to use amazing ghci features I don't have yet ;(
15:13:58 <Cale> MarcelineVQ: What are you looking forward to?
15:14:03 <monochrom> You have to also make GHC from HEAD.
15:14:13 <dazednconfused> hello room. newb here who's confused with monads. i need some help
15:14:22 <MarcelineVQ> :type +v and :source are the two that come to mind right away
15:14:54 <athan> isn't there a noninvasive :show or something that demonstrates unevaluated thunks?
15:15:06 <MarcelineVQ> ​:print and :sprint
15:15:06 <Cale> The main thing which is going to change my life when 8.0.2 comes out is deterministic builds meaning that our nix-based infrastructure can finally build things in parallel and everything will be like 8 times faster
15:15:10 <athan> it didn't "work correctly" when I tried it on 8.0.1 iirc :x
15:15:23 <Cale> dazednconfused: Feel free to ask any questions you might have
15:15:41 <athan> thanks MarcelineVQ!!
15:16:01 <athan> dazednconfused: monads are life
15:16:03 <MarcelineVQ> sprint is a tricky one, if your types aren't concrete it won't show you things the way you expect because it's still expecting type arguments to your classes, there's probably a better way to word that
15:16:29 <dazednconfused> I'm writing a program to decode strings from a prefix tree. i've written a function that finds a character from a prefix tree based on the code provided. it returns a Just Char or a Nothing. I call this function from another function which cons the results. I end up with a [Maybe Char]
15:16:43 <dazednconfused> will lpaste it. one sec
15:16:55 <Cale> dazednconfused: Okay, are you looking to use the fact that Maybe is a monad to tidy up the code some?
15:17:11 <Cale> Like, if you would rather have a Maybe [Char], you can use sequence
15:17:22 <athan> oh hm I think I understand MarcelineVQ. I just remember from the Marlow's performance book that there's one that shows something like `[_,_,_]` after checking the length of an unevaluated list
15:17:22 <MarcelineVQ> athan: x = [1..10] vs x = [1..10 ::​ Int] is an easy example, try take 2 from both fo those and :sprint afterwards
15:17:41 <lpaste> dazednconfused pasted “findChar” at http://lpaste.net/349568
15:17:41 <Cale> (that will give you Nothing if any of the elements of the list was Nothing, and Just a string of the characters if they were *all* Just)
15:18:05 <dazednconfused> Yes Cale that's what I want
15:18:08 <athan> oh! dang, thanks again MarcelineVQ!
15:18:11 <MarcelineVQ> *both of those with :sprint x after each
15:18:15 <dazednconfused> Cale yes that's what i want
15:18:18 <Cale> dazednconfused: cool :)
15:18:21 <Cale> :t sequence
15:18:23 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:18:37 <Cale> Ah, I always forget it's going to show you the Traversable one
15:18:48 <MarcelineVQ> Cale buuut that's what :type +v will fix
15:19:00 <Cale> MarcelineVQ: What does that do?
15:19:12 <MarcelineVQ> uses the most concrete default type when showing the type
15:19:26 <Cale> MarcelineVQ: Won't that fill in lots of stuff with ()?
15:19:46 <monochrom> I love ()
15:20:00 <dazednconfused> Cale thanks so much. I knew I'd read about it somewhere but just couldn't recollect
15:20:10 <MarcelineVQ> I'm not sure, I'm probably working that badly, I'll find the manual wording shortly.
15:20:34 <MarcelineVQ> what it means is: :type +v length  shows   length :: [a] -> Int
15:21:54 <MarcelineVQ> oop that's not +v that'd +d actually, both are new
15:21:57 <athan> MarcelineVQ: Holy tamole! Can you customize what "most concrete" means for each typeclass?
15:22:03 <Cale> MarcelineVQ: huh, interesting, so they default the Traversable to []
15:22:16 <mmaruseacph2> :type +v?
15:22:19 <Cale> I'm not sure I like *that* either though :D
15:22:26 <mmaruseacph2> in ghci? I'm getting an error
15:22:28 <Cale> If it's going to lie :)
15:22:29 <monochrom> I wonder whether it will default Monad m to m=IO or something
15:22:34 <mmaruseacph2> oh, wait, I was using it wrong
15:22:45 <athan> why not Identity :x
15:22:56 <MarcelineVQ> actual wording http://lpaste.net/349569
15:23:18 <MarcelineVQ> +v is quite different
15:23:19 <monochrom> Oh, it doesn't do anything to Monad m.
15:23:42 <monochrom> Oh, +d? +v?
15:23:46 <Cale> How does it default things constrained by Ord?
15:24:12 <Cale> Like, if you :type +d sort
15:24:16 <Cale> what do you get?
15:24:35 <vsimen> hi, can somebody explainme how 'any (char ==) "aouei"' is working in http://lpaste.net/349567 ? 
15:24:48 <MarcelineVQ> idk, there's just that one example there atm
15:25:10 <monochrom> ExtendedDefaultRules probably nails it to () again
15:25:10 <Cale> vsimen: any is a function which takes a predicate and a list, and tests to see if the predicate is true for any of the elements of the list
15:25:41 <monochrom> any (char ==) "abc" = char == 'a' || char == 'b' || char == 'c'
15:25:56 <lpaste> MarcelineVQ annotated “No title” with “type +v (annotation)” at http://lpaste.net/349569#a349570
15:26:12 <vsimen> Cale, char is defined as char :: Char -> ReadP Char
15:26:30 <vsimen> Cale, how (char ==) is evaluated ?
15:27:02 <Cale> no, char is bound as an argument to the function
15:27:11 <Cale> (confusingly)
15:27:20 <monochrom> interesting, :type +v is very subtle
15:27:22 <Cale> Probably not a great plan
15:27:33 <Cale> isVowel x = any (x ==) "aouei"
15:27:39 <Cale> would be an equivalent definition
15:27:55 <vsimen> Cale, I understand now 
15:28:16 <monochrom> Yeah, you wrote "isVowel char = ..." so now so-called "char" is a parameter not a global thing you imported
15:28:54 <monochrom> This is the problem with meaningful identifiers.
15:29:12 <Cale> monochrom: Yeah, I'm not sure how comfortable I am with the idea that there is now this distinction between specified and inferred type variables... and that the prettyprinter is by default going to mess with it.
15:29:21 <vsimen> monochrom, the example is from the web two-wrongs. com 
15:29:53 <monochrom> I wonder what's the 2nd wrong thing.
15:30:12 <monochrom> Perhaps I get to pick on its line-break positions.
15:31:18 <vsimen> monochrom, Cale thanks
15:33:32 <monochrom> But ReadP is a good choice because it's a lightweight parser combinator. And it comes with GHC, you don't have to ask around about building and installing and "should I use cabal or should I use stack?"
15:35:05 <kuribas> why not (`elem` "aouei")?
15:35:28 <kuribas> :t (`elem` "aouei")
15:35:30 <lambdabot> Char -> Bool
15:36:11 <monochrom> because someone tossed a coin to decide
15:37:22 <kuribas> elem is shorter
15:40:39 <kuribas> and more to the point
15:41:22 <kuribas> oh, hlint beat me to it...
15:56:21 <kuribas> https://www.haskell.org/hoogle/?hoogle=%3C%3E
15:56:31 <kuribas> that's pretty bad
15:58:45 <kadoban> kuribas: stackage's hoogle is a bit better, or hayoo. I never use actual hoogle, it's ... terrible quite frankly for any uses I use hoogle-ish stuff for.
15:59:15 <kuribas> My local hoogle gives the right results
15:59:56 <glguy> kuribas: http://hoogle.haskell.org/?hoogle=%3C%3E
16:01:23 <kuribas> glguy: that's not the one that turns up in google.
16:01:28 <glguy> ok
16:02:28 <kuribas> shouldn't www.haskell.org/hoogle be updated?
16:03:02 <haasn> Hmm. I have a ‘key’ type like data Key = Foo | Bar; with each key having a different associated representation; e.g. via a type family KeyRep (k :: Key) where KeyRep Foo = Last Int and KeyRep Bar = [Flag], or whatever. More importantly, I have a Monoid instance on these KeyReps. Now I want to create some sort of “dependent map” like a Map Key (KeyRep ofThatKey), if that makes sense; i.e. insertD ::
16:03:04 <haasn> (k :: Key) -> KeyRep k -> DMap Key -> DMap Key, if I was able to use dependent types in Haskell
16:03:10 <haasn> Is there any sort of analog to this that I could use or embed in Haskell?
16:03:19 <kuribas> glguy: it's also the one that hackage links to.
16:03:48 <dazednconfused> hey guys, is there an easy way to test my program with an older version of ghc? i have written it on 7.10.3 but need to test it with 7.6.3
16:03:53 <haasn> Basically the goal is to have a well-typed key/value collection on a closed set of keys, where pattern matching on the key lets me know the type of the associated value, but also imports a Monoid instance on that value
16:04:09 <glguy> kuribas: Probably worth asking someone in #haskell-infrastructure
16:04:28 <Koterpillar> dazednconfused: maybe stack has a resolver to help you, e.g. resolver: ghc-7.6
16:04:48 <kadoban> dazednconfused: stack helps if you only need to go back to 7.8.4, but I don't think it particularly helps with anything older.
16:05:11 <haasn> Now obviously I could just use data KeyVal = Foo (Last Int) | Bar [Flag] and use a Set KeyVal or something along those lines, but 1. I want keys to be unique, 2. not all keys have Eq-able implementations, 3. I want to write a mergeDMap :: DMap Key -> DMap Key -> DMap Key that uses each key representations' monoid instance to merge them
16:05:18 <kadoban> Maybe it could if someone added a resolver for older GHC.
16:05:33 <dazednconfused> oh ok. if stack can't help, it'd be best to setup a vm?
16:06:30 <Cale> dazednconfused: https://www.haskell.org/ghc/download_ghc_7_6_3
16:07:28 <Cale> You can download an older GHC there. It's perfectly possible to have more than one version of GHC installed (though of course, only one of them can be what you get when you type ghc or ghci into your terminal)
16:09:01 <Cale> haasn: are you literally describing DMap?
16:09:15 <haasn> I'm not sure. Is DMap a thing that exists? I made that name up
16:09:19 <Cale> https://hackage.haskell.org/package/dependent-map
16:09:25 <haasn> Oh hey, so it exists
16:09:49 <Cale> Maybe what you want is slightly different though
16:10:41 <Cale> This gives you a thing where your key type and value types have a parameter which matches for each key, and the DMap as a whole is heterogeneous with respect to that parameter.
16:11:26 <Cale> But you can do that as a kind of singleton
16:11:52 <haasn> I'm not sure if I understand. Is there a usage example?
16:12:03 <Cale> https://hackage.haskell.org/package/dependent-map-0.2.3.0/docs/Data-Dependent-Map.html
16:12:31 <haasn> That's what I'm looking at
16:12:46 <Cale> oh, oops
16:13:03 <Cale> This documentation unfortunately sucks
16:13:18 <Cale> That's what you get for not typechecking it ;)
16:13:20 <haasn> I guess DSum sort of explains it
16:13:56 <dazednconfused> Cale thanks once again :)
16:13:57 <Cale> The important difference between what DMap/DSum are now vs. what the example shows is that now the values are like the keys in being parametric types
16:14:10 <sm> dazednconfused: yeah, you can just install the old GHC and then use cabal install -w ghc-7.6.x ... 
16:14:27 <Cale> You can use DMap Tag Identity if you want something like their examples show
16:14:43 <Cale> But you'll need AString :=> Identity "hello!" now
16:15:13 <Cale> insert :: forall k f v. GCompare k => k v -> f v -> DMap k f -> DMap k f
16:15:30 <Cale> ^^ if you stare at that type signature, it might be clearer
16:15:30 <dazednconfused> sm yeah i'm fetching the old binaries from the link Cale provided
16:16:06 <lurkashflake> Haskell is functional (which I believe is not using the same logic as all the language I used before). Can it perform on any field? (Game, webscrapping, pentesting tools and etc)
16:16:19 <Cale> lurkashflake: yes
16:16:45 <lurkashflake> I consider myself as an amateur (above novice) will the learning curve be steep?
16:17:02 <LordBrain> it is well worth whatever effort you put in
16:17:14 <sm> lurkashflake: yes
16:17:19 <Cale> The learning curve is pretty long at least.
16:17:55 <LordBrain> start with types, product types and sum types, whats the difference?
16:18:14 <Cale> lurkashflake: We use it at the company I work for to make web applications -- we use it both for the backend (server), compiled to native code, and for the frontend (what runs in your web browser), compiled to Javascript.
16:18:16 <hpc> i would say it's steep with lots of switchbacks
16:18:23 <lurkashflake> LordBrain: those are results not types
16:18:33 <hpc> if you're learning concepts X, Y, and Z which all relate to each other in some way
16:18:45 <hpc> you can learn whichever is easiest or gradually absorb all of them at the same time
16:19:25 <lurkashflake> Last question, will haskell help me become a 1337 h4x0r?
16:19:32 <grantwu> c.c
16:19:34 <lurkashflake> :(
16:20:07 <lurkashflake> ok I'll get to the haskell documentation now..
16:20:14 <LordBrain> it can help with the productivity more so than with the reverse engineering
16:20:19 <Cale> lurkashflake: I guess it depends on your definition of that term. There's only so much deployed Haskell code out in the wild since it's still relatively new to industrial use.
16:20:55 <lurkashflake> Ah so I won't realy be able to copy other's code like a good skid
16:21:00 <hpc> "new" in this context means "younger than java and python"
16:21:06 <lurkashflake> like python's code everywhere
16:21:12 <hpc> even though haskell is actually older than both
16:21:25 <hpc> haskell has evolved a lot over the years
16:21:29 <hpc> and is still evolving!
16:21:31 <LordBrain> you can copy code pretty easy actually
16:21:39 <Cale> and of course, it's actually older than both, but for a long period of its history, had no intention of being a practical language to build real software in
16:21:53 <LordBrain> i just mean if you want to pick apart binary executables
16:22:05 <Cale> (it was more oriented at just being an exploration ground for new ideas in programming languages)
16:22:20 <hpc> it'll be really exciting to see how close haskell gets to full-blown dependent types
16:22:22 <LordBrain> its easier to keep track of scopes in haskell than in python, so you can actually cut and paste more easily i'd argue
16:22:31 <Cale> Around 2005 or so, I would say is when that really started to change.
16:22:48 <hpc> i think DT is going to be the next 20 years of other languages playing catch-up
16:23:09 <hpc> what happened in 2005?
16:23:17 <Cale> ByteString and a bunch of other stuff
16:23:23 <hpc> ah
16:23:45 <hpc> i would have been taking one of my first programming classes around that time
16:23:48 <Cale> Maybe that was 2004, this is approximate :)
16:24:32 <Cale> Basically Don Stewart got interested in pushing Haskell to the top of the programming languages shootout
16:25:17 <Cale> and around the same time, a bunch of changes happened in GHC to implement very helpful optimisations like constructor specialisation
16:26:17 <LordBrain> if by leet, you mean you want to inject your own code into an existing executable context, then you'd want a lowlevel language which haskell hasn't historically had a great deal of development/interest on that front.
16:27:47 <LordBrain> then again, if you know c you can inspect the runtime for some kind of security issues
16:28:44 <LordBrain> and thats valuable if the context you are injecting into was a made by a binary generated by ghc.
16:29:18 <LordBrain> if you find that tho, please be nice and report it
16:29:28 <lurkashflake> hah ya
16:30:43 <Cale> If your goal is just to get a lot of stuff done in a way that minimises the costs of maintaining it, I think Haskell is probably one of the best languages. Its type system is expressive enough that the compiler can help you to find nearly all the places in the code which need to change in response to some initial refactoring or new feature you start adding.
16:31:09 <LordBrain> since haskell programs often link against c libraries, you can still get in sometimes using old fashioned techniques.. say a database library bug or something
16:31:24 <Cale> It also has a lot of breadth in terms of the kinds of application which are reasonable to write in it -- even if it's not itself a low-level language, the FFI is really good, and you *can* do low level stuff where it's vital to do it.
16:32:11 <hpc> also if your goal is to write precisely designed bug-free code, you'll find haskell is the gateway drug to some even cooler stuff
16:32:14 <LordBrain> generally when we set up c bindings, we say "trust this"
16:32:23 <Cale> hpc: Yeah :)
16:33:25 <Cale> LordBrain: Also, you can use the FFI libraries to do low level stuff even if you're not binding to C code.
16:33:56 <LordBrain> thru the c calling convention, or you mean bypassing that somehow?
16:34:32 <Cale> I mean, the FFI library gives you stuff to allocate memory manually and write to / read from it and such.
16:34:41 <LordBrain> yeah
16:34:44 <LordBrain> i see
16:35:02 <LordBrain> you neeed that for making an interpretter
16:35:11 <vsimen> how is sequence function derived from monad bind ?  
16:35:31 <Cale> vsimen: Are you okay with do-notation?
16:35:38 <LordBrain> it just discards the result vsimen 
16:35:45 <LordBrain> :t (>>=)
16:35:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:35:50 <Cale> LordBrain: ??
16:35:50 <LordBrain> :t (>>)
16:35:51 <lambdabot> Monad m => m a -> m b -> m b
16:35:54 <Cale> :t sequence
16:35:56 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
16:36:07 <hpc> :t id -- AMIDOINITRITE?
16:36:08 <lambdabot> a -> a
16:36:12 <LordBrain> some people call >> sequence Cale, i know its confusing
16:36:28 <Cale> I... have not heard that, but understandable
16:37:00 <Cale> vsimen: anyway, let's just write  sequence :: (Monad m) => [m a] -> m [a]
16:37:18 <lyxia> >>, "programmable semicolon", "sequence operator"
16:37:22 <Cale> vsimen: just using recursion, and thinking about what action we want it to produce from this list of actions
16:37:42 <Cale> vsimen: So, we'll break it down by cases like with most recursive functions on lists:
16:37:45 <Cale> sequence [] = ...
16:37:49 <Cale> sequence (x:xs) = ...
16:37:58 <LordBrain> so vsimen which one did you mean? sequence or (>>) ?
16:38:13 <dazednconfused> (off topic) I read somewhere that Miran Lipovaca (author of LYAH) hangs out on this channel sometimes.. Is that true?
16:38:17 <Cale> The goal of sequence is to execute each of the actions in the list in turn, and produce a list of the results
16:38:18 <vsimen> λ> readP_to_S ( traverse char "eaea") "eaea" == [("eaea","")]
16:38:23 <hpc> dazednconfused: not in a while
16:38:24 <vsimen> sequence 
16:38:24 <Cale> dazednconfused: A *long* time ago
16:38:30 <vsimen> not >>
16:38:33 <hpc> not sure what he ended up doing
16:38:43 <Cale> dazednconfused: He disappeared shortly after the book was released
16:38:46 <dazednconfused> oh ok
16:39:05 <LordBrain> couldn't we do something like sequence = fold (>>)
16:39:10 <Cale> In the empty list case, we have no actions to run, so we just want to produce an action which does nothing, and produces an empty list as its result
16:39:34 <Cale> LordBrain: sequence = foldr (liftM2 (:)) (return []) is a highbrow way
16:39:51 <Cale> So...
16:39:58 <vsimen> LordBrain, the result of is not discarded because in the example below there is a result 
16:40:08 <Cale> sequence [] = return [] -- remembering that return v is the action which does nothing except to, well, return v
16:40:28 <Cale> Now, the interesting case:
16:40:36 <Cale> vsimen: following?
16:40:46 <Cale> sequence (x:xs) = ...
16:41:01 <Cale> sequence (x:xs) = do v <- x ... -- first we'll execute the first action in the list, obtaining some result v
16:41:08 <LordBrain> good point, my def is wrong
16:41:27 <Cale> and now we want to execute all the rest of the actions in the list, and get a list of their results, if only we had some way to do that...
16:41:36 <Cale> Thankfully we do, it's the function we're writing:
16:41:52 <vsimen> recursivity 
16:41:54 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs ... -- execute the rest of the list of actions, getting a list of results vs
16:42:53 <Cale> and lastly, we want to produce (v:vs) as the result of our combined action, so we'll execute return (v:vs), since the result of the last action is the result of the whole do block
16:43:04 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:43:29 <LordBrain> one thing is i think haskell is easier to remember than other programming languages
16:43:57 <vsimen> Cale, nice 
16:44:17 <Cale> So sequence is sort of like a primordial simple loop: if we can determine ahead of time what should occur on each iteration, and form a list of those actions, sequence will stitch them all together into a single action for us
16:44:29 <LordBrain> i guess partly because its so dense, that you get your memory jogged quick reading it, and another reason is the type system and error checking give you a good dose of reminders firming up your memory
16:44:38 <Cale> So in terms of that, we have  mapM f xs = sequence (map f xs)
16:44:51 <Cale> which is effectively a for-each loop
16:45:06 <LordBrain> i did some python years ago, but when i go back to it, i'm like omg this sucks
16:46:11 <Cale> LordBrain: Yeah, if in Python, you don't know how some API is meant to be used, you have to read the documentation. In Haskell, you skim the type signatures and they tell you how everything fits together, and you can just guess and get everything right almost all of the time.
16:46:43 <Cale> and when you screw up with that, the compiler tells you what to contemplate
16:46:44 <LordBrain> exactly
16:46:45 <mmaruseacph2> it's like jigsaw puzzles
16:46:52 <haasn> Cale: https://0x0.st/LL_.txt it seems to type check!
16:46:55 <haasn> exciting
16:46:58 <suzu> its like adult lego!
16:47:04 <haasn> haven't actually run it yet but who cares about running things when you could type check them instead
16:47:10 <mmaruseacph2> it _is_ adult lego :P
16:47:11 <Lokathor> A friend was trying to convert python's builtin "zip" function to Golang the other day. It was quite the chuckle for me just watching
16:47:25 <suzu> go makes me cry
16:47:28 <LordBrain> in haskell, you really only need to read docs and tutorials and stuff when you're learning a new thing
16:47:36 <suzu> it's very painful to move from a very high level abstract language like haskell
16:47:41 <suzu> to a language that lacks generics
16:47:52 <LordBrain> not when you happened to have put it down for 6 months and just want to make a program all of a sudden
16:48:09 <ogkloo> that's what I've found with Haskell, the documentation is miles ahead of most
16:48:18 <Cale> suzu: I started learning go, and the very first thing I tried to write in it was a polymorphic 'map' function. When that seemed difficult to impossible, I immediately dropped it.
16:48:32 <mmaruseacph2> still lacking a little in some aspects but can be enhanced
16:48:32 <ogkloo> or rather it's easier to adapt everything in the documentation to what you need it to do
16:48:41 <suzu> Cale: you can't write one
16:49:08 <Lokathor> ogkloo, I'd say that haskell documentation is hit or miss most of the time
16:49:31 <Cale> ogkloo: Actually, often the documentation sucks, but still the little bits that are provided are surprisingly more than good enough!
16:49:40 <ogkloo> maybe I just haven't hit a high enough level to hit that wall yet
16:49:55 <Lokathor> the base library, and a few other huge libraries, are good
16:49:55 <Cale> Depends on the library of course
16:50:05 <Lokathor> less common libraries usually drop off fast in doc quality
16:50:17 <ogkloo> honestly just having :t has helped me so much
16:50:23 <ogkloo> I went from python and C to this
16:50:29 <Cale> Yeah, :t is why the documentation is allowed to suck
16:50:42 <Lokathor> in my experience, Java actually has the best doc
16:50:50 <ogkloo> C has a lot of good documentation for a lot of libraries but it's often like "Oh you want to use this library, here's the 200pg book"
16:50:58 <Lokathor> because "void doThing()" really needs that doc to be written down
16:51:14 <Rembane> The thing with Java documentation is that it documents so many bad things that you don't want to have to know to just program something.
16:51:31 <ogkloo> well and mutable state just makes everything so much harder to manage
16:51:52 <ogkloo> and I mean Haskell DEALS with mutable states a lot but not near as often or as painfully from my limited experience
16:52:04 <Lokathor> i like that java editors have popups on the doc because they're generlly supported at the IDE level
16:52:16 <ogkloo> Java IDEs are good
16:52:22 <ogkloo> does Scala follow that trend?
16:52:27 <Lokathor> I want a haskell IDE that has docs in a popup when you hover over a symbol
16:52:41 <Lokathor> maybe in 10 years
16:52:51 <LordBrain> doesn't leksah havev that?
16:52:59 <haasn> why isn't (<&>) in Control.Functor yet
16:53:02 <haasn> Data.Functor, w/e
16:53:09 <LordBrain> i think leksah has that feature Lokathor 
16:53:09 <Cale> What is <&>?
16:53:13 <haasn> flip <$>
16:53:32 <Cale> oh, perhaps just "not wasting good infix operator space" :)
16:53:36 <Rembane> I just have a ghci running in another window.
16:53:48 <ogkloo> get a nice tiling wm
16:54:05 <kuribas> Couldn't you make a heterogenous map with Data.Map and existential types?
16:54:24 <Cale> kuribas: sort of
16:54:37 <Lokathor> hmmmmmmm
16:54:50 <Cale> kuribas: The existential forgets which types of things you had though, so you need a way to recover that
16:55:20 <LordBrain> i think the flip should look like a backwards dolar sign
16:55:24 <LordBrain> ᴤ
16:55:25 <hexagoxel> haasn: dfeuer proposed that on libraries list on 21/08/16
16:55:55 <Cale> kuribas: (at least, if you want to do stuff with the values when you get them out again, you need to know something about what operations they support, if not information about what types they have)
16:55:55 <LordBrain> Unicode hexadecimal: 0x1d24 ᴤ
16:56:07 <kadoban> Trying to come up with a new local alias for: flip (.)   How offensive is it to use (.>) for that?  I see it's used in lens apparently, but ... never quite seen it used and don't understand what it means there xD
16:56:10 <LordBrain> the line doesnt go all the way thru, but i could live wiht that
16:56:25 <Cale> kadoban: Control.Arrow has (>>>)
16:56:39 <LordBrain> that just makes it easier to tell the difference
16:56:42 <Cale> Actually, that one might be in Control.Category too? I haven't looked.
16:57:32 <hexagoxel> (haasn: the feedback was little but positive iirc)
16:57:37 <kadoban> Cale: Ya, I've so far avoided using that because the precedence struck me as possibly problematic. Maybe I should look again though, hmm.
16:57:57 <kadoban> Also it's kind of long, but ... it shouldn't matter. Any time I'm using it is for short stuff really.
16:58:07 <LordBrain> unfortunately its not considered a symbol in ghc, so you need the backticks `ᴤ`
16:58:07 <Cale> kadoban: Well, I tend to avoid flipping ($) or (.)
16:58:22 <LordBrain> tho thats just as many characters as <&>
16:58:42 <kuribas> Cale: and something like lookup :: k v -> Map k -> v
16:58:45 <LordBrain> but that also means you cant set hte precedence
16:59:20 <kadoban> Yeah :) I find it a lot more comfortable the other way around to write things though. I can think about it fine in either direction, but as a practical matter it's annoying to write stuff with (.)
16:59:20 <Cale> kuribas: Are you *also* looking for DMap?
16:59:20 <Cale> https://hackage.haskell.org/package/dependent-map-0.2.3.0/docs/Data-Dependent-Map.html
16:59:21 <kuribas> Cale: no, just wondering
16:59:32 <kuribas> If it can be done with Data.Map
17:00:05 <jle`> (>>>) is in Control.Category, but its fixity makes it unusable as a replacement for (.)
17:00:07 <Cale> (note, the example doc is a little out of date, you now use Identity for the second argument to DSum/DMap to get what you'd have in the old version that the examples use)
17:00:10 <jle`> except in super simple cases
17:00:18 <jle`> also it's kinda ugly
17:00:27 <kadoban> jle`: :(
17:00:33 <jle`> oh, this was mentioned earlier
17:00:37 <jle`> i should probably read the entire logs ._.
17:01:04 <jle`> but yeah, probably best to just avoid backwards style altogether
17:01:07 <kadoban> Well, I wasn't sure if it could be used or not. I had remembered there being something wonky about the fixity/prec when I last looked at it forever ago, but it's good to have it confirmed.
17:01:40 <jle`> when i say unusable i'm being melodramatic a bit.  but it definitely makes it awkward as a drop-in replacement for (.) i think, heh
17:01:41 <Cale> I dunno, it works well with the other Arrow stuff when that kind of thing is appropriate
17:01:49 <jle`> yeah, it works well with other arrow/category combinators
17:01:57 <jle`> but against the normal suite of things you'd use (.) with ...
17:03:14 <Rembane> More bracket! \o/
17:03:28 <kadoban> jle`: Ya, I understand why people suggest not doing it, but regardless I think I'm set on doing it anyway for a certain kind of personal project. I just have to pick a name. I've been using (&) = flip (.), but that's obviously not a good idea.
17:03:37 <Cale> Somehow it doesn't really come up so often that I want to flip (.)
17:04:05 <LordBrain> I think we should just do that, that backwards dolar sign thing  ᴤ, patch ghc and make it work,  its actually the IPA symbol for "voiced laryngeal spirant", which is apparently so rarely used i cant find a wikipedia page for it.
17:04:10 <jle`> if applicable, the x & b & c & d style has been goin on
17:04:15 <jle`> er, x & f & g & h
17:04:16 <LordBrain> nor an X_Sampa code...
17:04:38 <jle`> it's not my favorite but it's somewhat prolific in some circles
17:04:56 <Cale> jle`: I put up with that when it gets used with lens just because idiomaticness
17:05:05 <kadoban> Too hard to find unused short operators in haskell, heh.
17:05:05 <jle`> > [1..] & filter even & take 10 & sum
17:05:08 <lambdabot>  110
17:05:10 <Cale> But otherwise, I really don't like it.
17:05:12 <jle`> but like
17:05:14 <jle`> gross
17:05:35 <Cale> and it bugs me just a bit that (&) got stolen for such a frivolous thing
17:06:09 <jle`> i kind of liked F#'s (|>)
17:06:24 <jle`> or is that elm
17:06:27 <jle`> or is that everyone
17:06:32 <Cale> I believe F# does have that
17:07:17 <jle`> for the record diagrams also had a flip ($)
17:07:22 <jle`> it was (#)
17:07:28 <jle`> i guess the lens one won over
17:07:32 <Cale> I just think that if function application is going to be the way that it is, it's sort of obnoxious usually to be flipping things around
17:07:37 <jle`> definitely not because ed was on the base comittee
17:07:55 <Cale> It still has that, doesn't it?
17:08:06 <jle`> yeah
17:08:18 <jle`> i'm saying that there were two popular libraries that had their own versions of flip ($)
17:08:22 <LordBrain> Hey it is symbolic
17:08:34 <LordBrain> I just needed -XUnicodeSyntax
17:08:36 <jle`> but one was abosrbed into base over the other
17:09:11 <Cale> I doubt byorgey minds :P
17:09:25 <jle`> i think diagrams can't use (&) from base anyways because of its fixity
17:09:50 <jle`> operators are weird
17:09:53 <LordBrain> > let (ᴤ) a b = b $ a in 3 ᴤ (*2)
17:09:55 <lambdabot>  error:
17:09:55 <lambdabot>      • Could not deduce (Num a0)
17:09:56 <lambdabot>        from the context: (Num ((t -> (t -> t2) -> t2) -> (a -> a) -> t3),
17:10:22 <jle`> that's quite an error
17:10:30 <LordBrain> oops
17:11:14 <LordBrain> > (*2) $ 3
17:11:16 <lambdabot>  6
17:11:21 <Cale> Seems not to be a symbol character
17:11:27 <LordBrain> oh 
17:11:47 <LordBrain> yeah
17:11:55 <LordBrain> somehow i tricked myself into thinking it works
17:12:00 <Cale> Prelude Data.Char> generalCategory 'ᴤ'
17:12:00 <Cale> LowercaseLetter
17:12:05 <jle`> > isSymbol 'ᴤ'
17:12:07 <lambdabot>  False
17:12:48 <jle`> > filter isSymbol [minBound ..]
17:12:50 <lambdabot>  "$+<=>^`|~\162\163\164\165\166\168\169\172\174\175\176\177\180\184\215\247\7...
17:13:10 <hololeap> was making Functor a superclass of Monad a relatively recent move?
17:13:20 <jle`> hololeap: happened about a year ago
17:13:59 <Koterpillar> > len it
17:14:01 <lambdabot>  error:
17:14:01 <lambdabot>      • Variable not in scope: len :: Maybe Bool -> t
17:14:01 <lambdabot>      • Perhaps you meant one of these:
17:14:03 <Koterpillar> > length it
17:14:05 <lambdabot>  1
17:14:06 <hololeap> jle`: ok, thanks. i was reading "Real World Haskell" and it was saying that Monad was not a subclass of Functor, which it obviously is now :0
17:14:11 <hololeap> * :)
17:15:13 <jle`> hololeap: march 2015
17:15:15 <c_wraith> a lot of Real World Haskell is out of date now. 
17:15:41 <jle`> back when i started learning haskell in 2013, RWH already had a reputation for being out of date heh
17:15:55 <jle`> doesn't mean it's not a good book, but ... just be aware :)
17:16:31 <jle`> oh it was released in 2008
17:16:37 <c_wraith> RWH was starting to be out of date when I first picked up haskell in 2008. just in one or two places, but it was happening already. :) 
17:16:56 <geekosaur> it was out of date when it hit the bookstores: extensible exceptions had already landed
17:17:00 <jle`> in 2008 ... people were first beginning to use Applicative
17:17:04 <jle`> and taking it seriously
17:17:39 <geekosaur> haskell moves way too fast for mere books >.>
17:18:29 <sm> yep
17:18:30 <haasn> Cale: https://0x0.st/LLp.txt awesome
17:18:30 <haasn> Cale: now I just need a way to generate the GCompare boilerplate
17:18:30 <haasn> I don't think Data.Data.Data or GHC.Generics will help me much for GADT stuff like this, will it?
17:18:31 <haasn> Although I could use template haskell..
17:19:05 <haasn> Oh I totally know what could help with the comparison boilerplate
17:19:21 <jle`> simon marlow's /b 32
17:19:48 <haasn> I could add a second copy of the ‘Opt’ key struct as a regular enum type, give it derived Show/Ord/whatever instances, and include that in the tag as a second parameter
17:19:48 <jle`> oh that's awkward. my attention span is apparently so short that i get bored and try to switch buffers in the middle of a message
17:19:57 <haasn> Then I could reflect that back to the value level for my ‘gcompare’ function
17:20:00 <jle`> simon marlow's book has remained relevant, after about 3 or 4 years
17:20:09 <dfeuer> glguy, I have a question about your tries, if you're available.
17:20:14 <Tuplanolla> How come there's 0x0.st, but no 1.st, haasn?
17:20:49 <haasn> 0x0 is clearly the null pointer
17:20:55 <haasn> feel free to write all your data there, nothing can go wrong
17:21:08 <jle`> > filter (\x -> isPrint x && isSymbol x) [minBound .. ]
17:21:10 <lambdabot>  "$+<=>^`|~\162\163\164\165\166\168\169\172\174\175\176\177\180\184\215\247\7...
17:21:19 <Tuplanolla> The world needs more single-character domain names.
17:21:42 <haasn> Hmm on second thought, reflecting to the value level makes the GEQ instances impossible to write
17:21:47 <jle`> huh i wonder why \162 is escaped
17:21:57 <haasn> because I can't go from a value-level EQ to a type-level equality guarantee
17:22:01 <jle`> > text "\162"
17:22:03 <lambdabot>  ¢
17:22:18 <Koterpillar> > text $ filter (\x -> isPrint x && isSymbol x) [minBound .. ]
17:22:20 <lambdabot>  $+<=>^`|~¢£¤¥¦¨©¬®¯°±´¸×÷˂˃˄˅˒˓˔˕˖˗˘˙˚˛˜˝˞˟˥˦˧˨˩˪˫˭˯˰˱˲˳˴˵˶˷˸˹˺˻˼˽˾˿͵΄΅϶҂֍֎֏...
17:23:03 <jle`> so many symbols we can use
17:23:18 <jle`> we should broaden our horizons when picking one-character operators
17:24:24 <jle`> > let (©) = ("copyright 2016 " ++) in (©) "jle`"
17:24:26 <lambdabot>  "copyright 2016 jle`"
17:24:42 <Lokathor> magic
17:25:32 <RoboCrop> Does anyone know if "updateGet" is atomic when using persistent-postgresql? Based on the default definition in PersistStore.hs, I don't think it is, as I can't find it overridden anywhere in the codebase
17:25:41 <random-jellyfish> Hi, I am trying to write the number 16 as a sum of up to 16 non-distinct integers that can take values {1,2,4} - is there a name for this problem?
17:26:41 <jle`> the knapsack problem?
17:27:31 <jle`> it's one of the more famous NP-hard problems
17:27:59 <Tuplanolla> :t (⣠)
17:28:00 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:28:06 <jle`> lol
17:28:06 <Tuplanolla> (⣰)
17:28:12 <Tuplanolla> :t (⣰)
17:28:13 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
17:28:19 <Tuplanolla> :t (⣸)
17:28:20 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
17:28:29 <Tuplanolla> I'm so going to use these.
17:28:47 <lurkashflake> second time I hear about knapsack, if I understand properly it's not solving the problem that is hard but to define if it is the optimal one.
17:29:15 <haasn> There's a difference between finding a solution and counting the number of solutions
17:29:49 <random-jellyfish> jle`: yes it seems to be very close to what I'm looking for, the only difference is that the knapsack problem constrains the sum to be less than or equal to the limit, I'm interested in equality only
17:29:52 <pacak>  Tuplanolla: Oh noes. What package is that from?
17:29:53 <haasn> (Or, indeed, testing whether a solution exists)
17:30:02 <Tuplanolla> Hopefully none, pacak.
17:30:55 <pacak> > let a <ᴤ> b = b $ a in 3 <ᴤ> (*2)
17:30:58 <lambdabot>  <hint>:1:5: error: Parse error in pattern: a < ᴤ
17:31:23 <pacak> > let a <☭> b = b $ a in 3 <☭> (*2)
17:31:26 <lambdabot>  6
17:33:16 <jle`> random-jellyfish: potentially related maybe then to the subset sum problem?
17:33:24 <MarcelineVQ> Tuplanolla: custom-prelude has those, they use oo and ooo instead of fancy unicode though
17:33:50 <Tuplanolla> Braille symbols would admit lots of ridiculous compositions.
17:34:15 <jle`> the benefit is also that haskell source code becomes more accessible to the vision-impaired
17:34:36 <jle`> since i think it's easier to distinguish/differentiate between braile symbols than conventional symbols
17:36:23 <haasn> random-jellyfish: your problem sounds closer to that of counting the number of partitions: https://en.wikipedia.org/wiki/Partition_%28number_theory%29
17:36:32 <haasn> but with a limited set of operands
17:39:38 <random-jellyfish> haasn: I don't think partitions can be computed for "a limited set of operands" using concepts from partition number theory...I went down that road, haven't found anything interesting
17:39:53 <haasn> well
17:40:00 <haasn> https://en.wikipedia.org/wiki/Partition_%28number_theory%29#Generating_function have a look at this
17:40:27 <haasn> seems like by restricting the product to only contain 1/(1-x), 1/(1-x²) and 1/(1-x⁴) you get a generating function that counts your problem
17:40:40 <haasn> not entirely sure
17:41:14 <haasn> and I'm also not sure if that gets you any closer to your answer
17:42:24 <haasn> https://www.wolframalpha.com/input/?i=1%20%2F%20((1-x)*(1-x%5E2)*(1-x%5E4)) wolframalpha gives a series expansion
17:42:25 <random-jellyfish> I also want to randomly generate such partitions, counting might be helpful 
17:42:42 <haasn> it gives 1, 1, 2, 2, 4, ...
17:42:58 <haasn> which also seems to be correct? 
17:43:44 <haasn> 0: [empty sum], 1: [1], 2: [1+1, 2], 3: [1+1+1, 2+1], 4: [1+1+1+1, 2+1+1, 2+2, 4]
17:44:07 <haasn> so yeah if you can figure out a good way of calculating this expansion you might be on the right track to an O(efficient) solution
17:44:42 <random-jellyfish> if it's a subset of the knapsack problem it's an NP hard problem
17:45:18 <int-index> So this has just compiled in my fork of singletons! http://lpaste.net/349571
17:46:11 <jle`> nice :)
17:46:31 <int-index> Time for type-level monads
17:46:38 <haasn> random-jellyfish: is it important to you that the possible partitions occur with equal probability?
17:46:53 <haasn> if not you can just randomly pick operands that are smaller than the remaining difference
17:48:04 <random-jellyfish> haasn: if I do that I can end up with a sum that's less than 16
17:49:51 <haasn> random-jellyfish: no, because ‘1’ is in your set
17:50:27 <haasn> No matter what partial sum you're on, you can always add 1; and since you're allowed to use 16 operands, the worst case is also permitted
17:51:50 <random-jellyfish> haasn: I'm allowed to use up to 16 operands aka any number of operands in the range [1,16]
17:52:06 <haasn> random-jellyfish: btw, if you ask WA for more terms it delivers, for 16 there are 25 ways
17:52:26 <haasn> (unique ways to write it as a sum of operands from {1,2,4})
17:53:48 <haasn> http://stackoverflow.com/questions/23821878/efficient-generation-of-taylor-maclaurin-series
17:53:51 <haasn> this sounds like your problem
17:53:59 <haasn> except they use {5,7,11} instead of {1,2,4}
17:55:47 <random-jellyfish> hmm interesting
17:56:30 <haasn> Sounds like they go back to a dynamic programming suggestion
18:01:19 <random-jellyfish> I could use that function to see if the remaining difference can be decomposed, if not I backtrack
18:02:00 <haasn> random-jellyfish: oh okay, so you're not just using {1,2,4) but you're allowed to pick up to 16 different operands for your set?
18:02:29 <haasn> and you need to count all the ways with all possible operand sets? or?
18:03:25 <unskill> Logging with Writer monad is the worst example of its usage.
18:03:50 <random-jellyfish> haasn: I want to randomly generate ways in which 16 can be written as a sum of 1 to 16 operands that can take values from the se {1,2,4}
18:04:00 <unskill> Ppl see this and say "What a stupid language. I need to change function type for logging"
18:04:17 <haasn> yes, you don't need backtracking for that
18:04:41 <haasn> and “1 to 16 operands” is a useless restriction because the longest possible solution 1+1+1+1..+1 is exactly 16 operands
18:04:47 <random-jellyfish> haasn: to be more domain specific, I'm trying to generate random 4 4 rhythms, if you're familiar with music theory :)
18:05:49 <haasn> unskill: If that's your only criteria for saying something is bad, then the majority of haskell is bad
18:06:22 <random-jellyfish> in a 4 4 rhythm, the notes of a measure can be (1/4) notes, (1/8) notes or (1/16) nothes, and all the notes in a measure need to sum up to 1
18:08:05 <random-jellyfish> so I'm trying to write 1 as a sum of 1/4 , 1/8, 1/16
18:08:08 <jle`> random-jellyfish: stars and bars
18:08:27 <jle`> random-jellyfish: https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics) :)
18:09:06 <jle`> it looks like one thing that you didn't reveal is that the order of the items does matter :o
18:09:27 <jle`> 1+2+1 is different than 1+1+2
18:09:47 <haasn> yeah that completely changes the equation
18:09:53 <random-jellyfish> yes it does matter from a musical point of view
18:10:16 <random-jellyfish> although I wouldn't mind to have unordered solutions that I could randomly shuffle
18:10:30 <haasn> well it depends on what probability distribution you want
18:10:51 <haasn> if all possible outcomes need to have equal probability, then in general you can't randomly generate a partition and then shuffle that
18:12:32 <random-jellyfish> hmmm, for a start any probability distribution will do
18:14:11 <jle`> hm
18:14:26 <haasn> then keep picking random notes that won't put you over budget
18:15:06 <jle`> yeah.  that'll definitely bias the results you get, but if your distribution doesn't matter ...
18:15:37 <unskill> haasn: it seems that you took my words as personal offense
18:15:44 <random-jellyfish> haasn: and use 1s to fill the sum when I get close to 16
18:16:10 <random-jellyfish> yeah that might be a good solution
18:16:12 <jle`> you can probably just keep on picking from anything
18:16:18 <jle`> but that'll bias your picks
18:16:25 <jle`> you'll get more large notes at the beginning of the bar
18:16:30 <jle`> than at the end of the bar
18:17:50 <haasn> random-jellyfish: http://math.stackexchange.com/questions/31562/number-of-ordered-partitions-of-integer suggests an inductive (recursive) generation
18:18:00 <jle`> one nice way to get a good usable distribution would be to pick a number of notes in advance and then generate a number of paritions using stars and bars
18:18:33 <jle`> that way there is no bias for types of notes being more towards the end or the beginning
18:18:56 <jle`> you could pick the number of notes from a boltzman distribution or an exponential distribution maybe
18:20:05 <haasn> if you can get an inductive solution for the counting problem, you could probably turn that into a recursive solution for the generation problem
18:20:16 <haasn> like if you subdivide your set into those that begin with 1, begin with 2 and begin with 4
18:20:25 <haasn> and you can estimate the relative size of each
18:20:44 <haasn> then to generate an evenly distributed random element you just need to pick 1, 2 and 4 with probabilities in proportion to that set size
18:21:06 <jle`> that would be nice
18:21:46 <haasn> and
18:21:48 <haasn> this is easy to do
18:22:06 <haasn> Just compute the ordered partition function using dynamic programming, filling out an array from 0 to 16
18:22:11 <jle`> it becomes a rather cute dynamic programming problem
18:22:19 <jle`> indeed
18:22:34 <haasn> then when you need to generate the first note, pick {1, 2, 4} with probability proportional to the index 1, the index 3 and the index 5
18:22:44 <haasn> (assuming you're at index 0 currently)
18:22:49 <haasn> and that index 0 represents 16
18:23:33 <haasn> sorry index 1, 2 and 4 of course
18:23:59 <haasn> then when you've picked, say, ‘1,2,2’ already you'd be at index 5 so you'd look at 7, 8 and 10
18:24:05 <haasn> 6, 7 and 9*
18:24:10 * haasn needs sleep it seems
18:24:26 <random-jellyfish> interesting idea
18:26:16 <random-jellyfish> haasn: thanks a lot, no need to lose sleep over this, you've given me enough interesting material, get some rest if needed, thanks :)
18:33:49 <granomoly> Hello; Can practicing Haskell improve the programmers retention in learning abstract ideas?
18:35:26 <jle`> maybe
18:35:42 <unskill> granomoly: yes. or no.
18:35:49 <jle`> i don't have any evidence other than anecdotal accounts
18:36:53 <jle`> it also depends on the abstract ideas you're talking about
18:36:56 <unskill> What is "abstract idea"?
18:42:13 <unskill> All ideas are abstract, I think. Because idea is the abstraction from insignificant details.
18:43:42 <LordBrain> looking at the definition of DataD...
18:43:56 <LordBrain> DataD Cxt Name [TyVarBndr] (Maybe Kind) [Con] Cxt
18:44:06 <LordBrain> why do I need [Maybe Kind] ?
18:44:33 <LordBrain> and is it new, because the example i see in the tutorial doesnt seem to have that parameter
18:44:48 <LordBrain> is there a template specific chatroom?
18:44:56 <LordBrain> templatehaskell i mean
18:45:08 <JuanDaugherty> an abstract idea or concept is one which is not a generalization from experience of the world directly
18:45:28 <jle`> i think practicing haskell regularly will give you exposure to a lot of different abstract ideas
18:45:53 <jle`> but more abstract ideas than in other languages ...?  maybe.
18:45:59 <granomoly> jle`: namely, haskell in general, it's categorical constructions, the debugging process/adaptive learning through investigation and resolution, etc.. Abstract idea as differentiated from general concept adoption in it's utility (e.g., the kind of application of theory you'll inevitably end up learning in CS survey courses etc)
18:46:06 <unskill> JuanDaugherty: cmon man. There are no such things.
18:46:35 <JuanDaugherty> unskill, if you say so
18:49:50 <granomoly> I think the semantics prescribed in haskell generally disincentive writing programs which make little to no sense.. This somewhat factors into my question as to if haskell can improve one's retention in those things learned by programming in it
19:25:14 <LordBrain> if I have x:: Q [Exp] how can I convert that to Q Exp ?
19:26:51 <dfeuer> LordBrain, you want something that makes a list of expressions and you want to turn it into something that makes a single expression? How do you want to combine them?
19:27:19 * dfeuer knows nothing about Template Haskell, but is aware that Q is an instance of Monad.
19:27:56 <dfeuer> So it's also an instance of Functor, so you can fmap whatever you like over it.
19:28:49 <LordBrain> i found what i needed, fmap ListE
19:29:01 <LordBrain> thanks
19:29:32 <LordBrain> but it didn't work anyway the way i hoped, because i tried to use reify, but the environment isnt right it seems
19:29:33 <MarcelineVQ> Are you sure that's what you're after?
19:29:50 <LordBrain> no i'm not sure of anything, just learning this
19:30:25 <LordBrain> fmap ListE got it to type check and compile
19:30:34 <glguy> dfeuer: I’m coming and going; feel free to drop the question whenever. I check history generally
19:30:42 <LordBrain> but then i hit an issue at the call site to the template
19:31:20 <dfeuer> glguy, am I correct in thinking the data family trie representation is necessary to prevent the type checker from going into an infinite loop?
19:31:30 <LordBrain> i'm trying to write a template that takes an ordinary sum type and gives me a list of the names of its data constructors
19:31:41 <dfeuer> I couldn't find a way to do so with just a type family. But I don't for the life of me understand why a data family helps.
19:35:37 <glguy> dfeuer: You mean in my generic-tries package or in the MemoTrie one?
19:36:00 <dfeuer> glguy, I mean in the "tries" repo on github. I have no idea what if anything that corresponds to on Hackage.
19:36:36 <glguy> OK. I thought I had that as a type family on the Trie class
19:36:41 <dfeuer> It is.
19:36:53 <dfeuer> But the GTrieWhatever for the generic reps has it as a data family.
19:37:03 <lpaste> LordBrain pasted “First Template..” at http://lpaste.net/6454363886198980608
19:37:31 <dfeuer> And I ended up reinventing essentially that same wheel (type family for the main class, data family for the representation class) when I was playing around with making MemoTrie do generics better.
19:38:16 <LordBrain> I wonder if someone will take a look at it help me toward where i intend this to go, the problem is it compiles and all, but when i try to use it i get this error:
19:38:17 <glguy> dfeuer: It's a data family there because I wanted to associate a new data type with the sum case
19:38:22 <dfeuer> In my case, it was because if I stuck with a type family for the representation class, I threw the type checker down a hole when I wrote  instance TrieWhatever a => TrieWhatever [a]
19:38:27 <glguy> and I don't get any benefit from a type family
19:38:28 <LordBrain> http://lpaste.net/6454363886198980608
19:38:30 <LordBrain> oops
19:38:51 <LordBrain> ExampleABC.hs:34:16:
19:38:51 <LordBrain>     Phoenician is not in the type environment at a reify
19:38:51 <LordBrain>     In the splice: $(makeListOfNames ''Phoenician)
19:39:07 <dfeuer> So I experimentally stuck a data family there and it worked. But I don't understand *why* it worked.
19:39:17 <LordBrain> I should be able to inspect a type at call... maybe reify is not the right tool, but can someone help?
19:39:21 <dfeuer> (or, alternatively, why it didn't with a type family)
19:39:25 <dfeuer> So that's a bit troubling.
19:39:36 <glguy> I'd look at the code if you wanted
19:39:46 <dfeuer> Why did you want a new data type with the sum case in particular?
19:39:50 <glguy> I use a type family in the Trie class, and I have an instance for lists I think
19:39:55 <dfeuer> Right.
19:40:00 <dfeuer> But 
19:40:54 <glguy> I have multiple constructors and wanted multiple fields on one of them. if I used a type family I'd just have to define a separate data type anyway, and I know there's only something like 5 instances, so no benefit from a type family in the generic cases
19:42:23 <LordBrain> I annotated, with the call site and error message
19:42:31 <dfeuer> glguy, what I mean is that I tried various versions of replacing the GTrie data family with a type family, and in every case the type checker blew up deriving the list instance.
19:42:57 <dfeuer> (Not actually that type family, but the equivalent from MemoTrie.
19:42:58 <dfeuer> )
19:43:04 <glguy> dfeuer: Paste the problem code?
19:43:16 <dfeuer> I'll have to reconstruct it. Back in a bit.
19:43:21 <dfeuer> I actually
19:43:27 <dfeuer> constructed several versions.
19:43:31 <dfeuer> Might still have one around.
19:45:45 <lpaste> dfeuer pasted “Broken MemoTrie” at http://lpaste.net/1659589622465822720
19:45:46 <MarcelineVQ> LordBrain: Are these seperate in files?
19:45:50 <dfeuer> glguy, ^^
19:46:26 <LordBrain> MarcelineVQ, yes
19:47:05 <LordBrain> it seems like i need Phoenecian in scope in the module where i define the template, but i don't want that
19:47:22 <MarcelineVQ> It doesn't need that
19:47:24 <dfeuer> glguy, the Identity wrappers I thought might stop the infinite reduction did absolutely nothing.
19:47:39 <dfeuer> But I don't have the code without them anymore.
19:47:48 <MarcelineVQ> I'm not sure what's wrong for you, your code works as expected for me: main = print $(makeListOfNames ''Phoenician)      ["ALEP","BET"]
19:48:01 <LordBrain> oh wow, really?
19:49:00 <glguy> dfeuer: I think you'd want:   type K1 i a :->> b = a :->: b
19:49:04 <LordBrain> weird
19:49:14 <LordBrain> what version of ghc?
19:50:16 <MarcelineVQ> 8.0.1, I had to add an extra _ to DataD and NewtypeD because of a kind-argument change for them, but otherwise it's the same
19:51:05 <dfeuer> glguy, why does that fix it?
19:51:28 <LordBrain> well i don't have that version available here
19:51:40 <LordBrain> do you have an older ghc you can try?
19:51:42 <dfeuer> Oh, because the expression doesn't have any more redexes; they're hidden under a wrapper....
19:51:46 <MarcelineVQ> sure
19:52:26 <lpaste> glguy annotated “Broken MemoTrie” with “Broken MemoTrie (annotation)” at http://lpaste.net/1659589622465822720#a5881107467261181952
19:52:43 <glguy> dfeuer:  I didn't remove all the Identities, but that loads now
19:53:09 <LordBrain> MarcelineVQ, i intended the code to follow type synonyms as well, so make a type P = Phonecian and try it with P
19:54:22 <LordBrain> MarcelineVQ, you have the Phoenician type defined in the same file as main right?
19:54:27 <MarcelineVQ> yes
19:54:36 <LordBrain> so weird
19:54:57 <dfeuer> glguy, yeah, that does indeed seem to work. And I guess you can't end up with a type whose Rep loops infinitely without a K1 breaking it?
19:56:04 <glguy> Yeah, otherwise the occurence of [a] that occurs as a field of (:) leads you to define an recursive type
19:56:34 <MarcelineVQ> it'll take a little bit, I have a testing project I use for messy things and it's taking a bit to downgrade it to ghc 7.10.3
19:57:47 <LordBrain> oh
19:57:50 <LordBrain> thanks
19:57:50 <sophiag> hi. i'm on a new machine and having trouble updating cabal to get ghci working... cabal-install says it requires base >=4.5 && <5 and base says it requires invalid-cabal-flag-settings <0
19:58:04 <dfeuer> Thanks, glguy.
20:00:26 <glguy> sophiag: Paste what commands you're running and what output you're getting to http://lpaste.net
20:05:21 <sophiag> glguy: here's what i was referring to along with the original error code i was trying to correct http://lpaste.net/349572
20:06:19 <glguy> sophiag: what version of GHC are you trying to use?
20:09:05 <sophiag> i assumed it was the latest overnight build...8 something...but i'm on centos6 now so not sure what the package manager actually installed with haskell-platform
20:10:22 <sophiag> oh...7.04
20:10:28 <sophiag> a little old
20:10:53 <sophiag> it's aggravating being on centos6 and the package manager giving me old versions of everything
20:13:24 <glguy> Yeah, if you're going to use package managers of things you'll need to mostly stick to all package manager versions of things
20:13:44 <glguy> at least in the world of Haskell development on old or "stable" distributions
20:15:15 <sophiag> it's that my os is old and can't be easily updated so i'm getting older versions of many applications unless i build them manually
20:17:01 <sophiag> and i'm not sure how much control i have over this if it's not compatible with emacs haskell-mode
20:17:52 <sophiag> this answer seemed to make the most sense: http://emacs.stackexchange.com/questions/2582/haskell-interactive-mode-setup-cabal-unrecognised-command-repl
20:18:07 <glguy> in any case the error was because your GHC is too many years old for the version of cabal-install
20:18:15 <sophiag> ah ok
20:18:21 <glguy> and the base package comes fixed to the ghc version
20:18:24 <sophiag> so i have to go and update ghc manually
20:18:29 <glguy> yes
20:20:15 <lpaste> dfeuer pasted “So why does this work?” at http://lpaste.net/2040595346660261888
20:20:49 <dfeuer> glguy, your explanation of how to fix the type family version and what seems to have been wrong with it seems good. But I don't understand how it explains why the data family version I just pasted works.
20:22:07 <lpaste> dfeuer revised “So why does this work?”: “So why does this work?” at http://lpaste.net/2040595346660261888
20:22:10 <glguy> the type of the trie is now finite, data families don't evaluate away
20:22:39 <dfeuer> glguy, I don't understand.
20:23:32 <dfeuer> Oh.....
20:23:51 <dfeuer> Right, because the thing that would expand is now under a data constructor.
20:31:02 * lambda-11235 just realized declaration don't need to begin with 'let' in ghci anymore.
20:34:00 <kadoban> Ya ... that's always confusing. It's a nice change though
20:34:30 <parsecUser> Does anyone know if there's a performance difference between ST and IO?
20:35:00 <dfeuer> parsecUser, there is none.
20:35:21 <parsecUser> Is it just the same under the hood?
20:35:29 <parsecUser> The types are just different in the code?
20:35:49 <dfeuer> parsecUser, except maybe at a couple weird points, like runST vs unsafePerformIO, and unsafeInterleaveST vs unsafeInterleaveIO.
20:36:00 <dfeuer> At the weird points like that, ST should be faster.
20:36:51 <parsecUser> As in, at the point where you actually kick everything off?
20:36:53 <dfeuer> parsecUser, yes, they're represented exactly the same. I don't remember exactly, but something like  newtype ST s a = ST (State# RealWorld -> (# State# RealWorld, a #)
20:36:58 <parsecUser> But from there, everything is the same?
20:37:02 <dfeuer> parsecUser, yeah, or interleave unsafely.
20:37:09 <dfeuer> Er... that was wrong 
20:37:11 <dfeuer> I meant
20:37:20 <dfeuer> parsecUser, yes, they're represented exactly the same. I don't remember exactly, but something like  newtype ST s a = ST (State# s -> (# State# s, a #)
20:37:41 <parsecUser> Cool, you just saved me a bunch of time!
20:37:43 <dfeuer> Whereas   newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)
20:37:56 <parsecUser> I am using a UnionFind data structure, and was wondering if it'd actually matter if it was the IO or ST version
20:38:18 <dfeuer> If you want to use it in pure code, use ST.
20:38:33 <dfeuer> If you need to use it across I/O actions, use IO.
20:38:43 <dfeuer> If you need each use-case in different contexts,
20:38:47 <dfeuer> use the primitive package.
20:39:05 <dfeuer> (The primitive package offers clean ways to write code that will work in either IO or ST)
20:39:23 <dfeuer> (Through the PrimMonad (or MonadPrim?) class.)
20:39:39 <parsecUser> Interesting, did not know about those!
20:41:10 <parsecUser> Alright, well, I'll get back to profiling and come up with alternate theories
20:41:17 <parsecUser> Thanks for your help!
20:44:51 <dfeuer> No problem.
20:45:40 <sophiag> ugh, i'm getting this libgmp error on centos6 when trying to run "stack upgrade": http://lpaste.net/349575
20:49:50 <sophiag> the installation docs say i should just use yum, but that gives me a version too old for compatibility with emacs haskell mode
20:54:56 <dfeuer> sophiag, do you have any working stack installation?
20:55:35 <LordBrain> wouldn't that make her problem trivial
20:55:38 <dfeuer> If not, you should be able to install the old version using yum, and then use stack to upgrade itself. But I don't know the exact procedure.
20:55:59 <LordBrain> if her os is so old its using ghc 7.0.4, i don't know there is going to be a stack
20:57:04 <Koterpillar> CentOS 6 is supported: https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#centos
20:57:43 <Koterpillar> sophiag: that repo should give you the most recent version, which one do you get?
20:59:10 <sophiag> Koterpillar: the problem is i'm on centos6 so it doesn't. i'm on 7.04 :/
20:59:52 <sophiag> i can no longer do an inline upgrade to centos7 so have to do a lot of things manually. usually it works fine, at least if it doesn't require gtk3
21:01:50 <Koterpillar> sophiag: there's a repo for CentOS 6
21:02:32 <Koterpillar> sophiag: again, https://docs.haskellstack.org/en/stable/install_and_upgrade/#centos - see under "CentOS 6"
21:02:34 <sophiag> koterpillar: i know, it's just that it's outdated
21:02:43 <sophiag> i have that installed already
21:03:00 <sophiag> problem is i can't launch ghci from emacs haskell-mode
21:03:10 <sophiag> similar problem as here: http://emacs.stackexchange.com/questions/2582/haskell-interactive-mode-setup-cabal-unrecognised-command-repl
21:03:23 <sophiag> here was my previous paste: http://lpaste.net/349572
21:03:46 <sophiag> i don't think it's a path issue, although tried that as well...
21:05:53 <sophiag> ugh, yeah because i tried installing the exec-path-from-shell package and now the error is this: http://lpaste.net/349576
21:10:36 <adarqui> hey quick noob q.. say i have "1480998641" timestamp and want to turn it into POSIXTime, so I can do something like this: formatTime defaultTimeLocale  "%c" $ posixSecondsToUTCTime 1480998641 .. need to turn a text string into POSIXTime. any idea?
21:10:46 <adarqui> i always get wrecked with the various time functions ;/
21:11:25 <adarqui> i need to get that "timestamp" to NominalDiffTime
21:16:44 <kadoban> adarqui: NominalDiffTime appears to be an instance of Num. So what type is the number of seconds you have there? If it's a literal you're putting in code, you can treat it as type NominalDiffTime directly.
21:17:22 <kadoban> If it's not, try fromIntegral? Should work for most types you'd be using.
21:18:28 <codygman> @pl (readRec .) . tokenizeRow
21:18:28 <lambdabot> (readRec .) . tokenizeRow
21:18:33 <codygman> @unpl (readRec .) . tokenizeRow
21:18:34 <lambdabot> (\ x x0 -> readRec (tokenizeRow x x0))
21:19:36 <adarqui> thanks kadoban .. btw my haskell weak right now, what about this? i'm using read etc because i'm getting this value as a Text string:
21:19:39 <adarqui> formatTime defaultTimeLocale  "%c" (posixSecondsToUTCTime (fromIntegral (read "1480998641" :: Integer)))
21:19:42 <adarqui> "Tue Dec  6 04:30:41 UTC 2016"
21:20:40 <kadoban> adarqui: I guess that works, though 'read' isn't something you want to use in real code very much
21:20:52 <kadoban> > read "hi" :: Integer
21:20:54 <adarqui> ya.. im going to use readMaybe for now
21:20:54 <lambdabot>  *Exception: Prelude.read: no parse
21:26:48 <nomind> hi guys
21:27:18 <nomind> new haskell user and a new vimmer too
21:27:44 <adarqui> word, works.. sexier date timestamp (i previously just had the unix timestamp there.. tehehe): http://i.imgur.com/UCE3XK0.png
21:27:48 <nomind> any good plugins for vim+haskell that i should begin with?
21:28:10 <adarqui> i use haskell-vim-now, it's solid.. but im not a major "power user".. check it out tho
21:29:50 <nomind> i'm a bit scared of installing too many plugins at once
21:30:40 <nomind> is haskell-vim-now like a "one click install" or should i say "one command install" of many plugins?
21:30:48 <adarqui> ya
21:31:36 <nomind> i wanted to start slow. maybe first get something for proper indentation and style, next move to something to help with type signatures etc etc.
21:32:32 <Rotaerk> nomind, http://www.stephendiehl.com/posts/vim_haskell.html
21:32:34 <Rotaerk> maybe that
21:33:37 <nomind> i've seen it. but again it's too many plugins at once. being a new vim user, i don't wanna jump into the deep end immediately
21:33:50 <Rotaerk> it's a list of plugins; don't install them all at once if you don't want to
21:34:17 <Rotaerk> oh, it's been updated... http://www.stephendiehl.com/posts/vim_2016.html
21:34:37 <nomind> i'll check it out
21:48:08 <glguy> You can parse second since unix epoch directly with the time package, too: parseTimeM False defaultTimeLocale  "%s" "1480998641" :: Maybe UTCTime
21:48:09 <glguy> Just 2016-12-06 04:30:41 UTC
22:01:49 <haskell890> Hi, is there a function like fold that will stop evaluating when the params returns Nothing? 
22:02:19 <haskell890> I'm looking for something like `foldrM (\i a -> if i < 50 then Just i else Nothing) 0 [1..50]`, but with the function instead of foldrM
22:02:34 <haskell890> I can't seems to find something like this in hoogle
22:02:46 <glguy> :t foldM
22:02:48 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
22:07:33 <roboguy`_> > foldM (\i a -> if i < 50 then Just i else Nothing) 0 [1..50]
22:07:35 <lambdabot>  Just 0
22:15:47 <glguy> The "accumulator" comes first, if I'm to guess what 'a' means
22:18:06 <roboguy`_> > foldM (\a i -> if i < 50 then Just i else Nothing) 0 [1..50]
22:18:08 <lambdabot>  Nothing
22:18:24 <roboguy`_> Not terribly exciting...
22:19:58 <geppettodivacin> haskell890: What's wrong with foldM for this kind of purpose? Once it reaches Nothing, it should exit early, as expected.
22:20:02 <roboguy`_> > foldM (\a i -> if i < 50 then Right i else Left i) 0 [1..100]
22:20:04 <lambdabot>  Left 50
22:20:09 <roboguy`_> actually...
22:20:19 <haskell890> oooooh that's really clever
22:20:22 <geppettodivacin> > foldM (\a i -> if i < 50 then Right i else Left i) 0 [1..]
22:20:25 <lambdabot>  Left 50
22:20:26 <roboguy`_> > foldM (\a i -> if i < 50 then Right (error "Never reached!") else Left i) 0 [1..100]
22:20:29 <lambdabot>  Left 50
22:20:43 <haskell890> wait why
22:20:57 <haskell890> oh I see lazy eval
22:21:18 <haskell890> foldM (\a i -> if i < 50 then Right (error "Never reached!") else Left a) 0 [1..100]
22:21:18 <geppettodivacin> That's it!
22:21:44 <geppettodivacin> You need the > in front to make it run.
22:22:00 <geppettodivacin> > foldM (\a i -> if i < 50 then Right (error "Never reached!") else Left a) 0 [1..100]
22:22:02 <lambdabot>  Left *Exception: Never reached!
22:22:24 <geppettodivacin> That's pretty neat.
22:23:09 <geppettodivacin> > foldM (\a i -> if i < 50 then Right (i + a) else Left a) 0 [1..100]
22:23:11 <lambdabot>  Left 1225
22:23:22 <geppettodivacin> > sum [1..50]
22:23:24 <lambdabot>  1275
22:28:42 <jle`> > sum (takeWhile (<50) [1..])
22:28:45 <lambdabot>  1225
22:29:00 <jle`> > sum [1 .. 49]
22:29:03 <lambdabot>  1225
22:31:02 <roboguy`_> I noticed that an "infinite" sequence of Either monad binds can be used to actually calculate things a little while back, giving a the result in a Left. I've always wondered if anyone uses this technique in practice...
22:31:51 <jle`> most people usually use <|> and Maybe's i think for something like that
22:32:25 <nevere> How can I send emails from my haskell web app without blocking the request handling process?
22:32:41 <codygman> I know how to write this function imperatively using indexes, but how would I do it functionally?    f "word1word2word3word4" [("ColA",5),("ColB",5),("ColC",5),("ColD",5)] == [("ColA","word1"),("ColB","word2"),("ColC","word3"),("ColD","word4)]
22:33:06 <jle`> roboguy`_: but, there's also a library that abstracts over this "go infinitely until you see a left" pattern that you mentioned
22:33:13 <jle`> roboguy`_: it's tekmo's 'break' library
22:33:21 <unskill> guys! Attention, please! What is functional programming?
22:33:40 <dmj`> unskill: there is no agreed upon definition for that term
22:33:51 <jle`> it's basically just Either but with cute combinator names to evoke break-like happy thoughts
22:34:08 <roboguy`_> jle`: ah, interesting. Looks like it's more refined than my version: generalFold fn initial = let Left result = go initial in result where go x = fn x >>= go
22:35:22 <jle`> codygman: what exactly does your function do?
22:35:34 <jle`> codygman: does it ust break the first strings into chunks of 5 characters
22:35:36 <jle`> and zips them?
22:35:39 <jle`> oh i see, there are numbers
22:35:57 <codygman> jle`: Yes, I think I see hwo to turn it into a fold
22:36:13 <jle`> yeah it would probably be a fold with "word1word2 ..." as the accumulator
22:36:35 <roboguy`> I like that it *almost* looks like it could have a pattern match failure, but it actually never can =)
22:37:46 <codygman> jle`: I'm stuck a bit on how to build the list of tuples and accumulate the shrinking string
22:38:20 <jle`> oh i guess there are two accumulators
22:38:29 <jle`> the shirnking string and the accumulating string
22:39:29 <jle`> foldl' (\(words,output) (tag, n) -> let (w,ws) = splitAt n words in (ws, output ++ [(tag, w)]))
22:39:42 <jle`> i'd probably just write it using explicit recursion myself
22:40:11 <codygman> jle`: Oh I see
22:50:44 <nevere> How can I send emails from my haskell web app without blocking the request handling process?
22:54:46 <nevere> What is the standard procedure for firing up tasks like sending mail via a remote smtp server, without blocking the current thread? 
22:54:55 <rblaze> nevere: run sender in separate thread
22:57:22 <sabekukku> hi, Can someone explain instance (Arbitrary a, CoArbitrary b) => CoArbitrary (a -> b) where
22:57:23 <sabekukku>   coarbitrary f gen =
22:57:23 <sabekukku>     do xs <- arbitrary
22:57:24 <sabekukku>        coarbitrary (map f xs) gen
22:57:37 <sabekukku> defined in class CoArbitrary a where
22:57:48 <sabekukku> 1 coarbitrary 4::1 a 4->1 Gen b 4->1 Gen b
22:58:07 <sabekukku> I understand that we are trying to generate functions from a -> b 
22:58:20 <sabekukku> xs <- arbitrary gets a value of type a
22:58:28 <sabekukku> but what is map f xs 
22:58:35 <sabekukku> f is a function from a - >b
22:58:52 <nevere> rblaze: Yes. I am looking at this package https://hackage.haskell.org/package/jobqueue-0.1.6/docs/Network-JobQueue.html, can this be used to implement the other thread. How can I communicate between my main thread and the sender thread?
22:59:06 <sabekukku> but how can map be applied? how come xs is a list?
23:00:28 <roboguy`> :t arbitrary
23:00:32 <lambdabot> Arbitrary a => Gen a
23:00:50 <roboguy`> :t arbitrary :: Arbitrary a => Gen [a]
23:00:52 <lambdabot> Arbitrary a => Gen [a]
23:00:56 <roboguy`> ^ sabekukku it uses the list instance
23:01:24 <jle`> sabekukku: whe you do 'xs <- arbitrary', you're generating an arbitrary list and naming it xs
23:01:34 <rblaze> nevere: MVars, IOVars, STM, there are a lot of options. I would highly recommend reading this book, it gives a lot of insights: http://community.haskell.org/~simonmar/pcph/
23:07:16 <nevere> rblaze: Thankyou. Will definitely read it. But isn't there a prebaked stanadard solution for this, without having to deal with the low level details?
23:10:22 <rblaze> nevere: depends on why do you want to communicate with main thread. If you need just to fire and forget mail send, use smtp-mail and do something like 'forkIO $ sendMail "foo" mail'
23:11:12 <rblaze> nevere: this will run sendMain in its own thread
23:11:45 <sabekukku> thanks
23:11:53 <nevere> rblaze: If fork a new process, what happens when by request processing thread is finished and the mail sending thread is only half way, will it get killed too?
23:14:01 <rblaze> nevere: no, such threads are independent. It will only be killed if process exits. But you will probably want to wrap sendMail in exception handler, for logging failed deliveries.
23:14:41 <rblaze> nevere: forkFinally may be of help there
23:16:51 <nevere> rblaze: When should I use something like Network.AMQP for this?
23:20:56 <rblaze> nevere: as far as I understand, AMQP/RabbitMQ is for internal message exchange in distributed applicatons. Very little in common with email, which is sent to humans (normally). You may want to use AMQP if writing an app occupying entire server cluster and in need of job coordination.
23:25:32 <nevere> rblaze: In the fork method, in case of a process crash, wouldn't I loose status of all the started sender threads?
23:31:47 <rblaze> nevere: sure you will. If this is a problem, save progress to some storage, local or otherwise. But preventing data loss or keeping consistent state is more of design problem. Any comm library will lose data just the same if process crashes before send is completed.
23:46:33 <slack1256> does Data.ByteString.Lazy.Char8.readfile suffer fromt the same problems of Lazy IO?
23:48:08 <cocreature> slack1256: yes
23:48:57 <slack1256> damn, I reduced the space usage from 250mb max residency to 50mb thinking I was clever...
23:49:06 <slack1256> oh well, io-streams
23:49:12 <cocreature> io-streams, pipes, conduit, …
23:49:15 <cocreature> whatever you like :)
23:50:12 <cocreature> slack1256: also lazy IO might not be a problem in your application
23:50:21 <cocreature> slack1256: it’s mostly a problem for long running programs
23:50:46 <cocreature> but it’s easy enough to avoid so personally I just try to never use it
23:51:28 <slack1256> I think in fact this case is an easy "fix" without any problems
23:51:55 <slack1256> I made hasktags reduce max residency when scanning ghc only using lazy BL
