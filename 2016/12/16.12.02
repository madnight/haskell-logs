00:00:04 <grantwu> This only happened after I increased the number of literals in the list
00:00:13 <lonokhov> tdammers: basically it warp erros on client disconnecting on keep-alive session.
00:00:14 <grantwu> blegh I'll look into making a repro case later
00:00:35 <lonokhov> tdammers: I don't know if it is an error in HTTP spec
00:02:57 <tdammers> hmm, that doesn't seem right
00:03:09 <geppettodivacin> :t intersperse
00:03:10 <lambdabot> a -> [a] -> [a]
00:03:22 <grantwu> I guess my question is - is this sort of thing, a compile-time constant that might take a while to evaluate - something that is known to trigger this bug?
00:04:44 <grantwu> Also yeah it would be nice to have intercalate for monoids, I guess?
00:08:18 <MarcelineVQ> grantwu: there's come trac's about the subject but none I saw mention that specifically. see if the top one is halfway relevant for you, since it's going to be fixed, http://tinyurl.com/jdcg5kz
00:09:33 <grantwu> MarcelineVQ: I... not sure
00:09:51 <grantwu> MarcelineVQ: We fixed it with -fsimpl-tick-factor=250
00:10:03 <grantwu> It seems like that bug is referring to an infinite loop, so that probably isn't it?
00:12:21 <tdammers> grantwu: sort of, although the behavior would be slightly surprising for some monoids, e.g. Maybe
00:13:08 <grantwu> surprising how?
00:13:12 <tdammers> e.g. intercalate (Just a) xs amounts to fromMaybe a . headMay $ xs
00:16:26 <grantwu> hrm
00:17:42 <ertes> :t \s xs -> foldr (\x y p -> p (s <> x <> y const) (x <> y const)) mempty xs (const id))
00:17:43 <lambdabot> error: parse error on input ‘)’
00:17:48 <ertes> :t \s xs -> foldr (\x y p -> p (s <> x <> y const) (x <> y const)) mempty xs (const id)
00:17:51 <lambdabot> (Monoid b, Foldable t) => b -> t b -> b
00:18:02 <ertes> @let mintercalate s xs = foldr (\x y p -> p (s <> x <> y const) (x <> y const)) mempty xs (const id)
00:18:04 <lambdabot>  Defined.
00:18:13 <ertes> > mintercalate "," ["abc", "def", "ghi"]
00:18:16 <lambdabot>  "abc,def,ghi"
00:18:31 <ertes> > mintercalate (Just ',') (Just 'a')
00:18:34 <lambdabot>  error:
00:18:34 <lambdabot>      • Couldn't match type ‘Char’ with ‘Maybe Char’
00:18:34 <lambdabot>        Expected type: Maybe (Maybe Char)
00:18:45 <ertes> > mintercalate (Just ',') [Just 'a']
00:18:51 <lambdabot>  error:
00:18:51 <lambdabot>      • No instance for (Monoid Char)
00:18:51 <lambdabot>          arising from a use of ‘mintercalate’
00:19:06 <ertes> > mintercalate (Just ",") [Just "a", Just "b", Just "c"]
00:19:11 <lambdabot>  Just "a,b,c"
00:20:09 <tdammers> you could also just > @let mintercalate s = mconcat . intersperse s
00:21:15 <grantwu> :t intersperse
00:21:17 <lambdabot> a -> [a] -> [a]
00:21:23 <grantwu> Isn't intersperse only for lists?
00:23:05 <ertes> it could be more general
00:23:44 <ertes> but the result is always a list
00:23:55 <ertes> :t \s xs -> foldr (\x y p -> p (s : x : y const) (x : y const)) mempty xs (const id)
00:23:57 <lambdabot> Foldable t => a -> t a -> [a]
00:24:08 <ertes> we don't have a more general notion of "cons" in base
00:52:57 <Koterpillar> Can I derive Default for a record?
01:04:42 <lyxia> http://hackage.haskell.org/package/data-default-class-0.1.2.0/docs/Data-Default-Class.html looks like you can
01:05:31 <Koterpillar> thank you, I was using data-default
01:05:34 <Koterpillar> I'll change
01:08:51 <lyxia> what were you using
01:10:37 <Koterpillar> http://hackage.haskell.org/package/data-default
01:10:41 <ertes> Koterpillar: if you derive Generic, it will write the instance for you
01:10:54 <ertes> data MyType = MyType { … }  deriving (…, Generic, …)
01:11:04 <Koterpillar> yes, I'm doing that now
01:11:35 <ertes> you still need to write the instance, but without 'def':  instance Default MyType
01:12:05 <Koterpillar> well, I've done deriving (Default, Generic, ...)
01:12:22 <Koterpillar> not sure if that's better
01:12:48 <ertes> i don't see how that could even work, unless your type is a newtype
01:13:05 <Koterpillar> DeriveAnyType
01:13:06 <ertes> typically to use generic deriving you write an instance and just leave out the member definitions
01:13:16 <lyxia> Koterpillar: data-default depends on data-default-class actually
01:13:17 <ertes> ah, i don't know how that works
01:13:20 <Koterpillar> that's what intero told me to do, anyway
01:13:37 <lyxia> It's the same class
01:14:06 <Koterpillar> lyxia: the other way around
01:14:21 <lyxia> Koterpillar: ?
01:14:42 <Koterpillar> data-default-class depends on data-default
01:14:44 <lyxia> ertes: DeriveAnyType makes the deriving syntax do the same as empty instance declarations
01:14:55 <ertes> yeah, i just checked
01:15:02 <Koterpillar> oh, wait, I'm reading it wrong
01:15:04 <ertes> with DeriveAny*Class* you can just use deriving
01:15:19 <lyxia> haha right
01:28:57 * hackagebot superbuffer 0.2.0.0 - Efficiently build a bytestring from smaller chunks  https://hackage.haskell.org/package/superbuffer-0.2.0.0 (AlexanderThiemann)
02:28:59 * hackagebot patat 0.4.3.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.4.3.0 (JasperVanDerJeugt)
04:16:09 <hackrilege> Hi, is there a subclass of Monoid which includes a generator element? Eg Nat has identity 0, (+) as an associative operator and 1 as a generator
04:17:22 <hackrilege> class Monoid a => Something a where generator :: a
04:18:28 <hpc> what properties does 1 have relative to 0 and (+) that you want to preserve?
04:18:51 <hackrilege> Repeated application of (+1) produces the group
04:18:59 <hackrilege> Applied to the identity
04:19:12 <tdammers> if it's a notion of "next value after", or "enumeration of all elements", then I guess you want the Enum typeclass
04:19:55 <hackrilege> iterate (mappend generator) 0 spans the set
04:20:12 <hpc> so basically 1 = epsilon
04:20:14 <hackrilege> (hackrilege) iterate (mappend generator) mempty
04:20:31 <hpc> Enum is probably the right thing for this
04:21:23 <hackrilege> No
04:21:24 <ertesx> hackrilege: there is no such thing in base, but you could easily make such a class
04:21:35 <ertesx> hackrilege: class (Monoid a) => Cyclic a
04:21:36 <hackrilege> That requires methods casting to and from Int
04:21:46 <hackrilege> I'm just using Nat
04:21:52 <hackrilege> No negative numbers
04:22:06 <hackrilege> So not an instance of Enum
04:22:16 <ertesx> no, Enum is not the right class for this
04:23:20 <tdammers> although the "cast Int to enum" operation is partial for many instances
04:23:36 <hackrilege> Is Cycle seems a reasonable name
04:23:38 <merijn> tdammers: Also potentially partial the other way around :)
04:23:39 <hackrilege> https://en.m.wikipedia.org/wiki/Cyclic_group
04:23:39 <tdammers> > toEnum 500 :: Bool
04:23:42 <lambdabot>  *Exception: Prelude.Enum.Bool.toEnum: bad argument
04:23:51 <merijn> tdammers: If your datatype has > #Int elements :p
04:23:58 <ertesx> hackrilege: well, it's cyclic *monoid* in this case, which is probably not a well known term, but it works for monoids, too
04:24:18 <hackrilege> Yes because of the lack of inverse
04:24:21 <hackrilege> Thanks
04:24:33 <hackrilege> A nice new class, don't see them every day
04:25:00 <tdammers> come to think of it, Enum is actually a rather messy class
04:25:11 <ertesx> hackrilege: unfortunately many monoids are generated by many generators, so you are binding a type to a specific one
04:25:21 <byorgey> I don't know if "cyclic monoid" is really a good term for things like Nat
04:25:32 <merijn> tdammers: Yes
04:25:35 <byorgey> the whole point is that it is not a group *because* it doesn't close up into a cycle.
04:25:35 <ertesx> true, i didn't think of that
04:25:46 <ertesx> hackrilege: perhaps just "Generated" then
04:25:49 <ertesx> instead of Cyclic
04:25:58 <hackrilege> I don't know if Enum is a good name for things being like Int...
04:26:08 <grantwu> what do you mean by "close up into a cycle?"
04:26:22 <ertesx> grantwu: "finite"…  at some point you come back to mempty
04:26:36 <grantwu> http://mathworld.wolfram.com/CyclicGroup.html seems to imply that infinite cyclic groups exist.
04:26:52 <merijn> grantwu: Group is more specific than Monoid, though
04:27:00 <merijn> grantwu: Group would require the existence of an inverse
04:27:14 <merijn> Unless my algebra memory is failing me
04:27:19 <byorgey> grantwu: right, that was pretty vague language.  I just meant that if the monoid is finite, when iterating (1+) you have to eventually get back to mempty.  (Actually, now I am not sure whether that is true...)
04:27:21 <grantwu> I think that's right
04:27:21 <merijn> Also, don't groups have two binary operations?
04:27:29 <byorgey> merijn: no, you are thinking of rings
04:27:37 <merijn> byorgey: ah, right
04:27:45 <hackrilege> If prime modulo addition is used every element is a generator :D
04:27:55 <grantwu> merijn: But if groups are special monoids - and infinite cyclic groups exist - then infinite cyclic monoids would exist, right?
04:27:58 <byorgey> grantwu: yes, infinite cyclic groups exist, e.g. Z.  I don't think "cyclic" is a good name for those either =)
04:28:06 <grantwu> heh
04:28:17 <byorgey> grantwu: yes, but we were talking about infinite "cyclic" monoids which are *not* groups
04:28:17 <ertesx> byorgey: i've found other sources that allow cyclic groups to be infinite, although all infinite cyclic groups seem to be isomorphic to (ℤ, +)
04:28:28 <byorgey> ertesx: yes, I think that's right
04:28:52 <byorgey> after all, all finite cyclic groups are isomorphic to (Z_m, +)
04:28:58 <grantwu> oh, I think the point I was trying to make here is
04:29:15 <grantwu> Any finite cyclic monoid is necessarily a finite cyclic group, right?
04:29:22 <hackrilege> Yes if it has a generator then it is countable
04:29:37 <ertesx> perhaps "cyclic" is just fine, and it allows one singularity: infinity
04:29:46 <byorgey> grantwu: that's the point I was making as well.  Though now I am unsure whether I believe it.
04:30:05 <grantwu> byorgey: Hrm.  Why don't you believe it?
04:30:16 <ertesx> byorgey, grantwu: actually i believe it
04:30:28 <hackrilege> It's a bijection so your theorem holds
04:30:42 <ertesx> let x^n = 1, then x^(n - 1) = n^(-1)
04:30:53 <hackrilege> Well something like that....
04:30:59 <ertesx> let x^n = 1, then x^(n - 2) = (n^2)^(-1)
04:30:59 <byorgey> ertesx: but why must you have an n such that x^n = 1 ?
04:31:00 <ertesx> etc.
04:31:08 <byorgey> that's the crux of it
04:31:26 <grantwu> byorgey: Because for every element in the set you can continue applying +1 until you get mempty again
04:31:27 <byorgey> perhaps 1+1 = 2, 2+1 = 3, ... and then  12+1 = 6
04:31:32 <hackrilege> You mean Zn
04:31:35 <byorgey> grantwu: but why do you have to get mempty again?
04:31:45 <ertesx> i see your point
04:31:49 <grantwu> byorgey: Because it's a cyclic and finite, right?
04:31:56 <byorgey> you have to reach *some* cycle, but it doesn't have to go back to mempty
04:32:16 <byorgey> the monoid could be shaped like a cycle with a little tail hanging off of it
04:32:28 <hackrilege> A finite Monoid must be cyclic in the way you are using the word
04:32:31 <grantwu> I don't think that's quite the definition of a cyclic structure
04:32:33 <byorgey> at least I *think* this is possible, perhaps some other monoid axioms rule this out
04:32:43 <ertesx> byorgey: i think one can prove even without inverses that x^|M| = 1 for all x, but i'm not entirely sure
04:33:05 <grantwu> http://mathworld.wolfram.com/CyclicGroup.html says that a cyclic group is one in which all elements are generated by a group generator
04:33:06 <byorgey> ertesx: the proof I know depends on inverses
04:33:24 <byorgey> ertesx: but you might be right.
04:33:34 <ertesx> i'd like to investigate that…  time to fire up agda, but not right now
04:33:35 <grantwu> I don't think a cycle with a tail on it would qualify
04:33:51 <hackrilege> A cyclic finite Monoid is a group so you can use the inverse
04:33:57 <byorgey> ertesx: same =)
04:34:04 <hackrilege> -cyclic
04:34:17 <byorgey> hackrilege: no, that's exactly what we are questioning in the first place =)
04:35:14 <hackrilege> Infinite application of the generator producing repeated elements means some power of the generator is the identity
04:35:35 <hackrilege> Otherwise it would not be finite
04:35:39 <byorgey> hackrilege: no, that argument depends on inverses existing, doesn't it?
04:35:45 <hackrilege> No
04:35:45 <ertesx> byorgey: refuted:  2^15 ≢ 1 (mod 15)
04:35:59 <ertesx> however, 2^15 ≡ 1 (mod 8)
04:36:19 <ertesx> so new hypothesis:  x^|M*| = 1  for all x
04:36:41 <ertesx> where M* is the group of all units in M
04:37:05 <byorgey> anyway, IRC is not a good medium for this because it is hard to pin down the exact definitions of things we are talking about =)
04:37:20 <ertesx> refuted again:  3^8 ≢ 1 (mod 15)
04:37:30 <ertesx> ok, i now believe that cyclicness only makes sense in the context of a group
04:39:42 <ertesx> of course…  there is no guarantee that a non-unit will every reach the identity element…  and if it doesn't, then it doesn't generate a monoid to begin with
04:41:01 <unskill> I will ask my stupid question again, because it seems that everybody was sleeping when I asked 12 hours ago.
04:41:02 <ertesx> and in fact if it does reach the identity element, it couldn't be a non-unit
04:41:22 <unskill> we all know that partial derivative of a type gives us a context in zipper for the type. did anybody studied the second derivative? e.g. the second derivative of a list gives us 2*L(x)³, which makes sence. L³ is a triple of lists (xs,ys,zs) and '2' points to the first or secod comma (hole) between lists. 
04:41:37 <unskill> but it seem to me that the middle list should be double-linked. i.e. accessible from both ends
04:42:37 <ertesx> hackrilege: without formal proof (yet) i strongly believe now that any monoid generated from a single element must be a group…  so i'm confident that what you want is a cyclic group
04:42:43 <hackrilege> it will always hit mempty even if it does not got every element
04:43:19 <byorgey> unskill: yes, second derivative gives you two holes, where the holes can be distinguished
04:43:33 <hackrilege> It will orbit if the generator does not divide the length
04:43:34 <ertesx> hackrilege: try to generate (ℤ/15ℤ, +)
04:43:42 <byorgey> unskill: the specific implementation of the lists is irrelevant, this is only up to isomorphism
04:43:54 <hackrilege> I don't get that notation
04:43:56 <ertesx> hackrilege: wait
04:43:59 <ertesx> hackrilege: try to generate (ℤ/15ℤ, *)
04:44:09 <ertesx> hackrilege: the multiplicative monoid modulo 15
04:44:54 <unskill> byorgey: is there any use of two holes?
04:46:01 <Gurkenglas__> http://stackoverflow.com/a/40932536/5318306 <- How do I make that console line run that script?
04:46:09 <hackrilege> Nat is not a grop though... Only finite Monoid are groups
04:46:44 <byorgey> unskill: there might be, I don't know.  It's like a zipper with two cursors I guess.
04:47:04 <ertesx> mh…  my beautiful reasoning is defeated by infinity again =/
04:47:34 <Gurkenglas> Free translation from German: 'The command "." is either mistyped or could not be found.'
04:47:40 <tdammers> "you just wait" -- infinity
04:48:06 <hackrilege> That's what, Lagrange partitioning ertesx? I can't remember the name
04:48:47 <ertesx> "that was fun!  let's play hide and seek again…  now you count to 10…" – "1, 1, 2, 3, 5, 8, 13, 21, …"
04:48:56 <byorgey> Gurkenglas: are you on Windows?
04:49:00 <Gurkenglas> yep
04:49:31 <byorgey> Gurkenglas: I don't think commands like './conduitnub.hs'  work at the Windows command prompt, that is unix-specific
04:49:48 <hackrilege> Right so sometimes you need more than one generator https://en.m.wikipedia.org/wiki/Lagrange's_theorem_(group_theory)
04:50:04 <byorgey> Gurkenglas: In fact the whole #!/usr/bin/env stack  thing is probably unix-specific as well.  I do not know if you can do something similar on Windows.
04:50:12 <ertesx> hackrilege: no, that's a statement about subgroups of groups, not unit groups of monoids
04:50:40 <Gurkenglas> Ah there yep Windows was the problem. https://github.com/commercialhaskell/stack/wiki/Script-interpreter <- "(on Windows, you will have to run stack <script>.hs)" and that seems to install stuff now k
04:50:59 <byorgey> great
04:51:02 <hackrilege> But that's why I can't generate your group....
04:51:37 <ertesx> hackrilege: you can't generate the *monoid*, and the reason is simple: any product of units is also a unit, and any product of non-units is also a non-unit
04:51:51 <ertesx> you couldn't find a generator that reaches *both*
04:52:23 <ertesx> hackrilege: interestingly in this particular case you couldn't even generate the unit group
04:53:32 <hackrilege> Argh
04:54:19 <hackrilege> Unskill, I was always interested, how do you differentiate a type!?
04:54:38 <hackrilege> I couldn't see how the fundamental theorem of calculus could apply
04:55:03 <unskill> hackrilege: google about zippers and type derivation. It is like symbolic derivation.
04:55:14 <hackrilege> I think a list of lists can have as many cursors as elements...
04:56:18 <geppettodivacin> Do normal list operations (like map, foldr, and zipWith) use stream fusion? And if so, is there a list somewhere of functions that do?
04:56:37 <ertesx> geppettodivacin: they use a different kind of fusion:  build/foldr fusion
04:57:12 <geppettodivacin> Do all the listed functions use it?
04:57:20 <Axman6> no
04:57:42 <ertesx> geppettodivacin: if you're uncertain, just read the source code and look for fusion rules
04:57:52 <ertesx> it's really easy to read
04:58:48 <geppettodivacin> Why isn't it mentioned in the Haddocs?
04:59:23 <Axman6> what would you like the documentation to say?
04:59:59 <merijn> The GHC manual lists fusable functions
05:00:25 <geppettodivacin> Axman6: "This function uses build/foldr fusion" ?
05:00:34 <geppettodivacin> I would imagine that would be helpful.
05:02:04 <Tuplanolla> Here it is: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#list-fusion
05:02:25 <Axman6> it's never something I've needed to know in my 9 years of using haskell
05:02:46 <unskill> hackrilege: when you introduce a ring of polynomials as just finite sequences of coefficients (a0, a1, a2, ..., 0, 0, 0,...) which corresponds to a0*x⁰+a1*x¹+a2*x²+... and you dont speak about  continuity but still introduce differentiation as a map between sequences, e.g. turning mentioned one into (a1, 2a2, ...)
05:03:42 <hackrilege> Hold up I need to turn on the cooling system
05:03:42 <geppettodivacin> It's more something I was curious about when looking at ways to make kind of slow code a little faster.
05:04:11 <unskill> hackrilege: sum, multiplication haz its interpretation in algebraic data types, but, TBH, polynomials is not enough for lists, we need infinite series.
05:04:57 <hackrilege> Nope, something snapped
05:05:52 <hackrilege> Lists are infinite?
05:05:57 <hackrilege> Can be*
05:06:00 <cocreature> [1..]
05:06:04 <cocreature> that’s infinite
05:06:49 <hackrilege> And maybe, lists is not enough for polynomials? Still struggling to decipher
05:06:51 <geppettodivacin> My use case was zipWith (+) (zipWith f xs ys) (zipWith g xs ys). Since it only fuses one of these streams (constructing a list for one of the two arguments) if there's a better way of doing it.
05:07:22 <unskill> hackrilege: lists could be thought about as sum type of empty tuple, one element tuple, two element tuple etc. and this sum is infinite
05:07:46 <hackrilege> Drastic
05:07:52 <cocreature> geppettodivacin: looks like "zipWith (\x y -> f x y + g x y)"
05:07:53 <geppettodivacin> hackrilege: Theoretically, you could have a polynomial that's infinite.
05:08:07 <hackrilege> Ok
05:08:20 <geppettodivacin> cocreature: Yeah, that actually looks like it.
05:08:24 <Tuplanolla> That's not a polynomial anymore, is it?
05:08:24 <unskill> hackrilege: you misunderstood I dont propose you to represent polynomials by lists...
05:08:38 <unskill> geppettodivacin: then they called "series"
05:08:45 <hackrilege> Lists by polynomials of tuples?
05:08:48 <cocreature> geppettodivacin: personally I also find that easier to read
05:09:31 <hackrilege> Still not getting the link between lists and polynomials I'm afraid
05:10:09 <unskill> hackrilege: https://www.youtube.com/watch?v=YScIPA8RbVE
05:10:16 <hackrilege> Thanks!
05:10:16 <cocreature> Tuplanolla: yeah they are typically called “formal power series”
05:10:50 <hackrilege> I'll drink some linseed oil and set to
05:11:15 <unskill> hackrilege: link is that you don't need calculus theorems to differentiate. You can just postulate for polynomials that d(x^n) is n*x^(n-1).
05:11:42 <hackrilege> So just a symbolic association
05:12:06 <unskill> hackrilege: yes. And you can differentiate types the same way. symbolically
05:12:28 <hackrilege> I actually don't know what I'm talking about, let me watch this and maybe I can converse meaningfully
05:12:50 <cocreature> that’s often refered to by “formal derivative”
05:13:06 <hpc> to give a specific simple example, data Maybe a = Nothing | Just a
05:13:22 <hpc> using the algebra in "algebraic data type", Maybe = λx. x + 1
05:13:37 <hpc> and the derivative of that is 1, or ()
05:13:57 <hackrilege> Brain. Melting
05:14:57 <hackrilege> What is the + ?
05:15:11 <hackrilege> It's like | ?
05:15:14 <hpc> yeah
05:15:24 <hackrilege> Oh so that makes sense
05:15:25 <hpc> like, Bool = 2 because it has two values
05:15:35 <hpc> or it's 1 + 1 because it's False | True
05:15:36 <hpc> yeah
05:16:11 <hackrilege> So the derivative of bool is ()
05:16:26 <hpc> the derivative of a constant function is 0, or Void
05:16:27 <hackrilege> Nice, so I guess list next
05:17:25 <hackrilege> data [a] = a:[a] | []
05:17:29 <unskill> List a = Nil | Cons a (List a) or L(x) = 1 + x*L(x)
05:17:52 <hackrilege> I like this fancy notation
05:18:09 <hackrilege> Is that what scala is like?
05:18:45 <hpc> probably not
05:18:49 <liste> hackrilege: the type definition notation? no
05:18:54 <liste> Scala defines types more like Java
05:19:00 <hpc> but algebra with data types is the gateway drug to some pretty neat theory
05:19:12 <hackrilege> (It has plenty of lambdas all about the place)
05:20:28 <hackrilege> So can I use product rule? How do I treat the recursive bit?
05:20:48 <hpc> use the chain rule
05:20:57 <hpc> but you can't actually dig deeper inside L, you have to leave it at L'
05:21:46 <ggVGc> when is it useful to do algebra on your algebraic types?
05:21:47 <hpc> that one's going to probably get ugly though
05:22:14 <hpc> ggVGc: i have only ever done it here
05:22:26 <hpc> but i also don't get very theoretical in my code
05:22:34 <unskill> hackrilege: L(x) = 1/(1-x)
05:22:41 <hackrilege> L + x*K'
05:22:52 <hackrilege> L' *
05:23:11 <unskill> hackrilege: but the problem is there is no subtraction and division for types
05:23:37 <unskill> hackrilege: so you think  1/(1-x) as series 1 + x + x^2 + ...
05:23:53 <hackrilege> Omg I'm not differentiating that where is my wolfram terminal. This isn't undergrad physics! Ey gads
05:24:09 <hackrilege> Oh yeah that's the trick I remember now
05:25:02 <hackrilege> Etc etc differentiation complete, time for snacks
05:29:06 * hackagebot patat 0.4.4.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.4.4.0 (JasperVanDerJeugt)
05:29:47 <hackrilege> It's the exponential right, it's its own derivative
05:30:22 <hackrilege> Maybe I did something wrong...
05:30:30 <hackrilege> Argh nvm
05:31:09 <unskill> L(x) = 1/(1-x), L'(x) = (1/(1-x))^2 = L(x)*L(x)
05:31:19 <unskill> So derivation of list is a pair of lists
05:32:50 <buttbutter> Say I have some function avg :: [Double] -> Double that I want to use in a where clause in another function. Ideally, I want to call the variable in the where clause avg as well...since that is what it is (i.e. where avg = avg [1,2,3,4]). Obviously can't do that, so I'll usually do avg_ = avg [1,2,3,4] or something. Is there a convention for this sort of variable-function name clash?
05:35:41 <jchia_> I have a version of a function using (.) and a version using (&). Which is better? http://lpaste.net/348988
05:36:47 <jchia_> I like reading from left to right. toValue1 seems easier to read, but I don't know what the compiler is going to do in terms of laziness and optimization.
05:37:35 <liste> toValue2 is easier to read for me
05:40:29 <AndreasK>  buttbutter: What i've seen is people using the convention of my_function as where variables. Using a trailing underscore for single word functions seems like a reasonable extension for single words. But maybe just use a more specific name in where
05:40:53 <AndreasK> buttbutter: like argument_avg = avg [1..5]
05:41:37 <kuribas> buttbutter: you could use theAvg
05:42:27 <maerwald> buttbutter: avg'
05:42:43 <buttbutter> tl;dr: there isn't a convention :P
05:43:06 <maerwald> foo vs foo' is used very heavily throughout the haskell ecosystem
05:43:15 <AndreasK> I learned over time to avoid keeping names short just for convenience, i've also forgotten it a few times and it always caught up to me later :D
05:43:23 <jchia_> I've added result1 & result2 to http://lpaste.net/348988. Which is easier read?
05:43:27 <buttbutter> Oh. I like '.
05:43:39 <buttbutter> AndreasK: But if your names are too long, your lines become too long :C
05:44:23 <maerwald> use linebreak
05:44:32 <maerwald> it's a secret weapon
05:44:48 <kuribas> liste: toValue2 looks cleaner to me.  That could be because toValue1 is better layedout.
05:44:53 <AndreasK> You have to use really long names for that to become an issue
05:46:48 <codedmart> Is there any libs out there already that can take HTML and just return the relevant text from it minus all the tags, etc?
05:47:05 <AndreasK> If my lines get too I see that as a hint that I should split a expression into multiple parts
05:47:17 <nikita2206> Hey, what if I need to parse program args/options into a record of type `data Args = Args { unicorn :: Maybe String }` where you could call a program with `prog` or `prog --unicorn foo` and the first call would leave `unicorn` with the value of `Nothing`, but the second one would fill it with `Just "foo"`
05:47:26 <nikita2206> I was trying to use CmdArgs library for parsing
05:47:46 <nikita2206> But I can't understand how do I fmap incoming argument with `Just` constructor
05:47:55 <lpaste> kuribas annotated “Which is better?” with “Which is better? (annotation)” at http://lpaste.net/348988#a348994
05:51:32 <kuribas> nikita2206: fmap f (unicorn args)?
05:52:30 <ggVGc> codedmart: s/<.*>//g
05:52:31 <ggVGc> !
05:53:11 <codedmart> ggVGc: It can't be that east can it?
05:54:30 <byorgey> codedmart: I suggest looking at the 'tagsoup' package
05:55:03 <byorgey> it can parse the HTML to a list of tags, and you can just filter for ones that consist of text
05:55:21 <codedmart> byorgey: OK I will take a look thanks!
05:55:24 <nikita2206> kuribas: fmap was just my guess, because it seems natural to fmap it if there was a value, but I have no idea... This CmdArgs library is pretty magical, in order to parse `data Args = Args { unicorn :: String }` I'd need to do: `parse = Args { unicorn = def &= opt "There was no argument" }` - this way it will set default value if `unicorn` option was not present, but what if I need `Nothing` instead of default string
05:56:16 <byorgey> nikita2206: it just magically handles Maybe String with the behavior you want
05:56:26 <byorgey> I don't think you need to do anything special.
05:56:52 <jchia_> kuribas: In your annotated version, which do you prefer?
05:57:07 <byorgey> just  data Args = Args { unicorn :: Maybe String }   parse = Args { unicorn = def }  should work
05:57:10 <a3gis> Hi! What is the most elegant way to represent an abstract syntax tree in Haskell? It is one of those things that are very natural in OOP with inheritance (easy to have a hierarchy of nodes, have functions that operate only on certain types of nodes, etc) but it is not at all obvious to me how to achieve something similar in Haskell
05:57:26 <byorgey> a3gis: you just use an algebraic data type
05:57:35 <nikita2206> byorgey: wow, I didn't even try it, thank you
05:57:53 <a3gis> byorgey: can you give me an example? I tried that of course, but it didn't work out
05:58:50 <a3gis> byorgey: it works for a "flat" ast structure where every node has a the same, type, but not for "node hierarchies" such as "those nodes are Expressions, those are Statements, etc" and functions which operate only on those subcategories
05:59:23 <kuribas> jchiathe second
05:59:23 <byorgey> a3gis: sure, in that case you just use multiple algebraic data types, one for each type of node
05:59:28 <a3gis> byorgey: you can create more and more ADTs wrapping those, but it becomes very much non-elegant and a pain to work with
05:59:34 <kuribas> jchia: the second
05:59:49 <jchia_> OK
06:00:11 <kuribas> jchia: it has the "order" right
06:00:25 <a3gis> byorgey: in that case, how would you go about decorating the AST later on with information such that the position of a node in the source file?
06:00:43 <AndreasK> a3gis: You could use GADTs: https://en.wikibooks.org/wiki/Haskell/GADT
06:01:12 <byorgey> a3gis: yes, I agree that part is tricky.  You may be interested to read this: http://blog.ezyang.com/2013/05/the-ast-typing-problem/
06:01:12 <jchia_> kuribas: What does it mean by having the "order" right? Having a f . g . h $ x pattern?
06:01:28 <kuribas> jchia: the order of the lenses
06:01:29 <jchia_> right to left instead of left to right?
06:01:48 <kuribas> jchia_: toValue1 mixes both
06:01:51 <jchia_> kuribas: Do you mean toValue, result or both?
06:01:51 <a3gis> byorgey: ah, thanks!
06:02:03 <byorgey> a3gis: and also the Lambda The Ultimate post linked from there
06:02:15 <kuribas> jchia_: toValue1
06:03:33 <jchia_> kuribas: What does it mean by "order of the lenses"? toValue1 & toValue2 do the same thing. Do you mean each of the lines with '&' involving lens can be written another way using another 'order'?
06:04:00 <kuribas> jchia_: I mean the order of reading them.
06:05:38 <jchia_> kuribas: I read toValue1 top-to-bottom, left to right. x gets 'transformed' one step at a time (top-to-bottom) with (&). traverse 'moves' from outside to inside (left-to-right).
06:06:11 <jchia_> I just started using lens two days ago, so I would like to know how others read them.
06:14:00 <lyxia> You can think of the lens type as data Lens s t a b = Lens (s -> a) (s -> b -> t)
06:14:18 <lyxia> Just a way to access and modify data.
06:14:25 <kuribas> jchia: is that well typed?
06:15:18 <lyxia> data Lens' s a = Lens' (s -> a) (s -> a -> s)   -- get an "a" out of an "s" + set an "a" producing a new "s".
06:16:10 <kuribas> ah (.) has stronger precedence than (%~)
06:16:18 * kuribas doesn't use (%~)
06:17:25 <kuribas> jchia: you could use _1 instead of  %~ fst
06:29:46 <ertesx> doing too much church encoding makes your brain hurt
06:33:01 <cocreature> friends don’t make friends church encode their data types
06:39:01 <quchen> Boehm-Berarducci is what friends do!
06:49:09 * hackagebot serokell-util 0.1.2.2 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.2.2 (gromak)
06:53:52 <jchia_> kuribas: Do you mean replacing "(traverse . _2 . traverse %~ fst)" with "(traverse . _2 . traverse _1)"? That changes the type.
06:54:15 <kuribas> jchia: combine it with the following lenses
06:54:24 <jchia_> lyxia: I get that part about Lens itself. But then there are other things like Iso, Prisms, etc.
06:55:18 <jchia_> kuribas, in the lpaste specifically what does that look like?
06:57:16 <lpaste> kuribas annotated “Which is better?” with “Which is better? (annotation) (annotation)” at http://lpaste.net/348988#a349016
07:00:06 <jchia_> kuribas: That didn't compile.
07:00:50 <jchia_> Also, does that change the meaning? Originally, the two traverse lines were doing their own thing on different levels. Now they are combined into one thing, traversing even deeper.
07:02:38 <jchia_> kuribas: type GroupedRc = [(Char, [(Text, [String])])]
07:08:58 <lpaste> kuribas annotated “Which is better?” with “Which is better? (annotation) (annotation) (annotation)” at http://lpaste.net/348988#a349019
07:09:35 <kuribas> jchia: and this?
07:11:03 <lpaste> kuribas revised “Which is better? (annotation) (annotation) (annotation)”: “Which is better? (annotation) (annotation) (annotation)” at http://lpaste.net/349019
07:12:06 <lyxia> that's a lot of annotations
07:12:35 <kuribas> lyxia: it's hard without proper types
07:14:14 <kuribas> jchia: anyway, you get the idea
07:14:58 <glguy> kuribas: what's the non lens choice?
07:15:42 <kuribas> glguy: you mean map, map, etc...?
07:16:09 <glguy> or list comprehension etc
07:17:04 <jchia_> kuribas:
07:17:04 <jchia_> type AccountGroup = Char
07:17:04 <jchia_> newtype Sym = Sym ByteString
07:17:05 <jchia_> data RcSym = RcSym { ... }
07:17:05 <jchia_> type GroupedRc = [(AccountGroup, [(Sym, RcSym)])]
07:20:44 <jchia_> The non-lens version looks like this:
07:20:45 <jchia_> toValue = object . map ((.=) <$> pack . (:[]) . fst <*> toJSON . map fst . snd)
07:21:42 <jchia_> The "pack . (:[])" can probably be simplified to "singleton", so "toValue = object . map ((.=) <$> (singleton :: Char -> Text). fst <*> toJSON . map fst . snd)".
07:21:49 <jchia_> But I find it quite cryptic.
07:24:25 <jchia_> So instead of building the Aeson Value manually, I now convert the list into a Map with the appropriately-transformed content and then give it to toJson.
07:27:50 <jgt> hey folks, given the string "abc123", how do I extract only numeric chars? I don't know the string length, so I can't do anything like `drop 3 "abc123"`.
07:28:00 <jgt> do I write a parser? Use a regex?
07:28:16 <_newb> you can use regex with
07:28:19 <_newb> regex_match
07:28:28 <lyxia> > filter isDigit "abc123"
07:28:32 <lambdabot>  "123"
07:28:48 <jgt> lyxia: Oh, of course. I should have thought of that. Thanks!
07:29:00 <glguy> toValue2 xs = toJSON $ M.fromList [ (singleton x, map fst y) | (x,y) <- xs ]
07:29:05 <lyxia> > takeWhile isDigit . dropWhile (not . isDigit) $ "abc123abc456"
07:29:08 <lambdabot>  "123"
07:29:10 * hackagebot intero 0.1.20 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.20 (ChrisDone)
07:30:18 <glguy> kuribas: I think that one is the way to go
07:34:43 <glguy> jchia_: the code I posted might be for you, too. I'm not clear whose question this is :)
07:40:38 <jchia_> glguy: I like your version. It's clearer and shorter than my lens and non-lens versions.
07:40:52 <jchia_> It was my question.
08:00:07 <mmaruseacph2>  /win 12
08:00:13 <mmaruseacph2> damn, bad window, sorry
08:05:11 <kuribas> glguy: that's a lot clearer.
08:07:42 <kuribas> or with lenses: toValue2 = toJSON . M.fromList . map (over (_1) singleton . over (_2) fst)
08:31:56 <ania123> Write a function that generates the innite list of negative integers.
08:32:02 <ania123> can one tell me how to write it?
08:34:03 <ania123> Write a function that generates the innite list of negative integers.
08:34:05 <ania123> can one tell me how to write it?
08:34:18 <Fuuzetsu> ania123: We have seen your question the first time, please wait for replies. Is that homework?
08:35:12 <pikajude> Is it possible to write this? http://lpaste.net/5228789633935998976
08:35:21 <pikajude> Or does the first argument to _async need to be IO a rather than m a?
08:35:56 <mmachenry> ania123: I don't understand why you would write a function for this. There are not arguments. The infinite list of negative integers is a constant. In Haskell, being a lazy language, there's no need for this to be a function. What would the argument(s) be?
08:36:15 <pikajude> I can make it typecheck when the first argument *is* IO a, but when I actually use this effect in code, I'm supposed to be not using IO at all
08:36:25 <pikajude> because that's the whole point of having a record of effects to pass around :(
08:37:00 <ania123> mmachenry: without argument just to generate it
08:37:26 <EvanR> answer :: [Integer]
08:37:32 <EvanR> not answer :: () -> [Integer]
08:38:32 <EvanR> pikajude: you need to put a type signature on mapConcurrently
08:38:39 <ania123> foo=o:map(+1*(-1)) foo
08:38:47 <ania123> I did in this way
08:38:48 <pikajude> EvanR: I can do that, but it still won't typecheck
08:38:54 <ania123> is there any other way to do it?
08:38:55 <EvanR> well, whats the error in that case?
08:39:04 <EvanR> you definitely need a type sig because of rankNTypes
08:40:08 <pikajude> ok, I updated the paste
08:40:21 <pikajude> there's an annotation below with the type signature I want
08:40:32 <Fuuzetsu> ania123: [-1, -2, ..]
08:40:43 <pikajude> the problem is, I'm not sure it's possible to produce an Async from a Free effects a
08:40:44 <EvanR> pikajude: thats better, its a different error
08:40:51 <kuribas> > fix (((-1):).map (subtract 1))
08:40:53 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
08:41:06 <pikajude> since the effects aren't necessarily going to include IO, but Async does need IO
08:41:14 <Fuuzetsu> kuribas: iterate (subtract 1) (-1)
08:41:16 <pikajude> I'd rather write an effect that can do concurrent execution, but I'm pretty sure that's not actually possible at all
08:41:30 <pikajude> because it'd have to take an m a as an argument and that's a no-no for writing effects
08:41:35 <EvanR> you will need IO at some point
08:41:45 <kuribas> Fuuzetsu: yeah :)
08:42:07 <pikajude> EvanR: ideally, if I'm using the testsuite Effects which don't use IO at all, I'd just make it do execution in serial
08:42:44 <EvanR> well youll need IO in order to handle Async
08:43:01 <pikajude> yeah :(
08:43:17 <pikajude> is there any other way to write a concurrency effect?
08:43:19 <EvanR> so writing it in terms of Async is restricting you to IO
08:43:25 <pikajude> yeah
08:44:25 <EvanR> youd need to make that part abstract
08:44:27 <pikajude> so is there a way to write a concurrency effect without Async?
08:45:36 <EvanR> you can make an API for async-like actions and accept different implementations
08:45:48 <pikajude> can you give me an example?
08:45:50 <EvanR> one with Async, one for testing
08:46:05 <pikajude> that's what i tried to do originally, but couldn't figure out a way to write it such that i was never taking an `m a` as an argument
08:46:24 <EvanR> you would take m a as an argument
08:46:34 <EvanR> but the result type would need to depend on m
08:46:39 <EvanR> so a functional dependency or type family
08:46:48 <pikajude> but you can't take m a as an argument in an effect
08:47:02 <EvanR> m a -> MyAsyncType m a
08:47:18 <pikajude> that's pretty much what lifted-async already does
08:47:27 <EvanR> are you using a standard definition of "effect" that means anything? or are we just talking haskell
08:47:33 <pikajude> the one that free-vl is using
08:47:43 <pikajude> see http://hackage.haskell.org/package/free-vl-0.1.4/docs/Control-Monad-Free-VanLaarhovenE.html
08:47:45 <EvanR> why cant you pass m a as an argument in effect
08:48:00 <pikajude> let me go and figure out why again
08:48:06 <pikajude> i don't remember the error
08:48:35 <EvanR> errors... how about types
08:48:55 <pikajude> yeah, sec
08:49:55 <b0llu> for a Foldable, how do I find the greatest index?
08:50:03 <b0llu> I can't think of a neat way of "indexing" a foldable
08:50:12 <pikajude> EvanR: ok, so you see the annotation in my paste, right? where it's trying to match `m` with `Free effects`?
08:50:13 <b0llu> when it is clearly possible, since you can write toList
08:50:26 <b0llu> one thing that I could to is to group from Foldable -> List -> usual process
08:50:38 <b0llu> "greatest index" = "index of greatest element*"
08:50:40 <pikajude> if I tried to define AsyncEff such that _async took Free effects a as an argument, I'd need to ensure that AsyncEff itself was an element of those effects
08:50:42 <b0llu> but idk if that's fast / smart
08:50:45 <EvanR> pikajude: it seems like a genuine type error, like we dont understand how to use the library
08:50:49 <glguy> b0llu: How about "length"?
08:50:49 <irpp> hi, is there a way a .hs file (or even a 'top level' line) could start with an uppercase char?
08:51:06 <b0llu> glguy: no, I want the _index_ of the _greatest element_ :) sorry for not being explicit
08:51:15 <pikajude> and to ensure that AsyncEff is an element of those effects, since AsyncEff is parameterized by that list of effects, it becomes recursive
08:51:16 <b0llu> glguy: and there is obviously a notion of an "index" for a foldable
08:51:29 <pikajude> and you can't construct an infinitely recursive type like that
08:51:35 <b0llu> glguy: but I want to know if converting the foldable to a list and then running the greatest integer thing is smart or not
08:51:36 <pikajude> i'll annotate the paste again with what i'm talking about
08:51:51 <ggVGc> b0llu: I'm not sure I agree there's obviously an index for a foldable
08:51:51 <EvanR> that that makes no sense, makes sense
08:51:59 <ggVGc> there are obvsious indexes in a list
08:52:06 <ggVGc> but a list is no longer the original foldable
08:52:13 <pikajude> EvanR: ?
08:52:16 <geekosaur> irpp: Nothing <!*!> Just a = ... -- or similar
08:52:22 <b0llu> ggVGc: foldable is isomorphic to toList
08:52:30 <geekosaur> binding for an infix
08:52:37 <EvanR> b0llu: hmm... dunno
08:52:43 <b0llu> ggVGc: and I want this to work on "indexable" things - vectors, lists, etc. Perhaps there is a better typeclass or something?
08:52:57 <ggVGc> I didn't know foldable was isomorphic to toList
08:53:00 <glguy> irpp: What're you trying to do? Are you actually just curious about capital letters in the first column?
08:53:06 <b0llu> ggVGc: toList = foldr (:) [] f
08:53:10 <geekosaur> assuming use of only stuff in Prelude, and that it is the definition of module Main aka a program
08:53:11 <glguy> geekosaur: Oh, or: Just x = Just 10
08:53:18 <nshepperd> it's not actually isomorphic to toList, due to infinite snoc lists
08:53:19 <b0llu> ggVGc: 
08:53:25 <nshepperd> and infinite trees
08:53:35 <b0llu> nshepperd: oh, hm, okay. but, like, pathologies excluded :)
08:53:52 <ggVGc> b0llu: in that case, I'm not sure I understand the problem
08:54:06 <b0llu> ggVGc: is converting to a list the smartest / fastest way?
08:54:13 <c_wraith> b0llu, it is isomorphic to foldMap even in cases involving infinite structures. 
08:54:15 <b0llu> ggVGc: or is there a cuter way?
08:54:17 <ggVGc> if they are isomorphic, I guess so?
08:54:31 <b0llu> ggVGc: I meant, performance wise
08:54:33 <ggVGc> I guess that depends on your foldable
08:54:39 <b0llu> hm
08:54:44 <ggVGc> if your foldable is a vector, then obviously it's faster to just index it
08:54:54 <ggVGc> if it's a tree, you'll have to make a list I guess
08:54:55 <b0llu> ggVGc: yeah, I suppose
08:55:13 <b0llu> dang, I wish the tradeoff between performance and generality didn't exist in this case
08:55:27 <b0llu> so, what is your recommendation?
08:55:44 <b0llu> Vyn: wb
08:55:52 <Vyn> Ty
08:56:02 <nshepperd> b0llu: if you wanted a Monoid that would do this, it would be something like data ArgMax a = { indexOfMax :: Int, length :: Int, maxItem :: a }
08:56:04 <ggVGc> I'm not sure what you're trying to come up with. You want a generic "index" function for foldable? The only one that makes sense is toList and then indexing that
08:56:07 <ggVGc> imo
08:56:09 <nshepperd> then you could use foldMap
08:56:26 <b0llu> nshepperd: for my entire process?
08:56:32 <nshepperd> yes
08:56:37 <b0llu> nshepperd: oh, that is cute :) but what is the mempty?
08:56:51 <ggVGc> if there was a generic notion of indexing for foldable, I think it would have been part of the type class
08:56:54 <b0llu> nshepperd: should it not be Maybe a?
08:56:55 <irpp> geekosaur: glguy thanks..mainly couriosity...and is there a way without an data constructor already in scope?
08:57:08 <nshepperd> b0llu: ah yeah
08:57:45 <nshepperd> or like 'data ArgMax a = Empty | Full { ... }'
08:57:53 <b0llu> nshepperd: oh right, that too
08:58:14 <geekosaur> irpp, data definitions are order agnostic as long as you're not using them in Template Haskell, so the data declaration could come later
08:58:52 <pikajude> EvanR: sorry, this got confusing real quick
08:59:06 <pikajude> but basically, you *can* define it such that _async would take a Free effects a as an argument, but you can never actually run it
08:59:22 <pikajude> because an implementation must be provided with some async :: Free effects a -> IO (Async a)
08:59:32 <pikajude> and to actually run that Free effects a, you would need to use that function, again
08:59:54 <b0llu> pikajude: what library are you trying to use?
08:59:59 <pikajude> free-vl
09:00:09 <b0llu> also, soft question: why does STG use weak head normal form?
09:00:13 <pikajude> i'll do an easier example using catchError which is where I originally figured this out
09:00:17 <b0llu> like, what makes weak head normal form attractive?
09:00:46 <geekosaur> non-strict evaluation
09:00:50 <EvanR> as opposed to what?
09:01:05 <geekosaur> you're evaluating the minimum necessary
09:01:08 <b0llu> EvanR: exactly, I don't know anything about normal forms :) why normalise at all?
09:01:16 <EvanR> normal form = eager evaluation
09:01:18 <geekosaur> normalisation == evaluation
09:01:30 <EvanR> so you wouldnt be haskell anymore
09:01:42 <nshepperd> weak head normal form is what you need to pattern match on the outermost constructor
09:01:51 <nshepperd> that's practically the definition I think
09:01:58 <b0llu> geekosaur: I had the impression that "normalisation" is finding the fixed point of a set of rules on a grammar? (something like that?)
09:01:59 <b0llu> I see
09:02:14 <b0llu> nshepperd: no, the definition AFAIK is something like "evaluate till the first constructor or lambda"
09:02:20 <irpp> geekosaur: thank you very much!
09:02:28 <nshepperd> close enough for government work
09:02:29 <geekosaur> "normalisation" is slightly overloaded, insofar as it can be used to describe the process or used to describe a particular form that process takes
09:02:36 <geekosaur> (normal form vs. weak head normal form)
09:03:14 <b0llu> geekosaur: where do I read properly about WHNF, etc?
09:03:21 <EvanR> the normal form of an infinite structure, would be infinite, bad
09:03:34 <b0llu> EvanR: which one?
09:03:40 <EvanR> [1..] ?
09:03:52 <b0llu> EvanR: no, like, according to which normal form?
09:03:56 <EvanR> normal form
09:04:02 <EvanR> as in NFData
09:04:06 <b0llu> EvanR: as I understand, WHNF will simply do 1 : _ : _ ...
09:04:10 <nshepperd> rnf [1..] = ⊥
09:04:12 <b0llu> EvanR: is that a GHC thing?
09:04:28 <b0llu> EvanR: "NFData"
09:04:36 <EvanR> deepseq evaluates everything in a structure to normal form, which might not terminate
09:05:34 <b0llu> hm
09:05:50 <b0llu> EvanR: seq evals it to WHNF right?
09:05:51 <nshepperd> heh. 'normal form' is when the thing is fully evaluated and no more rules apply. it's not a category of which 'weak head normal form' is a member
09:05:55 <EvanR> yes
09:05:57 <nshepperd> a white horse is not a horse
09:06:23 <EvanR> i just noticed that, weak head normal form isnt a kind of normal form h
09:06:29 <b0llu> hm
09:06:31 <geekosaur> b0llu, this is usually covered wth respect to lambda calculus
09:06:40 <b0llu> geekosaur: weak head normal form as well?
09:06:52 <geekosaur> http://www.cs.cornell.edu/courses/cs6110/2014sp/handouts/sestoft.pdf
09:06:53 <b0llu> geekosaur: I understand the normal form from simply typed lambda calculus
09:06:58 <EvanR> we need better names ;)
09:07:00 <b0llu> geekosaur: but that's about it
09:07:40 * ski . o O (: Sestoft :)
09:07:49 <b0llu> ah, I see. I thought WHNF was some haskell thing, not lambda calculus thing
09:07:50 <geekosaur> there are multiple lambda calculi
09:07:50 <ggVGc> EvanR: like Monad?
09:08:21 <nshepperd> at least Monad is specific
09:08:25 <b0llu> geekosaur: ah, right. right :)
09:08:30 <nshepperd> far too many things in math are called 'normal'
09:08:44 <b0llu> nshepperd: vector, group, what else?
09:08:55 <b0llu> subgroup*
09:09:10 <nshepperd> normal distribution!
09:09:23 <ggVGc> nshepperd: yeah but also it doesn't matter what things are called, since every math paragraph starts with "Let's define x,y,z to be whatever I want"
09:09:25 <geekosaur> geometry
09:09:26 <b0llu> oh right xD
09:09:31 <implementation> "standard normal distribution" is even better xD
09:09:44 <b0llu> nshepperd: though a lot of people go with "gaussian" for that purpose, right?
09:10:21 <geekosaur> ...except "gaussian" can be pretty overloaded too >.>
09:10:48 <EvanR> "normal distribution" is recognizable and distinct from isolate out of context "normal"
09:11:16 <EvanR> but WHNF and normal form might be testing peoples patience
09:12:06 <nshepperd> WHNF is a 'weakening' of normal form
09:13:27 <EvanR> b0llu: listing everything called normal is not going to happen here
09:14:07 <EvanR> the sucky part is none of them are really related, unlike "linear"
09:15:58 <EvanR> hmmmm i wonder if theres a theory of labels where you can assign the same label to a variety of different and incompatible, incomparable things
09:16:25 <EvanR> and prove some kind of "is nonsense" about it all 
09:16:37 <cloudhead> after optimizations, is plain list traversal slower than vector traversal?
09:17:41 * geekosaur wouldn't be surprised if some people call that "category theory" :p
09:18:36 <EvanR> lol
09:19:36 <pikajude> EvanR: this is what i'm talking about http://lpaste.net/2993481833242427392
09:19:54 <recursion-ninja> I defined a Show instance constrained by some Lens HasFoo s a, HasBar s b typeclasses. Now the compiler says that every type is a mtching instance of this show definition, which is causeing overlapping definitions. I don't understand why this is. Could anyone enlighten me?
09:20:23 <c_wraith> cloudhead, depends. their best cases are equally fast. both can get quite a bit slower in their less-optimal cases. 
09:20:46 * ski . o O ( <https://en.wikipedia.org/wiki/Family_resemblance> )
09:21:05 <cloudhead> c_wraith: thanks, that all I need to know at this stage
09:21:15 <byorgey> recursion-ninja: the compiler decides which instance to use by looking *only* at the right-hand side of the =>
09:21:22 <ski> recursion-ninja : instance resolution only takes the instance head into consideration, not the constraints
09:21:43 <byorgey> so something like    instance  (Foo a, Bar a) => MyClass a  where...   actually matches *any* type
09:22:04 <byorgey> it means 'any type is an instance of MyClass, and also it had better be the case that the type has instances of Foo and Bar as well'
09:22:21 <byorgey> it does *not* mean 'types which are instances of Foo and Bar are also instances of MyClass'
09:22:27 <ski> recursion-ninja : which instance should be used, if you have multiple such instances, with compatible constraints ? or contrariwise, how to check two sets of constraints are incompatible (/ disjoint) ?
09:23:03 <recursion-ninja> @ski What? How is that useful? I can't say: "Anything that HasFoo and HasBar is an instance of show using this supplied definition, but you have to make sure that it HasFoo and HasBar for me"?
09:23:03 <lambdabot> Maybe you meant: wiki src ask
09:23:12 <ski> to consider the constraints when selecting the instance, it would have to use something like backtracking .. and it still wouldn't solve the aforementioned problem
09:24:02 <byorgey> recursion-ninja: it's not a question of it being useful or not.  as ski explains, implementing the alternative would be impossible or at least very difficult.
09:24:20 <byorgey> especially since type class instances have to be unique.
09:24:35 <ski> recursion-ninja : what if someone else provides an instance employing constraints `HasFoo' and `HasBaz', and there happens to be some type which satisfies both sets of constraints ? the implementation doesn't know that the two instances are equivalent on this overlap (if it indeed is), so it must pick and choose. which should it pick ?
09:25:26 <recursion-ninja> ski: So the following isn't very useful: "(HasFoo s a, HasBar s b) => Show s where ..." because the compiler doesn't actually constrain type 's' based on the HasX instances?
09:26:13 <ski> ("it still wouldn't solve the aforementioned problem" -- it wouldn't solve it completely. if we assume close world (which is not the case), then after backtracking, it could happen that only one alternative remains, and we could then pick that. but it could just as well be that more than one alternative remains)
09:26:22 <ski> recursion-ninja : correct
09:26:26 <Jello_Raptor> does having an RWST over an IO monad force strictness for the RWST state? I want to tie the knot in a way that one pass through the monad collects information on actions the monad performs (not causally linked to anything that the IO returns, that's just used for getting handles from an external program) 
09:26:49 <b0llu> sorry, got Dcd
09:26:54 <b0llu> okay, so, about WHNF?
09:27:45 <recursion-ninja> ski: I understand how overlapping constrains are a problem. I have a type Gamma which is niether and instanc of HAsFoo nor HasBar, but the compiler is telling me that there are overlapping SHow instances for Gamma. Gamma a matching instance for (HasFoo s a, HasBar s b) => Show s, and Gamma's normal show instance. I guess I was expecting the lhs constraints of the => to do more work than the 
09:27:52 <recursion-ninja> compiler is capable of?
09:29:25 <geekosaur> if i compile a third module that imports yours and also overlaps, which instance does it choose?
09:29:29 <ski> recursion-ninja : the `OverlappingInstances' extension is generally frowned upon
09:29:40 <glguy> (HasFoo s a, HasBar s b) => Show s   means that all types for the form "s" are Showable, also all of these types will require HasFoo and HasBar constraints
09:30:07 <geekosaur> in your particular case, there is a somewhat clear resolution. if you add in more instances, there might not be, and in the general case there isn't one
09:30:34 <geekosaur> but he compiler while compiling your definition can't know I will write a new instance a year afterward
09:30:50 <recursion-ninja> ski: I haven't invoked that extension yet. I was hoping not to. Would a more advisable aproach be to manually create a Show instance for each concrete which is an instance of HasFoo & HasBar rather that try and have the compiler automatically resolve it for me?
09:31:57 <recursion-ninja> glguy: That's not how I would have read those constraints *intuitively* but after ski's explanation, I think I understand why that is the case.
09:32:09 <b0llu> geekosaur, EvanR: you were teling me abut WHNF
09:32:24 <b0llu> so, from what I understand, you evaluate "just enough" to branch>
09:32:26 <b0llu> ?
09:32:50 <ski> recursion-ninja : *nod*, just noting that it *might* solve the particular problem with `Gamma' in your case, but that we tend to recommend against using it
09:33:17 <b0llu> so in that case, how would something like traverse_ print [1..10] get evaluated?
09:33:26 <b0llu> geekosaur, EvanR, nshepperd ^
09:33:35 <b0llu> I don't understand the execution model
09:33:35 <geekosaur> don't confuse evaluation with execution
09:33:42 <b0llu> geekosaur: oh?
09:34:18 <geekosaur> conceptually, you produce a chain :: IO a and main "returns" that to the runtime, which executes it. you don't have control over the execution
09:34:31 <ski> recursion-ninja : you could write a `defaultHasFooBarShowsPrec :: (HasFoo s a,HasBar s b) => Int -> s -> ShowS', and then for each particular case of a type, say `Blah', you can write `instance Show Blah where showsPrec = defaultHasFooBarShowsPrec', or something like that
09:35:22 <b0llu> geekosaur: so in that case, what exactly is "evaluation"?
09:35:23 <geekosaur> the evaluation phase just reduces it to lower level "opcodes" for the runtime, which the runtime has to process. and you can think of (>>=) and `fmap` as attaching callbacks to an IO opcode
09:35:31 <recursion-ninja> ski: Thanks, I'll just write 3-5 Show instances manually for those concrete types and factor out the logic that was in my general (unconstrained) Show instance. That way Gamma keep's it's original Show instance and the other types get the appropriate Show instances also, and no one used OverlappingInstances!
09:35:58 <geekosaur> (or continuations, if you prefer)
09:36:00 <recursion-ninja> ski: I think we just suggested the same things ;)
09:36:01 <b0llu> geekosaur: so, evaluation = convert to opcode, execution = execute the opcode?
09:36:02 <ski> (it (usually) being preferred to define `showsPrec', rather than `shows' (or even `show'), when making an instance of `Show'. `showsPrec' takes care of inserting appropriate pairs of brackets, when needed)
09:36:24 <b0llu> geekosaur: or, like, evaluation = convert to your model of machine (STG in haskell case) and execution = execute the machine with said program?
09:37:03 <geekosaur> and this odd separation is how we can do I/O in a pure language: the pure language doesn't do I/O, it does pure operations (evaluations/reductions) on runtime opcodes and delivers the result to the runtime, which is impure
09:37:19 <ski> recursion-ninja : btw, since you're talking about manually writing an instance of `Show', i should node that generally we like (a) the string generated by `Show' to be a valid *Haskell* expression that evaluates (in an appropriate context of modules) to the given value; and (b) in case there's a `Read' instance, it should be able to read back the `Show' result into the original value
09:38:10 <b0llu> geekosaur: how "correct" way my analogy? probably not
09:38:21 <b0llu> geekosaur: can you take a simple example and show me the difference?
09:38:33 <ski> recursion-ninja : the most common is to output the data constructors (the representation), but if you want to hide that (for an abstract data type, say), you can generate a string representing code which would call exported module operations to reconstruct the value
09:39:19 <geekosaur> but much like I can use something like the Atom package to generate a program for a realtime system that has neither purity nor even something like memory segmentation/protection and the code generation in Haskell provides assurances of correctness, we can provide assurances of correctness about the runtime opcode sequence we feed to the unconstrained runtime
09:39:32 <ski> recursion-ninja : for writing `showsPrec', it usually helps to use itself, `shows',`showParen',`showChar',`showString'. for `readsPrec' (in `Read'), itself, `reads',`readParen',`lex'
09:40:35 <b0llu> nshepperd: to use foldMap for my problem, I would still need to convert to a list, right?
09:40:41 <recursion-ninja> ski: Thanks for the tutilage! I'll import Text.Show and construct a nice showsPrec definition :)
09:41:25 <b0llu> geekosaur: can you show me a minimal example which shows the difference between evaluation and execution?
09:41:29 <b0llu> geekosaur: something I can refer back to
09:41:33 <geekosaur> b0llu, not really. STG supports the non-strict reduction model by encoding a graph whose nodes can be reduced to WHNF, instead of encoding procedural operations.
09:41:52 <geekosaur> hm, those signals might be crossed, the "not really" was not in response to "show you..."
09:42:16 <b0llu> geekosaur: :)
09:42:20 <geekosaur> b0llu, the usual simple example is to replace IO with: data IO a = GetChar | ...
09:42:30 <b0llu> geekosaur: ?
09:42:36 <geekosaur> but, if you've been working with free monads, that's another example
09:42:40 <ski> recursion-ninja : if you want to show us the datatype definition, i could show the typical way to write the `Show' instance which otherwise would be derived (but sometimes that deriving machinery doesn't work, e.g. for GADTs)
09:43:01 <geekosaur> Haskell's IO can be thought of as a free monad that the runtime interprets
09:43:08 <b0llu> geekosaur: oh, hm
09:43:25 <recursion-ninja> ski: Nah, I'd rather struggle a little bit and figure it out on my own. I'll learn it better that way.
09:43:27 <b0llu> geekosaur: where is the "evaluation" in a free monad
09:43:31 <geekosaur> (which is really the same as the simpler example, if you think about it)
09:43:40 <b0llu> geekosaur: it is free since it simply "adds layers", right?
09:43:47 <ski> > listArray (0,9) [i^2 | i <- range (0,9)]  -- example of a `Show' instance that doesn't simply show the representation, instead constructing an expression that refer to the exported abstract data type operations
09:43:49 <lambdabot>  array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
09:43:58 <ski> recursion-ninja : *nod*
09:44:05 <geekosaur> in a free monad, you supply an interpreter. that interpreter could actually "run" it, or could run it in a mocking framework, or could transform it to produce something else
09:44:20 <geekosaur> a free monad just represents the monadic actions as data
09:44:25 <b0llu> geekosaur: yes
09:44:36 <b0llu> geekosaur: so, the "interpreter" is the evaluation, right?
09:44:45 <b0llu> geekosaur: the free monad itself does not have evaluation?
09:44:57 <b0llu> geekosaur: but, like, where is "execution"?
09:45:12 <geekosaur> when doing free monad stuff in Haskell itself, you never "execute" in the machine sense, but you are "executing" within the context of the free monad
09:45:18 <ski> recursion-ninja : anyway, beginners often miss that different `Show' instances are intended to be able to work together, when they attempt to use `Show' for custom pretty-printing (which it's not intended for. if one wants that, one should define a separate function, or class, or perhaps instance of some pretty-printing class)
09:45:19 <geekosaur> there are multiple levels here.
09:45:33 <b0llu> geekosaur: okay can you expand on that?
09:45:40 <ski> recursion-ninja : .. and ditto for `Read', mutatis mutandis
09:45:40 <orion> If you try to evaluate "GetChar" in some IO Free Monad, you'll eventually get stuck waiting for user input.
09:46:38 <geekosaur> b0llu, I'm not sure how, if you're becoming confused about levels now. I suggested the free monad to give an example at a purely Haskell level; the idea is you recognize the free monad's interpreter as "execution" with respect to the free monad.
09:46:50 <b0llu> geekosaur: oh, right, that way
09:46:57 <b0llu> geekosaur: okay, that makes sense
09:47:09 <b0llu> geekosaur: so in this example, if that is the "execution", what is the "evaluation"?
09:47:16 <recursion-ninja> ski: Yeah i've noticed it's next to impossible to nest custom pretty printed show instances into larger Show definitions.
09:47:18 <geekosaur> Haskell's runtime is "execution" on the hardware with respect to the Haskell program. A free monad interpreter is "execution" on the Haskell evaluation graph with respect to the free monad 
09:47:38 <geekosaur> which in turn gets executed, after reduction, on the hardware
09:48:19 <b0llu> geekosaur: okay. but.. well, where is "evaluation" in this case?
09:48:26 <geekosaur> (but even there, there are added levels: pretty much all current CPUs turn the programmer visible machine language into microcode before executing that)
09:48:31 <b0llu> geekosaur: I want an example that has both, but I can identify both
09:49:36 <geekosaur> evaluation in the context of a free monad is transforming it.
09:49:53 <geekosaur> at the Haskell level, consider that getChar :: IO Char is not a fundamental operation
09:51:17 <geekosaur> it is successively evaluated/reduced to hGetChar stdin, then to hGetBuf on the stdin Handle's buffer (assuming buffered input), then ultimately to a primop that takes a file descriptor, a buffer, and a length
09:52:04 <geekosaur> (which the execution phase handles by invoking the "read" system call, after blocking in the runtime's event loop until fd 0 is marked "has data")
09:52:07 <b0llu> hm
09:52:22 <b0llu> so evaluation = reduction to some sort of "minimal form"?
09:52:27 <geekosaur> yes
09:52:39 <b0llu> I see
09:52:41 <ski> rashmirathi : "it's next to impossible to nest custom pretty printed show instances into larger Show definitions" -- unless you do it correctly (with `showParen', defining `showsPrec', (usually) calling `showsPrec' instead of `shows' on sub-expressions, with the appropriate precedence levels)
09:52:54 <geekosaur> and the minimal form on the IO "free monad" is primops (instructions for the runtime, roughly) that it can execute
09:53:05 <b0llu> is there a "minimal form" for a free monad? I guess not, since the free monad is in itself minimal? 
09:53:07 <b0llu> hmm
09:53:11 <b0llu> where are the primops defined?
09:53:17 <b0llu> geekosaur: do you contribute to GHC?
09:53:40 <ski> er
09:53:57 <geekosaur> the free monad is itself minimal. usual free monad implementations in Haskell work with the minimized form already, but there are some things that transform the free monad before interpreting it --- that's equivalent to Haskell's evaluation
09:54:07 <ski> @tell recursion-ninja "it's next to impossible to nest custom pretty printed show instances into larger Show definitions" -- unless you do it correctly (with `showParen', defining `showsPrec', (usually) calling `showsPrec' instead of `shows' on sub-expressions, with the appropriate precedence levels)
09:54:07 <lambdabot> Consider it noted.
09:54:16 <ski> rashmirathi : sorry, ENICK
09:54:44 <geekosaur> b0llu, not directly although I'm slowly but surely being dragged into it (actually got tagged as a reviewer on a patch yesterday!)
09:54:58 <b0llu> geekosaur: give me an example where you would have things that transform the free monad? I can think of examples, but I can't think of somethinh cute
09:55:25 <orion> geekosaur: Where can I find a list of primops?
09:55:31 <geekosaur> I *have* dug into the runtime several times, usually to determine how some POSIX thing I know from the POSIX end translates to ghc runtime behavior (hi, signals :)
09:55:36 <b0llu> geekosaur: yes, that too
09:55:40 <b0llu> list of primops?
09:56:11 * geekosaur digging for it...
09:56:36 <geekosaur> there's a source file which lists them, but not what they do (they are literally defined there as `let x = x in x`!).
09:56:49 <b0llu> lol
09:57:59 <bollu> geekosaur: sorry, I DCd
09:58:31 <geekosaur> https://git.haskell.org/ghc.git/blob/4986837f8168cacf95c24fecc84d7b36c47f3c11:/compiler/prelude/primops.txt.pp
09:58:44 <geekosaur> that's the actual master list of primops
09:59:01 <bollu> geekosaur: ohh, what, it's C++?
09:59:18 <geekosaur> some of them are expanded in line, others become library calls into https://git.haskell.org/ghc.git/blob/4986837f8168cacf95c24fecc84d7b36c47f3c11:/rts/PrimOps.cmm
09:59:25 <geekosaur> hm?
10:00:01 <bollu> geekosaur: it's C++ code?
10:00:09 <geekosaur> no?
10:00:11 <bollu> geekosaur: what language is that?
10:00:14 <geekosaur> what are you looking at?
10:00:17 <bollu> geekosaur: how are there #includes?
10:00:19 <bollu> https://git.haskell.org/ghc.git/blob/4986837f8168cacf95c24fecc84d7b36c47f3c11:/compiler/prelude/primops.txt.pp
10:00:23 <geekosaur> it uses the C preprocessor
10:00:34 <bollu> oh
10:00:37 <bollu> oh, wow
10:00:42 <geekosaur> Haskell code uses the C preprocessor a lot, too (sadly --- it's a poor fit at best)
10:00:46 <bollu> that's.. cool? I dunno what to say
10:01:15 <geekosaur> but at the moment there's no better way to deal with multiple versions, platform dependencies, etc.
10:01:27 <bollu> hm
10:02:19 <geekosaur> so the #define-s I see in there relate to word size. primops are at too low a level to take e.g. Int
10:02:47 <geekosaur> they have to take unboxed values, which must be fixed size because there's no box to tell it what size it is
10:02:55 <bollu> hm
10:02:56 <bollu> right
10:05:29 <geekosaur> that's actually a current probem, someone's been working on levity polymorphism (things that can take lifted/boxed values or unlifted/unboxed values; the two are slightly different but run into similar problems), and figuring out sizes of unlifted values is necessary for polymorphism to work
10:06:30 <bollu> can I loop on a STVector?
10:06:37 <bollu> if I want to find the largest index of an STVector
10:06:40 <bollu> what is the right way?
10:06:49 <bollu> it doesn't seem to have a foldable instance
10:06:55 <bollu> nor can I pattern match on it
10:06:57 <geekosaur> (boxing vs. lifting: I can tell the compiler to inline/unbox a data value inside another one instead of boxing it, so the constructor tag and either the value pointer or potentially the actual value are directly in the outer `data`. that's unboxed. unlifted means there's also no constructor tag)
10:07:22 <bollu> geekosaur: I don't know what a "constructor tag" is
10:07:59 <geekosaur> you know how (almost) every data definition has to provide constructors? the constructor tag is how those constructors are represented internally
10:08:30 <bollu> I see
10:08:33 <geekosaur> data Maybe a = Nothing | Just a -- in ghc, Nothing is constructor tag 0 and Just is constructor tag 1; the tag is a machine word
10:08:51 <bollu> hm
10:08:53 <bollu> I see
10:09:07 <geekosaur> other compilers/interpreters represent it in other ways, but it has to be present somehow so it knows which "flavor" of Maybe the value is at runtime
10:09:44 <bollu> okay
10:09:48 <bollu> so its like a tagged union in C
10:09:50 <bollu> ?
10:09:54 <geekosaur> yes
10:10:48 <bollu> okay
10:11:21 <bollu> so, "... I can tell the compiler to unbox a data value inside another one" as in?
10:13:16 <geekosaur> -funbox-strict-fields and {-# UNPACK #-} pragma
10:13:56 <bollu> hm, so that uses the machine level repr?
10:14:16 * hackagebot coin 1.2 - Simple account manager  https://hackage.haskell.org/package/coin-1.2 (piotrborek)
10:14:25 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma for details
10:15:05 <ph88> hello
10:15:15 <geekosaur> notably "Any single-constructor data is eligible for unpacking" so it doesnt need to carry a constructor tag around, because it's always 0
10:15:41 <geekosaur> which it needs to know if that field gets passed to something else so it needs to be reboxed
10:16:36 <geekosaur> (and yes, that means it's fiddling with the machine representation)
10:20:33 <AndreasK> bollu: Largest value or index?
10:21:06 <orion> http://www.aosabook.org/en/ghc.html <-- I found this interesting.
10:23:25 <MVQq> but ghc has a user guide :> wonders are contained within
10:23:52 <Guest58965> how would I loop over a STVector? do I have to recurse?
10:24:03 <Guest58965> or is there something nice in control.monad.loops?
10:24:05 <ski> geekosaur : re "levity polymorphism", os `forall a.', where `a' could be be an unboxed type, will have to pass around run-time type info (possibly just size ?) ?
10:24:14 <cocreature> b0llu: foldr/foldl?
10:24:15 <ski> geekosaur : any link ?
10:24:17 * hackagebot lambdatex 0.1.1.0 - Type-Safe LaTeX EDSL  https://hackage.haskell.org/package/lambdatex-0.1.1.0 (Norfair)
10:24:37 <b0llu> cocreature: I suppose, but I'm using a mutable vector. I didn't see a foldable instance on it
10:25:57 <cocreature> b0llu: hm yeah looks like there is no fold for mutable vectors
10:26:02 <geekosaur> ski, https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes but the current plan as I understand it is an extended form of https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes#ProposalB2.Morelevitypolymorphism 
10:26:10 <b0llu> cocreature: so I would have to recurse?
10:26:47 <cocreature> b0llu: you could map over a list of indices
10:26:51 <AndreasK> b0llu: You should be able to use something like "maximum . toList <vector>" and it shouldn't actually create the list iirc
10:27:18 <cocreature> or fold over a list of indices
10:27:22 <geekosaur> ski, https://ghc.haskell.org/trac/ghc/wiki/LevityPolymorphism but there's no actual information there aside from a link to a paper and links to bugs
10:27:38 <geekosaur> there's also been some chatter on the ghc-devs list
10:27:42 <glguy> AndreasK: In the case of maximum, it's not even necessary to include toList
10:27:55 <b0llu> AndreasK: what do you mean?
10:27:59 <b0llu> cocreature: map or fold?
10:28:12 <b0llu> cocreature: hm, I think I'd need "traverse", right?
10:28:22 <cocreature> b0llu: well that depends on what you want to do, if you want to calculate the maximum, fold
10:28:31 <cocreature> or foldrM 
10:28:34 <b0llu> cocreature: I fold on the list of indeces, right?
10:29:11 <AndreasK> glguy: How so? Mutable vectors are not Foldable instances which maximum requires as far as I can tell.
10:29:17 * hackagebot pipes 4.3.0 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.3.0 (GabrielGonzalez)
10:29:32 <glguy> AndreasK: Mutable vectors don't have a toList either, so we couldn't talking about those
10:29:40 <cocreature> b0llu: foldrM (\i acc -> …) [1.. V.length v]
10:29:54 <b0llu> cocreature: I see, let me try that
10:29:56 <b0llu> thanks
10:30:00 <cocreature> b0llu: foldlM' or something like that is probably more appropriate
10:30:20 <cocreature> b0llu: in each step you call "V.read v i" to get access to the current element
10:30:23 <AndreasK> True I mixed that up :(
10:30:26 <b0llu> cocreature: foldrM' comes from where?
10:31:08 <cocreature> looks like foldlM' is not a thing
10:31:24 <cocreature> but there is foldlM in Data.Foldable
10:31:56 <cocreature> just throw in a seq somewhere if you care about spaceleaks
10:32:28 <cocreature> otherwise you’ll accumulate "max (max (max a b) c) d" instead of forcing the calculation at each step
10:32:35 <b0llu> cocreature: where do I throw in the seq?
10:33:25 <cocreature> b0llu: start writing your code and then I can tell you where to put "seq" :) it’s a bit hard to explain this without having code to look at
10:33:44 <b0llu> cocreature: sure
10:33:50 <geekosaur> oh, right, that's why I couldn't find the discussion on ghc-devs, it's a subthread of the "New type of ($) operator in GHC 8.0 is problematic" thread x.x
10:39:03 <sphalerite> I'm using parsec; 'True <$ string "the truth" <|> False <$ string "the lie" :: Parser Bool' never matches "the lie"; I'm guessing that this is because string "the truth" manages to advance a little into the string before it fails (strings that don't share a prefix don't exhibit this behaviour and work as I'd expect). How can I combine multiple parsers with the same prefix?
10:39:08 <granomoly> Hello; How may I utilize Haskell as a Theorem Prover or Algebraic Notebook(?) if at all?..
10:39:55 <geekosaur> sphalerite, `try (string "the truth")`
10:40:35 <b0llu> cocreature: I'm trying to figure out how to use STVector
10:40:59 <lpaste> b0llu pasted “st-vector-greatest-index” at http://lpaste.net/349099
10:41:03 <sphalerite> geekosaur: aah, perfect! Thanks. I came up with another solution while writing my question, but it would have been much harder to read and write than that.
10:41:06 <dash[m]> sphalerite: alternatively `string "the " >> (True <$ string "truth" <|> False <$ string "lie")` would also work I think for that specific case
10:41:11 <b0llu> http://lpaste.net/349099#line33 
10:41:13 <b0llu> line 33
10:41:25 <b0llu> cocreature: can I have some help debugging
10:41:27 <b0llu> its not compiling
10:41:37 <cocreature> b0llu: give me a minute, I’ll try to compile it
10:41:38 <glguy> sphalerite: It's worth reading the documentation on (<|>) and try http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:-60--124--62- http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try
10:41:45 <b0llu> cocreature: sure
10:42:03 <sphalerite> dash[m]: yeah that's the alternative solution that I thought of, but it would be a pain to extend that further
10:42:41 <geekosaur> it would, but if you use "try" too much then the parser spends a lot of time parsing and backtracking
10:43:11 <geekosaur> "try" is handy, but refactoring the parser is often the better choice
10:43:14 <glguy> Parsec turns you into the parser compiler. It's up to you to refactor your grammar to fit into parsec
10:43:15 <cocreature> b0llu: the return type should be  "ST s (Int, a)"
10:43:21 <b0llu> cocreature: ah
10:43:21 <dash[m]> The key distinction is that normally parsers that fail after consuming input will still leave the input consumed. using `try` makes it so a parser doesn't consume input when failing, but also makes it less efficient (as geekosaur was saying)
10:43:40 <b0llu> cocreature: but, like, now that's stuck inside an ST, right?
10:43:47 <b0llu> cocreature: I think I would prefer to runST ?
10:43:51 <b0llu> cocreature: or is that a bad design choice?
10:44:39 <b0llu> oh, runST doesn't do what I think it would do
10:44:39 <sphalerite> glguy: Thanks for the hint! I've been taking a FP class where we worked with parsers that behave similarly to that but where <|> will always backtrack, and I assumed it was written to be fully compatible with Parsec (I was wrong!). https://github.com/pigworker/CS316-16/blob/master/exercises/Ex4.hs
10:45:04 <cocreature> b0llu: btw your implementation makes no use of having access to a mutable vector
10:45:33 <b0llu> cocreature: yes, cause there's no use here. But I want to use it for johnson trotter, so there are swaps coming up
10:45:39 <b0llu> cocreature: there's no writes here*
10:45:47 <b0llu> cocreature: is there a more idiomatic way to write this?
10:45:48 <cocreature> b0llu: generally operations that operate on STVectors should return ST, then you can combine a bunch of them and run "runST" only once
10:45:50 <sphalerite> and yeah. I'm not really writing anything performance critical, just trying to apply what I've learnt to a real-world problem I'm encountering (fairly throw-away code)
10:45:53 <sphalerite> Thanks for the help!
10:45:57 <b0llu> cocreature: ah, okay
10:46:16 <cocreature> b0llu: you have an out of bounds error
10:46:27 <b0llu> cocreature: V.length - 1?
10:46:28 <cocreature> b0llu: V.length xs is after the last element
10:46:30 <cocreature> yep
10:46:33 <ph88_> i'm trying to use lens to traverse a structure, how can i get it to traverse all the way down?  http://pastebin.com/1PY8xbeb
10:46:53 <b0llu> cocreature: the arrays are 0 indexed right?
10:46:57 <cocreature> b0llu: yep
10:47:03 <ski> geekosaur : ty
10:47:11 <b0llu> cocreature: what is the semantics of >>= for ST?
10:47:16 <b0llu> I think I should read the ST implementation
10:47:19 <b0llu> if its not too ctazy
10:47:22 <b0llu> crazy*
10:47:39 <cocreature> ST is a ghc primitive so you’ll have to read GHC source afaik
10:48:12 <cocreature> >>= for ST is pretty similar to >>= IO but you are more limited in the actions you can perform
10:48:20 <b0llu> I see
10:48:57 <b0llu> geekosaur: any idea where ST is defined? :)
10:49:02 <cocreature> ah looks like ST might not be baked that deeply into tghc. most of the source is there
10:49:04 <cocreature> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.ST.html#ST
10:49:21 <glguy> ph88_: It looks like your code is working
10:49:41 <geekosaur> b0llu, not offhand. but relatively little of it is actually primops; much of the "trick" is purely in the typechecker
10:50:05 <geekosaur> (through it being parameterized by an existential phantom type
10:50:12 <b0llu> I see
10:50:24 <ph88_> glguy, i would like foo2 to be  F (Q (B "goodbye"))
10:50:29 <glguy> ph88_: it is
10:50:41 <ph88_> not in my ghci it isn't
10:50:48 <isovector> i'm trying to define a function (:: forall (a :: k). Fam v1 a -> Fam v2 a) by pattern matching on every data constructor of an injective type family, but ghc complains that none of the constructors is of type `Fam v1 a` (with a polymorphic `a`). am i doing anything obviously stupid here?
10:51:06 <glguy> ph88_: Then perhaps an old version of something is broken, or you didn't reload the file after saving it
10:51:10 <glguy> or didn't save
10:51:29 <ph88_> glguy, i saved and reload
10:51:56 <glguy> Testing on GHC 8.0.1 with lens-4.15.1 it works
10:52:04 <ph88_> glguy, i'm on lts-7.11
10:52:22 <glguy> If that doesn't have lens-4.15.1, you might try updating
10:52:36 <ph88_> it does have lens, but i'm not sure which version i'm using atm
10:53:21 <ph88_> how can i find out which version of packages stack is using ?
10:54:14 <geekosaur> ph88_, easiest is to look the lts version up on stackage.org
10:55:03 <ph88_> seems that i'm on lens-4.14
10:55:58 <b0llu> what is "State# "?
10:56:38 <glguy> ph88_: Your example works on lts-7.11
10:56:52 <b0llu> and runRW#?
10:57:00 <b0llu> oh lol, GHC.Magic
10:57:16 <b0llu> cocreature, geekosaur what does State# mean?
10:57:18 <ski> b0llu : a "token" representing the world state, that is passed around (and eventually removed completely in the code generator)
10:57:39 <b0llu> ski: does the # have a special meaning?
10:57:44 <b0llu> ski: or is it just some value?
10:57:46 <geekosaur> by convention, unboxed
10:57:52 <cocreature> but only by convention
10:57:57 <b0llu> I see
10:58:01 <geekosaur> in fact, State# is just the unboxed tuple version of State
10:58:07 <ski> (i think one could think of it as being an empty unboxed (and unlifted(?)) tuple type)
10:58:16 <cocreature> b0llu: tbh if you want to figure out how to use ST, I don’t think reading the source is going to be very helpful
10:58:25 <ski> geekosaur ?
10:58:42 <geekosaur> data State# s a = s -> (# a, s #)
10:58:44 * ski assumes b0llu is looking at `newtype IO a = IO (State# RealWorld -> (# State# RealWorld,a #))'
10:58:44 <b0llu> cocreature: no, I want to see how it is implemented
10:58:48 <geekosaur> er, not exactly
10:58:53 <b0llu> cocreature: isn't ST quite similar to state? except wrapped?
10:58:58 <geekosaur> data State# s a = State# (s -> (# a, s #))
10:59:07 <b0llu> ski: ^
10:59:18 * hackagebot haphviz 0.2.0.1 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.2.0.1 (Norfair)
10:59:31 <b0llu> geekosaur, cocreature how exactly is ST s a different from State s a? 
10:59:48 <geekosaur> where (# #) is the unboxed tuple type. note that unboxed values, including unboxed tuples, can only be used in some circumstances
11:00:01 <b0llu> hmm
11:00:05 <cocreature> b0llu: it doesn’t have an actual state that you can write to and read from
11:00:15 <b0llu> cocreature: so its some dummy "state" ?
11:00:18 <cocreature> yeah
11:00:27 <cocreature> I think it’s mostly there to prevent GHC from reordering things
11:00:31 <cocreature> but it gets eliminated completely
11:00:47 <ski> b0llu : `State s' threads values of type `s', `ST s' threads "values" of type `State# s'
11:01:17 <geekosaur> b0llu, in practice it's just two (possibly unboxed) values right next to each other. ghc depends on this, it's how it can make the `s` part go away completely for IO and ST (because the `s` is phantom with no runtime representation) --- code gen knows nothing uses it, so just leaves that part out and youre left with the normal boxed representation of the `a`
11:01:38 <ski> (given `newtype ST s a = ST (State# s -> (# State# s,a #))')
11:01:47 <b0llu> ski: but I have no control as to what State# s, right?
11:01:51 <ski> right
11:02:00 <b0llu> geekosaur: hmm
11:02:23 <b0llu> geekosaur: how does GHC infer that the s is phantom?
11:02:37 <b0llu> ski: what stops me from "creating" a State#? because its not exported from the module?
11:03:30 <geekosaur> b0llu, the typechecker guarantees it, since it knows that it's only used in contexts where it is of an existential phantom type and therefore can never be inhabited
11:04:06 <b0llu> geekosaur: so, beacuse it is existential, no one can "access it" and hence it doesn't matter?
11:04:12 <ski> conceptually, `State# s' represents your ("final future") heap. if you only even allocate two `Int's and a `String', then you could think of it as `(# Int , Int , String #)', being passed around. `STRef s a's are indices (/references/pointers) into this (heterogenously typed) heap/map/memory. the `STRef s a's doesn't contain the value of type `a', the heap does (which is why you can compare `STRef s a' for `Eq', even without `Eq a')
11:04:20 <geekosaur> so when codegen is working with an IO a or an ST a (which it has to be written for, since the types are gone but it can only be invoked in those circumstances), it knows it can just omit the `s` part
11:04:29 <geekosaur> b0llu, yes
11:04:37 <ski> b0llu, yep
11:05:07 <b0llu> geekosaur: GHC does type erasure
11:05:09 <b0llu> ?
11:05:28 <geekosaur> types are gone past the typechecker, yes
11:05:33 <ph88_> glguy, yes it's strange, now it gives the right result  ..  how does lens know it's suppose to replace `B "hello"` with `B "goodbye"` instead of replacing say F or Q   ?
11:05:55 <geekosaur> which is why, if you want run time type information, you need to pack a dictionary with the value (Typeable)
11:05:59 <glguy> Because the types of all those things are different
11:06:15 <b0llu> ski: when you talk about (# Int, Int String #), what is the relationship to State# s?
11:07:03 <ph88_> glguy, i mean how can it know that it only has to apply the function   (\s -> B "goodbye")   to the B type ?
11:07:28 <glguy> Because the type of s is constrainted to be B
11:07:47 <ph88_> glguy, where is this constraint coming from ?
11:07:48 <ski> (b0llu : also note that `unsafeInterleaveST' is more dangerous than `unsafeInterleaveIO'. with the former, you can write a "function" which gives a different result, depending on the order in which you inspect the result; while with the latter you could (arguably) attribute differences in results to general I/O nondeterministic behaviour (along the lines of by-need being similar to concurrency))
11:07:57 <ski> b0llu : btw .. for (lazy) `ST', monochrom's "lazy ST example" in 2012-02-18 (and later) at <http://lpaste.net/63925> (cf. "control.monad.state.lazy" in 2010-11-25 (and later) at <http://lpaste.net/41790>),"sequence causing stack overflow on pretty small lists" in 2013-08-27 at <https://mail.haskell.org/pipermail/haskell-cafe/2013-August/109998.html> might be fun
11:08:04 <glguy> ph88_: The function that is being applied to it
11:08:12 <b0llu> ski: ty
11:08:36 <glguy> over biplate :: (Typeable a, Data t) => (a -> a) -> t -> t
11:08:59 <glguy> In your particular case you could have used: set biplate :: (Typeable a, Data t) => a -> t -> t
11:09:24 <ph88_> glguy, don't see any function that is applied to s   (\s -> applyFunction s)
11:09:41 <ski> b0llu : if you only ever allocate three reference cells (with `newSTRef'), with contents of types `Int',`Int',`String', then your use of `ST s Result' is similar to using `State (# Int,Int,String #) Result', threading your free values around (you can imagine they being initialized to `_|_' in the tuple before you reach the `newSTRef' action in the State Thread (which is what `ST' stands for))
11:09:57 <glguy> ph88_: the function is being applied to the whole lambda expression: \s -> B "goodbye"
11:10:06 <pikajude> EvanR: is this at all more helpful? http://lpaste.net/4490829950865113088
11:10:09 <b0llu> ski: I havem't used STRef
11:10:21 <b0llu> ski: so it's like a new'd pointer?
11:10:33 <glguy> In traverseOf biplate %~ (\s -> B "goodbye"),   (%~) (traverseOf biplate)  is being applied to the lambda expression
11:10:33 <EvanR> pikajude: looks the same as before
11:10:51 <glguy> ph88_: traverseOf = id, so   traverseOf biplate = biplate
11:11:04 <pikajude> EvanR: ok
11:11:25 <ph88_> glguy, so there is some function that takes  \s -> B "goodbye"  as argument. How can that function yield to constraint that s has to be a B, when there are no other functions which specifically deal with the Bar type
11:11:43 <ski> b0llu : the catch is that you *don't* (in general) know statically, before the execution, which reference cells will be allocated. the other interesting thing with `ST' is that you can allocate reference cells with contents having any type you like, which you couldn't simulate with `State (IntMap ?which-content-type-here?)' (`Int' corresponding to `STRef s ParticularContentType')
11:11:49 <ski> b0llu : yes
11:12:11 <glguy> ph88_: over biplate :: (Typeable a, Data t) => (a -> a) -> t -> t
11:12:17 <glguy> See the (a -> a)?
11:12:20 <ph88_> ya
11:12:21 <ski> b0llu : what i said for `STRef' also applies for `STArray', except that you get a whole bunch of related cells (of the same type), instead of just one
11:12:33 <b0llu> ski: can you expand on the latter? 
11:12:35 <glguy> That tells us whatever function we apply   over biplate to, it's argument and result types will be the same
11:12:47 <martinium> does anyone know of any libraries in haskell of good quality for trading?
11:12:58 <glguy> (\s -> B "goodbye")'s result type will be B, so then we know that it's argument type is, too
11:12:59 <ph88_> glguy, ah so when you have     a -> a     and your function yield a specific type then the argument must be of the same type
11:13:10 <ski> (there's also `runSTArray',`runSTUArray' as alternatives to `runST', for when you want to generate an array imperatively, then return it as a result (automatically freezing it to an immutable one))
11:13:19 <b0llu> ski: the part with "you can allocate reference cells..."
11:13:22 <orion> dolio: Hi. Are you around?
11:13:24 <b0llu> ski: interesting
11:13:29 <pikajude> EvanR: there's no other way it can be structured
11:14:02 <ph88_> glguy, and you say i can use set because i don't use the old value ?
11:14:11 <glguy> yeah
11:14:19 <ph88_> ok cool
11:14:20 <orion> There is a package called monad-coroutine. Are there any data structures isomorphic to this provided in other packages?
11:14:34 <ski> b0llu : generally, freezing a mutable array (or thawing an immutable array) requires copying it, but in the `runSTArray',`runSTUArray' case, we're sure that we hold the only reference to the (recently allocated) array, so we can just "coerce" the same memory block into the immutable type
11:14:54 <b0llu> hm
11:14:58 <b0llu> ski: this is all "magic"?
11:15:18 <EvanR> pikajude: i do recall a package for a transformery thing with a fork command, but really i dont know how this effects thing works
11:15:36 <orion> ski: Would you consider ST to be a poor man's substitute for linear types?
11:16:20 <ski> b0llu : the simplest way to simulate `ST' is something like `State (Int,IntMap Value)', where we have to pick a particular `Value' type (so we have a *homogenous* heap, not a heterogenous one)
11:16:41 <b0llu> ski: can you give me an example where ST gives us heterogenity?
11:17:02 <EvanR> thanks to Monad
11:17:10 <monochrom> x <- newSTRef True; y <- newSTRef "hello"
11:17:46 <ski> orion : itym s/linear types/uniqueness types/, and no, `ST' could be seen as an abstract data type *hiding* innards which would require uniqueness types .. but even in languages with uniqueness (like Clean,Mercury), you'd still want something like `ST'
11:17:51 <b0llu> monochrom: ooh
11:17:56 <b0llu> monochrom: but that is because of >>= semantics
11:18:03 <b0llu> monochrom: I can do the same with state?
11:18:16 <monochrom> z <- newSTRef HuffHuff  (where HuffHuff belongs to a type I will write next year so you don't even know about it today)
11:18:22 <monochrom> No.
11:19:05 <monochrom> But you can show me how.
11:20:12 <ph88_> glguy, can you talk a bit about this patch?  https://github.com/ekmett/lens/commit/4e01a13f2fe738e77af29e09370a6cbaa74e6af9
11:20:36 <b0llu> monochrom: do x <- pure 1; y <- pure False; ?
11:20:39 <ski> orion : in Mercury, instead of using the abstract `ST s a', you concretely use `State# s -> (a,State# s)', or rather you pass (unique !) values of type `State# s' around. you have (in Haskell terms) `newState :: () -> exists. State# s', `newRef :: *(State# s) -> a -> (*(StRef s a),*(State# s))', &c., `*' indicating unique parts
11:20:53 <glguy> That was a misuse of the GHC.Generics API that stopped making sense when GHC 8 removed the nonsense Generic instances for the primitives
11:21:00 <glguy> so it's gone now
11:21:06 <monochrom> and how do you implement readSTRef and writeSTRef?
11:21:23 <orion> ski: Interesting.
11:21:30 <kipso> join
11:21:43 <monochrom> and where do you use your IntMap?
11:21:47 <ph88_> glguy, can you eloborate a bit more on the removed Generics instances in GHC 8 , i'm curious
11:22:05 <b0llu> monochrom: hm
11:22:07 <glguy> Int used to have a circular instance of Generic previously
11:22:13 <glguy> for example
11:22:14 <ski> (the `*' syntax is from Clean, btw. in practice it would be a little bit more involved, due to uniqueness polymorphism (wanting to have as general a type as possible for the function))
11:22:34 <ph88_> glguy, does that mean that of GHC 8 this function didn't work anymore ?
11:22:51 <glguy> It meant that the common uses of it including the examples in the documentation didn't work
11:22:57 <b0llu> monochrom: readSTRef basically gives you bacl ST s a rigt?
11:23:05 <b0llu> monochrom: which is some sort of "existential s" and an a?
11:23:09 <glguy> Also it was slow and still relied on Typeable to work, so it wasn't even really a proper GHC.Generics definition
11:23:31 <b0llu> monochrom: oh, okay. I can't pull out the trapped value from state since it's s -> (a, s)
11:23:33 <b0llu> monochrom: hmm
11:23:44 <b0llu> monochrom: interesting
11:23:47 * monochrom shakes head
11:23:47 <ph88_> glguy, in your best guess is it feasible to implement the tinplate and similar functions like biplate with GHC.Generics ? 
11:23:52 <b0llu> monochrom: no?
11:24:18 <glguy> ph88_: I don't think it's a good fit
11:24:50 <ph88_> i haven't even ever seen it work that way
11:25:58 <ski> orion : <https://www.mercurylang.org/information/doc-latest/mercury_library/store.html> is the library in question, for Mercury. i think `new_cyclic_mutvar' is interesting, in Haskell terms, it'd be `newCyclicSTRef :: (STRef s a -> a) -> STRef s (STRef s a); newCyclicSTRef f = mfix (newSTRef . f)'
11:27:07 <ski> b0llu : `readSTRef' looks up the "index" in the state "heap" passed to it, and yields the contents (and the same unmodified heap)
11:27:32 <granomoly> Hello; How may I utilize Haskell as a Theorem Prover or Algebraic Notebook(?) if at all?..
11:28:03 * ski idly wonders what an "Algebraic Notebook" is intended to mean
11:29:15 <ph88_> is it possible to copy memory from a data structure ?
11:29:46 <ph88_> like copy memory with size of C struct  .. but then a haskell data structure
11:29:47 <orion> ski: Thanks.
11:30:37 <geekosaur> ph88_, only with a Storable instance and then using the Foreign.Storable stuff
11:30:50 <geekosaur> Haskell ADTs are not stored in a way you can usefully memcopy
11:30:54 <granomoly> ski: "Notebook" in the PyNotebook/Mathematica sense should suffice, with the added expectation that I may ensue algebraic computations
11:31:18 <b0llu> ski: is that what it "Actually" does?
11:31:24 <b0llu> ski: or is that an intuitive explanation?
11:31:49 <b0llu> orion: what is mercury?
11:32:20 <orion> b0llu: Mercury is a logic/functional programming language which combines the clarity and expressiveness of declarative programming with advanced static analysis and error detection features.
11:32:56 <ph88_> bye all
11:33:00 <geekosaur> b0llu, a logic language whch is more or less a hybrid of Haskell and Prolog
11:33:33 <ski> orion : what a library like that (or `ST' in Haskell) gives you, over plain uniqueness, is (a) bundling up many different values (determined dynamically, as-we-go, of possibly differing types) into a single value (with "index" values which can be used with it to retrieve contents), which can be convenient;
11:33:39 <ski> orion : and (b) there is a possibility to store a *unique* value in a cell, while still sharing the reference to (the index into) the cell (as opposed to the reference to the value itself, which would destroy uniqueness)
11:34:22 <b0llu> orion: oh, that sounds super interesting. link?
11:34:35 <orion> b0llu: https://mercurylang.org/
11:34:37 <ski> orion : so in a sense, you can "have your cake and eat it too" (have uniqueness of the value, while sharing the reference to the cell)
11:34:50 <geekosaur> also https://github.com/Mercury-Language
11:35:34 <ski> b0llu : "is that what it \"Actually\" does?","or is that an intuitive explanation?" -- which ?
11:36:07 <orion> ski: Wait, why would sharing a reference to a value destroy uniqueness?
11:36:17 <b0llu> ski: the "index the heap"?
11:36:28 <b0llu> orion: is it still active?
11:36:43 <geekosaur> (so, everything mind-bending in Haskell plus everything mind-bending in Prolog. it will certainly exercise your neurons :p )
11:37:31 <seishun> > 0 :+ 1
11:37:31 <ski> b0llu : in actualy implementation, afaiui, the "index" is simply the memory address into the part of the memory where you dynamically allocate memory blocks (i don't recall whether it makes a difference that this block is mutable)
11:37:33 <lambdabot>  0 :+ 1
11:38:00 <seishun> is this the shortest way to get an imaginary unit?
11:38:16 <EvanR> define j = that
11:38:46 <b0llu> ski: "indexing" in the C sense of the pointer dereference?
11:38:50 <ski> b0llu : but part of the point of this picture is to realize that the value of type `a' is *not* "inside" the value of type `STRef s a', rather it's in the hidden state being (conceptually) threaded around by `ST s', while the former merely acts as an index/key into that data structure. this also explains why `instance Eq (STRef s a)' is fine
11:39:09 <b0llu> right
11:39:18 <ski> (but because of things possibly being moved around by copying (compacting) GC, you don't get `instance Ord (STRef s a)')
11:40:03 <ski> b0llu : "indexing" in the sense of indexing into an array, or a linked list. iow mapping a conceptual position to a corresponding value, given a collection in which to look it up in
11:41:35 <b0llu> ski: okay
11:41:36 <ski> orion : uniqueness means that you have exactly one reference to the value in question (a slight relaxation is that you know, statically/definitely, where all references to it are located)
11:43:16 <seishun> is there a variant of foldl where the function comes as the last argument?
11:43:45 <ski> not that i know of
11:44:12 <seishun> what do people usually do, wrap the lambda in brackets or define the function separately?
11:44:27 <ogkloo> I just do (\x -> whatever)
11:44:34 <ogkloo> er obviously it'd have two arguments
11:44:37 <ogkloo> but you get the idea
11:44:43 <seishun> I see
11:44:50 <ogkloo> or yes define it separately
11:45:00 <ogkloo> if you're liable to use it twice, just put it somewhere
11:45:03 <ogkloo> or if it gets ugly
11:45:26 <orion> ski: Wait, do you're just adding one level of indirection and still calling it unique?
11:45:30 <orion> s/do/so
11:45:36 <b0llu> ski: any more interesting information about STRef / ST?
11:49:14 <carado> how handicapped would haskell be without cyclic structures of any kind ?
11:49:39 <ski> orion : the value is stored uniquely inside the heap, which is passed around uniquely. sharing the "integers" which you use to index into this heap data structure doesn't affect the uniqueness of the former and the values stored in it
11:51:22 <ski> orion : of course, when accessing a unique value in the heap, you'd need to replace it by another one, to avoid now having two references to it; or make sure that noone else can access that cell in the heap, while you're modifying it
11:51:41 <orion> Right.
11:51:59 <ski> carado : note that recursive functions are cyclic structures, so i'd say *very* handicapped
11:53:26 <ski> (the "make sure that noone else .." is really a (temporary) shift to definite referencing, rather than unique referencing)
11:55:05 <ski> (some tail-call-module-cons optimizations in Mercury will also employ definite referencing, for the generated code, e.g. to be able to build a list from start to end, rather than the other way around (functions and data constructors in Mercury are strict))
11:59:14 <b0llu> ski: how do I use move if I have an STVector?
11:59:39 <b0llu> how do I use swap&
11:59:40 <b0llu> *
11:59:52 * ski doesn't know that much about `STVector'
12:00:18 <b0llu> hm, okay :)
12:01:47 <lpaste> b0llu pasted “help-with-STVector-move-fn” at http://lpaste.net/349145
12:01:57 <b0llu> http://lpaste.net/349145#line59
12:02:05 <b0llu> help please, how do I use swap on an STVector?
12:03:24 <b0llu> I'm getting a type error relating to my use of "s" in STVector s a
12:03:30 <b0llu> I think I have my "s" wrong
12:03:33 <b0llu> but I don't know how to fix it
12:04:21 <quchen> _ = ST s (), no?
12:05:46 <b0llu> but it's having a problem with the "s" itself
12:06:00 <b0llu> oh
12:06:02 <b0llu> hm
12:06:06 <b0llu> that worked?
12:06:08 <dmj`> Is the strict pragma ghc 8 only ?
12:06:13 <EvanR> "finite limits and small colimits", what does small mean ?
12:06:26 <b0llu> so, "PrimState m" is ST s in this case?
12:06:33 <b0llu> what exactly is PrimState?
12:06:43 <b0llu> either IO or ST s?
12:08:24 <quchen> Yes.
12:08:28 <quchen> Well, no
12:08:33 <b0llu> ?
12:08:33 <quchen> PrimState IO = RealWorld
12:08:40 <quchen> PrimState (ST s) = s
12:08:41 <quchen> iirc
12:08:52 <EvanR> so PrimState is a type family
12:08:57 <b0llu> oh
12:08:58 <quchen> Well, PrimMonad = IO or ST s.
12:09:00 <quchen> I think.
12:09:03 <quchen> Something along those lines.
12:09:12 <quchen> Anyway, gotta go :-)
12:09:14 <b0llu> quchen: what else can it be?
12:09:16 <b0llu> okay :)
12:09:29 <quchen> Nothing, I think it’s just those two possible ones
12:09:34 <b0llu> ah, okay
12:10:11 <ski> @type let infixr 2 <||>; (<||>) :: Monad m => m Bool -> m Bool -> m Bool; mb0 <||> mb1 = mb0 >>= \case True -> return True; False -> mb1 in (<||>)
12:10:13 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
12:10:22 <ski> @type let infixr 3 <&&>; (<&&>) :: Monad m => m Bool -> m Bool -> m Bool; mb0 <&&> mb1 = mb0 >>= \case False -> return False; True -> mb1 in (<&&>)
12:10:24 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
12:10:34 <ski> are those (or something similar) in some lib ?
12:10:51 <ski> @type unless
12:10:52 <lambdabot> Applicative f => Bool -> f () -> f ()
12:10:53 <ski> @type when
12:10:54 <lambdabot> Applicative f => Bool -> f () -> f ()
12:11:51 <b0llu> ski: liftM2 (||)?
12:12:05 <b0llu> ski: and liftM2 (&&)? or am I missing something?
12:12:17 <ski> EvanR : .. perhaps the indexing class being a set (as opposed to perhaps something like the whole class of objects in a large category) ?
12:12:45 <ski> b0llu : those don't have short-circuiting behaviour (unless you have a simple enough monad)
12:13:16 <b0llu> ski: oh, hm, I see
12:13:20 <EvanR> ski: how does that restriction work itself into CT theorems about which limits are preserved
12:13:37 <EvanR> it seems non categorical
12:23:16 <ski> EvanR : i don't know
12:28:34 <ski> (related to this, perhaps there should be `class Applicative i => ApplicativeChoice i where eitherA :: i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1 -> b)' ?)
12:30:11 <ski> (hm, or i suppose perhaps rather `eitherA :: i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1) -> i b' ? ..)
12:33:05 <zebr> hi all. what is the real reason for distinguishing newtype from data? if you have a constructor with a single argument anyway, what's gained? i ask because i apparently can't do `newtype Foo a where Foo :: Bar a => a -> Foo a` but i can with data. so i'm wondering why the restriction.
12:33:06 <ski> (then we could have `(<||>) :: ApplicativeChoice i => i Bool -> i Bool -> i Bool; ib0 <||> ib1 = eitherA (pure (\() -> True)) (fmap (\b1 () -> b1) ib1) (fmap (\case True -> Left (); False -> Right ()) ib0)', and similarly for `(<&&>)')
12:35:04 <ski> @type let unlessB :: Applicative i => Bool -> f Bool -> f Bool; unlessB True _ = pure True; unlessB False ib = ib in unlessB
12:35:05 <lambdabot> error:
12:35:06 <lambdabot>     • Could not deduce (Applicative i0)
12:35:06 <lambdabot>       from the context: Applicative i
12:35:13 <ski> @type let unlessB :: Applicative i => Bool -> i Bool -> i Bool; unlessB True _ = pure True; unlessB False ib = ib in unlessB
12:35:15 <lambdabot> Applicative i => Bool -> i Bool -> i Bool
12:35:30 <ski> @type let whenB :: Applicative i => Bool -> i Bool -> i Bool; whenB False _ = pure True; whenB True ib = ib in whenB
12:35:31 <lambdabot> Applicative i => Bool -> i Bool -> i Bool
12:37:47 <ski> i suppose one could have variants with a default value, generalizing to `a -> Bool -> i a -> i a'
12:38:31 <ski> zebr : `newtype' constructors are strict, and matching on them always terminates
12:39:09 <ski> zebr : in terms of implementation, typically there's one less indirection, as you're simply reusing the representation type as the new type, instead of wrapping it
12:40:03 <ski> zebr : in implementations, `Bar a => ' would often be translated to passing around a value of type `BarDict a' (a typeclass dictionary, "vtable") at run-time, which would then become an extra argument for your data constructor `Foo'
12:40:45 <b0llu> is there a quick way to create a mutable vector form a list?
12:41:06 <AndreasK> Creating a immutable one and thawing i guess
12:41:19 <b0llu> AndreasK: uh, how do I thaw?
12:41:33 <ski> @hoogle thaw
12:41:33 <lambdabot> Data.Vector thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
12:41:33 <lambdabot> Data.Vector.Generic thaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
12:41:34 <ski> @hoogle unsafeThaw
12:41:35 <lambdabot> Data.Vector.Primitive thaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
12:41:37 <lambdabot> Data.Vector unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
12:41:39 <lambdabot> Data.Vector.Generic unsafeThaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
12:41:41 <lambdabot> Data.Vector.Primitive unsafeThaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
12:42:03 <zebr> ski: ah, that makes sense, thanks
12:42:14 <ski> (also in `Data.Array')
12:42:45 <ski> zebr : so there's both a semantics side and an implementation side of it
12:42:50 <b0llu> ty
12:45:02 <orion> Does anyone know what alternatives there are to the monad-coroutines package?
12:46:10 <MarLinn> ski, what would be the benefit of explicit booleans vs just using the Either values directly?
12:47:16 <ski> MarLinn : hm, regarding which operation ?
12:47:46 <b0llu> :t assert
12:47:49 <lambdabot> Bool -> a -> a
12:48:05 <MarLinn> ski, the ones you build from the theoretical eitherA
12:48:52 <ski> merely convenience, if you already have `i Bool's, and want to combine them in something looking like a boolean algebra expression
12:49:56 <MarLinn> mh whenever I see a boolean I wonder if could short-circuit to the value it represents, but that may just be me
12:50:06 <ski> (fwiw, `ismobile' in b0llu's paste <http://lpaste.net/349145#line59> made be think of this, presently)
12:50:13 <MarLinn> btw that eitherA looks very much like (|||)
12:50:52 <ski> (and as you can see from <http://ircbrowse.net/browse/haskell?q=eitherA>, this is not the first time i'm pondering this)
12:50:58 <haskell_God> I have a problem; it seems that the <- operator makes my program freeze in the do block. The function call after <- is from another module, and works fine by itself. Any suggestions what might be wrong?
12:50:59 <ski> `(|||)' being ?
12:52:12 <MarLinn> (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
12:53:26 <slack1256> is separation of generators and consumers the only notion of modularity? are they others?
12:55:28 <Gurkenglas> stack's been stuck like this for minutes https://gyazo.com/091217bd031060cf0ad190bf1acdf25c why?
12:59:13 <ThomasHallgren> Hello everyone! Anyone need some help with haskell?
13:00:28 <haskell_God> yes, here's my question: It seems that the <- operator makes my program freeze in the do block. The function call after <- is from another module, and works fine by itself. Any suggestions what might be wrong?
13:00:41 <Tuplanolla> @paste
13:00:41 <lambdabot> Haskell pastebin: http://lpaste.net/
13:01:30 <ThomasHallgren> Hmm, that is a very good question, haskell_god. Please use http://lpaste.net/ so that i can see the issue more clearly.
13:02:43 <EvanR> <- isnt an operator, its part of the do notation syntax
13:06:21 <shapr> ThomasHallgren: are you the person who did Fudgets and House?
13:07:09 <ThomasHallgren> shapr: No, he is my lecturer actually
13:07:41 <shapr> huh, ok
13:08:01 <ThomasHallgren> He is great
13:09:13 <haskell_God> all right, here's the code: http://lpaste.net/349177
13:09:46 <haskell_God> on line 3 the the program freezes
13:10:57 <Gurkenglas> Try replacing lines 4 through 7 with print board? (Assuming GameBoard has Show.)
13:14:00 <haskell_God> The thing is that it doesn't execute the lines beyond line 3
13:14:48 <ThomasHallgren> Hmm, I don't really know what the issue might be. Could anyone else take a look at haskell_god's problem?
13:15:17 <Tuplanolla> Paste more.
13:15:25 <Gurkenglas> haskell_God, how do you know it's not freezing at the start of line 4?
13:16:34 <b0llu> thanks for the help everybody, I managed to implement johnson trotter using mutability ^_^
13:16:38 <b0llu> code is ugly as sin though: https://github.com/bollu/haskell-koans/blob/master/permutations-combinations.hs#L104
13:16:47 <b0llu> I would appreciate github issues on making it nicer :)
13:17:37 <Gurkenglas> How do you know readMinesweeper works fine by itself? Did you run 'readMinesweeper "mines.txt"' in ghci? If you did, replacing lines 4 through 7 with print board should work as well.
13:19:08 <not_nathan> I've got a Lens question if anyone feels up to it.
13:19:26 <dash[m]> go for it
13:19:26 <haskell_God> so, here's the first module : http://lpaste.net/349179. And here's the second: http://lpaste.net/349181
13:20:14 <haskell_God> Yes, but the GameBoard doesn't show the same way as we paint it uing canvas
13:21:04 <ThomasHallgren> haskell_god: Ohh, so you are making a web application. 
13:21:04 <not_nathan> http://lpaste.net/349180
13:22:06 <not_nathan> Just so you all know, I'm just getting into lenses.
13:23:07 <haskell_God> ThomasHallgren: Yes, basically
13:24:23 <Gurkenglas> not_nathan, maybeFoos = foldOf $ foobars . traverse . foo
13:24:53 <Gurkenglas> (or "quux ^.. foobars . traverse . foo")
13:25:29 <Gurkenglas> -foldOf+toListOf ._.
13:26:42 <Gurkenglas> (I did go to test it with lambdabot first but asking ghci whether the types work out is a bit fuzzy with lens)
13:28:56 <not_nathan> Thanks Gurkenglas .
13:37:38 <Gurkenglas> Why is there Maybe-lookup for Vector but not MVector?
13:39:13 <eric____> Hello all
13:39:37 <eric____> I've got a quick question about installing a package using cabal
13:39:49 <eric____> Anyone here / willing to help?
13:40:18 <jle`> best to just ask your question :)
13:40:39 <eric____> Word just checking to see if people are actaully here haha
13:40:51 <eric____> Using the command "cabal install vivid"
13:41:00 <eric____> I get a non-zero exit status
13:41:16 <eric____> There's a problem compiling the library
13:41:34 <eric____> Preprocessing library vivid-0.2.0.5...
13:41:48 <eric____> Vivid/SynthDef/FromUA.hs:1:1: error:
13:41:49 <eric____> etc.
13:42:19 <eric____> It's a specific package, idk how familiar people are going to be with it
13:43:03 <erisco> where are the folds and so on for MVector?
13:44:51 <eric____> Anyone got experience generating audio with haskell?
13:47:15 <jle`> eric____: can you paste more of the error?  looks like you stopped pasting at the point where it really mattered, heh
13:47:18 <jle`> @where lpaste
13:47:18 <lambdabot> http://lpaste.net/
13:47:26 <jle`> eric____: what kind of folds are you thinking of?
13:47:39 <eric____> I don't think in folds yet
13:47:45 <eric____> But it looks like, as for the vivid package
13:47:46 <jle`> oh sorry, that was meant for erisco 
13:47:58 <eric____> I need to install supercollider first
13:48:12 <eric____> reading the docs on the maintainer's site
13:48:32 <erisco> jle`, a strict left fold
13:48:33 <jle`> the "etc." in your messages is the most important part of the error, heh
13:48:39 <jle`> erisco: what type would it have?
13:48:57 <erisco> are there any or no?
13:49:12 <jle`> eric____: that's like saying "I have an error message -- the message is 'Error: (etc.)'"
13:49:21 <eric____> Okay so continuing from the etc.
13:49:24 <eric____> "solveWanteds: too many iterations (limit = 4)"
13:49:30 <eric____> "Unsolved: WC {wc_simple ="
13:49:32 <jle`> paste the whol ething on lpaste
13:49:36 <jle`> @where lpaste
13:49:36 <lambdabot> http://lpaste.net/
13:49:36 <eric____> lpaste
13:49:41 <eric____> got it one sec
13:49:47 <eric____> @where lpaste
13:49:47 <lambdabot> http://lpaste.net/
13:50:12 <jle`> erisco: was wondering what you thought a strict left fold for mvectors would even mean
13:51:00 <jle`> erisco: if you wanted, you could probably freeze it and do a strict left fold on that
13:51:06 <jle`> that wprobably wouldn't do any extra allocations
13:51:19 <erisco> sure it would
13:51:35 <jle`> erisco: foldl' f z <$> freeze v
13:52:08 <lpaste> eric____ pasted “Vivid install error” at http://lpaste.net/349198
13:52:22 <lpaste> eric____ pasted “Vivid install error” at http://lpaste.net/349199
13:53:00 <jle`> hm that's definitely odd.
13:53:08 <jle`> have you tried installing it with stack?
13:53:14 <erisco> why not  (b -> a -> b) -> b -> MVector s a -> s b
13:53:51 <erisco> (b -> a -> b) -> b -> MVector s a -> m s b
13:54:10 <jle`> (b -> a -> b) -> b -> MVector s a -> m b, you mean, right?
13:54:15 <eric____> Installing it with stack... no I haven'
13:54:21 <eric____> I'll look it up
13:54:33 <erisco> no
13:54:37 <jle`> that's definitely weird though; i haven't seen something like that before
13:54:57 <jle`> (to eric____ )
13:56:23 * ski . o O ( Thomas Hallgren )
13:56:26 <jle`> erisco: i guess it's not really a common operation you'd do with mvectors. most mvector operations include reading and writing at different indices
13:56:36 <ski> @where Fudgets
13:56:36 <lambdabot> GUI using X, by Thomas Hallgren and Magnus Carlsson, at <http://www.altocumulus.org/Fudgets/>,<http://www.carlssonia.org/ogi/ProdArrows/>. Also see `Alfa'
13:56:41 <ski> @where House
13:56:41 <lambdabot> http://programatica.cs.pdx.edu/House/
13:56:50 <jle`> erisco: foldl' f z <$> freeze v might be the simplest way
13:56:54 <ski> @where Alfa
13:56:55 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
13:56:55 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
13:56:55 <lambdabot> Agda',`Fudgets',`GF'
13:57:10 <EvanR> jle`: yeah i think he wants a transactional fold
13:57:27 <EvanR> so you could have the MVector in a TVar
13:57:48 <EvanR> (assuming it had an unsafe fold operation)
13:58:38 <erisco> I'll just have to write it myself then
13:59:20 <EvanR> theres foldM
13:59:49 <erisco> MVector isn't Traversable
13:59:57 <jle`> i don't think foldl' f z <$> freeze v should make any allocations; freeze is a good producer i believe
14:00:08 <EvanR> youd foldM over the indexes
14:00:26 <EvanR> doesnt freeze make a copy of the whole array?
14:00:36 <jle`> in some cases
14:00:43 <jle`> hm i could be wrong
14:01:22 <erisco> it'd have to know the frozen array is not used after the next mutation
14:01:41 <jle`> the frozen array is indeed never used
14:01:46 <jle`> it's lost to gc forever
14:02:05 <erisco> I doubt there is a pragma for that
14:02:37 <jle`> stream fusion should recognize producers like freeze and consumers like foldl'
14:02:59 <erisco> and replace it with the foldl' implementation it won't expose to me?
14:03:20 <EvanR> theres unsafeFreeze
14:03:37 <EvanR> but freeze really needs to make a full copy now, not lazily
14:04:53 <EvanR> freeze mv = unsafeFreeze =<< M.clone mv
14:05:18 <jle`> oh darn
14:10:44 <erisco> what could go wrong
14:11:30 <EvanR> since were talking about thread safety, because i said so, i am wondering about that M.clone
14:11:59 <EvanR> if were not worried about it, you could just do unsafeFreeze
14:13:08 <erisco> not worried about it... would design it differently if I was
14:16:54 <erisco> onMVec f v = f <$> UV.unsafeFreeze v
14:17:09 <erisco> UV is Data.Vector.Unboxed
14:20:42 <EvanR> heh, unsafeOnMVec ;)
14:22:03 <erisco> is it? it gets stuck in the state monad
14:22:39 <erisco> I suppose laziness can make it weird
14:22:48 <EvanR> if you do onMVec f v, then modify v, then evaluate the result...
14:23:32 <EvanR> a good contract for unsafeFreeze is that you dont use the original vector after the freeze returns
14:23:52 <EvanR> so it its hidden inside a function you might not remember that
14:24:44 <EvanR> freeze fulfills the contract because it creates that original vector and forgets it internally
14:24:54 <EvanR> fulfills the contract automatically
14:25:16 <erisco> the 'm b' value needs a dependency on the 'b' value, to full normal form
14:25:30 <erisco> not sure if there is any way to do that with GHC
14:25:50 <EvanR> are you trying to do a fold ?
14:26:05 <erisco> yes, but then there are derivatives such as 'any' and so on
14:28:19 <jle`> you could run a Fold from the foldl library i suppose
14:28:29 <erisco> seq only takes to whnf doesn't it?
14:28:31 <jle`> that wouild guaruntee that you never mutate the thing
14:28:33 <EvanR> yes
14:28:43 <erisco> it is better than nothing
14:28:54 <EvanR> on an unboxed vector, thats everything
14:29:21 <jle`> foldMVec :: Fold a b -> MVector s a -> m b; foldMVec f v = fold f <$> unsafeFreeze v
14:29:49 <erisco> say you put the elements of the mutable vector in a list. Lists are lazy, and just evaluating to : leaves you open to mutable weirdness
14:30:44 <erisco> if you send the vector to, say, Bool, it is fine
14:30:59 <erisco> but (Bool, Bool) is not fine
14:31:02 <erisco> layers of the onion
14:31:04 <jle`> as in, if someone modified the vector later
14:31:08 <jle`> and you read from your folded value
14:31:10 <EvanR> you dont have to worry about this if you clone
14:31:11 <jle`> you'd get the new val?
14:31:21 <EvanR> or dont use arrays
14:31:49 <EvanR> jle`: he means if if returns a Bool and seqs it
14:32:25 <erisco> I am just wondering if onMVec is really unsafeOnMVec, and it seems so
14:32:33 <EvanR> really, its violating referential transparency to define something using an unsafeFreezed array which is then modified
14:32:56 <EvanR> even if you seq it
14:33:10 <erisco> well I don't know how to seq it
14:33:33 <EvanR> by doing !x <- onMVec f v (if you are returning a Bool)
14:34:13 <erisco> hm, maybe that works
14:35:38 <erisco> ah neat, there is a class called NFData which is that which can be eval'd to normal form by seq
14:35:50 <EvanR> yes
14:36:03 <jle`> i call it superseq
14:36:09 <jle`> but they call it deepseq
14:36:20 <jle`> i submitted a PR but they never responded
14:36:49 <codedmart> I read a blog or something about using MaybeT and it had something like this https://gist.github.com/codedmart/fb18e0dc224e36714df573c7d6e01544. Is there a version or idea of this for EitherT?
14:36:53 <erisco> (NFData b, Unbox a, PrimMonad m) => (Vector a -> b) -> MVector (PrimState m) a -> m b
14:38:32 <jle`> codedmart: ExceptT has an Alternative instance, so you could probably do the same thing
14:38:43 <jle`> but the function is indeed written rather oddly
14:39:17 <erisco> so it is less general but not vulnerable to weirdness
14:39:39 <jle`> codedmart: i'd write fromMaybeT x y = maybe x return =<< y
14:39:51 <jle`> so you could do the same thing for ExceptT
14:40:01 <jle`> fromExcetpT x y = either (\_ -> x) return =<< y
14:40:16 <jle`> er that should be runMaybeT/runExceptT y in boht cases
14:40:33 <codedmart> jle`: I have a number of either's in case statements and wanted to do it for that.
14:40:48 <jle`> if you have bunches of EitherT's, you should asum them
14:40:56 <jle`> and then fromExceptT the end result
14:41:07 <jle`> asum :: [ExceptT e m a] -> ExceptT e m a
14:41:18 <jle`> and then you can fromExceptT x (asum ys)
14:41:39 <codedmart> Are EitherT and ExceptT interchangable?
14:42:08 <jle`> EitherT is from an esoteric library but ExceptT is in transformers and included with ghc
14:42:16 <jle`> but yes they're more or less identical
14:42:42 <jle`> sorry for calling your library esoteric Tekmo no hard feelings <3
14:43:02 <erisco> for some that'd be a compliment
14:43:32 <jle`> 'either' is a great library but almost all of its functionality has been re-absorbed into tesnformers
14:43:36 <jle`> *transformers
14:43:44 <jle`> i suppose that's the best fate you could hope for for your library?
14:44:00 <jle`> for its functionality to be absorbed into the standard/included libs?
14:44:09 <jle`> it was ahead of its time
14:44:11 <erisco> to be bought out by a mega library? pretty much
14:45:03 <codedmart> jle`: I guess I am missing something. This is what I was trying because the next either relies on the previous one -> https://gist.github.com/codedmart/bbb83d452fecf231e6e46b742b84f3c9
14:45:11 <jle`> 'either' has a bunch of neat little fairbairn-questionable combinators though
14:45:34 <jle`> utility functions
14:45:36 <jle`> on Either
14:45:38 <codedmart> But with this if one either fails the default Left I pass at the start is returned rather then the left of the fail.
14:46:15 <jle`> codedmart: yes because fromEitherT ignores the failure of the second argument
14:46:19 <jle`> what behavior did you want, really?
14:46:43 <jle`> if you want the failure of the second argument to be passed, why even use fromEitherT?
14:47:17 <jle`> all fromEitherT does is basically silence the second argument's error, heh.  that's basically its entire functionality
14:47:33 <codedmart> Trying to avoid case chains. I can do that with asum?
14:47:44 <jle`> can you write your program withb all of the cases
14:47:48 <jle`> so we know what you wnat?
14:47:56 <jle`> asum [x,y,z] = x <|> y <|> z
14:48:14 <jle`> but it's not exactly clear what you want, so just paste it with the cases, and we'll see what the best abstraction would be  :)
14:48:26 <codedmart> Sure thanks!
14:51:08 <erisco> λ Я us
14:52:54 <erisco> Vector has monadic folds… must be because of the laziness issue we were talking about then
14:53:14 <codedmart> jle`: https://gist.github.com/codedmart/bbb83d452fecf231e6e46b742b84f3c9#file-main-hs-L14-L19
14:53:28 <EvanR> its immutable, so it makes sense
14:53:33 <erisco> yes
14:53:50 <erisco> has anyone started the project to classify all the monadic variations?
14:53:56 <EvanR> it also has non monadic folds
14:54:10 <erisco> MFoldable and so forth
14:54:30 <EvanR> :t foldM
14:54:32 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:54:55 <EvanR> all Foldables are MFoldable
14:55:02 <erisco> apparently that one is already derivable
14:55:35 <erisco> MFunctor (a -> m b) -> f a -> m (f b)
14:56:40 <erisco> well you (and accidentally I) are looking at it the wrong way
14:56:51 <erisco> yes, all Foldable are MFoldable, it is that not all MFoldable are Foldable
14:57:10 <EvanR> :t sequence
14:57:12 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
14:57:53 <erisco> is sequence minimal?
14:59:17 <erisco> the monad is probably also a class parameter
14:59:24 <erisco> it is particularly so it can fit in with ST and ilk
15:01:41 <erisco> and we can all agree to use Identity everywhere so it is uniform
15:02:04 <erisco> Prelude 2020
15:04:21 <jle`> codedmart: i think i'd just do what you had before but handle the Left cases afterwards
15:04:40 <jle`> i posted a comment to the gist
15:05:13 <codedmart> jle`:  Ah ok fair enough. Thanks!
15:06:11 <jle`> (EitherT . return) is admittedly a bit awkward; kinda sad that there's no nicer way
15:06:21 <jle`> 'either throw return' works too if that's what floats your boat
15:07:21 <jle`> * either throwE return
15:08:46 <codedmart> I guess I was overcomplicateing it.
15:09:03 <jle`> it's very easy to overcomplicate things in haskell :)
15:09:09 <jle`> sometimes people make a sport out of it
15:09:21 <erisco> there's an abstraction for that
15:15:34 <EvanR> haha
15:16:06 <EvanR> erisco: an "abb"
15:27:36 <Gurkenglas> abbreviation?
15:29:04 <MarLinn> :t app -- I heard you like categories so I put categories into your categories
15:29:06 <lambdabot> ArrowApply a => a (a b c, b) c
16:04:29 * hackagebot quickcheck-special 0.1.0.1 - Edge cases and special values for QuickCheck Arbitrary instances  https://hackage.haskell.org/package/quickcheck-special-0.1.0.1 (minad)
16:04:31 * hackagebot console-style 0.0.2.1 - Styled console text output using ANSI escape sequences.  https://hackage.haskell.org/package/console-style-0.0.2.1 (minad)
16:04:33 * hackagebot wl-pprint-annotated 0.0.1.3 - Wadler/Leijen pretty printer with annotations and slightly modernized API  https://hackage.haskell.org/package/wl-pprint-annotated-0.0.1.3 (minad)
16:19:29 * hackagebot pipes-random 1.0.0.2 - Producers for handling randomness.  https://hackage.haskell.org/package/pipes-random-1.0.0.2 (fosskers)
16:24:30 * hackagebot morte 1.6.5 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.5 (GabrielGonzalez)
16:34:30 * hackagebot pipes-parse 3.0.8 - Parsing infrastructure for the pipes ecosystem  https://hackage.haskell.org/package/pipes-parse-3.0.8 (GabrielGonzalez)
16:39:30 * hackagebot pipes-concurrency 2.0.7 - Concurrency for the pipes ecosystem  https://hackage.haskell.org/package/pipes-concurrency-2.0.7 (GabrielGonzalez)
16:39:32 * hackagebot pipes-extras 1.0.8 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.8 (GabrielGonzalez)
16:45:43 <EvanR> nitrix: so, in your project you have abstracted away some kind of way to load resources and unload them?
16:45:48 <EvanR> is it purely functional
16:46:11 <mnn_> If the function passed to foldl is flipped, evaluation is still left associative, right? So the order of association I outlined at https://gist.github.com/mtn/b16b66a1397e326bc90ddcbcc65cfe2b is correct?
16:47:09 <mnn_> Oh wait, i think that's wrong
16:47:26 <EvanR> > foldl (-) 0 [1,2,3,4]
16:47:29 <lambdabot>  -10
16:47:33 <EvanR> > foldl subtract 0 [1,2,3,4]
16:47:35 <lambdabot>  2
16:47:54 <orzo>   when is foldl better than foldl' ?
16:48:01 <EvanR> nevar!
16:48:05 <mnn_> With the flip, you end up being right-associative, right?
16:48:11 <EvanR> no
16:48:33 <mnn_> Is the gist I posted incorrect? Arg order get's flipped though, I thought?
16:49:09 <EvanR> foldl's whole point is to left associate
16:49:20 <mnn_> So you end up with a left-associative structure, but when you remove the flip, you end up with a right-associative strucutre?
16:49:41 <EvanR> > foldl f 0 [1,2,3,4]
16:49:45 <lambdabot>  error:
16:49:45 <lambdabot>      Ambiguous occurrence ‘f’
16:49:45 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
16:49:46 <orzo> what do you mean by "the flip" ?  Are you refering to the apostrophe in foldl' ?
16:50:01 <EvanR> > foldl f x [y,z,w]
16:50:05 <lambdabot>  error:
16:50:05 <lambdabot>      Ambiguous occurrence ‘f’
16:50:05 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
16:50:12 <EvanR> ;_;
16:50:28 <mnn_> No, was referring to the gist I posted. And it turns out that it does make it right-associative. Here's the gist again if you want to see what I was referring to: https://gist.github.com/mtn/b16b66a1397e326bc90ddcbcc65cfe2b
16:50:30 <EvanR> orzo: they are talking about flipping the f
16:50:48 <mnn_> That's why foldl (flip (-)) 0 [1,2,3,4,5] == foldr (-) 0 [1,2,3,4,5]
16:51:23 <EvanR> its still not right associating
16:51:46 <EvanR> youll get the same performance issues with foldl and a flipped (-)
16:51:58 <EvanR> it will begin by building a huge thunk
16:53:07 <EvanR> also that equation is wrong
16:53:29 <nshepperd> > foldr (-) 0 [1, 2, 3, 4, 5]
16:53:31 <lambdabot>  3
16:53:49 <nshepperd> > foldl (subtract) 0 [1, 2, 3, 4, 5]
16:53:51 <lambdabot>  3
16:54:31 * hackagebot pipes 4.3.1 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.3.1 (GabrielGonzalez)
16:54:32 <EvanR> > foldr (-) 0 [1,2,3,4]
16:54:34 <lambdabot>  -2
16:54:40 <EvanR> > foldl subtract 0 [1,2,3,4]
16:54:42 <lambdabot>  2
16:54:46 <EvanR> so its wrong in general
16:56:13 <mnn_> EvanR, What I was saying was the computed result is the same if you flip f
16:56:28 <EvanR> its not true
16:56:39 <mnn_> > foldr (subtract) 0 [1,2,3,4]
16:56:41 <lambdabot>  -10
16:56:51 <mnn_> > foldl (flip subtract) 0 [1,2,3,4]
16:56:54 <lambdabot>  -10
16:57:27 <mnn_> EvanR, what am I missing?
16:58:21 <Koterpillar> > foldr const 0 [1,2,3,4]
16:58:23 <lambdabot>  1
16:58:25 <Koterpillar> > foldr (flip const) 0 [1,2,3,4]
16:58:28 <lambdabot>  0
16:59:00 <mnn_> > foldl (flip const) 0 [1,2,3,4]
16:59:01 <Koterpillar> > foldl (flip const) 0 [1,2,3,4]
16:59:02 <lambdabot>  4
16:59:04 <lambdabot>  4
16:59:17 <mnn_> Ah, I see
16:59:40 <EvanR> some tricky coincidences
16:59:53 <cloudhead> if a record is copied a thousand times but never modified, will it be allocated in memory more than once?
17:00:06 <EvanR> copied?
17:00:25 * EvanR having flashbacks to copy constructors in C++
17:00:31 <cloudhead> EvanR: well, stored in a map a thousand times for example :)
17:00:42 <cloudhead> since there is no way to pass things by reference
17:00:42 <EvanR> they will all be shared
17:00:53 <cloudhead> ah wonderful
17:00:57 <EvanR> well, if you do it right
17:01:01 <cloudhead> :/
17:01:07 <cloudhead> how could I do it wrong?
17:01:20 <EvanR> for example, create that map, then serialize it, then deserialize it
17:01:43 <cloudhead> ah I see, yeah that makes sense
17:02:26 <EvanR> when you use variables, thats "pass by reference"
17:02:40 <EvanR> not that any of this is visible to us
17:02:54 <cloudhead> hm right that makes sense
17:03:04 <cloudhead> so the only case there is a copy, is if one is modified
17:03:18 <EvanR> modifying records has to make a copy
17:03:40 <cloudhead> nod
17:03:43 <EvanR> but you could make a copy other ways
17:04:22 <clmg> sup
17:04:25 <EvanR> which actually might improve performance! see the copy operation in Data.ByteString
17:04:31 * hackagebot pipes-group 1.0.6 - Group streams into substreams  https://hackage.haskell.org/package/pipes-group-1.0.6 (GabrielGonzalez)
17:04:34 <cloudhead> :o
17:05:04 <cloudhead> ah yes, makes sense
17:09:31 * hackagebot pipes-safe 2.2.5 - Safety for the pipes ecosystem  https://hackage.haskell.org/package/pipes-safe-2.2.5 (GabrielGonzalez)
17:19:32 * hackagebot pipes-bytestring 2.1.4 - ByteString support for pipes  https://hackage.haskell.org/package/pipes-bytestring-2.1.4 (GabrielGonzalez)
17:31:08 <laudiacay> heya i need to work through a tutorial to get really really good at functor/monoid/monad/applicative/parsers/states because somehow my brain took a vacation for ALL those lectures. should I do RWH or LYAH for the best crash course?
17:32:43 <ahihi> I would do typeclassopedia
17:32:46 <MarcelineVQ> https://wiki.haskell.org/Typeclassopedia
17:32:52 <laudiacay> oh god i tried that it was hard
17:33:00 <laudiacay> will y'all hold my hand with stupid questions
17:35:27 <MarcelineVQ> probably :>
17:36:27 <pacak> laudiacay: Show us your questions and we'll decide if they are worthy to get an answer.
17:36:46 <hpc> laudiacay: LYAH for the first four is decent
17:36:53 <hpc> laudiacay: RWH for the last two is decent
17:37:05 <hpc> laudiacay: cis194 is also quite recommended
17:37:31 <hpc> there's also a wikibook that's not entirely straightforward to read but can help a bit
17:37:46 <hpc> and the typeclassopedia as mentioned, and some various other wiki pages
17:37:48 <Rembane> laudiacay: Stupid questions are the best!
17:38:10 <hpc> laudiacay: go with the combination of one or more that happens to work, as they all teach in slightly different ways
17:38:11 <Rembane> laudiacay: Oh. Staring at type signatures becomes educational after a while.
17:38:24 <laudiacay> hpc: cis194? 
17:38:31 <laudiacay> Rembane: yasss type sigs are my favorite things
17:38:36 <hpc> these sorts of concepts aren't always the most strictly orderable of things, so which works best depends on what you already know
17:38:40 <laudiacay> pacak: i will be back when i have a stupid question
17:38:40 <hpc> @where cis194
17:38:40 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
17:39:25 <laudiacay> hpc: i've been able to BS my way to 100% on every homework and lab through the "yell at the type sig until it works" method
17:39:35 <hpc> i also recommend whatever resource you pick, also reading the source for each of those things
17:39:36 <laudiacay> i'm in CS 161 at uchicago idk if that's a class that's known here
17:39:42 <laudiacay> oh true
17:39:44 <laudiacay> i will do this
17:39:51 <hpc> either it makes things more clear and you penetrate past all the bad metaphors
17:40:05 <hpc> or it doesn't make sense and you can go "well, at least i have the api to hide this crap"
17:40:08 <laudiacay> i love bad metaphors though
17:40:09 <laudiacay> lmao
17:40:11 <laudiacay> ok
17:40:14 <pacak> laudiacay: And remember - monads are like burritos.
17:41:06 <Rembane> laudiacay: When you become too fond of your type signatures, take a look at Control.Lenses.
17:41:22 <pacak> :t confusing
17:41:24 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
17:41:47 <hpc> i really hope that's built into lambdabot
17:41:58 <Tuplanolla> Is not.
17:42:09 <Tuplanolla> :t fusing -- It's the dual of this.
17:42:10 <lambdabot> Functor f => LensLike (Data.Functor.Yoneda.Yoneda f) s t a b -> LensLike f s t a b
17:42:28 <pacak> :t beside
17:42:30 <laudiacay> fstab!
17:42:30 <lambdabot> (Data.Bitraversable.Bitraversable r, Data.Profunctor.Rep.Representable q, Applicative (Data.Profunctor.Rep.Rep q), Applicative f) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f
17:42:30 <lambdabot> (r s s') (r t t') a b
17:42:33 <laudiacay> i know what that is!
17:43:30 <pacak> laudiacay: Yours is a one word. Those are 4 letters.
17:43:39 <laudiacay> pacak: that was a joke :)
17:43:43 <hpc> wow
17:43:47 <hpc> confusing is pretty legit
17:45:12 <hpc> someday edwardk is going to write a type that contains "LensLike i n c e p t i o n" and nobody will bat an eye
17:45:37 <geekosaur> (wait until ekmett appears with a LensLike for editing fstab files, including solaris vfstab, aix /etc/filesystems, and hp/ux :p )
17:45:47 <laudiacay> idek what a lenslike is
17:45:51 <laudiacay> but i'm afraid right now
17:45:57 <hpc> it's like a lens
17:46:10 <laudiacay> but what kind of burrito is it hpc 
17:46:18 <hpc> edwardk encodes his bad metaphors directly into code
17:46:34 <geekosaur> hpc: just as long as it's not another i m a s t a b u :p
17:48:02 <hpc> someday i will properly internalize that stuff...
17:48:25 <Rembane> laudiacay: A lens is a way to update the content of a burrito in an easy way.
17:48:48 * hpc . o O ( telescopic burritos )
17:49:09 <laudiacay> oh so it's like fmap with less pain
17:49:17 <geekosaur> (maybe that's why IBM is afraid of Haskell! [see -cafe])
17:49:18 <Rembane> laudiacay: Bingo!
17:49:22 <laudiacay> brb taking my laundry out 
17:49:24 <laudiacay> brb
17:49:28 <hodapp> IBM's afraid of Haskell?
17:49:37 <Rembane> laudiacay: Or... more pain. That's a bit unclear.
17:49:47 <Rembane> hpc: They compose really well I've heard.
17:49:48 <geekosaur> except that like anything else mathematical, it's easier in one way and harder in another :p
17:50:34 <Axman6> geekosaur: link?
17:50:42 <Rembane> It's like partial fraction expansion.
17:51:04 <geekosaur> https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125651.html
17:51:33 <hodapp> geekosaur: yay AI!
17:51:52 <Axman6> heh
18:02:05 <lpaste> Tuplanolla revised “Integer Roots”: “Integer Roots” at http://lpaste.net/348787
18:02:08 <Tuplanolla> Looking back at the integer root problem I considered previously, I was wondering what kind of algorithm would work best when overflows need to be considered.
18:03:36 <Tuplanolla> This one is just Newton--Raphson and the `m ^ p` is worrisome.
18:09:33 * hackagebot Frames 0.1.8 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.8 (AnthonyCowley)
18:12:39 <laudiacay> hey I don't really understand what const does?
18:12:51 <pacak> :t const
18:12:53 <lambdabot> a -> b -> a
18:13:00 <pacak> > const 1 2
18:13:03 <lambdabot>  1
18:13:07 <pacak> >const 1 100500
18:13:22 <systemfault> > map (const 9) [1..10]
18:13:22 <pacak> > const "this gets returned" "this does nothing"
18:13:30 <lambdabot>  mueval-core: Time limit exceeded
18:13:30 <lambdabot>  mueval: ExitFailure 1
18:13:30 <lambdabot>  mueval-core: Time limit exceeded
18:13:30 <lambdabot>  mueval: ExitFailure 1
18:13:38 <pacak> O_o
18:13:43 <MarcelineVQ> she's tired
18:13:46 <systemfault> My code was too complicated :/
18:13:52 <pacak> > const "this gets returned" "this does nothing"
18:13:58 <lambdabot>  "this gets returned"
18:14:01 <laudiacay> huh that's interesting
18:14:07 <systemfault> >map (const 9) [1..10]
18:14:18 <systemfault> Yup
18:14:24 <laudiacay> > map (const 0) [1..3]
18:14:27 <lambdabot>  [0,0,0]
18:14:33 <laudiacay> systemfault: it likes me better
18:14:36 <systemfault> :)
18:14:38 <laudiacay> :)
18:15:06 <laudiacay> that reminds me of either, like how if you have a Left, it just kinda chucks out anything on the Right when you combine them
18:23:10 <laudiacay> ok when I'm reimplementing functor, how do i get ghci to not complain about it
18:28:51 <MarcelineVQ> the class? you can    import Prelude hiding (Functor(..))      but you could also just give it a new name
18:29:25 <MarcelineVQ> class Functor' f where ...     class MyFunctor f where ...     etc
18:29:28 <laudiacay> oh true
18:29:32 <laudiacay> ok question though
18:29:49 <laudiacay> why is the implementation for ((->) a) (.) instead of fmap f a = a.f
18:30:02 <laudiacay> wait i'm dumb
18:30:04 <laudiacay> never mind
18:30:33 <laudiacay> of course you'd have to apply f second, otherwise you'd have the wrong types
18:53:29 <megaparsechelp> using megaparsec, `:t parseTest (char 'a')` is giving an error of `Could not deduce (ShowErrorComponent e0)`... I'm confused and don't know how to fix it.
18:54:03 <megaparsechelp> I thought that the Parser type synonm used Dec which has a default instance that satisfies ShowErrorComponent
18:56:02 <megaparsechelp> maybe I should switch back to Parsec for now since it doesn't show errors lol
18:57:02 <megaparsechelp> If anyone can help I will check logs later. Thanks in advance
18:58:26 <MarcelineVQ> it's just too vague, char could be a lot of different things, try    parseTest (char 'a' :: Parser Char) "hello"   with import Text.Megaparsec.String to bring Parser into scope
18:58:34 <MarcelineVQ> aaaannnd they're gone, already
19:04:07 <laudiacay> whats the difference between megaparsec and parsec? other than an order of 10^6
19:04:18 <laudiacay> but for real ive only ever used readp parsercombinators
19:04:21 <laudiacay> and that was pretty fun
19:04:33 <kadoban> laudiacay: megaparsec is maintained seems to be the main difference, AFAIK
19:04:40 <laudiacay> kadoban: lmao fantastic
19:08:23 <MarcelineVQ> there's some nice tutorials available for megaparsec when you want to give it a try, I really enjoy using it when I do
19:08:43 <Axman6> laudiacay: look at the docs, IIRC there's a lot of information about the reason for making something new
19:11:32 <codygman_work> MarcelineVQ: not gone, that was me on a laptop. I had to leave so signed in on phone.
19:22:22 <laudiacay> MarcelineVQ: whats the difference between that and like readp
19:22:58 <laudiacay> also... is your nick referring to adventure time?
19:23:26 <MarcelineVQ> dunno, I've not used ReadP directly and yes
19:23:54 <laudiacay> 10/10
19:42:47 <laudiacay> when would someone actually use void?
19:43:02 <laudiacay> like... why do you need to throw out values
19:43:38 <glguy> laudiacay: Suppose you wanted to make a function where the argument was an IO action that was expected to never return normally
19:43:45 <glguy> You could ask for an argument of type   IO Void
19:43:51 <laudiacay> maybe with like a monadic operation that returns a thing and you want f () as the normal type
19:43:58 <laudiacay> wait is Void just ()
19:44:01 <glguy> no
19:44:11 <laudiacay> I don't understand then :(
19:44:28 <glguy> Suppose you had a parameterized type (let's use Either) and you wanted to indicate that it was only a Right and not a Left, you could use Either Void a
19:44:38 <laudiacay> oh hmm
19:44:40 <glguy> an   IO Void action can't return normally
19:44:42 <laudiacay> why would you want that
19:45:10 <MarcelineVQ> did you mean Void or void?
19:45:22 <laudiacay> void is what I'm looking at right now
19:45:29 <laudiacay> but i'm kinda curious about Void too
19:46:02 <laudiacay> are they the same
19:46:12 <Hijiri> no
19:46:17 <Hijiri> void is used to convert IO a to IO ()
19:46:24 <laudiacay> oh okay that makes sens
19:46:30 <Hijiri> you use it when something like another function wants an IO () instead of your a
19:46:39 <Hijiri> or to make GHC not warn about unused result
19:46:48 <laudiacay> because IO a can have side effects, and you can just keep the side effects and throw out the returned bit
19:46:55 <Hijiri> yeah
19:47:05 <Hijiri> Void is a type with no elements except errors and nontermination
19:47:11 <laudiacay> oh cool
19:47:22 <Hijiri> if you ignore errors, you can use Void to prove something never returns
19:47:33 <laudiacay> what do you mean "prove"
19:47:38 <Hijiri> it's guaranteed
19:47:55 <laudiacay> hmm
19:47:56 <Hijiri> if it typechecks it means you never return (or you return an error)
19:48:03 <laudiacay> hmmmmm
19:48:05 <Hijiri> for example you might want to do exit :: Int -> IO Void
19:48:14 <Hijiri> since exit kills the program, it will never return
19:48:18 <laudiacay> oh and you give it an it and it goes "bye"
19:48:21 <laudiacay> *int
19:48:32 <glguy> Void shines in the "negative"/argument position of a function
19:48:36 <laudiacay> shines?
19:48:41 <glguy> as a result you can have: exit :: Int -> IO a
19:48:50 <laudiacay> oh okay
19:49:04 <laudiacay> haskell is really confusing im going back to the typeclassopedia
19:49:09 <laudiacay> how did you all get so good at this
19:49:16 <Welkin> by just doing it
19:49:22 <Hijiri> procrastinating other things
19:49:28 <laudiacay> after 3 months were you still as terrible as i am right now
19:49:53 <Welkin> yes
19:50:02 <Welkin> it took many months to become comfortable
19:50:28 <laudiacay> gradewise CS grad school looks likely, but lmao i don't understand what's going on how will i ever do productive research
19:50:39 <laudiacay> anyway, haskell
19:50:57 <Welkin> I don't do anything academic with it
19:51:01 <Welkin> I just build apps
19:51:07 <laudiacay> https://en.wikibooks.org/wiki/Haskell/Category_theory what is this
19:51:54 <laudiacay> Welkin: wait, there are legit companies that use haskell for things
19:52:24 <Hijiri> laudiacay: some, but not too many
19:52:45 <systemfault> Facebook uses Haskell...
19:52:48 <laudiacay> i thought it was a teaching language, but also kinda a toy in the sense that brainfuck is a toy... like "haha look at this i wrote a desktop manager in brainfuck haha memes i have no life"
19:52:55 <systemfault> That small company that nobody ever heard of...
19:52:59 <laudiacay> wait for real?
19:53:03 <systemfault> Yes.
19:53:08 <laudiacay> what are the benefits of it?
19:53:15 <systemfault> They SPAM filtering system is written in it
19:53:18 <systemfault> *Their
19:53:19 <laudiacay> I've only been exposed to the academic side like "here is a monad"
19:53:24 <MarcelineVQ> I've heard good things about brainfuck
19:53:25 <laudiacay> systemfault: why?
19:53:43 <laudiacay> MarcelineVQ: like, if screams of "IT HURTS" are good then sure
19:53:45 <Axman6> literally everything said or submitted is passed through a spam filtering system called Sigma, written in haskell
19:53:47 <Welkin> I build all of my web apps with it
19:53:53 <Axman6> on facebook*
19:53:54 <laudiacay> Welkin: /web/ apps????
19:53:58 <Welkin> yesod or servants
19:53:59 <laudiacay> in haskell??? how
19:54:01 <Welkin> servant*
19:54:13 <MarcelineVQ> maybe, "it hurts" also usually means "I'm learning" :>
19:54:24 <Axman6> laudiacay: by using one of the several web frameworks/libraries we have :\
19:54:32 <Welkin> laudiacay: http://www.yesodweb.com/
19:54:34 <laudiacay> MarcelineVQ: IIRC it was a whole lot of arithmetic with ascii
19:54:51 <Welkin> laudiacay: also, https://wiki.haskell.org/Web/Frameworks
19:54:51 <systemfault> Microsoft used Haskell for their "Bond" lib 
19:55:13 <Axman6> "here is a monad" is a long way from being academic. it's fundamental to all programming, not just in haskell
19:55:13 <laudiacay> Axman6: one of my coworkers said we should write our webserver in haskell, and I laughed at him and negotiated it down to ruby
19:55:28 <Axman6> laudiacay: you did the universe a disservice
19:55:36 <laudiacay> like i thought it was a joke, like "web design in asm" or something
19:55:42 <laudiacay> duuude haskell is pretty cool
19:55:47 <Axman6> my day job is basically writing webservices in haskell
19:56:05 <Welkin> haskell is the easiest language to use (and has the best frameworks) for web apps
19:56:08 <Welkin> by far
19:56:29 <laudiacay> Axman6: is there any, like, web services with their sources on github that you could send me?
19:56:32 <laudiacay> I'm super curious
19:56:46 <laudiacay> because rails is making me want to scream right now, yesod could be fun
19:57:07 <Welkin> yesod is great
19:57:17 <Welkin> for a simple web API, look into servant too http://haskell-servant.readthedocs.io/en/stable/
19:57:21 <Axman6> laudiacay: probably hundreds
19:57:35 <Welkin> although servant is a lot newer (so lacks some features you might find in yesod already)
19:58:01 <Axman6> servant isnt exactly beginner friendly, but it offers so much power it's the only tool I can even think of writing web services in these days
19:58:22 <Axman6> servant and yesod don't really target the same domains
19:58:30 <systemfault> servant looked more accessible to me than yesod :/ (I'm still a beginner)
19:58:32 <laudiacay> so back to the facebook thing, why would you write a spam blocker in haskell? as a dumb freshman in college, my approach would be make a giant neural net and train it with a bunch of spam and not-spam content
19:58:45 <laudiacay> and my intuition would be to not do that in haskell
19:58:49 <Welkin> systemfault: they are for different use cases really
20:01:39 <laudiacay> also, back to category theory, if categories are sorta like types, and morphisms are functions within that category.... how do you go from category to category? Like if i want my function to go Int -> String, how does that fit into category theoretic explanations of haskell's typesystem?
20:02:18 <Axman6> systemfault: it is until you hit a type error :)
20:02:19 <laudiacay> also is Grp a category of morphisms what is this
20:02:42 <laudiacay> oh wait, * and . are the group operations, I'm being dumb ignore me
20:03:12 <Axman6> laudiacay: Sigma, the facebook spam filtering system, uses dozens of different sources of information to process rules about what looks like spam. they've given a few talks about it
20:03:51 <laudiacay> oh gosh this is no good I have about 9 hours of various engineering talks queued up now and like 3 exams to study for
20:03:55 <laudiacay> thanks though
20:04:33 <Welkin> just go play wow instead
20:04:37 * hackagebot pipes-text 0.0.2.5 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.5 (MichaelThompson)
20:08:22 <laudiacay> should i ask what a thunk is
20:08:28 <laudiacay> or will it hopelessly confuse me
20:08:44 <Jackoe> wait, I think I can help
20:09:23 <Jackoe> Are you looking for a general explanation or a very specific one?
20:09:25 <Welkin> an unevaluated expression
20:09:30 <laudiacay> oh okay
20:09:33 <Jackoe> ^
20:09:37 <Welkin> you pretend it was evaluated until you need it
20:09:47 <Welkin> it only *actually* gets evaluated when you need it
20:09:59 <laudiacay> I'm looking at the facebook sigma bug where backslashes in JSON files were making giant chains of thunks
20:10:04 <laudiacay> why are thunks so expensive
20:10:13 <c_wraith> they are allocated on the heap
20:10:13 <Welkin> they are stored in memory
20:10:28 <laudiacay> oh no that is no bueno
20:10:35 <laudiacay> probably fast but also
20:10:41 <laudiacay> okay
20:10:46 <laudiacay> cool time to read more sigma
20:14:20 <Axman6> laudiacay: if you write let x = 1 + 1, x will be a thunk pointing to the code needed to execute 1 + 1 until it is actually evaluated by something, after which x will be 2
20:29:35 <laudiacay> ohh okay thanks Axman6 
20:29:53 <laudiacay> also wow i found useful haskell while digging around ML stuff https://appliedgo.net/perceptron/
20:30:01 <laudiacay> wait jk this is not haskell
20:30:04 <laudiacay> i am silly
20:30:23 <c_wraith> the domain name did hint at that. :)
20:35:35 <jle`> laudiacay: http://blog.ezyang.com/2011/04/the-haskell-heap/
20:36:11 <laudiacay> c_wraith: i saw "type" then a capital letter
20:37:15 <laudiacay> jle`: this is adorable who wrote it
20:37:40 <c_wraith> laudiacay: unsurprisingly, ezyang did.  :P
20:38:05 <jle`> ezyang, one of the chief contributers of ghc
20:38:09 <laudiacay> oh that's a person
20:38:16 <c_wraith> Edward Z. Yang
20:38:18 <laudiacay> this is the cutest thing omg
20:41:31 <laudiacay> "Ghost-o-matic" this is the happiest i have even been while studying
20:44:21 <c_wraith> that's high praise.
20:55:41 <krae> started learining haskell using the lyah guide
20:55:53 <krae> s/learining/learning
20:56:21 <krae> the list comprehension section is complicated
20:57:50 <laudiacay> krae: i remember that
20:58:33 <laudiacay> tl;dr, ignore all the stupid things with [1.whatever.whatever]
20:59:00 <laudiacay> focus on the [f y | y <- whatever]
20:59:08 <krae> yeah
20:59:19 <laudiacay> all you need to know from the first one is like [1..10] and you can randomly google the rest
20:59:29 <krae> yeah
20:59:48 <krae> my local library has no haskell reference books
21:00:00 <laudiacay> google has haskell reference books
21:00:30 <krae> it's a little discouraging that i'm learning it for just for funsies
21:00:49 <krae> i don't always have internet access though
21:00:54 <laudiacay> oh that's no fun
21:01:12 <laudiacay> i think there are copies of LYAH and RWH in PDF form floating around the internet
21:01:20 <krae> yeah
21:02:36 <krae> i wish there were more occupations where functional languages are important
21:02:54 <jle`> how about software engineer
21:02:59 <jle`> scientist
21:03:10 <jle`> quantative analyst
21:03:14 <laudiacay> we just had a discussion in here about "wow is haskell useless" and everyone kinda dogpiled me with haskell applications
21:03:21 <laudiacay> facebook's sigma is REALLY COOL
21:03:29 <krae> yeah
21:03:51 <jle`> most occupations where programming/computers is useful is an occupation where functional languages are important
21:03:53 <krae> c++ seems to be the way to go for apps these days
21:04:31 <laudiacay> i am on hour two of diversion from homework. I am sorta stuck up a tree of opened wikipedia pages involving like random math conjectures, thunks, and back propagation thanks to that discussion
21:04:59 <krae> homework on a friday?
21:05:11 <laudiacay> krae: some dude in here was talking about how they write webapps with yesod
21:05:14 <laudiacay> and yeah finals next week
21:05:21 <krae> same here
21:05:29 <laudiacay> haskell is my homework though, so it's alright. 
21:06:13 <krae> heh
21:07:09 <Axman6> laudiacay: also, if you still feel Haskell is useless, I hope you don't have any money in Barclay's or Standard Chartered banks, they have huge amounts of Haskell
21:07:48 <krae> there's always an exception
21:08:16 <krae> people drive reliant robins, don't they
21:08:25 <laudiacay> Axman6: i dontttt i was wronggggggg
21:08:44 <Axman6> well, we can find more examples in case you forget that fact ;)
21:08:45 <jchia_> lens question. What's a useful way to think of composing Getting? E.g. How do I make something like the following code work and result in ('a', 'b')?
21:08:45 <jchia_> ('a','b','c') ^. ((,) <$> _1 <*> _2)
21:08:46 <laudiacay> i just didnt know people used it and i am very happy that people use it
21:09:17 <jle`> jchia_: there's an example in the lens docs i think
21:09:43 <laudiacay> that is not very readable
21:09:48 <jle`> oh the example combines things into a list
21:09:53 <jle`> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Getter.html
21:09:55 <jle`> hm
21:10:20 <Axman6> I think they're monoidal, but can't remember how to use that to combine them >_<
21:10:22 <krae> i like pure functional languages better than standard ones, but there isn't much of a reason to learn them
21:10:44 <jle`> how about any reason you would want to program anything?
21:10:48 <jle`> it applies to haskell too :)
21:11:00 <Axman6> :t \f -> f <$> _1 <*> _2
21:11:02 <lambdabot> (Field1 s t a b1, Field2 s1 t1 a b1, Functor f) => ((s -> f t) -> (s1 -> f t1) -> b) -> (a -> f b1) -> b
21:11:12 <jle`> any reason why you'd want to programming something in C++, Java, javacsript, php, etc. is also a reason why you'd program haskell
21:11:15 <krae> if you already know C, you might as well use it
21:11:16 <jle`> *use haskell
21:11:19 <Axman6> :t  (,) <$> _1 <*> _2
21:11:21 <lambdabot> (Field1 s t a b, Field2 s1 t1 a b, Functor f) => (a -> f b) -> (s -> f t, s1 -> f t1)
21:11:22 <laudiacay> krae: prepare to get yelled at
21:11:34 <jle`> krae: sure, but haskell offers a lot of advantages over C
21:11:38 <jle`> does that count as a reason to learn it?
21:11:48 <Axman6> krae: if you already know dirt, why cut down a tree?
21:12:02 <jle`> there isn't a reason to learn how to drive because you can already walk ~
21:12:11 <Axman6> if we have tubes, why bother with silicon?
21:12:13 <krae> do companies look for haskell programmers?
21:12:13 <jle`> what's the point of learning how to drive? :)
21:12:22 <jle`> yes :O
21:12:34 <Rotaerk> not as many as other languages for sure :P
21:12:42 <Axman6> krae: yes, it's often seen as a huge positive indicator when hiring
21:12:48 <Rotaerk> but since when is "do companies look for X?" the primary concern for your decision to learn something
21:13:03 <laudiacay> does anyone here do machine learning in haskell tho because my winter break is going to be an ML binge
21:13:26 <Axman6> laudiacay: google do, they have a wrapper for tensorflow in haskell
21:13:27 <jle`> laudiacay: check out http://datahaskell.github.io :)
21:13:43 <krae> all the machine learning/neural network stuff i've seen has been in python, c
21:13:59 <jle`> "i would want to learn how to cook a meal, but i don't think any companies look for meal cooking"
21:14:13 <Axman6> I think you mean, in C/C++ and glued together with pytoin ;)
21:14:34 <Axman6> :t _1 <> _2
21:14:37 <lambdabot> (Field1 s t a b, Field2 s t a b, Monoid (f t), Functor f) => (a -> f b) -> s -> f t
21:14:43 <laudiacay> ^^ literally most ML ive seen is either that, lua, or go
21:14:47 <krae> no one succesful has ever taken the time to learn any language besides the main oens
21:14:49 <krae> ones
21:15:01 <laudiacay> krae: false?
21:15:01 <Rotaerk> how do you know that?
21:15:02 <Axman6> lolwut?
21:15:09 <Axman6> have you not been listening?
21:15:19 <krae> torvalds wrote the linux kernel in c
21:15:38 <Axman6> heh, we're going to start with Linus as a successful person?
21:15:43 <jle`> if i can name one successful person, would you believe that you are wrong? :)
21:15:51 <krae> all proprietary software is written in c
21:15:56 <krae> aka 
21:15:57 <Axman6> jle`: no, you would have roved them wrong :P
21:16:03 <krae> all software that makes money
21:16:12 <jle`> there is plenty of software that makes money that is not written in C
21:16:19 <Rotaerk> hmm, my company doesn't use much C, and it relies on the software to make money
21:16:26 <Rotaerk> doesn't use haskell, but not C either
21:16:29 <Axman6> huh, better tell facebook, and standard chartered bank, and jane street capital and ...
21:16:46 <jle`> there is probably more money-making software written not in C than written in C
21:16:55 <jle`> C is in the minority of langauges used for money-making software
21:17:05 <Axman6> i mean, maybe you could argue that filtering all spam on facebook isn't making them money?
21:17:21 <jle`> maybe, but i still think my claim still stands
21:17:23 <Rotaerk> C isn't even the most popular language
21:17:24 <Axman6> or, perhaps directly literally making money through trading isn't making money?
21:17:28 <orzo> I'm building a web service intended to interface with an in-browser user interface client.  The server will be in haskell.  Should I consider writing the client in haskell?  With ghcjs?  Or am I better off just using html/javascript for the client?
21:17:46 <Rotaerk> at least according to the tiobe index, Java is way above C in popularity
21:18:21 <laudiacay> augh java
21:18:22 <Axman6> orzo: if you happen to be using servant for the server, you can auto generate the client libraries for JS (including variants for jquery, angular and a few others)
21:18:26 <laudiacay> java hurt me as a child
21:18:33 <laudiacay> the generics refusing to work with primitives
21:18:35 <laudiacay> augh
21:19:07 <laudiacay> haskell has a sane type system praise be
21:21:02 <Axman6> looks like some of krae's C based software failed :(
21:21:38 <laudiacay> i think y'all scared him off
21:22:02 <Axman6> nah network timeout, must've lost their connection
21:22:14 <laudiacay> is there an OS written in haskell
21:22:21 <laudiacay> is there an IRC client in haskell
21:22:27 <Rotaerk> pfft, who would do that; haskell is useless
21:22:38 <Axman6> despite that, yes to both
21:22:47 <laudiacay> omg how does the OS work
21:22:47 <systemfault> Haskell is useless, SPJ said so :P
21:23:15 <laudiacay> ooh i should write a haskell irc client
21:23:18 <glguy> HaLVM runs on Xen, and there was the House project
21:23:38 <Axman6> glguy: your using your haskell irc client at the moment aren't you?
21:23:42 <glguy> Yeah
21:23:51 <riaqn> Hi, can I register a hook on a variable such that, when the data is GCed, the hook is executed?
21:23:52 <Axman6> care to show it off? :)
21:24:01 <laudiacay> omg HaLVM is so cute
21:24:01 <jle`> yes
21:24:05 <jle`> you can
21:24:21 <laudiacay> glguy: screenshots!!!
21:24:26 <jchia_> So, regarding the ('a','b','c') ^. ((,) <$> _1 <*> _2) I mentioned earlier, I don't necessarily have to use lens. Is there simpler way to express \(a, b, c) -> (a, b)?
21:24:38 <riaqn> the problem is that, I have a function newXX :: Config -> IO (XX), which forks a new thread.
21:24:56 <riaqn> so I hope that when XX is GCed, the thread can be cancelled too.
21:25:12 <laudiacay> jchia_: i feel like no, because those are 2 different tuple constructor things
21:25:20 <Axman6> that seems like not the world's nicest design
21:25:27 <laudiacay> like one's (,,) a b c and the other's (,) a b
21:25:38 <glguy> Here's some recent shots: http://imgur.com/a/fM6aN
21:25:47 <riaqn> Axman6: while the nicest design is?
21:25:58 <laudiacay> glguy: is that solarized?
21:26:03 <glguy> yeah
21:26:07 <laudiacay> pretty
21:26:19 <Axman6> glguy: show us some code (here)
21:26:25 <laudiacay> i like my weechat for now... but eventually i'll write one
21:26:31 <Axman6> that's always been my favourite feature :)
21:26:32 <riaqn> Axman6: I guess you mean a data structure recording the thread id, and an explicit function deleteXX :: X -> IO ()  to cancel the thread?
21:26:48 <Axman6> that may be better yes
21:27:08 <riaqn> Axman6: that's ok, but I was just wondering if there's any clever approach.
21:27:14 <glguy> https://hackage.haskell.org/package/glirc https://github.com/glguy/irc-core
21:27:16 <riaqn> jle`: sorry, were you talking to me?
21:27:46 <Axman6> glguy: I meant the syntax highlighting when you send haskell
21:28:04 <glguy> Oh, I ended up taking that out.
21:28:14 <Axman6> D:
21:29:21 <Rotaerk> what do you mean by "dynamic views into the model of your IRC connections"?
21:30:00 <Rotaerk> I'm planning on building my own IRC client in haskell
21:30:09 <glguy> Different views of the data don't pollute your chat windows, you can search, filter, view ban lists without screwing up the chat window
21:30:15 <Rotaerk> ah
21:30:18 <glguy> some clients will dump the ban list into the chat window, for example
21:30:24 <glguy> and how your scrollback is ruined
21:30:25 <Rotaerk> k
21:30:28 <glguy> or filtering is after the fact
21:31:11 <Axman6> yeah I hate that about irssi
21:38:07 <laudiacay> ~~weechat~~
21:39:31 <orzo> Thanks, Axman6.  I can/will probably use servant.
21:41:29 <orzo> I'm seeing a lot of ghc-pkg: unable to decommit memory: Invalid argument when i install haskell packages
21:41:37 <orzo> should that concern me?
21:42:31 <laudiacay> sounds like memory leaks but idk 
21:44:17 <glguy> orzo: Do some Googling, there's tickets out there about it
21:44:37 <orzo> i saw a there was a ticket about it for nixos
21:44:42 <orzo> i'm using debian
21:46:31 <glguy> That's fine
22:09:30 <orzo> glguy: https://ghc.haskell.org/trac/ghc/ticket/12865 indicates it is because i'm using an older kernel than was used to build my binaries.  Does this mean that haskell programs wont free heap memory at all if I don't upgrade my kernel?
22:09:58 <orzo> i cant really tell how severe this is
22:11:24 <glguy> That's possible; I don't actually know what the consequences are.
22:12:05 <Axman6> its not really a huge issue, iirc the old behaviour basically meant that your app would never decrease in memory usage, but it won't necessarilly continue to grow, it reuses the memory it has
22:13:05 <orzo> that sounds like a pretty bad issue to me
22:30:15 <mikeplus32> k
22:30:24 <mikeplus32> oops
23:39:45 * hackagebot x509 1.6.5 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.5 (VincentHanquez)
23:54:50 <ashishnegi> hi.. i am trying to memory profile haskell code and it is 3 rd day.. but i have not got much success..
23:55:19 <ashishnegi> i am reading 1 million ints (8 MB) and making a Map Int [Int] out of it.. where list will have at max 4 ints..
23:56:19 <ashishnegi> this is the code : https://github.com/ashishnegi/hsalgos/blob/master/src/LongestEdgePathInDAG.hs#L96
23:57:50 <ashishnegi> i have taken some graphs with smaller data set 10^4 ints.. https://github.com/ashishnegi/hsalgos/tree/master/profs/100
