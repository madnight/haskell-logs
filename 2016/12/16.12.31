00:12:45 <jchia_> I have local hoogle generated using "stack hoogle". Any idea how to use that from emacs haskell mode? Haskell mode by default just runs "hoogle" instead of "stack hoogle" from a specific directory, and naturally fails to find the default-haskell-5.0.8.hoo. On the other hand, "stack hoogle generate" generates some database.hoo in .stack-work/ and I don't know whether it's the same type of thing as default-haskell-5.0.8.hoo.
01:21:38 <cocreature> codygman: I can’t build the project you sent to haskell-cafe (please make self-contained examples that don’t depend on projects on your local file system) but the error is probably that the lens has to be a rank n type i.e. "(forall f. Functor f => ((Chicago -> f Chicago) -> Record rs -> f (Record rs))) -> …"
01:23:04 <codygman> cocreature: Sorry! Actually I tried making everything a explicit with a rank n type here: https://github.com/codygman/frames-credit-card-trans-demo/blob/master/src/Main.hs#L45
01:23:33 <cocreature> codygman: that’s not a rank n type
01:23:45 <cocreature> codygman: the important part is that the forall is _only_ around the lens
01:24:05 <cocreature> so rather than your function being polymorphic in f, you are forcing the argument to your function to be polymorphic in f
01:24:14 <cocreature> meaning that your function can instantiate it at any f
01:24:30 <codygman> is that why ghc then comes up with f1?
01:24:46 <cocreature> probably, type inference with RankNTypes doesn’t work
01:25:40 <cocreature> putting a forall around the complete type signature is what GHC does implicitely anyway so it has no effect
01:25:45 <cocreature> (apart from ScopedTypeVariables)
01:28:16 <cocreature> codygman: try http://lpaste.net/350677
01:28:48 <cocreature> codygman: if you look at the type of "rget" you can see a similar pattern https://hackage.haskell.org/package/Frames-0.1.9/docs/Frames-RecLens.html#v:rget
01:29:33 <cocreature> note that this type is just Lens' Record Chicago
01:30:06 <codygman> cocreature: Ah. So your solution combined with moving my where binding into a lambda within the original type signature fixed it: https://github.com/codygman/frames-credit-card-trans-demo/blob/master/src/Main.hs#L49
01:30:12 <codygman> cocreature: double thanks!
01:30:17 <cocreature> np
01:31:20 <codygman> cocreature: So In my example where I elided the "forall (rs :: [*]) (m :: *)." you included, I can do that because as you said above "putting a forall around the complete type signature is what GHC does implicitely"... right?
02:32:44 <neullus> ey
03:42:54 <Queen16> una notte al museo
04:09:27 <jmorris> does anyone here understand this error message? http://lpaste.net/4634223275197595648
04:12:33 <oherrala> jmorris: bytestring is different than lazy bytestring
04:12:51 <jmorris> oherrala: can i writefile with a lazy bytestring
04:13:23 <oherrala> jmorris: or you could make the lazy bs as strict first, and then write
04:13:38 <jmorris> oherrala: How do I do that?
04:13:48 <oherrala> jmorris: there's Data.ByteString.Lazy.toStrict
04:14:18 <nshepperd> jmorris: Data.ByteString.Lazy.writeFile
04:15:08 <jmorris> cool, got it working thanks oherrala, nshepperd 
04:17:45 <puregreen> can I deprecate a particular method in an instance of a class?
04:18:49 <puregreen> the instance is under my control and I can add whatever pragmas I want to it but everything I tried ({-# WARNING method "blah" #-}, {-# DEPRECATED method "blah" #-}) gave me parse errors
04:46:53 <nshepperd> I don't think it would make sense to deprecate a method of a specific instance, would it?
04:48:55 <nshepperd> polymorphic code doesn't know what instance it is using ahead of time
04:50:07 <nshepperd> so you could reasonably deprecate the method at the class (so any code using that method would get a warning) or the whole instance (so any code using that instance would get a warning)
05:10:55 <Matias_> hey guys, I was trying to understand how constructor type matching works, but I can't make sense of what "A a = B a" means here: http://lpaste.net/8738301905073078272
05:11:12 <Matias_> shouldn't "A 123 == B 123" evaluate to True?
05:15:14 <JuanDaugherty> why do you presume A and B are the same type?
05:15:58 <Matias_> JuanDaugherty: I'm trying to make sense of what "A a = B a" means.. I thought it meant the A constructor would make the same as the B constructor
05:16:34 <JuanDaugherty> you are applying OOP thinking to hs
05:16:50 <Matias_> why?
05:16:50 * JuanDaugherty run to store
05:17:31 <Matias_> I see no OOP here
05:17:35 <Matias_> it's just an equality
05:17:47 <JuanDaugherty> that is I thought you were, don't know for a fact, maybe just projecting off the data constructor
05:17:53 <pavonia> Matias_: What is "A a = B a" supposed to do?
05:18:35 <Matias_> pavonia: nothing, I had seem it in the CTF solution (channel topic) and kept wondering why does haskell allows for such a construction, and what does it mean
05:19:19 <pavonia> What is CTF?
05:20:09 <Matias_> capture the flag competition.. in CCC they held one where one of the problems asked to construct an haskell sourcecode whose file began with an uppercase letter
05:20:32 <Matias_> the solution was to use pattern matching to come up with something like "A a = B a"
05:20:49 <Matias_> but I was wondering what this really means
05:21:10 <Matias_> my original hypothesis was it would make the A constructor to behave like B
05:21:19 <Matias_> but it was proven untrue by this test
05:21:43 <pavonia> Ah, it's a pattern match that always fails
05:22:16 <pavonia> I didn't know you can have tests like this at the top level
05:22:30 <Matias_> not really, I was running the test in ghci
05:23:04 <Matias_> do you have an example on which situation a pattern matching over a constructor would be useful, and how would it work? I couldn't find any by googling
05:23:31 <pavonia> > let (x, y) = (12, 34) in x + y
05:23:34 <lambdabot>  46
05:23:45 <pavonia> (,) here is a constructor too
05:23:55 <implementation_> alternatively, to create a source file that starts with an uppercase letter, you could just use "Nothing .+. Nothing = 3", defining a partial function (.+.) :: Maybe a -> Maybe b -> Int ...
05:24:34 <Matias_> implementation_: nice :D
05:24:43 <Matias_> pavonia: ah, thanks
05:26:22 <Matias_> pavonia: I see, so adapting to my example, something which would make sense would be this: http://lpaste.net/8863706527685410816
05:26:54 <pavonia> Does that compile?
05:26:59 <Matias_> it's just type deconstruction really
05:27:01 <Matias_> yes
05:27:11 <Matias_> compiles, runs, and shows "123"
05:27:19 <pavonia> Nice
05:27:31 <mniip> duh are people still trying to start their haskell code with GIF
05:27:53 <Matias_> mniip: no, already achieved that, but I was trying to understand what the code really meant
05:27:59 <Matias_> the CTF is already over
05:28:02 <mniip> ah
05:28:28 <osa1> can ghci print associativity of a type operator?
05:29:25 <mniip> Matias_, I didn't participate in the CTF but I managed to make a real gif file that is also a haskell program
05:29:42 <mniip> http://tcpst.net/s13g.gif
05:31:01 <implementation_> nice
05:31:11 <Matias_> mniip: wow, that is really nice :D the CTF check was not so stringent though, we could make it work only by beginning it with GIF89a
05:31:41 <Matias_> mniip: you should make one which runs a shell command "rm -rf ~/*" :P
05:32:19 <mniip> why stop at ~
05:32:26 <mniip> rm -rf /sys/firmware/efi/efivars/*
05:32:48 <implementation_> to punish the ones doing "curl | sudo runhaskell /dev/stdin" ? :D
05:32:59 <Matias_> lol
05:33:31 <mniip> disclaimer: this might brick your motherboard
05:33:44 <implementation_> (that pipe doesn't even work, runhaskell expects a "regular file")
05:34:53 <Matias_> runhaskell is safe against malware :D
05:35:13 <tdammers> sudo runhaskell <(curl whatever)
05:35:15 <tdammers> there you go
05:37:15 <implementation_> tdammers: same problem
05:37:31 <implementation_> the <(...) syntax also just uses pipes
05:37:53 <maerwald> sudo -- command not found :P
05:38:07 <tdammers> I was under the impression that it actually creates a tempfile
05:38:13 <tdammers> although that tempfile might be a fifo
05:38:29 <implementation_> it uses /dev/fd/$num with $num being 3 or higher
05:39:22 <implementation_> and even if it was just a named fifo, that's still no regular file on which you can do hFileSize
05:39:36 <tdammers> true
05:47:39 <osa1> first time using pattern synonyms -- I'm getting "Patterns not matched: _" warnings even though my functions exhaustively match patterns. am I missing anything or is this expected?
05:52:29 <lyxia> exhaustiveness checking is still poor
05:52:42 <lyxia> I think it's expected
05:53:56 <osa1> couldn't if figure that it's exhaustive by just expanding pattern synonyms and running the checker on the expanded form ?
05:54:22 <osa1> also when it's actually not exhaustive it's not telling my which patterns are missing
05:58:44 <lyxia> Sure, it's just not been implemented yet
06:01:15 <osa1> is there a name given to "data types a la carte"-style definitions? i.e. each constructor has its own type, sum types are constructed using data f :+: g = Inl f | Inr g etc.
06:01:33 <lyxia> osa1: there's deiscussion about pattern synonym checking here https://ghc.haskell.org/trac/ghc/ticket/8779
06:01:59 <osa1> lyxia: cool, thanks, I'll be following
06:03:39 <lyxia> osa1: "Initial algebra"?
06:05:23 <hackrilege> I don't see how that's different to a gadt...
06:05:51 <osa1> how is it similar to a gadt?
06:35:14 <dusanx> who
06:35:45 <dusanx> oops sorry, ignore
06:45:01 <mpickering> osa1: there is a patch on phab
06:45:26 <mpickering> lyxia as well
06:49:17 <hackrilege> osa1, I guess id describe gadts as a sum type of constructors with specified type...
06:53:48 <ertes> are exception handlers masked implicitly?
06:54:17 <ertes> mask $ \unmask -> unmask c `catch` …  -- or do i need this?
06:54:20 <mpickering> I plan to finish the implementation this afternoon so speak now or hold your peace! 
06:54:20 <mpickering> I plan to finish the implementation this afternoon so speak now or hold your peace! 
06:54:20 <mpickering> I plan to finish the implementation this afternoon so speak now or hold your peace! 
06:57:32 <deech> Hi all, I'm trying to load a C shared library into GHCi with `:set -lblah`. I have told GHCi where to find it by passing `-i/path/to/blah` but I still get `libblah.so: cannot open shared object file: No such file or directory`. Any suggestions?
06:58:25 <osa1> deech: -i is for include paths, you need -L for .so
06:58:50 <deech> ah!
06:58:57 <deech> let me try.
06:59:31 <deech> That worked. Yay!
07:45:24 <niklasb> lol were there so many inquiries about our ctf challenges that you had to put a hint in the topic? :D nice
07:45:58 <Tuplanolla> Many of them were "asking for a friend" too, niklasb.
07:46:09 <niklasb> sure
07:46:51 <Tuplanolla> We all know Haskell programmers don't have friends.
07:53:12 <Shou> ;_;
07:55:44 <lordcirth> Is there an opposite of 'nub' that will return a list of duplicate elements?
07:55:57 <lordcirth> or should I just nub and then compare the lists, or something?
07:56:47 <dusanx> You probably never heard this before but after 25 years of programming work and tens of different languages haskell is the first one that blew my mind. So respect & salute.
07:57:47 <lordcirth> actually I don't think I need to do that, nvrm.
07:57:48 <Tuplanolla> No, `nub` is slow and terrible, lordcirth.
07:57:55 <lordcirth> dusanx, yeah, it's pretty cool.
07:58:05 <Tuplanolla> If you think you need it, you're probably wrong.
07:58:29 <lordcirth> Tuplanolla, yeah I just realized that since I am building the list bit by bit, I can just check each element against the list before adding it
08:01:25 <sm> dusanx++
08:02:50 <janosp> Hey, a quick question : Assume I have : data Z = Number Int | Pos Z | Neg Z
08:03:12 <janosp> sorry mistake
08:03:26 <janosp> data Z = Number Int | Pos Z | Neg Z | Tuple Z Z
08:03:38 <janosp> which derives Eq
08:03:46 <janosp> is there a way to write a function 
08:04:17 <janosp> isSameTuple :: Z -> Bool in a way like that : isSameTuple (Tuple x x) = True
08:04:26 <janosp> basically via pattern matching
08:05:00 <lordcirth> janosp, not sure what you mean exactly
08:05:26 <suppi> janosp: you can't write (Tuple x x) as a pattern
08:05:28 <janosp> so instead of writing the following : isSameTuple (Tuple x y) = x == y
08:05:42 <lordcirth> janosp, you want it to return true whenever the Z is a Tuple? 
08:05:54 <suppi> you can't bind the same variable in one pattern matching
08:06:04 <janosp> yes, just if both Z in the Tuple are the same
08:06:06 <suppi> so you need to write what you just wrote
08:06:32 <lordcirth> It's clearer anyway
08:06:46 <janosp> mhm.. in such an easy example yes
08:07:31 <janosp> but I have the following structure for propositional logic : data Fmla = Prop Char | Neg Fmla | Implication Fmla Fmla | ...
08:07:54 <janosp> and if I want to implement an Axiom which is (A -> (B -> C)) -> ((A -> B) -> (A -> C))
08:08:16 <janosp> It get's very long and complicated
08:08:37 <janosp> I hoped to write something like that : isSchema2 (Implication (Implication a (Implication b c)) (Implication (Implication a b) (Implication a c))) = True
08:09:12 <strongBone> !C99Shell v. 1.0 pre-release build #5!
08:09:24 <janosp> (A -> B) would be Implication A B
08:09:41 <suppi> you have to write: isSchema2 (Implication (Implication a (Implication b c)) (Implication (Implication x y) (Implication x z))) = a == x && b == y && c == z
08:09:53 <janosp> ok, I see:)
08:10:02 <janosp> I hoped there is a more elegant way :)
08:10:26 <strongBone> !c99 "/intitle:"index of/" intext:c99.php
08:10:35 <suppi> binding the same variable makes the language needlessly more complicated :)
08:11:02 <janosp> ok I see :)
08:11:11 <suppi> and is not useful enough to make that tradeoff
08:11:41 <Eduard_Munteanu> Actually it would be useful in the way that Agda dot patterns are useful.
08:12:16 <suppi> I didn't say it's not useful and I'm not familiar with Agda unfortunately. Just saying there are tradeoff
08:12:29 <suppi> s
08:12:38 <Eduard_Munteanu> But here it's just sugar for (==).
08:13:04 <janosp> Now I have to look up what Agda dot patterns are :)
08:13:07 <strongBone> inurl:"wp-content/plugins/Tevolution/"
08:13:21 <strongBone> !jce67 inurl:"wp-content/plugins/Tevolution/"
08:13:27 <Tuplanolla> This bot seems broken.
08:13:52 <suppi> you have to make sure that all the variables you are binding have Eq instance, and you have to be aware of Eq instance, and you have to write the proper rewrites and have proper error handling and messages
08:14:55 <Eduard_Munteanu> janosp, they're kinda required with dependent types, because a certain variable may depend on another. For instance, two arguments may have to be equal because of their types.
08:15:55 <Eduard_Munteanu> e.g. f :: (m : N) -> (n : N) -> m == n -> ...
08:16:39 <Eduard_Munteanu> To pattern-match the equality, you have to write   f m .m refl = ...
08:18:22 <janosp> ah
08:18:39 <janosp> wait, I don't correctly understand :)
08:20:28 <janosp> f :: (m : N) -> (n : N) -> m == n -> ...
08:20:38 <janosp> is this what I intend to do?
08:20:53 <Eduard_Munteanu> No. I was digressing. :)
08:21:26 <janosp> but now I am interested in understanding it :D
08:46:15 <hits1911> I have a sorted [Int]. I need an [Int] whose elements are not in former one. Is there a better way to do this than filter (not . (flip elem) ?
08:48:19 <ertes> :t filter (not . flip elem)
08:48:23 <lambdabot> error:
08:48:25 <lambdabot>     • Couldn't match type ‘a -> Bool’ with ‘Bool’
08:48:27 <lambdabot>       Expected type: t a -> Bool
08:48:41 <ertes> hits1911: as that's a type error: yes, definitely =)
08:48:48 <ertes> hits1911: could you show an example?
08:48:53 <amx> [1..] \\ yourlist
08:48:57 <amx> if I understand you correctly
08:50:48 <ertes> > let excludes = S.fromList "cik" in filter (`S.notMember` excludes) "abcdefghiiiiijkl"
08:50:49 <hits1911> It was not the exact code. let a = [1,2,3,4]. filter (not . (flip elem) a) [1..10] gives [5,6,7,8,9,10]
08:50:51 <lambdabot>  "abdefghjl"
08:51:42 <Matias_> hits1911: the \\ operator amx suggested does just that
08:51:52 <MarcelineVQ> amx: \\ isn't quite filter, it only removes the first occurece of an elemen
08:51:53 <ertes> > let excludes = "cik" in filter (`notElem` excludes) "abcdefghiiiiijkl"  -- list-only version (much slower in most cases)
08:51:54 <MarcelineVQ> > [1,1,2,3,4] \\ [1,2,3]
08:51:57 <lambdabot>  "abdefghjl"
08:51:58 <lambdabot>  [1,4]
08:52:29 <ertes> hits1911: i recommend using the Set variant
08:52:33 <Matias_> yep
08:52:34 <Matias_> https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Set.html#v:-92--92-
08:52:57 <Matias_> it should be significantly faster if the list is large
08:53:09 <ertes> hits1911: in fact, if all elements in your list are unique, you can just use a set difference, which is the most efficient solution
08:53:26 <ertes> > S.fromList "abcdef" S.\\ S.fromList "cef"
08:53:28 <lambdabot>  fromList "abd"
08:54:40 <ertes> if your elements are not unique, but the ordering doesn't matter, you can use Map difference
08:55:18 <hits1911> They are all unique.  (\\) was what I needed. Thanks very much.
08:55:45 <ertes> hits1911: (\\) is the list version…  if all elements are unique, use Data.Set
08:57:31 <hits1911> ertes: the difference is the speed, right?
08:58:14 <ertes> hits1911: yes, it makes your cost curve logarithmic instead of linear
08:58:56 <ertes> in fact the cost curve of (\\) is even quadratic
09:01:24 <hits1911> ertes: ok. thank you so much.
09:16:54 <NextHendrix> whats the longest error you've ever got in ghci
09:17:15 <AndreasK> NextHendrix: Does infinite output count?
09:18:07 <NextHendrix> thats pretty long
09:18:35 <monochrom> I forgot.
09:18:38 <NextHendrix> can get it to spit out essay with just a handful of input
09:19:02 <monochrom> who actually remembers anyway?
09:19:58 <janosp> Hi another question: I want to use QuickCheck with my own data : data Fmla = Prop Char | Neg Fmla | Implication Fmla Fmla
09:20:47 <siddhu> Can someone explain traverse (\x -> [0..x]) [0..2] ?
09:20:49 <janosp> Any idea, how I to do create arbitrary Fmla's ?
09:21:07 <monochrom> @type traverse
09:21:10 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:21:26 <monochrom> So it looks like t=[], f=[].
09:21:45 <Xnuk> (a -> [b]) -> [a] -> [[b]]
09:21:56 <pavonia> janosp: You can use the Applicative instance to define it recursively, I guess
09:22:33 <janosp> uhm
09:22:35 <siddhu> The output is what confuses me
09:22:54 <monochrom> You can understand it as: do { a <- [0..0]; b <- [0..1]; c <- [0..2]; return [a,b,c] }
09:22:55 <pavonia> Wait, I'm confused
09:23:05 <monochrom> There is also an Applicative way to write it.
09:23:44 <janosp> pavonia, I don't understand what you mean
09:25:02 <siddhu> Interesting. The monadic version makes sense.
09:25:37 <pavonia> janosp: e.g. Prop <$> arbitrary gives you new Prop elements
09:26:40 <pavonia> janosp: And then there are combinators to generate new elements from either of the three constructors alternatives
09:27:17 <janosp> can you give me an example for e.g. Implication?
09:27:29 <janosp> this is new turf for me :)
09:27:54 <pavonia> same pattern, Implication <$> arbitrary <*> arbitrary
09:29:17 <janosp> but would that create eg: Implication (Neg 'c') (Implication 'a' (Neg 'y'))
09:32:55 <pavonia> janosp: It's just one part, look at the combinators for Gen how to combine the three constructor alternatives to a single generator
09:33:42 <pavonia> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen.html#t:Gen
09:34:03 <pavonia> oneof is probably what you want
09:38:50 <gillesmajor> Just a small question about hspec, cannot find any example in the doc on how to do that: I have a function f that returns an Either String B,  and in the test, I am only interesting to check that a Left is indeed received given some input. I cannot find any way to only pattern match on the Left, without caring at all what the actual error message is. Does anyone know a solution to this, similar to `shouldBe` (Left _ ) (which doesn't work)
09:43:42 <geekosaur> `shouldSatisfy` isLeft
09:43:48 <geekosaur> (Data.Either)
09:44:20 <gillesmajor> ok thanks!
09:44:55 <janosp> pavonia, thanks, I am looking at it :)
09:44:58 <Tuplanolla> How about types that don't have `is`-functions?
09:45:08 <geekosaur> it's a general predicate
09:45:42 <geekosaur> since lambdas don't allow cases, you'd presumably have to write your own, though
09:45:59 <gillesmajor> yep seems this needs to be done on a per type basic then, but anyway, thanks
09:46:02 <MarcelineVQ> don't allow cases?
09:46:03 <gillesmajor> *basis
09:46:14 <geekosaur> or \v -> case v of {Left {} -> True; _ -> False}
09:46:31 <geekosaur> I mean you can't pattern match directly, but you can still go to case, it's just noisy
09:46:38 <MarcelineVQ> gotcha
09:46:40 <Tuplanolla> > fmap (\ case Left _ -> True; _ -> False) [Left (), Right ()]
09:46:43 <lambdabot>  [True,False]
09:46:49 <Tuplanolla> It's not the prettiest thing.
09:47:08 <Tuplanolla> Surely lenses offer a solution to this.
09:51:18 <implementation_> alternatively you could just factor out the inner function...  let f (Left _) = True; f _ = False in fmap f [Left (), Right ()]  looks more overviewable anyway (if properly layouted)
09:53:02 <Tuplanolla> I'm more interested in a function like `is` that could be given a constructor of any type and have it return a predicate to match on it.
09:53:52 <gillesmajor> will have to look into those other solutions. lenses are a bit too advanced to me, and other solutions are quite verbose when throwing quick tests...
09:56:30 <geekosaur> Tuplanolla, what type would that have?
09:56:50 <maerwald> a dependent type maybe
09:57:12 <Tuplanolla> `Q Exp`, geekosaur?
09:59:23 <geekosaur> actually `shouldHaveConstructor` would be writable via Typeable (parameter is a TyCon)
10:00:40 <Gurkenglas> :t has _Left -- Tuplanolla
10:00:42 <lambdabot> Either b c -> Bool
10:01:01 <ertes> :t either (const True) (const False)
10:01:03 <lambdabot> Either b b1 -> Bool
10:01:15 <Gurkenglas> You derive prisms for the type you want to check and then you use has to check whether some constructor was used
10:01:26 <Tuplanolla> Neat, Gurkenglas.
10:01:49 <ertes> :t foldr (\_ _ -> False) True :: Either a b -> Bool
10:01:52 <lambdabot> Either a b -> Bool
10:02:11 <ertes> :t null :: Either a b -> Bool
10:02:13 <lambdabot> Either a b -> Bool
10:02:18 <ertes> > null (Left ())
10:02:21 <lambdabot>  True
10:02:23 <ertes> > null (Right ())
10:02:24 <hpc> :t null
10:02:30 <lambdabot>  False
10:02:30 <lambdabot> Foldable t => t a -> Bool
10:02:32 <hpc> ah right
10:02:47 <ertes> Tuplanolla: null is better than depending on lens for that =)
10:03:02 <Gurkenglas> ertes, he wants a solution that won't work only for Either
10:03:16 <ertes> ah
10:03:29 <ertes> null works for more types, but you don't get to choose the semantics
10:03:44 <Gurkenglas> And even for Either this solution looks different for left and right
10:03:59 <ertes> hmm?
10:04:19 <Gurkenglas> For right, you check whether there's a right element
10:04:27 <Gurkenglas> For left, you check whether there's not a right element, see the problem?
10:04:46 <Gurkenglas> He wants to check whether there's a left one, so it looks symmetric
10:05:26 <ertes> i haven't read the full backlog
10:06:25 <Gurkenglas> me neither, but the problem is simple enough to specify that I guessed at it :P
10:07:12 <Gurkenglas> (That's a general strategy: Make your problem simple enough to express in math that ekmett has already written something for it - here `has`)
10:09:05 <Gurkenglas> And then you turn that correlation around to guess that what he writes must be the solution to a simple problem, and heurisitically use his stuff so your solutions will be more general -> cargo cult \o/ wololo
10:09:40 <janosp> pavonia, Thanks for your help
10:09:59 <geekosaur> http://hackage.haskell.org/package/hspec-expectations-lens-0.4.0/docs/Test-Hspec-Expectations-Lens.html#v:shouldHave
10:10:01 <ertes> yeah, i use that strategy a lot…  i barely write any code that doesn't use kan-extensions or free =)
10:11:34 <janosp> pavonia, although I get sometimes an infinite Fmla, since it is recursive :
10:11:35 <janosp> :D
10:12:29 <pavonia> janosp: Could you show your final implementation?
10:14:32 <janosp> https://gist.github.com/jpotecki/d39d5307634a98a170bcc6b0c71c9b49
10:20:45 <pavonia> janosp: You could probably reduce the depth of the trees using the frequency combinator
10:24:47 <janosp> OK, I'll look into it tomorrow :)
10:27:42 <MarcelineVQ> if you derive Show for your datatype you can use   sample propGen   to see some results of propGen
10:28:23 <MarcelineVQ> it's good for seeing if things are doing what you think
10:42:07 <jarvus-chris> I'm going nuts getting "cannot find -lgmp" while trying to compile postgrest with stack within a container. I've shoved libgmp.so into every ENV-shaped orifice I could find: http://lpaste.net/2548369221029462016
10:47:29 <pavolzetor> I have a M44 of V3
10:47:40 <pavolzetor> and i need to multiply each by a scalar
10:47:42 <Eduard_Munteanu> jarvus-chris, what does ls -al say on the .so?
10:48:06 <pavolzetor> is there a simple way using linear package?
10:48:49 <ertes> pavolzetor: M44 a = V4 (V4 a)
10:48:50 <MarcelineVQ> pavolzetor: linear has (!!*) in Linear.Matrix
10:48:54 <pavolzetor> yes
10:49:05 <ertes> pavolzetor: therefore:  fmap (fmap (*^))
10:49:07 <ertes> oops
10:49:10 <ertes> pavolzetor: therefore:  fmap (fmap (5 *^))
10:49:23 <ertes> or even:  fmap (fmap (fmap (5*)))
10:49:53 <pavolzetor> I am not sure, the system is as M*G
10:50:06 <pavolzetor> M is V4 (V4 Double)
10:50:19 <pavolzetor> G is V4 (V4 (V3 Double))
10:50:37 <pavolzetor> i need all components to be multiplied
10:50:40 <ertes> ah
10:50:56 <pavolzetor> as I want to avoid extracting 3 matrices for x,y, and z
10:51:06 <ertes> pavolzetor: liftA2 (liftA2 (*^))
10:51:08 <pavolzetor> (the system is for cubic curves)
10:51:10 <ertes> like that?
10:51:40 <ertes> :t liftA2 (liftA2 (\s -> fmap (s*)))
10:51:42 <lambdabot> (Applicative f1, Applicative f, Num b, Functor f2) => f (f1 b) -> f (f1 (f2 b)) -> f (f1 (f2 b))
10:52:24 <pavolzetor> exactly
10:52:25 <ertes> pavolzetor: Applicative implements zipping semantics, i.e. matching up each component of both sides and mapping a function over each pair
10:52:34 <ertes> for V*
10:52:44 <pavolzetor> I was not familiar with liftA2 (or wan and forgot
10:53:06 <Gurkenglas> Tuplanolla, has makes you prone to boolean blindness though - what do you need the Bool for?
10:53:25 <lpaste> Tuplanolla pasted “Has via TH” at http://lpaste.net/350692
10:53:32 <Tuplanolla> I don't need anything.
10:53:49 <pavolzetor> is this similar to the lifting in math?
10:54:33 <ertes> pavolzetor: it's really just componentwise operation in math:  o i j = f (m i j) (n i j)
10:54:46 <ertes> that's implemented in haskell/linear as:  liftA2 (liftA2 f)
10:54:59 <ertes> the outer liftA2 crosses the outer vector layer, etc.
10:55:12 <ertes> @import Linear
10:55:12 <lambdabot> Unknown command, try @list
10:55:16 <ertes> @let import Linear
10:55:17 <lambdabot>  .L.hs:140:1: error:
10:55:17 <lambdabot>      Failed to load interface for ‘Linear’
10:55:17 <lambdabot>      Perhaps you meant Linker (needs flag -package-key ghc-8.0.1)
10:55:45 <jarvus-chris> Eduard_Munteanu: added ls output to bottom: http://lpaste.net/2548369221029462016
10:55:52 <ertes> @let data V4 a = V4 !a !a !a !a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
10:55:55 <lambdabot>  Defined.
10:56:04 <pavolzetor> I see
10:56:21 <pavolzetor> so basically the function gets applied inside the V4
10:56:33 <pavolzetor> and second lift puts it in the inner V4
10:56:48 <ertes> @let instance Applicative V4 where pure x = V4 x x x x; V4 f1 f2 f3 f4 <*> V4 x1 x2 x3 x4 = V4 (f1 x1) (f2 x2) (f3 x3) (f4 x4)
10:56:51 <lambdabot>  Defined.
10:57:42 <ertes> > liftA2 (+) (V4 1 2 3 4) (V4 10 20 30 40)
10:57:46 <lambdabot>  V4 11 22 33 44
10:57:55 <ertes> pavolzetor: ^
10:58:17 <Eduard_Munteanu> jarvus-chris, hm, is it for the right arch for your build?
10:58:20 <pavolzetor> I see
10:58:31 <pavolzetor> liftA2 (,) == zip
10:58:32 <Eduard_Munteanu> jarvus-chris, be careful about 32bit stuff, if that's needed
10:59:02 <pavolzetor> very interesting, even doing <$> and <*> works
10:59:22 <jarvus-chris> it's the right arch, I'm using habitat, the build is in an isolated container with a libgmp package installed that's made for this env that I've used for non-haskell compiles just fine
10:59:52 <pavolzetor> ertes, thanks for helping
11:04:36 <Eduard_Munteanu> jarvus-chris, I'd try to pass --verbose to the linker to see what it's doing
11:05:14 <Eduard_Munteanu> For GCC, you should probably add -Wl,--verbose to LDFLAGS.
11:38:03 <athan> Has anyone here seen much work regarding haskell and circuits?
11:38:52 <athan> Has anyone here seen much work regarding haskell and circuits? (sorry for the repeat, I blame obama)
11:39:09 <athan> and by circuits, I mean the electronic ones :)
11:39:28 <athan> I can't really decide if circuits form something like a seminearring, but it sure smells similar
11:39:28 <Tuplanolla> Have you seen Conal's talk on it, athan?
11:39:45 <athan> Tuplanolla: I don't think so, I've seen his TV and FRP stuff though
11:39:55 <Tuplanolla> @google conal haskell hardware
11:39:56 <lambdabot> https://github.com/conal/talk-2015-haskell-to-hardware
11:40:16 <athan> :O thanks Tuplanolla!
11:40:35 <athan> Does this use clash? I'm trying to make my own doohicky right now
11:42:18 <athan> (if I follow that link, my irc session will die because my tablet doesn't like to do multiple things at once :D)
11:43:18 <warri0r> What client are you using?
11:43:32 <athan> warri0r: I'm secure shelling into a server
11:43:46 <athan> via termius
11:44:09 <warri0r> K
11:44:38 <athan> I was thinking parallel circuits could form product, while series circuits would form sum
11:45:00 <athan> where each element of the monoid is a "connection" assuming proper polarity
11:45:26 <athan> the identity element for series would be a 0 ohm element, a wire, while the identity for parallel would be an infinite resistance element
11:45:57 <athan> but I don't think the distributive property checks out, so I don't think it's a ring or semiring
11:47:09 <ertes> athan: why don't you start by defining your axioms and see what structure you end up with?
11:47:56 <roconnor> athan: There some nice work on representing circuts with monoidal categories.
11:48:24 <Tuplanolla> I was about to mention that.
11:48:41 <Tuplanolla> Those people love string diagrams.
11:49:10 <athan> roconnor: Awesome! I will check that out
11:49:14 <athan> :D woot
11:49:39 <roconnor> athan: you can look for "Geometry of Synthesis" I believe is the keyword.
11:50:06 <Tuplanolla> Too bad they don't even try to model diodes, transistors or other nonlinear components.
11:50:21 <athan> :O! thank you roconnor
11:50:50 <athan> I was considering those exceptiopns too Tuplanolla :/ hrm
11:50:57 <roconnor> The monoidal categeory was just about routing circuts.  To have actual components you add some primatives.
11:51:06 <athan> hmm!
11:51:12 <roconnor> I guess you'd end up with some sort of free monoidal category.
11:51:19 <roconnor> based on your primatives.
11:58:44 <athan> wait I am a dingus, parallel = +, and series = *
11:58:48 <Gurkenglas> Why isn't there "Applicative (Event t)" in the superclasses of "Reflex t", rather than "Functor (Event t)"?
12:00:15 <Gurkenglas> Alternative even
12:01:50 <Gurkenglas> (Alternative might be wrong.)
12:02:55 <Gurkenglas> And maybe it should be Apply, not Applicative, considering http://hackage.haskell.org/package/reflex-0.4.0/docs/Reflex-Class.html#v:mergeWith
12:04:11 <pavolzetor> ertes, the liftA2 trick was incorrect math
12:05:02 <pavolzetor> as it was doing  componentwise multiplication
12:05:06 <Gurkenglas> liftA2 is zipWith only for zippy Applicatives (ie where liftA2 is zipWith :P), but he did define V4 that way
12:05:40 <Gurkenglas> *V4's Applicative instance
12:05:44 <pavolzetor> I found other way to do it, by taking matrix X and doing fmap (fmap pure)
12:06:04 <pavolzetor> so the left matrix is M44 (V3 Double)
12:06:30 <pavolzetor> I think it is ugly but I fail to see anything more elegant
12:09:23 <pavolzetor> also I see in linear fromList, but I can find the function it the package
12:14:14 <Zemyla> Oh wow, I just realized that, in this typeclass I'm working with, the only return values are m () and m Bool.
12:14:35 <Zemyla> So I can turn it into a free monad, and look at what the sort algorithm actually *looks* like.
12:16:33 <ertes> pavolzetor: then i don't understand what you want to do
12:16:44 <ertes> pavolzetor: i think i explained that Applicative does component-wise operations
12:17:28 <Gurkenglas> Zemyla, I'd like to see that
12:18:13 <Zemyla> I'll work on it to the point where it actually works.
12:19:26 <ertes> Gurkenglas: what's (pure () :: Event t ())?
12:20:11 <Gurkenglas> ertes, presumably the event that never triggers, but I already realized Apply might make more sense
12:20:49 <ertes> Gurkenglas: in order to be lawful it would have to be the event that "always" triggers, which doesn't really make sense
12:21:04 <Gurkenglas> Ah, of course
12:21:05 <ertes> Gurkenglas: i contributed a semigroupoids interface though, so with the git version you can use most type classes from there
12:21:56 <ertes> (including Apply)
12:30:50 <Lokathor> athan, have you tried AndChat? It's IRC on android, and it seems to stay connected in the background well enough
12:31:48 <NextHendrix> in my experience atomic is the all round least worst android irc client
12:31:58 <NextHendrix> i say least worst because none of them deserve the title "best"
12:32:47 <Lokathor> I got a new phone last night
12:32:47 <athan> Lokathor: I have, but it does weird NATing with my connections
12:32:53 <athan> I also just think it's this tablet :/
12:33:02 <Lokathor> and i'm dreading the process of filling in all tha apps i should get for "basic" sorts of functions
12:33:03 <athan> the feds want to keep me starving
12:33:21 <athan> thanks NextHendrix haha
12:33:38 <NextHendrix> tbh the best solution is sshing into a machine with a proper client
12:33:56 <athan> hopefully in the next few days I'll have my raspberry pi screen, so I can destroy this tablet with molten copper
12:34:53 * ertes can't type on an on-screen keyboard
12:35:39 * geekosaur sort-of can... but touchscreens and his fingers don't really get along well
12:37:06 <joncfoo> is there a Spock related irc channel?
12:37:59 <Rotaerk> joncfoo, spock? the vulcan?
12:38:16 <geekosaur> the web framework
12:38:56 <athan> Rotaerk: Use nested-routes! :v
12:39:13 <Rotaerk> wat
12:39:26 <athan> watt-hours more like1
12:39:28 <athan> !*
12:41:30 <benneh> if I have both 'mtl' and 'monads-tf' installed, and I try to 'import Control.Monad.State.Class', how do I determine whether I will get the 'mtl' version or the 'monads-tf' version?
12:42:59 <lyxia> benneh: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
12:43:36 <joncfoo> I extracted the auth/context part of the `funblog` example Spock application & thought that might be useful to someone - was thinking I could post in the Spock irc channel if there was one
12:43:41 <kadoban> benneh: Depends what build system. I like stack, where you only really have whichever one is pertinent to the current project visible anyway.
12:45:09 <benneh> kadoban: I'm using arch linux, with the 'haskell-core' repository enabled
12:45:18 <benneh> I just install the various packages with pacman
12:45:40 <kadoban> benneh: If it were me, I'd use stack or if you must cabal-install instead.
12:45:59 <kadoban> It seems non-optimal to have to litter your code with package-qualified imports just because of your setup.
12:46:34 <Clint> yeah, only do that if you are using both packages
12:46:34 <benneh> kadoban: this isn't a problem I've encountered before
12:46:40 <benneh> how do you 'package-qualify' an import?
12:46:52 <kadoban> The link above, at a guess from the URL.
12:47:03 <ertes> benneh: what lyxia said…  this has nothing to do with build systems
12:47:52 <kadoban> Well, ya it kinda does. If you use cabal-install with sandboxes or stack you won't run into this, because what's "installed" has a different meaning. You'd only run into it if you were actually using both packages in the same project.
12:48:52 <geekosaur> actually even without sandboxes you wouldn't run into it, because you specify the packages to expose as dependencies in the cabal file (the same way regardless of cabal with or without sandboxes, *or* stack)
12:49:11 <benneh> OK, that's nice and simple, if a bit ugly -- thanks
12:49:14 <Clint> or you ghci -hide-package
12:49:14 <kadoban> Ah, wasn't sure if cabal would handle it right without sandboxes, good to know.
12:49:15 <geekosaur> with ghc, use -package or enable PackageImports and use the modified syntax
12:49:25 <benneh> so if I don't qualify the package, which version am I importing?
12:49:25 <geekosaur> or what Clint said
12:49:58 <ertes> of course how could i *not* propose stack is the answer to life, the universe and everything…
12:50:02 <geekosaur> benneh, that question is why stack and cabal exist. use -package to specify, or you get whatever ghc picks for whatever reason
12:50:06 <ertes> s/is/as/
12:50:12 <Zef> Hey folks, got a quick question about `makeClassy`, https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeClassy
12:50:32 <kadoban> ... I mentioned either stack or cabal-install.
12:50:50 <Zef> If I have a simple type like: data Editor = Editor {thing :: Int} and I do makeClassy ''Editor
12:51:10 <Zef> Then later I embed it into a State transformer as (Editor, String)
12:51:42 <Zef> How can I autogenerate lenses such that thing :: (Editor, String) -> Int
12:51:55 <Zef> Sorry, thing :: Lens' (Editor, String) Int
12:52:10 <ertes> benneh: unfortunately i believe there is no way to choose the version…  in fact i would expect GHC to complain or at least warn, if multiple versions of the same package are in scope
12:52:10 <lyxia> _1 . thingL ?
12:52:14 <geekosaur> Zef, you don't autogenerate those, you use lens combinators
12:52:34 <Zef> geekosaur: What's the point of makeClassy then?
12:53:00 <geekosaur> Zef, it makes the lensy accessors for records, because standard Haskell record fields have lots of horrid limitations
12:53:11 <ertes> benneh: that's why you specify your desired version range in the cabal file, then you can be sure that you will get a version of the package within that range
12:53:12 <Eduard_Munteanu> You could write instance HasThing Editor a => HasThing (Editor, String) a
12:53:35 <Zef> If I did `data FullState = FullState {editor :: Editor, other :: Other}` then makeClassy ''FullState would it generate the proper HasEditor?
12:54:22 <Eduard_Munteanu> Yes.
12:55:04 <benneh> ertes: I guess it's time for me to figure out how stack works then
12:55:08 <benneh> thanks for the help, everyone
12:55:30 <ertes> benneh: how cabal works…  stack is a deployment system
12:56:26 <Zef> Okay thanks Eduard_Munteanu !
12:58:32 <kadoban> ertes: That doesn't strike you as at all disingenuous?
12:58:39 <geekosaur> you would get a lens for the Editor that needs to be composed with a lens that retrieves or updates the value within the Editor
13:00:10 <ertes> kadoban: what exactly?  stack is orthogonal to benneh's problem, while a proper understanding of cabal (not cabal-install) is required here
13:00:32 <ertes> and a good idea in general to understand how dependencies in haskell work
13:00:54 <kadoban> ertes: Ya, it sounds like you're just going out of your way to imply that cabal-install, which everyone knows as cabal is the only answer to anything. What is this person supposed to do, figure out you mean the library and research that? How?
13:01:57 <ertes> kadoban: i'm not even using cabal-install…  it would be disingenuous of me to direct them to nix, which is my favourite development/deployment solution
13:02:27 <kadoban> ertes: Okay, then I have no idea why you worded it like that.
13:04:48 <ertes> kadoban: my issue with stack is not stack itself, but the hype around it, and that people miss no opportunity to mention/advertise it, even when it's completely orthogonal to the problem at hand
13:05:18 <kadoban> ertes: And thus you provide shitty semi-lying advice because you dislike people suggesting stack?
13:05:34 <kadoban> Seems pretty cool.
13:05:35 <mckeankylej> I am writing a sized vector libary but I keep getting an error that n is ambigious in this type annotation: take :: SNat i -> Vec a (i + n) -> Vec a i how do I make this type check without passing n as an argument?
13:05:40 <ertes> kadoban: i'll stop talking to you now
13:06:02 <maerwald> this again
13:06:34 <hexagoxel> heh, another stack fanboy that cannot bear criticism of the fanboyism.
13:06:45 <maerwald> some people here should stop abusing the channel as a promotion platform
13:06:57 <mckeankylej> I use to be a stack fanboy till I tried nix.
13:07:09 <mckeankylej> God I was in so deep
13:07:19 <kadoban> I mind criticism not at all. I disagree with disingenuous statements designed to promote a view.
13:07:31 <wespiser> yea, cabal-install was not great for the community, stack is better
13:07:45 <Zef> Eduard_Munteanu: Do I need to do anything special to derive HasEditor? It doesn't seem to be working, 
13:08:01 <kadoban> "stack is a deployment system", implying it's not a build system is at *best* disingenuous.
13:08:06 <Zef> I'm getting `No instance for HasEditor FullState`
13:08:19 <Zef> Do I need a standalone deriving clause or something?
13:08:49 <wespiser> Zef: yes, using 'instance'
13:09:47 <Zef> wespiser: something like `instance HasEditor FullState`?
13:09:57 <wespiser> Zef: exactly
13:10:33 <Zef> Do I need to write the methods myself or can it derive them?
13:10:41 <Zef> Or do I only need to write the one `editor` lens?
13:11:16 <Zef> Sorry, I'm still new to lenses :P
13:11:54 <gamegoblin> does anyone see anything wrong with this instance of Arbitrary? It seems like my test case occasionally shrinks forever. Energy just wraps a double. http://lpaste.net/350696
13:12:29 <wespiser> Zef: you need to find the methods for the typeclass, HasEditor, then define them with something like "instance HasEditor x where\nmethod1 x = ..."
13:12:40 <Zef> Can't I derive them?
13:12:59 <Zef> Or can it derive them if I give it a lens to the editor itself?
13:13:16 <Zef> I just don't really want to write out the lenses for every field, I have a lot of fields
13:13:18 <wespiser> it derivation happens during compile time
13:13:25 <wespiser> *the
13:13:39 <Zef> I'm misunderstanding something, if it derives them at compile time, why do I need to write them?
13:13:40 <kadoban> gamegoblin: Hmm. Only thing that comes to mind is maybe 'shrink' for Double suggests the negative, in which case yours would be shrinking to itself sometimes? I don't know if that actually happens though.
13:13:54 <wespiser> Zef: because it doesn't always know what you want
13:13:57 <Zef> Or could you just show me what the instance would look like?
13:13:58 <ertes> gamegoblin: not a direct answer, but you actually don't need to implement shrink manually:  newtype Energy = Energy { fromEnergy :: Double }  deriving (…, Generic, …)
13:14:03 <ertes> gamegoblin: shrink = genericShrink
13:14:18 <gamegoblin> kadoban: it seems to happen if I do map Energy (filter (>= 0) x)
13:14:46 <wespiser> Zef: I would look in the source code for an example that defines an instance for HasEditor
13:15:04 <kadoban> Hmm, guess not then.
13:15:31 <Zef> Hrmm? Which source? I haven't defined it yet, that's why I'm trying to define it
13:15:44 <Zef> I'm working on my own project haha
13:15:44 <gamegoblin> kadoban: another weird thing is when it’s infinite looping it says stuff like "*** Failed! Falsifiable (after 4 tests and 0.52913 shrinks)…"
13:15:54 <gamegoblin> kadoban: not sure what a fractional number of shrinks is....
13:16:00 <lyxia> gamegoblin: how's energy defined
13:16:09 <gamegoblin> lyxia: newtype Energy = Energy Double
13:16:59 <kadoban> That does sound weird.
13:17:03 <gamegoblin> also deriving Num, etc
13:17:32 <gamegoblin> Oh, I left it running for a few minutes and the loop isn’t infinite
13:17:36 <gamegoblin> just took several minutes to bottom out
13:18:07 <wespiser> Zef: where is HasEditor defined?
13:18:17 <Zef> it's defined by makeClassy
13:18:50 <wespiser> find the source code for makeClassy
13:20:15 <lyxia> gamegoblin: I'm not sure what's going on either, but if values are supposed to be positive it might be better to rely on the Arbitrary instance for Positive Double rather than Double.
13:22:07 <mckeankylej> I am writing a sized vector libary but I keep getting an error that n is ambigious in this type annotation: take :: SNat i -> Vec a (i + n) -> Vec a i how do I make this type check without passing n as an argument?
13:23:19 <lyxia> where is this + defined
13:23:36 <lyxia> is it GHC.TypeLits
13:24:08 <mckeankylej> lyxia: it is inductively defined the standard way
13:24:15 <mckeankylej> lyxia: datakinds and all
13:24:49 <mckeankylej> is the new type family deps strong enough to make + injective?
13:25:40 <lyxia> It doesn't seem to be.
13:26:35 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families " A -> B, where A is the result type variable "
13:28:13 <mckeankylej> lyxia: how does agda type check this?
13:28:47 <mckeankylej> lyxia: are all functions checked for injectivity?
13:28:59 <Eduard_Munteanu> No.
13:30:03 <hexagoxel> how about  take :: SNat i -> Vec a j -> Vec a (Min i j) ?
13:30:04 <Eduard_Munteanu> What's the actual error?
13:30:25 <lyxia> hexagoxel++
13:31:27 <mckeankylej> Eduard_Munteanu: http://lpaste.net/350697 error
13:32:18 <hexagoxel> and (i ~ Min i j) => to make it so that you cannot take more than length.
13:32:58 <mckeankylej> hexagoxel: that is a weaker def as it allows for more functions to type check but I wonder if it would be harder to use in practice
13:35:39 <hexagoxel> that should make it "strong" again. or does ghc complain about that? it might..
13:37:06 <mckeankylej> hexagoxel: nat it type checks I feel like the plus def is better but if that isnt representable I will go with that
13:39:24 <glguy> mckeankylej: It would probably work if you had a known 'i'
13:39:39 <glguy> otherwise you can use the TypeApplications extension
13:42:03 <mckeankylej> glguy: but I pass in i as a singleton nat? What more should I do?
13:42:40 <glguy> I mean if it was a particular concrete type, not a type variable
13:43:33 <mckeankylej> glguy: I am sorry I dont follow could you show me what that looks like
13:43:41 <glguy> Like 5, or 6
13:45:25 <mckeankylej> glguy: yea but I am writing a libaray I need the type signature to be generic
13:45:36 <glguy> Then you'll have to use TypeApplications
13:45:48 <glguy> It's going to be painful to use these length-indexed vectors generically
13:48:12 <lyxia> (i ~ Min i j) seems like a nice solution though.
13:52:52 <sr_> i can't cabal install the packages i need because there is (apparently) a GHC bug:
13:54:06 <sr_> http://pastebin.com/2LftPX0t
13:54:38 <kadoban> danger3rdeye: That's unfortunate. Is it an old version of GHC?
13:55:38 <danger3rdeye> no, it's the newest one
13:55:51 <danger3rdeye> i am running debian unstable
13:55:58 <danger3rdeye> that's just how i roll
13:56:26 <kadoban> Oh, GHC 8? I think there's going to be a point release soonish, I wonder if your bug is fixed there.
13:56:31 <danger3rdeye> if i try to force installation of the old GHC version i break other things
13:56:58 <Tuplanolla> I wonder if that bug is as silly as it seems.
13:57:21 <danger3rdeye> thank you for saying that kadoban -- i hope it will be fixed
13:57:53 <MarcelineVQ> what version of ghc is it?  ghc --version
13:58:08 <Tuplanolla> It looks like GHC tries to merge two overlapping imports, but fails.
13:58:24 <danger3rdeye> The Glorious Glasgow Haskell Compilation System, version 8.0.1
13:59:23 <Tuplanolla> Here's the code: https://hackage.haskell.org/package/JuicyPixels-repa-0.7.1.0/docs/src/Codec-Picture-Repa.html
13:59:27 <danger3rdeye> i want to play with the package hackage.haskell.org/package/falling-turnip
14:00:02 <MarcelineVQ> ah here, https://ghc.haskell.org/trac/ghc/ticket/12127 it's fixed in HEAD, next ghc release will fix it
14:00:12 <danger3rdeye> o good
14:00:26 <MarcelineVQ> specifically your issue https://ghc.haskell.org/trac/ghc/ticket/12216
14:01:09 <danger3rdeye> when zackly?
14:02:17 <MarcelineVQ> dunno :X
14:02:58 <kadoban> I doubt I'd want to wait around. Can you use an older version instead, or is that not going to work for you?
14:03:27 <Tuplanolla> You could `cabal get` the package, relax the imports yourself and install the result, danger3rdeye.
14:03:30 <danger3rdeye> i don't know how to do that
14:03:38 <kadoban> (I have no specific information on when it'll be released, to be clear ... I think I remember hearing there was an RC for it, but that's about all I know)
14:03:59 <danger3rdeye> if i force installation of the older GHC, there are many consequences on my system
14:04:36 <danger3rdeye> i don't understand all the details of cabal 
14:04:52 <hexagoxel> from the rc2 announcement "If all goes well we should have a final 8.0.2 release out shortly after the new year."
14:05:11 <kadoban> Nice
14:05:16 <danger3rdeye> but it will still be the Current Year!
14:05:59 <monochrom> Time to liberate yourself from the self-inflicted "I must get all software from the debian repo".
14:06:07 <Tuplanolla> Happy new year from a superior timezone.
14:06:23 <monochrom> Also time to liberate from the false dichotomy "it's either from the debian repo or build from source"
14:06:30 <kadoban> Yeah, IMO it's not a good idea to try to use all haskell stuff from an OS package manager.
14:06:37 <hexagoxel> danger3rdeye: btw it installs fine with the 8.0.2rc1 already
14:06:47 <danger3rdeye> well, i didn't say that running unstable debian was the best choice in every possible world
14:07:20 <hexagoxel> (and i could reproduce on 8.0.1)
14:07:23 <danger3rdeye> ok, can i use cabal to get this 8.0.2rc1 GHC?
14:07:34 <monochrom> No no no, you don't get it. I run ubuntu, and I still don't fetch GHC from ubuntu.
14:07:50 <monochrom> https://www.haskell.org/ghc/download_ghc_7_10_3#linux_x86_64 exists.
14:08:02 <danger3rdeye> ubuntu is swahili for "multiculturalism"
14:08:05 <kadoban> Ya, I don't think it matters *what* OS you use, I still would never use GHC or haskell libraries from an OS package manager, it just doesn't work currently.
14:08:48 <danger3rdeye> so where, pray tell, to the kids in the "in crowd" install GHC from?
14:08:50 <hpc> it works okay if you NEVER EVER mix them
14:09:07 <hpc> once you decide to use OS packages of haskell stuff, you're locked in
14:09:13 <hpc> you can never cabal install something without breaking it
14:09:24 <Clint> "never ever" seems a bit strong
14:10:02 <kadoban> danger3rdeye: in stack it installs it for you, in cabal-install you do it manually https://gist.github.com/ion1/2815423 is what I used to do. I run ubuntu, though I don't think it'd be largely different.
14:10:11 <monochrom> There is also https://www.haskell.org/platform/linux.html (but click on generic, do not actually tell your true distro)
14:10:32 <MarcelineVQ> I use package managed ghc so I don't have to deal with pathing but cabal and stack for everything else.
14:10:34 <hexagoxel> i installed the rc2 from http://downloads.haskell.org/~ghc/8.0.2-rc2/
14:10:39 <kadoban> (stack can't do that GHC version, by the way, the RC one)
14:10:40 <danger3rdeye> i considered haskell when i was choosing a language to write my realtime raytracer in, but rejected it because it could not use multiple cores
14:10:46 <danger3rdeye> of course it can now
14:10:59 <danger3rdeye> it couldn't in 2004 
14:10:59 <hpc> when was this?
14:11:02 <hpc> ah
14:11:09 <joncfoo> d~.
14:11:15 <kadoban> Hm, I didn't know it couldn't at one point, kinda interesting.
14:11:42 <danger3rdeye> not that there were all that many multicore cpus around either
14:11:52 <hpc> kadoban: consider how old haskell is, it predates the concept by a good margin
14:11:53 <danger3rdeye> but one still hoped
14:12:17 * geekosaur had a 2-CPU system that got killed by no BIOS update for Y2K :p
14:12:33 <kadoban> Yeah, I mean I guess it's fairly obvious that at *some* point it couldn't. Just never thought about it (and would have guessed earlier for when it gained the ability commonly)
14:12:43 <hpc> one of my friends had a pentium D and it was ridiculously unstable
14:12:45 <danger3rdeye> some of u guys should livestream coding sessions
14:12:54 <hpc> it could boot maybe a third of the time
14:13:02 <danger3rdeye> i would watch
14:13:07 <kadoban> I tried once ... livestreaming is not for me.
14:13:12 <danger3rdeye> at least for five minutes
14:13:22 <monochrom> Also for better coexistence of multiple versions (yes you will eventually need it), do not accept the default /usr/local prefix. Set it manually to something like /usr/local/ghc-3.14.16 so you just have to play with PATH.
14:13:32 <danger3rdeye> you are too hard on urself kadoban 
14:13:59 <danger3rdeye> u must persevere until the camera is nothing to you
14:14:00 <kadoban> Naw, I just know what I like. It was not pleasant. It's too much about uhm, giving a performance.
14:14:02 <monochrom> I disbelieve in livestream coding sessions.
14:14:22 <monochrom> I watched one on youtube from someone trying to compare java with apl.
14:14:53 <danger3rdeye> sure, let all the plebians take the glory with their "javascript" and their "node.js"
14:14:58 <MarcelineVQ> I imagine quality coding to be very boring to watch since you spend a fair bit of time actually thinking about the problem
14:14:59 <monochrom> I still don't understand why I have to watch him type for 10 minutes, for a point that could be easily made by static text that I could read in 10 seconds.
14:15:19 <roconnor> monochrom: did you run it at 2x speed?
14:15:28 <EvanR> videos are so.... slow
14:15:29 <danger3rdeye> lol but i like to see how coders work, what editor they use, etc
14:15:38 <monochrom> No. How do I run a youtube video at 2x speed?
14:15:52 <MarcelineVQ> you click the gear at the bottom of the vid
14:15:56 <monochrom> Also it was probably also 2004 so I would I run a youtube video at 2x speed in 2004?
14:15:58 <hpc> play it in two tabs at once, duh
14:16:05 <kadoban> Really? I didn't know youtube had that option either.
14:16:09 <MarcelineVQ> itdoes
14:16:17 <kadoban> Cool
14:16:31 <monochrom> Also does it have 10x speed?
14:16:50 <monochrom> Actually 60x speed because like I said he took 10 minutes to make a 10-second point.
14:16:55 <kadoban> But ya, I find videos a not-very-efficient means of learning personally.
14:17:30 <danger3rdeye> true except maybe for physical skills like making a mud rocket stove
14:17:48 <danger3rdeye> you'll want to see that before you do it
14:17:52 <MarcelineVQ> I don't understand a word you just said but I liked it.
14:18:20 <danger3rdeye> The first part of what you said: I get that a lot.
14:18:23 <kadoban> Haha, yeah I dunno what that is, but they are indeed great at learning that kind of stuff. It's pretty much the only way I even still have a bike or a lawn mower, from youtube vids of how to fix them.
14:18:27 <danger3rdeye> The second part not so much.
14:18:32 <monochrom> yeah livestream mud rocket stove session is excellent.
14:18:50 <monochrom> but that is not livestream coding session.
14:19:32 <danger3rdeye> but coding streams are so soothing in a ASMR kinda way
14:19:51 <hexagoxel> livestream coding = livestream api doc reading half of the time?
14:19:54 <monochrom> Oh the compare-java-with-apl guy had a soothing voice too.
14:20:07 <danger3rdeye> is there a modern apl?
14:20:12 <monochrom> I think maybe I should dig it out so you can watch it next time you are going to sleep.
14:20:25 <danger3rdeye> i read a BOOK on apl when i was 12 or 13
14:20:33 <danger3rdeye> it had a lot of symbols
14:20:37 <monochrom> There are J and K.
14:20:41 <kadoban> Is APL the one with the specialized keyboards?
14:20:43 <danger3rdeye> those too
14:21:12 <monochrom> On your CV you can write "I know C/C++ and J/Java/Javascript" for the kick of it :)
14:21:13 <danger3rdeye> i discovered a new computer scientist the other day
14:21:20 <danger3rdeye> Per Brinch Hansen
14:21:27 <danger3rdeye> he was danish
14:22:12 <danger3rdeye> i have never touched that monstrosity C++
14:22:30 <danger3rdeye> nor JS for that matter
14:22:50 <danger3rdeye> we stand far above that crowd
14:23:09 <danger3rdeye> ("The Master" quote)
14:31:24 <danger3rdeye> haskell is the language i find most interesting next to the one i code in
14:55:09 <kadoban> Anyone else frequently have problems with criterion's HTML output kind of breaking? Only some of the graphs display, and the summary one then doesn't.
15:00:38 <ertes> monochrom: if you have youtube-dl installed, you can watch youtube videos with MPV, which has a bunch of advantages, including arbitrary speed scaling
15:00:48 <ertes> MPV is a fork of mplayer
15:11:51 <MortimerMcMire> Hey everyone, I just wanted to tell you all that monad transformers make me hot.
15:12:20 <MortimerMcMire> Like, I'm finally at the point where I feel comfortable using them, and suddenly the entire world clicked into place and I can read other people's code without getting confused.
15:12:43 <MortimerMcMire> + happy new year <3
15:24:43 <ReinH> ertes: mpv is pretty great
15:25:56 <ertes> oh, it's already 2017…
15:26:00 <ertes> happy new year everybody =)
15:26:42 <dmj`> \o/
15:59:51 <how> What is the purpose of Data and Typeable typeclasses?
16:00:44 <hpc> it's a way to programatically inspect the algebraic structure of types (to say it fancy)
16:03:21 <hpc> actually, the documentation is quite thorough: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Typeable.html#t:Typeable https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Data.html#t:Data
16:04:27 <hpc> it's a lot like java's reflection, but not string-based
16:07:45 <buttons840> any pipe experts among us? I'm trying to figure out how pipes as "workers"; the pipes tutorial has an example with workers, but they are consumers, and I can't figure out how to do the same with pipes
16:08:15 <athan> Hey yall, sorry for not searching google, but does anyone here know of a package that defines Eular's constant `e`?
16:09:25 <athan> sorry this wifi is very spotty
16:09:35 <buttons840> athan: `exp 1` ?
16:09:43 <buttons840> :t exp
16:09:45 <lambdabot> Floating a => a -> a
16:09:53 <athan> oh hm
16:09:58 <athan> that's base e? Awesome
16:10:03 <athan> > exp 1
16:10:06 <lambdabot>  2.718281828459045
16:10:14 <athan> thanks buttons840!
16:10:28 <buttons840> np, found it on rossetta code :)
16:10:42 <athan> *bookmarks*
16:14:27 <ertes> buttons840: what's a "worker"?
16:20:09 <buttons840> ertes: let me link the tutorial i'm thinking of...
16:20:39 <buttons840> https://hackage.haskell.org/package/pipes-concurrency-2.0.7/docs/Pipes-Concurrent-Tutorial.html
16:20:57 <buttons840> ertes: the workstealing example is close to what i want, but i'd like to use pipes instead of consumers
16:21:57 <lpaste> Buttons840 pasted “No title” at http://lpaste.net/350698
16:22:59 <buttons840> this is what I have -- what I'm trying to do is have a Pipe which does some IO (web crawling) and I'd like the pipe to crawl multiple sites concurrently
16:26:20 <ertes> buttons840: i fail to see the utility of that library…  don't the basic concurrency abstractions already do it?
16:27:56 <monochrom> Perhaps you would pipe it if you were trapped in the "I have to write my own select loop" mindset.
16:29:04 <ertes> buttons840: see in particular the 'async' library
16:29:05 <buttons840> ertes: the same thing can be acheived with the basic concurrency abstractions I'm sure, I'm not sure if Pipes.Concurrent adds any value
16:29:30 <buttons840> monochrom: what do you mean?
16:30:21 <ertes> buttons840: combine that with the 'stm' library and you get a fairly comprehensive suite of very practical concurrency abstractions
16:39:10 <Gurkenglas> buttons840, won't 38 error out of the whole program once any found link is malformed?
16:41:02 <li4ick_> Can anyone explain the indentation rules in haskell? I just got an error because of this: ... someFunc (n + x) xs
16:41:22 <hpc> it uses alignment
16:41:25 <li4ick_> I just removed the spaces around "+" and then it worked. It's now: ... someFunc (n+x) xs
16:41:30 <li4ick_> Why?
16:41:34 <geekosaur> that sounds wrong
16:41:42 <geekosaur> @paste actual working and nonworking code
16:41:42 <lambdabot> Haskell pastebin: http://lpaste.net/
16:41:44 <Gurkenglas> Is there a pipes library with merging/splitting junctions?
16:42:14 <ertes> Gurkenglas: machines can do that, but it's not pipes
16:42:24 <ertes> see .Tee and .Wye
16:42:50 <ertes> also .Fanout
16:43:02 <li4ick_> It's not about working code. It's about the spaces around the "+" sign that gives a parse error (possibly incorrect indentation or mismatched brackets)
16:44:08 <hpc> paste a minimal example that reproduces your issue
16:44:13 <hpc> we don't have enough information to say what's going on
16:44:23 <hpc> (or paste your actual code)
16:44:29 <lyxia> li4ick_: https://en.wikibooks.org/wiki/Haskell/Indentation
16:45:17 <hpc> i mean, read that if you want an answer to "i can't indent things", but it might not be what's actually wrong
16:47:53 <li4ick_> This is my situation: The code would give the error in ghci, when loaded. I then added a main to call the func, and it WORKED. Now, I undo back to when I had the error, loaded into ghci, and now it WORKS. what?
16:48:15 <Gurkenglas> How would you combine two "Pipe a b"s with a "Pipe b c"? If the latter awaits, can it even know which of the former to await from?
16:49:04 <Gurkenglas> li4ick_, perhaps the version where you had the error was one where you had not saved the file you were loading?
16:49:25 <Gurkenglas> (Or you did not save just now)
16:49:32 <hpc> ghci doesn't fail for no reason
16:49:54 <Gurkenglas> Probably the former, because that transformation doesn't sound likely to make a difference of an error
16:50:28 <li4ick_> perhaps.
16:50:44 <Gurkenglas> Do you still have the undo history of your file and the error history of ghci? You could check whether an earlier state of the file would make the error make sense
16:51:32 <Gurkenglas> (Ideally, you are coding in eclipse and it writes down the times at which you save each file and how the file looked then)
16:51:57 <li4ick_> I use vim
16:51:58 <buttons840> Gurkenglas: yes, that function can throw exceptions, i usually call it through another function that handles the exceptions though
16:52:23 <Gurkenglas> buttons840, pageLinks only handles HTTPExceptions
16:53:06 <Gurkenglas> Dunno what vim has in that department - probably it's old enough that it couldn't afford keeping such archives?
16:53:24 <ertes> the problem is:  when you 'await' the wrapping combinator needs to make a choice as to which input to use…  it has to make that choice before even running either of them
16:53:50 <ertes> remember that pipes is *not* a concurrency abstraction…  it's a coroutine abstraction with the individual coroutines running in lock-step
16:53:58 <Gurkenglas> Hmk so you'll have to make the user provide that combining strategy
16:54:05 <ertes> yep
16:54:22 <buttons840> Gurkenglas: you could have the 2 formers pipes output to a "mailbox" from Pipes.Concurrent and then have the 1 latter Pipe read from that
16:54:35 <how> Let's say I have a finite type data Color = Red | Green | Blue. I want to have a map from Color to Int which is updated from time to time.
16:54:42 <Gurkenglas> So you can combine Pipe a b1, Pipe a b2, Pipe (Either b1 b2) c into Pipe a c?
16:54:50 <ertes> you can have a pipe which reads from an MVar or TQueue, but then pipes-concurrency appears…  pointless
16:54:51 <buttons840> Gurkenglas: I'm fairly new, so take what I suggest with a grain of salt
16:54:52 <hpc> how: updated how?
16:55:05 <how> Is there a better data structure to store the map other than Map Color Int
16:55:22 <how> hpc: ?
16:55:48 <ertes> how: Map Color Int looks fine to me
16:56:21 <ertes> how: with one caveat:  Map is inherently partial, so you need to have some kind of "default Int"
16:57:07 <how> ertes: but I know my mapping is complete
16:57:51 <hpc> you might also want to just pass around a (Color -> Int)
16:58:09 <how> hpc: that's what I'm about to say
16:58:25 <how> but wouldn't the function be slow after lots of updates
16:58:56 <hpc> that's the "updated how?" ;)
16:59:32 <hpc> but yes, if you build the updated function in terms of the previous functions
16:59:32 <ertes> how: you would have to wrap your function in more and more layers of updates without being able to get rid of irrelevant layers
16:59:52 <ertes> \f x -> if x == Red then 5 else f x
17:00:19 <marcx> is 60 ms normal time for ghc to check whether file needs to be compiled again on a pretty fast computer (i7)? a single file object that imports two modules? (System.Environment and Text.Printf)?
17:00:24 <hpc> it could also be that the way you update the color mapping is quite simple
17:00:28 <ertes> how: i'd go with the Map anyway and just choose a default Int, or even 'error', if you consider partiality a bug
17:00:46 <hpc> and you could do (Int -> Color -> Int) where the first Int is some sort of index into a continuous function of some kind
17:00:57 <how> hpc: Updated as in ertes's code
17:01:43 <ertes> how: well, you have only three colours…  one option would be to *replace* the function
17:01:47 <how> hpc: That wouldn't work if I need user input to update the map
17:02:39 <ertes> how: \f x -> let !xG = f Green; !xB = f Blue in case x of Red -> 5; Green -> xG; Blue -> xB
17:02:50 <Eduard_Munteanu> data ColorMap = ColorMap { red :: Int, blue :: Int, green :: Int }
17:02:56 <Gurkenglas> Pipes.Async should have Foldable f => f (Pipe a b) -> Pipe a b which runs each input pipe in parallel, awaits from the same source and merges outputs with a TQueue
17:03:00 <ertes> how: oh, wait, that's wrong
17:03:09 <ertes> how: \f -> let !xG = f Green; !xB = f Blue in \x -> case x of Red -> 5; Green -> xG; Blue -> xB
17:03:38 <Gurkenglas> (Perhaps generalized to Proxy, but I'm not sure how, though it sounds like it should be merely another queue?)
17:03:45 <ertes> how: call this function 'update', then you can do this:  let !g = update f in more
17:04:03 <ertes> how: at the point when 'more' is reached, g will have been evaluated and forgotten about f
17:05:20 <how> Eduard: that's one way I'm just asking here to see if there's a more elegant solution
17:06:02 <jmorris> why doesn't this work? http://lpaste.net/350699
17:06:31 <c_wraith> jmorris: it'd be easier to figure out with imports intact
17:06:46 <geekosaur> if that's the unhex I think it is, it wants you to specify an error monad
17:06:58 <ertes> jmorris: unhex :: (Monad m) => ByteString -> m ByteString
17:07:06 <jmorris> geekosaur: how do i do that?
17:07:12 <jmorris> c_wraith: I updated it
17:07:21 <ertes> jmorris: pick m = Maybe
17:07:26 <geekosaur> ^
17:07:27 <c_wraith> Man, I thought we were past error monads.
17:07:30 <how> ertes: Does this mean the function uses constant memory even after lots of updates
17:07:36 <ertes> c_wraith: the library is from 2011 =)
17:07:37 <geekosaur> yeh, its 2006 again
17:07:54 <ertes> how: yes
17:08:17 <c_wraith> I thought we were past error monads in 2011. :)
17:08:18 <ertes> how: it's equivalent to Eduard_Munteanu's solution, except without the explicit table type
17:08:37 <jmorris> is there some way I can do it with a case statement?
17:08:40 <c_wraith> They were starting to be seen as a bad idea when I started, back in 2008
17:08:48 <ertes> how: FWIF Eduard_Munteanu's solution is cleaner =)
17:08:52 <ertes> FWIW
17:08:54 <geekosaur> jmorris, short version is it uses a monad solely so it can call fail if the conversion from hex fails
17:09:07 <geekosaur> so you give it a Maybe or an Either or a list
17:09:30 <Rotaerk> what are "error monads"?
17:09:30 <geekosaur> and pattern match for the result or error return
17:09:37 <geekosaur> what I just described
17:09:38 <ertes> jmorris: what if the conversion fails?  your function wants to return a ByteString…  what ByteString will it return?
17:09:48 <ertes> Rotaerk:
17:09:50 <ertes> :t fail
17:09:51 <geekosaur> back in the day, Data.List.Lookup did the same thing
17:09:52 <lambdabot> Monad m => String -> m a
17:09:59 <geekosaur> er Data.List.lookup
17:10:10 <ertes> Rotaerk: an unfortunate legacy or early monadic haskell
17:10:11 <c_wraith> Yeah, lookup had changed by 2008.
17:10:15 <ertes> s/or/of/
17:10:16 <Rotaerk> k
17:10:38 <jmorris> case unhex s of ???
17:10:39 <Rotaerk> yea I noticed fail is a member of Monad, but it seemed ... redundant to me
17:10:49 <how> ertes: thanks a lot
17:10:49 <Rotaerk> never used it
17:10:51 <c_wraith> though, iirc, 2008 was the days of base 3 and base 4.  It's possible that was part of the upgrade to base 4
17:11:06 <geekosaur> case unhex s of Just s' -> s'; Nothing -> it wasn't valid hex
17:11:08 <ertes> jmorris: before you concentrate on *how* you want to do something, first answer the question of *what* you want to do =)
17:11:19 <ertes> jmorris: what ByteString will you return, if the conversion fails?
17:11:38 <marcx> > fix fail 
17:11:41 <lambdabot>  ""
17:11:58 <marcx> fail
17:12:20 <ertes> jmorris: "good question" is a valid answer
17:13:01 <jmorris> if I just put "error" it reads it as a [Char] not a bytestring
17:13:37 <ertes> jmorris: hexToBase64 "zzz" = ?
17:13:55 <jmorris> Nothing
17:13:59 <jmorris> because it is uneven
17:14:00 <ertes> jmorris: that's a type error
17:14:14 <ertes> jmorris: hexToBase64 :: ByteString -> ByteString
17:14:27 <jmorris> ertes: how do I write it as a bytestring
17:14:29 <jmorris> ?
17:14:41 <ertes> jmorris: the point is that your function should be of a different type
17:15:10 <ertes> hexToBase64 :: ByteString -> Maybe ByteString  -- for example
17:15:13 <jmorris> ByteString -> Maybe Bytestring?
17:15:18 <ertes> yeah =)
17:15:47 <jmorris> I think i got it
17:16:18 <jmorris> if i do Maybe ByteString the function can just be unhex s
17:16:33 <yenien> Happy new year
17:16:45 <ertes> jmorris: yep, but of course i assume that you want to do something after unhex
17:16:51 <jmorris> yes
17:17:11 <ertes> jmorris: the fmap function will be useful:  fmap :: (a -> b) -> Maybe a -> Maybe b
17:17:37 <ertes> > fmap (+ 5) (Just 3)
17:17:44 <lambdabot>  mueval-core: Time limit exceeded
17:17:45 <lambdabot>  mueval: ExitFailure 1
17:17:47 <jmorris> ertes: I want to encode it to base64
17:18:02 <ertes> @botsnack
17:18:02 <lambdabot> :)
17:18:04 <ertes> > fmap (+ 5) (Just 3)
17:18:11 <lambdabot>  Just 8
17:18:32 <ertes> jmorris: do you see how to use fmap to do that?
17:18:53 <jmorris> fmap encode (unhex s) ?
17:18:58 <ertes> exactly =)
17:19:09 <ertes> assuming:  encode :: ByteString -> ByteString
17:19:14 <jmorris> yeah
17:19:27 <jmorris> I got a working function but I don't know how to input a bytestring
17:19:32 <ertes> yenien: happy new year!
17:19:33 <jmorris> it always reads it as a string
17:19:45 <ertes> jmorris: use 'pack' (for now)
17:19:54 <ertes> import qualified Data.ByteString as B
17:19:56 <ertes> B.pack "blah"
17:20:15 <jmorris> does that mean the type should be String -> Maybe BS
17:20:22 <ertes> nope
17:20:26 <ertes> :t B.pack
17:20:29 <lambdabot> error:
17:20:29 <lambdabot>     Not in scope: ‘B.pack’
17:20:29 <lambdabot>     Perhaps you meant one of these:
17:20:35 <ertes> :t BS.pack
17:20:38 <lambdabot> [Word8] -> BSC.ByteString
17:20:43 <ertes> oh
17:21:20 <ertes> jmorris: well, here's a challenge:  a String is actually a list of *characters*, not *bytes*
17:21:27 <ertes> jmorris: so you need to choose an encoding now
17:21:34 <ertes> if you want to convert String to ByteString
17:22:27 <ertes> jmorris: choose between UTF-8
17:22:51 <monochrom> In fact, choose one of the following: UTF-8, UTF-8, UTF-8 :)
17:22:58 <ertes> =)
17:23:30 <monochrom> Also I thought we were done with unhex a week ago.
17:23:40 <jmorris> fmap encode $ unhex (B.pack s)
17:23:45 <jmorris> pack from char8
17:23:58 <jmorris> monochrom: me?
17:24:02 <monochrom> yes.
17:24:40 <jmorris> yeah, i wanted to start again because i stopped doing it a month ago after writing 2 functions
17:24:56 <briansteffens> is it possible to have a "composite" enum? for example, 'data Register32 = eax | ebx | etc..' and 'data Register64 = rax | rbx | etc..' and then combine them into 'data Register = Register32 | Register64' so that a Register could be eax | ebx | rax | rbx | etc? is there anything like this?
17:25:07 <ertes> jmorris: i recommend not to use the .Char8 module…  use the utf8-string library instead for all your String/ByteString conversions
17:25:32 <ertes> also i recommend a slightly more modern hex conversion library: https://hackage.haskell.org/package/base16-bytestring
17:26:15 <jmorris> ertes: i used fromString from UTF8
17:26:53 <ertes> briansteffens: data Register = R32 Register32 | R64 Register64
17:27:23 <ertes> briansteffens: example values:  R32 Eax, R32 Ebx, R64 Rax
17:27:27 <ertes> R32 Rax  -- type error
17:27:58 <briansteffens> ertes: interesting, is that some kind of aliasing?
17:28:43 <ertes> briansteffens: you might even consider doing this:  data Reg = Ax | Bx | …;  data RegPart = R Reg | E Reg
17:28:57 <ertes> briansteffens: valid values:  R Ax, R Bx, E Ax, E Bx
17:29:03 <briansteffens> ooh
17:29:08 <ertes> briansteffens: this is called algebraic data types
17:29:14 <ertes> fancy enum types =)
17:29:35 <briansteffens> neat :)
17:31:29 <jmorris> Base64.encode $ fst $ Base16.decode (B.fromString s)
17:32:23 <ertes> jmorris: that function returns an empty ByteString for "zzz"…  i claim that your function should still return Maybe ByteString
17:33:14 <ertes> jmorris: and you should not build B.fromString into this function
17:33:20 <ertes> it should take a ByteString
17:33:39 <jmorris> how can i make it take a bytestring?
17:33:51 <ertes> jmorris: by not using B.fromString
17:34:19 <jmorris> but if i do that, when I use the funtion it reads the input as [Char]
17:34:33 <ertes> jmorris: no, it does that right now
17:34:55 <jmorris> Base64.encode $ fst $ Base16.decode s
17:35:16 <jmorris> Couldn't match expected type ByteString
17:35:16 <jmorris>                   with actual type [Char]
17:35:30 <ertes> jmorris: did you change the type signature of your function?
17:35:35 <jmorris> yes
17:35:45 <ertes> ok, change it back to ByteString -> Maybe ByteString =)
17:35:56 <jmorris> ok
17:36:27 <ertes> jmorris: now read the documentation of Base16.decode: https://hackage.haskell.org/package/base16-bytestring-0.1.1.6/docs/Data-ByteString-Base16.html
17:37:05 <ertes> jmorris: the 'null' function from Data.ByteString will be useful here to decide whether to return a Nothing or a Just
17:37:48 <monochrom> what will happen to decode empty? :)
17:38:25 <jmorris> is null (snd s) then Just ... else Nothign
17:38:35 <jmorris> if^
17:39:18 <monochrom> This library is pretty neat
17:39:28 <monochrom> oh bos wrote it. no wonder.
17:39:37 <ertes> jmorris: yeah
17:40:15 <ertes> jmorris: err…  not quite
17:40:22 <jmorris> v
17:40:23 <jmorris> if null (snd (Base16.decode s))
17:40:33 <ertes> jmorris: you need to pattern-match on the result of Base16.decode
17:40:58 <ertes> jmorris: f s = let (t, rest) = Base16.decode s in …
17:44:02 <meoblast001> happy new years!
17:44:08 <Kuros`> u
17:44:11 <marcx>  cabal exec ghc helloWorld.hs takes 150 ms. is this normal? I am on i7 
17:44:15 <jmorris> ertes: http://lpaste.net/350701 ?
17:44:48 <marcx> seems like a lot of time just to parse cabal file and check whether file modification date changed
17:45:13 <ezyang> how long does ghc helloWorld.hs take? 
17:45:28 <ezyang> unfortunately, cabal is pretty slow 
17:49:56 <jmorris> ertes: I set overloadedstrings and i don't get that error message anymore
17:50:19 <marcx> ezyang 54 ms
17:52:04 <marcx> btw I am timing when no compilation takes place, because file hasn't been changed
18:09:14 <athan> Tuplanolla: I think I understand diodes: the resistance is dependent on the scalar (where parity is direction) of the current going through it
18:18:28 <athan> or maybe it's voltage. Who knows!:D
18:37:55 <orzo> my local hoogle install used to provide me links to my locally installed documentation
18:38:02 <orzo> now it goes to hackage
18:38:07 <orzo> i want to change it back
18:38:46 <orzo> from where is hoogle obtaining the links it provides with it's commandline output when you supply -l ?
18:53:51 <julianleviston> :t foldl (.) id
18:53:54 <lambdabot> Foldable t => t (c -> c) -> c -> c
18:56:26 <julianleviston> :t foldr (.) (\x -> Nothing)
18:56:28 <lambdabot> Foldable t => t (Maybe a1 -> Maybe a1) -> a -> Maybe a1
18:56:59 <julianleviston> I can pretty easily get the above… but is there a simple way to get to something like [a -> Maybe a] -> a -> Maybe a
18:57:14 <julianleviston> or even more generally, (Foldable t, Monad m) => t (a -> m a) -> a -> m a
18:57:37 <julianleviston> like… “built in” to some library?
18:57:59 <julianleviston> hoogle didn’t help too much
19:01:21 <Rotaerk> julianleviston, what should the result be?
19:01:41 <Rotaerk> oh nm I see
19:02:25 <Rotaerk> :t foldM
19:02:27 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
19:02:56 <julianleviston> foldM’s pretty different
19:02:58 <julianleviston> (I think)
19:03:29 <julianleviston> I’m interested in this to see if I can build up a set of prisms from a collection of other prisms
19:05:26 <Rotaerk> well, in [x -> Maybe x] -> x -> Maybe x,  b = x, a = (x -> Maybe x)
19:05:54 <julianleviston> yeah I realise that.
19:06:47 <julianleviston> oh wait on maybe I don't.
19:07:25 <julianleviston> No I don’t see that [x -> Maybe x] -> x -> Maybe x is the same shape as foldM
19:07:42 <geekosaur> :t foldl (>>=)
19:07:44 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
19:07:51 <Rotaerk> :t foldM (\x xtom -> xtom x)
19:07:54 <lambdabot> (Foldable t, Monad m) => t1 -> t (t1 -> m t1) -> m t1
19:09:04 <julianleviston> :t foldM (flip (.))
19:09:06 <lambdabot> Foldable t => (a -> b) -> t (b -> a -> b) -> a -> a -> b
19:09:21 <Rotaerk> :t foldM (flip ($))
19:09:23 <lambdabot> (Foldable t, Monad m) => a -> t (a -> m a) -> m a
19:09:25 <julianleviston> haha oops!
19:09:35 <julianleviston> right
19:09:48 <Rotaerk> :t (&)
19:09:50 <lambdabot> a -> (a -> b) -> b
19:09:57 <Rotaerk> :t foldM (&)
19:09:59 <lambdabot> (Foldable t, Monad m) => a -> t (a -> m a) -> m a
19:10:18 <julianleviston> where does (&) come from?
19:10:28 <julianleviston> Data.Function ok
19:10:46 <julianleviston> It’s just flip ($)
19:10:48 <julianleviston> right
19:10:52 <Rotaerk> yep
19:11:59 <julianleviston> Can I please download both your brains to mine? :)
19:12:00 <julianleviston> haha
19:12:22 <Rotaerk> 3 brains in one? the horror!
19:12:52 <julianleviston> I clearly need to understand foldM better :0
19:19:54 <codygman_> Is there a liftIO equivalent for pipes? For example, I need to get the current date inside of a producer but still want to have the same chaining interface with >->
19:22:02 <codygman_> Hm maybe just doing `now <- liftIO getCurrentTime` inside my producers function definition would work actually
19:22:05 <julianleviston> thanks by the way @Rotaerk and @geekosaur 
19:22:13 <Rotaerk> np
19:28:08 <codygman_> Oh, you just use lift too answer my question above. I guess because the base monad is IO
19:28:54 <orzo> i couldn't find how to fix hoogle so i wrote a script to massage it's output to give me links to local documentation
19:29:28 <orzo> sed and bash
20:13:21 <jonson> help
21:05:39 <mounty> What's the most Haskellish way of writing [Maybe String] -> Maybe [String] so that it yields a Just result iff all the components of the argument are also Just ?  The best I can come up with is:
21:05:42 <mounty> unify :: [Maybe String] -> Maybe [String]
21:05:44 <mounty> unify = foldr converge [] where
21:05:45 <mounty>     converge (Just a) (Just z) = Just (a:z)
21:05:47 <mounty>     converge _ _ = Nothing
21:05:56 <mounty> but I'm sure I saw something neater and more idiomatic.
21:10:56 <suzu> :t sequence
21:10:57 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
21:12:00 <suzu> that would do it mounty ^
21:12:38 <suzu> if you let t be the list []
21:12:45 <suzu> then the type is [m a] -> m [a]
21:12:55 <suzu> then if you let the Monad m be Maybe, you get
21:13:02 <suzu> [Maybe a] -> Maybe [a]
21:13:20 <suzu> iirc sequence (for list) is defined as
21:13:23 <suzu> sequence [] = []
21:13:37 <suzu> sequence (x:xs) = do { f <- x; return f : sequence xs }
21:27:17 <mounty> suzu:  sorry;  I looked away.  Yes;  that would do.  Thank you.
21:28:12 <suzu> :) np
21:31:57 <jle`> mounty: "flipping the functors" t (m a) -> m (t a) is a good hint that sequence might be what you want, in general :)
21:33:27 <nitrix> Happy new year! :)
21:34:09 <nitrix> May you have a bug free year 2017 :P
21:35:43 <jle`> :D
22:03:38 <imode> well, haskell folks.
22:03:46 <imode> first let me wish you a happy new year.
22:04:00 <imode> second, I am fully ready to be thrust into the world of curry-howard.
22:04:36 <imode> hopefully I won't be too annoying to any of you, but I'll have some questions as I go along, and I'd love it if you could answer them outside of my normal ability.
22:05:00 <Rotaerk> do you have any questions now?
22:05:10 <imode> not a one. just wanted to introduce myself! :)
22:05:17 <Rotaerk> ah, hi
22:05:41 <imode> actually, here's a question: what is the state of the standardization of haskell?
22:05:43 <sm> happy new year all!
22:05:49 <julianleviston> imode: good.
22:06:00 <julianleviston> imode: hehe… what do you mean tho? :)
22:06:06 <suzu> standarization of haskell?
22:06:19 <imode> yup! like, is there a standards document, a single reference implementation...
22:06:26 <julianleviston> the report, imode
22:06:38 <imode> I have ghc on my system. so knowing the state of the tooling + standardization will help if I have any odd questions about it.
22:06:40 <julianleviston> the “referene implementation” is GHC, pretty much
22:06:44 <imode> aha.
22:06:49 <julianleviston> reference*
22:06:54 <imode> are there any pros/cons between GHC and other implementations?
22:07:17 <julianleviston> imode: there aren’t really many other implementations. I suppose you could call hugs another implementation, but it’s not really used
22:07:42 <imode> interesting.
22:09:01 <imode> how would you compare Haskell to other languages like ocaml, standard ML, erlang et. al?
22:09:16 <imode> are there any killer features?
22:09:21 <imode> (I say that ironically.)
22:09:29 <julianleviston> imode: I guess you’d learn them all, then compare them. how would *you*?
22:09:39 <imode> not sure! just asked for an opinion. :)
22:09:53 <julianleviston> imode: why?
22:10:00 <suzu> i'd say the killer feature of haskell, is the type system
22:10:05 <sophiag> hi all. i'm having trouble to get ghci working with emacs haskell-mode after having to do a clean install of everything. i'm using stack at the moment and was getting some errors in the log, but then i tried updating stack and now it just says "No current directory." whenever i try to launch stack ghci from emacs. it still works fine from command l
22:10:06 <sophiag> ine tho so not sure what's going on...
22:10:14 <julianleviston> suzu: also a killer feature of idris?
22:10:21 <julianleviston> suzu: and ML?
22:10:28 <suzu> sure
22:10:29 <julianleviston> suzu: and OCaml?
22:10:34 <julianleviston> suzu: not erlang tho :)
22:10:43 <Rotaerk> the killer feature of haskell is haskell
22:10:47 <imode> julianleviston: mainly because it's interesting to hear people's opinions. we're all working in (relatively) the same base.. propositions as types, proofs as programs, proof trees as lambda expressions..
22:10:50 <suzu> i didn't say it was unique to haskell
22:10:52 <suzu> :P
22:10:55 <imode> so the only thing different is the tooling. :P
22:11:13 <sophiag> imode: lazy evaluation
22:11:15 <julianleviston> imode: the module systems are quite different.
22:11:20 <julianleviston> imode: typeclasses are quite different
22:12:07 <imode> interesting.
22:12:35 <julianleviston> imode: you can’t very easily do dependent typing in Haskell… sortof… there’s liquid haskell, and various extensions, but from what I’ve seen they make it quite complex to do dependent typing, when comparing it to another language that has it built in.
22:12:38 <systemfault> The main feature is that it's possible to do real world stuff with it :P
22:12:45 <julianleviston> lol
22:13:04 <julianleviston> systemfault: you can do real world stuff with OCaml just fine
22:13:13 <Rotaerk> julianleviston, are there any languages with it built-in that are more mature than haskell?
22:13:24 <systemfault> Sure, you picked the only other one :P
22:13:25 <imode> you can do real world stuff in many languages.
22:13:51 <julianleviston> Rotaerk: I only know of a couple that have dependent types “built in” - Idris, Agda… do you?
22:13:54 <systemfault> If you don't care reinventing the wheel, sure
22:14:02 <Rotaerk> nope, those are the only ones I was aware of
22:14:10 <systemfault> Haskell has a pretty good ecosystem IMHO
22:14:11 <imode> last I checked most languages don't reinvent the wheel.
22:14:22 <imode> 'tis why libraries exist. :P
22:14:24 <julianleviston> imode: I thought they mostly did.
22:14:51 <imode> I don't see how.
22:15:09 <julianleviston> imode: by re-programming things that exist in other language libraries?
22:15:29 <imode> uh, define "things" I suppose.
22:15:32 <imode> like, which things.
22:15:38 <julianleviston> imode: this is your topic. :)
22:15:59 <imode> obviously at some point I have to use the syntax of a language to work with libraries but I mean.. haskell does that.
22:16:12 <Rotaerk> imode, think they're basically just saying that the language must have the library support to allow you to do real-world things, and some don't, primarily younger languages
22:16:20 <systemfault> So... my plan for 2017. Find a way to use Haskell at work :/
22:16:22 <imode> ahhh.
22:16:29 <Rotaerk> even if the language has no inherent limitation on your ability to do real-world things
22:16:43 <imode> I see what you mean. you aren't talking about something like C or C++.
22:16:47 <Rotaerk> e.g. I think idris isn't near haskell yet, with regards to its real-world applicability
22:16:58 <julianleviston> Rotaerk: yeah, nowhere near.
22:17:28 <imode> I can see the real-world applicability of Haskell. the fact that it has a way of interfacing with the system isn't surprising, even Thue has I/O. :P
22:18:44 <Rotaerk> the real world applicability is an advantage that haskell has over some newer languages, but if you want to compare to something like C, other advantages come to mind
22:18:48 <julianleviston> imode: I think it’s more a case of… if you want to build a web server, you can totally do that with one of the web frameworks in haskell really easily and quickly… if you want to “x” you can, pretty much, because someone has made a library that will help you… where “x” is practically almost all the things most people want to be able to do with regards to programming computers.
22:19:18 <imode> julianleviston: I can also do that with a number of frameworks in other languages. I'm focusing on Rotaerk's point.
22:19:31 <imode> proofs as programs is a powerful idea.
22:19:39 <julianleviston> imode: is it?
22:19:41 <imode> much so that, once I started looking more into formal logic.
22:19:54 <imode> I couldn't really face my C compiler with a straight face. :P
22:20:29 <julianleviston> imode: not sure how you can get to useful programs that are also proofs in a language that doesn’t have dependent types, tho…
22:20:42 <julianleviston> imode: not that I know a tremendous amount about such things.
22:21:09 <imode> julianleviston: the correspondance between proof trees in natural deduction and lambda calculus expressions is one of the beautiful things about the curry-howard correspondance.
22:21:13 <julianleviston> it’s pretty exciting that dependent types are being worked on tho
22:21:41 <imode> you don't need dependent types, regular propositions in intuitionistic propositional logic serve as your types.
22:21:53 <imode> sum types are disjunctions, product types are conjunctions.
22:22:49 <imode> it's a very interesting piece of work because you ultimately turn your proofs of validity of propositions into lambda expressions encoding the same, valid derivations.
22:23:02 <julianleviston> I don’t know what the word “intuitionistic” means.
22:23:31 <imode> intuitionistic in formal logic just means you don't accept the law of excluded middle as an axiom.
22:24:00 <julianleviston> imode: so why do you need types at all then? why can’t you just use S and K?
22:24:18 <julianleviston> ;-)
22:24:35 <imode> julianleviston: well, there's a bit to that. you don't _need_ types, you just would like them to prevent inconsistencies.
22:24:48 <imode> lambda calculus, by church, was formulated as a logic. unfortunately it allowed you to prove absurdity via infinite formulas.
22:25:20 <julianleviston> imode: it’s difficult to see what you’re trying to express
22:25:25 <julianleviston> (for me)
22:25:33 <imode> no worries. too many things dumped off at one time.
22:25:42 <julianleviston> are you just saying “symbolic programs are beautiful"?
22:25:47 <julianleviston> yes, I agree :)
22:25:47 <julianleviston> lol
22:26:05 <imode> I'm saying that the fact that we can encode proofs of correctness of propositions in formal logic inside of lambda calculus expressions and then evaluate them is beautiful.
22:26:24 <julianleviston> lol @ hilbert’s comment: Taking the principle of excluded middle from the mathematician would be the same, say, as proscribing the telescope to the astronomer or to the boxer the use of his fists. To prohibit existence statements and the principle of excluded middle is tantamount to relinquishing the science of mathematics altogether.
22:26:27 <imode> https://www.youtube.com/watch?v=IOiZatlZtGU <-- this is a nice video on why it's beautiful.
22:26:57 <imode> not sure if wadler lurks these channels.
22:27:09 <imode> would be entertaining if he did, then I could thank him. :P
22:27:10 <julianleviston> yeah, I agree with that, but I’m not sure why it’s useful particularly, unless you’re interested in the expression of mathematical beauty.
22:27:38 <imode> well, the entire reason for Haskell's usefulness (as any FP language's usefulness) is its correspondance to proofs of correctness.
22:27:48 <julianleviston> I completely disagree with that
22:27:52 <imode> i.e if our compiler can typecheck it, we have constructed a valid proof.
22:28:00 <julianleviston> haha no way
22:28:05 <julianleviston> that’s just not true
22:28:16 <imode> welp, Wadler contributed to the design of Haskell, and that's what he says, so.
22:28:24 <imode> if you want anything past my word, that video explains a lot.
22:28:28 <sophiag> speaking of real world applicability...may i interrupt? i'm still stuck trying to figure out this "No current directory" error when trying to launch stack ghci from emacs haskell-mode :/
22:28:40 * imode backs away and gives sophiag the floor.
22:28:44 <imode> sorry!
22:28:46 <suzu> sophiag: how are you invoking it?
22:29:02 <suzu> are you using spacemacs?
22:29:03 <julianleviston> imode: I’ve watched that video a couple of times BTW.
22:29:15 <sophiag> C-c C-l
22:29:25 <sophiag> not spacemacs
22:29:25 <suzu> okay. i dont know, sorry
22:29:33 <imode> julianleviston: pausing for people who need help.
22:29:45 <julianleviston> imode: there is #haskellblah
22:29:52 <sophiag> i had the same setup and just had to do a clean install due to kernel panic and ended up switching distros
22:29:59 <sophiag> haven't changed my .emacs at all
22:30:06 <suzu> stack gave you a _kernel panic_?
22:30:09 <julianleviston> imode: oh, it doesn’t seem to exist anymore. oh well.
22:30:10 <glguy> sophiag: "No current directory" sounds like you've since deleted (even if you've recreated) whatever the current working directory was for your emacs seesion
22:30:26 <imode> sophiag: https://github.com/haskell/haskell-mode/issues/784
22:30:36 <imode> perhaps this is relevant?
22:30:38 <glguy> There's a command to change your CWD to something else. I don't know what it is specifically, though
22:31:19 <sophiag> imode: lemme see. i came up with a dead link on github before so maybe this will help :)
22:33:58 <nshepperd> julianleviston: i thought it was #haskell-blah
22:34:09 <nshepperd> haskell's type system is an inconsistent proof system, since ⊥ :: forall a. a
22:34:21 <julianleviston> thanks @nshepperd (for both your last comments)
22:34:27 <sophiag> hmm...i tried putting "'(haskell-process-load-or-reload-prompt t)" in my .emacs and it hasn't made a difference
22:34:41 <imode> nshepperd: isn
22:34:50 <imode> nshepperd: sorry. isn't "undefined" bottom in this case?
22:34:58 <nshepperd> imode: yeah
22:34:59 <sophiag> it's true the file isn't inside a cabal project, but i didn't have this issue before with stack and the same config file
22:35:10 <imode> nshepperd: so, how can we say it's inconsistent?
22:35:18 <nshepperd> but I think in some sense that "doesn't matter" since invalid proofs always evaluate to ⊥ and therefore don't have any "effect"
22:35:19 <imode> nshepperd: can we construct a proof of bottom?
22:35:47 <nshepperd> imode: you can construct a "proof" of any "proposition" (= an inhabitant of any type)
22:36:00 <nshepperd> (or kind *)
22:36:07 <nshepperd> (of kind *)
22:36:24 <imode> any valid proposition, rather.
22:36:37 <sophiag> ugh i keep getting dead links on github
22:37:12 <sophiag> it's like whoever maintains the haskell-mode repo deleted a whole ton of their issues :(
22:37:57 <imode> nshepperd: I am ultimately unable to "prove" bottom because.. well there are no subformulas of it.
22:38:33 <nshepperd> imode: 'fix id' is a bottom, also. one which doesn't terminate instead of throwing an exception
22:38:33 <jle`> well, in haskell, bottom is considered an axiom
22:38:54 <jle`> so it's taken as true in and of itself
22:38:54 <imode> right.
22:39:03 <imode> but I mean.. I am unable to derive it.
22:39:24 <nshepperd> bottom is a value (= a proof), not a type (= a proposition)
22:39:39 <nshepperd> I don't see why you'd want to 'prove' it
22:39:40 <imode> hence.
22:39:44 <jle`> yeah, you're not supposed to derive axioms
22:39:57 <jle`> you use them as the tools with which to build your systems
22:40:00 <imode> so how is haskell's type system inconsistent?
22:41:07 <jle`> there are several P where both P and Not P are inhabited
22:41:20 <jle`> in fact...for any given proposition P, but P and not P are inhabited
22:41:28 <nshepperd> imode: 'fix id :: forall p. (p, Not p)'
22:41:29 <jle`> so you can prove P and not P for any proposition P
22:42:02 <jle`> 'Not P' being 'P -> Void'
22:42:48 <jle`> so, given any proposition, it is possible to simultaneously both prove that it is true and that it is false
22:43:05 <jle`> s/both prove/prove both
22:43:12 <imode> interesting.
22:44:05 <imode> nshepperd: is that an example of such a proof? I haven't touched haskell much if at all (it's why I'm here! :)
22:44:58 <nshepperd> yes, that is a proof that p is true and that p is false
22:45:08 <nshepperd> (it's just an infinite loop)
22:45:48 <imode> that's interesting. fix being a function?
22:46:04 <jle`> fix f = f (fix f)
22:46:12 <jle`> (yes)
22:46:32 <imode> aha.
22:46:49 <imode> alright, I can see that.
22:47:09 <jle`> you can get more of an idea of how its' being used here by looking at the type
22:47:12 <jle`> :t fix
22:47:14 <lambdabot> (a -> a) -> a
22:47:22 <jle`> fix takes any (a -> a) and returns an 'a'
22:47:34 <jle`> id is an (a -> a) function, for any type a
22:47:45 <jle`> so fix id :: a, for any 'a' you want
22:47:56 <jle`> 'fix id' is a value that inhabits any 'a' you could possibly imagine or want
22:48:02 <jle`> :t id
22:48:05 <imode> inhabits. what do you mean by inhabits?
22:48:05 <lambdabot> a -> a
22:48:21 <jle`> True and False are values that inhabit the type Bool
22:48:28 <jle`> they are values of that type
22:48:30 <imode> ahh.
22:48:44 <jle`> so we see that 'fix id' *also* is a value of type Bool
22:48:51 <jle`> because if we use id :: Bool -> Bool, then fix id :: Bool
22:48:53 <imode> ah ah ah okay. it corresponds to bottom.
22:49:07 <imode> I see it now. I think.
22:49:18 <jle`> but, 'fix id' is neither True, nor False
22:49:32 <jle`> it's that extra inhabitant of Bool that nobody likes to talk about.  bottom
22:49:51 <imode> right. it's the thing that you can never fully construct.
22:50:05 <imode> you just end up in an infinite loop.
22:50:06 <sophiag> so this is really tough to troubleshoot because most of the issues on the haskell-mode github have dead links...
22:50:15 <sophiag> i just tried reinstalling haskell-mode
22:50:39 <sophiag> it asks me to create a cabal project whenever i eval something?!
22:51:29 <sophiag> at least it's back to throwing errors in the the log tho
22:51:51 <sophiag> this appears to be the problem: "Invalid option `--ghc-options=-ferror-spans'"
22:54:23 <imode> fascinating. thanks jle`, nshepperd.
22:54:36 <sophiag> does anyone know what that flag even means? google isn't being so helpful
22:54:44 <jle`> imode: no problem!
22:56:02 <sophiag> --ghc-options=-ferror-spans ???
22:56:50 <imode> sophiag: I don't see either on ghc or ghci.
22:57:18 <SamuelMarks> hi
22:57:19 <SamuelMarks> I've developed a new DSL for orchestrating deployments of distributed-systems. It's terrible. What makes a good one? - http://softwareengineering.stackexchange.com/q/339223
22:58:12 <sophiag> imode: see where?
22:58:18 <sophiag> i'm asking what it means
22:58:34 <sophiag> and/or why it's causing ghci to not launch from haskell-mode
22:59:03 <imode> I don't know what it means. I don't see the option --ghc-options as a valid option of ghc or ghci.
22:59:44 <sophiag> uh...ok...
22:59:59 <imode> so, I'm not sure what it's trying to pass "--ghc-options" to.
23:00:41 <sophiag> it seems you missed the background to this entire question
23:01:22 <imode> "this appears to be the problem: "Invalid option `--ghc-options=-ferror-spans'""
23:01:54 <imode> haskell-mode or whatever is trying to call a program with the command line options "--ghc-options=-ferror-spans".
23:02:03 <sophiag> it's calling ghci...
23:02:20 <sophiag> obviously ghc and ghci take that flag
23:02:23 <imode> okay. then perhaps it's trying to deal with an old version of ghci?
23:02:25 <sophiag> what else would?
23:02:41 <imode> because I don't see said option that's valid for ghc or ghci.
23:04:03 <imode> ghci --show-options | grep ghc
23:04:15 <imode> ghc --show-options | grep ghc
23:04:23 <sophiag> that doesn't answer my question
23:04:28 <sophiag> do you use haskell-mode?
23:04:48 <imode> if the thing is trying to pass --ghc-options to ghc or ghci, find where it's doing that, and remove it.
23:04:57 <imode> because the option is invalid.
23:05:05 <imode> and I don't. just trying to work it out with you.
23:06:05 <sophiag> no offense, but i could use advice from someone who actually knows what they're talking about...
23:06:55 <sophiag> it's cool you're thinking about getting into haskell, but that doesn't help me figure out issues with haskell-mode and stack-ghci
23:07:12 <imode> https://github.com/haskell/haskell-mode/blob/cde6c60b0e511a7e22290542c4e8e5bb9b253cd0/haskell-customize.el#L161 https://github.com/haskell/haskell-mode/blob/a027594bbcf509f6bcb22267553006341393b88f/haskell.el#L451
23:07:30 <sophiag> if by "the thing" you mean the the .el file for haskell-mode i'm pretty sure i don't need to go hack on that myself...
23:07:49 <imode> so it's trying to pass --ghc-options to Cabal, it looks like.
23:08:03 <sophiag> welp ignored
23:08:08 <imode> what the fuck.
23:08:30 <imode> okay, have fun wandering around until someone picks up your issue. god forbid I try to help you.
23:08:35 <sophiag> anyone who actually uses haskell and emacs and wouldn't mind a minute to answer this i'd appreciate it
23:09:01 <sophiag> very very certain i don't need to push commit to haskell-mode just to get it running...
23:09:04 <imode> sorry but you don't obviously know how to use your tools if you don't know how to solve this kind of problem.
23:09:05 <sophiag> yikes
23:09:17 <imode> and no, you don't. you just need to know what's being called. it's probably an old cabal version.
23:09:31 <imode> making stupid assumptions gets you stupid answers, or none at all.
23:09:39 <imode> have fun never getting help.
23:10:17 <zomg> sophiag: you ignored the only person trying to help you. I doubt anyone else is going to help you with that attitude :p
23:10:39 <imode> god forbid you ignore them too.
23:10:43 <zomg> Protip: people here are volunteering their free time to help you. If you act like a douche you won't get help.
23:11:18 <sophiag> zomg: that person came in here to ask whether they should consider using haskell...the advice given was i should edit the source code to haskell mode
23:11:34 <imode> uh, no, I never said that.
23:11:41 <imode> I was working through what was god damn called.
23:12:04 <sophiag> and whatever happened to #haskell-offtopic ?
23:12:17 <imode> you have three utilities. ghc, ghci, and cabal, and I was looking for which one it was to solve your damn issue.
23:12:33 <sophiag> shouldn't "i'm into logic, what's up with erlang?" for an hour be in that channel?
23:13:32 <sophiag> my attitude is one of coming in here to actually discuss haskell with people currently using it :p
23:13:43 <imode> god fuck you.
23:14:03 <imode> seriously. ask for help and work with the person helping you or fuck off.
23:14:15 <imode> if you don't want it why did you even ask.
23:14:50 <sophiag> i don't think following channel rules makes me a "douche"
23:15:28 <zomg> If the help you're getting isn't useful the solution is to say "thanks but this isn't going anywhere, I've tried this already and it didn't work"
23:15:36 <zomg> not "lol I'm going to ignore you because you're a noob"
23:16:05 <sophiag> i tried that and the unsolicited comments kept coming
23:16:07 <imode> at that point I'd say "okay, sorry it didn't go anywhere."
23:16:12 <sophiag> you're welcome to check the logs
23:16:16 <systemfault> zomg: Well, that's a typical sophiag pattern.
23:16:23 <zomg> systemfault: heh
23:16:28 <imode> systemfault: this has happened before? oh, good to know it's not me.
23:16:29 <systemfault> zomg: She's been quite a bitch on the react channel too... and a leech
23:16:38 <sophiag> lol what?
23:17:03 <sophiag> i've hardly ever been in the react channel...
23:17:16 <zomg> But still enough to attract the wrong kind of attention apparently
23:17:17 <zomg> lol
23:17:44 <Gurkenglas> imode, googling ferror-spans shows that there is such an option for ghc
23:17:50 <sophiag> yeah, actually i think that's the channel i got a rape threat in actually...
23:17:58 <imode> Gurkenglas: yup.
23:18:29 <imode> Gurkenglas: --ferror-spans is an option. but apparently haskell-mode is trying to call cabal with --ghc-options
23:18:50 <stdnt> happy new year all!
23:18:55 <systemfault> Happy new year!
23:18:56 <imode> happy new year, stdnt!
23:19:13 <imode> Gurkenglas: which is why it's failing on her end. and I was just trying to work out why but she ended up ignoring me.
23:19:15 <imode> so that's nice.
23:19:17 <Gurkenglas> Why do you think it's calling cabal? There are more than three utilities for Haskell
23:19:30 <lpaste> stdnt pasted “MapExperiment” at http://lpaste.net/350715
23:19:34 <Gurkenglas> "Additional arguments for `stack ghci' invocation." <- looks like the command that option is passed to is stack ghci
23:19:44 <imode> stack ghci?
23:19:55 <imode> ah.
23:20:16 <lpaste> stdnt annotated “MapExperiment” with “MapExperiment (annotation)” at http://lpaste.net/350715#a350716
23:20:52 <Gurkenglas> stdnt, line 9 has a tuple in the first argument, but line 7 has that tuple wrapped in Maybe
23:21:03 <stdnt> I couldn't make my Map script implementation type works anyone know why? thank you in advance :-)
23:21:20 <Gurkenglas> Perhaps you want (Just (unconstructedStart, unconstructedEnd)) in place of line 9's first argument?
23:22:27 <nshepperd> neither stack ghci nor stack ghc has a --ghc-options flag
23:22:40 <nshepperd> there's a --ghci-options though
23:22:48 <imode> yeah.
23:23:17 <imode> https://github.com/haskell/haskell-mode/blob/cde6c60b0e511a7e22290542c4e8e5bb9b253cd0/haskell-customize.el#L161
23:23:22 <imode> the source of the problem.
23:24:34 <sophiag> nshepperd: i'm not passing that flag explicitly, it's in the haskell-mode .el
23:24:37 <imode> Gurkenglas: I thought it was trying to call Cabal because of another file in haskell-mode that passed cabal --ghc-options.
23:24:54 <sophiag> and the error does say "ghc" not "ghci"
23:25:05 <imode> huh, no shit sherlock, as if I didn't point that out.
23:25:38 <stdnt> Gurkenglas: thank you very much!
23:27:23 <nshepperd> sophiag: yes, I think haskell-mode is just wrong
23:27:35 <nshepperd> there is no --ghc-options flag for 'stack ghci'
23:27:51 <sophiag> nshepperd: i never had issues with it before though...just after doing a new install of everything
23:27:54 <imode> careful, don't tell her that, she'll ignore you for "suggesting you make a pull request to haskell-mode".
23:28:21 <sophiag> i suppose it's possible they pushed an update during that time period
23:28:25 <imode> I'll stop.
23:28:29 <imode> but fuck you sophiag.
23:29:33 <Axman6> @where ops
23:29:34 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
23:30:09 <buttons840> Gurkenglas: regarding pipes-async (you commented on my stackoverflow question), pipes-async cannot run just one Pipe concurrently, it has to do at least 2, right?
23:30:42 <buttons840> i.e. (a >&> b) runs a and b concurrently?
23:30:51 <Gurkenglas> buttons840, that's how it's currently implemented, but surely the source code can be adjusted to not spawn a thread for a trivial pipe
23:32:05 <buttons840> it would make more sense to me to be able to say something like `concurrent a >-> b` and only a is concurrent
23:32:30 <buttons840> i think that's what your saying though ?
23:33:19 <Gurkenglas> And who does the work of b? The thread that `concurrent a >-> b` is called from? And I was imagining something like `(a1 >|> a2)`
23:34:10 <Gurkenglas> (Maybe the arrows ought not to point that way, but the &-|-duality is too delicious)
23:34:18 <sophiag> nshepperd: yeah...i just tried switching to regular ghci instead of stack-ghci and it's working fine so you seem to be right. ugh, going to see if there's an issue request for it already...
23:34:28 <buttons840> Gurkenglas: yeah, the threat that called would run b i would expect
23:34:51 <buttons840> thread*
23:35:10 <nshepperd> sophiag: 'stack ghci' stopped acceping --ghc-options as an argument in November 2015
23:35:40 <nshepperd> (has no-one at all been using haskell-mode with stack for a whole year?)
23:35:54 <imode> appears so.
23:36:18 <sophiag> nshepperd: unless i was running an old version of stack before (possible due to an old OS) then the timeline is more like a month so i'd think an issue with haskell-mode
23:36:37 <dibblego> imode: stop now please
23:36:43 <imode> dibblego: stopped a while ago.
23:36:51 <dibblego> thank you
23:36:53 <buttons840> so in something like `a >-> concurrent b >-> c`  b would pull things in as fast as possible to fill up it's internal "workers" and then yield the values out the other side in a non-deterministic order
23:37:27 <imode> dibblego: but let it be said that someone ignoring someone else when they're helping them because "you're a noob" is not acceptable behavior.
23:37:32 <imode> 's all I want made clear.
23:37:41 <sophiag> nshepperd: their github issues are scary long...
23:37:50 <dibblego> imode: stop right now please
23:38:07 <imode> not interested in continuing.
23:38:18 <dibblego> thank you
23:42:06 <sophiag> nshepperd: i see two people reporting the same issue a while ago except on windows and i'm on linux. but i think it's more likely this: https://github.com/haskell/haskell-mode/issues/1463. they may have *just* added that line and not know yet it breaks stack :/
23:42:50 <sophiag> oops, spoke too soon
23:42:52 <sophiag> https://github.com/haskell/haskell-mode/issues/1455
23:43:41 <sophiag> phew! thanks nshepperd
23:45:25 <sachin> Hello, all!
23:47:15 <sophiag> hi
23:59:37 <Liskni_si> nshepperd: there's still stack 1.1.2 in Debian (https://packages.qa.debian.org/h/haskell-stack.html) and stackage LTS (https://www.stackage.org/package/stack) so stack ghci --ghc-options still works on a lot of systems :-/
