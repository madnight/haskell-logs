01:17:57 <dmwit> ?tell mpcsh GHC.Natural is a slightly more native unbounded non-negative integer type. I don't believe there's anything lying around for strictly positive integers.
01:17:57 <lambdabot> Consider it noted.
01:20:16 <dmwit> ?tell mpcsh Oh, never mind. You already knew about that one under its other location (Numeric.Natural). I was confused and thinking that people had suggested the one that lives in Data.Number.Natural -- I can't keep those two straight.
01:20:16 <lambdabot> Consider it noted.
01:22:01 <dmwit> Fylwind: I believe the reason for having both Natural and Nat is the obvious one: Natural is much more efficient, but can't be lifted to the type level with the current machinery.
01:39:53 <utdemir> Hey. I'm trying to run a statically linked haskell executable on AWS Lambda. But I get "c_poll: permission denied (Operation not permitted)" error when trying to run the binary. Do you know what that error is about?
01:45:37 <dmwit> Why do we have both GHC.Generics.:*: and Data.Functor.Product.Product?
01:46:02 <dmwit> Same question for :+:/Sum and :.:/Compose
02:12:47 <sshine> with QuickCheck, is there a test function in-between 'quickCheck' and 'verboseCheck' that aids in printing what's being tested? like Hspec's 'it "blah blah" $ do { spec1; spec2; ... }'
02:15:02 <lyxia> dmwit: it seems they were moved out of transformers in base-4.9
02:15:12 <lyxia> dmwit: so, historical reasons
02:20:26 <lyxia> https://mail.haskell.org/pipermail/libraries/2015-July/026014.html for the proposal, which doesn't mention merging with Generics (that'd break a lot of stuff anyway)
02:31:57 <jchia> Can I get some comments on this code snippet? http://lpaste.net/350486
02:32:12 <jchia> is there a safer or cleaner way to write it?
02:41:52 <lyxia> looks fine
02:42:03 <srhb> jchia: Aren't you simply using it as map though?
02:42:53 <lyxia> A somewhat safer way is to use a fixed length container
02:44:05 <lyxia> but it's not as clean
02:56:03 <Gurkenglas> Why are there three separate arguments in the first place if you do the same thing to them
02:57:33 <dramforever> Can you just take a list in the first place?
02:58:09 <dramforever> And you can derive Traversable these days, you know
03:24:50 <jchia_> lyxia: How do I do it with a fixed-length container? I can't traverse a tuple.
03:27:08 <Gurkenglas> (with lens you can)
03:29:52 <lyxia> jchia_: data Triple a = Triple a a a deriving (Functor, Foldable, Traversable)
03:57:47 <jchia_> lyxia: Thanks
04:01:40 <ij> I can get parts of parsec's parse with <-. Can I get the whole of an expression without having to recombine 'em?
04:02:13 <sbrg> ij: if I understand you correctly, you can use Applicative.
04:03:06 <sbrg> do { p1 <- parseP1; p2 <- parseP2; return (Foo p1 p2) }    =    Foo <$> parseP1 <*> parseP2
04:03:51 <ij> Sorry, I meant the unparsed text that a parsec parser parsed.
04:04:15 <ertes> "the unparsed text that a parsec parser parsed"
04:05:02 <Ferdirand> oh
04:05:29 <Ferdirand> you want to get the original input that was consumed by a succesful parse
04:05:56 <ij> Yup.
04:10:38 <jaspervdj> ij: What are you trying to do?  If you are trying to store the input for error messages, it's often better to just store the (line, col) locations in my experience.
04:11:09 <ij> I was just wondering how would that problem be solved.
04:11:22 <Axman6> I've definitely seen one of the parser combinator libraries provide a way to do that
04:11:35 <ij> Or whether.
04:12:55 <ertes> you can look ahead (i.e. parse without consuming)
04:13:20 <ertes> then parse again…  if you observe the positions while doing that you will know how much to consume
04:13:37 <ertes> see e.g. attoparsec's lookAhead
04:20:50 <knupfer> What would be the type of a most general 'mean' function?
04:21:04 <knupfer> mean :: (Real a, Fractional b, Foldable t) => t a -> b
04:21:04 <knupfer> ?
04:22:06 <sbrg> I think the most general and mean function must be bottom
04:22:12 <sbrg> that's one mean sonuva
04:22:35 <knupfer> :)
04:22:48 <knupfer> Or would it be better to return a Rational?
04:23:25 <sbrg> Rational is an instance of Fractional
04:24:03 <knupfer> I know, but to be able to consume Integer and Double, I've to use Real, which I've to convert with toRational
04:24:28 <knupfer> So, if I use at the end fromRational I'll loose precision
04:25:10 * Axman6 points to his fold-statistics package
04:27:20 <knupfer> Axman6: That's surely nice, but specialized to Double, which is exactly what I'm trying to avoid
04:28:50 <knupfer> Thinking about it a bit more, the fromRational doesn't loose precision, only when later using it as Double, which would anyway require to loose precision
04:29:11 <dramforever> :t \xs -> sum xs / fromIntegral (length xs)
04:29:12 <Axman6> I've been considering reqriting it using edwardk's compensated package, so you can choose the precision
04:29:13 <lambdabot> (Foldable t, Fractional a) => t a -> a
04:29:24 <dramforever> :t fromRational
04:29:26 <lambdabot> Fractional a => Rational -> a
04:29:43 <Axman6> rewriting*
04:31:09 <Axman6> > let mean xs = let (Sum x,Sum n) = foldMap (\x -> (Sum x,Sum (1::Int)) xs in x / (fromIntegral n) in mean [1..1000]
04:31:12 <lambdabot>  <hint>:1:74: error: parse error on input ‘in’
04:31:25 <Axman6> > let mean xs = let (Sum x,Sum n) = foldMap (\x -> (Sum x,Sum (1::Int))) xs in x / (fromIntegral n) in mean [1..1000]
04:31:28 <lambdabot>  500.5
04:31:34 <knupfer> dramforever: If you use only Fractional, you can't give it Integers
04:33:00 <knupfer> :t \xs -> fromRational $ toRational (sum xs) / fromIntegral (length xs)
04:33:02 <lambdabot> (Foldable t, Real a1, Fractional a) => t a1 -> a
04:33:18 <knupfer> That's my guess at the moment
04:33:35 <knupfer> Note that high perf isn't required
04:33:38 <Axman6> that will have terrible performance btw, and terrible space usage
04:34:14 <Axman6> using foldMap in a single pass allows for deforrestation, using the usual sum xs / length xs means that xs must be completely stored in memoty
04:34:18 <Axman6> r*
04:34:26 <knupfer> Yes
04:34:57 <Axman6> this is one of the reasons why the foldl package exists, so you can write sum / (fromIntegral length)
04:35:56 <knupfer> Yeah, but it doesn't work for Rationals
04:36:11 <Axman6> not sure what you mean
04:36:13 <knupfer> (which I could convert)
04:37:41 <knupfer> I've to go, but I'll think about using your package. Thank you!
04:41:35 <jchia_> Gurkenglas: For the 'traverse' a tuple, do you mean something like this?
04:41:35 <jchia_> bar :: String -> String -> String -> IO (ByteString, ByteString, ByteString)
04:41:35 <jchia_> bar x y z = traverseOf each readFile (x, y, z)
05:01:27 <Gurkenglas> Yep. (Though you can write that as "bar x y z = each readFile (x, y, z)")
05:06:20 <samvher> has anyone here by any chance worked with cyrillic or other foreign character sets in haskell?
05:06:39 <samvher> I want to be able to use cyrillic in my source (at least in strings) but that seems to be a bit problematic
05:06:55 <lyxia> what is the problem
05:07:43 <samvher> I'm not 100% sure :)
05:07:58 <samvher> I'm developing a warp app (very early stage) and I want to serve a file containing cyrillic
05:08:17 <samvher> so I serve a string that contains "Привет мир!"
05:08:32 <samvher> but it does not seem to come through as UTF-8
05:10:01 <samvher> actually printing to the console is fine (putStrLn) so I guess the problem is with warp somewhere
05:11:16 <geekosaur> you may have to do the encoding yourself, since network connections typically use ByteString
05:11:33 <int-e> > text "☭☮"
05:11:36 <lambdabot>  ☭☮
05:12:28 <samvher> is that text :: String -> HtmlAttr?
05:12:37 <int-e> :t text -- no
05:12:38 <lambdabot> String -> Doc
05:12:43 <geekosaur> (also if you used Data.ByteString.Char8 to make things "simpler", you wielded the footgun.)
05:13:03 <samvher> so far I'm not using much at all
05:13:25 <samvher> just WAI, WARP and HTTP Types
05:14:05 <ij> If I want to change fixity of an ambiguous chain of operations in a formal language, I do that after the parser, right?
05:15:04 <ij> But it seems that it would be possible to do that inside the parser, but wouldn't that compilcate things?
05:16:23 <hexagoxel> if you can do it in the parser, it really is not an ambiguous chain (?)
05:17:03 <hexagoxel> i.e.: are the fixities known statically?
05:17:28 <jchia_> Gurkenglas: Thanks
05:18:17 <geekosaur> ghc patches up the AST after parsing, but it has to because Haskell lets you put the fixity declaration anywhere including after all uses of the operator
05:18:48 <ij> Right, so if I wanted that(declarable fixity), I'd have to do it after.
05:21:16 <geekosaur> if you know the fixities beforehand, both parsec/megaparsec and happy have ways to specify them as part of the grammar (see e.g. http://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec-Expr.html, or parsec equivalent module)
05:23:04 <samvher> I found it. WARP read my string as a ByteString but not as UTF8, I now import Data.ByteString.Lazy.UTF8 (fromString) which is in utf8-string, and use fromString to convert the text, this works
05:23:14 <samvher> thanks
05:24:46 <geekosaur> ij, it's also possible to encode fixity in parsec without using an expression parser, just more annoying because you need to carefully structure your parsing functions
05:34:25 <ph88> does stephen diehl ever pop up in here ?
05:40:10 <ij> Should I use Megaparsec?
05:40:27 <ph88> ij, i use it, can't tell you if you should use it though ^^
05:40:58 <sm> yes
05:41:22 <sm> ask a simple question, get a simple answer :)
05:41:33 <sm> morning all
05:41:37 <ij> :D 
06:03:18 <quuxman> so I ported my 1d continuous cellular automata demo from Haskell to JavaScript. It's now half the lines, more readable, is published on the web, can be edited interactively with the browser console, and runs at about the same speed
06:04:26 <quuxman> less buggy too because I'm using the canvas 2D context instead of OpenGL. I was getting crashes occasionally in Haskell
06:04:34 <quuxman> http://codepen.io/AbramClark/pen/pNXzym/?editors=1010#0
06:04:46 <hexagoxel> quuxman: great. and what is you question?
06:04:51 <hexagoxel> *your
06:05:23 <quuxman> it's not a question. I was just surprised how much easier and more elegant it was in JS, because usually the opposite is the case
06:06:17 <sm> quuxman: nice
06:06:47 <sm> woah. very nice :)
06:06:56 <quuxman> you can switch rules with 'rule = rules[4]' in console
06:07:29 <sm> your link is the js version, right ?
06:07:37 <quuxman> yeah
06:07:56 <quuxman> here's the version without the codepen UI http://s.codepen.io/boomerang/5443efd12026a52011aa5d78154749261482760796361/index.html
06:08:15 <quuxman> oh sorry broken link. I guess they randomize that per request
06:11:32 <quuxman> oh I named the rules, so now it's: rule = rules.1 .2 .3 or .pi
06:13:17 <quuxman> and now it's vastly easier to add UI widgets for manipulating the state. I've come to the conclusion that pretty much anything UI should be implemented in JavaScript
06:13:57 <quuxman> and anything involving serious data should be done in Haskell :)
06:14:19 <sm> lol, quuxman I misread your comment as the haskell being shorter than the js :)
06:15:00 <quuxman> This is the first fully ES2015 code I've written, where I've totally embraced all the new features
06:15:17 <sm> haskell can't beat js's ubiquity, but possibly you could write a better GUI DSL in it than in js 
06:15:19 <quuxman> the arrow function synatx is a huge improvement
06:18:13 <hexagoxel> quuxman: you could argue that the static safety which haskell provides is not as noticeable when (re)writing a known implementation, but rather when writing new code/prototyping/refactoring
06:19:03 <quuxman> I'm also hugely more experienced in js than hs
06:19:16 <hexagoxel> quuxman: out of curiosity: do you make use of js' untypedness? do you assign values of different types to the same vars?
06:19:42 <quuxman> hexagoxel: almost never
06:21:28 <quuxman> If you look at the js source it's arranged very similarly to the hs code. My big beef with Haskell is the difficulty in making UI and the greatly reduced interactivity in developent. I'm still hoping to use it in web backends though
06:22:04 <zomg> hexagoxel: fwiw the best JS devs I know treat JS as if it had stronger types even though it doesn't :)
06:22:21 <hexagoxel> quuxman: did you link the hs version?
06:22:28 <zomg> while you don't get compile time checks, it does make the code easier to reason about when things don't get assigned and casted randomly :P
06:22:34 <quuxman> hexagoxel: http://lpaste.net/350455
06:22:39 <hexagoxel> ty
06:23:40 <quuxman> hexagoxel: the haskell version is prettier and more elegant until you get to the graphics, and then it really goes down hill. To be fair opengl is a very low level API that's not really meant to be used directly
06:23:49 <shapr> GHC 8 is so much friendlier than GHC 4 or 5
06:24:01 <shapr> Haskell is so much better, w00t!
06:24:16 <sm> quuxman: indeed, there must be something better
06:24:31 <sm> gloss ? diagrams ? SDL ?
06:24:39 <apriori> shapr: in what way?
06:24:40 <srhb> shapr: Been out of the loop for a while? :-P
06:24:43 <quuxman> sm: you'd think, but I spent quite a few hours reading alternatives and trying to install and compile suggestions on the web and here, and got nowhere
06:24:45 <hexagoxel> quuxman: i agree with the "interactivity" aspect. this has become more and more important for me too.
06:24:49 <apriori> and ghc 4,5 is literally ages ago
06:25:10 <shapr> srhb: nah, just remembering how much stuff ghc5 didn't have
06:25:17 <sm> quuxman: oh indeed, I can imagine setup is still painful
06:25:33 <quuxman> I tried to install gloss, gpipe, and luminance, and none of them would install or compile with the examples
06:25:43 <hexagoxel> although i rather focus on getting quick feedback loops from my haskell setup :)
06:26:07 <srhb> shapr: Ah, I never experienced that, jumped in at the end of 6, I think.
06:26:20 <apriori> quuxman: try lambda cube
06:26:30 <sm> for web interactivity, the ALON project on github apparently reloads back and front ends for you on file change
06:26:46 <shapr> apriori: ghc8 has piles of usability improvements compared to ghc5, type holes, strictness annotations, CallStack, it's a long list
06:27:07 <apriori> shapr: yeah, I actually never experienced ghc 5
06:27:26 <shapr> srhb: I bet you're happier with ghc8 than with 6?
06:28:23 <shapr> I'm pretty sure I used ghc4, but I can't swear that's true, I know I got started sometime in 2000
06:29:01 <apriori> quuxman: for really simple 3d graphics, try "not-gloss", which is pretty much gloss in 3d
06:31:54 <srhb> shapr: I am, definitely!
06:33:19 <shapr> srhb: Got a random feature you like in the newer versions? I love using type holes.
06:33:44 <shapr> apriori: what about you? random ghc feature you like?
06:34:06 <apriori> BangPatterns :P
06:34:19 <srhb> shapr: That was one of my favourites as well. I'm beginning to take a great liking to the stack trace facilities too, though!
06:34:28 <xa0> @pl \a -> f . g a . c
06:34:28 <lambdabot> (f .) . (. c) . g
06:34:37 <sm> shapr: helpful "did you mean..." suggestions 
06:34:52 <xa0> @pl \a b -> f . g a . c b
06:34:52 <lambdabot> ((f .) .) . (. c) . (.) . g
06:35:39 <xa0> nasty stuff :p
06:36:09 <apriori> shapr: and yes, type holes rock. so many times I twisted my mind about what to pass in a bigger function call chain.
06:36:18 <sm> srhb: how are you using the stack trace features ?
06:36:32 <shapr> I've never used bangpatterns, time to go read up on them.
06:36:54 <srhb> sm: Basically as described in the Simon Marlow blog post: http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
06:37:05 <srhb> They're so cool :-)
06:37:44 <srhb> You can s/trace/traceStack and immediately get going without any real work. :)
06:38:00 <sm> will check it, thanks!
06:38:46 <shapr> apriori: I suspect my AoC solutions could be faster with bang patterns, thanks!
06:38:55 <apriori> np :)
06:39:20 <apriori> shapr: there was also a global, module-wide marker added
06:39:31 <apriori> don't recall the name. it switches to strict default semantics, afaik.
06:39:49 <MarcelineVQ> -XStrict and -XStrictData
06:40:13 <grazie> I want to move stack to an external harddrive. would it be sufficent to set $STACK_ROOT in the shell to that external dir anytime I want to use haskell?
06:40:24 <grazie> (I'm on Mac os)
06:55:52 <ggVGc> can I print things on multiple lines with Debug.Trace?
06:56:31 <mmaruseacph2> yes, use unlines or inserts \n's into the string
06:56:47 <mmaruseacph2> trace (unlines [show a, show b]) (a, b)
06:57:12 <ggVGc> didn't work for me
06:57:20 <ggVGc> it just prints the newline characters literally
06:57:21 <mmaruseacph2> or trace (printf "Value of a = %s\n" $ show a)
06:58:47 <mmaruseacph2> just tested the unlines one, it works
06:59:34 <mmaruseacph2> same for the printf one
06:59:45 <orion> Does -fllvm make sense to use on libraries, as opposed to executables?
07:00:44 <ggVGc> hm, thanks
07:00:47 <ggVGc> I'll try again
07:03:47 <praveen> I made a simple webapp with WAI + Warp. I belive Wapr is a web sever just like Ngnix. Do I any other compoent to deplay this app on ubuntu serveer?
07:03:51 <geekosaur> orion, ... what do you imagine is going on, that that question makes sense?
07:03:55 <praveen> I made a simple webapp with WAI + Warp. I belive Wapr is a web sever just like Ngnix. Do I any other compoent to deplay this app on ubuntu serveer?
07:04:17 <praveen> I made a simple webapp with WAI + Warp. I belive Wapr is a web sever just like Ngnix. Do I any other compoent to deplay this app on ubuntu serveer?
07:04:19 <praveen> exit
07:11:02 <orion> geekosaur: Certain flags only make sense on executables, like rtsopts. However I suppose it makes sense to pass -fllvm on both executables and libraries, because code generation is taking place in both cases.
07:11:34 <geekosaur> yes
07:13:35 <geekosaur> (I was wondering if you thought it would be saving only LLVM bytecode or something, and only doing 'lld' for executables. that only makes sense for LTO, and currently there's no point in attempting that because nobody has taught LLVM how ghc-generated LLVM IR works.)
07:15:36 <orion> geekosaur: I see.
07:16:43 <praveen>  
07:17:41 <shapr> praveen: yes, warp and nginx are both web servers.
07:18:28 <ertes> praveen: you could use nginx to route between multiple haskell web apps, but a haskell web app is actually fully fledged web server on its own
07:18:30 <OliverDeOliveira> Good morning/evening/night everyone
07:18:44 <shapr> greetinsg OliverDeOliveira 
07:18:47 <shapr> How's code treating you?
07:19:03 <OliverDeOliveira> In a gentle way
07:19:22 <Shockk> I couldn't read praveen's message presumably because it was colored black, I just thought it was a blank message
07:19:43 <OliverDeOliveira> I just began my studies on this theme
07:20:08 <OliverDeOliveira> The purity of haskell stuns me
07:20:23 <geekosaur> the most recent one was blank, you missed the original typo-ridden one sent 3 times in quick succession (and I'm still surprised freenode's spambot didn't strike)
07:20:29 <Shockk> ohh okay
07:20:39 <praveen> ertes: I just a one app. I read yesod docs on deployment. it suggest many ways to deploy. But I am looking for simple solution.
07:21:00 <praveen> I think I will try to deploy only using warp
07:21:30 <shapr> OliverDeOliveira: yup, the big idea of Haskell didn't get watered down with real world constraints in the way that happens to most things.
07:22:09 <OliverDeOliveira> Shapr yes
07:22:26 <praveen> sorry about posting 3 times. my weechat client wasn't reponding. and I kept pressing  Enter
07:22:35 <ertes> praveen: yeah, that's the simplest deployment "strategy"
07:25:05 <shapr> sm: I'm almost catching up to you on AoC
07:31:04 <sm> shapr: aiiee!
07:31:25 <sm> I had to stop burning hours on it :)
07:32:27 <shapr> sm: I can understand that :-)
07:32:36 <sm> shapr: I *might* be a little faster next year.. hope so
07:33:01 <shapr> Yeah, same here. I started 8 or 10 days in, and I think you started even later.
07:37:46 <sm> things I've learned more about from AoC: stack, quickcheck, hashing, ansi rendering, array, vector, fgl, data modelling, haskell code idioms, the list monad, graph theory, solution/path-finding
07:39:16 <apriori> sm: AoC?
07:39:23 <shapr> sm: wow!
07:39:30 <shapr> apriori: adventofcode.com
07:39:40 <shapr> apriori: you can get on the #haskell leaderboard with the code at the end of the topic
07:39:52 <apriori> shapr: ah, ok
07:40:06 <sm> megaparsec, here, working with a 2d grid (harder than it seems even with array/vector)
07:40:47 <sm> staying focussed, *stopping* being focussed :)
07:40:53 <shapr> I need to learn array and vector
07:42:30 <MarcelineVQ> I ended up using Map for grids becasuse it was easier, for me, to make changes to the indexes
07:44:03 <sm> choosing the right data structures, declarations & libs for optimal convenience/speed of development is a bit of an art
07:45:10 <sm> I found type synonyms usually the most convenient, and often wished I could give them proper Show instances
07:45:39 <sm> (avoiding the built-in ones, which clash)
07:46:30 <mettekou> Is it possible to automatically derive Eq1, Ord1, Read1, and Show1 with GHC 8.0 for a type which is an instance of Functor?
07:50:00 <MarcelineVQ> I believe that in ghc 8.2 you can, dunno about currently
07:51:41 * ClaudiusMaximus guesses you need more specifics than Functor, because  instance Functor ((->) r)
07:54:28 <erisco> I wonder what the perf difference between  data X = X !Bool !Bool  and  data Y = TT | TF | FT | FF   is
07:55:21 <erisco> I am thinking the latter is probably better
07:56:43 <erisco> but more generally if it really explodes the number terms perhaps not… pure guesses though
07:57:47 <erisco> I am just thinking that in the former you're probably getting two jumps and the latter just one
08:07:51 <newToHaskell> hey guys
08:08:02 <newToHaskell> I have a quick question about curried functions
08:08:26 <xa0> I have a long answer about curried functions
08:08:40 <lpaste> newToHaskell pasted “curried” at http://lpaste.net/350498
08:09:03 <newToHaskell> haha i understand its central to haskell
08:09:39 <newToHaskell> but i kinda get how it works, if u look at my lpaste, i dont see how calling compareWithHundred with a parameter
08:09:48 <newToHaskell> will pass that parameter onto compare 100
08:09:56 <newToHaskell> but apparently it does?
08:10:43 <xa0> the return type of compareWithHundred
08:10:46 <xa0> is a function
08:10:51 <xa0> (a -> Ordering)
08:11:02 <xa0> so when you apply an argument, you're applying it to that function
08:11:32 <newToHaskell> right
08:11:52 <newToHaskell> what confuses me is it takes an input
08:12:07 <newToHaskell> but that input is never expressed in the function
08:12:18 <xa0> the return type of compareWithHundred
08:12:20 <newToHaskell> am i seeing this wrong?
08:12:21 <xa0> is a function
08:12:27 <xa0> (a -> Ordering)
08:12:46 <newToHaskell> oh
08:12:46 <xa0> in other words, when you call compareWithHundred, you get a function back
08:13:01 <newToHaskell> so the a in (a-> Ordering)
08:13:03 <newToHaskell> is not the input?
08:13:13 <newToHaskell> its expressing the signature of the function returned?
08:13:23 <xa0> you can think of it that way yes
08:13:31 <newToHaskell> that makes a bit more sense
08:14:36 <newToHaskell> ah i see now, compareWithHundred isn't taking an input parameter at all
08:23:46 <erisco> g x = f x  is the same as  g = f   this is called eta reduction
08:41:31 <shapr> sm: It turns out I wasted at least two hours yesterday on various bugs that would have easily been found by QuickCheck tests. I keep thinking I'll just hack up a solution, but I'm not sure I have enough free time to skip writing tests.
08:49:30 <kuribas> Is it possible to import a library that isn't in a package in ghci?
08:49:57 <kadoban> kuribas: :load it as a file?
08:50:35 <kuribas> kadoban: doesn't loading it remove the previously loaded file?
08:51:13 <kadoban> Probably ... maybe. I don't use ghci like that, not sure :-/
08:51:26 <kuribas> The usecase is for interactive debugging with another helper module.
08:51:44 <kuribas> But the helper module isn't interesting enough to create a package.
08:52:34 <kuribas> Just a quick hack to export my path as svg.
08:54:52 <geekosaur> possibly you can use :add?
08:55:39 <geekosaur> mm, or not. I don't think ghci likes that use case very much, unless you start it with all the source files
08:56:01 <geekosaur> oh wait, :load shows the same syntax so maybe it would work
08:56:15 <geekosaur> or :load Foo.hs Bar/Baz.hs ...
08:56:24 <kuribas> geekosaur: that works?
08:56:38 <geekosaur> :? seems to think it does
08:57:06 <geekosaur> and it's possible :add will also work the same way without losing your currently loaded module
08:58:14 <kuribas> oh, it seems that works, great!
09:02:03 <kuribas> strange, it doesn't really load the second file.
09:02:35 <geekosaur> considering the help says it should, that might be a bug
09:04:20 <ganya> If f :: a -> b and g :: b -> c and x :: a,  why can't Haskell infer that "g f x" should be "g (f x)" ?
09:04:46 <ganya> I understand that function composition is left associative by default
09:05:16 <ganya> But if there's a type error from the default associativity, shouldn't GHC guess the next alternative?
09:05:54 <geekosaur> consistency is a good thing, having the compiler guess at you is a bad thing especially if you change types around at some point
09:06:44 <ganya> But 4 extra keystrokes uggh
09:07:32 <ganya> Thanks for the input, though
09:08:58 <kuribas> ganya: that would be very confusing
09:09:24 <erisco> not only the compiler, but humans don't want to be guessing either
09:09:56 * geekosaur is remembering watfiv doing that... there's a reason almost nobody else picked up on it
09:10:00 <erisco> then any time we write  g f x   it is meaningless without a type sig, how annoying
09:10:13 <kuribas> ganya: that's what operator ($) is for
09:10:36 <ganya> I think I might prefer "g f" to mean function composition by default rather than function application
09:10:49 <ganya> But of course that would be a huge difference from Haskell
09:10:51 <erisco> what is function application then?
09:11:11 <ganya> I think you could overload it
09:11:19 <erisco> and then, if so,  g f x  would be  g . f . x
09:11:34 <erisco> so you'd have to write  (g f) $ x  supposing we choose $ for application
09:11:44 <erisco> but then that means  (g . f) . ($) . x
09:11:49 <erisco> what a disaster
09:11:51 <ganya> You could make x:: mean x:: () -> a
09:11:57 <ganya> x::a *
09:12:11 <ganya> So everything is simply function composition
09:12:54 <ganya> so g f x :: () -> c   :)
09:13:23 <erisco> while I like a function as much as the next person, that would be a bit much
09:13:52 <kuribas> ganya: function composition is a function (or operator), like it should be.
09:14:09 <kuribas> ganya: it's not primitive.
09:14:21 * geekosaur thinks about () -> a as the encoding of laziness in a strict language, and considers that could be *really* confusing
09:14:25 <ganya> Is function application primitve?
09:14:34 <erisco> yes
09:14:53 <geekosaur> (especially in a file with -XStrict)
09:15:32 <monochrom> Is the type of id a->a or is it ()->a->a now? Or even ()->()->a->a?
09:15:45 <ganya> id is still a->a
09:15:51 <geekosaur> how about a fold that produces a function?
09:15:54 <erisco> but id is a value
09:15:59 <erisco> so it has to be () -> a -> a
09:16:19 <erisco> how do you stop the madness
09:16:22 <ganya> Sure but there's a natural isomorphism (() -> a)   = a
09:17:08 <erisco> and () :: () -> ()
09:17:25 <monochrom> The broken idea "x::a means x::()->a" is based on the false dichotomy "there are non-function types and then there are function types"
09:17:50 <monochrom> To be sure the false dichotomy is true in many other languages. But it's pretty artificial.
09:19:03 <ganya> By "x::a means x::()->a", I just mean that everything is a function.
09:19:48 <erisco> then by your rule x::()->a means x::()->(()->a)
09:19:56 <kuribas> scheme has force and delay
09:20:15 <monochrom> There is a natural isomorphism () = ()->()->()->()->()
09:20:23 <erisco> :P
09:20:56 <monochrom> Oh great you know what, id :: (() -> () -> () ->()) -> (() -> ()) -> (() -> () -> ()) -> (() -> a) -> (() -> () -> a)
09:21:33 <monochrom> talk about natural isomorphism application and composition
09:21:42 <kuribas> (identity (delay (+ 1 2))) gives <promise>
09:22:21 <kuribas> (force (identiy (delay (+ 1 2)))) gives 3
09:23:46 <kuribas> That works only because functions in haskell are impure.
09:23:50 <kuribas> erm in scheme
09:24:00 <xa0> ..lol
09:24:30 <tsani> Free monad question: I'm trying to add a constructor to a free monad's pattern functor to accept an action in the monad as one parameter. An interpretation I have in mind for this constructor is to perform the nested action in some special way (e.g. catching exceptions). However I can't seem to get the types to work out.
09:25:13 <tsani> Is it possible to nest actions this way in the pattern functor in the first place? Or should I be doing something completely different to implement this sort of behaviour?
09:39:27 <shapr> argh, changing map to `parMap rdeepseq` does not improve my desktop experience!
09:40:14 <erisco> all your cores are belong to Haskell
09:40:26 <shapr> and now I have a space leak again :-(
09:40:36 <shapr> 42gb is too much
09:41:26 <shapr> neat, 778% CPU usage in the three minutes before I killed it.
09:41:33 <erisco> try hopping furiously ^.^
09:41:39 * shapr hops furiously!
09:42:26 <shapr> ok, that didn't work. hm
09:50:40 <madgen> Hey everyone. I know it is not directly a Haskell questions but do you know how to pass -l option when using "stack repl"
09:50:53 <madgen> When I use it within --ghci-options it seems to be ignored
09:51:59 <kadoban> madgen: At a guess, 'stack repl -- -l'  ?
09:52:31 <madgen> does not exist I'm afraid
09:52:59 <kadoban> What's -l ? What is it even an option to?
09:53:54 <kadoban> Oh I see, yeah stack repl doesn't support that.
09:54:18 <madgen> Lovely. No REPL for me then.
09:54:21 <madgen> Thanks!
09:55:53 <ClaudiusMaximus> shapr: in my experience parBuffer is usually what you really want over parMap
09:56:28 <shapr> I'll try that
09:57:16 <ClaudiusMaximus> shapr: parMap does the whole list in parallel, parBuffer rolls along the list in order doing a limited number in parallel at once
09:57:33 <shapr> Since I have only 8 cores, that does sound more useful.
09:57:41 <kuribas> tsani: better paste an example
09:59:05 <shapr> Especially since this code was eating 64GB+ in less than three minutes with parMap rdeepseq
09:59:08 <kuribas> the free package is unreadable without a degree in cathegory theory.
09:59:13 <fosskers> Do we have a canonical library for circular lists?
09:59:59 <erisco> > cycle [1,2,3]
10:00:02 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:00:44 <shapr> fosskers: if you find one, I'd like to use it.
10:00:58 <erisco> what operations do you do on cyclic lists?
10:01:00 <fosskers> erisco, true, but I'd like to ensure the objects are the same
10:01:19 <fosskers> XMonad-style scrolling that cycle back to the beginning
10:01:25 <_sras_> If I have a type synonym type Tsyn a = Tpoly (a Int) (a Int) (a Int) such that Tsyn Maybe ~ Tpoly (Maybe Int) (Maybe Int) (Maybe Int)?
10:01:26 <fosskers> I'm making a terminal app with Brick
10:01:44 <kuribas> > cycle [1, 2, 3] !! 3 == cycle [1, 2, 3] !! 27
10:01:47 <lambdabot>  True
10:01:49 <erisco> what do you mean by "the objects are the same"? are you saying 1, 2, 3 might not be 1, 2, 3?
10:02:11 <_sras_> can I have a type synonym, `type Tsyn a = Tpoly (a Int) (a Int) (a Int)` such that Tsyn Maybe ~ Tpoly (Maybe Int) (Maybe Int) (Maybe Int)?
10:02:24 <monochrom> No, they mean [1,2,3...] might not be [1,2,3...] :)
10:03:19 <monochrom> The real, unsaid question is probably "will it use O(1) space or will it use O(n) space?"
10:03:34 <fosskers> [a, b, c] may be stateful, it makes more sense to actually cycle back to the beginning if some operation like "next" is made on the final node
10:03:53 <fosskers> https://hackage.haskell.org/package/deque-0.1/docs/Deque.html
10:04:07 <monochrom> What is "stateful"?
10:04:22 <erisco> I am perplexed… how is it stateful?
10:08:25 <shapr> fosskers: are you doing AoC day 19?
10:08:45 <erisco> maybe we're actually talking about cyclic mutable arrays, or something like that?
10:16:58 <osa1> in pipes is there a shorthand for `yield x >-> pipe` ?
10:17:38 <_sras_> If I have a type synonym, `type TypSn a = a Int`, how can I use it to get an 'Int' type, ie use something like `id` function for a?
10:18:20 <monochrom> You can only come close. TypSn Identity.
10:18:58 <_sras_> monochrom: Can you please elaborate a bit?
10:19:45 <geekosaur> _sras_, you cannot make the a go away
10:19:56 <geekosaur> you can make it do nothing, but you can't make it go away
10:20:23 <geekosaur> (Identity Int acts just like Int, but is not the same as Int)
10:21:39 <monochrom> Look for the Identity type in Data.Functor.Identity
10:25:28 <_sras_> geekosaur: monochrom actually I am trying to use Opaleye, where the Table definitions have the form Table (Column a, Column b...). But when this Table come right of a left join, then the types need to be Table (Column (Nullable a), Column (Nullable b)...etc. So i am trying to find a way to toggle Nullable on/off infront of the base type.
10:26:45 <_sras_> geekosaur: monochrom The author of Opaleye have written this "Because left joins can change non-nullable columns into nullable columns we have to make sure the type of the output supports nullability.  We introduce the following type synonym for this purpose, which is just a notational convenience."
10:27:01 <_sras_> here https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasicTypeFamilies.lhs
10:27:31 <_sras_> But I am not sure I find the mentioned type synonym below that paragrah.
10:30:38 <monochrom> I don't know.
10:31:08 <Gurkenglas> osa1, is "pipe" in there supposed to stand for a combinator or a free variable?
10:31:39 <osa1> Gurkenglas: it's just something with type Pipes.Pipe
10:32:47 <geekosaur> _sras_, I think it actually means the type families declared at line 130
10:32:53 <Gurkenglas> That's not a type, but to your question: I'd be very surprised if here was a reformulation of those four tokens using three tokens
10:33:03 <Gurkenglas> -here+there
10:34:29 <Gurkenglas> If that's the only place using that pipe, since that pipe only ever and immediately receives one piece of input, why not hardcode that piece into it and make it a Producer?
10:45:18 <nagyf> exit
11:11:57 <shirt> _sras_: check out channel #haskell-opaleye
11:14:11 <xa0> https://i.imgur.com/Eolf9E6.png why
11:15:06 <pikajude> xa0: [Int] isn't the same as (forall a. [a])
11:15:13 <pikajude> because it isn't any a. It's Int
11:15:35 <xa0> why can't it be type-inferred that a i-oh the forall
11:15:35 <xa0> right
11:15:43 <xa0> implicit forall.. every times
11:15:48 <geekosaur> xa0, `result :: [a]` does ot mean you get to specify the a, it means the caller gets to say what it is
11:15:51 <xa0> yeah
11:15:54 <geekosaur> and you must abide b y the caller's choice\
11:15:54 <xa0> i get you
11:16:07 <xa0> i feel silly >_>
11:28:45 <onintza> Er, I'm looking to a apply a function to both elements of a tuple, I'm pretty sure I'm missing something because I can't find anything
11:29:04 <onintza> Why does fmap only apply the function to the second element?
11:29:29 <Tuplanolla> The types in a pair may differ, onintza.
11:29:47 <kadoban> onintza: Because that's the only thing that the Functor interface for tuples could really possibly do, based on types.
11:29:54 <Tuplanolla> :t join bimap -- Use this to apply a function to both.
11:29:56 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
11:30:33 <onintza> kadoban: i guess, but why is that the only thing it could do?
11:30:38 <onintza> why not apply it to both?
11:30:59 <onintza> Oh, because (,) is of kind * -> * -> *
11:31:11 <onintza> And a Functor can only be defined for * -> *
11:31:14 <onintza> Right?
11:31:19 <kadoban> onintza: Yep
11:31:34 <onintza> also, thanks Tuplanolla !
11:31:56 <kadoban> So you pretty much have to pick an element that's the "contained" one, in that metaphor, and the only one that easily works syntactically is the last one.
11:32:36 <onintza> kadoban: is there no data Pair a = (a, a)?
11:32:58 <onintza> That would allow to define a Functor that applies to both elements right?
11:33:01 <kadoban> onintza: No, but you could write one. (Can't use the () syntax, but otherwise you could)
11:33:10 <onintza> Oh, right
11:33:21 <kadoban> At least not one I know of. But yeah, sure you can do that. But then you can't use it like  Pair 5 "hi"
11:33:34 <onintza> Yeah
11:34:01 <foooz> is there any way to use `language-c` package to extract the C program AST with comments intact (eg, for doing doxygen analysis for high level codegen)
11:34:14 <Tuplanolla> Curiously you can also do the joining on the type level, onintza.
11:34:22 <Tuplanolla> @let newtype Join f a = Join {getJoin :: f a a}
11:34:25 <lambdabot>  Defined.
11:34:38 <Tuplanolla> @let instance Bifunctor f => Functor (Join f) where fmap f (Join x) = Join (join bimap f x)
11:34:41 <lambdabot>  Defined.
11:35:21 <Tuplanolla> > getJoin . fmap negate . Join $ (2, 3)
11:35:24 <lambdabot>  (-2,-3)
11:35:45 <onintza> That's pretty
11:36:16 <Tuplanolla> There's probably a lens to do this too.
11:36:27 <Tuplanolla> (The previous sentence is universally true.)
11:36:31 <onintza> Mh, would there be any problem with Join a f = Join {getJoin :: f a a}?
11:37:37 <onintza> Disregard that
11:38:32 <hits1911> I am trying to write a program to compute the smallest triangle number which has over 500 divisors. Here is what I have written : http://sprunge.us/HTKa?haskell . The code works but I wonder if it's a good haskell program. Is there any improvements I can do for code style or efficiency? Because I feel like it's not the optimal solution.
11:39:53 <Tuplanolla> Isn't it faster to find the divisors via prime factorization, hits1911?
11:40:26 <wayne> coprimes may be helpful here too
11:40:33 <kadoban> hits1911: You're really supposed to do project euler yourself ;)
11:41:14 <foooz> nm, i got `language-c-comments` to work.. seems to have been not building because of a stack bug or sth
11:41:43 <hits1911> doesn't prime facitorization only count "2" where all of "2,4,8" is needed?
11:42:07 <Gurkenglas> kadoban, if he already has the solution he should be allowed to ask for refactors
11:42:36 <isd> Re: style, if you were going to keep the existing algorithm, it might make sense to just re-write result as head $ filter (\n -> divisors n > 500) [1,2..]
11:42:40 <samvher> hits1911: shouldn't it just give 2 as a factor 3 times?
11:42:41 <hits1911> kadoban: I already have done it I'm just asking for improvements but I don't know if it's a problem.
11:43:42 <isd> withLen is superfluous
11:44:08 <Gurkenglas> hits1911, given the set of nonzero exponents of prime factors in the prime factorization of n, you can already find ns number of divisors
11:44:22 <kadoban> Gurkenglas: Most of them aren't very hard to write a solution for, as long as you don't care if it ever completes. Is that code actually fast enough to wait for an answer? I'd suspect it's going to take ... quite a while.
11:44:29 <Gurkenglas> *the bag
11:45:14 <Gurkenglas> kadoban, he said it works, you think he checked it for small numbers?
11:45:38 <kadoban> Gurkenglas: Well, "works" is ambiguous.
11:45:48 <hits1911> I checked for small number less than 500, namely 100.
11:45:49 <isd> Honestly, a lot of the things that feel at a glance like brute-forcing should be infeasible are actually totally not. This is "only" quadradic in the value of the result.
11:46:08 <isd> That's well within the range of "run it on your laptop and go get a snack."
11:46:12 <Gurkenglas> Ah well, shame on me.
11:46:26 <osa1> Gurkenglas: that expression looks like `return x >>= f` which can be simplified as `f x`, that's why I'm asking.
11:47:49 <Gurkenglas> osa1, it connects the output of the pipe that outputs exactly x exactly once to all of the input slot of the second pipe, barring it from ever getting more input
11:48:19 <hits1911> I'll consider your suggestions and try some more. Thanks everyone for helping.
11:48:55 <geekosaur> isd, in a sense it is cheating, though. Project Euler isn't so much about programming as it is about number theory
11:50:27 <Gurkenglas> osa1, the analogy to f x is good though - Instead of writing await in the second pipe, just use x.
11:51:05 <Gurkenglas> (Instead of the first await, that is)
11:55:34 <isd> geekosaur: granted, but that was mostly in response to the assertion that it would effectively never finish.
11:55:40 <isd> It's totally not in the spirit
11:57:19 <isd> But you absolutely *can* do it.
11:59:09 <isd> I really wish if they were giving you data sizes for which brute-forcing isn't realistic. It's somewhat less exciting to come up with a clever solution when the practical software engineer part of my brain knows I could have gotten to a solution in 1/10th the time if I'd just done the stupid thing.
11:59:23 <isd> Even I know that's not the point.
11:59:25 <geekosaur> some of this is that it's a fairly old project and computers have caught up with it
11:59:47 <hits1911> I believe all of PE questions are possible to be done within 1 minute. So my solution is not really a solution. 
11:59:48 <isd> How old are we talking?
12:00:02 <samvher> often the earlier ones are brute-forcable, and later there is a bigger variant I think
12:00:25 <samvher> so then it is actually kind of interesting to see that suddenly your stupid approach doesnt work anymore
12:00:41 <geekosaur> people were doing PE when I started learning Haskell 10 years ago, and I'm pretty sure it was old then
12:01:50 <isd> fair enough. Then yeah, moore's law + quadradic algorithms + exponentially increasing compute power...
12:02:50 <kadoban> isd: Exponentially increasing anything is bound to be limited, in the real world (and in practice moore's law is ... kind of dead).
12:03:09 <isd> kadoban: yeah, but if it was "old" 10 years ago, it was probably still relevant
12:03:27 <kadoban> Ah, then yeah fair enough.
12:13:51 <Lokathor> turns out notepad++ can do the one thing i want an editor to do with my code that most don't seem to
12:14:01 <Lokathor> it can just list all the functions in the current file in a sidebar
12:14:48 <geekosaur> M-x speedbar     :p
12:15:12 <geekosaur> (although I think haskell-mode didn't know how to feed it that information last time I tried it)
12:16:30 <kadoban> Lokathor: And it works in haskell too?
12:57:26 <parsnip> imenu i think
12:57:57 <parsnip> folding can serve a similar purpose
13:02:53 <cheshircat> also what about good old etags?
13:04:30 <mettekou_> Is there a way to use deriving-compat's deriveEq1 and pals for mutually recursive data types?
13:07:43 <mettekou> Oh, never mind, I think you can use them as long as you manually write the instances for Eq and pals.
13:52:01 <how> hi is it possible to have local type declaration?
13:52:58 <geekosaur> no
13:55:08 <how> ok thanks
13:59:02 <amx> Profpatsch: is the assembly at the congress already open?
14:01:34 <octarin> Hello. What does <− actually mean ? Is it generic syntaxic sugar depending of the context (eg. in do blocks or in list comprehensions) ?
14:02:46 <shirt> octarin: something like that, yes. it means different things in monad do block, arrow do block, and list comprehension
14:03:01 <ninedotnine> do blocks are basically generalized list comprehensions to any monad 
14:03:11 <geekosaur> and view patterns
14:03:16 <ninedotnine> so the <- is the same in those two contexts
14:03:33 <geekosaur> and in all of them, it is conceptually similar in that some notional action is performed, rather than just binding
14:04:43 <geekosaur> in list/monad comprehensions (this is a ghc-ism) and monadic do, it translates roughly to the (>>=) operator
14:08:03 <ertes> forever $ mask $ \unmask -> do …  -- ugh…  that's so ugly
14:12:14 <suzu> could do forever . mask $ 
14:16:59 <ertes> suzu: nope
14:20:04 <hashme> hey guys
14:20:21 <hashme> what is ghc-mod actually used for?
14:20:24 <ibouvousaime> hey hashme
14:20:40 <hashme> is it mostly for linting purposes?
14:23:19 <geekosaur> it's generally used so editors can provide e.g. type information
14:23:31 <geekosaur> so, more of an IDE backend
14:28:14 <hashme> basically for plugins and other things for editors
14:28:27 <hashme> alright thanks! geekosaur :)
14:33:55 <lyxia> ertes: why not
14:34:37 <ertes> lyxia: because RankNTypes
14:34:55 <ertes> i would expect it to work (it's rank 3), but it doesn't for some reason
14:36:05 <ertes> even ($) only works because of a rewrite rule
14:36:45 <ertes> this doesn't work either:  forever `id` mask $ \unmask -> …
14:37:26 <ertes> oh!
14:37:57 <ertes> that was non-sense
14:38:03 <ertes> this doesn't work either:  forever $ mask `id` \unmask -> …
14:40:34 <suzu> really? that doesn't work?
14:40:45 <suzu> (forever . mask) \unmask -> do ... ?
14:59:13 <lyxia> oh I see.
15:01:05 <lyxia> ($) is black magic
15:01:18 <geekosaur> yes
15:07:25 <lyxia> https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcExpr.hs#L302 Yay I understand black magic.
15:12:12 <erisco> infix id… you're just being evil
15:19:45 <biglambda> How can I tell which version of cabal, stack is using?
15:20:27 <hpc> check the config
15:20:36 <hpc> or if you're desperate, stack cabal --version should work
15:22:00 <sm> stack exec -- ghc-pkg list Cabal; stack exec -- which cabal
15:26:21 <how> Is it possible to import modules within a function scope?
15:26:41 <glguy> no
15:31:53 <jfokes> Can someone point out to me the error in the following typeclass? It's not really meant to do anything other than take a value out of a context.
15:31:59 <jfokes> class (Monad m) => Should m where
15:32:00 <jfokes>   (>>==) :: m a -> a
15:32:00 <jfokes> instance Should Maybe where
15:32:01 <jfokes>   (>>==) (Just x) = x
15:32:38 <glguy> With that type you'll never be able to use (>>==) as an operator
15:33:06 <glguy> well, not never I suppose
15:33:39 <jfokes> Ha, so, I couldn't call (>>==) Just 5, and expect a return of 5.
15:33:47 <glguy> It's not great that your instance for Maybe is partial
15:33:58 <glguy> If you want that you'd write:   (>>==) (Just 5)
15:34:25 <jfokes> partial as in I didn't give an instance for Nothing?
15:35:00 <glguy> Yeah, you're missing a case so your function will fail for some inputs
15:35:13 <jfokes> Ok. I was missing the parenthesis around the Monad.
15:35:23 <glguy> (Just 5) isn't "the monad"
15:35:32 <jfokes> yeah, I'm learning that..
15:35:56 <jfokes> It's hard for me to grasp that.
15:36:43 <jfokes> The "monad" is the type which belongs to the typeclass "Monad", which in this case is Maybe, right?
15:37:30 <quchen> Yes.
15:39:49 <jfokes> So in the case of (>>==) why does Just 5 need to be in parenthesis?
15:40:06 <jfokes> I guess I am having trouble reading the following error
15:40:12 <jfokes> <interactive>:79:8:
15:40:13 <jfokes>     Couldn't match type ‘Maybe a0’ with ‘Integer -> t’
15:40:13 <jfokes>     Expected type: a0 -> Integer -> t
15:40:15 <jfokes>       Actual type: a0 -> Maybe a0
15:40:15 <glguy> Because function application is left-associative
15:40:16 <jfokes>     Relevant bindings include it :: t (bound at <interactive>:79:1)
15:40:18 <jfokes>     In the first argument of ‘(>>==)’, namely ‘Just’
15:40:20 <jfokes>     In the expression: (>>==) Just 5
15:40:23 <glguy> if you write:   f x y, that's   (f x) y
15:40:51 <glguy> Avoid pasting into chat. you can use a pastebin for that
15:41:42 <jfokes> I don't even know what pastebin is, but I'll look into it. 
15:41:46 <jfokes> Thanks.
15:42:00 <quchen> jfokes: You write an instance »Should Maybe«, and the »Should« class demands that for all its instances supply a function “>>==” with type »Should m => m a -> a«. So for Maybe, this means that “(>>==) :: Maybe a -> a”.
15:42:23 <quchen> Therefore, you need to map values of type »Maybe a« to »a«s in your definition of >>==.
15:42:36 <quchen> »Just« is not a value of type »Maybe a«,
15:42:37 <quchen> :t Just
15:42:39 <lambdabot> a -> Maybe a
15:42:54 <jfokes> Thanks! That makes a lot of sense.
15:45:14 <quchen> jfokes: Are you confused because the instance is for »Maybe«, but (>>==) does not take a value of type »Maybe«, but of »Maybe a«?
15:45:58 <quchen> That’s just something we can do in typeclasses; classes don’t need to use what we define instances for »directly«, as in »(>>==) :: m -> a«.
15:46:04 <quchen> In fact, that would be impossible to write.
15:46:18 <quchen> (Since there are no values of type Maybe)
15:46:42 <quchen> There are values of type »Maybe a« (namely Nothing), and there are plenty of values of type »Maybe Int«, but none of type »Maybe« alone.
15:47:07 <biglambda> hpc sm, thanks
15:47:46 <quchen> We say that »Maybe« is a type constructor – it takes an argument to become something that has values. »Maybe« can take an argument »Int« for example, and the resulting type »Maybe Int« has values Nothing, Just 1, Just 124, … 
15:47:51 <quchen> jfokes: ^
15:48:09 <jfokes> Right, parametric polymorphism, right?
15:48:42 <jfokes> the Maybe is an algebraic datatype?
15:49:05 <quchen> Maybe is a parametric type.
15:49:07 <jfokes> With type constructors.
15:49:14 <suzu> it is algebraic yes
15:49:21 <suzu> data Maybe a = Just a | Nothing
15:49:23 <glguy> "Maybe" is a type constructor
15:49:25 <quchen> Maybe is also an algebraic data type with *value* or *data* constructors.
15:49:35 <quchen> (Maybe a), rather.
15:49:53 <quchen> Ah, glguy is back, I’ll be quiet again :-)
15:50:03 <glguy> Type constructors are capitalized names of types
15:50:16 <glguy> quchen: You're doing fine, I'm just starting up Grid 2 for some racing :)
15:50:22 <jfokes> Maybe = Nothing | Just a
15:50:35 <quchen> Maybe a = Nothing | Just a
15:50:55 <jfokes> ^^
15:51:01 <jfokes> (thanks)
15:51:30 <rdococ> Maybe
15:51:42 <rdococ> :p
15:52:30 <quchen> ?karma c
15:52:30 <lambdabot> c has a karma of 2
15:52:45 <Zemyla> Okay, so I came up with a weird type, and am kind of wondering what it's good for and whether anyone's seen it before.
15:53:11 <Zemyla> newtype Sorted a = Sorted { runSorted :: (a -> a -> Ordering) -> [a] }
15:53:23 <Zemyla> It's a Functor, because all its occurrences of 'a' are covariant.
15:54:57 <quchen> jfokes: In (data Maybe a = Nothing | Just a), we define a *type constructor* »Mabye« that takes an argument to become a »type with values«. The definition of »Maybe a« gives us two functions, called »data/value constructors«: »Nothing :: Maybe a« and »Just :: a -> Maybe a«.
15:55:41 <Zemyla> It's also a Semigroup and Monoid, with Sorted ma <> Sorted mb = Sorted $ \cmp -> mergeLists cmp (ma cmp) (mb cmp)
15:55:47 <Zemyla> I'm pretty sure it's not Applicative, though.
15:58:17 <quchen> jfokes: In most languages, we can only talk about »types that have values«. In Java, we can talk about »Optional<Int>«, but we cannot talk about »Optional« alone. In Haskell we can! And it turns out this is really useful.
15:58:42 <quchen> As you said, »Maybe Int« is not a Monad – »Maybe« alone is!
15:59:31 <quchen> »Types that have values« are often called »of kind star«, just so you’ve heard the term for now :-)
15:59:56 <jfokes> So, the Maybe Int is said to be a value constructor?
16:00:01 <quchen> Like »5« is a value »of type Int«, we say that »Int« is a type »of kind star«.
16:00:06 <Zemyla> quchen: Except for the ones that are of kind #, but they don't need to know about that right now.
16:00:11 <quchen> No, »Maybe Int« is a type.
16:00:14 <quchen> Zemyla: Those are not Haskell.
16:00:37 <biglambda> I’m trying to build a stack project using a cabal file with build-type: custom. My Setup.hs file needs to import Distribution.MacOSX so that I can create a Mac app bundle. But… I keep getting a “Failed to load interface for ‘Distribution.MacOSX’ “ even though it’s seems to have built the cabal-macosx package. I’ve been googling and trying a bunch of stuff but I’m at a loss.
16:01:00 <quchen> jfokes: A value constructor is what you use to, well, construct values. Nothing gives you a value of type »Maybe a«, so it’s a value constructor.
16:01:25 <glguy> Nothing is a value constructor because it's a capitalized name at the value level
16:01:38 <quchen> Arr, got disconnected. Did anyone say anything in the last minute?
16:01:49 <quchen> jfokes: A value constructor is what you use to, well, construct values. Nothing gives you a value of type »Maybe a«, so it’s a value constructor.
16:01:58 <glguy> The only message between when I saw you leave and join was
16:02:00 <glguy> Nothing is a value constructor because it's a capitalized name at the value level
16:04:29 <quchen> jfokes: »Maybe Int« has values, but it does not construct them. It merely gives their type a name. »Maybe Int« is a value constructor just like »Bool« is a value constructor – it’s not! Bool has values (True and False, which are its value constructors), and (Maybe Int) has values (Nothing, and anything inside a Just), so Nothing and Just are its value constructors.
16:05:22 <quchen> jfokes: In general, value constructors are on the value level (inside expressions and computations), and type constructors are on the type level (inside type signatures).
16:05:40 <jfokes> ^
16:05:41 <glguy> Err; "Maybe Int" and "Bool" are types, not value constructors
16:05:52 <quchen> Did I say that?
16:05:55 <jfokes> That click quchen
16:05:56 <rdococ> I'm thinking about getting back into the Haskell "groove"... can someone direct me to some quick documentation? Most things I find on google are long tutorials and don't address what I need quickly.
16:05:57 <quchen> Let me reread then
16:06:01 <jfokes> clicked*
16:06:10 <sm> http://haskell-lang.org/documentation
16:06:21 <quchen> glguy: I think I hid the »it’s not« too much?
16:06:22 <rdococ> ty
16:07:05 <glguy> quchen: Oh I suppose I just misunderstood what you were trying to say
16:07:29 <quchen> I could have phrased it better. I hope it didn’t click the wrong way for jfokes ;-)
16:09:02 * geekosaur thought the phrasing was a bit unfortunate...
16:09:09 <jfokes> Haha: I liked the explanation of how value constructors are on the value level, and type constructors are at the type level.
16:09:23 <jfokes> inside the signature.
16:10:02 <ertes> jfokes: the value constructors (or often just constructors) of a type are what construct values of their type
16:10:11 <glguy> Right, there are "constructors" and "variables". Whether they are types or values has to do with where you used them
16:10:18 <ertes> jfokes: every Bool is of the shape (True) or of the shape (False)
16:10:33 <shapr> biglambda: maybe it's a path issue?
16:10:40 <ertes> jfokes: every (Maybe A) is of the shape (Nothing) or (Just x), where (x :: A)
16:13:53 <ertes> jfokes: we like to use the terminology "type constructor" more loosely…  sometimes we refer to types that take an argument (like Maybe)…  sometimes we just refer to types in general (so sometimes we'd call Int a type constructor)
16:14:01 <ertes> but value constructors are well defined
16:15:45 <glguy> The report's pretty clear about it, however. "Type constructor" is a category of names
16:16:28 <jfokes> It's funny, I haven't had this feeling since Philosophy of Logic: at some point I just can't follow anymore, but when I come back to it later after some time to think on it, it all makes better sense.
16:16:48 <jfokes> Lot's to think on. Thanks a lot!
16:18:51 <quchen> You’re welcome!
17:09:24 <Orbstheorem> Hello, can someone please explain me what does the '<+>' operator does
17:09:50 <Orbstheorem> I'm looking at xmonad configuration and in the wiki there is the expression
17:09:53 <Orbstheorem> manageHook = manageDocks <+> manageHook defaultConfig
17:10:41 <geekosaur> infix mappend
17:10:52 <Tuplanolla> @hoogle (<+>)
17:10:57 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
17:10:57 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
17:10:57 <lambdabot> Text.PrettyPrint (<+>) :: Doc -> Doc -> Doc
17:11:13 <geekosaur> what it actually does depends on what it's being used with, but in general it's combining hooks
17:11:44 <geekosaur> there is no standard definition for (<+>), different packages use it to mean different things
17:12:16 <joeyh> http://hackage.haskell.org/package/xmonad-0.12/docs/XMonad-ManageHook.html
17:12:39 <Tuplanolla> Why have I never seen this?
17:13:15 <geekosaur> originally it only worked for ManageHooks, and most people use composeAll [...] instead
17:13:25 <geekosaur> (composeAll being an alias for mconcat)
17:13:31 <joeyh> I've never seen it because I cargo-culted my xmonad.hs before I knew how to write haskell :)
17:14:32 <geekosaur> also Data.Monoid lifted it from xmonad, but because <+> is already in use in so many places it got renamed to <> there
17:15:15 <Orbstheorem> thanks :)
17:28:02 <Orbstheorem> just to check if I did understand correctly: a = b <+> c d e will first join b and c through '<+>' (call it x), then join x and d using '<+>' (call it y), then join y and e using '<+>' (call it z) and finally assign z to a
17:28:07 <Orbstheorem> it that correct?
17:31:24 <monochrom> Your words describe a = b <+> c <+> d <+> e
17:32:09 <monochrom> If I wrote "5 + sin 30" you would not be saying "that's 5 plus sin plus 30"
17:32:49 <Orbstheorem> :(, can you please explain me what does this means then: manageHook = manageDocks <+> manageHook defaultConfig
17:33:00 <Orbstheorem> what is defaultConfig?
17:33:09 <monochrom> No, explain "5 + sin 30" first. Then you'll know.
17:33:28 <Zemyla> Okay, I have a kind of "constrained sorting challenge".
17:33:44 <Zemyla> And I'm wondering if I should post it in /r/Haskell.
17:33:56 <monochrom> Toss a coin.
17:34:16 <Zemyla> Well, lemme see if anyone here has an answer.
17:34:56 <monochrom> But does anyone have the question?
17:35:48 <suzu> Zemyla: give us the challenge?
17:36:50 <Tuplanolla> If you garner enough interest, it'll solve itself automatically, Zemyla.
17:37:08 <monochrom> Or it'll dissolve itself. Just as good.
17:37:30 <Gurkenglas> No don't! We can't have the channel condoning conversations that are deliberately started with filler
17:38:02 <Zemyla> Suppose we have class (Eq r, Monad m) => Rearrangable r m | r -> m where { compareM :: r -> r -> m Ordering; swap :: r -> r -> m () } where compareM is antisymmetric, reflexive, and transitive; swap is symmetric; swap a b *> swap a b = pure (); swap a b *> compareM a b = compareM b a <* swap a b;
17:38:29 <Zemyla> And swap a b *> swap b c *> swap a b = swap a c.
17:40:10 <Gurkenglas> Doesn't yet sound like Data.List's sort will end up being a bad answer to whatever the question's going to be
17:41:36 <suzu> this is one complex premise
17:41:39 <suzu> ok go on
17:42:07 <Zemyla> Write a function rsort :: [r] -> m (), given that no two different values in the list are Eq, such that, for test :: (Rearrangable r m) => r -> m Bool; test (a:as@(b:_)) = compareM a b >>= (\c -> if c == GT then return False else test as); test _ = return True;
17:42:16 <shapr> Orbstheorem: it's likely just adding them together
17:42:20 <monochrom> What does "reflexive" mean for "r -> r -> m Ordering"? I only know what reflexive means for "r -> r -> Ordering"
17:42:54 <Zemyla> monochrom: If a == b, then compareM a b is equivalent to return EQ.
17:43:18 <monochrom> OK, so why can't I just delete m?
17:43:41 <Zemyla> monochrom: Because you can't just unwrap a monad. What if m were IO?
17:43:53 <Zemyla> Don't say unsafePerformIO.
17:44:03 <monochrom> Yeah, what if m is IO? Then what does IO add?
17:44:26 <monochrom> Why am I trapped in a monad?
17:44:38 <Gurkenglas> monochrom, the monad might add effects when a /= b
17:44:38 <monochrom> When comparison is always effect-free?
17:45:07 <Zemyla> monochrom: Because swap a b *> compareM a b = compareM b a <* swap a b.
17:45:26 <monochrom> OK, so what else is hiding behind "antisymmetric" and "transitive"?
17:45:51 <Zemyla> And compareM a b = (\c -> case c of { GT -> LT; EQ -> EQ; LT -> GT }) <$> compareM b a.
17:47:26 <Zemyla> A conforming implementation is instance (Ord a) => Rearrangable (STRef s a) (ST s) where { compareM ra rb = compare <$> readSTRef ra <*> readSTRef rb; swap ra rb = readSTRef ra >>= (\a -> readSTRef rb >>= (\b -> writeSTRef ra b >> writeSTRef rb a)) }
17:48:09 <Gurkenglas> You haven't explained transitivity yet. More importantly, you haven't finished the problem statement - what about test?
17:48:59 <Gurkenglas> (Shouldn't it be test :: … => [r] -> m Bool?)
17:49:36 <Zemyla> I said test :: (Rearrangable r m) => [r] -> m Bool
17:50:00 <Zemyla> For all ls :: [r], rsort r >> test r == return True.
17:50:56 <Gurkenglas> Equality to return True would require that rsort and test both do no effects, Zemyla
17:51:03 <monochrom> Yeah
17:51:25 <Zemyla> Gurkenglas: I actually gave the definition for test.
17:51:35 <monochrom> This is hiding OOP behind a monad. It is going to be madness.
17:52:07 <Zemyla> test :: (Rearrangable r m) => [r] -> m Bool; test (a:as@(b:_)) = compareM a b >>= (\c -> if c == GT then return False else test as); test _ = return True.
17:52:50 <Zemyla> Imagine it's an [STRef s a], except you can't directly readSTRef or writeSTRef on them.
17:52:51 <monochrom> I mean I certainly see how a JUnit test for sorting algorithms looks exactly like this, all inputs and tests and observations are mediated through effects, all methods are "void xxx(params)".
17:52:55 <Gurkenglas> Zemyla, right, and test uses compareM, so those uses will need to be effectless. Same for all the swaps rsort will presumably need to do. (11 minutes ago it was in fact typo'd as "test :: (Rearrangable r m) => r -> m Bool" fyi)
17:53:46 <shapr> I want to call it OOFP, because that a visceral sound to it.
17:54:18 <Gurkenglas> Okay, let's do the naive quadratic solution first
18:01:56 <Zemyla> @let class (Eq r, Monad m) => Rearrangable r m where { compareM :: r -> r -> m Ordering; swapM :: r -> r -> m () }
18:01:59 <lambdabot>  Defined.
18:02:47 <orion> What database backend does hackage use?
18:02:54 <Zemyla> :t traverse_ (uncurry $ \ra -> foldr (\rb c -> compareM ra rb >>= (\o -> if o == GT then swapM ra rb >> c else c)) (return ())) . mapMaybe uncons . tails
18:03:00 <lambdabot> Rearrangable r f => [r] -> f ()
18:03:20 <Zemyla> That's the naive solution.
18:03:59 <Gurkenglas> Was going for another one, but bumped into a problem where finding the swaps between [3,5,8,1,2] and [1,2,3,5,8] isn't actually that easy even if you know both lists
18:05:28 <Shockk> orion: from a very (very) quick glance, I would say it might use acid-state, but to what end, I don't know
18:05:32 <Shockk> I just glanced at this https://github.com/haskell/hackage-server/blob/master/hackage-server.cabal
18:06:03 <orion> Shockk: Thanks.
18:08:58 <geekosaur> acid-state is just an interface, though. haskell.status.io thinks it's backed by mysql
18:09:20 <Shockk> ahh
18:11:11 <Zemyla> Gurkenglas: But yeah, I want it to basically be usable even if, theoretically, it could be connecting to a bad MMO and manually sorting the contents of your inventory because the programmers didn't implement an autosort.
18:14:01 * ertes just created a PTY pair and fired up urxvt in a separate process to get a terminal for debugging
18:14:14 <ertes> i wish haskell-mode would ensure that GHCi gets an actual terminal
18:16:47 <ertes> my previous attempt was to write a mini-telnet server, but that turned out to be far more complicated
18:19:07 <how> Let's say I have data Dir = North | South | East | West and data Action = Forward | TurnLeft | TurnRight | Reverse
18:19:29 <how> What is the best way to write move :: Action -> Dir -> Dir
18:19:51 <how> without pattern matching 16 times
18:20:24 <ertes> write a separate function for one 90 degree turn, then use it 0, 1, 2 or 3 times
18:20:30 <ertes> how: ^
18:21:51 <how> ertes: thanks
18:22:08 <how> ertes: is there a more efficient solution
18:23:06 <ertes> how: if you write this in the most straightforward way, GHC will most likely optimise away the individual turns
18:23:33 <ertes> (check core to be sure)
18:24:28 <how> ertes: oh didn't know that do i need to pass in any flag for the optimization?
18:24:50 <ertes> how: just compile with optimisations turned on (default with cabal)
18:24:59 <Zemyla> how: Write data Dlr = North | East | South | West deriving (Enum) and data Action = Forward | TurnRight | Reverse | TurnLeft deriving (Enum).
18:25:02 <ertes> how: if you're invoking GHC directly, pass -O
18:25:39 <Zemyla> Then move a d = toEnum $ (fromEnum a + fromEnum d) `mod` 4.
18:26:28 <how> Zemyla: thanks! that seems like exactly what I want
18:27:16 <Zemyla> Better yet, have Dir and Action be newtypes wrapping Word or something, and use pattern synonyms to name the values.
18:27:22 <MarcelineVQ> Does Reverse change your direction?
18:29:23 * ertes is not in favour of replacing ADTs by integers, especially when there is no performance benefit
18:29:53 <how> MarcelineVQ: yes
18:29:54 <MarcelineVQ> ertes: what is the advantage for you of ghci in a terminal?
18:30:44 <ertes> MarcelineVQ: no, GHCi is not in the terminal…  it's running as a subprocess of emacs/haskell-mode, therefore it doesn't run in a terminal, which is a problem, because i need interactivity
18:31:49 <how> ertes: I may use a combination of your solution and that of Zemyla
18:31:53 <Gurkenglas> Zemyla, why not go through Data.List's sort and make everything monadic? I tried this at http://lpaste.net/808228221366566912 but apparently there's an "Ambiguous infix expression" and I can't find it.
18:32:21 <MarcelineVQ> Ah so it's a limitation of how emacs is running it? I've pretty much only run ghci by itself which is why I'm asking about what you're doing :>
18:32:38 <how> that is, derive Enum of Dir so I only need to pattern match two times for rotating 90 degrees
18:33:01 <Zemyla> Gurkenglas: Because you can't store extra copies of data?
18:34:04 <Gurkenglas> Zemyla, can you rephrase? If I understand correctly I'm merely "storing pointers"
18:34:25 <ertes> MarcelineVQ: yeah, although i might switch to vty at some point, and i don't know how well that would work with GHCi in the same terminal anyway =)
18:35:22 <ertes> right now i have a really awkward mini-REPL implementation that doesn't even handle cursor movement
18:35:52 <ertes> i basically need a REPL with stuff happening/printing async
18:37:46 <Gurkenglas> (And each "pointer" is in at most one place at a time anyway, Zemyla)
18:39:06 <MarcelineVQ> ertes: are you aware of -fexternal-interpreter ? it's probably the opposite of what you're working on but it's new so it bears mentioning just in case
18:40:19 <ertes> MarcelineVQ: yeah, that also came to my mind, but i couldn't make any use of that fact
18:40:54 <ertes> anyway, it works and is good enough =)
18:40:56 <MarcelineVQ> makes me wish I knew more about process communication and terminals
18:41:22 <ertes> i didn't really know much either…  honestly i just followed the mini-tutorial in the urxvt manpage =)
18:41:39 <ertes> and translated the perl example to haskell using the 'unix' and 'process' libraries
18:43:22 <geekosaur> sadly, I don't think you can make haskell-process.el use a terminal sanely; it's actually setting ghci's prompt to something binary so it can do a fake packet protocol 
18:46:11 <ertes> here is a template, if you ever need something like that, too: https://gist.github.com/esoeylemez/9b2a34c71bc18cc04049f7129060ce0e
18:50:10 <MarcelineVQ> complete tangent, but did you know you could specify threadDelay as 2e6 with -XNumDecimals?
18:51:28 <ertes> yeah, but each time i'm about to type another 7-digit constant i feel like enabling the extension needs more typing than hitting the 0 key 6 times =)
18:51:54 <MarcelineVQ> well, it's for the reader as much as you :> 12 0's is harder to scan than e12
18:53:06 <ertes> sure…  12 zeroes are also twice as expensive to type =)
18:53:48 <ertes> though instead of 1e12 i'd probably just type 10^12
19:00:41 <MarcelineVQ> good idea, looks like the difference is that 1e12 expands out to it's proper literal  1000000000000 instead of being recomputed each run.
19:01:10 <MarcelineVQ> not as though that's ever going to be an expensive thing to do
19:05:28 <ertes> MarcelineVQ: i recently checked: at least for Int and Integer GHC computes this at compile time
19:05:37 <ertes> (check yourself though)
19:05:54 <MarcelineVQ> the core didn't in ghci but I'm seeing if -O -O2 does atm
19:09:20 <orion> Has anyone noticed that Stackage nightly hasn't been updated in over 4 nights?
19:10:06 <geekosaur> ghci's known not to do any optimization
19:11:02 <geekosaur> (far as I can tell, optimization in the bytecode backend would be complicated, because it also has to work at TH time)
19:11:35 <MarcelineVQ> oh ho ho... that's interesting 2*6 is optimized to 12 but 2^6 is an application still
19:13:59 <MarcelineVQ> ^ this is with -O / -O2 where 2*6 is optimized
19:14:38 * geekosaur wonders if it has to do with totality
19:14:40 <MarcelineVQ> I wouldn't mind being wrong though if anyone else is interesting
19:14:43 <MarcelineVQ> *interested
19:15:09 <geekosaur> since (^) throws on a negative power
19:16:13 <exio4> or that (&) is recursive
19:16:26 <exio4> err, éxponentiation :P
19:56:38 <ertes> MarcelineVQ: weird…  have you tried with an explicit type signature?
19:56:57 <MarcelineVQ> I'm trying a few things right now, just looking at the src docs for (^)
19:57:05 <MarcelineVQ> with Int it's , which is even more interesting.  2^2 :: Int  it is reduced to 4, 2^4 :: Int is reduced to 16, however 2^6 :: Int or 2^16 :: Int is still an application
19:57:37 <MarcelineVQ> haha, okay.. appearantly there's rewrite rules for ^2-5
19:57:52 <MarcelineVQ> "^4/Int"        forall x. x ^ (4 :: Int) = let u = x in u*u*u*u
19:58:17 <MarcelineVQ> shoulda looked there first
19:59:37 <MarcelineVQ> ertes: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Real.html#%5E   Note [Inlining (^)  if you're intersted
20:05:43 <manek> Hello guys! What is the state of the art among monadic parser combinators in Haskell? Which is most feature-rich with backtracking, nice errors etc? Megaparsec / Trifecta / Earley / ... ?
20:06:32 <manek> I know the quetion is broad, I just want to know what do you think about the "new tools" here :)
20:08:24 <MarcelineVQ> uu-parsinglib may belong on that list too, no idea about the answer though
20:08:38 <c_wraith> Megaparsec is the most-used right now.
20:08:50 <c_wraith> ..  At least by people asking questions in here. :)
20:13:35 <defanor> i'm looking for an FTP client library, not sure what to pick; ftphs and curl weren't updated for years, though maybe there's nothing to update. any recommendations?
20:13:36 <manek> MarcelineVQ: If I remember correctly uu-parsinglib has got some performance problems that cannot be solved at the moment - there was a long discussion months ago with its author about it.
20:14:02 <manek> c_wraith: interesting. I've got to give it a try then, thank you! :)
20:23:47 <gamegoblin> Anyone have any better pattern than "if x then y else True"
20:25:28 <glguy> x && y
20:25:30 <glguy> err
20:25:34 <glguy> x || y
20:25:47 <glguy> nope, gotta think before pressing enter!
20:25:57 <jao> not x || y
20:25:57 <defanor> not x || y
20:28:56 <pavonia> x <= y
20:29:01 <lordcirth> The original looks clearer to mee
20:29:33 <defanor> can't install ftphs with ghc 8 because of dependencies, apparently bitrotten. will try curl
21:35:45 <anohigisavay> help... :'(
21:35:49 <anohigisavay> https://paste.pound-python.org/show/DDtbhCABrj54aiPZRaJI/
21:36:12 <anohigisavay> running Gentoo
21:37:25 <athan> tgeeky: Ping!
21:37:38 <anohigisavay> stack is installed from `wget -qO- https://get.haskellstack.org/ | sh`
21:37:44 <anohigisavay> not via portage
21:37:56 <tgeeky> athan: pong
21:38:00 <suzu> try the portage version anohigisavay 
21:38:11 <suzu> remove this one first
21:38:19 <athan> hey everyone, can a CCC's adjuction be represented graphically, for instance as a GUI for haskell?
21:38:50 <athan> specifically the `AxB -> C <=> A -> C^B` doodad
21:39:18 <athan> i feel like the diagram chase itself would be really hard to do
21:41:16 <athan> er - can there exist a representable functor from an CCC to... a category representing 2d pixels, which preserves all the stuff?
21:41:36 <tgeeky> athan: does section 6.2 of fpl.cs.depaul.edu/ajeffrey/papers/premonA.pdf help?
21:41:41 <tgeeky> I don't even understand the question yet.
21:41:52 <athan> oop hold up
21:44:03 <athan> :O tgeeky I think that works!
21:44:07 <athan> shoot I was wrong
21:44:18 <anohigisavay> suzu, the portage (gentoo-haskell overlay) only has version 1.1
22:28:12 <orion> Why is RFP so popular?
22:32:17 <sshine> orion, because a lot of domains are asynchronous?
22:33:20 <orion> s/RFP/FRP
22:35:25 <orion> It seems like it has only become popular recently.
22:47:31 <davean> by recently do you mean like 2002?
22:47:41 <davean> It seemed pretty popular back then too
22:51:43 <anohigisavay> Gentoo users, make sure to have the ncurses package with USE=tinfo (without it, stack will not be able to install GHC).
22:51:53 <anohigisavay> just found this in the document
22:52:13 <anohigisavay> unfortunately it's put under the section of Arch Linux _(:з」∠)_
22:54:02 <suzu> glad you found the issue
22:54:10 <suzu> you should just switch to arch though :D
22:54:18 * suzu is a former gentoo user, now on arch
22:57:36 <anohigisavay> suzu, i use both arch and gentoo. i run arch mostly on server machines. i suffer from network issues when installing stuff from AUR
22:57:46 <suzu> network issues?
22:58:11 <anohigisavay> suzu, mainland China, you know _(:з」∠)_
22:58:47 <suzu> heheh
22:58:57 <suzu> do VPNs work there?
22:59:34 <anohigisavay> suzu, must be lucky to find a working one, because GFW constantly add VPNs to its blacklist
23:00:07 <suzu> could you make your own?
23:00:18 <suzu> rent a VPS outside of china and install openvpn on it?
23:01:37 <anohigisavay> suzu, sometimes it just blocks an entire range of IPs. (all Linode servers were blocked once. not sure how it goes now)
23:01:44 <suzu> oh
23:01:54 <suzu> yeah i guess that'd do it..
23:02:14 <anohigisavay> now i'm paying for a shadowsocks proxy
23:02:24 <anohigisavay> at least i can switch servers 
23:03:07 <suzu> the gfw cant actually tell that you're using a vpn, can they?
23:03:20 <suzu> just that you're doing.. something that they can't read. so they'll randomly block you or such
23:04:05 <anohigisavay> technically it can tell. but even the government/banking corps cant avoid the demand of connecting to overseas VPN so they won't cut off everything
23:05:35 <anohigisavay> they just implement some machine learning algorithm (which has caveats of course :))
23:49:59 <kwantam1> coming into this late, but there's also been some work looking at how GFW identifies circumvention servers. Roya Ensafi et al have written some nice papers on this https://www.cs.princeton.edu/~rensafi/papers/Ensafi2015b.pdf
23:50:20 <kwantam1> (more generally, https://www.cs.princeton.edu/~rensafi/ )
