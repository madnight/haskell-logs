01:04:20 <inerkick> Hi Haskellers. Need some help in here.. I just followed this doc "https://docs.haskellstack.org/en/stable/install_and_upgrade/" .. To install Haskell on my Ubuntu.. It downloaded somewhere around 200Mb file i guess which is Selected resolver: lts-7.12. but not sure from there where to go ahead. Since when I follow "https://haskell-lang.org/get-started" this.. I get a statement saying It will again download  ghc-8.0.1 (x86_64) .. Now its' confusing what L
01:04:21 <inerkick> TS is and now why is it GHC downloading now.. Kindly help
01:05:50 <cocreature> inerkick: GHC is the standard Haskell compiler. stack downloads that automatically for you
01:06:17 <inerkick> So LTS which downloaded, was that included GCHI
01:06:36 <cocreature> inerkick: LTS stands for "long term support" and defines a set of relatively stable packages (at specific versions) that work together
01:06:48 <inerkick> when I give stack ghci I am getting this http://lpaste.net/349767
01:07:05 <cocreature> just run "stack setup" like it tells you to
01:07:29 <hashme_> hi guys, can you please look into this little code (of Project Euler Problem 27 solution implementation)
01:07:31 <hashme_> http://lpaste.net/349766
01:07:46 <inerkick> inside the folder or say any new project I'm doing. I just create a new folder and just do stack setup? cocreature 
01:08:03 <hashme_> If I implement the same thing in C, with two loops and Sieve (by storing it in an array), it gives me answer in less than a second
01:08:04 <cocreature> inerkick: you can just run it in the folder you are currently in
01:08:20 <inerkick> ok let me try
01:08:39 <hashme_> hi guys, can you please look into this little code (of Project Euler Problem 27 solution implementation)
01:08:40 <hashme_> http://lpaste.net/349766
01:08:47 <hashme_> If I implement the same thing in C, with two loops and Sieve (by storing it in an array), it gives me answer in less than a second
01:09:15 <cocreature> hashme_: please donâ€™t repeat your question every minute. just hang around for a bit and see if anybody answers your question
01:09:23 <hashme_> The primes are pre-computed in both haskell and C
01:09:42 <hashme_> cocreature: Oh sorry, that was by mistake
01:09:53 <inerkick> it states it is downloading again cocreature http://lpaste.net/349767
01:10:02 <cocreature> inerkick: just let it finish :)
01:10:12 <inerkick> will it each time download 100 mb?
01:10:22 <cocreature> no that will only be done once per compiler version
01:10:23 <inerkick> I don't have that much data to download!!!!
01:10:35 <inerkick> oh so what was that which is LTS
01:10:39 <inerkick> what that file does
01:10:49 <cocreature> I donâ€™t know what you are referring to
01:10:59 <inerkick> lts-7.12  version
01:11:08 <cocreature> you canâ€™t really download an lts
01:11:17 <cocreature> you download individual packages at the version specified in the lts
01:11:26 <lyxia> hashme_: can you paste the C program too
01:11:28 <inerkick> when I tried to install with stack, it downloaded around 200MN file which said lts-7.12 
01:11:44 <inerkick> 200Mb around it was
01:11:46 <cocreature> inerkick: do you have the exact output?
01:11:54 <lyxia> hashme_: what use is computing primes
01:11:58 <lyxia> hashme_: you don't use it
01:12:27 <inerkick> now , I don't have that.. cocreature ... but you can see it got lts-7.12. So I was wondering what did it downloaded than... 
01:13:18 <hashme_> lyxia: I found the mistake, I had to use checkPrime method instead of isPrime in quadraticPrimes method! I forgot to change it there
01:13:34 <MarcelineVQ> inerkick: I believe there is a package index that is downloaded to .stack/indices/Hackage that might be what that first download was
01:13:35 <lyxia> hashme_: indexing in a list is very slow
01:13:58 <lyxia> hashme_: it's quite different from an array.
01:14:02 <hashme_> lyxia: You dont have to check if everytime a given number is prime or not, that's why you pre-compute it - and keep in [Bool] list
01:14:09 <inerkick> Trust me "I" feel stack is more horrible concept.. Earlier through cabal it was far better. :-( Now nothing isn't clear what's happening behind the hood, what it is downloading and stuff like that.
01:14:38 <cocreature> inerkick: if you prefer cabal, then why not use it? :)
01:14:53 <hashme_> lyxia: I just started haskell and functional programming a few days back. I come from the imperative world :P So, yeah I used the list like an array datastructure
01:15:21 <inerkick> i will check it out again.. As many online guidance are pushing to use Stack, and it's so tough for cabal users to follow without knowing.. 
01:16:05 <lyxia> @hackage vector hashme_ 
01:16:05 <lambdabot> http://hackage.haskell.org/package/vector hashme_
01:16:13 <inerkick> It should be just one shot at installation.. Later yeah, it should be customization.. It feels like I installing microsoft :-D
01:17:12 <hashme_>  Alright :) thanks guys!
01:18:14 <hashme_> But what's the difference between lists, arrays and vectors actually (at least in Haskell, I knwo from C++ point of view)
01:18:38 <Bynbo7> haskell lists are singley linked lists
01:19:50 <Bynbo7> arrays are usually just a pointer to some contiguous piece of memory containing values of the same type, vectors are built on arrays and allow amortized O(1) append in most languages
01:20:09 <unskill> exactly
01:20:20 <lyxia> I meant "vector" to mean what the vector package provides
01:20:24 <lyxia> which is not at all O(1) append
01:21:01 <hashme_> Hmm seems to be the same in most languages
01:21:21 <hashme_> I haven't learnt the data structures part yet in haskell
01:21:27 <lyxia> the array and vector packages address many of the same use case, sequences of values with efficient indexing
01:21:38 <hashme_> Will be back with more questions probably :)
01:21:41 <unskill> Is IOUArray Int Int foldable?
01:22:01 <lyxia> You can only index vectors with Int, whereas Arrays can have different index types
01:23:36 <lyxia> unskill: it doesn't seem to be
01:24:25 <unskill> lyxia: the fastest way to get maximum from IOUArray? Currently I turn it into list by getElems
01:24:47 <Bynbo7> that's probably not any slower than any other method
01:50:07 <Cale> Bynbo7: That's only not slower if the list is somehow fused away. Writing a more explicit loop which avoids allocating that list might be better.
02:16:08 <b0llu> jle`, monochrom: how do I implement type-safe indexing?
02:16:20 <b0llu> I want a user to be able to index a matrix (as long as the index is "legal"
02:16:32 <b0llu> 0 <= rindex < r && 0 <= cindex < c
02:29:41 <EvanR> b0llu: you have to use types which express the less-than-or-equal-relation
02:30:08 <b0llu> EvanR: but how do I get them to be a constraint?
02:30:14 <EvanR> well, probably type class constraints 
02:30:23 <EvanR> because haskell
02:30:44 <b0llu> ah
02:30:47 <b0llu> TIL
02:30:52 <b0llu> I'm checking this out
02:30:58 <EvanR> here is an inductive definition of LTE
02:31:21 <EvanR> for all n, 0 LTE n
02:31:57 <EvanR> forall n, m, n LTE m implies s(n) LTE s(m)
02:32:01 <b0llu> hm
02:32:10 <b0llu> interestin
02:32:12 <EvanR> these can be two instances of the LTE class
02:32:13 <b0llu> interesting
02:33:22 <EvanR> instance LTE n m => LTE s(n) s(m) where
02:33:34 <EvanR> (body irrelevant)
02:33:56 <b0llu> right
02:34:05 <EvanR> it relies on the numbers being types, not values
02:34:21 <EvanR> s :: Nat -> Nat where Nat is a kind
02:35:44 <b0llu> EvanR: universe of types hurts my head sometimes :P
02:36:08 <EvanR> if we had dependent types, it would be simpler
02:36:19 <EvanR> n and m would just be type N
02:36:33 <EvanR> no kinds
02:37:06 <EvanR> and LTE would be an inductively defined predicate, a regular data type
02:37:49 <EvanR> btw you can build on the LTE class to define a Between class
02:38:08 <b0llu> hmm
02:38:15 <b0llu> I think I can see how
02:38:19 <b0llu> let me take a stab at it first
02:38:20 <b0llu> cool?
02:38:24 <EvanR> instance (LTE lower n, LTE n upper) => Between lower n upper 
02:38:28 <EvanR> oh
02:38:35 <b0llu> xD
02:38:39 <b0llu> issokay
02:41:08 <HKei> Hi, I've not really been keeping up with developments these past couple of months. How much of a thing is cabal 2.0 yet?
02:45:00 <Bynbo7> I haven't heard anything about a cabal 2.0
02:47:56 <inerkick> Hi.. Need some help. I'm trying to install haskell using stack. I got this issue. It is just stuck http://lpaste.net/4329462763924488192
02:48:00 <HKei> Bynbo7: I was talking about this: https://github.com/haskell/cabal/milestone/39 - I know it's not out yet, but last I checked some of the stuff it was supposed to bring was already there
02:48:04 <HKei> like new-build and such
02:48:15 <HKei> I was just wondering if anyone's actively using that
02:48:38 <Bynbo7> inerkick: that'd doing exactly what it's supposed to, what problem are you having?
02:48:43 <sbrg> inerkick: is it stuck?
02:48:48 <inerkick> yeah
02:48:53 <inerkick> it just stopped there itself
02:48:58 <inerkick> not completing 
02:49:04 <sbrg> is it the first time you tried'
02:49:09 <inerkick> yeah
02:49:18 <sbrg> if it is, just Ctrl+C and try running it again. or wait and see if it completes
02:49:29 <inerkick> ok
02:49:50 <inerkick> it started to download again :-(
02:49:54 <sbrg> yeah
02:49:58 <inerkick> for 0% .. Crap
02:50:19 <sbrg> unfortunately it doesn't cache the partially completed ghc download. though it caches most everything else
02:50:33 <inerkick> Horrible it is now. i have been trying to get haskell up and running since 3 times using stack. This is really hurting more than any installation 
02:51:26 <sbrg> inerkick: It's even odds that that issue is caused by bad network connectivity. FWIW, I just recently helped ~40 students get Haskell running using stack, and in 99% of cases, it was no issue at all
02:51:38 <inerkick> Stack is not for people who have weak internet and even we pay more :-(
02:51:42 <ab9rf> yeah, i've use stack to install ghc four times now, and it's never had a problem
02:52:03 <ab9rf> you might consider installing a local proxy server and telling stack to use it for http(s) transactions
02:52:05 <jedai> sbrg: 99% of 40 ? How do you get that result ? ;)
02:52:11 <inerkick> I often used apt-get . That was far far better I feel compared to stack :-( just y personal experience 
02:52:21 <ab9rf> inerkick: apt-get doesn't do what stack does
02:52:29 <sbrg> jedai: I don't consider all my students full human beings
02:52:36 <ab9rf> apt-get installs it in the system, stack installed it in a dev sandbox
02:52:37 <inerkick> I wish they improved using cabal than stack :-( ..
02:52:52 <Bynbo7> inerkick: your experience is certainly not normal
02:53:06 <ab9rf> i admit that having crappy internet makes stack less suitable
02:53:07 <sbrg> but no, so 97.5%, heh. one of them ran into issue with gcc using some hardening flags on ubuntu 16.10
02:53:09 <inerkick> I now need to pay more for using internet. I was using it in an internet shop.. 
02:53:33 <sbrg> inerkick: well, for subsequent uses, stack will reuse packages that it's already download
02:53:34 <sbrg> ed
02:53:36 <ab9rf> i can't imagine what stack would be like on my old 1200 baud dialup modem :)
02:53:47 <inerkick> yeah.. 
02:54:16 <inerkick> It's big hole in my pocket now. But hope this time it works and completes.. This isn't good man. Really, it's so hurts!!
02:54:28 <b0llu> I need help debugging type level encoding of nats: http://lpaste.net/349770
02:54:35 <b0llu> I don't understand why the natVal call is bugging out
02:54:38 <b0llu> help please?
02:54:43 <jedai> sbrg: I understand, Students are like the larval stage of humanity... (Yes I have been a student) Welp the PIE on ubuntu 16.10 is a problem, I hope they have that fixed ASAP
02:54:46 <b0llu> EvanR, jle`, monochrom: help?
02:55:16 <sbrg> jedai: yeah it's a bit unfortunate.
02:55:26 <sbrg> but on the upside, they have ghc working in the linux subsystem for windows now
02:55:55 <jedai> sbrg: Nice ! :)
02:56:07 <b0llu> EvanR: http://lpaste.net/349770#line89
02:56:09 <inerkick> whatever it be.. downloading a huge file online and installation along side it and it doesn't cache isn't so good
02:56:10 <b0llu> line 89
02:56:31 <sbrg> inerkick: it caches almost everything else. it even caches the download if it completes
02:57:16 <inerkick> lol. I just feel like, those atm machines wherein you put your card and it takes in and doesn't come out :-D
02:57:41 <b0llu> can I have some help with Proxy and type level nats, please? http://lpaste.net/349770#line89
02:58:05 <lyxia> spamming is bad b0llu 
02:58:18 <b0llu> lyxia: sorry :P
02:58:27 <b0llu> lyxia: a little desperate as the cafe is closing and I have no wiki
02:58:28 <b0llu> wifi*
03:00:44 <lyxia> your error puzzles me
03:00:46 <jedai> b0llu: how does it "bug out" ?
03:00:59 <b0llu> jedai: type error
03:01:04 <b0llu> jedai: error at the bottom
03:01:07 <b0llu> lyxia: ikr
03:03:52 <lyxia> b0llu: can you try import Data.Proxy, to make sure you were using the right proxy
03:03:57 <b0llu> sure
03:04:33 <b0llu> lyxia: new errors now
03:04:36 <b0llu> lyxia: so.. yay?
03:04:40 <b0llu> lyxia: okay, cafe is closing
03:04:46 <b0llu> lyxia: what type was it using?
03:04:50 <jedai> b0llu: Right, I don't know where your "Proxy" is coming from bu it probably isn't the right one
03:04:52 <lyxia> no idea
03:04:56 <b0llu> huuh
03:04:59 <b0llu> any way I can find out?
03:05:09 <lyxia> I'm guessing it comes from one of the symengines
03:05:21 <b0llu> I haven't bound anything called "Proxy" yet
03:05:23 <b0llu> hmm
03:05:28 <b0llu> is there a way I can find out for sure?
03:05:28 <lyxia> load your module, :info Proxy
03:05:44 <jedai> b0llu: you comment out all the code but imports then load your module and :info Proxy
03:05:50 <b0llu> I see
03:05:52 <b0llu> lemme do that
03:17:10 <slaterr> how can I supress this warning in a particular source file? "The import of `Control.Monad' is redundant"
03:17:33 <slaterr> suppress&
03:18:56 <ab9rf> don't import it twice?
03:19:24 <slaterr> i didn't import it twice
03:19:44 <ab9rf> are you quite certain?
03:19:46 <Bynbo7> if you're getting that warning you don't need the import
03:20:00 <slaterr> i do because i am using functions from the module in the repl
03:20:56 <ab9rf> the only responsible way to get rid of the warning is to remove the redundant import.
03:21:07 <slaterr> *yawns*
03:21:09 <ab9rf> you can suppress the warnings with a ghc flag, but that's not a good pratice
03:21:23 <maerwald> first time I hear that
03:21:25 <maerwald> and I disagree
03:22:16 <maerwald> try -fno-warn-unused-imports
03:23:06 <slaterr> is it possible to specify flags on a per file basis
03:23:39 <jedai> slaterr: you can put them into a pragma at the beginning of the file
03:24:00 <maerwald> slaterr: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/ch04s02.html
03:24:32 <slaterr> cool thanks
03:38:30 <b0llu> lyxia: there is no Proxy
03:38:48 <b0llu> lyxia: I think maybe it's some weird interaction of all the extensions I've enabled?
03:40:43 <lyxia> b0llu: oh indeed I get your error if I use a non-existing identifier with your extesions
03:40:51 <b0llu> hm
03:40:57 <b0llu> lyxia: do I file this a bug report?
03:40:59 <b0llu> or..?
03:41:23 <lyxia> oh it's just TypeApplications
03:41:27 <b0llu> ?
03:41:52 <lyxia> yeah that looks like a bug to me
03:42:35 <b0llu> lyxia: OK, let me repro it and file a bug report
03:42:56 <lyxia> I mean it's not an interaction. A type application of a variable not in scope gets this weird error.
03:43:57 <b0llu> oh
03:48:31 <jaziz> Alright bois
03:48:37 <jaziz> I wanna learn haskell and have fun doing it
03:48:53 <jaziz> could any kind soul link me to a text that'll get the job done?
03:49:08 <maerwald> @where learnhaskell
03:49:08 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:49:35 <Shockk> http://www.learnyouahaskell.com/ is quite nice, from my experience at least
03:49:45 <maerwald> no
03:49:50 <maerwald> don't use it
03:49:56 <jaziz> hahahahahaha
03:49:58 <jaziz> I like it
03:50:06 <maerwald> it won't get the job done
03:50:09 <jaziz> really?
03:50:11 <jaziz> it looks fun :(
03:50:12 <maerwald> yes
03:50:19 <jaziz> what does it fall short on?
03:50:41 <maerwald> exercises, in-depth explanations, conciseness, not being up2date
03:51:15 <maerwald> people like it because it has pictures and a wall of text. It's not a good resource though
03:53:05 <jaziz> but what about for a beginner just trying to get into it?
03:53:16 <maerwald> I just linked a proper resource
03:53:18 <maerwald> use that
03:53:23 <jaziz> alllrighty
03:53:46 <ab9rf> i don't like lyah much. the pictures are bizarre.
03:53:53 <ab9rf> and do not assist with comprehension
03:54:43 <AndreasK> Makes it seem more approachable though
04:15:06 <danpalmer> Hi all. I've asked on the Yesod channel a few times but it seems a bit dead, if anyone knows of a more relevant active channel do point me in the right direction...
04:15:18 <danpalmer> I'm trying to figure out a good way to structure a "large" application.
04:16:11 <danpalmer> (with Yesod). I'm finding that everything seems to end up in Foundation.hs, which doesn't really scale well. This is because everything seems to end up depending on knowing what the `App` type is.
04:17:01 <danpalmer> Handlers seem to get around this some way with something very clever that I don't really understand. If anyone could point me in the direction of a well structured Yesod app that doesn't have everything in Foundation.hs, I'd really appreciate it!
04:18:57 <inerkick> Kindly help: http://lpaste.net/6090167444230373376 .. Is this really installing?
04:23:02 <srhb> inerkick: Do you mean it's stuck at "Updating package index"... ?
04:24:24 <danpalmer> inerkick: looks like it's going ok, although I think the Yesod templates require a bit of manual work to get them to use GHC 8.x. There was an issue with `yesod devel` which I believe caused this restriction, but once the template has installed you should be able to lift the version restrictions on `base` and use 8.0.1
04:24:43 <danpalmer> (Unless you're on macOS Sierra, in which case it's a bit trickier, let us know if you are)
04:28:12 <Cale> danpalmer: I don't know about Yesod in particular, but quite often in applications, some central types end up being defined in their own module.
04:28:55 <Cale> (even to the exclusion of most of the functionality on those types)
04:30:39 <danpalmer> Cale: thanks, I might try moving the main type. The really tricky bit I've found though is when I'm implementing an instance for a typeclass on the main type (i.e. a typeclass that allows background jobs in a webapp) â€“ I want to implement the actual jobs elsewhere, but that creates a circular import of instance -> job implementation -> Foundation
04:30:39 <danpalmer> functionality -> instance.
04:31:37 <danpalmer> I tried putting the instances in a separate file, but I keep ending up with circular imports
04:45:04 <danpalmer> I've found Carnival by Thoughtbot, it looks like a very complete Yesod app in many ways - looks very useful for beginners. https://github.com/thoughtbot/carnival
04:48:17 <b0llu> how do I enable an extension in GHCi?
04:48:21 <b0llu> I need DataKinds
04:48:25 <lyxia> :set -XDataKinds
04:48:48 <b0llu> thanks :)
05:16:22 <jchia_> Is there a library for calling python2.7 from haskell that I can use with stack lts-7 or nightly?
05:23:07 <b0llu> why does the type system not allow this? densematrix_new_eye :: forall r c k. (KnownNat r,  KnownNat c, KnownNat k, KnownNat (r + k), KnownNat (c + k)) => DenseMatrix (r + k) (c + k)
05:23:17 <b0llu>       NB: â€˜+â€™ is a type function, and may not be injective
05:23:31 <b0llu> how does the injectivity of (+) matter here?
05:23:56 <hpc> it has to do with the non-overlapping property of class instances
05:24:23 <b0llu> hpc: I'm sorry, I don't follow. could you expand on that?
05:28:32 <hpc> i don't understand it 100% myself, looking for a good explanation
05:28:44 <hpc> i don't think i could explain it well enough for someone else yet
05:28:55 <danpalmer> Ok, I think I've figured out the root of my problem: I have a typeclass that does dispatch to a bunch of other functions, and provides database access to those functions. Now I have a circular import from the instance of that typeclass (which imports the functions) -> to the functions themselves (which must import the instance so that they can access the
05:28:55 <danpalmer> database) -> back to the instance.
05:29:07 <danpalmer> I'm not sure how to structure that to get rid of the circular import?
05:29:24 <danpalmer> Any help or pointers towards things I should read about that might help would be appreciated.
05:29:37 <hpc> b0llu: http://blog.ezyang.com/2010/08/generalizing-apis/ - this touches on it reasonably well
05:30:48 <b0llu> hpc: thank you
05:30:57 <b0llu> hpc: so, well, is there a solution?
05:31:34 <hpc> basically just formulate it differently
05:31:39 <hpc> i couldn't give any specific techniques
05:32:01 <lyxia> now it should be possible with TypeApplications
05:32:03 <hpc> oh, actually here's a good explanation of the issue you're having with that specific function
05:32:10 <hpc> oh, good call
05:32:12 <b0llu> 	yes
05:32:17 <b0llu> lyxia: okay, how?
05:32:51 <hpc> b0llu: so imagine you call densematrix_new_eye with a type of DenseMatrix 5 6
05:33:01 <hpc> b0llu: there's not enough information there to know what r, k, and c are
05:33:09 <b0llu> hm
05:33:10 <b0llu> right
05:33:10 <lyxia> b0llu: TypeApplications + AllowAmbiguousTypes
05:33:18 <hpc> with an injective function, you have some way of unambiguously reversing the function application
05:33:29 <hpc> but in this case we could have k = 3, r = 2, c = 3
05:33:34 <hpc> or k = 0, r = 5, c = 6
05:33:37 <b0llu> ah
05:33:38 <b0llu> hm
05:33:38 <hpc> or a number of other things
05:33:49 <hpc> it's a special case of ambiguous instances
05:34:31 <b0llu> hpc: this will make my library hard to use, right?
05:34:55 <hpc> you can probably solve it by doing densematrix_new_eye @ 5 @ 6 @ 0
05:35:10 <b0llu> hpc: right, I understand that. But.. for new people to Haskell
05:35:11 <hpc> which assigns those types to the first thing it finds in the forall (as if it's a type-level function)
05:35:20 <hpc> oh yeah, it might
05:35:32 <b0llu> dang
05:35:49 <b0llu> is there a way to design this API so that I prove Int for new people and type level coolness for people who understand it?
05:36:18 <hpc> maybe
05:37:04 <lyxia> You could also put in the documentation "use this function like this"
05:37:28 <hpc> or not formulate your type in terms of addition
05:37:37 <hpc> in that case you can probably just make it DenseMatrix r c
05:38:09 <hpc> k seems to be a "make it at least this big" type parameter, which you could make a parameter for maybe
05:38:21 <b0llu> hpc: hm
05:38:29 <hpc> do some sort of class-y trick to make it so you have 5 :: KnownNat 5, 6 :: KnownNat 6, etc
05:38:31 <b0llu> hpc: no, like, it's the offset of the 1s
05:38:56 <b0llu> hpc: what do you mean "which you could make a parameter for maybe"?
05:39:40 <hpc> right now r, c, k are totally self-enclosed in the definition of that value
05:39:49 <lyxia> literals are just Num a => a though
05:40:51 <hpc> you can disambiguate it by using the fact that (forall a b. KnownNat a, KnownNat b, KnownNat (a + b) => a + b) = (forall a. KnownNat a => a)
05:41:24 <hpc> or something like that
05:41:39 <hpc> basically from outside that type, there's no way to observe what those type variables are
05:41:41 <lyxia> the first might use more knownNat constraints
05:41:44 <hpc> so they might as well go away
05:42:14 <hpc> remember that types get reduced to normal form during compilation
05:42:30 <b0llu> huuh
05:42:32 <b0llu> I'm learning a lot
05:42:33 <b0llu> I see
05:42:33 <lyxia> What
05:42:44 <b0llu> "remember that types get reduced to normal form during compilation" ?
05:42:46 <b0llu> I didn't know that
05:43:28 <hpc> it's pretty obvious from the right perspective
05:43:45 <hpc> infinite types are like bottoms because they stop compilation
05:44:02 <hpc> and types that result in an error do similarly
05:44:13 <hpc> (if you do something tricky with TH or whatever)
05:44:30 <hpc> doesn't really matter for the most part
05:44:56 <hpc> but in this case you can treat (a + b) as whatever (a + b) reduces to, because a and b are never observable outside that context
05:45:31 <Gurkenglas> What was that article that said to replace custom flag data types with the only type they're turned into, like a callback?
05:45:52 <lyxia> hpc: (a + b) is not of kind * though. Are you claiming that (KnownNat a, KnownNat b, KnownNat (a + b)) => Proxy (a + b) -> Int   is equivalent to   KnownNat a => Proxy a -> Int
05:46:35 <hpc> lyxia: it requires (KnownNat a, KnownNat b) => KnownNat (a + b), but yeah
05:47:11 <lyxia> Well I can write a function that's of the first type but not the other
05:47:19 <lyxia> with scopedTypeVariables
05:47:35 <hpc> oh?
05:49:16 <hpc> lyxia: do you mean a strict function? because i can see \_ -> 0 inhabiting both types
05:51:24 <hpc> oh, you mean you can generate a definition that doesn't inhabit both types
05:51:38 <hpc> not that the second is uninhabited
05:52:41 <hpc> lyxia: what am i missing?
05:53:01 <lyxia> http://lpaste.net/349771
05:53:35 <lyxia> There is strictly more information in a (KnownNat a, KnownNat b) constraint than in a single (KnownNat c)
05:54:31 <hpc> oh dang
05:55:53 <hpc> argh, because type information is available at the value level too
05:55:57 * hpc is a derp
06:25:49 <hongminh1e> I have a question. I want to derive an instance for (Show (T a)) e.g. data T a = T { v :: (Show a) => a } deriving (Show), but GHC says "No instance for (Show (Show a => a))" to me
06:26:09 <Fare> Hi. I'm trying to give a non-monomorphic type to prototypes, and I admit I have no idea how to do it with haskell
06:26:44 <hongminh1e> How should I do if I want to derive a parameterized type?
06:28:43 <Fare> it's about how fixpoints can be polymorphic, and how to make sure we compute the least fixed point, I suppose.
06:29:04 <Fare> my fixed points knowledge is a bit rusty
06:29:42 <lyxia> hongminh1e: there is currently no way to derive this
06:30:22 <hongminh1e> oh
06:30:34 <lyxia> hongminh1e: or maybe  with standalone deriving
06:31:05 <nure> ls
06:31:40 <hongminh1e> thanks for answer!
06:33:58 <lyxia> Fare: What's a prototype
06:34:09 <lyxia> Fare: do you have a question
06:34:23 <Fare> data Proto r = Proto (r -> r -> r)
06:34:23 <Fare> instantiate :: Proto r -> r
06:34:23 <Fare> instantiate (Proto p) = self where self = p self abort
06:34:32 <Fare> abort :: r
06:34:32 <Fare> abort = error "abort"
06:34:43 <Fare> I should probably call it bottom
06:35:33 <Fare> renamed, it's bottom.
06:35:41 <lyxia> What about that piece of code
06:37:14 <Fare> I'd like to make it polymorphic in r
06:37:26 <Fare> using some kind of subtyping or row typing.
06:37:50 <lyxia> Isn't it already
06:38:00 <Fare> not sufficiently
06:38:57 <Fare> I want something more like Subtype r s => Proto r s = Proto (r -> r -> s)
06:39:26 <c_wraith> this is entering XY territory
06:39:29 <Fare> and then the fix point is of type s, assuming you proved it's or type r
06:39:34 <Fare> XY?
06:39:49 <Fare> what's XY?
06:39:53 <lyxia> http://xyproblem.info
06:40:27 <lyxia> I don't even understand your Y problem though
06:40:39 <Fare> the problem is modelling prototype OO in a typed language.
06:40:58 <Fare> a minimal model of prototyping, even
06:41:23 <Fare> In Racket: (define (make p b) (letrec ((f (p (Î» a (apply f a)) b))) f))
06:43:00 <Fare> In Jsonnet (pure lazy functional language): local instantiate_proto(proto) = local this = proto(this, bottom); this;
07:44:03 <Naughtmare[m]> I don't know if this is relevant, but have you looked at: https://hackage.haskell.org/package/oo-prototypes
07:45:48 <hodapp> huh...
07:52:42 <JakobCTH> Hi, I have a problem with running the interpreter in haskell-mode for emacs. Whenever the interpreter is loaded the editor becomes extremely slow when editing functions.
07:53:13 <JakobCTH> Is there a solution to this, I have tried googling around but I guess it has something to do with emacs being single threaded?
07:54:46 <serious> Is Real World Haskell still actual?
07:55:25 <JakobCTH> Essentially emacs freezes until the function definition shows up after a second or two in the mini-buffer. :/
08:01:27 <systemfault> serious: The consensus seems to be that it's not
08:10:23 <manek> Hello guys! Should I use nowadays Data.Data or GHC Generics? is Generics just "better"? 
08:11:21 <serious> systemfault: is there something you can suggest to start with? I tried with learnyouahaskell a couple of times but failed to finish it :( Not my thing really.
08:12:45 <lyxia> manek: GHC.Generics is better in many respects yes. Much safer.
08:13:26 <systemfault> serious: Both RWH and LYAH were bad _for_me_... The only thing that really worked for me is the haskell book but it's not free :/
08:14:16 <lyxia> manek: It's a bit less intuitive to use, but the documentation covers the basics.
08:14:16 <systemfault> serious: I guess that without it, I'd do the CIS194 course that is linked on the bitemyapp github https://github.com/bitemyapp/learnhaskell/
08:17:08 <serious> systemfault: thanks, it looks it is worth to look at
08:18:34 <manek> lyxia: cool, thank you! :)
08:21:13 <manek> by the way, are there any generics examples, like generics Show or Typeable implementations?
08:22:30 <lyxia> Typeable is pure magic, it's not something you implement.
08:23:01 <manek> lyxia: you can implement it using Data.Typeable functions that transform TypeRep
08:23:25 <manek> lyxia: in fact Im right now creating wrapper over Typeable and want to be ableto put it in deriving clause
08:23:26 <manek> so I
08:23:31 <manek> m thinking of using generics for that
08:31:13 <mettekou> Is there a reason why Debug.Trace.trace wouldn't produce any output? When I apply it to part of an expression it produces the value of that part, but when I apply it to the entire expression it doesn't produce anything.
08:32:13 <ongy> mettekou: are you sure the expression is fully evaluated?
08:35:17 <mettekou> ongy: I was, until you just asked me about it. ðŸ˜œ So no, it's not. It's part of a guard of the form f x `elem` xs, where xs is [] in the case I was tracing for.
08:35:21 <mettekou> ongy: Thanks!
08:49:08 <seishun> is there a way to guard on constructor? something like `guard $ not $ isType Ctor a`
08:52:16 <seishun> or pattern match to NOT be a particular constructor
08:53:07 <hpc> suppos you had something like data Foo = One | Two | Three | Four
08:53:08 <hpc> you could write
08:53:19 <hpc> ifNotThree Three t f = f
08:53:25 <hpc> ifNotThree _ t f = t
08:54:05 <hpc> basically match on what you don't want first, then below that any other pattern is going to always be not that
08:54:30 <seishun> so I need a separate function for that I guess
08:54:49 <hpc> or write whatever you're doing in that particular way
08:56:04 <seishun> I could do `case val of`, but then the rest of the do block will be indented...
08:57:38 <lyxia> but you're doing just a guard
09:21:10 <glguy> I've you're playing adventofcode.com this year, check out the #haskell private leaderboard. The key is in /topic
09:21:14 <hackrilege> I'm not sure how to order the permutations of a list. If a list of branches is traversed in order in the Foldable instance of a Tree, permuting the list will result in a different fold visiting the elements in a different order, which is indicated by an Int as the permutations are ordered, forcing the user to understand this ordering..
09:23:52 <hackrilege> I guess I want a better argument than Int to require for the user to indicate the ordering of the navigation of branches
09:27:10 <hackrilege> Maybe the question is how to create different Enum instances for the Integers
09:28:08 * ski doesn't see what `Int' has to do with permuations, here
09:29:41 <lambdafan> if I say "Haskell functions are (1) curried (2) higher-order (3) subject to partial application", can I say that 91) (2) and (3) are properties of haskell functions?
09:30:12 <hackrilege> ski, The permutations are generated in order, so have a fromIntegral instance.
09:32:11 <ski> how do you convert from an integer to e.g. `[GT,LT,EQ]' ?
09:32:56 <ski> lambdafan : (1) isn't a property of the functions, but of how they're (often, not always) used
09:33:25 <foojin> hackrilege: AFAIK there is a nice way to map (non-negative) integers to permutations that arises from a positional number system of sorts, with factorials instead of powers of a certain base.
09:33:37 <ski> lambdafan : (2) Haskell *allows* higher-order functions (which implies (3) being able to partially apply to early arguments)
09:33:55 * ski nods to foojin
09:34:15 <lambdafan> ski: Thanks. I'm trying to describe haskell functions by their properties, and so am trying to sort those out
09:34:33 <hackrilege> > (enumFromTo (map fromIntegral [1..] )::[Bool]
09:34:36 <lambdabot>  <hint>:1:46: error:
09:34:36 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:34:58 <lambdafan> ski: right now I am just sticking to the haskell wiki definition
09:36:01 <ski> lambdafan : btw, C also allows higher-order functions, but there functions can't depend on non-local (and non-global) scope identifiers (so that functions typically aren't implemented as closures)
09:36:14 <hackrilege> Id like a class for permitted lists of Ints
09:36:31 <hackrilege> Permuted*
09:37:24 <ski> lambdafan : in Pascal (and Ada), functions *can* depend on nonlocals, however you can't return them as results from other function (nor store into some outer scope mutable variable), you can only pass them as arguments to other functions. so it's not the full power of higher-order functions
09:38:38 <ski> (in GCC, you can do the same, define local functions depending on nonlocals, and pass them as arguments to other functions. if you try to "return" them out of the dynamic extent of the enclosing function (containing a nonlocal they depended on), then you get UB, though)
09:40:56 <ski> lambdafan : otoh, Haskell allows locally constructed (or defined) functions, and allows them to refer to nonlocals, with no restriction in use
09:41:27 <ski> (you can also store functions in data structures, or in mutable cells, &c.)
09:41:34 <ski> in short : "functions are first-class citizens/values"
09:41:55 <hackrilege> I guess I could use [a] -> ([a] -> (a,[a]) -- which then should have various Enum instances
09:42:18 <roundhouse> hi, is there an easy way to have a configure script with a stack project? Using "defaultMainWithHooks autoconfUserHooks" in Setup.hs doesn't seem to do anything
09:42:34 <hackrilege> [a] -> ([a] -> (a,[a]))
09:42:44 <glguy> roundhouse: Did you set the "build-type" field in your .cabal file?
09:42:52 <ski> lambdafan : btw, higher-order implies both being able to take a function as argument, and being able to return a function. and those functions could also possibly be higher-order, &c.
09:42:59 <foojin> hackrilege: Would you mind showing an example of this premutation indexing problem? Is there a library function involved that produces a list to be further indexed?
09:43:07 <foojin> *permutation
09:43:45 <roundhouse> glguy: ah, I missed that. It is set to Simple. What do I want to have there instead?
09:43:47 <ski> lambdafan : if we see a repeated expression/block in our code, we prefer to give it a name, defining it in one place, not repeating the block of code, instead reusing (repeating) the name
09:44:12 <glguy> roundhouse: Probably Custom
09:44:21 <glguy> roundhouse: It's in the docs otherwise
09:44:25 <ski> lambdafan : sometimes there's small variations in the repeated blocks, and then we parameterize, defining a function with parameters (formal arguments), to account for the variations/differences
09:45:39 <ski> lambdafan : but sometimes these differences are in the form of a varying subexpression, *but* that in turn having a subexpression of its own which is the same in all cases. so then you want to parameterize over a function, to capture the non-varying parts, passing in the varying parts as parameters
09:45:40 <hackrilege> Ok foojin I'll make a paste
09:45:47 <roundhouse> glguy: Thanks alot, it seems that Configure is the correct build type
09:45:57 * lambdafan nods
09:46:03 <lambdafan> ski: thanks :)
09:46:05 <ski> lambdafan : so, higher-order functions (at least passing functions as arguments) arise naturally, when wanting to refactor code so as to not repeat oneself
10:08:26 <hackrilege> http://lpaste.net/349775
10:09:24 <c_wraith> is foldl a valid minimal instance for foldable? huh
10:09:44 <c_wraith> No, it isn't.  Ok.
10:16:25 <Forlorn> Do we have any experienced haskell programmers here?
10:16:31 <Tuplanolla> Yes.
10:16:35 <Tuplanolla> Quite a few!
10:17:18 <Forlorn> https://sprunge.us/QgZA
10:17:26 <Forlorn> I can't figure out what's wrong with my code
10:17:48 <Forlorn> it's just 5 lines long
10:18:12 <Forlorn> I want to select dearrangements using this method
10:18:36 <Forlorn> any ideas?
10:20:30 <ab9rf> "sprunge.us unexpectedly closed the connection."
10:20:40 <ab9rf> could you use the pastebin in the channel topic instead?
10:21:18 <Forlorn> http://sprunge.us/dNNi
10:21:22 <Forlorn> does that work?
10:21:44 <Forlorn> my clipboard breaks so I have to copy by hand, (no browser on this computer)
10:22:09 <Forlorn> I am sshing to my main machine attaching to its tmux session with irssi :/
10:22:24 <hackrilege> Forlorn lpaste.net
10:22:43 <ab9rf> ugh
10:23:03 <ab9rf> why don't you use map insead of g?
10:23:08 <lambdafan> ski: is this a valid statement: "A function maps a value to another value."?
10:23:12 <Forlorn> ab9rf, alright
10:23:15 <Forlorn> ab9rf, thanks
10:25:35 <hackrilege> A function is a mapping between types, it takes and returns values of these types
10:25:58 <Forlorn> ab9rf, http://sprunge.us/bajB
10:26:01 <Forlorn> ab9rf, like so?
10:26:31 <Forlorn> ab9rf, still getting errors though, how come?
10:28:11 <lambdafan> hackrilege: nice, thanks :)
10:30:35 <Forlorn> oh, perhaps I need to flatten the results of f.
10:33:48 <ski> lambdafan : generally, a function will map each value in a set of values (the domain of the function) to a value in another set of values (the codomain of the function)
10:34:15 <ski> lambdafan : "A function maps a value to another value." sounds like it's just about two values, which could be misleading
10:35:11 <ski> lambdafan : these two set of values (domain and codomain of the function) are also often referred to as types (or "objects", if you're talking category theory)
10:35:31 <xcmw> Is there a type function that will take a type and generate a ~ constraint for it? F String :: * -> Constraint
10:37:34 <hackrilege> Still struggling with this foldable instance... http://lpaste.net/349775
10:37:51 <lyxia> :k (~) String
10:37:53 <lambdabot> * -> Constraint
10:38:36 <Forlorn> hmm, this makes it difficult
10:38:42 <Forlorn> anyway to represent a tree in haskell?
10:39:00 <lyxia> there are lots
10:39:23 <Forlorn> what's the simplest?
10:40:09 <lyxia> data Tree = Leaf | Node Tree Tree
10:40:21 <Forlorn> oh nice
10:40:22 <Forlorn> thanks!
10:42:03 <xcmw> :k ((~) String)
10:42:05 <lambdabot> * -> Constraint
10:42:55 <xcmw> lyxia: It has the right kind. When I use it I get parser error: ~
10:43:25 <lyxia> xcmw: have you turned on either TypeFamilies or GADTs
10:43:37 <foojin> hackrilege: I'm trying to load it without the instance itself and it seems like you need to write (permute f) instead of f in permuteTree. It produces a different error still.
10:44:03 <xcmw> lyxia: Both. I'm partially applying it. Does that matter?
10:45:12 <lyxia> hackrilege: foldr (flip (foldr f))
10:45:30 <hackrilege> Thanks
10:45:43 <lyxia> xcmw: how are you using it
10:46:21 <xcmw> lyxia: newtype Thing c a k = Thing (forall t. a t -> FieldNewtype c k t)
10:46:37 <xcmw> lyxia: smA :: Thing Show a k1 -> Thing ((~) String) a TK4
10:46:55 <foojin> hackrilege: permuteTree f (Tree stem branches) = Tree stem (permute f (map (permuteTree f) branches))
10:47:52 <hackrilege> Oh yeah
10:49:33 <pothepanda> guys, i know this is probs not the right place to ask
10:49:35 <lyxia> xcmw: I have no problem parsing that, even without TypeFamilies or GADTs actually...
10:49:35 <hackrilege> @letPaste 349775
10:49:37 <lambdabot>  .L.hs:209:1: error:
10:49:37 <lambdabot>      Multiple declarations of â€˜TreeNâ€™
10:49:37 <lambdabot>      Declared at: .L.hs:198:1
10:49:58 <hackrilege> @undefine
10:49:58 <lambdabot> Undefined.
10:50:05 <hackrilege> @letPaste 349775
10:50:07 <lambdabot>  Defined.
10:50:15 <pothepanda> but im looking for some programming language/library whatever, to help me build apps that import an excel file (not well structured), do some manipulation, export an excel file. any suggestions ?
10:51:20 <Forlorn> lyxia, oh, yikes. What if each branch as N-nodes? Should I make it into list of nodes per branch?
10:51:30 <foojin> Why does lpaste give me code with TreeN when I try to download the raw version?
10:51:43 <Forlorn> s/as/has/
10:52:21 <foojin> That looks like a bug to me.
10:52:34 <lyxia> foojin: yes
10:53:00 <lyxia> foojin: what do you mean
10:53:05 <lyxia> Forlorn: yes
10:53:28 <Forlorn> lyxia, oh, that's so pretty, wow haskell is beautiful
10:54:01 <Forlorn> should really, read me a book about it, but I can't concentrate, perhaps I should try video lectures instead
10:54:05 * Forlorn shrugs.
10:54:55 <foojin> lyxia: When asked for "Raw" it serves something completely different from any revision it mentions. Maybe it's the original?
10:54:58 <hackrilege> I updated the paste, sorry your maybe looking at an old version
10:56:45 <foojin> lyxia: It's the same for lambdabot judjing by the TreeN type popping up in its output.
10:58:47 <calloc> Does anyone use a flipped : to make their multi-line lists pretty?
10:58:57 <lyxia> foojin: what hackrilege said. The current version has a TreeN.
11:00:13 <hackrilege> If I extract the nth element I can turn a list of Int into a permutation, so long as the list if Ints is itself a permutation
11:02:02 <hackrilege> I guess I could write an unfold to give an alternative ordering
11:03:19 <Ordentlig> q = filter (\s -> (not (elem s y)) and (not (s == x))) z
11:03:35 <Ordentlig>     â€¢ The function â€˜notâ€™ is applied to three arguments,
11:03:45 <Ordentlig> I don't get it, what's wrong here?
11:03:57 <ski> hackrilege : post-order traversal ?
11:04:15 <hackrilege> So I guess what I need is of type [a] -> (a,[a])
11:04:47 <lyxia> Ordentlig: "and" should be "&&"
11:04:55 <ski> Ordentlig : kanske ville du anvÃ¤nda `&&' istÃ¤llet fÃ¶r `and' ?
11:05:23 <Ordentlig> can you define != in haskell?
11:05:30 <ski> there's also a `notElem', and a `/=' operator for disequality
11:05:31 <Ordentlig> alright, thanks
11:05:40 <Ordentlig> oh nice
11:05:44 <ski> @src (/=)
11:05:44 <lambdabot> x /= y = not (x == y)
11:05:45 * Ordentlig claps hands.
11:06:12 <ski> @type and
11:06:14 <lambdabot> Foldable t => t Bool -> Bool
11:06:23 <ski> > and [True,True,False,True]
11:06:25 <lambdabot>  False
11:06:27 <ski> > and [True,True,True,True]
11:06:29 <lambdabot>  True
11:06:37 <hackrilege> Oh so building up a Tree to indicate the order of traversal of a Tree. Fancy
11:06:43 <ski> `and' is a function which takes a list of booleans. it's not an infix operator
11:07:01 <hashme_> how do i access different data when i define abstract data type?
11:07:10 <Ordentlig> omg, it compiled
11:07:17 * Ordentlig throws kisses.
11:07:19 * ski smiles
11:07:36 <hashme_> suppose i define a 2D point data with x and y coordinate, how do i access it in a function?
11:07:53 <hackrilege> hashme, you can pattern match the constructor or use record syntax
11:07:55 * ski . o O ( "Var nu en ordentlig student, och lyssna pÃ¥ kompilatorn .." )
11:08:28 <ski> hashme_ : you can export accessing functions
11:08:41 <maerwald> hashme_: that's very basic knowledge that's explained in all tutorials out there
11:08:46 <maerwald> @where learnhaskell
11:08:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:09:01 <hashme_> http://lpaste.net/349787
11:09:16 <Ordentlig> ski, men vafan, kan den inte indentera mitt output? Det ar ett trad! :)
11:09:19 <hackrilege> @let data P a = P { getX :: a, getY :: a}
11:09:20 <lambdabot>  Defined.
11:09:46 <hackrilege> @let p = P 1 2
11:09:48 <lambdabot>  Defined.
11:09:56 <hackrilege> getX p
11:10:11 <hackrilege> :t getX
11:10:13 <lambdabot> P a -> a
11:10:25 <maerwald> I suggest he should start with a proper haskell tutorial
11:10:31 <hashme_> getX?
11:10:31 <hackrilege> > getY p
11:10:33 <lambdabot>  error:
11:10:34 <lambdabot>      Ambiguous occurrence â€˜pâ€™
11:10:34 <lambdabot>      It could refer to either â€˜Debug.SimpleReflect.pâ€™,
11:10:59 <marxS> How can I implement an iterated for loop in a list comprehension? Something like: for (i=0; i<n; i++){for (j=0, j<k; j++) do something; }
11:11:05 <hackrilege> Yes I defined that function by the way I defined the datatype P
11:11:42 <marxS> I was thinking something like this: func i j k n = head[x | y <- [j..k], x <- [i..n], mod x y == 0]
11:11:46 <marxS> but it doesnt seem to work as intended
11:12:00 <hashme_> Oh alright
11:12:27 <marxS> I want to check if a number in list [i..n] is divisible by every number in list [j..k]
11:12:37 <ski> Ordentlig : fwiw, you might be interested in #haskell.scandinavian (and perhaps #haskell.se or #haskell.no)
11:12:37 <hashme_> Can you send me the link learnyouahaskell where this kind of thing is done?
11:12:39 <hashme_> Thanks!
11:13:04 <gamegoblin> marxS: can you paste your non-haskell code here http://lpaste.net/new/haskell and Iâ€™ll walk you through a haskell translation
11:14:05 <maerwald> hashme_: https://github.com/bitemyapp/learnhaskell
11:14:11 <ski> > getY L.p
11:14:13 <lambdabot>  2
11:14:39 <hackrilege> > (\f n -> [f i j | i <- [1..n], j <- [1..n] ) (+) 3 -- marxS
11:14:41 <lambdabot>  <hint>:1:44: error: parse error on input â€˜)â€™
11:16:10 <ski> > [x | x <- [1 .. 10] , all (\y -> x `mod` y == 0) [1 .. 4]]
11:16:13 <lambdabot>  []
11:16:26 <ski> > [x | x <- [1 .. 100] , all (\y -> x `mod` y == 0) [1 .. 4]]
11:16:28 <lambdabot>  [12,24,36,48,60,72,84,96]
11:16:39 <marxS> something like this maybe gamegoblin http://paste.ofcode.org/BrQpqQnNX2fpvdaiZUHWJC
11:16:44 <hackrilege> > (\f n -> [f i j | i <- [1..n], j <- [1..n]] ) (+) 3 -- marxS
11:16:46 <lambdabot>  [2,3,4,3,4,5,4,5,6]
11:16:59 <ski> > [x | x <- [1 .. 100] , and [x `mod` y | y <- [1 .. 4]]
11:17:01 <lambdabot>  <hint>:1:55: error:
11:17:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:17:06 <ski> > [x | x <- [1 .. 100] , and [x `mod` y | y <- [1 .. 4]]]
11:17:08 <lambdabot>  error:
11:17:08 <lambdabot>      â€¢ No instance for (Num Bool) arising from the literal â€˜1â€™
11:17:08 <lambdabot>      â€¢ In the expression: 1
11:17:13 <MarcelineVQ> must be sunday
11:17:19 * ski sighs
11:17:25 <marxS> Why must it be sunday?
11:17:30 <ski> > [x | x <- [1 .. 100] , and [x `mod` y == 0 | y <- [1 .. 4]]]  -- there
11:17:32 <lambdabot>  [12,24,36,48,60,72,84,96]
11:18:03 <MarcelineVQ> 'cause people aren't checking their work before sharing :>
11:19:04 <foojin> > [x | x <- [1 .. 100] , and [(x `mod` y) /= 0 | y <- [1 .. 4]]]
11:19:06 <lambdabot>  []
11:19:11 <EvanR> it is necessarily sunday
11:19:23 <tdammers> https://github.com/tdammers/sprinkles/blob/master/src/Web/Sprinkles/Handlers/Static.hs#L34
11:19:24 <gamegoblin> marxS: are you sure about that C program? Can you describe exactly what you want it to do?
11:19:29 <EvanR> modal logic
11:19:33 <tdammers> any clues why GHC insists that the pattern matches overlap here?
11:19:49 <ski> marxS : ok, looks like my version(s) is roughly what you're looking for ?
11:19:56 <marxS> ski yes I think so, thanks
11:20:21 <marxS> I don't really understand it though, why the comma, does that have a role?
11:20:50 <gamegoblin> tdammers: I donâ€™t see the overlap either
11:20:50 <ski> marxS : normally, you'd do something like `[x | y <- [j..k], x <- [i..n], mod x y == 0]' for nested ("iterated") loops, with list comprehensions. but that's assuming no non-local exists, which you had (`break')
11:20:53 <roundhouse> hi, if I have a newtype Object (say "newtype MyInt = MyInt { unMyInt :: Int }"), is there an easy way to apply an function to the underlying object? (so I have "f: Int -> Int" and I want to get "g: MyInt -> MyInt")
11:21:18 <glguy> tdammers: Maybe you didn't save. Read the whole error message, it's more specific about what overlapped
11:21:51 <marxS> hmm okay ski, thanks. Also, is there any way to "break" once the first list gets its first element?
11:22:01 <marxS> So I can use an infinite list in the first list comprehension
11:22:10 <ski> marxS : use `head' or `take 1' on the resulting list
11:22:20 <hackrilege> Roundhouse you should define a Functor instance and then fmap is the function your after
11:22:22 <marxS> But what if the list is going on forever
11:22:26 <marxS> I.e it never stops adding elements to itself
11:22:32 <alec_> i'm a complete noob and everything i try to debug in visual studio says it's a library and it needs an executable.. Am i in the wrong place?
11:22:37 <marxS> Will head still return the first element as soon as it is found?
11:22:43 <ski> marxS : .. or `listToMaybe', in case you're not sure there'll be a solution
11:22:43 <tdammers> glguy: I did save, this warning has been popping up for quite a while now
11:22:50 <tdammers> the part it highlights is:
11:22:53 <tdammers> "In a case alternative: Just (MultiItem (x : xs)) -> ..."
11:23:00 <tdammers> i.e., the last case
11:23:09 <ski> marxS : yes, in this case. in general, depends on whether the list is constructed incrementally, or "bulkily"
11:23:19 <Tuplanolla> Does `OverloadedLists` interfere, tdammers?
11:23:35 <Tuplanolla> I haven't seen this one before.
11:23:49 <ski> (`take 1' also works, even if there happens to be no element in the list)
11:23:57 <roundhouse> hackrilege: Thanks, that is what I suspected. Can you give me a hint how to do that with a newtype as above?
11:23:57 <tdammers> Tuplanolla: I do have OverloadedLists enabled, but I don't see why it would interfere
11:24:46 <ski> alec_ : this channel is for discussion related to the programming language Haskell. in case you're doing C (or C++) programming, perhaps you want to ask in ##c (or ##c++) ?
11:25:16 <hackrilege> instance Functor MyInt where fmap f (MyInt a) = MyInt (f a)
11:25:45 <glguy> tdammers: overloadedlists overloads list pattern matching, too
11:25:58 <ski> alec_ : also seems there's a #visualstudio channel, you could try
11:25:59 <glguy> tdammers: maybe it works better if you factor the matching on the list pattern
11:26:00 <hackrilege> Oops that won't work for your type
11:26:14 <glguy> Jast (Multiline xs) -> case xs of [] -> ...; y:ys -> ...
11:26:27 <tdammers> hmm, just removing OverloadedLists makes the warning go away
11:26:28 <hackrilege> You should define a new function
11:27:13 <tdammers> but since MultiItem is not polymorphic in any way, shouldn't OverloadedList just amount to a no-op in this case?
11:27:22 <hackrilege> myIntF f (MyInt a) = MyInt (f a)
11:28:31 <ertes> helo
11:28:38 <hackrilege> Or you could use g= MyInt . f . unMyInt
11:29:33 <ski> ehlo ertes@@pD9FCB082.dip0.t-ipconnect.de
11:29:38 <hackrilege> You don't have enough type parameters to support a Functor instance
11:30:07 <ertes> =)
11:30:29 <hackrilege> Having constrained the contained type to Int
11:32:16 <buglebudabey> can someone give me a quick easy example of 'second' in use?
11:32:22 <roundhouse> hmm I was hoping for a less tedious method ^^
11:32:32 <ertes> > second (+ 1) (1, 1)
11:32:34 <lambdabot>  (1,2)
11:33:03 <ertes> buglebudabey: of course for (->) 'second' is just 'fmap'
11:33:16 <ertes> > fmap (+ 1) (1, 1)
11:33:18 <lambdabot>  (1,2)
11:33:25 <buglebudabey> so it's different from snd $ (+1)(1,1)
11:33:35 <ertes> yesâ€¦  that one is a type error
11:33:45 <buglebudabey> oh woops ur right
11:34:23 <hackrilege> Can you show me what you mean roundhouse?
11:34:55 <ertes> buglebudabey: if you want to map over individual components of a tuple, i suggest using either Functor or Bifunctor
11:34:59 <ski> > case second id undefined of (_,_) -> ()
11:35:00 <ski> > case fmap id undefined of (_,_) -> ()
11:35:03 <lambdabot>  ()
11:35:07 <lambdabot>  *Exception: Prelude.undefined
11:35:38 <ertes> i stand corrected =)
11:36:08 <ertes> > bimap id id undefined `seq` ()
11:36:11 <lambdabot>  error:
11:36:11 <lambdabot>      â€¢ Ambiguous type variable â€˜p0â€™ arising from a use of â€˜bimapâ€™
11:36:11 <lambdabot>        prevents the constraint â€˜(Bifunctor p0)â€™ from being solved.
11:36:19 <roundhouse> Well, it's just that I have multiple stages of decoding my ByteStrings. So I'll have newtype RawMessage, newtype NetworkMessage, newtype PackedMessage, ... etc all basically ByteStrings
11:36:22 <ertes> > bimap id id (undefined :: ((), ())) `seq` ()
11:36:25 <lambdabot>  ()
11:36:37 <buglebudabey> ertes i'm just trying to dissect an example i saw in a blog post
11:36:39 <roundhouse> so I'll have my code littlered with lots of Rawmessage, unNetworkMessage ,... etc
11:36:39 <ertes> ski: interesting that bimap and fmap don't agree
11:36:53 <ski> yes
11:37:11 <ski> arguably `bimap id id' ought to be `id' ?
11:37:21 <ertes> yeah
11:37:50 <ertes> but recently i learned that () is also not a proper monoid in that regard
11:38:21 <ertes> > mappend undefined mempty
11:38:23 <lambdabot>  ()
11:38:47 * ski nods
11:38:52 <ertes> (defaulting unexpectedly working for me) =)
11:38:56 <hackrilege> roundhouse, I think your stuck stringing the constructors and deconstructors together with dots
11:39:37 <roundhouse> ok, thanks anyway!
11:40:25 <hackrilege> Unless you want to relax the Int constraint, but then you would just be composing fmap with (.)
11:41:57 <EvanR> roundhouse: you have newtypes for a reason, dont you. so you have to have a "verified" special function to go from one to the other which has access to the bytestring
11:42:29 <EvanR> which works by pattern match then rewrapping
11:43:37 <buglebudabey> can someone explain the arguments for fmap here? http://lpaste.net/349790. is 'x' type State a? and does that mean s is :: State b?
11:43:41 <roundhouse> evanr: yeah, now that I think about it, such an "fmap" would allow clients to screw with the underlying data
11:43:45 <roundhouse> not what I want ^^
11:45:13 <lyxia> buglebudabey: the type signature is incorrect
11:45:35 <glguy> Or State is a type synonym and the instance is incorrect
11:45:47 <buglebudabey> lyxia what would be the correct one? this is from haskell for all first blog post :P
11:45:59 * buglebudabey glguy  lyxia  http://www.haskellforall.com/2011/12/haskell-for-mainstream-programmers-code.html
11:46:15 <buglebudabey> he has the type synonym in there
11:46:47 <lyxia> buglebudabey: fmap :: Functor f => (a -> b) -> f a -> f b, replace f with State s, fmap :: (a -> b) -> State s a -> State s b
11:46:49 <glguy> That's not standard Haskell, it's just illustrating a point I guess
11:47:10 <ski> buglebudabey : that's a simplification, for ease of understanding. actual code is slightly more cluttered
11:47:34 <buglebudabey> i feel like it'd be easier to understand the more cluttered version, not sure why this is confusing me
11:47:55 <buglebudabey> lyxia yeah, what you said makes perfect sense
11:48:16 <ski> buglebudabey : the reason is that you can't make a type synonym an instance of a type class (in some cases, with extensions, you can, but it might not no what you expect it to, depending on what you expect)
11:49:16 <buglebudabey> so is there an instance of functor for state i can look to instead that's more digestable?
11:49:30 <ski> buglebudabey : the more cluttered version amounts to inserting wrapping an unwrapping between the type `s -> (a,s)' and the *new* data type `State s a'
11:49:57 <glguy> buglebudabey: It'll be good to spend some time understanding that if a type synonym is for a function type that you can have have arguments like that
11:50:32 <buglebudabey> glguy because of the currying?
11:50:53 <glguy> no, because when you're defining a function you can list its arguments
11:51:09 <lpaste> glguy pasted â€œfor buglebudabeyâ€ at http://lpaste.net/349791
11:51:26 <lyxia> buglebudabey: http://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.State.Lazy.html#State
11:51:39 <buglebudabey> glguy thats way simple
11:51:47 <lyxia> oh wait that's for StateT which is even more complex
11:52:17 <ski> buglebudabey : the usual definition of `fmap', ignoring that type synonyms can't be instances, is plain `fmap f x s0 = case x s0 of (a,s1) -> (f a,s1)'
11:52:34 <ski> buglebudabey : have you seen `case' before ?
11:53:38 <buglebudabey> ski yes
11:53:46 * ski realizes this post does it like `s -> (s,a)', not like `s -> (a,s)'
11:53:57 <buglebudabey> yeah he does switch it up
11:54:11 <ski> buglebudabey : anyway, that is equivalent to (fixing this switch to match the post)
11:54:22 <ski>   fmap f x s0 = case x s0 of (a,s1) -> (s1,f a)
11:54:26 <ski> er, to
11:54:31 <ski>   fmap f x = \s0 -> case x s0 of (a,s1) -> (s1,f a)
11:54:52 <buglebudabey> in the example.... (x s) is simply feeding a state into 'x' to get the (s,a) to then run second over, correct?
11:55:08 <ski> where `\s0 -> ..f..x..s0..' is the function that, given an input (call it `s0'), returns `..f..x..s0..' (which is allowed to use `f',`x',`s0')
11:55:14 <ski> yes
11:55:19 <buglebudabey> ok cool, i get it now
11:55:25 <ski> now, to insert wrapping, assuming we have say
11:55:37 <ski>   newtype State s a = MkState (s -> (s,a))
11:55:43 <ski> we just switch to
11:55:51 <ski>   fmap f x = MkState (\s0 -> case x s0 of (a,s1) -> (s1,f a))
11:55:54 <buglebudabey> ski believe it or not understanding the wrapping and unwrapping made sense to me much faster
11:56:04 <buglebudabey> ski i kind of just brain farted on what was going on here
11:56:05 * ski nods
11:56:43 * ski also assumes buglebudabey has seen `newtype' before, otherwise you can think of it as a variant of `data'
11:57:05 <buglebudabey> ski i have seen all the stuff you guys mentioned, really was just a brain fart i promise :D
11:57:13 <ski> aye
12:04:23 <buglebudabey> ski one thing i would like to improve on is my usage of all things seen in typeclassopedia, i read it all but is the best way to solidify everything to find ways to work type classes into my code?
12:05:46 <EvanR> no, dont try to find ways to work type classes into your code
12:06:00 <ski> buglebudabey : well, understand the type classes, find examples of your own for using them, be on the lookup for when something you're expressing could benefit from using one of them
12:06:16 <ski> but probably don't go out of your way, just to use a type class
12:06:38 <EvanR> decades of legacy code which uses feature X "because its there" and shouldnt have
12:06:41 <ski> (and please don't go out of your way to define type classes on your own. that should be rarely done)
12:07:16 <ski> s/lookup/lookout/
12:08:17 <buglebudabey> ski understood, are there any topics i really should be trying to familiarize myself with besides those that are common in practice?
12:09:15 <maerwald> no
12:10:19 <buglebudabey> maerwald seriously?
12:11:19 <maerwald> I don't see how one can enjoy haskell if he has to digest all the weird concepts people have come up with. If you hit a problem that you think you cannot solve nicely with the "tools" you have at your disposal, ask/look if there's another way. Don't do it reverse
12:11:37 <ski> buglebudabey : question is so broad that it's hard to answer anything (positively) meaningful
12:12:21 <buglebudabey> maerwald that's a good way of thinking about it, i've been trying to digest as much as i can and i guess that's a problem
12:12:25 <EvanR> besides those that are common in practice, sounds like a really complex and questionably useful addendum 
12:12:51 <maerwald> buglebudabey: yes, and you also cannot develop good intuition if you are just loading in concept after concept
12:12:51 <EvanR> i hope it doesnt mean you are trying to avoid learning stuff thats common in practice heh
12:12:59 <hpc> maerwald: you managed to phrase that in the most depressing way possible lol
12:13:11 <maerwald> hpc: please rephrase it in a positive way :o
12:13:58 <buglebudabey> ski going along with what i just said to maerwald, i guess it's just hoping to find out what sorts of things are good to know. i see a lot of talk in this chat that seems advanced or extremely specific, and would like to get to the point of being able to draw from that kind of knowledge
12:13:59 <EvanR> to do recall going to school and loading in concept after concept, and developing intuition when things started to get hazy, with exercises
12:14:03 <ski> buglebudabey : you should be familiar with recursion (including accumulating-style, and incrementally generating output), higher-order functions, be able to perform type-inference to some degree in your head, to name a few basic topics
12:14:19 <hpc> buglebudabey: it's often still worthwhile to go looking for new things just to have the idea in case it's useful
12:14:45 <hpc> but also pace yourself because there's more out there than any one person can keep track of ;)
12:14:55 <EvanR> im not sure if its common practice or not, but i benefit from RankN polymorphism now a days
12:15:23 <hpc> especially in a language like haskell that's actively used for research
12:15:26 <buglebudabey> EvanR ski stuff like this, or generic types or GADTs i hear a lot about
12:15:54 <EvanR> GADTs are like poor mans inductively defined dependent types
12:15:58 <hpc> buglebudabey: those you'll definitely eventually find occasion to use
12:15:59 <EvanR> so could come in handy
12:16:19 <buglebudabey> ski i consider myself solid with the topics you mentioned, it's the higher functional and more abstract concepts i'm looking to know and how to use them
12:16:19 <hpc> probably not immediately though ;)
12:16:24 <EvanR> generics will let you programmatically produce support which is tedious to write, in some cases
12:17:23 <BartAdv> hm, so I'm doing following with ViewPatterns to destructure a Point V2 Int into two values of type CInt: (P (fmap fromIntegral -> V2 x2 y2))
12:17:32 <BartAdv> can I bring pattern synonyms to ease the repetition?
12:18:05 <BartAdv> or: can I remove the repetition at all?
12:18:12 <EvanR> whats the point of the Point type?
12:19:02 <BartAdv> yeah, well, that could be another question. But with only V2 it would be about the same
12:19:17 <EvanR> with just V2 Int, you could destructure with just V2 x y
12:19:20 <maerwald> BartAdv: they are a can of worms and can be easily overused and also may break exhaustiveness check. I try to avoid them, but they can be handy if used wisely
12:19:39 <BartAdv> EvanR but there's still Int -> CInt conversion (I'm doing FFI)
12:20:03 <EvanR> oh... well i do a fromIntegral at the very last minute for FFI
12:20:33 <EvanR> perhaps with a local let fi = fromIntegral to easy the typing
12:20:46 <ski> buglebudabey : existentials, higher-rank, and GADTs (and type families) can definitely be useful at times. if you want to, you could look into continuation-passing-style. or basics of category theory, if you're a mathy person
12:21:06 <maerwald> type theory is probably more useful
12:21:19 <BartAdv> I got tempted by the fact that with ViewPatterns my FFI wrappers are one-liners
12:21:36 <buglebudabey> ski, currently going through bartoz's little lecture series, i do enjoy the abstract math
12:21:51 <buglebudabey> ski thank you for those, i'll write them down
12:22:12 <buglebudabey> maerwald i also have a copy of types and programming languages i've been meaning to read through
12:22:47 <ski> buglebudabey : for some basic info on type systems, you could try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>, and "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
12:23:18 <ski> buglebudabey : the former, at least, requires some knowledge of lambda-calculus, so you might have to look up that first
12:23:59 <BartAdv> https://github.com/BartAdv/hackslash/blob/master/src/Freeablo.hs#L53 <- the example. With usage of ViewPatterns I can avoid some local lets, but the patterns are noisy and repetitive
12:24:10 <ski> buglebudabey : *nod*, TaPL is good
12:24:28 <buglebudabey> ski i'm familiar with the basics, i remade a Core -> G Code compiler and got to see the inards of a bit
12:25:16 <buglebudabey> ski your former link is broken btw
12:25:35 <ski> buglebudabey : it's available as both PS and PDF
12:25:47 <buglebudabey> i'll look it up
12:26:28 <ski> buglebudabey : the first link i gave was meant to express both alternatives. you have to pick and choose)
12:26:32 <ski> buglebudabey : if you feel like it, you could attempt Per Martin-LÃ¶f's "Intuitionistic Type Theory" in 1984 at <https://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/>
12:27:38 <buglebudabey> that looks interesting
12:28:30 <seishun> is `[0..length l - 1]` the idiomatic way to get a list of valid list indexes?
12:30:02 <seishun> (I need that to get a list of all possible non-repeating pairs in a list)
12:30:22 <EvanR> BartAdv: if the ffi stubs are repetative, you could generate them all with TH
12:30:41 <steven_> Hey guys, I would like to know what text editor are you using for haskell projects? 
12:30:43 <EvanR> repetitive repetitive repetitive
12:30:50 <BartAdv> for now just this one pattern seems to be annoying
12:31:18 <EvanR> BartAdv: but, i think it makes more sense to just bite the bullet and list them all in code as dumb as possible
12:31:23 <EvanR> as simple as possible
12:31:57 <EvanR> you could use text editor shenanigans to make it easier to type them all
12:34:25 <hpc> :t nub . sort . liftA2 (,)
12:34:27 <lambdabot> error:
12:34:27 <lambdabot>     â€¢ Couldn't match type â€˜f b0 -> f (a1, b0)â€™ with â€˜[a]â€™
12:34:27 <lambdabot>       Expected type: f a1 -> [a]
12:34:50 <hpc> :t \x y -> nub . sort $ liftA2 (,) x y -- seishun?
12:34:52 <lambdabot> (Ord b, Ord a) => [a] -> [b] -> [(a, b)]
12:35:05 <BartAdv> EvanR: cool, thanks. There's not *that* much of them:)
12:35:07 <seishun> hpc: no, from a single list
12:35:23 <hpc> :t nub . sort . join (liftA2 (,))
12:35:26 <lambdabot> Ord b => [b] -> [(b, b)]
12:37:29 <quchen> steven_: Emacs and Atom have the best Haskell support nowadays. We also have people using Vim and Sublime.
12:37:43 <byorgey> glguy: I really like your Day 10 solution.  I went on to steal your idea to solve a problem from last year's AoC. And in the same spirit of using lazy functional programming to its best effect, allow me to share https://github.com/byorgey/AoC/blob/master/08/08.hs =)
12:40:21 <glguy> byorgey: Nice functional array :)
12:40:47 <byorgey> To even my surprise, it is plenty fast enough, especially when compiled with -O2
12:41:48 <glguy> I guess it's not so bad, it runs a rather simple computation per instruction per pixel, but there aren't really that many pixels or instructions
12:42:09 <glguy> byorgey: I did a version of the similar AoC puzzle last year using Template Haskell, too
12:42:20 <EvanR> AoC ?
12:42:22 <glguy> generating variable definitions per instruction
12:42:23 <EvanR> axiom of choice?
12:42:31 <glguy> yeah, axiom of choice puzzle
12:42:38 <byorgey> EvanR: yes, the axiom of choice changes every year
12:42:41 <glguy> and then I let the compiler work it out from there
12:42:41 * ski nods solemnly
12:42:51 <EvanR> o_O
12:42:52 <quchen> seishun: What do you mean with Â»list of all possible non-repeating pairsÂ«? You want to drop all consecutive duplicates?
12:43:01 <glguy> I've been happy with this year's axiom of choice. I feel like I have more choice
12:43:14 <byorgey> EvanR: https://adventofcode.com/ =)
12:43:16 <EvanR> oh
12:43:41 <byorgey> glguy: wow, sounds... icky =)
12:43:42 <hpc> i hear next year it's going to be zorn's lemma
12:43:53 <seishun> quchen: [1,2,3] -> [(1,2),(1,3),(2,3)]
12:44:03 <quchen> [1,1] -> ?
12:44:15 * ski . o O ( "Intensional vs Extensional Choice" by roconnor in 2005-06-04 at <http://r6.ca/blog/20050604T143800Z.html>,"100 years of Zermelo's axiom: what was the problem with it?" by Per Martin-LÃ¶f in 2006 at <http://www.math.kth.se/~kurlberg/colloquium/2005/MartinLooef.pdf> )
12:44:20 <seishun> they're all unique
12:44:30 <BartAdv> EvanR: pattern CoordXY x y <- P (fmap fromIntegral -> V2 x y)
12:44:32 <hpc> seishun: what about (3, 1)?
12:44:34 <drw__> In order to build my library, I have to compile with `stack build --extra-lib-dirs=c:\sqlite and --extra-include-dirs=c:\sqlite`.  No big deal, but when I try to open the repl inside of emacs, it fails because I can't (don't know how) to pass the extra flags.  I understand that there are similar entries for the cabal file "extra-lib-dirs" and "include-dirs" but value I put there don't have the expected effect.  Can anyone explain ho
12:44:49 <BartAdv> GHC8 brought some goodies to allow this :) 
12:45:10 <seishun> hpc: I need just one of (1,3) and (3,1)
12:46:17 <ski> > [(x,y) | x:xs <- tails [0,1,2],y <- xs]  -- seishun ?
12:46:19 <lambdabot>  [(0,1),(0,2),(1,2)]
12:46:42 <quchen> [1,1] -> ?
12:47:15 <ski> the natural thing to do is to regard the elements abstractly, no ?
12:48:29 * ski idly ponders unnatural transformations, parametrically
12:48:39 <Tuplanolla> > [(x, y) | x <- [0, 1, 2], y <- [succ x .. 2]]
12:48:40 <seishun> yeah that works
12:48:41 <lambdabot>  [(0,1),(0,2),(1,2)]
12:49:04 <glguy> byorgey: Oh, maybe that was wrong. I ended up using TH for 2015 Day23 https://github.com/glguy/advent2015/blob/f8c81d5857aa96bd6e954e1bf895fc2d486288dd/Day23TH.hs
12:49:17 <glguy> http://adventofcode.com/2015/day/23 where the puzzle was to run a program
12:49:27 <byorgey> glguy: haven't solved that one yet, I'll look at your TH code once I do =)
12:52:29 <seishun> ski: how would you do that in a do block? `(x,y) <- [(x,y) | x:xs <- tails [0,1,2],y <- xs]` or can it be simplified?
12:53:45 <hpc> does it have to be in a do block?
12:54:45 <seishun> yeah
12:56:13 <quchen> Nothing *has* to be done in a do-block. Do you mean Â»in a list contextÂ«?
12:56:31 <hpc> quchen: homework sometimes has to ;)
12:57:04 <seishun> I'm not good with terminology
12:57:15 <quchen> runIdentity (do Identity x)  ;-)
12:57:40 <quchen> Okay, not helpful, sorry, Iâ€™ll be quiet.
12:58:07 <glguy> > do 5 + do do 6
12:58:09 <lambdabot>  11
12:58:22 <Tuplanolla> @type do not
12:58:24 <lambdabot> Bool -> Bool
12:58:43 <hpc> > do do doodoo
12:58:46 <lambdabot>  teehee
12:58:52 <glguy> seishun: You could have: do ....; x:xs <- tails [0,1,2]; y <- xs; ...
12:59:02 <geekosaur> now all you need is appropriate @let-s so ":t there is no try" works :p
12:59:03 <seishun> yeah, that's what I did
13:02:04 <EvanR> ski: on page 7 of intuitionistic type theory, he says 10^10 isnt obtainable with the given rules (0:N and n:N -> s(n):N)
13:02:30 <EvanR> any idea what that means
13:03:11 <EvanR> and of course he throws a "clearly" in there so i feel extra dumb
13:05:06 <EvanR> perhaps we cant obviously count 10^10 s( )'s in a row?
13:05:14 <EvanR> and be sure its right?
13:08:16 <hackrilege> Maybe it's referring to a power being referred to using (*) rather than (+)
13:15:58 <Katyusha> Hello! does anybody knows base paypal logins to brute?
13:16:19 <geekosaur> this is not a hacking channel
13:16:42 <Shockk> yes, wtf12345 with the password getoutofhere or something like that
13:16:43 <geekosaur> would you like to explain why you think it is?
13:17:09 <kadoban> Katyusha: I can only imagine you're in the wrong place.
13:18:21 <seishun> can I not use `when valid $ return state` at the end of a do-block in a list context?
13:18:27 <seishun> getting "Couldn't match type `()' with `Map Item Int'"
13:18:39 <hexagoxel> :t when
13:18:40 <lambdabot> Applicative f => Bool -> f () -> f ()
13:19:06 <johnw> seishun: you'd need to use: if valid then return state else return <whatever the invalid state should be>
13:19:21 <johnw> or, use a monad that allows you to throw an error if there is no invalid state
13:19:53 <seishun> is List such a monad?
13:21:02 <hexagoxel> seishun: you can `guard valid; return state`
13:21:14 <seishun> yeah, that's what I did
13:21:46 <byorgey> seishun: when valid $ return state  is not the same as   guard valid; return state
13:22:22 <byorgey> when valid $ return state  is the same as  return ()  if valid is false, which has the wrong type
13:23:08 <seishun> so `when valid $ return state` can be at the end of a do block only if the expected type is ()?
13:24:01 <kadoban> Yes, and only when 'state' is ()
13:24:13 <seishun> I see, cool
13:25:36 <ij> Can lens be used with TVars?
13:29:53 <hexagoxel> seishun: There is quite a difference between `pure ()` and `empty`.
13:29:57 <hexagoxel> > do { x <- [1..3]; when (x>2) (return ()) }
13:30:00 <lambdabot>  [(),(),()]
13:30:59 <ertes> ij: in what sense?
13:31:52 <ertes> ij: you can certainly do something like:  modifyTVar v (l %~ f)
13:34:28 <ij> Well, there's write/read/modify and they're all supposed to be pure-ish with `atomically', soâ€¦ I was guessing you could make a lens out of that. 
13:34:46 <ij> Or perhaps I'm speaking rubbish.
13:35:17 <EvanR_> STM is a functor
13:35:24 <EvanR_> maybe you can use lens with STM, not TVar
13:39:44 <EvanR_> mutable variables really does mess up a lot of nice abstractions
13:39:52 <ski> EvanR_ : i think the idea is that it isn't practically possible (tractable) to reduce `10^10' to an expression in canonical form, in this case a zero followed by a large number of primes (cf. ultra-finitism)
13:40:36 <seishun> > do { x <- [1..3]; when (x>2) (empty) }
13:40:39 <lambdabot>  [(),()]
13:41:01 <EvanR_> i see so with "non canonical elements" hes referring to other forms of syntax to talk about elements besides literally using the rules
13:41:38 <ski> yes
13:42:43 <EvanR_> i guess that example seems funny now
13:43:08 <EvanR_> but in 1984 you probably didnt expect to be able to print out ten billion s's to a terminal
13:43:21 <EvanR_> or dev null
13:44:05 <EvanR_> > 10^10
13:44:08 <lambdabot>  10000000000
13:44:31 <ski> (also, the sense in which he's using "category" is not the one from category theory. iiuc, the notion of "category" used there is in essence an open notion, as opposed to defining a set/type inductively, e.g. -- the classes of objects in common large categories would be "categories" in this sense)
13:44:40 <ertes> ij: i think you're on the wrong level there:  lens is for constructing functions that read or modify values in some way
13:45:06 <ski> > '0' : replicate (10^10) '\''
13:45:08 <lambdabot>  "0''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''...
13:45:13 <ski> > length ('0' : replicate (10^10) '\'')
13:45:14 <EvanR_> showIntAtBase 1 intToDigit (10^10) ""
13:45:19 <lambdabot>  mueval-core: Time limit exceeded
13:45:46 <ski> > showIntAtBase 1 intToDigit 7
13:45:48 <lambdabot>  <[Char] -> [Char]>
13:45:50 <ski> > showIntAtBase 1 intToDigit 7 ""
13:45:53 <lambdabot>  "*Exception: Numeric.showIntAtBase: applied to unsupported base 1
13:46:11 * ski idly wonders whether it supports negative bases
13:46:28 <EvanR_> nope
13:46:31 <ski> (also, the above wouldn't be base one, despite commonly being called "unary")
13:47:34 <ski> with negative bases (less than negative 1), you can represent all integers, without needing an additional sign
13:50:00 <hashme_> Can you guys see this error
13:50:02 <hashme_> http://lpaste.net/349796
13:50:41 <hashme_> Nvm I missed an = sign
13:50:41 <Koterpillar> hashme_: otherwise = remaining
13:50:48 <EvanR_> ski: i wonder if computers could use that for something
13:51:19 <EvanR_> base -2
13:52:32 <ski> EvanR_ : perhaps one could try forming an `n'-bit adder/subtractor/comparator, with this representation, and see how it goes
13:57:35 <seishun> how can I merge a Map with a list of key-value pairs with a combining function?
13:58:39 <seishun> the keys in the list are all unique, but some of them might be already present in the map
14:00:02 <seishun> fromList followed by unionWith I suppose
14:00:29 <Tuplanolla> Fold with insert, seishun.
14:01:23 <seishun> yeah I suppose that would be better
14:01:29 <EvanR_> insertWith
14:01:36 <EvanR_> that lets you use a combining function
14:01:47 <ski> @type Data.Map.insertWith
14:01:48 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
14:01:49 <ski> @type Data.Map.insertWithKey
14:01:51 <lambdabot> Ord k => (k -> a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
14:02:02 <ski> @type Data.Map.unionWith
14:02:03 <ski> @type Data.Map.unionWithKey
14:02:03 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
14:02:05 <lambdabot> Ord k => (k -> a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
14:07:57 <gamegoblin> Hey all whatâ€™s the current best way to get ghc, cabal etc? haskell-platform?
14:08:05 <gamegoblin> (on ubuntu)
14:08:42 <Koterpillar> apt if you are on a recent release; if you need the latest ghc, stack
14:11:45 <seishun> insertWith is inconvenient to use with fold because it takes the map as the last argument...
14:13:06 <dfeuer> seishun, are the values in the list ordered? Why are they in a list?
14:13:52 <ab9rf> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
14:13:53 <lambdabot> Data.Strictness.HT arguments3 :: (a -> b -> c -> x) -> a -> b -> c -> x
14:13:53 <lambdabot> Data.Function.Apply (--$) :: (a -> b -> c -> d) -> c -> a -> b -> d
14:13:53 <lambdabot> Data.Function.Slip slipl :: (a -> b -> c -> d) -> c -> a -> b -> d
14:13:55 <dfeuer> And I agree with you: you're likely better off converting the list and then taking the union.
14:14:03 <seishun> dfeuer: not ordered
14:14:20 <seishun> to be precise the list actually contains just keys, the value will be the same for all
14:14:45 <seishun> I want to insert only if the value is less than the existing key, if any
14:14:49 <dfeuer> How'd you end up with a list of unique keys?
14:15:08 <seishun> trying to implement dijkstra's algorithm
14:16:02 <dfeuer> I'm not sufficiently familiar with that algorithm to guess exactly what you mean.
14:16:27 <dfeuer> But I do know it uses a priority queue. Where's the Map come in?
14:16:35 <ab9rf> dijkstra sssp?
14:17:47 <seishun> I'm using a map instead of a priority queue
14:19:25 <seishun> the list contains neighbor vertices
14:21:57 <dfeuer> seishun, okay. I think the unionWith approach is good. If there are more than one or two neighbors, it's likely to be faster.
14:22:10 <dfeuer> But you can benchmark.
14:22:22 <seishun> I'm not aiming for high performance
14:22:25 <dfeuer> Of course, using Map as a priority queue is probably not the greatest idea anyway.
14:23:39 <seishun> `unvisited' = foldl (\m k -> insertWith min k (distance + 1) m) unvisited $ neighbors current`
14:23:40 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard. Key in /topic
14:23:44 <seishun> this doesn't look pretty
14:28:51 <EvanR> ski: i see under the meaning of equality of sets that something can be element of two different sets... thats weird
14:29:42 <EvanR> if a in A <-> a in B, and a=b in A <-> a=b in B, then A=B
14:30:14 <EvanR> so this kind of set or type is really like a setoid
14:30:36 <EvanR> which draws elements from the same global universe
14:30:50 <hackrilege> What was the type?
14:31:04 <ski> EvanR : page ?
14:31:09 <hackrilege> And has anyone looked at https://github.com/MateVM
14:31:13 <hackrilege> ?
14:31:34 <EvanR> page 14 and 15 go over the rules a second time
14:31:45 <EvanR> first mentioned on 9
14:31:56 <hackrilege> https://github.com/MateVM/MateVM
14:32:00 <hackrilege> Sorry...
14:32:04 <lpaste> hexagoxel pasted â€œWhat is a good name for this class?â€ at http://lpaste.net/349799
14:34:32 <hexagoxel> looking at possible lawful instances, it seems important that the internal structure is static (around the parameter type).
14:35:05 <hackrilege> :t either
14:35:07 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:35:18 <hexagoxel> but I don't know how to name the method really, if I follow that pattern.
14:35:18 <ski> EvanR : i think that is possibly intended to *allow* formation of subsets (e.g. of "structural sets" a la <http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html>), and to subsequently show that some subsets are equal to the full set
14:37:07 <ski> EvanR : .. perhaps another take could be to think of it as talking about the formable terms (existing prior to the type-assignment rules, but still allowing for "bound variables" (cf. HOAS))
14:43:10 <EvanR> so category here is kind of like "kind"
14:45:42 <ski> yes
14:50:13 <HactarCE> Does anyone know why I'm getting an error for this line?
14:50:23 <HactarCE> firstValidMove Nothing : array = firstValidMove arraying
14:50:38 <glguy> you need ()s around the : pattern
14:50:43 <ski>   firstValidMove (Nothing : array) = firstValidMove arraying
14:50:44 <HactarCE> Ah thanks :)
14:50:49 <ski> what you wrote means the same as
14:50:55 <ski>   (firstValidMove Nothing) : array = firstValidMove arraying
14:51:14 <HactarCE> ok thanks
14:51:15 <ski> which isn't what you meant (and is even a syntax error, because such things aren't supported in pattern syntax)
14:51:45 <HactarCE> just realized there were half a dozen other typos in the snippit I sent, but whatever :)
14:51:56 <ski> function application can be seen as an invisible infix binary operator, which is left associative, and binds tighter than any other infix operator
14:53:35 <HactarCE> Function application meaning 'f arg1 arg2'? Isn't that prefix...?
14:53:36 <ski> (except from a few special syntax constructions like `@',`~',`!' (in patterns), and `... {...}' (record syntax, both in patterns (construction) and expressions (construction and update)). but all ordinary binary operators bind less tightly than application)
14:53:41 <ski> no
14:53:53 <ski> `f' isn't a prefix operator
14:54:06 <HactarCE> Where f :: a -> b -> c or something
14:54:23 <ski> and `f arg1' is certainly not a prefix operator being attached to `arg2'
14:54:30 <ski> `f arg1' is an expression
14:54:49 <HactarCE> I'm new to Haskell, please have sympathy D:
14:54:53 <HactarCE> You're completely losing me
14:55:04 <ski> in `a b (c d)', both `a b' and `c d' are ordinary expressions, and there's an "invisible" function application inbetween them
14:55:07 <ski> ok
14:55:09 <HactarCE> So what do you mean by "function application"?
14:55:26 <ski> i mean applying a function expression to an argument expression
14:55:32 <ski> e.g. `not False'
14:55:59 <HactarCE> Where `not' is the function expression and `False' is the argument expression?
14:56:15 <ski> yes
14:56:17 <ski> or `(div 16) (3 + 4)'
14:56:29 <ski> where `div 16' is the function expression, and `3 + 4' is the argument expression
14:56:38 <ski> > (div 16) (3 + 4)
14:56:40 <lambdabot>  2
14:56:59 <HactarCE> Ok. I think I see what you mean now about the invisible infix stuff
14:57:14 <HactarCE> But I don't see how `myFunc arg1` is not a function expression
14:57:14 <ski> now, `div 6' is in turn a function application, of the function expression `div' (which is just a variable name, which happens to refer to a function), to the argument expression `16'
14:57:30 <HactarCE> `myFunc' is function expr and `arg1' is argument expr**
14:57:46 <ski> `myFunc arg1' is an expression which represents a function. but it's not an (infix, nor prefix) *operator*
14:57:58 <ski> yes
14:58:00 <HactarCE> Right
14:58:17 <HactarCE> So how is there an invisible operator involved in `(div 16) (3 + 4)'?
14:58:26 <ski> > - (- 3)  -- example of prefix operator in Haskell
14:58:28 <lambdabot>  3
14:58:45 <HactarCE> Ok
14:58:51 <ski> let's for the moment pretend that this infix application operator was actually written as .. say `@'
14:59:06 <ski> then `(div 16) (3 + 4)' would be `(div @ 16) @ (3 + 4)'
14:59:12 <HactarCE> Right
14:59:21 <Koterpillar> ski: you forgot the +
14:59:28 <ski> Koterpillar : i did not
14:59:33 <HactarCE> And even `(div @ 16) @ ((+) @ 3 @ 4)' if we wanted
14:59:41 <Koterpillar> ...okay?
14:59:54 <HactarCE> Because `(+)' is its own infix operator
14:59:57 <HactarCE> Right?
15:00:02 <ski> HactarCE : no, `(+)' is an expression, not an operator, i wanted to keep that as an operator (in order for every expression "node" to be an operator, in this example)
15:00:12 <ski> but since `@' (function application) is left-associative, we can actually write this as `div @ 16 @ 3 + 4'
15:00:19 <ski> HactarCE : ok
15:00:28 <HactarCE> Woa woa woa back up
15:00:37 <ski> sorry, the last "no, ..." comment was for Koterpillar
15:00:50 <HactarCE> ok
15:01:00 <HactarCE> Then I'm still following I think
15:01:49 <HactarCE> But how do we know that `div @ 16 @ 3 + 4' won't evaluate to `(div @ 16 @ 3) + 4'?
15:02:18 <ski> Koterpillar : `(+) @ 3 @ 4' would be *equivalent* to `3 + 4' (just like `[0,1,2,3]' is equivalent to `0 : 1 : 2 : 3 : []'). but they're still different expressions. the former is a function application expression. the latter is an infix operator expression
15:02:34 <Koterpillar> ski: ok, misunderstood your intentions earlier
15:02:57 <ski> Koterpillar : np, just clarifying what i had in mind
15:03:01 <ski> HactarCE : well, how do we know `2 + 3 * 4' won't evaluate to the same as `(2 + 3) * 4' ?
15:03:41 <ski> HactarCE : well, we know that the convention is that `*' binds more tightly (in Haskell, "has higher precedence (level)") than `+'
15:03:48 <HactarCE> Gotcha ok
15:04:26 <ski> HactarCE : and by the same token, this magic function application operator, `@', binds more tightly than, has higher precedence than, every (normal) infix operator
15:04:47 <HactarCE> Ok
15:05:20 <HactarCE> It's like dark energy/matter -- ubiquitous, invisible, and more powerful than ordinary things :P
15:05:33 <ski> (the few exceptions aren't operators in the normal sense, they're more like hard-wired syntactic constructions that happen to look like operators. one could perhaps call them "syntactic operators". otoh, *ordinary* operators in Haskell aren't hard-wired to the language, can be defined (and redefined) at will, by the programmer)
15:05:56 <ski> d: HactarCE
15:09:06 <HactarCE> So are the parentheses in the expression `f (a ++ b) c' unnecessary?
15:09:07 <ski> HactarCE : the precedence levels in Haskell are integers between `0' and `9' (inclusive). for the purposes of comparing precedence levels of operators, one treats function application as having precedence level `10' (this shows up occasionally, when hand-writing "instances for `Show' and `Read'", which are for converting a value to a string (representing a Haskell expression) and back, for debugging purposes only (not pretty-printing))
15:09:25 <ski> (hrm, cut off near ".., for debugging purposes only (not pretty-printing))")
15:09:50 <ski> HactarCE : `f a ++ b c' would mean the same as `(f a) ++ (b c)', which isn't the same thing
15:10:10 <HactarCE> okay good to know :s
15:10:14 <ski> so, those brackets in your expression are necessary, nonredundant
15:10:22 <HactarCE> Re operator precedence: I noticed that looking at http://kevincantu.org/code/operators.html :) Still not sure about left/right/non-associative thing
15:11:22 <ski> sometimes people seem to think that one must write brackets around a "list constructor" expression/pattern, like `element : elements', simply because one most commonly need to do that, in order to force the correct reading wrt precedence
15:11:47 <ski> > 2 : [3,5,7]  -- shows what `:' does, adds a single element to the front of a list
15:11:49 <lambdabot>  [2,3,5,7]
15:12:45 <ski> @let headTimesSumOfRest (element : elements) = element * sum elements
15:12:48 <lambdabot>  Defined.
15:12:51 <ski> > headTimesSumOfRest [2,3,5,7]
15:12:55 <lambdabot>  30
15:13:02 <ski> computes `2 * (3 + 5 + 7)'
15:13:03 <gooby> i goby
15:13:05 <gooby> hey all
15:13:31 <ski> in this case, one needs to wrap the `:'-operator pattern in brackets
15:13:39 <ski> however, consider
15:14:15 <ski> @let firstPrime : remainingSmallPrimes = [2,3,5,7]
15:14:17 <lambdabot>  Defined.
15:14:19 <ski> > firstPrime
15:14:22 <lambdabot>  2
15:14:24 <ski> > remainingSmallPrimes
15:14:26 <lambdabot>  [3,5,7]
15:15:00 <EvanR> ski: this is an interesting distinction now that i see it, set/type means you have exhaustive rules for generating the elements. and category means... you dont, he says because it just doenst make sense. but we have all kinds of examples from set theory where its provably impossible
15:15:20 <EvanR> like all subsets of N
15:15:25 <ski> in this case, we didn't need to write `(firstPrime : remainingSmallPrimes) = [2,3,5,7]', because there was nothing which would require us to insert them, in order to avoid another interpretation of the expression, due to operator precedence or associativity
15:16:10 <EvanR> so this notion of category seems even more useful
15:16:37 <ski> HactarCE : `==' is non-assocaitive (simply `infix', in Haskell syntax). meaning that `x == y == z' is illegal, you must write either `(x == y) == z' or `x == (y == z)', depending on which you intend
15:17:10 <HactarCE> Oh okay. Interesting
15:17:21 <ski> HactarCE : `-' is left-associative (`infixl'), meaning that `x - y - z' means `(x - y) - z'. if you intended `x - (y - z)', then you must write the brackets there
15:17:47 <HactarCE> Or do `x - $ y - z' or something similar
15:18:09 <ski> HactarCE : `**' (exponentiation, "raise to the power of") is right-associative (`infixr'), meaning that `x ** y ** z' means `x ** (y ** z)'. if you intended `(x ** y) ** z', then you must write the brackets there
15:18:19 <HactarCE> Ok thanks that makes more sense
15:18:41 <EvanR> two elements are equal if they yield equal canonical elements, now i see where hott has trouble, because you can get into situations where equal elements dont reduce
15:18:56 <ski> HactarCE : well .. you can't write two infix operators in a row like that (`$' is an ordinary infix operator, having the *lowest* precedence level (`0'), as opposed to the "invisible application operator", which i wrote as `@' above)
15:19:25 <HactarCE> oh?
15:19:27 <HactarCE> ok
15:20:08 <HactarCE> Ofc even easier in this case would be simply `x - y + z' :P
15:20:11 <ski> HactarCE : further, if you have `x op0 y op1 z', where `op0' and `op1' are infix operators (which can't consist of any letters or digits, only "symbols"), then first the precedence levels of `op0' and `op1' are compared, to see which of them "wins" in the "tug-o'-war" over the poor `y' stuck inbetween them
15:22:29 <ski> HactarCE : in case both have the same precedence level, then you compare their associativity. if both are left-associative, then `op0' wins. if both are right-associative, then `op1' wins
15:22:44 <ski> otherwise you must bracket more, to disambiguate
15:24:10 <HactarCE> Ok interesting
15:24:11 <HactarCE> thanks
15:24:23 <ski> HactarCE : so because `+' and `-' have the same precedence level (and `+' is also declared as left-associative, even though it always ought to be an associative operator, meaning that both associations yield the same result), `a - b - c + d - e' will mean `(((a - b) - c) + d) - e'
15:24:50 <ski> and similarly for `a / b / c * d / e' (`*' and `/' sharing a different precedence level)
15:25:59 <HactarCE> ok
15:26:09 <ski> EvanR : "so this notion of category seems even more useful" -- in which sense ?
15:26:28 <EvanR> the one in PML ITT
15:26:48 <EvanR> the open world thing
15:27:05 <ski> EvanR : subsets of `|N' is comparable to a function space / exponential, which is more similar to codata than to data. i wonder how "category" here would compare to codata. presumably it's still not the same thing (?)
15:27:24 <EvanR> he gives functions from N to N as an example of a category
15:28:16 <EvanR> its not something you would be able to enumerate
15:28:33 <EvanR> or want to, i take it
15:28:50 <HactarCE> Another question: So `f1 f2 arg' = `(f1 f2) arg', but what is the difference (if there is one) between `f1 (f2 arg)' and `(f1 . f2) arg' (and furthermore `f1 . f2 arg')?
15:30:17 <EvanR> (typed) lambda calculus expressions for functions is another story
15:30:29 <EvanR> or primitive recursive functions
15:30:53 <benzrf> EvanR: where is "two elements are equal if they yield equal canonical elements" from?
15:30:58 <benzrf> that sounds like judgmental equality to me
15:31:45 <EvanR> thats a combination of an observation and the mixing of what element means from the first few sections
15:32:09 <EvanR> it says "lets just conflate element to mean canonical elements and programs to generate canonical elements"
15:32:16 * ski just refreshed on the relevant pages
15:32:37 <benzrf> EvanR: well, all of that only works in empty contexts
15:32:51 <EvanR> equality is defined on canonical elements, then you get an obvious way to extend that to all elements
15:32:53 * ski isn't quite sure in which sense Martin-LÃ¶f intends the power construction on the naturals as a category (but not a set), there
15:33:14 <hackrilege> > map ($ 0) $ map (+) [1..10]
15:33:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:33:26 <EvanR> theres certainly no way to have an exhaustive set of rules to generate all subsets of N
15:33:33 <ski> <EvanR> he gives functions from N to N as an example of a category
15:33:44 <ski> actually, as an example of a set (given that `|N' is a set)
15:34:02 <EvanR> he says both
15:34:03 <glguy> HactarCE: (f . g) x    evaluates to   f (g x),   the two expressions are indistinguishable
15:34:46 <glguy> (f . g x)   evaluates to   \y -> f (g x y)
15:35:00 <HactarCE> ah ok
15:35:00 <ski> "The reason that `B^A' can be construed as a set is that we take the notion of function as primitive, insead of defining a function as a set of ordered pairs or a binary relation satisfying the usual existence and uniqueness conditions, which would make it a category (like `|P(A)) instead of a set."
15:35:21 <EvanR> pasting
15:35:42 <HactarCE> So if the end result of `(f . g) x' is :: a -> b then `f . g x' would work as well?
15:36:06 <ski> (obviously, since sets are (or can be considered to be) categories, it's also a category)
15:36:37 <EvanR> http://lpaste.net/349800
15:36:49 <glguy> HactarCE: No, those are just different things
15:37:27 <EvanR> seems to be saying B^A isnt a set... but clearly it also calls it a set anyway
15:37:32 <EvanR> so now im confused
15:38:16 <EvanR> blasteed paste
15:39:02 <ski> EvanR : clearly being able to inductively generate the canonical objects isn't the only criterion used to deeming a category a set
15:39:21 <EvanR> what is the missing criteria?
15:39:36 <ski> pg. 23, by quote above, i think
15:39:49 <ski> (perhaps there are more criteria ?)
15:40:15 <grazie> `cabal install hakyll` didn't install the preview server. supposedly I can rebuild and set flag to True... anyway this can be done with cabal?
15:40:41 <EvanR> uhm. its a set because its a primitive...
15:41:07 <EvanR> oh well, i thought i was on to something ;)
15:41:14 * ski agrees that the desiderata here doesn't seem particularly clear
15:41:47 <geekosaur> grazie, reinstall with the -f (or --flags=) option specifying the flag in question
15:42:11 <ski> perhaps the idea is that functions are to be thought of as determined by their *behaviour* on *elimination* (rather than introduction), cf. codata
15:42:31 <ski> while categories could be more "wild" than that
15:43:24 <ski> (there is no (sensible) elimination rule for `Set', a universe (as opposed to a particular fixation of it as an inductive type))
15:43:50 <EvanR> in the introduce of categories, he says we dont necessarily have rules for exhaustively generating all the objects. one example is sets which are supposed to be added at will. another is what seems like type constructors like product of two sets
15:44:02 <EvanR> introduction*
15:44:23 <EvanR> we can know what objects of a category are and when they are equal
15:44:41 <EvanR> but we cant generate them all, the objects dont form a set
15:45:00 <grazie> geekosaur: ok, thank you trying it `cabal install hakyll --reinstall -f previewServer`
15:45:11 <EvanR> focusing instead on how they eliminate, interesting, i didnt see that in the text
15:45:22 <ski> "the category of binary functions which take two sets into another set." .. think `Set^(Set * Set)' (in category theory)
15:46:02 <EvanR> so why is that not a set but N^N is
15:46:08 <ski> EvanR : in this case, i think it's considered a ("pure") category, because it has "components" coming from categories
15:46:27 <ski> (hm, s/pure/proper/)
15:48:17 <ski> EvanR : "focusing instead on how they eliminate, interesting, i didnt see that in the text" -- on p. 26, you have extensionality for functions -- but i agree that the text seems to emphasize construction/introduction as more basic than de(con)struction/elimination
15:48:20 <EvanR> regardless, maybe its a happy accident to see that not wanting to or not being able to come up with logical rules to generate everything of a certain kind is an important distinction
15:50:59 <ski> (whereas i think that you need both perspectives, after reading about Curry-Howard-Lambek, adjunctions, `F'-(co)algebras (e.g. "A Tutorial on (Co)Algebras and (Co)Induction"), Jacobs' "Categorical Logic and Type Theory")
15:54:32 <ski> EvanR : probably one could also draw a connection to (im)predicativity issues
15:55:34 <ski> `Set^(Set * Set)' could be "extended at will" (by extending `Set'). not so (?) with `|N^|N'
15:55:36 <grazie> geekosaur: if this is the flag in the stack.yaml file, do you know how I would pass that flag in cabal (exactly)? I did `cabal install hakyll --reinstall -f previewServer=True` and it didn't work
15:55:51 <grazie> geekosaur: this is the flag in the stack.yaml https://github.com/jaspervdj/hakyll/blob/master/stack.yaml#L8
15:56:08 <EvanR> (?) indeed
15:56:23 <EvanR> in what sense is it not extensible
15:56:47 <geekosaur> ...sigh this will take a bit..
15:57:05 <geekosaur> grazie, just the flag not the value
15:57:12 <geekosaur> -fpreviewServer
15:57:28 <geekosaur> also note cabal knows nothing of stack.yaml although I hope those flags are also in the cabal file
15:57:33 <EvanR> like Set supposedly is
15:57:38 <ski> (let's consider instead `data SmallOrdinal : Set where Zero : SmallOrdinal; Succ : SmallOrdinal -> SmallOrdinal; StrictSup : (Nat -> SmallOrdinal) -> SmallOrdinal' (with the addition that the sequence there is strictly increasing, if you prefer))
15:58:24 <Myrl-saki> Why is `mappend x y /= x` not a requirement?
15:58:32 <ski> (now, constructing a new inhabitant of `Nat -> SmallOrdinal' could cause you to construct yet another `SmallOrdinal', greater than the previous ones)
15:58:49 <hpc> Myrl-saki: for Monoid?
15:58:52 <EvanR> > mappend [1,2,3] []
15:58:54 <lambdabot>  [1,2,3]
15:58:55 <ski> > mappend (First 2) (First 3)
15:58:57 <lambdabot>  error:
15:58:57 <lambdabot>      â€¢ Ambiguous type variable â€˜a0â€™ arising from a use of â€˜show_M353139950194...
15:58:57 <lambdabot>        prevents the constraint â€˜(Show a0)â€™ from being solved.
15:59:03 <grazie> geekosaur: ok, trying it again (and yes the flag's in the cabal file)
15:59:14 <ski> > mappend (First (Just 2)) (First (Just 3))
15:59:17 <lambdabot>  First {getFirst = Just 2}
15:59:40 <geekosaur> flags can only be true or false, if you wanted to mark one false it'd be -f-Foo for flag Foo
15:59:50 <EvanR> ski: right
16:00:01 <Myrl-saki> hpc: mhm
16:00:12 <hpc> yeah, what they said
16:00:18 <hpc> but also there's no reason for it to be a requirement
16:00:33 <ski> EvanR : so the "(?)" isn't that clear in my mind atm, at least ..
16:00:39 <Myrl-saki> hpc: Mmm. true. I was just thinking of ()
16:01:20 <ski> Myrl-saki : anyway, both the neutral element case, and the `First' (and `Last') case are practically useful
16:02:06 <EvanR> ski: my original line of thought when i "realized" what was going on was that uncountability is really some form of openness in disguise, but maybe thats all wrong
16:02:06 <ski> if one would consider `forall x y. mappend x y = x => y = mempty', then `First' (and `Last') would still be practical counterexamples
16:02:32 <ski> EvanR : perhaps it's a different "kind" of openness
16:02:47 <ski> an openness in actually carrying out constructions
16:03:17 <ski> as opposed to an openness in applying some creativity in e.g. specifying a new set in some (valid) way
16:03:39 <ski> (is there a difference here, apart from one of these occuring one "meta" above the other ?)
16:04:32 <jmcarthur> Myrl-saki: In fact, `mappend x mempty` must be `x`.
16:04:32 <EvanR> since subsets of of infinite sets, real numbers, and other things amount to functions of one form or another, seems like that is still involving creativity
16:04:42 <EvanR> unless functions are restricted
16:05:33 <EvanR> you can come up with a brand new real number by specifying a brand new cauchy approximation (function of rationals)
16:05:47 <ski> jmcarthur : we noted earlier today that `mappend (undefined :: ()) mempty' is defined to be `()' rather than `undefined' ..
16:06:17 <EvanR> someone may or may notbe able to come up with a "brand new" proof that it is equal to some other equally creative real number
16:06:51 * ski wonders whether the distinction between algorithmic and computable is relevant here
16:07:55 <EvanR> algorithmic vs computable ?
16:08:25 <ski> algorithmic means that you can write a finite program (expression) to encode it. computable is just an intuitive notion. it's an open question whether physical processes (under some suitable idealization (which ?), presumably) are algorithmic, or merely computable
16:09:24 <hpc> does that mean fix id is algorithmic?
16:09:27 <ski> to add two real numbers, represented as cauchy sequences, you don't need to know that there is an algorithm computing each of the sequences, you just need to be able to eventually get a hold of the `n'th element of each sequence, for any natural number `n'
16:10:11 <ski> (EscardÃ³ mentions this a little in his thesis)
16:10:13 <ski> @where topology
16:10:13 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
16:10:13 <lambdabot> dvi|ps)> by Martín Escardó
16:10:22 <EvanR> addition of reals seems incredibly unproblematic
16:10:40 <EvanR> unless youre trying to represent it with digit sequences
16:11:01 <EvanR> im half way through that paper
16:11:25 <ski> the point is that we could imagine one (or both) of the reals as coming from physical measurements, where we don't presuppose that there's an algorithm (in the sense of being computable by a finite program) that computes the Cauchy sequence
16:11:27 <jmcarthur> ski: Yeah, I "hate" it when I see things like that. (It probably doesn't matter all that much in practice.)
16:11:55 <ski> we're just assuming that, given enough time and resources, we could in principle get as accurate measurings as we desire
16:12:21 <ski> (this is obviously ignoring quantum problems, Heisenberg uncertainty principle, &c.)
16:12:47 <yhhko> https://xkcd.com/1240/
16:12:51 <EvanR> that... doesnt make sense as is. but you could say the input is a stream from a sensor and just call each subsequent input the 10^-n digit
16:12:52 <Tuplanolla> This reminds me of people who call certain Monte Carlo procedures exact.
16:13:02 <EvanR> you cant really measure something to get a real number
16:13:25 <EvanR> in both cases were not talking about the same thing anymore
16:13:30 <yhhko> EvanR: the measurement *process* is the real number :)
16:13:30 <ski> yhhko : ty
16:13:55 <EvanR> yhhko: you mean like the speed of light?
16:13:58 <EvanR> or length of meter
16:14:04 <EvanR> the output of that isnt a number
16:14:15 <yhhko> it totally is though, bad example
16:14:20 <EvanR> its a platinum bar or meter stick
16:14:46 * ski . o O ( "Does Every Real Number Have a Decimal Expansion?" by Luitzen Egbertus Jan Brouwer in 1921 )
16:15:11 <yhhko> ski: the answer: no
16:15:20 <EvanR> ski: that is sort of what i am thinking, the reals are a lot more open than normally considered
16:15:21 <yhhko> decimal expansions are pretty crap from a computability POV
16:15:46 <yhhko> you can't even compute the function *3 if your reals are represented by decimal expansions
16:15:58 <EvanR> yes that representation is bad
16:16:03 <ski> yhhko : if you assume some anti-classical axioms, like bar induction, or church's thesis, then probably you can prove the answer is "no"
16:16:24 <yhhko> if you want to work constructively, you can provably not prove it
16:16:32 <ski> hpc : obviously one needs to add in something about termination/totality as well, to get an inclusion
16:16:34 <EvanR> which is why i said cauchy approximations, which are functions of reals satisfying some lawws, to put the burden back on functions
16:16:40 <yhhko> if you want to lie and use some amount of choice, sure, it's possible
16:16:56 <yhhko> EvanR: that's one of several ways to "fix" it yeah
16:17:09 <EvanR> i think at this point the thread is not even about proving stuff
16:17:31 <yhhko> you can provably not write *3
16:17:34 <EvanR> its like the qualitative aspects of what logic does for you
16:17:37 * ski takes yhhko's "constructively" to mean in the ecumenical sense
16:18:05 <yhhko> ski: i subscribe to thorsten altenkirch's view on constructivity :)
16:18:10 <EvanR> *3 is fine
16:18:21 <ski> yhhko : is that elaborated anywhere in particular you'd suggest ?
16:18:23 <yhhko> EvanR: what makes you say that?
16:18:23 <EvanR> obviously decimal exapnsions are silly
16:18:27 <EvanR> not on topic
16:18:30 * ski . o O ( #constructive-math )
16:18:33 <yhhko> EvanR: ah yeah :)
16:19:26 <yhhko> ski: e.g. http://www.fields.utoronto.ca/video-archive/static/2016/05/2012-15058/mergedvideo.ogv
16:19:32 <ski> ty
16:20:21 <yhhko> (that's hott-specific but it conveys the essence i think)
16:20:58 <EvanR> my line of questions were not classical, but not obviously construtive either
16:21:12 <EvanR> uh oh philsoophy
16:21:24 * ski bookmarks it for later
16:21:26 <yhhko> EvanR: well we're in #haskell. we are interested in writing programs.
16:21:34 <yhhko> they are constructed without choice
16:21:42 * ski . o O ( philosophy of writing programs )
16:22:07 * ski . o O ( "Intensional vs Extensional Choice" by roconnor in 2005-06-04 at <http://r6.ca/blog/20050604T143800Z.html>,"100 years of Zermelo's axiom: what was the problem with it?" by Per Martin-LÃ¶f in 2006 at <http://www.math.kth.se/~kurlberg/colloquium/2005/MartinLooef.pdf> )
16:22:22 <EvanR> ski: i cant seem to google the decimal expansion paper by brouwer
16:22:40 <ski> EvanR : i'm not aware of it being online :(
16:22:51 <EvanR> where is it at all?
16:23:12 <yhhko> e.g. in "from brouwer to hilbert"
16:23:22 <yhhko> it's not a great article if you're not a fan of brouwer's math
16:23:43 <yhhko> if you want to be convinced that decimal numbers are crap for constructive or computational stuff, consider *3
16:23:55 <EvanR> i know...
16:24:12 <yhhko> then there's not much to learn from that article except for historical relevance
16:24:22 <EvanR> oh so its about that
16:24:28 <ski> (hm, it doesn't seem to be available in "Frege to GÃ¶del: A Source Book in Mathematical Logic, 1879-1931", compiled by Jean van Heijenoort in 1967, either)
16:24:30 <yhhko> he has more convoluted examples
16:24:48 <yhhko> the *3 counterexample was discovered later
16:27:19 <ski> (oh, it's in "From Brouwer to Hilbert : The Debate on the Foundations of Mathematics in the 1920s", compiled by Paolo Mancosu in 1997-09, though :)
16:27:34 <EvanR> ok
16:27:34 * ski notices yhhko already mentioned it
16:27:39 <yhhko> :)
16:28:42 <ski> Tuplanolla : .. how's that ?
16:29:20 <Tuplanolla> What?
16:29:22 <EvanR> bought it
16:30:37 <EvanR> resurrecting debates on foundations of math from 1920s, so hipster
16:30:53 * ski idly seems to recall augustss/lennart expressing impatiently waiting for ZFC to be proved inconsistent
16:31:04 <ski> Tuplanolla : "This reminds me of people who call certain Monte Carlo procedures exact."
16:33:38 <ski> EvanR : must be the turn of the century
16:34:04 <EvanR> dependent type theory is more powerful than first order logic right
16:34:14 <EvanR> does that mean you could prove ZFC consistent
16:34:20 <yhhko> define "powerful"
16:34:21 <Tuplanolla> It's a bit silly, because the results they produce are still presented with error estimates due to the authors not having an infinite time to run the thing.
16:34:30 <EvanR> despite incompleteness
16:34:49 <Tuplanolla> That's how it appears in physics, ski.
16:34:52 <ski> Tuplanolla : well, "exact in the limie" :)
16:36:28 <ski> (s/limie/limit/)
16:36:36 * ski . o O ( <http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/> )
16:37:03 <hpc> i have an exact monte carlo procedure for deciding ZFC's completeness
16:37:21 <hpc> where i randomly check here every so often to see if someone else proved it
16:37:29 <ski> EvanR : well, ZFC is a first order theory, which isn't the same as plain first order logic
16:39:26 <ski> EvanR : but if one could represent ZFC & first order logic in dependent type theory adequately, then inconsistency in ZFC would leak into dependent type theory (see relative consistency), iiuc
16:40:28 <EvanR> so they are equiconsistent
16:40:38 <yhhko> ski: i don't see how inconsistency of ZFC implies inconsistency of all dependent type theories
16:41:05 <yhhko> you'd need to prove that, in any dependent type theory, you can define a model of ZFC. i don't think this has been done.
16:45:39 <ski> yhhko : this was handwaving, wrt some particular dependent type theory
16:45:53 <yhhko> which one?
16:46:40 <ski> the "..., iiuc" statement
16:47:19 <yhhko> yeah but which particular DTT?
16:47:38 <ski> (the "if ..." quantified over "reasonable" DTTs, not picking a particular one)
16:48:05 <ski> (i probably should have said "a dependent type theory")
16:48:25 <yhhko> still, which one?
16:48:37 <ski> illformed question
16:49:23 <ski> "`forall n : |N. even (n*n) => even n' !" -- "Which `n' in `|N' ?"
16:50:52 <yhhko> ski: "for example n=2"
16:50:56 <ski> (i wasn't intending to pick a particular one, i was vaguely talking about any one for which one could "represent adequately", &c.)
16:52:01 <ski> i don't know enough about the topic to know which DTT (if any) would apply
16:52:29 <ski> (cf. "I don't know whether the domain of implication / universal quantification is inhabited.")
16:53:40 <xcmw> Is there a type operator that will combine two * -> Constraint into one?
16:54:20 <xcmw> Eq `operator` Show
16:59:14 <ski>   class (c0 a,c1 a) => And c0 c1 a
16:59:23 <ski>   instance (c0 a,c1 a) => And c0 c1 a
16:59:25 <ski> perhaps ?
16:59:56 * ski was thinking the `constraints' package possibly had something like this, but doesn't look like it
17:00:06 * ski . o O ( <https://xorshammer.com/2016/05/14/the-arithmetic-hierarchy-meets-the-real-world/> )
17:01:01 <xcmw> That requires UndecidableSuperClasses
17:01:43 <ski> iiuc, it should be ok in this case (?)
17:01:48 <ski> EvanR,yhhko :  .. if you're done talking about interesting things now, maybe i can now go to sleep ? ;)
17:01:54 <EvanR> ski: i was just thinking of the von neumann hiearchy too
17:01:59 <EvanR> oh
17:02:47 <xcmw> ski: Thanks that works
17:04:51 <xcmw> Show `And` Eq `And` Num works
17:05:19 <EvanR> actually i was only done temporarily because i had to walk home, but ill just bother someone else now
17:08:13 * ski 'll try to remember to check backlog later
17:11:36 <EvanR> hehe
17:11:59 <anks> hi, are there any resources on setting up ghcjs+ghcjsi to work with emacs haskell-mode?
17:15:23 <grantwu> I think ghc-mod not doing the right thing with qualified imports is just https://github.com/DanielG/ghc-mod/issues/290
17:15:37 <SrPx> What bad things happens if * : * on the calculus of constructions?
17:15:51 <SrPx> happen*
17:18:00 <yhhko> SrPx: define "bad things"
17:18:26 <yhhko> SrPx: will the compiler blow up? possibly. will it set your cat on fire? depends, is your cat connected to the internet of things?
17:18:28 <SrPx> yhhko: that's my second question. What exactly changes?
17:18:49 <SrPx> that sounds risky
17:19:03 <SrPx> at least no black holes were created
17:19:08 <yhhko> yeah no black holes
17:19:17 <c_wraith> unless you're compiling on the LHC
17:19:23 <yhhko> xD
17:19:42 <SrPx> but seriously, anywhere to read about it? it is hard to google for "* : *"
17:19:49 <c_wraith> SrPx: it allows certain paradoxes in the type system.  Things like Russell's paradox, for instance.
17:20:15 <SrPx> I'd love to see some construction of that paradox in practice
17:20:35 <yhhko> c_wraith: but to be fair, paradoxes were already possible in haskell anyway
17:20:35 <SrPx> Is it still strongly normalizing?
17:20:56 <yhhko> SrPx: no, but neither is haskell without *:*
17:21:16 <c_wraith> yhhko: sure, which is why it's no big deal to introduce it in Haskell.
17:21:49 <yhhko> SrPx: so yeah, long story short, it's terrible and you will cause global hunger, but feel free to enable it
17:22:31 <yhhko> SrPx: on a more serious note: yeah, it makes haskell "even less normalizing", whatever that means
17:23:38 <yhhko> and they also call this "type-in-type"
17:25:26 <EvanR> c_wraith: SrPx the ghc ticket for that feature has a comment that claims no inconsistency results, for some reason
17:25:48 <EvanR> a reason specific to ghc haskell
17:27:15 <c_wraith> EvanR: Goldfiere's paper claims no *additional* inconsistency results in Haskell, because it's already an inconsistent logic. :)
17:27:51 <EvanR> didnt seem like that was th reason
17:28:10 <EvanR> first of all, the type system isnt inconsistent without enabling certain extension
17:28:19 <c_wraith> Sure it is
17:28:21 <c_wraith> :t undefined
17:28:23 <lambdabot> a
17:28:26 <c_wraith> See?
17:28:27 <EvanR> the type system
17:28:35 <EvanR> the type level computations
17:28:37 <c_wraith> that is a proof of a, for all a
17:28:50 <c_wraith> that's already as inconsistent as you can get
17:28:58 <yhhko> EvanR: when people say "inconsistent" they mean "is there a term of type Empty"
17:29:00 <EvanR> we dont have a type level undefined
17:29:10 <EvanR> which causes the compiler to freeze up
17:29:21 <yhhko> and types are erased at compile time, so what you say doesn't really make sense IMO
17:29:47 <EvanR> granted no one is listening to me, so after i eat my chinese appetizer tray ill have to go find that comment
17:31:10 <c_wraith> EvanR: https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell "... * :: * makes a language inconsistent as a logic. However, Haskell is already inconsistent as a logic (because of undefined and GHC.Exts.Any) and so we don't have to worry about a new source of inconsistency."
17:31:24 <c_wraith> EvanR: GHC.Exts.Any is your type-level undefined
17:32:30 <EvanR> or it might have been limited to "girards paradox cant happen"
17:33:01 <c_wraith> EvanR: oh, maybe you were thinking of the next sentence. "Furthermore, the type safety of Haskell does not depend on its own consistency -- unlike Coq and Agda, Haskell relies on the consistency of a coercion language, which is not threatened by * :: *. See the paper for more details."
17:33:20 <EvanR> a comment, not the feature description
17:33:23 <SrPx> I was actually talking about the calculus of constructions itself
17:33:36 <SrPx> I noticed I can do some cool things on the CoC but I need *:* for that
17:33:51 <EvanR> hehe "cool"
17:38:03 <SrPx> yes for example, I can have a generic description of a datatype (like Rec :*: One :+: One :+: Zero) and then derive its fold type (like âˆ€ (a:*) -> (a -> a) -> a -> a) from it
17:38:16 <SrPx> but to do that I need *:*
17:38:22 <SrPx> am I breaking the matrix? 
17:39:06 <wespiser> the matrix breaks you
17:44:05 <Ordentlig> How do you convince someone to mentor you?
17:44:14 <EvanR> money
17:44:38 <SrPx> I just wonder, though, why not just have *:anything_else on the Haskell case? Like box, or a tower of types?
17:44:47 <SrPx> Sounds trivial to implement
17:44:47 <Ordentlig> EvanR, isn't there any other way?
17:45:00 <Ordentlig> like out of sheer love?
17:45:04 <Ordentlig> :)
17:45:38 <EvanR> they might accept that as payment
17:45:41 <Ordentlig> Oh, sorry, perhaps this is too off-topic, I'll stop.
17:45:52 <Ordentlig> EvanR, would you?
17:46:36 <Ordentlig> Don't you yearn for a successor of your knowledge?
17:46:45 <Ordentlig> --stops--
17:48:15 <xcmw> Ordentlig: If you have questions, the people here will answer them. I don't think anyone is going to mentor you.
17:50:33 <Ordentlig> xcmw, alright, had to ask.
17:51:20 <xcmw> Ordentlig: Why do you thing you need a mentor?
17:52:45 <xcmw> A book + google + this irc channel is enough to learn. There are many free haskell books.
17:52:47 <Ordentlig> xcmw, it seems like a nice commitment and relationship to have, someone you can communicate with at a regular basis and bond with.
17:56:33 <xcmw> Ordentlig: The people here are extremely helpful. You should not have a problem.
17:56:39 <EvanR> Ordentlig: haskell meetup group in your city maybe
17:56:55 <Ordentlig> EvanR, good idea, never thought about it
17:57:35 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard. Key in /topic
18:00:29 <EvanR> "This means that inhabited kinds have type *. In particular, * has type *. Though this causes inconsistency in other dependently-typed languages, it does not in Haskell, essentially because equality proofs are written in a different sub-language than ordinary terms."
18:00:29 <EvanR> ill have to settle for this
18:00:29 <EvanR> SrPx: 
18:01:39 <SrPx> EvanR: hmm ok, so, basically, there is no point in making *:anythingelse because *:* doesn't actually cause any problem for haskell
18:02:34 <EvanR> what does anything else mean?
18:02:48 <EvanR> not sure * : anythingelse makes sense
18:03:11 <EvanR> anything else is a type ?
18:03:27 <EvanR> or * : Int
18:03:54 <EvanR> this is absurd enough i will look at adventofcode instead
18:08:29 <geekosaur> BOX :p
18:15:10 <Fusionnex> this is dumb and ive done a bit of googling, but what book would you all reccomend to learn haskell deeply
18:15:15 <Fusionnex> is little schemer still relevant?
18:16:46 <glguy> Not for learning Haskell. I've got a copy of Programming in Haskell 2nd ed on my desk that I like
18:23:09 <z64> i just got the one from haskellbook.com.. been eager to get into it. 
18:23:34 <z64> tried a lot of resources. haskell has been hard for me to learn with something practical to do with it right away.
18:23:41 <z64> *without
18:47:57 <buglebudabey> too bad he left the channel, felleisens stuff is greats
18:47:59 <buglebudabey> great*
18:49:02 <Bynbo7> obaachan: #haskell will mentor you, is available 24/7, but may at time take a while to respond and may be moody at times
18:49:28 <Bynbo7> oh, means Ordentlig but they seem to ahve left. sorry obaachan
18:49:31 <Bynbo7> meant*
18:57:50 <grantwu> Bynbo7: so, you mean to say, we're all human? :P
19:00:45 <Bynbo7> yes
19:02:01 <Bynbo7> I mean no
19:02:13 <Bynbo7> lambdabot is best mentor and is only mostly human
19:02:25 <grantwu> Oooh, good point
19:02:39 <Bynbo7> but even lambdabot can be moody
19:03:08 * Bynbo7 is loving glguy's glirc irc client
19:06:01 <EvanR> huzzah i got a advent of code star
19:06:37 <glguy> yay, and you joined the #haskell list :)
19:07:24 <pavonia> Btw, did anyone solve the yesterday's puzzle programmatically?
19:07:51 <glguy> at least byorgey and I did
19:08:10 <glguy> I didn't check if seishun did, but I assume so
19:08:45 <pavonia> Cool, I went out of memory too early
19:11:30 <glguy> Did you add yourself to the #haskell aoc list under a name I don't know, perhaps?
19:13:49 <pavonia> Me?
19:14:07 <glguy> Yeah
19:14:30 <glguy> There are a couple of people on the list under their full names, so I didn't know if one of them was you
19:14:46 <pavonia> What list is that?
19:15:00 <glguy> The #haskell AoC leaderboard
19:15:21 <glguy> http://adventofcode.com/2016/leaderboard/private key: 43100-84040706 
19:15:38 <glguy> Just figured if you did enough to run out of memory you might have done others :)
19:16:50 <pavonia> Thanks, I didn't know about that list
19:18:45 <pavonia> Hey, second :D
19:19:14 <glguy> Yeah, and you have a global score, too. Nice :)
20:18:37 <b0llu> is it possible to have a dependantly typed  function?
20:19:17 <b0llu> dependently*
20:19:37 <Bynbo7> if you mean types depending on values, no not really (yet)
20:19:49 <b0llu> ah, dang
20:20:06 <Bynbo7> but, if you have a more specific question the answer might be yes
20:20:12 <b0llu> uh, okay
20:20:23 <b0llu> so, I have this function densematrix_new_eye :: forall r c k. (KnownNat r,  KnownNat c, KnownNat k, KnownNat (r + k), KnownNat (c + k)) => DenseMatrix (r + k) (c + k)
20:20:31 <b0llu> I want to make the "k" a parameter
20:20:42 <b0llu> rather than a type level thing
20:20:47 <b0llu> I want it to be a value level thing
20:20:51 <b0llu> is this possible?
20:21:43 <EvanR> you can get a value within that function 
20:21:44 <Bynbo7> you could use something like (Proxy @7) to pass in a number
20:22:02 <b0llu> EvanR: yep, I know. but I want the API to be easy
20:22:07 <EvanR> haha
20:22:08 <Bynbo7> (or even, if you make k the first parameter in the forall, I think you could just use densematrix_new_eye @7
20:22:14 <b0llu> EvanR: is there a clean way to have a "non matrix typed" API with a "matrix typed" API
20:22:28 <EvanR> i still dont get what youre trying to do
20:22:45 <EvanR> you want to undo the k type?
20:22:53 <EvanR> what would the new type be?
20:22:58 <b0llu> EvanR: can I have a function densematrix_new_eye' :: Int -> forall r c. DenseMatrix (r + k) DenseMatrix (r + k) where k depends on the Int parameter
20:23:06 <b0llu> EvanR: I want a dependant function. 
20:23:15 <EvanR> thatd be a type family
20:23:21 <b0llu> hmm
20:23:26 <b0llu> EvanR: oh, right! interesting
20:23:36 <b0llu> EvanR: wait, no. a type family takes types to types
20:23:38 <EvanR> or another type class
20:23:44 <b0llu> EvanR: not the *value* of Int to the type
20:23:48 <EvanR> yes, its already a type, and you want another type that depends on it
20:23:58 <EvanR> oh the Int
20:24:01 <b0llu> yes
20:24:07 <b0llu> it should depend on the *value* of the Int
20:24:08 <b0llu> :
20:24:09 <b0llu> :)
20:24:09 <EvanR> you cant do that
20:24:12 <b0llu> hence "dependant type"
20:24:13 <b0llu> ah, okay
20:24:15 <b0llu> hm
20:24:41 <EvanR> i.e. :: (k :: Int) -> Foo (r + k)
20:24:51 <Bynbo7> what's wrong with having forall k r c. (KnownNat r,  KnownNat c, KnownNat k, KnownNat (r + k), KnownNat (c + k)) => DenseMatrix (r + k) (c + k) and then calling it with densematrix_new_eye @7?
20:25:23 <EvanR> yeah, breaking that pattern youre already in isnt going to make it much easier on the library user
20:25:32 <EvanR> its already past the point
20:25:45 <b0llu> I see
20:26:32 <EvanR> someone somewhere can take an Int to a KnownNat
20:26:54 <EvanR> or Nothing
20:27:05 <EvanR> to satisfy that some runtime check was performed
20:29:51 <EvanR> someNatVal :: Integer -> Maybe SomeNat
20:44:33 <b0llu> can someone tell me what the exact semantics of unsafePerformIO are?
20:44:41 <b0llu> I'm writing an C FFI to wrap around symengine
20:44:45 <EvanR> none
20:44:48 <b0llu> and I don't want users to have IO everwhere
20:44:49 <b0llu> what?
20:44:56 <EvanR> it doesnt have exact semantics
20:45:04 <grantwu> "Refer to GHC source"
20:45:06 <b0llu> EvanR: okay, give me thumb rule semantics? 
20:45:15 <b0llu> like, when is it "OK" to use unsafePerformIO?
20:45:22 <EvanR> ah now thats a better question
20:45:28 <Koterpillar> when no one find out
20:45:36 <Koterpillar> *when no one finds out
20:45:40 <EvanR> its OK to use unsafePerformIO on an IO action which doesn't do any IO
20:45:50 <EvanR> i have a feeling you wont like that ;)
20:46:28 <EvanR> you may also be able to on top of that get away with IO actions which dont have any side effects
20:46:47 <b0llu> EvanR: is "allocate chunk of memory for object you asked for" a side effect?
20:47:05 <EvanR> so whats the exact api of this?
20:47:40 <b0llu> EvanR: let me link it
20:47:57 <fikse> what is the difference between :add, :load, and when would you use :reload instead of :load?
20:48:03 <b0llu> EvanR: here is how I allocate a chunk of memory: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L126
20:48:10 <b0llu> EvanR: that I care about (a BasicSym)
20:48:14 <EvanR> simply allocating memory doesnt count as a side effect if you never round out of memory
20:48:17 <b0llu> EvanR: that's the core type of the library
20:49:02 <EvanR> so whats is your non-IO api supposed to look like?
20:49:30 <b0llu> EvanR: this is one: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L163
20:49:40 <b0llu> EvanR: symbol "x" creates a symbolic variable "x"
20:50:08 <b0llu> EvanR: is my use of unsafePerformIO "correct"?
20:50:30 <EvanR> and let foo = symbol "x" = (foo, foo) is the same as (symbol "x", symbol "x") ?
20:50:42 <EvanR> er let foo = symbol "x" in (foo,foo)
20:50:53 <b0llu> EvanR: no, I need two different "symbol" s
20:51:00 <EvanR> ... that... does not compute
20:51:02 <b0llu> EvanR: each symbol "x" is a different symbol
20:51:09 <b0llu> EvanR: since it's a different block of memory?
20:51:12 <EvanR> thats not referentially transparent
20:51:16 <b0llu> EvanR: ah
20:51:18 <b0llu> EvanR: hm
20:51:32 <b0llu> EvanR: so, this will need to be inside a monad of some sort?
20:51:40 <EvanR> symbol "x" :: X cant be different from any other
20:51:45 <b0llu> EvanR: okay. what if I say that all symbols with the same name are the same?
20:51:51 <pavonia> fikse: :load loads a Haskell module, :add adds modules to the current set of loaded modules, and :reload is useful when you changed the module loaded by :load (or any dependency) and want to load the updated version
20:52:02 <EvanR> i dont understand why they are different?
20:52:29 <fikse> :load also forgets all previously loaded packages, whereas reload doesn't 
20:52:31 <fikse> thanks pavonia 
20:52:53 <b0llu> EvanR: what happens if you do symbol "x" + 1, symbol "x" + 2?
20:53:11 <b0llu> EvanR: can you give me a quick example to check if this would break or not?
20:53:12 <EvanR> are you trying to get + to have side effects too?
20:53:18 <b0llu> EvanR: no
20:53:21 <b0llu> EvanR: like, my question is
20:53:42 <EvanR> so whats the problem with let s = symbol "x" in (s + 1, s + 2)
20:54:16 <b0llu> EvanR: I'm actually not sure, let me think about this
20:54:19 <MarcelineVQ> fikse: also useful is :reload!  which will reload module while deferring type errors, so if you're working on a file and you want to examine it despite it having compilation issues you can
20:54:48 <fikse> does "target set" refer to the set of modules you are currently interacting within the scope?
20:54:50 <MarcelineVQ> ditto for :load!
20:55:03 <fikse> MarcelineVQ: thank you for that tip!
20:55:27 <MarcelineVQ> fikse: all kinds of useful stuff like that here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
20:55:37 <b0llu> EvanR: you are right, according to my semantics, two symbols are equal if they represent the same name
20:56:05 <EvanR> my original question wasnt if two symbols are equal or compare equal, but if two expressions involving them were equal
20:56:14 <b0llu> EvanR: yes
20:56:24 <EvanR> let x = s in (x,x) vs (s,s)
20:56:35 <b0llu> EvanR: yes, semantically they should be
20:56:46 <b0llu> EvanR: since the are the same symbolic thing
20:57:27 <EvanR> so then defining s "foo" as an unsafePerformIO memory allocation should work
20:57:43 <b0llu> I see
20:58:08 <EvanR> as long as something doesnt deallocate it while the objects still exist
20:58:23 <b0llu> EvanR: yeah, the are all foreign pointers, so they deallocate on GC
21:27:52 <qmm> is there a difference between guards and pattern guards?
21:28:23 <Clint> qmm: https://wiki.haskell.org/Pattern_guard
21:30:26 <qmm> pattern guards seem to be a way to bind values to variables. is this correct?
21:30:58 <qmm> that doesn't seem like an accurate enough definition
21:32:20 <qmm> this is helpful: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
21:32:23 <qmm> thanks Clint 
21:42:19 <gamegoblin> (catching up on haskell news) whats up with overloaded record fields? did that hit yet?
23:48:38 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706'
23:48:38 --- topic: set by glguy on [Fri Dec 09 10:59:28 2016]
23:49:06 <grantwu> I think File !Int !Int !Int !Int would be good
23:49:15 <dmj`> jle`: o/
23:49:23 <jle`>  \o
23:49:41 <shiona> grantwu: what if the number of registers was increased to 8 or 32?
23:49:49 <grantwu> uh...
23:49:54 <grantwu> I have no idea then
23:50:04 <grantwu> Maybe an Array of !Int?
23:50:46 <grantwu> Wait, how does Map Reg !Int do
23:51:07 <jle`> Map Reg !Int is not a thing, heh
23:51:08 <shiona> I'll give it a try
23:51:16 <shiona> ok, then I won't ^^
23:51:17 <grantwu> er
23:51:20 <grantwu> oh
23:51:21 <grantwu> dran
23:51:24 <grantwu> *darn
23:51:28 <shiona> Hmm, An array can use as its index any Bounded Enumerated value right? Maybe I should go with (STArray Reg Int)?
23:52:00 <shiona> maybe some bangs here and there for good measure if needed
23:52:11 <grantwu> pew pew
23:52:35 <EvanR> shiona: i was asking what makes you call it inefficient?
23:52:49 <shiona> http://pastebin.com/gaXwr5bn this
23:53:14 <EvanR> what would look efficient in a profile?
23:53:35 <EvanR> if the program were doing less than 100% ?
23:54:26 <shiona> oops, cut out this:  total alloc = 3,054,908,848 bytes  (excludes profiling overheads)
23:56:57 <EvanR> its true you might be able to get it to go faster by tweaking the way data is constructed
23:57:09 <EvanR> strict fields can help
