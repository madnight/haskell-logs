00:00:32 <liste> > [1, 2, 3] == [1, 2, 3]
00:00:35 <lambdabot>  True
00:00:39 <liste> > [1, 2, 3] == [4, 5, 6]
00:00:41 <lambdabot>  False
00:00:57 <dmwit> clinton_: oh ho ho
00:02:17 <clinton_> dmwit: Hrmm?
00:02:22 <EvanR> > [1..] /= [1..100] ++ [3] ++ [102..]
00:02:24 <lambdabot>  True
00:02:38 <EvanR> > [1..] /= [1..]
00:02:44 <lambdabot>  mueval-core: Time limit exceeded
00:04:09 <EvanR> (/=) :: [Int] -> [Int] -> Either () Void 
00:06:15 <phanimahesh> wut!
00:06:26 <phanimahesh> there's a built in instance!
00:06:39 * phanimahesh facepalms.
00:07:27 <phanimahesh> Now that I think of it, it's obvious there should be one. What was I even thinking. :/
00:07:34 <dmwit> clinton_: Answered on SO.
00:10:36 <dmwit> EvanR: Either Bool Void?
00:10:59 <EvanR> False will never come up
00:11:23 <dmwit> > [1,2,3] /= [1,2,3]
00:11:25 <lambdabot>  False
00:11:42 <EvanR> curse you and your finite lists
00:11:46 <dmwit> =)
00:12:03 * EvanR removes [] from dmwit's initial algebra
00:12:26 <EvanR> carmen sandiego style
00:15:20 <earthy> where in the world is [] ? :)
00:22:49 <nshepperd1> But Either () Void has three elements :(
00:23:07 <nshepperd1> Surely you just want ()
00:23:58 <EvanR> or does it have 4
00:24:16 <Lokathor> I thought Void wasn't an inhabited type?
00:24:23 <EvanR> _|_, Left _|_, Left (), Right _|_
00:24:31 <nshepperd1> Oh, yeah, 4.
00:24:59 <EvanR> i refudiate that, and pretend bottoms dont exist !
00:25:03 <Lokathor> i don't think bottom at the outside counts
00:25:21 <Rotaerk> hmm... it has both a left bottom and a right bottom; probably has to buy two plane tickets
00:25:29 <nshepperd1> You need some kind of unlifted void if you want something truly uninhabited
00:25:34 <Lokathor> Though I'll allow the Left bottom and Right bottom I guess
00:26:46 <nshepperd1> If you're going for a semidecision type, it's the bottom at the outside that counts
00:27:58 <nshepperd1> You can't get Right _, because then the user knows that the predicate is false
00:28:07 <nshepperd1> Because it will never be Left ()
00:29:06 <EvanR> i was going for yes it will be Left () when they are not equal
00:29:14 * dmwit mutters something about jokes and frogs
00:30:06 <Lokathor> saying you have a value when you have a bottom is cheating, at least in the Left bottom case you have a constructor
00:30:47 <EvanR> sierpinski space for haskell is really data Ω = T, or ()
00:31:11 <Lokathor> is () the same as _|_ in that notiation?
00:31:18 <EvanR> no
00:31:28 <EvanR> Ω is just a fancy renaming of ()
00:31:44 <Lokathor> data () = T | () ?
00:31:50 <EvanR> no
00:32:06 <EvanR> its T or _|_
00:32:24 <Lokathor> what about +
00:32:30 <Lokathor> when you move the horizontal bit halfway
00:32:57 <nshepperd1> data S = T
00:33:03 <EvanR> which explains the swiss flag, neutral 
00:33:22 <EvanR> Ω for "type of truth values" from nlab or hott
00:33:42 <nshepperd1> T = "yes they're not equal" _|_ = "keep trying, sucker"
00:34:44 <Lokathor> i don't know who most of these names are
00:34:45 <Lokathor> oh well
00:35:01 <EvanR> haskell is broken though, if you pretend bottom doesnt exist, none of this works
00:35:09 <EvanR> if you have bottom, its not even a category
00:35:47 <Lokathor> i feel like, if i ask, it will turn out that all programming languages are "broken" in that way though
00:35:55 <Lokathor> so i'm not overly worried
00:37:00 <EvanR> simply typed lambda calculus isnt broken!
00:37:05 <nshepperd1> There are total languages. But you can't express semidecidable things in them. So, screw em
00:38:31 <nshepperd1> (caveat lector: i don't understand codata, so maybe that's "wrong")
00:39:41 <EvanR> totality is replaced with productivity
00:40:42 <EvanR> you wouldnt be able to write an omniscience search of an infinite sequence that is total (without some extra hypothesis)
00:41:12 <EvanR> but you could transform one sequence into another improving result
01:01:52 <nshepperd1> Thought: (.) and id seem to obey the necessary category laws when f.g is defined as f `seq` g `seq` (\x -> f (g x ))
01:02:29 <somewone> I have a buffer from which I need to read a CDouble at an arbitary offset. I can advance the Ptr with plusPtr by n bytes but can not figure out how to shift by n bits before peeking the value. Any hints ?
01:02:37 <nshepperd1> Assuming seq is associative and, hm, idempotent
01:03:47 <dmwit> seq surely isn't associative
01:05:11 <dmwit> somewone: I think I probably wouldn't try to do that in Haskell; ship that operation out via the FFI instead.
01:05:33 <nshepperd1> dmwit: what makes you say that?
01:06:00 <nshepperd1> Although maybe we should use pseq instead to be sure of getting the "right" bottoms
01:07:06 <dmwit> nshepperd1: Temporary insanity made me say that.
01:07:15 <nshepperd1> Heh
01:09:35 <somewone> @dmwit I was actually thinking of doing that, I have to cross compile to ARM though, not sure how much of a hassle it will be to make it work with FFI then.
01:09:35 <lambdabot> Unknown command, try @list
01:10:10 <tdammers> no need to use @ on nicks, this isn't twitter
01:11:44 <dmwit> somewone: I suppose another possibility would be to use a Ptr Word64 (or similar) instead.
01:12:40 <dmwit> If you need a bitshift, read two Word64's and use bit operations to get the bits you need. Then unsafeCoerce.
01:12:48 <amx> I cannot make sense of this ghci error: http://lpaste.net/350336
01:12:55 <dmwit> This is... probably mildly dangerous.
01:12:57 <amx> I'm just calling head on a list, twice
01:13:25 <dmwit> amx: ghci has a magic variable named `it` for the result of the previous computation
01:13:41 <amx> thanks, I thought it's something like this but googling was not successful
01:16:02 <nshepperd1> I guess we don't use f `seq` g `seq` (f (g x)) because it's unnecessarily strict
01:16:50 <dmwit> I think it's probably pretty unusual to have a loop at function type.
01:17:34 <nshepperd1> But maybe we can salvage some useful categoryness for real haskell by mapping to the language with strict (.)
01:18:36 <nshepperd1> I imagine it would happen sometimes. Like with infinite dlists or something
01:19:10 <dmwit> Yeah, and I guess there's probably some situations where forcing a function early would require more computation/memory even if it didn't loop.
01:23:31 <EvanR> are yall serious...
01:23:42 <EvanR> you cant make . strict
01:24:05 <EvanR> that would totally mess up the endo builder / diff list trick
01:24:46 <dmwit> Would it?
01:25:34 <EvanR> erm uhm
01:25:38 <nshepperd1> Heh
01:26:09 <EvanR> you already mentioned infinite dlist
01:26:19 <EvanR> maybe thats the only issue
01:26:19 <nshepperd1> I suppose it would, yes
01:27:17 <EvanR> dont ask me how you make use of an infinite diff list
01:27:19 <dmwit> > let x = (0:) . x in x `seq` "is infinite dlist even a problem"
01:27:21 <lambdabot>  "is infinite dlist even a problem"
01:28:11 <dmwit> I think `seq` does less on functions than you're thinking it does.
01:28:24 <EvanR> yes, how did that not freeze
01:28:41 <nshepperd1> Hm
01:29:19 <dmwit> `x` becomes `\y -> (0:) . x` after, like, one evaluation step. And then it's already in WHNF so it's done.
01:29:31 <dmwit> sorry
01:29:42 <dmwit> `x` becomes `\y -> (0:) (x y)`, I mean
01:43:47 <nshepperd1> So, anyway, we don't have to actually make (.) strict to define the thing and say "nyah, Hask is too a category"
01:44:41 <nshepperd1> But then we have to do some legwork to convert facts about terms with strict (.) into facts about the same term with lazy (.)
01:46:43 <bollu> I would like some review on the tutorial that I have been writing: http://bollu.github.io/teleport/
01:46:56 <bollu> it's meant for the "advanced beginner" I suppose
01:47:10 <bollu> ertes, johnw: I polished it up according to what you guys said
01:56:28 <quchen> I’ve got a password in memory that I’d like to be able to overwrite with zeros to purge it after I’ve used it. What’s the easiest way of pinning memory in GHC?
01:58:49 <lyxia> https://hackage.haskell.org/package/primitive-0.6.2.0/docs/Data-Primitive-ByteArray.html#v:newPinnedByteArray
01:58:51 <quchen> Data.Text.Foreign.wighCStringLen probably doesn’t move around much
02:01:43 <quchen> lyxia: Thanks! 
02:04:17 <lyxia> Foreign.Marshall has malloc, I think it's not moved either, but you have to deallocate explicitly.
02:06:44 <lyxia> I found that ByteArray still consumes twice the memory, I'm not sure why exactly but I guess it has to do with the GC algorithm, stop and copy?
02:07:30 <Liskni_si> there's also https://hackage.haskell.org/package/unix-memory which turns "doesn’t move around much" into "doesn’t move around at all, never, I, the kernel, promise"
02:09:12 <Liskni_si> but you'll have to be extremely careful to never ever do anything else than copy that into another mlocked buffer
02:10:30 <Liskni_si> which means not using bytestrings, I'm afraid
02:10:48 <Liskni_si> or blaze-builder or anything like that
02:13:34 <EvanR> and is having it in unix memory secure?
02:13:47 <EvanR> or is that special secure unix memory
02:17:40 <Liskni_si> nothing is secure these days
02:19:52 <bollu> I would some some review on this tutorial that I'm writing / have written: http://bollu.github.io/teleport
02:20:16 <Liskni_si> EvanR: but to answer your question, unix-memory doesn't give you a special secure unix memory, it gives you memoryLock :: Ptr a -> CSize -> IO () and that's it.
02:20:45 <EvanR> now im wonder what you would even do with that
02:21:09 <Liskni_si> with encrypted or no swap at all it's probably entirely useless
02:22:14 <EvanR> when ubuntu pops up a little box, supported by a mile-high tower of gtk/gnome stuff
02:22:21 <EvanR> and asks you to put your password in...
02:22:38 <EvanR> your password is all over the place im sure
02:24:16 <EvanR> i just found options to make it show stars instead of letters... secure
02:26:21 <phanimahesh> i have essentially a matrix as csv. Rows and columns have headers. Both number of rows and columns can vary. How can i parse this?
02:26:36 <phanimahesh> read header -> then for every line convert to a hashmap?
02:26:50 <phanimahesh> or is there a better way?
02:26:59 <quchen> I guess for truly security-critical applications I should just break out to C
02:27:02 <Liskni_si> EvanR: yeah, well, gnome... :-)
02:27:15 <quchen> Luckily enough, I’ve got a toy-ish problem only. (Tooling for myself)
02:27:25 <Liskni_si> but gpg-agent still does it right, with mlocks and shreds, I think
02:27:39 <EvanR> phanimahesh: theres a package called cassava
02:27:43 <EvanR> might work
02:28:04 <phanimahesh> EvanR: I'm looking at cassava. All examples are converting a row to record.
02:28:29 <phanimahesh> But since I have varying columns, and I need to keep things simple, records are out of question
02:28:32 <EvanR> well youd be converting a row to a hashmap i guess
02:29:15 <phanimahesh> yep. That's what I had in mind. Any other ideas? I'll do that if that's the simplest option.
02:30:03 <EvanR> whats the issue here, you want more type safety?
02:32:37 <phanimahesh> I want ease of transformations both row wise and column wise. All values are numeric, so hashmap works for me.
02:36:21 <EvanR> a matrix?
02:37:30 <phanimahesh> Yep. With named columns and rows.
02:38:20 <phanimahesh> Different from the matrix in the sense that ordering doesn't matter, the row/column headers are important, and I don't need any matrix operations.
02:38:34 <EvanR> in that case
02:39:26 <EvanR> a nested hashmap, HashMap RowName (HashMap ColName Number) would be convenient one way
02:39:45 <EvanR> if you needed it to go the other way, you could "transpose" it
02:41:41 <phanimahesh> Sounds good. I'll try that, thanks. Currently I'm trying a vector of records, each with a text header and hashmap of values.
02:42:31 <phanimahesh> Because cassava can be directly used. I'll maybe transform it into nested hashmap at the end.
03:09:31 <benl23> I need a better word than "expliciate" to mean "make something more explicit".. anyone?
03:10:00 <benl23> I need a better word than "expliciate" to mean "make something more explicit".. anyone?
03:10:26 <free_beard> explicitate is definitely better
03:13:48 <ertes> bollu: you can use `overflow: auto` to get rid of the scroll-bars in code blocks unless they're actually needed
03:13:50 <tdammers> how about "make more explicit"
03:13:58 <tdammers> wordier, but also more explicit
03:14:03 <benl23> :-)
03:14:28 <bollu> ertes: ah right
03:14:33 <benl23> implicit -> explicit   ..   implicitize -> expliciate  .. disaster.
03:14:42 <bollu> ertes: content-wise?
03:14:46 <bollu> ertes: does it "read" okay?
03:17:41 <ertes> bollu: this may be a nitpick, but sometimes your text is weird tense-wise: "So, we will write a simple shell script wrapper…"
03:17:56 <ertes> internal response: "huh? it's already written…  i cloned your repo earlier!"
03:18:03 <bollu> ertes: xD
03:18:18 <bollu> ertes: okay, so it should be past tense?
03:18:23 <bollu> "we have written.."?
03:18:54 <ertes> that's up to you…  are you telling a story?  or are you doing something with the reader?
03:18:57 <EvanR> we need new tenses... talking about hypothetically doing something that had already been done
03:21:19 <ertes> bollu: also i renoticed this inconsistency i forgot to mention last time: "This is complicated, since we are not allowed to change the working directory of the shell." – "I see, so how are we going to tackle this complicated problem?" – "[…] we will write a simple shell script wrapper around teleport." – "Oh?  That's…  kinda anti-climactic." =)
03:22:57 <ertes> bollu: is this really a *complicated* problem?  remember that "impossible" doesn't imply "complicated"
03:23:02 <bollu> ertes: oh, right
03:23:10 <bollu> ertes: so, "this is impossible within our tool"
03:23:14 <bollu> ertes: that works?
03:23:35 <ertes> yeah, perhaps together with an explanation *why* it's impossible =)
03:23:40 <ertes> just a short sentence
03:29:38 <bollu> ertes: sure :)
03:30:54 <ertes> bollu: regarding your earlier question:  your text is laid out as an explanation of code that has already been written…  it doesn't feel like i'm writing the code with you, but you're explaining your code to me…  would you agree?
03:32:38 <bollu> ertes: yes, I suppose
03:32:49 <bollu> ertes: but, well, I'm not sure how to "structure" it correctly
03:32:53 <bollu> if you know what I mean
03:33:08 <ertes> bollu: it's not incorrect, *if* that was what you were going for
03:33:21 <bollu> ertes: I was going for "here is how we do things"
03:34:02 <ertes> bollu: that could go in either direction
03:34:09 <ertes> do you want to write a coding tutorial or an explanation?
03:34:43 <ertes> or put differently:  is this a presentation or a workshop?
03:45:47 <bollu> ertes: I don't know tbh :(
03:45:53 <bollu> ertes: which do you think fits my style?
03:45:57 <bollu> ertes: let's say "tutorial"
03:48:46 <ertesx> bollu: i suggest that you don't change the style of the text, because you would basically write a completely new one
03:49:50 <ertesx> bollu: just for the future before writing a new text ask yourself what kind of text it is…  presentation or workshop?
03:50:16 <ertesx> bollu: the one you have written is a presentation =)
03:58:50 <bollu> ertes: OK :)
03:58:58 <bollu> ertes: thanks a ton for the writing tip
03:59:04 <bollu> ertes: I hadn't even considered that as a.. factor
04:38:46 <bollu> ertes: any more comments?
04:39:05 <bollu> ertes: I edited in your comments: http://bollu.github.io/teleport
04:39:31 <bollu> ah, it takes some more time for github pages to reload
04:46:10 <bollu> I would like some help choosing a new language to learn
04:46:21 <bollu> is Agda learnable? in terms of tutorials and such?
04:46:26 <bollu> also, what about logic programming?
04:46:30 <bollu> is prolog still maintained?
04:46:36 <bollu> or are there "newer" logic based languages/
04:48:48 <oish> MiniKanren? http://minikanren.org/
04:49:20 <bollu> oish: neat!
04:50:10 <EvanR> bollu: i learned enough fast enough... along with emacs to do something with it
04:50:22 <bollu> EvanR: with miniKraken or prolog?
04:50:31 <liste> bollu: mercury is a pretty awesome successor to prolog
04:50:37 <bollu> liste: I see
04:50:47 <liste> bollu: https://mercurylang.org/
04:52:02 <bollu> liste: I see, logic programming language with some types shebang is how I'm reading it?
04:52:31 <bollu> "comparing mercury and haskell" :)
04:52:32 <bollu> neat
04:54:38 <EvanR> bollu: agda
04:54:44 <Unhammer> does GHC -O2 always fuse (filter a $ filter b […]), or are there caveats?
04:54:49 <bollu> EvanR: where are the docs? :(
04:54:55 <Unhammer> (assuming GHC 7.8.4 and up)
04:54:56 <EvanR> i dont think there are any
04:54:57 <bollu> EvanR: I am learning coq through software foundations
04:55:01 <bollu> EvanR: exactly :P
04:55:03 <EvanR> lol
04:55:12 <EvanR> a channel exists
04:55:23 <bollu> it's not very alive, unfortnately
04:55:25 <EvanR> theres one table of key combos on the wiki, incomplete
04:55:37 <bollu> EvanR: my current plan is to learn coq properly, and then perhaps move to idris
04:55:40 <EvanR> i found out 1 particular thing from the lisp code
04:55:53 <EvanR> agda is really sweet though ;)
04:56:02 <bollu> :)
04:56:19 <EvanR> and idris isnt for proving
04:56:33 <bollu> EvanR: oh? but you can use a dependantly typed language as a proof system, correct?
04:56:38 <EvanR> just now i was confronted with the fact that idris proves the negation of LEM
04:56:42 <bollu> "if the type is inhabited, the proposition is true"
04:56:44 <bollu> what? :O
04:56:55 <EvanR> we already knew it disproves univalence ;)
04:56:59 <bollu> EvanR: I gotta go now, but that sounds interesting
04:57:07 <bollu> EvanR: let me ping you about this once I'm back
05:40:07 <yhhko> i have to record data types A and B. A and B have identical fields, except that in B, some fields are optional. what library would I use to most conveniently translate A into B?
05:40:26 <yhhko> two* record data types
05:42:02 <yhhko> (where optional means Maybe, and translate means insert those values with Just)
05:42:10 <kuribas> yhhko: just write "AtoB :: A -> B" ?
05:42:49 <kuribas> no need for a library
05:42:55 <yhhko> yeah i could do that, except i actually have this at several levels
05:43:09 <yhhko> so i'd have to write A1 -> B1 and A2 -> B2 and A3->B3
05:43:20 <Profpatsch> Yay, wai-middleware-static completely broke.
05:43:28 <yhhko> and now i have about two pages of code that only inserts Just in some places
05:43:40 <Hijiri> maybe lens has something for this?
05:43:53 <Hijiri> Prisms maybe?
05:43:55 <yhhko> i was thinking about that but i never used lenses before, so i'm not quite sure what to search for
05:43:55 <Profpatsch> I stared at my code for an hour, wondering why my routes where all broken.
05:44:24 <Profpatsch> Until I opened ghci and noticed basically no combinator functions anymore.
05:44:27 <ertes> bollu: no more comments so far =)
05:44:34 <Profpatsch> yay for no tests!
05:44:38 <yhhko> Hijiri: so i would use some kind of a Maybe prism, and write a lens for my A and B? and then how to map over all those values?
05:44:56 <ertes> bollu: i'm actually trying to find an alternative to haskell for productive reasons (as a replacement for shell scripts), but unsuccessful so far
05:45:26 <ertes> scheme was the most promising one so far
05:45:47 <ertes> but i find it really difficult to prototype without types
05:45:52 <quchen_> Is it safe to delete the latest Stackage snapshot builds from ~/.stack/snapshots?
05:46:09 <quchen_> Or could it be that 7.10 uses packages installed for 7.12?
05:46:29 <quchen_> In other words, does stack install package snapshots as stacks or as random access structures?
05:46:55 <kuribas> yhhko: or data A a = A {field1 :: Int, optionalField :: a Int, ...}
05:47:35 <kuribas> yhhko: then "newtype B = A Maybe"
05:48:06 <Profpatsch> WTF
05:48:14 <yhhko> kuribas: hm, and then how'd I write the converter?
05:48:17 <Profpatsch> I opened ghci again and suddenly it works?!
05:48:25 <yhhko> kuribas: (not a bad idea to do it that way though)
05:48:45 <yhhko> i suppose i could use some kind of Identity lens then
05:48:49 <kuribas> yhhko: fmap (Just . runIdentity)
05:48:51 <quchen_> Profpatsch: So you have tried turning it off and on again?
05:49:00 <kuribas> :t fmap (Just . runIdentity)
05:49:01 <lambdabot> Functor f => f (Identity a) -> f (Maybe a)
05:49:17 <yhhko> kuribas: ah but i have several optional fields. would fmap understand that?
05:49:32 <kuribas> hm, I guess no...
05:50:57 <kuribas> :t fmap ((Just . runIdentity) :: (forall x. Identity x -> Maybe x))
05:50:59 <lambdabot> Functor f => f (Identity x) -> f (Maybe x)
05:51:46 <yhhko> kuribas: i'd expect the Functor deriving instance to pick out a field, though... let's look this up
05:53:16 <yhhko> i don't think it quite fits in this use case: because we have "a :: * -> *" rather than "a :: *"
05:54:07 <Profpatsch> quchen_: Yes, apparently </> just ignores the first argument when the second starts with /
05:54:40 <Profpatsch> And middleware-static uses </> for addBase
05:54:52 <lyxia> yhhko: you'd get a functor with { optionalField :: a, ... }
05:55:40 <delYsid> I am apparently not smart enough for Haskell.
05:56:26 <Profpatsch> delYsid: If you say so.
05:56:36 <yhhko> i suppose i know how to rephrase this more categorically. I have a natural transformation from F to G. now i have a data type data C f = {...}, where f::*->*. can i then obtain a map C F -> C G?
05:56:49 <yhhko> and i suppose the answer is "not in general" as f might be used contravariantly
05:58:13 <Social-Reject> hey
05:58:15 <erisco> why can I not figure out how to implement drop with a fold
05:58:16 <erisco> is it not a fold?
05:58:23 <delYsid> Profpatsch: I love it, but translating procedural algorithms into it is not easy for me.
05:58:23 <Social-Reject> what does | mean in haskell
05:58:37 <Profpatsch> Social-Reject: Search for Pattern Guard
05:58:48 <quchen_> Social-Reject: Depends on the context, could you paste some example code?
05:58:57 <Profpatsch> There’s more uses of |?
05:59:05 <quchen_> data Foo = A | B
05:59:07 <quchen_> Guards
05:59:09 <delYsid> Social-Reject: Depends on the context.  In function definitions, it is a guard.  In class definition, functional dependency.
05:59:10 <Profpatsch> Ah, right.
05:59:10 <quchen_> Pattern Guards
05:59:13 <quchen_> (||)
05:59:18 <Social-Reject> [x*2 | x <- [1..10]] . I dont know what does | and <- means
05:59:23 <quchen_> Anonymous sums in the next release
05:59:25 <Social-Reject> what is guard
05:59:28 <Profpatsch> lol, that’s the last way | is used.
05:59:30 <quchen_> Ahaa! It’s list comprehensions. :-)
05:59:33 <lyxia> yhhko: the DeriveFunctor extension also has to make that restriction FWIW
06:00:23 <yhhko> lyxia: oh cool, thanks for clearing that up :)
06:00:28 <Social-Reject> what is guard plox :D
06:01:09 <delYsid> OK, I read the haskell wiki page about dynamic programming, and the nice article linked from that.  But I still have no idea how to translate my C++ impl. of breaking paragraphs into lines into Haskell.  Anyone experienced with that algo?
06:01:30 <kuribas> delYsid: you can use lazyness
06:02:13 <delYsid> kuribas: I already got that notion from reading about dyn. prog in haskell.
06:02:35 <delYsid> I guess my problem is, that I dont fully get the procedural impl. in the first place.
06:02:56 <quchen_> Social-Reject: Guards are unrelated to your question. :-)
06:03:04 <Social-Reject> :-))
06:03:11 <quchen_> Social-Reject: FWIW, guards are this: http://learnyouahaskell.com/syntax-in-functions#guards-guards
06:03:13 <lyxia> erisco: probably not "drop n = foldr f [] where f = ...", but something like "drop n = g . foldr f x where (g, f, x) = ..." should be possible.
06:03:32 <quchen_> quchen_: They’re a form of »multi-if« in Haskell.
06:03:59 <EvanR> talking to yourself is a sign of insanity
06:04:02 <kuribas> delYsid: I believe you calculate the "badness" for breaking after each word, then take the minimum value.
06:04:08 <quchen_> Social-Reject: The »|« you’re asking about are in the context of list comprehensions, http://learnyouahaskell.com/starting-out#im-a-list-comprehension
06:04:18 <erisco> lyxia, I don't know, I am quite stumped on it
06:04:31 <kuribas> delYsid: I did it before, but it's been a while ago...
06:04:37 <quchen_> > [ "The number " ++ show n | n <- [1..5] ] -- Social-Reject 
06:04:40 <lambdabot>  ["The number 1","The number 2","The number 3","The number 4","The number 5"]
06:05:09 <Social-Reject> I dont understand :()
06:05:11 <erisco> preprocess the list, postprocess the list, do whatever, but you can only use folds, not pattern matching
06:05:11 <Social-Reject> :<
06:05:33 <Social-Reject> how would look that in javascript? :D
06:05:45 <quchen_> Social-Reject: The »|« there roughly means »where«. So my example above is »The number n where (|) is drawn from (<-) the list of 1 to 5 (1..5)
06:06:00 <erisco> I can think of a way to do it that does not retain laziness, which isn't good enough
06:06:08 <Social-Reject> so (|) mean where and (<-) means from?
06:06:17 <delYsid> kuribas: Yes, that sounds like it.
06:06:44 <erisco> :t drop
06:06:46 <lambdabot> Int -> [a] -> [a]
06:06:53 <Social-Reject> :R
06:06:54 <Social-Reject> :R
06:06:55 <Social-Reject> :r
06:06:56 <erisco> note that it isn't defined on Foldable, so someone else found a problem too, or didn't try
06:07:22 <quchen_> Social-Reject: You can read them that way, yes.
06:07:33 <Profpatsch> delYsid: What do you want with dynamic programming?
06:07:35 <quchen_> Social-Reject: For example, we can use a list comprehension to square all elements in a list.
06:07:48 <quchen_> > [ x^2 | x <- [1..10] ]
06:07:51 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
06:07:57 <Profpatsch> delYsid: It’s probably a simple recursive function.
06:07:57 <quchen_> x-square, where x is drawn from 1..10
06:08:33 <Social-Reject> hmm, im close to udnerstand it :D
06:09:15 <quchen_> In math, you would write { x² | x ∈ [1,10] }
06:09:26 <quchen_> It’s fairly close to basic set notation, if that helps.
06:09:32 <erisco> this is one of those problems that only a hot shower can solve
06:09:36 <quchen_> If you’re unfamiliar with it, it does not help at all, and you should not worry about it. :-)
06:10:24 <Social-Reject> :D
06:11:06 <Social-Reject> can you come here quchen_ https://kobra.io/#/e/-KZarCNNMQuH35XyNfpC
06:11:57 <kuribas> delYsid: the badness of a break is equal to the badness of the line and the badness of the previous break.
06:12:26 <lyxia> erisco: what's your way to do it
06:12:54 <kuribas> delYsid: so at each break you search for the minimum.
06:13:15 <erisco> lyxia, on second thought it doesn't work because it depends on zip which has a similar problem
06:13:21 <kuribas> delYsid: then the final break gives optimal breaks.
06:13:22 <erisco> I was thinking zip with indices, filter, project
06:13:33 <erisco> zip is also not definable
06:14:05 <kuribas> delYsid: when badness goes above a threshold, you stop searching.
06:14:24 <kuribas> delYsid: otherwise the algorithm is O(n^2)
06:15:17 <erisco> that solution uses filter which isn't lazy enough
06:17:01 <lyxia> > let drop = flip $ foldr (\x dropxs n -> if n == 0 then (x : dropxs 0) else dropxs (n - 1)) (\_ -> []) in drop 2 ([0..5] ++ undefined)
06:17:03 <lambdabot>  [2,3,4,5*Exception: Prelude.undefined
06:17:40 <erisco> filter is definable on Foldable but likely not because sending a Foldable to [] is perhaps not attractive enough
06:18:06 <erisco> other than toList particularly
06:18:41 <_sras_> How can I find the version of the package that stack has choose to install?
06:20:11 <lyxia> stack list-dependencies
06:20:22 <erisco> lyxia, nice try though
06:21:14 <lyxia> it is lazy
06:22:39 <halogenandtoast> if I have a data constructor `data Obstacle = Obstacle ObstacleType Coord` and I have a list of types and a list of coords can I easily create an array of these. I was thinking I could do `Obstacle <$> types <$> coords` but that isn't true
06:22:45 <erisco> lyxia, you're right
06:23:10 <halogenandtoast> by array I mean List
06:24:46 <kuribas> delYsid: to get started: http://lpaste.net/350344
06:25:01 <lyxia> > let obstacle = (,) in obstacle <$> ["wall", "tree"] <*> ["here", "there"]
06:25:03 <lambdabot>  [("wall","here"),("wall","there"),("tree","here"),("tree","there")]
06:25:19 <lyxia> > let obstacle = (,) in zipWith obstacle ["wall", "tree"] ["here", "there"] -- halogenandtoast 
06:25:22 <lambdabot>  [("wall","here"),("tree","there")]
06:26:50 <halogenandtoast> lyxia: so zipWith?
06:29:02 <erisco> lyxia, I don't know why I didn't see this
06:29:04 <lyxia> halogenandtoast: zipWith pairs each type with one coordinate, whereas (<*>) ("ap") pairs each type with every coordinate.
06:31:44 <delYsid> Profpatsch: I want to implement a simplified version of "breaking paragraphs into lines", one that doesn't care about stretchness and such, a version for fixed-font-size so-to-speak.  I have my own C++ version of that thing already, but I totally fail to translate it to Haskell.
06:33:02 <halogenandtoast> lyxia: thanks I'll try it out
06:33:45 <delYsid> I basically want to translate this code: https://github.com/mlang/bmc/blob/master/lib/linebreaking.cpp
06:34:58 <delYsid> but I guess a literal translation is going to look rather horrible in Haskell.  I gather Lazyness can help with dyn. prog algos, but I sort of fail to see how it helps here.
06:36:21 <delYsid> kuribas: Thanks.  I sort of know most of what you told me, but I am unable to put that in code.
06:36:55 <lpaste> kuribas annotated “No title” with “breaking paragraphs” at http://lpaste.net/350344#a350345
06:37:05 <erisco> lyxia, it is lazy though it does keep the overhead over the whole list
06:37:15 <erisco> something still a bit off about that
06:40:11 <lpaste> kuribas revised “breaking paragraphs”: “breaking paragraphs” at http://lpaste.net/350345
06:40:45 <EvanR> erisco: such is the life of foldl
06:41:16 <EvanR> for a different account, try foldr
06:42:43 <lyxia> erisco: are you referring to the fact that the result is reconstructed from scratch, rather than just taking a tail of the original list?
06:42:43 <kuribas> delYsid: that should work
06:42:56 <kuribas> delYsid: then fill in bestBreak
06:43:22 <erisco> lyxia, yes
06:43:36 <erisco> EvanR, well this is using foldr
06:43:44 <delYsid> hmm.  I appreciate the effort, but I dont get it at all.  Need to read up on scnal first.
06:43:57 <kuribas> delYsid: of course TeX also takes into account previous lines.
06:43:57 <lyxia> yeah I'm not sure what to do about that either
06:44:12 <EvanR> erisco: in that case, sounds wrong
06:44:13 <delYsid> kuribas: Which is what I need as well.
06:44:59 <delYsid> What I want, is the optimal linebreak placement, for the whole paragraph.  So some sort of backtracking, contrary to all the PP libs I know.
06:45:09 <kuribas> delYsid: you can put extra parameters into BreakBadness
06:45:09 <erisco> it almost seems like a clever solution, i.e. exploiting drop specifically
06:45:31 <erisco> that drop 0 is the identity
06:45:38 <onintza> I'm searching for some "f delete [a] :: [a] -> [a]" that will crush together a bunch of deletes for different arguments
06:45:48 <kuribas> delYsid: it doesn't backtrack.
06:45:51 <erisco> can we implement take? take 0 is not the identity
06:45:53 <delYsid> And things like penalize consecutive hypens and such.
06:45:54 <onintza> I'm a bit confused about the type it should have
06:47:14 <erisco> yes, seems straight-forward to implement take
06:47:32 <kuribas> delYsid: try to implement breaking ascii lines into 80 columns, with a simple penalty calculation, then you can work from there.
06:47:39 <erisco> \x a n -> if n == 0 then [] else x : a (n - 1)
06:47:49 <kuribas> delYsid: the base of the algorithm will be the same.
06:49:06 <delYsid> kuribas: thanks for the starter. Lets see if I can actually understand your approach.
06:49:21 <kuribas> delYsid: the bestBreak function is straight-forward.  It takes the current word, and all the previous breaks/badnesses.
06:49:27 <kuribas> in reverse
06:49:27 <erisco> \x a n -> if n == 0 then x else a (n - 1)   is !!
06:49:35 <lyxia> erisco: you can have the accumulator be ([a], Int -> [a]) instead, that might be more straightforward.
06:49:43 <erisco> with this, you could implement a quadratic zip
06:49:58 <kuribas> delYsid: you can encode wathever extra information you want into BreakBadness
06:50:08 <kuribas> delYsid: like looseness etc...
06:51:15 <kuribas> delYsid: "scanl (flip (:)) []" is the same as "map reverse . inits" but more efficient.
06:51:37 <kuribas> > scanl (flip (:)) [] [1..10]
06:51:39 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
06:51:45 * delYsid feels stupid
06:51:59 <delYsid> kuribas: BreadBadness you mean? :-)
06:52:14 <kuribas> typo ;-)
06:52:34 <delYsid> obviously :-)
06:52:50 <erisco> BreadingBad
06:53:31 <erisco> is there a better zip? hm
06:53:58 <erisco> lyxia, what does that change?
06:54:11 <erisco> not sure how to use that accumulator
06:54:45 <kuribas> delYsid: makes sense?
06:54:51 <lyxia> erisco: the first component just rebuilds the tail of the list, it would change that when n = 0 you don't need to be smart about drop 0 being id, you just put the tail which is now available.
06:54:53 <erisco> I think you need to upgrade to traverse to make the proper drop
06:55:13 <erisco> lyxia, oh
06:56:24 <erisco> maybe foldMap works
06:57:00 <erisco> no that can't be right =\
06:57:11 <v0d1ch> so do you have to have haskell platform installed on server in order to run haskell binary?
06:57:16 <kuribas> delYsid: bestBreak just needs to look at the previous breaks, which is what the "scanl ..." does.
06:57:29 <codedmart> How do I check multiple possible keys in an aeson FromJSON instance? I initially tried something like this https://gist.github.com/codedmart/dc3939e220b0ea2ed450d59c6d0dfbce#file-main-hs-L14-L22
06:59:22 <erisco> imagine something like  Monoid m => (b -> a -> m b) -> b -> f a -> m b
07:00:10 <kuribas> > let l = zipWith (\e p -> sum (take 2 p) + e) [1..10] $ scanl (flip (:)) [] l in l -- delYsid
07:00:12 <lambdabot>  [1,3,7,14,26,46,79,133,221,364]
07:00:53 <erisco> probably  (m b -> a -> m b) -> m b -> f a -> m b  rather, otherwise it doesn't make much sense
07:00:59 <erisco> but this just specialises foldl
07:01:22 <kuribas> > f 1 2
07:01:24 <lambdabot>  error:
07:01:25 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M298036925927...
07:01:25 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:01:31 <kuribas> > f 1
07:01:34 <lambdabot>  error:
07:01:34 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M797898780944...
07:01:34 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:01:44 <erisco> I am just trying to think what would allow shorting
07:02:04 <erisco> <> or <|> comes to mind
07:02:27 <erisco> Maybe, Either, that stuff
07:03:52 <kuribas> > let l = zipWith (\e p -> sum p + e) [a, b, c, d, e] $ scanl (flip (:)) [] l in l -- delYsid
07:03:55 <lambdabot>  [0 + a,0 + (0 + a) + b,0 + (0 + (0 + a) + b) + (0 + a) + c,0 + (0 + (0 + (0 ...
07:04:20 <erisco> I don't know, I am flummoxed right now
07:04:49 <onintza> Should "do {x <- f; y <- g x; return y} :: a -> a" not be equal to "g . f"?
07:05:34 <lesshaste> hi all
07:05:37 <Clint> onintza: it should not
07:05:53 <shlevy> Is there a good existing facility for a concurrent source of unique IDs of some bounded type (in my case, Word64) where an ID can be added back to the pool?
07:05:56 <onintza> Clint: what would the monadic equivalent of composition be?
07:06:07 <lyxia> :t do {x <- f; y <- g x; return y} `asAppliedTo` undefined
07:06:09 <lambdabot> error:
07:06:09 <lambdabot>     • Could not deduce (FromExpr t0) arising from a use of ‘f’
07:06:09 <lambdabot>       from the context: (FromExpr b, Show a)
07:06:13 <EvanR> adding IDs back to a pool o_O
07:06:22 <lyxia> :t \f g -> do {x <- f; y <- g x; return y} `asAppliedTo` undefined
07:06:24 <lambdabot> (a -> t) -> (t -> a -> b) -> a -> b
07:06:25 <shlevy> Currently thinking of just a shared list from 0 to maxBound, and put the id on the front when done
07:06:31 <EvanR> that sounds provably insane
07:06:34 <lyxia> :t \f g -> g . f
07:06:37 <lambdabot> (a -> b) -> (b -> c) -> a -> c
07:06:38 <Clint> @undo do {x <- f; y <- g x; return y}
07:06:38 <lambdabot> f >>= \ x -> g x >>= \ y -> return y
07:06:40 <shlevy> EvanR: Why?
07:06:56 <shlevy> EvanR: I mean, it's a Word64 so realistically I should never actually have to
07:07:01 <EvanR> indeed
07:07:09 <v0d1ch> \help
07:07:13 <v0d1ch> oops :)
07:07:23 <shlevy> EvanR: But what's the problem with it?
07:07:24 <EvanR> have you ever debugged something where the IDs were all messed up?
07:07:46 <EvanR> another manifestation is when pointers are used after the object is deallocated, or the pointer becomes invalid somehow
07:07:49 <shlevy> EvanR: It's pretty simple semantics, it's just assigning an ID to a request/response pair, so you know exactly when the ID has expired
07:08:19 <lyxia> onintza: g x is a function which is going to be applied to the same argument as f in your expression. Function composition doesn't do that.
07:08:22 <Profpatsch> quchen_: Hear, hear, you will be at Curry Club?
07:08:24 <Profpatsch> Nice!
07:08:24 <EvanR> also you can ensure that you dont run out with Integer
07:08:47 <Profpatsch> Will you be at Congress as well?
07:08:48 <shlevy> EvanR: I'm talking with a daemon I don't control
07:08:51 <EvanR> shlevy: Integer is implemented as a Word for small numbers, i.e. until it doesnt fit
07:09:03 <EvanR> and both are boxed
07:09:12 <EvanR> so what do we gain
07:09:16 <quchen_> Profpatsch: Congress? Haven’t heard of that, so probably not. But Yes, Max recruited me for the Curry Club.
07:09:21 <lesshaste> would any speed gurus be interested in making a faster answer to http://codegolf.stackexchange.com/questions/97060/calculate-the-permanent-as-quickly-as-possible ?
07:09:27 <shlevy> EvanR: We gain proper semantics for the existing protocol :)
07:09:27 <Profpatsch> quchen_: https://events.ccc.de/congress/2016/wiki/Assembly:Haskell
07:09:30 <quchen_> Oh, the C3
07:09:36 <quchen_> Nope :-/
07:09:39 <Profpatsch> oh :(
07:09:44 <lpaste> xcmw pasted “Why does this error (MegaParsec)?” at http://lpaste.net/350347
07:09:44 <EvanR> shlevy: which is?
07:09:47 <Profpatsch> Didn’t get a ticket?
07:09:48 <lesshaste> it would be interested if the speed of Dennis's C answer can be matched
07:10:00 <shlevy> EvanR: A uint64_t
07:10:03 <lesshaste> (the answer by Ton Hospel is hardly in C so can be safely ignored)
07:10:10 <lesshaste> interesting
07:10:34 <EvanR> well if that demon is deciding what the IDs are, then that settles it
07:10:36 <quchen_> Profpatsch: Nope, it’s held at a very unfortunate time usually ;-)
07:10:47 <lyxia> codedmart: what result are you expecting
07:10:53 <vozz> I seem to write a lot of code with nested case expressions like so: http://lpaste.net/1910757158157287424 How would I neaten it up? 
07:11:36 <Clint> vozz: Maybe monad
07:11:42 <Profpatsch> quchen_: For many people that time is very fortunate. ;)
07:12:07 <fosskers> vozz, Are you using the `aeson` library?
07:12:18 <vozz> No, it's not actually json
07:12:45 <codedmart> lyxia: So I can get json like this `{"has_more": true, "addresses": [...]}`, or `{"has_more": true, "parcels": [...]}`, or `{"has_more": true, "shipments": [...]}` and so on. I just turn that into https://gist.github.com/codedmart/dc3939e220b0ea2ed450d59c6d0dfbce#file-main-hs-L1-L4.
07:12:50 <fosskers> You could probably get far with `do` notation here, taking advantage of the fact that Maybe is a monad
07:12:56 <vozz> it's some weird format someone rolled themselves, it looked a bit like json with different delimiters so I started with a parsec json parser, then heavily modified it
07:13:19 <codedmart> lyxia: so `has_more` is consistent but then there is a list of possible values the other key could be.
07:13:21 <vozz> How would I fit the pattern matching into the monad?
07:14:31 <EvanR> vozz: maybe you could employ "views" which return a data structure that you can pattern match
07:14:45 <lpaste> lyxia annotated “No title” with “to vozz” at http://lpaste.net/1910757158157287424#a350348
07:14:46 <vozz> ah I'm dumb, neermind
07:15:03 <EvanR> though in this case parsec combinators are probably fine
07:15:07 <vozz> wow that's a lot nicer
07:15:26 <lyxia> views are a good idea here too
07:15:31 <lyxia> EvanR++
07:15:41 <vozz> what are views?
07:17:53 <lesshaste> I ask again later :)
07:18:09 <lpaste> kuribas annotated “No title” with “breaking paragraphs - non lazy” at http://lpaste.net/350344#a350349
07:18:46 <kuribas> delYsid: you don't even need lazyness ^^^
07:19:13 <lpaste> lyxia annotated “No title” with “to vozz (view patterns)” at http://lpaste.net/1910757158157287424#a350350
07:19:16 <EvanR> vozz: if you define a datatype specifically to reveal particular information about something, in a way that youd obvious want to case split on. its really nice in cases where youre trying to analyze an abstract data type that doesnt expose constructors
07:19:33 <codedmart> lyxia: Does that make sense? Any pointers?
07:20:27 <Tuplanolla> Check out Repa and its optimization guide, lesshaste.
07:20:48 <Tuplanolla> While Repa itself may not admit a faster solution, some of the compiler flags might help.
07:21:35 <lyxia> codedmart: I think it makes sense. What do you need help with
07:22:31 <lpaste> lyxia annotated “No title” with “to vozz (annotation)” at http://lpaste.net/1910757158157287424#a350351
07:23:26 <codedmart> lyxia: Not sure how to check a list of possible keys before failing ie `EPList <$> o .: "has_more" <*> o .: ["addresses", "parcels", "shipments", ...]`.
07:24:16 <lyxia> codedmart: The code you pasted seemed to make sense
07:24:23 <lyxia> codedmart: did it not work
07:24:43 <vozz> that's pretty rad
07:24:54 <jophish> mpickering: I'm excited to try out CompleteSigs, thanks for that work!
07:25:01 <vozz> thanks a lot, that's incredibly helpful
07:25:08 <lesshaste> Tuplanolla,  thanks.. I think the code needs to be written differently
07:25:20 <lesshaste> Tuplanolla, one idea is do it with mutable arrays, then you will see how good ghc's strictness analyser for the int variables is
07:25:24 <lyxia> vozz: the view pattern thing is neat but not very common
07:25:39 <lesshaste> Tuplanolla, or  write pretty much the same code as the (non-vectorised) c in haskell, and the llvm backend ought to give you basically the same performance
07:25:41 <EvanR> view patterns extension, not very common
07:25:48 <codedmart> lyxia: Yes I get this error: https://gist.github.com/codedmart/dc3939e220b0ea2ed450d59c6d0dfbce#file-error
07:25:51 <lesshaste> Tuplanolla,  but I am not the right person to do this probably being a relative newbie
07:25:56 <EvanR> but just using a view type doesnt require an extension and is sane
07:26:01 <lesshaste> it was just in case anyone likes this sort of thing
07:26:41 <Tuplanolla> I'd try it with more time, lesshaste.
07:26:47 <lesshaste> Tuplanolla,  cool!
07:26:57 <Social-Reject> is there in haskell something like console.log in javascript
07:27:11 <vozz> In that last one, the annotation one, you're matching on the list being length 2, what happens if it's not? Does the maybe monad handle that, or does it get pattern matched as parseHand _ = Nothing ?
07:27:13 <Tuplanolla> Yeah, `Debug.Trace.trace`, Social-Reject.
07:27:24 <Social-Reject> k.. :D
07:29:41 <erisco> foldr is always going to rebuild the list, isn't it, hrm
07:29:53 <erisco> maybe best to just stop at Scott lists then
07:29:58 <lyxia> codedmart: .:? actually succeeds (returning Nothing) if the key is not present
07:30:23 <erisco> then zip is efficient too
07:30:38 <lyxia> codedmart: .: would work.
07:31:21 <Gurkenglas> Why not "JsonTup _ [_, JsonTup _ [JsonStr s1, JsonStr s2]]" in line 4 of the last annotation?
07:31:31 <lyxia> codedmart: the error is not very helpful. But it comes from the fact that (<*>) expects a parser as its second argument at line 10
07:32:21 <xcmw> How can I get Megaparsec to backtrace? I tried adding trys but that did not help. http://lpaste.net/350347
07:32:23 <lyxia> Gurkenglas: hmm... that's better indeed.
07:32:42 <codedmart> lyxia: Ah ok. Yeah I see now. Thanks!
07:33:09 <vozz> Gurkenglas: neat!
07:33:20 <lyxia> codedmart: EPList <$> o .: "has_more" <*> (o .: "addresses" <|> ...)
07:35:07 <Social-Reject> how does one deal with 1000 icons on desktop
07:35:21 <Social-Reject> ups wrong channel :p
07:36:02 <yulax> Social-Reject: here's an idea - implement a program that takes your icons on desktop, then makes them into a pretty picture
07:36:19 <Social-Reject> of cats? ;p
07:36:28 <Gurkenglas> Social-Reject, keep making them smaller so you can fit more
07:36:51 <Tuplanolla> No, no. You take a screenshot of the desktop, delete the icons and set the screenshot as the background image, Social-Reject.
07:37:22 <lyxia> Don't have icons.
07:37:25 <Social-Reject> there are files from 2010 lol
07:37:25 <erisco> you buy a second and third monitor, duh
07:37:32 <Social-Reject> thats good second monitor kek
07:37:48 <quchen_> Virtual monitors are cheaper
07:38:01 <quchen_> I have hundreds of them to organize my desktop
07:38:25 <erisco> but their warranty is tied to your real monitor, not as reliable
07:38:28 <sm> xcmw: surprising. What version of megaparsec ?
07:38:52 <quchen_> erisco: »Real monitor«? I use an audio frontend for my XServer
07:39:07 <sm> you tried "h = (try (string "s") <|> string "sec") <* char ' '" ?
07:40:07 <quchen_> No need to »try« there
07:40:20 <byorgey> xcmw: that is the error I would expect.  It sucessfully consumes the 's' and then expects to see the space.  If you add 'try' around (string "s") that should make it backtrack
07:40:33 <quchen_> Oh, if you have the space afterwards I think you need it.
07:41:05 <quchen_> Although then you could refactor it to use »optional (string "ec")«, not needing the »try« anymore again. :-)
07:41:46 <sm> also, I read that string backtracks automatically since 4.4.0
07:42:10 <vozz> What happens here if the list has some other type of JSON in it other than a JsonStr? http://lpaste.net/2700788775616774144
07:43:14 <lyxia> it crashes when you try to get it
07:44:02 <lyxia> > map (\(Just a) -> a) [Nothing]
07:44:05 <lambdabot>  [*Exception: <interactive>:3:6-19: Non-exhaustive patterns in lambda
07:44:14 <vozz> How would I get the maybe monad to return nothing instead?
07:44:17 <Lvcrft> Hello
07:45:56 <EvanR> > [a | Just a <- [Nothing]]
07:45:59 <lambdabot>  []
07:46:06 <lyxia> vozz: mapM (\v -> case v of JsonStr s -> Just s ; _ -> Nothing) arr
07:46:20 <vozz> thanks!
07:46:30 <Lvcrft> Does anyone know how to solve the realgcc problem on Windows?
07:46:54 <Lvcrft> I'm trying to set Haskell up but it keeps popping up whenever I try to open WinGHCi
07:47:44 <c_wraith> Lvcrft: I've honestly never heard of anyone getting winghci working well.  Though that may be that I only hear from people who are complaining. :)
07:48:05 <Lvcrft> Is there any other alternate compiler I might use then?
07:48:07 <mpickering> jophish: I'm hoping to have finished it soon but the design is causing some problems
07:48:26 <c_wraith> Lvcrft: ghc is the de-facto standard haskell compiler these days
07:48:57 <Lvcrft> I get the same error when trying to open GHCi
07:49:19 <lpaste> xcmw revised “Why does this error (MegaParsec)?”: “Why does this error (MegaParsec)?” at http://lpaste.net/350347
07:49:22 <lpaste> Gurkenglas annotated “No title” with “Could even pull the (Just "CHANGE") into an additional "CHANGE" <- but meh -- vozz” at http://lpaste.net/2700788775616774144#a350357
07:49:26 <c_wraith> how did you install ghc?
07:49:37 <Lvcrft> I used the Haskell Platform
07:49:52 <xcmw> byorgey: It still errors
07:49:54 <Lvcrft> It - theoretically - installed perfectly
07:50:13 <xcmw> byorgey: Did I put the try in the right place?
07:50:37 <c_wraith> Hmm.  What version of the platform?
07:50:44 <vozz> Ah that forM is nice!
07:50:47 <Lvcrft> 8.0.1
07:51:08 <c_wraith> But which version of the *platform*?  It has minimal and more-full versions
07:51:08 <Lvcrft> I tried both 32 and 64 bits version and both give the same error
07:51:14 <Lvcrft> ah, minimal
07:51:16 <Lvcrft> My Bad
07:51:38 <c_wraith> Hmm.  It still should install msys properly.
07:51:46 <jophish> mpickering: just reading through the changes now, would it make sense to have a warning about 'orphan' COMPLETE pragmas?
07:52:10 <vozz> In the maybe monad, if the pattern doesn't match, is it nonexhaustive matching and it errors, or does it just return Nothing?
07:52:15 <c_wraith> Lvcrft: can you paste the output from trying to run ghci at lpaste.net ?
07:52:31 <mpickering> jophish: I was thinking of not allowing orphan pragmas all together
07:52:36 <ksj> Lvcrft: you could try installing it with stack
07:52:39 <jophish> mpickering: that's even better
07:52:41 <mpickering> Less powerful and can be relaxed if someone really wants it
07:52:48 <c_wraith> > do Just x <- Nothing ; return () -- vozz 
07:52:50 <lambdabot>  Nothing
07:53:08 <lpaste> kuribas annotated “No title” with “even better with foldl' ” at http://lpaste.net/350344#a350358
07:53:17 <vozz> c_wraith: ooh that's cool
07:53:22 <mpickering> I've been spending too much time trying to setup a build environment for GHC in nixos though
07:53:33 <mpickering> and not been succeeding..
07:53:36 <jophish> c_wraith: that's not quite right, that's just failing with Nothing
07:53:43 <kuribas> delYsid: I am being stupid, even a simple fold will work! ^^^
07:53:48 <jophish> > do 1 <- Just 2; pure ()
07:53:51 <lambdabot>  Nothing
07:54:09 <ongy> :t do 1<- Just; pure ()
07:54:10 <lambdabot> (Num (Maybe a), Eq a) => a -> ()
07:54:31 <lpaste> kuribas revised “even better with foldl' ”: “even better with foldl' ” at http://lpaste.net/350358
07:54:32 <c_wraith> jophish: The question was what happens if a pattern doesn't match.  *shrug*
07:55:37 <Lvcrft> c_wraith: http://lpaste.net/4071971090753126400
07:55:41 <vozz> http://lpaste.net/1227297036659851264 :) So these new ones shouldn't error at runtime?
07:55:47 <jophish> yeah, I guess we interpreted the question differently :) I probably shouldn't have said it's "not right" :)
07:55:49 <kuribas> @pl \f acc e -> f e acc:acc
07:55:49 <lambdabot> join . ((flip . ((:) .)) .) . flip
07:55:53 <vozz> I guess I can move the _ = Nothing into the monad too for the bottom two
07:55:54 <kuribas> @pl \f acc e -> f acc e:acc
07:55:54 <lambdabot> (flip . ((:) .) =<<)
07:56:14 <Lvcrft> and then I gotta finish the gcc and ghc tasks on Task Manager before I can get that pop up to go away / close.
07:56:24 <c_wraith> Lvcrft: wow.  Never seen that before.
07:56:53 <c_wraith> Lvcrft: did you have additional drives mounted when you installed the platform or something?
07:56:57 <Lvcrft> No
07:57:38 <Lvcrft> Google tells me other people had similar problems
07:57:45 <Lvcrft> but either there's no solutions
07:58:06 <Lvcrft> Or a solution like "I used Power Shell instead of the command prompt", which I really don't know how to even apply here
07:58:16 <Lvcrft> As I opened GHCi from the Start menu
07:59:32 <lpaste> Gurkenglas annotated “No title” with “-> vozz” at http://lpaste.net/1227297036659851264#a350360
08:00:02 <vozz> aaaaah! cool
08:00:06 <Lvcrft> I guess I'll try uninstalling it and try installing via Stack
08:00:07 <vozz> I love this
08:00:49 <c_wraith> Lvcrft: I see that now that I'm looking.  I have no idea why powershell would matter.  I'm not confident installing with stack will go any better for you.
08:00:57 <Gurkenglas> By the way checking floats for equality is a bad time vozz
08:01:21 <Lvcrft> I guess it's worth the shot, I suppose
08:01:43 <c_wraith> Lvcrft: I'd report this as a bug in the windows version of ghc.  This shouldn't be happening.
08:02:05 <Tuplanolla> What even is `realgcc`?
08:02:24 <c_wraith> Lvcrft: and for what it's worth, the next version of windows 10 is expected to replace the command prompt with powershell in all cases anyway, so it might just be worth learning to use it.
08:04:34 <c_wraith> powershell's cmdlet model was actually based on lessons learned from haskell anyway. :)
08:05:06 <kuribas> Does this exist?  http://lpaste.net/350355
08:05:15 <ongy> next version of windows10? I thought it's rolling release now
08:05:21 <Rotaerk> powershell's syntax is just so absurd
08:05:38 <c_wraith> ongy: it is, but the releases are like twice a year unless you're running preview versions
08:05:39 <kuribas> (fmap a rank 2 function).
08:05:56 <vozz> Gurkenglas: I thought it might, trouble is all the numbers sent over the wire are parsed as doubles
08:07:20 <c_wraith> Powershell gives you a typed environment, and cmdlets are sort of a monad in that environment.  I'm not sure how exactly that's true, but they documented that powershell's model was based on Haskell's IO type
08:07:58 <Lvcrft> I guess I'll try installing it on a laptop, to see if it's a desktop problem or a windows problem
08:08:04 <Gurkenglas> I think it's fine as long as they actually input it as 1, without any arithmetic happening along the way, so it might as well be a flag
08:08:18 <c_wraith> vozz: json?
08:08:35 <vozz> c_wraith: something similar yeah
08:08:39 <Lvcrft> I just kinda wish I knew what even realgcc is
08:09:15 <vozz> I guess I could parse ints separately actually
08:09:47 <c_wraith> looks like realgcc is an executable that does the actual compiling, and gcc is a wrapper around it.
08:09:53 <c_wraith> On windows.  Somehow.
08:18:16 <Social-Reject> helloWorld = "HelloWorld"
08:18:32 <Social-Reject> :p
08:18:32 <Social-Reject> :D
08:18:52 <kuribas> Does something like this exists?  (fmapping with a rank 2 function) http://lpaste.net/350355
08:19:16 <kuribas> it seems useful
08:20:12 <c_wraith> kuribas: https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#g:1 is related, but not the same
08:20:33 <Tuplanolla> "Does something I just created exist?"
08:20:45 <Tuplanolla> I like the form of the question.
08:21:05 <c_wraith> It's a common question here.
08:21:17 <c_wraith> About half the time the answer is "yes", so it's even a good question. :)
08:21:26 <kuribas> Tuplanolla: when I come up with something, it usually already exists...
08:21:33 <NextHendrix> been scratching my head for a while about this
08:21:38 <Tuplanolla> If it didn't before, it does now!
08:21:49 <NextHendrix> how can i go from a list of ints to a list of pairs
08:21:51 <phanimahesh> Earlier today I reimplemented (==) on lists in a bunch of ways and was wondering if there's a simpler version.
08:22:06 <NextHendrix> ie, [1,2,3,4,5,6] to [(1,2),(3,4),(5,6)]
08:22:08 <Justatech> should i download my college project from internet but since my professor are very active on internet i am sure they watch out at github.com
08:22:57 <c_wraith> NextHendrix: the easiest solution is just a simple recursive function that pattern-matches the first two elements of the list.
08:23:18 <EvanR> annoyingly lambda the ultimate has unicode problems and i cant read this claim "JaÅ›kowski's natural deduction is superior to Gentzen's"
08:23:40 <kuribas> > let pairs [] = []; pairs [_] = []; pairs (a:b:r) = (a,b):pairs r in pairs [1..6]
08:23:43 <lambdabot>  [(1,2),(3,4),(5,6)]
08:23:45 <EvanR> can anybody solve the puzzle
08:23:57 <c_wraith> kuribas: that version has a bit of an error. :P
08:24:10 <NextHendrix> nice, feels like a right dogs ear parsing input from files
08:24:15 <Tuplanolla> Jaśkowski, EvanR.
08:24:21 <EvanR> thx
08:24:26 <Tuplanolla> Stanisław even.
08:24:37 <kuribas> c_wraith: what error?
08:24:43 <NextHendrix> original format of file is similar to "1\n2 3\n4 5\n6 7"
08:24:53 <c_wraith> kuribas: fails on an input of odd length
08:24:59 <c_wraith> kuribas: with an exception, I mean
08:25:06 <NextHendrix> always even length anyway
08:25:10 <kuribas> c_wraith: it doesn't?
08:25:19 <kuribas> > let pairs [] = []; pairs [_] = []; pairs (a:b:r) = (a,b):pairs r in pairs [1..7]
08:25:20 <NextHendrix> i discard the first number in the file, since that just says how many lines there are, which isn't important
08:25:22 <lambdabot>  [(1,2),(3,4),(5,6)]
08:25:23 <c_wraith> Oh, you wrote three cases.  somehow I missed the middle one
08:25:28 <c_wraith> You only needed two cases. :P
08:25:57 <kuribas> c_wraith: yeah
08:26:37 <Tuplanolla> If it's on the Internet, you can usually undo the damage by converting the mangled text from UTF-8 to a byte string and interpreting it as ISO 8859-1, EvanR.
08:27:23 <Tuplanolla> Or was it the other way around?
08:28:03 <jasondockers> is it typical for ghc to be installed to %appdata%/local/programs on windows 7?
08:28:22 <phanimahesh> And here I was reaching out to a full blown chunkBy for lists.
08:28:22 <kuribas> c_wraith: would it be worth to write a package for it?
08:28:34 <EvanR> Tuplanolla: i find it odd they still havent fixed it
08:28:46 <kuribas> c_wraith: my SuperFunctor I mean...
08:28:47 <EvanR> on LTU
08:28:47 <phanimahesh> kuribas: Data.List.Split, from package split
08:28:59 <EvanR> the only explanation i can come up with is they dont know about it
08:30:26 <NemesisD> why is repeat x = xs where xs = x : xs instead of repeat x = x : repeat x
08:30:45 <blackdog> NemesisD: i think you get better sharing
08:31:29 <NemesisD> oh shit whaddup mwotton
08:31:33 <NemesisD> i think?
08:31:36 <blackdog> yes :) 
08:31:41 <NemesisD> mxavier here
08:31:48 <blackdog> orly? ha, i never new
08:31:50 <blackdog> *knew
08:32:01 <blackdog> audible sound of two personae smushing together in my head
08:32:12 <NemesisD> can't have all the dumb questions i ask in here under my real name
08:32:22 <blackdog> also i think you are trolling me with that ice-skating pic
08:32:35 <blackdog> it's not enough you have beautiful weather year-round, you gotta take our cold-weather stuff too?
08:32:47 <blackdog> oh wait, that's xavier lange
08:32:56 <blackdog> hahaha, oops, mis-smushed
08:33:05 <blackdog> clearly need more coffee
08:43:15 <nitrix> santa = say (repeat "Ho!")
08:43:30 <bstamour> that's a lot of ho's ;)
08:44:30 <Cale> NemesisD: blackdog is correct, you can see the difference using Debug.Trace.trace
08:45:17 <Cale> With repeat x = x : repeat x, you'll end up evaluating repeat arbitrarily many times, and there will be new cons cells allocated on the heap each time
08:46:04 <Cale> Whereas in the other definition, since xs is bound to a variable, it will be evaluated at most once (and in fact is already a constructor application, so there's not much to do)
08:46:39 <Cale> and only one cons cell, with a cyclic reference in it
08:46:59 <Social-Reject> will haskell make me better programmer
08:47:32 <Social-Reject> its a simple question
08:47:33 <Social-Reject> :D
08:47:38 <bstamour> Social-Reject: it did for me. I mostly use C++ in my job, but in a simpelr, more functional style nowadays
08:47:39 <nitrix> The language doesn't have that sort of super mystical powers, no.
08:47:54 <raichoo> Social-Reject: No, learning will.
08:47:59 <bstamour> Haskell influenced me a lot.
08:48:04 <nitrix> But attempting to learn it seriously might lead to changes in thinking that are beneficial to you.
08:48:14 <kazagistar> Learning new ideas about programming makes you a better programmer. Haskell contains a lot of new ideas for most programmers.
08:49:01 <blackdog> there is unfortunately a good chance that learning it deeply will make you see the misfeatures in mainstream languages more clearly, and make it more annoying to use them.
08:49:46 <Social-Reject> I must admit thats the reason one why I'am learning it. Because I think it will make me better programmer
08:50:09 <Rotaerk> there's a good chance that living in a first-world country would make you realize how awful third-world countries are, and make it more annoying to live there
08:50:26 <blackdog> i mean, there are echoes of the whole "learn lisp because of how it changes your mind" meme from ESR
08:50:53 <blackdog> Rotaerk: well, maybe. i miss living in Vietnam though ;)
08:50:55 <maerwald> learning haskell does not necessarily make you a better programmer... but, it will make you a better programmer in haskell
08:50:59 <Rotaerk> heh
08:51:06 <kazagistar> I mean, lisp is probably worth learning a bit too.
08:51:44 <maerwald> becoming a better programmer (in the broader sense) involves different stuff imo
08:52:19 <Social-Reject> maerwald what are those stuff? :D
08:52:22 <c_wraith> kuribas, I'd say that it's less useful overall than hoist from mmorph. way more things fit that pattern, or at least can choose to. 
08:52:35 <Tuplanolla> Haskell is a good gateway to advanced math and proof assistants too, Social-Reject. If you like living inside your head, that's where you should look.
08:52:37 <nitrix> My path learning Haskell resulted in me learning new abstractions that could be applied to a wider variety of concepts. It allowed me to make some room in my head to learn new more advanced things rather than a multitude of tiny intricate details.
08:52:53 <maerwald> Social-Reject: quality, security, safety practices/methodologies, architectural knowledge (on process-level for example, sound algorithmic choices, ...)
08:52:56 <Rotaerk> becoming a better programmer requires identifying what the goals of a "good" programmer are, and constantly thinking about how to improve your fulfillment of those goals with your code
08:52:57 <nitrix> I feel like I'm doing better use of my mental capacity and time.
08:53:12 <Tuplanolla> Good technical writing, maerwald.
08:53:35 <Rotaerk> also "best practices" and such should be taken merely as food for thought, not as rules
08:53:50 <Rotaerk> once you understand WHY they're considered best, and can form your own opinion, you are better for it
08:54:16 <hodapp> also be aware that some "best" practices are actually worst practices but a lot of people really, really want them to be good practices and believe they are.
08:54:55 <Social-Reject> So I was advised
08:55:12 <Social-Reject> that learning haskell that will make me better programmer
08:55:14 <Social-Reject> in long run
08:55:19 <nitrix> I'll also add that we're all still "learning haskell" on various degree. If it had no value, we'd be off doing something else.
08:55:33 <Social-Reject> I'am coming from JavaScript world
08:56:06 <Cale> Social-Reject: I think it does force you to learn certain things which might otherwise take a long time to pick up on
08:57:57 <Cale> Even programming in C or Javascript, you can eventually learn that it's a good idea to limit the use of mutation, but it takes many years of experience before that becomes obvious, whereas Haskell more strongly encourages you into a style where that sort of thing is minimised.
08:58:36 <Rotaerk> Social-Reject, dynamically typed languages like javascript rely heavily on the programmer not screwing up; some people who program in those languages use it like a badge of pride, that only bad programmers need fancy schmancy features like static type checking
08:59:26 <nitrix> Rotaerk: Then there's bugs and they get to be heroes for fixing them!
08:59:59 <Rotaerk> embracing the idea that even the best programmers are fallible is part of the reason to use a static type system, because it both protects you from a lot of mistakes; it also informs you, a sort of inherent documentation
09:00:15 <Social-Reject> Lol on other side I'am learning Angular 2 and on other side Haskell
09:00:18 <Social-Reject> wtf im doing?
09:00:19 <Social-Reject> :D
09:00:22 <raichoo> Social-Reject: If you are coming from JavaScript you might find PureScript interesting.
09:00:38 <hodapp> There is an interesting shift when moving to a language like Haskell or Scala in which the static type system, rather than just being a glorified way of tying the programmer's hands, is more of an assistant.
09:00:39 <Rotaerk> and haskell has a much better static type system than most languages
09:01:03 <raichoo> Social-Reject: It takes a lot of ideas from Haskell, looks very similar and compiles to JavaScript.
09:01:16 <hodapp> and that's a thing that you can use a wide array of "mainstream" statically-typed languages and not ever encounter
09:01:27 <Rotaerk> haskell itself also compiles to javascript with the ghcjs compiler
09:01:52 <Social-Reject> interesting
09:02:25 <Rotaerk> yea dynamically typed programming language users tend to think of static typing as a burden, that they have so much boilerplate to write which could just be avoided if they used a dynamically typed language
09:02:25 <nitrix> I have a little thought here, would using unsafePerformIO inside ST lead to catastrophic results or is that how mutable arrays/vectors/maps are implemented?
09:02:38 <Social-Reject> [ x + 2 | x <- [1..100] so how would this be compiled to javascript
09:02:41 * Cale writes web applications in Haskell for a living
09:02:42 <Rotaerk> but while that's true of some statically typed languages, it's not inherent to the concept
09:02:42 <hodapp> Rotaerk: and for a lot of "normal" statically-typed languages, they really have a point.
09:03:00 <raichoo> Cale: Do you use ghcjs?
09:03:02 <Cale> yes
09:03:02 <bollu> Cale: that's cheating :) GHCjs isn't even close to how terrible JS is
09:03:05 <Cale> and reflex-dom
09:03:10 <raichoo> Interesting.
09:03:15 <Rotaerk> lol
09:03:28 <raichoo> Cale: At my company we are currently using Haskell only on the backend.
09:03:40 <nitrix> Cale: How's the state of GHCjs as of lately? On par with GHC, just with an extra backend?
09:03:53 <Cale> nitrix: Yeah, pretty much
09:04:13 <nitrix> Is there a reason why they wouldn't simply merge their work on GHC itself?
09:04:20 <nitrix> GHC has multiple backend supports already.
09:04:28 <Cale> Because of the dependencies
09:04:45 <nitrix> Ah. Okay.
09:05:00 <chrisdotcode> Cale: is ghcjs heavy?
09:05:24 <Cale> I don't know what heavy means, but probably :)
09:05:33 <raichoo> I thought ghcjs was more like a toy in its currenty state. An impressive toy nevertheless. Nice to hear that someone is actually using it for frontend development.
09:07:29 <nitrix> ertes: I'm back with Haskell on my FRP edeavours. Is reflex the most mature recommendation you'd give me at the moment? What are its issues that I should pay attention to?
09:07:46 <raichoo> Cale: Out of curiosity, have you tried purescript, and if yes, any thoughts on ghcjs vs purescript?
09:07:49 <Cale> It's definitely not in a toy state, we're using it in production on a number of client projects. Since last February we've built a competitor to Slack with a bunch of additional features, and it's working pretty nicely. We're interacting with luite and the GHC team to try to make improvements where we need them.
09:08:08 <Cale> Well, my main thought is "it's really nice to just be able to grab stuff off of Hackage and use it"
09:08:23 <blackdog> chrisdotcode: for reference, our ghcjs app with react bundled in is about 750k after closure-compiling and gzipping
09:09:31 <raichoo> Cale: That's great to hear, it's nice to be proven wrong on the toy assumption ^^
09:09:44 <chrisdotcode> blackdog: nice. how big is it before gzipping?
09:09:58 <dsds> sa tu jacys polacy kurwa ?
09:10:03 <chrisdotcode> 750k is not bad - it's smaller than one big image
09:10:15 <dsds> 8 sa tu jacys polacy kurwa ?
09:10:23 <blackdog> chrisdotcode: about 4mb
09:10:36 <dsds> 4 sa tu jacys polacy kurwa ?
09:10:44 <blackdog> it's not ideal, and purescript definitely produces smaller files
09:11:05 <blackdog> but considering that it's the source code for everything, only needs to be loaded once, and we have many bigger media files...
09:11:26 <chrisdotcode> blackdog: does ghcjs remove unused code in libraries like PS?
09:11:32 <nitrix> dsds: Enlish is the preferred language here if you expect an answer. Otherwise, you'll have to be patient until someone can answer you :)
09:12:35 <ertes> nitrix: reflex is my "default" recommendation…  if in doubt use reflex
09:12:58 <blackdog> chrisdotcode: yes - i think that's actually a ghc feature, though
09:13:03 <blackdog> but you still need the runtime system
09:13:03 <nitrix> ertes: Are there time leaks issues, invariants that breaks or anything funky?
09:13:12 <Cale> and if you're going to try reflex, I highly recommend getting it via reflex-platform.
09:13:28 <Cale> It's much easier than building ghcjs yourself and getting all the dependencies right and so on.
09:13:30 <blackdog> re reflex: i did find the type errors a bit impenetrable sometimes. we use ian duncan's react binding and it's been ok.
09:13:35 <dsds> 4 sa tu jacys polacy kurwa ?
09:13:36 <dsds> 4 sa tu jacys polacy kurwa ?
09:13:36 <dsds> 4 sa tu jacys polacy kurwa ?
09:13:38 <dsds> 4 sa tu jacys polacy kurwa ?
09:13:41 <hexagoxel> @where ops
09:13:41 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
09:13:43 <nitrix> shapr.
09:13:45 --- mode: ChanServ set +o Cale
09:13:52 --- mode: ChanServ set +o johnw
09:13:52 --- mode: johnw set +b *!~dssdsd@5.172.255.189
09:13:53 --- kick: dsds was kicked by johnw (Kicked)
09:13:53 --- mode: Cale set +b *!*@5.172.255.189
09:13:53 --- mode: johnw set -o johnw
09:14:00 <Cale> hah
09:14:06 --- mode: Cale set -o Cale
09:14:09 <nitrix> They didn't take my advice :(
09:14:15 <Rotaerk> that sentence "sa tu jacys polacy kurwa" apparently means "here are some poles whore"
09:14:20 <Rotaerk> according to google
09:14:31 <Rotaerk> so I don't think they wanted help
09:14:48 <nitrix> They're trying to learn Haskell, they just don't know it yet.
09:14:53 <Rotaerk> heh
09:15:01 <johnw> they're learning which inputs result in what effects
09:15:04 <ertes> nitrix: currently there is a memory leak to be aware of when dealing with long-running high-framerate applications
09:15:14 <nitrix> The KickM monad.
09:15:47 <nitrix> ertes: Like a game? That sounds problematic.
09:16:09 <ertes> nitrix: yeah…  it's nothing that can't be fixed, but ryan hasn't got around to fixing it yet, as far as i can tell
09:17:32 <ertes> nitrix: however, the leak occurs only if a root event (one created in the host language – you'll know what that means) fires rarely…  whenever it fires all the leaked memory is released
09:18:47 <johnw> if anyone has problems sending/receiving to haskell.org mailing lists, please ping me
09:19:14 <nitrix> ertes: Oh so it's an artifact between the push/pull model? If I have for example SDL events at the root, in some PushM, it'll forcefully clear that up?
09:19:52 <nitrix> ertes: That's not that bad then. What about wires? I was looking up to it ;-;
09:22:59 <ertes> nitrix: wires has smaller constant factors, no known memory leaks and more opportunities for effects, so i'd generally recommend it for high-framerate applications or applications that involve randomness, in your particular case i recommend reflex anyway, because the A in AFRP makes things work differently in non-obvious ways
09:26:32 <Cale> Yeah, non-Arrowised FRP is so much nicer to manipulate. AFRP is still pretty good, but it can be frustrating sometimes that you can't give names to the things you want to give names to.
09:26:46 <Cale> (proc/do-notation helps with that, but only locally)
09:26:47 <ertes> the reactive constructs like behaviours and events aren't first-class in AFRP (arrow syntax creates the illusion that they are, but they really aren't)…  and "everything is a behaviour"
09:27:04 <Social-Reject> so there is no 'return' in haskell functions
09:27:10 <Social-Reject> then how do you stop recursion??!?
09:27:28 <Cale> Social-Reject: I think you might be misunderstanding something
09:27:36 <Social-Reject> probably :p
09:27:58 <Cale> Functions have results.
09:28:20 <Cale> and you can have base cases just as usual
09:28:35 <Cale> 'return' isn't a keyword in Haskell
09:28:57 <Social-Reject> :-)
09:29:01 <grantwu> fib 1 = 1
09:29:08 <Cale> But you just write the result of the function to the right of the = sign in its definition.
09:29:15 <Social-Reject> I see
09:29:17 <Social-Reject> so
09:29:32 <Social-Reject> someFun x y = someFun x y
09:29:34 <Social-Reject> ?
09:29:42 <Cale> That will loop forever as written
09:30:04 <Social-Reject> how is the right way :>
09:30:20 <ertes> Social-Reject: "what's the result of someFun 5 7?  ah, it's someFun 5 7…  ok, what's the result of someFun 5 7?  ah, it's someFun 5 7…"
09:30:23 <Cale> Maybe you want to have someFun x y be equal to someFun applied to *different* arguments?
09:30:46 <Social-Reject> ertes that will go forever lol :D
09:30:53 <ertes> Social-Reject: indeed ;)
09:31:09 <Cale> > let fib a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 10
09:31:12 <lambdabot>  55
09:31:23 <NextHendrix> check out this shit i just wrote https://ptpw.pb/rzUd/haskell
09:31:39 <Social-Reject> Cale I just started haskell yesterday, getting a bit over my head
09:31:46 <NextHendrix> the simplest problem and i end up with this mess
09:32:08 <Cale> Social-Reject: well, this is a function that computes the Fibonacci numbers (reasonably efficiently)
09:32:10 <NextHendrix> works though, but not sure how to go about cleaning it up a bit
09:33:06 <NextHendrix> typod link * https://ptpb.pw/rzUd/haskell
09:34:21 <ertes> NextHendrix: first step: reduce your usage of ($) *a lot*
09:34:53 <ertes> NextHendrix: at this point i would suggest to avoid it completely
09:35:01 <Cale> Social-Reject: I dunno, there will be lots of examples of recursive functions you'll run into early on :)
09:35:02 <ertes> just to see your code with more structure
09:35:09 <Social-Reject> :D
09:35:20 <Cale> Social-Reject: There are lots of good ones which operate on lists
09:35:24 <Cale> sum [] = 0
09:35:29 <Cale> sum (x:xs) = x + sum xs
09:35:33 <NextHendrix> ertes: i know it looks more like an invoice than source code 
09:35:36 <Cale> This says that the sum of an empty list is 0
09:35:53 <Cale> and then the sum of a nonempty list whose first element is x and whose tail is xs, is x plus the sum of xs
09:35:55 <ertes> NextHendrix: more importantly it's surprisingly difficult to read
09:36:22 <Social-Reject> I'am intimidated by recursion kek
09:36:23 <Social-Reject> :D
09:36:25 <NextHendrix> i was sort of working backwards in ghci from the input, parsing it was hell
09:36:58 <Cale> Social-Reject: Well, it's more intimidating in languages where you can have arbitrary effects going on as the evaluation proceeds
09:37:15 <NextHendrix> would it be better with a bunch of wheres or separately declared functions
09:37:26 <Cale> (Well, you can have that in Haskell too, but for simple functions like this, it's totally avoided)
09:37:31 <ertes> NextHendrix: so yeah, get rid of all ($) and see which ones were unnecessary to begin with (yes, there are some), and what the application structure of your code actually looks like when it hasn't been force-flattened by ($)
09:37:46 <ertes> NextHendrix: no, really just remove ($) and introduce parentheses instead
09:37:57 <grantwu> I like uh
09:38:09 <grantwu> Hlint can remove some of those $
09:38:21 <NextHendrix> ertes nice one, going to walk the dogs ill lispify it when i get back
09:39:03 <ertes> NextHendrix: don't worry, another function called (.) will delispify it again, but in a much more readable manner, because that one is associative =)
09:39:11 <Rotaerk> more $ is always better
09:39:19 <NextHendrix> parsing the specific input those little code challenge websites give me is by far the hardest thing ive found so far
09:39:21 <Rotaerk> though $ doesn't buy happiness
09:39:24 <lpaste> hexagoxel pasted “perfectly readable (ertes, NextHendrix)” at http://lpaste.net/350362
09:40:16 <blackdog> NextHendrix: also what should your function do if i run echo "" | ./yourprogram ?
09:40:19 <Cale> Social-Reject: Just to introduce better how lists work in Haskell so I can explain the example, every list is either [], the empty list, or it consists of a single element x (called the head of the list) followed by another list, say xs, the tail of the list. (Note that it's conventional to use something plural for lists, and xs is the plural of x :)
09:40:31 <Cale> and that's written (x:xs)
09:40:39 <mmaruseacph2> I usuualy go from "f (g (h a (i x)))" to "f $ g $ h a $ i $ x" first and then replace all dolars but the last with .
09:40:57 <Cale> So when you write a list such as [1,2,3,4,5], this is really syntax sugar for 1 : (2 : (3 : (4 : (5 : []))))
09:40:58 <NextHendrix> blackdog: the input is from stdin, described at the top
09:41:11 <NextHendrix> first line is the number of pairs, the rest are pairs of numbers separated by a space
09:41:13 <Social-Reject> interesting
09:41:21 <NextHendrix> sum them and print out as a space separated string
09:41:44 <blackdog> NextHendrix: yes, I understand that. What i'm gesturing at vaguely is that if stdin is empty, your program will crash.
09:41:55 <NextHendrix> blackdog: yes i pipe it in
09:41:57 <ertes> my "$" is almost always followed by "do"
09:42:02 <blackdog> NextHendrix: ...
09:42:03 <hexagoxel> NextHendrix: note that map f . map g == fmap (f . g)
09:42:17 <blackdog> NextHendrix: read what i'm writing :)
09:42:20 <ertes> sometimes by "case"
09:42:22 <Cale> Social-Reject: So, suppose we apply our sum function to this list: we can work out the result the same way you might simplify an expression in highschool algebra, by replacing equals with equals according to the definition:
09:42:27 <hexagoxel> and that this rule is applicable is immediately clear with my ($)-based layouting
09:42:33 <hexagoxel> but far less clear with parentheses
09:42:36 <NextHendrix> blackdog: yes this program is definitely not suited for an end user :]
09:42:43 <Cale> sum (1 : (2 : (3 : (4 : (5 : []))))) = 1 + sum (2 : (3 : (4 : (5 : []))))
09:42:58 <Cale> = 1 + (2 + sum (3 : (4 : (5 : []))))
09:43:02 <NextHendrix> hexagoxel: i did not know that, thanks
09:43:14 <Cale> = 1 + (2 + (3 + sum (4 : (5 : []))))
09:43:16 <hexagoxel> s/fmap/map/, oops
09:43:26 <Social-Reject> :D
09:43:29 <hexagoxel> (although fmap would work too)
09:43:29 <Cale> = 1 + (2 + (3 + (4 + sum (5 : []))))
09:43:38 <Cale> = 1 + (2 + (3 + (4 + (5 + sum []))))
09:43:41 <Cale> = 1 + (2 + (3 + (4 + (5 + 0))))
09:43:48 <Cale> = 1 + (2 + (3 + (4 + 5)))
09:43:51 <blackdog> NextHendrix: ok, but it's generally good haskell style not to write programs that have the possibility of crashing on bad input :) 
09:43:55 <Cale> = 1 + (2 + (3 + 9))
09:44:01 <lpaste> tippenein pasted “ToJSON insert with generic” at http://lpaste.net/350363
09:44:05 <Cale> = 1 + (2 + 12)
09:44:09 <Cale> = 1 + 14
09:44:11 <Cale> = 15
09:44:19 <Rotaerk> good, you didn't mess up your arithmetic
09:44:27 <Cale> haha, I was scared :)
09:44:34 <Rotaerk> hehe
09:45:13 <NextHendrix> blackdog: very wise, i was just gassed that it finally actually worked
09:45:25 <tippenein> above lpaste is my question on how to use genericToJSON but add additional fields to the Object
09:46:00 <Cale> Social-Reject: But of course, when you're writing the function, you don't have to think all this through: when you define a recursive function, you always assume that it will work as expected when applied to any argument which is "smaller" than the original input.
09:46:19 <Cale> Social-Reject: So, rather than thinking through how sum xs will unfold in the definition  sum (x:xs) = x + sum xs
09:46:40 <Cale> We just ask "is the sum of the whole list supposed to be equal to the first element plus the sum of the rest of the list?"
09:46:51 <Cale> and seeing as the answer is "yes", we see that this will work
09:46:56 <blackdog> NextHendrix: don't let me ungas you then :)
09:48:06 <NextHendrix> blackdog: regassed to learn
09:49:54 <Rotaerk> Social-Reject, when trying to understand a recursive expression, I think when I started, I tried to mentally step through each level of recursion, and then my mental stack would explode
09:50:13 <Social-Reject> how do you see 3 steps in advance
09:50:52 <Rotaerk> I think it's easier to understand, though, if you approach it differently:  understand the *concept* of what the expression means
09:51:04 <Rotaerk> sum xs is the sum of everything in xs, doesn't matter *how* it achieves that
09:51:10 <NextHendrix> ertes: bar cleaning it up, cycling through all those different data structures seems like the long way round a short distance
09:51:12 <Rotaerk> and clearly sum(x:xs) is just sum xs ... plus x
09:51:37 <NextHendrix> am i missing an easy way to parse that input into a usable format
09:52:21 <ertes> sorry, i can't help you
09:53:13 <blackdog> NextHendrix: quite often, fusion will kick in - it's not necessarily constructing the intermediate lists.
09:53:35 <blackdog> that said, you can pull everything into the external map and do it yourself, if you like
09:53:57 <blackdog> it'll look more like getSums xs = map someFunc $ tail $ lines xs
09:54:08 <blackdog> or getSums = map someFunc . tail . lines, if you're pointfree-inclined
09:55:27 <nitrix> Cale: reduce (1 + 14)
09:55:37 <nitrix> > reduce (1 + 14) -- Cale
09:55:40 <lambdabot>  15
09:55:54 <nitrix> > reduction (1 + (2 + 12)) -- Cale
09:55:57 <lambdabot>  [1 + (2 + 12),1 + 14,15]
09:56:03 <nitrix> My favorite little tool :P
09:56:35 <ertes> > reduction (scanl (+) 0 [1..])
09:56:37 <lambdabot>  error:
09:56:38 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
09:56:38 <lambdabot>      • In the first argument of ‘reduction’, namely
09:57:01 <ertes> > reduction (foldr (+) 0 [1..])
09:57:04 <lambdabot>  [1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
09:57:23 <ertes> lovely…
09:57:41 <nitrix> Yeah it shows the reductions of foldr/foldl nicely for teaching.
09:58:38 <ertes> that's…  not quite what it does there =)
09:59:04 <nitrix> Its doing its best :<
09:59:44 <ertes> i've actually found that the algebraic approach to teaching foldr has worked best so far
10:00:31 <maerwald> depends on the audience
10:01:43 <ertes> maerwald: and on the teacher
10:01:55 <maerwald> and the phase of the moon!
10:10:27 <nitrix> maerwald: Here's a git hook to deploy only when the planets are aligned (for increased luck): https://github.com/lhartikk/AstroBuild
10:11:39 <maerwald> that should do
10:37:12 <bollu> can I have some review of a tutorial I wrote? http://bollu.github.io/teleport/
10:37:22 <bollu> ertes, johnw: I simplified the types
10:37:59 <kmelva> Any ideas why is Haskell about 100x slower than Python in this simple SQLite script? https://gist.github.com/kmelva/a5607b1704c25d5d4e0e462f00829772
10:38:45 <kmelva> I've tried profiling, but all I can see it's stuck for 99% of the time in SQLite bindings (direct-sqlite)
10:39:59 <johnw> I wonder if the sqlite library have different commit policies
10:40:50 <kmelva> johnw: but both are :memory: databases, I think it shouldn't matter that much...
10:41:08 <johnw> still, it's something to rule out as a possibility
10:41:16 <johnw> queueing 200,000 inserts and then committing them
10:41:22 <johnw> is quite different from 200,000 insert/commits
10:41:26 <kmelva> johnw: agree, I'm off to check that... 
10:41:34 <bollu> johnw: do you think it is in decent shape now? :)
10:41:52 <johnw> bollu: I'm a bit snowed under to read through again; I'd ask others who haven't seen it yet, who have fresh eyes
10:42:25 <ongy> I'd guess that this is a safe call in the binding and the bookkeeping/thread spawning/taking over of the RTS slows it down. have you tried if threaded RTS makes a difference?
10:42:40 <blackdog> kmelva: worth checking what version of direct-sqlite you're using too - i'm on the mailing list and i think they just updated the underlying lib to a faster version.
10:43:29 <blackdog> for what it's worth, i used that library to write data to disk about as fast as i could serialise it to a flat file
10:44:32 <kmelva> blackdog: thanks for the idea, but I'm on latest version, stack lts-7.14
10:44:36 <dmj`> bollu: looks nice, just a cursory read, might want to avoid String, and partial functions from the definition of Command (snake types make partials).
10:45:18 <blackdog> oh - i think you should also prepare a statement, rather than just executing text
10:45:23 <bollu> dmj`: what are snake types?
10:45:31 <blackdog> it's probably just parsing it every time, rather than prepping once then using.
10:45:32 <bollu> dmj`: I try to use Text throughout
10:45:45 <dmj`> sum types with record fields
10:45:46 <bollu> dmj`: but there is some friction between Filepath, Aeson, etc.
10:45:50 <bollu> dmj`: ah, that
10:45:58 <bollu> dmj`: I initially had it in a separate option type
10:46:09 <dmj`> removeName (CommandAdd x y) == *boom*
10:46:11 <bollu> dmj`: like, CommandAdd AddOptions | CommandRemove RemoveOptions | ...
10:46:29 <bollu> dmj`: yeah, but, I found that the added complexity of lifting parsers and such doesn't pay off
10:46:39 <bollu> dmj`: since the goal was to write a tutorial sort of thing
10:46:42 <dmj`> yea, that’s probably safer, or keep it in one Sum type, but type def String, etc.
10:46:45 <bollu> yeah
10:46:51 <bollu> I could mention it at the end though
10:47:00 <blackdog> kmelva: yeah, prepare, then bind/step/reset
10:47:00 <bollu> and typedefing String seems like a solid idea, let me do that
10:47:03 <dmj`> ah yea, parsing command line options
10:47:08 <bollu> dmj`: any other stylistic comments?
10:47:21 <dmj`> getopt-generics is cool, anything with the “environment” I’d check out generics
10:47:32 <dmj`> @package getopt-generic
10:47:32 <lambdabot> http://hackage.haskell.org/package/getopt-generic
10:48:29 <dmj`> same with JSON too, I’d probably use Generics or TH, but for the sake of pedagogy that might not be helpful
10:49:34 <blackdog> kmelva: direct-sqlite is meant to be a very low-level mapping - pretty much every function maps directly to the C equivalent. python's sqlite3 might be doing the preparing behind the scenes.
10:51:19 <dmj`> kmelva: I’d avoid for_ here, it’s probably not doing any inserts in the database until it has allocated all of the insert statements as thunks first
10:51:27 <dmj`> @src for_
10:51:27 <lambdabot> Source not found. You untyped fool!
10:51:37 <dmj`> for_ = flip (foldr ((*>) . f) (pure ()))
10:51:40 <kmelva> dmj`: what to use instead of for_?
10:52:13 <johnw> @src forM_
10:52:13 <lambdabot> forM_ = flip mapM_
10:52:17 <johnw> @src mapM_
10:52:17 <lambdabot> mapM_ f as = sequence_ (map f as)
10:52:25 <blackdog> dmj`: i'd be hugely surprised if that was it :)
10:52:25 <dmj`> sequence_ is foldr too afaik
10:52:31 <johnw> @src sequence_
10:52:32 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:52:34 <johnw> yep
10:52:50 <johnw> but I think >> is sufficiently strict
10:53:18 <johnw> I don't think I've had a case where mapM_ generated a thunk for every possible action
10:53:29 <johnw> I'm a bit surprised if for_ is really doing that too
10:53:35 <johnw> would need to see the profiling output
10:53:50 <johnw> (I guess I meant, sufficiently lazy)
11:00:16 <blackdog> kmelva: tried with prepared statements, that speeds it up by 5x or so here
11:03:46 <kmelva> blackdog: thanks, will try that later for sure... in the mean time - I've managed to slow down the Python script by about a factor of 500 :D, by using isolation_level=None
11:04:22 <kmelva> I guess by default direct-sqlite and python sqlite3 do handle databases diferently... will have to look into it in detail later, but probably that's the issue
11:05:02 <blackdog> kmelva: https://gist.github.com/mwotton/4108f92329bf35724963fdc9c2e39b12 is the fragment i changed.
11:17:53 <dmj`> blackdog, johnw: http://heap.ezyang.com/view/c3a0b477479765512622bcc7ce6cee6571220f91
11:19:08 <johnw> dmj`: this results from what change?
11:21:15 <dmj`> johnw: no change, just his code verbatim, I did change it from 2M to 200k since it was taking too long. (for_ [ 1..200000])
11:21:26 <c_wraith> that's a very pretty memory profile. 
11:21:34 <johnw> yeah, I was going to say, no thunk buildup there
11:21:50 <johnw> it seems like the execution is slow then
11:21:58 <dmj`> yea, very flat
11:24:31 <swxg> uhh can anyone help me with a quick question i have in swift?
11:24:47 <johnw> not here, swxg 
11:24:55 <swxg> ait nw
11:25:07 <dmj`> seems like 60% of the time is spent in exec
11:25:11 <dmj`> http://sqlite-prof.bitballoon.com/
11:28:00 <blackdog> dmj`: yeah, that's expected
11:28:17 <blackdog> reparsing the stmt every time isn't exactly performant :)
11:31:55 <c_wraith> does sqlite do prepared statements? 
11:36:08 <johnw> even if it doesn't, why is the Python code so much faster?
11:36:20 <blackdog> c_wraith: yes.
11:36:51 <c_wraith> it's possible the haskell bindings are just bad. 
11:37:09 <c_wraith> that's slowed down more than one db benchmark in Haskell. 
11:37:55 <blackdog> c_wraith: they are not bad.
11:38:10 <blackdog> i used them at meanpath, insertion was about as fast as writing directly to a flat file.
11:38:13 <kmelva> johnw: Python is doing something different... autoCommit is off
11:38:46 <kmelva> johnw: I can make Python even slower by using sqlite3.connect(":memory:", isolation_level=None)
11:38:49 <blackdog> you need to prepare statements then step them, same as in the C api. direct-sqlite is a faithful binding, not a high level one. exec is meant to be for playing around.
11:39:02 <c_wraith> blackdog, OK, yes. that sounds pretty good. 
11:39:06 <kmelva> johnw: or Haskell fast by wrapping everything in "BEGIN" "COMMIT"
11:40:34 <blackdog> given how little computation is involved in either, it's actually sorta surprising that it uses much cpu at all - i'd expect it to be mostly IO time.
11:41:04 <grazie> hi, the prop_build function (109) takes an argument, but when it's called by quickCheck (134) no arguments are supplied. is there a way to know what quickCheck's calling it with? https://gist.github.com/caa84df63f87a1cd1e1814a64596b81b
11:42:44 <geekosaur> easiest way is probably to use traceShowId in prop_build
11:43:23 <c_wraith> grazie, the whole point of quickcheck is that it calls the functions it's given with a bunch of sorta-random arguments 
11:44:05 <c_wraith> grazie, and if the test fails, it tells you what the failing input was. 
11:45:00 <grazie> c_wraith : ok, thank you
11:45:28 <c_wraith> I'm a bit suspicious of those tests though. seems they would have to be monomorphized when provided to quickcheck 
11:45:55 <c_wraith> and if they are allowed to specialize automatically, they'll pick () for a
11:46:03 <c_wraith> which isn't very good. 
11:46:21 <blackdog> c_wraith: a fearsome deadpan, that :)
11:46:24 <c_wraith> oh, I scrolled down. they are fixed to better types. 
11:46:41 <blackdog> "we tested on a type with one inhabitant. this is .. sub-optimal."
11:46:56 <lyxia> QuickCheck has a "collect" function to keep test cases
11:47:12 <c_wraith> @check \xs -> xs == reverse xs
11:47:15 <lambdabot>  +++ OK, passed 100 tests.
11:47:17 <ertes> kmelva: just to be sure: is the python variant actually linking to the same sqlite library?  there are two major versions still in use today
11:47:47 <blackdog> ertes: kmelva is using the most recent version of sqlite with haskell, at least.
11:50:05 <Adeon> hey...is there a way to turn off the overcommit behaviour in recent GHC that allocates 1 terabyte of virtual memory upfront when program starts
11:50:19 <Adeon> I have a C library that I suspect is being stupid and behaves differently with this on
11:51:18 <lyxia> Adeon: there are RTS options for that
11:51:50 <lyxia> +RTS -M1G   ?
11:52:02 <Adeon> hmm let's try it
11:52:21 <lyxia> you might need to recompile with rtsopts
11:53:35 <Adeon> hmm nope, still 1 terabyte of virtual memory
11:53:43 <Adeon> I will dig deeper into the user guide and try other arguments
11:55:05 <Liskni_si> Adeon: the 32-bit rts doesn't do that :-)
11:55:09 <Adeon> if nothing else I would expect I can at least compile it away
11:55:10 <Adeon> yeah
11:55:18 <Adeon> as in compile new ghc
11:55:22 <Adeon> although I am hoping I don't have to
11:57:06 <SecretAgentX-9> Hello, Can someone tell me why `tellFortune :: (String s) => s -> s` is invalid?  Haskell for OSX complains "‘String’ is applied to too many type arguments"
11:57:36 <Akii> String is a type, not a typeclass
11:57:46 <Akii> or, constraint I should say
11:58:07 <Akii> `tellFortune :: String -> String`
11:58:29 <SecretAgentX-9> Gotcha
11:58:42 <SecretAgentX-9> So I guess [Char] would work? 
11:58:53 <Akii> type String = [Char]
11:58:55 <Akii> literally
11:58:59 <SecretAgentX-9> oh 
11:59:24 <Cale> SecretAgentX-9: You probably meant to write tellFortune :: String -> String
11:59:34 <Cale> ah, Akii said this
11:59:43 <SecretAgentX-9> Yeah
11:59:56 <Akii> Cale: please do correct me if I am being not precise or anything
11:59:56 <nitrix> :k String
11:59:59 <lambdabot> *
11:59:59 <nitrix> :k Num
12:00:01 <lambdabot> * -> Constraint
12:00:05 <SecretAgentX-9> Guess I'm just wondering why 
12:00:11 * SecretAgentX-9 is a C# dev
12:00:12 <Cale> Nah, that's fine, I just replied without reading the conversation properly :)
12:00:27 <Cale> SecretAgentX-9: why what?
12:00:30 <SecretAgentX-9> so I'm used to just defining my argument types
12:00:55 <Cale> String isn't a type class, it's just a type
12:01:51 <Cale> What you wrote originally means "For any type s which is an instance of the String type class, tellFortune will take an argument of type s, and produce a result of type s.
12:01:53 <Cale> "
12:02:16 <Cale> But there is no such class, hence the compiler complained
12:02:33 <Akii> in a weird way though
12:02:47 <Akii> could've said that String is not a typeclass
12:02:48 <SecretAgentX-9> Ahh ok. I think I'm starting to get it. 
12:03:33 <SecretAgentX-9> thanks for the help 
12:03:53 * geekosaur still thinks recent type level changes made errors a lot more confusing :/
12:04:03 <Akii> this is heading down the complexity road but wouldn't it possible for the compiler to deduct this?
12:04:03 <Rotaerk> :t undefined :: String
12:04:05 <lambdabot> String
12:04:20 <Akii> :t undefined :: Void
12:04:22 <Rotaerk> :t undefined :: (String s) => String
12:04:23 <lambdabot> Void
12:04:25 <lambdabot> error:
12:04:25 <lambdabot>     • Expecting one fewer argument to ‘String’
12:04:25 <lambdabot>       Expected kind ‘k0 -> Constraint’, but ‘String’ has kind ‘*’
12:04:34 <Akii> ha
12:04:54 <Cale> Yeah, there's probably a fair amount which could be done to look for special cases like that where it appears someone is using a type of kind * as if it was a class, and produce an easier to understand message.
12:10:51 <geekosaur> SecretAgentX-9, typeclasses aren't like OOP classes/types. they're a bit like interfaces; a type can have instances of multiple typeclasses, saying they can do various things (Eq, Ord, Show, Monoid, ...)
12:11:26 <geekosaur> and we can then write functions that rely only on those interfaces, rather than specific types
12:13:23 <geekosaur> typeclasses are one kind of constraint (the other common one is type equality constraints); they go on the left of => and include one or more type variables that you can then use in the type as needed
12:14:35 <geekosaur> :t (^)
12:14:37 <lambdabot> (Num a, Integral b) => a -> b -> a
12:15:21 <geekosaur> ...also note that using e.g. (Num a) includes all numbers, but only provides the operations valid for all of them --- notably, *not* division.
12:16:50 <orion> geekosaur: Are you aware of any resources that cover the more esoteric aspects of the language, like equality constraints?
12:17:53 <geekosaur> not really, no
12:18:08 <geekosaur> (in fact I still want to file a doc bug about them...)
12:18:48 <geekosaur> ghc doc has a short blurb about them, doesn't say whether they're even considered an extension, doesn't say what extensions imply them...
12:18:51 <nitrix> Aren't we supposed to use funtional dependencies instead?
12:19:10 <Cale> nitrix: ?
12:19:12 <geekosaur> er? 
12:19:52 <geekosaur> they're vaguely related but don't really do similar things
12:21:17 <nitrix> It seems the me the difference is no super class as a constraint, but the type checker performs similar work in both cases :/
12:22:02 <geekosaur> ... are we even talking about the same thing
12:22:06 <geekosaur> type equality is ~
12:25:13 <orion> From typeclassopedia: "As noted before, the list constructor [] is a functor *" -- isn't it * -> *
12:25:20 <orion> :k ([])
12:25:22 <lambdabot> * -> *
12:25:39 <geekosaur> constructor.
12:25:48 <geekosaur> it's talking about the nil case []
12:25:52 <orion> oh
12:26:09 <glguy> orion: Those "*" are not kinds
12:26:15 <orion> I see.
12:26:25 <nitrix> orion: The * is an annotation, the note is in the margin on the right.
12:26:28 <geekosaur> ...and, oh
12:27:21 <nitrix> orion: [] does have kind :: * -> * and they're functors indeed :)
12:27:32 <nitrix> instance Functor [] -- Defined in `GHC.Base`.
12:27:50 <nitrix> geekosaur: class Foo x y | x -> y    vs.   class (Bar x ~ y) => Foo x y where type Bar x, aren't they vaguely similar?
12:29:07 <geekosaur> they are, but there is no "thought we were supposed to use" in that case --- fundeps and type families occupy different but related niches in ghc's type system
12:29:41 <geekosaur> but ~ is useful for more than that situation
12:30:22 <nitrix> Can't the other situations fallback on fundeps? Are are there situations where you really need equalities + families ?
12:31:01 <geekosaur> no? ~ is much more general
12:32:02 <c_wraith> I think fundeps still work better with inference in some cases. 
12:33:31 <nitrix> geekosaur: Ah okay. I'll keep that in mind. I haven't been very exposed yet to such code, so it's still blurry :(
12:34:08 <shapr> I just used debtree to check my company's package dependencies, then was asked if I could do that for Ruby. I had no idea Haskell's graphviz bindings have explicit FGL support!
12:34:30 <lesshaste> would any speed gurus be interested in making a faster answer to http://codegolf.stackexchange.com/questions/97060/calculate-the-permanent-as-quickly-as-possible ?
12:34:37 <lesshaste> (the answer by Ton Hospel is hardly in C so can be safely ignored)
12:34:45 <lesshaste> it would be interested if the speed of Dennis's C answer can be matched
12:34:48 <lesshaste> interesting
12:35:27 <shapr> lesshaste: Do you ever use parMap to speed up your golf answers?
12:35:57 <lesshaste> shapr, I am sadly not a haskell expert.. I just feel that an expert might have some more to contribute here
12:36:01 <lesshaste> so no :)
12:37:26 <shapr> lesshaste: amusingly, the top Haskell answer on that problem explicitly uses Control.Parallel
12:38:48 <lesshaste> shapr,  sorry to be dim but why is that amusing?
12:40:02 <shapr> lesshaste: I wasn't expecting code golf solutions to be making use of parallelism in Haskell
12:41:02 <lesshaste> shapr,  ah ok
12:41:23 <lesshaste> I think that codes creates lots of short vectors
12:41:28 <lesshaste> which is why it isn't as fast as possible
12:41:46 <lesshaste> one idea is do it with mutable arrays, then you will see how good ghc's strictness analyser for the int variables is
12:42:03 <lesshaste> or  write pretty much the same code as the (non-vectorised) c in haskell, and the llvm backend ought to give you basically the same performance
12:42:08 <lesshaste> but I am really no expert
12:42:37 <shapr> lesshaste: you are more of an expert than I am!
12:42:59 <shapr> I just want to solve all of the Advent of Code problems
12:43:01 <lesshaste> not at haskell!
12:44:10 <glguy> shapr: Do you have an AoC problem in mind to do next?
12:45:18 <shapr> glguy: spare time is my largest constraint at the moment, I just need a few hours to sit down and think
12:45:51 <shapr> glguy: Also, can you point me to a good megaparsec tutorial?
12:46:44 <shapr> I used Parsec to build a full RFC822 parser .. more than ten years ago. I seem to have forgotten how it all works.
12:48:07 <johnw> isn't megaparsec pretty much the same as parsec in terms of UI?
12:48:15 <Tuplanolla> Yes.
12:49:28 * geekosaur boggles slightly... mostly because strict parsing has never really worked for mail
12:49:29 <shapr> johnw: do you have a Parsec or Megaparsec tutorial that you recommend?
12:50:27 <glguy> shapr: I don't know of any. I don't remember when it was that I learned how to use parsec
12:50:47 <johnw> shapr: the parsec manual is very good
12:51:01 <johnw> there's https://github.com/JakeWheat/intro_to_parsing
12:51:10 <johnw> and http://book.realworldhaskell.org/read/using-parsec.html
12:51:30 <Tuplanolla> If you know the underlying theory, you can just start using Parsec, shapr.
12:51:59 <Tuplanolla> It's quite intuitive.
13:00:53 <shapr> Tuplanolla: Where is the underlying theory documented?
13:01:20 <c_wraith> usually in compiler classes and books. 
13:01:48 <Tuplanolla> @google direct style monadic parser combinators for the real world
13:01:49 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
13:01:59 <monochrom> :)
13:02:12 <mmaruseacph2> interesting
13:05:41 <geekosaur> you can mostly boil the theory down to a few guidelines, though. (like, don't do left recursion...)
13:07:12 <sm> shapr: you could check megaparsec's docs :)
13:21:31 <monochrom> Oh God, for Christmas we won't have 8.0.2, we will only have release candidate 2
13:30:19 <f-a> I am scratching my head reading this build error http://hackage.haskell.org/package/lentil-1.0.3.3/reports/1
13:30:53 <f-a> If I configure it on my machine and try to put transformer 0.5 in place of 0.4 it warns of a likely broken build 
13:31:08 <f-a> how to fix this so it works on hackage ?
13:32:24 <nitrix> You'll have to loosen up your dependency on transformers 4.0
13:32:44 <geekosaur> "broken build" means some other dependency has the hard transformers-4.x dep
13:32:51 <nitrix> f-a: transformers 4.0 requires base < 4.9 and your projects has a strict dependency on base == 4.9.
13:32:55 <geekosaur> so it would be trying to use both versions at the same time
13:33:31 <nitrix> Oh nevermind, you don't. Interesting.
13:34:36 <f-a> thanks nitrix , geekosaur . Any way to pinpoint which pasky dependency is doing that
13:35:05 <geekosaur> using -v3 with cabal should tell you which dependency is insisting on 4.x
13:35:33 <geekosaur> you would probably need to loosen that dependency's constraints afterward, assuming a version exists that accepts transformers 5
13:37:45 <vozz> Anyone know why I might occasionally be getting "hGetChunk: invalid argument (invalid byte sequence)"? I'm using hGetChunk to read a file that is being appended to by another process. Checking the file after this happens, it doesn't look like there's any weird characters in there.
13:39:06 <geekosaur> most programs use buffered output to files. this can lead to a utf8 character being split across buffer chunks
13:40:41 <geekosaur> more generally, even if you don't see that, there is no guarantee that your read chunk consists of complete utf8 characters
13:40:42 <vozz> Hm... is there a way I can handle this safely?
13:41:07 <nitrix> f-a: Upgrading your dependency on transformers by allowing transformers==0.5.* compiles fine here.
13:41:20 <vozz> Would I want to read as a bytestring rather than text?
13:42:15 <kadoban> vozz: Well, what is the file? What encoding is the contents?
13:42:17 <nitrix> f-a: I'd personally recommend you use ranges instead. It'd relax a lot of the pressure put on the dependency checker to find a build path that's compatible.
13:43:22 <geekosaur> vozz, that'd be a start. I'd probably read as bytes (so yes, ByteString) and maintain my own decoder that can be suspended and restarted on partial input
13:43:27 <nitrix> f-a: At the moment, even with the suggested fix of putting transformers==0.5.*, you're loosing previous support of people that were on base 4.8 and transformers 0.4.0
13:43:53 <vozz> The file is utf8
13:44:07 <nitrix> f-a: This is normally more prefereable: https://github.com/nitrix/lspace/blob/master/lspace.cabal#L16
13:44:08 <geekosaur> ...it is likely that pipes or conduit will make it easier to do this
13:44:41 <geekosaur> (insofar as either can be considered "easier" :) but for something like this, handling the decode yourself is decidedly NOT easy)
13:44:50 <Eduard_Munteanu> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
13:44:50 <savrem> Does anyone know if digestFromByteString from the cryptonite library expects a specific string encoding? I have a problem where I'm trying to use this function on a ByteString that I know is an actual sha512 hash, but I always get Nothing back from this function. https://gist.github.com/anonymous/d5e87bcdd1eff5f4c8b3739919a87f33
13:44:53 <f-a> nitrix: thanks! So a >=0.3.0.0 && <0.6 would do?
13:44:57 <hexagoxel> woah, ghci needs ~1GB memory to load my project. that can't be normal.
13:44:58 <Eduard_Munteanu> See "Stream oriented decoding".
13:45:19 <f-a> sorry, meant >=0.4.0.0 && <0.6 would do?
13:45:23 <geekosaur> savrem, it doesn't use an encoding, it expects a raw hash --- not character encoded
13:45:42 <geekosaur> you would need to unhex your hash and feed *that* to it
13:45:58 <nitrix> f-a: Yeah, as a short term solution to support all your base 4.* users (so 4.8 and 4.9) that uses transformers 0.4 and 0.5
13:46:10 <f-a> nitrix: what'd be long term one?
13:46:33 <geekosaur> (encoding is otherwise irrelevant as hex digits are the same in all supported 8-bit encodings)
13:46:55 <vozz> geekosaur: I'm already using conduit, I rewrote conduit's sourceFile function to do some other stuff, but that uses hGetChunk internally
13:47:11 <vozz> So it seems i'd still experience the same problem
13:47:35 <geekosaur> you still want to use it on a raw ByteString (so ghc's decoding doesn't happen)
13:47:48 <Eduard_Munteanu> vozz, make it a ByteString source, then convert
13:48:02 <geekosaur> and have the decode step explicit in your conduit plumbing, which should work because it knows how to suspend and restart around partial data
13:48:02 <nitrix> f-a: Ideally, you'd that the range approach like the example I sent, where you have lower and upper bounds on your dependencies. As the ecosystem evolves, you move up the upper bounds to keep up with them and if you actually end up depending on a recent feature a library added, then you update the lower bound, which might cascades into you changing a couple other lower bounds.
13:48:13 <vozz> I'll give it a go
13:48:39 <f-a> thanks nitrix 
13:49:02 <savrem> geekosaur, makes sense, thank you!
13:50:29 <vozz> Am I right in thinking this hGetChunk is the same one as from Data.Text.IO? https://hackage.haskell.org/package/conduit-combinators-1.0.8.3/docs/src/Data-Conduit-Combinators.html#sourceHandle
13:51:43 <geekosaur> that looks like the wrong link, but probably yes
13:51:54 <geekosaur> so it is doing decoding, strictly
13:52:10 <geekosaur> you need to defer that because you can have partial buffers
13:52:29 <geekosaur> er, partial characters split across buffers, I mean
13:58:25 <Xyliton> Hi! I'm trying to build a parser using Parsec but I'm stuck at correctly modeling my data types because I don't know the exact difference between statements and expressions. Could someone please explain the difference(s) to me? I would really appreciate it!
13:58:53 <vozz> geekosaur: What in conduit converts from Bytestring to Text without blowing up on partial input?
13:59:35 <f-a> Xyliton: can't answer that, but what difference would it make?
13:59:41 <AndreasK> Xyliton: As I understand it: Expressions evaluate to a vaue. Statements are independent things (naked expressions, if statements, loops, assignments and so on)
13:59:46 <f-a> I mean, what would be the problem in your parser
14:00:00 <vozz> ah found it
14:01:14 <Xyliton> f-a: let's take function calls for example. I'll assume that a call looks like this "func(arg1, arg2)". Now this can either work independently or as argument for another function (so I want the return value of func to be the argument for a second function). But, from what I understand, these are two different uses
14:01:56 <Xyliton> so I would need to add them to my statement and expression datatype, AFAIK.
14:02:06 <geekosaur> vozz, should be http://hackage.haskell.org/package/conduit-combinators-1.0.8.3/docs/Data-Conduit-Combinators.html#v:decodeUtf8
14:02:20 <Xyliton> but now I don't know the difference between both so I don't know what else should go into them
14:02:20 <geekosaur> the conduit itself should handle partial input to this
14:02:29 <f-a> ahhh so it's not parsec related, I see
14:02:33 <AndreasK> Do you already have a grammar?
14:03:08 <Xyliton> tbh, not really
14:06:00 <Xyliton> http://lpaste.net/999908931000074240 this is an example for defining functions ("<name> <args>, where "..." means vararg). Then there's assigning (arguments contains a list with all the varargs) which is then concat'ed together with " "'s and printed to the screen.
14:06:30 <Xyliton> I don't have to worry too much about how the language itself is implemented though because I intend to translate from my custom grammar to Lua
14:06:50 <vozz> geekosaur: thanks, all sorted, now to test whether it works :)
14:06:54 <AndreasK> Unless you already have a good idea what the result should look like it might be easier to create a grammar first
14:07:07 <geekosaur> Xyliton, tbh this is a question of designing a grammar more than anything else. a statement is usually distinct from an expression, but in a grammar for C ``` statement ::= expr ';' ''' is a production
14:08:14 <geekosaur> (but can introduce conflicts unless the language/grammar design is thought out properly)
14:08:49 <Xyliton> geekosaur: Another example: how does "if" work in Haskell? And what is it classified as? I know that it can be "standalone", but you can use it as, I think, expression too
14:09:06 <geekosaur> parser libraries can't really help you with the "this grammar is self-inconsistent" problem :)
14:09:13 <geekosaur> it's an expression
14:09:19 <Xyliton> both times?
14:09:20 <Social-Reject> why are there more people in haskell channel than javascript
14:09:21 <Social-Reject> :p
14:09:24 <geekosaur> Haskell doesn't really have statements
14:09:30 <Hafydd> What do you mean by "standalone"?
14:09:44 <geekosaur> "do" looks like it has statements, but it turns into an expression.
14:10:16 <EvanR> Social-Reject: explainable, javascript people are moving to slack
14:13:33 <monochrom> Haskell works by not having "statement".
14:13:33 <geekosaur> so in Haskell "if" is always an expression
14:13:33 <monochrom> My sentence is an oversimplification. When you point at the do-notation, you have "statement" again. Even ignoring that, Haskell still draws a line between "expression" and "declaration", you still have two tiers.
14:13:33 <geekosaur> this is also true of Lisps, Schemes, and other ML family languages. in Algol family languages (C, Java, ...) there is statement-if and may be a separate expression-if (which may not use the same syntax, compare C ?: ternary)
14:13:49 <Xyliton> I'm confused ;-;
14:14:07 <geekosaur> (um, slight unclearness there, Lisp and Scheme are not ML family. Haskell is ML family along with SML, OCaml, etc.)
14:14:15 <grantwu> Is there a monoid instance for Maybe?
14:14:25 <Eduard_Munteanu> You could come up with an abstraction which if-statement desugars to, e.g. continuations.
14:14:41 <lyxia> grantwu: yes
14:14:44 <Tuplanolla> Yes and `Alternative` too, grantwu.
14:14:54 <geekosaur> Xyliton, that was slightly deliberate. this is design on a completely different level from parsers :)
14:15:29 <geekosaur> and, I don't think anyone here can actually help you with your problem because the only thing we know about your language is the one small part you showed us
14:15:32 <grantwu> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html i... Can't really find it
14:15:56 <Tuplanolla> The one with lots of documentation, grantwu.
14:16:13 <grantwu> All I see is the line about lifting a semigroup
14:16:13 <geekosaur> grantwu, looks pretty clearly there to me (and what Tuplanolla said)
14:16:33 <monochrom> I tell you what I honestly think. Questions like "statement vs expression" are red herring pseudoquestions. You may as well be asking "in the C standard what is going on with primary-expression vs postfix-expression?" These questions are asking about symptoms not causes. You should spend time gaining experience from designing your own grammars and studying other people's grammars. Then you will know what's going on.
14:16:34 <grantwu> But I don't have a semigroup
14:16:55 <grantwu> At least, I don't think I do
14:17:03 <geekosaur> yes, the comment is a bit out of date and fairly CS-wonkish.
14:17:27 <lyxia> is it out of data
14:17:27 <grantwu> Oh, I missed the last line
14:17:33 <lyxia> date
14:17:44 <geekosaur> as of 8.0.1 Semigroup is in base
14:18:02 <geekosaur> although realigning mappend might not have happened yet, I guess
14:18:12 <lyxia> Right
14:18:16 <grantwu> Is there an easy way to get the first Just out of a [Maybe a] ?
14:18:29 <lyxia> asum
14:18:32 <grantwu> I mean, a fold can do it
14:19:25 <lyxia> grantwu: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:asum
14:19:40 <geekosaur> Xyliton, monochrom's remark has a lot of truth to it
14:19:53 <grantwu> I see, thanks
14:20:30 <grantwu> I did an interview in Haskell today and said "I'm sure there's a better way of doing this but I don't want to Hoogle right now"
14:20:42 <geekosaur> we can't really help you with your question because you need to sort out how your language works. you probably want to examine existing languages' grammars (not necessarily parsers!) to get some idea of what works
14:21:20 <grantwu> Now that I think about it, does Hoogle know to generalize based on typeclass constraints?
14:21:31 <geekosaur> it's supposed to
14:21:37 <geekosaur> not sure it works currently
14:21:38 <grantwu> Hrm let me try
14:22:39 <grantwu> Oh hey it did find asum
14:23:30 <Xyliton> okay, thanks :)
14:29:00 <nitrix> > getFirst $ foldMap First [Nothing, Just 42, Nothing] -- grantwu
14:29:03 <lambdabot>  Just 42
14:30:37 <grantwu> Wait, what are getFirst and First?
14:31:24 <nitrix> grantwu: foldMap lets you fold a foldable whose values are monoids. `First a`, which is wrapper around `Maybe a`, is such monoid.
14:31:54 <nitrix> newtype First a = First { getFirst :: Maybe a }
14:33:21 <nitrix> grantwu: Have you seen monoids yet?
14:34:00 <grantwu> Where is First defined?
14:34:02 <Social-Reject> is learning C# and Haskell at same time suicide
14:34:21 <monochrom> probably in Data.Monoid
14:34:32 <Tuplanolla> Why would it be, Social-Reject?
14:34:55 <grantwu> Huh
14:35:05 <Social-Reject> I don`t know.. I know JavaScript, and I want to expand. But I like to learn proper OOP and with Haskell proper functional
14:35:36 <monochrom> Social-Reject, this is a first-world problem, and first-world problems are not suicide.
14:35:49 <Tuplanolla> That's fine, but you're not going to find "proper oop" with C#, Social-Reject.
14:36:19 <Social-Reject> Meaning not prototypal OOP
14:36:27 <Social-Reject> when I said 'proper oop'
14:36:32 <nitrix> grantwu: I can walk you through any clarifications you may need. Monoids are fairly important.
14:36:55 <geekosaur> um. whose "proper OOP"?
14:37:00 <grantwu> I know what a monoid is, mathematically.  I haven't looked into Data
14:37:04 <grantwu> Err, Data
14:37:30 <grantwu> Data.Monoid.  . key is next to enter on this phone keyboard.
14:37:49 <nitrix> That's dedication :)
14:38:05 <monochrom> No, "Data.Monoid" is a name. Do not cut it into "Data" and "Monoid" and deconstructivist it.
14:40:03 * geekosaur has folding keyboard... those on screen things are for the birds (maybe they'd work better if I had a beak?(
14:40:03 <nitrix> (.) :: Module -> Module -> Module
14:40:03 <grantwu> ????
14:40:03 <monochrom> the module name is "Data.Monoid", all of it.
14:40:03 <grantwu> I know that.
14:40:03 <monochrom> Ah I see now. Sorry, nevermind.
14:40:03 <monochrom> Find its haddock page, you may find First there.
14:40:03 <Eduard_Munteanu> Would be nice to have composable modules, tho. ;)
14:40:03 <grantwu> Yeah, I see it is there now.
14:40:03 <nitrix> There's a `Last` as well, the dual of `First`.
14:41:38 <grantwu> Reading the source proved to be instructive
14:42:05 <Eduard_Munteanu> geekosaur, 'saurs are now known to have evolved into birds
14:42:23 <geekosaur> sure, I only need a couple million years to get there :p
14:42:47 <Eduard_Munteanu> And a disaster. :)
14:43:31 <monochrom> No, be a snake, stick out your tongue to hit a key, quickly retract so no one saw you doing it.
14:44:06 <monochrom> A frog also does that too, but this time to evade detection by flying insects.
14:44:28 <monochrom> I do have an Ikea frog and an Ikea snake.
14:46:27 <monochrom> Oh lately I have also acquired an Ikea rooster. Now I have a beak too.
14:49:09 <grantwu> Is there a good explanation of applicative that people recommend?
14:49:30 <grantwu> I'm trying to read the original paper and its examples seem... Unmotivated to me
14:49:34 <monochrom> I am planning on writing one.
14:56:50 <Eduard_Munteanu> grantwu, maybe this? https://en.wikibooks.org/wiki/Haskell/Applicative_functors
14:57:30 <Eduard_Munteanu> I remember wikibooks being quite useful on a few topics.
15:04:08 <AndreasK> what about using catMaybes for the list of maybes? listToMaybe . catMaybes if you don't want to use head
15:06:41 <nitrix> Then it'd work only on lists instead of all foldables, but it's fine too.
15:09:43 <nitrix> grantwu: Do you understand Functors?
15:11:27 <nitrix> Functor f => (a -> b) -> f a -> f b
15:11:29 <nitrix> Functor f => f (a -> b) -> f a -> f b
15:11:37 <nitrix> grantwu: Can you spot the difference :) ?
15:11:54 <grantwu> Yes
15:12:20 <grantwu> The first one is fmap, the second is... Weird, the function is inside the functor
15:12:44 <grantwu> The first parameter rather
15:12:57 <EvanR> the second one is equivalent in a way to Functor f => f a -> f b -> f (a,b)
15:13:01 <nitrix> The only difference is that the function transformation of type `a -> b` that's meant to me applied to your functor value `f a` to obtains `f b`, well it's now in a functor as well.
15:13:23 <nitrix> Thus, you can see where the name comes from, Applicative Functor, a functor that can be applied.
15:13:47 <EvanR> another word for this is monoidal functor
15:14:15 <grantwu> Sorry y'all I have another obligation right now so
15:14:30 <grantwu> I'll be back I guess
15:15:13 <nitrix> I hope my condensed explanation didn't scare them away :<
15:15:30 <grantwu> Lol please
15:15:39 <nitrix> I'm always hesitant to give it in that form, but it's really the most straight forward explanation imo.
15:17:19 <grantwu> It makes sense but i haven't connected it to any of the things I know are instances of alternative... But I g2g
15:17:19 <nitrix> > (+1) <$> Just 42
15:17:21 <lambdabot>  Just 43
15:17:24 <nitrix> > Just (+1) <*> Just 42
15:17:26 <lambdabot>  Just 43
15:17:50 <nitrix> grantwu: Here are two examples to work with. I'll be glad to help when you're back :)
15:18:09 <Strikingwolf> And for a better use case of `<*>`
15:18:21 <Strikingwolf> > Just (+) <*> Just 3 <*> Just 42
15:18:23 <lambdabot>  Just 45
15:19:35 <EvanR> liftA2 (+) (Just 3) (Just 42)
15:21:10 <nitrix> No no no, where did all the nice infix go D:
15:21:27 <nitrix> (+) <$> Just 3 <*> Just 42
15:21:43 <Strikingwolf> Yeah that's the best way to write it
15:22:00 <Strikingwolf> but it's easier to see how `Just (+) <*> Just 3 <*> Just 42` works on first grok
15:22:13 <monochrom> clearly, the best way is let (+++) = liftA2 (+) in Just 3 +++ Just 42
15:25:04 <Shou>  I wish there was an (<*>) argument application operator without the Applicative in base, i.e. infixl ($), so you could do the same there: (+) -$ 2 -$ 2.
15:29:38 <nitrix> > (+) & ($2) & ($2)
15:29:39 <MarcelineVQ> (+) is left associative
15:29:41 <lambdabot>  4
15:31:14 <nitrix> Love these dollar signs. Getting closer to PHP here.
15:37:23 <nitrix> I have a question.
15:39:21 <Strikingwolf> mmhmm nitrix?
15:39:54 <nitrix> ($) seems isomorphic to (($) ($) ($)). I can do `(+1) $ 0` but not (+1) (($) ($) ($)) 0. Is there any way to make it infix? Backticks doesn't seem to help.
15:40:48 <c_wraith> only by assigning it a name. 
15:40:49 <monochrom> backticks don't support using arbitrary expressions
15:41:06 <c_wraith> identifiers can be made infix, not expressions. 
15:41:23 <monochrom> eh? let me check again
15:41:23 <nitrix> That's an interesting limitation.
15:41:33 <Strikingwolf> I think you can use expressions
15:41:36 <Strikingwolf> but it takes an extension
15:41:41 <monochrom> > Just 4 `liftA2 (+)` Just 5
15:41:44 <lambdabot>  <hint>:1:16: error: parse error on input ‘(’
15:42:24 <monochrom> > Just 4 `liftA2 mod` Just 5
15:42:26 <lambdabot>  <hint>:1:16: error: parse error on input ‘mod’
15:42:42 <c_wraith> > let plus = liftA2 (+) in Just 3 `plus` Just 5
15:42:44 <lambdabot>  Just 8
15:43:17 <nitrix> @let infixr 0 -:, :-; data Infix f y = f :- y; x -:f:- y = x `f` y
15:43:17 <lambdabot>  Parse failed: Parse error in pattern:
15:43:48 <nitrix> I'm reading the wiki, someone came up with a syntax   Just 4 -: liftA2 (+) :- Just 5, intead of backticks.
15:44:09 <MarcelineVQ> someone who didn't enjoy people reading their code
15:44:46 <c_wraith> there's a package on hackage that does that 
15:45:37 <c_wraith> err, nevermind, I was thinking of something else entirely. 
15:46:15 <monochrom> Yes, the -: :- there can be done, and it is why type inference is exponential time.
15:47:23 <monochrom> Chris Okasaki first noticed this in reality when he did something similar, and he was like "I have this 5 lines of code that takes several minutes to compile LOL"
15:59:24 <Jello_Raptor> is there any place I can find the subset of the grammar that's allowed for infix operators 
15:59:33 <nitrix> Is this just a Haskell thing or a real problem of type system design?
15:59:52 <Jello_Raptor> niteria: haskell, I just want to know what ASCII infix operators are valid 
16:00:07 <nitrix> My question was for monochrom.
16:01:07 <Jello_Raptor> I should be in ehre somewhere https://www.haskell.org/onlinereport/lexemes.html
16:16:53 <codedmart> Is there a way to run two separate monad computations while passing the result into the last function: https://gist.github.com/codedmart/a584d47fadc81fe6830720fec8434237
16:17:08 <codedmart> That is probably a horrible example but I am not sure how to word it right.
16:24:08 <c_wraith> codedmart, I'm not sure what exactly you're asking, but that is also expressible as liftA2 threeFunction oneFunction twoFunction
16:24:09 <Rotaerk> codedmart, what about:  main = threeFunction <$> oneFunction <*> twoFunction
16:27:10 <Rotaerk> codedmart, the sequencing can become a concern though if you do that
16:27:33 <codedmart> Rotaerk: OK is it just good practice to keep it with do notation?
16:27:46 <Rotaerk> if threeFunction takes arguments a then b, but you want to run the action to obtain b *before* the action to obtain a, then that won't work I think
16:28:09 <c_wraith> Rotaerk, but it matches the do notation version. 
16:28:35 <Rotaerk> yea
16:29:12 <c_wraith> codedmart, are you concerned with how to write it more expressively, or how to make it run the two actions simultaneously? 
16:30:31 <codedmart> c_wraith: Write it more expressivly.
16:31:35 <c_wraith> then yeah.. if you observe that you want to apply a pure function to the result of several independent actions, it means you can use the Applicative interface 
16:32:22 <codedmart> Thanks guys :)
17:22:40 <moet> is there an IO action to detect whether i'm on the main thread?
17:23:58 <monochrom> I wonder if you will accept the following way:
17:24:41 <monochrom> First, when in the main thread, use myThreadId to obtain its ThreadId, and put it somewhere for all threads to know.
17:24:55 <monochrom> Second, in an arbitrary thread, ask for myThreadId again and compare.
17:25:08 <monochrom> because there is pretty much no other way
17:25:36 <monochrom> oh there is actually a destructive way and requires a very meta trick
17:25:57 <Tuplanolla> I wonder why there isn't a function for that, because the runtime systems knows the main thread.
17:26:38 <Axman6> monochrom: terminate the thread and if the program exists, it was the main thread? =)
17:26:40 <monochrom> hmm, I don't know how to finish the very meta trick, so nevermind. it's pretty suicidal anyway.
17:26:47 <monochrom> yeah!
17:27:32 <Axman6> or... fork and then terminate the thread in the new process, and if it terminated, then it was the main thread.. if it keeps on going kill it and now you know
17:27:41 <monochrom> except in case the thread is not the main thread, I wonder how to let the program know "whew! that was close"
17:27:52 <monochrom> Oh, that will work, neat.
17:28:35 <monochrom> Watch the movie "The Prestige" for more information. :)
17:28:41 <geekosaur> er? only the current thread survives a fork
17:29:06 <Axman6> you can't fork multithreaded executables? o.O
17:29:14 <geekosaur> nope
17:29:29 <Axman6> I had no idea!
17:29:38 <geekosaur> moreover I am recalling that ghc's runtime has known infelicities in the interaction between forkIO and forkProcess
17:30:14 <monochrom> Programming is so hard. Let's watch a movie instead. :)
17:30:37 <Axman6> agreed
17:30:38 <geekosaur> the only-current-survives-fork is true for POSIX threads and most non-POSIX thread implementations. runtimes that provide their own thread abstraction can try to evade it, but it would be risky at best because of questions like what to do with thread local storage
17:31:08 <Tuplanolla> What happens to thread-local storage now?
17:31:13 <geekosaur> and synchronization points between threads
17:31:14 <Axman6> moet: I think the answer to your question is sadly no, without doing what monochrom said and keeping track of the ThreadId of the main thread
17:31:36 <monochrom> You should actually write your way out of needing to know at all.
17:31:43 <geekosaur> Tuplanolla, what happens now is they're lost along with the threads that held them; only the current thread survives forkProcess, and becomes the main thread of the new process
17:31:52 <geekosaur> threads and processes do not mix
17:32:11 <monochrom> Structure your program so the main thread doesn't do anything except initing and waiting for other threads to finish. Do all real work on non-main threads.
17:32:15 <geekosaur> and this is enforced by the OS, not the language runtime
17:32:32 <monochrom> Then the answer to "am I the main thread?" is simply always "no".
17:33:11 <monochrom> s/work on/work in/
17:34:43 <isd> Hi all. Is there a module out there that defines an instance of QuickCheck's Arbitrary for Data.Text?
17:35:31 <geekosaur> "forkProcess comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent."
17:36:55 <geekosaur> isd, http://hackage.haskell.org/package/quickcheck-instances-0.3.12/docs/Test-QuickCheck-Instances.html
17:38:19 <MarcelineVQ> chances are the instance is just   pack <$> arbitrary   as well if you just need the one
17:41:15 <isd> geekosaur: thanks
17:43:09 <isd> MarcelineVQ: good point; that would certainly do it.
17:47:53 <moet> monochrom: it's a glfw requiredment that certain functions be run on the main thread
17:47:57 <moet> so i can't write my way out of it
17:48:03 <moet> Axman6: thanks anyway! :)
17:48:43 * nshepperd finally finished aoc #22 \o/
17:49:10 <nshepperd> but my code is now an utter mishmash after trying many things and strewing traceShow everywhere
17:49:27 <monochrom> I am not convinced that you aren't modifying "has to pick one bound thread and stick to it" to "has to be the main thread".
17:49:50 <Axman6> OpenGL tends to be picky about where things run
17:50:07 <monochrom> But either way a solution is to do the dual of what I said. Do all the work in the main thread.
17:50:43 <Tyg13> is anyone here familiar with hscurses?
17:51:13 <geekosaur> monochrom, opengl does indeed have this restriction
17:51:19 <monochrom> Here is how. The main thread is just a loop waiting for messages. "Message" contains a glfw command issued by other threads. main's job is to receive such commands and execute them.
17:51:22 <geekosaur> so does X11 for that matter (even xcb)
17:51:31 <Tyg13> Or would maybe know why a curses window would become unresponsive when using Curses.getCh?
17:51:39 <geekosaur> X11 might be fakeable, opengl is known not to be
17:51:53 <Axman6> yeah, just run a loop over a Chan (IO ()) in the main thread
17:52:04 <geekosaur> Tyg13, define unresponsive
17:52:22 <Tyg13> It's not that it doesn't output, just that when I mouse-over it gives me the loading cursor
17:52:25 <monochrom> Let me be more precise. main's job is to wait for messages from other threads and call glfw based on the messages received.
17:52:35 <monochrom> All other threads just message to the main thread.
17:52:43 <monochrom> gtk2hs does this.
17:53:03 <geekosaur> Tyg13, curses knows nothing of cursors, that will be something about your terminal emulator
17:53:14 <Tyg13> And it only registers my input when I type into the terminal, not the actual curses window
17:53:14 <geekosaur> text UIs don't know anything about GUI components
17:53:27 <geekosaur> uhhhhh
17:53:35 <Tyg13> I'm on windows if that helps
17:53:36 <Tyg13> pdcurses
17:53:37 <monochrom> It even has "postAsync" vs "postSync". "postSync" just means after you send your message you wait for main's reply. THE END.
17:53:56 <Tyg13> What you said otherwise makes sense to me, I'll have to look into that
17:54:07 <geekosaur> I think your problem is likely to be with pdcurses, or how you are using it
17:54:49 <lpaste> xcmw pasted “Suggestions for improvement?” at http://lpaste.net/350370
17:54:56 <Tyg13> I'm tempted to say screw it to the whole curses on windows idea
17:55:09 <geekosaur> that might be smart. it's known to be tricky at best
17:55:34 <Axman6> do any of the other curses libraries work? there's vty, which seems pretty nice (this IRC client is built using it)
17:55:37 <Tyg13> Is there any other way to do something similar, maybe with SDL? All I wanted was to make a roguelike
17:55:45 <Tyg13> Vty only works in cygwin on windows, apparently
17:56:20 <geekosaur> terminal abstractions on windows are weird
17:56:42 <Tuplanolla> Take a look at how DCSS does it, Tyg13.
17:56:51 <Tuplanolla> (Hint: it's a mess.)
17:57:35 <Tyg13> hehe
17:57:36 <geekosaur> DCSS local tiles is SDL2 (hackily converted from SDL1; I don't recommend paying close attention to its code...)
17:58:01 <Tyg13> I've also mucked about with SDL2 in haskell, though the port seems poorly done
17:58:11 <Tuplanolla> I was referring to the text mode.
17:59:28 <geekosaur> re pdcurses, if you are using a mingw/msys/cygwin terminal instead of a native one, it will probably behave oddly because it wants a native terminal (cmd.exe or some replacements/alternatives)
18:00:05 <Tyg13> I have been using cmd.exe, but I'll try cygwin just for kicks
18:00:06 <geekosaur> the other kind of terminal is actually using a named pipe, and pdcurses probably doesn't even know about it and goes straight to the console APIs which would use the original terminal window
18:00:21 <geekosaur> ummm
18:00:32 <geekosaur> you said [23 01:52:51] <Tyg13> And it only registers my input when I type into the terminal, not the actual curses window
18:00:39 <geekosaur> this does not sound like you are in cmd.exe
18:00:54 <geekosaur> unless you launched a second one, but that would not be reading input from the original window
18:01:09 <Tyg13> Whenever I run the .exe it launches a separate cmd window alongside the curses window
18:01:17 <Tyg13> where I can actually type into
18:02:02 <Tyg13> it's real weird
18:04:13 <lordcirth> Tyg13, btw, I am making a roguelike in Haskell with Brick
18:04:32 <Tyg13> Oh? Maybe I'll look into that
18:05:04 <Tyg13> Do you know if it has Windows support?
18:05:15 <geekosaur> brick is the current name of vty-ui, so you'd need cygwin if what you said earlier was correct
18:05:25 <Tyg13> aw
18:06:04 <MarcelineVQ> Lokathor is also making similar things using his own ncurses lib he's working on (I think) and windows, ask him about it if he's around
18:06:09 <lordcirth> Wouldn't Ubuntu on Windows work too?
18:06:17 <lordcirth> If Win10
18:06:47 <Tyg13> Not too sure, I tried looking into it but I wanted to see if a native solution was possible first
18:06:51 <geekosaur> did they fix any of the bugs yet? some of them involved terminal ioctl calls which would break curses
18:07:50 <Tyg13> The demos that came with pdcurses work just fine, there's something weird about hscurses I think
18:42:29 <xcmw> Any suggestions? http://lpaste.net/350370
18:57:32 <xcmw> Any suggestions? http://lpaste.net/350370
19:07:55 <emmanuel_erc> Hello there everyone!
19:08:45 <vozz> Hello!
19:09:07 <emmanuel_erc> I've got a question about the package "inline-java"
19:09:51 <emmanuel_erc> I am trying to install a haskell package called "inline-java". I downloaded the library from github and the installation instructions include the command "stack --nix -stack-yaml --stack-HEAD.yaml build" and  I get a particularly strange error.
19:10:05 <vozz> Are you using nixos?
19:10:14 <emmanuel_erc> I am  not. I am using archlinux
19:10:16 <vozz> or do you know what nix is and are using it?
19:10:23 <vozz> then remove the --nix part of the command
19:10:27 <emmanuel_erc> oh ok
19:10:30 <xcmw> Do you have nix install?
19:10:40 <xcmw> You can use it without nix os
19:10:49 <emmanuel_erc> I have the nix package manager installed
19:10:55 <xcmw> But try it without nix first
19:10:56 <vozz> ah
19:11:03 <emmanuel_erc> I tried the same command without nix and I get the exact same error message
19:11:11 <vozz> what's the error?
19:11:24 <emmanuel_erc> error: setting synchronous mode: disk I/O error
19:11:51 <Lokathor> MarcelineVQ, what?
19:14:00 <xcmw> emmanuel_erc: Make a bug report on github
19:14:04 <vozz> hm...
19:14:09 <vozz> how much disk space do you have? :)
19:15:16 <geekosaur> better question might be, what filesystem is /tmp on
19:15:42 <geekosaur> er, filesystem tyoe
19:15:42 <emmanuel_erc> "/tmp " is under the sda2 partition 
19:15:44 <geekosaur> type
19:16:07 <geekosaur> and with what mount options
19:16:19 <emmanuel_erc> How do I find that out?
19:16:20 <geekosaur> mount | grep /tmp
19:16:42 <emmanuel_erc> I get "tmpfs on /tmp type tmpfs (rw,nosuid,nodev)"
19:18:06 <emmanuel_erc> on that partition, sda2, I only have 1.2G left out of 20G.
19:18:14 <emmanuel_erc> could be that be the issue?
19:18:21 <geekosaur> that shouldn't matter, it's setting it synchronous that it's complaining about
19:18:44 <geekosaur> but that error message doesn't tell me how it's doing so, so... think you open a ticket on fpco/stack
19:19:06 <emmanuel_erc> ok thanks
19:19:25 <geekosaur> space on sda2 is not relevant, you are using tmpfs according to mount
19:19:41 <geekosaur> (if that is not actually true then you have even bigger problems...)
19:19:54 <geekosaur> tmpfs = spare memory, backed by swap
19:20:43 <emmanuel_erc> gotcha
19:21:33 <geekosaur> I'm seeing complaints about older kernels not supporting O_DIRECT opens on tmpfs, but that seems inconsistent with "setting synchronous mode" which sounds like fcntl(O_SYNC) or one of its cousins to me
19:23:07 <emmanuel_erc> I think it might be a space issue. I just tried reinstalling it with just the command "stack build", and the nix package manager is download quite a bit of packages to the the folder "/"
19:24:11 <geekosaur> that would be a weird error to get due to space though
19:24:18 <emmanuel_erc> I actually need the nix package manager to install inline java (it is part of the build I am pretty sure)
19:28:08 <emmanuel_erc> yeah it is, when I rerun "stack build" (without making any changes), I get an unsurprising error message "error: writing to file: No space left on device"
19:28:35 <geekosaur> huh. lousy way to report it
19:28:52 <c_wraith> I'm sure that you do need java to build against - at least the jni header files
19:29:21 <emmanuel_erc> c_wraith: I have everything that I need, except a big enough root partition.
19:29:34 <emmanuel_erc> Ithink
19:29:42 <geekosaur> the other thing is figuring out which filesystem it is talking about, tmpfs would mean you used up swap, but it could be talking about the filesystem ~/.stack-work is in
19:29:58 <geekosaur> or whatever filesystem(s) nix is using
19:30:01 <emmanuel_erc> right
19:30:19 <Tyg13> why would I be able to stack build and run the binary fine but stack ghci doesn't work?
19:30:38 <emmanuel_erc> Thanks for the input geekosaur!
19:30:44 <Tyg13> it says ghc.EXE unable to load package hscurses-1.4.2.0 
19:31:11 <glguy> Tyg13: Because you didn't install hscurses into your global or user package repository
19:31:36 <glguy> or you're running the command from a different directory perhaps?
19:31:42 <Tyg13> so I need to run stack install hscurses outside of my working directory?
19:31:53 <Tyg13> I'm in my project folder right now, so it should work
19:31:57 <c_wraith> or not running ghci with stack..
19:32:08 <glguy> the user/global comment was before I noticed that you said "stack ghci"
19:32:21 <Tyg13> I was having issues compiling hscurses with the conflicting globally install ghci
19:32:46 <geekosaur> there's also some oddness with native vs. mingw/msys/whatever dlls, iirc
19:32:50 <Tyg13> yeah
19:33:56 <Tyg13> even when I install it globally, it doesn't work
19:35:10 <Tyg13> oh I see now
19:35:20 <Tyg13> unknown symbol getch
19:42:04 <Lokathor> Tyg13, roguelike you say?
19:49:09 <xcmw> Any suggestions? http://lpaste.net/350370
19:53:40 <pavonia> Suggestions concerning what?
19:54:28 <xcmw> pavonia: Any way to make it better?
19:57:25 <xcmw> Or polykinded
20:00:37 <Tyg13> Lokathor, indeed
20:00:41 <Lokathor> do tell
20:01:07 <Tyg13> I've been trying to make one using hscurses on windows, but efforts have proven fruitless
20:01:16 <Lokathor> oh i'm sorry, in haskell we can leave off the "do" if there's just one function call
20:01:19 <Lokathor> tell
20:01:29 <Lokathor> :3c
20:01:40 <Tyg13> lol
20:02:09 <Lokathor> Tyg13, if you're using cygwin you can make direct curses calls via inline-c
20:02:47 <Tyg13> so I could call all of pdcurses natively from the dll?
20:02:54 <Lokathor> uh
20:02:58 <Lokathor> ...kinda
20:03:13 <Tyg13> how does inline-c work?
20:03:34 <Lokathor> TemplateHaskell magic lets you shove C blocks into IO actions
20:03:39 <Eduard_Munteanu> Actually, you can even use 'do' in a non-monadic context if it';s just an expression.
20:03:51 <Lokathor> and the template magic turns that into a .c file with the correct stub funcitons and the IO actions become the correct FFI calls
20:04:06 <Eduard_Munteanu> > do { 1 + 1 }
20:04:08 <lambdabot>  2
20:04:26 <Lokathor> Tyg13, your code ends up looking like things like this, https://github.com/Lokathor/fullainth/blob/master/lib/UI/Curses.hs#L160
20:05:06 <Lokathor> the problem that I was having with fullainth that i was not able to solve was that the program crashed instantly (but cleanly) when the user resized the window :P
20:05:23 <Tyg13> are you on windows?
20:05:39 <Lokathor> i was on windows, accesing debian via ssh
20:05:46 <Lokathor> i think it's just that signal handlers don't move across the FFI bounds cleanly
20:05:46 <Tyg13> ah
20:06:24 <Lokathor> now here's a thing though: https://github.com/Lokathor/galaxy-break/blob/master/lib/Control/Console/Win32.hs#L50
20:06:58 <Lokathor> if you set the windows terminal into the right mode you can just read 1 char at a time, and you could just display the game by printing 24 lines that are each up to 80 chars
20:07:03 <Lokathor> and have a "curses-like" result
20:07:12 <Tyg13> wow
20:07:46 <Tyg13> What's the point of the inline c though?
20:07:53 <Lokathor> i'm just delving into this particular thing myself, and i have to refine what i have so far before i'd start to build up a game around it, but thigns seems promising
20:08:07 <Tyg13> is it just to facilitate calling curcses?
20:08:08 <Tyg13> curses*
20:08:29 <Lokathor> well, in this case here with window, to set the console into the correct mode to read a character you must make calls to windows.h functions
20:08:41 <Lokathor> and the Win32 haskell package is woefully incomplete
20:08:55 <Tyg13> yeah windows haskell anything is nonexistent I've found
20:09:01 <Tyg13> almost
20:09:30 <Lokathor> we walk a lonely road
20:09:38 <Tyg13> so it automatically translates the c calls into haskell code and does the ffi declarations, that's neat
20:10:06 <Lokathor> though, as i said, readOneChar :: IO Char, isn't entirely helpful. For example, you can't read arrow keys this way
20:10:32 <Lokathor> so i need to expand it out a bit to incorporate VK_* codes
20:10:41 <Tyg13> is that a limitation of Win32?
20:10:46 <Tyg13> the package, at least
20:10:57 <Lokathor> no it's a limitation of my own use of their struct
20:11:18 <Tyg13> oh I see
20:11:19 <Lokathor> inrec.Event.KeyEvent.uChar.AsciiChar will only ever be a printable character, and other fields are holding data about things like arrow keys
20:11:23 <Tyg13> yeah
20:11:35 <Tyg13> I have to say this is pretty damn cool
20:11:40 <Lokathor> so i just need to improve my own code, and then return a signal value of some sort, and then wrap that up into a sum type
20:11:53 <Tyg13> it makes me feel almost gross to write C in haskell, but it definitely looks like it would work
20:12:05 <Lokathor> data KeyPress = ArrowUp | ArrowDown | ... | AsciiKey Char ...
20:12:16 <Tyg13> yeah that's what the hscurses guy did
20:12:20 <Tyg13> almost exactly
20:12:30 <Lokathor> it's a good way to encode that sort of thing
20:12:44 <Lokathor> right now i want it for a command line based game
20:13:11 <Tyg13> that's how I've been trying to teach myself haskell
20:13:27 <Tyg13> the curses hurdle has been a major issue in that journey
20:14:03 <Lokathor> but i also want to be able to support tab complete, command history, and most importantly: I want to support printing without trashing a buffered partial command
20:14:22 <Lokathor> so i need to juggle a few things, but i think it'll be cool
20:14:35 <Tyg13> sounds ambitious, but doable
20:15:11 <Lokathor> also been trying Handmade Hero in Haskell with SDL
20:15:15 <Lokathor> and a roguelike in rust
20:15:20 <Lokathor> scatterbrained
20:15:27 <Tyg13> ha
20:15:58 <Tyg13> I've got a half-working cocos2d python project, and some rust stuff too
20:16:10 <Tyg13> rust definitely looks like it's going to be big soon
20:16:40 <Lokathor> as a person who doesn't know C or C++, I can't imagine ever bothering to learn them at this point with rust out
20:16:55 <Tyg13> legacy stuff
20:17:26 <Lokathor> I'll make an FFI call if I have to, but I don't program as a job so I don't have to support legacy things myself
20:17:49 <Tyg13> oh, you meant you don't know c or c++?
20:18:18 <sm> Tyg13, Lokathor: any chance you would like to finish porting vty to windows ? I believe there's a prototype
20:18:48 <Tyg13> do you mean vty natively on windows, sans cygwin?
20:18:49 <Lokathor> I read the C book one time, and Handmade Hero is done in C/C++, but I don't know anything about them that you wouldn't know from knowing JAva
20:18:56 <sm> yes
20:19:04 <Tyg13> where is such a prototype?
20:19:33 <Lokathor> sm, will vty ever let me just write a character to a cell on the screen and stay out of my way? That was my complaint about vty when i did use it on unix
20:19:38 <sm> Tyg13: https://github.com/jtdaugherty/vty/pull/1#issuecomment-246939093
20:20:04 <sm> Lokathor: I don't understand, but I'm guessing yes
20:20:31 <Tyg13> I wish I had the expertise to figure something like vty out
20:20:39 <Tyg13> though it's certainly ambitious
20:20:56 <sm> Tyg13: or, the commits above that comment
20:21:46 <Tyg13> you mean those commits worked but never got merged?
20:21:48 <Lokathor> sm, so how do i actually test this? I really don't know how to interact with a... pullrequest review page? or whatever sort of page this is
20:22:16 <sm> Tyg13: I only know what I've read here, probably the next step is to test this stuff
20:22:28 <sm> it looks like there are three different attempts
20:22:32 <Lokathor> well i can see if it builds at least
20:22:58 <Lokathor> like, do all these people not own even one windows computer with stack on it?
20:23:02 <sm> oh, two attempts. coreyoconnor's WIP and pavonia's thing
20:23:03 <Lokathor> what sort of strange place Europe must be
20:23:51 <sm> stack was not established, at least not among the vty devs
20:23:55 <jophish> Is there some kind of type level 'lift'?
20:24:03 <jophish> Proxy a -> Type
20:24:07 <jophish> or Q Type, I don't mind
20:24:24 <Lokathor> sm, or cabal, or haskell platform, but i mean.. do i just have to download a zip and see if it compiles?
20:24:29 <sm> and jt daugherty who is current maintainer was avoiding it
20:24:31 <Lokathor> because i can do that
20:24:37 <pavonia> That reminds me, there are still pending pull requests :<
20:24:49 <sm> oh there's pavonia, +1 :)
20:25:09 <roboguy`> jophish: what would that do? Haskell doesn't allow types at the value level
20:25:25 <roboguy`> well, not like that anyway
20:25:29 <sm> Lokathor: in this case, you would 1. check out that git branch 2. figure out deps to get it building - probably we can help
20:26:23 <Tyg13> https://github.com/pavonia/Win32-console
20:26:32 <jophish> roboguy`: as in Language.Haskell.TH.Type
20:27:00 <sm> pavonia's thing is win-specific, right ? I would rather have coreyoconnor's thing
20:27:09 <jophish> in the same way that `lift` lifts terms to template haskell Exps, this would lift types totemplate haskell's `Type`
20:27:36 <pavonia> Yes, Win32-console is a raw Win32 API binding
20:27:50 <jophish> not a huge pain to write for what I need.
20:29:00 <Tyg13> how versatile is the win32 console api?
20:29:09 <Lokathor> Tyg13, shockingly
20:29:17 <Lokathor> for being just a console, and all
20:29:29 <Tyg13> is there a disconnect between console and terminal?
20:29:39 <jophish> I suppose `TypeRep -> Q Type` would be most flexible
20:30:05 <Lokathor> the console is the entire window that the stdin and stdout are within, so the console event loop gets events for window-resizes and mouse stuff and things in addition to pure text events
20:31:47 <Tyg13> I definitely need to look into this win32 api, thanks pavonia
20:32:00 <Tyg13> and thanks sm, as well
20:32:06 <Lokathor> Tyg13, note that what I just said is based on my reading of the MSDN pages
20:32:08 <sm> np Tyg13 
20:32:11 <Tyg13> and lokathor too, why not
20:32:21 <Lokathor> and not all of that will necessarily be there within the haskell FFI library
20:32:47 <Tyg13> Is there any way I could try to extend the library myself?
20:33:09 <Lokathor> yeah, i mean you can just write more FFI things and call them, they don't have to be specifically in that library
20:33:23 <Tyg13> I didn't think FFI would be such a big part of haskell, tbh
20:33:37 <Lokathor> well for IO systems, you basically have to talk to C
20:33:54 <Lokathor> sm, I can check about vty on windows on the weekend perhaps, but tonight is for other programming things
20:34:16 <Tyg13> I still have not managed to be productive all day because of issues with curses
20:35:43 <sm> just imagine stack install vty working on windows.. instant console GUI goodness! :)
20:36:05 <sm> Lokathor: cool, shout if you find out anything
20:36:19 <Lokathor> sm, what i meant earlier about "just write a character to where i want" is that in vty it is shockingly hard to actually just get an @ on the screen moving around.
20:36:36 <sm> really ?
20:36:51 <Lokathor> Like, I read the documentation for over 10 minutes and couldn't figure what they thought I should be doing to get that happening
20:36:57 <sm> ansi-terminal is probably enough for that
20:37:10 <Lokathor> but ansi-terminal doesn't do the input part
20:37:29 <sm> ok, then what about going up a level and using brick
20:38:16 <Lokathor> it goes like this: I want curses to make an @ walk around. I try curses, people talk about vty or brick when i ask a question, vty and brick don't seem to support an @ moving around, then people say "oh what you want is too easy for those libs", and it circles back around :P
20:38:42 <sm> sorry :)
20:38:51 <Lokathor> no, i'm laughing about it
20:38:59 <Lokathor> but this is like the 7th time this has happened in #haskell
20:39:09 <sm> I don't really believe vty or brick don't support that
20:39:24 <Lokathor> right, i'm sure they do, but it's not explained *how* they do easily
20:39:44 <Lokathor> everything is in terms of these abstract picture things, and like, putting things next to things, and stuff
20:40:13 <sm> I just tend to push vty when curses comes up because I always found it easier to get going than curses
20:40:36 <Tyg13> it's simple, a monad is just a monoid in the category of endofunctors, duh!
20:40:45 <Lokathor> i just want to show a string and get my input back and not have it crash in between. VTY does step 2 and 3, but not step 1. Curses is steps 1 and 2 but not 3
20:41:06 <Lokathor> ah well, time to control console access via an MVar
20:41:33 <Lokathor> oh hay, you can install stack on rpi3 now
20:41:42 <sm> it's a higher level api to the console I guess. Maybe someone needs to write a low-level grid-of-characters api for it
20:43:02 <Lokathor> what i need to do is get off my butt and make that for SDL
20:43:02 <sm> an Image that fills the screen, I guess
20:43:53 <Lokathor> well it'd be a grid of small portions from a texturemap glued together
20:44:22 <sm> ack you're complicating things again
20:44:56 <sm> never had no texturemaps when I was making ascii super boxing battle
20:45:24 <sm> heh, I should make that again
20:45:24 <Lokathor> well, if they're not a texture map you need 1 file handle per letter you show on the screen
20:45:29 <Lokathor> which is... unfortunate
20:45:43 <sm> what makes you say that ? 
20:46:58 <Lokathor> well that's like 100 file handles
20:47:13 <sm> where do file handles come in ? are you talking about curses ?
20:47:18 <Lokathor> no for SDL
20:47:45 <sm> oh. I'm still in vty-land :)
20:48:17 <Lokathor> i have a nice interface to curses i wrote for haskell that's perfect as long as the user never resizes the window
20:48:21 <Lokathor> so, you know, pretty good
20:48:46 <Lokathor> just dump the program state to a file every time you pause to get more input, and restore from there if they crash you, clearly
20:51:10 <Tyg13> just tell the user that resizing the window is cheating and will not be tolerated
20:51:36 <Lokathor> oh they'll figure it out after a few sudden crashes i'm sure
20:52:11 <Tyg13> ah, but your way, it's a bug, my way, it's a feature
20:53:05 <Tyg13> seriously though, it sounds strange that everything works, except resizing
20:54:11 * sm thinks: update vty $ picForImage $ translate x y $ charFill defAttr '@' 1 1, handles resizing
20:54:41 <Tyg13> vty for windows sounds lovely right about now
20:56:14 <Tyg13> I can't for the life of me understand why hscurses is creating a curses terminal and a regular cmd console every time it initializes
20:56:31 <Lokathor> Tyg13, resizing the terminal sends a Signal to the program, and curses tries to have its handler do the right thing, but also Haskell tries to do its own thing, and then things explode
20:56:51 <Tyg13> it calls initscr the exact same way the c example program does
20:57:19 <Tyg13> lokathor, is there no way to prevent one of the two from getting that Signal?
20:57:51 <Lokathor> no one I asked could solve it, but it's also a realllllly obscure sort of problem across an FFI line, so i don't expect people to just know
20:59:39 <Tyg13> it looks like I'm going to be delving into some FFI fun myself
21:00:25 <Tyg13> maybe I can get pdcurses working on windows without hscurses just by using ffi
21:01:04 <mavihs> Hello everyone, another noob here! I'm looking out for good books on Haskell and I came across *learn you a haskell*. Do you guys have some other recommendation? I'm looking for an equivalent of Well Grounded Rubyist, which explains something end to end. Thanks!
21:01:08 <Tyg13> or not, but it'll be fun failing
21:01:52 <Tyg13> mavihs, I've heard good things about Haskell Programming from First Principles, but it's $60 so take that for what it's worth
21:02:31 <Lokathor> mavihs, http://haskellbook.com/ there is currently no better book for Haskell
21:02:40 <Lokathor> I stand behind it 100%
21:02:45 <mavihs> Interesting. Thanks for sharing, I'll have a look Tyg13 
21:03:10 <mavihs> Thanks Lokathor :)
21:05:11 <mavihs> so apart from the books, are there good playgrounds or challenges which I should be working on simulatenously?
21:05:34 <Lokathor> Haskell Book has a lot of "homework" problems as you go
21:05:50 <Lokathor> CIS194, Spring '13 edition, also has some homeworks
21:07:09 <Lokathor> http://cis.upenn.edu/~cis194/spring13/lectures.html
21:08:26 <mavihs> Awesome, cheers!
21:13:28 <Lokathor> modifyMVar :: MVar [Char] -> ([Char] -> IO ([Char], Maybe String)) -> IO (Maybe String) -- boy howdy
21:20:00 <saurabhn_> any quickcheckers around here? http://stackoverflow.com/questions/41294502/state-machine-based-testing-in-haskell-quickcheck
21:34:11 <Lokathor> my concurrent code doesn't run concurrently
21:34:21 <Lokathor> i think everyone can see why this would be a problem
21:35:18 <athan> Lokathor: did you use -threaded?
21:35:24 <Lokathor> oh mannnn
21:35:46 <athan> wa wa waaaa
21:36:14 <Lokathor> oh gosh, 3x the build time, talk about code bloat, these modern compilers
21:37:51 <buttons840> i'm trying to craw web pages, based on what i find, i need to do some tasks against a database, based on what i find there i might do whois lookups, and based on what i find there i might start crawling other pages -- any suggestions for a tasks queue like library to help coordinate this?
21:39:53 <jophish> buttons840: jobqueue perhaps
21:39:56 <jophish> I've not used it though
21:40:25 <jophish> there are a whole host of distributed processing frameworks which might work well for you
21:40:29 <buttons840> i need to crawl web pages, and based on what i find do some database tasks, and then based on that do more crawling, etc. -- are there any libraries that can help with this? some sort of task queue?
21:40:43 <buttons840> sorry, had network trouble and wasn't sure if my message made it
21:40:51 <Lokathor> so guys, it works
21:40:57 <Lokathor> and it's goofy
21:40:59 <jophish> :) you made me feel somewhat prescient 
21:41:20 <jophish> buttons840: please let me know if you find a good one
21:41:54 <buttons840> jophish: jobqueue puts stuff into an actual database it looks like, i don't necissarily need that
21:41:59 <Lokathor> http://lpaste.net/350372
21:42:05 <jophish> buttons840: this is also a really good resource for these kind of questions
21:42:06 <jophish> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
21:42:24 <buttons840> yeah, i've read that, but i don't know what category this will fall in
21:42:53 <jophish> I don't think there's an exact match in there
21:43:00 <jophish> you should add it if you find it!
21:43:00 <buttons840> it kind of seems like something for pipes maybe, but i don't know if pipes can handle circular tasks like this?
21:43:07 <bollu> so, the tutorial hit show HN front page xD (https://news.ycombinator.com/item?id=13239663#13241371) thanks everybody for massive amounts of help with it :)
21:43:20 <jophish> pipes is probably a really good place to start
21:47:57 <Lokathor> buttons840, if the task isn't infinitely circular then setting up the pipe should be trivial
21:48:12 <Lokathor> infinite circular with conditional halt is probably less trivial
21:48:25 <buttons840> Lokathor: it will converge, it's recursive like a web crawl with a limited depth, it eventually ends
21:48:43 <buttons840> there are more tasks than just crawling though, and they all need to be interleaved idealy for maximum performance
21:52:02 <Lokathor> hlint says that using take on a repeat value is an error, to use replicate
21:52:15 <Lokathor> but clearly hlint has never looked at the source code for the base package
21:54:59 <jophish> buttons840: there's some nice pipes machinery for concurrent processes 
21:56:24 <GGuy> Hi. I'm trying to create a heterogeneous collection using ConstraintKinds. It seems like while the code works for a single constraint it doesn't work for multiple. I'll paste what I have so far.
21:56:35 <lpaste> GGuy pasted “ConstraintKinds - heterogeneous collection” at http://lpaste.net/350373
21:57:36 <johnw> that's more like, homogeneous up to a constraint
21:58:30 <johnw> give testData a type signature
21:58:45 <GGuy> johnw: what would the typc signature be?
21:59:22 <johnw> something like testData :: forall c :: Constraint. H c
21:59:29 <johnw> i haven't worked with ConstraintKinds much
21:59:35 <johnw> but you need to make it polymorphic in the constraint
22:02:16 <buttons840> in pipes, how can i say "only do a max of 4 of this thing at a time"?
22:02:30 <johnw> you can chunk with pipes-group
22:02:51 <johnw> or do you mean this for concurrency?
22:03:01 <buttons840> for concurrency
22:03:07 <johnw> http://hackage.haskell.org/package/pipes-async
22:03:10 <buttons840> eg, "only scrap 4 pages at a time"
22:03:17 <johnw> see the Int argument to 'buffer'
22:04:26 <buttons840> oh, is basic pipes not concurrent?
22:04:31 <johnw> no, it is not
22:04:57 <GGuy> johnw: I tried "forall c. [H c]" but get "Could not deduce: c Int arising from a use of ‘H’"
22:06:05 <johnw> that's not enough
22:06:08 <johnw> you need "c :: Constraint"
22:06:22 <johnw> I'm pretty sure it won't infer the kind
22:06:32 <johnw> you may need to enable KindSignatures
22:10:36 <GGuy> testData :: forall (c :: * -> Constraint). [H c]?
22:10:50 <johnw> yeah, that looks right
22:10:57 <GGuy> Could not deduce: c Int...
22:10:59 <GGuy> same error
22:11:02 <johnw> let me try here
22:12:32 <johnw> i see
22:12:36 <johnw> right, that can't work
22:12:47 <johnw> you can't provide a list of values that might satisfy any constraint whatsoever
22:13:08 <johnw> nor can you specify a value that polymorphic in a "set" of possible constraints
22:13:13 <johnw> you'd need KindClasses
22:13:44 <johnw> it works if you use testData :: [H Show] and testData' :: [H IsInt]
22:16:31 <GGuy> Yeah, in my case i'm trying to create an api that creates a list from derivegeneric. So upfront I know nothing about the types, just that some will exist.
22:18:32 <GGuy> so it'd be nice if i could transform ghc.generics into something that can "show" if all contained types are instances of show... and so on
22:19:13 <johnw> well, there's always this:
22:19:34 <johnw> https://gist.github.com/jwiegley/9310e616ca0757a748f3ac7fb27b0f10
22:19:51 <johnw> encode the "set" of possibles, and dispatch at runtime
22:23:15 <GGuy> johnw: that'll do the trick! Thanks.
23:16:15 <osa1> any stack users here? what do I do to get ghc warnings printed? I have -Wall in my .cabal file
23:32:43 <cocreature> osa1: you need to build a specific package i.e. run "stack build packagename"
23:33:15 <osa1> cocreature: nice, thanks
23:33:47 <cocreature> osa1: the reason why stack hides the output by default is because it could get confusing if there are multiple concurrent builds
23:38:54 <osa1> cocreature: I don't think that's an excuse, it can collect outputs to separate files and then print them sequentially
23:39:02 <osa1> it could*
23:41:11 <cocreature> osa1: I’m not defending it (I really dislike this behavior). I was just explaining the rationale behind it :)
23:41:18 <osa1> right, thanks
23:48:03 <MarcelineVQ> it's kinda hideous but if you have -Wall in your .cabal and you want to see the warnings you could use    stack build --force-dirty --ghc-options="-fforce-recomp"     to cause everything to be re-examined
23:48:38 <MarcelineVQ> alternatively   stack ghci   will display them every time
