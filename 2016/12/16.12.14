00:02:49 <lyxia> moet: I think that's closest to what you wrote. But arrows may well be what you're looking for too.
00:05:03 <lyxia> Arrows turn pairing into a closed operation. the pair of two arrows corresponds to an arrow.
00:06:30 <moet> lyxia: when you said 'product' did you mean Data.Functor.Product, or just any product type, eg. (a, b)
00:12:26 <lyxia> I don't think there is currently a good Haskell type to represent that.
00:13:46 <lyxia> But I am referring to "product category" https://ncatlab.org/nlab/show/product+category, I think it can be represented
00:18:33 <lyxia> oh no it's not an instance of Category, because this only represents categories whose objects can be any type.
00:19:15 <Axman6> moet: looks like possibly Bifunctor?
00:19:33 <Axman6> :t bimap
00:19:37 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
00:20:21 <Axman6> hmm, maybe not
00:20:56 * Axman6 wonders if there's a Bicategory or something
00:21:10 <b0llu> Axman6: product of categories?
00:21:16 <Axman6> yeah
00:21:42 <lyxia> http://hackage.haskell.org/package/bifunctors-5.4.1/docs/Data-Bifunctor-Biff.html
00:24:57 <moet> so (->) is a category
00:24:59 <lyxia> moet: with functions as arrows: (ina *** outa) . (inb *** outb) = (ina . inb  ***  outa . outb)
00:25:44 <lyxia> doesn't work for general arrows.
00:25:47 <moet> and Data.Functor.Product does producty stuff (um, applies to both elements of a pair) i think
00:26:01 <moet> yeah, that's the arrow solution i was thinking about earlier
00:26:10 <moet> but now i want to find the solution you suggested
00:28:52 <moet> :t (***)
00:28:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
00:29:34 <lpaste> lyxia pasted “Product category, for moet” at http://lpaste.net/349912
00:31:17 <moet> woah
00:31:40 <lyxia> oops
00:31:56 <moet> That's definitely a category
00:31:57 <lyxia> c appears with two different kinds
00:32:07 <Axman6> Arrows are somewhat on the decline in mindshare, Profunctor offers the same power but is often a bit easier to use
00:33:00 <lyxia> fixed
00:33:12 <LordBrain> second and first though should be elevated to some more central location
00:33:22 <lyxia> Profunctor don't compose.
00:33:23 <LordBrain> those are the only things i like to use from ARrows
00:34:58 <LordBrain> well if people need arrows, keep it around, but second and first are in a class in their own in terms of utility, maybe they should be in the prelude
00:36:17 <moet> lyxia: your paste seems like it does the thing i need
00:37:02 <moet> which is great! i just wish i understood this stuff better
00:37:05 <lyxia> LordBrain: first and second are also the methods of Bifunctor (specialized to (->))
00:37:35 <lyxia> that might be easier to include in Prelude
00:38:06 <LordBrain> i don't object
00:38:35 <LordBrain> theory being we should aim for generalized functions in the prelude?
00:39:51 <lyxia> Why generalize functions?
00:40:25 <Axman6> because sometimes we actually want Kleisli
00:40:40 <lyxia> Bifunctor covers 99% of what people use Arrow for [citation needed]
00:40:47 <moet> generalize all the things! i was writing an edsl awhile back and kept running into issues where prelude functions require Bool instead of Bool b =>
00:40:47 <Axman6> yeah
00:42:04 <LordBrain> might as well, we've already started that process 
00:42:45 <LordBrain> hmmm
00:43:23 <LordBrain> that could cut down our inference tho
00:43:30 <b0llu> so, I'm encoding matrix dimensions in the type level: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/DenseMatrix.hs#L180
00:43:38 <b0llu> what if someone wants to dynamically create matrices?
00:43:43 <b0llu> then what happens to the type level stuf
00:43:53 <b0llu> stuff*
00:44:02 <b0llu> jle`, monochrom, lyxia: any insight?
00:44:07 <lyxia> moet: If you can recognize a category when you're given one you're not far from making up your own!
00:44:11 <b0llu> will users have to "fall back" to the untyped API?
00:46:53 <lyxia> b0llu: I think so
00:47:41 <sdx23> b0llu: when you create it, you say how big it'll be, no? In which case don't you know it?
00:48:14 <b0llu> sdx23: what if I want to create it with like, some random integer?
00:48:24 <b0llu> [30, 40] x [50, 60]
00:48:28 <b0llu> or something like that
00:48:33 <b0llu> you can't promote this to the type level
00:49:08 <Axman6> right, Haskell isn't a dependently typed language
00:49:13 <b0llu> yes
00:49:27 <b0llu> Axman6: you missed a ":(" at the end of the sentence ;)
00:49:28 <Axman6> this is essentially the definition of a dependently typed language
00:49:33 <b0llu> yep
00:49:45 <b0llu> so.. I give up the types for this right?
00:49:51 <b0llu> I "step back" to the "untyped" API?
00:51:57 <jchia1> jle`: I don't know about PolyKinds. I just ran stack haddock
00:52:49 <moet> b0llu: i've run into stuff like this before and there's usually a way around it
00:52:56 <b0llu> how?
00:53:13 <lyxia> You can't control external input, so you need to validate it anyway. Then you could technically reflect some of the validation in the types, but that requires a lot of existential type spaghetti.
00:53:38 <moet> ^ existential type spaghetti
00:54:20 <moet> use induction with a typeclass instance to "build" the type up from a base case
00:54:25 <moet> and never specify it at runtime
00:54:47 <moet> i can't believe i'm saying this; it doesn't really convey the pattern i've seen
00:54:48 <moet> sorry
00:55:00 <moet> wish i had a decent example
00:57:34 <bollu> moet: xD
00:57:36 <bollu> moet: okay
00:57:40 <bollu> moet: hmm
00:57:40 <moet> trying to make one now
00:57:49 <bollu> moet: okay, thank you
00:59:22 <lyxia> For example you can write functions like http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Typeable.html#v:eqT
00:59:54 <lyxia> Pattern matching does a runtime check, and if you get Just then you have a proof that the types are equal
01:00:35 <lyxia> And that equality is available when typechecking the Just branch.
01:01:19 <sdx23> when you build it inductively, you know the size at type level by construction.
01:03:34 <moet> ^ yes that
01:05:40 <bollu> lyxia: that is quite interesting 
01:08:26 <moet> erg.. my example be damnned, but this library uses the technique: http://hackage.haskell.org/package/Vec-1.0.5/docs/src/Data-Vec-Base.html
01:08:35 <moet> it's not the best example, but it's in there
01:09:07 <moet> bollu: look at the `VecList` class, and its instances
01:09:50 <moet> they take a list, with runtime-variable length, and convert it to a Vec, whose length is known by the typesystem
01:11:09 <moet> "known"
01:11:12 <moet> enforced?
01:14:12 <bollu> thanks
01:14:12 <bollu> Ill check
01:24:06 <sdx23> bollu: oh, you do this for symengine - nice!
01:27:54 <bollu> yes
01:27:54 <bollu> )
01:27:54 <bollu> :)
01:28:01 <bollu> sdx23: do you use SymEngine?
01:31:11 <bollu> lyxia: so do you want me to still keep everything typed?
01:31:14 <bollu> or provide an escape hatch?
01:31:16 <sdx23> bollu: no, but I'd like to discontinue using mathematica at some point. So, it's on my list to look into it somewhen.
01:33:05 <bollu> I see
01:44:03 <Profpatsch> data MyType a = Mytype Int
01:44:34 <Profpatsch> fn :: MyType Phantom -> Text
01:44:44 <Profpatsch> fn should output "Phantom"
01:45:10 <Profpatsch> And in general: fo :: MyType a -> Text
01:45:21 <Profpatsch> fo should output <name of a>
01:45:34 <Profpatsch> fn is easy when doing it manually.
01:45:44 <Profpatsch> fo is harder; how would I do that?
01:48:37 <jle`> Profpatsch: it's not directly possible, because of type erasure
01:48:53 <jle`> but you can use a typeclass that lets you call a "name" from instances to help you
01:48:57 <jle`> like Typeable from base
01:49:30 <jle`> fo :: Typeable a => MyType a -> String
01:49:50 <jle`> er
01:49:57 <jle`> fo :: forall a. Typeable a => MyType a -> String
01:50:09 <jle`> fo _ = show (typeRep (Proxy :: Proxy a))
01:50:42 <jle`> or you can just grab the TypeRep and do whatever you want with it
01:51:40 <jle`> oh, hm, even simpler
01:51:44 <jle`> fo = show . typeRep
01:51:48 <lyxia> bollu: IMO it's not worth the effort. Keep whatever the user inputs "dynamically typed".
01:52:22 <jle`> Profpatsch: you can think of 'Typeable' as a dummy typeclass that just assigns a constant value to every instance
01:52:54 <jle`> Profpatsch: like class TypeString a where typeString :: p a -> String; instance TypeString Int where typeString _ = "Int", instance TypeSTring Bool where typeString _ = "Bool"
01:53:24 <Profpatsch> jle`: It works!
01:53:30 <jle`> so 'foo :: TypeString a => MyType a -> String; foo = typeString' would be the equivalent
01:53:35 <Profpatsch> But I’m not sure why it has the same result.
01:53:39 <Profpatsch> data Phantom
01:53:50 <Profpatsch> data Foo a = Foo Int
01:53:55 <Profpatsch> let f = Foo 4
01:54:04 <Profpatsch> show $ typeRep (f :: Foo Phantom)
01:54:06 <Profpatsch> "Phantom"
01:54:17 <jle`> Profpatsch: do you understand the 'TypeString' class I gave up there"?
01:54:17 <Profpatsch> Why not "Foo Phantom"?
01:54:29 <jle`> Profpatsch: ah, look at the type of typeRep
01:54:38 <jle`> typeRep :: Typeable a => p a -> TypeRep
01:54:45 <jle`> the thing you want to "get the type of" is the 'a'
01:54:47 <jle`> in 'p a'
01:55:08 <jle`> so if you pass a 'Foo Phantom' to typeRep, you'll be using the 'Phantom' instance
01:55:23 <Profpatsch> So p is any type, but only the last * of * -> * will be used by typeRep
01:55:30 <pacak> Profpatsch: Also you usually use Proxy for that
01:55:36 <Profpatsch> That’s why you have proxy for *?
01:55:37 <pacak> :t Proxy
01:55:40 <lambdabot> forall k (t :: k). Proxy t
01:55:50 <jle`> yeah, it's done this way so that you don't actually *need* a value of the TypeRep instance
01:55:58 <Profpatsch> Ah, for all kinds, not just for k
01:56:21 <jle`> Profpatsch: you can use 'Proxy' if you don't have something that already fits 'p a'
01:56:46 <jle`> for example if you wanted to typeRep the 'a' of an '(a, Void)', you could do 'typeRep (Proxy :: Proxy a)'
01:57:04 <jle`> so it's kind of convenient for this, but in your case, you already had a 'p a' you could use
01:57:33 <jle`> thing thing is that you need to tell the typeRep function what 'a' you want...so you need to pass in the type 'a' as an argument somehow
01:57:36 <jle`> *the thing
01:57:49 <lpaste> eiGHttt pasted “Reader defautl value” at http://lpaste.net/349918
01:57:49 <jle`> but, 'typeRep :: Typeable a => a -> TypeRep' is a bad idea
01:57:55 <Profpatsch> Ah, because Proxy simulate a value even for e.g. Void?
01:58:03 <jle`> because you might not even have any values of type 'a' at hand
01:58:17 <jle`> so 'typeRep :: Typeable a => p a -> TypeRep' is the more sane way
01:58:28 <jle`> because you can pass in a 'p a' without having any actual values of type 'a' on hand
01:58:40 <jle`> like, for example, in your case, you don't have any values of type Phantom
01:59:03 <jle`> you have to give typeRep *something* to tell it what type you want of, and this is a convenient API trick
01:59:52 <Profpatsch> I see.
01:59:57 <Profpatsch> It makes sense, yes.
02:00:08 <Profpatsch> Now I have exactly the behavior I need.
02:00:09 <jle`> in the most recent GHC  we have new features that let us not require this hack anymore
02:00:17 <jle`> but, yeah.
02:00:34 <Profpatsch> Otherwise I’d have to define a monomorphic function for each of my Phantom types.
02:00:47 <jle`> mhm, you can think of Typeable as counter-acting type erasure because haskell basically passes around TypeRep's at runtime
02:00:57 <Profpatsch> Now I can just serialize the typeRep string into my database.
02:01:11 <jle`> Profpatsch: ah.  in that use case, it's no different than writing your own 'PhantomString' typeclass, and having an instance for every one of your phantom type parameters
02:01:24 <Profpatsch> Ah, I see.
02:01:28 <jle`> Profpatsch: the advantage here is that Typeable instances can be auto-derived by GHC
02:01:32 <jle`> so that's convenient heh
02:01:39 <Profpatsch> It is.
02:01:50 <jle`> yeah, you could write 'class PhantomString a where phantomString :: p a -> String'
02:01:54 <Profpatsch> Oh, but now I’m not sure if I can go the other way around.
02:02:02 <jle`> and instance PhantomString Phantom where phantomString _ = "Phantom"
02:02:09 <jle`> instance PhantomString Phantom2 where phantomString _ = "Phantom2"
02:02:38 <jle`> oh, go from a string to the appropriate phantom type parameter?
02:02:42 <Profpatsch> Yeah
02:02:56 <Profpatsch> Because I’d need that for deserializing.
02:02:57 <jle`> heh, yeah, that's actually the dual problem
02:03:05 <jle`> what we were doing with Typeable is often called 'reflection'
02:03:19 <jle`> and what you're talking about is the opposite, 'reification'
02:03:20 <Profpatsch> yeah, you kind of want that in your language.
02:04:03 <jle`> the two are sort of dual processes.  hopefully that gives you some keywords you can use to look around -- i have to head out now, though.
02:13:18 <Profpatsch> thanks; I see Edward Kmett has a similar thing with reflection
02:18:58 <meretrix> what's a fast way to shuffle a small (5-10 element) list?
02:19:16 <meretrix> I used the random-shuffle package, but it's extremely slow.
02:20:02 <meretrix> Profiling shows it using 15% of my run-time.  I would expect far less than 0.1% of the time based on all the other calculations I'm doing.
02:21:25 <merijn> hmmm I know how to shuffle arrays efficiently, but the resulting implementation for list would be rather slow
02:22:06 <meretrix> merijn: even for such a small list?
02:22:19 <merijn> meretrix: Well, depends how often you're shuffling it? :)
02:22:22 <meretrix> I suppose I could use an array.  It's a really tiny portion of my code.
02:22:50 <meretrix> Few million times.
02:23:36 <merijn> See, that's where you get issues. As even a moderatly poor shuffle becomes a million times poorer ;)
02:24:04 <pavonia> You are shuffling the same list a million times?
02:24:10 <merijn> If you could use a mutable vector instead of a list then you can make a fast shuffle pretty fast
02:24:35 <meretrix> pavonia: No, different list, but same length each time.
02:24:43 <meretrix> Thanks, I'll give that a try.
02:25:32 <merijn> meretrix: You'll want to lookup "Fisher-Yates shuffle", it's a surprisingly trivial algorithm for a perfect shuffle :)
02:25:56 <meretrix> yup, i was just reading the wiki page :)
03:01:49 <zzq> \quit
03:28:27 <Profpatsch> Someone with persistent experience reading this by chance?
03:29:30 <Profpatsch> I have some fields that are numeric constants, they have a type, an integer constant and an optional description.
03:29:55 <Profpatsch> I modeled them as a type data NumericConstant a = NumericConstant Int Text
03:30:37 <Profpatsch> And then there’s a phantom type for every variant (so that I don’t confuse them)
03:31:02 <bollu> two quick questions on haddock. 1. is there a "quick reference" like for markdown? 2. is it possible to theme haddock?
03:31:14 <bollu> also, how does one write a tutorial that gets auto-built?
03:31:18 <bollu> and is it possible to have doctests?
03:32:41 <Profpatsch> Now, in order to persist those, I have a table which pretty much conists of type::Text, constant::Int, desc::Text and unique identifier TypeConstant type constant
03:33:34 <Profpatsch> I call it NumericConstantSql.
03:34:08 <Profpatsch> But I don’t want my original type to have fields of NumericConstantSql, I want it to have NumericConstant a.
03:35:48 <Profpatsch> To map those, I’d need to filter on the type field of NumericConstantSql.
03:54:36 <meretrix> I'm going to be doing millions of smallish matrix multiplications: (1x5)*(5x100).  Is the matrix package likely to be the fastest?
03:57:40 <merijn> meretrix: If you want fastest, get hblas
03:57:47 <merijn> Which is just a wrapper around BLAS
03:58:37 <meretrix> merijn: I was thinking the FFI overhead might be relatively high for such small matrices..
03:58:45 <merijn> maybe, hard to say
03:59:02 <merijn> tbh, the FFI overhead isn't that much
03:59:11 <merijn> Especially if the people writing the bindings know what they're doing
04:19:01 <cocreature> 5x100 seems large enough to justify the ffi overhead
04:24:28 <meretrix> ok, I'll do some testing
04:24:38 <meretrix> I also just came across Statistics.Matrix
04:24:47 <meretrix> which appears to use unboxed Vectors
04:30:06 <kuribas> meretrix: why don't you benchmark it with criterion?
04:30:30 <cocreature> to benchmark it you first need to implement it :)
04:31:31 <kuribas> cocreature: matrix multiplication should be so hard to implement.
04:32:02 <kuribas> You can just use a random matrix, since you only care about the speed.
04:32:03 <cocreature> kuribas: sure but replacing the matrix multiplication in existing code can take a nontrivial amount of effort
04:32:49 <kuribas> cocreature: I understood that he is still writing the code...
05:01:35 <stobix> Looking at Control.Category. What would it mean that "id and (.) must form a monoid"? My first reaction was to try to define mempty and mappend in terms of Category.id and Category.. that made sense, but I can't seem to do it. Am I thinking wrong somehow?
05:02:15 <stobix> s/that made sense/in a way that made sense/
05:03:41 <cocreature> stobix: this is about mathematical monoids, not about instances of the haskell typeclass Monoid
05:03:59 * stobix just got severely mind fucked
05:04:15 <stobix> Ah. Well, that changes things a bit, doesn't it...
05:04:19 <cocreature> stobix: here it meanst wo things 1) "id . something" and "something . id" are both "something"
05:04:27 <cocreature> and 2) composition is associative
05:04:36 <cocreature> i.e. (f . g) . h = f . (g . h)
05:04:44 <stobix> Ah, good.
05:05:05 * stobix is learning category theory at the moment, and kinda wondered if Control.Category followed category laws.
05:08:02 <lyxia> It should, but we can't enforce it in Haskell.
05:08:52 <cocreature> whether it is a good idea to enforce it even if we could is also at least debatable
05:09:50 <stobix> If "id and (.) must form a monoid" <=> "follow the category rules gdammit", then I'm satisfied.
05:10:41 <stobix> And the rules cocreature just gave seems to me to be equivalent to the category rules, for a subset where left id is right id.
05:10:55 <Cale> It's not quite the same thing as a monoid
05:10:58 <stobix> (eh, scratch that last part.)
05:11:10 <stobix> Cale: what's the difference?
05:11:29 <cocreature> you can’t compose all functions
05:11:33 <Cale> yeah
05:11:35 <stobix> And does monoids have anything to do with Monoids?
05:11:38 <cocreature> f . g doesn’t typecheck for arbitrary functions f and g
05:12:12 <cocreature> but category theory also doesn’t tell you that all functions need to compose so that part is fine
05:12:13 <bollu> how do I get the quickcheck trace on running `stack test`
05:12:23 <stobix> Ah, right. So monoids are categories with arbitrary composition?
05:12:37 <Cale> Monoids are categories with a single object
05:12:49 <Cale> (if you like)
05:13:09 <stobix> Ah, which could mean kinda the same as "arbitrary composition" since the type doesn't change.
05:13:10 <Cale> The objects in a category are just there to tell you which arrows are allowed to be composed
05:13:14 <Cale> So yeah
05:13:49 <merijn> Obligatory comment that learning category theory is interesting, doing so to become better at Haskell doesn't have a great ROI :)
05:13:55 <mads-> In big steps, how would you solve this task? Given a list of strings, read it, find every unique string and print the strings sorted by the number of occurences (and also their occurence)? 
05:14:01 <bollu> what is exit code 11?
05:14:13 <merijn> bollu: SIGSEGV :)
05:14:15 <bollu> mads-: use a hash map
05:14:17 <Cale> mads-: map (head &&& length) . group . sort
05:14:25 <bollu> oh
05:14:35 <bollu> ohh xD
05:14:38 <bollu> merijn: interesting
05:14:48 <bollu> merijn: some of my C to Haskell FFI is crashing
05:14:50 <mads-> Cale: what does head &&& length do? 
05:14:52 <bollu> merijn: I don't know where
05:14:55 <bollu> merijn: how do I debug
05:14:57 <cocreature> merijn: I was waiting for that comment :)
05:14:59 <bollu> :t (&&&)
05:15:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:15:01 <Cale> (\x -> (head x, length x))
05:15:16 <merijn> bollu: Depends, if it's crashing in the C bit you can just use gdb :)
05:15:21 <mads-> thanks
05:15:35 <bollu> merijn: how do I GDB through my haskell code? (also, I'm using stack if that changes anything)
05:15:44 <bollu> like, how do I see what's happening through the FFI?
05:16:00 <cocreature> if you tell ghc to compile with DWARF info you can usually see where your haskell code started to jump to the ffi code
05:16:18 <merijn> I haven't tested GHC's DWARF support, though
05:16:22 <stobix> merijn: Well, I think it greatly helps, at least with reconciling with the strange names of all the Haskell classes. Anyways, my Const a k is now a Functor, and maybe an Applicative. The Monad bit is hard.
05:16:34 <merijn> bollu: Are you calling C from Haskell of Haskell from C?
05:16:52 <Cale> > Map.toList . Map.fromListWith (+) $ zip "character count" (repeat 1)
05:16:55 <merijn> stobix: How did you get the Applicative to follow the laws? :)
05:16:55 <lambdabot>  error:
05:16:55 <lambdabot>      Not in scope: ‘Map.toList’
05:16:55 <lambdabot>      Perhaps you meant one of these:
05:17:04 <Cale> > M.toList . M.fromListWith (+) $ zip "character count" (repeat 1)
05:17:06 <lambdabot>  [(' ',1),('a',2),('c',3),('e',1),('h',1),('n',1),('o',1),('r',2),('t',2),('u...
05:17:14 <Cale> ^^ another way, using Data.Map
05:17:23 <Cale> (that'll work for strings too of course)
05:18:21 <bollu> merijn: C from haskell
05:18:37 <merijn> bollu: And you're familiar with gdb for C debugging already?
05:18:40 <stobix> merijn: I made a a monoid. mempty was the only thing that made sense to me for the value I needed to grasp from thin air for pure.
05:18:49 <bollu> merijn: yep!
05:18:54 <merijn> stobix: Right. And <*> ?
05:19:11 <merijn> bollu: tbh, you can literally just load your haskell binary in gdb and put a breakpoint on your C code as normal
05:19:18 <bollu> wait what?
05:19:19 <stobix> merijn: Just a moment. Gonna find the .hs file somewhere.
05:20:03 <merijn> bollu: gdb knows only 2 things: 1) machine code and 2) DWARF (which maps machine code to strings representing source), it doesn't give a shit that there's non-C machine code in there :)
05:20:26 <merijn> bollu: And as cocreature pointed out modern (I think only ghc 8+) can actually generate DWARF for haskell code too
05:20:32 <bollu> merijn: yes, but that seems like a very primitive way of debugging. The Haskell code will look like giberish
05:20:54 <bollu> merijn: that's okay, I'm using every GHC extension there is for types (or so I'd like to believe :P) so my code is strictly GHC 8+
05:21:16 <merijn> bollu: True, but if you can find that some variable is, e.g. NULL that shouldn't be, you can trace it back to whereever it got passed in from the FFI :)
05:21:21 <bollu> I see
05:21:30 <merijn> bollu: But I haven't used GHC's DWARF stuff so can't help with that
05:21:34 <bollu> okay
05:21:58 <stobix> merijn: I set (Const x) <*> (Const y) = Const (x `mappend` y). I think I've convinced myself it follows the homomorphism and interchange rules, but I'm not sure about composition.
05:22:37 <merijn> stobix: That's right
05:22:43 <tsahyt> Hello, I've got a question about control flow! I've got two parsers that I execute within an IO function, which return Either (ParseError ..) A. Now if the parsing fails this is a user error and there's no way to recover here so I'd just like to print the error and exit. what would be the cleanest way to execute both these parsers in sequence, and aborting everything whenever an error occurs?
05:22:48 <merijn> stobix: So, now let's have another look at Monad and Applicative
05:22:51 <merijn> :t (<*>)
05:22:52 <bollu> merijn: I think unsafePerformIO is screwing me over
05:22:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:22:56 <merijn> :t (>>=)
05:22:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:23:03 <tsahyt> I can put them into ExceptT, and then pattern match on the combined result, but that seems unnecessarily verbose
05:23:05 <merijn> data Const k a = Const k
05:23:15 <tsahyt> especially because now the entire rest of my computation lives in the case alternative
05:23:28 <merijn> stobix: Can you tell me any interesting difference between the types of <*> and >>= ?
05:23:31 <stobix> merijn: yeah, I have no idea where I could find a magic a to put into (a -> m b), or how it would happen.
05:23:46 <merijn> stobix: Well, yes, that's the point ;)
05:24:39 <stobix> merijn: is it at all possible? It feels like I would have to drag it from the "abstract" world of types into the "real" world of values for it to work.
05:25:03 <Profpatsch> unsafePerformIO is the answer. Always.
05:25:06 <tsahyt> if there was something like catch for IO (Either e a) than that would work
05:25:08 <merijn> stobix: That's why Const *can't* be a Monad. Because the Monad interface allows the result Const to depend on an arbitrary Haskell function of 'a'. "\b -> if b then foo else bar" <- which monadic action gets executed depends on the actual value of 'b'
05:25:12 <stobix> lol @ Profpatsch 
05:25:39 <merijn> stobix: Note that the resulting action of <*> *never* depends on any of the values "inside" the Applicative, only on the applicative itself
05:25:43 <Profpatsch> Or its big brother, unsafeCoerce
05:26:12 <merijn> stobix: If we look at, for example, IO >>= allows ">>= \b -> if b then return () else print "whoo!""
05:26:18 <bollu> god damn
05:26:28 <bollu> I think my function is referentially transparent
05:26:33 <bollu> how do I quickly check if it is?
05:26:50 <Profpatsch> bollu: You test for every input.
05:26:55 <merijn> stobix: >>= can conditionally execute print, whereas <*> can never conditionally do anything. It's behaviour is the same regardless of results of the behaviours :)
05:27:06 <bollu> Profpatsch: how exactly does one formalise referential transparency?
05:27:12 <bollu> equal inputs give equal outputs?
05:27:41 <Profpatsch> You can replace for the definition and it’s the same expression.
05:28:13 <bollu> hm
05:28:15 <merijn> stobix: So the requirement of being able to produce an *actual* 'a' and the ability to let the result depend on the value of that 'a' is exactly the difference in "power" between Applicative and Monad :)
05:28:23 <bollu> but if there is an unsafePerformIO?
05:28:45 <Profpatsch> That’s not even a very good informal definition tbh
05:29:00 <bollu> Profpatsch: so, like, basically, "eta reduction holds" ?
05:29:38 <Profpatsch> no idoa
05:29:42 <prose[m]> https://diversitytickets.org/events/52
05:29:43 <bollu> okay
05:29:47 <bollu> what is the formal definition?
05:29:47 <stobix> merijn: Hm. Have I gotten this right:  <*> could depend on the type, only it had to be in its definition, not "dynamically" as a part of an expression?
05:30:03 <stobix> s/type/value of 'a'/
05:31:33 <merijn> stobix: Well, it can't depend on the type of 'a' either, because of parametric polymorphism :)
05:31:33 <stobix> merijn: Like I could define a ... <*> ... a = ... where the type depended on a somehow.. Or, no, maybe that's exactly what can't be done...
05:31:59 <stobix> merijn: True, I think I get it somewhat now.
05:32:28 <merijn> stobix: But the type of <*> never requires you to produce an actual 'a', which why Const can be one :)
05:33:22 <stobix> merijn: So, "it doesn't require you to" <=> "you can't use it".
05:33:31 <merijn> stobix: Yes
05:33:40 <stobix> Nice.
05:33:50 <merijn> stobix: >>= can't use 'a' either, but the function passed to >>= has to be able to
05:34:08 <bollu> how can I log which quickCheck input was sent?
05:34:14 <bollu> I want a list of all inputs quickCheck generated
05:34:19 <bollu> so I can isolate what caused the vrash
05:34:50 <stobix> bollu: check the verbose functions. verboseCheck IIRC
05:35:20 <bollu> ty
05:35:23 <kuribas> is it useful to specialize non-exported functions?
05:35:27 <bollu> this is quite frustrating to trach down
05:35:28 <bollu> track*
05:36:20 <merijn> kuribas: only if they're used by exported polymorphic functions and you specialise those too, I think? But if you specialise the exported ones the non-exported functions might not need to be specialised...
05:36:24 <stobix> merijn: Well, yeah. >>= has to be able to use that the function passed to it has to be able to do it. :)
05:36:26 <merijn> kuribas: So...probably not :)
05:36:39 <kuribas> merijn: ok :)
05:36:51 <bollu> I'm doing this inside Tasty
05:37:06 <bollu> so it's a little harder
05:37:17 <bollu> is there a command line option that I can pass to tasty?
05:37:38 * stobix has no idea what Tasty is, but it souns nom.
05:37:42 <stobix> ds*
05:37:55 <bollu> testing library :)
05:38:47 <kadoban> bollu: I think you can ask for help when you run the tasty thing, in the usual way (--help)
05:39:02 <tsahyt> @hoogle IO (Either a b) -> (a -> IO b) -> IO b
05:39:05 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr b)) -> (Maybe a -> IO (Ptr b))
05:39:06 <lambdabot> Foreign.Marshal.Utils maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
05:39:06 <lambdabot> Data.GI.Base.Utils convertIfNonNull :: Ptr a -> (Ptr a -> IO b) -> IO (Maybe b)
05:39:13 <bollu> I see
05:39:14 <bollu> tanks
05:39:25 <bollu> thanks*
05:39:33 <athan> metatanks
05:39:58 <tsahyt> isn't there some way to treat Left like an exception and use some catch-like construct?
05:40:23 <tsahyt> Ideally something existing in some library
05:40:30 <athan> tsahyt: sure, there would be an easy one with throw . userError . show
05:40:46 <athan> @type either (throw . userError . show) pure
05:40:48 <lambdabot> (Applicative f, Show a) => Either a a1 -> f a1
05:41:00 <athan> er, those functions swapped
05:41:22 <bollu> wait, what?
05:41:26 <bollu> it doesn't crash when I run it directly
05:41:33 <bollu> it crashes *through stack test*
05:41:34 <bollu> WTF
05:41:34 <athan> you're looking for something like "hush", but for IO... hm...
05:41:56 <bollu> what. the. fuck.
05:42:01 <athan> bollu: same executable? Sometimes stack hashes databases or something in .stack-work/
05:42:08 <athan> what's prollem?
05:42:12 <bollu> how do I check if it's the same executable
05:42:32 <bollu> athan: a quickCheck test crashes when I run it through "stack test"
05:42:34 <athan> can you show me some longs bollu?
05:42:35 <bollu> (segfault)
05:42:38 <bollu> uh
05:42:41 <athan> logs*
05:42:45 <bollu> let me try and generate a log for you right now
05:43:01 <bollu> hm
05:43:03 <bollu> gimme a sec
05:43:26 <bollu> "    commutativity:                             symengine-test(27976,0x70000051c000) malloc: *** error for object 0x7fb1fac03420: pointer being freed was not allocated"
05:43:29 <bollu> interesting
05:43:34 <bollu> works flawlessly "outside"
05:43:55 <athan> oh woah
05:44:00 <athan> are you doing ffi stuff?
05:44:11 <athan> you might need something something foreign pointer-y
05:44:28 <bollu> yes
05:44:30 <bollu> I am FFIing
05:44:35 <bollu> and I am using foreign pointer
05:44:39 <bollu> foreign pointers
05:45:15 <bollu> hm
05:45:17 <athan> hmm. Have you managed to save the seed that generates this error?
05:45:19 <bollu> let me look at my code first
05:45:22 <bollu> let me do that
05:45:25 <merijn> bollu: oh
05:45:39 <merijn> bollu: You're passing a ForeignPtr allocated pointer to C, yes?
05:45:39 <athan> the quickcheck seed i mean - then you could isolate it to the executable like you said you saw inconsistency with
05:45:43 <bollu> yep
05:45:53 <bollu> it crashes before it can log the seed (segfault)
05:46:00 <athan> D:
05:46:03 <bollu> athan: can I log the seed in the beginning
05:46:05 <bollu> ?
05:46:07 <merijn> bollu: Two questions: 1) does the C code store the pointer somewhere? 2) How are you calling the C function with the foreign ptr?
05:46:12 <athan> there should be a way bollu
05:46:34 <bollu> merijn: 1. according to the semantics, it shouldn't. Deallocation should be in my control 2.I use 'withForeignPtr' 
05:46:45 <merijn> bollu: hmmm
05:47:04 <merijn> bollu: oh...you used unsafePerformIO?
05:47:11 <bollu> yes
05:47:13 <bollu> merijn: yeo
05:47:16 <bollu> merijn: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/DenseMatrix.hs#L173
05:47:22 <merijn> Inside the code passed to withForeignPtr?
05:47:27 <bollu> yes
05:47:31 <bollu> merijn: is that wrong? :O
05:47:43 <tdammers> if you have to ask, then the answer is "yes, very"
05:47:48 <bollu> hm
05:47:51 <bollu> okay, why?
05:48:04 <bollu> because, from the external point of view, it "doesn't matter"?
05:48:06 <merijn> bollu: unsafePerformIO == I don't care when this runs and if it runs 0, one or more times
05:48:20 <bollu> merijn: oh, so the finaliser can run multiple times?
05:48:21 <bollu> oh, fuck
05:48:21 <tdammers> also, "I'm fine with this running multiple times in parallel"
05:48:27 <bollu> wow
05:48:29 <merijn> bollu: No, the finaliser won't
05:48:33 <bollu> then?
05:48:36 <athan> :D
05:48:41 <bollu> I still don't see the issue
05:48:50 <merijn> bollu: The computation using the pointer might lazily run after withForeignPtr returns
05:49:30 <merijn> bollu: So, GHC goes "welp, this is no longer used" and GC the ptr, later it forces the unsafe thunk that uses that pointer and the segmentation fault faery visits you :)
05:49:41 <bollu> merijn: from what I understand, creating a foreign pointer hooks into the GC, so the block should still be alive?
05:50:00 <bollu> merijn: but if it is lazily executed, then the reference to the thunk is held?
05:50:03 <merijn> bollu: When you extract said foreignptr into an *actual* pointer GHC can't track it any more
05:50:09 <bollu> hmm
05:50:19 <bollu> merijn: wait, can you clarify for me (I'm trying to understand this)
05:50:21 <merijn> bollu: withForeignPtr exists to force the pointer to remain alive the entire duration of the foreign call
05:50:32 <bollu> thunk[foreign pointer[internal pointer]]
05:50:34 <bollu> right?
05:50:39 <merijn> bollu: withForeignPtr is just "ffi call; touch foreignptr"
05:50:41 <bollu> [] as in "contains"
05:50:44 <bollu> hm
05:51:07 <bollu> merijn: okay, can you step back for a sec? tell me what happens if I did not use unsafePerformIO
05:51:48 <bollu> merijn: I'm confused now >_<
05:51:57 <bollu> merijn: my understanding of foreign pointers is flawed
05:52:06 <merijn> bollu: You unwrap the foreignptr, call the C function with the naked ptr, C function returns, touch does a no-op on the foreignptr (so it can't have been GCed), at some pointer foreign ptr gets GCed and finalizer runs
05:52:18 <bollu> okay
05:52:20 <merijn> bollu: Now imagine:
05:53:14 <merijn> You unwrap the foreignptr, apply to the imported C function which is all wrapped with unsafePerformIO, so it just returns a thunk without running. withForeignPtr returns. Touch does a no-op, foreignptr get's GCed, later you evaluate the thunk of the C code. Whoops
05:53:46 <merijn> I'm not saying that's what happens, but that's one of the possible sorta scenarios, depending on how GHC decides to compile your unsafePerformIO
05:53:49 <bollu> "Touch does a no-op" <- exactly, so why does it get GCd?
05:54:04 <merijn> bollu: Well, is anything using it after touch?
05:54:04 <tdammers> touch *prevents* it from getting GC'd
05:54:12 <tdammers> but only until the touch
05:54:26 <bollu> yes, so the "touch" will also be within the thunk, no?
05:54:30 <bollu> or am I seeing it wrong?
05:54:32 <merijn> bollu: Why?
05:54:51 <bollu> merijn: because the thunk is the entire evaluation of the <withForeignPtr …>?
05:54:53 <bollu> or is that wrong?
05:55:29 <tdammers> the problem with unsafePerformIO here is that it allows you to run IO (which, under normal circumstances, guarantees execution order) inside a thunk (which normally means "you can evaluate this whenever you want")
05:55:31 <merijn> bollu: Why? Why not just the inner call? I dunno how exactly withForeignPtr is compiled, but I don't see why it would never produce a thunk internall if the function called inside is using unsafePerformIO
05:55:48 <merijn> bollu: Normally the IO monad would enforce the entire thing finishes before withForeignPtr does
05:55:56 <merijn> bollu: But unsafePerformIO subverts that guarantee
05:56:39 <bollu> merijn: so you're saying that the return value of the withForeignPtr call gets thunked
05:56:41 <bollu> ?
05:56:47 <bollu> merijn: what exactly is getting thunked?
05:56:48 <merijn> bollu: *Could* be
05:56:53 <bollu> I'm sorry, I don't follow
05:56:53 <bollu> okay
05:57:14 <bollu> merijn: okay, so touch runs after the thunk has been returned?
05:57:32 <bollu> ah
05:57:36 <merijn> bollu: touch runs, then the thunk is returned, and gets evaluated at some point
05:57:37 <bollu> so the pointer is not guaranteed to be alive
05:57:40 <bollu> dang
05:57:54 <bollu> so is there no way to have a non-IO tagged API for FFI stuff?
05:58:14 <merijn> Not if it involves allocations
05:58:21 <bollu> :(
05:58:31 <bollu> I'm writing an API for symengine
05:58:50 <merijn> bollu: What's the problem?
05:58:53 <bollu> so how do I do something like this?
05:58:53 <bollu> https://github.com/bollu/symengine.hs/blob/master/src/Symengine/DenseMatrix.hs#L171
05:58:59 <bollu> merijn: the API will now have IO () everywhere
05:59:05 <bollu> I wanted to be able to have a "nice" functional API
05:59:21 <bollu> I can't write a function like `densemarix_add` anymore in that cas
05:59:22 <bollu> case*
05:59:38 <bollu> (the with is something that just pulls out the correct foreignPtr)
05:59:48 <bollu> this is the with stuff: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/Internal.hs#L55
05:59:52 <merijn> bollu: You could have a pure API that builds a datastructure representing operations, allocations etc. and have "doComputation :: MatrixComputation r -> IO r"
06:00:14 <bollu> merijn: hm
06:00:20 <merijn> bollu: Basically, making your library an (E)DSL for the SymEngine API
06:00:24 <bollu> merijn: so, like, free monad?
06:00:34 <merijn> Not necessarily using free, but yes
06:00:49 <bollu> merijn: so, for example, how would I do this? (a + (b + c) == a + (b + c) where a, b, c, are matrices
06:00:54 <bollu> in your version of the API
06:02:19 <merijn> That would become something like: densematrix_add :: forall r c. (KnownNat r, KnownNat c) => MatrixComputation (DenseMatrix r c) -> MatrixComputation (DenseMatrix r c) -> MatrixComputation (DenseMatrix r c)
06:03:00 <bollu> ah
06:03:11 <bollu> so you're literally making a freakin' evaluation tree
06:03:14 <bollu> god damn
06:03:17 <bollu> this is complex
06:03:22 <bollu> is there really no other way?
06:03:31 <merijn> bollu: Tbh, just making everything IO isn't that bad, IMO
06:04:15 <bollu> really?
06:04:44 <bollu> so you would be okay with matrix_add :: DenseMatrix -> DenseMatrix -> IO DenseMatrix
06:04:54 <merijn> bollu: Most of my haskell is rather IO heavy :p
06:04:58 <bollu> merijn: I now realise that wrapping imperative APIs is haskell is insanely hard
06:04:59 <bollu> :P
06:05:07 <bollu> like, I didn't think it would be this hard
06:05:13 <kadoban> bollu: That's the reality, recognizing the reality in haskell's model of it doesn't seem so bad
06:05:41 <bollu> kadoban: I wish the machine level fact that I'm allocating pointers didn't interfere with the "fact" that my computation is pure
06:05:42 <kadoban> IMO haskell's main benefit isn't that everything is pure, it's that it has a model that can tell the difference between pure code and non-pure.
06:05:49 <bollu> like, matrix addition has zero side effects
06:05:56 <bollu> it's just that the underlying library has side effects
06:05:59 <bollu> this is quite leaky
06:05:59 <bollu> :(
06:06:09 <kadoban> Yes, in that sense it's not ideal.
06:06:22 <bollu> yeah
06:06:24 <merijn> bollu: At quick glance that's what the hblas library does too
06:06:50 <bollu> merijn: is there no way to ask GHC to like, "keep the pointer alive as long as the thunk is alive"?
06:07:09 <merijn> bollu: That can be arbitrarily hard :)
06:07:22 <bollu> merijn: how so?
06:07:36 <bollu> merijn: I just want some perspective here, I'm feeling tremendously dejected :P
06:07:56 <bollu> that the true notion of "pure" is marred by some implementation detail of memory allocation
06:08:03 <merijn> bollu: You'd have to maintain a cross-reference of pointer values to foreignptr, but that's not enough, because what if you do pointer addition on that pointer
06:08:30 <merijn> Suppose I have an array pointer and I do "pointer + 5" to point at the 6th element. now I need to remember that that relies on the original foreignptr
06:08:39 <bollu> hm
06:09:13 <bollu> so, does every library that around some C library return IO?
06:09:29 <merijn> bollu: Well, you might be able to do what you want by messing with GHC primitive stuff
06:09:38 <bollu> ooh, tell me
06:09:51 <merijn> bollu: i.e. instead of allocating via malloc, allocating via GHC, but that limits what you can do and doesn't work with all libraries
06:10:13 <bollu> ah,no
06:10:25 <bollu> I can't edit an entire library to fit haskell's world view
06:10:46 <bollu> merijn: so, like, if I have a library that does pure stuff but is "impure" because it uses C, "tough luck"?
06:11:03 <merijn> bollu: Sure, but if the C library only needs pointers to data and doesn't free or allocate them itself you could use GHC's arrays to allocate stuff
06:11:16 <merijn> bollu: You might wanna browse ghc-prim a bit: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate/docs/GHC-Prim.html
06:11:17 <bollu> merijn: interesting
06:11:19 <bollu> merijn: tell me more?
06:11:39 <merijn> Which has all sorts of low-level GHC voodoo you can use for low-level stuff
06:12:29 <bollu> merijn: the library calls "new"
06:12:42 <bollu> merijn: but, lke, I could probably pass it a pointer-to-pointer and to a placement new
06:12:47 <bollu> merijn: does that help?
06:13:25 <bollu> merijn: where is the call for "chunk of memory ;)"
06:13:33 <merijn> bollu: Maybe? Everything depends on so many details and how far you're willing to go :p
06:13:46 <bollu> merijn: like, what is the "void*" of the haskell API?
06:13:48 <bollu> GHC
06:14:00 <bollu> since GHC doesn't / can't know anything about the type
06:14:06 <merijn> void* is Addr# (as in, Addr# is literally a void*)
06:14:08 <bollu> all of the "information" happens on the C side (SymEngine)
06:14:11 <bollu> I see
06:14:13 <merijn> You'll want newPinnedByteArray# :: Int# -> State# s -> (#State# s, MutableByteArray# s#)
06:14:22 <merijn> Which is a mutable byte array that can't be moved
06:14:31 <merijn> But I can't quickly find how to turn that into an Addr#
06:15:13 <merijn> This also ends up in IO, mostly. But at least GHC can track it properly, so unsafePerformIO that should be less problematic
06:15:28 <bollu> I see
06:15:39 <merijn> byteArrayContents# :: ByteArray# -> Addr#
06:15:49 <bollu> hm
06:15:51 <bollu> yay, no IO
06:15:56 <bollu> but fuck, this is black magic level
06:16:10 <merijn> :p
06:16:15 <bollu> I had no idea that writing wrappers for a library would end up with me learning type level progamming and messing with GHC API :P
06:16:23 <merijn> Like I said, just doing IO would probably be easier :)
06:16:26 <Profpatsch> Is there a good way to have Read, but for Text?
06:16:32 <bollu> no, I don't want to have IO
06:16:33 <hodapp> Let's do machine learning using only GHC's type system.
06:16:34 <bollu> it's so ugly
06:16:35 <bollu> :)
06:16:36 <merijn> Profpatsch: Write a parser
06:16:44 <Profpatsch> merijn: Well, I’m writing a cassava parser.
06:16:44 <kadoban> Profpatsch: T.pack . read  ;)
06:16:47 <merijn> Profpatsch: Megaparsec or attoparsec
06:16:57 <merijn> Profpatsch: Read's performance is awful
06:17:10 <kadoban> Or wait, that was not the right way and didn't make any sense.
06:17:24 <Profpatsch> But the cassava interface is kind of unsatisfying
06:17:34 <bollu> merijn: can you throw a quick example together?
06:17:38 <bollu> merijn: please?
06:17:52 <merijn> bollu: tbh, I'd have to research how to :)
06:17:57 <bollu> merijn: xD
06:17:58 <merijn> bollu: I've not done much with this stuff
06:17:58 <bollu> merijn: okay
06:18:07 <bollu> merijn: lemme go do this. Thanks for all the help
06:18:16 <bollu> merijn: shall I blog post this if / when I figure this out?
06:18:18 <merijn> bollu: Also, you might be a candidate for #numerical-haskell :)
06:18:21 <bollu> merijn: there aren't a lot of resources :(
06:18:23 <bollu> merijn: xD
06:18:27 <Profpatsch> merijn: cassava already uses attoparsec internally.
06:18:28 <bollu> merijn: OK, let me join
06:18:40 <merijn> bollu: People there should be more experienced with stuff like this
06:18:48 <bollu> ty
06:18:49 <merijn> bollu: Lots of matrix/linear algebra stuff and GHC voodoo
06:19:01 <Profpatsch> But it apparently defines its own Parser type, so I cannot use any attoparsec parser?
06:19:12 <Profpatsch> Or is this thing here compatible with attoparsec? http://localhost:8080/file/nix/store/141nf56rbzd8jjd4g69pd5vyzhb73sgh-cassava-0.4.5.1/share/doc/x86_64-linux-ghc-8.0.1/cassava-0.4.5.1/html/Data-Csv.html#t:Parser
06:19:17 <Profpatsch> Oh, sorry, localhost
06:19:24 <merijn> Profpatsch: I don't really understand the question/goal?
06:20:50 <Profpatsch> merijn: I have a cassava Parser https://hackage.haskell.org/package/cassava-0.4.5.1/docs/Data-Csv.html#t:Parser
06:21:17 <Profpatsch> And I want to say ”parse this int, but first normalize it by filtering out spaces”
06:21:46 <bollu> merijn: shall I ask on /r/haskell?
06:22:19 <merijn> bollu: I would recommend haskell-cafe mailing list, the mailing list tends to have more varied expertise
06:22:32 <bollu> okay
06:22:35 <bollu> merijn: how about both? ;)
06:22:41 <merijn> Also works
06:22:49 <bollu> merijn: I'm basically "spray-and-pray"ing here for solutions
06:25:08 <Profpatsch> cassava apparently defines its own parser, so theres basically no combinators one can use.
06:25:37 <Profpatsch> In particular no attoparsec combinatiors.
06:27:57 <bollu> merijn: how will adress spaces work?
06:28:01 <bollu> merijn: if I allocate on GHC
06:28:07 <bollu> merijn: how will C be able to access to it?
06:28:13 <bollu> merijn: how will be able to access it*
06:28:30 <merijn> bollu: It's all just memory and pointers
06:28:54 <merijn> Why wouldn't you be able to access random bits because of where their allocated?
06:28:54 <bollu> merijn: AFAIK, the JVM maintains two heaps
06:28:59 <merijn> There's no "address space" in machine code
06:29:00 <bollu> merijn: because adress spaces
06:29:10 <Profpatsch> merijn: How would you get a function  readInt :: Text -> Int?
06:30:12 <Profpatsch> ,exf Text -> Int
06:31:31 <Profpatsch> :exf Text -> Int
06:31:33 <exferenceBot> \ t1 -> fromEnum (t1 Data.Eq./= t1)
06:31:41 <Profpatsch> lol
06:32:00 <kadoban> Haha, that's an interesting choice.
06:35:20 <kuribas> :t Data.Text.length
06:35:21 <lambdabot> Data.Text.Internal.Text -> Int
06:35:34 <kuribas> Profpatsch: ^^
06:35:47 <Profpatsch> const 42
06:43:54 <bollu> merijn: ping
06:43:56 <bollu> merijn: https://en.wikibooks.org/wiki/Haskell/FFI
06:44:03 <bollu> the haskell FFI tutorial does what I'm doing
06:44:10 <bollu> makes a foreign pointer
06:44:15 <bollu> and then uses unsafePerformIO on it
06:45:54 <bollu> merijn: why does that work. and not my code?
06:46:56 <bollu> merijn: (what is the functional difference)
06:49:20 <kuribas> I often disagree with hlint
06:49:28 <kuribas> like eta-reduce
06:49:44 <kuribas> or (a $ b $ c) -> a (b $ c)
06:49:54 <merijn> bollu: tbh, you'd probably have to study the Core of both to see what happens
06:50:13 <merijn> bollu: I'm not good enough to say what's going on exactly
06:50:36 <merijn> I would also not a priori rule out the wikibook being buggy until proven otherwise :)
06:50:47 <buglebudabey> i have a model that I am updating "n" times using a fold and a base model as the accumulator, is there a better way to go about that? sort of like "foldl (\acc _ -> f acc) base [1...n]"
06:50:58 <quchen> kuribas: If you often disagree with HLint, write your own config! Like this one, https://github.com/quchen/stgi/blob/master/HLint.hs
06:51:54 <bollu> merijn: I see
06:51:56 <bollu> merijn: xD
06:51:57 <kuribas> quchen: nice, thanks!
06:52:16 <quchen> kuribas: Due to API changes, the currently released ghc-mod does not respect this file, unfortunately.
06:52:26 <quchen> You can use the current HEAD of ghc-mod to remedy that though.
06:52:37 <merijn> buglebudabey: iterate + !! ?
06:52:47 <kuribas> quchen: I use flycheck
06:52:56 <merijn> :t iterate
06:52:57 <lambdabot> (a -> a) -> a -> [a]
06:53:15 <merijn> :t \f start -> iterate f start !! 10
06:53:17 <lambdabot> (a -> a) -> a -> a
06:53:48 <buglebudabey> merijn so are you saying to have (!!) be the function i pass into that?
06:54:02 <merijn> buglebudabey: No, see the last example
06:54:12 <merijn> > iterate (+1) 0 !! 100
06:54:14 <lambdabot>  100
06:54:21 <merijn> > iterate (^2) 2 !! 100
06:54:28 <lambdabot>  mueval: ExitFailure 1
06:54:34 <buglebudabey> maybe smaller numbers hah
06:54:35 <merijn> Actually, I suppose that was a bit ambitious :p
06:54:38 <merijn> > iterate (^2) 2 !! 10
06:54:41 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:54:48 <kuribas> > iterate (**2) 2 !! 100
06:54:50 <lambdabot>  Infinity
06:55:21 <kuribas> merijn: no wonder, it's infinite!
06:55:55 <quchen> :t \n -> appEndo . mconcat . replicate n . Endo
06:55:57 <lambdabot> Int -> (a -> a) -> a -> a
06:56:23 <quchen> :t \n -> ala Endo (mconcat . replicate n)
06:56:24 <lambdabot> Int -> (a -> a) -> a -> a
06:58:11 <Gilgames1> Haskell's type system is being mean to me
06:58:34 <Gilgames1> Anyone know what to do if you want to have a function work on lists however you do not know how nested these lists are
06:59:00 <kuribas> Gilgames1: use a tree datatype?
06:59:06 <Gilgames1> I am
06:59:57 <Gilgames1> Sec I can elaborate
07:00:11 <buglebudabey> if i'm running stack runghc __ is there a way i can see how long my program takes to run?
07:00:21 <quchen> time stack runghc _
07:00:25 <buglebudabey> thanks
07:00:57 <tsahyt> Just trying to gauge whether I should attempt this, so please excuse the vague and stupid question. given an existing AST type and an existing parser (although external, but bindings exist), how hard would it be to write a quasiquoter for the language implemented by the parser?
07:01:14 <tsahyt> the parser is of course at least morally pure
07:01:20 <buglebudabey> merijn oddly enough, the iterate solution takes slightly longer to run than the fold solution
07:01:57 <merijn> tsahyt: Pretty trivial
07:02:24 <tsahyt> good to hear. I suppose the it's nice to be quoted paper would be a good start to look up how it works?
07:02:30 <merijn> tsahyt: Like, "it'll probably take you longer to find and skim the docs than to actually write it"
07:02:38 <tsahyt> because writing those ASTs by hand is a massive pain
07:03:06 <kuribas> buglebudabey: also with -O2?
07:03:21 <buglebudabey> kuribas not sure what you mean, haven't seen that before
07:03:37 <buglebudabey> i breathe it sometimes
07:03:43 <kuribas> buglebudabey: -O2 flag to ghc, it means optimize well.
07:04:02 <buglebudabey> kuribas ill try it out
07:04:57 <merijn> tsahyt: I had a decent tutorial for it but can't find it quickly
07:05:06 <tsahyt> merijn: how about the anti quotation bits? I really just need to put Text values and maybe some Ints in there
07:05:25 <buglebudabey> kuribas seems almost identical now, iterate lost on sys time and fold lost on user time
07:07:03 <merijn> tsahyt: This seems an ok example to work with: http://dev.stephendiehl.com/hask/#template-haskell
07:08:17 <tsahyt> merijn: thanks
07:08:58 <merijn> tsahyt: tbh, my personal experience is that I spend like a couple of hours figuring out what the hell TH actually meant, and then quickly realised "oh...that's it?" The actual mechanics are pretty simple, but doing complex things like deriving modules, etc. gets a bit tricky since you need to inspect modules, extract types, etc.
07:09:13 <merijn> tsahyt: For simple "convert text to Foo" stuff it's pretty straightforward
07:14:14 <bollu> how do I generate an Int in a certain range from Arbitrary?
07:14:17 <bollu> (quickcheck)
07:14:53 <athan> bollu: chose iirc
07:14:57 <athan> er choose*
07:15:32 <bollu> athan: nope :( can you help me look?
07:15:37 <athan> er... something that starts with a `c` I remember; it looks like `choose (1,n)` to pick one
07:15:48 <athan> I would but I'm on a dinky tablet :(
07:15:50 <tsahyt> merijn: yes, all I need is just embed a specific language, plus some antiquotation to make it useful. So far it doesn't look too hard indeed. The example you posted looks pretty trivial.
07:16:34 <merijn> tsahyt: You really just need a Lift instance for your datatype (actually, even that is optional, but then you have to redo the parsing at runtime)
07:17:02 <athan> bollu: You could also just `mod` it: `(mode(arbitrary :: Gen Int)
07:17:06 <bollu> oh, it is "choose"
07:17:06 <athan> grrr tablet
07:17:08 <bollu> heh right
07:17:12 <tsahyt> merijn: I suppose the fact that the data type is parametric doesn't matter, as long as the type parameters have a lift instance too, right?
07:17:18 <athan> (mod n) <$> arbitrary
07:17:42 <athan> woot! Don't need that cranial checkup after all!
07:17:50 <merijn> tsahyt: Template Haskell can run completely arbitrary (including IO) haskell at compile time, so parsing from an external file or whatever is simple too. Then you just need to convert the result into the datatype you want (AST or not) and stuff into this quasiquoting record to use
07:17:55 <merijn> tsahyt: Yeah
07:18:01 <tsahyt> merijn: also, I'm thinking of implementing the Lift instances in a separate module, i.e. Foo.AST holds the AST, and Foo.AST.QQ the quasiquoter plus the necessary instances. is that a bad idea, since those are going to be orphans?
07:18:38 <merijn> tsahyt: I would generally avoid the orphan and put Lift in the same module (although I think ghc8 or the next one) have auto-derivation of Lift
07:18:39 <bollu> merijn: interesting
07:18:50 <bollu> merijn: it looks like the error was because of some Int thing o_O
07:18:54 <bollu> like, representation error?
07:19:02 <athan> merijn: Is it true though that a TH splice cannot "create" a value in haskell-land unless the value can be determined statically?
07:19:04 <merijn> bollu: Which platform are you working on?
07:19:11 <bollu> merijn: macOS sierra
07:19:18 <bollu> merijn: I'm not 100% sure
07:19:19 <tsahyt> merijn: the main module already compiles for about a minute or so due to all the deriving I'm doing there
07:19:24 <merijn> bollu: oh, be careful there
07:19:26 <bollu> merijn: but I just ran 50k quickcheck tests without a crash
07:19:31 <tsahyt> those are about 30 or 40 types or so, all with a bunch of instances that can be useful
07:19:33 <merijn> bollu: 64bit haskell has 64bit Int
07:19:40 <tsahyt> it's a pretty big AST
07:19:44 <bollu> merijn: yeah so I'm focibly bounding int
07:19:49 <merijn> bollu: But CInt (i.e. int in C) is *not* 64bit on OSX
07:19:55 <bollu> merijn: ah
07:19:58 <bollu> merijn: oh holy fuck what
07:20:06 <merijn> bollu: Make sure you use the correct Foreign.C.Types type in the FFI
07:20:17 <athan> something something word64?
07:20:20 <bollu>   Symbols of Ints - Ring
07:20:21 <bollu>     (+) commutativity:                         OK (1.73s)
07:20:21 <bollu>       +++ OK, passed 100000 tests.
07:20:21 <bollu>     (+) associativity:                         OK (2.73s)
07:20:21 <bollu>       +++ OK, passed 100000 tests.
07:20:27 <bollu> merijn: I feel so stupid :(
07:20:43 <merijn> bollu: For a long time the OSX kernel was 32bit with a 64bit userland, so int needed to be 32bit for userland to communicate with kernel
07:20:44 <athan> bollu: Don't feel stupid, _be_ stupid!
07:21:03 * athan jk, sorry I'll go back to my shame corner
07:21:17 <nitrix> Stupid & lazy, like peanut butter and jelly :3
07:21:25 <merijn> athan: A TH splice cannot create non-Lift values at compile time. I'm not sure what you mean by "statically" :)
07:21:41 <bollu> athan: :)
07:21:46 <athan> oh wow! Lift is a typeclass..?
07:22:09 <athan> that just sounds funny
07:22:35 <merijn> athan: Lift is basically what teaches GHC how to convert values into ASTs
07:23:00 <athan> :O okay shoot
07:23:24 <merijn> athan: Eh, that was all there is to know about it :p
07:24:11 <nitrix> Hi, I'm trying to allow mutable ADTs while keeping them pure using linear types trickery. It started with a phantom type and something akind to ST and now leading to type families and free monads... does anyone know if this has been done before and/or resources to move forward?
07:24:40 <athan> nitrix: Like -XLinearTypes? :x
07:25:08 <nitrix> athan: Is this now in GHC?
07:25:15 <merijn> nitrix: I wish
07:25:17 <athan> no it shouldn't be
07:25:20 <tsahyt> merijn: there's a problem though. the parser that I'm provided with is completely opaque (it's actually part of a C library), so I can't change that to use antiquotation the way I want to
07:25:46 <merijn> tsahyt: What does the parser being C matter? The result is a Haskell ADT, no?
07:25:58 <athan> nitrix: How would your design allude to a type family?
07:26:21 <tsahyt> merijn: yeah but how can I use haskell values in the language then?
07:26:26 <tsahyt> I thought that's what antiquotation is for
07:26:36 <tsahyt> and the examples I see all change the parser to use antiquotation
07:27:07 <nitrix> athan: http://lpaste.net/349930, http://lpaste.net/349931
07:27:08 <merijn> tsahyt: You run the parser + C code at compile time, you get a resulting Haskell AST type, then you use Lift to turn it into an AST and you're done?
07:27:10 <nitrix> athan: Not by me.
07:28:08 <nitrix> athan: A given cake cannot be kept if previously eaten, the reverse seems possible.
07:28:10 <tsahyt> merijn: say it's a simple expression language, then I can't have something like [foo|$bar + 3] though, where bar is a value that is in scope in Haskell
07:28:29 <tsahyt> the concrete case is something like "$ident(X) :- constant(X)" or whatever
07:28:41 <athan> that looks nice nitrix
07:28:44 <tsahyt> and I want $ident to become the contents of the ident binding
07:29:58 <tsahyt> oh wait, that's not what antiquotation means, does it?
07:30:21 <nitrix> athan: I'm reading as much as I can on the subject. My goal is to provide a highly abstracted library that'd let you "patch" any given ADT to grant it O(1) access and updates at any local point. Kinda like lens but better performance.
07:30:40 <nitrix> athan: But it'll be a lot of unsafePerformIO hackery, which means I need to take care of not breaking referential transparency.
07:31:07 <athan> oh lord nitrix that is crazy lol
07:31:35 <tsahyt> merijn: I think I've got my nomenclature mixed up here. what does antiquotation mean really? What I need is to take haskell values and basically substitute them in the language to be quoted
07:31:38 <athan> how do you index into the AST's sum-of-products structure?
07:31:54 <tsahyt> i.e. the resulting AST does depend on runtime values
07:31:58 <athan> or is that implicit in the lens you provide? (if thats how you designate the area to be mutated)
07:32:05 <merijn> tsahyt: I'm not sure of what antiquotation means, I've not heard it before
07:32:32 <merijn> tsahyt: Ah, that's not something you said before :)
07:32:35 <athan> coanticoquotationization
07:32:45 <fryguybob> nitrix: I think you would also need to consider GC.
07:33:01 <merijn> tsahyt: Then you'd have to be a bit more tricky and instead of generating the full AST, generate, essentially a function that takes the runtime values as input and produces the AST
07:33:13 <c_wraith> nitrix: does the zippers package not do that?
07:33:14 <tsahyt> I'm not sure how I'd do that
07:33:15 <merijn> That's still possible, but a bit trickier
07:33:27 <tsahyt> given that the parser is essentially just a binary somewhere, I can't change it
07:33:39 <nitrix> c_wraith: Interesting if it does. I'll definitely check.
07:33:46 <merijn> tsahyt: So the parser can't run until runtime because it needs parameters?
07:33:52 <merijn> (runtime parameters)
07:34:56 <tsahyt> well the only thing the parser depends on is the input code. and that technically depends on runtime values. but it's basically the same as having a function taking some values to an AST, as you said
07:35:29 <nitrix> athan: I'm in the process of figuring that part out. I'll probably start with simple use cases. I'd be okay with just container-like stuff, say Map.
07:35:30 <tsahyt> so what I'd really like is to run the parser at compile time, and create an AST with "holes" where the runtime values go
07:35:34 <merijn> tsahyt: So the stuff to parse depends on input values?
07:35:39 <tsahyt> yes
07:36:02 <tsahyt> but only in a few places. running the parser at runtime over and over again is not a good option
07:36:10 <merijn> tsahyt: that's trickier, unless you can split up the text in things that can be parsed independently
07:36:12 <nitrix> athan: Ironically, changing a value and not the structure reminds me of a functor. I wonder if the handle you have to do the mutation could be a mere functor.
07:36:25 <tsahyt> merijn: only into statements, that's the most finegrained I can get
07:36:45 <merijn> tsahyt: Right, but would that be enough? If you only had to reparse statements with holes?
07:36:48 <nitrix> athan: Anyway. So that GHC extension, it's still just a proposal?
07:36:52 <athan> nitrix: oh totally, setters are generalized maps
07:36:57 <tsahyt> merijn: but this should all be possible. I mean yesod does similar things, building blaze (I think) ASTs and inserting data at runtime
07:37:18 <tsahyt> merijn: I'd like to avoid reparsing at all
07:37:37 <tsahyt> All I want to do is get rid of the manual AST writing
07:37:47 <merijn> tsahyt: Yes, but blaze stuff doesn't have to parse first
07:38:00 <tsahyt> merijn: it does, the template language is not haskell
07:38:04 <merijn> tsahyt: Well, I suppose a bit, but they control the parser
07:38:15 <athan> nitrix: yeah just a proposal right now, but I'm fiendishly anticipating its arrival
07:38:17 <merijn> tsahyt: I mean that blaze has support *in the parser* for holes
07:38:24 <tsahyt> well shit
07:38:32 <tsahyt> I mean I guess I could just hack a parser
07:38:38 <merijn> tsahyt: Without the ability to retrofit that into your parser you can't really do it, I think?
07:38:43 <nitrix> athan: Wouldn't it be nice :) ?   lookup :: Instant Map k v -> k -> Maybe v
07:39:14 <tsahyt> merijn: well I guess I could reserve special values, then traverse the AST afterwards and swap them as needed
07:39:39 <tsahyt> not sure if something sane works with the conventions for identifiers in this language
07:39:45 <nitrix> I guess it'd need another special type for the lookup key, some form of lens-like stuff.
07:40:07 <nitrix> Let's build on top of lens! Edward, let me abuse your library :D
07:41:37 <tsahyt> merijn: then again trying to traverse the AST is about as hard as just building it from scratch
07:41:44 <tsahyt> so I'm not sure I even win anything that way
07:43:49 <tsahyt> merijn: alternatively I could write a DSL that spits out an AST at the end, but that's a lot more work
07:43:54 <tsahyt> eDSL that is
07:46:18 <merijn> tsahyt: I think it's all roughly the same amount of work in the end
07:56:57 <nitrix> athan: Do you think I could achieve the same with just a phantom type? ST pulls it off, you can't keep individual copies of STRef.
07:57:20 <nitrix> You can, though, make copies inside the ST context :/
07:57:36 <nitrix> s/context/thread/
07:58:53 <athan> nitrix: Wait, i don't know what you mean
07:59:05 <athan> I would honestly consider keeping it pure, if you're concerned over performance
07:59:21 <athan> I've seen some mighty fine pure compilation routines
07:59:22 <mniip> bgamari, "Not only do orphan instances come at a compile-time cost," what kind of cost?
07:59:59 <athan> mniip: extra entity in the dictionary?
08:00:12 <nitrix> athan: My ultimate goal is to write a system that allow relational data to be modified with constant time.
08:00:17 <athan> i could see overlapping instances borking around with the constraint solver
08:01:02 <nitrix> athan: Even some of the nicest libraries, like Ixset, are logarithmic. Even lenses, copy a whole lot of stuff :/
08:01:09 <athan> like relational algebra stuff nitrix? I'm not sure if this is a solvable problem in the general aspect
08:01:25 <athan> there's some cool mutable container libraries though
08:01:30 <athan> @hackage stm-containers
08:01:31 <lambdabot> http://hackage.haskell.org/package/stm-containers
08:01:37 <athan> @hackage hashtables
08:01:37 <lambdabot> http://hackage.haskell.org/package/hashtables
08:01:53 <athan> idk about lens :s
08:01:57 <nitrix> Presumably, if I pull off my solution, you could even update a list in place in O(1).
08:02:16 <nitrix> Which you just cannot do normally with the basic Haskell constructs :/
08:03:44 <fryguybob> nitrix: You can't do that with the assumptions that GC makes.
08:05:14 <athan> and also fusion something something (oop too late sorry can't answer!)
08:05:54 <nitrix> fryguybob: Why is that?
08:07:19 <fryguybob> nitrix: The GC is generational where objects in young generations do not point to objects in old generations.  If you break that, live objects could be collected.
08:08:18 <fryguybob> nitrix: The heap objects that can be mutated all have special consideration in the GC and special code to ensure that they are handled correctly.
08:08:28 <nitrix> fryguybob: I can probably use some for of stable pointers. IORef or Weak with it.
08:08:59 <fryguybob> nitrix: At which point you have lost any performance benefit you hoped to gain .
08:09:27 <nitrix> fryguybob: Isn't it just an extra layer of indirection?
08:11:17 <fryguybob> nitrix: Not stable pointers.  For IORef's there is indirection as well as GC write barriers.
08:11:37 <bgamari> mniip, GHC needs to read more interface files to find the instance
08:13:35 <fryguybob> nitrix: This proposal would give you more things to work with: https://github.com/simonmar/ghc-proposals/blob/mutable-fields/proposals/0000-mutable-fields.rst
08:14:33 <theduke> I think I'm misunderstanding DataKinds. I thought it would make this possible:   Data D = A Int | B Float;  someFn :: A -> String
08:14:41 <theduke> but this gives the error "Expected a type, but 'A has kind Int -> Test"
08:15:03 <athan> theduke: The issue with functions is their kind
08:15:11 <athan> @kind (->)
08:15:13 <lambdabot> * -> * -> *
08:15:26 <athan> notice it's explicitly *, and not something like D
08:16:18 <athan> @type Proxy
08:16:19 <lambdabot> forall k (t :: k). Proxy t
08:16:26 <athan> ^ check that out theduke
08:16:42 <athan> notice that it can use a type parameter, from _any_ kind
08:18:23 <Kestrel-029> Hey, what's the command to get the type of a variable?
08:18:37 <bengt_> :t or :type
08:18:38 <lambdabot> error: parse error on input ‘type’
08:20:30 <nitrix> fryguybob: "The GC write barrier for a mutable constructor may be a little less efficient than the write barrier for a MutVar#, but this is more than compensated for by losing a layer of indirection."
08:20:32 <nitrix> fryguybob: I see.
08:21:18 <athan> "Just use type application via @Foo in a template haskell splice to get rid of that ambiguous skolemized type variable, what's the problem?"
08:22:43 <nitrix> fryguybob: Oh the proposal is by simon marlow; it might actually see the light :)
08:23:06 <fryguybob> nitrix: Yes, I'm working on implmenting it for STM.
08:23:07 <bollu> athan: xD that sounds reasonable tbh :P
08:23:12 <bollu> athan: without context
08:24:13 <bollu> how do I generate "Ratio"s?
08:24:23 <bollu> there doesn't seem to be an Arbitrary instance?
08:24:26 <nitrix> fryguybob: What would you recommend for my crazy idea of pure mutable containers?
08:24:34 <nitrix> fryguybob: "Don't try it?"
08:25:32 <bollu> long maps to CLong in the FFI, correct?
08:25:37 <nitrix> The solution earlier with linear types was fairly interesting.
08:26:02 <nitrix> fryguybob: (and unsafePerformIO hackery)
08:26:07 <fryguybob> nitrix: I'm not saying don't try it, just that there is an assumption that that does not happen that is baked in to much of how GHC's runtime system works.
08:27:16 <nitrix> fryguybob: So even if it's semantically sound (referential transparency is preserved) and the type checker is happy, I might still see runtime issues?
08:27:21 <fryguybob> nitrix: Even if something works with unsafePerformIO it may not work under something like STM too.
08:27:52 <fryguybob> nitrix: You most certainly would see problems if you didn't modify the runtime system.
08:28:26 <fryguybob> (Or make restrictions like single threaded runtime, single generation heap)
08:30:20 <nitrix> fryguybob: Thanks. That's very informative. You might've saved me a couple hours ahah. I appreciate :)
08:30:58 <fryguybob> nitrix: I'm glad whenever my *days* of time tracking down what turned out to be GC breaking changes can save anyone some time :D
08:36:04 <ski> nitrix : "I'm trying to allow mutable ADTs while keeping them pure using linear types trickery.","My goal is to provide a highly abstracted library that'd let you "patch" any given ADT to grant it O(1) access and updates at any local point. Kinda like lens but better performance." -- have you checked out uniqueness in Clean and Mercury yet ?
08:37:15 <bollu> ski: Rust as well? 
08:38:18 <bollu> CLong doesn't have an arbitrary instance. How do I generate arbitrary CLongs?
08:39:32 <tdammers> > fromIntegral (23 :: Int) :: CLong
08:39:35 <lambdabot>  error:
08:39:35 <lambdabot>      Not in scope: type constructor or class ‘CLong’
08:39:38 <tdammers> awww
08:40:10 <ski> bollu : possibly. i don't know that much about Rust yet
08:40:32 <bollu> tdammers: yeah :(
08:41:08 <tdammers> anyway, generate an Int and fromIntegral it to CLong, that should work
08:41:15 <bollu> hm
08:41:40 <nitrix> ski: I haven't.
08:41:44 <ski> @let import Foreign.C
08:41:45 <lambdabot>  Defined.
08:41:47 <ski> > fromIntegral (23 :: Int) :: CLong
08:41:49 <lambdabot>  23
08:43:14 <nitrix> ski: I'm aware my request makes little sense; I just want a way to not pay the O(log n) cost that's inheritant to immutable data structures. Sure it's great, most of the time, but not when you do a lot of updates, as it needs to fix a ton of pointers.
08:43:42 <ski> nitrix : if you know that you've the only reference to e.g. a list (and all its tails), then you can e.g. do append by update-in-place. in Clean and Mercury, it's overloaded (more or less), so that if you call it with a unique front list, it'll use a different compiled version of append (same source code, though), that'll do the update-in-place
08:43:43 <nitrix> ski: If there's a single instance of it, Haskell should let you do in-place updates :/
08:44:10 <nitrix> ski: That's precisely what I'm trying to implement in Haskell :/
08:45:10 <ski> nitrix : in Clean, they express this by uniqueness polymorphism (with inequality bounds in general case, iirc). in Mercury, you have multiple mode declarations (in this case handling the unicity stufF) going together with the single type declaration, so separating uniqueness from types. still a single source implementation
08:45:42 <nitrix> ski: Was my idea of linear types going south or it could work?
08:45:44 <Kestrel-029> So I'm trying to code haskell aftera hiatus so this might seem like an obvious question but I keep getting an error on a very basic function
08:45:46 <ski> nitrix : afaiui, you want uniqueness, not linearity, for this kind of thing, though
08:45:51 <nitrix> Oh.
08:46:02 <Kestrel-029>   addition :: Int -> Int -> Int
08:46:04 <Kestrel-029>   addition a b = a+b
08:46:06 <Kestrel-029> Give this error:
08:46:08 <Kestrel-029> parse error on input ‘=’
08:46:12 <Kestrel-029>     Perhaps you need a 'let' in a 'do' block?
08:46:14 <Kestrel-029>     e.g. 'let x = 5' instead of 'x = 5'
08:46:19 <ski> nitrix : .. i didn't read the full backlog (and i have to leave in a few minutes). just wanted to point to something hopefully useful
08:46:44 <nitrix> ski: I'll look at unique types then. Thanks for the heads up.
08:47:22 <ski> at least with the "usual" way to implement things, linearity ensures that you can't duplicate your linear reference in the *future* (it might have been duplicated in the past, before demoting from a shared to a linear reference)
08:47:22 <ertes> Kestrel-029: 1. please use a pastebin like lpaste.net for longer pastes, 2. could that code be indented?
08:47:28 <ertes> oh, and…
08:47:29 <ertes> helo
08:47:39 <nitrix> ski: Ah, gotcha.
08:47:42 <Kestrel-029> ertes, sure will do next time, sorry
08:47:48 <ski> while with uniqueness, it ensures that the reference haven't been duplicated *yet* in the past (but might be in the future)
08:48:12 <ski> nitrix : at least that's roughly how edwardk explained the difference to me :)
08:48:13 <nitrix> Idris apparently has uniqueness types.
08:48:26 <Kestrel-029> ertes, yeah it was indentation, thanks (silly me) >.<
08:48:26 <grantwu> > addition a b = a + b
08:48:28 <lambdabot>  <hint>:1:14: error:
08:48:28 <lambdabot>      parse error on input ‘=’
08:48:28 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:48:36 <nitrix> And I read here that it's a nice substitute for doing I/O operations in functional languages in lieu of monads.
08:48:44 <nitrix> We'll see how it goes.
08:48:44 <ertes> Kestrel-029: other than that the code looks fine to me
08:48:59 <nitrix> ski: "The term is often used interchangeably with linear type, although often what is being discussed is technically uniqueness typing, as actual linear typing allows a non-linear value to be "cast" to a linear form, while still retaining multiple references to it. Uniqueness guarantees that a value has no other references to it, while linearity guarantees that no more references can be made to a value."
08:49:05 <nitrix> ski: That seems aligned with Edward and you.
08:49:16 <Kestrel-029> ertes, yeah that's why I had to ask. I'm mainly used to Java which doesn't complain as much about indentations
08:49:45 <edwardk> uniqueness is forgettable, you can give a unique thing to someone and they can pass it out to all their friends, but upon doing so uniqueness is forgotten.
08:49:56 <ski> uniqueness types can be a replacement for using an abstract monad to hide a state that shouldn't be duplicated. one advantage to doing it "raw" like this is that the compiler (and you) has more room to move code around, you haven't over-sequentialized everything
08:50:18 <ski> otoh, you still have verbosity, so monads (or applicative functors) could still be useful in reducing that
08:50:21 <byorgey> Kestrel-029: Java doesn't complain about indentation at all =)
08:50:36 <ertes> edwardk: (i solved my problem)
08:50:38 <ski> (and obviously uniqueness doesn't handle other kinds of monadic (or applicative) effects)
08:50:59 <Kestrel-029> true byorgey :P although I keep some form of it for conventional purposes but Haskell takes it to a new level lol
08:51:08 <edwardk> 'unrestrictedness' or the ! modality in linear logic is also forgettable. you have a logic in which you aren't free to use duplication: the rule that A -> (A,A), but where you have some types !A that permit it, and which offer !A -> A.  once you forget the ! you can't get it back.
08:51:22 <byorgey> Kestrel-029: right =)
08:51:29 <edwardk> if you look at it categorically ! is actually a comonad
08:52:00 <ski> .. also, even if you have uniqueness, something like the `ST s' monad would be useful. Mercury as it, e.g. <https://www.mercurylang.org/information/doc-latest/mercury_library/store.html> (did i already mention this to you, recently ? perhaps it was someone else)
08:52:10 <edwardk> i leave the studying of relevance/affinity/uniqueness modalities from a categorical perspective to the reader i've forgotten most of the details
08:52:30 <nitrix> I'm the reader :D
08:53:14 <edwardk> even with uniqueness monads are handy to have. i had a nice project where i had a monad that would have perfectly been expressed in Clean, but the language isn't well designed around supporting classes like Monad very well.
08:53:15 <ski> nitrix : <https://www.mercurylang.org/information/doc-latest/mercury_ref/Unique-modes.html> is the Mercury docs for uniqueness. also some papers in <https://www.mercurylang.org/documentation/papers.html> are probably also helpful
08:53:23 <ertes> edwardk: is something like 'try' the reason why trifecta's Parser is not a transformer?  because i basically solved my problem by making it a non-transformer
08:53:24 <nitrix> edwardk: I was discussing how one would build in-place updates in a given ADT while preserving purity in Haskell, and it lead to unique types.
08:54:03 <ski> nitrix : Clean manual <http://clean.cs.ru.nl/download/html_report/CleanRep.2.2_1.htm>
08:54:28 <nitrix> ski: No offense but, isn't Clean and Mercury even less used than Haskell :S ?
08:54:32 <nitrix> ski: I like my Haskell.
08:54:33 <edwardk> ertes: <|> should cancel the 'effects' of exploring the branch you just tried. hard to roll back IO
08:55:12 <ski> nitrix : sure. just pointing at things you could read, to get ideas for prior work (also Mercury is cool in other ways, imho. there's even a channel #mercury here)
08:55:30 <edwardk> nitrix: it'd be nice, but keep in mind uniqueness carries a lot of pretty heavy costs in terms of what optimizations are permitted. lambda lifting/lowering etc. all affect uniqueness information
08:55:52 <edwardk> so if these things become part of your semantics large numbers of existing optimizations cease to be legal
08:56:35 <nyuszika7h> it seems Chrome on my phone doesn't trust haskell.org's cert as it's not signed by a trusted CA... which is weird because it's signed by GlobalSign
08:56:38 <edwardk> also in some ways i'd rather get uniqueness information through the active assistance of the garbage collector as it is actually a recoverable state.
08:56:47 <nitrix> edwardk: Noted. On the other hand, you gain really quick lookups and updates, O(1) instead of some O(log n) degenerative.
08:56:51 <edwardk> if you're just using it to get better operational behavior
08:57:23 <ertes> edwardk: if that weren't a requirement, could an input-backtracking (<|>) implemented for a parser monad that is both church and a transformer?  just a yes/no would suffice…  if yes, i'll eventually figure it out myself
08:57:37 <nitrix> edwardk: Yeah, entirely operational. If I could, I'd keep the type as it is. Map would just stay Map, but the uniqueness needs to be encoded somehow.
08:57:47 <nyuszika7h> https://goo.gl/photos/FKw5za3UVWd1DmMx5
08:57:55 <ski> (getting guarantees would in some cases be really handy, as opposed to hoping optimizations (compile-time or run-time) gives you benefits)
08:58:25 <edwardk> ertes: well, depends on your semantics for <|>. if you want effects to not roll back then sure.
08:58:35 <edwardk> but those semantics are often quite surprising
08:58:48 <ski> (one could imagine uniqueness being expressed in low-level module inferface, but not (usually at least) in surface-level code, letting the compiler infer where to insert uniqueness stuff)
08:58:54 <Profpatsch> Will DeriveAnyClass try to derive instances for all classes, or just ones specially marked by the authors?
08:59:06 <ski> nitrix : have fun. must leave
08:59:11 <nitrix> ski: Cheers!
08:59:17 <ertes> edwardk: oh, further requirement: incremental input…  that's the main thing that's tripping me up
08:59:21 <edwardk> ski: yeah, but the fact that the gc can 'restore' uniqueness is something i definitely want to explore some day when i have infinite free time ;)
09:00:03 <edwardk> ertes: incremental input is one reason why i tend to shy away from transformer parsers, or limit the effect to the 'fetch more input' form
09:00:11 <nitrix> edwardk: Just make sure you solve the uniqueness problem only after you've cloned yourself :P
09:00:17 <nitrix> edwardk: Catch-22 :P ?
09:00:30 <nyuszika7h> > signum (-0.0)
09:00:33 <lambdabot>  -0.0
09:00:33 <ertes> edwardk: yeah, i see what you mean…  i don't insist on a transformer, i'm just curious whether it's possible
09:00:34 <nyuszika7h> this is weird
09:00:49 <edwardk> the attoparsec approach of letting you feed the parser from 'outside' has worked as a pretty good cultural compromise
09:01:15 <edwardk> and separates out the m effects for feeding the parser from the parser type itself
09:02:00 <edwardk> but i think in general there isn't a form of parser that does the sane backtracking thing that is itself a transformer. this is why parsers has instances for lifting parsers over transformers. you can use StateT s Parser, but not ParserT (StateT s)
09:02:08 <edwardk> er ParserT (State s)
09:02:08 <ertes> edwardk: yeah…  reason i'm exploring this is that i basically need a mini-trifecta…  something that is as fast as manual splitAt, no error reporting, no fancy features at all
09:02:16 * ski . o O ( external vs. internal iteration, composable continuations )
09:03:14 <edwardk> when writing a parser i tend to think in terms of transformers applied to my parser type, and if the parser needs effects then i'll usually build some m effect as the result of the parser to run once i finish parsing
09:03:59 <edwardk> this isn't the answer you want, but its the answer i've found i can assign reasonable semantics to
09:04:15 <ertes> edwardk: sure…  the effects are mostly input effects, so incremental parsing is good enough…  i don't need parse effects that would leak from the parser
09:04:28 <ertes> edwardk: actually it is the answer i want =)
09:04:43 <ertes> edwardk: i'm researching, so there is no answer i don't want =)
09:05:00 <ertes> also it aligns well with what i have found myself
09:08:16 <ertes> edwardk: another question, if you don't mind:  since trifecta's Parser is not a transformer what's your reasoning to go with church encoding?  is there some constant speed advantage, or is it just convenience?
09:08:33 <edwardk> as asymptotics
09:08:40 <edwardk> not just constant
09:08:50 <ertes> even as a non-transformer?
09:08:52 <edwardk> yep
09:09:41 <edwardk> >>= is really expensive in a traditional form
09:09:58 <Profpatsch> nvm, I found out by means of rtfm
09:09:58 <ertes> hmm
09:10:04 <edwardk> this is analogous to the free monad >>= problem
09:10:10 <ertes> edwardk: ah, you're reassociating (>>=)?
09:10:14 <edwardk> yeah
09:10:18 <edwardk> this forces all >>='s to the right
09:10:25 <ertes> i see…  nice!
09:10:33 <edwardk> as literally every parsing combinator is multiple things in a left associated bubble
09:10:38 <ertes> i thought it would only do that for the underlying monad of a transformer
09:11:18 <edwardk> setting things up in cps'd form automatically right associates all the things, in exchange for making many/some require manual implementation
09:12:08 <edwardk> you can see some huge performance increases from parsec 3 to 3.1 or so from the same thing
09:12:46 <bollu> what is the correct way to use unsafePerformIO with foreign pointers?
09:13:43 <edwardk> bollu: "very carefully"
09:16:25 <ertes> edwardk: is there a particular reason you went with church instead of scott?
09:17:02 <bollu> edwardk: :)
09:17:07 <bollu> edwardk: tutorial or something please?
09:17:15 <bollu> edwardk: this is crashing
09:18:23 <ertes> bollu: here is my tutorial: you must assume that your IO action may run at any point during execution, and that you don't know how often it will run
09:18:23 <bollu> edwardk: https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L134
09:18:41 <bollu> ertes: that is OK by me because I'm using a foreignPtr
09:18:43 <ertes> bollu: the usual haskell consistency guarantees are out the window
09:18:44 <bollu> but it is still crashing
09:18:45 <gameer> Hey Guys. Can u recommend a page with exercises? I am actually reading learnyouahaskell, but I miss a bit the practice :/
09:18:47 <glguy> ertes: maybe start series of twitter-hosted tutorials? :)
09:18:57 <bollu> ertes: could you please check my code ?
09:19:01 <ertes> glguy: hehe
09:19:06 <bollu> this is failing: https://github.com/bollu/symengine.hs/blob/master/test/Spec.hs#L137
09:19:09 <bollu> (identity of +)
09:19:15 <bollu> it crashes with a "dobule free"
09:19:16 <bollu> double*
09:19:21 <bollu> I would love to know how to fix this
09:19:40 <mmaruseacph2> gameer: try doing the advent-of-code puzzles in Haskell
09:19:51 <glguy> gameer: adventofcode.com is running a series of small programming problems you can do this month . http://cis.upenn.edu/~cis194/spring13/lectures.html has a bunch of exercises
09:20:09 <mmaruseacph2> then, if you want, you can also join the private leaderboard with code AoC: 43100-84040706
09:20:12 <ertes> bollu: sorry, no…  i would just do the same kind of guesswork you have to do right now…  if you can, avoid unsafePerformIO
09:20:17 <bollu> :(
09:20:26 <bollu> ertes: but, like, I want Num instances on it
09:20:33 <bollu> because it's a symbolic math variable
09:21:03 <gameer> Would you say my haskell"skills" are enough for adventofcode? I dont know monades actually
09:21:10 <gameer> (but I can work in them ofc)
09:21:16 <gameer> Can try
09:21:19 <mmaruseacph2> gameer: most of the code there doesn't need monads
09:22:15 <ertes> bollu: i'm not saying don't do it…  i'm saying: i won't brute-force the bug for you =)
09:23:09 <bollu> ertes: fair :)
09:23:18 <bollu> ertes: but it is "possible" right?
09:24:02 <ertes> bollu: probably…  i don't know
09:24:09 <ertes> if it's semantically pure, then sure
09:28:51 <ertes> bollu: the thing is: in my ~9 years of haskell i have successfully avoided unsafePerformIO; i've never used it once, and even ForeignPtr i've never used for anything practical, just experimentation, so i'm really not the right person to look at your code
09:29:29 <bollu> ertes: very well 
09:29:41 <bollu> ertes: I *need* this for library though. Otherwise usability drops like hell
09:32:13 <ertes> bollu: i would probably make a safe IO/ST interface first and then wrap that one instead of wrapping something low-level directly
09:32:20 <bollu> okay
09:32:22 <bollu> ertes: hm
09:32:30 <bollu> ertes: how would you wrap an IO interface?
09:33:18 <ertes> bollu: probably using unsafePerformIO, but if the IO interface has safe and well understood semantics, then you have a better chance at predicting the behaviour of the wrapped thing
09:33:41 <bollu> ertes: it does have safe semantics which is what bugs me. it is literally "allocate memory, run function"
09:33:46 <bollu> ertes: it's a two liner
09:33:57 <bollu> "function only affects allocated memory, hence referentially transparent"
09:34:09 <bollu> (parameters are all "const")
09:34:28 <bollu> I'm trying to allow GHC to manage the memory now with alloca
09:34:36 <bollu> so that maybe GHC knows the chunk of memory
09:34:48 <bollu> idk, at this point I'm just experimenting with despair :P
09:35:23 <ertes> bollu: referential transparency has nothing to do with that…  you have an effectful API, and your goal is to turn it into a non-effectful API
09:35:50 <bollu> ertes: yes, it runs no "effects" beyond allocating some memory and calling a function on the newly allocated chunk
09:35:55 <ertes> if it overwrites allocated memory you need to ensure that you make copies as appropriate, etc.
09:35:56 <bollu> ertes: nothing is modified
09:36:03 <ertes> ah, i see
09:36:19 <ertes> what do you need ForeignPtr for then?
09:37:01 <bollu> ertes: because the new chunk of memory needs to be freed at some point :)
09:37:05 <bollu> ertes: it's a matrix
09:37:29 <ertes> bollu: why don't you use the vector library?
09:37:49 <bollu> ertes: because I'm writing bindings for SymEngine (a symbolic math library in C/C++) to haskell
09:38:33 <ertes> bollu: ah, but the matrices are represented as arrays of elements?
09:38:54 <bollu> ertes: no, just some internal representation that doesn't matter to Haskell. (the API doesn't expose the internal repr)
09:39:00 <bollu> ertes: I want to call matrix_add
09:39:10 <bollu> matrix_add(dest, a b)
09:39:13 <bollu> is the signature
09:39:25 <ertes> so it works similar to GMP?
09:39:33 <bollu> I suppose, yes
09:39:51 <bollu> GMP is more about numerical though (AFAIK), this is symbolic 
09:41:18 <ertes> yeah, but it's the same interface?  you allocate an mpz_t z (which is a mutable integer), then you say something like:  mpz_add(z, x, y);
09:41:35 <bollu> yep
09:41:50 <bollu> same interface :)
09:42:36 <ertes> ok, ForeignPtr seems plausible for that…  you should be able to write a nice ST interface
09:43:57 <ertes> unsafeIOToST is the function that you use when you promise that your effects are not observable from ST
09:44:01 <ertes> from outside of ST
09:44:11 <ertes> it's generally a much safer choice than unsafePerformIO
09:44:25 <bollu> ertes: what is the difference?
09:45:06 <ertes> then since your matrices are immutable you can just semantically copy an ST reference to an immutable matrix…  technically it would be a no-op
09:45:18 <ertes> similar to how unsafeFreeze works for Vector
09:45:27 <ertes> or 'create'
09:45:49 <ertes> that's one way to get a safe pure interface
09:46:02 <bollu> hm
09:46:04 <ertes> most importantly it doesn't involve unsafePerformIO
09:46:22 <ertes> oh, wait…  it does
09:47:08 <ertes> for things like 'modify' it does, because you need something like unsafeThaw as well to get back into ST
09:48:29 <ertes> bollu: in any case the basic idea is:  clearly define the boundary between mutable and immutable the way the vector library does
09:48:43 <bollu> hm
09:48:44 <ertes> then if you have a bug like this, you will know where to look
09:56:15 <cocreature> bollu: do you have a specific usecase for symengine? just wondering because I’ve never heard of it before
09:57:20 <AndChat89889> Hello
09:57:23 <bollu> cocreature: somewhat, I want to use it with diagrams to generate high quality plots. And recently, I want to try and use it with "hamilton"
09:57:30 <bollu> cocreature: it's an offshoot of SymPy
09:57:51 <cocreature> bollu: how does a lib for symbolic math help with creating high quality plots?
09:58:12 <drifter[m]> How is babby formed?
09:58:41 <bollu> cocreature: it doesn't, it just lets you do symbolic math :) I want to plot derivatives and stuff
09:58:46 <byorgey> hi AndChat89889 
09:58:48 <bollu> oh, "high quality" was the wrong words
09:58:49 <bollu> sorry
09:58:59 <bollu> "interesting" was what I was going for
09:59:02 <cocreature> bollu: ah ok, cool
10:00:15 <bollu> cocreature: but yes, I'm having trouble with the FFI
10:00:24 <bollu> can I get GHC to allocate memory?
10:00:37 <bollu> so I can placement new on the C side?
10:00:53 <cocreature> isn’t placement new a c++ feature?
10:01:21 <bollu> cocreature: yep
10:01:22 <ertes> bollu: if you're just looking for a CAS, i can recommend maxima
10:01:25 <bollu> cocreature: symengine is C++
10:01:32 <cocreature> bollu: there are various allocation functions in https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Marshal-Alloc.html#v:alloca but I’m not sure if these help you
10:01:32 <bollu> ertes: no, I want to bind this as well
10:01:36 <AndChat89889> I'm new on Irc :) 
10:01:36 <ertes> ok
10:01:42 <bollu> AndChat89889: hey!
10:11:27 <Akii> sl
10:11:34 <Akii> sry nvm
10:13:17 <bollu> what does "exitFailure: -11" mean exactly?
10:14:55 <bollu> segfault
10:14:55 <bollu> neat
10:17:09 <bollu> it shows me the stack frame where it crashes
10:17:13 <bollu> not very enlightening
10:17:14 <bollu> :(
10:38:01 <tsahyt> I was wondering, is there something like Applicative but building on Contravariant rather than on Functor?
10:38:51 <ph88> can anyone help me figure out how i can resolve this compiler error? i don't understand it  https://paste.fedoraproject.org/506473/74066914/
10:38:57 <S11001001> tsahyt: Divisible
10:39:23 <tsahyt> oh it's right there in the same package
10:40:33 <tsahyt> S11001001: thanks I'll read into it. How about a Monad "analog"?
10:40:37 <tsahyt> Comonad isn't it
10:40:56 <S11001001> ph88: your prism for IExtended isn't in scope
10:41:30 <S11001001> ph88: note the bit about it being a hole, not your prism
10:41:46 <S11001001> tsahyt: don't think so
10:42:04 <greymalkin> I'm confused. datetime requires 'base <5' according to hackage, but complains about base 4.10
10:42:39 <ph88> S11001001, i have on my top-level  makePrisms ''Identifier
10:42:40 <geekosaur> usually means something else (often a dependency) has a different constraint
10:43:00 <S11001001> ph88: maybe it has to occur before your definition of aeis
10:43:14 <geekosaur> staging restriction
10:43:26 <S11001001> ph88: template haskell throws the rearrangeability of top-level definitions out the window
10:43:27 <ph88> S11001001, no it's after the definition of both aeis and Identifier
10:43:45 <S11001001> ph88: right, I'm saying it might have to go before aeis
10:43:57 <geekosaur> greymalkin, lpaste output of build attempt with -d
10:43:59 <geekosaur> @paste
10:43:59 <lambdabot> Haskell pastebin: http://lpaste.net/
10:44:05 <S11001001> ph88: and so would data Identifier, since it has to come before makePrisms, IIRC
10:44:15 <ph88> ah right
10:48:29 <ph88> S11001001, now i get this https://paste.fedoraproject.org/506480/17412671/
10:49:02 <ph88> first comment line of that paste is wrong, should be: -- line 2172 on next line
10:49:51 <S11001001> ph88: shouldn't go take an ExtendedIdentifier as arg?
10:50:07 <athan> omg, we should make a paste system that lets you hyperlink line numbers in comments
10:50:19 <ph88> S11001001, no .. 
10:50:25 <athan> then you can have them auto dereference, then we can have while loops, everything we need for good reading
10:50:43 <S11001001> ph88: but you're drilling in using the prism
10:51:33 <ph88> S11001001, well likely i didn't write the correct code .. but the intention was to traverse a data structure, and when it hits the IExtended constructor replace the value with something else
10:52:13 <S11001001> ph88: try just making go an ExtendedIdentifier -> ExtendedIdentifier
10:53:12 <S11001001> @ty (_Just %~)
10:53:14 <lambdabot> (a -> b) -> Maybe a -> Maybe b
10:53:37 <S11001001> ph88: ^note that we don't repeat the (Just x) pattern in the (a -> b) we pass; it lifts into Just for us
10:54:28 <athan> is there a common notation for "this argument is used x times in the body"?
10:55:15 <orion> Is it technically feasible to create/distribute binary packages of Haskell libraries?
10:55:16 <athan> LinearTypes will use something like \(x ::1 Int) -> to show 1 use, but I'm just wondering if there's a more standard syntax used in substructural type systems (correct me if I'm off)
10:56:43 <ph88> S11001001, nice one :D
10:57:32 <tsahyt> athan: is there progress being made on LinearTypes now?
10:58:19 <athan> eh I've seen a few things tsahyt, but only speculation
10:58:38 <athan> I still think the principal of knowing how often an argument is used can be useful reasoning
10:59:10 <bollu> :t asTypeOf
10:59:11 <lambdabot> a -> a -> a
10:59:24 <bollu> ^ what on earth is the use for such a thing?
10:59:29 <athan> if you treat them as unified concepts, you can let unification show usage, but that's not term-level enough
10:59:45 <athan> bollu: just use a constant to coerce
10:59:52 <bollu> athaller: ah
11:00:02 <johnw> > 10 `asTypeOf` 20.0
11:00:04 <lambdabot>  10.0
11:00:10 <greymalkin> geekosaur: I would, but this is (may be) also nix related; so I'll have to figure out how to do that.
11:00:12 <bollu> athan: but haskell is so strict, how much would you even want to coerce
11:00:14 <bollu> neat
11:00:24 <athan> bollu: coercion can write code for you!
11:00:35 <bollu> athan: ? enlighten me please :)
11:01:03 <geekosaur> greymalkin, er? just do the same build attempt with -d so that the actual dependency information is in the output
11:01:03 <athan> you'll get the hang of it :)
11:01:35 <bollu> oh, it's a joke? :)
11:01:56 <geekosaur> so we (or maybe even you) can see where the dependency got changed from (<5) to something tighter, or it pulled in something incompatible with your installed ghc
11:02:27 * athan coerces more :v
11:03:42 <greymalkin> Okay, I see the problem.  datetime has a test suite which requires >= 4.2 && < 4.9; even though the library requires < 5.
11:04:11 <greymalkin> So the fact that I'm using base == 4.10 is causing the default build to fail.
11:06:25 <qmm> > concatMap (+1) [1,2,3] -- what am i missing?
11:06:30 <lambdabot>  error:
11:06:30 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M851853072461...
11:06:30 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
11:06:51 <athan> @type concatMap
11:06:56 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
11:07:14 <athan> qmm: You're not creating a list in the mapped func
11:07:49 <qmm> thanks
11:19:44 <athan> I think I found a typo in Pure Type Systems! woot!
11:20:04 <athan> page 61, first bullet of exercise 4.2.8
11:22:31 <mmaruseacph2> do the authors do a Knuth and give 2.56$ for every found mistake?
11:22:59 <marekw2143> hello 
11:23:15 <byorgey> hi marekw2143 
11:23:51 <marekw2143> http://lpaste.net/349937  - I'm getting     No instance for (MonadWriter [[Char]] (writer [String])) arising from a use of ‘writer’ In the expression: writer (1, ["super Data"])
11:24:01 <marekw2143> could somebody help me ? :)
11:24:52 <marekw2143> ok, I've received help at haskell-beginners :)
11:48:22 <jsiva> Hello all, I'm trying to setup haskell in windows 10 (enterprise edition). Should I use 'stack' or the haskell platform minimal? I tried stack but when I create a new project using 'stack new', am getting permission denied when it tries to download and untar ghc 8.0.1. Furthermore, tries stack install hoogle (global) and network library doesn't build
11:50:20 <maerwald> then try the haskell platform, both are free :o
11:51:31 <jsiva> @maerwald Thanks! Tried the haskell platform and did a `stack install hoogle` and that fails to build network too. Tried `cabal install hoogle`. That went through (didn't print any errors). However, I don't know where to find the executable 'hoogle'
11:51:31 <lambdabot> Unknown command, try @list
11:51:37 <hodapp> huh, it's odd to me that more Computer Algebra Systems don't seem to exist in Haskell
11:52:47 <EvanR_> dont those tend to be dynamically typed
11:53:35 <EvanR_> might explain it, people are still trying to come up with a nice CAS type system
11:53:54 <orion> What exactly is the difference between "manual" and "default" in Cabal flags?
11:55:46 <ezyang> orion: a manual flag is one the solver won't toggle automatically when trying to find a solution 
11:55:53 <mstruebing> how could I read the content of a file non-lazy?
11:56:31 <hodapp> EvanR_: I dunno. I think that's more incidental than anything
11:56:53 <hodapp> EvanR_: when I think of the design of Maxima, for instance, nothing about it seems to suggest that it has to be
11:57:26 <Tuplanolla> There's Axiom that's statically typed.
11:57:33 <Tuplanolla> Too bad it's completely unusable.
11:57:50 <byorgey> mstruebing: the simplest way is to use http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html
11:58:13 <orion> ezyang: Thank you.
12:00:35 <mstruebing> thx byorgey 
12:02:37 <p_implies_q> Sorry if I'm in the wrong place, but is this an acceptable place to ask (perhaps Newbieish) questions
12:02:42 <p_implies_q> ?
12:03:29 <p_implies_q> (Never mind the fact that that is already a newbieish question)
12:03:44 <lyxia> yes
12:03:55 <lyxia> feel free to ask any question about haskell
12:04:05 <Kestrel-029> Hi, what's the Haskell equivalent of Java's && and || operators? Thanks!
12:04:07 <p_implies_q> Ok, here goes
12:04:13 <Tuplanolla> The same, Kestrel-029.
12:04:15 <kadoban> Kestrel-029: && and ||
12:04:19 <Kestrel-029> thanks kadoban
12:04:22 <sm> jsiva: http://neilmitchell.blogspot.co.il/2016/12/installing-haskell-network-library-on.html appeared recently. If the standard stack install flow linked there fails, check the stack bug tracker - it's quite likely reported already
12:04:58 <p_implies_q> I'm trying to create a list of some type of object that satisfies the criteria of being a MenuItem (a class I created myself) and I have 2 different instances of that class
12:05:17 <p_implies_q> But since these are two different data-types the list is of course not well typed
12:05:26 <p_implies_q> I could make them some sort of algebraic data-type
12:05:26 <lyxia> indeed
12:05:42 <p_implies_q> But then a lot of functions that are defined on only 1 of these 2 would be partial
12:06:00 <p_implies_q> I can come up with various hacky ways around this, but I get the vague sensation there must be something more elegant
12:06:47 <p_implies_q> Basically I want to make lists of things that I can guarantee expose a certain interface (defined in my MenuItem) class
12:07:04 <p_implies_q> Any suggestions?
12:07:39 <lyxia> If there are only two such types A and B, how about "Either A B"
12:08:16 <p_implies_q> Ah,  but the whole reason for doing this is so that I can later easily add other items that suppost the MenuItem iterface and add those to the list too :-)
12:08:22 <lyxia> Otherwise if your interface is open to external implementations, there are existential types, but this is a bit of a code smell.
12:08:28 <p_implies_q> Hmmmm
12:09:38 <Boomerang> p_implies_q: you could try HList if you know your list at compile time
12:09:42 <kadoban> p_implies_q: Sounds like MenuItem should just be a type, not a typeclass. It's a bit unclear what the thing actually does though.
12:10:44 <kadoban> If some action on MenuItem only makes sense for some MenuItems, you can always change the types, like instead of  getTitle :: MenuItem -> String, it could be getTitle :: MenuItem -> Maybe String
12:11:11 <kadoban> Other uses have different fixes, but it's certainly not impossible ... really depends on the goal.
12:11:23 <p_implies_q> Thanks for the feedback, I'm starting to rethink the whole structure
12:11:53 <ertes> p_implies_q: are you trying to do OOP using type classes?
12:12:40 <p_implies_q> ertes: Hehe, maybe. this is my first larger Haskell project, and I used to do a lot of python. This is still the direction my brain bends in
12:13:05 <kadoban> It's pretty common, I used to do that a *lot*
12:14:07 <ertes> p_implies_q: well, it would help to know alternatives: do you have a kind of richness tree?  like: one thing *contains* another?  because then you could just create multiple types, and each could include each other as fields
12:14:44 <p_implies_q> Um... let me try to explain what I'm trying to make
12:15:10 <p_implies_q> In Spacemacs there is this helm-interface where you push a leader-key, and then by pushing various other keys you descend into submenus and finally execute an action
12:15:20 <p_implies_q> I'm trying to make such a thing for XMonad with X-actions
12:15:26 <p_implies_q> I've already got it up and running
12:15:33 <p_implies_q> Showing the menus with dzen2
12:15:50 <lyxia> nice
12:15:51 <p_implies_q> But I wanted to separate the dzen2 'rendering' interface from the internal logic
12:16:02 <ertes> that sounds like little more than a recursive algebraic data type
12:16:16 <p_implies_q> That means I have 'actions' Which are X () actions with a bit of description
12:16:26 <p_implies_q> And other menus, so you can descend
12:16:48 <p_implies_q> I wanted to simply have lists of actions and other menus
12:16:56 <p_implies_q> And have those other menu's be interpreted as actions
12:17:11 <p_implies_q> So anything that exposes an 'action' interface could be dumped into a list representing a menu
12:17:17 <ertes> data Menu a = Submenu [Menu a] | Action Text a
12:17:19 <ertes> how about that?
12:17:31 <ertes> then (Menu (X ())) would be a menu of X actions
12:17:36 <p_implies_q> Yeah, that works, but I wanted people to easily define their own without having to go into my own source code
12:17:43 <geekosaur> have you looked at XMonad.Action.Submap? and XMonad.Util.EZConfig for easier usage of it
12:17:48 <ertes> p_implies_q: their own what?
12:17:59 <p_implies_q> Their own 'actions'
12:18:10 <ertes> p_implies_q: what's the type of those actions?
12:18:27 <geekosaur> also note that an X action is a function, and can neither be read nor written from a file
12:18:40 <p_implies_q> I was hoping not to have to care, all I care about is that they have 2 'properties', an action and a description
12:18:48 <p_implies_q> But that was OOP brain-bend, perhaps :p
12:18:52 <ertes> p_implies_q: you have to care ;)
12:18:59 <geekosaur> (well. it's a transformer over IO, but that amounts to the same thing)
12:18:59 <p_implies_q> Hehe, and so I learn
12:19:19 <ertes> p_implies_q: the problem is this:  say that you allow a menu to contain literally anything…  then you can make no assumptions about what it contains
12:19:24 <p_implies_q> Yeah, I'll restructure this
12:19:30 <ertes> you can't "run" an action, because then you're assuming that actions can be run
12:19:33 <p_implies_q> Because running a menu is itself an X () action
12:19:47 <ertes> does that make sense?
12:19:48 <p_implies_q> so putting in a submenu is simply adding "runMenu myMenu"
12:19:54 <p_implies_q> I was trying to be too clever
12:20:44 <p_implies_q> Well, the class I wrote defines a function that must be satisfied 'action :: a -> X ()'
12:21:01 <p_implies_q> So I was trying to let people define anything, so long as calling action on it gave me an X-action
12:21:15 <p_implies_q> and then put the people in charge of implementing a correct 'action' function in their instantiation
12:21:48 <ertes> p_implies_q: let me use a simpler example:  say that you want to express a list that can contain anything…  the list elements must have a type, so let Something be the type of *anything* (it could be Int, Double, X (), etc.)
12:22:01 <ertes> p_implies_q: now you receive a list of type [Something]
12:22:05 <ertes> what can you do with it?
12:22:11 <p_implies_q> Yeah, I see what you mean
12:22:35 <p_implies_q> But there is still so much of haskell that I don't know, that I thought perhaps there was a well known way of dealing with this problem
12:22:42 <ertes> you can count the number of list elements, but you couldn't do anything with the elements themselves, because anything you do would require a restriction on Something
12:22:57 <p_implies_q> Well, there is a restriction, right
12:23:04 <ertes> ok, what is the restriction?
12:23:06 <p_implies_q> the restriction being an instance of MenuItem
12:23:18 <p_implies_q> which garantees that 'action something' gives me an X ()
12:23:19 <ertes> try without type classes =)
12:23:35 <p_implies_q> Hehe :p
12:23:39 <ertes> given [Item] what are your assumptions on Item?
12:23:52 <ertes> that you can convert Item to X ()?
12:23:57 <p_implies_q> Yep
12:24:04 <ertes> is that the only assumption?
12:24:28 <p_implies_q> There is also "descr item" which gives a descriptive string, but is useless for the current discussion
12:24:42 <ertes> not quite =)
12:24:45 <ertes> it's actually useful
12:24:57 <p_implies_q> Hmmm, do explain :-)
12:25:21 <ertes> so you're assuming that there exists a function (Item -> X ()) and a function (Item -> Text)
12:25:25 <ertes> or String if you will
12:25:30 <p_implies_q> Yep
12:25:41 <ertes> how about Item = (Text, X ()) then?
12:25:55 <ertes> because if these assumptions are complete, then Item is indistinguishable from (Text, X ())
12:26:01 <p_implies_q> True
12:26:04 <ertes> from the viewpoint of your implementation
12:26:25 <hodapp> https://github.com/abid-mujtaba/haskell-cas oh, there is a fairly recent one!
12:26:26 <p_implies_q> So all I need is some type that describes what is minimally needed by my implementation
12:26:34 <p_implies_q> And anything that maps to that can then be included in my menus
12:26:40 <ertes> exactly
12:26:59 <p_implies_q> I'll try that.
12:27:27 <Boomerang> And instead of implementing an instance of a class you could just have a function toItem :: Something -> Item for anything you want to use as an Item
12:27:32 <ertes> p_implies_q: and then in fact you don't even have to define Menu, because it's predefined for you in Data.Tree from the containers package =)
12:28:01 <p_implies_q> Egads, that is so much simpler :p
12:29:12 <ertes> p_implies_q: the (or one) secret to the transition from OOP to FP is not to focus so much on what a data structure *contains*, but what *assumptions* you make about the elements
12:29:30 <p_implies_q> Hmmm, I'll try to remember that
12:30:03 <ertes> you don't care that a game entity is a "player"…  you care that it's something that has certain semantics
12:30:16 <p_implies_q> Also, just as a random question, suppose I do finish this to my liking and I'd like to share it, and supposing people are interested, where should I announce my creation? All I really know is reddit.com/r/haskell
12:31:09 <ertes> p_implies_q: the haskell-cafe mailing list is regularly used for announcements…  look for posts with "ANN:" in their subject
12:31:21 <ertes> reddit is also a good PR platform these days, and also twitter
12:31:35 <p_implies_q> A twitter, the land I hope never to frequent
12:32:13 <mstruebing> byorgey: is this an acceptable implementation too? https://github.com/mstruebing/todo.hs/blob/0db2447db4e6411b7fc82d98cb4706e48308ce98/src/Lib.hs#L59
12:32:20 <p_implies_q> Ok, thanks for all the feedback! Luckily haskell is so much easier to refactor than anything else I'm used to :-)
12:34:07 <EvanR_> ertes: and then... encode the assumptions directly into the type and get a free implementation
12:34:15 <EvanR_> then ???, then profit
12:34:57 <ertes> EvanR_: do you mean something other than Item = (Text, X ())?
12:35:06 <EvanR_> i didnt follow the entire convo
12:35:26 <EvanR_> but the gist was, dont use a typeclass, use a record of functions
12:35:27 <ertes> EvanR_: ah, then:  well, that's basically what i suggested =)
12:35:57 <EvanR_> X () looks funny
12:36:05 <EvanR_> type level tic tac toe
12:36:27 <ertes> hehe
12:36:28 <p_implies_q> Hah, can't be unseen :p
12:36:39 <ertes> i would even resist the temptation to define (type Menu = Tree MenuItem), and just use (Tree Item) directly
12:36:53 <ertes> but i would define Item (or perhaps MenuItem) as a new ADT instead of a tuple type
12:38:02 <EvanR_> learning haskell has helped me comprehend more about the OOP thought process, but standing outside of it and looking back in
12:38:30 <EvanR_> like, i have a problem, havent thought it out fully yet, but before i do ill make a class or interface with named methods
12:38:31 <ab9rf> i got someone mad at me for saying that tic-tac-toe on a 6x6 board is proved to be a draw with optimal play but the optimal strategy strategy is unknown
12:38:59 <kadoban> ab9rf: Is that true?
12:39:07 <EvanR_> then whatever the solution is, ill be able to come up with more subclasses of it
12:39:14 <ab9rf> as far as i know it is
12:39:45 <EvanR_> how do you know its a draw?
12:39:59 <kadoban> ab9rf: I assume it can be proven just by exhaustively exploring the game tree, and the strategy is just "look in the game tree for where you should play now?"
12:40:13 <MarcelineVQ> is 3 in a line still a win on 6x6 ?
12:40:16 <ertes> OOP focusses too much on what things *are* and how they would relate in a "real-world species tree", which leads to the weirdest constructions and the worst code size blow-up i have ever seen
12:40:21 <ab9rf> MarcelineVQ: no, you need six in a line
12:40:27 <byorgey> kadoban: if it could be proven by exhaustively exploring the game tree, then the optimal strategy would be known.
12:40:37 <byorgey> ab9rf said the optimal strategy is unknown.
12:40:39 <kadoban> byorgey: Well yeah, that was kind of my point.
12:40:55 <ab9rf> presumably nobody has actually mapped out the entire tree
12:41:03 <ertes> that's why i never take something like "my project has 100k LoC" seriously when OOP was used, because only perhaps 2% of it is actual semantics…  the rest is OOP
12:41:03 <geekosaur> iirc tic tac toe and variants are easily proven algorithmically, but that doesn't give you a strategy
12:41:06 <ab9rf> and nobody has found a shortcut strategy that is optimal
12:41:21 <EvanR_> ertes: what things *are* (denotational semantics), how things relate (category theory), yes totally bogus!
12:41:24 <ab9rf> 7 in a row on a 7x7 board has never been proven to be a draw
12:41:38 <kadoban> I know go is proven up to like 7x7? At least 6x7, so it doesn't seem particularly intractible, though it could still be expensive.
12:41:45 <ab9rf> n in a row on nxn is proven a draw on n 8 or greater
12:41:49 <byorgey> > 3^36  -- number of possible states in a 6x6 tic-tac-toe game
12:41:51 <lambdabot>  150094635296999121
12:42:03 <p_implies_q> ertes: You said above you would use an ADT over a Tuple, any particular reason why?
12:42:11 <byorgey> actually, some of those are invalid.  But that's a ballpark.
12:42:50 <ertes> p_implies_q: you can freely define instances, and using record syntax you can extend it without having to rewrite everything
12:42:58 <geekosaur> also, tuples are both harder to read, and admit values you might not expect
12:43:13 <ertes> p_implies_q: for example you might want to define a Show instance for debugging
12:43:21 <ab9rf> "6-in-a-row is a draw on 6x6 (by a pairing strategy) but nothing is known about it otherwise."
12:43:21 <p_implies_q> Ahhhh of course
12:43:28 <ertes> p_implies_q: (Text, X ()) has no Show instance
12:43:31 <EvanR_> p_implies_q: i think ertes meant use a record type instead of a tuple
12:43:41 <geekosaur> that is, ADTs encode semantics in the type system, whereas any tuple with the right type can be used anywhere without any guarantee of it meaning what you intended
12:43:50 <EvanR_> they are effectively the same but records are more convenient for more than 2 fields
12:44:02 <ab9rf> 9-in-a-row is a draw on boards of any size whatsoever.
12:44:13 <monochrom> It is also valuable to have different types standing for different concepts even though they all have the "same" content as (Int, Bool) for example.
12:44:26 <geekosaur> ^ that's what I meant by semantics
12:44:35 <ab9rf> monochrom: yeah, that's a point that is hard to bang into the heads of so many people it seems
12:44:52 <p_implies_q> I'm going to have to make you guys look at my code when it's all good and done, and then you'll still find 5000 inaccuracies :p
12:45:01 <monochrom> The point of nominal typing is that the different types are reminders for you and machine-checked.
12:45:02 <ab9rf> monochrom: it's why i am SO PISSED at people who blithely use anonymous tuples instead of declaring a (structurally equivalen) record type
12:45:09 <byorgey> ab9rf: interesting. I am guessing "by a pairing strategy" means you can group the locations into pairs, such that if your opponent plays one location of a pair, you play the other, and the pairs are arranged such that this will always lead to a draw
12:45:26 <ertes> p_implies_q: only perhaps 15, because the remaining 4985 inaccuracies are probably found by the type system =)
12:45:28 <ab9rf> byorgey: to avoid excess off-topic meandering, i direct you to http://www.weijima.com/index.php?option=com_content&view=article&id=11
12:45:34 <byorgey> thanks =)
12:45:34 <p_implies_q> Haha
12:46:08 <monochrom> To be sure, I just write like (Int, Bool) when I'm lazy. But when I'm lazy I don't write production code.
12:46:16 <ab9rf> monochrom: of course, the ability of many "modern" languages to readily use anonymous tuples (or hashes) is often touted as a "feature"
12:46:58 <EvanR_> "a hash"
12:47:18 <EvanR_> talk about mixing so many things together by calling them that
12:47:19 <monochrom> Well, it is in the same spirit as anonymous lambdas, and further into history, anonymous expressions altogether.
12:48:04 <monochrom> That's right, before Fortran, you were not allowed to write "X = Y*Z + T". Before Fortran, you had to give the Y*Z part a name, too.
12:48:22 <ertes> p_implies_q: BTW, the reason i would go with (Tree MenuItem) directly is that your user may not actually start from a (Tree MenuItem)…  they might start from [A], then blow it up into a (Tree B), then map it to a (Tree (IO C)) and finally 'traverse' it into a (Tree MenuItem) that they give your library
12:48:30 <EvanR_> who needs names, make it fully anonymous
12:48:31 <monochrom> It is important to offer the freedom to name or not-name an expression, a function, or a type.
12:48:43 <monochrom> err, s/type/data structure/
12:48:51 <Cale> ab9rf: For any number c of players, and any side-length n, there exists an H large enough that n^H tic-tac-toe with c players can't draw. :)
12:49:08 <monochrom> But to be sure, about 90% of things should be named and differentiated.
12:49:22 <ab9rf> Cale: i think you've generalized beyond my capacity to visualize without the use of psychoactive substances
12:49:28 <p_implies_q> ertes: I guess it's generally better to stay in touch with the core libraries where possible
12:50:05 <EvanR_> ive never had to need for a library Tree
12:50:17 <ertes> p_implies_q: no, what i mean is that you might be tempted to do something like:  newtype Menu = Menu (Tree MenuItem)
12:50:29 <EvanR_> list or Map seems more common
12:50:31 <p_implies_q> Ahhhh
12:50:34 <p_implies_q> I was not :)
12:50:43 <Cale> https://en.wikipedia.org/wiki/Hales%E2%80%93Jewett_theorem
12:51:12 <Jello_Raptor> is there a good library for representing bijections? 
12:51:17 <ertes> p_implies_q: i wouldn't even define a type alias, because that only obscures your types =)
12:51:42 <ertes> Jello_Raptor: lens
12:51:56 <ertes> see Iso and Iso'
12:51:59 <p_implies_q> ertes: So basically pass around (Tree MenuItem)'s to keep things clear
12:52:08 <p_implies_q> (sans parentesis)
12:52:12 <slack1256> -- lift (m >>= f) = lift m >>= (lift . f) . Does it pay off to use this law from rhs to lhs?
12:52:25 <Cale> ab9rf: Oh, you can go even farther and say that it also doesn't matter who plays on each turn: once H is sufficiently large, any colouring of the board with c colours will produce a line or diagonal all of the same colour
12:53:07 <Jello_Raptor> ertes: I need something more like bimaps or bimap, where I can add pairs to the bijection as well as check whether an element is part of it. 
12:53:15 <Jello_Raptor> Iso isn't quite right for my use case
12:53:21 <EvanR_> Cale: is there a formula for this H
12:53:34 <p_implies_q> ertes: I'm going to bugger off now, but thanks for the help :-) I'll come and hang out in IRC more in the future. This is a cool place.
12:53:35 <lyxia> slack1256: I'd assume so
12:53:45 <Cale> EvanR: There's a primitive recursive bound on H apparently.
12:53:54 <ertes> Jello_Raptor: ah, you want something like a bidirectional Map?
12:53:59 <dmwit> Jello_Raptor: It's called `bimap` on Hackage.
12:54:01 <dmwit> ?hackage bimap
12:54:01 <lambdabot> http://hackage.haskell.org/package/bimap
12:54:19 <Cale> The original argument for the theorem results in an H which grows as fast as the Ackermann function, but that's been subsequently improved.
12:54:20 <dmwit> There's also `relation` for when you don't want it to be bijective.
12:54:44 <Jello_Raptor> I'm leaning towards bimap since it's simpler
12:54:49 <Kestrel-029> Does haskell have any built-in methods to reverse a tuple? eg. make (1,2) into (2,1)?
12:54:50 <monochrom> That's a substantial improvement from Ackermann to something primitive-recursive
12:54:59 <Jello_Raptor> dmwit: ertes: thank you kindly
12:55:02 <ertes> Kestrel-029: 'swap' from Data.Tuple
12:55:05 <dmwit> ?pl \(a,b) -> (b,a)
12:55:05 <lambdabot> uncurry (flip (,))
12:55:22 <ertes> > swap (1,2)
12:55:24 <lambdabot>  (2,1)
12:55:43 <Kestrel-029> nice ertes, thanks
12:56:29 <EvanR_> > swap (1, 'A')
12:56:31 <lambdabot>  ('A',1)
12:58:04 <byorgey> mstruebing: I am 85% sure that should work but it feels icky.
12:58:58 <Jello_Raptor> Actually, is there an equality map class somewhere? `EqMap k v` with a `join :: v -> v -> v` operation over values, and `setEq :: k -> k -> EqMap k v -> EqMap k v` that will create transitive equality classes? 
12:59:26 <byorgey> mstruebing: are you aware of https://github.com/ginatrapani/todo.txt-cli/ ?
13:00:03 <Jello_Raptor> or even just a data structure for managing transitive equality classes?
13:00:21 <lyxia> "transitive equality classes" what's that
13:00:32 <byorgey> Jello_Raptor: https://hackage.haskell.org/package/union-find ?
13:01:17 <acowley> Is hackage not building docs again or is there just a multi-day lag?
13:01:28 <acowley> Was just looking at: http://hackage.haskell.org/package/haskell-src-exts
13:03:42 <Jello_Raptor> lyxia: a pair  (objects :: Set o, eq :: o -> o -> Bool) such that `forall objects a, b, and c. (a `eq` b) && (b `eq` c) => (a `eq` c)` 
13:04:14 <Jello_Raptor> byorgey: :/ damn, that lives in a monad or monad transformer. It's a shame. 
13:05:23 <lyxia> Jello_Raptor: I call it a transitive relation.
13:05:59 <lyxia> there is a pure union find somewhere
13:07:18 <lyxia> @hackage persistent-equivalence
13:07:18 <lambdabot> http://hackage.haskell.org/package/persistent-equivalence
13:07:58 <lyxia> Has nothing to do with Persistent the database thing.
13:08:46 <dmwit> I guess you lose path compression, though, huh?
13:08:53 <dmwit> Or is it impure under the hood?
13:09:21 <dmwit> Oh yeah, it's impure under the hood.
13:09:30 <Jello_Raptor> lyxia: yeah, i suppose "equality class" is a bit redundant. I'm using it to keep track of whether elements refer to the same not-haskell!type in a sorta compiler thing I'm building. 
13:10:26 <EvanR> you could define something like that inductively
13:11:04 <Jello_Raptor> EvanR: as the composition of a bunch of statements of the form "a = b"? 
13:12:05 <EvanR> im thinking
13:12:18 <EvanR> here are the informal rules
13:12:28 <EvanR> a set of "transitive equality classes" is either
13:13:39 <EvanR> the empty set, a new class with representative x appended to the set, or y appended to an existing class represented by x in some set
13:14:15 <EvanR> which amounts to Map a (Set a)
13:14:23 <EvanR> with nonempty sets
13:15:41 <EvanR> [Set a]
13:16:10 <ab9rf> EvanR: i suppose there should be a requirement that the sets are mutually nonintersecting
13:16:47 <EvanR> nevermind, youre right, its bollocks
13:16:58 <Jello_Raptor> yup, I would like it to be a bit more efficient than that if possible
13:17:04 <EvanR> back to the drawing board
13:17:49 <EvanR> do you want to merge classes if they end up being equal?
13:17:52 <ab9rf> Jello_Raptor: can't you just compare the type signatures?
13:19:13 <byorgey> Jello_Raptor: I think https://hackage.haskell.org/package/union-find-0.2/docs/Data-UnionFind-IntMap.html is a pure implementation.  It has no documentation but pretty much the same API as the other modules so it shouldn't be hard to figure out.
13:19:41 <byorgey> Jello_Raptor: of course it's not as efficient as the IO/ST versions but it's probably plenty fast for most applications
13:19:45 <Jello_Raptor> EvanR, ab9rf: Here's what I'm actually using it for. I have a pile of variables with associated types, a set of "type of value a == type of value b" relations, and the types form a join semilattice, where "join" is the type unification operator
13:20:02 <EvanR> so basically unification
13:20:20 <ab9rf> ah, so we are talking about unification
13:20:33 <EvanR> a good way to do that is with a mutable graph structure
13:21:25 <Jello_Raptor> I want to be able to get the types for any variable, and query whether they're in the same equality class 
13:21:34 <Jello_Raptor> EvanR: mmm?
13:21:40 <EvanR> right
13:22:05 <EvanR> when you add information to the graph, you may equate two classes
13:22:40 <Jello_Raptor> I've pretty much just got a (Map k Integer, Map Integer (Set k), Map Integer v) where Integers mark each equality class 
13:23:40 <EvanR> each variable has a type which is either unknown, known, or equal to the type of some other variable
13:24:18 <AndreasK> Is there something abstract that is well suited to represent "double buffering"? Where I can map over the whole thing but the results are placed at the same place but of a new version?
13:24:19 <EvanR> you can go from unknown to equal-to-something by updating
13:24:52 <EvanR> and then you have a chain of equals to a final known value, if all goes well in the end
13:25:23 <EvanR> for all variables
13:26:32 <EvanR> but if you add information that makes two variables with known different types equal, that should be an error
13:27:27 <EvanR> AndreasK: sounds like a job for linear types, move semantics
13:28:03 <EvanR> i.e. the action of doing the mapping makes the original unavailable, it was "moved"
13:28:04 <AndreasK> Since Haskell has no linear types afaik I guess it would be some kind of Monad
13:28:11 <Jello_Raptor> EvanR: right, though that's just captured by the type becoming Top and I can deal with it later.
13:28:47 <EvanR> monads cant really express this
13:28:57 <EvanR> but indexed monads can, sort of
13:29:06 <AndreasK> I know since they don't delete the old thing
13:29:24 <EvanR> if you put a counter in the type of the monad
13:29:37 <EvanR> and each mapping you do increases the counter
13:29:42 <AndreasK> Which is fine by me in this case. Just wondered if there is a well fitting abstraction
13:30:48 <EvanR> the type of the mapping operation is like, give me a structure with counter n, and in monad context n, ill give you a structure with counter n+1 and update monad context to n+1
13:31:03 <EvanR> well, also pass in the mapping function
13:31:44 <EvanR> that monad would be unable to modify the structure in a looping construct
13:32:46 <EvanR> you also would need an ST like parameter to stop the structure from leaving the monadic program
13:34:30 <EvanR> AndreasK: you might able be about to talk about the steps using arrows
13:34:47 <EvanR> which are more restrictive than monads
13:35:06 <EvanR> but have a fancy syntax extension
13:48:08 <AndreasK> EvanR: I don't want to use it in a library so it theoretically being able to leak out of the monad would be ok
13:48:35 <AndreasK> EvanR: But I guess I could check out Arrows, heard them too often to ignore by now xD
13:48:52 <EvanR> you could "just dont use it again"
13:49:14 <EvanR> and use IO or some monad
13:50:36 <EvanR> you can put in support for a dynamic check that you dont use an old buffer
13:50:50 <EvanR> and simply throws an exception
13:51:14 <EvanR> but you dont gain much if its a monad anyway where we expect side effects
14:03:41 <AndreasK> Looking at the wiki going with Arrows might be worthwile but it seems like it's definitely the most confusing way for me to approach this at the moment
14:15:15 <ph88> Ever since i started using Lens/TH haskell can't find some data types anymore. I have this function  wtf :: ContextClause -> Int  wtf _ = 1    and then later in the file  newtype ContextClause = CC [ContextItem] deriving (Eq, Show, Data, Typeable)    and i get this error:  Not in scope: type constructor or class ‘ContextClause’
14:15:48 <glguy> ph88: Using top-level template haskell to splice in declarations segments your file
14:15:58 <glguy> You can't use data types defined  below the template haskell above it
14:16:06 <monochrom> yikes
14:16:21 <glguy> so... do the template haskell early
14:16:29 <ph88> oh ok
14:16:59 <monochrom> There goes my model of "Haskell lets you order declarations any way you like".
14:17:18 <ph88> by the way is there a tool to check for unused code in haskell ? like unused imports or unused functions
14:17:41 <glguy> Yeah, you can use GHC to do that
14:18:30 <monochrom> Go to GHC User's Guide section 6.6 "Flag reference" and start searching for "unused".
14:19:15 <monochrom> And with version 8.* the user's guide itself has a search box and does highlights (requires javascript).
14:19:46 <Koterpillar> Is there something like %timeit in GHCi?
14:19:48 <ph88> cool
14:19:53 <kadoban> The GHC 8 user guide is fancy as hell
14:21:37 <monochrom> I like its new colour :)
14:22:17 <monochrom> Maybe I should learn from it and change all my tutorials to light grey ink.
14:23:19 <MarcelineVQ> Koterpillar: aside from :set +s ?
14:23:21 <EvanR> i hope there was an extensive mailing list thread followed by community survey to decide on that color
14:23:44 <Koterpillar> MarcelineVQ: that's what I was looking for, thanks!
14:23:48 <MarcelineVQ> oh good :>
14:51:45 <dazednconfused> hi room
14:52:29 <dazednconfused> I already asked this on #haskell-beginners. Anyone knows the meaning of "proper morphisms" and "nonproper morphisms" for monads?
14:53:40 <ph88> great 20 minutes of running quickcheck an no mistake found :P
14:53:43 <ph88> it's slow though
14:55:28 <glguy> Cool, now you can be a little more confident that the quickchecks you wrote don't find the bugs in your program!
14:58:47 <lyxia> dazednconfused: http://muddsnyder.com/pubs/monadfactory.pdf uses them to differentiate >>= and return from other operations
15:19:14 <AndreasK> EvanR: Having looked into it arrows it seems to be the wrong way to go about it. At least I now have a (better) idea about what they are.
15:19:29 <glguy> That's going to be generally the case for arrows
15:19:44 <EvanR> heh
15:20:20 <AndreasK> The only thing I had used about arrows so far was &&&
15:20:38 <EvanR> categories and category-plus-stuff would be better if it wasnt more polymorphic, if more haskell types could satisfy the interface
15:21:17 <EvanR> would be better if it WAS more polymorphic... 
15:34:21 <AndreasK> Is there a function (Monoid m, Foldable f) => f a -> (a -> m b) -> m b? Basically concatMap only it wraps the result in a Monoid instead of a list
15:35:16 <Hijiri> AndreasK: if m is a Monoid, you can't apply it to anything
15:35:37 <Hijiri> there does exist fold
15:35:39 <Hijiri> :t fold
15:35:42 <lambdabot> (Monoid m, Foldable t) => t m -> m
15:35:48 <Hijiri> and foldMap
15:35:51 <Hijiri> :t foldMap
15:35:53 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
15:36:42 <AndreasK> foldMap is what i was looking for
15:37:35 <AndreasK> My monoid is a set in that case hence why I wrote 'm b'  :x 
15:37:46 <mtn`> Hey, i've got some pretty straightforward questions; trying to check my understanding
15:37:55 <mtn`> would length [1, 2, 3, 4, 5] be considered WHNF?
15:39:09 <Hijiri> mtn`: if that represents a thunk of applying length to that list, then no
15:39:52 <mtn`> would 1 : 2 : 3 : 4 : _ be whnf?
15:40:25 <Hijiri> yes, since it's a constructor at the top level
15:40:34 <Hijiri> (:) 1 (2 : 3: 4 : _)
15:40:41 <hexagoxel> > (1:undefined) `seq` ()
15:40:43 <lambdabot>  ()
15:41:19 <mtn`> Hijiri, Hm, ok. And [1+2,3] also would be, because it's a constructor at the top level as well, right?
15:41:29 <mtn`> Hijiri, Despite the operation, which isn't being applied at the top level
15:41:52 <hexagoxel> > (undefined:undefined) `seq` ()
15:41:54 <lambdabot>  ()
15:42:00 <Hijiri> mtn`: yeah
15:42:04 <mtn`> Hijiri, Thank you!
15:42:15 <Hijiri> https://wiki.haskell.org/Weak_head_normal_form lists all the cases of WHNF
15:57:04 * mekeor is surprised by how few lines of code are needed to write a GTK-based terminal emulator in haskell: https://github.com/puffnfresh/puffyterm/blob/master/Main.hs
16:10:31 <ab9rf> i'm not really that surprised
16:11:12 <ab9rf> the "hard" parts are imported from GTK
16:12:08 <davean> It takes even less codes in sh
16:17:58 <orion> Hi. I custom compile a kernel. What options do I need to enable support for binmiscctl?
16:18:12 <orion> I already have: options         IMAGACT_BINMISC
16:18:32 <glguy> What's the Haskell part of that question?
16:18:38 <orion> Oh crap.
16:18:42 <orion> Wrong window.
16:20:10 <yulax>  heh
16:34:18 <ezyang> Trying to decide how to put version number-like things in a package name. bytestring-signature-r0d10d8-v1; what do you think this means to you? 
16:35:19 <glguy> Is that a Star Wars character?
16:35:34 <glguy> other-signature-r2d2-v1
16:35:35 <ezyang> hahaha 
16:35:56 <Axman6> what does the number represent?
16:36:04 <glguy> I think that's what we're supposed to guess
16:36:11 <ezyang> yeah 
16:36:22 <hackrilege> But you should use a standard
16:36:22 <glguy> It's a signature for bytestrings, for sure
16:36:23 <Axman6> git hash?
16:36:34 <glguy> no, it has r in it, git hash is hex
16:36:44 <glguy> Oh, I guess only the leading char is r
16:37:08 <ezyang> hmm, what if I said bytestring-signature-rel0d10d8-v1 
16:37:19 <hackrilege> How are arrows like lenses?
16:37:24 <ezyang> or maybe bytestring-signature-rel0108-v1? 
16:38:31 <ezyang> bytestring-signature-v0108-r1 
16:38:44 <glguy> version 108, revision 1?
16:38:53 <ezyang> ok, sounds like we have a winner :) 
16:38:56 <AndreasK> Anyone an idea why this fails? http://lpaste.net/8548510323919814656
16:39:03 <ezyang> if I wanted to denote version 0.10.8 how might I try that? 
16:39:08 <ezyang> that's what the d's were 
16:39:26 <AndreasK> If i change the type to just s Int and delete the const it typechecks :x
16:39:26 <ezyang> AndreasK: what's the error 
16:39:51 <ezyang> Oh, you probably need scoped type variables 
16:40:08 <AndreasK> http://lpaste.net/8548510323919814656
16:40:21 <glguy> AndreasK: When you're writing constraints with type variables applied to non type variables you're generally doing something wrong
16:40:26 <glguy> e.g.  Monoid (s Int)
16:40:59 <glguy> or even Monoid (s a)
16:41:25 <AndreasK> Didn't manage to define s to be foldable and Monoid otherwise
16:41:33 <hackrilege> You probably want Alternative a =>
16:41:41 <hackrilege> Alternative s
16:41:48 <hackrilege> Sorry my autocorrect
16:42:37 <acowley> Does anyone know of any attempts to make haskell-src-exts's data types more accessible? Something like the -prisms package, but... more.
16:43:11 <hackrilege> I wish alternative didn't have applicative as a superclass
16:43:14 <AndreasK> I currently use a Set as Instance which doesn't implement Alternative though as far as I can tell
16:44:19 <AndreasK> ezyang: Scoped type variables didn't change it
16:46:03 <hackrilege> > mempty :: Set Int
16:46:05 <lambdabot>  error:
16:46:05 <lambdabot>      Not in scope: type constructor or class ‘Set’
16:46:05 <lambdabot>      Perhaps you meant one of these:
16:46:26 <hackrilege> > mempty :: Data.Set Int
16:46:26 <Axman6> > mempty :: Set.Set Int
16:46:28 <lambdabot>  error:
16:46:28 <lambdabot>      Not in scope: type constructor or class ‘Data.Set’
16:46:28 <lambdabot>      No module named ‘Data’ is imported.
16:46:28 <lambdabot>  error:
16:46:28 <lambdabot>      Not in scope: type constructor or class ‘Set.Set’
16:46:30 <lambdabot>      Perhaps you meant one of these:
16:46:36 <Axman6> > mempty :: S.Set Int
16:46:40 <lambdabot>  fromList []
16:46:43 <hackrilege> Woop
16:46:46 <roboguy`> AndreasK: you also need an explicit forall for the 's' type variable for scoped type variables to kick in
16:48:06 <AndreasK> roboguy`: That did the trick
16:48:59 <AndreasK> glguy: Do you have another suggestion how to make a typevariable polymorphic over Foldable and Monoid at the same time though?
16:49:18 <AndreasK> I get why it looks strange but don't see the big issue with that
16:50:00 <geekosaur> that sounds ill-kinded to me...
16:50:39 <hackrilege> The Monoid instance requires Ord a, the Foldable instance couldn't, I don't know if that's what you mean
16:52:32 <hackrilege> You can make Foldable Alternatives easily enough, or MonadPlus, but then you need the Applicative superclass. Maybe you could define Alterative2 which doesn't have that constraint
16:53:16 <hackrilege> Is that what you mean?
16:54:33 <AndreasK> hackrilege: My question was how one could avoid "Monoid (s a)" when (s a) is used as a monoid and s as a foldable
16:54:57 <S11001001> AndreasK: since you have Monoid (Set a) (from Ord a) and Foldable Set, then it seems that f a -> (a -> m) -> m where m = Set a and f = Foldable would serve well
16:56:44 <S11001001> AndreasK: the thing about concatting an output structure to build it up is that any connection to the input [foldable] structure is completely artificial, because by folding you've discarded that structure
16:57:26 <hackrilege> http://lpaste.net/349952
16:59:23 <hackrilege> But since you have the Monoid instance I'm not sure why you would need to...
17:02:06 <hackrilege> I think Sets intersection is removes duplicates so it's still more complex than just folding the two structures separately and combining the results...
17:03:22 <hackrilege> union* not intersection
17:03:29 <S11001001> AndreasK: by contrast, monads like Either e and semimonads like Map k preserve the input structure in their result, so the tie between input and output is important in 'bind'
17:03:41 <S11001001> hackrilege: so Alternative2 could not be instantiated
17:04:10 <hackrilege> Why not?
17:04:14 <AndreasK> S11001001: I plan to pass the output back in as input. If i make either one concrete i might as not bother with polymorphism
17:04:26 <roboguy`> AndreasK: I might be mistaken, but I think glguy sounded like he was talking more about something like "Monoid (s Int)" than "Monoid (s a)"
17:04:28 <ab9rf> what's Alternative2 ?
17:04:37 <S11001001> hackrilege: (<||>) :: Set a -> Set a -> Set a
17:05:23 <S11001001> ab9rf: in hackrilege's last link
17:05:34 <hackrilege> It's (Ord a,Monoid (s a))
17:06:51 <AndreasK> roboguy`: He mentioned both cases. I use Int mostly because I had to stop my urge to be polymorphic at some point. The alternative was requiring (Num a) but I will probably never end up using something other than Int there.
17:07:14 <roboguy`> ahh. huh
17:08:12 <roboguy`> I don't think I really have an opinion either way on that at the moment, actually. It looks a bit strange, but I'm not sure I can come up with a reason off the top of my head why it could be a problem or a symptom of a problem
17:08:46 <roboguy`> at least, given that information about it
17:08:50 <hackrilege> S11001001, ah right, still needs Ord a, but the class declaration won't allow that constraint
17:11:00 <hackrilege> So because of the Ord a constraint there is no alternative than to use Monoid (s a) so your approach looks pretty good, why didnt you like it?
17:25:07 <Jello_Raptor> Hmm, I have no idea how to debug my issues with MVars :/ 
17:25:16 <Jello_Raptor> I'm using a monadFix instance over IO 
17:26:22 <Jello_Raptor> and don't know how to figure out what parts of my code are blocking threads
17:26:25 <AndreasK> hackrilege: I didn't like it because I got a type error (required scoped type variables) :D Not familiar with "good" style in haskell yet so I wondered why someone was skeptical of the Monoid (s a)
17:27:37 <glguy> AndreasK: Mixing the constraints like that will just lead to code that's hard to use beyond the couple of instances you had in mind
17:27:39 <c_wraith> Jello_Raptor: in general, the problems happen in the same case as any other MonadFix instance - when something depends on itself, it blows up.  It just blows up.. differently.
17:28:09 <ab9rf> how many ways can some code blow up before we call it toast?
17:28:13 <glguy> and if you're going to be making a new typeclass anyway, like "Something" that you might be able to jsut define the correct abstraction once there rather than piecing it together from Monoid and Foldable
17:29:35 <Jello_Raptor> c_wraith: problem is that I don't know the debugging techniques to figure out what's depending on itself
17:30:01 <c_wraith> Jello_Raptor: I don't know of any techniques other than "look at the code" for that myself.
17:30:30 <hpc> my technique is to not understand it well enough to use
17:30:39 <Jello_Raptor> THere's got to be some way to trace or debug which MVars are causing the issue
17:30:44 <ab9rf> hpc: i'm very good at that technique
17:31:07 <ab9rf> hpc: there are an uncountable number of things i don't understand well enough to use
17:31:28 <c_wraith> I don't use mfix/mdo/do rec on anything where I can't keep the data dependencies in my head.
17:31:51 <c_wraith> Which means I top out around 2 recursive references
17:32:47 <Jello_Raptor> I thought i was, I've got a bunch of stuff that *should* make the data dependencies acyclic 
17:32:58 <Jello_Raptor> anyway, I have to head out I'll ask again later I suppose
17:34:18 <theseb> i like lisp but haskell seems to be the new kid on the block.....is it somehow "better" than lisp?  seems like it has less historical baggage than common lisp
17:35:27 <roboguy`> theseb: that seems like an interesting question to ask the "#haskell" channel... Maybe something more specific would help?
17:35:30 <ab9rf> well, lisp is 48 years old, while haskell is 26, so yeah
17:35:45 <ab9rf> sorry, lisp is 58 years old, i can't do math
17:36:05 <AndreasK> glguy: I see, I would still end up having Monoid (x y) somewhere though unless I reimplement the functionality in my own class.
17:36:21 <glguy> Yeah, so here it might be better if it was in your class
17:36:44 <AndreasK> But shifting the constraint into the typeclass at least saves some typing xD
17:37:09 <roboguy`> theseb: also, lisp is a family of languages and Haskell is a single language (more or less)
17:37:26 <c_wraith> theseb: I suppose haskell is new compared to lisp, but it's approaching 30 years old now.  It makes languages like ruby look like newborns. :)
17:38:26 <theseb> roboguy`, c_wraith : lisp was so mathematical and elegant....i've heard rumors haskell is hard to learn....so it won't be as brainless for a simple guy like me as lisp was :(
17:39:16 <c_wraith> theseb: Now you get into the specifics of "which lisp?".  Haskell is more complex than scheme, but I'd argue it's a lot simpler than common lisp.
17:39:22 <roboguy`> theseb: you should try and find out for yourself, and not worry about the rumors!
17:40:18 <theseb> roboguy`: i did here haskell is more religiously lamba calculus-ish.....that soothes my soul...the more mathematical and elegant the better for me
17:40:23 <theseb> s/here/hear
17:41:05 <ab9rf> c_wraith: ruby is only 5 years younger than haskell
17:41:41 <c_wraith> ab9rf: newborn!  :)  I dunno, I don't think there are any particularly young mainstream languages.
17:42:21 <ab9rf> c_wraith: there's a long incubation period on a lot of them, becuase languags get written by obscure computer scientists and only make it out in the big bad world when someone outside of academia notices one of them
17:42:24 <c_wraith> I mean. Maybe C#, but even it has to be at least 15 now
17:42:38 <ab9rf> ruby languished in obscurity for almost a decade 
17:42:51 <roboguy`> maybe Swift? That probably doesn't count as mainstream still though
17:42:56 <Sonolin> Go is only ~7 years old
17:42:58 <ab9rf> clojure is only 9
17:43:09 <c_wraith> There's a few younger ones.  Ok!
17:43:09 <roboguy`> Swift is just 2
17:43:21 <ab9rf> rust is 6
17:43:27 <Rembane> Racket is 22
17:43:32 <Tuplanolla> What, ab9rf? I remember when Clojure was new.
17:43:34 <roboguy`> theseb: well, it is pretty heavily based on lambda calculus
17:43:47 <roboguy`> extended with algebraic data types and some other typing stuff
17:44:20 <c_wraith> theseb: if you like the math side, check out System F.  It's not exactly what haskell's based on, but it's close.
17:46:55 <theseb> c_wraith: i appreciate your System F recommendation...here's the thing...i'm a physicist.....i'd rather wish someone would invent $PERFECT_LANG so that i could just learn that and not have to keep learning new ones! is that bad?
17:47:49 <theseb> c_wraith: some people like learning langs..i just want to learn the "best" for some def of best
17:48:50 <c_wraith> theseb: I suspect civilization will collapse before we stop running out of ways to clearly improve things for experienced practitioners.  Let alone differences in opinion that don't have a clearly correct position.
17:49:02 <ab9rf> theseb: there's no more a perfect language than there is a perfect multifunction tool
17:49:12 <Welkin> you made me think of the game Civilization
17:50:19 <theseb> c_wraith: i was happy to learn C, Lisp, Python and a little Java.....fast forward few years and now all the buzz is about Go, Scale, Rust
17:50:27 <theseb> so i'm like...crap....so much to select
17:50:38 <Welkin> for the first two, no and no
17:51:17 <theseb> Welkin: in my little world i'm told the brilliant Google gods made Go to "scale" better..whatever that means
17:51:33 <ab9rf> so they say
17:51:33 <Tuplanolla> The meaning is important.
17:51:34 <theseb> Welkin: 2nd one should have been "Scala"
17:51:56 <hpc> they made go scale by making it do nothing, afaict
17:52:02 <hpc> it's the same way fortran scales
17:52:02 <Welkin> plan9 trolls made Go
17:52:06 <Welkin> for no reason
17:52:49 <Sonolin> hey, I like Go... 
17:52:49 <theseb> Rust is a better C...i.e. for low level speedy apps......Scala is great for fault tolerant afaict...so is Haskell
17:53:44 <ab9rf> go is what happens when you identify tradeoffs in language design, and then choose the worst possible option for each one
17:53:51 <Tuplanolla> My favorite remark about scaling is this one written by Gary Fredericks: "If you need the database to be fast, we recommend not putting too much data in it."
17:54:19 <glguy> Generic comparisons with Go and Scala and Ruby and ... C and whatever else are off topic in #haskell
17:56:56 <roboguy`> theseb: maybe asking more specific Haskell questions would help you out?
17:58:55 <dfeuer> Ping phadej 
18:01:21 <sophiag> i'm wondering if anyone has time to offer some general help with some code i'm working on? trying to port the simple parser from the K&R C book: http://lpaste.net/349957 and i've tried two different formats...one with pattern matching: http://lpaste.net/349955 and one with conditionals more like the C code: http://lpaste.net/349956. both are throwi
18:01:21 <sophiag> ng runtime errors i'm having a bit of trouble understanding in order to begin debugging them
18:02:18 <dfeuer> Anyone here have much experience writing Read1 instances? The one I just wrote for Data.Tree is a bit complicated, and I could use a code review.
18:03:11 <dfeuer> (and writing QuickCheck properties for Read instances does not strike me as a particularly simple matter.)
18:03:23 <dfeuer> Er, I mean Read1. Whatever.
18:04:56 <hackrilege> You need to pattern match [] in matchHere
18:05:25 <hackrilege> You have only matched (x:xs,y:ys)
18:06:14 <sophiag> for which string?
18:06:19 <hackrilege> In matchStar also
18:06:39 <theseb> roboguy`: is this correct..Haskell is most powerful fault tolerant awesome lang but most are afraid to use it because they think it is more complex?
18:06:40 <hackrilege> You use tail...
18:06:56 <sophiag> matchStar shouldn't need to test if the regex is empty
18:07:01 <theseb> roboguy`: hence the people that learn haskell will be the gods of software
18:07:09 <dfeuer> theseb, you should listen to glguy.
18:07:11 <sophiag> matchHere does test for both
18:07:25 <hackrilege> You should always make a basecase when pattern matching (x:xs) in a recursive function
18:07:41 <sophiag> hackrilege: first of all, which example are you referring to?
18:07:47 <hackrilege> Both
18:07:48 <theseb> dfeuer: where is this glguy? haskell enthusiast?
18:08:24 <sophiag> ok, first of all those are both helper functions
18:08:36 <hackrilege> matchHere will fail if passed ([],_) or (_,[])
18:08:52 <sophiag> lines 17 and 20
18:09:00 <sophiag> i do test for those
18:09:16 <hackrilege> The errors are on lines 16 and 26
18:09:31 <jchia> If I want to make an instance of ReaderT with a redefined mplus <|>, how do I do it? E.g, I want to make a special version of ReaderT Foo m a where a is a Monoid, and the special version behaves exactly like ReaderT Foo m a but mplus and <|> are redefined to operate over the Monoid operators of a
18:09:35 <sophiag> those are the function declaratoins
18:09:53 <sophiag> hackrilege: you said this applies to both examples, right?
18:10:11 <sophiag> so i have runtime errors on lines 16 and 26 in both examples?
18:10:27 <sophiag> or are you talking about just one?
18:10:28 <dfeuer> theseb, his name is Eric Mertens. See https://hackage.haskell.org/user/EricMertens for a list of packages he maintains or co-maintains, and note that he is also a package trustee. Perhaps more to the point, he is an operator in this channel and can ban you.
18:10:39 <hackrilege> You should replace (x:xs,y:ys) with (x,y) in the function argument and case expression and it should work
18:10:59 <hackrilege> Oh, and on line 9 also
18:11:43 <sophiag> and then just use tail?
18:12:31 <hackrilege> In the second paste you should not use head like that
18:13:18 <sophiag> what do you mean?
18:13:43 <sophiag> the thing is i need to test for the index 1 and i'd rather not use !!
18:14:29 <sophiag> same as how if i use (x,y) as the arguments i'll have to use (tail x, tail y) for some of rhs of the cases
18:14:54 <hackrilege> You could replace the then statement by pattern matching eg matchHead (x:(xs@('*':_))
18:15:00 <hackrilege> )
18:15:22 <sophiag> well, i'd rather stick with the first version without all the conditionals if i can do it that way. much simpler
18:16:03 <hackrilege> Probably it would be better to not use case and write a bunch of definitions
18:16:08 <sophiag> ah ok
18:16:27 <sophiag> that should be fine i think
18:16:35 <sophiag> in the same form?
18:17:40 <hackrilege> The easiest would be to use the first version and replace the argument in the function definition which you provide to case for matching simply with 'a'
18:18:29 <hackrilege> You don't want to use something that could fail to match if your not going to provide exhaustive definitions
18:19:22 <hackrilege> match a = case a of
18:19:48 <hackrilege> And the same for the matchHere and matchStar
18:21:01 <jchia> How do I make a newtype deriving everything of the type it 'contains'? How do I make a newtype deriving everything except for a few specific typeclasses?
18:21:25 <sophiag> i'm thinking i'd rather not use case and just learn to match it correctly
18:21:52 <hackrilege> Awesome times
18:22:34 <hackrilege> The case version seems fine though if you remove your error
18:22:51 <sophiag> oh really?
18:23:08 <hackrilege> Yeah it's just a stylistic preference
18:23:26 <sophiag> yeah i'm not sure how to do with just pattern matching anyway and still pass along the list to the other functions
18:24:07 <sophiag> so to be clear, you're saying instead of xs and ys i should use tail x and tail y ?
18:24:22 <hackrilege> What do you mean? It's basically the same as case, the variables assigned in the definition are available in the whole scope of the function definition
18:24:27 <geekosaur> I thin most haskellers would tell you the opposite
18:24:57 <sophiag> geekosaur: well here's my code... http://lpaste.net/349955
18:25:01 <hackrilege> No I mean "match a = case a of"
18:25:24 <sophiag> and then how do i match for x, y, xs, ys, etc. ?
18:25:45 <hackrilege> And I guess the case below otherwise is redundant
18:26:12 <sophiag> i keep asking the same question
18:26:25 <sophiag> if i do match a = case a of"
18:26:30 <geekosaur> (1) you should probably use multiple definitions
18:26:35 <hackrilege> Yes then the recursive calls would use eg tail
18:27:07 <hackrilege> Assuming you use (x,y) rather than a
18:27:15 <geekosaur> match ([],_) = Sum 0; match ('^':_,_) = ...
18:27:18 <hackrilege> The problem came from using (:)
18:27:36 <sophiag> alright i'm just going to wait while you guys sort out advice i get
18:27:42 <dfeuer> Anyone have a guess as to why Data.Graph.SCC doesn't have basic instances like Eq, Ord, Read, or Show?
18:27:56 <geekosaur> but matchHere is about a different issue, probably that x:xs does not match []
18:28:04 <hackrilege> geekosaur, then xs or ys is not available, that was the concern
18:28:05 <sophiag> i'm not sure what to do when i get conflicting advice every few lines from the same person
18:28:06 <geekosaur> it only matches non-empty lists/Strings
18:28:18 <geekosaur> sophiag, I do not see a conflict here
18:28:24 <geekosaur> except perhaps in your understanding
18:28:30 <dfeuer> Now whether anyone cares about Data.Graph, ..., well, I don't know about that.
18:28:40 <geekosaur> what is the conflict you imagine?
18:29:13 <sophiag> i was told to use "match a = case a of" and then use tail x
18:29:23 <dfeuer> tail?
18:29:26 <hackrilege> There are a bunch of ways to do it, eg using fst and snd on the variable a
18:29:32 <dfeuer> There are very few legitimate uses of tail.
18:29:44 <sophiag> well, this is what i mean
18:29:44 <geekosaur> no, I see you thinking you need tail for some reason
18:29:53 <geekosaur> which tells me you don't quite have a handle on pattern matching
18:29:58 <sophiag> because the first person to answer me advised me to
18:30:08 <geekosaur> also: what did you think that "otherwise -> " does?
18:30:15 <sophiag> rather than matching for (x:xs,y:ys)
18:30:23 <sophiag> i was told that was the source of my runtime error
18:30:30 <dfeuer> I've seen maybe two or three places *ever* where tail was used legitimately.
18:30:45 <geekosaur> sophiag, it possibly could be, because it doesn't do what you think
18:31:03 <geekosaur> (a) the case underneath will never be matched, because "otherwise ->" ate it
18:31:29 <sophiag> yeah i realize that
18:31:31 <hackrilege> I don't agree that tail is useless, head and tail can be used instead of a (x:xs) pattern everywhere one appears. Not saying you should, but there is nothing wrong with it so long as you handle the basecase correctly
18:31:49 <geekosaur> (b) "otherwise" there has nothing to do with "otherwise" in guards. it's a wildcard match that creates a new local binding that has nothing to do with "otherwise" as used in guards (where "otherwise" is literally an alias for True)
18:31:52 <sophiag> why wouldn't i use (x:xs,y:ys)? that seems to make the most sense?
18:32:18 <sophiag> i was using otherwise to attempt to replicate a do-while loop through pattern matching
18:32:26 <geekosaur> you are matching the same thing twice. why does that make the most sense?
18:32:28 <sophiag> but i realize it doesn't work
18:32:46 <geekosaur> also: order of patterns matters
18:33:00 <geekosaur> and the canonical wildcard pattern is _; using "otherwise" there is confusing
18:33:11 <geekosaur> [15 02:26:52] <geekosaur> match ([],_) = Sum 0; match ('^':_,_) = ...
18:33:15 <sophiag> ok got it
18:33:37 <sophiag> i can replace the first otherwise with (_,_)
18:33:47 <geekosaur> it should be _ and it should be *last*
18:33:54 <sophiag> the point is just i need it to loop through that before testing the last case
18:33:55 <geekosaur> after the other pattern, so the other pattern can match
18:34:17 <geekosaur> (I am talking about line 12 in your paste specifically)
18:34:39 <hackrilege> You could put the basecases (where you use Sum and match []) in the function definition and then when (x:xs,y:ys) is safe, use the rest of your case expression...
18:35:20 <geekosaur> I don't see what;s wrong with just collapsing the explicit case into the implicit one
18:35:21 <sophiag> yeah, i think i'm being too literal in comparing it to the C code. you understand what i'm saying about how the C code has do-while instead of just while, though, right?
18:35:55 <hackrilege> C!?
18:36:04 <hackrilege> No sir
18:36:15 <geekosaur> and, uh, you will get pretty much nowhere trying to match Haskell and C code :)
18:36:27 <sophiag> hackrilege....this is the entire thing you've been responding to....
18:36:45 <hackrilege> I was just reading your Haskell code
18:36:50 <geekosaur> I mean, you can write C in Haskell if you insist (more verbose and not a whole lot like native/idiomatic Haskell)
18:36:57 <sophiag> hackriilege saw the C code.. geekosaur: you came in later
18:37:13 <hackrilege> I saw no c code!
18:37:21 <hackrilege> What an accusation
18:37:29 <sophiag> ok, so you only read half the question i asked before responding to it?
18:37:52 <sophiag> i assumed you read my question since you jumped in to answer it. my bad
18:37:54 <geekosaur> hackrilege is kinda prone to that, sadly
18:38:02 <sophiag> yikes
18:38:17 <sophiag> anyway...
18:39:05 <jchia> Is there a function f :: (Traversable t, Applicative m, Monoid a) => t (m a) => m a that basically mconcats the results of all the (m a) values? e.g. f [pure "a", pure "b"] should return pure "ab".
18:39:06 <sophiag> so first i should decide whether to stick with cases or just use pattern matching. i'm thinking the latter, but not sure how to do it then
18:39:32 <geekosaur> just looking at the Haskell paste I see a number of weirdnesses, tbh. but as for "then xs or ys is not available". that's kinda the point; in those cases, neither *exists*. how then should they be made available?
18:40:04 <Tuplanolla> :t fold -- There's this, jchia.
18:40:06 <lambdabot> (Monoid m, Foldable t) => t m -> m
18:40:06 <geekosaur> but each pattern defines bindings for that pattern only; the xs in one pattern is not related to the xs in the next
18:40:37 <geekosaur> so if one pattern you have no xs, you just don't pattern match or use it. this does not affect the xs in the next pattern, if it has one
18:41:23 <geekosaur> oh, hm, actually I think I see the core of your confusion
18:41:38 <geekosaur> you do things like ('$':null:_,_) -> 
18:41:40 <glguy> sophiag: I didn't read the wall of text above, did someone explain to you that ('$':null:_,_)
18:41:54 <geekosaur> "null" there doesn't test equality
18:41:55 <glguy> makes a new name null, not checking for equality
18:42:03 <geekosaur> it matches anything and makes it available locally as null
18:42:10 <sophiag> ah ok
18:42:13 <geekosaur> likewise (y:_,_) doesn't compare against y
18:42:14 <glguy> and then I don't know what you think casing on otherwise does
18:42:41 <geekosaur> for that you need guards, not patterns
18:42:59 <jchia> :t fmap fold . sequence
18:43:01 <lambdabot> (Monoid b, Traversable t, Monad f) => t (f b) -> f b
18:43:06 <geekosaur> patterns match *structure*, they do not match values except in the case where a value is completely described by its constructor
18:43:47 <glguy> sophiag: also alternatives are tried from top to bottom
18:43:49 <sophiag> i'm trying to refactor it to get rid of the case expression first
18:44:02 <Tuplanolla> :t fmap fold . sequenceA -- Rather this, jchia.
18:44:03 <jchia> :t fmap fold . sequenceA -- Tuplanolla, I think this is what I want.
18:44:03 <lambdabot> (Monoid b, Traversable t, Applicative f) => t (f b) -> f b
18:44:05 <lambdabot> (Monoid b, Traversable t, Applicative f) => t (f b) -> f b
18:44:10 <geekosaur> when you do need to capture components of a pattern, you can use as-patterns
18:44:12 <Tuplanolla> Good timing.
18:44:15 <jchia> yeah
18:44:15 <glguy> sophiag: also,   x:xs is never going to match the [] pattern
18:45:10 <sophiag> i think it'll help to break it down so that way i'll get compile time errors
18:45:21 <sophiag> it'll help me understand the matching better
18:45:26 <geekosaur> x@(ys@(_:_),zs@(_:_)) matches the entire tuple as x, the entire non-empty list first element of the tuple as ys, and the entire non-empty second element as zs
18:45:50 <glguy> sophiag: (x:xs) doesn't match all lists, it only matches non-empty lists
18:46:27 <glguy> so all your top-level definitions that only match on the cons pattern with:  (x:xs)
18:46:31 <glguy> will fail for empty lists
18:48:02 <sophiag> i'm having trouble absorbing all this...refactoring it into separate matches first so i can see exactly where the problems are
18:49:14 <geekosaur> I'm thinking you might have wanted to start with something simpler
18:49:34 <geekosaur> this is likely to end up being a complex set of patterns and guards
18:50:14 <sophiag> i don't think it should be that complicated. just a matter of translating it correctly
18:50:39 <sophiag> i just need a minute to refactor it
18:52:33 <jchia> How can I search for an existing library function of the type "(Monoid b, Traversable t, Applicative f) => t (f b) -> f b"? It seems that www.haskell.org/hoogle is not smart enough for this.
18:54:04 <roboguy`> jchia: Hayoo is sometimes better at that sort of thing http://hayoo.fh-wedel.de/
18:56:13 <dfeuer> Still hoping for someone to check out this Read1 instance. Anyone?
18:56:37 <dfeuer> Re-ping phadej?
18:57:48 <sophiag> geekosaur: ok, so i'm still not sure i'm translating the C code correctly, but aside from that i'm mainly confused by how to go about lines and 24 here: http://lpaste.net/349955
18:57:54 <dfeuer> jchia, I wouldn't expect that to be a library function.
18:58:10 <sophiag> on 17 i'm trying to match the head of the first list to the head of the second
18:58:25 <dfeuer> jchia, presumably, that's just  fmap fold . sequenceA ?
18:58:26 <sophiag> oops...sorry on line *20*
18:58:28 <glguy> dfeuer: Is the Read1 instance somewhere?
18:58:38 <dfeuer> :t fmap fold . sequenceA
18:58:40 <lambdabot> (Monoid b, Traversable t, Applicative f) => t (f b) -> f b
18:59:13 <sophiag> line 24...trying to test the char at the beginning to match index 1 of the second list
18:59:22 <dfeuer> glguy, https://github.com/haskell/containers/pull/366
18:59:42 <geekosaur> sophiag, again, you can't do that with just a pattern, you need a guard as well
18:59:59 <sophiag> ah ok
19:00:38 <geekosaur> matchStart (c,_,y:c0:ys) | c == c0 = ...
19:00:45 <geekosaur> er, matchStar
19:01:03 <sophiag> ah i see. thanks
19:01:07 <geekosaur> you don't need an otherwise guard if you just want to try the other patterns
19:01:14 <dfeuer> I merged it already (with minimal testing) because we're trying to get a major version out the door, but I'd love to get another pair of eyes on it anyway.
19:01:16 <sophiag> i'm not using otherwise in this versoin
19:01:26 <sophiag> ugh, chopping irc is screwing up my typing
19:01:44 <sophiag> geekosaur: do you see anything obviously wrong with it i'm *not* catching?
19:02:39 <jchia> dfeuer: Yes, that's the fmap fold . sequenceA
19:02:57 <geekosaur> line 16 I don't think you need the tail unless you actually want to ignore the first character of xs as well as the ones you already matched (and even then I'd just move it into the pattern)
19:03:45 <geekosaur> line 20 is the same issue as line 24, need to use a guard to compare things, not just duplicate y in the pattern
19:03:47 <glguy> dfeuer: seems right to me so far. the only thing I can think of to suggest is merging  showString ", " . showString "subForest = ", and I wouldn't even argue if you liked it better this way
19:03:57 <dfeuer> jchia, yeah, I just wouldn't expect anyone to bother putting that in a library. It doesn't seem useful enough. 
19:03:59 <sophiag> (there were some compiler errors i fixed related to holes, but other than that i mean)
19:04:06 <sophiag> yup, line 20 fixed
19:04:38 <dfeuer> glguy, thanks, I'll change that. But I was mostly concerned about the Read1 instance, since it's a bit on the complicated side.
19:04:43 <jchia> OK
19:05:12 <dfeuer> glguy, oh, and basically everything to do with precedence management, which I do not trust myself with.
19:05:15 <sophiag> geekosaur: line 16 i think i do actually need to chop the head off the tail. what do you mean move it to the pattern? like use two conses?
19:05:35 <sophiag> oh, actually i do already. i think you're right
19:05:36 <geekosaur> matchHere (x:
19:05:38 <geekosaur> er
19:05:58 <sophiag> i already have (x:'*':xs,y:ys)
19:06:11 <sophiag> so xs is minus two indices
19:06:12 <geekosaur> matchHere (x:'*':_:xs,ys) = matchStar (x,xs,ys)
19:06:19 <geekosaur> if you need to skip the first thing in xs
19:06:30 <glguy> dfeuer: actuall
19:06:35 <geekosaur> if you just wanted to skip the first character and star, all you need to do is not use tail
19:06:41 <glguy> dfeuer: I don't think you're expected to call liftReadList
19:06:45 <geekosaur> matchHere (x:'*':xs,ys) = matchStar (x,xs,ys)
19:06:55 <sophiag> yeah exactly. you were right from the start
19:07:40 <dfeuer> glguy, why not?
19:07:43 <geekosaur> this may be incorrect if you actually need ys to be nonempy there, though: in that case, matchHere (x:'*':xs,ys@(_:_)) = matchStar (x,xs,ys)
19:07:59 <glguy> dfeuer: That method is for the [] instance to use
19:08:15 <geekosaur> because it's pointlessly building a *new* list otherwise
19:08:17 <sophiag> oooo, it might be working :)
19:08:27 <sophiag> i need to test it more tho
19:08:34 <glguy> dfeuer: Well, you wouldn't use it writing the Read instance
19:08:43 <sophiag> i ran the simplest of tests: ./regex "^xyx" "xyxlmnop"
19:08:47 <glguy> dfeuer: now I have to think about if things are different with Read1
19:10:06 <sophiag> this is the kind of thing where liquid haskell would make sense...if it were actually serious and not an exercise
19:10:15 <sophiag> just due to the complexity of enumerating the test space
19:10:39 <geekosaur> there's a number of other things I would change, but one step at a time...
19:11:01 <dfeuer> glguy, I think otherwise I need to either write a binding that does exactly the same thing manually, or pull some horrible trick with a Compose-like type.
19:13:23 <sophiag> yeah...no. it only seems to be working for the carrot :/
19:15:35 <sophiag> also not actually summing them. just testing one occurrence. i think the code just might be designed like that so unless i'm going to go all out i may as well not use Sum
19:16:04 <sophiag> welp, 25% working
19:17:52 <glguy> dfeuer: I think it would come out like this,       (fr, s9) <- liftReadsPrec (liftReadsPrec rd rdl) (liftReadList rd rdl) 0 s8
19:19:00 <glguy> But given that we know what the instance for list does it's probably OK to inline in here like this
19:19:54 <glguy> that is to leave it like you wrote
19:20:07 <dfeuer> glguy, yeah, I'm pretty sure it will come out the same.
19:22:05 <sophiag> geekosaur: so i tried changing line 26: http://lpaste.net/349955 and now getting a non-exhaustive pattern error on that function
19:22:21 <sophiag> do i need a line with (_,_,_) as well?
19:22:35 <dfeuer> glguy, indeed, the Read1 [] instance says  liftReadsPrec _ rl _ = rl, so that reduces your thing immediately to  liftReadList rd rdl
19:24:37 <glguy> lgtm, then
19:25:30 <dfeuer> Cool.
19:25:33 <dfeuer> Thanks.
19:26:11 <geekosaur> sophiag, that depends on where it was reporting from. if you compile with -Wall ghc should tell you which cases you are missing
19:26:40 <geekosaur> and on a quick look it seems to me you are missing (_,[],_) in matchStar
19:26:43 <sophiag> well, i just went ahead and tried it and it's back to not working
19:26:50 <sophiag> yeah i should try that one
19:27:05 <sophiag> it seems i'm missing a looping case there, though
19:27:21 <sophiag> here's the C code if you're at all interested: http://lpaste.net/349963
19:28:36 <dfeuer> :q
19:29:18 <dfeuer> glguy, do you have any guesses as to why Data.Graph.SCC has no Show, Read, Eq, or Ord instances? Also, do you have any sense of whether anyone cares about Data.Graph?
19:30:27 <glguy> dfeuer: I don't know the actual reasons. https://github.com/haskell/containers/issues/51
19:30:56 <geekosaur> I saw it earlier. not that interesting aside from "oh look POSIX BRE" >.>
19:31:17 <sophiag> yeah
19:31:25 <dfeuer> glguy, looks like there's no good reason. May I ask what you use Data.Graph for?
19:31:27 <sophiag> but just to show what i'm trying to do i guess
19:32:04 <sophiag> i think the issue clearly must be that in both matchStar and match i don't have a recursive case to match the do-whiles in the C code
19:32:40 <sophiag> i figured wrt to matchStar that the first two cases were handling that
19:32:53 <sophiag> since all it does is call matchHere
19:34:10 <sophiag> in both cases it should just keep doing that until it matches the empty list i specified, right?
19:35:50 <glguy> dfeuer: I don't remember what I was using it for at that time
19:36:36 <dfeuer> Oh well.
19:36:54 <glguy> I've used it recently for topSorting a module graph
19:37:12 <dfeuer> glguy, well, since it seems to get some use, I'll add instances.
19:37:29 <geekosaur> sophiag, I think your recursion is mis-specified / your translation of the C is not quite right
19:37:48 <geekosaur> if you are doing it in Haskell with pattern matching, you actually want a somewhat different organization than the C
19:38:18 <sophiag> yeah, i know it must not be right! i just can't figure out how :p
19:38:36 <sophiag> but i don't actually have any direct recursive calls if you look
19:38:48 <sophiag> i'm not sure that's the problem tho
19:40:22 <geekosaur> ok, the problem is you try to recurse by invoking matchHere
19:41:35 <geekosaur> but matchHere is not recursive in the way you need; you need to recurse on matchStar, and matchHere is a go/no-go one-shot for "so does the rest match here or should I try matching another c instead?"
19:42:58 <nitrix> ertes: What limitations arises in an FRP system if it doesn't allow dynamic switching?
19:43:06 <geekosaur> matchStar (c,xs,ys@(y:_)) | c == y && matchHere (xs,ys) == 1 = 1; matchStar ...
19:43:40 <geekosaur> (this will need to change if you fix the part where it's returning 0/1. I'm not clear if it should be counting something, or just doing the usual C emulation of Bool with int)
19:43:42 <sophiag> right that's what i figured. i need to recurse on matchStar
19:43:51 <sophiag> rather than returning 0 in the base case
19:44:12 <sophiag> it should only return zero if the second list terminates with no match
19:44:43 <sophiag> yeah i'm not sure if i can change it to count multiple matches or i should just change it to return Bools
19:44:57 <geekosaur> it would not count multiple matches
19:45:13 <geekosaur> you need to reconsider how ^ and $ work for that to even be meaningfuk
19:45:15 <nitrix> ertes: Is it bearable or would it be considered completely broken? I'm looking at a way to avoid time glitches (executions in the wrong order) by topologically sorting the dependencies, but this dynamic thing complicates the picture.
19:45:15 <sophiag> yeah, it's not in the one case where it's working
19:45:16 <geekosaur> *meaningful
19:45:27 <sophiag> ok, so i'll switch to Bools then
19:45:30 <geekosaur> so I think the C code is just doing Bool, but C-flavored
19:45:46 <sophiag> yeah i know. it's one of the main hacks all of UNIX is based around :p
19:45:56 <sophiag> hence that little test function to convert it to reality
19:46:29 <sophiag> so just trying to make sure i understand your suggestion to recurse on matchStar
19:46:37 <geekosaur> well. C is fundamentally a systems programming language; how it treats booleans is fine for that :)
19:46:55 <sophiag> i think it's more the other way around
19:46:56 <geekosaur> but people insist on using it for general purpose programming, which should really be done at a higher level than C
19:47:06 <sophiag> it happens to treat bools that way so all the code takes advantage of it
19:47:07 <geekosaur> systems programming languages are *necessarily* very low level
19:47:31 <sophiag> i mean, is Fortran like that?
19:47:47 <geekosaur> for most of its history, yes
19:47:50 <sophiag> ah ok
19:48:05 <sophiag> but none of the pointer arithmetic, right?
19:48:09 <geekosaur> even lower level than C; it's intended to get as close to the hardware as possible for the fastest possible number crunching
19:48:45 <sophiag> right, that's why i'm saying some of these things are just idiosyncrasies and not resulting from it mapping to assembly
19:48:53 <jchia> Given that now a Monad is an Applicative, does it make sense to redefine in my own codebase sequence as sequenceA and get rid of sequenceA? Would having both original sequence & sequenceA be beneficial at all for a code base, e.g. in terms of disambiguation power?
19:50:29 <jchia> Is there an alternative Prelude that does away with some of this type of language baggage that's fairly uncontroversial?
19:50:42 <sophiag> geekosaur: so i'm just having trouble understanding this (c,xs,ys@(y:_))
19:50:49 <nitrix> I'm sure a lot of people are wondering the same thing, but somehow I feel like the decision will be to "maintain backwards compatibility"...
19:51:18 <sophiag> as in how that differs from (c,xs,y:ys) for this purpose?
19:51:33 <shapr> jchia: I've seen several alternative preludes, I'm sure one of them goes ahead and makes these kinds of changes.
19:51:48 <geekosaur> I collapsed the x:xs to just xs because you never used x. ys@(y:_) gives you ys that is the whole thing (rather than repeating y:ys on the right, which builds a new list instead of reusing the perfectly good existing one) while still giving you the y for the other comparison
19:51:55 <ezyang> jchia: Does Foundation count? 
19:52:30 <shapr> ezyang: oh this? https://hackage.haskell.org/package/foundation
19:52:43 <geekosaur> but, now that I think about it, that's actually wrong because you have effectively inverted the do/while in your Haskell
19:52:44 <ezyang> yep 
19:52:52 <ezyang> I just wrote an adaptor module for their string type for my Backpack strings :) 
19:52:53 <sophiag> ah i see
19:53:16 <sophiag> yeah it's not right when i compile it
19:53:20 <geekosaur> what it does is first check matchHere, then onlyif that fails does it look at c at all
19:53:24 <geekosaur> (in C)
19:53:36 <sophiag> i see what you're going for with the match tho
19:53:45 <geekosaur> but your code, and what I rewrote it into, checks c *first*
19:54:05 <sophiag> ah right
19:54:34 <sophiag> huh so that explains why it's not working
19:54:48 <geekosaur> matchStar (_,xs,ys) | matchHere xs ys = 1; matchStar ...
19:54:53 <jchia> ezyang: Let me read up on it.
19:55:06 <geekosaur> (assuming matchHere produces Bool, you need to compare to 1 as it currently is)
19:55:14 <geekosaur> matchStar (_,xs,ys) | matchHere xs ys == 1 = 1; matchStar ...
19:55:56 <sophiag> ah right. that case needs to go first
19:56:12 <geekosaur> right, that happens first and then we test c and recurse if appropriate
19:56:23 <geekosaur> or produce 0 if it doesn't match
20:00:08 <sophiag> ok, 50% there. working for the kleene star, not for single match
20:00:32 <sophiag> and i assume still not for $
20:09:18 <dfeuer> glguy, do you care whether AcyclicSCC x < CyclicSCC y or the other way around?
20:10:58 <jchia> nitrix: I really hope the baggage gets obliterated soon. It's quite annoying for new codebases, and it is more pervasive than just Prelude. A lot of base package has the baggage. E.g. Control.Monad.Except reexports Control.Monad, and Control.Monad defines sequence. If I import Control.Monad.Except, I get the old 'sequence' conflicting with whatever custom 'sequence' I'm using and I have to resolve ambiguity.
20:11:45 <dfeuer> jchia, most people want sequence redefined to sequenceA, which still won't free up that name for you.
20:11:59 <dfeuer> Or sequenceA renamed to sequence. Whatever.
20:12:27 <jchia> dfeuer: Renaming sequenceA to sequence (implying getting rid of the old sequence) is good enough for me.
20:12:46 <dfeuer> jchia, I can't promise it'll happen.....
20:22:39 <fearless_man> one dumb question: I'm from python, what are the major/minor differences in using  a different paradigm like functional?
20:23:12 <fearless_man> and what are the pros and cons.
20:23:40 <fearless_man> I really don't understand why haskell has no states?
20:24:56 <kadoban> fearless_man: At first it will look extremely different, it becomes far more natural and familiar over time. Also, most explanations kind of don't really click, at least none did for me, it all sounds like nonsense until you start learning a bit.
20:25:01 <fearless_man> what if you want an object to mutate? will you create another object based on that object?
20:25:05 <nitrix> fearless_man: We actually do have stateful computations; you might be misinformed.
20:25:26 <fearless_man> monads right?
20:25:26 <kadoban> fearless_man: I would say not that haskell has no state, it just has the ability in the type system to represent the difference between code that uses mutable state and code that doesn't.
20:25:56 <dfeuer> glguy?
20:26:52 <fearless_man> kadoban: and the ability to represent a mutable state is monads?
20:27:10 <nitrix> fearless_man: Monads have no relation whatsoever with that problem, other than its convenience to approach it.
20:27:10 <EvanR> fearless_man: haskell has the ability to mutate objects
20:27:18 <kadoban> fearless_man: Not really, but Monad provides a decent interface to some of them. Monad is a convenience thing.
20:27:45 <EvanR> writeIORef :: IORef a -> a -> IO ()
20:28:13 <fearless_man> I've never understand the reason behind using an immutable object, when do you need this?
20:28:15 <EvanR> this isnt really a monad-related feature
20:28:23 <nitrix> fearless_man: Eventually you'll see that `State` is merely a function `s -> (a, s)`.
20:28:50 <EvanR> fearless_man: most of the data you process is immutable, and so not even really objects, you think of it as pure data
20:28:55 <EvanR> which really simplifies a lot
20:29:19 <EvanR> then you can start thinking of your code more like math, not instructions to modify memory
20:29:23 <nitrix> That is, a function that's stateful just takes the old state and yields the new one. Monads are just going to make this more implicit so that it's less painful to work with.
20:29:36 <kadoban> fearless_man: Because reasoning about values is much more sane when they don't change out from under you. You can look at one little part of a program, see the definition of a thing, and know that nothing will change that. That's one reason anyway.
20:29:44 <dfeuer> *grumble*. I guess the Ord instance for SCC isn't going to actually *mean* anything, but serve only to let people use the things as keys.
20:29:52 <ezyang> Straw poll: do you prefer bytestring-signature-major10-minor2 or bytestring-signature-maj10-min2? 
20:29:58 <dfeuer> Although that seems absurd.
20:30:14 <nitrix> ezyang: Former.
20:30:24 <EvanR> if you ever noticed in javascript that strings are immutable, and noticed how much pain and suffering that has saved you from, then imagine that expands to everything
20:30:49 <dfeuer> Anyone else care about how the Ord instance for Data.Graph.SCC should behave?
20:31:01 <dfeuer> Going once! Going Twice! ....
20:31:02 <ezyang> dfeuer: "Maybe it shouldn't have one"?  
20:31:25 <dfeuer> ezyang, quite possibly. glguy wanted one at some point, but doesn't remember why.
20:31:43 <dfeuer> But yeah, I guess the safe thing is to leave it out.
20:31:46 <fearless_man> say I have a data that has list of names, when I modify it, it becomes an object, if I save it , it becomes data again, am I wrong?
20:31:52 <EvanR> nope
20:32:16 <dfeuer> ezyang, yeah, that's what I'm going to do until someone cares enough to ask for what they want there.
20:32:19 <EvanR> if you have a record with a list in some field, you can update that record, but its an immutable update, you get a new records
20:32:33 <nitrix> fearless_man: We have neither data or objects, we with with values :)
20:32:44 <kadoban> fearless_man: Not really clear what you mean by an "object" there or "data"
20:32:51 <kadoban> (So probably no)
20:32:57 <nitrix> fearless_man: You can create values based on other values.
20:33:21 <ezyang> OK, so, how about when you have something like 1.2 
20:33:27 <ezyang> major12, 1major2, something else? 
20:33:29 <EvanR> fearless_man: in python and similar, you may not yet know that records and lookup tables ought to be distinct entities, kind of like how arrays and lookup tables should be distinct (but arent) in PHP
20:33:31 <fearless_man> so everthing you create is immutable?
20:33:41 <ezyang> (major102) 
20:33:42 <nitrix> fearless_man: That's the idea.
20:33:55 <fearless_man> so you are 100% sure they wont change
20:34:02 <fearless_man> no side effects
20:34:03 <EvanR> i dont want 4 to change
20:34:08 <EvanR> i dont want [1,2,3] to change
20:34:14 <EvanR> i dont want True or False to change
20:34:17 <nitrix> fearless_man: 1 is immutable. 2 is immutable. If I want 3, I create 3 from 1 and 2, I don't have to change those numbers.
20:34:30 <nitrix> fearless_man: They have one and only one meaning, there's no point and changing it.
20:34:32 <fearless_man> now I understand
20:34:44 * geekosaur suddenly reminded of ancient FORTRAN compilers
20:34:55 <fearless_man> then how about memory allocation?
20:35:08 <nitrix> fearless_man: Happens magically for you.
20:35:14 <EvanR> implementation detail
20:35:35 <EvanR> fearless_man: a lot of the time, immutable data can be shared, and so its not allocated
20:36:18 <EvanR> if i slice out the middle of a long array, i dont have a copy of that region, its just a pointer
20:36:24 <nitrix> fearless_man: If you're worried, creating a new record from an older record, the compiler will share the pointer of the remaining data that you didn't modify.
20:36:47 <nitrix> fearless_man: It can do that because things are guaranteed not to change. We get to optimize tons of stuff by sharing pointers.
20:37:13 <fearless_man> so it's like clay vs lego blocks, mutable vs immutable
20:37:32 <fearless_man> nothing is wasted they're just reused
20:37:39 <EvanR> interesting analogy
20:37:52 <nitrix> fearless_man: The same pointers also serves another purpose, which is computing something only once, even if it is re-used multiple times (memoization).
20:37:54 <EvanR> lego blocks are immutable ;)
20:38:30 <EvanR> now if you add that you have infinite of each kind of block, youre golden
20:38:38 <EvanR> thats how haskell works, until you run out of memory
20:39:27 <EvanR> and to make the other guy look bad, you can replace the clay with sand castle blocks
20:40:51 <EvanR> if you modify some part of your sandcastle, it could all collapse
20:41:08 <glguy> dfeuer: no, like most Ord instances it doesn't matter
20:41:21 <glguy> just useful for stuff like Map keys
20:41:25 <nitrix> fearless_man: let x = length [1..10000000] in (x, x)  -- The idea here is that the two `x`'s are going to share the same result computed only once, that is the length of that very large list.
20:41:47 <nitrix> fearless_man: And there's even nicer optimization due to lazy evaluation, but that a whole other subject.
20:42:39 <EvanR> well x = foo; [x,x] has the same behavior in python
20:42:47 <EvanR> only one foo in memory
20:43:00 <nitrix> Ah. Not bad.
20:43:49 <nitrix> EvanR: Is it some form of call-by-name?
20:43:55 <joehh> is there a standard way of abstracting out calls to getCurrentTime for testing
20:44:08 <EvanR> pass the current time in as an argument, definitely
20:44:13 <joehh> ie like a MonadHasCurrentTime
20:44:46 <EvanR> or if its a free monad-like thing which asks for the time, then use a different interpreter
20:44:57 <joehh> I'm wanting to test some conduit code that calls getCurrentTime to record when certain events occur
20:44:57 <EvanR> the test interpreter
20:45:29 <joehh> not knowing enough about free monads, how would/can that integrate with conduit?
20:45:44 <EvanR> not knowing much about conduit, no idea
20:45:51 <joehh> I feel that your suggestion is probably what I want
20:45:52 <joehh> :)
20:46:16 <fearless_man> Ok, can I like hang out here? I really wanted to learn haskell, I've tried reading the docs but I can't understand why they're doing something differently.
20:46:41 <joehh> time to read up on free monads
20:47:08 <kadoban> fearless_man: Of course. http://haskellbook.com/ is a good place to start, IMO. There's other ways to go though.
20:48:06 <fearless_man> so the things I'll be learning in haskell an be used in different languanges like python?
20:48:40 <EvanR> it will certainly change your thought process, and thne when you go back to python, you may be horrified at the number of things you need to worry about
20:48:44 <kadoban> Some of the concepts
20:48:52 <EvanR> which is good or bad
20:49:10 <Rotaerk> well, horror at other languages isn't the ONLY thing you get out of it :P
20:49:16 <fearless_man> Like tuple in python are immutable, I never knew why now I do
20:49:23 <Rotaerk> you *can* apply some of the approaches you learn in haskell, in those languages
20:49:37 <EvanR> immutable tuples in python are kind of an arbitrary choice on their part
20:49:52 <EvanR> more things being immutable would be even better
20:50:01 <EvanR> like strings
20:50:28 <EvanR> going with the "might as well be mutable" philosophy doesnt explain why they made tuples immutable
20:50:39 <fearless_man> Another dumb question: If immutability is better, why don't other languages implement it?
20:51:04 <roboguy`> fearless_man: I would say more languages are. Modern C++ has constexpr now
20:51:14 <EvanR> yes, wait a while and see how many adopt it
20:51:26 <EvanR> like lambdas, pattern matching, etc
20:52:08 <fearless_man> so lambdas and pattern matching(regex) came from functional?
20:52:16 <EvanR> not regex
20:53:30 <EvanR> this writeIORef :: IORef a -> a -> IO ()
20:53:32 <EvanR> er
20:53:40 <EvanR> http://lpaste.net/349964
20:53:49 <roboguy`> yeah, regex is a different kind of pattern matching
20:53:50 <EvanR> that
20:54:09 <roboguy`> The kind of pattern matching in Haskell is matching on data structures
20:54:37 <EvanR> fearless_man: pattern matching case analysis, its amazing. switch statement on acid
20:55:05 <EvanR> also other languages do embrace immutability, like clojure, also rust
20:56:32 <EvanR> newer languages
20:57:22 <EvanR> you should have asked why it took so long ;)
20:58:14 <fearless_man> how about date? date in infinite
20:59:21 <EvanR> dates?
20:59:50 <EvanR> dates are just like numbers, why would they change
21:01:11 <fearless_man> There really is no point in changing a data right?
21:02:00 <EvanR> dont change the value of "the date 12-31-1999", but you could update a date field with a different date all you want
21:02:45 <EvanR> insanely a lot of languages give you date objects which actually can be modified
21:03:26 <fearless_man> when we say value do we mean variable?
21:03:32 <EvanR> no
21:03:42 <EvanR> value is like "the date 12-31-1999"
21:04:06 <EvanR> but variable is the x in the code: let x = 2 in x + x
21:04:17 <fearless_man> but that value is put in a variable, and can be updated with diff value?
21:04:28 <EvanR> you cant update variables, no
21:04:46 <EvanR> unlike some languages
21:05:20 <fearless_man> ok, so if I have name = "Mark" and I wan't to change it to "kevin", how do I do that?
21:05:35 <EvanR> you cant
21:05:43 <fearless_man> ow, i'll just use another variable?
21:05:48 <roboguy`> fearless_man: it's more "variable" in a math sense. Consider the function "f x = x + 1". You can give it different numbers in different places in the code, but it never changes within the call
21:05:51 <fearless_man> that contains mark
21:05:56 <EvanR> but if you have a record User { name = "Mark" } then you can update it with record update syntax
21:06:07 <roboguy`> so x is a variable
21:06:10 <EvanR> user { name = "kevin" }
21:06:47 <EvanR> at this point you probably want to install haskell and go through an intro guide, and just try stuff
21:06:55 <fearless_man> yeah
21:07:09 <joehh> I think I'll pass in a (IO UTCTime) function which will be getCurrentTime when running in realtime and a function to query a STM UTCTime when being tested/replaying operations
21:07:22 <EvanR> could work
21:08:53 <joehh> testing will consist of replaying lots of data that was timestamped when collected, so if each time the data is "sent", I updated the STM UTCTime, it should just work...
21:08:57 <joehh> thanks for your thoughts
21:19:56 <glguy> Is the mysterious anonymous user on the AoC #haskell leaderboard willing to send me a /msg sharing identity?
21:20:53 <EvanR> theres only one ?
21:21:10 <glguy> Yeah, you can specifically be "anonymous user #_____"
21:21:20 <shiona> \o
21:21:49 <Axman6> what is AoC?
21:22:06 <glguy> adventofcode.com
21:24:04 <glguy> We've got a leaderboard for #haskell members going for people participating
21:24:40 <glguy> and I'm terrible at memorizing who's on it, so when I refresh like I just did and it grows I'm left wondering :)
21:29:53 <roboguy`> glguy: ooh, I don't think I've seen that before
21:33:13 <glguy> shiona: I got my solution down to running in 0.006 seconds so far :)
21:33:31 <shiona> glguy: I know you're about a million times better at haskell
21:33:36 <shiona> I'm just scraping by
21:34:24 <shiona> yesterday I had to take a look at your code after my program had been running for about nine hours to see how much I need to improve to actually get some results
21:34:28 <glguy> shiona: Are you putting your solutions up anywhere?
21:34:33 <shiona> no
21:34:45 <MarcelineVQ> md5 took a long time to compute for me :(
21:34:46 <glguy> Was it useful to look at mine yesterday?
21:35:02 <glguy> My MD5 solution used cryptonite and took a minute and a half to finish ...
21:35:53 <MarcelineVQ> longer than a minute is a long time to me for puzzles :>
21:36:07 <glguy> There's not much to do about it when the slow part is computing MD5, though
21:36:12 <shiona> yes. I have absolutely no idea about any stringbuilders or whatever you had there, but it did remind me how easy it was to "memoize" the hash results
21:38:59 <shiona> and only function I could find to do md5 result to hex representation was Data.Hex (which seems to make upper case letters), my keyStretch is probably unbelievably slow: iterate (BSC.pack . map toLower . BSC.unpack . hex . MD5.hash)
21:39:45 <amx> pureMD5 worked rather well for me
21:43:35 <Axman6> IIRC there's a bytestring-base16 library
21:43:48 <dfeuer> glguy, I just *imagined* that you wanted an Ord instance for SCC. Sorry for the confusion. Of course, if you can argue for a particular ordering, you're welcome to have it.
21:44:04 <glguy> dfeuer: I'd be happy to have one
21:44:05 <amx> glguy: did you use Par?
21:44:16 <dfeuer> I've added all the instances you actually requested, as well as the Data instance Milan mentioned way back when.
21:44:20 <glguy> amx, no, but that is probably a good idea. Did you?
21:44:31 <amx> no, was too lazy :(
21:45:14 <dfeuer> glguy, is there a particular order that makes sense in context? My guess is no, and that I should just use the derived ordering, but I don't want to pick something and then have someone gripe that it was obviously The Wrong Thing.
21:45:26 <glguy> amx: did you submit a solution for the problem?
21:45:42 <amx> I got my two stars, yes
21:45:51 <glguy> Are you on the #haskell leaderboard?
21:45:54 <amx> yes
21:47:54 <roboguy`> oh man, it's good that I learned about AoC now, *after* finals =)
21:54:43 <glguy> roboguy`: Don't forget to add yourself to the #haskell list if you start :)
21:54:55 <roboguy`> glguy: will do!
22:11:44 <qmm> what is the difference between <<< and .
22:12:48 <Axman6> :t (<<<)
22:12:50 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
22:12:51 <Axman6> :t (.)
22:12:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:13:11 <Axman6> nothing really (assuming you mean Category's (.))
22:15:12 <dfeuer> qmm, there is no difference whatsoever.
22:15:24 <dfeuer> Yeah, what Axman6 said.
22:15:36 <mniip> <<< is more generic
22:15:45 <mniip> letting you compose not only functions
22:16:03 <dfeuer> More generic than Prelude..
22:16:05 <mniip> yes
22:16:11 <Axman6> Category's (.) is identical, Prelude's (.) is just a specialised Category one
22:16:12 <dfeuer> The same as Control.Category..
22:16:13 <mniip> Control.Category.. is identical
22:16:55 <dfeuer> The reason <<< exists is to provide syntactic symmetry with >>>, I believe.
22:19:05 <mniip> well, =<< and >>= exist
22:19:25 <mniip> it just happens that Control.Category.<<< coincides with Prelude..
22:34:32 <gamegoblin> I run stack test and get "    quickcheck must match >=2.9, but the stack configuration has no specified version "
22:34:39 <gamegoblin> fixes?
22:34:50 <gamegoblin> first time using stack, so a little unfamiliar
22:35:07 <MarcelineVQ> QuickCheck
22:36:42 <gamegoblin> MarcelineVQ: thanks
22:36:54 <gamegoblin> MarcelineVQ: do I need to update via stack or something? I now have "    QuickCheck-2.8.2 must match >=2.9 (latest applicable is 2.9.2)"
22:37:41 <effectfully> :i (<<<)
22:37:42 <Axman6> what do you have in your cabal file?
22:38:15 <gamegoblin> Axman6: I have QuickCheck >= 2.9
22:38:23 <MarcelineVQ> the latest lts, lts-7.13, has QuickCheck 2.8.2 you'll need to use nightly-2016-12-14 as your resolver to use QuickCheck 2.9.2 or add QuickCheck-2.9.2 to your extra-deps section of your stack.yaml
22:38:24 <effectfully> lambdabot doesn't want to respond to me? :(
22:38:29 <gamegoblin> in the build-depends of the test-suite section
22:38:41 <gamegoblin> I’ll just lower dep to 2.8
22:38:57 <gamegoblin> works, thanks all
22:39:05 <effectfully> :t (<<<)
22:39:07 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
22:39:19 <MarcelineVQ> lambdabot doesn't have :i
22:39:28 <Axman6> effectfully: lambdabot doesn't answer to :i
22:39:38 <Axman6> @ingo Bool
22:39:39 <lambdabot> Maybe you meant: undo ping
22:39:43 <Axman6> @info Bool
22:39:43 <lambdabot> Bool
22:39:50 <effectfully> how to see the fixity of an operator?
22:39:52 <Axman6> (that doesn't actually do anything)
22:40:00 <Axman6> using :i in ghci
22:40:06 <Axman6> lambdabot isn't ghci
22:40:17 <effectfully> I see
22:40:34 <MarcelineVQ> @info do { x <- [1..10]; return x; } -- Axman6: it does a little :>
22:40:34 <lambdabot> [1 .. 10] >>= \ x -> return x
22:41:03 <Axman6> that's just @undo ;)
22:41:06 <MarcelineVQ> yep
22:41:08 <effectfully> anyways, just wanted to say that (<<<) and (.) have distinct fixities
22:41:29 <effectfully> it's convenient sometimes to use (<<<) with (<=<)
23:00:33 <phadej> @tell dfeuer I'm in Europe, so that ping was a bit too early to me to wake-up
23:00:33 <lambdabot> Consider it noted.
23:00:50 <phadej> :i Bool
23:01:05 <phadej> :(
23:45:11 <bollu> could someone please tell me how to use unsafePerformIO with foreignPointer correctly?
23:45:17 <bollu> I've been having segfaults
23:45:47 <ezyang> bollu: Well, are you touching the foreign pointer correctly 
23:46:27 <bollu> ezyang: what do you mean by that? I'm using "withForeignPtr" everywhere
23:46:31 <bollu> is there something more I need to do?
23:46:32 <bollu> https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L134
23:46:41 <ezyang> does your reference to the pointer ever escape? 
23:47:15 <bollu> ezyang: it can't right? I'm only touching the C values through "withForeignPtr". and I make  a foreign pointer  as soon as I allocate some memory
23:48:04 <ezyang> so, you only ever poke inside withForeignPtr? 
23:49:07 <bollu> ezyang: the first allocation happens through a raw ptr (The C api is of the form basicsym* basicsym_new). I immediately put the thing in a ForeignPtr
23:49:15 <bollu> but the first allocation call happens "outside" a ForeinPtr
23:49:24 <bollu> (since it is C that is allocating the memory)
23:49:55 <ezyang> I mean, that's pretty normal 
23:50:09 <bollu> yes
23:50:20 <bollu> but I wasn't sure if I had to have GHC manage all the memory
23:50:28 <bollu> so I'm using it correctly?
23:50:28 <cocreature> bollu: do you have some kind of minimal example demonstrating the error?
23:50:33 <ezyang> That seems ok 
23:50:52 <ezyang> Usually, foreign ptr segfaults are due to you not realizing that the ForeignPtr has already gone dead when you want to use the memory 
23:50:54 <bollu> cocreature: let me try and give you one
23:50:54 <bollu> cocreature: just (+) crashes 
23:51:15 <bollu> cocreature: https://github.com/bollu/symengine.hs/blob/master/test/Spec.hs#L137
23:51:19 <bollu> cocreature: ^ that crashes
23:51:27 <cocreature> bollu: and the other functions work correctly?
23:51:42 <cocreature> or does it crash at + and the rest is not executed
23:51:50 <bollu> cocreature: crashes at (+)
23:51:56 <bollu> cocreature: nothing is executed after
23:53:06 <cocreature> bollu: so what I would try is writing a minimal example that binds to some custom c code that you have written and first make sure that works. then you can move on to translating that to SymEngine
23:53:37 <bollu> cocreature: I see
23:53:55 <cocreature> debugging ffi stuff can be quite painful
23:54:19 <bollu> yeah, I'm witnessing that
23:54:50 <cocreature> bollu: do the segfaults disapper if you don’t free, i.e. just leak memory?
23:54:59 <bollu> cocreature: I have not tried
23:55:04 <bollu> cocreature: you want me to remove the finaliser?
23:55:10 <bollu> cocreature: interesting
23:55:13 <cocreature> bollu: that would at least be worth a try
23:55:21 <bollu> cocreature: ty, let me try that
23:55:23 <cocreature> just to make sure it’s really caused by the ForeignPtr
23:56:31 <bollu> cocreature: is there a way to create a ForiegnPtr without a finaliser?
23:56:54 <bollu> cocreature: to quickly test the hypothesis
23:57:00 <cocreature> bollu: you can just use "const (pure ())" as the finalizer
23:57:06 <bollu> ah
23:57:08 <bollu> cute
23:57:14 <cocreature> there is also newForeignPtr_
23:57:37 <cocreature> but completely removing the finalizer probably requires more changes than just changing ptr_basic_free_heap_ffi to const (pure ())
23:57:39 <bollu> right, I just saw that
23:58:20 <bollu> wow, okay, it still segfaults
23:58:21 <bollu> hm
23:58:24 <bollu> so the problem isn't memory?
23:58:30 <cocreature> doesn’t look like it
23:58:36 <bollu> cocreature: thanks a ton, I wouldn't have considered this at all
23:58:58 <cocreature> bollu: I’ve written enough ffi code to have stopped trusting my instincts :)
23:58:58 <bollu> cocreature: okay
23:59:10 <bollu> cocreature: let me go back and study the library's contracts
23:59:12 <bollu> cocreature: I probably missed something
23:59:14 <bollu> cocreature: thanks :) 
23:59:31 <bollu> cocreature: also, out of curiosity, which FFI bindings did you write? :3
23:59:39 <cocreature> bollu: np, if you haven’t already done so, compiling with DWARF info and then running in gdb/lldb can be extremely helpful
23:59:46 <cocreature> bollu: I’ve worked on llvm-general a fair bit
23:59:49 <bollu> 	I'm planning on doing that next
