00:00:22 <Lokathor> functors that get paid to not modify their structure when mapping in a function
00:01:38 <DemiMarie> I am getting wierd type errors in GHC when using the ST monad
00:02:11 <lyxia> @lpaste
00:02:11 <lambdabot> Haskell pastebin: http://lpaste.net/
00:03:53 <lyxia> DemiMarie: feel free to paste your code in there ^
00:08:44 <DemiMarie> Can't connect to lpaste
00:09:11 <LordBrain> seems to work from here
00:09:38 <DemiMarie> lambdabot: import Control.Monad.ST.Safe; import Data.Array.ST.Safe; runST $ do { x <- newArray (0, 1) 1; readArray x 1 }
00:10:34 <DemiMarie> @help
00:10:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:10:46 <DemiMarie> > runST $ do { x <- newArray (0, 1) 1; readArray x 1 }
00:10:49 <lambdabot>  error:
00:10:49 <lambdabot>      Variable not in scope:
00:10:49 <lambdabot>        newArray :: (Integer, Integer) -> Integer -> ST s t0error:
00:10:58 <DemiMarie> > runST $ do { x <- Data.Array.ST.Safe.newArray (0, 1) 1; readArray x 1 }
00:11:00 <lambdabot>  error:
00:11:00 <lambdabot>      Not in scope: ‘Data.Array.ST.Safe.newArray’
00:11:00 <lambdabot>      No module named ‘Data.Array.ST.Safe’ is imported.
00:11:05 <DemiMarie> > runST $ do { x <- Data.Array.ST.newArray (0, 1) 1; readArray x 1 }
00:11:08 <lambdabot>  error:
00:11:08 <lambdabot>      Not in scope: ‘Data.Array.ST.newArray’
00:11:08 <lambdabot>      Perhaps you meant one of these:
00:11:26 <dfeuer> DemiMarie, you can PM lambdabot.
00:15:43 <MarcelineVQ> lambdabot won't neccesarily show the same error you're getting as well which is why it's better to paste your code and your error in a pastebin of some kind
00:15:46 <lyxia> DemiMarie: What is the error you are having?
00:15:48 <MarcelineVQ> @let import Control.Monad.ST
00:15:50 <lambdabot>  Defined.
00:15:52 <MarcelineVQ> @let import Data.Array.ST.Safe
00:15:54 <lambdabot>  Defined.
00:16:08 <MarcelineVQ> > runST $ do { x <- newArray (0, 1) 1; readArray x 1 } -- this is lambdabot's error, dunno if it's yours
00:16:11 <lambdabot>  error:
00:16:11 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘newArray’
00:16:11 <lambdabot>        prevents the constraint ‘(MArray a0 a (ST s))’ from being solved.
00:16:32 <DemiMarie> It is the same error
00:16:49 <DemiMarie> How do I resolve it?  Obviously I need a type annotation, but where?
00:18:26 <lyxia> newArray (0, 1) 1 :: ST s (STUArray s Int Int) maybe?
00:18:57 <DemiMarie> That works
00:19:42 <lyxia> Take a look at vector, it has a much simpler interface.
00:20:00 <DemiMarie> If I recall correctly, vector is faster too
00:22:13 <Philippa> okay, thanks for the links, folks!
00:57:51 <Profpatsch> persistent gurus:
00:58:09 <Profpatsch> I want to derive JSON instances for the datatypes generated by persistLowerCase                                                        
00:58:10 <Profpatsch> But I can’t find a way to structure it that it doesn’t throw instance errors                                                           
00:58:12 <Profpatsch> I already split the modules of DB TH types and other data using them, but this other data cannot derive json instances, GHC says the DB
00:58:14 <Profpatsch> types don’t have instances                                                                                                             
00:58:16 <Profpatsch> Code: http://lpaste.net/349717                                                                                                         
00:58:18 <Profpatsch> And it’s impossible to enable DeriveAnyClass in the TH module: https://github.com/yesodweb/persistent/issues/578                       
00:58:20 <Profpatsch> What can I do?                                                                                                                         
00:58:22 <Profpatsch> Err, sorry for the paste fu.
01:01:22 <Cale> Profpatsch: Can you add some StandaloneDeriving to the bottom of the module which defines Mobilfunk to help that?
01:01:57 <Profpatsch> Cale: You mean instance Mobilfunk ToJSON where?
01:02:33 <Cale> If you wanted to write it manually, that would also probably work?
01:03:23 <Cale> I was thinking like  deriving instance Generic Mobilfunk
01:03:32 <Cale> and then  deriving instance ToJSON Mobilfunk
01:03:40 <Profpatsch> Cale: Hm, now I get     • Expecting one fewer argument to ‘Mobilfunk’
01:03:41 <Profpatsch>       Expected kind ‘(* -> Constraint) -> Constraint’,
01:03:54 <Profpatsch> argh, I hate TH.
01:04:02 <Cale> er, oh, you flipped it around
01:04:06 <Cale> The class name goes first
01:04:42 <Profpatsch> Right. I’m not awake yet.
01:07:13 <Profpatsch> Heck yeah.
01:08:02 <Profpatsch> So it works if I put a deriving Generic in the persistent TH definition.
01:08:18 <Cale> Can't you also do that after though?
01:08:35 <Cale> If you don't want to edit persistent, you can just use StandaloneDeriving
01:08:43 <Profpatsch> And then do an instance ToJSON/FromJSON for the generated types afterwads.
01:09:16 <Profpatsch> Ah, not in the persistent source, but in my database table definitions.
01:09:27 <Cale> ah
01:10:06 <Cale> Does persistent expect to define the types for you?
01:10:54 <Profpatsch> Yes, persistent defines the types from the schema I provide.
01:10:55 <Cale> If so, that's a little different from how groundhog does it -- which is just to require the stuff you give in the TH quasiquoter to refer to types you already defined elsewhere.
01:11:08 <Cale> Interesting
01:11:41 <Profpatsch> Hm, that sounds more sensible.
01:11:59 <Cale> It still really sucks, but yeah
01:13:31 <Cale> It would be a lot nicer if they'd worked hard at making it easy to give the inputs to the TH bit as Haskell datastructures, rather than using this yaml quasiquoter shenanigans that just silently ignores anything it doesn't understand.
01:13:59 <Profpatsch> Yeah, I think having a full-blown ORM is always a bad idea.
01:15:04 <Cale> Well, it makes a certain amount of sense in the abstract I think, it's just there are a bunch of problems with the way it's presently done.
01:15:16 <Profpatsch> It possibly does a lot of lookups for one datatype.
01:15:29 <Profpatsch> Or a lot of joins at least.
01:15:43 <Cale> Persistent and groundhog don't do joins
01:16:00 <Cale> That's actually one of the most annoying things about them.
01:16:31 <Cale> We use groundhog in our backends, but end up using postgresql-simple for a lot of queries, just because we need joins.
01:16:54 <Cale> It's nice to have the extra type safety of using groundhog where we can get it still though.
01:17:51 <Cale> (groundhog also has *some* facility for raw queries, but it's a good deal less nice to use than postgresql-simple's support for that)
01:18:03 <Profpatsch> “Some fields may require access to other tables, so we need a monad in the signature.”
01:18:34 <Cale> Oh, I suppose it's joining in the fields, that's true
01:18:56 <Cale> I just mean, if you want to write a query which would involve a join of multiple tables, you're stuck
01:19:37 <Profpatsch> Yeah. There’s esqueleto, which can do joins.
01:19:50 <Profpatsch> It uses persistent afaik.
01:21:29 <Cale> Then there's the issue that sum types are just not a concept in SQL generally, and so the databases don't really give you anything to express them properly.
01:22:09 <LordBrain> Anyone recall how to specify a sandbox to ghc without using cabal?
01:22:36 <LordBrain> there was a switch where you could give it the path to the compiled packages
01:22:56 <LordBrain> something like database = or something... 
01:23:34 <LordBrain> oh package-db
01:24:16 <Profpatsch> Cale: you have the sum-type problem with basically every serialization format.
01:24:33 <Cale> Well, many aren't so bad.
01:25:02 <Cale> Things that can store arbitrary tree structures don't have any trouble with sums
01:25:10 <Profpatsch> Yes, true.
01:25:31 <Profpatsch> You can give them a constructor tag and then use a map.
01:25:46 <Profpatsch> But SQL is has fixed fields.
01:26:31 <Cale> Yeah, it's just for some reason they overlooked the idea of having a column whose type is "this is a foreign key to table A, or a foreign key to table B, and we know which"
01:27:21 <Cale> (and not both, and not neither, importantly)
01:29:42 <Cale> I don't know what it is about programming languages and databases outside of the functional programming realm, but it seems like sum types generally get overlooked a lot.
01:30:14 <Profpatsch> Yes, they are pretty much a “new idea”.
01:30:28 <Cale> A "new idea" which predates electronic computing.
01:30:54 <Profpatsch> For most imperative languages switching on anything but an integer or maybe a string is unheard of.
01:31:34 <Profpatsch> And most languages don’t even have symbols, Lisp being a lone outlier.
01:32:01 <Cale> I don't know if it's quite as bad as Tony Hoare's billion dollar mistake, but I'm sure there have been cases where someone used two nullable columns in place of a sum, and paid horribly for it when their program had a bug which wrote data into both or neither.
01:32:38 <Cale> (and similar things go on outside databases all over the place really)
01:33:10 <Profpatsch> Multiple nullable columns are state of the art btw
01:33:21 <Cale> lol
01:33:30 <Profpatsch> I can remember those where examples on how to do it in our introductory courses.
01:33:40 <grantwu> I know protobufs have sum types, and those can be persisted to Bigtable...
01:33:54 <grantwu> Then again, proto3 is nullable-every-field by default...
01:34:02 <grantwu> er rather, mandatory nullable-every-field
01:34:03 <grantwu> aiui
01:35:40 <Cale> There's been a lot of push for databases with less precisely specified types with the whole "NoSQL" thing, and that's completely in the opposite direction of what people actually need -- we need more expressive types in our DB, and query languages to match.
01:36:18 <LordBrain> Now that we have stream fusion, is Control.Foldl still useful?
01:36:44 <grantwu> Schema flexibility is still somewhat problematic though
01:36:49 <LordBrain> https://hackage.haskell.org/package/foldl-1.1.5/docs/Control-Foldl.html
01:37:09 <Cale> LordBrain: If it was ever useful, then I expect it's still about as useful as ever.
01:37:25 <Cale> Stream fusion doesn't really help with the kind of problem which motivated the existence of Control.Foldl
01:37:48 <LordBrain> "This allows the Applicative instance to assemble derived folds that traverse the container only once "
01:38:04 <LordBrain> is it because applicative gets in the way of that usually?
01:38:10 <Cale> no
01:38:33 <LordBrain> i need a good motivating example
01:38:33 <Cale> The canonical example is computing the average of a list
01:38:50 <Cale> You want to compute its length as well as the sum of its elements, at the same time
01:39:42 <LordBrain> ok
01:39:49 <Cale> It would be nice if you could put together some sort of specification for computing the length and some sort of specification for computing the sum, and obtain both in one go through the list (making sure that the head of the list becomes garbage as soon as possible)
01:42:06 <Cale> i.e. normally you might write something like  foldl' (+) 0  for the sum, and  foldl' (\_ n -> n+1)) 0  for the length, but then the sum and length functions you define this way aren't efficiently composable
01:42:20 <Cale> If you write  sum xs / length xs
01:42:34 <LordBrain> yeah
01:42:41 <LordBrain> the point is to get nice combinators
01:42:49 <Cale> then xs will be retained in memory while the sum is computed (so if xs is being computed lazily and is very long, your program is dead)
01:43:23 <anohigisavay> hello!
01:43:35 <anohigisavay> i got this message with ghci
01:43:37 <anohigisavay> *** WARNING: /home/kj is writable by someone else, IGNORING!
01:43:49 <anohigisavay> how could i hide this message?
01:44:28 <tdammers> what's the mode on your ~?
01:44:29 <Cale> chmod go-w ~
01:44:48 <anohigisavay> and yea i set my home dir writable by others intentionally
01:44:54 <tdammers> don't do that
01:44:56 <tdammers> why would you
01:45:03 <anohigisavay> my home dir is acl controled
01:45:34 <grantwu> Why does ghci care about this?
01:45:58 <tdammers> grantwu: I did wonder myself
01:46:03 <Yuras> anohigisavay: you have .ghci in home?
01:46:33 <tdammers> grantwu: maybe to prevent others from injecting code into ~/.ghci, ~/.ghc, ~/.cabal, etc
01:46:52 <Cale> grantwu: Because someone can inject stuff into those files which will cause code to run with your permissions when you go to use GHC
01:48:05 <anohigisavay> Yuras: yes i have
01:48:08 <Cale> Apparently if you give -ghci-script explicitly it will ignore the permissions
01:48:28 <grantwu> Are you using an ACL system which doesn't ignore Unix permissions?
01:49:33 <anohigisavay> grantwu: it will not. i think it works by overlapping acl permissions with unix permissions
01:50:00 <anohigisavay> so i need to leave the write permission enabled
01:50:07 <grantwu> Out of curiosity... which acl system is this?
01:50:49 <Cale> Instead of giving people access to write to your home directory, would it suffice to just make a subdirectory of that writable?
01:52:22 <anohigisavay> Cale: well my case is i use two accounts for different desktop environments. for convenience i want their home dirs easily accessible to each other
01:53:34 <anohigisavay> (for some reason one account will cause problems, e.g. theming issue)
01:53:38 <Yuras> anohigisavay: here is the relevant ticket: https://ghc.haskell.org/trac/ghc/ticket/8248 You may try to convince ghc devs that your use case is important.
01:53:44 <Cale> What login manager are you using? All the login managers I've used in the last decade or so have supported switching desktop environments for a single user...
01:53:49 <Cale> hm, weird
01:56:47 <anohigisavay> Cale: i have no issue with login managers. but my kde will freeze for some reason and when i go back to gnome the themes of qt apps will have been overridden by kde themes. 
01:57:11 <anohigisavay> trivial issues like that
01:57:28 <anohigisavay> but damn it degrade my user experience 
01:58:41 <anohigisavay> Yuras: thanks man :)
01:59:44 <Unhammer> with Network.Wai.Middleware.RequestLogger, can I turn off logging for a certain endpoint but on for the rest? (or do I have to have it off by default and then turn it on for all except one?)
01:59:50 <sdx23> anohigisavay: alias ghci='ghci -ghci-script ~/.ghci' and its done? (Usually I'd think that a bad idea, but your setup is weird anyway...)
02:02:44 <anohigisavay> grantwu: not sure. i'm running gentoo. how could i find the acl system in control?
02:03:00 <grantwu> ...I don't know
02:04:35 <anohigisavay> sdx23: okay i tried that but nothing changed
02:09:40 <anohigisavay> sdx23: ghci: aliased to ghci -ghci-script ~/.ghci
02:12:04 <sdx23> anohigisavay: from "Cale> Apparently if you give -ghci-script explicitly it will ignore the permissions" I expect this to be sufficient
02:12:20 <grantwu> I think anohigisavay is saying that it didn't work
02:12:34 <grantwu> What happens if you just run it without the alias?
02:17:45 <grantwu> anohigisavay: With regards to asking what sort of acls you're talking about... I feel like what you mean is that your two accounts are under the same group?
02:18:05 <grantwu> I asked an acquaintance who's an experienced Gentoo user and he's not aware of anything special that Gentoo does with regards to ACLs
02:19:21 <anohigisavay> grantwu: yes i they are under the same group
02:19:56 <grantwu> Okay
02:20:11 <grantwu> So, yeah, I kind of agree that Haskell is being a little overzealous here by caring about the group bit
02:20:56 <EvanR> haskell overzealous?! NEVARRRR
02:21:08 <grantwu> s/Haskell/GHCi
02:31:10 <maerwald> how fast does hakyll generate stuff, e.g. if it involves a lot of translation pages
02:31:50 <Axman6> my experience has been it's basically instant, but my use is pretty small
02:32:40 <Unhammer> agh after upgrading  stack:amd64 (1.2.0-0~xenial, 1.3.0-0~xenial) it no longer finds my system ghc
02:33:07 <Unhammer> ghc --version says 7.8.4, but stack build says "No compiler found, expected minor version match with ghc-7.8.4 (x86_64)
02:33:11 <sras> Is there any way to get the line no and file that caused it from an exception?
02:33:59 <anohigisavay> grantwu: same result when run `ghci -ghci-alias ~/.ghci`.
02:34:11 <lyxia> sras: GHC 8 has a CallStack thing to help with that
02:35:06 <sras> lyxia: Is it meant to be enabled it in prodcution?
02:35:22 <grantwu> anohigisavay: Uh, that should be -ghci-script not -ghci-alias
02:36:21 <lyxia> sras: I think it is
02:36:25 <anohigisavay> grantwu: oops, yea i meant -ghci-script not sure what happened to me xD
02:37:22 <lyxia> sras: you can control how much code the stack trace cover.
02:41:21 <anohigisavay> thank you guys anyway :) grantwu, sdx23, Cale, Yuras, tdammers
03:02:24 <EvanR> emojihaskell tweet: ones = 1 : 1 : 1 : 1 : ...
03:02:40 <EvanR> (no actual emoji)
03:15:00 <hectorhon1> hi, newbie here, i posted a link of my blog post to reddit but it's not appearing, spam filter? or is it against community etiquette?
03:20:08 <tdammers> hectorhon1: why don't you ask on a channel that's about reddit, rather than this one, which is about Haskell?
03:21:21 <hectorhon1> tdammers: correction, to r/haskell
03:22:20 <tdammers> hectorhon1: still, most likely a reddit thing, not really related to haskell
03:22:38 <tdammers> hectorhon1: anyway, reddit has a bunch of tricks up its sleeve that can lead to posts not appearing
03:24:37 <tdammers> hectorhon1: self-promotion is somewhat frowned upon in the reddit community, especially when you do nothing else
03:27:51 <hectorhon1> tdammers: ok.. haha. it's just one of those "aha" moments that make you want to shout out
03:28:04 <lyxia> probably caught in the spam filter, waiting for mod approval
03:28:22 <hectorhon1> tdammers: peace (Y)
03:29:39 <tdammers> yeah
03:30:33 <tdammers> IIRC there's a rule something like "karma < 50 and all posts so far in the same domain -> mod approval requires"
03:30:44 <hectorhon1> lyxia: ooh
03:30:46 <kuribas> Is announcing your own package self-promotion?
03:31:01 <tdammers> edge case
03:31:12 <tdammers> also seems to depend on the subreddit - some hate it more than others
03:31:32 <kuribas> well r/haskell
03:31:41 <tdammers> oh, and it seems that announcing your own package is more likely to be considered acceptable if it's free, open source, and non-commercial
03:32:16 <tdammers> in the end, the most important factor is still "is this something people would find interesting / helpful"
03:33:26 <kuribas> I wanted to post my package when it's useable, and somewhat bug free.
03:35:16 <kuribas> Don't think it will be a problem, though...
03:35:50 <EvanR> im still waiting for a decent left-pad package
03:36:05 <kuribas> EvanR: what does that do?
03:36:14 <EvanR> pads strings on the left
03:36:55 <kuribas> like printf?
03:37:38 <EvanR> this one doesnt have enough dependers https://hackage.haskell.org/package/acme-left-pad
03:39:26 <Xnuk> http://left-pad.io/
03:40:51 <kuribas> EvanR: what about left?  https://hackage.haskell.org/package/formatting-6.2.4/docs/Formatting-Formatters.html
03:42:40 <kuribas> :t left
03:42:42 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
03:42:59 <grantwu> I think EvanR is making a joke
03:43:49 <kuribas> oh
03:43:55 <lyxia> kuribas: https://www.reddit.com/r/programming/comments/4bjss2/an_11_line_npm_package_called_leftpad_with_only
03:44:51 <kuribas> lyxia: thanks
04:17:22 <matheus23> Hi, i have a question about where include directories are specified for ghc when using cabal-install. Cabal prints to me "include-dir: ... is a relative path which makes no sense ...", but i dont know where i have ever specified that path
04:18:39 <matheus23> Its not in my .cabal of my project, It's not in my stack.yaml (neither in the local nor the global), and i can't find it anywhere
04:19:09 <matheus23> its also not in the global cabal or stack config
04:19:36 <matheus23> ah and I've also looked at my INCLUDE and PATH environment variables and its nowwhere there too
05:03:55 <nut`> how to run hasktags on library source code?
05:04:02 <nut`> i'm using stack
05:33:43 <lunaris> Anyone here played around with running two `conduit` `Sink`s in parallel?
05:34:32 <lunaris> Or perhaps I should say concurrently. I've used the Applicative ZipSink newtype, but it's (understandably) not actually spawning threads and pulling from upstream in paralle.
05:34:35 <lunaris> parallel*
05:34:47 <lunaris> There's Data.Conduit.Async but I don't think that's quite what I need.
05:35:11 <lunaris> Use case: single source, multiple sinks which write to e.g. different PostgreSQL tables.
05:55:18 <spdionis_> Hello
05:55:43 <spdionis_> given a type like `data List a = Cons1 [a] | Cons2 [a]  `
05:57:02 <spdionis_> nevermind...
06:02:34 <spdionis_> for the above data type, how can I implement a (a -> List b) function (for the `>>=` operator) if a and b should actually be lists!
06:02:45 <spdionis_> is it possible somehow?
06:03:08 <spdionis_> :t >>=
06:03:10 <lambdabot> error: parse error on input ‘>>=’
06:03:15 <spdionis_> :t (>>=)
06:03:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:04:36 <spdionis_> swap :: a -> List a
06:04:36 <spdionis_> swap [] = []
06:04:36 <spdionis_> swap [x] = [x]
06:04:36 <spdionis_> swap (x:y:xs)
06:04:36 <spdionis_>     | x > y = SwappedList y:x:xs
06:04:37 <spdionis_>     | otherwise = NotSwappedList x:y:xs
06:04:45 <spdionis_> is it possible to make the above legal?
06:05:14 <shiona> spdionis_: say you are doing "Cons1 [1,2,3] >>= (\x -> Cons2 [x])". What do you want the result to be?
06:07:10 <shiona> and assuming SwappedList and NotSwappedList are the Cons1 and Cons2, then that should work if you put the x:y:xs and y:x:xs in parentheses
06:08:08 <shiona> I think it's parsed as (SwappedList y):x:xs currently
06:08:55 <spdionis_> shiona: no, parentheses don't help
06:09:05 <spdionis_> ` Couldn't match expected type `List a' with actual type `[t0]'`
06:09:20 <spdionis_> still trying to figure out your other question :D
06:09:49 <shiona> Oh of course. There's "swap [x] = [x]". That's a plain list, not your List you're returning
06:10:05 <shiona> same for empty list
06:12:14 <spdionis_> still doesn't work: `Couldn't match expected type `a' with actual type `[a]'`
06:12:42 <spdionis_> sounds logical that if I declare a type `a` but match on a list it shouldn't work
06:12:53 <spdionis_> sounds logical that if I declare type `a` in the signature but match on a list it shouldn't work
06:14:52 <spdionis_> for your first question, I want the result to be either Cons1 or Cons2 [x] depending on a rule I'd like to define in `>>=`
06:15:23 <spdionis_> I'm trying to implement bubble sort
06:15:28 <spdionis_> basically I'm trying to implement bubble sort
06:15:56 <marchelzo_> What is the difference between Cons1 and Cons2?
06:16:02 <spdionis_> no difference
06:16:03 <spdionis_> just a tag
06:18:28 <marchelzo_> why do you need two different tags?
06:21:20 <marchelzo_> your swap implementation will have to double in size because it needs to handle both Cons1 and Cons2 everywhere
06:22:50 <superlinux> hello.. I am in stack  upgrade hell
06:23:04 <superlinux> I am stuck on a package
06:26:04 <superlinux> please help
06:29:44 <mirpa> superlinux: you must first describe your problem or give a link to lpaste.net with error message
06:32:17 <Profpatsch> What’s with the “no explicit implementation for xy” warnings?
06:32:35 <Profpatsch> I think those should be done by generic default implementations, so why the warnings
06:35:17 <Cale> Profpatsch: That's the warning you get when there's a MINIMAL pragma and its conditions aren't met
06:35:23 <spdionis_> marchelzo_: the point was that swap should take a simple list and return one of the cases
06:35:39 <Profpatsch> Cale: For the minimal implementations?
06:35:40 <Cale> So perhaps there's a MINIMAL pragma which is incorrect, if you're getting that and the whole instance is actually filled out.
06:35:44 <Cale> yeah
06:36:12 <Profpatsch> GHC doesn’t check if MINIMALs make sense I guess?
06:36:50 <spdionis_> marchelzo_: remember, I have
06:36:50 <spdionis_> data List a = SwappedList [a] | NotSwappedList [a]  deriving(Show)
06:36:50 <spdionis_> and I have to implement
06:36:50 <spdionis_> a -> List a
06:36:52 <Profpatsch> Will an incomplete instance crash at runtime?
06:37:49 <Profpatsch> Heck yeah, GHC panic.
06:37:53 <yushyin> Profpatsch: 'If an instance does not satisfy the minimal complete definition, then a warning is generated.'
06:38:01 <Profpatsch> I love persistent.
06:38:02 <yushyin> that’s all.
06:45:58 <Gilgames1> I have some syntax problems, if anyone could give me a hand I'd appreciate it a lot: http://pastebin.com/UEKnepDH
06:46:11 <Gilgames1> I'm implementing Lisp in Haskell and want to apply a function
06:46:20 <Gilgames1> But I'm not sure how to construct the where clause at line
06:46:24 <Gilgames1> 16
06:46:53 <srhb> Gilgames1: You have to have some definition after the equals sign of apply
06:47:04 <Gilgames1> That's fine
06:47:09 <Gilgames1> But my main issue is with the where
06:47:20 <Gilgames1> I'm not sure how to construct it such that it returns a function
06:47:37 <Gilgames1> I want it to return each type of the function
06:48:26 <Gilgames1> I e I want it to return an Expr(parameters) Expr(function body) Env(closure)
06:49:17 <srhb> Gilgames1: So LFunction params body closure ?
06:49:35 <srhb> Gilgames1: You just deconstructed it on the lhs though.
06:49:48 <Gilgames1> lhs?
06:49:52 <srhb> left hand side
06:50:04 <Gilgames1> So is the way I've done it in the where correct?
06:50:09 <srhb> Well, no, actually you defined LFunction which is probably not what you wanted.
06:50:14 <srhb> (It won't work anyway)
06:50:16 <Gilgames1> Ahh
06:50:28 <Gilgames1> Then how can I make it work? By removing the constructor?
06:50:58 <srhb> Gilgames1: I'm not sure what you want it to do really. I can tell you how to return an Expr that is an LFunction (see above) but you need to get those params, body, closure from somewhere.
06:52:13 <Gilgames1> Yeah ok so I should probably try to clarify :p
06:52:21 <srhb> Gilgames1: Please. :-)
06:52:27 <Gilgames1> So I have an environment e that takes a string -> Expr
06:52:31 <srhb> Where?
06:52:37 <Gilgames1> think of it as a hash map, though I've implemented it as list
06:52:41 <srhb> the argument of apply?
06:52:50 <Gilgames1> on apply
06:52:52 <srhb> OK, got that one. params and body?
06:52:55 <Gilgames1> apply takes an e
06:53:00 <Gilgames1> that's the environment
06:53:10 <Gilgames1> an LFunction is an expression
06:53:33 <Gilgames1> so Env (function name) -> LFunction Params Body closure
06:53:42 <Gilgames1> or so I hope
06:54:00 <Gilgames1> I'm just not sure how to extract the function information from the environment
06:54:35 <Gilgames1> So basically
06:55:06 <srhb> Gilgames1: where yourfunc = LFunction f p e ?
06:55:09 <Gilgames1> I want e to return a function in the where clause using (getVar) function
06:55:44 <Gilgames1> More like where myFun = getVar e funName
06:55:55 <srhb> Aah
06:56:05 <Gilgames1> getVar extracts the function from the global environment
06:56:18 <Gilgames1> I get that I'm saying "environment" and have made this way more complicated than need be :p
06:56:31 <srhb> Gilgames1: I think it would be helpful to have the type of getVar
06:56:54 <Gilgames1> getVar :: String -> Env -> Expr
06:57:14 <Gilgames1> btw thanks a lot for taking the time :)
06:57:31 <srhb> And that Expr at the end is a function.
06:57:36 <Gilgames1> YEs
06:57:59 <srhb> Well, then you're doing it right, really. Only you've pattern matched out params, body and env
06:58:03 <Gilgames1> Though it could be a variable as well
06:58:04 <srhb> if you just want the full LFunction you do
06:58:11 <srhb> where myFun = getvar f
06:58:21 <Gilgames1> I see
06:58:32 <Gilgames1> Then I can have a function that extracts the information I need from a function!
06:58:44 <srhb> what's in the where clause is not a function
06:58:51 <srhb> (in Haskell terms)
06:59:05 <srhb> You're just pattern matching on the result of getVar f and binding names to Expr, Expr and Env
06:59:32 <Gilgames1> I was thinking more like  (funEnv :: Expr -> Env) or (funBody :: Expr -> Expr)
06:59:44 <Gilgames1> But thanks a lot man
06:59:46 <Gilgames1> Much appreciated
07:08:18 <Profpatsch> The almighty Gilgamesh in #haskell. Hide your horses.
07:44:00 <david__> anyone her familiar with idris?
07:45:29 <ski> david__ : you could perhaps try #idris ?
07:46:06 <ski> EvanR : btw, i apologize if i came off as a bit snarky(?) yesteryesterday. i was attempting to express that i was leaving the conversation, in a jesting way. naturally, i didn't meant to imply that you and yhhko shouldn't continue the conversation at that time, if you wished to
07:47:17 <kqr> quick sanity check: if I want to implement some sort of i18n, should I have a simple data type for language (data Lang = EN | FR | DE) and then a typeclass Messages with instances for each language, or should I embed the messages in the data type?
07:47:23 <kqr> imma check what yesod does
07:48:45 <kqr> hm, yesod does something weird
07:49:29 <ski> one alternative might be to have `Lang' not have an alternative for each language, but instead a record of the basic custom language-specific functions (what you would have put in your type-class, basically) that you need to be able to use for i18n
07:50:01 <ski> then particular language alternatives wouldn't be constuctors `EN',`FR',&c. but simply predefined function records
07:50:11 <alehander42> are there any haskell extensions / haskell forks for lower level programming? like, safer pointer types etc 
07:51:19 <grantwu> alehander42: Have you looked into Rust?
07:51:25 <kqr> ski, oh so "data Lang = Lang { login :: Text, welcome :: User -> Text }" etc?
07:51:40 <kqr> alehander42, have you looked into Ada? (I always have to give love to ada when someone mentions rust...)
07:51:54 <geekosaur> alehander42, more commonly you find EDSLs for programming at a lower level (e.g. atom for embedded systems programming)
07:52:06 <kqr> ski, is there a benefit to that over typeclasses? I guess that it's more easily extensible?
07:52:20 <ski> (an advantage of this would be that when one wants to add a language, one doesn't have to modify existing code (pattern-matching on `Lang'), but instead you just construct a new record value. this is basically the OO (record/struct) approach to structuring "operations"/"alternatives", which is the dual to the algebraic data type (/ sum/variant type) approach, which is more common in FPLs)
07:52:20 <grantwu> It's not a Haskell extension nor a Haskell fork, but it contains elements of functional principles, attempts to achieve zero overhead, memory safety through something something linear types, and is pretty popular these days
07:53:31 <ski> kqr : with type classes, you associate a single unique bundle of methods to a type. with the record approach, you can have as many as you want. this can both be good and bad (good for expressivity, bad for "reasonability")
07:53:32 <kqr> ski, and then if I want to dynamically get a language, I guess I just bunch them up in a map, rather than a case…of, for the same reason?
07:53:58 <ski> kqr : i'm not saying you should do this approach in this case, just pointing it out as a potential alternative to the sum type version
07:54:04 <kqr> yeah but I really like that idea
07:54:14 <kqr> rings much closer to my intuition of the problem than whatever I had in mind
07:54:21 <johnw> kqr: if you really want to dig into the distinction between typeclasses and the record approach, I have a paper for you
07:54:33 <ski> (Ada isn't that bad, *nod*)
07:54:35 <johnw> http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
07:55:07 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at ^
07:55:49 <kqr> johnw, oh boy how I want to, but I'm really pressed for time :(
07:56:02 <johnw> queue it for another day; it's a good read
07:56:05 <ski> kqr : if you want to dynamically get a language, you'd typically pass the record as an argument (or part of one)
07:56:56 <ski> kqr : of course, you could map the string `"EN"' to a specific record, &c. at some point in the code, but that code then won't handle languages provided by third parties, ..
07:57:06 <ski> johnw, indeed
07:57:28 <kqr> ski, when I said "dynamically get" I was thinking about do { putStrLn "Which language do you want?"; choice <- getLine; let language = lookup choice langmap }
07:57:52 <kqr> ski, the benefit of putting the "EN" string with the "en" dict in a map is that then client code may extend that map, I guess
07:57:59 <ski> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> might be interesting to check out around the same time, as the paper above is more or less a response to (part of) this one
07:57:59 <kqr> ski, as opposed to if I put them together in a simple case…of
07:58:08 <kqr> johnw, will try to remember!
07:58:16 <ski> kqr : *nod*
07:58:23 * ski must leave atm
07:58:28 <kqr> thanks for your help ski !
08:14:40 <srk> is there a console drawing framework? like when you're building a rougelike but without game related stuff, just drawing
08:14:57 <Phillemann> I'm using servant for the first time and I'd like to return a text/calendar document via a HTTP GET. What's a good entry point for adding this type to servant? I'm a bit lost.
08:14:58 <ertes> helo
08:15:16 <ertes> srk: vty, if you're happy with no windows support
08:15:30 <srk> ertes: ah, forgot about that
08:16:23 <srk> thanks!
08:16:54 <ertes> if you need windows support you can either try to use ansi-terminal, which is rather limited, or you can take on your very own adventure game and try to get ncurses to work
08:17:59 <srk> windows got linux subsystem so there's no need to .. :D
08:18:27 <alehander42> @grantwu thanks, I know of rust, I just wondered if there is anything closer to haskell / ocaml
08:18:28 <lambdabot> Unknown command, try @list
08:18:30 <z64> tfw stuck on win7 at work ;(
08:19:00 <grantwu> Hrm... I'm not sure how much closer you can get to be honest...
08:19:08 <grantwu> Rust could get HKT
08:19:17 <srk> actually you can get closer
08:19:20 <srk> with ivory/tower
08:19:24 <srk> alehander42: ^^
08:19:26 <hodapp> srk: you use Ivory?
08:19:45 <srk> kind of, just experimenting 
08:19:57 <hodapp> alehander42: check out #haskell-embedded
08:19:57 <srk> learning, but want to use it for motor controller on stm32
08:20:08 <pavonia> In "Version 0.5.0 breaks compatibility with prior versions, the AST has been reworked to allow round trip processing of JavaScript", any idea what could be meant by round trip processing?
08:20:13 <hodapp> not a big channel, but I'm there and have used Haskell for some embedded stuff
08:20:17 <hodapp> particularly via Ivory
08:20:36 <srk> cool, will ask you about some stuff soon :D
08:21:21 <srk> I was blown away when I've 'stack built' elf binaries for stm32f4 (smaccmpilot)
08:21:25 <grantwu> pavonia: Being able to round trip, aiui, mainly means that there's an isomorphism
08:21:31 <hodapp> srk: how'd you use stack to do that?
08:21:41 <hodapp> I ended up doing it mostly in Shake (for actual firmware)
08:21:59 <srk> hodapp: this repo https://github.com/GaloisInc/smaccmpilot-build
08:22:06 <pavonia> grantwu: Like show <-> read?
08:22:08 <ertes> alehander42: what's the question?  a haskell-line language for embedded stuff?
08:22:28 <grantwu> pavonia: Hrm... yeah
08:22:35 <grantwu> But that's not an isomorphism, I think
08:22:51 <grantwu> Read is not total
08:23:01 <grantwu> But it is what you actually want
08:23:57 <pavonia> The two ASTs are http://hackage.haskell.org/package/language-javascript-0.4.10/docs/Language-JavaScript-Parser-AST.html vs. http://hackage.haskell.org/package/language-javascript-0.6.0.9/docs/Language-JavaScript-Parser-AST.html
08:24:26 <pavonia> They don't look too diferent too me, jst merged actual data with whitespace information
08:28:59 <tippenei1> trying to achieve speed similar to python's Counter with a multiset - http://lpaste.net/349867
08:29:21 <tippenein> not having much luck
08:30:57 <ertes> tippenein: what does Counter do?
08:31:13 <tippenein> creates a multiset afaik
08:31:28 <tippenein> just counts of the occurences of items in a list
08:31:47 <tippenein> https://docs.python.org/2/library/collections.html#collections.Counter
08:32:31 <byorgey> tippenein: looks like MultiSet is implemented as just a Map to Int.  If you're using Text as keys I wonder if it would be faster to use a strict HashMap: http://hackage.haskell.org/package/unordered-containers-0.2.7.1/docs/Data-HashMap-Strict.html
08:32:49 <byorgey> IIUC the unordered-containers package is heavily optimized
08:33:55 <ertes> python probably uses hash tables under the hood, so you may still be at a slight disadvantage
08:34:04 <ertes> but it's very fast regardless
08:34:21 <byorgey> "A Counter is a dict subclass for counting hashable objects" -- so yes.
08:34:44 <tippenein> byorgey: ok. what disadvantage would unordered-containers have so that the author didn't use it?
08:34:47 <ertes> i'd actually like to have a fast hash table implementation in haskell…  sometimes it's useful
08:35:02 <tippenein> ertes: seems like it ;)
08:35:33 <byorgey> tippenein: well, it's unordered.  Sometimes you want to be able to quickly get the keys of your multiset in order, in which case a HashMap is inappropriate
08:35:44 <ertes> tippenein: the author of multiset probably tried to use the least common denominator and went with Map
08:35:52 <ertes> but for Text keys HashMap is generally far better
08:36:05 <byorgey> tippenein: it also requires a Hashable constraint instead of an Ord constraint.  It's just different.
08:36:38 <byorgey> Also, the first version of multiset was written 2 years before the first release of unordered-containers.
08:36:59 <ertes> that might explain it even better =)
08:38:03 <tippenein> maybe a Pull Request is in order
08:38:19 <ertes> very often HashMap is even better for basic types like Int and Double, because under the hood it uses an IntMap-like structure (a radix tree) instead of a binary tree
08:39:00 <tippenein> I was testing how well haskell could represent the spell-checker Norvig wrote about long ago with python - http://norvig.com/spell-correct.html
08:39:12 <byorgey> ertes: http://hackage.haskell.org/package/hashtables
08:42:13 <ertes> byorgey: that one performed considerably worse for me than HashMap
08:42:25 <byorgey> interesting
08:42:51 <byorgey> maybe it depends on the type of the keys and the size of the table
08:43:22 <byorgey> anyway, I haven't actually used either one, so I make no particular claims about anything =)
08:45:30 <ertes> byorgey: you haven't used HashMap?
08:46:11 <c_wraith> it doesn't seem like a common thing to want. 
08:46:25 <byorgey> ertes: I confess I haven't.  I always reach for Data.Map just because of intertia/familiarity, and in my use cases it's never a bottleneck.
08:46:45 <byorgey> *inertia
08:47:53 <fryguybob> Depending on the strings (and the hashing), a non-hashed Trie might be better.
08:49:07 <ertes> it's usually the one i reach for before Map, unless i actually need (predictable) ordering…  the API is almost the same, except that the Ord-related parts are missing
08:50:01 <fryguybob> ertes: A Trie would retain ordering.
08:51:13 <fryguybob> (I think Data.Map might be implemented with a Trie, so I'm probabliy not really adding anything to the conversation :D)
08:51:46 <c_wraith> nah, it's a binary tree. 
08:52:09 <c_wraith> because the only constraint on the keys is Ord
08:52:12 <ertes> fryguybob: a raw trie is not necessarily more efficient than HashMap, because the hashing saves you from having to do string comparisons
08:53:02 <c_wraith> well, the point of a trie is that you only have to traverse the string once while going from root to leaf. 
08:53:05 <fryguybob> ertes: Right, when the strings have the right distribution of prefixes the Trie can save significantly
08:54:24 <fryguybob> ertes: Hashing just ensures a good distribution, but at the cost of visiting the whole string, or allowing for bad corner-cases.
08:58:01 <ertes> fryguybob: it also makes the string sizes constant, which is often an important benefit
09:01:35 <michbad> What's the current recommended library for ASCII terminal applications? (I want to write a roguelike, I know, very original.)
09:02:02 <nitrix> michbad: vty / brick
09:02:51 <michbad> i'll check it out, thanks
09:05:11 <nitrix> michbad: vty is the terminfo stuff, and brick is for GUIs built on top of that (textareas, forms, layout, etc).
09:05:16 <nitrix> vty-ui got deprecated.
09:07:18 <michbad> nitrix: so vty is probably easier to start with, right?
09:08:38 <ertes> michbad: vty gives you a console canvas that you can draw into
09:08:46 <ertes> brick builds a UI library on top of it
09:15:52 <kqr> can I have (and build) several executables in one package with stack?
09:17:32 <blackdog> kqr: yeah. just have multiple executable stanzas in your caaaabal file
09:18:24 <ertes> edwardk: i have implemented a very simple parser in church encoding, but i'm running into a problem:  in order to implement 'try' i would have to break church and parameterise over the underlying StateT that the actual parse function uses for incremental feeding…  how would you go about solving that?
09:18:28 <kqr> blackdog, I tried that, but GHC (?) complains that none of them are called Main
09:19:09 <ertes> edwardk: this is my parser type: newtype Parser c m a = Parser { runParser :: forall x. m x -> ((Maybe c -> m x) -> m x) -> (a -> m x) -> m x }
09:19:23 <kqr> blackdog, ah I guess maybe I have two different source files but both define a module Main
09:19:28 <blackdog> do you have a "main-is" line in your cabal file?
09:19:31 <ertes> edwardk: in order: "failure", "need more" and "success"
09:19:32 <blackdog> yes. don't do that :)
09:19:51 <blackdog> kqr: or have hs-source-dirs be different for each
09:20:38 <kqr> blackdog, I do have a main-is file, which points to each source file. but you're saying don't let both files define a Main module?
09:22:13 <ertes> edwardk: this is the experimental non-incremental parse function: parse :: (Monad m) => Parser c (StateT [c] m) a -> [c] -> m (Maybe a)
09:23:14 <nitrix> michbad: They're both reasonably simple; but yeah, vty is going to have your building blocks to manipulate the terminal, while brick will provide the fancy abstractions on top of it that you'd probably end up writing anyway for convenience.
09:23:20 <blackdog> kqr: no, they should both define a Main module, but it doesn't have to be Main.hs
09:23:38 <blackdog> main modules can be called anything you like, they're not bound to the filename the way actual modules are
09:24:06 <blackdog> kqr: probably easiest if you post your cabal file in a gist or something
09:24:32 <michbad> nitrix: thanks, i'll try brick. i'm still figuring out how to install libraries with stack
09:26:52 <sm> stack install brick
09:28:27 <sm> brick is great. Maybe compare it with plain vty at some point just to see if there's any performance cost
09:28:49 <sm> be aware neither of them works on windows yet
09:28:59 <nitrix> michbad: https://www.stackage.org/package/brick
09:29:21 <nitrix> michbad: It seems like brick made it to stackage, so it should just magically work if it's listed in your .cabal file.
09:29:35 <michbad> sm: is it normal that I had to insert text-zipper-0.9 and vty-5.14 intro extra deps in my yaml file?
09:29:49 <sm> nitrix: oh yay! for a while it was (intentionally) kept out
09:29:53 <nitrix> michbad: (Unless you require a specific version that's not in the snapshot you're using)
09:30:15 <sm> michbad: yes, I have to do the same. Someone should get those added to stackage
09:31:10 <nitrix> michbad: From stack's perspective, packages are supposed to be on stackage, and hackage packages are "external dependencies".
09:31:11 <michbad> sm: and then I add brick to my .cabal file?
09:31:51 <sm> well, I guess someone did. So if you use the current nightly resolver, you won't have to add those things
09:32:05 <sm> yes, in all cases you add the deps to your cabal file
09:32:07 <nitrix> michbad: Both the cabal-install tool and the stack tool uses the unified Cabal build system underneath, which is that .cabal file.
09:33:04 <michbad> hmm, I got "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))" when trying to exec (it built fine)
09:33:43 * ertes . o (once you get used to church encoding it actually turns out to be not only more efficient, but actually even more convenient)
09:33:58 <nitrix> michbad:  ghc-options:         -Wall -threaded -with-rtsopts=-T -O1
09:35:09 <sm> in the cabal file. (Why -O1, and what's -T  ?)
09:35:42 <fosskers> nice, I didn't know brick existed
09:36:31 <michbad> nitrix: thanks, it worked! it's all pretty mysterious to me, since I don't much about haskell building/modules/cabal etc
09:36:49 <fosskers> I wish brick's guide had some pictures
09:37:29 <fosskers> is it ncurses, pretty much?
09:37:59 <buglebudabey> can i have a diagonal matrix of functions :: (Int -> a) and use that as a transformation matrix to convert an nx1 matrix from Matrix Int -> Matrix a?
09:38:40 <buglebudabey> or is there a better way to map a function over a vector/matrix
09:38:50 <mmaruseacph2> why not have just a single function?
09:39:00 <mmaruseacph2> and do a map (map f)
09:39:32 <buglebudabey> or should i make the matrix an instance of Functor implement it myself
09:43:28 <nitrix> michbad: -threaded is the only one needed. It's documented somewhere in their examples. Some of the lower level libraries (like graphical or networking) are going to have greedy requirements like that from the compiler.
09:45:13 <sm> fosskers: there's one at http://hledger.org . And a bunch of great example executables in the package. It's higher level than curses
09:46:08 <sm> animation at https://asciinema.org/a/29665
09:57:56 <meditans> kosmikus: I'd like to ask a question on generic-sop
09:58:30 <meditans> let's say I have a datatype User f = User (f Text), (f will be a functor)
09:58:41 <meditans> the code for a datatype of this kind would be something like
09:59:22 <meditans> SOP (Z (I (Just "a") :* Nil))
09:59:22 <meditans>  
09:59:34 <meditans> for example if the functor is Maybe
09:59:54 <meditans> with type SOP I '['[Maybe Text]]
10:00:12 <meditans> is there a way to obtain directly a value of type
10:00:32 <meditans> SOP f '['[Text]] from a value of type User f?
10:02:06 <hackrilege> Hi, I'm revisiting the concept of Stack as a way to capture the nature of foldable containers to generalise List, could anyone discuss with me the design of the class I'm writing here? http://lpaste.net/349875
10:10:42 <hackrilege> It's missing the base case because the Maybe calls complicate things a lot for legibility. I'll put them in shortly, but I wanted to discuss the overall idea which I think is more clearly communicate without the additional clutter...
10:12:47 <quchen> I don’t understand that code. It’s way too dense, and the core of the class is left open.
10:13:07 <quchen> And I don’t know what it is supposed to represent.
10:21:39 <hackrilege> Sorry my client crashed just after my last message...
10:22:14 <hackrilege> I wanted to talk about http://lpaste.net/349875
10:32:46 <hackrilege> I can't supply 'a function which uses the result of another function' to that function
10:35:42 <glguy> hackrilege: Are you sharing code without a compiler to check it locally again?
10:36:37 <hackrilege> I can see the errors, just trying to figure out how to work around them, but yes, I'm sans compiler
10:37:38 <hackrilege> I'm also not handling the passing of the list properly, an [] appears, I should fix that first really, I apologise
10:54:38 <hackrilege> :t id
10:54:40 <lambdabot> a -> a
10:56:01 <hackrilege> I think it's better now
10:56:04 <hackrilege> http://lpaste.net/349875
10:57:45 <nitrix> We can assume a lot of things without a compiler :)
11:01:39 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard! Key in /topic (We're up to 19!)
11:04:59 <nitrix> I was going to give it a look tonight. I hope I'm not too far behind.
11:05:15 <kadoban> Hmm, if we're plugging random coding this, be cool if more haskell people did: https://www.hackerrank.com/world-codesprint-8 , it's this weekend
11:05:17 <glguy> There are people on the list with 0 stars, so you're not too late
11:05:30 <kadoban> coding things*
11:05:34 <yulax> *
11:06:47 <nitrix> First hundred users to get the first star on Day 13:
11:06:49 <nitrix>   1) Dec 13  00:04:24  glguy (AoC++)
11:06:55 <nitrix> glguy: Nice nice :)
11:07:08 <Gurkenglas> Is there a data structure that provides iterate, and checking whether something's one of the first n elements in O(log(n))?
11:07:08 <glguy> Thanks ^_^
11:08:09 <kadoban> Gurkenglas: What's iterate? Getting the next element after one?
11:08:22 <Gurkenglas> :t iterate -- replace [] with the object of my request
11:08:24 <lambdabot> (a -> a) -> a -> [a]
11:08:37 <glguy> Gurkenglas: Data.Set supports "splitAt" so you could take a prefix of the set
11:08:45 <glguy> and then efficient membership
11:08:50 <Gurkenglas> Are sets generated lazily? :D
11:09:01 <glguy> No
11:09:26 <kadoban> Gurkenglas: I don't really follow the iterate part honestly. Maybe I'm being slow.
11:10:48 <Gurkenglas> I want an f and an iterate' and an elem' with elem y (take n $ iterate f x) == elem' n y (iterate' f x) for all f and x (with Eq on x's type), but elem' n y is supposed to run in O(log(n))
11:10:57 <Gurkenglas> Um, Ord not Eq
11:11:50 <Gurkenglas> "I want an f" <- Um, that's supposed to be on the type level, but I just noticed I never used that again, so take out the part
11:12:10 <orion> To build GHC, do I *only* need a C compiler?
11:12:18 <orion> Or is a C++ compiler required as well?
11:12:26 <mmaruseacph2> no, you also need a ghc compiler to bootstrap the process
11:12:34 <orion> Ok, well yeah that too.
11:12:43 <quchen> No C++ required, I think.
11:12:52 <mmaruseacph2> yep, n C++required
11:12:54 <geekosaur> no C++ needed
11:12:56 <orion> Great.
11:13:02 <mmaruseacph2> or it wasn't required last time I tried compiling ghc
11:13:31 <quchen> The RTS is written in C, there used to be some Perl and Python for working with GHC
11:13:45 <quchen> The testsuite is in Python at least, and boot is (still?) a Perl script
11:13:53 <quchen> But no C++ ;-)
11:16:34 <kadoban> Gurkenglas: Do you care if it uses a ton of memory?
11:17:22 <Gurkenglas> I'd think it possible in O(n) space, but what's your idea?
11:18:11 <kadoban> IIUC you could do that with a ... memoized Data.Set, you keep track of every version of it, with one item in it, with two items in it, etc. And then treat it as an order-statistics-tree. Uhm, sec let me make sure Data.Set allows the thing I think it does.
11:19:24 <kadoban> Gurkenglas: Ya, it has splitRoot, which doesn't have guaranteed behavior, but in practice allows you to find the "rank" of any element in O(lg n) time
11:19:44 <kadoban> So ... a couple of not great things about this solution really, there's probably a better idea.
11:19:50 <hackrilege> Ok, I added the basecase, I think it's ready for reference in a discussion about what it's doing. http://lpaste.net/349875
11:19:54 <Gurkenglas> hmm that should take only O(n * log n) space
11:20:10 <kadoban> Gurkenglas: Yeah. Which isn't amazingly bad? It's probably not necessary though.
11:21:13 <kadoban> Or actually I bet you can use something less fugly than splitRoot too.
11:21:33 <Cookies34> http://ilredentore.dynv6.net regards...
11:21:37 <kadoban> 'split' should be better, in that it at least has guaranteed performance behavior.
11:22:58 <kadoban> Oh hhm, one problem with this is that this is going to give different answers a bit in cases of duplicated values.
11:24:10 <Gurkenglas> Why's there a need for split? Just do scanl (flip insert) $ iterate f x, which will only take O(n * log n) time and thus cannot possibly consume more than O(n * log n) space
11:25:12 <kadoban> Oh ... ya you're right, there's no reason for split or friends, you just check the correct Set.
11:25:24 <Gurkenglas> (Except that !! on that would be O(n))
11:26:47 <Gurkenglas> But still, a manual infinite tree can obviously do all this in optimal time, so surely someone's already done this or it falls out of FreeT or something
11:27:20 <Gurkenglas> *in optimal space, optimal time is already achieved
11:31:43 <meditans> I'd appreciate some help in investigating why I can't do a thing which seems obvious with injective type families:
11:32:04 <meditans> let's say I have this injective type family:
11:32:14 <meditans> type family AllMap (f :: * -> *) (xs :: [*]) = (result :: [*]) | result -> xs where
11:32:14 <meditans>   AllMap (f :: * -> *) '[] = '[]
11:32:14 <meditans>   AllMap (f :: * -> *) (x ': xs) = f x ': AllMap f xs
11:32:14 <meditans>  
11:32:30 <meditans> and this simple function:
11:32:51 <meditans> uNP :: (ys ~ AllMap f xs) => NP I ys -> NP f xs
11:32:51 <meditans> uNP Nil = Nil
11:32:51 <meditans>  
11:33:55 <meditans> (NP is a simple data type defined at https://hackage.haskell.org/package/generics-sop-0.2.3.0/docs/Generics-SOP-NP.html#t:NP )
11:34:57 <meditans> the question: the typechecker complains that it cannot deduce that xs ~ '[] from the fact that ys ~ '[]
11:36:09 <meditans> but I don't understand where it gets stuck: if I know that ys ~ '[], I can deduce that AllMap f xs ~ '[], then for injectivity xs ~ '[]
11:36:12 <meditans> what am I missing?
11:36:30 <Gurkenglas> Actually that !! part sounds like a real problem, we've only reduced the problem to finding an infinite data structure that can do !!, rather than elem, in O(log n)
11:40:44 <kosmikus> meditans: your last step makes use of more than just injectivity
11:43:04 <meditans> kosmikus: ok, so doesn't the `result -> xs` part mean that if I know that result is '[], it has been generated with xs ~ '[]?
11:43:58 <kosmikus> meditans: no, I don't think it looks inside the definition in order to derive partial inverse functions
11:44:24 <kosmikus> meditans: it only allows it to deduce that 'xs' is actually uniquely determined once you know 'AllMap f xs', but not what 'xs' is
11:45:19 <kadoban> Gurkenglas: I'm not sure what you mean by the !! part. Couldn't you just memoize this in the normal way? You'll get amortized bounds I guess, but I don't think you can avoid that. If you want to basically iterate n times, there's no shortcut to that unless you know more about the function I don't think.
11:45:23 <meditans> kosmikus: I see, so it can solve some uniqueness problems at best, right? Is there a way to express the kind of computation I'm trying to do there?
11:45:31 <kadoban> (sec I'll look up the memoization thing I'm thinking of)
11:45:37 <meditans> what should I look into, or think differently?
11:46:41 <kosmikus> meditans: add an SListI constraint on xs, do pattern matching on the singleton?
11:47:10 <kosmikus> meditans: I have the function you want to write in one of my modules as:
11:47:20 <kosmikus> fromNPI :: forall f xs . SListI xs => NP I (Map f xs) -> NP f xs
11:47:48 <kosmikus> meditans: with Map not even being injective
11:47:57 <kosmikus> meditans: I mean, not even being declared as injective
11:49:05 <meditans> kosmikus: I need a minute to unpack the suggestion and try to implement it :D
11:49:32 <kosmikus> meditans: I'm not sure if you're doing this as an exercise or in order to get stuff done. I can also give you the code.
11:49:33 <kadoban> Gurkenglas: http://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html is what I was thinking of. So you'd memoize the function   f :: Int -> (a, Set a)  and define it recursively (in terms of the previous one), and then you'd use *that* to get the Set you check in.
11:49:47 <kadoban> Probably a simpler construction, but it should work.
11:50:28 <meditans> kosmikus: originally it was done to get stuff done, but then I realized again I don't really understand the details, and it became an exercise :D
11:51:35 <meditans> I'll try, and ask you for the code in case; however, if you have to go, please post the link before so I avoid getting stuck
11:52:17 <kosmikus> meditans: ok, since I don't know exactly when I'll leave: https://gist.github.com/kosmikus/11523015ed5224de165354af9a40bec7
11:52:42 <meditans> kosmikus: well, thank you very much for the help! :)
11:52:52 <kosmikus> meditans: I'm always glad to have users :)
11:55:18 <hackrilege> Added something like unfold for a directed version of Alterative (towards a parameterised <|>) http://lpaste.net/349875
11:57:46 <orion> Why does GHC's configure script check for and claim to need "ld.gold" after it already found "ld"?
12:00:13 <kadoban> Gurkenglas: Totally untested (didn't even try to compile), but this was what I was thinking of, in case it's not clear: https://gist.github.com/kadoban/62a9b7bae05c4195e679db1a54591b45
12:00:58 <kosmikus> meditans: sorry, I also only now see that you asked me a question earlier, which I guess was leading to the problem you're solving now
12:01:06 <hackrilege> What's memoFix?
12:01:28 <kadoban> http://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html <-- from here
12:01:42 <meditans> yes kosmikus, exactly: the second problem was part of a clumsy implementation for the earlier one :D
12:01:44 <kosmikus> meditans: I think there's no easier way right now to achieve what you want (except by writing TH for this special case)
12:02:39 <meditans> perfect, thanks again for the heads up!
12:03:38 <kosmikus> meditans: you're welcome
12:03:46 <meditans> by the way, why this kind of functions isn't in the package kosmikus? You didn't anticipate a need for it or do they have some problem I'm not seeing?
12:04:51 <kosmikus> meditans: I must admit that I've been thinking about adding it, but I'm a bit reluctant, and I'm not sure if I can even say why.
12:05:40 <kosmikus> meditans: but primarily it is because I've never been needing it myself, and I'd consider it to be a rare special case.
12:06:07 <kosmikus> meditans: however, given that you're, I think, the third person posing this question (that's why I have the code lying around), it might be me who's wrong.
12:06:07 <meditans> I might be able to provide an usecase if I manage to implement what I want; so in that case I'll ping you to show it
12:07:15 <kosmikus> meditans: it feels to me that datatypes that adhere to the condition that their code is of shape NP I (Map f xs) are rare
12:07:33 <kosmikus> meditans: but perhaps by using generics-sop you're encouraged to define exactly such (concrete) datatypes
12:08:01 <meditans> exactly, in my case I'm drawn to that kind of datatypes because I want to use hap
12:08:16 <meditans> and so the xss have to be the same
12:08:38 <meditans> actually in all the function exposed by the library, I think, the xss have to be the same
12:08:39 <kosmikus> meditans: I'm certainly interested to hear more about your use case
12:09:10 <kosmikus> meditans: and I guess these functions should probably at least go into a separate library, if not into generics-sop itself
12:09:22 <meditans> sure, let me wrap things up to be able to present them a little better, and I'll ping you afterwards
12:10:07 <kosmikus> I might not be around today. but feel free to send me email.
12:10:48 <meditans> ok, that's perfect; I'll get around to that probably tomorrow! :)
12:11:10 <kosmikus> good luck :)
12:24:45 <hackrilege> How do I make a Tree where two branches point to the same subTree?
12:27:08 <hexagoxel> let x = subTree in Node x x
12:28:19 <hackrilege> I want to be able to use it to make a figure of 8
12:29:27 <hexagoxel> hackrilege: some sort of knot-tying?
12:30:20 <hexagoxel> i fail to reinterpret_cast glyph(8) to TreeLike
12:30:58 <hackrilege> Yeah, I'm trying to make a zipper for a graph containing cycles, it seems to generate a different representation depending on which Hamiltonian path is used in traversal, and some nodes are revisited
12:31:59 <Cale> hackrilege: If that subtree is a variable, you can just use that variable in multiple places, and the subtrees will be identical
12:32:15 <Cale> hackrilege: (and not duplicated in memory)
12:32:37 <Cale> However, you might need to do something extra in your program to *know* that they're identical when you look at the tree again later.
12:32:56 <hackrilege> They have unique int labels to help with that
12:33:00 <Cale> yeah
12:33:25 <hexagoxel> (in theory you could use stable-memo to retain sharing as well)
12:35:00 <hexagoxel> in practice i also resorted to unique Ints to make this work; stable-memo always became unreliable for some reason that i gave up investigating
12:36:22 <hackrilege> It's foldable so I can visit each element in order, so I guess I just then just use zipper left and right a various number of times to get to where the various branches point to, and store those to make a difference list style zipper...
12:36:54 <Cale> Don't be surprised if you need to write something more subtle than some pre-existing Traversable instance gives you.
12:37:32 <Cale> You may want to keep track of which node labels you've seen and not traverse a subtree if it has one of those in it.
12:38:05 <hackrilege> So that the zipper for the graph can jump between list zipper representations when navigating branches.
12:39:27 <Cale> Note that if it weren't for those unique labels, a tree which is infinite will look the same as a tree whose in-memory representation has a cycle in it because of reusing a variable like that.
12:39:39 <hackrilege> I guess the idea is to generate a foldable instance (using a cautious traversal as you describe) so that later, different orders of visitation can be generated
12:42:16 <ppg> Hi all
12:42:19 <hackrilege> Which I guess I hope that when traversing along a different branch, the underlying foldable representation will save me from having to redraw the whole Hamiltonian path each time
12:42:28 <hackrilege> Hi ppg
12:42:56 <ppg> Is there a canonical way to assign variable names to intermediate pattern matches? Example ...
12:43:29 <ppg> Say you have the type Tree a = Node a a | ...
12:44:22 <ppg> and you have a function f: Tree -> String  that for which some pattern matches don't look inside the node definition
12:44:36 <geekosaur> I think you want as-patterns
12:44:44 <ppg> Oh ok, I'll look that up
12:44:44 <geekosaur> foo@(x:xs) and similar
12:44:46 <ppg> Thanks
12:44:47 <Cale> If you have some pattern pat, and var is some variable, then the pattern var@pat will match the same thing as pat, but will bind the entire matched thing to var
12:44:59 <ppg> Yeah, that's exactly what I want
12:45:00 <ppg> Thanks
12:45:17 <maerwald> and, it doesn't require GHC extensions :o
12:45:38 <lynn> hum, unless I'm misinterpreting, I think you just need:   f (Node _ _) = ...
12:46:38 <ppg> No, lynn, I want to use both the name of the node  i.e. node@(Node a b)  and the stuff inside multiple times
12:47:12 <lynn> Ah, okay
12:47:13 <ppg> So the "@" syntax is what I need.  Thanks for the help, I wasn't very clear in my description.
12:47:14 <geekosaur> but the foo@(Node {}) or foo@(Node _ _) type of pattern is also useful at times
12:47:23 <geekosaur> yes, if you don
12:47:31 <geekosaur> t already know, it can be hard to ask about it
12:49:22 <c_wraith> it is unfortunate how many things you have to know to ask good questions. 
12:49:23 <maerwald> geekosaur: which one do you actually prefer? ({} vs _ _ _) the latter is sometimes nicer, because it makes API changes more visible, but can also be annoying if you don't care about the records anyway
12:49:57 <maerwald> I wasn't able to come up with my personal policy of when to use which one
12:50:11 <geekosaur> if it's got a lot of fields I use {}
12:50:23 <geekosaur> for 1-3 I just use _
12:50:59 <maerwald> that's one of those cases where I'd like a compiler warning instead of a compiler error
12:51:09 <hackrilege> I guess I would only use _ if they were not all _
12:51:25 <c_wraith> the threshold for "a lot" has now been set to: 4. gee, my car has a lot of tires. 
12:51:35 <geekosaur> only in this context :p
12:52:12 <maerwald> hackrilege: but, can you be sure an additional record would not require changes in functions using the data type? Might be easily overlooked when using {}
12:52:31 <hackrilege> If it has potentially infinitely many tires I wouldn't count more than 3 of them to check I understood the recursion
12:52:43 <geekosaur> {} is also annoying if a refactor means you suddenly need to use one of those fields and the type wasn't defined with record syntax
12:53:19 <hackrilege> Good point maerwald
12:53:21 <geekosaur> but that case is rather less likely the more fields there are. 3's arbitrary but seems to work well for the situations I run into
12:55:22 <hackrilege> Could anyone help me with this concept? http://lpaste.net/349875
12:58:25 <hackrilege> It could be used eg if \a n xs -> (take n xs) ++ (a:(drop n xs)) was used instead of a:xs
12:59:01 <hackrilege> In which case direction = Int
13:00:04 <hackrilege> I want to be able to use it to grow the cyclic graph I was talking about and use it in the difference list zipper I described
13:07:58 <Darwin226> Hey guys. I have a type with some fields. I want to have those fields strict, but there will be cases when they are "uninitialized". Is there a way to get some "null" value that will be a placeholder and that wont turn the whole constructor into undefined?
13:08:34 <Darwin226> The type has extra type level info that will prevent access to that field,
13:12:18 <EvanR> Darwin226: yes
13:12:40 <kadoban> Darwin226: Kind of guessing, but couldn't you make a strict version of Maybe and then use strict fields with one of those? Other than that, strict fields are really just sugar for seq in certain places, right? You could just use what they're sugar for in the correct places really, though it'll likely be tedious.
13:12:44 <EvanR> a Maybe wrapper
13:13:11 <EvanR> but laziness is really the simpler way to deal with this kind of thing
13:13:15 <EvanR> then you could use an IVar
13:13:28 <Darwin226> I want it strict for performance reasons
13:13:44 <Darwin226> anyways, using 'unsafeCoerce ()' instead of undefined seems to work
13:13:44 <EvanR> does your field type have a dummy value in it?
13:13:56 <EvanR> -1
13:14:19 <Darwin226> Yeah, ideally I want something like that but the solution needs to be generic for every type
13:14:44 <danharaj> edwardk: this sounds like the sort of thing you'd have a silly trick for ;)
13:15:23 <Darwin226> I'm kind of surprised that unsafeCoerce () works
13:15:36 <EvanR> well, i see a contradiction in the features and requirements youre talking about
13:15:44 * edwardk tunes in. wassat?
13:16:07 <EvanR> what do you gain from the strict field in this case
13:16:24 <EvanR> its not the same as being unboxed
13:16:25 <danharaj> edwardk: uninitialized strict fields
13:16:37 <edwardk> i pretty much use an unsafeCoerced () in structs
13:16:42 <edwardk> its its own data type, but same diff
13:16:44 <danharaj> there you have it
13:16:52 <Darwin226> excellent
13:16:55 <EvanR> how does that even work
13:17:06 <Darwin226> And how come it doesn't blow up when the runtime check if the value is evaluated?
13:17:16 <Darwin226> checks*
13:17:39 <EvanR> and im still not sure how its better than a lazy field?
13:17:50 <edwardk> Darwin226: you can enter the thunk for a () to evaluate it just fine
13:18:24 <Darwin226> EvanR: How is any strict unpacked field better than a lazy one? I don't see why this makes a difference
13:18:34 <danharaj> edwardk: does that mean the field has some random ass pointer to a thunk in it? also this works for the unboxed fields in structs too?
13:18:49 <Darwin226> It does, that's my case
13:19:29 <edwardk> danharaj: if you UNPACK then the whole target structure gets inlined
13:19:58 <edwardk> the thing i mentioned above would work for !'d but not UNPACK'd fields that will never be looked at
13:23:14 <EvanR> Darwin226: the benefit of strict is it gets evaluated as soon as the record is constructed and you dont have to tell it to do that explicitly
13:23:28 <EvanR> which it sounds like you dont want to do
13:24:21 <Darwin226> EvanR: Hmm, what you're saying is true. But is there no other benefit in knowing that the field is evaluated?
13:24:24 <EvanR> the fields are unboxed? now im really confused
13:24:30 <Darwin226> Like later when you use it in places
13:25:19 <EvanR> how were you planning to initialize it later?
13:25:43 <Darwin226> I just set the value
13:25:54 <Darwin226> via a lens, but I'm guessing it doesn't matter
13:26:02 <EvanR> oh
13:26:10 <EvanR> not a destructive update
13:26:15 <Darwin226> no no
13:26:45 <EvanR> then this unsafeCoerce makes more sense
13:27:21 <EvanR> youll use less memory by not having an unevalled thunk floating around
13:28:19 <EvanR> and its more convenient than Maybe
13:29:41 <Darwin226> Good, I'm glad it turned out not to be complete nonsense :D
13:31:18 <orion> hmm
13:32:07 <orion> qinusty / geekosaur / mmaruseacph2: When bulding GHC I get a failure during the configure script of libffi: armv7a-linux-gnueabihf-gcc: error: conftest.cpp: C++ compiler not installed on this system
13:32:16 <orion> This suggests to me that C++ is required.
13:32:46 <geekosaur> that sounds to me like libffi is being misconfigured
13:33:03 <geekosaur> libffi certainly has c++ support, but the one bundled with ghc shouldn't be activating it
13:33:21 <geekosaur> suggest you ask in #ghc
13:34:49 <johnw> geekosaur: I didn't think libffi had the ability to call c++ functions that weren't extern "C"...
13:35:49 <geekosaur> it doesn't support demangling, but there are other aspects it has to deal with, like propagating unwind information in case it's being sandwiched between C++ components
13:36:24 <geekosaur> (C++ code can break in *weird* ways otherwise)
13:39:30 <geekosaur> heh. libffi's acinclude.m4 comments are a bit snarky at times
13:41:57 <kqr> is it a good idea to have a StateT around IO, or is it better to simple use some sort of IORef/MVar/whathaveyou?
13:43:06 <johnw> or just use ReaderT (IORef a) IO b
13:47:52 <kqr> haha I guess that's an option too
13:49:07 <kqr> i guess maybe lens has primitives for state and not for IO?
13:49:17 <johnw> correct
13:49:25 <johnw> partly because State is purely functional, and IO is not
13:49:38 <johnw> lens doesn't really deal with things that require effects to take place
13:50:13 <kqr> aren't effects pretty much embedded into van laarhoven lenses?
13:50:21 <johnw> no
13:50:27 <kqr> which is why %%= is id for lenses, or something along those lines
13:50:44 <johnw> when I say "effects" here, I mean actions taken by the IO runtime
13:51:16 <kqr> ah
13:51:25 <dmwit> johnw: Is there a standardish library which provides a MonadState instance and uses ReaderT IORef (or ReaderT MVar) as the implementation?
13:51:54 <johnw> dmwit: the type of put would be wrong, though
13:52:00 <johnw> wouldn't it?
13:52:01 <dmwit> :t put
13:52:03 <lambdabot> MonadState s m => s -> m ()
13:52:07 <dmwit> no?
13:52:20 <johnw> ah, you're right
13:52:26 <johnw> http://lpaste.net/84769
13:52:53 <dmwit> I've implemented it myself a few times before for one-offs. I'm just wondering if there's a library I can pull in next time I need it.
13:57:55 <johnw> dmwit: can't find such a library
13:58:04 <johnw> but this means that yes, lenses could be used, doen't it
14:16:00 <Shockk> this is largely opinionated but which is more preferable for me to use, to both show intent and make it easier to read?
14:16:10 <Shockk> position . Point2 x =<< viewportCenterY
14:16:23 <Shockk> position =<< Point2 x <$> viewportCenterY
14:17:35 <EvanR> yyeesh
14:18:04 <EvanR> both seem kind of golfy
14:18:32 <EvanR> its a pipeline but the pipe connectors arent the same so its ruining my mojo
14:19:42 <EvanR> in the secnod one, whats even the precendence
14:20:16 <EvanR> (position =<< Point2 x) <$> viewportCenterY ?
14:20:31 <EvanR> no...
14:21:41 <Gurkenglas> The first, but why would position be monadic
14:24:29 <qmm> is there a way to make ghc throw a warning when you write a partial function?
14:24:40 <qmm> ...when you have non-exhaustive pattern matching
14:24:43 <EvanR> -Wall
14:25:14 <ezyang> qmm: -fwarn-incomplete-patterns 
14:25:59 <qmm> {-# OPTIONS_GHC -Wall #-}
14:26:00 <qmm> {-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
14:26:02 <qmm> thanks
14:26:53 <Tuplanolla> Check this out, qmm: `ghc --show-options | grep -F -- -fwarn`.
14:29:39 <EvanR> would you say that "there exists unique x such that P(x)" means "if you have x, y such that P(x) and P(x), then you have x = y" ?
14:29:43 <Tuplanolla> I do that when I don't want to bother wading through the user manual.
14:29:50 <sm> is it possible to run individual webdriver commands from GHCI, keeping the session open ?
14:31:04 <EvanR> after fixing the typo, should be P(y)
14:31:25 <johnw> EvanR: I think so, if P(x) and P(y) and exists !x, P(x), then y = x
14:31:39 <EvanR> interesting
14:31:56 <Shockk> sorry I went afk there
14:31:57 <johnw> P is then a single "choice" from the set of which 'x' is a member
14:31:59 <Shockk> thanks EvanR and Gurkenglas 
14:32:27 <EvanR> oh thats taking it a step further ... 
14:32:28 <johnw> Shockk: I prefer the former
14:32:42 <Shockk> and Gurkenglas I'm trying to figure out how exactly I want stuff to be expressed in the game logic part of my game engine
14:33:33 <Shockk> for reference this is what I have right now, in case what I said doesn't make much sense https://gist.github.com/shockkolate/2b236bcd6170fbaa301d56d5b4278d9b
14:33:48 <Shockk> it may or may not be valid haskell or consistent
14:34:08 <EvanR> johnw: my issue is with this proof http://lpaste.net/349900 the above meaning of unique seems to disallow defining functions a certain way
14:34:32 <EvanR> like, id *can* be defined as such, and thus causes a contradiction... which seems weird
14:37:37 <EvanR> but agda accepts it, so it must be true
14:37:48 <johnw> true insofar as your axiom is true
14:38:07 <EvanR> i find the argument about what id equals / is defined as odd
14:39:27 <EvanR> its like its defined two ways
14:39:35 <EvanR> how does that work
14:40:02 <johnw> i don't know what you're talking about
14:40:07 <EvanR> if its merely equal to two things... then whats the problem
14:40:16 <EvanR> i dont know, oh well
14:44:25 <Gurkenglas> Shockk, where do entity and position come from? I don't see them on like https://github.com/polar-engine/polar/search?utf8=%E2%9C%93&q=entity 
14:45:57 <Shockk> Gurkenglas: they don't exist yet, this is sample code for what I'd like to have
14:47:13 <hackrilege> :t \ f -> liftIO . f  =<< ask
14:47:15 <lambdabot> (MonadIO m, MonadReader a m) => (a -> IO b) -> m b
14:48:47 <Gurkenglas> :t ?position <~ ?viewPointCenter -- Shockk, if position and viewPointCenter are going to be lenses, maybe like this
14:48:49 <lambdabot> (MonadState s m, ?viewPointCenter::m b, ?position::ASetter s s a b) => m ()
14:49:32 <Shockk> not sure if I'll use lenses but probably yes
14:50:01 <Shockk> though I've been avoiding thinking about actual implementation before I figure out what I want the API to look like
14:50:11 <Gurkenglas> Umm, use in front of ?viewPointCenter of course
14:50:13 <Shockk> i.e. writing this sample code without regard for whether or not it'll work 
14:50:33 <Shockk> right
14:51:05 <Gurkenglas> One of my heuristics is, lens is designed well enough that I can just put my code in short lens form and that usually works out
14:52:16 <hackrilege> What ate all these question marks and left pointing tilde arrows?
14:52:21 <hackrilege> Are*
14:52:39 <Shockk> the question marks I think assume that the name exists
14:52:51 <Shockk> that's my best guess based on them appearing in the output type too
14:52:57 <Shockk> and the <~ is a lens operator I think
14:52:59 <johnw> implicits?
14:52:59 <Gurkenglas> :t (<~)
14:53:01 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
14:53:40 <xcmw> Has anyone ever used vinyl? Is there a good tutorial? What are the symbols in Derived?
14:54:24 <Gurkenglas> Are there any example lenses with sane types?
14:54:49 <hackrilege> It's unclear from that how to create values of those types
14:56:15 <Gurkenglas> hackrilege, ASetter s s a b is any lenslike that contains "(a -> b) -> s -> s" information, such as any Lens' or Traversal'
14:56:58 <Gurkenglas> m b is any monadic value in the monad whose do block we are currently writing a line for. (It is expected that somewhere's a StateT s layer.)
14:57:08 <hackrilege> How are those variables ending up inside the context!?!?!?
14:58:01 <Gurkenglas> :t show ?asd -- ...I like to treat this as magic syntax? :P
14:58:03 <lambdabot> (?asd::a, Show a) => String
14:58:15 <Gurkenglas> Just for lambdabot demonstrations.
15:00:05 <Shockk> :t ?asdf
15:00:07 <lambdabot> (?asdf::t) => t
15:01:13 <hackrilege> But (<~) didn't operate on constraints
15:01:49 <hackrilege> :t ?x <~
15:01:52 <lambdabot> error:
15:01:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:02:08 <Gurkenglas> :t (?x <~)
15:02:10 <lambdabot> (MonadState s m, ?x::ASetter s s a b) => m b -> m ()
15:02:36 <hackrilege> :t (<~ ?y)
15:02:40 <lambdabot> (MonadState s m, ?y::m b) => ASetter s s a b -> m ()
15:02:52 <hackrilege> Ok I get it
15:03:30 <hackrilege> Oh it's because it uses :: in the constraint
15:04:24 <hackrilege> Anyway, how do we construct ASetter s s a b?
15:06:52 <Gurkenglas> :t iso -- This constructs the "isomorphism" lenslike which you can use as a setter
15:06:54 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
15:07:13 <Gurkenglas> Dammit, y u unroll type synonyms
15:07:49 <qmm> with pattern matching at a function definition, how can i check that the second item in a list isn't empty?
15:07:54 <Gurkenglas> :t iso :: (s -> a) -> (a -> s) -> Iso' s a -- this unrolls too, how do I make it not do that
15:07:55 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (a -> s) -> p a (f a) -> p s (f s)
15:08:05 <Shockk> qmm: something like this I guess
15:08:13 <Shockk> secondNotEmpty [] = False
15:08:29 <Shockk> secondNotEmpty (_:[]) = False
15:08:34 <Shockk> secondNotEmpty _ = True
15:08:52 <Shockk> this is probably bad and can be made better but that definitely just uses pattern matching
15:08:55 <Gurkenglas> :t lens :: (s -> a) -> (s -> a -> s) -> Lens' s a -- This constructs the "lens" or "getter-setter-pair" lenslike which you can use as a setter
15:08:57 <lambdabot> Functor f => (s -> a) -> (s -> a -> s) -> (a -> f a) -> s -> f s
15:09:34 <qmm> Shockk: how would this work with -fwarn-incomplete-patterns?
15:09:50 <Shockk> the _ matches all other patterns 
15:10:03 <Shockk> also I just realized I wrote this in a stupid way, you can just pattern match like the following:
15:10:16 <Shockk> secondNotEmpty (_:_:_) = True
15:10:21 <Shockk> secondNotEmpty _ = False
15:10:35 <hackrilege> (\ (_:_:[])  -> True) [1,2]
15:10:43 <hackrilege> > (\ (_:_:[])  -> True) [1,2]
15:10:46 <lambdabot>  True
15:11:28 <lpaste> qmm pasted “incomplete-patterns” at http://lpaste.net/349901
15:11:33 <qmm> Shockk ^
15:11:38 <qmm> that doesn't compile
15:11:39 <Gurkenglas> :t id :: Applicative f => (a -> f a) -> (s -> f s) -> Traversal' s a -- This constructs the "traversal" lenslike (which is like a "gets-multiple-things&sets-multiple-things"-pair) which you can use as a setter. Note that traverse is a traversal, and the id means that this is the form lenslikes take so you can plug any of them in case of any more general one
15:11:41 <lambdabot> error:
15:11:41 <lambdabot>     • Couldn't match type ‘f2’ with ‘(->) (a1 -> f3 a1)’
15:11:41 <lambdabot>       ‘f2’ is a rigid type variable bound by
15:12:05 <qmm> Couldn't match expected type ‘a’ with actual type ‘[t0]’, ‘a’ is a rigid type variable bound by
15:12:10 <kqr>     ‘show’ is not a (visible) method of class ‘Show’
15:12:11 <kqr> what is this supposed to mean?
15:12:58 <hackrilege> head'' (_:_:[]) = []
15:13:17 <hackrilege> qmm ^
15:13:18 <Shockk> qmm: you're giving a result of [] for two of those patterns
15:13:24 <Shockk> which is of type [a]
15:13:34 <Gurkenglas> :t id :: (forall f. Applicative f => (a -> f a) -> s -> f s) -> Traversal' s a -- whoops, missed some brackets, and now I have to provide the function context, and I have the feeling the following lambdabot line is even less helpful than usual
15:13:36 <lambdabot> Applicative f => (forall (f1 :: * -> *). Applicative f1 => (a -> f1 a) -> s -> f1 s) -> (a -> f a) -> s -> f s
15:13:40 <xcmw> kqr: In what code?
15:14:14 <hackrilege> head'' (_:a:_) = a -- that's better
15:14:53 <hpc> might i suggest https://hackage.haskell.org/package/acme-cadre-0.1/docs/Acme-Cadre.html ;)
15:14:55 <kqr> xcmw, http://lpaste.net/425223795486228480
15:14:58 <kqr> xcmw, really about as simple as it gets
15:15:34 <kqr> though I suspect this may have something to do with the fact that I'm using protolude rather than the regular prelude... I just can't figure out why that matters
15:15:36 <hackrilege> Then head _ = error " head'' passed empty or singleton list"
15:16:01 <Shockk> qmm: if you want to return some kind of 'failure' value if the second item doesn't exist, I would suggest using (Maybe a) as your return type, so you return either Nothing, or (Just a)
15:16:17 <Shockk> or you can go the route that hackrilege suggested
15:16:34 <hackrilege> > head []
15:16:36 <lambdabot>  *Exception: Prelude.head: empty list
15:16:43 <xcmw> kqr: Your code works on my machine. Show is defined in the prelude.
15:16:48 <Gurkenglas> :t _1 :: Lens' (a,b) a -- Here's a predefined lens for us to play with - it's a getter-setter-pair for the first element of a tuple
15:16:49 <lambdabot> Functor f => (a -> f a) -> (a, b) -> f (a, b)
15:17:14 <Koterpillar> hackrilege: cadr?
15:17:21 <kqr> xcmw, ah yes. it appears protolude redefines show as a regular function (rather than a class member) which in turn calls into the class member
15:17:42 <kqr> xcmw, for reference: http://stackoverflow.com/a/37644701/1463507
15:18:28 <hackrilege> Koterpillar, what you say?
15:18:37 <Gurkenglas> > execState (_1 <~ use _2) (2,3) -- use is like StateT's get, but also takes a getter on the state.
15:18:40 <lambdabot>  (3,3)
15:19:12 <Koterpillar> hackrilege: I just saw all the attempts to define this function which is really cadr in Lisp
15:19:15 <hackrilege> :t use
15:19:17 <lambdabot> MonadState s m => Getting a s a -> m a
15:21:00 <johnw> :t (<~)
15:21:02 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
15:22:15 <johnw> never used that before, cool
15:25:34 <johnw> if local lambdabot is telling me mueval-core: GhcException "cannot satisfy -trust random", how do I force it to trust it?
15:26:00 <Gurkenglas> It's kinda sad to get into the style of using it though without all the other operators like += though.
15:26:34 <Gurkenglas> > execState (_1 <~ (+) <$> use _1 <*> use _2) (100,1)
15:26:37 <lambdabot>  (101,1)
15:33:06 <v0d1ch> take 5 [1..]
15:47:33 <hackrilege> I wish I knew how to define those functions; use, _1 and <~
15:50:12 <johnw> _1 is pretty easily defined in a naive (i.e., not super general) way
15:51:15 <hackrilege> But in a way that it works with those other functions?
15:51:20 <johnw> sure
15:51:36 <johnw> a lens is just a function parameterized over some choice of Functor
15:51:43 <hackrilege> Then I guess they are where the complicated bits are...
15:51:49 <johnw> it's the user's choice of functor that determines whether it's a getter or setter
15:51:58 <hackrilege> Aha
15:52:01 <johnw> there aren't any complicated bits, actually
15:52:10 <johnw> watch http://ftp.newartisans.com/pub/Lenses.mp4
15:52:21 <hackrilege> Ok I will! Thanks
15:52:27 <johnw> what's complicated about the 'lens' package is how general things are; but the core idea is not hard
15:52:59 <hackrilege> I was trying to get some commentary on this paste earlier http://lpaste.net/349875
15:53:54 <johnw> what comments were you looking for?
15:54:19 <hackrilege> I'm worried that trying to direct growth is futile and everything is a List
15:54:32 <johnw> i have no thoughts for you on that one
15:55:28 <hackrilege> Oh no that was a random comment I was typing before yours came through
15:56:35 <hackrilege> Basically trying to make a framework to act like unfoldable for graphs
15:57:28 <hexagoxel> hackrilege: laws/example instances?
15:59:09 <hackrilege> I got confused while trying to figure out how to handle cycles, would you need to see it working on a non cyclic container first?
15:59:38 <johnw> it seems awfully narrow in use to deserve such a general treatment
15:59:38 <hackrilege> I thought it seemed fairly clear what was going on with the functions defined
15:59:43 <johnw> i mean, who is the user for this?
15:59:50 <johnw> how many instances could there be?
16:00:08 <johnw> if all you want to do is build graphs from a seed, that could be done with functions
16:00:50 <hackrilege> Well I have unfold for list I wanted to generalise to capture branched data types, I should be able to grow various different trees
16:01:00 <johnw> but why?
16:01:42 <johnw> Arbitrary can build various different trees too
16:02:25 <hackrilege> To write a framework that a user can apply to their datatypes so that they can be constructed, too abstract out the design of programs directing the shape of the resulting tree
16:03:10 <johnw> I still don't see why I'd want to do that from a seed, rather than just building the data I need some other way
16:05:40 <hackrilege> [(a,direction)] is a good seed though
16:06:13 <hackrilege> It's about imposing a shape over a List
16:06:42 <hackrilege> I'm really stuck at that point to handle the foldable instance
16:07:39 <johnw> I still wouldn't need a typeclass for this.  The only reason to have such a typeclass is because you expect people to write algorithms that are general over that interface
16:07:57 <johnw> anyway, show me a compelling use case, and then I'll rethink :)
16:09:32 <hackrilege> The point is to provide an api to handle the way you represent the shape of the structure. I'm working on trying to use it in a zipper, I'll remember to do that next, I just want tip get that class finished, each time I write it it comes out a little differently. I guess I hoped it looked reasonable
16:09:58 <hackrilege> to get*
16:10:51 <hexagoxel> yeah i agree with johnw. the existence of `direction` as an argument to most of the methods means that you won't be able to write anything generic based on this interface.
16:11:46 <hackrilege> And yes, it is totally deliberate to force the user to consider the linear growth of the structure, basically that's the point, I can't quite see how it's not a good idea, but there is some redundancy with Foldable
16:13:56 <hackrilege> (:) could be used, requiring direction as an additional argument to the push and pull should allow a parameter to indicate direction, with getDirection to remember and return this order, as regardless of where new elements are placed, they are placed there *in order*
16:14:39 <johnw> is this a solution in search of a problem, or are you developing it because it simplifies some repetitive code you've found yourself writing?
16:15:53 <johnw> I mean, zippers are themselves a decent abstraction, but even they aren't really used much at all
16:16:12 <xcmw> Has anyone used vinyl before?
16:16:25 <johnw> a better way to build up complex structures might be to just have a good Monoid instance, letting you glue together pieces of the structures as you go
16:16:25 <hackrilege> I'm trying to resolve something and the code was written to refer to in discussion. Basically I'm confused since no matter where in a data structure growth occurs, there is a linear sequence for these operations. This class just tries to represent the operations
16:17:38 <hackrilege> I'm trying to extend Alternative to also require parameters directing growth
16:17:53 <hackrilege> Rather than using Monoid
16:18:01 <johnw> why?
16:18:20 <johnw> again, unless a real problem is driving this, placing such constraints on the solution seems wrong
16:19:07 <hackrilege> It's an abstraction for a class that must be instantiated by various polymer growth methods
16:19:10 <hackrilege> There
16:19:17 <johnw> I get it; but again, why
16:20:02 <hackrilege> Because I can't find a suitable class representing this
16:20:17 <hackrilege> Well I can, such as unfolder or arbitrary
16:20:47 <hackrilege> But I'm just trying to write down the class for communication purposes
16:20:59 <johnw> communication to whom?
16:21:25 <hackrilege> This channel, and also myself later when I try and wrote it again
16:21:39 <hackrilege> It will end up in the library I'm writing
16:21:46 <hackrilege> It's just a style
16:22:02 <hexagoxel> hackrilege: that you need to express this _as a class_ still seems like an arbitrary assumption.
16:22:04 <hackrilege> And the library is built around that style
16:22:41 <hexagoxel> you could just define a Direction datatype for each thing that would be an instance, and define some functions.
16:22:57 <SlimCow> Hi! I'm trying to define a Show instance for one of my data types, but I get a "Malformed instance" compilation error. 
16:23:21 <hexagoxel> forcing this interface into a class does not seem to serve any particular purpose.
16:23:21 <hackrilege> How else do I demand demand as yet undefined types instantiate abstract methods and associated types!? That's exactly what classes are for!!
16:23:25 <xcmw> SlimCow: Can you post the code?
16:23:27 <kadoban> SlimCow: lpaste.net the code, with the error?
16:24:23 <hackrilege> Direction should also be a variable used to generate push and pull functions
16:24:43 <hackrilege> :t (!!)
16:24:45 <lambdabot> [a] -> Int -> a
16:24:50 <hexagoxel> hackrilege: again, you assume that there is something inherently good about having "abstract methods"
16:25:20 <hackrilege> Yes, it's specifically a design feature I wish to invoke
16:26:08 <SlimCow> xcmw: kadoban http://lpaste.net/349903
16:26:23 <SlimCow> The error is just: Malformed instance: Show Graph => Graph -> String
16:27:16 <hackrilege> For lists Int is a suitable type for direction. For other instances, other types will work, so I Need this abstract associated type. And it would be impossible for me to write the get methods until the type is defined
16:27:23 <Koterpillar> SlimCow: instance Show Graph where...
16:28:06 <Koterpillar> SlimCow: typeclasses can have more than one method, so it's pointless to specify the signature of show in the header
16:28:21 <hackrilege> I really don't get why it being a class is a question...
16:29:13 <kadoban> SlimCow: Also, you're deriving Show, you can't both derive it and implement it manually, you should pick one or the other.
16:29:24 <kadoban> Though that's not why you're getting the error
16:33:32 <hexagoxel> hackrilege: classes solve a certain type of problem, and what you have there does not look like a good match, and you have not given a good reason _for_ using a class. and it simply is hard/impossible to give any advice when the intentions are as unclear.
16:33:34 <SlimCow> kadoban: got it, I thought you had to let the compiler know you're going to provide an instance
16:33:53 <johnw> hackrilege: because you're coming here, without code, trying to design a feature "for the sake of discussion", in the hopes it will lead to a future library. We're discussing your design now by saying it's overly general without a compelling reason to be so.  Things should really end there, until you have either (a) a real problem to drive the design, or (b) code that shows your proposal has merit.  Until then, there's no reason to use
16:33:53 <johnw> the channel's time further.  We've talked about this before, becasue this whole zipper thing has been going nowhere for _months_ now.
16:34:01 <SlimCow> Koterpillar: thanks! got it to work
16:35:11 <kqr> I feel like I'm reinventing the wheel here: http://lpaste.net/6349157219174449152
16:35:13 <kqr> am I?
16:35:19 <hackrilege> Ok I'll write some instances before inviting discussions about classes!
16:36:12 <hackrilege> Thanks, thats not totally unhelpful, I didn't anticipate that being the only point worth discussing
16:36:25 <hackrilege> Won't happen again
16:36:30 <johnw> thanks, hackrilege 
16:37:13 <johnw> we don't challenge you to be harsh, but to encourage a productive way to further your ideas
16:37:46 <hackrilege> Sings *I didn't mean to take up all your sweet time, I'll give it right back to you one of these days* exits to guitar solo
16:38:10 <ggVGc> I tried using zippers in the beginning of my haskell usage, and I quickly started feeling they were problematic becuse the contined data and the pointer to it was a single structure
16:39:04 <ggVGc> I feel that's it's much more useful to have a cursor structure and some data that it can point to
16:39:15 <ggVGc> so you can have multiple cursors without having copies of the data
16:39:37 <johnw> zippers optimize several local changes within a large structure; I haven't needed such an optimization yet.  You can just compose multiple updates, and often that's good enough.
16:40:22 <johnw> or, with lens, use zoom, and then do multiple updates within the sub-part
16:40:51 <johnw> I guess they're also useful for "relative addressing"
16:41:07 <ggVGc> johnw: yep, I started learning about lenses a few months after I tried zippers, and lenses were what I initially wanted zippers to be
16:41:18 <ggVGc> so far I still don't know when I'd use a zipper
16:43:52 <johnw> it's funny that they're introduced in LYAH even
16:44:03 <johnw> http://stackoverflow.com/questions/380438/what-is-the-zipper-data-structure-and-should-i-be-using-it
16:45:34 <Tuplanolla> I don't recall ever using a zipper consciously.
16:46:07 <johnw> ah, it's the dreaming coders that use them
16:50:31 <xcmw> Is there any existing record library the supports a type changing map. An example would be running Just on every key.
16:52:23 <johnw> what does "key" mean in that context?
16:53:37 <xcmw> johnw: Like {x: 5, y: "Hi"} `rmap` Just = {x: Just 5, y: Just "Hi"}
16:55:03 <jle`> xcmw: 'fmap' for normal Data.Map changes the types of the values
16:55:32 <xcmw> jle`: Does Data.Map support values of different types?
16:55:37 <jle`> er, not fmap.  map
16:55:51 <jle`> oh wait, yes, fmap
16:55:56 <jle`> xcmw: no,it's not heterogeneous
16:56:07 <Koterpillar> xcmw: well, that looks like either vinyl or record
16:56:09 <jle`> but the Object type from the 'aeson' package has a heterogeneous one
16:56:31 <jle`> of strings or numbers and stuff like that
16:56:33 <Koterpillar> jle`: not generically
16:56:44 <jle`> mhm
16:56:55 <xcmw> Koterpillar: I looked at vinyl. It looks promising but I can't understand how to use it.
16:57:16 <Koterpillar> xcmw: same problem
16:57:33 <Koterpillar> well, I actually tried, but ran into GHC limitations
16:57:53 <Koterpillar> i.e. I can declare a value which I can use but for which I can't infer any valid type
16:59:11 <xcmw> Koterpillar: I made my own record library with the help of the people on this channel that supports this but it is not very good
17:00:21 <xcmw> Koterpillar: It relies on contraints. And it requires you to explain to ghc how the type and constraints change.
17:01:40 <xcmw> Vinyl looks better. Does anyone know how to use it?
17:02:05 <Koterpillar> xcmw: I think that's what I tried with
17:03:59 <orion> http://www.aosabook.org/en/ghc.html -- "In the future we hope it may be possible to find a compromise solution that allows retaining ABI compatibility while still allowing some cross-module optimisation to take place." Has this happened yet?
17:04:00 <acowley> xcmw: Ido!
17:04:13 <acowley> xcmw: What are you trying to do?
17:04:18 <ezyang> orion: Not really 
17:04:49 <xcmw> acowley: What is vinyl derivied with symbol?
17:05:22 <acowley> I don't think I understand that question
17:05:54 <xcmw> acowley: https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Derived.html
17:06:21 <xcmw> acowley: Is this ElField better than the one in the tutorial?
17:06:26 <acowley> That is a specialization of the `Rec` type to fix the first type argument as ElField
17:07:13 <acowley> xcmw: That's difficult to answer: it is better in that it can be easy to use and is similar to what other extensible record libraries give you.
17:08:05 <acowley> xcmw: A downside to it is that it is very unconstrained.
17:08:21 <xcmw> acowley: Do I have to make a new (=::) for every set of prop to type mappings?
17:08:38 <acowley> The tutorial uses a more complex setup to avoid relying on strings to identify things.
17:09:36 <acowley> xcmw: If you want to use the closed universe style in the tutorial, then yes. If you want to use Symbols as in the module you linked, then no.
17:10:42 <xcmw> acowley: Ok. Question 2: Lets say I have d1 = {x: "5", y: "Hi"} and d2 = {x: (read :: String -> Int), y: (id :: String -> String)}
17:11:12 <xcmw> And I want to get d3 = {x: 5, y: "Hi"}
17:11:57 <xcmw> Can vinyl do that?
17:12:33 <acowley> I think so, but it's a smidge tricky because changing types is awkward (the change from d1's type to d3)
17:13:59 <xcmw> acowley: How?
17:15:17 <xcmw> Is there any good example usage of vinyl beyond the tutorial?
17:15:31 <acowley> The way I'd try to do it is to map d1 into a d1' with type `Rec (Const String) '[Int,String]`, then d2 <*> d1'
17:15:37 <acowley> Err, d2 <<*>> d1'
17:17:28 <xcmw> acowley: I don't even know how to make d2? When I try to give a key a different value type I get an error.
17:19:24 <xcmw> acowley: If I'm in the tutorial and try to give SName an Int instead of a string ghc complains
17:23:02 <acowley> xcmw: I just pieced it togher in a repl, but I didn't use the ElField stuff, so bear with me
17:25:01 <acowley> xcmw: let d1 = Const "5" :& Const "Hi" :& RNil :: Rec (Const String) '[Int,String]
17:25:53 <acowley> xcmw: let d2 = Lift (pure . read . getConst) :& Lift (pure . getConst) :& RNil :: Rec (Lift (->) (Const String) Identity) '[Int,String]
17:26:00 <acowley> xcmw: d2 <<*>> d1
17:26:06 <acowley> xcmw: {5, "Hi"}
17:26:27 <acowley> Clearly one would want to use some helpers rather than typing it all like that
17:26:44 <xcmw> acowley: Data.Vinyl.Functor.Const or Control.Applicative.Const?
17:27:00 <acowley> That was with the Vinyl one, but I don't think it would matter
17:27:50 <acowley> And <<*>> can be written rapply, which is what I usually do
17:29:06 <acowley> One could also write that application like this: rapply (Lift (pure . read . getConst) :& Lift (pure . getConst) :& RNil) d1 :: Rec Identity _
17:29:17 <acowley> If you've already got d1 hanging around and its type is clear
17:29:30 <acowley> The partial type signature is sufficient to fix Identity as the result functor
17:32:21 <xcmw> acowley: Ok. Thanks.
17:32:56 <xcmw> How can I make it so that ghci can print d1?
17:40:33 <xcmw> acowley: Where are the property names?
17:44:14 <acowley> Ugh, there's no Show instance for Const
17:44:19 <acowley> instance Show a => Show (Const a b) where show (Const x) = "(Const "++show x++")"
17:44:27 <acowley> Then d1 shows
17:44:34 <acowley> I'll add that instance to the library
17:44:53 <acowley> I didn't do the property names since it would get too noisy doing it like that at the repl
17:46:09 <xcmw> acowley: Does vinyl support type changing maps?
17:48:30 <buglebudabey> im using "foldl (\acc x -> f( x acc) ..) base [1...i] to apply a function to something i times, is there a better way to do this?
17:48:31 <acowley> xcmw: I don't remember what the state of that is. It was not supported for quite some time.
17:48:48 <xcmw> acowley: It it possible to write a generic show function that works when all keys are showable and a list of keys is given as an argument?
17:49:15 <acowley> xcmw: The difficulty wasn't very profound: the problem was deleting an element from the type list and replacing it with another resulting in types that didn't always reduce
17:50:55 <acowley> xcmw: Sure: rcast d1 :: Rec (Const String) '[Int]
17:51:02 <acowley> xcmw: {(Const "5")}
17:54:19 <htmldrum> Is there a standard operator for retriving a value from a Functor? E.g.Functor f => f a -> a?
17:54:27 <MitchellSalad> htmldrum: nope
17:54:41 <htmldrum> MitchellSalad: Is there a reason that I'm missing?
17:54:43 <MitchellSalad> that's why the container analogy is a bad one, imo
17:55:07 <MitchellSalad> that's just not part of the definition of a functor
17:55:25 <Rembane> htmldrum: What makes you want to do that?
17:55:32 <htmldrum> MitchellSalad: I'm down with Applicative, Monoid and Monad as well but no help there either.
17:56:05 <htmldrum> Rembane: Well (>>=), (*), ($) seem useful and have similar behavior.
17:56:07 <MitchellSalad> Comonad has that function, but I suspect you don't actually want that function =)
17:56:56 <Rembane> htmldrum: Indeed. 
17:57:13 <edwardk> htmldrum: here's a Functor. data Foo a = Foo -- notice it has no 'a's in it. How would you implement your function?
17:57:34 <Rembane> htmldrum: Generally you combine values until you have a structure that does what you want and then you run it.
17:57:38 <edwardk> instance Functor Foo where fmap _ Foo = Foo
17:57:55 <edwardk> heck, it is even a monad
17:58:04 <edwardk> instance Monad Foo where return _ = Foo; Foo >>= _ = Foo
17:58:24 <Rotaerk> htmldrum, specific instances of functors can be containers of values that you can retrieve; think of functor-ness as just being an aspect of those specific types, and that aspect doesn't include extraction of values...
17:58:53 <htmldrum> Thanks, all. Thought I was missing something.
17:59:39 <edwardk> '(->) ProofOfTheRiemannHypothesis' is also a functor. the existence of such a method would be... interesting ;)
18:00:03 <haskell942> I suspect that my code is in an infinite loop but I have no idea where, is there a tool that can help me?
18:06:04 <htmldrum> MitchellSalad: Thanks for the pointer to Comonad.
18:07:49 <kushi> I am having so much trouble with if statements
18:08:12 <Rotaerk> what about them?
18:08:21 <kushi> just there syntax
18:08:25 <MitchellSalad> what is this "statement" you speak of
18:08:34 <kushi> ghci isn't helping either
18:08:49 <kushi> it just tells me vague info
18:08:52 <MitchellSalad> if <expr> then <expr> else <expr>
18:09:04 <MitchellSalad> that's the syntax
18:09:30 <Rotaerk> what are you using to learn haskell?
18:09:40 <MitchellSalad> does that help or am i misunderstanding the problem?
18:09:53 <kushi> here is my code http://pastebin.com/iSPb46j0
18:09:58 <kushi> along with log
18:10:09 <MitchellSalad> ah, your then/else branches have to be vertically aligned, i believe
18:10:14 <Rotaerk> I get a little annoyed with indentation rules sometimes in haskell, and I remember not quite liking how if-then-else worked in that aspect
18:10:58 <MitchellSalad> well, they don't *have* to be vertically aligned, because putting it all on one line works
18:10:58 <kushi> I couldn't even write a fibonacci sequence function in an hour
18:11:38 <MitchellSalad> the first steps are always the hardest
18:12:33 <kushi> how would I vertically align it?
18:13:24 <kadoban> kushi: You should line up the 'then' and the 'else' vertically, and they should be indented farther than 'if' is, I believe. Also you need to remember that they're *expressions*, not statements. What's wrong in your code there in the else is going to bite you.
18:13:55 <kadoban> kushi: let newTime = time-1 in countDown newTime    the *in* is important
18:13:57 <MitchellSalad> they can be in the same column as the "if"
18:14:07 <kadoban> > let x = 5 in x + x
18:14:10 <Rotaerk> kushi, how are you trying to learn this?
18:14:10 <lambdabot>  10
18:14:21 <Rotaerk> reading a book?
18:14:42 <kushi> well I read a bit of the book Learn you a haskell and then I try to write simple problems
18:14:51 <kushi> probably not the best approach
18:15:19 <Rotaerk> nothing wrong with trying it out as you go
18:15:34 <Rotaerk> does LYaH not explain indentation?
18:16:20 <kushi> lol I haven't read to conditional flows is why I mean not the best approach but I wanted to write a fibonacci sequence function and i thought I would need it
18:16:58 <MarcelineVQ> kadoban, MitchellSalad: they can even be less indented than the if, but not less indented than the indentation level of the expression you're making the if... in.. that's hard to explain clearly <_< http://lpaste.net/349906
18:18:21 <Rotaerk> kushi, most languages don't care about your use of whitespace, as long as you have some, and nesting of expressions is usually indicated by some kind of wrapping symbols, like { }... for instance if (x) { } else { }
18:19:13 <Rotaerk> but in haskell, while you *can* use { }'s for explicit nesting, it's usually indicated by relative indentation
18:25:46 <Rotaerk> oh, kushi, https://en.wikibooks.org/wiki/Haskell/Indentation
18:25:48 <Rotaerk> might help
18:26:19 <kushi> thanks
18:26:34 <kushi> I think I fixed it but this will help thanks
18:26:42 <kushi> I did else do
18:27:22 <MitchellSalad> don't do that! =(
18:27:28 <Rotaerk> haha
18:27:48 <MitchellSalad> non-monadic do-blocks shouldn't be allowed
18:28:00 <Rotaerk> there are non-monadic do-blocks?
18:28:19 <MitchellSalad> yeah, he just said he did "else do"
18:28:42 <Rotaerk> well, don't think that's not monadic, it just probably won't work
18:28:43 <MitchellSalad> as in, using ";" to mean a newline, "else do; let foo = bar; baz"
18:29:00 <Rotaerk> hmm
18:29:01 <MitchellSalad> instead of "else; let foo = bar; in baz"
18:29:22 <MitchellSalad> it will work and it isn't in a monad, that's what i mean by non-monadic
18:48:01 <byorgey> > do 3  -- Rotaerk 
18:48:03 <lambdabot>  3
18:48:11 <byorgey> > do 5 + do do 7
18:48:13 <lambdabot>  12
18:48:39 <byorgey> let re = succ; mi = 3 in do re mi
18:48:47 <Koterpillar> :t do 3
18:48:49 <lambdabot> Num t => t
18:49:32 <Koterpillar> :t do -- don't expect this to work
18:49:34 <lambdabot> error: Empty 'do' block
18:49:42 <Koterpillar> I didn't expect _that_
18:49:53 <byorgey> well, it's syntax
18:50:01 <Koterpillar> > do { 3 }
18:50:03 <lambdabot>  3
18:50:04 <Koterpillar> > do { 3; 4 }
18:50:07 <lambdabot>  error:
18:50:07 <lambdabot>      • Could not deduce (Num (m a0))
18:50:07 <lambdabot>        from the context: (Num (m b), Num (m a), Monad m)
18:51:43 <lpaste> xcmw pasted “Weird constraint error but only when using let” at http://lpaste.net/349908
18:52:11 <xcmw> Is that a ghc bug?
18:54:28 <c_wraith> xcmw: no
18:54:42 <c_wraith> xcmw: the lambda binding is desugaring to using a case instead of a let
18:55:11 <c_wraith> xcmw: using case is necessary there.
18:56:48 <c_wraith> xcmw: if you tried "case (getA k a, getA k b) of (FieldNewtype va, FieldNewtype vb) -> va == vb" it should work, barring typos
18:58:45 <c_wraith> xcmw: the reason it works with case but not let has to do with the hindley-milner algorithm's let-generalization step.
18:59:11 <c_wraith> xcmw: it attempts to give bindings in a let as general of a type as possible, unlike bindings in a case
18:59:31 <xcmw> c_wraith: Ok. Thanks
19:00:44 <c_wraith> xcmw: amusingly, you found one of the few cases where that strikes where the error message doesn't talk about ghc's brain exploding
19:02:25 <xcmw> c_wraith: Is there any benefit to having let behave the way it does?
19:03:06 <c_wraith> > let f x = x * 2 + 1 in (f 3 :: Int, f 4 :: Double)
19:03:08 <lambdabot>  (7,9.0)
19:03:36 <c_wraith> xcmw: it's nice to be able to define polymorphic functions in a let expression
19:04:33 <c_wraith> xcmw: note that top-level bindings in a source file are essentially treated as if they were in a let expression in a lot of ways, including the fact that they get general types.
19:05:38 <MitchellSalad> what is the purpose of "Control.Exception.Base"?
19:05:55 <MitchellSalad> the module doc says "Extensible exceptions, except for multiple handlers.", but I'm not sure what that means
19:06:54 <xcmw> > > (\f -> (f 3 :: Int, f 4 :: Double)) (\x -> x * 2 + 1)
19:06:56 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
19:07:09 <xcmw> > (\f -> (f 3 :: Int, f 4 :: Double)) (\x -> x * 2 + 1)
19:07:11 <lambdabot>  error:
19:07:11 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Int’
19:07:11 <lambdabot>      • In the expression: f 4 :: Double
19:07:43 <xcmw> c_wraith: I see now
19:08:38 <c_wraith> MitchellSalad: it means it doesn't have the catches function.  I'm not sure *why* it is split up that way
19:09:57 <MitchellSalad> oh
19:09:59 <c_wraith> MitchellSalad: maybe someone wanted to keep the existential required to make catches work out of the base exceptions code?
19:11:38 <MitchellSalad> that's possible, although you don't need to enable ExistentialQuantification just to import Control.Exception
19:11:48 <c_wraith> I really have no idea
19:11:58 <MitchellSalad> seems like... a wart! in base? gasp!
19:12:18 <c_wraith> throw it in the pile with all the rest
19:12:28 <c_wraith> Especially the Enum instances for Float and Double. :P
19:12:51 <MitchellSalad> here's another warty wart... in the form of a pop quiz
19:12:53 <MitchellSalad> :t first
19:12:55 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:13:07 <MitchellSalad> ha, WRONG, it's a bifunctor method IDIOT
19:13:16 <MitchellSalad> Oh, it's both.
19:14:41 <c_wraith> I remember the discussion leading to that. 
19:14:58 <MitchellSalad> I don't but I'd love to read it! was it on haskell-cafe?
19:15:16 <c_wraith> either that or -libraries 
19:15:55 <MitchellSalad> is that different than haskell-core-libraries?
19:16:10 <c_wraith> but the main point was that it's hardly the only name collision in base, and that a very large number of Arrow imports were only for first or second. 
19:16:54 <c_wraith> yes, it's a different list. 
19:17:16 <c_wraith> look for the discussion on adding Bifunctor to base
19:19:41 <MitchellSalad> is there any way to browse the mailing list online? i can only figure out how to subscribe to it...
19:20:24 <nitrix> MitchellSalad: https://mail.haskell.org/pipermail/haskell-cafe/
19:20:32 <MitchellSalad> thanks!
19:21:43 <MitchellSalad> now if only i could search these threads
19:23:11 <nitrix> You can look at the text downloadable version and Ctrl-F stuff.
19:24:05 <nitrix> The interface seems really limited. I'm personally subscribed to it with a filter in my inbox.
19:25:15 <c_wraith> MitchellSalad, https://mail.haskell.org/pipermail/libraries/2014-April/022844.html
19:25:26 <MitchellSalad> i actually just use google groups for haskell-cafe, but libraries isn't mirrored there for whatever reason
19:25:27 <c_wraith> (I cheated and used google) 
19:25:31 <MitchellSalad> c_wraith: oh, thanks!
19:40:29 <monochrom> MitchellSalad: Are you related to FunctorSalad?
19:40:41 <MitchellSalad> nope
19:41:05 <MitchellSalad> though now i feel less special
19:42:54 <hodapp> all salads matter
20:14:46 <pavonia> Heh, someone made the #haskell AoC leaderboard look like a display with a defective pixel
20:20:30 <MarcelineVQ> some people do things out of order, those rogue rebel mavericks
20:50:58 <slack1256> what is the de facto way to do GUI in haskell? some popular example applications would be nice!
20:51:46 <Koterpillar> slack1256: OS requirements?
20:52:22 <Koterpillar> slack1256: gi-gtk seems nice... but that might be because I know it :)
20:53:39 <Axman6> I would say there is no defacto was to make gui apps with Haskell. there are some ways, but they're not used widely
20:54:15 <glguy> Web frontend is probably the "defacto way"
20:57:58 <auggy> Hi folks, I'm new to Haskell and I'm running into a syntax error I can't seem figure out.
20:58:03 <auggy> https://www.irccloud.com/pastebin/uSKnr9Z0/
20:58:25 <auggy> error is "error: parse error on input ‘case’"
20:58:43 <glguy> auggy: Line the "case" up with "s" above it
20:58:47 <auggy> I'm hoping it's something glaringly obvious to someone who hasn't been staring at the code for awhile
20:58:50 <auggy> ahhhhh man
20:58:57 <auggy> I knew it was something silly
20:58:59 <auggy> Thanks!
20:59:48 <Axman6> for a beginner, that's quite nice code, well done
21:00:25 <auggy> Ha well I'll thank the Aeson tutorial for that
21:00:46 <Axman6> also, you can replace that case statement using fromMaybe: fromMaybe "none" (readMaybe s)
21:01:07 <Axman6> uh, with return out the front
21:01:16 <auggy> oh cool
21:01:35 <auggy> I've mostly worked with Perl before getting into Haskell so I'm all about one liners ;)
21:02:52 <auggy> I really should be using something like servant or a github client but thought it would be fun to handroll it first so I understood what's happening below the hood :)
21:04:12 <Axman6> is this accessing the GitHub API?
21:04:16 <ezyang> Does 'any' fuse? 
21:04:45 <auggy> Axman6: yeah it is 
21:04:57 <Axman6> ezyang: surely it's written in terms of foldr so... um, does foldr fuse? (build/foldr makes me hesitant to say yes)
21:04:58 <nshepperd> @src any
21:04:59 <lambdabot> any p = or . map p
21:05:36 <Koterpillar> don't trust src for this
21:06:12 <auggy> i'm basically grabbing different github events and creating/updating trello cards
21:06:17 <ezyang> well, I can't remember the last time someone needed to use 'any' on 'String' 
21:06:48 <Axman6> surely things like `any isSpace` isn't that uncommon?
21:06:51 <auggy> my first inclination was to do it in Perl but then I thought it'd be fun to actually write IRL Haskell code after messing around with tutorials and exercises etc
21:07:17 <ezyang> Axman6: Oh you're right 
21:08:03 <nshepperd> looks like any is actually implemented in terms of foldMap and Any now
21:08:34 <nshepperd> which doesn't really answer the question I suppose
21:15:45 <MarcelineVQ> ezyang: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#list-fusion   it's on the list, though that list has been the same for awhile I think so no idea about its current accuracy
21:16:19 <ezyang> MArcelineVQ: Thanks! 
21:18:53 <glguy> byorgey: Looks like my computer is faster than yours :( this was a dumb puzzle
21:19:34 <byorgey> glguy: agreed
21:27:03 <glguy> byorgey: Do you know how to run a Builder with a known output length?
21:27:13 <glguy> I'd swear there was a function for this
21:27:35 <glguy> Oh, this stuff! http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Builder-Extra.html#t:AllocationStrategy
21:27:37 <byorgey> glguy: no clue
21:29:35 <ezyang> Straw poll: should the "default" string signature support indexing by Int 
21:36:18 <slack1256> Koterpillar: I didn't know about gi-gtk or haskell-gi
21:36:25 <slack1256> cool
21:37:51 <jle`> ezyang: what string signature?
21:38:44 <ezyang> jle`: The one here https://github.com/haskell-backpack/backpack-str (specifically https://github.com/haskell-backpack/backpack-str/blob/master/str-signature-v1/Str.hsig ) 
22:45:56 <jchia1> My local haddock describes ReaderT as "newtype ReaderT k r m a :: forall k. * -> (k -> *) -> k -> *" instead of "newtype ReaderT r m a :: * -> (* -> *) -> * -> *" as given on hackage. Any idea why I might be getting this different description? It really confused me.
22:51:37 <jle`> jchia1: where are you seeing hackage's kind signature?
22:51:43 <jle`> i'm not seeing it anywhere here http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Reader.html
22:53:20 <jle`> oh, i see it in the docs for mtl
22:53:44 <jle`> you might have compiled it with PolyKinds enabled somehow?
23:10:52 <glguy> transformers is polykinded now, I don't know why that's not showing up on hackage
23:11:09 <glguy> Maybe someone explicitly turned it off because it's just confusing
23:12:44 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard. Key in /topic
23:41:51 <b0llu> why does hackage not build tdcs?
23:41:53 <b0llu> docs*
23:50:35 <moet> what would be the right abstraction to represent a pair of functions which can be composed 'in parallel' with another pair?
23:51:46 <moet> like `(ina, outa) . (inb, outb) = (ina . inb, outa . outb)`
23:51:49 <jchia1> jle`: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#v:ReaderT
23:52:13 <moet> (this is bracket, lifted to a data structure... :sheep:)
23:53:17 <moet> i feel like there's something i can do with the fmap instance of (->) to get there
23:53:32 <moet> *functor
23:55:36 <moet> or not.. that's reader monad sth
23:57:43 <lyxia> moet: product of categories
23:58:19 <moet> lyxia: blurg.. i was just reading about arrows
23:58:40 <moet> i'll poke at products and categories, but tbh i'm not sure i'll understand 'em.. thanks!
