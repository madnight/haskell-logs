00:09:59 <sanett> Does Float/Double not have a min/maxBound?
00:11:05 <haskell182> :t maxBound
00:11:07 <lambdabot> Bounded a => a
00:11:13 <haskell182> :i Bounded
00:12:11 <liste> > maxBound :: Float
00:12:13 <lambdabot>  error:
00:12:14 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
00:12:14 <lambdabot>      • In the expression: maxBound :: Float
00:12:35 <liste> apparently not
00:13:03 <EvanR> if you think its a "ghetto real" number, then it wouldnt make sense
00:13:37 <liste> > maxBound > (0.0/0.0)
00:13:39 <lambdabot>  error:
00:13:39 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘maxBound’
00:13:39 <lambdabot>        prevents the constraint ‘(Bounded a0)’ from being solved.
00:13:45 <liste> > maxBound > (0.0::Float/0.0)
00:13:47 <lambdabot>  <hint>:1:24: error: parse error on input ‘0.0’
00:14:32 <EvanR> not bounded
00:17:35 <uiop> > maxBound > (0/0::Float)
00:17:38 <lambdabot>  error:
00:17:38 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
00:17:38 <lambdabot>      • In the first argument of ‘(>)’, namely ‘maxBound’
00:17:50 <uiop> > (maxBound::Float) > 0/0
00:17:54 <lambdabot>  error:
00:17:54 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
00:17:54 <lambdabot>      • In the first argument of ‘(>)’, namely ‘(maxBound :: Float)’
00:18:12 <uiop> liste: ^ 2 ways to do that (the lack of instance is coincidental)
00:19:56 <uiop> liste: once you type "::" the only thing that can close the type parsing context is a ")"
00:20:35 <uiop> wait, also floating point being bounded is sketchy
00:20:43 <uiop> probably why there's no instance
00:23:03 <lonokhov> o/
00:23:22 <lonokhov> is there a way in QuickCheck to override test count per property?
00:24:49 <lyxia> quickCheckWith theRightArg
00:24:54 <uiop> actually whats wrong with bounding floating point by +/- infinity
00:25:04 * uiop votes nothing
00:30:17 <Latro__> uiop, it's not really useful to treat maxBound as inf and minBound as -inf
00:31:06 <latro`a> uiop, you could make the instance of course...but you'll have problems with using it
00:31:09 <latro`a> I expect
00:32:36 <latro`a> basically it's a bound you should never hit, because if you do you fall into a situation where your "programming model" doesn't match your "reality"
00:33:34 <EvanR> for one thing, the laws of Bounded dont actually get satisfied
00:33:51 <EvanR> > (0/0) < (1/0)
00:33:54 <lambdabot>  False
00:34:08 <EvanR> i mean if you picked infinity as the maxBound
00:35:24 <latro`a> seems like you'd need some kind of a wrapper to prevent NaNs to make that work out...which would be horrible
00:37:10 <sanett> Is there unsigned Num in haskell?
00:38:07 <EvanR> no
00:38:27 <EvanR> there is Numeric.Natural
00:38:32 <EvanR> which is a type not a class
00:41:09 <lonokhov> lyxia: Hm, that doesn't with tasty-quickcheck interface :(
00:44:29 <dmwit> sanett: What is Num?
00:45:40 <sanett> :t 10
00:45:42 <lambdabot> Num t => t
00:46:35 <dmwit> Are you asking if there is a typeclass like `Num` for types that don't support e.g. `negate`/`abs`/`signum`?
00:47:05 <sanett> no... I was only curious if haskell distinguishes between signed and unsigned integers
00:47:19 <EvanR> Integer is signed, Natural is not
00:47:19 <dmwit> > -10 :: Word64
00:47:21 <lambdabot>  18446744073709551606
00:47:26 <dmwit> > -10 :: Int64
00:47:28 <lambdabot>  -10
00:47:41 <EvanR> there are a lot of numeric types in haskell
00:49:00 <dmwit> (You might like the numeric-prelude package to answer the other question about a class for things which don't support negation.)
00:49:57 <dmwit> Oh, neat, \bot has Numeric.Natural loaded by default.
00:50:00 <dmwit> > -10 :: Natural
00:50:02 <lambdabot>  *Exception: Natural: (-)
00:50:15 <dmwit> > -10 :: Integer
00:50:18 <lambdabot>  -10
00:50:28 <dmwit> > 2^128 :: Natural
00:50:31 <lambdabot>  *Exception: stack overflow
00:50:54 <dmwit> ...huh.
00:51:25 <sanett> um... that works on my device
00:51:29 <sanett> no exception was thrown
00:51:47 <dmwit> Indeed. And here. Also 2^128 works fine in \bot.
00:51:50 <dmwit> I wonder what's going on.
00:54:31 <dmwit> Even 2^20 :: Natural stack overflows.
01:05:32 <EvanR> > even 2^20 :: Natural
01:05:34 <lambdabot>  error:
01:05:35 <lambdabot>      • Couldn't match expected type ‘Natural’ with actual type ‘Bool’
01:05:35 <lambdabot>      • In the expression: even 2 ^ 20 :: Natural
01:05:39 <EvanR> you tricked me
01:05:46 <EvanR> > even (2^20 :: Natural)
01:05:48 <lambdabot>  True
01:05:54 <dmwit> wut
01:06:01 <dmwit> > 2^20 :: Natural
01:06:03 <lambdabot>  *Exception: stack overflow
01:06:06 <dmwit> WUT
01:06:32 <dmwit> ...perhaps this is not Numeric.Natural.
01:06:32 <EvanR> purely functional?
01:06:55 <EvanR> oh hmm
01:07:13 <dmwit> > printf "%d" (0 :: Natural) :: String
01:07:17 <lambdabot>  error:
01:07:17 <lambdabot>      • No instance for (PrintfArg Natural)
01:07:17 <lambdabot>          arising from a use of ‘printf’
01:07:23 <dmwit> Okay, this is not Numeric.Natural.
01:07:26 <Freundlich> One thing that comes to mind is that "even" should be tail-recursive while "show" isn't.
01:07:26 <EvanR> maybe lambda was upgraded and this is an unary
01:07:42 <Freundlich> Does this explain the behavior though?
01:07:43 <dmwit> right
01:08:13 <EvanR> > even (2^128 :: Natural)
01:08:23 <lambdabot>  mueval: ExitFailure 1
01:08:23 * EvanR waits
01:08:42 <EvanR> i want Numeric.Natural back
01:09:26 <dmwit> > infinity :: Natural
01:09:28 <lambdabot>  *Exception: stack overflow
01:09:46 <dmwit> This is Data.Number.Natural from the numbers package. It's unary indeed.
01:10:44 <dmwit> > 2^20 :: N.Natural
01:10:46 <lambdabot>  1048576
01:10:50 <dmwit> > 2^128 :: N.Natural
01:10:52 <lambdabot>  340282366920938463463374607431768211456
01:11:16 <dmwit> I have ?let import qualified Numeric.Natural as N. Enjoy until somebody ?undefine's it. =)
01:11:27 <dmwit> > -10 :: N.Natural
01:11:28 <EvanR> screw that
01:11:29 <lambdabot>  *Exception: arithmetic underflow
01:12:12 <EvanR> is there some point to Data.Number.Natural
01:12:30 <dmwit> yes
01:12:36 <dmwit> > genericLength [1..] > (3 :: Natural)
01:12:38 <lambdabot>  True
01:13:31 <EvanR> > 1 + infinity
01:13:32 <meretrix> If my application is taking significantly longer (25x) to run with profiling enabled, do you think the relative cost-center breakdown will still be valid?
01:13:32 <lambdabot>  *Exception: stack overflow
01:13:52 <dmwit> Of course you can also write `not . null . drop 3` but where's the fun in that?
01:14:35 <dmwit> meretrix: I think so, yes. Profiling does make things take much longer. 25x seems pretty excessive, though; have you annotated an unusually large amount of cost centers?
01:16:07 <meretrix> dmwit: No, I just used the default stack --profile
01:16:29 <meretrix> The huge increase in time occurred when I switch some list types to Vector.
01:16:41 <osa1> meretrix: try adding cost centers manually
01:17:01 <meretrix> It's reporting the longest running cost center as:
01:17:03 <meretrix> >>=                          Data.Vector.Fusion.Util
01:17:16 <dmwit> Hm. Although I don't have much experience with it, I suppose having a cost center annotation could interfere with fusion or similar optimizations.
01:17:21 <meretrix> which seems strange.. almost like profiling broke some kind of Vector optimization
01:17:29 <dmwit> ...yeah =)
01:17:39 <meretrix> ok, so manual cost centers then 
01:17:40 <meretrix> thanks
01:20:09 <meretrix> yeah, just saw this:
01:20:11 <meretrix> https://ghc.haskell.org/trac/ghc/ticket/12893
01:20:23 <osa1> in PVP there isn't a rule that requires bumping A, right?
01:21:00 <osa1> meretrix: usually (at least in my case), numbers from libraries are not too useful
01:21:16 <dmwit> osa1: Right. A.B is treated as one whole unit for the purposes of PVP.
01:21:16 <osa1> meretrix: so I add cost centers manually to important parts of my program
01:21:29 <osa1> dmwit: thanks. so when to bump A is rather arbitrary
01:21:41 <dmwit> Bump A when "something big" changes.
01:22:02 <dmwit> so yes =)
01:22:39 <osa1> meretrix: it also avoids this kind of problems. cost centers sometimes get in the way of optimizations that GHC's simplifier does
01:42:19 <tsahyt> I'm trying to trace down a segfault in those C bindings. It does occur when I write foo >>= \h -> bar h quux, but not when I write bar <$> foo <*> pure h. So I'm wondering, what's the difference here really?
01:42:39 <tsahyt> erm, pure quux
01:42:55 <tsahyt> there must be some difference in execution ordering or something, otherwise they should behave identically
01:42:56 <ezyang> one uses Monad, other uses Applicative 
01:43:03 <ezyang> you could have different impls 
01:43:37 <dmwit> um
01:43:38 <tsahyt> ezyang: the monad I'm in is just a ReaderT Stuff IO in a newtype wrapper. I use GND for deriving Monad and Applicative instances
01:43:45 <dmwit> Those two things don't even have the same type, do they?
01:44:17 <ezyang> oh yeah, also what dmwit said 
01:44:23 <dmwit> The latter just returns `bar`'s effects, it doesn't execute them.
01:45:03 <tsahyt> why, why?
01:45:15 <tsahyt> let me see
01:45:43 <tsahyt> you're right, it's m (m ())
01:45:44 <dmwit> There is no Applicative version of `foo >>= \h -> bar h quux`.
01:45:56 <tsahyt> at least that explains why it doesn't crash, because nothing actually happens
01:46:13 <tsahyt> I need more caffeine it seems. so at least the bug is not as weird as it looked at first
01:51:15 <boxscape> hi, I just cloned a OpenGL tutorial repo and am trying to execute it using `stack runghc'. However, stack complains that it's ambiguous because I installed both GLFW and GLFW-b. I know I can tell stack to use a package with --package GLFW-b, but if I do that, stack still complains that it's ambiguous. Is there some easy way (without putting the whole thing into a stack project) to tell stack that it shouldn't use the other packag
01:51:16 <boxscape> the other package, since I don't need it)
01:52:37 <lyxia> is it ambiguous because the packages export the same module names?
01:52:51 <boxscape> yes
01:53:15 <lyxia> there is an extension you can use to annotate modules with the package they come from.
01:53:25 <boxscape> ah, I see, I'll take a look, thanks
01:53:36 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
01:53:41 <boxscape> thanks
01:54:25 <lyxia> yw
02:58:31 <osa1> how do you people solve this problem: a dependency has too strict dependency bounds, but I still want to get it from Hackage (e.g. can't install a fork). I can't use --allow-newer because that effects all dependencies and the main package too
02:59:28 <ezyang> osa1: --allow-newer lets you zero in on a specific package bound 
03:00:15 <osa1> WOW I've been using this for years and only now I realied it accepts a dependency argument (--allow-newer=base)
03:00:20 <osa1> err
03:00:25 <osa1> --allow-newer=dep
03:00:27 <ezyang> http://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=allow-newer#cmdoption-setup-configure--allow-newer 
03:00:40 <ezyang> you can also instruct it to relax a specific dep 
03:01:21 <osa1> ezyang: awesome, thanks
03:17:08 <xenon-> any emacs users around? i've been trying to get argument types hints when typing function name in a buffer and ghci, but without much luck. I have ghc-mod and haskell-mode installed and running, and i am not which mode is supposed to provide that functionality
03:19:43 <cloudhead> is there a typeclass I can use for indexable types? Such as [] and Vector?
03:20:34 <mpickering> cloudhead: What do you want it to do?
03:21:04 <cloudhead> mpickering: all I need is a function `:: Int -> Maybe a` on it
03:21:30 <cloudhead> I need to cycle it also ideally, but I can also use a modulo of the length instead
03:21:57 <mpickering> What does this function do?
03:22:11 <cloudhead> just returns the element at a certain index
03:22:12 <xenon-> ASRock Z97 Extreme3
03:22:15 <xenon-> wops
03:22:36 <mpickering> oh I see now
03:22:37 <cloudhead> so like `!?` for Vector
03:22:47 <mpickering> I thought you were talking about "Indexed" data types 
03:23:03 <cloudhead> oh no no
03:23:54 <mpickering> I think the modern way would be to use something from Lens
03:24:20 <cloudhead> hmm I see
03:24:28 <cloudhead> I avoid lens usually
03:24:30 <mpickering> https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-At.html
03:24:56 <cloudhead> ah yes, I remember this
03:25:35 <cloudhead> yeah I guess I want something like Ixed
03:27:23 <mpickering> why do you avoid lens usually? 
03:27:41 <cloudhead> I find it pretty unreadable
03:28:13 <mpickering> I tend not to use any of the infix operators as I can't remember the names of any of them
03:28:20 <xenon-> it is pretty readable if you stick to named functions
03:28:23 <cloudhead> and incredibly complex for what I get out of it
03:28:37 <cloudhead> yeah I think the operators are part of that problem
03:29:05 <mpickering> I often think about releasing a cut down version with all the essential ideas to show how it isn't too complicated 
03:29:08 <xenon-> it is rather heavy though, so i avoid it unless i really need it
03:29:25 <cloudhead> yeah
03:29:32 <cloudhead> there's micro-lens which I considered using once
03:29:47 <cloudhead> 'microlens' actually
03:29:56 <mpickering> Which doesn't have prisms or isomorphisms 
03:30:03 <Tuplanolla> My problem with `lens` is packages that depend on it and thus take a few hours longer to install.
03:30:08 <cloudhead> ah I see
03:30:14 <cloudhead> yes and that ^
03:30:34 <liste> few hours? wow
03:30:38 <mpickering> also I don't think that's really true, it only has 40 rev deps 
03:30:44 <mpickering> which are common base packages
03:31:11 <mpickering> if you use stack or new-build you compile them once and you're done forever
03:31:14 <mpickering> or nix
03:31:26 <Tuplanolla> I don't, yet.
03:31:28 <mpickering> xenon-: What do you find "heavy" about the package? 
03:31:36 <cloudhead> my concern is more that there are too many options
03:31:43 <xenon-> mpickering a lot of dependencies. a lot of things to download and compile
03:31:49 <cloudhead> it's a big toolbox
03:31:51 <mpickering> cloudhead: That is true
03:31:58 <mpickering> There is too much surface area 
03:32:32 <cloudhead> so if you introduce it in a project, you're essentially saying, 'hey, use anything from this package if it's helpful'
03:32:54 <cloudhead> so a small subset sounds more appealing
03:34:33 <cloudhead> my main use case was first-class setters though, and it looks like that's coming in GHC soon
03:35:30 <mpickering> I don't think so?
03:36:06 <cloudhead> isn't it?
03:37:35 <cloudhead> I think this is what I'm referring to https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/MagicClasses
03:38:32 <xenon-> did open/extensible data come already? i remember there were several suggestions for that a year ago
03:38:38 <xenon-> data types
03:39:08 <mpickering> The language is getting so complicated now
03:40:33 <cloudhead> thank god for the extensions system :p
03:41:33 <xenon-> what about open data types? is there already an extension for that
03:42:29 <mpickering> No
03:42:44 <mpickering> You mean being able to define new constructors for datatypes in different modules?
03:46:01 <cloudhead> there's PatternSynonyms which can do 'open enums' but that's about it afaik
03:46:06 <xenon-> mpickering yes
03:46:38 <xenon-> also, a different issue.. several data types sharing the same field names.. is that a thing already
03:46:52 <cloudhead> yeah that's DuplicateRecordFields
03:47:01 <cloudhead> not super useful in its current form though
03:47:09 <xenon-> why not
03:47:12 <cloudhead> but it works
03:47:28 <cloudhead> well, you still get ambiguities in many cases
03:47:36 <cloudhead> ie: you have to use a type annotation when using getters sometimes
03:48:48 <cloudhead> since they aren't technically polymorphic yet (the getters)
03:48:52 <cloudhead> I forget the exact details
03:48:58 <cloudhead> but it "works"
03:49:31 <cloudhead> I think it'll really come together when the whole overhaul of the record system is done though
03:52:04 <Profpatsch> How do I catch InvalidArgument Exceptions from https://hackage.haskell.org/package/directory-1.3.0.0/docs/System-Directory.html#v:createDirectory
03:52:18 <Profpatsch> And how do I get the error message from that?
03:52:29 <Profpatsch> It’s not at all clear from the documentation.
03:55:10 <lyxia> Profpatsch: Control.Exception
03:56:43 <Profpatsch> lyxia: I know how that works. But I’m asking about that error especially.
03:56:54 <mniip> bgamari, I've pushed finite-typelits-0.1.1.0, fyi
03:57:09 <Profpatsch> How would I catch it and extract the error message?
03:58:06 <lyxia> Oh.
04:04:20 <lyxia> Profpatsch: It's an IOError, from System.IO.Error in base
04:04:43 <lyxia> The constructor is hidden, but probably you can find it in a GHC.IO module
04:04:56 <Profpatsch> lyxia: Are you sure? It’s not listed anywhere.
04:05:48 <lyxia> Profpatsch: IOError = IOException contains an IOErrorType
04:06:00 <lyxia> So actually InvalidArgument is a constructor of IOErrorType
04:06:17 <Profpatsch> So it’s not expected that I catch it?
04:07:20 <tsahyt> is there any way to get some more information out of GHC 8's call stack feature?
04:08:04 <tsahyt> I'm reaching a case that should be impossible under normal circumstances (i.e. nonrecoverable) and abort with error. Now I get the line where error was called, but that's about it. can I see the rest of the "stack" somehow?
04:08:55 <tsahyt> oh I think I need -prof
04:09:25 <Profpatsch> tsahyt: Be aware that means all dependencies have to be compiled with -prof as well.
04:09:34 <tsahyt> Profpatsch: stack should be able to handle that
04:09:58 <tsahyt> at least it usually does
04:10:59 <tsahyt> do I need to be in ghci for this or can I get it during normal execution as well?
04:11:43 <Profpatsch> +RTS *something* -RTS
04:11:46 <Nik05> @bot
04:11:46 <lambdabot> :)
04:13:15 <tsahyt> okay this didn't really give me much more usable information
04:13:21 <Profpatsch> lyxia: https://ghc.haskell.org/trac/ghc/ticket/1868
04:13:36 <tsahyt> but good to know anyhow
04:13:51 <Profpatsch> It’s kind of funny that it’s apparently impossible to catch all IO errors on GHC.
04:16:01 <maerwald> yeah, exceptions are a mess in general in GHC
04:16:57 <Profpatsch> maerwald: What would you try to catch for createDirectoryIfMissing?
04:18:08 <maerwald> Profpatsch: I don't use the directory package, because I consider it dangerous. I interface with POSIX functions
04:18:47 <Profpatsch> Obviously not HardwareFault or ResourceExhausted. But not handling InappropriateType or InvalidArgument seems negligent.
04:18:59 <Profpatsch> maerwald: How would that look? FFI?
04:19:11 <Profpatsch> maerwald: Also, why do you consider it dangerous?
04:19:40 <maerwald> because it tries to be cross-platform, without that being sensible
04:20:32 <Profpatsch> Well, my program should be cross-platform (Windows and Linux).
04:20:48 <maerwald> then you have to code that properly
04:20:53 <Profpatsch> So maybe it’s okay to use that module and just hope for the best.
04:21:01 <maerwald> that's exactly what you should not do
04:21:15 <Profpatsch> maerwald: What means “coding it properly”?
04:21:22 <Profpatsch> Not using the base library?
04:21:40 <maerwald> file system handling is about _details_, if you abstract wrongly over those details (partly because there is no sensible abstraction), then you intrudoce semi-defined behavior
04:22:09 <Profpatsch> maerwald: So you would litter your code with #ifdefs instead?
04:22:11 <maerwald> that includes canonicalizePath, symlink behavior, ...
04:23:03 <maerwald> Profpatsch: I haven't thought about an actual architecture design, littering everything with #ifdefs might be the most straight-forward solution
04:23:35 <maerwald> you really have to know the differences and think in every file-handling function about what can go wrong where on which platform
04:24:00 <maerwald> the directory package doesn't even properly document possible exceptions
04:25:36 <Profpatsch> maerwald: Can I even create directories without that module?
04:25:42 <Profpatsch> Without resorting to FFi?
04:25:48 <maerwald> ofc, you use the low-level package like posix
04:26:05 <maerwald> I don't do windows coding, so I don't know which package that would be
04:26:28 <Profpatsch> I don’t think there is a package like that.
04:26:44 <maerwald> @hackage unix
04:26:45 <lambdabot> http://hackage.haskell.org/package/unix
04:26:46 <Profpatsch> Also, if you use posix you have exactly the same problem.
04:26:47 <maerwald> @hackage Win32
04:26:47 <lambdabot> http://hackage.haskell.org/package/Win32
04:27:07 <maerwald> Profpatsch: no
04:28:33 <Profpatsch> The Win32 module is just a thin FFI wrapper, with no documentation.
04:28:53 <maerwald> if it's a wrapper, you look at the original documentation
04:29:07 <Profpatsch> true
04:29:38 <Profpatsch> So System.Directory it is.
04:32:01 <maerwald> sure, if one doesn't care about correctness, safety or even security that might be a good choice
04:33:35 <Tuplanolla> @google all file systems are not created equal
04:33:47 <Profpatsch> that’s just, like, your opinion man
04:33:50 <lambdabot> Plugin `search' failed with: <<timeout>>
04:33:53 <Tuplanolla> :t lambdabot
04:33:55 <lambdabot> error: Variable not in scope: lambdabot
04:36:20 <maerwald> Profpatsch: well, I find it alarming that so few people care about "reasoning about code" and "correctness" in some areas, although that's what we thought haskell is about. But those principles are often only followed if they are in line with "abstraction" and "high-level". Except that's not always the case.
04:37:05 <Tuplanolla> Take a look at that paper lambdabot failed to find, Profpatsch.
04:38:05 <maerwald> just by looking at the function documentation of canonicalizePath should tell you you'll never be able to reason about that function properly
04:38:40 <maerwald> even less so cross-platform
04:39:43 <Profpatsch> maerwald: What about getXdgDirectory?
04:40:22 <maerwald> I don't understand the question
04:40:35 <Profpatsch> Can you reason about the correctness of that function?
04:42:31 <maerwald> Profpatsch: does windows follow the xdg specification?
04:42:55 <maerwald> afais this is just some random guesswork, mapping xdg variables to windows variables
04:43:03 <maerwald> so you have a hybrid again, not following the spec
04:43:56 <Profpatsch> Does it have to, if my usage is “give me a place where I can put my config file”
04:45:24 <maerwald> I don't know, depends on the context etc. But the 'directory' implementation doesn't follow the spec, because it makes it's own assumptions, which is by definition already an attack surface (other applications might do things differently, since there's no spec about what to do)
04:45:25 <Profpatsch> And maybe after calling that function I can be reasonably sure that creating a folder with an ascii name and an ascii file in that will work.
04:45:57 <Profpatsch> Of course I will check for permission errors.
04:46:48 <Profpatsch> But at least I can expect it to not throw InvalidArgument errors.
04:47:37 <Profpatsch> Or course I’d have a problem if there is no space left, since I cannot catch ResourceExhausted errors.
04:47:51 <maerwald> writing an application that works reliably on both linux and windows is _hard_. I think the haskell ecosystem only got away with that hackery, because it's rarely used in system programming
04:49:23 * kuribas wants to write a GUI app for mac/linux/windows
04:50:01 <Profpatsch> If I wanted to have *correctness*, I’d have to write a C function that correctly handles OutOfMemory situations and returns a custom error code.
04:50:20 <maerwald> kuribas: make it 3 projects :P
04:50:39 <Profpatsch> But to be fair: How many C programs check *any* of their writes for OOM errors?
04:50:42 <kuribas> maerwald: I want to use wxHaskell
04:50:44 <Profpatsch> 2%? 3%?
04:50:57 <Profpatsch> kuribas: Have fun.
04:51:00 <kuribas> Though I find it a bit limiting...
04:51:11 <Profpatsch> I’d go with a web application if I were you.
04:51:44 <Profpatsch> The POSIX interface is basically a bad joke that doesn’t give you a lot of correctness.
04:51:48 <kuribas> Profpatsch: no, a proper GUI is better than a web app kludge.
04:51:59 <Profpatsch> And I don’t even want to know about Win32.
04:52:16 <Profpatsch> kuribas: What on earth is a proper GUI.
04:52:24 <Profpatsch> I haven’t seen one in my lifetime.
04:52:30 <zomg> Considering how many GUI toolkits are garbage I'm not sure if they're any less a kludge than a web app :D
04:52:45 <kuribas> Profpatsch: using the native widgets.
04:52:48 <Profpatsch> zomg: You mean any one of them?
04:53:11 <Profpatsch> Except maybe the GUI toolkit defined by W3C … wait.
04:53:13 <maerwald> the web is broken :P
04:53:36 <Profpatsch> kuribas: Then have fun writing Obj-C wrappers for Cocoa.
04:53:40 <kuribas> A webapp is like forcing a stateful app on a stateless protocol.
04:53:44 <zomg> Do any GUI toolkits even really use the native controls for anything if you do cross-OS stuff
04:53:53 <Profpatsch> kuribas: It’s exactly like that.
04:53:58 <kuribas> Profpatsch: that's what wxhaskell does.
04:54:09 <kuribas> zomg: yeah, wxWidgets does.
04:54:17 <zomg> oh I see
04:54:23 <Profpatsch> kuribas: It’s the same problem as with System.Directory.
04:54:31 <zomg> usually whenever there's some cross-OS app it just has its custom UI chrome everywhere :)
04:54:42 <Profpatsch> It generalizes over the toolkits, so you lose the power of all of them.
04:54:47 <zomg> it ends up looking different than you'd expect from the host OS but at least it'll look the same on different OS's (mostly)
04:54:49 <Profpatsch> And probably correctness as well.
04:55:38 <Profpatsch> kuribas: Be prepared to generate the haskell wrappers for the current wxWidgets versions yourself, though.
04:55:46 <Profpatsch> They haven’t been updated in ages.
04:56:04 <Profpatsch> And when I last looked there was no good documentation on how to do it.
04:56:19 <kuribas> Profpatsch: last updates on wxHaskell are a few months old.
04:56:25 <maerwald> well, wxWidgets is ok-ish and it's just GUI after all
04:56:35 <maerwald> not something to worry too much about
04:57:05 <kuribas> It's the easiest solution I found so far.
04:57:56 <kuribas> Alternatively I could use just Gtk, and abstract all the GUI stuff out.  Then port it to Win32/Cocoa.
04:58:03 <kuribas> But that seems more work.
04:59:06 <maerwald> yeah, and if the GUI doesn't behave correctly 100%, so what
04:59:30 <kuribas> maerwald: right :)
04:59:39 <maerwald> ofc, if you mix up "Ok" and "Cancel", it might be surprising xD
04:59:53 <maerwald> "remove all data?" -> "Cancel" -> err wat
05:00:51 <kuribas> maerwald: I suspect I might be more like toolbars being not exactly in the same space, and maybe different keybindings.
05:00:58 <kuribas> But that can probably be fixed.
05:01:09 <maerwald> yeah
05:01:26 <kuribas> At least wxWidgets uses the "apple menu".
05:01:51 <kuribas> And native widgets, it doesn't "emulate" them, like gtk for example.
05:15:53 <xenon-> any emacs users around? i've been trying to get argument types hints when typing function name in a buffer and ghci, but without much luck. I have ghc-mod and haskell-mode installed and running, and i am not which mode is supposed to provide that functionality
05:24:15 <kuribas> xenon-: try #haskell-emacs
05:25:13 <gameer> Hey Guys. How can I split for example A5 in a tuple (A,5)?
05:26:08 <maerwald> what type is A5?
05:26:36 <jhrcek> Say I have the following code: mconcat [("a"++),("b"++)] $ ""
05:26:43 <jhrcek> How do I know which instance of Monoid was used?
05:27:37 <kuribas> :t mconcat
05:27:38 <lambdabot> Monoid a => [a] -> a
05:28:39 <gameer> maerwald: I wanted to solve as an exercise the first Task from adventofcode and I thought that it is a good way to have a List with Tupels: [(R,3),(L5),...]. Cause then I could iterate with x:xs over the list and get with fst/snd the both thinks of each tuple
05:28:42 <kuribas> > mconcat [("a"++),("b"++)] $ ""
05:28:44 <lambdabot>  "ab"
05:29:02 <kuribas> gameer: I'd say ((->) String)
05:29:19 <maerwald> I still don't know what type A5 is
05:29:50 <gameer> A string I think
05:30:18 <Tuplanolla> It's `Monoid b => Monoid (a -> b)` actually, kuribas and jhrcek.
05:31:04 <kuribas> Tuplanolla: is that sort of a reader monoid?
05:31:12 <zoran119_> i'd like to read a comma separated list of integers from stdin, giving the user a nice error message if parsing fails. what's the right way to do this?
05:31:14 <kuribas> > mconcat [("a"++),("b"++)] $ "r"
05:31:15 <lambdabot>  "arbr"
05:31:26 <Tuplanolla> Kind of, kuribas.
05:31:45 <Tuplanolla> The other common one is `Endo`.
05:31:50 <zoran119_> i'm doing ints <- fmap (map (\x -> read x :: Int) . words) $ getLine
05:31:57 <kuribas> Tuplanolla: it seems like it...
05:32:25 <zoran119_> but not sure how to handle parsing failures, or if that's a good way to go about it
05:33:30 <Tuplanolla> Use `readMaybe` or a proper parser, zoran119_.
05:33:48 <kuribas> > appEndo (mconcat (map Endo [("a"++),("b"++)])) "r"
05:33:50 <lambdabot>  "abr"
05:34:32 <jhrcek> Tuplanolla kuribas: i'm actually looking for efficient way to  concatenate list of ShowS values, so the Endo seems like what I wanted
05:34:49 <kuribas> jhrcek: use concat?
05:34:54 <kuribas> :t concat
05:34:56 <lambdabot> Foldable t => t [a] -> [a]
05:35:02 <Tuplanolla> Yes, use `Endo`, jhrcek.
05:35:42 <Tuplanolla> It's the same as folding with `.`.
05:35:55 <jhrcek> Tuplanolla: got it. Thanks
05:36:28 <Tuplanolla> > foldr (.) id [("a" ++), ("b" ++)] "r"
05:36:30 <lambdabot>  "abr"
05:37:53 <mniip> is it possible to infer "m ~ 1 + n" from "not (m ~ 0)"
05:39:58 <Profpatsch> Argh, I have no idea how to work with IOExceptions.
05:40:13 <maerwald> Profpatsch: :(
05:40:20 <Profpatsch> e.g. if I write a function writeConfig :: Config -> IO ()
05:41:17 <Profpatsch> writeConfig = withConfigFileBinary WriteMode . BL.hPut . encode
05:41:34 <Profpatsch> That will possibly throw errors for:
05:41:42 <Profpatsch> 1) creating the config folder
05:41:55 <Profpatsch> 2) opening the config file
05:42:03 <Profpatsch> 3) writing to the config
05:42:08 <Profpatsch> And possibly a few others.
05:42:13 <Profpatsch> (Who knows which)
05:42:33 <maerwald> yeah, the question now is, where do you use this functions and do you need to take different actions depending on the failure?
05:42:59 <Profpatsch> Without understanding the recursive definitions of all functions I’m using I cannot ever know what errors this function can throw, right?
05:43:14 <Profpatsch> It could be every error in this universe.
05:43:18 <maerwald> GHC doesn't assist you with knowing that, you have to investigate it yourself
05:43:26 <maerwald> which is also another reason exceptions in GHC are annoying
05:43:36 <Profpatsch> Checked Exceptions are the one thing Java does right.
05:44:08 <maerwald> yeah, but now everyone uses Unchecked Exceptions there :P
05:44:16 <Profpatsch> And most functions don’t even document what errors they could throw.
05:44:22 <maerwald> I do :P
05:44:34 <maerwald> I even test the exceptions in the test suite
05:44:39 <Tuplanolla> If you need complete error tolerance, Haskell won't be enough. You can't, for example, catch EIO in many circumstances, Profpatsch.
05:44:48 <Profpatsch> e.g. what does BL.hPut throw?
05:44:56 <Profpatsch> And why isn’t it documented anywhere?
05:45:29 <Tuplanolla> The exact set of error conditions depends on the operating system and its support libraries.
05:46:24 <Profpatsch> So should I assume a function that doesn’t list errors shouldn’t throw in practice?
05:46:29 <maerwald> haha
05:46:36 <Profpatsch> e.g. hPut will never throw or it’s a bug?
05:46:45 <Profpatsch> Well, there has to be *some* sanity.
05:46:51 <maerwald> don't assume that 
05:47:03 <Profpatsch> But is it a bug if hPut throws without documenting it?
05:47:23 <Profpatsch> Or should I as programmer just know about it?
05:48:13 <Profpatsch> I just don’t know where the guarantees lie.
05:48:45 <Profpatsch> e.g. for out of memory I’d expect the kernel to handle that before it reaches my program.
05:49:02 <Profpatsch> e.g. by killing my program.
05:49:14 <maerwald> that sounds like an attack vector :)
05:49:33 <Tuplanolla> This is a consequence of the laziness of the library's author.
05:49:36 <Profpatsch> In that case it’s an attack vector on the kernel.
05:49:42 <Profpatsch> Not on my program.
05:49:47 <Tuplanolla> Take a look at the error conditions of rename for example: https://linux.die.net/man/2/rename
05:49:52 <Profpatsch> And that’s a very important difference.
05:50:12 <maerwald> Profpatsch: no, it's a potential attack vector on any program
05:50:31 <Profpatsch> Tuplanolla: We all know that POSIX is extremely braindead.
05:50:51 <Profpatsch> Throwing every possible error at the user because worse is better.
05:51:06 <Profpatsch> And Linux just follows that bad example.
05:51:19 <Profpatsch> And everybody hopes nothing bad happens.
05:51:36 <Profpatsch> I mean ENOMEM, wtf.
05:51:58 <Tuplanolla> Can't build a castle out of toothpicks.
05:52:12 <Profpatsch> Well, of course you can.
05:52:28 <Profpatsch> Just look at the operating system that runs your IRC client.
05:52:34 <Profpatsch> And then look at your IRC client.
05:52:36 <maerwald> Profpatsch: you can even get ENOMEM for malloc :D most people don't check for it
05:53:00 <Profpatsch> Somehow everything just _doesn’t_ explode constantly, and I have no idea.
05:53:23 <Tuplanolla> I have the opposite experience.
05:53:44 <Profpatsch> Of course it burns everywhere, but it doesn’t explode.
05:53:51 <Profpatsch> Even though it totally should.
05:53:57 <kuribas> The worst is that allocation never fails.
05:54:37 <kuribas> Yeah, it's better to grind the whole system to a halt, rather than refuse an app memory that isn't there.
05:54:52 <maerwald> Profpatsch: the solutions are hard, I mean... people still think regex and escaping is a valid solution to SQL injection
05:54:57 <Tuplanolla> @google gunshow on fire
05:54:59 <lambdabot> http://gunshowcomic.com/648
05:54:59 <lambdabot> Title: Gunshow - On Fire
05:55:28 <kuribas> maerwald: does malloc ever return ENOMEM?
05:55:40 <mniip> malloc returns NULL
05:55:44 <maerwald> no, it sets errno to ENOMEM
05:55:51 <maerwald> as mniip said
05:56:20 <kuribas> But does that ever occur?
05:56:26 <mniip> tbf in my whole history of C programming I've never checked malloc's errno
05:56:44 <maerwald> the point is, NULL can also be returned on success
05:57:02 <mniip> not sure about errno, but malloc can indeed return NULL
05:57:33 <kuribas> if there is no memory, the OOM killer just kills an app.
05:57:58 <maerwald> kuribas: but when exactly... race conditions incoming
05:57:59 <xenon-> would not returning null when failing to allocate memory and setting errno instead be standard compliant implementation of malloc?
05:58:06 <mniip> kuribas, not necessarily
05:58:22 <mniip> kuribas, if a process has a memory limit
05:58:40 <mniip> malloc will return NULL and set errno to whatever stands for "Cannot allocate memory" in strerror
05:58:50 <mniip> just tested it
05:59:15 <kuribas> mniip: that makes sense
06:01:49 <Profpatsch> mniip: And when you try to write to NULL you segfault?
06:01:54 <mniip> depends
06:02:13 <mniip> if 0x0 is not mapped like it usually is then yes
06:02:21 <Profpatsch> Right, the answer to C/POSIX questions is always “depends”
06:02:28 <mniip> in, for example, tcc/libtcc, the 0 page is mapped
06:02:56 <xenon-> and writing to null does what?
06:02:58 <p_implies_q> Need some advice
06:03:15 <mniip> oops there goes matrix
06:03:18 <mniip> xenon-, if it is mapped it is like any other address
06:03:18 <maerwald> xenon-: segfault? xD
06:03:41 <maerwald> that would be funny
06:03:45 <xenon-> so it hides the bug, possibly causing data corruption, while the user things everything is fine and dandy
06:03:52 <xenon-> wonderful
06:03:57 <mniip> xenon-, do you know what TCC is?
06:04:26 <mniip> tiny C compiler, a compiler capable of interpreting C code at runtime
06:04:49 <mniip> writing to null is a common cause of segfault, and it'd be better if tcc did not end up SIGSEGV'd because of the code it ran
06:05:37 <p_implies_q> I want to manipulate strings that have different colors for different bits of the string, like rich text basically. I was thinking of just creating a ColoredSegment data type with a string and color attribute, and then making ColoredStrings be lists of these segments. Is there a more elegant or accepted way to work with this kind of "tagged data" that I am unaware of?
06:05:59 <xenon-> it would be better if it caused segfault, would discourage people from doing silly things, such as using C as a scripting language
06:06:08 <mniip> shrug
06:06:27 <hodapp> never knew that many people were on matrix
06:06:30 <mniip> it is useful for introspecting C programs
06:06:51 <mniip> otherwise you have to use the ffi facilities of your language which is a lot of boilerplate
06:12:16 <kuribas> p_implies_q: that may work.   Alternatively you can use a map from regions to attributes.
06:12:36 <f-a> hello, I am not sure what do do regarding this dependency problem (cabal) http://hastebin.com/xokomuvito.rb
06:13:16 <f-a> apparently it requires 1.8 to be installed when the most updated version on hackage is 0.14.*. What causes this?
06:13:19 <kuribas> f-a: did you install webkitgtk?
06:13:31 <f-a> oh, not the haskell pagace, silly my
06:14:31 <f-a> thanks kuribas 
06:14:38 <kuribas> f-a: np
06:21:53 <p_implies_q> kuribas: Thanks. I was hoping for some kind of "Decorated data" functor that I could substitute for my ColoredSegment AGD, but I guess I just have to write some code :-)
06:23:03 <kuribas> this may be usefull as well: https://hackage.haskell.org/package/rope
06:23:15 <kuribas> Doesn't seem to be actively maintained though...
06:23:39 <p_implies_q> kuribas: Thanks for the headsup. Always good to look at how other people solve similar problems
06:24:32 <p_implies_q> kuribas: actually, thanks a great deal! This gave me the moment of insight I needed :-)
06:31:24 <AndreasK> -O2 is still considered safe right?
06:32:31 <maerwald> not sure if that has ever been validated
06:32:48 <AndreasK> If so i might have found a counterexample :x
06:34:57 <maerwald> we need proof
06:39:13 <AndreasK> Yeah i'm working on reducing the example.
06:39:54 <AndreasK> I iterate over a state and -O2 seems to cause exponential slowdown with each iteration
06:40:13 <AndreasK> Doesn't seem to be leaking memory though
06:40:47 <Profpatsch> IO (Either ErrorType a) or ExceptT ErrorType IO a?
06:40:52 <slack1256> for record syntax, is it neccesary that *all* fields must have a record?
06:41:01 <Profpatsch> Or something else entirely?
06:41:10 <slack1256> I just want a record for a single field (for update syntax)
06:41:11 <maerwald> AndreasK: I was expecting that the semantics of your program changes. Performance differences are to be expected anyway (for better or worse
06:41:14 <Profpatsch> Make ErrorType an Exception?
06:42:30 <AndreasK> maerwald: Well if i would take the result after 100 iterations at the rate it slows down with -O2 i expect it to take until the heat death of the universe
06:42:50 <AndreasK> So thats pretty close to bottom xD
06:42:50 <maerwald> Profpatsch: personally, I don't particularly like "IO (Either ErrorType a)". That's what "try" is for anyway
06:42:56 <maerwald> :t try
06:42:58 <lambdabot> Exception e => IO a -> IO (Either e a)
06:44:24 <maerwald> AndreasK: mh, haven't thought about whether time complexity is part of "program semantics"
06:44:29 <Profpatsch> So instance Exception ErrorType?
06:44:59 <AndreasK> Well even if it's not broken in terms of referential transparancy it's definitly broken in terms of people can't use it that way
06:45:23 <Profpatsch> Then I’m guilty of creating unchecked exceptions as well oO
06:48:02 <gehmehgeh> ARRRRRRRRRRRRRRRRRRR.
06:48:09 <Profpatsch> You are a pirate!
06:48:18 <maerwald> everyone run
06:48:32 <kuribas> slack1256: yes
06:48:55 <AndreasK> I would expect it have a memory leak but it keeps using omly about 3M of ram as well
06:49:09 <AndreasK> So definitly an interesting issue no matter what causes it 
06:49:21 <kuribas> slack1256: but you can define an accessor as a normal function.
06:56:08 <kuribas> AndreasK: do you have the code?
06:56:40 <AndreasK> Yeah but still trimming out all the terrible parts i wrote which don't change the effect
06:59:02 <slack1256> kuribas: but for update syntax?
06:59:26 <slack1256> data Foo = F Int { bar :: String } isn't valid syntax
06:59:56 <slack1256> and a custom accessor, won't let me do ` foo { bar = "baz" } `
07:00:23 <kuribas> slack1256: no, that will not work.
07:00:34 <AndreasK> Seems to be something to do with Set though as it seems
07:00:36 <kuribas> idk why haskell doesn't support it...
07:06:26 <ab9rf> slack1256: why would it?
07:06:31 <ab9rf> what would it even mean?
07:07:29 <ab9rf> oh, you want records with anonymous members?
07:08:06 <ab9rf> i don't think that really adds a lot of value 
07:08:55 <ab9rf> you can alawys create a custom accessor
07:09:10 <ab9rf> Data foo { bar :: T }; baz = bar
07:09:36 <lpaste> AndreasK pasted “Memory leak at -O2” at http://lpaste.net/350028
07:09:39 <ab9rf> my shift key hates me today, but you get my point
07:11:02 <AndreasK> kuribas: Heres the code, its a memory leak that only happens at -O2. I don't think I can remove much more without it leaking: http://lpaste.net/350028
07:24:41 <kuribas> AndreasK: file a gtk bug?
07:24:51 <AndreasK> gtk?
07:24:58 <kuribas> ghc sorry
07:25:44 <c_wraith> AndreasK: out of curiousity, does it still leak if you put {-# OPTIONS_GHC -fno-full-laziness #-} at the top?
07:26:45 <c_wraith> AndreasK: the full laziness transform is the main cause of space leaks at -O2 that didn't exist before
07:27:11 <AndreasK> c_wraith: Still leaks
07:28:17 <AndreasK> Didn't know you could set ghc options that way, another thing learned
07:29:38 <c_wraith> AndreasK: it has the advantage of doing things like applying that option even when loaded in ghci
07:30:02 <c_wraith> (without specifying that option in ghci)
07:30:05 <AndreasK> Also per file basis I assume when compoling multiple files
07:30:13 <c_wraith> yes
07:32:40 <c_wraith> AndreasK: the $! on line 37 is useless - cycleWorld is already strict
07:33:49 <kuribas> AndreasK: you can remove threadDelay
07:34:09 <AndreasK> c_wraith: Thats just a relict iirc from earlier
07:34:28 <c_wraith> AndreasK: I figured it was something like that, and it's certainly not the cause of the leak.  Just a note.
07:35:47 <AndreasK> I've found a few ways to have the same logic without the leak by now. Interesting question is why that one does leak :D
07:37:19 <kuribas> AndreasK: it looks like a ghc bug.
07:38:58 <AndreasK> Sweet i wanted a reason to look around ghc internals anyway
07:39:32 <Clint> r/win 23
07:40:54 <bollu> what is the "easiest" way to get SDL2 + an openGL context up and running?
07:41:00 <bollu> (or some openGL context)
07:43:58 <AndreasK> bollu: There is a SDL2 package
07:44:25 <bollu> AndreasK: yep, I saw. but, like, does openGL + SDL2 work correcty?
07:44:29 <bollu> correctly*
07:44:32 <AndreasK> bollu: https://hackage.haskell.org/package/sdl2 it's at least reasonably eas yto get something on the screen with it. Haven't used the ogl side of it yet though
07:44:39 <bollu> okay
07:44:55 <AndreasK> bollu: Are you on windows?
07:45:56 <AndreasK> bollu: If so this worked nicely for me: https://www.reddit.com/r/haskellgamedev/comments/4jpthu/windows_sdl2_is_now_almost_painless_via_stack/
07:48:12 <yulax> haskellgamedev
07:48:20 <yulax> never knew about that!
07:48:48 <AndreasK> found it when i looked for a way to install sdl on windows don't know if its active
07:49:42 <bollu> AndreasK: nope, OSX
07:50:26 <bollu> how does the GC perform for games?
07:50:51 <ab9rf> yeah, i've managed to do a couple of simple SDL2 things using that approach
07:51:12 <bollu> neat
07:51:18 <orion> I have a steel door controlled by GPIO pins on a Raspberry Pi. To use a pin, I need to allocate it by writing the pin number to /sys/class/gpio/export. I can then write to /sys/class/gpio/gpio24/value to lock or unlock the door. After I'm done, I free the pin by writing to /sys/class/gpio/unexport.
07:51:36 <yulax> SDL2 is pretty good, once you get going
07:51:36 <orion> What libraries can help with this resource allocation? I tried resourceT, but it doesn't seem like enough.
07:51:44 <ab9rf> every few days i put a bit of time into writing a reflex sdl binding
07:51:57 <ab9rf> usually don't get very far, but meh
07:52:26 <orion> In particular, I need to allocate the same resource potentially multiple times, and only free it when the last holder exits.
07:52:28 <bollu> the "stack setup" download freezes occasionally
07:52:33 <bollu> I live on painfully slow internet
07:52:40 <bollu> is there anyway I can have it resume?
07:52:43 <bollu> (auto resume)
07:52:54 <ab9rf> bollu: i kinda wish stack would retain a local cache of the things it downloads
07:53:01 <bollu> ab9rf: yes, that too!
07:53:06 <ab9rf> it does for some things, but not for ghc implementations
07:53:12 <bollu> ab9rf: I'm not at uni right now, and the internet speeds back home sucks :(
07:53:29 <bollu> ghc-7.10.2:  389.53 KiB / 140.12 MiB (  0.27%) downloaded... :(
07:53:44 <ab9rf> i have decently fast home internet (~25 Mb/s) but it's still irritating to have to download ghc everytime i start a new project
07:55:30 <glguy> Why do you download a new copy of GHC every time you start a new project?
07:56:19 <yulax> maybe they update?
07:57:56 <c_wraith> sounds like a side effect of using stack
07:58:12 <c_wraith> I mean, it's supposed to cache ghc versions, but..
07:58:23 <AndreasK> ab9rf: At least for me stack keeps a local cache, but afaik only for fully downloaded things
07:58:38 <c_wraith> ab9rf: are you sure you're using the same resolver for everything?
07:59:36 <knupfer> Is it possible to set with TH the flags which the compiler will use for compilation?
08:00:06 <ab9rf> c_wraith: i have at least one project with an overridden resolver, but i think my global prefs have lts-8.01 set 
08:00:31 <ab9rf> from what i've seen it retains a cache of packages, but NOT of ghc installers
08:00:46 <glguy> Yeah, but it doesn't need reinstall GHC
08:00:57 <c_wraith> knupfer: no.  TH can only generate declarations/expressions/patterns/types
08:01:07 <c_wraith> knupfer: pragmas and imports are things it can't touch
08:01:18 <ab9rf> glguy: it does seem to share ghc instances across projecst with the same resolver, but i'm not 100% sure of that
08:01:38 <glguy> TH can generate some pragmas, too
08:02:02 <c_wraith> Oh, I suppose it can generate local pragmas, just not global ones
08:02:16 <glguy> stack reuses versions of GHC across resolvers if the resolvers share the same version
08:02:22 <ab9rf> c_wraith: i've got one that's explicitly overridden because it uses a package that doesn't compiule on lts-8.01
08:02:59 <ab9rf> actually might just be that it's declared as not compatible with the base in 8.01
08:03:03 <ab9rf> i don't remember anymore
08:07:26 <knupfer> c_wraith: What happens if I change the source of the module in which the TH resides?  With TH I could simply use IO and modify it...
08:08:06 <c_wraith> knupfer: TH runs after the module has been parsed.  You wouldn't change anything.
08:08:42 <c_wraith> knupfer: consider the CPP extension instead, if you need to change the module before it's parsed.
08:09:15 <knupfer> Would a (any) preprocessor work instead?
08:09:29 <knupfer> I'd like to write the manipulations in haskell.
08:10:43 <knupfer> I'm musing about donsbot post about genetic evolution of llvm flags. It seams there is nothing on hackage so I thought that I'll try that one...
08:13:01 <c_wraith> Yeah, you could use the other preprocessor stuff, though I never have.
08:26:01 <SkyBlond> 、quit
08:26:24 <yulax> hmm, script kiddy using weechat
08:26:35 <yulax> why can't they write good spam
08:27:35 <berndl> good spam?
09:32:38 <domenkozar> anyone on GHC 8.0.2?
09:32:53 <mniip> 8.0.1 will do?
09:33:13 <domenkozar> vector-algorithms fails to build on 8.0.2
09:33:16 <mniip> hvr, should I disallow base 4.6 or should I add some ifdefs to replace KnownNat/natSing with 4.6's SingI/case sing of SNat x -> x
09:33:40 <glguy> domenkozar: No, it hasn't be released yet so no one can be on 8.0.2. There are some rc versions available
09:34:04 <mniip> domenkozar, ah, that needs a functioning cabal, sorry mate
09:34:37 <domenkozar> glguy: I meant -rc1
09:46:02 <mniip> hvr, I've strengthened the constraint to >=4.7.0.0 for now
09:59:50 <ph88> hey guys, i have a lot of types (over 150) and for each type i need to make 2 instances and 1 function .. would it be worth to use generic programming for this ? 
10:00:07 <mizu_no_oto_work> > set (_Just . _Just)  1 (Just Nothing)
10:00:09 <lambdabot>  Just Nothing
10:00:43 <mizu_no_oto_work> Is there anything similar to lenses/prisms where the result of that would instead be (Just $ Just 1)?
10:01:38 <ph88> glguy, could you comment on that perhaps ?
10:02:35 <ph88> here is an example of such type with 2 instances and function https://paste.fedoraproject.org/507469/91131814/
10:03:14 <ph88> possibly i could also use php to parse the types and generate the haskell code for me
10:06:47 <ski> ph88 : why do you use `oneof' on a singleton list ?
10:08:18 <ski> ph88 : you can use `GeneralizedNewtypeDeriving', to be able to say `newtype SimpleName = SN Identifier deriving (Eq,Show,Data,Typeable,Arbitrary,P.Pretty)'
10:08:51 <ski> ph88 : the definition of `simpleName' could be simplified to just `simpleName = SN <$> identifier'
10:09:22 <ski> @type Test.QuickCheck.oneof . (:[])
10:09:23 <lambdabot> Gen a -> Gen a
10:11:38 <ph88> ski, what could i use instead of oneof ?    when i was using    fmap SN arbitrary    the type was not of  Gen
10:12:05 <athan> ph88: It definitely should
10:12:11 <athan> should be* a Gen
10:12:13 <ph88> ok let me try again
10:12:53 <ph88> oh ye it works .. not sure why i did it that way
10:12:59 <athan> :p
10:13:06 <ski> ph88 : anyway, now try `GeneralizedNewtypeDeriving' :)
10:13:31 <athan> what package are the `ala` and `alaf` functions defined again?
10:13:38 <johnw> newtype
10:13:44 <johnw> ala is also in lens
10:13:49 <athan> derp, thanks johnw
10:14:23 <ph88> damn GeneralizedNewtypeDeriving  saves a lot of work ^^
10:14:28 <athan> don't they basically just rely on an instance of an Isomorphism class or something?
10:14:44 <ski> ph88 : now there's only the type definition, and `simpleName' left :)
10:14:46 <ph88> does GeneralizedNewtypeDeriving also implement the shrink function of the Arbitrary instance ?
10:14:50 <byorgey> alaf is *only* in lens, not in newtype.
10:14:59 <ski> ph88 : should be the case
10:15:13 <athan> oop, thanks byorgey
10:15:14 <byorgey> as far as I know newtype is basically deprecated in favor of lens
10:15:37 <athan> hm, right on
10:15:40 <ski> (as long as its implemented for `Identifier'. but if it isn't, then your pasted code wouldn't work either)
10:15:51 <ph88> how can it be that GeneralizedNewtypeDeriving knows how to implement those instances ?
10:16:06 <ph88> did quickcheck define something special to make that possible ?
10:16:52 <ski> ph88 : there is an obvious isomorphism between a `newtype', and its representation type, which is used
10:17:45 <ph88> yes i noticed
10:18:11 <ph88> but didn't know haskell had enough information to figure that out
10:18:31 <ski> together with that `newtype's are typically implemented as no extra structure/indirection on top of the representation type (iow the distinction between new (sometimes abstract) type and representation type goes away at run-time), this means that it can simply just reuse the instance for the representation type as the instance for the new type
10:19:17 <athan> > alaf Sum fold [1,2,3] -- why isn't this just `6`?
10:19:19 <lambdabot>  Sum {getSum = 6}
10:19:33 <ski> (where "instance" here would typically be something like a "dictionary", a record of the methods implementing the "messages"/operations in the type class, for the particular instance type)
10:19:40 <glguy> > alaf Sum foldMap [1..3]
10:19:41 <athan> I thought it would result in the Unwrapped version
10:19:43 <lambdabot>  error:
10:19:44 <lambdabot>      • Couldn't match type ‘[Sum Integer]’ with ‘a -> Sum b’
10:19:44 <lambdabot>        Expected type: [Sum Integer] -> t a -> Sum b
10:19:57 <glguy> err
10:20:00 <athan> :v
10:20:18 <glguy> > ala Sum foldMap [1..3]
10:20:19 <athan> ala works like a charm like that glguy
10:20:20 <lambdabot>  6
10:20:26 <glguy> There we go
10:20:49 <athan> what is `alaf` supposed to mean? "ala f...functor?"
10:20:52 <ph88> i'm using this function https://hackage.haskell.org/package/wl-pprint-1.2/docs/Text-PrettyPrint-Leijen.html#v:renderPretty and i was wondering if there is a function that does printing without putting a maximum amount of characters on a line. Is there such a function, if not how could i implement it ?
10:21:23 <mniip> :t alaf
10:21:24 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
10:21:42 <athan> maybe it's using Sum as `g`
10:21:47 <athan> :s
10:21:52 <shapr> glguy: your AoC code is getting compliments from my makerspace friends. They were also saying they know nothing about Haskell but it's surprisingly easy to read anyway.
10:22:08 <athan> > runIdentity $ alaf Sum fold [1..3]
10:22:11 <lambdabot>  error:
10:22:11 <lambdabot>      • Couldn't match type ‘Identity (Sum a)’ with ‘Sum b0’
10:22:11 <lambdabot>          arising from a use of ‘alaf’
10:22:19 <glguy> shapr: Oh, awesome :)
10:23:04 <athan> > alaf Sum (Identity . fold) [1..3]
10:23:06 <lambdabot>  Identity 6
10:23:10 <athan> woot :)
10:26:24 <ski> ph88 : i suppose you could try with `maxBound', but if you're rendering a large document, it might perhaps run into it anyway (depending on the size of `Int', and the document). is the idea that you'd like no line breaks at all in the output ?
10:27:03 <ph88> ski, i like the output to be exactly the same as the randomly generated input
10:28:07 <ph88> ski, is there any way i can see the code that was generated by GeneralizedNewtypeDeriving ? because when i use this the program is not the same as it used to be
10:28:44 <geekosaur> -ddump-deriv
10:29:29 <ph88> geekosaur, where would i put that option when using stack ?
10:31:38 <geekosaur> stack build --ghc-options=-ddump-deriv
10:31:58 <geekosaur> note that stack itself uses -ddump-to-file so the result will be somewhere under ~/.stack-work
10:32:42 <ph88> oh i see
10:32:43 <ph88> thx
10:32:44 <geekosaur> (in a file with extension .dump-deriv)
10:33:00 <ph88> just found that i can also do   {-# OPTIONS_GHC -ddump-deriv #-}   and it will print in ghci
10:37:08 <ph88> i'm having a bit of a problem comparing the derived code with my own code to figure out why it doesn't work the same  https://paste.fedoraproject.org/507485/81913386/
10:40:45 <geekosaur> um. you understand what GND does, right?
10:41:07 <geekosaur> (which is probably not what you want)
10:41:25 <ph88> no not really, just started using it 10 minutes ago
10:41:36 <geekosaur> GND just auto-unwraps newtypes
10:41:43 <ph88> i was asking for a way to avoid having to implement 2 instances and 1 function for over 150 types
10:41:59 <geekosaur> it will never generate a map P.pretty like you do in your instance
10:42:05 <ph88> maybe using generic programming
10:42:57 <ph88> so the original question was: i have a lot of types (over 150) and for each type i need to make 2 instances and 1 function .. would it be worth to use generic programming for this ?
10:44:14 <c_wraith> GND is more subtle than auto-unwrapping. because it also acts like it auto-rewraps sometimes. 
10:44:44 <c_wraith> in truth, GND just treats types that differ only by the new type wrapper as being the same type. 
10:45:16 <c_wraith> which is why GND has opened holes in the type system occasionally. 
10:45:35 <geekosaur> for generics, I don't think you can use the usual trick for e.g. Arbitrary, because you don't "own" the class definition
10:46:02 <geekosaur> (the usual trick is to have a default implementation in the class definition that uses generics, then anything that needs to can declare an explicit instance)
10:46:46 <geekosaur> er, explicit instance method (you have to declare the instance anyway)
10:47:41 <ph88> any other things that can help here? The implementation of Arbitrary and Pretty is regular depending on the structure of the type
10:49:58 <ph88> to summarize on GND   newtype Foo = F Bar  is ok,  newtype Foo = F [Bar]  won't work.  What about something like  newtype Foo = F (String, Int)  ?
10:51:07 <geekosaur> it uses the instance on (String, Int)
10:51:27 <geekosaur> it does not do anything special for you, it just pretends the newtype is the thing wrapped in the newtype
10:51:41 <geekosaur> if that doesn't do what you want then GND is not the tool you want
10:52:11 <geekosaur> ("won't work" doesn't mean anything, so I must assume you mean "doesn't do what you intended")
10:52:24 <ph88> oh i see ... i will only use it on cases like   newtype Foo = F Bar   where i already implemented an instance for Bar
10:52:42 <hashme> hey guys, I have a doubt in usage 0f '\' as escape character -
10:53:16 <hashme> Prelude> putStrLn " \" this is a string" -> " this is a string but Prelude> putStrLn "\"this is a string\"" -> "this is a string"
10:53:16 <geekosaur> Haskell string escapes are not C string escapes
10:53:43 <hashme> should i give in lpaste?
10:53:44 <geekosaur> ...ok?
10:54:03 <geekosaur> I don't understand what you are asking
10:54:12 <hashme> Can oyu explain  " \" this is a string"
10:54:25 <hashme> Like what happens when you do putStrLn with that
10:54:35 <hashme> " this is a string 
10:54:39 <hashme> is what you get
10:54:45 <geekosaur> yes, what did you think it would do?
10:54:48 <ph88> well at least GND saves me implementing those instances for 35 types already :P
10:54:54 <hashme> "\"this is a string\""
10:54:56 <hashme> you get
10:54:59 <hashme> this is a string
10:55:07 <glguy> no
10:55:13 <geekosaur> no, you don't
10:55:16 <xenon-> nodawg.jpg
10:55:41 <hashme> ohh wait
10:55:45 <hashme> i got it
10:57:45 <ph88> glguy, is it possible to use generic programming to derive Arbitrary and Pretty instances automatically ?
10:58:36 <geekosaur> only if you control the class definition, as I said
10:58:45 <geekosaur> (unless you want to fight with overlapping instances)
10:59:26 <ph88> i don't think i control the class definition of Arbitrary .. it's from QuickCheck
10:59:31 <geekosaur> exactly
10:59:33 <ph88> i was looking at this package  https://github.com/dreixel/generic-deriving
10:59:56 <ph88> so if the QuickCheck author implements this then anyone can derive Arbitrary automatically ?
11:01:01 <ph88> what about "DeriveAnyClass"  ?
11:01:47 <ph88> {-# LANGUAGE DeriveAnyClass #-}
11:01:50 <geekosaur> makes an empty instance (instance Foo YourType where {}) for use with classes whose default method implementations use e.g. Generics
11:02:08 <geekosaur> but again you must control the class definition
11:03:14 <geekosaur> there is ongoing work to support the kind of thing you want to do (look for "deriving strategies") but ghc does not yet support it
11:04:20 <xenon-> ddd
11:06:34 <ski> ph88 : for your `SimpleName' case, `GeneralizedNewtypeDeriving' should be fine. this `ContextClause' is a different story (for `P.Pretty'. deriving `Arbitrary' for it looks like it could still work fine) (since presumably `[ContextItem]' isn't an instance of `P.Pretty', or if it is, its instance doesn't have the behaviour that you want for `ContextClause')
11:07:32 <ski> ph88 : "i will only use it on cases like   newtype Foo = F Bar   where i already implemented an instance for Bar" -- yes
11:07:34 <geekosaur> ph88, basically this is a thing that coems up every so often and ghc doesn't really have any good solutions for it, although there are some TH hacks to construct instance definitions
11:07:52 <ph88> always nice to get confirmation when not sure :)
11:08:00 <geekosaur> which is why people are looking into deriving strategies as a possible solution. but they don't exist yet
11:08:07 <ski> ph88 : sorry for not being precise enough about what `GeneralizedNewtypeDeriving' buys you, before
11:09:04 <ph88> it's ok, i'm getting somewhere :P
11:10:10 <ph88> ok so for the moment i have GND for very simple newtype cases ... then i can use DeriveGeneric with genericArbitrary and genericShrink to make the implementation easier   .. for Pretty i'm still looking for something
11:10:37 <ph88> references: https://hackage.haskell.org/package/quickcheck-arbitrary-adt-0.2.0.0/docs/Test-QuickCheck-Arbitrary-ADT.html#v:genericArbitrary and https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:genericShrink
11:11:01 <ph88> already noticed that genericShrink doesn't always work .. don't know why .. just wrote implementation myself ^^
11:13:06 <isovector> hey all -- is the result of `show $ typeRep (Proxy :: Proxy a)` well-defined between GHC versions?
11:13:34 <mniip> hvr, thanks for updating the 0.1.0.0 too btw
11:13:37 <mniip> I didn't notice
11:13:56 <glguy> isovector: You should only rely on the typereps being unique to a particular compiled executable afaik
11:14:34 <isovector> glguy: lame. thanks
11:15:28 <isovector> on that note, do we have any guarantees for `Hashable` remaining the same?
11:15:58 <isovector> i'm trying to generate hash signatures for arbitrary data
11:17:06 <ompaul> isovector: sha256 foo.data 
11:17:11 <ompaul> what's wrong with that
11:17:35 <ompaul> sorry - I was in the wrong channel in my mind
11:17:51 <monochrom> heh
11:18:28 <geekosaur> it's still close to the correct answer. don't rely on Hashable, use a well known hash from one of the crypto libraries
11:18:53 <geekosaur> that's what they are for. Hashable has other duties.
11:18:55 <isovector> this is good advice. thanks all :)
11:20:31 <glguy> isovector: I'd expect a major version bump if a package changed its implementation of Hashable, possibly, but I don't think the stability is documented
11:20:53 <glguy> It exists to help build fast hashmaps rather than to be a reliable long-term storage key
11:21:31 <geekosaur> I could argue that stability is actually wrong, for the same reason that many languages/libraries have hash implementations that randomize (to avoid certain data-related denial of service attacks)
11:22:17 <mizu_no_oto_work> > set (_Just . _Just)  1 (Just Nothing)
11:22:19 <lambdabot>  Just Nothing
11:22:20 <mizu_no_oto_work> Is there anything similar to lenses/prisms where the result of that would instead be (Just $ Just 1)?
11:22:52 <geekosaur> I doubt it because then it has to know how to remap constructors
11:23:30 <byorgey> > set _Just (Just 1) (Just Nothing)
11:23:32 <lambdabot>  Just (Just 1)
11:23:33 <geekosaur> this is pretty much only possible if you provide the mapping, or for the specific case of two constructors where one constructor is nullary
11:23:57 <geekosaur> (and even in the latter case I'd want something similar to type roles around because it
11:24:03 <geekosaur> s not always a good idea)
11:24:37 <mizu_no_oto_work> There's always Monoid and mzero, for providing a default value for a type
11:36:46 <sm> omg AoC 1b you are so annoying :)
11:36:51 <hashme> guys I have doubt in parsing \" in a string
11:36:56 <shapr> sm: ooh, did you join the #haskell leaderboard?
11:37:01 <hashme> http://lpaste.net/350039
11:37:42 <sm> yes I couldn't help myself with it being promoted in here every day
11:37:51 <sm> better late than never!
11:37:51 <ph88> geekosaur, you said for DeriveAnyClass i must control the class definition, is this also the case for https://github.com/dreixel/generic-deriving ?
11:37:56 <shapr> :t Text.Parsec.noneOf
11:37:57 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
11:38:12 <monochrom> hashme, this is not caused by escapes, this is cause by you assuming Char = [Char]
11:38:18 <shapr> :t Text.Parsec.noneOf "\""
11:38:20 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char
11:38:34 <geekosaur> DeriveAnyClass creates an empty/defaulted instance; by definition any behavior must come from the class definition
11:38:49 <sm> incidentally shouldn't the direct leaderboard url be in /topic as well
11:39:03 <shapr> sm: I think it's the last thing in the topic?
11:39:10 <shapr> sm: AoC: 43100-84040706
11:39:13 <hashme> hmm alright
11:39:32 * sm clicks harder.. nope, browser still doesn't take me there ..
11:39:48 <sm> maybe I need to reboot 
11:39:55 <shapr> :t Text.Parsec.string "foo"
11:39:56 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m String
11:41:26 <ph88> geekosaur, i'm not sure if DeriveAnyClass and package generic-deriving are related .. Are you saying that for both i should have control over the class definition because behaviour should originate from there?
11:41:54 <geekosaur> I'm noit sure if they are related either. I am not an encyclopedia of Hackage
11:42:04 <shapr> sm: Not enough space in the topic, what to remove?
11:42:31 <geekosaur> I would *guess* that generic-deriving can be used to do the other half of (default instance, class has default methods using Generics)
11:42:39 <sm> hmm yes, what about... downloads.haskell.org
11:42:50 <ph88> geekosaur, well i don't expect you to know anything. It's ok to say "i don't know" :P thanks for all the infos that you do know though
11:43:00 <shapr> well, fine with me
11:43:12 <ph88> geekosaur, anything -> everything  lol
11:43:15 <sm> and s/www.haskell.org/haskell.org/
11:43:28 <ph88> stupid typo :|
11:43:43 <shapr> I'll change the topic after work, I'm not logged into AoC at work. (so I don't get distracted)
11:44:00 <sm> well you are smarter than me. I am closing it right now :)
11:44:46 <geekosaur> but somehow I have this feeling you expect ghc to be sentient and/or mind-reading. No automatic derivation is going to figure out exactly what you want. Existing auto-derivation relies on very simple built-in behavior, possibly combined with default methods (which must be part of the class definition)
11:45:27 <ph88> this looks basically what you were saying before .. but still i find it informational "I agree. Most (all?) of the classes for which DeriveAnyClass is useful will be relying on a top-level superclass like Generic or Data, rather than a recursive context based on the structure of the type."
11:45:29 <geekosaur> ..or alternately must use Template Haskell to generate "stereotyped" instance definitions
11:45:35 <ph88> found that in a SO comment
11:46:18 <ph88> no no, i don't expect GHC to be mind-reading, but i would like it to be xD
11:46:29 <geekosaur> yes, thats just saying you use it with Generics (or the simpler Data). you still need the actual implementation that uses those to be within the class definition
11:46:31 <ph88> subtle difference :D
11:46:49 <geekosaur> because putting it anywhere else will overlap any explicit instances
11:47:36 <geekosaur> (you don't want to get into an overlap fight with the compiler. It will win, and may pick unexpected instances out of apparent spite)
11:48:03 <ph88> yeah surely
11:48:38 <monochrom> we can easily drop the reddit url too, people can figure it out themselves
11:49:36 <ph88> i'm still thinking in terms of what would be feasible to do in another language with reflection mechanisms and whatnot.
11:51:08 <glguy> sm: The leaderboard URL will only work for people who've already joined it, I think
11:51:10 <geekosaur> that's not the problem here, really; you have reflection mechanisms. Your problem is that typeclasses have rigid behaviors that aren't the behaviors you want
11:51:14 <monochrom> oh I just have a cunning plan of indirection. the topic should contain just one URL. it points to a web page we control, where we can add as much information as we want. and pictures too.
11:51:29 <johnw> what's the standard way these day to just grab a ByteString from a URL?  It's data that I'd ordinarily download using curl
11:51:32 <geekosaur> (and never will be, because they introduce holes into the type system)
11:52:23 <johnw> http-client?
11:52:45 <johnw> it's small sized data, so I don't need streaming
11:53:23 <johnw> although, maybe I'll use pipes-http just to future proof it
11:53:30 <monochrom> I don't know about standard ways (and I suspect there are always many of time), but I'm from an old era so I would just use the HTTP library and its "simple HTTP request" function.
11:53:35 <sm> http://hackage.haskell.org/package/download looks easy
11:53:37 <byorgey> johnw: http-client is too low-level, use Network.HTTP.Simple from http-conduit
11:53:45 <johnw> byorgey: ok, thanks
11:54:00 <byorgey> johnw: that's not the only possible answer, but http-client is not the answer =)
11:54:03 <johnw> sm: heh, indeed
11:55:14 <monochrom> haha http-client doc recommends what byorgey said too
11:55:57 <monochrom> although with "I just want a ByteString and it's going to be short" I wonder if low level is actually simpler.
11:56:18 <byorgey> no, it's not.
11:56:24 <sm> what is this craziness.. stack install cabal-install, "base-4.9.1.0 must match >=4.5 && <5 && <0"
11:56:38 <monochrom> OK, maybe its "Manager" thing is too much trouble
11:56:44 <ph88> geekosaur, so the problem is whether behaviours can be implemented in a generic way ? And people found that for some classes they can be, but for others it's not possible ?  I saw for the two classes i need (Arbitrary and Pretty) it is possible to derive the behaviour in a generic way .. but then on the other hand sometimes it could not .. for example genericShrink sometimes just doesn't work
11:56:44 <johnw> full disclosure: it's a .tar.gz that I want to download and unpack; and although for the foreseeable future it will be tiny (<100 bytes), no reason not to just do this the right way, and stream it through the proper codecs lazily into a directory of files
11:56:50 <byorgey> by "low level" I mean you have to create a connection manager object, and then create a Request object, and then ...
11:57:15 <monochrom> Oh God that is not low level. That is object-oriented.
11:57:23 <byorgey> haha
11:57:31 <geekosaur> ph88, I was talking just about the part where generic deriving needs control of the class definition.
11:57:41 <byorgey> did I mention the RequestManagerFactoryFactory
11:58:45 <geekosaur> The other one is just that any time you think you're being clever about generic implementations, you're probably shooting yourself in the foot (although you may not be able to see the foot that got shot until it's too late)
11:59:09 <ph88> geekosaur, besides that it would be nice to have this stuff to help me make my program it's also just fascinating to me :)
11:59:50 <geekosaur> many things can be characterized algorithmically, and then you can make reliable reflection/generics based mechanisms. but many more can't, or have exception cases that need to be managed
12:05:18 <hashme> is there a function for reading binary numbers?
12:05:22 <hashme> like readOct readHex?
12:05:46 <Wizek_> Hey, Anyone knows how to set default values if Nothing is encountered somewhere in a deep Lens lookup/assignment? E.g. `((Just (3,2), 2) ^. _1 . (non $ Just (5,4)) . _1 == 3) && ((Nothing, 2) ^. _1 . (non $ Just (5,4)) . _1 == 5)`
12:08:20 <glguy> hashme: no, but you can build one like this: readInt 2 (`elem`"01") digitToInt
12:10:23 <glguy> sm: adding a constraint of base<0 is a way to disable a package from being installed
12:10:38 <glguy> sm: Try specifying an explicit version of cabal-install ?
12:18:35 <cocreature> is "fromIntegral" the right method if I want a _bitwise_ conversion of a Word32 to an Int32 and the other way around?
12:18:43 <begriffs> Just curious, does anybody build haskell programs using makefiles?
12:20:03 <glguy> Other than GHC?
12:20:30 <sm> glguy: specifying the version didn't help
12:20:35 <geekosaur> cocreature, in general if you want bitwise you want unsafeCoerce. but fromIntegral should be optimized in that use case to just swap the constructor
12:20:42 <Wizek_> Or perhaps more importantly: `((Just (4,3), 2) & _1 . (non (6,5)) . _1 .~ 7 == (Just (7,3), 2))  &&  (
12:20:42 <Wizek_> (Nothing, 2) & _1 . (non (6,5)) . _1 .~ 7 == (Just (7,5), 2))`
12:20:46 <glguy> sm: Does it help to specify a resolver?
12:20:51 <sm> no
12:21:02 <glguy> lame 
12:21:05 <sm> I would try cabal, but I accidentally nuked it
12:21:05 <glguy> Have you tried stack?
12:21:23 <sm> stack is what I'm using
12:21:25 <cocreature> geekosaur: I care less about the performance and more about the fact that it does the right thing with the sign bits
12:21:33 <geekosaur> isn't stack what's causing the problem here?
12:21:36 <glguy> thatsthejoke.jpg (I'm I doing that right?)
12:22:06 <Wizek_> I'm in the process of acquainting myself with lenses, so maybe what I am trying to do is not possible for some reason?
12:22:38 <hashme> I wish there were examples as well in hackage with function description
12:22:50 <hashme> Our understanding would be clearer
12:24:22 <shapr> hashme: me too
12:24:42 <geekosaur> cocreature, I'm not talking performance really. unsafeCoerce is about reinterpreting a bit pattern representing a constructor tag and associated value(s); as long as those line up, it is safe. fromIntegral optimizes to that in known safe cases via RULES, but otherwise doesn't guarantee bit pattern fidelity
12:25:12 <cocreature> geekosaur: good point, I guess unsafeCoerce is really what I want to use here.
12:25:16 <geekosaur> yes
12:25:22 <sm> dang that reminds me. shapr I missed my goal that, oops :/
12:25:50 <cocreature> geekosaur: thanks!
12:26:37 <geekosaur> (although I think in practice that one will always be correct even without optimization)
12:26:39 <c_wraith> I understand that examples don't have to mean bad documentation, but they're sure strongly associated in my head. maybe if php and rails used real documentation instead of examples-only, I'd have much less of a visceral rejection of examples. 
12:27:01 <geekosaur> (but that assumes current ghc implementation, so.)
12:29:24 <xenon-> is this use of unsafePerformIO acceptable? http://lpaste.net/350042
12:29:38 <sm> "stack install cabal-install" works with lts-7.1 and the latest lts-7.13, I guess there's some trouble in the recent 7s
12:30:12 <uiop> xenon-: the type of "hello" is () then
12:30:35 <xenon-> uiop it is IO ()
12:30:38 <uiop> xenon-: and it wont happen until it gets forced somewhere else in the program
12:30:57 <uiop> xenon-: unsafePerformIO :: IO a -> a
12:31:17 <xenon-> look at the type of onlyOnce again
12:31:29 <uiop> oh is it IO (IO ()) ?
12:31:40 <xenon-> yes
12:31:50 <c_wraith> xenon-, the hlint warning from lpaste should not be ignored. 
12:31:55 <uiop> xenon-: then my bad
12:32:02 <uiop> xenon-: why not just use join
12:32:12 <xenon-> i did just to satisfy the types
12:32:13 <uiop> oh nm
12:32:17 <xenon-> yeah :)
12:32:22 <c_wraith> xenon-, if you obey that warning, you have the typical top-level IO action hack. 
12:32:27 <thomasd> if I'm using the 'free' package, do I need to define `instance MonadFree (MyFunctor)`?
12:32:31 <uiop> does join defeat the purpose of onlyOnce?
12:32:34 <thomasd> in order to use liftF?
12:32:41 <c_wraith> xenon-, if you ignore that warning, you have lots of bugs. 
12:32:51 <xenon-> c_wraith I see. and there's nothing we can use instead of unsafePerformIO here?
12:33:03 <xenon-> uiop yes "Warning" is printed every time you call hello
12:33:23 <ph88> why does hoogle not find https://hackage.haskell.org/package/generic-random-0.3.0.0/docs/Generic-Random-Generic.html#v:genericArbitrary when i search for "genericArbitrary" ??
12:33:32 <c_wraith> xenon-, I'd just use a nested IO type, myself. 
12:33:36 <uiop> xenon-: then it seems like unsafePerformIO is appropriate here
12:33:43 <uiop> i guess
12:33:44 <sm> ph88: which hoogle ?
12:33:51 <ezyang> ph88: https://www.stackage.org/lts-7.13/hoogle?q=genericArbitrary 
12:33:53 <xenon-> but I did use nested IO type?
12:34:04 <ezyang> "classic" Hoogle only has a certain set of packages it searches 
12:34:14 <c_wraith> xenon-, I mean as the main interface. 
12:34:20 <ph88> http://hoogle.haskell.org/?hoogle=genericArbitrary
12:34:37 <uiop> xenon-: oh hah i just noticed you also defined onlyOnce
12:34:38 <ph88> ezyang, yes your link doesn't show it either !!
12:34:38 <c_wraith> xenon-, I understand why you don't want it, but I really think it's better. 
12:34:45 <xenon-> ah, so do something like h <- hello in main
12:34:53 <xenon-> uiop yes :)
12:34:54 <ph88> sm, http://hoogle.haskell.org/?hoogle=genericArbitrary 
12:34:59 <c_wraith> xenon-, especially when things like dynamic reloading get involved. 
12:35:00 <ezyang> oh the package is probably not in the LTS then haha 
12:35:14 <c_wraith> xenon-, yeah, that's what I mean. 
12:35:55 <sm> yeah, it's not in stackage, which that hoogle searches by default
12:36:01 <xenon-> cool. btw I am curious what is the bug that I have right now (having not used NOINLINE pragma) and how will it manifest itself?
12:36:55 <c_wraith> xenon-, if the definition of hello gets inlined, it will have an UnsafePerformIO in each location it gets inlined 
12:37:16 <ph88> sm, ezyang how can i search through packages that are not in stackage but still have documentation on hackage ?
12:37:16 <c_wraith> xenon-, and therefore not share the IORef between all of them.
12:37:35 <xenon-> i see
12:37:45 <ezyang> I don't think this exists. Love to be wrong. 
12:37:50 <xenon-> does that actually happen in practice?
12:38:04 <xenon-> i didn't get that warning until i used lpaste.. maybe i should start using hlint
12:38:28 <c_wraith> I'd expect it to happen with that particular example any time you compile with optimizations. :) 
12:38:29 <geekosaur> ph88, hayoo?
12:38:55 <geekosaur> (https://hayoo.fh-wedel.de)
12:39:04 <ph88> no results found
12:41:58 <hashme> Can you guys please  look at this errror?
12:42:02 <hashme> http://lpaste.net/350043
12:42:25 <monochrom> what is the type of x? answer: Char
12:42:39 <monochrom> what is the type of [x]? answer: [Char]
12:43:04 <monochrom> what is the type of ["\t"] (or simply ["h"] for that matter)? answer: [[Char]]
12:43:11 <ph88> hashme, maybe if you put 'r' instead of "r"
12:43:14 <monochrom> So why are you doing this to yourself? answer: ...
12:43:37 <hashme> I want it to return a tring
12:43:39 <hashme> string
12:43:54 <monochrom> Sure, but ["h"] is not String.
12:44:08 <Xnuk> return "\t"
12:44:13 <monochrom> "h" is String, ["h"] is [String]. Logical, no?
12:44:16 <ph88> hashme, when you take 1 character from a string (x) and then compare it with a "string" instead of a 'c'har ??
12:44:26 <hashme> "h" is char right?
12:44:29 <ph88> no
12:44:30 <monochrom> No.
12:44:37 <ph88> "h" is string with 1 char
12:44:38 <monochrom> Where did you get that wrong idea from?
12:44:43 <ph88> "h" = ['h']
12:45:22 <ph88> monochrom, from any other language i suppose
12:45:30 <hashme> Ahh right
12:45:40 <hashme> ['\t'] would work right
12:45:54 <monochrom> Sure, meta-question: where did you get the "can presume based on other languages" wrong idea from?
12:46:24 <ph88> hashme, i think you have a problem on x and also a problem on return
12:46:37 <xenon-> :t oneOf
12:46:39 <lambdabot> Eq a => [a] -> Splitter a
12:46:41 <hashme> right i fixed it
12:46:44 <monochrom> It can only come from people  you shouldn't trust or your own imagination you shouldn't trust.
12:46:50 <hashme> '' <- this is used for char right
12:46:55 <ph88> ya
12:46:57 <hashme> x is char in my case so
12:47:03 <hashme> that was giving an error
12:47:14 <monochrom> Besides, even after presuming, you can always ask ghci for ":type "h"" to confirm or deny.
12:47:33 <ph88> hashme, "r" -> do return ["\r"]    -->   'r' -> do return "\r"    i think
12:48:21 <bollu> so I'm reading F is for functor
12:48:28 <hashme> yeah yeah i got it 
12:48:33 <hashme> thanks a lot!
12:48:57 <ph88> hashme, i think you have another problem with that parser
12:49:50 <xenon-> if it compiles.. ship it
12:50:01 <ph88> yes with haskell that is almost true :P
12:50:06 <ph88> aaaaaaalmost
12:50:13 <monochrom> sail away, sail away, sail away
12:50:24 <ph88> time for more wine
12:51:48 <ph88> yoohooo hashme !
12:53:11 <hashme> Guys readOct returns [(Integer, String)] right?
12:53:25 <hashme> How do I parse it to an integer?
12:53:42 <monochrom> How about asking GHCi ":type readOct" to see the answer?
12:53:43 <hashme> Like what does [(Integer, String)] represent?
12:53:56 <glguy> monochrom: What'd it say?
12:54:08 <ph88> hashme, don't want to know the other problem with that parser ??
12:54:11 <monochrom> I don't know. I don't even know where readOct comes from
12:54:12 <ph88> okay
12:54:18 <Xnuk> readOct :: (Eq a, Num a) => ReadS a
12:54:30 <int-e> monochrom: Numeric
12:54:35 <hashme> ph88: I'm not getting any error, and I checked it - it works
12:54:46 <int-e> > readOct "0123abc"
12:54:48 <lambdabot>  [(83,"abc")]
12:54:58 <int-e> > readOct "abc"
12:55:00 <lambdabot>  []
12:55:02 <hashme> ph88: If you're so determined, go ahead :P
12:55:10 <ph88> :)
12:55:31 <ph88> hashme, what happens when you have for example \B  ?
12:55:37 <int-e> hashme: the [] is a total parse failure; the [(83,"abc")] means that 0123 is parsed as 83 and "abc" remained.
12:56:11 <monochrom> > readOct "38"
12:56:13 <lambdabot>  [(3,"8")]
12:56:15 <ph88> > readOct "a123b"
12:56:18 <lambdabot>  []
12:56:28 <hashme> int-e: how do you propose to parse it then
12:57:43 <int-e> well, just pattern match on the result of readOct
12:58:11 <ph88> int-e, and then what about the rest of the string? :)
12:58:23 <uiop> let readOctM a = case readOct a of []-> Nothing; (x,_):_-> Just x
12:59:13 <Hafydd> If the rest of the string is non-empty, then the string you've parsed does not wholly consist of an octal number, which is a parse error.
12:59:28 <ph88> input_string = "important_number 1542important_information" ups "important_information" was dropped
13:00:15 <uiop> ph88: first figure out what you even want to happen, then make it happen pattern matching on readOct result
13:00:17 <uiop> ez??
13:00:45 <ph88> i doubt hashme wants that to happen
13:01:00 <ph88> uiop, it's not my problem fyi
13:01:06 <int-e> ph88: well, you could check whether it's empty, or whether it's all whitespace, or use it for further parsing; the possibilities are endless
13:01:20 <ph88> :D
13:01:36 <ph88> do you work in the advertisement business? :P
13:01:38 <uiop> ph88: oh my bad am distracted, i thought you asked original question
13:01:59 <int-e> (the 1st is the easiest; the second is closest to what `read` does; the third is most useful for general parsing, maybe)
13:02:31 <monochrom> It may be easiest to ignore readOct and roll your own.
13:02:35 <ph88> don't think readOct is the way to go here
13:03:14 <ph88> oh hashme quit ?
13:03:21 <ph88> meh
13:03:21 <monochrom> Either that, or do a "many (oneOf "01234567")" and then you can call readOct and ignore all the erroneous cases because they can't happen.
13:03:45 <monochrom> err, many1
13:03:46 <ph88> oneOf [0..7]
13:07:57 <ph88> eh that's not correct it think, anyway doesnt matter since he left ^^
13:08:23 <monochrom> ['0'..'7'] fixes it
13:08:37 <ph88> yeah
13:08:41 <monochrom> People should simply pay more attention to types.
13:09:06 <ph88> well kind of hard to ignore them with those compiler errors, no ?
13:09:26 <Hafydd> Heh. "01234567" is the same number of characters.
13:09:56 <monochrom> Yet you read this channel and you find people trying so hard to ignore types.
13:11:38 <ph88> maybe cuz of other languages :P
13:12:26 <monochrom> other languages don't eliminate types, they just postpone crashes to run time, so programmer still have to pay attention.
13:12:34 <monochrom> s/programmer/programmers/
13:12:58 <monochrom> I mean, we are not talking about Tcl, we are merely talking about python
13:14:51 <implementation_> monochrom: that's a nice way of expressing the problem, i'll save that quote for the usual occasions.
13:15:45 <ph88> a haskell to tcl compiler might that be something nice ?
13:19:01 <Sonolin> haskell all the languages!
13:21:28 <zach32> Hey folks, I wrote this function:  slice xs n1 n2 = [ x | n<-[n1..n2], x<-[xs!!n] ] , but when used, returns the error [*** Exception: <interactive>:33:1-9: Non-exhaustive patterns in function !!
13:21:37 <zach32> does anyone have any ideas?
13:22:12 <ezyang> probably out of bounds 
13:22:19 <ph88> zach32, you have a problem when xs is empty
13:22:39 <zach32> ph88' I used it for a list [1..10' though
13:22:40 <ph88> zach32, n2 < n1 also seems riscy
13:22:54 <zach32> True true, it was just me toying around
13:23:09 <ph88> i don't really know what happened there .. just noticing a few things
13:23:19 <ski> > [() | _ <- [5 .. 2]]
13:23:20 <lambdabot>  []
13:23:28 <glguy> zach32: If you have a question about some code that doesn't work you can paste it to http://lpaste.net 
13:23:44 <zach32> ohh lemme try switching the vars. Ok, thanks, will do
13:23:55 <implementation_> > [() | _ <- [2 .. 5]]
13:23:57 <lambdabot>  [(),(),(),()]
13:23:58 <ski> zach32 : btw, that `x<-[xs!!n]' there is equivalent to `let x = xs !! n'
13:24:22 <zach32> Oh, yeah, I was wondering about how to do that. Hey can you tell me how to do a replacement at index?
13:24:39 <zach32> xs!!5 = 12 is invalid
13:24:42 <ski> zach32 : and then `[ x | n<-[n1..n2], let x = xs !! n ]' could be simplified to `[xs !! n | n <- [n1 .. n2]]'
13:25:10 <athan> zach32: lists aren't really for updates
13:25:14 <uiop> zach32: anytime you're indexing into lists repeatedly, and replacing at indices, etc, you know you need to rethink the datastructure you're using
13:25:21 <ski> using indices to access elements of lists is inefficient
13:25:24 <athan> but i think there's something like `updateAt` or similar
13:25:37 <zach32> Alrighty, sounds good
13:25:39 <ski> if you really want to update an element at a specific position in a list, you could write a function that does that
13:26:06 <ski> e.g. of type `Int -> a -> [a] -> [a]', or `Int -> [a] -> (a -> a) -> [a]', or something
13:26:11 <implementation_> > let xs = [1..5]; (start,_:end) = splitAt 2; in start ++ [100] ++ end
13:26:13 <lambdabot>  error:
13:26:13 <lambdabot>      • Couldn't match expected type ‘(t, [t1])’
13:26:13 <lambdabot>                    with actual type ‘[a0] -> ([a0], [a0])’
13:26:21 <ph88> nice
13:26:22 <implementation_> > let xs = [1..5]; (start,_:end) = splitAt 2 xs; in start ++ [100] ++ end
13:26:25 <lambdabot>  [1,2,100,4,5]
13:26:54 <zach32> [1..10]
13:27:04 <zach32> oh, wait, is lambdabot like, a real bot
13:27:08 <ski> yes
13:27:18 <grantwu> lol
13:27:19 <ski> use `> ' before an expression, to get it to evaluate it
13:27:25 <ph88>  @pl is also nice
13:27:32 <grantwu> zach32: https://hackage.haskell.org/package/lambdabot
13:27:35 <implementation_> it can also tell you the type of expressions
13:27:37 <zach32> That sounds dangerous, what if i did [0..]
13:27:38 <implementation_> :t [1..10]
13:27:40 <lambdabot> (Num t, Enum t) => [t]
13:27:46 <implementation_> > [0..]
13:27:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:27:51 <ski> @type length "foo"
13:27:52 <lambdabot> Int
13:27:56 <zach32> whew
13:28:10 <ski> @help run
13:28:10 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:28:20 <ski> `> ' is sugar for `@run '
13:28:48 <ph88> anyone know a good line to show of @pl ?
13:28:54 <ski> (and `:t ' for `@type ')
13:29:08 <implementation_> :k Monad
13:29:10 <lambdabot> (* -> *) -> Constraint
13:29:11 <ski> @help pl
13:29:12 <lambdabot> pointless <expr>. Play with pointfree code.
13:29:37 <ski> @pl toUppers s = map toUpper s
13:29:37 <lambdabot> toUppers = map toUpper
13:29:48 <zach32> > [1..10]
13:29:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:29:51 <ph88> something more impressive than that :P
13:29:56 <grantwu> Do something that involves Control.Arrow :P
13:30:25 <ski> function extensionality isn't impressive ? ;P
13:30:32 <zach32> > data Ternary t = T1 | F2 | T3 deriving(Eq, Show)
13:30:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
13:30:39 <zach32> doh
13:30:46 <ski> it evaluates *expressions*
13:30:52 <implementation_> @let update i e xs = let (h,_:t) = splitAt i xs in h ++ [e] ++ t
13:30:53 <ski> @let data Ternary t = T1 | F2 | T3 deriving (Eq,Show)
13:30:54 <lambdabot>  Defined.
13:30:56 <lambdabot>  Defined.
13:31:03 <implementation_> > update 2 100 [1..5]
13:31:05 <zach32> lets see if I can use your data type...
13:31:06 <lambdabot>  [1,2,100,4,5]
13:31:08 <ski> > T1 == T3
13:31:10 <lambdabot>  False
13:31:17 <zach32> > let asd = T1
13:31:19 <lambdabot>  <no location info>: error: not an expression: ‘let asd = T1’
13:31:38 <implementation_> :t T1
13:31:39 <lambdabot> forall k (t :: k). Ternary t
13:31:40 <ski> `let asd = T1' isn't an expression
13:31:42 <zach32> :t T1
13:31:44 <lambdabot> forall k (t :: k). Ternary t
13:31:45 <ski> > update 100 2 [0 .. 4]
13:31:47 <lambdabot>  *Exception: /tmp/mueval1911759956749241873.hs:165:21-45: Irrefutable pattern...
13:32:20 * ski isn't sure what zach32 is doing with the `t' type parameter, there ..
13:32:44 <grantwu> I think you need @let
13:32:46 <grantwu> @let foo = 3
13:32:48 <ph88> always nice to have some parameters
13:32:48 <lambdabot>  Defined.
13:32:49 <zach32> gotcha
13:32:49 <grantwu> > foo
13:32:51 <lambdabot>  3
13:32:56 <zach32> @let foo = T2
13:32:57 <ab9rf> ski: is there any way to instantiate T1?
13:32:58 <lambdabot>  .L.hs:164:1: error:
13:32:58 <lambdabot>      Multiple declarations of ‘foo’
13:32:58 <lambdabot>      Declared at: .L.hs:163:1
13:33:09 <zach32> @let asd = T3
13:33:11 <ski> ab9rf : not sure what you mean ..
13:33:11 <lambdabot>  Defined.
13:33:15 <zach32> :t T3
13:33:17 <lambdabot> forall k (t :: k). Ternary t
13:33:17 <ph88> when do @let expire ?
13:33:22 <implementation_> @let update i e xs = case splitAt i xs of { (h,_:t) -> h ++ [e] ++ t; _ -> []; }
13:33:24 <lambdabot>  .L.hs:168:1: warning: [-Woverlapping-patterns]
13:33:24 <lambdabot>      Pattern match is redundant
13:33:24 <lambdabot>      In an equation for ‘update’: update i e xs = ...
13:33:28 <ski> ph88 : whenever anyone does `@undefine'
13:33:44 <ph88> isn't @undefine on a cron or something ?
13:33:51 <ph88> can't imagine it staying defined forever :P
13:33:52 <implementation_> > update 100 2 [1..5]
13:33:54 <lambdabot>  *Exception: /tmp/mueval1911759956749241873.hs:167:21-45: Irrefutable pattern...
13:34:44 <implementation_> @undefine update
13:34:44 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
13:35:01 * ski smirks
13:35:02 <zach32> > @undefine
13:35:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
13:35:07 <zach32> :t T3
13:35:09 <lambdabot> forall k (t :: k). Ternary t
13:35:23 <zach32> hm, so it only unsets the vars. neat
13:35:34 <Tuplanolla> You used it wrong, zach32.
13:35:47 <zach32> @undefine
13:35:47 <lambdabot> Undefined.
13:35:52 <zach32> :t T3
13:35:53 <lambdabot> error:
13:35:53 <lambdabot>     • Data constructor not in scope: T3
13:35:53 <lambdabot>     • Perhaps you meant variable ‘_3’ (imported from Control.Lens)
13:35:57 <zach32>  :O
13:36:11 <Tuplanolla> > lambdabot
13:36:13 <ski> it unsets every `@let' definition
13:36:14 <lambdabot>  Bot
13:37:36 <ski> > lambdabot <> lambdabot
13:37:38 <lambdabot>  Bot
13:38:10 <implementation_> :t (<>)
13:38:12 <lambdabot> Monoid m => m -> m -> m
13:38:17 <implementation_> :t lambdabot
13:38:19 <lambdabot> Dumbass
13:38:20 <ski> > "abc" <> "de"
13:38:22 <implementation_> wat
13:38:22 <lambdabot>  "abcde"
13:38:38 <orion> If a function requires that I pass it a (IO () -> IO a), will both forkIO :: IO () -> IO ThreadId
13:38:42 <zach32> damb lambdabot talks hard smack
13:38:50 <ski> @botsmack
13:38:50 <lambdabot> :)
13:38:53 <orion> and async :: IO a -> IO (Async a) work?
13:39:06 <grantwu> @botsnack
13:39:06 <lambdabot> :)
13:39:08 <orion> I feel like it would.
13:39:10 <grantwu> huh.
13:39:21 <Tuplanolla> Look at all these essential features.
13:39:31 <zach32> Lbot would probably just shoot us out the airlock on a spaceship
13:39:57 <ski> orion : yes. but other occurances of `a' in the type signature will be instantiated (to `()' respectively to `Asynch ()')
13:40:18 <orion> ski: Totally find.
13:40:36 <ski> (er, sorry, to `ThreadId' in the first case, not `()')
13:40:44 <orion> I just wanted to make sure that my logic was sound before submitting a feature request to Michael Snoyman.
13:44:30 <glguy> Playing adventofcode.com this year? Not too late to start. #haskell leaderboard key is in /topic
13:49:46 * ski . o O ( Don't get left behind by the AoC craze by missing out on third list homomorphism and Futamura's projection! )
13:52:40 <glguy> I think I just got left behind :-S
13:53:17 * mmaruseacph2 always read that as Futurama's projection
14:02:44 <bollu> If I wanted to benchmark STG, how would I go about doing this? 
14:05:48 <cocreature> b0llu: as in “hand-written stg”?
14:06:01 <cocreature> you can’t even feed that to ghc to compile it, can you?
14:11:21 <acowley> No
14:11:59 <acowley> But providing a Core and STG frontends is a popular request
14:14:09 <orion> Let's say the last line of my main function is "waitAnyCancel [foo, bar, baz]" If I throw SIGINT to the process, is it possible that the whole process will die before the finalizers in bar and baz have a chance to run?
14:16:35 <b0llu> cocreature: yep, hand written 
14:17:15 <cocreature> b0llu: so given that you can’t feed it to ghc to compile & run it, profiling is going to be hard :)
14:17:54 <acowley> There is http://hackage.haskell.org/package/ministg though possibly bitrotted
14:17:58 <mniip> hvr: prod
14:18:39 <cocreature> acowley: yeah but if you are interested in performance (which you usually are if you’re profiling) you probably want to use ghc
14:19:14 <cocreature> there is also https://github.com/quchen/stgi#readme but that won’t help you with profiling either
14:19:17 <b0llu> cocreature: yeah :) that's what I was thinking. It's quite unfortunate though 
14:19:29 <b0llu> cocreature: I wanted to implement STG in rust and compare performance 
14:19:36 <suffi> hey im going rthrough the haskellbook right now, anyone here that can help me writing an Applicative instance for the Constant type?
14:19:52 <acowley> What you can do is tweak some Haskell until it generates the STG you want
14:19:54 <suffi> newtype Constant a b = Constant { getConstant :: a } 
14:20:02 <acowley> so reverse compile the STG you want to write into Haskell
14:20:13 <acowley> Also pronounced "mpile"
14:20:37 <b0llu> acowley: is that a categoeu theory joke? :)
14:20:44 <b0llu> acowley: that sounds like a decent idea 
14:21:11 <acowley> It's a joke in the category of bad
14:21:33 <acowley> Dan Doel did a nice talk about STG as a language a couple years ago
14:21:41 <shapr> acowley: argh, mpile
14:21:56 <acowley> I can't remember exactly what approach he used to deal with the lack of a straightforward compilation strategy
14:22:08 <b0llu> acowley: yeah, I have winter break, so I'm considering implementing STG to understand it properly 
14:23:01 <acowley> b0llu: It'd be great to have a modern STG compiler that isn't chained up in GHC's basement
14:23:18 <acowley> I wish I was more familiar with it
14:23:31 <b0llu> acowley: I'm no expert in performance though :) just interested. I'll take a stab and report back 
14:24:02 <b0llu> can I have some category theory help BTW? I want to understand how "every lambda calculus term is a functor" 
14:24:49 <acowley> Expertise not required! Compiler optimization is so broad that you end up with a suite of loosely coupled techniques. It's great to learn because there's no giant up-front learning investment needed, you can add pieces as you go.
14:25:17 <b0llu> xD that's nice then! 
14:25:30 <b0llu> I also want to work on GHC at some point. But the codebase size is so daunting
14:26:20 <EvanR> well the first question is what category its coming from, where its going
14:26:24 <acowley> I don't know how to interpret that CT quote either. A functor is a mapping between categories that preserves identities and composition.
14:26:55 <EvanR> what category would \x . x x come from
14:31:40 <EvanR> b0llu: lambda calculus is the internal language of cartesian closed categories
14:33:19 <EvanR> so you could write down terms inside such a category, now if that category were a category of functors...
14:37:35 <ski> b0llu : context ?
14:38:12 <b0llu> ski: it's from the F is for functor paper 
14:38:42 <b0llu> Ski: i was sleepy when I read it, but it said something along the lines of "you can think of every simply typed lambda calculus term as some appropriate functor" 
14:39:47 * ski hasn't seen that paper
14:42:43 <c_wraith> wait.. is \x.x x even simply typed? 
14:43:05 <EvanR> "In general, the interpretation
14:43:05 <EvanR> of a λ-term is an arrow from the interpretation of its free
14:43:06 <EvanR> variables to the interpretation of its type."
14:43:13 <Tuplanolla> No.
14:43:42 <EvanR> a lambda term can be interpreted as a functor, which makes sense
14:44:19 <monochrom> \x. x x is simply untyped :)
14:44:54 <b0llu> Monochrom: :) 
14:44:58 <b0llu> So, any explanations? :3
14:45:09 <EvanR> (thats straight from the paper you mentioned)
14:46:14 <b0llu> EvanR: I don't understand it 
14:46:36 <b0llu> EvanR: what does "interpretation" mean and in what category? :( 
14:47:11 <ski> it has type ⌜∀ ω. α where α = α → ω⌝
14:47:55 <c_wraith> that's definitely not simple. 
14:48:41 <monochrom> or maybe it's simply equirecursively typed
14:49:21 <monochrom> but then it would be stretching how often we get to say "simply"
14:49:22 <EvanR> b0llu: interpretation sends a lambda term to something. exactly what, "ideally" is some direct thing involving the interpretation of its components
14:49:42 <EvanR> until you get to a thing without components
14:54:00 <b0llu> EvanR: could you take an example and illustrate? What about \x -> x + 1
14:54:15 <EvanR> so + and 1 are free here
14:54:16 <b0llu> Where is the "functor"
14:54:20 <b0llu> Right 
14:54:48 <monochrom> you need two categories before you can ask where is the functor
14:54:54 <EvanR> lets say the type of that is Int -> Int
14:55:22 <b0llu> Sure 
14:55:31 <monochrom> I don't know which categories the paper uses, but perhaps you should figure that out first.
14:55:32 <EvanR> i guess we can say the source category is Haskell, but it doesnt have to be
14:56:15 <monochrom> A paper could also be very fast-paced, so it could mention the answer in only 3 words that you easily miss.
14:58:22 <b0llu> EvanR: okay, go onc
14:58:28 <b0llu> Monochrom: point noted :) 
15:03:45 <EvanR> ok
15:04:34 <EvanR> b0llu: so lets say you have a cartesian closed category C
15:05:18 <b0llu> Sure 
15:05:23 <EvanR> which means it has products and exponentials, and a terminal object
15:06:16 <EvanR> you wish to interpret (\x . x + 1) : Int -> Int in C
15:06:37 <Aleksejs> Hi, is there some special reason why zip source is not "zipWith (,)"?
15:06:50 <EvanR> the interpretation is going to be an arrow in C
15:06:56 <geekosaur> history probably
15:07:08 <EvanR> but you have to say what the source and target of that arrow will be
15:07:24 <b0llu> Right 
15:07:52 <EvanR> for the target, you have to assign Int -> Int to an object in C
15:08:03 <geekosaur> zipWith likely came later, and zipWith (,) probably didn't optimize well in early ghc / hugs / nhc98 versions (the latter two no longer being relevant)
15:09:21 <b0llu> EvanR: wait what? Repeat that again. What is the source and what is the target? 
15:09:31 <EvanR> thats the only thing we have to answer
15:09:51 <EvanR> i didnt choose yet
15:10:36 <geekosaur> Aleksejs, also note that (,) is in fact special syntax and might not have worked well in some compilers
15:10:58 <geekosaur> (even modern ghc requires you to enable an extension to use it in sections)
15:11:17 <Aleksejs> geekosaur: I think modern ghc supports it by default
15:11:29 <mniip> "in sections"
15:11:34 <geekosaur> ^
15:11:37 <Aleksejs> ah
15:11:37 <mniip> you need -XTupleSections
15:11:51 <geekosaur> (,) works, but (foo,) requires TupleSections. the syntax is difficult.
15:12:30 <geekosaur> so avoiding that as a requirement in a production compiler would help encourage implementations. (not that that has had much success in the Haskell arena...(
15:13:50 <EvanR> b0llu: the two things here are... the Int -> Int will be interpreted as an exponential object in C, which one, it depends on how you interpret Int. if you interpret it as object X, then Int -> Int would be X^X
15:14:35 <EvanR> b0llu: the other thing here is, the assignment of types to the free variables 1 and + is done with a context, and you can build that context with the terminal object in C followed by repeated product-ing
15:14:45 <EvanR> with other objects
15:15:17 <b0llu> "And you can build that context..." you lost me after that 
15:15:26 <b0llu> How exactly does the terminal object help here? 
15:15:33 <EvanR> the empty context is interpreted as the terminal object
15:15:53 <b0llu> Ah 
15:16:10 <EvanR> then you need to answer what the type of 1 is
15:16:27 <b0llu> EvanR: so you're thinking of it as a monoid? "Building up context" as a monoid homomorphism? 
15:16:53 <EvanR> not a monoid homomorphism, its just a dumb list of objects
15:18:51 <b0llu> Okay 
15:19:10 <EvanR> if [[Int]] = I : C, then your context specifying the types of 1 and + would be (* x I) x (I^I)^I
15:19:25 <b0llu> EvanR: all you had to do was map the types to objects, the function to an arrow, and then the context to some objects in C? 
15:20:07 <EvanR> according to the paper
15:20:24 <b0llu> I see. I missed that :) 
15:20:46 <EvanR> and the interpretation type of the lambda term, [[Int -> Int]] -> I^I
15:21:15 <EvanR> i mean to say = there
15:21:31 <EvanR> and the interpretation of the whole thing, (* x I) x (I^I)^I -> I^I
15:21:42 <EvanR> well, an arrow of that type
15:21:45 <b0llu> Hm 
15:22:10 <EvanR> finally, if C = category of categories with functors between them... that is what they were trying to pull
15:22:11 <b0llu> Wait. The lambda term is "that arrow" between the LHS and RHS right? 
15:22:18 <EvanR> its an arrow
15:22:19 <b0llu> So you map to types, not values? 
15:22:42 <EvanR> arrows are values
15:23:02 <EvanR> i didnt specify which arrow yet, just the type
15:23:02 * ski . o O ( "values are arrows" )
15:23:12 <b0llu> Ah hm 
15:23:16 <glguy> sm: Did you manage to write your solution to 1a in such a way that it was unusable for 1b?
15:23:24 <b0llu> So you described the Hom set, not which arrow? 
15:23:37 <EvanR> we described the source and target
15:23:50 <EvanR> i messed up saying thats all we needed, but theres more
15:24:23 <b0llu> Okay. What else do we need? 
15:24:27 <geekosaur> but wait, there's more!
15:24:28 <EvanR> the exponential object comes with a way to build lambda arrows and applications
15:25:07 <b0llu> EvanR: I don't see how it lets us build application 
15:25:37 <Darrin> Hey guys I got a quick question in the following code:
15:25:39 <Darrin> describeList :: [a] -> String   describeList xs = "The list is " ++ case xs of [] -> "empty."                                                  [x] -> "a singleton list."                                                   xs -> "a longer list."  
15:26:01 <EvanR> its the eval diagram
15:26:01 <Darrin> Err wait...
15:26:07 <geekosaur> @paste
15:26:08 <lambdabot> Haskell pastebin: http://lpaste.net/
15:26:23 <geekosaur> far easier to use a pastebin
15:26:36 <b0llu> Hm 
15:27:09 <Darrin> In the following code: http://lpaste.net/350045       Why can you put 
15:27:15 <Darrin> 'x' inside brackets [ ]
15:27:29 <glguy> > [1]
15:27:30 <Darrin> to me that seems like your breaking up the variable 'xs'
15:27:31 <lambdabot>  [1]
15:27:48 <glguy> Yeah, you're creating a pattern that xs is being matched against
15:27:49 <EvanR> b0llu: eval : Z^Y x Y -> Z ;)
15:27:50 <geekosaur> Darrin, it's a pattern. the *point* is to break up xs
15:28:01 <geekosaur> we also call them deconstructors
15:28:02 <EvanR> its basically ($)
15:28:25 * ski always found it strange that it's (often ?) called `eval'
15:28:32 <geekosaur> so [x] as a pattern against a list xs is a single element list, whose element is captured as x
15:28:36 * ski 'd prefer `app' or `apply' or something
15:28:40 <EvanR> heh
15:29:08 <b0llu> EvanR: oh :) 
15:29:12 <geekosaur> you can also write that pattern as (x:[]) which makes the cons cell structure visible
15:29:32 <b0llu> EvanR: OK, makes sense 
15:29:36 <Darrin> Oooh so x and 'xs' are different?
15:29:50 <ski> they are different variable names
15:30:08 <geekosaur> yes and no. xs is also a pattern, but it matches anything as used here so it acts like a normal function parameter as in other languages
15:30:24 <Darrin> that makes much more sense.  I thought they were like splitting the variable 'xs' into two parts or something
15:30:48 <geekosaur> oh, I see, you have xs also as a case pattern
15:30:56 <geekosaur> that's actually a different xs from the function parameter pattern
15:30:57 <Darrin> So why not use _ instead of x in this case?  Isn't the point of _ to mean we don't care what the value is?
15:31:06 <geekosaur> it matches anything, so you recover the original list in it
15:31:19 <ski> they're checking whether it's (a) of the shape `[]' (empty list); or (b) of the shape `[x]' (singleton list, with the single element being named `x'); or else (c) of the shape `xs' (which matches any list, since it's just a variable name)
15:31:27 <geekosaur> and here, you could indeed use _ in place of both x and the second xs, since all you are actually matching is the list structure
15:31:34 <ski> Darrin : `_' could be used in the last case here, yes
15:31:39 <Darrin> @ski  That makes sense
15:31:39 <lambdabot> Maybe you meant: wiki src ask
15:31:47 <mniip> [_] is a valid pattern too
15:31:52 <mniip> so yes to your question too
15:32:07 * ski nods
15:32:20 <geekosaur> but it can be easier to use variables now and point out _ later, to avoid hitting learners with too many new concepts at once. Haskell does enough of that already :)
15:32:42 <glguy> Darrin: @ is for bot commands
15:32:59 <ski> (btw, note that the `xs' in the last case is actually a new variable, which as it happens to be spelled the same as the old `xs', will shadow it. but in this case, it will be bound to the same value, so the shadowing doesn't matter here)
15:33:12 <EvanR> b0llu: in the paper, someone blurted out to use Cat as the category, in which case you have functors as arrows. 
15:33:34 <Darrin> Mmk thanks guys I got my question answered.  I'm going to continue on with the book.  Thanks!
15:33:37 <b0llu> Ahh. Okay, let me go back and read again :) 
15:33:53 <ski> Darrin, yw
15:34:21 <ski> (not a lurker, apparently)
15:34:22 <EvanR> so the idea that its a specific functor from a specific category to another was a red herring
16:07:40 <Gurkenglas> When I see something like http://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/src/GHC.Tuple.html#%28%2C%29 , can I be sure there's nothing more to (,), so I can say things like "Tuples can't possibly be faster than data-constructed types"?
16:09:05 <geekosaur> might be more of a #ghc question, but as far as I know the only magic in tuples is some syntax/lexical support (needed because both comma and parentheses mean too many other things already)
16:09:27 <geekosaur> unboxed tuples might be another question
16:09:32 <MarcelineVQ> Isn't the constructor dissapeared unlike with data?
16:09:46 <geekosaur> only for unboxed
16:09:52 <MarcelineVQ> I see
16:10:19 <Gurkenglas> Do I need to ask this question before being able to say sentences like that one?
16:11:11 <Gurkenglas> (As in, can I look how stuff works up on GHC.Prim and the like, or is that just the magic pretending to be reducible. That unboxed tuples behave differently is fine)
16:24:09 <nshepperd> I'm not sure I would trust anything in ghc-prim
16:25:19 <nshepperd> the primops are defined as like 'primop# = primop#' for example
16:26:23 <geekosaur> aren't they all let x = x in x?
16:26:49 <geekosaur> (they're placeholders, basically; primops compile to machine code, the haskell code is ignored)
16:29:09 <khumba> Hmm, my package was assuming that the initial directory of a Cabal build (e.g. in a configure hook) is the root of the package, but with GHC 8/Cabal 1.24 it seems that's not the case.  What's the best way to find it?  takeDirectory on pkgDescrFile?
17:17:39 <tommy`> I have a question about Traversable
17:18:40 <sm> it's quite unfortunate that GHCI chokes on the !! operator
17:19:32 <lyxia> tommy`: what is it
17:19:46 <tommy`> Does anyone know how to define traverse in the presence of a indirectly define recursive data structure?
17:19:57 <tommy`> Example: data RT = RT (T RT)
17:19:57 <tommy`> data T c = D | E c | F [c]
17:20:21 <lyxia> RT is not of the right kind
17:20:37 <tommy`> If leave out the F then I have no problem
17:20:42 <shane_> Is it possible to loop through all types in a type class? Specific example looping through types of Suite and Rank to generate a full deck of playing cards.
17:20:51 <tommy`> If I make it directly recursive the it works too.
17:21:12 <lyxia> tommy`: what type does traverse have for RT
17:22:49 <tommy`> @lyxia: tr :: Applicative f => (a -> f b) -> f (T b)
17:22:49 <lambdabot> Unknown command, try @list
17:22:55 <lyxia> shane_: why not define Suite and Rank as datatypes
17:22:55 <tommy`> lyxia: tr :: Applicative f => (a -> f b) -> f (T b)
17:23:22 <lyxia> tommy`: There is no RT
17:24:05 <lyxia> :t traverse -- its actual type
17:24:07 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:24:14 <stepcut> what is the simplest way to get low-level keyboard IO with GHC. I want to be able to get key press and release events. I can use SDL, GLFW, or ncurses to get that -- but they all have a bunch of graphics stuff I don't really care about 
17:25:20 <geekosaur> ncurses will not get you both press and release events
17:25:47 <lyxia> tommy`: traverse f (F cs) = F <$> traverse f cs
17:25:48 <tommy`> Full disclosure: I'm trying to generalize Test3.hs from data-reify from binary operators to n-ary.
17:25:50 <geekosaur> and yes, most ways to get low level events like that are part of graphics libraries.
17:27:24 <tommy`> OHH.  That works!  Thanks lyxia.  I thought I had tried that.
17:28:54 <geekosaur> stepcut, basically the only way to get those events without using the GUI is to shut down the GUI.
17:30:01 <geekosaur> otherwise you must interact with the GUI to receive the events that are directed by it to your program, so you must use a graphics library
17:31:11 <geekosaur> on linux, the lowest level you can use is X11; from Haskell you could use the X11 package (based on Xlib) or xhb (direct binding to X11 primitives equivalent to xcb) 
17:32:44 <stepcut> hmm
17:32:56 <stepcut> maybe I should skip the console app and go straight to the web app
17:38:06 <stepcut> geekosaur: so I guess things like nethack that give the appearance of detecting keydown vs keyup events are just relying on key repeat instead?
17:38:14 <geekosaur> yes
17:38:24 <geekosaur> they can only receive characters, not key down/up events
17:38:46 <stepcut> would that limit me to one key down at a time?
17:38:56 <geekosaur> that you could discern, yes
17:39:13 * stepcut ponders
17:39:18 <geekosaur> note that some things of this sort are not built into e.g. nethack, but into the terminal emulator
17:39:27 <geekosaur> you can often see them somewhere in the preferences
17:39:27 <stepcut> right
17:40:13 * stepcut wonders if netwire-input-glfw will install on the RPi3/raspbian
17:40:36 <stepcut> actually, that doesn't matter
17:40:41 <stepcut> because I only have ssh access
17:42:03 <stepcut> so.. webapp it is I guess
17:42:55 <EvanR> aalib bindings for maximum ascii goodness
17:43:09 <EvanR> you could do FMV cutscenes... all in ascii
17:44:48 <stepcut> now.. which FRP library should I use for a robot?
17:50:42 <shane_> @lyxia about my card deck question, I don't quit understand what you mean by "datatype" as opposed to what I have now: data Suit = Clubs | Diamonds | Hearts | Spades
17:50:42 <lambdabot> Unknown command, try @list
17:51:03 <shane_> lyxia: about my card deck question, I don't quit understand what you mean by "datatype" as opposed to what I have now: data Suit = Clubs | Diamonds | Hearts | Spades
17:51:25 <geekosaur> then where is the typeclass?
17:55:13 <geekosaur> for types with only nullary constructors like your Suit, you can derive Enum and Bounded and use them to iterate through constructors
17:57:31 <shane_> geekosaur: I guess I'm mixing up terms, then.
17:57:56 <shane_> how would I go from data Suit = Clubs | Diamonds | Hearts | Spades to [Clubs, Diamonds, Hearts, Spades]?
17:58:32 <geekosaur> data Suit = Clubs | Diamonds | Hearts | Spades deriving (Enum, Bounded); [minBound :: Suit .. maxBound]
17:58:42 <ertes> helo
17:59:04 <geekosaur> (or: [minBound .. maxBound] :: [Suit])
18:01:02 <jmnoz> does anyone perchance happen to know how to print to stdout from inside a Snap () monad?
18:02:33 <geekosaur> without looking, probably liftIO $ putStrLn ...
18:03:00 <geekosaur> yep, it has a MonadIO instance
18:03:04 <jmnoz> thanks!
18:03:56 <shane_> geekosaur: thanks so much!
18:04:25 <jmnoz> for some reason I'm not seeing the output but I guess it prints it to somewhere :/
18:05:18 <geekosaur> will depend on the platform (windows does some "interesting" things with stdout/stderr) and/or how you're running it
18:05:56 <jmnoz> ah, ooh oh noes
18:06:06 <geekosaur> if you are using it hooked into an apache server then you must be careful because stdout is the web connection and stderr is the http error log
18:06:41 <geekosaur> (snap should be its own server normally though)
18:08:25 <geekosaur> most web applications use some kind of logging framework instead of stdout, specifically because you have control over where that output goes, instead of relying on exactly how the application is run and any platform oddness
18:08:34 <jmnoz> yeah I'm using Snap's startServer
18:09:15 <jmnoz> will be looking into that mos def
18:10:24 <sm> shapr: right behind you on AoC :)
18:16:59 <stepcut> anyone here knowledgable about GHC on ARM?
18:17:22 <athan> stepcut: You need a good amount of RAM :/
18:17:32 <athan> but what were you needing?
18:17:36 <stepcut> I am trying to figure out if there is a 'generic linux GHC for ARM' tarball that I can use to bootstrap with or if I have to build my own via cross compilation
18:17:57 <stepcut> I have an RPi3 which has less RAM than I would like, but does have swap enabled
18:18:19 <athan> nope, both 8.01 and 7.8.2 are available as binaries, you just have to dig a bit to get them
18:18:41 <athan> also, if you're using stack, you have to tell it that you're using your system GHC so it doesn't try to fetch
18:18:51 <stepcut> not using stack
18:19:05 <athan> but yeah, I've got a pi 2, and i couldn't build stack even after 3 days of running :/
18:19:11 <athan> oh right on
18:19:23 <athan> it was capable of building trivial libraries at least
18:19:29 <stepcut> oo! found the page
18:19:34 <athan> :)
18:19:58 <stepcut> The efforts to 'improve' haskell.org have made it harder to find this page
18:20:14 <stepcut> but finally found the right google search terms
18:20:39 <stepcut> my aim is to get ghc for arm into nixos
18:29:50 <Gurkenglas> http://stackoverflow.com/questions/41194824/data-structure-request-lazily-infinite-set
18:30:24 <EvanR> this question is pretty old
18:32:22 <glguy> sm movin' up on the board
18:32:29 <EvanR> might be a job for topless data of some sort
18:33:28 <EvanR> Gurkenglas: do we get Eq or Ord or anything?
18:33:38 <Gurkenglas> Right, Ord ofc
18:34:37 <EvanR> how will elem' ever return False, if this is an infinite set?
18:35:13 <EvanR> Bounded ?
18:35:29 <nshepperd> Gurkenglas: is that supposed to be 'elem x (take n $ iterate f y)' there?
18:35:37 <nshepperd> n is the 'depth of search'?
18:35:40 <EvanR> even with that, my idea would be out
18:35:50 <Gurkenglas> Gah, forgot to use n, fixed
18:36:34 <EvanR> ah
18:36:34 <sm> glguy you got me hooked
18:36:39 <Gurkenglas> Perhaps I should make it less compulsory to have it search up to exactly n... but that should only incur constant factors
18:38:51 <nshepperd> I'm also not sure what your second line means. it's O(log n) on any collection that has already been evaluated?
18:38:58 <Gurkenglas> Yes
18:39:43 <Gurkenglas> How should I write that? I thought that since I'm assuming that x and y and f in the first line incur no extra time/space, I can assume the same about xs in the second
18:39:44 <EvanR> mkay
18:40:31 <EvanR> Node (Maybe Node) a (Maybe Node)
18:41:16 <EvanR> inserting will get slower and slower though
18:42:22 <Gurkenglas> Fine so long as it's logarithmically slower
18:42:31 <c_wraith> only if it's balanced
18:44:10 <EvanR> what are the semantics for the Int supposed to be
18:44:34 <EvanR> number of iterations of the function
18:44:34 <Gurkenglas> Set is balanced, and maybe there's a way to use it? (iterate' f = scanl S.insert S.empty . iterate f already only takes O(nlogn) time and space (and elem' is linear ofc because of !! :P))
18:44:56 <Gurkenglas> EvanR, elem' n x (iterate' f y) == elem x (take n (iterate f y))
18:45:06 <EvanR> ok
18:45:29 <EvanR> alright so
18:45:44 <EvanR> you internally use impurity and a regular Set
18:45:52 <EvanR> track the number of iterations you did
18:46:00 <Gurkenglas> "impurity" :(
18:46:01 <EvanR> if they ask for more, iterate and add to the set
18:46:16 <EvanR> theyll never know the difference
18:46:35 <Gurkenglas> Can you use impurity internally without unsafe functions?
18:47:04 <EvanR> i imagine something is going to say unsafe somewhere in here
18:47:20 <EvanR> but it would actually be safe
18:47:46 <Gurkenglas> (Hmm... I could say elem x (take n (iterate f y)) => elem' n x (iterate f y) => elem x (iterate f y) to allow data structures that do even better)
18:48:11 <stefan-__> is there a package for sparse vectors, which are indexed by integer?
18:50:04 <EvanR> i can see another way the construction should proceed that would not involve reallocating anything
18:52:10 <EvanR> again involving secret impurity, the constructing agent would wait for requests and have a directory of IVars which represent leaves of the tree. if someone asks for past the iteration counter, he generates new values and inserts them at the end and updates the directory
18:52:31 <EvanR> otherwise traverse the tree from the root
18:53:02 <EvanR> maybe not IVars since you need to be able to know you hit the end, and return False
18:53:35 <EvanR> i have no idea how to do this in haskell
18:56:32 <EvanR> tracking the end points, might as well just keep an updated tree
18:57:34 <lpaste> glguy pasted “toward Gurkenglas's data structure” at http://lpaste.net/350050
18:58:07 <glguy> something like this could work for allowing laziness to be your update mechanism
18:58:25 <glguy> this doesn't solve the problem directly, just exploring
18:59:27 <EvanR> recurse on buildT ?
18:59:33 <glguy> Oh yeah
19:00:13 <glguy> or something like a list of search trees each with twice as many elements as the previous
19:00:14 <Gurkenglas> Degenerates logarthmic into linear though. Maybe one could even prove that you need updating to solve that problem
19:00:59 <EvanR> if its conceptually infinite, does it actually have any balancing issues
19:01:01 <Gurkenglas> glguy, then you'd need to search each though, for O(log^2) elem', or duplicate entries, for...
19:01:08 <EvanR> you can never reach a leaf node
19:01:15 <Gurkenglas> Huh, only a constant factor of extra space? That might do it!
19:01:24 <sophiag> do i need to tell the stack resolver when i'm moving source files? i just switched to using stack so am not that familiar with it and moving files to subdirectories seems to cause it to not compile
19:02:17 <Gurkenglas> EvanR, you'd have to take arbitrary time to get to the next node even if it's not in the first n elements
19:02:47 <EvanR> the max is at least n
19:02:51 <EvanR> er, at most
19:02:59 <EvanR> er, is n
19:03:18 <EvanR> which, is more than log n, but its not arbitrary
19:03:51 <EvanR> youre right it could cause a performance issue
19:04:55 <EvanR> and if you wanted to rebalance you wouldnt even be able to
19:06:57 <EvanR> Gurkenglas: know what im thinking... a lazily generated graph, lookup would be a parallel graph traversal
19:07:14 <EvanR> youd have to do the manual laziness thing here also
19:07:46 <Gurkenglas> Why would it be max n? You ask for the next node that will be placed as a left child of your current node... and then you wait forever
19:08:01 <Gurkenglas> iterate' (+1) 0
19:08:10 <Gurkenglas> (then lookup -1)
19:08:50 <Gurkenglas> Umm, scratch my last two lines, but not the third before this one.
19:09:37 <EvanR> youre right
19:10:28 <EvanR> you would need to search the tree in parallel
19:11:32 <EvanR> unamb
19:13:50 <EvanR> which would actually fix the issue earlier with encountering unfilled ivars
19:15:05 <tommy`> stepcut: [late follow up] FWIW, You might look into ODROID-C2.  It's 64-bit Quad Core ARM with 2 GB, comparable to RPi3 but better.  I have gotten things running there with swap.
19:15:51 <lpaste> nshepperd pasted “For Gurkenglas” at http://lpaste.net/350052
19:15:56 <Gurkenglas> Solved it <.<? http://stackoverflow.com/a/41195030/5318306
19:16:10 <nshepperd> lazy map of Int -> Set a
19:16:30 <EvanR> nice
19:16:34 <nshepperd> could probably be more efficient if it was balanced
19:16:49 <nshepperd> as it is I think it takes up O(n log n) memory rather than O(n)
19:17:26 <EvanR> do you mean also want the Int -> Set a to memoize?
19:18:01 <Gurkenglas> (flip S.insert, not S.insert)
19:19:12 <EvanR> this last solution is more elegant, but you have to use !! right
19:19:37 <EvanR> might be detrimental for large n
19:19:43 <Gurkenglas> nshepperd, oh O(n log n) memory because all the dropped non-power-of-two sets are still allocated, right? I think thats right dang
19:19:44 <nshepperd> my thing is basically just a memoized verison of 'sets n = Set.insert (f^n x) (sets (n-1))'
19:20:09 <nshepperd> an infinite list of sets where each set is the previous set plus the next iterated value
19:20:15 <Gurkenglas> Can you even do finite sets in O(n) memory if you have to balance them
19:20:53 <nshepperd> it could be O(n) memory if each set was an efficent hedge union of some previous sets
19:21:13 <nshepperd> (I think?)
19:22:19 <nshepperd> maybe not. not sure
19:22:39 <stepcut> tommy`: yeah, I have considered it. 
19:22:52 <EvanR> maybe adding more support than Ord could help somehow?
19:23:39 <stepcut> tommy`: or the ODROID-XU4
19:26:29 <jelloslice> hello : )
19:26:30 * nshepperd reads Gurkenglas' solution
19:27:28 <nshepperd> oh, that could be O(n) memory indeed, I think
19:27:52 <EvanR> no
19:28:02 <EvanR> the old paths in the tree will be kept around
19:28:28 <EvanR> unless you drop parts of that list
19:29:34 <nshepperd> Gurkenglas' solution has O(log n) sets
19:29:49 <jelloslice> I had a noob question - would be very grateful for help
19:29:54 <EvanR> sure
19:30:09 <jelloslice> http://lpaste.net/350053
19:30:14 <nshepperd> each taking up [O(n), O(n/2), O(n/4), ...] memory
19:30:22 <nshepperd> which sums up to O(2n) = O(n)
19:30:37 <EvanR> huh
19:30:57 <glguy> jelloslice: You're defining two different functions 'f' there
19:31:14 <glguy> the second let makes a brand new function and names it 'f', hiding the previous one
19:31:54 <jelloslice> ah, so pattern matching only looks at the last definition?
19:32:03 <glguy> jelloslice: There are ways to input a multi-clause function definition in GHCi, but you'll do better to save thing work in a file and then load it with ghci
19:32:05 <EvanR> ah interesting
19:32:09 <glguy> as you change your file you can use :r
19:32:13 <glguy> to reload it
19:32:32 <EvanR> accumulating and remembering old sets forever only gets you O(n) memory
19:32:47 <glguy> jelloslice: Yeah, only the Nothing case is being considered here. If you had defined those two clauses all at once (or put them into a file) then both would work
19:32:58 <glguy> each use of "let" start a new set of definitions
19:33:18 <EvanR> can you somehow get rid of the !! operation?
19:34:09 <nshepperd> as long as you only remember an exponentially diminishing fraction of old sets
19:34:41 <nshepperd> you could use a trie or something instead of the list, but it wouldn't affect the asymptotic complexity
19:34:43 <Gurkenglas> EvanR, I could throw nshepperds Int tries at it? <.<
19:34:47 <nshepperd> that !! is already log n
19:35:04 <EvanR> interesting
19:35:29 <EvanR> but thats a different semantics
19:35:46 <EvanR> n was supposed to see anything up to iteration n
19:35:47 <nshepperd> Gurkenglas: your solution technically doesn't obey the spec in that elem' n = elem' (next power of two from n)
19:35:53 <nshepperd> yeah
19:36:19 <EvanR> you could accelerate the progress that n implies and change the semantics
19:36:26 <Gurkenglas> I edited the spec before I thought (more like stole from glguy) of the solution
19:36:40 <Gurkenglas> elem x (take n (iterate f y)) ⇒ elem' n x (iterate' f y) ⇒ elem x (iterate f y)
19:36:58 <EvanR> 4 means generate 16, 5 means generate 32
19:37:05 <Gurkenglas> You need to find if its within n, but youre only allowed to not find if its nowhere at all
19:37:28 <Gurkenglas> *only not allowed to find <.<
19:37:37 <nshepperd> EvanR: that might actually be nicer since it does away with the floating point logarithm
19:37:37 <EvanR> yes, taking the log means you might find it even if its going to be there in a minute
19:37:42 <tommy`> stepcut: indeed, but the C2 is 64-bit.  Prompted, I found two 4 GB option: NVIDIA Jetson TX1 ($600) and Cubox-i 4X4 ($180)
19:37:53 <EvanR> you might not find it*
19:38:30 <sophiag> um, so asking again: can anyone tell me why running "stack ghc" stops producing executables if i move the location of source files? i can't find anything about it in the faq and was just using ghc with cabal until i had to downgrade oses recently
19:38:57 <ezyang> sophiag: In more detail? 
19:39:08 <ezyang> e.g., what command are you running? 
19:39:12 <stepcut> tommy`: sure. But my primary use would be to use it as a build slave for machines that are 32-bit
19:39:18 <sophiag> "stack ghc" ...as noted previously
19:39:51 <sophiag> not sure what more detail there is to give. it works fine... stops working if i move the source file to a different dir
19:39:52 <stepcut> though, the C2 might still be a better choice
19:40:22 <tommy`> stepcut: the Cubox-i 4X4 is actually 32-bit (so really only 3.8 GB)
19:40:53 <ezyang> So, to be completely clear, you are running "stack ghc" with no arguments 
19:41:15 <sophiag> i suppose i have to create a new source file and copy the contents so the resolver history is clean?
19:41:24 <geekosaur> ...what
19:41:29 <sophiag> seeing as there's nothing about this on the stack site?
19:41:34 <geekosaur> whatever you are doing is not stack's intended usage
19:41:51 <geekosaur> so no, I doubt they have much help for it
19:41:55 <sophiag> i have to use ghc through stack if i want to use beyond 7.08
19:42:09 <sophiag> that's the last version that will ever be released for my os
19:42:14 <sophiag> even with manual builds
19:42:21 <sophiag> it's documented on github
19:42:33 <ezyang> I'm still really confused. 'stack ghc' is supposed to just be a way to call through to ghc right? 
19:42:45 <nshepperd> sophiag: please give the actual command line, and the error message
19:42:51 <geekosaur> but if stack ghc is being remapped to stack exec ghc, then it only knows the files in the current directory and it has zero project support
19:43:03 <sophiag> there's no error message
19:43:05 <geekosaur> just like ghc itself
19:43:08 <sophiag> it appears to work
19:43:17 <stepcut> tommy`: yeah, I looked at the Cubox as well. Also, I looked at used OnePlus One phones which can be rooted, and have 3GB of RAM and quadcore 2.5GHz snapdragon 801
19:43:27 <sophiag> the files are all there as well
19:43:38 <sophiag> but they won't launch...and i've checked chmod
19:43:45 <glguy> sophiag: Imagine that people can't see your computer screen on look in your head, so they only know what you're telling them about your arrangement of files
19:43:56 <glguy> they can't guess command arguments, files, directory structure, intent
19:44:14 <sophiag> the error is "bash: no such file or directory"
19:44:52 <sophiag> whereas if i move the source back to where it was created, run stack ghc again, it's fine
19:45:05 <geekosaur> that sounds like something else is wrong
19:45:20 <nshepperd> stack ghc what
19:45:28 <sophiag> stack ghc "filename"
19:45:29 <geekosaur> the command you are typing that produces that is... what? exactly? not a prefix of it, not part of it, the whole command
19:45:30 <tommy`> stepcut: and what are you current thought on these options?  RPi3 is a brick wall AFAICT.
19:45:37 <tommy`> *thougts
19:45:44 <sophiag> ./filename args
19:45:56 <sophiag> :bash filename no such file or directory
19:46:17 <sophiag> again, this only occurs if i move the location of the source file
19:46:31 <ezyang> sophiag: Can you run your command, move the source file, run it again, and then copy paste the entire transcript into http://lpaste.net 
19:46:33 <sophiag> and never occurred before i used stack
19:46:34 <geekosaur> I would suggest you stop using "stack ghc" and start using: stack exec -- ghc
19:46:41 <geekosaur> which is not the same thing and which should behave like ghc
19:46:54 <ezyang> the transcript will include the command lines and the output you get, as well as the intermediate commands you used to run it 
19:47:04 <geekosaur> what you are getting now sounds like stack is using a project, possibly the global project, and yes you will have problems if you randomly copy or move stuff around
19:47:19 <sophiag> "stack exec --ghc" is an invalid command
19:47:40 <geekosaur> no quotes. spaces are NOT optional
19:47:46 <geekosaur> stack exec -- ghc filename
19:47:48 <glguy> That's not what geekosaur suggested that you type, and it's not the error message you got
19:48:14 <geekosaur> for whatever your filename is (do not change the rest)
19:49:34 <sophiag> it produces the same erorr code
19:49:47 <sophiag> i can repeat the error code again if that helps?
19:49:57 <sophiag> "bash: ./filename: No such file or directory"
19:49:58 <nshepperd> do what ezyang said
19:50:31 <ezyang> Also stick in a call to 'ls' for good measure 
19:50:44 <stepcut> tommy`: it really depends on the project. Right now I am actually looking at a project that would use a lot of the C.H.I.P. systems from getchip, but they are slow with even less ram. I have the RPi3 for use with some projects that require RPi Hats.
19:51:38 <tommy`> :) I have C.H.I.P.s too and actually deployed one.  However run running Haskell
19:51:47 <tommy`> *not running Haskell
19:52:01 <sophiag> well, it stopped working now entirely
19:52:08 <stepcut> tommy`: I might run Haskell apps on the CHIP but I would hopefully compile them elsewhere
19:52:13 <ezyang> well, paste it anyway 
19:52:19 <geekosaur> sophiag: you are doing something wrong. we cannot tell what as you don't seem to produce accurate reports of what you have done or what the result is. attention to detail is important here; build tools do not "oh that's close enough", they trust what you gave them.
19:52:49 <sophiag> oh, wait it's because it's the same as a directory name now
19:52:51 <sophiag> so i can't run it
19:52:53 <stepcut> tommy`: I'd also love to get sel4 working on the CHIP -- or something similar. That is a semi-pointless on the RPi since the RPi's have a ton of binary blobs
19:53:14 <sophiag> what you're asking me to do is irrepreducable... lol, but i'll paste it anyway
19:53:44 <tommy`> stepcut: I like how you think and I suspect you might be following the RISC-V development too
19:54:47 <sophiag> ezyang: http://lpaste.net/350054
19:55:06 <tommy`> (No matter which platform, I always ends up begging for more memory)
19:55:24 <sophiag> see if i try to move it back then it duplicates the name of the folder so won't run regardless
19:55:27 <sophiag> but as you asked
19:55:57 <stepcut> tommy`: RISC-V looks interesting
19:58:01 <ezyang> so, can you move it somwehre besides .. so that you don't have the filename overlap problem? 
19:59:57 <ab9rf> tommy`: hofstadter's law
20:00:23 <sophiag> ezyang: but then that's the same issue, right? that was the folder it was created in...that's the only one i've been able to get it to run in...
20:00:53 <sophiag> is it that you don't believe me this bug exists?
20:00:55 <nshepperd> sophiag: stack exec -- ghc -o wc wordcount.hs
20:01:55 <MarcelineVQ> Belief isn't involved, it has to be reproducable to know what to fix
20:02:24 <sophiag> "<no location info>: error: output was redirected with -o, but no output will be generated because there is no Main module."
20:03:02 <ab9rf> it did what you asked it to
20:03:07 <ab9rf> it compiled wordcount.hs to wordcount.o
20:03:18 <ab9rf> you didn't ask it to make an executable, so it didn't
20:04:00 <ezyang> sophiag: I mean, I certainly believe that if you want to build an executable named foo, but you already have a folder named foo, it's not going to work... 
20:04:01 <sophiag> well normally calling "stack ghc" i can run a command line app
20:04:05 <nshepperd> hey, that's a useful error message
20:04:16 <ab9rf> ezyang: go figgur
20:04:16 <tommy`> stepcut: I just logged into my CHIP (5000 miles away) to check the memory.  Only 0.5 GB.  I guess you aren't looking to run a web server :)
20:04:21 <nshepperd> sophiag: it won't create an executable because you don't have a Main module
20:04:36 <stepcut> tommy`: nope. Just flashing some LEDs off and on
20:04:36 <sophiag> i never called my module Main before and it was fine
20:04:58 <stepcut> tommy`: and eventually playing some sounds and maybe recording them
20:04:59 <MarcelineVQ> ab9rf: -c is for object files -o just names your output
20:05:04 <nshepperd> sophiag: did you put 'module Wordcount' at the top of your file
20:05:28 <nshepperd> sophiag: yeah, files with no module declaration are assumed to be Main by default
20:05:35 <sophiag> nshepperd: yes...guessing that's the problem
20:05:43 <sophiag> got it
20:05:43 <ab9rf> MarcelineVQ: that's not where the compiler wasn't asked to build an executable
20:05:48 <sophiag> ad hoc fallacy
20:05:56 <sophiag> post hoc
20:05:57 <sophiag> yikes
20:05:59 <sophiag> brain
20:06:03 <ab9rf> MarcelineVQ: there was no module named Main and no declaration of an alternate main in the cabal file
20:06:11 <MarcelineVQ> ab9rf: np then, just mentioning it in case of flag confusion
20:06:12 <tommy`> sophiag: you should also use upper case file names
20:06:33 <sophiag> tommy`: what's the deal with that?
20:06:35 <tommy`> on systems that care
20:06:40 <sophiag> ah ok
20:06:50 <tommy`> module X goes in X.hs (or X.lhs)
20:06:53 <ab9rf> MarcelineVQ: if you ask ghc to compile a .hs that containsa module declaration and that module is not Main, it just compiles the .hs file, without making an executable
20:07:23 <nshepperd> ideally your filename should match the module name. so 'Wordcount.hs <-> module Wordcount' and so on
20:08:57 <sophiag> nshepperd: that was my thinking, but then i need to call stack build to get an executable since i won't have a main module?
20:09:15 <ab9rf> sophiag: if you don't have a main module, you won't get an executable.
20:09:16 <nshepperd> er
20:09:35 <nshepperd> right, in this case you don't want module Wordcount
20:09:57 <nshepperd> it should be called 'module Main' if it has your 'main :: IO ()'
20:10:01 <sophiag> you mean for larger projects i suppose?
20:10:16 <ab9rf> sophiag: doesn't really matter how large it is
20:10:38 <tommy`> sophiag: as you've found, you can something get away with not following the "rules", but if you want things to work in all cases, call you executable module "Main" and a "main :: IO ()" function.
20:10:46 <sophiag> well it seems a little silly to separate a three line main function from the rest of the tiny program
20:11:06 <tommy`> We don't make the rules
20:11:22 <sophiag> tommy`: that wasn't what i was responding to...
20:11:34 <sophiag> "ideally your filename should match the module name. so 'Wordcount.hs <-> module Wordcount' and so on"
20:11:46 <sophiag> "if you want things to work in all cases, call you executable module "Main""
20:11:58 <sophiag> hence everything i've written...
20:12:17 <sophiag> in a larger project i would break them up
20:13:07 <tommy`> everyone here so far have told what you need to do for it to work.  If you don't want to do that, then I don't see how we can help.
20:13:08 <nshepperd> sophiag: yeah, for a tiny one-file project I will often do "projectname.hs" containing "module Main where ..."
20:13:41 <nshepperd> nothing ever tries to import Main so that works fine
20:14:53 <nshepperd> sophiag: for bigger projects with multiple files I will have "main.hs" containing "module Main where ..." and then other files like "Library.hs" containing "module Library" and so on
20:14:55 <tommy`> nshepperd: sure, but then you have to understand *why* that works (despite the module name != file name).
20:15:30 <sophiag> nshepperd: thanks. reading comprehension is always appreciated when you're new to things
20:17:17 <dmwit> There is -main-is if you want to pick a different module than Main as your top-level one.
20:18:25 <sophiag> dmwit: does that work with stack?
20:18:58 <dmwit> Your .cabal file can specify a main-is that cabal (and presumably stack) will honor.
20:19:08 <kadoban> sophiag: You typically put it in your .cabal file, which yes works fine with stack.
20:19:22 <sophiag> ah cool, thank you
20:20:26 <shane_> How would I go about hiding the impurity of a function that picks a random element from a list so that the function definition looks like pick :: [a] -> a?
20:20:47 <dmwit> You wouldn't.
20:20:54 <c_wraith> shane_: you shouldn't.  you would respect the definition of "function"
20:21:01 <shapr> sm: and you're ahead of me!
20:21:32 <shane_> What about with use with other pure functions that do not take IO parameters?
20:21:43 <ski> shane_ : you could add a random generator argument ..
20:22:15 <dmwit> Pure functions cannot* interact with impure ones in any interesting way.
20:22:24 <dmwit> It is what makes the hair shirt so scratchy.
20:22:32 <dmwit> But we wear it anyway. =)
20:22:41 * ski combs the hair
20:24:33 <shane_> ski: so parameterizing the generator will allow me to extract a pure value?
20:24:49 <ab9rf> depends on the genreator
20:27:33 <jle`> pick :: StdGen -> [a] -> (a, StdGen) is a common pattern
20:27:42 <jle`> used by a lot of libs
20:28:16 <ski> alt. `pick :: [a] -> State StdGen a', if you've seen `State' before
20:28:50 <ski> @type random
20:28:52 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
20:29:03 <jle`> yeah, if you've seen State, there are a lot of combinators that make dealing with 'State StdGen a' extremely convenient
20:29:31 <ski> @type randomR
20:29:33 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:30:01 <ski> @type let pick :: RandomGen g => g -> [a] -> a; pick gen as = as !! n where (n,_) = randomR (0,length as - 1) gen in pick
20:30:03 <lambdabot> RandomGen g => g -> [a] -> a
20:30:10 <jle`> > fst (random (mkStdGen 10)) :: Int
20:30:14 <lambdabot>  -2774747785423059091
20:30:16 <jle`> > fst (random (mkStdGen 10)) :: Int
20:30:19 <lambdabot>  -2774747785423059091
20:30:27 <jle`> > fst (random (mkStdGen 54832)) :: Int
20:30:30 <lambdabot>  4023006246876969223
20:30:31 <ski> (that one throws away the new random generator state, which is probably less than ideal, even though there's `split')
20:30:57 <shane_> Thanks for that -- will digest
20:31:40 <ski> > randomRs (0,9) (mkStdGen 0) :: [Integer]
20:31:42 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
20:31:47 <ski> @type randoms
20:31:49 <lambdabot> (Random a, RandomGen g) => g -> [a]
20:31:49 <ski> @type randomRs
20:31:51 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
20:32:21 <ski> (these two will generate an infinite list, so there's no last random generator state there)
20:37:14 <ski> > replicateM 4 (("abcdefgh" !!) <$> state (randomR (0,7))) `evalState` mkStdGen 0  -- using `State StdGen'
20:37:16 <lambdabot>  "dfhg"
20:37:21 <ski> > replicateM 10 (("abcdefgh" !!) <$> state (randomR (0,7))) `evalState` mkStdGen 0  -- using `State StdGen'
20:37:24 <lambdabot>  "dfhgadbbbg"
20:38:26 <ski> (generating a given number of random indices (from a specified starting random generator seed, in this case), to use to select characters from the string)
20:40:02 <meretrix> I'm running "ghc -O2 -prof -fno-prof-auto Main.hs", but "./Main +RTS -p" is still producing a file with *all* cost centers, rather than just my manual cost centers.  Any idea why?
20:42:43 <ezyang> meretrix: are those other cost centers from libraries? 
20:43:48 <shane_> ski: that's exactly what I was looking for even if I don't understand it, yet. thanks so much for your help!
20:45:01 <meretrix> ezyang: ah, yes they are all from libraries.  I guess I need to recompile all them.
20:45:13 <ezyang> meretrix: Yep. cabal new-build should help you here 
20:45:38 <ezyang> http://cabal.readthedocs.io/en/latest/nix-local-build.html#how-can-i-profile-my-library-application 
20:45:50 <meretrix> thanks
20:46:54 <ski> shane_ : in practice, instead of using `mkStdGen' with some fixed seed, you should probably use `newStdGen' (in I/O) to get a new seed each time
20:47:40 <ski> (but we can't do I/O in lambdabot, so we have to illustrate the random operations, by using `mkStdGen', there)
20:47:55 <shane_> gotcha. will keep that in mind.
21:27:10 <dmj`> jle`: o/
21:37:36 <stepcut> has anyone successfully used the 'generic' ghc armv7l binaries. the make install is failing for me when trying to run `ghc-cabal copy`. It claims that saved package file is corrupt. It looks like the package file was created with an older version of ghc/cabal
21:39:26 <meretrix> I'm still getting auto cost centers created in package dependencies after removing stack and rebuilding everything with:
21:39:30 <meretrix> stack build --executable-profiling --ghc-options='-O2 -fno-prof-auto'
21:39:34 <meretrix> any idea why?
23:02:45 <meretrix> I'm writing a turn-based simulation with about 10 agents.  Each agent will have his own state and make use of a random number generator.  Does it make sense to basically write my entire application in the ST monad?
23:03:47 <meretrix> For example, I don't see any other way to pass around mwc-random generator to all of the agents.
23:23:32 <xocolatl> there's no way I'm going to be able to do today'd AoC in haskell :(
23:25:23 <amx> I'm still on day 11
23:30:15 <pavonia> xocolatl: Where are you stuck?
23:42:26 <Lokathor> so it appears that record update syntax binds tighter than function application
23:42:44 <Lokathor> is this the right way of thinking? or does record update syntax not count as an application at all?
23:45:12 <cocreature> Lokathor: that’s the way I think about it
23:45:19 <cocreature> and so far it has worked pretty well :)
23:49:04 <xocolatl> pavonia: I haven't started typing anything yet, but I don't know how to do recursive descent in haskell
23:49:28 <cocreature> xocolatl: recursive descent as in recursive descent parsers?
23:49:48 <xocolatl> cocreature: as in shortest path: http://adventofcode.com/2016/day/17
23:52:09 <cocreature> seems like a problem that you just need to bruteforce
23:54:51 <cocreature> xocolatl: what are you referring to by "recursive descent" in this case? I’ve only seen this term used for parsers
23:55:18 <xocolatl> well, whatever the term is
23:55:26 <cocreature> just ordinary recursion?
23:55:31 <xocolatl> this seems like a recursive problem to me
23:55:41 <xocolatl> maybe haskell can do it with iteration?
23:56:13 <cocreature> recursion in haskell is not that different from recursion in other languages, no?
23:56:16 <xocolatl> it's almost as if I need to implement a* which is way outside my comfort level
23:56:57 <cocreature> I don’t think a* work, walking in cycles can change the hash and thereby open different doors
23:58:25 <cocreature> so just do some bruteforce search and maintain a cache of field-hash pairs
23:58:31 <fresheyeball> what do you call a Lens where the Setter is guaranteed to succeed, but Getting might fail?
