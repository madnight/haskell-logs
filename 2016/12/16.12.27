00:07:03 <mounty> Hello, I have a question about package dependencies and cabal.  The relevant lines of output from cabal build --only-dependencies:
00:07:14 <mounty> Data/Attoparsec/Text/Buffer.hs:47:1:
00:07:16 <mounty>     Bad interface file: /home/mounty/JackRose/source/.cabal-sandbox/lib/$abi/$libname/Data/Text/Internal/Encoding/Utf16.hi
00:07:17 <mounty>         Something is amiss; requested module  text-1.2.2.1:Data.Text.Internal.Encoding.Utf16 differs from name found in the interface file streaming-commons-0.1.16:Data.Text.Internal.Encoding.Utf16
00:07:27 <mounty> Is that $abi stuff spoofing the compiler?
00:15:13 <hal_> What's an appropriate value of epsilon for Haskell's Double type? Or is it architecture dependent?
00:34:55 <pineapples> hello I'm new here just seeing if this works
00:44:56 <mounty> pineapples:  there is also #haskell-beginners for newcomers to the language, as opposed to newcomers to IRC.
00:45:15 <EvanR> pineapples left
01:14:23 <dmwit> lyxia: I guess merging Product/(:*:) and others shouldn't be too incompatible what with pattern synonyms and all. At least you could deprecate one of the two and remove it in a future version.
01:15:26 <dmwit> mounty: I don't think it's related to $abi at all. It sounds like you've really managed to mung things up there.
01:16:07 <dmwit> Perhaps a `ghc-pkg check` (or perhaps `cabal sandbox hc-pkg check` if you are in a sandbox) would be in order.
01:23:58 <mounty> "cabal sandbox hc-pkg check" outputs "ghc-pkg: Data.Binary.Get.runGet at position 40: demandInput: not enough bytes"
01:26:45 <c_wraith> that sounds like a corrupted package index
01:36:42 <ledongthuc> I'm beginner, I have a question: Should we use the `do` notation or just plain monad >>= ?
01:37:08 <ledongthuc> my opinion, the >>= is more describable and clearly
01:37:28 <ledongthuc> it take the reader know the monad than `do` notation
01:38:15 <ledongthuc> the `do` notation, sometime make reader think about step by step declare action, that is not
01:38:32 <ledongthuc> but how do you think, because it just my thinking
01:39:48 <EvanR> in many cases you can think of it as step-by-step action
01:40:19 <EvanR> sometimes you cant, but its interesing to look at it in do notation anyway
01:41:13 <ledongthuc> yub, the step by step action make me thinking we shouldn't use `do` notation.
01:41:32 <ledongthuc> ofcouse, in long nested monad with IO, it's still ok
01:41:55 <ledongthuc> but maybe we need to be careful in mind about step-by-step and real thing is working
01:42:06 <EvanR> well maybe you would like ML
01:45:00 <winter__> I'd like discuss a alternative ByteString stream design
01:45:14 <winter__> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString (IO ByteString)
01:45:32 <winter__> what if i add IO monad layer to the Chunk constructor
01:45:55 <winter__> instead of pretend lazy bytestring is a pure value
01:46:13 <winter__> i always assume get next chunk need live in IO
01:46:16 <EvanR> its not pretend
01:46:26 <lyxia> So, an IO stream.
01:46:30 <winter__> Yes
01:46:40 <winter__> i'm ispired by io-streams
01:47:03 <winter__> but why don't we directly build IO into a lazy streamming bytestring
01:47:28 <EvanR> why do you want to
01:47:50 <winter__> I'm try to build a tcp server framework for my company
01:47:59 <EvanR> ah, then there are better ways
01:48:00 <winter__> i used to use io-streams
01:48:22 <winter__> here's my previos solution http://hackage.haskell.org/package/tcp-streams
01:48:49 <EvanR> iteratees, pipes, conduit
01:49:31 <winter__> Those thing will need you to embed all your computation inside a CPSed Monad
01:50:05 <winter__> I'm just to try abstract a streaming interface for network socket
01:50:24 <EvanR> they are more like coroutines
01:50:47 <winter__> Yeah, that will change my coding style to much
01:50:57 <EvanR> why change it at all?
01:51:25 <winter__> i have to change all my computation's type
01:51:41 <EvanR> why are you changing what you already have
01:52:09 <winter__> isn't using Pipe or Conduit need this?
01:52:22 <EvanR> this is a different question
01:52:37 <EvanR> in response to "no, i will have to change code"
01:52:50 <EvanR> whats wrong with the current code
01:53:18 <winter__> current code use io-streams, which works quite nicely
01:53:45 <winter__> I'm just wondering if my alternative defination
01:53:56 <winter__> can provide same functionality
01:54:23 <EvanR> you mean, rename the io stream type to ByteString?
01:54:28 <winter__> yes
01:54:33 <EvanR> why would you do that
01:54:53 <winter__> Ah, this's just a thought
01:55:29 <winter__> It seems in many place lazy ByteString is pretend it's a pure value
01:55:39 <EvanR> it is
01:55:53 <winter__> But without lazy IO, am i right?
01:56:26 <EvanR> by a technicality, results produced by unsafeInterleaveIO are pure
01:57:41 <winter__> I'm confused, unsafeInterleaveIO create RealWorld as the value being consumed
01:57:49 <winter__> how could that be pure 
01:57:58 <EvanR> i dont think that explanation makes any sense
01:58:47 <michaelt> winter__: have you seen this https://hackage.haskell.org/package/streaming-bytestring
01:59:17 <Profpatsch> amx: Yeah, we are open.
01:59:59 <winter__> Yes, i'm considering give streaming a try
02:00:43 <winter__> Can you shade some light on these different streaming library
02:00:57 <michaelt> what's wrong with io-streams though?
02:02:00 <winter__> nothing wrong with it ; )
02:02:19 <winter__> I'm just think about the streaming problem
02:02:32 <EvanR> streaming-bytestring just seems to be a better lazy bytestring
02:02:38 <winter__> and come across this idea
02:04:03 <winter__> Ah~ streaming-bytestring is almost what i want
02:04:07 <winter__> nice!
02:05:40 <winter__> BTW
02:06:02 <winter__> how streaming-bytestring achieve push-back behavior which io-streams features
02:06:18 <winter__> i found it's very useful when doing parsing
02:08:05 <michaelt> chunk leftover >> rest  -- prepends the chunk in your hands to the rest
02:09:20 <michaelt> how would you 'push back' onto  a lazy bytestring?
02:10:56 <winter__> I see
02:12:16 <winter__> This exactly i'm looking for, i just need specialize m to IO
02:12:25 <winter__> thanks!
02:13:05 <michaelt> welcome! 
02:24:32 <dalcde> I constructed a new class "Ring", and then I tried to say
02:24:39 <dalcde> instance (Num a) => Ring a where ...
02:25:14 <dalcde> But I get an "Illegal instance declaration" error. It says all instance types must be of the form T a1 ... an), where a1 ... an are distinct type variables, but I thought a is a type variable?
02:25:28 <c_wraith> dalcde: You're missing the T part.
02:25:35 <dalcde> T = Ring?
02:25:45 <c_wraith> dalcde: You need a type constructor.
02:25:49 <lyxia> The instance should look like Ring (T a1 ... an)
02:25:50 <c_wraith> dalcde: Ring is the class
02:26:03 <dalcde> Ah. So I can't say that all Nums are Rings?
02:26:16 <c_wraith> dalcde: Not like that, anyway
02:26:26 <c_wraith> dalcde: You can do it with a newtype wrapper, for instance
02:26:40 <c_wraith> dalcde: (I understand this is a learning exercise, but Num is already a ring..)
02:26:52 <dalcde> No. Num has a lot of things that do not belong to rings.
02:27:10 <dalcde> And there are things I want to do with Rings that are not necessariy Nums.
02:27:16 <c_wraith> Your declaration says that ring has everything in it that Num has
02:27:28 <dalcde> Ring has less things than Nums.
02:27:38 <c_wraith> Oh, whoops.  You didn't provide the declaration.
02:27:44 <c_wraith> But anyway - use a newtype
02:27:52 <c_wraith> then you get a type constructor
02:28:12 <dalcde> Then I would have to do it for every Num manually?
02:28:26 <c_wraith> newtype FromNum a = FromNum a ;  instance (Num a) => Ring (FromNum a) where ...
02:28:32 <dalcde> Ah okay.
02:29:21 <riaqn> Something has been driven me crazy.
02:29:47 <riaqn> Network.Socket.ByteString.recv returns empty bytestring even the connection is stil on.
02:29:59 <dalcde> That works, but it's annoying.
02:30:11 <c_wraith> dalcde: and if you create an instance (Num a) => Num (FromNum a) you can use numeric literals to create FromNum values
02:30:27 <c_wraith> dalcde: that instance is free if you use the GeneralizedNewtypeDeriving extension
02:30:43 <dalcde> I guess it makes the distinction between a-as-a-ring and a-as-a-num clear.
02:31:33 <c_wraith> dalcde: it'd also necessary because of the open world assumption.  Haskell assumes every type could be an instance of a class, and so it never rejects a class selection due to a missing instance - it just adds that instance as a requirement of using the function.
02:32:13 <c_wraith> dalcde: so if you enable enough extensions, you can create instance (Num a) => Ring a, but it will overlap every other instance.
02:32:32 <c_wraith> dalcde: the lack of an instance doesn't make it wrong - haskell just assumes the instance will be added later.
02:33:27 <dalcde> What do you mean by "overlap every other instance"?
02:33:41 <c_wraith> I mean it would match every type
02:33:52 <c_wraith> So if you had other instances, they would both match
02:34:01 <c_wraith> (On the relevant type of the other instances)
02:34:16 <c_wraith> That's called overlapping, and generally should be avoided, even though you can allow it with extensions
02:35:06 <dalcde> What would match every type?
02:35:07 <dalcde> (sorry)
02:35:29 <c_wraith> instance (Num a) => Ring a
02:35:49 <c_wraith> The instance head isn't used in instance resolution because of the open world assumption
02:36:08 <c_wraith> So all that it sees is that you've declared an instance for every type.
02:36:50 <dalcde> Ah but (Num a) => Ring (FromNum a) only matches things of the specific from FromNum a.
02:36:55 <c_wraith> Exactly
02:37:17 <c_wraith> That's why I steered you that direction instead of telling you to enable the extensions that allow that instance. :)
02:37:38 <dalcde> Also any suggestion for the symbol I should use for the ring operations?
02:37:53 <dalcde> <+>, <*> etc would clash with applicable functors.
02:38:09 <c_wraith> you can use unicode, if you can type them comfortably.  If not - well, no.  I don't have good suggestions
02:38:32 <dalcde> I'm currently using $+$ etc, but it is ugly and annoying to type.
02:38:45 <dalcde> And is also confusing because $ is also used a lot elsewhere.
02:38:57 <dalcde> And I suppose I cannot use :+:, :*: etc?
02:39:10 <c_wraith> those get considered to be type constructors
02:39:11 <dalcde> It throws an "invalid type signature" error
02:39:23 <dalcde> Yeah.
02:39:24 <dalcde> Thanks!
02:39:30 <EvanR> maybe look at inspiration in this package https://hackage.haskell.org/package/algebra-4.3/docs/Numeric-Ring-Class.html
02:39:43 <Profpatsch> amx: The map doesn’t want to update, so here’s a screenshot of the place: https://a.uguu.se/PRCfsY1pzefr_screenshot.png
02:39:49 <Profpatsch> We’re on level 1.
02:39:57 <amx> thank you! I will check by later
02:40:14 <c_wraith> err, data constructors
02:40:23 <EvanR> maybe no, i guess they use * for multiplication and + for addition
02:41:03 <EvanR> they also use flexible instances to do what dalcde asked
02:41:21 <EvanR> hmmmm more seriously, undecidable instances
02:42:52 <EvanR> this package is huge... i was looking for a different one with a Ring class
02:52:00 <dalcde> Hmm why doesn't idris have problems with that?
02:52:11 <dalcde> Idris is completely happy with such declarations.
02:52:47 <c_wraith> Idris uses something other than classes, right?
02:54:37 <EvanR> idris allows multiple instances per class
02:54:57 <EvanR> for a given type
02:55:13 <EvanR> it treats instances sort of like agda, as dependent records
02:55:15 <p_implies_q> Quick question. I am writing a newtype wrapper around X for an XMonad extension I am writing. I derive a bunch of instances using generalized newtype deriving, and all this goes well. Now, inside this newtype Monad, I would like to use cleanMask, a (a -> X a) function, but now it complains about the types not matching (obviously). How am I supposed to deal with this?
02:59:49 <elfeck> Hello, can someone tell me how to quickly fold a Maybe (Maybe (... (Type)) to Maybe Type?
03:00:10 <jaspervdj> > join (Just (Just 2))
03:00:12 <lambdabot>  Just 2
03:00:47 <elfeck> join (Just (Just (Just 2)))
03:00:55 <elfeck> > join (Just (Just (Just 2)))
03:01:00 <lambdabot>  Just (Just 2)
03:01:27 <elfeck> this only works for 1 nested Maybe
03:01:31 <c_wraith> Arbitrarily nested Maybes all have different types.  There's nothing for the job that's polymorphic over some random number of them
03:01:31 <EvanR> put more joins
03:01:55 <jaspervdj> ah, misunderstood the question, sorry -- c_wraith is right.
03:01:56 <Profpatsch> ATTENTION
03:02:04 <elfeck> hm okay
03:02:06 <elfeck> thanks
03:02:15 <Profpatsch> IF somebody has any Haskell stickers and is at 33C3, the #haskell assembly could need some.
03:02:47 <theDon> Profpatsch: don't have any stickers, but where is the assembly?
03:03:13 <pavonia> elfeck: Maybe have a look at Data.Fix
03:03:38 <Profpatsch> theDon: https://a.uguu.se/PRCfsY1pzefr_screenshot.png
03:03:45 <c_wraith> Fix Maybe is very different from that structure.  Fix Maybe will always end with a Nothing.
03:03:51 <c_wraith> (If it ends at all)
03:04:03 <c_wraith> On the other hand, Free Maybe is similar to recursive maybes.
03:04:27 <pavonia> Why will it end with a Nothing?
03:04:54 <jaspervdj> pavonia: It will either end with Nothing, or not end at all
03:05:11 <c_wraith> pavonia: data Fix f = Fix (f (Fix f))
03:05:17 <kuribas> pavonia: because the Functor argument is of type Maybe
03:05:32 <kuribas> pavonia: not Int or anything else
03:05:38 <c_wraith> pavonia: the only way that can end is if a value of type f (Fix f) contains no (Fix f) values
03:05:47 <c_wraith> pavonia: with Maybe, that means Nothing
03:07:26 <pavonia> So you'd need a helper type with two arguments then to actually store values?
03:07:37 <c_wraith> Fix (Either a)
03:08:03 <c_wraith> That will end with a Left value containing a value of type a
03:08:11 <c_wraith> Or you could just use Free Maybe a
03:08:22 <c_wraith> Or if you wanted a value at each step, Cofree Maybe a
03:10:17 <theDon> Profpatsch: okay, nice, i'll come by later some time
03:40:25 <Social-Reject> can I learn haskell in less than 5 years
03:41:25 <quchen> Yes.
03:41:56 <Social-Reject> is haskell going to nirvana
03:42:02 <quchen> No.
04:03:53 <bollu> where do I learn how to contribute to GHC code
04:03:57 <bollu> I have an assigned issue
04:04:01 <bollu> but the codebase is so large
04:05:55 <quchen> bollu: This is a good overview over the pipeline of GHC: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
04:06:09 <quchen> Step 1: figure out where your change is roughly going to be. :-)
04:06:19 <bollu>  quchen :)
04:06:45 <Social-Reject> why learn haskell is a big question
04:07:09 <bollu> quchen: I took this ticket https://ghc.haskell.org/trac/ghc/ticket/4806
04:07:15 <bollu> quchen: but I'm not sure how to repro the error
04:07:23 <bollu> quchen: do I setup a sandbox and damage it on purpose?
04:07:40 <quchen> bollu: Oh, you haven’t built GHC yet?
04:07:44 <quchen> I mean, never?
04:07:46 <bollu> quchen: that's done
04:07:50 <bollu> quchen: thrice, in fact ;)
04:07:58 <bollu> quchen: but I wasn't able to get started on my issue
04:08:16 <quchen> Okay. Well, you do that, and then start hacking away in that. That’s your sandbox. There is no fancy Cabal sandbox in GHC. ;-)
04:08:29 <kuribas> Is this a good way to handle default values?  type Optional = Endo, options = mconcat, defaultOptions = mempty
04:08:39 <quchen> There are some tricks to not pollute your working tree with build files, but that’s as much as we have.
04:09:12 <quchen> kuribas: I would say so.
04:09:38 <Profpatsch> theDon: Cool!
04:09:58 <quchen> bollu: I don’t really understand the ticket. But you can just search for the error message in the GHC source to find where it is generated and continue from there.
04:10:05 <aidecoe> i wonder whether following code can be written in more concise way. I have a RWS () () Struct ()
04:10:13 <aidecoe> and i do:
04:10:13 <aidecoe> someStruct <- get
04:10:18 <aidecoe> lensForDataMap .= (at 0 ?~ newDataMapValue $ getDataMap someStruct)
04:10:20 <quchen> RWS () () s = State s
04:10:25 <aidecoe> using lens library
04:10:36 <bollu> quchen: ah
04:10:37 <aidecoe> i have actually something else than ()
04:10:41 <bollu> quchen: that sounds like a decent idea
04:10:46 <quchen> bollu: GHC uses a prettyprinter though, so words might be broken up and not be together in a single string.
04:10:58 <aidecoe> bo for simplicity i have removed these signatures
04:11:11 <quchen> bollu: So try searching for the most characteristic word in your error. It’s a bit of trial and error, but doesn’t take long usually.
04:11:24 <aidecoe> so, is there a lens function which does that in more concise way?
04:11:41 <bollu> quchen: ah, thanks!
04:11:45 <bollu> quchen: I appreciate the help
04:11:52 <bollu> quchen: you contribute to GHC I assume?
04:12:07 <quchen> aidecoe: I remember <~ doing something like applying a lens to the state.
04:12:14 <quchen> Not sure whether it’s correct.
04:12:25 <quchen> bollu: Occasionally, yes. I’ve done some minor modifications at least.
04:16:38 <aidecoe> quchen: hm, so i would do something like "lensForDataMap . at 0 <~ newDataMapValue"?
04:21:16 <aidecoe> quchen: hm, <?= did the job
04:22:01 <aidecoe> quchen: but <~ was a good trace
04:24:36 <kuribas> more linenoise...
04:27:41 <kuribas> modifying lensForDataMap (set (at 0) newDataMapValue)
04:29:05 <kuribas> better: assign (lensForDataMap.at 0) newDataMapValue
04:31:20 <aidecoe> kuribas: thanks, i like the latter. "Just" is just missing:  assign (lensForDataMap.at 0) (Just newDataMapValue)
04:31:43 <kuribas> right 
04:32:43 <kuribas> aidecoe: assign == (.=)
04:33:37 <kuribas> personally I find (.=) tolerable as far as line noise goes ;-)
04:34:10 <kuribas> At least you can guess what it means.
04:35:23 <kuribas> aidecoe: btw you can also do lensForDataMap.at 0 .= Just newDataMapValue
04:35:45 <aidecoe> hm
04:36:13 <aidecoe> i think i was trying something like that previosly...
04:41:31 <Arvraepe> Hi, I'm extremely new to haskell and was wondering what is wrong with the following snippet http://lpaste.net/350523
04:41:49 <Arvraepe> Getting     • Could not deduce (Fractional Int) arising from a use of ‘/’ on the getAverageOfGameScores function
04:43:13 <Gurkenglas> You want div instead. / is for no-remainder quotients
04:43:39 <Gurkenglas> (As in, dividing of numbers where there is no need for talking about remainders)
04:44:51 <kuribas> :t (/)
04:44:54 <lambdabot> Fractional a => a -> a -> a
04:46:09 <kuribas> Arvraepe: or if you want a fractional number, use realToFrac
04:46:20 <kuribas> :t realToFrac
04:46:22 <lambdabot> (Real a, Fractional b) => a -> b
04:46:30 <Arvraepe> I've tried `div` before but that resolved to 0
04:46:46 <Arvraepe> I know it should round ... but rounding 5.5 does not resolve to 0?
04:47:19 <kuribas> > 11 `div` 2
04:47:22 <lambdabot>  5
04:47:31 <Arvraepe> omg
04:47:43 <Arvraepe> sorry I got 0 when the functions were switched
04:47:51 <kuribas> Arvraepe: it doesn't.  Must be something else.
04:47:53 <Arvraepe> starting with haskell is hurting my brain
04:48:10 <Arvraepe> kuribas: I know... found it... pak
04:52:51 <bollu> quchen: I'm trying to re-clone GHC
04:52:57 <bollu> and I get the error: fatal: unable to connect to github.com:
04:52:58 <bollu> github.com[0: 192.30.253.113]: errno=Connection refused
04:53:07 <bollu> quchen: I'm able to pull from all my other repos
04:53:10 <bollu> this is weird
04:59:26 <romano> hi guys!
04:59:39 <romano> has anyone used the Spock background workers package? https://hackage.haskell.org/package/Spock-worker
04:59:57 <romano> the documentation lacks any examples on how to set it up
05:02:38 <ertes> romano: you could just use concurrency
05:04:18 <ddk> hello folks
05:04:30 <romano> ertes, i probably could but i want to queue jobs 
05:05:21 <ertes> romano: although the API seems very straightforward, if you want to use it:  use newWorker from your 'spock' block, then addWork from anywhere you want
05:05:54 <ertes> romano: haskell concurrency has all of that by itself, including queues
05:06:22 <ertes> Spock-worker doesn't seem to do anything special, except that it supports a non-concurrent mode
05:07:00 <ertes> hi ddk
05:08:17 <romano> ertes, thanks. i may end up rolling my own. i was just hoping i would not have to reinvent the wheel :)
05:08:39 <ertes> romano: there really isn't much to roll =)
05:09:06 <ertes> romano: if you do it using vanilla concurrency, just create a worker using withAsync, create a TBQueue to communicate with it
05:10:32 <romano> ertes, awesome. thanks for the tip!
05:10:47 <ertes> romano: do q <- newTBQueueIO 50; withASync (forever (readTBQueue q >>= work)) (\_ -> restOfApplication q)
05:11:16 <ertes> romano: where 'work' does the actual work, and 'restOfApplication' is…  well…  the rest of your application, e.g. your spock application
05:11:45 <ertes> 50 is the queue bound…  if there are 50 items queued, new writes to the queue will block until the worker catches up
05:12:18 <ertes> romano: oh, i missed an 'atomically'
05:12:24 <romano> ertes, cheers! i will give this a go
05:12:31 <ertes> romano: do q <- newTBQueueIO 50; withASync (forever (atomically (readTBQueue q) >>= work)) (\_ -> restOfApplication q)
05:14:08 <ertes> romano: one more thing: be sure to handle exceptions in 'work', so a dying worker doesn't kill the whole worker thread
05:14:33 <ddk> I have a subject of computer graphics in this semester and I want to use Haskell ... my teacher has told us to use openGL can someone suggest how to proceed programming with Graphics in Haskell ..plzz  
05:14:37 <romano> ertes, ok. will do! thanks again
05:16:33 <ertes> ddk: the most popular library for getting a canvas is 'sdl2' right now
05:16:42 <Gurkenglas> Here's a pipes package that does that queue stuff for you https://hackage.haskell.org/package/pipes-async-0.1.1/docs/Pipes-Async.html
05:16:48 <ertes> ddk: after that the most popular OpenGL binding is 'gl'
05:17:20 <ertes> ddk: it has a major advantange:  it's generated from the spec in a rather straightforward way, so the haskell API corresponds almost exactly to the C API
05:17:50 <ertes> ddk: in other words: if you find materials on OpenGL online, you will know how to apply them to haskell, because the API calls translate almost 1:1
05:18:09 <Shockk> ertes: how does gl compare and differ with OpenGLRaw?
05:18:40 <ddk> basically my whole project's task is to come up with a program which will allow the user an artificial feel of the real world and the user could go inside model of the building and view woth any angle ...etc there may be extrasimulations ...
05:18:43 <ertes> Shockk: it's complete and mechanically generated…  it also has modules that correspond to OpenGL profiles, which is quite nice
05:19:08 <Gurkenglas> Why doesn't haddock show associated type instances next to each instance?
05:19:24 <ertes> Shockk: import Graphics.GL.Core33  -- import everything from the core 3.3 profile, but nothing else
05:19:32 <Shockk> hmm
05:19:44 <Shockk> OpenGLRaw has the same module names
05:19:57 <ddk> ertes : keeping my task in view how i should start can you suggest ~~Q
05:20:13 <ertes> ddk: are you a haskell beginner?
05:20:37 <ertes> Shockk: oh, indeed…  never noticed that
05:20:43 <ddk> hmmm... may be but i have to do with haskell only
05:21:43 <ddk> I love haskell and however difficult I have to do in haskell and become proficient in it... as my dream is to work with haskell
05:22:21 <ertes> Shockk: at the very least there is a problem with OpenGLRaw in that it doesn't like multiple contexts
05:22:29 <Shockk> ahh right
05:23:11 <ddk> ertes : I can't judge myself whether i am begginer or not ...m doing haskell from 1.5 years
05:23:13 <ertes> ddk: then your first step is to properly learn haskell…  which OS are you using?
05:24:28 <ddk> ertes : linux --debian ,, I am learning also ....recently I have written an Editor in Haskell with brick library and a couple of games using monads etc...
05:25:21 <ertes> ddk: i suggest as your first task to get sdl2 to display a window that you can interact with (make your program print on stdout when the user presses a key, for example)
05:25:43 <ddk> ertes : well I have to complete this task whether using haskell or anything else in 5-6 months ...so I would prefer haskell ..
05:26:05 <ertes> ddk: from there it's only a small step to OpenGL:  you just tell sdl2 to give you an OpenGL context
05:26:44 <ddk> ertes : ok so first sdl2 then OpenGl
05:27:09 <ertes> ddk: yes, if that didn't come across:  sdl2 and gl are haskell libraries; bindings to SDL and OpenGL respectively =)
05:28:18 <ddk> ertes : ohh nice and also I have seen a post about haskell SpriteKit by MChakraborty what about that ..~~Q
05:30:53 <pie_> hey guys, how can i install a specific ghc version with stack? specifically 7.10
05:34:22 <MarcelineVQ> use stack normally but specify a resolver withg ghc 7.10.*   on the command line that might look like: stack ghci --resolver lts-6.27   or stack ghci --resolver ghc-7.10.3
05:34:48 <MarcelineVQ> if you're using a stack.yaml it'd be the same but you'd specify the resolver there
05:35:48 <pie_> ok thank you
05:40:25 <MarcelineVQ> I think the ghc-* resolvers only include basic libraries so you should prefer an lts, there's a list of which match to which ghc versions on the front page here https://www.stackage.org/
05:47:15 <dalcde> When implementing a type class, say (Num a) => (Foo a), is there a way to say that "if a is in addition Integral, then implement the function in this way; otherwise, do it a different way"?
05:48:48 <Gurkenglas> Which of these four is false? "newtype and data definitions could be replaced by constructions of (->) and forall." "RankNTypes is implemented correctly." "ImpredicativeTypes would be hard to implement correctly even if GADTs didn't exist." "The first two statements refute the third."
05:52:26 <sphinxo> is it possible to write a generic memoization function?
05:52:34 <geekosaur> dalcde, not without a newtype to hold the Integral constraint
05:54:24 <ClaudiusMaximus> dalcde: another idiom for  class Num a => Foo a where foo :: blah  is to write functions like   fooNum :: Foo a => something   fooIntegral :: (Integral a, Foo a) => whatever   so you can implement all the instances you need like  instance Foo Baz where foo = fooIntegral  or instance Foo Quux where foo = fooNum  as appropriate
05:54:34 <Gurkenglas> sphinxo, no in the keys, yes in the values
05:55:30 <Gurkenglas> sphinxo, http://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html
05:58:17 <Wizek> Hey! Is there a tool that could tell me the time worst-case complexity of an arbitrary function?
05:58:36 <Wizek> *worst-case time complexity
05:59:24 <Wizek> By looking at the haskell source code
06:00:26 <ClaudiusMaximus> Wizek: sounds like halting problem (worst case: will not finish)
06:04:01 <Taneb> Wizek, in general, that is impossible
06:04:21 <Taneb> I don't know of any tools that can really help here, I'm afraid
06:04:46 <Gurkenglas> Wizek, that's not possible in the general case. Suppose there were such a tool, implementable in Haskell, with a predicate halts :: (String -> Bool) which, given a haskell source String, says even just if that code always finishes after finite time even in the worst-case. (let paradox = if halts "paradox" then length [1..] else 0). What's (halts "paradox")?
06:06:03 <hexagoxel> well who said the tool needed to terminate if the input function did not halt for some inputs.
06:07:39 <Taneb> hexagoxel, that's a fairly important preliminary to work out how long it takes in the worst case
06:07:56 <Taneb> Because "infinite time" is a pretty bad running time so I think would qualify as worst case
06:08:08 <Gurkenglas> Ah, you mean it run the function for all inputs and time it? That's possible if the inputs are Enum. See criterion.
06:08:13 <Gurkenglas> *should run
06:12:00 <Wizek> Gurkenglas, Thanks for that example. Let's see: `length` is O(n), and "n of [1..]" is Infinity, so we can say that `length [1..]` is O(Infinity). So we have O(Infinity) on one branch of the if-else and O(1) on the other. Since we are interested in the worst case we just take the maximum, therefore f has O(Infinity) worst case time complexity.
06:12:03 <hexagoxel> "running time" does not have much to do with complexity..
06:13:36 <Wizek> Gurkenglas, Could there be a tool that reasons like that?
06:15:59 <Gurkenglas> Wizek, no harm done if the tool deduces a worse complexity than the program actually has?
06:16:56 <Wizek> Gurkenglas, well, if it reasonably approximates most of the time I would still be interested in trying it
06:17:46 <Gurkenglas> Yes, that's possible. I don't know a library that does that, though. If this is for an environment where you want to execute user-specified code and want a gurantee it won't hog everything, maybe you want to look at Coq
06:18:02 <Gurkenglas> (Such that the user can provide a proof and you just check it)
06:20:36 <Gurkenglas> (I'm guessing that any such tool will generate better bounds the more specific the combinators used to write the checked code are. Recursion bad, mapAccumL good.)
06:22:58 <hexagoxel> but can one write such at tool that only ever gives exact results, not just (a) bound(s), and that terminates if the input terminates on all its inputs?
06:24:06 <Gurkenglas> (Wizek, by your example calculation, halts "paradox" = False, so paradox = 0, so you also just gave an upper bound - "worst case" usually distinguishes among possible inputs, not possible branches of any if statement)
06:25:08 <Gurkenglas> hexagoxel, compile and run the input, count the lambda reductions.
06:25:17 <hexagoxel> the existence of a tool that returns (0, infinity) in general and something more specific in a couple of cases does not look very interesting to me :p
06:25:47 <hexagoxel> Gurkenglas: that still is "run time", effectively, not complexity.
06:26:08 <Gurkenglas> Is this supposed to also work if there are infinitely many possible inputs
06:26:19 <hexagoxel> complexity would require some dependency on properties of the input, of course.
06:26:29 <hexagoxel> like, length of an input list
06:29:02 <Gurkenglas> How is it supposed to output the complexity?
06:30:46 <hexagoxel> i don't know if there exists a notion of complexity that would work for arbitrary inputs and the properties of those. Or how one could restrict the types of input to allow for such a notion.
06:31:53 <Gurkenglas> Arbitrary complexities can only be represented by something that's turing-complete. How about a Haskell function that gives you the exact runtime for any input value you specify? >:P
06:33:39 <Wizek> Gurkenglas, Well, at first, maybe it could be a cli tool that reads from standard in some haskell source code and the name of the function we are interested and outputs on the standard output the guessed complexity
06:34:20 <Wizek> Or it could also take a filename and try to load imports, but that sounds like a perpendicular problem to solve.
06:36:09 <hexagoxel> Gurkenglas: the notion of "exact runtime" otoh makes no sense to me at all :p
06:36:11 <Gurkenglas> Wizek, right, if you only want bounds, that's no problem. We compose the known complexity bounds for library functions our tool knows and throw our hands up and say "infinity" when we see recursion more complicated than what hlint can hint away
06:37:00 <Gurkenglas> hexagoxel, how do you measure complexity if not by the number of elementary operations used?
06:37:41 <Wizek> Gurkenglas, That sounds like that could be useful, yes.
06:40:27 <Gurkenglas> -measure+define
06:49:35 <hexagoxel> Gurkenglas: i am thinking of infinitely many possible inputs. but you are right, for any specific input or finite set of inputs, run time does make sense.
06:51:24 <Gurkenglas> Since arbitrary complexities can only be represented by something that's turing complete, we might as well use Haskell code, which we already know can return the run-time for any specific finite set of inputs. So your problem is... trivial :D
06:53:12 <Gurkenglas> (The code *is* the solution that is returned in finite time to solve the general case. To inspect it for any given n, you run it. That's no worse than what you'd have to do for any other representation of general solutions.)
07:14:11 <kuribas> Is a monad a monoid?
07:15:08 <libscott> is it possible to have a type mapping, such that I can have a polymorphic tree A with a corresponding polymorphic tree B and zip them together?
07:15:16 <nitri-xmas> kuribas: In themathematical sense or in Haskell?
07:15:41 <kuribas> nitri-xmas: haskell? or possible haskell?
07:16:05 <kuribas> (I mean possible in haskell but not necessarily implemented).
07:16:15 <libscott> say i have a tree of (red and green apples) and a tree of (red and green pairs) and I want to zip them into (red apple, maybe red pair)
07:16:35 <nitri-xmas> kuribas: In the mathematical sense, yes, a monad in C should also be a monoid in the category of endofunctors of that C.
07:17:04 <kuribas> nitri-xmas: how would that translate to haskell?
07:18:44 <kuribas> libscott: how do you zip a tree?
07:19:16 <nitri-xmas> kuribas: As far as what's commonly seen and done in haskell, I believe they more often solve different problems. Usually a monoid will be merely a type, while the endofunctors are going to be type constructors.
07:19:58 <libscott> kuribas: if they have the same structure ie branches and leaves, you go Tree a -> Tree b -> Tree (a,b)
07:20:42 <libscott> where a and b are polymorphic types that have a 1:1 mapping in their constructors
07:20:56 <kuribas> libscott: sure, why not?
07:21:56 <nitri-xmas> kuribas: Anyway, other than their mathematical relation, they rarely exhibit this strong bonding in practice.
07:22:14 <kuribas> nitri-xmas: so you cannot define (<>) for monads?
07:22:22 <libscott> so if a is RedApple | GreenApple and B is RedPair | GreenPair I never want to allow (RedApple, GreenPair)
07:22:45 <nitri-xmas> kuribas: Some monads, probably not all monads. I'd have to check.
07:23:29 <lifter> Does anyone know if annotating functions w/ "HasCallStack" incurs much of a runtime performance penalty?
07:23:39 <kuribas> libscott: well, if you have an operation "Tree (Maybe a) -> Tree a", then yes.
07:23:44 <nitri-xmas> kuribas: My instinct tells me the kinds wont match.
07:24:06 <kuribas> nitri-xmas: hm, okay
07:24:36 <nitri-xmas> kuribas: Normally you have a monadic value `m a`, where `m` is the monad, but with monoids, you merely have `a` where the monoid value is itself the monoid.
07:24:38 <ertes> nitri-xmas: you can certainly zip trees, and you can certainly filter them…  preventing to get certain combinations *statically* is a lot more involved though
07:24:45 <libscott> kuribas: yea I understand. Thanks
07:24:46 <nitri-xmas> kuribas: * -> * vs. *
07:24:52 <ertes> whoops
07:25:04 <ertes> libscott: that was for you
07:25:43 <kuribas> nitri-xmas: ah yes
07:26:16 <kuribas> nitri-xmas: an operation on an unapplied monad doesn't make sense on the value level.
07:26:23 <nitri-xmas> kuribas: Presumably, if you're able to give `m a` a binary operation and an indentity, then you can make such monadic type also a monoid.
07:26:54 <kuribas> <> = m () and mempty = return ()
07:28:03 <kuribas> but that's m (), not m
07:28:20 <kuribas> I mean <> = >>
07:28:55 <libscott> ertes: is it possible though, without dependant typing?
07:30:20 <shapr> So what's the plan for Haskell in 2017? Is this the year of documentation?
07:30:56 <kuribas> libscott: you could use (Either GreenApple RedApple) and (Either GreenPair RedPair)
07:31:05 <shapr> lifter: I've read that HasCallStack cuts performance dramatically, but I don't remember where I read that.
07:31:31 <libscott> also has anyone heard anything about improving compiler performance lately?
07:32:05 <kuribas> libscott: then f :: (Either GreenApple RedApple) -> (Either GreenPair RedPair) -> Maybe (GreenApple, RedPair)
07:32:58 <shapr> lifter: after a bit of google searching and reading mailing list posts, it sounds like ghc 7.x was slow with HasCallStack, and ghc 8 is faster. That still doesn't give any info on the relative speed.
07:33:31 <ertes> libscott: well, there is actually one simple way
07:33:43 <lifter> shapr: There is some discussion here http://www.stephendiehl.com/posts/haskell_2017.html under the heading "Stack Traces": "Currently this introduces a 2-3x runtime overhead when compiled." ...but I think this is specifically about "automatic stack traces across the entire program in GHCi"
07:33:44 <libscott> kuribas: sounds like I'd be better off with `data ApplesAndPairs = Green Apple (Maybe Pear) | Red Apple (Maybe Pear)`
07:33:56 <shapr> lifter: ah, I was about to reference that myself!
07:34:02 <lifter> haha
07:34:03 <shapr> lifter: yeah, that's the best info I have
07:34:04 <libscott> ie one tree even when i dont need pears
07:34:05 <ertes> libscott: zipWith :: (a -> b -> c) -> Tree a -> Tree b -> Tree c
07:34:25 <shapr> lifter: do you have any empirical evidence?
07:34:30 <ertes> libscott: just make sure the result type is restricted enough (so not (A, B)) to only allow certain things
07:35:00 <libscott> ertes: but you have to do that with pattern matching at runtime right
07:35:01 <lifter> shapr: No, I only just found out about this when reading the pg I referenced; I'm starting to use "HasCallStack" now in my code.
07:35:08 <kuribas> libscott: or data ApplesAndPears a = Green Apple a
07:35:11 <ertes> libscott: note: most such tree types are instances of Apply from the semigroupoids package
07:35:21 <ertes> libscott: often even Bind
07:35:40 <ertes> libscott: what do you mean?
07:35:41 <kuribas> libscott: then you can go from "(ApplesAndPears Pear)" to "ApplesAndPears ()"
07:35:50 <shapr> lifter: Well, if you get some measurements, I want to know!
07:35:57 <lifter> shapr: "HasCallStack"s can easily be removed when I feel confident I don't need them anymore. In order to get a presumed performance boost.
07:36:12 <lifter> shapr: OK, thanks!
07:36:39 <ertes> libscott: example:  data A = A1 | A2; data B = B1 | B2; data C = A1B1 | A2B2 | A1B2
07:36:58 <ertes> C denotes combinations of A and B, but disallows A2B1
07:38:15 <MarcelineVQ> shapr, lifter: marlow has more detail about it at https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
07:38:21 <libscott> ertes: right, but in your example A1B1 isn't actually specifying A1 or B1, you have to define a function (A -> B -> Maybe C)
07:38:23 <nitri-xmas> kuribas: Almost. I can re-iterate this differently.
07:38:37 <ertes> libscott: yes
07:38:56 <libscott> What I'd like is `Tree A (Maybe B)` such that A and B are dependent
07:39:08 <nitri-xmas> kuribas: Haskell's requirement for a monad is `return` and `>>=` but in the mathematical sense, all that is necessary is `join` and `fmap`.
07:39:20 <lifter> MarcelineVQ: Thanks, I wasn't aware of this! This will be a valuable read, as I've had trouble finding info about this stuff.
07:39:29 <Gurkenglas> http://stackoverflow.com/questions/41348010/reducing-impredicativetypes-to-rankntypes-with-cps
07:39:43 <nitri-xmas> kuribas: Since we know monads are also functors, I wont focus on `fmap`, but this `join` stuff is interesting. join :: m (m a) -> m a
07:39:43 <ertes> libscott: in haskell you might be better off not trying to guarantee that statically, unless you want to get into singleton types territory
07:40:12 <ertes> libscott: things have become much nicer recently (-XTypeInType), but it's still really awkward to program with singletons
07:40:18 <nitri-xmas> kuribas: Surely, if you can join the two monadic context into a single one, you have devised the equivalent of a binary operation on the two monadic values.
07:40:39 <sm> shapr: "Year of Documentation", I like it! :)
07:40:46 <kuribas> nitri-xmas: on the type level?
07:41:28 <nitri-xmas> kuribas: So this goes to show that a monad requires this monoid with endofunctors because of that join operation.
07:41:49 <libscott> ertes: i guess TypeInType is not for intermediates like myself
07:41:52 <libscott> :p
07:42:05 <kuribas> nitri-xmas: that's a bit over my head, but I get the idea :)
07:42:39 <libscott> I'll have a read though for curiosity's sake, didn't know about such things
07:45:47 <nitri-xmas> kuribas: I thought was was doing good :( Is it the endofuntor? An endofunctor is just like a functor, but it starts and ends in the same category.
07:45:54 <kuribas> > ala Dual foldMap [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
07:45:57 <lambdabot>  [7,8,9,4,5,6,1,2,3]
07:47:00 <kuribas> nitri-xmas: I don't know enough math, that's all.
07:47:54 <Snowboarder> U
07:48:02 <kuribas> nitri-xmas: like (Maybe (Maybe a))?
07:48:07 <nitri-xmas> Yup !
07:48:09 <kuribas> nitri-xmas: but Maybe /= Maybe a
07:48:21 <kuribas> it's a different kind...
07:48:25 <nitri-xmas> > join (Just (Just 42))
07:48:28 <lambdabot>  Just 42
07:48:45 <nitri-xmas> :t Just (Just 42)
07:48:47 <lambdabot> Num a => Maybe (Maybe a)
07:49:10 <nitri-xmas> So this, is possible because of `join`. And you can probably imagine how such join would be implemented.
07:50:42 <nitri-xmas> While typical haskell monoid goes `Monoid a => a -> a -> a`, here you have the equivalent of `Monoid (m a) => m a -> m a -> m a`, but in the form `m (m a) -> m a`.
07:51:16 <kuribas> nitri-xmas: ok I get it.  It has nothing to do with function application...
07:52:28 <ertes> libscott: if TypeInType isn't for you, then singletons probably aren't either =)
07:53:01 <nitri-xmas> It's just that instead if having a monoid of these `a`, it's a monoid of these `m a`, where m is an haskell functor (remember every monads are functors).
07:53:11 <kuribas> :t (>>= (>>= return))
07:53:13 <lambdabot> Monad m => m (m b) -> m b
07:53:19 <nitri-xmas> And not only are they functors, in this case they're endofunctors because they say in the category `->`.
07:54:05 <nitri-xmas> (This is the part I'm not sure, I think it's actually the kleisli arrow... anyway)
07:54:11 <nitri-xmas> kuribas: Yup !
07:54:19 <shapr> MarcelineVQ: I like that post, I had no idea ghci could do parallel compilation!
07:54:38 <nitri-xmas> *stay
07:54:58 <kuribas> :t (>>= return)
07:55:00 <lambdabot> Monad m => m b -> m b
07:55:01 <shapr> I was sad about simon marlow joining facebook, but I was wrong, it's been a huge benefit to GHC
07:56:09 <kuribas> :t (\m -> do m' <- m; m')
07:56:10 <lambdabot> Monad m => m (m b) -> m b
07:56:27 <nitri-xmas> kuribas: The (>>= (>>= return)) is great, but that's merely `join`. The secret lies in understanding that you have a monoid of functors instead of regular types.
07:56:50 <nitri-xmas> a -> a -> a  vs.  (Monad m, Functor m) => m a -> m a -> m a
07:57:05 <nitri-xmas> Monoid a => a -> a -> a  vs.  (Monad m, Functor m) => m a -> m a -> m a
07:57:08 <nitri-xmas> kuribas: ^
07:57:24 <kuribas> ok
07:58:09 <kuribas> nitri-xmas: I think I get it now
07:59:01 <kuribas> > ala First foldMap [1..]
07:59:04 <lambdabot>  error:
07:59:04 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M441322471844...
07:59:04 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
07:59:08 <kuribas> > ala First foldMap [1..] :: Int
07:59:11 <lambdabot>  error:
07:59:11 <lambdabot>      • Couldn't match type ‘Maybe b0’ with ‘Int’
07:59:11 <lambdabot>        Expected type: [Maybe b0] -> Int
08:00:02 <kuribas> > ala First foldMap [1..] :: Maybe Int
08:00:05 <lambdabot>  error:
08:00:05 <lambdabot>      • No instance for (Enum (Maybe Int))
08:00:05 <lambdabot>          arising from the arithmetic sequence ‘1 .. ’
08:01:03 <Gurkenglas> It thinks [1..] is a [Maybe Int], where Maybe Int has a Num instance providing for example 1
08:01:32 <nitri-xmas> :t [1..] :: [Maybe Int]
08:01:35 <lambdabot> error:
08:01:44 <lambdabot>     • No instance for (Enum (Maybe Int))
08:01:44 <lambdabot>         arising from the arithmetic sequence ‘1 .. ’
08:01:44 <nitri-xmas> Yeah that wont work.
08:01:55 <Gurkenglas> :t ala First foldMap [1..]
08:01:57 <lambdabot> (Num (Maybe b), Enum (Maybe b)) => Maybe b
08:02:09 <kuribas> > ala (First.Just) foldMap [1..] :: Int
08:02:11 <nitri-xmas> If you're using First, the values must be of type `Maybe Int` for you to foldMap using First, but that type cannot be enumerated.
08:02:12 <lambdabot>  error:
08:02:12 <lambdabot>      Not in scope: data constructor ‘First.Just’
08:02:12 <lambdabot>      No module named ‘First’ is imported.
08:02:23 <kuribas> > ala (First . Just) foldMap [1..] :: Int
08:02:26 <lambdabot>  error:
08:02:26 <lambdabot>      • Couldn't match type ‘Maybe b0’ with ‘Int’
08:02:26 <lambdabot>        Expected type: [Maybe b0] -> Int
08:02:40 <Gurkenglas> Whitespace is irrelevant. First.Just is not a newtype wrapper.
08:02:48 <Gurkenglas> > alaf First foldMap Just [1..]
08:02:51 <lambdabot>  Just 1
08:03:07 <kuribas> Gurkenglas: it cannot unwrap Just?
08:03:33 <Gurkenglas> Just is not a newtype wrapper, and the composition of two newtype wrappers is not a newtype wrapper
08:03:46 <Gurkenglas> But if we suppose Nothing doesn't exist:
08:03:50 <kuribas> Gurkenglas: it's not?
08:04:03 <Gurkenglas> @src Maybe
08:04:04 <lambdabot> data Maybe a = Nothing | Just a
08:04:31 <kuribas> Gurkenglas: yeah, it cannot extract a from Nothing.
08:04:45 <kuribas> Gurkenglas: wouldn't it be technically possible to compose wrappers?
08:08:16 <kuribas> Not sure how First would be useful, since I could also use (listToMaybe . fromList)
08:09:57 <Gurkenglas> listToMaybe takes a list and fromList turns a list into something else...
08:11:19 <kuribas> right (ListToMaybe . toList)
08:15:18 <kuribas> > foldr (const.Just) Nothing [1..]
08:15:25 <lambdabot>  Just 1
08:15:35 <kuribas> > foldl (const Just) Nothing [1..100]
08:15:38 <lambdabot>  Just 100
08:15:56 <kuribas> > foldl (const Just) Nothing [undefined, undefined, 10]
08:15:58 <lambdabot>  Just 10
08:16:09 <kuribas> heh, I actually found a use for non-strict foldl.
08:17:22 <kuribas> > foldl' (const Just) Nothing [undefined, undefined, 10]
08:17:25 <lambdabot>  Just 10
08:17:37 <kuribas> how?
08:17:49 <MarcelineVQ> @src const
08:17:49 <lambdabot> const x _ = x
08:18:06 <AndreasK> Isn't that equal to Just $ last ?
08:18:06 <Gurkenglas> foldl' reduces "const Just undefined" to whnf before continuing
08:18:32 <Gurkenglas> Um, "const Just Nothing undefined"
08:18:35 <kuribas> AndreasK: no, last is partial
08:18:48 <Gurkenglas> Just undefined is in whnf, so it goes on
08:19:26 <kuribas> right
08:20:19 <kuribas> > foldl' (const Just) Nothing [] -- AndreasK
08:20:22 <lambdabot>  Nothing
08:20:27 <AndreasK> True
08:21:04 <AndreasK> Was more thinking of how both throw away the values of the start of the list without inspecting them
08:21:10 <kuribas> AndreasK: it's what last should have been.
08:22:08 <kuribas> @src last
08:22:08 <lambdabot> last [x]    = x
08:22:08 <lambdabot> last (_:xs) = last xs
08:22:08 <lambdabot> last []     = error "Prelude.last: empty list"
08:22:13 <AndreasK> Personally I don't mind partiality in head/last. It's useful when you already know the form of the list. But it would be nice for safe versions to be available as well
08:26:14 <kuribas> AndreasK: yeah, there should be safe version of everthing in the prelude
08:27:34 <AndreasK> The safe package is pretty useful. But it's one more dependency :/
08:37:20 <shapr> from https://github.com/divipp/x86-64/ "Quickcheck tests: You can quickcheck your x86 processor! Please report failures, there is a higher chance that the error is in this library rather than in your processor." 
08:40:54 <ed_sand> exit
08:43:16 <pie_> so i installed clash-ghc from hackage with stack install clash-ghc, but when i try to run clash.exe i get "Calling GHC failed with error code: 1
08:43:16 <pie_> "
08:43:38 <pie_> im guessing because ghc isnt installed on asystem level, only whatever stack setup --resolver lts-6.27 does
08:43:45 <pie_> is there a way to work around this?
08:44:47 <quchen_> pie_: Try »stack exec clash.exe«
08:45:32 <pie_> hm, still gives that same error :/
08:45:39 <pie_> im on windows btw :/
08:45:48 <pie_> err, wellthats obviousfrom the .exe
08:45:59 <quchen_> I’m not familiar with Windows, unfortunately.
08:46:28 <pie_> im not sure its a windows thing, just saying
08:46:33 <quchen_> christiaanb isn’t online right now, but he’s the head developer of Clash, and sometimes around here
08:46:37 <shapr> yeah, I don't know anything about running Haskell on windows :-(
08:47:10 * Sornaensis nests Monads 12 layers deep
08:48:36 <mmaruseacph2> :o
08:48:40 <mmaruseacph2> isn't that too much?
08:50:28 <AndreasK> pie_: What solver are you using? For me stack doesn'
08:50:34 <AndreasK> sdnt even find a build plan
08:52:30 <pie_> AndreasK, i didnt do anything special, im a total noob
08:52:47 <sphinxo> How do I escape \ ?
08:53:08 <shiona> \\ ?
08:53:15 <pie_> quchen_, yeah i hang around in his channel
08:53:16 <quchen_> > "\\"
08:53:19 <lambdabot>  "\\"
08:53:26 <quchen_> > length "\\"
08:53:29 <lambdabot>  1
08:53:34 <quchen_> > text "\\"
08:53:36 <sphinxo> ahh
08:53:37 <lambdabot>  \
08:53:42 <sphinxo> thanks :)
08:55:01 <pie_> oh wait
08:55:08 <pie_> i forgot to add the resolver to stack exec
08:55:13 <pie_> now i get a different error
08:55:42 <quchen_> Progress!
08:56:51 <MarcelineVQ> stack install clash-ghc doesn't install from hackage it installs from stackage, which is what the lts resolver is about, which would be stack install clash-ghc --resolver lts-6.27  if you want ghc 7.10.3
08:57:00 <pie_> woo
08:57:10 <pie_> stack exec --resolver ghc-7.10.3 clash -- --help
08:57:11 <pie_> works
08:57:39 <pie_> MarcelineVQ, ah...ok didnt know there is a stackage thing that is not hackage
08:58:09 <pie_> also i messed up the versionnumber which is why i got that "differenterror"
08:58:16 <MarcelineVQ> https://docs.haskellstack.org/en/stable/GUIDE/
08:58:18 <pie_> *different error
08:58:26 <pie_> MarcelineVQ, yeahi need to read that :
08:58:27 <pie_> * :/
08:58:36 * pie_ has an unreliable spacebar
08:59:56 <AndreasK> pie_ for me installing clash-ghc with the 6.27 resolver works
09:00:31 <AndreasK> 6.26
09:00:41 <pie_> yeah stack exec --resolver lst-6.27 clash -- --help works fine for me
09:02:48 <kadoban> stack exec with a resolver specified ... I suspect that doesn't actually do anything.
09:03:06 <kadoban> It should be doing the same thing it does without the resolver specified, that is.
09:03:18 <pie_> kadoban, why doesnt it make sense?
09:03:34 <pie_> i mean i dont know how it works but it makes sense if i want to choose the environment that it execs in
09:03:57 <kadoban> Because exec never builds or downloads anything AFAIK, all it does is run the specified program, which can come from a bigger set of directories than just what's on $PATH
09:04:02 <MarcelineVQ> it's a frontend for ghc kadoban so it needs a specific ghc version on the path
09:04:09 <MarcelineVQ> clash seems pretty interesting, I wonder why they didn't continue onto ghc
09:04:13 <MarcelineVQ> *onto ghc8
09:04:15 <pie_> the empirical situation is that it is necessary for the command to work though
09:04:17 <kadoban> Hmm, does exec do that?
09:04:28 <kadoban> Oh, alrighty, I guess it does more than I thought then.
09:04:30 <MarcelineVQ> that's pretty much the main thing exec is for
09:04:33 <MarcelineVQ> uh, afaik I mean
09:04:34 <pie_> MarcelineVQ, WIP i think
09:04:56 <MarcelineVQ> setting up paths and env
09:06:48 <MarcelineVQ> err: it uses ghc as a frontend, rather than being a frontend
09:21:49 <Gurkenglas> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Fold.html#v:firstOf <- "The answer is computed in a manner that leaks space less than ala First . foldMapOf" that should say "\l -> alaf First (foldMapOf l) Just", right?
09:31:22 <Gurkenglas> http://stackoverflow.com/questions/41348010/reducing-impredicativetypes-to-rankntypes-with-cps updated with an explanation? o.o
09:33:48 <libscott> If i have a datatype `data Fruit a b c = Orange a | Lemon b | Lime c` is there any way to map over the Lemons or the Limes without defining mapLemons and pattern matching?
09:34:10 <Ferdirand> lenses !
09:34:42 <libscott> Ferdirand: implying TH if im not mistaken?
09:35:19 <kuribas> :t ala First . foldMapOf $ traverse
09:35:21 <lambdabot> Traversable t => t (Maybe b) -> Maybe b
09:35:27 <kuribas> :t firstOf
09:35:32 <lambdabot> Getting (Leftmost a) s a -> s -> Maybe a
09:35:38 <kuribas> :t firstOf traverse
09:35:41 <lambdabot> Traversable t => t a -> Maybe a
09:35:59 <Gurkenglas> import Control.Lens; makeClassyPrisms ''Fruit; mapLemons = over _Lemons
09:36:27 <libscott> right that makes sense
09:36:44 <Gurkenglas> *over _Lemon, of course
09:37:13 <kuribas> Gurkenglas: the types seem to agree with you
09:56:59 <buttons840> when I get an exception, how can I know what the type of that exception is?
09:57:44 <cocreature> buttons840: catch it and call "typeOf" on it
09:58:11 <buttons840> catch is part of Control.Exception?
09:58:20 <lifter> Is there an easy alternative to the partial function "last"?
09:59:00 <kadoban> lifter: lastMay from the safe package, probably.
09:59:11 <quchen_> let last [] = Nothing; last xs = Just (last xs) -- this one ;-)
09:59:14 <kadoban> Though note that it's not really a good alternative, since last is ... pretty bad by itself.
09:59:20 <cocreature> buttons840: yep, in this case you need to catch all exceptions which is done by catching SomeException
09:59:51 <lifter> Ah OK, so "last" is actually used but empty list is checked for first.
10:03:45 <quchen_> lifter: As kadoban said, »last« is usually not a good solution. Like »length« and »head« and friends it is often unnecessarily complicated.
10:03:58 <quchen_> But that depends on the use case, sometimes it’s correct to use last.
10:04:13 <kadoban> Note that if your list is infinite, nothing can save that from better ⊥ anyway
10:04:18 <kadoban> from being*
10:05:04 <lifter> Right.
10:06:15 <puregreen> is there any way to detect overflow when adding two 'Word64's? I found addIntC# but there's no addWord64C#
10:07:12 <mmaruseacph2> if the sum is smaller than one of the operands then you have overflow
10:07:30 <mmaruseacph2> assuming wrap-around and not saturation
10:07:31 <buttons840> cocreature: can you give me an example of using catch like you describe?
10:07:44 <buttons840> cocreature: do you mean `typeOf` from Data.Typeable?
10:08:45 <osa1> any ideas why Data.Time.DiffTime doesn't have an Integral instance?
10:10:33 <cocreature> buttons840: throwIO Deadlock `catch` (\(SomeException e) -> print (typeOf e))
10:12:43 <lyxia> osa1: DiffTime may not be an integral number of seconds.
10:13:26 <quchen_> puregreen: The Haskell Report demands integer arithmetic to be modular. You can write your own overflow-checker of course.
10:13:27 <osa1> lyxia: but it's always an integral number of picoseconds
10:14:01 <lyxia> osa1: but you should treat it as a number of seconds. "Conversion functions will treat it as seconds."
10:14:35 <osa1> lyxia: but it has a `picosecondsToDiffTime` function :o
10:14:55 <lyxia> Sure.
10:15:13 <cocreature> that comment is about Num, Fractional, … instances
10:15:28 <cocreature> making these inconsistent would be really weird
10:15:51 <cocreature> e.g. toInteger . fromInteger would multiply by 10^12
10:15:53 <puregreen> quchen_: sure, but there could still be some primop for that (or some other way that is faster than branching)
10:16:08 <lyxia> osa1: it's treated as a number of seconds, which can be fractional
10:16:19 <lyxia> osa1: hence the Fractional instance and no Integral one.
10:16:20 <puregreen> mmaruseacph2: thanks! I haven't thought of that
10:16:42 <buttons840> cocreature: thanks; I'm having trouble getting the type of 2nd argument to `catch` to match the type of the first argument
10:17:59 <lyxia> osa1: Even if they chose picoseconds, it would make sense not to implement Integral so that the library can evolve to use a higher precision.
10:18:16 <cocreature> buttons840: you could always use "error . show" instead of "print" if you are fine with your program crashing after it has printed the exception
10:18:44 <buttons840> cocreature: good idea, i'm just testing in the repl now, so that's fine
10:34:44 <nitri-xmas> Why is Haskell's Functor not named Endofunctor? Are there ways to work outside of the Hask category within Haskell?
10:35:17 <lyxia> because that's 4 more characters to type
10:35:27 <lyxia> and it scares newcomers even more
10:35:41 <nitri-xmas> Also, does Kleisli counts as outside the typical (->) of Hask?
10:35:45 <lyxia> yes
10:36:41 <nitri-xmas> lyxia: But Haskell's Functor doesn't allow a proper mathematical functor between -> and Kleisli, does it?
10:37:04 <lyxia> You're right.
10:37:50 <nitri-xmas> I see. So it is named after something more generic than it actually is. It's proper name would normally be Endofunctor.
10:38:00 <nitri-xmas> Interesting.
10:39:28 <nitri-xmas> So that must be why people keep mentioning Haskell's functor differs from CT's functor.
10:39:35 <nitri-xmas> lyxia: Things are starting to click :P
10:42:08 <lyxia> although it's technically correct that every instance of the Functor typeclass actually represents an Endofunctor, I don't think it's a relevant technicality for day-to-day programming in Haskell.
10:42:44 <nitri-xmas> lyxia: I like to foray a little further, but you're confirming what I wanted to hear then :)
10:43:14 <int-e> And you can still make an Exofunctor class if you like.
10:44:42 <int-e> There's also the historical influence that Haskell 98 and earlier didn't even have multi parameter typeclasses.
10:46:51 <notdan> hi
10:47:23 <nitri-xmas> lyxia: int-e Appreciated.
10:47:35 <ski> nitri-xmas : consider something like `newtype List ref a = MkList (ref (ListCell ref a)); data ListCell ref a = Nil | Cons a (List ref a)', often one'd like an operation of type `forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. List f a -> List g a)', which would be the mapping function for a functor from the category of functors of kind `* -> *', to itself. also something like `Traversable' would be useful here
10:47:39 <int-e> Hmm, what's the status here anyway, Haskell 2010 also doesn't have them.
10:49:23 <ski> cf. e.g. `hoist' in
10:49:31 <ski> @hackage mmorph
10:49:31 <lambdabot> http://hackage.haskell.org/package/mmorph
10:50:40 <Aleksejs> Hi, is it possible to make a function that takes multi-dimensional list and list of indexes, and applies function (!!) recursively on list using those indexes? I tried let foo a [] = a; foo a (x:xs) = foo (a !! x) xs  in  foo [["a","bc"],[]] [0,1,1], but it shows an error
10:50:41 <nitri-xmas> Interesting.
10:51:12 <greggel_> anyone here successfully root the fire 8?
10:51:15 <greggel_> 6th gen?
10:52:01 <int-e> So there's still no clear plan for adding MPTCs to Haskell'. https://prime.haskell.org/ticket/49 hasn't seen much activity (also not on the corresponding wiki pages, it seems)
10:52:04 <nitri-xmas> Aleksejs: At this point you probably want arrays, vectors or any other combinations.
10:53:28 <pikajude> Aleksejs: sure it's possible
10:53:45 <pikajude> what's your error?
10:54:10 <nitri-xmas> int-e: Forget Haskell, GHC is the best language :D
10:54:19 <Aleksejs> cannot construct the infinite type: a0 = [a0] in the first argument of (!!)
10:54:28 <pikajude> oh, that's right
10:54:56 <pikajude> right, so no, it isn't possible
10:55:45 <pikajude> > listArray ((0,0,0),(1,1,1)) [0..] ! (0,1,1)
10:55:47 <lambdabot>  3
10:55:54 <pikajude> ^ that might be useful
10:56:56 <nitri-xmas> Aleksejs: The problem is, the elements needs to have the type of a list, so that you can apply !! on the result of !!
10:57:20 <nitri-xmas> Aleksejs: At which point, you can never get to a specific `e` of an `[e]`.
11:01:22 <nitri-xmas> Aleksejs: data RecursiveList a = Element a | [RecursiveList a]
11:02:10 <exio4> nitri-xmas: invalid syntax =P
11:02:16 <nitri-xmas> Meh
11:02:21 <nitri-xmas> Aleksejs: data RecursiveList a = Element a | Deeper [RecursiveList a]
11:03:12 <nitri-xmas> With something like this, you'd be able to, but I hope you have a limited amount of operations in mind to implement because it'll be rather painful :P
11:06:34 <nitri-xmas> Element 5 == [5];   Deeeper [Element 1, Element 2] == [1,2];  Deeper [Deeper [Element 1], Deeper [Element 2, Element3]] == [1, [2, 3]] -- Where this would normally not be possible
11:07:00 <pikajude> nitri-xmas: the last one would be [[1],[2,3]]
11:07:05 <pikajude> which is possible
11:07:11 <pikajude> i think you have an extra `Deeper` there
11:07:14 <nitri-xmas> Ah you're right.
11:07:34 <nitri-xmas> I'm sloppy today. I hope the idea is enough to help though.
11:07:59 <pikajude> you could even implement a Show instance for RecursiveList that makes it look like a regular list!
11:08:21 <nitri-xmas> This seems no different than a rose tree, now that I think about it.
11:08:28 <Tuplanolla> We have that.
11:08:34 <Tuplanolla> :t Data.Tree.Node
11:08:36 <lambdabot> a -> Forest a -> Tree a
11:08:38 <pikajude> probably because it's a rose tree
11:12:32 <ski>   data PerfectlyBalancedTree a = Elements a | Nest (PerfectlyBalancedTree [a])
11:13:28 <ski> `[[],[0],[1,2]]' would be represented here as `(Nest . Nest . Elements) [[],[0],[1,2]]' (having type `PerfectlyBalancedTree Integer', say)
11:13:36 <monochrom> oh wait, that's polymorphic recursion
11:14:56 <ski> not yet :)
11:41:17 <dfeuer> I don't need it this minute, but I'm wondering if there's some way to trick GHC into forcing something that's already been forced (i.e., to follow the pointer, bringing the item back into cache).
11:42:17 <ertes> dfeuer: if it's Storable, you could allocate a copy and discard it
11:43:02 <dfeuer> Gross.... But I guess what I'm talking about is gross anyway.
11:43:32 <ertes> dfeuer: if it's Hashable you could force the hash and discard it
11:43:33 <ertes> etc.
11:43:40 <ertes> i don't think there is a primitive trick though
11:43:52 <dfeuer> *nod*
11:44:13 <dfeuer> And it depends on how deep I want to go, which this hypothetical question doesn't address.
11:45:51 <jrkp> hey, anyone could give me a tip about how to structure my program? i'm trying to build a ncurses app that would read from a thread but can't get the monads to line up, http://lpaste.net/350533
11:47:53 <ertes> dfeuer: there might be a way to avoid unnecessary copying/computing by using the ghc-heap-view library
11:47:56 <dfeuer> jrkp, can you be more specific about the problem?
11:48:10 <Gurkenglas> In line 16 you want to lead with "return $". jrkp, if that doesnt work paste the error too
11:48:27 <ertes> dfeuer: but i'd assume that it comes with a cost of its own
11:49:23 <jrkp> from what i understand stm operations give me IO monad but i'm inside Curses monad so i can't use it
11:49:49 <dfeuer> ertes, the cleanest way would probably be a copy of the NFData class with different instances, some of which would have to get more specific.
11:49:59 <ertes> jrkp: Curses is a MonadIO, so you can use liftIO :: IO a -> Curses a
11:50:15 <ertes> jrkp: import Control.Monad.IO.Class
11:50:28 <jrkp> alright, i'll look into that, thank you
11:50:35 <Gurkenglas> ertes, he uses liftIO in line 15
11:50:50 <ertes> Gurkenglas: that didn't seem to answer their question =)
11:51:53 <dfeuer> I don't understand much about STM, but it seems a bit weird to have a bunch of atomic transactions, each of which only performs one atomic operation.
11:52:02 <dfeuer> Is that a typical use?
11:52:29 <ertes> not with TMVar (because there is MVar)
11:52:41 <ertes> but some abstractions are only available for STM (practically)
11:52:45 <ertes> like TBQueue
11:52:52 <ertes> or semaphores
11:53:01 <dfeuer> I don't know these things :-/
11:53:42 <ertes> you should learn them then =)
11:53:45 <dfeuer> Yes.
11:53:49 <dfeuer> Clearly.
11:54:02 <dfeuer> It's just a bit hard to chase down the basic ideas sometimes.
11:55:35 <ertes> dfeuer: it's easier with an actual application…  try to write a small telnet chat server perhaps
11:57:23 <dfeuer> ertes, I may try that when I have the bandwidth.
11:57:24 <ertes> this is a useful case for STM, because each client thread has multiple concurrent inputs:  the client itself, but also other clients
11:57:39 <ertes> STM is a really useful Alternative
11:57:57 <dfeuer> The Alternative bit is the part I understand least there.
11:58:24 <dfeuer> I don't understand why that doesn't make it *really hard* to predict how the system will behave.
11:58:29 <mfukar> don't get into Alternative now
11:58:47 <ertes> dfeuer: do you understand what it does?
11:59:18 <dfeuer> ertes, I believe so. "If X transaction succeeds, go with it. If it would retry, do Y instead."
11:59:31 <dfeuer> Transaction's probably the wrong word.
11:59:49 <ertes> dfeuer: no, it's fine…  it creates a compound transaction out of two individual ones
12:00:38 <ertes> dfeuer: so what part makes it feel unpredictable?
12:01:07 <dfeuer> ertes, Try to move money from account A to account B. If someone else is doing something with one of them right now,then move money from account C to account D instead.
12:01:35 <dfeuer> Or am I missing something?
12:01:57 <ertes> dfeuer: yeah, that would be a weird composite, but that's not a typical context to use it in
12:02:46 <dfeuer> ertes, what I mean is that I thought STM was partly about making sure stupid stuff like that didn't happen by mistake.
12:03:19 <ertes> dfeuer: STM only guarantees that transactions are atomic
12:03:48 <dfeuer> *nod*
12:03:49 <ertes> as in: you will never find that money was withdrawn from the source account but not added to the target account
12:04:08 <ertes> more precisely it makes (>>=) atomic
12:05:09 <ertes> t1 <|> t2  -- this is also atomic in the following sense:  you will only observe the effects of t1, t2 or neither, atomically
12:05:15 <dfeuer> ertes, a big thing I didn't get when skimming the paper and looking at the library was the interaction with IO.
12:05:49 <dfeuer> It seems there's very little built-in interaction with IO, and I'm unclear on what the STM variables *mean* once they escape transactions.
12:06:28 <ertes> they basically mean the same things as their non-STM counterparts, but can (only) be used in transactions
12:07:23 <dfeuer> Hrmm... OK.
12:07:59 <ertes> dfeuer: here is an example i use a lot:  withAsync reader $ \res -> …  -- let's say that reader does some I/O (like reading from a socket) and streams stuff into (dataVar :: TMVar A)
12:08:28 <lyxia> Can you think of STM as having a global lock allowing a single STM action with "atomically" at a time?
12:08:32 <ertes> now there are two things that could happen:  1. there might be data available from 'reader' via dataVar
12:08:42 <dfeuer> I'll have to play with it. Some kind of chat service thing could be a good exercise, although that might drag in a lot of networking learning that should be a different exercise.
12:08:52 <ertes> 2. the thread 'reader' finishes
12:09:19 <dfeuer> OK...
12:09:43 <ertes> join . atomically $ handleData <$> takeTMVar dataVar <|> handleQuit <$> waitCatchSTM res
12:10:07 <ertes> if data is available, do (handleData :: A -> IO R) on it
12:10:31 <ertes> if the thread died, do (handleQuit :: Either SomeException B -> IO R) on the result
12:10:50 <int-e> lyxia: well if you keep in mind that it's an approximation
12:11:30 <ertes> dfeuer: (withAsync is from the async library, which is also built on STM)
12:11:38 <int-e> lyxia: (in the global lock model, (<|>) cannot be fully understood, I think)
12:11:58 <ertes> dfeuer: (that's also how it does all the multiplexing it supports…  STM basically gives it multiplexing for free)
12:12:46 <lyxia> int-e: Oh, that makes sense.
12:17:29 <ckubrak> Hi guys, is there any way to get a random number and get an Int instead of an IO int?
12:17:48 <johnw> with pseudo-random you could
12:17:51 <ertes> ckubrak: you need IO to get the random number, but the random number itself will be an Int
12:17:52 <johnw> but not with system random
12:18:10 <ertes> (unless you hard-code the seed)
12:18:57 <geekosaur> well. the usual way you do it is use IO to get the seed, then stash it in a State or MonadRandom and use that in pure code.
12:19:22 <geekosaur> (since the program starts out in IO and you usually want to get the initial seed early, this is not much of an issue)
12:20:24 <ckubrak> johnw: how can I use pseudo random?
12:20:43 <johnw> for example, https://hackage.haskell.org/package/mwc-random
12:20:55 <johnw> you'll need to use a State monad to maintain the internal state of the PRNG
12:20:59 <johnw> but it won't rely on IO effects
12:21:14 <johnw> if your goal was to remove all monadicity, and just have Int, then no, that is not possible
12:21:19 <AndreasK> I used https://hackage.haskell.org/package/random-1.1/docs/System-Random.html
12:21:21 <sm> hey all.. if you're not on haskell-cafe, I'm asking about hackagebot future there: https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125828.html . (Best to reply on-list for consensus, I'm afk right now) o/
12:21:33 <ertes> ckubrak: you should read this: https://www.vex.net/~trebla/haskell/IO.xhtml
12:21:41 <johnw> if anyone has any mailing list problems today, please let me know.  I turned on several more anti-spam measures today.
12:22:05 <ckubrak> geekosaur: I'll do some research on that, thanks
12:23:21 <ckubrak> ertes: thanks
12:27:26 <sphinxo> say I have a function that returns ExceptT ErrorType FreshM (Int, Int)
12:27:38 <sphinxo> How can I get the (Int,Int) ?
12:28:06 <geekosaur> >>= or do notation
12:29:22 <sphinxo> how can I pull it out with >>= ?
12:29:26 <notdan> sphinxo: use runExceptT, runFreshM etc
12:29:31 <sphinxo> ahh
12:29:46 <ertes> sphinxo: what do you mean by "pull out"?  what's the type of the function that does what you want?
12:29:48 <notdan> not sure what arguments do those functions take exactly
12:30:05 <sphinxo> yeah they are just placeholders notdan 
12:30:18 <dfeuer> ertes, I'm looking at GHC.Conc.Sync.alwaysSucceeds, and it looks a bit weird. I can't figure it out from source because I don't know what check# does.
12:30:52 <sphinxo> notdan: how do I run both the FreshM and ExceptT
12:31:08 <sphinxo> oh wait
12:31:10 <sphinxo> nvm
12:31:19 <ertes> dfeuer: honestly i've never used alwaysSucceeds
12:31:34 <ertes> dfeuer: also i've never actually looked at the implementation of any of this stuff
12:40:32 <jackhill> is http://hackage.haskell.org/package/cabal-test-quickcheck the recommended way to use QuickCheck with Cabal test suites? I ask because I see that it is not yet in stackage while many other quickcheck things are, so that made me wonder about it's popularity.
12:43:13 <mmaruseacph2> jackhill: try tasty and tasty-quickcheck instead
12:43:30 <mmaruseacph2> if you use stack, start the project usint the tasty-travis template
12:46:49 <jackhill> mmaruseacph2: cool, I'll look into that, thanks
12:56:40 <zq> .
12:57:16 <ertes> is there a total variant of Map or even better HashMap?  i.e. one where i register keys, and then lookups with those keys will never fail
12:57:21 <fryguybob> dfeuer: You can think of alwaysSucceeds and check# as a debugging tool.  But it is broken and I'm not sure there is an implmentation that doesn't have a fundamental problem with it.  I will make a proposal at some point for removing it as a feature (no one uses it as well).
12:58:46 <fryguybob> dfeuer: Also, `orElse` is easier to reason about then your example.  There is no "if someone else is doing something" at the level of transactions, though you may have those semantics with your program.
12:59:01 <ertes> (not sure what the API would look like, but i basically need to simulate dynamically allocated mutable variables)
13:02:11 <Gurkenglas> zipWith f x (drop n x) will keep n items in RAM at a time, right?
13:02:43 <Gurkenglas> "takes n + O(1) space"
13:05:35 <Gurkenglas> (Starting with 1, linearly reaching n as the term has outputted n results of f, staying at n)
13:06:21 <Gurkenglas> (Though there's already n pieces of spine as the first result is outputted)
13:07:04 <jackhill> mmaruseacph2: hmm, one thing about the tasty-quickcheck examples I'm looking at, they all use the exitcode-stdio rather than the detailed interface. Should I care? (and if now why not?)
13:09:11 <mmaruseacph2> jackhill: afaik everything that detailed offers is easier achieved via travis
13:09:15 <mmaruseacph2> *tasty
13:09:20 <Tuplanolla> If you phrase that in terms of evaluating tail thunks and becoming eligible for collection, then yes, Gurkenglas.
13:13:09 <jackhill> mmaruseacph2: ah, neat
13:13:33 <lifter> Does "OverloadedLabels" offer a viable solution to the problem of duplicate record names?
13:14:45 <lifter> Presently I'm using "DuplicateRecordFields" in my project; it's nice but I often have to disambiguate using type annotations. I'm wondering how "OverloadedLabels" fits into all this.
13:15:57 <spikefoo> Can someone help me with this question: Can a valid Haskell program start with a capital letter?
13:16:14 <Tuplanolla> Yes?
13:16:17 <Gurkenglas> Yes.
13:16:27 <Tuplanolla> What's "program" here?
13:16:47 <spikefoo> A single file which can be compiled or run with runhaskell
13:16:57 <geekosaur> lifter, it's a first step toward OverloadedRecordFields
13:17:38 * geekosaur wonders if this question is homework
13:17:42 <lifter> Do you know if "OverloadedRecordFields" landing in the next ver of GHC?
13:17:59 <lifter> Me? Not homework.
13:18:27 <shapr> Gurkenglas: is that true? drop n doesn't discard elements?
13:18:28 <Gurkenglas> For example, you can have 'Just main = lookup "a" [("a", print "#haskell sends its regards.")]'
13:18:34 <geekosaur> won't be in 8.0.2, unlikely to be in 8.2.1
13:19:00 <puregreen> spikefoo: sure. “Right x = Right 3; main = print x”
13:19:01 <kadoban> Gurkenglas: Nice
13:19:24 <Gurkenglas> shapr, the start of x is kept track of until it's used for the first few results of f
13:19:25 <puregreen> Gurkenglas: oh, haven't noticed your message. It's nicer
13:19:43 <lifter> geekosaur: OK, I'll probably wait for 8.2.1 rather than attempt to play around w/ the "intermediate" extensions.
13:21:34 <fsestini> hi guys. i’m trying to build compdata from source (cabal install fails with 8.0.1). however, when runhaskell Setup.hs configure, it finds some missing dependencies which are not really …missing. proof is that cabal offers to reinstall them. what should I do?
13:22:38 <spikefoo> puregreen: so you can define multiple top level functions with a single definition using pattern matching. cool, thanks
13:24:27 <Tuplanolla> @let x : y : z : _ = Identity <$> [0 ..] -- This is a seriously underused idiom for generating local names for indexed identifiers.
13:24:29 <lambdabot>  Defined.
13:24:37 <spikefoo> `Nothing = Nothing; main = print 1` works too
13:24:59 <Tuplanolla> (Pretend `Identity` is any wrapper type.)
13:25:16 <geekosaur> more practical example might be an operator defined via pattern matching, before main
13:28:22 <spikefoo> `Nothing # _ = 0`
13:31:02 <kuribas> > x
13:31:05 <lambdabot>  error:
13:31:05 <lambdabot>      Ambiguous occurrence ‘x’
13:31:05 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
13:31:08 <kuribas> :t x
13:31:10 <lambdabot> error:
13:31:11 <lambdabot>     Ambiguous occurrence ‘x’
13:31:11 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
13:31:26 <kuribas> or?  speak out man.
13:31:44 <Tuplanolla> > L.x
13:31:47 <lambdabot>  Identity 0
13:32:56 <Tuplanolla> Turns out lambdabot has single-letter identifiers already defined.
13:33:09 <geekosaur> yes
13:33:17 <geekosaur> :t e
13:33:19 <lambdabot> Expr
13:33:45 <mmaruseacph2> > Debug.SimpleReflect.x
13:33:48 <lambdabot>  x
13:34:05 <mmaruseacph2> > Debug.SimpleReflect.x + 1
13:34:08 <lambdabot>  x + 1
13:34:26 <Tuplanolla> @undefine
13:34:27 <lambdabot> Undefined.
13:42:16 <kuribas> > foldr (+) 0 [a, b, c, d, e]
13:42:19 <lambdabot>  a + (b + (c + (d + (e + 0))))
13:42:23 <kuribas> > foldl (+) 0 [a, b, c, d, e]
13:42:25 <lambdabot>  0 + a + b + c + d + e
13:43:12 <EvanR> that ...
13:44:09 <EvanR> is probably the complete source of confusion over how haskell evaluates ;)
13:44:24 <EvanR> those expressions are obviously equal in school
13:44:36 <kuribas> > foldl f 0 [a, b, c, d, e]
13:44:38 <lambdabot>  error:
13:44:39 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M879050357172...
13:44:39 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:44:52 <kuribas> :t f
13:44:57 <lambdabot> FromExpr a => a
13:45:41 <kuribas> hm I though f was defined as a function.
13:47:43 <kuribas> > foldl f 0 [a, b, c, d, e] :: Expr
13:47:46 <lambdabot>  f (f (f (f (f 0 a) b) c) d) e
13:48:22 <Tuplanolla> I'll have to pick this up as a teaching tool.
13:48:32 <kuribas> > foldl (<>) 0 [a, b, c, d, e]
13:48:35 <lambdabot>  ((((0 <> a) <> b) <> c) <> d) <> e
13:48:56 <kuribas> EvanR: is that better?
13:49:17 <MarcelineVQ> > reduction (foldr (+) 0 [1..3])
13:49:20 <lambdabot>  [1 + (2 + (3 + 0)),1 + (2 + 3),1 + 5,6]
13:49:47 <kuribas> :t reduction
13:49:48 <lambdabot> Expr -> [Expr]
13:49:54 <Tuplanolla> :t reductions
13:49:56 <lambdabot> error:
13:49:56 <lambdabot>     • Variable not in scope: reductions
13:49:56 <lambdabot>     • Perhaps you meant ‘reduction’ (imported from Debug.SimpleReflect)
13:50:20 <Tuplanolla> I've been tricked.
13:50:21 <MarcelineVQ> reduce / reduction
13:52:57 <EvanR> kuribas: yes
13:53:48 <athan> Is there a mainstream Percentage type?
13:54:50 <Tuplanolla> What would be the use of that, athan?
13:54:56 <EvanR> yeah, speaking with someone familiar with APL, and lisp "+" behavior, its sometimes clear that precedence, order of operations, evaluation have all been thrown into a blender
13:57:18 <kuribas> EvanR: well lisp doesn't have precendence
13:57:23 <kuribas> AFAIK
14:00:08 <kuribas> > foldl (⊗) 0 [a, b, c, d, e]
14:00:11 <lambdabot>  ((((0 ⊗ a) ⊗ b) ⊗ c) ⊗ d) ⊗ e
14:03:22 <athan> Tuplanolla: Just type clarity, like how `Sum Int` is different from just `Int`
14:04:52 <Tuplanolla> So you basically want a refinement type for numbers between 0 and 1, athan.
14:10:15 <lifter> Does anyone know if it's possible to use Liquid Haskell on a project that is build w/ stack and requires GHC 8.0?
14:12:18 <pikajude> :t (⊗)
14:12:19 <lambdabot> Expr -> Expr -> Expr
14:12:39 <geekosaur> lifter, I don't think it was updated for ghc 8
14:12:56 <geekosaur> also, Liquid Haskell is very much an experimental prototype, not a finished product
14:16:46 <Keepo> Hi all, is there a way to use a derived instance in a definition of an instance?
14:17:10 <Keepo> For example, say I have a huge algebraic datatype, and I don't want to pattern match on everything..
14:18:03 <kadoban> Keepo: Not really clear what you mean
14:18:27 <Shockk> I think Keepo means derive the instance for a particular pattern match of the value
14:18:41 <Keepo> Say I have a datatype Huge = Huge1 | Huge2 |... | Huge50 | Reverse Huge
14:19:17 <Keepo> And I want it to be an Eq instance such that HugeX == HugeX and HugeX == Reverse HugeX and that's all
14:19:18 <Shockk> for example derive the Show instance for Huge1, but write a custom Show instance for Huge2?
14:20:06 <Keepo> But then I have to pattern match on Huge1, Huge2,... if I want to make my own instance
14:20:21 <kadoban> Don't think so. Maybe someone else can think of a trick ... I got nothing.
14:20:23 <Shockk> I'm not sure if that's possible, what you're asking
14:20:47 <Keepo> I guess I can just make another type  isomorphic to (Huge, Bool)
14:20:57 <Keepo> Thanks anyway
14:23:24 <Shockk> Keepo: what you could do is derive the instance for Huge, and then create a wrapped newtype of Huge
14:24:16 <Shockk> and write your instance for that so that _ results in the value from the unwrapped instance
14:29:06 <athan> Tuplanolla: Eh, yeah basically. Thanks!
14:29:36 <Keepo> Shockk: That's what I ended up deciding, yeah
14:32:04 <pikajude> you could also use the Show instance for == if you want to be a very bad person
14:33:58 <ner0x652> Hello!
14:34:22 <ner0x652> can somebody help me on a non-standard Haskell question... ?
14:34:34 <Shockk> a lot of people might be able to
14:34:42 <ner0x652> Ok
14:34:46 <ner0x652> let me explain
14:34:48 <kadoban> There's some non-standard haskell people here, I bet you'll have some luck.
14:35:15 <ner0x652> First, I'm am doing a capture the flag competition now, and it has a Haskell related task
14:35:25 <ner0x652> I am a newbie in a Haskell
14:35:44 <kadoban> ... we sure are getting a lot of the same question. Can you link to this thing so we can participate directly at least?
14:35:59 <ner0x652> I need to make a valid Haskell code that starts with the magic words GIF
14:36:16 <ner0x652> because it needs bo be injected as a GIF file, at least it is interpreted so
14:36:27 <Shockk> valid source code?
14:36:31 <ner0x652> @kadoban yes, 33c3 CTF
14:36:32 <lambdabot> Unknown command, try @list
14:36:59 <ner0x652> https://33c3ctf.ccc.ac
14:37:09 <ner0x652> @Shockk
14:37:09 <lambdabot> Unknown command, try @list
14:37:14 <kadoban> Thanks
14:37:31 <ner0x652> Shockk, I would say yes
14:37:37 <kadoban> Courtesy of mniip, GIF89a{- binary garbage-} = undefined  should be a good start
14:37:53 <mniip> hi
14:38:54 <ner0x652> mniip Hi!
14:39:03 <ner0x652> kadoban, ok, let me try
14:39:05 <mniip> ah if it's a CTF it probably has relaxed rules on what counts as a gif file :(
14:39:28 <mniip> I have a totally proper and valid gif file over here
14:39:45 <ner0x652> mniip can you share it?
14:40:38 <Tuplanolla> It seems unlikely that you could write a text file that's also a valid GIF file.
14:40:58 <mniip> Tuplanolla, it's not text, but the binary is well-contained within a comment
14:41:14 <mniip> ner0x652, wouldn't that be a little bit of cheating, in context of a contest?
14:41:51 <ner0x652> mniip, yeap, agreed. Sorry, I reacted inappropriately
14:42:23 <Shockk> Tuplanolla: a gif file begins with the magic string: GIF89a
14:42:57 <Tuplanolla> ...followed by a large header.
14:43:04 <Shockk> yep
14:43:25 <Shockk> {- would determine the width of the image, then you can put any binary data in there as long as it's not -}
14:43:47 <Hafydd> How did you send that empty message?
14:44:03 <Shockk> huh?
14:44:06 <mniip> actually the image size is duplicated inside the header
14:44:13 <mniip> so you get another {- for free :p
14:44:25 <kadoban> Haha, nice
14:44:50 <Shockk> Hafydd: is it caused by me doing stuff in { - and - } like this:?
14:44:53 <Shockk> {- test -}
14:45:00 <kadoban> I suppose whatever is in the comment should also be valid utf8, I guess? Not sure how hard that'll be.
14:45:01 <mniip> Shockk, I think that was sarcasm
14:45:15 <Shockk> hmm
14:45:23 <mniip> kadoban, experimental evidence suggests that utf8 conformance is not required
14:45:25 <Shockk> my sarcasm detector isn't very strong apparently
14:45:26 <Hafydd> It wasn't sarcasm, but it was a joke.
14:45:42 <kadoban> mniip: Hmm, interesting. I wonder if it's supposed to be/should be.
14:45:44 <Shockk> oh
14:45:49 <Shockk> it went over my head sorry
14:46:05 <Hafydd> I am {- not -} sorry.
14:48:08 <Shockk> if you need a different width than {- then you can use spaces/tabs/newlines/carriage returns too
14:48:21 <Shockk> but then the height would need to be {-
14:48:53 <Shockk> well I guess you could actually use any character valid in an identifier actually
14:48:56 <kadoban> -- should also be possible to use somewhere.
14:49:00 <Shockk> remove one of those actuallies
14:49:01 <kadoban> Or that, yeah.
14:49:31 <kadoban> You probably do want a comment in there somewhere just for kicks, though maybe in hard mode you could skip it? Heh.
14:52:06 <mniip> I sort of want to write a program that iteratively iterates pixels of the gif image to try to get the LZW output to be what it needs to be
14:52:18 <mniip> but then the utility of that would be ~0
14:52:41 <mniip> as a comment is fine
14:54:07 <brix_> hey
14:54:41 <ner0x652> mniip can you give a hint or some direction on how to solve, because I don't have any ideas, tried what you suggested but it failed
14:55:33 <brix_> I made a bet with my friend, that whatever letter he chooses, I could write simple Hello world program in haskel which starts with that letter (thb, I thought I could do something like <letter> = "Hello world"; main = print $ <letter>. But, he chose uppercased X (damn, did I lose?)
14:55:57 <brix_> as I see, uppercase is reserved for constructors only
14:56:06 <mniip> this question seems familiar
14:56:27 <mniip> aren't you trying to write a program that starts with GIF89a
14:56:33 <kadoban> I wonder how many times we're going to get this question.
14:56:40 <ner0x652> :D
14:56:47 <kadoban> That one is at least adorably disguised.
14:57:13 <brix_> I have no idea what's GIF89a, my friend asked me question about that uppercase stuff 
14:57:26 <Tuplanolla> You're the third person today, brix_.
14:57:27 <kadoban> Uh huh.
14:57:35 <Tuplanolla> Tell that person to ask the other two.
14:57:51 <ner0x652> :D
14:57:52 <brix_> is that for some kind of challenge/competition?
14:58:00 <brix_> I mean that type of question
14:58:11 <mniip> well, answering your question, your program could begin with
14:58:13 <ner0x652> brix_ yes, it's from a competition
14:58:15 <mniip> X=X
14:58:25 <mniip> where data X=X is declared at a later point in the file
14:58:47 <EvanR> well this competition seems broken on several accounts
14:59:12 <EvanR> the question is boring as hell and the solution is to pipe IRC into the answer box
14:59:12 <brix_> mniip: something like post-declaration? I wasn't even aware that something like that exists
14:59:24 <kadoban> Haskell mostly doesn't care what order you do things in.
14:59:37 <mniip> brix_, everything can be post-declared in haskell
14:59:53 <mniip> functions, datatypes, classes, instances, fixity declarations
14:59:54 <brix_> EvanR: sorry, I wasn't aware it was from competition, I'll told my friend then, that I know how to do it, but I'll tell him that later :)
15:03:07 <brix_> err, I just tried, with X=X \newline data X = True  | False
15:03:10 <brix_> and it doesn't work
15:03:25 <EvanR> myth busted
15:03:44 <kadoban> That's broken in a couple of ways, the error message you get should give at least one of them. Or you can just more carefully re-read what was given above.
15:04:19 <brix_> "data X=X is declared at a later point in the file", what does it mean to declare X=X, you mean declare X?
15:04:29 <mmaruseacph2> brix_: X=X; data X = X; main = print "Hello world"
15:04:38 <mmaruseacph2> where each ; can be several newlines
15:04:54 <brix_> wow, magic :o
15:05:30 <brix_> so it works for every declaration, I mean it doesn't matter in which part of the file I declare something?
15:05:42 <mmaruseacph2> yep
15:05:54 <brix_> ok, thx! today I've learnt something new!
15:06:11 <mmaruseacph2> unless you use template haskell
15:06:31 <Tuplanolla> I just generated a tiny GIF file and I don't see how it's possible to eliminate all the nonprintable characters.
15:06:34 <EvanR> what does X = X even do?
15:06:54 <monochrom> "X = X" doesn't do anything. But it can be valid. It's of the form "pattern = expression", meaning you match the RHS expression against the LHS pattern.
15:07:18 <monochrom> But this example is too tautological to have any impact.
15:07:42 <EvanR> [1,x,3] = [1,2,3]
15:07:52 <EvanR> at the top level... causes top level x=2
15:07:57 <EvanR> mind blown
15:08:28 <kadoban> Haha, yeah, it's pretty weird. But it makes sense.
15:09:01 <monochrom> More typical uses are "(x, y) = divMod 50 24" and "x:xs = [1..]"
15:10:39 <monochrom> I also did "LanguageDef{reserved = myreserved, semicolon = mysemicolon} = <something that builds a LanguageDef record>" (when using Parsec)
15:11:05 <monochrom> Err maybe s/LauguageDef/Tokenizer/
15:12:09 <monochrom> Here: https://wiki.haskell.org/Parsing_expressions_and_statements#Make_token_parser
15:15:25 <kuribas> > foldr (⊗) 0 [a, b, c, d, e]
15:15:28 <lambdabot>  a ⊗ (b ⊗ (c ⊗ (d ⊗ (e ⊗ 0))))
15:15:35 <kuribas> > foldr (⊗) 0 [1..10]
15:15:37 <lambdabot>  1 ⊗ (2 ⊗ (3 ⊗ (4 ⊗ (5 ⊗ (6 ⊗ (7 ⊗ (8 ⊗ (9 ⊗ (10 ⊗ 0)))))))))
15:18:20 <kuribas> > expr $ foldr (<>) 0 [1..5]
15:18:22 <lambdabot>  1 <> 2 <> 3 <> 4 <> 5 <> 0
15:19:06 <kuribas> no parens?
15:19:44 <EvanR> <> is assoc duh ;)
15:22:43 <kuribas> > expr $ foldl (<>) 0 [1..5]
15:22:46 <lambdabot>  ((((0 <> 1) <> 2) <> 3) <> 4) <> 5
15:23:04 <kuribas> EvanR: and here with parens...
15:31:28 <MarcelineVQ> infixr 6 <>
15:53:54 <johnw> ok, for a few hours there I don't think mail delivery for the mailing lists was happening; should be fixed now
16:48:26 <hirad_> Hey folks… is this a good place to ask basic code questions?
16:48:49 <Clint> if they're about haskell
16:49:14 <hirad_> Excellent! :D
16:51:22 <hirad_> I’m very new and I’m trying to do some exercises in Haskell… in this case, writing a function that takes a hex string “4d15c2” and turns it to a ByteString. I’ve got `pack . unhex` to do this (pack from Data.ByteString.Char8, unhex from Data.Hex), but I’m getting a type mismatch.
16:51:45 <hirad_> I can’t pin down why the type mistmatch occurs. 
16:52:14 <monochrom> what is the type of unhex?
16:52:29 <monochrom> where can I find Data.Hex?
16:52:58 <hirad_> Monad m => t -> m t (which I don’t fully understand in this context)
16:53:08 <hirad_> https://hackage.haskell.org/package/hex-0.1.2/docs/Data-Hex.html
16:53:40 <niklasb> Hi guys. If you always wanted to break Haskell code instead of building it, feel free to check out 33C3 CTF at https://33c3ctf.ccc.ac/. We have two Haskell challenges, try and coercive
16:53:59 <hirad_> In ghci, unhex seems to do what I need
16:54:37 <monochrom> I'm too lazy to install this library and try it myself. what does unhex "4142" give you?
16:55:04 <hirad_> “AB”
16:55:07 <hirad_> in GHCI
16:55:59 <hirad_> :t unhex “4142” produces “Monad m => m [Char]” 
16:56:01 <lambdabot> error: lexical error at character '\8220'
16:56:26 <monochrom> OK I think you should set m=Maybe.
16:57:26 <monochrom> Also I think it's better for many reasons to pack before using unhex, i.e., make unhex work on ByteString instead of String.
16:58:19 <monochrom> So here it goes: case unhex (pack "4142") of Just v -> <the answer is v, what do you want to do with it now?> ; Nothing -> <input is invalid, what do you want to do here?>
16:58:31 <hirad_> Re. setting m=Maybe, how do I “set” that? I should write the surrounding code so it’d be inferred, correct?
16:58:45 <monochrom> Yes, just what I said.
16:59:02 <hirad_> Right.. ok
17:08:37 --- mode: ChanServ set +o monochrom
17:08:54 --- mode: monochrom set +b *!*@unaffiliated/codeslay0r
17:08:54 --- kick: niklasb was kicked by monochrom (niklasb)
17:09:23 --- mode: monochrom set -b+b *!*@unaffiliated/codeslay0r $a:codeslay0r
17:09:28 --- mode: monochrom set -o monochrom
17:16:01 <hirad_> Thanks, monochrom! Got it working :)
17:20:59 <bennofs> monochrom: :o may I ask why that ban? or should I ask that somewhere else?
17:21:12 <monochrom> looked like spamming
17:21:53 <bennofs> it's actually legit, chaos communication congress is currently ongoing and as part of the event there is a CTF which has some haskell challenges as well
17:22:06 <monochrom> OK then I'll unban.
17:22:37 --- mode: ChanServ set +o monochrom
17:22:57 --- mode: monochrom set -b $a:codeslay0r
17:23:02 --- mode: monochrom set -o monochrom
17:23:59 <johnw> it really looked like spam to me too, trying to bait people in this channel to click the link
17:24:13 <johnw> since only the word "Haskell" seemed to make it relate to haskell
17:37:02 <kadoban> It's related to that question that was asked like 12 times above, about starting a haskell file with a capital letter.
17:38:30 <monochrom> eh?
17:40:49 <geekosaur> aha, yes, that would make sense
17:42:44 <digitalmentat> vincenz, are you around? I wanted a bit of guidance on what might be the best way to go about augmenting the `memory` library's base32 encoding functions?
17:43:35 <dolio> So bans aren't enough? We need to track them down and rough them up for being a general nuisance?
17:44:25 <ludat> Is there some way to goto definition of a function declared inside a package? (in emacs for example)
17:44:49 <dolio> If you have etags set up, they can probably do that.
17:45:26 <ludat> I mean inside another package, like from yesod for example
17:45:41 <ludat> I have intero setup (from spacemacs)
17:45:56 <dolio> Oh. In that case you'd need source and tags for that package.
17:46:27 <ludat> but can I get the source easily using stack?
17:46:39 <dolio> Dunno.
17:48:09 <ludat> mmm.. ok, thanks I'll probably come back later
18:06:47 <buttons840> I'm trying to use tryJust from Control.Exception, but I'm not sure how to write a function of the type `Exception e => (e -> Maybe b)`?
18:07:57 <buttons840> I.e., how do I determine if e is a HttpException?
18:09:22 <ertes> ludat: if you have haskell-interactive-mode set up, M-. will look up a symbol in the context of the loaded module
18:15:03 <c_wraith> buttons840: add a type signature
18:15:05 <geekosaur> buttons840, I think for this you want try; tryJust would be for when you wanted to distinguish between error constructors (e.g. if you are using http://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Conduit.html#t:HttpException it would let you catch HttpExceptionRequest and rethrow InvalidUrlException) 
18:15:15 <ludat> ertes, I have intero and it does an excellent job if the function I'm looking for is in my package but if it's from an external package (like yesod or snap) it can't find it
18:16:40 <buttons840> geekosaur: wont try catch every kind of exception? I don't necissarily want that do I?
18:16:51 <geekosaur> no, because you use the type system to control it
18:17:13 <geekosaur> so you want try, and specify the result type as IO (Either HttpException whatever)
18:17:16 <buttons840> :t try
18:17:17 <lambdabot> Exception e => IO a -> IO (Either e a)
18:17:23 <ludat> buttons840, the Exception typeclass indicates that something is an exception, not that it throws an exception
18:17:31 <tommd> buttons840: You had previously asked how to use DRBG. What type of information were you looking for?  What should I add to the docs?
18:17:33 <buttons840> right
18:17:53 <buttons840> tommd: i don't know what DRBG, I think you're mistaken
18:17:55 <geekosaur> and the type tells it to catch HttpException only and rethrow anything else
18:18:49 <buttons840> so I can make the `e` in `try` any type I want? so long as it's a "subtype" of Exception -- by making the type more specific i will be limiting what kind of exceptions I catch?
18:18:53 <tommd> buttons840: I'm referring to this question (http://ircbrowse.net/browse/haskell?id=23331076&timestamp=1473137004#t1473137004) but if it wasn't you or you don't remember then that's that, I was just looking for feedback.
18:18:58 <geekosaur> yes
18:19:12 <geekosaur> it's somewhat weird, but the more natural way of using constructors isn't extensible
18:19:54 <buttons840> tommd, oh, yeah, that was a long time ago and i'm not working on the same thing now
18:20:05 <geekosaur> so you often see stuff like catch (\(SomeException e) -> ...) to catch all exceptions, or catch (\(IOException e) -> ...) to catch just IO exceptions, etc.
18:20:34 <buttons840> geekosaur: in those examples `IOException` is a data constructor or a type?
18:20:38 <geekosaur> (note that that particular usage requires ScopedTypeVariables extension; but for try you don't)
18:20:39 <geekosaur> it
18:20:57 <geekosaur> gah I fluffed those actually
18:21:18 <geekosaur> so you often see stuff like catch (\(e :: SomeException) -> ...) to catch all exceptions, or catch (\(e :: IOException) -> ...) to catch just IO exceptions, etc.
18:21:19 <geekosaur> types
18:21:34 <buttons840> ok :)
18:41:10 <edwardk> this is why lens has catching _ArithException  and the like
19:06:50 <codygman_> Can anyone help me with figuring out how this fold should look to do grouping on a map? http://lpaste.net/350543
19:22:20 <orion> Is anyone using acid-state in production?
19:22:38 <tmciver> codygman_: I'm no expert, but perhaps something like this: http://lpaste.net/350544
19:23:05 <jackhill> Hi, I'm trying to follow the instructions on this page <https://www.haskell.org/platform/windows.html> to install the minimal platform on Windows. I did the install and everything seems to work, but I'm a little confused about step 3
19:23:12 <jackhill> modifying the cabal paths.
19:23:50 <jackhill> I assume that I want to add the ones listed there to the defaults, but I'm not sure of the correct syntax.
19:34:49 <codygman_> tmciver: Not quite, but thanks for the help :)
19:35:41 <codygman_> jackhill: Just copy it as is and put it in your cabal config file. Those paths are needed for haskell build stuff it seems.
19:38:17 <jackhill> codygman_: okay. I did a cabal user-config init, so those lines are already present with different values (e.g. C:\Users\jackhill\AppData\Roaming\Cabal\bin for extra-prog-path)
19:38:31 <jackhill> should I add duplicates for those lines or overwrite them?
19:40:13 <codygman_> jackhill: Huh, I'm not totally sure. I've been making educated guesses. If you are comfortable with that though, can you give a list of whats in the Roaming\Cabal\bin directory vs what is in the suggested msys/usr/bin directory? 
19:40:37 <jackhill> codygman_: sure, one sec
19:43:21 <jackhill> hmm, Roaming\Cabal\bin doesn't exist. I wonder if that's where stuff I would cabal install would go.
19:43:41 <codygman_> jackhill: It might get created
19:45:05 <codygman_> jackhill: In the absence of a better answer, I would just follow the instructions on the install page or install with stack instead.
19:47:29 <lpaste> jackhill revised “msys bin dir listing”: “msys bin dir listing” at http://lpaste.net/350545
19:48:44 <jackhill> codygman_: okay thanks. I know it's a tired line, but I'm just trying to help a friend by following along with what they did. Usually I don't use Windows.
19:49:01 <jackhill> at least I got further than they did as I can get a ghci prompt ☺
19:49:25 <codygman_> jackhill: It's fine. I wish I could be of more windows specific help instead of "use stack" ;)
19:49:42 <jackhill> no worries, thanks for your time
19:51:25 <tmciver> codygman_: May not be the most elegant, but this seems to work for me: http://lpaste.net/350544
19:55:17 <geppettodivacin> If you bind a type variable at the top level, does it carry into where clauses?
19:56:34 <geppettodivacin> For example, f :: Bounded a => a -> a -> Int; f = .. where x = maxBound :: a
19:56:51 <geppettodivacin> Is the a at the top level the same as the a used for the maxBound?
19:57:20 <suzu> if it is in the where clause of f, then yes
19:57:38 <suzu> it uses the same `a` as in f's type signature
19:57:54 <geppettodivacin> Thanks, suzu. Then I've got a phantom error that I can't pin down. Give me a second to paste it.
19:58:11 <suzu> ok
19:58:37 <pavonia> No, it doesn't do that by default
19:58:46 <pavonia> You need to enable -XScopedTypeVariables
19:59:25 <pavonia> And put an explicit forall before the type
20:02:30 <geppettodivacin> pavonia: Ah, that sounds fixable.
20:02:57 <geppettodivacin> Do you need forall in front of all type variables when you use ScopedTYpeVariables?
20:05:00 <tmciver> geppettodivacin: No, just the ones used in the where clause, in this case.
20:07:24 <geppettodivacin> Yeah, that fixed it. Thanks, tmciver, pavonia.
21:03:34 <cheshircat> Hey guys, do you know any formal development of applicative functors in category theory?
21:03:41 <cheshircat> Do you have a good resource for that?
21:13:40 <johnw> cheshircat: strong lax monoidal functors
21:15:19 <JSharp> This reference might actually be a bit more helpful in explaining what the documentation means in terms of category theory: <https://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors>
21:23:43 <riaqn> Hi, could someone paraphase this for me? The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and ThreadKilled, and passes all other exceptions to the uncaught exception handler.
21:25:05 <riaqn> To be specific, i don't understand what "discard" means
21:26:53 <JSharp> Well, without reading the source, I would guess that the exceptions are simply ignored and/or not passed to the exception handler. Sometimes, systems that use exceptions for control flow exhibit that behaviour.
21:27:54 <riaqn> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:forkIO
21:28:05 <riaqn> This is the source.
21:29:43 <riaqn> JSharp: I just tried and it seems that threadKilled does kill a thread of forkIO
21:30:08 <riaqn> I MEAN,  a thread created by forkIO
21:30:09 <JSharp> riaqn: looks like <https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Conc.Sync.html#real_handler> is where that behaviour originates.
21:31:19 <riaqn> JSharp: my understanding is that, threadKilled is not for user to handle?
21:31:51 <riaqn> It’s handled by RTS strictly
21:32:22 <cheshircat> thank you johnw and JSharp
21:34:23 <JSharp> riaqn: it does indeed appear that the user provided exception handler is not invoked when those exceptions are raised, however, I am not terribly familiar with Haskell concurrency just yet.
21:34:31 <JSharp> cheshircat: no worries
21:35:02 <riaqn> JSharp: thanks! I will just assume this.
21:38:01 <JSharp> riaqn: hope I've been helpful, but again, please take anything I've said with a grain of salt. I'm just getting started.
21:57:05 <riaqn> JSharp: no worries! We are always learning.
21:57:24 <JSharp> cheers :)
23:21:14 <rdococ> hello
23:21:26 <Lokathor> saluton
23:21:33 <rdococ> bon...jour?
23:22:20 <Lokathor> saluton is Esperanto
23:22:30 <Lokathor> though Esperanto often looks like french and/or spanish
23:22:37 <Lokathor> it's kinda a bluring of all the romance languages
23:23:28 <rdococ> ok
23:23:40 <Lokathor> so what are your questions and/or comments regarding Haskell
23:24:11 <rdococ> where did the name originate
23:24:26 <Lokathor> https://en.wikipedia.org/wiki/Haskell_Curry
23:25:20 <rdococ> tasty?
23:26:12 <Lokathor> no he was a mathimatician
23:32:16 <Blizzardlolz> Hello
23:34:21 <Blizzardlolz> Companies will actually have you drink dihydrogen monoxide!Spread the word!!
23:35:04 <Blizzardlolz> Connrs
23:35:22 <Lokathor> it's in my milk right now
23:35:22 <Blizzardlolz> PING
23:35:45 <Blizzardlolz> Omg be carful
23:35:50 <Blizzardlolz> It's everywhere
23:35:52 <rdococ> oh no
23:36:00 <rdococ> did someone say dihydrogen monoxide?!
23:36:02 <rdococ> aaah!
23:36:20 <Blizzardlolz> Yes
23:36:36 <Blizzardlolz> Leading cause of asphyxiation in water
23:36:56 <rdococ> also known as burnt hydrogen!
23:37:35 <Blizzardlolz> Lost me there
23:37:35 <rdococ> :o
23:37:53 <rdococ> when you oxidize something, oxygen or some other oxidizer is added to its structure
23:38:06 <rdococ> hydrogen, then, gets oxidized into wa-sorry I mean dihydrogen monoxide.
23:38:19 <Blizzardlolz> Gotcha, I'm tired lmao
23:38:26 <rdococ> thus, water is burnt hydrogen.
23:38:40 <Blizzardlolz> I've never considered that
23:38:41 <rdococ> I wanna say hydrogen rust but apparently it's not something-or-other.
23:38:58 <Blizzardlolz> #themoreyouknow
23:39:11 <rdococ> um
23:39:14 <rdococ> that channel does not exist
23:39:32 <Blizzardlolz> 😂 
23:40:43 <rdococ> we must ban it
23:40:56 <rdococ> :p
23:41:06 <Blizzardlolz> It exists now
23:41:34 <systemfault> Let`s replace it with Brawndo... it has electrolytes.
23:42:44 <Blizzardlolz> My cum has protein
23:43:02 <rdococ> tasty
23:50:55 <jchia> Question about how to search documentation. Let's say I see the entry for Monad and under it 'fail'. I want to know what it does exactly, because the natural language description isn't always clear, so I click on 'Source' on the right. http://localhost:8000/file/home/jchia/.stack/programs/x86_64-linux/ghc-8.0.1/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:fail
23:51:08 <jchia> but then I just see the top of GHC.Base
23:51:31 <jchia> so, generally, how do I find the code for some function that I see on haddock? I often get bounced to nowhere
23:51:50 <Lokathor> well, you're looking at a local copy, for one
23:52:28 <Lokathor> perhaps your docs aren't generated properly somehow? for example, https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IORef.html#newIORef
23:52:41 <Lokathor> the hackage.haskell.org docs seem to be working
23:52:56 <jchia> http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Monad
23:53:13 <jchia> Look for 'fail' under 'class Applicative m => Monad m where'
23:53:34 <jchia> click on 'Source' and get bounced to: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#fail
23:53:44 <Lokathor> oh i see the problem, yes
23:53:46 <jchia> #fail just goes to the top of the page
23:53:55 <Lokathor> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#Monad try there
23:54:31 <geekosaur> this sounds like a bug in haddock...
23:54:35 <Lokathor> typeclass methods don't normally have source at all, since the source is with the types that implement the type class
23:54:54 <Lokathor> the only reason that fail has source is because it's got a default implementation
23:55:04 <geekosaur> although possibly haddock is confused by the fact that fail is being moved
