00:00:12 <Lokathor> sound also only half works :P
00:00:15 <edwardk> alternately just using modern opengl would fix almost everything perf wise instantly
00:00:19 <Lokathor> its a mountain to climb
00:00:43 <Axman6> edwardk: hey do you know a good OpenGL library? =)
00:00:47 <edwardk> but would require you to try to figure out how to generate something functionally equivalent to his code as you worked through he videos and something like the opengl superbible at the same time
00:00:52 <edwardk> Axman6: i use gl =P
00:00:57 <Axman6> ;)
00:01:24 <Lokathor> yeah, right bow it builds a ByteString, using Surface would let me have a hardware accelerated direct pixel buffer instead
00:01:29 <edwardk> actually, currently i use c++ ;)
00:01:40 <Lokathor> gasp!
00:02:17 <edwardk> i now have a fair bit of succinct code in shader form =P
00:02:41 <Lokathor> we need a "how to opengl using the haskell gl library" book
00:02:42 <edwardk> makes very general memory efficient compute passes possible.
00:03:16 <edwardk> the main thing with the gl library is it doesn't try to feel haskelly. it tries to make it so you can just read the c tutorial on a thing and use it
00:03:41 <edwardk> the defines are all there with the same names as pattern synonyms. the functions are all there with the same names and just as awfully unsafe as the c versions
00:04:16 <Lokathor> i rememver having trouble once, not knowing the ffi elements makes it super tricky
00:04:27 <edwardk> my current code is off in c++ because it has to talk to things like OpenVR and other c++ libraries, and haskell just sucks at that
00:04:41 <edwardk> Lokathor: fair
00:05:16 <edwardk> for a while the quine repo served as a reasonable intro. i haven't really tried building it in a year. i recall the #haskell-game folks upgraded sdl2 quite a bit since i stopped
00:05:17 <Lokathor> another book subject :P
00:05:45 <Lokathor> yeah sdl2 is pretty good now, obly missing a few thing
00:05:53 <Lokathor> things*
00:06:23 <edwardk> another potential talk topic for lambdajam might be to go into how to port a haskell style IO manager and make lightweight fibers work in c++ for things like propagators.
00:06:41 <edwardk> but giving a c++ keynote for lambdajam might just get me off the christmas card list of the organizers
00:07:02 <edwardk> so i think transients might be a better pitch =)
00:09:31 <athan> no way, that's like how compilers are implemented
00:10:36 <edwardk> athan: basically its a whole bunch of RTS stuff i started to put together for a toy game engine before i decided if i was going to need it
00:10:59 <athan> D: can I see it? It sounds awesome. I just started learning about g machines
00:10:59 <edwardk> moving everything to vulkan will be vastly more efficient than finishing it
00:11:20 <edwardk> some bits and pieces of it are in https://github.com/ekmett/vr
00:11:44 <athan> is vulkan your vr system, or a new language?
00:12:30 <edwardk> vulkan is the sort of next generation opengl replacement that lets you do things like talk to it from *gasp* multiple threads
00:12:42 <athan> :O lawd
00:13:49 <edwardk> right now the vr code i have carefully sets up one main thread for working with opengl, then in a branch that might not be on github, i have code for setting up a batch of worker threads that pump a job queue for tasks or fibers and recycle the stacks the fibers were running on between them
00:14:18 <edwardk> the trick is that context switching this way is way way faster than anything involving a real thread switch
00:14:29 <edwardk> something like boost::context is super fast
00:15:11 <edwardk> then i just need to keep all the locks out of the management of the worker pool by using wait-free structures and epoch based reclamation
00:15:15 <athan> woah... hm, so you keep it from paging?
00:15:33 <edwardk> the goal is to keep it from having to lock to switch fibers
00:15:33 <athan> (c++ is still on my list of things to learn overnight)
00:15:55 <edwardk> switching threads is expensive in the timescale i'm interested in
00:16:29 <athan> epoch meaning absolute / predetermined time scales?
00:17:20 <athan> that is friggin awesome. It sounds like something FRP-esque (as a background), but this is where i put my foot in my mouth
00:17:29 <athan> backend*
00:17:30 <edwardk> raw context switching means something like 700ns overhead. switching fibers is ~37ns on the same kind of machine. the goal is to keep the pool management down low enough that it doesn't lose that edge
00:17:43 <edwardk> epoch based reclamation is actually a tricky idea
00:17:45 <edwardk> let me link a video
00:18:16 <edwardk> https://www.youtube.com/watch?v=aV-RyMXXuks
00:18:29 <athan> ;-; santa does exist
00:18:39 <edwardk> ^- that video is worth watching all the way through if you care about lock-free or wait-free structures and algorithms at all
00:19:08 <athan> definitely, I will. Thank you, time to get my thinking cap oh god
00:19:11 <edwardk> samy goes through a pretty solid overview paper on the topic then proceeds to double the efficiency of the best variant
00:20:56 <edwardk> once you switch to lock-free queues and the like someone has to clean up old parts of the structure. and you can't afford 'real' gc. the epoch scheme is probably my favorite cleanup technique for when i'm not, say, in the kernel.
00:21:17 <edwardk> this is for super painfully closed to the metal stuff
00:21:24 <athan> could this relate at all to linear types?
00:21:33 <athan> er, utilize
00:21:37 <edwardk> sorta
00:21:46 <edwardk> there is a cute little post on doing this sort of thing in rust
00:22:01 <edwardk> https://aturon.github.io/blog/2015/08/27/epoch/
00:22:32 <edwardk> i don't personally find that the marginal benefit of types there helps in a meaningful way, but i've learned how to be very careful with these sorts of garbage
00:23:24 <edwardk> anyways aaron's approach in that article gets to use all the rust type system bells and whistles
00:23:53 <edwardk> but you can't just say 'this part of the structure is linear typed' because someone can be traversing it while you set up a CAS, etc.
00:24:16 <edwardk> the approach mentioned by aaron above works, but its higher level than you might think
00:24:16 <athan> ahh okay, that sounds very tricky
00:24:45 <edwardk> samy walks through the sort of issue i mean in the video i linked
00:25:13 <edwardk> sbahra doesn't lurk in here very often but he does sit in ##systems
00:25:46 <edwardk> and moderates /r/systems with me and a few others
00:26:56 <athan> quit tempting me lol, I have too much work that I don't actually need to do as it is >.>
00:27:23 * athan and there goes the night
00:27:27 <edwardk> anyways the whole idea was, move my code into fibers, then i can literally hand the current computation off to an async io manager for callbacks, i can make things like { with_gl gl_lock; .... }   and everything inside the { } block gets RAII'd onto the opengl thread, etc.
00:28:31 <athan> oh wow, so compositional concurrency without detrimental GC? ..kinda?
00:28:36 <edwardk> and by using a small pre-bounded number of workers that are known not to be blocking on IO i can use wait-free algorithms for stuff
00:28:56 <athan> er, realtime[tm
00:29:11 <edwardk> but i need the epoch reclamation scheme to clean up 'dead' parts of the queues used to push these fibers around
00:29:59 <edwardk> in haskell you don't have to use things like hazard pointers or epoch reclamation because we stop the world every so often to touch all the things.
00:30:11 <edwardk> but the downside of that is that as the queues get bigger you have more stuff to touch
00:30:31 <edwardk> and you after all, have to stop the world which is the very antithesis of lock-free design
00:31:20 <edwardk> and lock-free algorithms don't scale as well as the sort of wait-free ones i care about as your core count rises.
00:32:02 <athan> Do you think alternative GC implementations could help alleiveate this in GHC?
00:32:13 <edwardk> this isn't a gc
00:32:16 <athan> beyond the alg. designs I mean
00:32:21 <athan> :s
00:32:52 <edwardk> its more like userspace RCU
00:33:29 <athan> rcu? Sorry
00:33:33 <edwardk> its being used to delay cleaning up garbage until we know nobody is using it, but there is a clear 'disposer' involved.
00:33:50 <athan> oh wow okay
00:35:15 <edwardk> basically what you want to do is say 'hey i'm done with this thing and would really like to delete it, it is now time x' and then wait until everyone else acknowledges that fact somehow by saying that they have seen everything up to point x, and then it doesn't matter who throws it away as long as someone does.
00:35:55 <edwardk> RCU schemes are used to reduce reliance on locks, mostly in the linux kernel.
00:35:57 <edwardk> https://lwn.net/Articles/262464/
00:36:48 <edwardk> http://hackage.haskell.org/package/rcu provides a userspace RCU implementation in haskell that exploits the existence of our GC for managing resources.
00:37:15 <athan> that is friggin awesome, man
00:37:29 <Zemyla> I have a question.
00:37:49 <athan> sup Zemyla 
00:38:00 <Zemyla> The current implementation for ArrowChoice on Cokleisli violates the ArrowChoice laws.
00:38:01 <edwardk> you have a main thread that can create new workers. workers can enter a read side critical section where all they can do is read, or a write side one where they can also write to a reference or 'synchronize'.
00:38:29 <edwardk> Zemyla: i vaguely recall this coming up
00:39:06 <edwardk> it really should use a proper costrength
00:39:10 <edwardk> but we don't have a class for that
00:39:12 <Zemyla> So I'm wondering if there is a way to write (Traversable t, Comonad w) => (w a -> b) -> w (f a) -> f b.
00:39:41 <edwardk> t vs f?
00:39:51 <Zemyla> My mistake. It should be w (t a) -> t b.
00:39:54 <Axman6> I was confused for a sec, not sure what a "rength" is. damn greedy reading algorithm >_<
00:40:13 <Zemyla> That's basically Traversing from Profunctors.
00:41:22 <edwardk> anyways the answer should be no.
00:41:47 <edwardk> the thing you ask for there would imply that you can always 'zip' your traversable meaningfully to stitch together the output t b
00:42:33 <Zemyla> Because if there isn't, then Cokleisli isn't an ArrowChoice.
00:42:42 <edwardk> pick w = Pair, data Pair a = Pair a a. this is isomorphic to Bool -> a,    and f = (,) Double
00:42:56 <Zemyla> Because every Traversing is also a Choice, and every ArrowChoice is (or should be) Traversing.
00:43:12 <edwardk> Cokleisli can be ArrowChoice if we have a proper costrength. but extract isn't costrength
00:43:22 <edwardk> that is my very fuzzy recollection
00:43:45 <athan> Isn't strength something like (a, f b) -> f (a, b)?
00:43:49 <edwardk> every functor in haskell is strong. (a, f b) -> f (a, b)   is easy.
00:44:07 <Zemyla> Actually, maybe we're doing the wrong kind of dual for Kleisli vs Cokleisli.
00:44:13 <athan> ahh okay
00:44:19 <edwardk> f (Either a b) -> Either a (f b)        without losing information is harder. it basically requires 'f' to have exactly one 'hole' for an 'a' in it.
00:44:46 <Zemyla> Maybe we should have Cokleisli w a b = Cokleisli { runCokleisli :: forall r. w (b -> r) -> a -> r }.
00:45:02 <edwardk> that is a different beast
00:45:21 <Zemyla> Yeah, it's basically your "Monads from Comonads" transformation.
00:45:22 <edwardk> Cokleisli is really the dual construction
00:46:15 <edwardk> i do mean to go through and remove the lying Comonad m => Choice (Cokleisli m) instance sometime
00:46:29 <edwardk> i need to figure out how to do it without breaking a bunch of code that exploits the lie gainfully though
00:46:50 <edwardk> right now the instance is tagged with a comment
00:46:57 <edwardk> http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Choice.html#t:Choice
00:47:25 <edwardk> as a sign of my displeasure with it ;)
00:48:03 <Zemyla> Oh, I have a question. What exactly *is* Cochoice? And is there a reason Kleisli isn't one?
00:48:10 <Zemyla> Because it seems like it should be.
00:48:20 <edwardk> Cochoice and Costrong are quite strange beasts
00:49:24 <edwardk> Costrong starts to feel like ArrowLoop
00:49:45 <edwardk> and it arises when you start playing funny little games to flip profunctors around
00:49:58 <Zemyla> Does unleft simply pass the a in to the Left, and "loop" it through the Profunctor until the result is also on the Left?
00:49:59 <edwardk> similarly Cochoice arises when you start flipping Choice around
00:50:27 <edwardk> you're fishing for an intuition that woud work in a sort of kleisli monadic kinda context... and it doesn't 
00:50:37 <edwardk> take it as a formal dual to Choice. ;)
00:51:23 <Zemyla> But yeah, WrappedArrow should be a Traversing when the arrow it's wrapped is an ArrowChoice.
00:52:03 <edwardk> ArrowChoice isn't something that i've gone out of my way to map onto the profunctor concepts
00:52:12 <edwardk> the tops of the arrow hierarchy are a damn mess
00:53:03 <Zemyla> Oh, what exactly are the Cochoice laws, so I can know if something is an instance of it?
00:53:48 <edwardk> Traversing is 'is a profuncrtor that is corepresentable by an applicative functor'
00:54:06 <edwardk> p a b ~ (a -> f b)    where f is applicative
00:54:27 <edwardk> it just isn't so kind as to tell you which 'f'
00:55:34 <edwardk> one thing to note re profunctorial strength, strength isn't unique.
00:56:23 <edwardk> have you read rivas and jaskellioff's paper on 'notions of computations as monoids'?
00:56:25 <edwardk> https://arxiv.org/pdf/1406.4823v1.pdf
00:56:37 <Zemyla> Well, yes. But traversing with an ArrowChoice seems to me like it's a simple matter of producing a Bazaar a b t = Done t | More a (Bazaar a b (b -> t)), then one by one turning the as into bs and feeding them in.
00:57:22 <edwardk> 7.1 gives the definition of a strong profunctor
00:58:40 <Zemyla> I mean, you'd probably use a different representation where fmap wasn't O(n) and <*> wasn't O(n^2), but aside from that, it seems straightforward.
00:58:51 <edwardk> anyways for 'Choice' you can take the diagram from 7.1 and replace * with Either. for Co-Foo turn the arrows around
00:59:23 <edwardk> i don't have a concrete recollection if the arrowchoice thing you are looking for breaks down.
00:59:28 <edwardk> build it or disprove it ;)
00:59:45 <edwardk> i don't recall the answer off the top of my head and i don't have a compiler handy to figure it out
01:00:18 <Zemyla> Okay, I'll build it. :P
01:00:21 <edwardk> the bazaar thing you mentioned only works on finite containers though.
01:00:27 <edwardk> this is why i favor the other bazaar in lens
01:01:02 <edwardk> of course its harder to get your head around to use, and is likely almost vacuous in this case
01:01:04 <Zemyla> edwardk: Actually, it works on infinite containers as long as they aren't left-infinite.
01:02:19 <edwardk> sadly not true. you can try to replace the uses of bazaar/context in lens with the direct encoding you gave there and just walk some lists with them and a lot of code becomes non-productive that is productive under the funny encoding
01:02:22 <edwardk> lets' see why
01:03:26 <edwardk> forall f. Applicative f => (a -> f b) -> f t   can let you start exploring the 'f t'  you get back without having to first finish an infinite number of pattern matches on More constructors
01:03:35 <edwardk> you never finish walking the 'More's to build the result f t'
01:04:10 <edwardk> i came up with the tricky Bazaar in lens explicitly because the thing you gave above doesn't work on lists ;)
01:04:27 <edwardk> at least for the refilling side
01:04:40 <edwardk> the _reading_ side is lazy enough if its only right infinite
01:05:13 <Zemyla> Hmm. Could you use Magma instead?
01:05:52 <edwardk> i've largely forgotten the unholy tricks i used to glue together magma
01:07:46 <edwardk> i do remember their being some craziness around dealing with the index monoidally that breaks down in infinite left recursion cases with the existing magma code
01:08:04 <edwardk> well i guess that is in Mafic.
01:08:11 * edwardk peeks at the code to refresh his memory
01:09:19 <edwardk> but lets go back and look at your type
01:09:30 <edwardk> (Traversable t, Comonad w) => (w a -> b) -> w (t a) -> t b
01:09:45 <edwardk> in w we know there is one or more 't a' available to us. we can extract after all.
01:10:15 <edwardk> but the key problem here is traversable gives us no way to combine multiple 't's together.
01:10:17 <edwardk> you can of course
01:10:19 <edwardk> walk them
01:10:27 <edwardk> but you have no reason to expect them all to be of the same length
01:10:55 <edwardk> consider t = [[
01:10:57 <edwardk> er []
01:11:11 <edwardk> w = (Bool -> 
01:11:56 <edwardk> (Pair a -> b) -> Pair [a] -> [b] -- this exposes the expectation of zipping
01:12:15 <edwardk> there is no reason to expect it to be legal to 'zip' your traversables.
01:12:52 <edwardk> Wot a = (Maybe a, Maybe a)  has two 'unrelated' named holes where 'a's might live.
01:13:00 <edwardk> and is clearly traversable
01:13:42 <Zemyla> Also, an unrelated problem is there's two possible Comonad instances for Pair.
01:13:58 <edwardk> sure, pick a monoid for Bool. I don't care which
01:14:07 <edwardk> i just wanted an easy comonad
01:14:12 <edwardk> one with more than one 'a'
01:14:20 <Zemyla> Well, Any and All result in the same one, but also there's Xor.
01:14:20 <edwardk> so that you'd have to do something with both
01:14:39 <Zemyla> Yeah, understandable. I went with NonEmpty, which makes things probably even harder and less law-abiding.
01:15:47 <edwardk> anyways, all we need is to poke one hole in this combinator by showing something like the above case and its kaput.
01:16:03 <edwardk> and the Pair case is sufficient irrespective of choice of monoid for Bool
01:16:45 <edwardk> IntMap is maybe more compelling than []
01:17:26 <edwardk> (Pair a -> b) -> Pair (IntMap a) -> IntMap b   -- is an operation you could define, but its not one you can define with just traversable on IntMap.
01:17:40 <edwardk> you have no way to 'zip up the maps'
01:18:28 <edwardk> data Foo a = Foo a | Bar a -- has no meaningful canonical 'zip', its isomorphic to (Bool, a), and you're back to what monoid do you choose for Bool?
01:19:01 <Zemyla> And it's not something you could zip with just Traversable, again.
01:19:05 <edwardk> yeah
01:19:13 <edwardk> well
01:19:16 <edwardk> you can
01:19:18 <edwardk> of course
01:19:23 <edwardk> in this case there is always 1 element
01:19:37 <edwardk> but knowing its traversable isn't enough to _tell_ you that its safe
01:20:09 <edwardk> data X = X a | Y a a runs the risk of differing numbers of values
01:20:41 <edwardk> (also in the Foo case above, you have the problem that which one you choose to refill changes the answer. just like with the (Bool, a) case
01:21:30 <MarkusBarthlen> Can anybody tell me how to clear the settings in haskforce to deselect the ghc-mod path? Forgot how to do it.
01:26:43 <Zemyla> Hmm. If I show you an implementation of Traversing for ArrowChoices that works at least in the finitary and right-infinitary cases, then might there be a case for looking further into seeing whether it works without reassociation?
01:28:03 <MarkusBarthlen> Nevermind, I just uninstalled the plugin.
01:33:07 <edwardk> oh, anyways. the above isn't necessarily a case against ArrowChoice
01:33:11 <edwardk> just the Cokleisli instance
01:33:24 <edwardk> which is what i was going to walk all of this back to originally
01:33:26 <edwardk> then i forgot
01:34:15 <edwardk> so if we had a true costrength 'f' and you had (f a -> b) -> f (t a) -> f (t b)  -- _that_ should be able to work out find
01:34:23 <edwardk> f (Either a b) -> Either a (f b)
01:35:03 <edwardk> or maybe it is flipped
01:35:27 <edwardk> er (f a -> b) -> f (t a) -> t b is the goal
01:36:46 <edwardk> you should be able to do something with 'f' having exactly one place for an 'a', as it should be a left adjoint, isomorphic to (,) x for some x.
01:37:53 <edwardk> lets see. ((x,a) -> b) -> (x, t a) -> t b   -- (x -> a -> b) -> x -> t a -> t b      feed it x, (a -> b) -> t a -> t b
01:38:11 <edwardk> so thats just fmap and the knowledge 'f' is costrong
01:39:39 <edwardk> Zemyla: ^- anyways that shows that the ArrowChoice thing you're looking for is plausible
01:39:51 <edwardk> at least with the fixed Cokleisli instance
01:40:46 <edwardk> but we don't have a 'is left adjoint' class with costrength in it
01:41:18 <edwardk> it sort of belongs somewhere near Data.Functor.Representable as the latter is basically 'is right adjoint'
01:42:02 <edwardk> i guess just having costrength would belong somewhere more compatable to Data.Distributive and Data.Traversable
01:42:24 * edwardk is going to sleep. its christmas. have a nice night ;)
01:42:29 <Zemyla> Goodnight.
01:42:39 <Zemyla> And Merry Snmgfiehp to you.
01:43:20 <edwardk> our christmas decorations consist of a pair of "Bah Humbug" shirts and a darth vadar jingly thing we hang on our door. ;)
01:44:06 <edwardk> this is positively festive compared to years past ;)
01:44:14 <edwardk> anyways, later
02:28:07 <kiki`> hey! let's have a shape of 4 vertices in 3D space (rectangle): A(-1,1,1) B(1,1,1) C(1,-1,1) D(-1,-1.1), and camera at V(0,0,0) targeting V'(0,0,1). We'd like to transform the coordinates onto a 2D screen.. for that it seems we need to scale down x,y proportional to z, right (the further away, the smaller the plane).. how would you do that in haskell?
02:42:27 <lyxia> \(x,y,z) -> (x/z, y/z)
02:52:02 <kiki`> cool.. so that would be the function code? and how would would you note the shape? 
02:52:08 <kiki`> notate*
02:54:25 <kiki`> also how would i have function taking a parameter fov that returns a function \(x,y,z) -> (x/z*fov, y/z*fov)
02:55:22 <srhb> kiki`: \(x,y,z) -> \fov -> ...
02:55:37 <srhb> kiki`: Or simply \(x,y,z) fov -> ...
02:55:39 <kiki`> alright!
02:55:46 <kiki`> thanks
02:55:48 <srhb> kiki`: Same thing. :)
02:58:56 <kiki`> are there any literals reserved, having some special meaning?
02:59:11 <srhb> kiki`: Literals in what sense?
02:59:27 <kiki`> erm. lets have chars a-z
02:59:56 <kiki`> is "f a" the same as "v w"
03:00:28 <srhb> kiki`: There are no a-z one-letter reserved words, afaik.
03:00:56 <kiki`> any reserved words? :))
03:01:06 <srhb> kiki`: Yeah, sure. if, =, data, ...
03:01:14 <srhb> kiki`: You can find a complete list in the haskell language report.
03:01:25 <piupiu>  hello
03:01:30 <srhb> piupiu: Hello.
03:02:20 <piupiu>  
03:02:54 <kiki`> srhb: ok. a quick recommended reading for beginners (but for cute beginners)?
03:03:17 <srhb> kiki`: The language report? I use it as a reference, I've never done a complete readthrough.
03:03:22 <srhb> kiki`: It is quite readable though.
03:03:23 <kiki`> no. 
03:03:31 <kiki`> not the reference. ..
03:03:36 <kiki`> hence i ask..
03:03:47 <kiki`> for sth that would give me wings fast. 
03:04:02 <kiki`> (to burn my ass, and learn later)
03:04:14 * kiki` is now known as ikarus
03:04:18 <srhb> kiki`: Sorry, I've yet to find such a resource. :)
03:04:31 <srhb> I think haskell is best learned in a principled from-scratch manner.
03:05:07 <kiki`> but not using a reference i hope. that would be like learning a language by reading a dictionary 
03:05:14 <kiki`> yet thx! 
03:05:24 <srhb> kiki`: Oh, agreed. I've heard the haskell from first principles book recommended a lot recently.
03:05:51 <kiki`> ok. thx a lot! merry christmas
03:05:56 <srhb> kiki`: You too. :)
03:13:47 <Cale> kiki`: http://www.cis.upenn.edu/~cis194/spring13/lectures.html is pretty decent -- there's also Graham Hutton's book "Programming in Haskell"
03:18:29 <kiki`> cale: cool. *noted dank u well
03:54:12 <ledongthuc> where do anyone know source code of "!!" operator?
03:55:27 <MarcelineVQ> The link that says # Source to the right of the type sig here   http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:-33--33-
03:56:36 <ledongthuc> thank MarcelineVQ, it's useful for me :)
04:34:19 <erisco> if we are discussing whether something is finite or infinite, what quality are we discussing?
04:42:16 <erisco> is there a library where Set is a -> Bool?
04:43:12 <hpc> technically base ;)
04:43:28 <hpc> but i assume you want the same api as the containers Set, in which case dunno
04:43:54 <erisco> not the same. there are things you can do with a -> Bool that you cannot do with Data.Set, and vice versa
04:44:00 <hpc> i can imagine the complexity of the operations are going to change too
04:44:16 <hpc> er, the big O
04:47:04 <erisco> you can get a -> Bool from Set a but not the other way
04:47:29 <erisco> only if you establish a "universe of discourse" as they call it
04:47:54 <erisco> which lets you enumerate the domain
04:48:21 <erisco> for being weaker you can have sets such as const True
04:48:31 <erisco> and complements
04:51:36 <kuribas> Is evaluation by composing functions efficient?
04:51:46 <kuribas> As opposed to using some sort of AST?
04:52:12 <erisco> how does composing functions evaluate?
04:57:58 <kuribas> by evaluating an expression to a closure...
04:58:26 <erisco> what is different about the AST?
04:59:18 <max33> can anyone help me with this http://pastebin.com/4XakXnA3
05:00:54 <c_wraith> max33: that error message boils down to depending on a different version of GHC than you have installed.
05:01:02 <erisco> heh, and Set is a Functor whereas ->Bool isn't
05:01:03 <kuribas> erisco: for example going from parser directly to a function.
05:01:04 <c_wraith> max33: though it's a bit indirect
05:01:22 <max33> c_wraith, which version?
05:01:46 <c_wraith> max33: that's the tough part, as it's indirect.  The error is because some template haskell isn't supported.
05:02:01 <max33> so i should upgrade?
05:02:09 <c_wraith> Let me track it down
05:02:59 <c_wraith> max33: what version of template haskell do you currently have installed?
05:03:20 <erisco> kuribas, it is both more efficient and more difficult to work with, is my guess
05:03:21 <c_wraith> max33: nevermind, it's 2.10
05:03:28 <c_wraith> max33: (I found it in the output)
05:03:34 <max33> how do i figure that out? i guess it's ghc 8? https://github.com/bos/aeson/issues/336
05:03:43 <max33> (that needs to be installed)
05:04:12 <c_wraith> max33: well, there are two options.  You can find an older version of partial-isomorphism that works with ghc 7.10
05:04:18 <c_wraith> max33: or you can install ghc 8
05:04:31 <erisco> you may not even measure the difference
05:04:40 <kuribas> erisco: what's easy and efficient?  Maybe a byte code compiler?
05:04:58 <c_wraith> max33: and yeah, I confirmed that the constructors it's missing are in template-haskell 2.11 but not 2.10, and 2.10 goes with ghc 7.10, where 2.11 goes with ghc 8
05:05:13 <max33> c_wraith, well the package i want to install requires 7.10
05:05:19 <max33> i guess i should try earlier partial
05:05:38 <erisco> building an AST has cost. The compiler probably doesn't elide it.
05:05:53 <c_wraith> max33: yeah.  It doesn't appear it set its dependency on the template-haskell package properly, which doesn't help. :(
05:06:37 <erisco> but I don't think it would be a substantially measurable difference except for some niche scenarios
05:07:26 <erisco> if you're doing something sophisticated then you want an AST to make algorithms that analyse expressions easier
05:08:40 <erisco> if you're, say, parsing binary numbers and want to evaluate the number immediately rather than building a list of 0's and 1's, that's niche and probably a win
05:09:03 <max33> c_wraith, 0.2
05:09:06 <max33> worked
05:09:09 <max33> thank you for the help
05:09:18 <c_wraith> max33: you're welcome
05:10:06 <erisco> but if you later want to dissect the 0's and 1's it may not have helped you
05:10:54 <erisco> ASTs present information and you later decide what to do with it
05:11:05 <erisco> this is generally the strength of data, and I prefer that
05:11:19 <max33> so if cabal isn't a package manager does haskell have a package manager?
05:12:33 <erisco> if you are reducing too much (beta reduction) then you're throwing away information that could be valuable
05:12:56 <erisco> so you end up in spots where you realise you need a piece of information but it is lost somewhere else in your program
05:13:21 <c_wraith> max33: stack tries harder, but still can't handle a bunch of situations involving native libs.  I don't think there's anything that sets up native libs properly for you
05:13:23 <erisco> that is the cost of reduction, but what you buy is abstraction
05:13:34 <sphinxo> https://github.com/lambdageek/unbound-generics/blob/master/examples/F.hs#L89 what is gamma and delta here?
05:13:53 <erisco> by reducing you hide information and thus do not need to convey it, which can be tricky and burdensome to do
05:14:58 <c_wraith> sphinxo: they are  type aliases defined in the previous couple lines
05:15:10 <sphinxo> Yes but what do they represent?
05:15:26 <erisco> in other words, Subway is a mix of these qualities
05:18:00 <c_wraith> sphinxo: given what checkTyVar does, Delta must be a list of type names currently in scope
05:19:23 <sphinxo> ok thanks, that makes sense
05:19:40 <c_wraith> sphinxo: but I don't know the package, and I can't guess at what Gamma is that quickly
05:19:46 <erisco> is contravariant the package to get contravariant functors from or is there something newer?
05:20:46 <c_wraith> sphinxo: oh, hey, I scrolled up in the file.  Gamma is a list of named terms in scope along with their type
05:22:15 <c_wraith> erisco: afaik, contravariant is still the go-to package
05:22:15 <sphinxo> so term isn't really a term in the sense that terms can be types and values?
05:22:36 <erisco> okay. I ask because these small packages tend to get sucked into bigger ones
05:22:59 <erisco> the "contra all the things" package
05:23:33 <c_wraith> sphinxo: I still don't really know the package, I'm just extrapolating from the comment on line 22
05:23:39 <sphinxo> oh ok
05:24:47 <kuribas> erisco: well, it's a language inside an interactive app (for expressing constraints and expressions inside a CAD app.
05:25:12 <c_wraith> sphinxo: but the Tm data structure on line 32 looks like both type application and type lambdas are terms
05:25:29 <c_wraith> sphinxo: so you're right that terms can include some type-level stuff
05:25:54 <kuribas> erisco: but I guess evaluating it will not be a bottleneck.
05:25:58 <erisco> *shrug* well you are probably looking for a mix of reductions and constructions
05:26:15 <erisco> reduce where there is extraneous information, construct otherwise
05:26:27 <kuribas> ok
05:26:33 <sphinxo> thanks c_wraith 
05:28:00 <erisco> somewhere in contravariant is -> with flipped arguments but I am blind to it
05:28:45 <c_wraith> erisco: Op
05:28:55 <c_wraith> erisco: (I cheated by searching for newtypes)
05:29:11 <erisco> ah ha, thanks... no idea what it is standing for
05:29:22 <c_wraith> opposite, I think
05:29:45 <erisco> Backwards and Reverse were taken
05:30:12 <erisco> soon TOW (The Other Way)
05:39:39 <seishun> how does one usually represent 2d arrays? A list of lists, or just a list + width?
05:40:05 <erisco> there are many ways, not a usual one
05:41:29 <erisco> a list of pairs of positions and values is an option
05:41:40 <erisco> lists, vectors, arrays, boxed, unboxed, mutable, immutable
05:41:57 <erisco> maybe a map of positions to values
05:42:07 <erisco> or a function
05:43:42 <c_wraith> Don't forget repa!
05:44:31 <erisco> is I10n a bit mean for Intersection? such a long word
05:45:08 <c_wraith> I'm much more used to seeing l10n, which is for localization
05:45:24 <erisco> that is I18n no? Internationalisation
05:45:49 <c_wraith> No, i18n is modifying your program so that it supports multiple languages. l10n is creating a translation for a specific language.
05:45:52 <erisco> or, l's and I's
05:46:05 <erisco> oh*
05:46:33 <erisco> how about Ixn
05:47:48 <c_wraith> that one, I haven't seen
05:50:57 <erisco> this could be a fun package, a -> Bool fits so many things
05:51:07 <erisco> is probably out there already but I can't find it
05:51:40 <c_wraith> erisco: there's a newtype for it in contravariant, if you hadn't seen it.
05:52:04 <erisco> Predicate? ah ha
05:52:23 <erisco> that gets you the instances for contravariant and friends
05:52:33 <erisco> then I also want to take this as a set
05:52:58 <erisco> two Monoids, a Category, and I'll find more
05:53:20 <erisco> er, not a Category, but if I build Relation similarly then it is a Category
05:53:56 <kiki`> seishun and folks.. intuitively ..  \(w,h) -> \(x,y) -> a 
05:54:00 <kiki`> ?
05:54:13 <kiki`> would that make sense to you?
05:55:47 <erisco> if Kmett made Predicate then maybe he has such a Set library around already
05:56:03 <erisco> a rather peculiar addition otherwise
06:10:54 <erisco> how does "absurd" get in here with no import and no declaration? http://hackage.haskell.org/package/contravariant-1.4/docs/src/Data.Functor.Contravariant.Divisible.html#line-361
06:11:02 <erisco> it is absurd!
06:11:15 <c_wraith> erisco: no import?
06:11:24 <c_wraith> erisco: that package has like 20 imports.
06:11:28 <c_wraith> err, module
06:11:38 <c_wraith> erisco: it's from Data.Void
06:11:41 <erisco> oh, right, they are wildcarded...
06:11:58 <erisco> I don't do such things
06:13:41 <erisco> "lose" is mysterious to me then
06:14:10 <c_wraith> Decidable as a class is mysterious.
06:14:28 <hodapp> ehhhh?
06:14:30 <erisco> I understand choose
06:14:40 <c_wraith> It was created as the opposite of divide & conquer
06:16:31 <erisco> not sure how "crash the program" is sensibly part of a class
06:16:44 <c_wraith> absurd doesn't crash the program
06:16:51 <c_wraith> because there are no values of type Void
06:17:00 <c_wraith> that's kind of the point of absurd.
06:17:10 <c_wraith> It makes things you know to be impossible type check
06:17:38 <erisco> that isn't what I mean
06:18:10 <erisco> the only way to get a -> Void is through something bad
06:19:07 <c_wraith> Sort of.
06:19:27 <erisco> choose Left (lose f) m = kaboom
06:20:28 <erisco> too far into esoteria for me... maybe one day I'll figure out the use
06:21:19 <c_wraith> there is a reason the lose is documented as "The only way to win is not to play"
06:24:06 <kuribas> :t undefined :: a -> Void
06:24:08 <lambdabot> a -> Void
06:27:33 <kuribas> hm, typed holes are better than undefined when creating new code...
06:42:12 <ertes> for the past few days i've been looking at scheme implementations as a replacement for haskell for scripting tasks, which is really just an unfortunate effect of runghc being so slow to boot
06:42:23 <ertes> is there a way to make runghc boot faster?
06:42:53 * ledongthuc
06:43:32 <ertes> (perhaps i should just stop treating "scripting" differently)
06:46:23 <Tuplanolla> I've used CHICKEN for that, but how about you compile your scripts, ertes?
06:49:40 <kiki`> do you have some bot haskell iterpreter here?
06:49:58 <kiki`> ah lambdabot 
06:52:39 <ertes> Tuplanolla: yeah, that's what i'm thinking…  i tried chicken as well
06:53:23 <ertes> i knew it!  i would come back to haskell, wouldn't i
06:53:29 <ij> > reverse "`ikik puy"
06:53:32 <lambdabot>  "yup kiki`"
06:54:31 <Tuplanolla> I tried to go back to Scheme recently too, ertes, but I can no longer use it, because it lacks libraries that feel complete.
06:57:42 <ertes> well, i don't mind haskell most of the time, but it's just so…  "large"…  everything about it feels like it's massive
06:57:58 <ertes> even just GHC with its 1.1 GiB closure
06:58:42 <ertes> i'm actually going to link haskell libraries statically because of that, but then executables are large
06:59:20 <kuribas> ertes: maybe gauche?
06:59:31 <Tuplanolla> Sometimes I wish it was even larger. I hate it when trivial things I want don't already exist.
06:59:33 <ertes> kuribas: gauche?
06:59:42 <kuribas> ertes: http://practical-scheme.net/gauche/
07:00:39 <kuribas> ertes: disclaimer, since programming haskell I have hardly touched scheme.
07:01:22 <ij> Is it possible to _pointless_ „type L a = A -> [A] -> a“?
07:01:30 <ertes> kuribas: the implementations i've tried are fine, but actually i really just want to program haskell
07:02:03 <ertes> Tuplanolla: that's not what's making stuff big i think…  it's just that stuff was never optimised for size
07:02:14 <kuribas> ertes: yeah, I really miss static types when I try scheme again.
07:02:31 <chrissound> Merry December everyone! Using spacemacs / emacs, is there a way I can navigate to a function within a package?
07:03:03 <ertes> chrissound: if you have set things up properly M-. should do it
07:03:04 <kiki`> ::learn rot13 s => s.replace(/[a-zA-Z]/g, function(c) { return String.fromCharCode((c <= "Z" ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26); })
07:03:05 <esmeralda> kiki`: learned new command: rot13
07:04:12 <kuribas> ertes: the only thing I like more about scheme is that macros are much cleaner.
07:04:18 <kiki`> ::rot13 xvxv`: gunaxf vw
07:04:19 <esmeralda> kiki`: kiki`: thanks ij
07:05:13 <ertes> @let letter :: Traversal' Char Int; letter l c | isAsciiUpper c = (\x -> chr (mod x 26 + ord 'A')) <$> l (ord c - ord 'A') | isAsciiLower c = (\x -> chr (mod x 26 + ord 'a')) <$> l (ord c - ord 'a') | otherwise = pure c
07:05:15 <lambdabot>  Defined.
07:05:27 <ertes> > (letter +~ 13) "hi there!"
07:05:31 <lambdabot>  error:
07:05:31 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
07:05:31 <lambdabot>      • In the first argument of ‘letter +~ 13’, namely ‘"hi there!"’
07:05:37 <ertes> > (traverse . letter +~ 13) "hi there!"
07:05:41 <lambdabot>  "uv gurer!"
07:05:42 <ij> kiki`, No probs :) I'm not so certain the locals will appreciate more bots much, though.
07:05:45 <sm> ertes: interesting, I didn't think runghc startup was that slow
07:05:55 <kiki`> ij: yw
07:06:18 <kiki`> could somebody port this to haskell? just so i get a clue. it's ecma: var board2D = (cols,rows) => { var matrix=Array.from({length:cols*rows}, (e,i)=>({x:i%cols,y:Math.floor(i/rows)})); matrix.w=cols; matrix.h=rows; function field(x, y) { if ((x<0||x>=this.w) || (y<0||y>=this.h)) return undefined; return this[y*this.w+x] }; return field.bind(matrix); }
07:06:19 <sm> what about hugs ?
07:06:47 <chrissound> ertes: What is M-? There is 'go to definition' functionality but that only seems to work for definitions within the project itself. What should I be looking to 'setup'?
07:07:05 <Tuplanolla> Oh, you meant different kind of big, ertes.
07:07:16 <ertes> sm: it's so slow that i'm compiling my Setup.lhs =)
07:07:41 <kiki`> "seishun and folks.. intuitively ..  \(w,h) -> \(x,y) -> a  " <- thats how it works (probably :)
07:07:46 <ertes> chrissound: which haskell mode are you using?  haskell-mode?
07:07:54 <ertes> or intero?
07:08:16 <kiki`> should return a function taking x,y which returns some object in a 1dimensional list
07:08:35 <sm> ertes: I find that stack shebang lines slow down scripts a lot
07:10:06 <sm> but this makes compilation pretty easy: #!/usr/bin/env stack exec [--verbosity info] [--package ...] -- ghc
07:10:31 <ertes> kiki`: (nobody is going to decipher an ECMA one-liner on IRC…  perhaps you should prettify it and paste it somewhere)
07:11:38 <Tuplanolla> It might be more useful to describe what you want the thing to do and start over, kiki`.
07:12:01 <Tuplanolla> If you port imperative code directly, you just get a huge `ST` mess.
07:12:18 <sm> ertes: also if you feel like it: why didn't you choose racket, and do the "haskell lites" like purescript/elm work for scripting yet ?
07:12:55 <chrissound> ertes: Not too sure what haskell mode. I've just enabled a 'haskell' layer in spacemacs which seems to be a plugin / config of some sort. I might read through the config / long readme.
07:13:54 <ertes> sm: i tried racket, but its interpreter took just as long as runghc to boot, and the compiler needed half a minute to compile hello world with an executable that was just about to collapse into a black hole
07:14:01 <kiki`> ertes: sure! but you can just do it witout the scratch: its a function taking width, and height, returning another function that is bound to a 1 dimensional array taking (x,y) addressing and returning 1 field of the bound array.. 
07:14:04 <ertes> sm: in other words: it was worse than haskell in every way =)
07:14:21 <sm> aha good to know
07:14:37 <ij> Gurkenglas, Newtype + runBot works nicely, thanks. Your implementation of my atomState was also much nicer, with the <$ that I didn't know about. :)
07:15:26 <ertes> kiki`: where does the array itself come from?
07:15:43 <kiki`> https://www.irccloud.com/pastebin/sRJHDJ5g/
07:16:16 <kiki`> the js code beautified
07:17:08 <ertes> kiki`: that looks like…
07:17:48 <kiki`> titties?
07:17:56 <ertes> > (\w x y -> y*w + x) 20 4 7
07:17:58 <lambdabot>  144
07:18:31 <ertes> given a width, this function computes the linear address of the given 2D coordinates
07:19:04 <kiki`> should it be sth like \(w,h) -> \(x,y) -> a 
07:19:06 <ertes> and it's a function that returns a function (functions written this way are curried by default in haskell)
07:19:15 <ertes> the h is redundant
07:19:37 <Tuplanolla> The n-dimensional case is quite useful and fun to write.
07:20:12 <kiki`> can u make it like sth i can use in lambdabot? somebody? thx so far ertes, of course also ertes
07:20:32 <ertes> @let mkLinear w x y = y*w + x
07:20:34 <lambdabot>  Defined.
07:20:51 <ertes> > let f = mkLinear 20 in (f 5 7, f 0 0, f 19 19)
07:20:54 <lambdabot>  (145,0,399)
07:21:59 <kiki`> ertes: so you get a better clue: var chess=board2D(8,8); chess(2,4).items=['queen']; chess(2,4) //outputs: { items: [ 'queen' ], x: 2, y: 4 } 
07:22:09 <kiki`> check?
07:22:41 <kiki`> you dont need to recreate the output.. just the function
07:22:46 <kiki`> if possible
07:23:16 <kiki`> (the output is just some inspect on the object in that field .. coudd also be 42
07:23:25 <kiki`> hmm
07:23:26 <ertes> so you want an array for a board game?
07:23:36 <kiki`> yes kinda
07:23:44 <kiki`> thats just a use case
07:24:32 <kiki`> i know u guys prefer to obscure things, but im trying to find out if hs is useful for anything
07:24:34 <erisco>  though the sad thing about a -> Bool is it has list-like performance
07:24:43 <kiki`> without golf shoes
07:24:52 <ertes> kiki`: i see…  you want to create a linear array, but address it in 2D
07:25:02 <kiki`> yes!
07:25:12 <kiki`> that was like something somebody asked before
07:25:18 <ertes> well, one way would be to use the 'array' package, which supports 2D indexing out of the box
07:25:52 <kiki`> so u cant have a function that creates an array without giving it any?
07:25:56 <ertes> but consider that a game board is usually mostly sparse, so you could use a data structure instead like a Map or a HashMap
07:26:04 <ertes> yes, you can
07:26:16 <kiki`> i mean it must not have binding
07:26:19 <ertes> instead of giving you the array i might give you a pair of functions to manipulate it
07:26:35 <erisco> I wonder if a -> Ordering fixes the problem
07:27:05 <kiki`> ertes: yw.. thats all no problem.. im just interested in how that would look in haskell
07:27:11 <kiki`> to get a taste
07:27:15 <kiki`> any of that solutions
07:27:41 <ertes> kiki`: the thing is:  there are actually quite a few ways to represent this in haskell, and it depends on the particular use case which one you should choose
07:28:00 <kiki`> ertes: ok. thanx bru.
07:28:03 <ij> I was googling a bunch of things today and I noticed that lots of ghc users_guide docs are 404ing. Has it been noticed already?
07:28:03 <Tuplanolla> You could represent it as an adjacency graph too, kiki`.
07:28:21 <Tuplanolla> I once wrote a prototype for playing Tic-Tac-Toe on lattice defects.
07:28:23 <kiki`> yw. but thats all haskell unrelated ;) 
07:28:39 <Tuplanolla> I'll finish it one day.
07:28:43 <kiki`> you are right, and i understand you'd like to discuss the real thing.
07:28:58 <kiki`> while im interested in some notation syntax thingies...:)
07:29:02 <erisco> maybe just memo'ing a -> Bool with Set is 'aight
07:29:03 <kiki`> thats how it goes.
07:29:06 <ertes> kiki`: for a chess board i would most likely go with a Map
07:29:07 <MarcelineVQ> ij: could you link one?
07:29:10 <kiki`> but all will be good :)
07:29:14 <ij> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators
07:29:29 <kiki`> ic..coolcool.
07:29:35 <kiki`> merry xmas @ all
07:29:38 <kiki`> brb
07:29:42 <ertes> kiki`: although depending on what i'm implementing chess for i might not even give you anything resembling a board *at all*…  i might give you a value of a type that represents your possible moves
07:29:49 <ertes> kiki`: if that makes sense
07:29:52 <erisco> yeah that seems reasonable
07:31:08 <MarcelineVQ> ij: ah, quite odd, that file used to exist but doesn't in the latest maual version. for example if you change latest to 7.10.2 it'll work fine, https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/data-type-extensions.html#type-operators
07:31:29 <MarcelineVQ> this is the new link, not sure what to do about google though :X https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-operators
07:31:40 <erisco> or, just converting to Set is even more reasonable
07:32:31 <erisco> guess it depends... easier to implement though
07:33:00 <ij> I found it in a 2014-12-08 blog article.
07:33:53 <erisco> such a conversion is quadratic, bleh
07:34:31 <MarcelineVQ> oh, you didn't find it on google?
07:35:05 <erisco> why can't the simple things also be efficient
07:37:05 <ertes> erisco: at the limit that would make programmers useless =)
07:37:15 <erisco> the only path to general efficiency would be to have some predicate eDSL thingie
07:38:33 <ertes> erisco: a simple representation might suffice:  data Predicate a = All | None | Predicate (a -> Bool)
07:38:38 <erisco> which minimally can exploit boolean logic but to be more useful would probably have to get involved with other properties
07:38:52 <erisco> so then you need special stuff for integers and sets and lists and so on, no way
07:39:07 <ertes> erisco: as the efficiency concern is mostly about dynamically optimising trivial cases
07:39:31 <erisco> singleton x = Set (==x)
07:39:43 <ij> MarcelineVQ, Indeed, should've been more precise. In an article this time, but this is the 3rd 404 today already. Looks like googling 'em up straight leads me to the right articles.
07:39:43 <erisco> now union these together to build your x1,...,xn set
07:39:50 <erisco> it is a linear check to see if any element is in this set
07:40:02 <erisco> so if you check for x1 to xn, now you're quadratic
07:41:04 <ertes> if you want efficient set operations you need assumptions on the subject type
07:41:13 <MarcelineVQ> that's alright then, there's not much that can be done about blogs that are out of date other than contacting the authors. it's a good argument for writers to be specific about the documentation version they link to though
07:42:23 <erisco> Ord isn't a big deal, but I don't know what you'd do with Ord
07:42:42 <ertes> erisco: well, you'd approach an EDSL
07:42:56 <ertes> … | Match (Set a) | …
07:43:37 <ertes> but as long as you have that (a -> Bool) in there the worst case is going to stay the same…  you'd just see it less often
07:44:24 <erisco> Set a is convertible to a -> Bool but perhaps better to keep it Set a
07:45:04 <erisco> a mix of predicates and sets
07:46:29 <erisco> but seems a bit pointless
07:46:44 <erisco> if you play your cards right for efficiency then it will be the same as using Set
07:48:31 <erisco> intersect set and predicate is filter, union set and predicate is a predicate
07:49:05 <erisco> probably need union and intersect in the edsl as well so that you can collect the sets
07:49:14 <erisco> if union of set and predicate is a predicate then you lose the set
07:49:54 <erisco> both Functor and Contravariant go away
07:50:17 <ij> I wrote a laughable function today: uncurry (*>) . (uncurry fileLog &&& uncurry stateLog)
07:50:59 <Tuplanolla> I feel that the `uncurry`s could be combined.
07:51:36 <erisco> ertes, why did you call it a Match?
07:51:40 <Nik05> anyone know why (<<) is not defined in the prelude? Monad is inconsistant with Functors and Applicatives
07:52:13 <ij> Tuplanolla, You're free to tell me how!
07:52:50 <MarcelineVQ> Nik05: Monads are Functors and Applicatives, so what would the Applicative version of << be?
07:53:19 <Nik05> MarcelineVQ flip (>>)
07:54:16 <Nik05> oh wait its <*
07:54:21 <MarcelineVQ> bingo
07:54:26 <c_wraith> Uh, no it's not
07:54:32 <Tuplanolla> How about `((&&&) `on` uncurry) fileLog stateLog`, ij?
07:54:34 <c_wraith> :t (<*)
07:54:35 <lambdabot> Applicative f => f a -> f b -> f a
07:54:48 <MarcelineVQ> oh, no?
07:55:01 <Nik05> why don't they put =<< in the Monad definition instead of >>= ?
07:55:04 <c_wraith> (<*) and (<<) do effects in the opposite order
07:55:09 <Nik05> and remove all these aliases?
07:56:59 <MarcelineVQ> I see, I've mislead you Nik05
07:57:04 <Nik05> oh
07:57:10 <Tuplanolla> As a whole you'd have this, ij: ``uncurry (*>) . ((&&&) `on` uncurry) fileLog stateLog``
07:58:05 <Tuplanolla> Then you can remove the log points as well, resulting in something like this: ``uncurry (*>) .:: ((&&&) `on` uncurry)``
07:58:45 <Tuplanolla> Now it's impossible to read.
07:59:05 <chrissound> Not having much luck getting emacs setup with navigation functionality. Are there any usefull utilities out there to easily navigate source code? I wouldn't mind having a seperate editor just for this. Does anyone know if Vim / Atom / Sublime has such functionality?
07:59:30 <Nik05> MarcelineVQ I dont get <*, *> anymore, they both do the same thing in a short testcase
08:00:14 <ij> Nik05, One returns the output of left and right action, respectively.
08:00:35 <Nik05> right, and it still "executes" from left to right
08:00:39 <ij> Yeah.
08:01:40 <Nik05> function application is from right to left, and these things from left to right. I dont get it
08:03:32 <Nik05> or is it also from left to right...
08:03:37 <Nik05> composition is from right to left
08:03:51 <Tuplanolla> Composition is the odd one out.
08:04:02 <Tuplanolla> Blame mathematicians.
08:04:54 <Nik05> or the other way around
08:07:49 <Nik05> So I should stick to >>= i guess and only normal composition is the other way around
08:08:03 <Nik05> instead of composition is correct and all the others are wrong
08:08:51 <Tuplanolla> :t (>>>) -- We have this too.
08:08:53 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
08:09:23 <Tuplanolla> It looks bad, but it's actually reverse composition.
08:09:47 <Tuplanolla> :t (<<<) -- This is the other one.
08:09:49 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
08:10:43 <Nik05> and arrows are categories?
08:11:47 <Nik05> still all feels really weird. <$>, <*> are inconsistent with >>=
08:12:18 <ertes> erisco: good question
08:13:57 <Tuplanolla> It's a historical problem, Nik05.
08:14:16 <ertes> chrissound: i'm using regular emacs, not spacemacs, and lookup works exactly as it should
08:14:21 <Tuplanolla> They used to be completely unrelated.
08:14:24 <ertes> chrissound: i'm using haskell-mode
08:15:27 <ertes> chrissound: it comes with haskell-interactive-mode, which requires minor setup, but then handles pretty much everything for you
08:16:50 <Nik05> Tuplanolla I know they changed it in 7.10, i think. But I still don't get how this could be "fixed"
08:17:36 <Tuplanolla> I guess `=<<` could be pushed into the `Monad` class with a default implementation in terms of `>>=`, but I don't see this happening anytime soon.
08:18:14 <Nik05> But even then <*> (and <*, *>) also execute from left to right
08:18:20 <ertes> chrissound: actually unless you have special needs all it needs is the following: (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
08:18:22 <Tuplanolla> There's also the weaker monads-from-join formulation, but it's more awkward for programming.
08:18:40 <ertes> chrissound: potentially also: (add-hook 'haskell-mode-hook 'turn-on-haskell-doc)
08:18:44 <Nik05> monad is just applicative with join right?
08:18:57 <hpc> yes
08:18:57 <Tuplanolla> Yes.
08:19:35 <ertes> why would you have (=<<) in Monad?
08:20:14 <Tuplanolla> The argument order is consistent with `<$>` and `<*>`, ertes.
08:20:32 <ertes> Tuplanolla: you mean: take out (>>=) and bring in (=<<)?
08:20:49 <Tuplanolla> That's what Nik05 suggested.
08:20:53 <Nik05> ertes well thats what i am saying ;)
08:20:56 <ertes> ah
08:21:09 <chrissound> ertes: Many thanks! Think I've found the issue which is an error being thrown - https://github.com/haskell/haskell-mode/issues/1455 
08:21:56 <Nik05> oh this would also completely destroy do notation...
08:22:04 <ertes> ah
08:22:07 <Nik05> or not?
08:22:10 * ertes has no experience with stack
08:22:35 <ertes> Nik05: nope, do-notation might as well just continue to use (>>=) or be reexpressed in terms of (=<<)
08:22:43 <ertes> c >>= f = f =<< c
08:23:50 <Nik05> I think I see the picture clearer now. Except for the order of execution of the IO monad
08:24:29 <ertes> Nik05: but while we can fix some of the historical mistakes by relying on the haskell community's sense for clean abstractions, we can't really fix more subjective *style* issues like (>>=) vs. (=<<), because all Monad instances are defined in terms of (>>=)
08:24:37 <Nik05> putStr "b" <* putStr "a", should print "ab"...
08:24:56 <ertes> Nik05: nope, it prints "ba" and returns the result of the first putStr
08:25:15 <Nik05> yes that what it does, but i think it should print "ab"
08:25:33 <ertes> Nik05: (<<) ≠ (<*)
08:25:42 <ertes> if you want it to print "ab", use (<<)
08:26:20 <Nik05> Yes i get that, but why would <* have to print b first?
08:26:33 <ertes> because it's defined that way
08:26:40 <ertes> (<*) = liftA2 const
08:26:46 <Tuplanolla> It's not `flip (*>)` as the name suggests, Nik05.
08:26:49 <int-e> Nik05: a <* b just means you don't care about the result of b
08:27:11 <Nik05> yes i know, but i want to make things consistent :P
08:27:12 <int-e> Nik05: a context where this is useful would be parsers
08:27:46 <Nik05> but i guess f <$> a <*> b, should execute from left to right, and not right to left...
08:29:07 <int-e> personally I think =<< and << probably shouldn't exist. But they're not going away. And I've even used =<< on occasion.
08:29:30 <ertes> i don't mind their existence
08:29:48 <Nik05> Personally I would think >>= should exists
08:29:57 <Nik05> shouldn't
08:30:22 <int-e> but =<< with lambdas is just too awkward.
08:30:39 <Nik05> What do you mean?
08:30:48 <Nik05> oh i think i get it
08:30:51 <int-e> foo >>= \x -> ... x ...  puts the bound variable next to the "bind"
08:31:10 <Nik05> (\x -> bla) =<< foo
08:31:14 <ertes> Nik05: (\x -> (\y -> (\z -> …) =<< c3) =<< c2) =<< c1
08:31:34 <ertes> that's horrible
08:31:41 <Nik05> oh wow
08:31:58 <ertes> the variables disconnect from their corresponding actions more the deeper this gets
08:32:18 <ertes> the x variable (far left) is bound as the result of c1 (far right)
08:32:47 <ertes> also haskell's syntax allows lambdas to the right of an operator without using parentheses
08:32:47 <Nik05> I guess to fix it would should write function application the other way around :P
08:33:04 <Nik05> sorry my english
08:33:07 <ertes> no, you would also need lambdas to go in the other direction
08:33:15 <Zemyla> Huh, not every instance of Costrong is a lazy loop.
08:33:16 <ertes> application is not the problem here
08:34:07 <ertes> Nik05: basically you would have to create cohaskell (haskell with all directions flipped) to make this reasonable ;)
08:34:10 <Zemyla> Take a variation in the Bazaar type used in Lens.
08:34:20 <Nik05> ertes i guess you have :P
08:34:29 <Zemyla> @let newtype Baz t b a = Baz { runBaz :: forall f. (Applicative f) => (a -> f b) -> f t } deriving (Functor)
08:34:32 <lambdabot>  Defined.
08:34:39 <Zemyla> @let instance Profunctor (Baz t) where { lmap f (Baz m) = Baz $ \c -> m (fmap f . c); rmap = fmap }
08:34:41 <lambdabot>  Defined.
08:35:20 <Zemyla> Then this is the Costrong instance:
08:35:22 <Zemyla> @let instance Costrong (Baz t) where { unfirst (Baz m) = Baz $ \c -> m $ \(a, d) -> (\b -> (b, d)) <$> c a; unsecond (Baz m) = Baz $ \c -> m $ \(d, a) -> (,) d <$> c a }
08:35:25 <lambdabot>  Defined.
08:36:35 <ph88> merry xmas :)
08:37:11 <seishun> does standard haskell have anything like monadic iterate? basically I want something like `map runState $ [f, f >> f, f >> f >> f, ...]` but without repeated computations
08:37:34 <c_wraith> seishun: that sounds more like a monadic scan
08:38:02 <c_wraith> seishun: in general, it's not possible, though
08:38:24 <ertes> seishun: without repeated effects you mean?
08:38:34 <c_wraith> seishun: you have two options - m [a] or [m a]
08:38:42 <c_wraith> seishun: the former doesn't really work with infinite lists
08:38:47 <Nik05> I guess it has to execute from left to right, otherwise parsers would also be a hell to write
08:38:48 <c_wraith> seishun: the latter means repeated effects
08:39:07 <int-e> :t iterate . execState
08:39:09 <lambdabot> State a a1 -> a -> [a]
08:39:17 <Zemyla> It also has a Cochoice instance. O
08:39:23 <ph88> hey guys, when i run my program after a while it gets killed i forgot how i can find out the cause of it
08:39:27 <int-e> (very state monad specific and it discards the result of f)
08:39:35 <Zemyla> @let instance Cochoice (Baz t) where { unleft (Baz m) = Baz $ \c -> m $ either (fmap Left . c) (pure . Right); unright (Baz m) = Baz $ \c -> m $ either (pure . Left) (fmap Right . c) }
08:39:37 <lambdabot>  Defined.
08:39:41 <c_wraith> seishun: The general solution to this is is to use a streaming library instead of []
08:40:35 <c_wraith> seishun: the popular choices in streaming libraries these days are pipes, conduit, and streaming (in no particular order)
08:40:35 <ertes> seishun: depending on what you want to do you can use the free monad of the monad, which essentially introduces breakpoints into your monad
08:40:35 <Nik05> Well thanks everyone. Im still confused about this :P
08:40:35 <int-e> seishun: you may also get something like that out of the lazy state monad.
08:40:35 <ertes> seishun: (Free (State s)) is like (State s) with breakpoints
08:40:35 <ph88> could it be that i need to increase the amount of memory that can be allocated ?
08:41:16 <ertes> seishun: this is actually a super-special case of stream processing =)
08:41:32 <sm> ph88: if you're being killed by the out-of-memory killer, then maybe yes. Watch your process memory usage with top to find out
08:41:58 <ph88> is it stack memory ?
08:42:53 <c_wraith> ph88: stack is part of the process memory - usually much smaller than the heap
08:43:03 <ertes> ph88: give your program the following argument:  +RTS -M128m
08:43:28 <ertes> ph88: if your program is dying because of heap overflow (more than 128 MiB), then you will get a useful error message
08:44:14 <seishun> the result is a Maybe, I basically want to do `take 100 . catMaybes $ iterateThing`
08:44:16 <ph88> htop says the program uses like 86% of my memory
08:45:21 <ph88> ertes, yeah it says heap exhausted .. what to do now ?
08:45:25 <seishun> if it's too complicated to do with monads I'll just put the state and the Maybe result in a tuple
08:46:19 <ertes> ph88: well, find the memory leak =)
08:46:37 <ertes> ph88: if there is one…  maybe your program is supposed to eat that much memory
08:46:48 <ph88> it's running quickcheck
08:47:02 <ph88> maybe the generated data is getting too big ?
08:47:37 <ertes> ph88: yeah, that's possible, if you let it generate complicated stuff…  but i think you can tweak it
08:48:04 <seishun> I just don't like how the function would need a dummy parameter (well, dummy tuple element) with this approach
08:48:33 <ertes> if you let it generate a list of lists of maps of trees of unbounded integers …
08:48:58 <ertes> seishun: i think your problem description is too abstract
08:50:26 <Nik05> ertes int-e Tuplanolla ij thanks for helping me with my brainfartansy, and happy midwinter
08:50:35 <ph88> ertes, do you know how to tweak it ?
08:51:57 <ertes> ph88: not really, but check out the command line --help of your test suite
08:52:24 <ertes> ph88: at least in the QuickCheck API there is the Args type, which has a maxSize field
08:52:26 <seishun> the function would look something like `f (state, _) = if blah then (newState, Nothing) else (newState, Just output)` and I would then use it like `take 100 . catMaybes . map fst . iterate f (initState, Nothing)`
08:52:31 <ertes> but that field is just an Int, so i have no idea what it means
08:53:29 <seishun> *map snd
08:53:54 <ertes> seishun: first of all check out unfoldr
08:54:16 <ph88> i found the maxSize setting of quickcheck, anyone know what it's suppose to represent? megabytes ??
08:54:34 <ertes> @let isPrime x = all (\d -> mod x d /= 0) [2 .. x - 1]
08:54:37 <lambdabot>  Defined.
08:55:05 <seishun> oh, that looks interesting ertes 
08:55:59 <ertes> > unfoldr (\s -> Just (if isPrime x then Just x else Nothing, x + 1)) 5
08:56:03 <lambdabot>  [*Exception: not an integer: x - 1
08:56:07 <ertes> > unfoldr (\x -> Just (if isPrime x then Just x else Nothing, x + 1)) 5
08:56:10 <lambdabot>  [Just 5,Nothing,Just 7,Nothing,Nothing,Nothing,Just 11,Nothing,Just 13,Nothi...
08:56:30 <Nicmavr> how do you run a .hs file in ubuntu? I think I've installed Haskell and GHC but I've only managed to compile the hs files
08:56:53 <ertes> seishun: in fact if you use [] instead of Maybe you can just use concat/join
08:57:05 <ertes> > concat $ unfoldr (\x -> Just (if isPrime x then [x] else [], x + 1)) 5
08:57:09 <lambdabot>  [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,...
08:58:40 <ertes> seishun: but of course even better would be not to generate all those empty cases in the first place
08:58:43 <ertes> :t until
08:58:46 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:59:50 <ertes> > iterate (until isPrime (1 +))
08:59:56 <lambdabot>  <Integer -> [Integer]>
08:59:57 <ertes> > iterate (until isPrime (1 +)) 5
09:00:02 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
09:00:05 <ertes> uhm
09:00:29 <ertes> > unfoldr (\x -> let y = until isPrime (1 +) x in Just (y, y + 1)) 5
09:00:35 <lambdabot>  mueval-core: Time limit exceeded
09:01:53 <ertes> lambdabot: you suck today…  but perhaps all you need is some encouragement
09:01:56 <ertes> @botsnack
09:01:56 <lambdabot> :)
09:02:00 <ertes> > unfoldr (\x -> let y = until isPrime (1 +) x in Just (y, y + 1)) 5
09:02:06 <lambdabot>  mueval-core: Time limit exceeded
09:02:12 <ertes> lambdabot: dude!
09:02:28 <ertes> > take 10 $ unfoldr (\x -> let y = until isPrime (1 +) x in Just (y, y + 1)) 5
09:02:33 <lambdabot>  [5,7,11,13,17,19,23,29,31,37]
09:02:59 <seishun> well in my case the `+` is more complicated
09:03:23 <ertes> seishun: sure, just replace (1 +) by your more complicated function
09:03:39 <seishun> I'd have to do that in the Just part too, wouldn't I?
09:03:57 <ertes> oh, yeah
09:04:48 <ertes> be sure to give your function a name
09:07:00 <ertes> > iterate (until isPrime (1 +) . (1 +)) 4
09:07:04 <lambdabot>  [4,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,10...
09:07:24 <ertes> > tail (iterate (until isPrime (1 +) . (1 +)) 4)
09:07:27 <lambdabot>  [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,...
09:08:18 <ertes> seishun: this works, too, if you don't mind specifying your initial state *outside* of the set of candidates
09:08:31 <seishun> what are the disadvantages of the catMaybes approach?
09:09:20 <ertes> not too many, although this last version will likely be a bit faster
09:10:19 <seishun> also I don't really have an equivalent for isPrime since the function pattern-matches and gives the "result" in just one of many case
09:11:22 <ertes> what's the type of your transition function?
09:12:05 <Nicmavr> anyone here with haskell experience on linux ubuntu?
09:12:32 <ertes> Nicmavr: sorry, i meant to answer:  try runghc
09:14:31 <seishun> well I haven't written it yet but it seems it's going to be `MyState -> Maybe (Maybe Char, MyState)`
09:16:54 <ertes> seishun: do you need to handle the case separately where there may be no final state?
09:18:41 <ph88> if i have   data Foo = F [Bar]   data Bar = B [Int]   and i put maxSize on 2  and i test property of Foo does that mean max 4 testcases, because there are 2 generators so 2 * 2 ?
09:18:55 <seishun> I might not have understood the question, but depending on the initial state it may or may not be infinite
09:20:46 <ertes> seishun: then it sounds like unfoldr does exactly what you need it to do, and you'd just use catMaybes
09:21:13 <seishun> yeah, seems so
09:22:04 <haasn> I remember reading some paper introducing a variant of Haskell in which types like Int { x < 0 } made sense, with a type inferencing algorithm that automatically induced the most general possible conditions
09:22:10 <haasn> Anybody know what I'm talking about?
09:22:17 <monochrom> Liquid Haskell
09:22:20 <haasn> Oh right, thanks
09:22:56 <monochrom> On April 1st I'll announce "Hot Air Haskell". It will solve the halting problem. :)
09:27:59 <Nicmavr> ertes, do I run the .hs file or the .hi/.o files that resulted from compiling with "ghc"?
09:29:49 <ertes> Nicmavr: if you want to interpret the *.hs file, you runghc that one
09:30:32 <ertes> Nicmavr: if you compile your haskell file, it becomes a native executable, and you don't need anything GHC-related to run it (except perhaps libraries, if you linked dynamically)
09:39:12 <seishun> is there a simpler way to compare the first N elements from two infinite lists than `take 100 l1 == take 100 l2`?
09:40:09 <shiona> :t ((==) `on` (take 100))
09:40:11 <lambdabot> Eq a => [a] -> [a] -> Bool
09:40:37 <shiona> that might work, if you see that as simpler
09:40:54 <seishun> :t ((==) `on` take 100)
09:40:57 <lambdabot> Eq a => [a] -> [a] -> Bool
09:41:15 <seishun> yeah that works
09:42:51 <Nicmavr> ertes, I tried using runghc but it gives me this error:
09:42:53 <Nicmavr> Not in scope: ‘main’
09:42:54 <Nicmavr>     Perhaps you meant ‘min’ (imported from Prelude)
09:45:05 <nicksh> Anyone have time for a newbie question on function composition?
09:46:10 <samvher> nicksh: sure, I can try to help you
09:46:49 <ertes> seishun: i'd prefer (take 100 l1 == take 100 l2) =)
09:47:11 <ertes> Nicmavr: have you seen the source code for a haskell hello world program?
09:47:36 -nicksh(~nicksh@c-73-5-170-85.hsd1.mn.comcast.net)- Thanks.  I'm working through Haskell Programming from First Principles on a problem to get the 10s digit off a number...
09:49:07 <osa1> in STM if I do `takeTMVar var >> putTMVar var x` can any other thread fill the mvar after this takeMVar? I'm trying to replace value in a TMVar and I've never used STM before...
09:49:48 <MarcelineVQ> aww geeze, that's rough, why even allow unathorized announces instead of killing when they happen, silly freenode
09:50:15 <samvher> ah I was wondering what that was
09:50:38 <ertes> osa1: no, transactions are atomic and isolated
09:51:09 <ertes> osa1: neither can another thread fill the variable, nor can another thread even observe that it was taken…  they can only observe the effects in an all-or-nothing manner
09:51:26 <osa1> ertes: awesome, that's exactly what I need. thanks
09:52:18 <ertes> i've found a use case for GHCi in a separate process =)
09:53:02 <hpc> how do you accidentally announce?
09:53:44 <samvher> maybe with some gui-based client, wrong button?
09:53:51 <Nicmavr> ertes, I don't think so no
09:54:11 <Nicmavr> ertes, the same code works on WinGHCi on my windows machine so I don't get why it wouldn't on ubuntu
09:54:52 <lpaste> ertes pasted “Hello world” at http://lpaste.net/350451
09:54:56 <hpc> osa1: usually with STM you want to just use TVar as well
09:55:12 <hpc> in case you're coming straight from using MVars and trying to translate things
09:55:31 <ertes> Nicmavr: GHCi is different…  if you compile your code or try to runghc it, it needs to have a 'main' action
09:56:10 <hpc> the i in ghci is "interactive"
09:56:10 <ertes> Nicmavr: GHCi loads arbitrary modules…  it doesn't insist on your code to be a "program" that it can "execute", just a bunch of definitions that you can use from the interpreter
09:56:19 <Nicmavr> ertes, is there a way to run the same code on ubuntu as it does on windows without changing it? Either from the command line or from a linux equivalent of WinGHCi?
09:56:37 <ertes> Nicmavr: ghci
09:57:22 <ertes> Nicmavr: in general if you're looking for the linux/unix equivalent of "WinX", the answer is often just "X" =)
09:58:26 <ertes> Nicmavr: except more likely "x" than "X" (unix is case-sensitive for most things)
09:58:54 <Nicmavr> ertes, right got it :P
09:59:10 <Nicmavr> I was confusing GHC with GHCi.. embarrassing 
09:59:19 <Nicmavr> just tried it on terminal now and it works so thanks :)
10:00:42 <ertes> Nicmavr: i was confused by the word "run", because GHCi doesn't actually run anything by itself…  it just type-checks your code and compiles it into bytecode, then it exposes all the definitions to you on the interactive prompt (the "REPL")
10:03:50 <Hafydd> I'm looking for the Linux equivalent of Windows: dows.
10:10:22 <ph88> if i have   data Foo = F [Bar]   data Bar = B [Int]   and i put maxSize on 2  and i test property of Foo does that mean max 4 testcases, because there are 2 generators so 2 * 2 ?
10:23:16 <lyxia> What two generators
10:23:47 <lyxia> and it depends on your generator
10:23:56 <lyxia> some generators don't care about the size parameter
10:29:35 <ph88> lyxia, well i thought one generator for Foo and one for Bar that generate a list each of max 2 elements
10:58:26 <Gurkenglas> F [], F [B []], F [B [], B []], F [B [1], B []], F [B [1, 1], B []], and so on. (That'll take a while.)
11:04:12 <johnw> haasn: hi
11:07:01 <johnw> @tell haasn https://github.com/jwiegley/coq-haskell/blob/master/src/Control/Monad/Predicate.v#L1316
11:07:01 <lambdabot> Consider it noted.
11:15:52 <Lokathor> so
11:16:11 <Lokathor> how sane is it to concurrently write to an IOVector from two threads
11:16:20 <Lokathor> like, if you know for sure that they'll be writing to distinct indexes
11:17:11 <ertes> could the System.Process API (especially callProcess) interact weirdly with threads?  i need to spawn processes from multiple haskell threads
11:17:55 <Lokathor> seems everyone has concurrency questions today
11:18:22 <geekosaur> ertes, yes absolutely
11:19:02 <ertes> geekosaur: what's the proper way to do it?  spawn all of them from the main thread?
11:20:22 <ertes> hmm, but the haddocks of System.Process sure sound like everything should be fine
11:20:26 <ertes> i'll just try it
11:20:30 <geekosaur> depends on what you are doing with them. at one point there was a bug, which I don't recall if it got fixed or not. in general threads + processes is problematic though.
11:21:21 <ertes> yeah, i read about that
11:21:48 <ertes> because forked processes don't inherit threads…  however, i'm executing into a different program
11:22:07 <geekosaur> although callProcess *should* be relatively safe, usualy (see the gotcha in forkProcess)
11:22:36 <ertes> where is forkProcess?
11:23:14 <geekosaur> oh, sorry I had mentioned in an earlier iteration of that response :/ System.Posix.Process.forkProcess
11:23:24 <geekosaur> which is the primitive it's using on linux/osx/unix
11:23:44 <ertes> oh, i'm not actually using the unix API…  i'm really just starting other programs via the process API
11:23:53 <geekosaur> (it'll be doing something different on Windows and I don't know what kind of things to watch out for there)
11:24:07 <geekosaur> right, I cited it just for the caveat about cross-thread data access
11:24:37 <geekosaur> which for callProcess could mean the parameters you pass it, since it shouldn't otherwise do anything before exec()ing
11:24:50 <ertes> it might become relevant at some point, because i'm going to do containery stuff from haskell, but i'll try to avoid fork/clone as much as possible anyway
11:24:57 <geekosaur> (in theory. there was a bug with (iirc) Handle locking and threads at one point)
11:25:46 <geekosaur> with hints the bug might be a more general runtime bug, and the suggestion that forkProcess + forkIO might be generally not safe :/
11:26:22 <geekosaur> have you actually seen problems with it, or are you asking beforehand?
11:26:23 <ertes> geekosaur: does any of this apply to the process API?  i can't find any warnings in the haddocks of System.Process
11:26:29 <ertes> i'm asking beforehand
11:27:03 <geekosaur> then I'd say TIAS -- it is *supposed* to work, but there might well be corner cases (in which case report them)
11:27:15 <ertes> the little information about threads provided there really suggests that i should be safe
11:27:22 <geekosaur> "should be"
11:27:31 <ertes> i'll just try =)
11:29:10 <randomnickname> @pl \f -> \x y -> fmap (f x) y
11:29:10 <lambdabot> (fmap .)
11:30:07 <Lokathor> so I have a Ptr (), what's the best way to write data to it
11:30:08 <shiona> @unpl (fmap .)
11:30:08 <lambdabot> (\ g x -> fmap (g x))
11:30:12 <geekosaur> I should dig out that old thread and see if it actually had an outcome other than "uh, be careful, there may be dragons lurking" which is what I recall from it
11:31:04 <ertes> there is one remaining question:  callProcess will use waitForProcess when an async exception occurs, but what if it's used in a secondary thread and the main thread dies?  it won't get a chance to wait in that case…  will something else wait, or will the subprocess become a zombie?
11:31:07 <geekosaur> (well, that and "there's a possibility the I/O manager will explode killing everyone in range if you forkProcess at the wrong time")
11:31:12 <ertes> Lokathor: see Foreign.Storable
11:31:30 <Lokathor> ah ha
11:31:34 <Lokathor> i was looking in marshal
11:31:47 <geekosaur> main thread dies = process exits = children get inherited and reaped by pid 1
11:31:56 <geekosaur> (init/upstart/systemd/whatever)
11:32:10 <ertes> Lokathor: if it's an array i generally recommend the Data.Vector.Storable.Mutable API over Foreign.Storable
11:32:23 <geekosaur> if they end up zombies, you have a bigger problem :)
11:32:42 <ertes> geekosaur: they get inherited by process 1 right away?
11:32:48 <geekosaur> yes
11:32:52 <ertes> ah, ok
11:32:54 <Lokathor> ertes, it is a Ptr () reprisenting the bytes of an SDL_Surface, which will be of a known format
11:32:57 <geekosaur> no action needed (or possible)
11:33:54 <ertes> geekosaur: out of interest: can that be overridden?  i have an s6-svscan sitting between my system's systemd and my own program, so i might as well leave that responsibility to s6-svscan
11:33:58 <Lokathor> ertes, Data.Vector.Storable.Mutable seems to use ForeignPtr rather than Ptr.
11:34:11 <ertes> Lokathor: and so should you =)
11:34:32 <ertes> raw Ptr is asking for trouble
11:34:35 <Lokathor> ertes, uhhhh, are they convertable? Pretend I've never used a Ptr in Haskell before :P
11:34:54 <Lokathor> I'm using Ptr because that's what the library gives me, I don't get to pick in this case
11:35:08 <geekosaur> ertes, that was what I meant by "(or possible)"
11:35:19 <ertes> Lokathor: are you in charge of the Ptr?  i.e. do you need to "release" it at some point in some way?
11:35:26 <Lokathor> I do
11:35:28 <ertes> geekosaur: ah, ok
11:35:32 <Lokathor> well
11:35:33 <geekosaur> that said, systemd does provide a few extra non-POSIX doodads, but you'd have to know about them and configure the systemd unit and the interposer to use them
11:35:44 <Lokathor> you lock the pixels, fiddle with the pixel data, and then unlock the pixels
11:35:51 <ertes> Lokathor: then you can go right from the Ptr to a ForeignPtr and attach a finaliser
11:36:01 <Lokathor> ertes, https://hackage.haskell.org/package/sdl2-2.1.3/docs/SDL-Video-Renderer.html#v:surfacePixels
11:36:10 <ertes> Lokathor: then when you no longer need it, you finalise explicitly
11:36:32 <ertes> Lokathor: yeah, you can definitely use ForeignPtr there together with the vector API
11:37:09 <ertes> Lokathor: here is how i did it with that API: http://lpaste.net/170277
11:37:22 <ertes> Lokathor: line 166
11:37:33 <geekosaur> but in general, if the parent exits any children immediately get reparented to pid 1. (which makes the pgrp variant of waitpid() less useful than it might be, but there's not really a good way to handle it otherwise --- at least via POSIX. cgroups bring in more options, but now you get to decipher the cgroups API)
11:38:00 <ertes> Lokathor: i didn't even attach a finaliser, but used bracket to make sure that the texture gets unlocked
11:38:14 <Lokathor> right, i was figuring on bracket
11:38:28 <Lokathor> okay I'll give this a try
11:38:48 <ertes> Lokathor: you can run that code, if you want to watch some haskell+reflex+sdl2 eye candy =)
11:39:04 <ertes> + kan-extensions
11:39:15 <Lokathor> i'm trying the handmade hero project in SDL + Haskell
11:39:33 <Lokathor> but day 10 is performance counters, and i just realized that it's going at like 20fps using bytestring
11:39:39 <Lokathor> :/
11:39:52 <ertes> geekosaur: i have to decipher that one anyway, but with lower priority
11:40:05 <ertes> geekosaur: i want to get namespaces right, first…  cgroups are technically optional
11:40:28 <ertes> geekosaur: in fact i think it's the PID namespaces that provide extra options here, not cgroups
11:41:18 <geekosaur> Lokathor, probably want Storable Vector Word8 instead
11:41:35 <ertes> Lokathor: any particular reason you're not using OpenGL?
11:41:37 <sm> Lokathor: that's great.. do you have a blog/tweetstream/repo showing progress ?
11:41:46 <Lokathor> geekosaur, exactly. Im already using ByteString's unfoldrN to build the bytes one Word8 at a time
11:42:30 <Lokathor> ertes, I know neither SDL or OGL, and SDL seems friendlier because i found a guide for SDL already (though it's handmade hero in C++ + SDL, so still quite a bit of converting)
11:42:33 <geekosaur> ByteString predates Vector, and was ripped out of ghc (FastPackedString). there's even an (oldish) vector-bytestring proof of concept on Hackage which is basically the (then current) ByteString API on top of Vector
11:42:55 <ertes> Lokathor: i see, yeah…  not saying you should right now, because OpenGL has a learning curve of its own
11:43:52 <ertes> what's your opinions on an experiment to create new APIs based on vector instead of bytestring?  i'd really like to help deprecate bytestring at some point
11:44:22 <monochrom> Yes that will give us a more unified FFI story.
11:44:36 <Lokathor> in mean the original handmade hero is also dumping bytes into a windows pixel buffer, so it should be "fast enough" to throw down some Word8 or maybe Word8# values, if i do it right
11:45:42 <Lokathor> sm, I have been documenting things, though at the moment it's all in a private repo because his project is a 15$ signup for the code (he'll open source it later)
11:45:51 <ertes> Lokathor: the way you do it can have a major impact on performance…  you should also know that C/C++ compilers likely optimise looping char writes into larger units (machine words), if possible…  GHC does not do that
11:45:56 <Lokathor> I can put the notes only up in a moment actually
11:46:23 <Lokathor> ertes, yeah in his version he writes per 32-bit value
11:46:32 <Lokathor> and then bitshifts the correct colors into position
11:46:56 <ertes> you should write in units of Word, if you can, which is solved elegantly by not looping explicitly at all, but just use one of the copying APIs of vector
11:46:59 <geekosaur> ertes, re new APIs, you might want to look at vector-bytestring too
11:47:15 <randomnickname> @pl \f -> if a f then b f else c f
11:47:15 <lambdabot> ap (liftM2 if' a b) c
11:47:25 <geekosaur> note that if
11:47:26 <geekosaur> er
11:47:30 <ertes> geekosaur: i've seen that one, but i haven't ever seen it in use
11:47:30 <randomnickname> yeah
11:47:31 <randomnickname> what is that
11:47:36 <geekosaur> note that if' doens't exist
11:47:38 <randomnickname> oh
11:47:44 <Lokathor> ertes, the copy functions all seemed to be from vector to vector, I think an unfoldr is what i'd need at the moment
11:47:51 <randomnickname> unteresting
11:47:57 <Lokathor> currently there's no bitmaps, just a software generated color gradiant
11:48:10 <geekosaur> ertes, it was an experiment. you probably want to look for discussion around it, which will likely involve why ghc used FPS/ByteString in the first place
11:48:10 <ertes> Lokathor: if one of them is not a vector, make it a vector
11:48:25 <Lokathor> ertes, i mean that the source doesn't exist at all :P
11:48:34 <ertes> Lokathor: ah, ok =)
11:48:46 <Lokathor> ertes, http://lpaste.net/350454
11:48:46 <randomnickname> is @pl not okay with ifs?
11:49:20 <geekosaur> there's some screw cases involved with retrofitting a vector version back into ghc, like (iirc) the way ghc stores string literals as FPS/ByteString in the r/o text segment and therefore FPS/ByteString expects pinned/non-GCd byte arrays so it can handle that use case
11:49:35 <monochrom> if' is a fantastic beast defined by if' b p q = if b then p else q
11:49:41 <ertes> Lokathor: you can save yourself the trouble to compute/write individual components in sequence by using the 'linear' library
11:49:48 <geekosaur> randomnickname, actually it just hasn't been updated. there is now
11:49:51 <geekosaur> :t bool
11:49:53 <lambdabot> a -> a -> Bool -> a
11:49:58 <ertes> Lokathor: i.e. use V3 Word8 for RGB with 1-byte components
11:50:00 <geekosaur> different parameter order but same idea
11:50:15 <Lokathor> i've never used linear, but i'll give it a look
11:50:19 <quuxman> Yay merry Haskell. I'm pretty happy to see this channel active on Christmas :). 
11:50:31 <randomnickname> geekosaur: oh ok
11:50:41 <geekosaur> but in general, the problem @pl is running into is that the if..then..else is not really pointfree-able as such
11:50:48 <ertes> Lokathor: V3 Word8 is Storable such that (V3 x y z) has a 3-byte memory layout with x, y and z in that order
11:50:53 <Lokathor> geekosaur, my biggest request for vector stuff is a well tuned "ranged copy" operation, which doesn't seem to exist. at the moment it looks like you have to roll your own
11:50:57 <quuxman> I'm trying to get some code to compile that I _know_ compiles, but I'm getting a type error. How do I figure out which extension I need, or what else could be wrong?
11:51:13 <geekosaur> so it cheated. (and `bool` is very recent in the Haskell ecosystem)
11:51:25 <randomnickname> i see
11:51:34 <geekosaur> Lokathor, I'd imagine it could be done by a RULES pragma but nobody has needed it as yet
11:51:51 <ertes> Lokathor: in other words you would just use Vector (V3 Word8)…  look at my paste to see how it works
11:52:10 <sm> merry Haskell quuxman
11:52:24 <quuxman> (TwoDimensionalTextureTarget (Maybe a0)) /  arising from a use of ‘texImage2D’'
11:52:26 <geekosaur> recognize the bulk copy case and rewrite it to use the same tricks a C compiler would use (machine word copies, sometimes FPU copies!)
11:52:27 <quuxman> opengl.hs:141:3: No instance for (TwoDimensionalTextureTarget (Maybe a0)) /  arising from a use of ‘texImage2D’
11:52:30 <sm> you may have tried this already, but.. read the error message ? :)
11:52:31 <Lokathor> well, i want something like, limitedCopy :: VecSource -> VecDest -> Start -> End -> IO ()
11:52:31 <ertes> Lokathor: (actually i'm using V3 Double and convert it Word32)
11:53:03 <Lokathor> ertes, what about V4?
11:53:24 <sm> oops
11:53:28 <geekosaur> (although FPU would only be used on i686, since the word size is big enough on x86_64)
11:53:49 <lpaste> quuxman pasted “continuous 1d cellular automata” at http://lpaste.net/350455
11:54:10 <ertes> Lokathor: yeah, i didn't bother, because oddly there is actually no non-explicit way to go from (V3 a) to (V4 a), so i chose to just bitshift explicitly =)
11:54:41 <Lokathor> well later on I know for sure that i'll need to be adjusting the alpha channel with blending, once actual art assets come into play
11:54:47 <Lokathor> so i guess i'll just go with V4
11:55:42 <Lokathor> oh huh
11:55:45 <ertes> Lokathor: i could have used V4 with alpha for the lighting calculation, but i considered the alpha value to be just a scalar multipler in that code
11:55:53 <Lokathor> ertes, it seems like SDL's vector library is already the linear library maybe?
11:56:16 <ertes> Lokathor: yes
11:56:17 <geekosaur> quuxman, and the full error message? (use the "Annotate" link on that paste so it gets grouped with it)
11:56:22 <Lokathor> perf
11:56:25 <sm> quuxman: how do you "know" it compiles when it doesn't :)
11:56:54 <geekosaur> sm, sounds like this is code that worked with an older ghc or older dependencies
11:57:03 <sm> what if you give that Nothing  a type annotation, eg (Nothing :: TheType)
11:57:20 <sm> or make it (Just whatever) just to see
11:57:36 <Lokathor> aside question, does haskell do the Null Pointer Optimization thing that rust folks like to talk about?
11:57:40 <quuxman> sm: I have a compiled version on this computer and I haven't touched any libraries or the compiler
11:57:44 <Lokathor> for like, the Maybe type
11:57:45 <geekosaur> which is entirely possible, as both ghc and OpenGL have gotten some fairly major revisions depending on how old the code is
11:57:52 <ertes> Lokathor: unlikely
11:58:14 <sm> quuxman: if you build with cabal, I suppose it could be pulling in newer deps from hackage
11:58:36 <lpaste> quuxman annotated “continuous 1d cellular automata” with “continuous 1d cellular automata (annotation)” at http://lpaste.net/350455#a350456
11:58:49 <Lokathor> ertes, what worries me a little about the SDL Vectors is that they are (V4 ~a ~a ~a ~a) and the linear ones are (V4 !a !a !a !a)
11:58:55 <monochrom> what is null pointer optimization?
11:58:55 <quuxman> sm: never figured out how to build with cabal
11:59:15 <monochrom> but bear in mind that Maybe is an algebraic type, pointer is not.
11:59:30 <ertes> Lokathor: huh?  they should be the same thing
11:59:43 <ertes> Lokathor: try this:  V4 undefined () () () `seq` ()
11:59:47 <geekosaur> ok, I am going t guess something that used to produce an a now produces a Maybe a, for some a
12:00:01 <Lokathor> monochrom, with the rust Option type, when it points to a ref type, they optimize it to just being the ref type with an internal check for 0 or not, instead of having one byte for the enum tag and one for the pointer if it's there
12:00:16 <lpaste> quuxman revised “continuous 1d cellular automata (annotation)”: “compile error” at http://lpaste.net/350456
12:00:41 <MarcelineVQ> it is the case that old versions of texImage2D took a Maybe a as the first argument, newer versions require something like TextureTarget2D or another instance of TwoDimensionalTextureTarget
12:01:10 <cobreadmonster> Has anyone here implemented LDA in Haskell?
12:01:14 <Lokathor> ertes, http://lpaste.net/350458 seems they made it lazy for some reason?
12:01:21 <monochrom> I see. GHC doesn't do that. But GHC does a different thing and it's more general, it applies to all algebraic types. It's pointer tagging.
12:01:25 <MarcelineVQ> well used to take Maybe CubeMapTarget actually
12:01:33 <Lokathor> or, no, it didn't print at all, i guess it's strict
12:01:43 <ertes> Lokathor: yes, because it's the same type
12:02:00 <Lokathor> very weird that the docs have different notations on them then
12:02:16 <ertes> Lokathor: make the test:  import SDL and Linear, and see if referring to V4 causes a name clash
12:02:27 <ertes> or better: import SDL and try :i V4
12:02:35 <ertes> it should tell you that it's defined in Linear.V4
12:03:07 <monochrom> OTOH GHC is a memory hog (and there is an aesthetic reason). You say Rust uses just 1 byte for tag? GHC uses 8.
12:03:15 <Lokathor> just gotta build sdl2 for my global stack package... 1 sec
12:03:23 <ertes> regarding the null pointer optimisation:  i'm pretty sure rust's Option and haskell's Maybe aren't actually the same type
12:03:48 <quuxman> MarcelineVQ: huh, but I haven't run any cabal commands or upgraded any packages since I compiled this :-|
12:03:59 <Lokathor> monochrom, well i don't know if it's litearlly 1 byte for a tag, but they avoid any extra memory at all when there's an Option<&T> compared to a &T, and they get to keep the type safety
12:05:05 <Lokathor> ertes, yeah, defined in Linear.V4
12:05:08 <quuxman> MarcelineVQ: what's the TextureTarget2D equivalent of Nothing?
12:05:19 <ertes> GHC on 64 bit platforms could probably use some of the higher bits for extra information
12:05:24 <Lokathor> still confusing why the SDL docs say that they're lazy fields. That's what the ~ normally means on a field right?
12:05:40 <ertes> Lokathor: where do they say that?
12:05:45 <MarcelineVQ> quuxman: likely Texture2D
12:05:49 <Lokathor> https://hackage.haskell.org/package/sdl2-2.1.3/docs/SDL-Vect.html#t:V4
12:06:16 <MarcelineVQ> which is a value of the type TextureTarget2D
12:07:00 <ertes> Lokathor: judging by the instances this is definitely an edwardk type, so from 'linear' =) and honestly i don't know what those ~ mean
12:07:14 <Lokathor> bizarre
12:07:34 <ertes> they don't mean non-strict, because that would be indicated by the lack of !
12:07:43 <randomnickname> @pl (\ys xs -> fmap ($ xs) . fmap (:) $ ys)
12:07:43 <lambdabot> flip ((. fmap (:)) . fmap . flip id)
12:07:48 <MarcelineVQ> does it have StrictData on? "Informally the StrictData language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a ~ in front of the field."
12:08:01 <randomnickname> lord
12:08:04 <Lokathor> well in Strict mode the ~ is non-strict. I think they're also.. uh, "irrefutable" in normal haskell maybe?>
12:08:05 <randomnickname> that's a horrible pointfree form
12:08:12 <randomnickname> >_>
12:08:15 <ertes> ah
12:08:21 <ertes> i forgot about -XStrict
12:08:29 <quuxman> MarcelineVQ: I have no idea why that change is made, but why wasn't TwoDimensionalTextureTarget given a Maybe instance?
12:09:06 <ertes> Lokathor: then perhaps it's a haddock bug…
12:09:07 <MarcelineVQ> I actually don't know anything about that package so I can't say sorry :(
12:09:21 <Lokathor> i'd believe it
12:09:43 <ertes> Lokathor: care to report a bug?
12:09:51 * geekosaur actually did wonder if the ~s meant it was using Strict / StrictData...
12:10:15 <Lokathor> ertes, no i've already reported several this week :P
12:10:20 <monochrom> yes ~ is irrefutable pattern in normal Haskell. but it appears in pattern only in normal Haskell. OTOH it's all OK because ~ increases laziness in normal Haskell already, may as well extend the analogy.
12:10:44 <Lokathor> sm, https://www.dropbox.com/s/2ckzuta4v4g92zm/handmade-haskell-notes.zip?dl=0
12:11:04 <ertes> i believe even in strict mode haddock should generate regular docs
12:11:19 <ertes> i.e. it should generate (V4 !a !a !a !a)
12:11:44 <ertes> otherwise we'd have to pay attention in the future whether the module had strict mode on before reading module docs
12:18:55 <quuxman> MarcelineVQ: weird, the current version of OpenGL has Maybe CubeMapTarget as first argument of texImage2D, and my version is TwoDimensionalTextureTarget t, so somehow my opengl package regressed
12:20:09 <MarcelineVQ> the current version does not, which version is the current version for you? :o
12:20:53 <ertes> @let worthyChristmasDinner xs = foldr (\x go n -> fmap (x:) . (if n < 10 then swap else id) . go . succ $ n) mempty xs 0
12:20:56 <lambdabot>  Defined.
12:21:03 <ertes> > worthyChristmasDinner "mpairzgzhaerita"
12:21:07 <lambdabot>  ("pizza","margherita")
12:21:17 * Lokathor claps
12:21:29 <quuxman> MarcelineVQ: http://lambda.haskell.org/platform/doc/current/packages/OpenGL-2.8.0.0/doc/html/Graphics-Rendering-OpenGL-GL-Texturing-Specification.html#v:texImage2D
12:21:52 <MarcelineVQ> ah 2.8.0.0 isn't the most current version, 3.0.1.0 is
12:22:11 <quuxman> I was looking at http://lambda.haskell.org/platform/doc/current/
12:22:31 <quuxman> I probably have two versions of haskell or something
12:22:52 <MarcelineVQ> I don't even know what this lambda is, but the last update was 2013 http://lambda.haskell.org/platform/doc/
12:22:58 <quuxman> I have homebrew cask haskell-platform
12:24:01 <MarcelineVQ> hmm well regardless, you have a version of OpenGL currently that requires a TwoDimensionalTextureTarget for texImage2D, you should find out what version you have so you can be pointed to the right docs
12:24:40 <geekosaur> quuxman, homebrew is behind on updates because recent ghc has had problems on recent OS X (8.0.2 has a workaround for them but is still in release candidate state)
12:28:46 <Lokathor> ertes, so you're using Word32 in the lpaste example you said
12:29:01 <Lokathor> but you also said that you use V3?
12:33:14 <ertes> Lokathor: yes, in the actual colour compotations
12:33:17 <ertes> computations
12:33:31 <ertes> see line 120
12:34:13 <ertes> also line 78, where i do the lighting calculations in RGB
12:35:46 <ertes> Lokathor: actually the whole code uses V3 Double for colours, except the very last step when it gets written into the texture buffer
12:37:04 <ertes> (this is perhaps one of the rare occasions when it would actually be helpful to have a type alias, because i'm also using V3 Double for positions in 3D)
12:37:14 <ertes> type Colour = V3
12:37:57 <ertes> however, this code is really quick-n-dirty…  originally all i wanted to do was to experiment with reflex+sdl2, but it turned into a software-rendered light effect at some point =)
12:38:34 <Lokathor> i'll give it a try
12:39:00 <Lokathor> wow look at all the errors!
12:39:01 <Lokathor> whee
12:39:14 <Lokathor> PS: coloUr = V3, next you'll be talking about how linear lets you do all kinds of mathS
12:40:28 <ertes> Lokathor: you need the following libraries (beside sdl2) to run it: clock, kan-extensions, mwc-random, reflex
12:40:46 <ertes> if it still gives you errors, just tell me, and i'll fix it
12:41:08 <Lokathor> ha
12:41:12 <Lokathor> can't install reflex it seems
12:41:23 <Lokathor> on my current LTS
12:41:32 <ertes> oh…  do you happen to have nix?
12:41:33 <Lokathor> oh well
12:41:42 <Lokathor> no i've got windows 7
12:41:47 <Lokathor> i live life on the edge like that
12:41:49 <ertes> oh, i see
12:41:56 <Lokathor> though, the errors i was talking about are actually my own
12:42:06 <Lokathor> i've ripped out and replcaed like 30% of the program at once
12:42:16 <Lokathor> tons of little things stack wants me to fix
12:42:18 <ertes> ah, ok =)
12:42:28 <ertes> couldn't you just use a cabal sandbox?
12:42:44 <quuxman> how do I find what version of a module I'm using?
12:43:14 <Lokathor> ertes, the biggest problem is that i need an older version of base
12:43:27 <Lokathor> so i'd have to download a GHC 7.10 or whatever
12:43:49 <ertes> Lokathor: huh?
12:43:59 <ertes> Lokathor: for your changes?  because the code should work with 8
12:45:12 <MarcelineVQ> quuxman: What are you using to build your source file? ghc directly or cabal?
12:45:18 <Lokathor> http://lpaste.net/350459 is what it says when i tried to install the packages you said
12:45:19 <ertes> quuxman: modules don't have versions, but packages do…  to see the version of a package you have installed, you should just ask cabal:  cabal info PKGNAME
12:45:26 <quuxman> MarcelineVQ: ghc directly. Never figured out how to use cabal
12:45:51 <quuxman> ertes: I have two versions, so presumably the newest is used when imported
12:46:05 <ertes> quuxman: oh, in that case: ghc-pkg list PKGNAME
12:46:58 * Lokathor wants a new GHC extension... {-# LANGUAGE IDontCareJustFixTheIntegralsHoweverYouNeedToItsFine #-}
12:48:17 <randomnickname> is there any reason i might not be able to replace : with <|> at any given time
12:48:29 <randomnickname> assuming i know for sure i'm using []
12:48:30 <ertes> Lokathor: i have no experience with stack, but perhaps just try what it tells you to do
12:49:02 <ertes> randomnickname: (:) and (<|>) do different things
12:49:09 <ertes> > 'a' : "bc"
12:49:12 <lambdabot>  "abc"
12:49:13 <randomnickname> oh eorry
12:49:13 <ertes> > 'a' <|> "bc"
12:49:16 <lambdabot>  error:
12:49:17 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
12:49:17 <lambdabot>      • In the first argument of ‘(<|>)’, namely ‘'a'’
12:49:19 <randomnickname> i meant (<|>) . pure
12:49:26 <quuxman> what is lambda.haskell.org btw?
12:49:46 <ertes> randomnickname: if type inference can figure out that it's [], then there is no reason
12:49:55 <ij> I really cannot $(use) functions of module X with TemplateHaskell inside of module X?
12:50:13 <Lokathor> ertes, i could, but i'd rather get this gradiant animating faster. Attempt 1: it runs at 2000fps but displays nothing
12:50:35 <ertes> Lokathor: that's pretty slow for a loop that displays nothing =P
12:50:40 <sbahra> Is there a particular error report / error aggregation system folks tend to use for Haskell? Something like WER.
12:50:48 <Lokathor> there's also println calls slowing it down
12:51:11 <sbahra> For example, I have a web service built in Haskell, and I want errors to be aggregated to a central server so I can build workflows around it.
12:51:17 <geekosaur> ij, only if they come *before* the use
12:51:37 <geekosaur> it's running *while it's parsing*, it has not seen the rest of the file yet
12:51:54 <randomnickname> ertes: and yet when i do switch it out, i get an error... odd
12:51:54 <geekosaur> that's what compile time means
12:52:10 <ertes> randomnickname: ambiguity error?
12:52:15 * Lokathor carefully adds a call to "SDL.updateWindowSurface window" after the bracket section
12:53:29 <geekosaur> quuxman, part of the web infrastructure, if you really care try asking in #haskell-infrastructure
12:54:02 <Lokathor> geekosaur, here's another Vector operation I'd want: a map-like operation that gives you the index and you give it what you want at that index, and it fuses it all into fastness using magic
12:54:07 <quuxman> geekosaur: I was hoping it was like AWS lambda for Haskell
12:54:41 <geekosaur> afaik it's got nothing to do with that, it's just using a functional programming naming scheme
12:54:51 <quuxman> man I'm so frustrated by this opengl library change from 2.8 to 2.9 because I can't find anything about why it was changed and how to migrate
12:55:03 <quuxman> and cabal fails to install 2.8 for some obscure reason
12:55:29 <Lokathor> ertes, ~800fps while showing just blue and not computing anything
12:55:40 <randomnickname> ertes: yeah
12:56:16 <randomnickname> so I'm using lists of (lists of (lists of)) numbers, and i'm getting no instance for Num a0
12:56:19 <ertes> Lokathor: might be related to your driver/hardware/settings
12:56:53 <Lokathor> well theoretically i'm also requesting VSync through SDL, but i've no way to know if it's actually doing that. probably not if the FPS is going above 60 :P
12:57:15 <Lokathor> oops, commented out the vsync line it seems
12:57:23 <ertes> hehe
12:57:51 <ertes> randomnickname: feel free to paste your code
12:57:57 <geekosaur> @paste
12:57:58 <lambdabot> Haskell pastebin: http://lpaste.net/
12:58:04 <ertes> … there ^
12:59:01 <Lokathor> :t zipWithM_
12:59:04 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()
12:59:34 <Lokathor> :t mapM_
12:59:36 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
13:00:46 <Lokathor> > [0..5]
13:00:49 <lambdabot>  [0,1,2,3,4,5]
13:01:49 <randomnickname> ertes: http://lpaste.net/350461
13:02:11 <randomnickname> ignore my ..overpointfree form
13:02:15 <randomnickname> and terrible naming :p
13:03:29 <geekosaur> I think that's just that you became too polymorphic and disabled numeric defaulting
13:03:42 <geekosaur> so you need to specify which Num instance it should use
13:04:14 <geekosaur> easiest way is to stick a type annotation on one of the numeric literals
13:04:49 <Tuplanolla> You might also like `:set prompt "> "` and `:set prompt2 "> "`, randomnickname.
13:05:30 <ij> Can you paste to lpaste from commandline?
13:05:57 <geekosaur> hm, no, that gives me a better error though
13:06:08 <geekosaur> somewhere you are using a number as if it were a function
13:06:11 <Tuplanolla> Does using `curl` or `w3m` count, ij?
13:06:27 <lpaste> ij pasted “geekosaur, Should this work?” at http://lpaste.net/350462
13:06:52 <ij> Tuplanolla, Nope, not at all. I'm thinking sprunge.us/ix.io.
13:07:11 <Tuplanolla> Then probably not.
13:07:41 <randomnickname> Tuplanolla: ah yes
13:08:28 <ph88> when i have something like   Foo a   is "a" called a type parameter ? is there a general name of programming with this technique? I think in other languages they would call this generic programming but generic programming in haskell is used for programming over structures so it must have another name ..
13:08:41 <Lokathor> ertes, ~130fps with animation and all
13:09:12 <Lokathor> pfft, and the other day someone was trying to be all "oh the bytestring isn't too expensive, i'm sure"
13:09:19 <Tuplanolla> Usually "parameter" when abstracted and "argument" when supplied, ph88.
13:09:32 <ertes> Lokathor: ByteString *is* expensive
13:10:14 <Lokathor> probably
13:10:15 <ertes> ph88: what Tuplanolla said, and the concept is called (parametric) polymorphism in haskell
13:10:33 <ertes> Lokathor: also ByteString has no mutable counterpart (other than ForeignPtr)
13:10:34 <Lokathor> they blamed the intermediate Word8 allocations of the B.unfoldrN process
13:10:36 <ph88> i heard earlier that polymorphism only applied to functions ??
13:10:43 <randomnickname> ertes: a little clearer: http://lpaste.net/350461
13:11:09 <Tuplanolla> :t 42 -- What's this then, ph88?
13:11:11 <lambdabot> Num t => t
13:11:11 <geekosaur> ij, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#using-template-haskell see point two
13:12:36 <ertes> randomnickname: ah, i see what your mistake is:  you're typing all of this into a line of GHCi =)
13:12:43 <randomnickname> :p
13:12:56 <ph88> Tuplanolla, a rethoric question ?
13:13:04 <Lokathor> ph88 you could imagine (Foo a) being a type level operation similar to functions being value level operations. To get a type with actual usable values you apply Foo to some other type, like (Foo Int)
13:13:11 <Tuplanolla> It's a polymorphic not-function, ph88.
13:13:31 <geekosaur> ij, basically it would be necessary to compile the module fully up to the point of the splice, possibly with anything not seen yet replaced with `undefined`, so that it can run the function at compile time.
13:13:36 <ertes> Lokathor: a lot of things can be blamed when it comes to ByteString performance, but it doesn't help…  just don't use it
13:13:49 <geekosaur> (at the time TH splices are run, it is still parsing; it has not generated runnable code for `cmd`)
13:13:55 <ertes> consider ByteString to be an exchange type mostly for binary data from files/sockets
13:13:56 <ij> Yeah, I gather.
13:13:57 <ph88> thx guys
13:14:04 <randomnickname> ertes: so does it just not give a better error because it's a repl?
13:14:15 <ij> I see how it could be implemented, but can be dealt with otherwise.
13:14:16 <ertes> ph88: polymorphism applies to everything
13:14:18 <Lokathor> ertes, I was only using it because ByteString is what the SDL package has you use ...It's starting to look like sdl2 is maybe less slick than they say >_>
13:14:43 <geekosaur> if ghc were always an interpreter, like perl/python/ruby/etc., it could do that more sensibly. but for a full compiler (even to a bytecode, like javac), this is difficult
13:14:54 <ertes> randomnickname: no, it gives the same errors, but i honestly don't want to decipher that line
13:15:09 <randomnickname> fair enough :P
13:15:13 <randomnickname> how bizarre
13:15:46 <ertes> Lokathor: hmm?  i haven't seen ByteString in the sdl2 API yet
13:16:10 <ertes> Lokathor: not that it isn't there…  i just haven't seen it
13:16:21 <geekosaur> Tuplanolla, re your :t 42, keep in mind that it *is* a function
13:16:23 <Lokathor> https://hackage.haskell.org/package/sdl2-2.1.3/docs/SDL-Video-Renderer.html#v:updateTexture
13:16:33 <geekosaur> because ghc is wrapping it in fromInteger behind your back
13:16:47 <Lokathor> they should maybe have you pass them an IOVector instead
13:16:47 <Tuplanolla> Let's not go there.
13:17:18 <randomnickname> well i guess the thing to do now is see if i can reduce this to a simpler case
13:21:12 <ertes> Lokathor: that's weird!
13:21:57 <Lokathor> maybe they expect you to use something like (pixels <- B.fromFileIO) and overwrite an old texture with new file data
13:21:59 <Lokathor> i dunno
13:22:02 <ertes> Lokathor: however, you still have the surface API
13:22:18 <Lokathor> yeah, it's pretty slick using it like you suggested
13:23:16 <Lokathor> http://lpaste.net/350464 ~130fp seems reasonable considering that we're computing half the channels every frame instead of mostly copying around buffers
13:23:34 <ertes> Lokathor: at some point you're probably converging toward OpenGL, and then…  let me just say that ByteString won't be the thing that makes you pull your hair out =)
13:24:02 <Lokathor> well after the "platform" layer is done, Handmade Hero mostly moves into gameplay elements for a long while
13:24:30 <Lokathor> i've seen up to about ep 50, and he's on an entity system and collisions and moving them between update batches and stuff
13:25:06 <ertes> Lokathor: BTW, although it doesn't apply to this particular example i like to use Codensity from kan-extensions to streamline nested brackets
13:25:30 <Lokathor> hmm
13:25:48 <Lokathor> "Codensity f is the Monad generated by taking the right Kan extension of" i'm already lost
13:26:12 <geekosaur> heh
13:26:36 <ertes> Lokathor: before:  bracket o1 c1 (\x -> bracket o2 c2 (\y -> f x y))
13:27:08 <ertes> after:  do x <- Codensity (bracket o1 c1); y <- Codensity (bracket o2 c2); liftIO (f x y)
13:27:25 <Lokathor> that does seem handy
13:27:51 <Lokathor> however, years of java have taught my brain to be comfortable with nested levels of brackets :P
13:28:10 <ertes> yeah, especially when you have conditional brackets, as they tend to pop up in applications like this
13:28:23 <wayne> if a monoid is invertible does that make it a group?
13:28:29 <wayne> does that mean that all groups are also monoids?
13:28:33 <Lokathor> I usually use haskell more like the best imperative language rather than the best type gymnatics language
13:28:39 <ertes> wayne: if all elements have inverses
13:28:46 <ertes> wayne: and yes
13:28:50 <wayne> ah cool thanks ertes
13:28:51 <quuxman> wow, after a lot of digging through the API I realized that crazy set of type classes and constructors was basically an enum with some parameters maybe? Turned Nothing to Texture2D and it compiles
13:29:31 <wayne> i've gone through some abstract algebra texts but they don't even mention monoids
13:29:37 <wayne> then again, they're prettty introductory ones
13:29:38 <ertes> Lokathor: the main insight is:  1. Codensity m a ≃ forall r. (a -> m r) -> m r
13:29:58 <ertes> Lokathor: 2. bracket o c :: forall r. (A -> IO r) -> IO r
13:30:04 <lpaste> quuxman annotated “continuous 1d cellular automata” with “fixed compile error for opengl 2.8 to 2.9 change” at http://lpaste.net/350455#a350465
13:30:25 <lpaste> quuxman revised “fixed compile error for opengl 2.8 to 2.9 change”: “fixed compile error for opengl 2.8 to 2.9 change” at http://lpaste.net/350465
13:30:28 <ertes> Lokathor: so bracket actually uses continuation passing style, and Codensity just streamlines actions that use CPS
13:30:40 <Lokathor> what is that squigle equals
13:30:51 <ertes> Lokathor: "is isomorphic to"
13:31:04 <Lokathor> uhmmmmmm
13:31:13 <Lokathor> something-shaped
13:31:33 <ertes> Lokathor: for example you can also "register" actions that should run at the end of the Codensity:  Codensity (\k -> k () `finally` putStrLn "Ok, we're done. Bye!")
13:31:59 <Lokathor> but Control.Exception has finally
13:32:07 <Lokathor> so this is like finally, but fancier looking?
13:32:09 <ertes> yeah, that is Control.Exception's finally =)
13:32:49 <Lokathor> I never actually passed calculus, i just type letters and symbols until GHC says i can stop
13:32:51 <kuribas> Is testing each handle and object for a mouse hover a good strategy for a canvas, or should I use a space datatype?
13:32:56 <ertes> Lokathor: try this:  main = lowerCodensity $ do Codensity (\k -> k () `finally` putStrLn "Bye!"); liftIO (putStrLn "Hello!")
13:33:17 <Lokathor> hello, then bye?
13:33:18 <quuxman> I'm kind of fascinated why my last 1D rule stabilizes to Pi
13:33:32 <ertes> Lokathor: yeah
13:33:45 <Lokathor> so it's like registering a handler for later
13:33:47 <mohsen_> Doesn't "do" function make programming procedural in haskell?
13:33:47 <geekosaur> afaik the only relevant calculus here is lambda calculus, which is not what your average "calculus" course will teach you...
13:34:05 <ertes> Lokathor: for at the end
13:34:14 <geekosaur> mohsen_, not exactly. it simulates procedural programming, to an extent
13:34:24 <Lokathor> mohsen_, not really, the do is sugar over a compile transformation that maintains purity
13:34:25 <kuribas> mohsen_: do isn't a function, it's syntax.
13:34:39 <ertes> Lokathor: Codensity (\k -> …)  -- here k is the continuation…  the rest of the action after this particular one…  if you do something *after* k, then it happens after the rest of the Codensity action
13:34:43 <ertes> Lokathor: does that make sense?
13:34:44 <ij> So I heard that a module X.Y can be not only be named "X/Y.hs", but also "X.Y.hs". Should "X/Y.Z.hs" work though?
13:35:04 <Lokathor> geekosaur, I meant that in the general non-mathty that a person who hasn't even gone past calculus would refer to all math as being on some sort of absolute spectrum :3
13:35:13 <geekosaur> glwt :p
13:35:46 <ertes> Lokathor: read the first paragraph here: http://ertes.eu/tutorial/foldr.html
13:35:47 <ertes> =)
13:35:55 <kuribas> Say in a vector drawing app, would you test for mouse clicks against every object, or use a spatial tree to reduce testing?
13:35:57 <mohsen_> Is it not recommended to use "do"?
13:36:19 <kuribas> mohsen_: sometimes not using do results in more concise code.
13:36:23 <Lokathor> mohsen_, use do as often as you like. to the compiler it's the same
13:36:24 <quuxman> \ a b c -> let avg = (a + b + c) / 3 in avg + sin avg / 10
13:36:26 <kuribas> mohsen_: but do is generally safe.
13:36:39 <quuxman> how does that turn into Pi? Also 10 can be basically anything it seems like, experimenting with that
13:37:04 <kuribas> mohsen_: for example do a <- action; return (b a) == b <$> action
13:37:28 <kuribas> or "do a <- action; b a" == "action >>= b"
13:38:43 <Lokathor> ertes, i'm not saying i don't see the value, i'm just saying that a lot is going over my head; I guess my biggest question is "does this compile into faster code or not?"
13:38:48 <geekosaur> quuxman, welcome to the wonderful world of mathematical series
13:38:56 <Lokathor> otherwise it's kinda just a style thing
13:39:12 <ertes> Lokathor: this one is definitely a style thing
13:39:29 <ertes> Lokathor: although it might make your code go faster, because it associates all the (>>=) to the right
13:39:47 <quuxman> geekosaur: a better mathematician could figure it out fairly easily I imagine
13:39:54 <Lokathor> I was told that StateT in CPS is like 5% faster than normal StateT, that's the kind of fancy CPS I want to have.
13:40:13 <ertes> Lokathor: yeah, that's the kind of CPS that Codensity does, too
13:40:35 <ertes> Lokathor: but it only makes an asymptotic difference, if you have a bunch of left-associated (>>=)
13:41:04 <ertes> as could happen with loopy or conditiony things
13:41:06 <Lokathor> and state is left?
13:41:38 <ertes> Lokathor: as you probably know:  (c >>= f) >>= g = c >>= \x -> f x >>= g
13:41:56 <ertes> Lokathor: so the semantics of those two is the same by the monad associativity law
13:42:09 <ertes> but the latter has performance benefits
13:42:29 <Lokathor> whaaaa
13:42:59 <Lokathor> if the latter has performance gains, should't the compiler use laws to transform to that style more often?
13:43:22 <ertes> Lokathor: for most monads (>>=) needs the/a result of its first argument before it can even apply the function that is its second argument
13:43:30 <ertes> Lokathor: the compiler can't do that in general
13:44:01 <Lokathor> awh
13:44:04 <ertes> left-associated applications of (>>=) occur in the context of combinators, and the compiler can't just pre-evaluate
13:44:33 <ertes> that's where ContT/Codensity come in:  they *ensure* that all (>>=) in the underlying monad are right-associated
13:45:13 <Lokathor> hmm
13:45:26 <Lokathor> i'm afraid i'm a cargo culter too much of the time
13:45:34 <ij> Wasn't there something on /r/haskell recently about module X.Y being allowed to be named X.Y.hs?
13:45:37 <ertes> it probably won't give you a major speed boost with IO actions, but consider complicated list actions with recursion and guards
13:45:39 <ertes> or parsers
13:45:58 <randomnickname> ertes: hey
13:45:59 <hpc> i saw it on -cafe
13:46:05 <randomnickname> here's a cleaner example of the inconsistency
13:46:06 <randomnickname> http://lpaste.net/350468
13:46:15 <hpc> the conclusion ended up being it allowed ambiguous file names
13:46:22 <hpc> if X.Y.hs and X/Y.hs both exist
13:46:33 <ij> hpc, -cafe?
13:46:36 <Lokathor> the other day i managed to get a console to operate correctly in a multi-threaded way, so i might make a game using that, and it might need big lists of things
13:46:50 <geekosaur> ij, haskell-cafe mailing list
13:46:53 <ij> Ah.
13:47:01 <randomnickname> want me to trim that some more :p
13:47:17 <ij> So was that just rumors or is it an actual feature?
13:47:35 <ertes> randomnickname: it's not about length, but about single-lineness and forcing me to do type inference in my head =)
13:47:42 <randomnickname> ah lol
13:48:03 <ertes> randomnickname: of course giving relevant definitions a type signature could just solve your problem ;)
13:48:06 <geekosaur> it's a "feature". which is to say, many people consider it a bug because it means you can't be certain what happens if you have both, which complicates build systems
13:48:17 <randomnickname> heh
13:48:38 <geekosaur> "have both" both in the sense of your mixed form, and in the sense of "both files exist, which one wins?"
13:49:11 <geekosaur> (or, for your mixed example, there might be more than two candidate files for the module...)
13:51:38 <Wizek_> Hey! Does anyone know of a tool for haskell (may be online, may be local) that is able to take an expression as input and it could suggest refactored code as output that is simpler than the input, e.g. contains fewer symbols, while preserving type and functionality?
13:51:59 <hpc> like a linter?
13:52:13 <Wizek_> I'm looking for more than that
13:52:24 <hpc> so some sort of hypothetical golfer
13:52:27 <hpc> don't think it exists
13:52:37 <brennie> I mean, some linters will tell you how to write stuff in point-free I believe
13:53:21 <hpc> there's @pl in lambdabot, which will horribly inflate expressions
13:53:33 <hpc> @pl \a b c d e f g -> g e a d b c f f e g a
13:53:59 <hpc> that may have been just a smidge too terrible
13:54:01 <ij> geekosaur, What's it called, how do I google it?
13:54:02 <lambdabot> flip =<< ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((flip . ((flip . (ap .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . (liftM2 (flip . (
13:54:02 <lambdabot> flip .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip (flip .
13:54:06 <hpc> ah, there it is
13:54:08 <Nik05> ;p
13:54:21 <geekosaur> expression simplification is difficult even in a strict language. in a lazy one, there's added complications
13:54:32 <hpc> actually that's not well typed either probably, it applies g to g
13:54:35 <brennie> hpc: wha does @pl stand for? thats awful :)
13:54:56 <Lokathor> pointless :3
13:55:02 <brennie> :)
13:55:08 <Nik05> its pointless because it has a lot of points :P
13:55:12 <randomnickname> hpc: good lord
13:55:14 <Wizek_> hpc, Yes, I'm looking for something in similar spirit
13:55:14 <geekosaur> ij, https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125758.html is the start of the discussion thread
13:55:16 <randomnickname> that's terrifying
13:55:42 <Wizek_> hpc, but with a requirement that the output code I'd prefer to be simpler than the input
13:56:06 * randomnickname switches back to xa0
13:56:12 * xa0 is
13:56:27 <hpc> there's an issue with @pl where it doesn't properly typecheck expressions
13:56:29 <hpc> @pl \x -> x x
13:56:29 <lambdabot> join id
13:56:33 <hpc> :t join id
13:56:34 <lambdabot> error:
13:56:35 <lambdabot>     • Occurs check: cannot construct the infinite type: m ~ (->) (m a)
13:56:35 <lambdabot>       Expected type: m (m a)
13:56:44 <hpc> except it seemed to do fine there
13:56:59 <hpc> but you can contrive statements that are ridiculously huge and loop the simplifier
13:57:00 <Lokathor> :t \x -> x x
13:57:02 <lambdabot> error:
13:57:02 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
13:57:02 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
13:57:11 <Tuplanolla> I always fall for that manually, too.
13:57:17 <Lokathor> seems fine that pl gives you a garbage type if you give it a garbage type
13:57:37 <hpc> Lokathor: that part's fine, looping the simplifier is a bit less fine ;)
13:57:43 <Lokathor> oh no!
13:59:22 <mohsen_> I get a user input and put it in a variable by writing: "line <- getLine" how can I do the same but give the user input to a function?
13:59:54 <brennie> f line ?
14:00:16 <Wizek_> mohsen_, do { l <- getLine; fn l }
14:00:34 <mohsen_> Is there a way without "do"?
14:00:41 <Wizek_> mohsen_, sure:
14:00:46 <geekosaur> getLine >>= fn
14:01:01 <geekosaur> but, note that fn must produce a type IO ...
14:01:08 <hpc> mohsen_: to peek behind that curtain
14:01:10 <Wizek_> geekosaur, teamwork, highfive o/
14:01:17 <hpc> @undo do {l <- getLine; f l}
14:01:17 <lambdabot> getLine >>= \ l -> f l
14:01:33 <hpc> :t \f -> getLine >>= f
14:01:35 <lambdabot> (String -> IO b) -> IO b
14:01:43 <hpc> :t (>>=)
14:01:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:01:50 <mohsen_> It's not possible
14:02:01 <hpc> that is how you make your own do-notation, with Monad instances
14:02:25 <geekosaur> or to make that happen for a function not in IO:  fmap fn getLine        OR  fn <$> getLine
14:02:40 <mohsen_> It's not possible to go solo in haskell
14:02:51 <Wizek_> hpc, So if what I am looking for doesn't exist, I wonder how hard it could be to write something like that. Any guesses?
14:03:45 <mohsen_> I'm new to haskell, I'm a Java developer, using a new imprative language is way more simpler than a new functional
14:03:52 <hpc> Wizek_: start by figuring out exactly how you want to quantify "simpler" and figuring out what that means for a smaller version of the language with a few select symbols
14:03:59 <hpc> Wizek_: maybe x, y, f, g, (.), and ($)
14:04:06 <hpc> and parenthetization, ofc
14:04:08 <mohsen_> I easily switched between Java and C++, but it's not possible with haskell
14:04:38 <Wizek_> hpc, I would go with number of identifiers. That could be a simple way to measure simpleness I think.
14:05:21 <geekosaur> yes, Hava and C++ are much more closely related to each other than either is to Haskell
14:05:28 <geekosaur> *Java and
14:05:32 <ij> geekosaur, How do I make it work though? I hoped for a name to google and perhaps enable.
14:06:00 <geekosaur> ij, ? as far as I know that works now (but I don't know which compiler versions support it)
14:06:02 <hpc> mohsen_: they are similar enough languages that this is going to be your first significant change of style
14:06:07 <hpc> so it'll just naturally be difficult
14:06:12 <ij> I've 8.0.1.
14:06:39 <hpc> mohsen_: you're a bit lucky in that the design of haskell will stop you from falling into old habits better than most other languages
14:06:54 <hpc> so you'll be able to learn despite yourself
14:07:24 <geekosaur> ij, but I don't know if it supports the mixed style you asked about, and suspect it doesn't. and there are no options around this to change its behavior
14:07:25 <hpc> (it's extremely easy to follow bad habits without even knowing it)
14:07:28 <ij> geekosaur, http://vpaste.net/zDpmv
14:08:17 <hpc> mohsen_: haskell is definitely worth the effort though ;)
14:08:49 <geekosaur> ij, at this point I can only point you at #ghc. you seem to believe this is a feature that should be actively supported somehow, and I am pretty sure it is not (that is, it is accidental behavior falling out of something else)
14:09:34 <geekosaur> the only thing guaranteed to work is C/D.hs, the other might only work when compiling (ghc) instead of interpreting (runhaskell), or etc.
14:10:15 <ij> I was merely under the impression that it works.
14:10:54 <geekosaur> but you jumped from "works" to "people specifically maintain it and guarantee particular features from it"
14:11:21 <ij> This is the most basic version of works.
14:11:56 <ij> I'm assuming we're talking about the paste, right?
14:12:23 <geekosaur> I'm talking about the first message of the mailing list thread which did not say what circumstances it was found to work in
14:14:11 <mohsen_> hpc: I once tried to learn it by the book "Learn you a Haskell" but it was too extensive, isn't there a smaller book?
14:14:12 <ij> Ah.
14:14:38 <mohsen_> Sorry for the poor english 
14:14:58 <Tuplanolla> Extensive, mohsen_? LYaH is more like a tour than a textbook.
14:15:25 <mohsen_> Tuplanolla: You mean it's not that much extensive?
14:15:40 <mohsen_> But the number of chapters were too many
14:15:53 <geekosaur> in particular, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#haskell-source-files does not document that module to filename mapping
14:16:35 <Lokathor> mohsen_, I think they mean that Learn You A Haskell doesn't actually teach you much, and that there's a lot more to Haskell than it shows you
14:17:07 <geekosaur> no, it teaches you to read Haskell code, it doesn't help you *write* Haskell code
14:17:35 <Lokathor> well, that too
14:17:47 <geekosaur> for that, you need something additional, like a full set of exercises instead of the occasional one in LYAH
14:18:49 <mohsen_> geekosaur: Yes, that's what I was about to tell Lokathor, when you guys tried to tell me how to do that without "do", I didn't even know what you guys are talking about.
14:19:09 <mohsen_> were*
14:19:24 <mohsen_> I need to learn the syntax
14:20:00 <mohsen_> Through LYah?
14:20:21 <Lokathor> there's a few places where haskell allows two syntaxes and it converts one into the other as it reads in the file before it begins optimizations
14:20:26 <Lokathor> do and >>= are an example
14:21:34 <ertes> mohsen_: haskell actually has a really simple core syntax and then a whole tower of syntactic sugar to make practical things easier
14:22:03 <ertes> mohsen_: the important bits are things like functions and function application, pattern matching and data type definitions
14:24:58 <ertes> mohsen_: an important difference to keep in mind when reading/writing haskell code is that in function/value definitions "=" actually means "equals"…  this feature is often called "purity" or "referential transparency"
14:25:45 <mohsen_> ertes: I see.
14:26:46 <ppg> Hi all
14:26:55 <mohsen_> Okay guys, thank you all, I'm going to read LYaH to get started, see you at that time.
14:27:14 <Gurkenglas> Idea: For each monad m an indexed monad ContexedT m, newtype ContexedT m i j a = ContexedT { runContexedT :: (a -> m j) -> m i }, where ilift = ContexedT . (>>=), and which allows you to write "numberbetweenoneandfive <- ContexedT $ forM [1..5]" to get rid of nested forM do blocks, or in fact use any traversals to the right of that "ContexedT $"
14:29:10 <monochrom> Oh, LYAH again? It's a 2-hour movie trailer. :)
14:29:40 <NemesisD> what would be a good pattern for a fold which can add items to the structure its mapping over as it goes?
14:29:54 <monochrom> There is a chance http://www.happylearnhaskelltutorial.com/ is better than LYAH and being similarly gentle.
14:30:28 <ertes> > flip execState [] . flip runContT pure $ do x <- ContT (forM_ [0..5]); y <- ContT (forM_ [10,20]); modify ((x,y) :)
14:30:31 <lambdabot>  [(5,20),(5,10),(4,20),(4,10),(3,20),(3,10),(2,20),(2,10),(1,20),(1,10),(0,20...
14:30:35 <ertes> Gurkenglas: like this?
14:31:24 <ertes> ideally use Codensity, not ContT =)
14:32:40 <ertes> @let import Control.Monad.Codensity
14:32:42 <lambdabot>  Defined.
14:32:45 <ertes> uhhhhh!
14:32:59 <ertes> > flip execState [] . lowerCodensity $ do x <- Codensity (forM_ [0..5]); y <- Codensity (forM_ [10,20]); modify ((x,y) :)
14:33:01 <lambdabot>  error:
14:33:02 <lambdabot>      • Couldn't match type ‘b’ with ‘()’
14:33:02 <lambdabot>        ‘b’ is a rigid type variable bound by
14:33:12 <Gurkenglas> But forM, not forM_
14:33:25 <ertes> ah
14:34:26 <athan> NemesisD: Wait, folds collapse a structure, there's nothing left after :s
14:34:32 <athan> @type fold
14:34:34 <lambdabot> (Monoid m, Foldable t) => t m -> m
14:34:57 <ertes> NemesisD: foldr seems fine?
14:35:13 <ertes> NemesisD: or more generally catamorphisms
14:35:52 <NemesisD> ertes: but i don't see how foldr could add elements to the structure of the thing you're folding over (e.g. a list)
14:36:01 <ertes> > foldr (\x xs -> x : if null xs then xs else ',' : xs) [] "abcde"
14:36:06 <lambdabot>  "a,b,c,d,e"
14:38:27 <Guest14407> hello
14:38:35 <ertes> NemesisD: would you consider this "adding"?
14:38:39 <ertes> hi Guest14407 
14:39:22 <NemesisD> ertes: no. i'm doing a monadic fold over a list of items and i'm allowing for the concept of "do it later" which takes the current item and appends it to the end of the list to do last
14:39:35 <Guest14407> I am playing around with trying to make a functor definition of the composition of 2 functors
14:39:43 <NemesisD> ertes: my plan so far is StateT and explicit recursion
14:39:56 <ertes> NemesisD: foldr can express that
14:40:05 <Guest14407> so something like instance (Functor f, Functor g) => Functor (Compose f g) where     fmap = fmap.fmap
14:40:15 <ertes> NemesisD: http://ertes.eu/tutorial/foldr.html#stateful-folds
14:41:00 <Guest14407> but you can't write Compose f g because you can't do something like (\x -> g (f x)) at the type level
14:41:40 <Guest14407> and trying to write the definition as: type family Compose f g a where     Compose f g a = g (f a)
14:42:02 <Guest14407> causes the error : Illegal type synonym family application in instance: Compose f g
14:42:12 <Guest14407> not sure how to solve this or if it's even solvable
14:42:14 <ertes> Guest14407: Compose must be a newtype
14:42:18 <Guest14407> yes
14:42:27 <Guest14407> i can wrap it in a newtype
14:42:28 <ertes> Guest14407: partial application is not allowed for type synonyms
14:42:39 <Guest14407> even type families?
14:42:43 <ertes> yes
14:42:59 <ertes> your type family is really just a type synonym in disguise
14:43:26 <Guest14407> it is cause I really wanted to work around it
14:44:00 <Guest14407> and partial type applications are not allowed
14:44:09 <ertes> there is no workaround, because partial application would make instance resolution undecidable and could introduce some really weird overlaps
14:44:25 <Guest14407> I see
14:44:53 <ertes> consider this:  type Flip f x y = f y x
14:45:07 <ertes> instance C (Flip (->))
14:45:44 <Guest14407> but if I could just get it to work things like fmap (+2) [Just [Just 2,Nothing], Nothing] would work beautifully 
14:46:41 <Guest14407> hmmm
14:48:05 <ertes> unfortunately that requires type-level computation
14:48:20 <Guest14407> which could be undecidable 
14:48:33 <Guest14407> I understand but why isn't there some haskell extension
14:48:41 <Guest14407> that allows me to do this at my own risk
14:48:42 <Gurkenglas> :exf "(((a -> b) -> m j) -> m i) -> ((a -> m k) -> m j) -> ((b -> m k) -> m i)" -- (regards to earlier) aaaaaa im not actualy using Monad m wat is this sorcery
14:48:43 <exferenceBot> \ f1 f2 f3 -> f1 (\ f6 -> f2 (f3 . f6))
14:48:57 <ertes> Guest14407: you mean like -XDependentTypes? =)
14:49:17 <ertes> Guest14407: ask again in 5-10 years =)
14:49:32 <Guest14407> ha
14:49:35 <Guest14407> I wish
14:50:05 <Guest14407> hopefully dependent types would be well made by then
14:50:13 <Guest14407> in haskell
14:50:46 <Guest14407> I am considering learning idris as the whole dependent type thing seems very interesting 
14:52:22 <athan> idris is awesome
14:52:28 <athan> so is agda and coq
14:52:34 <athan> and cryptol :)
14:52:34 <Guest14407> but are they useful?
14:52:39 <maerwald> Guest14407: and introduces another layer of complexity and reasoning
14:52:44 <athan> I think so, crucially semantically
14:52:51 <athan> maybe not in industry
14:52:53 <Guest14407> as in can I write a program that actually does things
14:53:04 <athan> technically lol
14:53:12 <Guest14407> efficiently
14:53:18 <maerwald> no
14:53:22 <maerwald> the ecosystem is missing
14:53:23 <Guest14407> I mean can I write it efficiently
14:53:43 <athan> oh you mean rapid development? I think so
14:53:49 <ertes> Guest14407: i use agda, but for theorem proving, not programming
14:53:51 <athan> in my opinion you can
14:54:20 <ShalokShalom> http://leftoversalad.com/c/015_programmingpeople/
14:54:34 <ertes> Guest14407: i wouldn't use it for programming though
14:54:42 <ertes> idris is probably much better suited for that
14:54:50 <Guest14407> idris aims to be useful no?
14:54:55 <Guest14407> as a programming language
14:55:16 <Guest14407> agda aims to be a theorem prover
14:55:28 <ertes> but "much better" doesn't mean "good"…  it means that it's developed with programming in mind, and as such has syntactic sugar, proper type classes, etc.
14:55:44 <ertes> but it's still in its infancy when it comes to solving real problems in production
14:55:46 <athan> what's the difference? :v
14:57:18 <ertes> Guest14407: remember when you tried to use haskell ~15 years ago?  almost no libraries, very basic ecosystem, only a small group of users mostly from academia
14:57:25 <ertes> Guest14407: idris is like that right now =)
14:57:33 <ertes> in other words: give it another 10 years =)
14:57:39 <Guest14407> I started learning haskell 1 year ago 
14:57:40 <Guest14407> :p
14:57:45 <ertes> or become an active developer and speed it up by a few months
14:58:25 <Guest14407> but I love it
14:59:38 <ertes> well, idris is written in haskell…  become a developer and get the best of both worlds =)
15:00:15 <Guest41038> ?
15:01:40 <maerwald> "become a compiler developer"... very useful suggestion :P
15:02:31 <Gurkenglas> http://lpaste.net/350469 it all fits, but the flippity
15:03:15 <quuxman> I have a function: processArgs :: [String] -> IO (Int, Int, [Double]) -- and I want to print a catch-all error and usage message if it fails. What's a more elegant way of doing this than a complex case statement with a bunch of pattern matching?
15:04:09 <Gurkenglas> Well, when does it fail?
15:04:57 <Gurkenglas> Maybe you want http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception-Base.html#v:catch ?
15:04:58 <quuxman> well if the first two elements of [String] aren't read as Ints, and the rest aren't read as doubles
15:05:23 <quuxman> that's what I was thinking, I haven't used Control.Exception much
15:06:03 <Gurkenglas> quuxman, you could use readMay and the Maybe monad, or try try
15:06:43 <quuxman> ok I've never used Control.Exception I don't think. Why are they in the IO monad, instead of something more specific?
15:06:45 <monochrom> quuxman: use a library, "options" or "optparse-applicative"
15:07:02 <quuxman> monochrom: that's the sane answer, I was kinda trying to understand exceptions
15:07:28 <athan> quuxman: exceptions are very anti-haskell-y
15:07:29 <monochrom> for exceptions read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
15:07:40 <monochrom> No, exceptions are not anti-haskell-y.
15:07:42 <RoxxikM> Hey compiling cabal with cabal currently and saw that ghc seems to leak subprocess handles, don't know whether this is a known problem (there are a lot of llc zobies below ghc on my ps tree)
15:07:47 <athan> but they help for a lot of real world issues, like signal interrupts, and stuff liek that
15:07:57 <athan> there's a heirarchy of monormorphic exception types
15:08:05 <monochrom> Exceptions inside IO are Haskell-y. Exception outside IO are not. That's all.
15:08:10 <athan> SomeException will catch any exception, for instance, if you hardcode to that type
15:08:52 <athan> co-haskell maybe? :p
15:09:05 <monochrom> However, for parsing getArgs stuff and printing help messages, you need not go through exceptions (or even IO, apart from getArgs and putStrLn)
15:09:20 <monochrom> No, fearmongering about exception is simply wrong.
15:09:43 <athan> I'm not trying to fearmonger lol, just trying to paint a picture for expectations
15:10:01 <monochrom> But your picture is fearmongering.
15:10:04 <athan> *meta eyeroll*
15:10:28 <Gurkenglas> (It's the thing that eyerolls are a metaphor for.)
15:10:54 <nshepperd1> Catching exceptions outside IO is anti haskelly and evil imo
15:11:09 <monochrom> Yes sure.
15:11:10 <quuxman> disappointing that options isn't in the main lib
15:11:26 <ertes> quuxman: "main"?
15:11:46 <quuxman> I mean the standard modules that come with ghc
15:11:54 <quuxman> I'd expect it to be in System.Environment or something
15:11:59 <ertes> well, there is System.Console.GetOpt, but it's terrible
15:12:40 <ertes> it can't even handle failure to parse option arguments
15:12:47 <geekosaur> ghc has annoying behaviors with respect to module versioning, which make it a good idea to unbundle as much as possible from the compiler
15:13:15 <geekosaur> so most of the "good stuff" does *not* come with it, and the devs are always looking for ways to unbundle even more stuff
15:14:07 <ertes> quuxman: while i'd generally advocate the use of options/optparse-applicative, the way i see it you're really just parsing a fixed bunch of mandatory command line arguments (non-options)
15:14:14 <geekosaur> (basically, if something is bundled with ghc, there is a risk that using a different version from the bundled one will get you into trouble)
15:14:47 <ertes> quuxman: if that's the case either of them may overcomplicate things, and you should perhaps just use readMaybe
15:16:02 <kuribas> I believe haskell-platform comes with more packages.
15:16:34 <ertes> quuxman: if you still want to use a real parser, in this case i'd suggest optparse-applicative, because it lets you just parse into a tuple
15:16:40 <monochrom> yes but it still doesn't include options
15:17:56 <quuxman> ertes: yeah arguments is either 1 integer, 2 integers, or 2 integers and X doubles. I think I want a series of readMaybes with a common fail call... 
15:18:58 <quuxman> uh, @hoogle readMaybe
15:19:01 <ertes> quuxman: oh, that looks more complicated…  ok, i'd go with options/optparse-applicative
15:20:04 <quuxman> wow, there's applicative, declarative, and simple. hmmm
15:20:39 <Gurkenglas> Oh hey, Ekmett already wrote my idea 8 years ago it looks like. http://hackage.haskell.org/package/indexed-extras-0.2/docs/Control-Monad-Indexed-Cont.html
15:24:38 <geekosaur> "surprise"
15:26:08 <ertes> quuxman: https://gist.github.com/esoeylemez/f5ed2beab4fde3808e945b28848cc8d9
15:26:30 <Gurkenglas> Which line on https://github.com/reinerp/indexed-extras/blob/master/Control/Monad/Indexed/Cont.hs would I PR-add "descend :: Lenslike f s t a b -> s -> IxContT f t b a" to?
15:27:12 <ertes> quuxman: wait, no
15:27:15 <ertes> that doesn't work
15:28:40 <ertes> actually optparse-applicative doesn't seem to support this use case, except with a rather ugly hack
15:29:34 <ertes> hmm…  is there really no "try" for optparse-applicative's Parser?
15:30:15 <monochrom> it doesn't need "try" does it? it just needs MonadPlus, and I think it already is.
15:30:17 <lpaste> quuxman pasted “option parsing dilema” at http://lpaste.net/350471
15:30:45 <ertes> monochrom: with the parser in the gist "program 5" doesn't work
15:30:54 <ertes> the first parser just fails, and then everything fails
15:31:09 <ertes> monochrom: (and it definitely has no MonadPlus, because it's not a Monad)
15:31:57 <monochrom> Alternative!
15:32:54 <lpaste> quuxman revised “option parsing dilema”: “option parsing dilema” at http://lpaste.net/350471
15:32:59 <ertes> it has a special subcommand combinator that, i assume, does something akin to 'try'
15:33:05 <ertes> but it insists on…  well…  subcommands
15:34:11 <ertes> quuxman: note that Maybe is a monad
15:34:27 <ertes> > do x <- Just 3; y <- Just 5; pure (x, y)
15:34:31 <lambdabot>  Just (3,5)
15:34:36 <lpaste> quuxman revised “option parsing dilema”: “option parsing dilema” at http://lpaste.net/350471
15:34:50 <quuxman> I can barely understand my old version
15:35:35 <quuxman> I wrote it years ago and it doesn't look sane to my current programming sensibilities
15:37:06 <Nik05> @bot
15:37:06 <lambdabot> :)
15:37:18 <quuxman> I feel like I should be able to make a really simple do block in the Maybe monad that's Just (Int, Int, [Double]) or calls usage for Nothing
15:39:37 <Eduard_Munteanu> You can.
15:39:57 <quuxman> Eduard_Munteanu: but how do I stack the failure case in the monad along with the values I'm parsing?
15:41:19 <ertes> quuxman: here is a raw version (no library) using readMaybe: https://gist.github.com/esoeylemez/d54bdf227ee26a0f78e3f2fde6cb4433
15:41:50 <Eduard_Munteanu> rule <- readMaybe ruleArg; seed <- readMaybe seedArg; guard (0 <= rule); guard (rule <= 5); return (rule, seed)
15:42:34 <ertes> quuxman: toOptions does the magic
15:42:56 <monochrom> @type sequence
15:42:57 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:43:03 <monochrom> @type mapM
15:43:05 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:43:22 <monochrom> @type traverse
15:43:23 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:43:36 <ertes> yeah, the code uses 'traverse'
15:43:42 <ertes> line 19
15:43:53 <quuxman> I'm happy with monads, but still baffled by <*> <$>
15:44:17 <monochrom> oh you're happier with Monad? I'll do Monad then.
15:44:19 <ertes> quuxman: do you understand their types?
15:44:21 <kuribas> quuxman: <$> is fmap or liftM
15:44:28 <monochrom> But you only need Applicative
15:44:48 <kuribas> quuxman: <*> can replace liftM2, liftM3, etc...
15:45:03 <ertes> quuxman: (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b  -- just reading the type can you guess what this function does?
15:46:09 <quuxman> but the actual type is (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:46:22 <ertes> quuxman: yes, but look at the f = Maybe
15:46:23 <ertes> case
15:46:27 <lpaste> monochrom pasted “maybe doable” at http://lpaste.net/350474
15:46:31 <monochrom> that
15:47:03 <monochrom> oh oops you want Monad, I should use mapM instead of traverse
15:47:06 <ertes> quuxman: what monochrom just pasted is equivalent to mine (apart from the type error)
15:47:08 <Gurkenglas> monochrom, "Right"?
15:47:09 <monochrom> but same difference
15:47:17 <quuxman> ertes: ok in that case I would guess that it returns Nothing if first or second arg is Nothing, and otherwise returns a b
15:47:28 <monochrom> Oh, delete "Right", I couldn't make up my mind
15:47:30 <quuxman> I mean returns type b
15:47:34 <quuxman> the application of the first argument
15:47:39 <ertes> quuxman: Just f <*> Just x = ?
15:47:44 <lpaste> monochrom revised “maybe doable”: “maybe doable” at http://lpaste.net/350474
15:47:48 <monochrom> fixed
15:48:36 <quuxman> ertes: I like that. Very understandable
15:48:49 <kuribas> monochrom: I don't like returning undefined...
15:48:55 <ertes> quuxman: now imagine:  f :: A -> B -> C, x :: A
15:49:01 <quuxman> sort of. I don't really understand the lifting between list monand and maybe
15:49:11 <ertes> quuxman: what's the type of (Just f <*> Just x)?
15:49:13 <monochrom> yes kuribas I'm sure quuxman knows how to fix it
15:50:04 <kuribas> monochrom: ah I see.
15:50:48 <kuribas> quuxman: which list monad?
15:50:56 <shapr> My Haskillz have improved much during advent of code
15:51:04 --- mode: shapr set -o shapr
15:51:21 <quuxman> oh nevermind, it's just a Maybe monad with list pattern matching
15:52:08 <quuxman> traverse is similar to fold, but generalized?
15:52:16 <monochrom> traverse is mapM
15:52:40 <shapr> @deech got me interested in learning lens, then gabriel gonzalez pointed me to his lens tutorial, and five minutes later I'm using lens.
15:52:40 <lambdabot> Unknown command, try @list
15:52:42 <shapr> whoops
15:53:10 <ertes> > traverse readMaybe ["13.5", "17"] :: Maybe [Double]
15:53:14 <lambdabot>  error:
15:53:14 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Double
15:53:21 <ertes> @let import Text.Read
15:53:23 <lambdabot>  Defined.
15:53:24 <ertes> > traverse readMaybe ["13.5", "17"] :: Maybe [Double]
15:53:27 <lambdabot>  Just [13.5,17.0]
15:53:33 <ertes> > traverse readMaybe ["13.5", "blah"] :: Maybe [Double]
15:53:35 <lambdabot>  Nothing
15:53:58 <xa0> Hey #haskell, show me the doubtless better way of doing this: 
15:54:05 <xa0> > let (<&>) = (\i -> (($ pure []) . foldr . (((asum .) . fmap) .)) (\b a -> fmap (pure b <|>) $ if null a then pure mempty else fmap (($ a) . (<|>) . pure) i)) in [1,2,3] <&> [9,8,7]
15:54:07 <lambdabot>  [[9,1,8,1,7],[9,2,8,1,7],[9,3,8,1,7],[9,1,8,2,7],[9,2,8,2,7],[9,3,8,2,7],[9,...
15:54:28 <monochrom> edkmett is so massive, he causes gravitational lensing :)
15:54:29 <shapr> xa0: what is that trying to do?
15:54:37 <kuribas> mconcat $ map readMaybe ["13.5", "blah"]
15:54:47 <xa0> Intersperse, but ..Kinda across the list monad
15:55:20 <shapr> After reading this, I don't know why I ever thought lens was scary: https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html
15:56:16 <monochrom> [[9, x, 8, y, 7] | y <- [1..], x <- [1,2,3]]
15:56:52 <int-e> > let a <&> b = sequence $ intersperse a (map (:[]) b) in [1,2,3] <&> [9,8,7] -- not the same order
15:56:58 <lambdabot>  [[9,1,8,1,7],[9,1,8,2,7],[9,1,8,3,7],[9,2,8,1,7],[9,2,8,2,7],[9,2,8,3,7],[9,...
15:57:08 <kuribas> xa0: heh, I needed an interleave function in my code recently.
15:57:25 <quuxman> kuribas: I don't understand why that doesn't work
15:57:42 <xa0> int-e: ..Ooh you bastard
15:57:46 <quuxman> > mconcat $ map readMaybe ["13.5", "10"] :: Maybe [Double]
15:57:51 <lambdabot>  Nothing
15:57:58 <kuribas> quuxman: never mind that
15:58:25 <monochrom> @type mconcat
15:58:26 <lambdabot> Monoid a => [a] -> a
15:58:31 <xa0> int-e: (thanks :p)
15:58:35 <kuribas> > mapMaybe readMaybe ["13.5", "blah"]
15:58:37 <lambdabot>  []
15:58:47 <kuribas> > mapMaybe readMaybe ["13.5", "blah"] :: [Double]
15:58:50 <lambdabot>  [13.5]
15:59:32 <ertes> xa0: you could change that lucifomorphism to a malmorphism by realising that ((asum .) . fmap) is just a contravariant functor from Hask to Hell
15:59:54 <monochrom> ...
16:00:10 <xa0> ertes: ahahaha
16:00:11 <shapr> ertes: quotable
16:00:19 <kuribas> :t intersperse
16:00:21 <lambdabot> a -> [a] -> [a]
16:00:22 <quuxman> kuribas: that's a interesting and useful construction, just not in my case because I want Nothing to propagate  instead of being removed
16:00:33 <kuribas> quuxman: yes
16:00:51 <quuxman> ertes' code seems pretty ideal
16:02:51 <quuxman> but I wouldn't have come up with it because I didn't know of traverse and I wouldn't have thought of combining a list pattern match with a Maybe do like that
16:03:44 <kuribas> quuxman: it takes time to get used to haskell idioms.
16:03:58 <shapr> quuxman: this is a good place to learn those idioms!
16:06:00 <kuribas> Is monadplus different from alternative?
16:08:10 <Eduard_Munteanu> kuribas, different typeclass, but same idea
16:08:20 <Eduard_Munteanu> One is for Applicative, the other for Monad.
16:08:36 <kuribas> I see
16:09:08 <shapr> Oh, someone sent me a Haskell t-shirt for Christmas. But I don't know who! https://twitter.com/shapr/status/812857466132267008
16:10:42 <systemfault> Could be a Half-Life loving troll :P
16:11:34 <ertes> kuribas: MonadPlus has stronger laws
16:11:37 <lpaste> quuxman revised “option parsing dilema”: “option parsing dilema” at http://lpaste.net/350471
16:12:14 <quuxman> My only niggling concern here is the case statement in processArgs is verbose, but I can't think of any std function to replace it
16:12:58 <ertes> quuxman: that's exactly why i pointed out that Maybe is a monad
16:13:29 <ertes> quuxman: oh, i misread your code
16:13:37 <ertes> quuxman: the 'maybe' function does that
16:13:50 <ertes> quuxman: see the 'main' action in my example
16:14:31 <kuribas> quuxman: that looks fine
16:14:46 <kuribas> :t maybe
16:14:48 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:15:03 <ertes> maybe (getProgName >>= putStrLn . usage) mainWith  -- this function takes a (Maybe Options), and if it's Nothing, prints usage, otherwise does mainWith the Options
16:15:11 <lpaste> quuxman annotated “continuous 1d cellular automata” with “new version with rule arguments (experiment with magic pi rule 5)” at http://lpaste.net/350455#a350477
16:16:12 <xa0> int-e: I just worked out how that works, you're ..smart
16:16:19 <quuxman> this is definitely my favorite Haskell program I've written :). I want to make a GUI version where you just enter in the Rule funcs
16:16:42 <xa0> Or maybe I just haven't been exposed to sequence enough
16:16:50 <kuribas> quuxman: or: "processArgs args = maybe usage return $ parseArgs args
16:17:30 <kuribas> quuxman: even though that's mildly obfuscated.
16:18:35 <zq> what's that trick to print out the type at an inner location with '?'?
16:19:21 <Eduard_Munteanu> Any GUI libs emerged recently, that'd make a better choice than gtk2hs?
16:19:34 <kuribas> Eduard_Munteanu: there's wxHaskell
16:20:00 <kuribas> Eduard_Munteanu: which is only better if you need native look on windows and mac.
16:20:39 <quuxman> speaking of gui libs, I'd love a less complex option than opengl to make an infinitely scrolling image that's added to one line at a time
16:22:56 <Eduard_Munteanu> Nice. A few years ago, gtk2hs seemed to be better maintained than wxHaskell, not sure right now.
16:23:12 <quuxman> also the way I figured out how to implement it in OpenGL limits me to widths in powers of 2. I didn't bother writing code to chop the texture off, so I just hardcoded it to 512 pixels wide :-/
16:24:26 * geekosaur doesn't think wxHaskell looks very maintained
16:24:34 <kuribas> Eduard_Munteanu: I don't think anything happend the last months.  And many widgets aren't supported yet (like wxDataView).
16:26:15 <quuxman> Are there any graphics libs that let you easily turn a [[Double]] into a texture, then tile and slide these in 1 dimension?
16:29:23 <Eduard_Munteanu> I'm seriously considering having a go at a structural editor for Haskell, along with a binary representation for source code.
16:29:57 <quuxman> structural editor cood be cool, but I'd skip the binary representation
16:30:20 <quuxman> maybe have it cache a bunch of metadata in an Sqlite DB or something like that
16:30:47 <Eduard_Munteanu> The nice thing about a binary representation is that it may loosen restrictions on naming things.
16:30:54 <quuxman> and then you could have a plain text serialization of that perhaps for grep and other stream based tools
16:31:34 <quuxman> Haskell supports Unicode, what kind of restrictions are concerned about??
16:31:56 <ertes> Eduard_Munteanu: take inspiration from structured-haskell-mode for emacs (itself inspired by paredit)
16:32:02 <Eduard_Munteanu> Well, names are still used to distinguish types from terms and a lot of other things.
16:32:05 <monochrom> the nice thing about binary representation is that ASCII is binary too :)
16:32:25 <geekosaur> quuxman, things like uppercase needed to distinguish constructors from bindings in patterns?
16:32:31 <quuxman> a normalized plain text representation of the DB would be great for version control too, for any metadata that couldn't fit into the Haskell source, though you could always use specially formatted comments of course
16:33:32 <quuxman> Just create a plain text meta data format. Plain text is incredibly valuable for version contral and all the other source tools out there
16:33:33 <Eduard_Munteanu> For instance, the compiler shouldn't care if you pass it a lower case type constructor as long as it knows it's a type constructor and not a type variable.
16:33:58 <quuxman> right. the editor would just use the name from metadata, and in the source it would have a generated name
16:35:10 <quuxman> basically I guess I'm counter-proposing simply making very simple superset of Haskell that compiles to HS and talks to ghci in the editor environment
16:37:19 <quuxman> I've thought a lot about structured editors and used a handful (that I've hated). I think the closest you can make it behave like text the better, but things like column select would use the syntax tree, for example. And there's this really huge and exciting domain of features for auto-completion and search
16:37:46 <Eduard_Munteanu> I find it a bit odd we're still specifying languages in terms of a concrete syntax in 2016-2017.
16:38:07 <Gurkenglas> What does (forall f. Monad m => LensLike f s t a b) look like, when compared to Traversal s t a b?
16:38:26 <Zemyla> Gurkenglas: Where is the m?
16:38:33 <Gurkenglas> -m+f, right
16:38:47 <quuxman> I'm really excited about tab-complete and search features that use runtime information (like a database representation of profiling info, so you can navigate by the most common call stack)
16:39:39 <Zemyla> Gurkenglas: I'm not sure. It probably could be almost anything.
16:39:53 <quuxman> like there should be a navigate key that cycles through all the functions that are most often called by current function, and all the functions that most often call the current
16:40:11 <Eduard_Munteanu> quuxman, not just that... it seems there's a huge disconnect between compiler and editors. The compiler should be the authoritative source for any code analysis, but many tools resort to less principled ways of parsing code.
16:41:13 <quuxman> Eduard_Munteanu: yeah, but editors are big and complex and people have different preferences, and compilers are big and complex and you often use more than one in a project. The prospect of integrating them is... daunting. But I agree there should be sophisticated standards for compilers and interpreters to integrate with editors
16:41:23 <quuxman> But I don't see any problem with a concrete syntax
16:42:40 <Gurkenglas> Writing on https://github.com/reinerp/indexed-extras/edit/master/Control/Monad/Indexed/Cont.hs . How do I check what the doc would look like before making a PR?
16:42:42 <quuxman> Though I do think there should be structured ways to add editing tools alongside the source code
16:42:44 <Eduard_Munteanu> For one thing, it's unnecessarily complex. It's much easier to specify and work with abstract syntax.
16:43:37 <geekosaur> Gurkenglas, providing you have already forked it and set up a build env, cabal/stack haddock?
16:43:38 <quuxman> Eduard_Munteanu: definitely easier to work with trees. There should be one chunk of code that turns the concrete syntax into a tree, and that should be called on by the editor and interpreter
16:44:33 <ppg> Greetings haskellers, quick question.  
16:44:39 <quuxman> but that turns into a major problem if the editor and interpreter are implemented in different languages. You need a consistent in-memory representation, which is exactly what a parser does
16:44:52 <AndreasK> I think the core of the issue is that as you increase complexity of representation the higher to risk that the representation will suck.
16:45:13 <quuxman> but editors should easily be able to get a FFI to the interpreter to get the code in memory
16:45:23 <Gurkenglas> Hmm. Any way that uses only the browser? Surely there's some online haddock compiler.
16:45:53 <ppg> Suppose I have a function connect :: Vertex -> Vertex -> Graph -> Graph.  And I want to do something like  "zipWith f newVertices (tail cycle newVertices)  where f a b = connect a b ChangingGraph."
16:46:21 <ppg> Where ChangingGraph changes as the zip goes along
16:46:34 <ppg> Should I use the State monad or something?
16:46:37 <Eduard_Munteanu> quuxman, true, but you don't need to parse from human-readable form all the time. There are easier ways to represent an AST in binary form.
16:46:43 <geekosaur> Gurkenglas, only one I know of is submit it to hackage and let its doc builder have at it. otherwise there's quite a few complications; haddock is not just markup
16:47:48 <geekosaur> does "what the doc would look like" include how it makes types look? which requires potentially building or at least referencing a database of more stuff than just that one page
16:47:58 <quuxman> Eduard_Munteanu: for sure. Maybe the best solution is to have a binary representation that both the interpreter and editor can use
16:48:21 <quuxman> Eduard_Munteanu: but in that case you'd have to not only build a whole new editor, but also hack ghc itself
16:48:54 <geekosaur> this is starting to sound like the old integrated smalltalk dev environments
16:49:28 <quuxman> geekosaur: which have some excellent aspects to them. The thing I always hated about smalltalk is the editor is pathetic in comparison to vim and standard Linux command line tools
16:49:41 <geekosaur> and that would indeed be the weakness
16:50:15 <AndreasK> ppg: Isn't that basically a fold? But it's late so I might be wrong
16:50:29 <quuxman> yeah, which is why I was advocating having a plain text concrete representation of whatever superset Eduard_Munteanu was imagining
16:51:38 <Eduard_Munteanu> Well, obviously you still need a parser/pretty-printer from/to concrete syntax for some cases.
16:51:48 <quuxman> If you make the structured editor behave very similarly to vim, and have a plain-text version of all the metadata so you can still use your favorite command-line tools, seems like you could get the best of both
16:52:01 <Eduard_Munteanu> a + b is painful to input in a completely abstract form.
16:52:39 <Gurkenglas> Is there a lenslike with a simple type signature?
16:53:37 <quuxman> another thing I've been thinking about recently is an interactive visual debugging tool that communicates with a profiling version of your code as you edit it
16:53:51 <ppg> AndreasK You're right!
16:53:54 <ppg> Thans
16:53:56 <ppg> Thanks*
16:54:34 <AndreasK> ppg: foldl (\g (v1, v2) -> connect v1 v2 g) emptyGraph $ zip newVertices (tail cycle newVertices) I guess (didn't test it though)
17:01:10 <quuxman> by visual debugger, I'm imagining using bits of your existing code along with custom debugging tools to show your data structures graphically instead of textual, and being able to see these at breakpoints. There are so many awesome innovations for debuggers....
17:02:16 <Tyg13> how we doin tonight ladies and gentlemonads?
17:02:43 <quuxman> Like setting a "non breaking" conditional break point while running your code, and then being able to query the sum of all the stack traces from them later
17:04:01 <quuxman> say you're trying to debug a deeply nested loop or recursive function. You create a conditional that narrows it down to a sane amount of data, then dig into it. Instead of painstakingly stepping into and out of your code 100 times
17:04:08 --- mode: ChanServ set +o glguy
17:04:08 --- mode: glguy set -bo *!*@unaffiliated/octagonfly glguy
17:04:34 <Tyg13> there's a debugger for haskell?
17:05:20 <quuxman> I'm just talking about theoretical code tools. I don't actually know of a way to interactively debug haskell :-[
17:05:28 <ludat> hi everyone, I am having a hard time understanding cabal files, I wanted to have a library section with nothing but my domain and an executable section that requires snap to be a http server 
17:06:05 <ludat> but when testing I can't import Site from the executable package, is it expected?
17:06:16 <Tyg13> what's your specific error?
17:06:18 --- mode: ChanServ set +o glguy
17:06:19 --- mode: glguy set -bbbo Halite*!*@* $a:Halite $a:HaliteBird glguy
17:06:45 <ludat> just `Couldn't find module Site`
17:07:00 <Tyg13> are you using cabal or stack?
17:07:46 <ludat> stack
17:08:02 <ludat> this is the cabal file http://lpaste.net/350479
17:08:53 <Tyg13> in your lib file, it looks like you're exporting the module Ganancias
17:09:25 <Tyg13> I don't see you exporting Site anywhere
17:09:53 <ludat> because Site doesn't belong to ganancias, it lives in backend
17:10:36 <ludat> my reasoning was that my domain live in the library and the http server lives in an executable
17:10:41 <Tyg13> Forgive me, because I'm a bit new with this myself, but wouldn't you need to expose Site as a module
17:11:39 <ludat> http://lpaste.net/350479#line24
17:12:46 <quuxman> Tyg13: you can set breakpoints in ghci, I've just never bothered to do it. Honestly once my code compiles it's so close to working that it's been easier for me to throw in a print statement or equivalent so far. With Haskell the major battle is usually getting the types of my code to match the types of the libs I'm using
17:13:19 <riaqn> Hello, in Control.Exception, is the handler passed to `catch` garanteed not to be interrupted by another exception?
17:14:03 <Tyg13> ludat: I think you know more about cabal than I do, heh
17:14:40 <Tyg13> quuxman: I've used them before, but never really found them useful.
17:14:52 <Tyg13> You're right that once you've made it past the compiler, the issue is almost never at run-time
17:15:16 <ludat> Tyg13: hehe, no problem I think I found the problem, I think I should be using more than one cabal to do the thing I want to do
17:16:17 <glguy> riaqn: It's guaranteed not to be interrupted unless you block inside the handler
17:16:29 <quuxman> did anybody check out my cellular thingy? Any input on the feasibility of porting this to ghcjs?
17:16:36 <riaqn> glguy: great! I see.
17:17:00 <riaqn> glguy: there 's a implied mask around handler in catch.
17:17:51 <riaqn> wait, so killThread is blocking, right?
17:18:13 <riaqn> means I have to wrap maskUninterruptable around it. hmm. 
17:18:34 <Tyg13> quuxman: link?
17:18:53 <quuxman> Tyg13: http://lpaste.net/350455
17:19:06 <Tyg13> I can't wait to actually produce functioning, useful code
17:19:36 <systemfault> Tyg13: I can feel your pain.
17:20:30 <Tyg13> so far I've mostly been wrestling with linking libraries and getting distracted by pretty Haskell features
17:21:30 <quuxman> Tyg13: if you get it to compile, rule 4 is my favorite, but the magic pi rule is pretty cool mathematically, but visually boring
17:22:20 <quuxman> I think the only dependency that's not in standard ghc distirbution is opengl package
17:47:52 <mpcsh> hey guys, I'm self-learning haskell from a scheme (specifically typed racket) perspective, got a few questions. first, how do I create union types? i.e. in racket: (define-type Shape (U Square Circle))
17:48:54 <riaqn> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/System.Timeout.html#timeout 
17:49:09 <riaqn> ^ can anyone explain to me why we need the case for bound threads?
17:49:19 <riaqn> only for performance? or correctness?
17:50:39 <c_wraith> riaqn: that's specifically bound threads on windows
17:51:06 <c_wraith> riaqn: looks like it's a way of detecting whether the program was compiled with the threaded runtime or not
17:51:13 <c_wraith> riaqn: in which case it's a correctness thing
17:52:05 <geekosaur> it's ifndef not ifdef
17:52:07 <riaqn> c_wraith: for me it looks like, we have threadedRTS on platforms except mingw
17:52:22 <c_wraith> Oh, whoops.  Missed the n
17:52:31 <riaqn> so it's specific to platforms other than windows?
17:53:47 <c_wraith> I guess it's something like the windows not having a threaded runtime that works anything like other OS's
17:53:54 <geekosaur> yes, and only if bound threads are supported, which in practice means the threaded runtime --- forkIO is fine in the nonthreaded runtime (it uses green threads instead of OS threads), but forkOS is not
17:54:28 <geekosaur> I suspect the timer manager doesn't exist on Windows
17:57:21 <riaqn> what I don't understnd is it says: "forkIO on threaded RTS is expensive".
17:57:56 <riaqn> from what I understand, RTS being threaded simply means now sparks can utilize multi-core.
17:58:05 <riaqn> but it should still be cheap to forkIO.
17:58:13 <riaqn> what's expensive is forkOS.
17:58:55 <geekosaur> I think this is relative expense
18:00:42 <geekosaur> also, I think what's really expensive there is not the forkIOWithUnmask /per se/ but the ensuing MVar op
18:01:35 <riaqn> geekosaur: so you think it's just some performance consideration? I can safely delete this case?
18:01:58 <geekosaur> (relative expense meaning, even something relatively cheap is expensive if you're doing a timeout on millisecond or shorter scales --- remember that this uses nanoseconds!
18:02:26 <riaqn> geekosaur: make sense.
18:02:53 <riaqn> it's microseconds, though.
18:03:12 <geekosaur> mm, right, I skipped a level :)
18:03:34 <geekosaur> whatever, people always assume the timing stuff is in milliseconds and it's not
18:04:08 <geekosaur> "I told this to sleep 1 second and it returned immediately" "no, you told it 1/1000 second" "??! ---oh"
18:05:02 <geekosaur> so I suspect it'll work without the special case but timing may be noticeably off if you use short timeout or expect near-realtime timing
18:10:46 <jchia> Is there a concise way to express Python's "{}a{}b{}".format(x, y, z)? I know about Text.Printf, but I'm looking for something even simpler when all the things I want to "print" have show instances or are IsString.
18:11:57 <byorgey> jchia: what does that Python syntax do?
18:12:32 <jchia> "{}a{}b{}".format(1, "x", "2") == "1axb2"
18:12:52 <byorgey> mpcsh: you make an algebraic data type.  data Shape = S Square | C Circle
18:13:46 <jchia> i don't want to do long-winded tshow a <> tshow b <> ...
18:14:18 <byorgey> jchia: that doesn't exist, but you could easily make your own function to do it for you
18:14:28 <byorgey> using printf
18:14:48 <jchia> OK
18:16:10 <jchia> doesn't printf require the types to be specified in the format string?
18:17:09 <jchia> i don't want to have to have to care about the types when i provide the format strings
18:18:19 <quuxman> mpcsh: figure out union types?
18:18:20 <geekosaur> fmt ('{':'}':xs) (v:vs) = v:fmt xs vs; fmt (x:xs) vs = x:fmt xs vs; fmt "" _ = "" -- or replace the `v:` with `show v:` if that's what you want; also maybe cases for too few/many values instead of letting them throw pattern errors
18:18:35 <mpcsh> quuxman: well yeah, how are they written in haskell?
18:18:38 <geekosaur> hm, bu as a list that's not real useful :)
18:18:46 <geekosaur> and no, do not suggest hlist :p
18:18:57 <mpcsh> quuxman: oh, didn't see byorgey's response
18:18:59 <mpcsh> byorgey: thanks
18:20:33 <jchia> geekosaur: The variables being printed are different types. I can't represent them in a list
18:20:56 <quuxman> mpcsh: data Foo = FooNum Int | FooStr String deriving Show
18:21:05 <geekosaur> the varargs trick is annoying though
18:21:17 <quuxman> FooNum and FooStr are called constructors of type Foo
18:21:18 * geekosaur wonders if %v will default to using show
18:21:24 <jchia> concretely, i have a pathname that is made up of different params, some numeric, some string, etc, and i want to compute the pathname without too much boilerplate code
18:21:29 <quuxman> the 'deriving Show' adds a type class so it can be turned into a string automatically
18:22:48 <geekosaur> bleh, nope. pity they didn't include a %S or something that just uses show
18:23:04 <geekosaur> but then I suppose the varargs machinery wouldn't work right
18:23:11 <geekosaur> since it's a typeclass hack
18:23:46 <quuxman> hum, can lambdabot define types? ...
18:23:53 <quuxman> > data Foo = FooNum Int | FooStr String deriving Show
18:23:59 <geekosaur> use @let
18:23:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
18:24:02 <geekosaur> > is just expressions
18:24:06 <geekosaur> whoops
18:24:06 <lambdabot>  error:
18:24:06 <lambdabot>      • Variable not in scope: is :: t0 -> t1 -> t
18:24:06 <lambdabot>      • Perhaps you meant one of these:
18:24:10 <geekosaur> :p
18:24:14 <quuxman> @let data Foo = FooNum Int | FooStr String deriving Show
18:24:17 <lambdabot>  Defined.
18:24:31 <quuxman> > (FooNum 1, FooStr "hihi")
18:24:34 <lambdabot>  (FooNum 1,FooStr "hihi")
18:33:38 <Tyg13> Is there anyway to do something like this? data Array a = Array (field :: a) (field2 :: a)
18:33:59 <wespiser> merry christmas: Is there a comparison of interpreter performance: mtl vs. free monad?
18:34:35 <Tyg13> So you'd use it like a = Array Int 1 2
18:34:40 <wespiser> data Array a = Array { field1 :: a, field2 :: a}
18:34:54 <Tyg13> oh perfect
18:35:10 <Tyg13> Is there a way to do it without record syntax (just out of curiousity)
18:35:20 <wespiser> yea, data Array a = Array a a
18:35:38 <Tyg13> I should have just tried it first before I asked
18:35:47 <wespiser> the RHS is called the "data constructor"
18:36:05 <wespiser> Tyg13, no worries, i'm here asking questions too that I should probably just be looking up!
18:36:10 <Tyg13> LHS is the type constructor, right?
18:36:14 <Tyg13> hehe, aren't we all?
18:36:24 <wespiser> yes, exactly
18:58:37 <violafrown> yo
18:58:50 <rdococ> ho
18:59:10 * rdococ suddenly realizes he spoke in this channel
18:59:18 <violafrown> am i interrupting something? can't see what happened above
18:59:30 <rdococ> don't think so
18:59:35 <violafrown> kool
18:59:41 <violafrown> what brings you here?
18:59:45 <violafrown> are you perhaps a mod?
19:01:46 <hamishmack> Eduard_Munteanu: I would recomend using haskell-gi not Gtk2Hs these days.  Here are the Gtk2Hs examples ported to haskell-gi https://github.com/haskell-gi/gi-gtk-examples
19:02:58 * violafrown wonders why everything is so quite around here
19:03:03 <rdococ> nope, not a mod
19:03:08 <violafrown> aha
19:03:20 <rdococ> what?
19:03:52 <violafrown> sorry, not a "gotcha" "aha", just a "i understand" "aha"
19:04:35 <violafrown> i didn't really come to ask about anything in particular, just to chill
19:04:38 <jchia> I'm calling a function that can take both Text and String. When I try to call with a string literal, I get an ambiguous type error. Is there a way to tell ghc to default to Text when there's any ambiguity between Text and String?
19:04:45 <rdococ> oh okay
19:05:23 <jchia> (I'm using OverloadedStrings)
19:06:01 <violafrown> I won't be of much help with that particular issue. Anyone else?
19:06:33 <violafrown> (Google might be your friend this time around)
19:09:42 <geekosaur> looks like a default declaration would work
19:12:01 * geekosaur tested in ghci of 7.10.3 with: default (Double, Integer, Text, ())
19:12:02 <geekosaur> (the () is because of ExtendedDefaultRules)
19:13:09 <geekosaur> I wonder when they fixed that... or maybe it still fails if you use String
19:40:10 <haskell580> Merry Christmas! If I want to quickcheck a property for functions f1, f2 with input type T, but I know that f1, f2 are resp. only meaningful for subsets of T, T1 and T2, how would I go about creating two instances of Arbitrary T?
19:42:16 <haskell580> is the best way to create phantom types to separate T1 and T2?
19:43:12 <c_wraith> haskell580: That's a case where it's reasonable to use the controls quickcheck offers to filter the inputs when running particular tests
19:43:57 <haskell580> c_wraith: if I'm not mistaken, doesn't quickcheck give up after trying to generate too many inputs that are filtered out? 
19:44:22 <c_wraith> I think that's true - and possibly a mistake in the design.
19:45:01 <riaqn> Hi, what's the convention of exception-safe? are all functionas required to keep state consistent in case of exception?
19:45:08 <haskell580> c_wraith: so if I know that T1 and T2 are in some sense small subsets of T, it would be rather inefficient to try your suggestion, no?
19:45:53 <c_wraith> riaqn: yeah, actions should keep things consistent in the case of exceptions.  Though be aware that any pure function doesn't need to worry about it.
19:46:01 <haskell580> c_wraith: unless you meant that there was a mistake in my design of the program and that I should have used phantom types to distinguish the two in the first place :)
19:46:04 <riaqn> nevermind, I think the answer is yes.
19:46:22 <c_wraith> haskell580: yeah, in that case.  In that case I'd wonder why they both take an input type that has so many uninteresting cases. :)
19:46:38 <haskell580> c_wraith: thanks for the advice!
19:46:39 <riaqn> c_wraith: yeah, that's a wonderful thing about purity.
19:46:44 <ertes> riaqn: note that functions are unrelated to exceptions
19:46:54 <riaqn> IO are.
19:47:55 <c_wraith> haskell580: If you're committed to that design (and there are lots of good reasons to be committed to a design like that - don't take it as bad if you are) the best approach is probably a couple newtypes for testing those functions, as you suggested initially
19:49:55 <ertes> riaqn: also what exactly do you mean by "keeping state consistent"?  what kind of state?
19:54:03 <riaqn> ertes: like scarce resources. I'm writing a clean-up function for an data type of outer resources. Now, I don't want the status in the data type marked recycled, while the outer resource is not.
19:54:14 <riaqn> The data type is like an abstraction of socket.
19:54:23 <augur> how can i get a bunch of Haskell type signatures out of Base or whatever?
19:56:11 <ertes> riaqn: there are a few common patterns like 'bracket' that are really useful in this case
19:56:33 <riaqn> ertes: yes. but it's kind of different.
19:57:07 <riaqn> Say I abstrat socket to a data type Sock, and provide two function: new :: IO(Sock) and delete :: Sock -> IO ()
19:57:46 <riaqn> now, in delete we will close the socket, in the meantime mark Sock as deleted.
19:58:12 <riaqn> I guess I will just uninterruptableMask_ around the delete.
19:58:17 <riaqn> as it's a quick function.
19:58:31 <ertes> riaqn: only do that if the closing is indeed interruptible
19:59:13 <riaqn> ertes: well, it's just an example. Actually I have to killThread too, which certainly blocks.
20:00:47 <ertes> riaqn: killThread is not "quick" though…  do you *need to* make sure that killing the thread, closing the socket and setting the state have to be atomic?
20:01:50 <riaqn> ertes: hmm, so during uninterruptableMask_ other threads won't be scheduled?
20:02:16 <ertes> riaqn: they will be, but uninterruptableMask_ is a recipe for deadlocks
20:02:27 <chrono> 3,4THIS NETWORK 4,3IS BLOWJOBS! GET ON SUPERNETS4,3 FOR COLD 3,4HARD CHATS NOW
20:02:27 <chrono> 4,3ITS DECEMBER 25th! 3,4MERRY 4,3FLOODMAS 3,4FROM SUPERNETS!4,3 SEE YA NEXT YEAR
20:02:28 <chrono> 3,4IRC.SUPERNETS.ORG | 4,3PORT 6667/3,4 6697 (SSL) |4,3 #SUPERBOWL | 3,4IPV6 READY
20:02:45 <ertes> riaqn: any throwTo that thread will block until unmasked
20:02:46 <riaqn> ertes: ahh, you are afriad that, the thread being killed masks exceptions.
20:02:59 <ertes> riaqn: no, the thread that kills it
20:03:43 <riaqn> ertes: but in the case where the thread to be killed has no mask, it shouldn't be a huge problem?
20:04:00 <riaqn> because killThread will be quick.
20:05:20 <ertes> riaqn: i'm just saying that you should avoid uninterruptableMask (regular mask is fine), because if nothing else you might be just killing your concurrent performance for no reason
20:05:41 <ertes> riaqn: that's why you should consider whether uninterruptability is really necessary
20:05:54 <ertes> riaqn: properly handling failure is usually the better option
20:06:07 <riaqn> ertes: yeah, I understand. But I still don't see why it will hit the performance.
20:07:11 <riaqn> I think it's just that, the killing thread is unresponsive until the killed thread is killed.
20:07:41 <riaqn> which is perfectly fine in my case, as I expect the killed thread to be killed instantly.
20:18:17 <ertes> riaqn: your reasoning to why you use it is: "because it's fine", not: "because i have to"
20:18:22 <ertes> that's the problem!
20:18:55 <ertes> let me cite the haddocks: "THIS SHOULD BE USED WITH GREAT CARE" [sic]
20:19:29 <ertes> find reasons *for* it, not reasons *not against* it
20:25:15 <shapr> randomly littering strictness annotations around my code and using -funbox-strict-fields brought my memory usage down to nearly nothing.
20:26:33 <ertes> shapr: if your GHC is recent enough -funbox-strict-fields is actually the default
20:26:48 <shapr> oh good
20:28:45 <ertes> shapr: now figure out which of all those strictness annotations actually made the difference =)
20:29:07 <shapr> I think they did, memory usage went from 64+ GB to effectively nothing.
20:29:48 <ertes> shapr: of course, but *which* ones?  i find it important to know that to see where your code went bad =)
20:32:46 <glguy> It feels so strange to not have an AoC to be preparing for
20:33:19 <shapr> glguy: want to tell me what idiotic thing I've done with mine? :-/
20:33:32 <glguy> I can try
20:34:41 <shapr> glguy: Anything obviously wrong with this? http://lpaste.net/350482
20:35:36 <shapr> I stole the strictness annotations you use on your data types, suddenly my space leaks went away.
20:38:08 <glguy> I'd expect that you were storing thunks in your registers each update instead of the unpacked Ints you are now
20:38:23 <glguy> so you would build up lots of AState values in memory
20:38:26 <shapr> glguy: do you do any other coding contests? I've learned a bunch from writing my own solutions and then seeing yours
20:38:58 <glguy> I don't
20:39:03 <shapr> ah, too bad
20:39:24 <shapr> How long did your solution to Day23 take to execute?
20:39:40 <shapr> I figure ten minutes is too long.
20:40:12 <glguy> I'll check
20:40:30 <glguy> You're wondering for part 2, right?
20:40:46 <shapr> I haven't gotten part 1 yet
20:40:55 <shapr> day 12 was fast
20:41:21 <glguy> Day23 part 1 is pretty much instant
20:41:31 <sm> are glguy's solutions somewhere ? never mind, don't tell me
20:41:33 <shapr> then I'm doing it entirely wrong
20:41:52 <glguy> sm: all on github
20:42:36 <sm> I'll check them out afterward
20:49:59 <glguy> shapr: Is your code hosted anywhere?
20:50:04 <glguy> other than that pastebin link
20:50:40 <shapr> glguy: I can check it into my github repo
20:52:30 <quuxman> oh my goodness I think Graphics.Gloss is what I've been looking for. Haskell opengl is NOT fun
20:54:20 <ertes> quuxman: are you saying that OpenGL is fun elsewhere? ;)
20:54:35 <quuxman> no. The opengl API is seriously too low level
20:55:04 <quuxman> the problem is each language and environment has its own friendly abstraction of it
20:55:44 <quuxman> think gloss is pretty new because I've been looking for a friendly hardware accelerated 2d graphics for a long time that doesn't depend on gtkhs
20:56:01 <shapr> glguy: ok, it's checked in and builds
20:56:12 <ertes> quuxman: actually gloss has been around for a few years
20:56:23 <quuxman> haven't written any Haskell for a few years :P
20:56:55 <ertes> quuxman: there are also higher-level wrappers around the 'gl' library
20:57:03 <ertes> quuxman: most notably GPipe and luminance
20:57:15 <ertes> GPipe even has a haskell EDSL for shaders, which is quite nice
20:59:02 <quuxman> ooh very cool
20:59:26 <quuxman> there isn't a Haskell -> JavaScript implementation of gpipe is there?
20:59:48 <ertes> quuxman: both use the 'gl' library, which is currently native-only
21:00:09 <ertes> the problem is that WebGL is not quite OpenGL…  essentially it requires a different binding
21:00:18 <quuxman> aaaarhg :-[]
21:00:47 <quuxman> I'm pretty interested in getting hardware accelerated functional graphics in browser
21:01:10 <ertes> the main point of the gl library is that it's not actually written/maintained by a human, but it's fully generated from the spec
21:02:02 <ertes> i suppose if there is a similar formal description of WebGL, then there could be ways to automate binding to that as well, and then create a unified wrapper library around both
21:02:53 <shapr> glguy: program succeeds instantly when instructions are read and a is set to 7 :-/
21:03:13 <shapr> well, part 1 is done
21:03:18 * shapr sighs
21:03:20 <glguy> You weren't initializing a before?
21:03:38 <shapr> yup, I copy'n'pasted from day 12
21:07:36 <shapr> Does part2 of day 23 take a long time?
21:07:41 <glguy> yeah
21:07:50 <glguy> Mine took about 4 minutes
21:07:56 <shapr> oh, ok then.
21:08:12 <glguy> I think all of my other ones ran instantly or in less than a few seconds
21:08:19 <glguy> but I never did optimize this one
21:14:18 <shapr> glguy: 8 minutes for my code to solve part 2
22:44:15 <pikarudolph> is it possible to serialize a digestive-functors View?
22:44:33 <pikarudolph> it contains one of these http://hackage.haskell.org/package/digestive-functors-0.8.1.1/docs/Text-Digestive-Form-Internal.html#t:FormTree
22:44:43 <pikarudolph> which I know isn't usually serializable
22:45:04 <pikarudolph> wondering if any of the cloud-haskell distributed stuff could help
22:52:19 <lurkashf1ake> Does haskell have backward compatibility? I've built a short hs script and it ouput errors. 
22:54:12 <pacak> lurkashf1ake: Depends. Can you show your script?
22:55:44 <lurkashf1ake> pacak: https://github.com/tuxmark5/EnableRazer/blob/master/src/Main.hs I've added ', 0x0cc' inside the brackets after the 3 other device's ID as specified in the instructions.
22:56:13 <pacak> lurkashf1ake: And the error message?
22:57:34 <pacak> It's a very poorly coding btw.
22:58:08 <lurkashf1ake> ok
22:59:05 <lurkashf1ake> reading xclip man page to see how to copy those few lines of errors real quick (new OS)
22:59:26 <pacak> lurkashf1ake: But if you show error message - somebody will be able to help you.
22:59:44 <pacak> lurkashf1ake: In linux you can just select text to copy it and paste it using mouse wheeel
23:00:23 <lurkashf1ake> pacak: it failed this time
23:02:00 <pacak> lurkashf1ake: Check issues - there are some issues about strange error messages and suggestion how to fix it. I'm off.
23:02:15 * lurkashf1ake wonder why he can paste in his url bar but not inside thepasteb.in text field
23:02:37 <lurkashf1ake> pacak: ok I'll paste soon for others to help
23:03:39 <Fylwind> is there a reason for GHC to have both Natural and Nat?  Why not use the same type for both value-level and type-level numbers? 
23:05:28 <quuxman> Eduard_Munteanu: what's your opinion of lambdu?
23:06:00 <Eduard_Munteanu> quuxman, dunno what that is
23:06:11 <lurkashf1ake> I get those errors http://pasted.co/54c4bd17 out of building this https://github.com/tuxmark5/EnableRazer/blob/master/src/Main.hs
23:08:09 <Eduard_Munteanu> quuxman, interesting though, I'll have a look
23:08:32 <quuxman> Eduard_Munteanu: I think it's structured editing gone horribly, horribly wrong
23:09:59 <quuxman> even if it's just a prototype / demo, I do not like or understand where it's going
23:11:10 <quuxman> thing is, I like pretty much everything I read on lambdu.org :-|
23:11:12 <lurkashf1ake> Is the script unix agnostic, I am running openbsd
23:12:48 <quuxman> Eduard_Munteanu: I think it's incredibly easy to have very good intentions and even good ideas about structured editing, or advances in development environments, and create totally worthless code
23:13:05 <quuxman> or at least extremely painful UI
23:13:32 <Eduard_Munteanu> Hm.
23:15:58 <quuxman> (after an enormous amount of thought and work)
23:21:58 <riaqn> it's so interesting. in AttoParsec, if I use atEnd to detect end of input, I actually get PartialResult.
23:22:24 <riaqn> That is, detecting end requires more input, makes it partial.
23:22:33 <riaqn> While I only want to know if it's theend.
23:24:50 <quuxman> riaqn: don't really know what your talking about, but based on my experience in parsing, sounds like you're calling atEnd at a syntactically invalid point
23:25:05 <quuxman> and so it needs further input to return True or False
23:26:19 <riaqn> quuxman: well, the whole parser always read 4 bytes. I just want to make sure that the input is also only 4bytes.
23:27:00 <riaqn> quuxman: In case it's not the end yet, throw error.(this is what I want)
23:28:41 <riaqn> quuxman: nevermind, I think it's semantically correct.
23:29:02 <riaqn> quuxman: as "testing the end" requires to know if more data is available.
23:29:15 <riaqn> So I just pass empty string to the continuation in the partial result, and it's done.
23:30:22 <quuxman> riaqn: I find it often quite difficult to determine the semantics of haskell libraries, because usually the documentation is just the types and a couple examples
23:30:49 <quuxman> (examples if you're lucky)
23:36:39 <riaqn> quuxman: after dependent types prevails, there will be just types.
23:39:08 <mpcsh> Does haskell have an unbounded positive integer (natural) type?
23:41:29 <riaqn> riaqn: ahh, even better, there is parseOnly.
23:42:43 <Fylwind> mpcsh: if by “positive” you mean ≥0, there’s https://hackage.haskell.org/package/base-4.9.0.0/docs/Numeric-Natural.html
23:43:18 <mpcsh> Fylwind: no more "native" solutions?
23:43:28 <Fylwind> mpcsh: native?
23:43:56 <mpcsh> Fylwind: oh wait, what you linked is in base - is that included by default then?
23:44:00 <mpcsh> I just have ghc installed
23:46:06 <quuxman> > mpcsh Integer
23:46:09 <lambdabot>  error: Variable not in scope: mpcsh :: t0 -> terror:
23:46:09 <lambdabot>      • Data constructor not in scope: Integer
23:46:09 <lambdabot>      • Perhaps you meant one of these:
23:46:43 <quuxman> mpcsh: oops. I meant Int is bounded, Integer is not.
23:46:48 <quuxman> > maxBound :: Int
23:46:51 <lambdabot>  9223372036854775807
23:46:56 <quuxman> > maxBound :: Integer
23:46:59 <lambdabot>  error:
23:46:59 <lambdabot>      • No instance for (Bounded Integer)
23:46:59 <lambdabot>          arising from a use of ‘maxBound’
23:47:17 <mpcsh> quuxman: yes, but of course you can have negative integers
23:47:39 <quuxman> oh yeah, I guess natural means 0 or positive eh?
23:48:19 <mpcsh> quuxman: yeah
23:49:13 <ij> How do I take a subsequence of Seq?
23:49:34 <ij> Umm, specifically from index n to m.
23:49:42 <quuxman> mpcsh: Numeric.Natural ?
23:50:47 <ij> There's Data.Sequence.take, not sure how I didn't notice yesterday.
23:51:00 <mpcsh> quuxman: quuxman ok yeah, that's what Fylwind linked. how would I use that in a type signature?
23:51:14 <mpcsh> would it be like fun :: Numeric.Natural -> Numeric.Natural ?
23:51:17 <mpcsh> surely no
23:51:41 <ij> It's not O(n), nice.
23:51:42 <quuxman> :import Numeric.Natural; fun :: Natural -> Natural
23:52:22 <quuxman> mpcsh: though of course you just get a runtime error if a negative value is produced
23:52:34 <mpcsh> quuxman: perfect, thanks
23:52:36 <mpcsh> quuxman: and yeah of course
23:57:01 <quuxman> mpcsh: Numeric.Natural is the module, Numeric.Natural.Natural is the single thing in the module, a type class. I recommend installing hoogle and using :hoogle and :m <tab> in ghci
23:58:18 <Fylwind> quuxman: I don't believe Natural is a type class
23:58:34 <quuxman> oh doh. data type
23:59:33 <quuxman> far past time to go to sleep, but of course I'm not going to
