00:01:13 <ashishnegi> one thing i noticed while profiling is that  : if i lazily read strings and convert to ints.. it takes more memory ; while `force` leads to smaller memory footprint.. i could not find why the unused lines not getting GCed.
00:02:16 <ashishnegi> `lines` i mean lines of files which are parsed -- i go over each line by line; (prevLine, currLine, nextLine)..
00:02:44 <lyxia> ashishnegi: (force a, force b) does not seem strict enough
00:04:29 <lyxia> especially in foldl', you're still building up a thunk that gets evaluated only at the end
00:05:37 <lyxia> > (undefined, undefined) `seq` ()
00:05:40 <lambdabot>  ()
00:05:43 <lyxia> > undefined `seq` ()
00:05:47 <lambdabot>  *Exception: Prelude.undefined
00:06:35 <ashishnegi> oh.. lyxia.. thanks for info.. i will play around with it.
00:07:06 <Myrl-saki> seq is awesome. I proved that a very very swedish greeting terminates with it.
00:07:33 <lyxia> so if you want the components to be evaluated when the tuple constructor is, you need a strict constructor: let strictPair !a !b = (a, b)
00:07:41 * hackagebot pipes-text 0.0.2.5 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.5 (MichaelThompson)
00:07:41 * hackagebot x509 1.6.5 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.5 (VincentHanquez)
00:07:52 <lyxia> or let strictPair a b = a `seq` b `seq` (a, b) if you don't like extensions
00:08:06 <lyxia> oh you have bangpatterns on already :)
00:10:58 <lyxia> you could also do "force (graph'', nodesInEdges'')" but force is perhaps too heavyweight.
00:12:10 <lyxia> it has to traverse the whole graph, which might not be necessary.
00:14:08 <ashishnegi> lyxia: yes.. but i first wanted to bring the memory to some sane value.. currently it is around 1 GB.
00:14:31 <xocolatl> is there already a function to turn [1,2,3,4,5,6,7,8,9] into [[1,2,3],[4,5,6],[7,8,9]]?  If so, I can't find it
00:15:04 <ongy> Data.List.Split in the split package has a few nice functions
00:15:12 <ongy> I think chunksOf is what you are asking for
00:16:30 <xocolatl> ongy: that's exactly what I want.  Thanks!
00:21:08 <MarcelineVQ> you can also put it together with unfoldr and splitAt if you just want the one function, the split package has some nice stuff though
00:24:40 <ongy> I usually just copy paste the one function I need... splitAt feels a bit like leftpad
00:24:44 <ashishnegi> but ! or seq would evaluate to WHNF.. 
00:25:26 <ashishnegi> lyxia: calling `force` around the tuple is not helping.. same profile results.
00:26:33 <MarcelineVQ> ongy: idk what leftpad means :>  you can make chunksOf pretty straightforwardly with splitOn though, chunksOf n = unfoldr (\b -> case splitAt n b of ([],_) -> Nothing; x -> Just x)
00:27:11 <MarcelineVQ> *splitAt
00:28:33 <lyxia> ashishnegi: my point was that putting ! at the right places is more efficient than force everywhere
00:29:48 <xocolatl> today's advent challenge is complete! \o/
00:32:15 <xocolatl> does anyone else here do http://adventofcode.com/ ?
00:32:34 <MarcelineVQ> a few people last year, dunno about currently
00:33:15 <xocolatl> I figured it'd be a good way to practice haskell (for me)
00:35:57 <jchia_> aeson question: If I have a JSON '{"a": {"b": {"c": 1}}}' thats decoded into an Object o, and I want to get a.b.c during parsing, is there a more elegant way than this?
00:35:57 <jchia_> c <- o .: "a" >>= (.: "b) >>= (.: "c")
00:36:15 <cocreature> ashishnegi: "force x" doesn’t magically force the evaluation of x, all it does is that if "force x" would be evaluated to whnf, x will be evaluated to normal form. you still need to make sure that it is evaluated to whnf
00:36:55 <jchia_> I want to avoid doing one <- for each intermediate result.
00:39:20 <xocolatl> ha!  ghci understands :q
00:40:42 <lyxia> jchia_: write your own combinator or use lenses
00:40:51 <cocreature> xocolatl: you can also send EOF (usually that’s done by pressing contol+d)
00:40:53 <MarcelineVQ> xocolatl: any many many others, have a look https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
00:41:03 <MarcelineVQ> *and
00:41:12 <xocolatl> cocreature: that's what I usually do
00:44:04 <jchia_> OK
00:44:06 <ashishnegi> cocreature: after creating the graph (map) , i traverse it.. it would then force the evaluation, also i am doing force after every 1000th step..
00:44:27 <ashishnegi> Is there any good docs for creating big data structures in Haskell ?
00:53:03 <ongy> MarcelineVQ: http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/ A funny JS desaster, that came in parts from "let's pack every function into a library"
00:56:45 <xocolatl> I don't understand why  f a b = last (g a b)  turns into  f = (last .) . g
00:56:52 <xocolatl> why not just  last . g  ?
00:58:29 <cocreature> xocolatl: let’s look at how last . g is defined
00:58:33 <cocreature> @src (.)
00:58:33 <lambdabot> (f . g) x = f (g x)
00:58:42 <cocreature> alright so we have (last . g) a b
00:58:45 <cocreature> we substitute the definition
00:58:51 <cocreature> we end up with last (g a) b
00:58:57 <cocreature> but that’s not what you intended!
00:59:25 <cocreature> now let’s start with "((last .) . g) a "
00:59:45 <cocreature> then we get (last .) (g a) b
00:59:52 <cocreature> which is just (last . g a) b
00:59:58 <cocreature> which is last (g a b)
01:00:07 <xocolatl> hmm
01:00:19 <cocreature> xocolatl: but tbh, I wouldn’t recommend anybody actually uses (last .) . g in their code
01:00:55 <cocreature> if you really want that at least define a separate combinator (f .: g) a b = f (g a b)
01:01:08 <cocreature> which can be found in the composition package (and in various other packages)
01:01:15 <cocreature> (last .) . g is pretty hard to read
01:01:32 <xocolatl> I agree.  I'll keep it non-point-free
01:01:44 <MarcelineVQ> ongy: I'm not sure I understand, there's a fair bit of warning when base changes, so I'm not sure how that article's leftpad is related to splitAt, if anything it's an argument against the split package
01:02:46 <ongy> ah yes, I was refering to the package split, not splitAt, I fail
01:02:57 <MarcelineVQ> oh alright
01:03:17 <cocreature> well the split package implements a lot of different functions, so I don’t think leftPad applies
01:06:52 <cocreature> xocolatl: it might be a fun exercise to verify that "((.) . (.)) f g a b" also does what you want :)
01:57:38 * hackagebot strelka 0.4 - Extremely flexible and composable router  https://hackage.haskell.org/package/strelka-0.4 (NikitaVolkov)
01:57:40 * hackagebot strelka-wai 0.4 - WAI compatibility layer for "strelka"  https://hackage.haskell.org/package/strelka-wai-0.4 (NikitaVolkov)
02:37:26 <volhovm> Hello everyone. Is there any good manual on how unsafePerformIO should be used?
02:37:48 <volhovm> I know something about inline pragmas and that functions using unsafePerformIO should be NOINLINE.
02:37:53 <volhovm> But there might be more caveats.
02:52:40 * hackagebot aivika 5.0.1 - A multi-method simulation library  https://hackage.haskell.org/package/aivika-5.0.1 (DavidSorokin)
02:52:42 * hackagebot aivika-transformers 5.0.1 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-5.0.1 (DavidSorokin)
03:18:17 <darkpsi> hey guys fairly new to haskell, writing an application that works with files on a bit level i am looking for somthing like bitstrings but for indiual bytes thanks 
03:18:33 <darkpsi> *bits
03:19:00 <darkpsi> hey guys fairly new to haskell, writing an application that works with files on a bit level i am looking for somthing like bytestrings but for indiual bits thanks
03:19:53 <darkpsi> *individual 
03:56:38 <oherrala> darkpsi: bytestring?
03:57:07 <oherrala> darkpsi: I have used bytestring + Data.Bits, but I don't know about bitstrings
04:00:41 <darkpsi> @oherrala there is a BitStrings on hackage not very good and they are not very quick so i was just wondering if any one knew a nice way of dealing with files on the bitlevel so that i can write a arbitory amount of bits to a file 
04:00:41 <lambdabot> Unknown command, try @list
04:03:36 <jedai> darkpsi: that's bytestring
04:04:03 <darkpsi> oherrala: there is a BitStrings on hackage not very good and they are not very quick so i was just wondering if any one knew a nice way of dealing with files on the bitlevel so that i can write a arbitory amount of bits to a file 
04:04:30 <jedai> any binary protocol/file format should use bytestring except if there's already a specialized library (that use bytestring underneath)
04:05:01 <jedai> Wait, you want to touch the bit level, not the byte ?
04:05:08 <darkpsi> yes
04:05:26 <jedai> Well I would still recommend bytestring with Data.Bit
04:07:21 <darkpsi> ok will probly do that it is quite a niesh thing i am doing thanks any way
04:07:42 * hackagebot pandoc-placetable 0.4.2 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.4.2 (mb21)
04:15:23 <riaqn> Hi, I have several layers of functions returning Either e a. What is the best practice of error handling, preserving best isolation?
04:15:56 <riaqn> by isolation I mean, the error types of layers should be different, since the errors ARE different.
04:16:15 <riaqn> Of course I can invent an error type containing all possible errors, but that's not elegant.
04:21:30 <riaqn> Moreover, sometimes Layer 3 may care about errors happens in Layer 1, while layer 2 doesn't.
04:22:17 <lyxia> ew
04:22:42 <lyxia> I don't quite understand what you mean by layer
04:22:43 * hackagebot heterocephalus 1.0.1.1 - A type-safe template engine for working with popular front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.1.1 (arowM)
04:23:22 <riaqn> lyxia: so there are several layers in my programs, functions in alll layers return Either e a
04:23:47 <lyxia> what is a layer
04:23:54 <riaqn> layer 3 functions call(depend) on layer2 functions. so on.
04:26:12 <riaqn> I think basically I need a exception system as in Java.
04:29:42 <riaqn> ahh I don't know if Control.Exception is what I want.
04:33:22 <riaqn> OK, so it essentially a hack in GHC, so `catch` can catch all exceptions.
04:34:02 <jedai> riaqn: I wouldn't call it a hack, it's just existential type + Typeable
04:34:30 <jedai> riaqn: and of course exceptions but that's a runtime thing
04:35:20 <riaqn> jedai: I mean, can we implement such a exception system by user code?
04:35:43 <riaqn> mainly the "extensible" feature I care about.
04:36:05 <jedai> riaqn: the extensible feature is completely doable (and done) in user code
04:36:47 <jedai> You can even piggyback on it by using the SomeException type
04:38:03 <riaqn> jedai: ahh, I see.
04:43:19 <riaqn> jedai: but I guess typeable introduces some overhead? I mean, some runtime comparison I guess.
04:43:54 <jedai> riaqn: Sure but not much and it's supposed to be an "exceptional" thing anyway ! ;)
04:44:49 <riaqn> jedai: hmm, so do you have suggestions for my original question? :-)
04:45:05 <jedai> riaqn: Typeable has been used in other applications where its performance was more important and it performed pretty well there so for the infime amount it could add to throwing and catching exception, it really doesn't matter much
04:45:51 <riaqn> jedai: I need some “extensible exception" for pure code(Either e a, where e is some exception)
04:45:55 <jedai> riaqn: Well I guess you could use the Either SomeException monad and encode what type you care in your layers
04:46:34 <riaqn> jedai: oh, so SomeException itself has nothing to do with IO?
04:46:41 <jedai> riaqn: no
04:46:47 <riaqn> I mean, exceptions has to be caught in IO
04:46:57 <riaqn> jedai: great! thanks.
04:47:00 <jedai> riaqn: it just data SomeException = Exception e => SomeException e
04:47:45 <jedai> riaqn: each instance of the Exception typeclass has methods fromException :: e -> SomeException and toException :: SomeException -> Maybe e
04:48:45 <jedai> riaqn: if your exception type is an instance of Typeable (which can be automatically derived), then toException and fromException are written for you, you just have to say "instance Exception MyType where"
04:49:05 <jedai> *"instance Exception MyType"
04:51:13 <riaqn> jedai: hmm, is this nessary? I don't see why we need "toException" and "fromException".
04:51:31 <riaqn> aren't they unique? Just boxing or unboxing SomeException.
04:52:36 <jedai> riaqn: Normally each of your exception is its own type (so that it can be extensible, you can add some new exception type) but to throw them and catch them you have to get a specific type
04:53:22 <jedai> riaqn: this root type is SomeException, which can contain any type that is an instance of Exception
04:54:04 <riaqn> jedai: hmm.. what sense it makes to define toException other than \e -> SomeException e?
04:54:29 <jedai> so toException is just SomeException, sure (at least if you don't create a hierarchy) but fromException has to use Typeable to know if it give back Nothing (the exception wasn't of the type demanded) or Just e
04:55:26 <seishun> what's the most elegant way to get a count of elements in a list for which a predicate returns True?
04:55:33 <jedai> riaqn: toExtension can be more complicated than that if you create a hierarchy of exceptions (so you have SomeCompilerException, someBusinessException ....)
04:56:09 <jedai> seishun: length . filter ?
04:56:23 <riaqn> jedai: but what sense it makes to define fromException other than cast?
04:56:25 <seishun> yeah, didn't think of that, thanks
04:56:38 <riaqn> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Typeable.html#cast 
04:57:24 <riaqn> jedai: also, can you elaborate on the hierarchy thing? I don't see why then we will need different toException
04:59:25 <jedai> riaqn: Because then you have to wrap your exception in SomeCompilerException before wrapping that by SomeException, the intent being that someone can catch SomeCompilerException and it will catch all those compiler exceptions and no others (No IOException...)
05:00:07 <jedai> riaqn: if you're really curious you should read the paper : http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf
05:00:49 <jedai> riaqn: the objective was to have an "Extensible Dynamically-Typed Hierarchy of Exceptions" as the paper said
05:02:02 <riaqn> jedai: I see how it works. Many thanks!
05:02:04 <jedai> riaqn: with it you can catch a specific exception type, a category of exception (or subcategory) or all exceptions, and it's all encoded by Haskell normal type system
05:02:24 <jedai> riaqn: You're welcome :) Good luck with your system
05:03:57 <stalek[m]> hello
05:05:49 <stalek[m]> I haven't found a megaparsec tutorial that wouldn't focus on some specific thing. Is there one?
05:43:53 <cocreature> stalek[m]: fwiw megaparsec is close enough to parsec that you can use any parsec tutorial to learn the basics. but it’s been too long since I’ve been in that position so I can’t recommend a good tutorial :/
05:45:18 <stalek[m]> ah, good
05:45:37 <stalek[m]> by the way, is parsec dead, or could I just use it instead of mega
05:45:38 <stalek[m]> ?
05:46:08 <cocreature> megaparsec mostly exists because parsec development is dead
05:46:31 <stalek[m]> So, it would be better to actually use mega, then
05:46:32 <cocreature> but parsec is not fundamentally broken so you could still use it but I don’t think there are a lot of good reasons to use parsec over megaparsec if you are starting a new project
05:47:09 <stalek[m]> ok, good to know
05:49:07 <stalek[m]> when reading "dev.stephendiehl.com", I'd like to try and do everything there
06:27:17 <quchen> Does anyone know Noam Lewis? He’s the maintainer of wl-pprint, but I’m unfamiliar with his name
06:27:28 <stalek[m]> mmh, I got something working
06:27:31 <quchen> Could be shapr for all I know :-D
06:27:55 <hodapp> that is not a pseudonym I'm aware of shapr having :P
06:28:07 <quchen> Could be shapr for all hodapp knows
06:28:16 <quchen> The evidence is striking!
06:28:20 <quchen> cf Raven Paradox :-)
06:28:21 <skgbanga> hey, quick question: So in this chapter http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types, If I want to control that my circle can only be constructed with positive radius, is there a way to do that?
06:28:24 <hodapp> I find your case strangely compelling.
06:28:24 <stalek[m]> The `choice` combinator doesn't consume input for the tried-but-haven't-suceeded parsers given, right?
06:29:07 <quchen> stalek[m]: Depends on the parser lib, but in general, choice commits to one of its branches once they consume any input.
06:29:41 <quchen> So when you have a choice that does not work right away you try the next choice; if one choice »somewhat« works, when you pick it.
06:30:01 <stalek[m]> I'm using parsec for now
06:30:08 <stalek[m]> well, "using"
06:30:30 <quchen> Well, try parsing "ab" with choice [string "aa", string "ab"]
06:30:44 <stalek[m]> "choice ps tries to apply the parsers in the list ps in order, until one of them succeeds. Returns the value of the succeeding parser."
06:30:50 <quchen> Parsec should fail entirely here, because it does not backtrack by default
06:32:32 <stalek[m]> yeah, I get an error
06:32:53 <stalek[m]> so, what's the standard solution for that?
06:33:24 <stalek[m]> I could apply `try` to everything
06:34:55 <stalek[m]> but I guess that's sort of stupid, performance wise
06:36:13 <quchen> »try« should generally be avoided, yes.
06:36:47 <quchen> You could refactor your grammar such that the elements are in an order that requires less backtracking.
06:37:12 <quchen> And you don’t have to add »try« to everything, it’s enough to do it for the prefix you’re using to decide what to do.
06:37:15 <stalek[m]> I'm trying to parse links out of markdown files
06:37:36 <quchen> So instead of »try (a >> b >> c)«, consider whether »try a >> b >> c« is not also sufficient.
06:38:00 <quchen> That way, you can fail in the »a« and backtrack, but once you enter the »b« you’re committed.
06:38:05 <stalek[m]> but the problem is that there are also references and footnotes that look the same as links
06:57:09 <Ox0dea> Is it not possible to `take` from the `intersect` of two infinite lists?
06:58:29 <hpc> > take 5 (intersect [1..] [1..])
06:58:32 <lambdabot>  [1,2,3,4,5]
06:58:45 <Ox0dea> What's happening here? http://ideone.com/WgitLh
06:58:50 <kuribas> > take 5 (intersect [1..] [2..])
06:58:58 <lambdabot>  mueval: ExitFailure 1
06:59:16 <hpc> > take 5 (intersect [2..] [1..])
06:59:23 <lambdabot>  [2,3,4,5,6]
06:59:50 <hpc> there's your problem then
06:59:53 <Ox0dea> What "law" is being followed here that it's not commutative?
07:00:11 <hpc> the law of it was just written that way ;)
07:00:44 <hpc> it can't know the list is sorted, so it has to pick one or the other
07:01:02 <hpc> it can't just go "this starts with 1 and this starts with 2 so let's just not traverse that infinite list looking for 1"
07:01:04 <Ox0dea> That's fair, but is there a way to inform the system that they in fact are?
07:01:06 <kuribas> > take 5 (intersect (1:[3..])  (2:[4..]))
07:01:13 <lambdabot>  mueval: ExitFailure 1
07:01:36 <hpc> you probably need to write a sortedIntersect or something like that
07:02:12 <hpc> or do something clever with whatever generates the infinite lists
07:02:16 <stalek[m]> http://lpaste.net/4188177207677419520
07:02:45 <hpc> this isn't something that comes up very often, so i am not sure if there's something pre-existing that implements it
07:02:59 <stalek[m]> this chokes on "[a[]b](def)" for instance
07:03:06 <Ox0dea> No worries. I appreciate the help you've provided.
07:03:21 <stalek[m]> `[a[]b](def)`, rather
07:04:14 <stalek[m]> What should I do to make it unchoke ?
07:05:11 <hpc> stalek[m]: it looks like it can't parse [a[]b] with wellBalBracket
07:05:28 <hpc> or rather, a[]b
07:05:58 <hpc> it tries to consume [ and fails
07:06:01 <stalek[m]> I'm not sure the `try` at the middle is useful anyway
07:06:09 <hpc> so instead it consumes one or more non-[] characters
07:06:12 <hpc> and consumes just a
07:06:32 <hpc> then after wellBalBracket, it tries to consume ] but instead finds [
07:06:36 <stalek[m]> wait, why would it fail at consuming [ ?
07:06:48 <hpc> because that's not what's under the cursor
07:06:56 <hpc> it's currently seeing a
07:07:21 <stalek[m]> mmh, yeah
07:07:39 <stalek[m]> at first, when seeing it choke, I put a try before the do-block
07:08:33 <stalek[m]> so, I should do a "lookahead", like test if the next character is a "[", and do in function of that?
07:08:54 <ashishnegi> hi.. for my program hp2ps is generating corrupt ps files when running program with `+RTS -hc` .. graphs are coming fine with `+RTS -hy`.. Anyone has seen similar problem ?
07:09:03 <ashishnegi> Any way to proceed ?
07:09:20 <hpc> stalek[m]: http://lpaste.net/4188177207677419520 - a rough step-by-step
07:11:44 <stalek[m]> ah, yes
07:11:48 <hpc> i recommend you start from BNF or something like that, make sure you have a specification that does what you want
07:11:51 <hpc> then translate that to parsec
07:11:54 <stalek[m]> I don't think wellBalBracket does what I wanted
07:12:00 <hpc> yeah
07:12:51 <stalek[m]> I seem to recall implementing "well balanced stuff" was the typical easy thing in DNF
07:12:54 <stalek[m]> B
07:14:36 <hpc> yep
07:14:48 <hpc> just need to make sure you're including the other stuff that can go into those balanced parens
07:14:52 <stalek[m]> I think I just have to parse `màny noneOf` also before and after my brackets
07:15:03 <stalek[m]> yeah, right
07:17:17 <stalek[m]> heh, yeah, that was it
07:23:34 <haasn> If Type :: Type with -XTypeInType, does that mean Haskell permits the russel's paradox?
07:24:32 <haasn> (Based on https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell “Following the work in the kind equality paper, the new Haskell will merge types and kinds into one syntactic and semantic category. Haskell would have the * :: * property.”)
07:26:18 <haasn> Ah that page says it: “However, Haskell is already inconsistent as a logic (because of undefined and GHC.Exts.Any) and so we don't have to worry about a new source of inconsistency.”
07:29:46 <stalek[m]> OK, leaving now. Thanks for the help guys!
07:35:24 <Guest47767> Hi all, I have what's maybe a simple question - I'm wondering if there's a way to specify an implementation for Eq for a new type I've written that derives it
07:36:14 <liste> Guest47767: not deriving it, and writing the instance yourself?
07:36:24 <Guest47767> I want to tell it to only compare the equality of two of the value constructors, and ignore the third
07:37:04 <Guest47767> liste that sounds like what I'm trying to do but I haven't learned about that yet
07:37:16 <Guest47767> What should I google to read about that?
07:38:20 <liste> Guest47767: probably "haskell typeclass instances"
07:38:42 <liste> Guest47767: are you reading some tutorial/book or on a course?
07:39:06 <haasn> Since * :: *, that means I can now use ‘*’ as a “normal” type, e.g. [*] :: *, and I can write stuff like “undefined :: *”
07:39:25 <haasn> This greatly confuses me, since it seems to make no sense. What is the meaning of ([] :: [*]) even?
07:39:27 <Guest47767> I read a lot of learn you a haskell but right now I'm trying to do the first advent of code challenge in haskell
07:39:39 <haasn> Is * effectively equivalent to Void in that only undefined inhabits it?
07:39:54 <haasn> I mean, I know types like Bool etc. inhabit *, but I can't exactly write [undefined :: *, Bool :: *] :: [*]
07:40:14 <haasn> since I can't use type names in expressions
07:41:26 <haasn> And what would happen if I could use (undefined :: *) in a type? Like Tree (undefined :: *) :: *
07:41:33 <liste> Guest47767: "declaring typeclass instances" in http://book.realworldhaskell.org/read/using-typeclasses.html, and "typeclasses 102" in http://learnyouahaskell.com/making-our-own-types-and-typeclasses
07:45:25 <Guest47767> liste thank you that helps a lot
08:27:52 * hackagebot itemfield 1.2.2.1 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.2.2.1 (KevinQuick)
08:49:09 <sybilsleaf> Hi all
08:49:37 <tdammers> hello
08:49:45 <sybilsleaf> I'm trying to get specific ghcjs compilers for use on stack as per the instructions here
08:49:47 <sybilsleaf> https://docs.haskellstack.org/en/stable/ghcjs/#ghcjs
08:50:15 <sybilsleaf> The thing is I'm looking for specific nightly builds and I can't work out what the paths would be
08:51:04 <sybilsleaf> tolysz seems to be hosting them here at http://ghcjs.tolysz.org
08:51:34 <sybilsleaf> and using this to create them https://github.com/tolysz/prepare-ghcjs
08:51:52 <sybilsleaf> but that is where my investigations have run into a bit of a wall!
09:00:45 <xocolatl> seems like a lot work to get the md5 of a string :(
09:00:52 <xocolatl> still haven't managed to do it
09:04:53 <xocolatl> [Char] -> ByteString  is a thing that seems not to really exist
09:05:43 <ij> I want to make a parseJSON for a FromJSON instance. I can get a key by «value .: "key"», but how do I just require that value's a string?
09:07:08 <ij> s/value/Object/
09:07:26 <Gurkenglas> Is there a library that classifies ~10-200-character texts according to some training set?
09:07:29 <ij> Oh, no I thought it's the samething, but it's not!
09:11:06 <glguy> xocolatl: You can't take the MD5 of a [Char] directly, you'll need to select an encoding first (like UTF-8) to get it to a ByteString, and then you can use cryptonite to compute the hash
09:11:27 <xocolatl> meh
09:12:06 <xocolatl> what does md5sum do?
09:12:19 <xocolatl> echo hi | md5sum
09:12:45 <glguy> echo emits hi in an encoding specified by your current locale
09:12:55 <glguy> md5sum hashes that encoding
09:14:07 <xocolatl> how do I convert [Char] -> ByteString using utf8 then?
09:14:48 <glguy> The utf8-string package has an encode function, the text package has an encodeUtf8 function
09:19:14 <ij> How aeson works is such a mystery to me.
09:20:08 <tdammers> which part? it's not rocket science
09:20:11 <ij> Oooooooooooh. If I want a string I just parse a value and expect a string via type inference.
09:20:30 <tdammers> yes, pretty much
09:20:43 <tdammers> or you decode a bytestring
09:20:46 <ij> thinking is so hard
09:21:02 <sybilsleaf> ij - the way to think of it is just in terms of simple typeclasses
09:21:29 <sybilsleaf> your program defines the type that you want, and then the appropriate instance of FromJSON is used
09:22:54 * hackagebot yi 0.13.4 - Yi editor  https://hackage.haskell.org/package/yi-0.13.4 (DmitryIvanov)
09:22:56 * hackagebot yi-core 0.13.4 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.4 (DmitryIvanov)
09:22:58 * hackagebot yi-frontend-pango 0.13.4 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.4 (DmitryIvanov)
09:23:00 * hackagebot yi-frontend-vty 0.13.4 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.4 (DmitryIvanov)
09:23:02 * hackagebot yi-fuzzy-open 0.13.4 - Fuzzy open plugin for yi  https://hackage.haskell.org/package/yi-fuzzy-open-0.13.4 (DmitryIvanov)
09:25:19 <alexknvl> Any PolyKinds/GADT/RankNTypes gurus? https://gist.github.com/alexknvl/5c820a191247c02629288475668c34e6 How do I fix the last line?
09:26:05 <sybilsleaf> and ij if you are writing parseJSON by hand you can use withText to require the Value to be a String
09:27:06 <ij> Wouldn't just forcing type on "parseJSON :: Value -> Parser String" require that it's a string either?
09:27:12 <codygman_work> Did that /r/haskell topic on pusher switching to Go from Haskell for an application get deleted? Or am i just bad at finding things again?
09:27:43 <glguy> alexknvl: Do you know about -fprint-explicit-kinds ?
09:27:52 <glguy> It's not the answer to your question, but it helps with these kinds of things
09:28:04 * hackagebot yi-ireader 0.13.4 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.4 (DmitryIvanov)
09:28:06 * hackagebot yi-keymap-cua 0.13.4 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.4 (DmitryIvanov)
09:28:08 * hackagebot yi-keymap-emacs 0.13.4 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.4 (DmitryIvanov)
09:28:10 * hackagebot yi-keymap-vim 0.13.4 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.4 (DmitryIvanov)
09:28:12 * hackagebot yi-language 0.13.4 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.4 (DmitryIvanov)
09:29:07 <ij> My aeson instances for Data.Ini: parseJSON a = either error id . parseIni <$> parseJSON a; toJSON = String . printIni
09:29:27 <sybilsleaf> Yes it would but the advantage of withText is that you get to define error messages to use when the Value is not a String
09:29:36 <ij> ah
09:29:49 <ij> I just want serialization to file and back, to save a dumb application's state for restarting.
09:30:11 <EvanR> ij: acid-state !
09:30:42 <glguy> alexknvl: I think you'll need to update your definition of :~> to: data (:~>) (f :: k1 -> *) (g :: k1 -> *) where
09:30:58 <ertes> helo
09:31:03 <ertes> ij: is it state or configuration?  do you insist on a single file, or would a directory be ok?
09:31:36 <ij> ertes, The context before you joined was: I'm doing it with Aeson, so I've a solution already.
09:31:46 <ij> EvanR, Isn't it like… complicated?
09:32:15 <alexknvl> glguy: Hmmm right, since (a :: k2) ~> (b :: k2) does not make much sense
09:32:21 <sybilsleaf> ij: something like you have would work, so you could also do parseJSON = withText "Expecting a String when parsing Ini" (return . parseIni)
09:32:23 <alexknvl> glguy: thanks!
09:32:26 <ertes> ij: aeson does only going back and forth between JSON…  you need some extra engineering to actually turn it into a solution for saving state
09:32:44 <ij> I'm aware.
09:32:54 <EvanR> ij: well... conceptually no
09:33:13 <ertes> with the little context i have i second EvanR's suggestion, if you're fine with binary and a directory =)
09:33:14 * hackagebot yi-misc-modes 0.13.4 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.4 (DmitryIvanov)
09:33:16 * hackagebot yi-mode-haskell 0.13.4 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.4 (DmitryIvanov)
09:33:18 * hackagebot yi-mode-javascript 0.13.4 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.4 (DmitryIvanov)
09:33:20 * hackagebot yi-snippet 0.13.4 - Snippet support for yi  https://hackage.haskell.org/package/yi-snippet-0.13.4 (DmitryIvanov)
09:33:33 <sybilsleaf> (well, you'll need to handle the either that parseIni returns)
09:33:47 <ertes> it's the same amount of work as aeson, but it gives you the safe serialisation part for free
09:33:58 <EvanR> to me json dumping is more conceptually stressnuous because you 1) have to save the entirety of the database to a file each time instea of just updates 2) that may fail and youd be screwed
09:34:07 <EvanR> strenuous
09:34:13 <EvanR> whatever i cant spell
09:35:15 <ij> I see. I'll take a look at how the API works then.
09:35:29 <EvanR> however acid-state is serious business, you have to put literally everything you want to save into the state, and modifying the type of that state will require a migration (but compare and contrast how this would go with json)
09:35:42 <ij> Yeah, that's what I like about it.
09:36:08 <ij> I already know precisely how it'll work and it puts my mind at ease.
09:36:20 <EvanR> ive done json states before and its mostly things crashing and failing when the structure is forgotten or changed
09:36:47 <ertes> ij: the point is that acid-state is an actual solution for *state*, so it has stuff like state transactions, including multi-threaded access to the state (which is valuable in haskell), versioning, etc., should you ever need that…  and it is an ACID solution for free, too, so you will never lose data the way you could by rolling your own solution
09:37:24 <ij> But I won't, because I will have backups.
09:37:35 <sybilsleaf> It does depend a pit on exactly what you are saving though - if it's a config file with a couple of Bools and Strings where failure is not too critical then acid-state may be overkill
09:37:35 <EvanR> :-:
09:37:39 <ij> :D
09:37:47 <ij> sybilsleaf, precisely
09:38:01 <ertes> ij: backups can save you from loss of power, but not from data corruption
09:38:19 <ertes> sybilsleaf: the question is whether it's state or just configuration
09:38:32 <sybilsleaf> yeah I understood it was really just configuration
09:38:41 <sybilsleaf> hence the the use of Data.Ini
09:38:44 <EvanR> a "config file" is its own requirement
09:38:53 <EvanR> you wont have any config file with acid-state
09:38:56 <EvanR> so thats that
09:39:09 <ij> It's a stupid little application, I'm probs gonna roll with json.
09:39:15 <EvanR> but if you dump json its not going to look very nice ;)
09:39:32 <ertes> ij: you're overestimating the amount of work you need to do with acid-state =)
09:39:36 <ertes> ij: just try it
09:39:47 <EvanR> theres aeson-pretty package
09:39:55 <ij> spreading the gospel of acid-state
09:40:11 <ertes> hehe
09:40:17 <orion> I like acid.
09:40:28 <EvanR> i would like acid-state better if it was so template haskelled
09:40:30 <EvanR> wasnt
09:40:33 <sybilsleaf> fwiw once you get the hang of acid-state it is easy enough to use for stuff like this, and you can use that experience to do much more complicated things
09:40:55 <sybilsleaf> EvanR: nothing to stop you writing instances by hand!
09:41:01 <EvanR> ... yeah.
09:41:05 <ertes> BTW, i think the word "overkill" is used far too often
09:41:20 <EvanR> would you say its overkill to use the word overkill in this case?
09:41:36 <sybilsleaf> ha, what word would you prefer?
09:41:43 <ij> ertes, Or perhaps solutions are overkill too often?
09:41:57 <ij> <philosoraptor.jpg>
09:42:00 <orion> Using "overkill" all the time is really overkill.
09:42:17 <EvanR> if solutions are really easy to use, i think the overkill idea dissipates
09:42:34 <EvanR> like zlib might seem overkill for compression if it wasnst so easy to integrate
09:42:42 <EvanR> or using shell commands
09:42:56 <sybilsleaf> Agreed, but in this case if you finding Aeson an uphill battle then acid-state might be a mountain
09:43:08 <Gurkenglas> or using lens
09:43:12 <ij> What does acid-state use to serialize things?
09:43:34 <sybilsleaf> SafeCopy and Serialize
09:43:59 <ij> Aeson wasn't difficult. It's just that using new libs always takes some thinking with haskell.
09:44:00 <sybilsleaf> but you rarely have to define instances yourself as there is template haskell stuff for doing that for you
09:44:44 <ij> (Perhaps because not a lot of examples are encounted upfront in docs.)
09:46:43 <sybilsleaf> yeah I had a bit of a headache with Aeson when I first started using it as well
09:49:00 <sybilsleaf> oh and just to be clear, if you used acid-state you probably wouldn't use Data.Ini, you'd define your own record type for whatever state you have, like data Config = {foo :: Boo, bar :: String, [...]}
09:49:19 <sybilsleaf> and then use deriveSafeCopy on that type
09:49:20 <ij> No, I wouldn't.
09:50:13 <ertes> ij: the notion of "overkill" relies on the complexity of a solution, but i think that it's mostly used when a solution just appears "too large" for a particular use case (not too complicated), and that intuitive notion often leads to poor solutions: "splitting this little piece of wood?  no need for a saw…  i can use this simpler kitchen knife"
09:50:36 <ertes> s/poor solutions/poor decisions/
09:50:50 <ij> that's some strawman right there
09:51:34 <Tuplanolla> Good solutions to problems are almost always more difficult than people realize at first.
09:52:32 <EvanR> my friend made a "MOO" with node.js (or similar), and hes periodically dumping the entire world to a json file (which takes a second). He is protecting himself from catastrophic failure by "keeping backups" ;)
09:52:46 <ij> Tuplanolla, That may or may not be true, depending on what the words you used mean.
09:52:52 <EvanR> all other things being equal, that sounds like the old days of modifying PHP files on a live site without git or SVN
09:53:02 <EvanR> which to me sounds terrible, thats all
09:53:47 <ertes> the real problem perhaps is that acid-state is the only solution we have right now =)
09:54:01 <EvanR> theres SQL
09:54:20 <EvanR> but none of that matters if ij wants a honest-to-god config file on the disk which is human readable and editable
09:54:27 <ertes> that causes the "the only solution that everybody evangelises, so i'm not gonna use it" effect =)
09:54:51 <ij> EvanR, Well I beg to differ with the terrible here, git takes out all the fun and challenge out of programming. /s 
09:54:59 <EvanR> ...
09:55:04 <sybilsleaf> ertes: I suspect you are right in general but also I think that acid-state in this particular example is also more complicated than json... 
09:55:12 <orion> ij: You want a config file that's modifiable by your program?
09:55:16 <EvanR> im ok with not manually repairing data corruption in a file
09:55:34 <ij> Please no more solutions, I'm fine already.
09:55:44 <orion> ij: I wasn't prepared to offer a solution.
09:56:04 <ertes> sybilsleaf: most likely you will write more code using aeson
09:56:06 <ij> Thank god. I want to dump IRC bot's state and config.
09:56:12 <EvanR> im on your side, but i dont understand the anti-git thing
09:56:23 <orion> ij: Ah, ok.
09:56:24 <ij> EvanR, Did you see the "/s"?
09:56:28 <EvanR> huh
09:56:34 <ij> </sarcasm>
09:57:40 <orion> Is anyone familiar with both the 'monad-coroutine' and 'free' packages?
09:57:45 <sybilsleaf> ertes: true, but you don't have to understand the state monad, safecopy's versioning system, checkpointing, archiving etc
09:57:51 <ertes> orion: yeah
09:58:08 <manulari> hey, question about haskell on arm: I managed to get stack and dependencies installed on qemu arm (user emulation) and it compiles runnable executables, but at the end it gives a lot of warnings from ld.gold about not being able to scan for Cortex-A8 erratum. googling I find a couple of bug reports which were marked as fixed a year ago. should I be turning of symbol stripping somewhere? if so, where?
09:59:28 <orion> ertes: I had lunch with Ed Kemett one time and he told me that I could easily use FreeT instead of Coroutine. I'm struggling to determine how to make that happen.
09:59:59 <EvanR> yes coroutines are a form of free-monadism
10:00:01 <ertes> orion: first realise that they are literally the same thing =)
10:00:37 <ertes> orion: it would be easier to see if FreeT wouldn't have this FreeF type and would just use Either
10:02:12 <orion> My current understanding of the word "free" is that I can take any Functor and make it a Monad, but the resulting data structure has no notion of computation.
10:02:37 <orion> From SO: "The user who creates such a free monadic value is responsible for doing something with those nested contexts, so that the meaning of such a composition can be deferred until after the monadic value has been created."
10:02:51 <ertes> that's correct
10:02:55 <ertes> but there is a different interpretation
10:03:25 <orion> Oh? What is it?
10:03:35 <ertes> FreeT F M  -- that's layers of F that may be generated by M-actions
10:03:42 <ertes> each layer represents a "breakpoint" of sorts
10:03:49 <EvanR> that sentence is overly complex for whats going on
10:04:03 <ertes> at each layer your interpreter gets to choose how to interpret that layer
10:04:22 <ertes> and after that the interpreter gets another FreeT F M (the continuation)
10:06:27 <EvanR> a free monadic program is either "return x" or "give me a y and ill give you a free monadic program"
10:07:05 <EvanR> so return or yield
10:07:10 <EvanR> coroutines
10:07:25 <xocolatl> I have a list of sentences and a list of words I don't want to appear in them (so, filter).  I have a feeling I should be able to use the list monad here somehow
10:07:50 <orion> EvanR / ertes: Here is my current Monad transformer: https://github.com/centromere/cacophony/blob/d876c0aa64582c57cc80673f6b6af6b3bd65e3d3/src/Crypto/Noise/Internal/Handshake.hs#L56
10:08:07 <orion> What's confusing me is the presence of "(Request ScrubbedBytes ScrubbedBytes)"
10:08:19 <hpc> orion: http://lpaste.net/2926236496656596992 - step-by-step translation from FreeT to Coroutine, which might help
10:08:22 <ertes> xocolatl: like a bad word filter?
10:08:48 <xocolatl> ertes: yeah, I guess like that.  (it's an exercise, not a real thing)
10:09:24 <orion> I specifically chose "Request" because, at any time during a run of my interpreter, I need to be able to pause the computation yielding ScrubbedBytes and resume it when a ScrubbedBytes response is available.
10:09:42 <ertes> orion: first find the definition of Request…  it's what monad-coroutine would call your "suspension functor"
10:09:54 <ertes> xocolatl: it's a list of strings, which you want to map over
10:09:55 <orion> ertes: Indeed. I have the haddocks up.
10:10:01 <xocolatl> ertes: for just one word, I'm using  filter (not . isInfixOf theword) thelist
10:10:11 <orion> data Request request response x -- "The Request functor instance combines a Yield of a request with an Await for a response."
10:10:30 <orion> hpc: Thanks, reviewing now.
10:10:48 <ertes> xocolatl: each individual string is a sentence, so the overall value you have is of type [String]?
10:11:21 <Gurkenglas> :t foldr (filter . (.) not . isInfixOf) -- xocolatl
10:11:22 <lambdabot> (Foldable t, Eq a) => [[a]] -> t [a] -> [[a]]
10:11:41 <xocolatl> ertes: correct
10:11:55 <ertes> xocolatl: you want to do the same thing to each individual String, right?
10:12:00 <xocolatl> Gurkenglas: I can barely read that now, much less next week
10:13:15 <ertes> xocolatl: what if the words appear within words?  like "def" should be filtered, but it appears in "abcdefghi"?
10:14:07 <xocolatl> ertes: its actually a string of letters and I need to ban certain combinations, so banning def in abcdefghi is desired
10:15:04 <xocolatl> ertes: http://lpaste.net/349481
10:15:05 <Gurkenglas> :t filter (\sentence -> all (not . (`isInfixOf` sentence)) ?badwords) ?sentences -- xocolatl
10:15:07 <lambdabot> (?sentences::[[a]], ?badwords::t [a], Foldable t, Eq a) => [[a]]
10:15:58 <hanshogl> anybody know what tool is being used to generate the hyperlinked sources on hackage base?
10:16:01 <hanshogl> e.g. http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Control.Applicative.html
10:16:03 <xocolatl> ertes: I figured I'd work on the third rule first
10:17:02 <xocolatl> I'm almost tempted to bust out a parser for this
10:18:10 <Gurkenglas> Surely reading the parser next week takes longer than figuring out what the oneliner means next week?
10:18:11 <ertes> ah… that's a much easier problem
10:18:20 <orion> hpc: Your paste was quite helpful.
10:18:20 <ertes> you just need to find out whether there is a bad word in a string
10:18:42 <ertes> i thought you need to actually remove the words
10:19:07 <Gurkenglas> hanshogl, https://hackage.haskell.org/package/haddock-2.17.2/changelog <- ctrl-f hyperlink
10:19:31 <ertes> xocolatl: are you aware of 'any'?
10:19:45 <ertes> > any even [1,3,5,7,9]
10:19:48 <lambdabot>  False
10:19:49 <ertes> > any even [1,3,5,6,7,9]
10:19:52 <lambdabot>  True
10:20:01 <Gurkenglas> hanshogl, https://github.com/haskell/haddock/pull/410
10:20:28 <ertes> xocolatl: for each individual string you could use 'any' (on the list of bad words) to find out whether there is a bad word in the string
10:20:36 <hanshogl> Gurkenglas: so answer is haddock > 2.17.2
10:20:37 <hanshogl> thx
10:20:43 <xocolatl> ertes: lemme go play with that
10:21:06 <ertes> xocolatl: that reduces your list of strings to a list of Bool, and you just count True
10:21:14 <Gurkenglas> hanshogl, no, >= 2.16.2
10:21:25 <xocolatl> well, I'll have two other rules to apply
10:21:35 <hanshogl> ok
10:22:40 <Gurkenglas> I'm teaching him how to not need to ask while he teaches me how to properly answer :D
10:23:11 <ertes> xocolatl: isGoodString xs = hasThreeVowels xs && hasLettersInARow xs && not (hasBadWords xs)
10:23:23 <ertes> xocolatl: map isGoodString :: [String] -> [Bool]
10:23:33 <ertes> that's the idea
10:24:20 <xocolatl> ertes: thank you
10:24:22 <xocolatl> ertes: but please don't tell me any more yet :)
10:24:29 <ertes> xocolatl: i won't =)
10:24:44 <ertes> santa must be one hell of a programmer…  or his elves work some serious magic
10:25:10 <xocolatl> it's last year's http://adventofcode.com/
10:25:25 <ertes> ah
10:25:46 <xocolatl> using it to learn me a haskell
10:26:03 <ertes> have fun =)
10:26:37 <xocolatl> it's been mostly fun, sometimes frustrating, so far
10:37:57 <orion> What law allows me to say that "Foo a b = a | b" is isomorphic to "Either a b"?
10:39:10 <hpc> alpha renaming
10:39:28 <hpc> @src Either
10:39:28 <lambdabot> Source not found. Are you typing with your feet?
10:39:31 <hpc> :(
10:39:46 <ski>   data Either a b = Left a | Right b
10:39:55 <hpc> or to get a bit fancier, the algebraic properties of algebraic data types
10:40:03 <ertes> orion: it's just the definition of type isomorphism
10:40:11 <hpc> "|" corresponds to (+), (,) and similar things correspond to (*)
10:40:12 <ertes> orion: it's not a law, but a property
10:40:14 <hpc> () is 1
10:40:20 <hpc> in this case, Either a b = a + b
10:40:27 <hpc> and similarly you can work out that Foo a b = a + b
10:40:47 <ertes> orion: what *is* a law is something like the associativity property w.r.t. isomorphism:  (a + b) + c ≃ a + (b + c)
10:41:26 <orion> ertes: So like, Either (Either a b) c === Either a (Either b c) ?
10:41:54 <hpc> yep
10:42:06 <ski> @djinn Either (Either a b) c -> Either a (Either b c)
10:42:06 <lambdabot> f a =
10:42:06 <lambdabot>     case a of
10:42:06 <lambdabot>     Left b -> case b of
10:42:06 <lambdabot>               Left c -> Left c
10:42:06 <lambdabot>               Right d -> Right (Left d)
10:42:08 <lambdabot>     Right e -> Right (Right e)
10:42:18 <orion> hmm
10:42:22 <hpc> @djinn Either a (Either b c) -> Either (Either a b) c
10:42:22 <lambdabot> f a =
10:42:22 <lambdabot>     case a of
10:42:22 <lambdabot>     Left b -> Left (Left b)
10:42:22 <lambdabot>     Right c -> case c of
10:42:22 <lambdabot>                Left d -> Left (Right d)
10:42:24 <lambdabot>                Right e -> Right e
10:42:26 <hpc> (and the other way)
10:42:27 <ski> (that's a fourth of the isomorphism)
10:42:46 <orion> So, the very fact that I can write a function whose type is "Either (Either a b) c -> Either a (Either b c)" mathematically *proves* that they are isomorphic?
10:43:04 <hpc> not quite, it's one of the mappings required
10:43:35 <ertes> orion: you need a function back, too, and the two have to be inverses of each other in both directions
10:43:55 <ertes> their existence is the definition of isomorphism
10:44:22 <orion> Ah, so the type checker alone can't determine is you're actually following the laws.
10:44:28 <orion> s/is/if
10:44:31 <hpc> or constructively, the isomorphism is that pair of functions plus the proof that they are inverses
10:44:39 <hpc> right
10:44:44 <orion> Cool.
10:44:44 <hpc> (at least not in haskell)
10:45:59 <hpc> there's some really cool other stuff you can do with algebra / other manipulations on ADTs
10:46:29 <hpc> through some shennanigans, http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/ this one demonstrates that 2^(2^N) = N
10:46:34 <hpc> (for N = natural numbers)
10:46:40 <ertes> orion: more generally types form a commutative semiring w.r.t. to Either, (,) and isomorphism
10:46:44 <orion> hpc: I believe you, but I don't have the experience necessary to appreciate what is going on.
10:46:48 <hpc> but that's doing some very hard to understand stuff
10:47:00 <hpc> it's a sneak peek ;)
10:47:03 <orion> heh
10:47:12 <ertes> orion: so you have:  ((a, b), c) ≃ (a, (b, c))
10:47:26 <ertes> (a, Either b c) ≃ Either (a, b) (a, c)
10:47:27 <ertes> etc.
10:47:31 <ertes> all the usual semiring laws
10:47:56 <orion> I sort of wish I had studied pure math in college instead of biochemistry.
10:48:12 <ertes> just look up the definition of semiring =)
10:48:31 <EvanR> hpc: er what, 2^N as in N -> Bool ?
10:48:38 <EvanR> or set theory shit
10:48:41 <hpc> orion: fortunately pure math is one of the easiest things to study outside college
10:48:44 <hpc> EvanR: right
10:48:50 <hpc> (N -> Bool) -> Bool = N
10:49:03 <EvanR> ...
10:49:03 <ertes> hpc: that…  doesn't sound right
10:49:17 <EvanR> where -> is recursive functions or 
10:49:43 <ski> orion : see e.g. "Seven Trees in One" by Andreas Blass in 1995 at <http://www.math.lsa.umich.edu/~ablass/comb.html>, for a fun example
10:49:48 <ertes> hpc: 2^(2^N) is the powerset of the powerset of the naturals…  it has to be larger than the naturals
10:49:54 <hpc> it uses Axiom: All functionals 2N→2 are uniformly continuous
10:50:16 <EvanR> 2^N -> 2 are uniformly continuous, what topology?
10:50:45 <ertes> ah, wait
10:50:58 <hpc> EvanR: it cheats by simply demonstrating in haskell ;)
10:51:05 <EvanR> ah scott
10:51:08 <ertes> yeah, i've read about that…  it's the exhaustively searchable infinite sequences thing, isn't it?
10:51:15 <ski> EvanR : cantor on the domain, discrete on the codomain
10:51:18 <hpc> yeah, one particular application of it
10:51:27 <hpc> there's a bunch of posts exploring it
10:51:44 <ski> ertes : it's related to it, yes
10:51:48 <ski> @where impossible
10:51:48 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
10:52:02 <ertes> yeah, constructive math weirdness =)
10:52:02 <EvanR> interesting
10:52:06 * hpc is currently on a tear through math.andrej.com and blog.sigfpe.com
10:52:10 <ski> this is also related to Brouwer's anti-classical axioms in his intuitionistic mathematics
10:52:12 <orion> ertes / hpc / EvanR: Is there another way to define a "suspension functor"? What I have is a Free Monad that *is* my AST data structure for my DSL.
10:52:13 <hpc> (and eventually existentialtype.wordpress.com)
10:52:29 <EvanR> does this count as constructive if were specifically using cantor space and uniform continuity
10:52:38 <ski> (specifically the fan theorem and bar induction/recursion)
10:52:52 <ertes> orion: that's the ideal case…  what do you need?
10:53:03 <ski> EvanR : it doesn't count as constructive in the ecumenical sense (iow Bishop)
10:53:09 <ski> (ecumenial ?)
10:53:12 <EvanR> what...
10:53:22 * EvanR has to learn a word today i guess
10:53:49 <hpc> EvanR: i never said it was constructive either :P
10:54:14 <hpc> iirc the author even said it's not even classical
10:54:19 <EvanR> haha
10:54:23 <ertes> i wanted to learn about this for a while now…  it's called synthetic topology, right?
10:54:40 <orion> ertes: In "FreeT f m a", is 'f' a way to "extend the functionality" of my "DSL Free Monad AST"
10:54:58 <hpc> f is your DSL
10:55:06 <hpc> m is what you get by adding "T"
10:55:12 <ertes> orion: the free monad of f is your DSL
10:55:15 <hpc> and a is the result of your DSL
10:55:28 <ertes> and f is sort of a template that still leaves typing the knot open
10:55:42 <ertes> imagine you would define your types using fixed points instead of recursion
10:55:42 <EvanR> i like that, "non-classical"
10:56:00 <ertes> now you do it using a free monad constructor instead of Fix
10:56:30 <ski> EvanR : it starts from the insight that it appears to be impossible to actually *construct* a function from `2^N' (type of infinite values) to `2' (type of finite values), that depends on infinitely many of the parts of the input. iow each function we seem to be able to construct here depends only on a finite prefix, so yields the same result for any other infinite sequence with the same prefix, iow is *continuous*. so Brouwer more or less added this as an 
10:56:46 <martinium> for a new programmer such as myself learning haskell as my first language how much time would it be before I would be able to create simple programs?
10:56:50 <ski> er, cut off near ".., iow is *continuous*. so Brouwer more or less added this as an axiom (iirc, actually added something from which this can be derived)"
10:57:43 <orion> I meant to ask: Does FreeT allow me to extend the functionality of my base Free Monad *in the same way* that, say, "ReaderT r m a" allows me to add "ask" functionality to a base IO Monad?
10:57:52 <hpc> martinium: depends on how complicated your idea of simple is, but generally under a day
10:58:24 <ertes> orion: sure, (FreeT f m) is just another monad in the universe of monad transformers
10:58:44 <hpc> martinium: http://lpaste.net/3386712812477743104 - a simple program example
10:59:09 <orion> ertes: Great. So now I see "data Request request response x -- The Request functor instance combines a Yield of a request with an Await for a response."
10:59:13 <ertes> orion: however, you do get a second option with free monads:  the a la carte approach:  f can be a product functor, a coproduct functor, etc.
10:59:30 <mnn> Is mconcat not implemented for all monoids? I'm a bit confused how it'd work with Sum and Product monoids
10:59:46 <orion> ertes: I am trying to integrate the knowledge I just demonstrated to you with the idea of the Request suspension functor.
10:59:51 <hpc> martinium: feel free to ask questions about how to get set up or what things mean
11:00:05 <Tuplanolla> @src mconcat
11:00:05 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:00:11 <ski> > (getSum . mconcat . map Sum) [2,3,5,7]
11:00:13 <lambdabot>  17
11:00:18 <hpc> @src mconcat
11:00:18 <lambdabot> Source not found. It can only be attributed to human error.
11:00:19 <ski> > (getProduct . mconcat . map Product) [2,3,5,7]
11:00:21 <lambdabot>  210
11:00:34 <hpc> mnn: mconcat = put "`mappend`" between every element of the list
11:00:45 <hpc> mnn: so imagine what 1 + 2 + 3 + 4 + 5 + ... means
11:00:46 <mnn> So in order to use mconcat, we have to have a list of the monoid type, right?
11:00:53 <hpc> mnn: and what 1 * 2 * 3 * 4 * 5 * ... means
11:01:05 <ski>   mconcat = foldr mappend mempty  -- iirc
11:01:19 <ski> @type mconcat
11:01:20 <lambdabot> Monoid a => [a] -> a
11:01:27 <mnn> > (mconcat . map Product) [1,2,3,4,5]
11:01:29 <lambdabot>  Product {getProduct = 120}
11:01:30 <martinium> hpc thats definitely a simple program hehe
11:01:39 <mnn> ski, hpc  Thanks, that makes sense
11:01:46 <orion> ertes: What I've basically realized is that the "Request" suspension functor carries with it certain functionality (the "request" function -- "Suspend yielding a request and awaiting the response.") just like how ReaderT carries with it "ask" functionality.
11:02:09 <ski> orion : ooc, how's `Request' defined ?
11:02:11 <hpc> martinium: indeed, though be prepared to learn stuff from it nonetheless!
11:02:29 <orion> ski: data Request request response x = Request request (response -> x)
11:02:41 <EvanR> ski: it claims that you can represent such a function using *finite* information. still reading. i remember noticing that fourier or wavelets represented uncountable stuff with countable coefficients, this is even better ;)
11:02:52 <martinium> hpc ironically I just did. I just realized that the getLine function takes a users input
11:03:06 <martinium> <- applies the result of that to the variable in your example
11:03:28 <martinium> so far I had only been used to seeing -> for function arguments and return types
11:03:38 <ski> orion : ok, so `Free (Request request response)' is something like a SSP type, then
11:03:41 <hpc> :D
11:03:43 <orion> ski: SSP?
11:03:54 <ski> Synchronous Stream Processor
11:04:38 <orion> Yes.
11:04:58 <orion> I probably could use pipes or conduit, but it "feels" weird to do so.
11:05:01 <ertes> orion: FreeT (Request a b) m r ≃ m (Either r (Request a b (FreeT (Request a b) m r)))
11:05:09 <ski> typically `newtype SSP a b = GetPut (a -> (b,SSP a b))' (whereas `data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)', is Asynchronous Stream Processor)
11:05:35 <ertes> ≃ m (Either r (a, b -> FreeT (Request a b) m r))
11:05:42 <ski> in your case, you put before you get, and you also have the option (on the side of the "stream processor) of deciding to finish with an answer (of type `x')
11:06:20 <ertes> orion: that means: each time you use 'wrap' (or 'liftF' or even just Free explicitly) your monad yields an 'a' and takes a 'b' to continue
11:06:31 <orion> ertes: Exactly.
11:06:45 <ertes> orion: ok, perhaps i don't understand your question
11:06:58 <ski> martinium : to be pedantic, `getLine' is not a function (all functions takes an argument, `getLine' doesn't). it's an I/O action, a "recipe" describing how to do I/O (iow communicate with the OS, and through that possibly the outer world) in order to get back a `String' (in this case)
11:07:05 <orion> ertes: What was my question?
11:07:35 <ertes> <orion> ertes: I am trying to integrate the knowledge I just demonstrated to you with the idea of the Request suspension functor.
11:07:41 <hexagoxel> [shake] does anyone have a BuildBuild.hs that handles compilation/running of Build.hs?
11:07:41 <ertes> perhaps there was no question at all =)
11:08:09 <ski> martinium : in `do'-notation, `<-' executes the action to the right (in this case `getLine'), binding the result you get from that to the thing to the left (here `text', so `text' is now the name for the read line (a text string))
11:08:48 <orion> ertes: Yes. Basically you're feeding me knowledge and my brain is trying to combine it with previous knowledge/experience to crystallize in to something beautiful.
11:10:07 <ski> martinium : otoh, the `let number = read text' doesn't perform any I/O execution. it simply uses an internal ("pure","mathematical") function `read' in order to convert (translate) this text string to a number (called `number' here) (assuming the text string contains a string numeral consisting of digits, and perhaps a leading negative sign. otherwise you'll get a run-time error, in case the line you enter can't be read as a numeral)
11:10:27 <ski> (hm, possibly cut off : ".. otherwise you'll get a run-time error, in case the line you enter can't be read as a numeral)")
11:10:33 <ertes> orion: there really isn't too much to free monads…  it's a similarly "boring" concept as fixed points
11:10:43 <ski> martinium : does this help at all ?
11:11:41 <ertes> orion: there are some fancy ways to combine free monads with cofree comonads to have a more principled notion of interpreter, but i found it too awkward to work with…  and then there is the fact that your functor may be a composite of multiple functors
11:12:10 <ertes> what else?  oh yeah: there are a few equivalent definitions of free monads…  you would typically not use FreeT unless/until you have to
11:12:11 <hpc> martinium: (you have permission to be confused)
11:12:26 <orion> ertes: I could memorize Functor/Monad laws and regurgitate them back, but that doesn't necessarily lead me to intuition, which is really my goal.
11:13:03 <ertes> orion: ah, an intuition…  i suggest you just work with them for a while…  they aren't much different from recursive ASTs
11:13:10 <ertes> that's why we have "interpreters" for free monads
11:13:28 <orion> ertes: Indeed -- that's exactly what I'm trying to accomplish here.
11:13:34 <ertes> they are literally interpreters with a twist: the ASTs can be dynamically generated and infinite
11:14:03 * ski would like to be able to have multiple (coherent) definitions of a single `newtype'
11:14:06 <ertes> so one layer of the AST can dynamically decide what it contains depending on the interpreter
11:14:48 <ertes> like your "request function" of the Request functor does
11:15:00 <orion> ertes: Makes sense.
11:15:17 <ski>   newtype State s a = MkState (s -> (a,s))
11:15:20 <ski>   newtype State s a = StateFromStateT (StateT s Identity a)
11:15:22 <ski>   newtype StateT s m a = MkStateT (s -> m (a,s))
11:16:29 <ski> ought to be possible, at the same time, with `MkState = StateFromStateT . MkStateT . (MkIdentity .)'
11:16:59 <ski> (or at least it should work when the immediate body of the monadic transformer is wrapped with `m')
11:17:00 <glguy> ski: Can't you do that with coerce and pattern synonyms?
11:17:44 <orion> ertes: Imagine that you have a DSL where every instruction/operation is part of your Free Monad (data Foo next = A next | B next | C next). Now imagine that you define 16+ programs *only* in terms of those primitive operations.
11:17:58 <ski> glguy : i don't know
11:18:15 <orion> ertes: Now imagine that Alice and Bob are connected by TCP, and they are both running the same program in lock-step.
11:19:09 <orion> And at every step, the DSL interpreter pauses to consume data from the remote party and generate a response.
11:19:20 <orion> That's my overall goal.
11:23:21 <orion> And I have accomplished this goal: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/HandshakePatterns.hs
11:24:15 <mnn> Why does this work? : foldr mappend mempty ([2, 4, 6] :: [Product Int])
11:24:23 <orion> However, as Ed Kmett pointed out, I am relying on monad-coroutine, when all the functionality I need is provided by FreeT and friends.
11:24:41 <mnn> How can we just say the type of the list is [Product Int] when all the values inside are not wrapped?
11:25:08 <lyxia> mnn: numeric literals are overloaded
11:25:12 <lyxia> :t 2
11:25:14 <lambdabot> Num t => t
11:25:20 <lyxia> Product Int is an instance of Num
11:25:38 <mnn> lyxia, Got it, the instance of Num was the missing link
11:25:41 <mnn> Thanks!
11:27:52 <EvanR> orion: i wrote an eavesdropper program to mediate the conversation through alice and bob without them noticing... but i needed to use async, there was no theory behind it
11:28:03 <EvanR> async made it really easy though
11:28:45 <EvanR> between alice and bob
11:29:32 <EvanR> get a chunk, remember it for decrypting or decrypt now (since we cracked their crypto), forward it regardless
11:30:24 <EvanR> since there was multiple things going on at once, i didnt know how to make a well typed interpreter
11:31:36 <orion> EvanR: Neat.
11:32:24 <EvanR> saying async might be more flexible once things get too complicated
11:33:24 <orion> EvanR: Do you think you could have accomplished your goal more succinctly using Pipes?
11:34:21 <EvanR> no since there were two directions of communication, two stages of the protocol (someone connects before the other), and a side task to do the cracking computation that both channels needed to react to when it was done
11:34:48 <EvanR> but i heard there is pipes-concurrent
11:35:18 <ertes> orion: if all else fails all you need to do is to translate everything that monad-coroutine does to free…  you just need to change a few names basically
11:35:44 <orion> ertes: Indeed. hpc's paste wil be instrumental for that.
11:36:41 <orion> ertes: Although, I'm not sure the "free" package provides a suspension functor at all. I'll have to copy/paste it from monad-coroutine.
11:36:53 <ertes> orion: keep in mind that Coroutine and FreeT aren't just equally expressive…  they literally are the same thing
11:37:08 <EvanR> orion: i mean that workflow was less than a screen of async, while i know free monads structure setup takes more
11:37:22 <ertes> orion: fun experiment: use monad-coroutine's suspension functors with FreeT =)
11:37:48 <orion> ertes: Ha, I feel confident in doing that, but my goal is to eliminate a package dependency.
11:37:51 <ertes> perhaps translate the resulting FreeT back to Coroutine and use pogoStick
11:37:52 <ertes> etc.
11:39:44 <orion> instance Functor (Request x f) where map f (Request x g) = Request x (f . g) -- That seems to be where the magic happens.
11:39:59 <orion> s/map/fmap
11:40:02 <ertes> orion: (side note: -XDeriveFunctor)
11:41:55 <ertes> orion: all "command language"-style DSLs follow the same pattern:  data F x = CmdA (RespA -> x) ReqA | CmdB x ReqB | CmdC (RespC -> x) | CmdD x
11:42:31 <ertes> (i like to put the response field first, because that composes better with liftF/wrap)
11:42:59 * hackagebot hinotify 0.3.9 - Haskell binding to inotify  https://hackage.haskell.org/package/hinotify-0.3.9 (LennartKolmodin)
11:43:13 <ertes> orion: here is a command that aborts the program:  | CmdE
11:43:33 <ertes> orion: here is one that offers *two* continuations:  | CmdF (RespF1 -> x) (RespF2 -> x)
11:43:34 <orion> Yes -- it doesn't accept another instruction in the AST.
11:43:34 <ertes> etc.
11:44:01 <ertes> it's all about what choices the interpreter gets
11:45:57 <orion> ertes: "data Request request response x = Request request (response -> x)" -- Does 'x' here serve the same purpose that 'next' does in "data Foo next = A next | B next | C next" ?
11:46:12 <ertes> yeah
11:46:57 <ertes> it's the tie-in point for recursion…  the "type of the future" =)
11:47:28 <ertes> (which is just another free-monadic expression using the same functor, if you use FreeT)
11:47:59 * hackagebot BlogLiterately 0.8.4.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.4.3 (BrentYorgey)
11:48:31 <ski> one could think of it more or less as `self'/`this', in that case
11:50:06 <ski> (that's, strictly speaking, more appropriate for `Fix'/`Nu' (or `Mu', if you prefer), since `Free' and `FreeT' have an extra "stop now" case)
11:50:34 <ertes> theFreeMonadOfMe
11:50:41 <EvanR> btw i found a definition of continuous type, at least if the type has an ordering (partial or not) with suprema: a type with ordering with suprema is continuous if for all x the sup of the collection of everything way below x = x
11:52:17 <orion> ertes: In your previous example, are ReqA and RespA (etc) type synonyms for, say, ByteString?
11:52:20 * ski . o O ( <https://en.wikipedia.org/wiki/Complete_partial_order> )
11:53:17 <ertes> orion: yeah…  ReqA is a placeholder for the command's arguments, while RespA is a placeholder for the result
11:54:18 <EvanR> yeah i dont think this involves directedness, except in the definition of way below
11:54:50 <orion> ertes: What's the difference between CmdD and CmdD?
11:54:52 <orion> ertes: What's the difference between CmdD and CmdC?
11:55:12 <ertes> (i'd really like to learn this stuff, but nobody has paid attention to my questions =/)
11:55:25 <ertes> orion: CmdD is the same as CmdC, if RespC = ()
11:55:30 <ertes> a command without a result
11:55:43 <EvanR> any two elements have a least upper bound, which isnt not necessarily the case with DCPOs
11:57:17 <orion> ertes: What's the meaning of data F x y z = CmdA (RespA -> x) (RespA -> y) (RespA -> z) ReqA?
11:57:23 <orion> Or does that question make no sense?
11:57:56 <ertes> orion: (F x y) is a functor…  the continuation type in the definition is z
11:58:13 <ertes> orion: x and y have no special meaning
11:58:15 <ski> different "continuation" types `x',`y',`z'
11:58:29 <ertes> (in the context of FreeT)
11:58:50 <eklavya> is there an intero channel or should I ask here?
11:59:32 <orion> I See.
12:00:44 <byorgey> eklavya: I don't know, but you're welcome to ask here
12:01:07 <ski> (seems the channel exists .. dunno who's there)
12:01:26 <eklavya> byorgey: thanks :)
12:01:30 <Lokathor> foldr is giving me the wrong results
12:01:32 <Lokathor> how mysterious
12:01:45 <eklavya> ski: is it #intero? I think I tried that?
12:01:59 <eklavya> let me try haskell-intero
12:02:15 <ski> (oh, perhaps it was you who were in there, since now it appears to be gone)
12:02:24 <eklavya> :D
12:02:59 <eklavya> intero is failing to build with some type errors
12:02:59 * hackagebot haskell-gi-base 0.20 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.20 (inaki)
12:03:01 * hackagebot haskell-gi 0.20 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.20 (inaki)
12:03:27 <ertes> i don't like a lot about IRC, but one thing i do like:  its lazy notion of channel =)
12:03:40 <eklavya> this is the project
12:03:41 <eklavya> https://github.com/jfdm/smokehill.git
12:04:03 <eklavya> and the error:
12:04:07 <eklavya>         • Couldn't match type ‘ghci-8.0.1@ghci-8.0.1:GHCi.RemoteTypes.ForeignRef
12:04:08 <eklavya>                                  ghci-8.0.1@ghci-8.0.1:GHCi.BreakArray.BreakArray’
12:04:08 <eklavya>                          with ‘ForeignRef BreakArray’
12:04:34 <byorgey> eklavya: that looks suspiciously like you have multiple versions of the ghci package installed, and it is picking the wrong one
12:04:44 <orion> Wait, I think I just had a stroke of insight.
12:04:58 <eklavya> isn't that supposed to not happen with stack builds?
12:05:02 <Lokathor> why is foldl' not in the prelude when foldl is, i wonder. Isn't using non strict left folding almost always a bad plan?
12:05:04 <cocreature> eklavya: so are getting an error when building intero or is intero failing to build smokehill?
12:05:14 <eklavya> when building intero
12:05:18 <byorgey> eklavya: indeed, I was just going to ask whether you are using stack.
12:05:19 <eklavya> version 0.1.20
12:05:26 <cocreature> Lokathor: the answer is probably “historic reasons”
12:06:04 <cocreature> Lokathor: just like the answer to the question, why sum and product use foldl instead of foldl'
12:06:21 <cocreature> I really wish we could get rid of that but at this point it’s probably too late
12:06:21 <Lokathor> oh those blasted historic reasons
12:06:43 <Lokathor> adding a symbol seems easier than removing them though
12:06:51 <orion> ertes: Let's say hypothetically my DSL is "data Foo next = CmdA next | CmdB next | CmdC next". The other constraint is that all three commands must take a ByteString as input and must return a ByteString as output.
12:06:53 <Lokathor> even if we need to make it sum and sum'
12:07:05 <ertes> cocreature: it wouldn't be a change in semantics, so we could change it whenever we want =)
12:07:09 <orion> Rather than relying on some suspension functor, couldn't I just change the definition of Foo?
12:07:30 <orion> To be: data Foo next = CmdA ByteString (ByteString -> next) | CmdB ... ?
12:07:44 <cocreature> ertes: is that really true for any instance of Num?
12:07:49 <ertes> orion: sure, that's how i would do it
12:08:01 <ertes> orion: Foo *is* your suspension functor…  you're defining it
12:08:06 <cocreature> without having thought too long about it seems like you could make an instance that would throw an exception in one case and not in the other
12:08:32 <ertes> cocreature: yeah, it is…  semantically foldl = foldl'
12:08:44 <ertes> it would just change the time/memory behaviour of some programs
12:09:01 <cocreature> I’ve yet to see an instance where it is useful to have a lazy sum
12:09:18 <ertes> orion: in this particular case i would even consider collapsing the three different commands into one with a selector argument
12:09:26 <cocreature> or rather enough instances to convince me that it should be lazy by default
12:09:39 <orion> ertes: Just to confirm my knowledge/understanding... what I've just proposed to you is isomorphic with FreeT (Request request (response -> next)) Foo a -- correct?
12:10:21 <ertes> orion: huh?  no, don't think so
12:10:50 <ertes> orion: in (FreeT f m), the 'm' is for effects that construct the AST, not for the AST itself
12:11:30 <Gurkenglas> All this changing APIs stuff would be much easier if we got a system in place where each API change is accompanied by a bijection between code written against the old/new API.
12:11:31 <eklavya> byorgey: there are a bunch of warnings in the log
12:11:44 <eklavya> here's the full log
12:11:45 <eklavya> http://lpaste.net/349485
12:13:07 <ertes> cocreature: yeah, i agree…  even if examples like that existed, the forcing of foldl' doesn't really add much extra cost
12:13:27 <ertes> and it's easy enough to write "foldl (+) 0" instead of "sum" to eliminate even that
12:13:30 <hpc> orion: for example, if you wrote a DSL that encodes a restricted subset of IO, m would be IO
12:13:41 <orion> ertes: Hmm, let me reword my question: Is the following statement true?: There are at least two says to accomplish request/response semantics: 1. Use the Free Monad transformer FreeT to "bolt on" the Request suspension functor to my existing Free Monad, 2. Redefine my existing Free Monad to accept inputs and outputs directly (CmdA ByteString (ByteString -> next) | CmdB ...)
12:13:47 * ski nods to Gurkenglas
12:14:05 <hpc> maybe data F a = GetLine (String -> a) | PutStrLn String
12:14:47 <ertes> orion: i think you have a misconception on what the 'm' does
12:15:19 <ertes> orion: (Free f) is a free monad generated by the functor 'f', right?
12:15:37 <orion> ertes: Yes.
12:15:49 <ertes> orion: (FreeT f m) is a similar thing, except that it allows m-effects within expression
12:16:06 <orion> "within expression" = within the interpreter?
12:16:18 <hpc> yes
12:16:18 <orion> Or within the program specification?
12:16:27 <hpc> m is where the interpreter lives
12:16:28 <ertes> orion: no, within AST expressions…  the interpreter can have arbitrary effects
12:16:34 <hpc> er
12:16:57 <hpc> to some extent, it's within both
12:17:23 <ertes> the interpreter needs to interpret the 'm', too, sure, but it doesn't have to live in m…  let m = State s, then the interpreter can still do IO
12:17:29 <ertes> but the AST can only use state effects
12:18:00 * hackagebot fmt 0.0.0.2 - Nice formatting library  https://hackage.haskell.org/package/fmt-0.0.0.2 (Artyom)
12:18:12 <orion> So if your goal is to restrict IO usage, you don't want m = IO.
12:18:39 <ertes> orion: question: do you even need effectful ASTs?  i mean: do your AST actions need any effects other than the commands the functor defines?
12:19:24 <hpc> orion: m doesn't occur in the definition of f, so you still can
12:19:34 <hpc> orion: basically, m determines what you get out of runFreeT
12:19:45 <hpc> if m = State s, and you want to represent IO in your f
12:20:00 <hpc> you still can and you get State s (...) as the result of runFreeT
12:20:17 <hpc> and then another bit of stuff you write has to make the rest of the translation to IO
12:20:23 <orion> ertes: No, I do not want to allow any instructions other than the ones I define.
12:20:35 <ertes> orion: then i suggest that you don't use FreeT to begin with
12:20:55 <ertes> generally you can just use MonadFree…  then your functor works with *all* free monad constructors for free
12:21:12 <ertes> and your interpreter should probably just take (Free f a) instead of (FreeT f m a)
12:22:29 <ertes> let:  data ProgF x = GetLine (Text -> x) | PutLine x Text
12:22:40 <orion> ertes: Sure, but that goes back to my question: Is using FreeT + the Request suspension functor + my Foo AST/DSL isomprohic to redefining Foo such that "CmdA next" becomes "CmdA (ByteString -> next) ByteString"?
12:22:41 <ertes> then:  myGetLine :: (MonadFree ProgF m) => m Text
12:23:03 <ertes> myGetLine = liftF (GetLine id)
12:23:24 <ertes> i don't even understand that question
12:24:15 <ertes> i think you have a misunderstanding in the role of the 'm'…  in particular m needs to be a *monad*
12:27:26 <Tritlo> I made a minimal example of dependent types in haskell (https://gist.github.com/Tritlo/fb18a934f562763c8762046cd18e2d01), but was suprised to find that TypeInType was unnecessary. Could someone ELI5 what TypeInType adds?
12:29:07 <orion> 13:57:21 < orion> I meant to ask: Does FreeT allow me to extend the functionality of my base Free Monad *in the same way* that, say, "ReaderT r m a" allows me to add "ask" functionality to a base IO Monad? -- You answered in the affirmative.
12:29:45 <ertes> orion: not quite in the same way…  'm' is for effects the interpreter can only understand "as a whole"
12:30:22 <ertes> orion: example: let m = State s, then the interpreter cannot see individual 'put' or 'modify' invocations…  it can only ever see a stateful function
12:30:53 <orion> "see"?
12:32:23 <ertes> Tritlo: it lets you use 'forall' on kinds (along with TypeApplication, if you use it)…  it gets rid of the complexity of communication between types and kinds…  for example the KProxy from the singletons package type becomes obsolete
12:33:00 * hackagebot BlogLiterately-diagrams 0.2.0.5 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.5 (BrentYorgey)
12:33:24 <ertes> Tritlo: it gives you "dependent kinds" basically by collapsing the type and kind language…  it also lets type classes work for kinds, so you get kind classes
12:33:25 <ertes> etc.
12:34:25 <ertes> orion: if you write an interpreter for a free monad, it sees individual commands (CmdA, CmdB, CmdC, etc.), and it can choose how to interpret them
12:35:02 <ertes> you can't use the 'm' for that, because that one has to be a monad in FreeT semantics
12:35:26 <ertes> instance (Functor f, Monad m) => Monad (FreeT f m)
12:35:41 <ertes> the 'm' is *not* an extension mechanism…  it's an effect mechanism
12:36:10 <hpc> that's a good way to put it
12:37:04 <hpc> for instance, you could write a DSL for f that wants to read from standard input, and then write an interpreter that doesn't do any IO
12:37:15 <hpc> and instead always feeds the string "NUH UH!"
12:37:28 <hpc> but that f would "intend" for m to be IO
12:38:18 <hpc> "wants to read from standard input" meaning you want it to, and have named the command as if that's what it will be interpreted as
12:38:48 <ertes> an actual extension mechanism would be to use Coproduct (and sometimes Product) to construct f…  (Coproduct F G) is the functor that has commands from both F and G
12:38:48 <orion> Sure, that all makes sense.
12:39:36 <hpc> side question, why is Product = Coproduct?
12:39:49 <orion> ertes: Ok, so if m = State s, I have "injected" stateful functionality in to my DSL f?
12:40:00 <akegalj> I don't have any audio processing experiance but I would like to create a program that captures audio stream and then does some audio processing. Can someone point me how could I caapture audio stream with haskell and split the stream in areas of silence. I know it is too general but I don't have starting point so far. OpenAL seems like an overkill for this usecase
12:40:03 <ertes> hpc: huh?
12:40:14 <orion> injected / bolted on / extended the functionality of f to include / ...
12:40:26 <ertes> orion: no, you did not extend f…  i'm not going to repeat that again
12:40:36 <orion> Ok, sorry. :/
12:42:10 <ertes> akegalj: i'd usually recommend the sdl2 library for the capturing part
12:42:18 <hpc> orion: f is just a data type which encodes some sort of domain-specific language
12:42:37 <orion> I think poor communication is happening because of a lack of clarity on how words are defined.
12:42:46 <hpc> orion: if interpreting that language is meant to have some sort of effects beyond being a pure calculation, that goes in m
12:42:48 <akegalj> ertes: thnks. Do you have some advice for light audio processing ?
12:43:10 <ertes> orion: no, the problem is that you're *still* trying to read some extension mechanism into the 'm', when i told you repeatedly that there isn't one
12:43:13 <hpc> so it's more like m is the context in which f is executed
12:43:20 <Lokathor> if I have a [Int] what's the oneliner thingy to use (,,) and make a (Int,Int,Int)
12:43:31 <hpc> but you can't go "beyond" the capabilities of m
12:43:40 <ertes> akegalj: sorry, no…  just hang around =)
12:43:58 <orion> ertes: Sorry for being frustrating. It's not my intention.
12:44:24 <ertes> akegalj: maybe also ask in #haskell-game, even if it's not game-related…  it's a less noisy channel, so questions don't vanish in the backlog as quickly as here
12:44:31 <orion> hpc: When you say "executed" do you mean "interpreted"?
12:44:41 <orion> Are those terms synonymous?
12:44:51 <akegalj> ertes: thanks, didn't know there is such channel 
12:44:53 <Tritlo> ertes: ah, ok. Are there any practical examples of kindclasses}
12:44:56 <Tritlo> *?
12:46:18 <hpc> orion: in this case yes
12:46:27 <hpc> but i should have said interpreted
12:46:49 <ertes> orion: (FreeT f m) is the monad m enriched with f-commands, but the f-commands have no semantic meaning by themselves…  there needs to be an interpreter (typically itself in m) that gives them meaning
12:47:00 <orion> hpc: "if interpreting that language is meant to have some sort of effects" ==? "the interpreter lives in"
12:47:43 <ertes> orion: without the interpreter f-commands are just "breakpoints": "ok, here i need an interpreter to continue"
12:48:09 <orion> ertes: That makes sense.
12:48:57 <ertes> orion: edge case:  data VoidF a  deriving (Functor)
12:49:07 <ertes> orion: FreeT VoidF m ≃ m
12:49:14 <ertes> that's m with no extra commands
12:49:51 <ertes> data Unit a = Unit  deriving (Functor)
12:50:02 <akegalj> ertes: I round exactly what I need. Will probably have to tweak it a bit to cancel the noise https://hackage.haskell.org/package/split-record  . Thanks for the help
12:50:07 <akegalj> I found*
12:50:28 <ertes> (FreeT Unit m) is m with an extra command to "abort"
12:50:33 <orion> Ok, I think I understand why I was wrong.
12:50:58 <hpc> orion: while you digest ertes's explanation, a good exercise might be http://lpaste.net/6711100834832187392
12:51:14 <orion> With FreeT I am *not* extending my DSL instruction set in any way.
12:51:30 <orion> If I wanted to do that, I would use Coproduct, as you said.
12:51:35 <hpc> which should show the separation between the DSL and the interpreter's effects
12:51:48 <ertes> Tritlo: i'm not aware of any, sorry…  but you might observe the singletons library becoming a lot simpler, if they actually start to use -XTypeInType
12:52:49 <ertes> Tritlo: you could also think of some basic examples yourself:  class TNum k where type (a :: k) + (a :: k)  -- something like that should work
12:54:05 <ertes> before that you had to use some awkward KProxy-based stuff that was really hard to read
12:54:39 <ertes> whenever KProxy was needed, things got awkward
12:57:30 <orion> hpc: Did you mean "GADTs" instead of "GADTSyntax"?
13:00:14 <augur> so where is Control.Monad.State normally? it seems to not be part of Base anymore??? how do i get it installed universally so i can poke around without having to do a whole cabal sandbox install?
13:00:26 <hpc> orion: probablly
13:00:58 <hpc> ah, i did
13:02:12 <Tritlo> ertes: So I can do: class Addable k where type (a :: k) + (b :: k) :: k
13:02:43 <Tritlo> ertes: and then instance Addable Nat where type (Z + a) = a \n type (S a + b) = S (a + b)
13:02:53 <Tritlo> ertes: but even that only requires PolyKinds to compile.
13:04:16 <ertes> Tritlo: no, that one requires TypeInType, because k is a kind, and classes can only depend on types
13:04:24 <ertes> with TypeInType kinds and types are the same thing
13:05:01 <ertes> augur: Control.Monad.State has never been in base…  it's in mtl
13:05:40 <augur> isnt mtl included by default? or has it always been separate?
13:05:53 <augur> i feel like i've been able to use State without having to state things before
13:06:00 <augur> without having to install things **
13:06:30 <ertes> augur: your distribution may have had installed mtl globally, and now doesn't anymore…  or you may have cabal-installed mtl user-wide
13:06:41 <augur> hmm
13:06:52 <augur> how would i install mtl user-wide?
13:07:10 <augur> maybe just cabal install mtl w/o the sandbox?
13:07:31 <ertes> yeah, exactly, although in sandboxes user-wide packages are not visible (intentionally)
13:10:36 <Tritlo> ertes: Hmm. It compiles for me on 8.0.1. Maybe it's a bug? I remember reading somewhere that there might be some leakage.
13:11:57 <Tritlo> ertes: You can try it here: https://gist.github.com/Tritlo/ce5510e80935ac398a33934ee47c7930
13:43:03 * hackagebot idris 0.99 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.99 (EdwinBrady)
13:44:33 <augur> does anyone know how Hoogle does type-based lookup?
13:44:52 <hpc> augur: inconsistently ;)
13:44:59 <augur> hpc: :p
13:45:17 <augur> sure, but i mean, what's the technique it uses for finding things like what you typed in?
13:45:38 <hpc> yeah, dunno :P
13:46:08 <marutk> why  doesn't this function compile?
13:46:09 <marutk> appHomomorphism :: (Applicative f, Eq (f b)) => (a -> b) -> a -> Bool
13:46:10 <marutk> appHomomorphism f a = (pure f <*> pure a) == pure (f a)
13:46:10 <marutk>  
13:47:00 <marutk> Could not deduce (Eq (f0 b)) from the context: (Applicative f, Eq (f b))
13:47:19 <hpc> which f is being used?
13:48:00 <hpc> or rather, how could you constrain the type of appHomomorphism to decide what f to use
13:49:20 <marutk> I don't  know  ,    I  tried  to write function that checks Applicative homo-morphism
13:53:11 <hpc> you will find the following typechecks:
13:53:11 <hpc> appHomomorphism :: (Applicative f, Eq (f b)) => f () -> (a -> b) -> a -> Bool
13:53:11 <hpc> appHomomorphism proxy f a = (pure f <*> pure a) == (pure (\() x -> x) <*> proxy <*>pure (f a))
13:53:23 <hpc> what's happening is it doesn't know which f to pick for actually performing the computation
13:53:52 <marutk> yes,  I suspected that,  thank you  
13:53:59 <hpc> you have a class constraint against a type variable that doesn't occur in appHomomorphism's type
13:54:07 <hpc> and saying Applicative f there just defines an independent f
13:54:11 <hpc> so the error says f0
13:54:29 <hpc> my version of ghc says     Could not deduce (Applicative f0) arising from a use of ‘<*>’...
13:54:35 <hpc> as well as the error you pasted
13:54:50 <hpc> which pinpoints the issue a bit better
13:54:57 <orion> hpc: I'm stuck: https://dpaste.de/TqgT (lpaste seems down)
13:55:22 <hpc> that gross proxy trick just connects f to what you're already doing
13:55:34 <marutk> ok, I see
13:58:01 <ertes> Tritlo: that sounds like a leak, yeah
13:58:16 <ertes> Tritlo: consider reporting it
13:58:23 <hpc> orion: http://pastebin.centos.org/58901/ - here's my full solution
13:58:34 <hpc> orion: in retrospect the template i gave you was a bit crap
13:59:46 <hpc> orion: let me revise it a bit
14:02:08 <hpc> http://pastebin.centos.org/58906/ - that should do you nicely, with the solution to peek at when something is tricky
14:02:36 <hpc> it might be easiest to work on those functions from the outside in
14:02:50 <hpc> pureInterp = undefined
14:02:57 <hpc> pureInterp = runFoo undefined
14:03:06 <hpc> etc, refining and watching type errors
14:03:30 <hpc> (FreeT is even hard to teach)
14:03:55 <orion> hpc: Did you see my attempt at a solution?
14:04:13 <orion> I feel like I was on the right track.
14:10:57 <hpc> yeah
14:14:03 <hpc> your data type will need some changes, and a bit of a warning, the trappings around running the FreeT action are going to be a bit of a pain
14:15:39 <ertes> case encodeFloat 1 (-1074) :: Double of 0 -> Left "division by zero"; d -> Right (1 / d)
14:15:42 <ertes> > case encodeFloat 1 (-1074) :: Double of 0 -> Left "division by zero"; d -> Right (1 / d)
14:15:44 <lambdabot>  Right Infinity
14:16:02 <ertes> orion: ^
14:16:36 <Gurkenglas> Is there a library that exposes [(String, Bool)] -> String -> Bool, which throws ML at the list to extrapolate a label for the second argument string?
14:17:12 <ertes> orion: if you want to avoid infinity, check for infinity using isInfinite, not for zero denominator
14:17:14 <hpc> ertes: eeeew
14:17:26 <ertes> and also isNaN
14:20:23 <orion> Thank you.
14:26:02 <cloudhead> is there a clever way to compare existentially qualified values
14:26:50 <ertes> cloudhead: is the question: "i have a way to compare them, is there a cleverer one?", or is it: "how do i compare them?"?
14:26:52 <cloudhead> I have something like `data E = forall a. (Show a, Ord a, Eq a) => E a`
14:27:09 <ertes> cloudhead: you can't in that case
14:27:12 <cloudhead> ertes: I have a way which I dislike
14:27:22 <cloudhead> which is to convert them first
14:27:30 <ertes> cloudhead: that's the only way
14:27:40 <ertes> in fact the Eq is useless there
14:27:49 <ertes> because you only have a single value of that type
14:27:54 <cloudhead> so is there some instance I could use that would be good for this?
14:27:56 <ertes> Ord is similarly useless
14:27:57 <cloudhead> yeah you're right..
14:28:08 <cloudhead> I need those instances on the wrapper
14:28:41 <cloudhead> well why is Ord useless though?
14:28:45 <ertes> cloudhead: how about (type E = String)?
14:29:04 <cloudhead> ertes: well, I'd like it to be stricter than that
14:29:17 <cloudhead> I have a sum type right now
14:29:22 <ertes> again the Ord is useless, because you only have one value of that type
14:29:29 <ertes> you could only ever compare it to itself
14:30:03 <ertes> data E' = forall a. (Eq a, Ord a, Show a) => E a a
14:30:15 <ertes> here the context makes more sense, because there are two values
14:30:40 <cloudhead> hmm I think I understand
14:30:48 <ertes> but again it's little more than a pair of strings
14:31:15 <ertes> you can only observe strings and ordering about the type, because that's the only information you have
14:31:16 <cloudhead> originally I just had something like `data Foo = Foo { name :: forall a. Ord a => a, ... }`
14:31:20 <zyhn> what's the simplest way to write/read Storable things to/from files?
14:32:26 <cloudhead> ertes: I have a bunch of data types I want to use as keys in a map
14:32:36 <cloudhead> so I was thinking of just using their Ord instance
14:32:47 <cloudhead> that's what led me to existentials, but it's not working out
14:33:06 <cloudhead> so I'm wondering if it's my inexperience with them, or if it's just the wrong solution here
14:36:48 <cloudhead> though now that I think of it, it makes no sense
14:37:33 <hpc> the best kind of thinking about it!
14:38:05 <cloudhead> I know right
14:38:10 <cloudhead> it makes absolutely zero sense
14:38:22 <cloudhead> why would I try to mix key types in a single map
14:38:25 <hpc> the "hmm, i want existential types" problem is one of those really frustrating parts of designing a program
14:38:35 <hpc> because you almost always don't, but they look so tempting
14:38:43 <cloudhead> so true ^
14:38:57 <cloudhead> the number of times I've ripped them out of my code to find better solutions
14:39:01 <cloudhead> it's actually 100% of the times so far
14:39:32 <hexagoxel> now i wonder if `data E = forall a. (Typeable a, Ord a) => E a` makes sense
14:39:39 <cloudhead> it's this craving for a little of dynamic typing
14:40:01 <hexagoxel> Typeable is the first/only steps towards Dynamic :)
14:40:49 <cloudhead> yeah I'm trying to not reach out for that card
14:41:24 <hexagoxel> wait, is `data D = forall a. (Typeable a) => D a` isomorphic to Dynamic?
14:41:27 <ertes> cloudhead: existentials are often mistaken for a replacement for subtyping, but it isn't…  you should use a regular concrete "lowest common denominator" type
14:41:37 <cloudhead> it's this thing with haskell where you start to get greedy in terms of static type checking, but want increased flexibility at the same time
14:41:41 <cloudhead> and end up in dark corners
14:41:44 <ertes> cloudhead: which may very well be something like ByteString or Text
14:42:25 <ertes> cloudhead: or even a sum type that holds the individual types
14:42:39 <cloudhead> ertes: this ^ is what I'm leaning towards
14:42:43 <cloudhead> since it's all known at compile time
14:43:04 <cloudhead> I just wished it was not centralised in one type
14:43:24 <ertes> cloudhead: it isn't
14:43:35 <ertes> cloudhead: Either is associative and has Void as its identity
14:43:44 <cloudhead> well there's a central type holding all the other types?
14:43:48 <ertes> so you can use it as your "+", if you want
14:43:50 <hexagoxel> hmm no, you can't get from Dynamic to that existential
14:44:19 <ertes> Map (K1 + K2 + K3 + K4) A
14:44:26 <ertes> where (+) = Either
14:44:34 <cloudhead> oh
14:44:37 <cloudhead> hold on
14:44:41 <cloudhead> + is a type operator here?
14:44:50 <ertes> type (+) = Either
14:45:06 <cloudhead> didn't know Either could be used at the type level
14:45:17 <ertes> you did know that =)
14:45:17 <cloudhead> that's super interesting
14:45:30 <ertes> it's not anything special…  i'm just writing it infix
14:45:33 <cloudhead> heh yes sorry I mean in the way you're using it
14:45:38 <cloudhead> with types as the value of an Either
14:45:46 <cloudhead> oh
14:45:48 <ertes> Map (Either (Either (Either a b) c) d) A
14:46:13 <cloudhead> how could this be used in practice?
14:46:29 <ertes> the way i just wrote it =)
14:46:48 <ertes> it's the extensible version of the concrete sum type
14:46:57 <ertes> now you perhaps know why it's called a "sum type" =)
14:46:57 <hexagoxel> typical haskell interview question: what is the default associativity of type level operators? :)
14:47:10 <cloudhead> so like, accessing the map would be: `Map.lookup (Left (Left (Left x)))`
14:47:23 <ertes> yeah, exactly
14:47:39 <cloudhead> interesting
14:48:02 <ertes> you could make the type shallower though:  Either a b `Either` Either c d
14:48:07 <ertes> hmm
14:48:13 <cloudhead> indeed
14:48:15 <ertes> that's not even shallower in this case =)
14:48:23 <ertes> oh…  yes, it is
14:48:38 <Gurkenglas> Surely there's prisms for this so you don't need logarithmic constructors
14:48:40 <ertes> basically binary-tree it, then it gets reasonably shallow
14:48:51 <Gurkenglas> (As in, written in the code)
14:49:48 <ertes> cloudhead: (i'd go with the sum type in most cases)
14:50:01 <cloudhead> yeah I think so hmm
14:50:21 <cloudhead> I was looking at ways to use pattern synonyms for this purpose, but couldn't figure a way to make it work either
14:50:57 <ogkloo> hexagoxel: what *is* the associativity of type level operators?
14:51:31 <ertes> cloudhead: if the key types are all different, and you actually close the layers of Either with a Void, then you can use a lifting mechanism
14:51:40 <cloudhead> it's not that having a single type to hold all types is a big problem or anything, just felt like it could be better
14:52:11 <hexagoxel> cloudhead: maybe this would be a use-case for using DSum for your key type, from
14:52:17 <hexagoxel> @hackage dependent-sum
14:52:17 <lambdabot> http://hackage.haskell.org/package/dependent-sum
14:52:45 <cloudhead> ertes: heh I think I see where you're going there, but I think I'd be overcomplicating a relatively simple problem at this point
14:53:21 <ertes> cloudhead: most likely =)
14:54:02 <cloudhead> yeah, DSum looks like a similar solution
14:54:34 <hexagoxel> cloudhead: probably i am mistaken and sum type is the proper solution and DSum adds nothing for your use-case :/
14:55:01 <ertes> hexagoxel: unlikely…  it's just a regular sum problem…  dependent-sum is actually about tuples, where the type of the second component is chosen by type refinement on the first component
14:55:08 <ertes> lightweight dependent sums, basically
14:55:36 <hexagoxel> ertes: right. the "generalization of either" idea led me in a wrong direction.
14:56:22 * hexagoxel should not try so hard to find proper uses of DSum
14:56:28 <cloudhead> haha
14:56:40 <ertes> hexagoxel: dependent-map is a proper use case of dependent-sum =)
14:56:46 <ertes> and reflex is a proper use case of dependent-map =)
14:57:06 <ertes> acting on multiple event types without requiring them to be equal
15:10:16 <lynn> Heya. I just ran `cabal update && cabal install hlint` but when I try to run `hlint` my shell can't find it.
15:10:51 <lynn> Whereabouts should the executable be located? I'm on Ubuntu
15:12:00 <Tuplanolla> See `$HOME/.cabal/bin`, lynn.
15:12:09 <lynn> Oh, I found it! Yeah
15:12:18 <geekosaur> you need to add that to the front of $PATH yourself
15:12:25 <lynn> Thanks anyway n_n; will do
15:21:45 <buttbutter> Are there any good alternatives to Data.Matrix? It's so awkward to use, constantly converting between Vectors and Matrices.
15:23:08 <cloudhead> buttbutter: the linear package maybe?
15:25:01 <buttbutter> From brief inspection, seems quite literally to focus on the algebra parts of linear algebra instead of matrices for computation :P
15:25:25 <haasn> try repa
15:25:35 <buttbutter> Yeah...I figured that was going to be the reply.
15:25:41 <buttbutter> But that shit looks SO complicated ;_;
15:25:50 <buttbutter> But guess I have to learn at some point
15:26:33 <buttbutter> Maybe I'll just extend Data.Matrix a bit to work better for my purposes.
15:31:16 <Cale> buttbutter: hmatrix?
15:31:26 <Cale> https://hackage.haskell.org/package/hmatrix
15:31:32 <Tritlo> ertes: I decided to report it. Worst case is that I get an explanation.
15:31:39 <hodapp> hmatrix is decent, though docs are a little spotty
15:33:40 <buttbutter> Cale: Looks like a potential candidate! Thanks :D
16:05:34 <mnn_> If I include (deriving Eq) in my data type declaration and one of the variables contained has no instance of Eq, an error will be thrown at runtime right? (sorry if this question made it through earlier, had disconnect)
16:05:49 <mnn_> Relevant gist: https://gist.github.com/mtn/40630a16b49b554165510047b9828b8d
16:06:12 <geekosaur> mnn, will be thrown at compile time if used in a context requiring Eq
16:06:55 <geekosaur> it may not know the exact type at compile time, but it will know the Eq constraint is needed at compile time
16:07:04 <mnn_> Got it. Also, the relevant gist was actually for another question, my bad. I am wondering why the as-pattern fails as I've noted in the gist
16:07:34 <mnn_> The reason it'd be useful is to pattern match, but then allow us to not retype the full expression to the right of equality
16:09:20 <geekosaur> that syntax looks wrong, but, consider that it's not just the full expression but also the full type
16:09:34 <geekosaur> :t fmap
16:09:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:10:04 <geekosaur> it will not magically re-type an (f a) as (f b)
16:17:46 <nshepperd> in fmap :: (b -> c) -> Sum a b -> Sum a c, your 'x' is of type Sum a b. you can't use it as a Sum a c
16:18:08 <nshepperd> this is one of those times when you could 'safely' use unsafeCoerce... but you're better off just writing First a
16:29:59 <mnn> nshepperd, So does this have to do with type inference?
16:33:08 * hackagebot unfoldable 0.9.1 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9.1 (SjoerdVisscher)
16:36:16 <mniip> no
16:37:22 <mniip> aw
16:53:50 <lpaste> xcmw pasted “Bizarre error with GADT (See line 76)” at http://lpaste.net/349495
16:55:37 <geekosaur> xcmw, that doesn't do what you think
16:55:56 <geekosaur> in fact it is specifically *not* the `b` you had already defined; it is a new, local binding
16:56:08 <geekosaur> which matches anything
16:56:45 <xcmw> geekosaur: So b is not equal to X?
16:56:48 <geekosaur> nope
16:57:12 <xcmw> geekosaur: What part of b = X did GHC not understand?
16:57:14 <geekosaur> \case b -> ... -- `b` matches anything and creates a new binding, unrelated to any `b` in an outer scope
16:57:27 <xcmw> geekosaur: I see
16:58:08 <mniip> you need a pattern synonym
16:58:34 <geekosaur> (the scope here is the pattern + case expression + any guards attached to the pattern)
16:59:10 <mniip> or, hmm, can you write a GADT pattern synonym and have it still introduce constraints into the scope?
17:02:14 <xcmw> It works but it breaks -fwarn-incomplete-patterns
17:03:06 <xcmw> Anyway to have that still work? I used pattern B = X
17:04:15 <geekosaur> anything starting with lowercase is going to be taken as a pattern binding, and match anything
17:04:43 <xcmw> And I can't put it in a typeclass.
17:04:45 <geekosaur> if you want to check something not as a pattern, you need to use a guard
17:05:48 <geekosaur> but I'm not sure even that is what you want here. and I don't see why you want to do it that way
17:09:36 <xcmw> geekosaur: I was trying to be able to use sx instead of X in the constructor because I may end up with move the one GADT with an x property.
17:09:54 <geekosaur> you can't do it that way
17:10:05 <geekosaur> you would need to use a pattern guard
17:10:30 <geekosaur> ...or an ordinary guard with a match-anything pattern
17:11:34 <xcmw> geekosaur: I will try that
17:12:32 <Sinestro> Why isn't Aeson listening when I give `deriveJSON` an `Options` with `omitNothingFields = True`? It's still including/demanding nulls for `Nothing` values
17:16:53 <Sinestro> Oh, huh
17:17:08 <Sinestro> I don't know why I didn't realize that would happen
17:17:36 <Sinestro> Never mind, I wasn't thinking about the fact that it has no way to know that a generic type parameter is a Maybe 
17:20:21 <gfixler> Can overloaded strings work in the REPL?
17:21:04 <gfixler> I can write `main = expectingAnOverloadedString "whatever"` in my program, but can't write that RHS in the REPL
17:27:49 <glguy> gfixler: Yeah, they work fine; you just have to turn them on.
17:27:59 <gfixler> glguy: just found it
17:28:03 <gfixler> https://ghc.haskell.org/trac/ghc/ticket/5673
17:28:13 <gfixler> just gotta :set -XOverloadedStrings in GHCi
17:28:17 <gfixler> feeling relieved
17:29:22 <xcmw> geekosaur: It does not work. It is using the correct b.
17:29:42 <geekosaur> ?
17:29:49 <geekosaur> @lpaste show your work
17:29:50 <lambdabot> Haskell pastebin: http://lpaste.net/
17:30:36 <glguy> xcmw: Your use of newtyped functions for datatype is going to potentially lead to a lot of recomputed values
17:31:21 <geekosaur> oh, good. I' going to hit a wall pretty quickly trying to figure out what's actually trying to happen in there...
17:33:15 <xcmw> glguy: I though newtypes are optimized by the compiler?
17:33:31 <glguy> Nothing to do with the newtypes
17:33:44 <glguy> The problem is the functions
17:34:12 <xcmw> glguy: What is bad about them?
17:34:42 <glguy> They recompute their results each time you apply them to an argument
17:36:53 <xcmw> glguy: Is that worth worrying about? I don't really care about preformance. I'm compiling to javascript. I could not stand typescripts lack of operator overloading
17:37:28 <glguy> You'd have to decide if you care
17:38:28 <xcmw> glguy: Is it easy to fix?
17:39:20 <xcmw> geekosaur: http://lpaste.net/349496 (Line 76)
17:40:48 <glguy> You don't learn about types using == in guards
17:40:57 <geekosaur> ^
17:41:20 <geekosaur> but I'm still not entirely sure what you are trying to do here. (that is, it's over my head, sorry)
17:41:24 <glguy> There's where testEquality came in last time
17:43:03 <xcmw> glguy: Normall I would use \case see d2 but wanted to be able to use sx (see lpaste) in case there ended up being more than one GADT with an x field
17:43:38 <codedmart> If I want to log errors or messages in my servant app but have my app run as normal is adding LoggingT to my stack the way to go? For instance when a user requests to change their password. I send an email but if sending the email fails I don't want to affect the request response cycle, but I want to log that information.
17:44:06 <glguy> xcmw: OK, then perhaps you want to case testEquality sx j
17:45:28 <xcmw> glguy: Trying that now.
17:47:38 <xcmw> glguy: Can the be used in a guard or do I do that in a \case?
17:47:57 <glguy> You do it in a normal case
17:48:32 <glguy> It's possible you can do it with a pattern guard, I'm not actually sure if that desugars to the right thing
17:48:48 <glguy> | Just Refl <- testEquality sx j
17:52:20 <fragamus> Int -> (a -> a) -> a -> a
17:52:48 <xcmw> glguy: With a normal case I get a nested set of case staments
17:53:47 <fragamus> I need a function that applies a function to an argument repeatedly
17:55:06 <fragamus> iterateN gives a sequence but I just want one value; the last value after N iterations
17:55:27 <glguy> fragamus: I'm sure someone has one in a package on hackage, but otherwise you're better off writing it yourself
17:55:52 <xcmw> glguy: I can used the guard method to avoid nested case but then I lose -fwarn-incomplete-patterns
17:55:52 <glguy> You have to decide if you want strict application or not
17:56:46 <glguy> xcmw: If you're testing equality against arbitrary values like sx then your patterns will be incomplete for sure without some additional help
17:56:56 <glguy> There's nothing to say that sx is the only value of its type
17:58:20 <xcmw> glguy: I was hoping ghc would interpret sx as if I wrote X. I was wrong.
18:00:06 <xcmw> glguy: This is getting too complex. I have to think about it on my own for a little bit.
18:01:32 <glguy> making things complicated is kind of the point of all of this, isn't it?
18:03:02 <xcmw> glguy: Yeah but it takes me a little time to understand.
18:07:14 <xcmw> glguy: Will putting inline on the functions prevent the value from being recomputed?
18:09:55 <glguy> No, except in some trivial cases where the value itself can be completely inlined
18:12:21 <xcmw> glguy: What is being recomputed? Those functions will be run about 100 times during my application.
18:22:52 <unskilled> is there standard function which takes a predicate and a list and turn it into list of lists in such a way... ehm... better to show example. f is_even [0, 2, 1, 3, 2, 5] = [[0, 2], [1, 3], [2], [5]].
18:22:53 <dozerman> test
18:23:01 <unskilled> dozerman: failed
18:23:21 <dozerman> Sorry. Didn't realize I was already joined. I'll shut up now.
18:24:27 <unskilled> so it starts filling new list when predicate changes from true to false or vice versa
18:25:47 <unskilled> lets say: edge triggered
18:26:27 <xcmw> unskilled: Do any of these work? https://www.haskell.org/hoogle/?hoogle=%5Ba%5D+-%3E+%28a+-%3E+Bool%29+-%3E+%5B%5Ba%5D%5D
18:27:58 <Rotaerk> don't think so
18:28:48 <unskilled> xcmw: no
18:29:58 <xcmw> unskilled: https://www.stackage.org/haddock/lts-7.11/split-0.2.3.1/Data-List-Split.html#v:splitWhen
18:30:28 <xcmw> unskilled: Never mind
18:30:33 <Rotaerk> it's close
18:30:35 <unskilled> xcmw: yes, it removes
18:31:56 <MarcelineVQ> > (\f -> groupBy (\x y -> f x == f y)) even [0, 2, 1, 3, 2, 5]
18:31:58 <lambdabot>  [[0,2],[1,3],[2],[5]]
18:33:04 <unskilled> MarcelineVQ: 👍
18:33:06 <Rotaerk> clever
18:35:06 <unskilled> > (\f -> groupBy (\x y -> f x == f y)) even [1, 2, 1, 3, 2, 5]
18:35:09 <lambdabot>  [[1],[2],[1,3],[2],[5]]
18:35:58 <unskilled> And I want the head satisfy predicate. It might be an empty list.
18:37:16 <unskilled> Don't get me wrong, I'm not asking to write it, I was able to do it myself but just decided to ask to not reinwent the wheel.
18:37:18 <MarcelineVQ> I don't know what that means, group* are safe on empty lists though
18:37:45 <unskilled> MarcelineVQ: f even [1, 2, 1, 3, 2, 5] should be [[], [1],[2],[1,3],[2],[5]]
18:38:13 * hackagebot nonfree 0.1.0.2 - Free structures sans laws  https://hackage.haskell.org/package/nonfree-0.1.0.2 (ShachafBenKiki)
18:40:42 <unskilled> " I was able to do it myself" should be read " I was about to do it myself"
18:41:26 <MarcelineVQ> oh I see, I'll let you figure that one out though
18:42:48 <unskilled> MarcelineVQ: Do you have an elegant solution?
18:44:21 <MarcelineVQ> there's not much to it, if you have a list and you want to prepend to it you use :
18:44:26 <MarcelineVQ> > 1 : [2,3,4,5]
18:44:28 <lambdabot>  [1,2,3,4,5]
18:44:39 <MarcelineVQ> How might that look for a list of lists?
18:45:51 <unskilled> You offer to check the first element decide prepend or not.
18:48:11 <MarcelineVQ> Luckily you don't need to know what's in a list to tack something to the front of it
18:48:18 <MarcelineVQ> > undefined
18:48:20 <lambdabot>  *Exception: Prelude.undefined
18:48:33 <MarcelineVQ> > take 1 (1 : undefined)
18:48:36 <lambdabot>  [1]
18:48:46 <pikajude> > length [undefined]
18:48:49 <lambdabot>  1
18:52:20 <unskilled> May be you didn't understand. The head of result should consist of elements which satisfy the predicate. It might be empty. f even [0, 2, 1, 3, 2, 5] is [[1,2],[1,3],[2],[5]]; and f even [1, 2, 1, 3, 2, 5] should be [[],[1],[2],[1,3],[2],[5]]
18:52:46 <unskilled> I mean [[0,2],[1,3],[2],[5]], not [[1,2],[1,3],[2],[5]]
18:57:58 <MarcelineVQ> the yes I'd probably check the first element against the predicate and if it fails I'd append [] to the result of groupBy
18:58:13 * hackagebot haskakafka 1.2.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/haskakafka-1.2.0 (tdimson)
18:58:15 * hackagebot haskakafka 1.1.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/haskakafka-1.1.0 (tdimson)
18:58:37 <unskilled> MarcelineVQ: this is not an elegant solution for me :-)
19:00:36 <xcmw> Is it possible to put a pattern synonym in a type class? I don't think it is but I just want to make sure.
19:02:48 <fragamus> oh man I dipped my toe in clojure because i wanted om-next coolness and i just learned that they dont have tail recursion
19:08:45 <glguy> xcmw: Not directly, but you can build it out of class methods to acheive the same effect
19:09:53 <alexknvl> fragamus: Tail recursion on JVM is not possible without trampolines.
19:11:34 <alexknvl> Actually, let me correct myself. Tail recursion is ofc. possible (Scala does it), tail calls are not
19:12:40 <xcmw> glguy: How? You saw my earlier attempt and it was similar but not identical
19:15:58 <xcmw> glguy: Is there an overloaded record fields but for GADTs?
19:16:40 <glguy> I don’t know how overloaded record fields extension interacts with GADTs if at all, I don’t use it
19:16:52 <unskilled> MarcelineVQ: rate http://ideone.com/TpIknJ
19:17:51 <xcmw> glguy: Nevermind it does not exist
19:20:33 <MarcelineVQ> unskilled: very nice, should groupBy2 even [] result in a value of [] or [[]] ?
19:21:21 <unskilled> MarcelineVQ: good question
19:22:08 <lpaste> glguy pasted “for xcmw” at http://lpaste.net/349498
19:22:47 <unskilled> MarcelineVQ: I think [[]], so it should be groupBy2 _ [] = [[]]
19:23:10 <unskilled> Stop. No
19:23:55 <unskilled> Then it will break non-empty lists.
19:24:35 <unskilled> groupBy2 even [] = [] is perfectly fine
19:24:45 <xcmw> glguy: Ok. Thanks.
19:25:39 <MarcelineVQ> it won't break anything, [[]] is a list of lists, go with what makes sense to you though
19:26:07 <MarcelineVQ> oh maybe It will hehe, I forgot this does a swap thing
19:26:18 <MarcelineVQ> *span
19:27:14 <MarcelineVQ> anyway that's better than what I had in mind to try so good job
19:28:44 <unskilled> MarcelineVQ: inspired by groupBy from Data.List. It uses span in almost the same way. Ofc my function is a bit different because it (a -> Bool) -> [a] -> [[a]] and not (a -> a -> Bool) -> [a] -> [[a]]
19:29:32 <unskilled> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#groupBy
19:36:05 <unskilled> MarcelineVQ: groupBy2 even [] = [] is fine because it satisfy invariant that return list should always has even lenght.
19:37:11 <unskilled> *satisfy requirement
19:38:51 <MarcelineVQ> oh hmm, but yours doesn't satisfy that
19:39:13 <unskilled> MarcelineVQ: where?!
19:40:27 <MarcelineVQ> @let groupBy2 _ [] = []; groupBy2 p xs = ys : groupBy2 (not . p) zs where (ys, zs) = span p xs
19:40:29 <lambdabot>  Defined.
19:40:35 <MarcelineVQ> > length $ groupBy2 even [1,1,2,2,3,5,4,3,3,4,2,5,4]
19:40:37 <lambdabot>  9
19:40:42 <unskilled> hmmm
19:41:16 <xcmw> glguy: Amazing, except that it breaks -fwarn-incomplete-patterns
19:41:41 <unskilled> bullshit
19:42:04 <unskilled> then the last element should be an empty list!
19:45:04 <xcmw> glguy: There is a ticket. https://ghc.haskell.org/trac/ghc/ticket/8779
19:49:01 <unskilled> MarcelineVQ: I have no choice but use mutual recursion http://ideone.com/I3eGuD
19:49:18 <glguy> xcmw: In the case of type classes it's not even really a bug, though
19:50:53 <xcmw> glguy: The compiler knows that IntThing = GInt at compile time right?
19:51:07 <glguy> Not necessarily
19:51:31 <mnn> I'm a bit confused about the applicative instance of tuple ((,) a). How does pure work here?
19:51:59 <glguy> instance Monoid a => Applicative ((,) a) 
19:52:27 <glguy> It works because this isn't only works for types 'a' that have Monoid instances
19:52:36 <glguy> delete isn't*
19:52:50 <xcmw> glguy: Why not?
19:53:06 <mnn> glguy, Sorry, not really following
19:53:47 <mnn> I get that something like (Sum 2, (+7)) <*> (Sum 4, 7) = (Sum 6, 14) 
19:54:04 <glguy> For one, when matching on IntThing, GHC would have to look inside the definition of testEquality to see that the only thing that returns Just is GInt
19:54:23 <glguy> err, not testEquality in this case
19:54:24 <mnn> But how would I use the pure function for a tuple?
19:54:26 <glguy> but the match definition
19:54:32 <glguy> these things could be in another module even
19:54:57 <glguy> mnn: What do you mean "how"?
19:55:07 <glguy> > pure True :: (Sum Int, Bool)
19:55:08 <lambdabot>  (Sum {getSum = 0},True)
19:55:29 <mnn> glguy, Oh I see, thank you
20:04:52 <DavisMan> hello
20:05:02 <lambdabot> Hello.
20:05:46 <DavisMan> I want to know where to go to get my foot in the door to learning programming and game development, I am very triggered at the fact that I dont know where to start. I have searched and searched and decided to join this irc on haskell to ask for advice
20:07:18 <xcmw> glguy: You are right. GHC does not do any checking. :(
20:18:16 * hackagebot matrices 0.4.4 - native matrix based on vector  https://hackage.haskell.org/package/matrices-0.4.4 (kaizhang)
20:18:44 <ogkloo> DavisMan: Haskell might not be a great place to start at game development
20:23:16 * hackagebot HMarkov 1.0.1.0 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.1.0 (swizzard)
20:38:17 * hackagebot vty 5.14 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.14 (JonathanDaugherty)
20:43:17 * hackagebot brick 0.15 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.15 (JonathanDaugherty)
20:53:17 * hackagebot line 2.0.0.0 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-2.0.0.0 (noraesae)
21:10:04 <jlebar_> I have "system-ghc: true" in my ~/.stack/stack.yaml (and my project's stack.yaml), yet when I run "stack setup", it says "using sandboxed ghc".  When I run stack build, it does seem to be using the old GHC.
21:10:08 <jlebar_> How can I get it to use my system one?
21:10:20 <jlebar_> s/old GHC/sandboxed GHC/
21:17:19 <unskill> MarcelineVQ: tbh I don't really need that magic with empty lists before and after. All what I wanted is to apply different functions to continuous spans of elements  satisfying or not satisfying predicate.
21:17:37 <unskill> A function and example of usage http://ideone.com/O9QjhN 
21:18:22 <unskill> It reverses words in sentences keeping spaces and marks untouched
21:22:18 <MarcelineVQ> pretty neat, you're comes out extra silly which​ I like
21:24:15 <unskill> could you say it in simpler English, not sure if I got it right
21:26:28 <MarcelineVQ> I just like that the word you're becomes uoy'er
21:28:28 <unskill> Ah I see.
21:33:01 <MarcelineVQ> Just for comparison, I'd probably have tackled that one like    applyIf p f g =  concatMap (\xs -> if any p xs then f xs else g xs) . groupBy ((==)`on`p))    but I like yours more
21:34:14 <MarcelineVQ> *there's an uneccesary extra ) at the end ^
21:35:29 <unskill> I think mine will work for infinite lists, but yours wont
21:36:57 <ertes> is wl-pprint-text still the state of the art for formatted output?  i'd like to have colours, but still use Text rather than String
21:39:04 <ertes> ansi-wl-pprint will work, but it uses String =/
21:39:51 <unskill> (++) respects infinite second argumen whilst all concat[something] have forldr inside
21:41:16 <unskill> *foldr
21:41:20 <glguy> concat on infinite lists is fine, I think what MarcelineVQ's needs is to restrict the any p to only check the first
21:43:28 <glguy> applyIf p f g =  concatMap (\xs -> if p (head xs) then f xs else g xs) . groupBy ((==)`on`p)
21:46:29 <MarcelineVQ> thank you, I had forgotten head was safe there, and at the very least could have used take 1 xs before any
21:46:58 <glguy> unskill: foldl is the one to watch for with "infinite" lists
21:48:30 <unskill> glguy: kk, I've thought foldr fails for infinites.
21:49:12 <dash[m]> I find myself writing lambdas a lot when sorting / grouping that are all essentially like `groupBy (\a b -> f a == f b)` or `sortBy (\a b -> compare (f a) (f b)`
21:49:13 <dash[m]> Is there something in a library that does the whole (\a b -> g (f a) (f b)) thing so I don't have to keep writing it everywhere? It seems like a common thing to want to do
21:49:26 <jle`> there's one in 'base'
21:49:30 <jle`> called 'on'
21:49:45 <mnn> If I don't provide a type signature, why is pure ((+1) 1) == 2?
21:49:57 <mnn> I assume I'm thinking too much in terms of "lifting"
21:50:02 <jle`> hm
21:50:06 <jle`> do you mean in ghci?
21:50:27 <jle`> `pure ((+1) 1) == 2` should be a type error, alone
21:50:33 <MarcelineVQ> dash[m]: `on` as jle` said and I showed above, there's also `comparing` which is specific to your later example
21:50:33 <jle`> becuase there's no instance
21:50:46 <jle`> er, there's no way to pick the instance
21:50:48 <glguy> mnn: When you type: pure (1+1) in GHCi, it guesses you intended IO Integer
21:50:59 <dash[m]> thanks!
21:51:01 <jle`> mnn: but in ghci, it tries to interpret things as 'IO something' of possible
21:51:13 <jle`> so 'pure 4' is used as an IO Integer in ghci
21:51:17 <mnn> Oh I see. And the IO typeclass has no data constructors, right?
21:51:24 <jle`> IO is not a typeclass; it's a type
21:51:37 <mnn> Oh right lol
21:51:40 <jle`> 'pure 4' is an IO action that's a no-op and returns '4' as its result
21:51:51 <jle`> 'pure x' in general returns the no-op IO action
21:51:56 <jle`> where the result is just 'x'
21:52:08 <jle`> and yes, IO is implemented as an abstract data type in ghc/haskell
21:52:16 <jle`> like Map, Vector, etc.
21:52:31 <jle`> s/implemented/offered
21:52:37 <mnn> So they type of pure 4 is IO Int (or whatever it defaults to) and it is executed by ghci?
21:52:53 <jle`> yup, 'pure 2 :: IO Int' if you use it in ghci
21:52:56 <jle`> and it executes the IO action
21:53:02 <jle`> and returns the result -- which in this case is 2
21:53:07 <jle`> and then shows it :)
21:53:32 <mnn> Thanks jle` glguy !
21:56:38 <jle`> np!
21:58:18 <adarqui> anyone here who uses ghcjs, ever run into this error in console: uncaught exception in Haskell thread: ReferenceError: h$$KA7tAsSos9D374wZZX6w7v0ZCLNziUIziReactFluxziAppziThreadPostsziww137_XKcgdW is not defined
21:58:22 <adarqui> just curious
21:58:29 <adarqui> (not that exact error, but something similar)
22:03:56 <eklavya> byorgey: it looked like it but it wasn't a ghci problem at all, I removed an explicit "directory" package listing from extra-deps and intero works now
22:11:16 <latro`a> given a Data.Map, call it m, is there a way to efficiently write "f i = m ! (m.keys !! i)"?
22:11:23 <latro`a> er
22:11:24 <latro`a> brain
22:11:58 <latro`a> given a Data.Map, call it m, is there a way to efficiently write "f i = m ! (keys m !! i)"?
22:12:36 <jle`> latro`a: http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Strict.html#v:lookupIndex
22:12:48 <jle`> also http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Strict.html#v:elemAt
22:12:54 <jle`> for the unsafe version
22:13:13 <jle`> just the whole 'Indexed' section in general :)
22:13:18 <latro`a> is that only in Data.Map.Strict?
22:13:28 <jle`> where else do you need it for?
22:13:40 <latro`a> it doesn't matter, I was just curious because I haven't seen that block of documentation before
22:14:04 <latro`a> I'd want strictness anyway
22:14:06 <jle`> you can see all the documentation for modules here http://hackage.haskell.org/package/containers-0.5.8.1
22:14:22 <jle`> look at the type/module you want -- maybe it'll be there :)
22:14:46 <latro`a> I guess my meaning wasn't clear: mostly when I go to remind myself of how to use Data.Map, I find myself looking at Data.Map.Lazy. I didn't expect there to be additional functionality in Data.Map.Strict
22:14:52 <jle`> it seems to be a thing for lazy maps too -- http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Lazy.html#g:23
22:15:09 <latro`a> so it is
22:15:25 <jle`> if in doubt, you can just check the documentation for Data.Map.Lazy :)
22:15:55 <latro`a> appreciate it, I was expecting to need to do something homebrew or for it to just not work
23:04:55 <codygman> I'm trying to create a type synonym with template Haskell if that type synonym doesn't already exist, anyone know of tutorials with something similar or code that does something like that?
23:05:40 <pacak> codygman: To check if it exists - use reify, to create - just create
23:06:17 <codygman> pacak: Thanks. I don't want the answer but knowing that using reify is correct will help me quite a bit.
23:06:43 <pacak> :t reify
23:06:44 <lambdabot> error: Variable not in scope: reify
23:07:47 <pacak> codygman: I think there's enough info in template-haskell haddock. Feel free to ask more questions.
23:11:52 <codygman> pacak: Yeah, I'm trying to digest it all and don't yet have better questions. Will ask if I get some. Thank you.
23:15:37 <codygman> pacak: How can I create a TypeQ? I tried searching for a function that returned a TypeQ with Hayoo but didn't find one.
23:16:22 <codygman> Maybe I need to create a LitT representing say Int?
23:16:46 <pacak> codygman: TypeQ is an alias for Q Type.
23:16:58 <pacak> There are special quotations 'Foo and ''Foo.
23:17:14 <pacak> One of them looks for type, one for constructors. I don't remember which one is which though :)
23:18:40 <pacak> Lit is probably an ExprQ, you can create them with [| 12345 |]
23:36:09 <codygman> pacak: I can't figure out how to generate a DecsQ from a DecQ: https://github.com/codygman/th-upsert-typesynonym/blob/master/src/TH.hs#L14
23:40:12 <pacak> pure $ LitT (StrTyLit ("a" :: String))
23:40:18 <pacak> Try [| "a" |]
23:40:25 <pacak> Enable QuasiQuotation
23:41:10 <MarcelineVQ> iirc TemplateHaskell enables those basic quasiquoters, [d|  [t| and [e| / [|
23:41:28 <pacak> So DecsQ is Q [Dec]. DecQ is Q Dec.
23:41:46 <pacak> codygman: fmap is your friend.
23:42:10 <codygman> pacak: I was trying (:) <$> (myDecQ)
23:42:18 <pacak> :t (:)
23:42:19 <lambdabot> a -> [a] -> [a]
23:42:25 <pacak> :t (:[])
23:42:26 <lambdabot> a -> [a]
23:47:20 <codygman> pacak: Wouldn't "pure $ LitT (StrTyLit ("a" :: String))" be Q Type?
23:48:32 <pacak> codygman: Right.
23:48:35 <mari_mari> can someone help me who has access at thomson database?
23:48:56 <pacak> codygman: Again - you don't have to build AST yourself.
23:49:36 <codygman> pacak: right, I can make a ExpQ with [| "a" |]
23:50:50 <pacak> There are other quotations - for building types as well.
23:51:14 <codygman> pacak: Oh, is that what [t| |] is?
23:51:52 <pacak> [t| Int -> Bool |]
23:51:59 <pacak> This will give you TypeQ
23:54:41 <codygman> So would `tySynD (mkName "A") [] [t| String |]` give me `type A = String` then... I think?
23:55:00 <codygman> and are you saying I could even avoid building AST in the above case?
23:55:26 <pacak> Right. You can splice $ insideof [| |]
23:55:40 <codygman> which quasiquoter is "type" valid inside of?
23:55:41 <pacak> [| foo $( bar ) |]
23:56:00 <pacak> You probably want a declaration one
23:56:08 <pacak> [d| |]
23:57:09 <codygman> So, this seems to make a DecsQ: [d| type A = $([t| String |]) |]
23:57:29 <codygman> oh cool! that worked
23:58:04 <pacak> [d| type A = String |] will also work
23:58:22 <codygman> oh, cool
23:58:22 <pacak> But you'll need $ if you want to  change it
23:58:29 <pacak> or define with helpers
